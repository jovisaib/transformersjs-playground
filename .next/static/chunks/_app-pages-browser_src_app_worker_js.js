/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (function() { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "?c7c8":
/*!**********************************!*\
  !*** onnxruntime-node (ignored) ***!
  \**********************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

/* (ignored) */

/***/ }),

/***/ "?8373":
/*!********************!*\
  !*** fs (ignored) ***!
  \********************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

/* (ignored) */

/***/ }),

/***/ "?441f":
/*!**********************!*\
  !*** path (ignored) ***!
  \**********************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

/* (ignored) */

/***/ }),

/***/ "?1170":
/*!***********************!*\
  !*** sharp (ignored) ***!
  \***********************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

/* (ignored) */

/***/ }),

/***/ "?3951":
/*!****************************!*\
  !*** stream/web (ignored) ***!
  \****************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

/* (ignored) */

/***/ }),

/***/ "?85d5":
/*!********************!*\
  !*** fs (ignored) ***!
  \********************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

/* (ignored) */

/***/ }),

/***/ "?373b":
/*!**********************!*\
  !*** path (ignored) ***!
  \**********************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

/* (ignored) */

/***/ }),

/***/ "(app-pages-browser)/./node_modules/base64-js/index.js":
/*!*****************************************!*\
  !*** ./node_modules/base64-js/index.js ***!
  \*****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  var i\n  for (i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9iYXNlNjQtanMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosa0JBQWtCO0FBQ2xCLG1CQUFtQjtBQUNuQixxQkFBcUI7O0FBRXJCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1DQUFtQyxTQUFTO0FBQzVDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFNBQVM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQ0FBMkMsVUFBVTtBQUNyRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9iYXNlNjQtanMvaW5kZXguanM/YmMwOCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuZXhwb3J0cy5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuZXhwb3J0cy50b0J5dGVBcnJheSA9IHRvQnl0ZUFycmF5XG5leHBvcnRzLmZyb21CeXRlQXJyYXkgPSBmcm9tQnl0ZUFycmF5XG5cbnZhciBsb29rdXAgPSBbXVxudmFyIHJldkxvb2t1cCA9IFtdXG52YXIgQXJyID0gdHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnID8gVWludDhBcnJheSA6IEFycmF5XG5cbnZhciBjb2RlID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nXG5mb3IgKHZhciBpID0gMCwgbGVuID0gY29kZS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICBsb29rdXBbaV0gPSBjb2RlW2ldXG4gIHJldkxvb2t1cFtjb2RlLmNoYXJDb2RlQXQoaSldID0gaVxufVxuXG4vLyBTdXBwb3J0IGRlY29kaW5nIFVSTC1zYWZlIGJhc2U2NCBzdHJpbmdzLCBhcyBOb2RlLmpzIGRvZXMuXG4vLyBTZWU6IGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Jhc2U2NCNVUkxfYXBwbGljYXRpb25zXG5yZXZMb29rdXBbJy0nLmNoYXJDb2RlQXQoMCldID0gNjJcbnJldkxvb2t1cFsnXycuY2hhckNvZGVBdCgwKV0gPSA2M1xuXG5mdW5jdGlvbiBnZXRMZW5zIChiNjQpIHtcbiAgdmFyIGxlbiA9IGI2NC5sZW5ndGhcblxuICBpZiAobGVuICUgNCA+IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RyaW5nLiBMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDQnKVxuICB9XG5cbiAgLy8gVHJpbSBvZmYgZXh0cmEgYnl0ZXMgYWZ0ZXIgcGxhY2Vob2xkZXIgYnl0ZXMgYXJlIGZvdW5kXG4gIC8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2JlYXRnYW1taXQvYmFzZTY0LWpzL2lzc3Vlcy80MlxuICB2YXIgdmFsaWRMZW4gPSBiNjQuaW5kZXhPZignPScpXG4gIGlmICh2YWxpZExlbiA9PT0gLTEpIHZhbGlkTGVuID0gbGVuXG5cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IHZhbGlkTGVuID09PSBsZW5cbiAgICA/IDBcbiAgICA6IDQgLSAodmFsaWRMZW4gJSA0KVxuXG4gIHJldHVybiBbdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbl1cbn1cblxuLy8gYmFzZTY0IGlzIDQvMyArIHVwIHRvIHR3byBjaGFyYWN0ZXJzIG9mIHRoZSBvcmlnaW5hbCBkYXRhXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChiNjQpIHtcbiAgdmFyIGxlbnMgPSBnZXRMZW5zKGI2NClcbiAgdmFyIHZhbGlkTGVuID0gbGVuc1swXVxuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gbGVuc1sxXVxuICByZXR1cm4gKCh2YWxpZExlbiArIHBsYWNlSG9sZGVyc0xlbikgKiAzIC8gNCkgLSBwbGFjZUhvbGRlcnNMZW5cbn1cblxuZnVuY3Rpb24gX2J5dGVMZW5ndGggKGI2NCwgdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbikge1xuICByZXR1cm4gKCh2YWxpZExlbiArIHBsYWNlSG9sZGVyc0xlbikgKiAzIC8gNCkgLSBwbGFjZUhvbGRlcnNMZW5cbn1cblxuZnVuY3Rpb24gdG9CeXRlQXJyYXkgKGI2NCkge1xuICB2YXIgdG1wXG4gIHZhciBsZW5zID0gZ2V0TGVucyhiNjQpXG4gIHZhciB2YWxpZExlbiA9IGxlbnNbMF1cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IGxlbnNbMV1cblxuICB2YXIgYXJyID0gbmV3IEFycihfYnl0ZUxlbmd0aChiNjQsIHZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW4pKVxuXG4gIHZhciBjdXJCeXRlID0gMFxuXG4gIC8vIGlmIHRoZXJlIGFyZSBwbGFjZWhvbGRlcnMsIG9ubHkgZ2V0IHVwIHRvIHRoZSBsYXN0IGNvbXBsZXRlIDQgY2hhcnNcbiAgdmFyIGxlbiA9IHBsYWNlSG9sZGVyc0xlbiA+IDBcbiAgICA/IHZhbGlkTGVuIC0gNFxuICAgIDogdmFsaWRMZW5cblxuICB2YXIgaVxuICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTgpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCAxMikgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildIDw8IDYpIHxcbiAgICAgIHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMyldXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDE2KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gOCkgJiAweEZGXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICBpZiAocGxhY2VIb2xkZXJzTGVuID09PSAyKSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDIpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA+PiA0KVxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgaWYgKHBsYWNlSG9sZGVyc0xlbiA9PT0gMSkge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxMCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDQpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA+PiAyKVxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiA4KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBhcnJcbn1cblxuZnVuY3Rpb24gdHJpcGxldFRvQmFzZTY0IChudW0pIHtcbiAgcmV0dXJuIGxvb2t1cFtudW0gPj4gMTggJiAweDNGXSArXG4gICAgbG9va3VwW251bSA+PiAxMiAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtID4+IDYgJiAweDNGXSArXG4gICAgbG9va3VwW251bSAmIDB4M0ZdXG59XG5cbmZ1bmN0aW9uIGVuY29kZUNodW5rICh1aW50OCwgc3RhcnQsIGVuZCkge1xuICB2YXIgdG1wXG4gIHZhciBvdXRwdXQgPSBbXVxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkgKz0gMykge1xuICAgIHRtcCA9XG4gICAgICAoKHVpbnQ4W2ldIDw8IDE2KSAmIDB4RkYwMDAwKSArXG4gICAgICAoKHVpbnQ4W2kgKyAxXSA8PCA4KSAmIDB4RkYwMCkgK1xuICAgICAgKHVpbnQ4W2kgKyAyXSAmIDB4RkYpXG4gICAgb3V0cHV0LnB1c2godHJpcGxldFRvQmFzZTY0KHRtcCkpXG4gIH1cbiAgcmV0dXJuIG91dHB1dC5qb2luKCcnKVxufVxuXG5mdW5jdGlvbiBmcm9tQnl0ZUFycmF5ICh1aW50OCkge1xuICB2YXIgdG1wXG4gIHZhciBsZW4gPSB1aW50OC5sZW5ndGhcbiAgdmFyIGV4dHJhQnl0ZXMgPSBsZW4gJSAzIC8vIGlmIHdlIGhhdmUgMSBieXRlIGxlZnQsIHBhZCAyIGJ5dGVzXG4gIHZhciBwYXJ0cyA9IFtdXG4gIHZhciBtYXhDaHVua0xlbmd0aCA9IDE2MzgzIC8vIG11c3QgYmUgbXVsdGlwbGUgb2YgM1xuXG4gIC8vIGdvIHRocm91Z2ggdGhlIGFycmF5IGV2ZXJ5IHRocmVlIGJ5dGVzLCB3ZSdsbCBkZWFsIHdpdGggdHJhaWxpbmcgc3R1ZmYgbGF0ZXJcbiAgZm9yICh2YXIgaSA9IDAsIGxlbjIgPSBsZW4gLSBleHRyYUJ5dGVzOyBpIDwgbGVuMjsgaSArPSBtYXhDaHVua0xlbmd0aCkge1xuICAgIHBhcnRzLnB1c2goZW5jb2RlQ2h1bmsodWludDgsIGksIChpICsgbWF4Q2h1bmtMZW5ndGgpID4gbGVuMiA/IGxlbjIgOiAoaSArIG1heENodW5rTGVuZ3RoKSkpXG4gIH1cblxuICAvLyBwYWQgdGhlIGVuZCB3aXRoIHplcm9zLCBidXQgbWFrZSBzdXJlIHRvIG5vdCBmb3JnZXQgdGhlIGV4dHJhIGJ5dGVzXG4gIGlmIChleHRyYUJ5dGVzID09PSAxKSB7XG4gICAgdG1wID0gdWludDhbbGVuIC0gMV1cbiAgICBwYXJ0cy5wdXNoKFxuICAgICAgbG9va3VwW3RtcCA+PiAyXSArXG4gICAgICBsb29rdXBbKHRtcCA8PCA0KSAmIDB4M0ZdICtcbiAgICAgICc9PSdcbiAgICApXG4gIH0gZWxzZSBpZiAoZXh0cmFCeXRlcyA9PT0gMikge1xuICAgIHRtcCA9ICh1aW50OFtsZW4gLSAyXSA8PCA4KSArIHVpbnQ4W2xlbiAtIDFdXG4gICAgcGFydHMucHVzaChcbiAgICAgIGxvb2t1cFt0bXAgPj4gMTBdICtcbiAgICAgIGxvb2t1cFsodG1wID4+IDQpICYgMHgzRl0gK1xuICAgICAgbG9va3VwWyh0bXAgPDwgMikgJiAweDNGXSArXG4gICAgICAnPSdcbiAgICApXG4gIH1cblxuICByZXR1cm4gcGFydHMuam9pbignJylcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/base64-js/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/buffer/index.js":
/*!**************************************!*\
  !*** ./node_modules/buffer/index.js ***!
  \**************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n\n\nvar base64 = __webpack_require__(/*! base64-js */ \"(app-pages-browser)/./node_modules/base64-js/index.js\")\nvar ieee754 = __webpack_require__(/*! ieee754 */ \"(app-pages-browser)/./node_modules/ieee754/index.js\")\nvar customInspectSymbol =\n  (typeof Symbol === 'function' && typeof Symbol['for'] === 'function') // eslint-disable-line dot-notation\n    ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation\n    : null\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\nvar K_MAX_LENGTH = 0x7fffffff\nexports.kMaxLength = K_MAX_LENGTH\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Print warning and recommend using `buffer` v4.x which has an Object\n *               implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * We report that the browser does not support typed arrays if the are not subclassable\n * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`\n * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support\n * for __proto__ and has a buggy typed array implementation.\n */\nBuffer.TYPED_ARRAY_SUPPORT = typedArraySupport()\n\nif (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&\n    typeof console.error === 'function') {\n  console.error(\n    'This browser lacks typed array (Uint8Array) support which is required by ' +\n    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'\n  )\n}\n\nfunction typedArraySupport () {\n  // Can typed array instances can be augmented?\n  try {\n    var arr = new Uint8Array(1)\n    var proto = { foo: function () { return 42 } }\n    Object.setPrototypeOf(proto, Uint8Array.prototype)\n    Object.setPrototypeOf(arr, proto)\n    return arr.foo() === 42\n  } catch (e) {\n    return false\n  }\n}\n\nObject.defineProperty(Buffer.prototype, 'parent', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.buffer\n  }\n})\n\nObject.defineProperty(Buffer.prototype, 'offset', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.byteOffset\n  }\n})\n\nfunction createBuffer (length) {\n  if (length > K_MAX_LENGTH) {\n    throw new RangeError('The value \"' + length + '\" is invalid for option \"size\"')\n  }\n  // Return an augmented `Uint8Array` instance\n  var buf = new Uint8Array(length)\n  Object.setPrototypeOf(buf, Buffer.prototype)\n  return buf\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new TypeError(\n        'The \"string\" argument must be of type string. Received type number'\n      )\n    }\n    return allocUnsafe(arg)\n  }\n  return from(arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\nfunction from (value, encodingOrOffset, length) {\n  if (typeof value === 'string') {\n    return fromString(value, encodingOrOffset)\n  }\n\n  if (ArrayBuffer.isView(value)) {\n    return fromArrayView(value)\n  }\n\n  if (value == null) {\n    throw new TypeError(\n      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n      'or Array-like Object. Received type ' + (typeof value)\n    )\n  }\n\n  if (isInstance(value, ArrayBuffer) ||\n      (value && isInstance(value.buffer, ArrayBuffer))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof SharedArrayBuffer !== 'undefined' &&\n      (isInstance(value, SharedArrayBuffer) ||\n      (value && isInstance(value.buffer, SharedArrayBuffer)))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'number') {\n    throw new TypeError(\n      'The \"value\" argument must not be of type number. Received type number'\n    )\n  }\n\n  var valueOf = value.valueOf && value.valueOf()\n  if (valueOf != null && valueOf !== value) {\n    return Buffer.from(valueOf, encodingOrOffset, length)\n  }\n\n  var b = fromObject(value)\n  if (b) return b\n\n  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&\n      typeof value[Symbol.toPrimitive] === 'function') {\n    return Buffer.from(\n      value[Symbol.toPrimitive]('string'), encodingOrOffset, length\n    )\n  }\n\n  throw new TypeError(\n    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n    'or Array-like Object. Received type ' + (typeof value)\n  )\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(value, encodingOrOffset, length)\n}\n\n// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:\n// https://github.com/feross/buffer/pull/148\nObject.setPrototypeOf(Buffer.prototype, Uint8Array.prototype)\nObject.setPrototypeOf(Buffer, Uint8Array)\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be of type number')\n  } else if (size < 0) {\n    throw new RangeError('The value \"' + size + '\" is invalid for option \"size\"')\n  }\n}\n\nfunction alloc (size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpreted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(size).fill(fill, encoding)\n      : createBuffer(size).fill(fill)\n  }\n  return createBuffer(size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(size, fill, encoding)\n}\n\nfunction allocUnsafe (size) {\n  assertSize(size)\n  return createBuffer(size < 0 ? 0 : checked(size) | 0)\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(size)\n}\n\nfunction fromString (string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('Unknown encoding: ' + encoding)\n  }\n\n  var length = byteLength(string, encoding) | 0\n  var buf = createBuffer(length)\n\n  var actual = buf.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    buf = buf.slice(0, actual)\n  }\n\n  return buf\n}\n\nfunction fromArrayLike (array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\n  var buf = createBuffer(length)\n  for (var i = 0; i < length; i += 1) {\n    buf[i] = array[i] & 255\n  }\n  return buf\n}\n\nfunction fromArrayView (arrayView) {\n  if (isInstance(arrayView, Uint8Array)) {\n    var copy = new Uint8Array(arrayView)\n    return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength)\n  }\n  return fromArrayLike(arrayView)\n}\n\nfunction fromArrayBuffer (array, byteOffset, length) {\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\"offset\" is outside of buffer bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\"length\" is outside of buffer bounds')\n  }\n\n  var buf\n  if (byteOffset === undefined && length === undefined) {\n    buf = new Uint8Array(array)\n  } else if (length === undefined) {\n    buf = new Uint8Array(array, byteOffset)\n  } else {\n    buf = new Uint8Array(array, byteOffset, length)\n  }\n\n  // Return an augmented `Uint8Array` instance\n  Object.setPrototypeOf(buf, Buffer.prototype)\n\n  return buf\n}\n\nfunction fromObject (obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0\n    var buf = createBuffer(len)\n\n    if (buf.length === 0) {\n      return buf\n    }\n\n    obj.copy(buf, 0, 0, len)\n    return buf\n  }\n\n  if (obj.length !== undefined) {\n    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {\n      return createBuffer(0)\n    }\n    return fromArrayLike(obj)\n  }\n\n  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {\n    return fromArrayLike(obj.data)\n  }\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= K_MAX_LENGTH) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return b != null && b._isBuffer === true &&\n    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false\n}\n\nBuffer.compare = function compare (a, b) {\n  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)\n  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError(\n      'The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array'\n    )\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!Array.isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length)\n  var pos = 0\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i]\n    if (isInstance(buf, Uint8Array)) {\n      if (pos + buf.length > buffer.length) {\n        Buffer.from(buf).copy(buffer, pos)\n      } else {\n        Uint8Array.prototype.set.call(\n          buffer,\n          buf,\n          pos\n        )\n      }\n    } else if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    } else {\n      buf.copy(buffer, pos)\n    }\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    throw new TypeError(\n      'The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. ' +\n      'Received type ' + typeof string\n    )\n  }\n\n  var len = string.length\n  var mustMatch = (arguments.length > 2 && arguments[2] === true)\n  if (!mustMatch && len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) {\n          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8\n        }\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coercion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)\n// to detect a Buffer instance. It's not possible to use `instanceof Buffer`\n// reliably in a browserify context because there could be multiple different\n// copies of the 'buffer' package in use. This method works even for Buffer\n// instances that were created from another copy of the `buffer` package.\n// See: https://github.com/feross/buffer/issues/154\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  var i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  var len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.toLocaleString = Buffer.prototype.toString\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()\n  if (this.length > max) str += ' ... '\n  return '<Buffer ' + str + '>'\n}\nif (customInspectSymbol) {\n  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (isInstance(target, Uint8Array)) {\n    target = Buffer.from(target, target.offset, target.byteLength)\n  }\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError(\n      'The \"target\" argument must be one of type Buffer or Uint8Array. ' +\n      'Received type ' + (typeof target)\n    )\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart\n  var y = end - start\n  var len = Math.min(x, y)\n\n  var thisCopy = this.slice(thisStart, thisEnd)\n  var targetCopy = target.slice(start, end)\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset // Coerce to Number.\n  if (numberIsNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1\n  var arrLength = arr.length\n  var valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i\n  if (dir) {\n    var foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  var strLen = string.length\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (numberIsNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset >>> 0\n    if (isFinite(length)) {\n      length = length >>> 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return asciiWrite(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF)\n      ? 4\n      : (firstByte > 0xDF)\n          ? 3\n          : (firstByte > 0xBF)\n              ? 2\n              : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; ++i) {\n    out += hexSliceLookupTable[buf[i]]\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)\n  for (var i = 0; i < bytes.length - 1; i += 2) {\n    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf = this.subarray(start, end)\n  // Return an augmented `Uint8Array` instance\n  Object.setPrototypeOf(newBuf, Buffer.prototype)\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUintLE =\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUintBE =\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUint8 =\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUint16LE =\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUint16BE =\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUint32LE =\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUint32BE =\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUintLE =\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUintBE =\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUint8 =\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeUint16LE =\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeUint16BE =\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeUint32LE =\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset + 3] = (value >>> 24)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 1] = (value >>> 8)\n  this[offset] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeUint32BE =\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    var limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    var limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 3] = (value >>> 24)\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n\n  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {\n    // Use built-in when available, missing from IE11\n    this.copyWithin(targetStart, start, end)\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, end),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0)\n      if ((encoding === 'utf8' && code < 128) ||\n          encoding === 'latin1') {\n        // Fast path: If `val` fits into a single byte, use that numeric value.\n        val = code\n      }\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  } else if (typeof val === 'boolean') {\n    val = Number(val)\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  var i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val)\n      ? val\n      : Buffer.from(val, encoding)\n    var len = bytes.length\n    if (len === 0) {\n      throw new TypeError('The value \"' + val +\n        '\" is invalid for argument \"value\"')\n    }\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node takes equal signs as end of the Base64 encoding\n  str = str.split('=')[0]\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = str.trim().replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\n// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass\n// the `instanceof` check but they should be treated as of that type.\n// See: https://github.com/feross/buffer/issues/166\nfunction isInstance (obj, type) {\n  return obj instanceof type ||\n    (obj != null && obj.constructor != null && obj.constructor.name != null &&\n      obj.constructor.name === type.name)\n}\nfunction numberIsNaN (obj) {\n  // For IE11 support\n  return obj !== obj // eslint-disable-line no-self-compare\n}\n\n// Create lookup table for `toString('hex')`\n// See: https://github.com/feross/buffer/issues/219\nvar hexSliceLookupTable = (function () {\n  var alphabet = '0123456789abcdef'\n  var table = new Array(256)\n  for (var i = 0; i < 16; ++i) {\n    var i16 = i * 16\n    for (var j = 0; j < 16; ++j) {\n      table[i16 + j] = alphabet[i] + alphabet[j]\n    }\n  }\n  return table\n})()\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9idWZmZXIvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRVk7O0FBRVosYUFBYSxtQkFBTyxDQUFDLHdFQUFXO0FBQ2hDLGNBQWMsbUJBQU8sQ0FBQyxvRUFBUztBQUMvQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjO0FBQ2Qsa0JBQWtCO0FBQ2xCLHlCQUF5Qjs7QUFFekI7QUFDQSxrQkFBa0I7O0FBRWxCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixtQkFBbUI7QUFDckM7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsWUFBWTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsd0NBQXdDLFNBQVM7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGlCQUFpQjtBQUNqQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsaUJBQWlCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxFQUFFO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGVBQWU7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EseUJBQXlCLFFBQVE7QUFDakM7QUFDQSxzQkFBc0IsZUFBZTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixZQUFZO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0IsU0FBUztBQUMvQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLFNBQVM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCLFNBQVM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isc0JBQXNCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsaUJBQWlCO0FBQ2pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixZQUFZO0FBQzlCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0IsZ0JBQWdCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGdCQUFnQjtBQUNsQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IsWUFBWTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFFBQVE7QUFDMUI7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2J1ZmZlci9pbmRleC5qcz9mNDVhIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogVGhlIGJ1ZmZlciBtb2R1bGUgZnJvbSBub2RlLmpzLCBmb3IgdGhlIGJyb3dzZXIuXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGh0dHBzOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cblxuJ3VzZSBzdHJpY3QnXG5cbnZhciBiYXNlNjQgPSByZXF1aXJlKCdiYXNlNjQtanMnKVxudmFyIGllZWU3NTQgPSByZXF1aXJlKCdpZWVlNzU0JylcbnZhciBjdXN0b21JbnNwZWN0U3ltYm9sID1cbiAgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIFN5bWJvbFsnZm9yJ10gPT09ICdmdW5jdGlvbicpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZG90LW5vdGF0aW9uXG4gICAgPyBTeW1ib2xbJ2ZvciddKCdub2RlanMudXRpbC5pbnNwZWN0LmN1c3RvbScpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZG90LW5vdGF0aW9uXG4gICAgOiBudWxsXG5cbmV4cG9ydHMuQnVmZmVyID0gQnVmZmVyXG5leHBvcnRzLlNsb3dCdWZmZXIgPSBTbG93QnVmZmVyXG5leHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTID0gNTBcblxudmFyIEtfTUFYX0xFTkdUSCA9IDB4N2ZmZmZmZmZcbmV4cG9ydHMua01heExlbmd0aCA9IEtfTUFYX0xFTkdUSFxuXG4vKipcbiAqIElmIGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGA6XG4gKiAgID09PSB0cnVlICAgIFVzZSBVaW50OEFycmF5IGltcGxlbWVudGF0aW9uIChmYXN0ZXN0KVxuICogICA9PT0gZmFsc2UgICBQcmludCB3YXJuaW5nIGFuZCByZWNvbW1lbmQgdXNpbmcgYGJ1ZmZlcmAgdjQueCB3aGljaCBoYXMgYW4gT2JqZWN0XG4gKiAgICAgICAgICAgICAgIGltcGxlbWVudGF0aW9uIChtb3N0IGNvbXBhdGlibGUsIGV2ZW4gSUU2KVxuICpcbiAqIEJyb3dzZXJzIHRoYXQgc3VwcG9ydCB0eXBlZCBhcnJheXMgYXJlIElFIDEwKywgRmlyZWZveCA0KywgQ2hyb21lIDcrLCBTYWZhcmkgNS4xKyxcbiAqIE9wZXJhIDExLjYrLCBpT1MgNC4yKy5cbiAqXG4gKiBXZSByZXBvcnQgdGhhdCB0aGUgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBpZiB0aGUgYXJlIG5vdCBzdWJjbGFzc2FibGVcbiAqIHVzaW5nIF9fcHJvdG9fXy4gRmlyZWZveCA0LTI5IGxhY2tzIHN1cHBvcnQgZm9yIGFkZGluZyBuZXcgcHJvcGVydGllcyB0byBgVWludDhBcnJheWBcbiAqIChTZWU6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY5NTQzOCkuIElFIDEwIGxhY2tzIHN1cHBvcnRcbiAqIGZvciBfX3Byb3RvX18gYW5kIGhhcyBhIGJ1Z2d5IHR5cGVkIGFycmF5IGltcGxlbWVudGF0aW9uLlxuICovXG5CdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCA9IHR5cGVkQXJyYXlTdXBwb3J0KClcblxuaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJiB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICB0eXBlb2YgY29uc29sZS5lcnJvciA9PT0gJ2Z1bmN0aW9uJykge1xuICBjb25zb2xlLmVycm9yKFxuICAgICdUaGlzIGJyb3dzZXIgbGFja3MgdHlwZWQgYXJyYXkgKFVpbnQ4QXJyYXkpIHN1cHBvcnQgd2hpY2ggaXMgcmVxdWlyZWQgYnkgJyArXG4gICAgJ2BidWZmZXJgIHY1LnguIFVzZSBgYnVmZmVyYCB2NC54IGlmIHlvdSByZXF1aXJlIG9sZCBicm93c2VyIHN1cHBvcnQuJ1xuICApXG59XG5cbmZ1bmN0aW9uIHR5cGVkQXJyYXlTdXBwb3J0ICgpIHtcbiAgLy8gQ2FuIHR5cGVkIGFycmF5IGluc3RhbmNlcyBjYW4gYmUgYXVnbWVudGVkP1xuICB0cnkge1xuICAgIHZhciBhcnIgPSBuZXcgVWludDhBcnJheSgxKVxuICAgIHZhciBwcm90byA9IHsgZm9vOiBmdW5jdGlvbiAoKSB7IHJldHVybiA0MiB9IH1cbiAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YocHJvdG8sIFVpbnQ4QXJyYXkucHJvdG90eXBlKVxuICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihhcnIsIHByb3RvKVxuICAgIHJldHVybiBhcnIuZm9vKCkgPT09IDQyXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLnByb3RvdHlwZSwgJ3BhcmVudCcsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGhpcykpIHJldHVybiB1bmRlZmluZWRcbiAgICByZXR1cm4gdGhpcy5idWZmZXJcbiAgfVxufSlcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlci5wcm90b3R5cGUsICdvZmZzZXQnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKHRoaXMpKSByZXR1cm4gdW5kZWZpbmVkXG4gICAgcmV0dXJuIHRoaXMuYnl0ZU9mZnNldFxuICB9XG59KVxuXG5mdW5jdGlvbiBjcmVhdGVCdWZmZXIgKGxlbmd0aCkge1xuICBpZiAobGVuZ3RoID4gS19NQVhfTEVOR1RIKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBcIicgKyBsZW5ndGggKyAnXCIgaXMgaW52YWxpZCBmb3Igb3B0aW9uIFwic2l6ZVwiJylcbiAgfVxuICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZVxuICB2YXIgYnVmID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKVxuICBPYmplY3Quc2V0UHJvdG90eXBlT2YoYnVmLCBCdWZmZXIucHJvdG90eXBlKVxuICByZXR1cm4gYnVmXG59XG5cbi8qKlxuICogVGhlIEJ1ZmZlciBjb25zdHJ1Y3RvciByZXR1cm5zIGluc3RhbmNlcyBvZiBgVWludDhBcnJheWAgdGhhdCBoYXZlIHRoZWlyXG4gKiBwcm90b3R5cGUgY2hhbmdlZCB0byBgQnVmZmVyLnByb3RvdHlwZWAuIEZ1cnRoZXJtb3JlLCBgQnVmZmVyYCBpcyBhIHN1YmNsYXNzIG9mXG4gKiBgVWludDhBcnJheWAsIHNvIHRoZSByZXR1cm5lZCBpbnN0YW5jZXMgd2lsbCBoYXZlIGFsbCB0aGUgbm9kZSBgQnVmZmVyYCBtZXRob2RzXG4gKiBhbmQgdGhlIGBVaW50OEFycmF5YCBtZXRob2RzLiBTcXVhcmUgYnJhY2tldCBub3RhdGlvbiB3b3JrcyBhcyBleHBlY3RlZCAtLSBpdFxuICogcmV0dXJucyBhIHNpbmdsZSBvY3RldC5cbiAqXG4gKiBUaGUgYFVpbnQ4QXJyYXlgIHByb3RvdHlwZSByZW1haW5zIHVubW9kaWZpZWQuXG4gKi9cblxuZnVuY3Rpb24gQnVmZmVyIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICAvLyBDb21tb24gY2FzZS5cbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZ09yT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgJ1RoZSBcInN0cmluZ1wiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBzdHJpbmcuIFJlY2VpdmVkIHR5cGUgbnVtYmVyJ1xuICAgICAgKVxuICAgIH1cbiAgICByZXR1cm4gYWxsb2NVbnNhZmUoYXJnKVxuICB9XG4gIHJldHVybiBmcm9tKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG5CdWZmZXIucG9vbFNpemUgPSA4MTkyIC8vIG5vdCB1c2VkIGJ5IHRoaXMgaW1wbGVtZW50YXRpb25cblxuZnVuY3Rpb24gZnJvbSAodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBmcm9tU3RyaW5nKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0KVxuICB9XG5cbiAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5Vmlldyh2YWx1ZSlcbiAgfVxuXG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdUaGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCAnICtcbiAgICAgICdvciBBcnJheS1saWtlIE9iamVjdC4gUmVjZWl2ZWQgdHlwZSAnICsgKHR5cGVvZiB2YWx1ZSlcbiAgICApXG4gIH1cblxuICBpZiAoaXNJbnN0YW5jZSh2YWx1ZSwgQXJyYXlCdWZmZXIpIHx8XG4gICAgICAodmFsdWUgJiYgaXNJbnN0YW5jZSh2YWx1ZS5idWZmZXIsIEFycmF5QnVmZmVyKSkpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5QnVmZmVyKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBpZiAodHlwZW9mIFNoYXJlZEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgKGlzSW5zdGFuY2UodmFsdWUsIFNoYXJlZEFycmF5QnVmZmVyKSB8fFxuICAgICAgKHZhbHVlICYmIGlzSW5zdGFuY2UodmFsdWUuYnVmZmVyLCBTaGFyZWRBcnJheUJ1ZmZlcikpKSkge1xuICAgIHJldHVybiBmcm9tQXJyYXlCdWZmZXIodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdUaGUgXCJ2YWx1ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIG9mIHR5cGUgbnVtYmVyLiBSZWNlaXZlZCB0eXBlIG51bWJlcidcbiAgICApXG4gIH1cblxuICB2YXIgdmFsdWVPZiA9IHZhbHVlLnZhbHVlT2YgJiYgdmFsdWUudmFsdWVPZigpXG4gIGlmICh2YWx1ZU9mICE9IG51bGwgJiYgdmFsdWVPZiAhPT0gdmFsdWUpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20odmFsdWVPZiwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgdmFyIGIgPSBmcm9tT2JqZWN0KHZhbHVlKVxuICBpZiAoYikgcmV0dXJuIGJcblxuICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvUHJpbWl0aXZlICE9IG51bGwgJiZcbiAgICAgIHR5cGVvZiB2YWx1ZVtTeW1ib2wudG9QcmltaXRpdmVdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKFxuICAgICAgdmFsdWVbU3ltYm9sLnRvUHJpbWl0aXZlXSgnc3RyaW5nJyksIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aFxuICAgIClcbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgJ1RoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIHN0cmluZywgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQXJyYXksICcgK1xuICAgICdvciBBcnJheS1saWtlIE9iamVjdC4gUmVjZWl2ZWQgdHlwZSAnICsgKHR5cGVvZiB2YWx1ZSlcbiAgKVxufVxuXG4vKipcbiAqIEZ1bmN0aW9uYWxseSBlcXVpdmFsZW50IHRvIEJ1ZmZlcihhcmcsIGVuY29kaW5nKSBidXQgdGhyb3dzIGEgVHlwZUVycm9yXG4gKiBpZiB2YWx1ZSBpcyBhIG51bWJlci5cbiAqIEJ1ZmZlci5mcm9tKHN0clssIGVuY29kaW5nXSlcbiAqIEJ1ZmZlci5mcm9tKGFycmF5KVxuICogQnVmZmVyLmZyb20oYnVmZmVyKVxuICogQnVmZmVyLmZyb20oYXJyYXlCdWZmZXJbLCBieXRlT2Zmc2V0WywgbGVuZ3RoXV0pXG4gKiovXG5CdWZmZXIuZnJvbSA9IGZ1bmN0aW9uICh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBmcm9tKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbi8vIE5vdGU6IENoYW5nZSBwcm90b3R5cGUgKmFmdGVyKiBCdWZmZXIuZnJvbSBpcyBkZWZpbmVkIHRvIHdvcmthcm91bmQgQ2hyb21lIGJ1Zzpcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL3B1bGwvMTQ4XG5PYmplY3Quc2V0UHJvdG90eXBlT2YoQnVmZmVyLnByb3RvdHlwZSwgVWludDhBcnJheS5wcm90b3R5cGUpXG5PYmplY3Quc2V0UHJvdG90eXBlT2YoQnVmZmVyLCBVaW50OEFycmF5KVxuXG5mdW5jdGlvbiBhc3NlcnRTaXplIChzaXplKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgbnVtYmVyJylcbiAgfSBlbHNlIGlmIChzaXplIDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgXCInICsgc2l6ZSArICdcIiBpcyBpbnZhbGlkIGZvciBvcHRpb24gXCJzaXplXCInKVxuICB9XG59XG5cbmZ1bmN0aW9uIGFsbG9jIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIGlmIChzaXplIDw9IDApIHtcbiAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHNpemUpXG4gIH1cbiAgaWYgKGZpbGwgIT09IHVuZGVmaW5lZCkge1xuICAgIC8vIE9ubHkgcGF5IGF0dGVudGlvbiB0byBlbmNvZGluZyBpZiBpdCdzIGEgc3RyaW5nLiBUaGlzXG4gICAgLy8gcHJldmVudHMgYWNjaWRlbnRhbGx5IHNlbmRpbmcgaW4gYSBudW1iZXIgdGhhdCB3b3VsZFxuICAgIC8vIGJlIGludGVycHJldGVkIGFzIGEgc3RhcnQgb2Zmc2V0LlxuICAgIHJldHVybiB0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnXG4gICAgICA/IGNyZWF0ZUJ1ZmZlcihzaXplKS5maWxsKGZpbGwsIGVuY29kaW5nKVxuICAgICAgOiBjcmVhdGVCdWZmZXIoc2l6ZSkuZmlsbChmaWxsKVxuICB9XG4gIHJldHVybiBjcmVhdGVCdWZmZXIoc2l6ZSlcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiBhbGxvYyhzaXplWywgZmlsbFssIGVuY29kaW5nXV0pXG4gKiovXG5CdWZmZXIuYWxsb2MgPSBmdW5jdGlvbiAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGFsbG9jKHNpemUsIGZpbGwsIGVuY29kaW5nKVxufVxuXG5mdW5jdGlvbiBhbGxvY1Vuc2FmZSAoc2l6ZSkge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIHJldHVybiBjcmVhdGVCdWZmZXIoc2l6ZSA8IDAgPyAwIDogY2hlY2tlZChzaXplKSB8IDApXG59XG5cbi8qKlxuICogRXF1aXZhbGVudCB0byBCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqICovXG5CdWZmZXIuYWxsb2NVbnNhZmUgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUoc2l6ZSlcbn1cbi8qKlxuICogRXF1aXZhbGVudCB0byBTbG93QnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUoc2l6ZSlcbn1cblxuZnVuY3Rpb24gZnJvbVN0cmluZyAoc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJyB8fCBlbmNvZGluZyA9PT0gJycpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICB9XG5cbiAgaWYgKCFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gIH1cblxuICB2YXIgbGVuZ3RoID0gYnl0ZUxlbmd0aChzdHJpbmcsIGVuY29kaW5nKSB8IDBcbiAgdmFyIGJ1ZiA9IGNyZWF0ZUJ1ZmZlcihsZW5ndGgpXG5cbiAgdmFyIGFjdHVhbCA9IGJ1Zi53cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuXG4gIGlmIChhY3R1YWwgIT09IGxlbmd0aCkge1xuICAgIC8vIFdyaXRpbmcgYSBoZXggc3RyaW5nLCBmb3IgZXhhbXBsZSwgdGhhdCBjb250YWlucyBpbnZhbGlkIGNoYXJhY3RlcnMgd2lsbFxuICAgIC8vIGNhdXNlIGV2ZXJ5dGhpbmcgYWZ0ZXIgdGhlIGZpcnN0IGludmFsaWQgY2hhcmFjdGVyIHRvIGJlIGlnbm9yZWQuIChlLmcuXG4gICAgLy8gJ2FieHhjZCcgd2lsbCBiZSB0cmVhdGVkIGFzICdhYicpXG4gICAgYnVmID0gYnVmLnNsaWNlKDAsIGFjdHVhbClcbiAgfVxuXG4gIHJldHVybiBidWZcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5TGlrZSAoYXJyYXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCA8IDAgPyAwIDogY2hlY2tlZChhcnJheS5sZW5ndGgpIHwgMFxuICB2YXIgYnVmID0gY3JlYXRlQnVmZmVyKGxlbmd0aClcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgIGJ1ZltpXSA9IGFycmF5W2ldICYgMjU1XG4gIH1cbiAgcmV0dXJuIGJ1ZlxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlWaWV3IChhcnJheVZpZXcpIHtcbiAgaWYgKGlzSW5zdGFuY2UoYXJyYXlWaWV3LCBVaW50OEFycmF5KSkge1xuICAgIHZhciBjb3B5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlWaWV3KVxuICAgIHJldHVybiBmcm9tQXJyYXlCdWZmZXIoY29weS5idWZmZXIsIGNvcHkuYnl0ZU9mZnNldCwgY29weS5ieXRlTGVuZ3RoKVxuICB9XG4gIHJldHVybiBmcm9tQXJyYXlMaWtlKGFycmF5Vmlldylcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5QnVmZmVyIChhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmIChieXRlT2Zmc2V0IDwgMCB8fCBhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcIm9mZnNldFwiIGlzIG91dHNpZGUgb2YgYnVmZmVyIGJvdW5kcycpXG4gIH1cblxuICBpZiAoYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQgKyAobGVuZ3RoIHx8IDApKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1wibGVuZ3RoXCIgaXMgb3V0c2lkZSBvZiBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIHZhciBidWZcbiAgaWYgKGJ5dGVPZmZzZXQgPT09IHVuZGVmaW5lZCAmJiBsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGFycmF5KVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYnVmID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQpXG4gIH0gZWxzZSB7XG4gICAgYnVmID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlXG4gIE9iamVjdC5zZXRQcm90b3R5cGVPZihidWYsIEJ1ZmZlci5wcm90b3R5cGUpXG5cbiAgcmV0dXJuIGJ1ZlxufVxuXG5mdW5jdGlvbiBmcm9tT2JqZWN0IChvYmopIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihvYmopKSB7XG4gICAgdmFyIGxlbiA9IGNoZWNrZWQob2JqLmxlbmd0aCkgfCAwXG4gICAgdmFyIGJ1ZiA9IGNyZWF0ZUJ1ZmZlcihsZW4pXG5cbiAgICBpZiAoYnVmLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGJ1ZlxuICAgIH1cblxuICAgIG9iai5jb3B5KGJ1ZiwgMCwgMCwgbGVuKVxuICAgIHJldHVybiBidWZcbiAgfVxuXG4gIGlmIChvYmoubGVuZ3RoICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAodHlwZW9mIG9iai5sZW5ndGggIT09ICdudW1iZXInIHx8IG51bWJlcklzTmFOKG9iai5sZW5ndGgpKSB7XG4gICAgICByZXR1cm4gY3JlYXRlQnVmZmVyKDApXG4gICAgfVxuICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKG9iailcbiAgfVxuXG4gIGlmIChvYmoudHlwZSA9PT0gJ0J1ZmZlcicgJiYgQXJyYXkuaXNBcnJheShvYmouZGF0YSkpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5TGlrZShvYmouZGF0YSlcbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja2VkIChsZW5ndGgpIHtcbiAgLy8gTm90ZTogY2Fubm90IHVzZSBgbGVuZ3RoIDwgS19NQVhfTEVOR1RIYCBoZXJlIGJlY2F1c2UgdGhhdCBmYWlscyB3aGVuXG4gIC8vIGxlbmd0aCBpcyBOYU4gKHdoaWNoIGlzIG90aGVyd2lzZSBjb2VyY2VkIHRvIHplcm8uKVxuICBpZiAobGVuZ3RoID49IEtfTUFYX0xFTkdUSCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIGFsbG9jYXRlIEJ1ZmZlciBsYXJnZXIgdGhhbiBtYXhpbXVtICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICdzaXplOiAweCcgKyBLX01BWF9MRU5HVEgudG9TdHJpbmcoMTYpICsgJyBieXRlcycpXG4gIH1cbiAgcmV0dXJuIGxlbmd0aCB8IDBcbn1cblxuZnVuY3Rpb24gU2xvd0J1ZmZlciAobGVuZ3RoKSB7XG4gIGlmICgrbGVuZ3RoICE9IGxlbmd0aCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVxZXFlcVxuICAgIGxlbmd0aCA9IDBcbiAgfVxuICByZXR1cm4gQnVmZmVyLmFsbG9jKCtsZW5ndGgpXG59XG5cbkJ1ZmZlci5pc0J1ZmZlciA9IGZ1bmN0aW9uIGlzQnVmZmVyIChiKSB7XG4gIHJldHVybiBiICE9IG51bGwgJiYgYi5faXNCdWZmZXIgPT09IHRydWUgJiZcbiAgICBiICE9PSBCdWZmZXIucHJvdG90eXBlIC8vIHNvIEJ1ZmZlci5pc0J1ZmZlcihCdWZmZXIucHJvdG90eXBlKSB3aWxsIGJlIGZhbHNlXG59XG5cbkJ1ZmZlci5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAoYSwgYikge1xuICBpZiAoaXNJbnN0YW5jZShhLCBVaW50OEFycmF5KSkgYSA9IEJ1ZmZlci5mcm9tKGEsIGEub2Zmc2V0LCBhLmJ5dGVMZW5ndGgpXG4gIGlmIChpc0luc3RhbmNlKGIsIFVpbnQ4QXJyYXkpKSBiID0gQnVmZmVyLmZyb20oYiwgYi5vZmZzZXQsIGIuYnl0ZUxlbmd0aClcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYSkgfHwgIUJ1ZmZlci5pc0J1ZmZlcihiKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIFwiYnVmMVwiLCBcImJ1ZjJcIiBhcmd1bWVudHMgbXVzdCBiZSBvbmUgb2YgdHlwZSBCdWZmZXIgb3IgVWludDhBcnJheSdcbiAgICApXG4gIH1cblxuICBpZiAoYSA9PT0gYikgcmV0dXJuIDBcblxuICB2YXIgeCA9IGEubGVuZ3RoXG4gIHZhciB5ID0gYi5sZW5ndGhcblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gTWF0aC5taW4oeCwgeSk7IGkgPCBsZW47ICsraSkge1xuICAgIGlmIChhW2ldICE9PSBiW2ldKSB7XG4gICAgICB4ID0gYVtpXVxuICAgICAgeSA9IGJbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG5CdWZmZXIuaXNFbmNvZGluZyA9IGZ1bmN0aW9uIGlzRW5jb2RpbmcgKGVuY29kaW5nKSB7XG4gIHN3aXRjaCAoU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgY2FzZSAnYXNjaWknOlxuICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5CdWZmZXIuY29uY2F0ID0gZnVuY3Rpb24gY29uY2F0IChsaXN0LCBsZW5ndGgpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGxpc3QpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgfVxuXG4gIGlmIChsaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBCdWZmZXIuYWxsb2MoMClcbiAgfVxuXG4gIHZhciBpXG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGxlbmd0aCA9IDBcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgICAgbGVuZ3RoICs9IGxpc3RbaV0ubGVuZ3RoXG4gICAgfVxuICB9XG5cbiAgdmFyIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShsZW5ndGgpXG4gIHZhciBwb3MgPSAwXG4gIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGJ1ZiA9IGxpc3RbaV1cbiAgICBpZiAoaXNJbnN0YW5jZShidWYsIFVpbnQ4QXJyYXkpKSB7XG4gICAgICBpZiAocG9zICsgYnVmLmxlbmd0aCA+IGJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgICAgQnVmZmVyLmZyb20oYnVmKS5jb3B5KGJ1ZmZlciwgcG9zKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgVWludDhBcnJheS5wcm90b3R5cGUuc2V0LmNhbGwoXG4gICAgICAgICAgYnVmZmVyLFxuICAgICAgICAgIGJ1ZixcbiAgICAgICAgICBwb3NcbiAgICAgICAgKVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICAgIH0gZWxzZSB7XG4gICAgICBidWYuY29weShidWZmZXIsIHBvcylcbiAgICB9XG4gICAgcG9zICs9IGJ1Zi5sZW5ndGhcbiAgfVxuICByZXR1cm4gYnVmZmVyXG59XG5cbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihzdHJpbmcpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5sZW5ndGhcbiAgfVxuICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KHN0cmluZykgfHwgaXNJbnN0YW5jZShzdHJpbmcsIEFycmF5QnVmZmVyKSkge1xuICAgIHJldHVybiBzdHJpbmcuYnl0ZUxlbmd0aFxuICB9XG4gIGlmICh0eXBlb2Ygc3RyaW5nICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIFwic3RyaW5nXCIgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgb3IgQXJyYXlCdWZmZXIuICcgK1xuICAgICAgJ1JlY2VpdmVkIHR5cGUgJyArIHR5cGVvZiBzdHJpbmdcbiAgICApXG4gIH1cblxuICB2YXIgbGVuID0gc3RyaW5nLmxlbmd0aFxuICB2YXIgbXVzdE1hdGNoID0gKGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSA9PT0gdHJ1ZSlcbiAgaWYgKCFtdXN0TWF0Y2ggJiYgbGVuID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIFVzZSBhIGZvciBsb29wIHRvIGF2b2lkIHJlY3Vyc2lvblxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsZW5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiBsZW4gKiAyXG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gbGVuID4+PiAxXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB7XG4gICAgICAgICAgcmV0dXJuIG11c3RNYXRjaCA/IC0xIDogdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGggLy8gYXNzdW1lIHV0ZjhcbiAgICAgICAgfVxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuQnVmZmVyLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoXG5cbmZ1bmN0aW9uIHNsb3dUb1N0cmluZyAoZW5jb2RpbmcsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcblxuICAvLyBObyBuZWVkIHRvIHZlcmlmeSB0aGF0IFwidGhpcy5sZW5ndGggPD0gTUFYX1VJTlQzMlwiIHNpbmNlIGl0J3MgYSByZWFkLW9ubHlcbiAgLy8gcHJvcGVydHkgb2YgYSB0eXBlZCBhcnJheS5cblxuICAvLyBUaGlzIGJlaGF2ZXMgbmVpdGhlciBsaWtlIFN0cmluZyBub3IgVWludDhBcnJheSBpbiB0aGF0IHdlIHNldCBzdGFydC9lbmRcbiAgLy8gdG8gdGhlaXIgdXBwZXIvbG93ZXIgYm91bmRzIGlmIHRoZSB2YWx1ZSBwYXNzZWQgaXMgb3V0IG9mIHJhbmdlLlxuICAvLyB1bmRlZmluZWQgaXMgaGFuZGxlZCBzcGVjaWFsbHkgYXMgcGVyIEVDTUEtMjYyIDZ0aCBFZGl0aW9uLFxuICAvLyBTZWN0aW9uIDEzLjMuMy43IFJ1bnRpbWUgU2VtYW50aWNzOiBLZXllZEJpbmRpbmdJbml0aWFsaXphdGlvbi5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQgfHwgc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgLy8gUmV0dXJuIGVhcmx5IGlmIHN0YXJ0ID4gdGhpcy5sZW5ndGguIERvbmUgaGVyZSB0byBwcmV2ZW50IHBvdGVudGlhbCB1aW50MzJcbiAgLy8gY29lcmNpb24gZmFpbCBiZWxvdy5cbiAgaWYgKHN0YXJ0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCB8fCBlbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gIH1cblxuICBpZiAoZW5kIDw9IDApIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIC8vIEZvcmNlIGNvZXJjaW9uIHRvIHVpbnQzMi4gVGhpcyB3aWxsIGFsc28gY29lcmNlIGZhbHNleS9OYU4gdmFsdWVzIHRvIDAuXG4gIGVuZCA+Pj49IDBcbiAgc3RhcnQgPj4+PSAwXG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGF0aW4xU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1dGYxNmxlU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbi8vIFRoaXMgcHJvcGVydHkgaXMgdXNlZCBieSBgQnVmZmVyLmlzQnVmZmVyYCAoYW5kIHRoZSBgaXMtYnVmZmVyYCBucG0gcGFja2FnZSlcbi8vIHRvIGRldGVjdCBhIEJ1ZmZlciBpbnN0YW5jZS4gSXQncyBub3QgcG9zc2libGUgdG8gdXNlIGBpbnN0YW5jZW9mIEJ1ZmZlcmBcbi8vIHJlbGlhYmx5IGluIGEgYnJvd3NlcmlmeSBjb250ZXh0IGJlY2F1c2UgdGhlcmUgY291bGQgYmUgbXVsdGlwbGUgZGlmZmVyZW50XG4vLyBjb3BpZXMgb2YgdGhlICdidWZmZXInIHBhY2thZ2UgaW4gdXNlLiBUaGlzIG1ldGhvZCB3b3JrcyBldmVuIGZvciBCdWZmZXJcbi8vIGluc3RhbmNlcyB0aGF0IHdlcmUgY3JlYXRlZCBmcm9tIGFub3RoZXIgY29weSBvZiB0aGUgYGJ1ZmZlcmAgcGFja2FnZS5cbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvaXNzdWVzLzE1NFxuQnVmZmVyLnByb3RvdHlwZS5faXNCdWZmZXIgPSB0cnVlXG5cbmZ1bmN0aW9uIHN3YXAgKGIsIG4sIG0pIHtcbiAgdmFyIGkgPSBiW25dXG4gIGJbbl0gPSBiW21dXG4gIGJbbV0gPSBpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDE2ID0gZnVuY3Rpb24gc3dhcDE2ICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSAyICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAxNi1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSAyKSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMSlcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAzMiA9IGZ1bmN0aW9uIHN3YXAzMiAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgNCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMzItYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDMpXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDIpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwNjQgPSBmdW5jdGlvbiBzd2FwNjQgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDggIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDY0LWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDgpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyA3KVxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyA2KVxuICAgIHN3YXAodGhpcywgaSArIDIsIGkgKyA1KVxuICAgIHN3YXAodGhpcywgaSArIDMsIGkgKyA0KVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuZ3RoID09PSAwKSByZXR1cm4gJydcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB1dGY4U2xpY2UodGhpcywgMCwgbGVuZ3RoKVxuICByZXR1cm4gc2xvd1RvU3RyaW5nLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b0xvY2FsZVN0cmluZyA9IEJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmdcblxuQnVmZmVyLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMgKGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICBpZiAodGhpcyA9PT0gYikgcmV0dXJuIHRydWVcbiAgcmV0dXJuIEJ1ZmZlci5jb21wYXJlKHRoaXMsIGIpID09PSAwXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QgKCkge1xuICB2YXIgc3RyID0gJydcbiAgdmFyIG1heCA9IGV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVNcbiAgc3RyID0gdGhpcy50b1N0cmluZygnaGV4JywgMCwgbWF4KS5yZXBsYWNlKC8oLnsyfSkvZywgJyQxICcpLnRyaW0oKVxuICBpZiAodGhpcy5sZW5ndGggPiBtYXgpIHN0ciArPSAnIC4uLiAnXG4gIHJldHVybiAnPEJ1ZmZlciAnICsgc3RyICsgJz4nXG59XG5pZiAoY3VzdG9tSW5zcGVjdFN5bWJvbCkge1xuICBCdWZmZXIucHJvdG90eXBlW2N1c3RvbUluc3BlY3RTeW1ib2xdID0gQnVmZmVyLnByb3RvdHlwZS5pbnNwZWN0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKHRhcmdldCwgc3RhcnQsIGVuZCwgdGhpc1N0YXJ0LCB0aGlzRW5kKSB7XG4gIGlmIChpc0luc3RhbmNlKHRhcmdldCwgVWludDhBcnJheSkpIHtcbiAgICB0YXJnZXQgPSBCdWZmZXIuZnJvbSh0YXJnZXQsIHRhcmdldC5vZmZzZXQsIHRhcmdldC5ieXRlTGVuZ3RoKVxuICB9XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHRhcmdldCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBcInRhcmdldFwiIGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgQnVmZmVyIG9yIFVpbnQ4QXJyYXkuICcgK1xuICAgICAgJ1JlY2VpdmVkIHR5cGUgJyArICh0eXBlb2YgdGFyZ2V0KVxuICAgIClcbiAgfVxuXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5kID0gdGFyZ2V0ID8gdGFyZ2V0Lmxlbmd0aCA6IDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzU3RhcnQgPSAwXG4gIH1cbiAgaWYgKHRoaXNFbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNFbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKHN0YXJ0IDwgMCB8fCBlbmQgPiB0YXJnZXQubGVuZ3RoIHx8IHRoaXNTdGFydCA8IDAgfHwgdGhpc0VuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ291dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQgJiYgc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQpIHtcbiAgICByZXR1cm4gLTFcbiAgfVxuICBpZiAoc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDFcbiAgfVxuXG4gIHN0YXJ0ID4+Pj0gMFxuICBlbmQgPj4+PSAwXG4gIHRoaXNTdGFydCA+Pj49IDBcbiAgdGhpc0VuZCA+Pj49IDBcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0KSByZXR1cm4gMFxuXG4gIHZhciB4ID0gdGhpc0VuZCAtIHRoaXNTdGFydFxuICB2YXIgeSA9IGVuZCAtIHN0YXJ0XG4gIHZhciBsZW4gPSBNYXRoLm1pbih4LCB5KVxuXG4gIHZhciB0aGlzQ29weSA9IHRoaXMuc2xpY2UodGhpc1N0YXJ0LCB0aGlzRW5kKVxuICB2YXIgdGFyZ2V0Q29weSA9IHRhcmdldC5zbGljZShzdGFydCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAodGhpc0NvcHlbaV0gIT09IHRhcmdldENvcHlbaV0pIHtcbiAgICAgIHggPSB0aGlzQ29weVtpXVxuICAgICAgeSA9IHRhcmdldENvcHlbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG4vLyBGaW5kcyBlaXRoZXIgdGhlIGZpcnN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA+PSBgYnl0ZU9mZnNldGAsXG4vLyBPUiB0aGUgbGFzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPD0gYGJ5dGVPZmZzZXRgLlxuLy9cbi8vIEFyZ3VtZW50czpcbi8vIC0gYnVmZmVyIC0gYSBCdWZmZXIgdG8gc2VhcmNoXG4vLyAtIHZhbCAtIGEgc3RyaW5nLCBCdWZmZXIsIG9yIG51bWJlclxuLy8gLSBieXRlT2Zmc2V0IC0gYW4gaW5kZXggaW50byBgYnVmZmVyYDsgd2lsbCBiZSBjbGFtcGVkIHRvIGFuIGludDMyXG4vLyAtIGVuY29kaW5nIC0gYW4gb3B0aW9uYWwgZW5jb2RpbmcsIHJlbGV2YW50IGlzIHZhbCBpcyBhIHN0cmluZ1xuLy8gLSBkaXIgLSB0cnVlIGZvciBpbmRleE9mLCBmYWxzZSBmb3IgbGFzdEluZGV4T2ZcbmZ1bmN0aW9uIGJpZGlyZWN0aW9uYWxJbmRleE9mIChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICAvLyBFbXB0eSBidWZmZXIgbWVhbnMgbm8gbWF0Y2hcbiAgaWYgKGJ1ZmZlci5sZW5ndGggPT09IDApIHJldHVybiAtMVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0XG4gIGlmICh0eXBlb2YgYnl0ZU9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IGJ5dGVPZmZzZXRcbiAgICBieXRlT2Zmc2V0ID0gMFxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPiAweDdmZmZmZmZmKSB7XG4gICAgYnl0ZU9mZnNldCA9IDB4N2ZmZmZmZmZcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgLTB4ODAwMDAwMDApIHtcbiAgICBieXRlT2Zmc2V0ID0gLTB4ODAwMDAwMDBcbiAgfVxuICBieXRlT2Zmc2V0ID0gK2J5dGVPZmZzZXQgLy8gQ29lcmNlIHRvIE51bWJlci5cbiAgaWYgKG51bWJlcklzTmFOKGJ5dGVPZmZzZXQpKSB7XG4gICAgLy8gYnl0ZU9mZnNldDogaXQgaXQncyB1bmRlZmluZWQsIG51bGwsIE5hTiwgXCJmb29cIiwgZXRjLCBzZWFyY2ggd2hvbGUgYnVmZmVyXG4gICAgYnl0ZU9mZnNldCA9IGRpciA/IDAgOiAoYnVmZmVyLmxlbmd0aCAtIDEpXG4gIH1cblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldDogbmVnYXRpdmUgb2Zmc2V0cyBzdGFydCBmcm9tIHRoZSBlbmQgb2YgdGhlIGJ1ZmZlclxuICBpZiAoYnl0ZU9mZnNldCA8IDApIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoICsgYnl0ZU9mZnNldFxuICBpZiAoYnl0ZU9mZnNldCA+PSBidWZmZXIubGVuZ3RoKSB7XG4gICAgaWYgKGRpcikgcmV0dXJuIC0xXG4gICAgZWxzZSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCAtIDFcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgMCkge1xuICAgIGlmIChkaXIpIGJ5dGVPZmZzZXQgPSAwXG4gICAgZWxzZSByZXR1cm4gLTFcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSB2YWxcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFsID0gQnVmZmVyLmZyb20odmFsLCBlbmNvZGluZylcbiAgfVxuXG4gIC8vIEZpbmFsbHksIHNlYXJjaCBlaXRoZXIgaW5kZXhPZiAoaWYgZGlyIGlzIHRydWUpIG9yIGxhc3RJbmRleE9mXG4gIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsKSkge1xuICAgIC8vIFNwZWNpYWwgY2FzZTogbG9va2luZyBmb3IgZW1wdHkgc3RyaW5nL2J1ZmZlciBhbHdheXMgZmFpbHNcbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIC0xXG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAweEZGIC8vIFNlYXJjaCBmb3IgYSBieXRlIHZhbHVlIFswLTI1NV1cbiAgICBpZiAodHlwZW9mIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmIChkaXIpIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5sYXN0SW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgW3ZhbF0sIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCd2YWwgbXVzdCBiZSBzdHJpbmcsIG51bWJlciBvciBCdWZmZXInKVxufVxuXG5mdW5jdGlvbiBhcnJheUluZGV4T2YgKGFyciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIHZhciBpbmRleFNpemUgPSAxXG4gIHZhciBhcnJMZW5ndGggPSBhcnIubGVuZ3RoXG4gIHZhciB2YWxMZW5ndGggPSB2YWwubGVuZ3RoXG5cbiAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgIGlmIChlbmNvZGluZyA9PT0gJ3VjczInIHx8IGVuY29kaW5nID09PSAndWNzLTInIHx8XG4gICAgICAgIGVuY29kaW5nID09PSAndXRmMTZsZScgfHwgZW5jb2RpbmcgPT09ICd1dGYtMTZsZScpIHtcbiAgICAgIGlmIChhcnIubGVuZ3RoIDwgMiB8fCB2YWwubGVuZ3RoIDwgMikge1xuICAgICAgICByZXR1cm4gLTFcbiAgICAgIH1cbiAgICAgIGluZGV4U2l6ZSA9IDJcbiAgICAgIGFyckxlbmd0aCAvPSAyXG4gICAgICB2YWxMZW5ndGggLz0gMlxuICAgICAgYnl0ZU9mZnNldCAvPSAyXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZCAoYnVmLCBpKSB7XG4gICAgaWYgKGluZGV4U2l6ZSA9PT0gMSkge1xuICAgICAgcmV0dXJuIGJ1ZltpXVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYnVmLnJlYWRVSW50MTZCRShpICogaW5kZXhTaXplKVxuICAgIH1cbiAgfVxuXG4gIHZhciBpXG4gIGlmIChkaXIpIHtcbiAgICB2YXIgZm91bmRJbmRleCA9IC0xXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA8IGFyckxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAocmVhZChhcnIsIGkpID09PSByZWFkKHZhbCwgZm91bmRJbmRleCA9PT0gLTEgPyAwIDogaSAtIGZvdW5kSW5kZXgpKSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ID09PSAtMSkgZm91bmRJbmRleCA9IGlcbiAgICAgICAgaWYgKGkgLSBmb3VuZEluZGV4ICsgMSA9PT0gdmFsTGVuZ3RoKSByZXR1cm4gZm91bmRJbmRleCAqIGluZGV4U2l6ZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggIT09IC0xKSBpIC09IGkgLSBmb3VuZEluZGV4XG4gICAgICAgIGZvdW5kSW5kZXggPSAtMVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoYnl0ZU9mZnNldCArIHZhbExlbmd0aCA+IGFyckxlbmd0aCkgYnl0ZU9mZnNldCA9IGFyckxlbmd0aCAtIHZhbExlbmd0aFxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgZm91bmQgPSB0cnVlXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHZhbExlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmIChyZWFkKGFyciwgaSArIGopICE9PSByZWFkKHZhbCwgaikpIHtcbiAgICAgICAgICBmb3VuZCA9IGZhbHNlXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGZvdW5kKSByZXR1cm4gaVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluY2x1ZGVzID0gZnVuY3Rpb24gaW5jbHVkZXMgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIHRoaXMuaW5kZXhPZih2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSAhPT0gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24gaW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgdHJ1ZSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5sYXN0SW5kZXhPZiA9IGZ1bmN0aW9uIGxhc3RJbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBmYWxzZSlcbn1cblxuZnVuY3Rpb24gaGV4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0KSB8fCAwXG4gIHZhciByZW1haW5pbmcgPSBidWYubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gIH0gZWxzZSB7XG4gICAgbGVuZ3RoID0gTnVtYmVyKGxlbmd0aClcbiAgICBpZiAobGVuZ3RoID4gcmVtYWluaW5nKSB7XG4gICAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgICB9XG4gIH1cblxuICB2YXIgc3RyTGVuID0gc3RyaW5nLmxlbmd0aFxuXG4gIGlmIChsZW5ndGggPiBzdHJMZW4gLyAyKSB7XG4gICAgbGVuZ3RoID0gc3RyTGVuIC8gMlxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgcGFyc2VkID0gcGFyc2VJbnQoc3RyaW5nLnN1YnN0cihpICogMiwgMiksIDE2KVxuICAgIGlmIChudW1iZXJJc05hTihwYXJzZWQpKSByZXR1cm4gaVxuICAgIGJ1ZltvZmZzZXQgKyBpXSA9IHBhcnNlZFxuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIHV0ZjhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjhUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGFzY2lpV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihhc2NpaVRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYmFzZTY0V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihiYXNlNjRUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIHVjczJXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjE2bGVUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiB3cml0ZSAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpIHtcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZylcbiAgaWYgKG9mZnNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgZW5jb2RpbmcpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIG9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IG9mZnNldFxuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBvZmZzZXRbLCBsZW5ndGhdWywgZW5jb2RpbmddKVxuICB9IGVsc2UgaWYgKGlzRmluaXRlKG9mZnNldCkpIHtcbiAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgICBpZiAoaXNGaW5pdGUobGVuZ3RoKSkge1xuICAgICAgbGVuZ3RoID0gbGVuZ3RoID4+PiAwXG4gICAgICBpZiAoZW5jb2RpbmcgPT09IHVuZGVmaW5lZCkgZW5jb2RpbmcgPSAndXRmOCdcbiAgICB9IGVsc2Uge1xuICAgICAgZW5jb2RpbmcgPSBsZW5ndGhcbiAgICAgIGxlbmd0aCA9IHVuZGVmaW5lZFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnQnVmZmVyLndyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldFssIGxlbmd0aF0pIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQnXG4gICAgKVxuICB9XG5cbiAgdmFyIHJlbWFpbmluZyA9IHRoaXMubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCB8fCBsZW5ndGggPiByZW1haW5pbmcpIGxlbmd0aCA9IHJlbWFpbmluZ1xuXG4gIGlmICgoc3RyaW5nLmxlbmd0aCA+IDAgJiYgKGxlbmd0aCA8IDAgfHwgb2Zmc2V0IDwgMCkpIHx8IG9mZnNldCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gd3JpdGUgb3V0c2lkZSBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGFzY2lpV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgLy8gV2FybmluZzogbWF4TGVuZ3RoIG5vdCB0YWtlbiBpbnRvIGFjY291bnQgaW4gYmFzZTY0V3JpdGVcbiAgICAgICAgcmV0dXJuIGJhc2U2NFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1Y3MyV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OICgpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnQnVmZmVyJyxcbiAgICBkYXRhOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLl9hcnIgfHwgdGhpcywgMClcbiAgfVxufVxuXG5mdW5jdGlvbiBiYXNlNjRTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGlmIChzdGFydCA9PT0gMCAmJiBlbmQgPT09IGJ1Zi5sZW5ndGgpIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYuc2xpY2Uoc3RhcnQsIGVuZCkpXG4gIH1cbn1cblxuZnVuY3Rpb24gdXRmOFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuICB2YXIgcmVzID0gW11cblxuICB2YXIgaSA9IHN0YXJ0XG4gIHdoaWxlIChpIDwgZW5kKSB7XG4gICAgdmFyIGZpcnN0Qnl0ZSA9IGJ1ZltpXVxuICAgIHZhciBjb2RlUG9pbnQgPSBudWxsXG4gICAgdmFyIGJ5dGVzUGVyU2VxdWVuY2UgPSAoZmlyc3RCeXRlID4gMHhFRilcbiAgICAgID8gNFxuICAgICAgOiAoZmlyc3RCeXRlID4gMHhERilcbiAgICAgICAgICA/IDNcbiAgICAgICAgICA6IChmaXJzdEJ5dGUgPiAweEJGKVxuICAgICAgICAgICAgICA/IDJcbiAgICAgICAgICAgICAgOiAxXG5cbiAgICBpZiAoaSArIGJ5dGVzUGVyU2VxdWVuY2UgPD0gZW5kKSB7XG4gICAgICB2YXIgc2Vjb25kQnl0ZSwgdGhpcmRCeXRlLCBmb3VydGhCeXRlLCB0ZW1wQ29kZVBvaW50XG5cbiAgICAgIHN3aXRjaCAoYnl0ZXNQZXJTZXF1ZW5jZSkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgaWYgKGZpcnN0Qnl0ZSA8IDB4ODApIHtcbiAgICAgICAgICAgIGNvZGVQb2ludCA9IGZpcnN0Qnl0ZVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweDFGKSA8PCAweDYgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0YpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHhDIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAodGhpcmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3RkYgJiYgKHRlbXBDb2RlUG9pbnQgPCAweEQ4MDAgfHwgdGVtcENvZGVQb2ludCA+IDB4REZGRikpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgZm91cnRoQnl0ZSA9IGJ1ZltpICsgM11cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKGZvdXJ0aEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4MTIgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4QyB8ICh0aGlyZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAoZm91cnRoQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4RkZGRiAmJiB0ZW1wQ29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY29kZVBvaW50ID09PSBudWxsKSB7XG4gICAgICAvLyB3ZSBkaWQgbm90IGdlbmVyYXRlIGEgdmFsaWQgY29kZVBvaW50IHNvIGluc2VydCBhXG4gICAgICAvLyByZXBsYWNlbWVudCBjaGFyIChVK0ZGRkQpIGFuZCBhZHZhbmNlIG9ubHkgMSBieXRlXG4gICAgICBjb2RlUG9pbnQgPSAweEZGRkRcbiAgICAgIGJ5dGVzUGVyU2VxdWVuY2UgPSAxXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPiAweEZGRkYpIHtcbiAgICAgIC8vIGVuY29kZSB0byB1dGYxNiAoc3Vycm9nYXRlIHBhaXIgZGFuY2UpXG4gICAgICBjb2RlUG9pbnQgLT0gMHgxMDAwMFxuICAgICAgcmVzLnB1c2goY29kZVBvaW50ID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKVxuICAgICAgY29kZVBvaW50ID0gMHhEQzAwIHwgY29kZVBvaW50ICYgMHgzRkZcbiAgICB9XG5cbiAgICByZXMucHVzaChjb2RlUG9pbnQpXG4gICAgaSArPSBieXRlc1BlclNlcXVlbmNlXG4gIH1cblxuICByZXR1cm4gZGVjb2RlQ29kZVBvaW50c0FycmF5KHJlcylcbn1cblxuLy8gQmFzZWQgb24gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjI3NDcyNzIvNjgwNzQyLCB0aGUgYnJvd3NlciB3aXRoXG4vLyB0aGUgbG93ZXN0IGxpbWl0IGlzIENocm9tZSwgd2l0aCAweDEwMDAwIGFyZ3MuXG4vLyBXZSBnbyAxIG1hZ25pdHVkZSBsZXNzLCBmb3Igc2FmZXR5XG52YXIgTUFYX0FSR1VNRU5UU19MRU5HVEggPSAweDEwMDBcblxuZnVuY3Rpb24gZGVjb2RlQ29kZVBvaW50c0FycmF5IChjb2RlUG9pbnRzKSB7XG4gIHZhciBsZW4gPSBjb2RlUG9pbnRzLmxlbmd0aFxuICBpZiAobGVuIDw9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjb2RlUG9pbnRzKSAvLyBhdm9pZCBleHRyYSBzbGljZSgpXG4gIH1cblxuICAvLyBEZWNvZGUgaW4gY2h1bmtzIHRvIGF2b2lkIFwiY2FsbCBzdGFjayBzaXplIGV4Y2VlZGVkXCIuXG4gIHZhciByZXMgPSAnJ1xuICB2YXIgaSA9IDBcbiAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShcbiAgICAgIFN0cmluZyxcbiAgICAgIGNvZGVQb2ludHMuc2xpY2UoaSwgaSArPSBNQVhfQVJHVU1FTlRTX0xFTkdUSClcbiAgICApXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSAmIDB4N0YpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBsYXRpbjFTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBoZXhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG5cbiAgaWYgKCFzdGFydCB8fCBzdGFydCA8IDApIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCB8fCBlbmQgPCAwIHx8IGVuZCA+IGxlbikgZW5kID0gbGVuXG5cbiAgdmFyIG91dCA9ICcnXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgb3V0ICs9IGhleFNsaWNlTG9va3VwVGFibGVbYnVmW2ldXVxuICB9XG4gIHJldHVybiBvdXRcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGJ5dGVzID0gYnVmLnNsaWNlKHN0YXJ0LCBlbmQpXG4gIHZhciByZXMgPSAnJ1xuICAvLyBJZiBieXRlcy5sZW5ndGggaXMgb2RkLCB0aGUgbGFzdCA4IGJpdHMgbXVzdCBiZSBpZ25vcmVkIChzYW1lIGFzIG5vZGUuanMpXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoIC0gMTsgaSArPSAyKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0gKyAoYnl0ZXNbaSArIDFdICogMjU2KSlcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiBzbGljZSAoc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgc3RhcnQgPSB+fnN0YXJ0XG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuIDogfn5lbmRcblxuICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgKz0gbGVuXG4gICAgaWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIH0gZWxzZSBpZiAoc3RhcnQgPiBsZW4pIHtcbiAgICBzdGFydCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IDApIHtcbiAgICBlbmQgKz0gbGVuXG4gICAgaWYgKGVuZCA8IDApIGVuZCA9IDBcbiAgfSBlbHNlIGlmIChlbmQgPiBsZW4pIHtcbiAgICBlbmQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICB2YXIgbmV3QnVmID0gdGhpcy5zdWJhcnJheShzdGFydCwgZW5kKVxuICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZVxuICBPYmplY3Quc2V0UHJvdG90eXBlT2YobmV3QnVmLCBCdWZmZXIucHJvdG90eXBlKVxuXG4gIHJldHVybiBuZXdCdWZcbn1cblxuLypcbiAqIE5lZWQgdG8gbWFrZSBzdXJlIHRoYXQgYnVmZmVyIGlzbid0IHRyeWluZyB0byB3cml0ZSBvdXQgb2YgYm91bmRzLlxuICovXG5mdW5jdGlvbiBjaGVja09mZnNldCAob2Zmc2V0LCBleHQsIGxlbmd0aCkge1xuICBpZiAoKG9mZnNldCAlIDEpICE9PSAwIHx8IG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdvZmZzZXQgaXMgbm90IHVpbnQnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gbGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVHJ5aW5nIHRvIGFjY2VzcyBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVpbnRMRSA9XG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50TEUgPSBmdW5jdGlvbiByZWFkVUludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVWludEJFID1cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRCRSA9IGZ1bmN0aW9uIHJlYWRVSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuICB9XG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXVxuICB2YXIgbXVsID0gMVxuICB3aGlsZSAoYnl0ZUxlbmd0aCA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVpbnQ4ID1cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4ID0gZnVuY3Rpb24gcmVhZFVJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVpbnQxNkxFID1cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkxFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVWludDE2QkUgPVxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkUgPSBmdW5jdGlvbiByZWFkVUludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDgpIHwgdGhpc1tvZmZzZXQgKyAxXVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVaW50MzJMRSA9XG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKCh0aGlzW29mZnNldF0pIHxcbiAgICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSkgK1xuICAgICAgKHRoaXNbb2Zmc2V0ICsgM10gKiAweDEwMDAwMDApXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVpbnQzMkJFID1cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdICogMHgxMDAwMDAwKSArXG4gICAgKCh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgIHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludExFID0gZnVuY3Rpb24gcmVhZEludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRCRSA9IGZ1bmN0aW9uIHJlYWRJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgaSA9IGJ5dGVMZW5ndGhcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1pXVxuICB3aGlsZSAoaSA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uIHJlYWRJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICBpZiAoISh0aGlzW29mZnNldF0gJiAweDgwKSkgcmV0dXJuICh0aGlzW29mZnNldF0pXG4gIHJldHVybiAoKDB4ZmYgLSB0aGlzW29mZnNldF0gKyAxKSAqIC0xKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkxFID0gZnVuY3Rpb24gcmVhZEludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2QkUgPSBmdW5jdGlvbiByZWFkSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgMV0gfCAodGhpc1tvZmZzZXRdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdKSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10gPDwgMjQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyQkUgPSBmdW5jdGlvbiByZWFkSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCAyNCkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdExFID0gZnVuY3Rpb24gcmVhZEZsb2F0TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRCRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdEJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVMRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDUyLCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVCRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCA1MiwgOClcbn1cblxuZnVuY3Rpb24gY2hlY2tJbnQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImJ1ZmZlclwiIGFyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXIgaW5zdGFuY2UnKVxuICBpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pIHRocm93IG5ldyBSYW5nZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgaXMgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVpbnRMRSA9XG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludExFID0gZnVuY3Rpb24gd3JpdGVVSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKVxuICB9XG5cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVpbnRCRSA9XG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludEJFID0gZnVuY3Rpb24gd3JpdGVVSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKVxuICB9XG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMVxuICB2YXIgbXVsID0gMVxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVpbnQ4ID1cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50OCA9IGZ1bmN0aW9uIHdyaXRlVUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweGZmLCAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVWludDE2TEUgPVxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVpbnQxNkJFID1cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVaW50MzJMRSA9XG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVWludDMyQkUgPVxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludExFID0gZnVuY3Rpb24gd3JpdGVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCAoOCAqIGJ5dGVMZW5ndGgpIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgdmFyIGkgPSAwXG4gIHZhciBtdWwgPSAxXG4gIHZhciBzdWIgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSAtIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxXG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgKDggKiBieXRlTGVuZ3RoKSAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IDBcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgKyAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50OCA9IGZ1bmN0aW9uIHdyaXRlSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4N2YsIC0weDgwKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmYgKyB2YWx1ZSArIDFcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbmZ1bmN0aW9uIGNoZWNrSUVFRTc1NCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbiAgaWYgKG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5mdW5jdGlvbiB3cml0ZUZsb2F0IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA0LCAzLjQwMjgyMzQ2NjM4NTI4ODZlKzM4LCAtMy40MDI4MjM0NjYzODUyODg2ZSszOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCAyMywgNClcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0TEUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRCRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiB3cml0ZURvdWJsZSAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgOCwgMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgsIC0xLjc5NzY5MzEzNDg2MjMxNTdFKzMwOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCA1MiwgOClcbiAgcmV0dXJuIG9mZnNldCArIDhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUxFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG4vLyBjb3B5KHRhcmdldEJ1ZmZlciwgdGFyZ2V0U3RhcnQ9MCwgc291cmNlU3RhcnQ9MCwgc291cmNlRW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiBjb3B5ICh0YXJnZXQsIHRhcmdldFN0YXJ0LCBzdGFydCwgZW5kKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHRhcmdldCkpIHRocm93IG5ldyBUeXBlRXJyb3IoJ2FyZ3VtZW50IHNob3VsZCBiZSBhIEJ1ZmZlcicpXG4gIGlmICghc3RhcnQpIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCAmJiBlbmQgIT09IDApIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXRTdGFydCA+PSB0YXJnZXQubGVuZ3RoKSB0YXJnZXRTdGFydCA9IHRhcmdldC5sZW5ndGhcbiAgaWYgKCF0YXJnZXRTdGFydCkgdGFyZ2V0U3RhcnQgPSAwXG4gIGlmIChlbmQgPiAwICYmIGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIC8vIENvcHkgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuIDBcbiAgaWYgKHRhcmdldC5sZW5ndGggPT09IDAgfHwgdGhpcy5sZW5ndGggPT09IDApIHJldHVybiAwXG5cbiAgLy8gRmF0YWwgZXJyb3IgY29uZGl0aW9uc1xuICBpZiAodGFyZ2V0U3RhcnQgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3RhcmdldFN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICB9XG4gIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxuICBpZiAoZW5kIDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZUVuZCBvdXQgb2YgYm91bmRzJylcblxuICAvLyBBcmUgd2Ugb29iP1xuICBpZiAoZW5kID4gdGhpcy5sZW5ndGgpIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgPCBlbmQgLSBzdGFydCkge1xuICAgIGVuZCA9IHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCArIHN0YXJ0XG4gIH1cblxuICB2YXIgbGVuID0gZW5kIC0gc3RhcnRcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0ICYmIHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5jb3B5V2l0aGluID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gVXNlIGJ1aWx0LWluIHdoZW4gYXZhaWxhYmxlLCBtaXNzaW5nIGZyb20gSUUxMVxuICAgIHRoaXMuY29weVdpdGhpbih0YXJnZXRTdGFydCwgc3RhcnQsIGVuZClcbiAgfSBlbHNlIHtcbiAgICBVaW50OEFycmF5LnByb3RvdHlwZS5zZXQuY2FsbChcbiAgICAgIHRhcmdldCxcbiAgICAgIHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZCksXG4gICAgICB0YXJnZXRTdGFydFxuICAgIClcbiAgfVxuXG4gIHJldHVybiBsZW5cbn1cblxuLy8gVXNhZ2U6XG4vLyAgICBidWZmZXIuZmlsbChudW1iZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKGJ1ZmZlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoc3RyaW5nWywgb2Zmc2V0WywgZW5kXV1bLCBlbmNvZGluZ10pXG5CdWZmZXIucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbiBmaWxsICh2YWwsIHN0YXJ0LCBlbmQsIGVuY29kaW5nKSB7XG4gIC8vIEhhbmRsZSBzdHJpbmcgY2FzZXM6XG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIGlmICh0eXBlb2Ygc3RhcnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IHN0YXJ0XG4gICAgICBzdGFydCA9IDBcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZW5kID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBlbmRcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfVxuICAgIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2VuY29kaW5nIG11c3QgYmUgYSBzdHJpbmcnKVxuICAgIH1cbiAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJyAmJiAhQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgfVxuICAgIGlmICh2YWwubGVuZ3RoID09PSAxKSB7XG4gICAgICB2YXIgY29kZSA9IHZhbC5jaGFyQ29kZUF0KDApXG4gICAgICBpZiAoKGVuY29kaW5nID09PSAndXRmOCcgJiYgY29kZSA8IDEyOCkgfHxcbiAgICAgICAgICBlbmNvZGluZyA9PT0gJ2xhdGluMScpIHtcbiAgICAgICAgLy8gRmFzdCBwYXRoOiBJZiBgdmFsYCBmaXRzIGludG8gYSBzaW5nbGUgYnl0ZSwgdXNlIHRoYXQgbnVtZXJpYyB2YWx1ZS5cbiAgICAgICAgdmFsID0gY29kZVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbCA9IHZhbCAmIDI1NVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdib29sZWFuJykge1xuICAgIHZhbCA9IE51bWJlcih2YWwpXG4gIH1cblxuICAvLyBJbnZhbGlkIHJhbmdlcyBhcmUgbm90IHNldCB0byBhIGRlZmF1bHQsIHNvIGNhbiByYW5nZSBjaGVjayBlYXJseS5cbiAgaWYgKHN0YXJ0IDwgMCB8fCB0aGlzLmxlbmd0aCA8IHN0YXJ0IHx8IHRoaXMubGVuZ3RoIDwgZW5kKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ091dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHN0YXJ0ID0gc3RhcnQgPj4+IDBcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyB0aGlzLmxlbmd0aCA6IGVuZCA+Pj4gMFxuXG4gIGlmICghdmFsKSB2YWwgPSAwXG5cbiAgdmFyIGlcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgICAgdGhpc1tpXSA9IHZhbFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgYnl0ZXMgPSBCdWZmZXIuaXNCdWZmZXIodmFsKVxuICAgICAgPyB2YWxcbiAgICAgIDogQnVmZmVyLmZyb20odmFsLCBlbmNvZGluZylcbiAgICB2YXIgbGVuID0gYnl0ZXMubGVuZ3RoXG4gICAgaWYgKGxlbiA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIHZhbHVlIFwiJyArIHZhbCArXG4gICAgICAgICdcIiBpcyBpbnZhbGlkIGZvciBhcmd1bWVudCBcInZhbHVlXCInKVxuICAgIH1cbiAgICBmb3IgKGkgPSAwOyBpIDwgZW5kIC0gc3RhcnQ7ICsraSkge1xuICAgICAgdGhpc1tpICsgc3RhcnRdID0gYnl0ZXNbaSAlIGxlbl1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpc1xufVxuXG4vLyBIRUxQRVIgRlVOQ1RJT05TXG4vLyA9PT09PT09PT09PT09PT09XG5cbnZhciBJTlZBTElEX0JBU0U2NF9SRSA9IC9bXisvMC05QS1aYS16LV9dL2dcblxuZnVuY3Rpb24gYmFzZTY0Y2xlYW4gKHN0cikge1xuICAvLyBOb2RlIHRha2VzIGVxdWFsIHNpZ25zIGFzIGVuZCBvZiB0aGUgQmFzZTY0IGVuY29kaW5nXG4gIHN0ciA9IHN0ci5zcGxpdCgnPScpWzBdXG4gIC8vIE5vZGUgc3RyaXBzIG91dCBpbnZhbGlkIGNoYXJhY3RlcnMgbGlrZSBcXG4gYW5kIFxcdCBmcm9tIHRoZSBzdHJpbmcsIGJhc2U2NC1qcyBkb2VzIG5vdFxuICBzdHIgPSBzdHIudHJpbSgpLnJlcGxhY2UoSU5WQUxJRF9CQVNFNjRfUkUsICcnKVxuICAvLyBOb2RlIGNvbnZlcnRzIHN0cmluZ3Mgd2l0aCBsZW5ndGggPCAyIHRvICcnXG4gIGlmIChzdHIubGVuZ3RoIDwgMikgcmV0dXJuICcnXG4gIC8vIE5vZGUgYWxsb3dzIGZvciBub24tcGFkZGVkIGJhc2U2NCBzdHJpbmdzIChtaXNzaW5nIHRyYWlsaW5nID09PSksIGJhc2U2NC1qcyBkb2VzIG5vdFxuICB3aGlsZSAoc3RyLmxlbmd0aCAlIDQgIT09IDApIHtcbiAgICBzdHIgPSBzdHIgKyAnPSdcbiAgfVxuICByZXR1cm4gc3RyXG59XG5cbmZ1bmN0aW9uIHV0ZjhUb0J5dGVzIChzdHJpbmcsIHVuaXRzKSB7XG4gIHVuaXRzID0gdW5pdHMgfHwgSW5maW5pdHlcbiAgdmFyIGNvZGVQb2ludFxuICB2YXIgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aFxuICB2YXIgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcbiAgdmFyIGJ5dGVzID0gW11cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgY29kZVBvaW50ID0gc3RyaW5nLmNoYXJDb2RlQXQoaSlcblxuICAgIC8vIGlzIHN1cnJvZ2F0ZSBjb21wb25lbnRcbiAgICBpZiAoY29kZVBvaW50ID4gMHhEN0ZGICYmIGNvZGVQb2ludCA8IDB4RTAwMCkge1xuICAgICAgLy8gbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICghbGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgICAvLyBubyBsZWFkIHlldFxuICAgICAgICBpZiAoY29kZVBvaW50ID4gMHhEQkZGKSB7XG4gICAgICAgICAgLy8gdW5leHBlY3RlZCB0cmFpbFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH0gZWxzZSBpZiAoaSArIDEgPT09IGxlbmd0aCkge1xuICAgICAgICAgIC8vIHVucGFpcmVkIGxlYWRcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gdmFsaWQgbGVhZFxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG5cbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gMiBsZWFkcyBpbiBhIHJvd1xuICAgICAgaWYgKGNvZGVQb2ludCA8IDB4REMwMCkge1xuICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyB2YWxpZCBzdXJyb2dhdGUgcGFpclxuICAgICAgY29kZVBvaW50ID0gKGxlYWRTdXJyb2dhdGUgLSAweEQ4MDAgPDwgMTAgfCBjb2RlUG9pbnQgLSAweERDMDApICsgMHgxMDAwMFxuICAgIH0gZWxzZSBpZiAobGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgLy8gdmFsaWQgYm1wIGNoYXIsIGJ1dCBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgfVxuXG4gICAgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcblxuICAgIC8vIGVuY29kZSB1dGY4XG4gICAgaWYgKGNvZGVQb2ludCA8IDB4ODApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMSkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChjb2RlUG9pbnQpXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDgwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2IHwgMHhDMCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyB8IDB4RTAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDQpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDEyIHwgMHhGMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjb2RlIHBvaW50JylcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnl0ZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlUb0J5dGVzIChzdHIpIHtcbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgLy8gTm9kZSdzIGNvZGUgc2VlbXMgdG8gYmUgZG9pbmcgdGhpcyBhbmQgbm90ICYgMHg3Ri4uXG4gICAgYnl0ZUFycmF5LnB1c2goc3RyLmNoYXJDb2RlQXQoaSkgJiAweEZGKVxuICB9XG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVRvQnl0ZXMgKHN0ciwgdW5pdHMpIHtcbiAgdmFyIGMsIGhpLCBsb1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcblxuICAgIGMgPSBzdHIuY2hhckNvZGVBdChpKVxuICAgIGhpID0gYyA+PiA4XG4gICAgbG8gPSBjICUgMjU2XG4gICAgYnl0ZUFycmF5LnB1c2gobG8pXG4gICAgYnl0ZUFycmF5LnB1c2goaGkpXG4gIH1cblxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFRvQnl0ZXMgKHN0cikge1xuICByZXR1cm4gYmFzZTY0LnRvQnl0ZUFycmF5KGJhc2U2NGNsZWFuKHN0cikpXG59XG5cbmZ1bmN0aW9uIGJsaXRCdWZmZXIgKHNyYywgZHN0LCBvZmZzZXQsIGxlbmd0aCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgaWYgKChpICsgb2Zmc2V0ID49IGRzdC5sZW5ndGgpIHx8IChpID49IHNyYy5sZW5ndGgpKSBicmVha1xuICAgIGRzdFtpICsgb2Zmc2V0XSA9IHNyY1tpXVxuICB9XG4gIHJldHVybiBpXG59XG5cbi8vIEFycmF5QnVmZmVyIG9yIFVpbnQ4QXJyYXkgb2JqZWN0cyBmcm9tIG90aGVyIGNvbnRleHRzIChpLmUuIGlmcmFtZXMpIGRvIG5vdCBwYXNzXG4vLyB0aGUgYGluc3RhbmNlb2ZgIGNoZWNrIGJ1dCB0aGV5IHNob3VsZCBiZSB0cmVhdGVkIGFzIG9mIHRoYXQgdHlwZS5cbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvaXNzdWVzLzE2NlxuZnVuY3Rpb24gaXNJbnN0YW5jZSAob2JqLCB0eXBlKSB7XG4gIHJldHVybiBvYmogaW5zdGFuY2VvZiB0eXBlIHx8XG4gICAgKG9iaiAhPSBudWxsICYmIG9iai5jb25zdHJ1Y3RvciAhPSBudWxsICYmIG9iai5jb25zdHJ1Y3Rvci5uYW1lICE9IG51bGwgJiZcbiAgICAgIG9iai5jb25zdHJ1Y3Rvci5uYW1lID09PSB0eXBlLm5hbWUpXG59XG5mdW5jdGlvbiBudW1iZXJJc05hTiAob2JqKSB7XG4gIC8vIEZvciBJRTExIHN1cHBvcnRcbiAgcmV0dXJuIG9iaiAhPT0gb2JqIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2VsZi1jb21wYXJlXG59XG5cbi8vIENyZWF0ZSBsb29rdXAgdGFibGUgZm9yIGB0b1N0cmluZygnaGV4JylgXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL2lzc3Vlcy8yMTlcbnZhciBoZXhTbGljZUxvb2t1cFRhYmxlID0gKGZ1bmN0aW9uICgpIHtcbiAgdmFyIGFscGhhYmV0ID0gJzAxMjM0NTY3ODlhYmNkZWYnXG4gIHZhciB0YWJsZSA9IG5ldyBBcnJheSgyNTYpXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMTY7ICsraSkge1xuICAgIHZhciBpMTYgPSBpICogMTZcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IDE2OyArK2opIHtcbiAgICAgIHRhYmxlW2kxNiArIGpdID0gYWxwaGFiZXRbaV0gKyBhbHBoYWJldFtqXVxuICAgIH1cbiAgfVxuICByZXR1cm4gdGFibGVcbn0pKClcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/buffer/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/ieee754/index.js":
/*!***************************************!*\
  !*** ./node_modules/ieee754/index.js ***!
  \***************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval(__webpack_require__.ts("/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */\nexports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9pZWVlNzU0L2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUyxXQUFXOztBQUVwQjtBQUNBO0FBQ0E7QUFDQSxTQUFTLFdBQVc7O0FBRXBCO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVMsV0FBVzs7QUFFcEI7QUFDQTtBQUNBLFNBQVMsVUFBVTs7QUFFbkI7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvaWVlZTc1NC9pbmRleC5qcz9iMWI5Il0sInNvdXJjZXNDb250ZW50IjpbIi8qISBpZWVlNzU0LiBCU0QtMy1DbGF1c2UgTGljZW5zZS4gRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnL29wZW5zb3VyY2U+ICovXG5leHBvcnRzLnJlYWQgPSBmdW5jdGlvbiAoYnVmZmVyLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbVxuICB2YXIgZUxlbiA9IChuQnl0ZXMgKiA4KSAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgbkJpdHMgPSAtN1xuICB2YXIgaSA9IGlzTEUgPyAobkJ5dGVzIC0gMSkgOiAwXG4gIHZhciBkID0gaXNMRSA/IC0xIDogMVxuICB2YXIgcyA9IGJ1ZmZlcltvZmZzZXQgKyBpXVxuXG4gIGkgKz0gZFxuXG4gIGUgPSBzICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIHMgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IGVMZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgZSA9IChlICogMjU2KSArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIG0gPSBlICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIGUgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IG1MZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgbSA9IChtICogMjU2KSArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIGlmIChlID09PSAwKSB7XG4gICAgZSA9IDEgLSBlQmlhc1xuICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHtcbiAgICByZXR1cm4gbSA/IE5hTiA6ICgocyA/IC0xIDogMSkgKiBJbmZpbml0eSlcbiAgfSBlbHNlIHtcbiAgICBtID0gbSArIE1hdGgucG93KDIsIG1MZW4pXG4gICAgZSA9IGUgLSBlQmlhc1xuICB9XG4gIHJldHVybiAocyA/IC0xIDogMSkgKiBtICogTWF0aC5wb3coMiwgZSAtIG1MZW4pXG59XG5cbmV4cG9ydHMud3JpdGUgPSBmdW5jdGlvbiAoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG0sIGNcbiAgdmFyIGVMZW4gPSAobkJ5dGVzICogOCkgLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIHJ0ID0gKG1MZW4gPT09IDIzID8gTWF0aC5wb3coMiwgLTI0KSAtIE1hdGgucG93KDIsIC03NykgOiAwKVxuICB2YXIgaSA9IGlzTEUgPyAwIDogKG5CeXRlcyAtIDEpXG4gIHZhciBkID0gaXNMRSA/IDEgOiAtMVxuICB2YXIgcyA9IHZhbHVlIDwgMCB8fCAodmFsdWUgPT09IDAgJiYgMSAvIHZhbHVlIDwgMCkgPyAxIDogMFxuXG4gIHZhbHVlID0gTWF0aC5hYnModmFsdWUpXG5cbiAgaWYgKGlzTmFOKHZhbHVlKSB8fCB2YWx1ZSA9PT0gSW5maW5pdHkpIHtcbiAgICBtID0gaXNOYU4odmFsdWUpID8gMSA6IDBcbiAgICBlID0gZU1heFxuICB9IGVsc2Uge1xuICAgIGUgPSBNYXRoLmZsb29yKE1hdGgubG9nKHZhbHVlKSAvIE1hdGguTE4yKVxuICAgIGlmICh2YWx1ZSAqIChjID0gTWF0aC5wb3coMiwgLWUpKSA8IDEpIHtcbiAgICAgIGUtLVxuICAgICAgYyAqPSAyXG4gICAgfVxuICAgIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgdmFsdWUgKz0gcnQgLyBjXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlICs9IHJ0ICogTWF0aC5wb3coMiwgMSAtIGVCaWFzKVxuICAgIH1cbiAgICBpZiAodmFsdWUgKiBjID49IDIpIHtcbiAgICAgIGUrK1xuICAgICAgYyAvPSAyXG4gICAgfVxuXG4gICAgaWYgKGUgKyBlQmlhcyA+PSBlTWF4KSB7XG4gICAgICBtID0gMFxuICAgICAgZSA9IGVNYXhcbiAgICB9IGVsc2UgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICBtID0gKCh2YWx1ZSAqIGMpIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IGUgKyBlQmlhc1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gdmFsdWUgKiBNYXRoLnBvdygyLCBlQmlhcyAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSAwXG4gICAgfVxuICB9XG5cbiAgZm9yICg7IG1MZW4gPj0gODsgYnVmZmVyW29mZnNldCArIGldID0gbSAmIDB4ZmYsIGkgKz0gZCwgbSAvPSAyNTYsIG1MZW4gLT0gOCkge31cblxuICBlID0gKGUgPDwgbUxlbikgfCBtXG4gIGVMZW4gKz0gbUxlblxuICBmb3IgKDsgZUxlbiA+IDA7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IGUgJiAweGZmLCBpICs9IGQsIGUgLz0gMjU2LCBlTGVuIC09IDgpIHt9XG5cbiAgYnVmZmVyW29mZnNldCArIGkgLSBkXSB8PSBzICogMTI4XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ieee754/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js":
/*!***********************************************************!*\
  !*** ./node_modules/next/dist/build/polyfills/process.js ***!
  \***********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar _global_process, _global_process1;\nmodule.exports = ((_global_process = __webpack_require__.g.process) == null ? void 0 : _global_process.env) && typeof ((_global_process1 = __webpack_require__.g.process) == null ? void 0 : _global_process1.env) === \"object\" ? __webpack_require__.g.process : __webpack_require__(/*! ../../compiled/process */ \"(app-pages-browser)/./node_modules/next/dist/compiled/process/browser.js\");\n\n//# sourceMappingURL=process.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvcG9seWZpbGxzL3Byb2Nlc3MuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLHFDQUFxQyxxQkFBTSxpRkFBaUYscUJBQU0sa0VBQWtFLHFCQUFNLFdBQVcsbUJBQU8sQ0FBQyx3R0FBd0I7O0FBRXJQIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvcG9seWZpbGxzL3Byb2Nlc3MuanM/N2NhNyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfZ2xvYmFsX3Byb2Nlc3MsIF9nbG9iYWxfcHJvY2VzczE7XG5tb2R1bGUuZXhwb3J0cyA9ICgoX2dsb2JhbF9wcm9jZXNzID0gZ2xvYmFsLnByb2Nlc3MpID09IG51bGwgPyB2b2lkIDAgOiBfZ2xvYmFsX3Byb2Nlc3MuZW52KSAmJiB0eXBlb2YgKChfZ2xvYmFsX3Byb2Nlc3MxID0gZ2xvYmFsLnByb2Nlc3MpID09IG51bGwgPyB2b2lkIDAgOiBfZ2xvYmFsX3Byb2Nlc3MxLmVudikgPT09IFwib2JqZWN0XCIgPyBnbG9iYWwucHJvY2VzcyA6IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlZC9wcm9jZXNzXCIpO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcm9jZXNzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/app/worker.js":
/*!***************************!*\
  !*** ./src/app/worker.js ***!
  \***************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _xenova_transformers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @xenova/transformers */ \"(app-pages-browser)/./node_modules/@xenova/transformers/src/transformers.js\");\n\n// Skip local model check\n_xenova_transformers__WEBPACK_IMPORTED_MODULE_0__.env.allowLocalModels = false;\n// Use the Singleton pattern to enable lazy construction of the pipeline.\nclass PipelineSingleton {\n    static async getInstance() {\n        let progress_callback = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;\n        if (this.instance === null) {\n            this.instance = (0,_xenova_transformers__WEBPACK_IMPORTED_MODULE_0__.pipeline)(this.task, this.model, {\n                progress_callback\n            });\n        }\n        return this.instance;\n    }\n}\n(()=>{\n    PipelineSingleton.task = \"text-classification\";\n})();\n(()=>{\n    PipelineSingleton.model = \"Xenova/distilbert-base-uncased-finetuned-sst-2-english\";\n})();\n(()=>{\n    PipelineSingleton.instance = null;\n})();\n// Listen for messages from the main thread\nself.addEventListener(\"message\", async (event)=>{\n    // Retrieve the classification pipeline. When called for the first time,\n    // this will load the pipeline and save it for future use.\n    let classifier = await PipelineSingleton.getInstance((x)=>{\n        // We also add a progress callback to the pipeline so that we can\n        // track model loading.\n        self.postMessage(x);\n    });\n    // Actually perform the classification\n    let output = await classifier(event.data.text);\n    // Send the output back to the main thread\n    self.postMessage({\n        status: \"complete\",\n        output: output\n    });\n});\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvd29ya2VyLmpzIiwibWFwcGluZ3MiOiI7O0FBQXFEO0FBRXJELHlCQUF5QjtBQUN6QkMscURBQUdBLENBQUNDLGdCQUFnQixHQUFHO0FBRXZCLHlFQUF5RTtBQUN6RSxNQUFNQztJQUtGLGFBQWFDLGNBQXNDO1lBQTFCQyxvQkFBQUEsaUVBQW9CO1FBQ3pDLElBQUksSUFBSSxDQUFDQyxRQUFRLEtBQUssTUFBTTtZQUN4QixJQUFJLENBQUNBLFFBQVEsR0FBR04sOERBQVFBLENBQUMsSUFBSSxDQUFDTyxJQUFJLEVBQUUsSUFBSSxDQUFDQyxLQUFLLEVBQUU7Z0JBQUVIO1lBQWtCO1FBQ3hFO1FBQ0EsT0FBTyxJQUFJLENBQUNDLFFBQVE7SUFDeEI7QUFDSjs7SUFYTUgsa0JBQ0tJLE9BQU87OztJQURaSixrQkFFS0ssUUFBUTs7O0lBRmJMLGtCQUdLRyxXQUFXOztBQVV0QiwyQ0FBMkM7QUFDM0NHLEtBQUtDLGdCQUFnQixDQUFDLFdBQVcsT0FBT0M7SUFDcEMsd0VBQXdFO0lBQ3hFLDBEQUEwRDtJQUMxRCxJQUFJQyxhQUFhLE1BQU1ULGtCQUFrQkMsV0FBVyxDQUFDUyxDQUFBQTtRQUNqRCxpRUFBaUU7UUFDakUsdUJBQXVCO1FBQ3ZCSixLQUFLSyxXQUFXLENBQUNEO0lBQ3JCO0lBRUEsc0NBQXNDO0lBQ3RDLElBQUlFLFNBQVMsTUFBTUgsV0FBV0QsTUFBTUssSUFBSSxDQUFDQyxJQUFJO0lBRTdDLDBDQUEwQztJQUMxQ1IsS0FBS0ssV0FBVyxDQUFDO1FBQ2JJLFFBQVE7UUFDUkgsUUFBUUE7SUFDWjtBQUNKIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9hcHAvd29ya2VyLmpzP2VkMDkiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgcGlwZWxpbmUsIGVudiB9IGZyb20gXCJAeGVub3ZhL3RyYW5zZm9ybWVyc1wiO1xuXG4vLyBTa2lwIGxvY2FsIG1vZGVsIGNoZWNrXG5lbnYuYWxsb3dMb2NhbE1vZGVscyA9IGZhbHNlO1xuXG4vLyBVc2UgdGhlIFNpbmdsZXRvbiBwYXR0ZXJuIHRvIGVuYWJsZSBsYXp5IGNvbnN0cnVjdGlvbiBvZiB0aGUgcGlwZWxpbmUuXG5jbGFzcyBQaXBlbGluZVNpbmdsZXRvbiB7XG4gICAgc3RhdGljIHRhc2sgPSAndGV4dC1jbGFzc2lmaWNhdGlvbic7XG4gICAgc3RhdGljIG1vZGVsID0gJ1hlbm92YS9kaXN0aWxiZXJ0LWJhc2UtdW5jYXNlZC1maW5ldHVuZWQtc3N0LTItZW5nbGlzaCc7XG4gICAgc3RhdGljIGluc3RhbmNlID0gbnVsbDtcblxuICAgIHN0YXRpYyBhc3luYyBnZXRJbnN0YW5jZShwcm9ncmVzc19jYWxsYmFjayA9IG51bGwpIHtcbiAgICAgICAgaWYgKHRoaXMuaW5zdGFuY2UgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuaW5zdGFuY2UgPSBwaXBlbGluZSh0aGlzLnRhc2ssIHRoaXMubW9kZWwsIHsgcHJvZ3Jlc3NfY2FsbGJhY2sgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuaW5zdGFuY2U7XG4gICAgfVxufVxuXG4vLyBMaXN0ZW4gZm9yIG1lc3NhZ2VzIGZyb20gdGhlIG1haW4gdGhyZWFkXG5zZWxmLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBhc3luYyAoZXZlbnQpID0+IHtcbiAgICAvLyBSZXRyaWV2ZSB0aGUgY2xhc3NpZmljYXRpb24gcGlwZWxpbmUuIFdoZW4gY2FsbGVkIGZvciB0aGUgZmlyc3QgdGltZSxcbiAgICAvLyB0aGlzIHdpbGwgbG9hZCB0aGUgcGlwZWxpbmUgYW5kIHNhdmUgaXQgZm9yIGZ1dHVyZSB1c2UuXG4gICAgbGV0IGNsYXNzaWZpZXIgPSBhd2FpdCBQaXBlbGluZVNpbmdsZXRvbi5nZXRJbnN0YW5jZSh4ID0+IHtcbiAgICAgICAgLy8gV2UgYWxzbyBhZGQgYSBwcm9ncmVzcyBjYWxsYmFjayB0byB0aGUgcGlwZWxpbmUgc28gdGhhdCB3ZSBjYW5cbiAgICAgICAgLy8gdHJhY2sgbW9kZWwgbG9hZGluZy5cbiAgICAgICAgc2VsZi5wb3N0TWVzc2FnZSh4KTtcbiAgICB9KTtcblxuICAgIC8vIEFjdHVhbGx5IHBlcmZvcm0gdGhlIGNsYXNzaWZpY2F0aW9uXG4gICAgbGV0IG91dHB1dCA9IGF3YWl0IGNsYXNzaWZpZXIoZXZlbnQuZGF0YS50ZXh0KTtcblxuICAgIC8vIFNlbmQgdGhlIG91dHB1dCBiYWNrIHRvIHRoZSBtYWluIHRocmVhZFxuICAgIHNlbGYucG9zdE1lc3NhZ2Uoe1xuICAgICAgICBzdGF0dXM6ICdjb21wbGV0ZScsXG4gICAgICAgIG91dHB1dDogb3V0cHV0LFxuICAgIH0pO1xufSk7Il0sIm5hbWVzIjpbInBpcGVsaW5lIiwiZW52IiwiYWxsb3dMb2NhbE1vZGVscyIsIlBpcGVsaW5lU2luZ2xldG9uIiwiZ2V0SW5zdGFuY2UiLCJwcm9ncmVzc19jYWxsYmFjayIsImluc3RhbmNlIiwidGFzayIsIm1vZGVsIiwic2VsZiIsImFkZEV2ZW50TGlzdGVuZXIiLCJldmVudCIsImNsYXNzaWZpZXIiLCJ4IiwicG9zdE1lc3NhZ2UiLCJvdXRwdXQiLCJkYXRhIiwidGV4dCIsInN0YXR1cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/worker.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/native-url/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/next/dist/compiled/native-url/index.js ***!
  \*************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var __dirname = \"/\";\n(function(){var e={452:function(e){\"use strict\";e.exports=__webpack_require__(/*! next/dist/compiled/querystring-es3 */ \"(app-pages-browser)/./node_modules/next/dist/compiled/querystring-es3/index.js\")}};var t={};function __nccwpck_require__(o){var a=t[o];if(a!==undefined){return a.exports}var s=t[o]={exports:{}};var n=true;try{e[o](s,s.exports,__nccwpck_require__);n=false}finally{if(n)delete t[o]}return s.exports}if(typeof __nccwpck_require__!==\"undefined\")__nccwpck_require__.ab=__dirname+\"/\";var o={};!function(){var e=o;var t,a=(t=__nccwpck_require__(452))&&\"object\"==typeof t&&\"default\"in t?t.default:t,s=/https?|ftp|gopher|file/;function r(e){\"string\"==typeof e&&(e=d(e));var t=function(e,t,o){var a=e.auth,s=e.hostname,n=e.protocol||\"\",p=e.pathname||\"\",c=e.hash||\"\",i=e.query||\"\",u=!1;a=a?encodeURIComponent(a).replace(/%3A/i,\":\")+\"@\":\"\",e.host?u=a+e.host:s&&(u=a+(~s.indexOf(\":\")?\"[\"+s+\"]\":s),e.port&&(u+=\":\"+e.port)),i&&\"object\"==typeof i&&(i=t.encode(i));var f=e.search||i&&\"?\"+i||\"\";return n&&\":\"!==n.substr(-1)&&(n+=\":\"),e.slashes||(!n||o.test(n))&&!1!==u?(u=\"//\"+(u||\"\"),p&&\"/\"!==p[0]&&(p=\"/\"+p)):u||(u=\"\"),c&&\"#\"!==c[0]&&(c=\"#\"+c),f&&\"?\"!==f[0]&&(f=\"?\"+f),{protocol:n,host:u,pathname:p=p.replace(/[?#]/g,encodeURIComponent),search:f=f.replace(\"#\",\"%23\"),hash:c}}(e,a,s);return\"\"+t.protocol+t.host+t.pathname+t.search+t.hash}var n=\"http://\",p=\"w.w\",c=n+p,i=/^([a-z0-9.+-]*:\\/\\/\\/)([a-z0-9.+-]:\\/*)?/i,u=/https?|ftp|gopher|file/;function h(e,t){var o=\"string\"==typeof e?d(e):e;e=\"object\"==typeof e?r(e):e;var a=d(t),s=\"\";o.protocol&&!o.slashes&&(s=o.protocol,e=e.replace(o.protocol,\"\"),s+=\"/\"===t[0]||\"/\"===e[0]?\"/\":\"\"),s&&a.protocol&&(s=\"\",a.slashes||(s=a.protocol,t=t.replace(a.protocol,\"\")));var p=e.match(i);p&&!a.protocol&&(e=e.substr((s=p[1]+(p[2]||\"\")).length),/^\\/\\/[^/]/.test(t)&&(s=s.slice(0,-1)));var f=new URL(e,c+\"/\"),m=new URL(t,f).toString().replace(c,\"\"),v=a.protocol||o.protocol;return v+=o.slashes||a.slashes?\"//\":\"\",!s&&v?m=m.replace(n,v):s&&(m=m.replace(n,\"\")),u.test(m)||~t.indexOf(\".\")||\"/\"===e.slice(-1)||\"/\"===t.slice(-1)||\"/\"!==m.slice(-1)||(m=m.slice(0,-1)),s&&(m=s+(\"/\"===m[0]?m.substr(1):m)),m}function l(){}l.prototype.parse=d,l.prototype.format=r,l.prototype.resolve=h,l.prototype.resolveObject=h;var f=/^https?|ftp|gopher|file/,m=/^(.*?)([#?].*)/,v=/^([a-z0-9.+-]*:)(\\/{0,3})(.*)/i,_=/^([a-z0-9.+-]*:)?\\/\\/\\/*/i,b=/^([a-z0-9.+-]*:)(\\/{0,2})\\[(.*)\\]$/i;function d(e,t,o){if(void 0===t&&(t=!1),void 0===o&&(o=!1),e&&\"object\"==typeof e&&e instanceof l)return e;var s=(e=e.trim()).match(m);e=s?s[1].replace(/\\\\/g,\"/\")+s[2]:e.replace(/\\\\/g,\"/\"),b.test(e)&&\"/\"!==e.slice(-1)&&(e+=\"/\");var n=!/(^javascript)/.test(e)&&e.match(v),i=_.test(e),u=\"\";n&&(f.test(n[1])||(u=n[1].toLowerCase(),e=\"\"+n[2]+n[3]),n[2]||(i=!1,f.test(n[1])?(u=n[1],e=\"\"+n[3]):e=\"//\"+n[3]),3!==n[2].length&&1!==n[2].length||(u=n[1],e=\"/\"+n[3]));var g,y=(s?s[1]:e).match(/^https?:\\/\\/[^/]+(:[0-9]+)(?=\\/|$)/),w=y&&y[1],x=new l,C=\"\",U=\"\";try{g=new URL(e)}catch(t){C=t,u||o||!/^\\/\\//.test(e)||/^\\/\\/.+[@.]/.test(e)||(U=\"/\",e=e.substr(1));try{g=new URL(e,c)}catch(e){return x.protocol=u,x.href=u,x}}x.slashes=i&&!U,x.host=g.host===p?\"\":g.host,x.hostname=g.hostname===p?\"\":g.hostname.replace(/(\\[|\\])/g,\"\"),x.protocol=C?u||null:g.protocol,x.search=g.search.replace(/\\\\/g,\"%5C\"),x.hash=g.hash.replace(/\\\\/g,\"%5C\");var j=e.split(\"#\");!x.search&&~j[0].indexOf(\"?\")&&(x.search=\"?\"),x.hash||\"\"!==j[1]||(x.hash=\"#\"),x.query=t?a.decode(g.search.substr(1)):x.search.substr(1),x.pathname=U+(n?function(e){return e.replace(/['^|`]/g,(function(e){return\"%\"+e.charCodeAt().toString(16).toUpperCase()})).replace(/((?:%[0-9A-F]{2})+)/g,(function(e,t){try{return decodeURIComponent(t).split(\"\").map((function(e){var t=e.charCodeAt();return t>256||/^[a-z0-9]$/i.test(e)?e:\"%\"+t.toString(16).toUpperCase()})).join(\"\")}catch(e){return t}}))}(g.pathname):g.pathname),\"about:\"===x.protocol&&\"blank\"===x.pathname&&(x.protocol=\"\",x.pathname=\"\"),C&&\"/\"!==e[0]&&(x.pathname=x.pathname.substr(1)),u&&!f.test(u)&&\"/\"!==e.slice(-1)&&\"/\"===x.pathname&&(x.pathname=\"\"),x.path=x.pathname+x.search,x.auth=[g.username,g.password].map(decodeURIComponent).filter(Boolean).join(\":\"),x.port=g.port,w&&!x.host.endsWith(w)&&(x.host+=w,x.port=w.slice(1)),x.href=U?\"\"+x.pathname+x.search+x.hash:r(x);var q=/^(file)/.test(x.href)?[\"host\",\"hostname\"]:[];return Object.keys(x).forEach((function(e){~q.indexOf(e)||(x[e]=x[e]||null)})),x}e.parse=d,e.format=r,e.resolve=h,e.resolveObject=function(e,t){return d(h(e,t))},e.Url=l}();module.exports=o})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvbmF0aXZlLXVybC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiO0FBQUEsWUFBWSxPQUFPLGdCQUFnQixhQUFhLFVBQVUsbUJBQU8sQ0FBQywwSEFBb0MsSUFBSSxTQUFTLGdDQUFnQyxXQUFXLGtCQUFrQixpQkFBaUIsWUFBWSxZQUFZLFdBQVcsSUFBSSxzQ0FBc0MsUUFBUSxRQUFRLGlCQUFpQixpQkFBaUIsbUVBQW1FLFNBQVMsS0FBSyxTQUFTLFlBQVksUUFBUSwrR0FBK0csY0FBYyw2QkFBNkIsc0JBQXNCLDRGQUE0Riw2S0FBNkssNkJBQTZCLGlMQUFpTCx5R0FBeUcsUUFBUSxzREFBc0QsdUdBQXVHLGdCQUFnQixnQ0FBZ0MsNEJBQTRCLGdCQUFnQiw4S0FBOEssaUJBQWlCLGdHQUFnRyx3RkFBd0Ysa09BQWtPLGNBQWMsMkZBQTJGLDBFQUEwRSxJQUFJLDZEQUE2RCxJQUFJLGFBQWEsa0JBQWtCLHdGQUF3Riw0QkFBNEIsNkZBQTZGLDREQUE0RCx3S0FBd0ssMkZBQTJGLElBQUksYUFBYSxTQUFTLHlFQUF5RSxJQUFJLGVBQWUsU0FBUyxnQ0FBZ0MscU5BQXFOLG1CQUFtQixvS0FBb0ssd0NBQXdDLG9EQUFvRCwwQkFBMEIsRUFBRSxxQkFBcUIsSUFBSSx3REFBd0QscUJBQXFCLHVFQUF1RSxZQUFZLFNBQVMsVUFBVSxHQUFHLHFiQUFxYixvREFBb0QsMkNBQTJDLGlDQUFpQyxLQUFLLCtEQUErRCxpQkFBaUIsU0FBUyxHQUFHLGlCQUFpQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL25hdGl2ZS11cmwvaW5kZXguanM/OTY0ZiJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24oKXt2YXIgZT17NDUyOmZ1bmN0aW9uKGUpe1widXNlIHN0cmljdFwiO2UuZXhwb3J0cz1yZXF1aXJlKFwibmV4dC9kaXN0L2NvbXBpbGVkL3F1ZXJ5c3RyaW5nLWVzM1wiKX19O3ZhciB0PXt9O2Z1bmN0aW9uIF9fbmNjd3Bja19yZXF1aXJlX18obyl7dmFyIGE9dFtvXTtpZihhIT09dW5kZWZpbmVkKXtyZXR1cm4gYS5leHBvcnRzfXZhciBzPXRbb109e2V4cG9ydHM6e319O3ZhciBuPXRydWU7dHJ5e2Vbb10ocyxzLmV4cG9ydHMsX19uY2N3cGNrX3JlcXVpcmVfXyk7bj1mYWxzZX1maW5hbGx5e2lmKG4pZGVsZXRlIHRbb119cmV0dXJuIHMuZXhwb3J0c31pZih0eXBlb2YgX19uY2N3cGNrX3JlcXVpcmVfXyE9PVwidW5kZWZpbmVkXCIpX19uY2N3cGNrX3JlcXVpcmVfXy5hYj1fX2Rpcm5hbWUrXCIvXCI7dmFyIG89e307IWZ1bmN0aW9uKCl7dmFyIGU9bzt2YXIgdCxhPSh0PV9fbmNjd3Bja19yZXF1aXJlX18oNDUyKSkmJlwib2JqZWN0XCI9PXR5cGVvZiB0JiZcImRlZmF1bHRcImluIHQ/dC5kZWZhdWx0OnQscz0vaHR0cHM/fGZ0cHxnb3BoZXJ8ZmlsZS87ZnVuY3Rpb24gcihlKXtcInN0cmluZ1wiPT10eXBlb2YgZSYmKGU9ZChlKSk7dmFyIHQ9ZnVuY3Rpb24oZSx0LG8pe3ZhciBhPWUuYXV0aCxzPWUuaG9zdG5hbWUsbj1lLnByb3RvY29sfHxcIlwiLHA9ZS5wYXRobmFtZXx8XCJcIixjPWUuaGFzaHx8XCJcIixpPWUucXVlcnl8fFwiXCIsdT0hMTthPWE/ZW5jb2RlVVJJQ29tcG9uZW50KGEpLnJlcGxhY2UoLyUzQS9pLFwiOlwiKStcIkBcIjpcIlwiLGUuaG9zdD91PWErZS5ob3N0OnMmJih1PWErKH5zLmluZGV4T2YoXCI6XCIpP1wiW1wiK3MrXCJdXCI6cyksZS5wb3J0JiYodSs9XCI6XCIrZS5wb3J0KSksaSYmXCJvYmplY3RcIj09dHlwZW9mIGkmJihpPXQuZW5jb2RlKGkpKTt2YXIgZj1lLnNlYXJjaHx8aSYmXCI/XCIraXx8XCJcIjtyZXR1cm4gbiYmXCI6XCIhPT1uLnN1YnN0cigtMSkmJihuKz1cIjpcIiksZS5zbGFzaGVzfHwoIW58fG8udGVzdChuKSkmJiExIT09dT8odT1cIi8vXCIrKHV8fFwiXCIpLHAmJlwiL1wiIT09cFswXSYmKHA9XCIvXCIrcCkpOnV8fCh1PVwiXCIpLGMmJlwiI1wiIT09Y1swXSYmKGM9XCIjXCIrYyksZiYmXCI/XCIhPT1mWzBdJiYoZj1cIj9cIitmKSx7cHJvdG9jb2w6bixob3N0OnUscGF0aG5hbWU6cD1wLnJlcGxhY2UoL1s/I10vZyxlbmNvZGVVUklDb21wb25lbnQpLHNlYXJjaDpmPWYucmVwbGFjZShcIiNcIixcIiUyM1wiKSxoYXNoOmN9fShlLGEscyk7cmV0dXJuXCJcIit0LnByb3RvY29sK3QuaG9zdCt0LnBhdGhuYW1lK3Quc2VhcmNoK3QuaGFzaH12YXIgbj1cImh0dHA6Ly9cIixwPVwidy53XCIsYz1uK3AsaT0vXihbYS16MC05ListXSo6XFwvXFwvXFwvKShbYS16MC05ListXTpcXC8qKT8vaSx1PS9odHRwcz98ZnRwfGdvcGhlcnxmaWxlLztmdW5jdGlvbiBoKGUsdCl7dmFyIG89XCJzdHJpbmdcIj09dHlwZW9mIGU/ZChlKTplO2U9XCJvYmplY3RcIj09dHlwZW9mIGU/cihlKTplO3ZhciBhPWQodCkscz1cIlwiO28ucHJvdG9jb2wmJiFvLnNsYXNoZXMmJihzPW8ucHJvdG9jb2wsZT1lLnJlcGxhY2Uoby5wcm90b2NvbCxcIlwiKSxzKz1cIi9cIj09PXRbMF18fFwiL1wiPT09ZVswXT9cIi9cIjpcIlwiKSxzJiZhLnByb3RvY29sJiYocz1cIlwiLGEuc2xhc2hlc3x8KHM9YS5wcm90b2NvbCx0PXQucmVwbGFjZShhLnByb3RvY29sLFwiXCIpKSk7dmFyIHA9ZS5tYXRjaChpKTtwJiYhYS5wcm90b2NvbCYmKGU9ZS5zdWJzdHIoKHM9cFsxXSsocFsyXXx8XCJcIikpLmxlbmd0aCksL15cXC9cXC9bXi9dLy50ZXN0KHQpJiYocz1zLnNsaWNlKDAsLTEpKSk7dmFyIGY9bmV3IFVSTChlLGMrXCIvXCIpLG09bmV3IFVSTCh0LGYpLnRvU3RyaW5nKCkucmVwbGFjZShjLFwiXCIpLHY9YS5wcm90b2NvbHx8by5wcm90b2NvbDtyZXR1cm4gdis9by5zbGFzaGVzfHxhLnNsYXNoZXM/XCIvL1wiOlwiXCIsIXMmJnY/bT1tLnJlcGxhY2Uobix2KTpzJiYobT1tLnJlcGxhY2UobixcIlwiKSksdS50ZXN0KG0pfHx+dC5pbmRleE9mKFwiLlwiKXx8XCIvXCI9PT1lLnNsaWNlKC0xKXx8XCIvXCI9PT10LnNsaWNlKC0xKXx8XCIvXCIhPT1tLnNsaWNlKC0xKXx8KG09bS5zbGljZSgwLC0xKSkscyYmKG09cysoXCIvXCI9PT1tWzBdP20uc3Vic3RyKDEpOm0pKSxtfWZ1bmN0aW9uIGwoKXt9bC5wcm90b3R5cGUucGFyc2U9ZCxsLnByb3RvdHlwZS5mb3JtYXQ9cixsLnByb3RvdHlwZS5yZXNvbHZlPWgsbC5wcm90b3R5cGUucmVzb2x2ZU9iamVjdD1oO3ZhciBmPS9eaHR0cHM/fGZ0cHxnb3BoZXJ8ZmlsZS8sbT0vXiguKj8pKFsjP10uKikvLHY9L14oW2EtejAtOS4rLV0qOikoXFwvezAsM30pKC4qKS9pLF89L14oW2EtejAtOS4rLV0qOik/XFwvXFwvXFwvKi9pLGI9L14oW2EtejAtOS4rLV0qOikoXFwvezAsMn0pXFxbKC4qKVxcXSQvaTtmdW5jdGlvbiBkKGUsdCxvKXtpZih2b2lkIDA9PT10JiYodD0hMSksdm9pZCAwPT09byYmKG89ITEpLGUmJlwib2JqZWN0XCI9PXR5cGVvZiBlJiZlIGluc3RhbmNlb2YgbClyZXR1cm4gZTt2YXIgcz0oZT1lLnRyaW0oKSkubWF0Y2gobSk7ZT1zP3NbMV0ucmVwbGFjZSgvXFxcXC9nLFwiL1wiKStzWzJdOmUucmVwbGFjZSgvXFxcXC9nLFwiL1wiKSxiLnRlc3QoZSkmJlwiL1wiIT09ZS5zbGljZSgtMSkmJihlKz1cIi9cIik7dmFyIG49IS8oXmphdmFzY3JpcHQpLy50ZXN0KGUpJiZlLm1hdGNoKHYpLGk9Xy50ZXN0KGUpLHU9XCJcIjtuJiYoZi50ZXN0KG5bMV0pfHwodT1uWzFdLnRvTG93ZXJDYXNlKCksZT1cIlwiK25bMl0rblszXSksblsyXXx8KGk9ITEsZi50ZXN0KG5bMV0pPyh1PW5bMV0sZT1cIlwiK25bM10pOmU9XCIvL1wiK25bM10pLDMhPT1uWzJdLmxlbmd0aCYmMSE9PW5bMl0ubGVuZ3RofHwodT1uWzFdLGU9XCIvXCIrblszXSkpO3ZhciBnLHk9KHM/c1sxXTplKS5tYXRjaCgvXmh0dHBzPzpcXC9cXC9bXi9dKyg6WzAtOV0rKSg/PVxcL3wkKS8pLHc9eSYmeVsxXSx4PW5ldyBsLEM9XCJcIixVPVwiXCI7dHJ5e2c9bmV3IFVSTChlKX1jYXRjaCh0KXtDPXQsdXx8b3x8IS9eXFwvXFwvLy50ZXN0KGUpfHwvXlxcL1xcLy4rW0AuXS8udGVzdChlKXx8KFU9XCIvXCIsZT1lLnN1YnN0cigxKSk7dHJ5e2c9bmV3IFVSTChlLGMpfWNhdGNoKGUpe3JldHVybiB4LnByb3RvY29sPXUseC5ocmVmPXUseH19eC5zbGFzaGVzPWkmJiFVLHguaG9zdD1nLmhvc3Q9PT1wP1wiXCI6Zy5ob3N0LHguaG9zdG5hbWU9Zy5ob3N0bmFtZT09PXA/XCJcIjpnLmhvc3RuYW1lLnJlcGxhY2UoLyhcXFt8XFxdKS9nLFwiXCIpLHgucHJvdG9jb2w9Qz91fHxudWxsOmcucHJvdG9jb2wseC5zZWFyY2g9Zy5zZWFyY2gucmVwbGFjZSgvXFxcXC9nLFwiJTVDXCIpLHguaGFzaD1nLmhhc2gucmVwbGFjZSgvXFxcXC9nLFwiJTVDXCIpO3ZhciBqPWUuc3BsaXQoXCIjXCIpOyF4LnNlYXJjaCYmfmpbMF0uaW5kZXhPZihcIj9cIikmJih4LnNlYXJjaD1cIj9cIikseC5oYXNofHxcIlwiIT09alsxXXx8KHguaGFzaD1cIiNcIikseC5xdWVyeT10P2EuZGVjb2RlKGcuc2VhcmNoLnN1YnN0cigxKSk6eC5zZWFyY2guc3Vic3RyKDEpLHgucGF0aG5hbWU9VSsobj9mdW5jdGlvbihlKXtyZXR1cm4gZS5yZXBsYWNlKC9bJ158YF0vZywoZnVuY3Rpb24oZSl7cmV0dXJuXCIlXCIrZS5jaGFyQ29kZUF0KCkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCl9KSkucmVwbGFjZSgvKCg/OiVbMC05QS1GXXsyfSkrKS9nLChmdW5jdGlvbihlLHQpe3RyeXtyZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KHQpLnNwbGl0KFwiXCIpLm1hcCgoZnVuY3Rpb24oZSl7dmFyIHQ9ZS5jaGFyQ29kZUF0KCk7cmV0dXJuIHQ+MjU2fHwvXlthLXowLTldJC9pLnRlc3QoZSk/ZTpcIiVcIit0LnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpfSkpLmpvaW4oXCJcIil9Y2F0Y2goZSl7cmV0dXJuIHR9fSkpfShnLnBhdGhuYW1lKTpnLnBhdGhuYW1lKSxcImFib3V0OlwiPT09eC5wcm90b2NvbCYmXCJibGFua1wiPT09eC5wYXRobmFtZSYmKHgucHJvdG9jb2w9XCJcIix4LnBhdGhuYW1lPVwiXCIpLEMmJlwiL1wiIT09ZVswXSYmKHgucGF0aG5hbWU9eC5wYXRobmFtZS5zdWJzdHIoMSkpLHUmJiFmLnRlc3QodSkmJlwiL1wiIT09ZS5zbGljZSgtMSkmJlwiL1wiPT09eC5wYXRobmFtZSYmKHgucGF0aG5hbWU9XCJcIikseC5wYXRoPXgucGF0aG5hbWUreC5zZWFyY2gseC5hdXRoPVtnLnVzZXJuYW1lLGcucGFzc3dvcmRdLm1hcChkZWNvZGVVUklDb21wb25lbnQpLmZpbHRlcihCb29sZWFuKS5qb2luKFwiOlwiKSx4LnBvcnQ9Zy5wb3J0LHcmJiF4Lmhvc3QuZW5kc1dpdGgodykmJih4Lmhvc3QrPXcseC5wb3J0PXcuc2xpY2UoMSkpLHguaHJlZj1VP1wiXCIreC5wYXRobmFtZSt4LnNlYXJjaCt4Lmhhc2g6cih4KTt2YXIgcT0vXihmaWxlKS8udGVzdCh4LmhyZWYpP1tcImhvc3RcIixcImhvc3RuYW1lXCJdOltdO3JldHVybiBPYmplY3Qua2V5cyh4KS5mb3JFYWNoKChmdW5jdGlvbihlKXt+cS5pbmRleE9mKGUpfHwoeFtlXT14W2VdfHxudWxsKX0pKSx4fWUucGFyc2U9ZCxlLmZvcm1hdD1yLGUucmVzb2x2ZT1oLGUucmVzb2x2ZU9iamVjdD1mdW5jdGlvbihlLHQpe3JldHVybiBkKGgoZSx0KSl9LGUuVXJsPWx9KCk7bW9kdWxlLmV4cG9ydHM9b30pKCk7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/native-url/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/process/browser.js":
/*!************************************************************!*\
  !*** ./node_modules/next/dist/compiled/process/browser.js ***!
  \************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var __dirname = \"/\";\n(function(){var e={229:function(e){var t=e.exports={};var r;var n;function defaultSetTimout(){throw new Error(\"setTimeout has not been defined\")}function defaultClearTimeout(){throw new Error(\"clearTimeout has not been defined\")}(function(){try{if(typeof setTimeout===\"function\"){r=setTimeout}else{r=defaultSetTimout}}catch(e){r=defaultSetTimout}try{if(typeof clearTimeout===\"function\"){n=clearTimeout}else{n=defaultClearTimeout}}catch(e){n=defaultClearTimeout}})();function runTimeout(e){if(r===setTimeout){return setTimeout(e,0)}if((r===defaultSetTimout||!r)&&setTimeout){r=setTimeout;return setTimeout(e,0)}try{return r(e,0)}catch(t){try{return r.call(null,e,0)}catch(t){return r.call(this,e,0)}}}function runClearTimeout(e){if(n===clearTimeout){return clearTimeout(e)}if((n===defaultClearTimeout||!n)&&clearTimeout){n=clearTimeout;return clearTimeout(e)}try{return n(e)}catch(t){try{return n.call(null,e)}catch(t){return n.call(this,e)}}}var i=[];var o=false;var u;var a=-1;function cleanUpNextTick(){if(!o||!u){return}o=false;if(u.length){i=u.concat(i)}else{a=-1}if(i.length){drainQueue()}}function drainQueue(){if(o){return}var e=runTimeout(cleanUpNextTick);o=true;var t=i.length;while(t){u=i;i=[];while(++a<t){if(u){u[a].run()}}a=-1;t=i.length}u=null;o=false;runClearTimeout(e)}t.nextTick=function(e){var t=new Array(arguments.length-1);if(arguments.length>1){for(var r=1;r<arguments.length;r++){t[r-1]=arguments[r]}}i.push(new Item(e,t));if(i.length===1&&!o){runTimeout(drainQueue)}};function Item(e,t){this.fun=e;this.array=t}Item.prototype.run=function(){this.fun.apply(null,this.array)};t.title=\"browser\";t.browser=true;t.env={};t.argv=[];t.version=\"\";t.versions={};function noop(){}t.on=noop;t.addListener=noop;t.once=noop;t.off=noop;t.removeListener=noop;t.removeAllListeners=noop;t.emit=noop;t.prependListener=noop;t.prependOnceListener=noop;t.listeners=function(e){return[]};t.binding=function(e){throw new Error(\"process.binding is not supported\")};t.cwd=function(){return\"/\"};t.chdir=function(e){throw new Error(\"process.chdir is not supported\")};t.umask=function(){return 0}}};var t={};function __nccwpck_require__(r){var n=t[r];if(n!==undefined){return n.exports}var i=t[r]={exports:{}};var o=true;try{e[r](i,i.exports,__nccwpck_require__);o=false}finally{if(o)delete t[r]}return i.exports}if(typeof __nccwpck_require__!==\"undefined\")__nccwpck_require__.ab=__dirname+\"/\";var r=__nccwpck_require__(229);module.exports=r})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcHJvY2Vzcy9icm93c2VyLmpzIiwibWFwcGluZ3MiOiI7QUFBQSxZQUFZLE9BQU8sZ0JBQWdCLG1CQUFtQixNQUFNLE1BQU0sNEJBQTRCLG1EQUFtRCwrQkFBK0IscURBQXFELFlBQVksSUFBSSxtQ0FBbUMsYUFBYSxLQUFLLG9CQUFvQixTQUFTLG1CQUFtQixJQUFJLHFDQUFxQyxlQUFlLEtBQUssdUJBQXVCLFNBQVMsdUJBQXVCLElBQUksdUJBQXVCLG1CQUFtQix1QkFBdUIsMkNBQTJDLGFBQWEsdUJBQXVCLElBQUksY0FBYyxTQUFTLElBQUksd0JBQXdCLFNBQVMsMEJBQTBCLDRCQUE0QixxQkFBcUIsdUJBQXVCLGdEQUFnRCxlQUFlLHVCQUF1QixJQUFJLFlBQVksU0FBUyxJQUFJLHNCQUFzQixTQUFTLHdCQUF3QixTQUFTLFlBQVksTUFBTSxTQUFTLDJCQUEyQixXQUFXLE9BQU8sUUFBUSxhQUFhLGNBQWMsS0FBSyxLQUFLLGFBQWEsY0FBYyxzQkFBc0IsTUFBTSxPQUFPLGtDQUFrQyxPQUFPLGVBQWUsU0FBUyxJQUFJLEtBQUssYUFBYSxNQUFNLFlBQVksS0FBSyxXQUFXLE9BQU8sUUFBUSxtQkFBbUIsdUJBQXVCLG9DQUFvQyx1QkFBdUIsWUFBWSxtQkFBbUIsS0FBSyxxQkFBcUIsc0JBQXNCLHFCQUFxQix5QkFBeUIsbUJBQW1CLFdBQVcsYUFBYSw4QkFBOEIsaUNBQWlDLGtCQUFrQixlQUFlLFNBQVMsVUFBVSxhQUFhLGNBQWMsaUJBQWlCLFVBQVUsbUJBQW1CLFlBQVksV0FBVyxzQkFBc0IsMEJBQTBCLFlBQVksdUJBQXVCLDJCQUEyQix3QkFBd0IsVUFBVSxzQkFBc0IscURBQXFELGlCQUFpQixXQUFXLG9CQUFvQixtREFBbUQsbUJBQW1CLFlBQVksU0FBUyxnQ0FBZ0MsV0FBVyxrQkFBa0IsaUJBQWlCLFlBQVksWUFBWSxXQUFXLElBQUksc0NBQXNDLFFBQVEsUUFBUSxpQkFBaUIsaUJBQWlCLG1FQUFtRSxTQUFTLEtBQUssK0JBQStCLGlCQUFpQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3Byb2Nlc3MvYnJvd3Nlci5qcz81YjQ3Il0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbigpe3ZhciBlPXsyMjk6ZnVuY3Rpb24oZSl7dmFyIHQ9ZS5leHBvcnRzPXt9O3ZhciByO3ZhciBuO2Z1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKXt0aHJvdyBuZXcgRXJyb3IoXCJzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkXCIpfWZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQoKXt0aHJvdyBuZXcgRXJyb3IoXCJjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWRcIil9KGZ1bmN0aW9uKCl7dHJ5e2lmKHR5cGVvZiBzZXRUaW1lb3V0PT09XCJmdW5jdGlvblwiKXtyPXNldFRpbWVvdXR9ZWxzZXtyPWRlZmF1bHRTZXRUaW1vdXR9fWNhdGNoKGUpe3I9ZGVmYXVsdFNldFRpbW91dH10cnl7aWYodHlwZW9mIGNsZWFyVGltZW91dD09PVwiZnVuY3Rpb25cIil7bj1jbGVhclRpbWVvdXR9ZWxzZXtuPWRlZmF1bHRDbGVhclRpbWVvdXR9fWNhdGNoKGUpe249ZGVmYXVsdENsZWFyVGltZW91dH19KSgpO2Z1bmN0aW9uIHJ1blRpbWVvdXQoZSl7aWYocj09PXNldFRpbWVvdXQpe3JldHVybiBzZXRUaW1lb3V0KGUsMCl9aWYoKHI9PT1kZWZhdWx0U2V0VGltb3V0fHwhcikmJnNldFRpbWVvdXQpe3I9c2V0VGltZW91dDtyZXR1cm4gc2V0VGltZW91dChlLDApfXRyeXtyZXR1cm4gcihlLDApfWNhdGNoKHQpe3RyeXtyZXR1cm4gci5jYWxsKG51bGwsZSwwKX1jYXRjaCh0KXtyZXR1cm4gci5jYWxsKHRoaXMsZSwwKX19fWZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChlKXtpZihuPT09Y2xlYXJUaW1lb3V0KXtyZXR1cm4gY2xlYXJUaW1lb3V0KGUpfWlmKChuPT09ZGVmYXVsdENsZWFyVGltZW91dHx8IW4pJiZjbGVhclRpbWVvdXQpe249Y2xlYXJUaW1lb3V0O3JldHVybiBjbGVhclRpbWVvdXQoZSl9dHJ5e3JldHVybiBuKGUpfWNhdGNoKHQpe3RyeXtyZXR1cm4gbi5jYWxsKG51bGwsZSl9Y2F0Y2godCl7cmV0dXJuIG4uY2FsbCh0aGlzLGUpfX19dmFyIGk9W107dmFyIG89ZmFsc2U7dmFyIHU7dmFyIGE9LTE7ZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCl7aWYoIW98fCF1KXtyZXR1cm59bz1mYWxzZTtpZih1Lmxlbmd0aCl7aT11LmNvbmNhdChpKX1lbHNle2E9LTF9aWYoaS5sZW5ndGgpe2RyYWluUXVldWUoKX19ZnVuY3Rpb24gZHJhaW5RdWV1ZSgpe2lmKG8pe3JldHVybn12YXIgZT1ydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7bz10cnVlO3ZhciB0PWkubGVuZ3RoO3doaWxlKHQpe3U9aTtpPVtdO3doaWxlKCsrYTx0KXtpZih1KXt1W2FdLnJ1bigpfX1hPS0xO3Q9aS5sZW5ndGh9dT1udWxsO289ZmFsc2U7cnVuQ2xlYXJUaW1lb3V0KGUpfXQubmV4dFRpY2s9ZnVuY3Rpb24oZSl7dmFyIHQ9bmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgtMSk7aWYoYXJndW1lbnRzLmxlbmd0aD4xKXtmb3IodmFyIHI9MTtyPGFyZ3VtZW50cy5sZW5ndGg7cisrKXt0W3ItMV09YXJndW1lbnRzW3JdfX1pLnB1c2gobmV3IEl0ZW0oZSx0KSk7aWYoaS5sZW5ndGg9PT0xJiYhbyl7cnVuVGltZW91dChkcmFpblF1ZXVlKX19O2Z1bmN0aW9uIEl0ZW0oZSx0KXt0aGlzLmZ1bj1lO3RoaXMuYXJyYXk9dH1JdGVtLnByb3RvdHlwZS5ydW49ZnVuY3Rpb24oKXt0aGlzLmZ1bi5hcHBseShudWxsLHRoaXMuYXJyYXkpfTt0LnRpdGxlPVwiYnJvd3NlclwiO3QuYnJvd3Nlcj10cnVlO3QuZW52PXt9O3QuYXJndj1bXTt0LnZlcnNpb249XCJcIjt0LnZlcnNpb25zPXt9O2Z1bmN0aW9uIG5vb3AoKXt9dC5vbj1ub29wO3QuYWRkTGlzdGVuZXI9bm9vcDt0Lm9uY2U9bm9vcDt0Lm9mZj1ub29wO3QucmVtb3ZlTGlzdGVuZXI9bm9vcDt0LnJlbW92ZUFsbExpc3RlbmVycz1ub29wO3QuZW1pdD1ub29wO3QucHJlcGVuZExpc3RlbmVyPW5vb3A7dC5wcmVwZW5kT25jZUxpc3RlbmVyPW5vb3A7dC5saXN0ZW5lcnM9ZnVuY3Rpb24oZSl7cmV0dXJuW119O3QuYmluZGluZz1mdW5jdGlvbihlKXt0aHJvdyBuZXcgRXJyb3IoXCJwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZFwiKX07dC5jd2Q9ZnVuY3Rpb24oKXtyZXR1cm5cIi9cIn07dC5jaGRpcj1mdW5jdGlvbihlKXt0aHJvdyBuZXcgRXJyb3IoXCJwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWRcIil9O3QudW1hc2s9ZnVuY3Rpb24oKXtyZXR1cm4gMH19fTt2YXIgdD17fTtmdW5jdGlvbiBfX25jY3dwY2tfcmVxdWlyZV9fKHIpe3ZhciBuPXRbcl07aWYobiE9PXVuZGVmaW5lZCl7cmV0dXJuIG4uZXhwb3J0c312YXIgaT10W3JdPXtleHBvcnRzOnt9fTt2YXIgbz10cnVlO3RyeXtlW3JdKGksaS5leHBvcnRzLF9fbmNjd3Bja19yZXF1aXJlX18pO289ZmFsc2V9ZmluYWxseXtpZihvKWRlbGV0ZSB0W3JdfXJldHVybiBpLmV4cG9ydHN9aWYodHlwZW9mIF9fbmNjd3Bja19yZXF1aXJlX18hPT1cInVuZGVmaW5lZFwiKV9fbmNjd3Bja19yZXF1aXJlX18uYWI9X19kaXJuYW1lK1wiL1wiO3ZhciByPV9fbmNjd3Bja19yZXF1aXJlX18oMjI5KTttb2R1bGUuZXhwb3J0cz1yfSkoKTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/process/browser.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/querystring-es3/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/next/dist/compiled/querystring-es3/index.js ***!
  \******************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var __dirname = \"/\";\n(function(){\"use strict\";var e={815:function(e){function hasOwnProperty(e,r){return Object.prototype.hasOwnProperty.call(e,r)}e.exports=function(e,n,t,o){n=n||\"&\";t=t||\"=\";var a={};if(typeof e!==\"string\"||e.length===0){return a}var i=/\\+/g;e=e.split(n);var u=1e3;if(o&&typeof o.maxKeys===\"number\"){u=o.maxKeys}var c=e.length;if(u>0&&c>u){c=u}for(var p=0;p<c;++p){var f=e[p].replace(i,\"%20\"),s=f.indexOf(t),_,l,y,d;if(s>=0){_=f.substr(0,s);l=f.substr(s+1)}else{_=f;l=\"\"}y=decodeURIComponent(_);d=decodeURIComponent(l);if(!hasOwnProperty(a,y)){a[y]=d}else if(r(a[y])){a[y].push(d)}else{a[y]=[a[y],d]}}return a};var r=Array.isArray||function(e){return Object.prototype.toString.call(e)===\"[object Array]\"}},577:function(e){var stringifyPrimitive=function(e){switch(typeof e){case\"string\":return e;case\"boolean\":return e?\"true\":\"false\";case\"number\":return isFinite(e)?e:\"\";default:return\"\"}};e.exports=function(e,t,o,a){t=t||\"&\";o=o||\"=\";if(e===null){e=undefined}if(typeof e===\"object\"){return map(n(e),(function(n){var a=encodeURIComponent(stringifyPrimitive(n))+o;if(r(e[n])){return map(e[n],(function(e){return a+encodeURIComponent(stringifyPrimitive(e))})).join(t)}else{return a+encodeURIComponent(stringifyPrimitive(e[n]))}})).join(t)}if(!a)return\"\";return encodeURIComponent(stringifyPrimitive(a))+o+encodeURIComponent(stringifyPrimitive(e))};var r=Array.isArray||function(e){return Object.prototype.toString.call(e)===\"[object Array]\"};function map(e,r){if(e.map)return e.map(r);var n=[];for(var t=0;t<e.length;t++){n.push(r(e[t],t))}return n}var n=Object.keys||function(e){var r=[];for(var n in e){if(Object.prototype.hasOwnProperty.call(e,n))r.push(n)}return r}}};var r={};function __nccwpck_require__(n){var t=r[n];if(t!==undefined){return t.exports}var o=r[n]={exports:{}};var a=true;try{e[n](o,o.exports,__nccwpck_require__);a=false}finally{if(a)delete r[n]}return o.exports}if(typeof __nccwpck_require__!==\"undefined\")__nccwpck_require__.ab=__dirname+\"/\";var n={};!function(){var e=n;e.decode=e.parse=__nccwpck_require__(815);e.encode=e.stringify=__nccwpck_require__(577)}();module.exports=n})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcXVlcnlzdHJpbmctZXMzL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7QUFBQSxZQUFZLGFBQWEsT0FBTyxnQkFBZ0IsNkJBQTZCLGlEQUFpRCw0QkFBNEIsU0FBUyxTQUFTLFNBQVMsc0NBQXNDLFNBQVMsWUFBWSxhQUFhLFVBQVUsbUNBQW1DLFlBQVksZUFBZSxhQUFhLElBQUksWUFBWSxJQUFJLEtBQUssbURBQW1ELFNBQVMsZ0JBQWdCLGdCQUFnQixLQUFLLElBQUksS0FBSyx3QkFBd0Isd0JBQXdCLHlCQUF5QixPQUFPLGlCQUFpQixhQUFhLEtBQUssZUFBZSxVQUFVLGlDQUFpQyw2REFBNkQsaUJBQWlCLG1DQUFtQyxpQkFBaUIsc0JBQXNCLHNDQUFzQyxxQ0FBcUMsbUJBQW1CLDRCQUE0QixTQUFTLFNBQVMsYUFBYSxZQUFZLHdCQUF3Qiw2QkFBNkIsa0RBQWtELFlBQVksNkJBQTZCLG1EQUFtRCxXQUFXLEtBQUssdURBQXVELFdBQVcsZUFBZSw4RkFBOEYsaUNBQWlDLDZEQUE2RCxrQkFBa0IseUJBQXlCLFNBQVMsWUFBWSxXQUFXLEtBQUssa0JBQWtCLFNBQVMsK0JBQStCLFNBQVMsZ0JBQWdCLHVEQUF1RCxZQUFZLFNBQVMsZ0NBQWdDLFdBQVcsa0JBQWtCLGlCQUFpQixZQUFZLFlBQVksV0FBVyxJQUFJLHNDQUFzQyxRQUFRLFFBQVEsaUJBQWlCLGlCQUFpQixtRUFBbUUsU0FBUyxLQUFLLFNBQVMsWUFBWSxRQUFRLDBDQUEwQyw4Q0FBOEMsR0FBRyxpQkFBaUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9xdWVyeXN0cmluZy1lczMvaW5kZXguanM/OTIwNCJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24oKXtcInVzZSBzdHJpY3RcIjt2YXIgZT17ODE1OmZ1bmN0aW9uKGUpe2Z1bmN0aW9uIGhhc093blByb3BlcnR5KGUscil7cmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLHIpfWUuZXhwb3J0cz1mdW5jdGlvbihlLG4sdCxvKXtuPW58fFwiJlwiO3Q9dHx8XCI9XCI7dmFyIGE9e307aWYodHlwZW9mIGUhPT1cInN0cmluZ1wifHxlLmxlbmd0aD09PTApe3JldHVybiBhfXZhciBpPS9cXCsvZztlPWUuc3BsaXQobik7dmFyIHU9MWUzO2lmKG8mJnR5cGVvZiBvLm1heEtleXM9PT1cIm51bWJlclwiKXt1PW8ubWF4S2V5c312YXIgYz1lLmxlbmd0aDtpZih1PjAmJmM+dSl7Yz11fWZvcih2YXIgcD0wO3A8YzsrK3Ape3ZhciBmPWVbcF0ucmVwbGFjZShpLFwiJTIwXCIpLHM9Zi5pbmRleE9mKHQpLF8sbCx5LGQ7aWYocz49MCl7Xz1mLnN1YnN0cigwLHMpO2w9Zi5zdWJzdHIocysxKX1lbHNle189ZjtsPVwiXCJ9eT1kZWNvZGVVUklDb21wb25lbnQoXyk7ZD1kZWNvZGVVUklDb21wb25lbnQobCk7aWYoIWhhc093blByb3BlcnR5KGEseSkpe2FbeV09ZH1lbHNlIGlmKHIoYVt5XSkpe2FbeV0ucHVzaChkKX1lbHNle2FbeV09W2FbeV0sZF19fXJldHVybiBhfTt2YXIgcj1BcnJheS5pc0FycmF5fHxmdW5jdGlvbihlKXtyZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGUpPT09XCJbb2JqZWN0IEFycmF5XVwifX0sNTc3OmZ1bmN0aW9uKGUpe3ZhciBzdHJpbmdpZnlQcmltaXRpdmU9ZnVuY3Rpb24oZSl7c3dpdGNoKHR5cGVvZiBlKXtjYXNlXCJzdHJpbmdcIjpyZXR1cm4gZTtjYXNlXCJib29sZWFuXCI6cmV0dXJuIGU/XCJ0cnVlXCI6XCJmYWxzZVwiO2Nhc2VcIm51bWJlclwiOnJldHVybiBpc0Zpbml0ZShlKT9lOlwiXCI7ZGVmYXVsdDpyZXR1cm5cIlwifX07ZS5leHBvcnRzPWZ1bmN0aW9uKGUsdCxvLGEpe3Q9dHx8XCImXCI7bz1vfHxcIj1cIjtpZihlPT09bnVsbCl7ZT11bmRlZmluZWR9aWYodHlwZW9mIGU9PT1cIm9iamVjdFwiKXtyZXR1cm4gbWFwKG4oZSksKGZ1bmN0aW9uKG4pe3ZhciBhPWVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUobikpK287aWYocihlW25dKSl7cmV0dXJuIG1hcChlW25dLChmdW5jdGlvbihlKXtyZXR1cm4gYStlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKGUpKX0pKS5qb2luKHQpfWVsc2V7cmV0dXJuIGErZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShlW25dKSl9fSkpLmpvaW4odCl9aWYoIWEpcmV0dXJuXCJcIjtyZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShhKSkrbytlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKGUpKX07dmFyIHI9QXJyYXkuaXNBcnJheXx8ZnVuY3Rpb24oZSl7cmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChlKT09PVwiW29iamVjdCBBcnJheV1cIn07ZnVuY3Rpb24gbWFwKGUscil7aWYoZS5tYXApcmV0dXJuIGUubWFwKHIpO3ZhciBuPVtdO2Zvcih2YXIgdD0wO3Q8ZS5sZW5ndGg7dCsrKXtuLnB1c2gocihlW3RdLHQpKX1yZXR1cm4gbn12YXIgbj1PYmplY3Qua2V5c3x8ZnVuY3Rpb24oZSl7dmFyIHI9W107Zm9yKHZhciBuIGluIGUpe2lmKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLG4pKXIucHVzaChuKX1yZXR1cm4gcn19fTt2YXIgcj17fTtmdW5jdGlvbiBfX25jY3dwY2tfcmVxdWlyZV9fKG4pe3ZhciB0PXJbbl07aWYodCE9PXVuZGVmaW5lZCl7cmV0dXJuIHQuZXhwb3J0c312YXIgbz1yW25dPXtleHBvcnRzOnt9fTt2YXIgYT10cnVlO3RyeXtlW25dKG8sby5leHBvcnRzLF9fbmNjd3Bja19yZXF1aXJlX18pO2E9ZmFsc2V9ZmluYWxseXtpZihhKWRlbGV0ZSByW25dfXJldHVybiBvLmV4cG9ydHN9aWYodHlwZW9mIF9fbmNjd3Bja19yZXF1aXJlX18hPT1cInVuZGVmaW5lZFwiKV9fbmNjd3Bja19yZXF1aXJlX18uYWI9X19kaXJuYW1lK1wiL1wiO3ZhciBuPXt9OyFmdW5jdGlvbigpe3ZhciBlPW47ZS5kZWNvZGU9ZS5wYXJzZT1fX25jY3dwY2tfcmVxdWlyZV9fKDgxNSk7ZS5lbmNvZGU9ZS5zdHJpbmdpZnk9X19uY2N3cGNrX3JlcXVpcmVfXyg1NzcpfSgpO21vZHVsZS5leHBvcnRzPW59KSgpOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/querystring-es3/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/onnxruntime-common/dist/lib/backend-impl.js":
/*!******************************************************************!*\
  !*** ./node_modules/onnxruntime-common/dist/lib/backend-impl.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   registerBackend: function() { return /* binding */ registerBackend; },\n/* harmony export */   resolveBackend: function() { return /* binding */ resolveBackend; }\n/* harmony export */ });\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\nconst backends = {};\nconst backendsSortedByPriority = [];\n/**\n * Register a backend.\n *\n * @param name - the name as a key to lookup as an execution provider.\n * @param backend - the backend object.\n * @param priority - an integer indicating the priority of the backend. Higher number means higher priority. if priority\n * < 0, it will be considered as a 'beta' version and will not be used as a fallback backend by default.\n *\n * @internal\n */\nconst registerBackend = (name, backend, priority) => {\n    if (backend && typeof backend.init === 'function' && typeof backend.createSessionHandler === 'function') {\n        const currentBackend = backends[name];\n        if (currentBackend === undefined) {\n            backends[name] = { backend, priority };\n        }\n        else if (currentBackend.priority > priority) {\n            // same name is already registered with a higher priority. skip registeration.\n            return;\n        }\n        else if (currentBackend.priority === priority) {\n            if (currentBackend.backend !== backend) {\n                throw new Error(`cannot register backend \"${name}\" using priority ${priority}`);\n            }\n        }\n        if (priority >= 0) {\n            const i = backendsSortedByPriority.indexOf(name);\n            if (i !== -1) {\n                backendsSortedByPriority.splice(i, 1);\n            }\n            for (let i = 0; i < backendsSortedByPriority.length; i++) {\n                if (backends[backendsSortedByPriority[i]].priority <= priority) {\n                    backendsSortedByPriority.splice(i, 0, name);\n                    return;\n                }\n            }\n            backendsSortedByPriority.push(name);\n        }\n        return;\n    }\n    throw new TypeError('not a valid backend');\n};\n/**\n * Resolve backend by specified hints.\n *\n * @param backendHints - a list of execution provider names to lookup. If omitted use registered backends as list.\n * @returns a promise that resolves to the backend.\n *\n * @internal\n */\nconst resolveBackend = async (backendHints) => {\n    const backendNames = backendHints.length === 0 ? backendsSortedByPriority : backendHints;\n    const errors = [];\n    for (const backendName of backendNames) {\n        const backendInfo = backends[backendName];\n        if (backendInfo) {\n            if (backendInfo.initialized) {\n                return backendInfo.backend;\n            }\n            else if (backendInfo.aborted) {\n                continue; // current backend is unavailable; try next\n            }\n            const isInitializing = !!backendInfo.initPromise;\n            try {\n                if (!isInitializing) {\n                    backendInfo.initPromise = backendInfo.backend.init();\n                }\n                await backendInfo.initPromise;\n                backendInfo.initialized = true;\n                return backendInfo.backend;\n            }\n            catch (e) {\n                if (!isInitializing) {\n                    errors.push({ name: backendName, err: e });\n                }\n                backendInfo.aborted = true;\n            }\n            finally {\n                delete backendInfo.initPromise;\n            }\n        }\n    }\n    throw new Error(`no available backend found. ERR: ${errors.map(e => `[${e.name}] ${e.err}`).join(', ')}`);\n};\n//# sourceMappingURL=backend-impl.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9vbm54cnVudGltZS1jb21tb24vZGlzdC9saWIvYmFja2VuZC1pbXBsLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELEtBQUssbUJBQW1CLFNBQVM7QUFDN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIscUNBQXFDO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsbUNBQW1DO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQywyQkFBMkI7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxvQkFBb0IsT0FBTyxJQUFJLE1BQU0sY0FBYztBQUMzRztBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9vbm54cnVudGltZS1jb21tb24vZGlzdC9saWIvYmFja2VuZC1pbXBsLmpzP2ZlZDYiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5jb25zdCBiYWNrZW5kcyA9IHt9O1xuY29uc3QgYmFja2VuZHNTb3J0ZWRCeVByaW9yaXR5ID0gW107XG4vKipcbiAqIFJlZ2lzdGVyIGEgYmFja2VuZC5cbiAqXG4gKiBAcGFyYW0gbmFtZSAtIHRoZSBuYW1lIGFzIGEga2V5IHRvIGxvb2t1cCBhcyBhbiBleGVjdXRpb24gcHJvdmlkZXIuXG4gKiBAcGFyYW0gYmFja2VuZCAtIHRoZSBiYWNrZW5kIG9iamVjdC5cbiAqIEBwYXJhbSBwcmlvcml0eSAtIGFuIGludGVnZXIgaW5kaWNhdGluZyB0aGUgcHJpb3JpdHkgb2YgdGhlIGJhY2tlbmQuIEhpZ2hlciBudW1iZXIgbWVhbnMgaGlnaGVyIHByaW9yaXR5LiBpZiBwcmlvcml0eVxuICogPCAwLCBpdCB3aWxsIGJlIGNvbnNpZGVyZWQgYXMgYSAnYmV0YScgdmVyc2lvbiBhbmQgd2lsbCBub3QgYmUgdXNlZCBhcyBhIGZhbGxiYWNrIGJhY2tlbmQgYnkgZGVmYXVsdC5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGNvbnN0IHJlZ2lzdGVyQmFja2VuZCA9IChuYW1lLCBiYWNrZW5kLCBwcmlvcml0eSkgPT4ge1xuICAgIGlmIChiYWNrZW5kICYmIHR5cGVvZiBiYWNrZW5kLmluaXQgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGJhY2tlbmQuY3JlYXRlU2Vzc2lvbkhhbmRsZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY29uc3QgY3VycmVudEJhY2tlbmQgPSBiYWNrZW5kc1tuYW1lXTtcbiAgICAgICAgaWYgKGN1cnJlbnRCYWNrZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGJhY2tlbmRzW25hbWVdID0geyBiYWNrZW5kLCBwcmlvcml0eSB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGN1cnJlbnRCYWNrZW5kLnByaW9yaXR5ID4gcHJpb3JpdHkpIHtcbiAgICAgICAgICAgIC8vIHNhbWUgbmFtZSBpcyBhbHJlYWR5IHJlZ2lzdGVyZWQgd2l0aCBhIGhpZ2hlciBwcmlvcml0eS4gc2tpcCByZWdpc3RlcmF0aW9uLlxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGN1cnJlbnRCYWNrZW5kLnByaW9yaXR5ID09PSBwcmlvcml0eSkge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRCYWNrZW5kLmJhY2tlbmQgIT09IGJhY2tlbmQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNhbm5vdCByZWdpc3RlciBiYWNrZW5kIFwiJHtuYW1lfVwiIHVzaW5nIHByaW9yaXR5ICR7cHJpb3JpdHl9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByaW9yaXR5ID49IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGkgPSBiYWNrZW5kc1NvcnRlZEJ5UHJpb3JpdHkuaW5kZXhPZihuYW1lKTtcbiAgICAgICAgICAgIGlmIChpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIGJhY2tlbmRzU29ydGVkQnlQcmlvcml0eS5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJhY2tlbmRzU29ydGVkQnlQcmlvcml0eS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChiYWNrZW5kc1tiYWNrZW5kc1NvcnRlZEJ5UHJpb3JpdHlbaV1dLnByaW9yaXR5IDw9IHByaW9yaXR5KSB7XG4gICAgICAgICAgICAgICAgICAgIGJhY2tlbmRzU29ydGVkQnlQcmlvcml0eS5zcGxpY2UoaSwgMCwgbmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBiYWNrZW5kc1NvcnRlZEJ5UHJpb3JpdHkucHVzaChuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ25vdCBhIHZhbGlkIGJhY2tlbmQnKTtcbn07XG4vKipcbiAqIFJlc29sdmUgYmFja2VuZCBieSBzcGVjaWZpZWQgaGludHMuXG4gKlxuICogQHBhcmFtIGJhY2tlbmRIaW50cyAtIGEgbGlzdCBvZiBleGVjdXRpb24gcHJvdmlkZXIgbmFtZXMgdG8gbG9va3VwLiBJZiBvbWl0dGVkIHVzZSByZWdpc3RlcmVkIGJhY2tlbmRzIGFzIGxpc3QuXG4gKiBAcmV0dXJucyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgYmFja2VuZC5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGNvbnN0IHJlc29sdmVCYWNrZW5kID0gYXN5bmMgKGJhY2tlbmRIaW50cykgPT4ge1xuICAgIGNvbnN0IGJhY2tlbmROYW1lcyA9IGJhY2tlbmRIaW50cy5sZW5ndGggPT09IDAgPyBiYWNrZW5kc1NvcnRlZEJ5UHJpb3JpdHkgOiBiYWNrZW5kSGludHM7XG4gICAgY29uc3QgZXJyb3JzID0gW107XG4gICAgZm9yIChjb25zdCBiYWNrZW5kTmFtZSBvZiBiYWNrZW5kTmFtZXMpIHtcbiAgICAgICAgY29uc3QgYmFja2VuZEluZm8gPSBiYWNrZW5kc1tiYWNrZW5kTmFtZV07XG4gICAgICAgIGlmIChiYWNrZW5kSW5mbykge1xuICAgICAgICAgICAgaWYgKGJhY2tlbmRJbmZvLmluaXRpYWxpemVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJhY2tlbmRJbmZvLmJhY2tlbmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChiYWNrZW5kSW5mby5hYm9ydGVkKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7IC8vIGN1cnJlbnQgYmFja2VuZCBpcyB1bmF2YWlsYWJsZTsgdHJ5IG5leHRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGlzSW5pdGlhbGl6aW5nID0gISFiYWNrZW5kSW5mby5pbml0UHJvbWlzZTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc0luaXRpYWxpemluZykge1xuICAgICAgICAgICAgICAgICAgICBiYWNrZW5kSW5mby5pbml0UHJvbWlzZSA9IGJhY2tlbmRJbmZvLmJhY2tlbmQuaW5pdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhd2FpdCBiYWNrZW5kSW5mby5pbml0UHJvbWlzZTtcbiAgICAgICAgICAgICAgICBiYWNrZW5kSW5mby5pbml0aWFsaXplZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJhY2tlbmRJbmZvLmJhY2tlbmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGlmICghaXNJbml0aWFsaXppbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JzLnB1c2goeyBuYW1lOiBiYWNrZW5kTmFtZSwgZXJyOiBlIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBiYWNrZW5kSW5mby5hYm9ydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBiYWNrZW5kSW5mby5pbml0UHJvbWlzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYG5vIGF2YWlsYWJsZSBiYWNrZW5kIGZvdW5kLiBFUlI6ICR7ZXJyb3JzLm1hcChlID0+IGBbJHtlLm5hbWV9XSAke2UuZXJyfWApLmpvaW4oJywgJyl9YCk7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmFja2VuZC1pbXBsLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/onnxruntime-common/dist/lib/backend-impl.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/onnxruntime-common/dist/lib/backend.js":
/*!*************************************************************!*\
  !*** ./node_modules/onnxruntime-common/dist/lib/backend.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   registerBackend: function() { return /* reexport safe */ _backend_impl__WEBPACK_IMPORTED_MODULE_0__.registerBackend; }\n/* harmony export */ });\n/* harmony import */ var _backend_impl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./backend-impl */ \"(app-pages-browser)/./node_modules/onnxruntime-common/dist/lib/backend-impl.js\");\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\n//# sourceMappingURL=backend.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9vbm54cnVudGltZS1jb21tb24vZGlzdC9saWIvYmFja2VuZC5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7QUFDaUQ7QUFDakQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL29ubnhydW50aW1lLWNvbW1vbi9kaXN0L2xpYi9iYWNrZW5kLmpzPzg0YWQiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5leHBvcnQgeyByZWdpc3RlckJhY2tlbmQgfSBmcm9tICcuL2JhY2tlbmQtaW1wbCc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iYWNrZW5kLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/onnxruntime-common/dist/lib/backend.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/onnxruntime-common/dist/lib/env-impl.js":
/*!**************************************************************!*\
  !*** ./node_modules/onnxruntime-common/dist/lib/env-impl.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EnvImpl: function() { return /* binding */ EnvImpl; }\n/* harmony export */ });\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\nclass EnvImpl {\n    constructor() {\n        this.wasm = {};\n        this.webgl = {};\n        this.logLevelInternal = 'warning';\n    }\n    // TODO standadize the getter and setter convention in env for other fields.\n    set logLevel(value) {\n        if (value === undefined) {\n            return;\n        }\n        if (typeof value !== 'string' || ['verbose', 'info', 'warning', 'error', 'fatal'].indexOf(value) === -1) {\n            throw new Error(`Unsupported logging level: ${value}`);\n        }\n        this.logLevelInternal = value;\n    }\n    get logLevel() {\n        return this.logLevelInternal;\n    }\n}\n//# sourceMappingURL=env-impl.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9vbm54cnVudGltZS1jb21tb24vZGlzdC9saWIvZW52LWltcGwuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsTUFBTTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9vbm54cnVudGltZS1jb21tb24vZGlzdC9saWIvZW52LWltcGwuanM/Yjg4ZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbmV4cG9ydCBjbGFzcyBFbnZJbXBsIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy53YXNtID0ge307XG4gICAgICAgIHRoaXMud2ViZ2wgPSB7fTtcbiAgICAgICAgdGhpcy5sb2dMZXZlbEludGVybmFsID0gJ3dhcm5pbmcnO1xuICAgIH1cbiAgICAvLyBUT0RPIHN0YW5kYWRpemUgdGhlIGdldHRlciBhbmQgc2V0dGVyIGNvbnZlbnRpb24gaW4gZW52IGZvciBvdGhlciBmaWVsZHMuXG4gICAgc2V0IGxvZ0xldmVsKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycgfHwgWyd2ZXJib3NlJywgJ2luZm8nLCAnd2FybmluZycsICdlcnJvcicsICdmYXRhbCddLmluZGV4T2YodmFsdWUpID09PSAtMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBsb2dnaW5nIGxldmVsOiAke3ZhbHVlfWApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubG9nTGV2ZWxJbnRlcm5hbCA9IHZhbHVlO1xuICAgIH1cbiAgICBnZXQgbG9nTGV2ZWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvZ0xldmVsSW50ZXJuYWw7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZW52LWltcGwuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/onnxruntime-common/dist/lib/env-impl.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/onnxruntime-common/dist/lib/env.js":
/*!*********************************************************!*\
  !*** ./node_modules/onnxruntime-common/dist/lib/env.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   env: function() { return /* binding */ env; }\n/* harmony export */ });\n/* harmony import */ var _env_impl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./env-impl */ \"(app-pages-browser)/./node_modules/onnxruntime-common/dist/lib/env-impl.js\");\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\n/**\n * Represent a set of flags as a global singleton.\n */\nconst env = new _env_impl__WEBPACK_IMPORTED_MODULE_0__.EnvImpl();\n//# sourceMappingURL=env.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9vbm54cnVudGltZS1jb21tb24vZGlzdC9saWIvZW52LmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUNxQztBQUNyQztBQUNBO0FBQ0E7QUFDTyxnQkFBZ0IsOENBQU87QUFDOUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL29ubnhydW50aW1lLWNvbW1vbi9kaXN0L2xpYi9lbnYuanM/ZDE0ZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbmltcG9ydCB7IEVudkltcGwgfSBmcm9tICcuL2Vudi1pbXBsJztcbi8qKlxuICogUmVwcmVzZW50IGEgc2V0IG9mIGZsYWdzIGFzIGEgZ2xvYmFsIHNpbmdsZXRvbi5cbiAqL1xuZXhwb3J0IGNvbnN0IGVudiA9IG5ldyBFbnZJbXBsKCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lbnYuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/onnxruntime-common/dist/lib/env.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/onnxruntime-common/dist/lib/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/onnxruntime-common/dist/lib/index.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InferenceSession: function() { return /* reexport safe */ _inference_session__WEBPACK_IMPORTED_MODULE_2__.InferenceSession; },\n/* harmony export */   Tensor: function() { return /* reexport safe */ _tensor__WEBPACK_IMPORTED_MODULE_3__.Tensor; },\n/* harmony export */   env: function() { return /* reexport safe */ _env__WEBPACK_IMPORTED_MODULE_1__.env; },\n/* harmony export */   registerBackend: function() { return /* reexport safe */ _backend__WEBPACK_IMPORTED_MODULE_0__.registerBackend; }\n/* harmony export */ });\n/* harmony import */ var _backend__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./backend */ \"(app-pages-browser)/./node_modules/onnxruntime-common/dist/lib/backend.js\");\n/* harmony import */ var _env__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./env */ \"(app-pages-browser)/./node_modules/onnxruntime-common/dist/lib/env.js\");\n/* harmony import */ var _inference_session__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./inference-session */ \"(app-pages-browser)/./node_modules/onnxruntime-common/dist/lib/inference-session.js\");\n/* harmony import */ var _tensor__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./tensor */ \"(app-pages-browser)/./node_modules/onnxruntime-common/dist/lib/tensor.js\");\n/* harmony import */ var _onnx_value__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./onnx-value */ \"(app-pages-browser)/./node_modules/onnxruntime-common/dist/lib/onnx-value.js\");\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n/**\n * # ONNX Runtime JavaScript API\n *\n * ONNX Runtime JavaScript API is a unified API for all JavaScript usages, including the following NPM packages:\n *\n * - [onnxruntime-node](https://www.npmjs.com/package/onnxruntime-node)\n * - [onnxruntime-web](https://www.npmjs.com/package/onnxruntime-web)\n * - [onnxruntime-react-native](https://www.npmjs.com/package/onnxruntime-react-native)\n *\n * See also:\n * - [Get Started](https://onnxruntime.ai/docs/get-started/with-javascript.html)\n * - [Inference examples](https://github.com/microsoft/onnxruntime-inference-examples/tree/main/js)\n *\n * @packageDocumentation\n */\n\n\n\n\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9vbm54cnVudGltZS1jb21tb24vZGlzdC9saWIvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUMwQjtBQUNKO0FBQ2M7QUFDWDtBQUNJO0FBQzdCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9vbm54cnVudGltZS1jb21tb24vZGlzdC9saWIvaW5kZXguanM/NDA0YyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbi8qKlxuICogIyBPTk5YIFJ1bnRpbWUgSmF2YVNjcmlwdCBBUElcbiAqXG4gKiBPTk5YIFJ1bnRpbWUgSmF2YVNjcmlwdCBBUEkgaXMgYSB1bmlmaWVkIEFQSSBmb3IgYWxsIEphdmFTY3JpcHQgdXNhZ2VzLCBpbmNsdWRpbmcgdGhlIGZvbGxvd2luZyBOUE0gcGFja2FnZXM6XG4gKlxuICogLSBbb25ueHJ1bnRpbWUtbm9kZV0oaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2Uvb25ueHJ1bnRpbWUtbm9kZSlcbiAqIC0gW29ubnhydW50aW1lLXdlYl0oaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2Uvb25ueHJ1bnRpbWUtd2ViKVxuICogLSBbb25ueHJ1bnRpbWUtcmVhY3QtbmF0aXZlXShodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS9vbm54cnVudGltZS1yZWFjdC1uYXRpdmUpXG4gKlxuICogU2VlIGFsc286XG4gKiAtIFtHZXQgU3RhcnRlZF0oaHR0cHM6Ly9vbm54cnVudGltZS5haS9kb2NzL2dldC1zdGFydGVkL3dpdGgtamF2YXNjcmlwdC5odG1sKVxuICogLSBbSW5mZXJlbmNlIGV4YW1wbGVzXShodHRwczovL2dpdGh1Yi5jb20vbWljcm9zb2Z0L29ubnhydW50aW1lLWluZmVyZW5jZS1leGFtcGxlcy90cmVlL21haW4vanMpXG4gKlxuICogQHBhY2thZ2VEb2N1bWVudGF0aW9uXG4gKi9cbmV4cG9ydCAqIGZyb20gJy4vYmFja2VuZCc7XG5leHBvcnQgKiBmcm9tICcuL2Vudic7XG5leHBvcnQgKiBmcm9tICcuL2luZmVyZW5jZS1zZXNzaW9uJztcbmV4cG9ydCAqIGZyb20gJy4vdGVuc29yJztcbmV4cG9ydCAqIGZyb20gJy4vb25ueC12YWx1ZSc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/onnxruntime-common/dist/lib/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/onnxruntime-common/dist/lib/inference-session-impl.js":
/*!****************************************************************************!*\
  !*** ./node_modules/onnxruntime-common/dist/lib/inference-session-impl.js ***!
  \****************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InferenceSession: function() { return /* binding */ InferenceSession; }\n/* harmony export */ });\n/* harmony import */ var _backend_impl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./backend-impl */ \"(app-pages-browser)/./node_modules/onnxruntime-common/dist/lib/backend-impl.js\");\n/* harmony import */ var _tensor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./tensor */ \"(app-pages-browser)/./node_modules/onnxruntime-common/dist/lib/tensor.js\");\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\n\nclass InferenceSession {\n    constructor(handler) {\n        this.handler = handler;\n    }\n    async run(feeds, arg1, arg2) {\n        const fetches = {};\n        let options = {};\n        // check inputs\n        if (typeof feeds !== 'object' || feeds === null || feeds instanceof _tensor__WEBPACK_IMPORTED_MODULE_1__.Tensor || Array.isArray(feeds)) {\n            throw new TypeError('\\'feeds\\' must be an object that use input names as keys and OnnxValue as corresponding values.');\n        }\n        let isFetchesEmpty = true;\n        // determine which override is being used\n        if (typeof arg1 === 'object') {\n            if (arg1 === null) {\n                throw new TypeError('Unexpected argument[1]: cannot be null.');\n            }\n            if (arg1 instanceof _tensor__WEBPACK_IMPORTED_MODULE_1__.Tensor) {\n                throw new TypeError('\\'fetches\\' cannot be a Tensor');\n            }\n            if (Array.isArray(arg1)) {\n                if (arg1.length === 0) {\n                    throw new TypeError('\\'fetches\\' cannot be an empty array.');\n                }\n                isFetchesEmpty = false;\n                // output names\n                for (const name of arg1) {\n                    if (typeof name !== 'string') {\n                        throw new TypeError('\\'fetches\\' must be a string array or an object.');\n                    }\n                    if (this.outputNames.indexOf(name) === -1) {\n                        throw new RangeError(`'fetches' contains invalid output name: ${name}.`);\n                    }\n                    fetches[name] = null;\n                }\n                if (typeof arg2 === 'object' && arg2 !== null) {\n                    options = arg2;\n                }\n                else if (typeof arg2 !== 'undefined') {\n                    throw new TypeError('\\'options\\' must be an object.');\n                }\n            }\n            else {\n                // decide whether arg1 is fetches or options\n                // if any output name is present and its value is valid OnnxValue, we consider it fetches\n                let isFetches = false;\n                const arg1Keys = Object.getOwnPropertyNames(arg1);\n                for (const name of this.outputNames) {\n                    if (arg1Keys.indexOf(name) !== -1) {\n                        const v = arg1[name];\n                        if (v === null || v instanceof _tensor__WEBPACK_IMPORTED_MODULE_1__.Tensor) {\n                            isFetches = true;\n                            isFetchesEmpty = false;\n                            fetches[name] = v;\n                        }\n                    }\n                }\n                if (isFetches) {\n                    if (typeof arg2 === 'object' && arg2 !== null) {\n                        options = arg2;\n                    }\n                    else if (typeof arg2 !== 'undefined') {\n                        throw new TypeError('\\'options\\' must be an object.');\n                    }\n                }\n                else {\n                    options = arg1;\n                }\n            }\n        }\n        else if (typeof arg1 !== 'undefined') {\n            throw new TypeError('Unexpected argument[1]: must be \\'fetches\\' or \\'options\\'.');\n        }\n        // check if all inputs are in feed\n        for (const name of this.inputNames) {\n            if (typeof feeds[name] === 'undefined') {\n                throw new Error(`input '${name}' is missing in 'feeds'.`);\n            }\n        }\n        // if no fetches is specified, we use the full output names list\n        if (isFetchesEmpty) {\n            for (const name of this.outputNames) {\n                fetches[name] = null;\n            }\n        }\n        // feeds, fetches and options are prepared\n        const results = await this.handler.run(feeds, fetches, options);\n        const returnValue = {};\n        for (const key in results) {\n            if (Object.hasOwnProperty.call(results, key)) {\n                returnValue[key] = new _tensor__WEBPACK_IMPORTED_MODULE_1__.Tensor(results[key].type, results[key].data, results[key].dims);\n            }\n        }\n        return returnValue;\n    }\n    static async create(arg0, arg1, arg2, arg3) {\n        // either load from a file or buffer\n        let filePathOrUint8Array;\n        let options = {};\n        if (typeof arg0 === 'string') {\n            filePathOrUint8Array = arg0;\n            if (typeof arg1 === 'object' && arg1 !== null) {\n                options = arg1;\n            }\n            else if (typeof arg1 !== 'undefined') {\n                throw new TypeError('\\'options\\' must be an object.');\n            }\n        }\n        else if (arg0 instanceof Uint8Array) {\n            filePathOrUint8Array = arg0;\n            if (typeof arg1 === 'object' && arg1 !== null) {\n                options = arg1;\n            }\n            else if (typeof arg1 !== 'undefined') {\n                throw new TypeError('\\'options\\' must be an object.');\n            }\n        }\n        else if (arg0 instanceof ArrayBuffer ||\n            (typeof SharedArrayBuffer !== 'undefined' && arg0 instanceof SharedArrayBuffer)) {\n            const buffer = arg0;\n            let byteOffset = 0;\n            let byteLength = arg0.byteLength;\n            if (typeof arg1 === 'object' && arg1 !== null) {\n                options = arg1;\n            }\n            else if (typeof arg1 === 'number') {\n                byteOffset = arg1;\n                if (!Number.isSafeInteger(byteOffset)) {\n                    throw new RangeError('\\'byteOffset\\' must be an integer.');\n                }\n                if (byteOffset < 0 || byteOffset >= buffer.byteLength) {\n                    throw new RangeError(`'byteOffset' is out of range [0, ${buffer.byteLength}).`);\n                }\n                byteLength = arg0.byteLength - byteOffset;\n                if (typeof arg2 === 'number') {\n                    byteLength = arg2;\n                    if (!Number.isSafeInteger(byteLength)) {\n                        throw new RangeError('\\'byteLength\\' must be an integer.');\n                    }\n                    if (byteLength <= 0 || byteOffset + byteLength > buffer.byteLength) {\n                        throw new RangeError(`'byteLength' is out of range (0, ${buffer.byteLength - byteOffset}].`);\n                    }\n                    if (typeof arg3 === 'object' && arg3 !== null) {\n                        options = arg3;\n                    }\n                    else if (typeof arg3 !== 'undefined') {\n                        throw new TypeError('\\'options\\' must be an object.');\n                    }\n                }\n                else if (typeof arg2 !== 'undefined') {\n                    throw new TypeError('\\'byteLength\\' must be a number.');\n                }\n            }\n            else if (typeof arg1 !== 'undefined') {\n                throw new TypeError('\\'options\\' must be an object.');\n            }\n            filePathOrUint8Array = new Uint8Array(buffer, byteOffset, byteLength);\n        }\n        else {\n            throw new TypeError('Unexpected argument[0]: must be \\'path\\' or \\'buffer\\'.');\n        }\n        // get backend hints\n        const eps = options.executionProviders || [];\n        const backendHints = eps.map(i => typeof i === 'string' ? i : i.name);\n        const backend = await (0,_backend_impl__WEBPACK_IMPORTED_MODULE_0__.resolveBackend)(backendHints);\n        const handler = await backend.createSessionHandler(filePathOrUint8Array, options);\n        return new InferenceSession(handler);\n    }\n    startProfiling() {\n        this.handler.startProfiling();\n    }\n    endProfiling() {\n        this.handler.endProfiling();\n    }\n    get inputNames() {\n        return this.handler.inputNames;\n    }\n    get outputNames() {\n        return this.handler.outputNames;\n    }\n}\n//# sourceMappingURL=inference-session-impl.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9vbm54cnVudGltZS1jb21tb24vZGlzdC9saWIvaW5mZXJlbmNlLXNlc3Npb24taW1wbC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNBO0FBQ2dEO0FBQ2Q7QUFDM0I7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RSwyQ0FBTTtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLDJDQUFNO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0ZBQXdGLEtBQUs7QUFDN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELDJDQUFNO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLEtBQUs7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsMkNBQU07QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkUsa0JBQWtCO0FBQy9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRkFBaUYsK0JBQStCO0FBQ2hIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsNkRBQWM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvb25ueHJ1bnRpbWUtY29tbW9uL2Rpc3QvbGliL2luZmVyZW5jZS1zZXNzaW9uLWltcGwuanM/ZjZkZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbmltcG9ydCB7IHJlc29sdmVCYWNrZW5kIH0gZnJvbSAnLi9iYWNrZW5kLWltcGwnO1xuaW1wb3J0IHsgVGVuc29yIH0gZnJvbSAnLi90ZW5zb3InO1xuZXhwb3J0IGNsYXNzIEluZmVyZW5jZVNlc3Npb24ge1xuICAgIGNvbnN0cnVjdG9yKGhhbmRsZXIpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVyID0gaGFuZGxlcjtcbiAgICB9XG4gICAgYXN5bmMgcnVuKGZlZWRzLCBhcmcxLCBhcmcyKSB7XG4gICAgICAgIGNvbnN0IGZldGNoZXMgPSB7fTtcbiAgICAgICAgbGV0IG9wdGlvbnMgPSB7fTtcbiAgICAgICAgLy8gY2hlY2sgaW5wdXRzXG4gICAgICAgIGlmICh0eXBlb2YgZmVlZHMgIT09ICdvYmplY3QnIHx8IGZlZWRzID09PSBudWxsIHx8IGZlZWRzIGluc3RhbmNlb2YgVGVuc29yIHx8IEFycmF5LmlzQXJyYXkoZmVlZHMpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcXCdmZWVkc1xcJyBtdXN0IGJlIGFuIG9iamVjdCB0aGF0IHVzZSBpbnB1dCBuYW1lcyBhcyBrZXlzIGFuZCBPbm54VmFsdWUgYXMgY29ycmVzcG9uZGluZyB2YWx1ZXMuJyk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGlzRmV0Y2hlc0VtcHR5ID0gdHJ1ZTtcbiAgICAgICAgLy8gZGV0ZXJtaW5lIHdoaWNoIG92ZXJyaWRlIGlzIGJlaW5nIHVzZWRcbiAgICAgICAgaWYgKHR5cGVvZiBhcmcxID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgaWYgKGFyZzEgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmV4cGVjdGVkIGFyZ3VtZW50WzFdOiBjYW5ub3QgYmUgbnVsbC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhcmcxIGluc3RhbmNlb2YgVGVuc29yKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXFwnZmV0Y2hlc1xcJyBjYW5ub3QgYmUgYSBUZW5zb3InKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGFyZzEpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFyZzEubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1xcJ2ZldGNoZXNcXCcgY2Fubm90IGJlIGFuIGVtcHR5IGFycmF5LicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpc0ZldGNoZXNFbXB0eSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIC8vIG91dHB1dCBuYW1lc1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgbmFtZSBvZiBhcmcxKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1xcJ2ZldGNoZXNcXCcgbXVzdCBiZSBhIHN0cmluZyBhcnJheSBvciBhbiBvYmplY3QuJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMub3V0cHV0TmFtZXMuaW5kZXhPZihuYW1lKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGAnZmV0Y2hlcycgY29udGFpbnMgaW52YWxpZCBvdXRwdXQgbmFtZTogJHtuYW1lfS5gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmZXRjaGVzW25hbWVdID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBhcmcyID09PSAnb2JqZWN0JyAmJiBhcmcyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMgPSBhcmcyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgYXJnMiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXFwnb3B0aW9uc1xcJyBtdXN0IGJlIGFuIG9iamVjdC4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBkZWNpZGUgd2hldGhlciBhcmcxIGlzIGZldGNoZXMgb3Igb3B0aW9uc1xuICAgICAgICAgICAgICAgIC8vIGlmIGFueSBvdXRwdXQgbmFtZSBpcyBwcmVzZW50IGFuZCBpdHMgdmFsdWUgaXMgdmFsaWQgT25ueFZhbHVlLCB3ZSBjb25zaWRlciBpdCBmZXRjaGVzXG4gICAgICAgICAgICAgICAgbGV0IGlzRmV0Y2hlcyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGNvbnN0IGFyZzFLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoYXJnMSk7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBuYW1lIG9mIHRoaXMub3V0cHV0TmFtZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFyZzFLZXlzLmluZGV4T2YobmFtZSkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB2ID0gYXJnMVtuYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2ID09PSBudWxsIHx8IHYgaW5zdGFuY2VvZiBUZW5zb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0ZldGNoZXMgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzRmV0Y2hlc0VtcHR5ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmV0Y2hlc1tuYW1lXSA9IHY7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGlzRmV0Y2hlcykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGFyZzIgPT09ICdvYmplY3QnICYmIGFyZzIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMgPSBhcmcyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBhcmcyICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXFwnb3B0aW9uc1xcJyBtdXN0IGJlIGFuIG9iamVjdC4nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucyA9IGFyZzE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBhcmcxICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5leHBlY3RlZCBhcmd1bWVudFsxXTogbXVzdCBiZSBcXCdmZXRjaGVzXFwnIG9yIFxcJ29wdGlvbnNcXCcuJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY2hlY2sgaWYgYWxsIGlucHV0cyBhcmUgaW4gZmVlZFxuICAgICAgICBmb3IgKGNvbnN0IG5hbWUgb2YgdGhpcy5pbnB1dE5hbWVzKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGZlZWRzW25hbWVdID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgaW5wdXQgJyR7bmFtZX0nIGlzIG1pc3NpbmcgaW4gJ2ZlZWRzJy5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBpZiBubyBmZXRjaGVzIGlzIHNwZWNpZmllZCwgd2UgdXNlIHRoZSBmdWxsIG91dHB1dCBuYW1lcyBsaXN0XG4gICAgICAgIGlmIChpc0ZldGNoZXNFbXB0eSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBuYW1lIG9mIHRoaXMub3V0cHV0TmFtZXMpIHtcbiAgICAgICAgICAgICAgICBmZXRjaGVzW25hbWVdID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBmZWVkcywgZmV0Y2hlcyBhbmQgb3B0aW9ucyBhcmUgcHJlcGFyZWRcbiAgICAgICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IHRoaXMuaGFuZGxlci5ydW4oZmVlZHMsIGZldGNoZXMsIG9wdGlvbnMpO1xuICAgICAgICBjb25zdCByZXR1cm5WYWx1ZSA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiByZXN1bHRzKSB7XG4gICAgICAgICAgICBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwocmVzdWx0cywga2V5KSkge1xuICAgICAgICAgICAgICAgIHJldHVyblZhbHVlW2tleV0gPSBuZXcgVGVuc29yKHJlc3VsdHNba2V5XS50eXBlLCByZXN1bHRzW2tleV0uZGF0YSwgcmVzdWx0c1trZXldLmRpbXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXR1cm5WYWx1ZTtcbiAgICB9XG4gICAgc3RhdGljIGFzeW5jIGNyZWF0ZShhcmcwLCBhcmcxLCBhcmcyLCBhcmczKSB7XG4gICAgICAgIC8vIGVpdGhlciBsb2FkIGZyb20gYSBmaWxlIG9yIGJ1ZmZlclxuICAgICAgICBsZXQgZmlsZVBhdGhPclVpbnQ4QXJyYXk7XG4gICAgICAgIGxldCBvcHRpb25zID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgYXJnMCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGZpbGVQYXRoT3JVaW50OEFycmF5ID0gYXJnMDtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgYXJnMSA9PT0gJ29iamVjdCcgJiYgYXJnMSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMgPSBhcmcxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGFyZzEgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXFwnb3B0aW9uc1xcJyBtdXN0IGJlIGFuIG9iamVjdC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhcmcwIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgICAgICAgZmlsZVBhdGhPclVpbnQ4QXJyYXkgPSBhcmcwO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBhcmcxID09PSAnb2JqZWN0JyAmJiBhcmcxICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IGFyZzE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgYXJnMSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcXCdvcHRpb25zXFwnIG11c3QgYmUgYW4gb2JqZWN0LicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGFyZzAgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciB8fFxuICAgICAgICAgICAgKHR5cGVvZiBTaGFyZWRBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgYXJnMCBpbnN0YW5jZW9mIFNoYXJlZEFycmF5QnVmZmVyKSkge1xuICAgICAgICAgICAgY29uc3QgYnVmZmVyID0gYXJnMDtcbiAgICAgICAgICAgIGxldCBieXRlT2Zmc2V0ID0gMDtcbiAgICAgICAgICAgIGxldCBieXRlTGVuZ3RoID0gYXJnMC5ieXRlTGVuZ3RoO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBhcmcxID09PSAnb2JqZWN0JyAmJiBhcmcxICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IGFyZzE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgYXJnMSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICBieXRlT2Zmc2V0ID0gYXJnMTtcbiAgICAgICAgICAgICAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKGJ5dGVPZmZzZXQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcXCdieXRlT2Zmc2V0XFwnIG11c3QgYmUgYW4gaW50ZWdlci4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGJ5dGVPZmZzZXQgPCAwIHx8IGJ5dGVPZmZzZXQgPj0gYnVmZmVyLmJ5dGVMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYCdieXRlT2Zmc2V0JyBpcyBvdXQgb2YgcmFuZ2UgWzAsICR7YnVmZmVyLmJ5dGVMZW5ndGh9KS5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnl0ZUxlbmd0aCA9IGFyZzAuYnl0ZUxlbmd0aCAtIGJ5dGVPZmZzZXQ7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBhcmcyID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgICAgICBieXRlTGVuZ3RoID0gYXJnMjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihieXRlTGVuZ3RoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1xcJ2J5dGVMZW5ndGhcXCcgbXVzdCBiZSBhbiBpbnRlZ2VyLicpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChieXRlTGVuZ3RoIDw9IDAgfHwgYnl0ZU9mZnNldCArIGJ5dGVMZW5ndGggPiBidWZmZXIuYnl0ZUxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYCdieXRlTGVuZ3RoJyBpcyBvdXQgb2YgcmFuZ2UgKDAsICR7YnVmZmVyLmJ5dGVMZW5ndGggLSBieXRlT2Zmc2V0fV0uYCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBhcmczID09PSAnb2JqZWN0JyAmJiBhcmczICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zID0gYXJnMztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgYXJnMyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1xcJ29wdGlvbnNcXCcgbXVzdCBiZSBhbiBvYmplY3QuJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGFyZzIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1xcJ2J5dGVMZW5ndGhcXCcgbXVzdCBiZSBhIG51bWJlci4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgYXJnMSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcXCdvcHRpb25zXFwnIG11c3QgYmUgYW4gb2JqZWN0LicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmlsZVBhdGhPclVpbnQ4QXJyYXkgPSBuZXcgVWludDhBcnJheShidWZmZXIsIGJ5dGVPZmZzZXQsIGJ5dGVMZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5leHBlY3RlZCBhcmd1bWVudFswXTogbXVzdCBiZSBcXCdwYXRoXFwnIG9yIFxcJ2J1ZmZlclxcJy4nKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBnZXQgYmFja2VuZCBoaW50c1xuICAgICAgICBjb25zdCBlcHMgPSBvcHRpb25zLmV4ZWN1dGlvblByb3ZpZGVycyB8fCBbXTtcbiAgICAgICAgY29uc3QgYmFja2VuZEhpbnRzID0gZXBzLm1hcChpID0+IHR5cGVvZiBpID09PSAnc3RyaW5nJyA/IGkgOiBpLm5hbWUpO1xuICAgICAgICBjb25zdCBiYWNrZW5kID0gYXdhaXQgcmVzb2x2ZUJhY2tlbmQoYmFja2VuZEhpbnRzKTtcbiAgICAgICAgY29uc3QgaGFuZGxlciA9IGF3YWl0IGJhY2tlbmQuY3JlYXRlU2Vzc2lvbkhhbmRsZXIoZmlsZVBhdGhPclVpbnQ4QXJyYXksIG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gbmV3IEluZmVyZW5jZVNlc3Npb24oaGFuZGxlcik7XG4gICAgfVxuICAgIHN0YXJ0UHJvZmlsaW5nKCkge1xuICAgICAgICB0aGlzLmhhbmRsZXIuc3RhcnRQcm9maWxpbmcoKTtcbiAgICB9XG4gICAgZW5kUHJvZmlsaW5nKCkge1xuICAgICAgICB0aGlzLmhhbmRsZXIuZW5kUHJvZmlsaW5nKCk7XG4gICAgfVxuICAgIGdldCBpbnB1dE5hbWVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVyLmlucHV0TmFtZXM7XG4gICAgfVxuICAgIGdldCBvdXRwdXROYW1lcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlci5vdXRwdXROYW1lcztcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmZlcmVuY2Utc2Vzc2lvbi1pbXBsLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/onnxruntime-common/dist/lib/inference-session-impl.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/onnxruntime-common/dist/lib/inference-session.js":
/*!***********************************************************************!*\
  !*** ./node_modules/onnxruntime-common/dist/lib/inference-session.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InferenceSession: function() { return /* binding */ InferenceSession; }\n/* harmony export */ });\n/* harmony import */ var _inference_session_impl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./inference-session-impl */ \"(app-pages-browser)/./node_modules/onnxruntime-common/dist/lib/inference-session-impl.js\");\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\n// eslint-disable-next-line @typescript-eslint/naming-convention\nconst InferenceSession = _inference_session_impl__WEBPACK_IMPORTED_MODULE_0__.InferenceSession;\n//# sourceMappingURL=inference-session.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9vbm54cnVudGltZS1jb21tb24vZGlzdC9saWIvaW5mZXJlbmNlLXNlc3Npb24uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ29GO0FBQ3BGO0FBQ08seUJBQXlCLHFFQUFvQjtBQUNwRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvb25ueHJ1bnRpbWUtY29tbW9uL2Rpc3QvbGliL2luZmVyZW5jZS1zZXNzaW9uLmpzPzk2YzQiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5pbXBvcnQgeyBJbmZlcmVuY2VTZXNzaW9uIGFzIEluZmVyZW5jZVNlc3Npb25JbXBsIH0gZnJvbSAnLi9pbmZlcmVuY2Utc2Vzc2lvbi1pbXBsJztcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb25cbmV4cG9ydCBjb25zdCBJbmZlcmVuY2VTZXNzaW9uID0gSW5mZXJlbmNlU2Vzc2lvbkltcGw7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmZlcmVuY2Utc2Vzc2lvbi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/onnxruntime-common/dist/lib/inference-session.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/onnxruntime-common/dist/lib/onnx-value.js":
/*!****************************************************************!*\
  !*** ./node_modules/onnxruntime-common/dist/lib/onnx-value.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\n//# sourceMappingURL=onnx-value.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9vbm54cnVudGltZS1jb21tb24vZGlzdC9saWIvb25ueC12YWx1ZS5qcyIsIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTtBQUNVO0FBQ1YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL29ubnhydW50aW1lLWNvbW1vbi9kaXN0L2xpYi9vbm54LXZhbHVlLmpzPzNhYmEiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5leHBvcnQge307XG4vLyMgc291cmNlTWFwcGluZ1VSTD1vbm54LXZhbHVlLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/onnxruntime-common/dist/lib/onnx-value.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/onnxruntime-common/dist/lib/tensor-impl.js":
/*!*****************************************************************!*\
  !*** ./node_modules/onnxruntime-common/dist/lib/tensor-impl.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Tensor: function() { return /* binding */ Tensor; }\n/* harmony export */ });\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\nconst isBigInt64ArrayAvailable = typeof BigInt64Array !== 'undefined' && typeof BigInt64Array.from === 'function';\nconst isBigUint64ArrayAvailable = typeof BigUint64Array !== 'undefined' && typeof BigUint64Array.from === 'function';\n// a runtime map that maps type string to TypedArray constructor. Should match Tensor.DataTypeMap.\nconst NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP = new Map([\n    ['float32', Float32Array],\n    ['uint8', Uint8Array],\n    ['int8', Int8Array],\n    ['uint16', Uint16Array],\n    ['int16', Int16Array],\n    ['int32', Int32Array],\n    ['bool', Uint8Array],\n    ['float64', Float64Array],\n    ['uint32', Uint32Array],\n]);\n// a runtime map that maps type string to TypedArray constructor. Should match Tensor.DataTypeMap.\nconst NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP = new Map([\n    [Float32Array, 'float32'],\n    [Uint8Array, 'uint8'],\n    [Int8Array, 'int8'],\n    [Uint16Array, 'uint16'],\n    [Int16Array, 'int16'],\n    [Int32Array, 'int32'],\n    [Float64Array, 'float64'],\n    [Uint32Array, 'uint32'],\n]);\nif (isBigInt64ArrayAvailable) {\n    NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.set('int64', BigInt64Array);\n    NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.set(BigInt64Array, 'int64');\n}\nif (isBigUint64ArrayAvailable) {\n    NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.set('uint64', BigUint64Array);\n    NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.set(BigUint64Array, 'uint64');\n}\n/**\n * calculate size from dims.\n *\n * @param dims the dims array. May be an illegal input.\n */\nconst calculateSize = (dims) => {\n    let size = 1;\n    for (let i = 0; i < dims.length; i++) {\n        const dim = dims[i];\n        if (typeof dim !== 'number' || !Number.isSafeInteger(dim)) {\n            throw new TypeError(`dims[${i}] must be an integer, got: ${dim}`);\n        }\n        if (dim < 0) {\n            throw new RangeError(`dims[${i}] must be a non-negative integer, got: ${dim}`);\n        }\n        size *= dim;\n    }\n    return size;\n};\nclass Tensor {\n    constructor(arg0, arg1, arg2) {\n        let type;\n        let data;\n        let dims;\n        // check whether arg0 is type or data\n        if (typeof arg0 === 'string') {\n            //\n            // Override: constructor(type, data, ...)\n            //\n            type = arg0;\n            dims = arg2;\n            if (arg0 === 'string') {\n                // string tensor\n                if (!Array.isArray(arg1)) {\n                    throw new TypeError('A string tensor\\'s data must be a string array.');\n                }\n                // we don't check whether every element in the array is string; this is too slow. we assume it's correct and\n                // error will be populated at inference\n                data = arg1;\n            }\n            else {\n                // numeric tensor\n                const typedArrayConstructor = NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.get(arg0);\n                if (typedArrayConstructor === undefined) {\n                    throw new TypeError(`Unsupported tensor type: ${arg0}.`);\n                }\n                if (Array.isArray(arg1)) {\n                    // use 'as any' here because TypeScript's check on type of 'SupportedTypedArrayConstructors.from()' produces\n                    // incorrect results.\n                    // 'typedArrayConstructor' should be one of the typed array prototype objects.\n                    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                    data = typedArrayConstructor.from(arg1);\n                }\n                else if (arg1 instanceof typedArrayConstructor) {\n                    data = arg1;\n                }\n                else {\n                    throw new TypeError(`A ${type} tensor's data must be type of ${typedArrayConstructor}`);\n                }\n            }\n        }\n        else {\n            //\n            // Override: constructor(data, ...)\n            //\n            dims = arg1;\n            if (Array.isArray(arg0)) {\n                // only boolean[] and string[] is supported\n                if (arg0.length === 0) {\n                    throw new TypeError('Tensor type cannot be inferred from an empty array.');\n                }\n                const firstElementType = typeof arg0[0];\n                if (firstElementType === 'string') {\n                    type = 'string';\n                    data = arg0;\n                }\n                else if (firstElementType === 'boolean') {\n                    type = 'bool';\n                    // 'arg0' is of type 'boolean[]'. Uint8Array.from(boolean[]) actually works, but typescript thinks this is\n                    // wrong type. We use 'as any' to make it happy.\n                    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                    data = Uint8Array.from(arg0);\n                }\n                else {\n                    throw new TypeError(`Invalid element type of data array: ${firstElementType}.`);\n                }\n            }\n            else {\n                // get tensor type from TypedArray\n                const mappedType = NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.get(arg0.constructor);\n                if (mappedType === undefined) {\n                    throw new TypeError(`Unsupported type for tensor data: ${arg0.constructor}.`);\n                }\n                type = mappedType;\n                data = arg0;\n            }\n        }\n        // type and data is processed, now processing dims\n        if (dims === undefined) {\n            // assume 1-D tensor if dims omitted\n            dims = [data.length];\n        }\n        else if (!Array.isArray(dims)) {\n            throw new TypeError('A tensor\\'s dims must be a number array');\n        }\n        // perform check\n        const size = calculateSize(dims);\n        if (size !== data.length) {\n            throw new Error(`Tensor's size(${size}) does not match data length(${data.length}).`);\n        }\n        this.dims = dims;\n        this.type = type;\n        this.data = data;\n        this.size = size;\n    }\n    // #endregion\n    /**\n     * Create a new tensor object from image object\n     *\n     * @param buffer - Extracted image buffer data - assuming RGBA format\n     * @param imageFormat - input image configuration - required configurations height, width, format\n     * @param tensorFormat - output tensor configuration - Default is RGB format\n     */\n    static bufferToTensor(buffer, options) {\n        if (buffer === undefined) {\n            throw new Error('Image buffer must be defined');\n        }\n        if (options.height === undefined || options.width === undefined) {\n            throw new Error('Image height and width must be defined');\n        }\n        const { height, width } = options;\n        const norm = options.norm;\n        let normMean;\n        let normBias;\n        if (norm === undefined || norm.mean === undefined) {\n            normMean = 255;\n        }\n        else {\n            normMean = norm.mean;\n        }\n        if (norm === undefined || norm.bias === undefined) {\n            normBias = 0;\n        }\n        else {\n            normBias = norm.bias;\n        }\n        const inputformat = options.bitmapFormat !== undefined ? options.bitmapFormat : 'RGBA';\n        // default value is RGBA since imagedata and HTMLImageElement uses it\n        const outputformat = options.tensorFormat !== undefined ?\n            (options.tensorFormat !== undefined ? options.tensorFormat : 'RGB') :\n            'RGB';\n        const offset = height * width;\n        const float32Data = outputformat === 'RGBA' ? new Float32Array(offset * 4) : new Float32Array(offset * 3);\n        // Default pointer assignments\n        let step = 4, rImagePointer = 0, gImagePointer = 1, bImagePointer = 2, aImagePointer = 3;\n        let rTensorPointer = 0, gTensorPointer = offset, bTensorPointer = offset * 2, aTensorPointer = -1;\n        // Updating the pointer assignments based on the input image format\n        if (inputformat === 'RGB') {\n            step = 3;\n            rImagePointer = 0;\n            gImagePointer = 1;\n            bImagePointer = 2;\n            aImagePointer = -1;\n        }\n        // Updating the pointer assignments based on the output tensor format\n        if (outputformat === 'RGBA') {\n            aTensorPointer = offset * 3;\n        }\n        else if (outputformat === 'RBG') {\n            rTensorPointer = 0;\n            bTensorPointer = offset;\n            gTensorPointer = offset * 2;\n        }\n        else if (outputformat === 'BGR') {\n            bTensorPointer = 0;\n            gTensorPointer = offset;\n            rTensorPointer = offset * 2;\n        }\n        for (let i = 0; i < offset; i++, rImagePointer += step, bImagePointer += step, gImagePointer += step, aImagePointer += step) {\n            float32Data[rTensorPointer++] = (buffer[rImagePointer] + normBias) / normMean;\n            float32Data[gTensorPointer++] = (buffer[gImagePointer] + normBias) / normMean;\n            float32Data[bTensorPointer++] = (buffer[bImagePointer] + normBias) / normMean;\n            if (aTensorPointer !== -1 && aImagePointer !== -1) {\n                float32Data[aTensorPointer++] = (buffer[aImagePointer] + normBias) / normMean;\n            }\n        }\n        // Float32Array -> ort.Tensor\n        const outputTensor = outputformat === 'RGBA' ? new Tensor('float32', float32Data, [1, 4, height, width]) :\n            new Tensor('float32', float32Data, [1, 3, height, width]);\n        return outputTensor;\n    }\n    static async fromImage(image, options) {\n        // checking the type of image object\n        const isHTMLImageEle = typeof (HTMLImageElement) !== 'undefined' && image instanceof HTMLImageElement;\n        const isImageDataEle = typeof (ImageData) !== 'undefined' && image instanceof ImageData;\n        const isImageBitmap = typeof (ImageBitmap) !== 'undefined' && image instanceof ImageBitmap;\n        const isURL = typeof (String) !== 'undefined' && (image instanceof String || typeof image === 'string');\n        let data;\n        let tensorConfig = {};\n        // filling and checking image configuration options\n        if (isHTMLImageEle) {\n            // HTMLImageElement - image object - format is RGBA by default\n            const canvas = document.createElement('canvas');\n            const pixels2DContext = canvas.getContext('2d');\n            if (pixels2DContext != null) {\n                let height = image.naturalHeight;\n                let width = image.naturalWidth;\n                if (options !== undefined && options.resizedHeight !== undefined && options.resizedWidth !== undefined) {\n                    height = options.resizedHeight;\n                    width = options.resizedWidth;\n                }\n                if (options !== undefined) {\n                    tensorConfig = options;\n                    if (options.tensorFormat !== undefined) {\n                        throw new Error('Image input config format must be RGBA for HTMLImageElement');\n                    }\n                    else {\n                        tensorConfig.tensorFormat = 'RGBA';\n                    }\n                    if (options.height !== undefined && options.height !== height) {\n                        throw new Error('Image input config height doesn\\'t match HTMLImageElement height');\n                    }\n                    else {\n                        tensorConfig.height = height;\n                    }\n                    if (options.width !== undefined && options.width !== width) {\n                        throw new Error('Image input config width doesn\\'t match HTMLImageElement width');\n                    }\n                    else {\n                        tensorConfig.width = width;\n                    }\n                }\n                else {\n                    tensorConfig.tensorFormat = 'RGBA';\n                    tensorConfig.height = height;\n                    tensorConfig.width = width;\n                }\n                canvas.width = width;\n                canvas.height = height;\n                pixels2DContext.drawImage(image, 0, 0, width, height);\n                data = pixels2DContext.getImageData(0, 0, width, height).data;\n            }\n            else {\n                throw new Error('Can not access image data');\n            }\n        }\n        else if (isImageDataEle) {\n            // ImageData - image object - format is RGBA by default\n            const format = 'RGBA';\n            let height;\n            let width;\n            if (options !== undefined && options.resizedWidth !== undefined && options.resizedHeight !== undefined) {\n                height = options.resizedHeight;\n                width = options.resizedWidth;\n            }\n            else {\n                height = image.height;\n                width = image.width;\n            }\n            if (options !== undefined) {\n                tensorConfig = options;\n                if (options.bitmapFormat !== undefined && options.bitmapFormat !== format) {\n                    throw new Error('Image input config format must be RGBA for ImageData');\n                }\n                else {\n                    tensorConfig.bitmapFormat = 'RGBA';\n                }\n            }\n            else {\n                tensorConfig.bitmapFormat = 'RGBA';\n            }\n            tensorConfig.height = height;\n            tensorConfig.width = width;\n            if (options !== undefined) {\n                const tempCanvas = document.createElement('canvas');\n                tempCanvas.width = width;\n                tempCanvas.height = height;\n                const pixels2DContext = tempCanvas.getContext('2d');\n                if (pixels2DContext != null) {\n                    pixels2DContext.putImageData(image, 0, 0);\n                    data = pixels2DContext.getImageData(0, 0, width, height).data;\n                }\n                else {\n                    throw new Error('Can not access image data');\n                }\n            }\n            else {\n                data = image.data;\n            }\n        }\n        else if (isImageBitmap) {\n            // ImageBitmap - image object - format must be provided by user\n            if (options === undefined) {\n                throw new Error('Please provide image config with format for Imagebitmap');\n            }\n            if (options.bitmapFormat !== undefined) {\n                throw new Error('Image input config format must be defined for ImageBitmap');\n            }\n            const pixels2DContext = document.createElement('canvas').getContext('2d');\n            if (pixels2DContext != null) {\n                const height = image.height;\n                const width = image.width;\n                pixels2DContext.drawImage(image, 0, 0, width, height);\n                data = pixels2DContext.getImageData(0, 0, width, height).data;\n                if (options !== undefined) {\n                    // using square brackets to avoid TS error - type 'never'\n                    if (options.height !== undefined && options.height !== height) {\n                        throw new Error('Image input config height doesn\\'t match ImageBitmap height');\n                    }\n                    else {\n                        tensorConfig.height = height;\n                    }\n                    // using square brackets to avoid TS error - type 'never'\n                    if (options.width !== undefined && options.width !== width) {\n                        throw new Error('Image input config width doesn\\'t match ImageBitmap width');\n                    }\n                    else {\n                        tensorConfig.width = width;\n                    }\n                }\n                else {\n                    tensorConfig.height = height;\n                    tensorConfig.width = width;\n                }\n                return Tensor.bufferToTensor(data, tensorConfig);\n            }\n            else {\n                throw new Error('Can not access image data');\n            }\n        }\n        else if (isURL) {\n            return new Promise((resolve, reject) => {\n                const canvas = document.createElement('canvas');\n                const context = canvas.getContext('2d');\n                if (!image || !context) {\n                    return reject();\n                }\n                const newImage = new Image();\n                newImage.crossOrigin = 'Anonymous';\n                newImage.src = image;\n                newImage.onload = () => {\n                    canvas.width = newImage.width;\n                    canvas.height = newImage.height;\n                    context.drawImage(newImage, 0, 0, canvas.width, canvas.height);\n                    const img = context.getImageData(0, 0, canvas.width, canvas.height);\n                    if (options !== undefined) {\n                        // using square brackets to avoid TS error - type 'never'\n                        if (options.height !== undefined && options.height !== canvas.height) {\n                            throw new Error('Image input config height doesn\\'t match ImageBitmap height');\n                        }\n                        else {\n                            tensorConfig.height = canvas.height;\n                        }\n                        // using square brackets to avoid TS error - type 'never'\n                        if (options.width !== undefined && options.width !== canvas.width) {\n                            throw new Error('Image input config width doesn\\'t match ImageBitmap width');\n                        }\n                        else {\n                            tensorConfig.width = canvas.width;\n                        }\n                    }\n                    else {\n                        tensorConfig.height = canvas.height;\n                        tensorConfig.width = canvas.width;\n                    }\n                    resolve(Tensor.bufferToTensor(img.data, tensorConfig));\n                };\n            });\n        }\n        else {\n            throw new Error('Input data provided is not supported - aborted tensor creation');\n        }\n        if (data !== undefined) {\n            return Tensor.bufferToTensor(data, tensorConfig);\n        }\n        else {\n            throw new Error('Input data provided is not supported - aborted tensor creation');\n        }\n    }\n    toImageData(options) {\n        var _a, _b;\n        const pixels2DContext = document.createElement('canvas').getContext('2d');\n        let image;\n        if (pixels2DContext != null) {\n            // Default values for height and width & format\n            const width = this.dims[3];\n            const height = this.dims[2];\n            const channels = this.dims[1];\n            const inputformat = options !== undefined ? (options.format !== undefined ? options.format : 'RGB') : 'RGB';\n            const normMean = options !== undefined ? (((_a = options.norm) === null || _a === void 0 ? void 0 : _a.mean) !== undefined ? options.norm.mean : 255) : 255;\n            const normBias = options !== undefined ? (((_b = options.norm) === null || _b === void 0 ? void 0 : _b.bias) !== undefined ? options.norm.bias : 0) : 0;\n            const offset = height * width;\n            if (options !== undefined) {\n                if (options.height !== undefined && options.height !== height) {\n                    throw new Error('Image output config height doesn\\'t match tensor height');\n                }\n                if (options.width !== undefined && options.width !== width) {\n                    throw new Error('Image output config width doesn\\'t match tensor width');\n                }\n                if (options.format !== undefined && (channels === 4 && options.format !== 'RGBA') ||\n                    (channels === 3 && (options.format !== 'RGB' && options.format !== 'BGR'))) {\n                    throw new Error('Tensor format doesn\\'t match input tensor dims');\n                }\n            }\n            // Default pointer assignments\n            const step = 4;\n            let rImagePointer = 0, gImagePointer = 1, bImagePointer = 2, aImagePointer = 3;\n            let rTensorPointer = 0, gTensorPointer = offset, bTensorPointer = offset * 2, aTensorPointer = -1;\n            // Updating the pointer assignments based on the input image format\n            if (inputformat === 'RGBA') {\n                rTensorPointer = 0;\n                gTensorPointer = offset;\n                bTensorPointer = offset * 2;\n                aTensorPointer = offset * 3;\n            }\n            else if (inputformat === 'RGB') {\n                rTensorPointer = 0;\n                gTensorPointer = offset;\n                bTensorPointer = offset * 2;\n            }\n            else if (inputformat === 'RBG') {\n                rTensorPointer = 0;\n                bTensorPointer = offset;\n                gTensorPointer = offset * 2;\n            }\n            image = pixels2DContext.createImageData(width, height);\n            for (let i = 0; i < height * width; rImagePointer += step, gImagePointer += step, bImagePointer += step, aImagePointer += step, i++) {\n                image.data[rImagePointer] = (this.data[rTensorPointer++] - normBias) * normMean; // R value\n                image.data[gImagePointer] = (this.data[gTensorPointer++] - normBias) * normMean; // G value\n                image.data[bImagePointer] = (this.data[bTensorPointer++] - normBias) * normMean; // B value\n                image.data[aImagePointer] =\n                    aTensorPointer === -1 ? 255 : (this.data[aTensorPointer++] - normBias) * normMean; // A value\n            }\n        }\n        else {\n            throw new Error('Can not access image data');\n        }\n        return image;\n    }\n    // #endregion\n    // #region tensor utilities\n    reshape(dims) {\n        return new Tensor(this.type, this.data, dims);\n    }\n}\n//# sourceMappingURL=tensor-impl.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9vbm54cnVudGltZS1jb21tb24vZGlzdC9saWIvdGVuc29yLWltcGwuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBLHdDQUF3QyxFQUFFLDZCQUE2QixJQUFJO0FBQzNFO0FBQ0E7QUFDQSx5Q0FBeUMsRUFBRSx5Q0FBeUMsSUFBSTtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdGQUFnRjtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRSxLQUFLO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxNQUFNLGdDQUFnQyxzQkFBc0I7QUFDekc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtFQUErRSxpQkFBaUI7QUFDaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFLGlCQUFpQjtBQUM5RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxLQUFLLCtCQUErQixZQUFZO0FBQzdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixnQkFBZ0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixZQUFZO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsb0JBQW9CO0FBQ2hELGlHQUFpRztBQUNqRyxpR0FBaUc7QUFDakcsaUdBQWlHO0FBQ2pHO0FBQ0EsdUdBQXVHO0FBQ3ZHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL29ubnhydW50aW1lLWNvbW1vbi9kaXN0L2xpYi90ZW5zb3ItaW1wbC5qcz82Nzk0Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuY29uc3QgaXNCaWdJbnQ2NEFycmF5QXZhaWxhYmxlID0gdHlwZW9mIEJpZ0ludDY0QXJyYXkgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBCaWdJbnQ2NEFycmF5LmZyb20gPT09ICdmdW5jdGlvbic7XG5jb25zdCBpc0JpZ1VpbnQ2NEFycmF5QXZhaWxhYmxlID0gdHlwZW9mIEJpZ1VpbnQ2NEFycmF5ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgQmlnVWludDY0QXJyYXkuZnJvbSA9PT0gJ2Z1bmN0aW9uJztcbi8vIGEgcnVudGltZSBtYXAgdGhhdCBtYXBzIHR5cGUgc3RyaW5nIHRvIFR5cGVkQXJyYXkgY29uc3RydWN0b3IuIFNob3VsZCBtYXRjaCBUZW5zb3IuRGF0YVR5cGVNYXAuXG5jb25zdCBOVU1FUklDX1RFTlNPUl9UWVBFX1RPX1RZUEVEQVJSQVlfTUFQID0gbmV3IE1hcChbXG4gICAgWydmbG9hdDMyJywgRmxvYXQzMkFycmF5XSxcbiAgICBbJ3VpbnQ4JywgVWludDhBcnJheV0sXG4gICAgWydpbnQ4JywgSW50OEFycmF5XSxcbiAgICBbJ3VpbnQxNicsIFVpbnQxNkFycmF5XSxcbiAgICBbJ2ludDE2JywgSW50MTZBcnJheV0sXG4gICAgWydpbnQzMicsIEludDMyQXJyYXldLFxuICAgIFsnYm9vbCcsIFVpbnQ4QXJyYXldLFxuICAgIFsnZmxvYXQ2NCcsIEZsb2F0NjRBcnJheV0sXG4gICAgWyd1aW50MzInLCBVaW50MzJBcnJheV0sXG5dKTtcbi8vIGEgcnVudGltZSBtYXAgdGhhdCBtYXBzIHR5cGUgc3RyaW5nIHRvIFR5cGVkQXJyYXkgY29uc3RydWN0b3IuIFNob3VsZCBtYXRjaCBUZW5zb3IuRGF0YVR5cGVNYXAuXG5jb25zdCBOVU1FUklDX1RFTlNPUl9UWVBFREFSUkFZX1RPX1RZUEVfTUFQID0gbmV3IE1hcChbXG4gICAgW0Zsb2F0MzJBcnJheSwgJ2Zsb2F0MzInXSxcbiAgICBbVWludDhBcnJheSwgJ3VpbnQ4J10sXG4gICAgW0ludDhBcnJheSwgJ2ludDgnXSxcbiAgICBbVWludDE2QXJyYXksICd1aW50MTYnXSxcbiAgICBbSW50MTZBcnJheSwgJ2ludDE2J10sXG4gICAgW0ludDMyQXJyYXksICdpbnQzMiddLFxuICAgIFtGbG9hdDY0QXJyYXksICdmbG9hdDY0J10sXG4gICAgW1VpbnQzMkFycmF5LCAndWludDMyJ10sXG5dKTtcbmlmIChpc0JpZ0ludDY0QXJyYXlBdmFpbGFibGUpIHtcbiAgICBOVU1FUklDX1RFTlNPUl9UWVBFX1RPX1RZUEVEQVJSQVlfTUFQLnNldCgnaW50NjQnLCBCaWdJbnQ2NEFycmF5KTtcbiAgICBOVU1FUklDX1RFTlNPUl9UWVBFREFSUkFZX1RPX1RZUEVfTUFQLnNldChCaWdJbnQ2NEFycmF5LCAnaW50NjQnKTtcbn1cbmlmIChpc0JpZ1VpbnQ2NEFycmF5QXZhaWxhYmxlKSB7XG4gICAgTlVNRVJJQ19URU5TT1JfVFlQRV9UT19UWVBFREFSUkFZX01BUC5zZXQoJ3VpbnQ2NCcsIEJpZ1VpbnQ2NEFycmF5KTtcbiAgICBOVU1FUklDX1RFTlNPUl9UWVBFREFSUkFZX1RPX1RZUEVfTUFQLnNldChCaWdVaW50NjRBcnJheSwgJ3VpbnQ2NCcpO1xufVxuLyoqXG4gKiBjYWxjdWxhdGUgc2l6ZSBmcm9tIGRpbXMuXG4gKlxuICogQHBhcmFtIGRpbXMgdGhlIGRpbXMgYXJyYXkuIE1heSBiZSBhbiBpbGxlZ2FsIGlucHV0LlxuICovXG5jb25zdCBjYWxjdWxhdGVTaXplID0gKGRpbXMpID0+IHtcbiAgICBsZXQgc2l6ZSA9IDE7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkaW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGRpbSA9IGRpbXNbaV07XG4gICAgICAgIGlmICh0eXBlb2YgZGltICE9PSAnbnVtYmVyJyB8fCAhTnVtYmVyLmlzU2FmZUludGVnZXIoZGltKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgZGltc1ske2l9XSBtdXN0IGJlIGFuIGludGVnZXIsIGdvdDogJHtkaW19YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRpbSA8IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBkaW1zWyR7aX1dIG11c3QgYmUgYSBub24tbmVnYXRpdmUgaW50ZWdlciwgZ290OiAke2RpbX1gKTtcbiAgICAgICAgfVxuICAgICAgICBzaXplICo9IGRpbTtcbiAgICB9XG4gICAgcmV0dXJuIHNpemU7XG59O1xuZXhwb3J0IGNsYXNzIFRlbnNvciB7XG4gICAgY29uc3RydWN0b3IoYXJnMCwgYXJnMSwgYXJnMikge1xuICAgICAgICBsZXQgdHlwZTtcbiAgICAgICAgbGV0IGRhdGE7XG4gICAgICAgIGxldCBkaW1zO1xuICAgICAgICAvLyBjaGVjayB3aGV0aGVyIGFyZzAgaXMgdHlwZSBvciBkYXRhXG4gICAgICAgIGlmICh0eXBlb2YgYXJnMCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBPdmVycmlkZTogY29uc3RydWN0b3IodHlwZSwgZGF0YSwgLi4uKVxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIHR5cGUgPSBhcmcwO1xuICAgICAgICAgICAgZGltcyA9IGFyZzI7XG4gICAgICAgICAgICBpZiAoYXJnMCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAvLyBzdHJpbmcgdGVuc29yXG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGFyZzEpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Egc3RyaW5nIHRlbnNvclxcJ3MgZGF0YSBtdXN0IGJlIGEgc3RyaW5nIGFycmF5LicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyB3ZSBkb24ndCBjaGVjayB3aGV0aGVyIGV2ZXJ5IGVsZW1lbnQgaW4gdGhlIGFycmF5IGlzIHN0cmluZzsgdGhpcyBpcyB0b28gc2xvdy4gd2UgYXNzdW1lIGl0J3MgY29ycmVjdCBhbmRcbiAgICAgICAgICAgICAgICAvLyBlcnJvciB3aWxsIGJlIHBvcHVsYXRlZCBhdCBpbmZlcmVuY2VcbiAgICAgICAgICAgICAgICBkYXRhID0gYXJnMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIG51bWVyaWMgdGVuc29yXG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZWRBcnJheUNvbnN0cnVjdG9yID0gTlVNRVJJQ19URU5TT1JfVFlQRV9UT19UWVBFREFSUkFZX01BUC5nZXQoYXJnMCk7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVkQXJyYXlDb25zdHJ1Y3RvciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFVuc3VwcG9ydGVkIHRlbnNvciB0eXBlOiAke2FyZzB9LmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhcmcxKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyB1c2UgJ2FzIGFueScgaGVyZSBiZWNhdXNlIFR5cGVTY3JpcHQncyBjaGVjayBvbiB0eXBlIG9mICdTdXBwb3J0ZWRUeXBlZEFycmF5Q29uc3RydWN0b3JzLmZyb20oKScgcHJvZHVjZXNcbiAgICAgICAgICAgICAgICAgICAgLy8gaW5jb3JyZWN0IHJlc3VsdHMuXG4gICAgICAgICAgICAgICAgICAgIC8vICd0eXBlZEFycmF5Q29uc3RydWN0b3InIHNob3VsZCBiZSBvbmUgb2YgdGhlIHR5cGVkIGFycmF5IHByb3RvdHlwZSBvYmplY3RzLlxuICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgICAgICAgICBkYXRhID0gdHlwZWRBcnJheUNvbnN0cnVjdG9yLmZyb20oYXJnMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGFyZzEgaW5zdGFuY2VvZiB0eXBlZEFycmF5Q29uc3RydWN0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IGFyZzE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBBICR7dHlwZX0gdGVuc29yJ3MgZGF0YSBtdXN0IGJlIHR5cGUgb2YgJHt0eXBlZEFycmF5Q29uc3RydWN0b3J9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIE92ZXJyaWRlOiBjb25zdHJ1Y3RvcihkYXRhLCAuLi4pXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgZGltcyA9IGFyZzE7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhcmcwKSkge1xuICAgICAgICAgICAgICAgIC8vIG9ubHkgYm9vbGVhbltdIGFuZCBzdHJpbmdbXSBpcyBzdXBwb3J0ZWRcbiAgICAgICAgICAgICAgICBpZiAoYXJnMC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGVuc29yIHR5cGUgY2Fubm90IGJlIGluZmVycmVkIGZyb20gYW4gZW1wdHkgYXJyYXkuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGZpcnN0RWxlbWVudFR5cGUgPSB0eXBlb2YgYXJnMFswXTtcbiAgICAgICAgICAgICAgICBpZiAoZmlyc3RFbGVtZW50VHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZSA9ICdzdHJpbmcnO1xuICAgICAgICAgICAgICAgICAgICBkYXRhID0gYXJnMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZmlyc3RFbGVtZW50VHlwZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGUgPSAnYm9vbCc7XG4gICAgICAgICAgICAgICAgICAgIC8vICdhcmcwJyBpcyBvZiB0eXBlICdib29sZWFuW10nLiBVaW50OEFycmF5LmZyb20oYm9vbGVhbltdKSBhY3R1YWxseSB3b3JrcywgYnV0IHR5cGVzY3JpcHQgdGhpbmtzIHRoaXMgaXNcbiAgICAgICAgICAgICAgICAgICAgLy8gd3JvbmcgdHlwZS4gV2UgdXNlICdhcyBhbnknIHRvIG1ha2UgaXQgaGFwcHkuXG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSBVaW50OEFycmF5LmZyb20oYXJnMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkIGVsZW1lbnQgdHlwZSBvZiBkYXRhIGFycmF5OiAke2ZpcnN0RWxlbWVudFR5cGV9LmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGdldCB0ZW5zb3IgdHlwZSBmcm9tIFR5cGVkQXJyYXlcbiAgICAgICAgICAgICAgICBjb25zdCBtYXBwZWRUeXBlID0gTlVNRVJJQ19URU5TT1JfVFlQRURBUlJBWV9UT19UWVBFX01BUC5nZXQoYXJnMC5jb25zdHJ1Y3Rvcik7XG4gICAgICAgICAgICAgICAgaWYgKG1hcHBlZFR5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBVbnN1cHBvcnRlZCB0eXBlIGZvciB0ZW5zb3IgZGF0YTogJHthcmcwLmNvbnN0cnVjdG9yfS5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdHlwZSA9IG1hcHBlZFR5cGU7XG4gICAgICAgICAgICAgICAgZGF0YSA9IGFyZzA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gdHlwZSBhbmQgZGF0YSBpcyBwcm9jZXNzZWQsIG5vdyBwcm9jZXNzaW5nIGRpbXNcbiAgICAgICAgaWYgKGRpbXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gYXNzdW1lIDEtRCB0ZW5zb3IgaWYgZGltcyBvbWl0dGVkXG4gICAgICAgICAgICBkaW1zID0gW2RhdGEubGVuZ3RoXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghQXJyYXkuaXNBcnJheShkaW1zKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQSB0ZW5zb3JcXCdzIGRpbXMgbXVzdCBiZSBhIG51bWJlciBhcnJheScpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHBlcmZvcm0gY2hlY2tcbiAgICAgICAgY29uc3Qgc2l6ZSA9IGNhbGN1bGF0ZVNpemUoZGltcyk7XG4gICAgICAgIGlmIChzaXplICE9PSBkYXRhLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUZW5zb3IncyBzaXplKCR7c2l6ZX0pIGRvZXMgbm90IG1hdGNoIGRhdGEgbGVuZ3RoKCR7ZGF0YS5sZW5ndGh9KS5gKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRpbXMgPSBkaW1zO1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgICAgICB0aGlzLnNpemUgPSBzaXplO1xuICAgIH1cbiAgICAvLyAjZW5kcmVnaW9uXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IHRlbnNvciBvYmplY3QgZnJvbSBpbWFnZSBvYmplY3RcbiAgICAgKlxuICAgICAqIEBwYXJhbSBidWZmZXIgLSBFeHRyYWN0ZWQgaW1hZ2UgYnVmZmVyIGRhdGEgLSBhc3N1bWluZyBSR0JBIGZvcm1hdFxuICAgICAqIEBwYXJhbSBpbWFnZUZvcm1hdCAtIGlucHV0IGltYWdlIGNvbmZpZ3VyYXRpb24gLSByZXF1aXJlZCBjb25maWd1cmF0aW9ucyBoZWlnaHQsIHdpZHRoLCBmb3JtYXRcbiAgICAgKiBAcGFyYW0gdGVuc29yRm9ybWF0IC0gb3V0cHV0IHRlbnNvciBjb25maWd1cmF0aW9uIC0gRGVmYXVsdCBpcyBSR0IgZm9ybWF0XG4gICAgICovXG4gICAgc3RhdGljIGJ1ZmZlclRvVGVuc29yKGJ1ZmZlciwgb3B0aW9ucykge1xuICAgICAgICBpZiAoYnVmZmVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW1hZ2UgYnVmZmVyIG11c3QgYmUgZGVmaW5lZCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmhlaWdodCA9PT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMud2lkdGggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbWFnZSBoZWlnaHQgYW5kIHdpZHRoIG11c3QgYmUgZGVmaW5lZCcpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgaGVpZ2h0LCB3aWR0aCB9ID0gb3B0aW9ucztcbiAgICAgICAgY29uc3Qgbm9ybSA9IG9wdGlvbnMubm9ybTtcbiAgICAgICAgbGV0IG5vcm1NZWFuO1xuICAgICAgICBsZXQgbm9ybUJpYXM7XG4gICAgICAgIGlmIChub3JtID09PSB1bmRlZmluZWQgfHwgbm9ybS5tZWFuID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG5vcm1NZWFuID0gMjU1O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbm9ybU1lYW4gPSBub3JtLm1lYW47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vcm0gPT09IHVuZGVmaW5lZCB8fCBub3JtLmJpYXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbm9ybUJpYXMgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbm9ybUJpYXMgPSBub3JtLmJpYXM7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaW5wdXRmb3JtYXQgPSBvcHRpb25zLmJpdG1hcEZvcm1hdCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5iaXRtYXBGb3JtYXQgOiAnUkdCQSc7XG4gICAgICAgIC8vIGRlZmF1bHQgdmFsdWUgaXMgUkdCQSBzaW5jZSBpbWFnZWRhdGEgYW5kIEhUTUxJbWFnZUVsZW1lbnQgdXNlcyBpdFxuICAgICAgICBjb25zdCBvdXRwdXRmb3JtYXQgPSBvcHRpb25zLnRlbnNvckZvcm1hdCAhPT0gdW5kZWZpbmVkID9cbiAgICAgICAgICAgIChvcHRpb25zLnRlbnNvckZvcm1hdCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy50ZW5zb3JGb3JtYXQgOiAnUkdCJykgOlxuICAgICAgICAgICAgJ1JHQic7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IGhlaWdodCAqIHdpZHRoO1xuICAgICAgICBjb25zdCBmbG9hdDMyRGF0YSA9IG91dHB1dGZvcm1hdCA9PT0gJ1JHQkEnID8gbmV3IEZsb2F0MzJBcnJheShvZmZzZXQgKiA0KSA6IG5ldyBGbG9hdDMyQXJyYXkob2Zmc2V0ICogMyk7XG4gICAgICAgIC8vIERlZmF1bHQgcG9pbnRlciBhc3NpZ25tZW50c1xuICAgICAgICBsZXQgc3RlcCA9IDQsIHJJbWFnZVBvaW50ZXIgPSAwLCBnSW1hZ2VQb2ludGVyID0gMSwgYkltYWdlUG9pbnRlciA9IDIsIGFJbWFnZVBvaW50ZXIgPSAzO1xuICAgICAgICBsZXQgclRlbnNvclBvaW50ZXIgPSAwLCBnVGVuc29yUG9pbnRlciA9IG9mZnNldCwgYlRlbnNvclBvaW50ZXIgPSBvZmZzZXQgKiAyLCBhVGVuc29yUG9pbnRlciA9IC0xO1xuICAgICAgICAvLyBVcGRhdGluZyB0aGUgcG9pbnRlciBhc3NpZ25tZW50cyBiYXNlZCBvbiB0aGUgaW5wdXQgaW1hZ2UgZm9ybWF0XG4gICAgICAgIGlmIChpbnB1dGZvcm1hdCA9PT0gJ1JHQicpIHtcbiAgICAgICAgICAgIHN0ZXAgPSAzO1xuICAgICAgICAgICAgckltYWdlUG9pbnRlciA9IDA7XG4gICAgICAgICAgICBnSW1hZ2VQb2ludGVyID0gMTtcbiAgICAgICAgICAgIGJJbWFnZVBvaW50ZXIgPSAyO1xuICAgICAgICAgICAgYUltYWdlUG9pbnRlciA9IC0xO1xuICAgICAgICB9XG4gICAgICAgIC8vIFVwZGF0aW5nIHRoZSBwb2ludGVyIGFzc2lnbm1lbnRzIGJhc2VkIG9uIHRoZSBvdXRwdXQgdGVuc29yIGZvcm1hdFxuICAgICAgICBpZiAob3V0cHV0Zm9ybWF0ID09PSAnUkdCQScpIHtcbiAgICAgICAgICAgIGFUZW5zb3JQb2ludGVyID0gb2Zmc2V0ICogMztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvdXRwdXRmb3JtYXQgPT09ICdSQkcnKSB7XG4gICAgICAgICAgICByVGVuc29yUG9pbnRlciA9IDA7XG4gICAgICAgICAgICBiVGVuc29yUG9pbnRlciA9IG9mZnNldDtcbiAgICAgICAgICAgIGdUZW5zb3JQb2ludGVyID0gb2Zmc2V0ICogMjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvdXRwdXRmb3JtYXQgPT09ICdCR1InKSB7XG4gICAgICAgICAgICBiVGVuc29yUG9pbnRlciA9IDA7XG4gICAgICAgICAgICBnVGVuc29yUG9pbnRlciA9IG9mZnNldDtcbiAgICAgICAgICAgIHJUZW5zb3JQb2ludGVyID0gb2Zmc2V0ICogMjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9mZnNldDsgaSsrLCBySW1hZ2VQb2ludGVyICs9IHN0ZXAsIGJJbWFnZVBvaW50ZXIgKz0gc3RlcCwgZ0ltYWdlUG9pbnRlciArPSBzdGVwLCBhSW1hZ2VQb2ludGVyICs9IHN0ZXApIHtcbiAgICAgICAgICAgIGZsb2F0MzJEYXRhW3JUZW5zb3JQb2ludGVyKytdID0gKGJ1ZmZlcltySW1hZ2VQb2ludGVyXSArIG5vcm1CaWFzKSAvIG5vcm1NZWFuO1xuICAgICAgICAgICAgZmxvYXQzMkRhdGFbZ1RlbnNvclBvaW50ZXIrK10gPSAoYnVmZmVyW2dJbWFnZVBvaW50ZXJdICsgbm9ybUJpYXMpIC8gbm9ybU1lYW47XG4gICAgICAgICAgICBmbG9hdDMyRGF0YVtiVGVuc29yUG9pbnRlcisrXSA9IChidWZmZXJbYkltYWdlUG9pbnRlcl0gKyBub3JtQmlhcykgLyBub3JtTWVhbjtcbiAgICAgICAgICAgIGlmIChhVGVuc29yUG9pbnRlciAhPT0gLTEgJiYgYUltYWdlUG9pbnRlciAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBmbG9hdDMyRGF0YVthVGVuc29yUG9pbnRlcisrXSA9IChidWZmZXJbYUltYWdlUG9pbnRlcl0gKyBub3JtQmlhcykgLyBub3JtTWVhbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBGbG9hdDMyQXJyYXkgLT4gb3J0LlRlbnNvclxuICAgICAgICBjb25zdCBvdXRwdXRUZW5zb3IgPSBvdXRwdXRmb3JtYXQgPT09ICdSR0JBJyA/IG5ldyBUZW5zb3IoJ2Zsb2F0MzInLCBmbG9hdDMyRGF0YSwgWzEsIDQsIGhlaWdodCwgd2lkdGhdKSA6XG4gICAgICAgICAgICBuZXcgVGVuc29yKCdmbG9hdDMyJywgZmxvYXQzMkRhdGEsIFsxLCAzLCBoZWlnaHQsIHdpZHRoXSk7XG4gICAgICAgIHJldHVybiBvdXRwdXRUZW5zb3I7XG4gICAgfVxuICAgIHN0YXRpYyBhc3luYyBmcm9tSW1hZ2UoaW1hZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgLy8gY2hlY2tpbmcgdGhlIHR5cGUgb2YgaW1hZ2Ugb2JqZWN0XG4gICAgICAgIGNvbnN0IGlzSFRNTEltYWdlRWxlID0gdHlwZW9mIChIVE1MSW1hZ2VFbGVtZW50KSAhPT0gJ3VuZGVmaW5lZCcgJiYgaW1hZ2UgaW5zdGFuY2VvZiBIVE1MSW1hZ2VFbGVtZW50O1xuICAgICAgICBjb25zdCBpc0ltYWdlRGF0YUVsZSA9IHR5cGVvZiAoSW1hZ2VEYXRhKSAhPT0gJ3VuZGVmaW5lZCcgJiYgaW1hZ2UgaW5zdGFuY2VvZiBJbWFnZURhdGE7XG4gICAgICAgIGNvbnN0IGlzSW1hZ2VCaXRtYXAgPSB0eXBlb2YgKEltYWdlQml0bWFwKSAhPT0gJ3VuZGVmaW5lZCcgJiYgaW1hZ2UgaW5zdGFuY2VvZiBJbWFnZUJpdG1hcDtcbiAgICAgICAgY29uc3QgaXNVUkwgPSB0eXBlb2YgKFN0cmluZykgIT09ICd1bmRlZmluZWQnICYmIChpbWFnZSBpbnN0YW5jZW9mIFN0cmluZyB8fCB0eXBlb2YgaW1hZ2UgPT09ICdzdHJpbmcnKTtcbiAgICAgICAgbGV0IGRhdGE7XG4gICAgICAgIGxldCB0ZW5zb3JDb25maWcgPSB7fTtcbiAgICAgICAgLy8gZmlsbGluZyBhbmQgY2hlY2tpbmcgaW1hZ2UgY29uZmlndXJhdGlvbiBvcHRpb25zXG4gICAgICAgIGlmIChpc0hUTUxJbWFnZUVsZSkge1xuICAgICAgICAgICAgLy8gSFRNTEltYWdlRWxlbWVudCAtIGltYWdlIG9iamVjdCAtIGZvcm1hdCBpcyBSR0JBIGJ5IGRlZmF1bHRcbiAgICAgICAgICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICAgICAgY29uc3QgcGl4ZWxzMkRDb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgICAgICBpZiAocGl4ZWxzMkRDb250ZXh0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBsZXQgaGVpZ2h0ID0gaW1hZ2UubmF0dXJhbEhlaWdodDtcbiAgICAgICAgICAgICAgICBsZXQgd2lkdGggPSBpbWFnZS5uYXR1cmFsV2lkdGg7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMgIT09IHVuZGVmaW5lZCAmJiBvcHRpb25zLnJlc2l6ZWRIZWlnaHQgIT09IHVuZGVmaW5lZCAmJiBvcHRpb25zLnJlc2l6ZWRXaWR0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGhlaWdodCA9IG9wdGlvbnMucmVzaXplZEhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgd2lkdGggPSBvcHRpb25zLnJlc2l6ZWRXaWR0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICB0ZW5zb3JDb25maWcgPSBvcHRpb25zO1xuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy50ZW5zb3JGb3JtYXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbWFnZSBpbnB1dCBjb25maWcgZm9ybWF0IG11c3QgYmUgUkdCQSBmb3IgSFRNTEltYWdlRWxlbWVudCcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGVuc29yQ29uZmlnLnRlbnNvckZvcm1hdCA9ICdSR0JBJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5oZWlnaHQgIT09IHVuZGVmaW5lZCAmJiBvcHRpb25zLmhlaWdodCAhPT0gaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ltYWdlIGlucHV0IGNvbmZpZyBoZWlnaHQgZG9lc25cXCd0IG1hdGNoIEhUTUxJbWFnZUVsZW1lbnQgaGVpZ2h0Jyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZW5zb3JDb25maWcuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLndpZHRoICE9PSB1bmRlZmluZWQgJiYgb3B0aW9ucy53aWR0aCAhPT0gd2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW1hZ2UgaW5wdXQgY29uZmlnIHdpZHRoIGRvZXNuXFwndCBtYXRjaCBIVE1MSW1hZ2VFbGVtZW50IHdpZHRoJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZW5zb3JDb25maWcud2lkdGggPSB3aWR0aDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGVuc29yQ29uZmlnLnRlbnNvckZvcm1hdCA9ICdSR0JBJztcbiAgICAgICAgICAgICAgICAgICAgdGVuc29yQ29uZmlnLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgdGVuc29yQ29uZmlnLndpZHRoID0gd2lkdGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhbnZhcy53aWR0aCA9IHdpZHRoO1xuICAgICAgICAgICAgICAgIGNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgICAgICAgICAgcGl4ZWxzMkRDb250ZXh0LmRyYXdJbWFnZShpbWFnZSwgMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgICAgICAgZGF0YSA9IHBpeGVsczJEQ29udGV4dC5nZXRJbWFnZURhdGEoMCwgMCwgd2lkdGgsIGhlaWdodCkuZGF0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2FuIG5vdCBhY2Nlc3MgaW1hZ2UgZGF0YScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzSW1hZ2VEYXRhRWxlKSB7XG4gICAgICAgICAgICAvLyBJbWFnZURhdGEgLSBpbWFnZSBvYmplY3QgLSBmb3JtYXQgaXMgUkdCQSBieSBkZWZhdWx0XG4gICAgICAgICAgICBjb25zdCBmb3JtYXQgPSAnUkdCQSc7XG4gICAgICAgICAgICBsZXQgaGVpZ2h0O1xuICAgICAgICAgICAgbGV0IHdpZHRoO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMgIT09IHVuZGVmaW5lZCAmJiBvcHRpb25zLnJlc2l6ZWRXaWR0aCAhPT0gdW5kZWZpbmVkICYmIG9wdGlvbnMucmVzaXplZEhlaWdodCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgaGVpZ2h0ID0gb3B0aW9ucy5yZXNpemVkSGVpZ2h0O1xuICAgICAgICAgICAgICAgIHdpZHRoID0gb3B0aW9ucy5yZXNpemVkV2lkdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBoZWlnaHQgPSBpbWFnZS5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgd2lkdGggPSBpbWFnZS53aWR0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHRpb25zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0ZW5zb3JDb25maWcgPSBvcHRpb25zO1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmJpdG1hcEZvcm1hdCAhPT0gdW5kZWZpbmVkICYmIG9wdGlvbnMuYml0bWFwRm9ybWF0ICE9PSBmb3JtYXQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbWFnZSBpbnB1dCBjb25maWcgZm9ybWF0IG11c3QgYmUgUkdCQSBmb3IgSW1hZ2VEYXRhJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0ZW5zb3JDb25maWcuYml0bWFwRm9ybWF0ID0gJ1JHQkEnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRlbnNvckNvbmZpZy5iaXRtYXBGb3JtYXQgPSAnUkdCQSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0ZW5zb3JDb25maWcuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICAgICAgdGVuc29yQ29uZmlnLndpZHRoID0gd2lkdGg7XG4gICAgICAgICAgICBpZiAob3B0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdGVtcENhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICAgICAgICAgIHRlbXBDYW52YXMud2lkdGggPSB3aWR0aDtcbiAgICAgICAgICAgICAgICB0ZW1wQ2FudmFzLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgICAgICAgICBjb25zdCBwaXhlbHMyRENvbnRleHQgPSB0ZW1wQ2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgICAgICAgICAgaWYgKHBpeGVsczJEQ29udGV4dCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHBpeGVsczJEQ29udGV4dC5wdXRJbWFnZURhdGEoaW1hZ2UsIDAsIDApO1xuICAgICAgICAgICAgICAgICAgICBkYXRhID0gcGl4ZWxzMkRDb250ZXh0LmdldEltYWdlRGF0YSgwLCAwLCB3aWR0aCwgaGVpZ2h0KS5kYXRhO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW4gbm90IGFjY2VzcyBpbWFnZSBkYXRhJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZGF0YSA9IGltYWdlLmRhdGE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNJbWFnZUJpdG1hcCkge1xuICAgICAgICAgICAgLy8gSW1hZ2VCaXRtYXAgLSBpbWFnZSBvYmplY3QgLSBmb3JtYXQgbXVzdCBiZSBwcm92aWRlZCBieSB1c2VyXG4gICAgICAgICAgICBpZiAob3B0aW9ucyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQbGVhc2UgcHJvdmlkZSBpbWFnZSBjb25maWcgd2l0aCBmb3JtYXQgZm9yIEltYWdlYml0bWFwJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5iaXRtYXBGb3JtYXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW1hZ2UgaW5wdXQgY29uZmlnIGZvcm1hdCBtdXN0IGJlIGRlZmluZWQgZm9yIEltYWdlQml0bWFwJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBwaXhlbHMyRENvbnRleHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKS5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICAgICAgaWYgKHBpeGVsczJEQ29udGV4dCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaGVpZ2h0ID0gaW1hZ2UuaGVpZ2h0O1xuICAgICAgICAgICAgICAgIGNvbnN0IHdpZHRoID0gaW1hZ2Uud2lkdGg7XG4gICAgICAgICAgICAgICAgcGl4ZWxzMkRDb250ZXh0LmRyYXdJbWFnZShpbWFnZSwgMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgICAgICAgZGF0YSA9IHBpeGVsczJEQ29udGV4dC5nZXRJbWFnZURhdGEoMCwgMCwgd2lkdGgsIGhlaWdodCkuZGF0YTtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHVzaW5nIHNxdWFyZSBicmFja2V0cyB0byBhdm9pZCBUUyBlcnJvciAtIHR5cGUgJ25ldmVyJ1xuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5oZWlnaHQgIT09IHVuZGVmaW5lZCAmJiBvcHRpb25zLmhlaWdodCAhPT0gaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ltYWdlIGlucHV0IGNvbmZpZyBoZWlnaHQgZG9lc25cXCd0IG1hdGNoIEltYWdlQml0bWFwIGhlaWdodCcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGVuc29yQ29uZmlnLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyB1c2luZyBzcXVhcmUgYnJhY2tldHMgdG8gYXZvaWQgVFMgZXJyb3IgLSB0eXBlICduZXZlcidcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMud2lkdGggIT09IHVuZGVmaW5lZCAmJiBvcHRpb25zLndpZHRoICE9PSB3aWR0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbWFnZSBpbnB1dCBjb25maWcgd2lkdGggZG9lc25cXCd0IG1hdGNoIEltYWdlQml0bWFwIHdpZHRoJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZW5zb3JDb25maWcud2lkdGggPSB3aWR0aDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGVuc29yQ29uZmlnLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgdGVuc29yQ29uZmlnLndpZHRoID0gd2lkdGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBUZW5zb3IuYnVmZmVyVG9UZW5zb3IoZGF0YSwgdGVuc29yQ29uZmlnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2FuIG5vdCBhY2Nlc3MgaW1hZ2UgZGF0YScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzVVJMKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgICAgICAgICBpZiAoIWltYWdlIHx8ICFjb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3SW1hZ2UgPSBuZXcgSW1hZ2UoKTtcbiAgICAgICAgICAgICAgICBuZXdJbWFnZS5jcm9zc09yaWdpbiA9ICdBbm9ueW1vdXMnO1xuICAgICAgICAgICAgICAgIG5ld0ltYWdlLnNyYyA9IGltYWdlO1xuICAgICAgICAgICAgICAgIG5ld0ltYWdlLm9ubG9hZCA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY2FudmFzLndpZHRoID0gbmV3SW1hZ2Uud2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIGNhbnZhcy5oZWlnaHQgPSBuZXdJbWFnZS5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuZHJhd0ltYWdlKG5ld0ltYWdlLCAwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpbWcgPSBjb250ZXh0LmdldEltYWdlRGF0YSgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB1c2luZyBzcXVhcmUgYnJhY2tldHMgdG8gYXZvaWQgVFMgZXJyb3IgLSB0eXBlICduZXZlcidcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmhlaWdodCAhPT0gdW5kZWZpbmVkICYmIG9wdGlvbnMuaGVpZ2h0ICE9PSBjYW52YXMuaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbWFnZSBpbnB1dCBjb25maWcgaGVpZ2h0IGRvZXNuXFwndCBtYXRjaCBJbWFnZUJpdG1hcCBoZWlnaHQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlbnNvckNvbmZpZy5oZWlnaHQgPSBjYW52YXMuaGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdXNpbmcgc3F1YXJlIGJyYWNrZXRzIHRvIGF2b2lkIFRTIGVycm9yIC0gdHlwZSAnbmV2ZXInXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy53aWR0aCAhPT0gdW5kZWZpbmVkICYmIG9wdGlvbnMud2lkdGggIT09IGNhbnZhcy53aWR0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW1hZ2UgaW5wdXQgY29uZmlnIHdpZHRoIGRvZXNuXFwndCBtYXRjaCBJbWFnZUJpdG1hcCB3aWR0aCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVuc29yQ29uZmlnLndpZHRoID0gY2FudmFzLndpZHRoO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGVuc29yQ29uZmlnLmhlaWdodCA9IGNhbnZhcy5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZW5zb3JDb25maWcud2lkdGggPSBjYW52YXMud2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShUZW5zb3IuYnVmZmVyVG9UZW5zb3IoaW1nLmRhdGEsIHRlbnNvckNvbmZpZykpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgZGF0YSBwcm92aWRlZCBpcyBub3Qgc3VwcG9ydGVkIC0gYWJvcnRlZCB0ZW5zb3IgY3JlYXRpb24nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gVGVuc29yLmJ1ZmZlclRvVGVuc29yKGRhdGEsIHRlbnNvckNvbmZpZyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IGRhdGEgcHJvdmlkZWQgaXMgbm90IHN1cHBvcnRlZCAtIGFib3J0ZWQgdGVuc29yIGNyZWF0aW9uJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdG9JbWFnZURhdGEob3B0aW9ucykge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBjb25zdCBwaXhlbHMyRENvbnRleHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKS5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICBsZXQgaW1hZ2U7XG4gICAgICAgIGlmIChwaXhlbHMyRENvbnRleHQgIT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gRGVmYXVsdCB2YWx1ZXMgZm9yIGhlaWdodCBhbmQgd2lkdGggJiBmb3JtYXRcbiAgICAgICAgICAgIGNvbnN0IHdpZHRoID0gdGhpcy5kaW1zWzNdO1xuICAgICAgICAgICAgY29uc3QgaGVpZ2h0ID0gdGhpcy5kaW1zWzJdO1xuICAgICAgICAgICAgY29uc3QgY2hhbm5lbHMgPSB0aGlzLmRpbXNbMV07XG4gICAgICAgICAgICBjb25zdCBpbnB1dGZvcm1hdCA9IG9wdGlvbnMgIT09IHVuZGVmaW5lZCA/IChvcHRpb25zLmZvcm1hdCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5mb3JtYXQgOiAnUkdCJykgOiAnUkdCJztcbiAgICAgICAgICAgIGNvbnN0IG5vcm1NZWFuID0gb3B0aW9ucyAhPT0gdW5kZWZpbmVkID8gKCgoX2EgPSBvcHRpb25zLm5vcm0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tZWFuKSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5ub3JtLm1lYW4gOiAyNTUpIDogMjU1O1xuICAgICAgICAgICAgY29uc3Qgbm9ybUJpYXMgPSBvcHRpb25zICE9PSB1bmRlZmluZWQgPyAoKChfYiA9IG9wdGlvbnMubm9ybSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmJpYXMpICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm5vcm0uYmlhcyA6IDApIDogMDtcbiAgICAgICAgICAgIGNvbnN0IG9mZnNldCA9IGhlaWdodCAqIHdpZHRoO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmhlaWdodCAhPT0gdW5kZWZpbmVkICYmIG9wdGlvbnMuaGVpZ2h0ICE9PSBoZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbWFnZSBvdXRwdXQgY29uZmlnIGhlaWdodCBkb2VzblxcJ3QgbWF0Y2ggdGVuc29yIGhlaWdodCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy53aWR0aCAhPT0gdW5kZWZpbmVkICYmIG9wdGlvbnMud2lkdGggIT09IHdpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW1hZ2Ugb3V0cHV0IGNvbmZpZyB3aWR0aCBkb2VzblxcJ3QgbWF0Y2ggdGVuc29yIHdpZHRoJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmZvcm1hdCAhPT0gdW5kZWZpbmVkICYmIChjaGFubmVscyA9PT0gNCAmJiBvcHRpb25zLmZvcm1hdCAhPT0gJ1JHQkEnKSB8fFxuICAgICAgICAgICAgICAgICAgICAoY2hhbm5lbHMgPT09IDMgJiYgKG9wdGlvbnMuZm9ybWF0ICE9PSAnUkdCJyAmJiBvcHRpb25zLmZvcm1hdCAhPT0gJ0JHUicpKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RlbnNvciBmb3JtYXQgZG9lc25cXCd0IG1hdGNoIGlucHV0IHRlbnNvciBkaW1zJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRGVmYXVsdCBwb2ludGVyIGFzc2lnbm1lbnRzXG4gICAgICAgICAgICBjb25zdCBzdGVwID0gNDtcbiAgICAgICAgICAgIGxldCBySW1hZ2VQb2ludGVyID0gMCwgZ0ltYWdlUG9pbnRlciA9IDEsIGJJbWFnZVBvaW50ZXIgPSAyLCBhSW1hZ2VQb2ludGVyID0gMztcbiAgICAgICAgICAgIGxldCByVGVuc29yUG9pbnRlciA9IDAsIGdUZW5zb3JQb2ludGVyID0gb2Zmc2V0LCBiVGVuc29yUG9pbnRlciA9IG9mZnNldCAqIDIsIGFUZW5zb3JQb2ludGVyID0gLTE7XG4gICAgICAgICAgICAvLyBVcGRhdGluZyB0aGUgcG9pbnRlciBhc3NpZ25tZW50cyBiYXNlZCBvbiB0aGUgaW5wdXQgaW1hZ2UgZm9ybWF0XG4gICAgICAgICAgICBpZiAoaW5wdXRmb3JtYXQgPT09ICdSR0JBJykge1xuICAgICAgICAgICAgICAgIHJUZW5zb3JQb2ludGVyID0gMDtcbiAgICAgICAgICAgICAgICBnVGVuc29yUG9pbnRlciA9IG9mZnNldDtcbiAgICAgICAgICAgICAgICBiVGVuc29yUG9pbnRlciA9IG9mZnNldCAqIDI7XG4gICAgICAgICAgICAgICAgYVRlbnNvclBvaW50ZXIgPSBvZmZzZXQgKiAzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaW5wdXRmb3JtYXQgPT09ICdSR0InKSB7XG4gICAgICAgICAgICAgICAgclRlbnNvclBvaW50ZXIgPSAwO1xuICAgICAgICAgICAgICAgIGdUZW5zb3JQb2ludGVyID0gb2Zmc2V0O1xuICAgICAgICAgICAgICAgIGJUZW5zb3JQb2ludGVyID0gb2Zmc2V0ICogMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlucHV0Zm9ybWF0ID09PSAnUkJHJykge1xuICAgICAgICAgICAgICAgIHJUZW5zb3JQb2ludGVyID0gMDtcbiAgICAgICAgICAgICAgICBiVGVuc29yUG9pbnRlciA9IG9mZnNldDtcbiAgICAgICAgICAgICAgICBnVGVuc29yUG9pbnRlciA9IG9mZnNldCAqIDI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbWFnZSA9IHBpeGVsczJEQ29udGV4dC5jcmVhdGVJbWFnZURhdGEod2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGhlaWdodCAqIHdpZHRoOyBySW1hZ2VQb2ludGVyICs9IHN0ZXAsIGdJbWFnZVBvaW50ZXIgKz0gc3RlcCwgYkltYWdlUG9pbnRlciArPSBzdGVwLCBhSW1hZ2VQb2ludGVyICs9IHN0ZXAsIGkrKykge1xuICAgICAgICAgICAgICAgIGltYWdlLmRhdGFbckltYWdlUG9pbnRlcl0gPSAodGhpcy5kYXRhW3JUZW5zb3JQb2ludGVyKytdIC0gbm9ybUJpYXMpICogbm9ybU1lYW47IC8vIFIgdmFsdWVcbiAgICAgICAgICAgICAgICBpbWFnZS5kYXRhW2dJbWFnZVBvaW50ZXJdID0gKHRoaXMuZGF0YVtnVGVuc29yUG9pbnRlcisrXSAtIG5vcm1CaWFzKSAqIG5vcm1NZWFuOyAvLyBHIHZhbHVlXG4gICAgICAgICAgICAgICAgaW1hZ2UuZGF0YVtiSW1hZ2VQb2ludGVyXSA9ICh0aGlzLmRhdGFbYlRlbnNvclBvaW50ZXIrK10gLSBub3JtQmlhcykgKiBub3JtTWVhbjsgLy8gQiB2YWx1ZVxuICAgICAgICAgICAgICAgIGltYWdlLmRhdGFbYUltYWdlUG9pbnRlcl0gPVxuICAgICAgICAgICAgICAgICAgICBhVGVuc29yUG9pbnRlciA9PT0gLTEgPyAyNTUgOiAodGhpcy5kYXRhW2FUZW5zb3JQb2ludGVyKytdIC0gbm9ybUJpYXMpICogbm9ybU1lYW47IC8vIEEgdmFsdWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2FuIG5vdCBhY2Nlc3MgaW1hZ2UgZGF0YScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbWFnZTtcbiAgICB9XG4gICAgLy8gI2VuZHJlZ2lvblxuICAgIC8vICNyZWdpb24gdGVuc29yIHV0aWxpdGllc1xuICAgIHJlc2hhcGUoZGltcykge1xuICAgICAgICByZXR1cm4gbmV3IFRlbnNvcih0aGlzLnR5cGUsIHRoaXMuZGF0YSwgZGltcyk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGVuc29yLWltcGwuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/onnxruntime-common/dist/lib/tensor-impl.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/onnxruntime-common/dist/lib/tensor.js":
/*!************************************************************!*\
  !*** ./node_modules/onnxruntime-common/dist/lib/tensor.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Tensor: function() { return /* binding */ Tensor; }\n/* harmony export */ });\n/* harmony import */ var _tensor_impl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tensor-impl */ \"(app-pages-browser)/./node_modules/onnxruntime-common/dist/lib/tensor-impl.js\");\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\n// eslint-disable-next-line @typescript-eslint/naming-convention\nconst Tensor = _tensor_impl__WEBPACK_IMPORTED_MODULE_0__.Tensor;\n//# sourceMappingURL=tensor.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9vbm54cnVudGltZS1jb21tb24vZGlzdC9saWIvdGVuc29yLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUNxRDtBQUNyRDtBQUNPLGVBQWUsZ0RBQVU7QUFDaEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL29ubnhydW50aW1lLWNvbW1vbi9kaXN0L2xpYi90ZW5zb3IuanM/OGY5ZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbmltcG9ydCB7IFRlbnNvciBhcyBUZW5zb3JJbXBsIH0gZnJvbSAnLi90ZW5zb3ItaW1wbCc7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXG5leHBvcnQgY29uc3QgVGVuc29yID0gVGVuc29ySW1wbDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRlbnNvci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/onnxruntime-common/dist/lib/tensor.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/onnxruntime-web/dist/ort-web.min.js":
/*!**********************************************************!*\
  !*** ./node_modules/onnxruntime-web/dist/ort-web.min.js ***!
  \**********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n/*!\n* ONNX Runtime Web v1.14.0\n* Copyright (c) Microsoft Corporation. All rights reserved.\n* Licensed under the MIT License.\n*/\n!function(t,e){if(true)module.exports=e(__webpack_require__(/*! onnxruntime-common */ \"(app-pages-browser)/./node_modules/onnxruntime-common/dist/lib/index.js\"));else { var r, n; }}(self,(__WEBPACK_EXTERNAL_MODULE__1670__=>(()=>{var __webpack_modules__={3474:(t,e,n)=>{var _scriptDir,r=(_scriptDir=(_scriptDir=\"undefined\"!=typeof document&&document.currentScript?document.currentScript.src:void 0)||\"/index.js\",function(t){function e(){return $.buffer!=C&&H($.buffer),F}function r(){return $.buffer!=C&&H($.buffer),N}function i(){return $.buffer!=C&&H($.buffer),L}function o(){return $.buffer!=C&&H($.buffer),R}function a(){return $.buffer!=C&&H($.buffer),j}var s,u,c;t=t||{},s||(s=void 0!==t?t:{}),s.ready=new Promise((function(t,e){u=t,c=e}));var l,p,f,d,h,g,b=Object.assign({},s),m=\"./this.program\",y=(t,e)=>{throw e},_=\"object\"==typeof window,v=\"function\"==typeof importScripts,w=\"object\"==typeof process&&\"object\"==typeof process.versions&&\"string\"==typeof process.versions.node,x=s.ENVIRONMENT_IS_PTHREAD||!1,T=\"\";function S(t){return s.locateFile?s.locateFile(t,T):T+t}if(w){let e;T=v?n(908).dirname(T)+\"/\":\"//\",g=()=>{h||(d=n(1384),h=n(908))},l=function(t,e){return g(),t=h.normalize(t),d.readFileSync(t,e?void 0:\"utf8\")},f=t=>((t=l(t,!0)).buffer||(t=new Uint8Array(t)),t),p=(t,e,n)=>{g(),t=h.normalize(t),d.readFile(t,(function(t,r){t?n(t):e(r.buffer)}))},1<process.argv.length&&(m=process.argv[1].replace(/\\\\/g,\"/\")),process.argv.slice(2),process.on(\"uncaughtException\",(function(t){if(!(t instanceof ut))throw t})),process.on(\"unhandledRejection\",(function(t){throw t})),y=(t,e)=>{if(J())throw process.exitCode=t,e;e instanceof ut||P(\"exiting due to exception: \"+e),process.exit(t)},s.inspect=function(){return\"[Emscripten Module object]\"};try{e=n(9925)}catch(t){throw console.error('The \"worker_threads\" module is not supported in this node.js build - perhaps a newer version is needed?'),t}n.g.Worker=e.Worker}else(_||v)&&(v?T=self.location.href:\"undefined\"!=typeof document&&document.currentScript&&(T=document.currentScript.src),_scriptDir&&(T=_scriptDir),T=0!==T.indexOf(\"blob:\")?T.substr(0,T.replace(/[?#].*/,\"\").lastIndexOf(\"/\")+1):\"\",w||(l=t=>{var e=new XMLHttpRequest;return e.open(\"GET\",t,!1),e.send(null),e.responseText},v&&(f=t=>{var e=new XMLHttpRequest;return e.open(\"GET\",t,!1),e.responseType=\"arraybuffer\",e.send(null),new Uint8Array(e.response)}),p=(t,e,n)=>{var r=new XMLHttpRequest;r.open(\"GET\",t,!0),r.responseType=\"arraybuffer\",r.onload=()=>{200==r.status||0==r.status&&r.response?e(r.response):n()},r.onerror=n,r.send(null)}));w&&\"undefined\"==typeof performance&&(n.g.performance=n(6953).performance);var O=console.log.bind(console),A=console.warn.bind(console);w&&(g(),O=t=>d.writeSync(1,t+\"\\n\"),A=t=>d.writeSync(2,t+\"\\n\"));var E,I=s.print||O,P=s.printErr||A;Object.assign(s,b),b=null,s.thisProgram&&(m=s.thisProgram),s.quit&&(y=s.quit),s.wasmBinary&&(E=s.wasmBinary);var D=s.noExitRuntime||!1;\"object\"!=typeof WebAssembly&&it(\"no native wasm support detected\");var $,k,C,F,N,L,R,j,M=!1,U=\"undefined\"!=typeof TextDecoder?new TextDecoder(\"utf8\"):void 0;function V(t,e,n){var r=(e>>>=0)+n;for(n=e;t[n]&&!(n>=r);)++n;if(16<n-e&&t.buffer&&U)return U.decode(t.buffer instanceof SharedArrayBuffer?t.slice(e,n):t.subarray(e,n));for(r=\"\";e<n;){var i=t[e++];if(128&i){var o=63&t[e++];if(192==(224&i))r+=String.fromCharCode((31&i)<<6|o);else{var a=63&t[e++];65536>(i=224==(240&i)?(15&i)<<12|o<<6|a:(7&i)<<18|o<<12|a<<6|63&t[e++])?r+=String.fromCharCode(i):(i-=65536,r+=String.fromCharCode(55296|i>>10,56320|1023&i))}}else r+=String.fromCharCode(i)}return r}function B(t,e){return(t>>>=0)?V(r(),t,e):\"\"}function z(t,e,n,r){if(!(0<r))return 0;var i=n>>>=0;r=n+r-1;for(var o=0;o<t.length;++o){var a=t.charCodeAt(o);if(55296<=a&&57343>=a&&(a=65536+((1023&a)<<10)|1023&t.charCodeAt(++o)),127>=a){if(n>=r)break;e[n++>>>0]=a}else{if(2047>=a){if(n+1>=r)break;e[n++>>>0]=192|a>>6}else{if(65535>=a){if(n+2>=r)break;e[n++>>>0]=224|a>>12}else{if(n+3>=r)break;e[n++>>>0]=240|a>>18,e[n++>>>0]=128|a>>12&63}e[n++>>>0]=128|a>>6&63}e[n++>>>0]=128|63&a}}return e[n>>>0]=0,n-i}function G(t){for(var e=0,n=0;n<t.length;++n){var r=t.charCodeAt(n);127>=r?e++:2047>=r?e+=2:55296<=r&&57343>=r?(e+=4,++n):e+=3}return e}function H(t){C=t,s.HEAP8=F=new Int8Array(t),s.HEAP16=new Int16Array(t),s.HEAP32=L=new Int32Array(t),s.HEAPU8=N=new Uint8Array(t),s.HEAPU16=new Uint16Array(t),s.HEAPU32=R=new Uint32Array(t),s.HEAPF32=new Float32Array(t),s.HEAPF64=j=new Float64Array(t)}x&&(C=s.buffer);var W=s.INITIAL_MEMORY||16777216;if(x)$=s.wasmMemory,C=s.buffer;else if(s.wasmMemory)$=s.wasmMemory;else if(!(($=new WebAssembly.Memory({initial:W/65536,maximum:65536,shared:!0})).buffer instanceof SharedArrayBuffer))throw P(\"requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag\"),w&&console.log(\"(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and also use a recent version)\"),Error(\"bad memory\");$&&(C=$.buffer),W=C.byteLength,H(C);var q,X=[],Y=[],K=[],Z=[];function J(){return D||!1}function Q(){var t=s.preRun.shift();X.unshift(t)}var tt,et=0,nt=null,rt=null;function it(t){throw x?postMessage({cmd:\"onAbort\",arg:t}):s.onAbort&&s.onAbort(t),P(t=\"Aborted(\"+t+\")\"),M=!0,t=new WebAssembly.RuntimeError(t+\". Build with -sASSERTIONS for more info.\"),c(t),t}function ot(){return tt.startsWith(\"data:application/octet-stream;base64,\")}function at(){var t=tt;try{if(t==tt&&E)return new Uint8Array(E);if(f)return f(t);throw\"both async and sync fetching of the wasm failed\"}catch(t){it(t)}}tt=\"ort-wasm-threaded.wasm\",ot()||(tt=S(tt));var st={};function ut(t){this.name=\"ExitStatus\",this.message=\"Program terminated with exit(\"+t+\")\",this.status=t}function ct(t){(t=dt.Vb[t])||it(),dt.mc(t)}function lt(t){var e=dt.Cc();if(!e)return 6;dt.ac.push(e),dt.Vb[t.Ub]=e,e.Ub=t.Ub;var n={cmd:\"run\",start_routine:t.Ic,arg:t.zc,pthread_ptr:t.Ub};return e.$b=()=>{n.time=performance.now(),e.postMessage(n,t.Nc)},e.loaded&&(e.$b(),delete e.$b),0}function pt(t){if(x)return qt(1,1,t);J()||(dt.oc(),s.onExit&&s.onExit(t),M=!0),y(t,new ut(t))}function ft(t,e){if(!e&&x)throw bt(t),\"unwind\";J()||x||(me(),ht(K),be(0),re[1].length&&ie(1,10),re[2].length&&ie(2,10),dt.oc()),pt(t)}var dt={Yb:[],ac:[],qc:[],Vb:{},fc:function(){x&&dt.Ec()},Pc:function(){},Ec:function(){dt.receiveObjectTransfer=dt.Gc,dt.threadInitTLS=dt.pc,dt.setExitStatus=dt.nc,D=!1},nc:function(){},oc:function(){for(var t of Object.values(dt.Vb))dt.mc(t);for(t of dt.Yb)t.terminate();dt.Yb=[]},mc:function(t){var e=t.Ub;delete dt.Vb[e],dt.Yb.push(t),dt.ac.splice(dt.ac.indexOf(t),1),t.Ub=0,xe(e)},Gc:function(){},pc:function(){dt.qc.forEach((t=>t()))},Fc:function(t,e){t.onmessage=n=>{var r=(n=n.data).cmd;if(t.Ub&&(dt.Bc=t.Ub),n.targetThread&&n.targetThread!=de()){var i=dt.Vb[n.Qc];i?i.postMessage(n,n.transferList):P('Internal error! Worker sent a message \"'+r+'\" to target pthread '+n.targetThread+\", but that thread no longer exists!\")}else\"processProxyingQueue\"===r?Vt(n.queue):\"spawnThread\"===r?lt(n):\"cleanupThread\"===r?ct(n.thread):\"killThread\"===r?(n=n.thread,r=dt.Vb[n],delete dt.Vb[n],r.terminate(),xe(n),dt.ac.splice(dt.ac.indexOf(r),1),r.Ub=0):\"cancelThread\"===r?dt.Vb[n.thread].postMessage({cmd:\"cancel\"}):\"loaded\"===r?(t.loaded=!0,e&&e(t),t.$b&&(t.$b(),delete t.$b)):\"print\"===r?I(\"Thread \"+n.threadId+\": \"+n.text):\"printErr\"===r?P(\"Thread \"+n.threadId+\": \"+n.text):\"alert\"===r?alert(\"Thread \"+n.threadId+\": \"+n.text):\"setimmediate\"===n.target?t.postMessage(n):\"onAbort\"===r?s.onAbort&&s.onAbort(n.arg):r&&P(\"worker sent an unknown command \"+r);dt.Bc=void 0},t.onerror=t=>{throw P(\"worker sent an error! \"+t.filename+\":\"+t.lineno+\": \"+t.message),t},w&&(t.on(\"message\",(function(e){t.onmessage({data:e})})),t.on(\"error\",(function(e){t.onerror(e)})),t.on(\"detachedExit\",(function(){}))),t.postMessage({cmd:\"load\",urlOrBlob:s.mainScriptUrlOrBlob||_scriptDir,wasmMemory:$,wasmModule:k})},yc:function(){var t=S(\"ort-wasm-threaded.worker.js\");dt.Yb.push(new Worker(t))},Cc:function(){return 0==dt.Yb.length&&(dt.yc(),dt.Fc(dt.Yb[0])),dt.Yb.pop()}};function ht(t){for(;0<t.length;)t.shift()(s)}function gt(t){var e=Ae();return t=t(),Ee(e),t}function bt(t){if(x)return qt(2,0,t);try{ft(t)}catch(t){t instanceof ut||\"unwind\"==t||y(1,t)}}s.PThread=dt,s.establishStackSpace=function(){var t=de(),e=i()[t+44>>2>>>0];t=i()[t+48>>2>>>0],Oe(e,e-t),Ee(e)};var mt=[];function yt(t){var e=mt[t];return e||(t>=mt.length&&(mt.length=t+1),mt[t]=e=q.get(t)),e}s.invokeEntryPoint=function(t,e){t=yt(t)(e),J()?dt.nc(t):Te(t)};var _t,vt,wt=[],xt=0,Tt=0;function St(t){this.Zb=t,this.Sb=t-24,this.xc=function(t){o()[this.Sb+4>>2>>>0]=t},this.bc=function(){return o()[this.Sb+4>>2>>>0]},this.wc=function(t){o()[this.Sb+8>>2>>>0]=t},this.Dc=function(){return o()[this.Sb+8>>2>>>0]},this.rc=function(){i()[this.Sb>>2>>>0]=0},this.hc=function(t){t=t?1:0,e()[this.Sb+12>>0>>>0]=t},this.uc=function(){return 0!=e()[this.Sb+12>>0>>>0]},this.ic=function(t){t=t?1:0,e()[this.Sb+13>>0>>>0]=t},this.kc=function(){return 0!=e()[this.Sb+13>>0>>>0]},this.fc=function(t,e){this.cc(0),this.xc(t),this.wc(e),this.rc(),this.hc(!1),this.ic(!1)},this.sc=function(){Atomics.add(i(),this.Sb>>2,1)},this.Hc=function(){return 1===Atomics.sub(i(),this.Sb>>2,1)},this.cc=function(t){o()[this.Sb+16>>2>>>0]=t},this.tc=function(){return o()[this.Sb+16>>2>>>0]},this.vc=function(){if(De(this.bc()))return o()[this.Zb>>2>>>0];var t=this.tc();return 0!==t?t:this.Zb}}function Ot(t){return ge(new St(t).Sb)}function At(t,e,n,r){return x?qt(3,1,t,e,n,r):Et(t,e,n,r)}function Et(t,e,n,r){if(\"undefined\"==typeof SharedArrayBuffer)return P(\"Current environment does not support SharedArrayBuffer, pthreads are not available!\"),6;var i=[];return x&&0===i.length?At(t,e,n,r):(t={Ic:n,Ub:t,zc:r,Nc:i},x?(t.Oc=\"spawnThread\",postMessage(t,i),0):lt(t))}function It(t,e,n){return x?qt(4,1,t,e,n):0}function Pt(t,e){if(x)return qt(5,1,t,e)}function Dt(t,e){if(x)return qt(6,1,t,e)}function $t(t,e,n){if(x)return qt(7,1,t,e,n)}function kt(t,e,n){return x?qt(8,1,t,e,n):0}function Ct(t,e){if(x)return qt(9,1,t,e)}function Ft(t,e,n){if(x)return qt(10,1,t,e,n)}function Nt(t,e,n,r){if(x)return qt(11,1,t,e,n,r)}function Lt(t,e,n,r){if(x)return qt(12,1,t,e,n,r)}function Rt(t,e,n,r){if(x)return qt(13,1,t,e,n,r)}function jt(t){if(x)return qt(14,1,t)}function Mt(t,e){if(x)return qt(15,1,t,e)}function Ut(t,e,n){if(x)return qt(16,1,t,e,n)}function Vt(t){Atomics.store(i(),t>>2,1),de()&&we(t),Atomics.compareExchange(i(),t>>2,1,0)}function Bt(t){return o()[t>>>2]+4294967296*i()[t+4>>>2]}function zt(t,e,n,r,i,o){return x?qt(17,1,t,e,n,r,i,o):-52}function Gt(t,e,n,r,i,o){if(x)return qt(18,1,t,e,n,r,i,o)}function Ht(t){var n=G(t)+1,r=he(n);return r&&z(t,e(),r,n),r}function Wt(t,e,n){function r(t){return(t=t.toTimeString().match(/\\(([A-Za-z ]+)\\)$/))?t[1]:\"GMT\"}if(x)return qt(19,1,t,e,n);var a=(new Date).getFullYear(),s=new Date(a,0,1),u=new Date(a,6,1);a=s.getTimezoneOffset();var c=u.getTimezoneOffset(),l=Math.max(a,c);i()[t>>2>>>0]=60*l,i()[e>>2>>>0]=Number(a!=c),t=r(s),e=r(u),t=Ht(t),e=Ht(e),c<a?(o()[n>>2>>>0]=t,o()[n+4>>2>>>0]=e):(o()[n>>2>>>0]=e,o()[n+4>>2>>>0]=t)}function qt(t,e){var n=arguments.length-2,r=arguments;return gt((()=>{for(var i=Ie(8*n),o=i>>3,s=0;s<n;s++){var u=r[2+s];a()[o+s>>>0]=u}return ve(t,n,i,e)}))}s.executeNotifiedProxyingQueue=Vt,vt=w?()=>{var t=process.hrtime();return 1e3*t[0]+t[1]/1e6}:x?()=>performance.now()-s.__performance_now_clock_drift:()=>performance.now();var Xt,Yt=[],Kt={};function Zt(){if(!Xt){var t,e={USER:\"web_user\",LOGNAME:\"web_user\",PATH:\"/\",PWD:\"/\",HOME:\"/home/web_user\",LANG:(\"object\"==typeof navigator&&navigator.languages&&navigator.languages[0]||\"C\").replace(\"-\",\"_\")+\".UTF-8\",_:m||\"./this.program\"};for(t in Kt)void 0===Kt[t]?delete e[t]:e[t]=Kt[t];var n=[];for(t in e)n.push(t+\"=\"+e[t]);Xt=n}return Xt}function Jt(t,n){if(x)return qt(20,1,t,n);var r=0;return Zt().forEach((function(i,a){var s=n+r;for(a=o()[t+4*a>>2>>>0]=s,s=0;s<i.length;++s)e()[a++>>0>>>0]=i.charCodeAt(s);e()[a>>0>>>0]=0,r+=i.length+1})),0}function Qt(t,e){if(x)return qt(21,1,t,e);var n=Zt();o()[t>>2>>>0]=n.length;var r=0;return n.forEach((function(t){r+=t.length+1})),o()[e>>2>>>0]=r,0}function te(t){return x?qt(22,1,t):52}function ee(t,e,n,r){return x?qt(23,1,t,e,n,r):52}function ne(t,e,n,r,i){return x?qt(24,1,t,e,n,r,i):70}var re=[null,[],[]];function ie(t,e){var n=re[t];0===e||10===e?((1===t?I:P)(V(n,0)),n.length=0):n.push(e)}function oe(t,e,n,i){if(x)return qt(25,1,t,e,n,i);for(var a=0,s=0;s<n;s++){var u=o()[e>>2>>>0],c=o()[e+4>>2>>>0];e+=8;for(var l=0;l<c;l++)ie(t,r()[u+l>>>0]);a+=c}return o()[i>>2>>>0]=a,0}var ae=0;function se(t){return 0==t%4&&(0!=t%100||0==t%400)}var ue=[31,29,31,30,31,30,31,31,30,31,30,31],ce=[31,28,31,30,31,30,31,31,30,31,30,31];function le(t,n,r,o){function a(t,e,n){for(t=\"number\"==typeof t?t.toString():t||\"\";t.length<e;)t=n[0]+t;return t}function s(t,e){return a(t,e,\"0\")}function u(t,e){function n(t){return 0>t?-1:0<t?1:0}var r;return 0===(r=n(t.getFullYear()-e.getFullYear()))&&0===(r=n(t.getMonth()-e.getMonth()))&&(r=n(t.getDate()-e.getDate())),r}function c(t){switch(t.getDay()){case 0:return new Date(t.getFullYear()-1,11,29);case 1:return t;case 2:return new Date(t.getFullYear(),0,3);case 3:return new Date(t.getFullYear(),0,2);case 4:return new Date(t.getFullYear(),0,1);case 5:return new Date(t.getFullYear()-1,11,31);case 6:return new Date(t.getFullYear()-1,11,30)}}function l(t){var e=t.Wb;for(t=new Date(new Date(t.Xb+1900,0,1).getTime());0<e;){var n=t.getMonth(),r=(se(t.getFullYear())?ue:ce)[n];if(!(e>r-t.getDate())){t.setDate(t.getDate()+e);break}e-=r-t.getDate()+1,t.setDate(1),11>n?t.setMonth(n+1):(t.setMonth(0),t.setFullYear(t.getFullYear()+1))}return n=new Date(t.getFullYear()+1,0,4),e=c(new Date(t.getFullYear(),0,4)),n=c(n),0>=u(e,t)?0>=u(n,t)?t.getFullYear()+1:t.getFullYear():t.getFullYear()-1}var p=i()[o+40>>2>>>0];for(var f in o={Lc:i()[o>>2>>>0],Kc:i()[o+4>>2>>>0],dc:i()[o+8>>2>>>0],jc:i()[o+12>>2>>>0],ec:i()[o+16>>2>>>0],Xb:i()[o+20>>2>>>0],Tb:i()[o+24>>2>>>0],Wb:i()[o+28>>2>>>0],Rc:i()[o+32>>2>>>0],Jc:i()[o+36>>2>>>0],Mc:p?B(p):\"\"},r=B(r),p={\"%c\":\"%a %b %d %H:%M:%S %Y\",\"%D\":\"%m/%d/%y\",\"%F\":\"%Y-%m-%d\",\"%h\":\"%b\",\"%r\":\"%I:%M:%S %p\",\"%R\":\"%H:%M\",\"%T\":\"%H:%M:%S\",\"%x\":\"%m/%d/%y\",\"%X\":\"%H:%M:%S\",\"%Ec\":\"%c\",\"%EC\":\"%C\",\"%Ex\":\"%m/%d/%y\",\"%EX\":\"%H:%M:%S\",\"%Ey\":\"%y\",\"%EY\":\"%Y\",\"%Od\":\"%d\",\"%Oe\":\"%e\",\"%OH\":\"%H\",\"%OI\":\"%I\",\"%Om\":\"%m\",\"%OM\":\"%M\",\"%OS\":\"%S\",\"%Ou\":\"%u\",\"%OU\":\"%U\",\"%OV\":\"%V\",\"%Ow\":\"%w\",\"%OW\":\"%W\",\"%Oy\":\"%y\"})r=r.replace(new RegExp(f,\"g\"),p[f]);var d=\"Sunday Monday Tuesday Wednesday Thursday Friday Saturday\".split(\" \"),h=\"January February March April May June July August September October November December\".split(\" \");for(f in p={\"%a\":function(t){return d[t.Tb].substring(0,3)},\"%A\":function(t){return d[t.Tb]},\"%b\":function(t){return h[t.ec].substring(0,3)},\"%B\":function(t){return h[t.ec]},\"%C\":function(t){return s((t.Xb+1900)/100|0,2)},\"%d\":function(t){return s(t.jc,2)},\"%e\":function(t){return a(t.jc,2,\" \")},\"%g\":function(t){return l(t).toString().substring(2)},\"%G\":function(t){return l(t)},\"%H\":function(t){return s(t.dc,2)},\"%I\":function(t){return 0==(t=t.dc)?t=12:12<t&&(t-=12),s(t,2)},\"%j\":function(t){for(var e=0,n=0;n<=t.ec-1;e+=(se(t.Xb+1900)?ue:ce)[n++]);return s(t.jc+e,3)},\"%m\":function(t){return s(t.ec+1,2)},\"%M\":function(t){return s(t.Kc,2)},\"%n\":function(){return\"\\n\"},\"%p\":function(t){return 0<=t.dc&&12>t.dc?\"AM\":\"PM\"},\"%S\":function(t){return s(t.Lc,2)},\"%t\":function(){return\"\\t\"},\"%u\":function(t){return t.Tb||7},\"%U\":function(t){return s(Math.floor((t.Wb+7-t.Tb)/7),2)},\"%V\":function(t){var e=Math.floor((t.Wb+7-(t.Tb+6)%7)/7);if(2>=(t.Tb+371-t.Wb-2)%7&&e++,e)53==e&&(4==(n=(t.Tb+371-t.Wb)%7)||3==n&&se(t.Xb)||(e=1));else{e=52;var n=(t.Tb+7-t.Wb-1)%7;(4==n||5==n&&se(t.Xb%400-1))&&e++}return s(e,2)},\"%w\":function(t){return t.Tb},\"%W\":function(t){return s(Math.floor((t.Wb+7-(t.Tb+6)%7)/7),2)},\"%y\":function(t){return(t.Xb+1900).toString().substring(2)},\"%Y\":function(t){return t.Xb+1900},\"%z\":function(t){var e=0<=(t=t.Jc);return t=Math.abs(t)/60,(e?\"+\":\"-\")+String(\"0000\"+(t/60*100+t%60)).slice(-4)},\"%Z\":function(t){return t.Mc},\"%%\":function(){return\"%\"}},r=r.replace(/%%/g,\"\\0\\0\"),p)r.includes(f)&&(r=r.replace(new RegExp(f,\"g\"),p[f](o)));return f=function(t){var e=Array(G(t)+1);return z(t,e,0,e.length),e}(r=r.replace(/\\0\\0/g,\"%\")),f.length>n?0:(function(t,n){e().set(t,n>>>0)}(f,t),f.length-1)}dt.fc();var pe=[null,pt,bt,At,It,Pt,Dt,$t,kt,Ct,Ft,Nt,Lt,Rt,jt,Mt,Ut,zt,Gt,Wt,Jt,Qt,te,ee,ne,oe],fe={b:function(t){return he(t+24)+24},n:function(t){return(t=new St(t)).uc()||(t.hc(!0),xt--),t.ic(!1),wt.push(t),t.sc(),t.vc()},ma:function(t){throw P(\"Unexpected exception thrown, this is not properly supported - aborting\"),M=!0,t},x:function(){Se(0);var t=wt.pop();if(t.Hc()&&!t.kc()){var e=t.Dc();e&&yt(e)(t.Zb),Ot(t.Zb)}Tt=0},e:function(){var t=Tt;if(!t)return ae=0;var e=new St(t);e.cc(t);var n=e.bc();if(!n)return ae=0,t;for(var r=Array.prototype.slice.call(arguments),i=0;i<r.length;i++){var o=r[i];if(0===o||o===n)break;if(Pe(o,n,e.Sb+16))return ae=o,t}return ae=n,t},l:function(){var t=Tt;if(!t)return ae=0;var e=new St(t);e.cc(t);var n=e.bc();if(!n)return ae=0,t;for(var r=Array.prototype.slice.call(arguments),i=0;i<r.length;i++){var o=r[i];if(0===o||o===n)break;if(Pe(o,n,e.Sb+16))return ae=o,t}return ae=n,t},h:function(){var t=Tt;if(!t)return ae=0;var e=new St(t);e.cc(t);var n=e.bc();if(!n)return ae=0,t;for(var r=Array.prototype.slice.call(arguments),i=0;i<r.length;i++){var o=r[i];if(0===o||o===n)break;if(Pe(o,n,e.Sb+16))return ae=o,t}return ae=n,t},t:Ot,M:function(){var t=wt.pop();t||it(\"no exception to throw\");var e=t.Zb;throw t.kc()||(wt.push(t),t.ic(!0),t.hc(!1),xt++),Tt=e,e},c:function(t,e,n){throw new St(t).fc(e,n),Tt=t,xt++,t},pa:function(){return xt},Fa:function(t){ye(t,!v,1,!_),dt.pc()},T:function(t){x?postMessage({cmd:\"cleanupThread\",thread:t}):ct(t)},xa:Et,j:function(t){throw Tt||(Tt=t),t},H:It,Ma:Pt,ua:Dt,wa:$t,oa:kt,Ka:Ct,Ca:Ft,Ja:Nt,V:Lt,va:Rt,sa:jt,La:Mt,ta:Ut,Ta:function(){},X:function(){it(\"To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking\")},Ua:function(){it(\"To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking\")},W:function(){return Date.now()},ya:function(){return 2097152},Oa:function(){return!0},za:function(t,e,n,r){if(t==e)setTimeout((()=>Vt(r)));else if(x)postMessage({targetThread:t,cmd:\"processProxyingQueue\",queue:r});else{if(!(t=dt.Vb[t]))return;t.postMessage({cmd:\"processProxyingQueue\",queue:r})}return 1},Ea:function(){return-1},Pa:function(t,e){t=new Date(1e3*Bt(t)),i()[e>>2>>>0]=t.getUTCSeconds(),i()[e+4>>2>>>0]=t.getUTCMinutes(),i()[e+8>>2>>>0]=t.getUTCHours(),i()[e+12>>2>>>0]=t.getUTCDate(),i()[e+16>>2>>>0]=t.getUTCMonth(),i()[e+20>>2>>>0]=t.getUTCFullYear()-1900,i()[e+24>>2>>>0]=t.getUTCDay(),t=(t.getTime()-Date.UTC(t.getUTCFullYear(),0,1,0,0,0,0))/864e5|0,i()[e+28>>2>>>0]=t},Qa:function(t,e){t=new Date(1e3*Bt(t)),i()[e>>2>>>0]=t.getSeconds(),i()[e+4>>2>>>0]=t.getMinutes(),i()[e+8>>2>>>0]=t.getHours(),i()[e+12>>2>>>0]=t.getDate(),i()[e+16>>2>>>0]=t.getMonth(),i()[e+20>>2>>>0]=t.getFullYear()-1900,i()[e+24>>2>>>0]=t.getDay();var n=new Date(t.getFullYear(),0,1),r=(t.getTime()-n.getTime())/864e5|0;i()[e+28>>2>>>0]=r,i()[e+36>>2>>>0]=-60*t.getTimezoneOffset(),r=new Date(t.getFullYear(),6,1).getTimezoneOffset(),t=0|(r!=(n=n.getTimezoneOffset())&&t.getTimezoneOffset()==Math.min(n,r)),i()[e+32>>2>>>0]=t},Ra:function(t){var e=new Date(i()[t+20>>2>>>0]+1900,i()[t+16>>2>>>0],i()[t+12>>2>>>0],i()[t+8>>2>>>0],i()[t+4>>2>>>0],i()[t>>2>>>0],0),n=i()[t+32>>2>>>0],r=e.getTimezoneOffset(),o=new Date(e.getFullYear(),0,1),a=new Date(e.getFullYear(),6,1).getTimezoneOffset(),s=o.getTimezoneOffset(),u=Math.min(s,a);return 0>n?i()[t+32>>2>>>0]=Number(a!=s&&u==r):0<n!=(u==r)&&(a=Math.max(s,a),e.setTime(e.getTime()+6e4*((0<n?u:a)-r))),i()[t+24>>2>>>0]=e.getDay(),n=(e.getTime()-o.getTime())/864e5|0,i()[t+28>>2>>>0]=n,i()[t>>2>>>0]=e.getSeconds(),i()[t+4>>2>>>0]=e.getMinutes(),i()[t+8>>2>>>0]=e.getHours(),i()[t+12>>2>>>0]=e.getDate(),i()[t+16>>2>>>0]=e.getMonth(),e.getTime()/1e3|0},Aa:zt,Ba:Gt,Sa:function t(e,n,r){t.Ac||(t.Ac=!0,Wt(e,n,r))},y:function(){it(\"\")},U:function(){if(!w&&!v){var t=\"Blocking on the main thread is very dangerous, see https://emscripten.org/docs/porting/pthreads.html#blocking-on-the-main-browser-thread\";_t||(_t={}),_t[t]||(_t[t]=1,w&&(t=\"warning: \"+t),P(t))}},ra:function(){return 4294901760},B:vt,Ia:function(t,e,n){r().copyWithin(t>>>0,e>>>0,e+n>>>0)},F:function(){return w?n(3993).cpus().length:navigator.hardwareConcurrency},Da:function(t,e,n){Yt.length=e,n>>=3;for(var r=0;r<e;r++)Yt[r]=a()[n+r>>>0];return(0>t?st[-t-1]:pe[t]).apply(null,Yt)},qa:function(t){var e=r().length;if((t>>>=0)<=e||4294901760<t)return!1;for(var n=1;4>=n;n*=2){var i=e*(1+.2/n);i=Math.min(i,t+100663296);var o=Math;i=Math.max(t,i),o=o.min.call(o,4294901760,i+(65536-i%65536)%65536);t:{try{$.grow(o-C.byteLength+65535>>>16),H($.buffer);var a=1;break t}catch(t){}a=void 0}if(a)return!0}return!1},Na:function(){throw\"unwind\"},Ga:Jt,Ha:Qt,J:ft,I:te,S:ee,ga:ne,R:oe,d:function(){return ae},na:function t(r,i){t.lc||(t.lc=function(){if(\"object\"==typeof crypto&&\"function\"==typeof crypto.getRandomValues){var t=new Uint8Array(1);return()=>(crypto.getRandomValues(t),t[0])}if(w)try{var e=n(Object(function(){var t=new Error(\"Cannot find module 'crypto'\");throw t.code=\"MODULE_NOT_FOUND\",t}()));return()=>e.randomBytes(1)[0]}catch(t){}return()=>it(\"randomDevice\")}());for(var o=0;o<i;o++)e()[r+o>>0>>>0]=t.lc();return 0},ia:function(t,e,n){var r=Ae();try{return yt(t)(e,n)}catch(t){if(Ee(r),t!==t+0)throw t;Se(1,0)}},ja:function(t,e,n){var r=Ae();try{return yt(t)(e,n)}catch(t){if(Ee(r),t!==t+0)throw t;Se(1,0)}},K:function(t){var e=Ae();try{return yt(t)()}catch(t){if(Ee(e),t!==t+0)throw t;Se(1,0)}},f:function(t,e){var n=Ae();try{return yt(t)(e)}catch(t){if(Ee(n),t!==t+0)throw t;Se(1,0)}},P:function(t,e,n){var r=Ae();try{return yt(t)(e,n)}catch(t){if(Ee(r),t!==t+0)throw t;Se(1,0)}},Q:function(t,e,n){var r=Ae();try{return yt(t)(e,n)}catch(t){if(Ee(r),t!==t+0)throw t;Se(1,0)}},k:function(t,e,n){var r=Ae();try{return yt(t)(e,n)}catch(t){if(Ee(r),t!==t+0)throw t;Se(1,0)}},p:function(t,e,n,r){var i=Ae();try{return yt(t)(e,n,r)}catch(t){if(Ee(i),t!==t+0)throw t;Se(1,0)}},q:function(t,e,n,r,i){var o=Ae();try{return yt(t)(e,n,r,i)}catch(t){if(Ee(o),t!==t+0)throw t;Se(1,0)}},N:function(t,e,n,r,i,o){var a=Ae();try{return yt(t)(e,n,r,i,o)}catch(t){if(Ee(a),t!==t+0)throw t;Se(1,0)}},s:function(t,e,n,r,i,o){var a=Ae();try{return yt(t)(e,n,r,i,o)}catch(t){if(Ee(a),t!==t+0)throw t;Se(1,0)}},w:function(t,e,n,r,i,o,a){var s=Ae();try{return yt(t)(e,n,r,i,o,a)}catch(t){if(Ee(s),t!==t+0)throw t;Se(1,0)}},L:function(t,e,n,r,i,o,a,s){var u=Ae();try{return yt(t)(e,n,r,i,o,a,s)}catch(t){if(Ee(u),t!==t+0)throw t;Se(1,0)}},E:function(t,e,n,r,i,o,a,s,u,c,l,p){var f=Ae();try{return yt(t)(e,n,r,i,o,a,s,u,c,l,p)}catch(t){if(Ee(f),t!==t+0)throw t;Se(1,0)}},aa:function(t,e,n,r,i,o,a,s){var u=Ae();try{return Me(t,e,n,r,i,o,a,s)}catch(t){if(Ee(u),t!==t+0)throw t;Se(1,0)}},_:function(t,e,n,r,i,o,a){var s=Ae();try{return ke(t,e,n,r,i,o,a)}catch(t){if(Ee(s),t!==t+0)throw t;Se(1,0)}},Z:function(t,e,n,r,i){var o=Ae();try{return Ue(t,e,n,r,i)}catch(t){if(Ee(o),t!==t+0)throw t;Se(1,0)}},ca:function(t,e,n,r){var i=Ae();try{return Re(t,e,n,r)}catch(t){if(Ee(i),t!==t+0)throw t;Se(1,0)}},$:function(t){var e=Ae();try{return $e(t)}catch(t){if(Ee(e),t!==t+0)throw t;Se(1,0)}},ba:function(t,e){var n=Ae();try{return je(t,e)}catch(t){if(Ee(n),t!==t+0)throw t;Se(1,0)}},Y:function(t,e,n){var r=Ae();try{return Ce(t,e,n)}catch(t){if(Ee(r),t!==t+0)throw t;Se(1,0)}},g:function(t){var e=Ae();try{yt(t)()}catch(t){if(Ee(e),t!==t+0)throw t;Se(1,0)}},r:function(t,e){var n=Ae();try{yt(t)(e)}catch(t){if(Ee(n),t!==t+0)throw t;Se(1,0)}},i:function(t,e,n){var r=Ae();try{yt(t)(e,n)}catch(t){if(Ee(r),t!==t+0)throw t;Se(1,0)}},ha:function(t,e,n,r){var i=Ae();try{yt(t)(e,n,r)}catch(t){if(Ee(i),t!==t+0)throw t;Se(1,0)}},m:function(t,e,n,r){var i=Ae();try{yt(t)(e,n,r)}catch(t){if(Ee(i),t!==t+0)throw t;Se(1,0)}},v:function(t,e,n,r,i){var o=Ae();try{yt(t)(e,n,r,i)}catch(t){if(Ee(o),t!==t+0)throw t;Se(1,0)}},u:function(t,e,n,r,i,o){var a=Ae();try{yt(t)(e,n,r,i,o)}catch(t){if(Ee(a),t!==t+0)throw t;Se(1,0)}},O:function(t,e,n,r,i,o,a){var s=Ae();try{yt(t)(e,n,r,i,o,a)}catch(t){if(Ee(s),t!==t+0)throw t;Se(1,0)}},A:function(t,e,n,r,i,o,a,s){var u=Ae();try{yt(t)(e,n,r,i,o,a,s)}catch(t){if(Ee(u),t!==t+0)throw t;Se(1,0)}},ka:function(t,e,n,r,i,o,a,s,u){var c=Ae();try{yt(t)(e,n,r,i,o,a,s,u)}catch(t){if(Ee(c),t!==t+0)throw t;Se(1,0)}},C:function(t,e,n,r,i,o,a,s,u,c,l){var p=Ae();try{yt(t)(e,n,r,i,o,a,s,u,c,l)}catch(t){if(Ee(p),t!==t+0)throw t;Se(1,0)}},D:function(t,e,n,r,i,o,a,s,u,c,l,p,f,d,h,g){var b=Ae();try{yt(t)(e,n,r,i,o,a,s,u,c,l,p,f,d,h,g)}catch(t){if(Ee(b),t!==t+0)throw t;Se(1,0)}},fa:function(t,e,n,r,i,o,a,s){var u=Ae();try{Fe(t,e,n,r,i,o,a,s)}catch(t){if(Ee(u),t!==t+0)throw t;Se(1,0)}},da:function(t,e,n,r,i,o,a,s,u,c,l,p){var f=Ae();try{Le(t,e,n,r,i,o,a,s,u,c,l,p)}catch(t){if(Ee(f),t!==t+0)throw t;Se(1,0)}},ea:function(t,e,n,r,i,o){var a=Ae();try{Ne(t,e,n,r,i,o)}catch(t){if(Ee(a),t!==t+0)throw t;Se(1,0)}},o:function(t){return t},a:$||s.wasmMemory,G:function(t){ae=t},la:le,z:function(t,e,n,r){return le(t,e,n,r)}};!function(){function t(t,e){s.asm=t.exports,dt.qc.push(s.asm.sb),q=s.asm.ub,Y.unshift(s.asm.Va),k=e,x||(et--,s.monitorRunDependencies&&s.monitorRunDependencies(et),0==et&&(null!==nt&&(clearInterval(nt),nt=null),rt&&(t=rt,rt=null,t())))}function e(e){t(e.instance,e.module)}function n(t){return function(){if(!E&&(_||v)){if(\"function\"==typeof fetch&&!tt.startsWith(\"file://\"))return fetch(tt,{credentials:\"same-origin\"}).then((function(t){if(!t.ok)throw\"failed to load wasm binary file at '\"+tt+\"'\";return t.arrayBuffer()})).catch((function(){return at()}));if(p)return new Promise((function(t,e){p(tt,(function(e){t(new Uint8Array(e))}),e)}))}return Promise.resolve().then((function(){return at()}))}().then((function(t){return WebAssembly.instantiate(t,r)})).then((function(t){return t})).then(t,(function(t){P(\"failed to asynchronously prepare wasm: \"+t),it(t)}))}var r={a:fe};if(x||(et++,s.monitorRunDependencies&&s.monitorRunDependencies(et)),s.instantiateWasm)try{return s.instantiateWasm(r,t)}catch(t){return P(\"Module.instantiateWasm callback failed with error: \"+t),!1}(E||\"function\"!=typeof WebAssembly.instantiateStreaming||ot()||tt.startsWith(\"file://\")||w||\"function\"!=typeof fetch?n(e):fetch(tt,{credentials:\"same-origin\"}).then((function(t){return WebAssembly.instantiateStreaming(t,r).then(e,(function(t){return P(\"wasm streaming compile failed: \"+t),P(\"falling back to ArrayBuffer instantiation\"),n(e)}))}))).catch(c)}(),s.___wasm_call_ctors=function(){return(s.___wasm_call_ctors=s.asm.Va).apply(null,arguments)},s._OrtInit=function(){return(s._OrtInit=s.asm.Wa).apply(null,arguments)},s._OrtCreateSessionOptions=function(){return(s._OrtCreateSessionOptions=s.asm.Xa).apply(null,arguments)},s._OrtAppendExecutionProvider=function(){return(s._OrtAppendExecutionProvider=s.asm.Ya).apply(null,arguments)},s._OrtAddSessionConfigEntry=function(){return(s._OrtAddSessionConfigEntry=s.asm.Za).apply(null,arguments)},s._OrtReleaseSessionOptions=function(){return(s._OrtReleaseSessionOptions=s.asm._a).apply(null,arguments)},s._OrtCreateSession=function(){return(s._OrtCreateSession=s.asm.$a).apply(null,arguments)},s._OrtReleaseSession=function(){return(s._OrtReleaseSession=s.asm.ab).apply(null,arguments)},s._OrtGetInputCount=function(){return(s._OrtGetInputCount=s.asm.bb).apply(null,arguments)},s._OrtGetOutputCount=function(){return(s._OrtGetOutputCount=s.asm.cb).apply(null,arguments)},s._OrtGetInputName=function(){return(s._OrtGetInputName=s.asm.db).apply(null,arguments)},s._OrtGetOutputName=function(){return(s._OrtGetOutputName=s.asm.eb).apply(null,arguments)},s._OrtFree=function(){return(s._OrtFree=s.asm.fb).apply(null,arguments)},s._OrtCreateTensor=function(){return(s._OrtCreateTensor=s.asm.gb).apply(null,arguments)},s._OrtGetTensorData=function(){return(s._OrtGetTensorData=s.asm.hb).apply(null,arguments)},s._OrtReleaseTensor=function(){return(s._OrtReleaseTensor=s.asm.ib).apply(null,arguments)},s._OrtCreateRunOptions=function(){return(s._OrtCreateRunOptions=s.asm.jb).apply(null,arguments)},s._OrtAddRunConfigEntry=function(){return(s._OrtAddRunConfigEntry=s.asm.kb).apply(null,arguments)},s._OrtReleaseRunOptions=function(){return(s._OrtReleaseRunOptions=s.asm.lb).apply(null,arguments)},s._OrtRun=function(){return(s._OrtRun=s.asm.mb).apply(null,arguments)},s._OrtEndProfiling=function(){return(s._OrtEndProfiling=s.asm.nb).apply(null,arguments)};var de=s._pthread_self=function(){return(de=s._pthread_self=s.asm.ob).apply(null,arguments)},he=s._malloc=function(){return(he=s._malloc=s.asm.pb).apply(null,arguments)},ge=s._free=function(){return(ge=s._free=s.asm.qb).apply(null,arguments)},be=s._fflush=function(){return(be=s._fflush=s.asm.rb).apply(null,arguments)};s.__emscripten_tls_init=function(){return(s.__emscripten_tls_init=s.asm.sb).apply(null,arguments)};var me=s.___funcs_on_exit=function(){return(me=s.___funcs_on_exit=s.asm.tb).apply(null,arguments)},ye=s.__emscripten_thread_init=function(){return(ye=s.__emscripten_thread_init=s.asm.vb).apply(null,arguments)};s.__emscripten_thread_crashed=function(){return(s.__emscripten_thread_crashed=s.asm.wb).apply(null,arguments)};var _e,ve=s._emscripten_run_in_main_runtime_thread_js=function(){return(ve=s._emscripten_run_in_main_runtime_thread_js=s.asm.xb).apply(null,arguments)},we=s.__emscripten_proxy_execute_task_queue=function(){return(we=s.__emscripten_proxy_execute_task_queue=s.asm.yb).apply(null,arguments)},xe=s.__emscripten_thread_free_data=function(){return(xe=s.__emscripten_thread_free_data=s.asm.zb).apply(null,arguments)},Te=s.__emscripten_thread_exit=function(){return(Te=s.__emscripten_thread_exit=s.asm.Ab).apply(null,arguments)},Se=s._setThrew=function(){return(Se=s._setThrew=s.asm.Bb).apply(null,arguments)},Oe=s._emscripten_stack_set_limits=function(){return(Oe=s._emscripten_stack_set_limits=s.asm.Cb).apply(null,arguments)},Ae=s.stackSave=function(){return(Ae=s.stackSave=s.asm.Db).apply(null,arguments)},Ee=s.stackRestore=function(){return(Ee=s.stackRestore=s.asm.Eb).apply(null,arguments)},Ie=s.stackAlloc=function(){return(Ie=s.stackAlloc=s.asm.Fb).apply(null,arguments)},Pe=s.___cxa_can_catch=function(){return(Pe=s.___cxa_can_catch=s.asm.Gb).apply(null,arguments)},De=s.___cxa_is_pointer_type=function(){return(De=s.___cxa_is_pointer_type=s.asm.Hb).apply(null,arguments)},$e=s.dynCall_j=function(){return($e=s.dynCall_j=s.asm.Ib).apply(null,arguments)},ke=s.dynCall_iiiiij=function(){return(ke=s.dynCall_iiiiij=s.asm.Jb).apply(null,arguments)},Ce=s.dynCall_jii=function(){return(Ce=s.dynCall_jii=s.asm.Kb).apply(null,arguments)},Fe=s.dynCall_viiiiij=function(){return(Fe=s.dynCall_viiiiij=s.asm.Lb).apply(null,arguments)},Ne=s.dynCall_vjji=function(){return(Ne=s.dynCall_vjji=s.asm.Mb).apply(null,arguments)},Le=s.dynCall_viiijjjii=function(){return(Le=s.dynCall_viiijjjii=s.asm.Nb).apply(null,arguments)},Re=s.dynCall_iij=function(){return(Re=s.dynCall_iij=s.asm.Ob).apply(null,arguments)},je=s.dynCall_ji=function(){return(je=s.dynCall_ji=s.asm.Pb).apply(null,arguments)},Me=s.dynCall_iiiiiij=function(){return(Me=s.dynCall_iiiiiij=s.asm.Qb).apply(null,arguments)},Ue=s.dynCall_iiij=function(){return(Ue=s.dynCall_iiij=s.asm.Rb).apply(null,arguments)};function Ve(){function t(){if(!_e&&(_e=!0,s.calledRun=!0,!M)&&(x||ht(Y),u(s),s.onRuntimeInitialized&&s.onRuntimeInitialized(),!x)){if(s.postRun)for(\"function\"==typeof s.postRun&&(s.postRun=[s.postRun]);s.postRun.length;){var t=s.postRun.shift();Z.unshift(t)}ht(Z)}}if(!(0<et))if(x)u(s),x||ht(Y),postMessage({cmd:\"loaded\"});else{if(s.preRun)for(\"function\"==typeof s.preRun&&(s.preRun=[s.preRun]);s.preRun.length;)Q();ht(X),0<et||(s.setStatus?(s.setStatus(\"Running...\"),setTimeout((function(){setTimeout((function(){s.setStatus(\"\")}),1),t()}),1)):t())}}if(s.UTF8ToString=B,s.stringToUTF8=function(t,e,n){return z(t,r(),e,n)},s.lengthBytesUTF8=G,s.keepRuntimeAlive=J,s.wasmMemory=$,s.stackSave=Ae,s.stackRestore=Ee,s.stackAlloc=Ie,s.ExitStatus=ut,s.PThread=dt,rt=function t(){_e||Ve(),_e||(rt=t)},s.preInit)for(\"function\"==typeof s.preInit&&(s.preInit=[s.preInit]);0<s.preInit.length;)s.preInit.pop()();return Ve(),t.ready});t.exports=r},932:(t,e,n)=>{var _scriptDir,r=(_scriptDir=(_scriptDir=\"undefined\"!=typeof document&&document.currentScript?document.currentScript.src:void 0)||\"/index.js\",function(t){var e,r,i;t=t||{},e||(e=void 0!==t?t:{}),e.ready=new Promise((function(t,e){r=t,i=e}));var o,a,s,u,c,l,p=Object.assign({},e),f=\"./this.program\",d=(t,e)=>{throw e},h=\"object\"==typeof window,g=\"function\"==typeof importScripts,b=\"object\"==typeof process&&\"object\"==typeof process.versions&&\"string\"==typeof process.versions.node,m=\"\";b?(m=g?n(908).dirname(m)+\"/\":\"//\",l=()=>{c||(u=n(1384),c=n(908))},o=function(t,e){return l(),t=c.normalize(t),u.readFileSync(t,e?void 0:\"utf8\")},s=t=>((t=o(t,!0)).buffer||(t=new Uint8Array(t)),t),a=(t,e,n)=>{l(),t=c.normalize(t),u.readFile(t,(function(t,r){t?n(t):e(r.buffer)}))},1<process.argv.length&&(f=process.argv[1].replace(/\\\\/g,\"/\")),process.argv.slice(2),process.on(\"uncaughtException\",(function(t){if(!(t instanceof K))throw t})),process.on(\"unhandledRejection\",(function(t){throw t})),d=(t,e)=>{if(w||0<U)throw process.exitCode=t,e;e instanceof K||v(\"exiting due to exception: \"+e),process.exit(t)},e.inspect=function(){return\"[Emscripten Module object]\"}):(h||g)&&(g?m=self.location.href:\"undefined\"!=typeof document&&document.currentScript&&(m=document.currentScript.src),_scriptDir&&(m=_scriptDir),m=0!==m.indexOf(\"blob:\")?m.substr(0,m.replace(/[?#].*/,\"\").lastIndexOf(\"/\")+1):\"\",o=t=>{var e=new XMLHttpRequest;return e.open(\"GET\",t,!1),e.send(null),e.responseText},g&&(s=t=>{var e=new XMLHttpRequest;return e.open(\"GET\",t,!1),e.responseType=\"arraybuffer\",e.send(null),new Uint8Array(e.response)}),a=(t,e,n)=>{var r=new XMLHttpRequest;r.open(\"GET\",t,!0),r.responseType=\"arraybuffer\",r.onload=()=>{200==r.status||0==r.status&&r.response?e(r.response):n()},r.onerror=n,r.send(null)});var y,_=e.print||console.log.bind(console),v=e.printErr||console.warn.bind(console);Object.assign(e,p),p=null,e.thisProgram&&(f=e.thisProgram),e.quit&&(d=e.quit),e.wasmBinary&&(y=e.wasmBinary);var w=e.noExitRuntime||!1;\"object\"!=typeof WebAssembly&&W(\"no native wasm support detected\");var x,T,S,O,A,E,I=!1,P=\"undefined\"!=typeof TextDecoder?new TextDecoder(\"utf8\"):void 0;function D(t,e,n){var r=(e>>>=0)+n;for(n=e;t[n]&&!(n>=r);)++n;if(16<n-e&&t.buffer&&P)return P.decode(t.subarray(e,n));for(r=\"\";e<n;){var i=t[e++];if(128&i){var o=63&t[e++];if(192==(224&i))r+=String.fromCharCode((31&i)<<6|o);else{var a=63&t[e++];65536>(i=224==(240&i)?(15&i)<<12|o<<6|a:(7&i)<<18|o<<12|a<<6|63&t[e++])?r+=String.fromCharCode(i):(i-=65536,r+=String.fromCharCode(55296|i>>10,56320|1023&i))}}else r+=String.fromCharCode(i)}return r}function $(t,e){return(t>>>=0)?D(O,t,e):\"\"}function k(t,e,n,r){if(!(0<r))return 0;var i=n>>>=0;r=n+r-1;for(var o=0;o<t.length;++o){var a=t.charCodeAt(o);if(55296<=a&&57343>=a&&(a=65536+((1023&a)<<10)|1023&t.charCodeAt(++o)),127>=a){if(n>=r)break;e[n++>>>0]=a}else{if(2047>=a){if(n+1>=r)break;e[n++>>>0]=192|a>>6}else{if(65535>=a){if(n+2>=r)break;e[n++>>>0]=224|a>>12}else{if(n+3>=r)break;e[n++>>>0]=240|a>>18,e[n++>>>0]=128|a>>12&63}e[n++>>>0]=128|a>>6&63}e[n++>>>0]=128|63&a}}return e[n>>>0]=0,n-i}function C(t){for(var e=0,n=0;n<t.length;++n){var r=t.charCodeAt(n);127>=r?e++:2047>=r?e+=2:55296<=r&&57343>=r?(e+=4,++n):e+=3}return e}function F(){var t=x.buffer;T=t,e.HEAP8=S=new Int8Array(t),e.HEAP16=new Int16Array(t),e.HEAP32=A=new Int32Array(t),e.HEAPU8=O=new Uint8Array(t),e.HEAPU16=new Uint16Array(t),e.HEAPU32=E=new Uint32Array(t),e.HEAPF32=new Float32Array(t),e.HEAPF64=new Float64Array(t)}var N,L=[],R=[],j=[],M=[],U=0;function V(){var t=e.preRun.shift();L.unshift(t)}var B,z=0,G=null,H=null;function W(t){throw e.onAbort&&e.onAbort(t),v(t=\"Aborted(\"+t+\")\"),I=!0,t=new WebAssembly.RuntimeError(t+\". Build with -sASSERTIONS for more info.\"),i(t),t}function q(){return B.startsWith(\"data:application/octet-stream;base64,\")}if(B=\"ort-wasm.wasm\",!q()){var X=B;B=e.locateFile?e.locateFile(X,m):m+X}function Y(){var t=B;try{if(t==B&&y)return new Uint8Array(y);if(s)return s(t);throw\"both async and sync fetching of the wasm failed\"}catch(t){W(t)}}function K(t){this.name=\"ExitStatus\",this.message=\"Program terminated with exit(\"+t+\")\",this.status=t}function Z(t){for(;0<t.length;)t.shift()(e)}var J=[],Q=0,tt=0;function et(t){this.Db=t,this.zb=t-24,this.Ub=function(t){E[this.zb+4>>2>>>0]=t},this.Eb=function(){return E[this.zb+4>>2>>>0]},this.Sb=function(t){E[this.zb+8>>2>>>0]=t},this.Wb=function(){return E[this.zb+8>>2>>>0]},this.Tb=function(){A[this.zb>>2>>>0]=0},this.Ib=function(t){S[this.zb+12>>0>>>0]=t?1:0},this.Pb=function(){return 0!=S[this.zb+12>>0>>>0]},this.Jb=function(t){S[this.zb+13>>0>>>0]=t?1:0},this.Lb=function(){return 0!=S[this.zb+13>>0>>>0]},this.Rb=function(t,e){this.Fb(0),this.Ub(t),this.Sb(e),this.Tb(),this.Ib(!1),this.Jb(!1)},this.Nb=function(){A[this.zb>>2>>>0]+=1},this.Xb=function(){var t=A[this.zb>>2>>>0];return A[this.zb>>2>>>0]=t-1,1===t},this.Fb=function(t){E[this.zb+16>>2>>>0]=t},this.Ob=function(){return E[this.zb+16>>2>>>0]},this.Qb=function(){if(Et(this.Eb()))return E[this.Db>>2>>>0];var t=this.Ob();return 0!==t?t:this.Db}}function nt(t){return _t(new et(t).zb)}var rt=[];function it(t){var e=rt[t];return e||(t>=rt.length&&(rt.length=t+1),rt[t]=e=N.get(t)),e}function ot(t){var e=C(t)+1,n=yt(e);return n&&k(t,S,n,e),n}var at={};function st(){if(!ut){var t,e={USER:\"web_user\",LOGNAME:\"web_user\",PATH:\"/\",PWD:\"/\",HOME:\"/home/web_user\",LANG:(\"object\"==typeof navigator&&navigator.languages&&navigator.languages[0]||\"C\").replace(\"-\",\"_\")+\".UTF-8\",_:f||\"./this.program\"};for(t in at)void 0===at[t]?delete e[t]:e[t]=at[t];var n=[];for(t in e)n.push(t+\"=\"+e[t]);ut=n}return ut}var ut,ct=[null,[],[]];function lt(t,e){var n=ct[t];0===e||10===e?((1===t?_:v)(D(n,0)),n.length=0):n.push(e)}var pt=0;function ft(t){return 0==t%4&&(0!=t%100||0==t%400)}var dt=[31,29,31,30,31,30,31,31,30,31,30,31],ht=[31,28,31,30,31,30,31,31,30,31,30,31];function gt(t,e,n,r){function i(t,e,n){for(t=\"number\"==typeof t?t.toString():t||\"\";t.length<e;)t=n[0]+t;return t}function o(t,e){return i(t,e,\"0\")}function a(t,e){function n(t){return 0>t?-1:0<t?1:0}var r;return 0===(r=n(t.getFullYear()-e.getFullYear()))&&0===(r=n(t.getMonth()-e.getMonth()))&&(r=n(t.getDate()-e.getDate())),r}function s(t){switch(t.getDay()){case 0:return new Date(t.getFullYear()-1,11,29);case 1:return t;case 2:return new Date(t.getFullYear(),0,3);case 3:return new Date(t.getFullYear(),0,2);case 4:return new Date(t.getFullYear(),0,1);case 5:return new Date(t.getFullYear()-1,11,31);case 6:return new Date(t.getFullYear()-1,11,30)}}function u(t){var e=t.Bb;for(t=new Date(new Date(t.Cb+1900,0,1).getTime());0<e;){var n=t.getMonth(),r=(ft(t.getFullYear())?dt:ht)[n];if(!(e>r-t.getDate())){t.setDate(t.getDate()+e);break}e-=r-t.getDate()+1,t.setDate(1),11>n?t.setMonth(n+1):(t.setMonth(0),t.setFullYear(t.getFullYear()+1))}return n=new Date(t.getFullYear()+1,0,4),e=s(new Date(t.getFullYear(),0,4)),n=s(n),0>=a(e,t)?0>=a(n,t)?t.getFullYear()+1:t.getFullYear():t.getFullYear()-1}var c=A[r+40>>2>>>0];for(var l in r={$b:A[r>>2>>>0],Zb:A[r+4>>2>>>0],Gb:A[r+8>>2>>>0],Kb:A[r+12>>2>>>0],Hb:A[r+16>>2>>>0],Cb:A[r+20>>2>>>0],Ab:A[r+24>>2>>>0],Bb:A[r+28>>2>>>0],bc:A[r+32>>2>>>0],Yb:A[r+36>>2>>>0],ac:c?$(c):\"\"},n=$(n),c={\"%c\":\"%a %b %d %H:%M:%S %Y\",\"%D\":\"%m/%d/%y\",\"%F\":\"%Y-%m-%d\",\"%h\":\"%b\",\"%r\":\"%I:%M:%S %p\",\"%R\":\"%H:%M\",\"%T\":\"%H:%M:%S\",\"%x\":\"%m/%d/%y\",\"%X\":\"%H:%M:%S\",\"%Ec\":\"%c\",\"%EC\":\"%C\",\"%Ex\":\"%m/%d/%y\",\"%EX\":\"%H:%M:%S\",\"%Ey\":\"%y\",\"%EY\":\"%Y\",\"%Od\":\"%d\",\"%Oe\":\"%e\",\"%OH\":\"%H\",\"%OI\":\"%I\",\"%Om\":\"%m\",\"%OM\":\"%M\",\"%OS\":\"%S\",\"%Ou\":\"%u\",\"%OU\":\"%U\",\"%OV\":\"%V\",\"%Ow\":\"%w\",\"%OW\":\"%W\",\"%Oy\":\"%y\"})n=n.replace(new RegExp(l,\"g\"),c[l]);var p=\"Sunday Monday Tuesday Wednesday Thursday Friday Saturday\".split(\" \"),f=\"January February March April May June July August September October November December\".split(\" \");for(l in c={\"%a\":function(t){return p[t.Ab].substring(0,3)},\"%A\":function(t){return p[t.Ab]},\"%b\":function(t){return f[t.Hb].substring(0,3)},\"%B\":function(t){return f[t.Hb]},\"%C\":function(t){return o((t.Cb+1900)/100|0,2)},\"%d\":function(t){return o(t.Kb,2)},\"%e\":function(t){return i(t.Kb,2,\" \")},\"%g\":function(t){return u(t).toString().substring(2)},\"%G\":function(t){return u(t)},\"%H\":function(t){return o(t.Gb,2)},\"%I\":function(t){return 0==(t=t.Gb)?t=12:12<t&&(t-=12),o(t,2)},\"%j\":function(t){for(var e=0,n=0;n<=t.Hb-1;e+=(ft(t.Cb+1900)?dt:ht)[n++]);return o(t.Kb+e,3)},\"%m\":function(t){return o(t.Hb+1,2)},\"%M\":function(t){return o(t.Zb,2)},\"%n\":function(){return\"\\n\"},\"%p\":function(t){return 0<=t.Gb&&12>t.Gb?\"AM\":\"PM\"},\"%S\":function(t){return o(t.$b,2)},\"%t\":function(){return\"\\t\"},\"%u\":function(t){return t.Ab||7},\"%U\":function(t){return o(Math.floor((t.Bb+7-t.Ab)/7),2)},\"%V\":function(t){var e=Math.floor((t.Bb+7-(t.Ab+6)%7)/7);if(2>=(t.Ab+371-t.Bb-2)%7&&e++,e)53==e&&(4==(n=(t.Ab+371-t.Bb)%7)||3==n&&ft(t.Cb)||(e=1));else{e=52;var n=(t.Ab+7-t.Bb-1)%7;(4==n||5==n&&ft(t.Cb%400-1))&&e++}return o(e,2)},\"%w\":function(t){return t.Ab},\"%W\":function(t){return o(Math.floor((t.Bb+7-(t.Ab+6)%7)/7),2)},\"%y\":function(t){return(t.Cb+1900).toString().substring(2)},\"%Y\":function(t){return t.Cb+1900},\"%z\":function(t){var e=0<=(t=t.Yb);return t=Math.abs(t)/60,(e?\"+\":\"-\")+String(\"0000\"+(t/60*100+t%60)).slice(-4)},\"%Z\":function(t){return t.ac},\"%%\":function(){return\"%\"}},n=n.replace(/%%/g,\"\\0\\0\"),c)n.includes(l)&&(n=n.replace(new RegExp(l,\"g\"),c[l](r)));return l=function(t){var e=Array(C(t)+1);return k(t,e,0,e.length),e}(n=n.replace(/\\0\\0/g,\"%\")),l.length>e?0:(S.set(l,t>>>0),l.length-1)}var bt={a:function(t){return yt(t+24)+24},m:function(t){return(t=new et(t)).Pb()||(t.Ib(!0),Q--),t.Jb(!1),J.push(t),t.Nb(),t.Qb()},ia:function(t){throw v(\"Unexpected exception thrown, this is not properly supported - aborting\"),I=!0,t},w:function(){xt(0);var t=J.pop();if(t.Xb()&&!t.Lb()){var e=t.Wb();e&&it(e)(t.Db),nt(t.Db)}tt=0},d:function(){var t=tt;if(!t)return pt=0;var e=new et(t);e.Fb(t);var n=e.Eb();if(!n)return pt=0,t;for(var r=Array.prototype.slice.call(arguments),i=0;i<r.length;i++){var o=r[i];if(0===o||o===n)break;if(At(o,n,e.zb+16))return pt=o,t}return pt=n,t},k:function(){var t=tt;if(!t)return pt=0;var e=new et(t);e.Fb(t);var n=e.Eb();if(!n)return pt=0,t;for(var r=Array.prototype.slice.call(arguments),i=0;i<r.length;i++){var o=r[i];if(0===o||o===n)break;if(At(o,n,e.zb+16))return pt=o,t}return pt=n,t},g:function(){var t=tt;if(!t)return pt=0;var e=new et(t);e.Fb(t);var n=e.Eb();if(!n)return pt=0,t;for(var r=Array.prototype.slice.call(arguments),i=0;i<r.length;i++){var o=r[i];if(0===o||o===n)break;if(At(o,n,e.zb+16))return pt=o,t}return pt=n,t},s:nt,L:function(){var t=J.pop();t||W(\"no exception to throw\");var e=t.Db;throw t.Lb()||(J.push(t),t.Jb(!0),t.Ib(!1),Q++),tt=e,e},b:function(t,e,n){throw new et(t).Rb(e,n),tt=t,Q++,t},la:function(){return Q},i:function(t){throw tt||(tt=t),t},H:function(){return 0},Ba:function(){},pa:function(){},ra:function(){},ka:function(){return 0},za:function(){},ua:function(){},ya:function(){},R:function(){},qa:function(){},na:function(){},Aa:function(){},oa:function(){},Ha:function(){},Ja:function(){W(\"To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking\")},Ia:function(){W(\"To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking\")},S:function(){return Date.now()},Ca:function(){return!0},Da:function(t,e){t=new Date(1e3*(E[t>>>2]+4294967296*A[t+4>>>2])),A[e>>2>>>0]=t.getUTCSeconds(),A[e+4>>2>>>0]=t.getUTCMinutes(),A[e+8>>2>>>0]=t.getUTCHours(),A[e+12>>2>>>0]=t.getUTCDate(),A[e+16>>2>>>0]=t.getUTCMonth(),A[e+20>>2>>>0]=t.getUTCFullYear()-1900,A[e+24>>2>>>0]=t.getUTCDay(),A[e+28>>2>>>0]=(t.getTime()-Date.UTC(t.getUTCFullYear(),0,1,0,0,0,0))/864e5|0},Ea:function(t,e){t=new Date(1e3*(E[t>>>2]+4294967296*A[t+4>>>2])),A[e>>2>>>0]=t.getSeconds(),A[e+4>>2>>>0]=t.getMinutes(),A[e+8>>2>>>0]=t.getHours(),A[e+12>>2>>>0]=t.getDate(),A[e+16>>2>>>0]=t.getMonth(),A[e+20>>2>>>0]=t.getFullYear()-1900,A[e+24>>2>>>0]=t.getDay();var n=new Date(t.getFullYear(),0,1);A[e+28>>2>>>0]=(t.getTime()-n.getTime())/864e5|0,A[e+36>>2>>>0]=-60*t.getTimezoneOffset();var r=new Date(t.getFullYear(),6,1).getTimezoneOffset();n=n.getTimezoneOffset(),A[e+32>>2>>>0]=0|(r!=n&&t.getTimezoneOffset()==Math.min(n,r))},Fa:function(t){var e=new Date(A[t+20>>2>>>0]+1900,A[t+16>>2>>>0],A[t+12>>2>>>0],A[t+8>>2>>>0],A[t+4>>2>>>0],A[t>>2>>>0],0),n=A[t+32>>2>>>0],r=e.getTimezoneOffset(),i=new Date(e.getFullYear(),0,1),o=new Date(e.getFullYear(),6,1).getTimezoneOffset(),a=i.getTimezoneOffset(),s=Math.min(a,o);return 0>n?A[t+32>>2>>>0]=Number(o!=a&&s==r):0<n!=(s==r)&&(o=Math.max(a,o),e.setTime(e.getTime()+6e4*((0<n?s:o)-r))),A[t+24>>2>>>0]=e.getDay(),A[t+28>>2>>>0]=(e.getTime()-i.getTime())/864e5|0,A[t>>2>>>0]=e.getSeconds(),A[t+4>>2>>>0]=e.getMinutes(),A[t+8>>2>>>0]=e.getHours(),A[t+12>>2>>>0]=e.getDate(),A[t+16>>2>>>0]=e.getMonth(),e.getTime()/1e3|0},sa:function(){return-52},ta:function(){},Ga:function t(e,n,r){t.Vb||(t.Vb=!0,function(t,e,n){function r(t){return(t=t.toTimeString().match(/\\(([A-Za-z ]+)\\)$/))?t[1]:\"GMT\"}var i=(new Date).getFullYear(),o=new Date(i,0,1),a=new Date(i,6,1);i=o.getTimezoneOffset();var s=a.getTimezoneOffset();A[t>>2>>>0]=60*Math.max(i,s),A[e>>2>>>0]=Number(i!=s),t=r(o),e=r(a),t=ot(t),e=ot(e),s<i?(E[n>>2>>>0]=t,E[n+4>>2>>>0]=e):(E[n>>2>>>0]=e,E[n+4>>2>>>0]=t)}(e,n,r))},B:function(){W(\"\")},ma:function(){return 4294901760},I:b?()=>{var t=process.hrtime();return 1e3*t[0]+t[1]/1e6}:()=>performance.now(),xa:function(t,e,n){O.copyWithin(t>>>0,e>>>0,e+n>>>0)},G:function(t){var e=O.length;if(4294901760<(t>>>=0))return!1;for(var n=1;4>=n;n*=2){var r=e*(1+.2/n);r=Math.min(r,t+100663296);var i=Math;r=Math.max(t,r),i=i.min.call(i,4294901760,r+(65536-r%65536)%65536);t:{try{x.grow(i-T.byteLength+65535>>>16),F();var o=1;break t}catch(t){}o=void 0}if(o)return!0}return!1},va:function(t,e){var n=0;return st().forEach((function(r,i){var o=e+n;for(i=E[t+4*i>>2>>>0]=o,o=0;o<r.length;++o)S[i++>>0>>>0]=r.charCodeAt(o);S[i>>0>>>0]=0,n+=r.length+1})),0},wa:function(t,e){var n=st();E[t>>2>>>0]=n.length;var r=0;return n.forEach((function(t){r+=t.length+1})),E[e>>2>>>0]=r,0},ba:function(t){w||0<U||(wt(),Z(j),vt(0),ct[1].length&&lt(1,10),ct[2].length&&lt(2,10)),w||0<U||(e.onExit&&e.onExit(t),I=!0),d(t,new K(t))},E:function(){return 52},Q:function(){return 52},ca:function(){return 70},P:function(t,e,n,r){for(var i=0,o=0;o<n;o++){var a=E[e>>2>>>0],s=E[e+4>>2>>>0];e+=8;for(var u=0;u<s;u++)lt(t,O[a+u>>>0]);i+=s}return E[r>>2>>>0]=i,0},c:function(){return pt},ja:function t(e,r){t.Mb||(t.Mb=function(){if(\"object\"==typeof crypto&&\"function\"==typeof crypto.getRandomValues){var t=new Uint8Array(1);return()=>(crypto.getRandomValues(t),t[0])}if(b)try{var e=n(Object(function(){var t=new Error(\"Cannot find module 'crypto'\");throw t.code=\"MODULE_NOT_FOUND\",t}()));return()=>e.randomBytes(1)[0]}catch(t){}return()=>W(\"randomDevice\")}());for(var i=0;i<r;i++)S[e+i>>0>>>0]=t.Mb();return 0},ea:function(t,e,n){var r=Tt();try{return it(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;xt(1,0)}},fa:function(t,e,n){var r=Tt();try{return it(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;xt(1,0)}},J:function(t){var e=Tt();try{return it(t)()}catch(t){if(St(e),t!==t+0)throw t;xt(1,0)}},e:function(t,e){var n=Tt();try{return it(t)(e)}catch(t){if(St(n),t!==t+0)throw t;xt(1,0)}},N:function(t,e,n){var r=Tt();try{return it(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;xt(1,0)}},O:function(t,e,n){var r=Tt();try{return it(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;xt(1,0)}},j:function(t,e,n){var r=Tt();try{return it(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;xt(1,0)}},o:function(t,e,n,r){var i=Tt();try{return it(t)(e,n,r)}catch(t){if(St(i),t!==t+0)throw t;xt(1,0)}},p:function(t,e,n,r,i){var o=Tt();try{return it(t)(e,n,r,i)}catch(t){if(St(o),t!==t+0)throw t;xt(1,0)}},M:function(t,e,n,r,i,o){var a=Tt();try{return it(t)(e,n,r,i,o)}catch(t){if(St(a),t!==t+0)throw t;xt(1,0)}},r:function(t,e,n,r,i,o){var a=Tt();try{return it(t)(e,n,r,i,o)}catch(t){if(St(a),t!==t+0)throw t;xt(1,0)}},v:function(t,e,n,r,i,o,a){var s=Tt();try{return it(t)(e,n,r,i,o,a)}catch(t){if(St(s),t!==t+0)throw t;xt(1,0)}},K:function(t,e,n,r,i,o,a,s){var u=Tt();try{return it(t)(e,n,r,i,o,a,s)}catch(t){if(St(u),t!==t+0)throw t;xt(1,0)}},D:function(t,e,n,r,i,o,a,s,u,c,l,p){var f=Tt();try{return it(t)(e,n,r,i,o,a,s,u,c,l,p)}catch(t){if(St(f),t!==t+0)throw t;xt(1,0)}},X:function(t,e,n,r,i,o,a,s){var u=Tt();try{return Lt(t,e,n,r,i,o,a,s)}catch(t){if(St(u),t!==t+0)throw t;xt(1,0)}},V:function(t,e,n,r,i,o,a){var s=Tt();try{return Pt(t,e,n,r,i,o,a)}catch(t){if(St(s),t!==t+0)throw t;xt(1,0)}},U:function(t,e,n,r,i){var o=Tt();try{return Rt(t,e,n,r,i)}catch(t){if(St(o),t!==t+0)throw t;xt(1,0)}},Z:function(t,e,n,r){var i=Tt();try{return Ft(t,e,n,r)}catch(t){if(St(i),t!==t+0)throw t;xt(1,0)}},W:function(t){var e=Tt();try{return It(t)}catch(t){if(St(e),t!==t+0)throw t;xt(1,0)}},Y:function(t,e){var n=Tt();try{return Nt(t,e)}catch(t){if(St(n),t!==t+0)throw t;xt(1,0)}},T:function(t,e,n){var r=Tt();try{return Dt(t,e,n)}catch(t){if(St(r),t!==t+0)throw t;xt(1,0)}},f:function(t){var e=Tt();try{it(t)()}catch(t){if(St(e),t!==t+0)throw t;xt(1,0)}},q:function(t,e){var n=Tt();try{it(t)(e)}catch(t){if(St(n),t!==t+0)throw t;xt(1,0)}},h:function(t,e,n){var r=Tt();try{it(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;xt(1,0)}},da:function(t,e,n,r){var i=Tt();try{it(t)(e,n,r)}catch(t){if(St(i),t!==t+0)throw t;xt(1,0)}},l:function(t,e,n,r){var i=Tt();try{it(t)(e,n,r)}catch(t){if(St(i),t!==t+0)throw t;xt(1,0)}},t:function(t,e,n,r,i){var o=Tt();try{it(t)(e,n,r,i)}catch(t){if(St(o),t!==t+0)throw t;xt(1,0)}},u:function(t,e,n,r,i,o){var a=Tt();try{it(t)(e,n,r,i,o)}catch(t){if(St(a),t!==t+0)throw t;xt(1,0)}},x:function(t,e,n,r,i,o,a){var s=Tt();try{it(t)(e,n,r,i,o,a)}catch(t){if(St(s),t!==t+0)throw t;xt(1,0)}},z:function(t,e,n,r,i,o,a,s){var u=Tt();try{it(t)(e,n,r,i,o,a,s)}catch(t){if(St(u),t!==t+0)throw t;xt(1,0)}},ga:function(t,e,n,r,i,o,a,s,u){var c=Tt();try{it(t)(e,n,r,i,o,a,s,u)}catch(t){if(St(c),t!==t+0)throw t;xt(1,0)}},A:function(t,e,n,r,i,o,a,s,u,c,l){var p=Tt();try{it(t)(e,n,r,i,o,a,s,u,c,l)}catch(t){if(St(p),t!==t+0)throw t;xt(1,0)}},C:function(t,e,n,r,i,o,a,s,u,c,l,p,f,d,h,g){var b=Tt();try{it(t)(e,n,r,i,o,a,s,u,c,l,p,f,d,h,g)}catch(t){if(St(b),t!==t+0)throw t;xt(1,0)}},aa:function(t,e,n,r,i,o,a,s){var u=Tt();try{$t(t,e,n,r,i,o,a,s)}catch(t){if(St(u),t!==t+0)throw t;xt(1,0)}},_:function(t,e,n,r,i,o,a,s,u,c,l,p){var f=Tt();try{Ct(t,e,n,r,i,o,a,s,u,c,l,p)}catch(t){if(St(f),t!==t+0)throw t;xt(1,0)}},$:function(t,e,n,r,i,o){var a=Tt();try{kt(t,e,n,r,i,o)}catch(t){if(St(a),t!==t+0)throw t;xt(1,0)}},n:function(t){return t},F:function(t){pt=t},ha:gt,y:function(t,e,n,r){return gt(t,e,n,r)}};!function(){function t(t){e.asm=t.exports,x=e.asm.Ka,F(),N=e.asm.ib,R.unshift(e.asm.La),z--,e.monitorRunDependencies&&e.monitorRunDependencies(z),0==z&&(null!==G&&(clearInterval(G),G=null),H&&(t=H,H=null,t()))}function n(e){t(e.instance)}function r(t){return function(){if(!y&&(h||g)){if(\"function\"==typeof fetch&&!B.startsWith(\"file://\"))return fetch(B,{credentials:\"same-origin\"}).then((function(t){if(!t.ok)throw\"failed to load wasm binary file at '\"+B+\"'\";return t.arrayBuffer()})).catch((function(){return Y()}));if(a)return new Promise((function(t,e){a(B,(function(e){t(new Uint8Array(e))}),e)}))}return Promise.resolve().then((function(){return Y()}))}().then((function(t){return WebAssembly.instantiate(t,o)})).then((function(t){return t})).then(t,(function(t){v(\"failed to asynchronously prepare wasm: \"+t),W(t)}))}var o={a:bt};if(z++,e.monitorRunDependencies&&e.monitorRunDependencies(z),e.instantiateWasm)try{return e.instantiateWasm(o,t)}catch(t){return v(\"Module.instantiateWasm callback failed with error: \"+t),!1}(y||\"function\"!=typeof WebAssembly.instantiateStreaming||q()||B.startsWith(\"file://\")||b||\"function\"!=typeof fetch?r(n):fetch(B,{credentials:\"same-origin\"}).then((function(t){return WebAssembly.instantiateStreaming(t,o).then(n,(function(t){return v(\"wasm streaming compile failed: \"+t),v(\"falling back to ArrayBuffer instantiation\"),r(n)}))}))).catch(i)}(),e.___wasm_call_ctors=function(){return(e.___wasm_call_ctors=e.asm.La).apply(null,arguments)},e._OrtInit=function(){return(e._OrtInit=e.asm.Ma).apply(null,arguments)},e._OrtCreateSessionOptions=function(){return(e._OrtCreateSessionOptions=e.asm.Na).apply(null,arguments)},e._OrtAppendExecutionProvider=function(){return(e._OrtAppendExecutionProvider=e.asm.Oa).apply(null,arguments)},e._OrtAddSessionConfigEntry=function(){return(e._OrtAddSessionConfigEntry=e.asm.Pa).apply(null,arguments)},e._OrtReleaseSessionOptions=function(){return(e._OrtReleaseSessionOptions=e.asm.Qa).apply(null,arguments)},e._OrtCreateSession=function(){return(e._OrtCreateSession=e.asm.Ra).apply(null,arguments)},e._OrtReleaseSession=function(){return(e._OrtReleaseSession=e.asm.Sa).apply(null,arguments)},e._OrtGetInputCount=function(){return(e._OrtGetInputCount=e.asm.Ta).apply(null,arguments)},e._OrtGetOutputCount=function(){return(e._OrtGetOutputCount=e.asm.Ua).apply(null,arguments)},e._OrtGetInputName=function(){return(e._OrtGetInputName=e.asm.Va).apply(null,arguments)},e._OrtGetOutputName=function(){return(e._OrtGetOutputName=e.asm.Wa).apply(null,arguments)},e._OrtFree=function(){return(e._OrtFree=e.asm.Xa).apply(null,arguments)},e._OrtCreateTensor=function(){return(e._OrtCreateTensor=e.asm.Ya).apply(null,arguments)},e._OrtGetTensorData=function(){return(e._OrtGetTensorData=e.asm.Za).apply(null,arguments)},e._OrtReleaseTensor=function(){return(e._OrtReleaseTensor=e.asm._a).apply(null,arguments)},e._OrtCreateRunOptions=function(){return(e._OrtCreateRunOptions=e.asm.$a).apply(null,arguments)},e._OrtAddRunConfigEntry=function(){return(e._OrtAddRunConfigEntry=e.asm.ab).apply(null,arguments)},e._OrtReleaseRunOptions=function(){return(e._OrtReleaseRunOptions=e.asm.bb).apply(null,arguments)},e._OrtRun=function(){return(e._OrtRun=e.asm.cb).apply(null,arguments)},e._OrtEndProfiling=function(){return(e._OrtEndProfiling=e.asm.db).apply(null,arguments)};var mt,yt=e._malloc=function(){return(yt=e._malloc=e.asm.eb).apply(null,arguments)},_t=e._free=function(){return(_t=e._free=e.asm.fb).apply(null,arguments)},vt=e._fflush=function(){return(vt=e._fflush=e.asm.gb).apply(null,arguments)},wt=e.___funcs_on_exit=function(){return(wt=e.___funcs_on_exit=e.asm.hb).apply(null,arguments)},xt=e._setThrew=function(){return(xt=e._setThrew=e.asm.jb).apply(null,arguments)},Tt=e.stackSave=function(){return(Tt=e.stackSave=e.asm.kb).apply(null,arguments)},St=e.stackRestore=function(){return(St=e.stackRestore=e.asm.lb).apply(null,arguments)},Ot=e.stackAlloc=function(){return(Ot=e.stackAlloc=e.asm.mb).apply(null,arguments)},At=e.___cxa_can_catch=function(){return(At=e.___cxa_can_catch=e.asm.nb).apply(null,arguments)},Et=e.___cxa_is_pointer_type=function(){return(Et=e.___cxa_is_pointer_type=e.asm.ob).apply(null,arguments)},It=e.dynCall_j=function(){return(It=e.dynCall_j=e.asm.pb).apply(null,arguments)},Pt=e.dynCall_iiiiij=function(){return(Pt=e.dynCall_iiiiij=e.asm.qb).apply(null,arguments)},Dt=e.dynCall_jii=function(){return(Dt=e.dynCall_jii=e.asm.rb).apply(null,arguments)},$t=e.dynCall_viiiiij=function(){return($t=e.dynCall_viiiiij=e.asm.sb).apply(null,arguments)},kt=e.dynCall_vjji=function(){return(kt=e.dynCall_vjji=e.asm.tb).apply(null,arguments)},Ct=e.dynCall_viiijjjii=function(){return(Ct=e.dynCall_viiijjjii=e.asm.ub).apply(null,arguments)},Ft=e.dynCall_iij=function(){return(Ft=e.dynCall_iij=e.asm.vb).apply(null,arguments)},Nt=e.dynCall_ji=function(){return(Nt=e.dynCall_ji=e.asm.wb).apply(null,arguments)},Lt=e.dynCall_iiiiiij=function(){return(Lt=e.dynCall_iiiiiij=e.asm.xb).apply(null,arguments)},Rt=e.dynCall_iiij=function(){return(Rt=e.dynCall_iiij=e.asm.yb).apply(null,arguments)};function jt(){function t(){if(!mt&&(mt=!0,e.calledRun=!0,!I)){if(Z(R),r(e),e.onRuntimeInitialized&&e.onRuntimeInitialized(),e.postRun)for(\"function\"==typeof e.postRun&&(e.postRun=[e.postRun]);e.postRun.length;){var t=e.postRun.shift();M.unshift(t)}Z(M)}}if(!(0<z)){if(e.preRun)for(\"function\"==typeof e.preRun&&(e.preRun=[e.preRun]);e.preRun.length;)V();Z(L),0<z||(e.setStatus?(e.setStatus(\"Running...\"),setTimeout((function(){setTimeout((function(){e.setStatus(\"\")}),1),t()}),1)):t())}}if(e.UTF8ToString=$,e.stringToUTF8=function(t,e,n){return k(t,O,e,n)},e.lengthBytesUTF8=C,e.stackSave=Tt,e.stackRestore=St,e.stackAlloc=Ot,H=function t(){mt||jt(),mt||(H=t)},e.preInit)for(\"function\"==typeof e.preInit&&(e.preInit=[e.preInit]);0<e.preInit.length;)e.preInit.pop()();return jt(),t.ready});t.exports=r},4537:t=>{\"use strict\";t.exports=function(t,e){for(var n=new Array(arguments.length-1),r=0,i=2,o=!0;i<arguments.length;)n[r++]=arguments[i++];return new Promise((function(i,a){n[r]=function(t){if(o)if(o=!1,t)a(t);else{for(var e=new Array(arguments.length-1),n=0;n<e.length;)e[n++]=arguments[n];i.apply(null,e)}};try{t.apply(e||null,n)}catch(t){o&&(o=!1,a(t))}}))}},7419:(t,e)=>{\"use strict\";var n=e;n.length=function(t){var e=t.length;if(!e)return 0;for(var n=0;--e%4>1&&\"=\"===t.charAt(e);)++n;return Math.ceil(3*t.length)/4-n};for(var r=new Array(64),i=new Array(123),o=0;o<64;)i[r[o]=o<26?o+65:o<52?o+71:o<62?o-4:o-59|43]=o++;n.encode=function(t,e,n){for(var i,o=null,a=[],s=0,u=0;e<n;){var c=t[e++];switch(u){case 0:a[s++]=r[c>>2],i=(3&c)<<4,u=1;break;case 1:a[s++]=r[i|c>>4],i=(15&c)<<2,u=2;break;case 2:a[s++]=r[i|c>>6],a[s++]=r[63&c],u=0}s>8191&&((o||(o=[])).push(String.fromCharCode.apply(String,a)),s=0)}return u&&(a[s++]=r[i],a[s++]=61,1===u&&(a[s++]=61)),o?(s&&o.push(String.fromCharCode.apply(String,a.slice(0,s))),o.join(\"\")):String.fromCharCode.apply(String,a.slice(0,s))};var a=\"invalid encoding\";n.decode=function(t,e,n){for(var r,o=n,s=0,u=0;u<t.length;){var c=t.charCodeAt(u++);if(61===c&&s>1)break;if(void 0===(c=i[c]))throw Error(a);switch(s){case 0:r=c,s=1;break;case 1:e[n++]=r<<2|(48&c)>>4,r=c,s=2;break;case 2:e[n++]=(15&r)<<4|(60&c)>>2,r=c,s=3;break;case 3:e[n++]=(3&r)<<6|c,s=0}}if(1===s)throw Error(a);return n-o},n.test=function(t){return/^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(t)}},9211:t=>{\"use strict\";function e(){this._listeners={}}t.exports=e,e.prototype.on=function(t,e,n){return(this._listeners[t]||(this._listeners[t]=[])).push({fn:e,ctx:n||this}),this},e.prototype.off=function(t,e){if(void 0===t)this._listeners={};else if(void 0===e)this._listeners[t]=[];else for(var n=this._listeners[t],r=0;r<n.length;)n[r].fn===e?n.splice(r,1):++r;return this},e.prototype.emit=function(t){var e=this._listeners[t];if(e){for(var n=[],r=1;r<arguments.length;)n.push(arguments[r++]);for(r=0;r<e.length;)e[r].fn.apply(e[r++].ctx,n)}return this}},945:t=>{\"use strict\";function e(t){return\"undefined\"!=typeof Float32Array?function(){var e=new Float32Array([-0]),n=new Uint8Array(e.buffer),r=128===n[3];function i(t,r,i){e[0]=t,r[i]=n[0],r[i+1]=n[1],r[i+2]=n[2],r[i+3]=n[3]}function o(t,r,i){e[0]=t,r[i]=n[3],r[i+1]=n[2],r[i+2]=n[1],r[i+3]=n[0]}function a(t,r){return n[0]=t[r],n[1]=t[r+1],n[2]=t[r+2],n[3]=t[r+3],e[0]}function s(t,r){return n[3]=t[r],n[2]=t[r+1],n[1]=t[r+2],n[0]=t[r+3],e[0]}t.writeFloatLE=r?i:o,t.writeFloatBE=r?o:i,t.readFloatLE=r?a:s,t.readFloatBE=r?s:a}():function(){function e(t,e,n,r){var i=e<0?1:0;if(i&&(e=-e),0===e)t(1/e>0?0:2147483648,n,r);else if(isNaN(e))t(2143289344,n,r);else if(e>34028234663852886e22)t((i<<31|2139095040)>>>0,n,r);else if(e<11754943508222875e-54)t((i<<31|Math.round(e/1401298464324817e-60))>>>0,n,r);else{var o=Math.floor(Math.log(e)/Math.LN2);t((i<<31|o+127<<23|8388607&Math.round(e*Math.pow(2,-o)*8388608))>>>0,n,r)}}function a(t,e,n){var r=t(e,n),i=2*(r>>31)+1,o=r>>>23&255,a=8388607&r;return 255===o?a?NaN:i*(1/0):0===o?1401298464324817e-60*i*a:i*Math.pow(2,o-150)*(a+8388608)}t.writeFloatLE=e.bind(null,n),t.writeFloatBE=e.bind(null,r),t.readFloatLE=a.bind(null,i),t.readFloatBE=a.bind(null,o)}(),\"undefined\"!=typeof Float64Array?function(){var e=new Float64Array([-0]),n=new Uint8Array(e.buffer),r=128===n[7];function i(t,r,i){e[0]=t,r[i]=n[0],r[i+1]=n[1],r[i+2]=n[2],r[i+3]=n[3],r[i+4]=n[4],r[i+5]=n[5],r[i+6]=n[6],r[i+7]=n[7]}function o(t,r,i){e[0]=t,r[i]=n[7],r[i+1]=n[6],r[i+2]=n[5],r[i+3]=n[4],r[i+4]=n[3],r[i+5]=n[2],r[i+6]=n[1],r[i+7]=n[0]}function a(t,r){return n[0]=t[r],n[1]=t[r+1],n[2]=t[r+2],n[3]=t[r+3],n[4]=t[r+4],n[5]=t[r+5],n[6]=t[r+6],n[7]=t[r+7],e[0]}function s(t,r){return n[7]=t[r],n[6]=t[r+1],n[5]=t[r+2],n[4]=t[r+3],n[3]=t[r+4],n[2]=t[r+5],n[1]=t[r+6],n[0]=t[r+7],e[0]}t.writeDoubleLE=r?i:o,t.writeDoubleBE=r?o:i,t.readDoubleLE=r?a:s,t.readDoubleBE=r?s:a}():function(){function e(t,e,n,r,i,o){var a=r<0?1:0;if(a&&(r=-r),0===r)t(0,i,o+e),t(1/r>0?0:2147483648,i,o+n);else if(isNaN(r))t(0,i,o+e),t(2146959360,i,o+n);else if(r>17976931348623157e292)t(0,i,o+e),t((a<<31|2146435072)>>>0,i,o+n);else{var s;if(r<22250738585072014e-324)t((s=r/5e-324)>>>0,i,o+e),t((a<<31|s/4294967296)>>>0,i,o+n);else{var u=Math.floor(Math.log(r)/Math.LN2);1024===u&&(u=1023),t(4503599627370496*(s=r*Math.pow(2,-u))>>>0,i,o+e),t((a<<31|u+1023<<20|1048576*s&1048575)>>>0,i,o+n)}}}function a(t,e,n,r,i){var o=t(r,i+e),a=t(r,i+n),s=2*(a>>31)+1,u=a>>>20&2047,c=4294967296*(1048575&a)+o;return 2047===u?c?NaN:s*(1/0):0===u?5e-324*s*c:s*Math.pow(2,u-1075)*(c+4503599627370496)}t.writeDoubleLE=e.bind(null,n,0,4),t.writeDoubleBE=e.bind(null,r,4,0),t.readDoubleLE=a.bind(null,i,0,4),t.readDoubleBE=a.bind(null,o,4,0)}(),t}function n(t,e,n){e[n]=255&t,e[n+1]=t>>>8&255,e[n+2]=t>>>16&255,e[n+3]=t>>>24}function r(t,e,n){e[n]=t>>>24,e[n+1]=t>>>16&255,e[n+2]=t>>>8&255,e[n+3]=255&t}function i(t,e){return(t[e]|t[e+1]<<8|t[e+2]<<16|t[e+3]<<24)>>>0}function o(t,e){return(t[e]<<24|t[e+1]<<16|t[e+2]<<8|t[e+3])>>>0}t.exports=e(e)},7199:module=>{\"use strict\";function inquire(moduleName){try{var mod=eval(\"quire\".replace(/^/,\"re\"))(moduleName);if(mod&&(mod.length||Object.keys(mod).length))return mod}catch(t){}return null}module.exports=inquire},6662:t=>{\"use strict\";t.exports=function(t,e,n){var r=n||8192,i=r>>>1,o=null,a=r;return function(n){if(n<1||n>i)return t(n);a+n>r&&(o=t(r),a=0);var s=e.call(o,a,a+=n);return 7&a&&(a=1+(7|a)),s}}},4997:(t,e)=>{\"use strict\";var n=e;n.length=function(t){for(var e=0,n=0,r=0;r<t.length;++r)(n=t.charCodeAt(r))<128?e+=1:n<2048?e+=2:55296==(64512&n)&&56320==(64512&t.charCodeAt(r+1))?(++r,e+=4):e+=3;return e},n.read=function(t,e,n){if(n-e<1)return\"\";for(var r,i=null,o=[],a=0;e<n;)(r=t[e++])<128?o[a++]=r:r>191&&r<224?o[a++]=(31&r)<<6|63&t[e++]:r>239&&r<365?(r=((7&r)<<18|(63&t[e++])<<12|(63&t[e++])<<6|63&t[e++])-65536,o[a++]=55296+(r>>10),o[a++]=56320+(1023&r)):o[a++]=(15&r)<<12|(63&t[e++])<<6|63&t[e++],a>8191&&((i||(i=[])).push(String.fromCharCode.apply(String,o)),a=0);return i?(a&&i.push(String.fromCharCode.apply(String,o.slice(0,a))),i.join(\"\")):String.fromCharCode.apply(String,o.slice(0,a))},n.write=function(t,e,n){for(var r,i,o=n,a=0;a<t.length;++a)(r=t.charCodeAt(a))<128?e[n++]=r:r<2048?(e[n++]=r>>6|192,e[n++]=63&r|128):55296==(64512&r)&&56320==(64512&(i=t.charCodeAt(a+1)))?(r=65536+((1023&r)<<10)+(1023&i),++a,e[n++]=r>>18|240,e[n++]=r>>12&63|128,e[n++]=r>>6&63|128,e[n++]=63&r|128):(e[n++]=r>>12|224,e[n++]=r>>6&63|128,e[n++]=63&r|128);return n-o}},3442:(t,e)=>{\"use strict\";e.__esModule=!0;var n=function(){function t(e){if(!e)throw new TypeError(\"Invalid argument; `value` has no value.\");this.value=t.EMPTY,e&&t.isGuid(e)&&(this.value=e)}return t.isGuid=function(e){var n=e.toString();return e&&(e instanceof t||t.validator.test(n))},t.create=function(){return new t([t.gen(2),t.gen(1),t.gen(1),t.gen(1),t.gen(3)].join(\"-\"))},t.createEmpty=function(){return new t(\"emptyguid\")},t.parse=function(e){return new t(e)},t.raw=function(){return[t.gen(2),t.gen(1),t.gen(1),t.gen(1),t.gen(3)].join(\"-\")},t.gen=function(t){for(var e=\"\",n=0;n<t;n++)e+=(65536*(1+Math.random())|0).toString(16).substring(1);return e},t.prototype.equals=function(e){return t.isGuid(e)&&this.value===e.toString()},t.prototype.isEmpty=function(){return this.value===t.EMPTY},t.prototype.toString=function(){return this.value},t.prototype.toJSON=function(){return{value:this.value}},t.validator=new RegExp(\"^[a-z0-9]{8}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{12}$\",\"i\"),t.EMPTY=\"00000000-0000-0000-0000-000000000000\",t}();e.Guid=n},3720:t=>{t.exports=n;var e=null;try{e=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch(t){}function n(t,e,n){this.low=0|t,this.high=0|e,this.unsigned=!!n}function r(t){return!0===(t&&t.__isLong__)}n.prototype.__isLong__,Object.defineProperty(n.prototype,\"__isLong__\",{value:!0}),n.isLong=r;var i={},o={};function a(t,e){var n,r,a;return e?(a=0<=(t>>>=0)&&t<256)&&(r=o[t])?r:(n=u(t,(0|t)<0?-1:0,!0),a&&(o[t]=n),n):(a=-128<=(t|=0)&&t<128)&&(r=i[t])?r:(n=u(t,t<0?-1:0,!1),a&&(i[t]=n),n)}function s(t,e){if(isNaN(t))return e?m:b;if(e){if(t<0)return m;if(t>=d)return x}else{if(t<=-h)return T;if(t+1>=h)return w}return t<0?s(-t,e).neg():u(t%f|0,t/f|0,e)}function u(t,e,r){return new n(t,e,r)}n.fromInt=a,n.fromNumber=s,n.fromBits=u;var c=Math.pow;function l(t,e,n){if(0===t.length)throw Error(\"empty string\");if(\"NaN\"===t||\"Infinity\"===t||\"+Infinity\"===t||\"-Infinity\"===t)return b;if(\"number\"==typeof e?(n=e,e=!1):e=!!e,(n=n||10)<2||36<n)throw RangeError(\"radix\");var r;if((r=t.indexOf(\"-\"))>0)throw Error(\"interior hyphen\");if(0===r)return l(t.substring(1),e,n).neg();for(var i=s(c(n,8)),o=b,a=0;a<t.length;a+=8){var u=Math.min(8,t.length-a),p=parseInt(t.substring(a,a+u),n);if(u<8){var f=s(c(n,u));o=o.mul(f).add(s(p))}else o=(o=o.mul(i)).add(s(p))}return o.unsigned=e,o}function p(t,e){return\"number\"==typeof t?s(t,e):\"string\"==typeof t?l(t,e):u(t.low,t.high,\"boolean\"==typeof e?e:t.unsigned)}n.fromString=l,n.fromValue=p;var f=4294967296,d=f*f,h=d/2,g=a(1<<24),b=a(0);n.ZERO=b;var m=a(0,!0);n.UZERO=m;var y=a(1);n.ONE=y;var _=a(1,!0);n.UONE=_;var v=a(-1);n.NEG_ONE=v;var w=u(-1,2147483647,!1);n.MAX_VALUE=w;var x=u(-1,-1,!0);n.MAX_UNSIGNED_VALUE=x;var T=u(0,-2147483648,!1);n.MIN_VALUE=T;var S=n.prototype;S.toInt=function(){return this.unsigned?this.low>>>0:this.low},S.toNumber=function(){return this.unsigned?(this.high>>>0)*f+(this.low>>>0):this.high*f+(this.low>>>0)},S.toString=function(t){if((t=t||10)<2||36<t)throw RangeError(\"radix\");if(this.isZero())return\"0\";if(this.isNegative()){if(this.eq(T)){var e=s(t),n=this.div(e),r=n.mul(e).sub(this);return n.toString(t)+r.toInt().toString(t)}return\"-\"+this.neg().toString(t)}for(var i=s(c(t,6),this.unsigned),o=this,a=\"\";;){var u=o.div(i),l=(o.sub(u.mul(i)).toInt()>>>0).toString(t);if((o=u).isZero())return l+a;for(;l.length<6;)l=\"0\"+l;a=\"\"+l+a}},S.getHighBits=function(){return this.high},S.getHighBitsUnsigned=function(){return this.high>>>0},S.getLowBits=function(){return this.low},S.getLowBitsUnsigned=function(){return this.low>>>0},S.getNumBitsAbs=function(){if(this.isNegative())return this.eq(T)?64:this.neg().getNumBitsAbs();for(var t=0!=this.high?this.high:this.low,e=31;e>0&&0==(t&1<<e);e--);return 0!=this.high?e+33:e+1},S.isZero=function(){return 0===this.high&&0===this.low},S.eqz=S.isZero,S.isNegative=function(){return!this.unsigned&&this.high<0},S.isPositive=function(){return this.unsigned||this.high>=0},S.isOdd=function(){return 1==(1&this.low)},S.isEven=function(){return 0==(1&this.low)},S.equals=function(t){return r(t)||(t=p(t)),(this.unsigned===t.unsigned||this.high>>>31!=1||t.high>>>31!=1)&&this.high===t.high&&this.low===t.low},S.eq=S.equals,S.notEquals=function(t){return!this.eq(t)},S.neq=S.notEquals,S.ne=S.notEquals,S.lessThan=function(t){return this.comp(t)<0},S.lt=S.lessThan,S.lessThanOrEqual=function(t){return this.comp(t)<=0},S.lte=S.lessThanOrEqual,S.le=S.lessThanOrEqual,S.greaterThan=function(t){return this.comp(t)>0},S.gt=S.greaterThan,S.greaterThanOrEqual=function(t){return this.comp(t)>=0},S.gte=S.greaterThanOrEqual,S.ge=S.greaterThanOrEqual,S.compare=function(t){if(r(t)||(t=p(t)),this.eq(t))return 0;var e=this.isNegative(),n=t.isNegative();return e&&!n?-1:!e&&n?1:this.unsigned?t.high>>>0>this.high>>>0||t.high===this.high&&t.low>>>0>this.low>>>0?-1:1:this.sub(t).isNegative()?-1:1},S.comp=S.compare,S.negate=function(){return!this.unsigned&&this.eq(T)?T:this.not().add(y)},S.neg=S.negate,S.add=function(t){r(t)||(t=p(t));var e=this.high>>>16,n=65535&this.high,i=this.low>>>16,o=65535&this.low,a=t.high>>>16,s=65535&t.high,c=t.low>>>16,l=0,f=0,d=0,h=0;return d+=(h+=o+(65535&t.low))>>>16,f+=(d+=i+c)>>>16,l+=(f+=n+s)>>>16,l+=e+a,u((d&=65535)<<16|(h&=65535),(l&=65535)<<16|(f&=65535),this.unsigned)},S.subtract=function(t){return r(t)||(t=p(t)),this.add(t.neg())},S.sub=S.subtract,S.multiply=function(t){if(this.isZero())return b;if(r(t)||(t=p(t)),e)return u(e.mul(this.low,this.high,t.low,t.high),e.get_high(),this.unsigned);if(t.isZero())return b;if(this.eq(T))return t.isOdd()?T:b;if(t.eq(T))return this.isOdd()?T:b;if(this.isNegative())return t.isNegative()?this.neg().mul(t.neg()):this.neg().mul(t).neg();if(t.isNegative())return this.mul(t.neg()).neg();if(this.lt(g)&&t.lt(g))return s(this.toNumber()*t.toNumber(),this.unsigned);var n=this.high>>>16,i=65535&this.high,o=this.low>>>16,a=65535&this.low,c=t.high>>>16,l=65535&t.high,f=t.low>>>16,d=65535&t.low,h=0,m=0,y=0,_=0;return y+=(_+=a*d)>>>16,m+=(y+=o*d)>>>16,y&=65535,m+=(y+=a*f)>>>16,h+=(m+=i*d)>>>16,m&=65535,h+=(m+=o*f)>>>16,m&=65535,h+=(m+=a*l)>>>16,h+=n*d+i*f+o*l+a*c,u((y&=65535)<<16|(_&=65535),(h&=65535)<<16|(m&=65535),this.unsigned)},S.mul=S.multiply,S.divide=function(t){if(r(t)||(t=p(t)),t.isZero())throw Error(\"division by zero\");var n,i,o;if(e)return this.unsigned||-2147483648!==this.high||-1!==t.low||-1!==t.high?u((this.unsigned?e.div_u:e.div_s)(this.low,this.high,t.low,t.high),e.get_high(),this.unsigned):this;if(this.isZero())return this.unsigned?m:b;if(this.unsigned){if(t.unsigned||(t=t.toUnsigned()),t.gt(this))return m;if(t.gt(this.shru(1)))return _;o=m}else{if(this.eq(T))return t.eq(y)||t.eq(v)?T:t.eq(T)?y:(n=this.shr(1).div(t).shl(1)).eq(b)?t.isNegative()?y:v:(i=this.sub(t.mul(n)),o=n.add(i.div(t)));if(t.eq(T))return this.unsigned?m:b;if(this.isNegative())return t.isNegative()?this.neg().div(t.neg()):this.neg().div(t).neg();if(t.isNegative())return this.div(t.neg()).neg();o=b}for(i=this;i.gte(t);){n=Math.max(1,Math.floor(i.toNumber()/t.toNumber()));for(var a=Math.ceil(Math.log(n)/Math.LN2),l=a<=48?1:c(2,a-48),f=s(n),d=f.mul(t);d.isNegative()||d.gt(i);)d=(f=s(n-=l,this.unsigned)).mul(t);f.isZero()&&(f=y),o=o.add(f),i=i.sub(d)}return o},S.div=S.divide,S.modulo=function(t){return r(t)||(t=p(t)),e?u((this.unsigned?e.rem_u:e.rem_s)(this.low,this.high,t.low,t.high),e.get_high(),this.unsigned):this.sub(this.div(t).mul(t))},S.mod=S.modulo,S.rem=S.modulo,S.not=function(){return u(~this.low,~this.high,this.unsigned)},S.and=function(t){return r(t)||(t=p(t)),u(this.low&t.low,this.high&t.high,this.unsigned)},S.or=function(t){return r(t)||(t=p(t)),u(this.low|t.low,this.high|t.high,this.unsigned)},S.xor=function(t){return r(t)||(t=p(t)),u(this.low^t.low,this.high^t.high,this.unsigned)},S.shiftLeft=function(t){return r(t)&&(t=t.toInt()),0==(t&=63)?this:t<32?u(this.low<<t,this.high<<t|this.low>>>32-t,this.unsigned):u(0,this.low<<t-32,this.unsigned)},S.shl=S.shiftLeft,S.shiftRight=function(t){return r(t)&&(t=t.toInt()),0==(t&=63)?this:t<32?u(this.low>>>t|this.high<<32-t,this.high>>t,this.unsigned):u(this.high>>t-32,this.high>=0?0:-1,this.unsigned)},S.shr=S.shiftRight,S.shiftRightUnsigned=function(t){if(r(t)&&(t=t.toInt()),0==(t&=63))return this;var e=this.high;return t<32?u(this.low>>>t|e<<32-t,e>>>t,this.unsigned):u(32===t?e:e>>>t-32,0,this.unsigned)},S.shru=S.shiftRightUnsigned,S.shr_u=S.shiftRightUnsigned,S.toSigned=function(){return this.unsigned?u(this.low,this.high,!1):this},S.toUnsigned=function(){return this.unsigned?this:u(this.low,this.high,!0)},S.toBytes=function(t){return t?this.toBytesLE():this.toBytesBE()},S.toBytesLE=function(){var t=this.high,e=this.low;return[255&e,e>>>8&255,e>>>16&255,e>>>24,255&t,t>>>8&255,t>>>16&255,t>>>24]},S.toBytesBE=function(){var t=this.high,e=this.low;return[t>>>24,t>>>16&255,t>>>8&255,255&t,e>>>24,e>>>16&255,e>>>8&255,255&e]},n.fromBytes=function(t,e,r){return r?n.fromBytesLE(t,e):n.fromBytesBE(t,e)},n.fromBytesLE=function(t,e){return new n(t[0]|t[1]<<8|t[2]<<16|t[3]<<24,t[4]|t[5]<<8|t[6]<<16|t[7]<<24,e)},n.fromBytesBE=function(t,e){return new n(t[4]<<24|t[5]<<16|t[6]<<8|t[7],t[0]<<24|t[1]<<16|t[2]<<8|t[3],e)}},1446:(t,e,n)=>{\"use strict\";var r,i,o,a=n(2100),s=a.Reader,u=a.Writer,c=a.util,l=a.roots.default||(a.roots.default={});l.onnx=((o={}).Version=(r={},(i=Object.create(r))[r[0]=\"_START_VERSION\"]=0,i[r[1]=\"IR_VERSION_2017_10_10\"]=1,i[r[2]=\"IR_VERSION_2017_10_30\"]=2,i[r[3]=\"IR_VERSION_2017_11_3\"]=3,i[r[4]=\"IR_VERSION_2019_1_22\"]=4,i[r[5]=\"IR_VERSION\"]=5,i),o.AttributeProto=function(){function t(t){if(this.floats=[],this.ints=[],this.strings=[],this.tensors=[],this.graphs=[],t)for(var e=Object.keys(t),n=0;n<e.length;++n)null!=t[e[n]]&&(this[e[n]]=t[e[n]])}return t.prototype.name=\"\",t.prototype.refAttrName=\"\",t.prototype.docString=\"\",t.prototype.type=0,t.prototype.f=0,t.prototype.i=c.Long?c.Long.fromBits(0,0,!1):0,t.prototype.s=c.newBuffer([]),t.prototype.t=null,t.prototype.g=null,t.prototype.floats=c.emptyArray,t.prototype.ints=c.emptyArray,t.prototype.strings=c.emptyArray,t.prototype.tensors=c.emptyArray,t.prototype.graphs=c.emptyArray,t.create=function(e){return new t(e)},t.encode=function(t,e){if(e||(e=u.create()),null!=t.name&&t.hasOwnProperty(\"name\")&&e.uint32(10).string(t.name),null!=t.f&&t.hasOwnProperty(\"f\")&&e.uint32(21).float(t.f),null!=t.i&&t.hasOwnProperty(\"i\")&&e.uint32(24).int64(t.i),null!=t.s&&t.hasOwnProperty(\"s\")&&e.uint32(34).bytes(t.s),null!=t.t&&t.hasOwnProperty(\"t\")&&l.onnx.TensorProto.encode(t.t,e.uint32(42).fork()).ldelim(),null!=t.g&&t.hasOwnProperty(\"g\")&&l.onnx.GraphProto.encode(t.g,e.uint32(50).fork()).ldelim(),null!=t.floats&&t.floats.length){e.uint32(58).fork();for(var n=0;n<t.floats.length;++n)e.float(t.floats[n]);e.ldelim()}if(null!=t.ints&&t.ints.length){for(e.uint32(66).fork(),n=0;n<t.ints.length;++n)e.int64(t.ints[n]);e.ldelim()}if(null!=t.strings&&t.strings.length)for(n=0;n<t.strings.length;++n)e.uint32(74).bytes(t.strings[n]);if(null!=t.tensors&&t.tensors.length)for(n=0;n<t.tensors.length;++n)l.onnx.TensorProto.encode(t.tensors[n],e.uint32(82).fork()).ldelim();if(null!=t.graphs&&t.graphs.length)for(n=0;n<t.graphs.length;++n)l.onnx.GraphProto.encode(t.graphs[n],e.uint32(90).fork()).ldelim();return null!=t.docString&&t.hasOwnProperty(\"docString\")&&e.uint32(106).string(t.docString),null!=t.type&&t.hasOwnProperty(\"type\")&&e.uint32(160).int32(t.type),null!=t.refAttrName&&t.hasOwnProperty(\"refAttrName\")&&e.uint32(170).string(t.refAttrName),e},t.encodeDelimited=function(t,e){return this.encode(t,e).ldelim()},t.decode=function(t,e){t instanceof s||(t=s.create(t));for(var n=void 0===e?t.len:t.pos+e,r=new l.onnx.AttributeProto;t.pos<n;){var i=t.uint32();switch(i>>>3){case 1:r.name=t.string();break;case 21:r.refAttrName=t.string();break;case 13:r.docString=t.string();break;case 20:r.type=t.int32();break;case 2:r.f=t.float();break;case 3:r.i=t.int64();break;case 4:r.s=t.bytes();break;case 5:r.t=l.onnx.TensorProto.decode(t,t.uint32());break;case 6:r.g=l.onnx.GraphProto.decode(t,t.uint32());break;case 7:if(r.floats&&r.floats.length||(r.floats=[]),2==(7&i))for(var o=t.uint32()+t.pos;t.pos<o;)r.floats.push(t.float());else r.floats.push(t.float());break;case 8:if(r.ints&&r.ints.length||(r.ints=[]),2==(7&i))for(o=t.uint32()+t.pos;t.pos<o;)r.ints.push(t.int64());else r.ints.push(t.int64());break;case 9:r.strings&&r.strings.length||(r.strings=[]),r.strings.push(t.bytes());break;case 10:r.tensors&&r.tensors.length||(r.tensors=[]),r.tensors.push(l.onnx.TensorProto.decode(t,t.uint32()));break;case 11:r.graphs&&r.graphs.length||(r.graphs=[]),r.graphs.push(l.onnx.GraphProto.decode(t,t.uint32()));break;default:t.skipType(7&i)}}return r},t.decodeDelimited=function(t){return t instanceof s||(t=new s(t)),this.decode(t,t.uint32())},t.verify=function(t){if(\"object\"!=typeof t||null===t)return\"object expected\";if(null!=t.name&&t.hasOwnProperty(\"name\")&&!c.isString(t.name))return\"name: string expected\";if(null!=t.refAttrName&&t.hasOwnProperty(\"refAttrName\")&&!c.isString(t.refAttrName))return\"refAttrName: string expected\";if(null!=t.docString&&t.hasOwnProperty(\"docString\")&&!c.isString(t.docString))return\"docString: string expected\";if(null!=t.type&&t.hasOwnProperty(\"type\"))switch(t.type){default:return\"type: enum value expected\";case 0:case 1:case 2:case 3:case 4:case 5:case 6:case 7:case 8:case 9:case 10:}if(null!=t.f&&t.hasOwnProperty(\"f\")&&\"number\"!=typeof t.f)return\"f: number expected\";if(null!=t.i&&t.hasOwnProperty(\"i\")&&!(c.isInteger(t.i)||t.i&&c.isInteger(t.i.low)&&c.isInteger(t.i.high)))return\"i: integer|Long expected\";if(null!=t.s&&t.hasOwnProperty(\"s\")&&!(t.s&&\"number\"==typeof t.s.length||c.isString(t.s)))return\"s: buffer expected\";if(null!=t.t&&t.hasOwnProperty(\"t\")&&(n=l.onnx.TensorProto.verify(t.t)))return\"t.\"+n;if(null!=t.g&&t.hasOwnProperty(\"g\")&&(n=l.onnx.GraphProto.verify(t.g)))return\"g.\"+n;if(null!=t.floats&&t.hasOwnProperty(\"floats\")){if(!Array.isArray(t.floats))return\"floats: array expected\";for(var e=0;e<t.floats.length;++e)if(\"number\"!=typeof t.floats[e])return\"floats: number[] expected\"}if(null!=t.ints&&t.hasOwnProperty(\"ints\")){if(!Array.isArray(t.ints))return\"ints: array expected\";for(e=0;e<t.ints.length;++e)if(!(c.isInteger(t.ints[e])||t.ints[e]&&c.isInteger(t.ints[e].low)&&c.isInteger(t.ints[e].high)))return\"ints: integer|Long[] expected\"}if(null!=t.strings&&t.hasOwnProperty(\"strings\")){if(!Array.isArray(t.strings))return\"strings: array expected\";for(e=0;e<t.strings.length;++e)if(!(t.strings[e]&&\"number\"==typeof t.strings[e].length||c.isString(t.strings[e])))return\"strings: buffer[] expected\"}if(null!=t.tensors&&t.hasOwnProperty(\"tensors\")){if(!Array.isArray(t.tensors))return\"tensors: array expected\";for(e=0;e<t.tensors.length;++e)if(n=l.onnx.TensorProto.verify(t.tensors[e]))return\"tensors.\"+n}if(null!=t.graphs&&t.hasOwnProperty(\"graphs\")){if(!Array.isArray(t.graphs))return\"graphs: array expected\";for(e=0;e<t.graphs.length;++e){var n;if(n=l.onnx.GraphProto.verify(t.graphs[e]))return\"graphs.\"+n}}return null},t.fromObject=function(t){if(t instanceof l.onnx.AttributeProto)return t;var e=new l.onnx.AttributeProto;switch(null!=t.name&&(e.name=String(t.name)),null!=t.refAttrName&&(e.refAttrName=String(t.refAttrName)),null!=t.docString&&(e.docString=String(t.docString)),t.type){case\"UNDEFINED\":case 0:e.type=0;break;case\"FLOAT\":case 1:e.type=1;break;case\"INT\":case 2:e.type=2;break;case\"STRING\":case 3:e.type=3;break;case\"TENSOR\":case 4:e.type=4;break;case\"GRAPH\":case 5:e.type=5;break;case\"FLOATS\":case 6:e.type=6;break;case\"INTS\":case 7:e.type=7;break;case\"STRINGS\":case 8:e.type=8;break;case\"TENSORS\":case 9:e.type=9;break;case\"GRAPHS\":case 10:e.type=10}if(null!=t.f&&(e.f=Number(t.f)),null!=t.i&&(c.Long?(e.i=c.Long.fromValue(t.i)).unsigned=!1:\"string\"==typeof t.i?e.i=parseInt(t.i,10):\"number\"==typeof t.i?e.i=t.i:\"object\"==typeof t.i&&(e.i=new c.LongBits(t.i.low>>>0,t.i.high>>>0).toNumber())),null!=t.s&&(\"string\"==typeof t.s?c.base64.decode(t.s,e.s=c.newBuffer(c.base64.length(t.s)),0):t.s.length&&(e.s=t.s)),null!=t.t){if(\"object\"!=typeof t.t)throw TypeError(\".onnx.AttributeProto.t: object expected\");e.t=l.onnx.TensorProto.fromObject(t.t)}if(null!=t.g){if(\"object\"!=typeof t.g)throw TypeError(\".onnx.AttributeProto.g: object expected\");e.g=l.onnx.GraphProto.fromObject(t.g)}if(t.floats){if(!Array.isArray(t.floats))throw TypeError(\".onnx.AttributeProto.floats: array expected\");e.floats=[];for(var n=0;n<t.floats.length;++n)e.floats[n]=Number(t.floats[n])}if(t.ints){if(!Array.isArray(t.ints))throw TypeError(\".onnx.AttributeProto.ints: array expected\");for(e.ints=[],n=0;n<t.ints.length;++n)c.Long?(e.ints[n]=c.Long.fromValue(t.ints[n])).unsigned=!1:\"string\"==typeof t.ints[n]?e.ints[n]=parseInt(t.ints[n],10):\"number\"==typeof t.ints[n]?e.ints[n]=t.ints[n]:\"object\"==typeof t.ints[n]&&(e.ints[n]=new c.LongBits(t.ints[n].low>>>0,t.ints[n].high>>>0).toNumber())}if(t.strings){if(!Array.isArray(t.strings))throw TypeError(\".onnx.AttributeProto.strings: array expected\");for(e.strings=[],n=0;n<t.strings.length;++n)\"string\"==typeof t.strings[n]?c.base64.decode(t.strings[n],e.strings[n]=c.newBuffer(c.base64.length(t.strings[n])),0):t.strings[n].length&&(e.strings[n]=t.strings[n])}if(t.tensors){if(!Array.isArray(t.tensors))throw TypeError(\".onnx.AttributeProto.tensors: array expected\");for(e.tensors=[],n=0;n<t.tensors.length;++n){if(\"object\"!=typeof t.tensors[n])throw TypeError(\".onnx.AttributeProto.tensors: object expected\");e.tensors[n]=l.onnx.TensorProto.fromObject(t.tensors[n])}}if(t.graphs){if(!Array.isArray(t.graphs))throw TypeError(\".onnx.AttributeProto.graphs: array expected\");for(e.graphs=[],n=0;n<t.graphs.length;++n){if(\"object\"!=typeof t.graphs[n])throw TypeError(\".onnx.AttributeProto.graphs: object expected\");e.graphs[n]=l.onnx.GraphProto.fromObject(t.graphs[n])}}return e},t.toObject=function(t,e){e||(e={});var n={};if((e.arrays||e.defaults)&&(n.floats=[],n.ints=[],n.strings=[],n.tensors=[],n.graphs=[]),e.defaults){if(n.name=\"\",n.f=0,c.Long){var r=new c.Long(0,0,!1);n.i=e.longs===String?r.toString():e.longs===Number?r.toNumber():r}else n.i=e.longs===String?\"0\":0;e.bytes===String?n.s=\"\":(n.s=[],e.bytes!==Array&&(n.s=c.newBuffer(n.s))),n.t=null,n.g=null,n.docString=\"\",n.type=e.enums===String?\"UNDEFINED\":0,n.refAttrName=\"\"}if(null!=t.name&&t.hasOwnProperty(\"name\")&&(n.name=t.name),null!=t.f&&t.hasOwnProperty(\"f\")&&(n.f=e.json&&!isFinite(t.f)?String(t.f):t.f),null!=t.i&&t.hasOwnProperty(\"i\")&&(\"number\"==typeof t.i?n.i=e.longs===String?String(t.i):t.i:n.i=e.longs===String?c.Long.prototype.toString.call(t.i):e.longs===Number?new c.LongBits(t.i.low>>>0,t.i.high>>>0).toNumber():t.i),null!=t.s&&t.hasOwnProperty(\"s\")&&(n.s=e.bytes===String?c.base64.encode(t.s,0,t.s.length):e.bytes===Array?Array.prototype.slice.call(t.s):t.s),null!=t.t&&t.hasOwnProperty(\"t\")&&(n.t=l.onnx.TensorProto.toObject(t.t,e)),null!=t.g&&t.hasOwnProperty(\"g\")&&(n.g=l.onnx.GraphProto.toObject(t.g,e)),t.floats&&t.floats.length){n.floats=[];for(var i=0;i<t.floats.length;++i)n.floats[i]=e.json&&!isFinite(t.floats[i])?String(t.floats[i]):t.floats[i]}if(t.ints&&t.ints.length)for(n.ints=[],i=0;i<t.ints.length;++i)\"number\"==typeof t.ints[i]?n.ints[i]=e.longs===String?String(t.ints[i]):t.ints[i]:n.ints[i]=e.longs===String?c.Long.prototype.toString.call(t.ints[i]):e.longs===Number?new c.LongBits(t.ints[i].low>>>0,t.ints[i].high>>>0).toNumber():t.ints[i];if(t.strings&&t.strings.length)for(n.strings=[],i=0;i<t.strings.length;++i)n.strings[i]=e.bytes===String?c.base64.encode(t.strings[i],0,t.strings[i].length):e.bytes===Array?Array.prototype.slice.call(t.strings[i]):t.strings[i];if(t.tensors&&t.tensors.length)for(n.tensors=[],i=0;i<t.tensors.length;++i)n.tensors[i]=l.onnx.TensorProto.toObject(t.tensors[i],e);if(t.graphs&&t.graphs.length)for(n.graphs=[],i=0;i<t.graphs.length;++i)n.graphs[i]=l.onnx.GraphProto.toObject(t.graphs[i],e);return null!=t.docString&&t.hasOwnProperty(\"docString\")&&(n.docString=t.docString),null!=t.type&&t.hasOwnProperty(\"type\")&&(n.type=e.enums===String?l.onnx.AttributeProto.AttributeType[t.type]:t.type),null!=t.refAttrName&&t.hasOwnProperty(\"refAttrName\")&&(n.refAttrName=t.refAttrName),n},t.prototype.toJSON=function(){return this.constructor.toObject(this,a.util.toJSONOptions)},t.AttributeType=function(){var t={},e=Object.create(t);return e[t[0]=\"UNDEFINED\"]=0,e[t[1]=\"FLOAT\"]=1,e[t[2]=\"INT\"]=2,e[t[3]=\"STRING\"]=3,e[t[4]=\"TENSOR\"]=4,e[t[5]=\"GRAPH\"]=5,e[t[6]=\"FLOATS\"]=6,e[t[7]=\"INTS\"]=7,e[t[8]=\"STRINGS\"]=8,e[t[9]=\"TENSORS\"]=9,e[t[10]=\"GRAPHS\"]=10,e}(),t}(),o.ValueInfoProto=function(){function t(t){if(t)for(var e=Object.keys(t),n=0;n<e.length;++n)null!=t[e[n]]&&(this[e[n]]=t[e[n]])}return t.prototype.name=\"\",t.prototype.type=null,t.prototype.docString=\"\",t.create=function(e){return new t(e)},t.encode=function(t,e){return e||(e=u.create()),null!=t.name&&t.hasOwnProperty(\"name\")&&e.uint32(10).string(t.name),null!=t.type&&t.hasOwnProperty(\"type\")&&l.onnx.TypeProto.encode(t.type,e.uint32(18).fork()).ldelim(),null!=t.docString&&t.hasOwnProperty(\"docString\")&&e.uint32(26).string(t.docString),e},t.encodeDelimited=function(t,e){return this.encode(t,e).ldelim()},t.decode=function(t,e){t instanceof s||(t=s.create(t));for(var n=void 0===e?t.len:t.pos+e,r=new l.onnx.ValueInfoProto;t.pos<n;){var i=t.uint32();switch(i>>>3){case 1:r.name=t.string();break;case 2:r.type=l.onnx.TypeProto.decode(t,t.uint32());break;case 3:r.docString=t.string();break;default:t.skipType(7&i)}}return r},t.decodeDelimited=function(t){return t instanceof s||(t=new s(t)),this.decode(t,t.uint32())},t.verify=function(t){if(\"object\"!=typeof t||null===t)return\"object expected\";if(null!=t.name&&t.hasOwnProperty(\"name\")&&!c.isString(t.name))return\"name: string expected\";if(null!=t.type&&t.hasOwnProperty(\"type\")){var e=l.onnx.TypeProto.verify(t.type);if(e)return\"type.\"+e}return null!=t.docString&&t.hasOwnProperty(\"docString\")&&!c.isString(t.docString)?\"docString: string expected\":null},t.fromObject=function(t){if(t instanceof l.onnx.ValueInfoProto)return t;var e=new l.onnx.ValueInfoProto;if(null!=t.name&&(e.name=String(t.name)),null!=t.type){if(\"object\"!=typeof t.type)throw TypeError(\".onnx.ValueInfoProto.type: object expected\");e.type=l.onnx.TypeProto.fromObject(t.type)}return null!=t.docString&&(e.docString=String(t.docString)),e},t.toObject=function(t,e){e||(e={});var n={};return e.defaults&&(n.name=\"\",n.type=null,n.docString=\"\"),null!=t.name&&t.hasOwnProperty(\"name\")&&(n.name=t.name),null!=t.type&&t.hasOwnProperty(\"type\")&&(n.type=l.onnx.TypeProto.toObject(t.type,e)),null!=t.docString&&t.hasOwnProperty(\"docString\")&&(n.docString=t.docString),n},t.prototype.toJSON=function(){return this.constructor.toObject(this,a.util.toJSONOptions)},t}(),o.NodeProto=function(){function t(t){if(this.input=[],this.output=[],this.attribute=[],t)for(var e=Object.keys(t),n=0;n<e.length;++n)null!=t[e[n]]&&(this[e[n]]=t[e[n]])}return t.prototype.input=c.emptyArray,t.prototype.output=c.emptyArray,t.prototype.name=\"\",t.prototype.opType=\"\",t.prototype.domain=\"\",t.prototype.attribute=c.emptyArray,t.prototype.docString=\"\",t.create=function(e){return new t(e)},t.encode=function(t,e){if(e||(e=u.create()),null!=t.input&&t.input.length)for(var n=0;n<t.input.length;++n)e.uint32(10).string(t.input[n]);if(null!=t.output&&t.output.length)for(n=0;n<t.output.length;++n)e.uint32(18).string(t.output[n]);if(null!=t.name&&t.hasOwnProperty(\"name\")&&e.uint32(26).string(t.name),null!=t.opType&&t.hasOwnProperty(\"opType\")&&e.uint32(34).string(t.opType),null!=t.attribute&&t.attribute.length)for(n=0;n<t.attribute.length;++n)l.onnx.AttributeProto.encode(t.attribute[n],e.uint32(42).fork()).ldelim();return null!=t.docString&&t.hasOwnProperty(\"docString\")&&e.uint32(50).string(t.docString),null!=t.domain&&t.hasOwnProperty(\"domain\")&&e.uint32(58).string(t.domain),e},t.encodeDelimited=function(t,e){return this.encode(t,e).ldelim()},t.decode=function(t,e){t instanceof s||(t=s.create(t));for(var n=void 0===e?t.len:t.pos+e,r=new l.onnx.NodeProto;t.pos<n;){var i=t.uint32();switch(i>>>3){case 1:r.input&&r.input.length||(r.input=[]),r.input.push(t.string());break;case 2:r.output&&r.output.length||(r.output=[]),r.output.push(t.string());break;case 3:r.name=t.string();break;case 4:r.opType=t.string();break;case 7:r.domain=t.string();break;case 5:r.attribute&&r.attribute.length||(r.attribute=[]),r.attribute.push(l.onnx.AttributeProto.decode(t,t.uint32()));break;case 6:r.docString=t.string();break;default:t.skipType(7&i)}}return r},t.decodeDelimited=function(t){return t instanceof s||(t=new s(t)),this.decode(t,t.uint32())},t.verify=function(t){if(\"object\"!=typeof t||null===t)return\"object expected\";if(null!=t.input&&t.hasOwnProperty(\"input\")){if(!Array.isArray(t.input))return\"input: array expected\";for(var e=0;e<t.input.length;++e)if(!c.isString(t.input[e]))return\"input: string[] expected\"}if(null!=t.output&&t.hasOwnProperty(\"output\")){if(!Array.isArray(t.output))return\"output: array expected\";for(e=0;e<t.output.length;++e)if(!c.isString(t.output[e]))return\"output: string[] expected\"}if(null!=t.name&&t.hasOwnProperty(\"name\")&&!c.isString(t.name))return\"name: string expected\";if(null!=t.opType&&t.hasOwnProperty(\"opType\")&&!c.isString(t.opType))return\"opType: string expected\";if(null!=t.domain&&t.hasOwnProperty(\"domain\")&&!c.isString(t.domain))return\"domain: string expected\";if(null!=t.attribute&&t.hasOwnProperty(\"attribute\")){if(!Array.isArray(t.attribute))return\"attribute: array expected\";for(e=0;e<t.attribute.length;++e){var n=l.onnx.AttributeProto.verify(t.attribute[e]);if(n)return\"attribute.\"+n}}return null!=t.docString&&t.hasOwnProperty(\"docString\")&&!c.isString(t.docString)?\"docString: string expected\":null},t.fromObject=function(t){if(t instanceof l.onnx.NodeProto)return t;var e=new l.onnx.NodeProto;if(t.input){if(!Array.isArray(t.input))throw TypeError(\".onnx.NodeProto.input: array expected\");e.input=[];for(var n=0;n<t.input.length;++n)e.input[n]=String(t.input[n])}if(t.output){if(!Array.isArray(t.output))throw TypeError(\".onnx.NodeProto.output: array expected\");for(e.output=[],n=0;n<t.output.length;++n)e.output[n]=String(t.output[n])}if(null!=t.name&&(e.name=String(t.name)),null!=t.opType&&(e.opType=String(t.opType)),null!=t.domain&&(e.domain=String(t.domain)),t.attribute){if(!Array.isArray(t.attribute))throw TypeError(\".onnx.NodeProto.attribute: array expected\");for(e.attribute=[],n=0;n<t.attribute.length;++n){if(\"object\"!=typeof t.attribute[n])throw TypeError(\".onnx.NodeProto.attribute: object expected\");e.attribute[n]=l.onnx.AttributeProto.fromObject(t.attribute[n])}}return null!=t.docString&&(e.docString=String(t.docString)),e},t.toObject=function(t,e){e||(e={});var n={};if((e.arrays||e.defaults)&&(n.input=[],n.output=[],n.attribute=[]),e.defaults&&(n.name=\"\",n.opType=\"\",n.docString=\"\",n.domain=\"\"),t.input&&t.input.length){n.input=[];for(var r=0;r<t.input.length;++r)n.input[r]=t.input[r]}if(t.output&&t.output.length)for(n.output=[],r=0;r<t.output.length;++r)n.output[r]=t.output[r];if(null!=t.name&&t.hasOwnProperty(\"name\")&&(n.name=t.name),null!=t.opType&&t.hasOwnProperty(\"opType\")&&(n.opType=t.opType),t.attribute&&t.attribute.length)for(n.attribute=[],r=0;r<t.attribute.length;++r)n.attribute[r]=l.onnx.AttributeProto.toObject(t.attribute[r],e);return null!=t.docString&&t.hasOwnProperty(\"docString\")&&(n.docString=t.docString),null!=t.domain&&t.hasOwnProperty(\"domain\")&&(n.domain=t.domain),n},t.prototype.toJSON=function(){return this.constructor.toObject(this,a.util.toJSONOptions)},t}(),o.ModelProto=function(){function t(t){if(this.opsetImport=[],this.metadataProps=[],t)for(var e=Object.keys(t),n=0;n<e.length;++n)null!=t[e[n]]&&(this[e[n]]=t[e[n]])}return t.prototype.irVersion=c.Long?c.Long.fromBits(0,0,!1):0,t.prototype.opsetImport=c.emptyArray,t.prototype.producerName=\"\",t.prototype.producerVersion=\"\",t.prototype.domain=\"\",t.prototype.modelVersion=c.Long?c.Long.fromBits(0,0,!1):0,t.prototype.docString=\"\",t.prototype.graph=null,t.prototype.metadataProps=c.emptyArray,t.create=function(e){return new t(e)},t.encode=function(t,e){if(e||(e=u.create()),null!=t.irVersion&&t.hasOwnProperty(\"irVersion\")&&e.uint32(8).int64(t.irVersion),null!=t.producerName&&t.hasOwnProperty(\"producerName\")&&e.uint32(18).string(t.producerName),null!=t.producerVersion&&t.hasOwnProperty(\"producerVersion\")&&e.uint32(26).string(t.producerVersion),null!=t.domain&&t.hasOwnProperty(\"domain\")&&e.uint32(34).string(t.domain),null!=t.modelVersion&&t.hasOwnProperty(\"modelVersion\")&&e.uint32(40).int64(t.modelVersion),null!=t.docString&&t.hasOwnProperty(\"docString\")&&e.uint32(50).string(t.docString),null!=t.graph&&t.hasOwnProperty(\"graph\")&&l.onnx.GraphProto.encode(t.graph,e.uint32(58).fork()).ldelim(),null!=t.opsetImport&&t.opsetImport.length)for(var n=0;n<t.opsetImport.length;++n)l.onnx.OperatorSetIdProto.encode(t.opsetImport[n],e.uint32(66).fork()).ldelim();if(null!=t.metadataProps&&t.metadataProps.length)for(n=0;n<t.metadataProps.length;++n)l.onnx.StringStringEntryProto.encode(t.metadataProps[n],e.uint32(114).fork()).ldelim();return e},t.encodeDelimited=function(t,e){return this.encode(t,e).ldelim()},t.decode=function(t,e){t instanceof s||(t=s.create(t));for(var n=void 0===e?t.len:t.pos+e,r=new l.onnx.ModelProto;t.pos<n;){var i=t.uint32();switch(i>>>3){case 1:r.irVersion=t.int64();break;case 8:r.opsetImport&&r.opsetImport.length||(r.opsetImport=[]),r.opsetImport.push(l.onnx.OperatorSetIdProto.decode(t,t.uint32()));break;case 2:r.producerName=t.string();break;case 3:r.producerVersion=t.string();break;case 4:r.domain=t.string();break;case 5:r.modelVersion=t.int64();break;case 6:r.docString=t.string();break;case 7:r.graph=l.onnx.GraphProto.decode(t,t.uint32());break;case 14:r.metadataProps&&r.metadataProps.length||(r.metadataProps=[]),r.metadataProps.push(l.onnx.StringStringEntryProto.decode(t,t.uint32()));break;default:t.skipType(7&i)}}return r},t.decodeDelimited=function(t){return t instanceof s||(t=new s(t)),this.decode(t,t.uint32())},t.verify=function(t){if(\"object\"!=typeof t||null===t)return\"object expected\";if(null!=t.irVersion&&t.hasOwnProperty(\"irVersion\")&&!(c.isInteger(t.irVersion)||t.irVersion&&c.isInteger(t.irVersion.low)&&c.isInteger(t.irVersion.high)))return\"irVersion: integer|Long expected\";if(null!=t.opsetImport&&t.hasOwnProperty(\"opsetImport\")){if(!Array.isArray(t.opsetImport))return\"opsetImport: array expected\";for(var e=0;e<t.opsetImport.length;++e)if(n=l.onnx.OperatorSetIdProto.verify(t.opsetImport[e]))return\"opsetImport.\"+n}if(null!=t.producerName&&t.hasOwnProperty(\"producerName\")&&!c.isString(t.producerName))return\"producerName: string expected\";if(null!=t.producerVersion&&t.hasOwnProperty(\"producerVersion\")&&!c.isString(t.producerVersion))return\"producerVersion: string expected\";if(null!=t.domain&&t.hasOwnProperty(\"domain\")&&!c.isString(t.domain))return\"domain: string expected\";if(null!=t.modelVersion&&t.hasOwnProperty(\"modelVersion\")&&!(c.isInteger(t.modelVersion)||t.modelVersion&&c.isInteger(t.modelVersion.low)&&c.isInteger(t.modelVersion.high)))return\"modelVersion: integer|Long expected\";if(null!=t.docString&&t.hasOwnProperty(\"docString\")&&!c.isString(t.docString))return\"docString: string expected\";if(null!=t.graph&&t.hasOwnProperty(\"graph\")&&(n=l.onnx.GraphProto.verify(t.graph)))return\"graph.\"+n;if(null!=t.metadataProps&&t.hasOwnProperty(\"metadataProps\")){if(!Array.isArray(t.metadataProps))return\"metadataProps: array expected\";for(e=0;e<t.metadataProps.length;++e){var n;if(n=l.onnx.StringStringEntryProto.verify(t.metadataProps[e]))return\"metadataProps.\"+n}}return null},t.fromObject=function(t){if(t instanceof l.onnx.ModelProto)return t;var e=new l.onnx.ModelProto;if(null!=t.irVersion&&(c.Long?(e.irVersion=c.Long.fromValue(t.irVersion)).unsigned=!1:\"string\"==typeof t.irVersion?e.irVersion=parseInt(t.irVersion,10):\"number\"==typeof t.irVersion?e.irVersion=t.irVersion:\"object\"==typeof t.irVersion&&(e.irVersion=new c.LongBits(t.irVersion.low>>>0,t.irVersion.high>>>0).toNumber())),t.opsetImport){if(!Array.isArray(t.opsetImport))throw TypeError(\".onnx.ModelProto.opsetImport: array expected\");e.opsetImport=[];for(var n=0;n<t.opsetImport.length;++n){if(\"object\"!=typeof t.opsetImport[n])throw TypeError(\".onnx.ModelProto.opsetImport: object expected\");e.opsetImport[n]=l.onnx.OperatorSetIdProto.fromObject(t.opsetImport[n])}}if(null!=t.producerName&&(e.producerName=String(t.producerName)),null!=t.producerVersion&&(e.producerVersion=String(t.producerVersion)),null!=t.domain&&(e.domain=String(t.domain)),null!=t.modelVersion&&(c.Long?(e.modelVersion=c.Long.fromValue(t.modelVersion)).unsigned=!1:\"string\"==typeof t.modelVersion?e.modelVersion=parseInt(t.modelVersion,10):\"number\"==typeof t.modelVersion?e.modelVersion=t.modelVersion:\"object\"==typeof t.modelVersion&&(e.modelVersion=new c.LongBits(t.modelVersion.low>>>0,t.modelVersion.high>>>0).toNumber())),null!=t.docString&&(e.docString=String(t.docString)),null!=t.graph){if(\"object\"!=typeof t.graph)throw TypeError(\".onnx.ModelProto.graph: object expected\");e.graph=l.onnx.GraphProto.fromObject(t.graph)}if(t.metadataProps){if(!Array.isArray(t.metadataProps))throw TypeError(\".onnx.ModelProto.metadataProps: array expected\");for(e.metadataProps=[],n=0;n<t.metadataProps.length;++n){if(\"object\"!=typeof t.metadataProps[n])throw TypeError(\".onnx.ModelProto.metadataProps: object expected\");e.metadataProps[n]=l.onnx.StringStringEntryProto.fromObject(t.metadataProps[n])}}return e},t.toObject=function(t,e){e||(e={});var n={};if((e.arrays||e.defaults)&&(n.opsetImport=[],n.metadataProps=[]),e.defaults){if(c.Long){var r=new c.Long(0,0,!1);n.irVersion=e.longs===String?r.toString():e.longs===Number?r.toNumber():r}else n.irVersion=e.longs===String?\"0\":0;n.producerName=\"\",n.producerVersion=\"\",n.domain=\"\",c.Long?(r=new c.Long(0,0,!1),n.modelVersion=e.longs===String?r.toString():e.longs===Number?r.toNumber():r):n.modelVersion=e.longs===String?\"0\":0,n.docString=\"\",n.graph=null}if(null!=t.irVersion&&t.hasOwnProperty(\"irVersion\")&&(\"number\"==typeof t.irVersion?n.irVersion=e.longs===String?String(t.irVersion):t.irVersion:n.irVersion=e.longs===String?c.Long.prototype.toString.call(t.irVersion):e.longs===Number?new c.LongBits(t.irVersion.low>>>0,t.irVersion.high>>>0).toNumber():t.irVersion),null!=t.producerName&&t.hasOwnProperty(\"producerName\")&&(n.producerName=t.producerName),null!=t.producerVersion&&t.hasOwnProperty(\"producerVersion\")&&(n.producerVersion=t.producerVersion),null!=t.domain&&t.hasOwnProperty(\"domain\")&&(n.domain=t.domain),null!=t.modelVersion&&t.hasOwnProperty(\"modelVersion\")&&(\"number\"==typeof t.modelVersion?n.modelVersion=e.longs===String?String(t.modelVersion):t.modelVersion:n.modelVersion=e.longs===String?c.Long.prototype.toString.call(t.modelVersion):e.longs===Number?new c.LongBits(t.modelVersion.low>>>0,t.modelVersion.high>>>0).toNumber():t.modelVersion),null!=t.docString&&t.hasOwnProperty(\"docString\")&&(n.docString=t.docString),null!=t.graph&&t.hasOwnProperty(\"graph\")&&(n.graph=l.onnx.GraphProto.toObject(t.graph,e)),t.opsetImport&&t.opsetImport.length){n.opsetImport=[];for(var i=0;i<t.opsetImport.length;++i)n.opsetImport[i]=l.onnx.OperatorSetIdProto.toObject(t.opsetImport[i],e)}if(t.metadataProps&&t.metadataProps.length)for(n.metadataProps=[],i=0;i<t.metadataProps.length;++i)n.metadataProps[i]=l.onnx.StringStringEntryProto.toObject(t.metadataProps[i],e);return n},t.prototype.toJSON=function(){return this.constructor.toObject(this,a.util.toJSONOptions)},t}(),o.StringStringEntryProto=function(){function t(t){if(t)for(var e=Object.keys(t),n=0;n<e.length;++n)null!=t[e[n]]&&(this[e[n]]=t[e[n]])}return t.prototype.key=\"\",t.prototype.value=\"\",t.create=function(e){return new t(e)},t.encode=function(t,e){return e||(e=u.create()),null!=t.key&&t.hasOwnProperty(\"key\")&&e.uint32(10).string(t.key),null!=t.value&&t.hasOwnProperty(\"value\")&&e.uint32(18).string(t.value),e},t.encodeDelimited=function(t,e){return this.encode(t,e).ldelim()},t.decode=function(t,e){t instanceof s||(t=s.create(t));for(var n=void 0===e?t.len:t.pos+e,r=new l.onnx.StringStringEntryProto;t.pos<n;){var i=t.uint32();switch(i>>>3){case 1:r.key=t.string();break;case 2:r.value=t.string();break;default:t.skipType(7&i)}}return r},t.decodeDelimited=function(t){return t instanceof s||(t=new s(t)),this.decode(t,t.uint32())},t.verify=function(t){return\"object\"!=typeof t||null===t?\"object expected\":null!=t.key&&t.hasOwnProperty(\"key\")&&!c.isString(t.key)?\"key: string expected\":null!=t.value&&t.hasOwnProperty(\"value\")&&!c.isString(t.value)?\"value: string expected\":null},t.fromObject=function(t){if(t instanceof l.onnx.StringStringEntryProto)return t;var e=new l.onnx.StringStringEntryProto;return null!=t.key&&(e.key=String(t.key)),null!=t.value&&(e.value=String(t.value)),e},t.toObject=function(t,e){e||(e={});var n={};return e.defaults&&(n.key=\"\",n.value=\"\"),null!=t.key&&t.hasOwnProperty(\"key\")&&(n.key=t.key),null!=t.value&&t.hasOwnProperty(\"value\")&&(n.value=t.value),n},t.prototype.toJSON=function(){return this.constructor.toObject(this,a.util.toJSONOptions)},t}(),o.TensorAnnotation=function(){function t(t){if(this.quantParameterTensorNames=[],t)for(var e=Object.keys(t),n=0;n<e.length;++n)null!=t[e[n]]&&(this[e[n]]=t[e[n]])}return t.prototype.tensorName=\"\",t.prototype.quantParameterTensorNames=c.emptyArray,t.create=function(e){return new t(e)},t.encode=function(t,e){if(e||(e=u.create()),null!=t.tensorName&&t.hasOwnProperty(\"tensorName\")&&e.uint32(10).string(t.tensorName),null!=t.quantParameterTensorNames&&t.quantParameterTensorNames.length)for(var n=0;n<t.quantParameterTensorNames.length;++n)l.onnx.StringStringEntryProto.encode(t.quantParameterTensorNames[n],e.uint32(18).fork()).ldelim();return e},t.encodeDelimited=function(t,e){return this.encode(t,e).ldelim()},t.decode=function(t,e){t instanceof s||(t=s.create(t));for(var n=void 0===e?t.len:t.pos+e,r=new l.onnx.TensorAnnotation;t.pos<n;){var i=t.uint32();switch(i>>>3){case 1:r.tensorName=t.string();break;case 2:r.quantParameterTensorNames&&r.quantParameterTensorNames.length||(r.quantParameterTensorNames=[]),r.quantParameterTensorNames.push(l.onnx.StringStringEntryProto.decode(t,t.uint32()));break;default:t.skipType(7&i)}}return r},t.decodeDelimited=function(t){return t instanceof s||(t=new s(t)),this.decode(t,t.uint32())},t.verify=function(t){if(\"object\"!=typeof t||null===t)return\"object expected\";if(null!=t.tensorName&&t.hasOwnProperty(\"tensorName\")&&!c.isString(t.tensorName))return\"tensorName: string expected\";if(null!=t.quantParameterTensorNames&&t.hasOwnProperty(\"quantParameterTensorNames\")){if(!Array.isArray(t.quantParameterTensorNames))return\"quantParameterTensorNames: array expected\";for(var e=0;e<t.quantParameterTensorNames.length;++e){var n=l.onnx.StringStringEntryProto.verify(t.quantParameterTensorNames[e]);if(n)return\"quantParameterTensorNames.\"+n}}return null},t.fromObject=function(t){if(t instanceof l.onnx.TensorAnnotation)return t;var e=new l.onnx.TensorAnnotation;if(null!=t.tensorName&&(e.tensorName=String(t.tensorName)),t.quantParameterTensorNames){if(!Array.isArray(t.quantParameterTensorNames))throw TypeError(\".onnx.TensorAnnotation.quantParameterTensorNames: array expected\");e.quantParameterTensorNames=[];for(var n=0;n<t.quantParameterTensorNames.length;++n){if(\"object\"!=typeof t.quantParameterTensorNames[n])throw TypeError(\".onnx.TensorAnnotation.quantParameterTensorNames: object expected\");e.quantParameterTensorNames[n]=l.onnx.StringStringEntryProto.fromObject(t.quantParameterTensorNames[n])}}return e},t.toObject=function(t,e){e||(e={});var n={};if((e.arrays||e.defaults)&&(n.quantParameterTensorNames=[]),e.defaults&&(n.tensorName=\"\"),null!=t.tensorName&&t.hasOwnProperty(\"tensorName\")&&(n.tensorName=t.tensorName),t.quantParameterTensorNames&&t.quantParameterTensorNames.length){n.quantParameterTensorNames=[];for(var r=0;r<t.quantParameterTensorNames.length;++r)n.quantParameterTensorNames[r]=l.onnx.StringStringEntryProto.toObject(t.quantParameterTensorNames[r],e)}return n},t.prototype.toJSON=function(){return this.constructor.toObject(this,a.util.toJSONOptions)},t}(),o.GraphProto=function(){function t(t){if(this.node=[],this.initializer=[],this.input=[],this.output=[],this.valueInfo=[],this.quantizationAnnotation=[],t)for(var e=Object.keys(t),n=0;n<e.length;++n)null!=t[e[n]]&&(this[e[n]]=t[e[n]])}return t.prototype.node=c.emptyArray,t.prototype.name=\"\",t.prototype.initializer=c.emptyArray,t.prototype.docString=\"\",t.prototype.input=c.emptyArray,t.prototype.output=c.emptyArray,t.prototype.valueInfo=c.emptyArray,t.prototype.quantizationAnnotation=c.emptyArray,t.create=function(e){return new t(e)},t.encode=function(t,e){if(e||(e=u.create()),null!=t.node&&t.node.length)for(var n=0;n<t.node.length;++n)l.onnx.NodeProto.encode(t.node[n],e.uint32(10).fork()).ldelim();if(null!=t.name&&t.hasOwnProperty(\"name\")&&e.uint32(18).string(t.name),null!=t.initializer&&t.initializer.length)for(n=0;n<t.initializer.length;++n)l.onnx.TensorProto.encode(t.initializer[n],e.uint32(42).fork()).ldelim();if(null!=t.docString&&t.hasOwnProperty(\"docString\")&&e.uint32(82).string(t.docString),null!=t.input&&t.input.length)for(n=0;n<t.input.length;++n)l.onnx.ValueInfoProto.encode(t.input[n],e.uint32(90).fork()).ldelim();if(null!=t.output&&t.output.length)for(n=0;n<t.output.length;++n)l.onnx.ValueInfoProto.encode(t.output[n],e.uint32(98).fork()).ldelim();if(null!=t.valueInfo&&t.valueInfo.length)for(n=0;n<t.valueInfo.length;++n)l.onnx.ValueInfoProto.encode(t.valueInfo[n],e.uint32(106).fork()).ldelim();if(null!=t.quantizationAnnotation&&t.quantizationAnnotation.length)for(n=0;n<t.quantizationAnnotation.length;++n)l.onnx.TensorAnnotation.encode(t.quantizationAnnotation[n],e.uint32(114).fork()).ldelim();return e},t.encodeDelimited=function(t,e){return this.encode(t,e).ldelim()},t.decode=function(t,e){t instanceof s||(t=s.create(t));for(var n=void 0===e?t.len:t.pos+e,r=new l.onnx.GraphProto;t.pos<n;){var i=t.uint32();switch(i>>>3){case 1:r.node&&r.node.length||(r.node=[]),r.node.push(l.onnx.NodeProto.decode(t,t.uint32()));break;case 2:r.name=t.string();break;case 5:r.initializer&&r.initializer.length||(r.initializer=[]),r.initializer.push(l.onnx.TensorProto.decode(t,t.uint32()));break;case 10:r.docString=t.string();break;case 11:r.input&&r.input.length||(r.input=[]),r.input.push(l.onnx.ValueInfoProto.decode(t,t.uint32()));break;case 12:r.output&&r.output.length||(r.output=[]),r.output.push(l.onnx.ValueInfoProto.decode(t,t.uint32()));break;case 13:r.valueInfo&&r.valueInfo.length||(r.valueInfo=[]),r.valueInfo.push(l.onnx.ValueInfoProto.decode(t,t.uint32()));break;case 14:r.quantizationAnnotation&&r.quantizationAnnotation.length||(r.quantizationAnnotation=[]),r.quantizationAnnotation.push(l.onnx.TensorAnnotation.decode(t,t.uint32()));break;default:t.skipType(7&i)}}return r},t.decodeDelimited=function(t){return t instanceof s||(t=new s(t)),this.decode(t,t.uint32())},t.verify=function(t){if(\"object\"!=typeof t||null===t)return\"object expected\";if(null!=t.node&&t.hasOwnProperty(\"node\")){if(!Array.isArray(t.node))return\"node: array expected\";for(var e=0;e<t.node.length;++e)if(n=l.onnx.NodeProto.verify(t.node[e]))return\"node.\"+n}if(null!=t.name&&t.hasOwnProperty(\"name\")&&!c.isString(t.name))return\"name: string expected\";if(null!=t.initializer&&t.hasOwnProperty(\"initializer\")){if(!Array.isArray(t.initializer))return\"initializer: array expected\";for(e=0;e<t.initializer.length;++e)if(n=l.onnx.TensorProto.verify(t.initializer[e]))return\"initializer.\"+n}if(null!=t.docString&&t.hasOwnProperty(\"docString\")&&!c.isString(t.docString))return\"docString: string expected\";if(null!=t.input&&t.hasOwnProperty(\"input\")){if(!Array.isArray(t.input))return\"input: array expected\";for(e=0;e<t.input.length;++e)if(n=l.onnx.ValueInfoProto.verify(t.input[e]))return\"input.\"+n}if(null!=t.output&&t.hasOwnProperty(\"output\")){if(!Array.isArray(t.output))return\"output: array expected\";for(e=0;e<t.output.length;++e)if(n=l.onnx.ValueInfoProto.verify(t.output[e]))return\"output.\"+n}if(null!=t.valueInfo&&t.hasOwnProperty(\"valueInfo\")){if(!Array.isArray(t.valueInfo))return\"valueInfo: array expected\";for(e=0;e<t.valueInfo.length;++e)if(n=l.onnx.ValueInfoProto.verify(t.valueInfo[e]))return\"valueInfo.\"+n}if(null!=t.quantizationAnnotation&&t.hasOwnProperty(\"quantizationAnnotation\")){if(!Array.isArray(t.quantizationAnnotation))return\"quantizationAnnotation: array expected\";for(e=0;e<t.quantizationAnnotation.length;++e){var n;if(n=l.onnx.TensorAnnotation.verify(t.quantizationAnnotation[e]))return\"quantizationAnnotation.\"+n}}return null},t.fromObject=function(t){if(t instanceof l.onnx.GraphProto)return t;var e=new l.onnx.GraphProto;if(t.node){if(!Array.isArray(t.node))throw TypeError(\".onnx.GraphProto.node: array expected\");e.node=[];for(var n=0;n<t.node.length;++n){if(\"object\"!=typeof t.node[n])throw TypeError(\".onnx.GraphProto.node: object expected\");e.node[n]=l.onnx.NodeProto.fromObject(t.node[n])}}if(null!=t.name&&(e.name=String(t.name)),t.initializer){if(!Array.isArray(t.initializer))throw TypeError(\".onnx.GraphProto.initializer: array expected\");for(e.initializer=[],n=0;n<t.initializer.length;++n){if(\"object\"!=typeof t.initializer[n])throw TypeError(\".onnx.GraphProto.initializer: object expected\");e.initializer[n]=l.onnx.TensorProto.fromObject(t.initializer[n])}}if(null!=t.docString&&(e.docString=String(t.docString)),t.input){if(!Array.isArray(t.input))throw TypeError(\".onnx.GraphProto.input: array expected\");for(e.input=[],n=0;n<t.input.length;++n){if(\"object\"!=typeof t.input[n])throw TypeError(\".onnx.GraphProto.input: object expected\");e.input[n]=l.onnx.ValueInfoProto.fromObject(t.input[n])}}if(t.output){if(!Array.isArray(t.output))throw TypeError(\".onnx.GraphProto.output: array expected\");for(e.output=[],n=0;n<t.output.length;++n){if(\"object\"!=typeof t.output[n])throw TypeError(\".onnx.GraphProto.output: object expected\");e.output[n]=l.onnx.ValueInfoProto.fromObject(t.output[n])}}if(t.valueInfo){if(!Array.isArray(t.valueInfo))throw TypeError(\".onnx.GraphProto.valueInfo: array expected\");for(e.valueInfo=[],n=0;n<t.valueInfo.length;++n){if(\"object\"!=typeof t.valueInfo[n])throw TypeError(\".onnx.GraphProto.valueInfo: object expected\");e.valueInfo[n]=l.onnx.ValueInfoProto.fromObject(t.valueInfo[n])}}if(t.quantizationAnnotation){if(!Array.isArray(t.quantizationAnnotation))throw TypeError(\".onnx.GraphProto.quantizationAnnotation: array expected\");for(e.quantizationAnnotation=[],n=0;n<t.quantizationAnnotation.length;++n){if(\"object\"!=typeof t.quantizationAnnotation[n])throw TypeError(\".onnx.GraphProto.quantizationAnnotation: object expected\");e.quantizationAnnotation[n]=l.onnx.TensorAnnotation.fromObject(t.quantizationAnnotation[n])}}return e},t.toObject=function(t,e){e||(e={});var n={};if((e.arrays||e.defaults)&&(n.node=[],n.initializer=[],n.input=[],n.output=[],n.valueInfo=[],n.quantizationAnnotation=[]),e.defaults&&(n.name=\"\",n.docString=\"\"),t.node&&t.node.length){n.node=[];for(var r=0;r<t.node.length;++r)n.node[r]=l.onnx.NodeProto.toObject(t.node[r],e)}if(null!=t.name&&t.hasOwnProperty(\"name\")&&(n.name=t.name),t.initializer&&t.initializer.length)for(n.initializer=[],r=0;r<t.initializer.length;++r)n.initializer[r]=l.onnx.TensorProto.toObject(t.initializer[r],e);if(null!=t.docString&&t.hasOwnProperty(\"docString\")&&(n.docString=t.docString),t.input&&t.input.length)for(n.input=[],r=0;r<t.input.length;++r)n.input[r]=l.onnx.ValueInfoProto.toObject(t.input[r],e);if(t.output&&t.output.length)for(n.output=[],r=0;r<t.output.length;++r)n.output[r]=l.onnx.ValueInfoProto.toObject(t.output[r],e);if(t.valueInfo&&t.valueInfo.length)for(n.valueInfo=[],r=0;r<t.valueInfo.length;++r)n.valueInfo[r]=l.onnx.ValueInfoProto.toObject(t.valueInfo[r],e);if(t.quantizationAnnotation&&t.quantizationAnnotation.length)for(n.quantizationAnnotation=[],r=0;r<t.quantizationAnnotation.length;++r)n.quantizationAnnotation[r]=l.onnx.TensorAnnotation.toObject(t.quantizationAnnotation[r],e);return n},t.prototype.toJSON=function(){return this.constructor.toObject(this,a.util.toJSONOptions)},t}(),o.TensorProto=function(){function t(t){if(this.dims=[],this.floatData=[],this.int32Data=[],this.stringData=[],this.int64Data=[],this.externalData=[],this.doubleData=[],this.uint64Data=[],t)for(var e=Object.keys(t),n=0;n<e.length;++n)null!=t[e[n]]&&(this[e[n]]=t[e[n]])}return t.prototype.dims=c.emptyArray,t.prototype.dataType=0,t.prototype.segment=null,t.prototype.floatData=c.emptyArray,t.prototype.int32Data=c.emptyArray,t.prototype.stringData=c.emptyArray,t.prototype.int64Data=c.emptyArray,t.prototype.name=\"\",t.prototype.docString=\"\",t.prototype.rawData=c.newBuffer([]),t.prototype.externalData=c.emptyArray,t.prototype.dataLocation=0,t.prototype.doubleData=c.emptyArray,t.prototype.uint64Data=c.emptyArray,t.create=function(e){return new t(e)},t.encode=function(t,e){if(e||(e=u.create()),null!=t.dims&&t.dims.length){e.uint32(10).fork();for(var n=0;n<t.dims.length;++n)e.int64(t.dims[n]);e.ldelim()}if(null!=t.dataType&&t.hasOwnProperty(\"dataType\")&&e.uint32(16).int32(t.dataType),null!=t.segment&&t.hasOwnProperty(\"segment\")&&l.onnx.TensorProto.Segment.encode(t.segment,e.uint32(26).fork()).ldelim(),null!=t.floatData&&t.floatData.length){for(e.uint32(34).fork(),n=0;n<t.floatData.length;++n)e.float(t.floatData[n]);e.ldelim()}if(null!=t.int32Data&&t.int32Data.length){for(e.uint32(42).fork(),n=0;n<t.int32Data.length;++n)e.int32(t.int32Data[n]);e.ldelim()}if(null!=t.stringData&&t.stringData.length)for(n=0;n<t.stringData.length;++n)e.uint32(50).bytes(t.stringData[n]);if(null!=t.int64Data&&t.int64Data.length){for(e.uint32(58).fork(),n=0;n<t.int64Data.length;++n)e.int64(t.int64Data[n]);e.ldelim()}if(null!=t.name&&t.hasOwnProperty(\"name\")&&e.uint32(66).string(t.name),null!=t.rawData&&t.hasOwnProperty(\"rawData\")&&e.uint32(74).bytes(t.rawData),null!=t.doubleData&&t.doubleData.length){for(e.uint32(82).fork(),n=0;n<t.doubleData.length;++n)e.double(t.doubleData[n]);e.ldelim()}if(null!=t.uint64Data&&t.uint64Data.length){for(e.uint32(90).fork(),n=0;n<t.uint64Data.length;++n)e.uint64(t.uint64Data[n]);e.ldelim()}if(null!=t.docString&&t.hasOwnProperty(\"docString\")&&e.uint32(98).string(t.docString),null!=t.externalData&&t.externalData.length)for(n=0;n<t.externalData.length;++n)l.onnx.StringStringEntryProto.encode(t.externalData[n],e.uint32(106).fork()).ldelim();return null!=t.dataLocation&&t.hasOwnProperty(\"dataLocation\")&&e.uint32(112).int32(t.dataLocation),e},t.encodeDelimited=function(t,e){return this.encode(t,e).ldelim()},t.decode=function(t,e){t instanceof s||(t=s.create(t));for(var n=void 0===e?t.len:t.pos+e,r=new l.onnx.TensorProto;t.pos<n;){var i=t.uint32();switch(i>>>3){case 1:if(r.dims&&r.dims.length||(r.dims=[]),2==(7&i))for(var o=t.uint32()+t.pos;t.pos<o;)r.dims.push(t.int64());else r.dims.push(t.int64());break;case 2:r.dataType=t.int32();break;case 3:r.segment=l.onnx.TensorProto.Segment.decode(t,t.uint32());break;case 4:if(r.floatData&&r.floatData.length||(r.floatData=[]),2==(7&i))for(o=t.uint32()+t.pos;t.pos<o;)r.floatData.push(t.float());else r.floatData.push(t.float());break;case 5:if(r.int32Data&&r.int32Data.length||(r.int32Data=[]),2==(7&i))for(o=t.uint32()+t.pos;t.pos<o;)r.int32Data.push(t.int32());else r.int32Data.push(t.int32());break;case 6:r.stringData&&r.stringData.length||(r.stringData=[]),r.stringData.push(t.bytes());break;case 7:if(r.int64Data&&r.int64Data.length||(r.int64Data=[]),2==(7&i))for(o=t.uint32()+t.pos;t.pos<o;)r.int64Data.push(t.int64());else r.int64Data.push(t.int64());break;case 8:r.name=t.string();break;case 12:r.docString=t.string();break;case 9:r.rawData=t.bytes();break;case 13:r.externalData&&r.externalData.length||(r.externalData=[]),r.externalData.push(l.onnx.StringStringEntryProto.decode(t,t.uint32()));break;case 14:r.dataLocation=t.int32();break;case 10:if(r.doubleData&&r.doubleData.length||(r.doubleData=[]),2==(7&i))for(o=t.uint32()+t.pos;t.pos<o;)r.doubleData.push(t.double());else r.doubleData.push(t.double());break;case 11:if(r.uint64Data&&r.uint64Data.length||(r.uint64Data=[]),2==(7&i))for(o=t.uint32()+t.pos;t.pos<o;)r.uint64Data.push(t.uint64());else r.uint64Data.push(t.uint64());break;default:t.skipType(7&i)}}return r},t.decodeDelimited=function(t){return t instanceof s||(t=new s(t)),this.decode(t,t.uint32())},t.verify=function(t){if(\"object\"!=typeof t||null===t)return\"object expected\";if(null!=t.dims&&t.hasOwnProperty(\"dims\")){if(!Array.isArray(t.dims))return\"dims: array expected\";for(var e=0;e<t.dims.length;++e)if(!(c.isInteger(t.dims[e])||t.dims[e]&&c.isInteger(t.dims[e].low)&&c.isInteger(t.dims[e].high)))return\"dims: integer|Long[] expected\"}if(null!=t.dataType&&t.hasOwnProperty(\"dataType\")&&!c.isInteger(t.dataType))return\"dataType: integer expected\";if(null!=t.segment&&t.hasOwnProperty(\"segment\")&&(n=l.onnx.TensorProto.Segment.verify(t.segment)))return\"segment.\"+n;if(null!=t.floatData&&t.hasOwnProperty(\"floatData\")){if(!Array.isArray(t.floatData))return\"floatData: array expected\";for(e=0;e<t.floatData.length;++e)if(\"number\"!=typeof t.floatData[e])return\"floatData: number[] expected\"}if(null!=t.int32Data&&t.hasOwnProperty(\"int32Data\")){if(!Array.isArray(t.int32Data))return\"int32Data: array expected\";for(e=0;e<t.int32Data.length;++e)if(!c.isInteger(t.int32Data[e]))return\"int32Data: integer[] expected\"}if(null!=t.stringData&&t.hasOwnProperty(\"stringData\")){if(!Array.isArray(t.stringData))return\"stringData: array expected\";for(e=0;e<t.stringData.length;++e)if(!(t.stringData[e]&&\"number\"==typeof t.stringData[e].length||c.isString(t.stringData[e])))return\"stringData: buffer[] expected\"}if(null!=t.int64Data&&t.hasOwnProperty(\"int64Data\")){if(!Array.isArray(t.int64Data))return\"int64Data: array expected\";for(e=0;e<t.int64Data.length;++e)if(!(c.isInteger(t.int64Data[e])||t.int64Data[e]&&c.isInteger(t.int64Data[e].low)&&c.isInteger(t.int64Data[e].high)))return\"int64Data: integer|Long[] expected\"}if(null!=t.name&&t.hasOwnProperty(\"name\")&&!c.isString(t.name))return\"name: string expected\";if(null!=t.docString&&t.hasOwnProperty(\"docString\")&&!c.isString(t.docString))return\"docString: string expected\";if(null!=t.rawData&&t.hasOwnProperty(\"rawData\")&&!(t.rawData&&\"number\"==typeof t.rawData.length||c.isString(t.rawData)))return\"rawData: buffer expected\";if(null!=t.externalData&&t.hasOwnProperty(\"externalData\")){if(!Array.isArray(t.externalData))return\"externalData: array expected\";for(e=0;e<t.externalData.length;++e){var n;if(n=l.onnx.StringStringEntryProto.verify(t.externalData[e]))return\"externalData.\"+n}}if(null!=t.dataLocation&&t.hasOwnProperty(\"dataLocation\"))switch(t.dataLocation){default:return\"dataLocation: enum value expected\";case 0:case 1:}if(null!=t.doubleData&&t.hasOwnProperty(\"doubleData\")){if(!Array.isArray(t.doubleData))return\"doubleData: array expected\";for(e=0;e<t.doubleData.length;++e)if(\"number\"!=typeof t.doubleData[e])return\"doubleData: number[] expected\"}if(null!=t.uint64Data&&t.hasOwnProperty(\"uint64Data\")){if(!Array.isArray(t.uint64Data))return\"uint64Data: array expected\";for(e=0;e<t.uint64Data.length;++e)if(!(c.isInteger(t.uint64Data[e])||t.uint64Data[e]&&c.isInteger(t.uint64Data[e].low)&&c.isInteger(t.uint64Data[e].high)))return\"uint64Data: integer|Long[] expected\"}return null},t.fromObject=function(t){if(t instanceof l.onnx.TensorProto)return t;var e=new l.onnx.TensorProto;if(t.dims){if(!Array.isArray(t.dims))throw TypeError(\".onnx.TensorProto.dims: array expected\");e.dims=[];for(var n=0;n<t.dims.length;++n)c.Long?(e.dims[n]=c.Long.fromValue(t.dims[n])).unsigned=!1:\"string\"==typeof t.dims[n]?e.dims[n]=parseInt(t.dims[n],10):\"number\"==typeof t.dims[n]?e.dims[n]=t.dims[n]:\"object\"==typeof t.dims[n]&&(e.dims[n]=new c.LongBits(t.dims[n].low>>>0,t.dims[n].high>>>0).toNumber())}if(null!=t.dataType&&(e.dataType=0|t.dataType),null!=t.segment){if(\"object\"!=typeof t.segment)throw TypeError(\".onnx.TensorProto.segment: object expected\");e.segment=l.onnx.TensorProto.Segment.fromObject(t.segment)}if(t.floatData){if(!Array.isArray(t.floatData))throw TypeError(\".onnx.TensorProto.floatData: array expected\");for(e.floatData=[],n=0;n<t.floatData.length;++n)e.floatData[n]=Number(t.floatData[n])}if(t.int32Data){if(!Array.isArray(t.int32Data))throw TypeError(\".onnx.TensorProto.int32Data: array expected\");for(e.int32Data=[],n=0;n<t.int32Data.length;++n)e.int32Data[n]=0|t.int32Data[n]}if(t.stringData){if(!Array.isArray(t.stringData))throw TypeError(\".onnx.TensorProto.stringData: array expected\");for(e.stringData=[],n=0;n<t.stringData.length;++n)\"string\"==typeof t.stringData[n]?c.base64.decode(t.stringData[n],e.stringData[n]=c.newBuffer(c.base64.length(t.stringData[n])),0):t.stringData[n].length&&(e.stringData[n]=t.stringData[n])}if(t.int64Data){if(!Array.isArray(t.int64Data))throw TypeError(\".onnx.TensorProto.int64Data: array expected\");for(e.int64Data=[],n=0;n<t.int64Data.length;++n)c.Long?(e.int64Data[n]=c.Long.fromValue(t.int64Data[n])).unsigned=!1:\"string\"==typeof t.int64Data[n]?e.int64Data[n]=parseInt(t.int64Data[n],10):\"number\"==typeof t.int64Data[n]?e.int64Data[n]=t.int64Data[n]:\"object\"==typeof t.int64Data[n]&&(e.int64Data[n]=new c.LongBits(t.int64Data[n].low>>>0,t.int64Data[n].high>>>0).toNumber())}if(null!=t.name&&(e.name=String(t.name)),null!=t.docString&&(e.docString=String(t.docString)),null!=t.rawData&&(\"string\"==typeof t.rawData?c.base64.decode(t.rawData,e.rawData=c.newBuffer(c.base64.length(t.rawData)),0):t.rawData.length&&(e.rawData=t.rawData)),t.externalData){if(!Array.isArray(t.externalData))throw TypeError(\".onnx.TensorProto.externalData: array expected\");for(e.externalData=[],n=0;n<t.externalData.length;++n){if(\"object\"!=typeof t.externalData[n])throw TypeError(\".onnx.TensorProto.externalData: object expected\");e.externalData[n]=l.onnx.StringStringEntryProto.fromObject(t.externalData[n])}}switch(t.dataLocation){case\"DEFAULT\":case 0:e.dataLocation=0;break;case\"EXTERNAL\":case 1:e.dataLocation=1}if(t.doubleData){if(!Array.isArray(t.doubleData))throw TypeError(\".onnx.TensorProto.doubleData: array expected\");for(e.doubleData=[],n=0;n<t.doubleData.length;++n)e.doubleData[n]=Number(t.doubleData[n])}if(t.uint64Data){if(!Array.isArray(t.uint64Data))throw TypeError(\".onnx.TensorProto.uint64Data: array expected\");for(e.uint64Data=[],n=0;n<t.uint64Data.length;++n)c.Long?(e.uint64Data[n]=c.Long.fromValue(t.uint64Data[n])).unsigned=!0:\"string\"==typeof t.uint64Data[n]?e.uint64Data[n]=parseInt(t.uint64Data[n],10):\"number\"==typeof t.uint64Data[n]?e.uint64Data[n]=t.uint64Data[n]:\"object\"==typeof t.uint64Data[n]&&(e.uint64Data[n]=new c.LongBits(t.uint64Data[n].low>>>0,t.uint64Data[n].high>>>0).toNumber(!0))}return e},t.toObject=function(t,e){e||(e={});var n={};if((e.arrays||e.defaults)&&(n.dims=[],n.floatData=[],n.int32Data=[],n.stringData=[],n.int64Data=[],n.doubleData=[],n.uint64Data=[],n.externalData=[]),e.defaults&&(n.dataType=0,n.segment=null,n.name=\"\",e.bytes===String?n.rawData=\"\":(n.rawData=[],e.bytes!==Array&&(n.rawData=c.newBuffer(n.rawData))),n.docString=\"\",n.dataLocation=e.enums===String?\"DEFAULT\":0),t.dims&&t.dims.length){n.dims=[];for(var r=0;r<t.dims.length;++r)\"number\"==typeof t.dims[r]?n.dims[r]=e.longs===String?String(t.dims[r]):t.dims[r]:n.dims[r]=e.longs===String?c.Long.prototype.toString.call(t.dims[r]):e.longs===Number?new c.LongBits(t.dims[r].low>>>0,t.dims[r].high>>>0).toNumber():t.dims[r]}if(null!=t.dataType&&t.hasOwnProperty(\"dataType\")&&(n.dataType=t.dataType),null!=t.segment&&t.hasOwnProperty(\"segment\")&&(n.segment=l.onnx.TensorProto.Segment.toObject(t.segment,e)),t.floatData&&t.floatData.length)for(n.floatData=[],r=0;r<t.floatData.length;++r)n.floatData[r]=e.json&&!isFinite(t.floatData[r])?String(t.floatData[r]):t.floatData[r];if(t.int32Data&&t.int32Data.length)for(n.int32Data=[],r=0;r<t.int32Data.length;++r)n.int32Data[r]=t.int32Data[r];if(t.stringData&&t.stringData.length)for(n.stringData=[],r=0;r<t.stringData.length;++r)n.stringData[r]=e.bytes===String?c.base64.encode(t.stringData[r],0,t.stringData[r].length):e.bytes===Array?Array.prototype.slice.call(t.stringData[r]):t.stringData[r];if(t.int64Data&&t.int64Data.length)for(n.int64Data=[],r=0;r<t.int64Data.length;++r)\"number\"==typeof t.int64Data[r]?n.int64Data[r]=e.longs===String?String(t.int64Data[r]):t.int64Data[r]:n.int64Data[r]=e.longs===String?c.Long.prototype.toString.call(t.int64Data[r]):e.longs===Number?new c.LongBits(t.int64Data[r].low>>>0,t.int64Data[r].high>>>0).toNumber():t.int64Data[r];if(null!=t.name&&t.hasOwnProperty(\"name\")&&(n.name=t.name),null!=t.rawData&&t.hasOwnProperty(\"rawData\")&&(n.rawData=e.bytes===String?c.base64.encode(t.rawData,0,t.rawData.length):e.bytes===Array?Array.prototype.slice.call(t.rawData):t.rawData),t.doubleData&&t.doubleData.length)for(n.doubleData=[],r=0;r<t.doubleData.length;++r)n.doubleData[r]=e.json&&!isFinite(t.doubleData[r])?String(t.doubleData[r]):t.doubleData[r];if(t.uint64Data&&t.uint64Data.length)for(n.uint64Data=[],r=0;r<t.uint64Data.length;++r)\"number\"==typeof t.uint64Data[r]?n.uint64Data[r]=e.longs===String?String(t.uint64Data[r]):t.uint64Data[r]:n.uint64Data[r]=e.longs===String?c.Long.prototype.toString.call(t.uint64Data[r]):e.longs===Number?new c.LongBits(t.uint64Data[r].low>>>0,t.uint64Data[r].high>>>0).toNumber(!0):t.uint64Data[r];if(null!=t.docString&&t.hasOwnProperty(\"docString\")&&(n.docString=t.docString),t.externalData&&t.externalData.length)for(n.externalData=[],r=0;r<t.externalData.length;++r)n.externalData[r]=l.onnx.StringStringEntryProto.toObject(t.externalData[r],e);return null!=t.dataLocation&&t.hasOwnProperty(\"dataLocation\")&&(n.dataLocation=e.enums===String?l.onnx.TensorProto.DataLocation[t.dataLocation]:t.dataLocation),n},t.prototype.toJSON=function(){return this.constructor.toObject(this,a.util.toJSONOptions)},t.DataType=function(){var t={},e=Object.create(t);return e[t[0]=\"UNDEFINED\"]=0,e[t[1]=\"FLOAT\"]=1,e[t[2]=\"UINT8\"]=2,e[t[3]=\"INT8\"]=3,e[t[4]=\"UINT16\"]=4,e[t[5]=\"INT16\"]=5,e[t[6]=\"INT32\"]=6,e[t[7]=\"INT64\"]=7,e[t[8]=\"STRING\"]=8,e[t[9]=\"BOOL\"]=9,e[t[10]=\"FLOAT16\"]=10,e[t[11]=\"DOUBLE\"]=11,e[t[12]=\"UINT32\"]=12,e[t[13]=\"UINT64\"]=13,e[t[14]=\"COMPLEX64\"]=14,e[t[15]=\"COMPLEX128\"]=15,e[t[16]=\"BFLOAT16\"]=16,e}(),t.Segment=function(){function t(t){if(t)for(var e=Object.keys(t),n=0;n<e.length;++n)null!=t[e[n]]&&(this[e[n]]=t[e[n]])}return t.prototype.begin=c.Long?c.Long.fromBits(0,0,!1):0,t.prototype.end=c.Long?c.Long.fromBits(0,0,!1):0,t.create=function(e){return new t(e)},t.encode=function(t,e){return e||(e=u.create()),null!=t.begin&&t.hasOwnProperty(\"begin\")&&e.uint32(8).int64(t.begin),null!=t.end&&t.hasOwnProperty(\"end\")&&e.uint32(16).int64(t.end),e},t.encodeDelimited=function(t,e){return this.encode(t,e).ldelim()},t.decode=function(t,e){t instanceof s||(t=s.create(t));for(var n=void 0===e?t.len:t.pos+e,r=new l.onnx.TensorProto.Segment;t.pos<n;){var i=t.uint32();switch(i>>>3){case 1:r.begin=t.int64();break;case 2:r.end=t.int64();break;default:t.skipType(7&i)}}return r},t.decodeDelimited=function(t){return t instanceof s||(t=new s(t)),this.decode(t,t.uint32())},t.verify=function(t){return\"object\"!=typeof t||null===t?\"object expected\":null!=t.begin&&t.hasOwnProperty(\"begin\")&&!(c.isInteger(t.begin)||t.begin&&c.isInteger(t.begin.low)&&c.isInteger(t.begin.high))?\"begin: integer|Long expected\":null!=t.end&&t.hasOwnProperty(\"end\")&&!(c.isInteger(t.end)||t.end&&c.isInteger(t.end.low)&&c.isInteger(t.end.high))?\"end: integer|Long expected\":null},t.fromObject=function(t){if(t instanceof l.onnx.TensorProto.Segment)return t;var e=new l.onnx.TensorProto.Segment;return null!=t.begin&&(c.Long?(e.begin=c.Long.fromValue(t.begin)).unsigned=!1:\"string\"==typeof t.begin?e.begin=parseInt(t.begin,10):\"number\"==typeof t.begin?e.begin=t.begin:\"object\"==typeof t.begin&&(e.begin=new c.LongBits(t.begin.low>>>0,t.begin.high>>>0).toNumber())),null!=t.end&&(c.Long?(e.end=c.Long.fromValue(t.end)).unsigned=!1:\"string\"==typeof t.end?e.end=parseInt(t.end,10):\"number\"==typeof t.end?e.end=t.end:\"object\"==typeof t.end&&(e.end=new c.LongBits(t.end.low>>>0,t.end.high>>>0).toNumber())),e},t.toObject=function(t,e){e||(e={});var n={};if(e.defaults){if(c.Long){var r=new c.Long(0,0,!1);n.begin=e.longs===String?r.toString():e.longs===Number?r.toNumber():r}else n.begin=e.longs===String?\"0\":0;c.Long?(r=new c.Long(0,0,!1),n.end=e.longs===String?r.toString():e.longs===Number?r.toNumber():r):n.end=e.longs===String?\"0\":0}return null!=t.begin&&t.hasOwnProperty(\"begin\")&&(\"number\"==typeof t.begin?n.begin=e.longs===String?String(t.begin):t.begin:n.begin=e.longs===String?c.Long.prototype.toString.call(t.begin):e.longs===Number?new c.LongBits(t.begin.low>>>0,t.begin.high>>>0).toNumber():t.begin),null!=t.end&&t.hasOwnProperty(\"end\")&&(\"number\"==typeof t.end?n.end=e.longs===String?String(t.end):t.end:n.end=e.longs===String?c.Long.prototype.toString.call(t.end):e.longs===Number?new c.LongBits(t.end.low>>>0,t.end.high>>>0).toNumber():t.end),n},t.prototype.toJSON=function(){return this.constructor.toObject(this,a.util.toJSONOptions)},t}(),t.DataLocation=function(){var t={},e=Object.create(t);return e[t[0]=\"DEFAULT\"]=0,e[t[1]=\"EXTERNAL\"]=1,e}(),t}(),o.TensorShapeProto=function(){function t(t){if(this.dim=[],t)for(var e=Object.keys(t),n=0;n<e.length;++n)null!=t[e[n]]&&(this[e[n]]=t[e[n]])}return t.prototype.dim=c.emptyArray,t.create=function(e){return new t(e)},t.encode=function(t,e){if(e||(e=u.create()),null!=t.dim&&t.dim.length)for(var n=0;n<t.dim.length;++n)l.onnx.TensorShapeProto.Dimension.encode(t.dim[n],e.uint32(10).fork()).ldelim();return e},t.encodeDelimited=function(t,e){return this.encode(t,e).ldelim()},t.decode=function(t,e){t instanceof s||(t=s.create(t));for(var n=void 0===e?t.len:t.pos+e,r=new l.onnx.TensorShapeProto;t.pos<n;){var i=t.uint32();i>>>3==1?(r.dim&&r.dim.length||(r.dim=[]),r.dim.push(l.onnx.TensorShapeProto.Dimension.decode(t,t.uint32()))):t.skipType(7&i)}return r},t.decodeDelimited=function(t){return t instanceof s||(t=new s(t)),this.decode(t,t.uint32())},t.verify=function(t){if(\"object\"!=typeof t||null===t)return\"object expected\";if(null!=t.dim&&t.hasOwnProperty(\"dim\")){if(!Array.isArray(t.dim))return\"dim: array expected\";for(var e=0;e<t.dim.length;++e){var n=l.onnx.TensorShapeProto.Dimension.verify(t.dim[e]);if(n)return\"dim.\"+n}}return null},t.fromObject=function(t){if(t instanceof l.onnx.TensorShapeProto)return t;var e=new l.onnx.TensorShapeProto;if(t.dim){if(!Array.isArray(t.dim))throw TypeError(\".onnx.TensorShapeProto.dim: array expected\");e.dim=[];for(var n=0;n<t.dim.length;++n){if(\"object\"!=typeof t.dim[n])throw TypeError(\".onnx.TensorShapeProto.dim: object expected\");e.dim[n]=l.onnx.TensorShapeProto.Dimension.fromObject(t.dim[n])}}return e},t.toObject=function(t,e){e||(e={});var n={};if((e.arrays||e.defaults)&&(n.dim=[]),t.dim&&t.dim.length){n.dim=[];for(var r=0;r<t.dim.length;++r)n.dim[r]=l.onnx.TensorShapeProto.Dimension.toObject(t.dim[r],e)}return n},t.prototype.toJSON=function(){return this.constructor.toObject(this,a.util.toJSONOptions)},t.Dimension=function(){function t(t){if(t)for(var e=Object.keys(t),n=0;n<e.length;++n)null!=t[e[n]]&&(this[e[n]]=t[e[n]])}var e;return t.prototype.dimValue=c.Long?c.Long.fromBits(0,0,!1):0,t.prototype.dimParam=\"\",t.prototype.denotation=\"\",Object.defineProperty(t.prototype,\"value\",{get:c.oneOfGetter(e=[\"dimValue\",\"dimParam\"]),set:c.oneOfSetter(e)}),t.create=function(e){return new t(e)},t.encode=function(t,e){return e||(e=u.create()),null!=t.dimValue&&t.hasOwnProperty(\"dimValue\")&&e.uint32(8).int64(t.dimValue),null!=t.dimParam&&t.hasOwnProperty(\"dimParam\")&&e.uint32(18).string(t.dimParam),null!=t.denotation&&t.hasOwnProperty(\"denotation\")&&e.uint32(26).string(t.denotation),e},t.encodeDelimited=function(t,e){return this.encode(t,e).ldelim()},t.decode=function(t,e){t instanceof s||(t=s.create(t));for(var n=void 0===e?t.len:t.pos+e,r=new l.onnx.TensorShapeProto.Dimension;t.pos<n;){var i=t.uint32();switch(i>>>3){case 1:r.dimValue=t.int64();break;case 2:r.dimParam=t.string();break;case 3:r.denotation=t.string();break;default:t.skipType(7&i)}}return r},t.decodeDelimited=function(t){return t instanceof s||(t=new s(t)),this.decode(t,t.uint32())},t.verify=function(t){if(\"object\"!=typeof t||null===t)return\"object expected\";var e={};if(null!=t.dimValue&&t.hasOwnProperty(\"dimValue\")&&(e.value=1,!(c.isInteger(t.dimValue)||t.dimValue&&c.isInteger(t.dimValue.low)&&c.isInteger(t.dimValue.high))))return\"dimValue: integer|Long expected\";if(null!=t.dimParam&&t.hasOwnProperty(\"dimParam\")){if(1===e.value)return\"value: multiple values\";if(e.value=1,!c.isString(t.dimParam))return\"dimParam: string expected\"}return null!=t.denotation&&t.hasOwnProperty(\"denotation\")&&!c.isString(t.denotation)?\"denotation: string expected\":null},t.fromObject=function(t){if(t instanceof l.onnx.TensorShapeProto.Dimension)return t;var e=new l.onnx.TensorShapeProto.Dimension;return null!=t.dimValue&&(c.Long?(e.dimValue=c.Long.fromValue(t.dimValue)).unsigned=!1:\"string\"==typeof t.dimValue?e.dimValue=parseInt(t.dimValue,10):\"number\"==typeof t.dimValue?e.dimValue=t.dimValue:\"object\"==typeof t.dimValue&&(e.dimValue=new c.LongBits(t.dimValue.low>>>0,t.dimValue.high>>>0).toNumber())),null!=t.dimParam&&(e.dimParam=String(t.dimParam)),null!=t.denotation&&(e.denotation=String(t.denotation)),e},t.toObject=function(t,e){e||(e={});var n={};return e.defaults&&(n.denotation=\"\"),null!=t.dimValue&&t.hasOwnProperty(\"dimValue\")&&(\"number\"==typeof t.dimValue?n.dimValue=e.longs===String?String(t.dimValue):t.dimValue:n.dimValue=e.longs===String?c.Long.prototype.toString.call(t.dimValue):e.longs===Number?new c.LongBits(t.dimValue.low>>>0,t.dimValue.high>>>0).toNumber():t.dimValue,e.oneofs&&(n.value=\"dimValue\")),null!=t.dimParam&&t.hasOwnProperty(\"dimParam\")&&(n.dimParam=t.dimParam,e.oneofs&&(n.value=\"dimParam\")),null!=t.denotation&&t.hasOwnProperty(\"denotation\")&&(n.denotation=t.denotation),n},t.prototype.toJSON=function(){return this.constructor.toObject(this,a.util.toJSONOptions)},t}(),t}(),o.TypeProto=function(){function t(t){if(t)for(var e=Object.keys(t),n=0;n<e.length;++n)null!=t[e[n]]&&(this[e[n]]=t[e[n]])}var e;return t.prototype.tensorType=null,t.prototype.denotation=\"\",Object.defineProperty(t.prototype,\"value\",{get:c.oneOfGetter(e=[\"tensorType\"]),set:c.oneOfSetter(e)}),t.create=function(e){return new t(e)},t.encode=function(t,e){return e||(e=u.create()),null!=t.tensorType&&t.hasOwnProperty(\"tensorType\")&&l.onnx.TypeProto.Tensor.encode(t.tensorType,e.uint32(10).fork()).ldelim(),null!=t.denotation&&t.hasOwnProperty(\"denotation\")&&e.uint32(50).string(t.denotation),e},t.encodeDelimited=function(t,e){return this.encode(t,e).ldelim()},t.decode=function(t,e){t instanceof s||(t=s.create(t));for(var n=void 0===e?t.len:t.pos+e,r=new l.onnx.TypeProto;t.pos<n;){var i=t.uint32();switch(i>>>3){case 1:r.tensorType=l.onnx.TypeProto.Tensor.decode(t,t.uint32());break;case 6:r.denotation=t.string();break;default:t.skipType(7&i)}}return r},t.decodeDelimited=function(t){return t instanceof s||(t=new s(t)),this.decode(t,t.uint32())},t.verify=function(t){if(\"object\"!=typeof t||null===t)return\"object expected\";if(null!=t.tensorType&&t.hasOwnProperty(\"tensorType\")){var e=l.onnx.TypeProto.Tensor.verify(t.tensorType);if(e)return\"tensorType.\"+e}return null!=t.denotation&&t.hasOwnProperty(\"denotation\")&&!c.isString(t.denotation)?\"denotation: string expected\":null},t.fromObject=function(t){if(t instanceof l.onnx.TypeProto)return t;var e=new l.onnx.TypeProto;if(null!=t.tensorType){if(\"object\"!=typeof t.tensorType)throw TypeError(\".onnx.TypeProto.tensorType: object expected\");e.tensorType=l.onnx.TypeProto.Tensor.fromObject(t.tensorType)}return null!=t.denotation&&(e.denotation=String(t.denotation)),e},t.toObject=function(t,e){e||(e={});var n={};return e.defaults&&(n.denotation=\"\"),null!=t.tensorType&&t.hasOwnProperty(\"tensorType\")&&(n.tensorType=l.onnx.TypeProto.Tensor.toObject(t.tensorType,e),e.oneofs&&(n.value=\"tensorType\")),null!=t.denotation&&t.hasOwnProperty(\"denotation\")&&(n.denotation=t.denotation),n},t.prototype.toJSON=function(){return this.constructor.toObject(this,a.util.toJSONOptions)},t.Tensor=function(){function t(t){if(t)for(var e=Object.keys(t),n=0;n<e.length;++n)null!=t[e[n]]&&(this[e[n]]=t[e[n]])}return t.prototype.elemType=0,t.prototype.shape=null,t.create=function(e){return new t(e)},t.encode=function(t,e){return e||(e=u.create()),null!=t.elemType&&t.hasOwnProperty(\"elemType\")&&e.uint32(8).int32(t.elemType),null!=t.shape&&t.hasOwnProperty(\"shape\")&&l.onnx.TensorShapeProto.encode(t.shape,e.uint32(18).fork()).ldelim(),e},t.encodeDelimited=function(t,e){return this.encode(t,e).ldelim()},t.decode=function(t,e){t instanceof s||(t=s.create(t));for(var n=void 0===e?t.len:t.pos+e,r=new l.onnx.TypeProto.Tensor;t.pos<n;){var i=t.uint32();switch(i>>>3){case 1:r.elemType=t.int32();break;case 2:r.shape=l.onnx.TensorShapeProto.decode(t,t.uint32());break;default:t.skipType(7&i)}}return r},t.decodeDelimited=function(t){return t instanceof s||(t=new s(t)),this.decode(t,t.uint32())},t.verify=function(t){if(\"object\"!=typeof t||null===t)return\"object expected\";if(null!=t.elemType&&t.hasOwnProperty(\"elemType\")&&!c.isInteger(t.elemType))return\"elemType: integer expected\";if(null!=t.shape&&t.hasOwnProperty(\"shape\")){var e=l.onnx.TensorShapeProto.verify(t.shape);if(e)return\"shape.\"+e}return null},t.fromObject=function(t){if(t instanceof l.onnx.TypeProto.Tensor)return t;var e=new l.onnx.TypeProto.Tensor;if(null!=t.elemType&&(e.elemType=0|t.elemType),null!=t.shape){if(\"object\"!=typeof t.shape)throw TypeError(\".onnx.TypeProto.Tensor.shape: object expected\");e.shape=l.onnx.TensorShapeProto.fromObject(t.shape)}return e},t.toObject=function(t,e){e||(e={});var n={};return e.defaults&&(n.elemType=0,n.shape=null),null!=t.elemType&&t.hasOwnProperty(\"elemType\")&&(n.elemType=t.elemType),null!=t.shape&&t.hasOwnProperty(\"shape\")&&(n.shape=l.onnx.TensorShapeProto.toObject(t.shape,e)),n},t.prototype.toJSON=function(){return this.constructor.toObject(this,a.util.toJSONOptions)},t}(),t}(),o.OperatorSetIdProto=function(){function t(t){if(t)for(var e=Object.keys(t),n=0;n<e.length;++n)null!=t[e[n]]&&(this[e[n]]=t[e[n]])}return t.prototype.domain=\"\",t.prototype.version=c.Long?c.Long.fromBits(0,0,!1):0,t.create=function(e){return new t(e)},t.encode=function(t,e){return e||(e=u.create()),null!=t.domain&&t.hasOwnProperty(\"domain\")&&e.uint32(10).string(t.domain),null!=t.version&&t.hasOwnProperty(\"version\")&&e.uint32(16).int64(t.version),e},t.encodeDelimited=function(t,e){return this.encode(t,e).ldelim()},t.decode=function(t,e){t instanceof s||(t=s.create(t));for(var n=void 0===e?t.len:t.pos+e,r=new l.onnx.OperatorSetIdProto;t.pos<n;){var i=t.uint32();switch(i>>>3){case 1:r.domain=t.string();break;case 2:r.version=t.int64();break;default:t.skipType(7&i)}}return r},t.decodeDelimited=function(t){return t instanceof s||(t=new s(t)),this.decode(t,t.uint32())},t.verify=function(t){return\"object\"!=typeof t||null===t?\"object expected\":null!=t.domain&&t.hasOwnProperty(\"domain\")&&!c.isString(t.domain)?\"domain: string expected\":null!=t.version&&t.hasOwnProperty(\"version\")&&!(c.isInteger(t.version)||t.version&&c.isInteger(t.version.low)&&c.isInteger(t.version.high))?\"version: integer|Long expected\":null},t.fromObject=function(t){if(t instanceof l.onnx.OperatorSetIdProto)return t;var e=new l.onnx.OperatorSetIdProto;return null!=t.domain&&(e.domain=String(t.domain)),null!=t.version&&(c.Long?(e.version=c.Long.fromValue(t.version)).unsigned=!1:\"string\"==typeof t.version?e.version=parseInt(t.version,10):\"number\"==typeof t.version?e.version=t.version:\"object\"==typeof t.version&&(e.version=new c.LongBits(t.version.low>>>0,t.version.high>>>0).toNumber())),e},t.toObject=function(t,e){e||(e={});var n={};if(e.defaults)if(n.domain=\"\",c.Long){var r=new c.Long(0,0,!1);n.version=e.longs===String?r.toString():e.longs===Number?r.toNumber():r}else n.version=e.longs===String?\"0\":0;return null!=t.domain&&t.hasOwnProperty(\"domain\")&&(n.domain=t.domain),null!=t.version&&t.hasOwnProperty(\"version\")&&(\"number\"==typeof t.version?n.version=e.longs===String?String(t.version):t.version:n.version=e.longs===String?c.Long.prototype.toString.call(t.version):e.longs===Number?new c.LongBits(t.version.low>>>0,t.version.high>>>0).toNumber():t.version),n},t.prototype.toJSON=function(){return this.constructor.toObject(this,a.util.toJSONOptions)},t}(),o),t.exports=l},2100:(t,e,n)=>{\"use strict\";t.exports=n(9482)},9482:(t,e,n)=>{\"use strict\";var r=e;function i(){r.util._configure(),r.Writer._configure(r.BufferWriter),r.Reader._configure(r.BufferReader)}r.build=\"minimal\",r.Writer=n(1173),r.BufferWriter=n(3155),r.Reader=n(1408),r.BufferReader=n(593),r.util=n(9693),r.rpc=n(5994),r.roots=n(5054),r.configure=i,i()},1408:(t,e,n)=>{\"use strict\";t.exports=u;var r,i=n(9693),o=i.LongBits,a=i.utf8;function s(t,e){return RangeError(\"index out of range: \"+t.pos+\" + \"+(e||1)+\" > \"+t.len)}function u(t){this.buf=t,this.pos=0,this.len=t.length}var c,l=\"undefined\"!=typeof Uint8Array?function(t){if(t instanceof Uint8Array||Array.isArray(t))return new u(t);throw Error(\"illegal buffer\")}:function(t){if(Array.isArray(t))return new u(t);throw Error(\"illegal buffer\")},p=function(){return i.Buffer?function(t){return(u.create=function(t){return i.Buffer.isBuffer(t)?new r(t):l(t)})(t)}:l};function f(){var t=new o(0,0),e=0;if(!(this.len-this.pos>4)){for(;e<3;++e){if(this.pos>=this.len)throw s(this);if(t.lo=(t.lo|(127&this.buf[this.pos])<<7*e)>>>0,this.buf[this.pos++]<128)return t}return t.lo=(t.lo|(127&this.buf[this.pos++])<<7*e)>>>0,t}for(;e<4;++e)if(t.lo=(t.lo|(127&this.buf[this.pos])<<7*e)>>>0,this.buf[this.pos++]<128)return t;if(t.lo=(t.lo|(127&this.buf[this.pos])<<28)>>>0,t.hi=(t.hi|(127&this.buf[this.pos])>>4)>>>0,this.buf[this.pos++]<128)return t;if(e=0,this.len-this.pos>4){for(;e<5;++e)if(t.hi=(t.hi|(127&this.buf[this.pos])<<7*e+3)>>>0,this.buf[this.pos++]<128)return t}else for(;e<5;++e){if(this.pos>=this.len)throw s(this);if(t.hi=(t.hi|(127&this.buf[this.pos])<<7*e+3)>>>0,this.buf[this.pos++]<128)return t}throw Error(\"invalid varint encoding\")}function d(t,e){return(t[e-4]|t[e-3]<<8|t[e-2]<<16|t[e-1]<<24)>>>0}function h(){if(this.pos+8>this.len)throw s(this,8);return new o(d(this.buf,this.pos+=4),d(this.buf,this.pos+=4))}u.create=p(),u.prototype._slice=i.Array.prototype.subarray||i.Array.prototype.slice,u.prototype.uint32=(c=4294967295,function(){if(c=(127&this.buf[this.pos])>>>0,this.buf[this.pos++]<128)return c;if(c=(c|(127&this.buf[this.pos])<<7)>>>0,this.buf[this.pos++]<128)return c;if(c=(c|(127&this.buf[this.pos])<<14)>>>0,this.buf[this.pos++]<128)return c;if(c=(c|(127&this.buf[this.pos])<<21)>>>0,this.buf[this.pos++]<128)return c;if(c=(c|(15&this.buf[this.pos])<<28)>>>0,this.buf[this.pos++]<128)return c;if((this.pos+=5)>this.len)throw this.pos=this.len,s(this,10);return c}),u.prototype.int32=function(){return 0|this.uint32()},u.prototype.sint32=function(){var t=this.uint32();return t>>>1^-(1&t)|0},u.prototype.bool=function(){return 0!==this.uint32()},u.prototype.fixed32=function(){if(this.pos+4>this.len)throw s(this,4);return d(this.buf,this.pos+=4)},u.prototype.sfixed32=function(){if(this.pos+4>this.len)throw s(this,4);return 0|d(this.buf,this.pos+=4)},u.prototype.float=function(){if(this.pos+4>this.len)throw s(this,4);var t=i.float.readFloatLE(this.buf,this.pos);return this.pos+=4,t},u.prototype.double=function(){if(this.pos+8>this.len)throw s(this,4);var t=i.float.readDoubleLE(this.buf,this.pos);return this.pos+=8,t},u.prototype.bytes=function(){var t=this.uint32(),e=this.pos,n=this.pos+t;if(n>this.len)throw s(this,t);return this.pos+=t,Array.isArray(this.buf)?this.buf.slice(e,n):e===n?new this.buf.constructor(0):this._slice.call(this.buf,e,n)},u.prototype.string=function(){var t=this.bytes();return a.read(t,0,t.length)},u.prototype.skip=function(t){if(\"number\"==typeof t){if(this.pos+t>this.len)throw s(this,t);this.pos+=t}else do{if(this.pos>=this.len)throw s(this)}while(128&this.buf[this.pos++]);return this},u.prototype.skipType=function(t){switch(t){case 0:this.skip();break;case 1:this.skip(8);break;case 2:this.skip(this.uint32());break;case 3:for(;4!=(t=7&this.uint32());)this.skipType(t);break;case 5:this.skip(4);break;default:throw Error(\"invalid wire type \"+t+\" at offset \"+this.pos)}return this},u._configure=function(t){r=t,u.create=p(),r._configure();var e=i.Long?\"toLong\":\"toNumber\";i.merge(u.prototype,{int64:function(){return f.call(this)[e](!1)},uint64:function(){return f.call(this)[e](!0)},sint64:function(){return f.call(this).zzDecode()[e](!1)},fixed64:function(){return h.call(this)[e](!0)},sfixed64:function(){return h.call(this)[e](!1)}})}},593:(t,e,n)=>{\"use strict\";t.exports=o;var r=n(1408);(o.prototype=Object.create(r.prototype)).constructor=o;var i=n(9693);function o(t){r.call(this,t)}o._configure=function(){i.Buffer&&(o.prototype._slice=i.Buffer.prototype.slice)},o.prototype.string=function(){var t=this.uint32();return this.buf.utf8Slice?this.buf.utf8Slice(this.pos,this.pos=Math.min(this.pos+t,this.len)):this.buf.toString(\"utf-8\",this.pos,this.pos=Math.min(this.pos+t,this.len))},o._configure()},5054:t=>{\"use strict\";t.exports={}},5994:(t,e,n)=>{\"use strict\";e.Service=n(7948)},7948:(t,e,n)=>{\"use strict\";t.exports=i;var r=n(9693);function i(t,e,n){if(\"function\"!=typeof t)throw TypeError(\"rpcImpl must be a function\");r.EventEmitter.call(this),this.rpcImpl=t,this.requestDelimited=Boolean(e),this.responseDelimited=Boolean(n)}(i.prototype=Object.create(r.EventEmitter.prototype)).constructor=i,i.prototype.rpcCall=function t(e,n,i,o,a){if(!o)throw TypeError(\"request must be specified\");var s=this;if(!a)return r.asPromise(t,s,e,n,i,o);if(s.rpcImpl)try{return s.rpcImpl(e,n[s.requestDelimited?\"encodeDelimited\":\"encode\"](o).finish(),(function(t,n){if(t)return s.emit(\"error\",t,e),a(t);if(null!==n){if(!(n instanceof i))try{n=i[s.responseDelimited?\"decodeDelimited\":\"decode\"](n)}catch(t){return s.emit(\"error\",t,e),a(t)}return s.emit(\"data\",n,e),a(null,n)}s.end(!0)}))}catch(t){return s.emit(\"error\",t,e),void setTimeout((function(){a(t)}),0)}else setTimeout((function(){a(Error(\"already ended\"))}),0)},i.prototype.end=function(t){return this.rpcImpl&&(t||this.rpcImpl(null,null,null),this.rpcImpl=null,this.emit(\"end\").off()),this}},1945:(t,e,n)=>{\"use strict\";t.exports=i;var r=n(9693);function i(t,e){this.lo=t>>>0,this.hi=e>>>0}var o=i.zero=new i(0,0);o.toNumber=function(){return 0},o.zzEncode=o.zzDecode=function(){return this},o.length=function(){return 1};var a=i.zeroHash=\"\\0\\0\\0\\0\\0\\0\\0\\0\";i.fromNumber=function(t){if(0===t)return o;var e=t<0;e&&(t=-t);var n=t>>>0,r=(t-n)/4294967296>>>0;return e&&(r=~r>>>0,n=~n>>>0,++n>4294967295&&(n=0,++r>4294967295&&(r=0))),new i(n,r)},i.from=function(t){if(\"number\"==typeof t)return i.fromNumber(t);if(r.isString(t)){if(!r.Long)return i.fromNumber(parseInt(t,10));t=r.Long.fromString(t)}return t.low||t.high?new i(t.low>>>0,t.high>>>0):o},i.prototype.toNumber=function(t){if(!t&&this.hi>>>31){var e=1+~this.lo>>>0,n=~this.hi>>>0;return e||(n=n+1>>>0),-(e+4294967296*n)}return this.lo+4294967296*this.hi},i.prototype.toLong=function(t){return r.Long?new r.Long(0|this.lo,0|this.hi,Boolean(t)):{low:0|this.lo,high:0|this.hi,unsigned:Boolean(t)}};var s=String.prototype.charCodeAt;i.fromHash=function(t){return t===a?o:new i((s.call(t,0)|s.call(t,1)<<8|s.call(t,2)<<16|s.call(t,3)<<24)>>>0,(s.call(t,4)|s.call(t,5)<<8|s.call(t,6)<<16|s.call(t,7)<<24)>>>0)},i.prototype.toHash=function(){return String.fromCharCode(255&this.lo,this.lo>>>8&255,this.lo>>>16&255,this.lo>>>24,255&this.hi,this.hi>>>8&255,this.hi>>>16&255,this.hi>>>24)},i.prototype.zzEncode=function(){var t=this.hi>>31;return this.hi=((this.hi<<1|this.lo>>>31)^t)>>>0,this.lo=(this.lo<<1^t)>>>0,this},i.prototype.zzDecode=function(){var t=-(1&this.lo);return this.lo=((this.lo>>>1|this.hi<<31)^t)>>>0,this.hi=(this.hi>>>1^t)>>>0,this},i.prototype.length=function(){var t=this.lo,e=(this.lo>>>28|this.hi<<4)>>>0,n=this.hi>>>24;return 0===n?0===e?t<16384?t<128?1:2:t<2097152?3:4:e<16384?e<128?5:6:e<2097152?7:8:n<128?9:10}},9693:function(t,e,n){\"use strict\";var r=e;function i(t,e,n){for(var r=Object.keys(e),i=0;i<r.length;++i)void 0!==t[r[i]]&&n||(t[r[i]]=e[r[i]]);return t}function o(t){function e(t,n){if(!(this instanceof e))return new e(t,n);Object.defineProperty(this,\"message\",{get:function(){return t}}),Error.captureStackTrace?Error.captureStackTrace(this,e):Object.defineProperty(this,\"stack\",{value:(new Error).stack||\"\"}),n&&i(this,n)}return(e.prototype=Object.create(Error.prototype)).constructor=e,Object.defineProperty(e.prototype,\"name\",{get:function(){return t}}),e.prototype.toString=function(){return this.name+\": \"+this.message},e}r.asPromise=n(4537),r.base64=n(7419),r.EventEmitter=n(9211),r.float=n(945),r.inquire=n(7199),r.utf8=n(4997),r.pool=n(6662),r.LongBits=n(1945),r.isNode=Boolean(void 0!==n.g&&n.g&&n.g.process&&n.g.process.versions&&n.g.process.versions.node),r.global=r.isNode&&n.g||\"undefined\"!=typeof window&&window||\"undefined\"!=typeof self&&self||this,r.emptyArray=Object.freeze?Object.freeze([]):[],r.emptyObject=Object.freeze?Object.freeze({}):{},r.isInteger=Number.isInteger||function(t){return\"number\"==typeof t&&isFinite(t)&&Math.floor(t)===t},r.isString=function(t){return\"string\"==typeof t||t instanceof String},r.isObject=function(t){return t&&\"object\"==typeof t},r.isset=r.isSet=function(t,e){var n=t[e];return!(null==n||!t.hasOwnProperty(e))&&(\"object\"!=typeof n||(Array.isArray(n)?n.length:Object.keys(n).length)>0)},r.Buffer=function(){try{var t=r.inquire(\"buffer\").Buffer;return t.prototype.utf8Write?t:null}catch(t){return null}}(),r._Buffer_from=null,r._Buffer_allocUnsafe=null,r.newBuffer=function(t){return\"number\"==typeof t?r.Buffer?r._Buffer_allocUnsafe(t):new r.Array(t):r.Buffer?r._Buffer_from(t):\"undefined\"==typeof Uint8Array?t:new Uint8Array(t)},r.Array=\"undefined\"!=typeof Uint8Array?Uint8Array:Array,r.Long=r.global.dcodeIO&&r.global.dcodeIO.Long||r.global.Long||r.inquire(\"long\"),r.key2Re=/^true|false|0|1$/,r.key32Re=/^-?(?:0|[1-9][0-9]*)$/,r.key64Re=/^(?:[\\\\x00-\\\\xff]{8}|-?(?:0|[1-9][0-9]*))$/,r.longToHash=function(t){return t?r.LongBits.from(t).toHash():r.LongBits.zeroHash},r.longFromHash=function(t,e){var n=r.LongBits.fromHash(t);return r.Long?r.Long.fromBits(n.lo,n.hi,e):n.toNumber(Boolean(e))},r.merge=i,r.lcFirst=function(t){return t.charAt(0).toLowerCase()+t.substring(1)},r.newError=o,r.ProtocolError=o(\"ProtocolError\"),r.oneOfGetter=function(t){for(var e={},n=0;n<t.length;++n)e[t[n]]=1;return function(){for(var t=Object.keys(this),n=t.length-1;n>-1;--n)if(1===e[t[n]]&&void 0!==this[t[n]]&&null!==this[t[n]])return t[n]}},r.oneOfSetter=function(t){return function(e){for(var n=0;n<t.length;++n)t[n]!==e&&delete this[t[n]]}},r.toJSONOptions={longs:String,enums:String,bytes:String,json:!0},r._configure=function(){var t=r.Buffer;t?(r._Buffer_from=t.from!==Uint8Array.from&&t.from||function(e,n){return new t(e,n)},r._Buffer_allocUnsafe=t.allocUnsafe||function(e){return new t(e)}):r._Buffer_from=r._Buffer_allocUnsafe=null}},1173:(t,e,n)=>{\"use strict\";t.exports=p;var r,i=n(9693),o=i.LongBits,a=i.base64,s=i.utf8;function u(t,e,n){this.fn=t,this.len=e,this.next=void 0,this.val=n}function c(){}function l(t){this.head=t.head,this.tail=t.tail,this.len=t.len,this.next=t.states}function p(){this.len=0,this.head=new u(c,0,0),this.tail=this.head,this.states=null}var f=function(){return i.Buffer?function(){return(p.create=function(){return new r})()}:function(){return new p}};function d(t,e,n){e[n]=255&t}function h(t,e){this.len=t,this.next=void 0,this.val=e}function g(t,e,n){for(;t.hi;)e[n++]=127&t.lo|128,t.lo=(t.lo>>>7|t.hi<<25)>>>0,t.hi>>>=7;for(;t.lo>127;)e[n++]=127&t.lo|128,t.lo=t.lo>>>7;e[n++]=t.lo}function b(t,e,n){e[n]=255&t,e[n+1]=t>>>8&255,e[n+2]=t>>>16&255,e[n+3]=t>>>24}p.create=f(),p.alloc=function(t){return new i.Array(t)},i.Array!==Array&&(p.alloc=i.pool(p.alloc,i.Array.prototype.subarray)),p.prototype._push=function(t,e,n){return this.tail=this.tail.next=new u(t,e,n),this.len+=e,this},h.prototype=Object.create(u.prototype),h.prototype.fn=function(t,e,n){for(;t>127;)e[n++]=127&t|128,t>>>=7;e[n]=t},p.prototype.uint32=function(t){return this.len+=(this.tail=this.tail.next=new h((t>>>=0)<128?1:t<16384?2:t<2097152?3:t<268435456?4:5,t)).len,this},p.prototype.int32=function(t){return t<0?this._push(g,10,o.fromNumber(t)):this.uint32(t)},p.prototype.sint32=function(t){return this.uint32((t<<1^t>>31)>>>0)},p.prototype.uint64=function(t){var e=o.from(t);return this._push(g,e.length(),e)},p.prototype.int64=p.prototype.uint64,p.prototype.sint64=function(t){var e=o.from(t).zzEncode();return this._push(g,e.length(),e)},p.prototype.bool=function(t){return this._push(d,1,t?1:0)},p.prototype.fixed32=function(t){return this._push(b,4,t>>>0)},p.prototype.sfixed32=p.prototype.fixed32,p.prototype.fixed64=function(t){var e=o.from(t);return this._push(b,4,e.lo)._push(b,4,e.hi)},p.prototype.sfixed64=p.prototype.fixed64,p.prototype.float=function(t){return this._push(i.float.writeFloatLE,4,t)},p.prototype.double=function(t){return this._push(i.float.writeDoubleLE,8,t)};var m=i.Array.prototype.set?function(t,e,n){e.set(t,n)}:function(t,e,n){for(var r=0;r<t.length;++r)e[n+r]=t[r]};p.prototype.bytes=function(t){var e=t.length>>>0;if(!e)return this._push(d,1,0);if(i.isString(t)){var n=p.alloc(e=a.length(t));a.decode(t,n,0),t=n}return this.uint32(e)._push(m,e,t)},p.prototype.string=function(t){var e=s.length(t);return e?this.uint32(e)._push(s.write,e,t):this._push(d,1,0)},p.prototype.fork=function(){return this.states=new l(this),this.head=this.tail=new u(c,0,0),this.len=0,this},p.prototype.reset=function(){return this.states?(this.head=this.states.head,this.tail=this.states.tail,this.len=this.states.len,this.states=this.states.next):(this.head=this.tail=new u(c,0,0),this.len=0),this},p.prototype.ldelim=function(){var t=this.head,e=this.tail,n=this.len;return this.reset().uint32(n),n&&(this.tail.next=t.next,this.tail=e,this.len+=n),this},p.prototype.finish=function(){for(var t=this.head.next,e=this.constructor.alloc(this.len),n=0;t;)t.fn(t.val,e,n),n+=t.len,t=t.next;return e},p._configure=function(t){r=t,p.create=f(),r._configure()}},3155:(t,e,n)=>{\"use strict\";t.exports=o;var r=n(1173);(o.prototype=Object.create(r.prototype)).constructor=o;var i=n(9693);function o(){r.call(this)}function a(t,e,n){t.length<40?i.utf8.write(t,e,n):e.utf8Write?e.utf8Write(t,n):e.write(t,n)}o._configure=function(){o.alloc=i._Buffer_allocUnsafe,o.writeBytesBuffer=i.Buffer&&i.Buffer.prototype instanceof Uint8Array&&\"set\"===i.Buffer.prototype.set.name?function(t,e,n){e.set(t,n)}:function(t,e,n){if(t.copy)t.copy(e,n,0,t.length);else for(var r=0;r<t.length;)e[n++]=t[r++]}},o.prototype.bytes=function(t){i.isString(t)&&(t=i._Buffer_from(t,\"base64\"));var e=t.length>>>0;return this.uint32(e),e&&this._push(o.writeBytesBuffer,e,t),this},o.prototype.string=function(t){var e=i.Buffer.byteLength(t);return this.uint32(e),e&&this._push(a,e,t),this},o._configure()},7714:(t,e,n)=>{\"use strict\";e.R=void 0;const r=n(6919),i=n(7448);e.R=new class{async init(){}async createSessionHandler(t,e){const n=new r.Session(e);return await n.loadModel(t),new i.OnnxjsSessionHandler(n)}}},4200:(t,e,n)=>{\"use strict\";e.c8=e.rX=void 0;const r=n(1670),i=n(5381),o=n(2157),a=n(2306);e.rX=()=>{if((\"number\"!=typeof r.env.wasm.initTimeout||r.env.wasm.initTimeout<0)&&(r.env.wasm.initTimeout=0),\"boolean\"!=typeof r.env.wasm.simd&&(r.env.wasm.simd=!0),\"boolean\"!=typeof r.env.wasm.proxy&&(r.env.wasm.proxy=!1),\"number\"!=typeof r.env.wasm.numThreads||!Number.isInteger(r.env.wasm.numThreads)||r.env.wasm.numThreads<=0){const t=\"undefined\"==typeof navigator?(0,i.cpus)().length:navigator.hardwareConcurrency;r.env.wasm.numThreads=Math.min(4,Math.ceil((t||1)/2))}},e.c8=new class{async init(){(0,e.rX)(),await(0,o.initWasm)()}async createSessionHandler(t,e){const n=new a.OnnxruntimeWebAssemblySessionHandler;return await n.loadModel(t,e),Promise.resolve(n)}}},6018:function(t,e,n){\"use strict\";var r=this&&this.__createBinding||(Object.create?function(t,e,n,r){void 0===r&&(r=n);var i=Object.getOwnPropertyDescriptor(e,n);i&&!(\"get\"in i?!e.__esModule:i.writable||i.configurable)||(i={enumerable:!0,get:function(){return e[n]}}),Object.defineProperty(t,r,i)}:function(t,e,n,r){void 0===r&&(r=n),t[r]=e[n]}),i=this&&this.__exportStar||function(t,e){for(var n in t)\"default\"===n||Object.prototype.hasOwnProperty.call(e,n)||r(e,t,n)};Object.defineProperty(e,\"__esModule\",{value:!0}),i(n(1670),e);const o=n(1670);{const t=n(7714).R;(0,o.registerBackend)(\"webgl\",t,-10)}{const t=n(4200).c8;(0,o.registerBackend)(\"cpu\",t,10),(0,o.registerBackend)(\"wasm\",t,10),(0,o.registerBackend)(\"xnnpack\",t,9)}},246:(t,e)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.createAttributeWithCacheKey=void 0;class n{constructor(t){Object.assign(this,t)}get cacheKey(){return this._cacheKey||(this._cacheKey=Object.getOwnPropertyNames(this).sort().map((t=>`${this[t]}`)).join(\";\")),this._cacheKey}}e.createAttributeWithCacheKey=t=>new n(t)},7778:(t,e,n)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.Attribute=void 0;const r=n(1446),i=n(9395),o=n(9162),a=n(2517);var s=i.onnxruntime.experimental.fbs;class u{constructor(t){if(this._attributes=new Map,null!=t){for(const e of t)e instanceof r.onnx.AttributeProto?this._attributes.set(e.name,[u.getValue(e),u.getType(e)]):e instanceof s.Attribute&&this._attributes.set(e.name(),[u.getValue(e),u.getType(e)]);if(this._attributes.size<t.length)throw new Error(\"duplicated attribute names\")}}set(t,e,n){this._attributes.set(t,[n,e])}delete(t){this._attributes.delete(t)}getFloat(t,e){return this.get(t,\"float\",e)}getInt(t,e){return this.get(t,\"int\",e)}getString(t,e){return this.get(t,\"string\",e)}getTensor(t,e){return this.get(t,\"tensor\",e)}getFloats(t,e){return this.get(t,\"floats\",e)}getInts(t,e){return this.get(t,\"ints\",e)}getStrings(t,e){return this.get(t,\"strings\",e)}getTensors(t,e){return this.get(t,\"tensors\",e)}get(t,e,n){const r=this._attributes.get(t);if(void 0===r){if(void 0!==n)return n;throw new Error(`required attribute not found: ${t}`)}if(r[1]!==e)throw new Error(`type mismatch: expected ${e} but got ${r[1]}`);return r[0]}static getType(t){const e=t instanceof r.onnx.AttributeProto?t.type:t.type();switch(e){case r.onnx.AttributeProto.AttributeType.FLOAT:return\"float\";case r.onnx.AttributeProto.AttributeType.INT:return\"int\";case r.onnx.AttributeProto.AttributeType.STRING:return\"string\";case r.onnx.AttributeProto.AttributeType.TENSOR:return\"tensor\";case r.onnx.AttributeProto.AttributeType.FLOATS:return\"floats\";case r.onnx.AttributeProto.AttributeType.INTS:return\"ints\";case r.onnx.AttributeProto.AttributeType.STRINGS:return\"strings\";case r.onnx.AttributeProto.AttributeType.TENSORS:return\"tensors\";default:throw new Error(`attribute type is not supported yet: ${r.onnx.AttributeProto.AttributeType[e]}`)}}static getValue(t){const e=t instanceof r.onnx.AttributeProto?t.type:t.type();if(e===r.onnx.AttributeProto.AttributeType.GRAPH||e===r.onnx.AttributeProto.AttributeType.GRAPHS)throw new Error(\"graph attribute is not supported yet\");const n=this.getValueNoCheck(t);if(e===r.onnx.AttributeProto.AttributeType.INT&&a.LongUtil.isLong(n))return a.LongUtil.longToNumber(n);if(e===r.onnx.AttributeProto.AttributeType.INTS){const t=n,e=new Array(t.length);for(let n=0;n<t.length;n++){const r=t[n];e[n]=a.LongUtil.longToNumber(r)}return e}if(e===r.onnx.AttributeProto.AttributeType.TENSOR)return t instanceof r.onnx.AttributeProto?o.Tensor.fromProto(n):o.Tensor.fromOrtTensor(n);if(e===r.onnx.AttributeProto.AttributeType.TENSORS){if(t instanceof r.onnx.AttributeProto)return n.map((t=>o.Tensor.fromProto(t)));if(t instanceof s.Attribute)return n.map((t=>o.Tensor.fromOrtTensor(t)))}if(e===r.onnx.AttributeProto.AttributeType.STRING&&t instanceof r.onnx.AttributeProto){const t=n;return(0,a.decodeUtf8String)(t)}return e===r.onnx.AttributeProto.AttributeType.STRINGS&&t instanceof r.onnx.AttributeProto?n.map(a.decodeUtf8String):n}static getValueNoCheck(t){return t instanceof r.onnx.AttributeProto?this.getValueNoCheckFromOnnxFormat(t):this.getValueNoCheckFromOrtFormat(t)}static getValueNoCheckFromOnnxFormat(t){switch(t.type){case r.onnx.AttributeProto.AttributeType.FLOAT:return t.f;case r.onnx.AttributeProto.AttributeType.INT:return t.i;case r.onnx.AttributeProto.AttributeType.STRING:return t.s;case r.onnx.AttributeProto.AttributeType.TENSOR:return t.t;case r.onnx.AttributeProto.AttributeType.GRAPH:return t.g;case r.onnx.AttributeProto.AttributeType.FLOATS:return t.floats;case r.onnx.AttributeProto.AttributeType.INTS:return t.ints;case r.onnx.AttributeProto.AttributeType.STRINGS:return t.strings;case r.onnx.AttributeProto.AttributeType.TENSORS:return t.tensors;case r.onnx.AttributeProto.AttributeType.GRAPHS:return t.graphs;default:throw new Error(`unsupported attribute type: ${r.onnx.AttributeProto.AttributeType[t.type]}`)}}static getValueNoCheckFromOrtFormat(t){switch(t.type()){case s.AttributeType.FLOAT:return t.f();case s.AttributeType.INT:return t.i();case s.AttributeType.STRING:return t.s();case s.AttributeType.TENSOR:return t.t();case s.AttributeType.GRAPH:return t.g();case s.AttributeType.FLOATS:return t.floatsArray();case s.AttributeType.INTS:{const e=[];for(let n=0;n<t.intsLength();n++)e.push(t.ints(n));return e}case s.AttributeType.STRINGS:{const e=[];for(let n=0;n<t.stringsLength();n++)e.push(t.strings(n));return e}case s.AttributeType.TENSORS:{const e=[];for(let n=0;n<t.tensorsLength();n++)e.push(t.tensors(n));return e}default:throw new Error(`unsupported attribute type: ${s.AttributeType[t.type()]}`)}}}e.Attribute=u},7091:(t,e,n)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.resolveBackend=e.backend=void 0;const r=n(5038),i=new Map;async function o(t){const n=e.backend;if(void 0!==n[t]&&function(t){const e=t;return\"initialize\"in e&&\"function\"==typeof e.initialize&&\"createSessionHandler\"in e&&\"function\"==typeof e.createSessionHandler&&\"dispose\"in e&&\"function\"==typeof e.dispose}(n[t])){const e=n[t];let r=e.initialize();if(\"object\"==typeof r&&\"then\"in r&&(r=await r),r)return i.set(t,e),e}}e.backend={webgl:new r.WebGLBackend},e.resolveBackend=async function t(e){if(!e)return t([\"webgl\"]);{const t=\"string\"==typeof e?[e]:e;for(const e of t){const t=i.get(e);if(t)return t;const n=await o(e);if(n)return n}}throw new Error(\"no available backend to use\")}},5038:(t,e,n)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.WebGLBackend=void 0;const r=n(1670),i=n(6231),o=n(6416),a=n(7305);e.WebGLBackend=class{get contextId(){return r.env.webgl.contextId}set contextId(t){r.env.webgl.contextId=t}get matmulMaxBatchSize(){return r.env.webgl.matmulMaxBatchSize}set matmulMaxBatchSize(t){r.env.webgl.matmulMaxBatchSize=t}get textureCacheMode(){return r.env.webgl.textureCacheMode}set textureCacheMode(t){r.env.webgl.textureCacheMode=t}get pack(){return r.env.webgl.pack}set pack(t){r.env.webgl.pack=t}get async(){return r.env.webgl.async}set async(t){r.env.webgl.async=t}initialize(){try{return this.glContext=(0,a.createWebGLContext)(this.contextId),\"number\"!=typeof this.matmulMaxBatchSize&&(this.matmulMaxBatchSize=16),\"string\"!=typeof this.textureCacheMode&&(this.textureCacheMode=\"full\"),\"boolean\"!=typeof this.pack&&(this.pack=!1),\"boolean\"!=typeof this.async&&(this.async=!1),i.Logger.setWithEnv(r.env),i.Logger.verbose(\"WebGLBackend\",`Created WebGLContext: ${typeof this.glContext} with matmulMaxBatchSize: ${this.matmulMaxBatchSize}; textureCacheMode: ${this.textureCacheMode}; pack: ${this.pack}; async: ${this.async}.`),!0}catch(t){return i.Logger.warning(\"WebGLBackend\",`Unable to initialize WebGLBackend. ${t}`),!1}}createSessionHandler(t){return new o.WebGLSessionHandler(this,t)}dispose(){this.glContext.dispose()}}},5107:(t,e,n)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.CoordsGlslLib=void 0;const r=n(2517),i=n(8520),o=n(5060),a=n(7859),s=n(9390);class u extends i.GlslLib{constructor(t){super(t)}getFunctions(){return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({},this.offsetToCoords()),this.coordsToOffset()),this.toVec()),this.valueFrom()),this.getCommonUtilFuncs()),this.getInputsSamplingSnippets()),this.getOutputSamplingSnippet())}getCustomTypes(){return{}}offsetToCoords(){return{offsetToCoords:new i.GlslLibRoutine(\"\\n      vec2 offsetToCoords(int offset, int width, int height) {\\n        int t = offset / width;\\n        int s = offset - t*width;\\n        vec2 coords = (vec2(s,t) + vec2(0.5,0.5)) / vec2(width, height);\\n        return coords;\\n      }\\n      \")}}coordsToOffset(){return{coordsToOffset:new i.GlslLibRoutine(\"\\n      int coordsToOffset(vec2 coords, int width, int height) {\\n        float s = coords.s * float(width);\\n        float t = coords.t * float(height);\\n        int offset = int(t) * width + int(s);\\n        return offset;\\n      }\\n      \")}}getOutputSamplingSnippet(){const t=this.context.outputTextureLayout;return t.isPacked?this.getPackedOutputSamplingSnippet(t):this.getUnpackedOutputSamplingSnippet(t)}getPackedOutputSamplingSnippet(t){const e=t.unpackedShape,n=[t.width,t.height],r={},a=\"getOutputCoords\";switch(e.length){case 0:r[a]=this.getOutputScalarCoords();break;case 1:r[a]=this.getOutputPacked1DCoords(e,n);break;case 2:r[a]=this.getOutputPacked2DCoords(e,n);break;case 3:r[a]=this.getOutputPacked3DCoords(e,n);break;default:r[a]=this.getOutputPackedNDCoords(e,n)}const s=`\\n      void setOutput(vec4 val) {\\n        ${(0,o.getGlsl)(this.context.glContext.version).output} = val;\\n      }\\n    `;return r.floatTextureSetRGBA=new i.GlslLibRoutine(s),r}getUnpackedOutputSamplingSnippet(t){const e=t.unpackedShape,n=[t.width,t.height],r={},a=\"getOutputCoords\";switch(e.length){case 0:r[a]=this.getOutputScalarCoords();break;case 1:r[a]=this.getOutputUnpacked1DCoords(e,n);break;case 2:r[a]=this.getOutputUnpacked2DCoords(e,n);break;case 3:r[a]=this.getOutputUnpacked3DCoords(e,n);break;case 4:r[a]=this.getOutputUnpacked4DCoords(e,n);break;case 5:r[a]=this.getOutputUnpacked5DCoords(e,n);break;case 6:r[a]=this.getOutputUnpacked6DCoords(e,n);break;default:throw new Error(`Unsupported output dimensionality: ${e.length}`)}const s=`\\n        void setOutput(float val) {\\n          ${(0,o.getGlsl)(this.context.glContext.version).output} = vec4(val, 0, 0, 0);\\n        }\\n    `;return r.floatTextureSetR=new i.GlslLibRoutine(s),r}getOutputScalarCoords(){return new i.GlslLibRoutine(\"\\n      int getOutputCoords() {\\n        return 0;\\n      }\\n    \")}getOutputPacked1DCoords(t,e){const n=e;let r=\"\";return 1===n[0]?(r=`\\n          int getOutputCoords() {\\n            return 2 * int(TexCoords.y * ${n[1]}.0);\\n          }\\n        `,new i.GlslLibRoutine(r)):1===n[1]?(r=`\\n          int getOutputCoords() {\\n            return 2 * int(TexCoords.x * ${n[0]}.0);\\n          }\\n        `,new i.GlslLibRoutine(r)):(r=`\\n        int getOutputCoords() {\\n          ivec2 resTexRC = ivec2(TexCoords.xy *\\n                                 vec2(${n[0]}, ${n[1]}));\\n          return 2 * (resTexRC.y * ${n[0]} + resTexRC.x);\\n        }\\n      `,new i.GlslLibRoutine(r))}getOutputPacked2DCoords(t,e){let n=\"\";if(r.ArrayUtil.arraysEqual(t,e))return n=`\\n        ivec2 getOutputCoords() {\\n          return 2 * ivec2(TexCoords.xy * vec2(${e[0]}, ${e[1]}));\\n        }\\n      `,new i.GlslLibRoutine(n);const o=e,a=Math.ceil(t[1]/2);return n=`\\n        ivec2 getOutputCoords() {\\n          ivec2 resTexRC = ivec2(TexCoords.xy *\\n                                vec2(${o[0]}, ${o[1]}));\\n\\n          int index = resTexRC.y * ${o[0]} + resTexRC.x;\\n\\n          // reverse r and c order for packed texture\\n          int r = imod(index, ${a}) * 2;\\n          int c = 2 * (index / ${a});\\n\\n          return ivec2(r, c);\\n        }\\n      `,new i.GlslLibRoutine(n)}getOutputPacked3DCoords(t,e){const n=[e[0],e[1]],r=Math.ceil(t[2]/2),o=r*Math.ceil(t[1]/2),a=`\\n        ivec3 getOutputCoords() {\\n          ivec2 resTexRC = ivec2(TexCoords.xy *\\n                                vec2(${n[0]}, ${n[1]}));\\n          int index = resTexRC.y * ${n[0]} + resTexRC.x;\\n\\n          int b = index / ${o};\\n          index -= b * ${o};\\n\\n          // reverse r and c order for packed texture\\n          int r = imod(index, ${r}) * 2;\\n          int c = 2 * (index / ${r});\\n\\n          return ivec3(b, r, c);\\n        }\\n      `;return new i.GlslLibRoutine(a)}getOutputPackedNDCoords(t,e){const n=[e[0],e[1]],r=Math.ceil(t[t.length-1]/2),o=r*Math.ceil(t[t.length-2]/2);let a=o,s=\"\",u=\"b, r, c\";for(let e=2;e<t.length-1;e++)a*=t[t.length-e-1],s=`\\n      int b${e} = index / ${a};\\n      index -= b${e} * ${a};\\n    `+s,u=`b${e}, `+u;const c=`\\n      ivec${t.length} getOutputCoords() {\\n        ivec2 resTexRC = ivec2(TexCoords.xy *\\n                              vec2(${n[0]}, ${n[1]}));\\n        int index = resTexRC.y * ${n[0]} + resTexRC.x;\\n\\n        ${s}\\n\\n        int b = index / ${o};\\n        index -= b * ${o};\\n\\n        // reverse r and c order for packed texture\\n        int r = imod(index, ${r}) * 2;\\n        int c = 2 * (index / ${r});\\n\\n        return ivec${t.length}(${u});\\n      }\\n    `;return new i.GlslLibRoutine(c)}getOutputUnpacked1DCoords(t,e){const n=`\\n        int getOutputCoords() {\\n          ivec2 resTexRC = ivec2(TexCoords.xy *\\n                                vec2(${e[0]}, ${e[1]}));\\n          return resTexRC.y * ${e[0]} + resTexRC.x;\\n        }\\n      `;return new i.GlslLibRoutine(n)}getOutputUnpacked2DCoords(t,e){const n=`\\n        ivec2 getOutputCoords() {\\n          ivec2 resTexRC = ivec2(TexCoords.xy *\\n                                vec2(${e[0]}, ${e[1]}));\\n          int index = resTexRC.y * ${e[0]} + resTexRC.x;\\n          int r = index / ${t[1]};\\n          int c = index - r * ${t[1]};\\n          return ivec2(r, c);\\n        }\\n      `;return new i.GlslLibRoutine(n)}getOutputUnpacked3DCoords(t,e){let n=\"\";const r=t.length;let o=null;r<2&&(o=[]),o=new Array(r-1),o[r-2]=t[r-1];for(let e=r-3;e>=0;--e)o[e]=o[e+1]*t[e+1];const a=[\"r\",\"c\",\"d\"],s=o.map(((t,e)=>`int ${a[e]} = index / ${t}; ${e===o.length-1?`int ${a[e+1]} = index - ${a[e]} * ${t}`:`index -= ${a[e]} * ${t}`};`)).join(\"\");return n=`\\n        ivec3 getOutputCoords() {\\n          ivec2 resTexRC = ivec2(TexCoords.xy *\\n                                vec2(${e[0]}, ${e[1]}));\\n          int index = resTexRC.y * ${e[0]} + resTexRC.x;\\n          ${s}\\n          return ivec3(r, c, d);\\n        }\\n      `,new i.GlslLibRoutine(n)}getOutputUnpacked4DCoords(t,e){let n=\"\";const r=t.length;let o=null;r<2&&(o=[]),o=new Array(r-1),o[r-2]=t[r-1];for(let e=r-3;e>=0;--e)o[e]=o[e+1]*t[e+1];const a=[\"r\",\"c\",\"d\",\"d2\"],s=o.map(((t,e)=>`int ${a[e]} = index / ${t}; ${e===o.length-1?`int ${a[e+1]} = index - ${a[e]} * ${t}`:`index -= ${a[e]} * ${t}`};`)).join(\"\");return n=`\\n      ivec4 getOutputCoords() {\\n          ivec2 resTexRC = ivec2(TexCoords.xy *\\n                                vec2(${e[0]}, ${e[1]}));\\n          int index = resTexRC.y * ${e[0]} + resTexRC.x;\\n          ${s}\\n          return ivec4(r, c, d, d2);\\n        }\\n      `,new i.GlslLibRoutine(n)}getOutputUnpacked5DCoords(t,e){let n=\"\";const r=t.length;let o=null;r<2&&(o=[]),o=new Array(r-1),o[r-2]=t[r-1];for(let e=r-3;e>=0;--e)o[e]=o[e+1]*t[e+1];const a=[\"r\",\"c\",\"d\",\"d2\",\"d3\"],s=o.map(((t,e)=>`int ${a[e]} = index / ${t}; ${e===o.length-1?`int ${a[e+1]} = index - ${a[e]} * ${t}`:`index -= ${a[e]} * ${t}`};`)).join(\"\");return n=`\\n      ivec5 getOutputCoords() {\\n          ivec2 resTexRC = ivec2(TexCoords.xy *\\n                                vec2(${e[0]}, ${e[1]}));\\n          int index = resTexRC.y * ${e[0]} + resTexRC.x;\\n          ${s}\\n          return ivec5(r, c, d, d2, d3);\\n        }\\n      `,new i.GlslLibRoutine(n)}getOutputUnpacked6DCoords(t,e){let n=\"\";const r=t.length;let o=null;r<2&&(o=[]),o=new Array(r-1),o[r-2]=t[r-1];for(let e=r-3;e>=0;--e)o[e]=o[e+1]*t[e+1];const a=[\"r\",\"c\",\"d\",\"d2\",\"d3\",\"d4\"],s=o.map(((t,e)=>`int ${a[e]} = index / ${t}; ${e===o.length-1?`int ${a[e+1]} = index - ${a[e]} * ${t}`:`index -= ${a[e]} * ${t}`};`)).join(\"\");return n=`\\n     ivec6 getOutputCoords() {\\n         ivec2 resTexRC = ivec2(TexCoords.xy *\\n                               vec2(${e[0]}, ${e[1]}));\\n         int index = resTexRC.y * ${e[0]} + resTexRC.x;\\n         ${s}\\n         return ivec6(r, c, d, d2, d3, d4);\\n       }\\n     `,new i.GlslLibRoutine(n)}getCommonUtilFuncs(){const t={};let e=\"uvFromFlat\";t[e]=new i.GlslLibRoutine(\"\\n    vec2 uvFromFlat(int texNumR, int texNumC, int index) {\\n      int texC = index / texNumR;\\n      int texR = index - texC * texNumR;\\n      // TODO: swap texR, texC order in following function so row is corresponding to u and column is corresponding to\\n      //       v.\\n      return (vec2(texR, texC) + halfCR) / vec2(texNumR, texNumC);\\n    }\\n    \"),e=\"packedUVfrom1D\",t[e]=new i.GlslLibRoutine(\"\\n      vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\\n        int texelIndex = index / 2;\\n        int texR = texelIndex / texNumC;\\n        int texC = texelIndex - texR * texNumC;\\n        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\\n      }\\n      \"),e=\"packedUVfrom2D\",t[e]=new i.GlslLibRoutine(\"\\n      vec2 packedUVfrom2D(int texNumR, int texNumC, int texelsInLogicalRow, int row, int col) {\\n        int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\\n        int texR = texelIndex / texNumC;\\n        int texC = texelIndex - texR * texNumC;\\n        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\\n      }\\n      \"),e=\"packedUVfrom3D\",t[e]=new i.GlslLibRoutine(\"\\n      vec2 packedUVfrom3D(int texNumR, int texNumC,\\n          int texelsInBatch, int texelsInLogicalRow, int b,\\n          int row, int col) {\\n        int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\\n        int texR = index / texNumC;\\n        int texC = index - texR * texNumC;\\n        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\\n      }\\n      \"),e=\"sampleTexture\";const n=(0,o.getGlsl)(this.context.glContext.version);return t[e]=new i.GlslLibRoutine(`\\n        float sampleTexture(sampler2D textureSampler, vec2 uv) {\\n            return ${n.texture2D}(textureSampler, uv).r;\\n        }`),t}getInputsSamplingSnippets(){const t={},e=this.context.outputTextureLayout;return this.context.programInfo.inputNames.forEach(((n,r)=>{const i=this.context.inputTextureLayouts[r],o=(0,s.generateShaderFuncNameFromInputSamplerName)(n);i.isPacked?t[o]=this.getPackedSamplerFromInput(o,n,i):t[o]=this.getUnpackedSamplerFromInput(o,n,i);const a=(0,s.generateShaderFuncNameFromInputSamplerNameAtOutCoords)(n);i.unpackedShape.length<=e.unpackedShape.length&&(i.isPacked?t[a]=this.getPackedSamplerAtOutputCoords(a,i,e,n):t[a]=this.getUnpackedSamplerAtOutputCoords(a,i,e,n))})),t}getPackedSamplerAtOutputCoords(t,e,n,o){const a=e.unpackedShape,u=n.unpackedShape,c=o,l=(0,s.generateShaderFuncNameFromInputSamplerName)(c),p=a.length,f=u.length,d=r.BroadcastUtil.getBroadcastDims(a,u),h=(0,s.getCoordsDataType)(f),g=f-p;let b;const m=(0,s.getGlChannels)();b=0===p?\"\":f<2&&d.length>=1?\"coords = 0;\":d.map((t=>`coords.${m[t+g]} = 0;`)).join(\"\\n\");let y=\"\";y=f<2&&p>0?\"coords\":a.map(((t,e)=>`coords.${m[e+g]}`)).join(\", \");let _=\"return outputValue;\";const v=1===r.ShapeUtil.size(a),w=1===r.ShapeUtil.size(u);if(1!==p||v||w){if(v&&!w)_=1===f?\"\\n          return vec4(outputValue.x, outputValue.x, 0., 0.);\\n        \":\"\\n          return vec4(outputValue.x);\\n        \";else if(d.length){const t=p-2,e=p-1;d.indexOf(t)>-1&&d.indexOf(e)>-1?_=\"return vec4(outputValue.x);\":d.indexOf(t)>-1?_=\"return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);\":d.indexOf(e)>-1&&(_=\"return vec4(outputValue.xx, outputValue.zz);\")}}else _=\"\\n        return vec4(outputValue.xy, outputValue.xy);\\n      \";const x=`\\n      vec4 ${t}() {\\n        ${h} coords = getOutputCoords();\\n        \\n        int lastDim = coords.${m[f-1]};\\n        coords.${m[f-1]} = coords.${m[f-2]};\\n        coords.${m[f-2]} = lastDim;\\n      \\n        ${b}\\n        vec4 outputValue = ${l}(${y});\\n        ${_}\\n      }\\n    `;return new i.GlslLibRoutine(x,[\"coordinates.getOutputCoords\"])}getUnpackedSamplerAtOutputCoords(t,e,n,o){const a=[n.width,n.height],u=[e.width,e.height],c=e.unpackedShape.length,l=n.unpackedShape.length,p=e.unpackedShape,f=n.unpackedShape,d=(0,s.generateShaderFuncNameFromInputSamplerName)(o);if(c===l&&r.ArrayUtil.arraysEqual(u,a)){const e=`\\n          float ${t}() {\\n            return sampleTexture(${o}, TexCoords);\\n          }\\n        `;return new i.GlslLibRoutine(e,[\"coordinates.sampleTexture\"])}const h=(0,s.getCoordsDataType)(l),g=r.BroadcastUtil.getBroadcastDims(p,f),b=l-c;let m;const y=(0,s.getGlChannels)();m=0===c?\"\":l<2&&g.length>=1?\"coords = 0;\":g.map((t=>`coords.${y[t+b]} = 0;`)).join(\"\\n\");let _=\"\";_=l<2&&c>0?\"coords\":e.unpackedShape.map(((t,e)=>`coords.${y[e+b]}`)).join(\", \");const v=`\\n        float ${t}() {\\n          ${h} coords = getOutputCoords();\\n          ${m}\\n          return ${d}(${_});\\n        }\\n      `;return new i.GlslLibRoutine(v,[\"coordinates.getOutputCoords\"])}getPackedSamplerFromInput(t,e,n){switch(n.unpackedShape.length){case 0:return this.getPackedSamplerScalar(t,e);case 1:return this.getPackedSampler1D(t,e,n);case 2:return this.getPackedSampler2D(t,e,n);case 3:return this.getPackedSampler3D(t,e,n);default:return this.getPackedSamplerND(t,e,n)}}getUnpackedSamplerFromInput(t,e,n){const r=n.unpackedShape;switch(r.length){case 0:return this.getUnpackedSamplerScalar(t,e,n);case 1:return this.getUnpackedSampler1D(t,e,n);case 2:return this.getUnpackedSampler2D(t,e,n);case 3:return this.getUnpackedSampler3D(t,e,n);case 4:return this.getUnpackedSampler4D(t,e,n);case 5:return this.getUnpackedSampler5D(t,e,n);case 6:return this.getUnpackedSampler6D(t,e,n);default:throw new Error(`Unsupported dimension ${r.length}-D`)}}getPackedSamplerScalar(t,e){const n=`\\n          vec4 ${t}() {\\n            return ${(0,o.getGlsl)(this.context.glContext.version).texture2D}(${e}, halfCR);\\n          }\\n        `;return new i.GlslLibRoutine(n)}getPackedSampler1D(t,e,n){const r=[n.width,n.height],a=[r[1],r[0]],s=(0,o.getGlsl)(this.context.glContext.version),u=`vec4 ${t}(int index) {\\n      vec2 uv = packedUVfrom1D(\\n      ${a[0]}, ${a[1]}, index);\\n      return ${s.texture2D}(${e}, uv);\\n    }`;return new i.GlslLibRoutine(u,[\"coordinates.packedUVfrom1D\"])}getPackedSampler2D(t,e,n){const a=n.unpackedShape,s=[n.width,n.height],u=(0,o.getGlsl)(this.context.glContext.version),c=s[0],l=s[1];if(null!=s&&r.ArrayUtil.arraysEqual(a,s)){const n=`vec4 ${t}(int row, int col) {\\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${l}.0, ${c}.0);\\n        return ${u.texture2D}(${e}, uv);\\n      }`;return new i.GlslLibRoutine(n)}const p=s,f=Math.ceil(a[1]/2),d=`vec4 ${t}(int row, int col) {\\n      vec2 uv = packedUVfrom2D(${p[1]}, ${p[0]}, ${f}, row, col);\\n      return ${u.texture2D}(${e}, uv);\\n    }`;return new i.GlslLibRoutine(d,[\"coordinates.packedUVfrom2D\"])}getPackedSampler3D(t,e,n){const r=n.unpackedShape,a=[n.width,n.height],u=[a[0],a[1]],c=(0,o.getGlsl)(this.context.glContext.version);if(1===r[0]){const o=r.slice(1),a=[1,2],u=(0,s.squeezeInputShape)(r,o),c=[\"b\",\"row\",\"col\"],l=JSON.parse(JSON.stringify(n));l.unpackedShape=u;const p=this.getPackedSamplerFromInput(t,e,l),f=`${p.routineBody}\\n      vec4 ${t}(int b, int row, int col) {\\n        return ${t}(${(0,s.getSqueezedParams)(c,a)});\\n      } `;return new i.GlslLibRoutine(f,p.dependencies)}const l=u[0],p=u[1],f=Math.ceil(r[2]/2),d=`vec4 ${t}(int b, int row, int col) {\\n      vec2 uv = packedUVfrom3D(\\n        ${p}, ${l}, ${f*Math.ceil(r[1]/2)}, ${f}, b, row, col);\\n      return ${c.texture2D}(${e}, uv);}`;return new i.GlslLibRoutine(d,[\"coordinates.packedUVfrom3D\"])}getPackedSamplerND(t,e,n){const r=n.unpackedShape,a=r.length,s=[n.width,n.height],u=(0,o.getGlsl)(this.context.glContext.version),c=[s[0],s[1]],l=c[1],p=c[0],f=Math.ceil(r[a-1]/2);let d=f*Math.ceil(r[a-2]/2),h=\"int b, int row, int col\",g=`b * ${d} + (row / 2) * ${f} + (col / 2)`;for(let t=2;t<a-1;t++)h=`int b${t}, `+h,d*=r[a-t-1],g=`b${t} * ${d} + `+g;const b=`vec4 ${t}(${h}) {\\n      int index = ${g};\\n      int texR = index / ${p};\\n      int texC = index - texR * ${p};\\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${p}, ${l});\\n      return ${u.texture2D}(${e}, uv);\\n    }`;return new i.GlslLibRoutine(b)}getUnpackedSamplerScalar(t,e,n){const[r,o]=[n.width,n.height];if(1===r&&1===o){const n=`\\n          float ${t}() {\\n            return sampleTexture(${e}, halfCR);\\n          }\\n        `;return new i.GlslLibRoutine(n,[\"coordinates.sampleTexture\"])}const a=`\\n        float ${t}() {\\n          int offset_${e} = coordsToOffset(TexCoords, ${r}, ${o});\\n          vec2 uv = uvFromFlat(${r}, ${o}, offset_${e});\\n          return sampleTexture(${e}, uv);\\n        }\\n      `;return new i.GlslLibRoutine(a,[\"coordinates.uvFromFlat\",\"coordinates.sampleTexture\",\"coordinates.coordsToOffset\"])}getUnpackedSampler1D(t,e,n){const r=n.width,o=n.height;if(1===o&&1===r){const n=`\\n        float ${t}(int index) {\\n          return sampleTexture(${e}, halfCR);\\n        }\\n      `;return new i.GlslLibRoutine(n,[\"coordinates.sampleTexture\"])}if(1===o){const n=`\\n          float ${t}(int index) {\\n            vec2 uv = vec2((float(index) + 0.5) / ${r}.0, 0.5);\\n            return sampleTexture(${e}, uv);\\n          }\\n        `;return new i.GlslLibRoutine(n,[\"coordinates.sampleTexture\"])}if(1===r){const n=`\\n          float ${t}(int index) {\\n            vec2 uv = vec2(0.5, (float(index) + 0.5) / ${o}.0);\\n            return sampleTexture(${e}, uv);\\n          }\\n        `;return new i.GlslLibRoutine(n,[\"coordinates.sampleTexture\"])}const a=`\\n        float ${t}(int index) {\\n          vec2 uv = uvFromFlat(${r}, ${o}, index);\\n          return sampleTexture(${e}, uv);\\n        }\\n      `;return new i.GlslLibRoutine(a,[\"coordinates.uvFromFlat\",\"coordinates.sampleTexture\"])}getUnpackedSampler2D(t,e,n){const o=n.unpackedShape,u=[n.height,n.width];if(null!=u&&r.ArrayUtil.arraysEqual(o,u)){const n=`\\n          float ${t}(int row, int col) {\\n            vec2 uv = (vec2(row, col) + halfCR) / vec2(${u[1]}.0, ${u[0]}.0);\\n            return sampleTexture(${e}, uv);\\n          }\\n        `;return new i.GlslLibRoutine(n,[\"coordinates.sampleTexture\"])}const{newShape:c,keptDims:l}=(0,a.squeezeShape)(o),p=c;if(p.length<o.length){const r=(0,s.squeezeInputShape)(o,p),a=JSON.parse(JSON.stringify(n));a.unpackedShape=r;const u=[\"col\",\"row\"],c=`\\n          ${this.getUnpackedSamplerFromInput(t,e,a).routineBody}\\n          float ${t}(int row, int col) {\\n            return ${t}(${(0,s.getSqueezedParams)(u,l)});\\n          }\\n        `;return new i.GlslLibRoutine(c,[\"coordinates.sampleTexture\"])}const f=u[1],d=u[0];if(1===d){const n=`\\n          float ${t}(int row, int col) {\\n            int offset_${e} = coordsToOffset(TexCoords, ${f}, ${d});\\n            float index = dot(vec3(row, col, offset_${e}), vec3(${o[1]}, 1, 1));\\n            vec2 uv = vec2(0.5, (index + 0.5) / ${f}.0);\\n            return sampleTexture(${e}, uv);\\n          }\\n        `;return new i.GlslLibRoutine(n,[\"coordinates.sampleTexture\",\"coordinates.coordsToOffset\"])}if(1===f){const n=`\\n          float ${t}(int row, int col) {\\n            int offset_${e} = coordsToOffset(TexCoords, ${f}, ${d});\\n            float index = dot(vec3(row, col, offset_${e}), vec3(${o[1]}, 1, 1));\\n            vec2 uv = vec2((index + 0.5) / ${d}.0, 0.5);\\n            return sampleTexture(${e}, uv);\\n          }\\n        `;return new i.GlslLibRoutine(n,[\"coordinates.sampleTexture\",\"coordinates.coordsToOffset\"])}const h=`\\n        float ${t}(int row, int col) {\\n          int index = col * ${o[1]} + row;\\n          vec2 uv = uvFromFlat(${f}, ${d}, index);\\n          return sampleTexture(${e}, uv);\\n        }\\n      `;return new i.GlslLibRoutine(h,[\"coordinates.uvFromFlat\",\"coordinates.sampleTexture\",\"coordinates.coordsToOffset\"])}getUnpackedSampler3D(t,e,n){const r=n.unpackedShape,o=r[1]*r[2],u=r[2],{newShape:c,keptDims:l}=(0,a.squeezeShape)(r),p=c;if(p.length<r.length){const o=(0,s.squeezeInputShape)(r,p),a=[\"batch\",\"col\",\"row\"],u=JSON.parse(JSON.stringify(n));u.unpackedShape=o;const c=this.getUnpackedSamplerFromInput(t,e,u),f=l.reverse(),d=`\\n          ${c.routineBody}\\n          float ${t}(int batch, int row, int col) {\\n            return ${t}(${(0,s.getSqueezedParams)(a,f)});\\n          }\\n        `;return new i.GlslLibRoutine(d,c.dependencies)}const f=`\\n          float ${t}(int depth, int row, int col) {\\n            // Explicitly use integer operations as dot() only works on floats.\\n            int index = depth * ${o} + col * ${u} + row;\\n            vec2 uv = uvFromFlat(${n.width}, ${n.height}, index);\\n            return sampleTexture(${e}, uv);\\n          }\\n      `;return new i.GlslLibRoutine(f,[\"coordinates.uvFromFlat\",\"coordinates.sampleTexture\",\"coordinates.coordsToOffset\"])}getUnpackedSampler4D(t,e,n){const r=n.unpackedShape,o=r[3],a=r[2]*o,s=`\\n        float ${t}(int row, int col, int depth, int depth2) {\\n          int index = row * ${r[1]*a} + col * ${a} +\\n              depth2 * ${o} + depth;\\n          vec2 uv = uvFromFlat(${n.width}, ${n.height}, index);\\n          return sampleTexture(${e}, uv);\\n        }\\n      `;return new i.GlslLibRoutine(s,[\"coordinates.uvFromFlat\",\"coordinates.sampleTexture\"])}getUnpackedSampler5D(t,e,n){const r=n.unpackedShape,o=r[4],u=r[3]*o,c=r[2]*u,l=r[1]*c,{newShape:p,keptDims:f}=(0,a.squeezeShape)(r);if(p.length<r.length){const o=(0,s.squeezeInputShape)(r,p),a=[\"row\",\"col\",\"depth\",\"depth2\",\"depth3\"],u=JSON.parse(JSON.stringify(n));u.unpackedShape=o;const c=`\\n          ${this.getUnpackedSamplerFromInput(t,e,u).routineBody}\\n          float ${t}(int row, int col, int depth, int depth2, int depth3) {\\n            return ${t}(${(0,s.getSqueezedParams)(a,f)});\\n          }\\n        `;return new i.GlslLibRoutine(c,[\"coordinates.sampleTexture\",\"coordinates.uvFromFlat\"])}const d=`\\n        float ${t}(int row, int col, int depth, int depth2, int depth3) {\\n          int index = row * ${l} + col * ${c} + depth * ${u} +\\n          depth3 * ${o} + depth2;\\n          vec2 uv = uvFromFlat(${n.width}, ${n.height}, index);\\n          return sampleTexture(${e}, uv);\\n        }\\n      `;return new i.GlslLibRoutine(d,[\"coordinates.sampleTexture\",\"coordinates.uvFromFlat\"])}getUnpackedSampler6D(t,e,n){const r=n.unpackedShape,o=r[5],u=r[4]*o,c=r[3]*u,l=r[2]*c,p=r[1]*l,{newShape:f,keptDims:d}=(0,a.squeezeShape)(r);if(f.length<r.length){const o=(0,s.squeezeInputShape)(r,f),a=[\"row\",\"col\",\"depth\",\"depth2\",\"depth3\",\"depth4\"],u=JSON.parse(JSON.stringify(n));u.unpackedShape=o;const c=`\\n            ${this.getUnpackedSamplerFromInput(t,e,u).routineBody}\\n            float ${t}(int row, int col, int depth,\\n              int depth2, int depth3, int depth4) {\\n              return ${t}(${(0,s.getSqueezedParams)(a,d)});\\n            }\\n          `;return new i.GlslLibRoutine(c,[\"coordinates.sampleTexture\",\"coordinates.uvFromFlat\"])}const h=`\\n          float ${t}(int row, int col, int depth,\\n            int depth2, int depth3, int depth4) {\\n            int index = row * ${p} + col * ${l} + depth * ${c} +\\n            depth2 * ${u} + depth3 * ${o} + depth4;\\n            vec2 uv = uvFromFlat(${n.width}, ${n.height}, index);\\n            return sampleTexture(${e}, uv);\\n          }\\n        `;return new i.GlslLibRoutine(h,[\"coordinates.uvFromFlat\",\"coordinates.sampleTexture\",\"coordinates.coordsToOffset\"])}toVec(){const t=this.context.outputTextureLayout,e=t.shape.length,n=t.strides,r=t.width,o=t.height,a=[];for(let t=0;t<e-1;++t)a.push(`\\n        c[${t}] = offset / ${n[t]};`),a.push(`\\n        offset -= c[${t}] * ${n[t]};`);a.push(`\\n        c[${e-1}] = offset;`);const s=`\\n      void toVec(vec2 texCoords, out int c[${e}]) {\\n        int offset = coordsToOffset(texCoords, ${r}, ${o});\\n        ${a.join(\"\")}\\n      }\\n      void toVec(int offset, out int c[${e}]) {\\n        ${a.join(\"\")}\\n      }\\n    `;return{toVec:new i.GlslLibRoutine(s,[\"coordinates.coordsToOffset\"])}}valueFrom(){const t={};return this.context.programInfo.inputNames.forEach(((e,n)=>{const r=this.context.inputTextureLayouts[n],o=(r.unpackedShape.length>0?r.unpackedShape:r.shape).length;let a=`_${e}`;t[a]=new i.GlslLibRoutine(this.getValueFromSingle(e,o,r.width,r.height,!1),[`shapeUtils.indicesToOffset${a}`,\"coordinates.offsetToCoords\",\"fragcolor.getColorAsFloat\"]),a+=\"_T\",t[a]=new i.GlslLibRoutine(this.getValueFromSingle(e,o,r.width,r.height,!0),[`shapeUtils.indicesToOffset${a}`,\"coordinates.offsetToCoords\",\"fragcolor.getColorAsFloat\"])})),t}getValueFromSingle(t,e,n,r,i){let a=`_${t}`;return i&&(a+=\"_T\"),`\\n        float ${a}(int m[${e}]) {\\n          int offset = indicesToOffset${a}(m);\\n          vec2 coords = offsetToCoords(offset, ${n}, ${r});\\n          float value = getColorAsFloat(${(0,o.getGlsl)(this.context.glContext.version).texture2D}(${t}, coords));\\n          return value;\\n        }\\n        `}getPackedValueFrom(t,e,n,r,i){let a=`_${t}_Pack`;return i&&(a+=\"_T\"),`\\n        vec4 ${a}(int m[${e}]) {\\n          int offset = indicesToOffset_${t}(m);\\n          vec2 coords = offsetToCoords(offset, ${n}, ${r});\\n          return ${(0,o.getGlsl)(this.context.glContext.version).texture2D}(${t}, coords);\\n        }\\n        `}}e.CoordsGlslLib=u},8520:(t,e)=>{\"use strict\";var n;Object.defineProperty(e,\"__esModule\",{value:!0}),e.TopologicalSortGlslRoutines=e.GlslLibRoutineNode=e.GlslLibRoutine=e.GlslLib=e.GlslContext=e.FunctionType=void 0,(n=e.FunctionType||(e.FunctionType={}))[n.ValueBased=0]=\"ValueBased\",n[n.Positional=1]=\"Positional\",e.GlslContext=class{constructor(t,e,n,r){this.glContext=t,this.programInfo=e,this.inputTextureLayouts=n,this.outputTextureLayout=r}},e.GlslLib=class{constructor(t){this.context=t}},e.GlslLibRoutine=class{constructor(t,e){this.routineBody=t,this.dependencies=e}},e.GlslLibRoutineNode=class{constructor(t,e,n){this.name=t,this.dependencies=n||[],e&&(this.routineBody=e)}addDependency(t){t&&this.dependencies.push(t)}},e.TopologicalSortGlslRoutines=class{static returnOrderedNodes(t){if(!t||0===t.length)return[];if(1===t.length)return t;const e=new Set,n=new Set,r=new Array;return this.createOrderedNodes(t,e,n,r),r}static createOrderedNodes(t,e,n,r){for(let i=0;i<t.length;++i)this.dfsTraverse(t[i],e,n,r)}static dfsTraverse(t,e,n,r){if(!t||n.has(t.name))return;if(e.has(t.name))throw new Error(\"Cyclic dependency detected. Can't topologically sort routines needed for shader.\");e.add(t.name);const i=t.dependencies;if(i&&i.length>0)for(let t=0;t<i.length;++t)this.dfsTraverse(i[t],e,n,r);r.push(t),n.add(t.name),e.delete(t.name)}}},7341:(t,e,n)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.EncodingGlslLib=void 0;const r=n(8520);class i extends r.GlslLib{constructor(t){super(t)}getFunctions(){return Object.assign(Object.assign({},this.encodeFloat32()),this.decodeFloat32())}getCustomTypes(){return{}}encodeFloat32(){return{encode:new r.GlslLibRoutine(\"highp vec4 encode(highp float f) {\\n        return vec4(f, 0.0, 0.0, 0.0);\\n      }\\n        \")}}decodeFloat32(){return{decode:new r.GlslLibRoutine(\"highp float decode(highp vec4 rgba) {\\n        return rgba.r;\\n      }\\n        \")}}encodeUint8(){const t=i.isLittleEndian()?\"rgba.rgba=rgba.abgr;\":\"\";return{encode:new r.GlslLibRoutine(`\\n      highp vec4 encode(highp float f) {\\n        highp float F = abs(f);\\n        highp float Sign = step(0.0,-f);\\n        highp float Exponent = floor(log2(F));\\n        highp float Mantissa = (exp2(- Exponent) * F);\\n        Exponent = floor(log2(F) + 127.0) + floor(log2(Mantissa));\\n        highp vec4 rgba;\\n        rgba[0] = 128.0 * Sign  + floor(Exponent*exp2(-1.0));\\n        rgba[1] = 128.0 * mod(Exponent,2.0) + mod(floor(Mantissa*128.0),128.0);\\n        rgba[2] = floor(mod(floor(Mantissa*exp2(23.0 -8.0)),exp2(8.0)));\\n        rgba[3] = floor(exp2(23.0)*mod(Mantissa,exp2(-15.0)));\\n        ${t}\\n        rgba = rgba / 255.0; // values need to be normalized to [0,1]\\n        return rgba;\\n    }\\n        `)}}decodeUint8(){const t=i.isLittleEndian()?\"rgba.rgba=rgba.abgr;\":\"\";return{decode:new r.GlslLibRoutine(`\\n        highp float decode(highp vec4 rgba) {\\n          rgba = rgba * 255.0; // values need to be de-normalized from [0,1] to [0,255]\\n          ${t}\\n          highp float Sign = 1.0 - step(128.0,rgba[0])*2.0;\\n          highp float Exponent = 2.0 * mod(rgba[0],128.0) + step(128.0,rgba[1]) - 127.0;\\n          highp float Mantissa = mod(rgba[1],128.0)*65536.0 + rgba[2]*256.0 +rgba[3] + float(0x800000);\\n          highp float Result =  Sign * exp2(Exponent) * (Mantissa * exp2(-23.0 ));\\n          return Result;\\n      }\\n        `)}}static isLittleEndian(){const t=new ArrayBuffer(4),e=new Uint32Array(t),n=new Uint8Array(t);if(e[0]=3735928559,239===n[0])return!0;if(222===n[0])return!1;throw new Error(\"unknown endianness\")}}e.EncodingGlslLib=i},9894:(t,e,n)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.FragColorGlslLib=void 0;const r=n(8520),i=n(5060);class o extends r.GlslLib{constructor(t){super(t)}getFunctions(){return Object.assign(Object.assign({},this.setFragColor()),this.getColorAsFloat())}getCustomTypes(){return{}}setFragColor(){const t=(0,i.getGlsl)(this.context.glContext.version);return{setFragColor:new r.GlslLibRoutine(`\\n        void setFragColor(float value) {\\n            ${t.output} = encode(value);\\n        }\\n        `,[\"encoding.encode\"])}}getColorAsFloat(){return{getColorAsFloat:new r.GlslLibRoutine(\"\\n        float getColorAsFloat(vec4 color) {\\n            return decode(color);\\n        }\\n        \",[\"encoding.decode\"])}}}e.FragColorGlslLib=o},2848:(t,e)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.replaceInlines=void 0;const n=/@inline[\\s\\n\\r]+(\\w+)[\\s\\n\\r]+([0-9a-zA-Z_]+)\\s*\\(([^)]*)\\)\\s*{(([^}]|[\\n\\r])*)}/gm;e.replaceInlines=function(t){const e={};let r;for(;null!==(r=n.exec(t));){const t=r[3].split(\",\").map((t=>{const e=t.trim().split(\" \");return e&&2===e.length?{type:e[0],name:e[1]}:null})).filter((t=>null!==t));e[r[2]]={params:t,body:r[4]}}for(const n in e){const i=\"(\\\\w+)?\\\\s+([_0-9a-zA-Z]+)\\\\s+=\\\\s+__FUNC__\\\\((.*)\\\\)\\\\s*;\".replace(\"__FUNC__\",n),o=new RegExp(i,\"gm\");for(;null!==(r=o.exec(t));){const i=r[1],o=r[2],a=r[3].split(\",\"),s=i?`${i} ${o};`:\"\";let u=e[n].body,c=\"\";e[n].params.forEach(((t,e)=>{t&&(c+=`${t.type} ${t.name} = ${a[e]};\\n`)})),u=`${c}\\n ${u}`,u=u.replace(\"return\",`${o} = `);const l=`\\n      ${s}\\n      {\\n        ${u}\\n      }\\n      `;t=t.replace(r[0],l)}}return t.replace(n,\"\")}},8879:(t,e,n)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.GlslPreprocessor=void 0;const r=n(8520),i=n(2848),o=n(5483),a=n(5060);e.GlslPreprocessor=class{constructor(t,e,n,i){this.libs={},this.glslLibRoutineDependencyGraph={},this.context=new r.GlslContext(t,e,n,i),Object.keys(o.glslRegistry).forEach((t=>{const e=new o.glslRegistry[t](this.context);this.libs[t]=e}));const a=this.glslLibRoutineDependencyGraph;for(const t in this.libs){const e=this.libs[t].getFunctions();for(const n in e){const i=t+\".\"+n;let o;a[i]?(o=a[i],o.routineBody=e[n].routineBody):(o=new r.GlslLibRoutineNode(i,e[n].routineBody),a[i]=o);const s=e[n].dependencies;if(s)for(let t=0;t<s.length;++t)if(a[s[t]])o.addDependency(a[s[t]]);else{const e=new r.GlslLibRoutineNode(s[t]);a[s[t]]=e,o.addDependency(e)}}}}preprocess(){const t=this.context.programInfo;let e=t.shaderSource;return this.context.programInfo.hasMain||(e=`${e}\\n      ${(0,a.getDefaultFragShaderMain)(this.context.glContext.version,this.context.outputTextureLayout.shape.length)}`),e=(0,i.replaceInlines)(e),`${(0,a.getFragShaderPreamble)(this.context.glContext.version)}\\n    ${this.getUniforms(t.inputNames,t.variables)}\\n    ${this.getImports(e)}\\n    ${e}`}getImports(t){const e=this.selectGlslLibRoutinesToBeIncluded(t);if(0===e.length)return\"\";let n=\"\";for(let t=0;t<e.length;++t){if(!e[t].routineBody)throw new Error(`Missing body for the Glsl Library routine: ${e[t].name}`);n+=e[t].routineBody+\"\\n\"}return n}selectGlslLibRoutinesToBeIncluded(t){const e=[];return Object.keys(this.glslLibRoutineDependencyGraph).forEach((n=>{const r=n.split(\".\")[1];-1!==t.indexOf(r)&&e.push(this.glslLibRoutineDependencyGraph[n])})),r.TopologicalSortGlslRoutines.returnOrderedNodes(e)}getUniforms(t,e){const n=[];if(t)for(const e of t)n.push(`uniform sampler2D ${e};`);if(e)for(const t of e)n.push(`uniform ${t.type} ${t.name}${t.arrayLength?`[${t.arrayLength}]`:\"\"};`);return n.join(\"\\n\")}}},5483:(t,e,n)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.glslRegistry=void 0;const r=n(5107),i=n(7341),o=n(9894),a=n(2655),s=n(3891);e.glslRegistry={encoding:i.EncodingGlslLib,fragcolor:o.FragColorGlslLib,vec:s.VecGlslLib,shapeUtils:a.ShapeUtilsGlslLib,coordinates:r.CoordsGlslLib}},2655:(t,e,n)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.ShapeUtilsGlslLib=void 0;const r=n(8520);class i extends r.GlslLib{constructor(t){super(t)}getFunctions(){return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({},this.bcastIndex()),this.bcastMatmulIndex()),this.offsetToIndices()),this.indicesToOffset()),this.incrementIndices())}getCustomTypes(){return{}}bcastIndex(){const t=this.context.outputTextureLayout.shape.length,e={};return this.context.programInfo.inputNames.forEach(((n,i)=>{const o=this.context.inputTextureLayouts[i].unpackedShape;if(o.length<=t){const i=o.length,a=t-i,s=`bcastIndices_${n}`;let u=\"\";for(let t=0;t<i;++t)u+=`\\n          realIndices[${t}] = int( mod(float(bcastedIndices[${a+t}]), ${o[t]}.0) );\\n          `;const c=`\\n        void ${s} (int bcastedIndices[${t}], out int realIndices[${i}]) {\\n          ${u}\\n        }\\n        `;e[s]=new r.GlslLibRoutine(c)}})),e}bcastMatmulIndex(){const t=this.context.outputTextureLayout.shape.length,e={};return this.context.programInfo.inputNames.forEach(((n,i)=>{const o=this.context.inputTextureLayouts[i].shape;if(!(o.length<2||o.length>t)){const i=o.length,a=t-i,s=`bcastMatmulIndices_${n}`;let u=\"\";for(let t=0;t<i-2;++t)u+=`\\n          realIndices[${t}] = int( mod(float(bcastedIndices[${a+t}]), ${o[t]}.0) );\\n          `;const c=`\\n        void ${s}(int bcastedIndices[${t}], out int realIndices[${i}]) {\\n          ${u}\\n          realIndices[${i-1}] = bcastedIndices[${t-1}];\\n          realIndices[${i-2}] = bcastedIndices[${t-2}];\\n        }\\n        `;e[s]=new r.GlslLibRoutine(c)}})),e}indicesToOffset(){const t={};return this.context.programInfo.inputNames.forEach(((e,n)=>{const o=this.context.inputTextureLayouts[n].shape,a=this.context.inputTextureLayouts[n].strides,s=o.length;let u=`indicesToOffset_${e}`;t[u]=new r.GlslLibRoutine(i.indexToOffsetSingle(u,s,a)),u=`indicesToOffset_${e}_T`,t[u]=new r.GlslLibRoutine(i.indexToOffsetSingle(u,s,a.slice().reverse()))})),t}static indexToOffsetSingle(t,e,n){let r=\"\";for(let t=e-1;t>=0;--t)r+=`\\n        offset += indices[${t}] * ${n[t]};\\n        `;return`\\n      int ${t}(int indices[${e}]) {\\n        int offset = 0;\\n        ${r}\\n        return offset;\\n      }\\n      `}offsetToIndices(){const t={};return this.context.programInfo.inputNames.forEach(((e,n)=>{const o=this.context.inputTextureLayouts[n].shape,a=this.context.inputTextureLayouts[n].strides,s=o.length;let u=`offsetToIndices_${e}`;t[u]=new r.GlslLibRoutine(i.offsetToIndicesSingle(u,s,a)),u=`offsetToIndices_${e}_T`,t[u]=new r.GlslLibRoutine(i.offsetToIndicesSingle(u,s,a.slice().reverse()))})),t}static offsetToIndicesSingle(t,e,n){const r=[];for(let t=0;t<e-1;++t)r.push(`\\n      indices[${t}] = offset / ${n[t]};`),r.push(`\\n        offset -= indices[${t}] * ${n[t]};`);return r.push(`\\n      indices[${e-1}] = offset;`),`\\n      void ${t}(int offset, out int indices[${e}]) {\\n        ${r.join(\"\")}\\n      }\\n      `}incrementIndices(){const t={};return this.context.programInfo.inputNames.forEach(((e,n)=>{const i=this.context.inputTextureLayouts[n].shape,o=i.length,a=`incrementIndices_${e}`;let s=\"\";for(let t=0;t<o;++t)s+=`\\n        shape[${t}] = ${i[t]};`;const u=`\\n        void ${a}(int axis, out int indices[${o}]) {\\n          int shape[${o}];\\n          ${s};\\n          for(int i = ${o} -1 ; i >= 0; --i) {\\n            if(i > axis) continue;\\n            indices[i] += 1;\\n            if(indices[i] < shape[i]) {\\n              break;\\n            }\\n            indices[i] = 0;\\n          }\\n        }\\n        `;t[a]=new r.GlslLibRoutine(u)})),t}}e.ShapeUtilsGlslLib=i},5060:(t,e)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.getDefaultFragShaderMain=e.getFragShaderPreamble=e.getVertexShaderSource=e.getGlsl=void 0;const n={version:\"\",attribute:\"attribute\",varyingVertex:\"varying\",varyingFrag:\"varying\",texture2D:\"texture2D\",output:\"gl_FragColor\",outputDeclaration:\"\"},r={version:\"#version 300 es\",attribute:\"in\",varyingVertex:\"out\",varyingFrag:\"in\",texture2D:\"texture\",output:\"outputColor\",outputDeclaration:\"out vec4 outputColor;\"};function i(t){return 1===t?n:r}e.getGlsl=i,e.getVertexShaderSource=function(t){const e=i(t);return`${e.version}\\n      precision highp float;\\n      ${e.attribute} vec3 position;\\n      ${e.attribute} vec2 textureCoord;\\n\\n      ${e.varyingVertex} vec2 TexCoords;\\n\\n      void main()\\n      {\\n          gl_Position = vec4(position, 1.0);\\n          TexCoords = textureCoord;\\n      }`},e.getFragShaderPreamble=function(t){const e=i(t);return`${e.version}\\n    precision highp float;\\n    precision highp int;\\n    precision highp sampler2D;\\n    ${e.varyingFrag} vec2 TexCoords;\\n    ${e.outputDeclaration}\\n    const vec2 halfCR = vec2(0.5, 0.5);\\n\\n    // Custom vector types to handle higher dimenalities.\\n    struct ivec5\\n    {\\n      int x;\\n      int y;\\n      int z;\\n      int w;\\n      int u;\\n    };\\n\\n    struct ivec6\\n    {\\n      int x;\\n      int y;\\n      int z;\\n      int w;\\n      int u;\\n      int v;\\n    };\\n\\n    int imod(int x, int y) {\\n      return x - y * (x / y);\\n    }\\n\\n    `},e.getDefaultFragShaderMain=function(t,e){return`\\n  void main() {\\n    int indices[${e}];\\n    toVec(TexCoords, indices);\\n    vec4 result = vec4(process(indices));\\n    ${i(t).output} = result;\\n  }\\n  `}},3891:(t,e,n)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.VecGlslLib=void 0;const r=n(8520);class i extends r.GlslLib{constructor(t){super(t)}getCustomTypes(){return{}}getFunctions(){return Object.assign(Object.assign(Object.assign(Object.assign({},this.binaryVecFunctions()),this.copyVec()),this.setVecItem()),this.getVecItem())}binaryVecFunctions(){const t=this.context.outputTextureLayout.shape.length,e={add:\"+=\",sub:\"-=\",mul:\"*=\",div:\"/=\"},n={};for(const i in e){const o=`${i}Vec`;let a=\"\";for(let n=0;n<t;++n)a+=`\\n          dest[${n}] ${e[i]} src[${n}];\\n          `;const s=`\\n        void ${o}(int src[${t}], out int dest[${t}]) {\\n          ${a}\\n        }\\n        `;n[o]=new r.GlslLibRoutine(s)}return n}copyVec(){const t=this.context.outputTextureLayout.shape.length;let e=\"\";for(let n=0;n<t;++n)e+=`\\n        dest[${n}] = src[${n}];\\n        `;const n=`\\n      void copyVec(int src[${t}], out int dest[${t}]) {\\n        ${e}\\n      }\\n      `;return{copyVec:new r.GlslLibRoutine(n)}}setVecItem(){const t=this.context.outputTextureLayout.shape.length;let e=`\\n        if(index < 0)\\n            index =${t} + index;\\n        if (index == 0)\\n            m[0] = value;\\n        `;for(let n=1;n<t-1;++n)e+=`\\n        else if (index == ${n})\\n            m[${n}] = value;\\n            `;e+=`\\n        else\\n            m[${t-1}] = value;\\n        `;const n=`\\n      void setVecItem(out int m[${t}], int index, int value) {\\n        ${e}\\n      }\\n        `;return{setVecItem:new r.GlslLibRoutine(n)}}getVecItem(){const t=this.context.outputTextureLayout.shape.length;let e=`\\n        if(index < 0)\\n            index = ${t} + index;\\n        if (index == 0)\\n            return m[0];\\n      `;for(let n=1;n<t-1;++n)e+=`\\n        else if (index == ${n})\\n            return m[${n}];\\n      `;e+=`\\n        else\\n            return m[${t-1}];\\n        `;const n=`\\n      int getVecItem(int m[${t}], int index) {\\n        ${e}\\n      }\\n    `;return{getVecItem:new r.GlslLibRoutine(n)}}}e.VecGlslLib=i},8316:(t,e,n)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.WebGLInferenceHandler=void 0;const r=n(6231),i=n(9162),o=n(2517),a=n(2403),s=n(7019),u=n(8710),c=n(5611),l=n(4057),p=n(2039);e.WebGLInferenceHandler=class{constructor(t){this.session=t,this.packedTextureDataCache=new Map,this.unpackedTextureDataCache=new Map}calculateTextureWidthAndHeight(t,e){return(0,l.calculateTextureWidthAndHeight)(this.session.layoutStrategy,t,e)}executeProgram(t,e){if(e.length<t.inputNames.length)throw new Error(`Input size mustn't be less than ${t.inputNames.length}.`);if(t.inputNames.length!==t.inputTypes.length)throw new Error(\"input names size does not match input types\");const n=[];for(let r=0;r<t.inputNames.length;++r)n[r]=this.getOrCreateTextureData(e[r],t.inputTypes[r]);const r=((t,e)=>{const n=e.map((t=>`${t.unpackedShape.join(\",\")};${t.width}x${t.height}`)).join(\"_\");let r=t.name;return t.cacheHint&&(r+=\"[\"+t.cacheHint+\"]\"),r+=\":\"+n,r})(t,n);let i=this.session.programManager.getArtifact(r);const o=i?i.programInfo:\"function\"==typeof t.get?t.get():t,a=(0,l.createTextureLayoutFromTextureType)(this.session.layoutStrategy,o.output.dims,o.output.textureType),s=this.createTextureData(a,o.output.type);return i||(i=this.session.programManager.build(o,n,s),this.session.programManager.setArtifact(r,i)),this.runProgram(i,n,s),s}run(t,e){return this.executeProgram(t,e).tensor}runProgram(t,e,n){for(let n=0;n<e.length;++n)if(!!e[n].isPacked!=(t.programInfo.inputTypes[n]===p.TextureType.packed))throw new Error(`input[${n}] property packed inconsistent`);if(!!n.isPacked!=(t.programInfo.output.textureType===p.TextureType.packed))throw new Error(\"output property packed inconsistent\");this.session.programManager.run(t,e,n)}getOrCreateTextureData(t,e){let n=this.getTextureData(t.dataId,e===p.TextureType.packed);if(!n&&(n=this.getTextureData(t.dataId,e!==p.TextureType.packed),n))return e===p.TextureType.packed?this.pack(n):this.unpack(n);if(!n){const r=(0,l.createTextureLayoutFromTextureType)(this.session.layoutStrategy,t.dims,e);if(e===p.TextureType.packedLastDimension){const n=1,r=4,i=t.dims;if(4===i.length){const o=[i[0],Math.ceil(i[1]*i[2]*i[3]/r)],a=(0,l.createTextureLayoutFromTextureType)(this.session.layoutStrategy,o,e);let s=t.numberData;if(i[1]*i[2]*i[3]%r!=0){const e=i[0],o=i[1]*i[2]*i[3],a=Math.ceil(o*n/r)*r;s=new Float32Array(e*a);for(let r=0;r<e;++r){const e=r*o,i=r*a+r%n*o;s.set(t.numberData.subarray(e,e+o),i)}}return this.createTextureData(a,t.type,s,t,1)}}if(e===p.TextureType.packed){const e=(0,l.createTextureLayoutFromShape)(this.session.layoutStrategy,t.dims,1,[],{reverseWH:!0}),r=this.createTextureData(e,t.type,t.numberData,t,1);n=this.pack(r)}else n=this.createTextureData(r,t.type,t.numberData,t,1)}return n}createTextureDataFromLayoutBindTensor(t,e,n,r){return this.createTextureData(t,e,n,r,1)}createTextureData(t,e,n,i,o){r.Logger.verbose(\"InferenceHandler\",`Creating TextureData: layout:[${JSON.stringify(t)}]`);const a=this.session.textureManager.createTextureFromLayout(e,t,n,o);return this.createTextureDataFromTexture(t,e,a,i)}reshapeUnpacked(t,e){const n=this.getOrCreateTextureData(t,p.TextureType.unpacked),r={channels:n.channels,height:n.height,width:n.width,shape:0!==e.length?e:[1],strides:o.ShapeUtil.computeStrides(e),unpackedShape:e};return this.createTextureDataFromTexture(r,t.type,n.texture).tensor}reshapePacked(t,e){const n=this.getOrCreateTextureData(t,p.TextureType.packed);if((0,s.isReshapeCheap)(t.dims,e)){const r={channels:n.channels,height:n.height,width:n.width,shape:0!==e.length?e:[1],strides:o.ShapeUtil.computeStrides(e),unpackedShape:e,isPacked:!0};return this.createTextureDataFromTexture(r,t.type,n.texture).tensor}const r=(0,s.processDims3D)(t.dims),i=(0,s.processDims3D)(e),a=this.reshapePacked(t,r),u=this.run((0,s.createPackedReshape3DProgramInfoLoader)(this,a,i),[a]);return this.reshapePacked(u,e)}cast(t,e){const n=this.getOrCreateTextureData(t,p.TextureType.unpacked);return this.createTextureDataFromTexture(n,e,n.texture).tensor}createTextureDataFromTexture(t,e,n,r,o){const a=Object.assign(Object.assign({},t),{tensor:r||new i.Tensor(t.unpackedShape,e,(t=>this.readTexture(a)),(async t=>this.readTextureAsync(a)),void 0,o),texture:n});return this.setTextureData(a.tensor.dataId,a,t.isPacked),a}getTextureData(t,e=!1){return this.session.isInitializer(t)?this.session.getTextureData(t,e):e?this.packedTextureDataCache.get(t):this.unpackedTextureDataCache.get(t)}setTextureData(t,e,n=!1){this.session.isInitializer(t)?this.session.setTextureData(t,e,n):(n?this.packedTextureDataCache:this.unpackedTextureDataCache).set(t,e)}isTextureLayoutCached(t,e=!1){return!!this.getTextureData(t.dataId,e)}dispose(){this.session.textureManager.clearActiveTextures(),this.packedTextureDataCache.forEach((t=>this.session.textureManager.releaseTexture(t))),this.packedTextureDataCache=new Map,this.unpackedTextureDataCache.forEach((t=>this.session.textureManager.releaseTexture(t))),this.unpackedTextureDataCache=new Map}readTexture(t){return t.isPacked?this.readTexture(this.unpack(t)):this.session.backend.glContext.isFloat32DownloadSupported?this.session.textureManager.readTexture(t,t.tensor.type,t.channels):this.session.textureManager.readUint8TextureAsFloat((0,u.encodeAsUint8)(this,t))}async readTextureAsync(t){return t.isPacked?this.readTextureAsync(this.unpack(t)):this.session.backend.glContext.isFloat32DownloadSupported?this.session.textureManager.readTextureAsync(t,t.tensor.type,t.channels):this.session.textureManager.readUint8TextureAsFloat((0,u.encodeAsUint8)(this,t))}pack(t){return this.executeProgram((0,a.createPackProgramInfoLoader)(this,t.tensor),[t.tensor])}unpack(t){return this.executeProgram((0,c.createUnpackProgramInfoLoader)(this,t.tensor),[t.tensor])}}},1640:function(t,e,n){\"use strict\";var r=this&&this.__createBinding||(Object.create?function(t,e,n,r){void 0===r&&(r=n);var i=Object.getOwnPropertyDescriptor(e,n);i&&!(\"get\"in i?!e.__esModule:i.writable||i.configurable)||(i={enumerable:!0,get:function(){return e[n]}}),Object.defineProperty(t,r,i)}:function(t,e,n,r){void 0===r&&(r=n),t[r]=e[n]}),i=this&&this.__setModuleDefault||(Object.create?function(t,e){Object.defineProperty(t,\"default\",{enumerable:!0,value:e})}:function(t,e){t.default=e}),o=this&&this.__importStar||function(t){if(t&&t.__esModule)return t;var e={};if(null!=t)for(var n in t)\"default\"!==n&&Object.prototype.hasOwnProperty.call(t,n)&&r(e,t,n);return i(e,t),e};Object.defineProperty(e,\"__esModule\",{value:!0}),e.WEBGL_OP_RESOLVE_RULES=void 0;const a=n(2898),s=o(n(7839)),u=n(4196),c=n(2069),l=n(8138),p=n(9663),f=n(5193),d=n(7992),h=n(1253),g=n(4776),b=n(6572),m=n(3346),y=n(5623),_=n(2870),v=n(2143),w=n(4939),x=n(718),T=n(2268),S=n(8117),O=n(2278),A=n(5524),E=n(5975),I=n(3933),P=n(6558),D=n(5723),$=n(3738),k=o(n(4909)),C=n(8428),F=n(9793);e.WEBGL_OP_RESOLVE_RULES=[[\"Abs\",\"\",\"6+\",k.abs],[\"Acos\",\"\",\"7+\",k.acos],[\"Add\",\"\",\"7+\",s.add],[\"And\",\"\",\"7+\",s.and],[\"Asin\",\"\",\"7+\",k.asin],[\"Atan\",\"\",\"7+\",k.atan],[\"AveragePool\",\"\",\"7+\",v.averagePool,v.parseAveragePoolAttributes],[\"BatchNormalization\",\"\",\"7+\",a.batchNormalization,a.parseBatchNormalizationAttributes],[\"Cast\",\"\",\"6+\",u.cast,u.parseCastAttributes],[\"Ceil\",\"\",\"6+\",k.ceil],[\"Clip\",\"\",\"6-10\",k.clip,k.parseClipAttributes],[\"Clip\",\"\",\"11+\",k.clipV11],[\"Concat\",\"\",\"4+\",c.concat,c.parseConcatAttributes],[\"Conv\",\"\",\"1+\",l.conv,l.parseConvAttributes],[\"ConvTranspose\",\"\",\"1+\",p.convTranspose,p.parseConvTransposeAttributes],[\"Cos\",\"\",\"7+\",k.cos],[\"Div\",\"\",\"7+\",s.div],[\"Dropout\",\"\",\"7+\",k.identity],[\"DepthToSpace\",\"\",\"1+\",f.depthToSpace,f.parseDepthToSpaceAttributes],[\"Equal\",\"\",\"7+\",s.equal],[\"Elu\",\"\",\"6+\",k.elu,k.parseEluAttributes],[\"Exp\",\"\",\"6+\",k.exp],[\"Flatten\",\"\",\"1+\",d.flatten,d.parseFlattenAttributes],[\"Floor\",\"\",\"6+\",k.floor],[\"FusedConv\",\"com.microsoft\",\"1+\",l.conv,l.parseConvAttributes],[\"Gather\",\"\",\"1+\",h.gather,h.parseGatherAttributes],[\"Gemm\",\"\",\"7-10\",g.gemm,g.parseGemmAttributesV7],[\"Gemm\",\"\",\"11+\",g.gemm,g.parseGemmAttributesV11],[\"GlobalAveragePool\",\"\",\"1+\",v.globalAveragePool,v.parseGlobalAveragePoolAttributes],[\"GlobalMaxPool\",\"\",\"1+\",v.globalMaxPool],[\"Greater\",\"\",\"7+\",s.greater],[\"Identity\",\"\",\"1+\",k.identity],[\"ImageScaler\",\"\",\"1+\",b.imageScaler,b.parseImageScalerAttributes],[\"InstanceNormalization\",\"\",\"6+\",m.instanceNormalization,m.parseInstanceNormalizationAttributes],[\"LeakyRelu\",\"\",\"6+\",k.leakyRelu,k.parseLeakyReluAttributes],[\"Less\",\"\",\"7+\",s.less],[\"Log\",\"\",\"6+\",k.log],[\"MatMul\",\"\",\"1+\",y.matMul,y.parseMatMulAttributes],[\"MaxPool\",\"\",\"1+\",v.maxPool,v.parseMaxPoolAttributes],[\"Mul\",\"\",\"7+\",s.mul],[\"Neg\",\"\",\"6+\",k.neg],[\"Not\",\"\",\"1+\",k.not],[\"Or\",\"\",\"7+\",s.or],[\"Pad\",\"\",\"2-10\",_.padV2,_.parsePadAttributesV2],[\"Pad\",\"\",\"11+\",_.padV11,_.parsePadAttributesV11],[\"Pow\",\"\",\"7+\",s.pow],[\"PRelu\",\"\",\"7+\",s.pRelu],[\"ReduceLogSum\",\"\",\"1+\",w.reduceLogSum,w.parseReduceAttributes],[\"ReduceMax\",\"\",\"1+\",w.reduceMax,w.parseReduceAttributes],[\"ReduceMean\",\"\",\"1+\",w.reduceMean,w.parseReduceAttributes],[\"ReduceMin\",\"\",\"1+\",w.reduceMin,w.parseReduceAttributes],[\"ReduceProd\",\"\",\"1+\",w.reduceProd,w.parseReduceAttributes],[\"ReduceSum\",\"\",\"1-12\",w.reduceSum,w.parseReduceAttributes],[\"ReduceSumSquare\",\"\",\"1+\",w.reduceLogSumSquare,w.parseReduceAttributes],[\"Relu\",\"\",\"6+\",k.relu],[\"Reshape\",\"\",\"5+\",x.reshape],[\"Resize\",\"\",\"10\",T.resize,T.parseResizeAttributesV10],[\"Resize\",\"\",\"11+\",T.resize,T.parseResizeAttributesV11],[\"Shape\",\"\",\"1+\",S.shape],[\"Sigmoid\",\"\",\"6+\",k.sigmoid],[\"Sin\",\"\",\"7+\",k.sin],[\"Slice\",\"\",\"10+\",O.sliceV10],[\"Slice\",\"\",\"1-9\",O.slice,O.parseSliceAttributes],[\"Softmax\",\"\",\"1-12\",A.softmax,A.parseSoftmaxAttributes],[\"Softmax\",\"\",\"13+\",A.softmaxV13,A.parseSoftmaxAttributesV13],[\"Split\",\"\",\"2-12\",E.split,E.parseSplitAttributes],[\"Sqrt\",\"\",\"6+\",k.sqrt],[\"Squeeze\",\"\",\"1-12\",I.squeeze,I.parseSqueezeAttributes],[\"Squeeze\",\"\",\"13+\",I.squeezeV13],[\"Sub\",\"\",\"7+\",s.sub],[\"Sum\",\"\",\"6+\",P.sum],[\"Tan\",\"\",\"7+\",k.tan],[\"Tanh\",\"\",\"6+\",k.tanh],[\"Tile\",\"\",\"6+\",D.tile],[\"Transpose\",\"\",\"1+\",$.transpose,$.parseTransposeAttributes],[\"Upsample\",\"\",\"7-8\",F.upsample,F.parseUpsampleAttributesV7],[\"Upsample\",\"\",\"9\",F.upsample,F.parseUpsampleAttributesV9],[\"Unsqueeze\",\"\",\"1-12\",C.unsqueeze,C.parseUnsqueezeAttributes],[\"Unsqueeze\",\"\",\"13+\",C.unsqueezeV13],[\"Xor\",\"\",\"7+\",s.xor]]},2898:(t,e,n)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.parseBatchNormalizationAttributes=e.batchNormalization=void 0;const r=n(246),i=n(5060),o=n(2039),a={name:\"BatchNormalization\",inputNames:[\"A\",\"Scale\",\"B\",\"Mean\",\"Variance\"],inputTypes:[o.TextureType.unpacked,o.TextureType.unpacked,o.TextureType.unpacked,o.TextureType.unpacked,o.TextureType.unpacked]};e.batchNormalization=(t,e,n)=>(u(e),[t.run(Object.assign(Object.assign({},a),{cacheHint:n.cacheKey,get:()=>s(t,e,n)}),e)]),e.parseBatchNormalizationAttributes=t=>{const e=t.attributes.getFloat(\"epsilon\",1e-5),n=t.attributes.getFloat(\"momentum\",.9),i=t.attributes.getInt(\"spatial\",1);return(0,r.createAttributeWithCacheKey)({epsilon:e,momentum:n,spatial:i})};const s=(t,e,n)=>{const r=(0,i.getGlsl)(t.session.backend.glContext.version),s=e[0].dims.length,[u,c]=t.calculateTextureWidthAndHeight(e[1].dims,o.TextureType.unpacked),l=`\\n  float process(int[${s}] indices) {\\n    vec2 position = offsetToCoords(indices[1], ${u}, ${c});\\n    float scale = getColorAsFloat(${r.texture2D}(Scale, position));\\n    float mean = getColorAsFloat(${r.texture2D}(Mean, position));\\n    float variance = getColorAsFloat(${r.texture2D}(Variance, position));\\n    float b = getColorAsFloat(${r.texture2D}(B, position));\\n\\n    return scale * ( (_A(indices) - mean) / sqrt(variance + float(${n.epsilon})) ) + b;\\n  }`;return Object.assign(Object.assign({},a),{output:{dims:e[0].dims,type:e[0].type,textureType:o.TextureType.unpacked},shaderSource:l})},u=t=>{if(!t||5!==t.length)throw new Error(\"BatchNormalization requires 5 inputs.\");const e=t[0],n=t[1],r=t[2],i=t[3],o=t[4];if(e.dims.length<3||1!==n.dims.length||1!==r.dims.length||1!==i.dims.length||1!==o.dims.length)throw new Error(\"invalid input shape.\");if(n.dims[0]!==e.dims[1]||r.dims[0]!==e.dims[1]||i.dims[0]!==e.dims[1]||o.dims[0]!==e.dims[1])throw new Error(\"invalid input shape.\");if(\"float32\"!==e.type&&\"float64\"!==e.type||\"float32\"!==n.type&&\"float64\"!==n.type||\"float32\"!==r.type&&\"float64\"!==r.type||\"float32\"!==i.type&&\"float64\"!==i.type||\"float32\"!==o.type&&\"float64\"!==o.type)throw new Error(\"invalid input tensor types.\")}},7839:(t,e,n)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.xor=e.sub=e.pRelu=e.pow=e.or=e.mul=e.less=e.greater=e.equal=e.div=e.and=e.add=e.glslPRelu=e.glslPow=e.glslXor=e.glslOr=e.glslAnd=e.glslLess=e.glslGreater=e.glslEqual=e.glslSub=e.glslMul=e.glslDiv=e.glslAdd=void 0;const r=n(2517),i=n(8520),o=n(5060),a=n(2039);function s(){const t=\"add_\";return{body:`\\n  float ${t}(float a, float b) {\\n    return a + b;\\n  }\\n  vec4 ${t}(vec4 v1, vec4 v2) {\\n    return v1 + v2;\\n  }\\n  `,name:t,type:i.FunctionType.ValueBased}}function u(){const t=\"div_\";return{body:`\\n  float ${t}(float a, float b) {\\n    return a / b;\\n  }\\n  vec4 ${t}(vec4 v1, vec4 v2) {\\n    return v1 / v2;\\n  }\\n  `,name:t,type:i.FunctionType.ValueBased}}function c(){const t=\"mul_\";return{body:`\\n  float ${t}(float a, float b) {\\n    return a * b;\\n  }\\n  vec4 ${t}(vec4 v1, vec4 v2) {\\n    return v1 * v2;\\n  }\\n  `,name:t,type:i.FunctionType.ValueBased}}function l(){const t=\"sub_\";return{body:`\\n  float ${t}(float a, float b) {\\n    return a - b;\\n  }\\n  vec4 ${t}(vec4 v1, vec4 v2) {\\n    return v1 - v2;\\n  }\\n  `,name:t,type:i.FunctionType.ValueBased}}function p(){const t=\"equal_\";return{body:`\\n  float ${t}(float a, float b) {\\n    return float(a == b);\\n  }\\n  vec4 ${t}(vec4 v1, vec4 v2) {\\n    return vec4(equal(v1, v2));\\n  }\\n  `,name:t,type:i.FunctionType.ValueBased}}function f(){const t=\"greater_\";return{body:`\\n  float ${t}(float a, float b) {\\n    return float(a > b);\\n  }\\n  vec4 ${t}(vec4 v1, vec4 v2) {\\n    return vec4( v1.r > v2.r ,\\n      v1.g > v2.g,\\n      v1.b > v2.b,\\n      v1.a > v2.a );\\n  }\\n  `,name:t,type:i.FunctionType.ValueBased}}function d(){const t=\"less_\";return{body:`\\n  float ${t}(float a, float b) {\\n    return float(a < b);\\n  }\\n  vec4 ${t}(vec4 v1, vec4 v2) {\\n    return vec4( v1.r < v2.r ,\\n                v1.g < v2.g,\\n                v1.b < v2.b,\\n                v1.a < v2.a );\\n  }\\n  `,name:t,type:i.FunctionType.ValueBased}}function h(){const t=\"and_\";return{body:`\\n  float ${t}(float a, float b) {\\n    return float( bool(a) && bool(b) );\\n  }\\n  vec4 ${t}(vec4 v1, vec4 v2) {\\n    bvec4 b1 = bvec4(v1);\\n    bvec4 b2 = bvec4(v2);\\n    return vec4( b1.r && b2.r ,\\n                b1.g && b2.g,\\n                b1.b && b2.b,\\n                b1.a && b2.a );\\n  }\\n  `,name:t,type:i.FunctionType.ValueBased}}function g(){const t=\"or_\";return{body:`\\n  float ${t}(float a, float b) {\\n    return float( bool(a) || bool(b) );\\n  }\\n  vec4 ${t}(vec4 v1, vec4 v2) {\\n    bvec4 b1 = bvec4(v1);\\n    bvec4 b2 = bvec4(v2);\\n    return vec4( b1.r || b2.r ,\\n                b1.g || b2.g,\\n                b1.b || b2.b,\\n                b1.a || b2.a );\\n  }\\n  `,name:t,type:i.FunctionType.ValueBased}}function b(){const t=\"xor_\";return{body:`\\n  float ${t}(float a, float b) {\\n    return float( bool(a) ^^ bool(b) );\\n  }\\n  vec4 ${t}(vec4 v1, vec4 v2) {\\n    bvec4 b1 = bvec4(v1);\\n    bvec4 b2 = bvec4(v2);\\n    return vec4( b1.r ^^ b2.r ,\\n                b1.g ^^ b2.g,\\n                b1.b ^^ b2.b,\\n                b1.a ^^ b2.a );\\n  }\\n  `,name:t,type:i.FunctionType.ValueBased}}function m(){return function(t){const e=`${t}_`;return{body:`\\n  float ${e}(float a, float b) {\\n    return ${t}(a, b);\\n  }\\n  vec4 ${e}(vec4 v1, vec4 v2) {\\n    return ${t}(v1, v2);\\n  }\\n  `,name:e,type:i.FunctionType.ValueBased}}(\"pow\")}function y(){const t=\"prelu_\";return{body:`\\n  float ${t}(float a, float b) {\\n    return a < 0.0 ? a * b: a;\\n  }\\n  vec4 ${t}(vec4 v1, vec4 v2) {\\n    return vec4(\\n      v1.r < 0.0 ? v1.r * v2.r: v1.r,\\n      v1.g < 0.0 ? v1.g * v2.g: v1.g,\\n      v1.b < 0.0 ? v1.b * v2.b: v1.b,\\n      v1.a < 0.0 ? v1.a * v2.a: v1.a\\n      );\\n  }\\n  `,name:t,type:i.FunctionType.ValueBased}}e.glslAdd=s,e.glslDiv=u,e.glslMul=c,e.glslSub=l,e.glslEqual=p,e.glslGreater=f,e.glslLess=d,e.glslAnd=h,e.glslOr=g,e.glslXor=b,e.glslPow=m,e.glslPRelu=y;const _=(t,e,n,r=e[0].type,i)=>{const o=t.session.pack?a.TextureType.packed:a.TextureType.unpacked;return{name:n.name,inputNames:[\"A\",\"B\"],inputTypes:[o,o],cacheHint:i,get:()=>v(t,e,n,r)}},v=(t,e,n,i=e[0].type)=>{const s=t.session.pack?a.TextureType.packed:a.TextureType.unpacked,u=!r.ShapeUtil.areEqual(e[0].dims,e[1].dims);let c=e[0].dims;const l=t.session.pack;if(u){const a=r.BroadcastUtil.calcShape(e[0].dims,e[1].dims,!1);if(!a)throw new Error(\"Can't perform binary op on the given tensors\");c=a;const u=c.length,p=0!==e[0].dims.length?e[0].dims.length:1,f=0!==e[1].dims.length?e[1].dims.length:1,d=0!==e[0].dims.length?\"bcastIndices_A(indices, aindices);\":\"aindices[0] = 0;\",h=0!==e[1].dims.length?\"bcastIndices_B(indices, bindices);\":\"bindices[0] = 0;\",g=(0,o.getGlsl)(t.session.backend.glContext.version),b=l?`\\n      ${n.body}\\n      void main() {\\n        vec4 a = getAAtOutCoords();\\n        vec4 b = getBAtOutCoords();\\n        vec4 result = ${n.name}(a, b);\\n        ${g.output} = result;\\n      }`:`\\n      ${n.body}\\n      float process(int indices[${u}]) {\\n        int aindices[${p}];\\n        int bindices[${f}];\\n        ${d}\\n        ${h}\\n        return ${n.name}(_A(aindices), _B(bindices));\\n      }`;return{name:n.name,inputNames:[\"A\",\"B\"],inputTypes:[s,s],output:{dims:c,type:i,textureType:s},shaderSource:b,hasMain:l}}const p=(0,o.getGlsl)(t.session.backend.glContext.version),f=`\\n    ${n.body}\\n    void main() {\\n      vec4 v1 = ${p.texture2D}(A, TexCoords);\\n      vec4 v2 = ${p.texture2D}(B, TexCoords);\\n      vec4 result = ${n.name}(v1, v2);\\n      ${p.output} = result;\\n    }\\n    `;return{name:n.name,inputNames:[\"A\",\"B\"],inputTypes:[s,s],output:{dims:e[0].dims,type:i,textureType:s},shaderSource:f,hasMain:!0}};e.add=(t,e)=>[t.run(_(t,e,s()),e)],e.and=(t,e)=>[t.run(_(t,e,h(),\"bool\"),e)],e.div=(t,e)=>[t.run(_(t,e,u()),e)],e.equal=(t,e)=>[t.run(_(t,e,p(),\"bool\"),e)],e.greater=(t,e)=>[t.run(_(t,e,f(),\"bool\"),e)],e.less=(t,e)=>[t.run(_(t,e,d(),\"bool\"),e)],e.mul=(t,e)=>[t.run(_(t,e,c()),e)],e.or=(t,e)=>[t.run(_(t,e,g(),\"bool\"),e)],e.pow=(t,e)=>[t.run(_(t,e,m()),e)],e.pRelu=(t,e)=>[t.run(_(t,e,y()),e)],e.sub=(t,e)=>[t.run(_(t,e,l()),e)],e.xor=(t,e)=>[t.run(_(t,e,b(),\"bool\"),e)]},4196:(t,e,n)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.parseCastAttributes=e.cast=void 0;const r=n(2517);e.cast=(t,e,n)=>(i(e),[t.cast(e[0],n)]),e.parseCastAttributes=t=>r.ProtoUtil.tensorDataTypeFromProto(t.attributes.getInt(\"to\"));const i=t=>{if(!t||1!==t.length)throw new Error(\"Cast requires 1 input.\");if(\"string\"===t[0].type)throw new Error(\"Invalid input type.\")}},1163:(t,e,n)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.createPackedConcatProgramInfoLoader=void 0;const r=n(5060),i=n(2039),o=n(9390),a=n(2827);e.createPackedConcatProgramInfoLoader=(t,e,n)=>{const u=(c=e.length,l=n.cacheKey,{name:\"Concat (packed)\",inputNames:Array.from({length:c},((t,e)=>`X${e}`)),inputTypes:Array(c).fill(i.TextureType.packed),cacheHint:l});var c,l;return Object.assign(Object.assign({},u),{get:()=>((t,e,n,u)=>{const c=n[0].dims.slice();if(u>=c.length||u<-1*c.length)throw new Error(\"axis specified for concat doesn't match input dimensionality\");u<0&&(u=c.length+u);const l=c.slice(0);for(let t=1;t<n.length;t++){const e=n[t].dims.slice();for(let t=0;t<c.length;t++)if(t===u)l[u]+=e[t];else if(c[t]!==e[t])throw new Error(\"non concat dimensions must match\")}const p=l.length,f=(0,a.getChannels)(\"coords\",p),d=(0,o.getCoordsDataType)(p),h=(0,a.unpackFromChannel)(),g=n.map((t=>t.dims)),b=(0,o.getGlChannels)(p),m=new Array(g.length-1);m[0]=g[0][u];for(let t=1;t<m.length;t++)m[t]=m[t-1]+g[t][u];const y=b[u],_=b.slice(-2),v=b.join();let w=`if (${y} < ${m[0]}) {\\n        return getChannel(\\n            getX0(${v}), vec2(${_.join()}));\\n        }`;for(let t=1;t<m.length;t++){const e=m[t-1];w+=`\\n            if (${y} < ${m[t]}  && ${y} >= ${m[t-1]}) {\\n              return getChannel(\\n                getX${t}(${s(b,y,e)}),\\n                vec2(${s(_,y,e)}));\\n            }`}const x=m.length,T=m[m.length-1];w+=`\\n            return getChannel(\\n              getX${x}(${s(b,y,T)}),\\n              vec2(${s(_,y,T)}));`;const S=(0,r.getGlsl)(t.session.backend.glContext.version),O=`\\n          ${h}\\n          float getValue(${b.map((t=>\"int \"+t))}) {\\n            ${w}\\n          }\\n\\n          void main() {\\n            ${d} coords = getOutputCoords();\\n            int lastDim = coords.${b[p-1]};\\n            coords.${b[p-1]} = coords.${b[p-2]};\\n            coords.${b[p-2]} = lastDim;\\n\\n            vec4 result = vec4(getValue(${f}), 0., 0., 0.);\\n\\n            ${f[p-1]} = ${f[p-1]} + 1;\\n            if (${f[p-1]} < ${l[p-1]}) {\\n              result.g = getValue(${f});\\n            }\\n\\n            ${f[p-2]} = ${f[p-2]} + 1;\\n            if (${f[p-2]} < ${l[p-2]}) {\\n              result.a = getValue(${f});\\n            }\\n\\n            ${f[p-1]} = ${f[p-1]} - 1;\\n            if (${f[p-2]} < ${l[p-2]} &&\\n                ${f[p-1]} < ${l[p-1]}) {\\n              result.b = getValue(${f});\\n            }\\n            ${S.output} = result;\\n          }\\n        `;return Object.assign(Object.assign({},e),{output:{dims:l,type:n[0].type,textureType:i.TextureType.packed},shaderSource:O,hasMain:!0})})(t,u,e,n.axis)})};const s=(t,e,n)=>{const r=t.indexOf(e);return t.map(((t,e)=>e===r?`${t} - ${n}`:t)).join()}},2069:(t,e,n)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.parseConcatAttributes=e.concat=void 0;const r=n(246),i=n(2039),o=n(1163);e.concat=(t,e,n)=>(p(e),t.session.pack&&e[0].dims.length>1?[t.run((0,o.createPackedConcatProgramInfoLoader)(t,e,n),e)]:[t.run(a(t,e,n),e)]);const a=(t,e,n)=>{const r=(o=e.length,a=n.cacheKey,{name:\"Concat\",inputNames:Array.from({length:o},((t,e)=>`X${e}`)),inputTypes:Array(o).fill(i.TextureType.unpacked),cacheHint:a});var o,a;return Object.assign(Object.assign({},r),{get:()=>((t,e,n,r)=>{const o=n[0].dims.slice();if(r>=o.length||r<-1*o.length)throw new Error(\"axis specified for concat doesn't match input dimensionality\");r<0&&(r=o.length+r);const a=o.slice(0);for(let t=1;t<n.length;t++){const e=n[t].dims.slice();for(let t=0;t<o.length;t++)if(t===r)a[r]+=e[t];else if(o[t]!==e[t])throw new Error(\"non concat dimensions must match\")}const p=a.length,f=new Array(n.length);let d=0;for(let t=0;t<f.length;++t)d+=n[t].dims[r],f[t]=d;let h=\"\";h=n.length<5?s(f):u(f);const g=`\\n        ${c(n.length,p)}\\n        ${l(f)}\\n        ${h}\\n        float process(int indices[${p}]) {\\n          int textureIndex = getTextureWhereDataResides (indices[${r}]);\\n\\n          if(textureIndex != 0) {\\n            indices[${r}] = indices[${r}] - int(getSizeInConcatAxisValueFromIndex(textureIndex-int(1)));\\n          }\\n\\n          return fetchDataFromCorrectTexture(textureIndex, indices);\\n        }`;return Object.assign(Object.assign({},e),{output:{dims:a,type:n[0].type,textureType:i.TextureType.unpacked},shaderSource:g})})(0,r,e,n.axis)})},s=t=>`int getTextureWhereDataResides(int index) {\\n      ${t.map(((t,e)=>`if(index<${t}) {return ${e};}\\n`)).join(\"\")}\\n    }`,u=t=>s(t),c=(t,e)=>{const n=[`float fetchDataFromCorrectTexture(int textureIndex, int indices[${e}]) {`];for(let e=0;e<t;++e)0===e?n.push(`\\tif (textureIndex == ${e}) { return _X${e}(indices); }`):e===t-1?n.push(`\\telse { return _X${e}(indices); }`):n.push(`\\telse if (textureIndex == ${e}) { return _X${e}(indices); }`);return n.push(\"\\t}\"),n.join(\"\\n\")},l=t=>{const e=[\"int getSizeInConcatAxisValueFromIndex(int index) {\"];for(let n=0;n<t.length;++n)0===n?e.push(`\\tif (index == ${n}) { return ${t[n]}; }`):n===t.length-1?e.push(`\\telse { return ${t[n]}; }`):e.push(`\\telse if (index == ${n}) { return ${t[n]}; }`);return e.push(\"\\t}\"),e.join(\"\\n\")};e.parseConcatAttributes=t=>(0,r.createAttributeWithCacheKey)({axis:t.attributes.getInt(\"axis\")});const p=t=>{if(!t||t.length<1)throw new Error(\"too few inputs\");const e=t[0].type,n=t[0].dims.length;if(\"string\"===e)throw new Error(\"string tensor is not supported yet\");for(const r of t){if(r.type!==e)throw new Error(\"input tensors should be one type\");if(r.dims.length!==n)throw new Error(\"input tensors should have the same shape\")}}},4770:(t,e,n)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.createUnpackedGroupedConvProgramInfoLoader=void 0;const r=n(6231),i=n(5060),o=n(2039),a=n(8138),s=n(2823);e.createUnpackedGroupedConvProgramInfoLoader=(t,e,n)=>{const u=(c=e.length>2,l=n.cacheKey,{name:\"GroupedConv\",inputNames:c?[\"X\",\"W\",\"Bias\"]:[\"X\",\"W\"],inputTypes:c?[o.TextureType.unpacked,o.TextureType.unpacked,o.TextureType.unpacked]:[o.TextureType.unpacked,o.TextureType.unpacked],cacheHint:l});var c,l;return Object.assign(Object.assign({},u),{get:()=>((t,e,n,u)=>{const c=e.length>2?\"value += getBias(output_channel);\":\"\",l=e[0].dims.slice(),p=e[1].dims.slice(),f=p[0]/u.group;r.Logger.verbose(\"GroupedConv\",`autpPad:${u.autoPad}, dilations:${u.dilations}, group:${u.group}, kernelShape:${u.kernelShape}, pads:${u.pads}, strides:${u.strides}`);const d=(0,a.calculateOutputShape)(l,p,u.dilations,u.pads,u.strides),h=(0,i.getGlsl)(t.session.backend.glContext.version),{activationFunction:g,applyActivation:b}=(0,s.getActivationSnippet)(u),m=`\\n  const ivec2 strides = ivec2(${u.strides[0]}, ${u.strides[1]});\\n  const ivec2 pads = ivec2(${u.pads[0]}, ${u.pads[1]});\\n  ${g}\\n  void main() {\\n    ivec4 coords = getOutputCoords();\\n    int batch = coords.x;\\n    int output_channel = coords.y;\\n    ivec2 xRCCorner = coords.zw * strides - pads;\\n    int group_id = output_channel / ${f};\\n\\n    float value = 0.0;\\n    for (int wInChannel = 0; wInChannel < ${p[1]}; wInChannel++) {\\n      int input_channel = group_id * ${p[1]} + wInChannel;\\n      for (int wHeight = 0; wHeight < ${p[2]}; wHeight++) {\\n        int xHeight = xRCCorner.x + wHeight * ${u.dilations[0]};\\n\\n        if (xHeight < 0 || xHeight >= ${l[2]}) {\\n          continue;\\n        }\\n\\n        for (int wWidth = 0; wWidth < ${p[3]}; wWidth++) {\\n          int xWidth = xRCCorner.y + wWidth * ${u.dilations[1]};\\n          if (xWidth < 0 || xWidth >= ${l[3]}) {\\n            continue;\\n          }\\n\\n          float xVal = getX(batch, input_channel, xWidth, xHeight);\\n          float wVal = getW(output_channel, wInChannel, wWidth, wHeight);\\n          value += xVal*wVal;\\n        }\\n      }\\n    }\\n    ${c}\\n    ${b}\\n    ${h.output} = vec4(value, .0, .0, .0);\\n  }\\n`;return Object.assign(Object.assign({},n),{output:{dims:d,type:e[0].type,textureType:o.TextureType.unpacked},shaderSource:m,hasMain:!0})})(t,e,u,n)})}},1386:(t,e,n)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.conv2DPacked=e.conv2DPackedPointwise=void 0;const r=n(8138),i=n(8555),o=n(708);e.conv2DPackedPointwise=(t,e,n)=>{const i=e[0].dims,a=e[1].dims,s=(0,r.calculateOutputShape)(i,a,n.dilations,n.pads,n.strides),u=t.reshapePacked(e[0],[i[1],i[2]*i[3]]),c=t.reshapePacked(e[1],[a[0],a[1]]),l=e.length>2?[c,u,e[2]]:[c,u],p=t.run((0,o.createPackedMatmulProgramInfoLoader)(t,l,n),l);return t.reshapePacked(p,s)},e.conv2DPacked=(t,e,n)=>{const a=e[0].dims,s=e[1].dims,u=(0,r.calculateOutputShape)(a,s,n.dilations,n.pads,n.strides),c=t.run((0,i.createPackedIm2ColProgramInfoLoader)(t,e[0],e[1],u,n),[e[0]]),l=t.reshapePacked(e[1],[s[0],s[1]*s[2]*s[3]]),p=3===e.length?[l,c,e[2]]:[l,c],f=t.run((0,o.createPackedMatmulProgramInfoLoader)(t,p,n),p);return t.reshapePacked(f,u)}},9663:(t,e,n)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.parseConvTransposeAttributes=e.convTranspose=void 0;const r=n(246),i=n(5060),o=n(2039),a=n(2823),s=(t,e,n,r,i,o)=>(t-1)*e+n+(r-1)*i+1-o,u=(t,e,n,r,i)=>{const o=Math.floor(t/2);\"SAME_UPPER\"===e?(n[r]=o,n[i]=t-o):\"SAME_LOWER\"===e&&(n[r]=t-o,n[i]=o)};e.convTranspose=(t,e,n)=>(f(e,n),c(t,e,n));const c=(t,e,n)=>{const r=p(n,e);return[l(t,e,r)]},l=(t,e,n)=>t.run(((t,e,n)=>{const r=(s=e.length>2,u=n.cacheKey,{name:\"ConvTranspose\",inputNames:s?[\"X\",\"W\",\"B\"]:[\"X\",\"W\"],inputTypes:s?[o.TextureType.unpacked,o.TextureType.unpacked,o.TextureType.unpacked]:[o.TextureType.unpacked,o.TextureType.unpacked],cacheHint:u});var s,u;return Object.assign(Object.assign({},r),{get:()=>((t,e,n,r)=>{const s=e.length>2?\"getB(output_channel)\":\"0.0\",u=e[0].dims,c=e[1].dims,l=c[1],p=c[0]/r.group,f=[e[0].dims[0],e[1].dims[1]*r.group,...r.outputShape],d=(0,i.getGlsl)(t.session.backend.glContext.version),{activationFunction:h,applyActivation:g}=(0,a.getActivationSnippet)(r),b=`\\n  const ivec2 strides = ivec2(${r.strides[0]}, ${r.strides[1]});\\n  const ivec2 pads = ivec2(${r.pads[0]}, ${r.pads[1]});\\n  ${h}\\n  void main() {\\n    ivec4 coords = getOutputCoords();\\n    int batch = coords.x;\\n    int output_channel = coords.y;\\n\\n    ivec2 loc = coords.zw + pads;\\n\\n    int group_id = output_channel / ${l};\\n    int wOutChannel = output_channel - group_id * ${l};\\n\\n    float value = ${s};\\n    for (int inChannelOffset = 0; inChannelOffset < ${p}; inChannelOffset++) {\\n      int input_channel = group_id * ${p} + inChannelOffset;\\n      for (int wWOff = 0; wWOff < ${c[2]}; wWOff++) {\\n        for (int wHOff = 0; wHOff < ${c[3]}; wHOff++) {\\n          ivec2 wOff = ivec2(wWOff * ${r.dilations[0]}, wHOff * ${r.dilations[1]});\\n          ivec2 wLoc = loc - wOff;\\n          ivec2 wLocIn = wLoc / strides;\\n          if (\\n            wLocIn * strides == wLoc &&\\n            wLocIn.x >= 0 && wLocIn.x < ${u[2]} &&\\n            wLocIn.y >= 0 && wLocIn.y < ${u[3]}\\n          ) {\\n            float xVal = getX(batch, input_channel, wLocIn.y, wLocIn.x);\\n            float wVal = getW(input_channel, wOutChannel, wHOff, wWOff);\\n            value += xVal * wVal;\\n          }\\n        }\\n      }\\n    }\\n    ${g}\\n    ${d.output} = vec4(value, .0, .0, .0);\\n  }\\n`;return Object.assign(Object.assign({},n),{output:{dims:f,type:e[0].type,textureType:o.TextureType.unpacked},shaderSource:b,hasMain:!0})})(t,e,r,n)})})(t,e,n),e),p=(t,e)=>{const n=t.kernelShape.slice();if(0===t.kernelShape.length)for(let t=2;t<e[1].dims.length;++t)n.push(e[1].dims[t]);const r=t.pads.slice(),i=t.outputShape.slice();((t,e,n,r,i,o,a,c)=>{const l=t.length-2,p=0===c.length;for(let f=0;f<l;++f){const d=p?t[f+2]*o[f]:c[f],h=s(t[f+2],o[f],i[f],e[f],n[f],d);u(h,r,i,f,f+l),p&&c.push(o[f]*(t[f+2]-1)+a[f]+(e[f]-1)*n[f]+1-i[f]-i[f+l])}})(e[0].dims,n,t.dilations,t.autoPad,r,t.strides,t.outputPadding,i);const o=Object.assign({},t);return Object.assign(o,{kernelShape:n,pads:r,outputShape:i,cacheKey:t.cacheKey}),o};e.parseConvTransposeAttributes=t=>{const e=t.attributes,n=(0,a.parseInternalActivationAttributes)(e),i=e.getString(\"auto_pad\",\"NOTSET\"),o=e.getInts(\"dilations\",[1,1]),s=e.getInt(\"group\",1),u=e.getInts(\"kernel_shape\",[]),c=e.getInts(\"output_padding\",[0,0]),l=e.getInts(\"output_shape\",[]),p=e.getInts(\"pads\",[0,0,0,0]),f=e.getInts(\"strides\",[1,1]);return(0,r.createAttributeWithCacheKey)(Object.assign({autoPad:i,dilations:o,group:s,kernelShape:u,outputPadding:c,outputShape:l,pads:p,strides:f},n))};const f=(t,e)=>{if(!t||2!==t.length&&3!==t.length)throw new Error(\"Conv requires 2 or 3 inputs\");if(4!==t[0].dims.length||4!==t[1].dims.length)throw new Error(\"currently only support 2-dimensional conv\");if(t[0].dims[1]!==t[1].dims[0])throw new Error(\"FILTER_IN_CHANNEL should be equal to DATA_CHANNEL\");const n=t[1].dims[1]*e.group;if(3===t.length&&(1!==t[2].dims.length||t[2].dims[0]!==n))throw new Error(\"invalid bias\");const r=t[0].dims.length-2;if(e.dilations.length!==r)throw new Error(`dilations should be ${r}D`);if(e.strides.length!==r)throw new Error(`strides should be ${r}D`);if(e.pads.length!==2*r)throw new Error(`pads should be ${2*r}D`);if(e.outputPadding.length!==r)throw new Error(`output_padding should be ${r}D`);if(0!==e.kernelShape.length&&e.kernelShape.length!==t[1].dims.length-2)throw new Error(\"invalid kernel shape\");if(0!==e.outputShape.length&&e.outputShape.length!==t[0].dims.length-2)throw new Error(\"invalid output shape\");if(\"float32\"!==t[0].type||\"float32\"!==t[1].type)throw new Error(\"ConvTranspose input(X,W) should be float tensor\");if(3===t.length&&\"float32\"!==t[2].type)throw new Error(\"ConvTranspose input(bias) should be float tensor\")}},8138:(t,e,n)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.parseConvAttributes=e.conv=e.calculateOutputShape=void 0;const r=n(246),i=n(2517),o=n(4770),a=n(1386),s=n(9828),u=n(2823),c=n(3248),l=n(5623);e.calculateOutputShape=(t,e,n,r,i)=>{const o=t[0],a=t.slice(2),s=a.length,u=e[0],c=e.slice(2).map(((t,e)=>t+(t-1)*(n[e]-1))),l=a.map(((t,e)=>t+r[e]+r[e+s])).map(((t,e)=>Math.floor((t-c[e]+i[e])/i[e])));return[o,u].concat(...l)},e.conv=(t,e,n)=>(g(e,n),p(t,e,n));const p=(t,e,n)=>{const r=h(n,e),i=t.session.pack,s=1===r.kernelShape[0]&&1===r.kernelShape[1];return r.group>1?[t.run((0,o.createUnpackedGroupedConvProgramInfoLoader)(t,e,r),e)]:s&&i?[f(t,e,r)]:i&&4===e[0].dims.length&&1===e[0].dims[0]&&!s?[(0,a.conv2DPacked)(t,e,r)]:[d(t,e,r)]},f=(t,n,r)=>{const i=n[0].dims,o=n[1].dims,a=(0,e.calculateOutputShape)(i,o,r.dilations,r.pads,r.strides),s=t.reshapeUnpacked(n[0],[i[1],i[2]*i[3]]),u=t.reshapeUnpacked(n[1],[o[0],o[1]]),c=n.length>2?[u,s,n[2]]:[u,s],p=t.run((0,l.createMatmulProgramInfoLoader)(c,r),c);return t.reshapeUnpacked(p,a)},d=(t,n,r)=>{const i=n[0].dims,o=n[1].dims,a=(0,e.calculateOutputShape)(i,o,r.dilations,r.pads,r.strides),u=t.run((0,c.createIm2ColProgramInfoLoader)(t,n[0],n[1],a,r),[n[0]]),l=3===n.length?[u,n[1],n[2]]:[u,n[1]];return t.run((0,s.createDotProductProgramInfoLoader)(t,n,a,r),l)},h=(t,e)=>{const n=t.kernelShape.slice();if(0===t.kernelShape.length)for(let t=2;t<e[1].dims.length;++t)n.push(e[1].dims[t]);const r=t.pads.slice();i.PoolConvUtil.adjustPadsBasedOnAutoPad(e[0].dims,t.strides,t.dilations,n,r,t.autoPad);const o=Object.assign({},t);return Object.assign(o,{kernelShape:n,pads:r,cacheKey:t.cacheKey}),o};e.parseConvAttributes=t=>{const e=t.attributes,n=(0,u.parseInternalActivationAttributes)(e),i=e.getString(\"auto_pad\",\"NOTSET\"),o=e.getInts(\"dilations\",[1,1]),a=e.getInt(\"group\",1),s=e.getInts(\"kernel_shape\",[]),c=e.getInts(\"pads\",[0,0,0,0]),l=e.getInts(\"strides\",[1,1]);return(0,r.createAttributeWithCacheKey)(Object.assign({autoPad:i,dilations:o,group:a,kernelShape:s,pads:c,strides:l},n))};const g=(t,e)=>{if(!t||2!==t.length&&3!==t.length)throw new Error(\"Conv requires 2 or 3 inputs\");if(4!==t[0].dims.length||4!==t[1].dims.length)throw new Error(\"currently only support 2-dimensional conv\");if(t[0].dims[1]!==t[1].dims[1]*e.group)throw new Error(\"FILTER_IN_CHANNEL should be equal to DATA_CHANNEL\");if(3===t.length&&(1!==t[2].dims.length||t[1].dims[0]!==t[2].dims[0]))throw new Error(\"invalid bias\");const n=t[0].dims.length-2;if(e.dilations.length!==n)throw new Error(`dilations should be ${n}D`);if(e.strides.length!==n)throw new Error(`strides should be ${n}D`);if(e.pads.length!==2*n)throw new Error(`pads should be ${2*n}D`);if(0!==e.kernelShape.length&&e.kernelShape.length!==t[1].dims.length-2)throw new Error(\"invalid kernel shape\");if(\"float32\"!==t[0].type||\"float32\"!==t[1].type)throw new Error(\"Conv input(X,W) should be float tensor\");if(3===t.length&&\"float32\"!==t[2].type)throw new Error(\"Conv input(bias) should be float tensor\")}},5193:(t,e,n)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.parseDepthToSpaceAttributes=e.depthToSpace=void 0;const r=n(3738);e.depthToSpace=(t,e,n)=>{i(e);const o=n.blocksize,a=o*o,s=\"DCR\"===n.mode?[0,3,4,1,5,2]:[0,1,4,2,5,3],u=\"DCR\"===n.mode?[e[0].dims[0],o,o,e[0].dims[1]/a,e[0].dims[2],e[0].dims[3]]:[e[0].dims[0],e[0].dims[1]/a,o,o,e[0].dims[2],e[0].dims[3]],c=t.reshapeUnpacked(e[0],u),l={perm:s,cacheKey:`${s}`},[p]=(0,r.transpose)(t,[c],l),f=[e[0].dims[0],e[0].dims[1]/a,e[0].dims[2]*o,e[0].dims[3]*o];return[t.reshapeUnpacked(p,f)]},e.parseDepthToSpaceAttributes=t=>{const e=t.attributes.getInt(\"blocksize\");if(e<1)throw new Error(`blocksize must be >= 1, but got : ${e} for DepthToSpace`);const n=t.attributes.getString(\"mode\",\"DCR\");if(\"DCR\"!==n&&\"CRD\"!==n)throw new Error(`unrecognized mode: ${n} for DepthToSpace`);return{mode:n,blocksize:e}};const i=t=>{if(1!==t.length)throw new Error(`DepthToSpace expect 1 inputs, but got ${t.length}`);if(\"string\"===t[0].type||4!==t[0].dims.length)throw new TypeError(\"DepthToSpace input should be a 4-D numeric tensor\")}},9828:(t,e,n)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.createDotProductProgramInfoLoader=void 0;const r=n(2517),i=n(5060),o=n(2039),a=n(2823),s=n(3248);e.createDotProductProgramInfoLoader=(t,e,n,u)=>{const c=((t,e)=>({name:\"ConvDotProduct\",inputNames:t?[\"Im2Col\",\"K\",\"B\"]:[\"Im2Col\",\"K\"],inputTypes:t?[o.TextureType.unpacked,o.TextureType.packedLastDimension,o.TextureType.unpacked]:[o.TextureType.unpacked,o.TextureType.packedLastDimension],cacheKey:e.activationCacheKey}))(e.length>2,u);return Object.assign(Object.assign({},c),{get:()=>((t,e,n,u,c)=>{const l=n[0].dims,p=n[1].dims,f=[p[0],Math.ceil(l[1]*p[2]*p[3]/4)],d=(0,s.calculateIm2ColDims)(l,p,u),[h,g]=t.calculateTextureWidthAndHeight(f,o.TextureType.packedLastDimension),b=r.ShapeUtil.computeStrides(d),[m,y]=t.calculateTextureWidthAndHeight(d,o.TextureType.packedLastDimension),_=u.length,v=n.length<3?\"0.0\":\"_B(b)\",w=Math.ceil(l[1]*p[2]*p[3]/4),{activationFunction:x,applyActivation:T}=(0,a.getActivationSnippet)(c),S=(0,i.getGlsl)(t.session.backend.glContext.version),O=`\\n${x}\\nfloat process(int indices[${_}]) {\\n  int b[1];\\n  b[0] = indices[1];\\n  int im2col[4];\\n  im2col[0] = indices[0];\\n  im2col[1] = indices[2];\\n  im2col[2] = indices[3];\\n  int im2colOffset = im2col[0] * ${b[0]} + im2col[1] * ${b[1]} + im2col[2] * ${b[2]};\\n  int kernelOffset = indices[1] * ${f[1]};\\n  float value = ${v};\\n  for (int i = 0; i < ${w}; ++i) {\\n    vec2 im2colCoords = offsetToCoords(im2colOffset, ${m}, ${y});\\n    vec2 kernelCoords = offsetToCoords(kernelOffset, ${h}, ${g});\\n    value += dot(${S.texture2D}(Im2Col, im2colCoords), ${S.texture2D}(K, kernelCoords));\\n    ++im2colOffset;\\n    ++kernelOffset;\\n  }\\n  ${T}\\n  return value;\\n}`;return Object.assign(Object.assign({},e),{output:{dims:u,type:n[0].type,textureType:o.TextureType.unpacked},shaderSource:O})})(t,c,e,n,u)})}},7992:(t,e,n)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.parseFlattenAttributes=e.flatten=void 0;const r=n(2517);e.flatten=(t,e,n)=>{i(e,n);const o=r.ShapeUtil.flattenShape(e[0].dims,n);return[t.reshapeUnpacked(e[0],o)]},e.parseFlattenAttributes=t=>t.attributes.getInt(\"axis\",1);const i=(t,e)=>{if(!t||1!==t.length)throw new Error(\"Flatten requires 1 input.\");const n=t[0].dims.length;if(0===n)throw new Error(\"scalar tensor is not supported.\");if(e<-n||e>n)throw new Error(\"Invalid axis\");if(\"string\"===t[0].type)throw new Error(\"string tensor is not supported.\")}},2823:(t,e,n)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.parseInternalActivationAttributes=e.getActivationSnippet=void 0;const r=n(2517),i=n(4909);e.getActivationSnippet=function(t){let e;switch(t.activation){case\"Relu\":e=(0,i.glslRelu)();break;case\"Sigmoid\":e=(0,i.glslSigmoid)();break;case\"Clip\":e=(0,i.glslClip)(t.clipMin,t.clipMax);break;default:return{activationFunction:\"\",applyActivation:\"\"}}const n=e.name;return{activationFunction:e.body,applyActivation:`value = ${n}_(value);`}},e.parseInternalActivationAttributes=t=>{const e=t.getString(\"activation\",\"\");if(\"Clip\"===e){const[n,i]=t.getFloats(\"activation_params\",[r.MIN_CLIP,r.MAX_CLIP]);return{activation:e,clipMax:i,clipMin:n,activationCacheKey:`${e}:${n},${i}`}}return{activation:e,activationCacheKey:e}}},1253:(t,e,n)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.parseGatherAttributes=e.gather=void 0;const r=n(246),i=n(782),o=n(2517),a=n(2039);e.gather=(t,e,n)=>(c(e,n.axis),[t.run(u(t,e,n),e)]),e.parseGatherAttributes=t=>(0,r.createAttributeWithCacheKey)({axis:t.attributes.getInt(\"axis\",0)});const s={name:\"Gather\",inputNames:[\"A\",\"B\"],inputTypes:[a.TextureType.unpacked,a.TextureType.unpacked]},u=(t,e,n)=>{const r=Object.assign(Object.assign({},s),{cacheHint:n.cacheKey});return Object.assign(Object.assign({},r),{get:()=>((t,e,n,r)=>{const i=n[0].dims.slice(),s=n[1].dims.slice(),u=new Array(i.length+s.length-1);r=o.ShapeUtil.normalizeAxis(r,i.length);const c=[];for(let t=0;t<u.length;t++)t<r?(u[t]=i[t],c.push(`inputIdx[${t}] = outputIdx[${t}];`)):t<r+s.length?(u[t]=s[t-r],c.push(`indexDataIdx[${t-r}] = outputIdx[${t}];`)):(u[t]=i[t-s.length+1],c.push(`inputIdx[${t-s.length+1}] = outputIdx[${t}];`));const l=`\\n      float process(int outputIdx[${u.length||1}]) {\\n        int inputIdx[${i.length}];\\n        int indexDataIdx[${s.length||1}];\\n        indexDataIdx[0] = 0;\\n        ${c.join(\"\\n        \")}\\n        int idx = int(_B(indexDataIdx));\\n        inputIdx[${r}] = idx < 0 ? idx + ${i[r]} : idx;\\n        return _A(inputIdx);\\n      }`;return Object.assign(Object.assign({},e),{output:{dims:u,type:n[0].type,textureType:a.TextureType.unpacked},shaderSource:l})})(0,r,e,n.axis)})},c=(t,e)=>{if(!t||2!==t.length)throw new Error(\"Gather requires 2 inputs.\");const n=t[0].dims.length;if(n<1)throw new Error(\"Invalid input shape.\");if(e<-n||e>n-1)throw new Error(\"Invalid axis.\");if(-1===i.NUMBER_TYPES.indexOf(t[0].type))throw new Error(\"Invaid input type.\");if(\"int32\"!==t[1].type&&\"int16\"!==t[1].type)throw new Error(\"Invaid input type.\")}},4776:(t,e,n)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.parseGemmAttributesV11=e.parseGemmAttributesV7=e.gemm=void 0;const r=n(246),i=n(2517),o=n(2039);e.gemm=(t,e,n)=>(c(e,n),[t.run(s(e,n),e)]);const a=(t,e)=>{const n=0!==t.attributes.getInt(\"transA\",0),i=0!==t.attributes.getInt(\"transB\",0),o=t.attributes.getFloat(\"alpha\",1),a=t.attributes.getFloat(\"beta\",1);return(0,r.createAttributeWithCacheKey)({transA:n,transB:i,alpha:o,beta:a,isOptionalC:e})};e.parseGemmAttributesV7=t=>a(t,!1),e.parseGemmAttributesV11=t=>a(t,!0);const s=(t,e)=>{const n={name:\"Gemm\",inputNames:3===t.length?[\"A\",\"B\",\"C\"]:[\"A\",\"B\"],inputTypes:3===t.length?[o.TextureType.unpacked,o.TextureType.unpacked,o.TextureType.unpacked]:[o.TextureType.unpacked,o.TextureType.unpacked],key:e.cacheKey};return Object.assign(Object.assign({},n),{get:()=>u(n,t,e)})},u=(t,e,n)=>{const r=e[0].dims.slice(),a=e[1].dims.slice(),[s,u]=i.GemmUtil.getShapeOfGemmResult(r,n.transA,a,n.transB,3===e.length?e[2].dims:void 0),c=[s,u];if(!c)throw new Error(\"Can't use gemm on the given tensors\");let l=r[r.length-1],p=\"\";n.transA&&(l=r[0]),n.transA&&n.transB?p=\"value += _A_T(a) * _B_T(b);\":n.transA&&!n.transB?p=\"value += _A_T(a) * _B(b);\":!n.transA&&n.transB?p=\"value += _A(a) * _B_T(b);\":n.transA||n.transB||(p=\"value += _A(a) * _B(b);\");const f=c.length,d=`\\n      float process(int indices[${f}]) {\\n          int a[${f}];\\n          int b[${f}];\\n          ${3===e.length?`int c[${e[2].dims.length}];`:\"\"}\\n\\n          copyVec(indices, a);\\n          copyVec(indices, b);\\n          ${3===e.length?\"bcastIndices_C(indices, c);\":\"\"}\\n\\n          float value = 0.0;\\n          for (int k=0; k<${l}; ++k) {\\n              a[${f-1}] = k;\\n              b[${f-2}] = k;\\n              ${p}\\n          }\\n\\n          value = value * alpha;\\n          ${3===e.length?\"value += beta * _C(c);\":\"\"}\\n          return value;\\n      }`;return Object.assign(Object.assign({},t),{output:{dims:c,type:e[0].type,textureType:o.TextureType.unpacked},variables:[{name:\"alpha\",type:\"float\",data:n.alpha},{name:\"beta\",type:\"float\",data:n.beta}],shaderSource:d})},c=(t,e)=>{if(!t)throw new Error(\"Input is missing\");if(e.isOptionalC&&(t.length<2||t.length>3))throw new Error(\"Invaid input shape.\");if(!e.isOptionalC&&3!==t.length)throw new Error(\"Gemm requires 3 inputs\");if(3===t.length&&1!==t[2].dims.length&&2!==t[2].dims.length)throw new Error(\"Invalid input shape of C\");if(\"float32\"!==t[0].type&&\"float64\"!==t[0].type||\"float32\"!==t[1].type&&\"float64\"!==t[1].type||3===t.length&&\"float32\"!==t[2].type&&\"float64\"!==t[2].type)throw new Error(\"Invalid input type.\");if(t[0].type!==t[1].type||3===t.length&&t[0].type!==t[2].type)throw new Error(\"Input types are mismatched\")}},8555:(t,e,n)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.createPackedIm2ColProgramInfoLoader=void 0;const r=n(5060),i=n(2039),o=n(2827);e.createPackedIm2ColProgramInfoLoader=(t,e,n,a,s)=>{const u=(c=s.cacheKey,{name:\"Im2Col (packed)\",inputNames:[\"A\"],inputTypes:[i.TextureType.packed],cacheHint:c});var c;return Object.assign(Object.assign({},u),{get:()=>((t,e,n,a,s,u)=>{const c=n.dims,l=a.dims,p=s.length,f=[l[1]*l[2]*l[3],s[2]*s[3]],d=l[2]*l[3],h=(0,o.unpackFromChannel)(),g=(0,r.getGlsl)(t.session.backend.glContext.version);let b=\"\";for(let t=0;t<=1;t++)for(let e=0;e<=1;e++)b+=`\\n            blockIndex = rc.x + ${e};\\n            pos = rc.y + ${t};\\n\\n            if(blockIndex < ${f[1]} && pos < ${f[0]}) {\\n              offsetY = int(blockIndex / (${s[p-1]})) * ${u.strides[0]} -\\n                ${u.pads[0]};\\n              d0 = offsetY + ${u.dilations[0]} * (imod(pos, ${d}) / ${l[2]});\\n\\n              if(d0 < ${c[2]} && d0 >= 0) {\\n                offsetX = imod(blockIndex, ${s[p-1]}) * ${u.strides[1]} -\\n                  ${u.pads[1]};\\n                d1 = offsetX + ${u.dilations[1]} * imod(imod(pos, ${d}), ${l[2]});\\n\\n                if(d1 < ${c[3]} && d1 >= 0) {\\n\\n                  ch = int(float(pos)/ ${d}.);\\n                    innerDims = vec2(d0, d1);\\n                    result[${2*t+e}] = getChannel(\\n                      getA(0, ch, int(innerDims.x),\\n                      int(innerDims.y)), innerDims);\\n                }\\n              }\\n            }\\n\\n          `;const m=`\\n      ${h}\\n\\n      void main() {\\n        ivec2 rc = getOutputCoords();\\n          vec4 result = vec4(0.0);\\n          int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\\n          vec2 innerDims;\\n          ${b}\\n          ${g.output} = result;\\n      }\\n            `;return Object.assign(Object.assign({},e),{output:{dims:f,type:n.type,textureType:i.TextureType.packed},shaderSource:m,hasMain:!0})})(t,u,e,n,a,s)})}},3248:(t,e,n)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.calculateIm2ColDims=e.createIm2ColProgramInfoLoader=void 0;const r=n(2039);e.createIm2ColProgramInfoLoader=(t,n,i,o,a)=>{const s=(u=a.cacheKey,{name:\"Im2Col\",inputNames:[\"X\"],inputTypes:[r.TextureType.unpacked],cacheHint:u});var u;return Object.assign(Object.assign({},s),{get:()=>((t,n,i,o,a,s)=>{const u=i.dims,c=o.dims,l=a.length,p=(0,e.calculateIm2ColDims)(u,c,a,4),f=`\\n        const int XC = ${u[1]};\\n        const int XH = ${u[2]};\\n        const int XW = ${u[3]};\\n        const int KH = ${s.kernelShape[0]};\\n        const int KW = ${s.kernelShape[1]};\\n        const int dilationH = ${s.dilations[0]};\\n        const int dilationW = ${s.dilations[1]};\\n        const int strideH = ${s.strides[0]};\\n        const int strideW = ${s.strides[1]};\\n        const int padH = ${s.pads[0]};\\n        const int padW = ${s.pads[1]};\\n        const int KHKW = KH*KW;\\n        const int XCKHKW = XC * KHKW;\\n        const int outputChannels = 4;\\n        vec4 process(int indices[${l}]) {\\n          int b  = indices[0]; // batch size\\n          int oh = indices[1] * strideH - padH; //output height\\n          int ow = indices[2] * strideW - padW; //output width\\n          int p = indices[3] * outputChannels; //patch\\n          vec4 value = vec4(0.0);\\n          for(int i=0; i < outputChannels; ++i) {\\n            if(p < XCKHKW) {\\n              int patchC = p / KHKW;\\n              int patchH = (p - patchC*KHKW) / KW;\\n              int patchW = (p - patchC*KHKW) - patchH * KW;\\n              int xh2 = oh + patchH * dilationH;\\n              int xw2 = ow + patchW * dilationW;\\n              int x[${u.length}];\\n              x[0] = b;\\n              x[1] = patchC;\\n              x[2] = xh2;\\n              x[3] = xw2;\\n              if(xh2 >= 0 &&\\n                  xh2 < XH &&\\n                  xw2 >= 0 &&\\n                  xw2 < XW) {\\n                value[i] = _X(x);\\n              }\\n            }\\n            ++p;\\n          }\\n          return value;\\n        }\\n        `;return Object.assign(Object.assign({},n),{output:{dims:p,type:i.type,textureType:r.TextureType.packedLastDimension},shaderSource:f})})(0,s,n,i,o,a)})},e.calculateIm2ColDims=(t,e,n,r=4)=>[n[0],n[2],n[3],Math.ceil(t[1]*e[2]*e[3]/r)]},6572:(t,e,n)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.parseImageScalerAttributes=e.imageScaler=void 0;const r=n(246),i=n(2039);e.imageScaler=(t,e,n)=>(u(e),[t.run(a(t,e,n),e)]),e.parseImageScalerAttributes=t=>{const e=t.attributes.getFloat(\"scale\"),n=t.attributes.getFloats(\"bias\");return(0,r.createAttributeWithCacheKey)({scale:e,bias:n})};const o={name:\"ImageScaler\",inputNames:[\"X\"],inputTypes:[i.TextureType.unpacked]},a=(t,e,n)=>{const r=Object.assign(Object.assign({},o),{cacheHint:n.cacheKey});return Object.assign(Object.assign({},r),{get:()=>((t,e,n,r)=>{const o=n[0].dims.slice(),a=o.length,u=`\\n      ${s(r.bias.length)}\\n      float process(int indices[${a}]) {\\n        return _X(indices) * scale + getBias(bias, indices[1]);\\n      }`;return Object.assign(Object.assign({},e),{output:{dims:o,type:n[0].type,textureType:i.TextureType.unpacked},variables:[{name:\"bias\",type:\"float\",arrayLength:r.bias.length,data:r.bias},{name:\"scale\",type:\"float\",data:r.scale}],shaderSource:u})})(0,r,e,n)})},s=t=>{const e=[`float getBias(float bias[${t}], int channel) {`];for(let n=0;n<t;++n)0===n?e.push(`\\tif (channel == ${n}) { return bias[${n}]; }`):n===t-1?e.push(`\\telse { return bias[${n}]; }`):e.push(`\\telse if (channel == ${n}) { return bias[${n}]; }`);return e.push(\"\\t}\"),e.join(\"\\n\")},u=t=>{if(!t||1!==t.length)throw new Error(\"ImageScaler requires 1 input.\");if(4!==t[0].dims.length)throw new Error(\"Invalid input shape.\");if(\"float32\"!==t[0].type&&\"float64\"!==t[0].type)throw new Error(\"Invalid input type.\")}},3346:(t,e,n)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.parseInstanceNormalizationAttributes=e.instanceNormalization=void 0;const r=n(5060),i=n(2039);e.instanceNormalization=(t,e,n)=>{c(e);const r=t.run(a(e[0]),e);return[t.run(u(t,e[0],n,r.dims),[e[0],r,e[1],e[2]])]},e.parseInstanceNormalizationAttributes=t=>t.attributes.getFloat(\"epsilon\",1e-5);const o={name:\"InstanceNormalization_MeanAndVariance\",inputNames:[\"X\"],inputTypes:[i.TextureType.unpacked]},a=t=>Object.assign(Object.assign({},o),{get:()=>((t,e)=>{const n=e.dims.slice(),r=n[1],o=n[2]*n[3],a=[n[0],r],s=`\\n      vec4 process(int[2] indices) {\\n        vec4 v = vec4(0.0);\\n        int a[4];\\n        a[0] = indices[0];\\n        a[1] = indices[1];\\n        float temp = 0.0;\\n        for(int a2=0; a2<${n[2]}; a2++) {\\n          a[2] = a2;\\n          for(int a3=0; a3<${n[3]}; a3++) {\\n            a[3] = a3;\\n            float x = _X(a);\\n            temp += x;\\n          }\\n        }\\n        float mean = temp / float(${o});\\n        temp = 0.0;\\n        for(int a2=0; a2<${n[2]}; a2++) {\\n          a[2] = a2;\\n          for(int a3=0; a3<${n[3]}; a3++) {\\n            a[3] = a3;\\n            float x = _X(a);\\n            temp += (x - mean) * (x - mean);\\n          }\\n        }\\n        v.r = mean;\\n        v.g = temp / float(${o});\\n\\n        return v;\\n      }`;return Object.assign(Object.assign({},t),{output:{dims:a,type:e.type,textureType:i.TextureType.packedLastDimension},shaderSource:s})})(o,t)}),s={name:\"InstanceNormalization_ComputeOutput\",inputNames:[\"X\",\"MeanAndVariance\",\"Scale\",\"B\"],inputTypes:[i.TextureType.unpacked,i.TextureType.packedLastDimension,i.TextureType.unpacked,i.TextureType.unpacked]},u=(t,e,n,o)=>{const a=Object.assign(Object.assign({},s),{cacheHint:`${n}`});return Object.assign(Object.assign({},a),{get:()=>((t,e,n,o,a)=>{const s=(0,r.getGlsl)(t.session.backend.glContext.version),[u,c]=t.calculateTextureWidthAndHeight(a,i.TextureType.packedLastDimension),[l,p]=[u/4,c],f=`\\n      vec4 get_MeanAndVariance(int[2] mv) {\\n        int offset = indicesToOffset_MeanAndVariance(mv);\\n        vec2 coords = offsetToCoords(offset, ${l}, ${p});\\n        return ${s.texture2D}(MeanAndVariance, coords);\\n      }\\n\\n      float process(int[4] indices) {\\n        int mv[2];\\n        mv[0] = indices[0];\\n        mv[1] = indices[1];\\n        vec4 mean_and_variance = get_MeanAndVariance(mv);\\n        float mean = mean_and_variance.r;\\n        float variance = mean_and_variance.g;\\n\\n        int sb[1];\\n        sb[0] = indices[1];\\n        float scale = _Scale(sb);\\n        float b = _B(sb);\\n\\n        return scale * (_X(indices) - mean) / sqrt(variance + epsilon) + b;\\n      }`;return Object.assign(Object.assign({},e),{output:{dims:n.dims,type:n.type,textureType:i.TextureType.unpacked},variables:[{name:\"epsilon\",type:\"float\",data:o}],shaderSource:f})})(t,a,e,n,o)})},c=t=>{if(!t||3!==t.length)throw new Error(\"InstanceNormalization requires 3 inputs.\");const e=t[0],n=t[1],r=t[2];if(e.dims.length<3||1!==n.dims.length||1!==r.dims.length)throw new Error(\"Invalid input shape.\");if(n.dims[0]!==e.dims[1]||r.dims[0]!==e.dims[1])throw new Error(\"Input shapes are mismatched.\");if(\"float32\"!==e.type&&\"float64\"!==e.type||\"float32\"!==n.type&&\"float64\"!==n.type||\"float32\"!==r.type&&\"float64\"!==r.type)throw new Error(\"Invalid input type.\");if(4!==t[0].dims.length)throw new Error(\"Only support 4-D input shape.\")}},708:(t,e,n)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.createPackedMatmulProgramInfoLoader=void 0;const r=n(2517),i=n(5060),o=n(2039),a=n(9390),s=n(2823),u=n(5623);e.createPackedMatmulProgramInfoLoader=(t,e,n)=>{const c=(l=e.length>2,p=n.activationCacheKey,{name:\"MatMul (packed)\",inputNames:l?[\"A\",\"B\",\"Bias\"]:[\"A\",\"B\"],inputTypes:l?[o.TextureType.packed,o.TextureType.packed,o.TextureType.packed]:[o.TextureType.packed,o.TextureType.packed],cacheHint:p});var l,p;return Object.assign(Object.assign({},c),{get:()=>((t,e,n,c)=>{const l=n.length>2,p=l?\"value += getBiasForMatmul();\":\"\",f=n[0].dims,d=n[1].dims,h=r.BroadcastUtil.calcShape(f,d,!0),g=!r.ShapeUtil.areEqual(n[0].dims,n[1].dims);if(!h)throw new Error(\"Can't use matmul on the given tensors\");const b=f[f.length-1],m=Math.ceil(b/2),y=f.length,_=d.length,v=(0,i.getGlsl)(t.session.backend.glContext.version),w=(0,a.getCoordsDataType)(h.length),x=h.length,T=(0,a.getGlChannels)(),{activationFunction:S,applyActivation:O}=(0,s.getActivationSnippet)(c),A=l?`${(0,u.getBiasForMatmul)(w,T,n[2].dims,h,!0)}`:\"\",E=g?`${function(t,e,n,i){let o=[],a=[];const s=n[0].dims,u=n[1].dims,c=s.length,l=u.length,p=i.length,f=p-c,d=p-l;o=s.map(((t,n)=>`coords.${e[n+f]}`)),o[c-1]=\"i*2\",o.join(\", \"),a=u.map(((t,n)=>`coords.${e[n+d]}`)),a[l-2]=\"i*2\",a.join(\", \");const h=r.BroadcastUtil.getBroadcastDims(s,i),g=r.BroadcastUtil.getBroadcastDims(u,i),b=h.map((t=>`coords.${e[t+f]} = 0;`)).join(\"\\n\"),m=g.map((t=>`coords.${e[t+d]} = 0;`)).join(\"\\n\"),y=`int lastDim = coords.${e[p-1]};\\n  coords.${e[p-1]} = coords.${e[p-2]};\\n  coords.${e[p-2]} = lastDim;`;return`\\nvec4 getAAtOutCoordsMatmul(int i) {\\n  ${t} coords = getOutputCoords();\\n  ${y}\\n  ${b}\\n  vec4 outputValue = getA(${o});\\n  return outputValue;\\n}\\n\\nvec4 getBAtOutCoordsMatmul(int i) {\\n  ${t} coords = getOutputCoords();\\n  ${y}\\n  ${m}\\n  vec4 outputValue = getB(${a});\\n  return outputValue;\\n}`}(w,T,n,h)}`:\"\",I=g?\"getAAtOutCoordsMatmul(i)\":`getA(${function(t,e){let n=\"\";for(let r=0;r<e-2;r++)n+=`rc.${t[r]}, `;return n+=`rc.${t[e-2]}, i*2`,n}(T,y)})`,P=g?\"getBAtOutCoordsMatmul(i)\":`getB(${function(t,e){let n=\"\";for(let r=0;r<e-2;r++)n+=`rc.${t[r]}, `;return n+=`i*2, rc.${t[e-1]}`,n}(T,_)})`,D=`\\n            ${E}\\n            ${A}\\n            ${S}\\n            void main() {\\n              ${g?\"\":`${w} rc =\\n          getOutputCoords(); int lastDim = rc.${T[x-1]}; rc.${T[x-1]} =\\n          rc.${T[x-2]}; rc.${T[x-2]} = lastDim;\\n      `}\\n\\n              vec4 value = vec4(0);\\n              for (int i = 0; i < ${m}; i++) {\\n                vec4 a = ${I};\\n                vec4 b = ${P};\\n\\n                value += (a.rrbb * b.rgrg);\\n                value += (a.ggaa * b.baba);\\n              }\\n              ${p}\\n              ${O}\\n              ${v.output} = value;\\n            }`;return Object.assign(Object.assign({},e),{output:{dims:h,type:n[0].type,textureType:o.TextureType.packed},shaderSource:D,hasMain:!0})})(t,c,e,n)})}},5623:(t,e,n)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.getBiasForMatmul=e.createMatmulProgramInfoLoader=e.parseMatMulAttributes=e.matMul=void 0;const r=n(2517),i=n(2039),o=n(9390),a=n(2823),s=n(708);function u(t,e){const n=(s=t.length>2,u=e.activationCacheKey,{name:\"MatMul\",inputNames:s?[\"A\",\"B\",\"Bias\"]:[\"A\",\"B\"],inputTypes:s?[i.TextureType.unpacked,i.TextureType.unpacked,i.TextureType.unpacked]:[i.TextureType.unpacked,i.TextureType.unpacked],cacheHint:u});var s,u;return Object.assign(Object.assign({},n),{get:()=>function(t,e,n){const s=e[0].dims,u=e[1].dims,c=r.BroadcastUtil.calcShape(s,u,!0);if(!c)throw new Error(\"Can't use matmul on the given tensors\");const p=(0,o.getCoordsDataType)(c.length),f=(0,o.getGlChannels)(),{activationFunction:d,applyActivation:h}=(0,a.getActivationSnippet)(n),g=e.length>2,b=g?\"value += getBiasForMatmul();\":\"\",m=g?`${l(p,f,e[2].dims,c,!1)}`:\"\",y=c.length,_=s.length,v=u.length,w=`\\n    ${d}\\n    ${m}\\n    float process(int indices[${y}]) {\\n        int a[${_}];\\n        int b[${v}];\\n        bcastMatmulIndices_A(indices, a);\\n        bcastMatmulIndices_B(indices, b);\\n\\n        float value;\\n        for (int k=0; k<${s[s.length-1]}; ++k) {\\n            a[${_-1}] = k;\\n            b[${v-2}] = k;\\n            value += _A(a) * _B(b);\\n        }\\n        ${b}\\n        ${h}\\n        return value;\\n    }`;return Object.assign(Object.assign({},t),{output:{dims:c,type:e[0].type,textureType:i.TextureType.unpacked},shaderSource:w})}(n,t,e)})}e.matMul=(t,e,n)=>(c(e),t.session.pack?[t.run((0,s.createPackedMatmulProgramInfoLoader)(t,e,n),e)]:[t.run(u(e,n),e)]),e.parseMatMulAttributes=t=>(0,a.parseInternalActivationAttributes)(t.attributes),e.createMatmulProgramInfoLoader=u;const c=t=>{if(!t||2!==t.length)throw new Error(\"MatMul requires 2 inputs.\");if(t[0].dims[t[0].dims.length-1]!==t[1].dims[t[1].dims.length-2])throw new Error(\"shared dimension does not match.\");if(\"float32\"!==t[0].type&&\"float64\"!==t[0].type||\"float32\"!==t[1].type&&\"float64\"!==t[1].type)throw new Error(\"inputs should be float type\");if(t[0].type!==t[1].type)throw new Error(\"inputs types should match\")};function l(t,e,n,i,o){let a=\"\";const s=n.length,u=i.length,c=u-s;a=u<2&&s>0?\"coords\":n.map(((t,n)=>`coords.${e[n+c]}`)).join(\", \");const l=r.BroadcastUtil.getBroadcastDims(n,i).map((t=>`coords.${e[t+c]} = 0;`)).join(\"\\n\");let p=\"vec4(outputValue.xx, outputValue.yy)\";return 1===r.ShapeUtil.size(n)&&(p=\"vec4(outputValue.x)\"),o?`\\nvec4 getBiasForMatmul() {\\n  ${t} coords = getOutputCoords();\\n  ${l}\\n  vec4 outputValue = getBias(${a});\\n  return ${p};\\n}`:`\\nfloat getBiasForMatmul() {\\n  ${t} coords = getOutputCoords();\\n  ${l}\\n  return getBias(coords.x);\\n}`}e.getBiasForMatmul=l},2403:(t,e,n)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.createPackProgramInfoLoader=void 0;const r=n(5060),i=n(2039),o=n(9390),a=n(2827),s={name:\"pack\",inputNames:[\"A\"],inputTypes:[i.TextureType.unpackedReversed]};e.createPackProgramInfoLoader=(t,e)=>Object.assign(Object.assign({},s),{get:()=>((t,e)=>{const n=(0,r.getGlsl)(t.session.backend.glContext.version),u=e.dims,c=u.length,l=e.dims.length,p=(0,o.getCoordsDataType)(l),f=(0,a.getChannels)(\"rc\",l),d=(h=l,g=f,b=u[u.length-2],m=u[u.length-1],0===h||1===h?\"\":`\\n    int r = ${g[h-2]};\\n    int c = ${g[h-1]};\\n    int rp1 = ${g[h-2]} + 1;\\n    int cp1 = ${g[h-1]} + 1;\\n    bool rEdge = rp1 >= ${m};\\n    bool cEdge = cp1 >= ${b};\\n    `);var h,g,b,m;let y;y=0===c?[1,1]:1===c?[u[0],1]:[u[l-1],u[l-2]];const _=function(t,e,n){if(0===t)return\"false\";if(1===t)return`rc > ${e[0]}`;let r=\"\";for(let i=t-2;i<t;i++)r+=`${n[i]} >= ${e[i-t+2]}`,i<t-1&&(r+=\"||\");return r}(l,y,f),v=function(t,e){const n=t.length;if(0===n)return\"getA(), 0, 0, 0\";if(1===n)return`getA(rc),\\n            rc + 1 >= ${t[0]} ? 0. : getA(rc + 1),\\n            0, 0`;let r=\"\";if(n>2)for(let t=0;t<n-2;++t)r+=`${e[t]},`;return`getA(${r}r, c),\\n          rEdge ? 0. : getA(${r}rp1, c),\\n          cEdge ? 0. : getA(${r}r, cp1),\\n          rEdge || cEdge ? 0. : getA(${r}rp1, cp1)`}(u,f),w=`\\n        void main() {\\n          ${p} rc = getOutputCoords();\\n\\n          if(${_}) {\\n            ${n.output} = vec4(0);\\n          } else {\\n            ${d}\\n\\n            ${n.output} = vec4(${v});\\n          }\\n        }\\n      `;return Object.assign(Object.assign({},s),{hasMain:!0,output:{dims:e.dims,type:e.type,textureType:i.TextureType.packed},shaderSource:w})})(t,e)})},2827:(t,e,n)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.unpackFromChannel=e.getChannels=e.getVecChannels=void 0;const r=n(9390);function i(t,e){return(0,r.getGlChannels)(e).map((e=>`${t}.${e}`))}e.getVecChannels=i,e.getChannels=function(t,e){return 1===e?[t]:i(t,e)},e.unpackFromChannel=function(){return\"\\n    float getChannel(vec4 frag, int dim) {\\n      int modCoord = imod(dim, 2);\\n      return modCoord == 0 ? frag.r : frag.g;\\n    }\\n\\n    float getChannel(vec4 frag, vec2 innerDims) {\\n      vec2 modCoord = mod(innerDims, 2.);\\n      return modCoord.x == 0. ?\\n        (modCoord.y == 0. ? frag.r : frag.g) :\\n        (modCoord.y == 0. ? frag.b : frag.a);\\n    }\\n  \"}},2870:(t,e,n)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.parsePadAttributesV11=e.padV11=e.parsePadAttributesV2=e.padV2=void 0;const r=n(246),i=n(2517),o=n(5060),a=n(2039),s={name:\"Pad\",inputNames:[\"A\"],inputTypes:[a.TextureType.unpacked]};e.padV2=(t,e,n)=>(l(e),[t.run(Object.assign(Object.assign({},s),{cacheHint:n.cacheKey,get:()=>c(t,e[0],n)}),e)]),e.parsePadAttributesV2=t=>{const e=t.attributes.getString(\"mode\",\"constant\"),n=t.attributes.getFloat(\"value\",0),i=t.attributes.getInts(\"pads\");return(0,r.createAttributeWithCacheKey)({mode:e,value:n,pads:i})},e.padV11=(t,n,r)=>{p(n);const i=u(t,n,r);return(0,e.padV2)(t,[n[0]],i)},e.parsePadAttributesV11=t=>t.attributes.getString(\"mode\",\"constant\");const u=(t,e,n)=>{if(!t.session.isInitializer(e[1].dataId)||e.length>=3&&!t.session.isInitializer(e[2].dataId))throw new Error(\"dynamic pad attributes are not allowed\");const i=Array.from(e[1].integerData),o=e.length>=3?e[2].floatData[0]:0;return(0,r.createAttributeWithCacheKey)({mode:n,pads:i,value:o})},c=(t,e,n)=>{const r=i.ShapeUtil.padShape(e.dims.slice(),n.pads),o=r.length,s=`\\n      ${f(t,e,n)}\\n      float process(int[${o}] indices) {\\n          return padA(indices);\\n      }`;return{name:\"Pad\",inputNames:[\"A\"],inputTypes:[a.TextureType.unpacked],output:{dims:r,type:e.type,textureType:a.TextureType.unpacked},shaderSource:s}},l=t=>{if(!t||1!==t.length)throw new Error(\"Pad requires 1 input\");if(\"float32\"!==t[0].type&&\"float64\"!==t[0].type)throw new Error(\"Invalid input type.\")},p=t=>{if(!t||2!==t.length&&3!==t.length)throw new Error(\"Pad requires 2 or 3 inputs\");if(\"int32\"!==t[1].type)throw new Error(\"Invalid input type.\");if(t.length>=3&&\"string\"===t[2].type)throw new Error(\"Invalid input type.\")},f=(t,e,n)=>{const r=(0,o.getGlsl)(t.session.backend.glContext.version),[s,u]=t.calculateTextureWidthAndHeight(e.dims,a.TextureType.unpacked),c=i.ShapeUtil.computeStrides(e.dims);switch(n.mode){case\"constant\":return d(r,e.dims,c,s,u,n.pads,n.value);case\"reflect\":return h(r,e.dims,c,s,u,n.pads);case\"edge\":return g(r,e.dims,c,s,u,n.pads);default:throw new Error(\"Invalid mode\")}},d=(t,e,n,r,i,o,a)=>{const s=e.length;let u=\"\";for(let t=s-1;t>=0;--t)u+=`\\n        k = m[${t}] - ${o[t]};\\n        if (k < 0)  return constant;\\n        if (k >= ${e[t]}) return constant;\\n        offset += k * ${n[t]};\\n        `;return`\\n      float padA(int m[${s}]) {\\n        const float constant = float(${a});\\n        int offset = 0;\\n        int k = 0;\\n        ${u}\\n        vec2 coords = offsetToCoords(offset, ${r}, ${i});\\n        float value = getColorAsFloat(${t.texture2D}(A, coords));\\n        return value;\\n      }\\n      `},h=(t,e,n,r,i,o)=>{const a=e.length;let s=\"\";for(let t=a-1;t>=0;--t)s+=`\\n        k = m[${t}] - ${o[t]};\\n        if (k < 0) { k = -k; }\\n        {\\n          const int _2n_1 = ${2*(e[t]-1)};\\n          k = int( mod( float(k), float(_2n_1) ) ) ;\\n          if(k >= ${e[t]}) { k = _2n_1 - k; }\\n        }\\n        offset += k * ${n[t]};\\n        `;return`\\n      float padA(int m[${a}]) {\\n        int offset = 0;\\n        int k = 0;\\n        ${s}\\n        vec2 coords = offsetToCoords(offset, ${r}, ${i});\\n        float value = getColorAsFloat(${t.texture2D}(A, coords));\\n        return value;\\n      }\\n      `},g=(t,e,n,r,i,o)=>{const a=e.length;let s=\"\";for(let t=a-1;t>=0;--t)s+=`\\n        k = m[${t}] - ${o[t]};\\n        if (k < 0)  k = 0;\\n        if (k >= ${e[t]}) k = ${e[t]-1};\\n        offset += k * ${n[t]};\\n      `;return`\\n      float padA(int m[${a}]) {\\n        int offset = 0;\\n        int k = 0;\\n        ${s}\\n        vec2 coords = offsetToCoords(offset, ${r}, ${i});\\n        float value = getColorAsFloat(${t.texture2D}(A, coords));\\n        return value;\\n      }\\n      `}},2143:(t,e,n)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.globalMaxPool=e.parseMaxPoolAttributes=e.maxPool=e.parseGlobalAveragePoolAttributes=e.globalAveragePool=e.parseAveragePoolAttributes=e.averagePool=void 0;const r=n(246),i=n(2517),o=n(2039);e.averagePool=(t,e,n)=>{p(e);const r={name:\"AveragePool\",inputNames:[\"X\"],inputTypes:[o.TextureType.unpacked],cacheHint:n.cacheKey};return[t.run(Object.assign(Object.assign({},r),{get:()=>a(e,r,!1,n)}),e)]},e.parseAveragePoolAttributes=t=>{const e=t.attributes.getString(\"auto_pad\",\"NOTSET\"),n=t.attributes.getInt(\"ceil_mode\",0),i=0!==t.attributes.getInt(\"count_include_pad\",0),o=t.attributes.getInts(\"kernel_shape\"),a=t.attributes.getInts(\"strides\",[]),s=t.attributes.getInts(\"pads\",[]);if(0!==n)throw new Error(\"using ceil() in shape computation is not yet supported for AveragePool\");return(0,r.createAttributeWithCacheKey)({autoPad:e,ceilMode:n,countIncludePad:i,kernelShape:o,strides:a,pads:s})};const a=(t,e,n,r)=>{const[a,s]=u(t,r,n),c=i.ShapeUtil.size(a.kernelShape);let l=\"\";a.countIncludePad?l+=`value /= float(${c});`:l+=`value /= float(${c} - pad);`;const p=`\\n        ${f(t[0].dims,a,\"value += _X(x);\",l,\"0.0\")}\\n      `;return Object.assign(Object.assign({},e),{output:{dims:s,type:t[0].type,textureType:o.TextureType.unpacked},shaderSource:p})};e.globalAveragePool=(t,e,n)=>{p(e);const r={name:\"GlobalAveragePool\",inputNames:[\"X\"],inputTypes:[o.TextureType.unpacked],cacheHint:`${n.countIncludePad}`};return[t.run(Object.assign(Object.assign({},r),{get:()=>a(e,r,!0,n)}),e)]},e.parseGlobalAveragePoolAttributes=t=>{const e=0!==t.attributes.getInt(\"count_include_pad\",0);return(0,r.createAttributeWithCacheKey)({autoPad:\"\",ceilMode:0,countIncludePad:e,kernelShape:[],strides:[],pads:[]})},e.maxPool=(t,e,n)=>{p(e);const r={name:\"MaxPool\",inputNames:[\"X\"],inputTypes:[o.TextureType.unpacked],cacheHint:n.cacheKey};return[t.run(Object.assign(Object.assign({},r),{get:()=>s(e,r,!1,n)}),e)]},e.parseMaxPoolAttributes=t=>{const e=t.attributes.getString(\"auto_pad\",\"NOTSET\"),n=t.attributes.getInt(\"ceil_mode\",0),i=t.attributes.getInts(\"kernel_shape\"),o=t.attributes.getInts(\"strides\",[]),a=t.attributes.getInts(\"pads\",[]),s=t.attributes.getInt(\"storage_order\",0),u=t.attributes.getInts(\"dilations\",[]);if(0!==s)throw new Error(\"column major storage order is not yet supported for MaxPool\");if(0!==n)throw new Error(\"using ceil() in shape computation is not yet supported for MaxPool\");return(0,r.createAttributeWithCacheKey)({autoPad:e,ceilMode:n,countIncludePad:!1,kernelShape:i,strides:o,pads:a,storageOrder:s,dilations:u})};const s=(t,e,n,r)=>{const[i,a]=u(t,r,n),s=`\\n      ${f(t[0].dims,i,\"\\n      value = max(_X(x), value);\\n    \",\"\",\"-1e5\")}\\n    `;return Object.assign(Object.assign({},e),{output:{dims:a,type:t[0].type,textureType:o.TextureType.unpacked},shaderSource:s})},u=(t,e,n)=>{const r=t[0].dims.slice(),o=Object.hasOwnProperty.call(e,\"dilations\"),a=e.kernelShape.slice(),s=e.strides.slice(),u=o?e.dilations.slice():[],c=e.pads.slice();i.PoolConvUtil.adjustPoolAttributes(n,r,a,s,u,c);const l=i.PoolConvUtil.computePoolOutputShape(n,r,s,u,a,c,e.autoPad),p=Object.assign({},e);return o?Object.assign(p,{kernelShape:a,strides:s,pads:c,dilations:u,cacheKey:e.cacheKey}):Object.assign(p,{kernelShape:a,strides:s,pads:c,cacheKey:e.cacheKey}),[p,l]},c={autoPad:\"\",ceilMode:0,countIncludePad:!1,kernelShape:[],strides:[],pads:[],storageOrder:0,dilations:[],cacheKey:\"\"},l={name:\"GlobalMaxPool\",inputNames:[\"X\"],inputTypes:[o.TextureType.unpacked]};e.globalMaxPool=(t,e)=>(p(e),[t.run(Object.assign(Object.assign({},l),{get:()=>s(e,l,!0,c)}),e)]);const p=t=>{if(!t||1!==t.length)throw new Error(\"Pool ops requires 1 input.\");if(\"float32\"!==t[0].type&&\"float64\"!==t[0].type)throw new Error(\"Invalid input type.\")},f=(t,e,n,r,o)=>{const a=t.length;if(e.kernelShape.length<=2){const i=e.kernelShape[e.kernelShape.length-1],s=e.strides[e.strides.length-1],u=e.pads[e.pads.length/2-1],c=e.pads[e.pads.length-1],l=t[a-1];let p=\"\",f=\"\",d=\"\";if(p=u+c!==0?`\\n          for (int i = 0; i < ${i}; i++) {\\n            x[${a} - 1] = indices[${a} - 1] * ${s} - ${u} + i;\\n            if (x[${a} - 1] < 0 || x[${a} - 1] >= ${l}) {\\n              pad++;\\n              continue;\\n            }\\n            ${n}\\n          }`:`\\n          for (int i = 0; i < ${i}; i++) {\\n            x[${a} - 1] = indices[${a} - 1] * ${s} - ${u} + i;\\n            ${n}\\n          }`,2===e.kernelShape.length){const n=e.kernelShape[e.kernelShape.length-2],r=e.strides[e.strides.length-2],o=e.pads[e.pads.length/2-2],s=e.pads[e.pads.length-2],u=t[a-2];f=o+s!==0?`\\n            for (int j = 0; j < ${n}; j++) {\\n              x[${a} - 2] = indices[${a} - 2] * ${r} - ${o} + j;\\n              if (x[${a} - 2] < 0 || x[${a} - 2] >= ${u}) {\\n                pad+= ${i};\\n                continue;\\n              }\\n          `:`\\n            for (int j = 0; j < ${n}; j++) {\\n              x[${a} - 2] = indices[${a} - 2] * ${r} - ${o} + j;\\n            `,d=\"\\n          }\\n        \"}return`\\n        float process(int indices[${a}]) {\\n          int x[${a}];\\n          copyVec(indices, x);\\n\\n          float value = ${o};\\n          int pad = 0;\\n          ${f}\\n          ${p}\\n          ${d}\\n          ${r}\\n          return value;\\n        }\\n      `}{const s=i.ShapeUtil.size(e.kernelShape),u=i.ShapeUtil.computeStrides(e.kernelShape),c=u.length,l=e.pads.length,p=h(c),f=d(t,\"inputDims\"),g=d(e.pads,\"pads\"),b=d(u,\"kernelStrides\"),m=d(e.strides,\"strides\");let y=\"\";return y=e.pads.reduce(((t,e)=>t+e))?`\\n            if (x[j] >= inputDims[j] || x[j] < 0) {\\n              pad++;\\n              isPad = true;\\n              break;\\n            }\\n          }\\n          if (!isPad) {\\n            ${n}\\n          }`:`\\n          }\\n          ${n}\\n        `,`\\n        ${p}\\n        float process(int indices[${a}]) {\\n          int x[${a}];\\n          copyVec(indices, x);\\n          int offset[${c}];\\n          int pads[${l}];\\n          int inputDims[${a}];\\n          int kernelStrides[${c}];\\n          int strides[${c}];\\n          ${g}\\n          ${f}\\n          ${m}\\n          ${b}\\n\\n          float value = ${o};\\n          int pad = 0;\\n          bool isPad = false;\\n          for (int i = 0; i < ${s}; i++) {\\n            offsetToIndices(i, kernelStrides, offset);\\n            isPad = false;\\n            for (int j = ${a} - ${c}; j < ${a}; j++) {\\n              x[j] = indices[j] * strides[j - ${a} + ${c}]\\n                + offset[j - ${a} + ${c}] - pads[j - 2];\\n              ${y}\\n          }\\n          ${r}\\n\\n          return value;\\n        }\\n      `}},d=(t,e)=>{let n=\"\";for(let r=0;r<t.length;r++)n+=`\\n      ${e}[${r}] = ${t[r]};\\n    `;return n},h=t=>`\\n  void offsetToIndices(int offset, int[${t}] strides, out int[${t}] indices) {\\n    if (${t} == 0) {\\n      return;\\n    }\\n    for (int i = 0; i < ${t} - 1; ++i) {\\n      indices[i] = offset / strides[i];\\n      offset -= indices[i] * strides[i];\\n    }\\n    indices[${t} - 1] = offset;\\n  }`},4939:(t,e,n)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.reduceLogSumSquare=e.reduceLogSum=e.reduceProd=e.reduceMin=e.reduceMax=e.reduceMean=e.reduceSum=e.parseReduceAttributes=void 0;const r=n(246),i=n(782),o=n(2517),a=n(2039),s=(t,e,n,r,i)=>{c(e);const o={name:r,inputNames:[\"A\"],inputTypes:[a.TextureType.unpacked]};return[t.run(Object.assign(Object.assign({},o),{cacheHint:n.cacheKey,get:()=>u(t,e,n,r,i,o)}),e)]};e.parseReduceAttributes=t=>{const e=t.attributes.getInts(\"axes\",[]),n=1===t.attributes.getInt(\"keepdims\",1);return(0,r.createAttributeWithCacheKey)({axes:e,keepDims:n})};const u=(t,e,n,r,i,s)=>{const u=[],c=e[0].dims.length||1,l=[],p=o.ShapeUtil.normalizeAxes(n.axes,e[0].dims.length),f=i(e,p);let d=f[1];for(let t=0;t<e[0].dims.length;t++)p.indexOf(t)>=0||0===p.length?(n.keepDims&&u.push(1),d=`\\n          for(int j${t} = 0; j${t} < ${e[0].dims[t]}; j${t}++) {\\n            inputIdx[${t}] = j${t};\\n            ${d}\\n          }`):(l.push(`inputIdx[${t}] = outputIdx[${u.length}];`),u.push(e[0].dims[t]));const h=`\\n      float process(int outputIdx[${u.length||1}]) {\\n        float value;                 // final result\\n        int inputIdx[${c}];      // addressing input data\\n        ${l.join(\"\\n\")}\\n        ${f[0]}       // init ops for reduce max/min\\n        ${d}\\n        ${f[2]}       // final computation for reduce mean\\n        return value;\\n      }`;return Object.assign(Object.assign({},s),{output:{dims:u,type:e[0].type,textureType:a.TextureType.unpacked},shaderSource:h})},c=t=>{if(!t||1!==t.length)throw new Error(\"Reduce op requires 1 input.\");if(-1===i.NUMBER_TYPES.indexOf(t[0].type))throw new Error(\"Invalid input type.\")};e.reduceSum=(t,e,n)=>s(t,e,n,\"ReduceSum\",(()=>[\"value = 0.0;\",\"value += _A(inputIdx);\",\"\"])),e.reduceMean=(t,e,n)=>s(t,e,n,\"ReduceMean\",((t,e)=>{let n=1;for(let r=0;r<t[0].dims.length;r++)(e.indexOf(r)>=0||0===e.length)&&(n*=t[0].dims[r]);return[\"value = 0.0;\",\"value += _A(inputIdx);\",`value /= ${n}.;`]})),e.reduceMax=(t,e,n)=>s(t,e,n,\"ReduceMax\",((t,e)=>{const n=[];for(let r=0;r<t[0].dims.length;r++)(e.indexOf(r)>=0||0===e.length)&&n.push(`inputIdx[${r}] = 0;`);return[`${n.join(\"\\n\")}\\nvalue = _A(inputIdx);`,\"value = max(value, _A(inputIdx));\",\"\"]})),e.reduceMin=(t,e,n)=>s(t,e,n,\"ReduceMin\",((t,e)=>{const n=[];for(let r=0;r<t[0].dims.length;r++)(e.indexOf(r)>=0||0===e.length)&&n.push(`inputIdx[${r}] = 0;`);return[`${n.join(\"\\n\")}\\nvalue = _A(inputIdx);`,\"value = min(value, _A(inputIdx));\",\"\"]})),e.reduceProd=(t,e,n)=>s(t,e,n,\"ReduceProd\",(()=>[\"value = 1.0;\",\"value *= _A(inputIdx);\",\"\"])),e.reduceLogSum=(t,e,n)=>s(t,e,n,\"ReduceLogSum\",(()=>[\"value = 0.0;\",\"value += _A(inputIdx);\",\"value = log(value);\"])),e.reduceLogSumSquare=(t,e,n)=>s(t,e,n,\"ReduceLogSumSquare\",(()=>[\"float t; value = 0.0;\",\"t = _A(inputIdx); value += t * t;\",\"\"]))},7019:(t,e,n)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.isReshapeCheap=e.processDims3D=e.createPackedReshape3DProgramInfoLoader=void 0;const r=n(2517),i=n(5060),o=n(2039),a=n(2827);e.createPackedReshape3DProgramInfoLoader=(t,e,n)=>{const s=(t=>({name:\"Reshape (packed)\",inputTypes:[o.TextureType.packed],inputNames:[\"A\"],cacheHint:`${t}`}))(n);return Object.assign(Object.assign({},s),{get:()=>((t,e,n,s)=>{const u=e.dims,c=s;let l=\"\";for(let t=0;t<4;t++){let e=\"\";switch(t){case 0:e=\"outputCoords = rc;\";break;case 1:e=\"outputCoords = ivec3(rc.x, rc.y+1, rc.z);\";break;case 2:e=\"outputCoords = ivec3(rc.x, rc.y, rc.z+1);\";break;case 3:e=\"outputCoords = ivec3(rc.x, rc.y+1, rc.z+1);\";break;default:throw new Error}l+=`\\n        ${e}\\n        ${t>0?\"if(outputCoords.y < rows && outputCoords.z < cols){\":\"\"}\\n          int flattenedIndex = getFlattenedIndex(outputCoords);\\n\\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flattenedIndex);\\n          vec2 innerDims = vec2(float(inputRC.y),float(inputRC.z));\\n\\n          result[${t}] = getChannel(getA(inputRC.x, inputRC.y, inputRC.z), innerDims);\\n\\n        ${t>0?\"}\":\"\"}\\n      `}const p=(0,i.getGlsl)(t.session.backend.glContext.version),f=`\\n      ${function(t){const e=r.ShapeUtil.computeStrides(t),n=[\"b\",\"r\",\"c\"],i=\"index\";return`\\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\\n      ${e.map(((t,r)=>`int ${n[r]} = ${i} / ${t}; ${r===e.length-1?`int ${n[r+1]} = ${i} - ${n[r]} * ${t}`:`index -= ${n[r]} * ${t}`};`)).join(\"\")}\\n      return ivec3(b, r, c);\\n    }\\n  `}(u)}\\n      ${function(t){const e=r.ShapeUtil.computeStrides(t);return`\\n  int getFlattenedIndex(ivec3 coords) {\\n    // reverse y, z order\\n    return coords.x * ${e[0]} + coords.z * ${e[1]} + coords.y;\\n  }\\n`}(c)}\\n      ${(0,a.unpackFromChannel)()}\\n\\n      void main() {\\n        ivec3 rc = getOutputCoords();\\n\\n        vec4 result = vec4(0.0);\\n\\n        ivec3 outputCoords;\\n        int rows = ${c[2]};\\n        int cols = ${c[1]};\\n\\n        ${l}\\n        ${p.output} = result;\\n      }\\n    `;return Object.assign(Object.assign({},n),{output:{dims:c,type:e.type,textureType:o.TextureType.packed},shaderSource:f,hasMain:!0})})(t,e,s,n)})},e.processDims3D=function(t){if(0===t.length)return[1,1,1];let e=1;for(let n=0;n<t.length-2;++n)e*=t[n];return[e,t.length>1?t[t.length-2]:1,t[t.length-1]]},e.isReshapeCheap=function(t,e){let n=!1;return n=0===t.length||0===e.length||(t.length<2||e.length<2?t[t.length-1]===e[e.length-1]:t[t.length-1]===e[e.length-1]&&t[t.length-2]===e[e.length-2]),n}},718:(t,e,n)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.reshape=void 0;const r=n(2517);e.reshape=(t,e)=>{const n=r.ShapeUtil.calculateReshapedDims(e[0].dims,e[1].integerData);return t.session.pack?[t.reshapePacked(e[0],n)]:[t.reshapeUnpacked(e[0],n)]}},2268:(t,e,n)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.parseResizeAttributesV11=e.parseResizeAttributesV10=e.resize=void 0;const r=n(5060),i=n(2039),o=n(9390),a=n(2827),s=n(9793),u={name:\"Resize\",inputNames:[\"A\"],inputTypes:[i.TextureType.packed]};e.resize=(t,e,n)=>((0,s.validateInputs)(e,n),[t.run(Object.assign(Object.assign({},u),{cacheHint:n.cacheKey,get:()=>c(t,e,n)}),e)]),e.parseResizeAttributesV10=t=>(0,s.parseUpsampleAttributes)(t,10),e.parseResizeAttributesV11=t=>(0,s.parseUpsampleAttributes)(t,11);const c=(t,e,n)=>{const s=(0,r.getGlsl)(t.session.backend.glContext.version),[c,p]=l(e,n);if(c.every((t=>1===t))&&\"tf_crop_and_resize\"!==n.coordinateTransformMode)return Object.assign(Object.assign({},u),{output:{dims:p,type:e[0].type,textureType:i.TextureType.packed},hasMain:!0,shaderSource:`void main() {\\n                    vec4 v = ${s.texture2D}(X, TexCoords);\\n                    ${s.output} = v;\\n                }`});const f=p.length;if(f<2)throw new Error(`output dimension should be at least 2, but got ${f}`);const d=p[f-2],h=p[f-1],g=e[0].dims;if(f!==g.length)throw new Error(`output dimension should match input ${g.length}, but got ${f}`);const b=g[f-2],m=g[f-1],y=c[f-2],_=c[f-1];let v=\"\";if(\"linear\"!==n.mode)throw new Error(`resize (packed) does not support mode: '${n.mode}'`);switch(n.coordinateTransformMode){case\"asymmetric\":v=\"\\n                    vec4 getSourceFracIndex(ivec4 coords) {\\n                        return vec4(coords) / scaleWHWH;\\n                    }\\n                \";break;case\"half_pixel\":v=\"\\n                    vec4 getSourceFracIndex(ivec4 coords) {\\n                        return (vec4(coords) + 0.5) / scaleWHWH - 0.5;\\n                    }\\n                \";break;case\"pytorch_half_pixel\":v=`\\n                    vec4 getSourceFracIndex(ivec4 coords) {\\n                        vec4 fcoords = vec4(coords);\\n                        return vec4(\\n                            ${h}.0 > 1.0 ? (fcoords.x + 0.5) / scaleWHWH.x - 0.5 : 0.0,\\n                            ${d}.0 > 1.0 ? (fcoords.y + 0.5) / scaleWHWH.y - 0.5 : 0.0,\\n                            ${h}.0 > 1.0 ? (fcoords.z + 0.5) / scaleWHWH.z - 0.5 : 0.0,\\n                            ${d}.0 > 1.0 ? (fcoords.w + 0.5) / scaleWHWH.w - 0.5 : 0.0\\n                          );\\n                    }\\n                `;break;case\"align_corners\":v=`\\n                    vec4 getSourceFracIndex(ivec4 coords) {\\n                        vec4 resized = vec4(${h}.0 - 1.0, ${d}.0 - 1.0, ${h}.0 - 1.0,\\n                            ${d}.0 - 1.0);\\n                        vec4 original = vec4(${m}.0 - 1.0, ${b}.0 - 1.0, ${m}.0 - 1.0,\\n                            ${b}.0 - 1.0);\\n                        vec4 new_scale = original / resized;\\n                        return vec4(coords) * new_scale;\\n                    }\\n                `;break;default:throw new Error(`resize (packed) does not support coordinateTransformMode:                                 '${n.coordinateTransformMode}'`)}const w=(0,o.getCoordsDataType)(f),x=`\\n            const vec2 inputWH = vec2(${b}.0, ${m}.0);\\n            const vec4 scaleWHWH = vec4(float(${y}), float(${_}), float(${y}), float(${_}));\\n            ${(0,a.unpackFromChannel)()}\\n            ${v}\\n            float getAValue(int x10, int r, int c, int d) {\\n                return getChannel(getA(x10, r, c, d), vec2(c, d));\\n            }\\n            void main() {\\n                ${w} rc = getOutputCoords();\\n\\n                int batch = rc[0];\\n                int depth = rc[1];\\n\\n                // retrieve the 4 coordinates that is used in the 4 packed output values.\\n                ivec4 coords = ivec4(rc.wz, rc.w + 1, rc.z + 1);\\n\\n                // calculate the source index in fraction\\n                vec4 sourceFrac = getSourceFracIndex(coords);\\n\\n                // get the lower and upper bound of the 4 values that will be packed into one texel.\\n                ivec4 x00 = ivec4(max(sourceFrac.xy, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.xy)));\\n                ivec4 x01 = ivec4(max(sourceFrac.xw, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.xw)));\\n                ivec4 x10 = ivec4(max(sourceFrac.zy, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.zy)));\\n                ivec4 x11 = ivec4(max(sourceFrac.zw, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.zw)));\\n\\n                bool hasNextRow = rc.w < ${d-1};\\n                bool hasNextCol = rc.z < ${h-1};\\n\\n                // pack x00, x01, x10, x11's top-left corner into one vec4 structure\\n                vec4 topLeft = vec4(\\n                    getAValue(batch, depth, x00.x, x00.y),\\n                    hasNextCol ? getAValue(batch, depth, x01.x, x01.y) : 0.0,\\n                    hasNextRow ? getAValue(batch, depth, x10.x, x10.y) : 0.0,\\n                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.x, x11.y) : 0.0);\\n\\n                // pack x00, x01, x10, x11's top-right corner into one vec4 structure\\n                vec4 topRight = vec4(\\n                    getAValue(batch, depth, x00.x, x00.w),\\n                    hasNextCol ? getAValue(batch, depth, x01.x, x01.w) : 0.0,\\n                    hasNextRow ? getAValue(batch, depth, x10.x, x10.w) : 0.0,\\n                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.x, x11.w) : 0.0);\\n\\n                // pack x00, x01, x10, x11's bottom-left corner into one vec4 structure\\n                vec4 bottomLeft = vec4(\\n                    getAValue(batch, depth, x00.z, x00.y),\\n                    hasNextCol ? getAValue(batch, depth, x01.z, x01.y) : 0.0,\\n                    hasNextRow ? getAValue(batch, depth, x10.z, x10.y) : 0.0,\\n                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.z, x11.y) : 0.0);\\n\\n                // pack x00, x01, x10, x11's bottom-right corner into one vec4 structure\\n                vec4 bottomRight = vec4(\\n                    getAValue(batch, depth, x00.z, x00.w),\\n                    hasNextCol ? getAValue(batch, depth, x01.z, x01.w) : 0.0,\\n                    hasNextRow ? getAValue(batch, depth, x10.z, x10.w) : 0.0,\\n                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.z, x11.w) : 0.0);\\n\\n                // calculate the interpolation fraction on u and v direction\\n                vec4 frac = vec4(sourceFrac) - floor(sourceFrac);\\n                vec4 clampFrac = clamp(frac, vec4(0.0), vec4(1.0));\\n\\n                vec4 top = mix(topLeft, topRight, clampFrac.ywyw);\\n                vec4 bottom = mix(bottomLeft, bottomRight, clampFrac.ywyw);\\n                vec4 newValue = mix(top, bottom, clampFrac.xxzz);\\n\\n                ${s.output} = vec4(newValue);\\n            }\\n        `;return Object.assign(Object.assign({},u),{output:{dims:p,type:e[0].type,textureType:i.TextureType.packed},hasMain:!0,shaderSource:x})},l=(t,e)=>{const n=t[0].dims;let r,i=e.scales;if(0===i.length){const o=t[e.scalesInputIdx];if(o&&0!==o.size){if(t[e.sizesInputIdx])throw new Error(\"Only one of scales or sizes must be provided as input.\");i=p(o,e.mode,e.isResize)}else{const o=t[e.sizesInputIdx];if(!o||0===o.size)throw new Error(\"Either scales or sizes MUST be provided as input.\");r=Array.from(o.integerData),i=f(r,n,e.mode,e.isResize)}}else if(t[e.sizesInputIdx])throw new Error(\"Only one of scales or sizes must be provided as input.\");const o=r||n.map(((t,e)=>Math.floor(t*i[e])));return[i,o]},p=(t,e,n)=>{const r=Array.from(t.floatData);return(0,s.scalesValidation)(r,e,n),r},f=(t,e,n,r)=>{const i=e.length,o=new Array(i);for(let n=0,r=i;n<r;n++)if(0===e[n]){if(0!==t[n])throw new Error(\"Input dim is zero but required output dim is non-zero.\");o[n]=1}else o[n]=t[n]/e[n];return(0,s.scalesValidation)(o,n,r),o}},8117:(t,e,n)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.shape=void 0;const r=n(9162);e.shape=(t,e)=>(i(e),[new r.Tensor([e[0].dims.length],\"int32\",void 0,void 0,new Int32Array(e[0].dims))]);const i=t=>{if(!t||1!==t.length)throw new Error(\"Shape requires 1 input.\")}},2278:(t,e,n)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.sliceV10=e.parseSliceAttributes=e.slice=void 0;const r=n(246),i=n(782),o=n(2517),a=n(2039),s={name:\"Slice\",inputNames:[\"A\"],inputTypes:[a.TextureType.unpacked]};e.slice=(t,e,n)=>(c(e),[t.run(Object.assign(Object.assign({},s),{cacheHint:n.cacheKey,get:()=>u(t,e[0],n)}),e)]),e.parseSliceAttributes=t=>{const e=t.attributes.getInts(\"starts\"),n=t.attributes.getInts(\"ends\"),i=t.attributes.getInts(\"axes\",[]);return(0,r.createAttributeWithCacheKey)({starts:e,ends:n,axes:i})};const u=(t,e,n)=>{const r=0===n.axes.length?e.dims.slice(0).map(((t,e)=>e)):n.axes,i=o.ShapeUtil.normalizeAxes(r,e.dims.length),u=n.starts.map(((t,n)=>t>e.dims[i[n]]-1?e.dims[i[n]]:o.ShapeUtil.normalizeAxis(t,e.dims[i[n]]))),c=n.ends.map(((t,n)=>t>e.dims[i[n]]-1?e.dims[i[n]]:o.ShapeUtil.normalizeAxis(t,e.dims[i[n]]))),l=e.dims.slice(),p=[];for(let t=0;t<i.length;t++)l[i[t]]=c[t]-u[t],u[t]>0&&p.push(`outputIdx[${i[t]}] += ${u[t]};`);const f=`\\n      float process(int outputIdx[${l.length}]) {\\n        ${p.join(\"\\n      \")}\\n        return _A(outputIdx);\\n      }`;return Object.assign(Object.assign({},s),{output:{dims:l,type:e.type,textureType:a.TextureType.unpacked},shaderSource:f})},c=t=>{if(!t||1!==t.length)throw new Error(\"Slice requires 1 input.\");if(-1===i.NUMBER_TYPES.indexOf(t[0].type))throw new Error(\"Invalid input type.\")};e.sliceV10=(t,e)=>{p(e);const n=l(t,e);return[t.run(Object.assign(Object.assign({},s),{cacheHint:n.cacheKey,get:()=>u(t,e[0],n)}),[e[0]])]};const l=(t,e)=>{if(!t.session.isInitializer(e[1].dataId)||!t.session.isInitializer(e[2].dataId)||e.length>=4&&!t.session.isInitializer(e[3].dataId)||e.length>=5&&!t.session.isInitializer(e[4].dataId))throw new Error(\"dynamic slice attributes are not allowed\");if(e.length>=5&&e[4].integerData.some((t=>1!==t)))throw new Error(\"currently non-1 steps is not supported for Slice\");const n=Array.from(e[1].integerData),r=Array.from(e[2].integerData),i=e.length>=4?Array.from(e[3].integerData):[];return{starts:n,ends:r,axes:i,cacheKey:`${i};${n};${r}`}},p=t=>{if(!t||t.length<3||t.length>5)throw new Error(\"Invalid input number.\");if(\"int32\"!==t[1].type||1!==t[1].dims.length)throw new Error(\"Invalid input type.\");if(\"int32\"!==t[2].type||1!==t[2].dims.length)throw new Error(\"Invalid input type.\");if(t.length>=4&&(\"int32\"!==t[3].type||1!==t[3].dims.length))throw new Error(\"Invalid input type.\");if(t.length>=5&&(\"int32\"!==t[4].type||1!==t[4].dims.length))throw new Error(\"Invalid input type.\")}},5524:(t,e,n)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.softmaxV13=e.parseSoftmaxAttributesV13=e.parseSoftmaxAttributes=e.softmax=void 0;const r=n(246),i=n(2517),o=n(5060),a=n(2039),s=n(3738),u={name:\"SoftmaxComputeMax\",inputNames:[\"A\"],inputTypes:[a.TextureType.unpacked]},c={name:\"SoftmaxComputeScale\",inputNames:[\"A\",\"Max\"],inputTypes:[a.TextureType.unpacked,a.TextureType.unpacked]},l={name:\"SoftMax\",inputNames:[\"A\",\"Max\",\"Norm\"],inputTypes:[a.TextureType.unpacked,a.TextureType.unpacked,a.TextureType.unpacked]};e.softmax=(t,e,n)=>{g(e);const r=e[0].dims.slice(),o=i.ShapeUtil.normalizeAxis(n.axis,r.length),a=i.ShapeUtil.sizeToDimension(r,o),s=i.ShapeUtil.sizeFromDimension(r,o);return p(t,e,n,a,s)},e.parseSoftmaxAttributes=t=>(0,r.createAttributeWithCacheKey)({axis:t.attributes.getInt(\"axis\",1)}),e.parseSoftmaxAttributesV13=t=>(0,r.createAttributeWithCacheKey)({axis:t.attributes.getInt(\"axis\",-1)}),e.softmaxV13=(t,e,n)=>{g(e);const o=e[0].dims.slice(),a=i.ShapeUtil.normalizeAxis(n.axis,o.length),u=o.length,c=a!==u-1,l=[];let f,d=[],h=[];c&&(d=Array.from({length:u}).map(((t,e)=>e)),d[a]=u-1,d[u-1]=a,d.map((t=>l.push(o[t]))),f=(0,r.createAttributeWithCacheKey)({perm:d}),h=(0,s.transpose)(t,e,f));const b=c?i.ShapeUtil.sizeToDimension(l,u-1):i.ShapeUtil.sizeToDimension(o,u-1),m=c?i.ShapeUtil.sizeFromDimension(l,u-1):i.ShapeUtil.sizeFromDimension(o,u-1),y=p(t,c?h:e,n,b,m);return c?(0,s.transpose)(t,y,f):y};const p=(t,e,n,r,i)=>{const o=f(t,e[0],r,i,[r]),a=t.run(Object.assign(Object.assign({},u),{cacheHint:n.cacheKey,get:()=>o}),e),s=d(t,e[0],r,i,o.output.dims,[r]),p=t.run(Object.assign(Object.assign({},c),{cacheHint:n.cacheKey,get:()=>s}),[e[0],a]),g=h(t,e[0],r,i,o.output.dims,s.output.dims);return[t.run(Object.assign(Object.assign({},l),{cacheHint:n.cacheKey,get:()=>g}),[e[0],a,p])]},f=(t,e,n,r,i)=>{const[s,c]=t.calculateTextureWidthAndHeight(e.dims,a.TextureType.unpacked),l=i.length;if(n<1||r<1)throw new Error(\"Logical row count N and feature count D must be greater than or equal to 1\");if(1!==i.length)throw new Error(\"Dimensionality of the output should be 1\");if(i[0]!==n)throw new Error(\"Shape of the output should be equal to logical row count\");const p=(0,o.getGlsl)(t.session.backend.glContext.version),f=`\\n      float process(int[${l}] indices) {\\n        int logical_row_start_offset = indices[0] * ${r};\\n\\n        float max = getColorAsFloat(${p.texture2D}(A, offsetToCoords(logical_row_start_offset, ${s},\\n        ${c} )));\\n        for(int i=1; i<${r}; ++i)\\n        {\\n          float current = getColorAsFloat(${p.texture2D}(A, offsetToCoords(logical_row_start_offset + i,\\n            ${s}, ${c})));\\n          if(current > max)\\n          max = current;\\n        }\\n\\n        return max;\\n      }`;return Object.assign(Object.assign({},u),{output:{dims:i,type:e.type,textureType:a.TextureType.unpacked},shaderSource:f})},d=(t,e,n,r,i,s)=>{const[u,l]=t.calculateTextureWidthAndHeight(e.dims,a.TextureType.unpacked),p=s.length;if(n<1||r<1)throw new Error(\"Logical row count N and feature count D must be greater than or equal to 1\");if(1!==s.length)throw new Error(\"Dimensionality of the output should be 1\");if(s[0]!==n)throw new Error(\"Shape of the output should be equal to logical row count\");if(1!==i.length)throw new Error(\"Dimensionality of the intermediate results should be 1\");if(i[0]!==n)throw new Error(\"Shape of the intermediate results should be equal to logical row count\");const f=`\\n      float process(int[${p}] indices) {\\n        int logical_row_start_offset = indices[0] * ${r};\\n\\n        float norm_factor = 0.0;\\n        float max = _Max(indices);\\n        for(int i=0; i<${r}; ++i)\\n        {\\n          norm_factor += exp(getColorAsFloat(${(0,o.getGlsl)(t.session.backend.glContext.version).texture2D}(A, offsetToCoords(logical_row_start_offset + i,\\n            ${u}, ${l}))) - max);\\n        }\\n\\n        return norm_factor;\\n      }`;return Object.assign(Object.assign({},c),{output:{dims:s,type:e.type,textureType:a.TextureType.unpacked},shaderSource:f})},h=(t,e,n,r,i,o)=>{const[s,u]=t.calculateTextureWidthAndHeight(e.dims,a.TextureType.unpacked),c=e.dims.length;if(n<1||r<1)throw new Error(\"Logical row count N and feature count D must be greater than or equal to 1\");if(1!==i.length||1!==o.length)throw new Error(\"Dimensionality of the intermediate results should be 1\");if(i[0]!==n||o[0]!==n)throw new Error(\"Shape of the intermediate results should be equal to logical row count\");const p=`\\n      float process(int[${c}] indices) {\\n\\n      // get offset of current logical tensor index from the 2-D texture coordinates (TexCoords)\\n      int offset = coordsToOffset(TexCoords, ${s}, ${u});\\n\\n      //determine the logical row for this index\\n      int logical_row_index[1];\\n      logical_row_index[0] = offset / ${r};\\n\\n      float norm_factor = _Norm(logical_row_index);\\n\\n      // avoid possible division by 0\\n      // if norm_facor is 0, all elements are zero\\n      // if so, return 0\\n      if(norm_factor == 0.0)\\n        return 0.0;\\n\\n      return exp(_A(indices) - _Max(logical_row_index)) / norm_factor;\\n    }`;return Object.assign(Object.assign({},l),{output:{dims:e.dims,type:e.type,textureType:a.TextureType.unpacked},shaderSource:p})},g=t=>{if(!t||1!==t.length)throw new Error(\"Softmax requires 1 input.\");if(\"float32\"!==t[0].type&&\"float64\"!==t[0].type)throw new Error(\"Invalid input type\")}},5975:(t,e,n)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.parseSplitAttributes=e.split=void 0;const r=n(246),i=n(2517),o=n(2039),a={name:\"Split\",inputNames:[\"A\"],inputTypes:[o.TextureType.unpacked]};e.split=(t,e,n)=>{c(e);const r=i.ShapeUtil.normalizeAxis(n.axis,e[0].dims.length),o=s(t,e,r,n),l=[];for(let i=0;i<o;++i)l.push(t.run(Object.assign(Object.assign({},a),{cacheHint:`${n.cacheKey};${i}`,get:()=>u(t,e[0],n,r,i)}),e));return l},e.parseSplitAttributes=t=>{const e=t.attributes.getInt(\"axis\",0),n=t.attributes.getInts(\"split\",[]),i=t.outputs.length;return(0,r.createAttributeWithCacheKey)({axis:e,split:n,numOutputs:i})};const s=(t,e,n,r)=>{const[,o]=i.SplitUtil.splitShape(e[0].dims,n,r.split,r.numOutputs);return o.length},u=(t,e,n,r,s)=>{const[u,c]=i.SplitUtil.splitShape(e.dims,r,n.split,n.numOutputs),l=c[s],p=u[s],f=`\\n      float process(int indices[${p.length}]) {\\n        indices[${r}] += ${l};\\n        return _A(indices);\\n      }\\n    `;return Object.assign(Object.assign({},a),{cacheHint:`${n.cacheKey}:${s}`,output:{dims:p,type:e.type,textureType:o.TextureType.unpacked},shaderSource:f})},c=t=>{if(!t||1!==t.length)throw new Error(\"Split requires one input.\");if(\"int8\"!==t[0].type&&\"uint8\"!==t[0].type&&\"int16\"!==t[0].type&&\"uint16\"!==t[0].type&&\"int32\"!==t[0].type&&\"uint32\"!==t[0].type&&\"float32\"!==t[0].type&&\"float64\"!==t[0].type&&\"bool\"!==t[0].type)throw new Error(\"Invalid input type.\")}},3933:(t,e,n)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.parseSqueezeAttributes=e.squeezeV13=e.squeeze=void 0;const r=n(2517);e.squeeze=(t,e,n)=>{i(e);const o=r.ShapeUtil.squeezeShape(e[0].dims,n);return[t.reshapeUnpacked(e[0],o)]},e.squeezeV13=(t,n)=>(o(n),(0,e.squeeze)(t,[n[0]],Array.from(n[1].integerData))),e.parseSqueezeAttributes=t=>t.attributes.getInts(\"axes\");const i=t=>{if(!t||1!==t.length)throw new Error(\"Squeeze requires 1 input.\");if(\"string\"===t[0].type)throw new Error(\"invalid input tensor types.\")},o=t=>{if(!t||2!==t.length)throw new Error(\"Squeeze requires 2 inputs.\");if(\"int32\"!==t[1].type)throw new Error(\"Invalid input type.\")}},6558:(t,e,n)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.sum=void 0;const r=n(5060),i=n(2039);e.sum=(t,e)=>{a(e);const n={name:\"Sum\",inputNames:e.map(((t,e)=>`X${e}`)),inputTypes:new Array(e.length).fill(i.TextureType.unpacked)};return[t.run(Object.assign(Object.assign({},n),{get:()=>o(t,e,n)}),e)]};const o=(t,e,n)=>{const o=(0,r.getGlsl)(t.session.backend.glContext.version),a=e[0].dims.slice(),s=`\\n      void main() {\\n        vec4 result = ${e.map(((t,e)=>`${o.texture2D}(X${e},TexCoords)`)).join(\" + \")};\\n        ${o.output} = result;\\n      }\\n    `;return Object.assign(Object.assign({},n),{output:{dims:a,type:e[0].type,textureType:i.TextureType.unpacked},hasMain:!0,shaderSource:s})},a=t=>{if(!t||0===t.length)throw new Error(\"Sum requires inputs.\");const e=t[0].dims.length;for(let n=1;n<t.length;n++){if(e!==t[n].dims.length)throw new Error(\"Input shapes are mismatched.\");for(let r=0;r<e;r++)if(t[0].dims[r]!==t[n].dims[r])throw new Error(\"Input shapes are not matched.\")}if(\"float32\"!==t[0].type&&\"float64\"!==t[0].type)throw new Error(\"Invalid input type.\");for(let e=1;e<t.length;e++)if(t[0].type!==t[e].type)throw new Error(\"Input types are not matched.\")}},5723:(t,e,n)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.tile=void 0;const r=n(782),i=n(2039);e.tile=(t,e)=>{a(e);const n={name:\"Tile\",inputNames:[\"A\"],inputTypes:[i.TextureType.unpacked]};return[t.run(Object.assign(Object.assign({},n),{get:()=>o(t,e,n)}),e)]};const o=(t,e,n)=>{const r=e[0].dims.slice(),o=new Array(r.length),a=[];for(let t=0;t<r.length;t++)o[t]=r[t]*e[1].numberData[t],a.push(`inputIdx[${t}] = int(mod(float(outputIdx[${t}]), ${r[t]}.));`);const s=o.length,u=`\\n      float process(int outputIdx[${s}]) {\\n        int inputIdx[${s}];\\n        ${a.join(\"\\n\")}\\n        return _A(inputIdx);\\n      }\\n    `;return Object.assign(Object.assign({},n),{output:{dims:o,type:e[0].type,textureType:i.TextureType.unpacked},shaderSource:u})},a=t=>{if(!t||2!==t.length)throw new Error(\"Tile requires 2 input.\");if(1!==t[1].dims.length)throw new Error(\"The second input shape must 1 dimension.\");if(t[1].dims[0]!==t[0].dims.length)throw new Error(\"Invalid input shape.\");if(-1===r.NUMBER_TYPES.indexOf(t[0].type))throw new Error(\"Invalid input type.\");if(\"int32\"!==t[1].type&&\"int16\"!==t[1].type)throw new Error(\"Invalid repeat type.\")}},3738:(t,e,n)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.parseTransposeAttributes=e.transpose=void 0;const r=n(246),i=n(2517),o=n(2039),a={name:\"Transpose\",inputNames:[\"A\"],inputTypes:[o.TextureType.unpacked]};e.transpose=(t,e,n)=>(p(e),[t.run(Object.assign(Object.assign({},a),{cacheHint:n.cacheKey,get:()=>s(t,e[0],n.perm)}),e)]),e.parseTransposeAttributes=t=>(0,r.createAttributeWithCacheKey)({perm:t.attributes.getInts(\"perm\",[])});const s=(t,e,n)=>{const r=e.dims;n=u(r,n);const i=c(r,n),s=r.length,p=`\\n      ${l(\"perm\",n,s)}\\n      float process(int indices[${s}]) {\\n        int a[${s}];\\n        perm(a, indices);\\n        return _A(a);\\n      }`;return Object.assign(Object.assign({},a),{output:{dims:i,type:e.type,textureType:o.TextureType.unpacked},shaderSource:p})},u=(t,e)=>(e&&e.length!==t.length&&(e=[...t.keys()].reverse()),e),c=(t,e)=>(e=u(t,e),i.ShapeUtil.sortBasedOnPerm(t,e)),l=(t,e,n)=>{const r=[];r.push(`void ${t}(out int a[${n}], int src[${n}]) {`);for(let t=0;t<n;++t)r.push(`\\ta[${e[t]}]=src[${t}];`);return r.push(\"\\t}\"),r.join(\"\\n\")},p=t=>{if(!t||1!==t.length)throw new Error(\"Transpose requires 1 input.\");if(\"float32\"!==t[0].type&&\"float64\"!==t[0].type)throw new Error(\"input should be float tensor\")}},8710:(t,e,n)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.encodeAsUint8=void 0;const r=n(5060),i=n(2039);e.encodeAsUint8=(t,e)=>{const n=e.shape,o=(0,r.getGlsl)(t.session.backend.glContext.version),a=`\\n    const float FLOAT_MAX = 1.70141184e38;\\n    const float FLOAT_MIN = 1.17549435e-38;\\n\\n    bool isNaN(float val) {\\n      return (val < 1.0 || 0.0 < val || val == 0.0) ? false : true;\\n    }\\n\\n    highp vec4 encodeAsUint8(highp float v) {\\n      if (isNaN(v)) {\\n        return vec4(255, 255, 255, 255);\\n      }\\n\\n      highp float av = abs(v);\\n\\n      if(av < FLOAT_MIN) {\\n        return vec4(0.0, 0.0, 0.0, 0.0);\\n      } else if(v > FLOAT_MAX) {\\n        return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\\n      } else if(v < -FLOAT_MAX) {\\n        return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\\n      }\\n\\n      highp vec4 c = vec4(0,0,0,0);\\n\\n      highp float e = floor(log2(av));\\n      highp float m = exp2(fract(log2(av))) - 1.0;\\n\\n      c[2] = floor(128.0 * m);\\n      m -= c[2] / 128.0;\\n      c[1] = floor(32768.0 * m);\\n      m -= c[1] / 32768.0;\\n      c[0] = floor(8388608.0 * m);\\n\\n      highp float ebias = e + 127.0;\\n      c[3] = floor(ebias / 2.0);\\n      ebias -= c[3] * 2.0;\\n      c[2] += floor(ebias) * 128.0;\\n\\n      c[3] += 128.0 * step(0.0, -v);\\n\\n      return c / 255.0;\\n    }\\n\\n    void main() {\\n      float value = ${o.texture2D}(X,TexCoords).r;\\n      ${o.output} = encodeAsUint8(value);\\n    }`,s={name:\"Uint8Encode\",inputTypes:[i.TextureType.unpacked],inputNames:[\"X\"],output:{dims:n,type:e.tensor.type,textureType:i.TextureType.downloadUint8AsFloat},shaderSource:a,hasMain:!0};return t.executeProgram(s,[e.tensor])}},4909:(t,e,n)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.tanh=e.tan=e.sqrt=e.sin=e.sigmoid=e.relu=e.not=e.neg=e.log=e.parseLeakyReluAttributes=e.leakyRelu=e.identity=e.floor=e.exp=e.parseEluAttributes=e.elu=e.cos=e.ceil=e.clipV11=e.parseClipAttributes=e.clip=e.atan=e.asin=e.acos=e.abs=e.glslTanh=e.glslTan=e.glslSqrt=e.glslSigmoid=e.glslRelu=e.glslSin=e.glslNot=e.glslNeg=e.glslLog=e.glslLeakyRelu=e.glslIdentity=e.glslClip=e.glslFloor=e.glslExp=e.glslElu=e.glslCos=e.glslCeil=e.glslAtan=e.glslAsin=e.glslAcos=e.glslAbs=void 0;const r=n(246),i=n(2517),o=n(8520),a=n(5060),s=n(2039);function u(){return P(\"abs\")}function c(){return P(\"acos\")}function l(){return P(\"asin\")}function p(){return P(\"atan\")}function f(){return P(\"ceil\")}function d(){return P(\"cos\")}function h(t){const e=\"elu\";return{body:`\\n  const float alpha = float(${t});\\n\\n  float ${e}_(float a) {\\n    return a >= 0.0 ? a: (exp(a) - 1.0) * alpha;\\n  }\\n  vec4 ${e}_(vec4 v) {\\n    return vec4(${e}_(v.x), ${e}_(v.y), ${e}_(v.z), ${e}_(v.w));\\n  }\\n  `,name:e,type:o.FunctionType.ValueBased}}function g(){return P(\"exp\")}function b(){return P(\"floor\")}function m(t,e){const n=\"clip\";return{body:`\\n  const float min = float(${t});\\n  const float max = float(${e});\\n\\n  float ${n}_(float a) {\\n    return clamp(a, min, max);\\n  }\\n  vec4 ${n}_(vec4 v) {\\n    return clamp(v, min, max);\\n  }\\n  `,name:n,type:o.FunctionType.ValueBased}}function y(){const t=\"indentity\";return{body:`\\n  float ${t}_(float a) {\\n    return a;\\n  }\\n  vec4 ${t}_(vec4 v) {\\n    return v;\\n  }\\n  `,name:t,type:o.FunctionType.ValueBased}}function _(t){const e=\"leakyRelu\";return{body:`\\n  const float alpha = float(${t});\\n\\n  float ${e}_(float a) {\\n    return a < 0.0 ? a * alpha : a;\\n  }\\n  vec4 ${e}_(vec4 v) {\\n    return vec4(${e}_(v.x), ${e}_(v.y), ${e}_(v.z), ${e}_(v.w));\\n  }\\n  `,name:e,type:o.FunctionType.ValueBased}}function v(){return P(\"log\")}function w(){const t=\"neg\";return{body:`\\n  float ${t}_(float a) {\\n    return -a;\\n  }\\n  vec4 ${t}_(vec4 v) {\\n    return -v;\\n  }\\n  `,name:t,type:o.FunctionType.ValueBased}}function x(){const t=\"not\";return{body:`\\n  float ${t}_(float a) {\\n    return float( ! bool(a) );\\n  }\\n  bool ${t}_(bool a) {\\n    return !a;\\n  }\\n  vec4 ${t}_(vec4 v) {\\n    return vec4(!bool(v.x), !bool(v.y), !bool(v.z), !bool(v.w));\\n  }\\n  bvec4 ${t}_(bvec4 v) {\\n    return bvec4(!v.x, !v.y, !v.z, !v.w);\\n  }\\n  `,name:t,type:o.FunctionType.ValueBased}}function T(){return P(\"sin\")}function S(){const t=\"relu\";return{body:`\\n  float ${t}_(float a) {\\n    return max( a, 0.0 );\\n  }\\n  vec4 ${t}_(vec4 v) {\\n    return max( v, 0.0 );\\n  }\\n  `,name:t,type:o.FunctionType.ValueBased}}function O(){const t=\"sigmoid\";return{body:`\\n  float ${t}_(float a) {\\n    return 1.0 / (1.0 + exp(-a));\\n  }\\n  vec4 ${t}_(vec4 v) {\\n    return 1.0 / (1.0 + exp(-v));\\n  }\\n  `,name:t,type:o.FunctionType.ValueBased}}function A(){return P(\"sqrt\")}function E(){return P(\"tan\")}function I(){const t=\"tanh\";return{body:`\\n  float ${t}_(float a) {\\n    a = clamp(a, -10., 10.);\\n    a = exp(2.*a);\\n    return (a - 1.) / (a + 1.);\\n  }\\n  vec4 ${t}_(vec4 v) {\\n    v = clamp(v, -10., 10.);\\n    v = exp(2.*v);\\n    return (v - 1.) / (v + 1.);\\n  }\\n  `,name:t,type:o.FunctionType.ValueBased}}function P(t){return{body:`\\n  float ${t}_(float a) {\\n    return ${t}(a);\\n  }\\n  vec4 ${t}_(vec4 v) {\\n    return ${t}(v);\\n  }\\n  `,name:t,type:o.FunctionType.ValueBased}}e.glslAbs=u,e.glslAcos=c,e.glslAsin=l,e.glslAtan=p,e.glslCeil=f,e.glslCos=d,e.glslElu=h,e.glslExp=g,e.glslFloor=b,e.glslClip=m,e.glslIdentity=y,e.glslLeakyRelu=_,e.glslLog=v,e.glslNeg=w,e.glslNot=x,e.glslSin=T,e.glslRelu=S,e.glslSigmoid=O,e.glslSqrt=A,e.glslTan=E,e.glslTanh=I;const D=(t,e,n,r)=>{const i=t.session.pack?s.TextureType.packed:s.TextureType.unpacked,o={name:n.name,inputTypes:[i],inputNames:[\"A\"],cacheHint:r};return Object.assign(Object.assign({},o),{get:()=>((t,e,n,r)=>{const i=t.session.pack?s.TextureType.packed:s.TextureType.unpacked,o=(0,a.getGlsl)(t.session.backend.glContext.version);return Object.assign(Object.assign({},e),{output:{dims:n.dims,type:n.type,textureType:i},shaderSource:`\\n     ${r.body}\\n     void main() {\\n       vec4 v = ${o.texture2D}(A, TexCoords);\\n       v = ${r.name}_(v);\\n       ${o.output} = v;\\n     }\\n     `,hasMain:!0})})(t,o,e,n)})};e.abs=(t,e)=>[t.run(D(t,e[0],u()),e)],e.acos=(t,e)=>[t.run(D(t,e[0],c()),e)],e.asin=(t,e)=>[t.run(D(t,e[0],l()),e)],e.atan=(t,e)=>[t.run(D(t,e[0],p()),e)],e.clip=(t,e,n)=>[t.run(D(t,e[0],m(n.min,n.max),n.cacheKey),e)],e.parseClipAttributes=t=>(0,r.createAttributeWithCacheKey)({min:t.attributes.getFloat(\"min\",i.MIN_CLIP),max:t.attributes.getFloat(\"max\",i.MAX_CLIP)}),e.clipV11=(t,n)=>{const r=$(t,n);return(0,e.clip)(t,[n[0]],r)};const $=(t,e)=>{if(e.length>=3&&(!t.session.isInitializer(e[1].dataId)||!t.session.isInitializer(e[2].dataId)))throw new Error(\"dynamic clip attributes are not allowed\");const n=e.length>=3?e[1].numberData[0]:i.MIN_CLIP,o=e.length>=3?e[2].numberData[0]:i.MAX_CLIP;return(0,r.createAttributeWithCacheKey)({min:n,max:o})};e.ceil=(t,e)=>[t.run(D(t,e[0],f()),e)],e.cos=(t,e)=>[t.run(D(t,e[0],d()),e)],e.elu=(t,e,n)=>[t.run(D(t,e[0],h(n.alpha),n.cacheKey),e)],e.parseEluAttributes=t=>(0,r.createAttributeWithCacheKey)({alpha:t.attributes.getFloat(\"alpha\",1)}),e.exp=(t,e)=>[t.run(D(t,e[0],g()),e)],e.floor=(t,e)=>[t.run(D(t,e[0],b()),e)],e.identity=(t,e)=>[t.run(D(t,e[0],y()),e)],e.leakyRelu=(t,e,n)=>[t.run(D(t,e[0],_(n.alpha),n.cacheKey),e)],e.parseLeakyReluAttributes=t=>(0,r.createAttributeWithCacheKey)({alpha:t.attributes.getFloat(\"alpha\",.01)}),e.log=(t,e)=>[t.run(D(t,e[0],v()),e)],e.neg=(t,e)=>[t.run(D(t,e[0],w()),e)],e.not=(t,e)=>[t.run(D(t,e[0],x()),e)],e.relu=(t,e)=>[t.run(D(t,e[0],S()),e)],e.sigmoid=(t,e)=>[t.run(D(t,e[0],O()),e)],e.sin=(t,e)=>[t.run(D(t,e[0],T()),e)],e.sqrt=(t,e)=>[t.run(D(t,e[0],A()),e)],e.tan=(t,e)=>[t.run(D(t,e[0],E()),e)],e.tanh=(t,e)=>[t.run(D(t,e[0],I()),e)]},5611:(t,e,n)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.createUnpackProgramInfoLoader=e.createUnpackProgramInfo=void 0;const r=n(5060),i=n(2039),o=n(9390),a=n(2827),s={name:\"unpack\",inputNames:[\"A\"],inputTypes:[i.TextureType.packed]};e.createUnpackProgramInfo=(t,e)=>{const n=e.dims.length,u=(0,a.getChannels)(\"rc\",n),c=u.slice(-2),l=(0,o.getCoordsDataType)(n),p=(0,a.unpackFromChannel)(),f=0===e.dims.length?\"\":function(t,e){if(1===t)return\"rc\";let n=\"\";for(let r=0;r<t;r++)n+=e[r],r<t-1&&(n+=\",\");return n}(n,u),d=n<=1?\"rc\":`vec2(${c.join(\",\")})`,h=`\\n    ${p}\\n    void main() {\\n      ${l} rc = getOutputCoords();\\n\\n       // Sample the texture with the coords to get the rgba channel value.\\n       vec4 packedInput = getA(${f});\\n\\n       ${(0,r.getGlsl)(t.session.backend.glContext.version).output} = vec4(getChannel(packedInput, ${d}), 0, 0, 0);\\n     }\\n   `;return Object.assign(Object.assign({},s),{hasMain:!0,output:{dims:e.dims,type:e.type,textureType:i.TextureType.unpacked},shaderSource:h})},e.createUnpackProgramInfoLoader=(t,n)=>Object.assign(Object.assign({},s),{get:()=>(0,e.createUnpackProgramInfo)(t,n)})},8428:(t,e,n)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.parseUnsqueezeAttributes=e.unsqueezeV13=e.unsqueeze=void 0;const r=n(2517);e.unsqueeze=(t,e,n)=>{i(e);const o=r.ShapeUtil.unsqueezeShape(e[0].dims,n);return[t.reshapeUnpacked(e[0],o)]},e.unsqueezeV13=(t,n)=>(o(n),(0,e.unsqueeze)(t,[n[0]],Array.from(n[1].integerData))),e.parseUnsqueezeAttributes=t=>t.attributes.getInts(\"axes\");const i=t=>{if(!t||1!==t.length)throw new Error(\"Unsqueeze requires 1 input.\");if(\"string\"===t[0].type)throw new Error(\"invalid input tensor types.\")},o=t=>{if(!t||2!==t.length)throw new Error(\"Unsqueeze requires 2 inputs.\");if(\"int32\"!==t[1].type)throw new Error(\"Invalid input type.\")}},9793:(t,e,n)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.scalesValidation=e.validateInputs=e.parseUpsampleAttributes=e.parseUpsampleAttributesV9=e.parseUpsampleAttributesV7=e.upsample=void 0;const r=n(246),i=n(5060),o=n(2039),a={name:\"Upsample\",inputNames:[\"X\"],inputTypes:[o.TextureType.unpacked]};e.upsample=(t,n,r)=>((0,e.validateInputs)(n,r),[t.run(Object.assign(Object.assign({},a),{cacheHint:r.cacheKey,get:()=>s(t,n,r)}),n)]),e.parseUpsampleAttributesV7=t=>(0,e.parseUpsampleAttributes)(t,7),e.parseUpsampleAttributesV9=t=>(0,e.parseUpsampleAttributes)(t,9),e.parseUpsampleAttributes=(t,n)=>{const i=n>=10,o=t.attributes.getString(\"mode\",\"nearest\");if(\"nearest\"!==o&&\"linear\"!==o&&(n<11||\"cubic\"!==o))throw new Error(`unrecognized mode: ${o}`);let a=[];n<9&&(a=t.attributes.getFloats(\"scales\"),(0,e.scalesValidation)(a,o,i));const s=t.attributes.getFloat(\"extrapolation_value\",0),u=n>10?t.attributes.getString(\"coordinate_transformation_mode\",\"half_pixel\"):\"asymmetric\";if(-1===[\"asymmetric\",\"pytorch_half_pixel\",\"tf_half_pixel_for_nn\",\"align_corners\",\"tf_crop_and_resize\",\"half_pixel\"].indexOf(u))throw new Error(`coordinate_transform_mode '${u}' is not supported`);const c=\"tf_crop_and_resize\"===u,l=c,p=\"nearest\"===o&&n>=11?t.attributes.getString(\"nearest_mode\",\"round_prefer_floor\"):\"\";if(-1===[\"round_prefer_floor\",\"round_prefer_ceil\",\"floor\",\"ceil\",\"\"].indexOf(p))throw new Error(`nearest_mode '${p}' is not supported`);const f=t.attributes.getFloat(\"cubic_coeff_a\",-.75),d=0!==t.attributes.getInt(\"exclude_outside\",0);if(d&&\"cubic\"!==o)throw new Error(\"exclude_outside can be set to 1 only when mode is CUBIC.\");const h=n<11||\"nearest\"===o&&\"asymmetric\"===u&&\"floor\"===p;let g=0,b=0,m=0;return n>10?t.inputs.length>2?(g=1,b=2,m=3):(b=1,m=2):9===n&&(b=1),(0,r.createAttributeWithCacheKey)({opset:n,isResize:i,mode:o,scales:a,extrapolationValue:s,coordinateTransformMode:u,useExtrapolation:l,needRoiInput:c,nearestMode:p,cubicCoefficientA:f,excludeOutside:d,useNearest2xOptimization:h,roiInputIdx:g,scalesInputIdx:b,sizesInputIdx:m})};const s=(t,e,n)=>{const r=(0,i.getGlsl)(t.session.backend.glContext.version),[s,u]=t.calculateTextureWidthAndHeight(e[0].dims,o.TextureType.unpacked),c=e[0].dims.map(((t,e)=>Math.floor(t*n.scales[e]))),[l,p]=t.calculateTextureWidthAndHeight(c,o.TextureType.unpacked),f=c.length,d=new Array(f),h=new Array(f);let g=`\\n      int output_pitches[${f}];\\n      int input_pitches[${f}];\\n      `;for(let t=f-1;t>=0;t--)d[t]=t===f-1?1:d[t+1]*c[t+1],h[t]=t===f-1?1:h[t+1]*e[0].dims[t+1],g+=`\\n        output_pitches[${t}] = ${d[t]};\\n        input_pitches[${t}] = ${h[t]};\\n        `;const b=`\\n      float getInputFloat(int index) {\\n        vec2 coords = offsetToCoords(index, ${s}, ${u});\\n        float value = getColorAsFloat(${r.texture2D}(X, coords));\\n        return value;\\n      }\\n      `,m=\"nearest\"===n.mode?`\\n    ${b}\\n    float process(int indices[${f}]) {\\n      int input_index = 0;\\n      int output_index = coordsToOffset(TexCoords, ${l}, ${p});\\n\\n      ${g}\\n\\n      int d, m;\\n      for (int dim = 0; dim < ${f}; ++dim) {\\n        d = output_index / output_pitches[dim];\\n        m = output_index - d * output_pitches[dim];\\n        output_index = m;\\n\\n        if (scales[dim] != 1 && d > 0) {\\n          int d2 = d / scales[dim];\\n          m = d - d2 * scales[dim];\\n          d = d2;\\n        }\\n        input_index += input_pitches[dim] * d;\\n      }\\n\\n      return getInputFloat(input_index);\\n    }`:4===f?`\\n    ${b}\\n    float process(int indices[4]) {\\n      int input_index = 0;\\n      int output_index = coordsToOffset(TexCoords, ${l}, ${p});\\n\\n      ${g}\\n\\n      int m;\\n      int index_of_dim0, index_of_dim1, index_of_dim2, index_of_dim3;\\n      index_of_dim0 = output_index / output_pitches[0];\\n      m = output_index - index_of_dim0 * output_pitches[0];\\n      index_of_dim1 = m / output_pitches[1];\\n      m = m - index_of_dim1 * output_pitches[1];\\n      index_of_dim2 = m / output_pitches[2];\\n      m = m - index_of_dim2 * output_pitches[2];\\n      index_of_dim3 = m;\\n\\n      int index_of_input_dim2, index_of_input_dim3, x_offset, y_offset;\\n      index_of_input_dim2 = index_of_dim2 / scales[2];\\n      y_offset = index_of_dim2 - index_of_input_dim2 * scales[2];\\n      index_of_input_dim3 = index_of_dim3 / scales[3];\\n      x_offset = index_of_dim3 - index_of_input_dim3 * scales[3];\\n\\n      input_index = index_of_dim0 * input_pitches[0] +\\n            index_of_dim1 * input_pitches[1] +\\n            index_of_input_dim2 * input_pitches[2] +\\n            index_of_input_dim3;\\n\\n      float x00 = getInputFloat(input_index);\\n      float x10, x01, x11;\\n\\n      bool end_of_dim2 = false;\\n      if (index_of_input_dim2 == (${e[0].dims[2]} - 1)) {\\n        // It's the end in dimension 2\\n        x01 = x00;\\n        end_of_dim2 = true;\\n      } else {\\n        x01 = getInputFloat(input_index + input_pitches[2]);\\n      }\\n\\n      if (index_of_input_dim3 == (input_pitches[2] - 1)) {\\n        // It's the end in dimension 3\\n        x10 = x00;\\n        x11 = x01;\\n      }\\n      else {\\n        x10 = getInputFloat(input_index + 1);\\n        x11 = end_of_dim2 ? x10 : getInputFloat(input_index + input_pitches[2] + 1);\\n      }\\n\\n      float y0 = x00 + float(y_offset) * (x01 - x00) / float(scales[2]);\\n      float y1 = x10 + float(y_offset) * (x11 - x10) / float(scales[2]);\\n      return y0 + float(x_offset) * (y1 - y0) / float(scales[3]);\\n    }`:`\\n    ${b}\\n    float process(int indices[2]) {\\n      int input_index = 0;\\n      int output_index = coordsToOffset(TexCoords, ${l}, ${p});\\n\\n      ${g}\\n\\n      int m;\\n      int index_of_dim0, index_of_dim1;\\n      index_of_dim0 = output_index / output_pitches[0];\\n      m = output_index - index_of_dim0 * output_pitches[0];\\n      index_of_dim1 = m;\\n\\n      int index_of_input_dim0, index_of_input_dim1, x_offset, y_offset;\\n      index_of_input_dim0 = index_of_dim0 / scales[0];\\n      y_offset = index_of_dim0 - index_of_input_dim0 * scales[0];\\n      index_of_input_dim1 = index_of_dim1 / scales[1];\\n      x_offset = index_of_dim1 - index_of_input_dim1 * scales[1];\\n\\n      input_index = index_of_input_dim0 * input_pitches[0] + index_of_input_dim1;\\n\\n      float x00 = getInputFloat(input_index);\\n      float x10, x01, x11;\\n\\n      bool end_of_dim0 = false;\\n      if (index_of_input_dim0 == (${e[0].dims[0]} - 1)) {\\n        // It's the end in dimension 0\\n        x01 = x00;\\n        end_of_dim0 = true;\\n      } else {\\n        x01 = getInputFloat(input_index + input_pitches[0]);\\n      }\\n\\n      if (index_of_input_dim1 == (input_pitches[0] - 1)) {\\n        // It's the end in dimension 1\\n        x10 = x00;\\n        x11 = x01;\\n      }\\n      else {\\n        x10 = getInputFloat(input_index + 1);\\n        x11 = end_of_dim0 ? x10 : getInputFloat(input_index + input_pitches[0] + 1);\\n      }\\n\\n      float y0 = x00 + float(y_offset) * (x01 - x00) / float(scales[0]);\\n      float y1 = x10 + float(y_offset) * (x11 - x10) / float(scales[0]);\\n      return y0 + float(x_offset) * (y1 - y0) / float(scales[1]);\\n    }`;return Object.assign(Object.assign({},a),{output:{dims:c,type:e[0].type,textureType:o.TextureType.unpacked},shaderSource:m,variables:[{name:\"scales\",type:\"int\",arrayLength:n.scales.length,data:n.scales.map((t=>Math.ceil(t)))}]})};e.validateInputs=(t,e)=>{if(!t||e.opset<9&&1!==t.length||e.opset>=9&&e.opset<11&&2!==t.length||e.opset>=11&&t.length<2)throw new Error(\"invalid inputs.\");if(e.scales.length>0&&t[0].dims.length!==e.scales.length)throw new Error(\"Invalid input shape.\");if(\"string\"===t[0].type)throw new Error(\"Invalid input tensor types.\")},e.scalesValidation=(t,e,n)=>{if(n){for(const e of t)if(e<=0)throw new Error(\"Scale value should be greater than 0.\")}else for(const e of t)if(e<1)throw new Error(\"Scale value should be greater than or equal to 1.\");if(!(\"linear\"!==e&&\"cubic\"!==e||2===t.length||4===t.length&&1===t[0]&&1===t[1]))throw new Error(`'Linear' mode and 'Cubic' mode only support 2-D inputs ('Bilinear', 'Bicubic')         or 4-D inputs with the corresponding outermost 2 scale values being 1         in the ${n?\"Resize\":\"Upsample\"} opeartor.`)}},1958:(t,e,n)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.ProgramManager=void 0;const r=n(1670),i=n(6231),o=n(8879),a=n(5060);e.ProgramManager=class{constructor(t,e,n){this.profiler=t,this.glContext=e,this.textureLayoutStrategy=n,this.repo=new Map,this.attributesBound=!1}getArtifact(t){return this.repo.get(t)}setArtifact(t,e){this.repo.set(t,e)}run(t,e,n){var r;this.profiler.event(\"op\",`ProgramManager.run ${null!==(r=t.programInfo.name)&&void 0!==r?r:\"unknown kernel\"}`,(()=>{var r;const o=this.glContext.gl,a=t.program;o.useProgram(a);try{this.bindOutput(n),this.attributesBound||this.bindAttributes(t.attribLocations),this.bindUniforms(t.uniformLocations,null!==(r=t.programInfo.variables)&&void 0!==r?r:[],e)}catch(e){throw i.Logger.error(\"ProgramManager\",t.programInfo.shaderSource),e}this.profiler.event(\"backend\",\"GlContext.draw()\",(()=>{this.glContext.draw()}))}),this.glContext)}dispose(){this.vertexShader&&this.glContext.deleteShader(this.vertexShader),this.repo.forEach((t=>this.glContext.deleteProgram(t.program)))}build(t,e,n){return this.profiler.event(\"backend\",\"ProgramManager.build\",(()=>{const r=new o.GlslPreprocessor(this.glContext,t,e,n),i=r.preprocess(),a=this.compile(i);return{programInfo:t,program:a,uniformLocations:this.getUniformLocations(a,r.context.programInfo.inputNames,r.context.programInfo.variables),attribLocations:this.getAttribLocations(a)}}))}compile(t){if(!this.vertexShader){i.Logger.verbose(\"ProrgramManager\",\"Compiling and caching Vertex shader for the first time\");const t=(0,a.getVertexShaderSource)(this.glContext.version);this.vertexShader=this.glContext.compileShader(t,this.glContext.gl.VERTEX_SHADER)}r.env.debug&&i.Logger.verbose(\"ProrgramManager\",`FragShader:\\n${t}\\n`);const e=this.glContext.compileShader(t,this.glContext.gl.FRAGMENT_SHADER),n=this.glContext.createProgram(this.vertexShader,e);return this.glContext.deleteShader(e),n}bindOutput(t){const e=t.width,n=t.height;i.Logger.verbose(\"ProrgramManager\",`Binding output texture to Framebuffer: w/h=${e}/${n}, shape=${t.shape}, type=${t.tensor.type}`),this.glContext.attachFramebuffer(t.texture,e,n)}bindAttributes(t){const e=t.position,n=t.textureCoord;this.glContext.setVertexAttributes(e,n),this.attributesBound=!0}bindUniforms(t,e,n){var r;const i=this.glContext.gl;let o=0;for(const{name:a,type:s,location:u,arrayLength:c}of t){const t=null===(r=e.find((t=>t.name===a)))||void 0===r?void 0:r.data;if(\"sampler2D\"!==s&&!t)throw new Error(`variable '${a}' does not have data defined in program info`);switch(s){case\"sampler2D\":this.bindTexture(n[o],u,o),o++;break;case\"float\":c?i.uniform1fv(u,t):i.uniform1f(u,t);break;case\"int\":c?i.uniform1iv(u,t):i.uniform1i(u,t);break;default:throw new Error(`Uniform not implemented: ${s}`)}}}bindTexture(t,e,n){this.glContext.bindTextureToUniform(t.texture,n,e)}getAttribLocations(t){return{position:this.getAttribLocation(t,\"position\"),textureCoord:this.getAttribLocation(t,\"textureCoord\")}}getUniformLocations(t,e,n){const r=[];if(e)for(const n of e)r.push({name:n,type:\"sampler2D\",location:this.getUniformLocation(t,n)});if(n)for(const e of n)r.push(Object.assign(Object.assign({},e),{location:this.getUniformLocation(t,e.name)}));return r}getUniformLocation(t,e){const n=this.glContext.gl.getUniformLocation(t,e);if(null===n)throw new Error(`Uniform ${e} not found.`);return n}getAttribLocation(t,e){return this.glContext.gl.getAttribLocation(t,e)}}},6416:(t,e,n)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.WebGLSessionHandler=void 0;const r=n(6231),i=n(1047),o=n(8316),a=n(1640),s=n(1958),u=n(7859),c=n(5702);e.WebGLSessionHandler=class{constructor(t,e){this.backend=t,this.context=e,this.layoutStrategy=new u.PreferLogicalStrategy(t.glContext.maxTextureSize),this.programManager=new s.ProgramManager(this.context.profiler,t.glContext,this.layoutStrategy),this.textureManager=new c.TextureManager(t.glContext,this.layoutStrategy,this.context.profiler,{reuseTextures:\"full\"===t.textureCacheMode}),this.packedTextureDataCache=new Map,this.unpackedTextureDataCache=new Map,this.pack=t.pack,this.pack2unpackMap=new Map,this.unpack2packMap=new Map}createInferenceHandler(){return new o.WebGLInferenceHandler(this)}onGraphInitialized(t){const e=t.getValues().filter((t=>-1===t.from&&t.tensor)).map((t=>t.tensor.dataId));this.initializers=new Set(e)}isInitializer(t){return!!this.initializers&&this.initializers.has(t)}addInitializer(t){this.initializers.add(t)}getTextureData(t,e){return e?this.packedTextureDataCache.get(t):this.unpackedTextureDataCache.get(t)}setTextureData(t,e,n=!1){r.Logger.verbose(\"WebGLSessionHandler\",\"Storing Texture data in cache\"),n?this.packedTextureDataCache.set(t,e):this.unpackedTextureDataCache.set(t,e)}dispose(){this.programManager.dispose(),this.textureManager.clearActiveTextures(),this.packedTextureDataCache.forEach((t=>this.textureManager.releaseTexture(t,!0))),this.packedTextureDataCache=new Map,this.unpackedTextureDataCache.forEach((t=>this.textureManager.releaseTexture(t,!0))),this.unpackedTextureDataCache=new Map}resolve(t,e,n){const r=(0,i.resolveOperator)(t,e,a.WEBGL_OP_RESOLVE_RULES);return{impl:r.opImpl,context:r.opInit?r.opInit(t,n):t}}}},7769:(t,e,n)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.Uint8DataEncoder=e.RGBAFloatDataEncoder=e.RedFloat32DataEncoder=void 0;const r=n(6231);e.RedFloat32DataEncoder=class{constructor(t,e=1){if(1===e)this.internalFormat=t.R32F,this.format=t.RED,this.textureType=t.FLOAT,this.channelSize=e;else{if(4!==e)throw new Error(`Invalid number of channels: ${e}`);this.internalFormat=t.RGBA32F,this.format=t.RGBA,this.textureType=t.FLOAT,this.channelSize=e}}encode(t,e){let n,i;return t.constructor!==Float32Array&&(r.Logger.warning(\"Encoder\",\"data was not of type Float32; creating new Float32Array\"),i=new Float32Array(t)),e*this.channelSize>t.length?(r.Logger.warning(\"Encoder\",\"Source data too small. Allocating larger array\"),i=t,n=this.allocate(e*this.channelSize),i.forEach(((t,e)=>n[e]=t))):(i=t,n=i),n}allocate(t){return new Float32Array(4*t)}decode(t,e){return 1===this.channelSize?t.filter(((t,e)=>e%4==0)).subarray(0,e):t.subarray(0,e)}},e.RGBAFloatDataEncoder=class{constructor(t,e=1,n){if(1!==e&&4!==e)throw new Error(`Invalid number of channels: ${e}`);this.internalFormat=t.RGBA,this.format=t.RGBA,this.channelSize=e,this.textureType=n||t.FLOAT}encode(t,e){let n=t;return 1===this.channelSize&&(r.Logger.verbose(\"Encoder\",\"Exploding into a larger array\"),n=this.allocate(e),t.forEach(((t,e)=>n[4*e]=t))),n}allocate(t){return new Float32Array(4*t)}decode(t,e){return 1===this.channelSize?t.filter(((t,e)=>e%4==0)).subarray(0,e):t.subarray(0,e)}},e.Uint8DataEncoder=class{constructor(t,e=1){if(this.channelSize=4,1===e)this.internalFormat=t.ALPHA,this.format=t.ALPHA,this.textureType=t.UNSIGNED_BYTE,this.channelSize=e;else{if(4!==e)throw new Error(`Invalid number of channels: ${e}`);this.internalFormat=t.RGBA,this.format=t.RGBA,this.textureType=t.UNSIGNED_BYTE,this.channelSize=e}}encode(t,e){return new Uint8Array(t.buffer,t.byteOffset,t.byteLength)}allocate(t){return new Uint8Array(t*this.channelSize)}decode(t,e){if(t instanceof Uint8Array)return t.subarray(0,e);throw new Error(`Invalid array type: ${t.constructor}`)}}},7859:(t,e,n)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.getBatchDim=e.sizeToSquarishShape=e.getRowsCols=e.sizeFromShape=e.isInt=e.parseAxisParam=e.squeezeShape=e.PreferLogicalStrategy=e.AlwaysKeepOriginalSizeStrategy=void 0;const r=n(6231),i=n(2517);function o(t,e){const n=[],r=[],i=null!=e&&Array.isArray(e)&&0===e.length,o=null==e||i?null:a(e,t).sort();let s=0;for(let e=0;e<t.length;++e){if(null!=o){if(o[s]===e&&1!==t[e])throw new Error(`Can't squeeze axis ${e} since its dim '${t[e]}' is not 1`);(null==o[s]||o[s]>e)&&1===t[e]&&(n.push(t[e]),r.push(e)),o[s]<=e&&s++}1!==t[e]&&(n.push(t[e]),r.push(e))}return{newShape:n,keptDims:r}}function a(t,e){const n=e.length;return t=null==t?e.map(((t,e)=>e)):[].concat(t),(0,i.assert)(t.every((t=>t>=-n&&t<n)),(()=>`All values in axis param must be in range [-${n}, ${n}) but got axis ${t}`)),(0,i.assert)(t.every(s),(()=>`All values in axis param must be integers but got axis ${t}`)),t.map((t=>t<0?n+t:t))}function s(t){return t%1==0}function u(t){if(0===t.length)return 1;let e=t[0];for(let n=1;n<t.length;n++)e*=t[n];return e}function c(t){const e=Math.ceil(Math.sqrt(t));return[e,Math.ceil(t/e)]}e.AlwaysKeepOriginalSizeStrategy=class{constructor(t){this.maxTextureSize=t}computeTextureWH(t,e){if(0===t.length)return[1,1];const n=this.maxTextureSize;if(e&&void 0!==e.breakAxis){const i=e.breakAxis>=t.length?1:t.slice(e.breakAxis).reduce(((t,e)=>t*e)),o=e.breakAxis<=0?1:t.slice(0,e.breakAxis).reduce(((t,e)=>t*e));if(!(i>n||o>n))return[i,o];r.Logger.verbose(\"TextureLayout\",`Given width/height preferences were unattainable: shape:${t}, breakAxis:${e.breakAxis}`)}const i=t.reduce(((t,e)=>t*e));let o=Math.floor(Math.sqrt(i));for(;o<n&&o<i&&i%o!=0;o++);if(o>=n||i%o!=0)throw new Error(`The given dimensions are outside this GPU's boundaries: ${t}`);return[o,i/o]}},e.PreferLogicalStrategy=class{constructor(t){this.maxTextureSize=t}computeTextureWH(t,e){const n=this.computeTexture(t,e);return e&&e.isPacked&&(n[0]/=2,n[1]/=2),e&&e.reverseWH?[n[1],n[0]]:n}computeTexture(t,e){const n=e&&e.isPacked;if(0===t.length)return n?[2,2]:[1,1];let i=this.maxTextureSize;if(e&&void 0!==e.breakAxis){const n=e.breakAxis>=t.length?1:t.slice(e.breakAxis).reduce(((t,e)=>t*e)),o=e.breakAxis<=0?1:t.slice(0,e.breakAxis).reduce(((t,e)=>t*e));if(!(n>i||o>i))return[n,o];r.Logger.verbose(\"TextureLayout\",`Given width/height preferences were unattainable: shape:${t}, breakAxis:${e.breakAxis}`)}let a=t.slice(0);if(n&&(i*=2,a=a.map(((t,e)=>e>=a.length-2?a[e]%2==0?a[e]:a[e]+1:a[e])),1===a.length&&(a=[2,a[0]])),2!==a.length){const t=o(a);a=t.newShape}const s=u(a);return a.length<=1&&s<=i?[1,s]:2===a.length&&a[0]<=i&&a[1]<=i?a:3===a.length&&a[0]*a[1]<=i&&a[2]<=i?[a[0]*a[1],a[2]]:3===a.length&&a[0]<=i&&a[1]*a[2]<=i?[a[0],a[1]*a[2]]:4===a.length&&a[0]*a[1]*a[2]<=i&&a[3]<=i?[a[0]*a[1]*a[2],a[3]]:4===a.length&&a[0]<=i&&a[1]*a[2]*a[3]<=i?[a[0],a[1]*a[2]*a[3]]:n?c(s/4).map((t=>2*t)):c(s)}},e.squeezeShape=o,e.parseAxisParam=a,e.isInt=s,e.sizeFromShape=u,e.getRowsCols=function(t){if(0===t.length)throw Error(\"Cannot get rows and columns of an empty shape array.\");return[t.length>1?t[t.length-2]:1,t[t.length-1]]},e.sizeToSquarishShape=c,e.getBatchDim=function(t,e=2){return u(t.slice(0,t.length-e))}},4057:(t,e,n)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.createTextureLayoutFromShape=e.calculateTextureWidthAndHeight=e.createTextureLayoutFromTextureType=void 0;const r=n(2517),i=n(2039);e.createTextureLayoutFromTextureType=(t,n,r)=>{const o=r===i.TextureType.unpacked||r===i.TextureType.unpackedReversed?1:4,a=r===i.TextureType.packed,s=r===i.TextureType.unpackedReversed||r===i.TextureType.packed,u=r===i.TextureType.packedLastDimension?n.length-1:void 0,c=r===i.TextureType.packedLastDimension?n.map(((t,e)=>e===n.length-1?4*t:t)):void 0;return(0,e.createTextureLayoutFromShape)(t,n,o,c,{isPacked:a,reverseWH:s,breakAxis:u})},e.calculateTextureWidthAndHeight=(t,n,r)=>{const i=(0,e.createTextureLayoutFromTextureType)(t,n,r);return[i.width,i.height]},e.createTextureLayoutFromShape=(t,e,n=1,i,o)=>{const a=!(!o||!o.isPacked),[s,u]=t.computeTextureWH(a&&i||e,o),c=e.length;let l=e.slice(0);if(0===c&&(l=[1]),1===n)i=e;else if(a){if(4!==n)throw new Error(\"a packed texture must be 4-channel\");i=e,c>0&&(l[c-1]=Math.ceil(l[c-1]/2)),c>1&&(l[c-2]=Math.ceil(l[c-2]/2))}else if(!i)throw new Error(\"Unpacked shape is needed when using channels > 1\");return{width:s,height:u,channels:n,isPacked:a,shape:l,strides:r.ShapeUtil.computeStrides(l),unpackedShape:i,reversedWH:o&&o.reverseWH}}},5702:(t,e,n)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.TextureManager=void 0;const r=n(6231);e.TextureManager=class{constructor(t,e,n,r){this.glContext=t,this.layoutStrategy=e,this.profiler=n,this.config=r,this.pendingRead=new Map,r.reuseTextures&&(this.inUseTextures=new Map,this.idleTextures=new Map,this.textureLookup=new Map)}createTextureFromLayout(t,e,n,i){const o=this.toEncoderType(t),a=this.glContext.getEncoder(o,e.channels||1,i);if(e.isPacked&&1===i)throw new Error(\"not implemented\");const s=e.width,u=e.height;let c,l;if(this.config.reuseTextures){c=`${s}x${u}_${a.format}_${a.internalFormat}_${a.textureType}`,l=this.inUseTextures.get(c),l||(l=[],this.inUseTextures.set(c,l));const e=this.idleTextures.get(c);if(e&&e.length>0){const r=e.pop();return l.push(r),1===i&&this.glContext.updateTexture(r,s,u,a,this.toTextureData(t,n)),r}}r.Logger.verbose(\"TextureManager\",`Creating new texture of size ${e.width}x${e.height}`);const p=this.glContext.allocateTexture(s,u,a,this.toTextureData(t,n));return this.config.reuseTextures&&(l.push(p),this.textureLookup.set(p,c)),p}readTexture(t,e,n){return n||(n=1),this.profiler.event(\"backend\",\"TextureManager.readTexture\",(()=>{const r=t.shape.reduce(((t,e)=>t*e))*n,i=this.glContext.readTexture(t.texture,t.width,t.height,r,this.toEncoderType(e),n);return this.toTensorData(e,i)}))}async readTextureAsync(t,e,n){const r=t.tensor.dataId;if(n||(n=1),this.pendingRead.has(r)){const t=this.pendingRead.get(r);return new Promise((e=>null==t?void 0:t.push(e)))}return this.profiler.event(\"backend\",\"TextureManager.readTextureAsync\",(async()=>{this.pendingRead.set(r,[]);const i=t.shape.reduce(((t,e)=>t*e))*n;await this.glContext.createAndWaitForFence();const o=this.glContext.readTexture(t.texture,t.width,t.height,i,this.toEncoderType(e),n),a=this.toTensorData(e,o),s=this.pendingRead.get(r);return this.pendingRead.delete(r),null==s||s.forEach((t=>t(a))),a}))}readUint8TextureAsFloat(t){return this.profiler.event(\"backend\",\"TextureManager.readUint8TextureAsFloat\",(()=>{const e=t.shape.reduce(((t,e)=>t*e)),n=this.glContext.readTexture(t.texture,t.width,t.height,4*e,\"byte\",4);return new Float32Array(n.buffer,n.byteOffset,e)}))}releaseTexture(t,e){let n;if(this.config.reuseTextures&&(n=this.textureLookup.get(t.texture),n)){e&&this.textureLookup.delete(n);const r=this.inUseTextures.get(n);if(r){const e=r.indexOf(t.texture);if(-1!==e){r.splice(e,1);let i=this.idleTextures.get(n);i||(i=[],this.idleTextures.set(n,i)),i.push(t.texture)}}}n&&!e||(r.Logger.verbose(\"TextureManager\",`Deleting texture of size ${t.width}x${t.height}`),this.glContext.deleteTexture(t.texture))}toTensorData(t,e){switch(t){case\"int16\":return e instanceof Int16Array?e:Int16Array.from(e);case\"int32\":return e instanceof Int32Array?e:Int32Array.from(e);case\"int8\":return e instanceof Int8Array?e:Int8Array.from(e);case\"uint16\":return e instanceof Uint16Array?e:Uint16Array.from(e);case\"uint32\":return e instanceof Uint32Array?e:Uint32Array.from(e);case\"uint8\":case\"bool\":return e instanceof Uint8Array?e:Uint8Array.from(e);case\"float32\":return e instanceof Float32Array?e:Float32Array.from(e);case\"float64\":return e instanceof Float64Array?e:Float64Array.from(e);default:throw new Error(`TensorData type ${t} is not supported`)}}toTextureData(t,e){if(e)return e instanceof Float32Array?e:new Float32Array(e)}toEncoderType(t){return\"float\"}clearActiveTextures(){this.glContext.clearActiveTextures()}}},2039:(t,e)=>{\"use strict\";var n;Object.defineProperty(e,\"__esModule\",{value:!0}),e.TextureType=void 0,(n=e.TextureType||(e.TextureType={}))[n.unpacked=0]=\"unpacked\",n[n.unpackedReversed=1]=\"unpackedReversed\",n[n.packed=2]=\"packed\",n[n.downloadUint8AsFloat=3]=\"downloadUint8AsFloat\",n[n.packedLastDimension=4]=\"packedLastDimension\"},9390:(t,e,n)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.getGlChannels=e.getCoordsDataType=e.getSqueezedParams=e.squeezeInputShape=e.generateShaderFuncNameFromInputSamplerNameAtOutCoords=e.generateShaderFuncNameFromInputSamplerName=e.repeatedTry=e.getPackedShape=void 0;const r=n(2517);e.getPackedShape=function(t){const e=t.length;return t.slice(0,e-1).concat(t[e-1]/4)},e.repeatedTry=async function(t,e=(t=>0),n){return new Promise(((r,i)=>{let o=0;const a=()=>{if(t())return void r();o++;const s=e(o);null!=n&&o>=n?i():setTimeout(a,s)};a()}))},e.generateShaderFuncNameFromInputSamplerName=function(t){return(0,r.assert)(void 0!==t&&0!==t.length,(()=>\"empty string found for sampler name\")),\"get\"+t.charAt(0).toUpperCase()+t.slice(1)},e.generateShaderFuncNameFromInputSamplerNameAtOutCoords=function(t){return(0,r.assert)(void 0!==t&&0!==t.length,(()=>\"empty string found for sampler name\")),\"get\"+t.charAt(0).toUpperCase()+t.slice(1)+\"AtOutCoords\"},e.squeezeInputShape=function(t,e){let n=JSON.parse(JSON.stringify(t));return n=e,n},e.getSqueezedParams=function(t,e){return e.map((e=>t[e])).join(\", \")},e.getCoordsDataType=function(t){if(t<=1)return\"int\";if(2===t)return\"ivec2\";if(3===t)return\"ivec3\";if(4===t)return\"ivec4\";if(5===t)return\"ivec5\";if(6===t)return\"ivec6\";throw Error(`GPU for rank ${t} is not yet supported`)},e.getGlChannels=function(t=6){return[\"x\",\"y\",\"z\",\"w\",\"u\",\"v\"].slice(0,t)}},7305:(t,e,n)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.createNewWebGLContext=e.createWebGLContext=void 0;const r=n(6231),i=n(1713),o={};function a(t){const e=function(){if(\"undefined\"==typeof document){if(\"undefined\"==typeof OffscreenCanvas)throw new TypeError(\"failed to create canvas: OffscreenCanvas is not supported\");return new OffscreenCanvas(1,1)}const t=document.createElement(\"canvas\");return t.width=1,t.height=1,t}();let n;const o={alpha:!1,depth:!1,antialias:!1,stencil:!1,preserveDrawingBuffer:!1,premultipliedAlpha:!1,failIfMajorPerformanceCaveat:!1};if((!t||\"webgl2\"===t)&&(n=e.getContext(\"webgl2\",o),n))try{return new i.WebGLContext(n,2)}catch(t){r.Logger.warning(\"GlContextFactory\",`failed to create WebGLContext using contextId 'webgl2'. Error: ${t}`)}if((!t||\"webgl\"===t)&&(n=e.getContext(\"webgl\",o)||e.getContext(\"experimental-webgl\",o),n))try{return new i.WebGLContext(n,1)}catch(t){r.Logger.warning(\"GlContextFactory\",`failed to create WebGLContext using contextId 'webgl' or 'experimental-webgl'. Error: ${t}`)}throw new Error(\"WebGL is not supported\")}e.createWebGLContext=function t(e){let n;e&&\"webgl2\"!==e||!(\"webgl2\"in o)?e&&\"webgl\"!==e||!(\"webgl\"in o)||(n=o.webgl):n=o.webgl2,n=n||a(e),e=e||1===n.version?\"webgl\":\"webgl2\";const r=n.gl;return o[e]=n,r.isContextLost()?(delete o[e],t(e)):(r.disable(r.DEPTH_TEST),r.disable(r.STENCIL_TEST),r.disable(r.BLEND),r.disable(r.DITHER),r.disable(r.POLYGON_OFFSET_FILL),r.disable(r.SAMPLE_COVERAGE),r.enable(r.SCISSOR_TEST),r.enable(r.CULL_FACE),r.cullFace(r.BACK),n)},e.createNewWebGLContext=a},1713:function(t,e,n){\"use strict\";var r=this&&this.__createBinding||(Object.create?function(t,e,n,r){void 0===r&&(r=n);var i=Object.getOwnPropertyDescriptor(e,n);i&&!(\"get\"in i?!e.__esModule:i.writable||i.configurable)||(i={enumerable:!0,get:function(){return e[n]}}),Object.defineProperty(t,r,i)}:function(t,e,n,r){void 0===r&&(r=n),t[r]=e[n]}),i=this&&this.__setModuleDefault||(Object.create?function(t,e){Object.defineProperty(t,\"default\",{enumerable:!0,value:e})}:function(t,e){t.default=e}),o=this&&this.__importStar||function(t){if(t&&t.__esModule)return t;var e={};if(null!=t)for(var n in t)\"default\"!==n&&Object.prototype.hasOwnProperty.call(t,n)&&r(e,t,n);return i(e,t),e};Object.defineProperty(e,\"__esModule\",{value:!0}),e.WebGLContext=e.linearSearchLastTrue=void 0;const a=n(1670),s=o(n(7769)),u=n(9390);function c(t){let e=0;for(;e<t.length&&t[e]();++e);return e-1}e.linearSearchLastTrue=c,e.WebGLContext=class{constructor(t,e){this.frameBufferBound=!1,this.itemsToPoll=[],this.gl=t,this.version=e,this.getExtensions(),this.vertexbuffer=this.createVertexbuffer(),this.framebuffer=this.createFramebuffer(),this.queryVitalParameters()}allocateTexture(t,e,n,r){const i=this.gl,o=i.createTexture();i.bindTexture(i.TEXTURE_2D,o),i.texParameteri(i.TEXTURE_2D,i.TEXTURE_MIN_FILTER,i.NEAREST),i.texParameteri(i.TEXTURE_2D,i.TEXTURE_MAG_FILTER,i.NEAREST),i.texParameteri(i.TEXTURE_2D,i.TEXTURE_WRAP_S,i.CLAMP_TO_EDGE),i.texParameteri(i.TEXTURE_2D,i.TEXTURE_WRAP_T,i.CLAMP_TO_EDGE);const a=r?n.encode(r,t*e):null;return i.texImage2D(i.TEXTURE_2D,0,n.internalFormat,t,e,0,n.format,n.textureType,a),this.checkError(),o}updateTexture(t,e,n,r,i){const o=this.gl;o.bindTexture(o.TEXTURE_2D,t);const a=r.encode(i,e*n);o.texSubImage2D(o.TEXTURE_2D,0,0,0,e,n,r.format,r.textureType,a),this.checkError()}attachFramebuffer(t,e,n){const r=this.gl;r.bindTexture(r.TEXTURE_2D,t),r.bindFramebuffer(r.FRAMEBUFFER,this.framebuffer),r.framebufferTexture2D(r.FRAMEBUFFER,r.COLOR_ATTACHMENT0,r.TEXTURE_2D,t,0),this.checkError(),r.viewport(0,0,e,n),r.scissor(0,0,e,n)}readTexture(t,e,n,r,i,o){const a=this.gl;o||(o=1),this.frameBufferBound||this.attachFramebuffer(t,e,n);const s=this.getEncoder(i,o),u=s.allocate(e*n);return a.bindTexture(a.TEXTURE_2D,t),a.framebufferTexture2D(a.FRAMEBUFFER,a.COLOR_ATTACHMENT0,a.TEXTURE_2D,t,0),a.readPixels(0,0,e,n,a.RGBA,s.textureType,u),this.checkError(),s.decode(u,r)}isFramebufferReady(){return!0}getActiveTexture(){const t=this.gl;return\"TEXTURE\"+(t.getParameter(this.gl.ACTIVE_TEXTURE)-t.TEXTURE0)}getTextureBinding(){return this.gl.getParameter(this.gl.TEXTURE_BINDING_2D)}getFramebufferBinding(){return this.gl.getParameter(this.gl.FRAMEBUFFER_BINDING)}setVertexAttributes(t,e){const n=this.gl;n.vertexAttribPointer(t,3,n.FLOAT,!1,20,0),n.enableVertexAttribArray(t),-1!==e&&(n.vertexAttribPointer(e,2,n.FLOAT,!1,20,12),n.enableVertexAttribArray(e)),this.checkError()}createProgram(t,e){const n=this.gl,r=n.createProgram();return n.attachShader(r,t),n.attachShader(r,e),n.linkProgram(r),r}compileShader(t,e){const n=this.gl,r=n.createShader(e);if(!r)throw new Error(`createShader() returned null with type ${e}`);if(n.shaderSource(r,t),n.compileShader(r),!1===n.getShaderParameter(r,n.COMPILE_STATUS))throw new Error(`Failed to compile shader: ${n.getShaderInfoLog(r)}\\nShader source:\\n${t}`);return r}deleteShader(t){this.gl.deleteShader(t)}bindTextureToUniform(t,e,n){const r=this.gl;r.activeTexture(r.TEXTURE0+e),this.checkError(),r.bindTexture(r.TEXTURE_2D,t),this.checkError(),r.uniform1i(n,e),this.checkError()}draw(){this.gl.drawArrays(this.gl.TRIANGLE_STRIP,0,4),this.checkError()}checkError(){if(a.env.debug){const t=this.gl,e=t.getError();let n=\"\";switch(e){case t.NO_ERROR:return;case t.INVALID_ENUM:n=\"INVALID_ENUM\";break;case t.INVALID_VALUE:n=\"INVALID_VALUE\";break;case t.INVALID_OPERATION:n=\"INVALID_OPERATION\";break;case t.INVALID_FRAMEBUFFER_OPERATION:n=\"INVALID_FRAMEBUFFER_OPERATION\";break;case t.OUT_OF_MEMORY:n=\"OUT_OF_MEMORY\";break;case t.CONTEXT_LOST_WEBGL:n=\"CONTEXT_LOST_WEBGL\";break;default:n=`Unknown WebGL Error: ${e.toString(16)}`}throw new Error(n)}}deleteTexture(t){this.gl.deleteTexture(t)}deleteProgram(t){this.gl.deleteProgram(t)}getEncoder(t,e,n=0){if(2===this.version)return new s.RedFloat32DataEncoder(this.gl,e);switch(t){case\"float\":return 1===n||this.isRenderFloat32Supported?new s.RGBAFloatDataEncoder(this.gl,e):new s.RGBAFloatDataEncoder(this.gl,e,this.textureHalfFloatExtension.HALF_FLOAT_OES);case\"int\":throw new Error(\"not implemented\");case\"byte\":return new s.Uint8DataEncoder(this.gl,e);default:throw new Error(`Invalid dataType: ${t}`)}}clearActiveTextures(){const t=this.gl;for(let e=0;e<this.maxTextureImageUnits;++e)t.activeTexture(t.TEXTURE0+e),t.bindTexture(t.TEXTURE_2D,null)}dispose(){if(this.disposed)return;const t=this.gl;t.bindFramebuffer(t.FRAMEBUFFER,null),t.deleteFramebuffer(this.framebuffer),t.bindBuffer(t.ARRAY_BUFFER,null),t.deleteBuffer(this.vertexbuffer),t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,null),t.finish(),this.disposed=!0}createDefaultGeometry(){return new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0])}createVertexbuffer(){const t=this.gl,e=t.createBuffer();if(!e)throw new Error(\"createBuffer() returned null\");const n=this.createDefaultGeometry();return t.bindBuffer(t.ARRAY_BUFFER,e),t.bufferData(t.ARRAY_BUFFER,n,t.STATIC_DRAW),this.checkError(),e}createFramebuffer(){const t=this.gl.createFramebuffer();if(!t)throw new Error(\"createFramebuffer returned null\");return t}queryVitalParameters(){const t=this.gl;if(this.isFloatTextureAttachableToFrameBuffer=this.checkFloatTextureAttachableToFrameBuffer(),this.isRenderFloat32Supported=this.checkRenderFloat32(),this.isFloat32DownloadSupported=this.checkFloat32Download(),1===this.version&&!this.textureHalfFloatExtension&&!this.isRenderFloat32Supported)throw new Error(\"both float32 and float16 TextureType are not supported\");this.isBlendSupported=!this.isRenderFloat32Supported||this.checkFloat32Blend(),this.maxTextureSize=t.getParameter(t.MAX_TEXTURE_SIZE),this.maxTextureImageUnits=t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS),this.version}getExtensions(){2===this.version?(this.colorBufferFloatExtension=this.gl.getExtension(\"EXT_color_buffer_float\"),this.disjointTimerQueryWebgl2Extension=this.gl.getExtension(\"EXT_disjoint_timer_query_webgl2\")):(this.textureFloatExtension=this.gl.getExtension(\"OES_texture_float\"),this.textureHalfFloatExtension=this.gl.getExtension(\"OES_texture_half_float\"))}checkFloatTextureAttachableToFrameBuffer(){const t=this.gl,e=t.createTexture();t.bindTexture(t.TEXTURE_2D,e);const n=2===this.version?t.RGBA32F:t.RGBA;t.texImage2D(t.TEXTURE_2D,0,n,1,1,0,t.RGBA,t.FLOAT,null);const r=t.createFramebuffer();t.bindFramebuffer(t.FRAMEBUFFER,r),t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,e,0);const i=t.checkFramebufferStatus(t.FRAMEBUFFER)===t.FRAMEBUFFER_COMPLETE;return t.bindTexture(t.TEXTURE_2D,null),t.bindFramebuffer(t.FRAMEBUFFER,null),t.deleteTexture(e),t.deleteFramebuffer(r),i}checkRenderFloat32(){if(2===this.version){if(!this.colorBufferFloatExtension)return!1}else if(!this.textureFloatExtension)return!1;return this.isFloatTextureAttachableToFrameBuffer}checkFloat32Download(){if(2===this.version){if(!this.colorBufferFloatExtension)return!1}else{if(!this.textureFloatExtension)return!1;if(!this.gl.getExtension(\"WEBGL_color_buffer_float\"))return!1}return this.isFloatTextureAttachableToFrameBuffer}checkFloat32Blend(){const t=this.gl;let e,n,r,i,o;try{e=t.createTexture(),n=t.createFramebuffer(),t.bindTexture(t.TEXTURE_2D,e);const a=2===this.version?t.RGBA32F:t.RGBA;return t.texImage2D(t.TEXTURE_2D,0,a,1,1,0,t.RGBA,t.FLOAT,null),t.bindFramebuffer(t.FRAMEBUFFER,n),t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,e,0),t.enable(t.BLEND),r=t.createShader(t.VERTEX_SHADER),!!r&&(t.shaderSource(r,\"void main(){}\"),t.compileShader(r),i=t.createShader(t.FRAGMENT_SHADER),!!i&&(t.shaderSource(i,\"precision highp float;void main(){gl_FragColor=vec4(0.5);}\"),t.compileShader(i),o=t.createProgram(),!!o&&(t.attachShader(o,r),t.attachShader(o,i),t.linkProgram(o),t.useProgram(o),t.drawArrays(t.POINTS,0,1),t.getError()===t.NO_ERROR)))}finally{t.disable(t.BLEND),o&&t.deleteProgram(o),r&&t.deleteShader(r),i&&t.deleteShader(i),n&&(t.bindFramebuffer(t.FRAMEBUFFER,null),t.deleteFramebuffer(n)),e&&(t.bindTexture(t.TEXTURE_2D,null),t.deleteTexture(e))}}beginTimer(){if(2===this.version&&this.disjointTimerQueryWebgl2Extension){const t=this.gl,e=this.disjointTimerQueryWebgl2Extension,n=t.createQuery();return t.beginQuery(e.TIME_ELAPSED_EXT,n),n}throw new Error(\"WebGL1 profiling currently not supported.\")}endTimer(){if(2!==this.version||!this.disjointTimerQueryWebgl2Extension)throw new Error(\"WebGL1 profiling currently not supported\");{const t=this.gl,e=this.disjointTimerQueryWebgl2Extension;t.endQuery(e.TIME_ELAPSED_EXT)}}isTimerResultAvailable(t){let e=!1,n=!1;if(2!==this.version||!this.disjointTimerQueryWebgl2Extension)throw new Error(\"WebGL1 profiling currently not supported\");{const r=this.gl,i=this.disjointTimerQueryWebgl2Extension;e=r.getQueryParameter(t,r.QUERY_RESULT_AVAILABLE),n=r.getParameter(i.GPU_DISJOINT_EXT)}return e&&!n}getTimerResult(t){let e=0;if(2!==this.version)throw new Error(\"WebGL1 profiling currently not supported\");{const n=this.gl;e=n.getQueryParameter(t,n.QUERY_RESULT),n.deleteQuery(t)}return e/1e6}async waitForQueryAndGetTime(t){return await(0,u.repeatedTry)((()=>this.isTimerResultAvailable(t))),this.getTimerResult(t)}async createAndWaitForFence(){const t=this.createFence(this.gl);return this.pollFence(t)}createFence(t){let e;const n=t,r=n.fenceSync(n.SYNC_GPU_COMMANDS_COMPLETE,0);return t.flush(),e=null===r?()=>!0:()=>{const t=n.clientWaitSync(r,0,0);return t===n.ALREADY_SIGNALED||t===n.CONDITION_SATISFIED},{query:r,isFencePassed:e}}async pollFence(t){return new Promise((e=>{this.addItemToPoll((()=>t.isFencePassed()),(()=>e()))}))}pollItems(){const t=c(this.itemsToPoll.map((t=>t.isDoneFn)));for(let e=0;e<=t;++e){const{resolveFn:t}=this.itemsToPoll[e];t()}this.itemsToPoll=this.itemsToPoll.slice(t+1)}async addItemToPoll(t,e){this.itemsToPoll.push({isDoneFn:t,resolveFn:e}),this.itemsToPoll.length>1||await(0,u.repeatedTry)((()=>(this.pollItems(),0===this.itemsToPoll.length)))}}},1036:(t,e,n)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.ExecutionPlan=void 0;const r=n(6231);class i{constructor(t,e){this.op=t,this.node=e}}e.ExecutionPlan=class{constructor(t,e,n){this.graph=t,this.profiler=n,this.initialize(e)}initialize(t){this.profiler.event(\"session\",\"ExecutionPlan.initialize\",(()=>{const e=this.graph.getNodes();if(e.length!==t.length)throw new Error(\"The size of nodes and OPs do not match.\");this._ops=t.map(((t,n)=>new i(t,e[n]))),this.reset(),this._starter=[],this._ops.forEach(((t,e)=>{let n=!0;for(const e of t.node.inputs)if(!this._values[e]&&-1===this.graph.getInputIndices().indexOf(e)){n=!1;break}n&&this._starter.push(e)}))}))}reset(){this._values=this.graph.getValues().map((t=>t.tensor))}async execute(t,e){return this.profiler.event(\"session\",\"ExecutionPlan.execute\",(async()=>{this.reset();const n=t.createInferenceHandler(),i=this.graph.getInputIndices();if(e.length!==i.length)throw new Error(`number of input tensors don't match the number of inputs to the model: actual: ${e.length} expected: ${i.length}`);e.forEach(((t,e)=>{const n=i[e];this._values[n]=t}));const o=this._starter.slice(0),a=this.graph.getValues(),s=this.graph.getNodes();let u=0;for(;u<o.length;){const t=o[u++],e=this._ops[t],i=e.node.inputs.map((t=>this._values[t]));if(-1!==i.indexOf(void 0))throw new Error(`unresolved input detected: op: ${e.node}`);const c=i;r.Logger.verbose(\"ExecPlan\",`Runing op:${e.node.name} (${c.map(((t,n)=>`'${e.node.inputs[n]}': ${t.type}[${t.dims.join(\",\")}]`)).join(\", \")})`);const l=await this.profiler.event(\"node\",e.node.name,(async()=>e.op.impl(n,c,e.op.context)));if(l.length!==e.node.outputs.length)throw new Error(\"the size of output does not match model definition.\");l.forEach(((t,n)=>{const r=e.node.outputs[n];if(this._values[r])throw new Error(`output [${r}] already has value: op:${e.node.name}`);this._values[r]=t}));const p=new Set;l.forEach(((t,n)=>{const r=e.node.outputs[n];for(const t of a[r].to){const e=s[t];let n=!0;for(const t of e.inputs)if(!this._values[t]){n=!1;break}n&&p.add(t)}})),o.push(...p)}const c=[];for(let t=0;t<this.graph.getOutputIndices().length;t++){const e=this.graph.getOutputIndices()[t],n=this._values[e];if(void 0===n)throw new Error(`required output [${e}] does not have value`);0===e?await n.getData():n.data,c.push(n)}return r.Logger.verbose(\"ExecPlan\",\"disposing of inferenceHandler\"),n.dispose(),c}))}}},7070:(t,e,n)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.Graph=void 0;const r=n(1446),i=n(7778),o=n(9395),a=n(9162),s=n(2517);var u=o.onnxruntime.experimental.fbs;e.Graph={from:(t,e)=>new p(t,e)};class c{constructor(t){this._from=void 0,this._to=[],this.tensor=void 0,this.type=void 0,t&&(this.type=s.ProtoUtil.tensorValueTypeFromProto(t.type.tensorType))}get from(){return this._from}get to(){return this._to}}class l{constructor(t,e){t instanceof r.onnx.NodeProto?(this.name=t.name,this.opType=t.opType,this.attributes=new i.Attribute(t.attribute)):t instanceof u.Node&&(this.name=null!=e?e:t.name(),this.opType=t.opType(),this.attributes=new i.Attribute(s.ProtoUtil.tensorAttributesFromORTFormat(t))),this.inputs=[],this.outputs=[],this.executeNode=!0}}class p{constructor(t,e){if(!t)throw new TypeError(\"graph is empty\");this.buildGraph(t),this.transformGraph(e),this.checkIsAcyclic()}getInputIndices(){return this._allInputIndices}getInputNames(){return this._allInputNames}getOutputIndices(){return this._allOutputIndices}getOutputNames(){return this._allOutputNames}getValues(){return this._allData}getNodes(){return this._nodes}buildGraph(t){if(t instanceof r.onnx.GraphProto)this.buildGraphFromOnnxFormat(t);else{if(!(t instanceof u.Graph))throw new TypeError(\"Graph type is not supported.\");this.buildGraphFromOrtFormat(t)}}buildGraphFromOnnxFormat(t){const e=new Map;this._allData=[],this._allInputIndices=[],this._allInputNames=[],this._allOutputIndices=[],this._allOutputNames=[],this._nodes=[];const n=new Map;if(!t.input)throw new Error(\"missing information in graph: input\");const r=[];for(const n of t.input){if(e.has(n.name))throw new Error(`duplicated input name: ${n.name}`);const t=this._allData.push(new c(n))-1;e.set(n.name,t),r.push(n.name)}if(!t.initializer)throw new Error(\"missing information in graph: initializer\");for(const n of t.initializer){let t=e.get(n.name);if(void 0===t){const r=new c;r.type={shape:{dims:s.ProtoUtil.tensorDimsFromProto(n.dims)},tensorType:s.ProtoUtil.tensorDataTypeFromProto(n.dataType)},t=this._allData.push(r)-1,e.set(n.name,t)}this._allData[t]._from=-1,this._allData[t].tensor=a.Tensor.fromProto(n)}for(let t=0;t<this._allData.length;t++)this._allData[t].tensor||(this._allInputIndices.push(t),this._allInputNames.push(r[t]));if(!t.output)throw new Error(\"missing information in graph: output\");for(const n of t.output){if(e.has(n.name))throw new Error(`duplicated output name: ${n.name}`);const t=this._allData.push(new c(n))-1;e.set(n.name,t),this._allOutputIndices.push(t),this._allOutputNames.push(n.name)}if(!t.node)throw new Error(\"missing information in graph: node\");for(const e of t.node){if(!e.name)for(let t=0;;t++){const r=`unnamed_${e.opType}_${t}`;if(!n.has(r)){e.name=r;break}}if(n.has(e.name))throw new Error(`duplicated node name: ${e.name}`);const t=this._nodes.push(new l(e))-1;n.set(e.name,t)}for(let n=0;n<this._nodes.length;n++){const r=this._nodes[n],i=t.node[n];if(!i.output)throw new Error(`missing output for node: ${i.name}`);for(const t of i.output){let o=e.get(t);if(void 0===o&&(o=this._allData.push(new c)-1,e.set(t,o)),r.outputs.push(o),void 0!==this._allData[o]._from)throw new Error(`multiple nodes output to one data value: ${o}`);if(this._allData[o]._from=n,\"Constant\"===i.opType){if(!i.attribute||1!==i.attribute.length||!i.attribute[0].t)throw new Error(\"missing attributes or missing tensor value in attributes for this Constant operator\");if(!i.output||1!==i.output.length)throw new Error(\"missing output or incorrect number of outputs for this Constant operator\");r.outputs.pop(),r.executeNode=!1,this._allData[o]._from=-1,this._allData[o].tensor=a.Tensor.fromProto(i.attribute[0].t)}}}for(let n=0;n<this._nodes.length;n++){const r=this._nodes[n],i=t.node[n];if(!i.input)throw new Error(`missing input for node: ${i.name}`);for(const t of i.input){const o=e.get(t);if(void 0===o){if(\"\"===t&&3===i.input.length&&\"Resize\"===i.opType)continue;throw new Error(`unrecognized input '${t}' for node: ${i.name}`)}r.inputs.push(o),this._allData[o]._to.push(n)}}return!0}buildGraphFromOrtFormat(t){var e,n,r;const i=new Map;this._allData=[],this._allInputIndices=[],this._allInputNames=[],this._allOutputIndices=[],this._allOutputNames=[],this._nodes=[];const o=new Map,p=[];for(let o=0;o<t.inputsLength();o++){const a=t.inputs(o);if(i.has(a))throw new Error(`duplicated input name: ${a}`);for(let o=0;o<t.nodeArgsLength();o++)if((null===(e=t.nodeArgs(o))||void 0===e?void 0:e.name())===a){const e=new c;if((null===(r=null===(n=t.nodeArgs(o))||void 0===n?void 0:n.type())||void 0===r?void 0:r.valueType())!==u.TypeInfoValue.tensor_type)throw new Error(\"Unexpected value type for the nodeArg.\");const l=t.nodeArgs(o).type().value(new u.TensorTypeAndShape),f=s.ProtoUtil.tensorDataTypeFromProto(l.elemType()),d=l.shape(),h=[];for(let t=0;t<d.dimLength();t++)h.push(s.LongUtil.longToNumber(d.dim(t).value().dimValue()));e.type={shape:{dims:h},tensorType:f};const g=this._allData.push(e)-1;i.set(a,g),p.push(a)}}for(let e=0;e<t.initializersLength();e++){const n=t.initializers(e);let r=i.get(n.name());if(void 0===r){const t=new c,e=s.ProtoUtil.tensorDimsFromORTFormat(n),o=s.ProtoUtil.tensorDataTypeFromProto(n.dataType());t.type={shape:{dims:e},tensorType:o},r=this._allData.push(t)-1,i.set(n.name(),r)}this._allData[r]._from=-1,this._allData[r].tensor=a.Tensor.fromOrtTensor(n)}for(let t=0;t<this._allData.length;t++)this._allData[t].tensor||(this._allInputIndices.push(t),this._allInputNames.push(p[t]));for(let e=0;e<t.outputsLength();e++){const n=t.outputs(e);if(i.has(n))throw new Error(`duplicated output name: ${n}`);const r=this._allData.push(new c)-1;i.set(n,r),this._allOutputIndices.push(r),this._allOutputNames.push(n)}if(!t.nodes)throw new Error(\"missing information in graph: node\");for(let e=0;e<t.nodesLength();e++){const n=t.nodes(e);let r=n.name();if(!r)for(let t=0;r=`unnamed_${n.opType()}_${t}`,o.has(r);t++);if(o.has(r))throw new Error(`duplicated node name: ${r}`);const i=this._nodes.push(new l(n,r))-1;o.set(r,i)}for(let e=0;e<this._nodes.length;e++){const n=this._nodes[e],r=t.nodes(e);if(null==r)throw new Error(`No node exists at index ${e}`);if(0===(null==r?void 0:r.outputsLength()))throw new Error(`missing output for node: ${r.name}`);for(let t=0;t<(null==r?void 0:r.outputsLength());t++){const o=null==r?void 0:r.outputs(t);let s=i.get(o);if(void 0===s&&(s=this._allData.push(new c)-1,i.set(o,s)),n.outputs.push(s),void 0!==this._allData[s]._from)throw new Error(`multiple nodes output to one data value: ${s}`);if(this._allData[s]._from=e,\"Constant\"===r.opType()){if(1!==r.attributesLength()||!r.attributes(0).t())throw new Error(\"missing attributes or missing tensor value in attributes for this Constant operator\");if(1!==r.outputsLength())throw new Error(\"missing output or incorrect number of outputs for this Constant operator\");n.outputs.pop(),n.executeNode=!1,this._allData[s]._from=-1,this._allData[s].tensor=a.Tensor.fromOrtTensor(r.attributes(0).t())}}}for(let e=0;e<this._nodes.length;e++){const n=this._nodes[e],r=t.nodes(e);if(0===r.inputsLength())throw new Error(`missing input for node: ${r.name}`);for(let t=0;t<r.inputsLength();t++){const o=r.inputs(t),a=i.get(o);if(void 0===a)throw new Error(`unrecognized input '${o}' for node: ${r.name()}`);n.inputs.push(a),this._allData[a]._to.push(e)}}}checkIsAcyclic(){const t=new Set;this._allInputIndices.forEach((e=>{this._allData[e]._to.forEach((e=>{t.add(e)}))}));const e=Array.from(t),n=new Array(this._nodes.length).fill(\"white\");for(;e.length>0;){const t=e.pop();\"gray\"===n[t]?n[t]=\"black\":(e.push(t),n[t]=\"gray\",this._nodes[t].outputs.forEach((r=>{const i=this._allData[r];if(void 0!==i.tensor)throw new Error(\"node outputs should not be initialized\");if(i._from!==t)throw new Error(\"from property of the Value object doesn't match index of Node being processed\");i._to.forEach((t=>{if(\"gray\"===n[t])throw new Error(\"model graph is cyclic\");\"white\"===n[t]&&e.push(t)}))})))}}transformGraph(t){this.removeAllIdentityNodes(),this.removeAllDropoutNodes(),this.fuseConvActivationNodes(),t&&t.transformGraph(this),this.finalizeGraph()}finalizeGraph(){let t=0;for(let e=0;e<this._nodes.length;e++)this._nodes[e].executeNode?t>0&&(this._nodes[e].inputs.forEach((n=>{const r=this._allData[n]._to.indexOf(e+t);-1!==r&&(this._allData[n]._to[r]=e)})),this._nodes[e].outputs.forEach((n=>{this._allData[n]._from&&this._allData[n]._from===e+t&&(this._allData[n]._from=e)}))):(t++,this._nodes[e].outputs.forEach((t=>{this._allData[t]._from=-2})),this._nodes.splice(e,1),e--);t=0;for(let e=0;e<this._allData.length;e++)if(-2!==this._allData[e].from||-1!==this._allOutputIndices.indexOf(e+t)){if(t>0){let n=-1;void 0!==this._allData[e].from&&-1!==this._allData[e].from?(n=this._nodes[this._allData[e].from].outputs.indexOf(e+t),-1!==n&&(this._nodes[this._allData[e].from].outputs[n]=e)):(n=this._allInputIndices.indexOf(e+t),-1!==n&&(this._allInputIndices[n]=e)),this._allData[e].to.forEach((r=>{n=this._nodes[r].inputs.indexOf(e+t),-1!==n&&(this._nodes[r].inputs[n]=e)})),0===this._allData[e].to.length&&(n=this._allOutputIndices.indexOf(e+t),-1!==n&&(this._allOutputIndices[n]=e))}}else t++,this._allData.splice(e,1),e--}deleteNode(t){const e=this._nodes[t];if(e.outputs.length>1)for(let t=1;t<e.outputs.length;t++)if(this._allData[e.outputs[t]].to.length>0)throw new Error(\"Node deletion with more than one output connected to other nodes is not supported. \");e.executeNode=!1;const n=e.inputs[0],r=e.outputs[0],i=this._allData[r].to,o=this._allData[n].to.indexOf(t);if(-1===o)throw new Error(\"The Value object doesn't have the current Node in it's 'to' property \");this._allData[n].to.splice(o,1),this._allData[r]._to=[];const a=this._allOutputIndices.indexOf(r);if(-1!==a&&(this._allOutputIndices[a]=n),i&&i.length>0)for(const t of i){const e=this._nodes[t].inputs.indexOf(r);if(-1===e)throw new Error(\"The Node object doesn't have the output Value in it's 'inputs' property \");this._nodes[t].inputs[e]=n,this._allData[n].to.push(t)}}removeAllDropoutNodes(){let t=0;for(const e of this._nodes){if(\"Dropout\"===e.opType){if(1!==e.inputs.length)throw new Error(\"Dropout nodes should only contain one input. \");if(1!==e.outputs.length&&2!==e.outputs.length)throw new Error(\"Dropout nodes should contain either 1 or 2 output(s)\");if(2===e.outputs.length&&0!==this._allData[e.outputs[1]]._to.length)throw new Error(\"Dropout nodes's second output should not be referenced by other nodes\");this.deleteNode(t)}t++}}removeAllIdentityNodes(){let t=0;for(const e of this._nodes)\"Identity\"===e.opType&&this.deleteNode(t),t++}isActivation(t){switch(t.opType){case\"Relu\":case\"Sigmoid\":case\"Clip\":return!0;default:return!1}}fuseConvActivationNodes(){for(const t of this._nodes)if(\"Conv\"===t.opType){const e=this._allData[t.outputs[0]]._to;if(1===e.length&&this.isActivation(this._nodes[e[0]])){const n=this._nodes[e[0]];if(\"Clip\"===n.opType)if(1===n.inputs.length)try{t.attributes.set(\"activation_params\",\"floats\",[n.attributes.getFloat(\"min\"),n.attributes.getFloat(\"max\")])}catch(e){t.attributes.set(\"activation_params\",\"floats\",[s.MIN_CLIP,s.MAX_CLIP])}else{if(!(n.inputs.length>=3&&void 0!==this._allData[n.inputs[1]].tensor&&void 0!==this._allData[n.inputs[2]].tensor))continue;t.attributes.set(\"activation_params\",\"floats\",[this._allData[n.inputs[1]].tensor.floatData[0],this._allData[n.inputs[2]].tensor.floatData[0]])}t.attributes.set(\"activation\",\"string\",n.opType),this.deleteNode(e[0])}}}}},6231:(t,e)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.now=e.Profiler=e.Logger=void 0;const n={verbose:1e3,info:2e3,warning:4e3,error:5e3,fatal:6e3},r={none:new class{log(t,e,n){}},console:new class{log(t,e,n){console.log(`${this.color(t)} ${n?\"\u001b[35m\"+n+\"\u001b[0m \":\"\"}${e}`)}color(t){switch(t){case\"verbose\":return\"\u001b[34;40mv\u001b[0m\";case\"info\":return\"\u001b[32mi\u001b[0m\";case\"warning\":return\"\u001b[30;43mw\u001b[0m\";case\"error\":return\"\u001b[31;40me\u001b[0m\";case\"fatal\":return\"\u001b[101mf\u001b[0m\";default:throw new Error(`unsupported severity: ${t}`)}}}},i={provider:\"console\",minimalSeverity:\"warning\",logDateTime:!0,logSourceLocation:!1};let o={\"\":i};function a(t,e,n,r){if(void 0===e)return i=t,{verbose:a.verbose.bind(null,i),info:a.info.bind(null,i),warning:a.warning.bind(null,i),error:a.error.bind(null,i),fatal:a.fatal.bind(null,i)};if(void 0===n)s(t,e);else if(\"number\"==typeof n&&void 0===r)s(t,e);else if(\"string\"==typeof n&&void 0===r)s(t,n,0,e);else{if(\"string\"!=typeof n||\"number\"!=typeof r)throw new TypeError(\"input is valid\");s(t,n,0,e)}var i}function s(t,e,i,a){const s=o[a||\"\"]||o[\"\"];n[t]<n[s.minimalSeverity]||(s.logDateTime&&(e=`${(new Date).toISOString()}|${e}`),s.logSourceLocation,r[s.provider].log(t,e,a))}!function(t){function e(t){o={},n(\"\",t||{})}function n(t,n){if(\"*\"===t)e(n);else{const e=o[t]||i;o[t]={provider:n.provider||e.provider,minimalSeverity:n.minimalSeverity||e.minimalSeverity,logDateTime:void 0===n.logDateTime?e.logDateTime:n.logDateTime,logSourceLocation:void 0===n.logSourceLocation?e.logSourceLocation:n.logSourceLocation}}}t.verbose=function(e,n){t(\"verbose\",e,n)},t.info=function(e,n){t(\"info\",e,n)},t.warning=function(e,n){t(\"warning\",e,n)},t.error=function(e,n){t(\"error\",e,n)},t.fatal=function(e,n){t(\"fatal\",e,n)},t.reset=e,t.set=n,t.setWithEnv=function(t){const e={};t.logLevel&&(e.minimalSeverity=t.logLevel),n(\"\",e)}}(a||(a={})),e.Logger=a;class u{constructor(t,e,n,r,i,o){this.category=t,this.name=e,this.startTime=n,this.endCallback=r,this.timer=i,this.ctx=o}end(){return this.endCallback(this)}async checkTimer(){if(void 0===this.ctx||void 0===this.timer)throw new Error(\"No webgl timer found\");return this.ctx.endTimer(),this.ctx.waitForQueryAndGetTime(this.timer)}}class c{constructor(t,e,n,r){this.category=t,this.name=e,this.startTime=n,this.endTime=r}}e.Profiler=class{static create(t){return void 0===t?new this:new this(t.maxNumberEvents,t.flushBatchSize,t.flushIntervalInMilliseconds)}constructor(t,e,n){this._started=!1,this._flushPointer=0,this._started=!1,this._maxNumberEvents=void 0===t?1e4:t,this._flushBatchSize=void 0===e?10:e,this._flushIntervalInMilliseconds=void 0===n?5e3:n}start(){this._started=!0,this._timingEvents=[],this._flushTime=(0,e.now)(),this._flushPointer=0}stop(){for(this._started=!1;this._flushPointer<this._timingEvents.length;this._flushPointer++)this.logOneEvent(this._timingEvents[this._flushPointer])}event(t,e,n,r){const i=this._started?this.begin(t,e,r):void 0;let o=!1;const a=n();if(a&&\"function\"==typeof a.then)return o=!0,new Promise(((t,e)=>{a.then((async e=>{i&&await i.end(),t(e)}),(async t=>{i&&await i.end(),e(t)}))}));if(!o&&i){const t=i.end();if(t&&\"function\"==typeof t.then)return new Promise(((e,n)=>{t.then((()=>{e(a)}),(t=>{n(t)}))}))}return a}begin(t,n,r){if(!this._started)throw new Error(\"profiler is not started yet\");if(void 0===r){const r=(0,e.now)();return this.flush(r),new u(t,n,r,(t=>this.endSync(t)))}{const e=r.beginTimer();return new u(t,n,0,(async t=>this.end(t)),e,r)}}async end(t){const e=await t.checkTimer();this._timingEvents.length<this._maxNumberEvents&&(this._timingEvents.push(new c(t.category,t.name,t.startTime,e)),this.flush(e))}endSync(t){const n=(0,e.now)();this._timingEvents.length<this._maxNumberEvents&&(this._timingEvents.push(new c(t.category,t.name,t.startTime,n)),this.flush(n))}logOneEvent(t){e.Logger.verbose(`Profiler.${t.category}`,`${(t.endTime-t.startTime).toFixed(2)}ms on event '${t.name}' at ${t.endTime.toFixed(2)}`)}flush(t){if(this._timingEvents.length-this._flushPointer>=this._flushBatchSize||t-this._flushTime>=this._flushIntervalInMilliseconds){for(const t=this._flushPointer;this._flushPointer<t+this._flushBatchSize&&this._flushPointer<this._timingEvents.length;this._flushPointer++)this.logOneEvent(this._timingEvents[this._flushPointer]);this._flushTime=(0,e.now)()}}get started(){return this._started}},e.now=\"undefined\"!=typeof performance&&performance.now?()=>performance.now():Date.now},2644:(t,e,n)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.Model=void 0;const r=n(5686),i=n(1446),o=n(7070),a=n(9395),s=n(2517);var u=a.onnxruntime.experimental.fbs;e.Model=class{constructor(){}load(t,e,n){if(!n)try{return void this.loadFromOnnxFormat(t,e)}catch(t){if(void 0!==n)throw t}this.loadFromOrtFormat(t,e)}loadFromOnnxFormat(t,e){const n=i.onnx.ModelProto.decode(t);if(s.LongUtil.longToNumber(n.irVersion)<3)throw new Error(\"only support ONNX model with IR_VERSION>=3\");this._opsets=n.opsetImport.map((t=>({domain:t.domain,version:s.LongUtil.longToNumber(t.version)}))),this._graph=o.Graph.from(n.graph,e)}loadFromOrtFormat(t,e){const n=new r.flatbuffers.ByteBuffer(t),i=u.InferenceSession.getRootAsInferenceSession(n).model();if(s.LongUtil.longToNumber(i.irVersion())<3)throw new Error(\"only support ONNX model with IR_VERSION>=3\");this._opsets=[];for(let t=0;t<i.opsetImportLength();t++){const e=i.opsetImport(t);this._opsets.push({domain:null==e?void 0:e.domain(),version:s.LongUtil.longToNumber(e.version())})}this._graph=o.Graph.from(i.graph(),e)}get graph(){return this._graph}get opsets(){return this._opsets}}},782:(t,e)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.FLOAT_TYPES=e.INT_TYPES=e.NUMBER_TYPES=void 0,e.NUMBER_TYPES=[\"float32\",\"float64\",\"int32\",\"int16\",\"int8\",\"uint16\",\"uint32\",\"uint8\"],e.INT_TYPES=[\"int32\",\"int16\",\"int8\",\"uint16\",\"uint32\",\"uint8\"],e.FLOAT_TYPES=[\"float32\",\"float64\"]},1047:(t,e)=>{\"use strict\";function n(t,e){if(e.endsWith(\"+\")){const n=Number.parseInt(e.substring(0,e.length-1),10);return!isNaN(n)&&n<=t}if(2===e.split(\"-\").length){const n=e.split(\"-\"),r=Number.parseInt(n[0],10),i=Number.parseInt(n[1],10);return!isNaN(r)&&!isNaN(i)&&r<=t&&t<=i}return Number.parseInt(e,10)===t}Object.defineProperty(e,\"__esModule\",{value:!0}),e.resolveOperator=void 0,e.resolveOperator=function(t,e,r){for(const i of r){const r=i[0],o=i[1],a=i[2],s=i[3],u=i[4];if(t.opType===r)for(const t of e)if((t.domain===o||\"ai.onnx\"===t.domain&&\"\"===o)&&n(t.version,a))return{opImpl:s,opInit:u}}throw new TypeError(`cannot resolve operator '${t.opType}' with opsets: ${e.map((t=>`${t.domain||\"ai.onnx\"} v${t.version}`)).join(\", \")}`)}},9395:(t,e,n)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.onnxruntime=void 0;const r=n(5686);var i,o;i=e.onnxruntime||(e.onnxruntime={}),function(t){let e;!function(t){t[t.UNDEFINED=0]=\"UNDEFINED\",t[t.FLOAT=1]=\"FLOAT\",t[t.INT=2]=\"INT\",t[t.STRING=3]=\"STRING\",t[t.TENSOR=4]=\"TENSOR\",t[t.GRAPH=5]=\"GRAPH\",t[t.FLOATS=6]=\"FLOATS\",t[t.INTS=7]=\"INTS\",t[t.STRINGS=8]=\"STRINGS\",t[t.TENSORS=9]=\"TENSORS\",t[t.GRAPHS=10]=\"GRAPHS\",t[t.SPARSE_TENSOR=11]=\"SPARSE_TENSOR\",t[t.SPARSE_TENSORS=12]=\"SPARSE_TENSORS\"}(e=t.AttributeType||(t.AttributeType={}))}((o=i.experimental||(i.experimental={})).fbs||(o.fbs={})),function(t){!function(t){!function(t){let e;!function(t){t[t.UNKNOWN=0]=\"UNKNOWN\",t[t.VALUE=1]=\"VALUE\",t[t.PARAM=2]=\"PARAM\"}(e=t.DimensionValueType||(t.DimensionValueType={}))}(t.fbs||(t.fbs={}))}(t.experimental||(t.experimental={}))}(e.onnxruntime||(e.onnxruntime={})),function(t){!function(t){!function(t){let e;!function(t){t[t.UNDEFINED=0]=\"UNDEFINED\",t[t.FLOAT=1]=\"FLOAT\",t[t.UINT8=2]=\"UINT8\",t[t.INT8=3]=\"INT8\",t[t.UINT16=4]=\"UINT16\",t[t.INT16=5]=\"INT16\",t[t.INT32=6]=\"INT32\",t[t.INT64=7]=\"INT64\",t[t.STRING=8]=\"STRING\",t[t.BOOL=9]=\"BOOL\",t[t.FLOAT16=10]=\"FLOAT16\",t[t.DOUBLE=11]=\"DOUBLE\",t[t.UINT32=12]=\"UINT32\",t[t.UINT64=13]=\"UINT64\",t[t.COMPLEX64=14]=\"COMPLEX64\",t[t.COMPLEX128=15]=\"COMPLEX128\",t[t.BFLOAT16=16]=\"BFLOAT16\"}(e=t.TensorDataType||(t.TensorDataType={}))}(t.fbs||(t.fbs={}))}(t.experimental||(t.experimental={}))}(e.onnxruntime||(e.onnxruntime={})),function(t){!function(t){!function(t){let e;!function(t){t[t.Primitive=0]=\"Primitive\",t[t.Fused=1]=\"Fused\"}(e=t.NodeType||(t.NodeType={}))}(t.fbs||(t.fbs={}))}(t.experimental||(t.experimental={}))}(e.onnxruntime||(e.onnxruntime={})),function(t){!function(t){!function(t){let e;!function(t){t[t.NONE=0]=\"NONE\",t[t.tensor_type=1]=\"tensor_type\",t[t.sequence_type=2]=\"sequence_type\",t[t.map_type=3]=\"map_type\"}(e=t.TypeInfoValue||(t.TypeInfoValue={}))}(t.fbs||(t.fbs={}))}(t.experimental||(t.experimental={}))}(e.onnxruntime||(e.onnxruntime={})),function(t){!function(e){!function(e){class n{constructor(){this.bb=null,this.bb_pos=0}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsShape(t,e){return(e||new n).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsShape(t,e){return t.setPosition(t.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(e||new n).__init(t.readInt32(t.position())+t.position(),t)}dim(e,n){let r=this.bb.__offset(this.bb_pos,4);return r?(n||new t.experimental.fbs.Dimension).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+r)+4*e),this.bb):null}dimLength(){let t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__vector_len(this.bb_pos+t):0}static startShape(t){t.startObject(1)}static addDim(t,e){t.addFieldOffset(0,e,0)}static createDimVector(t,e){t.startVector(4,e.length,4);for(let n=e.length-1;n>=0;n--)t.addOffset(e[n]);return t.endVector()}static startDimVector(t,e){t.startVector(4,e,4)}static endShape(t){return t.endObject()}static createShape(t,e){return n.startShape(t),n.addDim(t,e),n.endShape(t)}}e.Shape=n}(e.fbs||(e.fbs={}))}(t.experimental||(t.experimental={}))}(e.onnxruntime||(e.onnxruntime={})),function(t){!function(e){!function(e){class n{constructor(){this.bb=null,this.bb_pos=0}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsDimension(t,e){return(e||new n).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsDimension(t,e){return t.setPosition(t.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(e||new n).__init(t.readInt32(t.position())+t.position(),t)}value(e){let n=this.bb.__offset(this.bb_pos,4);return n?(e||new t.experimental.fbs.DimensionValue).__init(this.bb.__indirect(this.bb_pos+n),this.bb):null}denotation(t){let e=this.bb.__offset(this.bb_pos,6);return e?this.bb.__string(this.bb_pos+e,t):null}static startDimension(t){t.startObject(2)}static addValue(t,e){t.addFieldOffset(0,e,0)}static addDenotation(t,e){t.addFieldOffset(1,e,0)}static endDimension(t){return t.endObject()}static createDimension(t,e,r){return n.startDimension(t),n.addValue(t,e),n.addDenotation(t,r),n.endDimension(t)}}e.Dimension=n}(e.fbs||(e.fbs={}))}(t.experimental||(t.experimental={}))}(e.onnxruntime||(e.onnxruntime={})),function(t){!function(e){!function(e){class n{constructor(){this.bb=null,this.bb_pos=0}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsDimensionValue(t,e){return(e||new n).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsDimensionValue(t,e){return t.setPosition(t.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(e||new n).__init(t.readInt32(t.position())+t.position(),t)}dimType(){let e=this.bb.__offset(this.bb_pos,4);return e?this.bb.readInt8(this.bb_pos+e):t.experimental.fbs.DimensionValueType.UNKNOWN}dimValue(){let t=this.bb.__offset(this.bb_pos,6);return t?this.bb.readInt64(this.bb_pos+t):this.bb.createLong(0,0)}dimParam(t){let e=this.bb.__offset(this.bb_pos,8);return e?this.bb.__string(this.bb_pos+e,t):null}static startDimensionValue(t){t.startObject(3)}static addDimType(e,n){e.addFieldInt8(0,n,t.experimental.fbs.DimensionValueType.UNKNOWN)}static addDimValue(t,e){t.addFieldInt64(1,e,t.createLong(0,0))}static addDimParam(t,e){t.addFieldOffset(2,e,0)}static endDimensionValue(t){return t.endObject()}static createDimensionValue(t,e,r,i){return n.startDimensionValue(t),n.addDimType(t,e),n.addDimValue(t,r),n.addDimParam(t,i),n.endDimensionValue(t)}}e.DimensionValue=n}(e.fbs||(e.fbs={}))}(t.experimental||(t.experimental={}))}(e.onnxruntime||(e.onnxruntime={})),function(t){!function(e){!function(e){class n{constructor(){this.bb=null,this.bb_pos=0}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsTensorTypeAndShape(t,e){return(e||new n).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsTensorTypeAndShape(t,e){return t.setPosition(t.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(e||new n).__init(t.readInt32(t.position())+t.position(),t)}elemType(){let e=this.bb.__offset(this.bb_pos,4);return e?this.bb.readInt32(this.bb_pos+e):t.experimental.fbs.TensorDataType.UNDEFINED}shape(e){let n=this.bb.__offset(this.bb_pos,6);return n?(e||new t.experimental.fbs.Shape).__init(this.bb.__indirect(this.bb_pos+n),this.bb):null}static startTensorTypeAndShape(t){t.startObject(2)}static addElemType(e,n){e.addFieldInt32(0,n,t.experimental.fbs.TensorDataType.UNDEFINED)}static addShape(t,e){t.addFieldOffset(1,e,0)}static endTensorTypeAndShape(t){return t.endObject()}static createTensorTypeAndShape(t,e,r){return n.startTensorTypeAndShape(t),n.addElemType(t,e),n.addShape(t,r),n.endTensorTypeAndShape(t)}}e.TensorTypeAndShape=n}(e.fbs||(e.fbs={}))}(t.experimental||(t.experimental={}))}(e.onnxruntime||(e.onnxruntime={})),function(t){!function(e){!function(e){class n{constructor(){this.bb=null,this.bb_pos=0}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsMapType(t,e){return(e||new n).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsMapType(t,e){return t.setPosition(t.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(e||new n).__init(t.readInt32(t.position())+t.position(),t)}keyType(){let e=this.bb.__offset(this.bb_pos,4);return e?this.bb.readInt32(this.bb_pos+e):t.experimental.fbs.TensorDataType.UNDEFINED}valueType(e){let n=this.bb.__offset(this.bb_pos,6);return n?(e||new t.experimental.fbs.TypeInfo).__init(this.bb.__indirect(this.bb_pos+n),this.bb):null}static startMapType(t){t.startObject(2)}static addKeyType(e,n){e.addFieldInt32(0,n,t.experimental.fbs.TensorDataType.UNDEFINED)}static addValueType(t,e){t.addFieldOffset(1,e,0)}static endMapType(t){return t.endObject()}static createMapType(t,e,r){return n.startMapType(t),n.addKeyType(t,e),n.addValueType(t,r),n.endMapType(t)}}e.MapType=n}(e.fbs||(e.fbs={}))}(t.experimental||(t.experimental={}))}(e.onnxruntime||(e.onnxruntime={})),function(t){!function(e){!function(e){class n{constructor(){this.bb=null,this.bb_pos=0}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsSequenceType(t,e){return(e||new n).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsSequenceType(t,e){return t.setPosition(t.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(e||new n).__init(t.readInt32(t.position())+t.position(),t)}elemType(e){let n=this.bb.__offset(this.bb_pos,4);return n?(e||new t.experimental.fbs.TypeInfo).__init(this.bb.__indirect(this.bb_pos+n),this.bb):null}static startSequenceType(t){t.startObject(1)}static addElemType(t,e){t.addFieldOffset(0,e,0)}static endSequenceType(t){return t.endObject()}static createSequenceType(t,e){return n.startSequenceType(t),n.addElemType(t,e),n.endSequenceType(t)}}e.SequenceType=n}(e.fbs||(e.fbs={}))}(t.experimental||(t.experimental={}))}(e.onnxruntime||(e.onnxruntime={})),function(t){!function(t){(t.fbs||(t.fbs={})).EdgeEnd=class{constructor(){this.bb=null,this.bb_pos=0}__init(t,e){return this.bb_pos=t,this.bb=e,this}nodeIndex(){return this.bb.readUint32(this.bb_pos)}srcArgIndex(){return this.bb.readInt32(this.bb_pos+4)}dstArgIndex(){return this.bb.readInt32(this.bb_pos+8)}static createEdgeEnd(t,e,n,r){return t.prep(4,12),t.writeInt32(r),t.writeInt32(n),t.writeInt32(e),t.offset()}}}(t.experimental||(t.experimental={}))}(e.onnxruntime||(e.onnxruntime={})),function(t){!function(e){!function(e){class n{constructor(){this.bb=null,this.bb_pos=0}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsNodeEdge(t,e){return(e||new n).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsNodeEdge(t,e){return t.setPosition(t.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(e||new n).__init(t.readInt32(t.position())+t.position(),t)}nodeIndex(){let t=this.bb.__offset(this.bb_pos,4);return t?this.bb.readUint32(this.bb_pos+t):0}inputEdges(e,n){let r=this.bb.__offset(this.bb_pos,6);return r?(n||new t.experimental.fbs.EdgeEnd).__init(this.bb.__vector(this.bb_pos+r)+12*e,this.bb):null}inputEdgesLength(){let t=this.bb.__offset(this.bb_pos,6);return t?this.bb.__vector_len(this.bb_pos+t):0}outputEdges(e,n){let r=this.bb.__offset(this.bb_pos,8);return r?(n||new t.experimental.fbs.EdgeEnd).__init(this.bb.__vector(this.bb_pos+r)+12*e,this.bb):null}outputEdgesLength(){let t=this.bb.__offset(this.bb_pos,8);return t?this.bb.__vector_len(this.bb_pos+t):0}static startNodeEdge(t){t.startObject(3)}static addNodeIndex(t,e){t.addFieldInt32(0,e,0)}static addInputEdges(t,e){t.addFieldOffset(1,e,0)}static startInputEdgesVector(t,e){t.startVector(12,e,4)}static addOutputEdges(t,e){t.addFieldOffset(2,e,0)}static startOutputEdgesVector(t,e){t.startVector(12,e,4)}static endNodeEdge(t){return t.endObject()}static createNodeEdge(t,e,r,i){return n.startNodeEdge(t),n.addNodeIndex(t,e),n.addInputEdges(t,r),n.addOutputEdges(t,i),n.endNodeEdge(t)}}e.NodeEdge=n}(e.fbs||(e.fbs={}))}(t.experimental||(t.experimental={}))}(e.onnxruntime||(e.onnxruntime={})),function(t){!function(e){!function(e){class n{constructor(){this.bb=null,this.bb_pos=0}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsNode(t,e){return(e||new n).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsNode(t,e){return t.setPosition(t.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(e||new n).__init(t.readInt32(t.position())+t.position(),t)}name(t){let e=this.bb.__offset(this.bb_pos,4);return e?this.bb.__string(this.bb_pos+e,t):null}docString(t){let e=this.bb.__offset(this.bb_pos,6);return e?this.bb.__string(this.bb_pos+e,t):null}domain(t){let e=this.bb.__offset(this.bb_pos,8);return e?this.bb.__string(this.bb_pos+e,t):null}sinceVersion(){let t=this.bb.__offset(this.bb_pos,10);return t?this.bb.readInt32(this.bb_pos+t):0}index(){let t=this.bb.__offset(this.bb_pos,12);return t?this.bb.readUint32(this.bb_pos+t):0}opType(t){let e=this.bb.__offset(this.bb_pos,14);return e?this.bb.__string(this.bb_pos+e,t):null}type(){let e=this.bb.__offset(this.bb_pos,16);return e?this.bb.readInt32(this.bb_pos+e):t.experimental.fbs.NodeType.Primitive}executionProviderType(t){let e=this.bb.__offset(this.bb_pos,18);return e?this.bb.__string(this.bb_pos+e,t):null}inputs(t,e){let n=this.bb.__offset(this.bb_pos,20);return n?this.bb.__string(this.bb.__vector(this.bb_pos+n)+4*t,e):null}inputsLength(){let t=this.bb.__offset(this.bb_pos,20);return t?this.bb.__vector_len(this.bb_pos+t):0}outputs(t,e){let n=this.bb.__offset(this.bb_pos,22);return n?this.bb.__string(this.bb.__vector(this.bb_pos+n)+4*t,e):null}outputsLength(){let t=this.bb.__offset(this.bb_pos,22);return t?this.bb.__vector_len(this.bb_pos+t):0}attributes(e,n){let r=this.bb.__offset(this.bb_pos,24);return r?(n||new t.experimental.fbs.Attribute).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+r)+4*e),this.bb):null}attributesLength(){let t=this.bb.__offset(this.bb_pos,24);return t?this.bb.__vector_len(this.bb_pos+t):0}inputArgCounts(t){let e=this.bb.__offset(this.bb_pos,26);return e?this.bb.readInt32(this.bb.__vector(this.bb_pos+e)+4*t):0}inputArgCountsLength(){let t=this.bb.__offset(this.bb_pos,26);return t?this.bb.__vector_len(this.bb_pos+t):0}inputArgCountsArray(){let t=this.bb.__offset(this.bb_pos,26);return t?new Int32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}implicitInputs(t,e){let n=this.bb.__offset(this.bb_pos,28);return n?this.bb.__string(this.bb.__vector(this.bb_pos+n)+4*t,e):null}implicitInputsLength(){let t=this.bb.__offset(this.bb_pos,28);return t?this.bb.__vector_len(this.bb_pos+t):0}static startNode(t){t.startObject(13)}static addName(t,e){t.addFieldOffset(0,e,0)}static addDocString(t,e){t.addFieldOffset(1,e,0)}static addDomain(t,e){t.addFieldOffset(2,e,0)}static addSinceVersion(t,e){t.addFieldInt32(3,e,0)}static addIndex(t,e){t.addFieldInt32(4,e,0)}static addOpType(t,e){t.addFieldOffset(5,e,0)}static addType(e,n){e.addFieldInt32(6,n,t.experimental.fbs.NodeType.Primitive)}static addExecutionProviderType(t,e){t.addFieldOffset(7,e,0)}static addInputs(t,e){t.addFieldOffset(8,e,0)}static createInputsVector(t,e){t.startVector(4,e.length,4);for(let n=e.length-1;n>=0;n--)t.addOffset(e[n]);return t.endVector()}static startInputsVector(t,e){t.startVector(4,e,4)}static addOutputs(t,e){t.addFieldOffset(9,e,0)}static createOutputsVector(t,e){t.startVector(4,e.length,4);for(let n=e.length-1;n>=0;n--)t.addOffset(e[n]);return t.endVector()}static startOutputsVector(t,e){t.startVector(4,e,4)}static addAttributes(t,e){t.addFieldOffset(10,e,0)}static createAttributesVector(t,e){t.startVector(4,e.length,4);for(let n=e.length-1;n>=0;n--)t.addOffset(e[n]);return t.endVector()}static startAttributesVector(t,e){t.startVector(4,e,4)}static addInputArgCounts(t,e){t.addFieldOffset(11,e,0)}static createInputArgCountsVector(t,e){t.startVector(4,e.length,4);for(let n=e.length-1;n>=0;n--)t.addInt32(e[n]);return t.endVector()}static startInputArgCountsVector(t,e){t.startVector(4,e,4)}static addImplicitInputs(t,e){t.addFieldOffset(12,e,0)}static createImplicitInputsVector(t,e){t.startVector(4,e.length,4);for(let n=e.length-1;n>=0;n--)t.addOffset(e[n]);return t.endVector()}static startImplicitInputsVector(t,e){t.startVector(4,e,4)}static endNode(t){return t.endObject()}static createNode(t,e,r,i,o,a,s,u,c,l,p,f,d,h){return n.startNode(t),n.addName(t,e),n.addDocString(t,r),n.addDomain(t,i),n.addSinceVersion(t,o),n.addIndex(t,a),n.addOpType(t,s),n.addType(t,u),n.addExecutionProviderType(t,c),n.addInputs(t,l),n.addOutputs(t,p),n.addAttributes(t,f),n.addInputArgCounts(t,d),n.addImplicitInputs(t,h),n.endNode(t)}}e.Node=n}(e.fbs||(e.fbs={}))}(t.experimental||(t.experimental={}))}(e.onnxruntime||(e.onnxruntime={})),function(t){!function(e){!function(e){class n{constructor(){this.bb=null,this.bb_pos=0}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsValueInfo(t,e){return(e||new n).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsValueInfo(t,e){return t.setPosition(t.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(e||new n).__init(t.readInt32(t.position())+t.position(),t)}name(t){let e=this.bb.__offset(this.bb_pos,4);return e?this.bb.__string(this.bb_pos+e,t):null}docString(t){let e=this.bb.__offset(this.bb_pos,6);return e?this.bb.__string(this.bb_pos+e,t):null}type(e){let n=this.bb.__offset(this.bb_pos,8);return n?(e||new t.experimental.fbs.TypeInfo).__init(this.bb.__indirect(this.bb_pos+n),this.bb):null}static startValueInfo(t){t.startObject(3)}static addName(t,e){t.addFieldOffset(0,e,0)}static addDocString(t,e){t.addFieldOffset(1,e,0)}static addType(t,e){t.addFieldOffset(2,e,0)}static endValueInfo(t){return t.endObject()}static createValueInfo(t,e,r,i){return n.startValueInfo(t),n.addName(t,e),n.addDocString(t,r),n.addType(t,i),n.endValueInfo(t)}}e.ValueInfo=n}(e.fbs||(e.fbs={}))}(t.experimental||(t.experimental={}))}(e.onnxruntime||(e.onnxruntime={})),function(t){!function(e){!function(e){class n{constructor(){this.bb=null,this.bb_pos=0}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsTypeInfo(t,e){return(e||new n).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsTypeInfo(t,e){return t.setPosition(t.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(e||new n).__init(t.readInt32(t.position())+t.position(),t)}denotation(t){let e=this.bb.__offset(this.bb_pos,4);return e?this.bb.__string(this.bb_pos+e,t):null}valueType(){let e=this.bb.__offset(this.bb_pos,6);return e?this.bb.readUint8(this.bb_pos+e):t.experimental.fbs.TypeInfoValue.NONE}value(t){let e=this.bb.__offset(this.bb_pos,8);return e?this.bb.__union(t,this.bb_pos+e):null}static startTypeInfo(t){t.startObject(3)}static addDenotation(t,e){t.addFieldOffset(0,e,0)}static addValueType(e,n){e.addFieldInt8(1,n,t.experimental.fbs.TypeInfoValue.NONE)}static addValue(t,e){t.addFieldOffset(2,e,0)}static endTypeInfo(t){return t.endObject()}static createTypeInfo(t,e,r,i){return n.startTypeInfo(t),n.addDenotation(t,e),n.addValueType(t,r),n.addValue(t,i),n.endTypeInfo(t)}}e.TypeInfo=n}(e.fbs||(e.fbs={}))}(t.experimental||(t.experimental={}))}(e.onnxruntime||(e.onnxruntime={})),function(t){!function(t){!function(t){class e{constructor(){this.bb=null,this.bb_pos=0}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsOperatorSetId(t,n){return(n||new e).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsOperatorSetId(t,n){return t.setPosition(t.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(n||new e).__init(t.readInt32(t.position())+t.position(),t)}domain(t){let e=this.bb.__offset(this.bb_pos,4);return e?this.bb.__string(this.bb_pos+e,t):null}version(){let t=this.bb.__offset(this.bb_pos,6);return t?this.bb.readInt64(this.bb_pos+t):this.bb.createLong(0,0)}static startOperatorSetId(t){t.startObject(2)}static addDomain(t,e){t.addFieldOffset(0,e,0)}static addVersion(t,e){t.addFieldInt64(1,e,t.createLong(0,0))}static endOperatorSetId(t){return t.endObject()}static createOperatorSetId(t,n,r){return e.startOperatorSetId(t),e.addDomain(t,n),e.addVersion(t,r),e.endOperatorSetId(t)}}t.OperatorSetId=e}(t.fbs||(t.fbs={}))}(t.experimental||(t.experimental={}))}(e.onnxruntime||(e.onnxruntime={})),function(t){!function(e){!function(e){class n{constructor(){this.bb=null,this.bb_pos=0}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsTensor(t,e){return(e||new n).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsTensor(t,e){return t.setPosition(t.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(e||new n).__init(t.readInt32(t.position())+t.position(),t)}name(t){let e=this.bb.__offset(this.bb_pos,4);return e?this.bb.__string(this.bb_pos+e,t):null}docString(t){let e=this.bb.__offset(this.bb_pos,6);return e?this.bb.__string(this.bb_pos+e,t):null}dims(t){let e=this.bb.__offset(this.bb_pos,8);return e?this.bb.readInt64(this.bb.__vector(this.bb_pos+e)+8*t):this.bb.createLong(0,0)}dimsLength(){let t=this.bb.__offset(this.bb_pos,8);return t?this.bb.__vector_len(this.bb_pos+t):0}dataType(){let e=this.bb.__offset(this.bb_pos,10);return e?this.bb.readInt32(this.bb_pos+e):t.experimental.fbs.TensorDataType.UNDEFINED}rawData(t){let e=this.bb.__offset(this.bb_pos,12);return e?this.bb.readUint8(this.bb.__vector(this.bb_pos+e)+t):0}rawDataLength(){let t=this.bb.__offset(this.bb_pos,12);return t?this.bb.__vector_len(this.bb_pos+t):0}rawDataArray(){let t=this.bb.__offset(this.bb_pos,12);return t?new Uint8Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}stringData(t,e){let n=this.bb.__offset(this.bb_pos,14);return n?this.bb.__string(this.bb.__vector(this.bb_pos+n)+4*t,e):null}stringDataLength(){let t=this.bb.__offset(this.bb_pos,14);return t?this.bb.__vector_len(this.bb_pos+t):0}static startTensor(t){t.startObject(6)}static addName(t,e){t.addFieldOffset(0,e,0)}static addDocString(t,e){t.addFieldOffset(1,e,0)}static addDims(t,e){t.addFieldOffset(2,e,0)}static createDimsVector(t,e){t.startVector(8,e.length,8);for(let n=e.length-1;n>=0;n--)t.addInt64(e[n]);return t.endVector()}static startDimsVector(t,e){t.startVector(8,e,8)}static addDataType(e,n){e.addFieldInt32(3,n,t.experimental.fbs.TensorDataType.UNDEFINED)}static addRawData(t,e){t.addFieldOffset(4,e,0)}static createRawDataVector(t,e){t.startVector(1,e.length,1);for(let n=e.length-1;n>=0;n--)t.addInt8(e[n]);return t.endVector()}static startRawDataVector(t,e){t.startVector(1,e,1)}static addStringData(t,e){t.addFieldOffset(5,e,0)}static createStringDataVector(t,e){t.startVector(4,e.length,4);for(let n=e.length-1;n>=0;n--)t.addOffset(e[n]);return t.endVector()}static startStringDataVector(t,e){t.startVector(4,e,4)}static endTensor(t){return t.endObject()}static createTensor(t,e,r,i,o,a,s){return n.startTensor(t),n.addName(t,e),n.addDocString(t,r),n.addDims(t,i),n.addDataType(t,o),n.addRawData(t,a),n.addStringData(t,s),n.endTensor(t)}}e.Tensor=n}(e.fbs||(e.fbs={}))}(t.experimental||(t.experimental={}))}(e.onnxruntime||(e.onnxruntime={})),function(t){!function(e){!function(e){class n{constructor(){this.bb=null,this.bb_pos=0}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsSparseTensor(t,e){return(e||new n).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsSparseTensor(t,e){return t.setPosition(t.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(e||new n).__init(t.readInt32(t.position())+t.position(),t)}values(e){let n=this.bb.__offset(this.bb_pos,4);return n?(e||new t.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb_pos+n),this.bb):null}indices(e){let n=this.bb.__offset(this.bb_pos,6);return n?(e||new t.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb_pos+n),this.bb):null}dims(t){let e=this.bb.__offset(this.bb_pos,8);return e?this.bb.readInt64(this.bb.__vector(this.bb_pos+e)+8*t):this.bb.createLong(0,0)}dimsLength(){let t=this.bb.__offset(this.bb_pos,8);return t?this.bb.__vector_len(this.bb_pos+t):0}static startSparseTensor(t){t.startObject(3)}static addValues(t,e){t.addFieldOffset(0,e,0)}static addIndices(t,e){t.addFieldOffset(1,e,0)}static addDims(t,e){t.addFieldOffset(2,e,0)}static createDimsVector(t,e){t.startVector(8,e.length,8);for(let n=e.length-1;n>=0;n--)t.addInt64(e[n]);return t.endVector()}static startDimsVector(t,e){t.startVector(8,e,8)}static endSparseTensor(t){return t.endObject()}static createSparseTensor(t,e,r,i){return n.startSparseTensor(t),n.addValues(t,e),n.addIndices(t,r),n.addDims(t,i),n.endSparseTensor(t)}}e.SparseTensor=n}(e.fbs||(e.fbs={}))}(t.experimental||(t.experimental={}))}(e.onnxruntime||(e.onnxruntime={})),function(t){!function(e){!function(e){class n{constructor(){this.bb=null,this.bb_pos=0}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsAttribute(t,e){return(e||new n).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsAttribute(t,e){return t.setPosition(t.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(e||new n).__init(t.readInt32(t.position())+t.position(),t)}name(t){let e=this.bb.__offset(this.bb_pos,4);return e?this.bb.__string(this.bb_pos+e,t):null}docString(t){let e=this.bb.__offset(this.bb_pos,6);return e?this.bb.__string(this.bb_pos+e,t):null}type(){let e=this.bb.__offset(this.bb_pos,8);return e?this.bb.readInt32(this.bb_pos+e):t.experimental.fbs.AttributeType.UNDEFINED}f(){let t=this.bb.__offset(this.bb_pos,10);return t?this.bb.readFloat32(this.bb_pos+t):0}i(){let t=this.bb.__offset(this.bb_pos,12);return t?this.bb.readInt64(this.bb_pos+t):this.bb.createLong(0,0)}s(t){let e=this.bb.__offset(this.bb_pos,14);return e?this.bb.__string(this.bb_pos+e,t):null}t(e){let n=this.bb.__offset(this.bb_pos,16);return n?(e||new t.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb_pos+n),this.bb):null}g(e){let n=this.bb.__offset(this.bb_pos,18);return n?(e||new t.experimental.fbs.Graph).__init(this.bb.__indirect(this.bb_pos+n),this.bb):null}floats(t){let e=this.bb.__offset(this.bb_pos,20);return e?this.bb.readFloat32(this.bb.__vector(this.bb_pos+e)+4*t):0}floatsLength(){let t=this.bb.__offset(this.bb_pos,20);return t?this.bb.__vector_len(this.bb_pos+t):0}floatsArray(){let t=this.bb.__offset(this.bb_pos,20);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}ints(t){let e=this.bb.__offset(this.bb_pos,22);return e?this.bb.readInt64(this.bb.__vector(this.bb_pos+e)+8*t):this.bb.createLong(0,0)}intsLength(){let t=this.bb.__offset(this.bb_pos,22);return t?this.bb.__vector_len(this.bb_pos+t):0}strings(t,e){let n=this.bb.__offset(this.bb_pos,24);return n?this.bb.__string(this.bb.__vector(this.bb_pos+n)+4*t,e):null}stringsLength(){let t=this.bb.__offset(this.bb_pos,24);return t?this.bb.__vector_len(this.bb_pos+t):0}tensors(e,n){let r=this.bb.__offset(this.bb_pos,26);return r?(n||new t.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+r)+4*e),this.bb):null}tensorsLength(){let t=this.bb.__offset(this.bb_pos,26);return t?this.bb.__vector_len(this.bb_pos+t):0}graphs(e,n){let r=this.bb.__offset(this.bb_pos,28);return r?(n||new t.experimental.fbs.Graph).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+r)+4*e),this.bb):null}graphsLength(){let t=this.bb.__offset(this.bb_pos,28);return t?this.bb.__vector_len(this.bb_pos+t):0}static startAttribute(t){t.startObject(13)}static addName(t,e){t.addFieldOffset(0,e,0)}static addDocString(t,e){t.addFieldOffset(1,e,0)}static addType(e,n){e.addFieldInt32(2,n,t.experimental.fbs.AttributeType.UNDEFINED)}static addF(t,e){t.addFieldFloat32(3,e,0)}static addI(t,e){t.addFieldInt64(4,e,t.createLong(0,0))}static addS(t,e){t.addFieldOffset(5,e,0)}static addT(t,e){t.addFieldOffset(6,e,0)}static addG(t,e){t.addFieldOffset(7,e,0)}static addFloats(t,e){t.addFieldOffset(8,e,0)}static createFloatsVector(t,e){t.startVector(4,e.length,4);for(let n=e.length-1;n>=0;n--)t.addFloat32(e[n]);return t.endVector()}static startFloatsVector(t,e){t.startVector(4,e,4)}static addInts(t,e){t.addFieldOffset(9,e,0)}static createIntsVector(t,e){t.startVector(8,e.length,8);for(let n=e.length-1;n>=0;n--)t.addInt64(e[n]);return t.endVector()}static startIntsVector(t,e){t.startVector(8,e,8)}static addStrings(t,e){t.addFieldOffset(10,e,0)}static createStringsVector(t,e){t.startVector(4,e.length,4);for(let n=e.length-1;n>=0;n--)t.addOffset(e[n]);return t.endVector()}static startStringsVector(t,e){t.startVector(4,e,4)}static addTensors(t,e){t.addFieldOffset(11,e,0)}static createTensorsVector(t,e){t.startVector(4,e.length,4);for(let n=e.length-1;n>=0;n--)t.addOffset(e[n]);return t.endVector()}static startTensorsVector(t,e){t.startVector(4,e,4)}static addGraphs(t,e){t.addFieldOffset(12,e,0)}static createGraphsVector(t,e){t.startVector(4,e.length,4);for(let n=e.length-1;n>=0;n--)t.addOffset(e[n]);return t.endVector()}static startGraphsVector(t,e){t.startVector(4,e,4)}static endAttribute(t){return t.endObject()}static createAttribute(t,e,r,i,o,a,s,u,c,l,p,f,d,h){return n.startAttribute(t),n.addName(t,e),n.addDocString(t,r),n.addType(t,i),n.addF(t,o),n.addI(t,a),n.addS(t,s),n.addT(t,u),n.addG(t,c),n.addFloats(t,l),n.addInts(t,p),n.addStrings(t,f),n.addTensors(t,d),n.addGraphs(t,h),n.endAttribute(t)}}e.Attribute=n}(e.fbs||(e.fbs={}))}(t.experimental||(t.experimental={}))}(e.onnxruntime||(e.onnxruntime={})),function(t){!function(e){!function(e){class n{constructor(){this.bb=null,this.bb_pos=0}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsGraph(t,e){return(e||new n).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsGraph(t,e){return t.setPosition(t.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(e||new n).__init(t.readInt32(t.position())+t.position(),t)}initializers(e,n){let r=this.bb.__offset(this.bb_pos,4);return r?(n||new t.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+r)+4*e),this.bb):null}initializersLength(){let t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__vector_len(this.bb_pos+t):0}nodeArgs(e,n){let r=this.bb.__offset(this.bb_pos,6);return r?(n||new t.experimental.fbs.ValueInfo).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+r)+4*e),this.bb):null}nodeArgsLength(){let t=this.bb.__offset(this.bb_pos,6);return t?this.bb.__vector_len(this.bb_pos+t):0}nodes(e,n){let r=this.bb.__offset(this.bb_pos,8);return r?(n||new t.experimental.fbs.Node).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+r)+4*e),this.bb):null}nodesLength(){let t=this.bb.__offset(this.bb_pos,8);return t?this.bb.__vector_len(this.bb_pos+t):0}maxNodeIndex(){let t=this.bb.__offset(this.bb_pos,10);return t?this.bb.readUint32(this.bb_pos+t):0}nodeEdges(e,n){let r=this.bb.__offset(this.bb_pos,12);return r?(n||new t.experimental.fbs.NodeEdge).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+r)+4*e),this.bb):null}nodeEdgesLength(){let t=this.bb.__offset(this.bb_pos,12);return t?this.bb.__vector_len(this.bb_pos+t):0}inputs(t,e){let n=this.bb.__offset(this.bb_pos,14);return n?this.bb.__string(this.bb.__vector(this.bb_pos+n)+4*t,e):null}inputsLength(){let t=this.bb.__offset(this.bb_pos,14);return t?this.bb.__vector_len(this.bb_pos+t):0}outputs(t,e){let n=this.bb.__offset(this.bb_pos,16);return n?this.bb.__string(this.bb.__vector(this.bb_pos+n)+4*t,e):null}outputsLength(){let t=this.bb.__offset(this.bb_pos,16);return t?this.bb.__vector_len(this.bb_pos+t):0}sparseInitializers(e,n){let r=this.bb.__offset(this.bb_pos,18);return r?(n||new t.experimental.fbs.SparseTensor).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+r)+4*e),this.bb):null}sparseInitializersLength(){let t=this.bb.__offset(this.bb_pos,18);return t?this.bb.__vector_len(this.bb_pos+t):0}static startGraph(t){t.startObject(8)}static addInitializers(t,e){t.addFieldOffset(0,e,0)}static createInitializersVector(t,e){t.startVector(4,e.length,4);for(let n=e.length-1;n>=0;n--)t.addOffset(e[n]);return t.endVector()}static startInitializersVector(t,e){t.startVector(4,e,4)}static addNodeArgs(t,e){t.addFieldOffset(1,e,0)}static createNodeArgsVector(t,e){t.startVector(4,e.length,4);for(let n=e.length-1;n>=0;n--)t.addOffset(e[n]);return t.endVector()}static startNodeArgsVector(t,e){t.startVector(4,e,4)}static addNodes(t,e){t.addFieldOffset(2,e,0)}static createNodesVector(t,e){t.startVector(4,e.length,4);for(let n=e.length-1;n>=0;n--)t.addOffset(e[n]);return t.endVector()}static startNodesVector(t,e){t.startVector(4,e,4)}static addMaxNodeIndex(t,e){t.addFieldInt32(3,e,0)}static addNodeEdges(t,e){t.addFieldOffset(4,e,0)}static createNodeEdgesVector(t,e){t.startVector(4,e.length,4);for(let n=e.length-1;n>=0;n--)t.addOffset(e[n]);return t.endVector()}static startNodeEdgesVector(t,e){t.startVector(4,e,4)}static addInputs(t,e){t.addFieldOffset(5,e,0)}static createInputsVector(t,e){t.startVector(4,e.length,4);for(let n=e.length-1;n>=0;n--)t.addOffset(e[n]);return t.endVector()}static startInputsVector(t,e){t.startVector(4,e,4)}static addOutputs(t,e){t.addFieldOffset(6,e,0)}static createOutputsVector(t,e){t.startVector(4,e.length,4);for(let n=e.length-1;n>=0;n--)t.addOffset(e[n]);return t.endVector()}static startOutputsVector(t,e){t.startVector(4,e,4)}static addSparseInitializers(t,e){t.addFieldOffset(7,e,0)}static createSparseInitializersVector(t,e){t.startVector(4,e.length,4);for(let n=e.length-1;n>=0;n--)t.addOffset(e[n]);return t.endVector()}static startSparseInitializersVector(t,e){t.startVector(4,e,4)}static endGraph(t){return t.endObject()}static createGraph(t,e,r,i,o,a,s,u,c){return n.startGraph(t),n.addInitializers(t,e),n.addNodeArgs(t,r),n.addNodes(t,i),n.addMaxNodeIndex(t,o),n.addNodeEdges(t,a),n.addInputs(t,s),n.addOutputs(t,u),n.addSparseInitializers(t,c),n.endGraph(t)}}e.Graph=n}(e.fbs||(e.fbs={}))}(t.experimental||(t.experimental={}))}(e.onnxruntime||(e.onnxruntime={})),function(t){!function(e){!function(e){class n{constructor(){this.bb=null,this.bb_pos=0}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsModel(t,e){return(e||new n).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsModel(t,e){return t.setPosition(t.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(e||new n).__init(t.readInt32(t.position())+t.position(),t)}irVersion(){let t=this.bb.__offset(this.bb_pos,4);return t?this.bb.readInt64(this.bb_pos+t):this.bb.createLong(0,0)}opsetImport(e,n){let r=this.bb.__offset(this.bb_pos,6);return r?(n||new t.experimental.fbs.OperatorSetId).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+r)+4*e),this.bb):null}opsetImportLength(){let t=this.bb.__offset(this.bb_pos,6);return t?this.bb.__vector_len(this.bb_pos+t):0}producerName(t){let e=this.bb.__offset(this.bb_pos,8);return e?this.bb.__string(this.bb_pos+e,t):null}producerVersion(t){let e=this.bb.__offset(this.bb_pos,10);return e?this.bb.__string(this.bb_pos+e,t):null}domain(t){let e=this.bb.__offset(this.bb_pos,12);return e?this.bb.__string(this.bb_pos+e,t):null}modelVersion(){let t=this.bb.__offset(this.bb_pos,14);return t?this.bb.readInt64(this.bb_pos+t):this.bb.createLong(0,0)}docString(t){let e=this.bb.__offset(this.bb_pos,16);return e?this.bb.__string(this.bb_pos+e,t):null}graph(e){let n=this.bb.__offset(this.bb_pos,18);return n?(e||new t.experimental.fbs.Graph).__init(this.bb.__indirect(this.bb_pos+n),this.bb):null}graphDocString(t){let e=this.bb.__offset(this.bb_pos,20);return e?this.bb.__string(this.bb_pos+e,t):null}static startModel(t){t.startObject(9)}static addIrVersion(t,e){t.addFieldInt64(0,e,t.createLong(0,0))}static addOpsetImport(t,e){t.addFieldOffset(1,e,0)}static createOpsetImportVector(t,e){t.startVector(4,e.length,4);for(let n=e.length-1;n>=0;n--)t.addOffset(e[n]);return t.endVector()}static startOpsetImportVector(t,e){t.startVector(4,e,4)}static addProducerName(t,e){t.addFieldOffset(2,e,0)}static addProducerVersion(t,e){t.addFieldOffset(3,e,0)}static addDomain(t,e){t.addFieldOffset(4,e,0)}static addModelVersion(t,e){t.addFieldInt64(5,e,t.createLong(0,0))}static addDocString(t,e){t.addFieldOffset(6,e,0)}static addGraph(t,e){t.addFieldOffset(7,e,0)}static addGraphDocString(t,e){t.addFieldOffset(8,e,0)}static endModel(t){return t.endObject()}static createModel(t,e,r,i,o,a,s,u,c,l){return n.startModel(t),n.addIrVersion(t,e),n.addOpsetImport(t,r),n.addProducerName(t,i),n.addProducerVersion(t,o),n.addDomain(t,a),n.addModelVersion(t,s),n.addDocString(t,u),n.addGraph(t,c),n.addGraphDocString(t,l),n.endModel(t)}}e.Model=n}(e.fbs||(e.fbs={}))}(t.experimental||(t.experimental={}))}(e.onnxruntime||(e.onnxruntime={})),function(t){!function(t){!function(t){class e{constructor(){this.bb=null,this.bb_pos=0}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsKernelCreateInfos(t,n){return(n||new e).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsKernelCreateInfos(t,n){return t.setPosition(t.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(n||new e).__init(t.readInt32(t.position())+t.position(),t)}nodeIndices(t){let e=this.bb.__offset(this.bb_pos,4);return e?this.bb.readUint32(this.bb.__vector(this.bb_pos+e)+4*t):0}nodeIndicesLength(){let t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__vector_len(this.bb_pos+t):0}nodeIndicesArray(){let t=this.bb.__offset(this.bb_pos,4);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}kernelDefHashes(t){let e=this.bb.__offset(this.bb_pos,6);return e?this.bb.readUint64(this.bb.__vector(this.bb_pos+e)+8*t):this.bb.createLong(0,0)}kernelDefHashesLength(){let t=this.bb.__offset(this.bb_pos,6);return t?this.bb.__vector_len(this.bb_pos+t):0}static startKernelCreateInfos(t){t.startObject(2)}static addNodeIndices(t,e){t.addFieldOffset(0,e,0)}static createNodeIndicesVector(t,e){t.startVector(4,e.length,4);for(let n=e.length-1;n>=0;n--)t.addInt32(e[n]);return t.endVector()}static startNodeIndicesVector(t,e){t.startVector(4,e,4)}static addKernelDefHashes(t,e){t.addFieldOffset(1,e,0)}static createKernelDefHashesVector(t,e){t.startVector(8,e.length,8);for(let n=e.length-1;n>=0;n--)t.addInt64(e[n]);return t.endVector()}static startKernelDefHashesVector(t,e){t.startVector(8,e,8)}static endKernelCreateInfos(t){return t.endObject()}static createKernelCreateInfos(t,n,r){return e.startKernelCreateInfos(t),e.addNodeIndices(t,n),e.addKernelDefHashes(t,r),e.endKernelCreateInfos(t)}}t.KernelCreateInfos=e}(t.fbs||(t.fbs={}))}(t.experimental||(t.experimental={}))}(e.onnxruntime||(e.onnxruntime={})),function(t){!function(e){!function(e){class n{constructor(){this.bb=null,this.bb_pos=0}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsSubGraphSessionState(t,e){return(e||new n).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsSubGraphSessionState(t,e){return t.setPosition(t.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(e||new n).__init(t.readInt32(t.position())+t.position(),t)}graphId(t){let e=this.bb.__offset(this.bb_pos,4);return e?this.bb.__string(this.bb_pos+e,t):null}sessionState(e){let n=this.bb.__offset(this.bb_pos,6);return n?(e||new t.experimental.fbs.SessionState).__init(this.bb.__indirect(this.bb_pos+n),this.bb):null}static startSubGraphSessionState(t){t.startObject(2)}static addGraphId(t,e){t.addFieldOffset(0,e,0)}static addSessionState(t,e){t.addFieldOffset(1,e,0)}static endSubGraphSessionState(t){let e=t.endObject();return t.requiredField(e,4),e}static createSubGraphSessionState(t,e,r){return n.startSubGraphSessionState(t),n.addGraphId(t,e),n.addSessionState(t,r),n.endSubGraphSessionState(t)}}e.SubGraphSessionState=n}(e.fbs||(e.fbs={}))}(t.experimental||(t.experimental={}))}(e.onnxruntime||(e.onnxruntime={})),function(t){!function(e){!function(e){class n{constructor(){this.bb=null,this.bb_pos=0}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsSessionState(t,e){return(e||new n).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsSessionState(t,e){return t.setPosition(t.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(e||new n).__init(t.readInt32(t.position())+t.position(),t)}kernels(e){let n=this.bb.__offset(this.bb_pos,4);return n?(e||new t.experimental.fbs.KernelCreateInfos).__init(this.bb.__indirect(this.bb_pos+n),this.bb):null}subGraphSessionStates(e,n){let r=this.bb.__offset(this.bb_pos,6);return r?(n||new t.experimental.fbs.SubGraphSessionState).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+r)+4*e),this.bb):null}subGraphSessionStatesLength(){let t=this.bb.__offset(this.bb_pos,6);return t?this.bb.__vector_len(this.bb_pos+t):0}static startSessionState(t){t.startObject(2)}static addKernels(t,e){t.addFieldOffset(0,e,0)}static addSubGraphSessionStates(t,e){t.addFieldOffset(1,e,0)}static createSubGraphSessionStatesVector(t,e){t.startVector(4,e.length,4);for(let n=e.length-1;n>=0;n--)t.addOffset(e[n]);return t.endVector()}static startSubGraphSessionStatesVector(t,e){t.startVector(4,e,4)}static endSessionState(t){return t.endObject()}static createSessionState(t,e,r){return n.startSessionState(t),n.addKernels(t,e),n.addSubGraphSessionStates(t,r),n.endSessionState(t)}}e.SessionState=n}(e.fbs||(e.fbs={}))}(t.experimental||(t.experimental={}))}(e.onnxruntime||(e.onnxruntime={})),function(t){!function(e){!function(e){class n{constructor(){this.bb=null,this.bb_pos=0}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsInferenceSession(t,e){return(e||new n).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsInferenceSession(t,e){return t.setPosition(t.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(e||new n).__init(t.readInt32(t.position())+t.position(),t)}static bufferHasIdentifier(t){return t.__has_identifier(\"ORTM\")}ortVersion(t){let e=this.bb.__offset(this.bb_pos,4);return e?this.bb.__string(this.bb_pos+e,t):null}model(e){let n=this.bb.__offset(this.bb_pos,6);return n?(e||new t.experimental.fbs.Model).__init(this.bb.__indirect(this.bb_pos+n),this.bb):null}sessionState(e){let n=this.bb.__offset(this.bb_pos,8);return n?(e||new t.experimental.fbs.SessionState).__init(this.bb.__indirect(this.bb_pos+n),this.bb):null}static startInferenceSession(t){t.startObject(3)}static addOrtVersion(t,e){t.addFieldOffset(0,e,0)}static addModel(t,e){t.addFieldOffset(1,e,0)}static addSessionState(t,e){t.addFieldOffset(2,e,0)}static endInferenceSession(t){return t.endObject()}static finishInferenceSessionBuffer(t,e){t.finish(e,\"ORTM\")}static finishSizePrefixedInferenceSessionBuffer(t,e){t.finish(e,\"ORTM\",!0)}static createInferenceSession(t,e,r,i){return n.startInferenceSession(t),n.addOrtVersion(t,e),n.addModel(t,r),n.addSessionState(t,i),n.endInferenceSession(t)}}e.InferenceSession=n}(e.fbs||(e.fbs={}))}(t.experimental||(t.experimental={}))}(e.onnxruntime||(e.onnxruntime={}))},7448:(t,e,n)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.OnnxjsSessionHandler=void 0;const r=n(1670),i=n(9162);e.OnnxjsSessionHandler=class{constructor(t){this.session=t,this.inputNames=this.session.inputNames,this.outputNames=this.session.outputNames}async dispose(){}async run(t,e,n){const o=new Map;for(const e in t)if(Object.hasOwnProperty.call(t,e)){const n=t[e];o.set(e,new i.Tensor(n.dims,n.type,void 0,void 0,n.data))}const a=await this.session.run(o),s={};return a.forEach(((t,e)=>{s[e]=new r.Tensor(t.type,t.data,t.dims)})),s}startProfiling(){this.session.startProfiling()}endProfiling(){this.session.endProfiling()}}},6919:(t,e,n)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.Session=void 0;const r=n(7067),i=n(1296),o=n(7091),a=n(1036),s=n(6231),u=n(2644);e.Session=class{constructor(t={}){this._initialized=!1,this.backendHint=t.backendHint,this.profiler=s.Profiler.create(t.profiler),this.context={profiler:this.profiler,graphInputTypes:[],graphInputDims:[]}}get inputNames(){return this._model.graph.getInputNames()}get outputNames(){return this._model.graph.getOutputNames()}startProfiling(){this.profiler.start()}endProfiling(){this.profiler.stop()}async loadModel(t,e,n){await this.profiler.event(\"session\",\"Session.loadModel\",(async()=>{const a=await(0,o.resolveBackend)(this.backendHint);if(this.sessionHandler=a.createSessionHandler(this.context),this._model=new u.Model,\"string\"==typeof t){const e=t.endsWith(\".ort\");if(\"undefined\"==typeof fetch){const n=await(0,i.promisify)(r.readFile)(t);this.initialize(n,e)}else{const n=await fetch(t),r=await n.arrayBuffer();this.initialize(new Uint8Array(r),e)}}else if(ArrayBuffer.isView(t))this.initialize(t);else{const r=new Uint8Array(t,e||0,n||t.byteLength);this.initialize(r)}}))}initialize(t,e){if(this._initialized)throw new Error(\"already initialized\");this.profiler.event(\"session\",\"Session.initialize\",(()=>{const n=this.sessionHandler.transformGraph?this.sessionHandler:void 0;this._model.load(t,n,e),this.sessionHandler.onGraphInitialized&&this.sessionHandler.onGraphInitialized(this._model.graph),this.initializeOps(this._model.graph),this._executionPlan=new a.ExecutionPlan(this._model.graph,this._ops,this.profiler)})),this._initialized=!0}async run(t){if(!this._initialized)throw new Error(\"session not initialized yet\");return this.profiler.event(\"session\",\"Session.run\",(async()=>{const e=this.normalizeAndValidateInputs(t),n=await this._executionPlan.execute(this.sessionHandler,e);return this.createOutput(n)}))}normalizeAndValidateInputs(t){const e=this._model.graph.getInputNames();if(Array.isArray(t)){if(t.length!==e.length)throw new Error(`incorrect input array length: expected ${e.length} but got ${t.length}`)}else{if(t.size!==e.length)throw new Error(`incorrect input map size: expected ${e.length} but got ${t.size}`);const n=new Array(t.size);let r=0;for(let i=0;i<e.length;++i){const o=t.get(e[i]);if(!o)throw new Error(`missing input tensor for: '${name}'`);n[r++]=o}t=n}if(this.context.graphInputTypes&&0!==this.context.graphInputTypes.length&&this.context.graphInputDims&&0!==this.context.graphInputDims.length)this.validateInputTensorDims(this.context.graphInputDims,t,!1);else{const e=this._model.graph.getInputIndices(),n=this._model.graph.getValues(),r=new Array(e.length);for(let i=0;i<e.length;++i){const o=n[e[i]];r[i]=o.type.shape.dims,this.context.graphInputTypes.push(o.type.tensorType),this.context.graphInputDims.push(t[i].dims)}this.validateInputTensorDims(r,t,!0)}return this.validateInputTensorTypes(this.context.graphInputTypes,t),t}validateInputTensorTypes(t,e){for(let n=0;n<e.length;n++){const r=t[n],i=e[n].type;if(r!==i)throw new Error(`input tensor[${n}] check failed: expected type '${r}' but got ${i}`)}}validateInputTensorDims(t,e,n){for(let r=0;r<e.length;r++){const i=t[r],o=e[r].dims;if(!this.compareTensorDims(i,o,n))throw new Error(`input tensor[${r}] check failed: expected shape '[${i.join(\",\")}]' but got [${o.join(\",\")}]`)}}compareTensorDims(t,e,n){if(t.length!==e.length)return!1;for(let r=0;r<t.length;++r)if(t[r]!==e[r]&&(!n||0!==t[r]))return!1;return!0}createOutput(t){const e=this._model.graph.getOutputNames();if(t.length!==e.length)throw new Error(\"expected number of outputs do not match number of generated outputs\");const n=new Map;for(let r=0;r<e.length;++r)n.set(e[r],t[r]);return n}initializeOps(t){const e=t.getNodes();this._ops=new Array(e.length);for(let n=0;n<e.length;n++)this._ops[n]=this.sessionHandler.resolve(e[n],this._model.opsets,t)}}},9162:function(t,e,n){\"use strict\";var r=this&&this.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(e,\"__esModule\",{value:!0}),e.Tensor=void 0;const i=n(3442),o=r(n(3720)),a=n(1446),s=n(9395),u=n(2517);var c=s.onnxruntime.experimental.fbs;class l{get data(){if(void 0===this.cache){const t=this.dataProvider(this.dataId);if(t.length!==this.size)throw new Error(\"Length of data provided by the Data Provider is inconsistent with the dims of this Tensor.\");this.cache=t}return this.cache}get stringData(){if(\"string\"!==this.type)throw new TypeError(\"data type is not string\");return this.data}get integerData(){switch(this.type){case\"uint8\":case\"int8\":case\"uint16\":case\"int16\":case\"int32\":case\"uint32\":case\"bool\":return this.data;default:throw new TypeError(\"data type is not integer (uint8, int8, uint16, int16, int32, uint32, bool)\")}}get floatData(){switch(this.type){case\"float32\":case\"float64\":return this.data;default:throw new TypeError(\"data type is not float (float32, float64)\")}}get numberData(){if(\"string\"!==this.type)return this.data;throw new TypeError(\"type cannot be non-number (string)\")}get(t){return this.data[u.ShapeUtil.indicesToOffset(t,this.strides)]}set(t,e){this.data[u.ShapeUtil.indicesToOffset(t,this.strides)]=e}async getData(){return void 0===this.cache&&(this.cache=await this.asyncDataProvider(this.dataId)),this.cache}get strides(){return this._strides||(this._strides=u.ShapeUtil.computeStrides(this.dims)),this._strides}constructor(t,e,n,r,o,a=i.Guid.create()){this.dims=t,this.type=e,this.dataProvider=n,this.asyncDataProvider=r,this.cache=o,this.dataId=a,this.size=u.ShapeUtil.validateDimsAndCalcSize(t);const s=this.size,c=void 0===n&&void 0===r&&void 0===o;if(void 0!==o&&o.length!==s)throw new RangeError(\"Input dims doesn't match data length.\");if(\"string\"===e){if(!(void 0===o||Array.isArray(o)&&o.every((t=>\"string\"==typeof t))))throw new TypeError(\"cache should be a string array\");c&&(this.cache=new Array(s))}else{if(void 0!==o){const t=f(e);if(!(o instanceof t))throw new TypeError(`cache should be type ${t.name}`)}if(c){const t=new ArrayBuffer(s*function(t){switch(t){case\"bool\":case\"int8\":case\"uint8\":return 1;case\"int16\":case\"uint16\":return 2;case\"int32\":case\"uint32\":case\"float32\":return 4;case\"float64\":return 8;default:throw new Error(`cannot calculate sizeof() on type ${t}`)}}(e));this.cache=function(t,e){return new(f(e))(t)}(t,e)}}}static fromProto(t){if(!t)throw new Error(\"cannot construct Value from an empty tensor\");const e=u.ProtoUtil.tensorDataTypeFromProto(t.dataType),n=u.ProtoUtil.tensorDimsFromProto(t.dims),r=new l(n,e);if(\"string\"===e)t.stringData.forEach(((t,e)=>{r.data[e]=(0,u.decodeUtf8String)(t)}));else if(t.rawData&&\"number\"==typeof t.rawData.byteLength&&t.rawData.byteLength>0){const e=r.data,n=new DataView(t.rawData.buffer,t.rawData.byteOffset,t.rawData.byteLength),i=p(t.dataType),o=t.rawData.byteLength/i;if(t.rawData.byteLength%i!=0)throw new Error(\"invalid buffer length\");if(e.length!==o)throw new Error(\"buffer length mismatch\");for(let r=0;r<o;r++){const o=h(n,t.dataType,r*i);e[r]=o}}else{let e;switch(t.dataType){case a.onnx.TensorProto.DataType.FLOAT:e=t.floatData;break;case a.onnx.TensorProto.DataType.INT32:case a.onnx.TensorProto.DataType.INT16:case a.onnx.TensorProto.DataType.UINT16:case a.onnx.TensorProto.DataType.INT8:case a.onnx.TensorProto.DataType.UINT8:case a.onnx.TensorProto.DataType.BOOL:e=t.int32Data;break;case a.onnx.TensorProto.DataType.INT64:e=t.int64Data;break;case a.onnx.TensorProto.DataType.DOUBLE:e=t.doubleData;break;case a.onnx.TensorProto.DataType.UINT32:case a.onnx.TensorProto.DataType.UINT64:e=t.uint64Data;break;default:throw new Error(\"unspecific error\")}if(null==e)throw new Error(\"failed to populate data from a tensorproto value\");const n=r.data;if(n.length!==e.length)throw new Error(\"array length mismatch\");for(let r=0;r<e.length;r++){const i=e[r];o.default.isLong(i)?n[r]=d(i,t.dataType):n[r]=i}}return r}static fromData(t,e,n){return new l(e,n,void 0,void 0,t)}static fromOrtTensor(t){if(!t)throw new Error(\"cannot construct Value from an empty tensor\");const e=u.ProtoUtil.tensorDimsFromORTFormat(t),n=u.ProtoUtil.tensorDataTypeFromProto(t.dataType()),r=new l(e,n);if(\"string\"===n)for(let e=0;e<t.stringDataLength();e++)r.data[e]=t.stringData(e);else if(t.rawDataArray()&&\"number\"==typeof t.rawDataLength()&&t.rawDataLength()>0){const e=r.data,n=new DataView(t.rawDataArray().buffer,t.rawDataArray().byteOffset,t.rawDataLength()),i=p(t.dataType()),o=t.rawDataLength()/i;if(t.rawDataLength()%i!=0)throw new Error(\"invalid buffer length\");if(e.length!==o)throw new Error(\"buffer length mismatch\");for(let r=0;r<o;r++){const o=h(n,t.dataType(),r*i);e[r]=o}}return r}}function p(t){switch(t){case a.onnx.TensorProto.DataType.UINT8:case a.onnx.TensorProto.DataType.INT8:case a.onnx.TensorProto.DataType.BOOL:return 1;case a.onnx.TensorProto.DataType.UINT16:case a.onnx.TensorProto.DataType.INT16:return 2;case a.onnx.TensorProto.DataType.FLOAT:case a.onnx.TensorProto.DataType.INT32:case a.onnx.TensorProto.DataType.UINT32:return 4;case a.onnx.TensorProto.DataType.INT64:case a.onnx.TensorProto.DataType.DOUBLE:case a.onnx.TensorProto.DataType.UINT64:return 8;default:throw new Error(`cannot calculate sizeof() on type ${a.onnx.TensorProto.DataType[t]}`)}}function f(t){switch(t){case\"bool\":case\"uint8\":return Uint8Array;case\"int8\":return Int8Array;case\"int16\":return Int16Array;case\"uint16\":return Uint16Array;case\"int32\":return Int32Array;case\"uint32\":return Uint32Array;case\"float32\":return Float32Array;case\"float64\":return Float64Array;default:throw new Error(\"unspecified error\")}}function d(t,e){if(e===a.onnx.TensorProto.DataType.INT64||e===c.TensorDataType.INT64){if(t.greaterThanOrEqual(2147483648)||t.lessThan(-2147483648))throw new TypeError(\"int64 is not supported\")}else{if(e!==a.onnx.TensorProto.DataType.UINT32&&e!==c.TensorDataType.UINT32&&e!==a.onnx.TensorProto.DataType.UINT64&&e!==c.TensorDataType.UINT64)throw new TypeError(`not a LONG type: ${a.onnx.TensorProto.DataType[e]}`);if(t.greaterThanOrEqual(4294967296)||t.lessThan(0))throw new TypeError(\"uint64 is not supported\")}return t.toNumber()}function h(t,e,n){switch(e){case a.onnx.TensorProto.DataType.BOOL:case a.onnx.TensorProto.DataType.UINT8:return t.getUint8(n);case a.onnx.TensorProto.DataType.INT8:return t.getInt8(n);case a.onnx.TensorProto.DataType.UINT16:return t.getUint16(n,!0);case a.onnx.TensorProto.DataType.INT16:return t.getInt16(n,!0);case a.onnx.TensorProto.DataType.FLOAT:return t.getFloat32(n,!0);case a.onnx.TensorProto.DataType.INT32:return t.getInt32(n,!0);case a.onnx.TensorProto.DataType.UINT32:return t.getUint32(n,!0);case a.onnx.TensorProto.DataType.INT64:return d(o.default.fromBits(t.getUint32(n,!0),t.getUint32(n+4,!0),!1),e);case a.onnx.TensorProto.DataType.DOUBLE:return t.getFloat64(n,!0);case a.onnx.TensorProto.DataType.UINT64:return d(o.default.fromBits(t.getUint32(n,!0),t.getUint32(n+4,!0),!0),e);default:throw new Error(`cannot read from DataView for type ${a.onnx.TensorProto.DataType[e]}`)}}e.Tensor=l},2517:function(t,e,n){\"use strict\";var r=this&&this.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(e,\"__esModule\",{value:!0}),e.decodeUtf8String=e.MAX_CLIP=e.MIN_CLIP=e.PoolConvUtil=e.ReduceUtil=e.SplitUtil=e.MathUtil=e.ShapeUtil=e.LongUtil=e.ProtoUtil=e.GemmUtil=e.arrayCopyHelper=e.BroadcastUtil=e.MatMulUtil=e.ArrayUtil=e.assert=e.checkInputsShape=void 0;const i=n(5686),o=r(n(3720)),a=n(1446),s=n(9162);e.checkInputsShape=function(t,...e){if(!t||t.length!==e.length)return!1;for(let n=0;n<t.length;n++)if(!t[n].dims||t[n].dims.length!==e[n])return!1;return!0},e.assert=function(t,e){if(!t)throw new Error(\"string\"==typeof e?e:e())},e.ArrayUtil=class{static arraysEqual(t,e){if(t.length!==e.length)return!1;for(let n=0;n<t.length;n++)if(t[n]!==e[n])return!1;return!0}};class u{static preprocessInputShapes(t,e){return[1===t.length?[1,t[0]]:t,1===e.length?[e[0],1]:e]}static postprocessOutputShape(t,e,n){1===e&&t.splice(t.length-2,1),1===n&&t.pop()}static calcMatMulShape(t,e){return t[1]!==e[0]?void 0:[t[0],e[1]]}}e.MatMulUtil=u;class c{static calcShape(t,e,n=!1){const r=t.length,i=e.length;if(0===r)return e;if(0===i)return t;const o=Math.max(t.length,e.length),a=new Array(o);if(n){if(r<2||i<2)return;const n=u.calcMatMulShape([t[r-2],t[r-1]],[e[i-2],e[i-1]]);if(void 0===n)return;[a[o-2],a[o-1]]=n}for(let s=n?3:1;s<=o;s++){const n=r-s<0?1:t[r-s],u=i-s<0?1:e[i-s];if(n!==u&&n>1&&u>1)return;a[o-s]=Math.max(n,u)}return a}static index(t,e){const n=new Array(e.length);return c.fillIndex(t,e,n),n}static fillIndex(t,e,n){const r=t.length-e.length;for(let i=0;i<e.length;i++)n[i]=t[r+i]%e[i]}static calc(t,e,n,r,i){const o=c.calcShape(t.dims,e.dims);if(o){if(r&&!f.areEqual(o,t.dims))return;const a=f.size(o),u=r?t:new s.Tensor(o,i||t.type);if(0===o.length)u.set([],n(t.get([]),e.get([])));else{const r=new Array(o.length),i=new Array(t.dims.length),s=new Array(e.dims.length);let l,p=0,f=0,d=!1,h=!1;0===t.dims.length&&(p=t.get([]),d=!0),0===e.dims.length&&(f=e.get([]),h=!0);for(let g=0;g<a;g++){l=g;for(let t=o.length-1;t>=0;t--)r[t]=l%o[t],l=Math.floor(l/o[t]);d||(c.fillIndex(r,t.dims,i),p=t.get(i)),h||(c.fillIndex(r,e.dims,s),f=e.get(s)),u.set(r,n(p,f))}}return u}}static isValidBroadcast(t,e){const n=t.length,r=e.length;if(n>r)return!1;for(let i=1;i<=n;i++)if(1!==t[n-i]&&t[n-i]!==e[r-i])return!1;return!0}static getBroadcastDims(t,e){const n=t.length,r=[];for(let i=0;i<n;i++){const o=n-1-i,a=t[o]||1;(e[e.length-1-i]||1)>1&&1===a&&r.unshift(o)}return r}}e.BroadcastUtil=c,e.arrayCopyHelper=function(t,e,n,r,i){if(r<0||r>=e.length)throw new Error(\"sourceIndex out of bounds\");if(n<0||n>=t.length)throw new Error(\"targetIndex out of bounds\");if(r+i>e.length)throw new Error(\"source indices to be copied are outside bounds\");if(n+i>t.length)throw new Error(\"target array is too small to hold result\");for(let o=0;o<i;o++)t[n+o]=e[r+o]},e.GemmUtil=class{static getShapeOfGemmResult(t,e,n,r,i){if(2!==t.length||2!==n.length)throw new Error(\"shape need to be of size 2\");let o,a,s;e?(o=t[1],a=t[0]):(o=t[0],a=t[1]);let u=-1;if(r?(s=n[0],u=1):(s=n[1],u=0),n[u]!==a)throw new Error(\"dimension mismatch\");if(o<=0||s<=0||a<=0)throw new Error(\"invalid shape specified\");if(i&&!c.isValidBroadcast(i,[o,s]))throw new Error(\"gemm: invalid bias shape for broadcast\");return[o,s,a]}};class l{static tensorDataTypeFromProto(t){switch(t){case a.onnx.TensorProto.DataType.INT8:return\"int8\";case a.onnx.TensorProto.DataType.UINT8:return\"uint8\";case a.onnx.TensorProto.DataType.BOOL:return\"bool\";case a.onnx.TensorProto.DataType.INT16:return\"int16\";case a.onnx.TensorProto.DataType.UINT16:return\"uint16\";case a.onnx.TensorProto.DataType.INT32:return\"int32\";case a.onnx.TensorProto.DataType.UINT32:return\"uint32\";case a.onnx.TensorProto.DataType.FLOAT:return\"float32\";case a.onnx.TensorProto.DataType.DOUBLE:return\"float64\";case a.onnx.TensorProto.DataType.STRING:return\"string\";case a.onnx.TensorProto.DataType.INT64:return\"int32\";case a.onnx.TensorProto.DataType.UINT64:return\"uint32\";default:throw new Error(`unsupported data type: ${a.onnx.TensorProto.DataType[t]}`)}}static tensorDataTypeStringToEnum(t){switch(t){case\"int8\":return a.onnx.TensorProto.DataType.INT8;case\"uint8\":return a.onnx.TensorProto.DataType.UINT8;case\"bool\":return a.onnx.TensorProto.DataType.BOOL;case\"int16\":return a.onnx.TensorProto.DataType.INT16;case\"uint16\":return a.onnx.TensorProto.DataType.UINT16;case\"int32\":return a.onnx.TensorProto.DataType.INT32;case\"uint32\":return a.onnx.TensorProto.DataType.UINT32;case\"float32\":return a.onnx.TensorProto.DataType.FLOAT;case\"float64\":return a.onnx.TensorProto.DataType.DOUBLE;case\"string\":return a.onnx.TensorProto.DataType.STRING;case\"int64\":return a.onnx.TensorProto.DataType.INT64;case\"uint64\":return a.onnx.TensorProto.DataType.UINT64;default:throw new Error(`unsupported data type: ${t}`)}}static tensorDimsFromProto(t){return t.map((t=>o.default.isLong(t)?t.toNumber():t))}static tensorValueTypeFromProto(t){return{tensorType:l.tensorDataTypeFromProto(t.elemType),shape:{dims:l.tensorDimsFromProto(t.shape.dim.map((t=>t.dimValue)))}}}static tensorDimsFromORTFormat(t){const e=[];for(let n=0;n<t.dimsLength();n++)e.push(p.longToNumber(t.dims(n)));return e}static tensorAttributesFromORTFormat(t){const e=[];for(let n=0;n<t.attributesLength();n++)e.push(t.attributes(n));return e}}e.ProtoUtil=l;class p{static longToNumber(t,e){return o.default.isLong(t)?t.toNumber():t instanceof i.flatbuffers.Long?o.default.fromValue({low:t.low,high:t.high,unsigned:null!=e&&e}).toNumber():t}static isLong(t){return o.default.isLong(t)||t instanceof i.flatbuffers.Long}}e.LongUtil=p;class f{static size(t){return f.getSizeFromDimensionRange(t,0,t.length)}static sizeFromDimension(t,e){if(e<0||e>t.length)throw new Error(`invalid dimension of ${e} for sizeFromDimension as Tensor has ${t.length} dimensions.`);return f.getSizeFromDimensionRange(t,e,t.length)}static sizeToDimension(t,e){if(e<0||e>t.length)throw new Error(`invalid dimension of ${e} for sizeToDimension as Tensor has ${t.length} dimensions.`);return f.getSizeFromDimensionRange(t,0,e)}static getSizeFromDimensionRange(t,e,n){let r=1;for(let i=e;i<n;i++){if(t[i]<=0)throw new Error(\"cannot get valid size from specified dimension range. Most likely the range contains 0 or negative values in them.\");r*=t[i]}return r}static computeStrides(t){const e=t.length;if(0===e)return[];if(1===e)return[1];const n=new Array(e);n[e-1]=1,n[e-2]=t[e-1];for(let r=e-3;r>=0;--r)n[r]=n[r+1]*t[r+1];return n}static transpose(t){return t.slice().reverse()}static indicesToOffset(t,e,n){void 0===n&&(n=t.length);let r=0;for(let i=0;i<n;++i)r+=e[i]*t[i];return r}static offsetToIndices(t,e){const n=e.length;if(0===n)return[];if(1===n)return[t*e[0]];const r=new Array(e.length);for(let n=0;n<r.length-1;++n)r[n]=Math.floor(t/e[n]),t-=r[n]*e[n];return r[r.length-1]=t,r}static normalizeAxis(t,e){if(t<-e&&t>=e)throw new Error(\"unsupported axis for this operation.\");return t<0?t+e:t}static normalizeAxes(t,e){return t.map((t=>this.normalizeAxis(t,e)))}static incrementIndex(t,e,n){if(0===e.length||0===t.length)throw new Error(\"Index incrementing unsupported for scalar Tensor\");if(void 0===n)n=e.length;else if(n<=0||n>e.length)throw new Error(\"Incorrect axis to increment on\");for(let r=n-1;r>=0&&(t[r]++,!(t[r]<e[r]));--r)t[r]=0}static calculateReshapedDims(t,e){if(0===e.length){if(0===t.length||1===f.size(t))return[];throw new Error(\"cannot reshape to a scalar Tensor\")}const n=e.length,r=new Array(n);let i=-1,o=1;for(let a=0;a<n;a++){if(e[a]<-1)throw new Error(\"a dimension in shape hints cannot be less than -1\");if(-1===e[a]){if(-1!==i)throw new Error(\"at most one dimension in shape hints can be -1\");i=a}else{if(0===e[a]){if(a>=t.length)throw new Error(\"the dimension with value zero exceeds the dimension size of the input tensor\");r[a]=t[a]}else r[a]=e[a];o*=r[a]}}const a=f.size(t);if(-1!==i){if(a%o!=0)throw new Error(`the input tensor cannot be reshaped to the requested shape. Input shape: [${t}] Output shape: [${e}]`);r[i]=a/o}else if(o!==a)throw new Error(\"reshapedDims and originalDims don't have matching sizes\");return r}static sortBasedOnPerm(t,e){return e?e.map((e=>t[e])):t.slice().reverse()}static padShape(t,e){const n=t.length;return t.map(((t,r)=>t+e[r]+e[r+n]))}static areEqual(t,e){return t.length===e.length&&t.every(((t,n)=>t===e[n]))}static validateDimsAndCalcSize(t){if(t.length>6)throw new TypeError(\"Only rank 0 to 6 is supported for tensor shape.\");let e=1;for(const n of t){if(!Number.isInteger(n))throw new TypeError(`Invalid shape: ${n} is not an integer`);if(n<0||n>2147483647)throw new TypeError(`Invalid shape: length ${n} is not allowed`);e*=n}return e}static flattenShape(t,e){e<0&&(e+=t.length);const n=t.reduce(((t,e)=>t*e),1),r=t.slice(e).reduce(((t,e)=>t*e),1);return[n/r,r]}static squeezeShape(t,e){const n=new Array;e=f.normalizeAxes(e,t.length);for(let r=0;r<t.length;r++){const i=e.indexOf(r)>=0;if(i&&1!==t[r])throw new Error(\"squeeze an axis of size different than 1\");(0===e.length&&t[r]>1||e.length>0&&!i)&&n.push(t[r])}return n}static unsqueezeShape(t,e){const n=new Array(t.length+e.length);n.fill(0);for(let t=0;t<e.length;t++){const r=f.normalizeAxis(e[t],n.length);if(r>=n.length)throw new Error(\"'axes' has an out of range axis\");if(0!==n[r])throw new Error(\"'axes' has a duplicate axis\");n[r]=1}let r=0;for(let e=0;e<n.length;e++)0===n[e]&&(n[e]=t[r++]);if(r!==t.length)throw new Error(\"the unsqueezed dimension could not be established\");return n}}e.ShapeUtil=f,e.MathUtil=class{static sqr(t,e,n,r,i){if(r<0||r>=e.length)throw new Error(\"sourceIndex out of bounds\");if(n<0||n>=t.length)throw new Error(\"targetIndex out of bounds\");if(r+i>e.length)throw new Error(\"source indices to be copied are outside bounds\");if(n+i>t.length)throw new Error(\"target array is too small to hold result\");for(let o=0;o<i;o++)t[n+o]+=Math.pow(e[r+o],2)}static axpy(t,e,n,r,i,o){if(r<0||r>=e.length)throw new Error(\"sourceIndex out of bounds\");if(n<0||n>=t.length)throw new Error(\"targetIndex out of bounds\");if(r+i>e.length)throw new Error(\"source indices to be copied are outside bounds\");if(n+i>t.length)throw new Error(\"target array is too small to hold result\");for(let a=0;a<i;a++)t[n+a]+=o*e[r+a]}static powx(t,e,n,r,i,o){if(r<0||r>=e.length)throw new Error(\"sourceIndex out of bounds\");if(n<0||n>=t.length)throw new Error(\"targetIndex out of bounds\");if(r+i>e.length)throw new Error(\"source indices to be copied are outside bounds\");if(n+i>t.length)throw new Error(\"target array is too small to hold result\");for(let a=0;a<i;a++)t[n+a]=Math.pow(e[r+a],o)}static mul(t,e,n,r,i){if(r<0||r>=e.length)throw new Error(\"sourceIndex out of bounds\");if(n<0||n>=t.length)throw new Error(\"targetIndex out of bounds\");if(r+i>e.length)throw new Error(\"source indices to be copied are outside bounds\");if(n+i>t.length)throw new Error(\"target array is too small to hold result\");for(let o=0;o<i;o++)t[n+o]=e[r+o]*t[n+o]}};class d{static splitShape(t,e,n,r){if(0===n.length){if(!r)throw new Error(\"need to know number of outputs when the 'split' attribute is not specified\");d.determineSplit(t[e],r,n)}const i=[],o=[0];for(let r=0;r<n.length;++r){0!==r&&o.push(o[r-1]+n[r-1]);const a=t.slice();a[e]=n[r],i.push(a)}return[i,o]}static determineSplit(t,e,n){if(t%e!=0)throw new Error(\"cannot split tensor to equal sized parts\");for(let r=0;r<e;++r)n.push(t/e)}}e.SplitUtil=d;class h{static calcReduce(t,e,n,r,i){const o=t.dims.slice(0);0===e.length&&o.forEach(((t,n)=>e.push(n)));const a=h.calcReduceShape(o,e,!0),u=f.size(a),l=new s.Tensor(a,t.type),p=f.computeStrides(a),d=f.computeStrides(o),g=new Array(o.length);for(let n=0;n<u;n++){const a=f.offsetToIndices(n,p);c.fillIndex(a,o,g),l.set(a,h.calcReduceByAxis(t.numberData,e,o,0,f.indicesToOffset(g,d),r,i))}return n?l:new s.Tensor(h.calcReduceShape(o,e,n),l.type,void 0,void 0,l.data,l.dataId)}static calcReduceByAxis(t,e,n,r,i,o,a){let s=0;if(r>=e.length)return o(t[i]);const u=e[r],c=u>=n.length?1:f.size(n.slice(u+1));for(let l=0;l<n[u];l++)s=0===l?h.calcReduceByAxis(t,e,n,r+1,i,o,a):a(s,h.calcReduceByAxis(t,e,n,r+1,i,o,a)),i+=c;return s}static calcReduceShape(t,e,n){const r=t.slice();for(let t=0;t<e.length;t++)r[e[t]]=n?1:0;return r.filter((t=>0!==t))}}e.ReduceUtil=h;class g{static adjustPoolAttributes(t,e,n,r,i,o){if(!t&&n.length!==e.length-2)throw new Error(\"length of specified kernel shapes should be 2 less than length of input dimensions\");if(t)for(let t=0;t<e.length-2;t++)t>=n.length?n.push(e[t+2]):n[t]=e[t+2];for(let t=0;t<n.length;t++)if(t<r.length){if(r[t]<0)throw new Error(\"strides should be greater than or equal to 1\")}else r.push(1);for(let t=0;t<n.length;t++)if(t<i.length){if(i[t]<0)throw new Error(\"dilations should be greater than or equal to 1\")}else i.push(1);for(let t=0;t<2*n.length;t++)if(t<o.length){if(o[t]<0)throw new Error(\"pad should be greater than or equal to 1\")}else o.push(0);for(let t=0;t<n.length;t++){if(n[t]<=0)throw new Error(\"kernel shapes need to be greater than 0\");if(o[t]>=n[t]||o[t+n.length]>=n[t])throw new Error(\"pads should be smaller than kernel\")}}static adjustPadsBasedOnAutoPad(t,e,n,r,i,o){if(o){if(i.length!==2*(t.length-2))throw new Error(\"length of pads should be twice the length of data dimensions\");if(e.length!==t.length-2)throw new Error(\"length of strides should be the length of data dimensions\");if(r.length!==t.length-2)throw new Error(\"length of kernel shapes should be the length of data dimensions\");for(let a=0;a<t.length-2;a++)g.adjustPadAndReturnShape(t[a+2],e[a],n[a],r[a],i,a,a+t.length-2,o)}}static computePoolOutputShape(t,e,n,r,i,o,a){if(e.length<=0)throw new Error(\"input shape must be of size greater than 0\");const s=[e[0],e[1]];return g.computeShapeHelper(t,e,s,n,r,i,o,a),s}static computeConvOutputShape(t,e,n,r,i,o,a){if(t.length<=0||e.length<=0)throw new Error(\"invalid input tensor dims or invalid filter tensor dims\");const s=[t[0],e[0]];return g.computeShapeHelper(!1,t,s,n,r,i,o,a),s}static computeShapeHelper(t,e,n,r,i,o,a,s){if(t)for(let t=0;t<e.length-2;t++)n.push(1);else for(let t=0;t<e.length-2;t++)n.push(g.adjustPadAndReturnShape(e[t+2],r[t],i[t],o[t],a,t,t+e.length-2,s))}static adjustPadAndReturnShape(t,e,n,r,i,o,a,s){const u=n*(r-1)+1;if(!s||\"NOTSET\"===s)return Math.floor((t+i[o]+i[a]-u)/e+1);switch(s){case\"VALID\":return i[o]=0,i[a]=0,Math.floor((t-u)/e+1);case\"SAME_LOWER\":case\"SAME_UPPER\":if(1!==n)throw new Error(\"Dilation not supported for SAME_UPPER or SAME_LOWER\");{const n=((t+e-1)/e-1)*e+r-t;return i[o]=\"SAME_LOWER\"===s?Math.floor((n+1)/2):Math.floor(n/2),i[a]=n-i[o],Math.floor((t+n-r)/e+1)}default:throw new Error(\"Unsupported AutoPad type\")}}}e.PoolConvUtil=g,e.MIN_CLIP=-34028234663852886e22,e.MAX_CLIP=34028234663852886e22,e.decodeUtf8String=function(t){return(new TextDecoder).decode(t)}},7967:(t,e)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.iterateExtraOptions=void 0,e.iterateExtraOptions=(t,n,r,i)=>{if(\"object\"==typeof t&&null!==t){if(r.has(t))throw new Error(\"Circular reference in options\");r.add(t)}Object.entries(t).forEach((([t,o])=>{const a=n?n+t:t;if(\"object\"==typeof o)(0,e.iterateExtraOptions)(o,a+\".\",r,i);else if(\"string\"==typeof o||\"number\"==typeof o)i(a,o.toString());else{if(\"boolean\"!=typeof o)throw new Error(\"Can't handle extra config type: \"+typeof o);i(a,o?\"1\":\"0\")}}))}},2157:function(t,e,n){\"use strict\";var r,i=this&&this.__createBinding||(Object.create?function(t,e,n,r){void 0===r&&(r=n);var i=Object.getOwnPropertyDescriptor(e,n);i&&!(\"get\"in i?!e.__esModule:i.writable||i.configurable)||(i={enumerable:!0,get:function(){return e[n]}}),Object.defineProperty(t,r,i)}:function(t,e,n,r){void 0===r&&(r=n),t[r]=e[n]}),o=this&&this.__setModuleDefault||(Object.create?function(t,e){Object.defineProperty(t,\"default\",{enumerable:!0,value:e})}:function(t,e){t.default=e}),a=this&&this.__importStar||function(t){if(t&&t.__esModule)return t;var e={};if(null!=t)for(var n in t)\"default\"!==n&&Object.prototype.hasOwnProperty.call(t,n)&&i(e,t,n);return o(e,t),e};Object.defineProperty(e,\"__esModule\",{value:!0}),e.endProfiling=e.run=e.releaseSession=e.createSession=e.createSessionFinalize=e.createSessionAllocate=e.initOrt=e.initWasm=void 0;const s=n(1670),u=a(n(349)),c=n(6361),l=()=>!!s.env.wasm.proxy&&\"undefined\"!=typeof document;let p,f,d,h=!1,g=!1,b=!1;const m=[],y=[],_=[],v=[],w=[],x=[],T=()=>{if(h||!g||b||!p)throw new Error(\"worker not ready\")},S=t=>{switch(t.data.type){case\"init-wasm\":h=!1,t.data.err?(b=!0,f[1](t.data.err)):(g=!0,f[0]());break;case\"init-ort\":t.data.err?d[1](t.data.err):d[0]();break;case\"create_allocate\":t.data.err?m.shift()[1](t.data.err):m.shift()[0](t.data.out);break;case\"create_finalize\":t.data.err?y.shift()[1](t.data.err):y.shift()[0](t.data.out);break;case\"create\":t.data.err?_.shift()[1](t.data.err):_.shift()[0](t.data.out);break;case\"release\":t.data.err?v.shift()[1](t.data.err):v.shift()[0]();break;case\"run\":t.data.err?w.shift()[1](t.data.err):w.shift()[0](t.data.out);break;case\"end-profiling\":t.data.err?x.shift()[1](t.data.err):x.shift()[0]()}},O=\"undefined\"!=typeof document?null===(r=null===document||void 0===document?void 0:document.currentScript)||void 0===r?void 0:r.src:void 0;e.initWasm=async()=>{if(l()){if(g)return;if(h)throw new Error(\"multiple calls to 'initWasm()' detected.\");if(b)throw new Error(\"previous call to 'initWasm()' failed.\");return h=!0,void 0===s.env.wasm.wasmPaths&&O&&0!==O.indexOf(\"blob:\")&&(s.env.wasm.wasmPaths=O.substr(0,+O.lastIndexOf(\"/\")+1)),new Promise(((t,e)=>{null==p||p.terminate(),p=n(9710).Z(),p.onmessage=S,f=[t,e];const r={type:\"init-wasm\",in:s.env.wasm};p.postMessage(r)}))}return(0,c.initializeWebAssembly)(s.env.wasm)},e.initOrt=async(t,e)=>{if(l())return T(),new Promise(((n,r)=>{d=[n,r];const i={type:\"init-ort\",in:{numThreads:t,loggingLevel:e}};p.postMessage(i)}));u.initOrt(t,e)},e.createSessionAllocate=async t=>l()?(T(),new Promise(((e,n)=>{m.push([e,n]);const r={type:\"create_allocate\",in:{model:t}};p.postMessage(r,[t.buffer])}))):u.createSessionAllocate(t),e.createSessionFinalize=async(t,e)=>l()?(T(),new Promise(((n,r)=>{y.push([n,r]);const i={type:\"create_finalize\",in:{modeldata:t,options:e}};p.postMessage(i)}))):u.createSessionFinalize(t,e),e.createSession=async(t,e)=>l()?(T(),new Promise(((n,r)=>{_.push([n,r]);const i={type:\"create\",in:{model:t,options:e}};p.postMessage(i,[t.buffer])}))):u.createSession(t,e),e.releaseSession=async t=>{if(l())return T(),new Promise(((e,n)=>{v.push([e,n]);const r={type:\"release\",in:t};p.postMessage(r)}));u.releaseSession(t)},e.run=async(t,e,n,r,i)=>l()?(T(),new Promise(((o,a)=>{w.push([o,a]);const s={type:\"run\",in:{sessionId:t,inputIndices:e,inputs:n,outputIndices:r,options:i}};p.postMessage(s,u.extractTransferableBuffers(n))}))):u.run(t,e,n,r,i),e.endProfiling=async t=>{if(l())return T(),new Promise(((e,n)=>{x.push([e,n]);const r={type:\"end-profiling\",in:t};p.postMessage(r)}));u.endProfiling(t)}},586:(t,e,n)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.setRunOptions=void 0;const r=n(7967),i=n(4983),o=n(6361);e.setRunOptions=t=>{const e=(0,o.getInstance)();let n=0;const a=[],s=t||{};try{if(void 0===(null==t?void 0:t.logSeverityLevel))s.logSeverityLevel=2;else if(\"number\"!=typeof t.logSeverityLevel||!Number.isInteger(t.logSeverityLevel)||t.logSeverityLevel<0||t.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${t.logSeverityLevel}`);if(void 0===(null==t?void 0:t.logVerbosityLevel))s.logVerbosityLevel=0;else if(\"number\"!=typeof t.logVerbosityLevel||!Number.isInteger(t.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${t.logVerbosityLevel}`);void 0===(null==t?void 0:t.terminate)&&(s.terminate=!1);let o=0;if(void 0!==(null==t?void 0:t.tag)&&(o=(0,i.allocWasmString)(t.tag,a)),n=e._OrtCreateRunOptions(s.logSeverityLevel,s.logVerbosityLevel,!!s.terminate,o),0===n)throw new Error(\"Can't create run options\");return void 0!==(null==t?void 0:t.extra)&&(0,r.iterateExtraOptions)(t.extra,\"\",new WeakSet,((t,r)=>{const o=(0,i.allocWasmString)(t,a),s=(0,i.allocWasmString)(r,a);if(0!==e._OrtAddRunConfigEntry(n,o,s))throw new Error(`Can't set a run config entry: ${t} - ${r}`)})),[n,a]}catch(t){throw 0!==n&&e._OrtReleaseRunOptions(n),a.forEach(e._free),t}}},2306:(t,e,n)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.OnnxruntimeWebAssemblySessionHandler=void 0;const r=n(2806),i=n(1670),o=n(2850),a=n(2157);let s;e.OnnxruntimeWebAssemblySessionHandler=class{async createSessionAllocate(t){const e=await fetch(t),n=await e.arrayBuffer();return(0,a.createSessionAllocate)(new Uint8Array(n))}async loadModel(t,e){if(s||(await(0,a.initOrt)(i.env.wasm.numThreads,(t=>{switch(t){case\"verbose\":return 0;case\"info\":return 1;case\"warning\":return 2;case\"error\":return 3;case\"fatal\":return 4;default:throw new Error(`unsupported logging level: ${t}`)}})(i.env.logLevel)),s=!0),\"string\"==typeof t)if(\"undefined\"==typeof fetch){const n=await(0,o.promisify)(r.readFile)(t);[this.sessionId,this.inputNames,this.outputNames]=await(0,a.createSession)(n,e)}else{const n=await this.createSessionAllocate(t);[this.sessionId,this.inputNames,this.outputNames]=await(0,a.createSessionFinalize)(n,e)}else[this.sessionId,this.inputNames,this.outputNames]=await(0,a.createSession)(t,e)}async dispose(){return(0,a.releaseSession)(this.sessionId)}async run(t,e,n){const r=[],o=[];Object.entries(t).forEach((t=>{const e=t[0],n=t[1],i=this.inputNames.indexOf(e);if(-1===i)throw new Error(`invalid input '${e}'`);r.push(n),o.push(i)}));const s=[];Object.entries(e).forEach((t=>{const e=t[0],n=this.outputNames.indexOf(e);if(-1===n)throw new Error(`invalid output '${e}'`);s.push(n)}));const u=await(0,a.run)(this.sessionId,o,r.map((t=>[t.type,t.dims,t.data])),s,n),c={};for(let t=0;t<u.length;t++)c[this.outputNames[s[t]]]=new i.Tensor(u[t][0],u[t][2],u[t][1]);return c}startProfiling(){}endProfiling(){(0,a.endProfiling)(this.sessionId)}}},4919:(t,e,n)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.setSessionOptions=void 0;const r=n(7967),i=n(4983),o=n(6361);e.setSessionOptions=t=>{const e=(0,o.getInstance)();let n=0;const a=[],s=t||{};(t=>{t.extra||(t.extra={}),t.extra.session||(t.extra.session={});const e=t.extra.session;e.use_ort_model_bytes_directly||(e.use_ort_model_bytes_directly=\"1\")})(s);try{void 0===(null==t?void 0:t.graphOptimizationLevel)&&(s.graphOptimizationLevel=\"all\");const u=(t=>{switch(t){case\"disabled\":return 0;case\"basic\":return 1;case\"extended\":return 2;case\"all\":return 99;default:throw new Error(`unsupported graph optimization level: ${t}`)}})(s.graphOptimizationLevel);void 0===(null==t?void 0:t.enableCpuMemArena)&&(s.enableCpuMemArena=!0),void 0===(null==t?void 0:t.enableMemPattern)&&(s.enableMemPattern=!0),void 0===(null==t?void 0:t.executionMode)&&(s.executionMode=\"sequential\");const c=(t=>{switch(t){case\"sequential\":return 0;case\"parallel\":return 1;default:throw new Error(`unsupported execution mode: ${t}`)}})(s.executionMode);let l=0;if(void 0!==(null==t?void 0:t.logId)&&(l=(0,i.allocWasmString)(t.logId,a)),void 0===(null==t?void 0:t.logSeverityLevel))s.logSeverityLevel=2;else if(\"number\"!=typeof t.logSeverityLevel||!Number.isInteger(t.logSeverityLevel)||t.logSeverityLevel<0||t.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${t.logSeverityLevel}`);if(void 0===(null==t?void 0:t.logVerbosityLevel))s.logVerbosityLevel=0;else if(\"number\"!=typeof t.logVerbosityLevel||!Number.isInteger(t.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${t.logVerbosityLevel}`);if(void 0===(null==t?void 0:t.enableProfiling)&&(s.enableProfiling=!1),n=e._OrtCreateSessionOptions(u,!!s.enableCpuMemArena,!!s.enableMemPattern,c,!!s.enableProfiling,0,l,s.logSeverityLevel,s.logVerbosityLevel),0===n)throw new Error(\"Can't create session options\");return(null==t?void 0:t.executionProviders)&&((t,e,n)=>{for(const r of e){let e=\"string\"==typeof r?r:r.name;switch(e){case\"xnnpack\":e=\"XNNPACK\";break;case\"wasm\":case\"cpu\":continue;default:throw new Error(`not supported EP: ${e}`)}const a=(0,i.allocWasmString)(e,n);if(0!==(0,o.getInstance)()._OrtAppendExecutionProvider(t,a))throw new Error(`Can't append execution provider: ${e}`)}})(n,t.executionProviders,a),void 0!==(null==t?void 0:t.extra)&&(0,r.iterateExtraOptions)(t.extra,\"\",new WeakSet,((t,r)=>{const o=(0,i.allocWasmString)(t,a),s=(0,i.allocWasmString)(r,a);if(0!==e._OrtAddSessionConfigEntry(n,o,s))throw new Error(`Can't set a session config entry: ${t} - ${r}`)})),[n,a]}catch(t){throw 0!==n&&e._OrtReleaseSessionOptions(n),a.forEach(e._free),t}}},4983:(t,e,n)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.allocWasmString=void 0;const r=n(6361);e.allocWasmString=(t,e)=>{const n=(0,r.getInstance)(),i=n.lengthBytesUTF8(t)+1,o=n._malloc(i);return n.stringToUTF8(t,o,i),e.push(o),o}},349:(t,e,n)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.extractTransferableBuffers=e.endProfiling=e.run=e.releaseSession=e.createSession=e.createSessionFinalize=e.createSessionAllocate=e.initOrt=void 0;const r=n(586),i=n(4919),o=n(4983),a=n(6361);e.initOrt=(t,e)=>{const n=(0,a.getInstance)()._OrtInit(t,e);if(0!==n)throw new Error(`Can't initialize onnxruntime. error code = ${n}`)};const s=new Map;e.createSessionAllocate=t=>{const e=(0,a.getInstance)(),n=e._malloc(t.byteLength);return e.HEAPU8.set(t,n),[n,t.byteLength]},e.createSessionFinalize=(t,e)=>{const n=(0,a.getInstance)();let r=0,o=0,u=[];try{if([o,u]=(0,i.setSessionOptions)(e),r=n._OrtCreateSession(t[0],t[1],o),0===r)throw new Error(\"Can't create a session\")}finally{n._free(t[0]),n._OrtReleaseSessionOptions(o),u.forEach(n._free)}const c=n._OrtGetInputCount(r),l=n._OrtGetOutputCount(r),p=[],f=[],d=[],h=[];for(let t=0;t<c;t++){const e=n._OrtGetInputName(r,t);if(0===e)throw new Error(\"Can't get an input name\");f.push(e),p.push(n.UTF8ToString(e))}for(let t=0;t<l;t++){const e=n._OrtGetOutputName(r,t);if(0===e)throw new Error(\"Can't get an output name\");h.push(e),d.push(n.UTF8ToString(e))}return s.set(r,[r,f,h]),[r,p,d]},e.createSession=(t,n)=>{const r=(0,e.createSessionAllocate)(t);return(0,e.createSessionFinalize)(r,n)},e.releaseSession=t=>{const e=(0,a.getInstance)(),n=s.get(t);if(!n)throw new Error(\"invalid session id\");const r=n[0],i=n[1],o=n[2];i.forEach(e._OrtFree),o.forEach(e._OrtFree),e._OrtReleaseSession(r),s.delete(t)};const u=t=>{switch(t){case\"int8\":return 3;case\"uint8\":return 2;case\"bool\":return 9;case\"int16\":return 5;case\"uint16\":return 4;case\"int32\":return 6;case\"uint32\":return 12;case\"float32\":return 1;case\"float64\":return 11;case\"string\":return 8;case\"int64\":return 7;case\"uint64\":return 13;default:throw new Error(`unsupported data type: ${t}`)}},c=t=>{switch(t){case 3:return\"int8\";case 2:return\"uint8\";case 9:return\"bool\";case 5:return\"int16\";case 4:return\"uint16\";case 6:return\"int32\";case 12:return\"uint32\";case 1:return\"float32\";case 11:return\"float64\";case 8:return\"string\";case 7:return\"int64\";case 13:return\"uint64\";default:throw new Error(`unsupported data type: ${t}`)}},l=t=>{switch(t){case\"float32\":return Float32Array;case\"uint8\":case\"bool\":return Uint8Array;case\"int8\":return Int8Array;case\"uint16\":return Uint16Array;case\"int16\":return Int16Array;case\"int32\":return Int32Array;case\"float64\":return Float64Array;case\"uint32\":return Uint32Array;case\"int64\":return BigInt64Array;case\"uint64\":return BigUint64Array;default:throw new Error(`unsupported type: ${t}`)}};e.run=(t,e,n,i,p)=>{const f=(0,a.getInstance)(),d=s.get(t);if(!d)throw new Error(\"invalid session id\");const h=d[0],g=d[1],b=d[2],m=e.length,y=i.length;let _=0,v=[];const w=[],x=[];try{[_,v]=(0,r.setRunOptions)(p);for(let t=0;t<m;t++){const e=n[t][0],r=n[t][1],i=n[t][2];let a,s;if(Array.isArray(i)){s=4*i.length,a=f._malloc(s),x.push(a);let t=a/4;for(let e=0;e<i.length;e++){if(\"string\"!=typeof i[e])throw new TypeError(`tensor data at index ${e} is not a string`);f.HEAPU32[t++]=(0,o.allocWasmString)(i[e],x)}}else s=i.byteLength,a=f._malloc(s),x.push(a),f.HEAPU8.set(new Uint8Array(i.buffer,i.byteOffset,s),a);const c=f.stackSave(),l=f.stackAlloc(4*r.length);try{let t=l/4;r.forEach((e=>f.HEAP32[t++]=e));const n=f._OrtCreateTensor(u(e),a,s,l,r.length);if(0===n)throw new Error(\"Can't create a tensor\");w.push(n)}finally{f.stackRestore(c)}}const t=f.stackSave(),a=f.stackAlloc(4*m),s=f.stackAlloc(4*m),d=f.stackAlloc(4*y),T=f.stackAlloc(4*y);try{let n=a/4,r=s/4,o=d/4,u=T/4;for(let t=0;t<m;t++)f.HEAPU32[n++]=w[t],f.HEAPU32[r++]=g[e[t]];for(let t=0;t<y;t++)f.HEAPU32[o++]=0,f.HEAPU32[u++]=b[i[t]];let p=f._OrtRun(h,s,a,m,T,y,d,_);const v=[];if(0===p)for(let t=0;t<y;t++){const e=f.HEAPU32[d/4+t],n=f.stackSave(),r=f.stackAlloc(16);let i,o=0;try{if(p=f._OrtGetTensorData(e,r,r+4,r+8,r+12),0!==p)throw new Error(`Can't access output tensor data. error code = ${p}`);let t=r/4;const a=f.HEAPU32[t++];o=f.HEAPU32[t++];const s=f.HEAPU32[t++],u=f.HEAPU32[t++],d=[];for(let t=0;t<u;t++)d.push(f.HEAPU32[s/4+t]);f._OrtFree(s);const h=0===d.length?1:d.reduce(((t,e)=>t*e));if(i=c(a),\"string\"===i){const t=[];let e=o/4;for(let n=0;n<h;n++){const r=f.HEAPU32[e++],i=n===h-1?void 0:f.HEAPU32[e]-r;t.push(f.UTF8ToString(r,i))}v.push([i,d,t])}else{const t=new(l(i))(h);new Uint8Array(t.buffer,t.byteOffset,t.byteLength).set(f.HEAPU8.subarray(o,o+t.byteLength)),v.push([i,d,t])}}finally{f.stackRestore(n),\"string\"===i&&o&&f._free(o),f._OrtReleaseTensor(e)}}if(0===p)return v;throw new Error(`failed to call OrtRun(). error code = ${p}.`)}finally{f.stackRestore(t)}}finally{w.forEach(f._OrtReleaseTensor),x.forEach(f._free),f._OrtReleaseRunOptions(_),v.forEach(f._free)}},e.endProfiling=t=>{const e=(0,a.getInstance)(),n=s.get(t);if(!n)throw new Error(\"invalid session id\");const r=n[0],i=e._OrtEndProfiling(r);if(0===i)throw new Error(\"Can't get an profile file name\");e._OrtFree(i)},e.extractTransferableBuffers=t=>{const e=[];for(const n of t){const t=n[2];!Array.isArray(t)&&t.buffer&&e.push(t.buffer)}return e}},6361:function(t,e,n){\"use strict\";var r=this&&this.__createBinding||(Object.create?function(t,e,n,r){void 0===r&&(r=n);var i=Object.getOwnPropertyDescriptor(e,n);i&&!(\"get\"in i?!e.__esModule:i.writable||i.configurable)||(i={enumerable:!0,get:function(){return e[n]}}),Object.defineProperty(t,r,i)}:function(t,e,n,r){void 0===r&&(r=n),t[r]=e[n]}),i=this&&this.__setModuleDefault||(Object.create?function(t,e){Object.defineProperty(t,\"default\",{enumerable:!0,value:e})}:function(t,e){t.default=e}),o=this&&this.__importStar||function(t){if(t&&t.__esModule)return t;var e={};if(null!=t)for(var n in t)\"default\"!==n&&Object.prototype.hasOwnProperty.call(t,n)&&r(e,t,n);return i(e,t),e},a=this&&this.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(e,\"__esModule\",{value:!0}),e.dispose=e.getInstance=e.initializeWebAssembly=void 0;const s=o(n(6449)),u=a(n(932)),c=n(3474);let l,p=!1,f=!1,d=!1;const h=(t,e)=>e?t?\"ort-wasm-simd-threaded.wasm\":\"ort-wasm-threaded.wasm\":t?\"ort-wasm-simd.wasm\":\"ort-wasm.wasm\";e.initializeWebAssembly=async t=>{if(p)return Promise.resolve();if(f)throw new Error(\"multiple calls to 'initializeWebAssembly()' detected.\");if(d)throw new Error(\"previous call to 'initializeWebAssembly()' failed.\");f=!0;const e=t.initTimeout,r=t.numThreads,i=t.simd,o=r>1&&(()=>{try{return\"undefined\"!=typeof SharedArrayBuffer&&(\"undefined\"!=typeof MessageChannel&&(new MessageChannel).port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11])))}catch(t){return!1}})(),a=i&&(()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch(t){return!1}})(),g=\"string\"==typeof t.wasmPaths?t.wasmPaths:void 0,b=h(!1,o),m=h(a,o),y=\"object\"==typeof t.wasmPaths?t.wasmPaths[m]:void 0;let _=!1;const v=[];if(e>0&&v.push(new Promise((t=>{setTimeout((()=>{_=!0,t()}),e)}))),v.push(new Promise(((t,e)=>{const r=o?c:u.default,i={locateFile:(t,e)=>o&&t.endsWith(\".worker.js\")&&\"undefined\"!=typeof Blob?URL.createObjectURL(new Blob([n(4154)],{type:\"text/javascript\"})):t===b?null!=y?y:(null!=g?g:e)+m:e+t};if(o)if(\"undefined\"==typeof Blob)i.mainScriptUrlOrBlob=s.join(\"/\",\"ort-wasm-threaded.js\");else{const t=`var ortWasmThreaded=(function(){var _scriptDir;return ${r.toString()}})();`;i.mainScriptUrlOrBlob=new Blob([t],{type:\"text/javascript\"})}r(i).then((e=>{f=!1,p=!0,l=e,t()}),(t=>{f=!1,d=!0,e(t)}))}))),await Promise.race(v),_)throw new Error(`WebAssembly backend initializing failed due to timeout: ${e}ms`)},e.getInstance=()=>{if(p&&l)return l;throw new Error(\"WebAssembly is not initialized yet.\")},e.dispose=()=>{var t;!p||f||d||(f=!0,null===(t=l.PThread)||void 0===t||t.terminateAllThreads(),l=void 0,f=!1,p=!1,d=!0)}},9710:(t,e,n)=>{\"use strict\";n.d(e,{Z:()=>o});var r=n(477),i=n.n(r);function o(){return i()('/*!\\n* ONNX Runtime Web v1.14.0\\n* Copyright (c) Microsoft Corporation. All rights reserved.\\n* Licensed under the MIT License.\\n*/\\n(()=>{var t={474:(t,e,n)=>{var _scriptDir,r=(_scriptDir=(_scriptDir=\"undefined\"!=typeof document&&document.currentScript?document.currentScript.src:void 0)||\"/index.js\",function(t){function e(){return j.buffer!=D&&N(j.buffer),P}function r(){return j.buffer!=D&&N(j.buffer),U}function a(){return j.buffer!=D&&N(j.buffer),F}function i(){return j.buffer!=D&&N(j.buffer),I}function o(){return j.buffer!=D&&N(j.buffer),W}var u,c,s;t=t||{},u||(u=void 0!==t?t:{}),u.ready=new Promise((function(t,e){c=t,s=e}));var l,f,p,h,d,y,b=Object.assign({},u),m=\"./this.program\",g=(t,e)=>{throw e},v=\"object\"==typeof window,w=\"function\"==typeof importScripts,_=\"object\"==typeof process&&\"object\"==typeof process.versions&&\"string\"==typeof process.versions.node,O=u.ENVIRONMENT_IS_PTHREAD||!1,A=\"\";function S(t){return u.locateFile?u.locateFile(t,A):A+t}if(_){let e;A=w?n(908).dirname(A)+\"/\":\"//\",y=()=>{d||(h=n(384),d=n(908))},l=function(t,e){return y(),t=d.normalize(t),h.readFileSync(t,e?void 0:\"utf8\")},p=t=>((t=l(t,!0)).buffer||(t=new Uint8Array(t)),t),f=(t,e,n)=>{y(),t=d.normalize(t),h.readFile(t,(function(t,r){t?n(t):e(r.buffer)}))},1<process.argv.length&&(m=process.argv[1].replace(/\\\\\\\\/g,\"/\")),process.argv.slice(2),process.on(\"uncaughtException\",(function(t){if(!(t instanceof ct))throw t})),process.on(\"unhandledRejection\",(function(t){throw t})),g=(t,e)=>{if(Q())throw process.exitCode=t,e;e instanceof ct||x(\"exiting due to exception: \"+e),process.exit(t)},u.inspect=function(){return\"[Emscripten Module object]\"};try{e=n(925)}catch(t){throw console.error(\\'The \"worker_threads\" module is not supported in this node.js build - perhaps a newer version is needed?\\'),t}n.g.Worker=e.Worker}else(v||w)&&(w?A=self.location.href:\"undefined\"!=typeof document&&document.currentScript&&(A=document.currentScript.src),_scriptDir&&(A=_scriptDir),A=0!==A.indexOf(\"blob:\")?A.substr(0,A.replace(/[?#].*/,\"\").lastIndexOf(\"/\")+1):\"\",_||(l=t=>{var e=new XMLHttpRequest;return e.open(\"GET\",t,!1),e.send(null),e.responseText},w&&(p=t=>{var e=new XMLHttpRequest;return e.open(\"GET\",t,!1),e.responseType=\"arraybuffer\",e.send(null),new Uint8Array(e.response)}),f=(t,e,n)=>{var r=new XMLHttpRequest;r.open(\"GET\",t,!0),r.responseType=\"arraybuffer\",r.onload=()=>{200==r.status||0==r.status&&r.response?e(r.response):n()},r.onerror=n,r.send(null)}));_&&\"undefined\"==typeof performance&&(n.g.performance=n(953).performance);var T=console.log.bind(console),E=console.warn.bind(console);_&&(y(),T=t=>h.writeSync(1,t+\"\\\\n\"),E=t=>h.writeSync(2,t+\"\\\\n\"));var M,C=u.print||T,x=u.printErr||E;Object.assign(u,b),b=null,u.thisProgram&&(m=u.thisProgram),u.quit&&(g=u.quit),u.wasmBinary&&(M=u.wasmBinary);var R=u.noExitRuntime||!1;\"object\"!=typeof WebAssembly&&at(\"no native wasm support detected\");var j,k,D,P,U,F,I,W,H=!1,L=\"undefined\"!=typeof TextDecoder?new TextDecoder(\"utf8\"):void 0;function z(t,e,n){var r=(e>>>=0)+n;for(n=e;t[n]&&!(n>=r);)++n;if(16<n-e&&t.buffer&&L)return L.decode(t.buffer instanceof SharedArrayBuffer?t.slice(e,n):t.subarray(e,n));for(r=\"\";e<n;){var a=t[e++];if(128&a){var i=63&t[e++];if(192==(224&a))r+=String.fromCharCode((31&a)<<6|i);else{var o=63&t[e++];65536>(a=224==(240&a)?(15&a)<<12|i<<6|o:(7&a)<<18|i<<12|o<<6|63&t[e++])?r+=String.fromCharCode(a):(a-=65536,r+=String.fromCharCode(55296|a>>10,56320|1023&a))}}else r+=String.fromCharCode(a)}return r}function Y(t,e){return(t>>>=0)?z(r(),t,e):\"\"}function B(t,e,n,r){if(!(0<r))return 0;var a=n>>>=0;r=n+r-1;for(var i=0;i<t.length;++i){var o=t.charCodeAt(i);if(55296<=o&&57343>=o&&(o=65536+((1023&o)<<10)|1023&t.charCodeAt(++i)),127>=o){if(n>=r)break;e[n++>>>0]=o}else{if(2047>=o){if(n+1>=r)break;e[n++>>>0]=192|o>>6}else{if(65535>=o){if(n+2>=r)break;e[n++>>>0]=224|o>>12}else{if(n+3>=r)break;e[n++>>>0]=240|o>>18,e[n++>>>0]=128|o>>12&63}e[n++>>>0]=128|o>>6&63}e[n++>>>0]=128|63&o}}return e[n>>>0]=0,n-a}function G(t){for(var e=0,n=0;n<t.length;++n){var r=t.charCodeAt(n);127>=r?e++:2047>=r?e+=2:55296<=r&&57343>=r?(e+=4,++n):e+=3}return e}function N(t){D=t,u.HEAP8=P=new Int8Array(t),u.HEAP16=new Int16Array(t),u.HEAP32=F=new Int32Array(t),u.HEAPU8=U=new Uint8Array(t),u.HEAPU16=new Uint16Array(t),u.HEAPU32=I=new Uint32Array(t),u.HEAPF32=new Float32Array(t),u.HEAPF64=W=new Float64Array(t)}O&&(D=u.buffer);var V=u.INITIAL_MEMORY||16777216;if(O)j=u.wasmMemory,D=u.buffer;else if(u.wasmMemory)j=u.wasmMemory;else if(!((j=new WebAssembly.Memory({initial:V/65536,maximum:65536,shared:!0})).buffer instanceof SharedArrayBuffer))throw x(\"requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag\"),_&&console.log(\"(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and also use a recent version)\"),Error(\"bad memory\");j&&(D=j.buffer),V=D.byteLength,N(D);var $,q=[],X=[],J=[],Z=[];function Q(){return R||!1}function K(){var t=u.preRun.shift();q.unshift(t)}var tt,et=0,nt=null,rt=null;function at(t){throw O?postMessage({cmd:\"onAbort\",arg:t}):u.onAbort&&u.onAbort(t),x(t=\"Aborted(\"+t+\")\"),H=!0,t=new WebAssembly.RuntimeError(t+\". Build with -sASSERTIONS for more info.\"),s(t),t}function it(){return tt.startsWith(\"data:application/octet-stream;base64,\")}function ot(){var t=tt;try{if(t==tt&&M)return new Uint8Array(M);if(p)return p(t);throw\"both async and sync fetching of the wasm failed\"}catch(t){at(t)}}tt=\"ort-wasm-threaded.wasm\",it()||(tt=S(tt));var ut={};function ct(t){this.name=\"ExitStatus\",this.message=\"Program terminated with exit(\"+t+\")\",this.status=t}function st(t){(t=ht.Vb[t])||at(),ht.mc(t)}function lt(t){var e=ht.Cc();if(!e)return 6;ht.ac.push(e),ht.Vb[t.Ub]=e,e.Ub=t.Ub;var n={cmd:\"run\",start_routine:t.Ic,arg:t.zc,pthread_ptr:t.Ub};return e.$b=()=>{n.time=performance.now(),e.postMessage(n,t.Nc)},e.loaded&&(e.$b(),delete e.$b),0}function ft(t){if(O)return $t(1,1,t);Q()||(ht.oc(),u.onExit&&u.onExit(t),H=!0),g(t,new ct(t))}function pt(t,e){if(!e&&O)throw bt(t),\"unwind\";Q()||O||(me(),dt(J),be(0),re[1].length&&ae(1,10),re[2].length&&ae(2,10),ht.oc()),ft(t)}var ht={Yb:[],ac:[],qc:[],Vb:{},fc:function(){O&&ht.Ec()},Pc:function(){},Ec:function(){ht.receiveObjectTransfer=ht.Gc,ht.threadInitTLS=ht.pc,ht.setExitStatus=ht.nc,R=!1},nc:function(){},oc:function(){for(var t of Object.values(ht.Vb))ht.mc(t);for(t of ht.Yb)t.terminate();ht.Yb=[]},mc:function(t){var e=t.Ub;delete ht.Vb[e],ht.Yb.push(t),ht.ac.splice(ht.ac.indexOf(t),1),t.Ub=0,Oe(e)},Gc:function(){},pc:function(){ht.qc.forEach((t=>t()))},Fc:function(t,e){t.onmessage=n=>{var r=(n=n.data).cmd;if(t.Ub&&(ht.Bc=t.Ub),n.targetThread&&n.targetThread!=he()){var a=ht.Vb[n.Qc];a?a.postMessage(n,n.transferList):x(\\'Internal error! Worker sent a message \"\\'+r+\\'\" to target pthread \\'+n.targetThread+\", but that thread no longer exists!\")}else\"processProxyingQueue\"===r?zt(n.queue):\"spawnThread\"===r?lt(n):\"cleanupThread\"===r?st(n.thread):\"killThread\"===r?(n=n.thread,r=ht.Vb[n],delete ht.Vb[n],r.terminate(),Oe(n),ht.ac.splice(ht.ac.indexOf(r),1),r.Ub=0):\"cancelThread\"===r?ht.Vb[n.thread].postMessage({cmd:\"cancel\"}):\"loaded\"===r?(t.loaded=!0,e&&e(t),t.$b&&(t.$b(),delete t.$b)):\"print\"===r?C(\"Thread \"+n.threadId+\": \"+n.text):\"printErr\"===r?x(\"Thread \"+n.threadId+\": \"+n.text):\"alert\"===r?alert(\"Thread \"+n.threadId+\": \"+n.text):\"setimmediate\"===n.target?t.postMessage(n):\"onAbort\"===r?u.onAbort&&u.onAbort(n.arg):r&&x(\"worker sent an unknown command \"+r);ht.Bc=void 0},t.onerror=t=>{throw x(\"worker sent an error! \"+t.filename+\":\"+t.lineno+\": \"+t.message),t},_&&(t.on(\"message\",(function(e){t.onmessage({data:e})})),t.on(\"error\",(function(e){t.onerror(e)})),t.on(\"detachedExit\",(function(){}))),t.postMessage({cmd:\"load\",urlOrBlob:u.mainScriptUrlOrBlob||_scriptDir,wasmMemory:j,wasmModule:k})},yc:function(){var t=S(\"ort-wasm-threaded.worker.js\");ht.Yb.push(new Worker(t))},Cc:function(){return 0==ht.Yb.length&&(ht.yc(),ht.Fc(ht.Yb[0])),ht.Yb.pop()}};function dt(t){for(;0<t.length;)t.shift()(u)}function yt(t){var e=Ee();return t=t(),Me(e),t}function bt(t){if(O)return $t(2,0,t);try{pt(t)}catch(t){t instanceof ct||\"unwind\"==t||g(1,t)}}u.PThread=ht,u.establishStackSpace=function(){var t=he(),e=a()[t+44>>2>>>0];t=a()[t+48>>2>>>0],Te(e,e-t),Me(e)};var mt=[];function gt(t){var e=mt[t];return e||(t>=mt.length&&(mt.length=t+1),mt[t]=e=$.get(t)),e}u.invokeEntryPoint=function(t,e){t=gt(t)(e),Q()?ht.nc(t):Ae(t)};var vt,wt,_t=[],Ot=0,At=0;function St(t){this.Zb=t,this.Sb=t-24,this.xc=function(t){i()[this.Sb+4>>2>>>0]=t},this.bc=function(){return i()[this.Sb+4>>2>>>0]},this.wc=function(t){i()[this.Sb+8>>2>>>0]=t},this.Dc=function(){return i()[this.Sb+8>>2>>>0]},this.rc=function(){a()[this.Sb>>2>>>0]=0},this.hc=function(t){t=t?1:0,e()[this.Sb+12>>0>>>0]=t},this.uc=function(){return 0!=e()[this.Sb+12>>0>>>0]},this.ic=function(t){t=t?1:0,e()[this.Sb+13>>0>>>0]=t},this.kc=function(){return 0!=e()[this.Sb+13>>0>>>0]},this.fc=function(t,e){this.cc(0),this.xc(t),this.wc(e),this.rc(),this.hc(!1),this.ic(!1)},this.sc=function(){Atomics.add(a(),this.Sb>>2,1)},this.Hc=function(){return 1===Atomics.sub(a(),this.Sb>>2,1)},this.cc=function(t){i()[this.Sb+16>>2>>>0]=t},this.tc=function(){return i()[this.Sb+16>>2>>>0]},this.vc=function(){if(Re(this.bc()))return i()[this.Zb>>2>>>0];var t=this.tc();return 0!==t?t:this.Zb}}function Tt(t){return ye(new St(t).Sb)}function Et(t,e,n,r){return O?$t(3,1,t,e,n,r):Mt(t,e,n,r)}function Mt(t,e,n,r){if(\"undefined\"==typeof SharedArrayBuffer)return x(\"Current environment does not support SharedArrayBuffer, pthreads are not available!\"),6;var a=[];return O&&0===a.length?Et(t,e,n,r):(t={Ic:n,Ub:t,zc:r,Nc:a},O?(t.Oc=\"spawnThread\",postMessage(t,a),0):lt(t))}function Ct(t,e,n){return O?$t(4,1,t,e,n):0}function xt(t,e){if(O)return $t(5,1,t,e)}function Rt(t,e){if(O)return $t(6,1,t,e)}function jt(t,e,n){if(O)return $t(7,1,t,e,n)}function kt(t,e,n){return O?$t(8,1,t,e,n):0}function Dt(t,e){if(O)return $t(9,1,t,e)}function Pt(t,e,n){if(O)return $t(10,1,t,e,n)}function Ut(t,e,n,r){if(O)return $t(11,1,t,e,n,r)}function Ft(t,e,n,r){if(O)return $t(12,1,t,e,n,r)}function It(t,e,n,r){if(O)return $t(13,1,t,e,n,r)}function Wt(t){if(O)return $t(14,1,t)}function Ht(t,e){if(O)return $t(15,1,t,e)}function Lt(t,e,n){if(O)return $t(16,1,t,e,n)}function zt(t){Atomics.store(a(),t>>2,1),he()&&_e(t),Atomics.compareExchange(a(),t>>2,1,0)}function Yt(t){return i()[t>>>2]+4294967296*a()[t+4>>>2]}function Bt(t,e,n,r,a,i){return O?$t(17,1,t,e,n,r,a,i):-52}function Gt(t,e,n,r,a,i){if(O)return $t(18,1,t,e,n,r,a,i)}function Nt(t){var n=G(t)+1,r=de(n);return r&&B(t,e(),r,n),r}function Vt(t,e,n){function r(t){return(t=t.toTimeString().match(/\\\\(([A-Za-z ]+)\\\\)$/))?t[1]:\"GMT\"}if(O)return $t(19,1,t,e,n);var o=(new Date).getFullYear(),u=new Date(o,0,1),c=new Date(o,6,1);o=u.getTimezoneOffset();var s=c.getTimezoneOffset(),l=Math.max(o,s);a()[t>>2>>>0]=60*l,a()[e>>2>>>0]=Number(o!=s),t=r(u),e=r(c),t=Nt(t),e=Nt(e),s<o?(i()[n>>2>>>0]=t,i()[n+4>>2>>>0]=e):(i()[n>>2>>>0]=e,i()[n+4>>2>>>0]=t)}function $t(t,e){var n=arguments.length-2,r=arguments;return yt((()=>{for(var a=Ce(8*n),i=a>>3,u=0;u<n;u++){var c=r[2+u];o()[i+u>>>0]=c}return we(t,n,a,e)}))}u.executeNotifiedProxyingQueue=zt,wt=_?()=>{var t=process.hrtime();return 1e3*t[0]+t[1]/1e6}:O?()=>performance.now()-u.__performance_now_clock_drift:()=>performance.now();var qt,Xt=[],Jt={};function Zt(){if(!qt){var t,e={USER:\"web_user\",LOGNAME:\"web_user\",PATH:\"/\",PWD:\"/\",HOME:\"/home/web_user\",LANG:(\"object\"==typeof navigator&&navigator.languages&&navigator.languages[0]||\"C\").replace(\"-\",\"_\")+\".UTF-8\",_:m||\"./this.program\"};for(t in Jt)void 0===Jt[t]?delete e[t]:e[t]=Jt[t];var n=[];for(t in e)n.push(t+\"=\"+e[t]);qt=n}return qt}function Qt(t,n){if(O)return $t(20,1,t,n);var r=0;return Zt().forEach((function(a,o){var u=n+r;for(o=i()[t+4*o>>2>>>0]=u,u=0;u<a.length;++u)e()[o++>>0>>>0]=a.charCodeAt(u);e()[o>>0>>>0]=0,r+=a.length+1})),0}function Kt(t,e){if(O)return $t(21,1,t,e);var n=Zt();i()[t>>2>>>0]=n.length;var r=0;return n.forEach((function(t){r+=t.length+1})),i()[e>>2>>>0]=r,0}function te(t){return O?$t(22,1,t):52}function ee(t,e,n,r){return O?$t(23,1,t,e,n,r):52}function ne(t,e,n,r,a){return O?$t(24,1,t,e,n,r,a):70}var re=[null,[],[]];function ae(t,e){var n=re[t];0===e||10===e?((1===t?C:x)(z(n,0)),n.length=0):n.push(e)}function ie(t,e,n,a){if(O)return $t(25,1,t,e,n,a);for(var o=0,u=0;u<n;u++){var c=i()[e>>2>>>0],s=i()[e+4>>2>>>0];e+=8;for(var l=0;l<s;l++)ae(t,r()[c+l>>>0]);o+=s}return i()[a>>2>>>0]=o,0}var oe=0;function ue(t){return 0==t%4&&(0!=t%100||0==t%400)}var ce=[31,29,31,30,31,30,31,31,30,31,30,31],se=[31,28,31,30,31,30,31,31,30,31,30,31];function le(t,n,r,i){function o(t,e,n){for(t=\"number\"==typeof t?t.toString():t||\"\";t.length<e;)t=n[0]+t;return t}function u(t,e){return o(t,e,\"0\")}function c(t,e){function n(t){return 0>t?-1:0<t?1:0}var r;return 0===(r=n(t.getFullYear()-e.getFullYear()))&&0===(r=n(t.getMonth()-e.getMonth()))&&(r=n(t.getDate()-e.getDate())),r}function s(t){switch(t.getDay()){case 0:return new Date(t.getFullYear()-1,11,29);case 1:return t;case 2:return new Date(t.getFullYear(),0,3);case 3:return new Date(t.getFullYear(),0,2);case 4:return new Date(t.getFullYear(),0,1);case 5:return new Date(t.getFullYear()-1,11,31);case 6:return new Date(t.getFullYear()-1,11,30)}}function l(t){var e=t.Wb;for(t=new Date(new Date(t.Xb+1900,0,1).getTime());0<e;){var n=t.getMonth(),r=(ue(t.getFullYear())?ce:se)[n];if(!(e>r-t.getDate())){t.setDate(t.getDate()+e);break}e-=r-t.getDate()+1,t.setDate(1),11>n?t.setMonth(n+1):(t.setMonth(0),t.setFullYear(t.getFullYear()+1))}return n=new Date(t.getFullYear()+1,0,4),e=s(new Date(t.getFullYear(),0,4)),n=s(n),0>=c(e,t)?0>=c(n,t)?t.getFullYear()+1:t.getFullYear():t.getFullYear()-1}var f=a()[i+40>>2>>>0];for(var p in i={Lc:a()[i>>2>>>0],Kc:a()[i+4>>2>>>0],dc:a()[i+8>>2>>>0],jc:a()[i+12>>2>>>0],ec:a()[i+16>>2>>>0],Xb:a()[i+20>>2>>>0],Tb:a()[i+24>>2>>>0],Wb:a()[i+28>>2>>>0],Rc:a()[i+32>>2>>>0],Jc:a()[i+36>>2>>>0],Mc:f?Y(f):\"\"},r=Y(r),f={\"%c\":\"%a %b %d %H:%M:%S %Y\",\"%D\":\"%m/%d/%y\",\"%F\":\"%Y-%m-%d\",\"%h\":\"%b\",\"%r\":\"%I:%M:%S %p\",\"%R\":\"%H:%M\",\"%T\":\"%H:%M:%S\",\"%x\":\"%m/%d/%y\",\"%X\":\"%H:%M:%S\",\"%Ec\":\"%c\",\"%EC\":\"%C\",\"%Ex\":\"%m/%d/%y\",\"%EX\":\"%H:%M:%S\",\"%Ey\":\"%y\",\"%EY\":\"%Y\",\"%Od\":\"%d\",\"%Oe\":\"%e\",\"%OH\":\"%H\",\"%OI\":\"%I\",\"%Om\":\"%m\",\"%OM\":\"%M\",\"%OS\":\"%S\",\"%Ou\":\"%u\",\"%OU\":\"%U\",\"%OV\":\"%V\",\"%Ow\":\"%w\",\"%OW\":\"%W\",\"%Oy\":\"%y\"})r=r.replace(new RegExp(p,\"g\"),f[p]);var h=\"Sunday Monday Tuesday Wednesday Thursday Friday Saturday\".split(\" \"),d=\"January February March April May June July August September October November December\".split(\" \");for(p in f={\"%a\":function(t){return h[t.Tb].substring(0,3)},\"%A\":function(t){return h[t.Tb]},\"%b\":function(t){return d[t.ec].substring(0,3)},\"%B\":function(t){return d[t.ec]},\"%C\":function(t){return u((t.Xb+1900)/100|0,2)},\"%d\":function(t){return u(t.jc,2)},\"%e\":function(t){return o(t.jc,2,\" \")},\"%g\":function(t){return l(t).toString().substring(2)},\"%G\":function(t){return l(t)},\"%H\":function(t){return u(t.dc,2)},\"%I\":function(t){return 0==(t=t.dc)?t=12:12<t&&(t-=12),u(t,2)},\"%j\":function(t){for(var e=0,n=0;n<=t.ec-1;e+=(ue(t.Xb+1900)?ce:se)[n++]);return u(t.jc+e,3)},\"%m\":function(t){return u(t.ec+1,2)},\"%M\":function(t){return u(t.Kc,2)},\"%n\":function(){return\"\\\\n\"},\"%p\":function(t){return 0<=t.dc&&12>t.dc?\"AM\":\"PM\"},\"%S\":function(t){return u(t.Lc,2)},\"%t\":function(){return\"\\\\t\"},\"%u\":function(t){return t.Tb||7},\"%U\":function(t){return u(Math.floor((t.Wb+7-t.Tb)/7),2)},\"%V\":function(t){var e=Math.floor((t.Wb+7-(t.Tb+6)%7)/7);if(2>=(t.Tb+371-t.Wb-2)%7&&e++,e)53==e&&(4==(n=(t.Tb+371-t.Wb)%7)||3==n&&ue(t.Xb)||(e=1));else{e=52;var n=(t.Tb+7-t.Wb-1)%7;(4==n||5==n&&ue(t.Xb%400-1))&&e++}return u(e,2)},\"%w\":function(t){return t.Tb},\"%W\":function(t){return u(Math.floor((t.Wb+7-(t.Tb+6)%7)/7),2)},\"%y\":function(t){return(t.Xb+1900).toString().substring(2)},\"%Y\":function(t){return t.Xb+1900},\"%z\":function(t){var e=0<=(t=t.Jc);return t=Math.abs(t)/60,(e?\"+\":\"-\")+String(\"0000\"+(t/60*100+t%60)).slice(-4)},\"%Z\":function(t){return t.Mc},\"%%\":function(){return\"%\"}},r=r.replace(/%%/g,\"\\\\0\\\\0\"),f)r.includes(p)&&(r=r.replace(new RegExp(p,\"g\"),f[p](i)));return p=function(t){var e=Array(G(t)+1);return B(t,e,0,e.length),e}(r=r.replace(/\\\\0\\\\0/g,\"%\")),p.length>n?0:(function(t,n){e().set(t,n>>>0)}(p,t),p.length-1)}ht.fc();var fe=[null,ft,bt,Et,Ct,xt,Rt,jt,kt,Dt,Pt,Ut,Ft,It,Wt,Ht,Lt,Bt,Gt,Vt,Qt,Kt,te,ee,ne,ie],pe={b:function(t){return de(t+24)+24},n:function(t){return(t=new St(t)).uc()||(t.hc(!0),Ot--),t.ic(!1),_t.push(t),t.sc(),t.vc()},ma:function(t){throw x(\"Unexpected exception thrown, this is not properly supported - aborting\"),H=!0,t},x:function(){Se(0);var t=_t.pop();if(t.Hc()&&!t.kc()){var e=t.Dc();e&&gt(e)(t.Zb),Tt(t.Zb)}At=0},e:function(){var t=At;if(!t)return oe=0;var e=new St(t);e.cc(t);var n=e.bc();if(!n)return oe=0,t;for(var r=Array.prototype.slice.call(arguments),a=0;a<r.length;a++){var i=r[a];if(0===i||i===n)break;if(xe(i,n,e.Sb+16))return oe=i,t}return oe=n,t},l:function(){var t=At;if(!t)return oe=0;var e=new St(t);e.cc(t);var n=e.bc();if(!n)return oe=0,t;for(var r=Array.prototype.slice.call(arguments),a=0;a<r.length;a++){var i=r[a];if(0===i||i===n)break;if(xe(i,n,e.Sb+16))return oe=i,t}return oe=n,t},h:function(){var t=At;if(!t)return oe=0;var e=new St(t);e.cc(t);var n=e.bc();if(!n)return oe=0,t;for(var r=Array.prototype.slice.call(arguments),a=0;a<r.length;a++){var i=r[a];if(0===i||i===n)break;if(xe(i,n,e.Sb+16))return oe=i,t}return oe=n,t},t:Tt,M:function(){var t=_t.pop();t||at(\"no exception to throw\");var e=t.Zb;throw t.kc()||(_t.push(t),t.ic(!0),t.hc(!1),Ot++),At=e,e},c:function(t,e,n){throw new St(t).fc(e,n),At=t,Ot++,t},pa:function(){return Ot},Fa:function(t){ge(t,!w,1,!v),ht.pc()},T:function(t){O?postMessage({cmd:\"cleanupThread\",thread:t}):st(t)},xa:Mt,j:function(t){throw At||(At=t),t},H:Ct,Ma:xt,ua:Rt,wa:jt,oa:kt,Ka:Dt,Ca:Pt,Ja:Ut,V:Ft,va:It,sa:Wt,La:Ht,ta:Lt,Ta:function(){},X:function(){at(\"To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking\")},Ua:function(){at(\"To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking\")},W:function(){return Date.now()},ya:function(){return 2097152},Oa:function(){return!0},za:function(t,e,n,r){if(t==e)setTimeout((()=>zt(r)));else if(O)postMessage({targetThread:t,cmd:\"processProxyingQueue\",queue:r});else{if(!(t=ht.Vb[t]))return;t.postMessage({cmd:\"processProxyingQueue\",queue:r})}return 1},Ea:function(){return-1},Pa:function(t,e){t=new Date(1e3*Yt(t)),a()[e>>2>>>0]=t.getUTCSeconds(),a()[e+4>>2>>>0]=t.getUTCMinutes(),a()[e+8>>2>>>0]=t.getUTCHours(),a()[e+12>>2>>>0]=t.getUTCDate(),a()[e+16>>2>>>0]=t.getUTCMonth(),a()[e+20>>2>>>0]=t.getUTCFullYear()-1900,a()[e+24>>2>>>0]=t.getUTCDay(),t=(t.getTime()-Date.UTC(t.getUTCFullYear(),0,1,0,0,0,0))/864e5|0,a()[e+28>>2>>>0]=t},Qa:function(t,e){t=new Date(1e3*Yt(t)),a()[e>>2>>>0]=t.getSeconds(),a()[e+4>>2>>>0]=t.getMinutes(),a()[e+8>>2>>>0]=t.getHours(),a()[e+12>>2>>>0]=t.getDate(),a()[e+16>>2>>>0]=t.getMonth(),a()[e+20>>2>>>0]=t.getFullYear()-1900,a()[e+24>>2>>>0]=t.getDay();var n=new Date(t.getFullYear(),0,1),r=(t.getTime()-n.getTime())/864e5|0;a()[e+28>>2>>>0]=r,a()[e+36>>2>>>0]=-60*t.getTimezoneOffset(),r=new Date(t.getFullYear(),6,1).getTimezoneOffset(),t=0|(r!=(n=n.getTimezoneOffset())&&t.getTimezoneOffset()==Math.min(n,r)),a()[e+32>>2>>>0]=t},Ra:function(t){var e=new Date(a()[t+20>>2>>>0]+1900,a()[t+16>>2>>>0],a()[t+12>>2>>>0],a()[t+8>>2>>>0],a()[t+4>>2>>>0],a()[t>>2>>>0],0),n=a()[t+32>>2>>>0],r=e.getTimezoneOffset(),i=new Date(e.getFullYear(),0,1),o=new Date(e.getFullYear(),6,1).getTimezoneOffset(),u=i.getTimezoneOffset(),c=Math.min(u,o);return 0>n?a()[t+32>>2>>>0]=Number(o!=u&&c==r):0<n!=(c==r)&&(o=Math.max(u,o),e.setTime(e.getTime()+6e4*((0<n?c:o)-r))),a()[t+24>>2>>>0]=e.getDay(),n=(e.getTime()-i.getTime())/864e5|0,a()[t+28>>2>>>0]=n,a()[t>>2>>>0]=e.getSeconds(),a()[t+4>>2>>>0]=e.getMinutes(),a()[t+8>>2>>>0]=e.getHours(),a()[t+12>>2>>>0]=e.getDate(),a()[t+16>>2>>>0]=e.getMonth(),e.getTime()/1e3|0},Aa:Bt,Ba:Gt,Sa:function t(e,n,r){t.Ac||(t.Ac=!0,Vt(e,n,r))},y:function(){at(\"\")},U:function(){if(!_&&!w){var t=\"Blocking on the main thread is very dangerous, see https://emscripten.org/docs/porting/pthreads.html#blocking-on-the-main-browser-thread\";vt||(vt={}),vt[t]||(vt[t]=1,_&&(t=\"warning: \"+t),x(t))}},ra:function(){return 4294901760},B:wt,Ia:function(t,e,n){r().copyWithin(t>>>0,e>>>0,e+n>>>0)},F:function(){return _?n(993).cpus().length:navigator.hardwareConcurrency},Da:function(t,e,n){Xt.length=e,n>>=3;for(var r=0;r<e;r++)Xt[r]=o()[n+r>>>0];return(0>t?ut[-t-1]:fe[t]).apply(null,Xt)},qa:function(t){var e=r().length;if((t>>>=0)<=e||4294901760<t)return!1;for(var n=1;4>=n;n*=2){var a=e*(1+.2/n);a=Math.min(a,t+100663296);var i=Math;a=Math.max(t,a),i=i.min.call(i,4294901760,a+(65536-a%65536)%65536);t:{try{j.grow(i-D.byteLength+65535>>>16),N(j.buffer);var o=1;break t}catch(t){}o=void 0}if(o)return!0}return!1},Na:function(){throw\"unwind\"},Ga:Qt,Ha:Kt,J:pt,I:te,S:ee,ga:ne,R:ie,d:function(){return oe},na:function t(r,a){t.lc||(t.lc=function(){if(\"object\"==typeof crypto&&\"function\"==typeof crypto.getRandomValues){var t=new Uint8Array(1);return()=>(crypto.getRandomValues(t),t[0])}if(_)try{var e=n(Object(function(){var t=new Error(\"Cannot find module \\'crypto\\'\");throw t.code=\"MODULE_NOT_FOUND\",t}()));return()=>e.randomBytes(1)[0]}catch(t){}return()=>at(\"randomDevice\")}());for(var i=0;i<a;i++)e()[r+i>>0>>>0]=t.lc();return 0},ia:function(t,e,n){var r=Ee();try{return gt(t)(e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},ja:function(t,e,n){var r=Ee();try{return gt(t)(e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},K:function(t){var e=Ee();try{return gt(t)()}catch(t){if(Me(e),t!==t+0)throw t;Se(1,0)}},f:function(t,e){var n=Ee();try{return gt(t)(e)}catch(t){if(Me(n),t!==t+0)throw t;Se(1,0)}},P:function(t,e,n){var r=Ee();try{return gt(t)(e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},Q:function(t,e,n){var r=Ee();try{return gt(t)(e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},k:function(t,e,n){var r=Ee();try{return gt(t)(e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},p:function(t,e,n,r){var a=Ee();try{return gt(t)(e,n,r)}catch(t){if(Me(a),t!==t+0)throw t;Se(1,0)}},q:function(t,e,n,r,a){var i=Ee();try{return gt(t)(e,n,r,a)}catch(t){if(Me(i),t!==t+0)throw t;Se(1,0)}},N:function(t,e,n,r,a,i){var o=Ee();try{return gt(t)(e,n,r,a,i)}catch(t){if(Me(o),t!==t+0)throw t;Se(1,0)}},s:function(t,e,n,r,a,i){var o=Ee();try{return gt(t)(e,n,r,a,i)}catch(t){if(Me(o),t!==t+0)throw t;Se(1,0)}},w:function(t,e,n,r,a,i,o){var u=Ee();try{return gt(t)(e,n,r,a,i,o)}catch(t){if(Me(u),t!==t+0)throw t;Se(1,0)}},L:function(t,e,n,r,a,i,o,u){var c=Ee();try{return gt(t)(e,n,r,a,i,o,u)}catch(t){if(Me(c),t!==t+0)throw t;Se(1,0)}},E:function(t,e,n,r,a,i,o,u,c,s,l,f){var p=Ee();try{return gt(t)(e,n,r,a,i,o,u,c,s,l,f)}catch(t){if(Me(p),t!==t+0)throw t;Se(1,0)}},aa:function(t,e,n,r,a,i,o,u){var c=Ee();try{return He(t,e,n,r,a,i,o,u)}catch(t){if(Me(c),t!==t+0)throw t;Se(1,0)}},_:function(t,e,n,r,a,i,o){var u=Ee();try{return ke(t,e,n,r,a,i,o)}catch(t){if(Me(u),t!==t+0)throw t;Se(1,0)}},Z:function(t,e,n,r,a){var i=Ee();try{return Le(t,e,n,r,a)}catch(t){if(Me(i),t!==t+0)throw t;Se(1,0)}},ca:function(t,e,n,r){var a=Ee();try{return Ie(t,e,n,r)}catch(t){if(Me(a),t!==t+0)throw t;Se(1,0)}},$:function(t){var e=Ee();try{return je(t)}catch(t){if(Me(e),t!==t+0)throw t;Se(1,0)}},ba:function(t,e){var n=Ee();try{return We(t,e)}catch(t){if(Me(n),t!==t+0)throw t;Se(1,0)}},Y:function(t,e,n){var r=Ee();try{return De(t,e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},g:function(t){var e=Ee();try{gt(t)()}catch(t){if(Me(e),t!==t+0)throw t;Se(1,0)}},r:function(t,e){var n=Ee();try{gt(t)(e)}catch(t){if(Me(n),t!==t+0)throw t;Se(1,0)}},i:function(t,e,n){var r=Ee();try{gt(t)(e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},ha:function(t,e,n,r){var a=Ee();try{gt(t)(e,n,r)}catch(t){if(Me(a),t!==t+0)throw t;Se(1,0)}},m:function(t,e,n,r){var a=Ee();try{gt(t)(e,n,r)}catch(t){if(Me(a),t!==t+0)throw t;Se(1,0)}},v:function(t,e,n,r,a){var i=Ee();try{gt(t)(e,n,r,a)}catch(t){if(Me(i),t!==t+0)throw t;Se(1,0)}},u:function(t,e,n,r,a,i){var o=Ee();try{gt(t)(e,n,r,a,i)}catch(t){if(Me(o),t!==t+0)throw t;Se(1,0)}},O:function(t,e,n,r,a,i,o){var u=Ee();try{gt(t)(e,n,r,a,i,o)}catch(t){if(Me(u),t!==t+0)throw t;Se(1,0)}},A:function(t,e,n,r,a,i,o,u){var c=Ee();try{gt(t)(e,n,r,a,i,o,u)}catch(t){if(Me(c),t!==t+0)throw t;Se(1,0)}},ka:function(t,e,n,r,a,i,o,u,c){var s=Ee();try{gt(t)(e,n,r,a,i,o,u,c)}catch(t){if(Me(s),t!==t+0)throw t;Se(1,0)}},C:function(t,e,n,r,a,i,o,u,c,s,l){var f=Ee();try{gt(t)(e,n,r,a,i,o,u,c,s,l)}catch(t){if(Me(f),t!==t+0)throw t;Se(1,0)}},D:function(t,e,n,r,a,i,o,u,c,s,l,f,p,h,d,y){var b=Ee();try{gt(t)(e,n,r,a,i,o,u,c,s,l,f,p,h,d,y)}catch(t){if(Me(b),t!==t+0)throw t;Se(1,0)}},fa:function(t,e,n,r,a,i,o,u){var c=Ee();try{Pe(t,e,n,r,a,i,o,u)}catch(t){if(Me(c),t!==t+0)throw t;Se(1,0)}},da:function(t,e,n,r,a,i,o,u,c,s,l,f){var p=Ee();try{Fe(t,e,n,r,a,i,o,u,c,s,l,f)}catch(t){if(Me(p),t!==t+0)throw t;Se(1,0)}},ea:function(t,e,n,r,a,i){var o=Ee();try{Ue(t,e,n,r,a,i)}catch(t){if(Me(o),t!==t+0)throw t;Se(1,0)}},o:function(t){return t},a:j||u.wasmMemory,G:function(t){oe=t},la:le,z:function(t,e,n,r){return le(t,e,n,r)}};!function(){function t(t,e){u.asm=t.exports,ht.qc.push(u.asm.sb),$=u.asm.ub,X.unshift(u.asm.Va),k=e,O||(et--,u.monitorRunDependencies&&u.monitorRunDependencies(et),0==et&&(null!==nt&&(clearInterval(nt),nt=null),rt&&(t=rt,rt=null,t())))}function e(e){t(e.instance,e.module)}function n(t){return function(){if(!M&&(v||w)){if(\"function\"==typeof fetch&&!tt.startsWith(\"file://\"))return fetch(tt,{credentials:\"same-origin\"}).then((function(t){if(!t.ok)throw\"failed to load wasm binary file at \\'\"+tt+\"\\'\";return t.arrayBuffer()})).catch((function(){return ot()}));if(f)return new Promise((function(t,e){f(tt,(function(e){t(new Uint8Array(e))}),e)}))}return Promise.resolve().then((function(){return ot()}))}().then((function(t){return WebAssembly.instantiate(t,r)})).then((function(t){return t})).then(t,(function(t){x(\"failed to asynchronously prepare wasm: \"+t),at(t)}))}var r={a:pe};if(O||(et++,u.monitorRunDependencies&&u.monitorRunDependencies(et)),u.instantiateWasm)try{return u.instantiateWasm(r,t)}catch(t){return x(\"Module.instantiateWasm callback failed with error: \"+t),!1}(M||\"function\"!=typeof WebAssembly.instantiateStreaming||it()||tt.startsWith(\"file://\")||_||\"function\"!=typeof fetch?n(e):fetch(tt,{credentials:\"same-origin\"}).then((function(t){return WebAssembly.instantiateStreaming(t,r).then(e,(function(t){return x(\"wasm streaming compile failed: \"+t),x(\"falling back to ArrayBuffer instantiation\"),n(e)}))}))).catch(s)}(),u.___wasm_call_ctors=function(){return(u.___wasm_call_ctors=u.asm.Va).apply(null,arguments)},u._OrtInit=function(){return(u._OrtInit=u.asm.Wa).apply(null,arguments)},u._OrtCreateSessionOptions=function(){return(u._OrtCreateSessionOptions=u.asm.Xa).apply(null,arguments)},u._OrtAppendExecutionProvider=function(){return(u._OrtAppendExecutionProvider=u.asm.Ya).apply(null,arguments)},u._OrtAddSessionConfigEntry=function(){return(u._OrtAddSessionConfigEntry=u.asm.Za).apply(null,arguments)},u._OrtReleaseSessionOptions=function(){return(u._OrtReleaseSessionOptions=u.asm._a).apply(null,arguments)},u._OrtCreateSession=function(){return(u._OrtCreateSession=u.asm.$a).apply(null,arguments)},u._OrtReleaseSession=function(){return(u._OrtReleaseSession=u.asm.ab).apply(null,arguments)},u._OrtGetInputCount=function(){return(u._OrtGetInputCount=u.asm.bb).apply(null,arguments)},u._OrtGetOutputCount=function(){return(u._OrtGetOutputCount=u.asm.cb).apply(null,arguments)},u._OrtGetInputName=function(){return(u._OrtGetInputName=u.asm.db).apply(null,arguments)},u._OrtGetOutputName=function(){return(u._OrtGetOutputName=u.asm.eb).apply(null,arguments)},u._OrtFree=function(){return(u._OrtFree=u.asm.fb).apply(null,arguments)},u._OrtCreateTensor=function(){return(u._OrtCreateTensor=u.asm.gb).apply(null,arguments)},u._OrtGetTensorData=function(){return(u._OrtGetTensorData=u.asm.hb).apply(null,arguments)},u._OrtReleaseTensor=function(){return(u._OrtReleaseTensor=u.asm.ib).apply(null,arguments)},u._OrtCreateRunOptions=function(){return(u._OrtCreateRunOptions=u.asm.jb).apply(null,arguments)},u._OrtAddRunConfigEntry=function(){return(u._OrtAddRunConfigEntry=u.asm.kb).apply(null,arguments)},u._OrtReleaseRunOptions=function(){return(u._OrtReleaseRunOptions=u.asm.lb).apply(null,arguments)},u._OrtRun=function(){return(u._OrtRun=u.asm.mb).apply(null,arguments)},u._OrtEndProfiling=function(){return(u._OrtEndProfiling=u.asm.nb).apply(null,arguments)};var he=u._pthread_self=function(){return(he=u._pthread_self=u.asm.ob).apply(null,arguments)},de=u._malloc=function(){return(de=u._malloc=u.asm.pb).apply(null,arguments)},ye=u._free=function(){return(ye=u._free=u.asm.qb).apply(null,arguments)},be=u._fflush=function(){return(be=u._fflush=u.asm.rb).apply(null,arguments)};u.__emscripten_tls_init=function(){return(u.__emscripten_tls_init=u.asm.sb).apply(null,arguments)};var me=u.___funcs_on_exit=function(){return(me=u.___funcs_on_exit=u.asm.tb).apply(null,arguments)},ge=u.__emscripten_thread_init=function(){return(ge=u.__emscripten_thread_init=u.asm.vb).apply(null,arguments)};u.__emscripten_thread_crashed=function(){return(u.__emscripten_thread_crashed=u.asm.wb).apply(null,arguments)};var ve,we=u._emscripten_run_in_main_runtime_thread_js=function(){return(we=u._emscripten_run_in_main_runtime_thread_js=u.asm.xb).apply(null,arguments)},_e=u.__emscripten_proxy_execute_task_queue=function(){return(_e=u.__emscripten_proxy_execute_task_queue=u.asm.yb).apply(null,arguments)},Oe=u.__emscripten_thread_free_data=function(){return(Oe=u.__emscripten_thread_free_data=u.asm.zb).apply(null,arguments)},Ae=u.__emscripten_thread_exit=function(){return(Ae=u.__emscripten_thread_exit=u.asm.Ab).apply(null,arguments)},Se=u._setThrew=function(){return(Se=u._setThrew=u.asm.Bb).apply(null,arguments)},Te=u._emscripten_stack_set_limits=function(){return(Te=u._emscripten_stack_set_limits=u.asm.Cb).apply(null,arguments)},Ee=u.stackSave=function(){return(Ee=u.stackSave=u.asm.Db).apply(null,arguments)},Me=u.stackRestore=function(){return(Me=u.stackRestore=u.asm.Eb).apply(null,arguments)},Ce=u.stackAlloc=function(){return(Ce=u.stackAlloc=u.asm.Fb).apply(null,arguments)},xe=u.___cxa_can_catch=function(){return(xe=u.___cxa_can_catch=u.asm.Gb).apply(null,arguments)},Re=u.___cxa_is_pointer_type=function(){return(Re=u.___cxa_is_pointer_type=u.asm.Hb).apply(null,arguments)},je=u.dynCall_j=function(){return(je=u.dynCall_j=u.asm.Ib).apply(null,arguments)},ke=u.dynCall_iiiiij=function(){return(ke=u.dynCall_iiiiij=u.asm.Jb).apply(null,arguments)},De=u.dynCall_jii=function(){return(De=u.dynCall_jii=u.asm.Kb).apply(null,arguments)},Pe=u.dynCall_viiiiij=function(){return(Pe=u.dynCall_viiiiij=u.asm.Lb).apply(null,arguments)},Ue=u.dynCall_vjji=function(){return(Ue=u.dynCall_vjji=u.asm.Mb).apply(null,arguments)},Fe=u.dynCall_viiijjjii=function(){return(Fe=u.dynCall_viiijjjii=u.asm.Nb).apply(null,arguments)},Ie=u.dynCall_iij=function(){return(Ie=u.dynCall_iij=u.asm.Ob).apply(null,arguments)},We=u.dynCall_ji=function(){return(We=u.dynCall_ji=u.asm.Pb).apply(null,arguments)},He=u.dynCall_iiiiiij=function(){return(He=u.dynCall_iiiiiij=u.asm.Qb).apply(null,arguments)},Le=u.dynCall_iiij=function(){return(Le=u.dynCall_iiij=u.asm.Rb).apply(null,arguments)};function ze(){function t(){if(!ve&&(ve=!0,u.calledRun=!0,!H)&&(O||dt(X),c(u),u.onRuntimeInitialized&&u.onRuntimeInitialized(),!O)){if(u.postRun)for(\"function\"==typeof u.postRun&&(u.postRun=[u.postRun]);u.postRun.length;){var t=u.postRun.shift();Z.unshift(t)}dt(Z)}}if(!(0<et))if(O)c(u),O||dt(X),postMessage({cmd:\"loaded\"});else{if(u.preRun)for(\"function\"==typeof u.preRun&&(u.preRun=[u.preRun]);u.preRun.length;)K();dt(q),0<et||(u.setStatus?(u.setStatus(\"Running...\"),setTimeout((function(){setTimeout((function(){u.setStatus(\"\")}),1),t()}),1)):t())}}if(u.UTF8ToString=Y,u.stringToUTF8=function(t,e,n){return B(t,r(),e,n)},u.lengthBytesUTF8=G,u.keepRuntimeAlive=Q,u.wasmMemory=j,u.stackSave=Ee,u.stackRestore=Me,u.stackAlloc=Ce,u.ExitStatus=ct,u.PThread=ht,rt=function t(){ve||ze(),ve||(rt=t)},u.preInit)for(\"function\"==typeof u.preInit&&(u.preInit=[u.preInit]);0<u.preInit.length;)u.preInit.pop()();return ze(),t.ready});t.exports=r},932:(t,e,n)=>{var _scriptDir,r=(_scriptDir=(_scriptDir=\"undefined\"!=typeof document&&document.currentScript?document.currentScript.src:void 0)||\"/index.js\",function(t){var e,r,a;t=t||{},e||(e=void 0!==t?t:{}),e.ready=new Promise((function(t,e){r=t,a=e}));var i,o,u,c,s,l,f=Object.assign({},e),p=\"./this.program\",h=(t,e)=>{throw e},d=\"object\"==typeof window,y=\"function\"==typeof importScripts,b=\"object\"==typeof process&&\"object\"==typeof process.versions&&\"string\"==typeof process.versions.node,m=\"\";b?(m=y?n(908).dirname(m)+\"/\":\"//\",l=()=>{s||(c=n(384),s=n(908))},i=function(t,e){return l(),t=s.normalize(t),c.readFileSync(t,e?void 0:\"utf8\")},u=t=>((t=i(t,!0)).buffer||(t=new Uint8Array(t)),t),o=(t,e,n)=>{l(),t=s.normalize(t),c.readFile(t,(function(t,r){t?n(t):e(r.buffer)}))},1<process.argv.length&&(p=process.argv[1].replace(/\\\\\\\\/g,\"/\")),process.argv.slice(2),process.on(\"uncaughtException\",(function(t){if(!(t instanceof J))throw t})),process.on(\"unhandledRejection\",(function(t){throw t})),h=(t,e)=>{if(_||0<L)throw process.exitCode=t,e;e instanceof J||w(\"exiting due to exception: \"+e),process.exit(t)},e.inspect=function(){return\"[Emscripten Module object]\"}):(d||y)&&(y?m=self.location.href:\"undefined\"!=typeof document&&document.currentScript&&(m=document.currentScript.src),_scriptDir&&(m=_scriptDir),m=0!==m.indexOf(\"blob:\")?m.substr(0,m.replace(/[?#].*/,\"\").lastIndexOf(\"/\")+1):\"\",i=t=>{var e=new XMLHttpRequest;return e.open(\"GET\",t,!1),e.send(null),e.responseText},y&&(u=t=>{var e=new XMLHttpRequest;return e.open(\"GET\",t,!1),e.responseType=\"arraybuffer\",e.send(null),new Uint8Array(e.response)}),o=(t,e,n)=>{var r=new XMLHttpRequest;r.open(\"GET\",t,!0),r.responseType=\"arraybuffer\",r.onload=()=>{200==r.status||0==r.status&&r.response?e(r.response):n()},r.onerror=n,r.send(null)});var g,v=e.print||console.log.bind(console),w=e.printErr||console.warn.bind(console);Object.assign(e,f),f=null,e.thisProgram&&(p=e.thisProgram),e.quit&&(h=e.quit),e.wasmBinary&&(g=e.wasmBinary);var _=e.noExitRuntime||!1;\"object\"!=typeof WebAssembly&&V(\"no native wasm support detected\");var O,A,S,T,E,M,C=!1,x=\"undefined\"!=typeof TextDecoder?new TextDecoder(\"utf8\"):void 0;function R(t,e,n){var r=(e>>>=0)+n;for(n=e;t[n]&&!(n>=r);)++n;if(16<n-e&&t.buffer&&x)return x.decode(t.subarray(e,n));for(r=\"\";e<n;){var a=t[e++];if(128&a){var i=63&t[e++];if(192==(224&a))r+=String.fromCharCode((31&a)<<6|i);else{var o=63&t[e++];65536>(a=224==(240&a)?(15&a)<<12|i<<6|o:(7&a)<<18|i<<12|o<<6|63&t[e++])?r+=String.fromCharCode(a):(a-=65536,r+=String.fromCharCode(55296|a>>10,56320|1023&a))}}else r+=String.fromCharCode(a)}return r}function j(t,e){return(t>>>=0)?R(T,t,e):\"\"}function k(t,e,n,r){if(!(0<r))return 0;var a=n>>>=0;r=n+r-1;for(var i=0;i<t.length;++i){var o=t.charCodeAt(i);if(55296<=o&&57343>=o&&(o=65536+((1023&o)<<10)|1023&t.charCodeAt(++i)),127>=o){if(n>=r)break;e[n++>>>0]=o}else{if(2047>=o){if(n+1>=r)break;e[n++>>>0]=192|o>>6}else{if(65535>=o){if(n+2>=r)break;e[n++>>>0]=224|o>>12}else{if(n+3>=r)break;e[n++>>>0]=240|o>>18,e[n++>>>0]=128|o>>12&63}e[n++>>>0]=128|o>>6&63}e[n++>>>0]=128|63&o}}return e[n>>>0]=0,n-a}function D(t){for(var e=0,n=0;n<t.length;++n){var r=t.charCodeAt(n);127>=r?e++:2047>=r?e+=2:55296<=r&&57343>=r?(e+=4,++n):e+=3}return e}function P(){var t=O.buffer;A=t,e.HEAP8=S=new Int8Array(t),e.HEAP16=new Int16Array(t),e.HEAP32=E=new Int32Array(t),e.HEAPU8=T=new Uint8Array(t),e.HEAPU16=new Uint16Array(t),e.HEAPU32=M=new Uint32Array(t),e.HEAPF32=new Float32Array(t),e.HEAPF64=new Float64Array(t)}var U,F=[],I=[],W=[],H=[],L=0;function z(){var t=e.preRun.shift();F.unshift(t)}var Y,B=0,G=null,N=null;function V(t){throw e.onAbort&&e.onAbort(t),w(t=\"Aborted(\"+t+\")\"),C=!0,t=new WebAssembly.RuntimeError(t+\". Build with -sASSERTIONS for more info.\"),a(t),t}function $(){return Y.startsWith(\"data:application/octet-stream;base64,\")}if(Y=\"ort-wasm.wasm\",!$()){var q=Y;Y=e.locateFile?e.locateFile(q,m):m+q}function X(){var t=Y;try{if(t==Y&&g)return new Uint8Array(g);if(u)return u(t);throw\"both async and sync fetching of the wasm failed\"}catch(t){V(t)}}function J(t){this.name=\"ExitStatus\",this.message=\"Program terminated with exit(\"+t+\")\",this.status=t}function Z(t){for(;0<t.length;)t.shift()(e)}var Q=[],K=0,tt=0;function et(t){this.Db=t,this.zb=t-24,this.Ub=function(t){M[this.zb+4>>2>>>0]=t},this.Eb=function(){return M[this.zb+4>>2>>>0]},this.Sb=function(t){M[this.zb+8>>2>>>0]=t},this.Wb=function(){return M[this.zb+8>>2>>>0]},this.Tb=function(){E[this.zb>>2>>>0]=0},this.Ib=function(t){S[this.zb+12>>0>>>0]=t?1:0},this.Pb=function(){return 0!=S[this.zb+12>>0>>>0]},this.Jb=function(t){S[this.zb+13>>0>>>0]=t?1:0},this.Lb=function(){return 0!=S[this.zb+13>>0>>>0]},this.Rb=function(t,e){this.Fb(0),this.Ub(t),this.Sb(e),this.Tb(),this.Ib(!1),this.Jb(!1)},this.Nb=function(){E[this.zb>>2>>>0]+=1},this.Xb=function(){var t=E[this.zb>>2>>>0];return E[this.zb>>2>>>0]=t-1,1===t},this.Fb=function(t){M[this.zb+16>>2>>>0]=t},this.Ob=function(){return M[this.zb+16>>2>>>0]},this.Qb=function(){if(Mt(this.Eb()))return M[this.Db>>2>>>0];var t=this.Ob();return 0!==t?t:this.Db}}function nt(t){return vt(new et(t).zb)}var rt=[];function at(t){var e=rt[t];return e||(t>=rt.length&&(rt.length=t+1),rt[t]=e=U.get(t)),e}function it(t){var e=D(t)+1,n=gt(e);return n&&k(t,S,n,e),n}var ot={};function ut(){if(!ct){var t,e={USER:\"web_user\",LOGNAME:\"web_user\",PATH:\"/\",PWD:\"/\",HOME:\"/home/web_user\",LANG:(\"object\"==typeof navigator&&navigator.languages&&navigator.languages[0]||\"C\").replace(\"-\",\"_\")+\".UTF-8\",_:p||\"./this.program\"};for(t in ot)void 0===ot[t]?delete e[t]:e[t]=ot[t];var n=[];for(t in e)n.push(t+\"=\"+e[t]);ct=n}return ct}var ct,st=[null,[],[]];function lt(t,e){var n=st[t];0===e||10===e?((1===t?v:w)(R(n,0)),n.length=0):n.push(e)}var ft=0;function pt(t){return 0==t%4&&(0!=t%100||0==t%400)}var ht=[31,29,31,30,31,30,31,31,30,31,30,31],dt=[31,28,31,30,31,30,31,31,30,31,30,31];function yt(t,e,n,r){function a(t,e,n){for(t=\"number\"==typeof t?t.toString():t||\"\";t.length<e;)t=n[0]+t;return t}function i(t,e){return a(t,e,\"0\")}function o(t,e){function n(t){return 0>t?-1:0<t?1:0}var r;return 0===(r=n(t.getFullYear()-e.getFullYear()))&&0===(r=n(t.getMonth()-e.getMonth()))&&(r=n(t.getDate()-e.getDate())),r}function u(t){switch(t.getDay()){case 0:return new Date(t.getFullYear()-1,11,29);case 1:return t;case 2:return new Date(t.getFullYear(),0,3);case 3:return new Date(t.getFullYear(),0,2);case 4:return new Date(t.getFullYear(),0,1);case 5:return new Date(t.getFullYear()-1,11,31);case 6:return new Date(t.getFullYear()-1,11,30)}}function c(t){var e=t.Bb;for(t=new Date(new Date(t.Cb+1900,0,1).getTime());0<e;){var n=t.getMonth(),r=(pt(t.getFullYear())?ht:dt)[n];if(!(e>r-t.getDate())){t.setDate(t.getDate()+e);break}e-=r-t.getDate()+1,t.setDate(1),11>n?t.setMonth(n+1):(t.setMonth(0),t.setFullYear(t.getFullYear()+1))}return n=new Date(t.getFullYear()+1,0,4),e=u(new Date(t.getFullYear(),0,4)),n=u(n),0>=o(e,t)?0>=o(n,t)?t.getFullYear()+1:t.getFullYear():t.getFullYear()-1}var s=E[r+40>>2>>>0];for(var l in r={$b:E[r>>2>>>0],Zb:E[r+4>>2>>>0],Gb:E[r+8>>2>>>0],Kb:E[r+12>>2>>>0],Hb:E[r+16>>2>>>0],Cb:E[r+20>>2>>>0],Ab:E[r+24>>2>>>0],Bb:E[r+28>>2>>>0],bc:E[r+32>>2>>>0],Yb:E[r+36>>2>>>0],ac:s?j(s):\"\"},n=j(n),s={\"%c\":\"%a %b %d %H:%M:%S %Y\",\"%D\":\"%m/%d/%y\",\"%F\":\"%Y-%m-%d\",\"%h\":\"%b\",\"%r\":\"%I:%M:%S %p\",\"%R\":\"%H:%M\",\"%T\":\"%H:%M:%S\",\"%x\":\"%m/%d/%y\",\"%X\":\"%H:%M:%S\",\"%Ec\":\"%c\",\"%EC\":\"%C\",\"%Ex\":\"%m/%d/%y\",\"%EX\":\"%H:%M:%S\",\"%Ey\":\"%y\",\"%EY\":\"%Y\",\"%Od\":\"%d\",\"%Oe\":\"%e\",\"%OH\":\"%H\",\"%OI\":\"%I\",\"%Om\":\"%m\",\"%OM\":\"%M\",\"%OS\":\"%S\",\"%Ou\":\"%u\",\"%OU\":\"%U\",\"%OV\":\"%V\",\"%Ow\":\"%w\",\"%OW\":\"%W\",\"%Oy\":\"%y\"})n=n.replace(new RegExp(l,\"g\"),s[l]);var f=\"Sunday Monday Tuesday Wednesday Thursday Friday Saturday\".split(\" \"),p=\"January February March April May June July August September October November December\".split(\" \");for(l in s={\"%a\":function(t){return f[t.Ab].substring(0,3)},\"%A\":function(t){return f[t.Ab]},\"%b\":function(t){return p[t.Hb].substring(0,3)},\"%B\":function(t){return p[t.Hb]},\"%C\":function(t){return i((t.Cb+1900)/100|0,2)},\"%d\":function(t){return i(t.Kb,2)},\"%e\":function(t){return a(t.Kb,2,\" \")},\"%g\":function(t){return c(t).toString().substring(2)},\"%G\":function(t){return c(t)},\"%H\":function(t){return i(t.Gb,2)},\"%I\":function(t){return 0==(t=t.Gb)?t=12:12<t&&(t-=12),i(t,2)},\"%j\":function(t){for(var e=0,n=0;n<=t.Hb-1;e+=(pt(t.Cb+1900)?ht:dt)[n++]);return i(t.Kb+e,3)},\"%m\":function(t){return i(t.Hb+1,2)},\"%M\":function(t){return i(t.Zb,2)},\"%n\":function(){return\"\\\\n\"},\"%p\":function(t){return 0<=t.Gb&&12>t.Gb?\"AM\":\"PM\"},\"%S\":function(t){return i(t.$b,2)},\"%t\":function(){return\"\\\\t\"},\"%u\":function(t){return t.Ab||7},\"%U\":function(t){return i(Math.floor((t.Bb+7-t.Ab)/7),2)},\"%V\":function(t){var e=Math.floor((t.Bb+7-(t.Ab+6)%7)/7);if(2>=(t.Ab+371-t.Bb-2)%7&&e++,e)53==e&&(4==(n=(t.Ab+371-t.Bb)%7)||3==n&&pt(t.Cb)||(e=1));else{e=52;var n=(t.Ab+7-t.Bb-1)%7;(4==n||5==n&&pt(t.Cb%400-1))&&e++}return i(e,2)},\"%w\":function(t){return t.Ab},\"%W\":function(t){return i(Math.floor((t.Bb+7-(t.Ab+6)%7)/7),2)},\"%y\":function(t){return(t.Cb+1900).toString().substring(2)},\"%Y\":function(t){return t.Cb+1900},\"%z\":function(t){var e=0<=(t=t.Yb);return t=Math.abs(t)/60,(e?\"+\":\"-\")+String(\"0000\"+(t/60*100+t%60)).slice(-4)},\"%Z\":function(t){return t.ac},\"%%\":function(){return\"%\"}},n=n.replace(/%%/g,\"\\\\0\\\\0\"),s)n.includes(l)&&(n=n.replace(new RegExp(l,\"g\"),s[l](r)));return l=function(t){var e=Array(D(t)+1);return k(t,e,0,e.length),e}(n=n.replace(/\\\\0\\\\0/g,\"%\")),l.length>e?0:(S.set(l,t>>>0),l.length-1)}var bt={a:function(t){return gt(t+24)+24},m:function(t){return(t=new et(t)).Pb()||(t.Ib(!0),K--),t.Jb(!1),Q.push(t),t.Nb(),t.Qb()},ia:function(t){throw w(\"Unexpected exception thrown, this is not properly supported - aborting\"),C=!0,t},w:function(){Ot(0);var t=Q.pop();if(t.Xb()&&!t.Lb()){var e=t.Wb();e&&at(e)(t.Db),nt(t.Db)}tt=0},d:function(){var t=tt;if(!t)return ft=0;var e=new et(t);e.Fb(t);var n=e.Eb();if(!n)return ft=0,t;for(var r=Array.prototype.slice.call(arguments),a=0;a<r.length;a++){var i=r[a];if(0===i||i===n)break;if(Et(i,n,e.zb+16))return ft=i,t}return ft=n,t},k:function(){var t=tt;if(!t)return ft=0;var e=new et(t);e.Fb(t);var n=e.Eb();if(!n)return ft=0,t;for(var r=Array.prototype.slice.call(arguments),a=0;a<r.length;a++){var i=r[a];if(0===i||i===n)break;if(Et(i,n,e.zb+16))return ft=i,t}return ft=n,t},g:function(){var t=tt;if(!t)return ft=0;var e=new et(t);e.Fb(t);var n=e.Eb();if(!n)return ft=0,t;for(var r=Array.prototype.slice.call(arguments),a=0;a<r.length;a++){var i=r[a];if(0===i||i===n)break;if(Et(i,n,e.zb+16))return ft=i,t}return ft=n,t},s:nt,L:function(){var t=Q.pop();t||V(\"no exception to throw\");var e=t.Db;throw t.Lb()||(Q.push(t),t.Jb(!0),t.Ib(!1),K++),tt=e,e},b:function(t,e,n){throw new et(t).Rb(e,n),tt=t,K++,t},la:function(){return K},i:function(t){throw tt||(tt=t),t},H:function(){return 0},Ba:function(){},pa:function(){},ra:function(){},ka:function(){return 0},za:function(){},ua:function(){},ya:function(){},R:function(){},qa:function(){},na:function(){},Aa:function(){},oa:function(){},Ha:function(){},Ja:function(){V(\"To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking\")},Ia:function(){V(\"To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking\")},S:function(){return Date.now()},Ca:function(){return!0},Da:function(t,e){t=new Date(1e3*(M[t>>>2]+4294967296*E[t+4>>>2])),E[e>>2>>>0]=t.getUTCSeconds(),E[e+4>>2>>>0]=t.getUTCMinutes(),E[e+8>>2>>>0]=t.getUTCHours(),E[e+12>>2>>>0]=t.getUTCDate(),E[e+16>>2>>>0]=t.getUTCMonth(),E[e+20>>2>>>0]=t.getUTCFullYear()-1900,E[e+24>>2>>>0]=t.getUTCDay(),E[e+28>>2>>>0]=(t.getTime()-Date.UTC(t.getUTCFullYear(),0,1,0,0,0,0))/864e5|0},Ea:function(t,e){t=new Date(1e3*(M[t>>>2]+4294967296*E[t+4>>>2])),E[e>>2>>>0]=t.getSeconds(),E[e+4>>2>>>0]=t.getMinutes(),E[e+8>>2>>>0]=t.getHours(),E[e+12>>2>>>0]=t.getDate(),E[e+16>>2>>>0]=t.getMonth(),E[e+20>>2>>>0]=t.getFullYear()-1900,E[e+24>>2>>>0]=t.getDay();var n=new Date(t.getFullYear(),0,1);E[e+28>>2>>>0]=(t.getTime()-n.getTime())/864e5|0,E[e+36>>2>>>0]=-60*t.getTimezoneOffset();var r=new Date(t.getFullYear(),6,1).getTimezoneOffset();n=n.getTimezoneOffset(),E[e+32>>2>>>0]=0|(r!=n&&t.getTimezoneOffset()==Math.min(n,r))},Fa:function(t){var e=new Date(E[t+20>>2>>>0]+1900,E[t+16>>2>>>0],E[t+12>>2>>>0],E[t+8>>2>>>0],E[t+4>>2>>>0],E[t>>2>>>0],0),n=E[t+32>>2>>>0],r=e.getTimezoneOffset(),a=new Date(e.getFullYear(),0,1),i=new Date(e.getFullYear(),6,1).getTimezoneOffset(),o=a.getTimezoneOffset(),u=Math.min(o,i);return 0>n?E[t+32>>2>>>0]=Number(i!=o&&u==r):0<n!=(u==r)&&(i=Math.max(o,i),e.setTime(e.getTime()+6e4*((0<n?u:i)-r))),E[t+24>>2>>>0]=e.getDay(),E[t+28>>2>>>0]=(e.getTime()-a.getTime())/864e5|0,E[t>>2>>>0]=e.getSeconds(),E[t+4>>2>>>0]=e.getMinutes(),E[t+8>>2>>>0]=e.getHours(),E[t+12>>2>>>0]=e.getDate(),E[t+16>>2>>>0]=e.getMonth(),e.getTime()/1e3|0},sa:function(){return-52},ta:function(){},Ga:function t(e,n,r){t.Vb||(t.Vb=!0,function(t,e,n){function r(t){return(t=t.toTimeString().match(/\\\\(([A-Za-z ]+)\\\\)$/))?t[1]:\"GMT\"}var a=(new Date).getFullYear(),i=new Date(a,0,1),o=new Date(a,6,1);a=i.getTimezoneOffset();var u=o.getTimezoneOffset();E[t>>2>>>0]=60*Math.max(a,u),E[e>>2>>>0]=Number(a!=u),t=r(i),e=r(o),t=it(t),e=it(e),u<a?(M[n>>2>>>0]=t,M[n+4>>2>>>0]=e):(M[n>>2>>>0]=e,M[n+4>>2>>>0]=t)}(e,n,r))},B:function(){V(\"\")},ma:function(){return 4294901760},I:b?()=>{var t=process.hrtime();return 1e3*t[0]+t[1]/1e6}:()=>performance.now(),xa:function(t,e,n){T.copyWithin(t>>>0,e>>>0,e+n>>>0)},G:function(t){var e=T.length;if(4294901760<(t>>>=0))return!1;for(var n=1;4>=n;n*=2){var r=e*(1+.2/n);r=Math.min(r,t+100663296);var a=Math;r=Math.max(t,r),a=a.min.call(a,4294901760,r+(65536-r%65536)%65536);t:{try{O.grow(a-A.byteLength+65535>>>16),P();var i=1;break t}catch(t){}i=void 0}if(i)return!0}return!1},va:function(t,e){var n=0;return ut().forEach((function(r,a){var i=e+n;for(a=M[t+4*a>>2>>>0]=i,i=0;i<r.length;++i)S[a++>>0>>>0]=r.charCodeAt(i);S[a>>0>>>0]=0,n+=r.length+1})),0},wa:function(t,e){var n=ut();M[t>>2>>>0]=n.length;var r=0;return n.forEach((function(t){r+=t.length+1})),M[e>>2>>>0]=r,0},ba:function(t){_||0<L||(_t(),Z(W),wt(0),st[1].length&&lt(1,10),st[2].length&&lt(2,10)),_||0<L||(e.onExit&&e.onExit(t),C=!0),h(t,new J(t))},E:function(){return 52},Q:function(){return 52},ca:function(){return 70},P:function(t,e,n,r){for(var a=0,i=0;i<n;i++){var o=M[e>>2>>>0],u=M[e+4>>2>>>0];e+=8;for(var c=0;c<u;c++)lt(t,T[o+c>>>0]);a+=u}return M[r>>2>>>0]=a,0},c:function(){return ft},ja:function t(e,r){t.Mb||(t.Mb=function(){if(\"object\"==typeof crypto&&\"function\"==typeof crypto.getRandomValues){var t=new Uint8Array(1);return()=>(crypto.getRandomValues(t),t[0])}if(b)try{var e=n(Object(function(){var t=new Error(\"Cannot find module \\'crypto\\'\");throw t.code=\"MODULE_NOT_FOUND\",t}()));return()=>e.randomBytes(1)[0]}catch(t){}return()=>V(\"randomDevice\")}());for(var a=0;a<r;a++)S[e+a>>0>>>0]=t.Mb();return 0},ea:function(t,e,n){var r=At();try{return at(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},fa:function(t,e,n){var r=At();try{return at(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},J:function(t){var e=At();try{return at(t)()}catch(t){if(St(e),t!==t+0)throw t;Ot(1,0)}},e:function(t,e){var n=At();try{return at(t)(e)}catch(t){if(St(n),t!==t+0)throw t;Ot(1,0)}},N:function(t,e,n){var r=At();try{return at(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},O:function(t,e,n){var r=At();try{return at(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},j:function(t,e,n){var r=At();try{return at(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},o:function(t,e,n,r){var a=At();try{return at(t)(e,n,r)}catch(t){if(St(a),t!==t+0)throw t;Ot(1,0)}},p:function(t,e,n,r,a){var i=At();try{return at(t)(e,n,r,a)}catch(t){if(St(i),t!==t+0)throw t;Ot(1,0)}},M:function(t,e,n,r,a,i){var o=At();try{return at(t)(e,n,r,a,i)}catch(t){if(St(o),t!==t+0)throw t;Ot(1,0)}},r:function(t,e,n,r,a,i){var o=At();try{return at(t)(e,n,r,a,i)}catch(t){if(St(o),t!==t+0)throw t;Ot(1,0)}},v:function(t,e,n,r,a,i,o){var u=At();try{return at(t)(e,n,r,a,i,o)}catch(t){if(St(u),t!==t+0)throw t;Ot(1,0)}},K:function(t,e,n,r,a,i,o,u){var c=At();try{return at(t)(e,n,r,a,i,o,u)}catch(t){if(St(c),t!==t+0)throw t;Ot(1,0)}},D:function(t,e,n,r,a,i,o,u,c,s,l,f){var p=At();try{return at(t)(e,n,r,a,i,o,u,c,s,l,f)}catch(t){if(St(p),t!==t+0)throw t;Ot(1,0)}},X:function(t,e,n,r,a,i,o,u){var c=At();try{return Ft(t,e,n,r,a,i,o,u)}catch(t){if(St(c),t!==t+0)throw t;Ot(1,0)}},V:function(t,e,n,r,a,i,o){var u=At();try{return xt(t,e,n,r,a,i,o)}catch(t){if(St(u),t!==t+0)throw t;Ot(1,0)}},U:function(t,e,n,r,a){var i=At();try{return It(t,e,n,r,a)}catch(t){if(St(i),t!==t+0)throw t;Ot(1,0)}},Z:function(t,e,n,r){var a=At();try{return Pt(t,e,n,r)}catch(t){if(St(a),t!==t+0)throw t;Ot(1,0)}},W:function(t){var e=At();try{return Ct(t)}catch(t){if(St(e),t!==t+0)throw t;Ot(1,0)}},Y:function(t,e){var n=At();try{return Ut(t,e)}catch(t){if(St(n),t!==t+0)throw t;Ot(1,0)}},T:function(t,e,n){var r=At();try{return Rt(t,e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},f:function(t){var e=At();try{at(t)()}catch(t){if(St(e),t!==t+0)throw t;Ot(1,0)}},q:function(t,e){var n=At();try{at(t)(e)}catch(t){if(St(n),t!==t+0)throw t;Ot(1,0)}},h:function(t,e,n){var r=At();try{at(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},da:function(t,e,n,r){var a=At();try{at(t)(e,n,r)}catch(t){if(St(a),t!==t+0)throw t;Ot(1,0)}},l:function(t,e,n,r){var a=At();try{at(t)(e,n,r)}catch(t){if(St(a),t!==t+0)throw t;Ot(1,0)}},t:function(t,e,n,r,a){var i=At();try{at(t)(e,n,r,a)}catch(t){if(St(i),t!==t+0)throw t;Ot(1,0)}},u:function(t,e,n,r,a,i){var o=At();try{at(t)(e,n,r,a,i)}catch(t){if(St(o),t!==t+0)throw t;Ot(1,0)}},x:function(t,e,n,r,a,i,o){var u=At();try{at(t)(e,n,r,a,i,o)}catch(t){if(St(u),t!==t+0)throw t;Ot(1,0)}},z:function(t,e,n,r,a,i,o,u){var c=At();try{at(t)(e,n,r,a,i,o,u)}catch(t){if(St(c),t!==t+0)throw t;Ot(1,0)}},ga:function(t,e,n,r,a,i,o,u,c){var s=At();try{at(t)(e,n,r,a,i,o,u,c)}catch(t){if(St(s),t!==t+0)throw t;Ot(1,0)}},A:function(t,e,n,r,a,i,o,u,c,s,l){var f=At();try{at(t)(e,n,r,a,i,o,u,c,s,l)}catch(t){if(St(f),t!==t+0)throw t;Ot(1,0)}},C:function(t,e,n,r,a,i,o,u,c,s,l,f,p,h,d,y){var b=At();try{at(t)(e,n,r,a,i,o,u,c,s,l,f,p,h,d,y)}catch(t){if(St(b),t!==t+0)throw t;Ot(1,0)}},aa:function(t,e,n,r,a,i,o,u){var c=At();try{jt(t,e,n,r,a,i,o,u)}catch(t){if(St(c),t!==t+0)throw t;Ot(1,0)}},_:function(t,e,n,r,a,i,o,u,c,s,l,f){var p=At();try{Dt(t,e,n,r,a,i,o,u,c,s,l,f)}catch(t){if(St(p),t!==t+0)throw t;Ot(1,0)}},$:function(t,e,n,r,a,i){var o=At();try{kt(t,e,n,r,a,i)}catch(t){if(St(o),t!==t+0)throw t;Ot(1,0)}},n:function(t){return t},F:function(t){ft=t},ha:yt,y:function(t,e,n,r){return yt(t,e,n,r)}};!function(){function t(t){e.asm=t.exports,O=e.asm.Ka,P(),U=e.asm.ib,I.unshift(e.asm.La),B--,e.monitorRunDependencies&&e.monitorRunDependencies(B),0==B&&(null!==G&&(clearInterval(G),G=null),N&&(t=N,N=null,t()))}function n(e){t(e.instance)}function r(t){return function(){if(!g&&(d||y)){if(\"function\"==typeof fetch&&!Y.startsWith(\"file://\"))return fetch(Y,{credentials:\"same-origin\"}).then((function(t){if(!t.ok)throw\"failed to load wasm binary file at \\'\"+Y+\"\\'\";return t.arrayBuffer()})).catch((function(){return X()}));if(o)return new Promise((function(t,e){o(Y,(function(e){t(new Uint8Array(e))}),e)}))}return Promise.resolve().then((function(){return X()}))}().then((function(t){return WebAssembly.instantiate(t,i)})).then((function(t){return t})).then(t,(function(t){w(\"failed to asynchronously prepare wasm: \"+t),V(t)}))}var i={a:bt};if(B++,e.monitorRunDependencies&&e.monitorRunDependencies(B),e.instantiateWasm)try{return e.instantiateWasm(i,t)}catch(t){return w(\"Module.instantiateWasm callback failed with error: \"+t),!1}(g||\"function\"!=typeof WebAssembly.instantiateStreaming||$()||Y.startsWith(\"file://\")||b||\"function\"!=typeof fetch?r(n):fetch(Y,{credentials:\"same-origin\"}).then((function(t){return WebAssembly.instantiateStreaming(t,i).then(n,(function(t){return w(\"wasm streaming compile failed: \"+t),w(\"falling back to ArrayBuffer instantiation\"),r(n)}))}))).catch(a)}(),e.___wasm_call_ctors=function(){return(e.___wasm_call_ctors=e.asm.La).apply(null,arguments)},e._OrtInit=function(){return(e._OrtInit=e.asm.Ma).apply(null,arguments)},e._OrtCreateSessionOptions=function(){return(e._OrtCreateSessionOptions=e.asm.Na).apply(null,arguments)},e._OrtAppendExecutionProvider=function(){return(e._OrtAppendExecutionProvider=e.asm.Oa).apply(null,arguments)},e._OrtAddSessionConfigEntry=function(){return(e._OrtAddSessionConfigEntry=e.asm.Pa).apply(null,arguments)},e._OrtReleaseSessionOptions=function(){return(e._OrtReleaseSessionOptions=e.asm.Qa).apply(null,arguments)},e._OrtCreateSession=function(){return(e._OrtCreateSession=e.asm.Ra).apply(null,arguments)},e._OrtReleaseSession=function(){return(e._OrtReleaseSession=e.asm.Sa).apply(null,arguments)},e._OrtGetInputCount=function(){return(e._OrtGetInputCount=e.asm.Ta).apply(null,arguments)},e._OrtGetOutputCount=function(){return(e._OrtGetOutputCount=e.asm.Ua).apply(null,arguments)},e._OrtGetInputName=function(){return(e._OrtGetInputName=e.asm.Va).apply(null,arguments)},e._OrtGetOutputName=function(){return(e._OrtGetOutputName=e.asm.Wa).apply(null,arguments)},e._OrtFree=function(){return(e._OrtFree=e.asm.Xa).apply(null,arguments)},e._OrtCreateTensor=function(){return(e._OrtCreateTensor=e.asm.Ya).apply(null,arguments)},e._OrtGetTensorData=function(){return(e._OrtGetTensorData=e.asm.Za).apply(null,arguments)},e._OrtReleaseTensor=function(){return(e._OrtReleaseTensor=e.asm._a).apply(null,arguments)},e._OrtCreateRunOptions=function(){return(e._OrtCreateRunOptions=e.asm.$a).apply(null,arguments)},e._OrtAddRunConfigEntry=function(){return(e._OrtAddRunConfigEntry=e.asm.ab).apply(null,arguments)},e._OrtReleaseRunOptions=function(){return(e._OrtReleaseRunOptions=e.asm.bb).apply(null,arguments)},e._OrtRun=function(){return(e._OrtRun=e.asm.cb).apply(null,arguments)},e._OrtEndProfiling=function(){return(e._OrtEndProfiling=e.asm.db).apply(null,arguments)};var mt,gt=e._malloc=function(){return(gt=e._malloc=e.asm.eb).apply(null,arguments)},vt=e._free=function(){return(vt=e._free=e.asm.fb).apply(null,arguments)},wt=e._fflush=function(){return(wt=e._fflush=e.asm.gb).apply(null,arguments)},_t=e.___funcs_on_exit=function(){return(_t=e.___funcs_on_exit=e.asm.hb).apply(null,arguments)},Ot=e._setThrew=function(){return(Ot=e._setThrew=e.asm.jb).apply(null,arguments)},At=e.stackSave=function(){return(At=e.stackSave=e.asm.kb).apply(null,arguments)},St=e.stackRestore=function(){return(St=e.stackRestore=e.asm.lb).apply(null,arguments)},Tt=e.stackAlloc=function(){return(Tt=e.stackAlloc=e.asm.mb).apply(null,arguments)},Et=e.___cxa_can_catch=function(){return(Et=e.___cxa_can_catch=e.asm.nb).apply(null,arguments)},Mt=e.___cxa_is_pointer_type=function(){return(Mt=e.___cxa_is_pointer_type=e.asm.ob).apply(null,arguments)},Ct=e.dynCall_j=function(){return(Ct=e.dynCall_j=e.asm.pb).apply(null,arguments)},xt=e.dynCall_iiiiij=function(){return(xt=e.dynCall_iiiiij=e.asm.qb).apply(null,arguments)},Rt=e.dynCall_jii=function(){return(Rt=e.dynCall_jii=e.asm.rb).apply(null,arguments)},jt=e.dynCall_viiiiij=function(){return(jt=e.dynCall_viiiiij=e.asm.sb).apply(null,arguments)},kt=e.dynCall_vjji=function(){return(kt=e.dynCall_vjji=e.asm.tb).apply(null,arguments)},Dt=e.dynCall_viiijjjii=function(){return(Dt=e.dynCall_viiijjjii=e.asm.ub).apply(null,arguments)},Pt=e.dynCall_iij=function(){return(Pt=e.dynCall_iij=e.asm.vb).apply(null,arguments)},Ut=e.dynCall_ji=function(){return(Ut=e.dynCall_ji=e.asm.wb).apply(null,arguments)},Ft=e.dynCall_iiiiiij=function(){return(Ft=e.dynCall_iiiiiij=e.asm.xb).apply(null,arguments)},It=e.dynCall_iiij=function(){return(It=e.dynCall_iiij=e.asm.yb).apply(null,arguments)};function Wt(){function t(){if(!mt&&(mt=!0,e.calledRun=!0,!C)){if(Z(I),r(e),e.onRuntimeInitialized&&e.onRuntimeInitialized(),e.postRun)for(\"function\"==typeof e.postRun&&(e.postRun=[e.postRun]);e.postRun.length;){var t=e.postRun.shift();H.unshift(t)}Z(H)}}if(!(0<B)){if(e.preRun)for(\"function\"==typeof e.preRun&&(e.preRun=[e.preRun]);e.preRun.length;)z();Z(F),0<B||(e.setStatus?(e.setStatus(\"Running...\"),setTimeout((function(){setTimeout((function(){e.setStatus(\"\")}),1),t()}),1)):t())}}if(e.UTF8ToString=j,e.stringToUTF8=function(t,e,n){return k(t,T,e,n)},e.lengthBytesUTF8=D,e.stackSave=At,e.stackRestore=St,e.stackAlloc=Tt,N=function t(){mt||Wt(),mt||(N=t)},e.preInit)for(\"function\"==typeof e.preInit&&(e.preInit=[e.preInit]);0<e.preInit.length;)e.preInit.pop()();return Wt(),t.ready});t.exports=r},967:(t,e)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.iterateExtraOptions=void 0,e.iterateExtraOptions=(t,n,r,a)=>{if(\"object\"==typeof t&&null!==t){if(r.has(t))throw new Error(\"Circular reference in options\");r.add(t)}Object.entries(t).forEach((([t,i])=>{const o=n?n+t:t;if(\"object\"==typeof i)(0,e.iterateExtraOptions)(i,o+\".\",r,a);else if(\"string\"==typeof i||\"number\"==typeof i)a(o,i.toString());else{if(\"boolean\"!=typeof i)throw new Error(\"Can\\'t handle extra config type: \"+typeof i);a(o,i?\"1\":\"0\")}}))}},586:(t,e,n)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.setRunOptions=void 0;const r=n(967),a=n(983),i=n(361);e.setRunOptions=t=>{const e=(0,i.getInstance)();let n=0;const o=[],u=t||{};try{if(void 0===(null==t?void 0:t.logSeverityLevel))u.logSeverityLevel=2;else if(\"number\"!=typeof t.logSeverityLevel||!Number.isInteger(t.logSeverityLevel)||t.logSeverityLevel<0||t.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${t.logSeverityLevel}`);if(void 0===(null==t?void 0:t.logVerbosityLevel))u.logVerbosityLevel=0;else if(\"number\"!=typeof t.logVerbosityLevel||!Number.isInteger(t.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${t.logVerbosityLevel}`);void 0===(null==t?void 0:t.terminate)&&(u.terminate=!1);let i=0;if(void 0!==(null==t?void 0:t.tag)&&(i=(0,a.allocWasmString)(t.tag,o)),n=e._OrtCreateRunOptions(u.logSeverityLevel,u.logVerbosityLevel,!!u.terminate,i),0===n)throw new Error(\"Can\\'t create run options\");return void 0!==(null==t?void 0:t.extra)&&(0,r.iterateExtraOptions)(t.extra,\"\",new WeakSet,((t,r)=>{const i=(0,a.allocWasmString)(t,o),u=(0,a.allocWasmString)(r,o);if(0!==e._OrtAddRunConfigEntry(n,i,u))throw new Error(`Can\\'t set a run config entry: ${t} - ${r}`)})),[n,o]}catch(t){throw 0!==n&&e._OrtReleaseRunOptions(n),o.forEach(e._free),t}}},919:(t,e,n)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.setSessionOptions=void 0;const r=n(967),a=n(983),i=n(361);e.setSessionOptions=t=>{const e=(0,i.getInstance)();let n=0;const o=[],u=t||{};(t=>{t.extra||(t.extra={}),t.extra.session||(t.extra.session={});const e=t.extra.session;e.use_ort_model_bytes_directly||(e.use_ort_model_bytes_directly=\"1\")})(u);try{void 0===(null==t?void 0:t.graphOptimizationLevel)&&(u.graphOptimizationLevel=\"all\");const c=(t=>{switch(t){case\"disabled\":return 0;case\"basic\":return 1;case\"extended\":return 2;case\"all\":return 99;default:throw new Error(`unsupported graph optimization level: ${t}`)}})(u.graphOptimizationLevel);void 0===(null==t?void 0:t.enableCpuMemArena)&&(u.enableCpuMemArena=!0),void 0===(null==t?void 0:t.enableMemPattern)&&(u.enableMemPattern=!0),void 0===(null==t?void 0:t.executionMode)&&(u.executionMode=\"sequential\");const s=(t=>{switch(t){case\"sequential\":return 0;case\"parallel\":return 1;default:throw new Error(`unsupported execution mode: ${t}`)}})(u.executionMode);let l=0;if(void 0!==(null==t?void 0:t.logId)&&(l=(0,a.allocWasmString)(t.logId,o)),void 0===(null==t?void 0:t.logSeverityLevel))u.logSeverityLevel=2;else if(\"number\"!=typeof t.logSeverityLevel||!Number.isInteger(t.logSeverityLevel)||t.logSeverityLevel<0||t.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${t.logSeverityLevel}`);if(void 0===(null==t?void 0:t.logVerbosityLevel))u.logVerbosityLevel=0;else if(\"number\"!=typeof t.logVerbosityLevel||!Number.isInteger(t.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${t.logVerbosityLevel}`);if(void 0===(null==t?void 0:t.enableProfiling)&&(u.enableProfiling=!1),n=e._OrtCreateSessionOptions(c,!!u.enableCpuMemArena,!!u.enableMemPattern,s,!!u.enableProfiling,0,l,u.logSeverityLevel,u.logVerbosityLevel),0===n)throw new Error(\"Can\\'t create session options\");return(null==t?void 0:t.executionProviders)&&((t,e,n)=>{for(const r of e){let e=\"string\"==typeof r?r:r.name;switch(e){case\"xnnpack\":e=\"XNNPACK\";break;case\"wasm\":case\"cpu\":continue;default:throw new Error(`not supported EP: ${e}`)}const o=(0,a.allocWasmString)(e,n);if(0!==(0,i.getInstance)()._OrtAppendExecutionProvider(t,o))throw new Error(`Can\\'t append execution provider: ${e}`)}})(n,t.executionProviders,o),void 0!==(null==t?void 0:t.extra)&&(0,r.iterateExtraOptions)(t.extra,\"\",new WeakSet,((t,r)=>{const i=(0,a.allocWasmString)(t,o),u=(0,a.allocWasmString)(r,o);if(0!==e._OrtAddSessionConfigEntry(n,i,u))throw new Error(`Can\\'t set a session config entry: ${t} - ${r}`)})),[n,o]}catch(t){throw 0!==n&&e._OrtReleaseSessionOptions(n),o.forEach(e._free),t}}},983:(t,e,n)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.allocWasmString=void 0;const r=n(361);e.allocWasmString=(t,e)=>{const n=(0,r.getInstance)(),a=n.lengthBytesUTF8(t)+1,i=n._malloc(a);return n.stringToUTF8(t,i,a),e.push(i),i}},349:(t,e,n)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.extractTransferableBuffers=e.endProfiling=e.run=e.releaseSession=e.createSession=e.createSessionFinalize=e.createSessionAllocate=e.initOrt=void 0;const r=n(586),a=n(919),i=n(983),o=n(361);e.initOrt=(t,e)=>{const n=(0,o.getInstance)()._OrtInit(t,e);if(0!==n)throw new Error(`Can\\'t initialize onnxruntime. error code = ${n}`)};const u=new Map;e.createSessionAllocate=t=>{const e=(0,o.getInstance)(),n=e._malloc(t.byteLength);return e.HEAPU8.set(t,n),[n,t.byteLength]},e.createSessionFinalize=(t,e)=>{const n=(0,o.getInstance)();let r=0,i=0,c=[];try{if([i,c]=(0,a.setSessionOptions)(e),r=n._OrtCreateSession(t[0],t[1],i),0===r)throw new Error(\"Can\\'t create a session\")}finally{n._free(t[0]),n._OrtReleaseSessionOptions(i),c.forEach(n._free)}const s=n._OrtGetInputCount(r),l=n._OrtGetOutputCount(r),f=[],p=[],h=[],d=[];for(let t=0;t<s;t++){const e=n._OrtGetInputName(r,t);if(0===e)throw new Error(\"Can\\'t get an input name\");p.push(e),f.push(n.UTF8ToString(e))}for(let t=0;t<l;t++){const e=n._OrtGetOutputName(r,t);if(0===e)throw new Error(\"Can\\'t get an output name\");d.push(e),h.push(n.UTF8ToString(e))}return u.set(r,[r,p,d]),[r,f,h]},e.createSession=(t,n)=>{const r=(0,e.createSessionAllocate)(t);return(0,e.createSessionFinalize)(r,n)},e.releaseSession=t=>{const e=(0,o.getInstance)(),n=u.get(t);if(!n)throw new Error(\"invalid session id\");const r=n[0],a=n[1],i=n[2];a.forEach(e._OrtFree),i.forEach(e._OrtFree),e._OrtReleaseSession(r),u.delete(t)};const c=t=>{switch(t){case\"int8\":return 3;case\"uint8\":return 2;case\"bool\":return 9;case\"int16\":return 5;case\"uint16\":return 4;case\"int32\":return 6;case\"uint32\":return 12;case\"float32\":return 1;case\"float64\":return 11;case\"string\":return 8;case\"int64\":return 7;case\"uint64\":return 13;default:throw new Error(`unsupported data type: ${t}`)}},s=t=>{switch(t){case 3:return\"int8\";case 2:return\"uint8\";case 9:return\"bool\";case 5:return\"int16\";case 4:return\"uint16\";case 6:return\"int32\";case 12:return\"uint32\";case 1:return\"float32\";case 11:return\"float64\";case 8:return\"string\";case 7:return\"int64\";case 13:return\"uint64\";default:throw new Error(`unsupported data type: ${t}`)}},l=t=>{switch(t){case\"float32\":return Float32Array;case\"uint8\":case\"bool\":return Uint8Array;case\"int8\":return Int8Array;case\"uint16\":return Uint16Array;case\"int16\":return Int16Array;case\"int32\":return Int32Array;case\"float64\":return Float64Array;case\"uint32\":return Uint32Array;case\"int64\":return BigInt64Array;case\"uint64\":return BigUint64Array;default:throw new Error(`unsupported type: ${t}`)}};e.run=(t,e,n,a,f)=>{const p=(0,o.getInstance)(),h=u.get(t);if(!h)throw new Error(\"invalid session id\");const d=h[0],y=h[1],b=h[2],m=e.length,g=a.length;let v=0,w=[];const _=[],O=[];try{[v,w]=(0,r.setRunOptions)(f);for(let t=0;t<m;t++){const e=n[t][0],r=n[t][1],a=n[t][2];let o,u;if(Array.isArray(a)){u=4*a.length,o=p._malloc(u),O.push(o);let t=o/4;for(let e=0;e<a.length;e++){if(\"string\"!=typeof a[e])throw new TypeError(`tensor data at index ${e} is not a string`);p.HEAPU32[t++]=(0,i.allocWasmString)(a[e],O)}}else u=a.byteLength,o=p._malloc(u),O.push(o),p.HEAPU8.set(new Uint8Array(a.buffer,a.byteOffset,u),o);const s=p.stackSave(),l=p.stackAlloc(4*r.length);try{let t=l/4;r.forEach((e=>p.HEAP32[t++]=e));const n=p._OrtCreateTensor(c(e),o,u,l,r.length);if(0===n)throw new Error(\"Can\\'t create a tensor\");_.push(n)}finally{p.stackRestore(s)}}const t=p.stackSave(),o=p.stackAlloc(4*m),u=p.stackAlloc(4*m),h=p.stackAlloc(4*g),A=p.stackAlloc(4*g);try{let n=o/4,r=u/4,i=h/4,c=A/4;for(let t=0;t<m;t++)p.HEAPU32[n++]=_[t],p.HEAPU32[r++]=y[e[t]];for(let t=0;t<g;t++)p.HEAPU32[i++]=0,p.HEAPU32[c++]=b[a[t]];let f=p._OrtRun(d,u,o,m,A,g,h,v);const w=[];if(0===f)for(let t=0;t<g;t++){const e=p.HEAPU32[h/4+t],n=p.stackSave(),r=p.stackAlloc(16);let a,i=0;try{if(f=p._OrtGetTensorData(e,r,r+4,r+8,r+12),0!==f)throw new Error(`Can\\'t access output tensor data. error code = ${f}`);let t=r/4;const o=p.HEAPU32[t++];i=p.HEAPU32[t++];const u=p.HEAPU32[t++],c=p.HEAPU32[t++],h=[];for(let t=0;t<c;t++)h.push(p.HEAPU32[u/4+t]);p._OrtFree(u);const d=0===h.length?1:h.reduce(((t,e)=>t*e));if(a=s(o),\"string\"===a){const t=[];let e=i/4;for(let n=0;n<d;n++){const r=p.HEAPU32[e++],a=n===d-1?void 0:p.HEAPU32[e]-r;t.push(p.UTF8ToString(r,a))}w.push([a,h,t])}else{const t=new(l(a))(d);new Uint8Array(t.buffer,t.byteOffset,t.byteLength).set(p.HEAPU8.subarray(i,i+t.byteLength)),w.push([a,h,t])}}finally{p.stackRestore(n),\"string\"===a&&i&&p._free(i),p._OrtReleaseTensor(e)}}if(0===f)return w;throw new Error(`failed to call OrtRun(). error code = ${f}.`)}finally{p.stackRestore(t)}}finally{_.forEach(p._OrtReleaseTensor),O.forEach(p._free),p._OrtReleaseRunOptions(v),w.forEach(p._free)}},e.endProfiling=t=>{const e=(0,o.getInstance)(),n=u.get(t);if(!n)throw new Error(\"invalid session id\");const r=n[0],a=e._OrtEndProfiling(r);if(0===a)throw new Error(\"Can\\'t get an profile file name\");e._OrtFree(a)},e.extractTransferableBuffers=t=>{const e=[];for(const n of t){const t=n[2];!Array.isArray(t)&&t.buffer&&e.push(t.buffer)}return e}},361:function(t,e,n){\"use strict\";var r=this&&this.__createBinding||(Object.create?function(t,e,n,r){void 0===r&&(r=n);var a=Object.getOwnPropertyDescriptor(e,n);a&&!(\"get\"in a?!e.__esModule:a.writable||a.configurable)||(a={enumerable:!0,get:function(){return e[n]}}),Object.defineProperty(t,r,a)}:function(t,e,n,r){void 0===r&&(r=n),t[r]=e[n]}),a=this&&this.__setModuleDefault||(Object.create?function(t,e){Object.defineProperty(t,\"default\",{enumerable:!0,value:e})}:function(t,e){t.default=e}),i=this&&this.__importStar||function(t){if(t&&t.__esModule)return t;var e={};if(null!=t)for(var n in t)\"default\"!==n&&Object.prototype.hasOwnProperty.call(t,n)&&r(e,t,n);return a(e,t),e},o=this&&this.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(e,\"__esModule\",{value:!0}),e.dispose=e.getInstance=e.initializeWebAssembly=void 0;const u=i(n(449)),c=o(n(932)),s=n(474);let l,f=!1,p=!1,h=!1;const d=(t,e)=>e?t?\"ort-wasm-simd-threaded.wasm\":\"ort-wasm-threaded.wasm\":t?\"ort-wasm-simd.wasm\":\"ort-wasm.wasm\";e.initializeWebAssembly=async t=>{if(f)return Promise.resolve();if(p)throw new Error(\"multiple calls to \\'initializeWebAssembly()\\' detected.\");if(h)throw new Error(\"previous call to \\'initializeWebAssembly()\\' failed.\");p=!0;const e=t.initTimeout,r=t.numThreads,a=t.simd,i=r>1&&(()=>{try{return\"undefined\"!=typeof SharedArrayBuffer&&(\"undefined\"!=typeof MessageChannel&&(new MessageChannel).port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11])))}catch(t){return!1}})(),o=a&&(()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch(t){return!1}})(),y=\"string\"==typeof t.wasmPaths?t.wasmPaths:void 0,b=d(!1,i),m=d(o,i),g=\"object\"==typeof t.wasmPaths?t.wasmPaths[m]:void 0;let v=!1;const w=[];if(e>0&&w.push(new Promise((t=>{setTimeout((()=>{v=!0,t()}),e)}))),w.push(new Promise(((t,e)=>{const r=i?s:c.default,a={locateFile:(t,e)=>i&&t.endsWith(\".worker.js\")&&\"undefined\"!=typeof Blob?URL.createObjectURL(new Blob([n(154)],{type:\"text/javascript\"})):t===b?null!=g?g:(null!=y?y:e)+m:e+t};if(i)if(\"undefined\"==typeof Blob)a.mainScriptUrlOrBlob=u.join(\"/\",\"ort-wasm-threaded.js\");else{const t=`var ortWasmThreaded=(function(){var _scriptDir;return ${r.toString()}})();`;a.mainScriptUrlOrBlob=new Blob([t],{type:\"text/javascript\"})}r(a).then((e=>{p=!1,f=!0,l=e,t()}),(t=>{p=!1,h=!0,e(t)}))}))),await Promise.race(w),v)throw new Error(`WebAssembly backend initializing failed due to timeout: ${e}ms`)},e.getInstance=()=>{if(f&&l)return l;throw new Error(\"WebAssembly is not initialized yet.\")},e.dispose=()=>{var t;!f||p||h||(p=!0,null===(t=l.PThread)||void 0===t||t.terminateAllThreads(),l=void 0,p=!1,f=!1,h=!0)}},154:t=>{\"use strict\";t.exports=\\'\"use strict\";var e={},t=\"object\"==typeof process&&\"object\"==typeof process.versions&&\"string\"==typeof process.versions.node;if(t){var r=require(\"worker_threads\"),a=r.parentPort;a.on(\"message\",(e=>onmessage({data:e})));var o=require(\"fs\");Object.assign(global,{self:global,require:require,Module:e,location:{href:__filename},Worker:r.Worker,importScripts:function(e){(0,eval)(o.readFileSync(e,\"utf8\"))},postMessage:function(e){a.postMessage(e)},performance:global.performance||{now:function(){return Date.now()}}})}var s=!1,n=[],i=function(){var e=Array.prototype.slice.call(arguments).join(\" \");t?o.writeSync(2,e+\"\\\\\\\\n\"):console.error(e)};self.alert=function(){var t=Array.prototype.slice.call(arguments).join(\" \");postMessage({cmd:\"alert\",text:t,threadId:e._pthread_self()})},e.instantiateWasm=(t,r)=>{var a=new WebAssembly.Instance(e.wasmModule,t);return r(a),e.wasmModule=null,a.exports},self.onunhandledrejection=e=>{throw e.reason??e},self.onmessage=t=>{try{if(\"load\"===t.data.cmd){if(e.wasmModule=t.data.wasmModule,e.wasmMemory=t.data.wasmMemory,e.buffer=e.wasmMemory.buffer,e.ENVIRONMENT_IS_PTHREAD=!0,\"string\"==typeof t.data.urlOrBlob)importScripts(t.data.urlOrBlob);else{var r=URL.createObjectURL(t.data.urlOrBlob);importScripts(r),URL.revokeObjectURL(r)}ortWasmThreaded(e).then((function(t){e=t}))}else if(\"run\"===t.data.cmd){e.__performance_now_clock_drift=performance.now()-t.data.time,e.__emscripten_thread_init(t.data.pthread_ptr,0,0,1),e.establishStackSpace(),e.PThread.receiveObjectTransfer(t.data),e.PThread.threadInitTLS(),s||(n.forEach((t=>{e.executeNotifiedProxyingQueue(t)})),n=[],s=!0);try{e.invokeEntryPoint(t.data.start_routine,t.data.arg)}catch(t){if(\"unwind\"!=t){if(!(t instanceof e.ExitStatus))throw t;e.keepRuntimeAlive()||e.__emscripten_thread_exit(t.status)}}}else\"cancel\"===t.data.cmd?e._pthread_self()&&e.__emscripten_thread_exit(-1):\"setimmediate\"===t.data.target||(\"processProxyingQueue\"===t.data.cmd?s?e.executeNotifiedProxyingQueue(t.data.queue):n.push(t.data.queue):(i(\"worker.js received unknown command \"+t.data.cmd),i(t.data)))}catch(t){throw i(\"worker.js onmessage() captured an uncaught exception: \"+t),t&&t.stack&&i(t.stack),e.__emscripten_thread_crashed&&e.__emscripten_thread_crashed(),t}};\\\\n\\'},384:()=>{},993:()=>{},908:()=>{},953:()=>{},925:()=>{},449:()=>{}},e={};function n(r){var a=e[r];if(void 0!==a)return a.exports;var i=e[r]={exports:{}};return t[r].call(i.exports,i,i.exports,n),i.exports}n.g=function(){if(\"object\"==typeof globalThis)return globalThis;try{return this||new Function(\"return this\")()}catch(t){if(\"object\"==typeof window)return window}}(),(()=>{\"use strict\";const t=n(349),e=n(361);self.onmessage=n=>{switch(n.data.type){case\"init-wasm\":(0,e.initializeWebAssembly)(n.data.in).then((()=>postMessage({type:\"init-wasm\"})),(t=>postMessage({type:\"init-wasm\",err:t})));break;case\"init-ort\":try{const{numThreads:e,loggingLevel:r}=n.data.in;(0,t.initOrt)(e,r),postMessage({type:\"init-ort\"})}catch(t){postMessage({type:\"init-ort\",err:t})}break;case\"create_allocate\":try{const{model:e}=n.data.in,r=(0,t.createSessionAllocate)(e);postMessage({type:\"create_allocate\",out:r})}catch(t){postMessage({type:\"create_allocate\",err:t})}break;case\"create_finalize\":try{const{modeldata:e,options:r}=n.data.in,a=(0,t.createSessionFinalize)(e,r);postMessage({type:\"create_finalize\",out:a})}catch(t){postMessage({type:\"create_finalize\",err:t})}break;case\"create\":try{const{model:e,options:r}=n.data.in,a=(0,t.createSession)(e,r);postMessage({type:\"create\",out:a})}catch(t){postMessage({type:\"create\",err:t})}break;case\"release\":try{const e=n.data.in;(0,t.releaseSession)(e),postMessage({type:\"release\"})}catch(t){postMessage({type:\"release\",err:t})}break;case\"run\":try{const{sessionId:e,inputIndices:r,inputs:a,outputIndices:i,options:o}=n.data.in,u=(0,t.run)(e,r,a,i,o);postMessage({type:\"run\",out:u},(0,t.extractTransferableBuffers)(u))}catch(t){postMessage({type:\"run\",err:t})}break;case\"end-profiling\":try{const e=n.data.in;(0,t.endProfiling)(e),postMessage({type:\"end-profiling\"})}catch(t){postMessage({type:\"end-profiling\",err:t})}}}})()})();\\n',\"Worker\",void 0,void 0)}},477:t=>{\"use strict\";t.exports=function(t,e,n,r){var i=self||window;try{try{var o;try{o=new i.Blob([t])}catch(e){(o=new(i.BlobBuilder||i.WebKitBlobBuilder||i.MozBlobBuilder||i.MSBlobBuilder)).append(t),o=o.getBlob()}var a=i.URL||i.webkitURL,s=a.createObjectURL(o),u=new i[e](s,n);return a.revokeObjectURL(s),u}catch(r){return new i[e](\"data:application/javascript,\".concat(encodeURIComponent(t)),n)}}catch(t){if(!r)throw Error(\"Inline worker is not supported\");return new i[e](r,n)}}},4154:t=>{\"use strict\";t.exports='\"use strict\";var e={},t=\"object\"==typeof process&&\"object\"==typeof process.versions&&\"string\"==typeof process.versions.node;if(t){var r=require(\"worker_threads\"),a=r.parentPort;a.on(\"message\",(e=>onmessage({data:e})));var o=require(\"fs\");Object.assign(global,{self:global,require:require,Module:e,location:{href:__filename},Worker:r.Worker,importScripts:function(e){(0,eval)(o.readFileSync(e,\"utf8\"))},postMessage:function(e){a.postMessage(e)},performance:global.performance||{now:function(){return Date.now()}}})}var s=!1,n=[],i=function(){var e=Array.prototype.slice.call(arguments).join(\" \");t?o.writeSync(2,e+\"\\\\n\"):console.error(e)};self.alert=function(){var t=Array.prototype.slice.call(arguments).join(\" \");postMessage({cmd:\"alert\",text:t,threadId:e._pthread_self()})},e.instantiateWasm=(t,r)=>{var a=new WebAssembly.Instance(e.wasmModule,t);return r(a),e.wasmModule=null,a.exports},self.onunhandledrejection=e=>{throw e.reason??e},self.onmessage=t=>{try{if(\"load\"===t.data.cmd){if(e.wasmModule=t.data.wasmModule,e.wasmMemory=t.data.wasmMemory,e.buffer=e.wasmMemory.buffer,e.ENVIRONMENT_IS_PTHREAD=!0,\"string\"==typeof t.data.urlOrBlob)importScripts(t.data.urlOrBlob);else{var r=URL.createObjectURL(t.data.urlOrBlob);importScripts(r),URL.revokeObjectURL(r)}ortWasmThreaded(e).then((function(t){e=t}))}else if(\"run\"===t.data.cmd){e.__performance_now_clock_drift=performance.now()-t.data.time,e.__emscripten_thread_init(t.data.pthread_ptr,0,0,1),e.establishStackSpace(),e.PThread.receiveObjectTransfer(t.data),e.PThread.threadInitTLS(),s||(n.forEach((t=>{e.executeNotifiedProxyingQueue(t)})),n=[],s=!0);try{e.invokeEntryPoint(t.data.start_routine,t.data.arg)}catch(t){if(\"unwind\"!=t){if(!(t instanceof e.ExitStatus))throw t;e.keepRuntimeAlive()||e.__emscripten_thread_exit(t.status)}}}else\"cancel\"===t.data.cmd?e._pthread_self()&&e.__emscripten_thread_exit(-1):\"setimmediate\"===t.data.target||(\"processProxyingQueue\"===t.data.cmd?s?e.executeNotifiedProxyingQueue(t.data.queue):n.push(t.data.queue):(i(\"worker.js received unknown command \"+t.data.cmd),i(t.data)))}catch(t){throw i(\"worker.js onmessage() captured an uncaught exception: \"+t),t&&t.stack&&i(t.stack),e.__emscripten_thread_crashed&&e.__emscripten_thread_crashed(),t}};\\n'},1670:t=>{\"use strict\";t.exports=__WEBPACK_EXTERNAL_MODULE__1670__},7067:()=>{},1296:()=>{},1384:()=>{},3993:()=>{},908:()=>{},6953:()=>{},9925:()=>{},2806:()=>{},6449:()=>{},2850:()=>{},5381:()=>{},5686:(t,e,n)=>{\"use strict\";n.r(e),n.d(e,{flatbuffers:()=>r});var r={};r.Offset,r.Table,r.SIZEOF_SHORT=2,r.SIZEOF_INT=4,r.FILE_IDENTIFIER_LENGTH=4,r.SIZE_PREFIX_LENGTH=4,r.Encoding={UTF8_BYTES:1,UTF16_STRING:2},r.int32=new Int32Array(2),r.float32=new Float32Array(r.int32.buffer),r.float64=new Float64Array(r.int32.buffer),r.isLittleEndian=1===new Uint16Array(new Uint8Array([1,0]).buffer)[0],r.Long=function(t,e){this.low=0|t,this.high=0|e},r.Long.create=function(t,e){return 0==t&&0==e?r.Long.ZERO:new r.Long(t,e)},r.Long.prototype.toFloat64=function(){return(this.low>>>0)+4294967296*this.high},r.Long.prototype.equals=function(t){return this.low==t.low&&this.high==t.high},r.Long.ZERO=new r.Long(0,0),r.Builder=function(t){if(t)e=t;else var e=1024;this.bb=r.ByteBuffer.allocate(e),this.space=e,this.minalign=1,this.vtable=null,this.vtable_in_use=0,this.isNested=!1,this.object_start=0,this.vtables=[],this.vector_num_elems=0,this.force_defaults=!1},r.Builder.prototype.clear=function(){this.bb.clear(),this.space=this.bb.capacity(),this.minalign=1,this.vtable=null,this.vtable_in_use=0,this.isNested=!1,this.object_start=0,this.vtables=[],this.vector_num_elems=0,this.force_defaults=!1},r.Builder.prototype.forceDefaults=function(t){this.force_defaults=t},r.Builder.prototype.dataBuffer=function(){return this.bb},r.Builder.prototype.asUint8Array=function(){return this.bb.bytes().subarray(this.bb.position(),this.bb.position()+this.offset())},r.Builder.prototype.prep=function(t,e){t>this.minalign&&(this.minalign=t);for(var n=1+~(this.bb.capacity()-this.space+e)&t-1;this.space<n+t+e;){var i=this.bb.capacity();this.bb=r.Builder.growByteBuffer(this.bb),this.space+=this.bb.capacity()-i}this.pad(n)},r.Builder.prototype.pad=function(t){for(var e=0;e<t;e++)this.bb.writeInt8(--this.space,0)},r.Builder.prototype.writeInt8=function(t){this.bb.writeInt8(this.space-=1,t)},r.Builder.prototype.writeInt16=function(t){this.bb.writeInt16(this.space-=2,t)},r.Builder.prototype.writeInt32=function(t){this.bb.writeInt32(this.space-=4,t)},r.Builder.prototype.writeInt64=function(t){this.bb.writeInt64(this.space-=8,t)},r.Builder.prototype.writeFloat32=function(t){this.bb.writeFloat32(this.space-=4,t)},r.Builder.prototype.writeFloat64=function(t){this.bb.writeFloat64(this.space-=8,t)},r.Builder.prototype.addInt8=function(t){this.prep(1,0),this.writeInt8(t)},r.Builder.prototype.addInt16=function(t){this.prep(2,0),this.writeInt16(t)},r.Builder.prototype.addInt32=function(t){this.prep(4,0),this.writeInt32(t)},r.Builder.prototype.addInt64=function(t){this.prep(8,0),this.writeInt64(t)},r.Builder.prototype.addFloat32=function(t){this.prep(4,0),this.writeFloat32(t)},r.Builder.prototype.addFloat64=function(t){this.prep(8,0),this.writeFloat64(t)},r.Builder.prototype.addFieldInt8=function(t,e,n){(this.force_defaults||e!=n)&&(this.addInt8(e),this.slot(t))},r.Builder.prototype.addFieldInt16=function(t,e,n){(this.force_defaults||e!=n)&&(this.addInt16(e),this.slot(t))},r.Builder.prototype.addFieldInt32=function(t,e,n){(this.force_defaults||e!=n)&&(this.addInt32(e),this.slot(t))},r.Builder.prototype.addFieldInt64=function(t,e,n){!this.force_defaults&&e.equals(n)||(this.addInt64(e),this.slot(t))},r.Builder.prototype.addFieldFloat32=function(t,e,n){(this.force_defaults||e!=n)&&(this.addFloat32(e),this.slot(t))},r.Builder.prototype.addFieldFloat64=function(t,e,n){(this.force_defaults||e!=n)&&(this.addFloat64(e),this.slot(t))},r.Builder.prototype.addFieldOffset=function(t,e,n){(this.force_defaults||e!=n)&&(this.addOffset(e),this.slot(t))},r.Builder.prototype.addFieldStruct=function(t,e,n){e!=n&&(this.nested(e),this.slot(t))},r.Builder.prototype.nested=function(t){if(t!=this.offset())throw new Error(\"FlatBuffers: struct must be serialized inline.\")},r.Builder.prototype.notNested=function(){if(this.isNested)throw new Error(\"FlatBuffers: object serialization must not be nested.\")},r.Builder.prototype.slot=function(t){this.vtable[t]=this.offset()},r.Builder.prototype.offset=function(){return this.bb.capacity()-this.space},r.Builder.growByteBuffer=function(t){var e=t.capacity();if(3221225472&e)throw new Error(\"FlatBuffers: cannot grow buffer beyond 2 gigabytes.\");var n=e<<1,i=r.ByteBuffer.allocate(n);return i.setPosition(n-e),i.bytes().set(t.bytes(),n-e),i},r.Builder.prototype.addOffset=function(t){this.prep(r.SIZEOF_INT,0),this.writeInt32(this.offset()-t+r.SIZEOF_INT)},r.Builder.prototype.startObject=function(t){this.notNested(),null==this.vtable&&(this.vtable=[]),this.vtable_in_use=t;for(var e=0;e<t;e++)this.vtable[e]=0;this.isNested=!0,this.object_start=this.offset()},r.Builder.prototype.endObject=function(){if(null==this.vtable||!this.isNested)throw new Error(\"FlatBuffers: endObject called without startObject\");this.addInt32(0);for(var t=this.offset(),e=this.vtable_in_use-1;e>=0&&0==this.vtable[e];e--);for(var n=e+1;e>=0;e--)this.addInt16(0!=this.vtable[e]?t-this.vtable[e]:0);this.addInt16(t-this.object_start);var i=(n+2)*r.SIZEOF_SHORT;this.addInt16(i);var o=0,a=this.space;t:for(e=0;e<this.vtables.length;e++){var s=this.bb.capacity()-this.vtables[e];if(i==this.bb.readInt16(s)){for(var u=r.SIZEOF_SHORT;u<i;u+=r.SIZEOF_SHORT)if(this.bb.readInt16(a+u)!=this.bb.readInt16(s+u))continue t;o=this.vtables[e];break}}return o?(this.space=this.bb.capacity()-t,this.bb.writeInt32(this.space,o-t)):(this.vtables.push(this.offset()),this.bb.writeInt32(this.bb.capacity()-t,this.offset()-t)),this.isNested=!1,t},r.Builder.prototype.finish=function(t,e,n){var i=n?r.SIZE_PREFIX_LENGTH:0;if(e){var o=e;if(this.prep(this.minalign,r.SIZEOF_INT+r.FILE_IDENTIFIER_LENGTH+i),o.length!=r.FILE_IDENTIFIER_LENGTH)throw new Error(\"FlatBuffers: file identifier must be length \"+r.FILE_IDENTIFIER_LENGTH);for(var a=r.FILE_IDENTIFIER_LENGTH-1;a>=0;a--)this.writeInt8(o.charCodeAt(a))}this.prep(this.minalign,r.SIZEOF_INT+i),this.addOffset(t),i&&this.addInt32(this.bb.capacity()-this.space),this.bb.setPosition(this.space)},r.Builder.prototype.finishSizePrefixed=function(t,e){this.finish(t,e,!0)},r.Builder.prototype.requiredField=function(t,e){var n=this.bb.capacity()-t,r=n-this.bb.readInt32(n);if(0==this.bb.readInt16(r+e))throw new Error(\"FlatBuffers: field \"+e+\" must be set\")},r.Builder.prototype.startVector=function(t,e,n){this.notNested(),this.vector_num_elems=e,this.prep(r.SIZEOF_INT,t*e),this.prep(n,t*e)},r.Builder.prototype.endVector=function(){return this.writeInt32(this.vector_num_elems),this.offset()},r.Builder.prototype.createString=function(t){if(t instanceof Uint8Array)var e=t;else{e=[];for(var n=0;n<t.length;){var r,i=t.charCodeAt(n++);(r=i<55296||i>=56320?i:(i<<10)+t.charCodeAt(n++)+-56613888)<128?e.push(r):(r<2048?e.push(r>>6&31|192):(r<65536?e.push(r>>12&15|224):e.push(r>>18&7|240,r>>12&63|128),e.push(r>>6&63|128)),e.push(63&r|128))}}this.addInt8(0),this.startVector(1,e.length,1),this.bb.setPosition(this.space-=e.length),n=0;for(var o=this.space,a=this.bb.bytes();n<e.length;n++)a[o++]=e[n];return this.endVector()},r.Builder.prototype.createLong=function(t,e){return r.Long.create(t,e)},r.ByteBuffer=function(t){this.bytes_=t,this.position_=0},r.ByteBuffer.allocate=function(t){return new r.ByteBuffer(new Uint8Array(t))},r.ByteBuffer.prototype.clear=function(){this.position_=0},r.ByteBuffer.prototype.bytes=function(){return this.bytes_},r.ByteBuffer.prototype.position=function(){return this.position_},r.ByteBuffer.prototype.setPosition=function(t){this.position_=t},r.ByteBuffer.prototype.capacity=function(){return this.bytes_.length},r.ByteBuffer.prototype.readInt8=function(t){return this.readUint8(t)<<24>>24},r.ByteBuffer.prototype.readUint8=function(t){return this.bytes_[t]},r.ByteBuffer.prototype.readInt16=function(t){return this.readUint16(t)<<16>>16},r.ByteBuffer.prototype.readUint16=function(t){return this.bytes_[t]|this.bytes_[t+1]<<8},r.ByteBuffer.prototype.readInt32=function(t){return this.bytes_[t]|this.bytes_[t+1]<<8|this.bytes_[t+2]<<16|this.bytes_[t+3]<<24},r.ByteBuffer.prototype.readUint32=function(t){return this.readInt32(t)>>>0},r.ByteBuffer.prototype.readInt64=function(t){return new r.Long(this.readInt32(t),this.readInt32(t+4))},r.ByteBuffer.prototype.readUint64=function(t){return new r.Long(this.readUint32(t),this.readUint32(t+4))},r.ByteBuffer.prototype.readFloat32=function(t){return r.int32[0]=this.readInt32(t),r.float32[0]},r.ByteBuffer.prototype.readFloat64=function(t){return r.int32[r.isLittleEndian?0:1]=this.readInt32(t),r.int32[r.isLittleEndian?1:0]=this.readInt32(t+4),r.float64[0]},r.ByteBuffer.prototype.writeInt8=function(t,e){this.bytes_[t]=e},r.ByteBuffer.prototype.writeUint8=function(t,e){this.bytes_[t]=e},r.ByteBuffer.prototype.writeInt16=function(t,e){this.bytes_[t]=e,this.bytes_[t+1]=e>>8},r.ByteBuffer.prototype.writeUint16=function(t,e){this.bytes_[t]=e,this.bytes_[t+1]=e>>8},r.ByteBuffer.prototype.writeInt32=function(t,e){this.bytes_[t]=e,this.bytes_[t+1]=e>>8,this.bytes_[t+2]=e>>16,this.bytes_[t+3]=e>>24},r.ByteBuffer.prototype.writeUint32=function(t,e){this.bytes_[t]=e,this.bytes_[t+1]=e>>8,this.bytes_[t+2]=e>>16,this.bytes_[t+3]=e>>24},r.ByteBuffer.prototype.writeInt64=function(t,e){this.writeInt32(t,e.low),this.writeInt32(t+4,e.high)},r.ByteBuffer.prototype.writeUint64=function(t,e){this.writeUint32(t,e.low),this.writeUint32(t+4,e.high)},r.ByteBuffer.prototype.writeFloat32=function(t,e){r.float32[0]=e,this.writeInt32(t,r.int32[0])},r.ByteBuffer.prototype.writeFloat64=function(t,e){r.float64[0]=e,this.writeInt32(t,r.int32[r.isLittleEndian?0:1]),this.writeInt32(t+4,r.int32[r.isLittleEndian?1:0])},r.ByteBuffer.prototype.getBufferIdentifier=function(){if(this.bytes_.length<this.position_+r.SIZEOF_INT+r.FILE_IDENTIFIER_LENGTH)throw new Error(\"FlatBuffers: ByteBuffer is too short to contain an identifier.\");for(var t=\"\",e=0;e<r.FILE_IDENTIFIER_LENGTH;e++)t+=String.fromCharCode(this.readInt8(this.position_+r.SIZEOF_INT+e));return t},r.ByteBuffer.prototype.__offset=function(t,e){var n=t-this.readInt32(t);return e<this.readInt16(n)?this.readInt16(n+e):0},r.ByteBuffer.prototype.__union=function(t,e){return t.bb_pos=e+this.readInt32(e),t.bb=this,t},r.ByteBuffer.prototype.__string=function(t,e){t+=this.readInt32(t);var n=this.readInt32(t),i=\"\",o=0;if(t+=r.SIZEOF_INT,e===r.Encoding.UTF8_BYTES)return this.bytes_.subarray(t,t+n);for(;o<n;){var a,s=this.readUint8(t+o++);if(s<192)a=s;else{var u=this.readUint8(t+o++);if(s<224)a=(31&s)<<6|63&u;else{var c=this.readUint8(t+o++);a=s<240?(15&s)<<12|(63&u)<<6|63&c:(7&s)<<18|(63&u)<<12|(63&c)<<6|63&this.readUint8(t+o++)}}a<65536?i+=String.fromCharCode(a):(a-=65536,i+=String.fromCharCode(55296+(a>>10),56320+(1023&a)))}return i},r.ByteBuffer.prototype.__indirect=function(t){return t+this.readInt32(t)},r.ByteBuffer.prototype.__vector=function(t){return t+this.readInt32(t)+r.SIZEOF_INT},r.ByteBuffer.prototype.__vector_len=function(t){return this.readInt32(t+this.readInt32(t))},r.ByteBuffer.prototype.__has_identifier=function(t){if(t.length!=r.FILE_IDENTIFIER_LENGTH)throw new Error(\"FlatBuffers: file identifier must be length \"+r.FILE_IDENTIFIER_LENGTH);for(var e=0;e<r.FILE_IDENTIFIER_LENGTH;e++)if(t.charCodeAt(e)!=this.readInt8(this.position_+r.SIZEOF_INT+e))return!1;return!0},r.ByteBuffer.prototype.createLong=function(t,e){return r.Long.create(t,e)}}},__webpack_module_cache__={};function __nested_webpack_require_546802__(t){var e=__webpack_module_cache__[t];if(void 0!==e)return e.exports;var n=__webpack_module_cache__[t]={exports:{}};return __webpack_modules__[t].call(n.exports,n,n.exports,__nested_webpack_require_546802__),n.exports}__nested_webpack_require_546802__.n=t=>{var e=t&&t.__esModule?()=>t.default:()=>t;return __nested_webpack_require_546802__.d(e,{a:e}),e},__nested_webpack_require_546802__.d=(t,e)=>{for(var n in e)__nested_webpack_require_546802__.o(e,n)&&!__nested_webpack_require_546802__.o(t,n)&&Object.defineProperty(t,n,{enumerable:!0,get:e[n]})},__nested_webpack_require_546802__.g=function(){if(\"object\"==typeof globalThis)return globalThis;try{return this||new Function(\"return this\")()}catch(t){if(\"object\"==typeof window)return window}}(),__nested_webpack_require_546802__.o=(t,e)=>Object.prototype.hasOwnProperty.call(t,e),__nested_webpack_require_546802__.r=t=>{\"undefined\"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:\"Module\"}),Object.defineProperty(t,\"__esModule\",{value:!0})};var __nested_webpack_exports__=__nested_webpack_require_546802__(6018);return __nested_webpack_exports__})()));\n//# sourceMappingURL=ort-web.min.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9vbm54cnVudGltZS13ZWIvZGlzdC9vcnQtd2ViLm1pbi5qcyIsIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsR0FBRyxJQUFpRCxrQkFBa0IsbUJBQU8sQ0FBQyxtR0FBb0IsR0FBRyxLQUFLLGFBQWdNLENBQUMsZ0RBQWdELHlCQUF5QixlQUFlLDBKQUEwSixhQUFhLGtDQUFrQyxhQUFhLGtDQUFrQyxhQUFhLGtDQUFrQyxhQUFhLGtDQUFrQyxhQUFhLGtDQUFrQyxVQUFVLE9BQU8sc0JBQXNCLHFDQUFxQyxRQUFRLEdBQUcsa0NBQWtDLGlDQUFpQyxRQUFRLGlGQUFpRixPQUFPLG1CQUFtQixPQUFPLDRCQUE0QixPQUFPLG1EQUFtRCxjQUFjLDBDQUEwQyxNQUFNLE1BQU0sc0NBQXNDLHdCQUF3QixpQkFBaUIsOERBQThELGdFQUFnRSxpREFBaUQsbUJBQW1CLEdBQUcsR0FBRyxPQUFPLGlCQUFpQixPQUFPLDZCQUE2QixPQUFPLGVBQWUsT0FBTyxxQ0FBcUMsOEJBQThCLEdBQUcsT0FBTyxzQ0FBc0MsUUFBUSxhQUFhLGFBQWEsT0FBTyxjQUFjLG1EQUFtRCxPQUFPLFNBQVMsc0JBQXNCLG9DQUFvQyxJQUFJLFVBQVUsU0FBUyxpSUFBaUksb0JBQW9CLGdQQUFnUCx5QkFBeUIsc0RBQXNELFdBQVcseUJBQXlCLCtGQUErRixjQUFjLHlCQUF5Qiw4REFBOEQseURBQXlELDBCQUEwQixHQUFHLDBFQUEwRSw2REFBNkQsK0RBQStELG1DQUFtQyw2R0FBNkcsMEJBQTBCLG9FQUFvRSwwRkFBMEYsa0JBQWtCLGlCQUFpQixRQUFRLGNBQWMsS0FBSywyR0FBMkcsU0FBUyxJQUFJLEVBQUUsYUFBYSxVQUFVLGdCQUFnQixvREFBb0QsS0FBSyxnQkFBZ0IsK0pBQStKLCtCQUErQixTQUFTLGdCQUFnQiw2QkFBNkIsb0JBQW9CLG1CQUFtQixhQUFhLFFBQVEsWUFBWSxXQUFXLEtBQUssc0JBQXNCLCtFQUErRSxjQUFjLGFBQWEsS0FBSyxZQUFZLGdCQUFnQixvQkFBb0IsS0FBSyxhQUFhLGdCQUFnQixxQkFBcUIsS0FBSyxnQkFBZ0IsNkNBQTZDLHVCQUF1QixxQkFBcUIsc0JBQXNCLGNBQWMsZ0JBQWdCLFdBQVcsS0FBSyxzQkFBc0IsMkRBQTJELFNBQVMsY0FBYyw4T0FBOE8sZ0JBQWdCLGlDQUFpQywrQkFBK0Isb0NBQW9DLHFDQUFxQyx3Q0FBd0MsdWFBQXVhLG9DQUFvQywwQkFBMEIsYUFBYSxhQUFhLGFBQWEsdUJBQXVCLGFBQWEsNEJBQTRCLGVBQWUscUJBQXFCLG9CQUFvQix5SUFBeUksY0FBYyxvREFBb0QsVUFBVSxjQUFjLFNBQVMsSUFBSSxxQ0FBcUMsaUJBQWlCLHVEQUF1RCxTQUFTLE9BQU8sNkNBQTZDLFVBQVUsZUFBZSx3RkFBd0YsZUFBZSw0QkFBNEIsZUFBZSxjQUFjLGVBQWUsc0NBQXNDLE9BQU8sd0RBQXdELGlCQUFpQiwrQ0FBK0Msa0NBQWtDLGVBQWUsc0JBQXNCLHlEQUF5RCxpQkFBaUIsOEJBQThCLHVGQUF1RixRQUFRLHVCQUF1QixlQUFlLFdBQVcsZ0JBQWdCLGVBQWUsa0ZBQWtGLGdCQUFnQixlQUFlLDJDQUEyQyw2QkFBNkIsU0FBUyxnQkFBZ0IsV0FBVyw0RUFBNEUsZ0JBQWdCLGVBQWUsd0JBQXdCLGtCQUFrQixnQkFBZ0IscUJBQXFCLDREQUE0RCxrQkFBa0IsNkpBQTZKLHlRQUF5USxhQUFhLHNWQUFzVixhQUFhLGVBQWUsMkVBQTJFLGlDQUFpQyxhQUFhLE9BQU8sRUFBRSw2QkFBNkIsYUFBYSxvQ0FBb0MsbUJBQW1CLGlGQUFpRixFQUFFLGVBQWUsdUNBQXVDLDBCQUEwQixlQUFlLGdFQUFnRSxlQUFlLEtBQUssV0FBVyxjQUFjLGVBQWUsV0FBVyxxQkFBcUIsZUFBZSxzQkFBc0IsSUFBSSxNQUFNLFNBQVMsc0NBQXNDLDhDQUE4Qyw4QkFBOEIsb0NBQW9DLFVBQVUsZUFBZSxZQUFZLDZEQUE2RCxpQ0FBaUMsK0JBQStCLDBCQUEwQixlQUFlLDJDQUEyQyx3QkFBd0Isb0JBQW9CLDZCQUE2QixxQkFBcUIsd0JBQXdCLG9CQUFvQiw2QkFBNkIsb0JBQW9CLHNCQUFzQixxQkFBcUIsaUNBQWlDLG9CQUFvQixpQ0FBaUMscUJBQXFCLGlDQUFpQyxvQkFBb0IsaUNBQWlDLHVCQUF1QixtRUFBbUUsb0JBQW9CLDhCQUE4QixvQkFBb0IseUNBQXlDLHFCQUFxQix5QkFBeUIsb0JBQW9CLDhCQUE4QixvQkFBb0IsNENBQTRDLGdCQUFnQix3QkFBd0IsZUFBZSx3QkFBd0IscUJBQXFCLHFDQUFxQyxxQkFBcUIsMklBQTJJLFNBQVMsdUNBQXVDLG9CQUFvQixrREFBa0QsbUJBQW1CLHlCQUF5QixpQkFBaUIsd0JBQXdCLGlCQUFpQix3QkFBd0IsbUJBQW1CLDBCQUEwQixtQkFBbUIseUJBQXlCLGlCQUFpQix3QkFBd0IsbUJBQW1CLDJCQUEyQixxQkFBcUIsNkJBQTZCLHFCQUFxQiw2QkFBNkIscUJBQXFCLDZCQUE2QixlQUFlLHVCQUF1QixpQkFBaUIseUJBQXlCLG1CQUFtQiwyQkFBMkIsZUFBZSw0RUFBNEUsZUFBZSwwQ0FBMEMseUJBQXlCLGtDQUFrQyx5QkFBeUIsaUNBQWlDLGVBQWUscUJBQXFCLHlCQUF5QixtQkFBbUIsY0FBYyxpRUFBaUUsMkJBQTJCLG1FQUFtRSx3QkFBd0IsNENBQTRDLHdKQUF3SixpQkFBaUIscUNBQXFDLGdCQUFnQiw2QkFBNkIsSUFBSSxLQUFLLGFBQWEsZUFBZSxtQkFBbUIsR0FBRyw0Q0FBNEMsTUFBTSxPQUFPLFVBQVUseUJBQXlCLCtFQUErRSxtQkFBbUIsY0FBYyxRQUFRLFNBQVMsK01BQStNLGtEQUFrRCxTQUFTLDhCQUE4QixLQUFLLFVBQVUsaUJBQWlCLHlCQUF5QixRQUFRLG1DQUFtQyxVQUFVLDhCQUE4QixXQUFXLG9DQUFvQyw4QkFBOEIsS0FBSyxpQkFBaUIseUJBQXlCLFdBQVcsdUJBQXVCLFFBQVEsOEJBQThCLGNBQWMscUJBQXFCLGVBQWUsdUJBQXVCLHFCQUFxQiw2QkFBNkIsdUJBQXVCLCtCQUErQixvQkFBb0IsaUJBQWlCLFlBQVkseURBQXlELHFCQUFxQiw2QkFBNkIsZ0JBQWdCLElBQUksS0FBSyxzQ0FBc0MsS0FBSyxZQUFZLElBQUksdUJBQXVCLEtBQUsseUJBQXlCLFNBQVMsZUFBZSxvQ0FBb0Msc0ZBQXNGLHFCQUFxQixrQkFBa0IsNENBQTRDLFdBQVcsVUFBVSxTQUFTLGdCQUFnQixrQkFBa0IsZ0JBQWdCLGNBQWMsc0JBQXNCLE1BQU0sMEhBQTBILGNBQWMsbUJBQW1CLGdEQUFnRCxnQkFBZ0IsNENBQTRDLDRDQUE0Qyw0Q0FBNEMsZ0RBQWdELGlEQUFpRCxjQUFjLFdBQVcsa0RBQWtELElBQUksRUFBRSxvREFBb0QsdUJBQXVCLHlCQUF5QixNQUFNLHNHQUFzRywySkFBMkosdUJBQXVCLGdCQUFnQixnTkFBZ04sV0FBVyxtWEFBbVgscUNBQXFDLGlMQUFpTCxZQUFZLGlCQUFpQiw4QkFBOEIsa0JBQWtCLGVBQWUsa0JBQWtCLDhCQUE4QixrQkFBa0IsZUFBZSxrQkFBa0IsOEJBQThCLGtCQUFrQixpQkFBaUIsa0JBQWtCLHFCQUFxQixrQkFBa0Isb0NBQW9DLGtCQUFrQixZQUFZLGtCQUFrQixpQkFBaUIsa0JBQWtCLDZDQUE2QyxrQkFBa0IsZ0JBQWdCLFVBQVUsK0JBQStCLG1CQUFtQixrQkFBa0IsbUJBQW1CLGtCQUFrQixpQkFBaUIsaUJBQWlCLFdBQVcsa0JBQWtCLGtDQUFrQyxrQkFBa0IsaUJBQWlCLGlCQUFpQixXQUFXLGtCQUFrQixlQUFlLGtCQUFrQix3Q0FBd0Msa0JBQWtCLHdDQUF3QywwRkFBMEYsS0FBSyxLQUFLLHdCQUF3QixrQ0FBa0MsY0FBYyxrQkFBa0IsWUFBWSxrQkFBa0IsOENBQThDLGtCQUFrQiwwQ0FBMEMsa0JBQWtCLGlCQUFpQixrQkFBa0Isa0JBQWtCLDZFQUE2RSxrQkFBa0IsWUFBWSxpQkFBaUIsV0FBVyxxRkFBcUYscUJBQXFCLG9CQUFvQiwyQkFBMkIsdURBQXVELGlCQUFpQixrQkFBa0IsUUFBUSw2RkFBNkYsY0FBYyxtQkFBbUIsZUFBZSw0RUFBNEUsZ0JBQWdCLHlGQUF5RixjQUFjLE1BQU0sZUFBZSxvQkFBb0IsYUFBYSx3QkFBd0IsS0FBSyxjQUFjLFNBQVMsa0JBQWtCLGdCQUFnQixRQUFRLGFBQWEsb0JBQW9CLG9EQUFvRCxXQUFXLEtBQUssV0FBVyxzQkFBc0IsaUNBQWlDLGNBQWMsY0FBYyxTQUFTLGtCQUFrQixnQkFBZ0IsUUFBUSxhQUFhLG9CQUFvQixvREFBb0QsV0FBVyxLQUFLLFdBQVcsc0JBQXNCLGlDQUFpQyxjQUFjLGNBQWMsU0FBUyxrQkFBa0IsZ0JBQWdCLFFBQVEsYUFBYSxvQkFBb0Isb0RBQW9ELFdBQVcsS0FBSyxXQUFXLHNCQUFzQixpQ0FBaUMsY0FBYyxtQkFBbUIsZUFBZSwrQkFBK0IsV0FBVyx5REFBeUQsbUJBQW1CLG9DQUFvQyxlQUFlLFVBQVUsZ0JBQWdCLHNCQUFzQixlQUFlLGVBQWUsNkJBQTZCLFFBQVEscUJBQXFCLG1CQUFtQiw0RkFBNEYsY0FBYyxxSEFBcUgsZUFBZSxxSEFBcUgsY0FBYyxrQkFBa0IsZUFBZSxlQUFlLGVBQWUsU0FBUyxzQkFBc0IsZ0NBQWdDLHVCQUF1QixrREFBa0QsRUFBRSxLQUFLLHdCQUF3QixlQUFlLG1DQUFtQyxFQUFFLFNBQVMsZUFBZSxTQUFTLGtCQUFrQixxVkFBcVYsa0JBQWtCLDRPQUE0Tyx3RUFBd0UsOE1BQThNLGdCQUFnQiwrUkFBK1IsZ1hBQWdYLGtDQUFrQywwQkFBMEIsY0FBYyxPQUFPLGNBQWMsV0FBVyxpSkFBaUosVUFBVSw4Q0FBOEMsZUFBZSxrQkFBa0IseUJBQXlCLG9DQUFvQyxjQUFjLDZEQUE2RCxvQkFBb0Isa0JBQWtCLFlBQVksSUFBSSx1QkFBdUIsMENBQTBDLGdCQUFnQixpQkFBaUIsc0NBQXNDLFlBQVksS0FBSyxNQUFNLGlCQUFpQiwwQkFBMEIsV0FBVyxtRUFBbUUsR0FBRyxJQUFJLDhDQUE4QyxRQUFRLFFBQVEsVUFBVSxTQUFTLGNBQWMsU0FBUyxlQUFlLGNBQWMsb0RBQW9ELFVBQVUsb0JBQW9CLHVCQUF1Qix1RUFBdUUsd0JBQXdCLDJDQUEyQyxTQUFTLDBCQUEwQiwrQ0FBK0Msa0NBQWtDLEtBQUssOEJBQThCLFVBQVUsNkJBQTZCLElBQUksWUFBWSxJQUFJLDJCQUEyQixTQUFTLG9CQUFvQixXQUFXLElBQUksa0JBQWtCLFNBQVMseUJBQXlCLFNBQVMsb0JBQW9CLFdBQVcsSUFBSSxrQkFBa0IsU0FBUyx5QkFBeUIsU0FBUyxlQUFlLFdBQVcsSUFBSSxlQUFlLFNBQVMseUJBQXlCLFNBQVMsaUJBQWlCLFdBQVcsSUFBSSxnQkFBZ0IsU0FBUyx5QkFBeUIsU0FBUyxtQkFBbUIsV0FBVyxJQUFJLGtCQUFrQixTQUFTLHlCQUF5QixTQUFTLG1CQUFtQixXQUFXLElBQUksa0JBQWtCLFNBQVMseUJBQXlCLFNBQVMsbUJBQW1CLFdBQVcsSUFBSSxrQkFBa0IsU0FBUyx5QkFBeUIsU0FBUyxxQkFBcUIsV0FBVyxJQUFJLG9CQUFvQixTQUFTLHlCQUF5QixTQUFTLHVCQUF1QixXQUFXLElBQUksc0JBQXNCLFNBQVMseUJBQXlCLFNBQVMseUJBQXlCLFdBQVcsSUFBSSx3QkFBd0IsU0FBUyx5QkFBeUIsU0FBUyx5QkFBeUIsV0FBVyxJQUFJLHdCQUF3QixTQUFTLHlCQUF5QixTQUFTLDJCQUEyQixXQUFXLElBQUksMEJBQTBCLFNBQVMseUJBQXlCLFNBQVMsNkJBQTZCLFdBQVcsSUFBSSw0QkFBNEIsU0FBUyx5QkFBeUIsU0FBUyxxQ0FBcUMsV0FBVyxJQUFJLG9DQUFvQyxTQUFTLHlCQUF5QixTQUFTLDhCQUE4QixXQUFXLElBQUksMkJBQTJCLFNBQVMseUJBQXlCLFNBQVMsMkJBQTJCLFdBQVcsSUFBSSx5QkFBeUIsU0FBUyx5QkFBeUIsU0FBUyx1QkFBdUIsV0FBVyxJQUFJLHFCQUFxQixTQUFTLHlCQUF5QixTQUFTLHNCQUFzQixXQUFXLElBQUksbUJBQW1CLFNBQVMseUJBQXlCLFNBQVMsZUFBZSxXQUFXLElBQUksYUFBYSxTQUFTLHlCQUF5QixTQUFTLGtCQUFrQixXQUFXLElBQUksZUFBZSxTQUFTLHlCQUF5QixTQUFTLG1CQUFtQixXQUFXLElBQUksaUJBQWlCLFNBQVMseUJBQXlCLFNBQVMsZUFBZSxXQUFXLElBQUksUUFBUSxTQUFTLHlCQUF5QixTQUFTLGlCQUFpQixXQUFXLElBQUksU0FBUyxTQUFTLHlCQUF5QixTQUFTLG1CQUFtQixXQUFXLElBQUksV0FBVyxTQUFTLHlCQUF5QixTQUFTLHNCQUFzQixXQUFXLElBQUksYUFBYSxTQUFTLHlCQUF5QixTQUFTLHFCQUFxQixXQUFXLElBQUksYUFBYSxTQUFTLHlCQUF5QixTQUFTLHVCQUF1QixXQUFXLElBQUksZUFBZSxTQUFTLHlCQUF5QixTQUFTLHlCQUF5QixXQUFXLElBQUksaUJBQWlCLFNBQVMseUJBQXlCLFNBQVMsMkJBQTJCLFdBQVcsSUFBSSxtQkFBbUIsU0FBUyx5QkFBeUIsU0FBUyw2QkFBNkIsV0FBVyxJQUFJLHFCQUFxQixTQUFTLHlCQUF5QixTQUFTLGdDQUFnQyxXQUFXLElBQUksdUJBQXVCLFNBQVMseUJBQXlCLFNBQVMsbUNBQW1DLFdBQVcsSUFBSSwyQkFBMkIsU0FBUyx5QkFBeUIsU0FBUyw2Q0FBNkMsV0FBVyxJQUFJLHFDQUFxQyxTQUFTLHlCQUF5QixTQUFTLDhCQUE4QixXQUFXLElBQUksb0JBQW9CLFNBQVMseUJBQXlCLFNBQVMsc0NBQXNDLFdBQVcsSUFBSSw0QkFBNEIsU0FBUyx5QkFBeUIsU0FBUywwQkFBMEIsV0FBVyxJQUFJLGdCQUFnQixTQUFTLHlCQUF5QixTQUFTLGVBQWUsU0FBUyxpQ0FBaUMsS0FBSywyQkFBMkIscUJBQXFCLFlBQVksZ0JBQWdCLGdOQUFnTixjQUFjLHVCQUF1QixjQUFjLGtCQUFrQixlQUFlLHdFQUF3RSwwQkFBMEIsb0JBQW9CLDREQUE0RCx1QkFBdUIscUJBQXFCLFlBQVksR0FBRyx1Q0FBdUMsa0JBQWtCLHFCQUFxQixLQUFLLEdBQUcsMENBQTBDLFlBQVksR0FBRyxxQkFBcUIsb0NBQW9DLHFCQUFxQixTQUFTLHVCQUF1QixxREFBcUQsR0FBRyxPQUFPLE1BQU0sMEZBQTBGLDhCQUE4QixTQUFTLHFFQUFxRSxvSUFBb0ksMEJBQTBCLG9CQUFvQixpRUFBaUUsa0dBQWtHLEdBQUcsYUFBYSxtQ0FBbUMsNERBQTRELHVCQUF1QixrREFBa0QsdUNBQXVDLGtFQUFrRSwwQ0FBMEMscUVBQXFFLHdDQUF3QyxtRUFBbUUsd0NBQXdDLG1FQUFtRSxnQ0FBZ0MsMkRBQTJELGlDQUFpQyw0REFBNEQsZ0NBQWdDLDJEQUEyRCxpQ0FBaUMsNERBQTRELCtCQUErQiwwREFBMEQsZ0NBQWdDLDJEQUEyRCx1QkFBdUIsa0RBQWtELCtCQUErQiwwREFBMEQsZ0NBQWdDLDJEQUEyRCxnQ0FBZ0MsMkRBQTJELG1DQUFtQyw4REFBOEQsb0NBQW9DLCtEQUErRCxvQ0FBb0MsK0RBQStELHNCQUFzQixpREFBaUQsK0JBQStCLDJEQUEyRCxrQ0FBa0MsMERBQTBELHlCQUF5QixvREFBb0QsdUJBQXVCLGtEQUFrRCx5QkFBeUIscURBQXFELG1DQUFtQyxnRUFBZ0UscUNBQXFDLDZEQUE2RCwwQ0FBMEMsc0VBQXNFLHlDQUF5QyxzRUFBc0UsaUVBQWlFLHNGQUFzRix1REFBdUQsa0ZBQWtGLCtDQUErQywwRUFBMEUsMENBQTBDLHFFQUFxRSwyQkFBMkIsc0RBQXNELDhDQUE4Qyx5RUFBeUUsMkJBQTJCLHNEQUFzRCw4QkFBOEIseURBQXlELDRCQUE0Qix1REFBdUQsa0NBQWtDLDZEQUE2RCx3Q0FBd0MsbUVBQW1FLDJCQUEyQixzREFBc0QsZ0NBQWdDLDJEQUEyRCw2QkFBNkIsd0RBQXdELGlDQUFpQyw0REFBNEQsOEJBQThCLHlEQUF5RCxtQ0FBbUMsOERBQThELDZCQUE2Qix3REFBd0QsNEJBQTRCLHVEQUF1RCxpQ0FBaUMsNERBQTRELDhCQUE4QiwwREFBMEQsY0FBYyxhQUFhLHdHQUF3Ryx1RUFBdUUsaUJBQWlCLEVBQUUsd0JBQXdCLGFBQWEsT0FBTywyQ0FBMkMsYUFBYSxFQUFFLEtBQUssbUVBQW1FLGdCQUFnQixLQUFLLDJFQUEyRSx1QkFBdUIsZ0JBQWdCLFNBQVMsWUFBWSxtREFBbUQsb0JBQW9CLHVKQUF1SixvQkFBb0IscUVBQXFFLG1CQUFtQixtQkFBbUIsb0JBQW9CLEVBQUUsWUFBWSxlQUFlLDBKQUEwSixVQUFVLE9BQU8sc0JBQXNCLHFDQUFxQyxRQUFRLEdBQUcsa0NBQWtDLGlDQUFpQyxRQUFRLGlGQUFpRixPQUFPLG1CQUFtQixPQUFPLDRCQUE0QixPQUFPLG9CQUFvQix5Q0FBeUMsd0JBQXdCLGlCQUFpQiw4REFBOEQsZ0VBQWdFLGlEQUFpRCxtQkFBbUIsR0FBRyxHQUFHLE9BQU8saUJBQWlCLE9BQU8sNkJBQTZCLE9BQU8sZUFBZSxPQUFPLHFDQUFxQyw2QkFBNkIsR0FBRyxPQUFPLHNDQUFzQyxRQUFRLGFBQWEsZ0JBQWdCLE9BQU8sY0FBYyxrREFBa0QsT0FBTyxTQUFTLHNCQUFzQixtQ0FBbUMsME9BQTBPLHlCQUF5QixzREFBc0QsV0FBVyx5QkFBeUIsK0ZBQStGLGNBQWMseUJBQXlCLDhEQUE4RCx5REFBeUQsMEJBQTBCLEVBQUUsb0ZBQW9GLDZHQUE2RywwQkFBMEIsbUVBQW1FLHNGQUFzRixrQkFBa0IsaUJBQWlCLFFBQVEsY0FBYyxLQUFLLHdEQUF3RCxTQUFTLElBQUksRUFBRSxhQUFhLFVBQVUsZ0JBQWdCLG9EQUFvRCxLQUFLLGdCQUFnQiwrSkFBK0osK0JBQStCLFNBQVMsZ0JBQWdCLDJCQUEyQixvQkFBb0IsbUJBQW1CLGFBQWEsUUFBUSxZQUFZLFdBQVcsS0FBSyxzQkFBc0IsK0VBQStFLGNBQWMsYUFBYSxLQUFLLFlBQVksZ0JBQWdCLG9CQUFvQixLQUFLLGFBQWEsZ0JBQWdCLHFCQUFxQixLQUFLLGdCQUFnQiw2Q0FBNkMsdUJBQXVCLHFCQUFxQixzQkFBc0IsY0FBYyxnQkFBZ0IsV0FBVyxLQUFLLHNCQUFzQiwyREFBMkQsU0FBUyxhQUFhLGVBQWUsNE9BQTRPLDhCQUE4QixhQUFhLHVCQUF1QixhQUFhLHdCQUF3QixjQUFjLDZJQUE2SSxhQUFhLG1EQUFtRCxVQUFVLDJCQUEyQixRQUFRLHFDQUFxQyxhQUFhLFFBQVEsSUFBSSxvQ0FBb0MsaUJBQWlCLHVEQUF1RCxTQUFTLE1BQU0sY0FBYyx3RkFBd0YsY0FBYyxLQUFLLFdBQVcsY0FBYyxrQkFBa0IsZUFBZSwyQ0FBMkMsc0JBQXNCLG9CQUFvQiwyQkFBMkIscUJBQXFCLHNCQUFzQixvQkFBb0IsMkJBQTJCLG9CQUFvQixvQkFBb0IscUJBQXFCLDJCQUEyQixvQkFBb0IsK0JBQStCLHFCQUFxQiwyQkFBMkIsb0JBQW9CLCtCQUErQix1QkFBdUIsbUVBQW1FLG9CQUFvQixxQkFBcUIsb0JBQW9CLHdCQUF3QixtQ0FBbUMscUJBQXFCLHVCQUF1QixvQkFBb0IsNEJBQTRCLG9CQUFvQiwwQ0FBMEMsZ0JBQWdCLHdCQUF3QixlQUFlLHdCQUF3QixVQUFVLGVBQWUsWUFBWSw2REFBNkQsZUFBZSxxQkFBcUIsdUJBQXVCLFVBQVUsY0FBYyxRQUFRLFNBQVMsK01BQStNLGtEQUFrRCxTQUFTLDhCQUE4QixLQUFLLFVBQVUsdUJBQXVCLGlCQUFpQixZQUFZLHlEQUF5RCxTQUFTLGVBQWUsb0NBQW9DLHNGQUFzRixxQkFBcUIsa0JBQWtCLDRDQUE0QyxXQUFXLFVBQVUsU0FBUyxnQkFBZ0Isa0JBQWtCLGdCQUFnQixjQUFjLHNCQUFzQixNQUFNLDBIQUEwSCxjQUFjLG1CQUFtQixnREFBZ0QsZ0JBQWdCLDRDQUE0Qyw0Q0FBNEMsNENBQTRDLGdEQUFnRCxpREFBaUQsY0FBYyxXQUFXLGtEQUFrRCxJQUFJLEVBQUUsb0RBQW9ELHVCQUF1Qix5QkFBeUIsTUFBTSxzR0FBc0csMkpBQTJKLHFCQUFxQixnQkFBZ0IsNExBQTRMLFdBQVcsbVhBQW1YLHFDQUFxQyxpTEFBaUwsWUFBWSxpQkFBaUIsOEJBQThCLGtCQUFrQixlQUFlLGtCQUFrQiw4QkFBOEIsa0JBQWtCLGVBQWUsa0JBQWtCLDhCQUE4QixrQkFBa0IsaUJBQWlCLGtCQUFrQixxQkFBcUIsa0JBQWtCLG9DQUFvQyxrQkFBa0IsWUFBWSxrQkFBa0IsaUJBQWlCLGtCQUFrQiw2Q0FBNkMsa0JBQWtCLGdCQUFnQixVQUFVLCtCQUErQixtQkFBbUIsa0JBQWtCLG1CQUFtQixrQkFBa0IsaUJBQWlCLGlCQUFpQixXQUFXLGtCQUFrQixrQ0FBa0Msa0JBQWtCLGlCQUFpQixpQkFBaUIsV0FBVyxrQkFBa0IsZUFBZSxrQkFBa0Isd0NBQXdDLGtCQUFrQix3Q0FBd0MsMEZBQTBGLEtBQUssS0FBSyx3QkFBd0Isa0NBQWtDLGNBQWMsa0JBQWtCLFlBQVksa0JBQWtCLDhDQUE4QyxrQkFBa0IsMENBQTBDLGtCQUFrQixpQkFBaUIsa0JBQWtCLGtCQUFrQiw2RUFBNkUsa0JBQWtCLFlBQVksaUJBQWlCLFdBQVcscUZBQXFGLHFCQUFxQixvQkFBb0IsMkJBQTJCLG9FQUFvRSxRQUFRLGNBQWMsbUJBQW1CLGVBQWUsMEVBQTBFLGdCQUFnQix5RkFBeUYsY0FBYyxNQUFNLGNBQWMsb0JBQW9CLGFBQWEsd0JBQXdCLEtBQUssY0FBYyxTQUFTLGtCQUFrQixnQkFBZ0IsUUFBUSxhQUFhLG9CQUFvQixvREFBb0QsV0FBVyxLQUFLLFdBQVcsc0JBQXNCLGlDQUFpQyxjQUFjLGNBQWMsU0FBUyxrQkFBa0IsZ0JBQWdCLFFBQVEsYUFBYSxvQkFBb0Isb0RBQW9ELFdBQVcsS0FBSyxXQUFXLHNCQUFzQixpQ0FBaUMsY0FBYyxjQUFjLFNBQVMsa0JBQWtCLGdCQUFnQixRQUFRLGFBQWEsb0JBQW9CLG9EQUFvRCxXQUFXLEtBQUssV0FBVyxzQkFBc0IsaUNBQWlDLGNBQWMsbUJBQW1CLGNBQWMsOEJBQThCLFdBQVcsdURBQXVELG1CQUFtQixtQ0FBbUMsZUFBZSxTQUFTLGVBQWUsbUJBQW1CLGNBQWMsU0FBUyxnQkFBZ0IsZ0JBQWdCLGdCQUFnQixlQUFlLFNBQVMsZ0JBQWdCLGdCQUFnQixnQkFBZ0IsZUFBZSxnQkFBZ0IsZ0JBQWdCLGdCQUFnQixnQkFBZ0IsZ0JBQWdCLGVBQWUsb0hBQW9ILGVBQWUsb0hBQW9ILGNBQWMsa0JBQWtCLGVBQWUsU0FBUyxrQkFBa0IsNFZBQTRWLGtCQUFrQix5UEFBeVAsb0NBQW9DLDBGQUEwRix3REFBd0Qsc0ZBQXNGLGdCQUFnQixpUkFBaVIsNFZBQTRWLGVBQWUsVUFBVSxnQkFBZ0Isc0JBQXNCLCtCQUErQixjQUFjLGlFQUFpRSxtRUFBbUUsd0JBQXdCLDRCQUE0Qix3SkFBd0osU0FBUyxjQUFjLE1BQU0sZUFBZSxrQkFBa0IsVUFBVSxNQUFNLE9BQU8sVUFBVSx5QkFBeUIsMENBQTBDLGtDQUFrQyxlQUFlLGVBQWUsZ0NBQWdDLFlBQVksS0FBSyxNQUFNLGlCQUFpQiwwQkFBMEIsV0FBVyxtRUFBbUUsR0FBRyxJQUFJLHNDQUFzQyxRQUFRLFFBQVEsVUFBVSxTQUFTLGNBQWMsU0FBUyxrQkFBa0IsUUFBUSxtQ0FBbUMsVUFBVSw0QkFBNEIsV0FBVyxrQ0FBa0MsNEJBQTRCLEtBQUssa0JBQWtCLFdBQVcscUJBQXFCLFFBQVEsOEJBQThCLGNBQWMsbUJBQW1CLGdCQUFnQiwySEFBMkgsY0FBYyxVQUFVLGNBQWMsVUFBVSxlQUFlLFVBQVUscUJBQXFCLGdCQUFnQixJQUFJLEtBQUssa0NBQWtDLEtBQUssWUFBWSxJQUFJLHFCQUFxQixLQUFLLHVCQUF1QixjQUFjLFVBQVUsb0JBQW9CLHVCQUF1Qix1RUFBdUUsd0JBQXdCLDJDQUEyQyxTQUFTLDBCQUEwQiwrQ0FBK0Msa0NBQWtDLEtBQUssOEJBQThCLFVBQVUsNEJBQTRCLElBQUksWUFBWSxJQUFJLHlCQUF5QixTQUFTLG9CQUFvQixXQUFXLElBQUksa0JBQWtCLFNBQVMseUJBQXlCLFNBQVMsb0JBQW9CLFdBQVcsSUFBSSxrQkFBa0IsU0FBUyx5QkFBeUIsU0FBUyxlQUFlLFdBQVcsSUFBSSxlQUFlLFNBQVMseUJBQXlCLFNBQVMsaUJBQWlCLFdBQVcsSUFBSSxnQkFBZ0IsU0FBUyx5QkFBeUIsU0FBUyxtQkFBbUIsV0FBVyxJQUFJLGtCQUFrQixTQUFTLHlCQUF5QixTQUFTLG1CQUFtQixXQUFXLElBQUksa0JBQWtCLFNBQVMseUJBQXlCLFNBQVMsbUJBQW1CLFdBQVcsSUFBSSxrQkFBa0IsU0FBUyx5QkFBeUIsU0FBUyxxQkFBcUIsV0FBVyxJQUFJLG9CQUFvQixTQUFTLHlCQUF5QixTQUFTLHVCQUF1QixXQUFXLElBQUksc0JBQXNCLFNBQVMseUJBQXlCLFNBQVMseUJBQXlCLFdBQVcsSUFBSSx3QkFBd0IsU0FBUyx5QkFBeUIsU0FBUyx5QkFBeUIsV0FBVyxJQUFJLHdCQUF3QixTQUFTLHlCQUF5QixTQUFTLDJCQUEyQixXQUFXLElBQUksMEJBQTBCLFNBQVMseUJBQXlCLFNBQVMsNkJBQTZCLFdBQVcsSUFBSSw0QkFBNEIsU0FBUyx5QkFBeUIsU0FBUyxxQ0FBcUMsV0FBVyxJQUFJLG9DQUFvQyxTQUFTLHlCQUF5QixTQUFTLDZCQUE2QixXQUFXLElBQUksMkJBQTJCLFNBQVMseUJBQXlCLFNBQVMsMkJBQTJCLFdBQVcsSUFBSSx5QkFBeUIsU0FBUyx5QkFBeUIsU0FBUyx1QkFBdUIsV0FBVyxJQUFJLHFCQUFxQixTQUFTLHlCQUF5QixTQUFTLHFCQUFxQixXQUFXLElBQUksbUJBQW1CLFNBQVMseUJBQXlCLFNBQVMsZUFBZSxXQUFXLElBQUksYUFBYSxTQUFTLHlCQUF5QixTQUFTLGlCQUFpQixXQUFXLElBQUksZUFBZSxTQUFTLHlCQUF5QixTQUFTLG1CQUFtQixXQUFXLElBQUksaUJBQWlCLFNBQVMseUJBQXlCLFNBQVMsZUFBZSxXQUFXLElBQUksUUFBUSxTQUFTLHlCQUF5QixTQUFTLGlCQUFpQixXQUFXLElBQUksU0FBUyxTQUFTLHlCQUF5QixTQUFTLG1CQUFtQixXQUFXLElBQUksV0FBVyxTQUFTLHlCQUF5QixTQUFTLHNCQUFzQixXQUFXLElBQUksYUFBYSxTQUFTLHlCQUF5QixTQUFTLHFCQUFxQixXQUFXLElBQUksYUFBYSxTQUFTLHlCQUF5QixTQUFTLHVCQUF1QixXQUFXLElBQUksZUFBZSxTQUFTLHlCQUF5QixTQUFTLHlCQUF5QixXQUFXLElBQUksaUJBQWlCLFNBQVMseUJBQXlCLFNBQVMsMkJBQTJCLFdBQVcsSUFBSSxtQkFBbUIsU0FBUyx5QkFBeUIsU0FBUyw2QkFBNkIsV0FBVyxJQUFJLHFCQUFxQixTQUFTLHlCQUF5QixTQUFTLGdDQUFnQyxXQUFXLElBQUksdUJBQXVCLFNBQVMseUJBQXlCLFNBQVMsbUNBQW1DLFdBQVcsSUFBSSwyQkFBMkIsU0FBUyx5QkFBeUIsU0FBUyw2Q0FBNkMsV0FBVyxJQUFJLHFDQUFxQyxTQUFTLHlCQUF5QixTQUFTLDhCQUE4QixXQUFXLElBQUksb0JBQW9CLFNBQVMseUJBQXlCLFNBQVMscUNBQXFDLFdBQVcsSUFBSSw0QkFBNEIsU0FBUyx5QkFBeUIsU0FBUyx5QkFBeUIsV0FBVyxJQUFJLGdCQUFnQixTQUFTLHlCQUF5QixTQUFTLGVBQWUsU0FBUyxlQUFlLEtBQUssMkJBQTJCLHFCQUFxQixZQUFZLGNBQWMsd0xBQXdMLGNBQWMsY0FBYyxjQUFjLGtCQUFrQixlQUFlLHNFQUFzRSwwQkFBMEIsb0JBQW9CLDJEQUEyRCx1QkFBdUIscUJBQXFCLFdBQVcsR0FBRyx1Q0FBdUMsaUJBQWlCLHFCQUFxQixLQUFLLEdBQUcsMENBQTBDLFdBQVcsR0FBRyxxQkFBcUIsb0NBQW9DLHFCQUFxQixTQUFTLHVCQUF1QixvREFBb0QsR0FBRyxPQUFPLE1BQU0sbUZBQW1GLDhCQUE4QixTQUFTLHFFQUFxRSxpSUFBaUksMEJBQTBCLG9CQUFvQixpRUFBaUUsa0dBQWtHLEdBQUcsYUFBYSxtQ0FBbUMsNERBQTRELHVCQUF1QixrREFBa0QsdUNBQXVDLGtFQUFrRSwwQ0FBMEMscUVBQXFFLHdDQUF3QyxtRUFBbUUsd0NBQXdDLG1FQUFtRSxnQ0FBZ0MsMkRBQTJELGlDQUFpQyw0REFBNEQsZ0NBQWdDLDJEQUEyRCxpQ0FBaUMsNERBQTRELCtCQUErQiwwREFBMEQsZ0NBQWdDLDJEQUEyRCx1QkFBdUIsa0RBQWtELCtCQUErQiwwREFBMEQsZ0NBQWdDLDJEQUEyRCxnQ0FBZ0MsMkRBQTJELG1DQUFtQyw4REFBOEQsb0NBQW9DLCtEQUErRCxvQ0FBb0MsK0RBQStELHNCQUFzQixpREFBaUQsK0JBQStCLDJEQUEyRCwrQkFBK0Isb0RBQW9ELHVCQUF1QixrREFBa0QseUJBQXlCLG9EQUFvRCxrQ0FBa0MsNkRBQTZELDJCQUEyQixzREFBc0QsMkJBQTJCLHNEQUFzRCw4QkFBOEIseURBQXlELDRCQUE0Qix1REFBdUQsa0NBQWtDLDZEQUE2RCx3Q0FBd0MsbUVBQW1FLDJCQUEyQixzREFBc0QsZ0NBQWdDLDJEQUEyRCw2QkFBNkIsd0RBQXdELGlDQUFpQyw0REFBNEQsOEJBQThCLHlEQUF5RCxtQ0FBbUMsOERBQThELDZCQUE2Qix3REFBd0QsNEJBQTRCLHVEQUF1RCxpQ0FBaUMsNERBQTRELDhCQUE4QiwwREFBMEQsY0FBYyxhQUFhLG1DQUFtQyxrSUFBa0ksaUJBQWlCLEVBQUUsd0JBQXdCLGFBQWEsTUFBTSxXQUFXLG1FQUFtRSxnQkFBZ0IsS0FBSyx5RUFBeUUsdUJBQXVCLGdCQUFnQixTQUFTLFlBQVksbURBQW1ELGtCQUFrQixxRkFBcUYsbUJBQW1CLHFFQUFxRSxtQkFBbUIsbUJBQW1CLG9CQUFvQixFQUFFLFlBQVksVUFBVSxhQUFhLHdCQUF3QixxREFBcUQsbUJBQW1CLHVCQUF1QixrQ0FBa0MsaUJBQWlCLG9CQUFvQixLQUFLLDRDQUE0QyxXQUFXLHFCQUFxQixrQkFBa0IsSUFBSSxtQkFBbUIsU0FBUyxnQkFBZ0IsSUFBSSxjQUFjLGFBQWEsUUFBUSxxQkFBcUIsZUFBZSxlQUFlLFlBQVksMkJBQTJCLEtBQUssa0NBQWtDLDZDQUE2QyxLQUFLLGtEQUFrRCx5QkFBeUIsOEJBQThCLElBQUksRUFBRSxhQUFhLFVBQVUscUNBQXFDLE1BQU0sd0NBQXdDLE1BQU0sMkNBQTJDLG9FQUFvRSw4S0FBOEsseUJBQXlCLHlCQUF5QixzQkFBc0IsV0FBVyxFQUFFLHdCQUF3QixxQkFBcUIsb0NBQW9DLFVBQVUsZUFBZSxNQUFNLHFDQUFxQyxNQUFNLDBDQUEwQyxNQUFNLDhCQUE4Qix3QkFBd0IsV0FBVyxvQkFBb0IseUJBQXlCLEVBQUUsbUJBQW1CLEVBQUUsaUJBQWlCLEVBQUUsZUFBZSxVQUFVLGFBQWEsYUFBYSxtQkFBbUIsMkNBQTJDLDBEQUEwRCxpQkFBaUIsT0FBTywrQkFBK0IsaUNBQWlDLHlDQUF5QyxzQ0FBc0MsV0FBVywrQkFBK0IsWUFBWSw4QkFBOEIseUJBQXlCLE1BQU0saUJBQWlCLG1CQUFtQix3QkFBd0IsUUFBUSxXQUFXLDZCQUE2QixhQUFhLFNBQVMsYUFBYSxjQUFjLGtEQUFrRCxxRUFBcUUsa0JBQWtCLHFEQUFxRCxrQkFBa0IscURBQXFELGdCQUFnQiwwREFBMEQsZ0JBQWdCLDBEQUEwRCxrRkFBa0YsY0FBYyxvQkFBb0IsY0FBYyw2Q0FBNkMsbUNBQW1DLDZEQUE2RCxzRkFBc0YsS0FBSyx1Q0FBdUMsMkVBQTJFLGtCQUFrQixvREFBb0QsNEZBQTRGLHNIQUFzSCwrQ0FBK0MscUVBQXFFLGtCQUFrQixxR0FBcUcsa0JBQWtCLHFHQUFxRyxnQkFBZ0IsMEdBQTBHLGdCQUFnQiwwR0FBMEcsc0ZBQXNGLGNBQWMsd0JBQXdCLGNBQWMsMERBQTBELGdEQUFnRCwyRUFBMkUsS0FBSyxNQUFNLHdGQUF3RixLQUFLLHVDQUF1QywwSEFBMEgsc0JBQXNCLGlGQUFpRix5RkFBeUYsMElBQTBJLEtBQUssa0JBQWtCLDREQUE0RCxrQkFBa0IsNERBQTRELGdCQUFnQixpREFBaUQsZ0JBQWdCLGlEQUFpRCxlQUFlLGVBQWUsYUFBYSw2QkFBNkIsSUFBSSxvREFBb0QseURBQXlELFVBQVUsWUFBWSx1QkFBdUIsVUFBVSxhQUFhLDBCQUEwQixpQ0FBaUMsbUJBQW1CLHdCQUF3QixvQkFBb0IsdUJBQXVCLDRCQUE0QixjQUFjLGFBQWEsUUFBUSxxQkFBcUIsb0JBQW9CLFdBQVcsZ0hBQWdILFNBQVMsd0JBQXdCLGtCQUFrQiwwQkFBMEIsSUFBSSx1U0FBdVMsK0hBQStILHlCQUF5QixvQkFBb0IsV0FBVyx5U0FBeVMsWUFBWSxjQUFjLGFBQWEsZ0JBQWdCLGlCQUFpQixjQUFjLDZDQUE2Qyx3QkFBd0Isa0RBQWtELDRCQUE0QixtQkFBbUIsZ0RBQWdELHFCQUFxQix1RUFBdUUsMEJBQTBCLDBCQUEwQixxQkFBcUIsZ0JBQWdCLGtCQUFrQiwrREFBK0QsbUJBQW1CLGlCQUFpQixJQUFJLDZEQUE2RCxTQUFTLGdDQUFnQyw4Q0FBOEMsZ0NBQWdDLDRCQUE0QixpQ0FBaUMsa0JBQWtCLCtCQUErQixPQUFPLGtCQUFrQixtQ0FBbUMsRUFBRSxVQUFVLEVBQUUsVUFBVSxFQUFFLFVBQVUsRUFBRSxVQUFVLEdBQUcseURBQXlELEdBQUcsU0FBUyxVQUFVLFlBQVksV0FBVyxJQUFJLHU2QkFBdTZCLFVBQVUsVUFBVSxrQkFBa0IsNkNBQTZDLGNBQWMsNkJBQTZCLHVFQUF1RSxTQUFTLGFBQWEsUUFBUSxNQUFNLGdCQUFnQixVQUFVLDBKQUEwSixnQkFBZ0IseUJBQXlCLE1BQU0sZ0JBQWdCLGlCQUFpQixLQUFLLGtCQUFrQixtQkFBbUIsMENBQTBDLGtCQUFrQixvQkFBb0Isd0NBQXdDLGVBQWUsa0JBQWtCLDRDQUE0Qyx3RUFBd0UsbUZBQW1GLE1BQU0sdURBQXVELDRDQUE0Qyw0QkFBNEIsV0FBVyxNQUFNLDhEQUE4RCxRQUFRLGdCQUFnQixxQkFBcUIsOEJBQThCLHNCQUFzQixnQkFBZ0IsMkdBQTJHLDZCQUE2QiwrQ0FBK0MsU0FBUyxjQUFjLFVBQVUsV0FBVyxRQUFRLGNBQWMsU0FBUyxZQUFZLFlBQVksMEJBQTBCLGNBQWMsa0JBQWtCLHVCQUF1QiwwQkFBMEIsY0FBYyxrQkFBa0IsbUJBQW1CLDJDQUEyQyx1QkFBdUIsaUZBQWlGLHdCQUF3QiwrQ0FBK0MsMkJBQTJCLHNCQUFzQixlQUFlLDhDQUE4QywyQ0FBMkMsaUNBQWlDLCtDQUErQyxFQUFFLDJEQUEyRCw2QkFBNkIsS0FBSyxXQUFXLFNBQVMsVUFBVSwwQkFBMEIsaUJBQWlCLGtDQUFrQyxxQkFBcUIseUJBQXlCLGdCQUFnQixpQ0FBaUMsb0JBQW9CLDRCQUE0QixxRUFBcUUsK0NBQStDLGlCQUFpQixLQUFLLDZCQUE2QixxQkFBcUIsbUNBQW1DLHdDQUF3QyxrQ0FBa0MseUJBQXlCLG1DQUFtQyxvQkFBb0IsdUJBQXVCLHFCQUFxQix1QkFBdUIsc0JBQXNCLDRIQUE0SCx1Q0FBdUMsa0JBQWtCLDJEQUEyRCxzQkFBc0IsK0NBQStDLHVCQUF1QiwwRUFBMEUsc0JBQXNCLHFEQUFxRCx1QkFBdUIsNEVBQTRFLHNDQUFzQyx5Q0FBeUMsOElBQThJLHNDQUFzQyxxREFBcUQsa0NBQWtDLGVBQWUsa0lBQWtJLGtKQUFrSix3QkFBd0Isd0NBQXdDLHlDQUF5QywwQkFBMEIsZ0dBQWdHLHVCQUF1QixtQ0FBbUMsbUNBQW1DLDJGQUEyRixpREFBaUQsNEVBQTRFLGdKQUFnSixnT0FBZ08sdUNBQXVDLDZEQUE2RCxVQUFVLGdMQUFnTCwwQ0FBMEMsa0JBQWtCLHNEQUFzRCwrQkFBK0IsSUFBSSxLQUFLLGtKQUFrSixvQ0FBb0MsMkZBQTJGLGlEQUFpRCxJQUFJLFdBQVcsU0FBUyxFQUFFLG9EQUFvRCxnRkFBZ0Ysd0JBQXdCLG9DQUFvQyx3Q0FBd0MsU0FBUyxxQ0FBcUMsb0pBQW9KLGdEQUFnRCw2Q0FBNkMsbUJBQW1CLHVFQUF1RSxrQkFBa0IsdUVBQXVFLG1CQUFtQix1RUFBdUUseUJBQXlCLDRJQUE0SSw0Q0FBNEMsOEpBQThKLHFEQUFxRCw4Q0FBOEMsZ0JBQWdCLDZGQUE2RixnRkFBZ0YsbURBQW1ELHlCQUF5QixtREFBbUQsdUJBQXVCLDJDQUEyQyx3QkFBd0IsMkJBQTJCLDRFQUE0RSx3QkFBd0IsMkJBQTJCLDRFQUE0RSw2QkFBNkIsK0NBQStDLDZCQUE2Qiw4RUFBOEUsNkJBQTZCLCtFQUErRSxnQkFBZ0IsYUFBYSx5RkFBeUYsRUFBRSxhQUFhLGVBQWUsMk9BQTJPLGNBQWMsNkdBQTZHLFdBQVcsd0NBQXdDLDBaQUEwWixnQkFBZ0Isd0JBQXdCLG1lQUFtZSxvQkFBb0IsWUFBWSxrQkFBa0IseUJBQXlCLFdBQVcsZ0NBQWdDLDRCQUE0QixnQkFBZ0IsdUJBQXVCLFdBQVcsNkNBQTZDLG1CQUFtQixxQ0FBcUMsNkNBQTZDLG1CQUFtQix5RUFBeUUsMkNBQTJDLGtCQUFrQix1RUFBdUUsMlBBQTJQLGlDQUFpQyxpQ0FBaUMsd0JBQXdCLGdDQUFnQywrREFBK0QsUUFBUSxFQUFFLGlCQUFpQixjQUFjLHlCQUF5QixNQUFNLGlDQUFpQyxNQUFNLCtCQUErQixNQUFNLHlCQUF5QixNQUFNLHFCQUFxQixNQUFNLHFCQUFxQixNQUFNLHFCQUFxQixNQUFNLG1EQUFtRCxNQUFNLGtEQUFrRCxNQUFNLHVGQUF1RixRQUFRLDBCQUEwQiw4QkFBOEIsTUFBTSw2RUFBNkUsUUFBUSx3QkFBd0IsNEJBQTRCLE1BQU0sNkVBQTZFLE1BQU0sNEdBQTRHLE1BQU0sdUdBQXVHLE1BQU0seUJBQXlCLFNBQVMsK0JBQStCLDhEQUE4RCxzQkFBc0Isd0RBQXdELDZGQUE2Rix5SEFBeUgsaUhBQWlILHlEQUF5RCwwQ0FBMEMsK0VBQStFLHFGQUFxRiw0SUFBNEkscUhBQXFILHFGQUFxRixvRkFBb0YsK0NBQStDLDJEQUEyRCxZQUFZLGtCQUFrQixzRUFBc0UsMkNBQTJDLHVEQUF1RCxRQUFRLGdCQUFnQiwySUFBMkksaURBQWlELDZEQUE2RCxRQUFRLG1CQUFtQiwwSEFBMEgsaURBQWlELDZEQUE2RCxRQUFRLG1CQUFtQixvRUFBb0UsK0NBQStDLDJEQUEyRCxRQUFRLGtCQUFrQixLQUFLLE1BQU0sOERBQThELFlBQVksMEJBQTBCLCtDQUErQyxnQ0FBZ0MscUtBQXFLLGdDQUFnQyxNQUFNLDRCQUE0QixNQUFNLDBCQUEwQixNQUFNLDZCQUE2QixNQUFNLDZCQUE2QixNQUFNLDRCQUE0QixNQUFNLDZCQUE2QixNQUFNLDJCQUEyQixNQUFNLDhCQUE4QixNQUFNLDhCQUE4QixNQUFNLCtCQUErQixtWEFBbVgsbUZBQW1GLHVDQUF1QyxjQUFjLG1GQUFtRixzQ0FBc0MsYUFBYSwyRkFBMkYsWUFBWSxZQUFZLGtCQUFrQixvQ0FBb0MsV0FBVyx1RkFBdUYsa0JBQWtCLGdCQUFnQixrUkFBa1IsY0FBYyw2RkFBNkYscUJBQXFCLG1CQUFtQiwyS0FBMkssY0FBYyw2RkFBNkYscUJBQXFCLG1CQUFtQixLQUFLLGtHQUFrRywwREFBMEQsYUFBYSwyRkFBMkYsb0JBQW9CLGtCQUFrQixLQUFLLGdHQUFnRyx1REFBdUQsU0FBUywwQkFBMEIsUUFBUSxFQUFFLFNBQVMscUdBQXFHLDJCQUEyQix5QkFBeUIsa0VBQWtFLGdDQUFnQyxpS0FBaUsseXFCQUF5cUIsWUFBWSxZQUFZLGtCQUFrQiwrRUFBK0UsMkNBQTJDLGdCQUFnQixzUEFBc1Asb0RBQW9ELG1CQUFtQiw0SkFBNEosb0RBQW9ELG1CQUFtQiw2REFBNkQsaURBQWlELGtCQUFrQiwwREFBMEQsOFJBQThSLCtCQUErQiw0REFBNEQsNEJBQTRCLFFBQVEsb0JBQW9CLDBOQUEwTixLQUFLLCtCQUErQixjQUFjLGtDQUFrQyxXQUFXLHdDQUF3QywrRkFBK0YsZ0JBQWdCLHdCQUF3Qix1UkFBdVIsaUNBQWlDLGlDQUFpQyx3QkFBd0IsZ0NBQWdDLCtEQUErRCxRQUFRLEVBQUUsaUJBQWlCLGNBQWMseUJBQXlCLE1BQU0sb0RBQW9ELE1BQU0sOEJBQThCLE1BQU0seUJBQXlCLFNBQVMsK0JBQStCLDhEQUE4RCxzQkFBc0Isd0RBQXdELDZGQUE2RiwyQ0FBMkMsc0NBQXNDLHFCQUFxQixvSEFBb0gsMEJBQTBCLCtDQUErQyxnQ0FBZ0MsdURBQXVELHlGQUF5RiwyQ0FBMkMsOERBQThELDBCQUEwQixRQUFRLEVBQUUsU0FBUyxxUkFBcVIsK0JBQStCLDREQUE0RCxHQUFHLDBCQUEwQixjQUFjLGlGQUFpRixXQUFXLHdDQUF3Qyx1TkFBdU4sZ0JBQWdCLHdCQUF3QiwrREFBK0QsaUJBQWlCLG9DQUFvQywyQ0FBMkMsa0JBQWtCLHFDQUFxQywrTEFBK0wscUJBQXFCLDhFQUE4RSxzS0FBc0ssaUNBQWlDLGlDQUFpQyx3QkFBd0IsZ0NBQWdDLDBEQUEwRCxRQUFRLEVBQUUsaUJBQWlCLGNBQWMsc0VBQXNFLE1BQU0sMEVBQTBFLE1BQU0seUJBQXlCLE1BQU0sMkJBQTJCLE1BQU0sMkJBQTJCLE1BQU0sc0hBQXNILE1BQU0sOEJBQThCLE1BQU0seUJBQXlCLFNBQVMsK0JBQStCLDhEQUE4RCxzQkFBc0Isd0RBQXdELDZDQUE2Qyx5REFBeUQsWUFBWSxpQkFBaUIsZ0VBQWdFLCtDQUErQywyREFBMkQsUUFBUSxrQkFBa0Isa0VBQWtFLDZGQUE2RixxR0FBcUcscUdBQXFHLHFEQUFxRCxpRUFBaUUsUUFBUSxxQkFBcUIsS0FBSyxtREFBbUQsMkJBQTJCLG9IQUFvSCwwQkFBMEIsMENBQTBDLDJCQUEyQixZQUFZLG9GQUFvRixXQUFXLFlBQVksaUJBQWlCLGtDQUFrQyxhQUFhLHNGQUFzRixvQkFBb0Isa0JBQWtCLG9DQUFvQyw4SUFBOEksNEZBQTRGLHVCQUF1QixxQkFBcUIsS0FBSyxpR0FBaUcsaUVBQWlFLDhEQUE4RCwwQkFBMEIsUUFBUSxFQUFFLFNBQVMsMkpBQTJKLFdBQVcsWUFBWSxpQkFBaUIsMEJBQTBCLGlEQUFpRCxrQkFBa0IsNEJBQTRCLGtMQUFrTCxxQkFBcUIsb0VBQW9FLHFKQUFxSiwrQkFBK0IsNERBQTRELEdBQUcsMkJBQTJCLGNBQWMsNEVBQTRFLFdBQVcsd0NBQXdDLDBWQUEwVixnQkFBZ0Isd0JBQXdCLDhyQkFBOHJCLHVCQUF1QixvRkFBb0YseURBQXlELHlCQUF5QiwyRkFBMkYsU0FBUyxpQ0FBaUMsaUNBQWlDLHdCQUF3QixnQ0FBZ0MsMkRBQTJELFFBQVEsRUFBRSxpQkFBaUIsY0FBYyw2QkFBNkIsTUFBTSxrSUFBa0ksTUFBTSxpQ0FBaUMsTUFBTSxvQ0FBb0MsTUFBTSwyQkFBMkIsTUFBTSxnQ0FBZ0MsTUFBTSw4QkFBOEIsTUFBTSxzREFBc0QsTUFBTSwrSUFBK0ksTUFBTSx5QkFBeUIsU0FBUywrQkFBK0IsOERBQThELHNCQUFzQix3REFBd0Qsb01BQW9NLHlEQUF5RCxxRUFBcUUsWUFBWSx1QkFBdUIsbUZBQW1GLDZIQUE2SCx5SUFBeUkscUdBQXFHLHlOQUF5TixpSEFBaUgsb0dBQW9HLDZEQUE2RCx5RUFBeUUsUUFBUSx5QkFBeUIsS0FBSyxNQUFNLHdGQUF3RixZQUFZLDBCQUEwQiwyQ0FBMkMsNEJBQTRCLDZVQUE2VSxpR0FBaUcsaUJBQWlCLFlBQVksdUJBQXVCLEtBQUssc0dBQXNHLHlFQUF5RSwwbEJBQTBsQix1RkFBdUYsOENBQThDLG9CQUFvQixxR0FBcUcsMkJBQTJCLHlCQUF5QixLQUFLLDBHQUEwRyxpRkFBaUYsU0FBUywwQkFBMEIsUUFBUSxFQUFFLFNBQVMsNkVBQTZFLFdBQVcseUJBQXlCLDBFQUEwRSx3Q0FBd0MsZ09BQWdPLDJsQ0FBMmxDLGlCQUFpQixZQUFZLHVCQUF1Qiw0RUFBNEUsc0VBQXNFLHlCQUF5QixvRkFBb0YsU0FBUywrQkFBK0IsNERBQTRELEdBQUcsdUNBQXVDLGNBQWMsa0NBQWtDLFdBQVcsd0NBQXdDLG9FQUFvRSxnQkFBZ0Isd0JBQXdCLG1LQUFtSyxpQ0FBaUMsaUNBQWlDLHdCQUF3QixnQ0FBZ0MsdUVBQXVFLFFBQVEsRUFBRSxpQkFBaUIsY0FBYyx3QkFBd0IsTUFBTSwwQkFBMEIsTUFBTSx5QkFBeUIsU0FBUywrQkFBK0IsOERBQThELHNCQUFzQixrT0FBa08sMEJBQTBCLHVEQUF1RCx3Q0FBd0MscUZBQXFGLDBCQUEwQixRQUFRLEVBQUUsU0FBUywySkFBMkosK0JBQStCLDREQUE0RCxHQUFHLGlDQUFpQyxjQUFjLG9FQUFvRSxXQUFXLHdDQUF3Qyx5R0FBeUcsZ0JBQWdCLHdCQUF3Qiw2TEFBNkwscUNBQXFDLHNHQUFzRyxTQUFTLGlDQUFpQyxpQ0FBaUMsd0JBQXdCLGdDQUFnQyxpRUFBaUUsUUFBUSxFQUFFLGlCQUFpQixjQUFjLCtCQUErQixNQUFNLDhMQUE4TCxNQUFNLHlCQUF5QixTQUFTLCtCQUErQiw4REFBOEQsc0JBQXNCLHdEQUF3RCxxSEFBcUgscUZBQXFGLGlHQUFpRyxZQUFZLHFDQUFxQyxLQUFLLDJFQUEyRSwyQ0FBMkMsWUFBWSwwQkFBMEIsaURBQWlELGtDQUFrQyx3RkFBd0YsbUlBQW1JLCtCQUErQixZQUFZLHFDQUFxQyxLQUFLLHdJQUF3SSx5R0FBeUcsU0FBUywwQkFBMEIsUUFBUSxFQUFFLFNBQVMsMk9BQTJPLCtCQUErQixZQUFZLHFDQUFxQyw0R0FBNEcsU0FBUywrQkFBK0IsNERBQTRELEdBQUcsMkJBQTJCLGNBQWMsaUpBQWlKLFdBQVcsd0NBQXdDLDhSQUE4UixnQkFBZ0Isd0JBQXdCLDZEQUE2RCxnQkFBZ0Isb0VBQW9FLHlIQUF5SCx1QkFBdUIsNkVBQTZFLDRIQUE0SCxpQkFBaUIsMEVBQTBFLDJDQUEyQyxrQkFBa0IsMkVBQTJFLGlEQUFpRCxxQkFBcUIsK0VBQStFLDJFQUEyRSxrQ0FBa0MsOEZBQThGLFNBQVMsaUNBQWlDLGlDQUFpQyx3QkFBd0IsZ0NBQWdDLDJEQUEyRCxRQUFRLEVBQUUsaUJBQWlCLGNBQWMsNkZBQTZGLE1BQU0seUJBQXlCLE1BQU0sMkhBQTJILE1BQU0sK0JBQStCLE1BQU0sdUdBQXVHLE1BQU0sMkdBQTJHLE1BQU0sdUhBQXVILE1BQU0sNktBQTZLLE1BQU0seUJBQXlCLFNBQVMsK0JBQStCLDhEQUE4RCxzQkFBc0Isd0RBQXdELDJDQUEyQyx1REFBdUQsWUFBWSxnQkFBZ0IsNERBQTRELDZGQUE2Rix5REFBeUQscUVBQXFFLFFBQVEsdUJBQXVCLDRFQUE0RSxpSEFBaUgsNkNBQTZDLHlEQUF5RCxRQUFRLGlCQUFpQixtRUFBbUUsK0NBQStDLDJEQUEyRCxRQUFRLGtCQUFrQixxRUFBcUUscURBQXFELGlFQUFpRSxRQUFRLHFCQUFxQiwyRUFBMkUsK0VBQStFLDJGQUEyRixRQUFRLGtDQUFrQyxLQUFLLE1BQU0sb0dBQW9HLFlBQVksMEJBQTBCLDJDQUEyQyw0QkFBNEIsV0FBVyxtRkFBbUYsVUFBVSxZQUFZLGdCQUFnQixLQUFLLHdGQUF3RixrREFBa0Qsd0RBQXdELGlHQUFpRyx5QkFBeUIsdUJBQXVCLEtBQUssc0dBQXNHLGtFQUFrRSxpRUFBaUUscUZBQXFGLG1CQUFtQixpQkFBaUIsS0FBSywwRkFBMEYseURBQXlELGFBQWEsdUZBQXVGLG9CQUFvQixrQkFBa0IsS0FBSyw0RkFBNEYsMkRBQTJELGdCQUFnQiw2RkFBNkYsdUJBQXVCLHFCQUFxQixLQUFLLGtHQUFrRyxpRUFBaUUsNkJBQTZCLHVIQUF1SCxvQ0FBb0Msa0NBQWtDLEtBQUssNEhBQTRILDZGQUE2RixTQUFTLDBCQUEwQixRQUFRLEVBQUUsU0FBUyx3TEFBd0wsVUFBVSxZQUFZLGdCQUFnQixxREFBcUQsd0hBQXdILHVCQUF1QixxRUFBcUUsMEhBQTBILGlCQUFpQiw0REFBNEQsaURBQWlELGtCQUFrQiw4REFBOEQsMERBQTBELHFCQUFxQixvRUFBb0UsaUdBQWlHLGtDQUFrQyxnR0FBZ0csU0FBUywrQkFBK0IsNERBQTRELEdBQUcsNEJBQTRCLGNBQWMsbUxBQW1MLFdBQVcsd0NBQXdDLGlkQUFpZCxnQkFBZ0Isd0JBQXdCLGtEQUFrRCxvQkFBb0IsWUFBWSxnQkFBZ0IsdUJBQXVCLFdBQVcsaVBBQWlQLDRCQUE0QixxQkFBcUIsNEJBQTRCLFdBQVcsMENBQTBDLDRCQUE0QixxQkFBcUIsNEJBQTRCLFdBQVcsbURBQW1ELHNCQUFzQix3Q0FBd0MsMENBQTBDLDRCQUE0QixxQkFBcUIsNEJBQTRCLFdBQVcsNExBQTRMLDRCQUE0QixzQkFBc0IsOEJBQThCLFdBQVcsNENBQTRDLDRCQUE0QixzQkFBc0IsOEJBQThCLFdBQVcsMElBQTBJLHdCQUF3QiwwRkFBMEYscUdBQXFHLGlDQUFpQyxpQ0FBaUMsd0JBQXdCLGdDQUFnQyw0REFBNEQsUUFBUSxFQUFFLGlCQUFpQixjQUFjLGlGQUFpRixRQUFRLHdCQUF3Qiw0QkFBNEIsTUFBTSw0QkFBNEIsTUFBTSxpRUFBaUUsTUFBTSw0RkFBNEYsUUFBUSw2QkFBNkIsaUNBQWlDLE1BQU0sNEZBQTRGLFFBQVEsNkJBQTZCLGlDQUFpQyxNQUFNLHlGQUF5RixNQUFNLDRGQUE0RixRQUFRLDZCQUE2QixpQ0FBaUMsTUFBTSx5QkFBeUIsTUFBTSwrQkFBK0IsTUFBTSwyQkFBMkIsTUFBTSwySUFBMkksTUFBTSxpQ0FBaUMsTUFBTSxnR0FBZ0csUUFBUSwrQkFBK0IsbUNBQW1DLE1BQU0sZ0dBQWdHLFFBQVEsK0JBQStCLG1DQUFtQyxNQUFNLHlCQUF5QixTQUFTLCtCQUErQiw4REFBOEQsc0JBQXNCLHdEQUF3RCwyQ0FBMkMsdURBQXVELFlBQVksZ0JBQWdCLDJJQUEySSwrR0FBK0cscUhBQXFILHFEQUFxRCxpRUFBaUUsUUFBUSxxQkFBcUIsNEVBQTRFLHFEQUFxRCxpRUFBaUUsUUFBUSxxQkFBcUIsMEVBQTBFLHVEQUF1RCxtRUFBbUUsUUFBUSxzQkFBc0Isc0lBQXNJLHFEQUFxRCxpRUFBaUUsUUFBUSxxQkFBcUIsb0tBQW9LLDZGQUE2RixpSEFBaUgseUpBQXlKLDJEQUEyRCx1RUFBdUUsUUFBUSx3QkFBd0IsS0FBSyxNQUFNLHNGQUFzRixpRkFBaUYsa0RBQWtELGVBQWUsdURBQXVELG1FQUFtRSxRQUFRLHNCQUFzQiw4RUFBOEUsdURBQXVELG1FQUFtRSxRQUFRLHNCQUFzQix5S0FBeUssWUFBWSwwQkFBMEIsNENBQTRDLDZCQUE2QixXQUFXLG9GQUFvRixVQUFVLFlBQVksZ0JBQWdCLGtSQUFrUixnRUFBZ0UsNEZBQTRGLDJEQUEyRCxnQkFBZ0IsOEZBQThGLHVCQUF1QixxQkFBcUIsMENBQTBDLGdCQUFnQiw4RkFBOEYsdUJBQXVCLHFCQUFxQixvQ0FBb0MsaUJBQWlCLGdHQUFnRyx3QkFBd0Isc0JBQXNCLGdNQUFnTSxnQkFBZ0IsOEZBQThGLHVCQUF1QixxQkFBcUIsOFVBQThVLG1SQUFtUixvR0FBb0csMEJBQTBCLHdCQUF3QixLQUFLLHlHQUF5RywrRUFBK0UsdUJBQXVCLHNDQUFzQyxNQUFNLHVDQUF1QyxpQkFBaUIsZ0dBQWdHLHdCQUF3QixzQkFBc0IsNENBQTRDLGlCQUFpQixnR0FBZ0csd0JBQXdCLHNCQUFzQiw0VkFBNFYsU0FBUywwQkFBMEIsUUFBUSxFQUFFLFNBQVMsNlhBQTZYLFVBQVUsWUFBWSxnQkFBZ0Isc1BBQXNQLDZPQUE2TyxxQkFBcUIsMkZBQTJGLDBEQUEwRCxxQkFBcUIsa0NBQWtDLDZEQUE2RCxzQkFBc0IsMktBQTJLLDBEQUEwRCxxQkFBcUIsbVNBQW1TLDhTQUE4UyxzQkFBc0IsK0ZBQStGLDZEQUE2RCxzQkFBc0IsOFNBQThTLCtJQUErSSx3QkFBd0Isa0ZBQWtGLGtLQUFrSywrQkFBK0IsNERBQTRELHVCQUF1QixRQUFRLG9CQUFvQiw4VkFBOFYsd0JBQXdCLGNBQWMsa0NBQWtDLFdBQVcsd0NBQXdDLGdJQUFnSSxnQkFBZ0Isd0JBQXdCLGdLQUFnSyxpQ0FBaUMsaUNBQWlDLHdCQUF3QixnQ0FBZ0Msb0VBQW9FLFFBQVEsRUFBRSxpQkFBaUIsY0FBYyx5QkFBeUIsTUFBTSx1QkFBdUIsTUFBTSx5QkFBeUIsU0FBUywrQkFBK0IsOERBQThELHNCQUFzQiwwV0FBMFcsMEJBQTBCLG9EQUFvRCxxQ0FBcUMsNmZBQTZmLDBCQUEwQixRQUFRLEVBQUUsU0FBUyxlQUFlLFdBQVcseUJBQXlCLHNFQUFzRSxvQ0FBb0MsK0hBQStILDJnQkFBMmdCLCtCQUErQiw0REFBNEQsR0FBRyw2QkFBNkIsUUFBUSxvQkFBb0Isa0RBQWtELEtBQUssaUNBQWlDLGNBQWMsOENBQThDLFdBQVcsd0NBQXdDLHlEQUF5RCxnQkFBZ0Isd0JBQXdCLDJEQUEyRCxlQUFlLG9GQUFvRixTQUFTLGlDQUFpQyxpQ0FBaUMsd0JBQXdCLGdDQUFnQyxpRUFBaUUsUUFBUSxFQUFFLGlCQUFpQiw4SEFBOEgsU0FBUywrQkFBK0IsOERBQThELHNCQUFzQix3REFBd0QseUNBQXlDLHFEQUFxRCxZQUFZLGVBQWUsS0FBSyx5REFBeUQscUJBQXFCLFlBQVksMEJBQTBCLGlEQUFpRCxrQ0FBa0MsVUFBVSx1RkFBdUYsU0FBUyxZQUFZLGVBQWUsS0FBSyw0RkFBNEYsaUVBQWlFLFNBQVMsMEJBQTBCLFFBQVEsRUFBRSxTQUFTLDJEQUEyRCxTQUFTLFlBQVksZUFBZSxvRUFBb0UsU0FBUywrQkFBK0IsNERBQTRELHdCQUF3QixjQUFjLGtDQUFrQyxXQUFXLHdDQUF3QyxNQUFNLDBKQUEwSixrRUFBa0UsdUJBQXVCLGdCQUFnQix3QkFBd0IsK1FBQStRLGlDQUFpQyxpQ0FBaUMsd0JBQXdCLGdDQUFnQywyRUFBMkUsUUFBUSxFQUFFLGlCQUFpQixjQUFjLDRCQUE0QixNQUFNLDZCQUE2QixNQUFNLCtCQUErQixNQUFNLHlCQUF5QixTQUFTLCtCQUErQiw4REFBOEQsc0JBQXNCLHdEQUF3RCxTQUFTLHlNQUF5TSxtREFBbUQsOENBQThDLHVFQUF1RSx3SEFBd0gsMEJBQTBCLDJEQUEyRCw0Q0FBNEMsaWFBQWlhLDBCQUEwQixRQUFRLEVBQUUsU0FBUywwaUJBQTBpQiwrQkFBK0IsNERBQTRELEdBQUcsS0FBSywwQkFBMEIsY0FBYyxrQ0FBa0MsV0FBVyx3Q0FBd0MsTUFBTSx3R0FBd0cseURBQXlELHVCQUF1QixnQkFBZ0Isd0JBQXdCLCtPQUErTyxpQ0FBaUMsaUNBQWlDLHdCQUF3QixnQ0FBZ0MsMERBQTBELFFBQVEsRUFBRSxpQkFBaUIsY0FBYyxpRUFBaUUsTUFBTSwrQkFBK0IsTUFBTSx5QkFBeUIsU0FBUywrQkFBK0IsOERBQThELHNCQUFzQix3REFBd0QsdURBQXVELG1EQUFtRCwyQkFBMkIsd0hBQXdILDBCQUEwQiwwQ0FBMEMsMkJBQTJCLHVCQUF1QixnR0FBZ0csOERBQThELGlFQUFpRSwwQkFBMEIsUUFBUSxFQUFFLFNBQVMsNFFBQTRRLCtCQUErQiw0REFBNEQscUJBQXFCLGNBQWMsa0NBQWtDLFdBQVcsd0NBQXdDLDBFQUEwRSxnQkFBZ0Isd0JBQXdCLHdOQUF3TixpQ0FBaUMsaUNBQWlDLHdCQUF3QixnQ0FBZ0MsaUVBQWlFLFFBQVEsRUFBRSxpQkFBaUIsY0FBYyw0QkFBNEIsTUFBTSw0REFBNEQsTUFBTSx5QkFBeUIsU0FBUywrQkFBK0IsOERBQThELHNCQUFzQix3REFBd0QsK0dBQStHLDZDQUE2Qyw4Q0FBOEMsc0JBQXNCLFlBQVksMEJBQTBCLGlEQUFpRCxrQ0FBa0MsOERBQThELDZGQUE2RixvREFBb0QsU0FBUywwQkFBMEIsUUFBUSxFQUFFLFNBQVMseU5BQXlOLCtCQUErQiw0REFBNEQsR0FBRyxLQUFLLG1DQUFtQyxjQUFjLGtDQUFrQyxXQUFXLHdDQUF3Qyx1R0FBdUcsZ0JBQWdCLHdCQUF3QixpTEFBaUwsaUNBQWlDLGlDQUFpQyx3QkFBd0IsZ0NBQWdDLG1FQUFtRSxRQUFRLEVBQUUsaUJBQWlCLGNBQWMsMkJBQTJCLE1BQU0sMkJBQTJCLE1BQU0seUJBQXlCLFNBQVMsK0JBQStCLDhEQUE4RCxzQkFBc0IsbVVBQW1VLDBCQUEwQixtREFBbUQsb0NBQW9DLHNWQUFzViwwQkFBMEIsUUFBUSxFQUFFLFNBQVMscUNBQXFDLHlCQUF5Qix3RUFBd0Usc0NBQXNDLDJXQUEyVywrQkFBK0IsNERBQTRELEdBQUcsa0JBQWtCLGdCQUFnQixhQUFhLGtCQUFrQixnQkFBZ0IsYUFBYSxRQUFRLGFBQWEsNEZBQTRGLGdLQUFnSyxnQkFBZ0IsYUFBYSxZQUFZLHNDQUFzQyxnQkFBZ0IseUVBQXlFLGNBQWMsd0NBQXdDLG1EQUFtRCw2REFBNkQsOEJBQThCLGFBQWEsb0NBQW9DLDhCQUE4QixjQUFjLDRCQUE0Qiw0QkFBNEIsMENBQTBDLEtBQUssSUFBSSxhQUFhLHFCQUFxQiwyQkFBMkIsS0FBSyxJQUFJLEtBQUssb0NBQW9DLG1GQUFtRix5REFBeUQsS0FBSyxJQUFJLHVGQUF1Riw4SEFBOEgsNEJBQTRCLEtBQUssSUFBSSx5RkFBeUYsVUFBVSxJQUFJLEtBQUssb0NBQW9DLHFGQUFxRix1Q0FBdUMsZ0JBQWdCLG1EQUFtRCxhQUFhLHVDQUF1Qyw4REFBOEQsZ0lBQWdJLG9FQUFvRSwyRUFBMkUsNEVBQTRFLDRFQUE0RSwyRUFBMkUsNkRBQTZELFNBQVMsK0JBQStCLHVCQUF1QiwrQkFBK0Isb0JBQW9CLHNCQUFzQiw2QkFBNkIseUJBQXlCLGdDQUFnQyx1Q0FBdUMsK0JBQStCLGlDQUFpQyx1Q0FBdUMsaUNBQWlDLDhCQUE4Qix1Q0FBdUMsNkNBQTZDLHFCQUFxQiwrQkFBK0IsdUNBQXVDLDhDQUE4QyxxQkFBcUIsOEJBQThCLDRDQUE0Qyw4QkFBOEIsZ0lBQWdJLCtCQUErQixtQkFBbUIsNEJBQTRCLDhCQUE4Qix1QkFBdUIsdUNBQXVDLFlBQVksUUFBUSxvQ0FBb0MsZ0NBQWdDLFlBQVksa0NBQWtDLFVBQVUsbUJBQW1CLE1BQU0sb0JBQW9CLE1BQU0sZ0NBQWdDLE1BQU0sWUFBWSx1QkFBdUIsa0JBQWtCLE1BQU0sb0JBQW9CLE1BQU0sbUVBQW1FLFlBQVksMEJBQTBCLGdDQUFnQyxpQ0FBaUMscUJBQXFCLGlCQUFpQiwyQkFBMkIsbUJBQW1CLDJCQUEyQixtQkFBbUIsc0NBQXNDLG9CQUFvQiwyQkFBMkIscUJBQXFCLDRCQUE0QixHQUFHLGVBQWUsYUFBYSxZQUFZLGNBQWMsdURBQXVELGNBQWMsY0FBYyxlQUFlLHdCQUF3Qix3REFBd0QsK0JBQStCLG9CQUFvQix5S0FBeUssZ0JBQWdCLFVBQVUsYUFBYSxhQUFhLGdCQUFnQixhQUFhLGtCQUFrQixnQkFBZ0IsYUFBYSxZQUFZLGNBQWMsa0JBQWtCLHNFQUFzRSw0R0FBNEcsOEdBQThHLG1EQUFtRCxXQUFXLHNDQUFzQyxpQkFBaUIsK0ZBQStGLHFDQUFxQyxhQUFhLHlCQUF5Qix1REFBdUQsU0FBUyxnQ0FBZ0Msb0NBQW9DLFVBQVUsR0FBRyxTQUFTLHVEQUF1RCxLQUFLLEtBQUssNEJBQTRCLDBCQUEwQixLQUFLLDZCQUE2QixzR0FBc0csZ0JBQWdCLGFBQWEsWUFBWSxjQUFjLGdCQUFnQiw0QkFBNEIsd0JBQXdCLHNCQUFzQixTQUFTLGtDQUFrQyxZQUFZLHFCQUFxQixVQUFVLG9DQUFvQyx5QkFBeUIsa0JBQWtCLFVBQVUsVUFBVSxtQ0FBbUMscUZBQXFGLG9CQUFvQiw2Q0FBNkMsa0JBQWtCLCtDQUErQyx1QkFBdUIsbURBQW1ELGtDQUFrQyxxQkFBcUIsb0NBQW9DLHdDQUF3QyxrQ0FBa0MsZ0NBQWdDLDBEQUEwRCxtREFBbUQsa0NBQWtDLHVCQUF1Qix3SkFBd0osK0JBQStCLGdKQUFnSixpQ0FBaUMsa0JBQWtCLGlGQUFpRixpQ0FBaUMsbUJBQW1CLGtGQUFrRiwrQkFBK0IsNkRBQTZELCtGQUErRixzQkFBc0IsYUFBYSxRQUFRLGtCQUFrQiw2QkFBNkIsV0FBVywyQ0FBMkMsU0FBUyxjQUFjLGdCQUFnQiwwQ0FBMEMsc0NBQXNDLGVBQWUsVUFBVSw4RkFBOEYsNEJBQTRCLGVBQWUsMkdBQTJHLGVBQWUsVUFBVSxrQ0FBa0MsbUNBQW1DLEdBQUcsNmFBQTZhLElBQUksMkNBQTJDLHlEQUF5RCx3QkFBd0IsOENBQThDLHdCQUF3Qiw2QkFBNkIsK0JBQStCLFdBQVcsa0hBQWtILHFCQUFxQixJQUFJLGlDQUFpQyxvQ0FBb0MsU0FBUyxhQUFhLDBFQUEwRSx3SkFBd0oscU9BQXFPLEVBQUUsaURBQWlELHlEQUF5RCw4QkFBOEIsNkJBQTZCLGtFQUFrRSxpQ0FBaUMsZ0RBQWdELDJFQUEyRSxZQUFZLEtBQUssV0FBVyxjQUFjLGtCQUFrQix5Q0FBeUMsS0FBSyx3RUFBd0UsMkJBQTJCLG1CQUFtQixZQUFZLFdBQVcsaUNBQWlDLGtCQUFrQiwrQ0FBK0MseUJBQXlCLGVBQWUsa0VBQWtFLGtCQUFrQixrREFBa0QsZ0JBQWdCLDZDQUE2QyxnQkFBZ0IsYUFBYSxZQUFZLGlEQUFpRCxrQkFBa0IsaURBQWlELGNBQWMsY0FBYyxvRUFBb0UsYUFBYSx1RUFBdUUsaUJBQWlCLDJCQUEyQiwyQkFBMkIsYUFBYSxJQUFJLFlBQVksZUFBZSxrQkFBa0IsV0FBVyxnQkFBZ0IsdUNBQXVDLGtCQUFrQixLQUFLLEtBQUssNERBQTRELEtBQUssU0FBUyxtQ0FBbUMsWUFBWSxrQkFBa0IsNERBQTRELGlDQUFpQyxzQkFBc0IseUdBQXlHLDhEQUE4RCx1RUFBdUUsS0FBSyxNQUFNLHlCQUF5QixPQUFPLGdDQUFnQyxtSEFBbUgsK0JBQStCLDJEQUEyRCxnQ0FBZ0MscUNBQXFDLGdDQUFnQyxnQkFBZ0Isa0NBQWtDLHFFQUFxRSwyQkFBMkIsa0NBQWtDLDhCQUE4Qiw2QkFBNkIsaUNBQWlDLDZCQUE2QiwwRUFBMEUsZ0JBQWdCLDRDQUE0Qyx3RUFBd0UsNENBQTRDLGdDQUFnQyw4Q0FBOEMsNENBQTRDLFdBQVcsaUJBQWlCLFlBQVksV0FBVyxpQkFBaUIsOEJBQThCLG1CQUFtQiwrQkFBK0Isa0JBQWtCLDZCQUE2QixvQkFBb0IsbUNBQW1DLGdDQUFnQyxrQkFBa0IsNkRBQTZELDZCQUE2QixnRkFBZ0YsOEJBQThCLG9MQUFvTCwrQkFBK0IsdUNBQXVDLHNGQUFzRiwrQkFBK0IsZ0VBQWdFLEVBQUUsbUNBQW1DLFNBQVMsMEJBQTBCLGlDQUFpQyxnQkFBZ0IsYUFBYSxZQUFZLGNBQWMsdURBQXVELGNBQWMsYUFBYSxhQUFhLGtCQUFrQiwwRUFBMEUsd0JBQXdCLHlKQUF5SixXQUFXLGlCQUFpQixpQ0FBaUMsaUJBQWlCLFdBQVcsZ0JBQWdCLCtCQUErQiw4Q0FBOEMsbUJBQW1CLGlFQUFpRSxnQ0FBZ0MsNkJBQTZCLGdEQUFnRCxnQkFBZ0IsZ0JBQWdCLGFBQWEsV0FBVywwQkFBMEIsY0FBYyxjQUFjLGdDQUFnQyx5QkFBeUIsNERBQTRELGdCQUFnQixhQUFhLGlCQUFpQiw4Q0FBOEMsVUFBVSxpVUFBaVUsd0ZBQXdGLHVEQUF1RCxnQkFBZ0IsYUFBYSxpQ0FBaUMsZ0NBQWdDLG1EQUFtRCxtREFBbUQsc0JBQXNCLGFBQWEsbUVBQW1FLGtCQUFrQiwyQ0FBMkMsOERBQThELDZCQUE2QixhQUFhLCtCQUErQixtQkFBbUIsNEJBQTRCLDJDQUEyQyxtRkFBbUYsc0NBQXNDLFNBQVMsZUFBZSxpQkFBaUIsa0JBQWtCLHNDQUFzQyxtQkFBbUIsMkdBQTJHLGFBQWEsYUFBYSxzQ0FBc0MsU0FBUyx1Q0FBdUMsUUFBUSxlQUFlLHNCQUFzQixlQUFlLDBGQUEwRixRQUFRLFdBQVcsb0JBQW9CLDBDQUEwQyxnQkFBZ0IsYUFBYSxzQ0FBc0MsU0FBUyxxQkFBcUIsOENBQThDLHFDQUFxQyxRQUFRLGVBQWUscUNBQXFDLG9NQUFvTSxpRkFBaUYsV0FBVyw4QkFBOEIsVUFBVSwyQkFBMkIsY0FBYyw2QkFBNkIsWUFBWSwyQkFBMkIsZUFBZSw4QkFBOEIsZUFBZSw4QkFBOEIsZUFBZSw4QkFBOEIsYUFBYSw0QkFBNEIsZ0JBQWdCLCtCQUErQixnQkFBZ0IsK0JBQStCLFdBQVcsZ0NBQWdDLGVBQWUsdUJBQXVCLGlEQUFpRCxFQUFFLEdBQUcsdURBQXVELEdBQUcsVUFBVSxLQUFLLEdBQUcsWUFBWSxrQkFBa0IsMkRBQTJELFVBQVUsNkRBQTZELHlEQUF5RCwrREFBK0QsK0RBQStELCtEQUErRCwyREFBMkQsaUVBQWlFLGlFQUFpRSxnRUFBZ0UsdUNBQXVDLElBQUksbUJBQW1CLDJEQUEyRCx5SkFBeUosZ0NBQWdDLHVHQUF1RyxpREFBaUQsZ0NBQWdDLFlBQVksV0FBVyxLQUFLLGFBQWEsZ0NBQWdDLFNBQVMsNElBQTRJLG9EQUFvRCwrRUFBK0UseUVBQXlFLHVGQUF1RixVQUFVLGdDQUFnQyx1SEFBdUgsMEJBQTBCLHFIQUFxSCx3Q0FBd0MsZUFBZSwwREFBMEQsd0RBQXdELDJEQUEyRCwyREFBMkQsMERBQTBELGdFQUFnRSw0REFBNEQsa0VBQWtFLGtFQUFrRSxnRUFBZ0UsdURBQXVELDRDQUE0QyxJQUFJLHVDQUF1QyxpQkFBaUIsd0NBQXdDLHNDQUFzQyx5Q0FBeUMseUNBQXlDLHdDQUF3QyxtREFBbUQsMkJBQTJCLFdBQVcsWUFBWSxpQkFBaUIsc0JBQXNCLFNBQVMsOEJBQThCLFdBQVcsWUFBWSxvQkFBb0IseUJBQXlCLFNBQVMsOEJBQThCLFdBQVcsWUFBWSxvQkFBb0IseUJBQXlCLFNBQVMsdURBQXVELDBCQUEwQixLQUFLLGNBQWMsZ0JBQWdCLGFBQWEsc0NBQXNDLFNBQVMsb0NBQW9DLDBCQUEwQixvQkFBb0Isa0JBQWtCLDhCQUE4QixVQUFVLDRLQUE0SyxRQUFRLGFBQWEscUJBQXFCLHNFQUFzRSxXQUFXLHlCQUF5QixzQ0FBc0MsMkJBQTJCLGlDQUFpQyxrQkFBa0IsaUJBQWlCLGNBQWMsbUJBQW1CLGVBQWUsZ0RBQWdELGdCQUFnQixhQUFhLHNDQUFzQyxTQUFTLHdCQUF3Qiw4Q0FBOEMscUJBQXFCLGdCQUFnQiw2QkFBNkIsaUJBQWlCLHdCQUF3Qix5QkFBeUIsc0NBQXNDLDBCQUEwQixpQ0FBaUMsdUJBQXVCLG9DQUFvQyx3QkFBd0IsK0JBQStCLFdBQVcsd0JBQXdCLFlBQVksbUJBQW1CLFlBQVkseUJBQXlCLGFBQWEsb0JBQW9CLGFBQWEsSUFBSSwyWEFBMlgsdUJBQXVCLDJCQUEyQiwwQkFBMEIsb0JBQW9CLHdCQUF3QixRQUFRLFlBQVksU0FBUyxXQUFXLE9BQU8sU0FBUyw2RUFBNkUsRUFBRSxPQUFPLHdCQUF3Qix5Q0FBeUMsVUFBVSwyQkFBMkIsZ0JBQWdCLGFBQWEsc0NBQXNDLFNBQVMseUJBQXlCLHdEQUF3RCwwQkFBMEIsZUFBZSxTQUFTLGVBQWUsMkdBQTJHLDZLQUE2SyxpQkFBaUIsU0FBUyxpQkFBaUIsT0FBTyxxR0FBcUcsaUNBQWlDLG1DQUFtQywwRUFBMEUsd0JBQXdCLFNBQVMsWUFBWSxpQkFBaUIsT0FBTyxxR0FBcUcsNENBQTRDLDZDQUE2QywrQ0FBK0Msd0JBQXdCLFNBQVMsWUFBWSwyQkFBMkIseUNBQXlDLGtHQUFrRyxrQ0FBa0MsaURBQWlELHFCQUFxQixpQkFBaUIseUNBQXlDLE1BQU0sOENBQThDLE1BQU0sOENBQThDLE1BQU0sOENBQThDLE1BQU0sK0NBQStDLDJDQUEyQyxZQUFZLHNEQUFzRCxNQUFNLFNBQVMsUUFBUSx1REFBdUQsb0NBQW9DLGlEQUFpRCxxQkFBcUIsaUJBQWlCLHlDQUF5QyxNQUFNLGdEQUFnRCxNQUFNLGdEQUFnRCxNQUFNLGdEQUFnRCxNQUFNLGdEQUFnRCxNQUFNLGdEQUFnRCxNQUFNLGdEQUFnRCxNQUFNLDhEQUE4RCxTQUFTLEdBQUcsOENBQThDLGNBQWMsc0RBQXNELHFCQUFxQixXQUFXLFFBQVEsb0RBQW9ELHdCQUF3Qiw0REFBNEQsbUJBQW1CLFNBQVMsU0FBUyw2QkFBNkIsVUFBVSxTQUFTLHVEQUF1RCw2Q0FBNkMsS0FBSyxJQUFJLGFBQWEscUZBQXFGLDZDQUE2QyxLQUFLLElBQUksYUFBYSwwRUFBMEUsMkZBQTJGLEtBQUssSUFBSSxLQUFLLEdBQUcsdUNBQXVDLE1BQU0sY0FBYyxXQUFXLG1DQUFtQyw2QkFBNkIsU0FBUyw2RUFBNkUsbURBQW1ELEtBQUssSUFBSSxLQUFLLEdBQUcsV0FBVyxrQ0FBa0MsOEJBQThCLDZDQUE2QywwRkFBMEYsS0FBSyxJQUFJLEtBQUssR0FBRyx5Q0FBeUMsTUFBTSxhQUFhLDJGQUEyRixFQUFFLE1BQU0sbUNBQW1DLEVBQUUsRUFBRSxpQ0FBaUMsV0FBVyxrQ0FBa0MsNkJBQTZCLG9HQUFvRywwRkFBMEYsS0FBSyxJQUFJLEtBQUssR0FBRyx1Q0FBdUMsTUFBTSxhQUFhLGdDQUFnQyxHQUFHLDJCQUEyQixHQUFHLDJGQUEyRixFQUFFLE1BQU0sbUNBQW1DLEVBQUUsRUFBRSxvQ0FBb0MsV0FBVyxVQUFVLCtCQUErQiw2QkFBNkIsZ0ZBQWdGLHlCQUF5QixZQUFZLGFBQWEseUNBQXlDLEdBQUcsWUFBWSxHQUFHLG9CQUFvQixHQUFHLElBQUksR0FBRyxnQkFBZ0IsRUFBRSxNQUFNLHVCQUF1QixVQUFVLG1CQUFtQixzRkFBc0YsS0FBSyxJQUFJLEtBQUssR0FBRyxxQ0FBcUMsTUFBTSxhQUFhLGNBQWMsRUFBRSw4QkFBOEIsR0FBRyx5QkFBeUIsR0FBRyx1RkFBdUYsRUFBRSxNQUFNLGlDQUFpQyxFQUFFLEVBQUUseUJBQXlCLFNBQVMsR0FBRyxFQUFFLEVBQUUsU0FBUyxRQUFRLCtCQUErQiwrQkFBK0IsMENBQTBDLDBGQUEwRixLQUFLLElBQUksS0FBSyxHQUFHLGtDQUFrQyxNQUFNLGFBQWEsV0FBVyxVQUFVLCtCQUErQiwrQkFBK0IsNENBQTRDLDBGQUEwRixLQUFLLElBQUksS0FBSyxHQUFHLHVDQUF1QyxNQUFNLGFBQWEsOEJBQThCLE1BQU0sa0NBQWtDLE1BQU0sK0JBQStCLFdBQVcsVUFBVSwrQkFBK0IsK0JBQStCLFNBQVMsaUJBQWlCLFdBQVcsMkNBQTJDLGNBQWMsS0FBSyx1QkFBdUIsNkNBQTZDLE1BQU0sWUFBWSxJQUFJLEVBQUUsc0JBQXNCLFFBQVEsWUFBWSxNQUFNLElBQUksRUFBRSxjQUFjLE1BQU0sSUFBSSxFQUFFLEdBQUcsYUFBYSw2Q0FBNkMsMEZBQTBGLEtBQUssSUFBSSxLQUFLLEdBQUcsdUNBQXVDLE1BQU0sYUFBYSxjQUFjLEVBQUUsa0NBQWtDLFdBQVcsa0NBQWtDLCtCQUErQixTQUFTLGlCQUFpQixXQUFXLDJDQUEyQyxjQUFjLEtBQUssdUJBQXVCLGtEQUFrRCxNQUFNLFlBQVksSUFBSSxFQUFFLHNCQUFzQixRQUFRLFlBQVksTUFBTSxJQUFJLEVBQUUsY0FBYyxNQUFNLElBQUksRUFBRSxHQUFHLGFBQWEsMkNBQTJDLDBGQUEwRixLQUFLLElBQUksS0FBSyxHQUFHLHVDQUF1QyxNQUFNLGFBQWEsY0FBYyxFQUFFLHNDQUFzQyxXQUFXLGtDQUFrQywrQkFBK0IsU0FBUyxpQkFBaUIsV0FBVywyQ0FBMkMsY0FBYyxLQUFLLHVCQUF1Qix1REFBdUQsTUFBTSxZQUFZLElBQUksRUFBRSxzQkFBc0IsUUFBUSxZQUFZLE1BQU0sSUFBSSxFQUFFLGNBQWMsTUFBTSxJQUFJLEVBQUUsR0FBRyxhQUFhLDJDQUEyQywwRkFBMEYsS0FBSyxJQUFJLEtBQUssR0FBRyx1Q0FBdUMsTUFBTSxhQUFhLGNBQWMsRUFBRSwwQ0FBMEMsV0FBVyxrQ0FBa0MsK0JBQStCLFNBQVMsaUJBQWlCLFdBQVcsMkNBQTJDLGNBQWMsS0FBSyx1QkFBdUIsNERBQTRELE1BQU0sWUFBWSxJQUFJLEVBQUUsc0JBQXNCLFFBQVEsWUFBWSxNQUFNLElBQUksRUFBRSxjQUFjLE1BQU0sSUFBSSxFQUFFLEdBQUcsYUFBYSwwQ0FBMEMsd0ZBQXdGLEtBQUssSUFBSSxLQUFLLEdBQUcsc0NBQXNDLE1BQU0sYUFBYSxhQUFhLEVBQUUsNkNBQTZDLFVBQVUsaUNBQWlDLHFCQUFxQixXQUFXLG1CQUFtQix1RkFBdUYsbUNBQW1DLDBDQUEwQywrTUFBK00sT0FBTyx5SEFBeUgscUNBQXFDLDBDQUEwQyxpREFBaUQsc0VBQXNFLFNBQVMsMEpBQTBKLHNFQUFzRSwwQ0FBMEMsaURBQWlELHNFQUFzRSxTQUFTLDBNQUEwTSxxRkFBcUYscUNBQXFDLDRDQUE0QyxzRUFBc0UsU0FBUyw2QkFBNkIsc0RBQXNELG9HQUFvRyx1QkFBdUIsWUFBWSx1QkFBdUIsV0FBVyxLQUFLLDRCQUE0QixVQUFVLG9DQUFvQyw0REFBNEQsa0dBQWtHLG1HQUFtRyx1RUFBdUUsbUtBQW1LLEtBQUssd0NBQXdDLHFNQUFxTSxNQUFNLDhCQUE4Qix3Q0FBd0Msc0JBQXNCLFFBQVEsSUFBSSxlQUFlLFNBQVMsNENBQTRDLE9BQU8sZUFBZSwwQkFBMEIsRUFBRSwwREFBMEQsZ0JBQWdCLGdGQUFnRixvREFBb0QsWUFBWSxrQkFBa0Isa0JBQWtCLCtEQUErRCw2RkFBNkYsbUVBQW1FLElBQUksOERBQThELFVBQVUsd0JBQXdCLEVBQUUsSUFBSSxZQUFZLEdBQUcsMkJBQTJCLDJDQUEyQyxRQUFRLG1CQUFtQixRQUFRLFdBQVcsUUFBUSxtQkFBbUIsUUFBUSxVQUFVLG9CQUFvQixFQUFFLCtCQUErQixFQUFFLEdBQUcsRUFBRSxFQUFFLFlBQVksRUFBRSxTQUFTLFFBQVEsK0RBQStELDBDQUEwQyw0TEFBNEwsd0NBQXdDLDZCQUE2QixFQUFFLElBQUkscUNBQXFDLEVBQUUsYUFBYSxhQUFhLFlBQVksNkRBQTZELGlGQUFpRixNQUFNLDhCQUE4Qix3Q0FBd0Msc0JBQXNCLFFBQVEsSUFBSSxlQUFlLFNBQVMsMERBQTBELE9BQU8sZUFBZSwyQkFBMkIsRUFBRSxJQUFJLGNBQWMsR0FBRywyQkFBMkIsY0FBYyxFQUFFLHFCQUFxQixFQUFFLEdBQUcsRUFBRSxFQUFFLFdBQVcsVUFBVSwrREFBK0QsaUNBQWlDLCtCQUErQiwrQ0FBK0MsNkNBQTZDLDZDQUE2Qyw2Q0FBNkMsK0NBQStDLG1DQUFtQyx3QkFBd0IsaUJBQWlCLG1EQUFtRCwrQ0FBK0MsK0NBQStDLCtDQUErQywrQ0FBK0MsK0NBQStDLCtDQUErQyxpREFBaUQsU0FBUyxNQUFNLDRCQUE0Qiw0QkFBNEIsRUFBRSxJQUFJLHVCQUF1Qix3REFBd0QsR0FBRyxFQUFFLFVBQVUsYUFBYSxZQUFZLCtCQUErQiwwQkFBMEIsbUdBQW1HLEVBQUUsYUFBYSwyQ0FBMkMsS0FBSyxJQUFJLEtBQUssU0FBUyxpQkFBaUIsWUFBWSxHQUFHLEVBQUUsTUFBTSxPQUFPLEVBQUUsOERBQThELDBCQUEwQiwyR0FBMkcsMENBQTBDLGdCQUFnQixFQUFFLG9CQUFvQix1REFBdUQsRUFBRSxNQUFNLEVBQUUsSUFBSSxtQkFBbUIsWUFBWSxHQUFHLEVBQUUsTUFBTSxTQUFTLEVBQUUsK0JBQStCLHdDQUF3QyxFQUFFLG9CQUFvQixtQ0FBbUMsS0FBSyxJQUFJLEtBQUssSUFBSSxFQUFFLFlBQVksaUJBQWlCLFlBQVksR0FBRyxFQUFFLE1BQU0sT0FBTyxFQUFFLDhEQUE4RCwwQkFBMEIsMkdBQTJHLGFBQWEsOEdBQThHLGtCQUFrQixtREFBbUQsY0FBYyxlQUFlLEVBQUUsMkJBQTJCLG1CQUFtQixFQUFFLEdBQUcsNkJBQTZCLEVBQUUsVUFBVSxFQUFFLDhDQUE4QyxrREFBa0QsRUFBRSwyQkFBMkIsNkNBQTZDLEVBQUUsSUFBSSxFQUFFLElBQUksb0JBQW9CLElBQUksRUFBRSxlQUFlLGlCQUFpQixZQUFZLEdBQUcsRUFBRSxPQUFPLEVBQUUsOERBQThELDBCQUEwQiwwSkFBMEosaUVBQWlFLEdBQUcsZ0JBQWdCLEdBQUcsYUFBYSxZQUFZLE1BQU0sY0FBYyxFQUFFLHdCQUF3QixHQUFHLElBQUksR0FBRyxNQUFNLGdCQUFnQixFQUFFLEdBQUcsRUFBRSxHQUFHLHNCQUFzQixHQUFHLDZCQUE2QixHQUFHLG9DQUFvQyxHQUFHLHVEQUF1RCxFQUFFLElBQUksRUFBRSxFQUFFLGlCQUFpQixZQUFZLEdBQUcsRUFBRSxNQUFNLE9BQU8sRUFBRSwrQkFBK0IsZ0NBQWdDLDhCQUE4QixpQkFBaUIsNkJBQTZCLEVBQUUsSUFBSSxxQ0FBcUMsRUFBRSxVQUFVLGFBQWEsWUFBWSw2REFBNkQsMkJBQTJCLEVBQUUsSUFBSSx5QkFBeUIsR0FBRyw4QkFBOEIsRUFBRSxJQUFJLEVBQUUsRUFBRSxtQ0FBbUMsRUFBRSxJQUFJLEVBQUUsV0FBVyxFQUFFLEVBQUUsbUNBQW1DLEVBQUUsTUFBTSxXQUFXLFVBQVUsbUhBQW1ILDRCQUE0QiwyQkFBMkIsaUJBQWlCLDJCQUEyQixFQUFFLGFBQWEsbUNBQW1DLEVBQUUsVUFBVSxXQUFXLFVBQVUsNkRBQTZELFVBQVUsNkJBQTZCLEVBQUUsYUFBYSxzREFBc0QsRUFBRSxTQUFTLHFDQUFxQyxFQUFFLE1BQU0sYUFBYSxZQUFZLDZEQUE2RCxVQUFVLDZCQUE2QixFQUFFLGFBQWEsMkRBQTJELEVBQUUsSUFBSSxxQ0FBcUMsRUFBRSxNQUFNLGFBQWEsWUFBWSw2REFBNkQsMkJBQTJCLEVBQUUsYUFBYSxtQ0FBbUMsRUFBRSxJQUFJLEVBQUUsU0FBUyxtQ0FBbUMsRUFBRSxNQUFNLFdBQVcsVUFBVSxzRkFBc0YsNEJBQTRCLDZDQUE2QywwQ0FBMEMsNkJBQTZCLEVBQUUsb0JBQW9CLDJEQUEyRCxLQUFLLE1BQU0sS0FBSyxJQUFJLHFDQUFxQyxFQUFFLE1BQU0sYUFBYSxZQUFZLDZEQUE2RCxNQUFNLHNCQUFzQiwyQkFBMkIsc0JBQXNCLHFFQUFxRSxrQkFBa0IsdUNBQXVDLG9EQUFvRCxvQkFBb0IsRUFBRSxvQkFBb0IsdUJBQXVCLEVBQUUsR0FBRyw2QkFBNkIsRUFBRSxhQUFhLFlBQVksNkRBQTZELG9CQUFvQixVQUFVLDZCQUE2QixFQUFFLG9CQUFvQiwyQkFBMkIsR0FBRyw4QkFBOEIsRUFBRSxJQUFJLEVBQUUsRUFBRSx3REFBd0QsRUFBRSxVQUFVLEtBQUssU0FBUyxvREFBb0QsRUFBRSxJQUFJLHFDQUFxQyxFQUFFLE1BQU0sYUFBYSxZQUFZLDBGQUEwRixVQUFVLDZCQUE2QixFQUFFLG9CQUFvQiwyQkFBMkIsR0FBRyw4QkFBOEIsRUFBRSxJQUFJLEVBQUUsRUFBRSx3REFBd0QsRUFBRSxVQUFVLEtBQUssU0FBUywrQ0FBK0MsRUFBRSxTQUFTLHFDQUFxQyxFQUFFLE1BQU0sYUFBYSxZQUFZLDBGQUEwRiwyQkFBMkIsRUFBRSxvQkFBb0IsZ0NBQWdDLE1BQU0sTUFBTSxtQ0FBbUMsRUFBRSxJQUFJLEVBQUUsU0FBUyxtQ0FBbUMsRUFBRSxNQUFNLFdBQVcsVUFBVSxtSEFBbUgsNEJBQTRCLDRDQUE0QyxzQkFBc0IsMkJBQTJCLHNCQUFzQiw2RkFBNkYsa0JBQWtCLCtFQUErRSxjQUFjLG9CQUFvQixFQUFFLCtCQUErQix1QkFBdUIsRUFBRSxHQUFHLDZCQUE2QixFQUFFLGFBQWEsWUFBWSw4Q0FBOEMsNkJBQTZCLEVBQUUsK0JBQStCLHFIQUFxSCxHQUFHLFVBQVUsR0FBRyxNQUFNLHFDQUFxQyxRQUFRLElBQUksU0FBUyxTQUFTLHFDQUFxQyxFQUFFLE1BQU0sYUFBYSxVQUFVLG1IQUFtSCw0QkFBNEIsNkRBQTZELEVBQUUsMkNBQTJDLGdDQUFnQyxRQUFRLFVBQVUsR0FBRyw0QkFBNEIsR0FBRyxRQUFRLG1DQUFtQyxRQUFRLElBQUksU0FBUyxTQUFTLG1DQUFtQyxFQUFFLE1BQU0sV0FBVyxVQUFVLHNGQUFzRiw0QkFBNEIsMkRBQTJELHNCQUFzQix1QkFBdUIsc0JBQXNCLCtHQUErRyxrQkFBa0IsdUJBQXVCLG9EQUFvRCxvQkFBb0IsRUFBRSx1REFBdUQsdUJBQXVCLEVBQUUsR0FBRyw2QkFBNkIsRUFBRSxhQUFhLFlBQVksc0ZBQXNGLDJCQUEyQixFQUFFLHVEQUF1RCxnQ0FBZ0MsR0FBRyxVQUFVLEdBQUcsWUFBWSxHQUFHLHdCQUF3QixHQUFHLFNBQVMsbUNBQW1DLFFBQVEsSUFBSSxTQUFTLFNBQVMsbUNBQW1DLEVBQUUsTUFBTSxXQUFXLFVBQVUsc0ZBQXNGLDRCQUE0QixvRUFBb0Usc0JBQXNCLHVCQUF1QixzQkFBc0Isd0hBQXdILGtCQUFrQix5QkFBeUIsb0RBQW9ELHNCQUFzQixFQUFFLGtGQUFrRix5QkFBeUIsRUFBRSxHQUFHLDZCQUE2QixFQUFFLGVBQWUsY0FBYyxzRkFBc0YsNkJBQTZCLEVBQUUsZ0ZBQWdGLGtDQUFrQyxHQUFHLFVBQVUsR0FBRyxZQUFZLEdBQUcsMEJBQTBCLEdBQUcsYUFBYSxHQUFHLFNBQVMscUNBQXFDLFFBQVEsSUFBSSxTQUFTLFNBQVMscUNBQXFDLEVBQUUsTUFBTSxhQUFhLFlBQVksbUhBQW1ILFFBQVEsZ0dBQWdHLFlBQVksTUFBTSwwQkFBMEIsRUFBRSxlQUFlLE1BQU0sbUNBQW1DLEVBQUUsTUFBTSxNQUFNLEdBQUcsc0JBQXNCLElBQUksV0FBVyxHQUFHLHdEQUF3RCxFQUFFLElBQUksbURBQW1ELEVBQUUsSUFBSSxFQUFFLEVBQUUsWUFBWSxXQUFXLFNBQVMsMkNBQTJDLEVBQUUsSUFBSSxZQUFZLFdBQVcsU0FBUyxRQUFRLE9BQU8sOERBQThELFlBQVksV0FBVyw0REFBNEQsd0dBQXdHLFVBQVUsRUFBRSxFQUFFLHlHQUF5RyxFQUFFLDhLQUE4SyxFQUFFLDZEQUE2RCxLQUFLLDhCQUE4QixVQUFVLEVBQUUsRUFBRSx1Q0FBdUMsRUFBRSxTQUFTLEVBQUUsSUFBSSwwQ0FBMEMsRUFBRSxJQUFJLG1EQUFtRCxFQUFFLElBQUksRUFBRSxFQUFFLDRDQUE0Qyx3REFBd0QsR0FBRyxFQUFFLFdBQVcseUJBQXlCLFdBQVcsWUFBWSw4QkFBOEIsVUFBVSxFQUFFLE9BQU8sc0NBQXNDLEVBQUUsU0FBUyxFQUFFLElBQUksMkNBQTJDLEVBQUUsSUFBSSxtREFBbUQsRUFBRSxJQUFJLEVBQUUsRUFBRSxxQkFBcUIsd0RBQXdELEdBQUcsRUFBRSxVQUFVLFdBQVcsYUFBYSxrQkFBa0IsY0FBYyxhQUFhLE1BQU0sc0NBQXNDLFNBQVMseUpBQXlKLG1GQUFtRixxQkFBcUIsMkZBQTJGLGlCQUFpQixlQUFlLGdCQUFnQix3QkFBd0IsaUJBQWlCLHdDQUF3Qyw0QkFBNEIsbUJBQW1CLDREQUE0RCxpQkFBaUIsOEJBQThCLHFDQUFxQyw2QkFBNkIsNkJBQTZCLHlCQUF5QixzQ0FBc0MsMENBQTBDLG1DQUFtQyxZQUFZLFdBQVcsaUNBQWlDLDRCQUE0Qiw0QkFBNEIscUhBQXFILGNBQWMsdUJBQXVCLDZCQUE2QixXQUFXLGlDQUFpQywyQ0FBMkMsZ0JBQWdCLGFBQWEsc0NBQXNDLFNBQVMsMkJBQTJCLGdCQUFnQiwwQkFBMEIsZUFBZSxTQUFTLGVBQWUscUNBQXFDLDZDQUE2QyxpQkFBaUIsU0FBUyxnQkFBZ0IsT0FBTywrREFBK0Qsd0NBQXdDLFNBQVMsY0FBYyxnQkFBZ0IsT0FBTyxrRUFBa0Usd0JBQXdCLFNBQVMsY0FBYyxjQUFjLGdEQUFnRCxLQUFLLE9BQU8sdUVBQXVFLGlDQUFpQywwQ0FBMEMsZ0RBQWdELHdEQUF3RCxvRUFBb0UsMEJBQTBCLCtEQUErRCxpRkFBaUYsMEVBQTBFLGdFQUFnRSxZQUFZLEVBQUUsK0JBQStCLDhEQUE4RCxPQUFPLGNBQWMsY0FBYyxnREFBZ0QsS0FBSyxPQUFPLDRFQUE0RSxpQ0FBaUMsc0VBQXNFLEVBQUUsNkRBQTZELDBGQUEwRix5R0FBeUcsb0ZBQW9GLDBCQUEwQixTQUFTLGNBQWMsd0JBQXdCLG9FQUFvRSx1Q0FBdUMsdUJBQXVCLHVDQUF1QyxvQkFBb0IsZ0JBQWdCLGFBQWEsc0NBQXNDLFNBQVMsNEJBQTRCLDBCQUEwQiwwQkFBMEIsZUFBZSxTQUFTLGVBQWUscUNBQXFDLDhDQUE4QyxpQkFBaUIsU0FBUyxlQUFlLHNEQUFzRCxPQUFPLDZFQUE2RSxnQkFBZ0IsVUFBVSxnQkFBZ0IsV0FBVyxrQ0FBa0Msa0JBQWtCLE9BQU8sbUZBQW1GLG1DQUFtQyxXQUFXLG1DQUFtQyxxQkFBcUIsY0FBYyxhQUFhLHNDQUFzQyxTQUFTLDBCQUEwQix3RUFBd0UsS0FBSyxZQUFZLElBQUksNkJBQTZCLFdBQVcsTUFBTSxLQUFLLHFCQUFxQixFQUFFLGlDQUFpQyw0QkFBNEIsd0JBQXdCLG9CQUFvQixNQUFNLHlCQUF5QixTQUFTLG9CQUFvQixrQkFBa0IsbUVBQW1FLDZDQUE2QyxLQUFLLHFCQUFxQixFQUFFLDZDQUE2QyxHQUFHLEVBQUUsR0FBRyxLQUFLLHFCQUFxQiw2QkFBNkIsVUFBVSxRQUFRLEVBQUUsUUFBUSxJQUFJLE1BQU0sS0FBSyxRQUFRLEVBQUUsS0FBSyxFQUFFLDBCQUEwQixHQUFHLEtBQUssbUJBQW1CLEVBQUUsU0FBUyxZQUFZLEVBQUUsU0FBUyxVQUFVLHFCQUFxQix3QkFBd0IsZ0JBQWdCLGFBQWEsc0NBQXNDLFNBQVMsNEJBQTRCLDhDQUE4Qyx5QkFBeUIscUJBQXFCLFlBQVksc0NBQXNDLGtGQUFrRiw0Q0FBNEMsZUFBZSxHQUFHLDJDQUEyQywwQkFBMEIsb0NBQW9DLGtCQUFrQixnQkFBZ0IsTUFBTSxxR0FBcUcsMEJBQTBCLGlCQUFpQixXQUFXLHdDQUF3QyxLQUFLLHVDQUF1QyxnQ0FBZ0MsYUFBYSxpQ0FBaUMscUJBQXFCLCtDQUErQyxFQUFFLFVBQVUsNkdBQTZHLGdDQUFnQyw0REFBNEQsUUFBUSwyQ0FBMkMsUUFBUSxtQkFBbUIsUUFBUSxFQUFFLEVBQUUsY0FBYyxrREFBa0QseUJBQXlCLFNBQVMsWUFBWSxXQUFXLEtBQUssbUZBQW1GLFVBQVUsR0FBRyx5QkFBeUIsU0FBUyxxQ0FBcUMsV0FBVyxvRUFBb0Usd0JBQXdCLGlFQUFpRSx1REFBdUQsaUJBQWlCLFdBQVcsa0RBQWtELEdBQUcsR0FBRyx3Q0FBd0MsUUFBUSxFQUFFLE9BQU8sRUFBRSxrQkFBa0IsY0FBYyxPQUFPLEdBQUcsc0JBQXNCLGdCQUFnQixhQUFhLHNDQUFzQyxTQUFTLHdCQUF3Qix3REFBd0QsZ0JBQWdCLHFJQUFxSSxnQkFBZ0IsYUFBYSxzQ0FBc0MsU0FBUyw2QkFBNkIsZ0JBQWdCLDBCQUEwQixlQUFlLFNBQVMsZUFBZSwrRUFBK0Usc0hBQXNILGlCQUFpQixTQUFTLGFBQWEsMkRBQTJELDREQUE0RCwwREFBMEQsZ0JBQWdCLHlDQUF5QyxFQUFFLEVBQUUsU0FBUyxZQUFZLElBQUksa0NBQWtDLEVBQUUsb0NBQW9DLElBQUksTUFBTSxLQUFLLE1BQU0sY0FBYywwQkFBMEIsR0FBRyxzQkFBc0IsRUFBRSx5QkFBeUIsRUFBRSxJQUFJLGNBQWMsRUFBRSxXQUFXLFlBQVksOEJBQThCLEtBQUssbUJBQW1CLDJEQUEyRCw0REFBNEQsa0RBQWtELDhCQUE4QiwrQ0FBK0MsRUFBRSxFQUFFLFNBQVMsWUFBWSxNQUFNLGtDQUFrQyxFQUFFLG9DQUFvQyxJQUFJLE1BQU0sS0FBSyxNQUFNLGNBQWMsMEJBQTBCLEVBQUUsc0JBQXNCLEVBQUUseUJBQXlCLEVBQUUsSUFBSSxjQUFjLEVBQUUsMEJBQTBCLElBQUkscUJBQXFCLElBQUksRUFBRSwwQkFBMEIsSUFBSSxxQkFBcUIsSUFBSSxFQUFFLFdBQVcsWUFBWSw4QkFBOEIsS0FBSyxrQkFBa0IsV0FBVyw0REFBNEQsMkdBQTJHLHlCQUF5QixFQUFFLEVBQUUsNkVBQTZFLEVBQUUsOEVBQThFLEtBQUssa0NBQWtDLFNBQVMsY0FBYyxLQUFLLHNDQUFzQyxFQUFFLE1BQU0sTUFBTSxZQUFZLHFCQUFxQixFQUFFLGVBQWUsRUFBRSxJQUFJLHlCQUF5QixZQUFZLEVBQUUsd0JBQXdCLFNBQVMsVUFBVSxrQkFBa0IsV0FBVyw0REFBNEQsMkdBQTJHLHlCQUF5QixFQUFFLEVBQUUsK0VBQStFLEVBQUUsZ0ZBQWdGLEtBQUssb0NBQW9DLFdBQVcsWUFBWSxNQUFNLDhCQUE4QixFQUFFLGVBQWUsTUFBTSx5Q0FBeUMsRUFBRSxNQUFNLE1BQU0sR0FBRyxpQ0FBaUMsSUFBSSxXQUFXLG1CQUFtQixFQUFFLCtCQUErQixFQUFFLElBQUksWUFBWSxXQUFXLFNBQVMsVUFBVSxtQkFBbUIsV0FBVyw0REFBNEQsbUZBQW1GLEVBQUUsRUFBRSxTQUFTLFlBQVksSUFBSSwwQkFBMEIsRUFBRSxNQUFNLE1BQU0sRUFBRSwwQkFBMEIsRUFBRSw2QkFBNkIsRUFBRSxJQUFJLHdCQUF3QixFQUFFLEVBQUUsY0FBYyxHQUFHLDBCQUEwQixHQUFHLEtBQUssUUFBUSxNQUFNLG9DQUFvQyw4QkFBOEIseUNBQXlDLHNCQUFzQixlQUFlLDZCQUE2QixhQUFhLFdBQVcsWUFBWSw2QkFBNkIsTUFBTSxzQkFBc0IsY0FBYyxhQUFhLHNDQUFzQyxTQUFTLDhGQUE4RixTQUFTLGdKQUFnSixJQUFJLCtKQUErSixHQUFHLGNBQWMsaUJBQWlCLGdEQUFnRCxhQUFhLFNBQVMsVUFBVSw4QkFBOEIsVUFBVSxhQUFhLGNBQWMsVUFBVSxhQUFhLGtCQUFrQixZQUFZLGlCQUFpQixlQUFlLDhCQUE4Qiw4Q0FBOEMscUNBQXFDLFNBQVMsRUFBRSxxQ0FBcUMsYUFBYSxTQUFTLFVBQVUsNEJBQTRCLDBCQUEwQixnQ0FBZ0MsUUFBUSxlQUFlLGVBQWUsUUFBUSxvQkFBb0IseUNBQXlDLHNGQUFzRixjQUFjLGNBQWMsY0FBYyxjQUFjLGNBQWMsUUFBUSwyQkFBMkIsY0FBYyxjQUFjLGNBQWMsY0FBYyxjQUFjLGNBQWMsUUFBUSxnQ0FBZ0MsK0JBQStCLE9BQU8sVUFBVSwwQ0FBMEMsd0JBQXdCLG9CQUFvQixFQUFFLEVBQUUsZ0NBQWdDLDJDQUEyQyxRQUFRLGFBQWEsU0FBUyxLQUFLLE9BQU8sZ0JBQWdCLGFBQWEsc0NBQXNDLFNBQVMsc0JBQXNCLGdCQUFnQiwwQkFBMEIsZUFBZSxTQUFTLGlCQUFpQixTQUFTLGVBQWUsaUVBQWlFLGtGQUFrRixxQkFBcUIseURBQXlELG9DQUFvQyxNQUFNLGtCQUFrQixXQUFXLEVBQUUsS0FBSyxTQUFTLFlBQVksSUFBSSwyQkFBMkIsRUFBRSxJQUFJLE1BQU0sTUFBTSxFQUFFLEVBQUUsY0FBYywwQkFBMEIsRUFBRSxXQUFXLEVBQUUsa0JBQWtCLEVBQUUsSUFBSSxjQUFjLEVBQUUsV0FBVyxZQUFZLDZCQUE2QixTQUFTLFVBQVUsc0RBQXNELFNBQVMsWUFBWSxJQUFJLHlCQUF5QixFQUFFLFVBQVUsRUFBRSxFQUFFLFlBQVksd0NBQXdDLEVBQUUsa0JBQWtCLEVBQUUsSUFBSSxZQUFZLEVBQUUsU0FBUyxVQUFVLE9BQU8saUNBQWlDLGFBQWEsc0RBQXNELHFEQUFxRCxHQUFHLFFBQVEsb0RBQW9ELFlBQVksWUFBWSxNQUFNLHNDQUFzQyxFQUFFLG1CQUFtQixFQUFFLFVBQVUsZ0JBQWdCLG9DQUFvQyxJQUFJLFVBQVUsWUFBWSw2Q0FBNkMsRUFBRSwwQkFBMEIsWUFBWSxFQUFFLFNBQVMsWUFBWSxPQUFPLG9DQUFvQyxhQUFhLHNEQUFzRCxzREFBc0QsR0FBRyxRQUFRLG1EQUFtRCxVQUFVLFlBQVksTUFBTSxzQ0FBc0MsRUFBRSwwQkFBMEIsRUFBRSxFQUFFLFVBQVUsMkNBQTJDLElBQUksRUFBRSxZQUFZLHdDQUF3QyxFQUFFLGVBQWUsWUFBWSxFQUFFLFNBQVMsUUFBUSxPQUFPLHFDQUFxQyxlQUFlLGdCQUFnQixhQUFhLHNDQUFzQyxTQUFTLGlDQUFpQyxnR0FBZ0csOEJBQThCLGVBQWUseUZBQXlGLG9DQUFvQyw0RUFBNEUsb0JBQW9CLG1GQUFtRixvQkFBb0IsSUFBSSw0R0FBNEcsV0FBVyxZQUFZLHNCQUFzQiwyREFBMkQsaUJBQWlCLHFCQUFxQiwyQkFBMkIsRUFBRSxRQUFRLEdBQUcsU0FBUyxjQUFjLGFBQWEsd0RBQXdELE9BQU8saURBQWlELGdOQUFnTiw2SEFBNkgsU0FBUyx1Q0FBdUMsa0JBQWtCLFlBQVksV0FBVyxzR0FBc0csRUFBRSxpQ0FBaUMsa0lBQWtJLHVDQUF1Qyw0QkFBNEIsNkRBQTZELGdJQUFnSSxPQUFPLHVGQUF1RiwwQ0FBMEMsdUJBQXVCLGlCQUFpQix1SEFBdUgsbUJBQW1CLHdCQUF3QixtREFBbUQsd0JBQXdCLFlBQVksSUFBSSxLQUFLLHdCQUF3Qix1Q0FBdUMsK0NBQStDLDZCQUE2QixvRkFBb0YsYUFBYSxzREFBc0QsZUFBZSx5REFBeUQsU0FBUywrQ0FBK0MseUNBQXlDLDZCQUE2QixxRUFBcUUsa0JBQWtCLElBQUkscUVBQXFFLGtEQUFrRCxxQkFBcUIsaUVBQWlFLGtJQUFrSSxvRUFBb0UsbUJBQW1CLDREQUE0RCxtQ0FBbUMsU0FBUyw4SUFBOEksb0VBQW9FLDhKQUE4SiwrQkFBK0IsVUFBVSw4REFBOEQsK0RBQStELHdDQUF3QyxzQ0FBc0MsS0FBSywwSEFBMEgsRUFBRSwyREFBMkQsdUJBQXVCLGdKQUFnSix5QkFBeUIsd0lBQXdJLDhCQUE4Qix3Q0FBd0MsVUFBVSw4U0FBOFMsZUFBZSxrUUFBa1EsMEJBQTBCLDRRQUE0USxRQUFRLHdGQUF3RixVQUFVLDRGQUE0RixzQkFBc0IsYUFBYSxtRUFBbUUsa0JBQWtCLDJDQUEyQyw4REFBOEQsNkJBQTZCLGFBQWEsK0JBQStCLG1CQUFtQiw0QkFBNEIsZ0VBQWdFLG1DQUFtQyxzQkFBc0IsRUFBRSxlQUFlLFlBQVkseUNBQXlDLDRCQUE0QixTQUFTLDZGQUE2RixpQkFBaUIsc0NBQXNDLFNBQVMsa0NBQWtDLDZTQUE2UyxxMkdBQXEyRyxnQkFBZ0IsYUFBYSxzQ0FBc0MsU0FBUyxrRUFBa0Usc0NBQXNDLDBNQUEwTSx5RUFBeUUsS0FBSyxzQ0FBc0MsK0NBQStDLHdIQUF3SCx5Q0FBeUMsK0JBQStCLEdBQUcsa0JBQWtCLGtMQUFrTCxFQUFFLFlBQVksbURBQW1ELEVBQUUsSUFBSSxFQUFFLEVBQUUsc0NBQXNDLFlBQVksbUJBQW1CLHFDQUFxQyxZQUFZLGtCQUFrQix5Q0FBeUMsWUFBWSxzQkFBc0Isa0NBQWtDLFlBQVksZUFBZSx3RUFBd0UsVUFBVSxTQUFTLEtBQUssRUFBRSxxQ0FBcUMsS0FBSyxRQUFRLGlFQUFpRSxnQkFBZ0IsRUFBRSxPQUFPLDZFQUE2RSx5Q0FBeUMsdUlBQXVJLHNJQUFzSSwwUEFBMFAsZ0JBQWdCLGFBQWEsc0NBQXNDLFNBQVMseU5BQXlOLDhDQUE4QyxhQUFhLGVBQWUsT0FBTyxrQkFBa0IsRUFBRSxvQkFBb0IsbUJBQW1CLEtBQUssV0FBVyxFQUFFLG9CQUFvQixxQkFBcUIsS0FBSyw2Q0FBNkMsYUFBYSxlQUFlLE9BQU8sa0JBQWtCLEVBQUUsb0JBQW9CLG1CQUFtQixLQUFLLFdBQVcsRUFBRSxvQkFBb0IscUJBQXFCLEtBQUssNkNBQTZDLGFBQWEsZUFBZSxPQUFPLGtCQUFrQixFQUFFLG9CQUFvQixtQkFBbUIsS0FBSyxXQUFXLEVBQUUsb0JBQW9CLHFCQUFxQixLQUFLLDZDQUE2QyxhQUFhLGVBQWUsT0FBTyxrQkFBa0IsRUFBRSxvQkFBb0IsbUJBQW1CLEtBQUssV0FBVyxFQUFFLG9CQUFvQixxQkFBcUIsS0FBSyw2Q0FBNkMsYUFBYSxpQkFBaUIsT0FBTyxrQkFBa0IsRUFBRSxvQkFBb0IsMkJBQTJCLEtBQUssV0FBVyxFQUFFLG9CQUFvQixpQ0FBaUMsS0FBSyw2Q0FBNkMsYUFBYSxtQkFBbUIsT0FBTyxrQkFBa0IsRUFBRSxvQkFBb0IsMEJBQTBCLEtBQUssV0FBVyxFQUFFLG9CQUFvQiw4RkFBOEYsS0FBSyw2Q0FBNkMsYUFBYSxnQkFBZ0IsT0FBTyxrQkFBa0IsRUFBRSxvQkFBb0IsMEJBQTBCLEtBQUssV0FBVyxFQUFFLG9CQUFvQiw0SEFBNEgsS0FBSyw2Q0FBNkMsYUFBYSxlQUFlLE9BQU8sa0JBQWtCLEVBQUUsb0JBQW9CLHlDQUF5QyxLQUFLLFdBQVcsRUFBRSxvQkFBb0IsMkJBQTJCLDJCQUEyQixnSUFBZ0ksS0FBSyw2Q0FBNkMsYUFBYSxjQUFjLE9BQU8sa0JBQWtCLEVBQUUsb0JBQW9CLHlDQUF5QyxLQUFLLFdBQVcsRUFBRSxvQkFBb0IsMkJBQTJCLDJCQUEyQixnSUFBZ0ksS0FBSyw2Q0FBNkMsYUFBYSxlQUFlLE9BQU8sa0JBQWtCLEVBQUUsb0JBQW9CLHlDQUF5QyxLQUFLLFdBQVcsRUFBRSxvQkFBb0IsMkJBQTJCLDJCQUEyQixnSUFBZ0ksS0FBSyw2Q0FBNkMsYUFBYSxtQkFBbUIsV0FBVyxFQUFFLEdBQUcsT0FBTyxrQkFBa0IsRUFBRSxvQkFBb0IsZUFBZSxFQUFFLE9BQU8sS0FBSyxXQUFXLEVBQUUsb0JBQW9CLGVBQWUsRUFBRSxTQUFTLEtBQUssNkNBQTZDLFFBQVEsYUFBYSxpQkFBaUIsT0FBTyxrQkFBa0IsRUFBRSxvQkFBb0IsZ0NBQWdDLEtBQUssV0FBVyxFQUFFLG9CQUFvQix1TEFBdUwsS0FBSyw2Q0FBNkMsd0pBQXdKLGdDQUFnQyxtRUFBbUUsT0FBTyxrRkFBa0YseUJBQXlCLGdIQUFnSCxnQkFBZ0IsdUJBQXVCLE1BQU0sMERBQTBELHNFQUFzRSxJQUFJLCtKQUErSixtQkFBbUIsNERBQTRELG1CQUFtQixzRUFBc0UsT0FBTyxxQkFBcUIscUNBQXFDLHFDQUFxQywwQkFBMEIsT0FBTyxPQUFPLFlBQVksVUFBVSxTQUFTLFNBQVMsYUFBYSxPQUFPLG9DQUFvQyxFQUFFLElBQUkseUJBQXlCLEVBQUUsRUFBRSx5QkFBeUIsRUFBRSxFQUFFLFlBQVksRUFBRSxZQUFZLEVBQUUsbUJBQW1CLE9BQU8sNkJBQTZCLFNBQVMsRUFBRSxPQUFPLDBEQUEwRCw0QkFBNEIsMkJBQTJCLHNFQUFzRSxPQUFPLG1CQUFtQixvQkFBb0IsWUFBWSxlQUFlLG9CQUFvQixZQUFZLGVBQWUsd0JBQXdCLE9BQU8sU0FBUyxVQUFVLFVBQVUsU0FBUyxPQUFPLFFBQVEsT0FBTywwREFBMEQsb0NBQW9DLDZCQUE2QixzZEFBc2QsZ0JBQWdCLGFBQWEsc0NBQXNDLFNBQVMsc0NBQXNDLGdCQUFnQixnSUFBZ0ksWUFBWSw4REFBOEQsZ0VBQWdFLGdCQUFnQixhQUFhLHNDQUFzQyxTQUFTLCtDQUErQyw4Q0FBOEMsZ0RBQWdELGtDQUFrQyw4Q0FBOEMsU0FBUyxhQUFhLEVBQUUsK0RBQStELEVBQUUsUUFBUSxxQ0FBcUMsS0FBSyxxQkFBcUIsMEJBQTBCLDhHQUE4RyxvQkFBb0IsbUJBQW1CLFlBQVksV0FBVyxLQUFLLDBCQUEwQixZQUFZLFdBQVcsd0JBQXdCLHdFQUF3RSxnTEFBZ0wsYUFBYSxZQUFZLFdBQVcsd0JBQXdCLHNDQUFzQyxhQUFhLEdBQUcsSUFBSSxLQUFLLEdBQUcsa0RBQWtELEVBQUUsVUFBVSxTQUFTLEdBQUcsV0FBVyxFQUFFLFlBQVksV0FBVyxLQUFLLGVBQWUsd0JBQXdCLEdBQUcsSUFBSSxPQUFPLEtBQUssR0FBRyxLQUFLLE9BQU8sR0FBRywwREFBMEQsRUFBRSxHQUFHLFNBQVMsMkJBQTJCLFNBQVMsR0FBRyxlQUFlLEVBQUUsaUNBQWlDLDBEQUEwRCxFQUFFLEdBQUcsU0FBUyx5QkFBeUIsU0FBUyxHQUFHLEVBQUUsNEVBQTRFLEVBQUUsNkJBQTZCLHFCQUFxQixHQUFHLGdCQUFnQixFQUFFLGFBQWEsMkJBQTJCLGdCQUFnQixHQUFHLDJCQUEyQixxQ0FBcUMsUUFBUSx1QkFBdUIsUUFBUSxXQUFXLFFBQVEsdUJBQXVCLFFBQVEsVUFBVSw4Q0FBOEMsRUFBRSxlQUFlLGtCQUFrQixRQUFRLElBQUksUUFBUSxJQUFJLG9CQUFvQixRQUFRLElBQUksT0FBTyxHQUFHLHNDQUFzQyxFQUFFLEVBQUUsZUFBZSxrQkFBa0IsUUFBUSxJQUFJLFFBQVEsSUFBSSxvQkFBb0IsUUFBUSxJQUFJLE9BQU8sR0FBRyxzQ0FBc0MsRUFBRSxFQUFFLGVBQWUsa0JBQWtCLFFBQVEsSUFBSSxRQUFRLElBQUksb0JBQW9CLFFBQVEsSUFBSSxRQUFRLHNCQUFzQixRQUFRLElBQUksT0FBTyxHQUFHLHNDQUFzQyxFQUFFLEVBQUUsZUFBZSxnQkFBZ0IsVUFBVSxTQUFTLGFBQWEsWUFBWSxxQ0FBcUMsS0FBSyxRQUFRLHVEQUF1RCwyQkFBMkIsRUFBRSxnQkFBZ0IsR0FBRyxrQkFBa0IscUJBQXFCLDhCQUE4QixHQUFHLElBQUksRUFBRSxjQUFjLGdCQUFnQixhQUFhLHNDQUFzQyxTQUFTLDBDQUEwQyxtQ0FBbUMsNElBQTRJLGtCQUFrQixrQ0FBa0MscUNBQXFDLFNBQVMsYUFBYSxFQUFFLGlFQUFpRSxFQUFFLFFBQVEscUNBQXFDLEtBQUsscUJBQXFCLDBCQUEwQiw4R0FBOEcsb0JBQW9CLG1CQUFtQixZQUFZLFdBQVcsS0FBSywwQkFBMEIsWUFBWSxXQUFXLHdCQUF3Qix3RUFBd0UsdUNBQXVDLFFBQVEsWUFBWSxXQUFXLDJCQUEyQixTQUFTLHVCQUF1QixxQkFBcUIsY0FBYyxZQUFZLEtBQUssWUFBWSxFQUFFLHNDQUFzQyxFQUFFLElBQUkscUVBQXFFLEVBQUUsR0FBRyxxQ0FBcUMsd0JBQXdCLEVBQUUsY0FBYyxFQUFFLGdFQUFnRSxhQUFhLHdFQUF3RSxXQUFXLEVBQUUscUNBQXFDLEtBQUssUUFBUSx5REFBeUQsZ0JBQWdCLEVBQUUsZ0JBQWdCLEVBQUUsa0RBQWtELFVBQVUsMEJBQTBCLEVBQUUsR0FBRyxTQUFTLElBQUksZUFBZSxPQUFPLHNCQUFzQiw0RUFBNEUsRUFBRSxJQUFJLEdBQUcsWUFBWSxJQUFJLDBDQUEwQyxFQUFFLElBQUksV0FBVyxFQUFFLFlBQVksNEJBQTRCLFdBQVcsRUFBRSxZQUFZLHdDQUF3QyxFQUFFLElBQUksV0FBVyxFQUFFLFlBQVksR0FBRyxrQkFBa0IsZ0JBQWdCLE9BQU8sNERBQTRELEdBQUcsWUFBWSxXQUFXLG1DQUFtQyxFQUFFLElBQUksU0FBUyxRQUFRLG1DQUFtQyxTQUFTLFFBQVEsaUNBQWlDLEVBQUUsSUFBSSxTQUFTLFFBQVEsR0FBRyxrQkFBa0IsaUJBQWlCLDhEQUE4RCxpQ0FBaUMsRUFBRSxZQUFZLG9EQUFvRCxxQ0FBcUMsc0VBQXNFLGtCQUFrQixrRUFBa0UsbUZBQW1GLGdCQUFnQixhQUFhLHNDQUFzQyxTQUFTLHNEQUFzRCx3REFBd0QsdURBQXVELG9DQUFvQywyTUFBMk0sRUFBRSxRQUFRLHFDQUFxQyxLQUFLLHFCQUFxQixxREFBcUQsNERBQTRELDBDQUEwQyxVQUFVLGNBQWMsWUFBWSxVQUFVLFFBQVEsZ0JBQWdCLGNBQWMsU0FBUyxPQUFPLFlBQVksVUFBVSxHQUFHLDJIQUEySCx1Q0FBdUMsb0VBQW9FLGFBQWEsSUFBSSxhQUFhLEVBQUUsK0JBQStCLFVBQVUsSUFBSSxVQUFVLEVBQUUsTUFBTSxFQUFFLGlCQUFpQix1Q0FBdUMsMkJBQTJCLG9DQUFvQyxtREFBbUQsd0NBQXdDLEdBQUcsMEJBQTBCLCtCQUErQixlQUFlLE9BQU8sZUFBZSx5Q0FBeUMsTUFBTSxhQUFhLDhCQUE4QixZQUFZLE9BQU8sWUFBWSxrREFBa0QsZ0JBQWdCLDRDQUE0QyxLQUFLLEdBQUcscUJBQXFCLFdBQVcsaUNBQWlDLFdBQVcsT0FBTyxXQUFXLGtEQUFrRCxnQkFBZ0IsMENBQTBDLEtBQUssR0FBRyx1QkFBdUIsYUFBYSx1RUFBdUUsMkVBQTJFLCtCQUErQixXQUFXLFNBQVMsT0FBTyxRQUFRLEVBQUUsUUFBUSxFQUFFLFFBQVEsVUFBVSwwQkFBMEIsS0FBSyxJQUFJLHFDQUFxQyxLQUFLLFFBQVEseURBQXlELDJCQUEyQixFQUFFLFdBQVcsR0FBRyxnQkFBZ0IsYUFBYSxzQ0FBc0MsU0FBUyxnREFBZ0QsbUNBQW1DLGtDQUFrQyxvUUFBb1EsNEJBQTRCLDBCQUEwQixrVEFBa1QsNkJBQTZCLGdCQUFnQixhQUFhLHNDQUFzQyxTQUFTLHdEQUF3RCxvR0FBb0csd0JBQXdCLHdFQUF3RSwyQ0FBMkMsa0JBQWtCLGVBQWUsaUJBQWlCLDZCQUE2QixvQ0FBb0MsME1BQTBNLEVBQUUsUUFBUSxxQ0FBcUMsS0FBSyxxQkFBcUIsMk1BQTJNLHVDQUF1QyxvRUFBb0UsYUFBYSxJQUFJLGFBQWEsRUFBRSwrQkFBK0IsVUFBVSxJQUFJLFVBQVUsRUFBRSxNQUFNLEVBQUUsaUJBQWlCLHVDQUF1QywyQkFBMkIsb0NBQW9DLHFDQUFxQywwQ0FBMEMsR0FBRyxzREFBc0QsR0FBRyx3QkFBd0IsR0FBRyxvQ0FBb0Msb0JBQW9CLElBQUksb0JBQW9CLHlDQUF5QyxHQUFHLGtCQUFrQiw0QkFBNEIsVUFBVSxPQUFPLFVBQVUsOEJBQThCLFVBQVUsT0FBTyxVQUFVLHlDQUF5QyxlQUFlLFlBQVksZUFBZSxFQUFFLG9DQUFvQywwQ0FBMEMscUdBQXFHLE1BQU0sOENBQThDLEtBQUssZUFBZSwwRUFBMEUsMEVBQTBFLG1DQUFtQyxhQUFhLFdBQVcsU0FBUyxPQUFPLFFBQVEsRUFBRSxRQUFRLFVBQVUsMEJBQTBCLEtBQUssSUFBSSxxQ0FBcUMsS0FBSyxRQUFRLHlEQUF5RCwyQkFBMkIsRUFBRSxXQUFXLEVBQUUsc0JBQXNCLDhCQUE4Qix3Q0FBd0MsbUJBQW1CLHlCQUF5QiwrQ0FBK0MscUJBQXFCLGtDQUFrQyxZQUFZLElBQUksS0FBSyw2REFBNkQsNEVBQTRFLG1FQUFtRSx3QkFBd0IsSUFBSSx3QkFBd0IsdURBQXVELEtBQUssbUNBQW1DLHVUQUF1VCx1REFBdUQsMkZBQTJGLE1BQU0sZ0JBQWdCLGlGQUFpRiwyR0FBMkcsb0dBQW9HLDZCQUE2QiwwRkFBMEYsMkJBQTJCLGlFQUFpRSxFQUFFLElBQUksNkRBQTZELEVBQUUsSUFBSSx5REFBeUQsSUFBSSxJQUFJLDBFQUEwRSxFQUFFLElBQUksK0dBQStHLCtHQUErRyxtSEFBbUgsNEdBQTRHLGdCQUFnQixhQUFhLHNDQUFzQyxTQUFTLDZEQUE2RCxxRkFBcUYscUNBQXFDLHFLQUFxSyx5QkFBeUIsbUNBQW1DLGtCQUFrQiw2RUFBNkUseUxBQXlMLGFBQWEsZ1FBQWdRLDhCQUE4QixhQUFhLHdNQUF3TSxpRUFBaUUsV0FBVyw4QkFBOEIsd0NBQXdDLG1CQUFtQix5QkFBeUIsdUJBQXVCLHVGQUF1Rix3QkFBd0IsSUFBSSx3QkFBd0IseUNBQXlDLEtBQUssMEJBQTBCLG9QQUFvUCx1REFBdUQsNkRBQTZELE1BQU0sZ0JBQWdCLGlGQUFpRiwyR0FBMkcsNEdBQTRHLHFHQUFxRywyQkFBMkIsaUVBQWlFLEVBQUUsSUFBSSw2REFBNkQsRUFBRSxJQUFJLHlEQUF5RCxJQUFJLElBQUksK0dBQStHLDBHQUEwRyxtR0FBbUcsZ0JBQWdCLGFBQWEsc0NBQXNDLFNBQVMsc0RBQXNELGdCQUFnQix5QkFBeUIsS0FBSywrT0FBK08sbUJBQW1CLEVBQUUsRUFBRSw0RkFBNEYsK0JBQStCLG1DQUFtQyx5Q0FBeUMsNERBQTRELEdBQUcsbUJBQW1CLDZDQUE2Qyw4REFBOEQsR0FBRyxtQkFBbUIsT0FBTyxxQkFBcUIsWUFBWSx5RUFBeUUsU0FBUyxHQUFHLHdIQUF3SCxnQkFBZ0IsYUFBYSxzQ0FBc0MsU0FBUyw2Q0FBNkMsd0RBQXdELGdEQUFnRCxrQkFBa0IsNlBBQTZQLGlCQUFpQixxQ0FBcUMsS0FBSyx1QkFBdUIsbVdBQW1XLHVDQUF1QywyRkFBMkYsRUFBRSw4QkFBOEIsRUFBRSxJQUFJLGFBQWEsc0JBQXNCLGtCQUFrQiwyQkFBMkIsMkJBQTJCLDJCQUEyQixxQ0FBcUMsTUFBTSxnQkFBZ0IsTUFBTSxnQkFBZ0IsTUFBTSxzQ0FBc0MsTUFBTSxvQkFBb0IsR0FBRyxvQkFBb0IsTUFBTSxJQUFJLE1BQU0seURBQXlELEVBQUUsSUFBSSxFQUFFLEVBQUUseURBQXlELEVBQUUsSUFBSSxFQUFFLEVBQUUscUJBQXFCLFlBQVksMEJBQTBCLFlBQVksbUJBQW1CLHFCQUFxQixxQkFBcUIsS0FBSyxNQUFNLEVBQUUsaUJBQWlCLEdBQUcsRUFBRSxxQ0FBcUMsS0FBSyxRQUFRLHlEQUF5RCxnQkFBZ0IsRUFBRSxhQUFhLEdBQUcsZ0JBQWdCLGFBQWEsc0NBQXNDLFNBQVMsNENBQTRDLGdCQUFnQixvQkFBb0IsT0FBTyw4Q0FBOEMsa0NBQWtDLDJEQUEyRCxnQkFBZ0IsaUVBQWlFLHlCQUF5Qiw0REFBNEQsNkNBQTZDLDRFQUE0RSxnQkFBZ0IsYUFBYSxzQ0FBc0MsU0FBUyxvRUFBb0UsMEJBQTBCLG1DQUFtQyxNQUFNLHFCQUFxQiw4QkFBOEIsTUFBTSxvQ0FBb0MsTUFBTSxpREFBaUQsTUFBTSxlQUFlLDBDQUEwQyxlQUFlLE9BQU8scURBQXFELEVBQUUsU0FBUyxHQUFHLHlDQUF5QyxxQ0FBcUMsZUFBZSxvRUFBb0UsT0FBTyx1REFBdUQsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsT0FBTyxvQ0FBb0MsZ0JBQWdCLGFBQWEsc0NBQXNDLFNBQVMsMENBQTBDLDRDQUE0QyxrSEFBa0gsbUNBQW1DLEVBQUUsU0FBUyw4RkFBOEYsYUFBYSxzQ0FBc0MsS0FBSyxxQkFBcUIsRUFBRSxxQ0FBcUMsS0FBSyxxQkFBcUIsK0VBQStFLHdDQUF3QyxXQUFXLFlBQVksV0FBVyxzQ0FBc0MsRUFBRSxnQkFBZ0IsRUFBRSxFQUFFLHFEQUFxRCxJQUFJLGdCQUFnQixFQUFFLEVBQUUsNkNBQTZDLGFBQWEsZ0JBQWdCLEVBQUUsRUFBRSxJQUFJLCtDQUErQyxZQUFZLElBQUkseUJBQXlCLFNBQVMsRUFBRSw2QkFBNkIsWUFBWSxFQUFFLDhCQUE4QixZQUFZLHFCQUFxQiwwQ0FBMEMscUJBQXFCLEVBQUUsc0JBQXNCLE1BQU0sTUFBTSw4QkFBOEIsU0FBUyxFQUFFLHFDQUFxQyxLQUFLLFFBQVEseURBQXlELGdCQUFnQixFQUFFLGdCQUFnQixFQUFFLFdBQVcsaUVBQWlFLHlCQUF5QiwrQ0FBK0MsZ0RBQWdELGdGQUFnRixtRkFBbUYsZ0JBQWdCLGFBQWEsc0NBQXNDLFNBQVMsaUVBQWlFLG1DQUFtQywyQ0FBMkMsZ0JBQWdCLHVKQUF1Six5Q0FBeUMsK0NBQStDLEdBQUcsdUVBQXVFLGdCQUFnQixTQUFTLDJOQUEyTixxQ0FBcUMsS0FBSyxpQkFBaUIsRUFBRSxhQUFhLGlKQUFpSiw2REFBNkQseUJBQXlCLG9FQUFvRSxrREFBa0Qsa0RBQWtELGlEQUFpRCxHQUFHLHdEQUF3RCxFQUFFLElBQUksb0JBQW9CLEVBQUUsRUFBRSxvQkFBb0IsRUFBRSxFQUFFLGNBQWMsc0JBQXNCLGlCQUFpQixFQUFFLEtBQUssa0NBQWtDLGdDQUFnQyxjQUFjLHlDQUF5QyxLQUFLLGdDQUFnQywwQkFBMEIsSUFBSSxJQUFJLE1BQU0sb0JBQW9CLElBQUksTUFBTSxvQkFBb0IsSUFBSSxNQUFNLGtCQUFrQixFQUFFLGFBQWEsb0NBQW9DLGNBQWMsb0NBQW9DLEtBQUsseUJBQXlCLFNBQVMsRUFBRSxxQ0FBcUMsS0FBSyxRQUFRLHlEQUF5RCxhQUFhLHVDQUF1QyxFQUFFLHFDQUFxQyxpQkFBaUIsRUFBRSxXQUFXLDBDQUEwQyxrRkFBa0YsMEVBQTBFLHdHQUF3RyxpTUFBaU0sNkdBQTZHLGdCQUFnQixhQUFhLHNDQUFzQyxTQUFTLCtDQUErQyxvQ0FBb0Msb0RBQW9ELHVCQUF1QixzRkFBc0YsRUFBRSxNQUFNLHFDQUFxQyxLQUFLLHlCQUF5Qiw2SkFBNkosU0FBUyxZQUFZLEtBQUssZ0JBQWdCLEtBQUssNENBQTRDLEdBQUcsNkJBQTZCLEdBQUcsa0NBQWtDLE1BQU0sV0FBVyxLQUFLLEdBQUcsOENBQThDLE9BQU8sT0FBTyxjQUFjLHFCQUFxQixXQUFXLGlDQUFpQyxnQkFBZ0IsZUFBZSxFQUFFLE1BQU0sS0FBSyxFQUFFLDRCQUE0QixNQUFNLGFBQWEsK0NBQStDLE9BQU8sTUFBTSxjQUFjLHVCQUF1QixXQUFXLG1DQUFtQyxnQkFBZ0IsbUJBQW1CLEVBQUUsS0FBSyxLQUFLLEVBQUUsOEJBQThCLE1BQU0sYUFBYSw2Q0FBNkMsRUFBRSxHQUFHLCtDQUErQywrQkFBK0IsTUFBTSwwSEFBMEgsbUJBQW1CLGlCQUFpQixlQUFlLGdCQUFnQixtQkFBbUIsRUFBRSx1QkFBdUIsdUNBQXVDLG9DQUFvQyw4REFBOEQsMkJBQTJCLGNBQWMsRUFBRSxjQUFjLFVBQVUsU0FBUyxTQUFTLGdCQUFnQixxQ0FBcUMsS0FBSyxRQUFRLG9EQUFvRCwyQkFBMkIsRUFBRSxlQUFlLEdBQUcsZ0JBQWdCLGFBQWEsc0NBQXNDLFNBQVMsK0RBQStELGdCQUFnQiw4Q0FBOEMsdUJBQXVCLCtFQUErRSxFQUFFLE1BQU0scUNBQXFDLEtBQUsseUJBQXlCLHNHQUFzRyxNQUFNLDJCQUEyQixNQUFNLDJCQUEyQixNQUFNLDJCQUEyQixrQkFBa0IsMkJBQTJCLGtCQUFrQixrQ0FBa0MsZ0JBQWdCLGtDQUFrQyxnQkFBZ0IsZ0NBQWdDLGNBQWMsZ0NBQWdDLGNBQWMsNkJBQTZCLFdBQVcsNkJBQTZCLFdBQVcsaUNBQWlDLHVDQUF1Qyx1Q0FBdUMscUNBQXFDLEVBQUUsSUFBSSxpQ0FBaUMsK0RBQStELGlFQUFpRSwrREFBK0QsMENBQTBDLHlCQUF5QixvQkFBb0IsTUFBTSw4QkFBOEIsc0NBQXNDLG9EQUFvRCw2REFBNkQsa0RBQWtELGtEQUFrRCx3QkFBd0IsU0FBUyxFQUFFLHlCQUF5Qiw4QkFBOEIsMkJBQTJCLDJCQUEyQiwySEFBMkgsbUNBQW1DLGlCQUFpQixlQUFlLGtCQUFrQixhQUFhLHlCQUF5QixXQUFXLFlBQVkscUNBQXFDLEtBQUssUUFBUSxpRUFBaUUsZ0JBQWdCLEVBQUUsZUFBZSxFQUFFLGlGQUFpRixnQkFBZ0IsYUFBYSxzQ0FBc0MsU0FBUyxvREFBb0QseUJBQXlCLG1GQUFtRix3RUFBd0UseUNBQXlDLGVBQWUsR0FBRyxTQUFTLHdFQUF3RSxhQUFhLHNDQUFzQyxLQUFLLHFCQUFxQixFQUFFLHFDQUFxQyxLQUFLLHFCQUFxQixrREFBa0QsaUJBQWlCLG9DQUFvQyxFQUFFLElBQUksaUVBQWlFLFNBQVMsRUFBRSxxQ0FBcUMsS0FBSyxRQUFRLHlEQUF5RCxhQUFhLCtEQUErRCxFQUFFLHVDQUF1QyxpQkFBaUIsRUFBRSxXQUFXLEVBQUUsT0FBTyxxQ0FBcUMsRUFBRSxpQkFBaUIsR0FBRyxZQUFZLElBQUkscUNBQXFDLEVBQUUsSUFBSSxjQUFjLEVBQUUsSUFBSSw0QkFBNEIsY0FBYyxFQUFFLElBQUksbUNBQW1DLEVBQUUsSUFBSSxjQUFjLEVBQUUsSUFBSSxHQUFHLGtCQUFrQixnQkFBZ0IsT0FBTyxxRUFBcUUsZ0VBQWdFLHdGQUF3RixnQkFBZ0IsYUFBYSxzQ0FBc0MsU0FBUyx3RUFBd0UsMEJBQTBCLGtDQUFrQyxLQUFLLHlCQUF5QixxREFBcUQsaUZBQWlGLFNBQVMsa0dBQWtHLG9DQUFvQyxLQUFLLGlCQUFpQiw4RkFBOEYsNkJBQTZCLG1CQUFtQiw0QkFBNEIsNEJBQTRCLDJCQUEyQix3QkFBd0IsS0FBSyxPQUFPLE9BQU8sc0JBQXNCLDBCQUEwQixLQUFLLE9BQU8sT0FBTyx3QkFBd0IsOEJBQThCLHdCQUF3QixhQUFhLFdBQVcsc0NBQXNDLEVBQUUsRUFBRSxxQkFBcUIsd0JBQXdCLEtBQUssT0FBTyxPQUFPLHNCQUFzQiwwQkFBMEIsS0FBSyxPQUFPLE9BQU8sd0JBQXdCLDhCQUE4Qiw4Q0FBOEMsYUFBYSxXQUFXLHFCQUFxQiwrQkFBK0IsRUFBRSxFQUFFLHFCQUFxQixTQUFTLEVBQUUscUNBQXFDLEtBQUssUUFBUSxpRUFBaUUsZ0JBQWdCLEVBQUUsT0FBTyxLQUFLLDhNQUE4TSxlQUFlLHNDQUFzQyxLQUFLLGFBQWEsRUFBRSxFQUFFLEVBQUUscUNBQXFDLEtBQUssdUJBQXVCLHFNQUFxTSwyREFBMkQsaURBQWlELEVBQUUsSUFBSSxFQUFFLEVBQUUsbUJBQW1CLFlBQVksMEJBQTBCLFNBQVMseUNBQXlDLG9CQUFvQiw2QkFBNkIsNkJBQTZCLDJEQUEyRCwyQ0FBMkMsK0NBQStDLHNCQUFzQiw2QkFBNkIsbUNBQW1DLDJCQUEyQiwrRUFBK0UsU0FBUyxFQUFFLHFDQUFxQyxLQUFLLFFBQVEsMkRBQTJELGFBQWEsbUNBQW1DLGlCQUFpQixFQUFFLGFBQWEsRUFBRSxPQUFPLGdGQUFnRiwyQkFBMkIsaUdBQWlHLGdHQUFnRyxpS0FBaUssMEVBQTBFLGVBQWUsYUFBYSxzQ0FBc0MsU0FBUywrQ0FBK0Msa0VBQWtFLGdEQUFnRCw4Q0FBOEMscU1BQXFNLEVBQUUsUUFBUSxxQ0FBcUMsS0FBSyxxQkFBcUIsb0RBQW9ELDhHQUE4RywrREFBK0QsMExBQTBMLHVDQUF1QyxzQ0FBc0MsMkNBQTJDLFlBQVksa0JBQWtCLGNBQWMsMkVBQTJFLDBCQUEwQixPQUFPLHdEQUF3RCxPQUFPLDhCQUE4Qiw0R0FBNEcsUUFBUSxJQUFJLHFDQUFxQyxRQUFRLElBQUkseUNBQXlDLFFBQVEsYUFBYSxRQUFRLFdBQVcsUUFBUSxhQUFhLFFBQVEsVUFBVSxFQUFFLDRDQUE0QyxNQUFNLEdBQUcsMkJBQTJCLE1BQU0sRUFBRSxNQUFNLEVBQUUsOEJBQThCLEVBQUUsRUFBRSx1QkFBdUIsR0FBRyx1Q0FBdUMsTUFBTSxHQUFHLDJCQUEyQixNQUFNLEVBQUUsTUFBTSxFQUFFLDhCQUE4QixFQUFFLEVBQUUsdUJBQXVCLEdBQUcsRUFBRSxVQUFVLDRDQUE0QyxjQUFjLFNBQVMsWUFBWSxNQUFNLGFBQWEsS0FBSyxJQUFJLGdCQUFnQixPQUFPLFNBQVMsTUFBTSwwQ0FBMEMsY0FBYyxTQUFTLFlBQVksTUFBTSxhQUFhLEtBQUssSUFBSSxxQkFBcUIsT0FBTyxJQUFJLE1BQU0sc0JBQXNCLEVBQUUsZ0JBQWdCLEVBQUUsZ0JBQWdCLEVBQUUsMkJBQTJCLGtCQUFrQixRQUFRLEdBQUcsbUNBQW1DLG1CQUFtQixTQUFTLEtBQUssUUFBUSxrQkFBa0IsU0FBUyxLQUFLLFFBQVEsVUFBVSxVQUFVLHVDQUF1QyxnQ0FBZ0MsTUFBTSxJQUFJLE1BQU0sNkJBQTZCLEdBQUcsNkJBQTZCLEdBQUcsK0NBQStDLDZDQUE2QyxpQkFBaUIsa0JBQWtCLEVBQUUsa0JBQWtCLEVBQUUsa0JBQWtCLFVBQVUsUUFBUSxlQUFlLEVBQUUscUNBQXFDLEtBQUssUUFBUSx1REFBdUQsMkJBQTJCLEVBQUUsV0FBVyxHQUFHLGdCQUFnQixhQUFhLHNDQUFzQyxTQUFTLDZGQUE2Rix1REFBdUQsZ0JBQWdCLDhDQUE4QyxzTUFBc00sRUFBRSxRQUFRLHFDQUFxQyxLQUFLLHdCQUF3QixrRUFBa0UsK0RBQStELG1FQUFtRSx1Q0FBdUMsNkVBQTZFLFlBQVksc0JBQXNCLGlEQUFpRCxFQUFFLFFBQVEsRUFBRSxrQ0FBa0MsRUFBRSxJQUFJLGtCQUFrQixFQUFFLEVBQUUsa0JBQWtCLEVBQUUsRUFBRSwyQ0FBMkMsMkNBQTJDLHdCQUF3Qix3QkFBd0IsSUFBSSxnQkFBZ0IsTUFBTSxrQkFBa0IsSUFBSSxNQUFNLGtCQUFrQixJQUFJLE1BQU0scUNBQXFDLFdBQVcsWUFBWSxFQUFFLFlBQVksRUFBRSx1QkFBdUIsT0FBTyxFQUFFLHFDQUFxQyxLQUFLLFFBQVEseURBQXlELGdCQUFnQixFQUFFLFFBQVEsRUFBRSx5T0FBeU8sWUFBWSxpRUFBaUUscUhBQXFILDZJQUE2SSx1RUFBdUUsc0JBQXNCLFNBQVMsa0NBQWtDLDRDQUE0QyxPQUFPLGVBQWUsZ0VBQWdFLFFBQVEsSUFBSSxlQUFlLDZDQUE2Qyx3RkFBd0YsTUFBTSxHQUFHLDJCQUEyQixNQUFNLEVBQUUsaUNBQWlDLEVBQUUsRUFBRSxhQUFhLEdBQUcsR0FBRywrQkFBK0IsTUFBTSxHQUFHLDJCQUEyQixNQUFNLEVBQUUsNkJBQTZCLEdBQUcsRUFBRSxxQkFBcUIsZ0JBQWdCLGFBQWEsc0NBQXNDLFNBQVMsdUNBQXVDLGlEQUFpRCwwRUFBMEUsbUVBQW1FLEtBQUssaUJBQWlCLG9PQUFvTyxRQUFRLGdCQUFnQixRQUFRLGtCQUFrQixRQUFRLElBQUksa0JBQWtCLFFBQVEsSUFBSSw0QkFBNEIsR0FBRyw0QkFBNEIsR0FBRyxTQUFTLFlBQVksTUFBTSw2Q0FBNkMsd0JBQXdCLHVCQUF1Qix1QkFBdUIsS0FBSyxFQUFFLFNBQVMsY0FBYyxJQUFJLFVBQVUsTUFBTSxLQUFLLFNBQVMsbUJBQW1CLFNBQVMsd0JBQXdCLGlCQUFpQixpQ0FBaUMsbURBQW1ELE1BQU0sd0NBQXdDLFNBQVMsbUJBQW1CLE1BQU0sVUFBVSxLQUFLLEdBQUcsY0FBYyxFQUFFLHNDQUFzQyxFQUFFLHdDQUF3QyxFQUFFLGlEQUFpRCxFQUFFLFdBQVcsZ0NBQWdDLGNBQWMsR0FBRyx1QkFBdUIsbUJBQW1CLEVBQUUsR0FBRyxnQkFBZ0IsVUFBVSxVQUFVLGNBQWMsTUFBTSxnQkFBZ0IsRUFBRSxrQkFBa0IsVUFBVSxTQUFTLEVBQUUsRUFBRSxhQUFhLFdBQVcsVUFBVSxxQ0FBcUMsS0FBSyxtQkFBbUIseURBQXlELGdCQUFnQixFQUFFLE9BQU8sRUFBRSxnQkFBZ0IsYUFBYSxzQ0FBc0MsU0FBUyw0REFBNEQsZ0JBQWdCLGdCQUFnQix3Q0FBd0MsRUFBRSxHQUFHLEVBQUUsSUFBSSwrQ0FBK0Msd0JBQXdCLGdDQUFnQyxtREFBbUQsb0NBQW9DLCtDQUErQyxPQUFPLHFEQUFxRCwyQ0FBMkMsZ0lBQWdJLE9BQU8sT0FBTyxnQkFBZ0IsYUFBYSxzQ0FBc0MsU0FBUyx5RUFBeUUsZ0RBQWdELGlFQUFpRSw0REFBNEQsS0FBSyx5Q0FBeUMsa0NBQWtDLG9IQUFvSCx5Q0FBeUMsc0JBQXNCLEVBQUUsb0JBQW9CLEtBQUssaUJBQWlCLDhCQUE4QixzRUFBc0Usa0JBQWtCLHVKQUF1Six1RUFBdUUseUNBQXlDLHNCQUFzQixFQUFFLGFBQWEsNEVBQTRFLFNBQVMsNEJBQTRCLEVBQUUsWUFBWSxpQ0FBaUMsU0FBUyxFQUFFLE9BQU8sd0VBQXdFLHNEQUFzRCxpQkFBaUIsT0FBTyw0REFBNEQsdUZBQXVGLE9BQU8sZ0ZBQWdGLDhEQUE4RCw0RUFBNEUsYUFBYSxzS0FBc0ssZUFBZSx1REFBdUQsOENBQThDLDJDQUEyQyx5Q0FBeUMscUJBQXFCLGlCQUFpQixTQUFTLGNBQWMsS0FBSywwQkFBMEIsRUFBRSxNQUFNLE1BQU0sc0NBQXNDLHFCQUFxQixLQUFLLGtCQUFrQiwwQkFBMEIsTUFBTSxZQUFZLGtDQUFrQyxFQUFFLElBQUkseUNBQXlDLEVBQUUsRUFBRSx5QkFBeUIsb0JBQW9CLFlBQVksRUFBRSxpREFBaUQsRUFBRSxJQUFJLEVBQUUsRUFBRSwwQ0FBMEMsWUFBWSxhQUFhLHVCQUF1QixTQUFTLFVBQVUsbUJBQW1CLGlCQUFpQixTQUFTLGNBQWMsS0FBSywwQkFBMEIsRUFBRSxNQUFNLE1BQU0sdUJBQXVCLFNBQVMsV0FBVyxnQ0FBZ0MsWUFBWSxzREFBc0Qsc0JBQXNCLEtBQUssSUFBSSxnQkFBZ0IsV0FBVywwQkFBMEIsTUFBTSxZQUFZLGtDQUFrQyxFQUFFLElBQUkseUJBQXlCLG9CQUFvQixZQUFZLEVBQUUsaURBQWlELEVBQUUsSUFBSSxFQUFFLEVBQUUsMENBQTBDLFlBQVksYUFBYSx1QkFBdUIsU0FBUyxVQUFVLG1CQUFtQixpQkFBaUIsU0FBUyxjQUFjLEtBQUssMEJBQTBCLEVBQUUsTUFBTSxNQUFNLDRCQUE0QixxQkFBcUIsS0FBSyxRQUFRLFFBQVEsMEJBQTBCLE1BQU0sVUFBVSxrQ0FBa0MsRUFBRSxJQUFJLHlCQUF5QixvQkFBb0IsWUFBWSxFQUFFLGlEQUFpRCxFQUFFLElBQUksRUFBRSxFQUFFLDBDQUEwQyxZQUFZLGFBQWEsdUJBQXVCLFNBQVMsV0FBVyxnQkFBZ0IsYUFBYSxzQ0FBc0MsU0FBUyw4SkFBOEosbUNBQW1DLHdCQUF3QixLQUFLLFNBQVMsOEZBQThGLDJDQUEyQyxLQUFLLG9CQUFvQixNQUFNLGtDQUFrQyx3UEFBd1AsbUdBQW1HLHlDQUF5QyxzRUFBc0UsR0FBRyxvQkFBb0Isc0RBQXNELFNBQVMsdUNBQXVDLEVBQUUsRUFBRSx1QkFBdUIsR0FBRyxPQUFPLEVBQUUscUJBQXFCLDhCQUE4QixXQUFXLFVBQVUscUNBQXFDLEtBQUssUUFBUSx5REFBeUQsZ0JBQWdCLEdBQUcsOEJBQThCLEtBQUssU0FBUywyRkFBMkYsa0JBQWtCLEdBQUcsMkNBQTJDLEtBQUssb0JBQW9CLE1BQU0sd0NBQXdDLHVEQUF1RCx5Q0FBeUMsMEVBQTBFLEVBQUUscUJBQXFCLEtBQUssU0FBUywwRkFBMEYsMkNBQTJDLEtBQUssb0JBQW9CLE1BQU0sOEJBQThCLHVSQUF1Uix3RkFBd0YsK0ZBQStGLHlDQUF5QyxrR0FBa0csR0FBRyxvQkFBb0IsaUNBQWlDLGlEQUFpRCxtQkFBbUIsUUFBUSxxQ0FBcUMsS0FBSyxRQUFRLHlEQUF5RCxnQkFBZ0IsRUFBRSxhQUFhLDhKQUE4SixpREFBaUQsdUZBQXVGLElBQUksMEJBQTBCLCtEQUErRCxtQkFBbUIsbURBQW1ELFFBQVEsSUFBSSxtSEFBbUgsSUFBSSwyRUFBMkUsa0VBQWtFLEtBQUssb0JBQW9CLE9BQU8sWUFBWSxrRUFBa0UsdUZBQXVGLGlCQUFpQixpQkFBaUIsNEJBQTRCLDZJQUE2SSxtQkFBbUIsMENBQTBDLE1BQU0sSUFBSSxNQUFNLGtCQUFrQixHQUFHLGlCQUFpQixHQUFHLFNBQVMsR0FBRyxJQUFJLEdBQUcsSUFBSSxzQkFBc0IsR0FBRyxnQkFBZ0IsR0FBRyxVQUFVLEVBQUUsR0FBRyxzQkFBc0IseUJBQXlCLGVBQWUsZ0JBQWdCLEVBQUUsYUFBYSwrQkFBK0IsTUFBTSxJQUFJLE1BQU0sa0JBQWtCLEdBQUcsaUJBQWlCLEdBQUcsU0FBUyxHQUFHLElBQUksR0FBRyxJQUFJLGdCQUFnQixFQUFFLGFBQWEsNEJBQTRCLDZJQUE2SSx5Q0FBeUMsTUFBTSxJQUFJLE1BQU0sb0JBQW9CLEdBQUcsaUJBQWlCLEdBQUcsU0FBUyxHQUFHLElBQUksR0FBRyxJQUFJLHdCQUF3QixHQUFHLGdCQUFnQixHQUFHLFVBQVUsRUFBRSxHQUFHLDBCQUEwQixHQUFHLDJCQUEyQixpQkFBaUIsNkNBQTZDLE1BQU0sSUFBSSxNQUFNLG9CQUFvQixHQUFHLGlCQUFpQixHQUFHLFNBQVMsR0FBRyxJQUFJLEdBQUcsSUFBSSxnQ0FBZ0MsWUFBWSw2Q0FBNkMsRUFBRSxJQUFJLG9CQUFvQixFQUFFLEVBQUUsZ0NBQWdDLDhCQUE4QixHQUFHLHdCQUF3QixjQUFjLEVBQUUsY0FBYyxFQUFFLGNBQWMsRUFBRSxjQUFjLEVBQUUseUJBQXlCLFdBQVcsV0FBVyw0TUFBNE0sU0FBUywyRkFBMkYsc0JBQXNCLDZCQUE2QixzQkFBc0IsZUFBZSxhQUFhLHlCQUF5QixnQkFBZ0IsRUFBRSxhQUFhLGdCQUFnQixjQUFjLEVBQUUseUJBQXlCLEVBQUUsc0NBQXNDLEVBQUUsSUFBSSxvQkFBb0IsRUFBRSxFQUFFLGdDQUFnQyx5QkFBeUIsRUFBRSxFQUFFLHVCQUF1QixFQUFFLEVBQUUsNEJBQTRCLEVBQUUsRUFBRSxnQ0FBZ0MsRUFBRSxFQUFFLDBCQUEwQixFQUFFLEVBQUUsY0FBYyxFQUFFLGNBQWMsRUFBRSxjQUFjLEVBQUUsY0FBYyxFQUFFLDhCQUE4QixHQUFHLHdCQUF3QiwrQkFBK0IsNEJBQTRCLE1BQU0sSUFBSSxNQUFNLHdEQUF3RCw0QkFBNEIsNkJBQTZCLEdBQUcsSUFBSSxJQUFJLE1BQU0sSUFBSSxNQUFNLGtEQUFrRCxHQUFHLElBQUksRUFBRSxrQ0FBa0MsR0FBRyxJQUFJLEVBQUUsZ0JBQWdCLGtCQUFrQixFQUFFLGFBQWEsY0FBYyxFQUFFLDJCQUEyQixXQUFXLFdBQVcsV0FBVyxTQUFTLFlBQVksV0FBVyxrQkFBa0IsRUFBRSxHQUFHLEVBQUUsTUFBTSxNQUFNLFFBQVEsU0FBUyxrREFBa0QsRUFBRSxxQkFBcUIsRUFBRSxZQUFZLFlBQVksR0FBRyxPQUFPLGVBQWUsT0FBTyxzQkFBc0IsTUFBTSxHQUFHLEtBQUssTUFBTSx5Q0FBeUMsMENBQTBDLE9BQU8sZ0JBQWdCLEdBQUcsY0FBYyxLQUFLLEVBQUUsZ0JBQWdCLGFBQWEsc0NBQXNDLFNBQVMsbUlBQW1JLDREQUE0RCxLQUFLLFNBQVMsNkRBQTZELDJDQUEyQyxLQUFLLDRDQUE0QyxPQUFPLDRCQUE0QixnRkFBZ0YseUNBQXlDLGtCQUFrQixHQUFHLHdCQUF3QixvR0FBb0csV0FBVyxZQUFZLG1CQUFtQixtRkFBbUYsR0FBRyxLQUFLLEdBQUcsR0FBRyxJQUFJLGVBQWUsR0FBRyxFQUFFLEtBQUsseUJBQXlCLEVBQUUsT0FBTyxHQUFHLGdCQUFnQixFQUFFLGFBQWEsdUJBQXVCLEVBQUUsZ0JBQWdCLFNBQVMsRUFBRSx5QkFBeUIsK0NBQStDLFlBQVksSUFBSSx1Q0FBdUMsd0NBQXdDLEVBQUUsUUFBUSxvQ0FBb0MsYUFBYSxZQUFZLFlBQVksMENBQTBDLEVBQUUsWUFBWSxZQUFZLDJEQUEyRCxTQUFTLEVBQUUscUNBQXFDLEtBQUssUUFBUSx5REFBeUQsZ0JBQWdCLEVBQUUsT0FBTyxtRUFBbUUsa0ZBQWtGLDREQUE0RCx5QkFBeUIsNERBQTRELFFBQVEsWUFBWSxtQkFBbUIsdURBQXVELG9CQUFvQix5QkFBeUIsY0FBYyxFQUFFLEVBQUUsR0FBRyxxREFBcUQsV0FBVyxZQUFZLG1CQUFtQix3REFBd0QsRUFBRSxNQUFNLEdBQUcsVUFBVSxhQUFhLHVCQUF1QixvQ0FBb0MsTUFBTSxxREFBcUQsV0FBVyxZQUFZLG1CQUFtQix3REFBd0QsRUFBRSxNQUFNLEdBQUcsVUFBVSxhQUFhLHVCQUF1QixvQ0FBb0MsTUFBTSxpRUFBaUUseUJBQXlCLDBFQUEwRSx5QkFBeUIsc0JBQXNCLGdGQUFnRixZQUFZLHFCQUFxQixlQUFlLFFBQVEsZ0JBQWdCLGFBQWEsc0NBQXNDLFNBQVMsbUZBQW1GLDhDQUE4QyxtREFBbUQsY0FBYyx3RkFBd0YsRUFBRSxFQUFFLE1BQU0scUNBQXFDLEtBQUsscUJBQXFCLG1CQUFtQixTQUFTLFlBQVksSUFBSSxLQUFLLFNBQVMsVUFBVSw0QkFBNEIsRUFBRSxNQUFNLG1EQUFtRCxFQUFFLE1BQU0sbURBQW1ELEVBQUUsTUFBTSxxREFBcUQsRUFBRSxNQUFNLHdCQUF3QixnQkFBZ0IsRUFBRSxZQUFZLHdEQUF3RCxLQUFLLGlFQUFpRSwrRUFBK0UscUVBQXFFLHVCQUF1QixFQUFFLGlFQUFpRSxjQUFjLE1BQU0sS0FBSyxVQUFVLHdFQUF3RSxZQUFZLGdFQUFnRSxnRUFBZ0UsVUFBVSxxQkFBcUIsTUFBTSxJQUFJLEdBQUcsSUFBSSxJQUFJLEVBQUUsc0JBQXNCLFFBQVEsSUFBSSxHQUFHLElBQUksTUFBTSxJQUFJLEVBQUUsY0FBYyxNQUFNLElBQUksRUFBRSxHQUFHLGFBQWEsOEJBQThCLE9BQU8sTUFBTSxJQUFJLFVBQVUsWUFBWSxzQ0FBc0MsZ0RBQWdELHFEQUFxRCxNQUFNLGVBQWUsTUFBTSxXQUFXLEtBQUssSUFBSSxJQUFJLFVBQVUsMEJBQTBCLHVCQUF1Qix1Q0FBdUMsb0NBQW9DLCtCQUErQix1QkFBdUIsTUFBTSx1QkFBdUIsTUFBTSxjQUFjLEVBQUUsWUFBWSxVQUFVLFNBQVMsU0FBUyxRQUFRLHFDQUFxQyxLQUFLLFFBQVEsb0RBQW9ELDJCQUEyQixFQUFFLFdBQVcsRUFBRSw2QkFBNkIsOEJBQThCLFFBQVEsWUFBWSxhQUFhLFlBQVksbURBQW1ELGdDQUFnQyxTQUFTLDRKQUE0SixlQUFlLGFBQWEsc0NBQXNDLFNBQVMsbUJBQW1CLGdCQUFnQixrQkFBa0Isc0VBQXNFLDZFQUE2RSxnQkFBZ0IsYUFBYSxzQ0FBc0MsU0FBUyx3RUFBd0UsMkRBQTJELGtFQUFrRSxrRkFBa0YsS0FBSyxzQ0FBc0MsMklBQTJJLGtCQUFrQix3RUFBd0UsOEdBQThHLEtBQUssUUFBUSx1REFBdUQsdUNBQXVDLGlDQUFpQyxZQUFZLGVBQWUsd0JBQXdCLFVBQVUsSUFBSSxtQkFBbUIsRUFBRSxFQUFFLGlCQUFpQix5RUFBeUUsRUFBRSxHQUFHLG9DQUFvQyx1RUFBdUUsU0FBUyxZQUFZLEVBQUUsR0FBRywwQ0FBMEMsU0FBUyxnRkFBZ0YsT0FBTyxJQUFJLGtDQUFrQyxpRkFBaUYsMERBQTBELHVCQUF1QixvQkFBb0IsTUFBTSxpRkFBaUYsd0VBQXdFLHVCQUF1QixvQkFBb0IsTUFBTSx5RkFBeUYsc0RBQXNELHNFQUFzRSxFQUFFLHVGQUF1RixFQUFFLHVGQUF1RixFQUFFLHVGQUF1RixFQUFFLG9GQUFvRix1QkFBdUIsb0JBQW9CLE1BQU0sb0ZBQW9GLGdEQUFnRCxFQUFFLFlBQVksRUFBRSxZQUFZLEVBQUUseUNBQXlDLEVBQUUsVUFBVSxpREFBaUQsRUFBRSxZQUFZLEVBQUUsWUFBWSxFQUFFLHlDQUF5QyxFQUFFLFVBQVUsOERBQThELDBEQUEwRCx1QkFBdUIsb0JBQW9CLE1BQU0sc0hBQXNILDBCQUEwQixJQUFJLGdGQUFnRixFQUFFLE1BQU0sRUFBRSxJQUFJLGtEQUFrRCxFQUFFLFdBQVcsRUFBRSxXQUFXLEVBQUUsV0FBVyxFQUFFLEdBQUcsZ0JBQWdCLDBCQUEwQixnQkFBZ0IsRUFBRSw2REFBNkQsb0VBQW9FLGVBQWUsMkJBQTJCLG9CQUFvQixHQUFHLHVCQUF1QixzQ0FBc0Msb0NBQW9DLCtKQUErSiw0SEFBNEgsb05BQW9OLDRHQUE0Ryw0R0FBNEcsNEdBQTRHLCtDQUErQyxLQUFLLDZDQUE2QyxLQUFLLHdiQUF3YiwwYkFBMGIsOGJBQThiLGdjQUFnYyxtSkFBbUoscUVBQXFFLHNFQUFzRSw2RUFBNkUsbUVBQW1FLHNCQUFzQixVQUFVLGlCQUFpQixlQUFlLFlBQVkscUNBQXFDLEtBQUssUUFBUSx1REFBdUQsMkJBQTJCLEVBQUUsV0FBVyxrQkFBa0IsaUJBQWlCLGlCQUFpQiw0QkFBNEIsa0JBQWtCLGdHQUFnRyx5QkFBeUIsS0FBSywyQkFBMkIsdUZBQXVGLHdEQUF3RCxxR0FBcUcsOENBQThDLFlBQVksYUFBYSxnQ0FBZ0Msc0NBQXNDLGVBQWUsZ0NBQWdDLGdCQUFnQixJQUFJLGlCQUFpQixzRkFBc0YsT0FBTyxvQkFBb0IsdUNBQXVDLGdCQUFnQixhQUFhLHNDQUFzQyxTQUFTLGlCQUFpQixnQkFBZ0IseUdBQXlHLFlBQVksZ0VBQWdFLGdCQUFnQixhQUFhLHNDQUFzQyxTQUFTLG1EQUFtRCwrQ0FBK0MsbUVBQW1FLDREQUE0RCxLQUFLLHlDQUF5QyxrQ0FBa0Msd0dBQXdHLHlDQUF5Qyx1QkFBdUIsR0FBRyxrQkFBa0Isb1VBQW9VLFlBQVksV0FBVyxrREFBa0QsS0FBSyxPQUFPLE1BQU0sR0FBRywrQ0FBK0MsU0FBUyxJQUFJLFlBQVksbUJBQW1CLCtCQUErQixTQUFTLEVBQUUscUNBQXFDLEtBQUssUUFBUSxzREFBc0QsZ0JBQWdCLEVBQUUsT0FBTywrREFBK0Qsa0ZBQWtGLG1CQUFtQixLQUFLLGVBQWUsMkNBQTJDLEtBQUsseUNBQXlDLFlBQVksZ0JBQWdCLG9QQUFvUCxzSEFBc0gsa0hBQWtILE9BQU8sbUNBQW1DLEdBQUcsRUFBRSxHQUFHLEVBQUUsRUFBRSxHQUFHLE9BQU8sdUVBQXVFLG9GQUFvRixvRkFBb0YsbUdBQW1HLG9HQUFvRyxnQkFBZ0IsYUFBYSxzQ0FBc0MsU0FBUyxxRkFBcUYsMERBQTBELDhFQUE4RSxJQUFJLDZHQUE2RyxJQUFJLGdJQUFnSSxvQkFBb0IsS0FBSywrSUFBK0ksb0JBQW9CLGdFQUFnRSxtQ0FBbUMsb0VBQW9FLG9DQUFvQyx5QkFBeUIsS0FBSyxpR0FBaUcsZ0JBQWdCLGtCQUFrQixTQUFTLGtHQUFrRyxPQUFPLDRCQUE0QixpTEFBaUwsbUNBQW1DLHNCQUFzQixnRUFBZ0UsS0FBSywrQkFBK0IsNkVBQTZFLEtBQUssK0JBQStCLHdEQUF3RCwyQ0FBMkMsS0FBSywrQkFBK0IsZUFBZSxpQkFBaUIsc0ZBQXNGLDBHQUEwRyw0RUFBNEUsd0ZBQXdGLDBGQUEwRixFQUFFLFlBQVksd0RBQXdELEdBQUcsMENBQTBDLFlBQVksK0NBQStDLEVBQUUsYUFBYSxHQUFHLElBQUksdUJBQXVCLElBQUksSUFBSSxlQUFlLDhDQUE4QyxZQUFZLGdFQUFnRSxFQUFFLElBQUksRUFBRSxJQUFJLHVEQUF1RCxXQUFXLHVCQUF1QixTQUFTLEVBQUUscUNBQXFDLEtBQUssUUFBUSxzREFBc0QsZ0JBQWdCLEVBQUUsbUJBQW1CLHNGQUFzRiwwR0FBMEcsNEVBQTRFLHdGQUF3RiwwRkFBMEYsc0dBQXNHLHFDQUFxQyxFQUFFLFlBQVksd0RBQXdELEdBQUcsb0NBQW9DLG9DQUFvQyx1QkFBdUIsSUFBSSxJQUFJLGVBQWUsaURBQWlELDZEQUE2RCxnRUFBZ0UsRUFBRSxJQUFJLEVBQUUsV0FBVyxXQUFXLCtCQUErQixTQUFTLEVBQUUscUNBQXFDLEtBQUssUUFBUSxzREFBc0QsZ0JBQWdCLEVBQUUsbUJBQW1CLDJGQUEyRiwwR0FBMEcsd0dBQXdHLGdIQUFnSCxxQ0FBcUMsRUFBRSxZQUFZLHFKQUFxSixFQUFFLElBQUksRUFBRSxFQUFFLHFGQUFxRiwwQ0FBMEMsR0FBRyx1REFBdUQsMEtBQTBLLDBFQUEwRSxPQUFPLEVBQUUscUNBQXFDLEtBQUssUUFBUSwyREFBMkQsZ0JBQWdCLEVBQUUsT0FBTyxpRUFBaUUsdUZBQXVGLGdCQUFnQixhQUFhLHNDQUFzQyxTQUFTLHdDQUF3QyxzQ0FBc0MsbUVBQW1FLGtCQUFrQixLQUFLLDZFQUE2RSxZQUFZLElBQUksK0NBQStDLEtBQUssYUFBYSxZQUFZLEVBQUUsRUFBRSwwQkFBMEIsTUFBTSxTQUFTLDRCQUE0Qiw0RkFBNEYseUNBQXlDLDRCQUE0QixHQUFHLG9CQUFvQixtRUFBbUUsZ0JBQWdCLGlCQUFpQixzSEFBc0gsU0FBUyxJQUFJLG9CQUFvQixFQUFFLE9BQU8sR0FBRyw2QkFBNkIsU0FBUyxRQUFRLHFDQUFxQyxLQUFLLGFBQWEsV0FBVyxHQUFHLEVBQUUsVUFBVSxzREFBc0QsZ0JBQWdCLEVBQUUsT0FBTyxpRUFBaUUsMk9BQTJPLGdCQUFnQixhQUFhLHNDQUFzQyxTQUFTLHlEQUF5RCxnQkFBZ0Isb0JBQW9CLEtBQUssOENBQThDLGtDQUFrQywwSUFBMEksWUFBWSxpRUFBaUUsdUVBQXVFLE9BQU8sa0VBQWtFLCtEQUErRCxnQkFBZ0IsYUFBYSxzQ0FBc0MsU0FBUyxlQUFlLDBCQUEwQixjQUFjLEtBQUssU0FBUyx3Q0FBd0MsRUFBRSxpRUFBaUUsMkNBQTJDLEtBQUssaUJBQWlCLE9BQU8sa0JBQWtCLHVHQUF1RywwQkFBMEIsaUJBQWlCLFlBQVksSUFBSSxFQUFFLDRCQUE0QixZQUFZLFVBQVUsU0FBUyxTQUFTLFFBQVEscUNBQXFDLEtBQUssUUFBUSx5REFBeUQsMkJBQTJCLEVBQUUsT0FBTyw0REFBNEQseUJBQXlCLFlBQVksV0FBVyxLQUFLLHdFQUF3RSxZQUFZLElBQUksb0ZBQW9GLHVGQUF1RixZQUFZLFdBQVcsOEVBQThFLGdCQUFnQixhQUFhLHNDQUFzQyxTQUFTLGdCQUFnQix5QkFBeUIsZUFBZSxLQUFLLFNBQVMsa0VBQWtFLDJDQUEyQyxLQUFLLGlCQUFpQixPQUFPLGtCQUFrQixxREFBcUQsWUFBWSxXQUFXLG9EQUFvRCxFQUFFLDhCQUE4QixFQUFFLE1BQU0sS0FBSyxJQUFJLEdBQUcsMERBQTBELEVBQUUsSUFBSSx5QkFBeUIsRUFBRSxFQUFFLFlBQVksYUFBYSw4QkFBOEIsU0FBUyxRQUFRLHFDQUFxQyxLQUFLLFFBQVEseURBQXlELGdCQUFnQixFQUFFLE9BQU8sOERBQThELG9GQUFvRiwyRUFBMkUsaUZBQWlGLHFGQUFxRixnQkFBZ0IsYUFBYSxzQ0FBc0MsU0FBUyxnREFBZ0Qsc0NBQXNDLHVFQUF1RSxnRUFBZ0UsS0FBSyw4Q0FBOEMsd0VBQXdFLHFDQUFxQyxFQUFFLGtCQUFrQixlQUFlLFNBQVMsdUNBQXVDLGNBQWMsb0NBQW9DLEVBQUUsSUFBSSxrQkFBa0IsRUFBRSxFQUFFLDJCQUEyQix1QkFBdUIsU0FBUyxFQUFFLHFDQUFxQyxLQUFLLFFBQVEsc0RBQXNELGdCQUFnQixFQUFFLG1JQUFtSSxXQUFXLGVBQWUsRUFBRSxhQUFhLEVBQUUsYUFBYSxFQUFFLElBQUksR0FBRyxZQUFZLElBQUksa0JBQWtCLEtBQUssUUFBUSxFQUFFLEVBQUUsR0FBRyxrQkFBa0IsZ0JBQWdCLE9BQU8sbUVBQW1FLGlHQUFpRyxnQkFBZ0IsYUFBYSxzQ0FBc0MsU0FBUyx5QkFBeUIsMEJBQTBCLHdCQUF3QixvSEFBb0gsNkNBQTZDLCtCQUErQixxRUFBcUUsT0FBTyxpREFBaUQsdUJBQXVCLDBDQUEwQyxTQUFTLGtDQUFrQyw4QkFBOEIsMENBQTBDLFVBQVUsd0JBQXdCLHNEQUFzRCxVQUFVLHlCQUF5Qix1REFBdUQsU0FBUyx1Q0FBdUMsMENBQTBDLG9EQUFvRCxrQ0FBa0MsMEJBQTBCLGtDQUFrQyw0QkFBNEIsb0NBQW9DLHdDQUF3QyxrQ0FBa0MsNEJBQTRCLHFDQUFxQyx3Q0FBd0MsMkJBQTJCLE9BQU8scUJBQXFCLHdCQUF3QixZQUFZLGdCQUFnQixVQUFVLFVBQVUsdUJBQXVCLE9BQU8sS0FBSyxnRkFBZ0YseUVBQXlFLDRCQUE0Qix1Q0FBdUMsZ0JBQWdCLGFBQWEsc0NBQXNDLFNBQVMsMmRBQTJkLHVEQUF1RCxhQUFhLGdCQUFnQixhQUFhLGlCQUFpQixhQUFhLGlCQUFpQixhQUFhLGlCQUFpQixhQUFhLGlCQUFpQixhQUFhLGdCQUFnQixjQUFjLGNBQWMsT0FBTyxzQ0FBc0MsRUFBRSxFQUFFLGNBQWMsRUFBRSxZQUFZLGtEQUFrRCxLQUFLLFdBQVcsRUFBRSxXQUFXLG9CQUFvQixFQUFFLFVBQVUsRUFBRSxVQUFVLEVBQUUsVUFBVSxFQUFFLFFBQVEsS0FBSyw2Q0FBNkMsYUFBYSxnQkFBZ0IsYUFBYSxrQkFBa0IsZ0JBQWdCLGVBQWUsT0FBTyxvQ0FBb0MsRUFBRSxFQUFFLDhCQUE4QixFQUFFLEVBQUUsY0FBYyxFQUFFLFlBQVksZ0NBQWdDLEtBQUssV0FBVyxFQUFFLFdBQVcsZ0NBQWdDLEtBQUssNkNBQTZDLGFBQWEsb0JBQW9CLE9BQU8sa0JBQWtCLEVBQUUsWUFBWSxlQUFlLEtBQUssV0FBVyxFQUFFLFdBQVcsZUFBZSxLQUFLLDZDQUE2QyxjQUFjLG9CQUFvQixPQUFPLHNDQUFzQyxFQUFFLEVBQUUsY0FBYyxFQUFFLFlBQVkscUNBQXFDLEtBQUssV0FBVyxFQUFFLFdBQVcsb0JBQW9CLEVBQUUsVUFBVSxFQUFFLFVBQVUsRUFBRSxVQUFVLEVBQUUsUUFBUSxLQUFLLDZDQUE2QyxhQUFhLGdCQUFnQixhQUFhLGNBQWMsT0FBTyxrQkFBa0IsRUFBRSxZQUFZLGdCQUFnQixLQUFLLFdBQVcsRUFBRSxXQUFXLGdCQUFnQixLQUFLLDZDQUE2QyxhQUFhLGNBQWMsT0FBTyxrQkFBa0IsRUFBRSxZQUFZLGdDQUFnQyxLQUFLLFdBQVcsRUFBRSxXQUFXLGdCQUFnQixLQUFLLFdBQVcsRUFBRSxXQUFXLGtFQUFrRSxLQUFLLFlBQVksRUFBRSxZQUFZLDJDQUEyQyxLQUFLLDZDQUE2QyxhQUFhLGdCQUFnQixhQUFhLGVBQWUsT0FBTyxrQkFBa0IsRUFBRSxZQUFZLDJCQUEyQixLQUFLLFdBQVcsRUFBRSxXQUFXLDJCQUEyQixLQUFLLDZDQUE2QyxhQUFhLGtCQUFrQixPQUFPLGtCQUFrQixFQUFFLFlBQVksbUNBQW1DLEtBQUssV0FBVyxFQUFFLFdBQVcsbUNBQW1DLEtBQUssNkNBQTZDLGFBQWEsaUJBQWlCLGFBQWEsZ0JBQWdCLGFBQWEsZUFBZSxPQUFPLGtCQUFrQixFQUFFLFlBQVksOEJBQThCLG9CQUFvQixpQ0FBaUMsS0FBSyxXQUFXLEVBQUUsV0FBVyw4QkFBOEIsb0JBQW9CLGlDQUFpQyxLQUFLLDZDQUE2QyxjQUFjLE9BQU8sa0JBQWtCLEVBQUUsWUFBWSxlQUFlLEVBQUUsSUFBSSxLQUFLLFdBQVcsRUFBRSxXQUFXLGVBQWUsRUFBRSxJQUFJLEtBQUssNkNBQTZDLHFSQUFxUixvQkFBb0Isc0VBQXNFLHlEQUF5RCxxQ0FBcUMsS0FBSyxxQkFBcUIsd0hBQXdILHFDQUFxQyxLQUFLLFFBQVEsc0NBQXNDLHdCQUF3QixPQUFPLG9CQUFvQixvQkFBb0IsWUFBWSxlQUFlLGVBQWUsT0FBTyxLQUFLLFdBQVcsVUFBVSxJQUFJLFFBQVEsb0JBQW9CLEVBQUUsV0FBVyxHQUFHLHNSQUFzUix3RkFBd0Ysb0JBQW9CLGVBQWUsOEJBQThCLGdCQUFnQiwwSkFBMEosOEZBQThGLHlDQUF5QyxZQUFZLEdBQUcsa01BQWtNLHVDQUF1Qyw0UEFBNFAseUNBQXlDLCtWQUErVixnQkFBZ0IsYUFBYSxzQ0FBc0MsU0FBUyxtRUFBbUUsaURBQWlELGtFQUFrRSxrQ0FBa0MsOEpBQThKLG9CQUFvQixTQUFTLFlBQVksSUFBSSw0QkFBNEIsU0FBUywwQkFBMEIsWUFBWSxjQUFjLEVBQUUsbUJBQW1CLFVBQVUsR0FBRyx1QkFBdUIsa0hBQWtILEVBQUUsRUFBRSxhQUFhLDJEQUEyRCxpQ0FBaUMsRUFBRSxZQUFZLFFBQVEsT0FBTyxxQ0FBcUMsS0FBSyxtQkFBbUIsMkRBQTJELGdCQUFnQixFQUFFLHNFQUFzRSxLQUFLLDJDQUEyQyxFQUFFLGdCQUFnQixhQUFhLHNDQUFzQyxTQUFTLCtEQUErRCxnQkFBZ0Isc0JBQXNCLEtBQUssZ0RBQWdELGtDQUFrQyxnSkFBZ0osWUFBWSxtRUFBbUUsdUVBQXVFLE9BQU8sb0VBQW9FLCtEQUErRCxnQkFBZ0IsYUFBYSxzQ0FBc0MsU0FBUywwSUFBMEksc0NBQXNDLHNFQUFzRSxvRkFBb0YsS0FBSyxzQ0FBc0MsNktBQTZLLHlEQUF5RCwwRkFBMEYsRUFBRSxHQUFHLFNBQVMsd0VBQXdFLGlKQUFpSiw4S0FBOEssRUFBRSxxQkFBcUIsMkhBQTJILGlIQUFpSCxFQUFFLHFCQUFxQixtR0FBbUcsOEZBQThGLDJEQUEyRCxnQkFBZ0Isc0dBQXNHLGlQQUFpUCxHQUFHLGtCQUFrQixrU0FBa1Msb0NBQW9DLEVBQUUsRUFBRSw0QkFBNEIsRUFBRSxFQUFFLFVBQVUsY0FBYyxLQUFLLHFHQUFxRyxFQUFFLE1BQU0sTUFBTSwwQkFBMEIsRUFBRSxNQUFNLE1BQU0sWUFBWSxpREFBaUQsZ0RBQWdELEVBQUUsSUFBSSxFQUFFLEVBQUUsMENBQTBDLFlBQVksYUFBYSx1QkFBdUIsU0FBUyx3Q0FBd0MsRUFBRSxrQ0FBa0MsRUFBRSxJQUFJLDRCQUE0Qix1REFBdUQsRUFBRSxJQUFJLEVBQUUsRUFBRSxZQUFZLEVBQUUsbUJBQW1CLDBCQUEwQixRQUFRLElBQUksUUFBUSxpREFBaUQscURBQXFELDJCQUEyQiw0Q0FBNEMscUNBQXFDLHFDQUFxQyxtQkFBbUIsV0FBVyxnREFBZ0QsU0FBUyw0Q0FBNEMsT0FBTyxpQkFBaUIsRUFBRSxxQ0FBcUMsNEJBQTRCLHVEQUF1RCxFQUFFLElBQUksRUFBRSxFQUFFLFlBQVksRUFBRSxnQkFBZ0IsdUVBQXVFLHlEQUF5RCw2REFBNkQsOENBQThDLGtEQUFrRCw4Q0FBOEMsa0RBQWtELDBCQUEwQiwyRUFBMkUsd0RBQXdELG1FQUFtRSx3REFBd0QsbUVBQW1FLGtNQUFrTSxpREFBaUQsNEJBQTRCLG1DQUFtQyxzQ0FBc0MsY0FBYyxPQUFPLDREQUE0RCw2QkFBNkIsVUFBVSxNQUFNLDhEQUE4RCxTQUFTLDhEQUE4RCw0REFBNEQsb0JBQW9CLFNBQVMsY0FBYywrQ0FBK0Msc0ZBQXNGLFNBQVMsNEVBQTRFLDBFQUEwRSxtRUFBbUUsT0FBTyxXQUFXLEVBQUUscUNBQXFDLDRCQUE0Qix1REFBdUQsRUFBRSxJQUFJLEVBQUUsRUFBRSxZQUFZLEVBQUUsZ0JBQWdCLHlDQUF5Qyx5REFBeUQsNkRBQTZELDBCQUEwQiwyRUFBMkUsd0RBQXdELG1FQUFtRSx3REFBd0QsbUVBQW1FLHFGQUFxRixpREFBaUQsNEJBQTRCLG1DQUFtQyxzQ0FBc0MsY0FBYyxPQUFPLDREQUE0RCw2QkFBNkIsVUFBVSxNQUFNLDhEQUE4RCxTQUFTLDhEQUE4RCw0REFBNEQsb0JBQW9CLFNBQVMsY0FBYywrQ0FBK0Msc0ZBQXNGLFNBQVMsNEVBQTRFLDBFQUEwRSxtRUFBbUUsT0FBTyxFQUFFLHFDQUFxQyxLQUFLLFFBQVEseURBQXlELDRCQUE0QiwwRkFBMEYsRUFBRSxHQUFHLHlCQUF5QixpSUFBaUksaUdBQWlHLHVFQUF1RSw4QkFBOEIsTUFBTSxrRkFBa0Ysa0dBQWtHLCtRQUErUSx1QkFBdUIsYUFBYSxnQkFBZ0IsYUFBYSxzQ0FBc0MsU0FBUywwQkFBMEIsOENBQThDLHVCQUF1QixtQkFBbUIsd0dBQXdHLGVBQWUsd0JBQXdCLGlCQUFpQixtQkFBbUIsV0FBVyxNQUFNLCtDQUErQyw2REFBNkQsUUFBUSxNQUFNLHNDQUFzQyxnQkFBZ0IsSUFBSSw0S0FBNEssU0FBUyxvRUFBb0UsdURBQXVELHNCQUFzQixHQUFHLGtCQUFrQixVQUFVLGtJQUFrSSxhQUFhLGtFQUFrRSx3RkFBd0YsT0FBTyxrTEFBa0wsR0FBRyxXQUFXLHVCQUF1Qiw2RkFBNkYsNERBQTRELGtGQUFrRixnRUFBZ0UsRUFBRSxLQUFLLDhIQUE4SCx3Q0FBd0MsY0FBYywyQkFBMkIsaUZBQWlGLEVBQUUsR0FBRyxFQUFFLFVBQVUsUUFBUSxTQUFTLGNBQWMsbURBQW1ELGtCQUFrQixvQ0FBb0MsZ0VBQWdFLG9CQUFvQixNQUFNLDBCQUEwQixRQUFRLFVBQVUsdUNBQXVDLE1BQU0scUVBQXFFLG9EQUFvRCxFQUFFLCtDQUErQyxVQUFVLCtDQUErQyxNQUFNLGlEQUFpRCxNQUFNLCtDQUErQyxNQUFNLG9EQUFvRCxFQUFFLEtBQUssbUJBQW1CLG1EQUFtRCxzQkFBc0IsT0FBTyxxR0FBcUcsMkJBQTJCLFdBQVcsOEJBQThCLDhEQUE4RCxFQUFFLDJEQUEyRCxLQUFLLDJDQUEyQyxHQUFHLFNBQVMsd0JBQXdCLGtEQUFrRCx1Q0FBdUMsR0FBRyxhQUFhLFNBQVMsdUJBQXVCLGtEQUFrRCxnQkFBZ0IsYUFBYSxzQ0FBc0MsU0FBUywrQkFBK0IsNEVBQTRFLDRCQUE0QixpQkFBaUIsMFNBQTBTLDBDQUEwQyxxSkFBcUoseUJBQXlCLHlDQUF5QyxzQkFBc0IsbUZBQW1GLDZCQUE2QixpQkFBaUIsb0RBQW9ELGtCQUFrQix5QkFBeUIsb0JBQW9CLGlGQUFpRix5QkFBeUIsc0pBQXNKLFVBQVUsMFRBQTBULGVBQWUsNERBQTRELE9BQU8sa0RBQWtELGdCQUFnQixhQUFhLHNDQUFzQyxTQUFTLDJFQUEyRSxnQkFBZ0IsOEJBQThCLG1CQUFtQixrR0FBa0csS0FBSyx3REFBd0QsRUFBRSxHQUFHLDhGQUE4RixZQUFZLFFBQVEsZ0dBQWdHLDZPQUE2TyxZQUFZLDZCQUE2QixZQUFZLHFGQUFxRiw4QkFBOEIscUJBQXFCLCtEQUErRCxFQUFFLEdBQUcsNkZBQTZGLFlBQVksUUFBUSw2SUFBNkksWUFBWSw2QkFBNkIsWUFBWSxxRkFBcUYsMEJBQTBCLG1CQUFtQixnSUFBZ0ksS0FBSyx3REFBd0QsRUFBRSxHQUFHLG1HQUFtRyxZQUFZLDBEQUEwRCxZQUFZLDBDQUEwQyxZQUFZLGtEQUFrRCx1Q0FBdUMsY0FBYyxLQUFLLGdCQUFnQixhQUFhLHNDQUFzQyxTQUFTLDRLQUE0SywwQkFBMEIsZ0JBQWdCLDBGQUEwRixRQUFRLFlBQVksV0FBVyxLQUFLLFlBQVksNERBQTRELEdBQUcsaUJBQWlCLEtBQUssYUFBYSxzRUFBc0UsbUNBQW1DLE9BQU8sdUJBQXVCLGdCQUFnQixpQkFBaUIsMElBQTBJLEVBQUUsSUFBSSxFQUFFLGlCQUFpQixFQUFFLDJGQUEyRixFQUFFLDBCQUEwQixjQUFjLGNBQWMsY0FBYyx5QkFBeUIsV0FBVyxZQUFZLFdBQVcsWUFBWSxTQUFTLGNBQWMsZ0NBQWdDLHlCQUF5Qix1Q0FBdUMsZUFBZSxzQkFBc0Isc0JBQXNCLDRCQUE0Qiw0QkFBNEIsNEJBQTRCLHlJQUF5SSwyQkFBMkIsNEZBQTRGLEVBQUUsY0FBYyxZQUFZLEdBQUcsK0JBQStCLCtCQUErQixLQUFLLGlCQUFpQixLQUFLLDJGQUEyRixFQUFFLEdBQUcsZUFBZSwrQkFBK0IsZUFBZSxzQkFBc0Isc0JBQXNCLGlDQUFpQyxxRUFBcUUsb0JBQW9CLHNCQUFzQixxQ0FBcUMsMEJBQTBCLDRCQUE0Qix5SUFBeUksMkJBQTJCLDRGQUE0RixFQUFFLGNBQWMsWUFBWSxHQUFHLGlCQUFpQixpSEFBaUgsYUFBYSxhQUFhLGFBQWEscVVBQXFVLDJGQUEyRixvRkFBb0YsaURBQWlELHVEQUF1RCxpQ0FBaUMsZ0JBQWdCLGFBQWEsc0NBQXNDLFNBQVMsOEdBQThHLDBCQUEwQiwrQ0FBK0MsbVRBQW1ULGtEQUFrRCxtQ0FBbUMsRUFBRSw0Q0FBNEMsd0RBQXdELHlCQUF5QixnREFBZ0QsMEVBQTBFLGlCQUFpQiw0QkFBNEIsV0FBVywrREFBK0Qsd0VBQXdFLCtFQUErRSxPQUFPLGlJQUFpSSxnQkFBZ0IsYUFBYSxzQ0FBc0MsU0FBUywwQkFBMEIsZ0JBQWdCLHVCQUF1QixxQkFBcUIsaU1BQWlNLGlDQUFpQyw2RUFBNkUsd0RBQXdELDJCQUEyQixRQUFRLDhCQUE4QixLQUFLLEVBQUUsR0FBRyxFQUFFLEdBQUcsU0FBUyxHQUFHLGlCQUFpQixHQUFHLGNBQWMsb0VBQW9FLGlDQUFpQyxrQkFBa0IsZ0JBQWdCLHlGQUF5RixrRUFBa0UsUUFBUSxHQUFHLFNBQVMsR0FBRyxzRUFBc0UsNEVBQTRFLG1CQUFtQixpRkFBaUYsMEhBQTBILDhCQUE4QixHQUFHLDhCQUE4Qix3QkFBd0IscUNBQXFDLGdDQUFnQyxrREFBa0Qsa0ZBQWtGLDJCQUEyQix1Q0FBdUMsNkNBQTZDLDRJQUE0SSxrRUFBa0UsR0FBRywyQkFBMkIsb0ZBQW9GLDJHQUEyRyxpREFBaUQsR0FBRyxvQkFBb0IsTUFBTSx1RUFBdUUsZ0NBQWdDLGtDQUFrQyxNQUFNLDZCQUE2QixXQUFXLGNBQWMsK0JBQStCLHlEQUF5RCxzRUFBc0UsUUFBUSxHQUFHLFNBQVMsNENBQTRDLGtCQUFrQixVQUFVLGdFQUFnRSxnRUFBZ0UsNkRBQTZELG1FQUFtRSxtRUFBbUUsMkVBQTJFLHNFQUFzRSxzRUFBc0UsMkNBQTJDLEdBQUcsb0JBQW9CLG1CQUFtQiw0REFBNEQsaUJBQWlCLGNBQWMsc0JBQXNCLHVDQUF1QyxjQUFjLGFBQWEsTUFBTSxzQ0FBc0MsU0FBUywwREFBMEQsa01BQWtNLGdCQUFnQixhQUFhLHNDQUFzQyxTQUFTLHlOQUF5TixnQkFBZ0IsNkJBQTZCLGlCQUFpQix1Q0FBdUMsNENBQTRDLDRCQUE0QixRQUFRLGFBQWEsdUJBQXVCLElBQUksYUFBYSxtQ0FBbUMsSUFBSSxHQUFHLDBEQUEwRCxvSUFBb0kscUVBQXFFLGtKQUFrSixtQ0FBbUMsb0NBQW9DLGFBQWEsbUNBQW1DLG1DQUFtQyxpQ0FBaUMsb0JBQW9CLHVCQUF1Qix1QkFBdUIsdUJBQXVCLHVCQUF1Qix1QkFBdUIsNEJBQTRCLEdBQUcsdUJBQXVCLCtCQUErQiw0Q0FBNEMsZ0JBQWdCLGFBQWEsc0NBQXNDLFNBQVMsc0RBQXNELCtCQUErQixjQUFjLG1CQUFtQixpQ0FBaUMsd0hBQXdILGdDQUFnQyx5Q0FBeUMsOEJBQThCLEdBQUcsTUFBTSxTQUFTLDBIQUEwSCwwREFBMEQsK0JBQStCLFNBQVMsc0dBQXNHLEVBQUUsR0FBRyw4RkFBOEYsK0JBQStCLFNBQVMsNkhBQTZILEVBQUUsR0FBRywwQ0FBMEMsbUNBQW1DLE1BQU0sc0lBQXNJLGFBQWEsZ1JBQWdSLDJCQUEyQixzQkFBc0IsYUFBYSxtRUFBbUUsa0JBQWtCLDJDQUEyQyw4REFBOEQsNkJBQTZCLGFBQWEsK0JBQStCLG1CQUFtQiw0QkFBNEIsZ0VBQWdFLG1DQUFtQyxzQkFBc0IsRUFBRSxlQUFlLFlBQVkseUNBQXlDLDRCQUE0QixTQUFTLDZGQUE2RixpQkFBaUIsc0NBQXNDLFNBQVMsK0NBQStDLHVDQUF1QyxjQUFjLFFBQVEsS0FBSyxtQkFBbUIsS0FBSyxXQUFXLDhDQUE4QyxpQkFBaUIsNk1BQTZNLHlCQUF5QixvQ0FBb0Msc1JBQXNSLCtCQUErQix3R0FBd0cseUJBQXlCLGdCQUFnQiw4QkFBOEIsd0JBQXdCLG1GQUFtRix5QkFBeUIsZ0JBQWdCLG9OQUFvTix5QkFBeUIsZ0JBQWdCLDhEQUE4RCwrQ0FBK0MsNkxBQTZMLHFCQUFxQixTQUFTLG1CQUFtQixnQkFBZ0Isb0VBQW9FLG9CQUFvQix3REFBd0Qsd0JBQXdCLHlEQUF5RCx5QkFBeUIsZ0JBQWdCLDZLQUE2SyxtQkFBbUIsb0NBQW9DLGtFQUFrRSxtQkFBbUIsb0NBQW9DLGdFQUFnRSxFQUFFLEdBQUcscUlBQXFJLHNCQUFzQixvQkFBb0IsRUFBRSxHQUFHLFNBQVMsZ0JBQWdCLHdCQUF3Qiw0QkFBNEIsZ0JBQWdCLG1JQUFtSSxPQUFPLGlFQUFpRSxhQUFhLGdCQUFnQiwrQkFBK0IsU0FBUyxVQUFVLHVCQUF1QixxQ0FBcUMsTUFBTSx1Q0FBdUMsTUFBTSwrQ0FBK0MsTUFBTSx1RUFBdUUsTUFBTSx1Q0FBdUMsTUFBTSxpREFBaUQsTUFBTSxrQ0FBa0MsZUFBZSxFQUFFLG9CQUFvQixpQkFBaUIseUJBQXlCLGlCQUFpQix5QkFBeUIsb0JBQW9CLGtFQUFrRSxVQUFVLGtMQUFrTCw2Q0FBNkMsb0RBQW9ELDZDQUE2QyxFQUFFLElBQUksc0JBQXNCLGdCQUFnQixZQUFZLDRCQUE0QixtRUFBbUUsVUFBVSx3QkFBd0IsZ0JBQWdCLHNOQUFzTix3QkFBd0IsdUVBQXVFLHFCQUFxQixtQ0FBbUMsc0RBQXNELHFDQUFxQyx1R0FBdUcsb0JBQW9CLG9DQUFvQyx5REFBeUQsU0FBUyx1QkFBdUIsZ0JBQWdCLDhXQUE4Vyx1TkFBdU4sZ0JBQWdCLHFWQUFxViwyQ0FBMkMsb0NBQW9DLDhCQUE4QiwwQ0FBMEMseURBQXlELDhCQUE4Qiw4R0FBOEcseUVBQXlFLDBIQUEwSCxxQkFBcUIscUJBQXFCLDRDQUE0Qyw2Q0FBNkMsa0RBQWtELHVCQUF1QixxQkFBcUIsNENBQTRDLEtBQUssd0NBQXdDLDhEQUE4RCxrREFBa0Qsb0JBQW9CLGdCQUFnQixjQUFjLElBQUksMEVBQTBFLDBDQUEwQyx1UUFBdVEsd0dBQXdHLFlBQVksd0JBQXdCLGlMQUFpTCxRQUFRLCtNQUErTSxhQUFhLDZEQUE2RCwyRUFBMkUsNENBQTRDLDZEQUE2RCxXQUFXLDBIQUEwSCx5REFBeUQsZ0NBQWdDLDBCQUEwQixjQUFjLDBIQUEwSCx5REFBeUQsdUZBQXVGLGFBQWEsa0JBQWtCLFFBQVEsaUZBQWlGLGdCQUFnQix5REFBeUQsYUFBYSxnQ0FBZ0MsMkZBQTJGLDhCQUE4QixrQ0FBa0MseUJBQXlCLGVBQWUsTUFBTSx3REFBd0Qsd0NBQXdDLGdDQUFnQyx5REFBeUQsRUFBRSx5QkFBeUIsbUJBQW1CLHdCQUF3QixzREFBc0QsR0FBRyxZQUFZLGlEQUFpRCxZQUFZLEtBQUssS0FBSyxNQUFNLFlBQVkscUJBQXFCLElBQUksNkNBQTZDLHlCQUF5Qix1QkFBdUIsdUJBQXVCLDRHQUE0RyxnQkFBZ0IsYUFBYSxzQ0FBc0MsU0FBUyx5QkFBeUIsZ0JBQWdCLFFBQVEsaUJBQWlCLHVCQUF1QixzQkFBc0IsbUJBQW1CLGdEQUFnRCxjQUFjLCtEQUErRCw4QkFBOEIsa0ZBQWtGLGlHQUFpRyxTQUFTLGdHQUFnRyxLQUFLLE1BQU0seUJBQXlCLEdBQUcsR0FBRyxRQUFRLHVEQUF1RCxtQkFBbUIsd0VBQXdFLGFBQWEsa0VBQWtFLHlIQUF5SCxVQUFVLFlBQVksU0FBUyxHQUFHLG1CQUFtQixhQUFhLGtCQUFrQixHQUFHLGdGQUFnRixRQUFRLEtBQUssV0FBVyxFQUFFLHdFQUF3RSw0RUFBNEUsT0FBTyxHQUFHLFVBQVUseUNBQXlDLGFBQWEsR0FBRyxrQkFBa0IsaUJBQWlCLEtBQUssT0FBTyxHQUFHLGlCQUFpQixnQkFBZ0IsSUFBSSw2RkFBNkYsMkdBQTJHLG1CQUFtQiwwQkFBMEIsOENBQThDLEVBQUUsMEJBQTBCLFlBQVksR0FBRyxrQkFBa0IsR0FBRyxnQkFBZ0IsbUJBQW1CLDBCQUEwQix3QkFBd0IsYUFBYSxTQUFTLDZDQUE2QyxLQUFLLE1BQU0sYUFBYSxnQkFBZ0IsV0FBVyxZQUFZLHVDQUF1QyxLQUFLLDJEQUEyRCxrREFBa0QsRUFBRSx3QkFBd0IseUNBQXlDLGtGQUFrRixLQUFLLGdCQUFnQixhQUFhLHNDQUFzQyxTQUFTLGlCQUFpQix3REFBd0QscUNBQXFDLFNBQVMsd0JBQXdCLFFBQVEsZUFBZSx5SUFBeUksV0FBVyxrQkFBa0IsU0FBUyxpQkFBaUIsUUFBUSxpQkFBaUIsZ1VBQWdVLFFBQVEsaUJBQWlCLDRDQUE0QyxnRUFBZ0Usa0JBQWtCLDZCQUE2QixnQkFBZ0IsMkJBQTJCLG1CQUFtQiw4QkFBOEIsaUJBQWlCLDRCQUE0QixZQUFZLHFCQUFxQixXQUFXLG1CQUFtQixjQUFjLG1FQUFtRSxLQUFLLCtFQUErRSxpQ0FBaUMsNEJBQTRCLGdCQUFnQixrSUFBa0ksZ0JBQWdCLG1FQUFtRSxXQUFXLHdCQUF3QiwyREFBMkQsT0FBTyxHQUFHLHVDQUF1QywrQkFBK0IsK0VBQStFLDhCQUE4QixvQkFBb0IsZUFBZSxjQUFjLFFBQVEsT0FBTyw2Q0FBNkMsNERBQTRELDJDQUEyQyx3RUFBd0UsWUFBWSx1QkFBdUIsNEZBQTRGLHFFQUFxRSx5QkFBeUIsNERBQTRELE9BQU8sR0FBRyx1Q0FBdUMsaUZBQWlGLGlFQUFpRSx1QkFBdUIsd0JBQXdCLEtBQUssbUJBQW1CLFNBQVMsR0FBRyxFQUFFLEVBQUUsY0FBYyxTQUFTLE9BQU8sMERBQTBELE9BQU8sR0FBRyxxQ0FBcUMsZ0JBQWdCLFlBQVkscUJBQXFCLEtBQUssbUNBQW1DLHlEQUF5RCxPQUFPLEdBQUcseUJBQXlCLGVBQWUsd0tBQXdLLEVBQUUsR0FBRyxtREFBbUQsa0tBQWtLLDhIQUE4SCwwSEFBMEgsWUFBWSxxQkFBcUIsS0FBSyxtQ0FBbUMsdURBQXVELE9BQU8sR0FBRyx3QkFBd0IsaUJBQWlCLGVBQWUsNERBQTRELHVDQUF1QyxFQUFFLGNBQWMsT0FBTyxHQUFHLCtDQUErQyxTQUFTLDJCQUEyQixVQUFVLGdCQUFnQixrSUFBa0kscUJBQXFCLFlBQVksbUJBQW1CLEtBQUssb0JBQW9CLHNEQUFzRCxFQUFFLEdBQUcsWUFBWSxxQkFBcUIsbUVBQW1FLGNBQWMsOExBQThMLGtJQUFrSSxZQUFZLGdCQUFnQixpRUFBaUUsUUFBUSxPQUFPLE9BQU8sZUFBZSxnQ0FBZ0Msc0JBQXNCLFlBQVkseUJBQXlCLEtBQUssMEJBQTBCLHNCQUFzQixlQUFlLDJHQUEyRyxRQUFRLE9BQU8sT0FBTyxjQUFjLDZDQUE2Qyw0RUFBNEUsWUFBWSx1QkFBdUIsNEZBQTRGLFlBQVksb0JBQW9CLEtBQUsscUJBQXFCLHVEQUF1RCxFQUFFLEdBQUcsb0NBQW9DLHVFQUF1RSxrRUFBa0UsWUFBWSxrQkFBa0IsS0FBSyxtQkFBbUIsZUFBZSxrQkFBa0IsYUFBYSxXQUFXLEdBQUcsRUFBRSxXQUFXLEtBQUsscURBQXFELEVBQUUsR0FBRyx1Q0FBdUMsV0FBVyxZQUFZLHFCQUFxQixLQUFLLG9DQUFvQyxzREFBc0QsRUFBRSxHQUFHLHNGQUFzRixPQUFPLEdBQUcsWUFBWSxxQ0FBcUMsS0FBSyxvQ0FBb0MsZUFBZSx3S0FBd0ssRUFBRSxHQUFHLHFEQUFxRCx5SkFBeUoscUhBQXFILGlJQUFpSSxZQUFZLHFCQUFxQixLQUFLLG9DQUFvQyxtRUFBbUUsT0FBTyxHQUFHLFlBQVksbUJBQW1CLEtBQUssK0JBQStCLHFEQUFxRCxFQUFFLGNBQWMsU0FBUyxHQUFHLGdEQUFnRCxpQkFBaUIsZ0JBQWdCLG1DQUFtQyxrQ0FBa0MsU0FBUyxHQUFHLEdBQUcsb0VBQW9FLEtBQUssV0FBVyxFQUFFLGdCQUFnQixzRkFBc0YseUJBQXlCLCtFQUErRSxnSEFBZ0gsbUJBQW1CLDBEQUEwRCwwQkFBMEIsR0FBRyxLQUFLLGtCQUFrQix5SUFBeUksZ0JBQWdCLFFBQVEsWUFBWSxxQkFBcUIsd0VBQXdFLDBDQUEwQyxvQ0FBb0MsdUNBQXVDLGlGQUFpRiw2Q0FBNkMsMEJBQTBCLGdDQUFnQyxJQUFJLFlBQVksdUJBQXVCLDZFQUE2RSxRQUFRLFNBQVMsOFJBQThSLDBFQUEwRSxrSEFBa0gsdUNBQXVDLGNBQWMsdUJBQXVCLGtDQUFrQyxtQkFBbUIsc0pBQXNKLGlCQUFpQiwwRkFBMEYsbUdBQW1HLHdEQUF3RCwwQ0FBMEMseUVBQXlFLHlDQUF5QyxzR0FBc0csd0RBQXdELHdCQUF3QixRQUFRLDRCQUE0Qix5QkFBeUIsd0ZBQXdGLHNIQUFzSCw2SkFBNkosbUJBQW1CLEtBQUsseUJBQXlCLFFBQVEseUVBQXlFLGdCQUFnQixpQkFBaUIsNkNBQTZDLGtCQUFrQiwwQkFBMEIsaURBQWlELHdDQUF3Qyx1REFBdUQsMEJBQTBCLGdEQUFnRCwyR0FBMkcsU0FBUyx1RUFBdUUsS0FBSywwSEFBMEgsK0lBQStJLDJFQUEyRSxjQUFjLGFBQWEsc0NBQXNDLFNBQVMsbUNBQW1DLFNBQVMscURBQXFELElBQUksZUFBZSxhQUFhLG1CQUFtQixXQUFXLGVBQWUsZUFBZSxFQUFFLHVCQUF1QixFQUFFLEVBQUUsR0FBRyxTQUFTLFVBQVUsMEJBQTBCLFVBQVUsOEJBQThCLDBCQUEwQixVQUFVLHdCQUF3QixVQUFVLGdDQUFnQyxpREFBaUQsRUFBRSxNQUFNLElBQUksa0ZBQWtGLE9BQU8sTUFBTSxvQkFBb0IsMEJBQTBCLDhJQUE4SSxxQkFBcUIsOENBQThDLGtEQUFrRCxLQUFLLGdGQUFnRixXQUFXLE1BQU0sb0JBQW9CLHdCQUF3QixpREFBaUQseUJBQXlCLEdBQUcsRUFBRSxpREFBaUQsYUFBYSxjQUFjLElBQUksV0FBVyxFQUFFLGdCQUFnQixnQkFBZ0IsS0FBSyxnQkFBZ0IsTUFBTSw2T0FBNk8sd0JBQXdCLGlCQUFpQixzQkFBc0IsY0FBYyx5QkFBeUIsaUJBQWlCLHVCQUF1QixlQUFlLHVCQUF1QixlQUFlLDRDQUE0QyxXQUFXLG9EQUFvRCxTQUFTLGNBQWMsUUFBUSx5QkFBeUIsd0ZBQXdGLE1BQU0sOEJBQThCLG1CQUFtQixrRkFBa0Ysd0VBQXdFLFFBQVEscUJBQXFCLDZEQUE2RCxpQkFBaUIsaUJBQWlCLHNHQUFzRyxtQkFBbUIsc0xBQXNMLFFBQVEsd0ZBQXdGLE9BQU8scUJBQXFCLDZDQUE2Qyw4RUFBOEUsZUFBZSwrQ0FBK0MsU0FBUyxZQUFZLGlFQUFpRSxrQkFBa0Isc0JBQXNCLGFBQWEsc0JBQXNCLEdBQUcsR0FBRyxVQUFVLGdCQUFnQiw0REFBNEQsYUFBYSxLQUFLLE9BQU8sS0FBSyxHQUFHLEdBQUcsU0FBUyxhQUFhLGlFQUFpRSxlQUFlLG9CQUFvQix3REFBd0QsdUJBQXVCLGdEQUFnRCxhQUFhLDZCQUE2QixpSUFBaUksV0FBVyxvQkFBb0IsaUlBQWlJLGVBQWUsNkJBQTZCLFdBQVcsS0FBSyxtQ0FBbUMsZUFBZSxPQUFPLE9BQU8scUJBQXFCLEdBQUcsU0FBUyw2SEFBNkgsK0JBQStCLHdGQUF3Riw4RUFBOEUsNkJBQTZCLGNBQWMsc0JBQXNCLHVGQUF1RixnQkFBZ0IsYUFBYSxzQ0FBc0MsU0FBUyxpQkFBaUIsd0RBQXdELHFDQUFxQyxjQUFjLGVBQWUsWUFBWSxVQUFVLHlDQUF5QyxTQUFTLHNCQUFzQiw0QkFBNEIsd0JBQXdCLG9DQUFvQyx3R0FBd0cscUNBQXFDLDJEQUEyRCx3Q0FBd0MsdUJBQXVCLGtHQUFrRywwR0FBMEcsZ0JBQWdCLFlBQVksd0JBQXdCLEtBQUsseUJBQXlCLG1CQUFtQiw4RUFBOEUsRUFBRSxzQ0FBc0MsWUFBWSxtQkFBbUIsYUFBYSxzQkFBc0IsYUFBYSxhQUFhLHNDQUFzQyxTQUFTLDJPQUEyTyxjQUFjLGFBQWEsZ0JBQWdCLG9CQUFvQixzREFBc0Qsc0JBQXNCLDRCQUE0QiwyRUFBMkUsdUNBQXVDLGlDQUFpQyxzQ0FBc0MsU0FBUyw2REFBNkQsa0JBQWtCLHlDQUF5Qyx3R0FBd0csbUJBQW1CLGdEQUFnRCxTQUFTLGlCQUFpQixhQUFhLHFCQUFxQixHQUFHLFVBQVUsZUFBZSxJQUFJLGdCQUFnQixhQUFhLHNDQUFzQyxTQUFTLHVCQUF1QixnQkFBZ0IsUUFBUSxrQ0FBa0MsY0FBYyxNQUFNLGFBQWEsd1VBQXdVLHVDQUF1QyxHQUFHLHNDQUFzQyxpQkFBaUIsZUFBZSxhQUFhLGFBQWEsTUFBTSxhQUFhLG1FQUFtRSxpREFBaUQsR0FBRyxpQkFBaUIsR0FBRyxtQ0FBbUMsR0FBRyxpQ0FBaUMsZUFBZSxhQUFhLGFBQWEsTUFBTSxhQUFhLHNaQUFzWix5Q0FBeUMsR0FBRyxpQkFBaUIsR0FBRyxtQ0FBbUMsR0FBRyxpQ0FBaUMsZUFBZSxhQUFhLGFBQWEsTUFBTSxhQUFhLGtEQUFrRCw2QkFBNkIsR0FBRyxpQkFBaUIsR0FBRyxtQ0FBbUMsR0FBRyxpQ0FBaUMsZUFBZSxhQUFhLGFBQWEsTUFBTSxhQUFhLG9IQUFvSCx1Q0FBdUMsR0FBRyxpQkFBaUIsR0FBRyxtQ0FBbUMsR0FBRyxpQ0FBaUMsZUFBZSxhQUFhLGFBQWEsUUFBUSxjQUFjLDJCQUEyQixZQUFZLG9DQUFvQywyQkFBMkIsa0VBQWtFLHVDQUF1QyxnSUFBZ0ksU0FBUyxzQ0FBc0MsNEhBQTRILFlBQVksc0NBQXNDLCtDQUErQyxxQkFBcUIsaUJBQWlCLG1CQUFtQix3QkFBd0IsNEJBQTRCLDRCQUE0QixxQkFBcUIsS0FBSyxzQkFBc0IscUJBQXFCLDJCQUEyQixxQkFBcUIsbUJBQW1CLHFCQUFxQix3QkFBd0Isb0RBQW9ELFVBQVUsaUJBQWlCLEdBQUcsbUNBQW1DLEdBQUcsaUNBQWlDLGVBQWUsYUFBYSxhQUFhLFFBQVEsY0FBYywyQkFBMkIsWUFBWSxvQ0FBb0MsK0JBQStCLGtFQUFrRSwyQ0FBMkMsZ0lBQWdJLFNBQVMsc0NBQXNDLDJHQUEyRyxjQUFjLHNDQUFzQyxnREFBZ0QseUJBQXlCLGlCQUFpQixxQkFBcUIsd0JBQXdCLDBCQUEwQix3QkFBd0IsdUJBQXVCLHFCQUFxQiw4QkFBOEIsbUZBQW1GLGNBQWMsaUJBQWlCLEdBQUcsbUNBQW1DLEdBQUcsaUNBQWlDLGVBQWUsYUFBYSxhQUFhLFFBQVEsY0FBYywyQkFBMkIsWUFBWSxvQ0FBb0Msb0NBQW9DLGtFQUFrRSxnREFBZ0QsZ0lBQWdJLFVBQVUsc0NBQXNDLHVGQUF1RixXQUFXLHNDQUFzQyxrRUFBa0UsWUFBWSxzQ0FBc0MsZ0RBQWdELDhCQUE4QixpQkFBaUIsdUJBQXVCLGtFQUFrRSx3QkFBd0IsdUNBQXVDLHdCQUF3Qix3QkFBd0IsNEJBQTRCLHFCQUFxQixxQ0FBcUMsZ0hBQWdILG1CQUFtQixpQkFBaUIsR0FBRyxtQ0FBbUMsR0FBRyxpQ0FBaUMsZUFBZSxhQUFhLGFBQWEsUUFBUSxjQUFjLDJCQUEyQixZQUFZLG9DQUFvQyx3Q0FBd0Msa0VBQWtFLG9EQUFvRCxnSUFBZ0ksV0FBVyxzQ0FBc0Msc0ZBQXNGLFNBQVMsc0NBQXNDLGtHQUFrRyxrQ0FBa0MsaUJBQWlCLHdCQUF3QixpRUFBaUUscUJBQXFCLHdCQUF3QixnQ0FBZ0MscUJBQXFCLHVDQUF1QyxtR0FBbUcsdUJBQXVCLGlCQUFpQixHQUFHLG1DQUFtQyxHQUFHLGlDQUFpQyxlQUFlLGFBQWEsYUFBYSxRQUFRLGNBQWMsMkJBQTJCLFlBQVksb0NBQW9DLDZCQUE2QixrRUFBa0UseUNBQXlDLGdJQUFnSSxVQUFVLHNDQUFzQyxzRkFBc0YsYUFBYSxzQ0FBc0MscUdBQXFHLHVCQUF1QixpQkFBaUIsdUJBQXVCLGlFQUFpRSx5QkFBeUIsd0JBQXdCLHFCQUFxQixxQkFBcUIsNEJBQTRCLGdGQUFnRixZQUFZLGlCQUFpQixHQUFHLG1DQUFtQyxHQUFHLGlDQUFpQyxlQUFlLGFBQWEsYUFBYSxRQUFRLGNBQWMsMkJBQTJCLFlBQVksb0NBQW9DLGtDQUFrQyxrRUFBa0UsOENBQThDLGdJQUFnSSxZQUFZLHNDQUFzQyxxR0FBcUcsNEJBQTRCLGlCQUFpQix3QkFBd0Isd0JBQXdCLDBCQUEwQixxQkFBcUIsK0JBQStCLHVFQUF1RSxpQkFBaUIsaUJBQWlCLEdBQUcsbUNBQW1DLEdBQUcsaUNBQWlDLGVBQWUsYUFBYSxpQkFBaUIsaUJBQWlCLGNBQWMsMkJBQTJCLFlBQVksb0NBQW9DLFlBQVksdUNBQXVDLGNBQWMsd0NBQXdDLGNBQWMsd0NBQXdDLDhCQUE4QixpRkFBaUYsbUNBQW1DLEdBQUcsaUNBQWlDLGVBQWUsYUFBYSxhQUFhLFFBQVEsY0FBYywyQkFBMkIsWUFBWSxvQ0FBb0MsOEJBQThCLGtFQUFrRSwwQ0FBMEMsZ0lBQWdJLFlBQVksc0NBQXNDLDZDQUE2QyxnQkFBZ0Isc0NBQXNDLHVHQUF1RyxtQkFBbUIsc0NBQXNDLCtDQUErQyxpQkFBaUIsc0NBQXNDLHVHQUF1RyxvQkFBb0Isc0NBQXNDLCtDQUErQyx3QkFBd0IsaUJBQWlCLHlCQUF5Qix1QkFBdUIsMEJBQTBCLHdCQUF3QixrQ0FBa0Msc0JBQXNCLDJCQUEyQix3QkFBd0IsbUNBQW1DLHNCQUFzQixzQkFBc0IscUJBQXFCLCtCQUErQiwyR0FBMkcsYUFBYSxpQkFBaUIsR0FBRyxtQ0FBbUMsR0FBRyxpQ0FBaUMsZUFBZSxhQUFhLGFBQWEsUUFBUSxjQUFjLDJCQUEyQixZQUFZLG9DQUFvQywwQkFBMEIsa0VBQWtFLHNDQUFzQyxnSUFBZ0ksUUFBUSxzQ0FBc0MsZ0RBQWdELGFBQWEsc0NBQXNDLGdEQUFnRCxVQUFVLHNDQUFzQyxnREFBZ0QsZUFBZSx1Q0FBdUMsNENBQTRDLFFBQVEsdUNBQXVDLDZDQUE2QyxVQUFVLHVDQUF1QyxnREFBZ0QsT0FBTyx1Q0FBdUMsZ0ZBQWdGLHlCQUF5Qix1Q0FBdUMsZ0RBQWdELFlBQVksdUNBQXVDLHNFQUFzRSxlQUFlLHVDQUF1QywrQ0FBK0MsYUFBYSx1Q0FBdUMsc0VBQXNFLGdCQUFnQix1Q0FBdUMsK0NBQStDLGdCQUFnQix1Q0FBdUMsNEhBQTRILG1CQUFtQix1Q0FBdUMsK0NBQStDLGtCQUFrQix1Q0FBdUMsa0VBQWtFLHVCQUF1Qix1Q0FBdUMsK0NBQStDLHNCQUFzQix1Q0FBdUMsb0pBQW9KLG9CQUFvQix1Q0FBdUMsc0VBQXNFLHVCQUF1Qix1Q0FBdUMsK0NBQStDLG9CQUFvQixrQkFBa0Isb0JBQW9CLHdCQUF3Qix5QkFBeUIsd0JBQXdCLHNCQUFzQix3QkFBd0IsNEJBQTRCLHVCQUF1QixxQkFBcUIsdUJBQXVCLHNCQUFzQix3QkFBd0Isb0JBQW9CLDJEQUEyRCxxQ0FBcUMsd0JBQXdCLHNCQUFzQix3QkFBd0IsK0JBQStCLDRCQUE0QixxQkFBcUIsS0FBSyxzQkFBc0IscUJBQXFCLDhCQUE4QixxQkFBcUIsdUJBQXVCLHdCQUF3QixnQ0FBZ0MsNEJBQTRCLHFCQUFxQixLQUFLLHNCQUFzQixxQkFBcUIsK0JBQStCLHFCQUFxQiwwQkFBMEIseUJBQXlCLG1DQUFtQyw0QkFBNEIscUJBQXFCLEtBQUssc0JBQXNCLHFCQUFxQixrQ0FBa0MscUJBQXFCLDhCQUE4Qix5QkFBeUIsdUNBQXVDLDRCQUE0QixxQkFBcUIsS0FBSyxxQkFBcUIscUJBQXFCLHNDQUFzQyxxQkFBcUIsOEJBQThCLHlCQUF5Qix1Q0FBdUMsNEJBQTRCLHFCQUFxQixLQUFLLHNCQUFzQixxQkFBcUIsc0NBQXNDLHFCQUFxQixrQkFBa0IscUJBQXFCLCtDQUErQyx5U0FBeVMsU0FBUyxpQkFBaUIsR0FBRyxtQ0FBbUMsR0FBRyxpQ0FBaUMsZUFBZSxhQUFhLGFBQWEsUUFBUSxjQUFjLDJCQUEyQixZQUFZLG9DQUFvQywrQkFBK0Isa0VBQWtFLDJDQUEyQyxnSUFBZ0ksUUFBUSxzQ0FBc0MsZ0RBQWdELGFBQWEsc0NBQXNDLGdEQUFnRCxRQUFRLHNDQUFzQyxxR0FBcUcseUJBQXlCLGlCQUFpQixvQkFBb0Isd0JBQXdCLHlCQUF5Qix3QkFBd0Isb0JBQW9CLHdCQUF3Qix1QkFBdUIscUJBQXFCLGdDQUFnQyxnR0FBZ0csY0FBYyxpQkFBaUIsR0FBRyxtQ0FBbUMsR0FBRyxpQ0FBaUMsZUFBZSxhQUFhLGFBQWEsUUFBUSxjQUFjLDJCQUEyQixZQUFZLG9DQUFvQyw4QkFBOEIsa0VBQWtFLDBDQUEwQyxnSUFBZ0ksY0FBYyxzQ0FBc0MsZ0RBQWdELFlBQVksc0NBQXNDLGdGQUFnRixTQUFTLHNDQUFzQywrQ0FBK0Msd0JBQXdCLGlCQUFpQiwwQkFBMEIsd0JBQXdCLHlCQUF5QiwwREFBMEQscUJBQXFCLHdCQUF3QixzQkFBc0IscUJBQXFCLCtCQUErQixxR0FBcUcsYUFBYSxpQkFBaUIsR0FBRyxtQ0FBbUMsR0FBRyxpQ0FBaUMsZUFBZSxhQUFhLGFBQWEsUUFBUSxjQUFjLDJCQUEyQixZQUFZLG9DQUFvQyxtQ0FBbUMsa0VBQWtFLCtDQUErQyxnSUFBZ0ksVUFBVSxzQ0FBc0MsZ0RBQWdELFVBQVUsc0NBQXNDLGtFQUFrRSw2QkFBNkIsaUJBQWlCLHNCQUFzQix3QkFBd0IsdUJBQXVCLHVDQUF1QywyQkFBMkIscUJBQXFCLGtDQUFrQyx5RkFBeUYsa0JBQWtCLGlCQUFpQixHQUFHLG1DQUFtQyxHQUFHLGlDQUFpQyxlQUFlLGFBQWEsYUFBYSxRQUFRLGNBQWMsMkJBQTJCLFlBQVksb0NBQW9DLDRCQUE0QixrRUFBa0Usd0NBQXdDLGdJQUFnSSxRQUFRLHNDQUFzQyxnREFBZ0QsYUFBYSxzQ0FBc0MsZ0RBQWdELFFBQVEsc0NBQXNDLHdGQUF3RixhQUFhLHNDQUFzQywrQ0FBK0MsV0FBVyx1Q0FBdUMsc0ZBQXNGLFdBQVcsdUNBQXVDLGdFQUFnRSxnQkFBZ0IsdUNBQXVDLCtDQUErQyxlQUFlLHVDQUF1QyxvSkFBb0osZ0JBQWdCLHVDQUF1QyxzRUFBc0UsbUJBQW1CLHVDQUF1QywrQ0FBK0Msc0JBQXNCLGlCQUFpQixvQkFBb0Isd0JBQXdCLHlCQUF5Qix3QkFBd0Isb0JBQW9CLHdCQUF3Qiw2QkFBNkIsNEJBQTRCLHFCQUFxQixLQUFLLHFCQUFxQixxQkFBcUIsNEJBQTRCLHFCQUFxQix3QkFBd0IsaUVBQWlFLHVCQUF1Qix3QkFBd0IsZ0NBQWdDLDRCQUE0QixxQkFBcUIsS0FBSyxvQkFBb0IscUJBQXFCLCtCQUErQixxQkFBcUIsMEJBQTBCLHdCQUF3QixtQ0FBbUMsNEJBQTRCLHFCQUFxQixLQUFLLHNCQUFzQixxQkFBcUIsa0NBQWtDLHFCQUFxQixvQkFBb0IscUJBQXFCLG1DQUFtQyxvSkFBb0osV0FBVyxpQkFBaUIsR0FBRyxtQ0FBbUMsR0FBRyxpQ0FBaUMsZUFBZSxhQUFhLGFBQWEsUUFBUSxjQUFjLDJCQUEyQixZQUFZLG9DQUFvQyxrQ0FBa0Msa0VBQWtFLDhDQUE4QyxnSUFBZ0ksVUFBVSxzQ0FBc0MsbUdBQW1HLFdBQVcsc0NBQXNDLG1HQUFtRyxRQUFRLHNDQUFzQyx3RkFBd0YsYUFBYSxzQ0FBc0MsK0NBQStDLDRCQUE0QixpQkFBaUIsc0JBQXNCLHdCQUF3Qix1QkFBdUIsd0JBQXdCLG9CQUFvQix3QkFBd0IsNkJBQTZCLDRCQUE0QixxQkFBcUIsS0FBSyxxQkFBcUIscUJBQXFCLDRCQUE0QixxQkFBcUIsMEJBQTBCLHFCQUFxQixtQ0FBbUMsc0dBQXNHLGlCQUFpQixpQkFBaUIsR0FBRyxtQ0FBbUMsR0FBRyxpQ0FBaUMsZUFBZSxhQUFhLGFBQWEsUUFBUSxjQUFjLDJCQUEyQixZQUFZLG9DQUFvQywrQkFBK0Isa0VBQWtFLDJDQUEyQyxnSUFBZ0ksUUFBUSxzQ0FBc0MsZ0RBQWdELGFBQWEsc0NBQXNDLGdEQUFnRCxPQUFPLHNDQUFzQyxxRkFBcUYsSUFBSSx1Q0FBdUMsOENBQThDLElBQUksdUNBQXVDLGtFQUFrRSxLQUFLLHVDQUF1QyxnREFBZ0QsS0FBSyx1Q0FBdUMsbUdBQW1HLEtBQUssdUNBQXVDLGtHQUFrRyxVQUFVLHVDQUF1QyxvRUFBb0UsZUFBZSx1Q0FBdUMsK0NBQStDLGNBQWMsdUNBQXVDLHNKQUFzSixRQUFRLHVDQUF1Qyx3RkFBd0YsYUFBYSx1Q0FBdUMsK0NBQStDLGFBQWEsdUNBQXVDLHNFQUFzRSxnQkFBZ0IsdUNBQXVDLCtDQUErQyxhQUFhLHVDQUF1Qyx5SEFBeUgsZ0JBQWdCLHVDQUF1QywrQ0FBK0MsWUFBWSx1Q0FBdUMsd0hBQXdILGVBQWUsdUNBQXVDLCtDQUErQyx5QkFBeUIsa0JBQWtCLG9CQUFvQix3QkFBd0IseUJBQXlCLHdCQUF3QixvQkFBb0IsZ0VBQWdFLGlCQUFpQix5QkFBeUIsaUJBQWlCLHVDQUF1QyxpQkFBaUIsd0JBQXdCLGlCQUFpQix3QkFBd0IsaUJBQWlCLHdCQUF3QixzQkFBc0Isd0JBQXdCLCtCQUErQiw0QkFBNEIscUJBQXFCLEtBQUssdUJBQXVCLHFCQUFxQiw4QkFBOEIscUJBQXFCLG9CQUFvQix3QkFBd0IsNkJBQTZCLDRCQUE0QixxQkFBcUIsS0FBSyxxQkFBcUIscUJBQXFCLDRCQUE0QixxQkFBcUIsdUJBQXVCLHlCQUF5QixnQ0FBZ0MsNEJBQTRCLHFCQUFxQixLQUFLLHNCQUFzQixxQkFBcUIsK0JBQStCLHFCQUFxQix1QkFBdUIseUJBQXlCLGdDQUFnQyw0QkFBNEIscUJBQXFCLEtBQUssc0JBQXNCLHFCQUFxQiwrQkFBK0IscUJBQXFCLHNCQUFzQix5QkFBeUIsK0JBQStCLDRCQUE0QixxQkFBcUIsS0FBSyxzQkFBc0IscUJBQXFCLDhCQUE4QixxQkFBcUIsdUJBQXVCLHFCQUFxQixvREFBb0QsaVBBQWlQLGNBQWMsaUJBQWlCLEdBQUcsbUNBQW1DLEdBQUcsaUNBQWlDLGVBQWUsYUFBYSxhQUFhLFFBQVEsY0FBYywyQkFBMkIsWUFBWSxvQ0FBb0MsMkJBQTJCLGtFQUFrRSx1Q0FBdUMsZ0lBQWdJLGtCQUFrQixzQ0FBc0MseUhBQXlILHFCQUFxQixzQ0FBc0MsK0NBQStDLGNBQWMsc0NBQXNDLDRIQUE0SCxpQkFBaUIsc0NBQXNDLCtDQUErQyxXQUFXLHNDQUFzQyx1SEFBdUgsY0FBYyxzQ0FBc0MsK0NBQStDLGVBQWUsdUNBQXVDLDZDQUE2QyxlQUFlLHVDQUF1QywySEFBMkgsa0JBQWtCLHVDQUF1QywrQ0FBK0MsWUFBWSx1Q0FBdUMsc0VBQXNFLGVBQWUsdUNBQXVDLCtDQUErQyxhQUFhLHVDQUF1QyxzRUFBc0UsZ0JBQWdCLHVDQUF1QywrQ0FBK0Msd0JBQXdCLHVDQUF1QywrSEFBK0gsMkJBQTJCLHVDQUF1QywrQ0FBK0MscUJBQXFCLGlCQUFpQiw0QkFBNEIsd0JBQXdCLHFDQUFxQyw0QkFBNEIscUJBQXFCLEtBQUssc0JBQXNCLHFCQUFxQixvQ0FBb0MscUJBQXFCLHdCQUF3Qix3QkFBd0IsaUNBQWlDLDRCQUE0QixxQkFBcUIsS0FBSyxzQkFBc0IscUJBQXFCLGdDQUFnQyxxQkFBcUIscUJBQXFCLHdCQUF3Qiw4QkFBOEIsNEJBQTRCLHFCQUFxQixLQUFLLHNCQUFzQixxQkFBcUIsNkJBQTZCLHFCQUFxQiw0QkFBNEIsdUJBQXVCLHlCQUF5Qix3QkFBd0Isa0NBQWtDLDRCQUE0QixxQkFBcUIsS0FBSyxzQkFBc0IscUJBQXFCLGlDQUFpQyxxQkFBcUIsc0JBQXNCLHdCQUF3QiwrQkFBK0IsNEJBQTRCLHFCQUFxQixLQUFLLHNCQUFzQixxQkFBcUIsOEJBQThCLHFCQUFxQix1QkFBdUIsd0JBQXdCLGdDQUFnQyw0QkFBNEIscUJBQXFCLEtBQUssc0JBQXNCLHFCQUFxQiwrQkFBK0IscUJBQXFCLGtDQUFrQyx3QkFBd0IsMkNBQTJDLDRCQUE0QixxQkFBcUIsS0FBSyxzQkFBc0IscUJBQXFCLDBDQUEwQyxxQkFBcUIsbUJBQW1CLHFCQUFxQixzQ0FBc0MsMk1BQTJNLFVBQVUsaUJBQWlCLEdBQUcsbUNBQW1DLEdBQUcsaUNBQWlDLGVBQWUsYUFBYSxhQUFhLFFBQVEsY0FBYywyQkFBMkIsWUFBWSxvQ0FBb0MsMkJBQTJCLGtFQUFrRSx1Q0FBdUMsZ0lBQWdJLFlBQVksc0NBQXNDLGtFQUFrRSxpQkFBaUIsc0NBQXNDLGdJQUFnSSxvQkFBb0Isc0NBQXNDLCtDQUErQyxnQkFBZ0Isc0NBQXNDLGdEQUFnRCxtQkFBbUIsdUNBQXVDLGdEQUFnRCxVQUFVLHVDQUF1QyxnREFBZ0QsZUFBZSx1Q0FBdUMsa0VBQWtFLGFBQWEsdUNBQXVDLGdEQUFnRCxTQUFTLHVDQUF1QyxrR0FBa0csa0JBQWtCLHVDQUF1QyxnREFBZ0QscUJBQXFCLGlCQUFpQix5QkFBeUIsdUNBQXVDLDJCQUEyQix3QkFBd0Isb0NBQW9DLDRCQUE0QixxQkFBcUIsS0FBSyxzQkFBc0IscUJBQXFCLG1DQUFtQyxxQkFBcUIsNEJBQTRCLHdCQUF3QiwrQkFBK0Isd0JBQXdCLHNCQUFzQix3QkFBd0IsNEJBQTRCLHVDQUF1Qyx5QkFBeUIsd0JBQXdCLHFCQUFxQix3QkFBd0IsOEJBQThCLHdCQUF3QixtQkFBbUIscUJBQXFCLHdDQUF3QyxzT0FBc08sVUFBVSxpQkFBaUIsR0FBRyxtQ0FBbUMsR0FBRyxpQ0FBaUMsZUFBZSxhQUFhLGFBQWEsUUFBUSxjQUFjLDJCQUEyQixZQUFZLG9DQUFvQyx1Q0FBdUMsa0VBQWtFLG1EQUFtRCxnSUFBZ0ksZUFBZSxzQ0FBc0MsbUVBQW1FLG9CQUFvQixzQ0FBc0MsK0NBQStDLG1CQUFtQixzQ0FBc0MscUpBQXFKLG1CQUFtQixzQ0FBc0MseUZBQXlGLHdCQUF3QixzQ0FBc0MsK0NBQStDLGlDQUFpQyxpQkFBaUIsMkJBQTJCLHdCQUF3QixvQ0FBb0MsNEJBQTRCLHFCQUFxQixLQUFLLHFCQUFxQixxQkFBcUIsbUNBQW1DLHFCQUFxQiwrQkFBK0Isd0JBQXdCLHdDQUF3Qyw0QkFBNEIscUJBQXFCLEtBQUsscUJBQXFCLHFCQUFxQix1Q0FBdUMscUJBQXFCLCtCQUErQixxQkFBcUIsc0NBQXNDLDhHQUE4RyxzQkFBc0IsaUJBQWlCLEdBQUcsbUNBQW1DLEdBQUcsaUNBQWlDLGVBQWUsYUFBYSxhQUFhLFFBQVEsY0FBYywyQkFBMkIsWUFBWSxvQ0FBb0MsMENBQTBDLGtFQUFrRSxzREFBc0QsZ0lBQWdJLFdBQVcsc0NBQXNDLGdEQUFnRCxnQkFBZ0Isc0NBQXNDLHlHQUF5RyxvQ0FBb0MsaUJBQWlCLHVCQUF1Qix3QkFBd0IsNEJBQTRCLHdCQUF3QixrQ0FBa0Msb0JBQW9CLDhCQUE4Qix5Q0FBeUMsNkdBQTZHLHlCQUF5QixpQkFBaUIsR0FBRyxtQ0FBbUMsR0FBRyxpQ0FBaUMsZUFBZSxhQUFhLGFBQWEsUUFBUSxjQUFjLDJCQUEyQixZQUFZLG9DQUFvQyxrQ0FBa0Msa0VBQWtFLDhDQUE4QyxnSUFBZ0ksV0FBVyxzQ0FBc0MsOEdBQThHLDJCQUEyQixzQ0FBc0MsdUlBQXVJLDhCQUE4QixzQ0FBc0MsK0NBQStDLDRCQUE0QixpQkFBaUIsdUJBQXVCLHdCQUF3QixxQ0FBcUMsd0JBQXdCLDhDQUE4Qyw0QkFBNEIscUJBQXFCLEtBQUssc0JBQXNCLHFCQUFxQiw2Q0FBNkMscUJBQXFCLDBCQUEwQixxQkFBcUIsaUNBQWlDLHNHQUFzRyxpQkFBaUIsaUJBQWlCLEdBQUcsbUNBQW1DLEdBQUcsaUNBQWlDLGVBQWUsYUFBYSxhQUFhLFFBQVEsY0FBYywyQkFBMkIsWUFBWSxvQ0FBb0Msc0NBQXNDLGtFQUFrRSxrREFBa0QsZ0lBQWdJLDhCQUE4QixrQ0FBa0MsY0FBYyxzQ0FBc0MsZ0RBQWdELFNBQVMsc0NBQXNDLGtHQUFrRyxnQkFBZ0Isc0NBQXNDLHlHQUF5RyxnQ0FBZ0MsaUJBQWlCLDBCQUEwQix3QkFBd0IscUJBQXFCLHdCQUF3Qiw0QkFBNEIsd0JBQXdCLDhCQUE4QixxQkFBcUIseUNBQXlDLG1CQUFtQixxREFBcUQsc0JBQXNCLHVDQUF1Qyx3SEFBd0gscUJBQXFCLGlCQUFpQixHQUFHLG1DQUFtQyxHQUFHLGlDQUFpQyxHQUFHLGdCQUFnQixhQUFhLHNDQUFzQyxTQUFTLGdDQUFnQywwQkFBMEIsNkJBQTZCLGVBQWUsaUdBQWlHLGlCQUFpQixpQkFBaUIsZ0JBQWdCLHFEQUFxRCxhQUFhLDBEQUEwRCx1Q0FBdUMsMEJBQTBCLHdDQUF3QyxLQUFLLGlCQUFpQiw4QkFBOEIsZUFBZSw4QkFBOEIsZ0JBQWdCLGFBQWEsc0NBQXNDLFNBQVMsbUJBQW1CLGtFQUFrRSxnQkFBZ0IsZ0JBQWdCLEVBQUUsOEdBQThHLDZEQUE2RCxpQkFBaUIseUNBQXlDLGtCQUFrQiwwQ0FBMEMsaUJBQWlCLHNCQUFzQixlQUFlLHFCQUFxQix1QkFBdUIsbUVBQW1FLG9EQUFvRCx3R0FBd0csMkJBQTJCLDhCQUE4Qiw0Q0FBNEMscUJBQXFCLEtBQUssK0NBQStDLHNDQUFzQyxpREFBaUQsS0FBSywrQ0FBK0Msb0JBQW9CLEdBQUcsZ0JBQWdCLDREQUE0RCx5REFBeUQsc0VBQXNFLG1QQUFtUCx3QkFBd0IsYUFBYSxxRUFBcUUsOERBQThELHNHQUFzRyw0QkFBNEIsR0FBRyw4QkFBOEIsMENBQTBDLHFCQUFxQixpRkFBaUYsVUFBVSxVQUFVLFNBQVMsR0FBRyxLQUFLLDJFQUEyRSxVQUFVLFVBQVUsT0FBTyxHQUFHLDBCQUEwQixRQUFRLFlBQVksV0FBVyxLQUFLLG9CQUFvQixvREFBb0QsS0FBSyxJQUFJLFNBQVMsSUFBSSw2TUFBNk0sS0FBSyxrR0FBa0csWUFBWSxXQUFXLEtBQUssZ0JBQWdCLHdIQUF3SCxxQ0FBcUMsdUVBQXVFLDhCQUE4QixZQUFZLFdBQVcsS0FBSyx5QkFBeUIseUNBQXlDLEVBQUUsaUNBQWlDLEVBQUUsWUFBWSxFQUFFLElBQUksK0JBQStCLFlBQVksV0FBVyxLQUFLLHlCQUF5QixrRUFBa0UsRUFBRSxtQ0FBbUMsWUFBWSxjQUFjLFlBQVksS0FBSyx5QkFBeUIsZ0NBQWdDLFlBQVksV0FBVyw0Q0FBNEMsU0FBUyxnQkFBZ0IsMkNBQTJDLDhHQUE4RyxnQkFBZ0IsWUFBWSxXQUFXLHFCQUFxQixTQUFTLGlCQUFpQixxQkFBcUIsOEJBQThCLFlBQVksV0FBVywwRUFBMEUsc0JBQXNCLGFBQWEsOENBQThDLDBCQUEwQixZQUFZLHNDQUFzQyxTQUFTLGtCQUFrQiwyREFBMkQscUNBQXFDLFFBQVEsV0FBVyx3QkFBd0IsdUNBQXVDLHNJQUFzSSxhQUFhLGtCQUFrQixpQkFBaUIsdUVBQXVFLGlCQUFpQixrQkFBa0Isa0JBQWtCLHFHQUFxRywyR0FBMkcsZ0JBQWdCLGtCQUFrQiw2Q0FBNkMsMEVBQTBFLGlCQUFpQix5Q0FBeUMsMERBQTBELE9BQU8sOERBQThELFNBQVMseURBQXlELGdCQUFnQiw4RkFBOEYsY0FBYywwRkFBMEYseUNBQXlDLGlKQUFpSix1REFBdUQsMEZBQTBGLGlCQUFpQiwySEFBMkgsNkJBQTZCLEtBQUssZUFBZSxhQUFhLGlFQUFpRSxPQUFPLEdBQUcsTUFBTSxzQ0FBc0MsVUFBVSwyQ0FBMkMsa0NBQWtDLGdEQUFnRCx1QkFBdUIsNkRBQTZELEVBQUUsSUFBSSxLQUFLLHlCQUF5QixvQkFBb0IsUUFBUSxvQkFBb0IscUVBQXFFLCtHQUErRyw4Q0FBOEMsb0NBQW9DLEdBQUcsa0ZBQWtGLG1JQUFtSSxzRUFBc0UsMERBQTBELFlBQVksSUFBSSxLQUFLLDRCQUE0QixRQUFRLEtBQUssTUFBTSxtQkFBbUIscURBQXFELE1BQU0sdVBBQXVQLE1BQU0scURBQXFELE1BQU0sdURBQXVELE1BQU0sK0ZBQStGLE1BQU0sNENBQTRDLCtFQUErRSxlQUFlLGdFQUFnRSxZQUFZLFdBQVcsS0FBSyxhQUFhLGlEQUFpRCxTQUFTLHVCQUF1QixrQ0FBa0Msd0JBQXdCLHFFQUFxRSxnSEFBZ0gsNEJBQTRCLHVCQUF1Qiw4QkFBOEIsbUZBQW1GLDZJQUE2SSxtRUFBbUUsMERBQTBELFlBQVksSUFBSSxLQUFLLDhCQUE4QixRQUFRLFVBQVUsY0FBYyxVQUFVLDRIQUE0SCx3RkFBd0YsK0hBQStILGdJQUFnSSw2REFBNkQsK0JBQStCLElBQUksY0FBYyxVQUFVLHlDQUF5Qyw0QkFBNEIsOEJBQThCLGdDQUFnQyw4QkFBOEIsZ0NBQWdDLGtDQUFrQyxrQ0FBa0MsOENBQThDLGdCQUFnQixzRUFBc0UsMkdBQTJHLEtBQUssb0xBQW9MLCtCQUErQixHQUFHLGtHQUFrRyxvQkFBb0Isa0JBQWtCLFVBQVUsa0dBQWtHLDBEQUEwRCxpRUFBaUUsK0RBQStELGlFQUFpRSwrREFBK0QsaUVBQWlFLGdIQUFnSCxrRUFBa0UsaUhBQWlILDhEQUE4RCwrQkFBK0IsSUFBSSxXQUFXLHNCQUFzQixhQUFhLDhDQUE4QywwQkFBMEIsWUFBWSxzQ0FBc0MsU0FBUywwT0FBME8saURBQWlELG9DQUFvQyxvQ0FBb0MsWUFBWSxXQUFXLG9EQUFvRCxTQUFTLHdCQUF3QixnREFBZ0QsbUJBQW1CLHdCQUF3QixnQ0FBZ0MsWUFBWSxXQUFXLDRCQUE0QixXQUFXLFFBQVEsa0NBQWtDLHdEQUF3RCxxQ0FBcUMsNkNBQTZDLDRCQUE0Qix1Q0FBdUMsZUFBZSxRQUFRLDJCQUEyQiw0QkFBNEIsa0JBQWtCLGtCQUFrQixtREFBbUQsTUFBTSxtQkFBbUIsMkRBQTJELHFCQUFxQixrQkFBa0IsZ0JBQWdCLEtBQUssS0FBSyx3Q0FBd0MsMEJBQTBCLHFCQUFxQixTQUFTLGtCQUFrQiw0QkFBNEIsNEJBQTRCLHdCQUF3QiwwQkFBMEIsWUFBWSxXQUFXLHFCQUFxQix1QkFBdUIsbUNBQW1DLE1BQU0sbUNBQW1DLGtEQUFrRCxpREFBaUQsS0FBSyxrRkFBa0Ysd0JBQXdCLDRFQUE0RSxZQUFZLElBQUksS0FBSyxJQUFJLHFCQUFxQixLQUFLLHFDQUFxQyxpR0FBaUcsVUFBVSw2QkFBNkIsNEJBQTRCLGdCQUFnQixZQUFZLEtBQUssNENBQTRDLFNBQVMsNkJBQTZCLHNCQUFzQixZQUFZLElBQUksS0FBSyx3QkFBd0IsNENBQTRDLFVBQVUsd0RBQXdELGlFQUFpRSxpRUFBaUUsa0ZBQWtGLDRFQUE0RSxZQUFZLElBQUksa0JBQWtCLGtCQUFrQix1Q0FBdUMsNEVBQTRFLFVBQVUsa0NBQWtDLFNBQVMsOEVBQThFLCtEQUErRCw2RkFBNkYsZ0JBQWdCLFFBQVEsa0NBQWtDLFVBQVUsbURBQW1ELHFEQUFxRCxtREFBbUQscURBQXFELHVEQUF1RCxxREFBcUQsdURBQXVELHVEQUF1RCx3REFBd0QsdURBQXVELHFEQUFxRCx1REFBdUQsa0RBQWtELCtCQUErQixJQUFJLHFDQUFxQyxVQUFVLG1EQUFtRCxxREFBcUQsbURBQW1ELHFEQUFxRCx1REFBdUQscURBQXFELHVEQUF1RCx1REFBdUQsd0RBQXdELHVEQUF1RCxxREFBcUQsdURBQXVELGtEQUFrRCxFQUFFLElBQUksOEJBQThCLHNEQUFzRCxtQ0FBbUMsT0FBTyx3REFBd0QsK0RBQStELGtDQUFrQyxXQUFXLFlBQVksaUJBQWlCLHNDQUFzQyxTQUFTLHdDQUF3QyxXQUFXLFlBQVksdUJBQXVCLDRCQUE0QixVQUFVLGNBQWMsUUFBUSx5QkFBeUIsNkZBQTZGLDBDQUEwQyxlQUFlLGlCQUFpQiw2REFBNkQsYUFBYSxRQUFRLGVBQWUsaURBQWlELDhCQUE4QiwyREFBMkQsR0FBRyxzQ0FBc0MsVUFBVSxjQUFjLGlEQUFpRCw0QkFBNEIsMkRBQTJELEdBQUcsb0NBQW9DLFVBQVUsY0FBYywwQ0FBMEMsd0NBQXdDLFFBQVEsWUFBWSxJQUFJLEtBQUssaUpBQWlKLFFBQVEsU0FBUyx5QkFBeUIsaUJBQWlCLGtCQUFrQixtQkFBbUIscUJBQXFCLHVCQUF1QixjQUFjLEtBQUssdUJBQXVCLFNBQVMsb0JBQW9CLDJCQUEyQiw4QkFBOEIseUJBQXlCLFFBQVEsWUFBWSxJQUFJLGlCQUFpQixTQUFTLDRCQUE0QixpQkFBaUIsa0JBQWtCLHdCQUF3Qiw0QkFBNEIsWUFBWSxhQUFhLHlDQUF5Qyx5QkFBeUIsMEJBQTBCLHNFQUFzRSxpQkFBaUIsMEJBQTBCLDJDQUEyQyw2QkFBNkIsa0dBQWtHLHlCQUF5QiwyRUFBMkUsY0FBYyw0QkFBNEIsV0FBVyxrQ0FBa0MsaUJBQWlCLHdDQUF3QyxxREFBcUQsZ0NBQWdDLGFBQWEsWUFBWSxJQUFJLEtBQUssZ0ZBQWdGLGNBQWMsNEVBQTRFLElBQUksS0FBSyxhQUFhLCtHQUErRyxVQUFVLGVBQWUsU0FBUyxrQkFBa0IsV0FBVyx1R0FBdUcsRUFBRSxtQkFBbUIsRUFBRSxJQUFJLFNBQVMseUZBQXlGLFNBQVMsNEJBQTRCLDhDQUE4QyxxQkFBcUIsaUJBQWlCLHFDQUFxQyxxQkFBcUIsdURBQXVELGtDQUFrQyxxRkFBcUYsUUFBUSxrQkFBa0IsOERBQThELEdBQUcsb0JBQW9CLGtFQUFrRSxHQUFHLGlCQUFpQixLQUFLLFNBQVMseUJBQXlCLG1CQUFtQixxRUFBcUUsY0FBYyx5QkFBeUIsa0JBQWtCLDhCQUE4QixZQUFZLFdBQVcsS0FBSyx3QkFBd0IsMkVBQTJFLHFEQUFxRCxTQUFTLDJCQUEyQixxQ0FBcUMsVUFBVSxZQUFZLFdBQVcsS0FBSyx1Q0FBdUMsa0VBQWtFLDJEQUEyRCxPQUFPLFFBQVEsWUFBWSxXQUFXLDRCQUE0QixxRkFBcUYsVUFBVSwrQkFBK0Isc0JBQXNCLGlFQUFpRSxpRUFBaUUsa0ZBQWtGLDRFQUE0RSxZQUFZLElBQUksK0JBQStCLHlCQUF5QixpRUFBaUUsaUVBQWlFLGtGQUFrRiw0RUFBNEUsWUFBWSxJQUFJLHFCQUFxQix5QkFBeUIsaUVBQWlFLGlFQUFpRSxrRkFBa0YsNEVBQTRFLFlBQVksSUFBSSw4QkFBOEIsc0JBQXNCLGlFQUFpRSxpRUFBaUUsa0ZBQWtGLDRFQUE0RSxZQUFZLElBQUksMkJBQTJCLFFBQVEsMkJBQTJCLGlCQUFpQixvR0FBb0csMkJBQTJCLGlCQUFpQixZQUFZLFdBQVcsS0FBSyw2QkFBNkIsa0JBQWtCLG9CQUFvQixZQUFZLDZCQUE2QixzRUFBc0UsWUFBWSxJQUFJLGlCQUFpQixjQUFjLFFBQVEsNkJBQTZCLHdCQUF3Qiw0Q0FBNEMseUlBQXlJLFlBQVksSUFBSSxLQUFLLCtCQUErQiw4RkFBOEYsdUZBQXVGLHVDQUF1QyxRQUFRLDhCQUE4QixrREFBa0QsWUFBWSxPQUFPLDhGQUE4RixTQUFTLDhCQUE4QixrQkFBa0IsWUFBWSxXQUFXLGtCQUFrQiw2QkFBNkIsZUFBZSxRQUFRLHlDQUF5QyxtSUFBbUksaUJBQWlCLGFBQWEsMkNBQTJDLFlBQVksV0FBVyxtQkFBbUIsMEVBQTBFLGVBQWUsWUFBWSxXQUFXLG1CQUFtQiw0RUFBNEUsZUFBZSxZQUFZLGFBQWEsbUJBQW1CLHNFQUFzRSxlQUFlLFlBQVksV0FBVyxLQUFLLHNFQUFzRSwwRkFBMEYsNkNBQTZDLE1BQU0sNkdBQTZHLHNHQUFzRyw0R0FBNEcsWUFBWSxhQUFhLHlFQUF5RSw2Q0FBNkMsNkVBQTZFLG9CQUFvQiwrQ0FBK0MsNkNBQTZDLHVHQUF1RyxvQkFBb0IsZ0RBQWdELDJDQUEyQyxpQkFBaUIsYUFBYSxjQUFjLGlCQUFpQixhQUFhLGdGQUFnRixnREFBZ0Qsa0JBQWtCLDJEQUEyRCxVQUFVLHVEQUF1RCxtSEFBbUgsNEJBQTRCLHFHQUFxRyxzREFBc0QsaUhBQWlILG1DQUFtQyxjQUFjLGFBQWEsc0NBQXNDLFNBQVMsaUVBQWlFLGlDQUFpQyw2REFBNkQsU0FBUyxxQ0FBcUMsZ0JBQWdCLDZEQUE2RCxpRUFBaUUsS0FBSyxvRkFBb0YsZ0JBQWdCLElBQUksc0JBQXNCLGFBQWEscUVBQXFFLGtCQUFrQiwyQ0FBMkMsOERBQThELDZCQUE2QixhQUFhLCtCQUErQixtQkFBbUIsNEJBQTRCLGdFQUFnRSxtQ0FBbUMsc0JBQXNCLEVBQUUsZUFBZSxZQUFZLHlDQUF5Qyw0QkFBNEIsU0FBUyw2RkFBNkYsaUJBQWlCLHNDQUFzQyxTQUFTLG9JQUFvSSw2RkFBNkYseUJBQXlCLDJDQUEyQyxvREFBb0QsT0FBTyxvQkFBb0Isc0VBQXNFLE1BQU0sa0RBQWtELE1BQU0sbUZBQW1GLE1BQU0sbUZBQW1GLE1BQU0sMEVBQTBFLE1BQU0saUVBQWlFLE1BQU0sdUVBQXVFLE1BQU0sd0VBQXdFLDRJQUE0SSxxQkFBcUIsUUFBUSxZQUFZLGlFQUFpRSw4REFBOEQsb0pBQW9KLDJEQUEyRCxTQUFTLGdDQUFnQyxpQkFBaUIsR0FBRyw4Q0FBOEMsd0JBQXdCLHVDQUF1QyxRQUFRLFNBQVMsb0JBQW9CLDhCQUE4QixpQkFBaUIsR0FBRyxlQUFlLGdFQUFnRSxjQUFjLFNBQVMsMkJBQTJCLFVBQVUsNEJBQTRCLGlHQUFpRyxjQUFjLFNBQVMsMkJBQTJCLHdCQUF3QixpQkFBaUIsMkZBQTJGLGNBQWMsU0FBUyxrQkFBa0Isb0JBQW9CLDRCQUE0QixvREFBb0QsdUNBQXVDLGNBQWMsU0FBUyxxQkFBcUIsaUJBQWlCLEdBQUcsb0JBQW9CLHVEQUF1RCxjQUFjLFNBQVMsZUFBZSxnRUFBZ0UsaURBQWlELDhDQUE4Qyx1Q0FBdUMsY0FBYyxTQUFTLDJCQUEyQixpQkFBaUIsR0FBRyxtQkFBbUIsZUFBZSxhQUFhLHNDQUFzQyxTQUFTLHlCQUF5QixvQ0FBb0Msb0JBQW9CLDRCQUE0QixRQUFRLG1CQUFtQixJQUFJLHFFQUFxRSxvTEFBb0wsbUJBQW1CLEdBQUcsdUVBQXVFLDBJQUEwSSxvQkFBb0IsR0FBRyx3REFBd0QsUUFBUSwwTUFBME0sb0dBQW9HLGdFQUFnRSx1RkFBdUYsR0FBRyxJQUFJLEVBQUUsR0FBRyxTQUFTLFNBQVMsK0RBQStELGdCQUFnQixhQUFhLHNDQUFzQyxTQUFTLGdEQUFnRCw4Q0FBOEMsTUFBTSw2Q0FBNkMsK0JBQStCLCtDQUErQyxxREFBcUQscUJBQXFCLHFEQUFxRCxVQUFVLHVCQUF1QixvQkFBb0IsdUJBQXVCLHFCQUFxQixxQkFBcUIsc0RBQXNELEVBQUUsSUFBSSwwRUFBMEUsNENBQTRDLGdGQUFnRixLQUFLLDRDQUE0Qyx3RkFBd0Ysb0ZBQW9GLGdCQUFnQiwyQ0FBMkMsaUJBQWlCLGdCQUFnQiwrQkFBK0IsaURBQWlELDRDQUE0QyxFQUFFLElBQUksb0JBQW9CLEdBQUcsV0FBVywrQkFBK0IsMkNBQTJDLDZDQUE2QyxFQUFFLElBQUksVUFBVSxHQUFHLHFGQUFxRixZQUFZLFdBQVcsb0VBQW9FLFNBQVMsa0JBQWtCLGVBQWUscUNBQXFDLGdCQUFnQixhQUFhLHNDQUFzQyxTQUFTLDZCQUE2QixvQ0FBb0Msd0JBQXdCLDRCQUE0QixRQUFRLG1CQUFtQixLQUFLLG9CQUFvQixzQ0FBc0MsRUFBRSx3QkFBd0IscUVBQXFFLEtBQUssSUFBSSxxRkFBcUYsYUFBYSxVQUFVLHdCQUF3QixxQkFBcUIsd0JBQXdCLG9CQUFvQixpRUFBaUUsRUFBRSxJQUFJLDRCQUE0Qix3TkFBd04sYUFBYSxVQUFVLDBCQUEwQix3QkFBd0IsdURBQXVELEVBQUUsSUFBSSxtQkFBbUIsUUFBUSw2SUFBNkksb0xBQW9MLG1CQUFtQixHQUFHLHVFQUF1RSwwSUFBMEksb0JBQW9CLEdBQUcseVFBQXlRLHdEQUF3RCxrQkFBa0Isa0NBQWtDLFVBQVUsMEJBQTBCLE1BQU0sOEJBQThCLDZDQUE2QyxFQUFFLEdBQUcsbUNBQW1DLGdIQUFnSCxFQUFFLElBQUkseUhBQXlILGdFQUFnRSwrRkFBK0YsR0FBRyxJQUFJLEVBQUUsR0FBRyxTQUFTLFNBQVMsbUVBQW1FLGdCQUFnQixhQUFhLHNDQUFzQyxTQUFTLDJCQUEyQixnQkFBZ0IsMEJBQTBCLG9FQUFvRSwwQ0FBMEMsZUFBZSxhQUFhLHNDQUFzQyxTQUFTLHNKQUFzSiw2Q0FBNkMsa0JBQWtCLDBDQUEwQyx1RUFBdUUsRUFBRSxJQUFJLGdCQUFnQiw0QkFBNEIsc0RBQXNELDBDQUEwQyxpQ0FBaUMsNEJBQTRCLGlCQUFpQixJQUFJLHVIQUF1SCxRQUFRLGdFQUFnRSw2RUFBNkUsWUFBWSxJQUFJLEtBQUssZ0NBQWdDLG9EQUFvRCxvQ0FBb0MsWUFBWSxJQUFJLEtBQUssaUNBQWlDLHFEQUFxRCxvQ0FBb0MsZ0NBQWdDLHlCQUF5Qix1Q0FBdUMsdUNBQXVDLHNCQUFzQix1Q0FBdUMsNENBQTRDLDJCQUEyQixpRkFBaUYsWUFBWSxVQUFVLG9CQUFvQixxQkFBcUIsb0JBQW9CLHFCQUFxQixzQkFBc0IscUJBQXFCLHVCQUF1Qix1QkFBdUIsd0JBQXdCLHNCQUFzQixxQkFBcUIsdUJBQXVCLGtEQUFrRCxFQUFFLElBQUksT0FBTyxVQUFVLG9CQUFvQixxQkFBcUIsb0JBQW9CLHFCQUFxQixzQkFBc0IscUJBQXFCLHVCQUF1Qix1QkFBdUIsd0JBQXdCLHNCQUFzQixxQkFBcUIsdUJBQXVCLGtEQUFrRCxFQUFFLElBQUksT0FBTyxVQUFVLGtDQUFrQyx5Q0FBeUMsNEJBQTRCLGdDQUFnQyw4QkFBOEIsOEJBQThCLGtDQUFrQyxnQ0FBZ0MsaUNBQWlDLG1DQUFtQyw2Q0FBNkMsRUFBRSxLQUFLLG9CQUFvQix1Q0FBdUMsNENBQTRDLGlEQUFpRCxhQUFhLGdCQUFnQixJQUFJLDZCQUE2QixZQUFZLElBQUksS0FBSyxvQ0FBb0MsUUFBUSxxQkFBcUIsc0NBQXNDLFVBQVUsWUFBWSxXQUFXLEtBQUsscUVBQXFFLEdBQUcsa0JBQWtCLDhDQUE4QyxxR0FBcUcsaURBQWlELElBQUksVUFBVSxnQ0FBZ0MsZ0RBQWdELGtEQUFrRCxVQUFVLFFBQVEsbUJBQW1CLHNHQUFzRyxJQUFJLDRCQUE0QixZQUFZLElBQUksK0NBQStDLFlBQVksSUFBSSw0Q0FBNEMsaUNBQWlDLFdBQVcscUJBQXFCLElBQUksS0FBSyw0REFBNEQsVUFBVSxJQUFJLGtIQUFrSCxFQUFFLEdBQUcsVUFBVSx1QkFBdUIsaUJBQWlCLDZDQUE2QyxZQUFZLElBQUksNkJBQTZCLGNBQWMsOENBQThDLHdCQUF3QixXQUFXLFVBQVUsWUFBWSxJQUFJLEtBQUssdURBQXVELDRCQUE0QixnQkFBZ0IsS0FBSyxxQkFBcUIsNkdBQTZHLFFBQVEsc0VBQXNFLGtCQUFrQix5REFBeUQsRUFBRSxJQUFJLFFBQVEsbUJBQW1CLFFBQVEsaUdBQWlHLG9CQUFvQix1Q0FBdUMsNENBQTRDLHFDQUFxQywyREFBMkQsY0FBYyxrQ0FBa0MsV0FBVyxrQkFBa0IsYUFBYSw4Q0FBOEMsVUFBVSxzQkFBc0IsYUFBYSxtRUFBbUUsa0JBQWtCLDJDQUEyQyw4REFBOEQsNkJBQTZCLGFBQWEsK0JBQStCLG1CQUFtQiw0QkFBNEIsZ0VBQWdFLG1DQUFtQyxzQkFBc0IsRUFBRSxlQUFlLFlBQVkseUNBQXlDLDRCQUE0QixTQUFTLDZGQUE2RixnQkFBZ0IsMkNBQTJDLDBCQUEwQixZQUFZLHNDQUFzQyxTQUFTLHlEQUF5RCx5Q0FBeUMscUJBQXFCLGlIQUFpSCxrQ0FBa0MsOEJBQThCLDhFQUE4RSwyRUFBMkUsS0FBSywyREFBMkQsSUFBSSxvUkFBb1IsU0FBUyxVQUFVLGVBQWUsSUFBSSx5S0FBeUssU0FBUyxVQUFVLDhIQUE4SCxTQUFTLFdBQVcsZ0NBQWdDLGlCQUFpQixTQUFTLEtBQUssZ0NBQWdDLHlCQUF5QixnSEFBZ0gsdUJBQXVCLHdDQUF3QywwRkFBMEYsS0FBSyx5Q0FBeUMsZUFBZSxTQUFTLGNBQWMsSUFBSSxFQUFFLG9DQUFvQyx1QkFBdUIsRUFBRSxlQUFlLGtCQUFrQixPQUFPLGVBQWUsR0FBRyx1R0FBdUcsRUFBRSxLQUFLLG9CQUFvQixpQkFBaUIsdURBQXVELGdCQUFnQixNQUFNLG9HQUFvRyxnQkFBZ0IsYUFBYSxPQUFPLFFBQVEsRUFBRSxzQkFBc0IsYUFBYSx1SkFBdUosT0FBTyxjQUFjLDBKQUEwSixhQUFhLGtDQUFrQyxhQUFhLGtDQUFrQyxhQUFhLGtDQUFrQyxhQUFhLGtDQUFrQyxhQUFhLGtDQUFrQyxVQUFVLE9BQU8sc0JBQXNCLHFDQUFxQyxRQUFRLEdBQUcsa0NBQWtDLGlDQUFpQyxRQUFRLHdNQUF3TSxjQUFjLDBDQUEwQyxNQUFNLE1BQU0sc0NBQXNDLHVCQUF1QixpQkFBaUIsOERBQThELGdFQUFnRSxpREFBaUQsbUJBQW1CLEdBQUcsbUlBQW1JLDhCQUE4QixnREFBZ0QsUUFBUSxhQUFhLGtDQUFrQyxtRUFBbUUsc0JBQXNCLG9DQUFvQyxJQUFJLFNBQVMsU0FBUyxtSUFBbUksb0JBQW9CLGdQQUFnUCx5QkFBeUIsc0RBQXNELFdBQVcseUJBQXlCLCtGQUErRixjQUFjLHlCQUF5Qiw4REFBOEQseURBQXlELDBCQUEwQixHQUFHLHlFQUF5RSw2REFBNkQsaUVBQWlFLG1DQUFtQyw2R0FBNkcsMEJBQTBCLG9FQUFvRSwwRkFBMEYsa0JBQWtCLGlCQUFpQixRQUFRLGNBQWMsS0FBSywyR0FBMkcsU0FBUyxJQUFJLEVBQUUsYUFBYSxVQUFVLGdCQUFnQixvREFBb0QsS0FBSyxnQkFBZ0IsK0pBQStKLCtCQUErQixTQUFTLGdCQUFnQiw2QkFBNkIsb0JBQW9CLG1CQUFtQixhQUFhLFFBQVEsWUFBWSxXQUFXLEtBQUssc0JBQXNCLCtFQUErRSxjQUFjLGFBQWEsS0FBSyxZQUFZLGdCQUFnQixvQkFBb0IsS0FBSyxhQUFhLGdCQUFnQixxQkFBcUIsS0FBSyxnQkFBZ0IsNkNBQTZDLHVCQUF1QixxQkFBcUIsc0JBQXNCLGNBQWMsZ0JBQWdCLFdBQVcsS0FBSyxzQkFBc0IsMkRBQTJELFNBQVMsY0FBYyw4T0FBOE8sZ0JBQWdCLGlDQUFpQywrQkFBK0Isb0NBQW9DLHFDQUFxQyx3Q0FBd0MsdWFBQXVhLG9DQUFvQywwQkFBMEIsYUFBYSxhQUFhLGFBQWEsdUJBQXVCLGFBQWEsNEJBQTRCLGVBQWUscUJBQXFCLG9CQUFvQix5SUFBeUksY0FBYyxvREFBb0QsVUFBVSxjQUFjLFNBQVMsSUFBSSxxQ0FBcUMsaUJBQWlCLHVEQUF1RCxTQUFTLE9BQU8sNkNBQTZDLFVBQVUsZUFBZSx3RkFBd0YsZUFBZSw0QkFBNEIsZUFBZSxjQUFjLGVBQWUsc0NBQXNDLE9BQU8sd0RBQXdELGlCQUFpQiwrQ0FBK0Msa0NBQWtDLGVBQWUsc0JBQXNCLHlEQUF5RCxpQkFBaUIsOEJBQThCLHVGQUF1RixRQUFRLHVCQUF1QixlQUFlLFdBQVcsZ0JBQWdCLGVBQWUsa0ZBQWtGLGdCQUFnQixlQUFlLDJDQUEyQyw2QkFBNkIsU0FBUyxnQkFBZ0IsV0FBVyw0RUFBNEUsZ0JBQWdCLGVBQWUsd0JBQXdCLGtCQUFrQixnQkFBZ0IscUJBQXFCLDREQUE0RCxrQkFBa0IsaUtBQWlLLHlRQUF5USxhQUFhLHNWQUFzVixhQUFhLGVBQWUsMkVBQTJFLGlDQUFpQyxhQUFhLE9BQU8sRUFBRSw2QkFBNkIsYUFBYSxvQ0FBb0MsbUJBQW1CLGlGQUFpRixFQUFFLGVBQWUsdUNBQXVDLDBCQUEwQixlQUFlLGdFQUFnRSxlQUFlLEtBQUssV0FBVyxjQUFjLGVBQWUsV0FBVyxxQkFBcUIsZUFBZSxzQkFBc0IsSUFBSSxNQUFNLFNBQVMsc0NBQXNDLDhDQUE4Qyw4QkFBOEIsb0NBQW9DLFVBQVUsZUFBZSxZQUFZLDZEQUE2RCxpQ0FBaUMsK0JBQStCLDBCQUEwQixlQUFlLDJDQUEyQyx3QkFBd0Isb0JBQW9CLDZCQUE2QixxQkFBcUIsd0JBQXdCLG9CQUFvQiw2QkFBNkIsb0JBQW9CLHNCQUFzQixxQkFBcUIsaUNBQWlDLG9CQUFvQixpQ0FBaUMscUJBQXFCLGlDQUFpQyxvQkFBb0IsaUNBQWlDLHVCQUF1QixtRUFBbUUsb0JBQW9CLDhCQUE4QixvQkFBb0IseUNBQXlDLHFCQUFxQix5QkFBeUIsb0JBQW9CLDhCQUE4QixvQkFBb0IsNENBQTRDLGdCQUFnQix3QkFBd0IsZUFBZSx3QkFBd0IscUJBQXFCLHFDQUFxQyxxQkFBcUIsMklBQTJJLFNBQVMsdUNBQXVDLG9CQUFvQixrREFBa0QsbUJBQW1CLHlCQUF5QixpQkFBaUIsd0JBQXdCLGlCQUFpQix3QkFBd0IsbUJBQW1CLDBCQUEwQixtQkFBbUIseUJBQXlCLGlCQUFpQix3QkFBd0IsbUJBQW1CLDJCQUEyQixxQkFBcUIsNkJBQTZCLHFCQUFxQiw2QkFBNkIscUJBQXFCLDZCQUE2QixlQUFlLHVCQUF1QixpQkFBaUIseUJBQXlCLG1CQUFtQiwyQkFBMkIsZUFBZSw0RUFBNEUsZUFBZSwwQ0FBMEMseUJBQXlCLGtDQUFrQyx5QkFBeUIsaUNBQWlDLGVBQWUscUJBQXFCLHlCQUF5QixtQkFBbUIsY0FBYyxtRUFBbUUsMkJBQTJCLG1FQUFtRSx3QkFBd0IsNENBQTRDLHdKQUF3SixpQkFBaUIscUNBQXFDLGdCQUFnQiw2QkFBNkIsSUFBSSxLQUFLLGFBQWEsZUFBZSxtQkFBbUIsR0FBRyw0Q0FBNEMsdUJBQXVCLHlCQUF5QiwrRUFBK0UsbUJBQW1CLGNBQWMsUUFBUSxTQUFTLCtNQUErTSxrREFBa0QsU0FBUyw4QkFBOEIsS0FBSyxVQUFVLGlCQUFpQix5QkFBeUIsUUFBUSxtQ0FBbUMsVUFBVSw4QkFBOEIsV0FBVyxvQ0FBb0MsOEJBQThCLEtBQUssaUJBQWlCLHlCQUF5QixXQUFXLHVCQUF1QixRQUFRLDhCQUE4QixjQUFjLHFCQUFxQixlQUFlLHVCQUF1QixxQkFBcUIsNkJBQTZCLHVCQUF1QiwrQkFBK0Isb0JBQW9CLGlCQUFpQixZQUFZLHlEQUF5RCxxQkFBcUIsNkJBQTZCLGdCQUFnQixJQUFJLEtBQUssc0NBQXNDLEtBQUssWUFBWSxJQUFJLHVCQUF1QixLQUFLLHlCQUF5QixTQUFTLGVBQWUsb0NBQW9DLHNGQUFzRixxQkFBcUIsa0JBQWtCLDRDQUE0QyxXQUFXLFVBQVUsU0FBUyxnQkFBZ0Isa0JBQWtCLGdCQUFnQixjQUFjLHNCQUFzQixNQUFNLDBIQUEwSCxjQUFjLG1CQUFtQixnREFBZ0QsZ0JBQWdCLDRDQUE0Qyw0Q0FBNEMsNENBQTRDLGdEQUFnRCxpREFBaUQsY0FBYyxXQUFXLGtEQUFrRCxJQUFJLEVBQUUsb0RBQW9ELHVCQUF1Qix5QkFBeUIsTUFBTSxzR0FBc0csMkpBQTJKLHVCQUF1QixnQkFBZ0IsZ05BQWdOLFdBQVcsbVhBQW1YLHFDQUFxQyxpTEFBaUwsWUFBWSxpQkFBaUIsOEJBQThCLGtCQUFrQixlQUFlLGtCQUFrQiw4QkFBOEIsa0JBQWtCLGVBQWUsa0JBQWtCLDhCQUE4QixrQkFBa0IsaUJBQWlCLGtCQUFrQixxQkFBcUIsa0JBQWtCLG9DQUFvQyxrQkFBa0IsWUFBWSxrQkFBa0IsaUJBQWlCLGtCQUFrQiw2Q0FBNkMsa0JBQWtCLGdCQUFnQixVQUFVLCtCQUErQixtQkFBbUIsa0JBQWtCLG1CQUFtQixrQkFBa0IsaUJBQWlCLGlCQUFpQixZQUFZLGtCQUFrQixrQ0FBa0Msa0JBQWtCLGlCQUFpQixpQkFBaUIsWUFBWSxrQkFBa0IsZUFBZSxrQkFBa0Isd0NBQXdDLGtCQUFrQix3Q0FBd0MsMEZBQTBGLEtBQUssS0FBSyx3QkFBd0Isa0NBQWtDLGNBQWMsa0JBQWtCLFlBQVksa0JBQWtCLDhDQUE4QyxrQkFBa0IsMENBQTBDLGtCQUFrQixpQkFBaUIsa0JBQWtCLGtCQUFrQiw2RUFBNkUsa0JBQWtCLFlBQVksaUJBQWlCLFdBQVcsdUZBQXVGLHFCQUFxQixvQkFBb0IsMkJBQTJCLHlEQUF5RCxpQkFBaUIsa0JBQWtCLFFBQVEsNkZBQTZGLGNBQWMsbUJBQW1CLGVBQWUsNEVBQTRFLGdCQUFnQix5RkFBeUYsY0FBYyxNQUFNLGVBQWUsb0JBQW9CLGFBQWEsd0JBQXdCLEtBQUssY0FBYyxTQUFTLGtCQUFrQixnQkFBZ0IsUUFBUSxhQUFhLG9CQUFvQixvREFBb0QsV0FBVyxLQUFLLFdBQVcsc0JBQXNCLGlDQUFpQyxjQUFjLGNBQWMsU0FBUyxrQkFBa0IsZ0JBQWdCLFFBQVEsYUFBYSxvQkFBb0Isb0RBQW9ELFdBQVcsS0FBSyxXQUFXLHNCQUFzQixpQ0FBaUMsY0FBYyxjQUFjLFNBQVMsa0JBQWtCLGdCQUFnQixRQUFRLGFBQWEsb0JBQW9CLG9EQUFvRCxXQUFXLEtBQUssV0FBVyxzQkFBc0IsaUNBQWlDLGNBQWMsbUJBQW1CLGVBQWUsK0JBQStCLFdBQVcseURBQXlELG1CQUFtQixvQ0FBb0MsZUFBZSxVQUFVLGdCQUFnQixzQkFBc0IsZUFBZSxlQUFlLDZCQUE2QixRQUFRLHFCQUFxQixtQkFBbUIsNEZBQTRGLGNBQWMscUhBQXFILGVBQWUscUhBQXFILGNBQWMsa0JBQWtCLGVBQWUsZUFBZSxlQUFlLFNBQVMsc0JBQXNCLGdDQUFnQyx1QkFBdUIsa0RBQWtELEVBQUUsS0FBSyx3QkFBd0IsZUFBZSxtQ0FBbUMsRUFBRSxTQUFTLGVBQWUsU0FBUyxrQkFBa0IscVZBQXFWLGtCQUFrQiw0T0FBNE8sd0VBQXdFLDhNQUE4TSxnQkFBZ0IsK1JBQStSLGdYQUFnWCxrQ0FBa0MsMEJBQTBCLGNBQWMsT0FBTyxjQUFjLFdBQVcsaUpBQWlKLFVBQVUsOENBQThDLGVBQWUsa0JBQWtCLHlCQUF5QixvQ0FBb0MsY0FBYyw0REFBNEQsb0JBQW9CLGtCQUFrQixZQUFZLElBQUksdUJBQXVCLDBDQUEwQyxnQkFBZ0IsaUJBQWlCLHNDQUFzQyxZQUFZLEtBQUssTUFBTSxpQkFBaUIsMEJBQTBCLFdBQVcsbUVBQW1FLEdBQUcsSUFBSSw4Q0FBOEMsUUFBUSxRQUFRLFVBQVUsU0FBUyxjQUFjLFNBQVMsZUFBZSxjQUFjLG9EQUFvRCxVQUFVLG9CQUFvQix1QkFBdUIsdUVBQXVFLHdCQUF3QiwyQ0FBMkMsU0FBUywwQkFBMEIsaURBQWlELGtDQUFrQyxLQUFLLDhCQUE4QixVQUFVLDZCQUE2QixJQUFJLFlBQVksSUFBSSwyQkFBMkIsU0FBUyxvQkFBb0IsV0FBVyxJQUFJLGtCQUFrQixTQUFTLHlCQUF5QixTQUFTLG9CQUFvQixXQUFXLElBQUksa0JBQWtCLFNBQVMseUJBQXlCLFNBQVMsZUFBZSxXQUFXLElBQUksZUFBZSxTQUFTLHlCQUF5QixTQUFTLGlCQUFpQixXQUFXLElBQUksZ0JBQWdCLFNBQVMseUJBQXlCLFNBQVMsbUJBQW1CLFdBQVcsSUFBSSxrQkFBa0IsU0FBUyx5QkFBeUIsU0FBUyxtQkFBbUIsV0FBVyxJQUFJLGtCQUFrQixTQUFTLHlCQUF5QixTQUFTLG1CQUFtQixXQUFXLElBQUksa0JBQWtCLFNBQVMseUJBQXlCLFNBQVMscUJBQXFCLFdBQVcsSUFBSSxvQkFBb0IsU0FBUyx5QkFBeUIsU0FBUyx1QkFBdUIsV0FBVyxJQUFJLHNCQUFzQixTQUFTLHlCQUF5QixTQUFTLHlCQUF5QixXQUFXLElBQUksd0JBQXdCLFNBQVMseUJBQXlCLFNBQVMseUJBQXlCLFdBQVcsSUFBSSx3QkFBd0IsU0FBUyx5QkFBeUIsU0FBUywyQkFBMkIsV0FBVyxJQUFJLDBCQUEwQixTQUFTLHlCQUF5QixTQUFTLDZCQUE2QixXQUFXLElBQUksNEJBQTRCLFNBQVMseUJBQXlCLFNBQVMscUNBQXFDLFdBQVcsSUFBSSxvQ0FBb0MsU0FBUyx5QkFBeUIsU0FBUyw4QkFBOEIsV0FBVyxJQUFJLDJCQUEyQixTQUFTLHlCQUF5QixTQUFTLDJCQUEyQixXQUFXLElBQUkseUJBQXlCLFNBQVMseUJBQXlCLFNBQVMsdUJBQXVCLFdBQVcsSUFBSSxxQkFBcUIsU0FBUyx5QkFBeUIsU0FBUyxzQkFBc0IsV0FBVyxJQUFJLG1CQUFtQixTQUFTLHlCQUF5QixTQUFTLGVBQWUsV0FBVyxJQUFJLGFBQWEsU0FBUyx5QkFBeUIsU0FBUyxrQkFBa0IsV0FBVyxJQUFJLGVBQWUsU0FBUyx5QkFBeUIsU0FBUyxtQkFBbUIsV0FBVyxJQUFJLGlCQUFpQixTQUFTLHlCQUF5QixTQUFTLGVBQWUsV0FBVyxJQUFJLFFBQVEsU0FBUyx5QkFBeUIsU0FBUyxpQkFBaUIsV0FBVyxJQUFJLFNBQVMsU0FBUyx5QkFBeUIsU0FBUyxtQkFBbUIsV0FBVyxJQUFJLFdBQVcsU0FBUyx5QkFBeUIsU0FBUyxzQkFBc0IsV0FBVyxJQUFJLGFBQWEsU0FBUyx5QkFBeUIsU0FBUyxxQkFBcUIsV0FBVyxJQUFJLGFBQWEsU0FBUyx5QkFBeUIsU0FBUyx1QkFBdUIsV0FBVyxJQUFJLGVBQWUsU0FBUyx5QkFBeUIsU0FBUyx5QkFBeUIsV0FBVyxJQUFJLGlCQUFpQixTQUFTLHlCQUF5QixTQUFTLDJCQUEyQixXQUFXLElBQUksbUJBQW1CLFNBQVMseUJBQXlCLFNBQVMsNkJBQTZCLFdBQVcsSUFBSSxxQkFBcUIsU0FBUyx5QkFBeUIsU0FBUyxnQ0FBZ0MsV0FBVyxJQUFJLHVCQUF1QixTQUFTLHlCQUF5QixTQUFTLG1DQUFtQyxXQUFXLElBQUksMkJBQTJCLFNBQVMseUJBQXlCLFNBQVMsNkNBQTZDLFdBQVcsSUFBSSxxQ0FBcUMsU0FBUyx5QkFBeUIsU0FBUyw4QkFBOEIsV0FBVyxJQUFJLG9CQUFvQixTQUFTLHlCQUF5QixTQUFTLHNDQUFzQyxXQUFXLElBQUksNEJBQTRCLFNBQVMseUJBQXlCLFNBQVMsMEJBQTBCLFdBQVcsSUFBSSxnQkFBZ0IsU0FBUyx5QkFBeUIsU0FBUyxlQUFlLFNBQVMsaUNBQWlDLEtBQUssMkJBQTJCLHFCQUFxQixZQUFZLGdCQUFnQixnTkFBZ04sY0FBYyx1QkFBdUIsY0FBYyxrQkFBa0IsZUFBZSx3RUFBd0UsMEJBQTBCLG9CQUFvQiw4REFBOEQsdUJBQXVCLHFCQUFxQixZQUFZLEdBQUcsdUNBQXVDLGtCQUFrQixxQkFBcUIsS0FBSyxHQUFHLDBDQUEwQyxZQUFZLEdBQUcscUJBQXFCLG9DQUFvQyxxQkFBcUIsU0FBUyx1QkFBdUIscURBQXFELEdBQUcsT0FBTyxNQUFNLDBGQUEwRiw4QkFBOEIsU0FBUyxxRUFBcUUsb0lBQW9JLDBCQUEwQixvQkFBb0IsaUVBQWlFLGtHQUFrRyxHQUFHLGFBQWEsbUNBQW1DLDREQUE0RCx1QkFBdUIsa0RBQWtELHVDQUF1QyxrRUFBa0UsMENBQTBDLHFFQUFxRSx3Q0FBd0MsbUVBQW1FLHdDQUF3QyxtRUFBbUUsZ0NBQWdDLDJEQUEyRCxpQ0FBaUMsNERBQTRELGdDQUFnQywyREFBMkQsaUNBQWlDLDREQUE0RCwrQkFBK0IsMERBQTBELGdDQUFnQywyREFBMkQsdUJBQXVCLGtEQUFrRCwrQkFBK0IsMERBQTBELGdDQUFnQywyREFBMkQsZ0NBQWdDLDJEQUEyRCxtQ0FBbUMsOERBQThELG9DQUFvQywrREFBK0Qsb0NBQW9DLCtEQUErRCxzQkFBc0IsaURBQWlELCtCQUErQiwyREFBMkQsa0NBQWtDLDBEQUEwRCx5QkFBeUIsb0RBQW9ELHVCQUF1QixrREFBa0QseUJBQXlCLHFEQUFxRCxtQ0FBbUMsZ0VBQWdFLHFDQUFxQyw2REFBNkQsMENBQTBDLHNFQUFzRSx5Q0FBeUMsc0VBQXNFLGlFQUFpRSxzRkFBc0YsdURBQXVELGtGQUFrRiwrQ0FBK0MsMEVBQTBFLDBDQUEwQyxxRUFBcUUsMkJBQTJCLHNEQUFzRCw4Q0FBOEMseUVBQXlFLDJCQUEyQixzREFBc0QsOEJBQThCLHlEQUF5RCw0QkFBNEIsdURBQXVELGtDQUFrQyw2REFBNkQsd0NBQXdDLG1FQUFtRSwyQkFBMkIsc0RBQXNELGdDQUFnQywyREFBMkQsNkJBQTZCLHdEQUF3RCxpQ0FBaUMsNERBQTRELDhCQUE4Qix5REFBeUQsbUNBQW1DLDhEQUE4RCw2QkFBNkIsd0RBQXdELDRCQUE0Qix1REFBdUQsaUNBQWlDLDREQUE0RCw4QkFBOEIsMERBQTBELGNBQWMsYUFBYSx3R0FBd0csdUVBQXVFLGlCQUFpQixFQUFFLHdCQUF3QixhQUFhLE9BQU8sMkNBQTJDLGFBQWEsRUFBRSxLQUFLLG1FQUFtRSxnQkFBZ0IsS0FBSywyRUFBMkUsdUJBQXVCLGdCQUFnQixTQUFTLFlBQVksbURBQW1ELG9CQUFvQix1SkFBdUosb0JBQW9CLHFFQUFxRSxtQkFBbUIsbUJBQW1CLG9CQUFvQixFQUFFLFlBQVksZUFBZSwwSkFBMEosVUFBVSxPQUFPLHNCQUFzQixxQ0FBcUMsUUFBUSxHQUFHLGtDQUFrQyxpQ0FBaUMsUUFBUSx5S0FBeUsseUNBQXlDLHVCQUF1QixpQkFBaUIsOERBQThELGdFQUFnRSxpREFBaUQsbUJBQW1CLEdBQUcsbUlBQW1JLDZCQUE2QixnREFBZ0QsUUFBUSxhQUFhLHFDQUFxQyxrRUFBa0Usc0JBQXNCLG1DQUFtQywwT0FBME8seUJBQXlCLHNEQUFzRCxXQUFXLHlCQUF5QiwrRkFBK0YsY0FBYyx5QkFBeUIsOERBQThELHlEQUF5RCwwQkFBMEIsRUFBRSxvRkFBb0YsNkdBQTZHLDBCQUEwQixtRUFBbUUsc0ZBQXNGLGtCQUFrQixpQkFBaUIsUUFBUSxjQUFjLEtBQUssd0RBQXdELFNBQVMsSUFBSSxFQUFFLGFBQWEsVUFBVSxnQkFBZ0Isb0RBQW9ELEtBQUssZ0JBQWdCLCtKQUErSiwrQkFBK0IsU0FBUyxnQkFBZ0IsMkJBQTJCLG9CQUFvQixtQkFBbUIsYUFBYSxRQUFRLFlBQVksV0FBVyxLQUFLLHNCQUFzQiwrRUFBK0UsY0FBYyxhQUFhLEtBQUssWUFBWSxnQkFBZ0Isb0JBQW9CLEtBQUssYUFBYSxnQkFBZ0IscUJBQXFCLEtBQUssZ0JBQWdCLDZDQUE2Qyx1QkFBdUIscUJBQXFCLHNCQUFzQixjQUFjLGdCQUFnQixXQUFXLEtBQUssc0JBQXNCLDJEQUEyRCxTQUFTLGFBQWEsZUFBZSw0T0FBNE8sOEJBQThCLGFBQWEsdUJBQXVCLGFBQWEsd0JBQXdCLGNBQWMsNklBQTZJLGFBQWEsbURBQW1ELFVBQVUsMkJBQTJCLFFBQVEscUNBQXFDLGFBQWEsUUFBUSxJQUFJLG9DQUFvQyxpQkFBaUIsdURBQXVELFNBQVMsTUFBTSxjQUFjLHdGQUF3RixjQUFjLEtBQUssV0FBVyxjQUFjLGtCQUFrQixlQUFlLDJDQUEyQyxzQkFBc0Isb0JBQW9CLDJCQUEyQixxQkFBcUIsc0JBQXNCLG9CQUFvQiwyQkFBMkIsb0JBQW9CLG9CQUFvQixxQkFBcUIsMkJBQTJCLG9CQUFvQiwrQkFBK0IscUJBQXFCLDJCQUEyQixvQkFBb0IsK0JBQStCLHVCQUF1QixtRUFBbUUsb0JBQW9CLHFCQUFxQixvQkFBb0Isd0JBQXdCLG1DQUFtQyxxQkFBcUIsdUJBQXVCLG9CQUFvQiw0QkFBNEIsb0JBQW9CLDBDQUEwQyxnQkFBZ0Isd0JBQXdCLGVBQWUsd0JBQXdCLFVBQVUsZUFBZSxZQUFZLDZEQUE2RCxlQUFlLHFCQUFxQix1QkFBdUIsVUFBVSxjQUFjLFFBQVEsU0FBUywrTUFBK00sa0RBQWtELFNBQVMsOEJBQThCLEtBQUssVUFBVSx1QkFBdUIsaUJBQWlCLFlBQVkseURBQXlELFNBQVMsZUFBZSxvQ0FBb0Msc0ZBQXNGLHFCQUFxQixrQkFBa0IsNENBQTRDLFdBQVcsVUFBVSxTQUFTLGdCQUFnQixrQkFBa0IsZ0JBQWdCLGNBQWMsc0JBQXNCLE1BQU0sMEhBQTBILGNBQWMsbUJBQW1CLGdEQUFnRCxnQkFBZ0IsNENBQTRDLDRDQUE0Qyw0Q0FBNEMsZ0RBQWdELGlEQUFpRCxjQUFjLFdBQVcsa0RBQWtELElBQUksRUFBRSxvREFBb0QsdUJBQXVCLHlCQUF5QixNQUFNLHNHQUFzRywySkFBMkoscUJBQXFCLGdCQUFnQiw0TEFBNEwsV0FBVyxtWEFBbVgscUNBQXFDLGlMQUFpTCxZQUFZLGlCQUFpQiw4QkFBOEIsa0JBQWtCLGVBQWUsa0JBQWtCLDhCQUE4QixrQkFBa0IsZUFBZSxrQkFBa0IsOEJBQThCLGtCQUFrQixpQkFBaUIsa0JBQWtCLHFCQUFxQixrQkFBa0Isb0NBQW9DLGtCQUFrQixZQUFZLGtCQUFrQixpQkFBaUIsa0JBQWtCLDZDQUE2QyxrQkFBa0IsZ0JBQWdCLFVBQVUsK0JBQStCLG1CQUFtQixrQkFBa0IsbUJBQW1CLGtCQUFrQixpQkFBaUIsaUJBQWlCLFlBQVksa0JBQWtCLGtDQUFrQyxrQkFBa0IsaUJBQWlCLGlCQUFpQixZQUFZLGtCQUFrQixlQUFlLGtCQUFrQix3Q0FBd0Msa0JBQWtCLHdDQUF3QywwRkFBMEYsS0FBSyxLQUFLLHdCQUF3QixrQ0FBa0MsY0FBYyxrQkFBa0IsWUFBWSxrQkFBa0IsOENBQThDLGtCQUFrQiwwQ0FBMEMsa0JBQWtCLGlCQUFpQixrQkFBa0Isa0JBQWtCLDZFQUE2RSxrQkFBa0IsWUFBWSxpQkFBaUIsV0FBVyx1RkFBdUYscUJBQXFCLG9CQUFvQiwyQkFBMkIsc0VBQXNFLFFBQVEsY0FBYyxtQkFBbUIsZUFBZSwwRUFBMEUsZ0JBQWdCLHlGQUF5RixjQUFjLE1BQU0sY0FBYyxvQkFBb0IsYUFBYSx3QkFBd0IsS0FBSyxjQUFjLFNBQVMsa0JBQWtCLGdCQUFnQixRQUFRLGFBQWEsb0JBQW9CLG9EQUFvRCxXQUFXLEtBQUssV0FBVyxzQkFBc0IsaUNBQWlDLGNBQWMsY0FBYyxTQUFTLGtCQUFrQixnQkFBZ0IsUUFBUSxhQUFhLG9CQUFvQixvREFBb0QsV0FBVyxLQUFLLFdBQVcsc0JBQXNCLGlDQUFpQyxjQUFjLGNBQWMsU0FBUyxrQkFBa0IsZ0JBQWdCLFFBQVEsYUFBYSxvQkFBb0Isb0RBQW9ELFdBQVcsS0FBSyxXQUFXLHNCQUFzQixpQ0FBaUMsY0FBYyxtQkFBbUIsY0FBYyw4QkFBOEIsV0FBVyx1REFBdUQsbUJBQW1CLG1DQUFtQyxlQUFlLFNBQVMsZUFBZSxtQkFBbUIsY0FBYyxTQUFTLGdCQUFnQixnQkFBZ0IsZ0JBQWdCLGVBQWUsU0FBUyxnQkFBZ0IsZ0JBQWdCLGdCQUFnQixlQUFlLGdCQUFnQixnQkFBZ0IsZ0JBQWdCLGdCQUFnQixnQkFBZ0IsZUFBZSxvSEFBb0gsZUFBZSxvSEFBb0gsY0FBYyxrQkFBa0IsZUFBZSxTQUFTLGtCQUFrQiw0VkFBNFYsa0JBQWtCLHlQQUF5UCxvQ0FBb0MsMEZBQTBGLHdEQUF3RCxzRkFBc0YsZ0JBQWdCLGlSQUFpUiw0VkFBNFYsZUFBZSxVQUFVLGdCQUFnQixzQkFBc0IsK0JBQStCLGNBQWMsbUVBQW1FLG1FQUFtRSx3QkFBd0IsNEJBQTRCLHdKQUF3SixTQUFTLGNBQWMsTUFBTSxlQUFlLGtCQUFrQixVQUFVLHVCQUF1Qix5QkFBeUIsMENBQTBDLGtDQUFrQyxlQUFlLGVBQWUsZ0NBQWdDLFlBQVksS0FBSyxNQUFNLGlCQUFpQiwwQkFBMEIsV0FBVyxtRUFBbUUsR0FBRyxJQUFJLHNDQUFzQyxRQUFRLFFBQVEsVUFBVSxTQUFTLGNBQWMsU0FBUyxrQkFBa0IsUUFBUSxtQ0FBbUMsVUFBVSw0QkFBNEIsV0FBVyxrQ0FBa0MsNEJBQTRCLEtBQUssa0JBQWtCLFdBQVcscUJBQXFCLFFBQVEsOEJBQThCLGNBQWMsbUJBQW1CLGdCQUFnQiwySEFBMkgsY0FBYyxVQUFVLGNBQWMsVUFBVSxlQUFlLFVBQVUscUJBQXFCLGdCQUFnQixJQUFJLEtBQUssa0NBQWtDLEtBQUssWUFBWSxJQUFJLHFCQUFxQixLQUFLLHVCQUF1QixjQUFjLFVBQVUsb0JBQW9CLHVCQUF1Qix1RUFBdUUsd0JBQXdCLDJDQUEyQyxTQUFTLDBCQUEwQixpREFBaUQsa0NBQWtDLEtBQUssOEJBQThCLFVBQVUsNEJBQTRCLElBQUksWUFBWSxJQUFJLHlCQUF5QixTQUFTLG9CQUFvQixXQUFXLElBQUksa0JBQWtCLFNBQVMseUJBQXlCLFNBQVMsb0JBQW9CLFdBQVcsSUFBSSxrQkFBa0IsU0FBUyx5QkFBeUIsU0FBUyxlQUFlLFdBQVcsSUFBSSxlQUFlLFNBQVMseUJBQXlCLFNBQVMsaUJBQWlCLFdBQVcsSUFBSSxnQkFBZ0IsU0FBUyx5QkFBeUIsU0FBUyxtQkFBbUIsV0FBVyxJQUFJLGtCQUFrQixTQUFTLHlCQUF5QixTQUFTLG1CQUFtQixXQUFXLElBQUksa0JBQWtCLFNBQVMseUJBQXlCLFNBQVMsbUJBQW1CLFdBQVcsSUFBSSxrQkFBa0IsU0FBUyx5QkFBeUIsU0FBUyxxQkFBcUIsV0FBVyxJQUFJLG9CQUFvQixTQUFTLHlCQUF5QixTQUFTLHVCQUF1QixXQUFXLElBQUksc0JBQXNCLFNBQVMseUJBQXlCLFNBQVMseUJBQXlCLFdBQVcsSUFBSSx3QkFBd0IsU0FBUyx5QkFBeUIsU0FBUyx5QkFBeUIsV0FBVyxJQUFJLHdCQUF3QixTQUFTLHlCQUF5QixTQUFTLDJCQUEyQixXQUFXLElBQUksMEJBQTBCLFNBQVMseUJBQXlCLFNBQVMsNkJBQTZCLFdBQVcsSUFBSSw0QkFBNEIsU0FBUyx5QkFBeUIsU0FBUyxxQ0FBcUMsV0FBVyxJQUFJLG9DQUFvQyxTQUFTLHlCQUF5QixTQUFTLDZCQUE2QixXQUFXLElBQUksMkJBQTJCLFNBQVMseUJBQXlCLFNBQVMsMkJBQTJCLFdBQVcsSUFBSSx5QkFBeUIsU0FBUyx5QkFBeUIsU0FBUyx1QkFBdUIsV0FBVyxJQUFJLHFCQUFxQixTQUFTLHlCQUF5QixTQUFTLHFCQUFxQixXQUFXLElBQUksbUJBQW1CLFNBQVMseUJBQXlCLFNBQVMsZUFBZSxXQUFXLElBQUksYUFBYSxTQUFTLHlCQUF5QixTQUFTLGlCQUFpQixXQUFXLElBQUksZUFBZSxTQUFTLHlCQUF5QixTQUFTLG1CQUFtQixXQUFXLElBQUksaUJBQWlCLFNBQVMseUJBQXlCLFNBQVMsZUFBZSxXQUFXLElBQUksUUFBUSxTQUFTLHlCQUF5QixTQUFTLGlCQUFpQixXQUFXLElBQUksU0FBUyxTQUFTLHlCQUF5QixTQUFTLG1CQUFtQixXQUFXLElBQUksV0FBVyxTQUFTLHlCQUF5QixTQUFTLHNCQUFzQixXQUFXLElBQUksYUFBYSxTQUFTLHlCQUF5QixTQUFTLHFCQUFxQixXQUFXLElBQUksYUFBYSxTQUFTLHlCQUF5QixTQUFTLHVCQUF1QixXQUFXLElBQUksZUFBZSxTQUFTLHlCQUF5QixTQUFTLHlCQUF5QixXQUFXLElBQUksaUJBQWlCLFNBQVMseUJBQXlCLFNBQVMsMkJBQTJCLFdBQVcsSUFBSSxtQkFBbUIsU0FBUyx5QkFBeUIsU0FBUyw2QkFBNkIsV0FBVyxJQUFJLHFCQUFxQixTQUFTLHlCQUF5QixTQUFTLGdDQUFnQyxXQUFXLElBQUksdUJBQXVCLFNBQVMseUJBQXlCLFNBQVMsbUNBQW1DLFdBQVcsSUFBSSwyQkFBMkIsU0FBUyx5QkFBeUIsU0FBUyw2Q0FBNkMsV0FBVyxJQUFJLHFDQUFxQyxTQUFTLHlCQUF5QixTQUFTLDhCQUE4QixXQUFXLElBQUksb0JBQW9CLFNBQVMseUJBQXlCLFNBQVMscUNBQXFDLFdBQVcsSUFBSSw0QkFBNEIsU0FBUyx5QkFBeUIsU0FBUyx5QkFBeUIsV0FBVyxJQUFJLGdCQUFnQixTQUFTLHlCQUF5QixTQUFTLGVBQWUsU0FBUyxlQUFlLEtBQUssMkJBQTJCLHFCQUFxQixZQUFZLGNBQWMsd0xBQXdMLGNBQWMsY0FBYyxjQUFjLGtCQUFrQixlQUFlLHNFQUFzRSwwQkFBMEIsb0JBQW9CLDZEQUE2RCx1QkFBdUIscUJBQXFCLFdBQVcsR0FBRyx1Q0FBdUMsaUJBQWlCLHFCQUFxQixLQUFLLEdBQUcsMENBQTBDLFdBQVcsR0FBRyxxQkFBcUIsb0NBQW9DLHFCQUFxQixTQUFTLHVCQUF1QixvREFBb0QsR0FBRyxPQUFPLE1BQU0sbUZBQW1GLDhCQUE4QixTQUFTLHFFQUFxRSxpSUFBaUksMEJBQTBCLG9CQUFvQixpRUFBaUUsa0dBQWtHLEdBQUcsYUFBYSxtQ0FBbUMsNERBQTRELHVCQUF1QixrREFBa0QsdUNBQXVDLGtFQUFrRSwwQ0FBMEMscUVBQXFFLHdDQUF3QyxtRUFBbUUsd0NBQXdDLG1FQUFtRSxnQ0FBZ0MsMkRBQTJELGlDQUFpQyw0REFBNEQsZ0NBQWdDLDJEQUEyRCxpQ0FBaUMsNERBQTRELCtCQUErQiwwREFBMEQsZ0NBQWdDLDJEQUEyRCx1QkFBdUIsa0RBQWtELCtCQUErQiwwREFBMEQsZ0NBQWdDLDJEQUEyRCxnQ0FBZ0MsMkRBQTJELG1DQUFtQyw4REFBOEQsb0NBQW9DLCtEQUErRCxvQ0FBb0MsK0RBQStELHNCQUFzQixpREFBaUQsK0JBQStCLDJEQUEyRCwrQkFBK0Isb0RBQW9ELHVCQUF1QixrREFBa0QseUJBQXlCLG9EQUFvRCxrQ0FBa0MsNkRBQTZELDJCQUEyQixzREFBc0QsMkJBQTJCLHNEQUFzRCw4QkFBOEIseURBQXlELDRCQUE0Qix1REFBdUQsa0NBQWtDLDZEQUE2RCx3Q0FBd0MsbUVBQW1FLDJCQUEyQixzREFBc0QsZ0NBQWdDLDJEQUEyRCw2QkFBNkIsd0RBQXdELGlDQUFpQyw0REFBNEQsOEJBQThCLHlEQUF5RCxtQ0FBbUMsOERBQThELDZCQUE2Qix3REFBd0QsNEJBQTRCLHVEQUF1RCxpQ0FBaUMsNERBQTRELDhCQUE4QiwwREFBMEQsY0FBYyxhQUFhLG1DQUFtQyxrSUFBa0ksaUJBQWlCLEVBQUUsd0JBQXdCLGFBQWEsTUFBTSxXQUFXLG1FQUFtRSxnQkFBZ0IsS0FBSyx5RUFBeUUsdUJBQXVCLGdCQUFnQixTQUFTLFlBQVksbURBQW1ELGtCQUFrQixxRkFBcUYsbUJBQW1CLHFFQUFxRSxtQkFBbUIsbUJBQW1CLG9CQUFvQixFQUFFLFlBQVksYUFBYSxhQUFhLHNDQUFzQyxTQUFTLGlFQUFpRSxpQ0FBaUMsNkRBQTZELFNBQVMscUNBQXFDLGdCQUFnQiw2REFBNkQsaUVBQWlFLEtBQUsscUZBQXFGLGdCQUFnQixJQUFJLGVBQWUsYUFBYSxzQ0FBc0MsU0FBUyx5QkFBeUIsaUNBQWlDLG9CQUFvQiw0QkFBNEIsUUFBUSxtQkFBbUIsSUFBSSxxRUFBcUUsb0xBQW9MLG1CQUFtQixHQUFHLHVFQUF1RSwwSUFBMEksb0JBQW9CLEdBQUcsd0RBQXdELFFBQVEsMk1BQTJNLG9HQUFvRyxnRUFBZ0Usd0ZBQXdGLEdBQUcsSUFBSSxFQUFFLEdBQUcsU0FBUyxTQUFTLCtEQUErRCxlQUFlLGFBQWEsc0NBQXNDLFNBQVMsNkJBQTZCLGlDQUFpQyx3QkFBd0IsNEJBQTRCLFFBQVEsbUJBQW1CLEtBQUssb0JBQW9CLHNDQUFzQyxFQUFFLHdCQUF3QixxRUFBcUUsS0FBSyxJQUFJLHFGQUFxRixhQUFhLFVBQVUsd0JBQXdCLHFCQUFxQix3QkFBd0Isb0JBQW9CLGlFQUFpRSxFQUFFLElBQUksNEJBQTRCLHdOQUF3TixhQUFhLFVBQVUsMEJBQTBCLHdCQUF3Qix1REFBdUQsRUFBRSxJQUFJLG1CQUFtQixRQUFRLDZJQUE2SSxvTEFBb0wsbUJBQW1CLEdBQUcsdUVBQXVFLDBJQUEwSSxvQkFBb0IsR0FBRywwUUFBMFEsd0RBQXdELGtCQUFrQixrQ0FBa0MsVUFBVSwwQkFBMEIsTUFBTSw4QkFBOEIsNkNBQTZDLEVBQUUsR0FBRyxtQ0FBbUMsaUhBQWlILEVBQUUsSUFBSSx5SEFBeUgsZ0VBQWdFLGdHQUFnRyxHQUFHLElBQUksRUFBRSxHQUFHLFNBQVMsU0FBUyxtRUFBbUUsZUFBZSxhQUFhLHNDQUFzQyxTQUFTLDJCQUEyQixlQUFlLDBCQUEwQixvRUFBb0UsMENBQTBDLGVBQWUsYUFBYSxzQ0FBc0MsU0FBUyxzSkFBc0osMENBQTBDLGtCQUFrQiwwQ0FBMEMsd0VBQXdFLEVBQUUsSUFBSSxnQkFBZ0IsNEJBQTRCLHNEQUFzRCwwQ0FBMEMsaUNBQWlDLDRCQUE0QixpQkFBaUIsSUFBSSx3SEFBd0gsUUFBUSxnRUFBZ0UsNkVBQTZFLFlBQVksSUFBSSxLQUFLLGdDQUFnQyxxREFBcUQsb0NBQW9DLFlBQVksSUFBSSxLQUFLLGlDQUFpQyxzREFBc0Qsb0NBQW9DLGdDQUFnQyx5QkFBeUIsdUNBQXVDLHVDQUF1QyxzQkFBc0IsdUNBQXVDLDRDQUE0QywyQkFBMkIsaUZBQWlGLFlBQVksVUFBVSxvQkFBb0IscUJBQXFCLG9CQUFvQixxQkFBcUIsc0JBQXNCLHFCQUFxQix1QkFBdUIsdUJBQXVCLHdCQUF3QixzQkFBc0IscUJBQXFCLHVCQUF1QixrREFBa0QsRUFBRSxJQUFJLE9BQU8sVUFBVSxvQkFBb0IscUJBQXFCLG9CQUFvQixxQkFBcUIsc0JBQXNCLHFCQUFxQix1QkFBdUIsdUJBQXVCLHdCQUF3QixzQkFBc0IscUJBQXFCLHVCQUF1QixrREFBa0QsRUFBRSxJQUFJLE9BQU8sVUFBVSxrQ0FBa0MseUNBQXlDLDRCQUE0QixnQ0FBZ0MsOEJBQThCLDhCQUE4QixrQ0FBa0MsZ0NBQWdDLGlDQUFpQyxtQ0FBbUMsNkNBQTZDLEVBQUUsS0FBSyxvQkFBb0IsdUNBQXVDLDRDQUE0QyxpREFBaUQsYUFBYSxnQkFBZ0IsSUFBSSw2QkFBNkIsWUFBWSxJQUFJLEtBQUssb0NBQW9DLFFBQVEscUJBQXFCLHNDQUFzQyxVQUFVLFlBQVksV0FBVyxLQUFLLHFFQUFxRSxHQUFHLGtCQUFrQiw4Q0FBOEMscUdBQXFHLGlEQUFpRCxJQUFJLFVBQVUsZ0NBQWdDLGdEQUFnRCxtREFBbUQsVUFBVSxRQUFRLG1CQUFtQixzR0FBc0csSUFBSSw0QkFBNEIsWUFBWSxJQUFJLCtDQUErQyxZQUFZLElBQUksNENBQTRDLGlDQUFpQyxXQUFXLHFCQUFxQixJQUFJLEtBQUssNERBQTRELFVBQVUsSUFBSSxtSEFBbUgsRUFBRSxHQUFHLFVBQVUsdUJBQXVCLGlCQUFpQiw2Q0FBNkMsWUFBWSxJQUFJLDZCQUE2QixjQUFjLDhDQUE4Qyx3QkFBd0IsV0FBVyxVQUFVLFlBQVksSUFBSSxLQUFLLHVEQUF1RCw0QkFBNEIsZ0JBQWdCLEtBQUsscUJBQXFCLDZHQUE2RyxRQUFRLHNFQUFzRSxrQkFBa0IseURBQXlELEVBQUUsSUFBSSxRQUFRLG1CQUFtQixRQUFRLGlHQUFpRyxvQkFBb0IsdUNBQXVDLDRDQUE0QyxxQ0FBcUMsNERBQTRELGNBQWMsa0NBQWtDLFdBQVcsa0JBQWtCLGFBQWEsOENBQThDLFVBQVUscUJBQXFCLGFBQWEsbUVBQW1FLGtCQUFrQiwyQ0FBMkMsOERBQThELDZCQUE2QixhQUFhLCtCQUErQixtQkFBbUIsNEJBQTRCLGdFQUFnRSxtQ0FBbUMsc0JBQXNCLEVBQUUsZUFBZSxZQUFZLHlDQUF5Qyw0QkFBNEIsU0FBUyw2RkFBNkYsZ0JBQWdCLDJDQUEyQywwQkFBMEIsWUFBWSxzQ0FBc0MsU0FBUyx5REFBeUQsdUNBQXVDLHFCQUFxQixpSEFBaUgsa0NBQWtDLDhCQUE4QixnRkFBZ0YsNkVBQTZFLEtBQUssMkRBQTJELElBQUksb1JBQW9SLFNBQVMsVUFBVSxlQUFlLElBQUkseUtBQXlLLFNBQVMsVUFBVSw4SEFBOEgsU0FBUyxXQUFXLGdDQUFnQyxpQkFBaUIsU0FBUyxLQUFLLGdDQUFnQyx5QkFBeUIsK0dBQStHLHVCQUF1Qix3Q0FBd0MsMEZBQTBGLEtBQUsseUNBQXlDLGVBQWUsU0FBUyxjQUFjLElBQUksRUFBRSxvQ0FBb0MsdUJBQXVCLEVBQUUsZUFBZSxrQkFBa0IsT0FBTyxlQUFlLEdBQUcsdUdBQXVHLEVBQUUsS0FBSyxvQkFBb0IsaUJBQWlCLHVEQUF1RCxnQkFBZ0IsTUFBTSxvR0FBb0csU0FBUyxhQUFhLHlCQUF5QixRQUFRLHVHQUF1RyxNQUFNLCtDQUErQyw4QkFBOEIsT0FBTyxJQUFJLG9CQUFvQixzQkFBc0IsK0NBQStDLGdCQUFnQiwyQ0FBMkMsbUNBQW1DLHlCQUF5QixpQkFBaUIsa0NBQWtDLGVBQWUsb0JBQW9CLEVBQUUsMkJBQTJCLHNEQUFzRCw2Q0FBNkMsc0JBQXNCLHNEQUFzRCxhQUFhLDhDQUE4QyxFQUFFLDJCQUEyQiwrQ0FBK0Msd0NBQXdDLCtCQUErQixrQkFBa0Isb0JBQW9CLElBQUksd0JBQXdCLDRMQUE0TCxLQUFLLDRDQUE0Qyx3Q0FBd0MscUNBQXFDLElBQUksR0FBRyw0QkFBNEIsZ09BQWdPLGtDQUFrQyxjQUFjLElBQUksb0RBQW9ELFNBQVMsZ0JBQWdCLHdDQUF3Qyw2REFBNkQsc1JBQXNSLFNBQVMsOEpBQThKLE1BQU0sV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFlBQVksTUFBTSxjQUFjLFdBQVcsK0JBQStCLFlBQVksWUFBWSxvREFBb0QsZUFBZSxpREFBaUQsSUFBSSwyQ0FBMkMsU0FBUywwQ0FBMEMsU0FBUyxhQUFhLHdCQUF3QixtQkFBbUIsb0JBQW9CLDhFQUE4RSxpQkFBaUIsb0JBQW9CLHVCQUF1QixJQUFJLE1BQU0sbUJBQW1CLE1BQU0sNEJBQTRCLFdBQVcsZ0NBQWdDLGdCQUFnQixFQUFFLFNBQVMsYUFBYSxzQkFBc0IsRUFBRSxNQUFNLDBCQUEwQixNQUFNLFFBQVEsNENBQTRDLGFBQWEsNkJBQTZCLEVBQUUsU0FBUyxhQUFhLDZCQUE2QixFQUFFLE1BQU0sMEJBQTBCLE1BQU0sc0JBQXNCLDhDQUE4QyxhQUFhLDZCQUE2QixFQUFFLFNBQVMsYUFBYSw2QkFBNkIsRUFBRSxNQUFNLGlCQUFpQixNQUFNLGtCQUFrQixzQ0FBc0MsYUFBYSxvQkFBb0IsRUFBRSxTQUFTLGFBQWEsb0JBQW9CLEVBQUUsTUFBTSxrQkFBa0Isa0JBQWtCLHFDQUFxQyxlQUFlLEVBQUUsU0FBUyxhQUFhLHFCQUFxQixFQUFFLE1BQU0sY0FBYyxNQUFNLDhEQUE4RCxrQ0FBa0MsYUFBYSxpQkFBaUIsc0NBQXNDLFNBQVMsYUFBYSxpQkFBaUIsRUFBRSxNQUFNLHdCQUF3QixrQkFBa0IsbUNBQW1DLHFCQUFxQixFQUFFLFNBQVMsYUFBYSwyQkFBMkIsS0FBSyxJQUFJLElBQUksNkJBQTZCLFNBQVMsYUFBYSw0QkFBNEIsbUJBQW1CLElBQUksSUFBSSxNQUFNLElBQUksa0JBQWtCLFNBQVMsdUdBQXVHLGdFQUFnRSw4QkFBOEIsU0FBUyxpRkFBaUYsU0FBUyxvREFBb0QsdUJBQXVCLFVBQVUsYUFBYSx3QkFBd0IsUUFBUSx1R0FBdUcsTUFBTSwrQ0FBK0MsOEJBQThCLE9BQU8sSUFBSSxvQkFBb0Isc0JBQXNCLCtDQUErQyxnQkFBZ0IsMkNBQTJDLG1DQUFtQyx5QkFBeUIsaUJBQWlCLGtDQUFrQyxlQUFlLG9CQUFvQixFQUFFLDJCQUEyQixzREFBc0QsMkNBQTJDLHNCQUFzQixzREFBc0QsYUFBYSw4Q0FBOEMsRUFBRSwyQkFBMkIsK0NBQStDLHdDQUF3QywrQkFBK0Isa0JBQWtCLG9CQUFvQixJQUFJLHdCQUF3Qiw0TEFBNEwsS0FBSyw0Q0FBNEMsd0NBQXdDLHFDQUFxQyxJQUFJLEdBQUcsNEJBQTRCLGdPQUFnTyxrQ0FBa0MsY0FBYyxJQUFJLG9EQUFvRCxTQUFTLGdCQUFnQix3Q0FBd0MsNkRBQTZELHNSQUFzUixTQUFTLDhKQUE4SixJQUFJLFVBQVUsYUFBYSw0Q0FBNEMsWUFBWSxZQUFZLFlBQVksWUFBWSxXQUFXLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLGdCQUFnQixhQUFhLGNBQWMsa0JBQWtCLEVBQUUsU0FBUywrR0FBK0csNEJBQTRCLDRNQUE0TSwyQkFBMkIsNkJBQTZCLDhDQUE4Qyx1Q0FBdUMsMENBQTBDLHFDQUFxQywwQ0FBMEMsbURBQW1ELFNBQVMsZ0JBQWdCLHdNQUF3TSxzQ0FBc0Msd01BQXdNLCtDQUErQyxzQkFBc0IsMkNBQTJDLGVBQWUsNkNBQTZDLHFGQUFxRix3Q0FBd0MsbUNBQW1DLG1EQUFtRCxpQkFBaUIsRUFBRSx5QkFBeUIsMkVBQTJFLFlBQVkscUNBQXFDLFlBQVksSUFBSSxzQ0FBc0MsMkNBQTJDLG1DQUFtQyw0Q0FBNEMsb0NBQW9DLDRDQUE0QyxvQ0FBb0MsNENBQTRDLG9DQUFvQyw4Q0FBOEMsc0NBQXNDLDhDQUE4QyxzQ0FBc0MseUNBQXlDLGlDQUFpQywwQ0FBMEMsa0NBQWtDLDBDQUEwQyxrQ0FBa0MsMENBQTBDLGtDQUFrQyw0Q0FBNEMsb0NBQW9DLDRDQUE0QyxvQ0FBb0Msa0RBQWtELDREQUE0RCxtREFBbUQsNkRBQTZELG1EQUFtRCw2REFBNkQsbURBQW1ELG1FQUFtRSxxREFBcUQsK0RBQStELHFEQUFxRCwrREFBK0Qsb0RBQW9ELDhEQUE4RCxvREFBb0Qsb0NBQW9DLHdDQUF3QyxzRkFBc0YsMENBQTBDLDBGQUEwRixzQ0FBc0MsNkJBQTZCLHVDQUF1QyxxQ0FBcUMsc0NBQXNDLG1CQUFtQix1RkFBdUYsc0NBQXNDLHlEQUF5RCwyQ0FBMkMsd0VBQXdFLDZDQUE2QywwRUFBMEUsWUFBWSxJQUFJLHFCQUFxQixpREFBaUQsMENBQTBDLDBHQUEwRyxpQkFBaUIsK0NBQStDLHdCQUF3QixLQUFLLGNBQWMsS0FBSyx3REFBd0QsbUNBQW1DLDJCQUEyQixpQkFBaUIscUJBQXFCLFVBQVUsc0JBQXNCLEtBQUsseUNBQXlDLDRCQUE0Qix5QkFBeUIsSUFBSSwrRUFBK0Usa0JBQWtCLE9BQU8sNkxBQTZMLDRDQUE0QywrQkFBK0IsTUFBTSxRQUFRLGdNQUFnTSxxQ0FBcUMsS0FBSyxvQ0FBb0MsMElBQTBJLHNEQUFzRCxvQkFBb0IsaURBQWlELG9EQUFvRCxxRkFBcUYsaURBQWlELHNGQUFzRiwwQ0FBMEMsNERBQTRELDhDQUE4QyxtQ0FBbUMsS0FBSyxLQUFLLFlBQVksV0FBVyxFQUFFLDBCQUEwQiw2TUFBNk0sNkZBQTZGLHVDQUF1QyxXQUFXLGdCQUFnQix3QkFBd0IsOENBQThDLDBCQUEwQiwwQkFBMEIsK0JBQStCLG1DQUFtQywyQ0FBMkMseUNBQXlDLGlCQUFpQix5Q0FBeUMsbUJBQW1CLDRDQUE0QyxzQkFBc0IsZ0RBQWdELGlCQUFpQiw0Q0FBNEMsMEJBQTBCLDZDQUE2QyxpQ0FBaUMsOENBQThDLHNCQUFzQiw4Q0FBOEMsa0NBQWtDLCtDQUErQywwQ0FBMEMsOENBQThDLG9GQUFvRiwrQ0FBK0MsNkJBQTZCLDhDQUE4Qyx5REFBeUQsK0NBQStDLDJEQUEyRCxnREFBZ0QsaURBQWlELGdEQUFnRCxzSEFBc0gsZ0RBQWdELGlCQUFpQixpREFBaUQsaUJBQWlCLGlEQUFpRCx1Q0FBdUMsa0RBQWtELHVDQUF1QyxpREFBaUQscUZBQXFGLGtEQUFrRCxxRkFBcUYsaURBQWlELHFEQUFxRCxrREFBa0QsdURBQXVELG1EQUFtRCw2Q0FBNkMsbURBQW1ELG1IQUFtSCx1REFBdUQsNkpBQTZKLGlCQUFpQiwyQkFBMkIseUVBQXlFLFNBQVMsK0NBQStDLDBCQUEwQixpREFBaUQsOENBQThDLGdEQUFnRCwrQ0FBK0MscUJBQXFCLGlDQUFpQyxnRkFBZ0YsS0FBSyxJQUFJLEVBQUUsOEJBQThCLGFBQWEsS0FBSyw0QkFBNEIsMEJBQTBCLEtBQUssNEJBQTRCLDJGQUEyRixrR0FBa0csU0FBUywrQ0FBK0MsMkJBQTJCLDZDQUE2Qyx3Q0FBd0MsaURBQWlELDJDQUEyQyxxREFBcUQsK0hBQStILFlBQVksMkJBQTJCLDhFQUE4RSxTQUFTLGlEQUFpRCw0QkFBNEIsNkJBQTZCLFNBQVMsaUNBQW1CLElBQUksa0NBQWtDLCtCQUErQixtQ0FBbUMsWUFBWSx5REFBeUQsaUNBQW1CLFlBQVksaUNBQW1CLE9BQU8sMENBQTBDLE9BQU8saUNBQW1CLE1BQU0sSUFBSSxJQUFJLENBQUMsaUNBQW1CLFdBQVcsZUFBZSxpQ0FBbUIsVUFBVSxpQ0FBbUIsb0NBQW9DLHVCQUF1QixFQUFFLENBQUMsaUNBQW1CLGNBQWMsaURBQWlELElBQUksMkNBQTJDLFNBQVMsMENBQTBDLEdBQUcsaUNBQW1CLG9EQUFvRCxpQ0FBbUIsT0FBTyw0RkFBNEYsZUFBZSx3Q0FBd0MsU0FBUyxHQUFHLElBQUksMEJBQW1CLENBQUMsaUNBQW1CLE9BQU8sT0FBTywwQkFBbUIsQ0FBQztBQUN0MnRoQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvb25ueHJ1bnRpbWUtd2ViL2Rpc3Qvb3J0LXdlYi5taW4uanM/YzNmNyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiogT05OWCBSdW50aW1lIFdlYiB2MS4xNC4wXG4qIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4qL1xuIWZ1bmN0aW9uKHQsZSl7aWYoXCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHMmJlwib2JqZWN0XCI9PXR5cGVvZiBtb2R1bGUpbW9kdWxlLmV4cG9ydHM9ZShyZXF1aXJlKFwib25ueHJ1bnRpbWUtY29tbW9uXCIpKTtlbHNlIGlmKFwiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZClkZWZpbmUoW10sZSk7ZWxzZXt2YXIgbj1cIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cz9lKHJlcXVpcmUoXCJvbm54cnVudGltZS1jb21tb25cIikpOmUodC5vcnQpO2Zvcih2YXIgciBpbiBuKShcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cz9leHBvcnRzOnQpW3JdPW5bcl19fShzZWxmLChfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX18xNjcwX189PigoKT0+e3ZhciBfX3dlYnBhY2tfbW9kdWxlc19fPXszNDc0Oih0LGUsbik9Pnt2YXIgX3NjcmlwdERpcixyPShfc2NyaXB0RGlyPShfc2NyaXB0RGlyPVwidW5kZWZpbmVkXCIhPXR5cGVvZiBkb2N1bWVudCYmZG9jdW1lbnQuY3VycmVudFNjcmlwdD9kb2N1bWVudC5jdXJyZW50U2NyaXB0LnNyYzp2b2lkIDApfHxcIi9pbmRleC5qc1wiLGZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUoKXtyZXR1cm4gJC5idWZmZXIhPUMmJkgoJC5idWZmZXIpLEZ9ZnVuY3Rpb24gcigpe3JldHVybiAkLmJ1ZmZlciE9QyYmSCgkLmJ1ZmZlciksTn1mdW5jdGlvbiBpKCl7cmV0dXJuICQuYnVmZmVyIT1DJiZIKCQuYnVmZmVyKSxMfWZ1bmN0aW9uIG8oKXtyZXR1cm4gJC5idWZmZXIhPUMmJkgoJC5idWZmZXIpLFJ9ZnVuY3Rpb24gYSgpe3JldHVybiAkLmJ1ZmZlciE9QyYmSCgkLmJ1ZmZlciksan12YXIgcyx1LGM7dD10fHx7fSxzfHwocz12b2lkIDAhPT10P3Q6e30pLHMucmVhZHk9bmV3IFByb21pc2UoKGZ1bmN0aW9uKHQsZSl7dT10LGM9ZX0pKTt2YXIgbCxwLGYsZCxoLGcsYj1PYmplY3QuYXNzaWduKHt9LHMpLG09XCIuL3RoaXMucHJvZ3JhbVwiLHk9KHQsZSk9Pnt0aHJvdyBlfSxfPVwib2JqZWN0XCI9PXR5cGVvZiB3aW5kb3csdj1cImZ1bmN0aW9uXCI9PXR5cGVvZiBpbXBvcnRTY3JpcHRzLHc9XCJvYmplY3RcIj09dHlwZW9mIHByb2Nlc3MmJlwib2JqZWN0XCI9PXR5cGVvZiBwcm9jZXNzLnZlcnNpb25zJiZcInN0cmluZ1wiPT10eXBlb2YgcHJvY2Vzcy52ZXJzaW9ucy5ub2RlLHg9cy5FTlZJUk9OTUVOVF9JU19QVEhSRUFEfHwhMSxUPVwiXCI7ZnVuY3Rpb24gUyh0KXtyZXR1cm4gcy5sb2NhdGVGaWxlP3MubG9jYXRlRmlsZSh0LFQpOlQrdH1pZih3KXtsZXQgZTtUPXY/big5MDgpLmRpcm5hbWUoVCkrXCIvXCI6XCIvL1wiLGc9KCk9PntofHwoZD1uKDEzODQpLGg9big5MDgpKX0sbD1mdW5jdGlvbih0LGUpe3JldHVybiBnKCksdD1oLm5vcm1hbGl6ZSh0KSxkLnJlYWRGaWxlU3luYyh0LGU/dm9pZCAwOlwidXRmOFwiKX0sZj10PT4oKHQ9bCh0LCEwKSkuYnVmZmVyfHwodD1uZXcgVWludDhBcnJheSh0KSksdCkscD0odCxlLG4pPT57ZygpLHQ9aC5ub3JtYWxpemUodCksZC5yZWFkRmlsZSh0LChmdW5jdGlvbih0LHIpe3Q/bih0KTplKHIuYnVmZmVyKX0pKX0sMTxwcm9jZXNzLmFyZ3YubGVuZ3RoJiYobT1wcm9jZXNzLmFyZ3ZbMV0ucmVwbGFjZSgvXFxcXC9nLFwiL1wiKSkscHJvY2Vzcy5hcmd2LnNsaWNlKDIpLHByb2Nlc3Mub24oXCJ1bmNhdWdodEV4Y2VwdGlvblwiLChmdW5jdGlvbih0KXtpZighKHQgaW5zdGFuY2VvZiB1dCkpdGhyb3cgdH0pKSxwcm9jZXNzLm9uKFwidW5oYW5kbGVkUmVqZWN0aW9uXCIsKGZ1bmN0aW9uKHQpe3Rocm93IHR9KSkseT0odCxlKT0+e2lmKEooKSl0aHJvdyBwcm9jZXNzLmV4aXRDb2RlPXQsZTtlIGluc3RhbmNlb2YgdXR8fFAoXCJleGl0aW5nIGR1ZSB0byBleGNlcHRpb246IFwiK2UpLHByb2Nlc3MuZXhpdCh0KX0scy5pbnNwZWN0PWZ1bmN0aW9uKCl7cmV0dXJuXCJbRW1zY3JpcHRlbiBNb2R1bGUgb2JqZWN0XVwifTt0cnl7ZT1uKDk5MjUpfWNhdGNoKHQpe3Rocm93IGNvbnNvbGUuZXJyb3IoJ1RoZSBcIndvcmtlcl90aHJlYWRzXCIgbW9kdWxlIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBub2RlLmpzIGJ1aWxkIC0gcGVyaGFwcyBhIG5ld2VyIHZlcnNpb24gaXMgbmVlZGVkPycpLHR9bi5nLldvcmtlcj1lLldvcmtlcn1lbHNlKF98fHYpJiYodj9UPXNlbGYubG9jYXRpb24uaHJlZjpcInVuZGVmaW5lZFwiIT10eXBlb2YgZG9jdW1lbnQmJmRvY3VtZW50LmN1cnJlbnRTY3JpcHQmJihUPWRvY3VtZW50LmN1cnJlbnRTY3JpcHQuc3JjKSxfc2NyaXB0RGlyJiYoVD1fc2NyaXB0RGlyKSxUPTAhPT1ULmluZGV4T2YoXCJibG9iOlwiKT9ULnN1YnN0cigwLFQucmVwbGFjZSgvWz8jXS4qLyxcIlwiKS5sYXN0SW5kZXhPZihcIi9cIikrMSk6XCJcIix3fHwobD10PT57dmFyIGU9bmV3IFhNTEh0dHBSZXF1ZXN0O3JldHVybiBlLm9wZW4oXCJHRVRcIix0LCExKSxlLnNlbmQobnVsbCksZS5yZXNwb25zZVRleHR9LHYmJihmPXQ9Pnt2YXIgZT1uZXcgWE1MSHR0cFJlcXVlc3Q7cmV0dXJuIGUub3BlbihcIkdFVFwiLHQsITEpLGUucmVzcG9uc2VUeXBlPVwiYXJyYXlidWZmZXJcIixlLnNlbmQobnVsbCksbmV3IFVpbnQ4QXJyYXkoZS5yZXNwb25zZSl9KSxwPSh0LGUsbik9Pnt2YXIgcj1uZXcgWE1MSHR0cFJlcXVlc3Q7ci5vcGVuKFwiR0VUXCIsdCwhMCksci5yZXNwb25zZVR5cGU9XCJhcnJheWJ1ZmZlclwiLHIub25sb2FkPSgpPT57MjAwPT1yLnN0YXR1c3x8MD09ci5zdGF0dXMmJnIucmVzcG9uc2U/ZShyLnJlc3BvbnNlKTpuKCl9LHIub25lcnJvcj1uLHIuc2VuZChudWxsKX0pKTt3JiZcInVuZGVmaW5lZFwiPT10eXBlb2YgcGVyZm9ybWFuY2UmJihuLmcucGVyZm9ybWFuY2U9big2OTUzKS5wZXJmb3JtYW5jZSk7dmFyIE89Y29uc29sZS5sb2cuYmluZChjb25zb2xlKSxBPWNvbnNvbGUud2Fybi5iaW5kKGNvbnNvbGUpO3cmJihnKCksTz10PT5kLndyaXRlU3luYygxLHQrXCJcXG5cIiksQT10PT5kLndyaXRlU3luYygyLHQrXCJcXG5cIikpO3ZhciBFLEk9cy5wcmludHx8TyxQPXMucHJpbnRFcnJ8fEE7T2JqZWN0LmFzc2lnbihzLGIpLGI9bnVsbCxzLnRoaXNQcm9ncmFtJiYobT1zLnRoaXNQcm9ncmFtKSxzLnF1aXQmJih5PXMucXVpdCkscy53YXNtQmluYXJ5JiYoRT1zLndhc21CaW5hcnkpO3ZhciBEPXMubm9FeGl0UnVudGltZXx8ITE7XCJvYmplY3RcIiE9dHlwZW9mIFdlYkFzc2VtYmx5JiZpdChcIm5vIG5hdGl2ZSB3YXNtIHN1cHBvcnQgZGV0ZWN0ZWRcIik7dmFyICQsayxDLEYsTixMLFIsaixNPSExLFU9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIFRleHREZWNvZGVyP25ldyBUZXh0RGVjb2RlcihcInV0ZjhcIik6dm9pZCAwO2Z1bmN0aW9uIFYodCxlLG4pe3ZhciByPShlPj4+PTApK247Zm9yKG49ZTt0W25dJiYhKG4+PXIpOykrK247aWYoMTY8bi1lJiZ0LmJ1ZmZlciYmVSlyZXR1cm4gVS5kZWNvZGUodC5idWZmZXIgaW5zdGFuY2VvZiBTaGFyZWRBcnJheUJ1ZmZlcj90LnNsaWNlKGUsbik6dC5zdWJhcnJheShlLG4pKTtmb3Iocj1cIlwiO2U8bjspe3ZhciBpPXRbZSsrXTtpZigxMjgmaSl7dmFyIG89NjMmdFtlKytdO2lmKDE5Mj09KDIyNCZpKSlyKz1TdHJpbmcuZnJvbUNoYXJDb2RlKCgzMSZpKTw8NnxvKTtlbHNle3ZhciBhPTYzJnRbZSsrXTs2NTUzNj4oaT0yMjQ9PSgyNDAmaSk/KDE1JmkpPDwxMnxvPDw2fGE6KDcmaSk8PDE4fG88PDEyfGE8PDZ8NjMmdFtlKytdKT9yKz1TdHJpbmcuZnJvbUNoYXJDb2RlKGkpOihpLT02NTUzNixyKz1TdHJpbmcuZnJvbUNoYXJDb2RlKDU1Mjk2fGk+PjEwLDU2MzIwfDEwMjMmaSkpfX1lbHNlIHIrPVN0cmluZy5mcm9tQ2hhckNvZGUoaSl9cmV0dXJuIHJ9ZnVuY3Rpb24gQih0LGUpe3JldHVybih0Pj4+PTApP1YocigpLHQsZSk6XCJcIn1mdW5jdGlvbiB6KHQsZSxuLHIpe2lmKCEoMDxyKSlyZXR1cm4gMDt2YXIgaT1uPj4+PTA7cj1uK3ItMTtmb3IodmFyIG89MDtvPHQubGVuZ3RoOysrbyl7dmFyIGE9dC5jaGFyQ29kZUF0KG8pO2lmKDU1Mjk2PD1hJiY1NzM0Mz49YSYmKGE9NjU1MzYrKCgxMDIzJmEpPDwxMCl8MTAyMyZ0LmNoYXJDb2RlQXQoKytvKSksMTI3Pj1hKXtpZihuPj1yKWJyZWFrO2VbbisrPj4+MF09YX1lbHNle2lmKDIwNDc+PWEpe2lmKG4rMT49cilicmVhaztlW24rKz4+PjBdPTE5MnxhPj42fWVsc2V7aWYoNjU1MzU+PWEpe2lmKG4rMj49cilicmVhaztlW24rKz4+PjBdPTIyNHxhPj4xMn1lbHNle2lmKG4rMz49cilicmVhaztlW24rKz4+PjBdPTI0MHxhPj4xOCxlW24rKz4+PjBdPTEyOHxhPj4xMiY2M31lW24rKz4+PjBdPTEyOHxhPj42JjYzfWVbbisrPj4+MF09MTI4fDYzJmF9fXJldHVybiBlW24+Pj4wXT0wLG4taX1mdW5jdGlvbiBHKHQpe2Zvcih2YXIgZT0wLG49MDtuPHQubGVuZ3RoOysrbil7dmFyIHI9dC5jaGFyQ29kZUF0KG4pOzEyNz49cj9lKys6MjA0Nz49cj9lKz0yOjU1Mjk2PD1yJiY1NzM0Mz49cj8oZSs9NCwrK24pOmUrPTN9cmV0dXJuIGV9ZnVuY3Rpb24gSCh0KXtDPXQscy5IRUFQOD1GPW5ldyBJbnQ4QXJyYXkodCkscy5IRUFQMTY9bmV3IEludDE2QXJyYXkodCkscy5IRUFQMzI9TD1uZXcgSW50MzJBcnJheSh0KSxzLkhFQVBVOD1OPW5ldyBVaW50OEFycmF5KHQpLHMuSEVBUFUxNj1uZXcgVWludDE2QXJyYXkodCkscy5IRUFQVTMyPVI9bmV3IFVpbnQzMkFycmF5KHQpLHMuSEVBUEYzMj1uZXcgRmxvYXQzMkFycmF5KHQpLHMuSEVBUEY2ND1qPW5ldyBGbG9hdDY0QXJyYXkodCl9eCYmKEM9cy5idWZmZXIpO3ZhciBXPXMuSU5JVElBTF9NRU1PUll8fDE2Nzc3MjE2O2lmKHgpJD1zLndhc21NZW1vcnksQz1zLmJ1ZmZlcjtlbHNlIGlmKHMud2FzbU1lbW9yeSkkPXMud2FzbU1lbW9yeTtlbHNlIGlmKCEoKCQ9bmV3IFdlYkFzc2VtYmx5Lk1lbW9yeSh7aW5pdGlhbDpXLzY1NTM2LG1heGltdW06NjU1MzYsc2hhcmVkOiEwfSkpLmJ1ZmZlciBpbnN0YW5jZW9mIFNoYXJlZEFycmF5QnVmZmVyKSl0aHJvdyBQKFwicmVxdWVzdGVkIGEgc2hhcmVkIFdlYkFzc2VtYmx5Lk1lbW9yeSBidXQgdGhlIHJldHVybmVkIGJ1ZmZlciBpcyBub3QgYSBTaGFyZWRBcnJheUJ1ZmZlciwgaW5kaWNhdGluZyB0aGF0IHdoaWxlIHRoZSBicm93c2VyIGhhcyBTaGFyZWRBcnJheUJ1ZmZlciBpdCBkb2VzIG5vdCBoYXZlIFdlYkFzc2VtYmx5IHRocmVhZHMgc3VwcG9ydCAtIHlvdSBtYXkgbmVlZCB0byBzZXQgYSBmbGFnXCIpLHcmJmNvbnNvbGUubG9nKFwiKG9uIG5vZGUgeW91IG1heSBuZWVkOiAtLWV4cGVyaW1lbnRhbC13YXNtLXRocmVhZHMgLS1leHBlcmltZW50YWwtd2FzbS1idWxrLW1lbW9yeSBhbmQgYWxzbyB1c2UgYSByZWNlbnQgdmVyc2lvbilcIiksRXJyb3IoXCJiYWQgbWVtb3J5XCIpOyQmJihDPSQuYnVmZmVyKSxXPUMuYnl0ZUxlbmd0aCxIKEMpO3ZhciBxLFg9W10sWT1bXSxLPVtdLFo9W107ZnVuY3Rpb24gSigpe3JldHVybiBEfHwhMX1mdW5jdGlvbiBRKCl7dmFyIHQ9cy5wcmVSdW4uc2hpZnQoKTtYLnVuc2hpZnQodCl9dmFyIHR0LGV0PTAsbnQ9bnVsbCxydD1udWxsO2Z1bmN0aW9uIGl0KHQpe3Rocm93IHg/cG9zdE1lc3NhZ2Uoe2NtZDpcIm9uQWJvcnRcIixhcmc6dH0pOnMub25BYm9ydCYmcy5vbkFib3J0KHQpLFAodD1cIkFib3J0ZWQoXCIrdCtcIilcIiksTT0hMCx0PW5ldyBXZWJBc3NlbWJseS5SdW50aW1lRXJyb3IodCtcIi4gQnVpbGQgd2l0aCAtc0FTU0VSVElPTlMgZm9yIG1vcmUgaW5mby5cIiksYyh0KSx0fWZ1bmN0aW9uIG90KCl7cmV0dXJuIHR0LnN0YXJ0c1dpdGgoXCJkYXRhOmFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbTtiYXNlNjQsXCIpfWZ1bmN0aW9uIGF0KCl7dmFyIHQ9dHQ7dHJ5e2lmKHQ9PXR0JiZFKXJldHVybiBuZXcgVWludDhBcnJheShFKTtpZihmKXJldHVybiBmKHQpO3Rocm93XCJib3RoIGFzeW5jIGFuZCBzeW5jIGZldGNoaW5nIG9mIHRoZSB3YXNtIGZhaWxlZFwifWNhdGNoKHQpe2l0KHQpfX10dD1cIm9ydC13YXNtLXRocmVhZGVkLndhc21cIixvdCgpfHwodHQ9Uyh0dCkpO3ZhciBzdD17fTtmdW5jdGlvbiB1dCh0KXt0aGlzLm5hbWU9XCJFeGl0U3RhdHVzXCIsdGhpcy5tZXNzYWdlPVwiUHJvZ3JhbSB0ZXJtaW5hdGVkIHdpdGggZXhpdChcIit0K1wiKVwiLHRoaXMuc3RhdHVzPXR9ZnVuY3Rpb24gY3QodCl7KHQ9ZHQuVmJbdF0pfHxpdCgpLGR0Lm1jKHQpfWZ1bmN0aW9uIGx0KHQpe3ZhciBlPWR0LkNjKCk7aWYoIWUpcmV0dXJuIDY7ZHQuYWMucHVzaChlKSxkdC5WYlt0LlViXT1lLGUuVWI9dC5VYjt2YXIgbj17Y21kOlwicnVuXCIsc3RhcnRfcm91dGluZTp0LkljLGFyZzp0LnpjLHB0aHJlYWRfcHRyOnQuVWJ9O3JldHVybiBlLiRiPSgpPT57bi50aW1lPXBlcmZvcm1hbmNlLm5vdygpLGUucG9zdE1lc3NhZ2Uobix0Lk5jKX0sZS5sb2FkZWQmJihlLiRiKCksZGVsZXRlIGUuJGIpLDB9ZnVuY3Rpb24gcHQodCl7aWYoeClyZXR1cm4gcXQoMSwxLHQpO0ooKXx8KGR0Lm9jKCkscy5vbkV4aXQmJnMub25FeGl0KHQpLE09ITApLHkodCxuZXcgdXQodCkpfWZ1bmN0aW9uIGZ0KHQsZSl7aWYoIWUmJngpdGhyb3cgYnQodCksXCJ1bndpbmRcIjtKKCl8fHh8fChtZSgpLGh0KEspLGJlKDApLHJlWzFdLmxlbmd0aCYmaWUoMSwxMCkscmVbMl0ubGVuZ3RoJiZpZSgyLDEwKSxkdC5vYygpKSxwdCh0KX12YXIgZHQ9e1liOltdLGFjOltdLHFjOltdLFZiOnt9LGZjOmZ1bmN0aW9uKCl7eCYmZHQuRWMoKX0sUGM6ZnVuY3Rpb24oKXt9LEVjOmZ1bmN0aW9uKCl7ZHQucmVjZWl2ZU9iamVjdFRyYW5zZmVyPWR0LkdjLGR0LnRocmVhZEluaXRUTFM9ZHQucGMsZHQuc2V0RXhpdFN0YXR1cz1kdC5uYyxEPSExfSxuYzpmdW5jdGlvbigpe30sb2M6ZnVuY3Rpb24oKXtmb3IodmFyIHQgb2YgT2JqZWN0LnZhbHVlcyhkdC5WYikpZHQubWModCk7Zm9yKHQgb2YgZHQuWWIpdC50ZXJtaW5hdGUoKTtkdC5ZYj1bXX0sbWM6ZnVuY3Rpb24odCl7dmFyIGU9dC5VYjtkZWxldGUgZHQuVmJbZV0sZHQuWWIucHVzaCh0KSxkdC5hYy5zcGxpY2UoZHQuYWMuaW5kZXhPZih0KSwxKSx0LlViPTAseGUoZSl9LEdjOmZ1bmN0aW9uKCl7fSxwYzpmdW5jdGlvbigpe2R0LnFjLmZvckVhY2goKHQ9PnQoKSkpfSxGYzpmdW5jdGlvbih0LGUpe3Qub25tZXNzYWdlPW49Pnt2YXIgcj0obj1uLmRhdGEpLmNtZDtpZih0LlViJiYoZHQuQmM9dC5VYiksbi50YXJnZXRUaHJlYWQmJm4udGFyZ2V0VGhyZWFkIT1kZSgpKXt2YXIgaT1kdC5WYltuLlFjXTtpP2kucG9zdE1lc3NhZ2UobixuLnRyYW5zZmVyTGlzdCk6UCgnSW50ZXJuYWwgZXJyb3IhIFdvcmtlciBzZW50IGEgbWVzc2FnZSBcIicrcisnXCIgdG8gdGFyZ2V0IHB0aHJlYWQgJytuLnRhcmdldFRocmVhZCtcIiwgYnV0IHRoYXQgdGhyZWFkIG5vIGxvbmdlciBleGlzdHMhXCIpfWVsc2VcInByb2Nlc3NQcm94eWluZ1F1ZXVlXCI9PT1yP1Z0KG4ucXVldWUpOlwic3Bhd25UaHJlYWRcIj09PXI/bHQobik6XCJjbGVhbnVwVGhyZWFkXCI9PT1yP2N0KG4udGhyZWFkKTpcImtpbGxUaHJlYWRcIj09PXI/KG49bi50aHJlYWQscj1kdC5WYltuXSxkZWxldGUgZHQuVmJbbl0sci50ZXJtaW5hdGUoKSx4ZShuKSxkdC5hYy5zcGxpY2UoZHQuYWMuaW5kZXhPZihyKSwxKSxyLlViPTApOlwiY2FuY2VsVGhyZWFkXCI9PT1yP2R0LlZiW24udGhyZWFkXS5wb3N0TWVzc2FnZSh7Y21kOlwiY2FuY2VsXCJ9KTpcImxvYWRlZFwiPT09cj8odC5sb2FkZWQ9ITAsZSYmZSh0KSx0LiRiJiYodC4kYigpLGRlbGV0ZSB0LiRiKSk6XCJwcmludFwiPT09cj9JKFwiVGhyZWFkIFwiK24udGhyZWFkSWQrXCI6IFwiK24udGV4dCk6XCJwcmludEVyclwiPT09cj9QKFwiVGhyZWFkIFwiK24udGhyZWFkSWQrXCI6IFwiK24udGV4dCk6XCJhbGVydFwiPT09cj9hbGVydChcIlRocmVhZCBcIituLnRocmVhZElkK1wiOiBcIituLnRleHQpOlwic2V0aW1tZWRpYXRlXCI9PT1uLnRhcmdldD90LnBvc3RNZXNzYWdlKG4pOlwib25BYm9ydFwiPT09cj9zLm9uQWJvcnQmJnMub25BYm9ydChuLmFyZyk6ciYmUChcIndvcmtlciBzZW50IGFuIHVua25vd24gY29tbWFuZCBcIityKTtkdC5CYz12b2lkIDB9LHQub25lcnJvcj10PT57dGhyb3cgUChcIndvcmtlciBzZW50IGFuIGVycm9yISBcIit0LmZpbGVuYW1lK1wiOlwiK3QubGluZW5vK1wiOiBcIit0Lm1lc3NhZ2UpLHR9LHcmJih0Lm9uKFwibWVzc2FnZVwiLChmdW5jdGlvbihlKXt0Lm9ubWVzc2FnZSh7ZGF0YTplfSl9KSksdC5vbihcImVycm9yXCIsKGZ1bmN0aW9uKGUpe3Qub25lcnJvcihlKX0pKSx0Lm9uKFwiZGV0YWNoZWRFeGl0XCIsKGZ1bmN0aW9uKCl7fSkpKSx0LnBvc3RNZXNzYWdlKHtjbWQ6XCJsb2FkXCIsdXJsT3JCbG9iOnMubWFpblNjcmlwdFVybE9yQmxvYnx8X3NjcmlwdERpcix3YXNtTWVtb3J5OiQsd2FzbU1vZHVsZTprfSl9LHljOmZ1bmN0aW9uKCl7dmFyIHQ9UyhcIm9ydC13YXNtLXRocmVhZGVkLndvcmtlci5qc1wiKTtkdC5ZYi5wdXNoKG5ldyBXb3JrZXIodCkpfSxDYzpmdW5jdGlvbigpe3JldHVybiAwPT1kdC5ZYi5sZW5ndGgmJihkdC55YygpLGR0LkZjKGR0LlliWzBdKSksZHQuWWIucG9wKCl9fTtmdW5jdGlvbiBodCh0KXtmb3IoOzA8dC5sZW5ndGg7KXQuc2hpZnQoKShzKX1mdW5jdGlvbiBndCh0KXt2YXIgZT1BZSgpO3JldHVybiB0PXQoKSxFZShlKSx0fWZ1bmN0aW9uIGJ0KHQpe2lmKHgpcmV0dXJuIHF0KDIsMCx0KTt0cnl7ZnQodCl9Y2F0Y2godCl7dCBpbnN0YW5jZW9mIHV0fHxcInVud2luZFwiPT10fHx5KDEsdCl9fXMuUFRocmVhZD1kdCxzLmVzdGFibGlzaFN0YWNrU3BhY2U9ZnVuY3Rpb24oKXt2YXIgdD1kZSgpLGU9aSgpW3QrNDQ+PjI+Pj4wXTt0PWkoKVt0KzQ4Pj4yPj4+MF0sT2UoZSxlLXQpLEVlKGUpfTt2YXIgbXQ9W107ZnVuY3Rpb24geXQodCl7dmFyIGU9bXRbdF07cmV0dXJuIGV8fCh0Pj1tdC5sZW5ndGgmJihtdC5sZW5ndGg9dCsxKSxtdFt0XT1lPXEuZ2V0KHQpKSxlfXMuaW52b2tlRW50cnlQb2ludD1mdW5jdGlvbih0LGUpe3Q9eXQodCkoZSksSigpP2R0Lm5jKHQpOlRlKHQpfTt2YXIgX3QsdnQsd3Q9W10seHQ9MCxUdD0wO2Z1bmN0aW9uIFN0KHQpe3RoaXMuWmI9dCx0aGlzLlNiPXQtMjQsdGhpcy54Yz1mdW5jdGlvbih0KXtvKClbdGhpcy5TYis0Pj4yPj4+MF09dH0sdGhpcy5iYz1mdW5jdGlvbigpe3JldHVybiBvKClbdGhpcy5TYis0Pj4yPj4+MF19LHRoaXMud2M9ZnVuY3Rpb24odCl7bygpW3RoaXMuU2IrOD4+Mj4+PjBdPXR9LHRoaXMuRGM9ZnVuY3Rpb24oKXtyZXR1cm4gbygpW3RoaXMuU2IrOD4+Mj4+PjBdfSx0aGlzLnJjPWZ1bmN0aW9uKCl7aSgpW3RoaXMuU2I+PjI+Pj4wXT0wfSx0aGlzLmhjPWZ1bmN0aW9uKHQpe3Q9dD8xOjAsZSgpW3RoaXMuU2IrMTI+PjA+Pj4wXT10fSx0aGlzLnVjPWZ1bmN0aW9uKCl7cmV0dXJuIDAhPWUoKVt0aGlzLlNiKzEyPj4wPj4+MF19LHRoaXMuaWM9ZnVuY3Rpb24odCl7dD10PzE6MCxlKClbdGhpcy5TYisxMz4+MD4+PjBdPXR9LHRoaXMua2M9ZnVuY3Rpb24oKXtyZXR1cm4gMCE9ZSgpW3RoaXMuU2IrMTM+PjA+Pj4wXX0sdGhpcy5mYz1mdW5jdGlvbih0LGUpe3RoaXMuY2MoMCksdGhpcy54Yyh0KSx0aGlzLndjKGUpLHRoaXMucmMoKSx0aGlzLmhjKCExKSx0aGlzLmljKCExKX0sdGhpcy5zYz1mdW5jdGlvbigpe0F0b21pY3MuYWRkKGkoKSx0aGlzLlNiPj4yLDEpfSx0aGlzLkhjPWZ1bmN0aW9uKCl7cmV0dXJuIDE9PT1BdG9taWNzLnN1YihpKCksdGhpcy5TYj4+MiwxKX0sdGhpcy5jYz1mdW5jdGlvbih0KXtvKClbdGhpcy5TYisxNj4+Mj4+PjBdPXR9LHRoaXMudGM9ZnVuY3Rpb24oKXtyZXR1cm4gbygpW3RoaXMuU2IrMTY+PjI+Pj4wXX0sdGhpcy52Yz1mdW5jdGlvbigpe2lmKERlKHRoaXMuYmMoKSkpcmV0dXJuIG8oKVt0aGlzLlpiPj4yPj4+MF07dmFyIHQ9dGhpcy50YygpO3JldHVybiAwIT09dD90OnRoaXMuWmJ9fWZ1bmN0aW9uIE90KHQpe3JldHVybiBnZShuZXcgU3QodCkuU2IpfWZ1bmN0aW9uIEF0KHQsZSxuLHIpe3JldHVybiB4P3F0KDMsMSx0LGUsbixyKTpFdCh0LGUsbixyKX1mdW5jdGlvbiBFdCh0LGUsbixyKXtpZihcInVuZGVmaW5lZFwiPT10eXBlb2YgU2hhcmVkQXJyYXlCdWZmZXIpcmV0dXJuIFAoXCJDdXJyZW50IGVudmlyb25tZW50IGRvZXMgbm90IHN1cHBvcnQgU2hhcmVkQXJyYXlCdWZmZXIsIHB0aHJlYWRzIGFyZSBub3QgYXZhaWxhYmxlIVwiKSw2O3ZhciBpPVtdO3JldHVybiB4JiYwPT09aS5sZW5ndGg/QXQodCxlLG4scik6KHQ9e0ljOm4sVWI6dCx6YzpyLE5jOml9LHg/KHQuT2M9XCJzcGF3blRocmVhZFwiLHBvc3RNZXNzYWdlKHQsaSksMCk6bHQodCkpfWZ1bmN0aW9uIEl0KHQsZSxuKXtyZXR1cm4geD9xdCg0LDEsdCxlLG4pOjB9ZnVuY3Rpb24gUHQodCxlKXtpZih4KXJldHVybiBxdCg1LDEsdCxlKX1mdW5jdGlvbiBEdCh0LGUpe2lmKHgpcmV0dXJuIHF0KDYsMSx0LGUpfWZ1bmN0aW9uICR0KHQsZSxuKXtpZih4KXJldHVybiBxdCg3LDEsdCxlLG4pfWZ1bmN0aW9uIGt0KHQsZSxuKXtyZXR1cm4geD9xdCg4LDEsdCxlLG4pOjB9ZnVuY3Rpb24gQ3QodCxlKXtpZih4KXJldHVybiBxdCg5LDEsdCxlKX1mdW5jdGlvbiBGdCh0LGUsbil7aWYoeClyZXR1cm4gcXQoMTAsMSx0LGUsbil9ZnVuY3Rpb24gTnQodCxlLG4scil7aWYoeClyZXR1cm4gcXQoMTEsMSx0LGUsbixyKX1mdW5jdGlvbiBMdCh0LGUsbixyKXtpZih4KXJldHVybiBxdCgxMiwxLHQsZSxuLHIpfWZ1bmN0aW9uIFJ0KHQsZSxuLHIpe2lmKHgpcmV0dXJuIHF0KDEzLDEsdCxlLG4scil9ZnVuY3Rpb24ganQodCl7aWYoeClyZXR1cm4gcXQoMTQsMSx0KX1mdW5jdGlvbiBNdCh0LGUpe2lmKHgpcmV0dXJuIHF0KDE1LDEsdCxlKX1mdW5jdGlvbiBVdCh0LGUsbil7aWYoeClyZXR1cm4gcXQoMTYsMSx0LGUsbil9ZnVuY3Rpb24gVnQodCl7QXRvbWljcy5zdG9yZShpKCksdD4+MiwxKSxkZSgpJiZ3ZSh0KSxBdG9taWNzLmNvbXBhcmVFeGNoYW5nZShpKCksdD4+MiwxLDApfWZ1bmN0aW9uIEJ0KHQpe3JldHVybiBvKClbdD4+PjJdKzQyOTQ5NjcyOTYqaSgpW3QrND4+PjJdfWZ1bmN0aW9uIHp0KHQsZSxuLHIsaSxvKXtyZXR1cm4geD9xdCgxNywxLHQsZSxuLHIsaSxvKTotNTJ9ZnVuY3Rpb24gR3QodCxlLG4scixpLG8pe2lmKHgpcmV0dXJuIHF0KDE4LDEsdCxlLG4scixpLG8pfWZ1bmN0aW9uIEh0KHQpe3ZhciBuPUcodCkrMSxyPWhlKG4pO3JldHVybiByJiZ6KHQsZSgpLHIsbikscn1mdW5jdGlvbiBXdCh0LGUsbil7ZnVuY3Rpb24gcih0KXtyZXR1cm4odD10LnRvVGltZVN0cmluZygpLm1hdGNoKC9cXCgoW0EtWmEteiBdKylcXCkkLykpP3RbMV06XCJHTVRcIn1pZih4KXJldHVybiBxdCgxOSwxLHQsZSxuKTt2YXIgYT0obmV3IERhdGUpLmdldEZ1bGxZZWFyKCkscz1uZXcgRGF0ZShhLDAsMSksdT1uZXcgRGF0ZShhLDYsMSk7YT1zLmdldFRpbWV6b25lT2Zmc2V0KCk7dmFyIGM9dS5nZXRUaW1lem9uZU9mZnNldCgpLGw9TWF0aC5tYXgoYSxjKTtpKClbdD4+Mj4+PjBdPTYwKmwsaSgpW2U+PjI+Pj4wXT1OdW1iZXIoYSE9YyksdD1yKHMpLGU9cih1KSx0PUh0KHQpLGU9SHQoZSksYzxhPyhvKClbbj4+Mj4+PjBdPXQsbygpW24rND4+Mj4+PjBdPWUpOihvKClbbj4+Mj4+PjBdPWUsbygpW24rND4+Mj4+PjBdPXQpfWZ1bmN0aW9uIHF0KHQsZSl7dmFyIG49YXJndW1lbnRzLmxlbmd0aC0yLHI9YXJndW1lbnRzO3JldHVybiBndCgoKCk9Pntmb3IodmFyIGk9SWUoOCpuKSxvPWk+PjMscz0wO3M8bjtzKyspe3ZhciB1PXJbMitzXTthKClbbytzPj4+MF09dX1yZXR1cm4gdmUodCxuLGksZSl9KSl9cy5leGVjdXRlTm90aWZpZWRQcm94eWluZ1F1ZXVlPVZ0LHZ0PXc/KCk9Pnt2YXIgdD1wcm9jZXNzLmhydGltZSgpO3JldHVybiAxZTMqdFswXSt0WzFdLzFlNn06eD8oKT0+cGVyZm9ybWFuY2Uubm93KCktcy5fX3BlcmZvcm1hbmNlX25vd19jbG9ja19kcmlmdDooKT0+cGVyZm9ybWFuY2Uubm93KCk7dmFyIFh0LFl0PVtdLEt0PXt9O2Z1bmN0aW9uIFp0KCl7aWYoIVh0KXt2YXIgdCxlPXtVU0VSOlwid2ViX3VzZXJcIixMT0dOQU1FOlwid2ViX3VzZXJcIixQQVRIOlwiL1wiLFBXRDpcIi9cIixIT01FOlwiL2hvbWUvd2ViX3VzZXJcIixMQU5HOihcIm9iamVjdFwiPT10eXBlb2YgbmF2aWdhdG9yJiZuYXZpZ2F0b3IubGFuZ3VhZ2VzJiZuYXZpZ2F0b3IubGFuZ3VhZ2VzWzBdfHxcIkNcIikucmVwbGFjZShcIi1cIixcIl9cIikrXCIuVVRGLThcIixfOm18fFwiLi90aGlzLnByb2dyYW1cIn07Zm9yKHQgaW4gS3Qpdm9pZCAwPT09S3RbdF0/ZGVsZXRlIGVbdF06ZVt0XT1LdFt0XTt2YXIgbj1bXTtmb3IodCBpbiBlKW4ucHVzaCh0K1wiPVwiK2VbdF0pO1h0PW59cmV0dXJuIFh0fWZ1bmN0aW9uIEp0KHQsbil7aWYoeClyZXR1cm4gcXQoMjAsMSx0LG4pO3ZhciByPTA7cmV0dXJuIFp0KCkuZm9yRWFjaCgoZnVuY3Rpb24oaSxhKXt2YXIgcz1uK3I7Zm9yKGE9bygpW3QrNCphPj4yPj4+MF09cyxzPTA7czxpLmxlbmd0aDsrK3MpZSgpW2ErKz4+MD4+PjBdPWkuY2hhckNvZGVBdChzKTtlKClbYT4+MD4+PjBdPTAscis9aS5sZW5ndGgrMX0pKSwwfWZ1bmN0aW9uIFF0KHQsZSl7aWYoeClyZXR1cm4gcXQoMjEsMSx0LGUpO3ZhciBuPVp0KCk7bygpW3Q+PjI+Pj4wXT1uLmxlbmd0aDt2YXIgcj0wO3JldHVybiBuLmZvckVhY2goKGZ1bmN0aW9uKHQpe3IrPXQubGVuZ3RoKzF9KSksbygpW2U+PjI+Pj4wXT1yLDB9ZnVuY3Rpb24gdGUodCl7cmV0dXJuIHg/cXQoMjIsMSx0KTo1Mn1mdW5jdGlvbiBlZSh0LGUsbixyKXtyZXR1cm4geD9xdCgyMywxLHQsZSxuLHIpOjUyfWZ1bmN0aW9uIG5lKHQsZSxuLHIsaSl7cmV0dXJuIHg/cXQoMjQsMSx0LGUsbixyLGkpOjcwfXZhciByZT1bbnVsbCxbXSxbXV07ZnVuY3Rpb24gaWUodCxlKXt2YXIgbj1yZVt0XTswPT09ZXx8MTA9PT1lPygoMT09PXQ/STpQKShWKG4sMCkpLG4ubGVuZ3RoPTApOm4ucHVzaChlKX1mdW5jdGlvbiBvZSh0LGUsbixpKXtpZih4KXJldHVybiBxdCgyNSwxLHQsZSxuLGkpO2Zvcih2YXIgYT0wLHM9MDtzPG47cysrKXt2YXIgdT1vKClbZT4+Mj4+PjBdLGM9bygpW2UrND4+Mj4+PjBdO2UrPTg7Zm9yKHZhciBsPTA7bDxjO2wrKylpZSh0LHIoKVt1K2w+Pj4wXSk7YSs9Y31yZXR1cm4gbygpW2k+PjI+Pj4wXT1hLDB9dmFyIGFlPTA7ZnVuY3Rpb24gc2UodCl7cmV0dXJuIDA9PXQlNCYmKDAhPXQlMTAwfHwwPT10JTQwMCl9dmFyIHVlPVszMSwyOSwzMSwzMCwzMSwzMCwzMSwzMSwzMCwzMSwzMCwzMV0sY2U9WzMxLDI4LDMxLDMwLDMxLDMwLDMxLDMxLDMwLDMxLDMwLDMxXTtmdW5jdGlvbiBsZSh0LG4scixvKXtmdW5jdGlvbiBhKHQsZSxuKXtmb3IodD1cIm51bWJlclwiPT10eXBlb2YgdD90LnRvU3RyaW5nKCk6dHx8XCJcIjt0Lmxlbmd0aDxlOyl0PW5bMF0rdDtyZXR1cm4gdH1mdW5jdGlvbiBzKHQsZSl7cmV0dXJuIGEodCxlLFwiMFwiKX1mdW5jdGlvbiB1KHQsZSl7ZnVuY3Rpb24gbih0KXtyZXR1cm4gMD50Py0xOjA8dD8xOjB9dmFyIHI7cmV0dXJuIDA9PT0ocj1uKHQuZ2V0RnVsbFllYXIoKS1lLmdldEZ1bGxZZWFyKCkpKSYmMD09PShyPW4odC5nZXRNb250aCgpLWUuZ2V0TW9udGgoKSkpJiYocj1uKHQuZ2V0RGF0ZSgpLWUuZ2V0RGF0ZSgpKSkscn1mdW5jdGlvbiBjKHQpe3N3aXRjaCh0LmdldERheSgpKXtjYXNlIDA6cmV0dXJuIG5ldyBEYXRlKHQuZ2V0RnVsbFllYXIoKS0xLDExLDI5KTtjYXNlIDE6cmV0dXJuIHQ7Y2FzZSAyOnJldHVybiBuZXcgRGF0ZSh0LmdldEZ1bGxZZWFyKCksMCwzKTtjYXNlIDM6cmV0dXJuIG5ldyBEYXRlKHQuZ2V0RnVsbFllYXIoKSwwLDIpO2Nhc2UgNDpyZXR1cm4gbmV3IERhdGUodC5nZXRGdWxsWWVhcigpLDAsMSk7Y2FzZSA1OnJldHVybiBuZXcgRGF0ZSh0LmdldEZ1bGxZZWFyKCktMSwxMSwzMSk7Y2FzZSA2OnJldHVybiBuZXcgRGF0ZSh0LmdldEZ1bGxZZWFyKCktMSwxMSwzMCl9fWZ1bmN0aW9uIGwodCl7dmFyIGU9dC5XYjtmb3IodD1uZXcgRGF0ZShuZXcgRGF0ZSh0LlhiKzE5MDAsMCwxKS5nZXRUaW1lKCkpOzA8ZTspe3ZhciBuPXQuZ2V0TW9udGgoKSxyPShzZSh0LmdldEZ1bGxZZWFyKCkpP3VlOmNlKVtuXTtpZighKGU+ci10LmdldERhdGUoKSkpe3Quc2V0RGF0ZSh0LmdldERhdGUoKStlKTticmVha31lLT1yLXQuZ2V0RGF0ZSgpKzEsdC5zZXREYXRlKDEpLDExPm4/dC5zZXRNb250aChuKzEpOih0LnNldE1vbnRoKDApLHQuc2V0RnVsbFllYXIodC5nZXRGdWxsWWVhcigpKzEpKX1yZXR1cm4gbj1uZXcgRGF0ZSh0LmdldEZ1bGxZZWFyKCkrMSwwLDQpLGU9YyhuZXcgRGF0ZSh0LmdldEZ1bGxZZWFyKCksMCw0KSksbj1jKG4pLDA+PXUoZSx0KT8wPj11KG4sdCk/dC5nZXRGdWxsWWVhcigpKzE6dC5nZXRGdWxsWWVhcigpOnQuZ2V0RnVsbFllYXIoKS0xfXZhciBwPWkoKVtvKzQwPj4yPj4+MF07Zm9yKHZhciBmIGluIG89e0xjOmkoKVtvPj4yPj4+MF0sS2M6aSgpW28rND4+Mj4+PjBdLGRjOmkoKVtvKzg+PjI+Pj4wXSxqYzppKClbbysxMj4+Mj4+PjBdLGVjOmkoKVtvKzE2Pj4yPj4+MF0sWGI6aSgpW28rMjA+PjI+Pj4wXSxUYjppKClbbysyND4+Mj4+PjBdLFdiOmkoKVtvKzI4Pj4yPj4+MF0sUmM6aSgpW28rMzI+PjI+Pj4wXSxKYzppKClbbyszNj4+Mj4+PjBdLE1jOnA/QihwKTpcIlwifSxyPUIocikscD17XCIlY1wiOlwiJWEgJWIgJWQgJUg6JU06JVMgJVlcIixcIiVEXCI6XCIlbS8lZC8leVwiLFwiJUZcIjpcIiVZLSVtLSVkXCIsXCIlaFwiOlwiJWJcIixcIiVyXCI6XCIlSTolTTolUyAlcFwiLFwiJVJcIjpcIiVIOiVNXCIsXCIlVFwiOlwiJUg6JU06JVNcIixcIiV4XCI6XCIlbS8lZC8leVwiLFwiJVhcIjpcIiVIOiVNOiVTXCIsXCIlRWNcIjpcIiVjXCIsXCIlRUNcIjpcIiVDXCIsXCIlRXhcIjpcIiVtLyVkLyV5XCIsXCIlRVhcIjpcIiVIOiVNOiVTXCIsXCIlRXlcIjpcIiV5XCIsXCIlRVlcIjpcIiVZXCIsXCIlT2RcIjpcIiVkXCIsXCIlT2VcIjpcIiVlXCIsXCIlT0hcIjpcIiVIXCIsXCIlT0lcIjpcIiVJXCIsXCIlT21cIjpcIiVtXCIsXCIlT01cIjpcIiVNXCIsXCIlT1NcIjpcIiVTXCIsXCIlT3VcIjpcIiV1XCIsXCIlT1VcIjpcIiVVXCIsXCIlT1ZcIjpcIiVWXCIsXCIlT3dcIjpcIiV3XCIsXCIlT1dcIjpcIiVXXCIsXCIlT3lcIjpcIiV5XCJ9KXI9ci5yZXBsYWNlKG5ldyBSZWdFeHAoZixcImdcIikscFtmXSk7dmFyIGQ9XCJTdW5kYXkgTW9uZGF5IFR1ZXNkYXkgV2VkbmVzZGF5IFRodXJzZGF5IEZyaWRheSBTYXR1cmRheVwiLnNwbGl0KFwiIFwiKSxoPVwiSmFudWFyeSBGZWJydWFyeSBNYXJjaCBBcHJpbCBNYXkgSnVuZSBKdWx5IEF1Z3VzdCBTZXB0ZW1iZXIgT2N0b2JlciBOb3ZlbWJlciBEZWNlbWJlclwiLnNwbGl0KFwiIFwiKTtmb3IoZiBpbiBwPXtcIiVhXCI6ZnVuY3Rpb24odCl7cmV0dXJuIGRbdC5UYl0uc3Vic3RyaW5nKDAsMyl9LFwiJUFcIjpmdW5jdGlvbih0KXtyZXR1cm4gZFt0LlRiXX0sXCIlYlwiOmZ1bmN0aW9uKHQpe3JldHVybiBoW3QuZWNdLnN1YnN0cmluZygwLDMpfSxcIiVCXCI6ZnVuY3Rpb24odCl7cmV0dXJuIGhbdC5lY119LFwiJUNcIjpmdW5jdGlvbih0KXtyZXR1cm4gcygodC5YYisxOTAwKS8xMDB8MCwyKX0sXCIlZFwiOmZ1bmN0aW9uKHQpe3JldHVybiBzKHQuamMsMil9LFwiJWVcIjpmdW5jdGlvbih0KXtyZXR1cm4gYSh0LmpjLDIsXCIgXCIpfSxcIiVnXCI6ZnVuY3Rpb24odCl7cmV0dXJuIGwodCkudG9TdHJpbmcoKS5zdWJzdHJpbmcoMil9LFwiJUdcIjpmdW5jdGlvbih0KXtyZXR1cm4gbCh0KX0sXCIlSFwiOmZ1bmN0aW9uKHQpe3JldHVybiBzKHQuZGMsMil9LFwiJUlcIjpmdW5jdGlvbih0KXtyZXR1cm4gMD09KHQ9dC5kYyk/dD0xMjoxMjx0JiYodC09MTIpLHModCwyKX0sXCIlalwiOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT0wLG49MDtuPD10LmVjLTE7ZSs9KHNlKHQuWGIrMTkwMCk/dWU6Y2UpW24rK10pO3JldHVybiBzKHQuamMrZSwzKX0sXCIlbVwiOmZ1bmN0aW9uKHQpe3JldHVybiBzKHQuZWMrMSwyKX0sXCIlTVwiOmZ1bmN0aW9uKHQpe3JldHVybiBzKHQuS2MsMil9LFwiJW5cIjpmdW5jdGlvbigpe3JldHVyblwiXFxuXCJ9LFwiJXBcIjpmdW5jdGlvbih0KXtyZXR1cm4gMDw9dC5kYyYmMTI+dC5kYz9cIkFNXCI6XCJQTVwifSxcIiVTXCI6ZnVuY3Rpb24odCl7cmV0dXJuIHModC5MYywyKX0sXCIldFwiOmZ1bmN0aW9uKCl7cmV0dXJuXCJcXHRcIn0sXCIldVwiOmZ1bmN0aW9uKHQpe3JldHVybiB0LlRifHw3fSxcIiVVXCI6ZnVuY3Rpb24odCl7cmV0dXJuIHMoTWF0aC5mbG9vcigodC5XYis3LXQuVGIpLzcpLDIpfSxcIiVWXCI6ZnVuY3Rpb24odCl7dmFyIGU9TWF0aC5mbG9vcigodC5XYis3LSh0LlRiKzYpJTcpLzcpO2lmKDI+PSh0LlRiKzM3MS10LldiLTIpJTcmJmUrKyxlKTUzPT1lJiYoND09KG49KHQuVGIrMzcxLXQuV2IpJTcpfHwzPT1uJiZzZSh0LlhiKXx8KGU9MSkpO2Vsc2V7ZT01Mjt2YXIgbj0odC5UYis3LXQuV2ItMSklNzsoND09bnx8NT09biYmc2UodC5YYiU0MDAtMSkpJiZlKyt9cmV0dXJuIHMoZSwyKX0sXCIld1wiOmZ1bmN0aW9uKHQpe3JldHVybiB0LlRifSxcIiVXXCI6ZnVuY3Rpb24odCl7cmV0dXJuIHMoTWF0aC5mbG9vcigodC5XYis3LSh0LlRiKzYpJTcpLzcpLDIpfSxcIiV5XCI6ZnVuY3Rpb24odCl7cmV0dXJuKHQuWGIrMTkwMCkudG9TdHJpbmcoKS5zdWJzdHJpbmcoMil9LFwiJVlcIjpmdW5jdGlvbih0KXtyZXR1cm4gdC5YYisxOTAwfSxcIiV6XCI6ZnVuY3Rpb24odCl7dmFyIGU9MDw9KHQ9dC5KYyk7cmV0dXJuIHQ9TWF0aC5hYnModCkvNjAsKGU/XCIrXCI6XCItXCIpK1N0cmluZyhcIjAwMDBcIisodC82MCoxMDArdCU2MCkpLnNsaWNlKC00KX0sXCIlWlwiOmZ1bmN0aW9uKHQpe3JldHVybiB0Lk1jfSxcIiUlXCI6ZnVuY3Rpb24oKXtyZXR1cm5cIiVcIn19LHI9ci5yZXBsYWNlKC8lJS9nLFwiXFwwXFwwXCIpLHApci5pbmNsdWRlcyhmKSYmKHI9ci5yZXBsYWNlKG5ldyBSZWdFeHAoZixcImdcIikscFtmXShvKSkpO3JldHVybiBmPWZ1bmN0aW9uKHQpe3ZhciBlPUFycmF5KEcodCkrMSk7cmV0dXJuIHoodCxlLDAsZS5sZW5ndGgpLGV9KHI9ci5yZXBsYWNlKC9cXDBcXDAvZyxcIiVcIikpLGYubGVuZ3RoPm4/MDooZnVuY3Rpb24odCxuKXtlKCkuc2V0KHQsbj4+PjApfShmLHQpLGYubGVuZ3RoLTEpfWR0LmZjKCk7dmFyIHBlPVtudWxsLHB0LGJ0LEF0LEl0LFB0LER0LCR0LGt0LEN0LEZ0LE50LEx0LFJ0LGp0LE10LFV0LHp0LEd0LFd0LEp0LFF0LHRlLGVlLG5lLG9lXSxmZT17YjpmdW5jdGlvbih0KXtyZXR1cm4gaGUodCsyNCkrMjR9LG46ZnVuY3Rpb24odCl7cmV0dXJuKHQ9bmV3IFN0KHQpKS51YygpfHwodC5oYyghMCkseHQtLSksdC5pYyghMSksd3QucHVzaCh0KSx0LnNjKCksdC52YygpfSxtYTpmdW5jdGlvbih0KXt0aHJvdyBQKFwiVW5leHBlY3RlZCBleGNlcHRpb24gdGhyb3duLCB0aGlzIGlzIG5vdCBwcm9wZXJseSBzdXBwb3J0ZWQgLSBhYm9ydGluZ1wiKSxNPSEwLHR9LHg6ZnVuY3Rpb24oKXtTZSgwKTt2YXIgdD13dC5wb3AoKTtpZih0LkhjKCkmJiF0LmtjKCkpe3ZhciBlPXQuRGMoKTtlJiZ5dChlKSh0LlpiKSxPdCh0LlpiKX1UdD0wfSxlOmZ1bmN0aW9uKCl7dmFyIHQ9VHQ7aWYoIXQpcmV0dXJuIGFlPTA7dmFyIGU9bmV3IFN0KHQpO2UuY2ModCk7dmFyIG49ZS5iYygpO2lmKCFuKXJldHVybiBhZT0wLHQ7Zm9yKHZhciByPUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyksaT0wO2k8ci5sZW5ndGg7aSsrKXt2YXIgbz1yW2ldO2lmKDA9PT1vfHxvPT09bilicmVhaztpZihQZShvLG4sZS5TYisxNikpcmV0dXJuIGFlPW8sdH1yZXR1cm4gYWU9bix0fSxsOmZ1bmN0aW9uKCl7dmFyIHQ9VHQ7aWYoIXQpcmV0dXJuIGFlPTA7dmFyIGU9bmV3IFN0KHQpO2UuY2ModCk7dmFyIG49ZS5iYygpO2lmKCFuKXJldHVybiBhZT0wLHQ7Zm9yKHZhciByPUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyksaT0wO2k8ci5sZW5ndGg7aSsrKXt2YXIgbz1yW2ldO2lmKDA9PT1vfHxvPT09bilicmVhaztpZihQZShvLG4sZS5TYisxNikpcmV0dXJuIGFlPW8sdH1yZXR1cm4gYWU9bix0fSxoOmZ1bmN0aW9uKCl7dmFyIHQ9VHQ7aWYoIXQpcmV0dXJuIGFlPTA7dmFyIGU9bmV3IFN0KHQpO2UuY2ModCk7dmFyIG49ZS5iYygpO2lmKCFuKXJldHVybiBhZT0wLHQ7Zm9yKHZhciByPUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyksaT0wO2k8ci5sZW5ndGg7aSsrKXt2YXIgbz1yW2ldO2lmKDA9PT1vfHxvPT09bilicmVhaztpZihQZShvLG4sZS5TYisxNikpcmV0dXJuIGFlPW8sdH1yZXR1cm4gYWU9bix0fSx0Ok90LE06ZnVuY3Rpb24oKXt2YXIgdD13dC5wb3AoKTt0fHxpdChcIm5vIGV4Y2VwdGlvbiB0byB0aHJvd1wiKTt2YXIgZT10LlpiO3Rocm93IHQua2MoKXx8KHd0LnB1c2godCksdC5pYyghMCksdC5oYyghMSkseHQrKyksVHQ9ZSxlfSxjOmZ1bmN0aW9uKHQsZSxuKXt0aHJvdyBuZXcgU3QodCkuZmMoZSxuKSxUdD10LHh0KyssdH0scGE6ZnVuY3Rpb24oKXtyZXR1cm4geHR9LEZhOmZ1bmN0aW9uKHQpe3llKHQsIXYsMSwhXyksZHQucGMoKX0sVDpmdW5jdGlvbih0KXt4P3Bvc3RNZXNzYWdlKHtjbWQ6XCJjbGVhbnVwVGhyZWFkXCIsdGhyZWFkOnR9KTpjdCh0KX0seGE6RXQsajpmdW5jdGlvbih0KXt0aHJvdyBUdHx8KFR0PXQpLHR9LEg6SXQsTWE6UHQsdWE6RHQsd2E6JHQsb2E6a3QsS2E6Q3QsQ2E6RnQsSmE6TnQsVjpMdCx2YTpSdCxzYTpqdCxMYTpNdCx0YTpVdCxUYTpmdW5jdGlvbigpe30sWDpmdW5jdGlvbigpe2l0KFwiVG8gdXNlIGRsb3BlbiwgeW91IG5lZWQgZW5hYmxlIGR5bmFtaWMgbGlua2luZywgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9lbXNjcmlwdGVuLWNvcmUvZW1zY3JpcHRlbi93aWtpL0xpbmtpbmdcIil9LFVhOmZ1bmN0aW9uKCl7aXQoXCJUbyB1c2UgZGxvcGVuLCB5b3UgbmVlZCBlbmFibGUgZHluYW1pYyBsaW5raW5nLCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2Vtc2NyaXB0ZW4tY29yZS9lbXNjcmlwdGVuL3dpa2kvTGlua2luZ1wiKX0sVzpmdW5jdGlvbigpe3JldHVybiBEYXRlLm5vdygpfSx5YTpmdW5jdGlvbigpe3JldHVybiAyMDk3MTUyfSxPYTpmdW5jdGlvbigpe3JldHVybiEwfSx6YTpmdW5jdGlvbih0LGUsbixyKXtpZih0PT1lKXNldFRpbWVvdXQoKCgpPT5WdChyKSkpO2Vsc2UgaWYoeClwb3N0TWVzc2FnZSh7dGFyZ2V0VGhyZWFkOnQsY21kOlwicHJvY2Vzc1Byb3h5aW5nUXVldWVcIixxdWV1ZTpyfSk7ZWxzZXtpZighKHQ9ZHQuVmJbdF0pKXJldHVybjt0LnBvc3RNZXNzYWdlKHtjbWQ6XCJwcm9jZXNzUHJveHlpbmdRdWV1ZVwiLHF1ZXVlOnJ9KX1yZXR1cm4gMX0sRWE6ZnVuY3Rpb24oKXtyZXR1cm4tMX0sUGE6ZnVuY3Rpb24odCxlKXt0PW5ldyBEYXRlKDFlMypCdCh0KSksaSgpW2U+PjI+Pj4wXT10LmdldFVUQ1NlY29uZHMoKSxpKClbZSs0Pj4yPj4+MF09dC5nZXRVVENNaW51dGVzKCksaSgpW2UrOD4+Mj4+PjBdPXQuZ2V0VVRDSG91cnMoKSxpKClbZSsxMj4+Mj4+PjBdPXQuZ2V0VVRDRGF0ZSgpLGkoKVtlKzE2Pj4yPj4+MF09dC5nZXRVVENNb250aCgpLGkoKVtlKzIwPj4yPj4+MF09dC5nZXRVVENGdWxsWWVhcigpLTE5MDAsaSgpW2UrMjQ+PjI+Pj4wXT10LmdldFVUQ0RheSgpLHQ9KHQuZ2V0VGltZSgpLURhdGUuVVRDKHQuZ2V0VVRDRnVsbFllYXIoKSwwLDEsMCwwLDAsMCkpLzg2NGU1fDAsaSgpW2UrMjg+PjI+Pj4wXT10fSxRYTpmdW5jdGlvbih0LGUpe3Q9bmV3IERhdGUoMWUzKkJ0KHQpKSxpKClbZT4+Mj4+PjBdPXQuZ2V0U2Vjb25kcygpLGkoKVtlKzQ+PjI+Pj4wXT10LmdldE1pbnV0ZXMoKSxpKClbZSs4Pj4yPj4+MF09dC5nZXRIb3VycygpLGkoKVtlKzEyPj4yPj4+MF09dC5nZXREYXRlKCksaSgpW2UrMTY+PjI+Pj4wXT10LmdldE1vbnRoKCksaSgpW2UrMjA+PjI+Pj4wXT10LmdldEZ1bGxZZWFyKCktMTkwMCxpKClbZSsyND4+Mj4+PjBdPXQuZ2V0RGF5KCk7dmFyIG49bmV3IERhdGUodC5nZXRGdWxsWWVhcigpLDAsMSkscj0odC5nZXRUaW1lKCktbi5nZXRUaW1lKCkpLzg2NGU1fDA7aSgpW2UrMjg+PjI+Pj4wXT1yLGkoKVtlKzM2Pj4yPj4+MF09LTYwKnQuZ2V0VGltZXpvbmVPZmZzZXQoKSxyPW5ldyBEYXRlKHQuZ2V0RnVsbFllYXIoKSw2LDEpLmdldFRpbWV6b25lT2Zmc2V0KCksdD0wfChyIT0obj1uLmdldFRpbWV6b25lT2Zmc2V0KCkpJiZ0LmdldFRpbWV6b25lT2Zmc2V0KCk9PU1hdGgubWluKG4scikpLGkoKVtlKzMyPj4yPj4+MF09dH0sUmE6ZnVuY3Rpb24odCl7dmFyIGU9bmV3IERhdGUoaSgpW3QrMjA+PjI+Pj4wXSsxOTAwLGkoKVt0KzE2Pj4yPj4+MF0saSgpW3QrMTI+PjI+Pj4wXSxpKClbdCs4Pj4yPj4+MF0saSgpW3QrND4+Mj4+PjBdLGkoKVt0Pj4yPj4+MF0sMCksbj1pKClbdCszMj4+Mj4+PjBdLHI9ZS5nZXRUaW1lem9uZU9mZnNldCgpLG89bmV3IERhdGUoZS5nZXRGdWxsWWVhcigpLDAsMSksYT1uZXcgRGF0ZShlLmdldEZ1bGxZZWFyKCksNiwxKS5nZXRUaW1lem9uZU9mZnNldCgpLHM9by5nZXRUaW1lem9uZU9mZnNldCgpLHU9TWF0aC5taW4ocyxhKTtyZXR1cm4gMD5uP2koKVt0KzMyPj4yPj4+MF09TnVtYmVyKGEhPXMmJnU9PXIpOjA8biE9KHU9PXIpJiYoYT1NYXRoLm1heChzLGEpLGUuc2V0VGltZShlLmdldFRpbWUoKSs2ZTQqKCgwPG4/dTphKS1yKSkpLGkoKVt0KzI0Pj4yPj4+MF09ZS5nZXREYXkoKSxuPShlLmdldFRpbWUoKS1vLmdldFRpbWUoKSkvODY0ZTV8MCxpKClbdCsyOD4+Mj4+PjBdPW4saSgpW3Q+PjI+Pj4wXT1lLmdldFNlY29uZHMoKSxpKClbdCs0Pj4yPj4+MF09ZS5nZXRNaW51dGVzKCksaSgpW3QrOD4+Mj4+PjBdPWUuZ2V0SG91cnMoKSxpKClbdCsxMj4+Mj4+PjBdPWUuZ2V0RGF0ZSgpLGkoKVt0KzE2Pj4yPj4+MF09ZS5nZXRNb250aCgpLGUuZ2V0VGltZSgpLzFlM3wwfSxBYTp6dCxCYTpHdCxTYTpmdW5jdGlvbiB0KGUsbixyKXt0LkFjfHwodC5BYz0hMCxXdChlLG4scikpfSx5OmZ1bmN0aW9uKCl7aXQoXCJcIil9LFU6ZnVuY3Rpb24oKXtpZighdyYmIXYpe3ZhciB0PVwiQmxvY2tpbmcgb24gdGhlIG1haW4gdGhyZWFkIGlzIHZlcnkgZGFuZ2Vyb3VzLCBzZWUgaHR0cHM6Ly9lbXNjcmlwdGVuLm9yZy9kb2NzL3BvcnRpbmcvcHRocmVhZHMuaHRtbCNibG9ja2luZy1vbi10aGUtbWFpbi1icm93c2VyLXRocmVhZFwiO190fHwoX3Q9e30pLF90W3RdfHwoX3RbdF09MSx3JiYodD1cIndhcm5pbmc6IFwiK3QpLFAodCkpfX0scmE6ZnVuY3Rpb24oKXtyZXR1cm4gNDI5NDkwMTc2MH0sQjp2dCxJYTpmdW5jdGlvbih0LGUsbil7cigpLmNvcHlXaXRoaW4odD4+PjAsZT4+PjAsZStuPj4+MCl9LEY6ZnVuY3Rpb24oKXtyZXR1cm4gdz9uKDM5OTMpLmNwdXMoKS5sZW5ndGg6bmF2aWdhdG9yLmhhcmR3YXJlQ29uY3VycmVuY3l9LERhOmZ1bmN0aW9uKHQsZSxuKXtZdC5sZW5ndGg9ZSxuPj49Mztmb3IodmFyIHI9MDtyPGU7cisrKVl0W3JdPWEoKVtuK3I+Pj4wXTtyZXR1cm4oMD50P3N0Wy10LTFdOnBlW3RdKS5hcHBseShudWxsLFl0KX0scWE6ZnVuY3Rpb24odCl7dmFyIGU9cigpLmxlbmd0aDtpZigodD4+Pj0wKTw9ZXx8NDI5NDkwMTc2MDx0KXJldHVybiExO2Zvcih2YXIgbj0xOzQ+PW47bio9Mil7dmFyIGk9ZSooMSsuMi9uKTtpPU1hdGgubWluKGksdCsxMDA2NjMyOTYpO3ZhciBvPU1hdGg7aT1NYXRoLm1heCh0LGkpLG89by5taW4uY2FsbChvLDQyOTQ5MDE3NjAsaSsoNjU1MzYtaSU2NTUzNiklNjU1MzYpO3Q6e3RyeXskLmdyb3coby1DLmJ5dGVMZW5ndGgrNjU1MzU+Pj4xNiksSCgkLmJ1ZmZlcik7dmFyIGE9MTticmVhayB0fWNhdGNoKHQpe31hPXZvaWQgMH1pZihhKXJldHVybiEwfXJldHVybiExfSxOYTpmdW5jdGlvbigpe3Rocm93XCJ1bndpbmRcIn0sR2E6SnQsSGE6UXQsSjpmdCxJOnRlLFM6ZWUsZ2E6bmUsUjpvZSxkOmZ1bmN0aW9uKCl7cmV0dXJuIGFlfSxuYTpmdW5jdGlvbiB0KHIsaSl7dC5sY3x8KHQubGM9ZnVuY3Rpb24oKXtpZihcIm9iamVjdFwiPT10eXBlb2YgY3J5cHRvJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKXt2YXIgdD1uZXcgVWludDhBcnJheSgxKTtyZXR1cm4oKT0+KGNyeXB0by5nZXRSYW5kb21WYWx1ZXModCksdFswXSl9aWYodyl0cnl7dmFyIGU9bihPYmplY3QoZnVuY3Rpb24oKXt2YXIgdD1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ2NyeXB0bydcIik7dGhyb3cgdC5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLHR9KCkpKTtyZXR1cm4oKT0+ZS5yYW5kb21CeXRlcygxKVswXX1jYXRjaCh0KXt9cmV0dXJuKCk9Pml0KFwicmFuZG9tRGV2aWNlXCIpfSgpKTtmb3IodmFyIG89MDtvPGk7bysrKWUoKVtyK28+PjA+Pj4wXT10LmxjKCk7cmV0dXJuIDB9LGlhOmZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1BZSgpO3RyeXtyZXR1cm4geXQodCkoZSxuKX1jYXRjaCh0KXtpZihFZShyKSx0IT09dCswKXRocm93IHQ7U2UoMSwwKX19LGphOmZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1BZSgpO3RyeXtyZXR1cm4geXQodCkoZSxuKX1jYXRjaCh0KXtpZihFZShyKSx0IT09dCswKXRocm93IHQ7U2UoMSwwKX19LEs6ZnVuY3Rpb24odCl7dmFyIGU9QWUoKTt0cnl7cmV0dXJuIHl0KHQpKCl9Y2F0Y2godCl7aWYoRWUoZSksdCE9PXQrMCl0aHJvdyB0O1NlKDEsMCl9fSxmOmZ1bmN0aW9uKHQsZSl7dmFyIG49QWUoKTt0cnl7cmV0dXJuIHl0KHQpKGUpfWNhdGNoKHQpe2lmKEVlKG4pLHQhPT10KzApdGhyb3cgdDtTZSgxLDApfX0sUDpmdW5jdGlvbih0LGUsbil7dmFyIHI9QWUoKTt0cnl7cmV0dXJuIHl0KHQpKGUsbil9Y2F0Y2godCl7aWYoRWUociksdCE9PXQrMCl0aHJvdyB0O1NlKDEsMCl9fSxROmZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1BZSgpO3RyeXtyZXR1cm4geXQodCkoZSxuKX1jYXRjaCh0KXtpZihFZShyKSx0IT09dCswKXRocm93IHQ7U2UoMSwwKX19LGs6ZnVuY3Rpb24odCxlLG4pe3ZhciByPUFlKCk7dHJ5e3JldHVybiB5dCh0KShlLG4pfWNhdGNoKHQpe2lmKEVlKHIpLHQhPT10KzApdGhyb3cgdDtTZSgxLDApfX0scDpmdW5jdGlvbih0LGUsbixyKXt2YXIgaT1BZSgpO3RyeXtyZXR1cm4geXQodCkoZSxuLHIpfWNhdGNoKHQpe2lmKEVlKGkpLHQhPT10KzApdGhyb3cgdDtTZSgxLDApfX0scTpmdW5jdGlvbih0LGUsbixyLGkpe3ZhciBvPUFlKCk7dHJ5e3JldHVybiB5dCh0KShlLG4scixpKX1jYXRjaCh0KXtpZihFZShvKSx0IT09dCswKXRocm93IHQ7U2UoMSwwKX19LE46ZnVuY3Rpb24odCxlLG4scixpLG8pe3ZhciBhPUFlKCk7dHJ5e3JldHVybiB5dCh0KShlLG4scixpLG8pfWNhdGNoKHQpe2lmKEVlKGEpLHQhPT10KzApdGhyb3cgdDtTZSgxLDApfX0sczpmdW5jdGlvbih0LGUsbixyLGksbyl7dmFyIGE9QWUoKTt0cnl7cmV0dXJuIHl0KHQpKGUsbixyLGksbyl9Y2F0Y2godCl7aWYoRWUoYSksdCE9PXQrMCl0aHJvdyB0O1NlKDEsMCl9fSx3OmZ1bmN0aW9uKHQsZSxuLHIsaSxvLGEpe3ZhciBzPUFlKCk7dHJ5e3JldHVybiB5dCh0KShlLG4scixpLG8sYSl9Y2F0Y2godCl7aWYoRWUocyksdCE9PXQrMCl0aHJvdyB0O1NlKDEsMCl9fSxMOmZ1bmN0aW9uKHQsZSxuLHIsaSxvLGEscyl7dmFyIHU9QWUoKTt0cnl7cmV0dXJuIHl0KHQpKGUsbixyLGksbyxhLHMpfWNhdGNoKHQpe2lmKEVlKHUpLHQhPT10KzApdGhyb3cgdDtTZSgxLDApfX0sRTpmdW5jdGlvbih0LGUsbixyLGksbyxhLHMsdSxjLGwscCl7dmFyIGY9QWUoKTt0cnl7cmV0dXJuIHl0KHQpKGUsbixyLGksbyxhLHMsdSxjLGwscCl9Y2F0Y2godCl7aWYoRWUoZiksdCE9PXQrMCl0aHJvdyB0O1NlKDEsMCl9fSxhYTpmdW5jdGlvbih0LGUsbixyLGksbyxhLHMpe3ZhciB1PUFlKCk7dHJ5e3JldHVybiBNZSh0LGUsbixyLGksbyxhLHMpfWNhdGNoKHQpe2lmKEVlKHUpLHQhPT10KzApdGhyb3cgdDtTZSgxLDApfX0sXzpmdW5jdGlvbih0LGUsbixyLGksbyxhKXt2YXIgcz1BZSgpO3RyeXtyZXR1cm4ga2UodCxlLG4scixpLG8sYSl9Y2F0Y2godCl7aWYoRWUocyksdCE9PXQrMCl0aHJvdyB0O1NlKDEsMCl9fSxaOmZ1bmN0aW9uKHQsZSxuLHIsaSl7dmFyIG89QWUoKTt0cnl7cmV0dXJuIFVlKHQsZSxuLHIsaSl9Y2F0Y2godCl7aWYoRWUobyksdCE9PXQrMCl0aHJvdyB0O1NlKDEsMCl9fSxjYTpmdW5jdGlvbih0LGUsbixyKXt2YXIgaT1BZSgpO3RyeXtyZXR1cm4gUmUodCxlLG4scil9Y2F0Y2godCl7aWYoRWUoaSksdCE9PXQrMCl0aHJvdyB0O1NlKDEsMCl9fSwkOmZ1bmN0aW9uKHQpe3ZhciBlPUFlKCk7dHJ5e3JldHVybiAkZSh0KX1jYXRjaCh0KXtpZihFZShlKSx0IT09dCswKXRocm93IHQ7U2UoMSwwKX19LGJhOmZ1bmN0aW9uKHQsZSl7dmFyIG49QWUoKTt0cnl7cmV0dXJuIGplKHQsZSl9Y2F0Y2godCl7aWYoRWUobiksdCE9PXQrMCl0aHJvdyB0O1NlKDEsMCl9fSxZOmZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1BZSgpO3RyeXtyZXR1cm4gQ2UodCxlLG4pfWNhdGNoKHQpe2lmKEVlKHIpLHQhPT10KzApdGhyb3cgdDtTZSgxLDApfX0sZzpmdW5jdGlvbih0KXt2YXIgZT1BZSgpO3RyeXt5dCh0KSgpfWNhdGNoKHQpe2lmKEVlKGUpLHQhPT10KzApdGhyb3cgdDtTZSgxLDApfX0scjpmdW5jdGlvbih0LGUpe3ZhciBuPUFlKCk7dHJ5e3l0KHQpKGUpfWNhdGNoKHQpe2lmKEVlKG4pLHQhPT10KzApdGhyb3cgdDtTZSgxLDApfX0saTpmdW5jdGlvbih0LGUsbil7dmFyIHI9QWUoKTt0cnl7eXQodCkoZSxuKX1jYXRjaCh0KXtpZihFZShyKSx0IT09dCswKXRocm93IHQ7U2UoMSwwKX19LGhhOmZ1bmN0aW9uKHQsZSxuLHIpe3ZhciBpPUFlKCk7dHJ5e3l0KHQpKGUsbixyKX1jYXRjaCh0KXtpZihFZShpKSx0IT09dCswKXRocm93IHQ7U2UoMSwwKX19LG06ZnVuY3Rpb24odCxlLG4scil7dmFyIGk9QWUoKTt0cnl7eXQodCkoZSxuLHIpfWNhdGNoKHQpe2lmKEVlKGkpLHQhPT10KzApdGhyb3cgdDtTZSgxLDApfX0sdjpmdW5jdGlvbih0LGUsbixyLGkpe3ZhciBvPUFlKCk7dHJ5e3l0KHQpKGUsbixyLGkpfWNhdGNoKHQpe2lmKEVlKG8pLHQhPT10KzApdGhyb3cgdDtTZSgxLDApfX0sdTpmdW5jdGlvbih0LGUsbixyLGksbyl7dmFyIGE9QWUoKTt0cnl7eXQodCkoZSxuLHIsaSxvKX1jYXRjaCh0KXtpZihFZShhKSx0IT09dCswKXRocm93IHQ7U2UoMSwwKX19LE86ZnVuY3Rpb24odCxlLG4scixpLG8sYSl7dmFyIHM9QWUoKTt0cnl7eXQodCkoZSxuLHIsaSxvLGEpfWNhdGNoKHQpe2lmKEVlKHMpLHQhPT10KzApdGhyb3cgdDtTZSgxLDApfX0sQTpmdW5jdGlvbih0LGUsbixyLGksbyxhLHMpe3ZhciB1PUFlKCk7dHJ5e3l0KHQpKGUsbixyLGksbyxhLHMpfWNhdGNoKHQpe2lmKEVlKHUpLHQhPT10KzApdGhyb3cgdDtTZSgxLDApfX0sa2E6ZnVuY3Rpb24odCxlLG4scixpLG8sYSxzLHUpe3ZhciBjPUFlKCk7dHJ5e3l0KHQpKGUsbixyLGksbyxhLHMsdSl9Y2F0Y2godCl7aWYoRWUoYyksdCE9PXQrMCl0aHJvdyB0O1NlKDEsMCl9fSxDOmZ1bmN0aW9uKHQsZSxuLHIsaSxvLGEscyx1LGMsbCl7dmFyIHA9QWUoKTt0cnl7eXQodCkoZSxuLHIsaSxvLGEscyx1LGMsbCl9Y2F0Y2godCl7aWYoRWUocCksdCE9PXQrMCl0aHJvdyB0O1NlKDEsMCl9fSxEOmZ1bmN0aW9uKHQsZSxuLHIsaSxvLGEscyx1LGMsbCxwLGYsZCxoLGcpe3ZhciBiPUFlKCk7dHJ5e3l0KHQpKGUsbixyLGksbyxhLHMsdSxjLGwscCxmLGQsaCxnKX1jYXRjaCh0KXtpZihFZShiKSx0IT09dCswKXRocm93IHQ7U2UoMSwwKX19LGZhOmZ1bmN0aW9uKHQsZSxuLHIsaSxvLGEscyl7dmFyIHU9QWUoKTt0cnl7RmUodCxlLG4scixpLG8sYSxzKX1jYXRjaCh0KXtpZihFZSh1KSx0IT09dCswKXRocm93IHQ7U2UoMSwwKX19LGRhOmZ1bmN0aW9uKHQsZSxuLHIsaSxvLGEscyx1LGMsbCxwKXt2YXIgZj1BZSgpO3RyeXtMZSh0LGUsbixyLGksbyxhLHMsdSxjLGwscCl9Y2F0Y2godCl7aWYoRWUoZiksdCE9PXQrMCl0aHJvdyB0O1NlKDEsMCl9fSxlYTpmdW5jdGlvbih0LGUsbixyLGksbyl7dmFyIGE9QWUoKTt0cnl7TmUodCxlLG4scixpLG8pfWNhdGNoKHQpe2lmKEVlKGEpLHQhPT10KzApdGhyb3cgdDtTZSgxLDApfX0sbzpmdW5jdGlvbih0KXtyZXR1cm4gdH0sYTokfHxzLndhc21NZW1vcnksRzpmdW5jdGlvbih0KXthZT10fSxsYTpsZSx6OmZ1bmN0aW9uKHQsZSxuLHIpe3JldHVybiBsZSh0LGUsbixyKX19OyFmdW5jdGlvbigpe2Z1bmN0aW9uIHQodCxlKXtzLmFzbT10LmV4cG9ydHMsZHQucWMucHVzaChzLmFzbS5zYikscT1zLmFzbS51YixZLnVuc2hpZnQocy5hc20uVmEpLGs9ZSx4fHwoZXQtLSxzLm1vbml0b3JSdW5EZXBlbmRlbmNpZXMmJnMubW9uaXRvclJ1bkRlcGVuZGVuY2llcyhldCksMD09ZXQmJihudWxsIT09bnQmJihjbGVhckludGVydmFsKG50KSxudD1udWxsKSxydCYmKHQ9cnQscnQ9bnVsbCx0KCkpKSl9ZnVuY3Rpb24gZShlKXt0KGUuaW5zdGFuY2UsZS5tb2R1bGUpfWZ1bmN0aW9uIG4odCl7cmV0dXJuIGZ1bmN0aW9uKCl7aWYoIUUmJihffHx2KSl7aWYoXCJmdW5jdGlvblwiPT10eXBlb2YgZmV0Y2gmJiF0dC5zdGFydHNXaXRoKFwiZmlsZTovL1wiKSlyZXR1cm4gZmV0Y2godHQse2NyZWRlbnRpYWxzOlwic2FtZS1vcmlnaW5cIn0pLnRoZW4oKGZ1bmN0aW9uKHQpe2lmKCF0Lm9rKXRocm93XCJmYWlsZWQgdG8gbG9hZCB3YXNtIGJpbmFyeSBmaWxlIGF0ICdcIit0dCtcIidcIjtyZXR1cm4gdC5hcnJheUJ1ZmZlcigpfSkpLmNhdGNoKChmdW5jdGlvbigpe3JldHVybiBhdCgpfSkpO2lmKHApcmV0dXJuIG5ldyBQcm9taXNlKChmdW5jdGlvbih0LGUpe3AodHQsKGZ1bmN0aW9uKGUpe3QobmV3IFVpbnQ4QXJyYXkoZSkpfSksZSl9KSl9cmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKGZ1bmN0aW9uKCl7cmV0dXJuIGF0KCl9KSl9KCkudGhlbigoZnVuY3Rpb24odCl7cmV0dXJuIFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlKHQscil9KSkudGhlbigoZnVuY3Rpb24odCl7cmV0dXJuIHR9KSkudGhlbih0LChmdW5jdGlvbih0KXtQKFwiZmFpbGVkIHRvIGFzeW5jaHJvbm91c2x5IHByZXBhcmUgd2FzbTogXCIrdCksaXQodCl9KSl9dmFyIHI9e2E6ZmV9O2lmKHh8fChldCsrLHMubW9uaXRvclJ1bkRlcGVuZGVuY2llcyYmcy5tb25pdG9yUnVuRGVwZW5kZW5jaWVzKGV0KSkscy5pbnN0YW50aWF0ZVdhc20pdHJ5e3JldHVybiBzLmluc3RhbnRpYXRlV2FzbShyLHQpfWNhdGNoKHQpe3JldHVybiBQKFwiTW9kdWxlLmluc3RhbnRpYXRlV2FzbSBjYWxsYmFjayBmYWlsZWQgd2l0aCBlcnJvcjogXCIrdCksITF9KEV8fFwiZnVuY3Rpb25cIiE9dHlwZW9mIFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlU3RyZWFtaW5nfHxvdCgpfHx0dC5zdGFydHNXaXRoKFwiZmlsZTovL1wiKXx8d3x8XCJmdW5jdGlvblwiIT10eXBlb2YgZmV0Y2g/bihlKTpmZXRjaCh0dCx7Y3JlZGVudGlhbHM6XCJzYW1lLW9yaWdpblwifSkudGhlbigoZnVuY3Rpb24odCl7cmV0dXJuIFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlU3RyZWFtaW5nKHQscikudGhlbihlLChmdW5jdGlvbih0KXtyZXR1cm4gUChcIndhc20gc3RyZWFtaW5nIGNvbXBpbGUgZmFpbGVkOiBcIit0KSxQKFwiZmFsbGluZyBiYWNrIHRvIEFycmF5QnVmZmVyIGluc3RhbnRpYXRpb25cIiksbihlKX0pKX0pKSkuY2F0Y2goYyl9KCkscy5fX193YXNtX2NhbGxfY3RvcnM9ZnVuY3Rpb24oKXtyZXR1cm4ocy5fX193YXNtX2NhbGxfY3RvcnM9cy5hc20uVmEpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0scy5fT3J0SW5pdD1mdW5jdGlvbigpe3JldHVybihzLl9PcnRJbml0PXMuYXNtLldhKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHMuX09ydENyZWF0ZVNlc3Npb25PcHRpb25zPWZ1bmN0aW9uKCl7cmV0dXJuKHMuX09ydENyZWF0ZVNlc3Npb25PcHRpb25zPXMuYXNtLlhhKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHMuX09ydEFwcGVuZEV4ZWN1dGlvblByb3ZpZGVyPWZ1bmN0aW9uKCl7cmV0dXJuKHMuX09ydEFwcGVuZEV4ZWN1dGlvblByb3ZpZGVyPXMuYXNtLllhKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHMuX09ydEFkZFNlc3Npb25Db25maWdFbnRyeT1mdW5jdGlvbigpe3JldHVybihzLl9PcnRBZGRTZXNzaW9uQ29uZmlnRW50cnk9cy5hc20uWmEpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0scy5fT3J0UmVsZWFzZVNlc3Npb25PcHRpb25zPWZ1bmN0aW9uKCl7cmV0dXJuKHMuX09ydFJlbGVhc2VTZXNzaW9uT3B0aW9ucz1zLmFzbS5fYSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxzLl9PcnRDcmVhdGVTZXNzaW9uPWZ1bmN0aW9uKCl7cmV0dXJuKHMuX09ydENyZWF0ZVNlc3Npb249cy5hc20uJGEpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0scy5fT3J0UmVsZWFzZVNlc3Npb249ZnVuY3Rpb24oKXtyZXR1cm4ocy5fT3J0UmVsZWFzZVNlc3Npb249cy5hc20uYWIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0scy5fT3J0R2V0SW5wdXRDb3VudD1mdW5jdGlvbigpe3JldHVybihzLl9PcnRHZXRJbnB1dENvdW50PXMuYXNtLmJiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHMuX09ydEdldE91dHB1dENvdW50PWZ1bmN0aW9uKCl7cmV0dXJuKHMuX09ydEdldE91dHB1dENvdW50PXMuYXNtLmNiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHMuX09ydEdldElucHV0TmFtZT1mdW5jdGlvbigpe3JldHVybihzLl9PcnRHZXRJbnB1dE5hbWU9cy5hc20uZGIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0scy5fT3J0R2V0T3V0cHV0TmFtZT1mdW5jdGlvbigpe3JldHVybihzLl9PcnRHZXRPdXRwdXROYW1lPXMuYXNtLmViKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHMuX09ydEZyZWU9ZnVuY3Rpb24oKXtyZXR1cm4ocy5fT3J0RnJlZT1zLmFzbS5mYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxzLl9PcnRDcmVhdGVUZW5zb3I9ZnVuY3Rpb24oKXtyZXR1cm4ocy5fT3J0Q3JlYXRlVGVuc29yPXMuYXNtLmdiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHMuX09ydEdldFRlbnNvckRhdGE9ZnVuY3Rpb24oKXtyZXR1cm4ocy5fT3J0R2V0VGVuc29yRGF0YT1zLmFzbS5oYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxzLl9PcnRSZWxlYXNlVGVuc29yPWZ1bmN0aW9uKCl7cmV0dXJuKHMuX09ydFJlbGVhc2VUZW5zb3I9cy5hc20uaWIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0scy5fT3J0Q3JlYXRlUnVuT3B0aW9ucz1mdW5jdGlvbigpe3JldHVybihzLl9PcnRDcmVhdGVSdW5PcHRpb25zPXMuYXNtLmpiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHMuX09ydEFkZFJ1bkNvbmZpZ0VudHJ5PWZ1bmN0aW9uKCl7cmV0dXJuKHMuX09ydEFkZFJ1bkNvbmZpZ0VudHJ5PXMuYXNtLmtiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHMuX09ydFJlbGVhc2VSdW5PcHRpb25zPWZ1bmN0aW9uKCl7cmV0dXJuKHMuX09ydFJlbGVhc2VSdW5PcHRpb25zPXMuYXNtLmxiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHMuX09ydFJ1bj1mdW5jdGlvbigpe3JldHVybihzLl9PcnRSdW49cy5hc20ubWIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0scy5fT3J0RW5kUHJvZmlsaW5nPWZ1bmN0aW9uKCl7cmV0dXJuKHMuX09ydEVuZFByb2ZpbGluZz1zLmFzbS5uYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfTt2YXIgZGU9cy5fcHRocmVhZF9zZWxmPWZ1bmN0aW9uKCl7cmV0dXJuKGRlPXMuX3B0aHJlYWRfc2VsZj1zLmFzbS5vYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxoZT1zLl9tYWxsb2M9ZnVuY3Rpb24oKXtyZXR1cm4oaGU9cy5fbWFsbG9jPXMuYXNtLnBiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGdlPXMuX2ZyZWU9ZnVuY3Rpb24oKXtyZXR1cm4oZ2U9cy5fZnJlZT1zLmFzbS5xYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxiZT1zLl9mZmx1c2g9ZnVuY3Rpb24oKXtyZXR1cm4oYmU9cy5fZmZsdXNoPXMuYXNtLnJiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O3MuX19lbXNjcmlwdGVuX3Rsc19pbml0PWZ1bmN0aW9uKCl7cmV0dXJuKHMuX19lbXNjcmlwdGVuX3Rsc19pbml0PXMuYXNtLnNiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O3ZhciBtZT1zLl9fX2Z1bmNzX29uX2V4aXQ9ZnVuY3Rpb24oKXtyZXR1cm4obWU9cy5fX19mdW5jc19vbl9leGl0PXMuYXNtLnRiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHllPXMuX19lbXNjcmlwdGVuX3RocmVhZF9pbml0PWZ1bmN0aW9uKCl7cmV0dXJuKHllPXMuX19lbXNjcmlwdGVuX3RocmVhZF9pbml0PXMuYXNtLnZiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O3MuX19lbXNjcmlwdGVuX3RocmVhZF9jcmFzaGVkPWZ1bmN0aW9uKCl7cmV0dXJuKHMuX19lbXNjcmlwdGVuX3RocmVhZF9jcmFzaGVkPXMuYXNtLndiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O3ZhciBfZSx2ZT1zLl9lbXNjcmlwdGVuX3J1bl9pbl9tYWluX3J1bnRpbWVfdGhyZWFkX2pzPWZ1bmN0aW9uKCl7cmV0dXJuKHZlPXMuX2Vtc2NyaXB0ZW5fcnVuX2luX21haW5fcnVudGltZV90aHJlYWRfanM9cy5hc20ueGIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sd2U9cy5fX2Vtc2NyaXB0ZW5fcHJveHlfZXhlY3V0ZV90YXNrX3F1ZXVlPWZ1bmN0aW9uKCl7cmV0dXJuKHdlPXMuX19lbXNjcmlwdGVuX3Byb3h5X2V4ZWN1dGVfdGFza19xdWV1ZT1zLmFzbS55YikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSx4ZT1zLl9fZW1zY3JpcHRlbl90aHJlYWRfZnJlZV9kYXRhPWZ1bmN0aW9uKCl7cmV0dXJuKHhlPXMuX19lbXNjcmlwdGVuX3RocmVhZF9mcmVlX2RhdGE9cy5hc20uemIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sVGU9cy5fX2Vtc2NyaXB0ZW5fdGhyZWFkX2V4aXQ9ZnVuY3Rpb24oKXtyZXR1cm4oVGU9cy5fX2Vtc2NyaXB0ZW5fdGhyZWFkX2V4aXQ9cy5hc20uQWIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sU2U9cy5fc2V0VGhyZXc9ZnVuY3Rpb24oKXtyZXR1cm4oU2U9cy5fc2V0VGhyZXc9cy5hc20uQmIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sT2U9cy5fZW1zY3JpcHRlbl9zdGFja19zZXRfbGltaXRzPWZ1bmN0aW9uKCl7cmV0dXJuKE9lPXMuX2Vtc2NyaXB0ZW5fc3RhY2tfc2V0X2xpbWl0cz1zLmFzbS5DYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxBZT1zLnN0YWNrU2F2ZT1mdW5jdGlvbigpe3JldHVybihBZT1zLnN0YWNrU2F2ZT1zLmFzbS5EYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxFZT1zLnN0YWNrUmVzdG9yZT1mdW5jdGlvbigpe3JldHVybihFZT1zLnN0YWNrUmVzdG9yZT1zLmFzbS5FYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxJZT1zLnN0YWNrQWxsb2M9ZnVuY3Rpb24oKXtyZXR1cm4oSWU9cy5zdGFja0FsbG9jPXMuYXNtLkZiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LFBlPXMuX19fY3hhX2Nhbl9jYXRjaD1mdW5jdGlvbigpe3JldHVybihQZT1zLl9fX2N4YV9jYW5fY2F0Y2g9cy5hc20uR2IpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sRGU9cy5fX19jeGFfaXNfcG9pbnRlcl90eXBlPWZ1bmN0aW9uKCl7cmV0dXJuKERlPXMuX19fY3hhX2lzX3BvaW50ZXJfdHlwZT1zLmFzbS5IYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSwkZT1zLmR5bkNhbGxfaj1mdW5jdGlvbigpe3JldHVybigkZT1zLmR5bkNhbGxfaj1zLmFzbS5JYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxrZT1zLmR5bkNhbGxfaWlpaWlqPWZ1bmN0aW9uKCl7cmV0dXJuKGtlPXMuZHluQ2FsbF9paWlpaWo9cy5hc20uSmIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sQ2U9cy5keW5DYWxsX2ppaT1mdW5jdGlvbigpe3JldHVybihDZT1zLmR5bkNhbGxfamlpPXMuYXNtLktiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LEZlPXMuZHluQ2FsbF92aWlpaWlqPWZ1bmN0aW9uKCl7cmV0dXJuKEZlPXMuZHluQ2FsbF92aWlpaWlqPXMuYXNtLkxiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LE5lPXMuZHluQ2FsbF92amppPWZ1bmN0aW9uKCl7cmV0dXJuKE5lPXMuZHluQ2FsbF92amppPXMuYXNtLk1iKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LExlPXMuZHluQ2FsbF92aWlpampqaWk9ZnVuY3Rpb24oKXtyZXR1cm4oTGU9cy5keW5DYWxsX3ZpaWlqamppaT1zLmFzbS5OYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxSZT1zLmR5bkNhbGxfaWlqPWZ1bmN0aW9uKCl7cmV0dXJuKFJlPXMuZHluQ2FsbF9paWo9cy5hc20uT2IpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0samU9cy5keW5DYWxsX2ppPWZ1bmN0aW9uKCl7cmV0dXJuKGplPXMuZHluQ2FsbF9qaT1zLmFzbS5QYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxNZT1zLmR5bkNhbGxfaWlpaWlpaj1mdW5jdGlvbigpe3JldHVybihNZT1zLmR5bkNhbGxfaWlpaWlpaj1zLmFzbS5RYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxVZT1zLmR5bkNhbGxfaWlpaj1mdW5jdGlvbigpe3JldHVybihVZT1zLmR5bkNhbGxfaWlpaj1zLmFzbS5SYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfTtmdW5jdGlvbiBWZSgpe2Z1bmN0aW9uIHQoKXtpZighX2UmJihfZT0hMCxzLmNhbGxlZFJ1bj0hMCwhTSkmJih4fHxodChZKSx1KHMpLHMub25SdW50aW1lSW5pdGlhbGl6ZWQmJnMub25SdW50aW1lSW5pdGlhbGl6ZWQoKSwheCkpe2lmKHMucG9zdFJ1bilmb3IoXCJmdW5jdGlvblwiPT10eXBlb2Ygcy5wb3N0UnVuJiYocy5wb3N0UnVuPVtzLnBvc3RSdW5dKTtzLnBvc3RSdW4ubGVuZ3RoOyl7dmFyIHQ9cy5wb3N0UnVuLnNoaWZ0KCk7Wi51bnNoaWZ0KHQpfWh0KFopfX1pZighKDA8ZXQpKWlmKHgpdShzKSx4fHxodChZKSxwb3N0TWVzc2FnZSh7Y21kOlwibG9hZGVkXCJ9KTtlbHNle2lmKHMucHJlUnVuKWZvcihcImZ1bmN0aW9uXCI9PXR5cGVvZiBzLnByZVJ1biYmKHMucHJlUnVuPVtzLnByZVJ1bl0pO3MucHJlUnVuLmxlbmd0aDspUSgpO2h0KFgpLDA8ZXR8fChzLnNldFN0YXR1cz8ocy5zZXRTdGF0dXMoXCJSdW5uaW5nLi4uXCIpLHNldFRpbWVvdXQoKGZ1bmN0aW9uKCl7c2V0VGltZW91dCgoZnVuY3Rpb24oKXtzLnNldFN0YXR1cyhcIlwiKX0pLDEpLHQoKX0pLDEpKTp0KCkpfX1pZihzLlVURjhUb1N0cmluZz1CLHMuc3RyaW5nVG9VVEY4PWZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4geih0LHIoKSxlLG4pfSxzLmxlbmd0aEJ5dGVzVVRGOD1HLHMua2VlcFJ1bnRpbWVBbGl2ZT1KLHMud2FzbU1lbW9yeT0kLHMuc3RhY2tTYXZlPUFlLHMuc3RhY2tSZXN0b3JlPUVlLHMuc3RhY2tBbGxvYz1JZSxzLkV4aXRTdGF0dXM9dXQscy5QVGhyZWFkPWR0LHJ0PWZ1bmN0aW9uIHQoKXtfZXx8VmUoKSxfZXx8KHJ0PXQpfSxzLnByZUluaXQpZm9yKFwiZnVuY3Rpb25cIj09dHlwZW9mIHMucHJlSW5pdCYmKHMucHJlSW5pdD1bcy5wcmVJbml0XSk7MDxzLnByZUluaXQubGVuZ3RoOylzLnByZUluaXQucG9wKCkoKTtyZXR1cm4gVmUoKSx0LnJlYWR5fSk7dC5leHBvcnRzPXJ9LDkzMjoodCxlLG4pPT57dmFyIF9zY3JpcHREaXIscj0oX3NjcmlwdERpcj0oX3NjcmlwdERpcj1cInVuZGVmaW5lZFwiIT10eXBlb2YgZG9jdW1lbnQmJmRvY3VtZW50LmN1cnJlbnRTY3JpcHQ/ZG9jdW1lbnQuY3VycmVudFNjcmlwdC5zcmM6dm9pZCAwKXx8XCIvaW5kZXguanNcIixmdW5jdGlvbih0KXt2YXIgZSxyLGk7dD10fHx7fSxlfHwoZT12b2lkIDAhPT10P3Q6e30pLGUucmVhZHk9bmV3IFByb21pc2UoKGZ1bmN0aW9uKHQsZSl7cj10LGk9ZX0pKTt2YXIgbyxhLHMsdSxjLGwscD1PYmplY3QuYXNzaWduKHt9LGUpLGY9XCIuL3RoaXMucHJvZ3JhbVwiLGQ9KHQsZSk9Pnt0aHJvdyBlfSxoPVwib2JqZWN0XCI9PXR5cGVvZiB3aW5kb3csZz1cImZ1bmN0aW9uXCI9PXR5cGVvZiBpbXBvcnRTY3JpcHRzLGI9XCJvYmplY3RcIj09dHlwZW9mIHByb2Nlc3MmJlwib2JqZWN0XCI9PXR5cGVvZiBwcm9jZXNzLnZlcnNpb25zJiZcInN0cmluZ1wiPT10eXBlb2YgcHJvY2Vzcy52ZXJzaW9ucy5ub2RlLG09XCJcIjtiPyhtPWc/big5MDgpLmRpcm5hbWUobSkrXCIvXCI6XCIvL1wiLGw9KCk9PntjfHwodT1uKDEzODQpLGM9big5MDgpKX0sbz1mdW5jdGlvbih0LGUpe3JldHVybiBsKCksdD1jLm5vcm1hbGl6ZSh0KSx1LnJlYWRGaWxlU3luYyh0LGU/dm9pZCAwOlwidXRmOFwiKX0scz10PT4oKHQ9byh0LCEwKSkuYnVmZmVyfHwodD1uZXcgVWludDhBcnJheSh0KSksdCksYT0odCxlLG4pPT57bCgpLHQ9Yy5ub3JtYWxpemUodCksdS5yZWFkRmlsZSh0LChmdW5jdGlvbih0LHIpe3Q/bih0KTplKHIuYnVmZmVyKX0pKX0sMTxwcm9jZXNzLmFyZ3YubGVuZ3RoJiYoZj1wcm9jZXNzLmFyZ3ZbMV0ucmVwbGFjZSgvXFxcXC9nLFwiL1wiKSkscHJvY2Vzcy5hcmd2LnNsaWNlKDIpLHByb2Nlc3Mub24oXCJ1bmNhdWdodEV4Y2VwdGlvblwiLChmdW5jdGlvbih0KXtpZighKHQgaW5zdGFuY2VvZiBLKSl0aHJvdyB0fSkpLHByb2Nlc3Mub24oXCJ1bmhhbmRsZWRSZWplY3Rpb25cIiwoZnVuY3Rpb24odCl7dGhyb3cgdH0pKSxkPSh0LGUpPT57aWYod3x8MDxVKXRocm93IHByb2Nlc3MuZXhpdENvZGU9dCxlO2UgaW5zdGFuY2VvZiBLfHx2KFwiZXhpdGluZyBkdWUgdG8gZXhjZXB0aW9uOiBcIitlKSxwcm9jZXNzLmV4aXQodCl9LGUuaW5zcGVjdD1mdW5jdGlvbigpe3JldHVyblwiW0Vtc2NyaXB0ZW4gTW9kdWxlIG9iamVjdF1cIn0pOihofHxnKSYmKGc/bT1zZWxmLmxvY2F0aW9uLmhyZWY6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGRvY3VtZW50JiZkb2N1bWVudC5jdXJyZW50U2NyaXB0JiYobT1kb2N1bWVudC5jdXJyZW50U2NyaXB0LnNyYyksX3NjcmlwdERpciYmKG09X3NjcmlwdERpciksbT0wIT09bS5pbmRleE9mKFwiYmxvYjpcIik/bS5zdWJzdHIoMCxtLnJlcGxhY2UoL1s/I10uKi8sXCJcIikubGFzdEluZGV4T2YoXCIvXCIpKzEpOlwiXCIsbz10PT57dmFyIGU9bmV3IFhNTEh0dHBSZXF1ZXN0O3JldHVybiBlLm9wZW4oXCJHRVRcIix0LCExKSxlLnNlbmQobnVsbCksZS5yZXNwb25zZVRleHR9LGcmJihzPXQ9Pnt2YXIgZT1uZXcgWE1MSHR0cFJlcXVlc3Q7cmV0dXJuIGUub3BlbihcIkdFVFwiLHQsITEpLGUucmVzcG9uc2VUeXBlPVwiYXJyYXlidWZmZXJcIixlLnNlbmQobnVsbCksbmV3IFVpbnQ4QXJyYXkoZS5yZXNwb25zZSl9KSxhPSh0LGUsbik9Pnt2YXIgcj1uZXcgWE1MSHR0cFJlcXVlc3Q7ci5vcGVuKFwiR0VUXCIsdCwhMCksci5yZXNwb25zZVR5cGU9XCJhcnJheWJ1ZmZlclwiLHIub25sb2FkPSgpPT57MjAwPT1yLnN0YXR1c3x8MD09ci5zdGF0dXMmJnIucmVzcG9uc2U/ZShyLnJlc3BvbnNlKTpuKCl9LHIub25lcnJvcj1uLHIuc2VuZChudWxsKX0pO3ZhciB5LF89ZS5wcmludHx8Y29uc29sZS5sb2cuYmluZChjb25zb2xlKSx2PWUucHJpbnRFcnJ8fGNvbnNvbGUud2Fybi5iaW5kKGNvbnNvbGUpO09iamVjdC5hc3NpZ24oZSxwKSxwPW51bGwsZS50aGlzUHJvZ3JhbSYmKGY9ZS50aGlzUHJvZ3JhbSksZS5xdWl0JiYoZD1lLnF1aXQpLGUud2FzbUJpbmFyeSYmKHk9ZS53YXNtQmluYXJ5KTt2YXIgdz1lLm5vRXhpdFJ1bnRpbWV8fCExO1wib2JqZWN0XCIhPXR5cGVvZiBXZWJBc3NlbWJseSYmVyhcIm5vIG5hdGl2ZSB3YXNtIHN1cHBvcnQgZGV0ZWN0ZWRcIik7dmFyIHgsVCxTLE8sQSxFLEk9ITEsUD1cInVuZGVmaW5lZFwiIT10eXBlb2YgVGV4dERlY29kZXI/bmV3IFRleHREZWNvZGVyKFwidXRmOFwiKTp2b2lkIDA7ZnVuY3Rpb24gRCh0LGUsbil7dmFyIHI9KGU+Pj49MCkrbjtmb3Iobj1lO3Rbbl0mJiEobj49cik7KSsrbjtpZigxNjxuLWUmJnQuYnVmZmVyJiZQKXJldHVybiBQLmRlY29kZSh0LnN1YmFycmF5KGUsbikpO2ZvcihyPVwiXCI7ZTxuOyl7dmFyIGk9dFtlKytdO2lmKDEyOCZpKXt2YXIgbz02MyZ0W2UrK107aWYoMTkyPT0oMjI0JmkpKXIrPVN0cmluZy5mcm9tQ2hhckNvZGUoKDMxJmkpPDw2fG8pO2Vsc2V7dmFyIGE9NjMmdFtlKytdOzY1NTM2PihpPTIyND09KDI0MCZpKT8oMTUmaSk8PDEyfG88PDZ8YTooNyZpKTw8MTh8bzw8MTJ8YTw8Nnw2MyZ0W2UrK10pP3IrPVN0cmluZy5mcm9tQ2hhckNvZGUoaSk6KGktPTY1NTM2LHIrPVN0cmluZy5mcm9tQ2hhckNvZGUoNTUyOTZ8aT4+MTAsNTYzMjB8MTAyMyZpKSl9fWVsc2Ugcis9U3RyaW5nLmZyb21DaGFyQ29kZShpKX1yZXR1cm4gcn1mdW5jdGlvbiAkKHQsZSl7cmV0dXJuKHQ+Pj49MCk/RChPLHQsZSk6XCJcIn1mdW5jdGlvbiBrKHQsZSxuLHIpe2lmKCEoMDxyKSlyZXR1cm4gMDt2YXIgaT1uPj4+PTA7cj1uK3ItMTtmb3IodmFyIG89MDtvPHQubGVuZ3RoOysrbyl7dmFyIGE9dC5jaGFyQ29kZUF0KG8pO2lmKDU1Mjk2PD1hJiY1NzM0Mz49YSYmKGE9NjU1MzYrKCgxMDIzJmEpPDwxMCl8MTAyMyZ0LmNoYXJDb2RlQXQoKytvKSksMTI3Pj1hKXtpZihuPj1yKWJyZWFrO2VbbisrPj4+MF09YX1lbHNle2lmKDIwNDc+PWEpe2lmKG4rMT49cilicmVhaztlW24rKz4+PjBdPTE5MnxhPj42fWVsc2V7aWYoNjU1MzU+PWEpe2lmKG4rMj49cilicmVhaztlW24rKz4+PjBdPTIyNHxhPj4xMn1lbHNle2lmKG4rMz49cilicmVhaztlW24rKz4+PjBdPTI0MHxhPj4xOCxlW24rKz4+PjBdPTEyOHxhPj4xMiY2M31lW24rKz4+PjBdPTEyOHxhPj42JjYzfWVbbisrPj4+MF09MTI4fDYzJmF9fXJldHVybiBlW24+Pj4wXT0wLG4taX1mdW5jdGlvbiBDKHQpe2Zvcih2YXIgZT0wLG49MDtuPHQubGVuZ3RoOysrbil7dmFyIHI9dC5jaGFyQ29kZUF0KG4pOzEyNz49cj9lKys6MjA0Nz49cj9lKz0yOjU1Mjk2PD1yJiY1NzM0Mz49cj8oZSs9NCwrK24pOmUrPTN9cmV0dXJuIGV9ZnVuY3Rpb24gRigpe3ZhciB0PXguYnVmZmVyO1Q9dCxlLkhFQVA4PVM9bmV3IEludDhBcnJheSh0KSxlLkhFQVAxNj1uZXcgSW50MTZBcnJheSh0KSxlLkhFQVAzMj1BPW5ldyBJbnQzMkFycmF5KHQpLGUuSEVBUFU4PU89bmV3IFVpbnQ4QXJyYXkodCksZS5IRUFQVTE2PW5ldyBVaW50MTZBcnJheSh0KSxlLkhFQVBVMzI9RT1uZXcgVWludDMyQXJyYXkodCksZS5IRUFQRjMyPW5ldyBGbG9hdDMyQXJyYXkodCksZS5IRUFQRjY0PW5ldyBGbG9hdDY0QXJyYXkodCl9dmFyIE4sTD1bXSxSPVtdLGo9W10sTT1bXSxVPTA7ZnVuY3Rpb24gVigpe3ZhciB0PWUucHJlUnVuLnNoaWZ0KCk7TC51bnNoaWZ0KHQpfXZhciBCLHo9MCxHPW51bGwsSD1udWxsO2Z1bmN0aW9uIFcodCl7dGhyb3cgZS5vbkFib3J0JiZlLm9uQWJvcnQodCksdih0PVwiQWJvcnRlZChcIit0K1wiKVwiKSxJPSEwLHQ9bmV3IFdlYkFzc2VtYmx5LlJ1bnRpbWVFcnJvcih0K1wiLiBCdWlsZCB3aXRoIC1zQVNTRVJUSU9OUyBmb3IgbW9yZSBpbmZvLlwiKSxpKHQpLHR9ZnVuY3Rpb24gcSgpe3JldHVybiBCLnN0YXJ0c1dpdGgoXCJkYXRhOmFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbTtiYXNlNjQsXCIpfWlmKEI9XCJvcnQtd2FzbS53YXNtXCIsIXEoKSl7dmFyIFg9QjtCPWUubG9jYXRlRmlsZT9lLmxvY2F0ZUZpbGUoWCxtKTptK1h9ZnVuY3Rpb24gWSgpe3ZhciB0PUI7dHJ5e2lmKHQ9PUImJnkpcmV0dXJuIG5ldyBVaW50OEFycmF5KHkpO2lmKHMpcmV0dXJuIHModCk7dGhyb3dcImJvdGggYXN5bmMgYW5kIHN5bmMgZmV0Y2hpbmcgb2YgdGhlIHdhc20gZmFpbGVkXCJ9Y2F0Y2godCl7Vyh0KX19ZnVuY3Rpb24gSyh0KXt0aGlzLm5hbWU9XCJFeGl0U3RhdHVzXCIsdGhpcy5tZXNzYWdlPVwiUHJvZ3JhbSB0ZXJtaW5hdGVkIHdpdGggZXhpdChcIit0K1wiKVwiLHRoaXMuc3RhdHVzPXR9ZnVuY3Rpb24gWih0KXtmb3IoOzA8dC5sZW5ndGg7KXQuc2hpZnQoKShlKX12YXIgSj1bXSxRPTAsdHQ9MDtmdW5jdGlvbiBldCh0KXt0aGlzLkRiPXQsdGhpcy56Yj10LTI0LHRoaXMuVWI9ZnVuY3Rpb24odCl7RVt0aGlzLnpiKzQ+PjI+Pj4wXT10fSx0aGlzLkViPWZ1bmN0aW9uKCl7cmV0dXJuIEVbdGhpcy56Yis0Pj4yPj4+MF19LHRoaXMuU2I9ZnVuY3Rpb24odCl7RVt0aGlzLnpiKzg+PjI+Pj4wXT10fSx0aGlzLldiPWZ1bmN0aW9uKCl7cmV0dXJuIEVbdGhpcy56Yis4Pj4yPj4+MF19LHRoaXMuVGI9ZnVuY3Rpb24oKXtBW3RoaXMuemI+PjI+Pj4wXT0wfSx0aGlzLkliPWZ1bmN0aW9uKHQpe1NbdGhpcy56YisxMj4+MD4+PjBdPXQ/MTowfSx0aGlzLlBiPWZ1bmN0aW9uKCl7cmV0dXJuIDAhPVNbdGhpcy56YisxMj4+MD4+PjBdfSx0aGlzLkpiPWZ1bmN0aW9uKHQpe1NbdGhpcy56YisxMz4+MD4+PjBdPXQ/MTowfSx0aGlzLkxiPWZ1bmN0aW9uKCl7cmV0dXJuIDAhPVNbdGhpcy56YisxMz4+MD4+PjBdfSx0aGlzLlJiPWZ1bmN0aW9uKHQsZSl7dGhpcy5GYigwKSx0aGlzLlViKHQpLHRoaXMuU2IoZSksdGhpcy5UYigpLHRoaXMuSWIoITEpLHRoaXMuSmIoITEpfSx0aGlzLk5iPWZ1bmN0aW9uKCl7QVt0aGlzLnpiPj4yPj4+MF0rPTF9LHRoaXMuWGI9ZnVuY3Rpb24oKXt2YXIgdD1BW3RoaXMuemI+PjI+Pj4wXTtyZXR1cm4gQVt0aGlzLnpiPj4yPj4+MF09dC0xLDE9PT10fSx0aGlzLkZiPWZ1bmN0aW9uKHQpe0VbdGhpcy56YisxNj4+Mj4+PjBdPXR9LHRoaXMuT2I9ZnVuY3Rpb24oKXtyZXR1cm4gRVt0aGlzLnpiKzE2Pj4yPj4+MF19LHRoaXMuUWI9ZnVuY3Rpb24oKXtpZihFdCh0aGlzLkViKCkpKXJldHVybiBFW3RoaXMuRGI+PjI+Pj4wXTt2YXIgdD10aGlzLk9iKCk7cmV0dXJuIDAhPT10P3Q6dGhpcy5EYn19ZnVuY3Rpb24gbnQodCl7cmV0dXJuIF90KG5ldyBldCh0KS56Yil9dmFyIHJ0PVtdO2Z1bmN0aW9uIGl0KHQpe3ZhciBlPXJ0W3RdO3JldHVybiBlfHwodD49cnQubGVuZ3RoJiYocnQubGVuZ3RoPXQrMSkscnRbdF09ZT1OLmdldCh0KSksZX1mdW5jdGlvbiBvdCh0KXt2YXIgZT1DKHQpKzEsbj15dChlKTtyZXR1cm4gbiYmayh0LFMsbixlKSxufXZhciBhdD17fTtmdW5jdGlvbiBzdCgpe2lmKCF1dCl7dmFyIHQsZT17VVNFUjpcIndlYl91c2VyXCIsTE9HTkFNRTpcIndlYl91c2VyXCIsUEFUSDpcIi9cIixQV0Q6XCIvXCIsSE9NRTpcIi9ob21lL3dlYl91c2VyXCIsTEFORzooXCJvYmplY3RcIj09dHlwZW9mIG5hdmlnYXRvciYmbmF2aWdhdG9yLmxhbmd1YWdlcyYmbmF2aWdhdG9yLmxhbmd1YWdlc1swXXx8XCJDXCIpLnJlcGxhY2UoXCItXCIsXCJfXCIpK1wiLlVURi04XCIsXzpmfHxcIi4vdGhpcy5wcm9ncmFtXCJ9O2Zvcih0IGluIGF0KXZvaWQgMD09PWF0W3RdP2RlbGV0ZSBlW3RdOmVbdF09YXRbdF07dmFyIG49W107Zm9yKHQgaW4gZSluLnB1c2godCtcIj1cIitlW3RdKTt1dD1ufXJldHVybiB1dH12YXIgdXQsY3Q9W251bGwsW10sW11dO2Z1bmN0aW9uIGx0KHQsZSl7dmFyIG49Y3RbdF07MD09PWV8fDEwPT09ZT8oKDE9PT10P186dikoRChuLDApKSxuLmxlbmd0aD0wKTpuLnB1c2goZSl9dmFyIHB0PTA7ZnVuY3Rpb24gZnQodCl7cmV0dXJuIDA9PXQlNCYmKDAhPXQlMTAwfHwwPT10JTQwMCl9dmFyIGR0PVszMSwyOSwzMSwzMCwzMSwzMCwzMSwzMSwzMCwzMSwzMCwzMV0saHQ9WzMxLDI4LDMxLDMwLDMxLDMwLDMxLDMxLDMwLDMxLDMwLDMxXTtmdW5jdGlvbiBndCh0LGUsbixyKXtmdW5jdGlvbiBpKHQsZSxuKXtmb3IodD1cIm51bWJlclwiPT10eXBlb2YgdD90LnRvU3RyaW5nKCk6dHx8XCJcIjt0Lmxlbmd0aDxlOyl0PW5bMF0rdDtyZXR1cm4gdH1mdW5jdGlvbiBvKHQsZSl7cmV0dXJuIGkodCxlLFwiMFwiKX1mdW5jdGlvbiBhKHQsZSl7ZnVuY3Rpb24gbih0KXtyZXR1cm4gMD50Py0xOjA8dD8xOjB9dmFyIHI7cmV0dXJuIDA9PT0ocj1uKHQuZ2V0RnVsbFllYXIoKS1lLmdldEZ1bGxZZWFyKCkpKSYmMD09PShyPW4odC5nZXRNb250aCgpLWUuZ2V0TW9udGgoKSkpJiYocj1uKHQuZ2V0RGF0ZSgpLWUuZ2V0RGF0ZSgpKSkscn1mdW5jdGlvbiBzKHQpe3N3aXRjaCh0LmdldERheSgpKXtjYXNlIDA6cmV0dXJuIG5ldyBEYXRlKHQuZ2V0RnVsbFllYXIoKS0xLDExLDI5KTtjYXNlIDE6cmV0dXJuIHQ7Y2FzZSAyOnJldHVybiBuZXcgRGF0ZSh0LmdldEZ1bGxZZWFyKCksMCwzKTtjYXNlIDM6cmV0dXJuIG5ldyBEYXRlKHQuZ2V0RnVsbFllYXIoKSwwLDIpO2Nhc2UgNDpyZXR1cm4gbmV3IERhdGUodC5nZXRGdWxsWWVhcigpLDAsMSk7Y2FzZSA1OnJldHVybiBuZXcgRGF0ZSh0LmdldEZ1bGxZZWFyKCktMSwxMSwzMSk7Y2FzZSA2OnJldHVybiBuZXcgRGF0ZSh0LmdldEZ1bGxZZWFyKCktMSwxMSwzMCl9fWZ1bmN0aW9uIHUodCl7dmFyIGU9dC5CYjtmb3IodD1uZXcgRGF0ZShuZXcgRGF0ZSh0LkNiKzE5MDAsMCwxKS5nZXRUaW1lKCkpOzA8ZTspe3ZhciBuPXQuZ2V0TW9udGgoKSxyPShmdCh0LmdldEZ1bGxZZWFyKCkpP2R0Omh0KVtuXTtpZighKGU+ci10LmdldERhdGUoKSkpe3Quc2V0RGF0ZSh0LmdldERhdGUoKStlKTticmVha31lLT1yLXQuZ2V0RGF0ZSgpKzEsdC5zZXREYXRlKDEpLDExPm4/dC5zZXRNb250aChuKzEpOih0LnNldE1vbnRoKDApLHQuc2V0RnVsbFllYXIodC5nZXRGdWxsWWVhcigpKzEpKX1yZXR1cm4gbj1uZXcgRGF0ZSh0LmdldEZ1bGxZZWFyKCkrMSwwLDQpLGU9cyhuZXcgRGF0ZSh0LmdldEZ1bGxZZWFyKCksMCw0KSksbj1zKG4pLDA+PWEoZSx0KT8wPj1hKG4sdCk/dC5nZXRGdWxsWWVhcigpKzE6dC5nZXRGdWxsWWVhcigpOnQuZ2V0RnVsbFllYXIoKS0xfXZhciBjPUFbcis0MD4+Mj4+PjBdO2Zvcih2YXIgbCBpbiByPXskYjpBW3I+PjI+Pj4wXSxaYjpBW3IrND4+Mj4+PjBdLEdiOkFbcis4Pj4yPj4+MF0sS2I6QVtyKzEyPj4yPj4+MF0sSGI6QVtyKzE2Pj4yPj4+MF0sQ2I6QVtyKzIwPj4yPj4+MF0sQWI6QVtyKzI0Pj4yPj4+MF0sQmI6QVtyKzI4Pj4yPj4+MF0sYmM6QVtyKzMyPj4yPj4+MF0sWWI6QVtyKzM2Pj4yPj4+MF0sYWM6Yz8kKGMpOlwiXCJ9LG49JChuKSxjPXtcIiVjXCI6XCIlYSAlYiAlZCAlSDolTTolUyAlWVwiLFwiJURcIjpcIiVtLyVkLyV5XCIsXCIlRlwiOlwiJVktJW0tJWRcIixcIiVoXCI6XCIlYlwiLFwiJXJcIjpcIiVJOiVNOiVTICVwXCIsXCIlUlwiOlwiJUg6JU1cIixcIiVUXCI6XCIlSDolTTolU1wiLFwiJXhcIjpcIiVtLyVkLyV5XCIsXCIlWFwiOlwiJUg6JU06JVNcIixcIiVFY1wiOlwiJWNcIixcIiVFQ1wiOlwiJUNcIixcIiVFeFwiOlwiJW0vJWQvJXlcIixcIiVFWFwiOlwiJUg6JU06JVNcIixcIiVFeVwiOlwiJXlcIixcIiVFWVwiOlwiJVlcIixcIiVPZFwiOlwiJWRcIixcIiVPZVwiOlwiJWVcIixcIiVPSFwiOlwiJUhcIixcIiVPSVwiOlwiJUlcIixcIiVPbVwiOlwiJW1cIixcIiVPTVwiOlwiJU1cIixcIiVPU1wiOlwiJVNcIixcIiVPdVwiOlwiJXVcIixcIiVPVVwiOlwiJVVcIixcIiVPVlwiOlwiJVZcIixcIiVPd1wiOlwiJXdcIixcIiVPV1wiOlwiJVdcIixcIiVPeVwiOlwiJXlcIn0pbj1uLnJlcGxhY2UobmV3IFJlZ0V4cChsLFwiZ1wiKSxjW2xdKTt2YXIgcD1cIlN1bmRheSBNb25kYXkgVHVlc2RheSBXZWRuZXNkYXkgVGh1cnNkYXkgRnJpZGF5IFNhdHVyZGF5XCIuc3BsaXQoXCIgXCIpLGY9XCJKYW51YXJ5IEZlYnJ1YXJ5IE1hcmNoIEFwcmlsIE1heSBKdW5lIEp1bHkgQXVndXN0IFNlcHRlbWJlciBPY3RvYmVyIE5vdmVtYmVyIERlY2VtYmVyXCIuc3BsaXQoXCIgXCIpO2ZvcihsIGluIGM9e1wiJWFcIjpmdW5jdGlvbih0KXtyZXR1cm4gcFt0LkFiXS5zdWJzdHJpbmcoMCwzKX0sXCIlQVwiOmZ1bmN0aW9uKHQpe3JldHVybiBwW3QuQWJdfSxcIiViXCI6ZnVuY3Rpb24odCl7cmV0dXJuIGZbdC5IYl0uc3Vic3RyaW5nKDAsMyl9LFwiJUJcIjpmdW5jdGlvbih0KXtyZXR1cm4gZlt0LkhiXX0sXCIlQ1wiOmZ1bmN0aW9uKHQpe3JldHVybiBvKCh0LkNiKzE5MDApLzEwMHwwLDIpfSxcIiVkXCI6ZnVuY3Rpb24odCl7cmV0dXJuIG8odC5LYiwyKX0sXCIlZVwiOmZ1bmN0aW9uKHQpe3JldHVybiBpKHQuS2IsMixcIiBcIil9LFwiJWdcIjpmdW5jdGlvbih0KXtyZXR1cm4gdSh0KS50b1N0cmluZygpLnN1YnN0cmluZygyKX0sXCIlR1wiOmZ1bmN0aW9uKHQpe3JldHVybiB1KHQpfSxcIiVIXCI6ZnVuY3Rpb24odCl7cmV0dXJuIG8odC5HYiwyKX0sXCIlSVwiOmZ1bmN0aW9uKHQpe3JldHVybiAwPT0odD10LkdiKT90PTEyOjEyPHQmJih0LT0xMiksbyh0LDIpfSxcIiVqXCI6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPTAsbj0wO248PXQuSGItMTtlKz0oZnQodC5DYisxOTAwKT9kdDpodClbbisrXSk7cmV0dXJuIG8odC5LYitlLDMpfSxcIiVtXCI6ZnVuY3Rpb24odCl7cmV0dXJuIG8odC5IYisxLDIpfSxcIiVNXCI6ZnVuY3Rpb24odCl7cmV0dXJuIG8odC5aYiwyKX0sXCIlblwiOmZ1bmN0aW9uKCl7cmV0dXJuXCJcXG5cIn0sXCIlcFwiOmZ1bmN0aW9uKHQpe3JldHVybiAwPD10LkdiJiYxMj50LkdiP1wiQU1cIjpcIlBNXCJ9LFwiJVNcIjpmdW5jdGlvbih0KXtyZXR1cm4gbyh0LiRiLDIpfSxcIiV0XCI6ZnVuY3Rpb24oKXtyZXR1cm5cIlxcdFwifSxcIiV1XCI6ZnVuY3Rpb24odCl7cmV0dXJuIHQuQWJ8fDd9LFwiJVVcIjpmdW5jdGlvbih0KXtyZXR1cm4gbyhNYXRoLmZsb29yKCh0LkJiKzctdC5BYikvNyksMil9LFwiJVZcIjpmdW5jdGlvbih0KXt2YXIgZT1NYXRoLmZsb29yKCh0LkJiKzctKHQuQWIrNiklNykvNyk7aWYoMj49KHQuQWIrMzcxLXQuQmItMiklNyYmZSsrLGUpNTM9PWUmJig0PT0obj0odC5BYiszNzEtdC5CYiklNyl8fDM9PW4mJmZ0KHQuQ2IpfHwoZT0xKSk7ZWxzZXtlPTUyO3ZhciBuPSh0LkFiKzctdC5CYi0xKSU3Oyg0PT1ufHw1PT1uJiZmdCh0LkNiJTQwMC0xKSkmJmUrK31yZXR1cm4gbyhlLDIpfSxcIiV3XCI6ZnVuY3Rpb24odCl7cmV0dXJuIHQuQWJ9LFwiJVdcIjpmdW5jdGlvbih0KXtyZXR1cm4gbyhNYXRoLmZsb29yKCh0LkJiKzctKHQuQWIrNiklNykvNyksMil9LFwiJXlcIjpmdW5jdGlvbih0KXtyZXR1cm4odC5DYisxOTAwKS50b1N0cmluZygpLnN1YnN0cmluZygyKX0sXCIlWVwiOmZ1bmN0aW9uKHQpe3JldHVybiB0LkNiKzE5MDB9LFwiJXpcIjpmdW5jdGlvbih0KXt2YXIgZT0wPD0odD10LlliKTtyZXR1cm4gdD1NYXRoLmFicyh0KS82MCwoZT9cIitcIjpcIi1cIikrU3RyaW5nKFwiMDAwMFwiKyh0LzYwKjEwMCt0JTYwKSkuc2xpY2UoLTQpfSxcIiVaXCI6ZnVuY3Rpb24odCl7cmV0dXJuIHQuYWN9LFwiJSVcIjpmdW5jdGlvbigpe3JldHVyblwiJVwifX0sbj1uLnJlcGxhY2UoLyUlL2csXCJcXDBcXDBcIiksYyluLmluY2x1ZGVzKGwpJiYobj1uLnJlcGxhY2UobmV3IFJlZ0V4cChsLFwiZ1wiKSxjW2xdKHIpKSk7cmV0dXJuIGw9ZnVuY3Rpb24odCl7dmFyIGU9QXJyYXkoQyh0KSsxKTtyZXR1cm4gayh0LGUsMCxlLmxlbmd0aCksZX0obj1uLnJlcGxhY2UoL1xcMFxcMC9nLFwiJVwiKSksbC5sZW5ndGg+ZT8wOihTLnNldChsLHQ+Pj4wKSxsLmxlbmd0aC0xKX12YXIgYnQ9e2E6ZnVuY3Rpb24odCl7cmV0dXJuIHl0KHQrMjQpKzI0fSxtOmZ1bmN0aW9uKHQpe3JldHVybih0PW5ldyBldCh0KSkuUGIoKXx8KHQuSWIoITApLFEtLSksdC5KYighMSksSi5wdXNoKHQpLHQuTmIoKSx0LlFiKCl9LGlhOmZ1bmN0aW9uKHQpe3Rocm93IHYoXCJVbmV4cGVjdGVkIGV4Y2VwdGlvbiB0aHJvd24sIHRoaXMgaXMgbm90IHByb3Blcmx5IHN1cHBvcnRlZCAtIGFib3J0aW5nXCIpLEk9ITAsdH0sdzpmdW5jdGlvbigpe3h0KDApO3ZhciB0PUoucG9wKCk7aWYodC5YYigpJiYhdC5MYigpKXt2YXIgZT10LldiKCk7ZSYmaXQoZSkodC5EYiksbnQodC5EYil9dHQ9MH0sZDpmdW5jdGlvbigpe3ZhciB0PXR0O2lmKCF0KXJldHVybiBwdD0wO3ZhciBlPW5ldyBldCh0KTtlLkZiKHQpO3ZhciBuPWUuRWIoKTtpZighbilyZXR1cm4gcHQ9MCx0O2Zvcih2YXIgcj1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpLGk9MDtpPHIubGVuZ3RoO2krKyl7dmFyIG89cltpXTtpZigwPT09b3x8bz09PW4pYnJlYWs7aWYoQXQobyxuLGUuemIrMTYpKXJldHVybiBwdD1vLHR9cmV0dXJuIHB0PW4sdH0sazpmdW5jdGlvbigpe3ZhciB0PXR0O2lmKCF0KXJldHVybiBwdD0wO3ZhciBlPW5ldyBldCh0KTtlLkZiKHQpO3ZhciBuPWUuRWIoKTtpZighbilyZXR1cm4gcHQ9MCx0O2Zvcih2YXIgcj1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpLGk9MDtpPHIubGVuZ3RoO2krKyl7dmFyIG89cltpXTtpZigwPT09b3x8bz09PW4pYnJlYWs7aWYoQXQobyxuLGUuemIrMTYpKXJldHVybiBwdD1vLHR9cmV0dXJuIHB0PW4sdH0sZzpmdW5jdGlvbigpe3ZhciB0PXR0O2lmKCF0KXJldHVybiBwdD0wO3ZhciBlPW5ldyBldCh0KTtlLkZiKHQpO3ZhciBuPWUuRWIoKTtpZighbilyZXR1cm4gcHQ9MCx0O2Zvcih2YXIgcj1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpLGk9MDtpPHIubGVuZ3RoO2krKyl7dmFyIG89cltpXTtpZigwPT09b3x8bz09PW4pYnJlYWs7aWYoQXQobyxuLGUuemIrMTYpKXJldHVybiBwdD1vLHR9cmV0dXJuIHB0PW4sdH0sczpudCxMOmZ1bmN0aW9uKCl7dmFyIHQ9Si5wb3AoKTt0fHxXKFwibm8gZXhjZXB0aW9uIHRvIHRocm93XCIpO3ZhciBlPXQuRGI7dGhyb3cgdC5MYigpfHwoSi5wdXNoKHQpLHQuSmIoITApLHQuSWIoITEpLFErKyksdHQ9ZSxlfSxiOmZ1bmN0aW9uKHQsZSxuKXt0aHJvdyBuZXcgZXQodCkuUmIoZSxuKSx0dD10LFErKyx0fSxsYTpmdW5jdGlvbigpe3JldHVybiBRfSxpOmZ1bmN0aW9uKHQpe3Rocm93IHR0fHwodHQ9dCksdH0sSDpmdW5jdGlvbigpe3JldHVybiAwfSxCYTpmdW5jdGlvbigpe30scGE6ZnVuY3Rpb24oKXt9LHJhOmZ1bmN0aW9uKCl7fSxrYTpmdW5jdGlvbigpe3JldHVybiAwfSx6YTpmdW5jdGlvbigpe30sdWE6ZnVuY3Rpb24oKXt9LHlhOmZ1bmN0aW9uKCl7fSxSOmZ1bmN0aW9uKCl7fSxxYTpmdW5jdGlvbigpe30sbmE6ZnVuY3Rpb24oKXt9LEFhOmZ1bmN0aW9uKCl7fSxvYTpmdW5jdGlvbigpe30sSGE6ZnVuY3Rpb24oKXt9LEphOmZ1bmN0aW9uKCl7VyhcIlRvIHVzZSBkbG9wZW4sIHlvdSBuZWVkIGVuYWJsZSBkeW5hbWljIGxpbmtpbmcsIHNlZSBodHRwczovL2dpdGh1Yi5jb20vZW1zY3JpcHRlbi1jb3JlL2Vtc2NyaXB0ZW4vd2lraS9MaW5raW5nXCIpfSxJYTpmdW5jdGlvbigpe1coXCJUbyB1c2UgZGxvcGVuLCB5b3UgbmVlZCBlbmFibGUgZHluYW1pYyBsaW5raW5nLCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2Vtc2NyaXB0ZW4tY29yZS9lbXNjcmlwdGVuL3dpa2kvTGlua2luZ1wiKX0sUzpmdW5jdGlvbigpe3JldHVybiBEYXRlLm5vdygpfSxDYTpmdW5jdGlvbigpe3JldHVybiEwfSxEYTpmdW5jdGlvbih0LGUpe3Q9bmV3IERhdGUoMWUzKihFW3Q+Pj4yXSs0Mjk0OTY3Mjk2KkFbdCs0Pj4+Ml0pKSxBW2U+PjI+Pj4wXT10LmdldFVUQ1NlY29uZHMoKSxBW2UrND4+Mj4+PjBdPXQuZ2V0VVRDTWludXRlcygpLEFbZSs4Pj4yPj4+MF09dC5nZXRVVENIb3VycygpLEFbZSsxMj4+Mj4+PjBdPXQuZ2V0VVRDRGF0ZSgpLEFbZSsxNj4+Mj4+PjBdPXQuZ2V0VVRDTW9udGgoKSxBW2UrMjA+PjI+Pj4wXT10LmdldFVUQ0Z1bGxZZWFyKCktMTkwMCxBW2UrMjQ+PjI+Pj4wXT10LmdldFVUQ0RheSgpLEFbZSsyOD4+Mj4+PjBdPSh0LmdldFRpbWUoKS1EYXRlLlVUQyh0LmdldFVUQ0Z1bGxZZWFyKCksMCwxLDAsMCwwLDApKS84NjRlNXwwfSxFYTpmdW5jdGlvbih0LGUpe3Q9bmV3IERhdGUoMWUzKihFW3Q+Pj4yXSs0Mjk0OTY3Mjk2KkFbdCs0Pj4+Ml0pKSxBW2U+PjI+Pj4wXT10LmdldFNlY29uZHMoKSxBW2UrND4+Mj4+PjBdPXQuZ2V0TWludXRlcygpLEFbZSs4Pj4yPj4+MF09dC5nZXRIb3VycygpLEFbZSsxMj4+Mj4+PjBdPXQuZ2V0RGF0ZSgpLEFbZSsxNj4+Mj4+PjBdPXQuZ2V0TW9udGgoKSxBW2UrMjA+PjI+Pj4wXT10LmdldEZ1bGxZZWFyKCktMTkwMCxBW2UrMjQ+PjI+Pj4wXT10LmdldERheSgpO3ZhciBuPW5ldyBEYXRlKHQuZ2V0RnVsbFllYXIoKSwwLDEpO0FbZSsyOD4+Mj4+PjBdPSh0LmdldFRpbWUoKS1uLmdldFRpbWUoKSkvODY0ZTV8MCxBW2UrMzY+PjI+Pj4wXT0tNjAqdC5nZXRUaW1lem9uZU9mZnNldCgpO3ZhciByPW5ldyBEYXRlKHQuZ2V0RnVsbFllYXIoKSw2LDEpLmdldFRpbWV6b25lT2Zmc2V0KCk7bj1uLmdldFRpbWV6b25lT2Zmc2V0KCksQVtlKzMyPj4yPj4+MF09MHwociE9biYmdC5nZXRUaW1lem9uZU9mZnNldCgpPT1NYXRoLm1pbihuLHIpKX0sRmE6ZnVuY3Rpb24odCl7dmFyIGU9bmV3IERhdGUoQVt0KzIwPj4yPj4+MF0rMTkwMCxBW3QrMTY+PjI+Pj4wXSxBW3QrMTI+PjI+Pj4wXSxBW3QrOD4+Mj4+PjBdLEFbdCs0Pj4yPj4+MF0sQVt0Pj4yPj4+MF0sMCksbj1BW3QrMzI+PjI+Pj4wXSxyPWUuZ2V0VGltZXpvbmVPZmZzZXQoKSxpPW5ldyBEYXRlKGUuZ2V0RnVsbFllYXIoKSwwLDEpLG89bmV3IERhdGUoZS5nZXRGdWxsWWVhcigpLDYsMSkuZ2V0VGltZXpvbmVPZmZzZXQoKSxhPWkuZ2V0VGltZXpvbmVPZmZzZXQoKSxzPU1hdGgubWluKGEsbyk7cmV0dXJuIDA+bj9BW3QrMzI+PjI+Pj4wXT1OdW1iZXIobyE9YSYmcz09cik6MDxuIT0ocz09cikmJihvPU1hdGgubWF4KGEsbyksZS5zZXRUaW1lKGUuZ2V0VGltZSgpKzZlNCooKDA8bj9zOm8pLXIpKSksQVt0KzI0Pj4yPj4+MF09ZS5nZXREYXkoKSxBW3QrMjg+PjI+Pj4wXT0oZS5nZXRUaW1lKCktaS5nZXRUaW1lKCkpLzg2NGU1fDAsQVt0Pj4yPj4+MF09ZS5nZXRTZWNvbmRzKCksQVt0KzQ+PjI+Pj4wXT1lLmdldE1pbnV0ZXMoKSxBW3QrOD4+Mj4+PjBdPWUuZ2V0SG91cnMoKSxBW3QrMTI+PjI+Pj4wXT1lLmdldERhdGUoKSxBW3QrMTY+PjI+Pj4wXT1lLmdldE1vbnRoKCksZS5nZXRUaW1lKCkvMWUzfDB9LHNhOmZ1bmN0aW9uKCl7cmV0dXJuLTUyfSx0YTpmdW5jdGlvbigpe30sR2E6ZnVuY3Rpb24gdChlLG4scil7dC5WYnx8KHQuVmI9ITAsZnVuY3Rpb24odCxlLG4pe2Z1bmN0aW9uIHIodCl7cmV0dXJuKHQ9dC50b1RpbWVTdHJpbmcoKS5tYXRjaCgvXFwoKFtBLVphLXogXSspXFwpJC8pKT90WzFdOlwiR01UXCJ9dmFyIGk9KG5ldyBEYXRlKS5nZXRGdWxsWWVhcigpLG89bmV3IERhdGUoaSwwLDEpLGE9bmV3IERhdGUoaSw2LDEpO2k9by5nZXRUaW1lem9uZU9mZnNldCgpO3ZhciBzPWEuZ2V0VGltZXpvbmVPZmZzZXQoKTtBW3Q+PjI+Pj4wXT02MCpNYXRoLm1heChpLHMpLEFbZT4+Mj4+PjBdPU51bWJlcihpIT1zKSx0PXIobyksZT1yKGEpLHQ9b3QodCksZT1vdChlKSxzPGk/KEVbbj4+Mj4+PjBdPXQsRVtuKzQ+PjI+Pj4wXT1lKTooRVtuPj4yPj4+MF09ZSxFW24rND4+Mj4+PjBdPXQpfShlLG4scikpfSxCOmZ1bmN0aW9uKCl7VyhcIlwiKX0sbWE6ZnVuY3Rpb24oKXtyZXR1cm4gNDI5NDkwMTc2MH0sSTpiPygpPT57dmFyIHQ9cHJvY2Vzcy5ocnRpbWUoKTtyZXR1cm4gMWUzKnRbMF0rdFsxXS8xZTZ9OigpPT5wZXJmb3JtYW5jZS5ub3coKSx4YTpmdW5jdGlvbih0LGUsbil7Ty5jb3B5V2l0aGluKHQ+Pj4wLGU+Pj4wLGUrbj4+PjApfSxHOmZ1bmN0aW9uKHQpe3ZhciBlPU8ubGVuZ3RoO2lmKDQyOTQ5MDE3NjA8KHQ+Pj49MCkpcmV0dXJuITE7Zm9yKHZhciBuPTE7ND49bjtuKj0yKXt2YXIgcj1lKigxKy4yL24pO3I9TWF0aC5taW4ocix0KzEwMDY2MzI5Nik7dmFyIGk9TWF0aDtyPU1hdGgubWF4KHQsciksaT1pLm1pbi5jYWxsKGksNDI5NDkwMTc2MCxyKyg2NTUzNi1yJTY1NTM2KSU2NTUzNik7dDp7dHJ5e3guZ3JvdyhpLVQuYnl0ZUxlbmd0aCs2NTUzNT4+PjE2KSxGKCk7dmFyIG89MTticmVhayB0fWNhdGNoKHQpe31vPXZvaWQgMH1pZihvKXJldHVybiEwfXJldHVybiExfSx2YTpmdW5jdGlvbih0LGUpe3ZhciBuPTA7cmV0dXJuIHN0KCkuZm9yRWFjaCgoZnVuY3Rpb24ocixpKXt2YXIgbz1lK247Zm9yKGk9RVt0KzQqaT4+Mj4+PjBdPW8sbz0wO288ci5sZW5ndGg7KytvKVNbaSsrPj4wPj4+MF09ci5jaGFyQ29kZUF0KG8pO1NbaT4+MD4+PjBdPTAsbis9ci5sZW5ndGgrMX0pKSwwfSx3YTpmdW5jdGlvbih0LGUpe3ZhciBuPXN0KCk7RVt0Pj4yPj4+MF09bi5sZW5ndGg7dmFyIHI9MDtyZXR1cm4gbi5mb3JFYWNoKChmdW5jdGlvbih0KXtyKz10Lmxlbmd0aCsxfSkpLEVbZT4+Mj4+PjBdPXIsMH0sYmE6ZnVuY3Rpb24odCl7d3x8MDxVfHwod3QoKSxaKGopLHZ0KDApLGN0WzFdLmxlbmd0aCYmbHQoMSwxMCksY3RbMl0ubGVuZ3RoJiZsdCgyLDEwKSksd3x8MDxVfHwoZS5vbkV4aXQmJmUub25FeGl0KHQpLEk9ITApLGQodCxuZXcgSyh0KSl9LEU6ZnVuY3Rpb24oKXtyZXR1cm4gNTJ9LFE6ZnVuY3Rpb24oKXtyZXR1cm4gNTJ9LGNhOmZ1bmN0aW9uKCl7cmV0dXJuIDcwfSxQOmZ1bmN0aW9uKHQsZSxuLHIpe2Zvcih2YXIgaT0wLG89MDtvPG47bysrKXt2YXIgYT1FW2U+PjI+Pj4wXSxzPUVbZSs0Pj4yPj4+MF07ZSs9ODtmb3IodmFyIHU9MDt1PHM7dSsrKWx0KHQsT1thK3U+Pj4wXSk7aSs9c31yZXR1cm4gRVtyPj4yPj4+MF09aSwwfSxjOmZ1bmN0aW9uKCl7cmV0dXJuIHB0fSxqYTpmdW5jdGlvbiB0KGUscil7dC5NYnx8KHQuTWI9ZnVuY3Rpb24oKXtpZihcIm9iamVjdFwiPT10eXBlb2YgY3J5cHRvJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKXt2YXIgdD1uZXcgVWludDhBcnJheSgxKTtyZXR1cm4oKT0+KGNyeXB0by5nZXRSYW5kb21WYWx1ZXModCksdFswXSl9aWYoYil0cnl7dmFyIGU9bihPYmplY3QoZnVuY3Rpb24oKXt2YXIgdD1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ2NyeXB0bydcIik7dGhyb3cgdC5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLHR9KCkpKTtyZXR1cm4oKT0+ZS5yYW5kb21CeXRlcygxKVswXX1jYXRjaCh0KXt9cmV0dXJuKCk9PlcoXCJyYW5kb21EZXZpY2VcIil9KCkpO2Zvcih2YXIgaT0wO2k8cjtpKyspU1tlK2k+PjA+Pj4wXT10Lk1iKCk7cmV0dXJuIDB9LGVhOmZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1UdCgpO3RyeXtyZXR1cm4gaXQodCkoZSxuKX1jYXRjaCh0KXtpZihTdChyKSx0IT09dCswKXRocm93IHQ7eHQoMSwwKX19LGZhOmZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1UdCgpO3RyeXtyZXR1cm4gaXQodCkoZSxuKX1jYXRjaCh0KXtpZihTdChyKSx0IT09dCswKXRocm93IHQ7eHQoMSwwKX19LEo6ZnVuY3Rpb24odCl7dmFyIGU9VHQoKTt0cnl7cmV0dXJuIGl0KHQpKCl9Y2F0Y2godCl7aWYoU3QoZSksdCE9PXQrMCl0aHJvdyB0O3h0KDEsMCl9fSxlOmZ1bmN0aW9uKHQsZSl7dmFyIG49VHQoKTt0cnl7cmV0dXJuIGl0KHQpKGUpfWNhdGNoKHQpe2lmKFN0KG4pLHQhPT10KzApdGhyb3cgdDt4dCgxLDApfX0sTjpmdW5jdGlvbih0LGUsbil7dmFyIHI9VHQoKTt0cnl7cmV0dXJuIGl0KHQpKGUsbil9Y2F0Y2godCl7aWYoU3QociksdCE9PXQrMCl0aHJvdyB0O3h0KDEsMCl9fSxPOmZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1UdCgpO3RyeXtyZXR1cm4gaXQodCkoZSxuKX1jYXRjaCh0KXtpZihTdChyKSx0IT09dCswKXRocm93IHQ7eHQoMSwwKX19LGo6ZnVuY3Rpb24odCxlLG4pe3ZhciByPVR0KCk7dHJ5e3JldHVybiBpdCh0KShlLG4pfWNhdGNoKHQpe2lmKFN0KHIpLHQhPT10KzApdGhyb3cgdDt4dCgxLDApfX0sbzpmdW5jdGlvbih0LGUsbixyKXt2YXIgaT1UdCgpO3RyeXtyZXR1cm4gaXQodCkoZSxuLHIpfWNhdGNoKHQpe2lmKFN0KGkpLHQhPT10KzApdGhyb3cgdDt4dCgxLDApfX0scDpmdW5jdGlvbih0LGUsbixyLGkpe3ZhciBvPVR0KCk7dHJ5e3JldHVybiBpdCh0KShlLG4scixpKX1jYXRjaCh0KXtpZihTdChvKSx0IT09dCswKXRocm93IHQ7eHQoMSwwKX19LE06ZnVuY3Rpb24odCxlLG4scixpLG8pe3ZhciBhPVR0KCk7dHJ5e3JldHVybiBpdCh0KShlLG4scixpLG8pfWNhdGNoKHQpe2lmKFN0KGEpLHQhPT10KzApdGhyb3cgdDt4dCgxLDApfX0scjpmdW5jdGlvbih0LGUsbixyLGksbyl7dmFyIGE9VHQoKTt0cnl7cmV0dXJuIGl0KHQpKGUsbixyLGksbyl9Y2F0Y2godCl7aWYoU3QoYSksdCE9PXQrMCl0aHJvdyB0O3h0KDEsMCl9fSx2OmZ1bmN0aW9uKHQsZSxuLHIsaSxvLGEpe3ZhciBzPVR0KCk7dHJ5e3JldHVybiBpdCh0KShlLG4scixpLG8sYSl9Y2F0Y2godCl7aWYoU3QocyksdCE9PXQrMCl0aHJvdyB0O3h0KDEsMCl9fSxLOmZ1bmN0aW9uKHQsZSxuLHIsaSxvLGEscyl7dmFyIHU9VHQoKTt0cnl7cmV0dXJuIGl0KHQpKGUsbixyLGksbyxhLHMpfWNhdGNoKHQpe2lmKFN0KHUpLHQhPT10KzApdGhyb3cgdDt4dCgxLDApfX0sRDpmdW5jdGlvbih0LGUsbixyLGksbyxhLHMsdSxjLGwscCl7dmFyIGY9VHQoKTt0cnl7cmV0dXJuIGl0KHQpKGUsbixyLGksbyxhLHMsdSxjLGwscCl9Y2F0Y2godCl7aWYoU3QoZiksdCE9PXQrMCl0aHJvdyB0O3h0KDEsMCl9fSxYOmZ1bmN0aW9uKHQsZSxuLHIsaSxvLGEscyl7dmFyIHU9VHQoKTt0cnl7cmV0dXJuIEx0KHQsZSxuLHIsaSxvLGEscyl9Y2F0Y2godCl7aWYoU3QodSksdCE9PXQrMCl0aHJvdyB0O3h0KDEsMCl9fSxWOmZ1bmN0aW9uKHQsZSxuLHIsaSxvLGEpe3ZhciBzPVR0KCk7dHJ5e3JldHVybiBQdCh0LGUsbixyLGksbyxhKX1jYXRjaCh0KXtpZihTdChzKSx0IT09dCswKXRocm93IHQ7eHQoMSwwKX19LFU6ZnVuY3Rpb24odCxlLG4scixpKXt2YXIgbz1UdCgpO3RyeXtyZXR1cm4gUnQodCxlLG4scixpKX1jYXRjaCh0KXtpZihTdChvKSx0IT09dCswKXRocm93IHQ7eHQoMSwwKX19LFo6ZnVuY3Rpb24odCxlLG4scil7dmFyIGk9VHQoKTt0cnl7cmV0dXJuIEZ0KHQsZSxuLHIpfWNhdGNoKHQpe2lmKFN0KGkpLHQhPT10KzApdGhyb3cgdDt4dCgxLDApfX0sVzpmdW5jdGlvbih0KXt2YXIgZT1UdCgpO3RyeXtyZXR1cm4gSXQodCl9Y2F0Y2godCl7aWYoU3QoZSksdCE9PXQrMCl0aHJvdyB0O3h0KDEsMCl9fSxZOmZ1bmN0aW9uKHQsZSl7dmFyIG49VHQoKTt0cnl7cmV0dXJuIE50KHQsZSl9Y2F0Y2godCl7aWYoU3QobiksdCE9PXQrMCl0aHJvdyB0O3h0KDEsMCl9fSxUOmZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1UdCgpO3RyeXtyZXR1cm4gRHQodCxlLG4pfWNhdGNoKHQpe2lmKFN0KHIpLHQhPT10KzApdGhyb3cgdDt4dCgxLDApfX0sZjpmdW5jdGlvbih0KXt2YXIgZT1UdCgpO3RyeXtpdCh0KSgpfWNhdGNoKHQpe2lmKFN0KGUpLHQhPT10KzApdGhyb3cgdDt4dCgxLDApfX0scTpmdW5jdGlvbih0LGUpe3ZhciBuPVR0KCk7dHJ5e2l0KHQpKGUpfWNhdGNoKHQpe2lmKFN0KG4pLHQhPT10KzApdGhyb3cgdDt4dCgxLDApfX0saDpmdW5jdGlvbih0LGUsbil7dmFyIHI9VHQoKTt0cnl7aXQodCkoZSxuKX1jYXRjaCh0KXtpZihTdChyKSx0IT09dCswKXRocm93IHQ7eHQoMSwwKX19LGRhOmZ1bmN0aW9uKHQsZSxuLHIpe3ZhciBpPVR0KCk7dHJ5e2l0KHQpKGUsbixyKX1jYXRjaCh0KXtpZihTdChpKSx0IT09dCswKXRocm93IHQ7eHQoMSwwKX19LGw6ZnVuY3Rpb24odCxlLG4scil7dmFyIGk9VHQoKTt0cnl7aXQodCkoZSxuLHIpfWNhdGNoKHQpe2lmKFN0KGkpLHQhPT10KzApdGhyb3cgdDt4dCgxLDApfX0sdDpmdW5jdGlvbih0LGUsbixyLGkpe3ZhciBvPVR0KCk7dHJ5e2l0KHQpKGUsbixyLGkpfWNhdGNoKHQpe2lmKFN0KG8pLHQhPT10KzApdGhyb3cgdDt4dCgxLDApfX0sdTpmdW5jdGlvbih0LGUsbixyLGksbyl7dmFyIGE9VHQoKTt0cnl7aXQodCkoZSxuLHIsaSxvKX1jYXRjaCh0KXtpZihTdChhKSx0IT09dCswKXRocm93IHQ7eHQoMSwwKX19LHg6ZnVuY3Rpb24odCxlLG4scixpLG8sYSl7dmFyIHM9VHQoKTt0cnl7aXQodCkoZSxuLHIsaSxvLGEpfWNhdGNoKHQpe2lmKFN0KHMpLHQhPT10KzApdGhyb3cgdDt4dCgxLDApfX0sejpmdW5jdGlvbih0LGUsbixyLGksbyxhLHMpe3ZhciB1PVR0KCk7dHJ5e2l0KHQpKGUsbixyLGksbyxhLHMpfWNhdGNoKHQpe2lmKFN0KHUpLHQhPT10KzApdGhyb3cgdDt4dCgxLDApfX0sZ2E6ZnVuY3Rpb24odCxlLG4scixpLG8sYSxzLHUpe3ZhciBjPVR0KCk7dHJ5e2l0KHQpKGUsbixyLGksbyxhLHMsdSl9Y2F0Y2godCl7aWYoU3QoYyksdCE9PXQrMCl0aHJvdyB0O3h0KDEsMCl9fSxBOmZ1bmN0aW9uKHQsZSxuLHIsaSxvLGEscyx1LGMsbCl7dmFyIHA9VHQoKTt0cnl7aXQodCkoZSxuLHIsaSxvLGEscyx1LGMsbCl9Y2F0Y2godCl7aWYoU3QocCksdCE9PXQrMCl0aHJvdyB0O3h0KDEsMCl9fSxDOmZ1bmN0aW9uKHQsZSxuLHIsaSxvLGEscyx1LGMsbCxwLGYsZCxoLGcpe3ZhciBiPVR0KCk7dHJ5e2l0KHQpKGUsbixyLGksbyxhLHMsdSxjLGwscCxmLGQsaCxnKX1jYXRjaCh0KXtpZihTdChiKSx0IT09dCswKXRocm93IHQ7eHQoMSwwKX19LGFhOmZ1bmN0aW9uKHQsZSxuLHIsaSxvLGEscyl7dmFyIHU9VHQoKTt0cnl7JHQodCxlLG4scixpLG8sYSxzKX1jYXRjaCh0KXtpZihTdCh1KSx0IT09dCswKXRocm93IHQ7eHQoMSwwKX19LF86ZnVuY3Rpb24odCxlLG4scixpLG8sYSxzLHUsYyxsLHApe3ZhciBmPVR0KCk7dHJ5e0N0KHQsZSxuLHIsaSxvLGEscyx1LGMsbCxwKX1jYXRjaCh0KXtpZihTdChmKSx0IT09dCswKXRocm93IHQ7eHQoMSwwKX19LCQ6ZnVuY3Rpb24odCxlLG4scixpLG8pe3ZhciBhPVR0KCk7dHJ5e2t0KHQsZSxuLHIsaSxvKX1jYXRjaCh0KXtpZihTdChhKSx0IT09dCswKXRocm93IHQ7eHQoMSwwKX19LG46ZnVuY3Rpb24odCl7cmV0dXJuIHR9LEY6ZnVuY3Rpb24odCl7cHQ9dH0saGE6Z3QseTpmdW5jdGlvbih0LGUsbixyKXtyZXR1cm4gZ3QodCxlLG4scil9fTshZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQpe2UuYXNtPXQuZXhwb3J0cyx4PWUuYXNtLkthLEYoKSxOPWUuYXNtLmliLFIudW5zaGlmdChlLmFzbS5MYSksei0tLGUubW9uaXRvclJ1bkRlcGVuZGVuY2llcyYmZS5tb25pdG9yUnVuRGVwZW5kZW5jaWVzKHopLDA9PXomJihudWxsIT09RyYmKGNsZWFySW50ZXJ2YWwoRyksRz1udWxsKSxIJiYodD1ILEg9bnVsbCx0KCkpKX1mdW5jdGlvbiBuKGUpe3QoZS5pbnN0YW5jZSl9ZnVuY3Rpb24gcih0KXtyZXR1cm4gZnVuY3Rpb24oKXtpZigheSYmKGh8fGcpKXtpZihcImZ1bmN0aW9uXCI9PXR5cGVvZiBmZXRjaCYmIUIuc3RhcnRzV2l0aChcImZpbGU6Ly9cIikpcmV0dXJuIGZldGNoKEIse2NyZWRlbnRpYWxzOlwic2FtZS1vcmlnaW5cIn0pLnRoZW4oKGZ1bmN0aW9uKHQpe2lmKCF0Lm9rKXRocm93XCJmYWlsZWQgdG8gbG9hZCB3YXNtIGJpbmFyeSBmaWxlIGF0ICdcIitCK1wiJ1wiO3JldHVybiB0LmFycmF5QnVmZmVyKCl9KSkuY2F0Y2goKGZ1bmN0aW9uKCl7cmV0dXJuIFkoKX0pKTtpZihhKXJldHVybiBuZXcgUHJvbWlzZSgoZnVuY3Rpb24odCxlKXthKEIsKGZ1bmN0aW9uKGUpe3QobmV3IFVpbnQ4QXJyYXkoZSkpfSksZSl9KSl9cmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKGZ1bmN0aW9uKCl7cmV0dXJuIFkoKX0pKX0oKS50aGVuKChmdW5jdGlvbih0KXtyZXR1cm4gV2ViQXNzZW1ibHkuaW5zdGFudGlhdGUodCxvKX0pKS50aGVuKChmdW5jdGlvbih0KXtyZXR1cm4gdH0pKS50aGVuKHQsKGZ1bmN0aW9uKHQpe3YoXCJmYWlsZWQgdG8gYXN5bmNocm9ub3VzbHkgcHJlcGFyZSB3YXNtOiBcIit0KSxXKHQpfSkpfXZhciBvPXthOmJ0fTtpZih6KyssZS5tb25pdG9yUnVuRGVwZW5kZW5jaWVzJiZlLm1vbml0b3JSdW5EZXBlbmRlbmNpZXMoeiksZS5pbnN0YW50aWF0ZVdhc20pdHJ5e3JldHVybiBlLmluc3RhbnRpYXRlV2FzbShvLHQpfWNhdGNoKHQpe3JldHVybiB2KFwiTW9kdWxlLmluc3RhbnRpYXRlV2FzbSBjYWxsYmFjayBmYWlsZWQgd2l0aCBlcnJvcjogXCIrdCksITF9KHl8fFwiZnVuY3Rpb25cIiE9dHlwZW9mIFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlU3RyZWFtaW5nfHxxKCl8fEIuc3RhcnRzV2l0aChcImZpbGU6Ly9cIil8fGJ8fFwiZnVuY3Rpb25cIiE9dHlwZW9mIGZldGNoP3Iobik6ZmV0Y2goQix7Y3JlZGVudGlhbHM6XCJzYW1lLW9yaWdpblwifSkudGhlbigoZnVuY3Rpb24odCl7cmV0dXJuIFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlU3RyZWFtaW5nKHQsbykudGhlbihuLChmdW5jdGlvbih0KXtyZXR1cm4gdihcIndhc20gc3RyZWFtaW5nIGNvbXBpbGUgZmFpbGVkOiBcIit0KSx2KFwiZmFsbGluZyBiYWNrIHRvIEFycmF5QnVmZmVyIGluc3RhbnRpYXRpb25cIikscihuKX0pKX0pKSkuY2F0Y2goaSl9KCksZS5fX193YXNtX2NhbGxfY3RvcnM9ZnVuY3Rpb24oKXtyZXR1cm4oZS5fX193YXNtX2NhbGxfY3RvcnM9ZS5hc20uTGEpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sZS5fT3J0SW5pdD1mdW5jdGlvbigpe3JldHVybihlLl9PcnRJbml0PWUuYXNtLk1hKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGUuX09ydENyZWF0ZVNlc3Npb25PcHRpb25zPWZ1bmN0aW9uKCl7cmV0dXJuKGUuX09ydENyZWF0ZVNlc3Npb25PcHRpb25zPWUuYXNtLk5hKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGUuX09ydEFwcGVuZEV4ZWN1dGlvblByb3ZpZGVyPWZ1bmN0aW9uKCl7cmV0dXJuKGUuX09ydEFwcGVuZEV4ZWN1dGlvblByb3ZpZGVyPWUuYXNtLk9hKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGUuX09ydEFkZFNlc3Npb25Db25maWdFbnRyeT1mdW5jdGlvbigpe3JldHVybihlLl9PcnRBZGRTZXNzaW9uQ29uZmlnRW50cnk9ZS5hc20uUGEpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sZS5fT3J0UmVsZWFzZVNlc3Npb25PcHRpb25zPWZ1bmN0aW9uKCl7cmV0dXJuKGUuX09ydFJlbGVhc2VTZXNzaW9uT3B0aW9ucz1lLmFzbS5RYSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxlLl9PcnRDcmVhdGVTZXNzaW9uPWZ1bmN0aW9uKCl7cmV0dXJuKGUuX09ydENyZWF0ZVNlc3Npb249ZS5hc20uUmEpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sZS5fT3J0UmVsZWFzZVNlc3Npb249ZnVuY3Rpb24oKXtyZXR1cm4oZS5fT3J0UmVsZWFzZVNlc3Npb249ZS5hc20uU2EpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sZS5fT3J0R2V0SW5wdXRDb3VudD1mdW5jdGlvbigpe3JldHVybihlLl9PcnRHZXRJbnB1dENvdW50PWUuYXNtLlRhKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGUuX09ydEdldE91dHB1dENvdW50PWZ1bmN0aW9uKCl7cmV0dXJuKGUuX09ydEdldE91dHB1dENvdW50PWUuYXNtLlVhKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGUuX09ydEdldElucHV0TmFtZT1mdW5jdGlvbigpe3JldHVybihlLl9PcnRHZXRJbnB1dE5hbWU9ZS5hc20uVmEpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sZS5fT3J0R2V0T3V0cHV0TmFtZT1mdW5jdGlvbigpe3JldHVybihlLl9PcnRHZXRPdXRwdXROYW1lPWUuYXNtLldhKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGUuX09ydEZyZWU9ZnVuY3Rpb24oKXtyZXR1cm4oZS5fT3J0RnJlZT1lLmFzbS5YYSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxlLl9PcnRDcmVhdGVUZW5zb3I9ZnVuY3Rpb24oKXtyZXR1cm4oZS5fT3J0Q3JlYXRlVGVuc29yPWUuYXNtLllhKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGUuX09ydEdldFRlbnNvckRhdGE9ZnVuY3Rpb24oKXtyZXR1cm4oZS5fT3J0R2V0VGVuc29yRGF0YT1lLmFzbS5aYSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxlLl9PcnRSZWxlYXNlVGVuc29yPWZ1bmN0aW9uKCl7cmV0dXJuKGUuX09ydFJlbGVhc2VUZW5zb3I9ZS5hc20uX2EpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sZS5fT3J0Q3JlYXRlUnVuT3B0aW9ucz1mdW5jdGlvbigpe3JldHVybihlLl9PcnRDcmVhdGVSdW5PcHRpb25zPWUuYXNtLiRhKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGUuX09ydEFkZFJ1bkNvbmZpZ0VudHJ5PWZ1bmN0aW9uKCl7cmV0dXJuKGUuX09ydEFkZFJ1bkNvbmZpZ0VudHJ5PWUuYXNtLmFiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGUuX09ydFJlbGVhc2VSdW5PcHRpb25zPWZ1bmN0aW9uKCl7cmV0dXJuKGUuX09ydFJlbGVhc2VSdW5PcHRpb25zPWUuYXNtLmJiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGUuX09ydFJ1bj1mdW5jdGlvbigpe3JldHVybihlLl9PcnRSdW49ZS5hc20uY2IpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sZS5fT3J0RW5kUHJvZmlsaW5nPWZ1bmN0aW9uKCl7cmV0dXJuKGUuX09ydEVuZFByb2ZpbGluZz1lLmFzbS5kYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfTt2YXIgbXQseXQ9ZS5fbWFsbG9jPWZ1bmN0aW9uKCl7cmV0dXJuKHl0PWUuX21hbGxvYz1lLmFzbS5lYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxfdD1lLl9mcmVlPWZ1bmN0aW9uKCl7cmV0dXJuKF90PWUuX2ZyZWU9ZS5hc20uZmIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sdnQ9ZS5fZmZsdXNoPWZ1bmN0aW9uKCl7cmV0dXJuKHZ0PWUuX2ZmbHVzaD1lLmFzbS5nYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSx3dD1lLl9fX2Z1bmNzX29uX2V4aXQ9ZnVuY3Rpb24oKXtyZXR1cm4od3Q9ZS5fX19mdW5jc19vbl9leGl0PWUuYXNtLmhiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHh0PWUuX3NldFRocmV3PWZ1bmN0aW9uKCl7cmV0dXJuKHh0PWUuX3NldFRocmV3PWUuYXNtLmpiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LFR0PWUuc3RhY2tTYXZlPWZ1bmN0aW9uKCl7cmV0dXJuKFR0PWUuc3RhY2tTYXZlPWUuYXNtLmtiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LFN0PWUuc3RhY2tSZXN0b3JlPWZ1bmN0aW9uKCl7cmV0dXJuKFN0PWUuc3RhY2tSZXN0b3JlPWUuYXNtLmxiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LE90PWUuc3RhY2tBbGxvYz1mdW5jdGlvbigpe3JldHVybihPdD1lLnN0YWNrQWxsb2M9ZS5hc20ubWIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sQXQ9ZS5fX19jeGFfY2FuX2NhdGNoPWZ1bmN0aW9uKCl7cmV0dXJuKEF0PWUuX19fY3hhX2Nhbl9jYXRjaD1lLmFzbS5uYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxFdD1lLl9fX2N4YV9pc19wb2ludGVyX3R5cGU9ZnVuY3Rpb24oKXtyZXR1cm4oRXQ9ZS5fX19jeGFfaXNfcG9pbnRlcl90eXBlPWUuYXNtLm9iKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LEl0PWUuZHluQ2FsbF9qPWZ1bmN0aW9uKCl7cmV0dXJuKEl0PWUuZHluQ2FsbF9qPWUuYXNtLnBiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LFB0PWUuZHluQ2FsbF9paWlpaWo9ZnVuY3Rpb24oKXtyZXR1cm4oUHQ9ZS5keW5DYWxsX2lpaWlpaj1lLmFzbS5xYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxEdD1lLmR5bkNhbGxfamlpPWZ1bmN0aW9uKCl7cmV0dXJuKER0PWUuZHluQ2FsbF9qaWk9ZS5hc20ucmIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sJHQ9ZS5keW5DYWxsX3ZpaWlpaWo9ZnVuY3Rpb24oKXtyZXR1cm4oJHQ9ZS5keW5DYWxsX3ZpaWlpaWo9ZS5hc20uc2IpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sa3Q9ZS5keW5DYWxsX3Zqamk9ZnVuY3Rpb24oKXtyZXR1cm4oa3Q9ZS5keW5DYWxsX3Zqamk9ZS5hc20udGIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sQ3Q9ZS5keW5DYWxsX3ZpaWlqamppaT1mdW5jdGlvbigpe3JldHVybihDdD1lLmR5bkNhbGxfdmlpaWpqamlpPWUuYXNtLnViKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LEZ0PWUuZHluQ2FsbF9paWo9ZnVuY3Rpb24oKXtyZXR1cm4oRnQ9ZS5keW5DYWxsX2lpaj1lLmFzbS52YikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxOdD1lLmR5bkNhbGxfamk9ZnVuY3Rpb24oKXtyZXR1cm4oTnQ9ZS5keW5DYWxsX2ppPWUuYXNtLndiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LEx0PWUuZHluQ2FsbF9paWlpaWlqPWZ1bmN0aW9uKCl7cmV0dXJuKEx0PWUuZHluQ2FsbF9paWlpaWlqPWUuYXNtLnhiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LFJ0PWUuZHluQ2FsbF9paWlqPWZ1bmN0aW9uKCl7cmV0dXJuKFJ0PWUuZHluQ2FsbF9paWlqPWUuYXNtLnliKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O2Z1bmN0aW9uIGp0KCl7ZnVuY3Rpb24gdCgpe2lmKCFtdCYmKG10PSEwLGUuY2FsbGVkUnVuPSEwLCFJKSl7aWYoWihSKSxyKGUpLGUub25SdW50aW1lSW5pdGlhbGl6ZWQmJmUub25SdW50aW1lSW5pdGlhbGl6ZWQoKSxlLnBvc3RSdW4pZm9yKFwiZnVuY3Rpb25cIj09dHlwZW9mIGUucG9zdFJ1biYmKGUucG9zdFJ1bj1bZS5wb3N0UnVuXSk7ZS5wb3N0UnVuLmxlbmd0aDspe3ZhciB0PWUucG9zdFJ1bi5zaGlmdCgpO00udW5zaGlmdCh0KX1aKE0pfX1pZighKDA8eikpe2lmKGUucHJlUnVuKWZvcihcImZ1bmN0aW9uXCI9PXR5cGVvZiBlLnByZVJ1biYmKGUucHJlUnVuPVtlLnByZVJ1bl0pO2UucHJlUnVuLmxlbmd0aDspVigpO1ooTCksMDx6fHwoZS5zZXRTdGF0dXM/KGUuc2V0U3RhdHVzKFwiUnVubmluZy4uLlwiKSxzZXRUaW1lb3V0KChmdW5jdGlvbigpe3NldFRpbWVvdXQoKGZ1bmN0aW9uKCl7ZS5zZXRTdGF0dXMoXCJcIil9KSwxKSx0KCl9KSwxKSk6dCgpKX19aWYoZS5VVEY4VG9TdHJpbmc9JCxlLnN0cmluZ1RvVVRGOD1mdW5jdGlvbih0LGUsbil7cmV0dXJuIGsodCxPLGUsbil9LGUubGVuZ3RoQnl0ZXNVVEY4PUMsZS5zdGFja1NhdmU9VHQsZS5zdGFja1Jlc3RvcmU9U3QsZS5zdGFja0FsbG9jPU90LEg9ZnVuY3Rpb24gdCgpe210fHxqdCgpLG10fHwoSD10KX0sZS5wcmVJbml0KWZvcihcImZ1bmN0aW9uXCI9PXR5cGVvZiBlLnByZUluaXQmJihlLnByZUluaXQ9W2UucHJlSW5pdF0pOzA8ZS5wcmVJbml0Lmxlbmd0aDspZS5wcmVJbml0LnBvcCgpKCk7cmV0dXJuIGp0KCksdC5yZWFkeX0pO3QuZXhwb3J0cz1yfSw0NTM3OnQ9PntcInVzZSBzdHJpY3RcIjt0LmV4cG9ydHM9ZnVuY3Rpb24odCxlKXtmb3IodmFyIG49bmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgtMSkscj0wLGk9MixvPSEwO2k8YXJndW1lbnRzLmxlbmd0aDspbltyKytdPWFyZ3VtZW50c1tpKytdO3JldHVybiBuZXcgUHJvbWlzZSgoZnVuY3Rpb24oaSxhKXtuW3JdPWZ1bmN0aW9uKHQpe2lmKG8paWYobz0hMSx0KWEodCk7ZWxzZXtmb3IodmFyIGU9bmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgtMSksbj0wO248ZS5sZW5ndGg7KWVbbisrXT1hcmd1bWVudHNbbl07aS5hcHBseShudWxsLGUpfX07dHJ5e3QuYXBwbHkoZXx8bnVsbCxuKX1jYXRjaCh0KXtvJiYobz0hMSxhKHQpKX19KSl9fSw3NDE5Oih0LGUpPT57XCJ1c2Ugc3RyaWN0XCI7dmFyIG49ZTtuLmxlbmd0aD1mdW5jdGlvbih0KXt2YXIgZT10Lmxlbmd0aDtpZighZSlyZXR1cm4gMDtmb3IodmFyIG49MDstLWUlND4xJiZcIj1cIj09PXQuY2hhckF0KGUpOykrK247cmV0dXJuIE1hdGguY2VpbCgzKnQubGVuZ3RoKS80LW59O2Zvcih2YXIgcj1uZXcgQXJyYXkoNjQpLGk9bmV3IEFycmF5KDEyMyksbz0wO288NjQ7KWlbcltvXT1vPDI2P28rNjU6bzw1Mj9vKzcxOm88NjI/by00Om8tNTl8NDNdPW8rKztuLmVuY29kZT1mdW5jdGlvbih0LGUsbil7Zm9yKHZhciBpLG89bnVsbCxhPVtdLHM9MCx1PTA7ZTxuOyl7dmFyIGM9dFtlKytdO3N3aXRjaCh1KXtjYXNlIDA6YVtzKytdPXJbYz4+Ml0saT0oMyZjKTw8NCx1PTE7YnJlYWs7Y2FzZSAxOmFbcysrXT1yW2l8Yz4+NF0saT0oMTUmYyk8PDIsdT0yO2JyZWFrO2Nhc2UgMjphW3MrK109cltpfGM+PjZdLGFbcysrXT1yWzYzJmNdLHU9MH1zPjgxOTEmJigob3x8KG89W10pKS5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLGEpKSxzPTApfXJldHVybiB1JiYoYVtzKytdPXJbaV0sYVtzKytdPTYxLDE9PT11JiYoYVtzKytdPTYxKSksbz8ocyYmby5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLGEuc2xpY2UoMCxzKSkpLG8uam9pbihcIlwiKSk6U3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsYS5zbGljZSgwLHMpKX07dmFyIGE9XCJpbnZhbGlkIGVuY29kaW5nXCI7bi5kZWNvZGU9ZnVuY3Rpb24odCxlLG4pe2Zvcih2YXIgcixvPW4scz0wLHU9MDt1PHQubGVuZ3RoOyl7dmFyIGM9dC5jaGFyQ29kZUF0KHUrKyk7aWYoNjE9PT1jJiZzPjEpYnJlYWs7aWYodm9pZCAwPT09KGM9aVtjXSkpdGhyb3cgRXJyb3IoYSk7c3dpdGNoKHMpe2Nhc2UgMDpyPWMscz0xO2JyZWFrO2Nhc2UgMTplW24rK109cjw8MnwoNDgmYyk+PjQscj1jLHM9MjticmVhaztjYXNlIDI6ZVtuKytdPSgxNSZyKTw8NHwoNjAmYyk+PjIscj1jLHM9MzticmVhaztjYXNlIDM6ZVtuKytdPSgzJnIpPDw2fGMscz0wfX1pZigxPT09cyl0aHJvdyBFcnJvcihhKTtyZXR1cm4gbi1vfSxuLnRlc3Q9ZnVuY3Rpb24odCl7cmV0dXJuL14oPzpbQS1aYS16MC05Ky9dezR9KSooPzpbQS1aYS16MC05Ky9dezJ9PT18W0EtWmEtejAtOSsvXXszfT0pPyQvLnRlc3QodCl9fSw5MjExOnQ9PntcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBlKCl7dGhpcy5fbGlzdGVuZXJzPXt9fXQuZXhwb3J0cz1lLGUucHJvdG90eXBlLm9uPWZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4odGhpcy5fbGlzdGVuZXJzW3RdfHwodGhpcy5fbGlzdGVuZXJzW3RdPVtdKSkucHVzaCh7Zm46ZSxjdHg6bnx8dGhpc30pLHRoaXN9LGUucHJvdG90eXBlLm9mZj1mdW5jdGlvbih0LGUpe2lmKHZvaWQgMD09PXQpdGhpcy5fbGlzdGVuZXJzPXt9O2Vsc2UgaWYodm9pZCAwPT09ZSl0aGlzLl9saXN0ZW5lcnNbdF09W107ZWxzZSBmb3IodmFyIG49dGhpcy5fbGlzdGVuZXJzW3RdLHI9MDtyPG4ubGVuZ3RoOyluW3JdLmZuPT09ZT9uLnNwbGljZShyLDEpOisrcjtyZXR1cm4gdGhpc30sZS5wcm90b3R5cGUuZW1pdD1mdW5jdGlvbih0KXt2YXIgZT10aGlzLl9saXN0ZW5lcnNbdF07aWYoZSl7Zm9yKHZhciBuPVtdLHI9MTtyPGFyZ3VtZW50cy5sZW5ndGg7KW4ucHVzaChhcmd1bWVudHNbcisrXSk7Zm9yKHI9MDtyPGUubGVuZ3RoOyllW3JdLmZuLmFwcGx5KGVbcisrXS5jdHgsbil9cmV0dXJuIHRoaXN9fSw5NDU6dD0+e1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIGUodCl7cmV0dXJuXCJ1bmRlZmluZWRcIiE9dHlwZW9mIEZsb2F0MzJBcnJheT9mdW5jdGlvbigpe3ZhciBlPW5ldyBGbG9hdDMyQXJyYXkoWy0wXSksbj1uZXcgVWludDhBcnJheShlLmJ1ZmZlcikscj0xMjg9PT1uWzNdO2Z1bmN0aW9uIGkodCxyLGkpe2VbMF09dCxyW2ldPW5bMF0scltpKzFdPW5bMV0scltpKzJdPW5bMl0scltpKzNdPW5bM119ZnVuY3Rpb24gbyh0LHIsaSl7ZVswXT10LHJbaV09blszXSxyW2krMV09blsyXSxyW2krMl09blsxXSxyW2krM109blswXX1mdW5jdGlvbiBhKHQscil7cmV0dXJuIG5bMF09dFtyXSxuWzFdPXRbcisxXSxuWzJdPXRbcisyXSxuWzNdPXRbciszXSxlWzBdfWZ1bmN0aW9uIHModCxyKXtyZXR1cm4gblszXT10W3JdLG5bMl09dFtyKzFdLG5bMV09dFtyKzJdLG5bMF09dFtyKzNdLGVbMF19dC53cml0ZUZsb2F0TEU9cj9pOm8sdC53cml0ZUZsb2F0QkU9cj9vOmksdC5yZWFkRmxvYXRMRT1yP2E6cyx0LnJlYWRGbG9hdEJFPXI/czphfSgpOmZ1bmN0aW9uKCl7ZnVuY3Rpb24gZSh0LGUsbixyKXt2YXIgaT1lPDA/MTowO2lmKGkmJihlPS1lKSwwPT09ZSl0KDEvZT4wPzA6MjE0NzQ4MzY0OCxuLHIpO2Vsc2UgaWYoaXNOYU4oZSkpdCgyMTQzMjg5MzQ0LG4scik7ZWxzZSBpZihlPjM0MDI4MjM0NjYzODUyODg2ZTIyKXQoKGk8PDMxfDIxMzkwOTUwNDApPj4+MCxuLHIpO2Vsc2UgaWYoZTwxMTc1NDk0MzUwODIyMjg3NWUtNTQpdCgoaTw8MzF8TWF0aC5yb3VuZChlLzE0MDEyOTg0NjQzMjQ4MTdlLTYwKSk+Pj4wLG4scik7ZWxzZXt2YXIgbz1NYXRoLmZsb29yKE1hdGgubG9nKGUpL01hdGguTE4yKTt0KChpPDwzMXxvKzEyNzw8MjN8ODM4ODYwNyZNYXRoLnJvdW5kKGUqTWF0aC5wb3coMiwtbykqODM4ODYwOCkpPj4+MCxuLHIpfX1mdW5jdGlvbiBhKHQsZSxuKXt2YXIgcj10KGUsbiksaT0yKihyPj4zMSkrMSxvPXI+Pj4yMyYyNTUsYT04Mzg4NjA3JnI7cmV0dXJuIDI1NT09PW8/YT9OYU46aSooMS8wKTowPT09bz8xNDAxMjk4NDY0MzI0ODE3ZS02MCppKmE6aSpNYXRoLnBvdygyLG8tMTUwKSooYSs4Mzg4NjA4KX10LndyaXRlRmxvYXRMRT1lLmJpbmQobnVsbCxuKSx0LndyaXRlRmxvYXRCRT1lLmJpbmQobnVsbCxyKSx0LnJlYWRGbG9hdExFPWEuYmluZChudWxsLGkpLHQucmVhZEZsb2F0QkU9YS5iaW5kKG51bGwsbyl9KCksXCJ1bmRlZmluZWRcIiE9dHlwZW9mIEZsb2F0NjRBcnJheT9mdW5jdGlvbigpe3ZhciBlPW5ldyBGbG9hdDY0QXJyYXkoWy0wXSksbj1uZXcgVWludDhBcnJheShlLmJ1ZmZlcikscj0xMjg9PT1uWzddO2Z1bmN0aW9uIGkodCxyLGkpe2VbMF09dCxyW2ldPW5bMF0scltpKzFdPW5bMV0scltpKzJdPW5bMl0scltpKzNdPW5bM10scltpKzRdPW5bNF0scltpKzVdPW5bNV0scltpKzZdPW5bNl0scltpKzddPW5bN119ZnVuY3Rpb24gbyh0LHIsaSl7ZVswXT10LHJbaV09bls3XSxyW2krMV09bls2XSxyW2krMl09bls1XSxyW2krM109bls0XSxyW2krNF09blszXSxyW2krNV09blsyXSxyW2krNl09blsxXSxyW2krN109blswXX1mdW5jdGlvbiBhKHQscil7cmV0dXJuIG5bMF09dFtyXSxuWzFdPXRbcisxXSxuWzJdPXRbcisyXSxuWzNdPXRbciszXSxuWzRdPXRbcis0XSxuWzVdPXRbcis1XSxuWzZdPXRbcis2XSxuWzddPXRbcis3XSxlWzBdfWZ1bmN0aW9uIHModCxyKXtyZXR1cm4gbls3XT10W3JdLG5bNl09dFtyKzFdLG5bNV09dFtyKzJdLG5bNF09dFtyKzNdLG5bM109dFtyKzRdLG5bMl09dFtyKzVdLG5bMV09dFtyKzZdLG5bMF09dFtyKzddLGVbMF19dC53cml0ZURvdWJsZUxFPXI/aTpvLHQud3JpdGVEb3VibGVCRT1yP286aSx0LnJlYWREb3VibGVMRT1yP2E6cyx0LnJlYWREb3VibGVCRT1yP3M6YX0oKTpmdW5jdGlvbigpe2Z1bmN0aW9uIGUodCxlLG4scixpLG8pe3ZhciBhPXI8MD8xOjA7aWYoYSYmKHI9LXIpLDA9PT1yKXQoMCxpLG8rZSksdCgxL3I+MD8wOjIxNDc0ODM2NDgsaSxvK24pO2Vsc2UgaWYoaXNOYU4ocikpdCgwLGksbytlKSx0KDIxNDY5NTkzNjAsaSxvK24pO2Vsc2UgaWYocj4xNzk3NjkzMTM0ODYyMzE1N2UyOTIpdCgwLGksbytlKSx0KChhPDwzMXwyMTQ2NDM1MDcyKT4+PjAsaSxvK24pO2Vsc2V7dmFyIHM7aWYocjwyMjI1MDczODU4NTA3MjAxNGUtMzI0KXQoKHM9ci81ZS0zMjQpPj4+MCxpLG8rZSksdCgoYTw8MzF8cy80Mjk0OTY3Mjk2KT4+PjAsaSxvK24pO2Vsc2V7dmFyIHU9TWF0aC5mbG9vcihNYXRoLmxvZyhyKS9NYXRoLkxOMik7MTAyND09PXUmJih1PTEwMjMpLHQoNDUwMzU5OTYyNzM3MDQ5Nioocz1yKk1hdGgucG93KDIsLXUpKT4+PjAsaSxvK2UpLHQoKGE8PDMxfHUrMTAyMzw8MjB8MTA0ODU3NipzJjEwNDg1NzUpPj4+MCxpLG8rbil9fX1mdW5jdGlvbiBhKHQsZSxuLHIsaSl7dmFyIG89dChyLGkrZSksYT10KHIsaStuKSxzPTIqKGE+PjMxKSsxLHU9YT4+PjIwJjIwNDcsYz00Mjk0OTY3Mjk2KigxMDQ4NTc1JmEpK287cmV0dXJuIDIwNDc9PT11P2M/TmFOOnMqKDEvMCk6MD09PXU/NWUtMzI0KnMqYzpzKk1hdGgucG93KDIsdS0xMDc1KSooYys0NTAzNTk5NjI3MzcwNDk2KX10LndyaXRlRG91YmxlTEU9ZS5iaW5kKG51bGwsbiwwLDQpLHQud3JpdGVEb3VibGVCRT1lLmJpbmQobnVsbCxyLDQsMCksdC5yZWFkRG91YmxlTEU9YS5iaW5kKG51bGwsaSwwLDQpLHQucmVhZERvdWJsZUJFPWEuYmluZChudWxsLG8sNCwwKX0oKSx0fWZ1bmN0aW9uIG4odCxlLG4pe2Vbbl09MjU1JnQsZVtuKzFdPXQ+Pj44JjI1NSxlW24rMl09dD4+PjE2JjI1NSxlW24rM109dD4+PjI0fWZ1bmN0aW9uIHIodCxlLG4pe2Vbbl09dD4+PjI0LGVbbisxXT10Pj4+MTYmMjU1LGVbbisyXT10Pj4+OCYyNTUsZVtuKzNdPTI1NSZ0fWZ1bmN0aW9uIGkodCxlKXtyZXR1cm4odFtlXXx0W2UrMV08PDh8dFtlKzJdPDwxNnx0W2UrM108PDI0KT4+PjB9ZnVuY3Rpb24gbyh0LGUpe3JldHVybih0W2VdPDwyNHx0W2UrMV08PDE2fHRbZSsyXTw8OHx0W2UrM10pPj4+MH10LmV4cG9ydHM9ZShlKX0sNzE5OTptb2R1bGU9PntcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBpbnF1aXJlKG1vZHVsZU5hbWUpe3RyeXt2YXIgbW9kPWV2YWwoXCJxdWlyZVwiLnJlcGxhY2UoL14vLFwicmVcIikpKG1vZHVsZU5hbWUpO2lmKG1vZCYmKG1vZC5sZW5ndGh8fE9iamVjdC5rZXlzKG1vZCkubGVuZ3RoKSlyZXR1cm4gbW9kfWNhdGNoKHQpe31yZXR1cm4gbnVsbH1tb2R1bGUuZXhwb3J0cz1pbnF1aXJlfSw2NjYyOnQ9PntcInVzZSBzdHJpY3RcIjt0LmV4cG9ydHM9ZnVuY3Rpb24odCxlLG4pe3ZhciByPW58fDgxOTIsaT1yPj4+MSxvPW51bGwsYT1yO3JldHVybiBmdW5jdGlvbihuKXtpZihuPDF8fG4+aSlyZXR1cm4gdChuKTthK24+ciYmKG89dChyKSxhPTApO3ZhciBzPWUuY2FsbChvLGEsYSs9bik7cmV0dXJuIDcmYSYmKGE9MSsoN3xhKSksc319fSw0OTk3Oih0LGUpPT57XCJ1c2Ugc3RyaWN0XCI7dmFyIG49ZTtuLmxlbmd0aD1mdW5jdGlvbih0KXtmb3IodmFyIGU9MCxuPTAscj0wO3I8dC5sZW5ndGg7KytyKShuPXQuY2hhckNvZGVBdChyKSk8MTI4P2UrPTE6bjwyMDQ4P2UrPTI6NTUyOTY9PSg2NDUxMiZuKSYmNTYzMjA9PSg2NDUxMiZ0LmNoYXJDb2RlQXQocisxKSk/KCsrcixlKz00KTplKz0zO3JldHVybiBlfSxuLnJlYWQ9ZnVuY3Rpb24odCxlLG4pe2lmKG4tZTwxKXJldHVyblwiXCI7Zm9yKHZhciByLGk9bnVsbCxvPVtdLGE9MDtlPG47KShyPXRbZSsrXSk8MTI4P29bYSsrXT1yOnI+MTkxJiZyPDIyND9vW2ErK109KDMxJnIpPDw2fDYzJnRbZSsrXTpyPjIzOSYmcjwzNjU/KHI9KCg3JnIpPDwxOHwoNjMmdFtlKytdKTw8MTJ8KDYzJnRbZSsrXSk8PDZ8NjMmdFtlKytdKS02NTUzNixvW2ErK109NTUyOTYrKHI+PjEwKSxvW2ErK109NTYzMjArKDEwMjMmcikpOm9bYSsrXT0oMTUmcik8PDEyfCg2MyZ0W2UrK10pPDw2fDYzJnRbZSsrXSxhPjgxOTEmJigoaXx8KGk9W10pKS5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLG8pKSxhPTApO3JldHVybiBpPyhhJiZpLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsby5zbGljZSgwLGEpKSksaS5qb2luKFwiXCIpKTpTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZyxvLnNsaWNlKDAsYSkpfSxuLndyaXRlPWZ1bmN0aW9uKHQsZSxuKXtmb3IodmFyIHIsaSxvPW4sYT0wO2E8dC5sZW5ndGg7KythKShyPXQuY2hhckNvZGVBdChhKSk8MTI4P2VbbisrXT1yOnI8MjA0OD8oZVtuKytdPXI+PjZ8MTkyLGVbbisrXT02MyZyfDEyOCk6NTUyOTY9PSg2NDUxMiZyKSYmNTYzMjA9PSg2NDUxMiYoaT10LmNoYXJDb2RlQXQoYSsxKSkpPyhyPTY1NTM2KygoMTAyMyZyKTw8MTApKygxMDIzJmkpLCsrYSxlW24rK109cj4+MTh8MjQwLGVbbisrXT1yPj4xMiY2M3wxMjgsZVtuKytdPXI+PjYmNjN8MTI4LGVbbisrXT02MyZyfDEyOCk6KGVbbisrXT1yPj4xMnwyMjQsZVtuKytdPXI+PjYmNjN8MTI4LGVbbisrXT02MyZyfDEyOCk7cmV0dXJuIG4tb319LDM0NDI6KHQsZSk9PntcInVzZSBzdHJpY3RcIjtlLl9fZXNNb2R1bGU9ITA7dmFyIG49ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KGUpe2lmKCFlKXRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGFyZ3VtZW50OyBgdmFsdWVgIGhhcyBubyB2YWx1ZS5cIik7dGhpcy52YWx1ZT10LkVNUFRZLGUmJnQuaXNHdWlkKGUpJiYodGhpcy52YWx1ZT1lKX1yZXR1cm4gdC5pc0d1aWQ9ZnVuY3Rpb24oZSl7dmFyIG49ZS50b1N0cmluZygpO3JldHVybiBlJiYoZSBpbnN0YW5jZW9mIHR8fHQudmFsaWRhdG9yLnRlc3QobikpfSx0LmNyZWF0ZT1mdW5jdGlvbigpe3JldHVybiBuZXcgdChbdC5nZW4oMiksdC5nZW4oMSksdC5nZW4oMSksdC5nZW4oMSksdC5nZW4oMyldLmpvaW4oXCItXCIpKX0sdC5jcmVhdGVFbXB0eT1mdW5jdGlvbigpe3JldHVybiBuZXcgdChcImVtcHR5Z3VpZFwiKX0sdC5wYXJzZT1mdW5jdGlvbihlKXtyZXR1cm4gbmV3IHQoZSl9LHQucmF3PWZ1bmN0aW9uKCl7cmV0dXJuW3QuZ2VuKDIpLHQuZ2VuKDEpLHQuZ2VuKDEpLHQuZ2VuKDEpLHQuZ2VuKDMpXS5qb2luKFwiLVwiKX0sdC5nZW49ZnVuY3Rpb24odCl7Zm9yKHZhciBlPVwiXCIsbj0wO248dDtuKyspZSs9KDY1NTM2KigxK01hdGgucmFuZG9tKCkpfDApLnRvU3RyaW5nKDE2KS5zdWJzdHJpbmcoMSk7cmV0dXJuIGV9LHQucHJvdG90eXBlLmVxdWFscz1mdW5jdGlvbihlKXtyZXR1cm4gdC5pc0d1aWQoZSkmJnRoaXMudmFsdWU9PT1lLnRvU3RyaW5nKCl9LHQucHJvdG90eXBlLmlzRW1wdHk9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy52YWx1ZT09PXQuRU1QVFl9LHQucHJvdG90eXBlLnRvU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudmFsdWV9LHQucHJvdG90eXBlLnRvSlNPTj1mdW5jdGlvbigpe3JldHVybnt2YWx1ZTp0aGlzLnZhbHVlfX0sdC52YWxpZGF0b3I9bmV3IFJlZ0V4cChcIl5bYS16MC05XXs4fS1bYS16MC05XXs0fS1bYS16MC05XXs0fS1bYS16MC05XXs0fS1bYS16MC05XXsxMn0kXCIsXCJpXCIpLHQuRU1QVFk9XCIwMDAwMDAwMC0wMDAwLTAwMDAtMDAwMC0wMDAwMDAwMDAwMDBcIix0fSgpO2UuR3VpZD1ufSwzNzIwOnQ9Pnt0LmV4cG9ydHM9bjt2YXIgZT1udWxsO3RyeXtlPW5ldyBXZWJBc3NlbWJseS5JbnN0YW5jZShuZXcgV2ViQXNzZW1ibHkuTW9kdWxlKG5ldyBVaW50OEFycmF5KFswLDk3LDExNSwxMDksMSwwLDAsMCwxLDEzLDIsOTYsMCwxLDEyNyw5Niw0LDEyNywxMjcsMTI3LDEyNywxLDEyNywzLDcsNiwwLDEsMSwxLDEsMSw2LDYsMSwxMjcsMSw2NSwwLDExLDcsNTAsNiwzLDEwOSwxMTcsMTA4LDAsMSw1LDEwMCwxMDUsMTE4LDk1LDExNSwwLDIsNSwxMDAsMTA1LDExOCw5NSwxMTcsMCwzLDUsMTE0LDEwMSwxMDksOTUsMTE1LDAsNCw1LDExNCwxMDEsMTA5LDk1LDExNywwLDUsOCwxMDMsMTAxLDExNiw5NSwxMDQsMTA1LDEwMywxMDQsMCwwLDEwLDE5MSwxLDYsNCwwLDM1LDAsMTEsMzYsMSwxLDEyNiwzMiwwLDE3MywzMiwxLDE3Myw2NiwzMiwxMzQsMTMyLDMyLDIsMTczLDMyLDMsMTczLDY2LDMyLDEzNCwxMzIsMTI2LDM0LDQsNjYsMzIsMTM1LDE2NywzNiwwLDMyLDQsMTY3LDExLDM2LDEsMSwxMjYsMzIsMCwxNzMsMzIsMSwxNzMsNjYsMzIsMTM0LDEzMiwzMiwyLDE3MywzMiwzLDE3Myw2NiwzMiwxMzQsMTMyLDEyNywzNCw0LDY2LDMyLDEzNSwxNjcsMzYsMCwzMiw0LDE2NywxMSwzNiwxLDEsMTI2LDMyLDAsMTczLDMyLDEsMTczLDY2LDMyLDEzNCwxMzIsMzIsMiwxNzMsMzIsMywxNzMsNjYsMzIsMTM0LDEzMiwxMjgsMzQsNCw2NiwzMiwxMzUsMTY3LDM2LDAsMzIsNCwxNjcsMTEsMzYsMSwxLDEyNiwzMiwwLDE3MywzMiwxLDE3Myw2NiwzMiwxMzQsMTMyLDMyLDIsMTczLDMyLDMsMTczLDY2LDMyLDEzNCwxMzIsMTI5LDM0LDQsNjYsMzIsMTM1LDE2NywzNiwwLDMyLDQsMTY3LDExLDM2LDEsMSwxMjYsMzIsMCwxNzMsMzIsMSwxNzMsNjYsMzIsMTM0LDEzMiwzMiwyLDE3MywzMiwzLDE3Myw2NiwzMiwxMzQsMTMyLDEzMCwzNCw0LDY2LDMyLDEzNSwxNjcsMzYsMCwzMiw0LDE2NywxMV0pKSx7fSkuZXhwb3J0c31jYXRjaCh0KXt9ZnVuY3Rpb24gbih0LGUsbil7dGhpcy5sb3c9MHx0LHRoaXMuaGlnaD0wfGUsdGhpcy51bnNpZ25lZD0hIW59ZnVuY3Rpb24gcih0KXtyZXR1cm4hMD09PSh0JiZ0Ll9faXNMb25nX18pfW4ucHJvdG90eXBlLl9faXNMb25nX18sT2JqZWN0LmRlZmluZVByb3BlcnR5KG4ucHJvdG90eXBlLFwiX19pc0xvbmdfX1wiLHt2YWx1ZTohMH0pLG4uaXNMb25nPXI7dmFyIGk9e30sbz17fTtmdW5jdGlvbiBhKHQsZSl7dmFyIG4scixhO3JldHVybiBlPyhhPTA8PSh0Pj4+PTApJiZ0PDI1NikmJihyPW9bdF0pP3I6KG49dSh0LCgwfHQpPDA/LTE6MCwhMCksYSYmKG9bdF09biksbik6KGE9LTEyODw9KHR8PTApJiZ0PDEyOCkmJihyPWlbdF0pP3I6KG49dSh0LHQ8MD8tMTowLCExKSxhJiYoaVt0XT1uKSxuKX1mdW5jdGlvbiBzKHQsZSl7aWYoaXNOYU4odCkpcmV0dXJuIGU/bTpiO2lmKGUpe2lmKHQ8MClyZXR1cm4gbTtpZih0Pj1kKXJldHVybiB4fWVsc2V7aWYodDw9LWgpcmV0dXJuIFQ7aWYodCsxPj1oKXJldHVybiB3fXJldHVybiB0PDA/cygtdCxlKS5uZWcoKTp1KHQlZnwwLHQvZnwwLGUpfWZ1bmN0aW9uIHUodCxlLHIpe3JldHVybiBuZXcgbih0LGUscil9bi5mcm9tSW50PWEsbi5mcm9tTnVtYmVyPXMsbi5mcm9tQml0cz11O3ZhciBjPU1hdGgucG93O2Z1bmN0aW9uIGwodCxlLG4pe2lmKDA9PT10Lmxlbmd0aCl0aHJvdyBFcnJvcihcImVtcHR5IHN0cmluZ1wiKTtpZihcIk5hTlwiPT09dHx8XCJJbmZpbml0eVwiPT09dHx8XCIrSW5maW5pdHlcIj09PXR8fFwiLUluZmluaXR5XCI9PT10KXJldHVybiBiO2lmKFwibnVtYmVyXCI9PXR5cGVvZiBlPyhuPWUsZT0hMSk6ZT0hIWUsKG49bnx8MTApPDJ8fDM2PG4pdGhyb3cgUmFuZ2VFcnJvcihcInJhZGl4XCIpO3ZhciByO2lmKChyPXQuaW5kZXhPZihcIi1cIikpPjApdGhyb3cgRXJyb3IoXCJpbnRlcmlvciBoeXBoZW5cIik7aWYoMD09PXIpcmV0dXJuIGwodC5zdWJzdHJpbmcoMSksZSxuKS5uZWcoKTtmb3IodmFyIGk9cyhjKG4sOCkpLG89YixhPTA7YTx0Lmxlbmd0aDthKz04KXt2YXIgdT1NYXRoLm1pbig4LHQubGVuZ3RoLWEpLHA9cGFyc2VJbnQodC5zdWJzdHJpbmcoYSxhK3UpLG4pO2lmKHU8OCl7dmFyIGY9cyhjKG4sdSkpO289by5tdWwoZikuYWRkKHMocCkpfWVsc2Ugbz0obz1vLm11bChpKSkuYWRkKHMocCkpfXJldHVybiBvLnVuc2lnbmVkPWUsb31mdW5jdGlvbiBwKHQsZSl7cmV0dXJuXCJudW1iZXJcIj09dHlwZW9mIHQ/cyh0LGUpOlwic3RyaW5nXCI9PXR5cGVvZiB0P2wodCxlKTp1KHQubG93LHQuaGlnaCxcImJvb2xlYW5cIj09dHlwZW9mIGU/ZTp0LnVuc2lnbmVkKX1uLmZyb21TdHJpbmc9bCxuLmZyb21WYWx1ZT1wO3ZhciBmPTQyOTQ5NjcyOTYsZD1mKmYsaD1kLzIsZz1hKDE8PDI0KSxiPWEoMCk7bi5aRVJPPWI7dmFyIG09YSgwLCEwKTtuLlVaRVJPPW07dmFyIHk9YSgxKTtuLk9ORT15O3ZhciBfPWEoMSwhMCk7bi5VT05FPV87dmFyIHY9YSgtMSk7bi5ORUdfT05FPXY7dmFyIHc9dSgtMSwyMTQ3NDgzNjQ3LCExKTtuLk1BWF9WQUxVRT13O3ZhciB4PXUoLTEsLTEsITApO24uTUFYX1VOU0lHTkVEX1ZBTFVFPXg7dmFyIFQ9dSgwLC0yMTQ3NDgzNjQ4LCExKTtuLk1JTl9WQUxVRT1UO3ZhciBTPW4ucHJvdG90eXBlO1MudG9JbnQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy51bnNpZ25lZD90aGlzLmxvdz4+PjA6dGhpcy5sb3d9LFMudG9OdW1iZXI9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy51bnNpZ25lZD8odGhpcy5oaWdoPj4+MCkqZisodGhpcy5sb3c+Pj4wKTp0aGlzLmhpZ2gqZisodGhpcy5sb3c+Pj4wKX0sUy50b1N0cmluZz1mdW5jdGlvbih0KXtpZigodD10fHwxMCk8Mnx8MzY8dCl0aHJvdyBSYW5nZUVycm9yKFwicmFkaXhcIik7aWYodGhpcy5pc1plcm8oKSlyZXR1cm5cIjBcIjtpZih0aGlzLmlzTmVnYXRpdmUoKSl7aWYodGhpcy5lcShUKSl7dmFyIGU9cyh0KSxuPXRoaXMuZGl2KGUpLHI9bi5tdWwoZSkuc3ViKHRoaXMpO3JldHVybiBuLnRvU3RyaW5nKHQpK3IudG9JbnQoKS50b1N0cmluZyh0KX1yZXR1cm5cIi1cIit0aGlzLm5lZygpLnRvU3RyaW5nKHQpfWZvcih2YXIgaT1zKGModCw2KSx0aGlzLnVuc2lnbmVkKSxvPXRoaXMsYT1cIlwiOzspe3ZhciB1PW8uZGl2KGkpLGw9KG8uc3ViKHUubXVsKGkpKS50b0ludCgpPj4+MCkudG9TdHJpbmcodCk7aWYoKG89dSkuaXNaZXJvKCkpcmV0dXJuIGwrYTtmb3IoO2wubGVuZ3RoPDY7KWw9XCIwXCIrbDthPVwiXCIrbCthfX0sUy5nZXRIaWdoQml0cz1mdW5jdGlvbigpe3JldHVybiB0aGlzLmhpZ2h9LFMuZ2V0SGlnaEJpdHNVbnNpZ25lZD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmhpZ2g+Pj4wfSxTLmdldExvd0JpdHM9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5sb3d9LFMuZ2V0TG93Qml0c1Vuc2lnbmVkPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubG93Pj4+MH0sUy5nZXROdW1CaXRzQWJzPWZ1bmN0aW9uKCl7aWYodGhpcy5pc05lZ2F0aXZlKCkpcmV0dXJuIHRoaXMuZXEoVCk/NjQ6dGhpcy5uZWcoKS5nZXROdW1CaXRzQWJzKCk7Zm9yKHZhciB0PTAhPXRoaXMuaGlnaD90aGlzLmhpZ2g6dGhpcy5sb3csZT0zMTtlPjAmJjA9PSh0JjE8PGUpO2UtLSk7cmV0dXJuIDAhPXRoaXMuaGlnaD9lKzMzOmUrMX0sUy5pc1plcm89ZnVuY3Rpb24oKXtyZXR1cm4gMD09PXRoaXMuaGlnaCYmMD09PXRoaXMubG93fSxTLmVxej1TLmlzWmVybyxTLmlzTmVnYXRpdmU9ZnVuY3Rpb24oKXtyZXR1cm4hdGhpcy51bnNpZ25lZCYmdGhpcy5oaWdoPDB9LFMuaXNQb3NpdGl2ZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLnVuc2lnbmVkfHx0aGlzLmhpZ2g+PTB9LFMuaXNPZGQ9ZnVuY3Rpb24oKXtyZXR1cm4gMT09KDEmdGhpcy5sb3cpfSxTLmlzRXZlbj1mdW5jdGlvbigpe3JldHVybiAwPT0oMSZ0aGlzLmxvdyl9LFMuZXF1YWxzPWZ1bmN0aW9uKHQpe3JldHVybiByKHQpfHwodD1wKHQpKSwodGhpcy51bnNpZ25lZD09PXQudW5zaWduZWR8fHRoaXMuaGlnaD4+PjMxIT0xfHx0LmhpZ2g+Pj4zMSE9MSkmJnRoaXMuaGlnaD09PXQuaGlnaCYmdGhpcy5sb3c9PT10Lmxvd30sUy5lcT1TLmVxdWFscyxTLm5vdEVxdWFscz1mdW5jdGlvbih0KXtyZXR1cm4hdGhpcy5lcSh0KX0sUy5uZXE9Uy5ub3RFcXVhbHMsUy5uZT1TLm5vdEVxdWFscyxTLmxlc3NUaGFuPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmNvbXAodCk8MH0sUy5sdD1TLmxlc3NUaGFuLFMubGVzc1RoYW5PckVxdWFsPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmNvbXAodCk8PTB9LFMubHRlPVMubGVzc1RoYW5PckVxdWFsLFMubGU9Uy5sZXNzVGhhbk9yRXF1YWwsUy5ncmVhdGVyVGhhbj1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5jb21wKHQpPjB9LFMuZ3Q9Uy5ncmVhdGVyVGhhbixTLmdyZWF0ZXJUaGFuT3JFcXVhbD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5jb21wKHQpPj0wfSxTLmd0ZT1TLmdyZWF0ZXJUaGFuT3JFcXVhbCxTLmdlPVMuZ3JlYXRlclRoYW5PckVxdWFsLFMuY29tcGFyZT1mdW5jdGlvbih0KXtpZihyKHQpfHwodD1wKHQpKSx0aGlzLmVxKHQpKXJldHVybiAwO3ZhciBlPXRoaXMuaXNOZWdhdGl2ZSgpLG49dC5pc05lZ2F0aXZlKCk7cmV0dXJuIGUmJiFuPy0xOiFlJiZuPzE6dGhpcy51bnNpZ25lZD90LmhpZ2g+Pj4wPnRoaXMuaGlnaD4+PjB8fHQuaGlnaD09PXRoaXMuaGlnaCYmdC5sb3c+Pj4wPnRoaXMubG93Pj4+MD8tMToxOnRoaXMuc3ViKHQpLmlzTmVnYXRpdmUoKT8tMToxfSxTLmNvbXA9Uy5jb21wYXJlLFMubmVnYXRlPWZ1bmN0aW9uKCl7cmV0dXJuIXRoaXMudW5zaWduZWQmJnRoaXMuZXEoVCk/VDp0aGlzLm5vdCgpLmFkZCh5KX0sUy5uZWc9Uy5uZWdhdGUsUy5hZGQ9ZnVuY3Rpb24odCl7cih0KXx8KHQ9cCh0KSk7dmFyIGU9dGhpcy5oaWdoPj4+MTYsbj02NTUzNSZ0aGlzLmhpZ2gsaT10aGlzLmxvdz4+PjE2LG89NjU1MzUmdGhpcy5sb3csYT10LmhpZ2g+Pj4xNixzPTY1NTM1JnQuaGlnaCxjPXQubG93Pj4+MTYsbD0wLGY9MCxkPTAsaD0wO3JldHVybiBkKz0oaCs9bysoNjU1MzUmdC5sb3cpKT4+PjE2LGYrPShkKz1pK2MpPj4+MTYsbCs9KGYrPW4rcyk+Pj4xNixsKz1lK2EsdSgoZCY9NjU1MzUpPDwxNnwoaCY9NjU1MzUpLChsJj02NTUzNSk8PDE2fChmJj02NTUzNSksdGhpcy51bnNpZ25lZCl9LFMuc3VidHJhY3Q9ZnVuY3Rpb24odCl7cmV0dXJuIHIodCl8fCh0PXAodCkpLHRoaXMuYWRkKHQubmVnKCkpfSxTLnN1Yj1TLnN1YnRyYWN0LFMubXVsdGlwbHk9ZnVuY3Rpb24odCl7aWYodGhpcy5pc1plcm8oKSlyZXR1cm4gYjtpZihyKHQpfHwodD1wKHQpKSxlKXJldHVybiB1KGUubXVsKHRoaXMubG93LHRoaXMuaGlnaCx0Lmxvdyx0LmhpZ2gpLGUuZ2V0X2hpZ2goKSx0aGlzLnVuc2lnbmVkKTtpZih0LmlzWmVybygpKXJldHVybiBiO2lmKHRoaXMuZXEoVCkpcmV0dXJuIHQuaXNPZGQoKT9UOmI7aWYodC5lcShUKSlyZXR1cm4gdGhpcy5pc09kZCgpP1Q6YjtpZih0aGlzLmlzTmVnYXRpdmUoKSlyZXR1cm4gdC5pc05lZ2F0aXZlKCk/dGhpcy5uZWcoKS5tdWwodC5uZWcoKSk6dGhpcy5uZWcoKS5tdWwodCkubmVnKCk7aWYodC5pc05lZ2F0aXZlKCkpcmV0dXJuIHRoaXMubXVsKHQubmVnKCkpLm5lZygpO2lmKHRoaXMubHQoZykmJnQubHQoZykpcmV0dXJuIHModGhpcy50b051bWJlcigpKnQudG9OdW1iZXIoKSx0aGlzLnVuc2lnbmVkKTt2YXIgbj10aGlzLmhpZ2g+Pj4xNixpPTY1NTM1JnRoaXMuaGlnaCxvPXRoaXMubG93Pj4+MTYsYT02NTUzNSZ0aGlzLmxvdyxjPXQuaGlnaD4+PjE2LGw9NjU1MzUmdC5oaWdoLGY9dC5sb3c+Pj4xNixkPTY1NTM1JnQubG93LGg9MCxtPTAseT0wLF89MDtyZXR1cm4geSs9KF8rPWEqZCk+Pj4xNixtKz0oeSs9bypkKT4+PjE2LHkmPTY1NTM1LG0rPSh5Kz1hKmYpPj4+MTYsaCs9KG0rPWkqZCk+Pj4xNixtJj02NTUzNSxoKz0obSs9bypmKT4+PjE2LG0mPTY1NTM1LGgrPShtKz1hKmwpPj4+MTYsaCs9bipkK2kqZitvKmwrYSpjLHUoKHkmPTY1NTM1KTw8MTZ8KF8mPTY1NTM1KSwoaCY9NjU1MzUpPDwxNnwobSY9NjU1MzUpLHRoaXMudW5zaWduZWQpfSxTLm11bD1TLm11bHRpcGx5LFMuZGl2aWRlPWZ1bmN0aW9uKHQpe2lmKHIodCl8fCh0PXAodCkpLHQuaXNaZXJvKCkpdGhyb3cgRXJyb3IoXCJkaXZpc2lvbiBieSB6ZXJvXCIpO3ZhciBuLGksbztpZihlKXJldHVybiB0aGlzLnVuc2lnbmVkfHwtMjE0NzQ4MzY0OCE9PXRoaXMuaGlnaHx8LTEhPT10Lmxvd3x8LTEhPT10LmhpZ2g/dSgodGhpcy51bnNpZ25lZD9lLmRpdl91OmUuZGl2X3MpKHRoaXMubG93LHRoaXMuaGlnaCx0Lmxvdyx0LmhpZ2gpLGUuZ2V0X2hpZ2goKSx0aGlzLnVuc2lnbmVkKTp0aGlzO2lmKHRoaXMuaXNaZXJvKCkpcmV0dXJuIHRoaXMudW5zaWduZWQ/bTpiO2lmKHRoaXMudW5zaWduZWQpe2lmKHQudW5zaWduZWR8fCh0PXQudG9VbnNpZ25lZCgpKSx0Lmd0KHRoaXMpKXJldHVybiBtO2lmKHQuZ3QodGhpcy5zaHJ1KDEpKSlyZXR1cm4gXztvPW19ZWxzZXtpZih0aGlzLmVxKFQpKXJldHVybiB0LmVxKHkpfHx0LmVxKHYpP1Q6dC5lcShUKT95OihuPXRoaXMuc2hyKDEpLmRpdih0KS5zaGwoMSkpLmVxKGIpP3QuaXNOZWdhdGl2ZSgpP3k6djooaT10aGlzLnN1Yih0Lm11bChuKSksbz1uLmFkZChpLmRpdih0KSkpO2lmKHQuZXEoVCkpcmV0dXJuIHRoaXMudW5zaWduZWQ/bTpiO2lmKHRoaXMuaXNOZWdhdGl2ZSgpKXJldHVybiB0LmlzTmVnYXRpdmUoKT90aGlzLm5lZygpLmRpdih0Lm5lZygpKTp0aGlzLm5lZygpLmRpdih0KS5uZWcoKTtpZih0LmlzTmVnYXRpdmUoKSlyZXR1cm4gdGhpcy5kaXYodC5uZWcoKSkubmVnKCk7bz1ifWZvcihpPXRoaXM7aS5ndGUodCk7KXtuPU1hdGgubWF4KDEsTWF0aC5mbG9vcihpLnRvTnVtYmVyKCkvdC50b051bWJlcigpKSk7Zm9yKHZhciBhPU1hdGguY2VpbChNYXRoLmxvZyhuKS9NYXRoLkxOMiksbD1hPD00OD8xOmMoMixhLTQ4KSxmPXMobiksZD1mLm11bCh0KTtkLmlzTmVnYXRpdmUoKXx8ZC5ndChpKTspZD0oZj1zKG4tPWwsdGhpcy51bnNpZ25lZCkpLm11bCh0KTtmLmlzWmVybygpJiYoZj15KSxvPW8uYWRkKGYpLGk9aS5zdWIoZCl9cmV0dXJuIG99LFMuZGl2PVMuZGl2aWRlLFMubW9kdWxvPWZ1bmN0aW9uKHQpe3JldHVybiByKHQpfHwodD1wKHQpKSxlP3UoKHRoaXMudW5zaWduZWQ/ZS5yZW1fdTplLnJlbV9zKSh0aGlzLmxvdyx0aGlzLmhpZ2gsdC5sb3csdC5oaWdoKSxlLmdldF9oaWdoKCksdGhpcy51bnNpZ25lZCk6dGhpcy5zdWIodGhpcy5kaXYodCkubXVsKHQpKX0sUy5tb2Q9Uy5tb2R1bG8sUy5yZW09Uy5tb2R1bG8sUy5ub3Q9ZnVuY3Rpb24oKXtyZXR1cm4gdSh+dGhpcy5sb3csfnRoaXMuaGlnaCx0aGlzLnVuc2lnbmVkKX0sUy5hbmQ9ZnVuY3Rpb24odCl7cmV0dXJuIHIodCl8fCh0PXAodCkpLHUodGhpcy5sb3cmdC5sb3csdGhpcy5oaWdoJnQuaGlnaCx0aGlzLnVuc2lnbmVkKX0sUy5vcj1mdW5jdGlvbih0KXtyZXR1cm4gcih0KXx8KHQ9cCh0KSksdSh0aGlzLmxvd3x0Lmxvdyx0aGlzLmhpZ2h8dC5oaWdoLHRoaXMudW5zaWduZWQpfSxTLnhvcj1mdW5jdGlvbih0KXtyZXR1cm4gcih0KXx8KHQ9cCh0KSksdSh0aGlzLmxvd150Lmxvdyx0aGlzLmhpZ2hedC5oaWdoLHRoaXMudW5zaWduZWQpfSxTLnNoaWZ0TGVmdD1mdW5jdGlvbih0KXtyZXR1cm4gcih0KSYmKHQ9dC50b0ludCgpKSwwPT0odCY9NjMpP3RoaXM6dDwzMj91KHRoaXMubG93PDx0LHRoaXMuaGlnaDw8dHx0aGlzLmxvdz4+PjMyLXQsdGhpcy51bnNpZ25lZCk6dSgwLHRoaXMubG93PDx0LTMyLHRoaXMudW5zaWduZWQpfSxTLnNobD1TLnNoaWZ0TGVmdCxTLnNoaWZ0UmlnaHQ9ZnVuY3Rpb24odCl7cmV0dXJuIHIodCkmJih0PXQudG9JbnQoKSksMD09KHQmPTYzKT90aGlzOnQ8MzI/dSh0aGlzLmxvdz4+PnR8dGhpcy5oaWdoPDwzMi10LHRoaXMuaGlnaD4+dCx0aGlzLnVuc2lnbmVkKTp1KHRoaXMuaGlnaD4+dC0zMix0aGlzLmhpZ2g+PTA/MDotMSx0aGlzLnVuc2lnbmVkKX0sUy5zaHI9Uy5zaGlmdFJpZ2h0LFMuc2hpZnRSaWdodFVuc2lnbmVkPWZ1bmN0aW9uKHQpe2lmKHIodCkmJih0PXQudG9JbnQoKSksMD09KHQmPTYzKSlyZXR1cm4gdGhpczt2YXIgZT10aGlzLmhpZ2g7cmV0dXJuIHQ8MzI/dSh0aGlzLmxvdz4+PnR8ZTw8MzItdCxlPj4+dCx0aGlzLnVuc2lnbmVkKTp1KDMyPT09dD9lOmU+Pj50LTMyLDAsdGhpcy51bnNpZ25lZCl9LFMuc2hydT1TLnNoaWZ0UmlnaHRVbnNpZ25lZCxTLnNocl91PVMuc2hpZnRSaWdodFVuc2lnbmVkLFMudG9TaWduZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy51bnNpZ25lZD91KHRoaXMubG93LHRoaXMuaGlnaCwhMSk6dGhpc30sUy50b1Vuc2lnbmVkPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudW5zaWduZWQ/dGhpczp1KHRoaXMubG93LHRoaXMuaGlnaCwhMCl9LFMudG9CeXRlcz1mdW5jdGlvbih0KXtyZXR1cm4gdD90aGlzLnRvQnl0ZXNMRSgpOnRoaXMudG9CeXRlc0JFKCl9LFMudG9CeXRlc0xFPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5oaWdoLGU9dGhpcy5sb3c7cmV0dXJuWzI1NSZlLGU+Pj44JjI1NSxlPj4+MTYmMjU1LGU+Pj4yNCwyNTUmdCx0Pj4+OCYyNTUsdD4+PjE2JjI1NSx0Pj4+MjRdfSxTLnRvQnl0ZXNCRT1mdW5jdGlvbigpe3ZhciB0PXRoaXMuaGlnaCxlPXRoaXMubG93O3JldHVyblt0Pj4+MjQsdD4+PjE2JjI1NSx0Pj4+OCYyNTUsMjU1JnQsZT4+PjI0LGU+Pj4xNiYyNTUsZT4+PjgmMjU1LDI1NSZlXX0sbi5mcm9tQnl0ZXM9ZnVuY3Rpb24odCxlLHIpe3JldHVybiByP24uZnJvbUJ5dGVzTEUodCxlKTpuLmZyb21CeXRlc0JFKHQsZSl9LG4uZnJvbUJ5dGVzTEU9ZnVuY3Rpb24odCxlKXtyZXR1cm4gbmV3IG4odFswXXx0WzFdPDw4fHRbMl08PDE2fHRbM108PDI0LHRbNF18dFs1XTw8OHx0WzZdPDwxNnx0WzddPDwyNCxlKX0sbi5mcm9tQnl0ZXNCRT1mdW5jdGlvbih0LGUpe3JldHVybiBuZXcgbih0WzRdPDwyNHx0WzVdPDwxNnx0WzZdPDw4fHRbN10sdFswXTw8MjR8dFsxXTw8MTZ8dFsyXTw8OHx0WzNdLGUpfX0sMTQ0NjoodCxlLG4pPT57XCJ1c2Ugc3RyaWN0XCI7dmFyIHIsaSxvLGE9bigyMTAwKSxzPWEuUmVhZGVyLHU9YS5Xcml0ZXIsYz1hLnV0aWwsbD1hLnJvb3RzLmRlZmF1bHR8fChhLnJvb3RzLmRlZmF1bHQ9e30pO2wub25ueD0oKG89e30pLlZlcnNpb249KHI9e30sKGk9T2JqZWN0LmNyZWF0ZShyKSlbclswXT1cIl9TVEFSVF9WRVJTSU9OXCJdPTAsaVtyWzFdPVwiSVJfVkVSU0lPTl8yMDE3XzEwXzEwXCJdPTEsaVtyWzJdPVwiSVJfVkVSU0lPTl8yMDE3XzEwXzMwXCJdPTIsaVtyWzNdPVwiSVJfVkVSU0lPTl8yMDE3XzExXzNcIl09MyxpW3JbNF09XCJJUl9WRVJTSU9OXzIwMTlfMV8yMlwiXT00LGlbcls1XT1cIklSX1ZFUlNJT05cIl09NSxpKSxvLkF0dHJpYnV0ZVByb3RvPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0KXtpZih0aGlzLmZsb2F0cz1bXSx0aGlzLmludHM9W10sdGhpcy5zdHJpbmdzPVtdLHRoaXMudGVuc29ycz1bXSx0aGlzLmdyYXBocz1bXSx0KWZvcih2YXIgZT1PYmplY3Qua2V5cyh0KSxuPTA7bjxlLmxlbmd0aDsrK24pbnVsbCE9dFtlW25dXSYmKHRoaXNbZVtuXV09dFtlW25dXSl9cmV0dXJuIHQucHJvdG90eXBlLm5hbWU9XCJcIix0LnByb3RvdHlwZS5yZWZBdHRyTmFtZT1cIlwiLHQucHJvdG90eXBlLmRvY1N0cmluZz1cIlwiLHQucHJvdG90eXBlLnR5cGU9MCx0LnByb3RvdHlwZS5mPTAsdC5wcm90b3R5cGUuaT1jLkxvbmc/Yy5Mb25nLmZyb21CaXRzKDAsMCwhMSk6MCx0LnByb3RvdHlwZS5zPWMubmV3QnVmZmVyKFtdKSx0LnByb3RvdHlwZS50PW51bGwsdC5wcm90b3R5cGUuZz1udWxsLHQucHJvdG90eXBlLmZsb2F0cz1jLmVtcHR5QXJyYXksdC5wcm90b3R5cGUuaW50cz1jLmVtcHR5QXJyYXksdC5wcm90b3R5cGUuc3RyaW5ncz1jLmVtcHR5QXJyYXksdC5wcm90b3R5cGUudGVuc29ycz1jLmVtcHR5QXJyYXksdC5wcm90b3R5cGUuZ3JhcGhzPWMuZW1wdHlBcnJheSx0LmNyZWF0ZT1mdW5jdGlvbihlKXtyZXR1cm4gbmV3IHQoZSl9LHQuZW5jb2RlPWZ1bmN0aW9uKHQsZSl7aWYoZXx8KGU9dS5jcmVhdGUoKSksbnVsbCE9dC5uYW1lJiZ0Lmhhc093blByb3BlcnR5KFwibmFtZVwiKSYmZS51aW50MzIoMTApLnN0cmluZyh0Lm5hbWUpLG51bGwhPXQuZiYmdC5oYXNPd25Qcm9wZXJ0eShcImZcIikmJmUudWludDMyKDIxKS5mbG9hdCh0LmYpLG51bGwhPXQuaSYmdC5oYXNPd25Qcm9wZXJ0eShcImlcIikmJmUudWludDMyKDI0KS5pbnQ2NCh0LmkpLG51bGwhPXQucyYmdC5oYXNPd25Qcm9wZXJ0eShcInNcIikmJmUudWludDMyKDM0KS5ieXRlcyh0LnMpLG51bGwhPXQudCYmdC5oYXNPd25Qcm9wZXJ0eShcInRcIikmJmwub25ueC5UZW5zb3JQcm90by5lbmNvZGUodC50LGUudWludDMyKDQyKS5mb3JrKCkpLmxkZWxpbSgpLG51bGwhPXQuZyYmdC5oYXNPd25Qcm9wZXJ0eShcImdcIikmJmwub25ueC5HcmFwaFByb3RvLmVuY29kZSh0LmcsZS51aW50MzIoNTApLmZvcmsoKSkubGRlbGltKCksbnVsbCE9dC5mbG9hdHMmJnQuZmxvYXRzLmxlbmd0aCl7ZS51aW50MzIoNTgpLmZvcmsoKTtmb3IodmFyIG49MDtuPHQuZmxvYXRzLmxlbmd0aDsrK24pZS5mbG9hdCh0LmZsb2F0c1tuXSk7ZS5sZGVsaW0oKX1pZihudWxsIT10LmludHMmJnQuaW50cy5sZW5ndGgpe2ZvcihlLnVpbnQzMig2NikuZm9yaygpLG49MDtuPHQuaW50cy5sZW5ndGg7KytuKWUuaW50NjQodC5pbnRzW25dKTtlLmxkZWxpbSgpfWlmKG51bGwhPXQuc3RyaW5ncyYmdC5zdHJpbmdzLmxlbmd0aClmb3Iobj0wO248dC5zdHJpbmdzLmxlbmd0aDsrK24pZS51aW50MzIoNzQpLmJ5dGVzKHQuc3RyaW5nc1tuXSk7aWYobnVsbCE9dC50ZW5zb3JzJiZ0LnRlbnNvcnMubGVuZ3RoKWZvcihuPTA7bjx0LnRlbnNvcnMubGVuZ3RoOysrbilsLm9ubnguVGVuc29yUHJvdG8uZW5jb2RlKHQudGVuc29yc1tuXSxlLnVpbnQzMig4MikuZm9yaygpKS5sZGVsaW0oKTtpZihudWxsIT10LmdyYXBocyYmdC5ncmFwaHMubGVuZ3RoKWZvcihuPTA7bjx0LmdyYXBocy5sZW5ndGg7KytuKWwub25ueC5HcmFwaFByb3RvLmVuY29kZSh0LmdyYXBoc1tuXSxlLnVpbnQzMig5MCkuZm9yaygpKS5sZGVsaW0oKTtyZXR1cm4gbnVsbCE9dC5kb2NTdHJpbmcmJnQuaGFzT3duUHJvcGVydHkoXCJkb2NTdHJpbmdcIikmJmUudWludDMyKDEwNikuc3RyaW5nKHQuZG9jU3RyaW5nKSxudWxsIT10LnR5cGUmJnQuaGFzT3duUHJvcGVydHkoXCJ0eXBlXCIpJiZlLnVpbnQzMigxNjApLmludDMyKHQudHlwZSksbnVsbCE9dC5yZWZBdHRyTmFtZSYmdC5oYXNPd25Qcm9wZXJ0eShcInJlZkF0dHJOYW1lXCIpJiZlLnVpbnQzMigxNzApLnN0cmluZyh0LnJlZkF0dHJOYW1lKSxlfSx0LmVuY29kZURlbGltaXRlZD1mdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLmVuY29kZSh0LGUpLmxkZWxpbSgpfSx0LmRlY29kZT1mdW5jdGlvbih0LGUpe3QgaW5zdGFuY2VvZiBzfHwodD1zLmNyZWF0ZSh0KSk7Zm9yKHZhciBuPXZvaWQgMD09PWU/dC5sZW46dC5wb3MrZSxyPW5ldyBsLm9ubnguQXR0cmlidXRlUHJvdG87dC5wb3M8bjspe3ZhciBpPXQudWludDMyKCk7c3dpdGNoKGk+Pj4zKXtjYXNlIDE6ci5uYW1lPXQuc3RyaW5nKCk7YnJlYWs7Y2FzZSAyMTpyLnJlZkF0dHJOYW1lPXQuc3RyaW5nKCk7YnJlYWs7Y2FzZSAxMzpyLmRvY1N0cmluZz10LnN0cmluZygpO2JyZWFrO2Nhc2UgMjA6ci50eXBlPXQuaW50MzIoKTticmVhaztjYXNlIDI6ci5mPXQuZmxvYXQoKTticmVhaztjYXNlIDM6ci5pPXQuaW50NjQoKTticmVhaztjYXNlIDQ6ci5zPXQuYnl0ZXMoKTticmVhaztjYXNlIDU6ci50PWwub25ueC5UZW5zb3JQcm90by5kZWNvZGUodCx0LnVpbnQzMigpKTticmVhaztjYXNlIDY6ci5nPWwub25ueC5HcmFwaFByb3RvLmRlY29kZSh0LHQudWludDMyKCkpO2JyZWFrO2Nhc2UgNzppZihyLmZsb2F0cyYmci5mbG9hdHMubGVuZ3RofHwoci5mbG9hdHM9W10pLDI9PSg3JmkpKWZvcih2YXIgbz10LnVpbnQzMigpK3QucG9zO3QucG9zPG87KXIuZmxvYXRzLnB1c2godC5mbG9hdCgpKTtlbHNlIHIuZmxvYXRzLnB1c2godC5mbG9hdCgpKTticmVhaztjYXNlIDg6aWYoci5pbnRzJiZyLmludHMubGVuZ3RofHwoci5pbnRzPVtdKSwyPT0oNyZpKSlmb3Iobz10LnVpbnQzMigpK3QucG9zO3QucG9zPG87KXIuaW50cy5wdXNoKHQuaW50NjQoKSk7ZWxzZSByLmludHMucHVzaCh0LmludDY0KCkpO2JyZWFrO2Nhc2UgOTpyLnN0cmluZ3MmJnIuc3RyaW5ncy5sZW5ndGh8fChyLnN0cmluZ3M9W10pLHIuc3RyaW5ncy5wdXNoKHQuYnl0ZXMoKSk7YnJlYWs7Y2FzZSAxMDpyLnRlbnNvcnMmJnIudGVuc29ycy5sZW5ndGh8fChyLnRlbnNvcnM9W10pLHIudGVuc29ycy5wdXNoKGwub25ueC5UZW5zb3JQcm90by5kZWNvZGUodCx0LnVpbnQzMigpKSk7YnJlYWs7Y2FzZSAxMTpyLmdyYXBocyYmci5ncmFwaHMubGVuZ3RofHwoci5ncmFwaHM9W10pLHIuZ3JhcGhzLnB1c2gobC5vbm54LkdyYXBoUHJvdG8uZGVjb2RlKHQsdC51aW50MzIoKSkpO2JyZWFrO2RlZmF1bHQ6dC5za2lwVHlwZSg3JmkpfX1yZXR1cm4gcn0sdC5kZWNvZGVEZWxpbWl0ZWQ9ZnVuY3Rpb24odCl7cmV0dXJuIHQgaW5zdGFuY2VvZiBzfHwodD1uZXcgcyh0KSksdGhpcy5kZWNvZGUodCx0LnVpbnQzMigpKX0sdC52ZXJpZnk9ZnVuY3Rpb24odCl7aWYoXCJvYmplY3RcIiE9dHlwZW9mIHR8fG51bGw9PT10KXJldHVyblwib2JqZWN0IGV4cGVjdGVkXCI7aWYobnVsbCE9dC5uYW1lJiZ0Lmhhc093blByb3BlcnR5KFwibmFtZVwiKSYmIWMuaXNTdHJpbmcodC5uYW1lKSlyZXR1cm5cIm5hbWU6IHN0cmluZyBleHBlY3RlZFwiO2lmKG51bGwhPXQucmVmQXR0ck5hbWUmJnQuaGFzT3duUHJvcGVydHkoXCJyZWZBdHRyTmFtZVwiKSYmIWMuaXNTdHJpbmcodC5yZWZBdHRyTmFtZSkpcmV0dXJuXCJyZWZBdHRyTmFtZTogc3RyaW5nIGV4cGVjdGVkXCI7aWYobnVsbCE9dC5kb2NTdHJpbmcmJnQuaGFzT3duUHJvcGVydHkoXCJkb2NTdHJpbmdcIikmJiFjLmlzU3RyaW5nKHQuZG9jU3RyaW5nKSlyZXR1cm5cImRvY1N0cmluZzogc3RyaW5nIGV4cGVjdGVkXCI7aWYobnVsbCE9dC50eXBlJiZ0Lmhhc093blByb3BlcnR5KFwidHlwZVwiKSlzd2l0Y2godC50eXBlKXtkZWZhdWx0OnJldHVyblwidHlwZTogZW51bSB2YWx1ZSBleHBlY3RlZFwiO2Nhc2UgMDpjYXNlIDE6Y2FzZSAyOmNhc2UgMzpjYXNlIDQ6Y2FzZSA1OmNhc2UgNjpjYXNlIDc6Y2FzZSA4OmNhc2UgOTpjYXNlIDEwOn1pZihudWxsIT10LmYmJnQuaGFzT3duUHJvcGVydHkoXCJmXCIpJiZcIm51bWJlclwiIT10eXBlb2YgdC5mKXJldHVyblwiZjogbnVtYmVyIGV4cGVjdGVkXCI7aWYobnVsbCE9dC5pJiZ0Lmhhc093blByb3BlcnR5KFwiaVwiKSYmIShjLmlzSW50ZWdlcih0LmkpfHx0LmkmJmMuaXNJbnRlZ2VyKHQuaS5sb3cpJiZjLmlzSW50ZWdlcih0LmkuaGlnaCkpKXJldHVyblwiaTogaW50ZWdlcnxMb25nIGV4cGVjdGVkXCI7aWYobnVsbCE9dC5zJiZ0Lmhhc093blByb3BlcnR5KFwic1wiKSYmISh0LnMmJlwibnVtYmVyXCI9PXR5cGVvZiB0LnMubGVuZ3RofHxjLmlzU3RyaW5nKHQucykpKXJldHVyblwiczogYnVmZmVyIGV4cGVjdGVkXCI7aWYobnVsbCE9dC50JiZ0Lmhhc093blByb3BlcnR5KFwidFwiKSYmKG49bC5vbm54LlRlbnNvclByb3RvLnZlcmlmeSh0LnQpKSlyZXR1cm5cInQuXCIrbjtpZihudWxsIT10LmcmJnQuaGFzT3duUHJvcGVydHkoXCJnXCIpJiYobj1sLm9ubnguR3JhcGhQcm90by52ZXJpZnkodC5nKSkpcmV0dXJuXCJnLlwiK247aWYobnVsbCE9dC5mbG9hdHMmJnQuaGFzT3duUHJvcGVydHkoXCJmbG9hdHNcIikpe2lmKCFBcnJheS5pc0FycmF5KHQuZmxvYXRzKSlyZXR1cm5cImZsb2F0czogYXJyYXkgZXhwZWN0ZWRcIjtmb3IodmFyIGU9MDtlPHQuZmxvYXRzLmxlbmd0aDsrK2UpaWYoXCJudW1iZXJcIiE9dHlwZW9mIHQuZmxvYXRzW2VdKXJldHVyblwiZmxvYXRzOiBudW1iZXJbXSBleHBlY3RlZFwifWlmKG51bGwhPXQuaW50cyYmdC5oYXNPd25Qcm9wZXJ0eShcImludHNcIikpe2lmKCFBcnJheS5pc0FycmF5KHQuaW50cykpcmV0dXJuXCJpbnRzOiBhcnJheSBleHBlY3RlZFwiO2ZvcihlPTA7ZTx0LmludHMubGVuZ3RoOysrZSlpZighKGMuaXNJbnRlZ2VyKHQuaW50c1tlXSl8fHQuaW50c1tlXSYmYy5pc0ludGVnZXIodC5pbnRzW2VdLmxvdykmJmMuaXNJbnRlZ2VyKHQuaW50c1tlXS5oaWdoKSkpcmV0dXJuXCJpbnRzOiBpbnRlZ2VyfExvbmdbXSBleHBlY3RlZFwifWlmKG51bGwhPXQuc3RyaW5ncyYmdC5oYXNPd25Qcm9wZXJ0eShcInN0cmluZ3NcIikpe2lmKCFBcnJheS5pc0FycmF5KHQuc3RyaW5ncykpcmV0dXJuXCJzdHJpbmdzOiBhcnJheSBleHBlY3RlZFwiO2ZvcihlPTA7ZTx0LnN0cmluZ3MubGVuZ3RoOysrZSlpZighKHQuc3RyaW5nc1tlXSYmXCJudW1iZXJcIj09dHlwZW9mIHQuc3RyaW5nc1tlXS5sZW5ndGh8fGMuaXNTdHJpbmcodC5zdHJpbmdzW2VdKSkpcmV0dXJuXCJzdHJpbmdzOiBidWZmZXJbXSBleHBlY3RlZFwifWlmKG51bGwhPXQudGVuc29ycyYmdC5oYXNPd25Qcm9wZXJ0eShcInRlbnNvcnNcIikpe2lmKCFBcnJheS5pc0FycmF5KHQudGVuc29ycykpcmV0dXJuXCJ0ZW5zb3JzOiBhcnJheSBleHBlY3RlZFwiO2ZvcihlPTA7ZTx0LnRlbnNvcnMubGVuZ3RoOysrZSlpZihuPWwub25ueC5UZW5zb3JQcm90by52ZXJpZnkodC50ZW5zb3JzW2VdKSlyZXR1cm5cInRlbnNvcnMuXCIrbn1pZihudWxsIT10LmdyYXBocyYmdC5oYXNPd25Qcm9wZXJ0eShcImdyYXBoc1wiKSl7aWYoIUFycmF5LmlzQXJyYXkodC5ncmFwaHMpKXJldHVyblwiZ3JhcGhzOiBhcnJheSBleHBlY3RlZFwiO2ZvcihlPTA7ZTx0LmdyYXBocy5sZW5ndGg7KytlKXt2YXIgbjtpZihuPWwub25ueC5HcmFwaFByb3RvLnZlcmlmeSh0LmdyYXBoc1tlXSkpcmV0dXJuXCJncmFwaHMuXCIrbn19cmV0dXJuIG51bGx9LHQuZnJvbU9iamVjdD1mdW5jdGlvbih0KXtpZih0IGluc3RhbmNlb2YgbC5vbm54LkF0dHJpYnV0ZVByb3RvKXJldHVybiB0O3ZhciBlPW5ldyBsLm9ubnguQXR0cmlidXRlUHJvdG87c3dpdGNoKG51bGwhPXQubmFtZSYmKGUubmFtZT1TdHJpbmcodC5uYW1lKSksbnVsbCE9dC5yZWZBdHRyTmFtZSYmKGUucmVmQXR0ck5hbWU9U3RyaW5nKHQucmVmQXR0ck5hbWUpKSxudWxsIT10LmRvY1N0cmluZyYmKGUuZG9jU3RyaW5nPVN0cmluZyh0LmRvY1N0cmluZykpLHQudHlwZSl7Y2FzZVwiVU5ERUZJTkVEXCI6Y2FzZSAwOmUudHlwZT0wO2JyZWFrO2Nhc2VcIkZMT0FUXCI6Y2FzZSAxOmUudHlwZT0xO2JyZWFrO2Nhc2VcIklOVFwiOmNhc2UgMjplLnR5cGU9MjticmVhaztjYXNlXCJTVFJJTkdcIjpjYXNlIDM6ZS50eXBlPTM7YnJlYWs7Y2FzZVwiVEVOU09SXCI6Y2FzZSA0OmUudHlwZT00O2JyZWFrO2Nhc2VcIkdSQVBIXCI6Y2FzZSA1OmUudHlwZT01O2JyZWFrO2Nhc2VcIkZMT0FUU1wiOmNhc2UgNjplLnR5cGU9NjticmVhaztjYXNlXCJJTlRTXCI6Y2FzZSA3OmUudHlwZT03O2JyZWFrO2Nhc2VcIlNUUklOR1NcIjpjYXNlIDg6ZS50eXBlPTg7YnJlYWs7Y2FzZVwiVEVOU09SU1wiOmNhc2UgOTplLnR5cGU9OTticmVhaztjYXNlXCJHUkFQSFNcIjpjYXNlIDEwOmUudHlwZT0xMH1pZihudWxsIT10LmYmJihlLmY9TnVtYmVyKHQuZikpLG51bGwhPXQuaSYmKGMuTG9uZz8oZS5pPWMuTG9uZy5mcm9tVmFsdWUodC5pKSkudW5zaWduZWQ9ITE6XCJzdHJpbmdcIj09dHlwZW9mIHQuaT9lLmk9cGFyc2VJbnQodC5pLDEwKTpcIm51bWJlclwiPT10eXBlb2YgdC5pP2UuaT10Lmk6XCJvYmplY3RcIj09dHlwZW9mIHQuaSYmKGUuaT1uZXcgYy5Mb25nQml0cyh0LmkubG93Pj4+MCx0LmkuaGlnaD4+PjApLnRvTnVtYmVyKCkpKSxudWxsIT10LnMmJihcInN0cmluZ1wiPT10eXBlb2YgdC5zP2MuYmFzZTY0LmRlY29kZSh0LnMsZS5zPWMubmV3QnVmZmVyKGMuYmFzZTY0Lmxlbmd0aCh0LnMpKSwwKTp0LnMubGVuZ3RoJiYoZS5zPXQucykpLG51bGwhPXQudCl7aWYoXCJvYmplY3RcIiE9dHlwZW9mIHQudCl0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5BdHRyaWJ1dGVQcm90by50OiBvYmplY3QgZXhwZWN0ZWRcIik7ZS50PWwub25ueC5UZW5zb3JQcm90by5mcm9tT2JqZWN0KHQudCl9aWYobnVsbCE9dC5nKXtpZihcIm9iamVjdFwiIT10eXBlb2YgdC5nKXRocm93IFR5cGVFcnJvcihcIi5vbm54LkF0dHJpYnV0ZVByb3RvLmc6IG9iamVjdCBleHBlY3RlZFwiKTtlLmc9bC5vbm54LkdyYXBoUHJvdG8uZnJvbU9iamVjdCh0LmcpfWlmKHQuZmxvYXRzKXtpZighQXJyYXkuaXNBcnJheSh0LmZsb2F0cykpdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguQXR0cmlidXRlUHJvdG8uZmxvYXRzOiBhcnJheSBleHBlY3RlZFwiKTtlLmZsb2F0cz1bXTtmb3IodmFyIG49MDtuPHQuZmxvYXRzLmxlbmd0aDsrK24pZS5mbG9hdHNbbl09TnVtYmVyKHQuZmxvYXRzW25dKX1pZih0LmludHMpe2lmKCFBcnJheS5pc0FycmF5KHQuaW50cykpdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguQXR0cmlidXRlUHJvdG8uaW50czogYXJyYXkgZXhwZWN0ZWRcIik7Zm9yKGUuaW50cz1bXSxuPTA7bjx0LmludHMubGVuZ3RoOysrbiljLkxvbmc/KGUuaW50c1tuXT1jLkxvbmcuZnJvbVZhbHVlKHQuaW50c1tuXSkpLnVuc2lnbmVkPSExOlwic3RyaW5nXCI9PXR5cGVvZiB0LmludHNbbl0/ZS5pbnRzW25dPXBhcnNlSW50KHQuaW50c1tuXSwxMCk6XCJudW1iZXJcIj09dHlwZW9mIHQuaW50c1tuXT9lLmludHNbbl09dC5pbnRzW25dOlwib2JqZWN0XCI9PXR5cGVvZiB0LmludHNbbl0mJihlLmludHNbbl09bmV3IGMuTG9uZ0JpdHModC5pbnRzW25dLmxvdz4+PjAsdC5pbnRzW25dLmhpZ2g+Pj4wKS50b051bWJlcigpKX1pZih0LnN0cmluZ3Mpe2lmKCFBcnJheS5pc0FycmF5KHQuc3RyaW5ncykpdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguQXR0cmlidXRlUHJvdG8uc3RyaW5nczogYXJyYXkgZXhwZWN0ZWRcIik7Zm9yKGUuc3RyaW5ncz1bXSxuPTA7bjx0LnN0cmluZ3MubGVuZ3RoOysrbilcInN0cmluZ1wiPT10eXBlb2YgdC5zdHJpbmdzW25dP2MuYmFzZTY0LmRlY29kZSh0LnN0cmluZ3Nbbl0sZS5zdHJpbmdzW25dPWMubmV3QnVmZmVyKGMuYmFzZTY0Lmxlbmd0aCh0LnN0cmluZ3Nbbl0pKSwwKTp0LnN0cmluZ3Nbbl0ubGVuZ3RoJiYoZS5zdHJpbmdzW25dPXQuc3RyaW5nc1tuXSl9aWYodC50ZW5zb3JzKXtpZighQXJyYXkuaXNBcnJheSh0LnRlbnNvcnMpKXRocm93IFR5cGVFcnJvcihcIi5vbm54LkF0dHJpYnV0ZVByb3RvLnRlbnNvcnM6IGFycmF5IGV4cGVjdGVkXCIpO2ZvcihlLnRlbnNvcnM9W10sbj0wO248dC50ZW5zb3JzLmxlbmd0aDsrK24pe2lmKFwib2JqZWN0XCIhPXR5cGVvZiB0LnRlbnNvcnNbbl0pdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguQXR0cmlidXRlUHJvdG8udGVuc29yczogb2JqZWN0IGV4cGVjdGVkXCIpO2UudGVuc29yc1tuXT1sLm9ubnguVGVuc29yUHJvdG8uZnJvbU9iamVjdCh0LnRlbnNvcnNbbl0pfX1pZih0LmdyYXBocyl7aWYoIUFycmF5LmlzQXJyYXkodC5ncmFwaHMpKXRocm93IFR5cGVFcnJvcihcIi5vbm54LkF0dHJpYnV0ZVByb3RvLmdyYXBoczogYXJyYXkgZXhwZWN0ZWRcIik7Zm9yKGUuZ3JhcGhzPVtdLG49MDtuPHQuZ3JhcGhzLmxlbmd0aDsrK24pe2lmKFwib2JqZWN0XCIhPXR5cGVvZiB0LmdyYXBoc1tuXSl0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5BdHRyaWJ1dGVQcm90by5ncmFwaHM6IG9iamVjdCBleHBlY3RlZFwiKTtlLmdyYXBoc1tuXT1sLm9ubnguR3JhcGhQcm90by5mcm9tT2JqZWN0KHQuZ3JhcGhzW25dKX19cmV0dXJuIGV9LHQudG9PYmplY3Q9ZnVuY3Rpb24odCxlKXtlfHwoZT17fSk7dmFyIG49e307aWYoKGUuYXJyYXlzfHxlLmRlZmF1bHRzKSYmKG4uZmxvYXRzPVtdLG4uaW50cz1bXSxuLnN0cmluZ3M9W10sbi50ZW5zb3JzPVtdLG4uZ3JhcGhzPVtdKSxlLmRlZmF1bHRzKXtpZihuLm5hbWU9XCJcIixuLmY9MCxjLkxvbmcpe3ZhciByPW5ldyBjLkxvbmcoMCwwLCExKTtuLmk9ZS5sb25ncz09PVN0cmluZz9yLnRvU3RyaW5nKCk6ZS5sb25ncz09PU51bWJlcj9yLnRvTnVtYmVyKCk6cn1lbHNlIG4uaT1lLmxvbmdzPT09U3RyaW5nP1wiMFwiOjA7ZS5ieXRlcz09PVN0cmluZz9uLnM9XCJcIjoobi5zPVtdLGUuYnl0ZXMhPT1BcnJheSYmKG4ucz1jLm5ld0J1ZmZlcihuLnMpKSksbi50PW51bGwsbi5nPW51bGwsbi5kb2NTdHJpbmc9XCJcIixuLnR5cGU9ZS5lbnVtcz09PVN0cmluZz9cIlVOREVGSU5FRFwiOjAsbi5yZWZBdHRyTmFtZT1cIlwifWlmKG51bGwhPXQubmFtZSYmdC5oYXNPd25Qcm9wZXJ0eShcIm5hbWVcIikmJihuLm5hbWU9dC5uYW1lKSxudWxsIT10LmYmJnQuaGFzT3duUHJvcGVydHkoXCJmXCIpJiYobi5mPWUuanNvbiYmIWlzRmluaXRlKHQuZik/U3RyaW5nKHQuZik6dC5mKSxudWxsIT10LmkmJnQuaGFzT3duUHJvcGVydHkoXCJpXCIpJiYoXCJudW1iZXJcIj09dHlwZW9mIHQuaT9uLmk9ZS5sb25ncz09PVN0cmluZz9TdHJpbmcodC5pKTp0Lmk6bi5pPWUubG9uZ3M9PT1TdHJpbmc/Yy5Mb25nLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHQuaSk6ZS5sb25ncz09PU51bWJlcj9uZXcgYy5Mb25nQml0cyh0LmkubG93Pj4+MCx0LmkuaGlnaD4+PjApLnRvTnVtYmVyKCk6dC5pKSxudWxsIT10LnMmJnQuaGFzT3duUHJvcGVydHkoXCJzXCIpJiYobi5zPWUuYnl0ZXM9PT1TdHJpbmc/Yy5iYXNlNjQuZW5jb2RlKHQucywwLHQucy5sZW5ndGgpOmUuYnl0ZXM9PT1BcnJheT9BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0LnMpOnQucyksbnVsbCE9dC50JiZ0Lmhhc093blByb3BlcnR5KFwidFwiKSYmKG4udD1sLm9ubnguVGVuc29yUHJvdG8udG9PYmplY3QodC50LGUpKSxudWxsIT10LmcmJnQuaGFzT3duUHJvcGVydHkoXCJnXCIpJiYobi5nPWwub25ueC5HcmFwaFByb3RvLnRvT2JqZWN0KHQuZyxlKSksdC5mbG9hdHMmJnQuZmxvYXRzLmxlbmd0aCl7bi5mbG9hdHM9W107Zm9yKHZhciBpPTA7aTx0LmZsb2F0cy5sZW5ndGg7KytpKW4uZmxvYXRzW2ldPWUuanNvbiYmIWlzRmluaXRlKHQuZmxvYXRzW2ldKT9TdHJpbmcodC5mbG9hdHNbaV0pOnQuZmxvYXRzW2ldfWlmKHQuaW50cyYmdC5pbnRzLmxlbmd0aClmb3Iobi5pbnRzPVtdLGk9MDtpPHQuaW50cy5sZW5ndGg7KytpKVwibnVtYmVyXCI9PXR5cGVvZiB0LmludHNbaV0/bi5pbnRzW2ldPWUubG9uZ3M9PT1TdHJpbmc/U3RyaW5nKHQuaW50c1tpXSk6dC5pbnRzW2ldOm4uaW50c1tpXT1lLmxvbmdzPT09U3RyaW5nP2MuTG9uZy5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0LmludHNbaV0pOmUubG9uZ3M9PT1OdW1iZXI/bmV3IGMuTG9uZ0JpdHModC5pbnRzW2ldLmxvdz4+PjAsdC5pbnRzW2ldLmhpZ2g+Pj4wKS50b051bWJlcigpOnQuaW50c1tpXTtpZih0LnN0cmluZ3MmJnQuc3RyaW5ncy5sZW5ndGgpZm9yKG4uc3RyaW5ncz1bXSxpPTA7aTx0LnN0cmluZ3MubGVuZ3RoOysraSluLnN0cmluZ3NbaV09ZS5ieXRlcz09PVN0cmluZz9jLmJhc2U2NC5lbmNvZGUodC5zdHJpbmdzW2ldLDAsdC5zdHJpbmdzW2ldLmxlbmd0aCk6ZS5ieXRlcz09PUFycmF5P0FycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHQuc3RyaW5nc1tpXSk6dC5zdHJpbmdzW2ldO2lmKHQudGVuc29ycyYmdC50ZW5zb3JzLmxlbmd0aClmb3Iobi50ZW5zb3JzPVtdLGk9MDtpPHQudGVuc29ycy5sZW5ndGg7KytpKW4udGVuc29yc1tpXT1sLm9ubnguVGVuc29yUHJvdG8udG9PYmplY3QodC50ZW5zb3JzW2ldLGUpO2lmKHQuZ3JhcGhzJiZ0LmdyYXBocy5sZW5ndGgpZm9yKG4uZ3JhcGhzPVtdLGk9MDtpPHQuZ3JhcGhzLmxlbmd0aDsrK2kpbi5ncmFwaHNbaV09bC5vbm54LkdyYXBoUHJvdG8udG9PYmplY3QodC5ncmFwaHNbaV0sZSk7cmV0dXJuIG51bGwhPXQuZG9jU3RyaW5nJiZ0Lmhhc093blByb3BlcnR5KFwiZG9jU3RyaW5nXCIpJiYobi5kb2NTdHJpbmc9dC5kb2NTdHJpbmcpLG51bGwhPXQudHlwZSYmdC5oYXNPd25Qcm9wZXJ0eShcInR5cGVcIikmJihuLnR5cGU9ZS5lbnVtcz09PVN0cmluZz9sLm9ubnguQXR0cmlidXRlUHJvdG8uQXR0cmlidXRlVHlwZVt0LnR5cGVdOnQudHlwZSksbnVsbCE9dC5yZWZBdHRyTmFtZSYmdC5oYXNPd25Qcm9wZXJ0eShcInJlZkF0dHJOYW1lXCIpJiYobi5yZWZBdHRyTmFtZT10LnJlZkF0dHJOYW1lKSxufSx0LnByb3RvdHlwZS50b0pTT049ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci50b09iamVjdCh0aGlzLGEudXRpbC50b0pTT05PcHRpb25zKX0sdC5BdHRyaWJ1dGVUeXBlPWZ1bmN0aW9uKCl7dmFyIHQ9e30sZT1PYmplY3QuY3JlYXRlKHQpO3JldHVybiBlW3RbMF09XCJVTkRFRklORURcIl09MCxlW3RbMV09XCJGTE9BVFwiXT0xLGVbdFsyXT1cIklOVFwiXT0yLGVbdFszXT1cIlNUUklOR1wiXT0zLGVbdFs0XT1cIlRFTlNPUlwiXT00LGVbdFs1XT1cIkdSQVBIXCJdPTUsZVt0WzZdPVwiRkxPQVRTXCJdPTYsZVt0WzddPVwiSU5UU1wiXT03LGVbdFs4XT1cIlNUUklOR1NcIl09OCxlW3RbOV09XCJURU5TT1JTXCJdPTksZVt0WzEwXT1cIkdSQVBIU1wiXT0xMCxlfSgpLHR9KCksby5WYWx1ZUluZm9Qcm90bz1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCl7aWYodClmb3IodmFyIGU9T2JqZWN0LmtleXModCksbj0wO248ZS5sZW5ndGg7KytuKW51bGwhPXRbZVtuXV0mJih0aGlzW2Vbbl1dPXRbZVtuXV0pfXJldHVybiB0LnByb3RvdHlwZS5uYW1lPVwiXCIsdC5wcm90b3R5cGUudHlwZT1udWxsLHQucHJvdG90eXBlLmRvY1N0cmluZz1cIlwiLHQuY3JlYXRlPWZ1bmN0aW9uKGUpe3JldHVybiBuZXcgdChlKX0sdC5lbmNvZGU9ZnVuY3Rpb24odCxlKXtyZXR1cm4gZXx8KGU9dS5jcmVhdGUoKSksbnVsbCE9dC5uYW1lJiZ0Lmhhc093blByb3BlcnR5KFwibmFtZVwiKSYmZS51aW50MzIoMTApLnN0cmluZyh0Lm5hbWUpLG51bGwhPXQudHlwZSYmdC5oYXNPd25Qcm9wZXJ0eShcInR5cGVcIikmJmwub25ueC5UeXBlUHJvdG8uZW5jb2RlKHQudHlwZSxlLnVpbnQzMigxOCkuZm9yaygpKS5sZGVsaW0oKSxudWxsIT10LmRvY1N0cmluZyYmdC5oYXNPd25Qcm9wZXJ0eShcImRvY1N0cmluZ1wiKSYmZS51aW50MzIoMjYpLnN0cmluZyh0LmRvY1N0cmluZyksZX0sdC5lbmNvZGVEZWxpbWl0ZWQ9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5lbmNvZGUodCxlKS5sZGVsaW0oKX0sdC5kZWNvZGU9ZnVuY3Rpb24odCxlKXt0IGluc3RhbmNlb2Ygc3x8KHQ9cy5jcmVhdGUodCkpO2Zvcih2YXIgbj12b2lkIDA9PT1lP3QubGVuOnQucG9zK2Uscj1uZXcgbC5vbm54LlZhbHVlSW5mb1Byb3RvO3QucG9zPG47KXt2YXIgaT10LnVpbnQzMigpO3N3aXRjaChpPj4+Myl7Y2FzZSAxOnIubmFtZT10LnN0cmluZygpO2JyZWFrO2Nhc2UgMjpyLnR5cGU9bC5vbm54LlR5cGVQcm90by5kZWNvZGUodCx0LnVpbnQzMigpKTticmVhaztjYXNlIDM6ci5kb2NTdHJpbmc9dC5zdHJpbmcoKTticmVhaztkZWZhdWx0OnQuc2tpcFR5cGUoNyZpKX19cmV0dXJuIHJ9LHQuZGVjb2RlRGVsaW1pdGVkPWZ1bmN0aW9uKHQpe3JldHVybiB0IGluc3RhbmNlb2Ygc3x8KHQ9bmV3IHModCkpLHRoaXMuZGVjb2RlKHQsdC51aW50MzIoKSl9LHQudmVyaWZ5PWZ1bmN0aW9uKHQpe2lmKFwib2JqZWN0XCIhPXR5cGVvZiB0fHxudWxsPT09dClyZXR1cm5cIm9iamVjdCBleHBlY3RlZFwiO2lmKG51bGwhPXQubmFtZSYmdC5oYXNPd25Qcm9wZXJ0eShcIm5hbWVcIikmJiFjLmlzU3RyaW5nKHQubmFtZSkpcmV0dXJuXCJuYW1lOiBzdHJpbmcgZXhwZWN0ZWRcIjtpZihudWxsIT10LnR5cGUmJnQuaGFzT3duUHJvcGVydHkoXCJ0eXBlXCIpKXt2YXIgZT1sLm9ubnguVHlwZVByb3RvLnZlcmlmeSh0LnR5cGUpO2lmKGUpcmV0dXJuXCJ0eXBlLlwiK2V9cmV0dXJuIG51bGwhPXQuZG9jU3RyaW5nJiZ0Lmhhc093blByb3BlcnR5KFwiZG9jU3RyaW5nXCIpJiYhYy5pc1N0cmluZyh0LmRvY1N0cmluZyk/XCJkb2NTdHJpbmc6IHN0cmluZyBleHBlY3RlZFwiOm51bGx9LHQuZnJvbU9iamVjdD1mdW5jdGlvbih0KXtpZih0IGluc3RhbmNlb2YgbC5vbm54LlZhbHVlSW5mb1Byb3RvKXJldHVybiB0O3ZhciBlPW5ldyBsLm9ubnguVmFsdWVJbmZvUHJvdG87aWYobnVsbCE9dC5uYW1lJiYoZS5uYW1lPVN0cmluZyh0Lm5hbWUpKSxudWxsIT10LnR5cGUpe2lmKFwib2JqZWN0XCIhPXR5cGVvZiB0LnR5cGUpdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguVmFsdWVJbmZvUHJvdG8udHlwZTogb2JqZWN0IGV4cGVjdGVkXCIpO2UudHlwZT1sLm9ubnguVHlwZVByb3RvLmZyb21PYmplY3QodC50eXBlKX1yZXR1cm4gbnVsbCE9dC5kb2NTdHJpbmcmJihlLmRvY1N0cmluZz1TdHJpbmcodC5kb2NTdHJpbmcpKSxlfSx0LnRvT2JqZWN0PWZ1bmN0aW9uKHQsZSl7ZXx8KGU9e30pO3ZhciBuPXt9O3JldHVybiBlLmRlZmF1bHRzJiYobi5uYW1lPVwiXCIsbi50eXBlPW51bGwsbi5kb2NTdHJpbmc9XCJcIiksbnVsbCE9dC5uYW1lJiZ0Lmhhc093blByb3BlcnR5KFwibmFtZVwiKSYmKG4ubmFtZT10Lm5hbWUpLG51bGwhPXQudHlwZSYmdC5oYXNPd25Qcm9wZXJ0eShcInR5cGVcIikmJihuLnR5cGU9bC5vbm54LlR5cGVQcm90by50b09iamVjdCh0LnR5cGUsZSkpLG51bGwhPXQuZG9jU3RyaW5nJiZ0Lmhhc093blByb3BlcnR5KFwiZG9jU3RyaW5nXCIpJiYobi5kb2NTdHJpbmc9dC5kb2NTdHJpbmcpLG59LHQucHJvdG90eXBlLnRvSlNPTj1mdW5jdGlvbigpe3JldHVybiB0aGlzLmNvbnN0cnVjdG9yLnRvT2JqZWN0KHRoaXMsYS51dGlsLnRvSlNPTk9wdGlvbnMpfSx0fSgpLG8uTm9kZVByb3RvPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0KXtpZih0aGlzLmlucHV0PVtdLHRoaXMub3V0cHV0PVtdLHRoaXMuYXR0cmlidXRlPVtdLHQpZm9yKHZhciBlPU9iamVjdC5rZXlzKHQpLG49MDtuPGUubGVuZ3RoOysrbiludWxsIT10W2Vbbl1dJiYodGhpc1tlW25dXT10W2Vbbl1dKX1yZXR1cm4gdC5wcm90b3R5cGUuaW5wdXQ9Yy5lbXB0eUFycmF5LHQucHJvdG90eXBlLm91dHB1dD1jLmVtcHR5QXJyYXksdC5wcm90b3R5cGUubmFtZT1cIlwiLHQucHJvdG90eXBlLm9wVHlwZT1cIlwiLHQucHJvdG90eXBlLmRvbWFpbj1cIlwiLHQucHJvdG90eXBlLmF0dHJpYnV0ZT1jLmVtcHR5QXJyYXksdC5wcm90b3R5cGUuZG9jU3RyaW5nPVwiXCIsdC5jcmVhdGU9ZnVuY3Rpb24oZSl7cmV0dXJuIG5ldyB0KGUpfSx0LmVuY29kZT1mdW5jdGlvbih0LGUpe2lmKGV8fChlPXUuY3JlYXRlKCkpLG51bGwhPXQuaW5wdXQmJnQuaW5wdXQubGVuZ3RoKWZvcih2YXIgbj0wO248dC5pbnB1dC5sZW5ndGg7KytuKWUudWludDMyKDEwKS5zdHJpbmcodC5pbnB1dFtuXSk7aWYobnVsbCE9dC5vdXRwdXQmJnQub3V0cHV0Lmxlbmd0aClmb3Iobj0wO248dC5vdXRwdXQubGVuZ3RoOysrbillLnVpbnQzMigxOCkuc3RyaW5nKHQub3V0cHV0W25dKTtpZihudWxsIT10Lm5hbWUmJnQuaGFzT3duUHJvcGVydHkoXCJuYW1lXCIpJiZlLnVpbnQzMigyNikuc3RyaW5nKHQubmFtZSksbnVsbCE9dC5vcFR5cGUmJnQuaGFzT3duUHJvcGVydHkoXCJvcFR5cGVcIikmJmUudWludDMyKDM0KS5zdHJpbmcodC5vcFR5cGUpLG51bGwhPXQuYXR0cmlidXRlJiZ0LmF0dHJpYnV0ZS5sZW5ndGgpZm9yKG49MDtuPHQuYXR0cmlidXRlLmxlbmd0aDsrK24pbC5vbm54LkF0dHJpYnV0ZVByb3RvLmVuY29kZSh0LmF0dHJpYnV0ZVtuXSxlLnVpbnQzMig0MikuZm9yaygpKS5sZGVsaW0oKTtyZXR1cm4gbnVsbCE9dC5kb2NTdHJpbmcmJnQuaGFzT3duUHJvcGVydHkoXCJkb2NTdHJpbmdcIikmJmUudWludDMyKDUwKS5zdHJpbmcodC5kb2NTdHJpbmcpLG51bGwhPXQuZG9tYWluJiZ0Lmhhc093blByb3BlcnR5KFwiZG9tYWluXCIpJiZlLnVpbnQzMig1OCkuc3RyaW5nKHQuZG9tYWluKSxlfSx0LmVuY29kZURlbGltaXRlZD1mdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLmVuY29kZSh0LGUpLmxkZWxpbSgpfSx0LmRlY29kZT1mdW5jdGlvbih0LGUpe3QgaW5zdGFuY2VvZiBzfHwodD1zLmNyZWF0ZSh0KSk7Zm9yKHZhciBuPXZvaWQgMD09PWU/dC5sZW46dC5wb3MrZSxyPW5ldyBsLm9ubnguTm9kZVByb3RvO3QucG9zPG47KXt2YXIgaT10LnVpbnQzMigpO3N3aXRjaChpPj4+Myl7Y2FzZSAxOnIuaW5wdXQmJnIuaW5wdXQubGVuZ3RofHwoci5pbnB1dD1bXSksci5pbnB1dC5wdXNoKHQuc3RyaW5nKCkpO2JyZWFrO2Nhc2UgMjpyLm91dHB1dCYmci5vdXRwdXQubGVuZ3RofHwoci5vdXRwdXQ9W10pLHIub3V0cHV0LnB1c2godC5zdHJpbmcoKSk7YnJlYWs7Y2FzZSAzOnIubmFtZT10LnN0cmluZygpO2JyZWFrO2Nhc2UgNDpyLm9wVHlwZT10LnN0cmluZygpO2JyZWFrO2Nhc2UgNzpyLmRvbWFpbj10LnN0cmluZygpO2JyZWFrO2Nhc2UgNTpyLmF0dHJpYnV0ZSYmci5hdHRyaWJ1dGUubGVuZ3RofHwoci5hdHRyaWJ1dGU9W10pLHIuYXR0cmlidXRlLnB1c2gobC5vbm54LkF0dHJpYnV0ZVByb3RvLmRlY29kZSh0LHQudWludDMyKCkpKTticmVhaztjYXNlIDY6ci5kb2NTdHJpbmc9dC5zdHJpbmcoKTticmVhaztkZWZhdWx0OnQuc2tpcFR5cGUoNyZpKX19cmV0dXJuIHJ9LHQuZGVjb2RlRGVsaW1pdGVkPWZ1bmN0aW9uKHQpe3JldHVybiB0IGluc3RhbmNlb2Ygc3x8KHQ9bmV3IHModCkpLHRoaXMuZGVjb2RlKHQsdC51aW50MzIoKSl9LHQudmVyaWZ5PWZ1bmN0aW9uKHQpe2lmKFwib2JqZWN0XCIhPXR5cGVvZiB0fHxudWxsPT09dClyZXR1cm5cIm9iamVjdCBleHBlY3RlZFwiO2lmKG51bGwhPXQuaW5wdXQmJnQuaGFzT3duUHJvcGVydHkoXCJpbnB1dFwiKSl7aWYoIUFycmF5LmlzQXJyYXkodC5pbnB1dCkpcmV0dXJuXCJpbnB1dDogYXJyYXkgZXhwZWN0ZWRcIjtmb3IodmFyIGU9MDtlPHQuaW5wdXQubGVuZ3RoOysrZSlpZighYy5pc1N0cmluZyh0LmlucHV0W2VdKSlyZXR1cm5cImlucHV0OiBzdHJpbmdbXSBleHBlY3RlZFwifWlmKG51bGwhPXQub3V0cHV0JiZ0Lmhhc093blByb3BlcnR5KFwib3V0cHV0XCIpKXtpZighQXJyYXkuaXNBcnJheSh0Lm91dHB1dCkpcmV0dXJuXCJvdXRwdXQ6IGFycmF5IGV4cGVjdGVkXCI7Zm9yKGU9MDtlPHQub3V0cHV0Lmxlbmd0aDsrK2UpaWYoIWMuaXNTdHJpbmcodC5vdXRwdXRbZV0pKXJldHVyblwib3V0cHV0OiBzdHJpbmdbXSBleHBlY3RlZFwifWlmKG51bGwhPXQubmFtZSYmdC5oYXNPd25Qcm9wZXJ0eShcIm5hbWVcIikmJiFjLmlzU3RyaW5nKHQubmFtZSkpcmV0dXJuXCJuYW1lOiBzdHJpbmcgZXhwZWN0ZWRcIjtpZihudWxsIT10Lm9wVHlwZSYmdC5oYXNPd25Qcm9wZXJ0eShcIm9wVHlwZVwiKSYmIWMuaXNTdHJpbmcodC5vcFR5cGUpKXJldHVyblwib3BUeXBlOiBzdHJpbmcgZXhwZWN0ZWRcIjtpZihudWxsIT10LmRvbWFpbiYmdC5oYXNPd25Qcm9wZXJ0eShcImRvbWFpblwiKSYmIWMuaXNTdHJpbmcodC5kb21haW4pKXJldHVyblwiZG9tYWluOiBzdHJpbmcgZXhwZWN0ZWRcIjtpZihudWxsIT10LmF0dHJpYnV0ZSYmdC5oYXNPd25Qcm9wZXJ0eShcImF0dHJpYnV0ZVwiKSl7aWYoIUFycmF5LmlzQXJyYXkodC5hdHRyaWJ1dGUpKXJldHVyblwiYXR0cmlidXRlOiBhcnJheSBleHBlY3RlZFwiO2ZvcihlPTA7ZTx0LmF0dHJpYnV0ZS5sZW5ndGg7KytlKXt2YXIgbj1sLm9ubnguQXR0cmlidXRlUHJvdG8udmVyaWZ5KHQuYXR0cmlidXRlW2VdKTtpZihuKXJldHVyblwiYXR0cmlidXRlLlwiK259fXJldHVybiBudWxsIT10LmRvY1N0cmluZyYmdC5oYXNPd25Qcm9wZXJ0eShcImRvY1N0cmluZ1wiKSYmIWMuaXNTdHJpbmcodC5kb2NTdHJpbmcpP1wiZG9jU3RyaW5nOiBzdHJpbmcgZXhwZWN0ZWRcIjpudWxsfSx0LmZyb21PYmplY3Q9ZnVuY3Rpb24odCl7aWYodCBpbnN0YW5jZW9mIGwub25ueC5Ob2RlUHJvdG8pcmV0dXJuIHQ7dmFyIGU9bmV3IGwub25ueC5Ob2RlUHJvdG87aWYodC5pbnB1dCl7aWYoIUFycmF5LmlzQXJyYXkodC5pbnB1dCkpdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguTm9kZVByb3RvLmlucHV0OiBhcnJheSBleHBlY3RlZFwiKTtlLmlucHV0PVtdO2Zvcih2YXIgbj0wO248dC5pbnB1dC5sZW5ndGg7KytuKWUuaW5wdXRbbl09U3RyaW5nKHQuaW5wdXRbbl0pfWlmKHQub3V0cHV0KXtpZighQXJyYXkuaXNBcnJheSh0Lm91dHB1dCkpdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguTm9kZVByb3RvLm91dHB1dDogYXJyYXkgZXhwZWN0ZWRcIik7Zm9yKGUub3V0cHV0PVtdLG49MDtuPHQub3V0cHV0Lmxlbmd0aDsrK24pZS5vdXRwdXRbbl09U3RyaW5nKHQub3V0cHV0W25dKX1pZihudWxsIT10Lm5hbWUmJihlLm5hbWU9U3RyaW5nKHQubmFtZSkpLG51bGwhPXQub3BUeXBlJiYoZS5vcFR5cGU9U3RyaW5nKHQub3BUeXBlKSksbnVsbCE9dC5kb21haW4mJihlLmRvbWFpbj1TdHJpbmcodC5kb21haW4pKSx0LmF0dHJpYnV0ZSl7aWYoIUFycmF5LmlzQXJyYXkodC5hdHRyaWJ1dGUpKXRocm93IFR5cGVFcnJvcihcIi5vbm54Lk5vZGVQcm90by5hdHRyaWJ1dGU6IGFycmF5IGV4cGVjdGVkXCIpO2ZvcihlLmF0dHJpYnV0ZT1bXSxuPTA7bjx0LmF0dHJpYnV0ZS5sZW5ndGg7KytuKXtpZihcIm9iamVjdFwiIT10eXBlb2YgdC5hdHRyaWJ1dGVbbl0pdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguTm9kZVByb3RvLmF0dHJpYnV0ZTogb2JqZWN0IGV4cGVjdGVkXCIpO2UuYXR0cmlidXRlW25dPWwub25ueC5BdHRyaWJ1dGVQcm90by5mcm9tT2JqZWN0KHQuYXR0cmlidXRlW25dKX19cmV0dXJuIG51bGwhPXQuZG9jU3RyaW5nJiYoZS5kb2NTdHJpbmc9U3RyaW5nKHQuZG9jU3RyaW5nKSksZX0sdC50b09iamVjdD1mdW5jdGlvbih0LGUpe2V8fChlPXt9KTt2YXIgbj17fTtpZigoZS5hcnJheXN8fGUuZGVmYXVsdHMpJiYobi5pbnB1dD1bXSxuLm91dHB1dD1bXSxuLmF0dHJpYnV0ZT1bXSksZS5kZWZhdWx0cyYmKG4ubmFtZT1cIlwiLG4ub3BUeXBlPVwiXCIsbi5kb2NTdHJpbmc9XCJcIixuLmRvbWFpbj1cIlwiKSx0LmlucHV0JiZ0LmlucHV0Lmxlbmd0aCl7bi5pbnB1dD1bXTtmb3IodmFyIHI9MDtyPHQuaW5wdXQubGVuZ3RoOysrciluLmlucHV0W3JdPXQuaW5wdXRbcl19aWYodC5vdXRwdXQmJnQub3V0cHV0Lmxlbmd0aClmb3Iobi5vdXRwdXQ9W10scj0wO3I8dC5vdXRwdXQubGVuZ3RoOysrciluLm91dHB1dFtyXT10Lm91dHB1dFtyXTtpZihudWxsIT10Lm5hbWUmJnQuaGFzT3duUHJvcGVydHkoXCJuYW1lXCIpJiYobi5uYW1lPXQubmFtZSksbnVsbCE9dC5vcFR5cGUmJnQuaGFzT3duUHJvcGVydHkoXCJvcFR5cGVcIikmJihuLm9wVHlwZT10Lm9wVHlwZSksdC5hdHRyaWJ1dGUmJnQuYXR0cmlidXRlLmxlbmd0aClmb3Iobi5hdHRyaWJ1dGU9W10scj0wO3I8dC5hdHRyaWJ1dGUubGVuZ3RoOysrciluLmF0dHJpYnV0ZVtyXT1sLm9ubnguQXR0cmlidXRlUHJvdG8udG9PYmplY3QodC5hdHRyaWJ1dGVbcl0sZSk7cmV0dXJuIG51bGwhPXQuZG9jU3RyaW5nJiZ0Lmhhc093blByb3BlcnR5KFwiZG9jU3RyaW5nXCIpJiYobi5kb2NTdHJpbmc9dC5kb2NTdHJpbmcpLG51bGwhPXQuZG9tYWluJiZ0Lmhhc093blByb3BlcnR5KFwiZG9tYWluXCIpJiYobi5kb21haW49dC5kb21haW4pLG59LHQucHJvdG90eXBlLnRvSlNPTj1mdW5jdGlvbigpe3JldHVybiB0aGlzLmNvbnN0cnVjdG9yLnRvT2JqZWN0KHRoaXMsYS51dGlsLnRvSlNPTk9wdGlvbnMpfSx0fSgpLG8uTW9kZWxQcm90bz1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCl7aWYodGhpcy5vcHNldEltcG9ydD1bXSx0aGlzLm1ldGFkYXRhUHJvcHM9W10sdClmb3IodmFyIGU9T2JqZWN0LmtleXModCksbj0wO248ZS5sZW5ndGg7KytuKW51bGwhPXRbZVtuXV0mJih0aGlzW2Vbbl1dPXRbZVtuXV0pfXJldHVybiB0LnByb3RvdHlwZS5pclZlcnNpb249Yy5Mb25nP2MuTG9uZy5mcm9tQml0cygwLDAsITEpOjAsdC5wcm90b3R5cGUub3BzZXRJbXBvcnQ9Yy5lbXB0eUFycmF5LHQucHJvdG90eXBlLnByb2R1Y2VyTmFtZT1cIlwiLHQucHJvdG90eXBlLnByb2R1Y2VyVmVyc2lvbj1cIlwiLHQucHJvdG90eXBlLmRvbWFpbj1cIlwiLHQucHJvdG90eXBlLm1vZGVsVmVyc2lvbj1jLkxvbmc/Yy5Mb25nLmZyb21CaXRzKDAsMCwhMSk6MCx0LnByb3RvdHlwZS5kb2NTdHJpbmc9XCJcIix0LnByb3RvdHlwZS5ncmFwaD1udWxsLHQucHJvdG90eXBlLm1ldGFkYXRhUHJvcHM9Yy5lbXB0eUFycmF5LHQuY3JlYXRlPWZ1bmN0aW9uKGUpe3JldHVybiBuZXcgdChlKX0sdC5lbmNvZGU9ZnVuY3Rpb24odCxlKXtpZihlfHwoZT11LmNyZWF0ZSgpKSxudWxsIT10LmlyVmVyc2lvbiYmdC5oYXNPd25Qcm9wZXJ0eShcImlyVmVyc2lvblwiKSYmZS51aW50MzIoOCkuaW50NjQodC5pclZlcnNpb24pLG51bGwhPXQucHJvZHVjZXJOYW1lJiZ0Lmhhc093blByb3BlcnR5KFwicHJvZHVjZXJOYW1lXCIpJiZlLnVpbnQzMigxOCkuc3RyaW5nKHQucHJvZHVjZXJOYW1lKSxudWxsIT10LnByb2R1Y2VyVmVyc2lvbiYmdC5oYXNPd25Qcm9wZXJ0eShcInByb2R1Y2VyVmVyc2lvblwiKSYmZS51aW50MzIoMjYpLnN0cmluZyh0LnByb2R1Y2VyVmVyc2lvbiksbnVsbCE9dC5kb21haW4mJnQuaGFzT3duUHJvcGVydHkoXCJkb21haW5cIikmJmUudWludDMyKDM0KS5zdHJpbmcodC5kb21haW4pLG51bGwhPXQubW9kZWxWZXJzaW9uJiZ0Lmhhc093blByb3BlcnR5KFwibW9kZWxWZXJzaW9uXCIpJiZlLnVpbnQzMig0MCkuaW50NjQodC5tb2RlbFZlcnNpb24pLG51bGwhPXQuZG9jU3RyaW5nJiZ0Lmhhc093blByb3BlcnR5KFwiZG9jU3RyaW5nXCIpJiZlLnVpbnQzMig1MCkuc3RyaW5nKHQuZG9jU3RyaW5nKSxudWxsIT10LmdyYXBoJiZ0Lmhhc093blByb3BlcnR5KFwiZ3JhcGhcIikmJmwub25ueC5HcmFwaFByb3RvLmVuY29kZSh0LmdyYXBoLGUudWludDMyKDU4KS5mb3JrKCkpLmxkZWxpbSgpLG51bGwhPXQub3BzZXRJbXBvcnQmJnQub3BzZXRJbXBvcnQubGVuZ3RoKWZvcih2YXIgbj0wO248dC5vcHNldEltcG9ydC5sZW5ndGg7KytuKWwub25ueC5PcGVyYXRvclNldElkUHJvdG8uZW5jb2RlKHQub3BzZXRJbXBvcnRbbl0sZS51aW50MzIoNjYpLmZvcmsoKSkubGRlbGltKCk7aWYobnVsbCE9dC5tZXRhZGF0YVByb3BzJiZ0Lm1ldGFkYXRhUHJvcHMubGVuZ3RoKWZvcihuPTA7bjx0Lm1ldGFkYXRhUHJvcHMubGVuZ3RoOysrbilsLm9ubnguU3RyaW5nU3RyaW5nRW50cnlQcm90by5lbmNvZGUodC5tZXRhZGF0YVByb3BzW25dLGUudWludDMyKDExNCkuZm9yaygpKS5sZGVsaW0oKTtyZXR1cm4gZX0sdC5lbmNvZGVEZWxpbWl0ZWQ9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5lbmNvZGUodCxlKS5sZGVsaW0oKX0sdC5kZWNvZGU9ZnVuY3Rpb24odCxlKXt0IGluc3RhbmNlb2Ygc3x8KHQ9cy5jcmVhdGUodCkpO2Zvcih2YXIgbj12b2lkIDA9PT1lP3QubGVuOnQucG9zK2Uscj1uZXcgbC5vbm54Lk1vZGVsUHJvdG87dC5wb3M8bjspe3ZhciBpPXQudWludDMyKCk7c3dpdGNoKGk+Pj4zKXtjYXNlIDE6ci5pclZlcnNpb249dC5pbnQ2NCgpO2JyZWFrO2Nhc2UgODpyLm9wc2V0SW1wb3J0JiZyLm9wc2V0SW1wb3J0Lmxlbmd0aHx8KHIub3BzZXRJbXBvcnQ9W10pLHIub3BzZXRJbXBvcnQucHVzaChsLm9ubnguT3BlcmF0b3JTZXRJZFByb3RvLmRlY29kZSh0LHQudWludDMyKCkpKTticmVhaztjYXNlIDI6ci5wcm9kdWNlck5hbWU9dC5zdHJpbmcoKTticmVhaztjYXNlIDM6ci5wcm9kdWNlclZlcnNpb249dC5zdHJpbmcoKTticmVhaztjYXNlIDQ6ci5kb21haW49dC5zdHJpbmcoKTticmVhaztjYXNlIDU6ci5tb2RlbFZlcnNpb249dC5pbnQ2NCgpO2JyZWFrO2Nhc2UgNjpyLmRvY1N0cmluZz10LnN0cmluZygpO2JyZWFrO2Nhc2UgNzpyLmdyYXBoPWwub25ueC5HcmFwaFByb3RvLmRlY29kZSh0LHQudWludDMyKCkpO2JyZWFrO2Nhc2UgMTQ6ci5tZXRhZGF0YVByb3BzJiZyLm1ldGFkYXRhUHJvcHMubGVuZ3RofHwoci5tZXRhZGF0YVByb3BzPVtdKSxyLm1ldGFkYXRhUHJvcHMucHVzaChsLm9ubnguU3RyaW5nU3RyaW5nRW50cnlQcm90by5kZWNvZGUodCx0LnVpbnQzMigpKSk7YnJlYWs7ZGVmYXVsdDp0LnNraXBUeXBlKDcmaSl9fXJldHVybiByfSx0LmRlY29kZURlbGltaXRlZD1mdW5jdGlvbih0KXtyZXR1cm4gdCBpbnN0YW5jZW9mIHN8fCh0PW5ldyBzKHQpKSx0aGlzLmRlY29kZSh0LHQudWludDMyKCkpfSx0LnZlcmlmeT1mdW5jdGlvbih0KXtpZihcIm9iamVjdFwiIT10eXBlb2YgdHx8bnVsbD09PXQpcmV0dXJuXCJvYmplY3QgZXhwZWN0ZWRcIjtpZihudWxsIT10LmlyVmVyc2lvbiYmdC5oYXNPd25Qcm9wZXJ0eShcImlyVmVyc2lvblwiKSYmIShjLmlzSW50ZWdlcih0LmlyVmVyc2lvbil8fHQuaXJWZXJzaW9uJiZjLmlzSW50ZWdlcih0LmlyVmVyc2lvbi5sb3cpJiZjLmlzSW50ZWdlcih0LmlyVmVyc2lvbi5oaWdoKSkpcmV0dXJuXCJpclZlcnNpb246IGludGVnZXJ8TG9uZyBleHBlY3RlZFwiO2lmKG51bGwhPXQub3BzZXRJbXBvcnQmJnQuaGFzT3duUHJvcGVydHkoXCJvcHNldEltcG9ydFwiKSl7aWYoIUFycmF5LmlzQXJyYXkodC5vcHNldEltcG9ydCkpcmV0dXJuXCJvcHNldEltcG9ydDogYXJyYXkgZXhwZWN0ZWRcIjtmb3IodmFyIGU9MDtlPHQub3BzZXRJbXBvcnQubGVuZ3RoOysrZSlpZihuPWwub25ueC5PcGVyYXRvclNldElkUHJvdG8udmVyaWZ5KHQub3BzZXRJbXBvcnRbZV0pKXJldHVyblwib3BzZXRJbXBvcnQuXCIrbn1pZihudWxsIT10LnByb2R1Y2VyTmFtZSYmdC5oYXNPd25Qcm9wZXJ0eShcInByb2R1Y2VyTmFtZVwiKSYmIWMuaXNTdHJpbmcodC5wcm9kdWNlck5hbWUpKXJldHVyblwicHJvZHVjZXJOYW1lOiBzdHJpbmcgZXhwZWN0ZWRcIjtpZihudWxsIT10LnByb2R1Y2VyVmVyc2lvbiYmdC5oYXNPd25Qcm9wZXJ0eShcInByb2R1Y2VyVmVyc2lvblwiKSYmIWMuaXNTdHJpbmcodC5wcm9kdWNlclZlcnNpb24pKXJldHVyblwicHJvZHVjZXJWZXJzaW9uOiBzdHJpbmcgZXhwZWN0ZWRcIjtpZihudWxsIT10LmRvbWFpbiYmdC5oYXNPd25Qcm9wZXJ0eShcImRvbWFpblwiKSYmIWMuaXNTdHJpbmcodC5kb21haW4pKXJldHVyblwiZG9tYWluOiBzdHJpbmcgZXhwZWN0ZWRcIjtpZihudWxsIT10Lm1vZGVsVmVyc2lvbiYmdC5oYXNPd25Qcm9wZXJ0eShcIm1vZGVsVmVyc2lvblwiKSYmIShjLmlzSW50ZWdlcih0Lm1vZGVsVmVyc2lvbil8fHQubW9kZWxWZXJzaW9uJiZjLmlzSW50ZWdlcih0Lm1vZGVsVmVyc2lvbi5sb3cpJiZjLmlzSW50ZWdlcih0Lm1vZGVsVmVyc2lvbi5oaWdoKSkpcmV0dXJuXCJtb2RlbFZlcnNpb246IGludGVnZXJ8TG9uZyBleHBlY3RlZFwiO2lmKG51bGwhPXQuZG9jU3RyaW5nJiZ0Lmhhc093blByb3BlcnR5KFwiZG9jU3RyaW5nXCIpJiYhYy5pc1N0cmluZyh0LmRvY1N0cmluZykpcmV0dXJuXCJkb2NTdHJpbmc6IHN0cmluZyBleHBlY3RlZFwiO2lmKG51bGwhPXQuZ3JhcGgmJnQuaGFzT3duUHJvcGVydHkoXCJncmFwaFwiKSYmKG49bC5vbm54LkdyYXBoUHJvdG8udmVyaWZ5KHQuZ3JhcGgpKSlyZXR1cm5cImdyYXBoLlwiK247aWYobnVsbCE9dC5tZXRhZGF0YVByb3BzJiZ0Lmhhc093blByb3BlcnR5KFwibWV0YWRhdGFQcm9wc1wiKSl7aWYoIUFycmF5LmlzQXJyYXkodC5tZXRhZGF0YVByb3BzKSlyZXR1cm5cIm1ldGFkYXRhUHJvcHM6IGFycmF5IGV4cGVjdGVkXCI7Zm9yKGU9MDtlPHQubWV0YWRhdGFQcm9wcy5sZW5ndGg7KytlKXt2YXIgbjtpZihuPWwub25ueC5TdHJpbmdTdHJpbmdFbnRyeVByb3RvLnZlcmlmeSh0Lm1ldGFkYXRhUHJvcHNbZV0pKXJldHVyblwibWV0YWRhdGFQcm9wcy5cIitufX1yZXR1cm4gbnVsbH0sdC5mcm9tT2JqZWN0PWZ1bmN0aW9uKHQpe2lmKHQgaW5zdGFuY2VvZiBsLm9ubnguTW9kZWxQcm90bylyZXR1cm4gdDt2YXIgZT1uZXcgbC5vbm54Lk1vZGVsUHJvdG87aWYobnVsbCE9dC5pclZlcnNpb24mJihjLkxvbmc/KGUuaXJWZXJzaW9uPWMuTG9uZy5mcm9tVmFsdWUodC5pclZlcnNpb24pKS51bnNpZ25lZD0hMTpcInN0cmluZ1wiPT10eXBlb2YgdC5pclZlcnNpb24/ZS5pclZlcnNpb249cGFyc2VJbnQodC5pclZlcnNpb24sMTApOlwibnVtYmVyXCI9PXR5cGVvZiB0LmlyVmVyc2lvbj9lLmlyVmVyc2lvbj10LmlyVmVyc2lvbjpcIm9iamVjdFwiPT10eXBlb2YgdC5pclZlcnNpb24mJihlLmlyVmVyc2lvbj1uZXcgYy5Mb25nQml0cyh0LmlyVmVyc2lvbi5sb3c+Pj4wLHQuaXJWZXJzaW9uLmhpZ2g+Pj4wKS50b051bWJlcigpKSksdC5vcHNldEltcG9ydCl7aWYoIUFycmF5LmlzQXJyYXkodC5vcHNldEltcG9ydCkpdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguTW9kZWxQcm90by5vcHNldEltcG9ydDogYXJyYXkgZXhwZWN0ZWRcIik7ZS5vcHNldEltcG9ydD1bXTtmb3IodmFyIG49MDtuPHQub3BzZXRJbXBvcnQubGVuZ3RoOysrbil7aWYoXCJvYmplY3RcIiE9dHlwZW9mIHQub3BzZXRJbXBvcnRbbl0pdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguTW9kZWxQcm90by5vcHNldEltcG9ydDogb2JqZWN0IGV4cGVjdGVkXCIpO2Uub3BzZXRJbXBvcnRbbl09bC5vbm54Lk9wZXJhdG9yU2V0SWRQcm90by5mcm9tT2JqZWN0KHQub3BzZXRJbXBvcnRbbl0pfX1pZihudWxsIT10LnByb2R1Y2VyTmFtZSYmKGUucHJvZHVjZXJOYW1lPVN0cmluZyh0LnByb2R1Y2VyTmFtZSkpLG51bGwhPXQucHJvZHVjZXJWZXJzaW9uJiYoZS5wcm9kdWNlclZlcnNpb249U3RyaW5nKHQucHJvZHVjZXJWZXJzaW9uKSksbnVsbCE9dC5kb21haW4mJihlLmRvbWFpbj1TdHJpbmcodC5kb21haW4pKSxudWxsIT10Lm1vZGVsVmVyc2lvbiYmKGMuTG9uZz8oZS5tb2RlbFZlcnNpb249Yy5Mb25nLmZyb21WYWx1ZSh0Lm1vZGVsVmVyc2lvbikpLnVuc2lnbmVkPSExOlwic3RyaW5nXCI9PXR5cGVvZiB0Lm1vZGVsVmVyc2lvbj9lLm1vZGVsVmVyc2lvbj1wYXJzZUludCh0Lm1vZGVsVmVyc2lvbiwxMCk6XCJudW1iZXJcIj09dHlwZW9mIHQubW9kZWxWZXJzaW9uP2UubW9kZWxWZXJzaW9uPXQubW9kZWxWZXJzaW9uOlwib2JqZWN0XCI9PXR5cGVvZiB0Lm1vZGVsVmVyc2lvbiYmKGUubW9kZWxWZXJzaW9uPW5ldyBjLkxvbmdCaXRzKHQubW9kZWxWZXJzaW9uLmxvdz4+PjAsdC5tb2RlbFZlcnNpb24uaGlnaD4+PjApLnRvTnVtYmVyKCkpKSxudWxsIT10LmRvY1N0cmluZyYmKGUuZG9jU3RyaW5nPVN0cmluZyh0LmRvY1N0cmluZykpLG51bGwhPXQuZ3JhcGgpe2lmKFwib2JqZWN0XCIhPXR5cGVvZiB0LmdyYXBoKXRocm93IFR5cGVFcnJvcihcIi5vbm54Lk1vZGVsUHJvdG8uZ3JhcGg6IG9iamVjdCBleHBlY3RlZFwiKTtlLmdyYXBoPWwub25ueC5HcmFwaFByb3RvLmZyb21PYmplY3QodC5ncmFwaCl9aWYodC5tZXRhZGF0YVByb3BzKXtpZighQXJyYXkuaXNBcnJheSh0Lm1ldGFkYXRhUHJvcHMpKXRocm93IFR5cGVFcnJvcihcIi5vbm54Lk1vZGVsUHJvdG8ubWV0YWRhdGFQcm9wczogYXJyYXkgZXhwZWN0ZWRcIik7Zm9yKGUubWV0YWRhdGFQcm9wcz1bXSxuPTA7bjx0Lm1ldGFkYXRhUHJvcHMubGVuZ3RoOysrbil7aWYoXCJvYmplY3RcIiE9dHlwZW9mIHQubWV0YWRhdGFQcm9wc1tuXSl0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5Nb2RlbFByb3RvLm1ldGFkYXRhUHJvcHM6IG9iamVjdCBleHBlY3RlZFwiKTtlLm1ldGFkYXRhUHJvcHNbbl09bC5vbm54LlN0cmluZ1N0cmluZ0VudHJ5UHJvdG8uZnJvbU9iamVjdCh0Lm1ldGFkYXRhUHJvcHNbbl0pfX1yZXR1cm4gZX0sdC50b09iamVjdD1mdW5jdGlvbih0LGUpe2V8fChlPXt9KTt2YXIgbj17fTtpZigoZS5hcnJheXN8fGUuZGVmYXVsdHMpJiYobi5vcHNldEltcG9ydD1bXSxuLm1ldGFkYXRhUHJvcHM9W10pLGUuZGVmYXVsdHMpe2lmKGMuTG9uZyl7dmFyIHI9bmV3IGMuTG9uZygwLDAsITEpO24uaXJWZXJzaW9uPWUubG9uZ3M9PT1TdHJpbmc/ci50b1N0cmluZygpOmUubG9uZ3M9PT1OdW1iZXI/ci50b051bWJlcigpOnJ9ZWxzZSBuLmlyVmVyc2lvbj1lLmxvbmdzPT09U3RyaW5nP1wiMFwiOjA7bi5wcm9kdWNlck5hbWU9XCJcIixuLnByb2R1Y2VyVmVyc2lvbj1cIlwiLG4uZG9tYWluPVwiXCIsYy5Mb25nPyhyPW5ldyBjLkxvbmcoMCwwLCExKSxuLm1vZGVsVmVyc2lvbj1lLmxvbmdzPT09U3RyaW5nP3IudG9TdHJpbmcoKTplLmxvbmdzPT09TnVtYmVyP3IudG9OdW1iZXIoKTpyKTpuLm1vZGVsVmVyc2lvbj1lLmxvbmdzPT09U3RyaW5nP1wiMFwiOjAsbi5kb2NTdHJpbmc9XCJcIixuLmdyYXBoPW51bGx9aWYobnVsbCE9dC5pclZlcnNpb24mJnQuaGFzT3duUHJvcGVydHkoXCJpclZlcnNpb25cIikmJihcIm51bWJlclwiPT10eXBlb2YgdC5pclZlcnNpb24/bi5pclZlcnNpb249ZS5sb25ncz09PVN0cmluZz9TdHJpbmcodC5pclZlcnNpb24pOnQuaXJWZXJzaW9uOm4uaXJWZXJzaW9uPWUubG9uZ3M9PT1TdHJpbmc/Yy5Mb25nLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHQuaXJWZXJzaW9uKTplLmxvbmdzPT09TnVtYmVyP25ldyBjLkxvbmdCaXRzKHQuaXJWZXJzaW9uLmxvdz4+PjAsdC5pclZlcnNpb24uaGlnaD4+PjApLnRvTnVtYmVyKCk6dC5pclZlcnNpb24pLG51bGwhPXQucHJvZHVjZXJOYW1lJiZ0Lmhhc093blByb3BlcnR5KFwicHJvZHVjZXJOYW1lXCIpJiYobi5wcm9kdWNlck5hbWU9dC5wcm9kdWNlck5hbWUpLG51bGwhPXQucHJvZHVjZXJWZXJzaW9uJiZ0Lmhhc093blByb3BlcnR5KFwicHJvZHVjZXJWZXJzaW9uXCIpJiYobi5wcm9kdWNlclZlcnNpb249dC5wcm9kdWNlclZlcnNpb24pLG51bGwhPXQuZG9tYWluJiZ0Lmhhc093blByb3BlcnR5KFwiZG9tYWluXCIpJiYobi5kb21haW49dC5kb21haW4pLG51bGwhPXQubW9kZWxWZXJzaW9uJiZ0Lmhhc093blByb3BlcnR5KFwibW9kZWxWZXJzaW9uXCIpJiYoXCJudW1iZXJcIj09dHlwZW9mIHQubW9kZWxWZXJzaW9uP24ubW9kZWxWZXJzaW9uPWUubG9uZ3M9PT1TdHJpbmc/U3RyaW5nKHQubW9kZWxWZXJzaW9uKTp0Lm1vZGVsVmVyc2lvbjpuLm1vZGVsVmVyc2lvbj1lLmxvbmdzPT09U3RyaW5nP2MuTG9uZy5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0Lm1vZGVsVmVyc2lvbik6ZS5sb25ncz09PU51bWJlcj9uZXcgYy5Mb25nQml0cyh0Lm1vZGVsVmVyc2lvbi5sb3c+Pj4wLHQubW9kZWxWZXJzaW9uLmhpZ2g+Pj4wKS50b051bWJlcigpOnQubW9kZWxWZXJzaW9uKSxudWxsIT10LmRvY1N0cmluZyYmdC5oYXNPd25Qcm9wZXJ0eShcImRvY1N0cmluZ1wiKSYmKG4uZG9jU3RyaW5nPXQuZG9jU3RyaW5nKSxudWxsIT10LmdyYXBoJiZ0Lmhhc093blByb3BlcnR5KFwiZ3JhcGhcIikmJihuLmdyYXBoPWwub25ueC5HcmFwaFByb3RvLnRvT2JqZWN0KHQuZ3JhcGgsZSkpLHQub3BzZXRJbXBvcnQmJnQub3BzZXRJbXBvcnQubGVuZ3RoKXtuLm9wc2V0SW1wb3J0PVtdO2Zvcih2YXIgaT0wO2k8dC5vcHNldEltcG9ydC5sZW5ndGg7KytpKW4ub3BzZXRJbXBvcnRbaV09bC5vbm54Lk9wZXJhdG9yU2V0SWRQcm90by50b09iamVjdCh0Lm9wc2V0SW1wb3J0W2ldLGUpfWlmKHQubWV0YWRhdGFQcm9wcyYmdC5tZXRhZGF0YVByb3BzLmxlbmd0aClmb3Iobi5tZXRhZGF0YVByb3BzPVtdLGk9MDtpPHQubWV0YWRhdGFQcm9wcy5sZW5ndGg7KytpKW4ubWV0YWRhdGFQcm9wc1tpXT1sLm9ubnguU3RyaW5nU3RyaW5nRW50cnlQcm90by50b09iamVjdCh0Lm1ldGFkYXRhUHJvcHNbaV0sZSk7cmV0dXJuIG59LHQucHJvdG90eXBlLnRvSlNPTj1mdW5jdGlvbigpe3JldHVybiB0aGlzLmNvbnN0cnVjdG9yLnRvT2JqZWN0KHRoaXMsYS51dGlsLnRvSlNPTk9wdGlvbnMpfSx0fSgpLG8uU3RyaW5nU3RyaW5nRW50cnlQcm90bz1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCl7aWYodClmb3IodmFyIGU9T2JqZWN0LmtleXModCksbj0wO248ZS5sZW5ndGg7KytuKW51bGwhPXRbZVtuXV0mJih0aGlzW2Vbbl1dPXRbZVtuXV0pfXJldHVybiB0LnByb3RvdHlwZS5rZXk9XCJcIix0LnByb3RvdHlwZS52YWx1ZT1cIlwiLHQuY3JlYXRlPWZ1bmN0aW9uKGUpe3JldHVybiBuZXcgdChlKX0sdC5lbmNvZGU9ZnVuY3Rpb24odCxlKXtyZXR1cm4gZXx8KGU9dS5jcmVhdGUoKSksbnVsbCE9dC5rZXkmJnQuaGFzT3duUHJvcGVydHkoXCJrZXlcIikmJmUudWludDMyKDEwKS5zdHJpbmcodC5rZXkpLG51bGwhPXQudmFsdWUmJnQuaGFzT3duUHJvcGVydHkoXCJ2YWx1ZVwiKSYmZS51aW50MzIoMTgpLnN0cmluZyh0LnZhbHVlKSxlfSx0LmVuY29kZURlbGltaXRlZD1mdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLmVuY29kZSh0LGUpLmxkZWxpbSgpfSx0LmRlY29kZT1mdW5jdGlvbih0LGUpe3QgaW5zdGFuY2VvZiBzfHwodD1zLmNyZWF0ZSh0KSk7Zm9yKHZhciBuPXZvaWQgMD09PWU/dC5sZW46dC5wb3MrZSxyPW5ldyBsLm9ubnguU3RyaW5nU3RyaW5nRW50cnlQcm90bzt0LnBvczxuOyl7dmFyIGk9dC51aW50MzIoKTtzd2l0Y2goaT4+PjMpe2Nhc2UgMTpyLmtleT10LnN0cmluZygpO2JyZWFrO2Nhc2UgMjpyLnZhbHVlPXQuc3RyaW5nKCk7YnJlYWs7ZGVmYXVsdDp0LnNraXBUeXBlKDcmaSl9fXJldHVybiByfSx0LmRlY29kZURlbGltaXRlZD1mdW5jdGlvbih0KXtyZXR1cm4gdCBpbnN0YW5jZW9mIHN8fCh0PW5ldyBzKHQpKSx0aGlzLmRlY29kZSh0LHQudWludDMyKCkpfSx0LnZlcmlmeT1mdW5jdGlvbih0KXtyZXR1cm5cIm9iamVjdFwiIT10eXBlb2YgdHx8bnVsbD09PXQ/XCJvYmplY3QgZXhwZWN0ZWRcIjpudWxsIT10LmtleSYmdC5oYXNPd25Qcm9wZXJ0eShcImtleVwiKSYmIWMuaXNTdHJpbmcodC5rZXkpP1wia2V5OiBzdHJpbmcgZXhwZWN0ZWRcIjpudWxsIT10LnZhbHVlJiZ0Lmhhc093blByb3BlcnR5KFwidmFsdWVcIikmJiFjLmlzU3RyaW5nKHQudmFsdWUpP1widmFsdWU6IHN0cmluZyBleHBlY3RlZFwiOm51bGx9LHQuZnJvbU9iamVjdD1mdW5jdGlvbih0KXtpZih0IGluc3RhbmNlb2YgbC5vbm54LlN0cmluZ1N0cmluZ0VudHJ5UHJvdG8pcmV0dXJuIHQ7dmFyIGU9bmV3IGwub25ueC5TdHJpbmdTdHJpbmdFbnRyeVByb3RvO3JldHVybiBudWxsIT10LmtleSYmKGUua2V5PVN0cmluZyh0LmtleSkpLG51bGwhPXQudmFsdWUmJihlLnZhbHVlPVN0cmluZyh0LnZhbHVlKSksZX0sdC50b09iamVjdD1mdW5jdGlvbih0LGUpe2V8fChlPXt9KTt2YXIgbj17fTtyZXR1cm4gZS5kZWZhdWx0cyYmKG4ua2V5PVwiXCIsbi52YWx1ZT1cIlwiKSxudWxsIT10LmtleSYmdC5oYXNPd25Qcm9wZXJ0eShcImtleVwiKSYmKG4ua2V5PXQua2V5KSxudWxsIT10LnZhbHVlJiZ0Lmhhc093blByb3BlcnR5KFwidmFsdWVcIikmJihuLnZhbHVlPXQudmFsdWUpLG59LHQucHJvdG90eXBlLnRvSlNPTj1mdW5jdGlvbigpe3JldHVybiB0aGlzLmNvbnN0cnVjdG9yLnRvT2JqZWN0KHRoaXMsYS51dGlsLnRvSlNPTk9wdGlvbnMpfSx0fSgpLG8uVGVuc29yQW5ub3RhdGlvbj1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCl7aWYodGhpcy5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzPVtdLHQpZm9yKHZhciBlPU9iamVjdC5rZXlzKHQpLG49MDtuPGUubGVuZ3RoOysrbiludWxsIT10W2Vbbl1dJiYodGhpc1tlW25dXT10W2Vbbl1dKX1yZXR1cm4gdC5wcm90b3R5cGUudGVuc29yTmFtZT1cIlwiLHQucHJvdG90eXBlLnF1YW50UGFyYW1ldGVyVGVuc29yTmFtZXM9Yy5lbXB0eUFycmF5LHQuY3JlYXRlPWZ1bmN0aW9uKGUpe3JldHVybiBuZXcgdChlKX0sdC5lbmNvZGU9ZnVuY3Rpb24odCxlKXtpZihlfHwoZT11LmNyZWF0ZSgpKSxudWxsIT10LnRlbnNvck5hbWUmJnQuaGFzT3duUHJvcGVydHkoXCJ0ZW5zb3JOYW1lXCIpJiZlLnVpbnQzMigxMCkuc3RyaW5nKHQudGVuc29yTmFtZSksbnVsbCE9dC5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzJiZ0LnF1YW50UGFyYW1ldGVyVGVuc29yTmFtZXMubGVuZ3RoKWZvcih2YXIgbj0wO248dC5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzLmxlbmd0aDsrK24pbC5vbm54LlN0cmluZ1N0cmluZ0VudHJ5UHJvdG8uZW5jb2RlKHQucXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lc1tuXSxlLnVpbnQzMigxOCkuZm9yaygpKS5sZGVsaW0oKTtyZXR1cm4gZX0sdC5lbmNvZGVEZWxpbWl0ZWQ9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5lbmNvZGUodCxlKS5sZGVsaW0oKX0sdC5kZWNvZGU9ZnVuY3Rpb24odCxlKXt0IGluc3RhbmNlb2Ygc3x8KHQ9cy5jcmVhdGUodCkpO2Zvcih2YXIgbj12b2lkIDA9PT1lP3QubGVuOnQucG9zK2Uscj1uZXcgbC5vbm54LlRlbnNvckFubm90YXRpb247dC5wb3M8bjspe3ZhciBpPXQudWludDMyKCk7c3dpdGNoKGk+Pj4zKXtjYXNlIDE6ci50ZW5zb3JOYW1lPXQuc3RyaW5nKCk7YnJlYWs7Y2FzZSAyOnIucXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lcyYmci5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzLmxlbmd0aHx8KHIucXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lcz1bXSksci5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzLnB1c2gobC5vbm54LlN0cmluZ1N0cmluZ0VudHJ5UHJvdG8uZGVjb2RlKHQsdC51aW50MzIoKSkpO2JyZWFrO2RlZmF1bHQ6dC5za2lwVHlwZSg3JmkpfX1yZXR1cm4gcn0sdC5kZWNvZGVEZWxpbWl0ZWQ9ZnVuY3Rpb24odCl7cmV0dXJuIHQgaW5zdGFuY2VvZiBzfHwodD1uZXcgcyh0KSksdGhpcy5kZWNvZGUodCx0LnVpbnQzMigpKX0sdC52ZXJpZnk9ZnVuY3Rpb24odCl7aWYoXCJvYmplY3RcIiE9dHlwZW9mIHR8fG51bGw9PT10KXJldHVyblwib2JqZWN0IGV4cGVjdGVkXCI7aWYobnVsbCE9dC50ZW5zb3JOYW1lJiZ0Lmhhc093blByb3BlcnR5KFwidGVuc29yTmFtZVwiKSYmIWMuaXNTdHJpbmcodC50ZW5zb3JOYW1lKSlyZXR1cm5cInRlbnNvck5hbWU6IHN0cmluZyBleHBlY3RlZFwiO2lmKG51bGwhPXQucXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lcyYmdC5oYXNPd25Qcm9wZXJ0eShcInF1YW50UGFyYW1ldGVyVGVuc29yTmFtZXNcIikpe2lmKCFBcnJheS5pc0FycmF5KHQucXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lcykpcmV0dXJuXCJxdWFudFBhcmFtZXRlclRlbnNvck5hbWVzOiBhcnJheSBleHBlY3RlZFwiO2Zvcih2YXIgZT0wO2U8dC5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzLmxlbmd0aDsrK2Upe3ZhciBuPWwub25ueC5TdHJpbmdTdHJpbmdFbnRyeVByb3RvLnZlcmlmeSh0LnF1YW50UGFyYW1ldGVyVGVuc29yTmFtZXNbZV0pO2lmKG4pcmV0dXJuXCJxdWFudFBhcmFtZXRlclRlbnNvck5hbWVzLlwiK259fXJldHVybiBudWxsfSx0LmZyb21PYmplY3Q9ZnVuY3Rpb24odCl7aWYodCBpbnN0YW5jZW9mIGwub25ueC5UZW5zb3JBbm5vdGF0aW9uKXJldHVybiB0O3ZhciBlPW5ldyBsLm9ubnguVGVuc29yQW5ub3RhdGlvbjtpZihudWxsIT10LnRlbnNvck5hbWUmJihlLnRlbnNvck5hbWU9U3RyaW5nKHQudGVuc29yTmFtZSkpLHQucXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lcyl7aWYoIUFycmF5LmlzQXJyYXkodC5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzKSl0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5UZW5zb3JBbm5vdGF0aW9uLnF1YW50UGFyYW1ldGVyVGVuc29yTmFtZXM6IGFycmF5IGV4cGVjdGVkXCIpO2UucXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lcz1bXTtmb3IodmFyIG49MDtuPHQucXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lcy5sZW5ndGg7KytuKXtpZihcIm9iamVjdFwiIT10eXBlb2YgdC5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzW25dKXRocm93IFR5cGVFcnJvcihcIi5vbm54LlRlbnNvckFubm90YXRpb24ucXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lczogb2JqZWN0IGV4cGVjdGVkXCIpO2UucXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lc1tuXT1sLm9ubnguU3RyaW5nU3RyaW5nRW50cnlQcm90by5mcm9tT2JqZWN0KHQucXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lc1tuXSl9fXJldHVybiBlfSx0LnRvT2JqZWN0PWZ1bmN0aW9uKHQsZSl7ZXx8KGU9e30pO3ZhciBuPXt9O2lmKChlLmFycmF5c3x8ZS5kZWZhdWx0cykmJihuLnF1YW50UGFyYW1ldGVyVGVuc29yTmFtZXM9W10pLGUuZGVmYXVsdHMmJihuLnRlbnNvck5hbWU9XCJcIiksbnVsbCE9dC50ZW5zb3JOYW1lJiZ0Lmhhc093blByb3BlcnR5KFwidGVuc29yTmFtZVwiKSYmKG4udGVuc29yTmFtZT10LnRlbnNvck5hbWUpLHQucXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lcyYmdC5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzLmxlbmd0aCl7bi5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzPVtdO2Zvcih2YXIgcj0wO3I8dC5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzLmxlbmd0aDsrK3Ipbi5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzW3JdPWwub25ueC5TdHJpbmdTdHJpbmdFbnRyeVByb3RvLnRvT2JqZWN0KHQucXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lc1tyXSxlKX1yZXR1cm4gbn0sdC5wcm90b3R5cGUudG9KU09OPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY29uc3RydWN0b3IudG9PYmplY3QodGhpcyxhLnV0aWwudG9KU09OT3B0aW9ucyl9LHR9KCksby5HcmFwaFByb3RvPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0KXtpZih0aGlzLm5vZGU9W10sdGhpcy5pbml0aWFsaXplcj1bXSx0aGlzLmlucHV0PVtdLHRoaXMub3V0cHV0PVtdLHRoaXMudmFsdWVJbmZvPVtdLHRoaXMucXVhbnRpemF0aW9uQW5ub3RhdGlvbj1bXSx0KWZvcih2YXIgZT1PYmplY3Qua2V5cyh0KSxuPTA7bjxlLmxlbmd0aDsrK24pbnVsbCE9dFtlW25dXSYmKHRoaXNbZVtuXV09dFtlW25dXSl9cmV0dXJuIHQucHJvdG90eXBlLm5vZGU9Yy5lbXB0eUFycmF5LHQucHJvdG90eXBlLm5hbWU9XCJcIix0LnByb3RvdHlwZS5pbml0aWFsaXplcj1jLmVtcHR5QXJyYXksdC5wcm90b3R5cGUuZG9jU3RyaW5nPVwiXCIsdC5wcm90b3R5cGUuaW5wdXQ9Yy5lbXB0eUFycmF5LHQucHJvdG90eXBlLm91dHB1dD1jLmVtcHR5QXJyYXksdC5wcm90b3R5cGUudmFsdWVJbmZvPWMuZW1wdHlBcnJheSx0LnByb3RvdHlwZS5xdWFudGl6YXRpb25Bbm5vdGF0aW9uPWMuZW1wdHlBcnJheSx0LmNyZWF0ZT1mdW5jdGlvbihlKXtyZXR1cm4gbmV3IHQoZSl9LHQuZW5jb2RlPWZ1bmN0aW9uKHQsZSl7aWYoZXx8KGU9dS5jcmVhdGUoKSksbnVsbCE9dC5ub2RlJiZ0Lm5vZGUubGVuZ3RoKWZvcih2YXIgbj0wO248dC5ub2RlLmxlbmd0aDsrK24pbC5vbm54Lk5vZGVQcm90by5lbmNvZGUodC5ub2RlW25dLGUudWludDMyKDEwKS5mb3JrKCkpLmxkZWxpbSgpO2lmKG51bGwhPXQubmFtZSYmdC5oYXNPd25Qcm9wZXJ0eShcIm5hbWVcIikmJmUudWludDMyKDE4KS5zdHJpbmcodC5uYW1lKSxudWxsIT10LmluaXRpYWxpemVyJiZ0LmluaXRpYWxpemVyLmxlbmd0aClmb3Iobj0wO248dC5pbml0aWFsaXplci5sZW5ndGg7KytuKWwub25ueC5UZW5zb3JQcm90by5lbmNvZGUodC5pbml0aWFsaXplcltuXSxlLnVpbnQzMig0MikuZm9yaygpKS5sZGVsaW0oKTtpZihudWxsIT10LmRvY1N0cmluZyYmdC5oYXNPd25Qcm9wZXJ0eShcImRvY1N0cmluZ1wiKSYmZS51aW50MzIoODIpLnN0cmluZyh0LmRvY1N0cmluZyksbnVsbCE9dC5pbnB1dCYmdC5pbnB1dC5sZW5ndGgpZm9yKG49MDtuPHQuaW5wdXQubGVuZ3RoOysrbilsLm9ubnguVmFsdWVJbmZvUHJvdG8uZW5jb2RlKHQuaW5wdXRbbl0sZS51aW50MzIoOTApLmZvcmsoKSkubGRlbGltKCk7aWYobnVsbCE9dC5vdXRwdXQmJnQub3V0cHV0Lmxlbmd0aClmb3Iobj0wO248dC5vdXRwdXQubGVuZ3RoOysrbilsLm9ubnguVmFsdWVJbmZvUHJvdG8uZW5jb2RlKHQub3V0cHV0W25dLGUudWludDMyKDk4KS5mb3JrKCkpLmxkZWxpbSgpO2lmKG51bGwhPXQudmFsdWVJbmZvJiZ0LnZhbHVlSW5mby5sZW5ndGgpZm9yKG49MDtuPHQudmFsdWVJbmZvLmxlbmd0aDsrK24pbC5vbm54LlZhbHVlSW5mb1Byb3RvLmVuY29kZSh0LnZhbHVlSW5mb1tuXSxlLnVpbnQzMigxMDYpLmZvcmsoKSkubGRlbGltKCk7aWYobnVsbCE9dC5xdWFudGl6YXRpb25Bbm5vdGF0aW9uJiZ0LnF1YW50aXphdGlvbkFubm90YXRpb24ubGVuZ3RoKWZvcihuPTA7bjx0LnF1YW50aXphdGlvbkFubm90YXRpb24ubGVuZ3RoOysrbilsLm9ubnguVGVuc29yQW5ub3RhdGlvbi5lbmNvZGUodC5xdWFudGl6YXRpb25Bbm5vdGF0aW9uW25dLGUudWludDMyKDExNCkuZm9yaygpKS5sZGVsaW0oKTtyZXR1cm4gZX0sdC5lbmNvZGVEZWxpbWl0ZWQ9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5lbmNvZGUodCxlKS5sZGVsaW0oKX0sdC5kZWNvZGU9ZnVuY3Rpb24odCxlKXt0IGluc3RhbmNlb2Ygc3x8KHQ9cy5jcmVhdGUodCkpO2Zvcih2YXIgbj12b2lkIDA9PT1lP3QubGVuOnQucG9zK2Uscj1uZXcgbC5vbm54LkdyYXBoUHJvdG87dC5wb3M8bjspe3ZhciBpPXQudWludDMyKCk7c3dpdGNoKGk+Pj4zKXtjYXNlIDE6ci5ub2RlJiZyLm5vZGUubGVuZ3RofHwoci5ub2RlPVtdKSxyLm5vZGUucHVzaChsLm9ubnguTm9kZVByb3RvLmRlY29kZSh0LHQudWludDMyKCkpKTticmVhaztjYXNlIDI6ci5uYW1lPXQuc3RyaW5nKCk7YnJlYWs7Y2FzZSA1OnIuaW5pdGlhbGl6ZXImJnIuaW5pdGlhbGl6ZXIubGVuZ3RofHwoci5pbml0aWFsaXplcj1bXSksci5pbml0aWFsaXplci5wdXNoKGwub25ueC5UZW5zb3JQcm90by5kZWNvZGUodCx0LnVpbnQzMigpKSk7YnJlYWs7Y2FzZSAxMDpyLmRvY1N0cmluZz10LnN0cmluZygpO2JyZWFrO2Nhc2UgMTE6ci5pbnB1dCYmci5pbnB1dC5sZW5ndGh8fChyLmlucHV0PVtdKSxyLmlucHV0LnB1c2gobC5vbm54LlZhbHVlSW5mb1Byb3RvLmRlY29kZSh0LHQudWludDMyKCkpKTticmVhaztjYXNlIDEyOnIub3V0cHV0JiZyLm91dHB1dC5sZW5ndGh8fChyLm91dHB1dD1bXSksci5vdXRwdXQucHVzaChsLm9ubnguVmFsdWVJbmZvUHJvdG8uZGVjb2RlKHQsdC51aW50MzIoKSkpO2JyZWFrO2Nhc2UgMTM6ci52YWx1ZUluZm8mJnIudmFsdWVJbmZvLmxlbmd0aHx8KHIudmFsdWVJbmZvPVtdKSxyLnZhbHVlSW5mby5wdXNoKGwub25ueC5WYWx1ZUluZm9Qcm90by5kZWNvZGUodCx0LnVpbnQzMigpKSk7YnJlYWs7Y2FzZSAxNDpyLnF1YW50aXphdGlvbkFubm90YXRpb24mJnIucXVhbnRpemF0aW9uQW5ub3RhdGlvbi5sZW5ndGh8fChyLnF1YW50aXphdGlvbkFubm90YXRpb249W10pLHIucXVhbnRpemF0aW9uQW5ub3RhdGlvbi5wdXNoKGwub25ueC5UZW5zb3JBbm5vdGF0aW9uLmRlY29kZSh0LHQudWludDMyKCkpKTticmVhaztkZWZhdWx0OnQuc2tpcFR5cGUoNyZpKX19cmV0dXJuIHJ9LHQuZGVjb2RlRGVsaW1pdGVkPWZ1bmN0aW9uKHQpe3JldHVybiB0IGluc3RhbmNlb2Ygc3x8KHQ9bmV3IHModCkpLHRoaXMuZGVjb2RlKHQsdC51aW50MzIoKSl9LHQudmVyaWZ5PWZ1bmN0aW9uKHQpe2lmKFwib2JqZWN0XCIhPXR5cGVvZiB0fHxudWxsPT09dClyZXR1cm5cIm9iamVjdCBleHBlY3RlZFwiO2lmKG51bGwhPXQubm9kZSYmdC5oYXNPd25Qcm9wZXJ0eShcIm5vZGVcIikpe2lmKCFBcnJheS5pc0FycmF5KHQubm9kZSkpcmV0dXJuXCJub2RlOiBhcnJheSBleHBlY3RlZFwiO2Zvcih2YXIgZT0wO2U8dC5ub2RlLmxlbmd0aDsrK2UpaWYobj1sLm9ubnguTm9kZVByb3RvLnZlcmlmeSh0Lm5vZGVbZV0pKXJldHVyblwibm9kZS5cIitufWlmKG51bGwhPXQubmFtZSYmdC5oYXNPd25Qcm9wZXJ0eShcIm5hbWVcIikmJiFjLmlzU3RyaW5nKHQubmFtZSkpcmV0dXJuXCJuYW1lOiBzdHJpbmcgZXhwZWN0ZWRcIjtpZihudWxsIT10LmluaXRpYWxpemVyJiZ0Lmhhc093blByb3BlcnR5KFwiaW5pdGlhbGl6ZXJcIikpe2lmKCFBcnJheS5pc0FycmF5KHQuaW5pdGlhbGl6ZXIpKXJldHVyblwiaW5pdGlhbGl6ZXI6IGFycmF5IGV4cGVjdGVkXCI7Zm9yKGU9MDtlPHQuaW5pdGlhbGl6ZXIubGVuZ3RoOysrZSlpZihuPWwub25ueC5UZW5zb3JQcm90by52ZXJpZnkodC5pbml0aWFsaXplcltlXSkpcmV0dXJuXCJpbml0aWFsaXplci5cIitufWlmKG51bGwhPXQuZG9jU3RyaW5nJiZ0Lmhhc093blByb3BlcnR5KFwiZG9jU3RyaW5nXCIpJiYhYy5pc1N0cmluZyh0LmRvY1N0cmluZykpcmV0dXJuXCJkb2NTdHJpbmc6IHN0cmluZyBleHBlY3RlZFwiO2lmKG51bGwhPXQuaW5wdXQmJnQuaGFzT3duUHJvcGVydHkoXCJpbnB1dFwiKSl7aWYoIUFycmF5LmlzQXJyYXkodC5pbnB1dCkpcmV0dXJuXCJpbnB1dDogYXJyYXkgZXhwZWN0ZWRcIjtmb3IoZT0wO2U8dC5pbnB1dC5sZW5ndGg7KytlKWlmKG49bC5vbm54LlZhbHVlSW5mb1Byb3RvLnZlcmlmeSh0LmlucHV0W2VdKSlyZXR1cm5cImlucHV0LlwiK259aWYobnVsbCE9dC5vdXRwdXQmJnQuaGFzT3duUHJvcGVydHkoXCJvdXRwdXRcIikpe2lmKCFBcnJheS5pc0FycmF5KHQub3V0cHV0KSlyZXR1cm5cIm91dHB1dDogYXJyYXkgZXhwZWN0ZWRcIjtmb3IoZT0wO2U8dC5vdXRwdXQubGVuZ3RoOysrZSlpZihuPWwub25ueC5WYWx1ZUluZm9Qcm90by52ZXJpZnkodC5vdXRwdXRbZV0pKXJldHVyblwib3V0cHV0LlwiK259aWYobnVsbCE9dC52YWx1ZUluZm8mJnQuaGFzT3duUHJvcGVydHkoXCJ2YWx1ZUluZm9cIikpe2lmKCFBcnJheS5pc0FycmF5KHQudmFsdWVJbmZvKSlyZXR1cm5cInZhbHVlSW5mbzogYXJyYXkgZXhwZWN0ZWRcIjtmb3IoZT0wO2U8dC52YWx1ZUluZm8ubGVuZ3RoOysrZSlpZihuPWwub25ueC5WYWx1ZUluZm9Qcm90by52ZXJpZnkodC52YWx1ZUluZm9bZV0pKXJldHVyblwidmFsdWVJbmZvLlwiK259aWYobnVsbCE9dC5xdWFudGl6YXRpb25Bbm5vdGF0aW9uJiZ0Lmhhc093blByb3BlcnR5KFwicXVhbnRpemF0aW9uQW5ub3RhdGlvblwiKSl7aWYoIUFycmF5LmlzQXJyYXkodC5xdWFudGl6YXRpb25Bbm5vdGF0aW9uKSlyZXR1cm5cInF1YW50aXphdGlvbkFubm90YXRpb246IGFycmF5IGV4cGVjdGVkXCI7Zm9yKGU9MDtlPHQucXVhbnRpemF0aW9uQW5ub3RhdGlvbi5sZW5ndGg7KytlKXt2YXIgbjtpZihuPWwub25ueC5UZW5zb3JBbm5vdGF0aW9uLnZlcmlmeSh0LnF1YW50aXphdGlvbkFubm90YXRpb25bZV0pKXJldHVyblwicXVhbnRpemF0aW9uQW5ub3RhdGlvbi5cIitufX1yZXR1cm4gbnVsbH0sdC5mcm9tT2JqZWN0PWZ1bmN0aW9uKHQpe2lmKHQgaW5zdGFuY2VvZiBsLm9ubnguR3JhcGhQcm90bylyZXR1cm4gdDt2YXIgZT1uZXcgbC5vbm54LkdyYXBoUHJvdG87aWYodC5ub2RlKXtpZighQXJyYXkuaXNBcnJheSh0Lm5vZGUpKXRocm93IFR5cGVFcnJvcihcIi5vbm54LkdyYXBoUHJvdG8ubm9kZTogYXJyYXkgZXhwZWN0ZWRcIik7ZS5ub2RlPVtdO2Zvcih2YXIgbj0wO248dC5ub2RlLmxlbmd0aDsrK24pe2lmKFwib2JqZWN0XCIhPXR5cGVvZiB0Lm5vZGVbbl0pdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguR3JhcGhQcm90by5ub2RlOiBvYmplY3QgZXhwZWN0ZWRcIik7ZS5ub2RlW25dPWwub25ueC5Ob2RlUHJvdG8uZnJvbU9iamVjdCh0Lm5vZGVbbl0pfX1pZihudWxsIT10Lm5hbWUmJihlLm5hbWU9U3RyaW5nKHQubmFtZSkpLHQuaW5pdGlhbGl6ZXIpe2lmKCFBcnJheS5pc0FycmF5KHQuaW5pdGlhbGl6ZXIpKXRocm93IFR5cGVFcnJvcihcIi5vbm54LkdyYXBoUHJvdG8uaW5pdGlhbGl6ZXI6IGFycmF5IGV4cGVjdGVkXCIpO2ZvcihlLmluaXRpYWxpemVyPVtdLG49MDtuPHQuaW5pdGlhbGl6ZXIubGVuZ3RoOysrbil7aWYoXCJvYmplY3RcIiE9dHlwZW9mIHQuaW5pdGlhbGl6ZXJbbl0pdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguR3JhcGhQcm90by5pbml0aWFsaXplcjogb2JqZWN0IGV4cGVjdGVkXCIpO2UuaW5pdGlhbGl6ZXJbbl09bC5vbm54LlRlbnNvclByb3RvLmZyb21PYmplY3QodC5pbml0aWFsaXplcltuXSl9fWlmKG51bGwhPXQuZG9jU3RyaW5nJiYoZS5kb2NTdHJpbmc9U3RyaW5nKHQuZG9jU3RyaW5nKSksdC5pbnB1dCl7aWYoIUFycmF5LmlzQXJyYXkodC5pbnB1dCkpdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguR3JhcGhQcm90by5pbnB1dDogYXJyYXkgZXhwZWN0ZWRcIik7Zm9yKGUuaW5wdXQ9W10sbj0wO248dC5pbnB1dC5sZW5ndGg7KytuKXtpZihcIm9iamVjdFwiIT10eXBlb2YgdC5pbnB1dFtuXSl0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5HcmFwaFByb3RvLmlucHV0OiBvYmplY3QgZXhwZWN0ZWRcIik7ZS5pbnB1dFtuXT1sLm9ubnguVmFsdWVJbmZvUHJvdG8uZnJvbU9iamVjdCh0LmlucHV0W25dKX19aWYodC5vdXRwdXQpe2lmKCFBcnJheS5pc0FycmF5KHQub3V0cHV0KSl0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5HcmFwaFByb3RvLm91dHB1dDogYXJyYXkgZXhwZWN0ZWRcIik7Zm9yKGUub3V0cHV0PVtdLG49MDtuPHQub3V0cHV0Lmxlbmd0aDsrK24pe2lmKFwib2JqZWN0XCIhPXR5cGVvZiB0Lm91dHB1dFtuXSl0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5HcmFwaFByb3RvLm91dHB1dDogb2JqZWN0IGV4cGVjdGVkXCIpO2Uub3V0cHV0W25dPWwub25ueC5WYWx1ZUluZm9Qcm90by5mcm9tT2JqZWN0KHQub3V0cHV0W25dKX19aWYodC52YWx1ZUluZm8pe2lmKCFBcnJheS5pc0FycmF5KHQudmFsdWVJbmZvKSl0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5HcmFwaFByb3RvLnZhbHVlSW5mbzogYXJyYXkgZXhwZWN0ZWRcIik7Zm9yKGUudmFsdWVJbmZvPVtdLG49MDtuPHQudmFsdWVJbmZvLmxlbmd0aDsrK24pe2lmKFwib2JqZWN0XCIhPXR5cGVvZiB0LnZhbHVlSW5mb1tuXSl0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5HcmFwaFByb3RvLnZhbHVlSW5mbzogb2JqZWN0IGV4cGVjdGVkXCIpO2UudmFsdWVJbmZvW25dPWwub25ueC5WYWx1ZUluZm9Qcm90by5mcm9tT2JqZWN0KHQudmFsdWVJbmZvW25dKX19aWYodC5xdWFudGl6YXRpb25Bbm5vdGF0aW9uKXtpZighQXJyYXkuaXNBcnJheSh0LnF1YW50aXphdGlvbkFubm90YXRpb24pKXRocm93IFR5cGVFcnJvcihcIi5vbm54LkdyYXBoUHJvdG8ucXVhbnRpemF0aW9uQW5ub3RhdGlvbjogYXJyYXkgZXhwZWN0ZWRcIik7Zm9yKGUucXVhbnRpemF0aW9uQW5ub3RhdGlvbj1bXSxuPTA7bjx0LnF1YW50aXphdGlvbkFubm90YXRpb24ubGVuZ3RoOysrbil7aWYoXCJvYmplY3RcIiE9dHlwZW9mIHQucXVhbnRpemF0aW9uQW5ub3RhdGlvbltuXSl0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5HcmFwaFByb3RvLnF1YW50aXphdGlvbkFubm90YXRpb246IG9iamVjdCBleHBlY3RlZFwiKTtlLnF1YW50aXphdGlvbkFubm90YXRpb25bbl09bC5vbm54LlRlbnNvckFubm90YXRpb24uZnJvbU9iamVjdCh0LnF1YW50aXphdGlvbkFubm90YXRpb25bbl0pfX1yZXR1cm4gZX0sdC50b09iamVjdD1mdW5jdGlvbih0LGUpe2V8fChlPXt9KTt2YXIgbj17fTtpZigoZS5hcnJheXN8fGUuZGVmYXVsdHMpJiYobi5ub2RlPVtdLG4uaW5pdGlhbGl6ZXI9W10sbi5pbnB1dD1bXSxuLm91dHB1dD1bXSxuLnZhbHVlSW5mbz1bXSxuLnF1YW50aXphdGlvbkFubm90YXRpb249W10pLGUuZGVmYXVsdHMmJihuLm5hbWU9XCJcIixuLmRvY1N0cmluZz1cIlwiKSx0Lm5vZGUmJnQubm9kZS5sZW5ndGgpe24ubm9kZT1bXTtmb3IodmFyIHI9MDtyPHQubm9kZS5sZW5ndGg7KytyKW4ubm9kZVtyXT1sLm9ubnguTm9kZVByb3RvLnRvT2JqZWN0KHQubm9kZVtyXSxlKX1pZihudWxsIT10Lm5hbWUmJnQuaGFzT3duUHJvcGVydHkoXCJuYW1lXCIpJiYobi5uYW1lPXQubmFtZSksdC5pbml0aWFsaXplciYmdC5pbml0aWFsaXplci5sZW5ndGgpZm9yKG4uaW5pdGlhbGl6ZXI9W10scj0wO3I8dC5pbml0aWFsaXplci5sZW5ndGg7KytyKW4uaW5pdGlhbGl6ZXJbcl09bC5vbm54LlRlbnNvclByb3RvLnRvT2JqZWN0KHQuaW5pdGlhbGl6ZXJbcl0sZSk7aWYobnVsbCE9dC5kb2NTdHJpbmcmJnQuaGFzT3duUHJvcGVydHkoXCJkb2NTdHJpbmdcIikmJihuLmRvY1N0cmluZz10LmRvY1N0cmluZyksdC5pbnB1dCYmdC5pbnB1dC5sZW5ndGgpZm9yKG4uaW5wdXQ9W10scj0wO3I8dC5pbnB1dC5sZW5ndGg7KytyKW4uaW5wdXRbcl09bC5vbm54LlZhbHVlSW5mb1Byb3RvLnRvT2JqZWN0KHQuaW5wdXRbcl0sZSk7aWYodC5vdXRwdXQmJnQub3V0cHV0Lmxlbmd0aClmb3Iobi5vdXRwdXQ9W10scj0wO3I8dC5vdXRwdXQubGVuZ3RoOysrciluLm91dHB1dFtyXT1sLm9ubnguVmFsdWVJbmZvUHJvdG8udG9PYmplY3QodC5vdXRwdXRbcl0sZSk7aWYodC52YWx1ZUluZm8mJnQudmFsdWVJbmZvLmxlbmd0aClmb3Iobi52YWx1ZUluZm89W10scj0wO3I8dC52YWx1ZUluZm8ubGVuZ3RoOysrciluLnZhbHVlSW5mb1tyXT1sLm9ubnguVmFsdWVJbmZvUHJvdG8udG9PYmplY3QodC52YWx1ZUluZm9bcl0sZSk7aWYodC5xdWFudGl6YXRpb25Bbm5vdGF0aW9uJiZ0LnF1YW50aXphdGlvbkFubm90YXRpb24ubGVuZ3RoKWZvcihuLnF1YW50aXphdGlvbkFubm90YXRpb249W10scj0wO3I8dC5xdWFudGl6YXRpb25Bbm5vdGF0aW9uLmxlbmd0aDsrK3Ipbi5xdWFudGl6YXRpb25Bbm5vdGF0aW9uW3JdPWwub25ueC5UZW5zb3JBbm5vdGF0aW9uLnRvT2JqZWN0KHQucXVhbnRpemF0aW9uQW5ub3RhdGlvbltyXSxlKTtyZXR1cm4gbn0sdC5wcm90b3R5cGUudG9KU09OPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY29uc3RydWN0b3IudG9PYmplY3QodGhpcyxhLnV0aWwudG9KU09OT3B0aW9ucyl9LHR9KCksby5UZW5zb3JQcm90bz1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCl7aWYodGhpcy5kaW1zPVtdLHRoaXMuZmxvYXREYXRhPVtdLHRoaXMuaW50MzJEYXRhPVtdLHRoaXMuc3RyaW5nRGF0YT1bXSx0aGlzLmludDY0RGF0YT1bXSx0aGlzLmV4dGVybmFsRGF0YT1bXSx0aGlzLmRvdWJsZURhdGE9W10sdGhpcy51aW50NjREYXRhPVtdLHQpZm9yKHZhciBlPU9iamVjdC5rZXlzKHQpLG49MDtuPGUubGVuZ3RoOysrbiludWxsIT10W2Vbbl1dJiYodGhpc1tlW25dXT10W2Vbbl1dKX1yZXR1cm4gdC5wcm90b3R5cGUuZGltcz1jLmVtcHR5QXJyYXksdC5wcm90b3R5cGUuZGF0YVR5cGU9MCx0LnByb3RvdHlwZS5zZWdtZW50PW51bGwsdC5wcm90b3R5cGUuZmxvYXREYXRhPWMuZW1wdHlBcnJheSx0LnByb3RvdHlwZS5pbnQzMkRhdGE9Yy5lbXB0eUFycmF5LHQucHJvdG90eXBlLnN0cmluZ0RhdGE9Yy5lbXB0eUFycmF5LHQucHJvdG90eXBlLmludDY0RGF0YT1jLmVtcHR5QXJyYXksdC5wcm90b3R5cGUubmFtZT1cIlwiLHQucHJvdG90eXBlLmRvY1N0cmluZz1cIlwiLHQucHJvdG90eXBlLnJhd0RhdGE9Yy5uZXdCdWZmZXIoW10pLHQucHJvdG90eXBlLmV4dGVybmFsRGF0YT1jLmVtcHR5QXJyYXksdC5wcm90b3R5cGUuZGF0YUxvY2F0aW9uPTAsdC5wcm90b3R5cGUuZG91YmxlRGF0YT1jLmVtcHR5QXJyYXksdC5wcm90b3R5cGUudWludDY0RGF0YT1jLmVtcHR5QXJyYXksdC5jcmVhdGU9ZnVuY3Rpb24oZSl7cmV0dXJuIG5ldyB0KGUpfSx0LmVuY29kZT1mdW5jdGlvbih0LGUpe2lmKGV8fChlPXUuY3JlYXRlKCkpLG51bGwhPXQuZGltcyYmdC5kaW1zLmxlbmd0aCl7ZS51aW50MzIoMTApLmZvcmsoKTtmb3IodmFyIG49MDtuPHQuZGltcy5sZW5ndGg7KytuKWUuaW50NjQodC5kaW1zW25dKTtlLmxkZWxpbSgpfWlmKG51bGwhPXQuZGF0YVR5cGUmJnQuaGFzT3duUHJvcGVydHkoXCJkYXRhVHlwZVwiKSYmZS51aW50MzIoMTYpLmludDMyKHQuZGF0YVR5cGUpLG51bGwhPXQuc2VnbWVudCYmdC5oYXNPd25Qcm9wZXJ0eShcInNlZ21lbnRcIikmJmwub25ueC5UZW5zb3JQcm90by5TZWdtZW50LmVuY29kZSh0LnNlZ21lbnQsZS51aW50MzIoMjYpLmZvcmsoKSkubGRlbGltKCksbnVsbCE9dC5mbG9hdERhdGEmJnQuZmxvYXREYXRhLmxlbmd0aCl7Zm9yKGUudWludDMyKDM0KS5mb3JrKCksbj0wO248dC5mbG9hdERhdGEubGVuZ3RoOysrbillLmZsb2F0KHQuZmxvYXREYXRhW25dKTtlLmxkZWxpbSgpfWlmKG51bGwhPXQuaW50MzJEYXRhJiZ0LmludDMyRGF0YS5sZW5ndGgpe2ZvcihlLnVpbnQzMig0MikuZm9yaygpLG49MDtuPHQuaW50MzJEYXRhLmxlbmd0aDsrK24pZS5pbnQzMih0LmludDMyRGF0YVtuXSk7ZS5sZGVsaW0oKX1pZihudWxsIT10LnN0cmluZ0RhdGEmJnQuc3RyaW5nRGF0YS5sZW5ndGgpZm9yKG49MDtuPHQuc3RyaW5nRGF0YS5sZW5ndGg7KytuKWUudWludDMyKDUwKS5ieXRlcyh0LnN0cmluZ0RhdGFbbl0pO2lmKG51bGwhPXQuaW50NjREYXRhJiZ0LmludDY0RGF0YS5sZW5ndGgpe2ZvcihlLnVpbnQzMig1OCkuZm9yaygpLG49MDtuPHQuaW50NjREYXRhLmxlbmd0aDsrK24pZS5pbnQ2NCh0LmludDY0RGF0YVtuXSk7ZS5sZGVsaW0oKX1pZihudWxsIT10Lm5hbWUmJnQuaGFzT3duUHJvcGVydHkoXCJuYW1lXCIpJiZlLnVpbnQzMig2Nikuc3RyaW5nKHQubmFtZSksbnVsbCE9dC5yYXdEYXRhJiZ0Lmhhc093blByb3BlcnR5KFwicmF3RGF0YVwiKSYmZS51aW50MzIoNzQpLmJ5dGVzKHQucmF3RGF0YSksbnVsbCE9dC5kb3VibGVEYXRhJiZ0LmRvdWJsZURhdGEubGVuZ3RoKXtmb3IoZS51aW50MzIoODIpLmZvcmsoKSxuPTA7bjx0LmRvdWJsZURhdGEubGVuZ3RoOysrbillLmRvdWJsZSh0LmRvdWJsZURhdGFbbl0pO2UubGRlbGltKCl9aWYobnVsbCE9dC51aW50NjREYXRhJiZ0LnVpbnQ2NERhdGEubGVuZ3RoKXtmb3IoZS51aW50MzIoOTApLmZvcmsoKSxuPTA7bjx0LnVpbnQ2NERhdGEubGVuZ3RoOysrbillLnVpbnQ2NCh0LnVpbnQ2NERhdGFbbl0pO2UubGRlbGltKCl9aWYobnVsbCE9dC5kb2NTdHJpbmcmJnQuaGFzT3duUHJvcGVydHkoXCJkb2NTdHJpbmdcIikmJmUudWludDMyKDk4KS5zdHJpbmcodC5kb2NTdHJpbmcpLG51bGwhPXQuZXh0ZXJuYWxEYXRhJiZ0LmV4dGVybmFsRGF0YS5sZW5ndGgpZm9yKG49MDtuPHQuZXh0ZXJuYWxEYXRhLmxlbmd0aDsrK24pbC5vbm54LlN0cmluZ1N0cmluZ0VudHJ5UHJvdG8uZW5jb2RlKHQuZXh0ZXJuYWxEYXRhW25dLGUudWludDMyKDEwNikuZm9yaygpKS5sZGVsaW0oKTtyZXR1cm4gbnVsbCE9dC5kYXRhTG9jYXRpb24mJnQuaGFzT3duUHJvcGVydHkoXCJkYXRhTG9jYXRpb25cIikmJmUudWludDMyKDExMikuaW50MzIodC5kYXRhTG9jYXRpb24pLGV9LHQuZW5jb2RlRGVsaW1pdGVkPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMuZW5jb2RlKHQsZSkubGRlbGltKCl9LHQuZGVjb2RlPWZ1bmN0aW9uKHQsZSl7dCBpbnN0YW5jZW9mIHN8fCh0PXMuY3JlYXRlKHQpKTtmb3IodmFyIG49dm9pZCAwPT09ZT90Lmxlbjp0LnBvcytlLHI9bmV3IGwub25ueC5UZW5zb3JQcm90bzt0LnBvczxuOyl7dmFyIGk9dC51aW50MzIoKTtzd2l0Y2goaT4+PjMpe2Nhc2UgMTppZihyLmRpbXMmJnIuZGltcy5sZW5ndGh8fChyLmRpbXM9W10pLDI9PSg3JmkpKWZvcih2YXIgbz10LnVpbnQzMigpK3QucG9zO3QucG9zPG87KXIuZGltcy5wdXNoKHQuaW50NjQoKSk7ZWxzZSByLmRpbXMucHVzaCh0LmludDY0KCkpO2JyZWFrO2Nhc2UgMjpyLmRhdGFUeXBlPXQuaW50MzIoKTticmVhaztjYXNlIDM6ci5zZWdtZW50PWwub25ueC5UZW5zb3JQcm90by5TZWdtZW50LmRlY29kZSh0LHQudWludDMyKCkpO2JyZWFrO2Nhc2UgNDppZihyLmZsb2F0RGF0YSYmci5mbG9hdERhdGEubGVuZ3RofHwoci5mbG9hdERhdGE9W10pLDI9PSg3JmkpKWZvcihvPXQudWludDMyKCkrdC5wb3M7dC5wb3M8bzspci5mbG9hdERhdGEucHVzaCh0LmZsb2F0KCkpO2Vsc2Ugci5mbG9hdERhdGEucHVzaCh0LmZsb2F0KCkpO2JyZWFrO2Nhc2UgNTppZihyLmludDMyRGF0YSYmci5pbnQzMkRhdGEubGVuZ3RofHwoci5pbnQzMkRhdGE9W10pLDI9PSg3JmkpKWZvcihvPXQudWludDMyKCkrdC5wb3M7dC5wb3M8bzspci5pbnQzMkRhdGEucHVzaCh0LmludDMyKCkpO2Vsc2Ugci5pbnQzMkRhdGEucHVzaCh0LmludDMyKCkpO2JyZWFrO2Nhc2UgNjpyLnN0cmluZ0RhdGEmJnIuc3RyaW5nRGF0YS5sZW5ndGh8fChyLnN0cmluZ0RhdGE9W10pLHIuc3RyaW5nRGF0YS5wdXNoKHQuYnl0ZXMoKSk7YnJlYWs7Y2FzZSA3OmlmKHIuaW50NjREYXRhJiZyLmludDY0RGF0YS5sZW5ndGh8fChyLmludDY0RGF0YT1bXSksMj09KDcmaSkpZm9yKG89dC51aW50MzIoKSt0LnBvczt0LnBvczxvOylyLmludDY0RGF0YS5wdXNoKHQuaW50NjQoKSk7ZWxzZSByLmludDY0RGF0YS5wdXNoKHQuaW50NjQoKSk7YnJlYWs7Y2FzZSA4OnIubmFtZT10LnN0cmluZygpO2JyZWFrO2Nhc2UgMTI6ci5kb2NTdHJpbmc9dC5zdHJpbmcoKTticmVhaztjYXNlIDk6ci5yYXdEYXRhPXQuYnl0ZXMoKTticmVhaztjYXNlIDEzOnIuZXh0ZXJuYWxEYXRhJiZyLmV4dGVybmFsRGF0YS5sZW5ndGh8fChyLmV4dGVybmFsRGF0YT1bXSksci5leHRlcm5hbERhdGEucHVzaChsLm9ubnguU3RyaW5nU3RyaW5nRW50cnlQcm90by5kZWNvZGUodCx0LnVpbnQzMigpKSk7YnJlYWs7Y2FzZSAxNDpyLmRhdGFMb2NhdGlvbj10LmludDMyKCk7YnJlYWs7Y2FzZSAxMDppZihyLmRvdWJsZURhdGEmJnIuZG91YmxlRGF0YS5sZW5ndGh8fChyLmRvdWJsZURhdGE9W10pLDI9PSg3JmkpKWZvcihvPXQudWludDMyKCkrdC5wb3M7dC5wb3M8bzspci5kb3VibGVEYXRhLnB1c2godC5kb3VibGUoKSk7ZWxzZSByLmRvdWJsZURhdGEucHVzaCh0LmRvdWJsZSgpKTticmVhaztjYXNlIDExOmlmKHIudWludDY0RGF0YSYmci51aW50NjREYXRhLmxlbmd0aHx8KHIudWludDY0RGF0YT1bXSksMj09KDcmaSkpZm9yKG89dC51aW50MzIoKSt0LnBvczt0LnBvczxvOylyLnVpbnQ2NERhdGEucHVzaCh0LnVpbnQ2NCgpKTtlbHNlIHIudWludDY0RGF0YS5wdXNoKHQudWludDY0KCkpO2JyZWFrO2RlZmF1bHQ6dC5za2lwVHlwZSg3JmkpfX1yZXR1cm4gcn0sdC5kZWNvZGVEZWxpbWl0ZWQ9ZnVuY3Rpb24odCl7cmV0dXJuIHQgaW5zdGFuY2VvZiBzfHwodD1uZXcgcyh0KSksdGhpcy5kZWNvZGUodCx0LnVpbnQzMigpKX0sdC52ZXJpZnk9ZnVuY3Rpb24odCl7aWYoXCJvYmplY3RcIiE9dHlwZW9mIHR8fG51bGw9PT10KXJldHVyblwib2JqZWN0IGV4cGVjdGVkXCI7aWYobnVsbCE9dC5kaW1zJiZ0Lmhhc093blByb3BlcnR5KFwiZGltc1wiKSl7aWYoIUFycmF5LmlzQXJyYXkodC5kaW1zKSlyZXR1cm5cImRpbXM6IGFycmF5IGV4cGVjdGVkXCI7Zm9yKHZhciBlPTA7ZTx0LmRpbXMubGVuZ3RoOysrZSlpZighKGMuaXNJbnRlZ2VyKHQuZGltc1tlXSl8fHQuZGltc1tlXSYmYy5pc0ludGVnZXIodC5kaW1zW2VdLmxvdykmJmMuaXNJbnRlZ2VyKHQuZGltc1tlXS5oaWdoKSkpcmV0dXJuXCJkaW1zOiBpbnRlZ2VyfExvbmdbXSBleHBlY3RlZFwifWlmKG51bGwhPXQuZGF0YVR5cGUmJnQuaGFzT3duUHJvcGVydHkoXCJkYXRhVHlwZVwiKSYmIWMuaXNJbnRlZ2VyKHQuZGF0YVR5cGUpKXJldHVyblwiZGF0YVR5cGU6IGludGVnZXIgZXhwZWN0ZWRcIjtpZihudWxsIT10LnNlZ21lbnQmJnQuaGFzT3duUHJvcGVydHkoXCJzZWdtZW50XCIpJiYobj1sLm9ubnguVGVuc29yUHJvdG8uU2VnbWVudC52ZXJpZnkodC5zZWdtZW50KSkpcmV0dXJuXCJzZWdtZW50LlwiK247aWYobnVsbCE9dC5mbG9hdERhdGEmJnQuaGFzT3duUHJvcGVydHkoXCJmbG9hdERhdGFcIikpe2lmKCFBcnJheS5pc0FycmF5KHQuZmxvYXREYXRhKSlyZXR1cm5cImZsb2F0RGF0YTogYXJyYXkgZXhwZWN0ZWRcIjtmb3IoZT0wO2U8dC5mbG9hdERhdGEubGVuZ3RoOysrZSlpZihcIm51bWJlclwiIT10eXBlb2YgdC5mbG9hdERhdGFbZV0pcmV0dXJuXCJmbG9hdERhdGE6IG51bWJlcltdIGV4cGVjdGVkXCJ9aWYobnVsbCE9dC5pbnQzMkRhdGEmJnQuaGFzT3duUHJvcGVydHkoXCJpbnQzMkRhdGFcIikpe2lmKCFBcnJheS5pc0FycmF5KHQuaW50MzJEYXRhKSlyZXR1cm5cImludDMyRGF0YTogYXJyYXkgZXhwZWN0ZWRcIjtmb3IoZT0wO2U8dC5pbnQzMkRhdGEubGVuZ3RoOysrZSlpZighYy5pc0ludGVnZXIodC5pbnQzMkRhdGFbZV0pKXJldHVyblwiaW50MzJEYXRhOiBpbnRlZ2VyW10gZXhwZWN0ZWRcIn1pZihudWxsIT10LnN0cmluZ0RhdGEmJnQuaGFzT3duUHJvcGVydHkoXCJzdHJpbmdEYXRhXCIpKXtpZighQXJyYXkuaXNBcnJheSh0LnN0cmluZ0RhdGEpKXJldHVyblwic3RyaW5nRGF0YTogYXJyYXkgZXhwZWN0ZWRcIjtmb3IoZT0wO2U8dC5zdHJpbmdEYXRhLmxlbmd0aDsrK2UpaWYoISh0LnN0cmluZ0RhdGFbZV0mJlwibnVtYmVyXCI9PXR5cGVvZiB0LnN0cmluZ0RhdGFbZV0ubGVuZ3RofHxjLmlzU3RyaW5nKHQuc3RyaW5nRGF0YVtlXSkpKXJldHVyblwic3RyaW5nRGF0YTogYnVmZmVyW10gZXhwZWN0ZWRcIn1pZihudWxsIT10LmludDY0RGF0YSYmdC5oYXNPd25Qcm9wZXJ0eShcImludDY0RGF0YVwiKSl7aWYoIUFycmF5LmlzQXJyYXkodC5pbnQ2NERhdGEpKXJldHVyblwiaW50NjREYXRhOiBhcnJheSBleHBlY3RlZFwiO2ZvcihlPTA7ZTx0LmludDY0RGF0YS5sZW5ndGg7KytlKWlmKCEoYy5pc0ludGVnZXIodC5pbnQ2NERhdGFbZV0pfHx0LmludDY0RGF0YVtlXSYmYy5pc0ludGVnZXIodC5pbnQ2NERhdGFbZV0ubG93KSYmYy5pc0ludGVnZXIodC5pbnQ2NERhdGFbZV0uaGlnaCkpKXJldHVyblwiaW50NjREYXRhOiBpbnRlZ2VyfExvbmdbXSBleHBlY3RlZFwifWlmKG51bGwhPXQubmFtZSYmdC5oYXNPd25Qcm9wZXJ0eShcIm5hbWVcIikmJiFjLmlzU3RyaW5nKHQubmFtZSkpcmV0dXJuXCJuYW1lOiBzdHJpbmcgZXhwZWN0ZWRcIjtpZihudWxsIT10LmRvY1N0cmluZyYmdC5oYXNPd25Qcm9wZXJ0eShcImRvY1N0cmluZ1wiKSYmIWMuaXNTdHJpbmcodC5kb2NTdHJpbmcpKXJldHVyblwiZG9jU3RyaW5nOiBzdHJpbmcgZXhwZWN0ZWRcIjtpZihudWxsIT10LnJhd0RhdGEmJnQuaGFzT3duUHJvcGVydHkoXCJyYXdEYXRhXCIpJiYhKHQucmF3RGF0YSYmXCJudW1iZXJcIj09dHlwZW9mIHQucmF3RGF0YS5sZW5ndGh8fGMuaXNTdHJpbmcodC5yYXdEYXRhKSkpcmV0dXJuXCJyYXdEYXRhOiBidWZmZXIgZXhwZWN0ZWRcIjtpZihudWxsIT10LmV4dGVybmFsRGF0YSYmdC5oYXNPd25Qcm9wZXJ0eShcImV4dGVybmFsRGF0YVwiKSl7aWYoIUFycmF5LmlzQXJyYXkodC5leHRlcm5hbERhdGEpKXJldHVyblwiZXh0ZXJuYWxEYXRhOiBhcnJheSBleHBlY3RlZFwiO2ZvcihlPTA7ZTx0LmV4dGVybmFsRGF0YS5sZW5ndGg7KytlKXt2YXIgbjtpZihuPWwub25ueC5TdHJpbmdTdHJpbmdFbnRyeVByb3RvLnZlcmlmeSh0LmV4dGVybmFsRGF0YVtlXSkpcmV0dXJuXCJleHRlcm5hbERhdGEuXCIrbn19aWYobnVsbCE9dC5kYXRhTG9jYXRpb24mJnQuaGFzT3duUHJvcGVydHkoXCJkYXRhTG9jYXRpb25cIikpc3dpdGNoKHQuZGF0YUxvY2F0aW9uKXtkZWZhdWx0OnJldHVyblwiZGF0YUxvY2F0aW9uOiBlbnVtIHZhbHVlIGV4cGVjdGVkXCI7Y2FzZSAwOmNhc2UgMTp9aWYobnVsbCE9dC5kb3VibGVEYXRhJiZ0Lmhhc093blByb3BlcnR5KFwiZG91YmxlRGF0YVwiKSl7aWYoIUFycmF5LmlzQXJyYXkodC5kb3VibGVEYXRhKSlyZXR1cm5cImRvdWJsZURhdGE6IGFycmF5IGV4cGVjdGVkXCI7Zm9yKGU9MDtlPHQuZG91YmxlRGF0YS5sZW5ndGg7KytlKWlmKFwibnVtYmVyXCIhPXR5cGVvZiB0LmRvdWJsZURhdGFbZV0pcmV0dXJuXCJkb3VibGVEYXRhOiBudW1iZXJbXSBleHBlY3RlZFwifWlmKG51bGwhPXQudWludDY0RGF0YSYmdC5oYXNPd25Qcm9wZXJ0eShcInVpbnQ2NERhdGFcIikpe2lmKCFBcnJheS5pc0FycmF5KHQudWludDY0RGF0YSkpcmV0dXJuXCJ1aW50NjREYXRhOiBhcnJheSBleHBlY3RlZFwiO2ZvcihlPTA7ZTx0LnVpbnQ2NERhdGEubGVuZ3RoOysrZSlpZighKGMuaXNJbnRlZ2VyKHQudWludDY0RGF0YVtlXSl8fHQudWludDY0RGF0YVtlXSYmYy5pc0ludGVnZXIodC51aW50NjREYXRhW2VdLmxvdykmJmMuaXNJbnRlZ2VyKHQudWludDY0RGF0YVtlXS5oaWdoKSkpcmV0dXJuXCJ1aW50NjREYXRhOiBpbnRlZ2VyfExvbmdbXSBleHBlY3RlZFwifXJldHVybiBudWxsfSx0LmZyb21PYmplY3Q9ZnVuY3Rpb24odCl7aWYodCBpbnN0YW5jZW9mIGwub25ueC5UZW5zb3JQcm90bylyZXR1cm4gdDt2YXIgZT1uZXcgbC5vbm54LlRlbnNvclByb3RvO2lmKHQuZGltcyl7aWYoIUFycmF5LmlzQXJyYXkodC5kaW1zKSl0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5UZW5zb3JQcm90by5kaW1zOiBhcnJheSBleHBlY3RlZFwiKTtlLmRpbXM9W107Zm9yKHZhciBuPTA7bjx0LmRpbXMubGVuZ3RoOysrbiljLkxvbmc/KGUuZGltc1tuXT1jLkxvbmcuZnJvbVZhbHVlKHQuZGltc1tuXSkpLnVuc2lnbmVkPSExOlwic3RyaW5nXCI9PXR5cGVvZiB0LmRpbXNbbl0/ZS5kaW1zW25dPXBhcnNlSW50KHQuZGltc1tuXSwxMCk6XCJudW1iZXJcIj09dHlwZW9mIHQuZGltc1tuXT9lLmRpbXNbbl09dC5kaW1zW25dOlwib2JqZWN0XCI9PXR5cGVvZiB0LmRpbXNbbl0mJihlLmRpbXNbbl09bmV3IGMuTG9uZ0JpdHModC5kaW1zW25dLmxvdz4+PjAsdC5kaW1zW25dLmhpZ2g+Pj4wKS50b051bWJlcigpKX1pZihudWxsIT10LmRhdGFUeXBlJiYoZS5kYXRhVHlwZT0wfHQuZGF0YVR5cGUpLG51bGwhPXQuc2VnbWVudCl7aWYoXCJvYmplY3RcIiE9dHlwZW9mIHQuc2VnbWVudCl0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5UZW5zb3JQcm90by5zZWdtZW50OiBvYmplY3QgZXhwZWN0ZWRcIik7ZS5zZWdtZW50PWwub25ueC5UZW5zb3JQcm90by5TZWdtZW50LmZyb21PYmplY3QodC5zZWdtZW50KX1pZih0LmZsb2F0RGF0YSl7aWYoIUFycmF5LmlzQXJyYXkodC5mbG9hdERhdGEpKXRocm93IFR5cGVFcnJvcihcIi5vbm54LlRlbnNvclByb3RvLmZsb2F0RGF0YTogYXJyYXkgZXhwZWN0ZWRcIik7Zm9yKGUuZmxvYXREYXRhPVtdLG49MDtuPHQuZmxvYXREYXRhLmxlbmd0aDsrK24pZS5mbG9hdERhdGFbbl09TnVtYmVyKHQuZmxvYXREYXRhW25dKX1pZih0LmludDMyRGF0YSl7aWYoIUFycmF5LmlzQXJyYXkodC5pbnQzMkRhdGEpKXRocm93IFR5cGVFcnJvcihcIi5vbm54LlRlbnNvclByb3RvLmludDMyRGF0YTogYXJyYXkgZXhwZWN0ZWRcIik7Zm9yKGUuaW50MzJEYXRhPVtdLG49MDtuPHQuaW50MzJEYXRhLmxlbmd0aDsrK24pZS5pbnQzMkRhdGFbbl09MHx0LmludDMyRGF0YVtuXX1pZih0LnN0cmluZ0RhdGEpe2lmKCFBcnJheS5pc0FycmF5KHQuc3RyaW5nRGF0YSkpdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguVGVuc29yUHJvdG8uc3RyaW5nRGF0YTogYXJyYXkgZXhwZWN0ZWRcIik7Zm9yKGUuc3RyaW5nRGF0YT1bXSxuPTA7bjx0LnN0cmluZ0RhdGEubGVuZ3RoOysrbilcInN0cmluZ1wiPT10eXBlb2YgdC5zdHJpbmdEYXRhW25dP2MuYmFzZTY0LmRlY29kZSh0LnN0cmluZ0RhdGFbbl0sZS5zdHJpbmdEYXRhW25dPWMubmV3QnVmZmVyKGMuYmFzZTY0Lmxlbmd0aCh0LnN0cmluZ0RhdGFbbl0pKSwwKTp0LnN0cmluZ0RhdGFbbl0ubGVuZ3RoJiYoZS5zdHJpbmdEYXRhW25dPXQuc3RyaW5nRGF0YVtuXSl9aWYodC5pbnQ2NERhdGEpe2lmKCFBcnJheS5pc0FycmF5KHQuaW50NjREYXRhKSl0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5UZW5zb3JQcm90by5pbnQ2NERhdGE6IGFycmF5IGV4cGVjdGVkXCIpO2ZvcihlLmludDY0RGF0YT1bXSxuPTA7bjx0LmludDY0RGF0YS5sZW5ndGg7KytuKWMuTG9uZz8oZS5pbnQ2NERhdGFbbl09Yy5Mb25nLmZyb21WYWx1ZSh0LmludDY0RGF0YVtuXSkpLnVuc2lnbmVkPSExOlwic3RyaW5nXCI9PXR5cGVvZiB0LmludDY0RGF0YVtuXT9lLmludDY0RGF0YVtuXT1wYXJzZUludCh0LmludDY0RGF0YVtuXSwxMCk6XCJudW1iZXJcIj09dHlwZW9mIHQuaW50NjREYXRhW25dP2UuaW50NjREYXRhW25dPXQuaW50NjREYXRhW25dOlwib2JqZWN0XCI9PXR5cGVvZiB0LmludDY0RGF0YVtuXSYmKGUuaW50NjREYXRhW25dPW5ldyBjLkxvbmdCaXRzKHQuaW50NjREYXRhW25dLmxvdz4+PjAsdC5pbnQ2NERhdGFbbl0uaGlnaD4+PjApLnRvTnVtYmVyKCkpfWlmKG51bGwhPXQubmFtZSYmKGUubmFtZT1TdHJpbmcodC5uYW1lKSksbnVsbCE9dC5kb2NTdHJpbmcmJihlLmRvY1N0cmluZz1TdHJpbmcodC5kb2NTdHJpbmcpKSxudWxsIT10LnJhd0RhdGEmJihcInN0cmluZ1wiPT10eXBlb2YgdC5yYXdEYXRhP2MuYmFzZTY0LmRlY29kZSh0LnJhd0RhdGEsZS5yYXdEYXRhPWMubmV3QnVmZmVyKGMuYmFzZTY0Lmxlbmd0aCh0LnJhd0RhdGEpKSwwKTp0LnJhd0RhdGEubGVuZ3RoJiYoZS5yYXdEYXRhPXQucmF3RGF0YSkpLHQuZXh0ZXJuYWxEYXRhKXtpZighQXJyYXkuaXNBcnJheSh0LmV4dGVybmFsRGF0YSkpdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguVGVuc29yUHJvdG8uZXh0ZXJuYWxEYXRhOiBhcnJheSBleHBlY3RlZFwiKTtmb3IoZS5leHRlcm5hbERhdGE9W10sbj0wO248dC5leHRlcm5hbERhdGEubGVuZ3RoOysrbil7aWYoXCJvYmplY3RcIiE9dHlwZW9mIHQuZXh0ZXJuYWxEYXRhW25dKXRocm93IFR5cGVFcnJvcihcIi5vbm54LlRlbnNvclByb3RvLmV4dGVybmFsRGF0YTogb2JqZWN0IGV4cGVjdGVkXCIpO2UuZXh0ZXJuYWxEYXRhW25dPWwub25ueC5TdHJpbmdTdHJpbmdFbnRyeVByb3RvLmZyb21PYmplY3QodC5leHRlcm5hbERhdGFbbl0pfX1zd2l0Y2godC5kYXRhTG9jYXRpb24pe2Nhc2VcIkRFRkFVTFRcIjpjYXNlIDA6ZS5kYXRhTG9jYXRpb249MDticmVhaztjYXNlXCJFWFRFUk5BTFwiOmNhc2UgMTplLmRhdGFMb2NhdGlvbj0xfWlmKHQuZG91YmxlRGF0YSl7aWYoIUFycmF5LmlzQXJyYXkodC5kb3VibGVEYXRhKSl0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5UZW5zb3JQcm90by5kb3VibGVEYXRhOiBhcnJheSBleHBlY3RlZFwiKTtmb3IoZS5kb3VibGVEYXRhPVtdLG49MDtuPHQuZG91YmxlRGF0YS5sZW5ndGg7KytuKWUuZG91YmxlRGF0YVtuXT1OdW1iZXIodC5kb3VibGVEYXRhW25dKX1pZih0LnVpbnQ2NERhdGEpe2lmKCFBcnJheS5pc0FycmF5KHQudWludDY0RGF0YSkpdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguVGVuc29yUHJvdG8udWludDY0RGF0YTogYXJyYXkgZXhwZWN0ZWRcIik7Zm9yKGUudWludDY0RGF0YT1bXSxuPTA7bjx0LnVpbnQ2NERhdGEubGVuZ3RoOysrbiljLkxvbmc/KGUudWludDY0RGF0YVtuXT1jLkxvbmcuZnJvbVZhbHVlKHQudWludDY0RGF0YVtuXSkpLnVuc2lnbmVkPSEwOlwic3RyaW5nXCI9PXR5cGVvZiB0LnVpbnQ2NERhdGFbbl0/ZS51aW50NjREYXRhW25dPXBhcnNlSW50KHQudWludDY0RGF0YVtuXSwxMCk6XCJudW1iZXJcIj09dHlwZW9mIHQudWludDY0RGF0YVtuXT9lLnVpbnQ2NERhdGFbbl09dC51aW50NjREYXRhW25dOlwib2JqZWN0XCI9PXR5cGVvZiB0LnVpbnQ2NERhdGFbbl0mJihlLnVpbnQ2NERhdGFbbl09bmV3IGMuTG9uZ0JpdHModC51aW50NjREYXRhW25dLmxvdz4+PjAsdC51aW50NjREYXRhW25dLmhpZ2g+Pj4wKS50b051bWJlcighMCkpfXJldHVybiBlfSx0LnRvT2JqZWN0PWZ1bmN0aW9uKHQsZSl7ZXx8KGU9e30pO3ZhciBuPXt9O2lmKChlLmFycmF5c3x8ZS5kZWZhdWx0cykmJihuLmRpbXM9W10sbi5mbG9hdERhdGE9W10sbi5pbnQzMkRhdGE9W10sbi5zdHJpbmdEYXRhPVtdLG4uaW50NjREYXRhPVtdLG4uZG91YmxlRGF0YT1bXSxuLnVpbnQ2NERhdGE9W10sbi5leHRlcm5hbERhdGE9W10pLGUuZGVmYXVsdHMmJihuLmRhdGFUeXBlPTAsbi5zZWdtZW50PW51bGwsbi5uYW1lPVwiXCIsZS5ieXRlcz09PVN0cmluZz9uLnJhd0RhdGE9XCJcIjoobi5yYXdEYXRhPVtdLGUuYnl0ZXMhPT1BcnJheSYmKG4ucmF3RGF0YT1jLm5ld0J1ZmZlcihuLnJhd0RhdGEpKSksbi5kb2NTdHJpbmc9XCJcIixuLmRhdGFMb2NhdGlvbj1lLmVudW1zPT09U3RyaW5nP1wiREVGQVVMVFwiOjApLHQuZGltcyYmdC5kaW1zLmxlbmd0aCl7bi5kaW1zPVtdO2Zvcih2YXIgcj0wO3I8dC5kaW1zLmxlbmd0aDsrK3IpXCJudW1iZXJcIj09dHlwZW9mIHQuZGltc1tyXT9uLmRpbXNbcl09ZS5sb25ncz09PVN0cmluZz9TdHJpbmcodC5kaW1zW3JdKTp0LmRpbXNbcl06bi5kaW1zW3JdPWUubG9uZ3M9PT1TdHJpbmc/Yy5Mb25nLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHQuZGltc1tyXSk6ZS5sb25ncz09PU51bWJlcj9uZXcgYy5Mb25nQml0cyh0LmRpbXNbcl0ubG93Pj4+MCx0LmRpbXNbcl0uaGlnaD4+PjApLnRvTnVtYmVyKCk6dC5kaW1zW3JdfWlmKG51bGwhPXQuZGF0YVR5cGUmJnQuaGFzT3duUHJvcGVydHkoXCJkYXRhVHlwZVwiKSYmKG4uZGF0YVR5cGU9dC5kYXRhVHlwZSksbnVsbCE9dC5zZWdtZW50JiZ0Lmhhc093blByb3BlcnR5KFwic2VnbWVudFwiKSYmKG4uc2VnbWVudD1sLm9ubnguVGVuc29yUHJvdG8uU2VnbWVudC50b09iamVjdCh0LnNlZ21lbnQsZSkpLHQuZmxvYXREYXRhJiZ0LmZsb2F0RGF0YS5sZW5ndGgpZm9yKG4uZmxvYXREYXRhPVtdLHI9MDtyPHQuZmxvYXREYXRhLmxlbmd0aDsrK3Ipbi5mbG9hdERhdGFbcl09ZS5qc29uJiYhaXNGaW5pdGUodC5mbG9hdERhdGFbcl0pP1N0cmluZyh0LmZsb2F0RGF0YVtyXSk6dC5mbG9hdERhdGFbcl07aWYodC5pbnQzMkRhdGEmJnQuaW50MzJEYXRhLmxlbmd0aClmb3Iobi5pbnQzMkRhdGE9W10scj0wO3I8dC5pbnQzMkRhdGEubGVuZ3RoOysrciluLmludDMyRGF0YVtyXT10LmludDMyRGF0YVtyXTtpZih0LnN0cmluZ0RhdGEmJnQuc3RyaW5nRGF0YS5sZW5ndGgpZm9yKG4uc3RyaW5nRGF0YT1bXSxyPTA7cjx0LnN0cmluZ0RhdGEubGVuZ3RoOysrciluLnN0cmluZ0RhdGFbcl09ZS5ieXRlcz09PVN0cmluZz9jLmJhc2U2NC5lbmNvZGUodC5zdHJpbmdEYXRhW3JdLDAsdC5zdHJpbmdEYXRhW3JdLmxlbmd0aCk6ZS5ieXRlcz09PUFycmF5P0FycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHQuc3RyaW5nRGF0YVtyXSk6dC5zdHJpbmdEYXRhW3JdO2lmKHQuaW50NjREYXRhJiZ0LmludDY0RGF0YS5sZW5ndGgpZm9yKG4uaW50NjREYXRhPVtdLHI9MDtyPHQuaW50NjREYXRhLmxlbmd0aDsrK3IpXCJudW1iZXJcIj09dHlwZW9mIHQuaW50NjREYXRhW3JdP24uaW50NjREYXRhW3JdPWUubG9uZ3M9PT1TdHJpbmc/U3RyaW5nKHQuaW50NjREYXRhW3JdKTp0LmludDY0RGF0YVtyXTpuLmludDY0RGF0YVtyXT1lLmxvbmdzPT09U3RyaW5nP2MuTG9uZy5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0LmludDY0RGF0YVtyXSk6ZS5sb25ncz09PU51bWJlcj9uZXcgYy5Mb25nQml0cyh0LmludDY0RGF0YVtyXS5sb3c+Pj4wLHQuaW50NjREYXRhW3JdLmhpZ2g+Pj4wKS50b051bWJlcigpOnQuaW50NjREYXRhW3JdO2lmKG51bGwhPXQubmFtZSYmdC5oYXNPd25Qcm9wZXJ0eShcIm5hbWVcIikmJihuLm5hbWU9dC5uYW1lKSxudWxsIT10LnJhd0RhdGEmJnQuaGFzT3duUHJvcGVydHkoXCJyYXdEYXRhXCIpJiYobi5yYXdEYXRhPWUuYnl0ZXM9PT1TdHJpbmc/Yy5iYXNlNjQuZW5jb2RlKHQucmF3RGF0YSwwLHQucmF3RGF0YS5sZW5ndGgpOmUuYnl0ZXM9PT1BcnJheT9BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0LnJhd0RhdGEpOnQucmF3RGF0YSksdC5kb3VibGVEYXRhJiZ0LmRvdWJsZURhdGEubGVuZ3RoKWZvcihuLmRvdWJsZURhdGE9W10scj0wO3I8dC5kb3VibGVEYXRhLmxlbmd0aDsrK3Ipbi5kb3VibGVEYXRhW3JdPWUuanNvbiYmIWlzRmluaXRlKHQuZG91YmxlRGF0YVtyXSk/U3RyaW5nKHQuZG91YmxlRGF0YVtyXSk6dC5kb3VibGVEYXRhW3JdO2lmKHQudWludDY0RGF0YSYmdC51aW50NjREYXRhLmxlbmd0aClmb3Iobi51aW50NjREYXRhPVtdLHI9MDtyPHQudWludDY0RGF0YS5sZW5ndGg7KytyKVwibnVtYmVyXCI9PXR5cGVvZiB0LnVpbnQ2NERhdGFbcl0/bi51aW50NjREYXRhW3JdPWUubG9uZ3M9PT1TdHJpbmc/U3RyaW5nKHQudWludDY0RGF0YVtyXSk6dC51aW50NjREYXRhW3JdOm4udWludDY0RGF0YVtyXT1lLmxvbmdzPT09U3RyaW5nP2MuTG9uZy5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0LnVpbnQ2NERhdGFbcl0pOmUubG9uZ3M9PT1OdW1iZXI/bmV3IGMuTG9uZ0JpdHModC51aW50NjREYXRhW3JdLmxvdz4+PjAsdC51aW50NjREYXRhW3JdLmhpZ2g+Pj4wKS50b051bWJlcighMCk6dC51aW50NjREYXRhW3JdO2lmKG51bGwhPXQuZG9jU3RyaW5nJiZ0Lmhhc093blByb3BlcnR5KFwiZG9jU3RyaW5nXCIpJiYobi5kb2NTdHJpbmc9dC5kb2NTdHJpbmcpLHQuZXh0ZXJuYWxEYXRhJiZ0LmV4dGVybmFsRGF0YS5sZW5ndGgpZm9yKG4uZXh0ZXJuYWxEYXRhPVtdLHI9MDtyPHQuZXh0ZXJuYWxEYXRhLmxlbmd0aDsrK3Ipbi5leHRlcm5hbERhdGFbcl09bC5vbm54LlN0cmluZ1N0cmluZ0VudHJ5UHJvdG8udG9PYmplY3QodC5leHRlcm5hbERhdGFbcl0sZSk7cmV0dXJuIG51bGwhPXQuZGF0YUxvY2F0aW9uJiZ0Lmhhc093blByb3BlcnR5KFwiZGF0YUxvY2F0aW9uXCIpJiYobi5kYXRhTG9jYXRpb249ZS5lbnVtcz09PVN0cmluZz9sLm9ubnguVGVuc29yUHJvdG8uRGF0YUxvY2F0aW9uW3QuZGF0YUxvY2F0aW9uXTp0LmRhdGFMb2NhdGlvbiksbn0sdC5wcm90b3R5cGUudG9KU09OPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY29uc3RydWN0b3IudG9PYmplY3QodGhpcyxhLnV0aWwudG9KU09OT3B0aW9ucyl9LHQuRGF0YVR5cGU9ZnVuY3Rpb24oKXt2YXIgdD17fSxlPU9iamVjdC5jcmVhdGUodCk7cmV0dXJuIGVbdFswXT1cIlVOREVGSU5FRFwiXT0wLGVbdFsxXT1cIkZMT0FUXCJdPTEsZVt0WzJdPVwiVUlOVDhcIl09MixlW3RbM109XCJJTlQ4XCJdPTMsZVt0WzRdPVwiVUlOVDE2XCJdPTQsZVt0WzVdPVwiSU5UMTZcIl09NSxlW3RbNl09XCJJTlQzMlwiXT02LGVbdFs3XT1cIklOVDY0XCJdPTcsZVt0WzhdPVwiU1RSSU5HXCJdPTgsZVt0WzldPVwiQk9PTFwiXT05LGVbdFsxMF09XCJGTE9BVDE2XCJdPTEwLGVbdFsxMV09XCJET1VCTEVcIl09MTEsZVt0WzEyXT1cIlVJTlQzMlwiXT0xMixlW3RbMTNdPVwiVUlOVDY0XCJdPTEzLGVbdFsxNF09XCJDT01QTEVYNjRcIl09MTQsZVt0WzE1XT1cIkNPTVBMRVgxMjhcIl09MTUsZVt0WzE2XT1cIkJGTE9BVDE2XCJdPTE2LGV9KCksdC5TZWdtZW50PWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0KXtpZih0KWZvcih2YXIgZT1PYmplY3Qua2V5cyh0KSxuPTA7bjxlLmxlbmd0aDsrK24pbnVsbCE9dFtlW25dXSYmKHRoaXNbZVtuXV09dFtlW25dXSl9cmV0dXJuIHQucHJvdG90eXBlLmJlZ2luPWMuTG9uZz9jLkxvbmcuZnJvbUJpdHMoMCwwLCExKTowLHQucHJvdG90eXBlLmVuZD1jLkxvbmc/Yy5Mb25nLmZyb21CaXRzKDAsMCwhMSk6MCx0LmNyZWF0ZT1mdW5jdGlvbihlKXtyZXR1cm4gbmV3IHQoZSl9LHQuZW5jb2RlPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIGV8fChlPXUuY3JlYXRlKCkpLG51bGwhPXQuYmVnaW4mJnQuaGFzT3duUHJvcGVydHkoXCJiZWdpblwiKSYmZS51aW50MzIoOCkuaW50NjQodC5iZWdpbiksbnVsbCE9dC5lbmQmJnQuaGFzT3duUHJvcGVydHkoXCJlbmRcIikmJmUudWludDMyKDE2KS5pbnQ2NCh0LmVuZCksZX0sdC5lbmNvZGVEZWxpbWl0ZWQ9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5lbmNvZGUodCxlKS5sZGVsaW0oKX0sdC5kZWNvZGU9ZnVuY3Rpb24odCxlKXt0IGluc3RhbmNlb2Ygc3x8KHQ9cy5jcmVhdGUodCkpO2Zvcih2YXIgbj12b2lkIDA9PT1lP3QubGVuOnQucG9zK2Uscj1uZXcgbC5vbm54LlRlbnNvclByb3RvLlNlZ21lbnQ7dC5wb3M8bjspe3ZhciBpPXQudWludDMyKCk7c3dpdGNoKGk+Pj4zKXtjYXNlIDE6ci5iZWdpbj10LmludDY0KCk7YnJlYWs7Y2FzZSAyOnIuZW5kPXQuaW50NjQoKTticmVhaztkZWZhdWx0OnQuc2tpcFR5cGUoNyZpKX19cmV0dXJuIHJ9LHQuZGVjb2RlRGVsaW1pdGVkPWZ1bmN0aW9uKHQpe3JldHVybiB0IGluc3RhbmNlb2Ygc3x8KHQ9bmV3IHModCkpLHRoaXMuZGVjb2RlKHQsdC51aW50MzIoKSl9LHQudmVyaWZ5PWZ1bmN0aW9uKHQpe3JldHVyblwib2JqZWN0XCIhPXR5cGVvZiB0fHxudWxsPT09dD9cIm9iamVjdCBleHBlY3RlZFwiOm51bGwhPXQuYmVnaW4mJnQuaGFzT3duUHJvcGVydHkoXCJiZWdpblwiKSYmIShjLmlzSW50ZWdlcih0LmJlZ2luKXx8dC5iZWdpbiYmYy5pc0ludGVnZXIodC5iZWdpbi5sb3cpJiZjLmlzSW50ZWdlcih0LmJlZ2luLmhpZ2gpKT9cImJlZ2luOiBpbnRlZ2VyfExvbmcgZXhwZWN0ZWRcIjpudWxsIT10LmVuZCYmdC5oYXNPd25Qcm9wZXJ0eShcImVuZFwiKSYmIShjLmlzSW50ZWdlcih0LmVuZCl8fHQuZW5kJiZjLmlzSW50ZWdlcih0LmVuZC5sb3cpJiZjLmlzSW50ZWdlcih0LmVuZC5oaWdoKSk/XCJlbmQ6IGludGVnZXJ8TG9uZyBleHBlY3RlZFwiOm51bGx9LHQuZnJvbU9iamVjdD1mdW5jdGlvbih0KXtpZih0IGluc3RhbmNlb2YgbC5vbm54LlRlbnNvclByb3RvLlNlZ21lbnQpcmV0dXJuIHQ7dmFyIGU9bmV3IGwub25ueC5UZW5zb3JQcm90by5TZWdtZW50O3JldHVybiBudWxsIT10LmJlZ2luJiYoYy5Mb25nPyhlLmJlZ2luPWMuTG9uZy5mcm9tVmFsdWUodC5iZWdpbikpLnVuc2lnbmVkPSExOlwic3RyaW5nXCI9PXR5cGVvZiB0LmJlZ2luP2UuYmVnaW49cGFyc2VJbnQodC5iZWdpbiwxMCk6XCJudW1iZXJcIj09dHlwZW9mIHQuYmVnaW4/ZS5iZWdpbj10LmJlZ2luOlwib2JqZWN0XCI9PXR5cGVvZiB0LmJlZ2luJiYoZS5iZWdpbj1uZXcgYy5Mb25nQml0cyh0LmJlZ2luLmxvdz4+PjAsdC5iZWdpbi5oaWdoPj4+MCkudG9OdW1iZXIoKSkpLG51bGwhPXQuZW5kJiYoYy5Mb25nPyhlLmVuZD1jLkxvbmcuZnJvbVZhbHVlKHQuZW5kKSkudW5zaWduZWQ9ITE6XCJzdHJpbmdcIj09dHlwZW9mIHQuZW5kP2UuZW5kPXBhcnNlSW50KHQuZW5kLDEwKTpcIm51bWJlclwiPT10eXBlb2YgdC5lbmQ/ZS5lbmQ9dC5lbmQ6XCJvYmplY3RcIj09dHlwZW9mIHQuZW5kJiYoZS5lbmQ9bmV3IGMuTG9uZ0JpdHModC5lbmQubG93Pj4+MCx0LmVuZC5oaWdoPj4+MCkudG9OdW1iZXIoKSkpLGV9LHQudG9PYmplY3Q9ZnVuY3Rpb24odCxlKXtlfHwoZT17fSk7dmFyIG49e307aWYoZS5kZWZhdWx0cyl7aWYoYy5Mb25nKXt2YXIgcj1uZXcgYy5Mb25nKDAsMCwhMSk7bi5iZWdpbj1lLmxvbmdzPT09U3RyaW5nP3IudG9TdHJpbmcoKTplLmxvbmdzPT09TnVtYmVyP3IudG9OdW1iZXIoKTpyfWVsc2Ugbi5iZWdpbj1lLmxvbmdzPT09U3RyaW5nP1wiMFwiOjA7Yy5Mb25nPyhyPW5ldyBjLkxvbmcoMCwwLCExKSxuLmVuZD1lLmxvbmdzPT09U3RyaW5nP3IudG9TdHJpbmcoKTplLmxvbmdzPT09TnVtYmVyP3IudG9OdW1iZXIoKTpyKTpuLmVuZD1lLmxvbmdzPT09U3RyaW5nP1wiMFwiOjB9cmV0dXJuIG51bGwhPXQuYmVnaW4mJnQuaGFzT3duUHJvcGVydHkoXCJiZWdpblwiKSYmKFwibnVtYmVyXCI9PXR5cGVvZiB0LmJlZ2luP24uYmVnaW49ZS5sb25ncz09PVN0cmluZz9TdHJpbmcodC5iZWdpbik6dC5iZWdpbjpuLmJlZ2luPWUubG9uZ3M9PT1TdHJpbmc/Yy5Mb25nLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHQuYmVnaW4pOmUubG9uZ3M9PT1OdW1iZXI/bmV3IGMuTG9uZ0JpdHModC5iZWdpbi5sb3c+Pj4wLHQuYmVnaW4uaGlnaD4+PjApLnRvTnVtYmVyKCk6dC5iZWdpbiksbnVsbCE9dC5lbmQmJnQuaGFzT3duUHJvcGVydHkoXCJlbmRcIikmJihcIm51bWJlclwiPT10eXBlb2YgdC5lbmQ/bi5lbmQ9ZS5sb25ncz09PVN0cmluZz9TdHJpbmcodC5lbmQpOnQuZW5kOm4uZW5kPWUubG9uZ3M9PT1TdHJpbmc/Yy5Mb25nLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHQuZW5kKTplLmxvbmdzPT09TnVtYmVyP25ldyBjLkxvbmdCaXRzKHQuZW5kLmxvdz4+PjAsdC5lbmQuaGlnaD4+PjApLnRvTnVtYmVyKCk6dC5lbmQpLG59LHQucHJvdG90eXBlLnRvSlNPTj1mdW5jdGlvbigpe3JldHVybiB0aGlzLmNvbnN0cnVjdG9yLnRvT2JqZWN0KHRoaXMsYS51dGlsLnRvSlNPTk9wdGlvbnMpfSx0fSgpLHQuRGF0YUxvY2F0aW9uPWZ1bmN0aW9uKCl7dmFyIHQ9e30sZT1PYmplY3QuY3JlYXRlKHQpO3JldHVybiBlW3RbMF09XCJERUZBVUxUXCJdPTAsZVt0WzFdPVwiRVhURVJOQUxcIl09MSxlfSgpLHR9KCksby5UZW5zb3JTaGFwZVByb3RvPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0KXtpZih0aGlzLmRpbT1bXSx0KWZvcih2YXIgZT1PYmplY3Qua2V5cyh0KSxuPTA7bjxlLmxlbmd0aDsrK24pbnVsbCE9dFtlW25dXSYmKHRoaXNbZVtuXV09dFtlW25dXSl9cmV0dXJuIHQucHJvdG90eXBlLmRpbT1jLmVtcHR5QXJyYXksdC5jcmVhdGU9ZnVuY3Rpb24oZSl7cmV0dXJuIG5ldyB0KGUpfSx0LmVuY29kZT1mdW5jdGlvbih0LGUpe2lmKGV8fChlPXUuY3JlYXRlKCkpLG51bGwhPXQuZGltJiZ0LmRpbS5sZW5ndGgpZm9yKHZhciBuPTA7bjx0LmRpbS5sZW5ndGg7KytuKWwub25ueC5UZW5zb3JTaGFwZVByb3RvLkRpbWVuc2lvbi5lbmNvZGUodC5kaW1bbl0sZS51aW50MzIoMTApLmZvcmsoKSkubGRlbGltKCk7cmV0dXJuIGV9LHQuZW5jb2RlRGVsaW1pdGVkPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMuZW5jb2RlKHQsZSkubGRlbGltKCl9LHQuZGVjb2RlPWZ1bmN0aW9uKHQsZSl7dCBpbnN0YW5jZW9mIHN8fCh0PXMuY3JlYXRlKHQpKTtmb3IodmFyIG49dm9pZCAwPT09ZT90Lmxlbjp0LnBvcytlLHI9bmV3IGwub25ueC5UZW5zb3JTaGFwZVByb3RvO3QucG9zPG47KXt2YXIgaT10LnVpbnQzMigpO2k+Pj4zPT0xPyhyLmRpbSYmci5kaW0ubGVuZ3RofHwoci5kaW09W10pLHIuZGltLnB1c2gobC5vbm54LlRlbnNvclNoYXBlUHJvdG8uRGltZW5zaW9uLmRlY29kZSh0LHQudWludDMyKCkpKSk6dC5za2lwVHlwZSg3JmkpfXJldHVybiByfSx0LmRlY29kZURlbGltaXRlZD1mdW5jdGlvbih0KXtyZXR1cm4gdCBpbnN0YW5jZW9mIHN8fCh0PW5ldyBzKHQpKSx0aGlzLmRlY29kZSh0LHQudWludDMyKCkpfSx0LnZlcmlmeT1mdW5jdGlvbih0KXtpZihcIm9iamVjdFwiIT10eXBlb2YgdHx8bnVsbD09PXQpcmV0dXJuXCJvYmplY3QgZXhwZWN0ZWRcIjtpZihudWxsIT10LmRpbSYmdC5oYXNPd25Qcm9wZXJ0eShcImRpbVwiKSl7aWYoIUFycmF5LmlzQXJyYXkodC5kaW0pKXJldHVyblwiZGltOiBhcnJheSBleHBlY3RlZFwiO2Zvcih2YXIgZT0wO2U8dC5kaW0ubGVuZ3RoOysrZSl7dmFyIG49bC5vbm54LlRlbnNvclNoYXBlUHJvdG8uRGltZW5zaW9uLnZlcmlmeSh0LmRpbVtlXSk7aWYobilyZXR1cm5cImRpbS5cIitufX1yZXR1cm4gbnVsbH0sdC5mcm9tT2JqZWN0PWZ1bmN0aW9uKHQpe2lmKHQgaW5zdGFuY2VvZiBsLm9ubnguVGVuc29yU2hhcGVQcm90bylyZXR1cm4gdDt2YXIgZT1uZXcgbC5vbm54LlRlbnNvclNoYXBlUHJvdG87aWYodC5kaW0pe2lmKCFBcnJheS5pc0FycmF5KHQuZGltKSl0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5UZW5zb3JTaGFwZVByb3RvLmRpbTogYXJyYXkgZXhwZWN0ZWRcIik7ZS5kaW09W107Zm9yKHZhciBuPTA7bjx0LmRpbS5sZW5ndGg7KytuKXtpZihcIm9iamVjdFwiIT10eXBlb2YgdC5kaW1bbl0pdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguVGVuc29yU2hhcGVQcm90by5kaW06IG9iamVjdCBleHBlY3RlZFwiKTtlLmRpbVtuXT1sLm9ubnguVGVuc29yU2hhcGVQcm90by5EaW1lbnNpb24uZnJvbU9iamVjdCh0LmRpbVtuXSl9fXJldHVybiBlfSx0LnRvT2JqZWN0PWZ1bmN0aW9uKHQsZSl7ZXx8KGU9e30pO3ZhciBuPXt9O2lmKChlLmFycmF5c3x8ZS5kZWZhdWx0cykmJihuLmRpbT1bXSksdC5kaW0mJnQuZGltLmxlbmd0aCl7bi5kaW09W107Zm9yKHZhciByPTA7cjx0LmRpbS5sZW5ndGg7KytyKW4uZGltW3JdPWwub25ueC5UZW5zb3JTaGFwZVByb3RvLkRpbWVuc2lvbi50b09iamVjdCh0LmRpbVtyXSxlKX1yZXR1cm4gbn0sdC5wcm90b3R5cGUudG9KU09OPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY29uc3RydWN0b3IudG9PYmplY3QodGhpcyxhLnV0aWwudG9KU09OT3B0aW9ucyl9LHQuRGltZW5zaW9uPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0KXtpZih0KWZvcih2YXIgZT1PYmplY3Qua2V5cyh0KSxuPTA7bjxlLmxlbmd0aDsrK24pbnVsbCE9dFtlW25dXSYmKHRoaXNbZVtuXV09dFtlW25dXSl9dmFyIGU7cmV0dXJuIHQucHJvdG90eXBlLmRpbVZhbHVlPWMuTG9uZz9jLkxvbmcuZnJvbUJpdHMoMCwwLCExKTowLHQucHJvdG90eXBlLmRpbVBhcmFtPVwiXCIsdC5wcm90b3R5cGUuZGVub3RhdGlvbj1cIlwiLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LnByb3RvdHlwZSxcInZhbHVlXCIse2dldDpjLm9uZU9mR2V0dGVyKGU9W1wiZGltVmFsdWVcIixcImRpbVBhcmFtXCJdKSxzZXQ6Yy5vbmVPZlNldHRlcihlKX0pLHQuY3JlYXRlPWZ1bmN0aW9uKGUpe3JldHVybiBuZXcgdChlKX0sdC5lbmNvZGU9ZnVuY3Rpb24odCxlKXtyZXR1cm4gZXx8KGU9dS5jcmVhdGUoKSksbnVsbCE9dC5kaW1WYWx1ZSYmdC5oYXNPd25Qcm9wZXJ0eShcImRpbVZhbHVlXCIpJiZlLnVpbnQzMig4KS5pbnQ2NCh0LmRpbVZhbHVlKSxudWxsIT10LmRpbVBhcmFtJiZ0Lmhhc093blByb3BlcnR5KFwiZGltUGFyYW1cIikmJmUudWludDMyKDE4KS5zdHJpbmcodC5kaW1QYXJhbSksbnVsbCE9dC5kZW5vdGF0aW9uJiZ0Lmhhc093blByb3BlcnR5KFwiZGVub3RhdGlvblwiKSYmZS51aW50MzIoMjYpLnN0cmluZyh0LmRlbm90YXRpb24pLGV9LHQuZW5jb2RlRGVsaW1pdGVkPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMuZW5jb2RlKHQsZSkubGRlbGltKCl9LHQuZGVjb2RlPWZ1bmN0aW9uKHQsZSl7dCBpbnN0YW5jZW9mIHN8fCh0PXMuY3JlYXRlKHQpKTtmb3IodmFyIG49dm9pZCAwPT09ZT90Lmxlbjp0LnBvcytlLHI9bmV3IGwub25ueC5UZW5zb3JTaGFwZVByb3RvLkRpbWVuc2lvbjt0LnBvczxuOyl7dmFyIGk9dC51aW50MzIoKTtzd2l0Y2goaT4+PjMpe2Nhc2UgMTpyLmRpbVZhbHVlPXQuaW50NjQoKTticmVhaztjYXNlIDI6ci5kaW1QYXJhbT10LnN0cmluZygpO2JyZWFrO2Nhc2UgMzpyLmRlbm90YXRpb249dC5zdHJpbmcoKTticmVhaztkZWZhdWx0OnQuc2tpcFR5cGUoNyZpKX19cmV0dXJuIHJ9LHQuZGVjb2RlRGVsaW1pdGVkPWZ1bmN0aW9uKHQpe3JldHVybiB0IGluc3RhbmNlb2Ygc3x8KHQ9bmV3IHModCkpLHRoaXMuZGVjb2RlKHQsdC51aW50MzIoKSl9LHQudmVyaWZ5PWZ1bmN0aW9uKHQpe2lmKFwib2JqZWN0XCIhPXR5cGVvZiB0fHxudWxsPT09dClyZXR1cm5cIm9iamVjdCBleHBlY3RlZFwiO3ZhciBlPXt9O2lmKG51bGwhPXQuZGltVmFsdWUmJnQuaGFzT3duUHJvcGVydHkoXCJkaW1WYWx1ZVwiKSYmKGUudmFsdWU9MSwhKGMuaXNJbnRlZ2VyKHQuZGltVmFsdWUpfHx0LmRpbVZhbHVlJiZjLmlzSW50ZWdlcih0LmRpbVZhbHVlLmxvdykmJmMuaXNJbnRlZ2VyKHQuZGltVmFsdWUuaGlnaCkpKSlyZXR1cm5cImRpbVZhbHVlOiBpbnRlZ2VyfExvbmcgZXhwZWN0ZWRcIjtpZihudWxsIT10LmRpbVBhcmFtJiZ0Lmhhc093blByb3BlcnR5KFwiZGltUGFyYW1cIikpe2lmKDE9PT1lLnZhbHVlKXJldHVyblwidmFsdWU6IG11bHRpcGxlIHZhbHVlc1wiO2lmKGUudmFsdWU9MSwhYy5pc1N0cmluZyh0LmRpbVBhcmFtKSlyZXR1cm5cImRpbVBhcmFtOiBzdHJpbmcgZXhwZWN0ZWRcIn1yZXR1cm4gbnVsbCE9dC5kZW5vdGF0aW9uJiZ0Lmhhc093blByb3BlcnR5KFwiZGVub3RhdGlvblwiKSYmIWMuaXNTdHJpbmcodC5kZW5vdGF0aW9uKT9cImRlbm90YXRpb246IHN0cmluZyBleHBlY3RlZFwiOm51bGx9LHQuZnJvbU9iamVjdD1mdW5jdGlvbih0KXtpZih0IGluc3RhbmNlb2YgbC5vbm54LlRlbnNvclNoYXBlUHJvdG8uRGltZW5zaW9uKXJldHVybiB0O3ZhciBlPW5ldyBsLm9ubnguVGVuc29yU2hhcGVQcm90by5EaW1lbnNpb247cmV0dXJuIG51bGwhPXQuZGltVmFsdWUmJihjLkxvbmc/KGUuZGltVmFsdWU9Yy5Mb25nLmZyb21WYWx1ZSh0LmRpbVZhbHVlKSkudW5zaWduZWQ9ITE6XCJzdHJpbmdcIj09dHlwZW9mIHQuZGltVmFsdWU/ZS5kaW1WYWx1ZT1wYXJzZUludCh0LmRpbVZhbHVlLDEwKTpcIm51bWJlclwiPT10eXBlb2YgdC5kaW1WYWx1ZT9lLmRpbVZhbHVlPXQuZGltVmFsdWU6XCJvYmplY3RcIj09dHlwZW9mIHQuZGltVmFsdWUmJihlLmRpbVZhbHVlPW5ldyBjLkxvbmdCaXRzKHQuZGltVmFsdWUubG93Pj4+MCx0LmRpbVZhbHVlLmhpZ2g+Pj4wKS50b051bWJlcigpKSksbnVsbCE9dC5kaW1QYXJhbSYmKGUuZGltUGFyYW09U3RyaW5nKHQuZGltUGFyYW0pKSxudWxsIT10LmRlbm90YXRpb24mJihlLmRlbm90YXRpb249U3RyaW5nKHQuZGVub3RhdGlvbikpLGV9LHQudG9PYmplY3Q9ZnVuY3Rpb24odCxlKXtlfHwoZT17fSk7dmFyIG49e307cmV0dXJuIGUuZGVmYXVsdHMmJihuLmRlbm90YXRpb249XCJcIiksbnVsbCE9dC5kaW1WYWx1ZSYmdC5oYXNPd25Qcm9wZXJ0eShcImRpbVZhbHVlXCIpJiYoXCJudW1iZXJcIj09dHlwZW9mIHQuZGltVmFsdWU/bi5kaW1WYWx1ZT1lLmxvbmdzPT09U3RyaW5nP1N0cmluZyh0LmRpbVZhbHVlKTp0LmRpbVZhbHVlOm4uZGltVmFsdWU9ZS5sb25ncz09PVN0cmluZz9jLkxvbmcucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodC5kaW1WYWx1ZSk6ZS5sb25ncz09PU51bWJlcj9uZXcgYy5Mb25nQml0cyh0LmRpbVZhbHVlLmxvdz4+PjAsdC5kaW1WYWx1ZS5oaWdoPj4+MCkudG9OdW1iZXIoKTp0LmRpbVZhbHVlLGUub25lb2ZzJiYobi52YWx1ZT1cImRpbVZhbHVlXCIpKSxudWxsIT10LmRpbVBhcmFtJiZ0Lmhhc093blByb3BlcnR5KFwiZGltUGFyYW1cIikmJihuLmRpbVBhcmFtPXQuZGltUGFyYW0sZS5vbmVvZnMmJihuLnZhbHVlPVwiZGltUGFyYW1cIikpLG51bGwhPXQuZGVub3RhdGlvbiYmdC5oYXNPd25Qcm9wZXJ0eShcImRlbm90YXRpb25cIikmJihuLmRlbm90YXRpb249dC5kZW5vdGF0aW9uKSxufSx0LnByb3RvdHlwZS50b0pTT049ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci50b09iamVjdCh0aGlzLGEudXRpbC50b0pTT05PcHRpb25zKX0sdH0oKSx0fSgpLG8uVHlwZVByb3RvPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0KXtpZih0KWZvcih2YXIgZT1PYmplY3Qua2V5cyh0KSxuPTA7bjxlLmxlbmd0aDsrK24pbnVsbCE9dFtlW25dXSYmKHRoaXNbZVtuXV09dFtlW25dXSl9dmFyIGU7cmV0dXJuIHQucHJvdG90eXBlLnRlbnNvclR5cGU9bnVsbCx0LnByb3RvdHlwZS5kZW5vdGF0aW9uPVwiXCIsT2JqZWN0LmRlZmluZVByb3BlcnR5KHQucHJvdG90eXBlLFwidmFsdWVcIix7Z2V0OmMub25lT2ZHZXR0ZXIoZT1bXCJ0ZW5zb3JUeXBlXCJdKSxzZXQ6Yy5vbmVPZlNldHRlcihlKX0pLHQuY3JlYXRlPWZ1bmN0aW9uKGUpe3JldHVybiBuZXcgdChlKX0sdC5lbmNvZGU9ZnVuY3Rpb24odCxlKXtyZXR1cm4gZXx8KGU9dS5jcmVhdGUoKSksbnVsbCE9dC50ZW5zb3JUeXBlJiZ0Lmhhc093blByb3BlcnR5KFwidGVuc29yVHlwZVwiKSYmbC5vbm54LlR5cGVQcm90by5UZW5zb3IuZW5jb2RlKHQudGVuc29yVHlwZSxlLnVpbnQzMigxMCkuZm9yaygpKS5sZGVsaW0oKSxudWxsIT10LmRlbm90YXRpb24mJnQuaGFzT3duUHJvcGVydHkoXCJkZW5vdGF0aW9uXCIpJiZlLnVpbnQzMig1MCkuc3RyaW5nKHQuZGVub3RhdGlvbiksZX0sdC5lbmNvZGVEZWxpbWl0ZWQ9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5lbmNvZGUodCxlKS5sZGVsaW0oKX0sdC5kZWNvZGU9ZnVuY3Rpb24odCxlKXt0IGluc3RhbmNlb2Ygc3x8KHQ9cy5jcmVhdGUodCkpO2Zvcih2YXIgbj12b2lkIDA9PT1lP3QubGVuOnQucG9zK2Uscj1uZXcgbC5vbm54LlR5cGVQcm90bzt0LnBvczxuOyl7dmFyIGk9dC51aW50MzIoKTtzd2l0Y2goaT4+PjMpe2Nhc2UgMTpyLnRlbnNvclR5cGU9bC5vbm54LlR5cGVQcm90by5UZW5zb3IuZGVjb2RlKHQsdC51aW50MzIoKSk7YnJlYWs7Y2FzZSA2OnIuZGVub3RhdGlvbj10LnN0cmluZygpO2JyZWFrO2RlZmF1bHQ6dC5za2lwVHlwZSg3JmkpfX1yZXR1cm4gcn0sdC5kZWNvZGVEZWxpbWl0ZWQ9ZnVuY3Rpb24odCl7cmV0dXJuIHQgaW5zdGFuY2VvZiBzfHwodD1uZXcgcyh0KSksdGhpcy5kZWNvZGUodCx0LnVpbnQzMigpKX0sdC52ZXJpZnk9ZnVuY3Rpb24odCl7aWYoXCJvYmplY3RcIiE9dHlwZW9mIHR8fG51bGw9PT10KXJldHVyblwib2JqZWN0IGV4cGVjdGVkXCI7aWYobnVsbCE9dC50ZW5zb3JUeXBlJiZ0Lmhhc093blByb3BlcnR5KFwidGVuc29yVHlwZVwiKSl7dmFyIGU9bC5vbm54LlR5cGVQcm90by5UZW5zb3IudmVyaWZ5KHQudGVuc29yVHlwZSk7aWYoZSlyZXR1cm5cInRlbnNvclR5cGUuXCIrZX1yZXR1cm4gbnVsbCE9dC5kZW5vdGF0aW9uJiZ0Lmhhc093blByb3BlcnR5KFwiZGVub3RhdGlvblwiKSYmIWMuaXNTdHJpbmcodC5kZW5vdGF0aW9uKT9cImRlbm90YXRpb246IHN0cmluZyBleHBlY3RlZFwiOm51bGx9LHQuZnJvbU9iamVjdD1mdW5jdGlvbih0KXtpZih0IGluc3RhbmNlb2YgbC5vbm54LlR5cGVQcm90bylyZXR1cm4gdDt2YXIgZT1uZXcgbC5vbm54LlR5cGVQcm90bztpZihudWxsIT10LnRlbnNvclR5cGUpe2lmKFwib2JqZWN0XCIhPXR5cGVvZiB0LnRlbnNvclR5cGUpdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguVHlwZVByb3RvLnRlbnNvclR5cGU6IG9iamVjdCBleHBlY3RlZFwiKTtlLnRlbnNvclR5cGU9bC5vbm54LlR5cGVQcm90by5UZW5zb3IuZnJvbU9iamVjdCh0LnRlbnNvclR5cGUpfXJldHVybiBudWxsIT10LmRlbm90YXRpb24mJihlLmRlbm90YXRpb249U3RyaW5nKHQuZGVub3RhdGlvbikpLGV9LHQudG9PYmplY3Q9ZnVuY3Rpb24odCxlKXtlfHwoZT17fSk7dmFyIG49e307cmV0dXJuIGUuZGVmYXVsdHMmJihuLmRlbm90YXRpb249XCJcIiksbnVsbCE9dC50ZW5zb3JUeXBlJiZ0Lmhhc093blByb3BlcnR5KFwidGVuc29yVHlwZVwiKSYmKG4udGVuc29yVHlwZT1sLm9ubnguVHlwZVByb3RvLlRlbnNvci50b09iamVjdCh0LnRlbnNvclR5cGUsZSksZS5vbmVvZnMmJihuLnZhbHVlPVwidGVuc29yVHlwZVwiKSksbnVsbCE9dC5kZW5vdGF0aW9uJiZ0Lmhhc093blByb3BlcnR5KFwiZGVub3RhdGlvblwiKSYmKG4uZGVub3RhdGlvbj10LmRlbm90YXRpb24pLG59LHQucHJvdG90eXBlLnRvSlNPTj1mdW5jdGlvbigpe3JldHVybiB0aGlzLmNvbnN0cnVjdG9yLnRvT2JqZWN0KHRoaXMsYS51dGlsLnRvSlNPTk9wdGlvbnMpfSx0LlRlbnNvcj1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCl7aWYodClmb3IodmFyIGU9T2JqZWN0LmtleXModCksbj0wO248ZS5sZW5ndGg7KytuKW51bGwhPXRbZVtuXV0mJih0aGlzW2Vbbl1dPXRbZVtuXV0pfXJldHVybiB0LnByb3RvdHlwZS5lbGVtVHlwZT0wLHQucHJvdG90eXBlLnNoYXBlPW51bGwsdC5jcmVhdGU9ZnVuY3Rpb24oZSl7cmV0dXJuIG5ldyB0KGUpfSx0LmVuY29kZT1mdW5jdGlvbih0LGUpe3JldHVybiBlfHwoZT11LmNyZWF0ZSgpKSxudWxsIT10LmVsZW1UeXBlJiZ0Lmhhc093blByb3BlcnR5KFwiZWxlbVR5cGVcIikmJmUudWludDMyKDgpLmludDMyKHQuZWxlbVR5cGUpLG51bGwhPXQuc2hhcGUmJnQuaGFzT3duUHJvcGVydHkoXCJzaGFwZVwiKSYmbC5vbm54LlRlbnNvclNoYXBlUHJvdG8uZW5jb2RlKHQuc2hhcGUsZS51aW50MzIoMTgpLmZvcmsoKSkubGRlbGltKCksZX0sdC5lbmNvZGVEZWxpbWl0ZWQ9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5lbmNvZGUodCxlKS5sZGVsaW0oKX0sdC5kZWNvZGU9ZnVuY3Rpb24odCxlKXt0IGluc3RhbmNlb2Ygc3x8KHQ9cy5jcmVhdGUodCkpO2Zvcih2YXIgbj12b2lkIDA9PT1lP3QubGVuOnQucG9zK2Uscj1uZXcgbC5vbm54LlR5cGVQcm90by5UZW5zb3I7dC5wb3M8bjspe3ZhciBpPXQudWludDMyKCk7c3dpdGNoKGk+Pj4zKXtjYXNlIDE6ci5lbGVtVHlwZT10LmludDMyKCk7YnJlYWs7Y2FzZSAyOnIuc2hhcGU9bC5vbm54LlRlbnNvclNoYXBlUHJvdG8uZGVjb2RlKHQsdC51aW50MzIoKSk7YnJlYWs7ZGVmYXVsdDp0LnNraXBUeXBlKDcmaSl9fXJldHVybiByfSx0LmRlY29kZURlbGltaXRlZD1mdW5jdGlvbih0KXtyZXR1cm4gdCBpbnN0YW5jZW9mIHN8fCh0PW5ldyBzKHQpKSx0aGlzLmRlY29kZSh0LHQudWludDMyKCkpfSx0LnZlcmlmeT1mdW5jdGlvbih0KXtpZihcIm9iamVjdFwiIT10eXBlb2YgdHx8bnVsbD09PXQpcmV0dXJuXCJvYmplY3QgZXhwZWN0ZWRcIjtpZihudWxsIT10LmVsZW1UeXBlJiZ0Lmhhc093blByb3BlcnR5KFwiZWxlbVR5cGVcIikmJiFjLmlzSW50ZWdlcih0LmVsZW1UeXBlKSlyZXR1cm5cImVsZW1UeXBlOiBpbnRlZ2VyIGV4cGVjdGVkXCI7aWYobnVsbCE9dC5zaGFwZSYmdC5oYXNPd25Qcm9wZXJ0eShcInNoYXBlXCIpKXt2YXIgZT1sLm9ubnguVGVuc29yU2hhcGVQcm90by52ZXJpZnkodC5zaGFwZSk7aWYoZSlyZXR1cm5cInNoYXBlLlwiK2V9cmV0dXJuIG51bGx9LHQuZnJvbU9iamVjdD1mdW5jdGlvbih0KXtpZih0IGluc3RhbmNlb2YgbC5vbm54LlR5cGVQcm90by5UZW5zb3IpcmV0dXJuIHQ7dmFyIGU9bmV3IGwub25ueC5UeXBlUHJvdG8uVGVuc29yO2lmKG51bGwhPXQuZWxlbVR5cGUmJihlLmVsZW1UeXBlPTB8dC5lbGVtVHlwZSksbnVsbCE9dC5zaGFwZSl7aWYoXCJvYmplY3RcIiE9dHlwZW9mIHQuc2hhcGUpdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguVHlwZVByb3RvLlRlbnNvci5zaGFwZTogb2JqZWN0IGV4cGVjdGVkXCIpO2Uuc2hhcGU9bC5vbm54LlRlbnNvclNoYXBlUHJvdG8uZnJvbU9iamVjdCh0LnNoYXBlKX1yZXR1cm4gZX0sdC50b09iamVjdD1mdW5jdGlvbih0LGUpe2V8fChlPXt9KTt2YXIgbj17fTtyZXR1cm4gZS5kZWZhdWx0cyYmKG4uZWxlbVR5cGU9MCxuLnNoYXBlPW51bGwpLG51bGwhPXQuZWxlbVR5cGUmJnQuaGFzT3duUHJvcGVydHkoXCJlbGVtVHlwZVwiKSYmKG4uZWxlbVR5cGU9dC5lbGVtVHlwZSksbnVsbCE9dC5zaGFwZSYmdC5oYXNPd25Qcm9wZXJ0eShcInNoYXBlXCIpJiYobi5zaGFwZT1sLm9ubnguVGVuc29yU2hhcGVQcm90by50b09iamVjdCh0LnNoYXBlLGUpKSxufSx0LnByb3RvdHlwZS50b0pTT049ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci50b09iamVjdCh0aGlzLGEudXRpbC50b0pTT05PcHRpb25zKX0sdH0oKSx0fSgpLG8uT3BlcmF0b3JTZXRJZFByb3RvPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0KXtpZih0KWZvcih2YXIgZT1PYmplY3Qua2V5cyh0KSxuPTA7bjxlLmxlbmd0aDsrK24pbnVsbCE9dFtlW25dXSYmKHRoaXNbZVtuXV09dFtlW25dXSl9cmV0dXJuIHQucHJvdG90eXBlLmRvbWFpbj1cIlwiLHQucHJvdG90eXBlLnZlcnNpb249Yy5Mb25nP2MuTG9uZy5mcm9tQml0cygwLDAsITEpOjAsdC5jcmVhdGU9ZnVuY3Rpb24oZSl7cmV0dXJuIG5ldyB0KGUpfSx0LmVuY29kZT1mdW5jdGlvbih0LGUpe3JldHVybiBlfHwoZT11LmNyZWF0ZSgpKSxudWxsIT10LmRvbWFpbiYmdC5oYXNPd25Qcm9wZXJ0eShcImRvbWFpblwiKSYmZS51aW50MzIoMTApLnN0cmluZyh0LmRvbWFpbiksbnVsbCE9dC52ZXJzaW9uJiZ0Lmhhc093blByb3BlcnR5KFwidmVyc2lvblwiKSYmZS51aW50MzIoMTYpLmludDY0KHQudmVyc2lvbiksZX0sdC5lbmNvZGVEZWxpbWl0ZWQ9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5lbmNvZGUodCxlKS5sZGVsaW0oKX0sdC5kZWNvZGU9ZnVuY3Rpb24odCxlKXt0IGluc3RhbmNlb2Ygc3x8KHQ9cy5jcmVhdGUodCkpO2Zvcih2YXIgbj12b2lkIDA9PT1lP3QubGVuOnQucG9zK2Uscj1uZXcgbC5vbm54Lk9wZXJhdG9yU2V0SWRQcm90bzt0LnBvczxuOyl7dmFyIGk9dC51aW50MzIoKTtzd2l0Y2goaT4+PjMpe2Nhc2UgMTpyLmRvbWFpbj10LnN0cmluZygpO2JyZWFrO2Nhc2UgMjpyLnZlcnNpb249dC5pbnQ2NCgpO2JyZWFrO2RlZmF1bHQ6dC5za2lwVHlwZSg3JmkpfX1yZXR1cm4gcn0sdC5kZWNvZGVEZWxpbWl0ZWQ9ZnVuY3Rpb24odCl7cmV0dXJuIHQgaW5zdGFuY2VvZiBzfHwodD1uZXcgcyh0KSksdGhpcy5kZWNvZGUodCx0LnVpbnQzMigpKX0sdC52ZXJpZnk9ZnVuY3Rpb24odCl7cmV0dXJuXCJvYmplY3RcIiE9dHlwZW9mIHR8fG51bGw9PT10P1wib2JqZWN0IGV4cGVjdGVkXCI6bnVsbCE9dC5kb21haW4mJnQuaGFzT3duUHJvcGVydHkoXCJkb21haW5cIikmJiFjLmlzU3RyaW5nKHQuZG9tYWluKT9cImRvbWFpbjogc3RyaW5nIGV4cGVjdGVkXCI6bnVsbCE9dC52ZXJzaW9uJiZ0Lmhhc093blByb3BlcnR5KFwidmVyc2lvblwiKSYmIShjLmlzSW50ZWdlcih0LnZlcnNpb24pfHx0LnZlcnNpb24mJmMuaXNJbnRlZ2VyKHQudmVyc2lvbi5sb3cpJiZjLmlzSW50ZWdlcih0LnZlcnNpb24uaGlnaCkpP1widmVyc2lvbjogaW50ZWdlcnxMb25nIGV4cGVjdGVkXCI6bnVsbH0sdC5mcm9tT2JqZWN0PWZ1bmN0aW9uKHQpe2lmKHQgaW5zdGFuY2VvZiBsLm9ubnguT3BlcmF0b3JTZXRJZFByb3RvKXJldHVybiB0O3ZhciBlPW5ldyBsLm9ubnguT3BlcmF0b3JTZXRJZFByb3RvO3JldHVybiBudWxsIT10LmRvbWFpbiYmKGUuZG9tYWluPVN0cmluZyh0LmRvbWFpbikpLG51bGwhPXQudmVyc2lvbiYmKGMuTG9uZz8oZS52ZXJzaW9uPWMuTG9uZy5mcm9tVmFsdWUodC52ZXJzaW9uKSkudW5zaWduZWQ9ITE6XCJzdHJpbmdcIj09dHlwZW9mIHQudmVyc2lvbj9lLnZlcnNpb249cGFyc2VJbnQodC52ZXJzaW9uLDEwKTpcIm51bWJlclwiPT10eXBlb2YgdC52ZXJzaW9uP2UudmVyc2lvbj10LnZlcnNpb246XCJvYmplY3RcIj09dHlwZW9mIHQudmVyc2lvbiYmKGUudmVyc2lvbj1uZXcgYy5Mb25nQml0cyh0LnZlcnNpb24ubG93Pj4+MCx0LnZlcnNpb24uaGlnaD4+PjApLnRvTnVtYmVyKCkpKSxlfSx0LnRvT2JqZWN0PWZ1bmN0aW9uKHQsZSl7ZXx8KGU9e30pO3ZhciBuPXt9O2lmKGUuZGVmYXVsdHMpaWYobi5kb21haW49XCJcIixjLkxvbmcpe3ZhciByPW5ldyBjLkxvbmcoMCwwLCExKTtuLnZlcnNpb249ZS5sb25ncz09PVN0cmluZz9yLnRvU3RyaW5nKCk6ZS5sb25ncz09PU51bWJlcj9yLnRvTnVtYmVyKCk6cn1lbHNlIG4udmVyc2lvbj1lLmxvbmdzPT09U3RyaW5nP1wiMFwiOjA7cmV0dXJuIG51bGwhPXQuZG9tYWluJiZ0Lmhhc093blByb3BlcnR5KFwiZG9tYWluXCIpJiYobi5kb21haW49dC5kb21haW4pLG51bGwhPXQudmVyc2lvbiYmdC5oYXNPd25Qcm9wZXJ0eShcInZlcnNpb25cIikmJihcIm51bWJlclwiPT10eXBlb2YgdC52ZXJzaW9uP24udmVyc2lvbj1lLmxvbmdzPT09U3RyaW5nP1N0cmluZyh0LnZlcnNpb24pOnQudmVyc2lvbjpuLnZlcnNpb249ZS5sb25ncz09PVN0cmluZz9jLkxvbmcucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodC52ZXJzaW9uKTplLmxvbmdzPT09TnVtYmVyP25ldyBjLkxvbmdCaXRzKHQudmVyc2lvbi5sb3c+Pj4wLHQudmVyc2lvbi5oaWdoPj4+MCkudG9OdW1iZXIoKTp0LnZlcnNpb24pLG59LHQucHJvdG90eXBlLnRvSlNPTj1mdW5jdGlvbigpe3JldHVybiB0aGlzLmNvbnN0cnVjdG9yLnRvT2JqZWN0KHRoaXMsYS51dGlsLnRvSlNPTk9wdGlvbnMpfSx0fSgpLG8pLHQuZXhwb3J0cz1sfSwyMTAwOih0LGUsbik9PntcInVzZSBzdHJpY3RcIjt0LmV4cG9ydHM9big5NDgyKX0sOTQ4MjoodCxlLG4pPT57XCJ1c2Ugc3RyaWN0XCI7dmFyIHI9ZTtmdW5jdGlvbiBpKCl7ci51dGlsLl9jb25maWd1cmUoKSxyLldyaXRlci5fY29uZmlndXJlKHIuQnVmZmVyV3JpdGVyKSxyLlJlYWRlci5fY29uZmlndXJlKHIuQnVmZmVyUmVhZGVyKX1yLmJ1aWxkPVwibWluaW1hbFwiLHIuV3JpdGVyPW4oMTE3Myksci5CdWZmZXJXcml0ZXI9bigzMTU1KSxyLlJlYWRlcj1uKDE0MDgpLHIuQnVmZmVyUmVhZGVyPW4oNTkzKSxyLnV0aWw9big5NjkzKSxyLnJwYz1uKDU5OTQpLHIucm9vdHM9big1MDU0KSxyLmNvbmZpZ3VyZT1pLGkoKX0sMTQwODoodCxlLG4pPT57XCJ1c2Ugc3RyaWN0XCI7dC5leHBvcnRzPXU7dmFyIHIsaT1uKDk2OTMpLG89aS5Mb25nQml0cyxhPWkudXRmODtmdW5jdGlvbiBzKHQsZSl7cmV0dXJuIFJhbmdlRXJyb3IoXCJpbmRleCBvdXQgb2YgcmFuZ2U6IFwiK3QucG9zK1wiICsgXCIrKGV8fDEpK1wiID4gXCIrdC5sZW4pfWZ1bmN0aW9uIHUodCl7dGhpcy5idWY9dCx0aGlzLnBvcz0wLHRoaXMubGVuPXQubGVuZ3RofXZhciBjLGw9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIFVpbnQ4QXJyYXk/ZnVuY3Rpb24odCl7aWYodCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXl8fEFycmF5LmlzQXJyYXkodCkpcmV0dXJuIG5ldyB1KHQpO3Rocm93IEVycm9yKFwiaWxsZWdhbCBidWZmZXJcIil9OmZ1bmN0aW9uKHQpe2lmKEFycmF5LmlzQXJyYXkodCkpcmV0dXJuIG5ldyB1KHQpO3Rocm93IEVycm9yKFwiaWxsZWdhbCBidWZmZXJcIil9LHA9ZnVuY3Rpb24oKXtyZXR1cm4gaS5CdWZmZXI/ZnVuY3Rpb24odCl7cmV0dXJuKHUuY3JlYXRlPWZ1bmN0aW9uKHQpe3JldHVybiBpLkJ1ZmZlci5pc0J1ZmZlcih0KT9uZXcgcih0KTpsKHQpfSkodCl9Omx9O2Z1bmN0aW9uIGYoKXt2YXIgdD1uZXcgbygwLDApLGU9MDtpZighKHRoaXMubGVuLXRoaXMucG9zPjQpKXtmb3IoO2U8MzsrK2Upe2lmKHRoaXMucG9zPj10aGlzLmxlbil0aHJvdyBzKHRoaXMpO2lmKHQubG89KHQubG98KDEyNyZ0aGlzLmJ1Zlt0aGlzLnBvc10pPDw3KmUpPj4+MCx0aGlzLmJ1Zlt0aGlzLnBvcysrXTwxMjgpcmV0dXJuIHR9cmV0dXJuIHQubG89KHQubG98KDEyNyZ0aGlzLmJ1Zlt0aGlzLnBvcysrXSk8PDcqZSk+Pj4wLHR9Zm9yKDtlPDQ7KytlKWlmKHQubG89KHQubG98KDEyNyZ0aGlzLmJ1Zlt0aGlzLnBvc10pPDw3KmUpPj4+MCx0aGlzLmJ1Zlt0aGlzLnBvcysrXTwxMjgpcmV0dXJuIHQ7aWYodC5sbz0odC5sb3woMTI3JnRoaXMuYnVmW3RoaXMucG9zXSk8PDI4KT4+PjAsdC5oaT0odC5oaXwoMTI3JnRoaXMuYnVmW3RoaXMucG9zXSk+PjQpPj4+MCx0aGlzLmJ1Zlt0aGlzLnBvcysrXTwxMjgpcmV0dXJuIHQ7aWYoZT0wLHRoaXMubGVuLXRoaXMucG9zPjQpe2Zvcig7ZTw1OysrZSlpZih0LmhpPSh0LmhpfCgxMjcmdGhpcy5idWZbdGhpcy5wb3NdKTw8NyplKzMpPj4+MCx0aGlzLmJ1Zlt0aGlzLnBvcysrXTwxMjgpcmV0dXJuIHR9ZWxzZSBmb3IoO2U8NTsrK2Upe2lmKHRoaXMucG9zPj10aGlzLmxlbil0aHJvdyBzKHRoaXMpO2lmKHQuaGk9KHQuaGl8KDEyNyZ0aGlzLmJ1Zlt0aGlzLnBvc10pPDw3KmUrMyk+Pj4wLHRoaXMuYnVmW3RoaXMucG9zKytdPDEyOClyZXR1cm4gdH10aHJvdyBFcnJvcihcImludmFsaWQgdmFyaW50IGVuY29kaW5nXCIpfWZ1bmN0aW9uIGQodCxlKXtyZXR1cm4odFtlLTRdfHRbZS0zXTw8OHx0W2UtMl08PDE2fHRbZS0xXTw8MjQpPj4+MH1mdW5jdGlvbiBoKCl7aWYodGhpcy5wb3MrOD50aGlzLmxlbil0aHJvdyBzKHRoaXMsOCk7cmV0dXJuIG5ldyBvKGQodGhpcy5idWYsdGhpcy5wb3MrPTQpLGQodGhpcy5idWYsdGhpcy5wb3MrPTQpKX11LmNyZWF0ZT1wKCksdS5wcm90b3R5cGUuX3NsaWNlPWkuQXJyYXkucHJvdG90eXBlLnN1YmFycmF5fHxpLkFycmF5LnByb3RvdHlwZS5zbGljZSx1LnByb3RvdHlwZS51aW50MzI9KGM9NDI5NDk2NzI5NSxmdW5jdGlvbigpe2lmKGM9KDEyNyZ0aGlzLmJ1Zlt0aGlzLnBvc10pPj4+MCx0aGlzLmJ1Zlt0aGlzLnBvcysrXTwxMjgpcmV0dXJuIGM7aWYoYz0oY3woMTI3JnRoaXMuYnVmW3RoaXMucG9zXSk8PDcpPj4+MCx0aGlzLmJ1Zlt0aGlzLnBvcysrXTwxMjgpcmV0dXJuIGM7aWYoYz0oY3woMTI3JnRoaXMuYnVmW3RoaXMucG9zXSk8PDE0KT4+PjAsdGhpcy5idWZbdGhpcy5wb3MrK108MTI4KXJldHVybiBjO2lmKGM9KGN8KDEyNyZ0aGlzLmJ1Zlt0aGlzLnBvc10pPDwyMSk+Pj4wLHRoaXMuYnVmW3RoaXMucG9zKytdPDEyOClyZXR1cm4gYztpZihjPShjfCgxNSZ0aGlzLmJ1Zlt0aGlzLnBvc10pPDwyOCk+Pj4wLHRoaXMuYnVmW3RoaXMucG9zKytdPDEyOClyZXR1cm4gYztpZigodGhpcy5wb3MrPTUpPnRoaXMubGVuKXRocm93IHRoaXMucG9zPXRoaXMubGVuLHModGhpcywxMCk7cmV0dXJuIGN9KSx1LnByb3RvdHlwZS5pbnQzMj1mdW5jdGlvbigpe3JldHVybiAwfHRoaXMudWludDMyKCl9LHUucHJvdG90eXBlLnNpbnQzMj1mdW5jdGlvbigpe3ZhciB0PXRoaXMudWludDMyKCk7cmV0dXJuIHQ+Pj4xXi0oMSZ0KXwwfSx1LnByb3RvdHlwZS5ib29sPWZ1bmN0aW9uKCl7cmV0dXJuIDAhPT10aGlzLnVpbnQzMigpfSx1LnByb3RvdHlwZS5maXhlZDMyPWZ1bmN0aW9uKCl7aWYodGhpcy5wb3MrND50aGlzLmxlbil0aHJvdyBzKHRoaXMsNCk7cmV0dXJuIGQodGhpcy5idWYsdGhpcy5wb3MrPTQpfSx1LnByb3RvdHlwZS5zZml4ZWQzMj1mdW5jdGlvbigpe2lmKHRoaXMucG9zKzQ+dGhpcy5sZW4pdGhyb3cgcyh0aGlzLDQpO3JldHVybiAwfGQodGhpcy5idWYsdGhpcy5wb3MrPTQpfSx1LnByb3RvdHlwZS5mbG9hdD1mdW5jdGlvbigpe2lmKHRoaXMucG9zKzQ+dGhpcy5sZW4pdGhyb3cgcyh0aGlzLDQpO3ZhciB0PWkuZmxvYXQucmVhZEZsb2F0TEUodGhpcy5idWYsdGhpcy5wb3MpO3JldHVybiB0aGlzLnBvcys9NCx0fSx1LnByb3RvdHlwZS5kb3VibGU9ZnVuY3Rpb24oKXtpZih0aGlzLnBvcys4PnRoaXMubGVuKXRocm93IHModGhpcyw0KTt2YXIgdD1pLmZsb2F0LnJlYWREb3VibGVMRSh0aGlzLmJ1Zix0aGlzLnBvcyk7cmV0dXJuIHRoaXMucG9zKz04LHR9LHUucHJvdG90eXBlLmJ5dGVzPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy51aW50MzIoKSxlPXRoaXMucG9zLG49dGhpcy5wb3MrdDtpZihuPnRoaXMubGVuKXRocm93IHModGhpcyx0KTtyZXR1cm4gdGhpcy5wb3MrPXQsQXJyYXkuaXNBcnJheSh0aGlzLmJ1Zik/dGhpcy5idWYuc2xpY2UoZSxuKTplPT09bj9uZXcgdGhpcy5idWYuY29uc3RydWN0b3IoMCk6dGhpcy5fc2xpY2UuY2FsbCh0aGlzLmJ1ZixlLG4pfSx1LnByb3RvdHlwZS5zdHJpbmc9ZnVuY3Rpb24oKXt2YXIgdD10aGlzLmJ5dGVzKCk7cmV0dXJuIGEucmVhZCh0LDAsdC5sZW5ndGgpfSx1LnByb3RvdHlwZS5za2lwPWZ1bmN0aW9uKHQpe2lmKFwibnVtYmVyXCI9PXR5cGVvZiB0KXtpZih0aGlzLnBvcyt0PnRoaXMubGVuKXRocm93IHModGhpcyx0KTt0aGlzLnBvcys9dH1lbHNlIGRve2lmKHRoaXMucG9zPj10aGlzLmxlbil0aHJvdyBzKHRoaXMpfXdoaWxlKDEyOCZ0aGlzLmJ1Zlt0aGlzLnBvcysrXSk7cmV0dXJuIHRoaXN9LHUucHJvdG90eXBlLnNraXBUeXBlPWZ1bmN0aW9uKHQpe3N3aXRjaCh0KXtjYXNlIDA6dGhpcy5za2lwKCk7YnJlYWs7Y2FzZSAxOnRoaXMuc2tpcCg4KTticmVhaztjYXNlIDI6dGhpcy5za2lwKHRoaXMudWludDMyKCkpO2JyZWFrO2Nhc2UgMzpmb3IoOzQhPSh0PTcmdGhpcy51aW50MzIoKSk7KXRoaXMuc2tpcFR5cGUodCk7YnJlYWs7Y2FzZSA1OnRoaXMuc2tpcCg0KTticmVhaztkZWZhdWx0OnRocm93IEVycm9yKFwiaW52YWxpZCB3aXJlIHR5cGUgXCIrdCtcIiBhdCBvZmZzZXQgXCIrdGhpcy5wb3MpfXJldHVybiB0aGlzfSx1Ll9jb25maWd1cmU9ZnVuY3Rpb24odCl7cj10LHUuY3JlYXRlPXAoKSxyLl9jb25maWd1cmUoKTt2YXIgZT1pLkxvbmc/XCJ0b0xvbmdcIjpcInRvTnVtYmVyXCI7aS5tZXJnZSh1LnByb3RvdHlwZSx7aW50NjQ6ZnVuY3Rpb24oKXtyZXR1cm4gZi5jYWxsKHRoaXMpW2VdKCExKX0sdWludDY0OmZ1bmN0aW9uKCl7cmV0dXJuIGYuY2FsbCh0aGlzKVtlXSghMCl9LHNpbnQ2NDpmdW5jdGlvbigpe3JldHVybiBmLmNhbGwodGhpcykuenpEZWNvZGUoKVtlXSghMSl9LGZpeGVkNjQ6ZnVuY3Rpb24oKXtyZXR1cm4gaC5jYWxsKHRoaXMpW2VdKCEwKX0sc2ZpeGVkNjQ6ZnVuY3Rpb24oKXtyZXR1cm4gaC5jYWxsKHRoaXMpW2VdKCExKX19KX19LDU5MzoodCxlLG4pPT57XCJ1c2Ugc3RyaWN0XCI7dC5leHBvcnRzPW87dmFyIHI9bigxNDA4KTsoby5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShyLnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yPW87dmFyIGk9big5NjkzKTtmdW5jdGlvbiBvKHQpe3IuY2FsbCh0aGlzLHQpfW8uX2NvbmZpZ3VyZT1mdW5jdGlvbigpe2kuQnVmZmVyJiYoby5wcm90b3R5cGUuX3NsaWNlPWkuQnVmZmVyLnByb3RvdHlwZS5zbGljZSl9LG8ucHJvdG90eXBlLnN0cmluZz1mdW5jdGlvbigpe3ZhciB0PXRoaXMudWludDMyKCk7cmV0dXJuIHRoaXMuYnVmLnV0ZjhTbGljZT90aGlzLmJ1Zi51dGY4U2xpY2UodGhpcy5wb3MsdGhpcy5wb3M9TWF0aC5taW4odGhpcy5wb3MrdCx0aGlzLmxlbikpOnRoaXMuYnVmLnRvU3RyaW5nKFwidXRmLThcIix0aGlzLnBvcyx0aGlzLnBvcz1NYXRoLm1pbih0aGlzLnBvcyt0LHRoaXMubGVuKSl9LG8uX2NvbmZpZ3VyZSgpfSw1MDU0OnQ9PntcInVzZSBzdHJpY3RcIjt0LmV4cG9ydHM9e319LDU5OTQ6KHQsZSxuKT0+e1widXNlIHN0cmljdFwiO2UuU2VydmljZT1uKDc5NDgpfSw3OTQ4Oih0LGUsbik9PntcInVzZSBzdHJpY3RcIjt0LmV4cG9ydHM9aTt2YXIgcj1uKDk2OTMpO2Z1bmN0aW9uIGkodCxlLG4pe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIHQpdGhyb3cgVHlwZUVycm9yKFwicnBjSW1wbCBtdXN0IGJlIGEgZnVuY3Rpb25cIik7ci5FdmVudEVtaXR0ZXIuY2FsbCh0aGlzKSx0aGlzLnJwY0ltcGw9dCx0aGlzLnJlcXVlc3REZWxpbWl0ZWQ9Qm9vbGVhbihlKSx0aGlzLnJlc3BvbnNlRGVsaW1pdGVkPUJvb2xlYW4obil9KGkucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoci5FdmVudEVtaXR0ZXIucHJvdG90eXBlKSkuY29uc3RydWN0b3I9aSxpLnByb3RvdHlwZS5ycGNDYWxsPWZ1bmN0aW9uIHQoZSxuLGksbyxhKXtpZighbyl0aHJvdyBUeXBlRXJyb3IoXCJyZXF1ZXN0IG11c3QgYmUgc3BlY2lmaWVkXCIpO3ZhciBzPXRoaXM7aWYoIWEpcmV0dXJuIHIuYXNQcm9taXNlKHQscyxlLG4saSxvKTtpZihzLnJwY0ltcGwpdHJ5e3JldHVybiBzLnJwY0ltcGwoZSxuW3MucmVxdWVzdERlbGltaXRlZD9cImVuY29kZURlbGltaXRlZFwiOlwiZW5jb2RlXCJdKG8pLmZpbmlzaCgpLChmdW5jdGlvbih0LG4pe2lmKHQpcmV0dXJuIHMuZW1pdChcImVycm9yXCIsdCxlKSxhKHQpO2lmKG51bGwhPT1uKXtpZighKG4gaW5zdGFuY2VvZiBpKSl0cnl7bj1pW3MucmVzcG9uc2VEZWxpbWl0ZWQ/XCJkZWNvZGVEZWxpbWl0ZWRcIjpcImRlY29kZVwiXShuKX1jYXRjaCh0KXtyZXR1cm4gcy5lbWl0KFwiZXJyb3JcIix0LGUpLGEodCl9cmV0dXJuIHMuZW1pdChcImRhdGFcIixuLGUpLGEobnVsbCxuKX1zLmVuZCghMCl9KSl9Y2F0Y2godCl7cmV0dXJuIHMuZW1pdChcImVycm9yXCIsdCxlKSx2b2lkIHNldFRpbWVvdXQoKGZ1bmN0aW9uKCl7YSh0KX0pLDApfWVsc2Ugc2V0VGltZW91dCgoZnVuY3Rpb24oKXthKEVycm9yKFwiYWxyZWFkeSBlbmRlZFwiKSl9KSwwKX0saS5wcm90b3R5cGUuZW5kPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnJwY0ltcGwmJih0fHx0aGlzLnJwY0ltcGwobnVsbCxudWxsLG51bGwpLHRoaXMucnBjSW1wbD1udWxsLHRoaXMuZW1pdChcImVuZFwiKS5vZmYoKSksdGhpc319LDE5NDU6KHQsZSxuKT0+e1widXNlIHN0cmljdFwiO3QuZXhwb3J0cz1pO3ZhciByPW4oOTY5Myk7ZnVuY3Rpb24gaSh0LGUpe3RoaXMubG89dD4+PjAsdGhpcy5oaT1lPj4+MH12YXIgbz1pLnplcm89bmV3IGkoMCwwKTtvLnRvTnVtYmVyPWZ1bmN0aW9uKCl7cmV0dXJuIDB9LG8uenpFbmNvZGU9by56ekRlY29kZT1mdW5jdGlvbigpe3JldHVybiB0aGlzfSxvLmxlbmd0aD1mdW5jdGlvbigpe3JldHVybiAxfTt2YXIgYT1pLnplcm9IYXNoPVwiXFwwXFwwXFwwXFwwXFwwXFwwXFwwXFwwXCI7aS5mcm9tTnVtYmVyPWZ1bmN0aW9uKHQpe2lmKDA9PT10KXJldHVybiBvO3ZhciBlPXQ8MDtlJiYodD0tdCk7dmFyIG49dD4+PjAscj0odC1uKS80Mjk0OTY3Mjk2Pj4+MDtyZXR1cm4gZSYmKHI9fnI+Pj4wLG49fm4+Pj4wLCsrbj40Mjk0OTY3Mjk1JiYobj0wLCsrcj40Mjk0OTY3Mjk1JiYocj0wKSkpLG5ldyBpKG4scil9LGkuZnJvbT1mdW5jdGlvbih0KXtpZihcIm51bWJlclwiPT10eXBlb2YgdClyZXR1cm4gaS5mcm9tTnVtYmVyKHQpO2lmKHIuaXNTdHJpbmcodCkpe2lmKCFyLkxvbmcpcmV0dXJuIGkuZnJvbU51bWJlcihwYXJzZUludCh0LDEwKSk7dD1yLkxvbmcuZnJvbVN0cmluZyh0KX1yZXR1cm4gdC5sb3d8fHQuaGlnaD9uZXcgaSh0Lmxvdz4+PjAsdC5oaWdoPj4+MCk6b30saS5wcm90b3R5cGUudG9OdW1iZXI9ZnVuY3Rpb24odCl7aWYoIXQmJnRoaXMuaGk+Pj4zMSl7dmFyIGU9MSt+dGhpcy5sbz4+PjAsbj1+dGhpcy5oaT4+PjA7cmV0dXJuIGV8fChuPW4rMT4+PjApLC0oZSs0Mjk0OTY3Mjk2Km4pfXJldHVybiB0aGlzLmxvKzQyOTQ5NjcyOTYqdGhpcy5oaX0saS5wcm90b3R5cGUudG9Mb25nPWZ1bmN0aW9uKHQpe3JldHVybiByLkxvbmc/bmV3IHIuTG9uZygwfHRoaXMubG8sMHx0aGlzLmhpLEJvb2xlYW4odCkpOntsb3c6MHx0aGlzLmxvLGhpZ2g6MHx0aGlzLmhpLHVuc2lnbmVkOkJvb2xlYW4odCl9fTt2YXIgcz1TdHJpbmcucHJvdG90eXBlLmNoYXJDb2RlQXQ7aS5mcm9tSGFzaD1mdW5jdGlvbih0KXtyZXR1cm4gdD09PWE/bzpuZXcgaSgocy5jYWxsKHQsMCl8cy5jYWxsKHQsMSk8PDh8cy5jYWxsKHQsMik8PDE2fHMuY2FsbCh0LDMpPDwyNCk+Pj4wLChzLmNhbGwodCw0KXxzLmNhbGwodCw1KTw8OHxzLmNhbGwodCw2KTw8MTZ8cy5jYWxsKHQsNyk8PDI0KT4+PjApfSxpLnByb3RvdHlwZS50b0hhc2g9ZnVuY3Rpb24oKXtyZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSgyNTUmdGhpcy5sbyx0aGlzLmxvPj4+OCYyNTUsdGhpcy5sbz4+PjE2JjI1NSx0aGlzLmxvPj4+MjQsMjU1JnRoaXMuaGksdGhpcy5oaT4+PjgmMjU1LHRoaXMuaGk+Pj4xNiYyNTUsdGhpcy5oaT4+PjI0KX0saS5wcm90b3R5cGUuenpFbmNvZGU9ZnVuY3Rpb24oKXt2YXIgdD10aGlzLmhpPj4zMTtyZXR1cm4gdGhpcy5oaT0oKHRoaXMuaGk8PDF8dGhpcy5sbz4+PjMxKV50KT4+PjAsdGhpcy5sbz0odGhpcy5sbzw8MV50KT4+PjAsdGhpc30saS5wcm90b3R5cGUuenpEZWNvZGU9ZnVuY3Rpb24oKXt2YXIgdD0tKDEmdGhpcy5sbyk7cmV0dXJuIHRoaXMubG89KCh0aGlzLmxvPj4+MXx0aGlzLmhpPDwzMSledCk+Pj4wLHRoaXMuaGk9KHRoaXMuaGk+Pj4xXnQpPj4+MCx0aGlzfSxpLnByb3RvdHlwZS5sZW5ndGg9ZnVuY3Rpb24oKXt2YXIgdD10aGlzLmxvLGU9KHRoaXMubG8+Pj4yOHx0aGlzLmhpPDw0KT4+PjAsbj10aGlzLmhpPj4+MjQ7cmV0dXJuIDA9PT1uPzA9PT1lP3Q8MTYzODQ/dDwxMjg/MToyOnQ8MjA5NzE1Mj8zOjQ6ZTwxNjM4ND9lPDEyOD81OjY6ZTwyMDk3MTUyPzc6ODpuPDEyOD85OjEwfX0sOTY5MzpmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7dmFyIHI9ZTtmdW5jdGlvbiBpKHQsZSxuKXtmb3IodmFyIHI9T2JqZWN0LmtleXMoZSksaT0wO2k8ci5sZW5ndGg7KytpKXZvaWQgMCE9PXRbcltpXV0mJm58fCh0W3JbaV1dPWVbcltpXV0pO3JldHVybiB0fWZ1bmN0aW9uIG8odCl7ZnVuY3Rpb24gZSh0LG4pe2lmKCEodGhpcyBpbnN0YW5jZW9mIGUpKXJldHVybiBuZXcgZSh0LG4pO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLFwibWVzc2FnZVwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdH19KSxFcnJvci5jYXB0dXJlU3RhY2tUcmFjZT9FcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLGUpOk9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLFwic3RhY2tcIix7dmFsdWU6KG5ldyBFcnJvcikuc3RhY2t8fFwiXCJ9KSxuJiZpKHRoaXMsbil9cmV0dXJuKGUucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoRXJyb3IucHJvdG90eXBlKSkuY29uc3RydWN0b3I9ZSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZS5wcm90b3R5cGUsXCJuYW1lXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0fX0pLGUucHJvdG90eXBlLnRvU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubmFtZStcIjogXCIrdGhpcy5tZXNzYWdlfSxlfXIuYXNQcm9taXNlPW4oNDUzNyksci5iYXNlNjQ9big3NDE5KSxyLkV2ZW50RW1pdHRlcj1uKDkyMTEpLHIuZmxvYXQ9big5NDUpLHIuaW5xdWlyZT1uKDcxOTkpLHIudXRmOD1uKDQ5OTcpLHIucG9vbD1uKDY2NjIpLHIuTG9uZ0JpdHM9bigxOTQ1KSxyLmlzTm9kZT1Cb29sZWFuKHZvaWQgMCE9PW4uZyYmbi5nJiZuLmcucHJvY2VzcyYmbi5nLnByb2Nlc3MudmVyc2lvbnMmJm4uZy5wcm9jZXNzLnZlcnNpb25zLm5vZGUpLHIuZ2xvYmFsPXIuaXNOb2RlJiZuLmd8fFwidW5kZWZpbmVkXCIhPXR5cGVvZiB3aW5kb3cmJndpbmRvd3x8XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHNlbGYmJnNlbGZ8fHRoaXMsci5lbXB0eUFycmF5PU9iamVjdC5mcmVlemU/T2JqZWN0LmZyZWV6ZShbXSk6W10sci5lbXB0eU9iamVjdD1PYmplY3QuZnJlZXplP09iamVjdC5mcmVlemUoe30pOnt9LHIuaXNJbnRlZ2VyPU51bWJlci5pc0ludGVnZXJ8fGZ1bmN0aW9uKHQpe3JldHVyblwibnVtYmVyXCI9PXR5cGVvZiB0JiZpc0Zpbml0ZSh0KSYmTWF0aC5mbG9vcih0KT09PXR9LHIuaXNTdHJpbmc9ZnVuY3Rpb24odCl7cmV0dXJuXCJzdHJpbmdcIj09dHlwZW9mIHR8fHQgaW5zdGFuY2VvZiBTdHJpbmd9LHIuaXNPYmplY3Q9ZnVuY3Rpb24odCl7cmV0dXJuIHQmJlwib2JqZWN0XCI9PXR5cGVvZiB0fSxyLmlzc2V0PXIuaXNTZXQ9ZnVuY3Rpb24odCxlKXt2YXIgbj10W2VdO3JldHVybiEobnVsbD09bnx8IXQuaGFzT3duUHJvcGVydHkoZSkpJiYoXCJvYmplY3RcIiE9dHlwZW9mIG58fChBcnJheS5pc0FycmF5KG4pP24ubGVuZ3RoOk9iamVjdC5rZXlzKG4pLmxlbmd0aCk+MCl9LHIuQnVmZmVyPWZ1bmN0aW9uKCl7dHJ5e3ZhciB0PXIuaW5xdWlyZShcImJ1ZmZlclwiKS5CdWZmZXI7cmV0dXJuIHQucHJvdG90eXBlLnV0ZjhXcml0ZT90Om51bGx9Y2F0Y2godCl7cmV0dXJuIG51bGx9fSgpLHIuX0J1ZmZlcl9mcm9tPW51bGwsci5fQnVmZmVyX2FsbG9jVW5zYWZlPW51bGwsci5uZXdCdWZmZXI9ZnVuY3Rpb24odCl7cmV0dXJuXCJudW1iZXJcIj09dHlwZW9mIHQ/ci5CdWZmZXI/ci5fQnVmZmVyX2FsbG9jVW5zYWZlKHQpOm5ldyByLkFycmF5KHQpOnIuQnVmZmVyP3IuX0J1ZmZlcl9mcm9tKHQpOlwidW5kZWZpbmVkXCI9PXR5cGVvZiBVaW50OEFycmF5P3Q6bmV3IFVpbnQ4QXJyYXkodCl9LHIuQXJyYXk9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIFVpbnQ4QXJyYXk/VWludDhBcnJheTpBcnJheSxyLkxvbmc9ci5nbG9iYWwuZGNvZGVJTyYmci5nbG9iYWwuZGNvZGVJTy5Mb25nfHxyLmdsb2JhbC5Mb25nfHxyLmlucXVpcmUoXCJsb25nXCIpLHIua2V5MlJlPS9edHJ1ZXxmYWxzZXwwfDEkLyxyLmtleTMyUmU9L14tPyg/OjB8WzEtOV1bMC05XSopJC8sci5rZXk2NFJlPS9eKD86W1xcXFx4MDAtXFxcXHhmZl17OH18LT8oPzowfFsxLTldWzAtOV0qKSkkLyxyLmxvbmdUb0hhc2g9ZnVuY3Rpb24odCl7cmV0dXJuIHQ/ci5Mb25nQml0cy5mcm9tKHQpLnRvSGFzaCgpOnIuTG9uZ0JpdHMuemVyb0hhc2h9LHIubG9uZ0Zyb21IYXNoPWZ1bmN0aW9uKHQsZSl7dmFyIG49ci5Mb25nQml0cy5mcm9tSGFzaCh0KTtyZXR1cm4gci5Mb25nP3IuTG9uZy5mcm9tQml0cyhuLmxvLG4uaGksZSk6bi50b051bWJlcihCb29sZWFuKGUpKX0sci5tZXJnZT1pLHIubGNGaXJzdD1mdW5jdGlvbih0KXtyZXR1cm4gdC5jaGFyQXQoMCkudG9Mb3dlckNhc2UoKSt0LnN1YnN0cmluZygxKX0sci5uZXdFcnJvcj1vLHIuUHJvdG9jb2xFcnJvcj1vKFwiUHJvdG9jb2xFcnJvclwiKSxyLm9uZU9mR2V0dGVyPWZ1bmN0aW9uKHQpe2Zvcih2YXIgZT17fSxuPTA7bjx0Lmxlbmd0aDsrK24pZVt0W25dXT0xO3JldHVybiBmdW5jdGlvbigpe2Zvcih2YXIgdD1PYmplY3Qua2V5cyh0aGlzKSxuPXQubGVuZ3RoLTE7bj4tMTstLW4paWYoMT09PWVbdFtuXV0mJnZvaWQgMCE9PXRoaXNbdFtuXV0mJm51bGwhPT10aGlzW3Rbbl1dKXJldHVybiB0W25dfX0sci5vbmVPZlNldHRlcj1mdW5jdGlvbih0KXtyZXR1cm4gZnVuY3Rpb24oZSl7Zm9yKHZhciBuPTA7bjx0Lmxlbmd0aDsrK24pdFtuXSE9PWUmJmRlbGV0ZSB0aGlzW3Rbbl1dfX0sci50b0pTT05PcHRpb25zPXtsb25nczpTdHJpbmcsZW51bXM6U3RyaW5nLGJ5dGVzOlN0cmluZyxqc29uOiEwfSxyLl9jb25maWd1cmU9ZnVuY3Rpb24oKXt2YXIgdD1yLkJ1ZmZlcjt0PyhyLl9CdWZmZXJfZnJvbT10LmZyb20hPT1VaW50OEFycmF5LmZyb20mJnQuZnJvbXx8ZnVuY3Rpb24oZSxuKXtyZXR1cm4gbmV3IHQoZSxuKX0sci5fQnVmZmVyX2FsbG9jVW5zYWZlPXQuYWxsb2NVbnNhZmV8fGZ1bmN0aW9uKGUpe3JldHVybiBuZXcgdChlKX0pOnIuX0J1ZmZlcl9mcm9tPXIuX0J1ZmZlcl9hbGxvY1Vuc2FmZT1udWxsfX0sMTE3MzoodCxlLG4pPT57XCJ1c2Ugc3RyaWN0XCI7dC5leHBvcnRzPXA7dmFyIHIsaT1uKDk2OTMpLG89aS5Mb25nQml0cyxhPWkuYmFzZTY0LHM9aS51dGY4O2Z1bmN0aW9uIHUodCxlLG4pe3RoaXMuZm49dCx0aGlzLmxlbj1lLHRoaXMubmV4dD12b2lkIDAsdGhpcy52YWw9bn1mdW5jdGlvbiBjKCl7fWZ1bmN0aW9uIGwodCl7dGhpcy5oZWFkPXQuaGVhZCx0aGlzLnRhaWw9dC50YWlsLHRoaXMubGVuPXQubGVuLHRoaXMubmV4dD10LnN0YXRlc31mdW5jdGlvbiBwKCl7dGhpcy5sZW49MCx0aGlzLmhlYWQ9bmV3IHUoYywwLDApLHRoaXMudGFpbD10aGlzLmhlYWQsdGhpcy5zdGF0ZXM9bnVsbH12YXIgZj1mdW5jdGlvbigpe3JldHVybiBpLkJ1ZmZlcj9mdW5jdGlvbigpe3JldHVybihwLmNyZWF0ZT1mdW5jdGlvbigpe3JldHVybiBuZXcgcn0pKCl9OmZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBwfX07ZnVuY3Rpb24gZCh0LGUsbil7ZVtuXT0yNTUmdH1mdW5jdGlvbiBoKHQsZSl7dGhpcy5sZW49dCx0aGlzLm5leHQ9dm9pZCAwLHRoaXMudmFsPWV9ZnVuY3Rpb24gZyh0LGUsbil7Zm9yKDt0LmhpOyllW24rK109MTI3JnQubG98MTI4LHQubG89KHQubG8+Pj43fHQuaGk8PDI1KT4+PjAsdC5oaT4+Pj03O2Zvcig7dC5sbz4xMjc7KWVbbisrXT0xMjcmdC5sb3wxMjgsdC5sbz10LmxvPj4+NztlW24rK109dC5sb31mdW5jdGlvbiBiKHQsZSxuKXtlW25dPTI1NSZ0LGVbbisxXT10Pj4+OCYyNTUsZVtuKzJdPXQ+Pj4xNiYyNTUsZVtuKzNdPXQ+Pj4yNH1wLmNyZWF0ZT1mKCkscC5hbGxvYz1mdW5jdGlvbih0KXtyZXR1cm4gbmV3IGkuQXJyYXkodCl9LGkuQXJyYXkhPT1BcnJheSYmKHAuYWxsb2M9aS5wb29sKHAuYWxsb2MsaS5BcnJheS5wcm90b3R5cGUuc3ViYXJyYXkpKSxwLnByb3RvdHlwZS5fcHVzaD1mdW5jdGlvbih0LGUsbil7cmV0dXJuIHRoaXMudGFpbD10aGlzLnRhaWwubmV4dD1uZXcgdSh0LGUsbiksdGhpcy5sZW4rPWUsdGhpc30saC5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZSh1LnByb3RvdHlwZSksaC5wcm90b3R5cGUuZm49ZnVuY3Rpb24odCxlLG4pe2Zvcig7dD4xMjc7KWVbbisrXT0xMjcmdHwxMjgsdD4+Pj03O2Vbbl09dH0scC5wcm90b3R5cGUudWludDMyPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmxlbis9KHRoaXMudGFpbD10aGlzLnRhaWwubmV4dD1uZXcgaCgodD4+Pj0wKTwxMjg/MTp0PDE2Mzg0PzI6dDwyMDk3MTUyPzM6dDwyNjg0MzU0NTY/NDo1LHQpKS5sZW4sdGhpc30scC5wcm90b3R5cGUuaW50MzI9ZnVuY3Rpb24odCl7cmV0dXJuIHQ8MD90aGlzLl9wdXNoKGcsMTAsby5mcm9tTnVtYmVyKHQpKTp0aGlzLnVpbnQzMih0KX0scC5wcm90b3R5cGUuc2ludDMyPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnVpbnQzMigodDw8MV50Pj4zMSk+Pj4wKX0scC5wcm90b3R5cGUudWludDY0PWZ1bmN0aW9uKHQpe3ZhciBlPW8uZnJvbSh0KTtyZXR1cm4gdGhpcy5fcHVzaChnLGUubGVuZ3RoKCksZSl9LHAucHJvdG90eXBlLmludDY0PXAucHJvdG90eXBlLnVpbnQ2NCxwLnByb3RvdHlwZS5zaW50NjQ9ZnVuY3Rpb24odCl7dmFyIGU9by5mcm9tKHQpLnp6RW5jb2RlKCk7cmV0dXJuIHRoaXMuX3B1c2goZyxlLmxlbmd0aCgpLGUpfSxwLnByb3RvdHlwZS5ib29sPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLl9wdXNoKGQsMSx0PzE6MCl9LHAucHJvdG90eXBlLmZpeGVkMzI9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuX3B1c2goYiw0LHQ+Pj4wKX0scC5wcm90b3R5cGUuc2ZpeGVkMzI9cC5wcm90b3R5cGUuZml4ZWQzMixwLnByb3RvdHlwZS5maXhlZDY0PWZ1bmN0aW9uKHQpe3ZhciBlPW8uZnJvbSh0KTtyZXR1cm4gdGhpcy5fcHVzaChiLDQsZS5sbykuX3B1c2goYiw0LGUuaGkpfSxwLnByb3RvdHlwZS5zZml4ZWQ2ND1wLnByb3RvdHlwZS5maXhlZDY0LHAucHJvdG90eXBlLmZsb2F0PWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLl9wdXNoKGkuZmxvYXQud3JpdGVGbG9hdExFLDQsdCl9LHAucHJvdG90eXBlLmRvdWJsZT1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5fcHVzaChpLmZsb2F0LndyaXRlRG91YmxlTEUsOCx0KX07dmFyIG09aS5BcnJheS5wcm90b3R5cGUuc2V0P2Z1bmN0aW9uKHQsZSxuKXtlLnNldCh0LG4pfTpmdW5jdGlvbih0LGUsbil7Zm9yKHZhciByPTA7cjx0Lmxlbmd0aDsrK3IpZVtuK3JdPXRbcl19O3AucHJvdG90eXBlLmJ5dGVzPWZ1bmN0aW9uKHQpe3ZhciBlPXQubGVuZ3RoPj4+MDtpZighZSlyZXR1cm4gdGhpcy5fcHVzaChkLDEsMCk7aWYoaS5pc1N0cmluZyh0KSl7dmFyIG49cC5hbGxvYyhlPWEubGVuZ3RoKHQpKTthLmRlY29kZSh0LG4sMCksdD1ufXJldHVybiB0aGlzLnVpbnQzMihlKS5fcHVzaChtLGUsdCl9LHAucHJvdG90eXBlLnN0cmluZz1mdW5jdGlvbih0KXt2YXIgZT1zLmxlbmd0aCh0KTtyZXR1cm4gZT90aGlzLnVpbnQzMihlKS5fcHVzaChzLndyaXRlLGUsdCk6dGhpcy5fcHVzaChkLDEsMCl9LHAucHJvdG90eXBlLmZvcms9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zdGF0ZXM9bmV3IGwodGhpcyksdGhpcy5oZWFkPXRoaXMudGFpbD1uZXcgdShjLDAsMCksdGhpcy5sZW49MCx0aGlzfSxwLnByb3RvdHlwZS5yZXNldD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnN0YXRlcz8odGhpcy5oZWFkPXRoaXMuc3RhdGVzLmhlYWQsdGhpcy50YWlsPXRoaXMuc3RhdGVzLnRhaWwsdGhpcy5sZW49dGhpcy5zdGF0ZXMubGVuLHRoaXMuc3RhdGVzPXRoaXMuc3RhdGVzLm5leHQpOih0aGlzLmhlYWQ9dGhpcy50YWlsPW5ldyB1KGMsMCwwKSx0aGlzLmxlbj0wKSx0aGlzfSxwLnByb3RvdHlwZS5sZGVsaW09ZnVuY3Rpb24oKXt2YXIgdD10aGlzLmhlYWQsZT10aGlzLnRhaWwsbj10aGlzLmxlbjtyZXR1cm4gdGhpcy5yZXNldCgpLnVpbnQzMihuKSxuJiYodGhpcy50YWlsLm5leHQ9dC5uZXh0LHRoaXMudGFpbD1lLHRoaXMubGVuKz1uKSx0aGlzfSxwLnByb3RvdHlwZS5maW5pc2g9ZnVuY3Rpb24oKXtmb3IodmFyIHQ9dGhpcy5oZWFkLm5leHQsZT10aGlzLmNvbnN0cnVjdG9yLmFsbG9jKHRoaXMubGVuKSxuPTA7dDspdC5mbih0LnZhbCxlLG4pLG4rPXQubGVuLHQ9dC5uZXh0O3JldHVybiBlfSxwLl9jb25maWd1cmU9ZnVuY3Rpb24odCl7cj10LHAuY3JlYXRlPWYoKSxyLl9jb25maWd1cmUoKX19LDMxNTU6KHQsZSxuKT0+e1widXNlIHN0cmljdFwiO3QuZXhwb3J0cz1vO3ZhciByPW4oMTE3Myk7KG8ucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoci5wcm90b3R5cGUpKS5jb25zdHJ1Y3Rvcj1vO3ZhciBpPW4oOTY5Myk7ZnVuY3Rpb24gbygpe3IuY2FsbCh0aGlzKX1mdW5jdGlvbiBhKHQsZSxuKXt0Lmxlbmd0aDw0MD9pLnV0Zjgud3JpdGUodCxlLG4pOmUudXRmOFdyaXRlP2UudXRmOFdyaXRlKHQsbik6ZS53cml0ZSh0LG4pfW8uX2NvbmZpZ3VyZT1mdW5jdGlvbigpe28uYWxsb2M9aS5fQnVmZmVyX2FsbG9jVW5zYWZlLG8ud3JpdGVCeXRlc0J1ZmZlcj1pLkJ1ZmZlciYmaS5CdWZmZXIucHJvdG90eXBlIGluc3RhbmNlb2YgVWludDhBcnJheSYmXCJzZXRcIj09PWkuQnVmZmVyLnByb3RvdHlwZS5zZXQubmFtZT9mdW5jdGlvbih0LGUsbil7ZS5zZXQodCxuKX06ZnVuY3Rpb24odCxlLG4pe2lmKHQuY29weSl0LmNvcHkoZSxuLDAsdC5sZW5ndGgpO2Vsc2UgZm9yKHZhciByPTA7cjx0Lmxlbmd0aDspZVtuKytdPXRbcisrXX19LG8ucHJvdG90eXBlLmJ5dGVzPWZ1bmN0aW9uKHQpe2kuaXNTdHJpbmcodCkmJih0PWkuX0J1ZmZlcl9mcm9tKHQsXCJiYXNlNjRcIikpO3ZhciBlPXQubGVuZ3RoPj4+MDtyZXR1cm4gdGhpcy51aW50MzIoZSksZSYmdGhpcy5fcHVzaChvLndyaXRlQnl0ZXNCdWZmZXIsZSx0KSx0aGlzfSxvLnByb3RvdHlwZS5zdHJpbmc9ZnVuY3Rpb24odCl7dmFyIGU9aS5CdWZmZXIuYnl0ZUxlbmd0aCh0KTtyZXR1cm4gdGhpcy51aW50MzIoZSksZSYmdGhpcy5fcHVzaChhLGUsdCksdGhpc30sby5fY29uZmlndXJlKCl9LDc3MTQ6KHQsZSxuKT0+e1widXNlIHN0cmljdFwiO2UuUj12b2lkIDA7Y29uc3Qgcj1uKDY5MTkpLGk9big3NDQ4KTtlLlI9bmV3IGNsYXNze2FzeW5jIGluaXQoKXt9YXN5bmMgY3JlYXRlU2Vzc2lvbkhhbmRsZXIodCxlKXtjb25zdCBuPW5ldyByLlNlc3Npb24oZSk7cmV0dXJuIGF3YWl0IG4ubG9hZE1vZGVsKHQpLG5ldyBpLk9ubnhqc1Nlc3Npb25IYW5kbGVyKG4pfX19LDQyMDA6KHQsZSxuKT0+e1widXNlIHN0cmljdFwiO2UuYzg9ZS5yWD12b2lkIDA7Y29uc3Qgcj1uKDE2NzApLGk9big1MzgxKSxvPW4oMjE1NyksYT1uKDIzMDYpO2Uuclg9KCk9PntpZigoXCJudW1iZXJcIiE9dHlwZW9mIHIuZW52Lndhc20uaW5pdFRpbWVvdXR8fHIuZW52Lndhc20uaW5pdFRpbWVvdXQ8MCkmJihyLmVudi53YXNtLmluaXRUaW1lb3V0PTApLFwiYm9vbGVhblwiIT10eXBlb2Ygci5lbnYud2FzbS5zaW1kJiYoci5lbnYud2FzbS5zaW1kPSEwKSxcImJvb2xlYW5cIiE9dHlwZW9mIHIuZW52Lndhc20ucHJveHkmJihyLmVudi53YXNtLnByb3h5PSExKSxcIm51bWJlclwiIT10eXBlb2Ygci5lbnYud2FzbS5udW1UaHJlYWRzfHwhTnVtYmVyLmlzSW50ZWdlcihyLmVudi53YXNtLm51bVRocmVhZHMpfHxyLmVudi53YXNtLm51bVRocmVhZHM8PTApe2NvbnN0IHQ9XCJ1bmRlZmluZWRcIj09dHlwZW9mIG5hdmlnYXRvcj8oMCxpLmNwdXMpKCkubGVuZ3RoOm5hdmlnYXRvci5oYXJkd2FyZUNvbmN1cnJlbmN5O3IuZW52Lndhc20ubnVtVGhyZWFkcz1NYXRoLm1pbig0LE1hdGguY2VpbCgodHx8MSkvMikpfX0sZS5jOD1uZXcgY2xhc3N7YXN5bmMgaW5pdCgpeygwLGUuclgpKCksYXdhaXQoMCxvLmluaXRXYXNtKSgpfWFzeW5jIGNyZWF0ZVNlc3Npb25IYW5kbGVyKHQsZSl7Y29uc3Qgbj1uZXcgYS5Pbm54cnVudGltZVdlYkFzc2VtYmx5U2Vzc2lvbkhhbmRsZXI7cmV0dXJuIGF3YWl0IG4ubG9hZE1vZGVsKHQsZSksUHJvbWlzZS5yZXNvbHZlKG4pfX19LDYwMTg6ZnVuY3Rpb24odCxlLG4pe1widXNlIHN0cmljdFwiO3ZhciByPXRoaXMmJnRoaXMuX19jcmVhdGVCaW5kaW5nfHwoT2JqZWN0LmNyZWF0ZT9mdW5jdGlvbih0LGUsbixyKXt2b2lkIDA9PT1yJiYocj1uKTt2YXIgaT1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsbik7aSYmIShcImdldFwiaW4gaT8hZS5fX2VzTW9kdWxlOmkud3JpdGFibGV8fGkuY29uZmlndXJhYmxlKXx8KGk9e2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGVbbl19fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQscixpKX06ZnVuY3Rpb24odCxlLG4scil7dm9pZCAwPT09ciYmKHI9biksdFtyXT1lW25dfSksaT10aGlzJiZ0aGlzLl9fZXhwb3J0U3Rhcnx8ZnVuY3Rpb24odCxlKXtmb3IodmFyIG4gaW4gdClcImRlZmF1bHRcIj09PW58fE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLG4pfHxyKGUsdCxuKX07T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksaShuKDE2NzApLGUpO2NvbnN0IG89bigxNjcwKTt7Y29uc3QgdD1uKDc3MTQpLlI7KDAsby5yZWdpc3RlckJhY2tlbmQpKFwid2ViZ2xcIix0LC0xMCl9e2NvbnN0IHQ9big0MjAwKS5jODsoMCxvLnJlZ2lzdGVyQmFja2VuZCkoXCJjcHVcIix0LDEwKSwoMCxvLnJlZ2lzdGVyQmFja2VuZCkoXCJ3YXNtXCIsdCwxMCksKDAsby5yZWdpc3RlckJhY2tlbmQpKFwieG5ucGFja1wiLHQsOSl9fSwyNDY6KHQsZSk9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLmNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleT12b2lkIDA7Y2xhc3Mgbntjb25zdHJ1Y3Rvcih0KXtPYmplY3QuYXNzaWduKHRoaXMsdCl9Z2V0IGNhY2hlS2V5KCl7cmV0dXJuIHRoaXMuX2NhY2hlS2V5fHwodGhpcy5fY2FjaGVLZXk9T2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGhpcykuc29ydCgpLm1hcCgodD0+YCR7dGhpc1t0XX1gKSkuam9pbihcIjtcIikpLHRoaXMuX2NhY2hlS2V5fX1lLmNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleT10PT5uZXcgbih0KX0sNzc3ODoodCxlLG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5BdHRyaWJ1dGU9dm9pZCAwO2NvbnN0IHI9bigxNDQ2KSxpPW4oOTM5NSksbz1uKDkxNjIpLGE9bigyNTE3KTt2YXIgcz1pLm9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnM7Y2xhc3MgdXtjb25zdHJ1Y3Rvcih0KXtpZih0aGlzLl9hdHRyaWJ1dGVzPW5ldyBNYXAsbnVsbCE9dCl7Zm9yKGNvbnN0IGUgb2YgdCllIGluc3RhbmNlb2Ygci5vbm54LkF0dHJpYnV0ZVByb3RvP3RoaXMuX2F0dHJpYnV0ZXMuc2V0KGUubmFtZSxbdS5nZXRWYWx1ZShlKSx1LmdldFR5cGUoZSldKTplIGluc3RhbmNlb2Ygcy5BdHRyaWJ1dGUmJnRoaXMuX2F0dHJpYnV0ZXMuc2V0KGUubmFtZSgpLFt1LmdldFZhbHVlKGUpLHUuZ2V0VHlwZShlKV0pO2lmKHRoaXMuX2F0dHJpYnV0ZXMuc2l6ZTx0Lmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJkdXBsaWNhdGVkIGF0dHJpYnV0ZSBuYW1lc1wiKX19c2V0KHQsZSxuKXt0aGlzLl9hdHRyaWJ1dGVzLnNldCh0LFtuLGVdKX1kZWxldGUodCl7dGhpcy5fYXR0cmlidXRlcy5kZWxldGUodCl9Z2V0RmxvYXQodCxlKXtyZXR1cm4gdGhpcy5nZXQodCxcImZsb2F0XCIsZSl9Z2V0SW50KHQsZSl7cmV0dXJuIHRoaXMuZ2V0KHQsXCJpbnRcIixlKX1nZXRTdHJpbmcodCxlKXtyZXR1cm4gdGhpcy5nZXQodCxcInN0cmluZ1wiLGUpfWdldFRlbnNvcih0LGUpe3JldHVybiB0aGlzLmdldCh0LFwidGVuc29yXCIsZSl9Z2V0RmxvYXRzKHQsZSl7cmV0dXJuIHRoaXMuZ2V0KHQsXCJmbG9hdHNcIixlKX1nZXRJbnRzKHQsZSl7cmV0dXJuIHRoaXMuZ2V0KHQsXCJpbnRzXCIsZSl9Z2V0U3RyaW5ncyh0LGUpe3JldHVybiB0aGlzLmdldCh0LFwic3RyaW5nc1wiLGUpfWdldFRlbnNvcnModCxlKXtyZXR1cm4gdGhpcy5nZXQodCxcInRlbnNvcnNcIixlKX1nZXQodCxlLG4pe2NvbnN0IHI9dGhpcy5fYXR0cmlidXRlcy5nZXQodCk7aWYodm9pZCAwPT09cil7aWYodm9pZCAwIT09bilyZXR1cm4gbjt0aHJvdyBuZXcgRXJyb3IoYHJlcXVpcmVkIGF0dHJpYnV0ZSBub3QgZm91bmQ6ICR7dH1gKX1pZihyWzFdIT09ZSl0aHJvdyBuZXcgRXJyb3IoYHR5cGUgbWlzbWF0Y2g6IGV4cGVjdGVkICR7ZX0gYnV0IGdvdCAke3JbMV19YCk7cmV0dXJuIHJbMF19c3RhdGljIGdldFR5cGUodCl7Y29uc3QgZT10IGluc3RhbmNlb2Ygci5vbm54LkF0dHJpYnV0ZVByb3RvP3QudHlwZTp0LnR5cGUoKTtzd2l0Y2goZSl7Y2FzZSByLm9ubnguQXR0cmlidXRlUHJvdG8uQXR0cmlidXRlVHlwZS5GTE9BVDpyZXR1cm5cImZsb2F0XCI7Y2FzZSByLm9ubnguQXR0cmlidXRlUHJvdG8uQXR0cmlidXRlVHlwZS5JTlQ6cmV0dXJuXCJpbnRcIjtjYXNlIHIub25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlLlNUUklORzpyZXR1cm5cInN0cmluZ1wiO2Nhc2Ugci5vbm54LkF0dHJpYnV0ZVByb3RvLkF0dHJpYnV0ZVR5cGUuVEVOU09SOnJldHVyblwidGVuc29yXCI7Y2FzZSByLm9ubnguQXR0cmlidXRlUHJvdG8uQXR0cmlidXRlVHlwZS5GTE9BVFM6cmV0dXJuXCJmbG9hdHNcIjtjYXNlIHIub25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlLklOVFM6cmV0dXJuXCJpbnRzXCI7Y2FzZSByLm9ubnguQXR0cmlidXRlUHJvdG8uQXR0cmlidXRlVHlwZS5TVFJJTkdTOnJldHVyblwic3RyaW5nc1wiO2Nhc2Ugci5vbm54LkF0dHJpYnV0ZVByb3RvLkF0dHJpYnV0ZVR5cGUuVEVOU09SUzpyZXR1cm5cInRlbnNvcnNcIjtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgYXR0cmlidXRlIHR5cGUgaXMgbm90IHN1cHBvcnRlZCB5ZXQ6ICR7ci5vbm54LkF0dHJpYnV0ZVByb3RvLkF0dHJpYnV0ZVR5cGVbZV19YCl9fXN0YXRpYyBnZXRWYWx1ZSh0KXtjb25zdCBlPXQgaW5zdGFuY2VvZiByLm9ubnguQXR0cmlidXRlUHJvdG8/dC50eXBlOnQudHlwZSgpO2lmKGU9PT1yLm9ubnguQXR0cmlidXRlUHJvdG8uQXR0cmlidXRlVHlwZS5HUkFQSHx8ZT09PXIub25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlLkdSQVBIUyl0aHJvdyBuZXcgRXJyb3IoXCJncmFwaCBhdHRyaWJ1dGUgaXMgbm90IHN1cHBvcnRlZCB5ZXRcIik7Y29uc3Qgbj10aGlzLmdldFZhbHVlTm9DaGVjayh0KTtpZihlPT09ci5vbm54LkF0dHJpYnV0ZVByb3RvLkF0dHJpYnV0ZVR5cGUuSU5UJiZhLkxvbmdVdGlsLmlzTG9uZyhuKSlyZXR1cm4gYS5Mb25nVXRpbC5sb25nVG9OdW1iZXIobik7aWYoZT09PXIub25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlLklOVFMpe2NvbnN0IHQ9bixlPW5ldyBBcnJheSh0Lmxlbmd0aCk7Zm9yKGxldCBuPTA7bjx0Lmxlbmd0aDtuKyspe2NvbnN0IHI9dFtuXTtlW25dPWEuTG9uZ1V0aWwubG9uZ1RvTnVtYmVyKHIpfXJldHVybiBlfWlmKGU9PT1yLm9ubnguQXR0cmlidXRlUHJvdG8uQXR0cmlidXRlVHlwZS5URU5TT1IpcmV0dXJuIHQgaW5zdGFuY2VvZiByLm9ubnguQXR0cmlidXRlUHJvdG8/by5UZW5zb3IuZnJvbVByb3RvKG4pOm8uVGVuc29yLmZyb21PcnRUZW5zb3Iobik7aWYoZT09PXIub25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlLlRFTlNPUlMpe2lmKHQgaW5zdGFuY2VvZiByLm9ubnguQXR0cmlidXRlUHJvdG8pcmV0dXJuIG4ubWFwKCh0PT5vLlRlbnNvci5mcm9tUHJvdG8odCkpKTtpZih0IGluc3RhbmNlb2Ygcy5BdHRyaWJ1dGUpcmV0dXJuIG4ubWFwKCh0PT5vLlRlbnNvci5mcm9tT3J0VGVuc29yKHQpKSl9aWYoZT09PXIub25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlLlNUUklORyYmdCBpbnN0YW5jZW9mIHIub25ueC5BdHRyaWJ1dGVQcm90byl7Y29uc3QgdD1uO3JldHVybigwLGEuZGVjb2RlVXRmOFN0cmluZykodCl9cmV0dXJuIGU9PT1yLm9ubnguQXR0cmlidXRlUHJvdG8uQXR0cmlidXRlVHlwZS5TVFJJTkdTJiZ0IGluc3RhbmNlb2Ygci5vbm54LkF0dHJpYnV0ZVByb3RvP24ubWFwKGEuZGVjb2RlVXRmOFN0cmluZyk6bn1zdGF0aWMgZ2V0VmFsdWVOb0NoZWNrKHQpe3JldHVybiB0IGluc3RhbmNlb2Ygci5vbm54LkF0dHJpYnV0ZVByb3RvP3RoaXMuZ2V0VmFsdWVOb0NoZWNrRnJvbU9ubnhGb3JtYXQodCk6dGhpcy5nZXRWYWx1ZU5vQ2hlY2tGcm9tT3J0Rm9ybWF0KHQpfXN0YXRpYyBnZXRWYWx1ZU5vQ2hlY2tGcm9tT25ueEZvcm1hdCh0KXtzd2l0Y2godC50eXBlKXtjYXNlIHIub25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlLkZMT0FUOnJldHVybiB0LmY7Y2FzZSByLm9ubnguQXR0cmlidXRlUHJvdG8uQXR0cmlidXRlVHlwZS5JTlQ6cmV0dXJuIHQuaTtjYXNlIHIub25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlLlNUUklORzpyZXR1cm4gdC5zO2Nhc2Ugci5vbm54LkF0dHJpYnV0ZVByb3RvLkF0dHJpYnV0ZVR5cGUuVEVOU09SOnJldHVybiB0LnQ7Y2FzZSByLm9ubnguQXR0cmlidXRlUHJvdG8uQXR0cmlidXRlVHlwZS5HUkFQSDpyZXR1cm4gdC5nO2Nhc2Ugci5vbm54LkF0dHJpYnV0ZVByb3RvLkF0dHJpYnV0ZVR5cGUuRkxPQVRTOnJldHVybiB0LmZsb2F0cztjYXNlIHIub25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlLklOVFM6cmV0dXJuIHQuaW50cztjYXNlIHIub25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlLlNUUklOR1M6cmV0dXJuIHQuc3RyaW5ncztjYXNlIHIub25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlLlRFTlNPUlM6cmV0dXJuIHQudGVuc29ycztjYXNlIHIub25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlLkdSQVBIUzpyZXR1cm4gdC5ncmFwaHM7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIGF0dHJpYnV0ZSB0eXBlOiAke3Iub25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlW3QudHlwZV19YCl9fXN0YXRpYyBnZXRWYWx1ZU5vQ2hlY2tGcm9tT3J0Rm9ybWF0KHQpe3N3aXRjaCh0LnR5cGUoKSl7Y2FzZSBzLkF0dHJpYnV0ZVR5cGUuRkxPQVQ6cmV0dXJuIHQuZigpO2Nhc2Ugcy5BdHRyaWJ1dGVUeXBlLklOVDpyZXR1cm4gdC5pKCk7Y2FzZSBzLkF0dHJpYnV0ZVR5cGUuU1RSSU5HOnJldHVybiB0LnMoKTtjYXNlIHMuQXR0cmlidXRlVHlwZS5URU5TT1I6cmV0dXJuIHQudCgpO2Nhc2Ugcy5BdHRyaWJ1dGVUeXBlLkdSQVBIOnJldHVybiB0LmcoKTtjYXNlIHMuQXR0cmlidXRlVHlwZS5GTE9BVFM6cmV0dXJuIHQuZmxvYXRzQXJyYXkoKTtjYXNlIHMuQXR0cmlidXRlVHlwZS5JTlRTOntjb25zdCBlPVtdO2ZvcihsZXQgbj0wO248dC5pbnRzTGVuZ3RoKCk7bisrKWUucHVzaCh0LmludHMobikpO3JldHVybiBlfWNhc2Ugcy5BdHRyaWJ1dGVUeXBlLlNUUklOR1M6e2NvbnN0IGU9W107Zm9yKGxldCBuPTA7bjx0LnN0cmluZ3NMZW5ndGgoKTtuKyspZS5wdXNoKHQuc3RyaW5ncyhuKSk7cmV0dXJuIGV9Y2FzZSBzLkF0dHJpYnV0ZVR5cGUuVEVOU09SUzp7Y29uc3QgZT1bXTtmb3IobGV0IG49MDtuPHQudGVuc29yc0xlbmd0aCgpO24rKyllLnB1c2godC50ZW5zb3JzKG4pKTtyZXR1cm4gZX1kZWZhdWx0OnRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgYXR0cmlidXRlIHR5cGU6ICR7cy5BdHRyaWJ1dGVUeXBlW3QudHlwZSgpXX1gKX19fWUuQXR0cmlidXRlPXV9LDcwOTE6KHQsZSxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUucmVzb2x2ZUJhY2tlbmQ9ZS5iYWNrZW5kPXZvaWQgMDtjb25zdCByPW4oNTAzOCksaT1uZXcgTWFwO2FzeW5jIGZ1bmN0aW9uIG8odCl7Y29uc3Qgbj1lLmJhY2tlbmQ7aWYodm9pZCAwIT09blt0XSYmZnVuY3Rpb24odCl7Y29uc3QgZT10O3JldHVyblwiaW5pdGlhbGl6ZVwiaW4gZSYmXCJmdW5jdGlvblwiPT10eXBlb2YgZS5pbml0aWFsaXplJiZcImNyZWF0ZVNlc3Npb25IYW5kbGVyXCJpbiBlJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBlLmNyZWF0ZVNlc3Npb25IYW5kbGVyJiZcImRpc3Bvc2VcImluIGUmJlwiZnVuY3Rpb25cIj09dHlwZW9mIGUuZGlzcG9zZX0oblt0XSkpe2NvbnN0IGU9blt0XTtsZXQgcj1lLmluaXRpYWxpemUoKTtpZihcIm9iamVjdFwiPT10eXBlb2YgciYmXCJ0aGVuXCJpbiByJiYocj1hd2FpdCByKSxyKXJldHVybiBpLnNldCh0LGUpLGV9fWUuYmFja2VuZD17d2ViZ2w6bmV3IHIuV2ViR0xCYWNrZW5kfSxlLnJlc29sdmVCYWNrZW5kPWFzeW5jIGZ1bmN0aW9uIHQoZSl7aWYoIWUpcmV0dXJuIHQoW1wid2ViZ2xcIl0pO3tjb25zdCB0PVwic3RyaW5nXCI9PXR5cGVvZiBlP1tlXTplO2Zvcihjb25zdCBlIG9mIHQpe2NvbnN0IHQ9aS5nZXQoZSk7aWYodClyZXR1cm4gdDtjb25zdCBuPWF3YWl0IG8oZSk7aWYobilyZXR1cm4gbn19dGhyb3cgbmV3IEVycm9yKFwibm8gYXZhaWxhYmxlIGJhY2tlbmQgdG8gdXNlXCIpfX0sNTAzODoodCxlLG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5XZWJHTEJhY2tlbmQ9dm9pZCAwO2NvbnN0IHI9bigxNjcwKSxpPW4oNjIzMSksbz1uKDY0MTYpLGE9big3MzA1KTtlLldlYkdMQmFja2VuZD1jbGFzc3tnZXQgY29udGV4dElkKCl7cmV0dXJuIHIuZW52LndlYmdsLmNvbnRleHRJZH1zZXQgY29udGV4dElkKHQpe3IuZW52LndlYmdsLmNvbnRleHRJZD10fWdldCBtYXRtdWxNYXhCYXRjaFNpemUoKXtyZXR1cm4gci5lbnYud2ViZ2wubWF0bXVsTWF4QmF0Y2hTaXplfXNldCBtYXRtdWxNYXhCYXRjaFNpemUodCl7ci5lbnYud2ViZ2wubWF0bXVsTWF4QmF0Y2hTaXplPXR9Z2V0IHRleHR1cmVDYWNoZU1vZGUoKXtyZXR1cm4gci5lbnYud2ViZ2wudGV4dHVyZUNhY2hlTW9kZX1zZXQgdGV4dHVyZUNhY2hlTW9kZSh0KXtyLmVudi53ZWJnbC50ZXh0dXJlQ2FjaGVNb2RlPXR9Z2V0IHBhY2soKXtyZXR1cm4gci5lbnYud2ViZ2wucGFja31zZXQgcGFjayh0KXtyLmVudi53ZWJnbC5wYWNrPXR9Z2V0IGFzeW5jKCl7cmV0dXJuIHIuZW52LndlYmdsLmFzeW5jfXNldCBhc3luYyh0KXtyLmVudi53ZWJnbC5hc3luYz10fWluaXRpYWxpemUoKXt0cnl7cmV0dXJuIHRoaXMuZ2xDb250ZXh0PSgwLGEuY3JlYXRlV2ViR0xDb250ZXh0KSh0aGlzLmNvbnRleHRJZCksXCJudW1iZXJcIiE9dHlwZW9mIHRoaXMubWF0bXVsTWF4QmF0Y2hTaXplJiYodGhpcy5tYXRtdWxNYXhCYXRjaFNpemU9MTYpLFwic3RyaW5nXCIhPXR5cGVvZiB0aGlzLnRleHR1cmVDYWNoZU1vZGUmJih0aGlzLnRleHR1cmVDYWNoZU1vZGU9XCJmdWxsXCIpLFwiYm9vbGVhblwiIT10eXBlb2YgdGhpcy5wYWNrJiYodGhpcy5wYWNrPSExKSxcImJvb2xlYW5cIiE9dHlwZW9mIHRoaXMuYXN5bmMmJih0aGlzLmFzeW5jPSExKSxpLkxvZ2dlci5zZXRXaXRoRW52KHIuZW52KSxpLkxvZ2dlci52ZXJib3NlKFwiV2ViR0xCYWNrZW5kXCIsYENyZWF0ZWQgV2ViR0xDb250ZXh0OiAke3R5cGVvZiB0aGlzLmdsQ29udGV4dH0gd2l0aCBtYXRtdWxNYXhCYXRjaFNpemU6ICR7dGhpcy5tYXRtdWxNYXhCYXRjaFNpemV9OyB0ZXh0dXJlQ2FjaGVNb2RlOiAke3RoaXMudGV4dHVyZUNhY2hlTW9kZX07IHBhY2s6ICR7dGhpcy5wYWNrfTsgYXN5bmM6ICR7dGhpcy5hc3luY30uYCksITB9Y2F0Y2godCl7cmV0dXJuIGkuTG9nZ2VyLndhcm5pbmcoXCJXZWJHTEJhY2tlbmRcIixgVW5hYmxlIHRvIGluaXRpYWxpemUgV2ViR0xCYWNrZW5kLiAke3R9YCksITF9fWNyZWF0ZVNlc3Npb25IYW5kbGVyKHQpe3JldHVybiBuZXcgby5XZWJHTFNlc3Npb25IYW5kbGVyKHRoaXMsdCl9ZGlzcG9zZSgpe3RoaXMuZ2xDb250ZXh0LmRpc3Bvc2UoKX19fSw1MTA3Oih0LGUsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLkNvb3Jkc0dsc2xMaWI9dm9pZCAwO2NvbnN0IHI9bigyNTE3KSxpPW4oODUyMCksbz1uKDUwNjApLGE9big3ODU5KSxzPW4oOTM5MCk7Y2xhc3MgdSBleHRlbmRzIGkuR2xzbExpYntjb25zdHJ1Y3Rvcih0KXtzdXBlcih0KX1nZXRGdW5jdGlvbnMoKXtyZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSx0aGlzLm9mZnNldFRvQ29vcmRzKCkpLHRoaXMuY29vcmRzVG9PZmZzZXQoKSksdGhpcy50b1ZlYygpKSx0aGlzLnZhbHVlRnJvbSgpKSx0aGlzLmdldENvbW1vblV0aWxGdW5jcygpKSx0aGlzLmdldElucHV0c1NhbXBsaW5nU25pcHBldHMoKSksdGhpcy5nZXRPdXRwdXRTYW1wbGluZ1NuaXBwZXQoKSl9Z2V0Q3VzdG9tVHlwZXMoKXtyZXR1cm57fX1vZmZzZXRUb0Nvb3Jkcygpe3JldHVybntvZmZzZXRUb0Nvb3JkczpuZXcgaS5HbHNsTGliUm91dGluZShcIlxcbiAgICAgIHZlYzIgb2Zmc2V0VG9Db29yZHMoaW50IG9mZnNldCwgaW50IHdpZHRoLCBpbnQgaGVpZ2h0KSB7XFxuICAgICAgICBpbnQgdCA9IG9mZnNldCAvIHdpZHRoO1xcbiAgICAgICAgaW50IHMgPSBvZmZzZXQgLSB0KndpZHRoO1xcbiAgICAgICAgdmVjMiBjb29yZHMgPSAodmVjMihzLHQpICsgdmVjMigwLjUsMC41KSkgLyB2ZWMyKHdpZHRoLCBoZWlnaHQpO1xcbiAgICAgICAgcmV0dXJuIGNvb3JkcztcXG4gICAgICB9XFxuICAgICAgXCIpfX1jb29yZHNUb09mZnNldCgpe3JldHVybntjb29yZHNUb09mZnNldDpuZXcgaS5HbHNsTGliUm91dGluZShcIlxcbiAgICAgIGludCBjb29yZHNUb09mZnNldCh2ZWMyIGNvb3JkcywgaW50IHdpZHRoLCBpbnQgaGVpZ2h0KSB7XFxuICAgICAgICBmbG9hdCBzID0gY29vcmRzLnMgKiBmbG9hdCh3aWR0aCk7XFxuICAgICAgICBmbG9hdCB0ID0gY29vcmRzLnQgKiBmbG9hdChoZWlnaHQpO1xcbiAgICAgICAgaW50IG9mZnNldCA9IGludCh0KSAqIHdpZHRoICsgaW50KHMpO1xcbiAgICAgICAgcmV0dXJuIG9mZnNldDtcXG4gICAgICB9XFxuICAgICAgXCIpfX1nZXRPdXRwdXRTYW1wbGluZ1NuaXBwZXQoKXtjb25zdCB0PXRoaXMuY29udGV4dC5vdXRwdXRUZXh0dXJlTGF5b3V0O3JldHVybiB0LmlzUGFja2VkP3RoaXMuZ2V0UGFja2VkT3V0cHV0U2FtcGxpbmdTbmlwcGV0KHQpOnRoaXMuZ2V0VW5wYWNrZWRPdXRwdXRTYW1wbGluZ1NuaXBwZXQodCl9Z2V0UGFja2VkT3V0cHV0U2FtcGxpbmdTbmlwcGV0KHQpe2NvbnN0IGU9dC51bnBhY2tlZFNoYXBlLG49W3Qud2lkdGgsdC5oZWlnaHRdLHI9e30sYT1cImdldE91dHB1dENvb3Jkc1wiO3N3aXRjaChlLmxlbmd0aCl7Y2FzZSAwOnJbYV09dGhpcy5nZXRPdXRwdXRTY2FsYXJDb29yZHMoKTticmVhaztjYXNlIDE6clthXT10aGlzLmdldE91dHB1dFBhY2tlZDFEQ29vcmRzKGUsbik7YnJlYWs7Y2FzZSAyOnJbYV09dGhpcy5nZXRPdXRwdXRQYWNrZWQyRENvb3JkcyhlLG4pO2JyZWFrO2Nhc2UgMzpyW2FdPXRoaXMuZ2V0T3V0cHV0UGFja2VkM0RDb29yZHMoZSxuKTticmVhaztkZWZhdWx0OnJbYV09dGhpcy5nZXRPdXRwdXRQYWNrZWRORENvb3JkcyhlLG4pfWNvbnN0IHM9YFxcbiAgICAgIHZvaWQgc2V0T3V0cHV0KHZlYzQgdmFsKSB7XFxuICAgICAgICAkeygwLG8uZ2V0R2xzbCkodGhpcy5jb250ZXh0LmdsQ29udGV4dC52ZXJzaW9uKS5vdXRwdXR9ID0gdmFsO1xcbiAgICAgIH1cXG4gICAgYDtyZXR1cm4gci5mbG9hdFRleHR1cmVTZXRSR0JBPW5ldyBpLkdsc2xMaWJSb3V0aW5lKHMpLHJ9Z2V0VW5wYWNrZWRPdXRwdXRTYW1wbGluZ1NuaXBwZXQodCl7Y29uc3QgZT10LnVucGFja2VkU2hhcGUsbj1bdC53aWR0aCx0LmhlaWdodF0scj17fSxhPVwiZ2V0T3V0cHV0Q29vcmRzXCI7c3dpdGNoKGUubGVuZ3RoKXtjYXNlIDA6clthXT10aGlzLmdldE91dHB1dFNjYWxhckNvb3JkcygpO2JyZWFrO2Nhc2UgMTpyW2FdPXRoaXMuZ2V0T3V0cHV0VW5wYWNrZWQxRENvb3JkcyhlLG4pO2JyZWFrO2Nhc2UgMjpyW2FdPXRoaXMuZ2V0T3V0cHV0VW5wYWNrZWQyRENvb3JkcyhlLG4pO2JyZWFrO2Nhc2UgMzpyW2FdPXRoaXMuZ2V0T3V0cHV0VW5wYWNrZWQzRENvb3JkcyhlLG4pO2JyZWFrO2Nhc2UgNDpyW2FdPXRoaXMuZ2V0T3V0cHV0VW5wYWNrZWQ0RENvb3JkcyhlLG4pO2JyZWFrO2Nhc2UgNTpyW2FdPXRoaXMuZ2V0T3V0cHV0VW5wYWNrZWQ1RENvb3JkcyhlLG4pO2JyZWFrO2Nhc2UgNjpyW2FdPXRoaXMuZ2V0T3V0cHV0VW5wYWNrZWQ2RENvb3JkcyhlLG4pO2JyZWFrO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBvdXRwdXQgZGltZW5zaW9uYWxpdHk6ICR7ZS5sZW5ndGh9YCl9Y29uc3Qgcz1gXFxuICAgICAgICB2b2lkIHNldE91dHB1dChmbG9hdCB2YWwpIHtcXG4gICAgICAgICAgJHsoMCxvLmdldEdsc2wpKHRoaXMuY29udGV4dC5nbENvbnRleHQudmVyc2lvbikub3V0cHV0fSA9IHZlYzQodmFsLCAwLCAwLCAwKTtcXG4gICAgICAgIH1cXG4gICAgYDtyZXR1cm4gci5mbG9hdFRleHR1cmVTZXRSPW5ldyBpLkdsc2xMaWJSb3V0aW5lKHMpLHJ9Z2V0T3V0cHV0U2NhbGFyQ29vcmRzKCl7cmV0dXJuIG5ldyBpLkdsc2xMaWJSb3V0aW5lKFwiXFxuICAgICAgaW50IGdldE91dHB1dENvb3JkcygpIHtcXG4gICAgICAgIHJldHVybiAwO1xcbiAgICAgIH1cXG4gICAgXCIpfWdldE91dHB1dFBhY2tlZDFEQ29vcmRzKHQsZSl7Y29uc3Qgbj1lO2xldCByPVwiXCI7cmV0dXJuIDE9PT1uWzBdPyhyPWBcXG4gICAgICAgICAgaW50IGdldE91dHB1dENvb3JkcygpIHtcXG4gICAgICAgICAgICByZXR1cm4gMiAqIGludChUZXhDb29yZHMueSAqICR7blsxXX0uMCk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIGAsbmV3IGkuR2xzbExpYlJvdXRpbmUocikpOjE9PT1uWzFdPyhyPWBcXG4gICAgICAgICAgaW50IGdldE91dHB1dENvb3JkcygpIHtcXG4gICAgICAgICAgICByZXR1cm4gMiAqIGludChUZXhDb29yZHMueCAqICR7blswXX0uMCk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIGAsbmV3IGkuR2xzbExpYlJvdXRpbmUocikpOihyPWBcXG4gICAgICAgIGludCBnZXRPdXRwdXRDb29yZHMoKSB7XFxuICAgICAgICAgIGl2ZWMyIHJlc1RleFJDID0gaXZlYzIoVGV4Q29vcmRzLnh5ICpcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZWMyKCR7blswXX0sICR7blsxXX0pKTtcXG4gICAgICAgICAgcmV0dXJuIDIgKiAocmVzVGV4UkMueSAqICR7blswXX0gKyByZXNUZXhSQy54KTtcXG4gICAgICAgIH1cXG4gICAgICBgLG5ldyBpLkdsc2xMaWJSb3V0aW5lKHIpKX1nZXRPdXRwdXRQYWNrZWQyRENvb3Jkcyh0LGUpe2xldCBuPVwiXCI7aWYoci5BcnJheVV0aWwuYXJyYXlzRXF1YWwodCxlKSlyZXR1cm4gbj1gXFxuICAgICAgICBpdmVjMiBnZXRPdXRwdXRDb29yZHMoKSB7XFxuICAgICAgICAgIHJldHVybiAyICogaXZlYzIoVGV4Q29vcmRzLnh5ICogdmVjMigke2VbMF19LCAke2VbMV19KSk7XFxuICAgICAgICB9XFxuICAgICAgYCxuZXcgaS5HbHNsTGliUm91dGluZShuKTtjb25zdCBvPWUsYT1NYXRoLmNlaWwodFsxXS8yKTtyZXR1cm4gbj1gXFxuICAgICAgICBpdmVjMiBnZXRPdXRwdXRDb29yZHMoKSB7XFxuICAgICAgICAgIGl2ZWMyIHJlc1RleFJDID0gaXZlYzIoVGV4Q29vcmRzLnh5ICpcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIoJHtvWzBdfSwgJHtvWzFdfSkpO1xcblxcbiAgICAgICAgICBpbnQgaW5kZXggPSByZXNUZXhSQy55ICogJHtvWzBdfSArIHJlc1RleFJDLng7XFxuXFxuICAgICAgICAgIC8vIHJldmVyc2UgciBhbmQgYyBvcmRlciBmb3IgcGFja2VkIHRleHR1cmVcXG4gICAgICAgICAgaW50IHIgPSBpbW9kKGluZGV4LCAke2F9KSAqIDI7XFxuICAgICAgICAgIGludCBjID0gMiAqIChpbmRleCAvICR7YX0pO1xcblxcbiAgICAgICAgICByZXR1cm4gaXZlYzIociwgYyk7XFxuICAgICAgICB9XFxuICAgICAgYCxuZXcgaS5HbHNsTGliUm91dGluZShuKX1nZXRPdXRwdXRQYWNrZWQzRENvb3Jkcyh0LGUpe2NvbnN0IG49W2VbMF0sZVsxXV0scj1NYXRoLmNlaWwodFsyXS8yKSxvPXIqTWF0aC5jZWlsKHRbMV0vMiksYT1gXFxuICAgICAgICBpdmVjMyBnZXRPdXRwdXRDb29yZHMoKSB7XFxuICAgICAgICAgIGl2ZWMyIHJlc1RleFJDID0gaXZlYzIoVGV4Q29vcmRzLnh5ICpcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIoJHtuWzBdfSwgJHtuWzFdfSkpO1xcbiAgICAgICAgICBpbnQgaW5kZXggPSByZXNUZXhSQy55ICogJHtuWzBdfSArIHJlc1RleFJDLng7XFxuXFxuICAgICAgICAgIGludCBiID0gaW5kZXggLyAke299O1xcbiAgICAgICAgICBpbmRleCAtPSBiICogJHtvfTtcXG5cXG4gICAgICAgICAgLy8gcmV2ZXJzZSByIGFuZCBjIG9yZGVyIGZvciBwYWNrZWQgdGV4dHVyZVxcbiAgICAgICAgICBpbnQgciA9IGltb2QoaW5kZXgsICR7cn0pICogMjtcXG4gICAgICAgICAgaW50IGMgPSAyICogKGluZGV4IC8gJHtyfSk7XFxuXFxuICAgICAgICAgIHJldHVybiBpdmVjMyhiLCByLCBjKTtcXG4gICAgICAgIH1cXG4gICAgICBgO3JldHVybiBuZXcgaS5HbHNsTGliUm91dGluZShhKX1nZXRPdXRwdXRQYWNrZWRORENvb3Jkcyh0LGUpe2NvbnN0IG49W2VbMF0sZVsxXV0scj1NYXRoLmNlaWwodFt0Lmxlbmd0aC0xXS8yKSxvPXIqTWF0aC5jZWlsKHRbdC5sZW5ndGgtMl0vMik7bGV0IGE9byxzPVwiXCIsdT1cImIsIHIsIGNcIjtmb3IobGV0IGU9MjtlPHQubGVuZ3RoLTE7ZSsrKWEqPXRbdC5sZW5ndGgtZS0xXSxzPWBcXG4gICAgICBpbnQgYiR7ZX0gPSBpbmRleCAvICR7YX07XFxuICAgICAgaW5kZXggLT0gYiR7ZX0gKiAke2F9O1xcbiAgICBgK3MsdT1gYiR7ZX0sIGArdTtjb25zdCBjPWBcXG4gICAgICBpdmVjJHt0Lmxlbmd0aH0gZ2V0T3V0cHV0Q29vcmRzKCkge1xcbiAgICAgICAgaXZlYzIgcmVzVGV4UkMgPSBpdmVjMihUZXhDb29yZHMueHkgKlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIoJHtuWzBdfSwgJHtuWzFdfSkpO1xcbiAgICAgICAgaW50IGluZGV4ID0gcmVzVGV4UkMueSAqICR7blswXX0gKyByZXNUZXhSQy54O1xcblxcbiAgICAgICAgJHtzfVxcblxcbiAgICAgICAgaW50IGIgPSBpbmRleCAvICR7b307XFxuICAgICAgICBpbmRleCAtPSBiICogJHtvfTtcXG5cXG4gICAgICAgIC8vIHJldmVyc2UgciBhbmQgYyBvcmRlciBmb3IgcGFja2VkIHRleHR1cmVcXG4gICAgICAgIGludCByID0gaW1vZChpbmRleCwgJHtyfSkgKiAyO1xcbiAgICAgICAgaW50IGMgPSAyICogKGluZGV4IC8gJHtyfSk7XFxuXFxuICAgICAgICByZXR1cm4gaXZlYyR7dC5sZW5ndGh9KCR7dX0pO1xcbiAgICAgIH1cXG4gICAgYDtyZXR1cm4gbmV3IGkuR2xzbExpYlJvdXRpbmUoYyl9Z2V0T3V0cHV0VW5wYWNrZWQxRENvb3Jkcyh0LGUpe2NvbnN0IG49YFxcbiAgICAgICAgaW50IGdldE91dHB1dENvb3JkcygpIHtcXG4gICAgICAgICAgaXZlYzIgcmVzVGV4UkMgPSBpdmVjMihUZXhDb29yZHMueHkgKlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVjMigke2VbMF19LCAke2VbMV19KSk7XFxuICAgICAgICAgIHJldHVybiByZXNUZXhSQy55ICogJHtlWzBdfSArIHJlc1RleFJDLng7XFxuICAgICAgICB9XFxuICAgICAgYDtyZXR1cm4gbmV3IGkuR2xzbExpYlJvdXRpbmUobil9Z2V0T3V0cHV0VW5wYWNrZWQyRENvb3Jkcyh0LGUpe2NvbnN0IG49YFxcbiAgICAgICAgaXZlYzIgZ2V0T3V0cHV0Q29vcmRzKCkge1xcbiAgICAgICAgICBpdmVjMiByZXNUZXhSQyA9IGl2ZWMyKFRleENvb3Jkcy54eSAqXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZWMyKCR7ZVswXX0sICR7ZVsxXX0pKTtcXG4gICAgICAgICAgaW50IGluZGV4ID0gcmVzVGV4UkMueSAqICR7ZVswXX0gKyByZXNUZXhSQy54O1xcbiAgICAgICAgICBpbnQgciA9IGluZGV4IC8gJHt0WzFdfTtcXG4gICAgICAgICAgaW50IGMgPSBpbmRleCAtIHIgKiAke3RbMV19O1xcbiAgICAgICAgICByZXR1cm4gaXZlYzIociwgYyk7XFxuICAgICAgICB9XFxuICAgICAgYDtyZXR1cm4gbmV3IGkuR2xzbExpYlJvdXRpbmUobil9Z2V0T3V0cHV0VW5wYWNrZWQzRENvb3Jkcyh0LGUpe2xldCBuPVwiXCI7Y29uc3Qgcj10Lmxlbmd0aDtsZXQgbz1udWxsO3I8MiYmKG89W10pLG89bmV3IEFycmF5KHItMSksb1tyLTJdPXRbci0xXTtmb3IobGV0IGU9ci0zO2U+PTA7LS1lKW9bZV09b1tlKzFdKnRbZSsxXTtjb25zdCBhPVtcInJcIixcImNcIixcImRcIl0scz1vLm1hcCgoKHQsZSk9PmBpbnQgJHthW2VdfSA9IGluZGV4IC8gJHt0fTsgJHtlPT09by5sZW5ndGgtMT9gaW50ICR7YVtlKzFdfSA9IGluZGV4IC0gJHthW2VdfSAqICR7dH1gOmBpbmRleCAtPSAke2FbZV19ICogJHt0fWB9O2ApKS5qb2luKFwiXCIpO3JldHVybiBuPWBcXG4gICAgICAgIGl2ZWMzIGdldE91dHB1dENvb3JkcygpIHtcXG4gICAgICAgICAgaXZlYzIgcmVzVGV4UkMgPSBpdmVjMihUZXhDb29yZHMueHkgKlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVjMigke2VbMF19LCAke2VbMV19KSk7XFxuICAgICAgICAgIGludCBpbmRleCA9IHJlc1RleFJDLnkgKiAke2VbMF19ICsgcmVzVGV4UkMueDtcXG4gICAgICAgICAgJHtzfVxcbiAgICAgICAgICByZXR1cm4gaXZlYzMociwgYywgZCk7XFxuICAgICAgICB9XFxuICAgICAgYCxuZXcgaS5HbHNsTGliUm91dGluZShuKX1nZXRPdXRwdXRVbnBhY2tlZDREQ29vcmRzKHQsZSl7bGV0IG49XCJcIjtjb25zdCByPXQubGVuZ3RoO2xldCBvPW51bGw7cjwyJiYobz1bXSksbz1uZXcgQXJyYXkoci0xKSxvW3ItMl09dFtyLTFdO2ZvcihsZXQgZT1yLTM7ZT49MDstLWUpb1tlXT1vW2UrMV0qdFtlKzFdO2NvbnN0IGE9W1wiclwiLFwiY1wiLFwiZFwiLFwiZDJcIl0scz1vLm1hcCgoKHQsZSk9PmBpbnQgJHthW2VdfSA9IGluZGV4IC8gJHt0fTsgJHtlPT09by5sZW5ndGgtMT9gaW50ICR7YVtlKzFdfSA9IGluZGV4IC0gJHthW2VdfSAqICR7dH1gOmBpbmRleCAtPSAke2FbZV19ICogJHt0fWB9O2ApKS5qb2luKFwiXCIpO3JldHVybiBuPWBcXG4gICAgICBpdmVjNCBnZXRPdXRwdXRDb29yZHMoKSB7XFxuICAgICAgICAgIGl2ZWMyIHJlc1RleFJDID0gaXZlYzIoVGV4Q29vcmRzLnh5ICpcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIoJHtlWzBdfSwgJHtlWzFdfSkpO1xcbiAgICAgICAgICBpbnQgaW5kZXggPSByZXNUZXhSQy55ICogJHtlWzBdfSArIHJlc1RleFJDLng7XFxuICAgICAgICAgICR7c31cXG4gICAgICAgICAgcmV0dXJuIGl2ZWM0KHIsIGMsIGQsIGQyKTtcXG4gICAgICAgIH1cXG4gICAgICBgLG5ldyBpLkdsc2xMaWJSb3V0aW5lKG4pfWdldE91dHB1dFVucGFja2VkNURDb29yZHModCxlKXtsZXQgbj1cIlwiO2NvbnN0IHI9dC5sZW5ndGg7bGV0IG89bnVsbDtyPDImJihvPVtdKSxvPW5ldyBBcnJheShyLTEpLG9bci0yXT10W3ItMV07Zm9yKGxldCBlPXItMztlPj0wOy0tZSlvW2VdPW9bZSsxXSp0W2UrMV07Y29uc3QgYT1bXCJyXCIsXCJjXCIsXCJkXCIsXCJkMlwiLFwiZDNcIl0scz1vLm1hcCgoKHQsZSk9PmBpbnQgJHthW2VdfSA9IGluZGV4IC8gJHt0fTsgJHtlPT09by5sZW5ndGgtMT9gaW50ICR7YVtlKzFdfSA9IGluZGV4IC0gJHthW2VdfSAqICR7dH1gOmBpbmRleCAtPSAke2FbZV19ICogJHt0fWB9O2ApKS5qb2luKFwiXCIpO3JldHVybiBuPWBcXG4gICAgICBpdmVjNSBnZXRPdXRwdXRDb29yZHMoKSB7XFxuICAgICAgICAgIGl2ZWMyIHJlc1RleFJDID0gaXZlYzIoVGV4Q29vcmRzLnh5ICpcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIoJHtlWzBdfSwgJHtlWzFdfSkpO1xcbiAgICAgICAgICBpbnQgaW5kZXggPSByZXNUZXhSQy55ICogJHtlWzBdfSArIHJlc1RleFJDLng7XFxuICAgICAgICAgICR7c31cXG4gICAgICAgICAgcmV0dXJuIGl2ZWM1KHIsIGMsIGQsIGQyLCBkMyk7XFxuICAgICAgICB9XFxuICAgICAgYCxuZXcgaS5HbHNsTGliUm91dGluZShuKX1nZXRPdXRwdXRVbnBhY2tlZDZEQ29vcmRzKHQsZSl7bGV0IG49XCJcIjtjb25zdCByPXQubGVuZ3RoO2xldCBvPW51bGw7cjwyJiYobz1bXSksbz1uZXcgQXJyYXkoci0xKSxvW3ItMl09dFtyLTFdO2ZvcihsZXQgZT1yLTM7ZT49MDstLWUpb1tlXT1vW2UrMV0qdFtlKzFdO2NvbnN0IGE9W1wiclwiLFwiY1wiLFwiZFwiLFwiZDJcIixcImQzXCIsXCJkNFwiXSxzPW8ubWFwKCgodCxlKT0+YGludCAke2FbZV19ID0gaW5kZXggLyAke3R9OyAke2U9PT1vLmxlbmd0aC0xP2BpbnQgJHthW2UrMV19ID0gaW5kZXggLSAke2FbZV19ICogJHt0fWA6YGluZGV4IC09ICR7YVtlXX0gKiAke3R9YH07YCkpLmpvaW4oXCJcIik7cmV0dXJuIG49YFxcbiAgICAgaXZlYzYgZ2V0T3V0cHV0Q29vcmRzKCkge1xcbiAgICAgICAgIGl2ZWMyIHJlc1RleFJDID0gaXZlYzIoVGV4Q29vcmRzLnh5ICpcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVjMigke2VbMF19LCAke2VbMV19KSk7XFxuICAgICAgICAgaW50IGluZGV4ID0gcmVzVGV4UkMueSAqICR7ZVswXX0gKyByZXNUZXhSQy54O1xcbiAgICAgICAgICR7c31cXG4gICAgICAgICByZXR1cm4gaXZlYzYociwgYywgZCwgZDIsIGQzLCBkNCk7XFxuICAgICAgIH1cXG4gICAgIGAsbmV3IGkuR2xzbExpYlJvdXRpbmUobil9Z2V0Q29tbW9uVXRpbEZ1bmNzKCl7Y29uc3QgdD17fTtsZXQgZT1cInV2RnJvbUZsYXRcIjt0W2VdPW5ldyBpLkdsc2xMaWJSb3V0aW5lKFwiXFxuICAgIHZlYzIgdXZGcm9tRmxhdChpbnQgdGV4TnVtUiwgaW50IHRleE51bUMsIGludCBpbmRleCkge1xcbiAgICAgIGludCB0ZXhDID0gaW5kZXggLyB0ZXhOdW1SO1xcbiAgICAgIGludCB0ZXhSID0gaW5kZXggLSB0ZXhDICogdGV4TnVtUjtcXG4gICAgICAvLyBUT0RPOiBzd2FwIHRleFIsIHRleEMgb3JkZXIgaW4gZm9sbG93aW5nIGZ1bmN0aW9uIHNvIHJvdyBpcyBjb3JyZXNwb25kaW5nIHRvIHUgYW5kIGNvbHVtbiBpcyBjb3JyZXNwb25kaW5nIHRvXFxuICAgICAgLy8gICAgICAgdi5cXG4gICAgICByZXR1cm4gKHZlYzIodGV4UiwgdGV4QykgKyBoYWxmQ1IpIC8gdmVjMih0ZXhOdW1SLCB0ZXhOdW1DKTtcXG4gICAgfVxcbiAgICBcIiksZT1cInBhY2tlZFVWZnJvbTFEXCIsdFtlXT1uZXcgaS5HbHNsTGliUm91dGluZShcIlxcbiAgICAgIHZlYzIgcGFja2VkVVZmcm9tMUQoaW50IHRleE51bVIsIGludCB0ZXhOdW1DLCBpbnQgaW5kZXgpIHtcXG4gICAgICAgIGludCB0ZXhlbEluZGV4ID0gaW5kZXggLyAyO1xcbiAgICAgICAgaW50IHRleFIgPSB0ZXhlbEluZGV4IC8gdGV4TnVtQztcXG4gICAgICAgIGludCB0ZXhDID0gdGV4ZWxJbmRleCAtIHRleFIgKiB0ZXhOdW1DO1xcbiAgICAgICAgcmV0dXJuICh2ZWMyKHRleEMsIHRleFIpICsgaGFsZkNSKSAvIHZlYzIodGV4TnVtQywgdGV4TnVtUik7XFxuICAgICAgfVxcbiAgICAgIFwiKSxlPVwicGFja2VkVVZmcm9tMkRcIix0W2VdPW5ldyBpLkdsc2xMaWJSb3V0aW5lKFwiXFxuICAgICAgdmVjMiBwYWNrZWRVVmZyb20yRChpbnQgdGV4TnVtUiwgaW50IHRleE51bUMsIGludCB0ZXhlbHNJbkxvZ2ljYWxSb3csIGludCByb3csIGludCBjb2wpIHtcXG4gICAgICAgIGludCB0ZXhlbEluZGV4ID0gKHJvdyAvIDIpICogdGV4ZWxzSW5Mb2dpY2FsUm93ICsgKGNvbCAvIDIpO1xcbiAgICAgICAgaW50IHRleFIgPSB0ZXhlbEluZGV4IC8gdGV4TnVtQztcXG4gICAgICAgIGludCB0ZXhDID0gdGV4ZWxJbmRleCAtIHRleFIgKiB0ZXhOdW1DO1xcbiAgICAgICAgcmV0dXJuICh2ZWMyKHRleEMsIHRleFIpICsgaGFsZkNSKSAvIHZlYzIodGV4TnVtQywgdGV4TnVtUik7XFxuICAgICAgfVxcbiAgICAgIFwiKSxlPVwicGFja2VkVVZmcm9tM0RcIix0W2VdPW5ldyBpLkdsc2xMaWJSb3V0aW5lKFwiXFxuICAgICAgdmVjMiBwYWNrZWRVVmZyb20zRChpbnQgdGV4TnVtUiwgaW50IHRleE51bUMsXFxuICAgICAgICAgIGludCB0ZXhlbHNJbkJhdGNoLCBpbnQgdGV4ZWxzSW5Mb2dpY2FsUm93LCBpbnQgYixcXG4gICAgICAgICAgaW50IHJvdywgaW50IGNvbCkge1xcbiAgICAgICAgaW50IGluZGV4ID0gYiAqIHRleGVsc0luQmF0Y2ggKyAocm93IC8gMikgKiB0ZXhlbHNJbkxvZ2ljYWxSb3cgKyAoY29sIC8gMik7XFxuICAgICAgICBpbnQgdGV4UiA9IGluZGV4IC8gdGV4TnVtQztcXG4gICAgICAgIGludCB0ZXhDID0gaW5kZXggLSB0ZXhSICogdGV4TnVtQztcXG4gICAgICAgIHJldHVybiAodmVjMih0ZXhDLCB0ZXhSKSArIGhhbGZDUikgLyB2ZWMyKHRleE51bUMsIHRleE51bVIpO1xcbiAgICAgIH1cXG4gICAgICBcIiksZT1cInNhbXBsZVRleHR1cmVcIjtjb25zdCBuPSgwLG8uZ2V0R2xzbCkodGhpcy5jb250ZXh0LmdsQ29udGV4dC52ZXJzaW9uKTtyZXR1cm4gdFtlXT1uZXcgaS5HbHNsTGliUm91dGluZShgXFxuICAgICAgICBmbG9hdCBzYW1wbGVUZXh0dXJlKHNhbXBsZXIyRCB0ZXh0dXJlU2FtcGxlciwgdmVjMiB1dikge1xcbiAgICAgICAgICAgIHJldHVybiAke24udGV4dHVyZTJEfSh0ZXh0dXJlU2FtcGxlciwgdXYpLnI7XFxuICAgICAgICB9YCksdH1nZXRJbnB1dHNTYW1wbGluZ1NuaXBwZXRzKCl7Y29uc3QgdD17fSxlPXRoaXMuY29udGV4dC5vdXRwdXRUZXh0dXJlTGF5b3V0O3JldHVybiB0aGlzLmNvbnRleHQucHJvZ3JhbUluZm8uaW5wdXROYW1lcy5mb3JFYWNoKCgobixyKT0+e2NvbnN0IGk9dGhpcy5jb250ZXh0LmlucHV0VGV4dHVyZUxheW91dHNbcl0sbz0oMCxzLmdlbmVyYXRlU2hhZGVyRnVuY05hbWVGcm9tSW5wdXRTYW1wbGVyTmFtZSkobik7aS5pc1BhY2tlZD90W29dPXRoaXMuZ2V0UGFja2VkU2FtcGxlckZyb21JbnB1dChvLG4saSk6dFtvXT10aGlzLmdldFVucGFja2VkU2FtcGxlckZyb21JbnB1dChvLG4saSk7Y29uc3QgYT0oMCxzLmdlbmVyYXRlU2hhZGVyRnVuY05hbWVGcm9tSW5wdXRTYW1wbGVyTmFtZUF0T3V0Q29vcmRzKShuKTtpLnVucGFja2VkU2hhcGUubGVuZ3RoPD1lLnVucGFja2VkU2hhcGUubGVuZ3RoJiYoaS5pc1BhY2tlZD90W2FdPXRoaXMuZ2V0UGFja2VkU2FtcGxlckF0T3V0cHV0Q29vcmRzKGEsaSxlLG4pOnRbYV09dGhpcy5nZXRVbnBhY2tlZFNhbXBsZXJBdE91dHB1dENvb3JkcyhhLGksZSxuKSl9KSksdH1nZXRQYWNrZWRTYW1wbGVyQXRPdXRwdXRDb29yZHModCxlLG4sbyl7Y29uc3QgYT1lLnVucGFja2VkU2hhcGUsdT1uLnVucGFja2VkU2hhcGUsYz1vLGw9KDAscy5nZW5lcmF0ZVNoYWRlckZ1bmNOYW1lRnJvbUlucHV0U2FtcGxlck5hbWUpKGMpLHA9YS5sZW5ndGgsZj11Lmxlbmd0aCxkPXIuQnJvYWRjYXN0VXRpbC5nZXRCcm9hZGNhc3REaW1zKGEsdSksaD0oMCxzLmdldENvb3Jkc0RhdGFUeXBlKShmKSxnPWYtcDtsZXQgYjtjb25zdCBtPSgwLHMuZ2V0R2xDaGFubmVscykoKTtiPTA9PT1wP1wiXCI6ZjwyJiZkLmxlbmd0aD49MT9cImNvb3JkcyA9IDA7XCI6ZC5tYXAoKHQ9PmBjb29yZHMuJHttW3QrZ119ID0gMDtgKSkuam9pbihcIlxcblwiKTtsZXQgeT1cIlwiO3k9ZjwyJiZwPjA/XCJjb29yZHNcIjphLm1hcCgoKHQsZSk9PmBjb29yZHMuJHttW2UrZ119YCkpLmpvaW4oXCIsIFwiKTtsZXQgXz1cInJldHVybiBvdXRwdXRWYWx1ZTtcIjtjb25zdCB2PTE9PT1yLlNoYXBlVXRpbC5zaXplKGEpLHc9MT09PXIuU2hhcGVVdGlsLnNpemUodSk7aWYoMSE9PXB8fHZ8fHcpe2lmKHYmJiF3KV89MT09PWY/XCJcXG4gICAgICAgICAgcmV0dXJuIHZlYzQob3V0cHV0VmFsdWUueCwgb3V0cHV0VmFsdWUueCwgMC4sIDAuKTtcXG4gICAgICAgIFwiOlwiXFxuICAgICAgICAgIHJldHVybiB2ZWM0KG91dHB1dFZhbHVlLngpO1xcbiAgICAgICAgXCI7ZWxzZSBpZihkLmxlbmd0aCl7Y29uc3QgdD1wLTIsZT1wLTE7ZC5pbmRleE9mKHQpPi0xJiZkLmluZGV4T2YoZSk+LTE/Xz1cInJldHVybiB2ZWM0KG91dHB1dFZhbHVlLngpO1wiOmQuaW5kZXhPZih0KT4tMT9fPVwicmV0dXJuIHZlYzQob3V0cHV0VmFsdWUueCwgb3V0cHV0VmFsdWUueSwgb3V0cHV0VmFsdWUueCwgb3V0cHV0VmFsdWUueSk7XCI6ZC5pbmRleE9mKGUpPi0xJiYoXz1cInJldHVybiB2ZWM0KG91dHB1dFZhbHVlLnh4LCBvdXRwdXRWYWx1ZS56eik7XCIpfX1lbHNlIF89XCJcXG4gICAgICAgIHJldHVybiB2ZWM0KG91dHB1dFZhbHVlLnh5LCBvdXRwdXRWYWx1ZS54eSk7XFxuICAgICAgXCI7Y29uc3QgeD1gXFxuICAgICAgdmVjNCAke3R9KCkge1xcbiAgICAgICAgJHtofSBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIFxcbiAgICAgICAgaW50IGxhc3REaW0gPSBjb29yZHMuJHttW2YtMV19O1xcbiAgICAgICAgY29vcmRzLiR7bVtmLTFdfSA9IGNvb3Jkcy4ke21bZi0yXX07XFxuICAgICAgICBjb29yZHMuJHttW2YtMl19ID0gbGFzdERpbTtcXG4gICAgICBcXG4gICAgICAgICR7Yn1cXG4gICAgICAgIHZlYzQgb3V0cHV0VmFsdWUgPSAke2x9KCR7eX0pO1xcbiAgICAgICAgJHtffVxcbiAgICAgIH1cXG4gICAgYDtyZXR1cm4gbmV3IGkuR2xzbExpYlJvdXRpbmUoeCxbXCJjb29yZGluYXRlcy5nZXRPdXRwdXRDb29yZHNcIl0pfWdldFVucGFja2VkU2FtcGxlckF0T3V0cHV0Q29vcmRzKHQsZSxuLG8pe2NvbnN0IGE9W24ud2lkdGgsbi5oZWlnaHRdLHU9W2Uud2lkdGgsZS5oZWlnaHRdLGM9ZS51bnBhY2tlZFNoYXBlLmxlbmd0aCxsPW4udW5wYWNrZWRTaGFwZS5sZW5ndGgscD1lLnVucGFja2VkU2hhcGUsZj1uLnVucGFja2VkU2hhcGUsZD0oMCxzLmdlbmVyYXRlU2hhZGVyRnVuY05hbWVGcm9tSW5wdXRTYW1wbGVyTmFtZSkobyk7aWYoYz09PWwmJnIuQXJyYXlVdGlsLmFycmF5c0VxdWFsKHUsYSkpe2NvbnN0IGU9YFxcbiAgICAgICAgICBmbG9hdCAke3R9KCkge1xcbiAgICAgICAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKCR7b30sIFRleENvb3Jkcyk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIGA7cmV0dXJuIG5ldyBpLkdsc2xMaWJSb3V0aW5lKGUsW1wiY29vcmRpbmF0ZXMuc2FtcGxlVGV4dHVyZVwiXSl9Y29uc3QgaD0oMCxzLmdldENvb3Jkc0RhdGFUeXBlKShsKSxnPXIuQnJvYWRjYXN0VXRpbC5nZXRCcm9hZGNhc3REaW1zKHAsZiksYj1sLWM7bGV0IG07Y29uc3QgeT0oMCxzLmdldEdsQ2hhbm5lbHMpKCk7bT0wPT09Yz9cIlwiOmw8MiYmZy5sZW5ndGg+PTE/XCJjb29yZHMgPSAwO1wiOmcubWFwKCh0PT5gY29vcmRzLiR7eVt0K2JdfSA9IDA7YCkpLmpvaW4oXCJcXG5cIik7bGV0IF89XCJcIjtfPWw8MiYmYz4wP1wiY29vcmRzXCI6ZS51bnBhY2tlZFNoYXBlLm1hcCgoKHQsZSk9PmBjb29yZHMuJHt5W2UrYl19YCkpLmpvaW4oXCIsIFwiKTtjb25zdCB2PWBcXG4gICAgICAgIGZsb2F0ICR7dH0oKSB7XFxuICAgICAgICAgICR7aH0gY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICAgICR7bX1cXG4gICAgICAgICAgcmV0dXJuICR7ZH0oJHtffSk7XFxuICAgICAgICB9XFxuICAgICAgYDtyZXR1cm4gbmV3IGkuR2xzbExpYlJvdXRpbmUodixbXCJjb29yZGluYXRlcy5nZXRPdXRwdXRDb29yZHNcIl0pfWdldFBhY2tlZFNhbXBsZXJGcm9tSW5wdXQodCxlLG4pe3N3aXRjaChuLnVucGFja2VkU2hhcGUubGVuZ3RoKXtjYXNlIDA6cmV0dXJuIHRoaXMuZ2V0UGFja2VkU2FtcGxlclNjYWxhcih0LGUpO2Nhc2UgMTpyZXR1cm4gdGhpcy5nZXRQYWNrZWRTYW1wbGVyMUQodCxlLG4pO2Nhc2UgMjpyZXR1cm4gdGhpcy5nZXRQYWNrZWRTYW1wbGVyMkQodCxlLG4pO2Nhc2UgMzpyZXR1cm4gdGhpcy5nZXRQYWNrZWRTYW1wbGVyM0QodCxlLG4pO2RlZmF1bHQ6cmV0dXJuIHRoaXMuZ2V0UGFja2VkU2FtcGxlck5EKHQsZSxuKX19Z2V0VW5wYWNrZWRTYW1wbGVyRnJvbUlucHV0KHQsZSxuKXtjb25zdCByPW4udW5wYWNrZWRTaGFwZTtzd2l0Y2goci5sZW5ndGgpe2Nhc2UgMDpyZXR1cm4gdGhpcy5nZXRVbnBhY2tlZFNhbXBsZXJTY2FsYXIodCxlLG4pO2Nhc2UgMTpyZXR1cm4gdGhpcy5nZXRVbnBhY2tlZFNhbXBsZXIxRCh0LGUsbik7Y2FzZSAyOnJldHVybiB0aGlzLmdldFVucGFja2VkU2FtcGxlcjJEKHQsZSxuKTtjYXNlIDM6cmV0dXJuIHRoaXMuZ2V0VW5wYWNrZWRTYW1wbGVyM0QodCxlLG4pO2Nhc2UgNDpyZXR1cm4gdGhpcy5nZXRVbnBhY2tlZFNhbXBsZXI0RCh0LGUsbik7Y2FzZSA1OnJldHVybiB0aGlzLmdldFVucGFja2VkU2FtcGxlcjVEKHQsZSxuKTtjYXNlIDY6cmV0dXJuIHRoaXMuZ2V0VW5wYWNrZWRTYW1wbGVyNkQodCxlLG4pO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBkaW1lbnNpb24gJHtyLmxlbmd0aH0tRGApfX1nZXRQYWNrZWRTYW1wbGVyU2NhbGFyKHQsZSl7Y29uc3Qgbj1gXFxuICAgICAgICAgIHZlYzQgJHt0fSgpIHtcXG4gICAgICAgICAgICByZXR1cm4gJHsoMCxvLmdldEdsc2wpKHRoaXMuY29udGV4dC5nbENvbnRleHQudmVyc2lvbikudGV4dHVyZTJEfSgke2V9LCBoYWxmQ1IpO1xcbiAgICAgICAgICB9XFxuICAgICAgICBgO3JldHVybiBuZXcgaS5HbHNsTGliUm91dGluZShuKX1nZXRQYWNrZWRTYW1wbGVyMUQodCxlLG4pe2NvbnN0IHI9W24ud2lkdGgsbi5oZWlnaHRdLGE9W3JbMV0sclswXV0scz0oMCxvLmdldEdsc2wpKHRoaXMuY29udGV4dC5nbENvbnRleHQudmVyc2lvbiksdT1gdmVjNCAke3R9KGludCBpbmRleCkge1xcbiAgICAgIHZlYzIgdXYgPSBwYWNrZWRVVmZyb20xRChcXG4gICAgICAke2FbMF19LCAke2FbMV19LCBpbmRleCk7XFxuICAgICAgcmV0dXJuICR7cy50ZXh0dXJlMkR9KCR7ZX0sIHV2KTtcXG4gICAgfWA7cmV0dXJuIG5ldyBpLkdsc2xMaWJSb3V0aW5lKHUsW1wiY29vcmRpbmF0ZXMucGFja2VkVVZmcm9tMURcIl0pfWdldFBhY2tlZFNhbXBsZXIyRCh0LGUsbil7Y29uc3QgYT1uLnVucGFja2VkU2hhcGUscz1bbi53aWR0aCxuLmhlaWdodF0sdT0oMCxvLmdldEdsc2wpKHRoaXMuY29udGV4dC5nbENvbnRleHQudmVyc2lvbiksYz1zWzBdLGw9c1sxXTtpZihudWxsIT1zJiZyLkFycmF5VXRpbC5hcnJheXNFcXVhbChhLHMpKXtjb25zdCBuPWB2ZWM0ICR7dH0oaW50IHJvdywgaW50IGNvbCkge1xcbiAgICAgICAgdmVjMiB1diA9ICh2ZWMyKGNvbCwgcm93KSArIGhhbGZDUikgLyB2ZWMyKCR7bH0uMCwgJHtjfS4wKTtcXG4gICAgICAgIHJldHVybiAke3UudGV4dHVyZTJEfSgke2V9LCB1dik7XFxuICAgICAgfWA7cmV0dXJuIG5ldyBpLkdsc2xMaWJSb3V0aW5lKG4pfWNvbnN0IHA9cyxmPU1hdGguY2VpbChhWzFdLzIpLGQ9YHZlYzQgJHt0fShpbnQgcm93LCBpbnQgY29sKSB7XFxuICAgICAgdmVjMiB1diA9IHBhY2tlZFVWZnJvbTJEKCR7cFsxXX0sICR7cFswXX0sICR7Zn0sIHJvdywgY29sKTtcXG4gICAgICByZXR1cm4gJHt1LnRleHR1cmUyRH0oJHtlfSwgdXYpO1xcbiAgICB9YDtyZXR1cm4gbmV3IGkuR2xzbExpYlJvdXRpbmUoZCxbXCJjb29yZGluYXRlcy5wYWNrZWRVVmZyb20yRFwiXSl9Z2V0UGFja2VkU2FtcGxlcjNEKHQsZSxuKXtjb25zdCByPW4udW5wYWNrZWRTaGFwZSxhPVtuLndpZHRoLG4uaGVpZ2h0XSx1PVthWzBdLGFbMV1dLGM9KDAsby5nZXRHbHNsKSh0aGlzLmNvbnRleHQuZ2xDb250ZXh0LnZlcnNpb24pO2lmKDE9PT1yWzBdKXtjb25zdCBvPXIuc2xpY2UoMSksYT1bMSwyXSx1PSgwLHMuc3F1ZWV6ZUlucHV0U2hhcGUpKHIsbyksYz1bXCJiXCIsXCJyb3dcIixcImNvbFwiXSxsPUpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkobikpO2wudW5wYWNrZWRTaGFwZT11O2NvbnN0IHA9dGhpcy5nZXRQYWNrZWRTYW1wbGVyRnJvbUlucHV0KHQsZSxsKSxmPWAke3Aucm91dGluZUJvZHl9XFxuICAgICAgdmVjNCAke3R9KGludCBiLCBpbnQgcm93LCBpbnQgY29sKSB7XFxuICAgICAgICByZXR1cm4gJHt0fSgkeygwLHMuZ2V0U3F1ZWV6ZWRQYXJhbXMpKGMsYSl9KTtcXG4gICAgICB9IGA7cmV0dXJuIG5ldyBpLkdsc2xMaWJSb3V0aW5lKGYscC5kZXBlbmRlbmNpZXMpfWNvbnN0IGw9dVswXSxwPXVbMV0sZj1NYXRoLmNlaWwoclsyXS8yKSxkPWB2ZWM0ICR7dH0oaW50IGIsIGludCByb3csIGludCBjb2wpIHtcXG4gICAgICB2ZWMyIHV2ID0gcGFja2VkVVZmcm9tM0QoXFxuICAgICAgICAke3B9LCAke2x9LCAke2YqTWF0aC5jZWlsKHJbMV0vMil9LCAke2Z9LCBiLCByb3csIGNvbCk7XFxuICAgICAgcmV0dXJuICR7Yy50ZXh0dXJlMkR9KCR7ZX0sIHV2KTt9YDtyZXR1cm4gbmV3IGkuR2xzbExpYlJvdXRpbmUoZCxbXCJjb29yZGluYXRlcy5wYWNrZWRVVmZyb20zRFwiXSl9Z2V0UGFja2VkU2FtcGxlck5EKHQsZSxuKXtjb25zdCByPW4udW5wYWNrZWRTaGFwZSxhPXIubGVuZ3RoLHM9W24ud2lkdGgsbi5oZWlnaHRdLHU9KDAsby5nZXRHbHNsKSh0aGlzLmNvbnRleHQuZ2xDb250ZXh0LnZlcnNpb24pLGM9W3NbMF0sc1sxXV0sbD1jWzFdLHA9Y1swXSxmPU1hdGguY2VpbChyW2EtMV0vMik7bGV0IGQ9ZipNYXRoLmNlaWwoclthLTJdLzIpLGg9XCJpbnQgYiwgaW50IHJvdywgaW50IGNvbFwiLGc9YGIgKiAke2R9ICsgKHJvdyAvIDIpICogJHtmfSArIChjb2wgLyAyKWA7Zm9yKGxldCB0PTI7dDxhLTE7dCsrKWg9YGludCBiJHt0fSwgYCtoLGQqPXJbYS10LTFdLGc9YGIke3R9ICogJHtkfSArIGArZztjb25zdCBiPWB2ZWM0ICR7dH0oJHtofSkge1xcbiAgICAgIGludCBpbmRleCA9ICR7Z307XFxuICAgICAgaW50IHRleFIgPSBpbmRleCAvICR7cH07XFxuICAgICAgaW50IHRleEMgPSBpbmRleCAtIHRleFIgKiAke3B9O1xcbiAgICAgIHZlYzIgdXYgPSAodmVjMih0ZXhDLCB0ZXhSKSArIGhhbGZDUikgLyB2ZWMyKCR7cH0sICR7bH0pO1xcbiAgICAgIHJldHVybiAke3UudGV4dHVyZTJEfSgke2V9LCB1dik7XFxuICAgIH1gO3JldHVybiBuZXcgaS5HbHNsTGliUm91dGluZShiKX1nZXRVbnBhY2tlZFNhbXBsZXJTY2FsYXIodCxlLG4pe2NvbnN0W3Isb109W24ud2lkdGgsbi5oZWlnaHRdO2lmKDE9PT1yJiYxPT09byl7Y29uc3Qgbj1gXFxuICAgICAgICAgIGZsb2F0ICR7dH0oKSB7XFxuICAgICAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoJHtlfSwgaGFsZkNSKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgYDtyZXR1cm4gbmV3IGkuR2xzbExpYlJvdXRpbmUobixbXCJjb29yZGluYXRlcy5zYW1wbGVUZXh0dXJlXCJdKX1jb25zdCBhPWBcXG4gICAgICAgIGZsb2F0ICR7dH0oKSB7XFxuICAgICAgICAgIGludCBvZmZzZXRfJHtlfSA9IGNvb3Jkc1RvT2Zmc2V0KFRleENvb3JkcywgJHtyfSwgJHtvfSk7XFxuICAgICAgICAgIHZlYzIgdXYgPSB1dkZyb21GbGF0KCR7cn0sICR7b30sIG9mZnNldF8ke2V9KTtcXG4gICAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoJHtlfSwgdXYpO1xcbiAgICAgICAgfVxcbiAgICAgIGA7cmV0dXJuIG5ldyBpLkdsc2xMaWJSb3V0aW5lKGEsW1wiY29vcmRpbmF0ZXMudXZGcm9tRmxhdFwiLFwiY29vcmRpbmF0ZXMuc2FtcGxlVGV4dHVyZVwiLFwiY29vcmRpbmF0ZXMuY29vcmRzVG9PZmZzZXRcIl0pfWdldFVucGFja2VkU2FtcGxlcjFEKHQsZSxuKXtjb25zdCByPW4ud2lkdGgsbz1uLmhlaWdodDtpZigxPT09byYmMT09PXIpe2NvbnN0IG49YFxcbiAgICAgICAgZmxvYXQgJHt0fShpbnQgaW5kZXgpIHtcXG4gICAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoJHtlfSwgaGFsZkNSKTtcXG4gICAgICAgIH1cXG4gICAgICBgO3JldHVybiBuZXcgaS5HbHNsTGliUm91dGluZShuLFtcImNvb3JkaW5hdGVzLnNhbXBsZVRleHR1cmVcIl0pfWlmKDE9PT1vKXtjb25zdCBuPWBcXG4gICAgICAgICAgZmxvYXQgJHt0fShpbnQgaW5kZXgpIHtcXG4gICAgICAgICAgICB2ZWMyIHV2ID0gdmVjMigoZmxvYXQoaW5kZXgpICsgMC41KSAvICR7cn0uMCwgMC41KTtcXG4gICAgICAgICAgICByZXR1cm4gc2FtcGxlVGV4dHVyZSgke2V9LCB1dik7XFxuICAgICAgICAgIH1cXG4gICAgICAgIGA7cmV0dXJuIG5ldyBpLkdsc2xMaWJSb3V0aW5lKG4sW1wiY29vcmRpbmF0ZXMuc2FtcGxlVGV4dHVyZVwiXSl9aWYoMT09PXIpe2NvbnN0IG49YFxcbiAgICAgICAgICBmbG9hdCAke3R9KGludCBpbmRleCkge1xcbiAgICAgICAgICAgIHZlYzIgdXYgPSB2ZWMyKDAuNSwgKGZsb2F0KGluZGV4KSArIDAuNSkgLyAke299LjApO1xcbiAgICAgICAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKCR7ZX0sIHV2KTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgYDtyZXR1cm4gbmV3IGkuR2xzbExpYlJvdXRpbmUobixbXCJjb29yZGluYXRlcy5zYW1wbGVUZXh0dXJlXCJdKX1jb25zdCBhPWBcXG4gICAgICAgIGZsb2F0ICR7dH0oaW50IGluZGV4KSB7XFxuICAgICAgICAgIHZlYzIgdXYgPSB1dkZyb21GbGF0KCR7cn0sICR7b30sIGluZGV4KTtcXG4gICAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoJHtlfSwgdXYpO1xcbiAgICAgICAgfVxcbiAgICAgIGA7cmV0dXJuIG5ldyBpLkdsc2xMaWJSb3V0aW5lKGEsW1wiY29vcmRpbmF0ZXMudXZGcm9tRmxhdFwiLFwiY29vcmRpbmF0ZXMuc2FtcGxlVGV4dHVyZVwiXSl9Z2V0VW5wYWNrZWRTYW1wbGVyMkQodCxlLG4pe2NvbnN0IG89bi51bnBhY2tlZFNoYXBlLHU9W24uaGVpZ2h0LG4ud2lkdGhdO2lmKG51bGwhPXUmJnIuQXJyYXlVdGlsLmFycmF5c0VxdWFsKG8sdSkpe2NvbnN0IG49YFxcbiAgICAgICAgICBmbG9hdCAke3R9KGludCByb3csIGludCBjb2wpIHtcXG4gICAgICAgICAgICB2ZWMyIHV2ID0gKHZlYzIocm93LCBjb2wpICsgaGFsZkNSKSAvIHZlYzIoJHt1WzFdfS4wLCAke3VbMF19LjApO1xcbiAgICAgICAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKCR7ZX0sIHV2KTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgYDtyZXR1cm4gbmV3IGkuR2xzbExpYlJvdXRpbmUobixbXCJjb29yZGluYXRlcy5zYW1wbGVUZXh0dXJlXCJdKX1jb25zdHtuZXdTaGFwZTpjLGtlcHREaW1zOmx9PSgwLGEuc3F1ZWV6ZVNoYXBlKShvKSxwPWM7aWYocC5sZW5ndGg8by5sZW5ndGgpe2NvbnN0IHI9KDAscy5zcXVlZXplSW5wdXRTaGFwZSkobyxwKSxhPUpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkobikpO2EudW5wYWNrZWRTaGFwZT1yO2NvbnN0IHU9W1wiY29sXCIsXCJyb3dcIl0sYz1gXFxuICAgICAgICAgICR7dGhpcy5nZXRVbnBhY2tlZFNhbXBsZXJGcm9tSW5wdXQodCxlLGEpLnJvdXRpbmVCb2R5fVxcbiAgICAgICAgICBmbG9hdCAke3R9KGludCByb3csIGludCBjb2wpIHtcXG4gICAgICAgICAgICByZXR1cm4gJHt0fSgkeygwLHMuZ2V0U3F1ZWV6ZWRQYXJhbXMpKHUsbCl9KTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgYDtyZXR1cm4gbmV3IGkuR2xzbExpYlJvdXRpbmUoYyxbXCJjb29yZGluYXRlcy5zYW1wbGVUZXh0dXJlXCJdKX1jb25zdCBmPXVbMV0sZD11WzBdO2lmKDE9PT1kKXtjb25zdCBuPWBcXG4gICAgICAgICAgZmxvYXQgJHt0fShpbnQgcm93LCBpbnQgY29sKSB7XFxuICAgICAgICAgICAgaW50IG9mZnNldF8ke2V9ID0gY29vcmRzVG9PZmZzZXQoVGV4Q29vcmRzLCAke2Z9LCAke2R9KTtcXG4gICAgICAgICAgICBmbG9hdCBpbmRleCA9IGRvdCh2ZWMzKHJvdywgY29sLCBvZmZzZXRfJHtlfSksIHZlYzMoJHtvWzFdfSwgMSwgMSkpO1xcbiAgICAgICAgICAgIHZlYzIgdXYgPSB2ZWMyKDAuNSwgKGluZGV4ICsgMC41KSAvICR7Zn0uMCk7XFxuICAgICAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoJHtlfSwgdXYpO1xcbiAgICAgICAgICB9XFxuICAgICAgICBgO3JldHVybiBuZXcgaS5HbHNsTGliUm91dGluZShuLFtcImNvb3JkaW5hdGVzLnNhbXBsZVRleHR1cmVcIixcImNvb3JkaW5hdGVzLmNvb3Jkc1RvT2Zmc2V0XCJdKX1pZigxPT09Zil7Y29uc3Qgbj1gXFxuICAgICAgICAgIGZsb2F0ICR7dH0oaW50IHJvdywgaW50IGNvbCkge1xcbiAgICAgICAgICAgIGludCBvZmZzZXRfJHtlfSA9IGNvb3Jkc1RvT2Zmc2V0KFRleENvb3JkcywgJHtmfSwgJHtkfSk7XFxuICAgICAgICAgICAgZmxvYXQgaW5kZXggPSBkb3QodmVjMyhyb3csIGNvbCwgb2Zmc2V0XyR7ZX0pLCB2ZWMzKCR7b1sxXX0sIDEsIDEpKTtcXG4gICAgICAgICAgICB2ZWMyIHV2ID0gdmVjMigoaW5kZXggKyAwLjUpIC8gJHtkfS4wLCAwLjUpO1xcbiAgICAgICAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKCR7ZX0sIHV2KTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgYDtyZXR1cm4gbmV3IGkuR2xzbExpYlJvdXRpbmUobixbXCJjb29yZGluYXRlcy5zYW1wbGVUZXh0dXJlXCIsXCJjb29yZGluYXRlcy5jb29yZHNUb09mZnNldFwiXSl9Y29uc3QgaD1gXFxuICAgICAgICBmbG9hdCAke3R9KGludCByb3csIGludCBjb2wpIHtcXG4gICAgICAgICAgaW50IGluZGV4ID0gY29sICogJHtvWzFdfSArIHJvdztcXG4gICAgICAgICAgdmVjMiB1diA9IHV2RnJvbUZsYXQoJHtmfSwgJHtkfSwgaW5kZXgpO1xcbiAgICAgICAgICByZXR1cm4gc2FtcGxlVGV4dHVyZSgke2V9LCB1dik7XFxuICAgICAgICB9XFxuICAgICAgYDtyZXR1cm4gbmV3IGkuR2xzbExpYlJvdXRpbmUoaCxbXCJjb29yZGluYXRlcy51dkZyb21GbGF0XCIsXCJjb29yZGluYXRlcy5zYW1wbGVUZXh0dXJlXCIsXCJjb29yZGluYXRlcy5jb29yZHNUb09mZnNldFwiXSl9Z2V0VW5wYWNrZWRTYW1wbGVyM0QodCxlLG4pe2NvbnN0IHI9bi51bnBhY2tlZFNoYXBlLG89clsxXSpyWzJdLHU9clsyXSx7bmV3U2hhcGU6YyxrZXB0RGltczpsfT0oMCxhLnNxdWVlemVTaGFwZSkocikscD1jO2lmKHAubGVuZ3RoPHIubGVuZ3RoKXtjb25zdCBvPSgwLHMuc3F1ZWV6ZUlucHV0U2hhcGUpKHIscCksYT1bXCJiYXRjaFwiLFwiY29sXCIsXCJyb3dcIl0sdT1KU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG4pKTt1LnVucGFja2VkU2hhcGU9bztjb25zdCBjPXRoaXMuZ2V0VW5wYWNrZWRTYW1wbGVyRnJvbUlucHV0KHQsZSx1KSxmPWwucmV2ZXJzZSgpLGQ9YFxcbiAgICAgICAgICAke2Mucm91dGluZUJvZHl9XFxuICAgICAgICAgIGZsb2F0ICR7dH0oaW50IGJhdGNoLCBpbnQgcm93LCBpbnQgY29sKSB7XFxuICAgICAgICAgICAgcmV0dXJuICR7dH0oJHsoMCxzLmdldFNxdWVlemVkUGFyYW1zKShhLGYpfSk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIGA7cmV0dXJuIG5ldyBpLkdsc2xMaWJSb3V0aW5lKGQsYy5kZXBlbmRlbmNpZXMpfWNvbnN0IGY9YFxcbiAgICAgICAgICBmbG9hdCAke3R9KGludCBkZXB0aCwgaW50IHJvdywgaW50IGNvbCkge1xcbiAgICAgICAgICAgIC8vIEV4cGxpY2l0bHkgdXNlIGludGVnZXIgb3BlcmF0aW9ucyBhcyBkb3QoKSBvbmx5IHdvcmtzIG9uIGZsb2F0cy5cXG4gICAgICAgICAgICBpbnQgaW5kZXggPSBkZXB0aCAqICR7b30gKyBjb2wgKiAke3V9ICsgcm93O1xcbiAgICAgICAgICAgIHZlYzIgdXYgPSB1dkZyb21GbGF0KCR7bi53aWR0aH0sICR7bi5oZWlnaHR9LCBpbmRleCk7XFxuICAgICAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoJHtlfSwgdXYpO1xcbiAgICAgICAgICB9XFxuICAgICAgYDtyZXR1cm4gbmV3IGkuR2xzbExpYlJvdXRpbmUoZixbXCJjb29yZGluYXRlcy51dkZyb21GbGF0XCIsXCJjb29yZGluYXRlcy5zYW1wbGVUZXh0dXJlXCIsXCJjb29yZGluYXRlcy5jb29yZHNUb09mZnNldFwiXSl9Z2V0VW5wYWNrZWRTYW1wbGVyNEQodCxlLG4pe2NvbnN0IHI9bi51bnBhY2tlZFNoYXBlLG89clszXSxhPXJbMl0qbyxzPWBcXG4gICAgICAgIGZsb2F0ICR7dH0oaW50IHJvdywgaW50IGNvbCwgaW50IGRlcHRoLCBpbnQgZGVwdGgyKSB7XFxuICAgICAgICAgIGludCBpbmRleCA9IHJvdyAqICR7clsxXSphfSArIGNvbCAqICR7YX0gK1xcbiAgICAgICAgICAgICAgZGVwdGgyICogJHtvfSArIGRlcHRoO1xcbiAgICAgICAgICB2ZWMyIHV2ID0gdXZGcm9tRmxhdCgke24ud2lkdGh9LCAke24uaGVpZ2h0fSwgaW5kZXgpO1xcbiAgICAgICAgICByZXR1cm4gc2FtcGxlVGV4dHVyZSgke2V9LCB1dik7XFxuICAgICAgICB9XFxuICAgICAgYDtyZXR1cm4gbmV3IGkuR2xzbExpYlJvdXRpbmUocyxbXCJjb29yZGluYXRlcy51dkZyb21GbGF0XCIsXCJjb29yZGluYXRlcy5zYW1wbGVUZXh0dXJlXCJdKX1nZXRVbnBhY2tlZFNhbXBsZXI1RCh0LGUsbil7Y29uc3Qgcj1uLnVucGFja2VkU2hhcGUsbz1yWzRdLHU9clszXSpvLGM9clsyXSp1LGw9clsxXSpjLHtuZXdTaGFwZTpwLGtlcHREaW1zOmZ9PSgwLGEuc3F1ZWV6ZVNoYXBlKShyKTtpZihwLmxlbmd0aDxyLmxlbmd0aCl7Y29uc3Qgbz0oMCxzLnNxdWVlemVJbnB1dFNoYXBlKShyLHApLGE9W1wicm93XCIsXCJjb2xcIixcImRlcHRoXCIsXCJkZXB0aDJcIixcImRlcHRoM1wiXSx1PUpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkobikpO3UudW5wYWNrZWRTaGFwZT1vO2NvbnN0IGM9YFxcbiAgICAgICAgICAke3RoaXMuZ2V0VW5wYWNrZWRTYW1wbGVyRnJvbUlucHV0KHQsZSx1KS5yb3V0aW5lQm9keX1cXG4gICAgICAgICAgZmxvYXQgJHt0fShpbnQgcm93LCBpbnQgY29sLCBpbnQgZGVwdGgsIGludCBkZXB0aDIsIGludCBkZXB0aDMpIHtcXG4gICAgICAgICAgICByZXR1cm4gJHt0fSgkeygwLHMuZ2V0U3F1ZWV6ZWRQYXJhbXMpKGEsZil9KTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgYDtyZXR1cm4gbmV3IGkuR2xzbExpYlJvdXRpbmUoYyxbXCJjb29yZGluYXRlcy5zYW1wbGVUZXh0dXJlXCIsXCJjb29yZGluYXRlcy51dkZyb21GbGF0XCJdKX1jb25zdCBkPWBcXG4gICAgICAgIGZsb2F0ICR7dH0oaW50IHJvdywgaW50IGNvbCwgaW50IGRlcHRoLCBpbnQgZGVwdGgyLCBpbnQgZGVwdGgzKSB7XFxuICAgICAgICAgIGludCBpbmRleCA9IHJvdyAqICR7bH0gKyBjb2wgKiAke2N9ICsgZGVwdGggKiAke3V9ICtcXG4gICAgICAgICAgZGVwdGgzICogJHtvfSArIGRlcHRoMjtcXG4gICAgICAgICAgdmVjMiB1diA9IHV2RnJvbUZsYXQoJHtuLndpZHRofSwgJHtuLmhlaWdodH0sIGluZGV4KTtcXG4gICAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoJHtlfSwgdXYpO1xcbiAgICAgICAgfVxcbiAgICAgIGA7cmV0dXJuIG5ldyBpLkdsc2xMaWJSb3V0aW5lKGQsW1wiY29vcmRpbmF0ZXMuc2FtcGxlVGV4dHVyZVwiLFwiY29vcmRpbmF0ZXMudXZGcm9tRmxhdFwiXSl9Z2V0VW5wYWNrZWRTYW1wbGVyNkQodCxlLG4pe2NvbnN0IHI9bi51bnBhY2tlZFNoYXBlLG89cls1XSx1PXJbNF0qbyxjPXJbM10qdSxsPXJbMl0qYyxwPXJbMV0qbCx7bmV3U2hhcGU6ZixrZXB0RGltczpkfT0oMCxhLnNxdWVlemVTaGFwZSkocik7aWYoZi5sZW5ndGg8ci5sZW5ndGgpe2NvbnN0IG89KDAscy5zcXVlZXplSW5wdXRTaGFwZSkocixmKSxhPVtcInJvd1wiLFwiY29sXCIsXCJkZXB0aFwiLFwiZGVwdGgyXCIsXCJkZXB0aDNcIixcImRlcHRoNFwiXSx1PUpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkobikpO3UudW5wYWNrZWRTaGFwZT1vO2NvbnN0IGM9YFxcbiAgICAgICAgICAgICR7dGhpcy5nZXRVbnBhY2tlZFNhbXBsZXJGcm9tSW5wdXQodCxlLHUpLnJvdXRpbmVCb2R5fVxcbiAgICAgICAgICAgIGZsb2F0ICR7dH0oaW50IHJvdywgaW50IGNvbCwgaW50IGRlcHRoLFxcbiAgICAgICAgICAgICAgaW50IGRlcHRoMiwgaW50IGRlcHRoMywgaW50IGRlcHRoNCkge1xcbiAgICAgICAgICAgICAgcmV0dXJuICR7dH0oJHsoMCxzLmdldFNxdWVlemVkUGFyYW1zKShhLGQpfSk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICBgO3JldHVybiBuZXcgaS5HbHNsTGliUm91dGluZShjLFtcImNvb3JkaW5hdGVzLnNhbXBsZVRleHR1cmVcIixcImNvb3JkaW5hdGVzLnV2RnJvbUZsYXRcIl0pfWNvbnN0IGg9YFxcbiAgICAgICAgICBmbG9hdCAke3R9KGludCByb3csIGludCBjb2wsIGludCBkZXB0aCxcXG4gICAgICAgICAgICBpbnQgZGVwdGgyLCBpbnQgZGVwdGgzLCBpbnQgZGVwdGg0KSB7XFxuICAgICAgICAgICAgaW50IGluZGV4ID0gcm93ICogJHtwfSArIGNvbCAqICR7bH0gKyBkZXB0aCAqICR7Y30gK1xcbiAgICAgICAgICAgIGRlcHRoMiAqICR7dX0gKyBkZXB0aDMgKiAke299ICsgZGVwdGg0O1xcbiAgICAgICAgICAgIHZlYzIgdXYgPSB1dkZyb21GbGF0KCR7bi53aWR0aH0sICR7bi5oZWlnaHR9LCBpbmRleCk7XFxuICAgICAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoJHtlfSwgdXYpO1xcbiAgICAgICAgICB9XFxuICAgICAgICBgO3JldHVybiBuZXcgaS5HbHNsTGliUm91dGluZShoLFtcImNvb3JkaW5hdGVzLnV2RnJvbUZsYXRcIixcImNvb3JkaW5hdGVzLnNhbXBsZVRleHR1cmVcIixcImNvb3JkaW5hdGVzLmNvb3Jkc1RvT2Zmc2V0XCJdKX10b1ZlYygpe2NvbnN0IHQ9dGhpcy5jb250ZXh0Lm91dHB1dFRleHR1cmVMYXlvdXQsZT10LnNoYXBlLmxlbmd0aCxuPXQuc3RyaWRlcyxyPXQud2lkdGgsbz10LmhlaWdodCxhPVtdO2ZvcihsZXQgdD0wO3Q8ZS0xOysrdClhLnB1c2goYFxcbiAgICAgICAgY1ske3R9XSA9IG9mZnNldCAvICR7blt0XX07YCksYS5wdXNoKGBcXG4gICAgICAgIG9mZnNldCAtPSBjWyR7dH1dICogJHtuW3RdfTtgKTthLnB1c2goYFxcbiAgICAgICAgY1ske2UtMX1dID0gb2Zmc2V0O2ApO2NvbnN0IHM9YFxcbiAgICAgIHZvaWQgdG9WZWModmVjMiB0ZXhDb29yZHMsIG91dCBpbnQgY1ske2V9XSkge1xcbiAgICAgICAgaW50IG9mZnNldCA9IGNvb3Jkc1RvT2Zmc2V0KHRleENvb3JkcywgJHtyfSwgJHtvfSk7XFxuICAgICAgICAke2Euam9pbihcIlwiKX1cXG4gICAgICB9XFxuICAgICAgdm9pZCB0b1ZlYyhpbnQgb2Zmc2V0LCBvdXQgaW50IGNbJHtlfV0pIHtcXG4gICAgICAgICR7YS5qb2luKFwiXCIpfVxcbiAgICAgIH1cXG4gICAgYDtyZXR1cm57dG9WZWM6bmV3IGkuR2xzbExpYlJvdXRpbmUocyxbXCJjb29yZGluYXRlcy5jb29yZHNUb09mZnNldFwiXSl9fXZhbHVlRnJvbSgpe2NvbnN0IHQ9e307cmV0dXJuIHRoaXMuY29udGV4dC5wcm9ncmFtSW5mby5pbnB1dE5hbWVzLmZvckVhY2goKChlLG4pPT57Y29uc3Qgcj10aGlzLmNvbnRleHQuaW5wdXRUZXh0dXJlTGF5b3V0c1tuXSxvPShyLnVucGFja2VkU2hhcGUubGVuZ3RoPjA/ci51bnBhY2tlZFNoYXBlOnIuc2hhcGUpLmxlbmd0aDtsZXQgYT1gXyR7ZX1gO3RbYV09bmV3IGkuR2xzbExpYlJvdXRpbmUodGhpcy5nZXRWYWx1ZUZyb21TaW5nbGUoZSxvLHIud2lkdGgsci5oZWlnaHQsITEpLFtgc2hhcGVVdGlscy5pbmRpY2VzVG9PZmZzZXQke2F9YCxcImNvb3JkaW5hdGVzLm9mZnNldFRvQ29vcmRzXCIsXCJmcmFnY29sb3IuZ2V0Q29sb3JBc0Zsb2F0XCJdKSxhKz1cIl9UXCIsdFthXT1uZXcgaS5HbHNsTGliUm91dGluZSh0aGlzLmdldFZhbHVlRnJvbVNpbmdsZShlLG8sci53aWR0aCxyLmhlaWdodCwhMCksW2BzaGFwZVV0aWxzLmluZGljZXNUb09mZnNldCR7YX1gLFwiY29vcmRpbmF0ZXMub2Zmc2V0VG9Db29yZHNcIixcImZyYWdjb2xvci5nZXRDb2xvckFzRmxvYXRcIl0pfSkpLHR9Z2V0VmFsdWVGcm9tU2luZ2xlKHQsZSxuLHIsaSl7bGV0IGE9YF8ke3R9YDtyZXR1cm4gaSYmKGErPVwiX1RcIiksYFxcbiAgICAgICAgZmxvYXQgJHthfShpbnQgbVske2V9XSkge1xcbiAgICAgICAgICBpbnQgb2Zmc2V0ID0gaW5kaWNlc1RvT2Zmc2V0JHthfShtKTtcXG4gICAgICAgICAgdmVjMiBjb29yZHMgPSBvZmZzZXRUb0Nvb3JkcyhvZmZzZXQsICR7bn0sICR7cn0pO1xcbiAgICAgICAgICBmbG9hdCB2YWx1ZSA9IGdldENvbG9yQXNGbG9hdCgkeygwLG8uZ2V0R2xzbCkodGhpcy5jb250ZXh0LmdsQ29udGV4dC52ZXJzaW9uKS50ZXh0dXJlMkR9KCR7dH0sIGNvb3JkcykpO1xcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XFxuICAgICAgICB9XFxuICAgICAgICBgfWdldFBhY2tlZFZhbHVlRnJvbSh0LGUsbixyLGkpe2xldCBhPWBfJHt0fV9QYWNrYDtyZXR1cm4gaSYmKGErPVwiX1RcIiksYFxcbiAgICAgICAgdmVjNCAke2F9KGludCBtWyR7ZX1dKSB7XFxuICAgICAgICAgIGludCBvZmZzZXQgPSBpbmRpY2VzVG9PZmZzZXRfJHt0fShtKTtcXG4gICAgICAgICAgdmVjMiBjb29yZHMgPSBvZmZzZXRUb0Nvb3JkcyhvZmZzZXQsICR7bn0sICR7cn0pO1xcbiAgICAgICAgICByZXR1cm4gJHsoMCxvLmdldEdsc2wpKHRoaXMuY29udGV4dC5nbENvbnRleHQudmVyc2lvbikudGV4dHVyZTJEfSgke3R9LCBjb29yZHMpO1xcbiAgICAgICAgfVxcbiAgICAgICAgYH19ZS5Db29yZHNHbHNsTGliPXV9LDg1MjA6KHQsZSk9PntcInVzZSBzdHJpY3RcIjt2YXIgbjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLlRvcG9sb2dpY2FsU29ydEdsc2xSb3V0aW5lcz1lLkdsc2xMaWJSb3V0aW5lTm9kZT1lLkdsc2xMaWJSb3V0aW5lPWUuR2xzbExpYj1lLkdsc2xDb250ZXh0PWUuRnVuY3Rpb25UeXBlPXZvaWQgMCwobj1lLkZ1bmN0aW9uVHlwZXx8KGUuRnVuY3Rpb25UeXBlPXt9KSlbbi5WYWx1ZUJhc2VkPTBdPVwiVmFsdWVCYXNlZFwiLG5bbi5Qb3NpdGlvbmFsPTFdPVwiUG9zaXRpb25hbFwiLGUuR2xzbENvbnRleHQ9Y2xhc3N7Y29uc3RydWN0b3IodCxlLG4scil7dGhpcy5nbENvbnRleHQ9dCx0aGlzLnByb2dyYW1JbmZvPWUsdGhpcy5pbnB1dFRleHR1cmVMYXlvdXRzPW4sdGhpcy5vdXRwdXRUZXh0dXJlTGF5b3V0PXJ9fSxlLkdsc2xMaWI9Y2xhc3N7Y29uc3RydWN0b3IodCl7dGhpcy5jb250ZXh0PXR9fSxlLkdsc2xMaWJSb3V0aW5lPWNsYXNze2NvbnN0cnVjdG9yKHQsZSl7dGhpcy5yb3V0aW5lQm9keT10LHRoaXMuZGVwZW5kZW5jaWVzPWV9fSxlLkdsc2xMaWJSb3V0aW5lTm9kZT1jbGFzc3tjb25zdHJ1Y3Rvcih0LGUsbil7dGhpcy5uYW1lPXQsdGhpcy5kZXBlbmRlbmNpZXM9bnx8W10sZSYmKHRoaXMucm91dGluZUJvZHk9ZSl9YWRkRGVwZW5kZW5jeSh0KXt0JiZ0aGlzLmRlcGVuZGVuY2llcy5wdXNoKHQpfX0sZS5Ub3BvbG9naWNhbFNvcnRHbHNsUm91dGluZXM9Y2xhc3N7c3RhdGljIHJldHVybk9yZGVyZWROb2Rlcyh0KXtpZighdHx8MD09PXQubGVuZ3RoKXJldHVybltdO2lmKDE9PT10Lmxlbmd0aClyZXR1cm4gdDtjb25zdCBlPW5ldyBTZXQsbj1uZXcgU2V0LHI9bmV3IEFycmF5O3JldHVybiB0aGlzLmNyZWF0ZU9yZGVyZWROb2Rlcyh0LGUsbixyKSxyfXN0YXRpYyBjcmVhdGVPcmRlcmVkTm9kZXModCxlLG4scil7Zm9yKGxldCBpPTA7aTx0Lmxlbmd0aDsrK2kpdGhpcy5kZnNUcmF2ZXJzZSh0W2ldLGUsbixyKX1zdGF0aWMgZGZzVHJhdmVyc2UodCxlLG4scil7aWYoIXR8fG4uaGFzKHQubmFtZSkpcmV0dXJuO2lmKGUuaGFzKHQubmFtZSkpdGhyb3cgbmV3IEVycm9yKFwiQ3ljbGljIGRlcGVuZGVuY3kgZGV0ZWN0ZWQuIENhbid0IHRvcG9sb2dpY2FsbHkgc29ydCByb3V0aW5lcyBuZWVkZWQgZm9yIHNoYWRlci5cIik7ZS5hZGQodC5uYW1lKTtjb25zdCBpPXQuZGVwZW5kZW5jaWVzO2lmKGkmJmkubGVuZ3RoPjApZm9yKGxldCB0PTA7dDxpLmxlbmd0aDsrK3QpdGhpcy5kZnNUcmF2ZXJzZShpW3RdLGUsbixyKTtyLnB1c2godCksbi5hZGQodC5uYW1lKSxlLmRlbGV0ZSh0Lm5hbWUpfX19LDczNDE6KHQsZSxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUuRW5jb2RpbmdHbHNsTGliPXZvaWQgMDtjb25zdCByPW4oODUyMCk7Y2xhc3MgaSBleHRlbmRzIHIuR2xzbExpYntjb25zdHJ1Y3Rvcih0KXtzdXBlcih0KX1nZXRGdW5jdGlvbnMoKXtyZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LHRoaXMuZW5jb2RlRmxvYXQzMigpKSx0aGlzLmRlY29kZUZsb2F0MzIoKSl9Z2V0Q3VzdG9tVHlwZXMoKXtyZXR1cm57fX1lbmNvZGVGbG9hdDMyKCl7cmV0dXJue2VuY29kZTpuZXcgci5HbHNsTGliUm91dGluZShcImhpZ2hwIHZlYzQgZW5jb2RlKGhpZ2hwIGZsb2F0IGYpIHtcXG4gICAgICAgIHJldHVybiB2ZWM0KGYsIDAuMCwgMC4wLCAwLjApO1xcbiAgICAgIH1cXG4gICAgICAgIFwiKX19ZGVjb2RlRmxvYXQzMigpe3JldHVybntkZWNvZGU6bmV3IHIuR2xzbExpYlJvdXRpbmUoXCJoaWdocCBmbG9hdCBkZWNvZGUoaGlnaHAgdmVjNCByZ2JhKSB7XFxuICAgICAgICByZXR1cm4gcmdiYS5yO1xcbiAgICAgIH1cXG4gICAgICAgIFwiKX19ZW5jb2RlVWludDgoKXtjb25zdCB0PWkuaXNMaXR0bGVFbmRpYW4oKT9cInJnYmEucmdiYT1yZ2JhLmFiZ3I7XCI6XCJcIjtyZXR1cm57ZW5jb2RlOm5ldyByLkdsc2xMaWJSb3V0aW5lKGBcXG4gICAgICBoaWdocCB2ZWM0IGVuY29kZShoaWdocCBmbG9hdCBmKSB7XFxuICAgICAgICBoaWdocCBmbG9hdCBGID0gYWJzKGYpO1xcbiAgICAgICAgaGlnaHAgZmxvYXQgU2lnbiA9IHN0ZXAoMC4wLC1mKTtcXG4gICAgICAgIGhpZ2hwIGZsb2F0IEV4cG9uZW50ID0gZmxvb3IobG9nMihGKSk7XFxuICAgICAgICBoaWdocCBmbG9hdCBNYW50aXNzYSA9IChleHAyKC0gRXhwb25lbnQpICogRik7XFxuICAgICAgICBFeHBvbmVudCA9IGZsb29yKGxvZzIoRikgKyAxMjcuMCkgKyBmbG9vcihsb2cyKE1hbnRpc3NhKSk7XFxuICAgICAgICBoaWdocCB2ZWM0IHJnYmE7XFxuICAgICAgICByZ2JhWzBdID0gMTI4LjAgKiBTaWduICArIGZsb29yKEV4cG9uZW50KmV4cDIoLTEuMCkpO1xcbiAgICAgICAgcmdiYVsxXSA9IDEyOC4wICogbW9kKEV4cG9uZW50LDIuMCkgKyBtb2QoZmxvb3IoTWFudGlzc2EqMTI4LjApLDEyOC4wKTtcXG4gICAgICAgIHJnYmFbMl0gPSBmbG9vcihtb2QoZmxvb3IoTWFudGlzc2EqZXhwMigyMy4wIC04LjApKSxleHAyKDguMCkpKTtcXG4gICAgICAgIHJnYmFbM10gPSBmbG9vcihleHAyKDIzLjApKm1vZChNYW50aXNzYSxleHAyKC0xNS4wKSkpO1xcbiAgICAgICAgJHt0fVxcbiAgICAgICAgcmdiYSA9IHJnYmEgLyAyNTUuMDsgLy8gdmFsdWVzIG5lZWQgdG8gYmUgbm9ybWFsaXplZCB0byBbMCwxXVxcbiAgICAgICAgcmV0dXJuIHJnYmE7XFxuICAgIH1cXG4gICAgICAgIGApfX1kZWNvZGVVaW50OCgpe2NvbnN0IHQ9aS5pc0xpdHRsZUVuZGlhbigpP1wicmdiYS5yZ2JhPXJnYmEuYWJncjtcIjpcIlwiO3JldHVybntkZWNvZGU6bmV3IHIuR2xzbExpYlJvdXRpbmUoYFxcbiAgICAgICAgaGlnaHAgZmxvYXQgZGVjb2RlKGhpZ2hwIHZlYzQgcmdiYSkge1xcbiAgICAgICAgICByZ2JhID0gcmdiYSAqIDI1NS4wOyAvLyB2YWx1ZXMgbmVlZCB0byBiZSBkZS1ub3JtYWxpemVkIGZyb20gWzAsMV0gdG8gWzAsMjU1XVxcbiAgICAgICAgICAke3R9XFxuICAgICAgICAgIGhpZ2hwIGZsb2F0IFNpZ24gPSAxLjAgLSBzdGVwKDEyOC4wLHJnYmFbMF0pKjIuMDtcXG4gICAgICAgICAgaGlnaHAgZmxvYXQgRXhwb25lbnQgPSAyLjAgKiBtb2QocmdiYVswXSwxMjguMCkgKyBzdGVwKDEyOC4wLHJnYmFbMV0pIC0gMTI3LjA7XFxuICAgICAgICAgIGhpZ2hwIGZsb2F0IE1hbnRpc3NhID0gbW9kKHJnYmFbMV0sMTI4LjApKjY1NTM2LjAgKyByZ2JhWzJdKjI1Ni4wICtyZ2JhWzNdICsgZmxvYXQoMHg4MDAwMDApO1xcbiAgICAgICAgICBoaWdocCBmbG9hdCBSZXN1bHQgPSAgU2lnbiAqIGV4cDIoRXhwb25lbnQpICogKE1hbnRpc3NhICogZXhwMigtMjMuMCApKTtcXG4gICAgICAgICAgcmV0dXJuIFJlc3VsdDtcXG4gICAgICB9XFxuICAgICAgICBgKX19c3RhdGljIGlzTGl0dGxlRW5kaWFuKCl7Y29uc3QgdD1uZXcgQXJyYXlCdWZmZXIoNCksZT1uZXcgVWludDMyQXJyYXkodCksbj1uZXcgVWludDhBcnJheSh0KTtpZihlWzBdPTM3MzU5Mjg1NTksMjM5PT09blswXSlyZXR1cm4hMDtpZigyMjI9PT1uWzBdKXJldHVybiExO3Rocm93IG5ldyBFcnJvcihcInVua25vd24gZW5kaWFubmVzc1wiKX19ZS5FbmNvZGluZ0dsc2xMaWI9aX0sOTg5NDoodCxlLG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5GcmFnQ29sb3JHbHNsTGliPXZvaWQgMDtjb25zdCByPW4oODUyMCksaT1uKDUwNjApO2NsYXNzIG8gZXh0ZW5kcyByLkdsc2xMaWJ7Y29uc3RydWN0b3IodCl7c3VwZXIodCl9Z2V0RnVuY3Rpb25zKCl7cmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSx0aGlzLnNldEZyYWdDb2xvcigpKSx0aGlzLmdldENvbG9yQXNGbG9hdCgpKX1nZXRDdXN0b21UeXBlcygpe3JldHVybnt9fXNldEZyYWdDb2xvcigpe2NvbnN0IHQ9KDAsaS5nZXRHbHNsKSh0aGlzLmNvbnRleHQuZ2xDb250ZXh0LnZlcnNpb24pO3JldHVybntzZXRGcmFnQ29sb3I6bmV3IHIuR2xzbExpYlJvdXRpbmUoYFxcbiAgICAgICAgdm9pZCBzZXRGcmFnQ29sb3IoZmxvYXQgdmFsdWUpIHtcXG4gICAgICAgICAgICAke3Qub3V0cHV0fSA9IGVuY29kZSh2YWx1ZSk7XFxuICAgICAgICB9XFxuICAgICAgICBgLFtcImVuY29kaW5nLmVuY29kZVwiXSl9fWdldENvbG9yQXNGbG9hdCgpe3JldHVybntnZXRDb2xvckFzRmxvYXQ6bmV3IHIuR2xzbExpYlJvdXRpbmUoXCJcXG4gICAgICAgIGZsb2F0IGdldENvbG9yQXNGbG9hdCh2ZWM0IGNvbG9yKSB7XFxuICAgICAgICAgICAgcmV0dXJuIGRlY29kZShjb2xvcik7XFxuICAgICAgICB9XFxuICAgICAgICBcIixbXCJlbmNvZGluZy5kZWNvZGVcIl0pfX19ZS5GcmFnQ29sb3JHbHNsTGliPW99LDI4NDg6KHQsZSk9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLnJlcGxhY2VJbmxpbmVzPXZvaWQgMDtjb25zdCBuPS9AaW5saW5lW1xcc1xcblxccl0rKFxcdyspW1xcc1xcblxccl0rKFswLTlhLXpBLVpfXSspXFxzKlxcKChbXildKilcXClcXHMqeygoW159XXxbXFxuXFxyXSkqKX0vZ207ZS5yZXBsYWNlSW5saW5lcz1mdW5jdGlvbih0KXtjb25zdCBlPXt9O2xldCByO2Zvcig7bnVsbCE9PShyPW4uZXhlYyh0KSk7KXtjb25zdCB0PXJbM10uc3BsaXQoXCIsXCIpLm1hcCgodD0+e2NvbnN0IGU9dC50cmltKCkuc3BsaXQoXCIgXCIpO3JldHVybiBlJiYyPT09ZS5sZW5ndGg/e3R5cGU6ZVswXSxuYW1lOmVbMV19Om51bGx9KSkuZmlsdGVyKCh0PT5udWxsIT09dCkpO2VbclsyXV09e3BhcmFtczp0LGJvZHk6cls0XX19Zm9yKGNvbnN0IG4gaW4gZSl7Y29uc3QgaT1cIihcXFxcdyspP1xcXFxzKyhbXzAtOWEtekEtWl0rKVxcXFxzKz1cXFxccytfX0ZVTkNfX1xcXFwoKC4qKVxcXFwpXFxcXHMqO1wiLnJlcGxhY2UoXCJfX0ZVTkNfX1wiLG4pLG89bmV3IFJlZ0V4cChpLFwiZ21cIik7Zm9yKDtudWxsIT09KHI9by5leGVjKHQpKTspe2NvbnN0IGk9clsxXSxvPXJbMl0sYT1yWzNdLnNwbGl0KFwiLFwiKSxzPWk/YCR7aX0gJHtvfTtgOlwiXCI7bGV0IHU9ZVtuXS5ib2R5LGM9XCJcIjtlW25dLnBhcmFtcy5mb3JFYWNoKCgodCxlKT0+e3QmJihjKz1gJHt0LnR5cGV9ICR7dC5uYW1lfSA9ICR7YVtlXX07XFxuYCl9KSksdT1gJHtjfVxcbiAke3V9YCx1PXUucmVwbGFjZShcInJldHVyblwiLGAke299ID0gYCk7Y29uc3QgbD1gXFxuICAgICAgJHtzfVxcbiAgICAgIHtcXG4gICAgICAgICR7dX1cXG4gICAgICB9XFxuICAgICAgYDt0PXQucmVwbGFjZShyWzBdLGwpfX1yZXR1cm4gdC5yZXBsYWNlKG4sXCJcIil9fSw4ODc5Oih0LGUsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLkdsc2xQcmVwcm9jZXNzb3I9dm9pZCAwO2NvbnN0IHI9big4NTIwKSxpPW4oMjg0OCksbz1uKDU0ODMpLGE9big1MDYwKTtlLkdsc2xQcmVwcm9jZXNzb3I9Y2xhc3N7Y29uc3RydWN0b3IodCxlLG4saSl7dGhpcy5saWJzPXt9LHRoaXMuZ2xzbExpYlJvdXRpbmVEZXBlbmRlbmN5R3JhcGg9e30sdGhpcy5jb250ZXh0PW5ldyByLkdsc2xDb250ZXh0KHQsZSxuLGkpLE9iamVjdC5rZXlzKG8uZ2xzbFJlZ2lzdHJ5KS5mb3JFYWNoKCh0PT57Y29uc3QgZT1uZXcgby5nbHNsUmVnaXN0cnlbdF0odGhpcy5jb250ZXh0KTt0aGlzLmxpYnNbdF09ZX0pKTtjb25zdCBhPXRoaXMuZ2xzbExpYlJvdXRpbmVEZXBlbmRlbmN5R3JhcGg7Zm9yKGNvbnN0IHQgaW4gdGhpcy5saWJzKXtjb25zdCBlPXRoaXMubGlic1t0XS5nZXRGdW5jdGlvbnMoKTtmb3IoY29uc3QgbiBpbiBlKXtjb25zdCBpPXQrXCIuXCIrbjtsZXQgbzthW2ldPyhvPWFbaV0sby5yb3V0aW5lQm9keT1lW25dLnJvdXRpbmVCb2R5KToobz1uZXcgci5HbHNsTGliUm91dGluZU5vZGUoaSxlW25dLnJvdXRpbmVCb2R5KSxhW2ldPW8pO2NvbnN0IHM9ZVtuXS5kZXBlbmRlbmNpZXM7aWYocylmb3IobGV0IHQ9MDt0PHMubGVuZ3RoOysrdClpZihhW3NbdF1dKW8uYWRkRGVwZW5kZW5jeShhW3NbdF1dKTtlbHNle2NvbnN0IGU9bmV3IHIuR2xzbExpYlJvdXRpbmVOb2RlKHNbdF0pO2Fbc1t0XV09ZSxvLmFkZERlcGVuZGVuY3koZSl9fX19cHJlcHJvY2Vzcygpe2NvbnN0IHQ9dGhpcy5jb250ZXh0LnByb2dyYW1JbmZvO2xldCBlPXQuc2hhZGVyU291cmNlO3JldHVybiB0aGlzLmNvbnRleHQucHJvZ3JhbUluZm8uaGFzTWFpbnx8KGU9YCR7ZX1cXG4gICAgICAkeygwLGEuZ2V0RGVmYXVsdEZyYWdTaGFkZXJNYWluKSh0aGlzLmNvbnRleHQuZ2xDb250ZXh0LnZlcnNpb24sdGhpcy5jb250ZXh0Lm91dHB1dFRleHR1cmVMYXlvdXQuc2hhcGUubGVuZ3RoKX1gKSxlPSgwLGkucmVwbGFjZUlubGluZXMpKGUpLGAkeygwLGEuZ2V0RnJhZ1NoYWRlclByZWFtYmxlKSh0aGlzLmNvbnRleHQuZ2xDb250ZXh0LnZlcnNpb24pfVxcbiAgICAke3RoaXMuZ2V0VW5pZm9ybXModC5pbnB1dE5hbWVzLHQudmFyaWFibGVzKX1cXG4gICAgJHt0aGlzLmdldEltcG9ydHMoZSl9XFxuICAgICR7ZX1gfWdldEltcG9ydHModCl7Y29uc3QgZT10aGlzLnNlbGVjdEdsc2xMaWJSb3V0aW5lc1RvQmVJbmNsdWRlZCh0KTtpZigwPT09ZS5sZW5ndGgpcmV0dXJuXCJcIjtsZXQgbj1cIlwiO2ZvcihsZXQgdD0wO3Q8ZS5sZW5ndGg7Kyt0KXtpZighZVt0XS5yb3V0aW5lQm9keSl0aHJvdyBuZXcgRXJyb3IoYE1pc3NpbmcgYm9keSBmb3IgdGhlIEdsc2wgTGlicmFyeSByb3V0aW5lOiAke2VbdF0ubmFtZX1gKTtuKz1lW3RdLnJvdXRpbmVCb2R5K1wiXFxuXCJ9cmV0dXJuIG59c2VsZWN0R2xzbExpYlJvdXRpbmVzVG9CZUluY2x1ZGVkKHQpe2NvbnN0IGU9W107cmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuZ2xzbExpYlJvdXRpbmVEZXBlbmRlbmN5R3JhcGgpLmZvckVhY2goKG49Pntjb25zdCByPW4uc3BsaXQoXCIuXCIpWzFdOy0xIT09dC5pbmRleE9mKHIpJiZlLnB1c2godGhpcy5nbHNsTGliUm91dGluZURlcGVuZGVuY3lHcmFwaFtuXSl9KSksci5Ub3BvbG9naWNhbFNvcnRHbHNsUm91dGluZXMucmV0dXJuT3JkZXJlZE5vZGVzKGUpfWdldFVuaWZvcm1zKHQsZSl7Y29uc3Qgbj1bXTtpZih0KWZvcihjb25zdCBlIG9mIHQpbi5wdXNoKGB1bmlmb3JtIHNhbXBsZXIyRCAke2V9O2ApO2lmKGUpZm9yKGNvbnN0IHQgb2YgZSluLnB1c2goYHVuaWZvcm0gJHt0LnR5cGV9ICR7dC5uYW1lfSR7dC5hcnJheUxlbmd0aD9gWyR7dC5hcnJheUxlbmd0aH1dYDpcIlwifTtgKTtyZXR1cm4gbi5qb2luKFwiXFxuXCIpfX19LDU0ODM6KHQsZSxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUuZ2xzbFJlZ2lzdHJ5PXZvaWQgMDtjb25zdCByPW4oNTEwNyksaT1uKDczNDEpLG89big5ODk0KSxhPW4oMjY1NSkscz1uKDM4OTEpO2UuZ2xzbFJlZ2lzdHJ5PXtlbmNvZGluZzppLkVuY29kaW5nR2xzbExpYixmcmFnY29sb3I6by5GcmFnQ29sb3JHbHNsTGliLHZlYzpzLlZlY0dsc2xMaWIsc2hhcGVVdGlsczphLlNoYXBlVXRpbHNHbHNsTGliLGNvb3JkaW5hdGVzOnIuQ29vcmRzR2xzbExpYn19LDI2NTU6KHQsZSxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUuU2hhcGVVdGlsc0dsc2xMaWI9dm9pZCAwO2NvbnN0IHI9big4NTIwKTtjbGFzcyBpIGV4dGVuZHMgci5HbHNsTGlie2NvbnN0cnVjdG9yKHQpe3N1cGVyKHQpfWdldEZ1bmN0aW9ucygpe3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sdGhpcy5iY2FzdEluZGV4KCkpLHRoaXMuYmNhc3RNYXRtdWxJbmRleCgpKSx0aGlzLm9mZnNldFRvSW5kaWNlcygpKSx0aGlzLmluZGljZXNUb09mZnNldCgpKSx0aGlzLmluY3JlbWVudEluZGljZXMoKSl9Z2V0Q3VzdG9tVHlwZXMoKXtyZXR1cm57fX1iY2FzdEluZGV4KCl7Y29uc3QgdD10aGlzLmNvbnRleHQub3V0cHV0VGV4dHVyZUxheW91dC5zaGFwZS5sZW5ndGgsZT17fTtyZXR1cm4gdGhpcy5jb250ZXh0LnByb2dyYW1JbmZvLmlucHV0TmFtZXMuZm9yRWFjaCgoKG4saSk9Pntjb25zdCBvPXRoaXMuY29udGV4dC5pbnB1dFRleHR1cmVMYXlvdXRzW2ldLnVucGFja2VkU2hhcGU7aWYoby5sZW5ndGg8PXQpe2NvbnN0IGk9by5sZW5ndGgsYT10LWkscz1gYmNhc3RJbmRpY2VzXyR7bn1gO2xldCB1PVwiXCI7Zm9yKGxldCB0PTA7dDxpOysrdCl1Kz1gXFxuICAgICAgICAgIHJlYWxJbmRpY2VzWyR7dH1dID0gaW50KCBtb2QoZmxvYXQoYmNhc3RlZEluZGljZXNbJHthK3R9XSksICR7b1t0XX0uMCkgKTtcXG4gICAgICAgICAgYDtjb25zdCBjPWBcXG4gICAgICAgIHZvaWQgJHtzfSAoaW50IGJjYXN0ZWRJbmRpY2VzWyR7dH1dLCBvdXQgaW50IHJlYWxJbmRpY2VzWyR7aX1dKSB7XFxuICAgICAgICAgICR7dX1cXG4gICAgICAgIH1cXG4gICAgICAgIGA7ZVtzXT1uZXcgci5HbHNsTGliUm91dGluZShjKX19KSksZX1iY2FzdE1hdG11bEluZGV4KCl7Y29uc3QgdD10aGlzLmNvbnRleHQub3V0cHV0VGV4dHVyZUxheW91dC5zaGFwZS5sZW5ndGgsZT17fTtyZXR1cm4gdGhpcy5jb250ZXh0LnByb2dyYW1JbmZvLmlucHV0TmFtZXMuZm9yRWFjaCgoKG4saSk9Pntjb25zdCBvPXRoaXMuY29udGV4dC5pbnB1dFRleHR1cmVMYXlvdXRzW2ldLnNoYXBlO2lmKCEoby5sZW5ndGg8Mnx8by5sZW5ndGg+dCkpe2NvbnN0IGk9by5sZW5ndGgsYT10LWkscz1gYmNhc3RNYXRtdWxJbmRpY2VzXyR7bn1gO2xldCB1PVwiXCI7Zm9yKGxldCB0PTA7dDxpLTI7Kyt0KXUrPWBcXG4gICAgICAgICAgcmVhbEluZGljZXNbJHt0fV0gPSBpbnQoIG1vZChmbG9hdChiY2FzdGVkSW5kaWNlc1ske2ErdH1dKSwgJHtvW3RdfS4wKSApO1xcbiAgICAgICAgICBgO2NvbnN0IGM9YFxcbiAgICAgICAgdm9pZCAke3N9KGludCBiY2FzdGVkSW5kaWNlc1ske3R9XSwgb3V0IGludCByZWFsSW5kaWNlc1ske2l9XSkge1xcbiAgICAgICAgICAke3V9XFxuICAgICAgICAgIHJlYWxJbmRpY2VzWyR7aS0xfV0gPSBiY2FzdGVkSW5kaWNlc1ske3QtMX1dO1xcbiAgICAgICAgICByZWFsSW5kaWNlc1ske2ktMn1dID0gYmNhc3RlZEluZGljZXNbJHt0LTJ9XTtcXG4gICAgICAgIH1cXG4gICAgICAgIGA7ZVtzXT1uZXcgci5HbHNsTGliUm91dGluZShjKX19KSksZX1pbmRpY2VzVG9PZmZzZXQoKXtjb25zdCB0PXt9O3JldHVybiB0aGlzLmNvbnRleHQucHJvZ3JhbUluZm8uaW5wdXROYW1lcy5mb3JFYWNoKCgoZSxuKT0+e2NvbnN0IG89dGhpcy5jb250ZXh0LmlucHV0VGV4dHVyZUxheW91dHNbbl0uc2hhcGUsYT10aGlzLmNvbnRleHQuaW5wdXRUZXh0dXJlTGF5b3V0c1tuXS5zdHJpZGVzLHM9by5sZW5ndGg7bGV0IHU9YGluZGljZXNUb09mZnNldF8ke2V9YDt0W3VdPW5ldyByLkdsc2xMaWJSb3V0aW5lKGkuaW5kZXhUb09mZnNldFNpbmdsZSh1LHMsYSkpLHU9YGluZGljZXNUb09mZnNldF8ke2V9X1RgLHRbdV09bmV3IHIuR2xzbExpYlJvdXRpbmUoaS5pbmRleFRvT2Zmc2V0U2luZ2xlKHUscyxhLnNsaWNlKCkucmV2ZXJzZSgpKSl9KSksdH1zdGF0aWMgaW5kZXhUb09mZnNldFNpbmdsZSh0LGUsbil7bGV0IHI9XCJcIjtmb3IobGV0IHQ9ZS0xO3Q+PTA7LS10KXIrPWBcXG4gICAgICAgIG9mZnNldCArPSBpbmRpY2VzWyR7dH1dICogJHtuW3RdfTtcXG4gICAgICAgIGA7cmV0dXJuYFxcbiAgICAgIGludCAke3R9KGludCBpbmRpY2VzWyR7ZX1dKSB7XFxuICAgICAgICBpbnQgb2Zmc2V0ID0gMDtcXG4gICAgICAgICR7cn1cXG4gICAgICAgIHJldHVybiBvZmZzZXQ7XFxuICAgICAgfVxcbiAgICAgIGB9b2Zmc2V0VG9JbmRpY2VzKCl7Y29uc3QgdD17fTtyZXR1cm4gdGhpcy5jb250ZXh0LnByb2dyYW1JbmZvLmlucHV0TmFtZXMuZm9yRWFjaCgoKGUsbik9Pntjb25zdCBvPXRoaXMuY29udGV4dC5pbnB1dFRleHR1cmVMYXlvdXRzW25dLnNoYXBlLGE9dGhpcy5jb250ZXh0LmlucHV0VGV4dHVyZUxheW91dHNbbl0uc3RyaWRlcyxzPW8ubGVuZ3RoO2xldCB1PWBvZmZzZXRUb0luZGljZXNfJHtlfWA7dFt1XT1uZXcgci5HbHNsTGliUm91dGluZShpLm9mZnNldFRvSW5kaWNlc1NpbmdsZSh1LHMsYSkpLHU9YG9mZnNldFRvSW5kaWNlc18ke2V9X1RgLHRbdV09bmV3IHIuR2xzbExpYlJvdXRpbmUoaS5vZmZzZXRUb0luZGljZXNTaW5nbGUodSxzLGEuc2xpY2UoKS5yZXZlcnNlKCkpKX0pKSx0fXN0YXRpYyBvZmZzZXRUb0luZGljZXNTaW5nbGUodCxlLG4pe2NvbnN0IHI9W107Zm9yKGxldCB0PTA7dDxlLTE7Kyt0KXIucHVzaChgXFxuICAgICAgaW5kaWNlc1ske3R9XSA9IG9mZnNldCAvICR7blt0XX07YCksci5wdXNoKGBcXG4gICAgICAgIG9mZnNldCAtPSBpbmRpY2VzWyR7dH1dICogJHtuW3RdfTtgKTtyZXR1cm4gci5wdXNoKGBcXG4gICAgICBpbmRpY2VzWyR7ZS0xfV0gPSBvZmZzZXQ7YCksYFxcbiAgICAgIHZvaWQgJHt0fShpbnQgb2Zmc2V0LCBvdXQgaW50IGluZGljZXNbJHtlfV0pIHtcXG4gICAgICAgICR7ci5qb2luKFwiXCIpfVxcbiAgICAgIH1cXG4gICAgICBgfWluY3JlbWVudEluZGljZXMoKXtjb25zdCB0PXt9O3JldHVybiB0aGlzLmNvbnRleHQucHJvZ3JhbUluZm8uaW5wdXROYW1lcy5mb3JFYWNoKCgoZSxuKT0+e2NvbnN0IGk9dGhpcy5jb250ZXh0LmlucHV0VGV4dHVyZUxheW91dHNbbl0uc2hhcGUsbz1pLmxlbmd0aCxhPWBpbmNyZW1lbnRJbmRpY2VzXyR7ZX1gO2xldCBzPVwiXCI7Zm9yKGxldCB0PTA7dDxvOysrdClzKz1gXFxuICAgICAgICBzaGFwZVske3R9XSA9ICR7aVt0XX07YDtjb25zdCB1PWBcXG4gICAgICAgIHZvaWQgJHthfShpbnQgYXhpcywgb3V0IGludCBpbmRpY2VzWyR7b31dKSB7XFxuICAgICAgICAgIGludCBzaGFwZVske299XTtcXG4gICAgICAgICAgJHtzfTtcXG4gICAgICAgICAgZm9yKGludCBpID0gJHtvfSAtMSA7IGkgPj0gMDsgLS1pKSB7XFxuICAgICAgICAgICAgaWYoaSA+IGF4aXMpIGNvbnRpbnVlO1xcbiAgICAgICAgICAgIGluZGljZXNbaV0gKz0gMTtcXG4gICAgICAgICAgICBpZihpbmRpY2VzW2ldIDwgc2hhcGVbaV0pIHtcXG4gICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBpbmRpY2VzW2ldID0gMDtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgYDt0W2FdPW5ldyByLkdsc2xMaWJSb3V0aW5lKHUpfSkpLHR9fWUuU2hhcGVVdGlsc0dsc2xMaWI9aX0sNTA2MDoodCxlKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUuZ2V0RGVmYXVsdEZyYWdTaGFkZXJNYWluPWUuZ2V0RnJhZ1NoYWRlclByZWFtYmxlPWUuZ2V0VmVydGV4U2hhZGVyU291cmNlPWUuZ2V0R2xzbD12b2lkIDA7Y29uc3Qgbj17dmVyc2lvbjpcIlwiLGF0dHJpYnV0ZTpcImF0dHJpYnV0ZVwiLHZhcnlpbmdWZXJ0ZXg6XCJ2YXJ5aW5nXCIsdmFyeWluZ0ZyYWc6XCJ2YXJ5aW5nXCIsdGV4dHVyZTJEOlwidGV4dHVyZTJEXCIsb3V0cHV0OlwiZ2xfRnJhZ0NvbG9yXCIsb3V0cHV0RGVjbGFyYXRpb246XCJcIn0scj17dmVyc2lvbjpcIiN2ZXJzaW9uIDMwMCBlc1wiLGF0dHJpYnV0ZTpcImluXCIsdmFyeWluZ1ZlcnRleDpcIm91dFwiLHZhcnlpbmdGcmFnOlwiaW5cIix0ZXh0dXJlMkQ6XCJ0ZXh0dXJlXCIsb3V0cHV0Olwib3V0cHV0Q29sb3JcIixvdXRwdXREZWNsYXJhdGlvbjpcIm91dCB2ZWM0IG91dHB1dENvbG9yO1wifTtmdW5jdGlvbiBpKHQpe3JldHVybiAxPT09dD9uOnJ9ZS5nZXRHbHNsPWksZS5nZXRWZXJ0ZXhTaGFkZXJTb3VyY2U9ZnVuY3Rpb24odCl7Y29uc3QgZT1pKHQpO3JldHVybmAke2UudmVyc2lvbn1cXG4gICAgICBwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuICAgICAgJHtlLmF0dHJpYnV0ZX0gdmVjMyBwb3NpdGlvbjtcXG4gICAgICAke2UuYXR0cmlidXRlfSB2ZWMyIHRleHR1cmVDb29yZDtcXG5cXG4gICAgICAke2UudmFyeWluZ1ZlcnRleH0gdmVjMiBUZXhDb29yZHM7XFxuXFxuICAgICAgdm9pZCBtYWluKClcXG4gICAgICB7XFxuICAgICAgICAgIGdsX1Bvc2l0aW9uID0gdmVjNChwb3NpdGlvbiwgMS4wKTtcXG4gICAgICAgICAgVGV4Q29vcmRzID0gdGV4dHVyZUNvb3JkO1xcbiAgICAgIH1gfSxlLmdldEZyYWdTaGFkZXJQcmVhbWJsZT1mdW5jdGlvbih0KXtjb25zdCBlPWkodCk7cmV0dXJuYCR7ZS52ZXJzaW9ufVxcbiAgICBwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuICAgIHByZWNpc2lvbiBoaWdocCBpbnQ7XFxuICAgIHByZWNpc2lvbiBoaWdocCBzYW1wbGVyMkQ7XFxuICAgICR7ZS52YXJ5aW5nRnJhZ30gdmVjMiBUZXhDb29yZHM7XFxuICAgICR7ZS5vdXRwdXREZWNsYXJhdGlvbn1cXG4gICAgY29uc3QgdmVjMiBoYWxmQ1IgPSB2ZWMyKDAuNSwgMC41KTtcXG5cXG4gICAgLy8gQ3VzdG9tIHZlY3RvciB0eXBlcyB0byBoYW5kbGUgaGlnaGVyIGRpbWVuYWxpdGllcy5cXG4gICAgc3RydWN0IGl2ZWM1XFxuICAgIHtcXG4gICAgICBpbnQgeDtcXG4gICAgICBpbnQgeTtcXG4gICAgICBpbnQgejtcXG4gICAgICBpbnQgdztcXG4gICAgICBpbnQgdTtcXG4gICAgfTtcXG5cXG4gICAgc3RydWN0IGl2ZWM2XFxuICAgIHtcXG4gICAgICBpbnQgeDtcXG4gICAgICBpbnQgeTtcXG4gICAgICBpbnQgejtcXG4gICAgICBpbnQgdztcXG4gICAgICBpbnQgdTtcXG4gICAgICBpbnQgdjtcXG4gICAgfTtcXG5cXG4gICAgaW50IGltb2QoaW50IHgsIGludCB5KSB7XFxuICAgICAgcmV0dXJuIHggLSB5ICogKHggLyB5KTtcXG4gICAgfVxcblxcbiAgICBgfSxlLmdldERlZmF1bHRGcmFnU2hhZGVyTWFpbj1mdW5jdGlvbih0LGUpe3JldHVybmBcXG4gIHZvaWQgbWFpbigpIHtcXG4gICAgaW50IGluZGljZXNbJHtlfV07XFxuICAgIHRvVmVjKFRleENvb3JkcywgaW5kaWNlcyk7XFxuICAgIHZlYzQgcmVzdWx0ID0gdmVjNChwcm9jZXNzKGluZGljZXMpKTtcXG4gICAgJHtpKHQpLm91dHB1dH0gPSByZXN1bHQ7XFxuICB9XFxuICBgfX0sMzg5MToodCxlLG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5WZWNHbHNsTGliPXZvaWQgMDtjb25zdCByPW4oODUyMCk7Y2xhc3MgaSBleHRlbmRzIHIuR2xzbExpYntjb25zdHJ1Y3Rvcih0KXtzdXBlcih0KX1nZXRDdXN0b21UeXBlcygpe3JldHVybnt9fWdldEZ1bmN0aW9ucygpe3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LHRoaXMuYmluYXJ5VmVjRnVuY3Rpb25zKCkpLHRoaXMuY29weVZlYygpKSx0aGlzLnNldFZlY0l0ZW0oKSksdGhpcy5nZXRWZWNJdGVtKCkpfWJpbmFyeVZlY0Z1bmN0aW9ucygpe2NvbnN0IHQ9dGhpcy5jb250ZXh0Lm91dHB1dFRleHR1cmVMYXlvdXQuc2hhcGUubGVuZ3RoLGU9e2FkZDpcIis9XCIsc3ViOlwiLT1cIixtdWw6XCIqPVwiLGRpdjpcIi89XCJ9LG49e307Zm9yKGNvbnN0IGkgaW4gZSl7Y29uc3Qgbz1gJHtpfVZlY2A7bGV0IGE9XCJcIjtmb3IobGV0IG49MDtuPHQ7KytuKWErPWBcXG4gICAgICAgICAgZGVzdFske259XSAke2VbaV19IHNyY1ske259XTtcXG4gICAgICAgICAgYDtjb25zdCBzPWBcXG4gICAgICAgIHZvaWQgJHtvfShpbnQgc3JjWyR7dH1dLCBvdXQgaW50IGRlc3RbJHt0fV0pIHtcXG4gICAgICAgICAgJHthfVxcbiAgICAgICAgfVxcbiAgICAgICAgYDtuW29dPW5ldyByLkdsc2xMaWJSb3V0aW5lKHMpfXJldHVybiBufWNvcHlWZWMoKXtjb25zdCB0PXRoaXMuY29udGV4dC5vdXRwdXRUZXh0dXJlTGF5b3V0LnNoYXBlLmxlbmd0aDtsZXQgZT1cIlwiO2ZvcihsZXQgbj0wO248dDsrK24pZSs9YFxcbiAgICAgICAgZGVzdFske259XSA9IHNyY1ske259XTtcXG4gICAgICAgIGA7Y29uc3Qgbj1gXFxuICAgICAgdm9pZCBjb3B5VmVjKGludCBzcmNbJHt0fV0sIG91dCBpbnQgZGVzdFske3R9XSkge1xcbiAgICAgICAgJHtlfVxcbiAgICAgIH1cXG4gICAgICBgO3JldHVybntjb3B5VmVjOm5ldyByLkdsc2xMaWJSb3V0aW5lKG4pfX1zZXRWZWNJdGVtKCl7Y29uc3QgdD10aGlzLmNvbnRleHQub3V0cHV0VGV4dHVyZUxheW91dC5zaGFwZS5sZW5ndGg7bGV0IGU9YFxcbiAgICAgICAgaWYoaW5kZXggPCAwKVxcbiAgICAgICAgICAgIGluZGV4ID0ke3R9ICsgaW5kZXg7XFxuICAgICAgICBpZiAoaW5kZXggPT0gMClcXG4gICAgICAgICAgICBtWzBdID0gdmFsdWU7XFxuICAgICAgICBgO2ZvcihsZXQgbj0xO248dC0xOysrbillKz1gXFxuICAgICAgICBlbHNlIGlmIChpbmRleCA9PSAke259KVxcbiAgICAgICAgICAgIG1bJHtufV0gPSB2YWx1ZTtcXG4gICAgICAgICAgICBgO2UrPWBcXG4gICAgICAgIGVsc2VcXG4gICAgICAgICAgICBtWyR7dC0xfV0gPSB2YWx1ZTtcXG4gICAgICAgIGA7Y29uc3Qgbj1gXFxuICAgICAgdm9pZCBzZXRWZWNJdGVtKG91dCBpbnQgbVske3R9XSwgaW50IGluZGV4LCBpbnQgdmFsdWUpIHtcXG4gICAgICAgICR7ZX1cXG4gICAgICB9XFxuICAgICAgICBgO3JldHVybntzZXRWZWNJdGVtOm5ldyByLkdsc2xMaWJSb3V0aW5lKG4pfX1nZXRWZWNJdGVtKCl7Y29uc3QgdD10aGlzLmNvbnRleHQub3V0cHV0VGV4dHVyZUxheW91dC5zaGFwZS5sZW5ndGg7bGV0IGU9YFxcbiAgICAgICAgaWYoaW5kZXggPCAwKVxcbiAgICAgICAgICAgIGluZGV4ID0gJHt0fSArIGluZGV4O1xcbiAgICAgICAgaWYgKGluZGV4ID09IDApXFxuICAgICAgICAgICAgcmV0dXJuIG1bMF07XFxuICAgICAgYDtmb3IobGV0IG49MTtuPHQtMTsrK24pZSs9YFxcbiAgICAgICAgZWxzZSBpZiAoaW5kZXggPT0gJHtufSlcXG4gICAgICAgICAgICByZXR1cm4gbVske259XTtcXG4gICAgICBgO2UrPWBcXG4gICAgICAgIGVsc2VcXG4gICAgICAgICAgICByZXR1cm4gbVske3QtMX1dO1xcbiAgICAgICAgYDtjb25zdCBuPWBcXG4gICAgICBpbnQgZ2V0VmVjSXRlbShpbnQgbVske3R9XSwgaW50IGluZGV4KSB7XFxuICAgICAgICAke2V9XFxuICAgICAgfVxcbiAgICBgO3JldHVybntnZXRWZWNJdGVtOm5ldyByLkdsc2xMaWJSb3V0aW5lKG4pfX19ZS5WZWNHbHNsTGliPWl9LDgzMTY6KHQsZSxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUuV2ViR0xJbmZlcmVuY2VIYW5kbGVyPXZvaWQgMDtjb25zdCByPW4oNjIzMSksaT1uKDkxNjIpLG89bigyNTE3KSxhPW4oMjQwMykscz1uKDcwMTkpLHU9big4NzEwKSxjPW4oNTYxMSksbD1uKDQwNTcpLHA9bigyMDM5KTtlLldlYkdMSW5mZXJlbmNlSGFuZGxlcj1jbGFzc3tjb25zdHJ1Y3Rvcih0KXt0aGlzLnNlc3Npb249dCx0aGlzLnBhY2tlZFRleHR1cmVEYXRhQ2FjaGU9bmV3IE1hcCx0aGlzLnVucGFja2VkVGV4dHVyZURhdGFDYWNoZT1uZXcgTWFwfWNhbGN1bGF0ZVRleHR1cmVXaWR0aEFuZEhlaWdodCh0LGUpe3JldHVybigwLGwuY2FsY3VsYXRlVGV4dHVyZVdpZHRoQW5kSGVpZ2h0KSh0aGlzLnNlc3Npb24ubGF5b3V0U3RyYXRlZ3ksdCxlKX1leGVjdXRlUHJvZ3JhbSh0LGUpe2lmKGUubGVuZ3RoPHQuaW5wdXROYW1lcy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKGBJbnB1dCBzaXplIG11c3RuJ3QgYmUgbGVzcyB0aGFuICR7dC5pbnB1dE5hbWVzLmxlbmd0aH0uYCk7aWYodC5pbnB1dE5hbWVzLmxlbmd0aCE9PXQuaW5wdXRUeXBlcy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiaW5wdXQgbmFtZXMgc2l6ZSBkb2VzIG5vdCBtYXRjaCBpbnB1dCB0eXBlc1wiKTtjb25zdCBuPVtdO2ZvcihsZXQgcj0wO3I8dC5pbnB1dE5hbWVzLmxlbmd0aDsrK3IpbltyXT10aGlzLmdldE9yQ3JlYXRlVGV4dHVyZURhdGEoZVtyXSx0LmlucHV0VHlwZXNbcl0pO2NvbnN0IHI9KCh0LGUpPT57Y29uc3Qgbj1lLm1hcCgodD0+YCR7dC51bnBhY2tlZFNoYXBlLmpvaW4oXCIsXCIpfTske3Qud2lkdGh9eCR7dC5oZWlnaHR9YCkpLmpvaW4oXCJfXCIpO2xldCByPXQubmFtZTtyZXR1cm4gdC5jYWNoZUhpbnQmJihyKz1cIltcIit0LmNhY2hlSGludCtcIl1cIikscis9XCI6XCIrbixyfSkodCxuKTtsZXQgaT10aGlzLnNlc3Npb24ucHJvZ3JhbU1hbmFnZXIuZ2V0QXJ0aWZhY3Qocik7Y29uc3Qgbz1pP2kucHJvZ3JhbUluZm86XCJmdW5jdGlvblwiPT10eXBlb2YgdC5nZXQ/dC5nZXQoKTp0LGE9KDAsbC5jcmVhdGVUZXh0dXJlTGF5b3V0RnJvbVRleHR1cmVUeXBlKSh0aGlzLnNlc3Npb24ubGF5b3V0U3RyYXRlZ3ksby5vdXRwdXQuZGltcyxvLm91dHB1dC50ZXh0dXJlVHlwZSkscz10aGlzLmNyZWF0ZVRleHR1cmVEYXRhKGEsby5vdXRwdXQudHlwZSk7cmV0dXJuIGl8fChpPXRoaXMuc2Vzc2lvbi5wcm9ncmFtTWFuYWdlci5idWlsZChvLG4scyksdGhpcy5zZXNzaW9uLnByb2dyYW1NYW5hZ2VyLnNldEFydGlmYWN0KHIsaSkpLHRoaXMucnVuUHJvZ3JhbShpLG4scyksc31ydW4odCxlKXtyZXR1cm4gdGhpcy5leGVjdXRlUHJvZ3JhbSh0LGUpLnRlbnNvcn1ydW5Qcm9ncmFtKHQsZSxuKXtmb3IobGV0IG49MDtuPGUubGVuZ3RoOysrbilpZighIWVbbl0uaXNQYWNrZWQhPSh0LnByb2dyYW1JbmZvLmlucHV0VHlwZXNbbl09PT1wLlRleHR1cmVUeXBlLnBhY2tlZCkpdGhyb3cgbmV3IEVycm9yKGBpbnB1dFske259XSBwcm9wZXJ0eSBwYWNrZWQgaW5jb25zaXN0ZW50YCk7aWYoISFuLmlzUGFja2VkIT0odC5wcm9ncmFtSW5mby5vdXRwdXQudGV4dHVyZVR5cGU9PT1wLlRleHR1cmVUeXBlLnBhY2tlZCkpdGhyb3cgbmV3IEVycm9yKFwib3V0cHV0IHByb3BlcnR5IHBhY2tlZCBpbmNvbnNpc3RlbnRcIik7dGhpcy5zZXNzaW9uLnByb2dyYW1NYW5hZ2VyLnJ1bih0LGUsbil9Z2V0T3JDcmVhdGVUZXh0dXJlRGF0YSh0LGUpe2xldCBuPXRoaXMuZ2V0VGV4dHVyZURhdGEodC5kYXRhSWQsZT09PXAuVGV4dHVyZVR5cGUucGFja2VkKTtpZighbiYmKG49dGhpcy5nZXRUZXh0dXJlRGF0YSh0LmRhdGFJZCxlIT09cC5UZXh0dXJlVHlwZS5wYWNrZWQpLG4pKXJldHVybiBlPT09cC5UZXh0dXJlVHlwZS5wYWNrZWQ/dGhpcy5wYWNrKG4pOnRoaXMudW5wYWNrKG4pO2lmKCFuKXtjb25zdCByPSgwLGwuY3JlYXRlVGV4dHVyZUxheW91dEZyb21UZXh0dXJlVHlwZSkodGhpcy5zZXNzaW9uLmxheW91dFN0cmF0ZWd5LHQuZGltcyxlKTtpZihlPT09cC5UZXh0dXJlVHlwZS5wYWNrZWRMYXN0RGltZW5zaW9uKXtjb25zdCBuPTEscj00LGk9dC5kaW1zO2lmKDQ9PT1pLmxlbmd0aCl7Y29uc3Qgbz1baVswXSxNYXRoLmNlaWwoaVsxXSppWzJdKmlbM10vcildLGE9KDAsbC5jcmVhdGVUZXh0dXJlTGF5b3V0RnJvbVRleHR1cmVUeXBlKSh0aGlzLnNlc3Npb24ubGF5b3V0U3RyYXRlZ3ksbyxlKTtsZXQgcz10Lm51bWJlckRhdGE7aWYoaVsxXSppWzJdKmlbM10lciE9MCl7Y29uc3QgZT1pWzBdLG89aVsxXSppWzJdKmlbM10sYT1NYXRoLmNlaWwobypuL3IpKnI7cz1uZXcgRmxvYXQzMkFycmF5KGUqYSk7Zm9yKGxldCByPTA7cjxlOysrcil7Y29uc3QgZT1yKm8saT1yKmErciVuKm87cy5zZXQodC5udW1iZXJEYXRhLnN1YmFycmF5KGUsZStvKSxpKX19cmV0dXJuIHRoaXMuY3JlYXRlVGV4dHVyZURhdGEoYSx0LnR5cGUscyx0LDEpfX1pZihlPT09cC5UZXh0dXJlVHlwZS5wYWNrZWQpe2NvbnN0IGU9KDAsbC5jcmVhdGVUZXh0dXJlTGF5b3V0RnJvbVNoYXBlKSh0aGlzLnNlc3Npb24ubGF5b3V0U3RyYXRlZ3ksdC5kaW1zLDEsW10se3JldmVyc2VXSDohMH0pLHI9dGhpcy5jcmVhdGVUZXh0dXJlRGF0YShlLHQudHlwZSx0Lm51bWJlckRhdGEsdCwxKTtuPXRoaXMucGFjayhyKX1lbHNlIG49dGhpcy5jcmVhdGVUZXh0dXJlRGF0YShyLHQudHlwZSx0Lm51bWJlckRhdGEsdCwxKX1yZXR1cm4gbn1jcmVhdGVUZXh0dXJlRGF0YUZyb21MYXlvdXRCaW5kVGVuc29yKHQsZSxuLHIpe3JldHVybiB0aGlzLmNyZWF0ZVRleHR1cmVEYXRhKHQsZSxuLHIsMSl9Y3JlYXRlVGV4dHVyZURhdGEodCxlLG4saSxvKXtyLkxvZ2dlci52ZXJib3NlKFwiSW5mZXJlbmNlSGFuZGxlclwiLGBDcmVhdGluZyBUZXh0dXJlRGF0YTogbGF5b3V0Olske0pTT04uc3RyaW5naWZ5KHQpfV1gKTtjb25zdCBhPXRoaXMuc2Vzc2lvbi50ZXh0dXJlTWFuYWdlci5jcmVhdGVUZXh0dXJlRnJvbUxheW91dChlLHQsbixvKTtyZXR1cm4gdGhpcy5jcmVhdGVUZXh0dXJlRGF0YUZyb21UZXh0dXJlKHQsZSxhLGkpfXJlc2hhcGVVbnBhY2tlZCh0LGUpe2NvbnN0IG49dGhpcy5nZXRPckNyZWF0ZVRleHR1cmVEYXRhKHQscC5UZXh0dXJlVHlwZS51bnBhY2tlZCkscj17Y2hhbm5lbHM6bi5jaGFubmVscyxoZWlnaHQ6bi5oZWlnaHQsd2lkdGg6bi53aWR0aCxzaGFwZTowIT09ZS5sZW5ndGg/ZTpbMV0sc3RyaWRlczpvLlNoYXBlVXRpbC5jb21wdXRlU3RyaWRlcyhlKSx1bnBhY2tlZFNoYXBlOmV9O3JldHVybiB0aGlzLmNyZWF0ZVRleHR1cmVEYXRhRnJvbVRleHR1cmUocix0LnR5cGUsbi50ZXh0dXJlKS50ZW5zb3J9cmVzaGFwZVBhY2tlZCh0LGUpe2NvbnN0IG49dGhpcy5nZXRPckNyZWF0ZVRleHR1cmVEYXRhKHQscC5UZXh0dXJlVHlwZS5wYWNrZWQpO2lmKCgwLHMuaXNSZXNoYXBlQ2hlYXApKHQuZGltcyxlKSl7Y29uc3Qgcj17Y2hhbm5lbHM6bi5jaGFubmVscyxoZWlnaHQ6bi5oZWlnaHQsd2lkdGg6bi53aWR0aCxzaGFwZTowIT09ZS5sZW5ndGg/ZTpbMV0sc3RyaWRlczpvLlNoYXBlVXRpbC5jb21wdXRlU3RyaWRlcyhlKSx1bnBhY2tlZFNoYXBlOmUsaXNQYWNrZWQ6ITB9O3JldHVybiB0aGlzLmNyZWF0ZVRleHR1cmVEYXRhRnJvbVRleHR1cmUocix0LnR5cGUsbi50ZXh0dXJlKS50ZW5zb3J9Y29uc3Qgcj0oMCxzLnByb2Nlc3NEaW1zM0QpKHQuZGltcyksaT0oMCxzLnByb2Nlc3NEaW1zM0QpKGUpLGE9dGhpcy5yZXNoYXBlUGFja2VkKHQsciksdT10aGlzLnJ1bigoMCxzLmNyZWF0ZVBhY2tlZFJlc2hhcGUzRFByb2dyYW1JbmZvTG9hZGVyKSh0aGlzLGEsaSksW2FdKTtyZXR1cm4gdGhpcy5yZXNoYXBlUGFja2VkKHUsZSl9Y2FzdCh0LGUpe2NvbnN0IG49dGhpcy5nZXRPckNyZWF0ZVRleHR1cmVEYXRhKHQscC5UZXh0dXJlVHlwZS51bnBhY2tlZCk7cmV0dXJuIHRoaXMuY3JlYXRlVGV4dHVyZURhdGFGcm9tVGV4dHVyZShuLGUsbi50ZXh0dXJlKS50ZW5zb3J9Y3JlYXRlVGV4dHVyZURhdGFGcm9tVGV4dHVyZSh0LGUsbixyLG8pe2NvbnN0IGE9T2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LHQpLHt0ZW5zb3I6cnx8bmV3IGkuVGVuc29yKHQudW5wYWNrZWRTaGFwZSxlLCh0PT50aGlzLnJlYWRUZXh0dXJlKGEpKSwoYXN5bmMgdD0+dGhpcy5yZWFkVGV4dHVyZUFzeW5jKGEpKSx2b2lkIDAsbyksdGV4dHVyZTpufSk7cmV0dXJuIHRoaXMuc2V0VGV4dHVyZURhdGEoYS50ZW5zb3IuZGF0YUlkLGEsdC5pc1BhY2tlZCksYX1nZXRUZXh0dXJlRGF0YSh0LGU9ITEpe3JldHVybiB0aGlzLnNlc3Npb24uaXNJbml0aWFsaXplcih0KT90aGlzLnNlc3Npb24uZ2V0VGV4dHVyZURhdGEodCxlKTplP3RoaXMucGFja2VkVGV4dHVyZURhdGFDYWNoZS5nZXQodCk6dGhpcy51bnBhY2tlZFRleHR1cmVEYXRhQ2FjaGUuZ2V0KHQpfXNldFRleHR1cmVEYXRhKHQsZSxuPSExKXt0aGlzLnNlc3Npb24uaXNJbml0aWFsaXplcih0KT90aGlzLnNlc3Npb24uc2V0VGV4dHVyZURhdGEodCxlLG4pOihuP3RoaXMucGFja2VkVGV4dHVyZURhdGFDYWNoZTp0aGlzLnVucGFja2VkVGV4dHVyZURhdGFDYWNoZSkuc2V0KHQsZSl9aXNUZXh0dXJlTGF5b3V0Q2FjaGVkKHQsZT0hMSl7cmV0dXJuISF0aGlzLmdldFRleHR1cmVEYXRhKHQuZGF0YUlkLGUpfWRpc3Bvc2UoKXt0aGlzLnNlc3Npb24udGV4dHVyZU1hbmFnZXIuY2xlYXJBY3RpdmVUZXh0dXJlcygpLHRoaXMucGFja2VkVGV4dHVyZURhdGFDYWNoZS5mb3JFYWNoKCh0PT50aGlzLnNlc3Npb24udGV4dHVyZU1hbmFnZXIucmVsZWFzZVRleHR1cmUodCkpKSx0aGlzLnBhY2tlZFRleHR1cmVEYXRhQ2FjaGU9bmV3IE1hcCx0aGlzLnVucGFja2VkVGV4dHVyZURhdGFDYWNoZS5mb3JFYWNoKCh0PT50aGlzLnNlc3Npb24udGV4dHVyZU1hbmFnZXIucmVsZWFzZVRleHR1cmUodCkpKSx0aGlzLnVucGFja2VkVGV4dHVyZURhdGFDYWNoZT1uZXcgTWFwfXJlYWRUZXh0dXJlKHQpe3JldHVybiB0LmlzUGFja2VkP3RoaXMucmVhZFRleHR1cmUodGhpcy51bnBhY2sodCkpOnRoaXMuc2Vzc2lvbi5iYWNrZW5kLmdsQ29udGV4dC5pc0Zsb2F0MzJEb3dubG9hZFN1cHBvcnRlZD90aGlzLnNlc3Npb24udGV4dHVyZU1hbmFnZXIucmVhZFRleHR1cmUodCx0LnRlbnNvci50eXBlLHQuY2hhbm5lbHMpOnRoaXMuc2Vzc2lvbi50ZXh0dXJlTWFuYWdlci5yZWFkVWludDhUZXh0dXJlQXNGbG9hdCgoMCx1LmVuY29kZUFzVWludDgpKHRoaXMsdCkpfWFzeW5jIHJlYWRUZXh0dXJlQXN5bmModCl7cmV0dXJuIHQuaXNQYWNrZWQ/dGhpcy5yZWFkVGV4dHVyZUFzeW5jKHRoaXMudW5wYWNrKHQpKTp0aGlzLnNlc3Npb24uYmFja2VuZC5nbENvbnRleHQuaXNGbG9hdDMyRG93bmxvYWRTdXBwb3J0ZWQ/dGhpcy5zZXNzaW9uLnRleHR1cmVNYW5hZ2VyLnJlYWRUZXh0dXJlQXN5bmModCx0LnRlbnNvci50eXBlLHQuY2hhbm5lbHMpOnRoaXMuc2Vzc2lvbi50ZXh0dXJlTWFuYWdlci5yZWFkVWludDhUZXh0dXJlQXNGbG9hdCgoMCx1LmVuY29kZUFzVWludDgpKHRoaXMsdCkpfXBhY2sodCl7cmV0dXJuIHRoaXMuZXhlY3V0ZVByb2dyYW0oKDAsYS5jcmVhdGVQYWNrUHJvZ3JhbUluZm9Mb2FkZXIpKHRoaXMsdC50ZW5zb3IpLFt0LnRlbnNvcl0pfXVucGFjayh0KXtyZXR1cm4gdGhpcy5leGVjdXRlUHJvZ3JhbSgoMCxjLmNyZWF0ZVVucGFja1Byb2dyYW1JbmZvTG9hZGVyKSh0aGlzLHQudGVuc29yKSxbdC50ZW5zb3JdKX19fSwxNjQwOmZ1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjt2YXIgcj10aGlzJiZ0aGlzLl9fY3JlYXRlQmluZGluZ3x8KE9iamVjdC5jcmVhdGU/ZnVuY3Rpb24odCxlLG4scil7dm9pZCAwPT09ciYmKHI9bik7dmFyIGk9T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLG4pO2kmJiEoXCJnZXRcImluIGk/IWUuX19lc01vZHVsZTppLndyaXRhYmxlfHxpLmNvbmZpZ3VyYWJsZSl8fChpPXtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBlW25dfX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LHIsaSl9OmZ1bmN0aW9uKHQsZSxuLHIpe3ZvaWQgMD09PXImJihyPW4pLHRbcl09ZVtuXX0pLGk9dGhpcyYmdGhpcy5fX3NldE1vZHVsZURlZmF1bHR8fChPYmplY3QuY3JlYXRlP2Z1bmN0aW9uKHQsZSl7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJkZWZhdWx0XCIse2VudW1lcmFibGU6ITAsdmFsdWU6ZX0pfTpmdW5jdGlvbih0LGUpe3QuZGVmYXVsdD1lfSksbz10aGlzJiZ0aGlzLl9faW1wb3J0U3Rhcnx8ZnVuY3Rpb24odCl7aWYodCYmdC5fX2VzTW9kdWxlKXJldHVybiB0O3ZhciBlPXt9O2lmKG51bGwhPXQpZm9yKHZhciBuIGluIHQpXCJkZWZhdWx0XCIhPT1uJiZPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCxuKSYmcihlLHQsbik7cmV0dXJuIGkoZSx0KSxlfTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLldFQkdMX09QX1JFU09MVkVfUlVMRVM9dm9pZCAwO2NvbnN0IGE9bigyODk4KSxzPW8obig3ODM5KSksdT1uKDQxOTYpLGM9bigyMDY5KSxsPW4oODEzOCkscD1uKDk2NjMpLGY9big1MTkzKSxkPW4oNzk5MiksaD1uKDEyNTMpLGc9big0Nzc2KSxiPW4oNjU3MiksbT1uKDMzNDYpLHk9big1NjIzKSxfPW4oMjg3MCksdj1uKDIxNDMpLHc9big0OTM5KSx4PW4oNzE4KSxUPW4oMjI2OCksUz1uKDgxMTcpLE89bigyMjc4KSxBPW4oNTUyNCksRT1uKDU5NzUpLEk9bigzOTMzKSxQPW4oNjU1OCksRD1uKDU3MjMpLCQ9bigzNzM4KSxrPW8obig0OTA5KSksQz1uKDg0MjgpLEY9big5NzkzKTtlLldFQkdMX09QX1JFU09MVkVfUlVMRVM9W1tcIkFic1wiLFwiXCIsXCI2K1wiLGsuYWJzXSxbXCJBY29zXCIsXCJcIixcIjcrXCIsay5hY29zXSxbXCJBZGRcIixcIlwiLFwiNytcIixzLmFkZF0sW1wiQW5kXCIsXCJcIixcIjcrXCIscy5hbmRdLFtcIkFzaW5cIixcIlwiLFwiNytcIixrLmFzaW5dLFtcIkF0YW5cIixcIlwiLFwiNytcIixrLmF0YW5dLFtcIkF2ZXJhZ2VQb29sXCIsXCJcIixcIjcrXCIsdi5hdmVyYWdlUG9vbCx2LnBhcnNlQXZlcmFnZVBvb2xBdHRyaWJ1dGVzXSxbXCJCYXRjaE5vcm1hbGl6YXRpb25cIixcIlwiLFwiNytcIixhLmJhdGNoTm9ybWFsaXphdGlvbixhLnBhcnNlQmF0Y2hOb3JtYWxpemF0aW9uQXR0cmlidXRlc10sW1wiQ2FzdFwiLFwiXCIsXCI2K1wiLHUuY2FzdCx1LnBhcnNlQ2FzdEF0dHJpYnV0ZXNdLFtcIkNlaWxcIixcIlwiLFwiNitcIixrLmNlaWxdLFtcIkNsaXBcIixcIlwiLFwiNi0xMFwiLGsuY2xpcCxrLnBhcnNlQ2xpcEF0dHJpYnV0ZXNdLFtcIkNsaXBcIixcIlwiLFwiMTErXCIsay5jbGlwVjExXSxbXCJDb25jYXRcIixcIlwiLFwiNCtcIixjLmNvbmNhdCxjLnBhcnNlQ29uY2F0QXR0cmlidXRlc10sW1wiQ29udlwiLFwiXCIsXCIxK1wiLGwuY29udixsLnBhcnNlQ29udkF0dHJpYnV0ZXNdLFtcIkNvbnZUcmFuc3Bvc2VcIixcIlwiLFwiMStcIixwLmNvbnZUcmFuc3Bvc2UscC5wYXJzZUNvbnZUcmFuc3Bvc2VBdHRyaWJ1dGVzXSxbXCJDb3NcIixcIlwiLFwiNytcIixrLmNvc10sW1wiRGl2XCIsXCJcIixcIjcrXCIscy5kaXZdLFtcIkRyb3BvdXRcIixcIlwiLFwiNytcIixrLmlkZW50aXR5XSxbXCJEZXB0aFRvU3BhY2VcIixcIlwiLFwiMStcIixmLmRlcHRoVG9TcGFjZSxmLnBhcnNlRGVwdGhUb1NwYWNlQXR0cmlidXRlc10sW1wiRXF1YWxcIixcIlwiLFwiNytcIixzLmVxdWFsXSxbXCJFbHVcIixcIlwiLFwiNitcIixrLmVsdSxrLnBhcnNlRWx1QXR0cmlidXRlc10sW1wiRXhwXCIsXCJcIixcIjYrXCIsay5leHBdLFtcIkZsYXR0ZW5cIixcIlwiLFwiMStcIixkLmZsYXR0ZW4sZC5wYXJzZUZsYXR0ZW5BdHRyaWJ1dGVzXSxbXCJGbG9vclwiLFwiXCIsXCI2K1wiLGsuZmxvb3JdLFtcIkZ1c2VkQ29udlwiLFwiY29tLm1pY3Jvc29mdFwiLFwiMStcIixsLmNvbnYsbC5wYXJzZUNvbnZBdHRyaWJ1dGVzXSxbXCJHYXRoZXJcIixcIlwiLFwiMStcIixoLmdhdGhlcixoLnBhcnNlR2F0aGVyQXR0cmlidXRlc10sW1wiR2VtbVwiLFwiXCIsXCI3LTEwXCIsZy5nZW1tLGcucGFyc2VHZW1tQXR0cmlidXRlc1Y3XSxbXCJHZW1tXCIsXCJcIixcIjExK1wiLGcuZ2VtbSxnLnBhcnNlR2VtbUF0dHJpYnV0ZXNWMTFdLFtcIkdsb2JhbEF2ZXJhZ2VQb29sXCIsXCJcIixcIjErXCIsdi5nbG9iYWxBdmVyYWdlUG9vbCx2LnBhcnNlR2xvYmFsQXZlcmFnZVBvb2xBdHRyaWJ1dGVzXSxbXCJHbG9iYWxNYXhQb29sXCIsXCJcIixcIjErXCIsdi5nbG9iYWxNYXhQb29sXSxbXCJHcmVhdGVyXCIsXCJcIixcIjcrXCIscy5ncmVhdGVyXSxbXCJJZGVudGl0eVwiLFwiXCIsXCIxK1wiLGsuaWRlbnRpdHldLFtcIkltYWdlU2NhbGVyXCIsXCJcIixcIjErXCIsYi5pbWFnZVNjYWxlcixiLnBhcnNlSW1hZ2VTY2FsZXJBdHRyaWJ1dGVzXSxbXCJJbnN0YW5jZU5vcm1hbGl6YXRpb25cIixcIlwiLFwiNitcIixtLmluc3RhbmNlTm9ybWFsaXphdGlvbixtLnBhcnNlSW5zdGFuY2VOb3JtYWxpemF0aW9uQXR0cmlidXRlc10sW1wiTGVha3lSZWx1XCIsXCJcIixcIjYrXCIsay5sZWFreVJlbHUsay5wYXJzZUxlYWt5UmVsdUF0dHJpYnV0ZXNdLFtcIkxlc3NcIixcIlwiLFwiNytcIixzLmxlc3NdLFtcIkxvZ1wiLFwiXCIsXCI2K1wiLGsubG9nXSxbXCJNYXRNdWxcIixcIlwiLFwiMStcIix5Lm1hdE11bCx5LnBhcnNlTWF0TXVsQXR0cmlidXRlc10sW1wiTWF4UG9vbFwiLFwiXCIsXCIxK1wiLHYubWF4UG9vbCx2LnBhcnNlTWF4UG9vbEF0dHJpYnV0ZXNdLFtcIk11bFwiLFwiXCIsXCI3K1wiLHMubXVsXSxbXCJOZWdcIixcIlwiLFwiNitcIixrLm5lZ10sW1wiTm90XCIsXCJcIixcIjErXCIsay5ub3RdLFtcIk9yXCIsXCJcIixcIjcrXCIscy5vcl0sW1wiUGFkXCIsXCJcIixcIjItMTBcIixfLnBhZFYyLF8ucGFyc2VQYWRBdHRyaWJ1dGVzVjJdLFtcIlBhZFwiLFwiXCIsXCIxMStcIixfLnBhZFYxMSxfLnBhcnNlUGFkQXR0cmlidXRlc1YxMV0sW1wiUG93XCIsXCJcIixcIjcrXCIscy5wb3ddLFtcIlBSZWx1XCIsXCJcIixcIjcrXCIscy5wUmVsdV0sW1wiUmVkdWNlTG9nU3VtXCIsXCJcIixcIjErXCIsdy5yZWR1Y2VMb2dTdW0sdy5wYXJzZVJlZHVjZUF0dHJpYnV0ZXNdLFtcIlJlZHVjZU1heFwiLFwiXCIsXCIxK1wiLHcucmVkdWNlTWF4LHcucGFyc2VSZWR1Y2VBdHRyaWJ1dGVzXSxbXCJSZWR1Y2VNZWFuXCIsXCJcIixcIjErXCIsdy5yZWR1Y2VNZWFuLHcucGFyc2VSZWR1Y2VBdHRyaWJ1dGVzXSxbXCJSZWR1Y2VNaW5cIixcIlwiLFwiMStcIix3LnJlZHVjZU1pbix3LnBhcnNlUmVkdWNlQXR0cmlidXRlc10sW1wiUmVkdWNlUHJvZFwiLFwiXCIsXCIxK1wiLHcucmVkdWNlUHJvZCx3LnBhcnNlUmVkdWNlQXR0cmlidXRlc10sW1wiUmVkdWNlU3VtXCIsXCJcIixcIjEtMTJcIix3LnJlZHVjZVN1bSx3LnBhcnNlUmVkdWNlQXR0cmlidXRlc10sW1wiUmVkdWNlU3VtU3F1YXJlXCIsXCJcIixcIjErXCIsdy5yZWR1Y2VMb2dTdW1TcXVhcmUsdy5wYXJzZVJlZHVjZUF0dHJpYnV0ZXNdLFtcIlJlbHVcIixcIlwiLFwiNitcIixrLnJlbHVdLFtcIlJlc2hhcGVcIixcIlwiLFwiNStcIix4LnJlc2hhcGVdLFtcIlJlc2l6ZVwiLFwiXCIsXCIxMFwiLFQucmVzaXplLFQucGFyc2VSZXNpemVBdHRyaWJ1dGVzVjEwXSxbXCJSZXNpemVcIixcIlwiLFwiMTErXCIsVC5yZXNpemUsVC5wYXJzZVJlc2l6ZUF0dHJpYnV0ZXNWMTFdLFtcIlNoYXBlXCIsXCJcIixcIjErXCIsUy5zaGFwZV0sW1wiU2lnbW9pZFwiLFwiXCIsXCI2K1wiLGsuc2lnbW9pZF0sW1wiU2luXCIsXCJcIixcIjcrXCIsay5zaW5dLFtcIlNsaWNlXCIsXCJcIixcIjEwK1wiLE8uc2xpY2VWMTBdLFtcIlNsaWNlXCIsXCJcIixcIjEtOVwiLE8uc2xpY2UsTy5wYXJzZVNsaWNlQXR0cmlidXRlc10sW1wiU29mdG1heFwiLFwiXCIsXCIxLTEyXCIsQS5zb2Z0bWF4LEEucGFyc2VTb2Z0bWF4QXR0cmlidXRlc10sW1wiU29mdG1heFwiLFwiXCIsXCIxMytcIixBLnNvZnRtYXhWMTMsQS5wYXJzZVNvZnRtYXhBdHRyaWJ1dGVzVjEzXSxbXCJTcGxpdFwiLFwiXCIsXCIyLTEyXCIsRS5zcGxpdCxFLnBhcnNlU3BsaXRBdHRyaWJ1dGVzXSxbXCJTcXJ0XCIsXCJcIixcIjYrXCIsay5zcXJ0XSxbXCJTcXVlZXplXCIsXCJcIixcIjEtMTJcIixJLnNxdWVlemUsSS5wYXJzZVNxdWVlemVBdHRyaWJ1dGVzXSxbXCJTcXVlZXplXCIsXCJcIixcIjEzK1wiLEkuc3F1ZWV6ZVYxM10sW1wiU3ViXCIsXCJcIixcIjcrXCIscy5zdWJdLFtcIlN1bVwiLFwiXCIsXCI2K1wiLFAuc3VtXSxbXCJUYW5cIixcIlwiLFwiNytcIixrLnRhbl0sW1wiVGFuaFwiLFwiXCIsXCI2K1wiLGsudGFuaF0sW1wiVGlsZVwiLFwiXCIsXCI2K1wiLEQudGlsZV0sW1wiVHJhbnNwb3NlXCIsXCJcIixcIjErXCIsJC50cmFuc3Bvc2UsJC5wYXJzZVRyYW5zcG9zZUF0dHJpYnV0ZXNdLFtcIlVwc2FtcGxlXCIsXCJcIixcIjctOFwiLEYudXBzYW1wbGUsRi5wYXJzZVVwc2FtcGxlQXR0cmlidXRlc1Y3XSxbXCJVcHNhbXBsZVwiLFwiXCIsXCI5XCIsRi51cHNhbXBsZSxGLnBhcnNlVXBzYW1wbGVBdHRyaWJ1dGVzVjldLFtcIlVuc3F1ZWV6ZVwiLFwiXCIsXCIxLTEyXCIsQy51bnNxdWVlemUsQy5wYXJzZVVuc3F1ZWV6ZUF0dHJpYnV0ZXNdLFtcIlVuc3F1ZWV6ZVwiLFwiXCIsXCIxMytcIixDLnVuc3F1ZWV6ZVYxM10sW1wiWG9yXCIsXCJcIixcIjcrXCIscy54b3JdXX0sMjg5ODoodCxlLG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5wYXJzZUJhdGNoTm9ybWFsaXphdGlvbkF0dHJpYnV0ZXM9ZS5iYXRjaE5vcm1hbGl6YXRpb249dm9pZCAwO2NvbnN0IHI9bigyNDYpLGk9big1MDYwKSxvPW4oMjAzOSksYT17bmFtZTpcIkJhdGNoTm9ybWFsaXphdGlvblwiLGlucHV0TmFtZXM6W1wiQVwiLFwiU2NhbGVcIixcIkJcIixcIk1lYW5cIixcIlZhcmlhbmNlXCJdLGlucHV0VHlwZXM6W28uVGV4dHVyZVR5cGUudW5wYWNrZWQsby5UZXh0dXJlVHlwZS51bnBhY2tlZCxvLlRleHR1cmVUeXBlLnVucGFja2VkLG8uVGV4dHVyZVR5cGUudW5wYWNrZWQsby5UZXh0dXJlVHlwZS51bnBhY2tlZF19O2UuYmF0Y2hOb3JtYWxpemF0aW9uPSh0LGUsbik9Pih1KGUpLFt0LnJ1bihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sYSkse2NhY2hlSGludDpuLmNhY2hlS2V5LGdldDooKT0+cyh0LGUsbil9KSxlKV0pLGUucGFyc2VCYXRjaE5vcm1hbGl6YXRpb25BdHRyaWJ1dGVzPXQ9Pntjb25zdCBlPXQuYXR0cmlidXRlcy5nZXRGbG9hdChcImVwc2lsb25cIiwxZS01KSxuPXQuYXR0cmlidXRlcy5nZXRGbG9hdChcIm1vbWVudHVtXCIsLjkpLGk9dC5hdHRyaWJ1dGVzLmdldEludChcInNwYXRpYWxcIiwxKTtyZXR1cm4oMCxyLmNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSkoe2Vwc2lsb246ZSxtb21lbnR1bTpuLHNwYXRpYWw6aX0pfTtjb25zdCBzPSh0LGUsbik9Pntjb25zdCByPSgwLGkuZ2V0R2xzbCkodC5zZXNzaW9uLmJhY2tlbmQuZ2xDb250ZXh0LnZlcnNpb24pLHM9ZVswXS5kaW1zLmxlbmd0aCxbdSxjXT10LmNhbGN1bGF0ZVRleHR1cmVXaWR0aEFuZEhlaWdodChlWzFdLmRpbXMsby5UZXh0dXJlVHlwZS51bnBhY2tlZCksbD1gXFxuICBmbG9hdCBwcm9jZXNzKGludFske3N9XSBpbmRpY2VzKSB7XFxuICAgIHZlYzIgcG9zaXRpb24gPSBvZmZzZXRUb0Nvb3JkcyhpbmRpY2VzWzFdLCAke3V9LCAke2N9KTtcXG4gICAgZmxvYXQgc2NhbGUgPSBnZXRDb2xvckFzRmxvYXQoJHtyLnRleHR1cmUyRH0oU2NhbGUsIHBvc2l0aW9uKSk7XFxuICAgIGZsb2F0IG1lYW4gPSBnZXRDb2xvckFzRmxvYXQoJHtyLnRleHR1cmUyRH0oTWVhbiwgcG9zaXRpb24pKTtcXG4gICAgZmxvYXQgdmFyaWFuY2UgPSBnZXRDb2xvckFzRmxvYXQoJHtyLnRleHR1cmUyRH0oVmFyaWFuY2UsIHBvc2l0aW9uKSk7XFxuICAgIGZsb2F0IGIgPSBnZXRDb2xvckFzRmxvYXQoJHtyLnRleHR1cmUyRH0oQiwgcG9zaXRpb24pKTtcXG5cXG4gICAgcmV0dXJuIHNjYWxlICogKCAoX0EoaW5kaWNlcykgLSBtZWFuKSAvIHNxcnQodmFyaWFuY2UgKyBmbG9hdCgke24uZXBzaWxvbn0pKSApICsgYjtcXG4gIH1gO3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sYSkse291dHB1dDp7ZGltczplWzBdLmRpbXMsdHlwZTplWzBdLnR5cGUsdGV4dHVyZVR5cGU6by5UZXh0dXJlVHlwZS51bnBhY2tlZH0sc2hhZGVyU291cmNlOmx9KX0sdT10PT57aWYoIXR8fDUhPT10Lmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJCYXRjaE5vcm1hbGl6YXRpb24gcmVxdWlyZXMgNSBpbnB1dHMuXCIpO2NvbnN0IGU9dFswXSxuPXRbMV0scj10WzJdLGk9dFszXSxvPXRbNF07aWYoZS5kaW1zLmxlbmd0aDwzfHwxIT09bi5kaW1zLmxlbmd0aHx8MSE9PXIuZGltcy5sZW5ndGh8fDEhPT1pLmRpbXMubGVuZ3RofHwxIT09by5kaW1zLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGlucHV0IHNoYXBlLlwiKTtpZihuLmRpbXNbMF0hPT1lLmRpbXNbMV18fHIuZGltc1swXSE9PWUuZGltc1sxXXx8aS5kaW1zWzBdIT09ZS5kaW1zWzFdfHxvLmRpbXNbMF0hPT1lLmRpbXNbMV0pdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBpbnB1dCBzaGFwZS5cIik7aWYoXCJmbG9hdDMyXCIhPT1lLnR5cGUmJlwiZmxvYXQ2NFwiIT09ZS50eXBlfHxcImZsb2F0MzJcIiE9PW4udHlwZSYmXCJmbG9hdDY0XCIhPT1uLnR5cGV8fFwiZmxvYXQzMlwiIT09ci50eXBlJiZcImZsb2F0NjRcIiE9PXIudHlwZXx8XCJmbG9hdDMyXCIhPT1pLnR5cGUmJlwiZmxvYXQ2NFwiIT09aS50eXBlfHxcImZsb2F0MzJcIiE9PW8udHlwZSYmXCJmbG9hdDY0XCIhPT1vLnR5cGUpdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBpbnB1dCB0ZW5zb3IgdHlwZXMuXCIpfX0sNzgzOToodCxlLG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS54b3I9ZS5zdWI9ZS5wUmVsdT1lLnBvdz1lLm9yPWUubXVsPWUubGVzcz1lLmdyZWF0ZXI9ZS5lcXVhbD1lLmRpdj1lLmFuZD1lLmFkZD1lLmdsc2xQUmVsdT1lLmdsc2xQb3c9ZS5nbHNsWG9yPWUuZ2xzbE9yPWUuZ2xzbEFuZD1lLmdsc2xMZXNzPWUuZ2xzbEdyZWF0ZXI9ZS5nbHNsRXF1YWw9ZS5nbHNsU3ViPWUuZ2xzbE11bD1lLmdsc2xEaXY9ZS5nbHNsQWRkPXZvaWQgMDtjb25zdCByPW4oMjUxNyksaT1uKDg1MjApLG89big1MDYwKSxhPW4oMjAzOSk7ZnVuY3Rpb24gcygpe2NvbnN0IHQ9XCJhZGRfXCI7cmV0dXJue2JvZHk6YFxcbiAgZmxvYXQgJHt0fShmbG9hdCBhLCBmbG9hdCBiKSB7XFxuICAgIHJldHVybiBhICsgYjtcXG4gIH1cXG4gIHZlYzQgJHt0fSh2ZWM0IHYxLCB2ZWM0IHYyKSB7XFxuICAgIHJldHVybiB2MSArIHYyO1xcbiAgfVxcbiAgYCxuYW1lOnQsdHlwZTppLkZ1bmN0aW9uVHlwZS5WYWx1ZUJhc2VkfX1mdW5jdGlvbiB1KCl7Y29uc3QgdD1cImRpdl9cIjtyZXR1cm57Ym9keTpgXFxuICBmbG9hdCAke3R9KGZsb2F0IGEsIGZsb2F0IGIpIHtcXG4gICAgcmV0dXJuIGEgLyBiO1xcbiAgfVxcbiAgdmVjNCAke3R9KHZlYzQgdjEsIHZlYzQgdjIpIHtcXG4gICAgcmV0dXJuIHYxIC8gdjI7XFxuICB9XFxuICBgLG5hbWU6dCx0eXBlOmkuRnVuY3Rpb25UeXBlLlZhbHVlQmFzZWR9fWZ1bmN0aW9uIGMoKXtjb25zdCB0PVwibXVsX1wiO3JldHVybntib2R5OmBcXG4gIGZsb2F0ICR7dH0oZmxvYXQgYSwgZmxvYXQgYikge1xcbiAgICByZXR1cm4gYSAqIGI7XFxuICB9XFxuICB2ZWM0ICR7dH0odmVjNCB2MSwgdmVjNCB2Mikge1xcbiAgICByZXR1cm4gdjEgKiB2MjtcXG4gIH1cXG4gIGAsbmFtZTp0LHR5cGU6aS5GdW5jdGlvblR5cGUuVmFsdWVCYXNlZH19ZnVuY3Rpb24gbCgpe2NvbnN0IHQ9XCJzdWJfXCI7cmV0dXJue2JvZHk6YFxcbiAgZmxvYXQgJHt0fShmbG9hdCBhLCBmbG9hdCBiKSB7XFxuICAgIHJldHVybiBhIC0gYjtcXG4gIH1cXG4gIHZlYzQgJHt0fSh2ZWM0IHYxLCB2ZWM0IHYyKSB7XFxuICAgIHJldHVybiB2MSAtIHYyO1xcbiAgfVxcbiAgYCxuYW1lOnQsdHlwZTppLkZ1bmN0aW9uVHlwZS5WYWx1ZUJhc2VkfX1mdW5jdGlvbiBwKCl7Y29uc3QgdD1cImVxdWFsX1wiO3JldHVybntib2R5OmBcXG4gIGZsb2F0ICR7dH0oZmxvYXQgYSwgZmxvYXQgYikge1xcbiAgICByZXR1cm4gZmxvYXQoYSA9PSBiKTtcXG4gIH1cXG4gIHZlYzQgJHt0fSh2ZWM0IHYxLCB2ZWM0IHYyKSB7XFxuICAgIHJldHVybiB2ZWM0KGVxdWFsKHYxLCB2MikpO1xcbiAgfVxcbiAgYCxuYW1lOnQsdHlwZTppLkZ1bmN0aW9uVHlwZS5WYWx1ZUJhc2VkfX1mdW5jdGlvbiBmKCl7Y29uc3QgdD1cImdyZWF0ZXJfXCI7cmV0dXJue2JvZHk6YFxcbiAgZmxvYXQgJHt0fShmbG9hdCBhLCBmbG9hdCBiKSB7XFxuICAgIHJldHVybiBmbG9hdChhID4gYik7XFxuICB9XFxuICB2ZWM0ICR7dH0odmVjNCB2MSwgdmVjNCB2Mikge1xcbiAgICByZXR1cm4gdmVjNCggdjEuciA+IHYyLnIgLFxcbiAgICAgIHYxLmcgPiB2Mi5nLFxcbiAgICAgIHYxLmIgPiB2Mi5iLFxcbiAgICAgIHYxLmEgPiB2Mi5hICk7XFxuICB9XFxuICBgLG5hbWU6dCx0eXBlOmkuRnVuY3Rpb25UeXBlLlZhbHVlQmFzZWR9fWZ1bmN0aW9uIGQoKXtjb25zdCB0PVwibGVzc19cIjtyZXR1cm57Ym9keTpgXFxuICBmbG9hdCAke3R9KGZsb2F0IGEsIGZsb2F0IGIpIHtcXG4gICAgcmV0dXJuIGZsb2F0KGEgPCBiKTtcXG4gIH1cXG4gIHZlYzQgJHt0fSh2ZWM0IHYxLCB2ZWM0IHYyKSB7XFxuICAgIHJldHVybiB2ZWM0KCB2MS5yIDwgdjIuciAsXFxuICAgICAgICAgICAgICAgIHYxLmcgPCB2Mi5nLFxcbiAgICAgICAgICAgICAgICB2MS5iIDwgdjIuYixcXG4gICAgICAgICAgICAgICAgdjEuYSA8IHYyLmEgKTtcXG4gIH1cXG4gIGAsbmFtZTp0LHR5cGU6aS5GdW5jdGlvblR5cGUuVmFsdWVCYXNlZH19ZnVuY3Rpb24gaCgpe2NvbnN0IHQ9XCJhbmRfXCI7cmV0dXJue2JvZHk6YFxcbiAgZmxvYXQgJHt0fShmbG9hdCBhLCBmbG9hdCBiKSB7XFxuICAgIHJldHVybiBmbG9hdCggYm9vbChhKSAmJiBib29sKGIpICk7XFxuICB9XFxuICB2ZWM0ICR7dH0odmVjNCB2MSwgdmVjNCB2Mikge1xcbiAgICBidmVjNCBiMSA9IGJ2ZWM0KHYxKTtcXG4gICAgYnZlYzQgYjIgPSBidmVjNCh2Mik7XFxuICAgIHJldHVybiB2ZWM0KCBiMS5yICYmIGIyLnIgLFxcbiAgICAgICAgICAgICAgICBiMS5nICYmIGIyLmcsXFxuICAgICAgICAgICAgICAgIGIxLmIgJiYgYjIuYixcXG4gICAgICAgICAgICAgICAgYjEuYSAmJiBiMi5hICk7XFxuICB9XFxuICBgLG5hbWU6dCx0eXBlOmkuRnVuY3Rpb25UeXBlLlZhbHVlQmFzZWR9fWZ1bmN0aW9uIGcoKXtjb25zdCB0PVwib3JfXCI7cmV0dXJue2JvZHk6YFxcbiAgZmxvYXQgJHt0fShmbG9hdCBhLCBmbG9hdCBiKSB7XFxuICAgIHJldHVybiBmbG9hdCggYm9vbChhKSB8fCBib29sKGIpICk7XFxuICB9XFxuICB2ZWM0ICR7dH0odmVjNCB2MSwgdmVjNCB2Mikge1xcbiAgICBidmVjNCBiMSA9IGJ2ZWM0KHYxKTtcXG4gICAgYnZlYzQgYjIgPSBidmVjNCh2Mik7XFxuICAgIHJldHVybiB2ZWM0KCBiMS5yIHx8IGIyLnIgLFxcbiAgICAgICAgICAgICAgICBiMS5nIHx8IGIyLmcsXFxuICAgICAgICAgICAgICAgIGIxLmIgfHwgYjIuYixcXG4gICAgICAgICAgICAgICAgYjEuYSB8fCBiMi5hICk7XFxuICB9XFxuICBgLG5hbWU6dCx0eXBlOmkuRnVuY3Rpb25UeXBlLlZhbHVlQmFzZWR9fWZ1bmN0aW9uIGIoKXtjb25zdCB0PVwieG9yX1wiO3JldHVybntib2R5OmBcXG4gIGZsb2F0ICR7dH0oZmxvYXQgYSwgZmxvYXQgYikge1xcbiAgICByZXR1cm4gZmxvYXQoIGJvb2woYSkgXl4gYm9vbChiKSApO1xcbiAgfVxcbiAgdmVjNCAke3R9KHZlYzQgdjEsIHZlYzQgdjIpIHtcXG4gICAgYnZlYzQgYjEgPSBidmVjNCh2MSk7XFxuICAgIGJ2ZWM0IGIyID0gYnZlYzQodjIpO1xcbiAgICByZXR1cm4gdmVjNCggYjEuciBeXiBiMi5yICxcXG4gICAgICAgICAgICAgICAgYjEuZyBeXiBiMi5nLFxcbiAgICAgICAgICAgICAgICBiMS5iIF5eIGIyLmIsXFxuICAgICAgICAgICAgICAgIGIxLmEgXl4gYjIuYSApO1xcbiAgfVxcbiAgYCxuYW1lOnQsdHlwZTppLkZ1bmN0aW9uVHlwZS5WYWx1ZUJhc2VkfX1mdW5jdGlvbiBtKCl7cmV0dXJuIGZ1bmN0aW9uKHQpe2NvbnN0IGU9YCR7dH1fYDtyZXR1cm57Ym9keTpgXFxuICBmbG9hdCAke2V9KGZsb2F0IGEsIGZsb2F0IGIpIHtcXG4gICAgcmV0dXJuICR7dH0oYSwgYik7XFxuICB9XFxuICB2ZWM0ICR7ZX0odmVjNCB2MSwgdmVjNCB2Mikge1xcbiAgICByZXR1cm4gJHt0fSh2MSwgdjIpO1xcbiAgfVxcbiAgYCxuYW1lOmUsdHlwZTppLkZ1bmN0aW9uVHlwZS5WYWx1ZUJhc2VkfX0oXCJwb3dcIil9ZnVuY3Rpb24geSgpe2NvbnN0IHQ9XCJwcmVsdV9cIjtyZXR1cm57Ym9keTpgXFxuICBmbG9hdCAke3R9KGZsb2F0IGEsIGZsb2F0IGIpIHtcXG4gICAgcmV0dXJuIGEgPCAwLjAgPyBhICogYjogYTtcXG4gIH1cXG4gIHZlYzQgJHt0fSh2ZWM0IHYxLCB2ZWM0IHYyKSB7XFxuICAgIHJldHVybiB2ZWM0KFxcbiAgICAgIHYxLnIgPCAwLjAgPyB2MS5yICogdjIucjogdjEucixcXG4gICAgICB2MS5nIDwgMC4wID8gdjEuZyAqIHYyLmc6IHYxLmcsXFxuICAgICAgdjEuYiA8IDAuMCA/IHYxLmIgKiB2Mi5iOiB2MS5iLFxcbiAgICAgIHYxLmEgPCAwLjAgPyB2MS5hICogdjIuYTogdjEuYVxcbiAgICAgICk7XFxuICB9XFxuICBgLG5hbWU6dCx0eXBlOmkuRnVuY3Rpb25UeXBlLlZhbHVlQmFzZWR9fWUuZ2xzbEFkZD1zLGUuZ2xzbERpdj11LGUuZ2xzbE11bD1jLGUuZ2xzbFN1Yj1sLGUuZ2xzbEVxdWFsPXAsZS5nbHNsR3JlYXRlcj1mLGUuZ2xzbExlc3M9ZCxlLmdsc2xBbmQ9aCxlLmdsc2xPcj1nLGUuZ2xzbFhvcj1iLGUuZ2xzbFBvdz1tLGUuZ2xzbFBSZWx1PXk7Y29uc3QgXz0odCxlLG4scj1lWzBdLnR5cGUsaSk9Pntjb25zdCBvPXQuc2Vzc2lvbi5wYWNrP2EuVGV4dHVyZVR5cGUucGFja2VkOmEuVGV4dHVyZVR5cGUudW5wYWNrZWQ7cmV0dXJue25hbWU6bi5uYW1lLGlucHV0TmFtZXM6W1wiQVwiLFwiQlwiXSxpbnB1dFR5cGVzOltvLG9dLGNhY2hlSGludDppLGdldDooKT0+dih0LGUsbixyKX19LHY9KHQsZSxuLGk9ZVswXS50eXBlKT0+e2NvbnN0IHM9dC5zZXNzaW9uLnBhY2s/YS5UZXh0dXJlVHlwZS5wYWNrZWQ6YS5UZXh0dXJlVHlwZS51bnBhY2tlZCx1PSFyLlNoYXBlVXRpbC5hcmVFcXVhbChlWzBdLmRpbXMsZVsxXS5kaW1zKTtsZXQgYz1lWzBdLmRpbXM7Y29uc3QgbD10LnNlc3Npb24ucGFjaztpZih1KXtjb25zdCBhPXIuQnJvYWRjYXN0VXRpbC5jYWxjU2hhcGUoZVswXS5kaW1zLGVbMV0uZGltcywhMSk7aWYoIWEpdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgcGVyZm9ybSBiaW5hcnkgb3Agb24gdGhlIGdpdmVuIHRlbnNvcnNcIik7Yz1hO2NvbnN0IHU9Yy5sZW5ndGgscD0wIT09ZVswXS5kaW1zLmxlbmd0aD9lWzBdLmRpbXMubGVuZ3RoOjEsZj0wIT09ZVsxXS5kaW1zLmxlbmd0aD9lWzFdLmRpbXMubGVuZ3RoOjEsZD0wIT09ZVswXS5kaW1zLmxlbmd0aD9cImJjYXN0SW5kaWNlc19BKGluZGljZXMsIGFpbmRpY2VzKTtcIjpcImFpbmRpY2VzWzBdID0gMDtcIixoPTAhPT1lWzFdLmRpbXMubGVuZ3RoP1wiYmNhc3RJbmRpY2VzX0IoaW5kaWNlcywgYmluZGljZXMpO1wiOlwiYmluZGljZXNbMF0gPSAwO1wiLGc9KDAsby5nZXRHbHNsKSh0LnNlc3Npb24uYmFja2VuZC5nbENvbnRleHQudmVyc2lvbiksYj1sP2BcXG4gICAgICAke24uYm9keX1cXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICB2ZWM0IGEgPSBnZXRBQXRPdXRDb29yZHMoKTtcXG4gICAgICAgIHZlYzQgYiA9IGdldEJBdE91dENvb3JkcygpO1xcbiAgICAgICAgdmVjNCByZXN1bHQgPSAke24ubmFtZX0oYSwgYik7XFxuICAgICAgICAke2cub3V0cHV0fSA9IHJlc3VsdDtcXG4gICAgICB9YDpgXFxuICAgICAgJHtuLmJvZHl9XFxuICAgICAgZmxvYXQgcHJvY2VzcyhpbnQgaW5kaWNlc1ske3V9XSkge1xcbiAgICAgICAgaW50IGFpbmRpY2VzWyR7cH1dO1xcbiAgICAgICAgaW50IGJpbmRpY2VzWyR7Zn1dO1xcbiAgICAgICAgJHtkfVxcbiAgICAgICAgJHtofVxcbiAgICAgICAgcmV0dXJuICR7bi5uYW1lfShfQShhaW5kaWNlcyksIF9CKGJpbmRpY2VzKSk7XFxuICAgICAgfWA7cmV0dXJue25hbWU6bi5uYW1lLGlucHV0TmFtZXM6W1wiQVwiLFwiQlwiXSxpbnB1dFR5cGVzOltzLHNdLG91dHB1dDp7ZGltczpjLHR5cGU6aSx0ZXh0dXJlVHlwZTpzfSxzaGFkZXJTb3VyY2U6YixoYXNNYWluOmx9fWNvbnN0IHA9KDAsby5nZXRHbHNsKSh0LnNlc3Npb24uYmFja2VuZC5nbENvbnRleHQudmVyc2lvbiksZj1gXFxuICAgICR7bi5ib2R5fVxcbiAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgdmVjNCB2MSA9ICR7cC50ZXh0dXJlMkR9KEEsIFRleENvb3Jkcyk7XFxuICAgICAgdmVjNCB2MiA9ICR7cC50ZXh0dXJlMkR9KEIsIFRleENvb3Jkcyk7XFxuICAgICAgdmVjNCByZXN1bHQgPSAke24ubmFtZX0odjEsIHYyKTtcXG4gICAgICAke3Aub3V0cHV0fSA9IHJlc3VsdDtcXG4gICAgfVxcbiAgICBgO3JldHVybntuYW1lOm4ubmFtZSxpbnB1dE5hbWVzOltcIkFcIixcIkJcIl0saW5wdXRUeXBlczpbcyxzXSxvdXRwdXQ6e2RpbXM6ZVswXS5kaW1zLHR5cGU6aSx0ZXh0dXJlVHlwZTpzfSxzaGFkZXJTb3VyY2U6ZixoYXNNYWluOiEwfX07ZS5hZGQ9KHQsZSk9Plt0LnJ1bihfKHQsZSxzKCkpLGUpXSxlLmFuZD0odCxlKT0+W3QucnVuKF8odCxlLGgoKSxcImJvb2xcIiksZSldLGUuZGl2PSh0LGUpPT5bdC5ydW4oXyh0LGUsdSgpKSxlKV0sZS5lcXVhbD0odCxlKT0+W3QucnVuKF8odCxlLHAoKSxcImJvb2xcIiksZSldLGUuZ3JlYXRlcj0odCxlKT0+W3QucnVuKF8odCxlLGYoKSxcImJvb2xcIiksZSldLGUubGVzcz0odCxlKT0+W3QucnVuKF8odCxlLGQoKSxcImJvb2xcIiksZSldLGUubXVsPSh0LGUpPT5bdC5ydW4oXyh0LGUsYygpKSxlKV0sZS5vcj0odCxlKT0+W3QucnVuKF8odCxlLGcoKSxcImJvb2xcIiksZSldLGUucG93PSh0LGUpPT5bdC5ydW4oXyh0LGUsbSgpKSxlKV0sZS5wUmVsdT0odCxlKT0+W3QucnVuKF8odCxlLHkoKSksZSldLGUuc3ViPSh0LGUpPT5bdC5ydW4oXyh0LGUsbCgpKSxlKV0sZS54b3I9KHQsZSk9Plt0LnJ1bihfKHQsZSxiKCksXCJib29sXCIpLGUpXX0sNDE5NjoodCxlLG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5wYXJzZUNhc3RBdHRyaWJ1dGVzPWUuY2FzdD12b2lkIDA7Y29uc3Qgcj1uKDI1MTcpO2UuY2FzdD0odCxlLG4pPT4oaShlKSxbdC5jYXN0KGVbMF0sbildKSxlLnBhcnNlQ2FzdEF0dHJpYnV0ZXM9dD0+ci5Qcm90b1V0aWwudGVuc29yRGF0YVR5cGVGcm9tUHJvdG8odC5hdHRyaWJ1dGVzLmdldEludChcInRvXCIpKTtjb25zdCBpPXQ9PntpZighdHx8MSE9PXQubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIkNhc3QgcmVxdWlyZXMgMSBpbnB1dC5cIik7aWYoXCJzdHJpbmdcIj09PXRbMF0udHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGlucHV0IHR5cGUuXCIpfX0sMTE2MzoodCxlLG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5jcmVhdGVQYWNrZWRDb25jYXRQcm9ncmFtSW5mb0xvYWRlcj12b2lkIDA7Y29uc3Qgcj1uKDUwNjApLGk9bigyMDM5KSxvPW4oOTM5MCksYT1uKDI4MjcpO2UuY3JlYXRlUGFja2VkQ29uY2F0UHJvZ3JhbUluZm9Mb2FkZXI9KHQsZSxuKT0+e2NvbnN0IHU9KGM9ZS5sZW5ndGgsbD1uLmNhY2hlS2V5LHtuYW1lOlwiQ29uY2F0IChwYWNrZWQpXCIsaW5wdXROYW1lczpBcnJheS5mcm9tKHtsZW5ndGg6Y30sKCh0LGUpPT5gWCR7ZX1gKSksaW5wdXRUeXBlczpBcnJheShjKS5maWxsKGkuVGV4dHVyZVR5cGUucGFja2VkKSxjYWNoZUhpbnQ6bH0pO3ZhciBjLGw7cmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSx1KSx7Z2V0OigpPT4oKHQsZSxuLHUpPT57Y29uc3QgYz1uWzBdLmRpbXMuc2xpY2UoKTtpZih1Pj1jLmxlbmd0aHx8dTwtMSpjLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJheGlzIHNwZWNpZmllZCBmb3IgY29uY2F0IGRvZXNuJ3QgbWF0Y2ggaW5wdXQgZGltZW5zaW9uYWxpdHlcIik7dTwwJiYodT1jLmxlbmd0aCt1KTtjb25zdCBsPWMuc2xpY2UoMCk7Zm9yKGxldCB0PTE7dDxuLmxlbmd0aDt0Kyspe2NvbnN0IGU9blt0XS5kaW1zLnNsaWNlKCk7Zm9yKGxldCB0PTA7dDxjLmxlbmd0aDt0KyspaWYodD09PXUpbFt1XSs9ZVt0XTtlbHNlIGlmKGNbdF0hPT1lW3RdKXRocm93IG5ldyBFcnJvcihcIm5vbiBjb25jYXQgZGltZW5zaW9ucyBtdXN0IG1hdGNoXCIpfWNvbnN0IHA9bC5sZW5ndGgsZj0oMCxhLmdldENoYW5uZWxzKShcImNvb3Jkc1wiLHApLGQ9KDAsby5nZXRDb29yZHNEYXRhVHlwZSkocCksaD0oMCxhLnVucGFja0Zyb21DaGFubmVsKSgpLGc9bi5tYXAoKHQ9PnQuZGltcykpLGI9KDAsby5nZXRHbENoYW5uZWxzKShwKSxtPW5ldyBBcnJheShnLmxlbmd0aC0xKTttWzBdPWdbMF1bdV07Zm9yKGxldCB0PTE7dDxtLmxlbmd0aDt0KyspbVt0XT1tW3QtMV0rZ1t0XVt1XTtjb25zdCB5PWJbdV0sXz1iLnNsaWNlKC0yKSx2PWIuam9pbigpO2xldCB3PWBpZiAoJHt5fSA8ICR7bVswXX0pIHtcXG4gICAgICAgIHJldHVybiBnZXRDaGFubmVsKFxcbiAgICAgICAgICAgIGdldFgwKCR7dn0pLCB2ZWMyKCR7Xy5qb2luKCl9KSk7XFxuICAgICAgICB9YDtmb3IobGV0IHQ9MTt0PG0ubGVuZ3RoO3QrKyl7Y29uc3QgZT1tW3QtMV07dys9YFxcbiAgICAgICAgICAgIGlmICgke3l9IDwgJHttW3RdfSAgJiYgJHt5fSA+PSAke21bdC0xXX0pIHtcXG4gICAgICAgICAgICAgIHJldHVybiBnZXRDaGFubmVsKFxcbiAgICAgICAgICAgICAgICBnZXRYJHt0fSgke3MoYix5LGUpfSksXFxuICAgICAgICAgICAgICAgIHZlYzIoJHtzKF8seSxlKX0pKTtcXG4gICAgICAgICAgICB9YH1jb25zdCB4PW0ubGVuZ3RoLFQ9bVttLmxlbmd0aC0xXTt3Kz1gXFxuICAgICAgICAgICAgcmV0dXJuIGdldENoYW5uZWwoXFxuICAgICAgICAgICAgICBnZXRYJHt4fSgke3MoYix5LFQpfSksXFxuICAgICAgICAgICAgICB2ZWMyKCR7cyhfLHksVCl9KSk7YDtjb25zdCBTPSgwLHIuZ2V0R2xzbCkodC5zZXNzaW9uLmJhY2tlbmQuZ2xDb250ZXh0LnZlcnNpb24pLE89YFxcbiAgICAgICAgICAke2h9XFxuICAgICAgICAgIGZsb2F0IGdldFZhbHVlKCR7Yi5tYXAoKHQ9PlwiaW50IFwiK3QpKX0pIHtcXG4gICAgICAgICAgICAke3d9XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgICAgICR7ZH0gY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICAgICAgaW50IGxhc3REaW0gPSBjb29yZHMuJHtiW3AtMV19O1xcbiAgICAgICAgICAgIGNvb3Jkcy4ke2JbcC0xXX0gPSBjb29yZHMuJHtiW3AtMl19O1xcbiAgICAgICAgICAgIGNvb3Jkcy4ke2JbcC0yXX0gPSBsYXN0RGltO1xcblxcbiAgICAgICAgICAgIHZlYzQgcmVzdWx0ID0gdmVjNChnZXRWYWx1ZSgke2Z9KSwgMC4sIDAuLCAwLik7XFxuXFxuICAgICAgICAgICAgJHtmW3AtMV19ID0gJHtmW3AtMV19ICsgMTtcXG4gICAgICAgICAgICBpZiAoJHtmW3AtMV19IDwgJHtsW3AtMV19KSB7XFxuICAgICAgICAgICAgICByZXN1bHQuZyA9IGdldFZhbHVlKCR7Zn0pO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAke2ZbcC0yXX0gPSAke2ZbcC0yXX0gKyAxO1xcbiAgICAgICAgICAgIGlmICgke2ZbcC0yXX0gPCAke2xbcC0yXX0pIHtcXG4gICAgICAgICAgICAgIHJlc3VsdC5hID0gZ2V0VmFsdWUoJHtmfSk7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICR7ZltwLTFdfSA9ICR7ZltwLTFdfSAtIDE7XFxuICAgICAgICAgICAgaWYgKCR7ZltwLTJdfSA8ICR7bFtwLTJdfSAmJlxcbiAgICAgICAgICAgICAgICAke2ZbcC0xXX0gPCAke2xbcC0xXX0pIHtcXG4gICAgICAgICAgICAgIHJlc3VsdC5iID0gZ2V0VmFsdWUoJHtmfSk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICR7Uy5vdXRwdXR9ID0gcmVzdWx0O1xcbiAgICAgICAgICB9XFxuICAgICAgICBgO3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sZSkse291dHB1dDp7ZGltczpsLHR5cGU6blswXS50eXBlLHRleHR1cmVUeXBlOmkuVGV4dHVyZVR5cGUucGFja2VkfSxzaGFkZXJTb3VyY2U6TyxoYXNNYWluOiEwfSl9KSh0LHUsZSxuLmF4aXMpfSl9O2NvbnN0IHM9KHQsZSxuKT0+e2NvbnN0IHI9dC5pbmRleE9mKGUpO3JldHVybiB0Lm1hcCgoKHQsZSk9PmU9PT1yP2Ake3R9IC0gJHtufWA6dCkpLmpvaW4oKX19LDIwNjk6KHQsZSxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUucGFyc2VDb25jYXRBdHRyaWJ1dGVzPWUuY29uY2F0PXZvaWQgMDtjb25zdCByPW4oMjQ2KSxpPW4oMjAzOSksbz1uKDExNjMpO2UuY29uY2F0PSh0LGUsbik9PihwKGUpLHQuc2Vzc2lvbi5wYWNrJiZlWzBdLmRpbXMubGVuZ3RoPjE/W3QucnVuKCgwLG8uY3JlYXRlUGFja2VkQ29uY2F0UHJvZ3JhbUluZm9Mb2FkZXIpKHQsZSxuKSxlKV06W3QucnVuKGEodCxlLG4pLGUpXSk7Y29uc3QgYT0odCxlLG4pPT57Y29uc3Qgcj0obz1lLmxlbmd0aCxhPW4uY2FjaGVLZXkse25hbWU6XCJDb25jYXRcIixpbnB1dE5hbWVzOkFycmF5LmZyb20oe2xlbmd0aDpvfSwoKHQsZSk9PmBYJHtlfWApKSxpbnB1dFR5cGVzOkFycmF5KG8pLmZpbGwoaS5UZXh0dXJlVHlwZS51bnBhY2tlZCksY2FjaGVIaW50OmF9KTt2YXIgbyxhO3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30scikse2dldDooKT0+KCh0LGUsbixyKT0+e2NvbnN0IG89blswXS5kaW1zLnNsaWNlKCk7aWYocj49by5sZW5ndGh8fHI8LTEqby5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiYXhpcyBzcGVjaWZpZWQgZm9yIGNvbmNhdCBkb2Vzbid0IG1hdGNoIGlucHV0IGRpbWVuc2lvbmFsaXR5XCIpO3I8MCYmKHI9by5sZW5ndGgrcik7Y29uc3QgYT1vLnNsaWNlKDApO2ZvcihsZXQgdD0xO3Q8bi5sZW5ndGg7dCsrKXtjb25zdCBlPW5bdF0uZGltcy5zbGljZSgpO2ZvcihsZXQgdD0wO3Q8by5sZW5ndGg7dCsrKWlmKHQ9PT1yKWFbcl0rPWVbdF07ZWxzZSBpZihvW3RdIT09ZVt0XSl0aHJvdyBuZXcgRXJyb3IoXCJub24gY29uY2F0IGRpbWVuc2lvbnMgbXVzdCBtYXRjaFwiKX1jb25zdCBwPWEubGVuZ3RoLGY9bmV3IEFycmF5KG4ubGVuZ3RoKTtsZXQgZD0wO2ZvcihsZXQgdD0wO3Q8Zi5sZW5ndGg7Kyt0KWQrPW5bdF0uZGltc1tyXSxmW3RdPWQ7bGV0IGg9XCJcIjtoPW4ubGVuZ3RoPDU/cyhmKTp1KGYpO2NvbnN0IGc9YFxcbiAgICAgICAgJHtjKG4ubGVuZ3RoLHApfVxcbiAgICAgICAgJHtsKGYpfVxcbiAgICAgICAgJHtofVxcbiAgICAgICAgZmxvYXQgcHJvY2VzcyhpbnQgaW5kaWNlc1ske3B9XSkge1xcbiAgICAgICAgICBpbnQgdGV4dHVyZUluZGV4ID0gZ2V0VGV4dHVyZVdoZXJlRGF0YVJlc2lkZXMgKGluZGljZXNbJHtyfV0pO1xcblxcbiAgICAgICAgICBpZih0ZXh0dXJlSW5kZXggIT0gMCkge1xcbiAgICAgICAgICAgIGluZGljZXNbJHtyfV0gPSBpbmRpY2VzWyR7cn1dIC0gaW50KGdldFNpemVJbkNvbmNhdEF4aXNWYWx1ZUZyb21JbmRleCh0ZXh0dXJlSW5kZXgtaW50KDEpKSk7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgcmV0dXJuIGZldGNoRGF0YUZyb21Db3JyZWN0VGV4dHVyZSh0ZXh0dXJlSW5kZXgsIGluZGljZXMpO1xcbiAgICAgICAgfWA7cmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxlKSx7b3V0cHV0OntkaW1zOmEsdHlwZTpuWzBdLnR5cGUsdGV4dHVyZVR5cGU6aS5UZXh0dXJlVHlwZS51bnBhY2tlZH0sc2hhZGVyU291cmNlOmd9KX0pKDAscixlLG4uYXhpcyl9KX0scz10PT5gaW50IGdldFRleHR1cmVXaGVyZURhdGFSZXNpZGVzKGludCBpbmRleCkge1xcbiAgICAgICR7dC5tYXAoKCh0LGUpPT5gaWYoaW5kZXg8JHt0fSkge3JldHVybiAke2V9O31cXG5gKSkuam9pbihcIlwiKX1cXG4gICAgfWAsdT10PT5zKHQpLGM9KHQsZSk9Pntjb25zdCBuPVtgZmxvYXQgZmV0Y2hEYXRhRnJvbUNvcnJlY3RUZXh0dXJlKGludCB0ZXh0dXJlSW5kZXgsIGludCBpbmRpY2VzWyR7ZX1dKSB7YF07Zm9yKGxldCBlPTA7ZTx0OysrZSkwPT09ZT9uLnB1c2goYFxcdGlmICh0ZXh0dXJlSW5kZXggPT0gJHtlfSkgeyByZXR1cm4gX1gke2V9KGluZGljZXMpOyB9YCk6ZT09PXQtMT9uLnB1c2goYFxcdGVsc2UgeyByZXR1cm4gX1gke2V9KGluZGljZXMpOyB9YCk6bi5wdXNoKGBcXHRlbHNlIGlmICh0ZXh0dXJlSW5kZXggPT0gJHtlfSkgeyByZXR1cm4gX1gke2V9KGluZGljZXMpOyB9YCk7cmV0dXJuIG4ucHVzaChcIlxcdH1cIiksbi5qb2luKFwiXFxuXCIpfSxsPXQ9Pntjb25zdCBlPVtcImludCBnZXRTaXplSW5Db25jYXRBeGlzVmFsdWVGcm9tSW5kZXgoaW50IGluZGV4KSB7XCJdO2ZvcihsZXQgbj0wO248dC5sZW5ndGg7KytuKTA9PT1uP2UucHVzaChgXFx0aWYgKGluZGV4ID09ICR7bn0pIHsgcmV0dXJuICR7dFtuXX07IH1gKTpuPT09dC5sZW5ndGgtMT9lLnB1c2goYFxcdGVsc2UgeyByZXR1cm4gJHt0W25dfTsgfWApOmUucHVzaChgXFx0ZWxzZSBpZiAoaW5kZXggPT0gJHtufSkgeyByZXR1cm4gJHt0W25dfTsgfWApO3JldHVybiBlLnB1c2goXCJcXHR9XCIpLGUuam9pbihcIlxcblwiKX07ZS5wYXJzZUNvbmNhdEF0dHJpYnV0ZXM9dD0+KDAsci5jcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkpKHtheGlzOnQuYXR0cmlidXRlcy5nZXRJbnQoXCJheGlzXCIpfSk7Y29uc3QgcD10PT57aWYoIXR8fHQubGVuZ3RoPDEpdGhyb3cgbmV3IEVycm9yKFwidG9vIGZldyBpbnB1dHNcIik7Y29uc3QgZT10WzBdLnR5cGUsbj10WzBdLmRpbXMubGVuZ3RoO2lmKFwic3RyaW5nXCI9PT1lKXRocm93IG5ldyBFcnJvcihcInN0cmluZyB0ZW5zb3IgaXMgbm90IHN1cHBvcnRlZCB5ZXRcIik7Zm9yKGNvbnN0IHIgb2YgdCl7aWYoci50eXBlIT09ZSl0aHJvdyBuZXcgRXJyb3IoXCJpbnB1dCB0ZW5zb3JzIHNob3VsZCBiZSBvbmUgdHlwZVwiKTtpZihyLmRpbXMubGVuZ3RoIT09bil0aHJvdyBuZXcgRXJyb3IoXCJpbnB1dCB0ZW5zb3JzIHNob3VsZCBoYXZlIHRoZSBzYW1lIHNoYXBlXCIpfX19LDQ3NzA6KHQsZSxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUuY3JlYXRlVW5wYWNrZWRHcm91cGVkQ29udlByb2dyYW1JbmZvTG9hZGVyPXZvaWQgMDtjb25zdCByPW4oNjIzMSksaT1uKDUwNjApLG89bigyMDM5KSxhPW4oODEzOCkscz1uKDI4MjMpO2UuY3JlYXRlVW5wYWNrZWRHcm91cGVkQ29udlByb2dyYW1JbmZvTG9hZGVyPSh0LGUsbik9Pntjb25zdCB1PShjPWUubGVuZ3RoPjIsbD1uLmNhY2hlS2V5LHtuYW1lOlwiR3JvdXBlZENvbnZcIixpbnB1dE5hbWVzOmM/W1wiWFwiLFwiV1wiLFwiQmlhc1wiXTpbXCJYXCIsXCJXXCJdLGlucHV0VHlwZXM6Yz9bby5UZXh0dXJlVHlwZS51bnBhY2tlZCxvLlRleHR1cmVUeXBlLnVucGFja2VkLG8uVGV4dHVyZVR5cGUudW5wYWNrZWRdOltvLlRleHR1cmVUeXBlLnVucGFja2VkLG8uVGV4dHVyZVR5cGUudW5wYWNrZWRdLGNhY2hlSGludDpsfSk7dmFyIGMsbDtyZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LHUpLHtnZXQ6KCk9PigodCxlLG4sdSk9Pntjb25zdCBjPWUubGVuZ3RoPjI/XCJ2YWx1ZSArPSBnZXRCaWFzKG91dHB1dF9jaGFubmVsKTtcIjpcIlwiLGw9ZVswXS5kaW1zLnNsaWNlKCkscD1lWzFdLmRpbXMuc2xpY2UoKSxmPXBbMF0vdS5ncm91cDtyLkxvZ2dlci52ZXJib3NlKFwiR3JvdXBlZENvbnZcIixgYXV0cFBhZDoke3UuYXV0b1BhZH0sIGRpbGF0aW9uczoke3UuZGlsYXRpb25zfSwgZ3JvdXA6JHt1Lmdyb3VwfSwga2VybmVsU2hhcGU6JHt1Lmtlcm5lbFNoYXBlfSwgcGFkczoke3UucGFkc30sIHN0cmlkZXM6JHt1LnN0cmlkZXN9YCk7Y29uc3QgZD0oMCxhLmNhbGN1bGF0ZU91dHB1dFNoYXBlKShsLHAsdS5kaWxhdGlvbnMsdS5wYWRzLHUuc3RyaWRlcyksaD0oMCxpLmdldEdsc2wpKHQuc2Vzc2lvbi5iYWNrZW5kLmdsQ29udGV4dC52ZXJzaW9uKSx7YWN0aXZhdGlvbkZ1bmN0aW9uOmcsYXBwbHlBY3RpdmF0aW9uOmJ9PSgwLHMuZ2V0QWN0aXZhdGlvblNuaXBwZXQpKHUpLG09YFxcbiAgY29uc3QgaXZlYzIgc3RyaWRlcyA9IGl2ZWMyKCR7dS5zdHJpZGVzWzBdfSwgJHt1LnN0cmlkZXNbMV19KTtcXG4gIGNvbnN0IGl2ZWMyIHBhZHMgPSBpdmVjMigke3UucGFkc1swXX0sICR7dS5wYWRzWzFdfSk7XFxuICAke2d9XFxuICB2b2lkIG1haW4oKSB7XFxuICAgIGl2ZWM0IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICBpbnQgYmF0Y2ggPSBjb29yZHMueDtcXG4gICAgaW50IG91dHB1dF9jaGFubmVsID0gY29vcmRzLnk7XFxuICAgIGl2ZWMyIHhSQ0Nvcm5lciA9IGNvb3Jkcy56dyAqIHN0cmlkZXMgLSBwYWRzO1xcbiAgICBpbnQgZ3JvdXBfaWQgPSBvdXRwdXRfY2hhbm5lbCAvICR7Zn07XFxuXFxuICAgIGZsb2F0IHZhbHVlID0gMC4wO1xcbiAgICBmb3IgKGludCB3SW5DaGFubmVsID0gMDsgd0luQ2hhbm5lbCA8ICR7cFsxXX07IHdJbkNoYW5uZWwrKykge1xcbiAgICAgIGludCBpbnB1dF9jaGFubmVsID0gZ3JvdXBfaWQgKiAke3BbMV19ICsgd0luQ2hhbm5lbDtcXG4gICAgICBmb3IgKGludCB3SGVpZ2h0ID0gMDsgd0hlaWdodCA8ICR7cFsyXX07IHdIZWlnaHQrKykge1xcbiAgICAgICAgaW50IHhIZWlnaHQgPSB4UkNDb3JuZXIueCArIHdIZWlnaHQgKiAke3UuZGlsYXRpb25zWzBdfTtcXG5cXG4gICAgICAgIGlmICh4SGVpZ2h0IDwgMCB8fCB4SGVpZ2h0ID49ICR7bFsyXX0pIHtcXG4gICAgICAgICAgY29udGludWU7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBmb3IgKGludCB3V2lkdGggPSAwOyB3V2lkdGggPCAke3BbM119OyB3V2lkdGgrKykge1xcbiAgICAgICAgICBpbnQgeFdpZHRoID0geFJDQ29ybmVyLnkgKyB3V2lkdGggKiAke3UuZGlsYXRpb25zWzFdfTtcXG4gICAgICAgICAgaWYgKHhXaWR0aCA8IDAgfHwgeFdpZHRoID49ICR7bFszXX0pIHtcXG4gICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBmbG9hdCB4VmFsID0gZ2V0WChiYXRjaCwgaW5wdXRfY2hhbm5lbCwgeFdpZHRoLCB4SGVpZ2h0KTtcXG4gICAgICAgICAgZmxvYXQgd1ZhbCA9IGdldFcob3V0cHV0X2NoYW5uZWwsIHdJbkNoYW5uZWwsIHdXaWR0aCwgd0hlaWdodCk7XFxuICAgICAgICAgIHZhbHVlICs9IHhWYWwqd1ZhbDtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH1cXG4gICAgJHtjfVxcbiAgICAke2J9XFxuICAgICR7aC5vdXRwdXR9ID0gdmVjNCh2YWx1ZSwgLjAsIC4wLCAuMCk7XFxuICB9XFxuYDtyZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LG4pLHtvdXRwdXQ6e2RpbXM6ZCx0eXBlOmVbMF0udHlwZSx0ZXh0dXJlVHlwZTpvLlRleHR1cmVUeXBlLnVucGFja2VkfSxzaGFkZXJTb3VyY2U6bSxoYXNNYWluOiEwfSl9KSh0LGUsdSxuKX0pfX0sMTM4NjoodCxlLG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5jb252MkRQYWNrZWQ9ZS5jb252MkRQYWNrZWRQb2ludHdpc2U9dm9pZCAwO2NvbnN0IHI9big4MTM4KSxpPW4oODU1NSksbz1uKDcwOCk7ZS5jb252MkRQYWNrZWRQb2ludHdpc2U9KHQsZSxuKT0+e2NvbnN0IGk9ZVswXS5kaW1zLGE9ZVsxXS5kaW1zLHM9KDAsci5jYWxjdWxhdGVPdXRwdXRTaGFwZSkoaSxhLG4uZGlsYXRpb25zLG4ucGFkcyxuLnN0cmlkZXMpLHU9dC5yZXNoYXBlUGFja2VkKGVbMF0sW2lbMV0saVsyXSppWzNdXSksYz10LnJlc2hhcGVQYWNrZWQoZVsxXSxbYVswXSxhWzFdXSksbD1lLmxlbmd0aD4yP1tjLHUsZVsyXV06W2MsdV0scD10LnJ1bigoMCxvLmNyZWF0ZVBhY2tlZE1hdG11bFByb2dyYW1JbmZvTG9hZGVyKSh0LGwsbiksbCk7cmV0dXJuIHQucmVzaGFwZVBhY2tlZChwLHMpfSxlLmNvbnYyRFBhY2tlZD0odCxlLG4pPT57Y29uc3QgYT1lWzBdLmRpbXMscz1lWzFdLmRpbXMsdT0oMCxyLmNhbGN1bGF0ZU91dHB1dFNoYXBlKShhLHMsbi5kaWxhdGlvbnMsbi5wYWRzLG4uc3RyaWRlcyksYz10LnJ1bigoMCxpLmNyZWF0ZVBhY2tlZEltMkNvbFByb2dyYW1JbmZvTG9hZGVyKSh0LGVbMF0sZVsxXSx1LG4pLFtlWzBdXSksbD10LnJlc2hhcGVQYWNrZWQoZVsxXSxbc1swXSxzWzFdKnNbMl0qc1szXV0pLHA9Mz09PWUubGVuZ3RoP1tsLGMsZVsyXV06W2wsY10sZj10LnJ1bigoMCxvLmNyZWF0ZVBhY2tlZE1hdG11bFByb2dyYW1JbmZvTG9hZGVyKSh0LHAsbikscCk7cmV0dXJuIHQucmVzaGFwZVBhY2tlZChmLHUpfX0sOTY2MzoodCxlLG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5wYXJzZUNvbnZUcmFuc3Bvc2VBdHRyaWJ1dGVzPWUuY29udlRyYW5zcG9zZT12b2lkIDA7Y29uc3Qgcj1uKDI0NiksaT1uKDUwNjApLG89bigyMDM5KSxhPW4oMjgyMykscz0odCxlLG4scixpLG8pPT4odC0xKSplK24rKHItMSkqaSsxLW8sdT0odCxlLG4scixpKT0+e2NvbnN0IG89TWF0aC5mbG9vcih0LzIpO1wiU0FNRV9VUFBFUlwiPT09ZT8obltyXT1vLG5baV09dC1vKTpcIlNBTUVfTE9XRVJcIj09PWUmJihuW3JdPXQtbyxuW2ldPW8pfTtlLmNvbnZUcmFuc3Bvc2U9KHQsZSxuKT0+KGYoZSxuKSxjKHQsZSxuKSk7Y29uc3QgYz0odCxlLG4pPT57Y29uc3Qgcj1wKG4sZSk7cmV0dXJuW2wodCxlLHIpXX0sbD0odCxlLG4pPT50LnJ1bigoKHQsZSxuKT0+e2NvbnN0IHI9KHM9ZS5sZW5ndGg+Mix1PW4uY2FjaGVLZXkse25hbWU6XCJDb252VHJhbnNwb3NlXCIsaW5wdXROYW1lczpzP1tcIlhcIixcIldcIixcIkJcIl06W1wiWFwiLFwiV1wiXSxpbnB1dFR5cGVzOnM/W28uVGV4dHVyZVR5cGUudW5wYWNrZWQsby5UZXh0dXJlVHlwZS51bnBhY2tlZCxvLlRleHR1cmVUeXBlLnVucGFja2VkXTpbby5UZXh0dXJlVHlwZS51bnBhY2tlZCxvLlRleHR1cmVUeXBlLnVucGFja2VkXSxjYWNoZUhpbnQ6dX0pO3ZhciBzLHU7cmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxyKSx7Z2V0OigpPT4oKHQsZSxuLHIpPT57Y29uc3Qgcz1lLmxlbmd0aD4yP1wiZ2V0QihvdXRwdXRfY2hhbm5lbClcIjpcIjAuMFwiLHU9ZVswXS5kaW1zLGM9ZVsxXS5kaW1zLGw9Y1sxXSxwPWNbMF0vci5ncm91cCxmPVtlWzBdLmRpbXNbMF0sZVsxXS5kaW1zWzFdKnIuZ3JvdXAsLi4uci5vdXRwdXRTaGFwZV0sZD0oMCxpLmdldEdsc2wpKHQuc2Vzc2lvbi5iYWNrZW5kLmdsQ29udGV4dC52ZXJzaW9uKSx7YWN0aXZhdGlvbkZ1bmN0aW9uOmgsYXBwbHlBY3RpdmF0aW9uOmd9PSgwLGEuZ2V0QWN0aXZhdGlvblNuaXBwZXQpKHIpLGI9YFxcbiAgY29uc3QgaXZlYzIgc3RyaWRlcyA9IGl2ZWMyKCR7ci5zdHJpZGVzWzBdfSwgJHtyLnN0cmlkZXNbMV19KTtcXG4gIGNvbnN0IGl2ZWMyIHBhZHMgPSBpdmVjMigke3IucGFkc1swXX0sICR7ci5wYWRzWzFdfSk7XFxuICAke2h9XFxuICB2b2lkIG1haW4oKSB7XFxuICAgIGl2ZWM0IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICBpbnQgYmF0Y2ggPSBjb29yZHMueDtcXG4gICAgaW50IG91dHB1dF9jaGFubmVsID0gY29vcmRzLnk7XFxuXFxuICAgIGl2ZWMyIGxvYyA9IGNvb3Jkcy56dyArIHBhZHM7XFxuXFxuICAgIGludCBncm91cF9pZCA9IG91dHB1dF9jaGFubmVsIC8gJHtsfTtcXG4gICAgaW50IHdPdXRDaGFubmVsID0gb3V0cHV0X2NoYW5uZWwgLSBncm91cF9pZCAqICR7bH07XFxuXFxuICAgIGZsb2F0IHZhbHVlID0gJHtzfTtcXG4gICAgZm9yIChpbnQgaW5DaGFubmVsT2Zmc2V0ID0gMDsgaW5DaGFubmVsT2Zmc2V0IDwgJHtwfTsgaW5DaGFubmVsT2Zmc2V0KyspIHtcXG4gICAgICBpbnQgaW5wdXRfY2hhbm5lbCA9IGdyb3VwX2lkICogJHtwfSArIGluQ2hhbm5lbE9mZnNldDtcXG4gICAgICBmb3IgKGludCB3V09mZiA9IDA7IHdXT2ZmIDwgJHtjWzJdfTsgd1dPZmYrKykge1xcbiAgICAgICAgZm9yIChpbnQgd0hPZmYgPSAwOyB3SE9mZiA8ICR7Y1szXX07IHdIT2ZmKyspIHtcXG4gICAgICAgICAgaXZlYzIgd09mZiA9IGl2ZWMyKHdXT2ZmICogJHtyLmRpbGF0aW9uc1swXX0sIHdIT2ZmICogJHtyLmRpbGF0aW9uc1sxXX0pO1xcbiAgICAgICAgICBpdmVjMiB3TG9jID0gbG9jIC0gd09mZjtcXG4gICAgICAgICAgaXZlYzIgd0xvY0luID0gd0xvYyAvIHN0cmlkZXM7XFxuICAgICAgICAgIGlmIChcXG4gICAgICAgICAgICB3TG9jSW4gKiBzdHJpZGVzID09IHdMb2MgJiZcXG4gICAgICAgICAgICB3TG9jSW4ueCA+PSAwICYmIHdMb2NJbi54IDwgJHt1WzJdfSAmJlxcbiAgICAgICAgICAgIHdMb2NJbi55ID49IDAgJiYgd0xvY0luLnkgPCAke3VbM119XFxuICAgICAgICAgICkge1xcbiAgICAgICAgICAgIGZsb2F0IHhWYWwgPSBnZXRYKGJhdGNoLCBpbnB1dF9jaGFubmVsLCB3TG9jSW4ueSwgd0xvY0luLngpO1xcbiAgICAgICAgICAgIGZsb2F0IHdWYWwgPSBnZXRXKGlucHV0X2NoYW5uZWwsIHdPdXRDaGFubmVsLCB3SE9mZiwgd1dPZmYpO1xcbiAgICAgICAgICAgIHZhbHVlICs9IHhWYWwgKiB3VmFsO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9XFxuICAgICR7Z31cXG4gICAgJHtkLm91dHB1dH0gPSB2ZWM0KHZhbHVlLCAuMCwgLjAsIC4wKTtcXG4gIH1cXG5gO3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sbikse291dHB1dDp7ZGltczpmLHR5cGU6ZVswXS50eXBlLHRleHR1cmVUeXBlOm8uVGV4dHVyZVR5cGUudW5wYWNrZWR9LHNoYWRlclNvdXJjZTpiLGhhc01haW46ITB9KX0pKHQsZSxyLG4pfSl9KSh0LGUsbiksZSkscD0odCxlKT0+e2NvbnN0IG49dC5rZXJuZWxTaGFwZS5zbGljZSgpO2lmKDA9PT10Lmtlcm5lbFNoYXBlLmxlbmd0aClmb3IobGV0IHQ9Mjt0PGVbMV0uZGltcy5sZW5ndGg7Kyt0KW4ucHVzaChlWzFdLmRpbXNbdF0pO2NvbnN0IHI9dC5wYWRzLnNsaWNlKCksaT10Lm91dHB1dFNoYXBlLnNsaWNlKCk7KCh0LGUsbixyLGksbyxhLGMpPT57Y29uc3QgbD10Lmxlbmd0aC0yLHA9MD09PWMubGVuZ3RoO2ZvcihsZXQgZj0wO2Y8bDsrK2Ype2NvbnN0IGQ9cD90W2YrMl0qb1tmXTpjW2ZdLGg9cyh0W2YrMl0sb1tmXSxpW2ZdLGVbZl0sbltmXSxkKTt1KGgscixpLGYsZitsKSxwJiZjLnB1c2gob1tmXSoodFtmKzJdLTEpK2FbZl0rKGVbZl0tMSkqbltmXSsxLWlbZl0taVtmK2xdKX19KShlWzBdLmRpbXMsbix0LmRpbGF0aW9ucyx0LmF1dG9QYWQscix0LnN0cmlkZXMsdC5vdXRwdXRQYWRkaW5nLGkpO2NvbnN0IG89T2JqZWN0LmFzc2lnbih7fSx0KTtyZXR1cm4gT2JqZWN0LmFzc2lnbihvLHtrZXJuZWxTaGFwZTpuLHBhZHM6cixvdXRwdXRTaGFwZTppLGNhY2hlS2V5OnQuY2FjaGVLZXl9KSxvfTtlLnBhcnNlQ29udlRyYW5zcG9zZUF0dHJpYnV0ZXM9dD0+e2NvbnN0IGU9dC5hdHRyaWJ1dGVzLG49KDAsYS5wYXJzZUludGVybmFsQWN0aXZhdGlvbkF0dHJpYnV0ZXMpKGUpLGk9ZS5nZXRTdHJpbmcoXCJhdXRvX3BhZFwiLFwiTk9UU0VUXCIpLG89ZS5nZXRJbnRzKFwiZGlsYXRpb25zXCIsWzEsMV0pLHM9ZS5nZXRJbnQoXCJncm91cFwiLDEpLHU9ZS5nZXRJbnRzKFwia2VybmVsX3NoYXBlXCIsW10pLGM9ZS5nZXRJbnRzKFwib3V0cHV0X3BhZGRpbmdcIixbMCwwXSksbD1lLmdldEludHMoXCJvdXRwdXRfc2hhcGVcIixbXSkscD1lLmdldEludHMoXCJwYWRzXCIsWzAsMCwwLDBdKSxmPWUuZ2V0SW50cyhcInN0cmlkZXNcIixbMSwxXSk7cmV0dXJuKDAsci5jcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkpKE9iamVjdC5hc3NpZ24oe2F1dG9QYWQ6aSxkaWxhdGlvbnM6byxncm91cDpzLGtlcm5lbFNoYXBlOnUsb3V0cHV0UGFkZGluZzpjLG91dHB1dFNoYXBlOmwscGFkczpwLHN0cmlkZXM6Zn0sbikpfTtjb25zdCBmPSh0LGUpPT57aWYoIXR8fDIhPT10Lmxlbmd0aCYmMyE9PXQubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIkNvbnYgcmVxdWlyZXMgMiBvciAzIGlucHV0c1wiKTtpZig0IT09dFswXS5kaW1zLmxlbmd0aHx8NCE9PXRbMV0uZGltcy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiY3VycmVudGx5IG9ubHkgc3VwcG9ydCAyLWRpbWVuc2lvbmFsIGNvbnZcIik7aWYodFswXS5kaW1zWzFdIT09dFsxXS5kaW1zWzBdKXRocm93IG5ldyBFcnJvcihcIkZJTFRFUl9JTl9DSEFOTkVMIHNob3VsZCBiZSBlcXVhbCB0byBEQVRBX0NIQU5ORUxcIik7Y29uc3Qgbj10WzFdLmRpbXNbMV0qZS5ncm91cDtpZigzPT09dC5sZW5ndGgmJigxIT09dFsyXS5kaW1zLmxlbmd0aHx8dFsyXS5kaW1zWzBdIT09bikpdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBiaWFzXCIpO2NvbnN0IHI9dFswXS5kaW1zLmxlbmd0aC0yO2lmKGUuZGlsYXRpb25zLmxlbmd0aCE9PXIpdGhyb3cgbmV3IEVycm9yKGBkaWxhdGlvbnMgc2hvdWxkIGJlICR7cn1EYCk7aWYoZS5zdHJpZGVzLmxlbmd0aCE9PXIpdGhyb3cgbmV3IEVycm9yKGBzdHJpZGVzIHNob3VsZCBiZSAke3J9RGApO2lmKGUucGFkcy5sZW5ndGghPT0yKnIpdGhyb3cgbmV3IEVycm9yKGBwYWRzIHNob3VsZCBiZSAkezIqcn1EYCk7aWYoZS5vdXRwdXRQYWRkaW5nLmxlbmd0aCE9PXIpdGhyb3cgbmV3IEVycm9yKGBvdXRwdXRfcGFkZGluZyBzaG91bGQgYmUgJHtyfURgKTtpZigwIT09ZS5rZXJuZWxTaGFwZS5sZW5ndGgmJmUua2VybmVsU2hhcGUubGVuZ3RoIT09dFsxXS5kaW1zLmxlbmd0aC0yKXRocm93IG5ldyBFcnJvcihcImludmFsaWQga2VybmVsIHNoYXBlXCIpO2lmKDAhPT1lLm91dHB1dFNoYXBlLmxlbmd0aCYmZS5vdXRwdXRTaGFwZS5sZW5ndGghPT10WzBdLmRpbXMubGVuZ3RoLTIpdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBvdXRwdXQgc2hhcGVcIik7aWYoXCJmbG9hdDMyXCIhPT10WzBdLnR5cGV8fFwiZmxvYXQzMlwiIT09dFsxXS50eXBlKXRocm93IG5ldyBFcnJvcihcIkNvbnZUcmFuc3Bvc2UgaW5wdXQoWCxXKSBzaG91bGQgYmUgZmxvYXQgdGVuc29yXCIpO2lmKDM9PT10Lmxlbmd0aCYmXCJmbG9hdDMyXCIhPT10WzJdLnR5cGUpdGhyb3cgbmV3IEVycm9yKFwiQ29udlRyYW5zcG9zZSBpbnB1dChiaWFzKSBzaG91bGQgYmUgZmxvYXQgdGVuc29yXCIpfX0sODEzODoodCxlLG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5wYXJzZUNvbnZBdHRyaWJ1dGVzPWUuY29udj1lLmNhbGN1bGF0ZU91dHB1dFNoYXBlPXZvaWQgMDtjb25zdCByPW4oMjQ2KSxpPW4oMjUxNyksbz1uKDQ3NzApLGE9bigxMzg2KSxzPW4oOTgyOCksdT1uKDI4MjMpLGM9bigzMjQ4KSxsPW4oNTYyMyk7ZS5jYWxjdWxhdGVPdXRwdXRTaGFwZT0odCxlLG4scixpKT0+e2NvbnN0IG89dFswXSxhPXQuc2xpY2UoMikscz1hLmxlbmd0aCx1PWVbMF0sYz1lLnNsaWNlKDIpLm1hcCgoKHQsZSk9PnQrKHQtMSkqKG5bZV0tMSkpKSxsPWEubWFwKCgodCxlKT0+dCtyW2VdK3JbZStzXSkpLm1hcCgoKHQsZSk9Pk1hdGguZmxvb3IoKHQtY1tlXStpW2VdKS9pW2VdKSkpO3JldHVybltvLHVdLmNvbmNhdCguLi5sKX0sZS5jb252PSh0LGUsbik9PihnKGUsbikscCh0LGUsbikpO2NvbnN0IHA9KHQsZSxuKT0+e2NvbnN0IHI9aChuLGUpLGk9dC5zZXNzaW9uLnBhY2sscz0xPT09ci5rZXJuZWxTaGFwZVswXSYmMT09PXIua2VybmVsU2hhcGVbMV07cmV0dXJuIHIuZ3JvdXA+MT9bdC5ydW4oKDAsby5jcmVhdGVVbnBhY2tlZEdyb3VwZWRDb252UHJvZ3JhbUluZm9Mb2FkZXIpKHQsZSxyKSxlKV06cyYmaT9bZih0LGUscildOmkmJjQ9PT1lWzBdLmRpbXMubGVuZ3RoJiYxPT09ZVswXS5kaW1zWzBdJiYhcz9bKDAsYS5jb252MkRQYWNrZWQpKHQsZSxyKV06W2QodCxlLHIpXX0sZj0odCxuLHIpPT57Y29uc3QgaT1uWzBdLmRpbXMsbz1uWzFdLmRpbXMsYT0oMCxlLmNhbGN1bGF0ZU91dHB1dFNoYXBlKShpLG8sci5kaWxhdGlvbnMsci5wYWRzLHIuc3RyaWRlcykscz10LnJlc2hhcGVVbnBhY2tlZChuWzBdLFtpWzFdLGlbMl0qaVszXV0pLHU9dC5yZXNoYXBlVW5wYWNrZWQoblsxXSxbb1swXSxvWzFdXSksYz1uLmxlbmd0aD4yP1t1LHMsblsyXV06W3Usc10scD10LnJ1bigoMCxsLmNyZWF0ZU1hdG11bFByb2dyYW1JbmZvTG9hZGVyKShjLHIpLGMpO3JldHVybiB0LnJlc2hhcGVVbnBhY2tlZChwLGEpfSxkPSh0LG4scik9Pntjb25zdCBpPW5bMF0uZGltcyxvPW5bMV0uZGltcyxhPSgwLGUuY2FsY3VsYXRlT3V0cHV0U2hhcGUpKGksbyxyLmRpbGF0aW9ucyxyLnBhZHMsci5zdHJpZGVzKSx1PXQucnVuKCgwLGMuY3JlYXRlSW0yQ29sUHJvZ3JhbUluZm9Mb2FkZXIpKHQsblswXSxuWzFdLGEsciksW25bMF1dKSxsPTM9PT1uLmxlbmd0aD9bdSxuWzFdLG5bMl1dOlt1LG5bMV1dO3JldHVybiB0LnJ1bigoMCxzLmNyZWF0ZURvdFByb2R1Y3RQcm9ncmFtSW5mb0xvYWRlcikodCxuLGEsciksbCl9LGg9KHQsZSk9Pntjb25zdCBuPXQua2VybmVsU2hhcGUuc2xpY2UoKTtpZigwPT09dC5rZXJuZWxTaGFwZS5sZW5ndGgpZm9yKGxldCB0PTI7dDxlWzFdLmRpbXMubGVuZ3RoOysrdCluLnB1c2goZVsxXS5kaW1zW3RdKTtjb25zdCByPXQucGFkcy5zbGljZSgpO2kuUG9vbENvbnZVdGlsLmFkanVzdFBhZHNCYXNlZE9uQXV0b1BhZChlWzBdLmRpbXMsdC5zdHJpZGVzLHQuZGlsYXRpb25zLG4scix0LmF1dG9QYWQpO2NvbnN0IG89T2JqZWN0LmFzc2lnbih7fSx0KTtyZXR1cm4gT2JqZWN0LmFzc2lnbihvLHtrZXJuZWxTaGFwZTpuLHBhZHM6cixjYWNoZUtleTp0LmNhY2hlS2V5fSksb307ZS5wYXJzZUNvbnZBdHRyaWJ1dGVzPXQ9Pntjb25zdCBlPXQuYXR0cmlidXRlcyxuPSgwLHUucGFyc2VJbnRlcm5hbEFjdGl2YXRpb25BdHRyaWJ1dGVzKShlKSxpPWUuZ2V0U3RyaW5nKFwiYXV0b19wYWRcIixcIk5PVFNFVFwiKSxvPWUuZ2V0SW50cyhcImRpbGF0aW9uc1wiLFsxLDFdKSxhPWUuZ2V0SW50KFwiZ3JvdXBcIiwxKSxzPWUuZ2V0SW50cyhcImtlcm5lbF9zaGFwZVwiLFtdKSxjPWUuZ2V0SW50cyhcInBhZHNcIixbMCwwLDAsMF0pLGw9ZS5nZXRJbnRzKFwic3RyaWRlc1wiLFsxLDFdKTtyZXR1cm4oMCxyLmNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSkoT2JqZWN0LmFzc2lnbih7YXV0b1BhZDppLGRpbGF0aW9uczpvLGdyb3VwOmEsa2VybmVsU2hhcGU6cyxwYWRzOmMsc3RyaWRlczpsfSxuKSl9O2NvbnN0IGc9KHQsZSk9PntpZighdHx8MiE9PXQubGVuZ3RoJiYzIT09dC5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiQ29udiByZXF1aXJlcyAyIG9yIDMgaW5wdXRzXCIpO2lmKDQhPT10WzBdLmRpbXMubGVuZ3RofHw0IT09dFsxXS5kaW1zLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJjdXJyZW50bHkgb25seSBzdXBwb3J0IDItZGltZW5zaW9uYWwgY29udlwiKTtpZih0WzBdLmRpbXNbMV0hPT10WzFdLmRpbXNbMV0qZS5ncm91cCl0aHJvdyBuZXcgRXJyb3IoXCJGSUxURVJfSU5fQ0hBTk5FTCBzaG91bGQgYmUgZXF1YWwgdG8gREFUQV9DSEFOTkVMXCIpO2lmKDM9PT10Lmxlbmd0aCYmKDEhPT10WzJdLmRpbXMubGVuZ3RofHx0WzFdLmRpbXNbMF0hPT10WzJdLmRpbXNbMF0pKXRocm93IG5ldyBFcnJvcihcImludmFsaWQgYmlhc1wiKTtjb25zdCBuPXRbMF0uZGltcy5sZW5ndGgtMjtpZihlLmRpbGF0aW9ucy5sZW5ndGghPT1uKXRocm93IG5ldyBFcnJvcihgZGlsYXRpb25zIHNob3VsZCBiZSAke259RGApO2lmKGUuc3RyaWRlcy5sZW5ndGghPT1uKXRocm93IG5ldyBFcnJvcihgc3RyaWRlcyBzaG91bGQgYmUgJHtufURgKTtpZihlLnBhZHMubGVuZ3RoIT09MipuKXRocm93IG5ldyBFcnJvcihgcGFkcyBzaG91bGQgYmUgJHsyKm59RGApO2lmKDAhPT1lLmtlcm5lbFNoYXBlLmxlbmd0aCYmZS5rZXJuZWxTaGFwZS5sZW5ndGghPT10WzFdLmRpbXMubGVuZ3RoLTIpdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBrZXJuZWwgc2hhcGVcIik7aWYoXCJmbG9hdDMyXCIhPT10WzBdLnR5cGV8fFwiZmxvYXQzMlwiIT09dFsxXS50eXBlKXRocm93IG5ldyBFcnJvcihcIkNvbnYgaW5wdXQoWCxXKSBzaG91bGQgYmUgZmxvYXQgdGVuc29yXCIpO2lmKDM9PT10Lmxlbmd0aCYmXCJmbG9hdDMyXCIhPT10WzJdLnR5cGUpdGhyb3cgbmV3IEVycm9yKFwiQ29udiBpbnB1dChiaWFzKSBzaG91bGQgYmUgZmxvYXQgdGVuc29yXCIpfX0sNTE5MzoodCxlLG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5wYXJzZURlcHRoVG9TcGFjZUF0dHJpYnV0ZXM9ZS5kZXB0aFRvU3BhY2U9dm9pZCAwO2NvbnN0IHI9bigzNzM4KTtlLmRlcHRoVG9TcGFjZT0odCxlLG4pPT57aShlKTtjb25zdCBvPW4uYmxvY2tzaXplLGE9bypvLHM9XCJEQ1JcIj09PW4ubW9kZT9bMCwzLDQsMSw1LDJdOlswLDEsNCwyLDUsM10sdT1cIkRDUlwiPT09bi5tb2RlP1tlWzBdLmRpbXNbMF0sbyxvLGVbMF0uZGltc1sxXS9hLGVbMF0uZGltc1syXSxlWzBdLmRpbXNbM11dOltlWzBdLmRpbXNbMF0sZVswXS5kaW1zWzFdL2EsbyxvLGVbMF0uZGltc1syXSxlWzBdLmRpbXNbM11dLGM9dC5yZXNoYXBlVW5wYWNrZWQoZVswXSx1KSxsPXtwZXJtOnMsY2FjaGVLZXk6YCR7c31gfSxbcF09KDAsci50cmFuc3Bvc2UpKHQsW2NdLGwpLGY9W2VbMF0uZGltc1swXSxlWzBdLmRpbXNbMV0vYSxlWzBdLmRpbXNbMl0qbyxlWzBdLmRpbXNbM10qb107cmV0dXJuW3QucmVzaGFwZVVucGFja2VkKHAsZildfSxlLnBhcnNlRGVwdGhUb1NwYWNlQXR0cmlidXRlcz10PT57Y29uc3QgZT10LmF0dHJpYnV0ZXMuZ2V0SW50KFwiYmxvY2tzaXplXCIpO2lmKGU8MSl0aHJvdyBuZXcgRXJyb3IoYGJsb2Nrc2l6ZSBtdXN0IGJlID49IDEsIGJ1dCBnb3QgOiAke2V9IGZvciBEZXB0aFRvU3BhY2VgKTtjb25zdCBuPXQuYXR0cmlidXRlcy5nZXRTdHJpbmcoXCJtb2RlXCIsXCJEQ1JcIik7aWYoXCJEQ1JcIiE9PW4mJlwiQ1JEXCIhPT1uKXRocm93IG5ldyBFcnJvcihgdW5yZWNvZ25pemVkIG1vZGU6ICR7bn0gZm9yIERlcHRoVG9TcGFjZWApO3JldHVybnttb2RlOm4sYmxvY2tzaXplOmV9fTtjb25zdCBpPXQ9PntpZigxIT09dC5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKGBEZXB0aFRvU3BhY2UgZXhwZWN0IDEgaW5wdXRzLCBidXQgZ290ICR7dC5sZW5ndGh9YCk7aWYoXCJzdHJpbmdcIj09PXRbMF0udHlwZXx8NCE9PXRbMF0uZGltcy5sZW5ndGgpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkRlcHRoVG9TcGFjZSBpbnB1dCBzaG91bGQgYmUgYSA0LUQgbnVtZXJpYyB0ZW5zb3JcIil9fSw5ODI4Oih0LGUsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLmNyZWF0ZURvdFByb2R1Y3RQcm9ncmFtSW5mb0xvYWRlcj12b2lkIDA7Y29uc3Qgcj1uKDI1MTcpLGk9big1MDYwKSxvPW4oMjAzOSksYT1uKDI4MjMpLHM9bigzMjQ4KTtlLmNyZWF0ZURvdFByb2R1Y3RQcm9ncmFtSW5mb0xvYWRlcj0odCxlLG4sdSk9Pntjb25zdCBjPSgodCxlKT0+KHtuYW1lOlwiQ29udkRvdFByb2R1Y3RcIixpbnB1dE5hbWVzOnQ/W1wiSW0yQ29sXCIsXCJLXCIsXCJCXCJdOltcIkltMkNvbFwiLFwiS1wiXSxpbnB1dFR5cGVzOnQ/W28uVGV4dHVyZVR5cGUudW5wYWNrZWQsby5UZXh0dXJlVHlwZS5wYWNrZWRMYXN0RGltZW5zaW9uLG8uVGV4dHVyZVR5cGUudW5wYWNrZWRdOltvLlRleHR1cmVUeXBlLnVucGFja2VkLG8uVGV4dHVyZVR5cGUucGFja2VkTGFzdERpbWVuc2lvbl0sY2FjaGVLZXk6ZS5hY3RpdmF0aW9uQ2FjaGVLZXl9KSkoZS5sZW5ndGg+Mix1KTtyZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LGMpLHtnZXQ6KCk9PigodCxlLG4sdSxjKT0+e2NvbnN0IGw9blswXS5kaW1zLHA9blsxXS5kaW1zLGY9W3BbMF0sTWF0aC5jZWlsKGxbMV0qcFsyXSpwWzNdLzQpXSxkPSgwLHMuY2FsY3VsYXRlSW0yQ29sRGltcykobCxwLHUpLFtoLGddPXQuY2FsY3VsYXRlVGV4dHVyZVdpZHRoQW5kSGVpZ2h0KGYsby5UZXh0dXJlVHlwZS5wYWNrZWRMYXN0RGltZW5zaW9uKSxiPXIuU2hhcGVVdGlsLmNvbXB1dGVTdHJpZGVzKGQpLFttLHldPXQuY2FsY3VsYXRlVGV4dHVyZVdpZHRoQW5kSGVpZ2h0KGQsby5UZXh0dXJlVHlwZS5wYWNrZWRMYXN0RGltZW5zaW9uKSxfPXUubGVuZ3RoLHY9bi5sZW5ndGg8Mz9cIjAuMFwiOlwiX0IoYilcIix3PU1hdGguY2VpbChsWzFdKnBbMl0qcFszXS80KSx7YWN0aXZhdGlvbkZ1bmN0aW9uOngsYXBwbHlBY3RpdmF0aW9uOlR9PSgwLGEuZ2V0QWN0aXZhdGlvblNuaXBwZXQpKGMpLFM9KDAsaS5nZXRHbHNsKSh0LnNlc3Npb24uYmFja2VuZC5nbENvbnRleHQudmVyc2lvbiksTz1gXFxuJHt4fVxcbmZsb2F0IHByb2Nlc3MoaW50IGluZGljZXNbJHtffV0pIHtcXG4gIGludCBiWzFdO1xcbiAgYlswXSA9IGluZGljZXNbMV07XFxuICBpbnQgaW0yY29sWzRdO1xcbiAgaW0yY29sWzBdID0gaW5kaWNlc1swXTtcXG4gIGltMmNvbFsxXSA9IGluZGljZXNbMl07XFxuICBpbTJjb2xbMl0gPSBpbmRpY2VzWzNdO1xcbiAgaW50IGltMmNvbE9mZnNldCA9IGltMmNvbFswXSAqICR7YlswXX0gKyBpbTJjb2xbMV0gKiAke2JbMV19ICsgaW0yY29sWzJdICogJHtiWzJdfTtcXG4gIGludCBrZXJuZWxPZmZzZXQgPSBpbmRpY2VzWzFdICogJHtmWzFdfTtcXG4gIGZsb2F0IHZhbHVlID0gJHt2fTtcXG4gIGZvciAoaW50IGkgPSAwOyBpIDwgJHt3fTsgKytpKSB7XFxuICAgIHZlYzIgaW0yY29sQ29vcmRzID0gb2Zmc2V0VG9Db29yZHMoaW0yY29sT2Zmc2V0LCAke219LCAke3l9KTtcXG4gICAgdmVjMiBrZXJuZWxDb29yZHMgPSBvZmZzZXRUb0Nvb3JkcyhrZXJuZWxPZmZzZXQsICR7aH0sICR7Z30pO1xcbiAgICB2YWx1ZSArPSBkb3QoJHtTLnRleHR1cmUyRH0oSW0yQ29sLCBpbTJjb2xDb29yZHMpLCAke1MudGV4dHVyZTJEfShLLCBrZXJuZWxDb29yZHMpKTtcXG4gICAgKytpbTJjb2xPZmZzZXQ7XFxuICAgICsra2VybmVsT2Zmc2V0O1xcbiAgfVxcbiAgJHtUfVxcbiAgcmV0dXJuIHZhbHVlO1xcbn1gO3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sZSkse291dHB1dDp7ZGltczp1LHR5cGU6blswXS50eXBlLHRleHR1cmVUeXBlOm8uVGV4dHVyZVR5cGUudW5wYWNrZWR9LHNoYWRlclNvdXJjZTpPfSl9KSh0LGMsZSxuLHUpfSl9fSw3OTkyOih0LGUsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLnBhcnNlRmxhdHRlbkF0dHJpYnV0ZXM9ZS5mbGF0dGVuPXZvaWQgMDtjb25zdCByPW4oMjUxNyk7ZS5mbGF0dGVuPSh0LGUsbik9PntpKGUsbik7Y29uc3Qgbz1yLlNoYXBlVXRpbC5mbGF0dGVuU2hhcGUoZVswXS5kaW1zLG4pO3JldHVyblt0LnJlc2hhcGVVbnBhY2tlZChlWzBdLG8pXX0sZS5wYXJzZUZsYXR0ZW5BdHRyaWJ1dGVzPXQ9PnQuYXR0cmlidXRlcy5nZXRJbnQoXCJheGlzXCIsMSk7Y29uc3QgaT0odCxlKT0+e2lmKCF0fHwxIT09dC5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiRmxhdHRlbiByZXF1aXJlcyAxIGlucHV0LlwiKTtjb25zdCBuPXRbMF0uZGltcy5sZW5ndGg7aWYoMD09PW4pdGhyb3cgbmV3IEVycm9yKFwic2NhbGFyIHRlbnNvciBpcyBub3Qgc3VwcG9ydGVkLlwiKTtpZihlPC1ufHxlPm4pdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBheGlzXCIpO2lmKFwic3RyaW5nXCI9PT10WzBdLnR5cGUpdGhyb3cgbmV3IEVycm9yKFwic3RyaW5nIHRlbnNvciBpcyBub3Qgc3VwcG9ydGVkLlwiKX19LDI4MjM6KHQsZSxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUucGFyc2VJbnRlcm5hbEFjdGl2YXRpb25BdHRyaWJ1dGVzPWUuZ2V0QWN0aXZhdGlvblNuaXBwZXQ9dm9pZCAwO2NvbnN0IHI9bigyNTE3KSxpPW4oNDkwOSk7ZS5nZXRBY3RpdmF0aW9uU25pcHBldD1mdW5jdGlvbih0KXtsZXQgZTtzd2l0Y2godC5hY3RpdmF0aW9uKXtjYXNlXCJSZWx1XCI6ZT0oMCxpLmdsc2xSZWx1KSgpO2JyZWFrO2Nhc2VcIlNpZ21vaWRcIjplPSgwLGkuZ2xzbFNpZ21vaWQpKCk7YnJlYWs7Y2FzZVwiQ2xpcFwiOmU9KDAsaS5nbHNsQ2xpcCkodC5jbGlwTWluLHQuY2xpcE1heCk7YnJlYWs7ZGVmYXVsdDpyZXR1cm57YWN0aXZhdGlvbkZ1bmN0aW9uOlwiXCIsYXBwbHlBY3RpdmF0aW9uOlwiXCJ9fWNvbnN0IG49ZS5uYW1lO3JldHVybnthY3RpdmF0aW9uRnVuY3Rpb246ZS5ib2R5LGFwcGx5QWN0aXZhdGlvbjpgdmFsdWUgPSAke259Xyh2YWx1ZSk7YH19LGUucGFyc2VJbnRlcm5hbEFjdGl2YXRpb25BdHRyaWJ1dGVzPXQ9Pntjb25zdCBlPXQuZ2V0U3RyaW5nKFwiYWN0aXZhdGlvblwiLFwiXCIpO2lmKFwiQ2xpcFwiPT09ZSl7Y29uc3RbbixpXT10LmdldEZsb2F0cyhcImFjdGl2YXRpb25fcGFyYW1zXCIsW3IuTUlOX0NMSVAsci5NQVhfQ0xJUF0pO3JldHVybnthY3RpdmF0aW9uOmUsY2xpcE1heDppLGNsaXBNaW46bixhY3RpdmF0aW9uQ2FjaGVLZXk6YCR7ZX06JHtufSwke2l9YH19cmV0dXJue2FjdGl2YXRpb246ZSxhY3RpdmF0aW9uQ2FjaGVLZXk6ZX19fSwxMjUzOih0LGUsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLnBhcnNlR2F0aGVyQXR0cmlidXRlcz1lLmdhdGhlcj12b2lkIDA7Y29uc3Qgcj1uKDI0NiksaT1uKDc4Miksbz1uKDI1MTcpLGE9bigyMDM5KTtlLmdhdGhlcj0odCxlLG4pPT4oYyhlLG4uYXhpcyksW3QucnVuKHUodCxlLG4pLGUpXSksZS5wYXJzZUdhdGhlckF0dHJpYnV0ZXM9dD0+KDAsci5jcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkpKHtheGlzOnQuYXR0cmlidXRlcy5nZXRJbnQoXCJheGlzXCIsMCl9KTtjb25zdCBzPXtuYW1lOlwiR2F0aGVyXCIsaW5wdXROYW1lczpbXCJBXCIsXCJCXCJdLGlucHV0VHlwZXM6W2EuVGV4dHVyZVR5cGUudW5wYWNrZWQsYS5UZXh0dXJlVHlwZS51bnBhY2tlZF19LHU9KHQsZSxuKT0+e2NvbnN0IHI9T2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LHMpLHtjYWNoZUhpbnQ6bi5jYWNoZUtleX0pO3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30scikse2dldDooKT0+KCh0LGUsbixyKT0+e2NvbnN0IGk9blswXS5kaW1zLnNsaWNlKCkscz1uWzFdLmRpbXMuc2xpY2UoKSx1PW5ldyBBcnJheShpLmxlbmd0aCtzLmxlbmd0aC0xKTtyPW8uU2hhcGVVdGlsLm5vcm1hbGl6ZUF4aXMocixpLmxlbmd0aCk7Y29uc3QgYz1bXTtmb3IobGV0IHQ9MDt0PHUubGVuZ3RoO3QrKyl0PHI/KHVbdF09aVt0XSxjLnB1c2goYGlucHV0SWR4WyR7dH1dID0gb3V0cHV0SWR4WyR7dH1dO2ApKTp0PHIrcy5sZW5ndGg/KHVbdF09c1t0LXJdLGMucHVzaChgaW5kZXhEYXRhSWR4WyR7dC1yfV0gPSBvdXRwdXRJZHhbJHt0fV07YCkpOih1W3RdPWlbdC1zLmxlbmd0aCsxXSxjLnB1c2goYGlucHV0SWR4WyR7dC1zLmxlbmd0aCsxfV0gPSBvdXRwdXRJZHhbJHt0fV07YCkpO2NvbnN0IGw9YFxcbiAgICAgIGZsb2F0IHByb2Nlc3MoaW50IG91dHB1dElkeFske3UubGVuZ3RofHwxfV0pIHtcXG4gICAgICAgIGludCBpbnB1dElkeFske2kubGVuZ3RofV07XFxuICAgICAgICBpbnQgaW5kZXhEYXRhSWR4WyR7cy5sZW5ndGh8fDF9XTtcXG4gICAgICAgIGluZGV4RGF0YUlkeFswXSA9IDA7XFxuICAgICAgICAke2Muam9pbihcIlxcbiAgICAgICAgXCIpfVxcbiAgICAgICAgaW50IGlkeCA9IGludChfQihpbmRleERhdGFJZHgpKTtcXG4gICAgICAgIGlucHV0SWR4WyR7cn1dID0gaWR4IDwgMCA/IGlkeCArICR7aVtyXX0gOiBpZHg7XFxuICAgICAgICByZXR1cm4gX0EoaW5wdXRJZHgpO1xcbiAgICAgIH1gO3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sZSkse291dHB1dDp7ZGltczp1LHR5cGU6blswXS50eXBlLHRleHR1cmVUeXBlOmEuVGV4dHVyZVR5cGUudW5wYWNrZWR9LHNoYWRlclNvdXJjZTpsfSl9KSgwLHIsZSxuLmF4aXMpfSl9LGM9KHQsZSk9PntpZighdHx8MiE9PXQubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIkdhdGhlciByZXF1aXJlcyAyIGlucHV0cy5cIik7Y29uc3Qgbj10WzBdLmRpbXMubGVuZ3RoO2lmKG48MSl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGlucHV0IHNoYXBlLlwiKTtpZihlPC1ufHxlPm4tMSl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGF4aXMuXCIpO2lmKC0xPT09aS5OVU1CRVJfVFlQRVMuaW5kZXhPZih0WzBdLnR5cGUpKXRocm93IG5ldyBFcnJvcihcIkludmFpZCBpbnB1dCB0eXBlLlwiKTtpZihcImludDMyXCIhPT10WzFdLnR5cGUmJlwiaW50MTZcIiE9PXRbMV0udHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhaWQgaW5wdXQgdHlwZS5cIil9fSw0Nzc2Oih0LGUsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLnBhcnNlR2VtbUF0dHJpYnV0ZXNWMTE9ZS5wYXJzZUdlbW1BdHRyaWJ1dGVzVjc9ZS5nZW1tPXZvaWQgMDtjb25zdCByPW4oMjQ2KSxpPW4oMjUxNyksbz1uKDIwMzkpO2UuZ2VtbT0odCxlLG4pPT4oYyhlLG4pLFt0LnJ1bihzKGUsbiksZSldKTtjb25zdCBhPSh0LGUpPT57Y29uc3Qgbj0wIT09dC5hdHRyaWJ1dGVzLmdldEludChcInRyYW5zQVwiLDApLGk9MCE9PXQuYXR0cmlidXRlcy5nZXRJbnQoXCJ0cmFuc0JcIiwwKSxvPXQuYXR0cmlidXRlcy5nZXRGbG9hdChcImFscGhhXCIsMSksYT10LmF0dHJpYnV0ZXMuZ2V0RmxvYXQoXCJiZXRhXCIsMSk7cmV0dXJuKDAsci5jcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkpKHt0cmFuc0E6bix0cmFuc0I6aSxhbHBoYTpvLGJldGE6YSxpc09wdGlvbmFsQzplfSl9O2UucGFyc2VHZW1tQXR0cmlidXRlc1Y3PXQ9PmEodCwhMSksZS5wYXJzZUdlbW1BdHRyaWJ1dGVzVjExPXQ9PmEodCwhMCk7Y29uc3Qgcz0odCxlKT0+e2NvbnN0IG49e25hbWU6XCJHZW1tXCIsaW5wdXROYW1lczozPT09dC5sZW5ndGg/W1wiQVwiLFwiQlwiLFwiQ1wiXTpbXCJBXCIsXCJCXCJdLGlucHV0VHlwZXM6Mz09PXQubGVuZ3RoP1tvLlRleHR1cmVUeXBlLnVucGFja2VkLG8uVGV4dHVyZVR5cGUudW5wYWNrZWQsby5UZXh0dXJlVHlwZS51bnBhY2tlZF06W28uVGV4dHVyZVR5cGUudW5wYWNrZWQsby5UZXh0dXJlVHlwZS51bnBhY2tlZF0sa2V5OmUuY2FjaGVLZXl9O3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sbikse2dldDooKT0+dShuLHQsZSl9KX0sdT0odCxlLG4pPT57Y29uc3Qgcj1lWzBdLmRpbXMuc2xpY2UoKSxhPWVbMV0uZGltcy5zbGljZSgpLFtzLHVdPWkuR2VtbVV0aWwuZ2V0U2hhcGVPZkdlbW1SZXN1bHQocixuLnRyYW5zQSxhLG4udHJhbnNCLDM9PT1lLmxlbmd0aD9lWzJdLmRpbXM6dm9pZCAwKSxjPVtzLHVdO2lmKCFjKXRocm93IG5ldyBFcnJvcihcIkNhbid0IHVzZSBnZW1tIG9uIHRoZSBnaXZlbiB0ZW5zb3JzXCIpO2xldCBsPXJbci5sZW5ndGgtMV0scD1cIlwiO24udHJhbnNBJiYobD1yWzBdKSxuLnRyYW5zQSYmbi50cmFuc0I/cD1cInZhbHVlICs9IF9BX1QoYSkgKiBfQl9UKGIpO1wiOm4udHJhbnNBJiYhbi50cmFuc0I/cD1cInZhbHVlICs9IF9BX1QoYSkgKiBfQihiKTtcIjohbi50cmFuc0EmJm4udHJhbnNCP3A9XCJ2YWx1ZSArPSBfQShhKSAqIF9CX1QoYik7XCI6bi50cmFuc0F8fG4udHJhbnNCfHwocD1cInZhbHVlICs9IF9BKGEpICogX0IoYik7XCIpO2NvbnN0IGY9Yy5sZW5ndGgsZD1gXFxuICAgICAgZmxvYXQgcHJvY2VzcyhpbnQgaW5kaWNlc1ske2Z9XSkge1xcbiAgICAgICAgICBpbnQgYVske2Z9XTtcXG4gICAgICAgICAgaW50IGJbJHtmfV07XFxuICAgICAgICAgICR7Mz09PWUubGVuZ3RoP2BpbnQgY1ske2VbMl0uZGltcy5sZW5ndGh9XTtgOlwiXCJ9XFxuXFxuICAgICAgICAgIGNvcHlWZWMoaW5kaWNlcywgYSk7XFxuICAgICAgICAgIGNvcHlWZWMoaW5kaWNlcywgYik7XFxuICAgICAgICAgICR7Mz09PWUubGVuZ3RoP1wiYmNhc3RJbmRpY2VzX0MoaW5kaWNlcywgYyk7XCI6XCJcIn1cXG5cXG4gICAgICAgICAgZmxvYXQgdmFsdWUgPSAwLjA7XFxuICAgICAgICAgIGZvciAoaW50IGs9MDsgazwke2x9OyArK2spIHtcXG4gICAgICAgICAgICAgIGFbJHtmLTF9XSA9IGs7XFxuICAgICAgICAgICAgICBiWyR7Zi0yfV0gPSBrO1xcbiAgICAgICAgICAgICAgJHtwfVxcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIHZhbHVlID0gdmFsdWUgKiBhbHBoYTtcXG4gICAgICAgICAgJHszPT09ZS5sZW5ndGg/XCJ2YWx1ZSArPSBiZXRhICogX0MoYyk7XCI6XCJcIn1cXG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xcbiAgICAgIH1gO3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sdCkse291dHB1dDp7ZGltczpjLHR5cGU6ZVswXS50eXBlLHRleHR1cmVUeXBlOm8uVGV4dHVyZVR5cGUudW5wYWNrZWR9LHZhcmlhYmxlczpbe25hbWU6XCJhbHBoYVwiLHR5cGU6XCJmbG9hdFwiLGRhdGE6bi5hbHBoYX0se25hbWU6XCJiZXRhXCIsdHlwZTpcImZsb2F0XCIsZGF0YTpuLmJldGF9XSxzaGFkZXJTb3VyY2U6ZH0pfSxjPSh0LGUpPT57aWYoIXQpdGhyb3cgbmV3IEVycm9yKFwiSW5wdXQgaXMgbWlzc2luZ1wiKTtpZihlLmlzT3B0aW9uYWxDJiYodC5sZW5ndGg8Mnx8dC5sZW5ndGg+MykpdGhyb3cgbmV3IEVycm9yKFwiSW52YWlkIGlucHV0IHNoYXBlLlwiKTtpZighZS5pc09wdGlvbmFsQyYmMyE9PXQubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIkdlbW0gcmVxdWlyZXMgMyBpbnB1dHNcIik7aWYoMz09PXQubGVuZ3RoJiYxIT09dFsyXS5kaW1zLmxlbmd0aCYmMiE9PXRbMl0uZGltcy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpbnB1dCBzaGFwZSBvZiBDXCIpO2lmKFwiZmxvYXQzMlwiIT09dFswXS50eXBlJiZcImZsb2F0NjRcIiE9PXRbMF0udHlwZXx8XCJmbG9hdDMyXCIhPT10WzFdLnR5cGUmJlwiZmxvYXQ2NFwiIT09dFsxXS50eXBlfHwzPT09dC5sZW5ndGgmJlwiZmxvYXQzMlwiIT09dFsyXS50eXBlJiZcImZsb2F0NjRcIiE9PXRbMl0udHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGlucHV0IHR5cGUuXCIpO2lmKHRbMF0udHlwZSE9PXRbMV0udHlwZXx8Mz09PXQubGVuZ3RoJiZ0WzBdLnR5cGUhPT10WzJdLnR5cGUpdGhyb3cgbmV3IEVycm9yKFwiSW5wdXQgdHlwZXMgYXJlIG1pc21hdGNoZWRcIil9fSw4NTU1Oih0LGUsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLmNyZWF0ZVBhY2tlZEltMkNvbFByb2dyYW1JbmZvTG9hZGVyPXZvaWQgMDtjb25zdCByPW4oNTA2MCksaT1uKDIwMzkpLG89bigyODI3KTtlLmNyZWF0ZVBhY2tlZEltMkNvbFByb2dyYW1JbmZvTG9hZGVyPSh0LGUsbixhLHMpPT57Y29uc3QgdT0oYz1zLmNhY2hlS2V5LHtuYW1lOlwiSW0yQ29sIChwYWNrZWQpXCIsaW5wdXROYW1lczpbXCJBXCJdLGlucHV0VHlwZXM6W2kuVGV4dHVyZVR5cGUucGFja2VkXSxjYWNoZUhpbnQ6Y30pO3ZhciBjO3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sdSkse2dldDooKT0+KCh0LGUsbixhLHMsdSk9Pntjb25zdCBjPW4uZGltcyxsPWEuZGltcyxwPXMubGVuZ3RoLGY9W2xbMV0qbFsyXSpsWzNdLHNbMl0qc1szXV0sZD1sWzJdKmxbM10saD0oMCxvLnVucGFja0Zyb21DaGFubmVsKSgpLGc9KDAsci5nZXRHbHNsKSh0LnNlc3Npb24uYmFja2VuZC5nbENvbnRleHQudmVyc2lvbik7bGV0IGI9XCJcIjtmb3IobGV0IHQ9MDt0PD0xO3QrKylmb3IobGV0IGU9MDtlPD0xO2UrKyliKz1gXFxuICAgICAgICAgICAgYmxvY2tJbmRleCA9IHJjLnggKyAke2V9O1xcbiAgICAgICAgICAgIHBvcyA9IHJjLnkgKyAke3R9O1xcblxcbiAgICAgICAgICAgIGlmKGJsb2NrSW5kZXggPCAke2ZbMV19ICYmIHBvcyA8ICR7ZlswXX0pIHtcXG4gICAgICAgICAgICAgIG9mZnNldFkgPSBpbnQoYmxvY2tJbmRleCAvICgke3NbcC0xXX0pKSAqICR7dS5zdHJpZGVzWzBdfSAtXFxuICAgICAgICAgICAgICAgICR7dS5wYWRzWzBdfTtcXG4gICAgICAgICAgICAgIGQwID0gb2Zmc2V0WSArICR7dS5kaWxhdGlvbnNbMF19ICogKGltb2QocG9zLCAke2R9KSAvICR7bFsyXX0pO1xcblxcbiAgICAgICAgICAgICAgaWYoZDAgPCAke2NbMl19ICYmIGQwID49IDApIHtcXG4gICAgICAgICAgICAgICAgb2Zmc2V0WCA9IGltb2QoYmxvY2tJbmRleCwgJHtzW3AtMV19KSAqICR7dS5zdHJpZGVzWzFdfSAtXFxuICAgICAgICAgICAgICAgICAgJHt1LnBhZHNbMV19O1xcbiAgICAgICAgICAgICAgICBkMSA9IG9mZnNldFggKyAke3UuZGlsYXRpb25zWzFdfSAqIGltb2QoaW1vZChwb3MsICR7ZH0pLCAke2xbMl19KTtcXG5cXG4gICAgICAgICAgICAgICAgaWYoZDEgPCAke2NbM119ICYmIGQxID49IDApIHtcXG5cXG4gICAgICAgICAgICAgICAgICBjaCA9IGludChmbG9hdChwb3MpLyAke2R9Lik7XFxuICAgICAgICAgICAgICAgICAgICBpbm5lckRpbXMgPSB2ZWMyKGQwLCBkMSk7XFxuICAgICAgICAgICAgICAgICAgICByZXN1bHRbJHsyKnQrZX1dID0gZ2V0Q2hhbm5lbChcXG4gICAgICAgICAgICAgICAgICAgICAgZ2V0QSgwLCBjaCwgaW50KGlubmVyRGltcy54KSxcXG4gICAgICAgICAgICAgICAgICAgICAgaW50KGlubmVyRGltcy55KSksIGlubmVyRGltcyk7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGA7Y29uc3QgbT1gXFxuICAgICAgJHtofVxcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWMyIHJjID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICAgIHZlYzQgcmVzdWx0ID0gdmVjNCgwLjApO1xcbiAgICAgICAgICBpbnQgYmxvY2tJbmRleCwgcG9zLCBvZmZzZXRZLCBkMCwgb2Zmc2V0WCwgZDEsIGNoO1xcbiAgICAgICAgICB2ZWMyIGlubmVyRGltcztcXG4gICAgICAgICAgJHtifVxcbiAgICAgICAgICAke2cub3V0cHV0fSA9IHJlc3VsdDtcXG4gICAgICB9XFxuICAgICAgICAgICAgYDtyZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LGUpLHtvdXRwdXQ6e2RpbXM6Zix0eXBlOm4udHlwZSx0ZXh0dXJlVHlwZTppLlRleHR1cmVUeXBlLnBhY2tlZH0sc2hhZGVyU291cmNlOm0saGFzTWFpbjohMH0pfSkodCx1LGUsbixhLHMpfSl9fSwzMjQ4Oih0LGUsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLmNhbGN1bGF0ZUltMkNvbERpbXM9ZS5jcmVhdGVJbTJDb2xQcm9ncmFtSW5mb0xvYWRlcj12b2lkIDA7Y29uc3Qgcj1uKDIwMzkpO2UuY3JlYXRlSW0yQ29sUHJvZ3JhbUluZm9Mb2FkZXI9KHQsbixpLG8sYSk9Pntjb25zdCBzPSh1PWEuY2FjaGVLZXkse25hbWU6XCJJbTJDb2xcIixpbnB1dE5hbWVzOltcIlhcIl0saW5wdXRUeXBlczpbci5UZXh0dXJlVHlwZS51bnBhY2tlZF0sY2FjaGVIaW50OnV9KTt2YXIgdTtyZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LHMpLHtnZXQ6KCk9PigodCxuLGksbyxhLHMpPT57Y29uc3QgdT1pLmRpbXMsYz1vLmRpbXMsbD1hLmxlbmd0aCxwPSgwLGUuY2FsY3VsYXRlSW0yQ29sRGltcykodSxjLGEsNCksZj1gXFxuICAgICAgICBjb25zdCBpbnQgWEMgPSAke3VbMV19O1xcbiAgICAgICAgY29uc3QgaW50IFhIID0gJHt1WzJdfTtcXG4gICAgICAgIGNvbnN0IGludCBYVyA9ICR7dVszXX07XFxuICAgICAgICBjb25zdCBpbnQgS0ggPSAke3Mua2VybmVsU2hhcGVbMF19O1xcbiAgICAgICAgY29uc3QgaW50IEtXID0gJHtzLmtlcm5lbFNoYXBlWzFdfTtcXG4gICAgICAgIGNvbnN0IGludCBkaWxhdGlvbkggPSAke3MuZGlsYXRpb25zWzBdfTtcXG4gICAgICAgIGNvbnN0IGludCBkaWxhdGlvblcgPSAke3MuZGlsYXRpb25zWzFdfTtcXG4gICAgICAgIGNvbnN0IGludCBzdHJpZGVIID0gJHtzLnN0cmlkZXNbMF19O1xcbiAgICAgICAgY29uc3QgaW50IHN0cmlkZVcgPSAke3Muc3RyaWRlc1sxXX07XFxuICAgICAgICBjb25zdCBpbnQgcGFkSCA9ICR7cy5wYWRzWzBdfTtcXG4gICAgICAgIGNvbnN0IGludCBwYWRXID0gJHtzLnBhZHNbMV19O1xcbiAgICAgICAgY29uc3QgaW50IEtIS1cgPSBLSCpLVztcXG4gICAgICAgIGNvbnN0IGludCBYQ0tIS1cgPSBYQyAqIEtIS1c7XFxuICAgICAgICBjb25zdCBpbnQgb3V0cHV0Q2hhbm5lbHMgPSA0O1xcbiAgICAgICAgdmVjNCBwcm9jZXNzKGludCBpbmRpY2VzWyR7bH1dKSB7XFxuICAgICAgICAgIGludCBiICA9IGluZGljZXNbMF07IC8vIGJhdGNoIHNpemVcXG4gICAgICAgICAgaW50IG9oID0gaW5kaWNlc1sxXSAqIHN0cmlkZUggLSBwYWRIOyAvL291dHB1dCBoZWlnaHRcXG4gICAgICAgICAgaW50IG93ID0gaW5kaWNlc1syXSAqIHN0cmlkZVcgLSBwYWRXOyAvL291dHB1dCB3aWR0aFxcbiAgICAgICAgICBpbnQgcCA9IGluZGljZXNbM10gKiBvdXRwdXRDaGFubmVsczsgLy9wYXRjaFxcbiAgICAgICAgICB2ZWM0IHZhbHVlID0gdmVjNCgwLjApO1xcbiAgICAgICAgICBmb3IoaW50IGk9MDsgaSA8IG91dHB1dENoYW5uZWxzOyArK2kpIHtcXG4gICAgICAgICAgICBpZihwIDwgWENLSEtXKSB7XFxuICAgICAgICAgICAgICBpbnQgcGF0Y2hDID0gcCAvIEtIS1c7XFxuICAgICAgICAgICAgICBpbnQgcGF0Y2hIID0gKHAgLSBwYXRjaEMqS0hLVykgLyBLVztcXG4gICAgICAgICAgICAgIGludCBwYXRjaFcgPSAocCAtIHBhdGNoQypLSEtXKSAtIHBhdGNoSCAqIEtXO1xcbiAgICAgICAgICAgICAgaW50IHhoMiA9IG9oICsgcGF0Y2hIICogZGlsYXRpb25IO1xcbiAgICAgICAgICAgICAgaW50IHh3MiA9IG93ICsgcGF0Y2hXICogZGlsYXRpb25XO1xcbiAgICAgICAgICAgICAgaW50IHhbJHt1Lmxlbmd0aH1dO1xcbiAgICAgICAgICAgICAgeFswXSA9IGI7XFxuICAgICAgICAgICAgICB4WzFdID0gcGF0Y2hDO1xcbiAgICAgICAgICAgICAgeFsyXSA9IHhoMjtcXG4gICAgICAgICAgICAgIHhbM10gPSB4dzI7XFxuICAgICAgICAgICAgICBpZih4aDIgPj0gMCAmJlxcbiAgICAgICAgICAgICAgICAgIHhoMiA8IFhIICYmXFxuICAgICAgICAgICAgICAgICAgeHcyID49IDAgJiZcXG4gICAgICAgICAgICAgICAgICB4dzIgPCBYVykge1xcbiAgICAgICAgICAgICAgICB2YWx1ZVtpXSA9IF9YKHgpO1xcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICArK3A7XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xcbiAgICAgICAgfVxcbiAgICAgICAgYDtyZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LG4pLHtvdXRwdXQ6e2RpbXM6cCx0eXBlOmkudHlwZSx0ZXh0dXJlVHlwZTpyLlRleHR1cmVUeXBlLnBhY2tlZExhc3REaW1lbnNpb259LHNoYWRlclNvdXJjZTpmfSl9KSgwLHMsbixpLG8sYSl9KX0sZS5jYWxjdWxhdGVJbTJDb2xEaW1zPSh0LGUsbixyPTQpPT5bblswXSxuWzJdLG5bM10sTWF0aC5jZWlsKHRbMV0qZVsyXSplWzNdL3IpXX0sNjU3MjoodCxlLG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5wYXJzZUltYWdlU2NhbGVyQXR0cmlidXRlcz1lLmltYWdlU2NhbGVyPXZvaWQgMDtjb25zdCByPW4oMjQ2KSxpPW4oMjAzOSk7ZS5pbWFnZVNjYWxlcj0odCxlLG4pPT4odShlKSxbdC5ydW4oYSh0LGUsbiksZSldKSxlLnBhcnNlSW1hZ2VTY2FsZXJBdHRyaWJ1dGVzPXQ9Pntjb25zdCBlPXQuYXR0cmlidXRlcy5nZXRGbG9hdChcInNjYWxlXCIpLG49dC5hdHRyaWJ1dGVzLmdldEZsb2F0cyhcImJpYXNcIik7cmV0dXJuKDAsci5jcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkpKHtzY2FsZTplLGJpYXM6bn0pfTtjb25zdCBvPXtuYW1lOlwiSW1hZ2VTY2FsZXJcIixpbnB1dE5hbWVzOltcIlhcIl0saW5wdXRUeXBlczpbaS5UZXh0dXJlVHlwZS51bnBhY2tlZF19LGE9KHQsZSxuKT0+e2NvbnN0IHI9T2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LG8pLHtjYWNoZUhpbnQ6bi5jYWNoZUtleX0pO3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30scikse2dldDooKT0+KCh0LGUsbixyKT0+e2NvbnN0IG89blswXS5kaW1zLnNsaWNlKCksYT1vLmxlbmd0aCx1PWBcXG4gICAgICAke3Moci5iaWFzLmxlbmd0aCl9XFxuICAgICAgZmxvYXQgcHJvY2VzcyhpbnQgaW5kaWNlc1ske2F9XSkge1xcbiAgICAgICAgcmV0dXJuIF9YKGluZGljZXMpICogc2NhbGUgKyBnZXRCaWFzKGJpYXMsIGluZGljZXNbMV0pO1xcbiAgICAgIH1gO3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sZSkse291dHB1dDp7ZGltczpvLHR5cGU6blswXS50eXBlLHRleHR1cmVUeXBlOmkuVGV4dHVyZVR5cGUudW5wYWNrZWR9LHZhcmlhYmxlczpbe25hbWU6XCJiaWFzXCIsdHlwZTpcImZsb2F0XCIsYXJyYXlMZW5ndGg6ci5iaWFzLmxlbmd0aCxkYXRhOnIuYmlhc30se25hbWU6XCJzY2FsZVwiLHR5cGU6XCJmbG9hdFwiLGRhdGE6ci5zY2FsZX1dLHNoYWRlclNvdXJjZTp1fSl9KSgwLHIsZSxuKX0pfSxzPXQ9Pntjb25zdCBlPVtgZmxvYXQgZ2V0QmlhcyhmbG9hdCBiaWFzWyR7dH1dLCBpbnQgY2hhbm5lbCkge2BdO2ZvcihsZXQgbj0wO248dDsrK24pMD09PW4/ZS5wdXNoKGBcXHRpZiAoY2hhbm5lbCA9PSAke259KSB7IHJldHVybiBiaWFzWyR7bn1dOyB9YCk6bj09PXQtMT9lLnB1c2goYFxcdGVsc2UgeyByZXR1cm4gYmlhc1ske259XTsgfWApOmUucHVzaChgXFx0ZWxzZSBpZiAoY2hhbm5lbCA9PSAke259KSB7IHJldHVybiBiaWFzWyR7bn1dOyB9YCk7cmV0dXJuIGUucHVzaChcIlxcdH1cIiksZS5qb2luKFwiXFxuXCIpfSx1PXQ9PntpZighdHx8MSE9PXQubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIkltYWdlU2NhbGVyIHJlcXVpcmVzIDEgaW5wdXQuXCIpO2lmKDQhPT10WzBdLmRpbXMubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW5wdXQgc2hhcGUuXCIpO2lmKFwiZmxvYXQzMlwiIT09dFswXS50eXBlJiZcImZsb2F0NjRcIiE9PXRbMF0udHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGlucHV0IHR5cGUuXCIpfX0sMzM0NjoodCxlLG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5wYXJzZUluc3RhbmNlTm9ybWFsaXphdGlvbkF0dHJpYnV0ZXM9ZS5pbnN0YW5jZU5vcm1hbGl6YXRpb249dm9pZCAwO2NvbnN0IHI9big1MDYwKSxpPW4oMjAzOSk7ZS5pbnN0YW5jZU5vcm1hbGl6YXRpb249KHQsZSxuKT0+e2MoZSk7Y29uc3Qgcj10LnJ1bihhKGVbMF0pLGUpO3JldHVyblt0LnJ1bih1KHQsZVswXSxuLHIuZGltcyksW2VbMF0scixlWzFdLGVbMl1dKV19LGUucGFyc2VJbnN0YW5jZU5vcm1hbGl6YXRpb25BdHRyaWJ1dGVzPXQ9PnQuYXR0cmlidXRlcy5nZXRGbG9hdChcImVwc2lsb25cIiwxZS01KTtjb25zdCBvPXtuYW1lOlwiSW5zdGFuY2VOb3JtYWxpemF0aW9uX01lYW5BbmRWYXJpYW5jZVwiLGlucHV0TmFtZXM6W1wiWFwiXSxpbnB1dFR5cGVzOltpLlRleHR1cmVUeXBlLnVucGFja2VkXX0sYT10PT5PYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sbykse2dldDooKT0+KCh0LGUpPT57Y29uc3Qgbj1lLmRpbXMuc2xpY2UoKSxyPW5bMV0sbz1uWzJdKm5bM10sYT1bblswXSxyXSxzPWBcXG4gICAgICB2ZWM0IHByb2Nlc3MoaW50WzJdIGluZGljZXMpIHtcXG4gICAgICAgIHZlYzQgdiA9IHZlYzQoMC4wKTtcXG4gICAgICAgIGludCBhWzRdO1xcbiAgICAgICAgYVswXSA9IGluZGljZXNbMF07XFxuICAgICAgICBhWzFdID0gaW5kaWNlc1sxXTtcXG4gICAgICAgIGZsb2F0IHRlbXAgPSAwLjA7XFxuICAgICAgICBmb3IoaW50IGEyPTA7IGEyPCR7blsyXX07IGEyKyspIHtcXG4gICAgICAgICAgYVsyXSA9IGEyO1xcbiAgICAgICAgICBmb3IoaW50IGEzPTA7IGEzPCR7blszXX07IGEzKyspIHtcXG4gICAgICAgICAgICBhWzNdID0gYTM7XFxuICAgICAgICAgICAgZmxvYXQgeCA9IF9YKGEpO1xcbiAgICAgICAgICAgIHRlbXAgKz0geDtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgZmxvYXQgbWVhbiA9IHRlbXAgLyBmbG9hdCgke299KTtcXG4gICAgICAgIHRlbXAgPSAwLjA7XFxuICAgICAgICBmb3IoaW50IGEyPTA7IGEyPCR7blsyXX07IGEyKyspIHtcXG4gICAgICAgICAgYVsyXSA9IGEyO1xcbiAgICAgICAgICBmb3IoaW50IGEzPTA7IGEzPCR7blszXX07IGEzKyspIHtcXG4gICAgICAgICAgICBhWzNdID0gYTM7XFxuICAgICAgICAgICAgZmxvYXQgeCA9IF9YKGEpO1xcbiAgICAgICAgICAgIHRlbXAgKz0gKHggLSBtZWFuKSAqICh4IC0gbWVhbik7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIHYuciA9IG1lYW47XFxuICAgICAgICB2LmcgPSB0ZW1wIC8gZmxvYXQoJHtvfSk7XFxuXFxuICAgICAgICByZXR1cm4gdjtcXG4gICAgICB9YDtyZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LHQpLHtvdXRwdXQ6e2RpbXM6YSx0eXBlOmUudHlwZSx0ZXh0dXJlVHlwZTppLlRleHR1cmVUeXBlLnBhY2tlZExhc3REaW1lbnNpb259LHNoYWRlclNvdXJjZTpzfSl9KShvLHQpfSkscz17bmFtZTpcIkluc3RhbmNlTm9ybWFsaXphdGlvbl9Db21wdXRlT3V0cHV0XCIsaW5wdXROYW1lczpbXCJYXCIsXCJNZWFuQW5kVmFyaWFuY2VcIixcIlNjYWxlXCIsXCJCXCJdLGlucHV0VHlwZXM6W2kuVGV4dHVyZVR5cGUudW5wYWNrZWQsaS5UZXh0dXJlVHlwZS5wYWNrZWRMYXN0RGltZW5zaW9uLGkuVGV4dHVyZVR5cGUudW5wYWNrZWQsaS5UZXh0dXJlVHlwZS51bnBhY2tlZF19LHU9KHQsZSxuLG8pPT57Y29uc3QgYT1PYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30scykse2NhY2hlSGludDpgJHtufWB9KTtyZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LGEpLHtnZXQ6KCk9PigodCxlLG4sbyxhKT0+e2NvbnN0IHM9KDAsci5nZXRHbHNsKSh0LnNlc3Npb24uYmFja2VuZC5nbENvbnRleHQudmVyc2lvbiksW3UsY109dC5jYWxjdWxhdGVUZXh0dXJlV2lkdGhBbmRIZWlnaHQoYSxpLlRleHR1cmVUeXBlLnBhY2tlZExhc3REaW1lbnNpb24pLFtsLHBdPVt1LzQsY10sZj1gXFxuICAgICAgdmVjNCBnZXRfTWVhbkFuZFZhcmlhbmNlKGludFsyXSBtdikge1xcbiAgICAgICAgaW50IG9mZnNldCA9IGluZGljZXNUb09mZnNldF9NZWFuQW5kVmFyaWFuY2UobXYpO1xcbiAgICAgICAgdmVjMiBjb29yZHMgPSBvZmZzZXRUb0Nvb3JkcyhvZmZzZXQsICR7bH0sICR7cH0pO1xcbiAgICAgICAgcmV0dXJuICR7cy50ZXh0dXJlMkR9KE1lYW5BbmRWYXJpYW5jZSwgY29vcmRzKTtcXG4gICAgICB9XFxuXFxuICAgICAgZmxvYXQgcHJvY2VzcyhpbnRbNF0gaW5kaWNlcykge1xcbiAgICAgICAgaW50IG12WzJdO1xcbiAgICAgICAgbXZbMF0gPSBpbmRpY2VzWzBdO1xcbiAgICAgICAgbXZbMV0gPSBpbmRpY2VzWzFdO1xcbiAgICAgICAgdmVjNCBtZWFuX2FuZF92YXJpYW5jZSA9IGdldF9NZWFuQW5kVmFyaWFuY2UobXYpO1xcbiAgICAgICAgZmxvYXQgbWVhbiA9IG1lYW5fYW5kX3ZhcmlhbmNlLnI7XFxuICAgICAgICBmbG9hdCB2YXJpYW5jZSA9IG1lYW5fYW5kX3ZhcmlhbmNlLmc7XFxuXFxuICAgICAgICBpbnQgc2JbMV07XFxuICAgICAgICBzYlswXSA9IGluZGljZXNbMV07XFxuICAgICAgICBmbG9hdCBzY2FsZSA9IF9TY2FsZShzYik7XFxuICAgICAgICBmbG9hdCBiID0gX0Ioc2IpO1xcblxcbiAgICAgICAgcmV0dXJuIHNjYWxlICogKF9YKGluZGljZXMpIC0gbWVhbikgLyBzcXJ0KHZhcmlhbmNlICsgZXBzaWxvbikgKyBiO1xcbiAgICAgIH1gO3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sZSkse291dHB1dDp7ZGltczpuLmRpbXMsdHlwZTpuLnR5cGUsdGV4dHVyZVR5cGU6aS5UZXh0dXJlVHlwZS51bnBhY2tlZH0sdmFyaWFibGVzOlt7bmFtZTpcImVwc2lsb25cIix0eXBlOlwiZmxvYXRcIixkYXRhOm99XSxzaGFkZXJTb3VyY2U6Zn0pfSkodCxhLGUsbixvKX0pfSxjPXQ9PntpZighdHx8MyE9PXQubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIkluc3RhbmNlTm9ybWFsaXphdGlvbiByZXF1aXJlcyAzIGlucHV0cy5cIik7Y29uc3QgZT10WzBdLG49dFsxXSxyPXRbMl07aWYoZS5kaW1zLmxlbmd0aDwzfHwxIT09bi5kaW1zLmxlbmd0aHx8MSE9PXIuZGltcy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpbnB1dCBzaGFwZS5cIik7aWYobi5kaW1zWzBdIT09ZS5kaW1zWzFdfHxyLmRpbXNbMF0hPT1lLmRpbXNbMV0pdGhyb3cgbmV3IEVycm9yKFwiSW5wdXQgc2hhcGVzIGFyZSBtaXNtYXRjaGVkLlwiKTtpZihcImZsb2F0MzJcIiE9PWUudHlwZSYmXCJmbG9hdDY0XCIhPT1lLnR5cGV8fFwiZmxvYXQzMlwiIT09bi50eXBlJiZcImZsb2F0NjRcIiE9PW4udHlwZXx8XCJmbG9hdDMyXCIhPT1yLnR5cGUmJlwiZmxvYXQ2NFwiIT09ci50eXBlKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW5wdXQgdHlwZS5cIik7aWYoNCE9PXRbMF0uZGltcy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiT25seSBzdXBwb3J0IDQtRCBpbnB1dCBzaGFwZS5cIil9fSw3MDg6KHQsZSxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUuY3JlYXRlUGFja2VkTWF0bXVsUHJvZ3JhbUluZm9Mb2FkZXI9dm9pZCAwO2NvbnN0IHI9bigyNTE3KSxpPW4oNTA2MCksbz1uKDIwMzkpLGE9big5MzkwKSxzPW4oMjgyMyksdT1uKDU2MjMpO2UuY3JlYXRlUGFja2VkTWF0bXVsUHJvZ3JhbUluZm9Mb2FkZXI9KHQsZSxuKT0+e2NvbnN0IGM9KGw9ZS5sZW5ndGg+MixwPW4uYWN0aXZhdGlvbkNhY2hlS2V5LHtuYW1lOlwiTWF0TXVsIChwYWNrZWQpXCIsaW5wdXROYW1lczpsP1tcIkFcIixcIkJcIixcIkJpYXNcIl06W1wiQVwiLFwiQlwiXSxpbnB1dFR5cGVzOmw/W28uVGV4dHVyZVR5cGUucGFja2VkLG8uVGV4dHVyZVR5cGUucGFja2VkLG8uVGV4dHVyZVR5cGUucGFja2VkXTpbby5UZXh0dXJlVHlwZS5wYWNrZWQsby5UZXh0dXJlVHlwZS5wYWNrZWRdLGNhY2hlSGludDpwfSk7dmFyIGwscDtyZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LGMpLHtnZXQ6KCk9PigodCxlLG4sYyk9Pntjb25zdCBsPW4ubGVuZ3RoPjIscD1sP1widmFsdWUgKz0gZ2V0Qmlhc0Zvck1hdG11bCgpO1wiOlwiXCIsZj1uWzBdLmRpbXMsZD1uWzFdLmRpbXMsaD1yLkJyb2FkY2FzdFV0aWwuY2FsY1NoYXBlKGYsZCwhMCksZz0hci5TaGFwZVV0aWwuYXJlRXF1YWwoblswXS5kaW1zLG5bMV0uZGltcyk7aWYoIWgpdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgdXNlIG1hdG11bCBvbiB0aGUgZ2l2ZW4gdGVuc29yc1wiKTtjb25zdCBiPWZbZi5sZW5ndGgtMV0sbT1NYXRoLmNlaWwoYi8yKSx5PWYubGVuZ3RoLF89ZC5sZW5ndGgsdj0oMCxpLmdldEdsc2wpKHQuc2Vzc2lvbi5iYWNrZW5kLmdsQ29udGV4dC52ZXJzaW9uKSx3PSgwLGEuZ2V0Q29vcmRzRGF0YVR5cGUpKGgubGVuZ3RoKSx4PWgubGVuZ3RoLFQ9KDAsYS5nZXRHbENoYW5uZWxzKSgpLHthY3RpdmF0aW9uRnVuY3Rpb246UyxhcHBseUFjdGl2YXRpb246T309KDAscy5nZXRBY3RpdmF0aW9uU25pcHBldCkoYyksQT1sP2AkeygwLHUuZ2V0Qmlhc0Zvck1hdG11bCkodyxULG5bMl0uZGltcyxoLCEwKX1gOlwiXCIsRT1nP2Ake2Z1bmN0aW9uKHQsZSxuLGkpe2xldCBvPVtdLGE9W107Y29uc3Qgcz1uWzBdLmRpbXMsdT1uWzFdLmRpbXMsYz1zLmxlbmd0aCxsPXUubGVuZ3RoLHA9aS5sZW5ndGgsZj1wLWMsZD1wLWw7bz1zLm1hcCgoKHQsbik9PmBjb29yZHMuJHtlW24rZl19YCkpLG9bYy0xXT1cImkqMlwiLG8uam9pbihcIiwgXCIpLGE9dS5tYXAoKCh0LG4pPT5gY29vcmRzLiR7ZVtuK2RdfWApKSxhW2wtMl09XCJpKjJcIixhLmpvaW4oXCIsIFwiKTtjb25zdCBoPXIuQnJvYWRjYXN0VXRpbC5nZXRCcm9hZGNhc3REaW1zKHMsaSksZz1yLkJyb2FkY2FzdFV0aWwuZ2V0QnJvYWRjYXN0RGltcyh1LGkpLGI9aC5tYXAoKHQ9PmBjb29yZHMuJHtlW3QrZl19ID0gMDtgKSkuam9pbihcIlxcblwiKSxtPWcubWFwKCh0PT5gY29vcmRzLiR7ZVt0K2RdfSA9IDA7YCkpLmpvaW4oXCJcXG5cIikseT1gaW50IGxhc3REaW0gPSBjb29yZHMuJHtlW3AtMV19O1xcbiAgY29vcmRzLiR7ZVtwLTFdfSA9IGNvb3Jkcy4ke2VbcC0yXX07XFxuICBjb29yZHMuJHtlW3AtMl19ID0gbGFzdERpbTtgO3JldHVybmBcXG52ZWM0IGdldEFBdE91dENvb3Jkc01hdG11bChpbnQgaSkge1xcbiAgJHt0fSBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICR7eX1cXG4gICR7Yn1cXG4gIHZlYzQgb3V0cHV0VmFsdWUgPSBnZXRBKCR7b30pO1xcbiAgcmV0dXJuIG91dHB1dFZhbHVlO1xcbn1cXG5cXG52ZWM0IGdldEJBdE91dENvb3Jkc01hdG11bChpbnQgaSkge1xcbiAgJHt0fSBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICR7eX1cXG4gICR7bX1cXG4gIHZlYzQgb3V0cHV0VmFsdWUgPSBnZXRCKCR7YX0pO1xcbiAgcmV0dXJuIG91dHB1dFZhbHVlO1xcbn1gfSh3LFQsbixoKX1gOlwiXCIsST1nP1wiZ2V0QUF0T3V0Q29vcmRzTWF0bXVsKGkpXCI6YGdldEEoJHtmdW5jdGlvbih0LGUpe2xldCBuPVwiXCI7Zm9yKGxldCByPTA7cjxlLTI7cisrKW4rPWByYy4ke3Rbcl19LCBgO3JldHVybiBuKz1gcmMuJHt0W2UtMl19LCBpKjJgLG59KFQseSl9KWAsUD1nP1wiZ2V0QkF0T3V0Q29vcmRzTWF0bXVsKGkpXCI6YGdldEIoJHtmdW5jdGlvbih0LGUpe2xldCBuPVwiXCI7Zm9yKGxldCByPTA7cjxlLTI7cisrKW4rPWByYy4ke3Rbcl19LCBgO3JldHVybiBuKz1gaSoyLCByYy4ke3RbZS0xXX1gLG59KFQsXyl9KWAsRD1gXFxuICAgICAgICAgICAgJHtFfVxcbiAgICAgICAgICAgICR7QX1cXG4gICAgICAgICAgICAke1N9XFxuICAgICAgICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgICAgICAgJHtnP1wiXCI6YCR7d30gcmMgPVxcbiAgICAgICAgICBnZXRPdXRwdXRDb29yZHMoKTsgaW50IGxhc3REaW0gPSByYy4ke1RbeC0xXX07IHJjLiR7VFt4LTFdfSA9XFxuICAgICAgICAgIHJjLiR7VFt4LTJdfTsgcmMuJHtUW3gtMl19ID0gbGFzdERpbTtcXG4gICAgICBgfVxcblxcbiAgICAgICAgICAgICAgdmVjNCB2YWx1ZSA9IHZlYzQoMCk7XFxuICAgICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8ICR7bX07IGkrKykge1xcbiAgICAgICAgICAgICAgICB2ZWM0IGEgPSAke0l9O1xcbiAgICAgICAgICAgICAgICB2ZWM0IGIgPSAke1B9O1xcblxcbiAgICAgICAgICAgICAgICB2YWx1ZSArPSAoYS5ycmJiICogYi5yZ3JnKTtcXG4gICAgICAgICAgICAgICAgdmFsdWUgKz0gKGEuZ2dhYSAqIGIuYmFiYSk7XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAke3B9XFxuICAgICAgICAgICAgICAke099XFxuICAgICAgICAgICAgICAke3Yub3V0cHV0fSA9IHZhbHVlO1xcbiAgICAgICAgICAgIH1gO3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sZSkse291dHB1dDp7ZGltczpoLHR5cGU6blswXS50eXBlLHRleHR1cmVUeXBlOm8uVGV4dHVyZVR5cGUucGFja2VkfSxzaGFkZXJTb3VyY2U6RCxoYXNNYWluOiEwfSl9KSh0LGMsZSxuKX0pfX0sNTYyMzoodCxlLG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5nZXRCaWFzRm9yTWF0bXVsPWUuY3JlYXRlTWF0bXVsUHJvZ3JhbUluZm9Mb2FkZXI9ZS5wYXJzZU1hdE11bEF0dHJpYnV0ZXM9ZS5tYXRNdWw9dm9pZCAwO2NvbnN0IHI9bigyNTE3KSxpPW4oMjAzOSksbz1uKDkzOTApLGE9bigyODIzKSxzPW4oNzA4KTtmdW5jdGlvbiB1KHQsZSl7Y29uc3Qgbj0ocz10Lmxlbmd0aD4yLHU9ZS5hY3RpdmF0aW9uQ2FjaGVLZXkse25hbWU6XCJNYXRNdWxcIixpbnB1dE5hbWVzOnM/W1wiQVwiLFwiQlwiLFwiQmlhc1wiXTpbXCJBXCIsXCJCXCJdLGlucHV0VHlwZXM6cz9baS5UZXh0dXJlVHlwZS51bnBhY2tlZCxpLlRleHR1cmVUeXBlLnVucGFja2VkLGkuVGV4dHVyZVR5cGUudW5wYWNrZWRdOltpLlRleHR1cmVUeXBlLnVucGFja2VkLGkuVGV4dHVyZVR5cGUudW5wYWNrZWRdLGNhY2hlSGludDp1fSk7dmFyIHMsdTtyZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LG4pLHtnZXQ6KCk9PmZ1bmN0aW9uKHQsZSxuKXtjb25zdCBzPWVbMF0uZGltcyx1PWVbMV0uZGltcyxjPXIuQnJvYWRjYXN0VXRpbC5jYWxjU2hhcGUocyx1LCEwKTtpZighYyl0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCB1c2UgbWF0bXVsIG9uIHRoZSBnaXZlbiB0ZW5zb3JzXCIpO2NvbnN0IHA9KDAsby5nZXRDb29yZHNEYXRhVHlwZSkoYy5sZW5ndGgpLGY9KDAsby5nZXRHbENoYW5uZWxzKSgpLHthY3RpdmF0aW9uRnVuY3Rpb246ZCxhcHBseUFjdGl2YXRpb246aH09KDAsYS5nZXRBY3RpdmF0aW9uU25pcHBldCkobiksZz1lLmxlbmd0aD4yLGI9Zz9cInZhbHVlICs9IGdldEJpYXNGb3JNYXRtdWwoKTtcIjpcIlwiLG09Zz9gJHtsKHAsZixlWzJdLmRpbXMsYywhMSl9YDpcIlwiLHk9Yy5sZW5ndGgsXz1zLmxlbmd0aCx2PXUubGVuZ3RoLHc9YFxcbiAgICAke2R9XFxuICAgICR7bX1cXG4gICAgZmxvYXQgcHJvY2VzcyhpbnQgaW5kaWNlc1ske3l9XSkge1xcbiAgICAgICAgaW50IGFbJHtffV07XFxuICAgICAgICBpbnQgYlske3Z9XTtcXG4gICAgICAgIGJjYXN0TWF0bXVsSW5kaWNlc19BKGluZGljZXMsIGEpO1xcbiAgICAgICAgYmNhc3RNYXRtdWxJbmRpY2VzX0IoaW5kaWNlcywgYik7XFxuXFxuICAgICAgICBmbG9hdCB2YWx1ZTtcXG4gICAgICAgIGZvciAoaW50IGs9MDsgazwke3Nbcy5sZW5ndGgtMV19OyArK2spIHtcXG4gICAgICAgICAgICBhWyR7Xy0xfV0gPSBrO1xcbiAgICAgICAgICAgIGJbJHt2LTJ9XSA9IGs7XFxuICAgICAgICAgICAgdmFsdWUgKz0gX0EoYSkgKiBfQihiKTtcXG4gICAgICAgIH1cXG4gICAgICAgICR7Yn1cXG4gICAgICAgICR7aH1cXG4gICAgICAgIHJldHVybiB2YWx1ZTtcXG4gICAgfWA7cmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSx0KSx7b3V0cHV0OntkaW1zOmMsdHlwZTplWzBdLnR5cGUsdGV4dHVyZVR5cGU6aS5UZXh0dXJlVHlwZS51bnBhY2tlZH0sc2hhZGVyU291cmNlOnd9KX0obix0LGUpfSl9ZS5tYXRNdWw9KHQsZSxuKT0+KGMoZSksdC5zZXNzaW9uLnBhY2s/W3QucnVuKCgwLHMuY3JlYXRlUGFja2VkTWF0bXVsUHJvZ3JhbUluZm9Mb2FkZXIpKHQsZSxuKSxlKV06W3QucnVuKHUoZSxuKSxlKV0pLGUucGFyc2VNYXRNdWxBdHRyaWJ1dGVzPXQ9PigwLGEucGFyc2VJbnRlcm5hbEFjdGl2YXRpb25BdHRyaWJ1dGVzKSh0LmF0dHJpYnV0ZXMpLGUuY3JlYXRlTWF0bXVsUHJvZ3JhbUluZm9Mb2FkZXI9dTtjb25zdCBjPXQ9PntpZighdHx8MiE9PXQubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIk1hdE11bCByZXF1aXJlcyAyIGlucHV0cy5cIik7aWYodFswXS5kaW1zW3RbMF0uZGltcy5sZW5ndGgtMV0hPT10WzFdLmRpbXNbdFsxXS5kaW1zLmxlbmd0aC0yXSl0aHJvdyBuZXcgRXJyb3IoXCJzaGFyZWQgZGltZW5zaW9uIGRvZXMgbm90IG1hdGNoLlwiKTtpZihcImZsb2F0MzJcIiE9PXRbMF0udHlwZSYmXCJmbG9hdDY0XCIhPT10WzBdLnR5cGV8fFwiZmxvYXQzMlwiIT09dFsxXS50eXBlJiZcImZsb2F0NjRcIiE9PXRbMV0udHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJpbnB1dHMgc2hvdWxkIGJlIGZsb2F0IHR5cGVcIik7aWYodFswXS50eXBlIT09dFsxXS50eXBlKXRocm93IG5ldyBFcnJvcihcImlucHV0cyB0eXBlcyBzaG91bGQgbWF0Y2hcIil9O2Z1bmN0aW9uIGwodCxlLG4saSxvKXtsZXQgYT1cIlwiO2NvbnN0IHM9bi5sZW5ndGgsdT1pLmxlbmd0aCxjPXUtczthPXU8MiYmcz4wP1wiY29vcmRzXCI6bi5tYXAoKCh0LG4pPT5gY29vcmRzLiR7ZVtuK2NdfWApKS5qb2luKFwiLCBcIik7Y29uc3QgbD1yLkJyb2FkY2FzdFV0aWwuZ2V0QnJvYWRjYXN0RGltcyhuLGkpLm1hcCgodD0+YGNvb3Jkcy4ke2VbdCtjXX0gPSAwO2ApKS5qb2luKFwiXFxuXCIpO2xldCBwPVwidmVjNChvdXRwdXRWYWx1ZS54eCwgb3V0cHV0VmFsdWUueXkpXCI7cmV0dXJuIDE9PT1yLlNoYXBlVXRpbC5zaXplKG4pJiYocD1cInZlYzQob3V0cHV0VmFsdWUueClcIiksbz9gXFxudmVjNCBnZXRCaWFzRm9yTWF0bXVsKCkge1xcbiAgJHt0fSBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICR7bH1cXG4gIHZlYzQgb3V0cHV0VmFsdWUgPSBnZXRCaWFzKCR7YX0pO1xcbiAgcmV0dXJuICR7cH07XFxufWA6YFxcbmZsb2F0IGdldEJpYXNGb3JNYXRtdWwoKSB7XFxuICAke3R9IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgJHtsfVxcbiAgcmV0dXJuIGdldEJpYXMoY29vcmRzLngpO1xcbn1gfWUuZ2V0Qmlhc0Zvck1hdG11bD1sfSwyNDAzOih0LGUsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLmNyZWF0ZVBhY2tQcm9ncmFtSW5mb0xvYWRlcj12b2lkIDA7Y29uc3Qgcj1uKDUwNjApLGk9bigyMDM5KSxvPW4oOTM5MCksYT1uKDI4MjcpLHM9e25hbWU6XCJwYWNrXCIsaW5wdXROYW1lczpbXCJBXCJdLGlucHV0VHlwZXM6W2kuVGV4dHVyZVR5cGUudW5wYWNrZWRSZXZlcnNlZF19O2UuY3JlYXRlUGFja1Byb2dyYW1JbmZvTG9hZGVyPSh0LGUpPT5PYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30scykse2dldDooKT0+KCh0LGUpPT57Y29uc3Qgbj0oMCxyLmdldEdsc2wpKHQuc2Vzc2lvbi5iYWNrZW5kLmdsQ29udGV4dC52ZXJzaW9uKSx1PWUuZGltcyxjPXUubGVuZ3RoLGw9ZS5kaW1zLmxlbmd0aCxwPSgwLG8uZ2V0Q29vcmRzRGF0YVR5cGUpKGwpLGY9KDAsYS5nZXRDaGFubmVscykoXCJyY1wiLGwpLGQ9KGg9bCxnPWYsYj11W3UubGVuZ3RoLTJdLG09dVt1Lmxlbmd0aC0xXSwwPT09aHx8MT09PWg/XCJcIjpgXFxuICAgIGludCByID0gJHtnW2gtMl19O1xcbiAgICBpbnQgYyA9ICR7Z1toLTFdfTtcXG4gICAgaW50IHJwMSA9ICR7Z1toLTJdfSArIDE7XFxuICAgIGludCBjcDEgPSAke2dbaC0xXX0gKyAxO1xcbiAgICBib29sIHJFZGdlID0gcnAxID49ICR7bX07XFxuICAgIGJvb2wgY0VkZ2UgPSBjcDEgPj0gJHtifTtcXG4gICAgYCk7dmFyIGgsZyxiLG07bGV0IHk7eT0wPT09Yz9bMSwxXToxPT09Yz9bdVswXSwxXTpbdVtsLTFdLHVbbC0yXV07Y29uc3QgXz1mdW5jdGlvbih0LGUsbil7aWYoMD09PXQpcmV0dXJuXCJmYWxzZVwiO2lmKDE9PT10KXJldHVybmByYyA+ICR7ZVswXX1gO2xldCByPVwiXCI7Zm9yKGxldCBpPXQtMjtpPHQ7aSsrKXIrPWAke25baV19ID49ICR7ZVtpLXQrMl19YCxpPHQtMSYmKHIrPVwifHxcIik7cmV0dXJuIHJ9KGwseSxmKSx2PWZ1bmN0aW9uKHQsZSl7Y29uc3Qgbj10Lmxlbmd0aDtpZigwPT09bilyZXR1cm5cImdldEEoKSwgMCwgMCwgMFwiO2lmKDE9PT1uKXJldHVybmBnZXRBKHJjKSxcXG4gICAgICAgICAgICByYyArIDEgPj0gJHt0WzBdfSA/IDAuIDogZ2V0QShyYyArIDEpLFxcbiAgICAgICAgICAgIDAsIDBgO2xldCByPVwiXCI7aWYobj4yKWZvcihsZXQgdD0wO3Q8bi0yOysrdClyKz1gJHtlW3RdfSxgO3JldHVybmBnZXRBKCR7cn1yLCBjKSxcXG4gICAgICAgICAgckVkZ2UgPyAwLiA6IGdldEEoJHtyfXJwMSwgYyksXFxuICAgICAgICAgIGNFZGdlID8gMC4gOiBnZXRBKCR7cn1yLCBjcDEpLFxcbiAgICAgICAgICByRWRnZSB8fCBjRWRnZSA/IDAuIDogZ2V0QSgke3J9cnAxLCBjcDEpYH0odSxmKSx3PWBcXG4gICAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgICAgJHtwfSByYyA9IGdldE91dHB1dENvb3JkcygpO1xcblxcbiAgICAgICAgICBpZigke199KSB7XFxuICAgICAgICAgICAgJHtuLm91dHB1dH0gPSB2ZWM0KDApO1xcbiAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICR7ZH1cXG5cXG4gICAgICAgICAgICAke24ub3V0cHV0fSA9IHZlYzQoJHt2fSk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICBgO3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30scykse2hhc01haW46ITAsb3V0cHV0OntkaW1zOmUuZGltcyx0eXBlOmUudHlwZSx0ZXh0dXJlVHlwZTppLlRleHR1cmVUeXBlLnBhY2tlZH0sc2hhZGVyU291cmNlOnd9KX0pKHQsZSl9KX0sMjgyNzoodCxlLG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS51bnBhY2tGcm9tQ2hhbm5lbD1lLmdldENoYW5uZWxzPWUuZ2V0VmVjQ2hhbm5lbHM9dm9pZCAwO2NvbnN0IHI9big5MzkwKTtmdW5jdGlvbiBpKHQsZSl7cmV0dXJuKDAsci5nZXRHbENoYW5uZWxzKShlKS5tYXAoKGU9PmAke3R9LiR7ZX1gKSl9ZS5nZXRWZWNDaGFubmVscz1pLGUuZ2V0Q2hhbm5lbHM9ZnVuY3Rpb24odCxlKXtyZXR1cm4gMT09PWU/W3RdOmkodCxlKX0sZS51bnBhY2tGcm9tQ2hhbm5lbD1mdW5jdGlvbigpe3JldHVyblwiXFxuICAgIGZsb2F0IGdldENoYW5uZWwodmVjNCBmcmFnLCBpbnQgZGltKSB7XFxuICAgICAgaW50IG1vZENvb3JkID0gaW1vZChkaW0sIDIpO1xcbiAgICAgIHJldHVybiBtb2RDb29yZCA9PSAwID8gZnJhZy5yIDogZnJhZy5nO1xcbiAgICB9XFxuXFxuICAgIGZsb2F0IGdldENoYW5uZWwodmVjNCBmcmFnLCB2ZWMyIGlubmVyRGltcykge1xcbiAgICAgIHZlYzIgbW9kQ29vcmQgPSBtb2QoaW5uZXJEaW1zLCAyLik7XFxuICAgICAgcmV0dXJuIG1vZENvb3JkLnggPT0gMC4gP1xcbiAgICAgICAgKG1vZENvb3JkLnkgPT0gMC4gPyBmcmFnLnIgOiBmcmFnLmcpIDpcXG4gICAgICAgIChtb2RDb29yZC55ID09IDAuID8gZnJhZy5iIDogZnJhZy5hKTtcXG4gICAgfVxcbiAgXCJ9fSwyODcwOih0LGUsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLnBhcnNlUGFkQXR0cmlidXRlc1YxMT1lLnBhZFYxMT1lLnBhcnNlUGFkQXR0cmlidXRlc1YyPWUucGFkVjI9dm9pZCAwO2NvbnN0IHI9bigyNDYpLGk9bigyNTE3KSxvPW4oNTA2MCksYT1uKDIwMzkpLHM9e25hbWU6XCJQYWRcIixpbnB1dE5hbWVzOltcIkFcIl0saW5wdXRUeXBlczpbYS5UZXh0dXJlVHlwZS51bnBhY2tlZF19O2UucGFkVjI9KHQsZSxuKT0+KGwoZSksW3QucnVuKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxzKSx7Y2FjaGVIaW50Om4uY2FjaGVLZXksZ2V0OigpPT5jKHQsZVswXSxuKX0pLGUpXSksZS5wYXJzZVBhZEF0dHJpYnV0ZXNWMj10PT57Y29uc3QgZT10LmF0dHJpYnV0ZXMuZ2V0U3RyaW5nKFwibW9kZVwiLFwiY29uc3RhbnRcIiksbj10LmF0dHJpYnV0ZXMuZ2V0RmxvYXQoXCJ2YWx1ZVwiLDApLGk9dC5hdHRyaWJ1dGVzLmdldEludHMoXCJwYWRzXCIpO3JldHVybigwLHIuY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KSh7bW9kZTplLHZhbHVlOm4scGFkczppfSl9LGUucGFkVjExPSh0LG4scik9PntwKG4pO2NvbnN0IGk9dSh0LG4scik7cmV0dXJuKDAsZS5wYWRWMikodCxbblswXV0saSl9LGUucGFyc2VQYWRBdHRyaWJ1dGVzVjExPXQ9PnQuYXR0cmlidXRlcy5nZXRTdHJpbmcoXCJtb2RlXCIsXCJjb25zdGFudFwiKTtjb25zdCB1PSh0LGUsbik9PntpZighdC5zZXNzaW9uLmlzSW5pdGlhbGl6ZXIoZVsxXS5kYXRhSWQpfHxlLmxlbmd0aD49MyYmIXQuc2Vzc2lvbi5pc0luaXRpYWxpemVyKGVbMl0uZGF0YUlkKSl0aHJvdyBuZXcgRXJyb3IoXCJkeW5hbWljIHBhZCBhdHRyaWJ1dGVzIGFyZSBub3QgYWxsb3dlZFwiKTtjb25zdCBpPUFycmF5LmZyb20oZVsxXS5pbnRlZ2VyRGF0YSksbz1lLmxlbmd0aD49Mz9lWzJdLmZsb2F0RGF0YVswXTowO3JldHVybigwLHIuY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KSh7bW9kZTpuLHBhZHM6aSx2YWx1ZTpvfSl9LGM9KHQsZSxuKT0+e2NvbnN0IHI9aS5TaGFwZVV0aWwucGFkU2hhcGUoZS5kaW1zLnNsaWNlKCksbi5wYWRzKSxvPXIubGVuZ3RoLHM9YFxcbiAgICAgICR7Zih0LGUsbil9XFxuICAgICAgZmxvYXQgcHJvY2VzcyhpbnRbJHtvfV0gaW5kaWNlcykge1xcbiAgICAgICAgICByZXR1cm4gcGFkQShpbmRpY2VzKTtcXG4gICAgICB9YDtyZXR1cm57bmFtZTpcIlBhZFwiLGlucHV0TmFtZXM6W1wiQVwiXSxpbnB1dFR5cGVzOlthLlRleHR1cmVUeXBlLnVucGFja2VkXSxvdXRwdXQ6e2RpbXM6cix0eXBlOmUudHlwZSx0ZXh0dXJlVHlwZTphLlRleHR1cmVUeXBlLnVucGFja2VkfSxzaGFkZXJTb3VyY2U6c319LGw9dD0+e2lmKCF0fHwxIT09dC5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiUGFkIHJlcXVpcmVzIDEgaW5wdXRcIik7aWYoXCJmbG9hdDMyXCIhPT10WzBdLnR5cGUmJlwiZmxvYXQ2NFwiIT09dFswXS50eXBlKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW5wdXQgdHlwZS5cIil9LHA9dD0+e2lmKCF0fHwyIT09dC5sZW5ndGgmJjMhPT10Lmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJQYWQgcmVxdWlyZXMgMiBvciAzIGlucHV0c1wiKTtpZihcImludDMyXCIhPT10WzFdLnR5cGUpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpbnB1dCB0eXBlLlwiKTtpZih0Lmxlbmd0aD49MyYmXCJzdHJpbmdcIj09PXRbMl0udHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGlucHV0IHR5cGUuXCIpfSxmPSh0LGUsbik9Pntjb25zdCByPSgwLG8uZ2V0R2xzbCkodC5zZXNzaW9uLmJhY2tlbmQuZ2xDb250ZXh0LnZlcnNpb24pLFtzLHVdPXQuY2FsY3VsYXRlVGV4dHVyZVdpZHRoQW5kSGVpZ2h0KGUuZGltcyxhLlRleHR1cmVUeXBlLnVucGFja2VkKSxjPWkuU2hhcGVVdGlsLmNvbXB1dGVTdHJpZGVzKGUuZGltcyk7c3dpdGNoKG4ubW9kZSl7Y2FzZVwiY29uc3RhbnRcIjpyZXR1cm4gZChyLGUuZGltcyxjLHMsdSxuLnBhZHMsbi52YWx1ZSk7Y2FzZVwicmVmbGVjdFwiOnJldHVybiBoKHIsZS5kaW1zLGMscyx1LG4ucGFkcyk7Y2FzZVwiZWRnZVwiOnJldHVybiBnKHIsZS5kaW1zLGMscyx1LG4ucGFkcyk7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIG1vZGVcIil9fSxkPSh0LGUsbixyLGksbyxhKT0+e2NvbnN0IHM9ZS5sZW5ndGg7bGV0IHU9XCJcIjtmb3IobGV0IHQ9cy0xO3Q+PTA7LS10KXUrPWBcXG4gICAgICAgIGsgPSBtWyR7dH1dIC0gJHtvW3RdfTtcXG4gICAgICAgIGlmIChrIDwgMCkgIHJldHVybiBjb25zdGFudDtcXG4gICAgICAgIGlmIChrID49ICR7ZVt0XX0pIHJldHVybiBjb25zdGFudDtcXG4gICAgICAgIG9mZnNldCArPSBrICogJHtuW3RdfTtcXG4gICAgICAgIGA7cmV0dXJuYFxcbiAgICAgIGZsb2F0IHBhZEEoaW50IG1bJHtzfV0pIHtcXG4gICAgICAgIGNvbnN0IGZsb2F0IGNvbnN0YW50ID0gZmxvYXQoJHthfSk7XFxuICAgICAgICBpbnQgb2Zmc2V0ID0gMDtcXG4gICAgICAgIGludCBrID0gMDtcXG4gICAgICAgICR7dX1cXG4gICAgICAgIHZlYzIgY29vcmRzID0gb2Zmc2V0VG9Db29yZHMob2Zmc2V0LCAke3J9LCAke2l9KTtcXG4gICAgICAgIGZsb2F0IHZhbHVlID0gZ2V0Q29sb3JBc0Zsb2F0KCR7dC50ZXh0dXJlMkR9KEEsIGNvb3JkcykpO1xcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xcbiAgICAgIH1cXG4gICAgICBgfSxoPSh0LGUsbixyLGksbyk9Pntjb25zdCBhPWUubGVuZ3RoO2xldCBzPVwiXCI7Zm9yKGxldCB0PWEtMTt0Pj0wOy0tdClzKz1gXFxuICAgICAgICBrID0gbVske3R9XSAtICR7b1t0XX07XFxuICAgICAgICBpZiAoayA8IDApIHsgayA9IC1rOyB9XFxuICAgICAgICB7XFxuICAgICAgICAgIGNvbnN0IGludCBfMm5fMSA9ICR7MiooZVt0XS0xKX07XFxuICAgICAgICAgIGsgPSBpbnQoIG1vZCggZmxvYXQoayksIGZsb2F0KF8ybl8xKSApICkgO1xcbiAgICAgICAgICBpZihrID49ICR7ZVt0XX0pIHsgayA9IF8ybl8xIC0gazsgfVxcbiAgICAgICAgfVxcbiAgICAgICAgb2Zmc2V0ICs9IGsgKiAke25bdF19O1xcbiAgICAgICAgYDtyZXR1cm5gXFxuICAgICAgZmxvYXQgcGFkQShpbnQgbVske2F9XSkge1xcbiAgICAgICAgaW50IG9mZnNldCA9IDA7XFxuICAgICAgICBpbnQgayA9IDA7XFxuICAgICAgICAke3N9XFxuICAgICAgICB2ZWMyIGNvb3JkcyA9IG9mZnNldFRvQ29vcmRzKG9mZnNldCwgJHtyfSwgJHtpfSk7XFxuICAgICAgICBmbG9hdCB2YWx1ZSA9IGdldENvbG9yQXNGbG9hdCgke3QudGV4dHVyZTJEfShBLCBjb29yZHMpKTtcXG4gICAgICAgIHJldHVybiB2YWx1ZTtcXG4gICAgICB9XFxuICAgICAgYH0sZz0odCxlLG4scixpLG8pPT57Y29uc3QgYT1lLmxlbmd0aDtsZXQgcz1cIlwiO2ZvcihsZXQgdD1hLTE7dD49MDstLXQpcys9YFxcbiAgICAgICAgayA9IG1bJHt0fV0gLSAke29bdF19O1xcbiAgICAgICAgaWYgKGsgPCAwKSAgayA9IDA7XFxuICAgICAgICBpZiAoayA+PSAke2VbdF19KSBrID0gJHtlW3RdLTF9O1xcbiAgICAgICAgb2Zmc2V0ICs9IGsgKiAke25bdF19O1xcbiAgICAgIGA7cmV0dXJuYFxcbiAgICAgIGZsb2F0IHBhZEEoaW50IG1bJHthfV0pIHtcXG4gICAgICAgIGludCBvZmZzZXQgPSAwO1xcbiAgICAgICAgaW50IGsgPSAwO1xcbiAgICAgICAgJHtzfVxcbiAgICAgICAgdmVjMiBjb29yZHMgPSBvZmZzZXRUb0Nvb3JkcyhvZmZzZXQsICR7cn0sICR7aX0pO1xcbiAgICAgICAgZmxvYXQgdmFsdWUgPSBnZXRDb2xvckFzRmxvYXQoJHt0LnRleHR1cmUyRH0oQSwgY29vcmRzKSk7XFxuICAgICAgICByZXR1cm4gdmFsdWU7XFxuICAgICAgfVxcbiAgICAgIGB9fSwyMTQzOih0LGUsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLmdsb2JhbE1heFBvb2w9ZS5wYXJzZU1heFBvb2xBdHRyaWJ1dGVzPWUubWF4UG9vbD1lLnBhcnNlR2xvYmFsQXZlcmFnZVBvb2xBdHRyaWJ1dGVzPWUuZ2xvYmFsQXZlcmFnZVBvb2w9ZS5wYXJzZUF2ZXJhZ2VQb29sQXR0cmlidXRlcz1lLmF2ZXJhZ2VQb29sPXZvaWQgMDtjb25zdCByPW4oMjQ2KSxpPW4oMjUxNyksbz1uKDIwMzkpO2UuYXZlcmFnZVBvb2w9KHQsZSxuKT0+e3AoZSk7Y29uc3Qgcj17bmFtZTpcIkF2ZXJhZ2VQb29sXCIsaW5wdXROYW1lczpbXCJYXCJdLGlucHV0VHlwZXM6W28uVGV4dHVyZVR5cGUudW5wYWNrZWRdLGNhY2hlSGludDpuLmNhY2hlS2V5fTtyZXR1cm5bdC5ydW4oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LHIpLHtnZXQ6KCk9PmEoZSxyLCExLG4pfSksZSldfSxlLnBhcnNlQXZlcmFnZVBvb2xBdHRyaWJ1dGVzPXQ9Pntjb25zdCBlPXQuYXR0cmlidXRlcy5nZXRTdHJpbmcoXCJhdXRvX3BhZFwiLFwiTk9UU0VUXCIpLG49dC5hdHRyaWJ1dGVzLmdldEludChcImNlaWxfbW9kZVwiLDApLGk9MCE9PXQuYXR0cmlidXRlcy5nZXRJbnQoXCJjb3VudF9pbmNsdWRlX3BhZFwiLDApLG89dC5hdHRyaWJ1dGVzLmdldEludHMoXCJrZXJuZWxfc2hhcGVcIiksYT10LmF0dHJpYnV0ZXMuZ2V0SW50cyhcInN0cmlkZXNcIixbXSkscz10LmF0dHJpYnV0ZXMuZ2V0SW50cyhcInBhZHNcIixbXSk7aWYoMCE9PW4pdGhyb3cgbmV3IEVycm9yKFwidXNpbmcgY2VpbCgpIGluIHNoYXBlIGNvbXB1dGF0aW9uIGlzIG5vdCB5ZXQgc3VwcG9ydGVkIGZvciBBdmVyYWdlUG9vbFwiKTtyZXR1cm4oMCxyLmNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSkoe2F1dG9QYWQ6ZSxjZWlsTW9kZTpuLGNvdW50SW5jbHVkZVBhZDppLGtlcm5lbFNoYXBlOm8sc3RyaWRlczphLHBhZHM6c30pfTtjb25zdCBhPSh0LGUsbixyKT0+e2NvbnN0W2Esc109dSh0LHIsbiksYz1pLlNoYXBlVXRpbC5zaXplKGEua2VybmVsU2hhcGUpO2xldCBsPVwiXCI7YS5jb3VudEluY2x1ZGVQYWQ/bCs9YHZhbHVlIC89IGZsb2F0KCR7Y30pO2A6bCs9YHZhbHVlIC89IGZsb2F0KCR7Y30gLSBwYWQpO2A7Y29uc3QgcD1gXFxuICAgICAgICAke2YodFswXS5kaW1zLGEsXCJ2YWx1ZSArPSBfWCh4KTtcIixsLFwiMC4wXCIpfVxcbiAgICAgIGA7cmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxlKSx7b3V0cHV0OntkaW1zOnMsdHlwZTp0WzBdLnR5cGUsdGV4dHVyZVR5cGU6by5UZXh0dXJlVHlwZS51bnBhY2tlZH0sc2hhZGVyU291cmNlOnB9KX07ZS5nbG9iYWxBdmVyYWdlUG9vbD0odCxlLG4pPT57cChlKTtjb25zdCByPXtuYW1lOlwiR2xvYmFsQXZlcmFnZVBvb2xcIixpbnB1dE5hbWVzOltcIlhcIl0saW5wdXRUeXBlczpbby5UZXh0dXJlVHlwZS51bnBhY2tlZF0sY2FjaGVIaW50OmAke24uY291bnRJbmNsdWRlUGFkfWB9O3JldHVyblt0LnJ1bihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30scikse2dldDooKT0+YShlLHIsITAsbil9KSxlKV19LGUucGFyc2VHbG9iYWxBdmVyYWdlUG9vbEF0dHJpYnV0ZXM9dD0+e2NvbnN0IGU9MCE9PXQuYXR0cmlidXRlcy5nZXRJbnQoXCJjb3VudF9pbmNsdWRlX3BhZFwiLDApO3JldHVybigwLHIuY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KSh7YXV0b1BhZDpcIlwiLGNlaWxNb2RlOjAsY291bnRJbmNsdWRlUGFkOmUsa2VybmVsU2hhcGU6W10sc3RyaWRlczpbXSxwYWRzOltdfSl9LGUubWF4UG9vbD0odCxlLG4pPT57cChlKTtjb25zdCByPXtuYW1lOlwiTWF4UG9vbFwiLGlucHV0TmFtZXM6W1wiWFwiXSxpbnB1dFR5cGVzOltvLlRleHR1cmVUeXBlLnVucGFja2VkXSxjYWNoZUhpbnQ6bi5jYWNoZUtleX07cmV0dXJuW3QucnVuKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxyKSx7Z2V0OigpPT5zKGUsciwhMSxuKX0pLGUpXX0sZS5wYXJzZU1heFBvb2xBdHRyaWJ1dGVzPXQ9Pntjb25zdCBlPXQuYXR0cmlidXRlcy5nZXRTdHJpbmcoXCJhdXRvX3BhZFwiLFwiTk9UU0VUXCIpLG49dC5hdHRyaWJ1dGVzLmdldEludChcImNlaWxfbW9kZVwiLDApLGk9dC5hdHRyaWJ1dGVzLmdldEludHMoXCJrZXJuZWxfc2hhcGVcIiksbz10LmF0dHJpYnV0ZXMuZ2V0SW50cyhcInN0cmlkZXNcIixbXSksYT10LmF0dHJpYnV0ZXMuZ2V0SW50cyhcInBhZHNcIixbXSkscz10LmF0dHJpYnV0ZXMuZ2V0SW50KFwic3RvcmFnZV9vcmRlclwiLDApLHU9dC5hdHRyaWJ1dGVzLmdldEludHMoXCJkaWxhdGlvbnNcIixbXSk7aWYoMCE9PXMpdGhyb3cgbmV3IEVycm9yKFwiY29sdW1uIG1ham9yIHN0b3JhZ2Ugb3JkZXIgaXMgbm90IHlldCBzdXBwb3J0ZWQgZm9yIE1heFBvb2xcIik7aWYoMCE9PW4pdGhyb3cgbmV3IEVycm9yKFwidXNpbmcgY2VpbCgpIGluIHNoYXBlIGNvbXB1dGF0aW9uIGlzIG5vdCB5ZXQgc3VwcG9ydGVkIGZvciBNYXhQb29sXCIpO3JldHVybigwLHIuY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KSh7YXV0b1BhZDplLGNlaWxNb2RlOm4sY291bnRJbmNsdWRlUGFkOiExLGtlcm5lbFNoYXBlOmksc3RyaWRlczpvLHBhZHM6YSxzdG9yYWdlT3JkZXI6cyxkaWxhdGlvbnM6dX0pfTtjb25zdCBzPSh0LGUsbixyKT0+e2NvbnN0W2ksYV09dSh0LHIsbikscz1gXFxuICAgICAgJHtmKHRbMF0uZGltcyxpLFwiXFxuICAgICAgdmFsdWUgPSBtYXgoX1goeCksIHZhbHVlKTtcXG4gICAgXCIsXCJcIixcIi0xZTVcIil9XFxuICAgIGA7cmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxlKSx7b3V0cHV0OntkaW1zOmEsdHlwZTp0WzBdLnR5cGUsdGV4dHVyZVR5cGU6by5UZXh0dXJlVHlwZS51bnBhY2tlZH0sc2hhZGVyU291cmNlOnN9KX0sdT0odCxlLG4pPT57Y29uc3Qgcj10WzBdLmRpbXMuc2xpY2UoKSxvPU9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsXCJkaWxhdGlvbnNcIiksYT1lLmtlcm5lbFNoYXBlLnNsaWNlKCkscz1lLnN0cmlkZXMuc2xpY2UoKSx1PW8/ZS5kaWxhdGlvbnMuc2xpY2UoKTpbXSxjPWUucGFkcy5zbGljZSgpO2kuUG9vbENvbnZVdGlsLmFkanVzdFBvb2xBdHRyaWJ1dGVzKG4scixhLHMsdSxjKTtjb25zdCBsPWkuUG9vbENvbnZVdGlsLmNvbXB1dGVQb29sT3V0cHV0U2hhcGUobixyLHMsdSxhLGMsZS5hdXRvUGFkKSxwPU9iamVjdC5hc3NpZ24oe30sZSk7cmV0dXJuIG8/T2JqZWN0LmFzc2lnbihwLHtrZXJuZWxTaGFwZTphLHN0cmlkZXM6cyxwYWRzOmMsZGlsYXRpb25zOnUsY2FjaGVLZXk6ZS5jYWNoZUtleX0pOk9iamVjdC5hc3NpZ24ocCx7a2VybmVsU2hhcGU6YSxzdHJpZGVzOnMscGFkczpjLGNhY2hlS2V5OmUuY2FjaGVLZXl9KSxbcCxsXX0sYz17YXV0b1BhZDpcIlwiLGNlaWxNb2RlOjAsY291bnRJbmNsdWRlUGFkOiExLGtlcm5lbFNoYXBlOltdLHN0cmlkZXM6W10scGFkczpbXSxzdG9yYWdlT3JkZXI6MCxkaWxhdGlvbnM6W10sY2FjaGVLZXk6XCJcIn0sbD17bmFtZTpcIkdsb2JhbE1heFBvb2xcIixpbnB1dE5hbWVzOltcIlhcIl0saW5wdXRUeXBlczpbby5UZXh0dXJlVHlwZS51bnBhY2tlZF19O2UuZ2xvYmFsTWF4UG9vbD0odCxlKT0+KHAoZSksW3QucnVuKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxsKSx7Z2V0OigpPT5zKGUsbCwhMCxjKX0pLGUpXSk7Y29uc3QgcD10PT57aWYoIXR8fDEhPT10Lmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJQb29sIG9wcyByZXF1aXJlcyAxIGlucHV0LlwiKTtpZihcImZsb2F0MzJcIiE9PXRbMF0udHlwZSYmXCJmbG9hdDY0XCIhPT10WzBdLnR5cGUpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpbnB1dCB0eXBlLlwiKX0sZj0odCxlLG4scixvKT0+e2NvbnN0IGE9dC5sZW5ndGg7aWYoZS5rZXJuZWxTaGFwZS5sZW5ndGg8PTIpe2NvbnN0IGk9ZS5rZXJuZWxTaGFwZVtlLmtlcm5lbFNoYXBlLmxlbmd0aC0xXSxzPWUuc3RyaWRlc1tlLnN0cmlkZXMubGVuZ3RoLTFdLHU9ZS5wYWRzW2UucGFkcy5sZW5ndGgvMi0xXSxjPWUucGFkc1tlLnBhZHMubGVuZ3RoLTFdLGw9dFthLTFdO2xldCBwPVwiXCIsZj1cIlwiLGQ9XCJcIjtpZihwPXUrYyE9PTA/YFxcbiAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8ICR7aX07IGkrKykge1xcbiAgICAgICAgICAgIHhbJHthfSAtIDFdID0gaW5kaWNlc1ske2F9IC0gMV0gKiAke3N9IC0gJHt1fSArIGk7XFxuICAgICAgICAgICAgaWYgKHhbJHthfSAtIDFdIDwgMCB8fCB4WyR7YX0gLSAxXSA+PSAke2x9KSB7XFxuICAgICAgICAgICAgICBwYWQrKztcXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAke259XFxuICAgICAgICAgIH1gOmBcXG4gICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCAke2l9OyBpKyspIHtcXG4gICAgICAgICAgICB4WyR7YX0gLSAxXSA9IGluZGljZXNbJHthfSAtIDFdICogJHtzfSAtICR7dX0gKyBpO1xcbiAgICAgICAgICAgICR7bn1cXG4gICAgICAgICAgfWAsMj09PWUua2VybmVsU2hhcGUubGVuZ3RoKXtjb25zdCBuPWUua2VybmVsU2hhcGVbZS5rZXJuZWxTaGFwZS5sZW5ndGgtMl0scj1lLnN0cmlkZXNbZS5zdHJpZGVzLmxlbmd0aC0yXSxvPWUucGFkc1tlLnBhZHMubGVuZ3RoLzItMl0scz1lLnBhZHNbZS5wYWRzLmxlbmd0aC0yXSx1PXRbYS0yXTtmPW8rcyE9PTA/YFxcbiAgICAgICAgICAgIGZvciAoaW50IGogPSAwOyBqIDwgJHtufTsgaisrKSB7XFxuICAgICAgICAgICAgICB4WyR7YX0gLSAyXSA9IGluZGljZXNbJHthfSAtIDJdICogJHtyfSAtICR7b30gKyBqO1xcbiAgICAgICAgICAgICAgaWYgKHhbJHthfSAtIDJdIDwgMCB8fCB4WyR7YX0gLSAyXSA+PSAke3V9KSB7XFxuICAgICAgICAgICAgICAgIHBhZCs9ICR7aX07XFxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICBgOmBcXG4gICAgICAgICAgICBmb3IgKGludCBqID0gMDsgaiA8ICR7bn07IGorKykge1xcbiAgICAgICAgICAgICAgeFske2F9IC0gMl0gPSBpbmRpY2VzWyR7YX0gLSAyXSAqICR7cn0gLSAke299ICsgajtcXG4gICAgICAgICAgICBgLGQ9XCJcXG4gICAgICAgICAgfVxcbiAgICAgICAgXCJ9cmV0dXJuYFxcbiAgICAgICAgZmxvYXQgcHJvY2VzcyhpbnQgaW5kaWNlc1ske2F9XSkge1xcbiAgICAgICAgICBpbnQgeFske2F9XTtcXG4gICAgICAgICAgY29weVZlYyhpbmRpY2VzLCB4KTtcXG5cXG4gICAgICAgICAgZmxvYXQgdmFsdWUgPSAke299O1xcbiAgICAgICAgICBpbnQgcGFkID0gMDtcXG4gICAgICAgICAgJHtmfVxcbiAgICAgICAgICAke3B9XFxuICAgICAgICAgICR7ZH1cXG4gICAgICAgICAgJHtyfVxcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XFxuICAgICAgICB9XFxuICAgICAgYH17Y29uc3Qgcz1pLlNoYXBlVXRpbC5zaXplKGUua2VybmVsU2hhcGUpLHU9aS5TaGFwZVV0aWwuY29tcHV0ZVN0cmlkZXMoZS5rZXJuZWxTaGFwZSksYz11Lmxlbmd0aCxsPWUucGFkcy5sZW5ndGgscD1oKGMpLGY9ZCh0LFwiaW5wdXREaW1zXCIpLGc9ZChlLnBhZHMsXCJwYWRzXCIpLGI9ZCh1LFwia2VybmVsU3RyaWRlc1wiKSxtPWQoZS5zdHJpZGVzLFwic3RyaWRlc1wiKTtsZXQgeT1cIlwiO3JldHVybiB5PWUucGFkcy5yZWR1Y2UoKCh0LGUpPT50K2UpKT9gXFxuICAgICAgICAgICAgaWYgKHhbal0gPj0gaW5wdXREaW1zW2pdIHx8IHhbal0gPCAwKSB7XFxuICAgICAgICAgICAgICBwYWQrKztcXG4gICAgICAgICAgICAgIGlzUGFkID0gdHJ1ZTtcXG4gICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgICAgICBpZiAoIWlzUGFkKSB7XFxuICAgICAgICAgICAgJHtufVxcbiAgICAgICAgICB9YDpgXFxuICAgICAgICAgIH1cXG4gICAgICAgICAgJHtufVxcbiAgICAgICAgYCxgXFxuICAgICAgICAke3B9XFxuICAgICAgICBmbG9hdCBwcm9jZXNzKGludCBpbmRpY2VzWyR7YX1dKSB7XFxuICAgICAgICAgIGludCB4WyR7YX1dO1xcbiAgICAgICAgICBjb3B5VmVjKGluZGljZXMsIHgpO1xcbiAgICAgICAgICBpbnQgb2Zmc2V0WyR7Y31dO1xcbiAgICAgICAgICBpbnQgcGFkc1ske2x9XTtcXG4gICAgICAgICAgaW50IGlucHV0RGltc1ske2F9XTtcXG4gICAgICAgICAgaW50IGtlcm5lbFN0cmlkZXNbJHtjfV07XFxuICAgICAgICAgIGludCBzdHJpZGVzWyR7Y31dO1xcbiAgICAgICAgICAke2d9XFxuICAgICAgICAgICR7Zn1cXG4gICAgICAgICAgJHttfVxcbiAgICAgICAgICAke2J9XFxuXFxuICAgICAgICAgIGZsb2F0IHZhbHVlID0gJHtvfTtcXG4gICAgICAgICAgaW50IHBhZCA9IDA7XFxuICAgICAgICAgIGJvb2wgaXNQYWQgPSBmYWxzZTtcXG4gICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCAke3N9OyBpKyspIHtcXG4gICAgICAgICAgICBvZmZzZXRUb0luZGljZXMoaSwga2VybmVsU3RyaWRlcywgb2Zmc2V0KTtcXG4gICAgICAgICAgICBpc1BhZCA9IGZhbHNlO1xcbiAgICAgICAgICAgIGZvciAoaW50IGogPSAke2F9IC0gJHtjfTsgaiA8ICR7YX07IGorKykge1xcbiAgICAgICAgICAgICAgeFtqXSA9IGluZGljZXNbal0gKiBzdHJpZGVzW2ogLSAke2F9ICsgJHtjfV1cXG4gICAgICAgICAgICAgICAgKyBvZmZzZXRbaiAtICR7YX0gKyAke2N9XSAtIHBhZHNbaiAtIDJdO1xcbiAgICAgICAgICAgICAgJHt5fVxcbiAgICAgICAgICB9XFxuICAgICAgICAgICR7cn1cXG5cXG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xcbiAgICAgICAgfVxcbiAgICAgIGB9fSxkPSh0LGUpPT57bGV0IG49XCJcIjtmb3IobGV0IHI9MDtyPHQubGVuZ3RoO3IrKyluKz1gXFxuICAgICAgJHtlfVske3J9XSA9ICR7dFtyXX07XFxuICAgIGA7cmV0dXJuIG59LGg9dD0+YFxcbiAgdm9pZCBvZmZzZXRUb0luZGljZXMoaW50IG9mZnNldCwgaW50WyR7dH1dIHN0cmlkZXMsIG91dCBpbnRbJHt0fV0gaW5kaWNlcykge1xcbiAgICBpZiAoJHt0fSA9PSAwKSB7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuICAgIGZvciAoaW50IGkgPSAwOyBpIDwgJHt0fSAtIDE7ICsraSkge1xcbiAgICAgIGluZGljZXNbaV0gPSBvZmZzZXQgLyBzdHJpZGVzW2ldO1xcbiAgICAgIG9mZnNldCAtPSBpbmRpY2VzW2ldICogc3RyaWRlc1tpXTtcXG4gICAgfVxcbiAgICBpbmRpY2VzWyR7dH0gLSAxXSA9IG9mZnNldDtcXG4gIH1gfSw0OTM5Oih0LGUsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLnJlZHVjZUxvZ1N1bVNxdWFyZT1lLnJlZHVjZUxvZ1N1bT1lLnJlZHVjZVByb2Q9ZS5yZWR1Y2VNaW49ZS5yZWR1Y2VNYXg9ZS5yZWR1Y2VNZWFuPWUucmVkdWNlU3VtPWUucGFyc2VSZWR1Y2VBdHRyaWJ1dGVzPXZvaWQgMDtjb25zdCByPW4oMjQ2KSxpPW4oNzgyKSxvPW4oMjUxNyksYT1uKDIwMzkpLHM9KHQsZSxuLHIsaSk9PntjKGUpO2NvbnN0IG89e25hbWU6cixpbnB1dE5hbWVzOltcIkFcIl0saW5wdXRUeXBlczpbYS5UZXh0dXJlVHlwZS51bnBhY2tlZF19O3JldHVyblt0LnJ1bihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sbykse2NhY2hlSGludDpuLmNhY2hlS2V5LGdldDooKT0+dSh0LGUsbixyLGksbyl9KSxlKV19O2UucGFyc2VSZWR1Y2VBdHRyaWJ1dGVzPXQ9Pntjb25zdCBlPXQuYXR0cmlidXRlcy5nZXRJbnRzKFwiYXhlc1wiLFtdKSxuPTE9PT10LmF0dHJpYnV0ZXMuZ2V0SW50KFwia2VlcGRpbXNcIiwxKTtyZXR1cm4oMCxyLmNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSkoe2F4ZXM6ZSxrZWVwRGltczpufSl9O2NvbnN0IHU9KHQsZSxuLHIsaSxzKT0+e2NvbnN0IHU9W10sYz1lWzBdLmRpbXMubGVuZ3RofHwxLGw9W10scD1vLlNoYXBlVXRpbC5ub3JtYWxpemVBeGVzKG4uYXhlcyxlWzBdLmRpbXMubGVuZ3RoKSxmPWkoZSxwKTtsZXQgZD1mWzFdO2ZvcihsZXQgdD0wO3Q8ZVswXS5kaW1zLmxlbmd0aDt0KyspcC5pbmRleE9mKHQpPj0wfHwwPT09cC5sZW5ndGg/KG4ua2VlcERpbXMmJnUucHVzaCgxKSxkPWBcXG4gICAgICAgICAgZm9yKGludCBqJHt0fSA9IDA7IGoke3R9IDwgJHtlWzBdLmRpbXNbdF19OyBqJHt0fSsrKSB7XFxuICAgICAgICAgICAgaW5wdXRJZHhbJHt0fV0gPSBqJHt0fTtcXG4gICAgICAgICAgICAke2R9XFxuICAgICAgICAgIH1gKToobC5wdXNoKGBpbnB1dElkeFske3R9XSA9IG91dHB1dElkeFske3UubGVuZ3RofV07YCksdS5wdXNoKGVbMF0uZGltc1t0XSkpO2NvbnN0IGg9YFxcbiAgICAgIGZsb2F0IHByb2Nlc3MoaW50IG91dHB1dElkeFske3UubGVuZ3RofHwxfV0pIHtcXG4gICAgICAgIGZsb2F0IHZhbHVlOyAgICAgICAgICAgICAgICAgLy8gZmluYWwgcmVzdWx0XFxuICAgICAgICBpbnQgaW5wdXRJZHhbJHtjfV07ICAgICAgLy8gYWRkcmVzc2luZyBpbnB1dCBkYXRhXFxuICAgICAgICAke2wuam9pbihcIlxcblwiKX1cXG4gICAgICAgICR7ZlswXX0gICAgICAgLy8gaW5pdCBvcHMgZm9yIHJlZHVjZSBtYXgvbWluXFxuICAgICAgICAke2R9XFxuICAgICAgICAke2ZbMl19ICAgICAgIC8vIGZpbmFsIGNvbXB1dGF0aW9uIGZvciByZWR1Y2UgbWVhblxcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xcbiAgICAgIH1gO3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30scykse291dHB1dDp7ZGltczp1LHR5cGU6ZVswXS50eXBlLHRleHR1cmVUeXBlOmEuVGV4dHVyZVR5cGUudW5wYWNrZWR9LHNoYWRlclNvdXJjZTpofSl9LGM9dD0+e2lmKCF0fHwxIT09dC5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiUmVkdWNlIG9wIHJlcXVpcmVzIDEgaW5wdXQuXCIpO2lmKC0xPT09aS5OVU1CRVJfVFlQRVMuaW5kZXhPZih0WzBdLnR5cGUpKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW5wdXQgdHlwZS5cIil9O2UucmVkdWNlU3VtPSh0LGUsbik9PnModCxlLG4sXCJSZWR1Y2VTdW1cIiwoKCk9PltcInZhbHVlID0gMC4wO1wiLFwidmFsdWUgKz0gX0EoaW5wdXRJZHgpO1wiLFwiXCJdKSksZS5yZWR1Y2VNZWFuPSh0LGUsbik9PnModCxlLG4sXCJSZWR1Y2VNZWFuXCIsKCh0LGUpPT57bGV0IG49MTtmb3IobGV0IHI9MDtyPHRbMF0uZGltcy5sZW5ndGg7cisrKShlLmluZGV4T2Yocik+PTB8fDA9PT1lLmxlbmd0aCkmJihuKj10WzBdLmRpbXNbcl0pO3JldHVybltcInZhbHVlID0gMC4wO1wiLFwidmFsdWUgKz0gX0EoaW5wdXRJZHgpO1wiLGB2YWx1ZSAvPSAke259LjtgXX0pKSxlLnJlZHVjZU1heD0odCxlLG4pPT5zKHQsZSxuLFwiUmVkdWNlTWF4XCIsKCh0LGUpPT57Y29uc3Qgbj1bXTtmb3IobGV0IHI9MDtyPHRbMF0uZGltcy5sZW5ndGg7cisrKShlLmluZGV4T2Yocik+PTB8fDA9PT1lLmxlbmd0aCkmJm4ucHVzaChgaW5wdXRJZHhbJHtyfV0gPSAwO2ApO3JldHVybltgJHtuLmpvaW4oXCJcXG5cIil9XFxudmFsdWUgPSBfQShpbnB1dElkeCk7YCxcInZhbHVlID0gbWF4KHZhbHVlLCBfQShpbnB1dElkeCkpO1wiLFwiXCJdfSkpLGUucmVkdWNlTWluPSh0LGUsbik9PnModCxlLG4sXCJSZWR1Y2VNaW5cIiwoKHQsZSk9Pntjb25zdCBuPVtdO2ZvcihsZXQgcj0wO3I8dFswXS5kaW1zLmxlbmd0aDtyKyspKGUuaW5kZXhPZihyKT49MHx8MD09PWUubGVuZ3RoKSYmbi5wdXNoKGBpbnB1dElkeFske3J9XSA9IDA7YCk7cmV0dXJuW2Ake24uam9pbihcIlxcblwiKX1cXG52YWx1ZSA9IF9BKGlucHV0SWR4KTtgLFwidmFsdWUgPSBtaW4odmFsdWUsIF9BKGlucHV0SWR4KSk7XCIsXCJcIl19KSksZS5yZWR1Y2VQcm9kPSh0LGUsbik9PnModCxlLG4sXCJSZWR1Y2VQcm9kXCIsKCgpPT5bXCJ2YWx1ZSA9IDEuMDtcIixcInZhbHVlICo9IF9BKGlucHV0SWR4KTtcIixcIlwiXSkpLGUucmVkdWNlTG9nU3VtPSh0LGUsbik9PnModCxlLG4sXCJSZWR1Y2VMb2dTdW1cIiwoKCk9PltcInZhbHVlID0gMC4wO1wiLFwidmFsdWUgKz0gX0EoaW5wdXRJZHgpO1wiLFwidmFsdWUgPSBsb2codmFsdWUpO1wiXSkpLGUucmVkdWNlTG9nU3VtU3F1YXJlPSh0LGUsbik9PnModCxlLG4sXCJSZWR1Y2VMb2dTdW1TcXVhcmVcIiwoKCk9PltcImZsb2F0IHQ7IHZhbHVlID0gMC4wO1wiLFwidCA9IF9BKGlucHV0SWR4KTsgdmFsdWUgKz0gdCAqIHQ7XCIsXCJcIl0pKX0sNzAxOToodCxlLG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5pc1Jlc2hhcGVDaGVhcD1lLnByb2Nlc3NEaW1zM0Q9ZS5jcmVhdGVQYWNrZWRSZXNoYXBlM0RQcm9ncmFtSW5mb0xvYWRlcj12b2lkIDA7Y29uc3Qgcj1uKDI1MTcpLGk9big1MDYwKSxvPW4oMjAzOSksYT1uKDI4MjcpO2UuY3JlYXRlUGFja2VkUmVzaGFwZTNEUHJvZ3JhbUluZm9Mb2FkZXI9KHQsZSxuKT0+e2NvbnN0IHM9KHQ9Pih7bmFtZTpcIlJlc2hhcGUgKHBhY2tlZClcIixpbnB1dFR5cGVzOltvLlRleHR1cmVUeXBlLnBhY2tlZF0saW5wdXROYW1lczpbXCJBXCJdLGNhY2hlSGludDpgJHt0fWB9KSkobik7cmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxzKSx7Z2V0OigpPT4oKHQsZSxuLHMpPT57Y29uc3QgdT1lLmRpbXMsYz1zO2xldCBsPVwiXCI7Zm9yKGxldCB0PTA7dDw0O3QrKyl7bGV0IGU9XCJcIjtzd2l0Y2godCl7Y2FzZSAwOmU9XCJvdXRwdXRDb29yZHMgPSByYztcIjticmVhaztjYXNlIDE6ZT1cIm91dHB1dENvb3JkcyA9IGl2ZWMzKHJjLngsIHJjLnkrMSwgcmMueik7XCI7YnJlYWs7Y2FzZSAyOmU9XCJvdXRwdXRDb29yZHMgPSBpdmVjMyhyYy54LCByYy55LCByYy56KzEpO1wiO2JyZWFrO2Nhc2UgMzplPVwib3V0cHV0Q29vcmRzID0gaXZlYzMocmMueCwgcmMueSsxLCByYy56KzEpO1wiO2JyZWFrO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yfWwrPWBcXG4gICAgICAgICR7ZX1cXG4gICAgICAgICR7dD4wP1wiaWYob3V0cHV0Q29vcmRzLnkgPCByb3dzICYmIG91dHB1dENvb3Jkcy56IDwgY29scyl7XCI6XCJcIn1cXG4gICAgICAgICAgaW50IGZsYXR0ZW5lZEluZGV4ID0gZ2V0RmxhdHRlbmVkSW5kZXgob3V0cHV0Q29vcmRzKTtcXG5cXG4gICAgICAgICAgaXZlYzMgaW5wdXRSQyA9IGlucHV0Q29vcmRzRnJvbVJlc2hhcGVkT3V0Q29vcmRzKGZsYXR0ZW5lZEluZGV4KTtcXG4gICAgICAgICAgdmVjMiBpbm5lckRpbXMgPSB2ZWMyKGZsb2F0KGlucHV0UkMueSksZmxvYXQoaW5wdXRSQy56KSk7XFxuXFxuICAgICAgICAgIHJlc3VsdFske3R9XSA9IGdldENoYW5uZWwoZ2V0QShpbnB1dFJDLngsIGlucHV0UkMueSwgaW5wdXRSQy56KSwgaW5uZXJEaW1zKTtcXG5cXG4gICAgICAgICR7dD4wP1wifVwiOlwiXCJ9XFxuICAgICAgYH1jb25zdCBwPSgwLGkuZ2V0R2xzbCkodC5zZXNzaW9uLmJhY2tlbmQuZ2xDb250ZXh0LnZlcnNpb24pLGY9YFxcbiAgICAgICR7ZnVuY3Rpb24odCl7Y29uc3QgZT1yLlNoYXBlVXRpbC5jb21wdXRlU3RyaWRlcyh0KSxuPVtcImJcIixcInJcIixcImNcIl0saT1cImluZGV4XCI7cmV0dXJuYFxcbiAgICBpdmVjMyBpbnB1dENvb3Jkc0Zyb21SZXNoYXBlZE91dENvb3JkcyhpbnQgaW5kZXgpIHtcXG4gICAgICAke2UubWFwKCgodCxyKT0+YGludCAke25bcl19ID0gJHtpfSAvICR7dH07ICR7cj09PWUubGVuZ3RoLTE/YGludCAke25bcisxXX0gPSAke2l9IC0gJHtuW3JdfSAqICR7dH1gOmBpbmRleCAtPSAke25bcl19ICogJHt0fWB9O2ApKS5qb2luKFwiXCIpfVxcbiAgICAgIHJldHVybiBpdmVjMyhiLCByLCBjKTtcXG4gICAgfVxcbiAgYH0odSl9XFxuICAgICAgJHtmdW5jdGlvbih0KXtjb25zdCBlPXIuU2hhcGVVdGlsLmNvbXB1dGVTdHJpZGVzKHQpO3JldHVybmBcXG4gIGludCBnZXRGbGF0dGVuZWRJbmRleChpdmVjMyBjb29yZHMpIHtcXG4gICAgLy8gcmV2ZXJzZSB5LCB6IG9yZGVyXFxuICAgIHJldHVybiBjb29yZHMueCAqICR7ZVswXX0gKyBjb29yZHMueiAqICR7ZVsxXX0gKyBjb29yZHMueTtcXG4gIH1cXG5gfShjKX1cXG4gICAgICAkeygwLGEudW5wYWNrRnJvbUNoYW5uZWwpKCl9XFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzMgcmMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG5cXG4gICAgICAgIHZlYzQgcmVzdWx0ID0gdmVjNCgwLjApO1xcblxcbiAgICAgICAgaXZlYzMgb3V0cHV0Q29vcmRzO1xcbiAgICAgICAgaW50IHJvd3MgPSAke2NbMl19O1xcbiAgICAgICAgaW50IGNvbHMgPSAke2NbMV19O1xcblxcbiAgICAgICAgJHtsfVxcbiAgICAgICAgJHtwLm91dHB1dH0gPSByZXN1bHQ7XFxuICAgICAgfVxcbiAgICBgO3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sbikse291dHB1dDp7ZGltczpjLHR5cGU6ZS50eXBlLHRleHR1cmVUeXBlOm8uVGV4dHVyZVR5cGUucGFja2VkfSxzaGFkZXJTb3VyY2U6ZixoYXNNYWluOiEwfSl9KSh0LGUscyxuKX0pfSxlLnByb2Nlc3NEaW1zM0Q9ZnVuY3Rpb24odCl7aWYoMD09PXQubGVuZ3RoKXJldHVyblsxLDEsMV07bGV0IGU9MTtmb3IobGV0IG49MDtuPHQubGVuZ3RoLTI7KytuKWUqPXRbbl07cmV0dXJuW2UsdC5sZW5ndGg+MT90W3QubGVuZ3RoLTJdOjEsdFt0Lmxlbmd0aC0xXV19LGUuaXNSZXNoYXBlQ2hlYXA9ZnVuY3Rpb24odCxlKXtsZXQgbj0hMTtyZXR1cm4gbj0wPT09dC5sZW5ndGh8fDA9PT1lLmxlbmd0aHx8KHQubGVuZ3RoPDJ8fGUubGVuZ3RoPDI/dFt0Lmxlbmd0aC0xXT09PWVbZS5sZW5ndGgtMV06dFt0Lmxlbmd0aC0xXT09PWVbZS5sZW5ndGgtMV0mJnRbdC5sZW5ndGgtMl09PT1lW2UubGVuZ3RoLTJdKSxufX0sNzE4Oih0LGUsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLnJlc2hhcGU9dm9pZCAwO2NvbnN0IHI9bigyNTE3KTtlLnJlc2hhcGU9KHQsZSk9Pntjb25zdCBuPXIuU2hhcGVVdGlsLmNhbGN1bGF0ZVJlc2hhcGVkRGltcyhlWzBdLmRpbXMsZVsxXS5pbnRlZ2VyRGF0YSk7cmV0dXJuIHQuc2Vzc2lvbi5wYWNrP1t0LnJlc2hhcGVQYWNrZWQoZVswXSxuKV06W3QucmVzaGFwZVVucGFja2VkKGVbMF0sbildfX0sMjI2ODoodCxlLG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5wYXJzZVJlc2l6ZUF0dHJpYnV0ZXNWMTE9ZS5wYXJzZVJlc2l6ZUF0dHJpYnV0ZXNWMTA9ZS5yZXNpemU9dm9pZCAwO2NvbnN0IHI9big1MDYwKSxpPW4oMjAzOSksbz1uKDkzOTApLGE9bigyODI3KSxzPW4oOTc5MyksdT17bmFtZTpcIlJlc2l6ZVwiLGlucHV0TmFtZXM6W1wiQVwiXSxpbnB1dFR5cGVzOltpLlRleHR1cmVUeXBlLnBhY2tlZF19O2UucmVzaXplPSh0LGUsbik9PigoMCxzLnZhbGlkYXRlSW5wdXRzKShlLG4pLFt0LnJ1bihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sdSkse2NhY2hlSGludDpuLmNhY2hlS2V5LGdldDooKT0+Yyh0LGUsbil9KSxlKV0pLGUucGFyc2VSZXNpemVBdHRyaWJ1dGVzVjEwPXQ9PigwLHMucGFyc2VVcHNhbXBsZUF0dHJpYnV0ZXMpKHQsMTApLGUucGFyc2VSZXNpemVBdHRyaWJ1dGVzVjExPXQ9PigwLHMucGFyc2VVcHNhbXBsZUF0dHJpYnV0ZXMpKHQsMTEpO2NvbnN0IGM9KHQsZSxuKT0+e2NvbnN0IHM9KDAsci5nZXRHbHNsKSh0LnNlc3Npb24uYmFja2VuZC5nbENvbnRleHQudmVyc2lvbiksW2MscF09bChlLG4pO2lmKGMuZXZlcnkoKHQ9PjE9PT10KSkmJlwidGZfY3JvcF9hbmRfcmVzaXplXCIhPT1uLmNvb3JkaW5hdGVUcmFuc2Zvcm1Nb2RlKXJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sdSkse291dHB1dDp7ZGltczpwLHR5cGU6ZVswXS50eXBlLHRleHR1cmVUeXBlOmkuVGV4dHVyZVR5cGUucGFja2VkfSxoYXNNYWluOiEwLHNoYWRlclNvdXJjZTpgdm9pZCBtYWluKCkge1xcbiAgICAgICAgICAgICAgICAgICAgdmVjNCB2ID0gJHtzLnRleHR1cmUyRH0oWCwgVGV4Q29vcmRzKTtcXG4gICAgICAgICAgICAgICAgICAgICR7cy5vdXRwdXR9ID0gdjtcXG4gICAgICAgICAgICAgICAgfWB9KTtjb25zdCBmPXAubGVuZ3RoO2lmKGY8Mil0aHJvdyBuZXcgRXJyb3IoYG91dHB1dCBkaW1lbnNpb24gc2hvdWxkIGJlIGF0IGxlYXN0IDIsIGJ1dCBnb3QgJHtmfWApO2NvbnN0IGQ9cFtmLTJdLGg9cFtmLTFdLGc9ZVswXS5kaW1zO2lmKGYhPT1nLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoYG91dHB1dCBkaW1lbnNpb24gc2hvdWxkIG1hdGNoIGlucHV0ICR7Zy5sZW5ndGh9LCBidXQgZ290ICR7Zn1gKTtjb25zdCBiPWdbZi0yXSxtPWdbZi0xXSx5PWNbZi0yXSxfPWNbZi0xXTtsZXQgdj1cIlwiO2lmKFwibGluZWFyXCIhPT1uLm1vZGUpdGhyb3cgbmV3IEVycm9yKGByZXNpemUgKHBhY2tlZCkgZG9lcyBub3Qgc3VwcG9ydCBtb2RlOiAnJHtuLm1vZGV9J2ApO3N3aXRjaChuLmNvb3JkaW5hdGVUcmFuc2Zvcm1Nb2RlKXtjYXNlXCJhc3ltbWV0cmljXCI6dj1cIlxcbiAgICAgICAgICAgICAgICAgICAgdmVjNCBnZXRTb3VyY2VGcmFjSW5kZXgoaXZlYzQgY29vcmRzKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZlYzQoY29vcmRzKSAvIHNjYWxlV0hXSDtcXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgXCI7YnJlYWs7Y2FzZVwiaGFsZl9waXhlbFwiOnY9XCJcXG4gICAgICAgICAgICAgICAgICAgIHZlYzQgZ2V0U291cmNlRnJhY0luZGV4KGl2ZWM0IGNvb3Jkcykge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAodmVjNChjb29yZHMpICsgMC41KSAvIHNjYWxlV0hXSCAtIDAuNTtcXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgXCI7YnJlYWs7Y2FzZVwicHl0b3JjaF9oYWxmX3BpeGVsXCI6dj1gXFxuICAgICAgICAgICAgICAgICAgICB2ZWM0IGdldFNvdXJjZUZyYWNJbmRleChpdmVjNCBjb29yZHMpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICB2ZWM0IGZjb29yZHMgPSB2ZWM0KGNvb3Jkcyk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZlYzQoXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICR7aH0uMCA+IDEuMCA/IChmY29vcmRzLnggKyAwLjUpIC8gc2NhbGVXSFdILnggLSAwLjUgOiAwLjAsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICR7ZH0uMCA+IDEuMCA/IChmY29vcmRzLnkgKyAwLjUpIC8gc2NhbGVXSFdILnkgLSAwLjUgOiAwLjAsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICR7aH0uMCA+IDEuMCA/IChmY29vcmRzLnogKyAwLjUpIC8gc2NhbGVXSFdILnogLSAwLjUgOiAwLjAsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICR7ZH0uMCA+IDEuMCA/IChmY29vcmRzLncgKyAwLjUpIC8gc2NhbGVXSFdILncgLSAwLjUgOiAwLjBcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICk7XFxuICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIGA7YnJlYWs7Y2FzZVwiYWxpZ25fY29ybmVyc1wiOnY9YFxcbiAgICAgICAgICAgICAgICAgICAgdmVjNCBnZXRTb3VyY2VGcmFjSW5kZXgoaXZlYzQgY29vcmRzKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgdmVjNCByZXNpemVkID0gdmVjNCgke2h9LjAgLSAxLjAsICR7ZH0uMCAtIDEuMCwgJHtofS4wIC0gMS4wLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAke2R9LjAgLSAxLjApO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlYzQgb3JpZ2luYWwgPSB2ZWM0KCR7bX0uMCAtIDEuMCwgJHtifS4wIC0gMS4wLCAke219LjAgLSAxLjAsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICR7Yn0uMCAtIDEuMCk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgdmVjNCBuZXdfc2NhbGUgPSBvcmlnaW5hbCAvIHJlc2l6ZWQ7XFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZlYzQoY29vcmRzKSAqIG5ld19zY2FsZTtcXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgYDticmVhaztkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgcmVzaXplIChwYWNrZWQpIGRvZXMgbm90IHN1cHBvcnQgY29vcmRpbmF0ZVRyYW5zZm9ybU1vZGU6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJyR7bi5jb29yZGluYXRlVHJhbnNmb3JtTW9kZX0nYCl9Y29uc3Qgdz0oMCxvLmdldENvb3Jkc0RhdGFUeXBlKShmKSx4PWBcXG4gICAgICAgICAgICBjb25zdCB2ZWMyIGlucHV0V0ggPSB2ZWMyKCR7Yn0uMCwgJHttfS4wKTtcXG4gICAgICAgICAgICBjb25zdCB2ZWM0IHNjYWxlV0hXSCA9IHZlYzQoZmxvYXQoJHt5fSksIGZsb2F0KCR7X30pLCBmbG9hdCgke3l9KSwgZmxvYXQoJHtffSkpO1xcbiAgICAgICAgICAgICR7KDAsYS51bnBhY2tGcm9tQ2hhbm5lbCkoKX1cXG4gICAgICAgICAgICAke3Z9XFxuICAgICAgICAgICAgZmxvYXQgZ2V0QVZhbHVlKGludCB4MTAsIGludCByLCBpbnQgYywgaW50IGQpIHtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldENoYW5uZWwoZ2V0QSh4MTAsIHIsIGMsIGQpLCB2ZWMyKGMsIGQpKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgICAgICAgICAke3d9IHJjID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuXFxuICAgICAgICAgICAgICAgIGludCBiYXRjaCA9IHJjWzBdO1xcbiAgICAgICAgICAgICAgICBpbnQgZGVwdGggPSByY1sxXTtcXG5cXG4gICAgICAgICAgICAgICAgLy8gcmV0cmlldmUgdGhlIDQgY29vcmRpbmF0ZXMgdGhhdCBpcyB1c2VkIGluIHRoZSA0IHBhY2tlZCBvdXRwdXQgdmFsdWVzLlxcbiAgICAgICAgICAgICAgICBpdmVjNCBjb29yZHMgPSBpdmVjNChyYy53eiwgcmMudyArIDEsIHJjLnogKyAxKTtcXG5cXG4gICAgICAgICAgICAgICAgLy8gY2FsY3VsYXRlIHRoZSBzb3VyY2UgaW5kZXggaW4gZnJhY3Rpb25cXG4gICAgICAgICAgICAgICAgdmVjNCBzb3VyY2VGcmFjID0gZ2V0U291cmNlRnJhY0luZGV4KGNvb3Jkcyk7XFxuXFxuICAgICAgICAgICAgICAgIC8vIGdldCB0aGUgbG93ZXIgYW5kIHVwcGVyIGJvdW5kIG9mIHRoZSA0IHZhbHVlcyB0aGF0IHdpbGwgYmUgcGFja2VkIGludG8gb25lIHRleGVsLlxcbiAgICAgICAgICAgICAgICBpdmVjNCB4MDAgPSBpdmVjNChtYXgoc291cmNlRnJhYy54eSwgdmVjMigwLjApKSwgbWluKGlucHV0V0ggLSAxLjAsIGNlaWwoc291cmNlRnJhYy54eSkpKTtcXG4gICAgICAgICAgICAgICAgaXZlYzQgeDAxID0gaXZlYzQobWF4KHNvdXJjZUZyYWMueHcsIHZlYzIoMC4wKSksIG1pbihpbnB1dFdIIC0gMS4wLCBjZWlsKHNvdXJjZUZyYWMueHcpKSk7XFxuICAgICAgICAgICAgICAgIGl2ZWM0IHgxMCA9IGl2ZWM0KG1heChzb3VyY2VGcmFjLnp5LCB2ZWMyKDAuMCkpLCBtaW4oaW5wdXRXSCAtIDEuMCwgY2VpbChzb3VyY2VGcmFjLnp5KSkpO1xcbiAgICAgICAgICAgICAgICBpdmVjNCB4MTEgPSBpdmVjNChtYXgoc291cmNlRnJhYy56dywgdmVjMigwLjApKSwgbWluKGlucHV0V0ggLSAxLjAsIGNlaWwoc291cmNlRnJhYy56dykpKTtcXG5cXG4gICAgICAgICAgICAgICAgYm9vbCBoYXNOZXh0Um93ID0gcmMudyA8ICR7ZC0xfTtcXG4gICAgICAgICAgICAgICAgYm9vbCBoYXNOZXh0Q29sID0gcmMueiA8ICR7aC0xfTtcXG5cXG4gICAgICAgICAgICAgICAgLy8gcGFjayB4MDAsIHgwMSwgeDEwLCB4MTEncyB0b3AtbGVmdCBjb3JuZXIgaW50byBvbmUgdmVjNCBzdHJ1Y3R1cmVcXG4gICAgICAgICAgICAgICAgdmVjNCB0b3BMZWZ0ID0gdmVjNChcXG4gICAgICAgICAgICAgICAgICAgIGdldEFWYWx1ZShiYXRjaCwgZGVwdGgsIHgwMC54LCB4MDAueSksXFxuICAgICAgICAgICAgICAgICAgICBoYXNOZXh0Q29sID8gZ2V0QVZhbHVlKGJhdGNoLCBkZXB0aCwgeDAxLngsIHgwMS55KSA6IDAuMCxcXG4gICAgICAgICAgICAgICAgICAgIGhhc05leHRSb3cgPyBnZXRBVmFsdWUoYmF0Y2gsIGRlcHRoLCB4MTAueCwgeDEwLnkpIDogMC4wLFxcbiAgICAgICAgICAgICAgICAgICAgKGhhc05leHRSb3cgJiYgaGFzTmV4dENvbCkgPyBnZXRBVmFsdWUoYmF0Y2gsIGRlcHRoLCB4MTEueCwgeDExLnkpIDogMC4wKTtcXG5cXG4gICAgICAgICAgICAgICAgLy8gcGFjayB4MDAsIHgwMSwgeDEwLCB4MTEncyB0b3AtcmlnaHQgY29ybmVyIGludG8gb25lIHZlYzQgc3RydWN0dXJlXFxuICAgICAgICAgICAgICAgIHZlYzQgdG9wUmlnaHQgPSB2ZWM0KFxcbiAgICAgICAgICAgICAgICAgICAgZ2V0QVZhbHVlKGJhdGNoLCBkZXB0aCwgeDAwLngsIHgwMC53KSxcXG4gICAgICAgICAgICAgICAgICAgIGhhc05leHRDb2wgPyBnZXRBVmFsdWUoYmF0Y2gsIGRlcHRoLCB4MDEueCwgeDAxLncpIDogMC4wLFxcbiAgICAgICAgICAgICAgICAgICAgaGFzTmV4dFJvdyA/IGdldEFWYWx1ZShiYXRjaCwgZGVwdGgsIHgxMC54LCB4MTAudykgOiAwLjAsXFxuICAgICAgICAgICAgICAgICAgICAoaGFzTmV4dFJvdyAmJiBoYXNOZXh0Q29sKSA/IGdldEFWYWx1ZShiYXRjaCwgZGVwdGgsIHgxMS54LCB4MTEudykgOiAwLjApO1xcblxcbiAgICAgICAgICAgICAgICAvLyBwYWNrIHgwMCwgeDAxLCB4MTAsIHgxMSdzIGJvdHRvbS1sZWZ0IGNvcm5lciBpbnRvIG9uZSB2ZWM0IHN0cnVjdHVyZVxcbiAgICAgICAgICAgICAgICB2ZWM0IGJvdHRvbUxlZnQgPSB2ZWM0KFxcbiAgICAgICAgICAgICAgICAgICAgZ2V0QVZhbHVlKGJhdGNoLCBkZXB0aCwgeDAwLnosIHgwMC55KSxcXG4gICAgICAgICAgICAgICAgICAgIGhhc05leHRDb2wgPyBnZXRBVmFsdWUoYmF0Y2gsIGRlcHRoLCB4MDEueiwgeDAxLnkpIDogMC4wLFxcbiAgICAgICAgICAgICAgICAgICAgaGFzTmV4dFJvdyA/IGdldEFWYWx1ZShiYXRjaCwgZGVwdGgsIHgxMC56LCB4MTAueSkgOiAwLjAsXFxuICAgICAgICAgICAgICAgICAgICAoaGFzTmV4dFJvdyAmJiBoYXNOZXh0Q29sKSA/IGdldEFWYWx1ZShiYXRjaCwgZGVwdGgsIHgxMS56LCB4MTEueSkgOiAwLjApO1xcblxcbiAgICAgICAgICAgICAgICAvLyBwYWNrIHgwMCwgeDAxLCB4MTAsIHgxMSdzIGJvdHRvbS1yaWdodCBjb3JuZXIgaW50byBvbmUgdmVjNCBzdHJ1Y3R1cmVcXG4gICAgICAgICAgICAgICAgdmVjNCBib3R0b21SaWdodCA9IHZlYzQoXFxuICAgICAgICAgICAgICAgICAgICBnZXRBVmFsdWUoYmF0Y2gsIGRlcHRoLCB4MDAueiwgeDAwLncpLFxcbiAgICAgICAgICAgICAgICAgICAgaGFzTmV4dENvbCA/IGdldEFWYWx1ZShiYXRjaCwgZGVwdGgsIHgwMS56LCB4MDEudykgOiAwLjAsXFxuICAgICAgICAgICAgICAgICAgICBoYXNOZXh0Um93ID8gZ2V0QVZhbHVlKGJhdGNoLCBkZXB0aCwgeDEwLnosIHgxMC53KSA6IDAuMCxcXG4gICAgICAgICAgICAgICAgICAgIChoYXNOZXh0Um93ICYmIGhhc05leHRDb2wpID8gZ2V0QVZhbHVlKGJhdGNoLCBkZXB0aCwgeDExLnosIHgxMS53KSA6IDAuMCk7XFxuXFxuICAgICAgICAgICAgICAgIC8vIGNhbGN1bGF0ZSB0aGUgaW50ZXJwb2xhdGlvbiBmcmFjdGlvbiBvbiB1IGFuZCB2IGRpcmVjdGlvblxcbiAgICAgICAgICAgICAgICB2ZWM0IGZyYWMgPSB2ZWM0KHNvdXJjZUZyYWMpIC0gZmxvb3Ioc291cmNlRnJhYyk7XFxuICAgICAgICAgICAgICAgIHZlYzQgY2xhbXBGcmFjID0gY2xhbXAoZnJhYywgdmVjNCgwLjApLCB2ZWM0KDEuMCkpO1xcblxcbiAgICAgICAgICAgICAgICB2ZWM0IHRvcCA9IG1peCh0b3BMZWZ0LCB0b3BSaWdodCwgY2xhbXBGcmFjLnl3eXcpO1xcbiAgICAgICAgICAgICAgICB2ZWM0IGJvdHRvbSA9IG1peChib3R0b21MZWZ0LCBib3R0b21SaWdodCwgY2xhbXBGcmFjLnl3eXcpO1xcbiAgICAgICAgICAgICAgICB2ZWM0IG5ld1ZhbHVlID0gbWl4KHRvcCwgYm90dG9tLCBjbGFtcEZyYWMueHh6eik7XFxuXFxuICAgICAgICAgICAgICAgICR7cy5vdXRwdXR9ID0gdmVjNChuZXdWYWx1ZSk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgYDtyZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LHUpLHtvdXRwdXQ6e2RpbXM6cCx0eXBlOmVbMF0udHlwZSx0ZXh0dXJlVHlwZTppLlRleHR1cmVUeXBlLnBhY2tlZH0saGFzTWFpbjohMCxzaGFkZXJTb3VyY2U6eH0pfSxsPSh0LGUpPT57Y29uc3Qgbj10WzBdLmRpbXM7bGV0IHIsaT1lLnNjYWxlcztpZigwPT09aS5sZW5ndGgpe2NvbnN0IG89dFtlLnNjYWxlc0lucHV0SWR4XTtpZihvJiYwIT09by5zaXplKXtpZih0W2Uuc2l6ZXNJbnB1dElkeF0pdGhyb3cgbmV3IEVycm9yKFwiT25seSBvbmUgb2Ygc2NhbGVzIG9yIHNpemVzIG11c3QgYmUgcHJvdmlkZWQgYXMgaW5wdXQuXCIpO2k9cChvLGUubW9kZSxlLmlzUmVzaXplKX1lbHNle2NvbnN0IG89dFtlLnNpemVzSW5wdXRJZHhdO2lmKCFvfHwwPT09by5zaXplKXRocm93IG5ldyBFcnJvcihcIkVpdGhlciBzY2FsZXMgb3Igc2l6ZXMgTVVTVCBiZSBwcm92aWRlZCBhcyBpbnB1dC5cIik7cj1BcnJheS5mcm9tKG8uaW50ZWdlckRhdGEpLGk9ZihyLG4sZS5tb2RlLGUuaXNSZXNpemUpfX1lbHNlIGlmKHRbZS5zaXplc0lucHV0SWR4XSl0aHJvdyBuZXcgRXJyb3IoXCJPbmx5IG9uZSBvZiBzY2FsZXMgb3Igc2l6ZXMgbXVzdCBiZSBwcm92aWRlZCBhcyBpbnB1dC5cIik7Y29uc3Qgbz1yfHxuLm1hcCgoKHQsZSk9Pk1hdGguZmxvb3IodCppW2VdKSkpO3JldHVybltpLG9dfSxwPSh0LGUsbik9Pntjb25zdCByPUFycmF5LmZyb20odC5mbG9hdERhdGEpO3JldHVybigwLHMuc2NhbGVzVmFsaWRhdGlvbikocixlLG4pLHJ9LGY9KHQsZSxuLHIpPT57Y29uc3QgaT1lLmxlbmd0aCxvPW5ldyBBcnJheShpKTtmb3IobGV0IG49MCxyPWk7bjxyO24rKylpZigwPT09ZVtuXSl7aWYoMCE9PXRbbl0pdGhyb3cgbmV3IEVycm9yKFwiSW5wdXQgZGltIGlzIHplcm8gYnV0IHJlcXVpcmVkIG91dHB1dCBkaW0gaXMgbm9uLXplcm8uXCIpO29bbl09MX1lbHNlIG9bbl09dFtuXS9lW25dO3JldHVybigwLHMuc2NhbGVzVmFsaWRhdGlvbikobyxuLHIpLG99fSw4MTE3Oih0LGUsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLnNoYXBlPXZvaWQgMDtjb25zdCByPW4oOTE2Mik7ZS5zaGFwZT0odCxlKT0+KGkoZSksW25ldyByLlRlbnNvcihbZVswXS5kaW1zLmxlbmd0aF0sXCJpbnQzMlwiLHZvaWQgMCx2b2lkIDAsbmV3IEludDMyQXJyYXkoZVswXS5kaW1zKSldKTtjb25zdCBpPXQ9PntpZighdHx8MSE9PXQubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIlNoYXBlIHJlcXVpcmVzIDEgaW5wdXQuXCIpfX0sMjI3ODoodCxlLG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5zbGljZVYxMD1lLnBhcnNlU2xpY2VBdHRyaWJ1dGVzPWUuc2xpY2U9dm9pZCAwO2NvbnN0IHI9bigyNDYpLGk9big3ODIpLG89bigyNTE3KSxhPW4oMjAzOSkscz17bmFtZTpcIlNsaWNlXCIsaW5wdXROYW1lczpbXCJBXCJdLGlucHV0VHlwZXM6W2EuVGV4dHVyZVR5cGUudW5wYWNrZWRdfTtlLnNsaWNlPSh0LGUsbik9PihjKGUpLFt0LnJ1bihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30scykse2NhY2hlSGludDpuLmNhY2hlS2V5LGdldDooKT0+dSh0LGVbMF0sbil9KSxlKV0pLGUucGFyc2VTbGljZUF0dHJpYnV0ZXM9dD0+e2NvbnN0IGU9dC5hdHRyaWJ1dGVzLmdldEludHMoXCJzdGFydHNcIiksbj10LmF0dHJpYnV0ZXMuZ2V0SW50cyhcImVuZHNcIiksaT10LmF0dHJpYnV0ZXMuZ2V0SW50cyhcImF4ZXNcIixbXSk7cmV0dXJuKDAsci5jcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkpKHtzdGFydHM6ZSxlbmRzOm4sYXhlczppfSl9O2NvbnN0IHU9KHQsZSxuKT0+e2NvbnN0IHI9MD09PW4uYXhlcy5sZW5ndGg/ZS5kaW1zLnNsaWNlKDApLm1hcCgoKHQsZSk9PmUpKTpuLmF4ZXMsaT1vLlNoYXBlVXRpbC5ub3JtYWxpemVBeGVzKHIsZS5kaW1zLmxlbmd0aCksdT1uLnN0YXJ0cy5tYXAoKCh0LG4pPT50PmUuZGltc1tpW25dXS0xP2UuZGltc1tpW25dXTpvLlNoYXBlVXRpbC5ub3JtYWxpemVBeGlzKHQsZS5kaW1zW2lbbl1dKSkpLGM9bi5lbmRzLm1hcCgoKHQsbik9PnQ+ZS5kaW1zW2lbbl1dLTE/ZS5kaW1zW2lbbl1dOm8uU2hhcGVVdGlsLm5vcm1hbGl6ZUF4aXModCxlLmRpbXNbaVtuXV0pKSksbD1lLmRpbXMuc2xpY2UoKSxwPVtdO2ZvcihsZXQgdD0wO3Q8aS5sZW5ndGg7dCsrKWxbaVt0XV09Y1t0XS11W3RdLHVbdF0+MCYmcC5wdXNoKGBvdXRwdXRJZHhbJHtpW3RdfV0gKz0gJHt1W3RdfTtgKTtjb25zdCBmPWBcXG4gICAgICBmbG9hdCBwcm9jZXNzKGludCBvdXRwdXRJZHhbJHtsLmxlbmd0aH1dKSB7XFxuICAgICAgICAke3Auam9pbihcIlxcbiAgICAgIFwiKX1cXG4gICAgICAgIHJldHVybiBfQShvdXRwdXRJZHgpO1xcbiAgICAgIH1gO3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30scykse291dHB1dDp7ZGltczpsLHR5cGU6ZS50eXBlLHRleHR1cmVUeXBlOmEuVGV4dHVyZVR5cGUudW5wYWNrZWR9LHNoYWRlclNvdXJjZTpmfSl9LGM9dD0+e2lmKCF0fHwxIT09dC5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiU2xpY2UgcmVxdWlyZXMgMSBpbnB1dC5cIik7aWYoLTE9PT1pLk5VTUJFUl9UWVBFUy5pbmRleE9mKHRbMF0udHlwZSkpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpbnB1dCB0eXBlLlwiKX07ZS5zbGljZVYxMD0odCxlKT0+e3AoZSk7Y29uc3Qgbj1sKHQsZSk7cmV0dXJuW3QucnVuKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxzKSx7Y2FjaGVIaW50Om4uY2FjaGVLZXksZ2V0OigpPT51KHQsZVswXSxuKX0pLFtlWzBdXSldfTtjb25zdCBsPSh0LGUpPT57aWYoIXQuc2Vzc2lvbi5pc0luaXRpYWxpemVyKGVbMV0uZGF0YUlkKXx8IXQuc2Vzc2lvbi5pc0luaXRpYWxpemVyKGVbMl0uZGF0YUlkKXx8ZS5sZW5ndGg+PTQmJiF0LnNlc3Npb24uaXNJbml0aWFsaXplcihlWzNdLmRhdGFJZCl8fGUubGVuZ3RoPj01JiYhdC5zZXNzaW9uLmlzSW5pdGlhbGl6ZXIoZVs0XS5kYXRhSWQpKXRocm93IG5ldyBFcnJvcihcImR5bmFtaWMgc2xpY2UgYXR0cmlidXRlcyBhcmUgbm90IGFsbG93ZWRcIik7aWYoZS5sZW5ndGg+PTUmJmVbNF0uaW50ZWdlckRhdGEuc29tZSgodD0+MSE9PXQpKSl0aHJvdyBuZXcgRXJyb3IoXCJjdXJyZW50bHkgbm9uLTEgc3RlcHMgaXMgbm90IHN1cHBvcnRlZCBmb3IgU2xpY2VcIik7Y29uc3Qgbj1BcnJheS5mcm9tKGVbMV0uaW50ZWdlckRhdGEpLHI9QXJyYXkuZnJvbShlWzJdLmludGVnZXJEYXRhKSxpPWUubGVuZ3RoPj00P0FycmF5LmZyb20oZVszXS5pbnRlZ2VyRGF0YSk6W107cmV0dXJue3N0YXJ0czpuLGVuZHM6cixheGVzOmksY2FjaGVLZXk6YCR7aX07JHtufTske3J9YH19LHA9dD0+e2lmKCF0fHx0Lmxlbmd0aDwzfHx0Lmxlbmd0aD41KXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW5wdXQgbnVtYmVyLlwiKTtpZihcImludDMyXCIhPT10WzFdLnR5cGV8fDEhPT10WzFdLmRpbXMubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW5wdXQgdHlwZS5cIik7aWYoXCJpbnQzMlwiIT09dFsyXS50eXBlfHwxIT09dFsyXS5kaW1zLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGlucHV0IHR5cGUuXCIpO2lmKHQubGVuZ3RoPj00JiYoXCJpbnQzMlwiIT09dFszXS50eXBlfHwxIT09dFszXS5kaW1zLmxlbmd0aCkpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpbnB1dCB0eXBlLlwiKTtpZih0Lmxlbmd0aD49NSYmKFwiaW50MzJcIiE9PXRbNF0udHlwZXx8MSE9PXRbNF0uZGltcy5sZW5ndGgpKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW5wdXQgdHlwZS5cIil9fSw1NTI0Oih0LGUsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLnNvZnRtYXhWMTM9ZS5wYXJzZVNvZnRtYXhBdHRyaWJ1dGVzVjEzPWUucGFyc2VTb2Z0bWF4QXR0cmlidXRlcz1lLnNvZnRtYXg9dm9pZCAwO2NvbnN0IHI9bigyNDYpLGk9bigyNTE3KSxvPW4oNTA2MCksYT1uKDIwMzkpLHM9bigzNzM4KSx1PXtuYW1lOlwiU29mdG1heENvbXB1dGVNYXhcIixpbnB1dE5hbWVzOltcIkFcIl0saW5wdXRUeXBlczpbYS5UZXh0dXJlVHlwZS51bnBhY2tlZF19LGM9e25hbWU6XCJTb2Z0bWF4Q29tcHV0ZVNjYWxlXCIsaW5wdXROYW1lczpbXCJBXCIsXCJNYXhcIl0saW5wdXRUeXBlczpbYS5UZXh0dXJlVHlwZS51bnBhY2tlZCxhLlRleHR1cmVUeXBlLnVucGFja2VkXX0sbD17bmFtZTpcIlNvZnRNYXhcIixpbnB1dE5hbWVzOltcIkFcIixcIk1heFwiLFwiTm9ybVwiXSxpbnB1dFR5cGVzOlthLlRleHR1cmVUeXBlLnVucGFja2VkLGEuVGV4dHVyZVR5cGUudW5wYWNrZWQsYS5UZXh0dXJlVHlwZS51bnBhY2tlZF19O2Uuc29mdG1heD0odCxlLG4pPT57ZyhlKTtjb25zdCByPWVbMF0uZGltcy5zbGljZSgpLG89aS5TaGFwZVV0aWwubm9ybWFsaXplQXhpcyhuLmF4aXMsci5sZW5ndGgpLGE9aS5TaGFwZVV0aWwuc2l6ZVRvRGltZW5zaW9uKHIsbykscz1pLlNoYXBlVXRpbC5zaXplRnJvbURpbWVuc2lvbihyLG8pO3JldHVybiBwKHQsZSxuLGEscyl9LGUucGFyc2VTb2Z0bWF4QXR0cmlidXRlcz10PT4oMCxyLmNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSkoe2F4aXM6dC5hdHRyaWJ1dGVzLmdldEludChcImF4aXNcIiwxKX0pLGUucGFyc2VTb2Z0bWF4QXR0cmlidXRlc1YxMz10PT4oMCxyLmNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSkoe2F4aXM6dC5hdHRyaWJ1dGVzLmdldEludChcImF4aXNcIiwtMSl9KSxlLnNvZnRtYXhWMTM9KHQsZSxuKT0+e2coZSk7Y29uc3Qgbz1lWzBdLmRpbXMuc2xpY2UoKSxhPWkuU2hhcGVVdGlsLm5vcm1hbGl6ZUF4aXMobi5heGlzLG8ubGVuZ3RoKSx1PW8ubGVuZ3RoLGM9YSE9PXUtMSxsPVtdO2xldCBmLGQ9W10saD1bXTtjJiYoZD1BcnJheS5mcm9tKHtsZW5ndGg6dX0pLm1hcCgoKHQsZSk9PmUpKSxkW2FdPXUtMSxkW3UtMV09YSxkLm1hcCgodD0+bC5wdXNoKG9bdF0pKSksZj0oMCxyLmNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSkoe3Blcm06ZH0pLGg9KDAscy50cmFuc3Bvc2UpKHQsZSxmKSk7Y29uc3QgYj1jP2kuU2hhcGVVdGlsLnNpemVUb0RpbWVuc2lvbihsLHUtMSk6aS5TaGFwZVV0aWwuc2l6ZVRvRGltZW5zaW9uKG8sdS0xKSxtPWM/aS5TaGFwZVV0aWwuc2l6ZUZyb21EaW1lbnNpb24obCx1LTEpOmkuU2hhcGVVdGlsLnNpemVGcm9tRGltZW5zaW9uKG8sdS0xKSx5PXAodCxjP2g6ZSxuLGIsbSk7cmV0dXJuIGM/KDAscy50cmFuc3Bvc2UpKHQseSxmKTp5fTtjb25zdCBwPSh0LGUsbixyLGkpPT57Y29uc3Qgbz1mKHQsZVswXSxyLGksW3JdKSxhPXQucnVuKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSx1KSx7Y2FjaGVIaW50Om4uY2FjaGVLZXksZ2V0OigpPT5vfSksZSkscz1kKHQsZVswXSxyLGksby5vdXRwdXQuZGltcyxbcl0pLHA9dC5ydW4oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LGMpLHtjYWNoZUhpbnQ6bi5jYWNoZUtleSxnZXQ6KCk9PnN9KSxbZVswXSxhXSksZz1oKHQsZVswXSxyLGksby5vdXRwdXQuZGltcyxzLm91dHB1dC5kaW1zKTtyZXR1cm5bdC5ydW4oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LGwpLHtjYWNoZUhpbnQ6bi5jYWNoZUtleSxnZXQ6KCk9Pmd9KSxbZVswXSxhLHBdKV19LGY9KHQsZSxuLHIsaSk9Pntjb25zdFtzLGNdPXQuY2FsY3VsYXRlVGV4dHVyZVdpZHRoQW5kSGVpZ2h0KGUuZGltcyxhLlRleHR1cmVUeXBlLnVucGFja2VkKSxsPWkubGVuZ3RoO2lmKG48MXx8cjwxKXRocm93IG5ldyBFcnJvcihcIkxvZ2ljYWwgcm93IGNvdW50IE4gYW5kIGZlYXR1cmUgY291bnQgRCBtdXN0IGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAxXCIpO2lmKDEhPT1pLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJEaW1lbnNpb25hbGl0eSBvZiB0aGUgb3V0cHV0IHNob3VsZCBiZSAxXCIpO2lmKGlbMF0hPT1uKXRocm93IG5ldyBFcnJvcihcIlNoYXBlIG9mIHRoZSBvdXRwdXQgc2hvdWxkIGJlIGVxdWFsIHRvIGxvZ2ljYWwgcm93IGNvdW50XCIpO2NvbnN0IHA9KDAsby5nZXRHbHNsKSh0LnNlc3Npb24uYmFja2VuZC5nbENvbnRleHQudmVyc2lvbiksZj1gXFxuICAgICAgZmxvYXQgcHJvY2VzcyhpbnRbJHtsfV0gaW5kaWNlcykge1xcbiAgICAgICAgaW50IGxvZ2ljYWxfcm93X3N0YXJ0X29mZnNldCA9IGluZGljZXNbMF0gKiAke3J9O1xcblxcbiAgICAgICAgZmxvYXQgbWF4ID0gZ2V0Q29sb3JBc0Zsb2F0KCR7cC50ZXh0dXJlMkR9KEEsIG9mZnNldFRvQ29vcmRzKGxvZ2ljYWxfcm93X3N0YXJ0X29mZnNldCwgJHtzfSxcXG4gICAgICAgICR7Y30gKSkpO1xcbiAgICAgICAgZm9yKGludCBpPTE7IGk8JHtyfTsgKytpKVxcbiAgICAgICAge1xcbiAgICAgICAgICBmbG9hdCBjdXJyZW50ID0gZ2V0Q29sb3JBc0Zsb2F0KCR7cC50ZXh0dXJlMkR9KEEsIG9mZnNldFRvQ29vcmRzKGxvZ2ljYWxfcm93X3N0YXJ0X29mZnNldCArIGksXFxuICAgICAgICAgICAgJHtzfSwgJHtjfSkpKTtcXG4gICAgICAgICAgaWYoY3VycmVudCA+IG1heClcXG4gICAgICAgICAgbWF4ID0gY3VycmVudDtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHJldHVybiBtYXg7XFxuICAgICAgfWA7cmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSx1KSx7b3V0cHV0OntkaW1zOmksdHlwZTplLnR5cGUsdGV4dHVyZVR5cGU6YS5UZXh0dXJlVHlwZS51bnBhY2tlZH0sc2hhZGVyU291cmNlOmZ9KX0sZD0odCxlLG4scixpLHMpPT57Y29uc3RbdSxsXT10LmNhbGN1bGF0ZVRleHR1cmVXaWR0aEFuZEhlaWdodChlLmRpbXMsYS5UZXh0dXJlVHlwZS51bnBhY2tlZCkscD1zLmxlbmd0aDtpZihuPDF8fHI8MSl0aHJvdyBuZXcgRXJyb3IoXCJMb2dpY2FsIHJvdyBjb3VudCBOIGFuZCBmZWF0dXJlIGNvdW50IEQgbXVzdCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMVwiKTtpZigxIT09cy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiRGltZW5zaW9uYWxpdHkgb2YgdGhlIG91dHB1dCBzaG91bGQgYmUgMVwiKTtpZihzWzBdIT09bil0aHJvdyBuZXcgRXJyb3IoXCJTaGFwZSBvZiB0aGUgb3V0cHV0IHNob3VsZCBiZSBlcXVhbCB0byBsb2dpY2FsIHJvdyBjb3VudFwiKTtpZigxIT09aS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiRGltZW5zaW9uYWxpdHkgb2YgdGhlIGludGVybWVkaWF0ZSByZXN1bHRzIHNob3VsZCBiZSAxXCIpO2lmKGlbMF0hPT1uKXRocm93IG5ldyBFcnJvcihcIlNoYXBlIG9mIHRoZSBpbnRlcm1lZGlhdGUgcmVzdWx0cyBzaG91bGQgYmUgZXF1YWwgdG8gbG9naWNhbCByb3cgY291bnRcIik7Y29uc3QgZj1gXFxuICAgICAgZmxvYXQgcHJvY2VzcyhpbnRbJHtwfV0gaW5kaWNlcykge1xcbiAgICAgICAgaW50IGxvZ2ljYWxfcm93X3N0YXJ0X29mZnNldCA9IGluZGljZXNbMF0gKiAke3J9O1xcblxcbiAgICAgICAgZmxvYXQgbm9ybV9mYWN0b3IgPSAwLjA7XFxuICAgICAgICBmbG9hdCBtYXggPSBfTWF4KGluZGljZXMpO1xcbiAgICAgICAgZm9yKGludCBpPTA7IGk8JHtyfTsgKytpKVxcbiAgICAgICAge1xcbiAgICAgICAgICBub3JtX2ZhY3RvciArPSBleHAoZ2V0Q29sb3JBc0Zsb2F0KCR7KDAsby5nZXRHbHNsKSh0LnNlc3Npb24uYmFja2VuZC5nbENvbnRleHQudmVyc2lvbikudGV4dHVyZTJEfShBLCBvZmZzZXRUb0Nvb3Jkcyhsb2dpY2FsX3Jvd19zdGFydF9vZmZzZXQgKyBpLFxcbiAgICAgICAgICAgICR7dX0sICR7bH0pKSkgLSBtYXgpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgcmV0dXJuIG5vcm1fZmFjdG9yO1xcbiAgICAgIH1gO3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sYykse291dHB1dDp7ZGltczpzLHR5cGU6ZS50eXBlLHRleHR1cmVUeXBlOmEuVGV4dHVyZVR5cGUudW5wYWNrZWR9LHNoYWRlclNvdXJjZTpmfSl9LGg9KHQsZSxuLHIsaSxvKT0+e2NvbnN0W3MsdV09dC5jYWxjdWxhdGVUZXh0dXJlV2lkdGhBbmRIZWlnaHQoZS5kaW1zLGEuVGV4dHVyZVR5cGUudW5wYWNrZWQpLGM9ZS5kaW1zLmxlbmd0aDtpZihuPDF8fHI8MSl0aHJvdyBuZXcgRXJyb3IoXCJMb2dpY2FsIHJvdyBjb3VudCBOIGFuZCBmZWF0dXJlIGNvdW50IEQgbXVzdCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMVwiKTtpZigxIT09aS5sZW5ndGh8fDEhPT1vLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJEaW1lbnNpb25hbGl0eSBvZiB0aGUgaW50ZXJtZWRpYXRlIHJlc3VsdHMgc2hvdWxkIGJlIDFcIik7aWYoaVswXSE9PW58fG9bMF0hPT1uKXRocm93IG5ldyBFcnJvcihcIlNoYXBlIG9mIHRoZSBpbnRlcm1lZGlhdGUgcmVzdWx0cyBzaG91bGQgYmUgZXF1YWwgdG8gbG9naWNhbCByb3cgY291bnRcIik7Y29uc3QgcD1gXFxuICAgICAgZmxvYXQgcHJvY2VzcyhpbnRbJHtjfV0gaW5kaWNlcykge1xcblxcbiAgICAgIC8vIGdldCBvZmZzZXQgb2YgY3VycmVudCBsb2dpY2FsIHRlbnNvciBpbmRleCBmcm9tIHRoZSAyLUQgdGV4dHVyZSBjb29yZGluYXRlcyAoVGV4Q29vcmRzKVxcbiAgICAgIGludCBvZmZzZXQgPSBjb29yZHNUb09mZnNldChUZXhDb29yZHMsICR7c30sICR7dX0pO1xcblxcbiAgICAgIC8vZGV0ZXJtaW5lIHRoZSBsb2dpY2FsIHJvdyBmb3IgdGhpcyBpbmRleFxcbiAgICAgIGludCBsb2dpY2FsX3Jvd19pbmRleFsxXTtcXG4gICAgICBsb2dpY2FsX3Jvd19pbmRleFswXSA9IG9mZnNldCAvICR7cn07XFxuXFxuICAgICAgZmxvYXQgbm9ybV9mYWN0b3IgPSBfTm9ybShsb2dpY2FsX3Jvd19pbmRleCk7XFxuXFxuICAgICAgLy8gYXZvaWQgcG9zc2libGUgZGl2aXNpb24gYnkgMFxcbiAgICAgIC8vIGlmIG5vcm1fZmFjb3IgaXMgMCwgYWxsIGVsZW1lbnRzIGFyZSB6ZXJvXFxuICAgICAgLy8gaWYgc28sIHJldHVybiAwXFxuICAgICAgaWYobm9ybV9mYWN0b3IgPT0gMC4wKVxcbiAgICAgICAgcmV0dXJuIDAuMDtcXG5cXG4gICAgICByZXR1cm4gZXhwKF9BKGluZGljZXMpIC0gX01heChsb2dpY2FsX3Jvd19pbmRleCkpIC8gbm9ybV9mYWN0b3I7XFxuICAgIH1gO3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sbCkse291dHB1dDp7ZGltczplLmRpbXMsdHlwZTplLnR5cGUsdGV4dHVyZVR5cGU6YS5UZXh0dXJlVHlwZS51bnBhY2tlZH0sc2hhZGVyU291cmNlOnB9KX0sZz10PT57aWYoIXR8fDEhPT10Lmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJTb2Z0bWF4IHJlcXVpcmVzIDEgaW5wdXQuXCIpO2lmKFwiZmxvYXQzMlwiIT09dFswXS50eXBlJiZcImZsb2F0NjRcIiE9PXRbMF0udHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGlucHV0IHR5cGVcIil9fSw1OTc1Oih0LGUsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLnBhcnNlU3BsaXRBdHRyaWJ1dGVzPWUuc3BsaXQ9dm9pZCAwO2NvbnN0IHI9bigyNDYpLGk9bigyNTE3KSxvPW4oMjAzOSksYT17bmFtZTpcIlNwbGl0XCIsaW5wdXROYW1lczpbXCJBXCJdLGlucHV0VHlwZXM6W28uVGV4dHVyZVR5cGUudW5wYWNrZWRdfTtlLnNwbGl0PSh0LGUsbik9PntjKGUpO2NvbnN0IHI9aS5TaGFwZVV0aWwubm9ybWFsaXplQXhpcyhuLmF4aXMsZVswXS5kaW1zLmxlbmd0aCksbz1zKHQsZSxyLG4pLGw9W107Zm9yKGxldCBpPTA7aTxvOysraSlsLnB1c2godC5ydW4oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LGEpLHtjYWNoZUhpbnQ6YCR7bi5jYWNoZUtleX07JHtpfWAsZ2V0OigpPT51KHQsZVswXSxuLHIsaSl9KSxlKSk7cmV0dXJuIGx9LGUucGFyc2VTcGxpdEF0dHJpYnV0ZXM9dD0+e2NvbnN0IGU9dC5hdHRyaWJ1dGVzLmdldEludChcImF4aXNcIiwwKSxuPXQuYXR0cmlidXRlcy5nZXRJbnRzKFwic3BsaXRcIixbXSksaT10Lm91dHB1dHMubGVuZ3RoO3JldHVybigwLHIuY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KSh7YXhpczplLHNwbGl0Om4sbnVtT3V0cHV0czppfSl9O2NvbnN0IHM9KHQsZSxuLHIpPT57Y29uc3RbLG9dPWkuU3BsaXRVdGlsLnNwbGl0U2hhcGUoZVswXS5kaW1zLG4sci5zcGxpdCxyLm51bU91dHB1dHMpO3JldHVybiBvLmxlbmd0aH0sdT0odCxlLG4scixzKT0+e2NvbnN0W3UsY109aS5TcGxpdFV0aWwuc3BsaXRTaGFwZShlLmRpbXMscixuLnNwbGl0LG4ubnVtT3V0cHV0cyksbD1jW3NdLHA9dVtzXSxmPWBcXG4gICAgICBmbG9hdCBwcm9jZXNzKGludCBpbmRpY2VzWyR7cC5sZW5ndGh9XSkge1xcbiAgICAgICAgaW5kaWNlc1ske3J9XSArPSAke2x9O1xcbiAgICAgICAgcmV0dXJuIF9BKGluZGljZXMpO1xcbiAgICAgIH1cXG4gICAgYDtyZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LGEpLHtjYWNoZUhpbnQ6YCR7bi5jYWNoZUtleX06JHtzfWAsb3V0cHV0OntkaW1zOnAsdHlwZTplLnR5cGUsdGV4dHVyZVR5cGU6by5UZXh0dXJlVHlwZS51bnBhY2tlZH0sc2hhZGVyU291cmNlOmZ9KX0sYz10PT57aWYoIXR8fDEhPT10Lmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJTcGxpdCByZXF1aXJlcyBvbmUgaW5wdXQuXCIpO2lmKFwiaW50OFwiIT09dFswXS50eXBlJiZcInVpbnQ4XCIhPT10WzBdLnR5cGUmJlwiaW50MTZcIiE9PXRbMF0udHlwZSYmXCJ1aW50MTZcIiE9PXRbMF0udHlwZSYmXCJpbnQzMlwiIT09dFswXS50eXBlJiZcInVpbnQzMlwiIT09dFswXS50eXBlJiZcImZsb2F0MzJcIiE9PXRbMF0udHlwZSYmXCJmbG9hdDY0XCIhPT10WzBdLnR5cGUmJlwiYm9vbFwiIT09dFswXS50eXBlKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW5wdXQgdHlwZS5cIil9fSwzOTMzOih0LGUsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLnBhcnNlU3F1ZWV6ZUF0dHJpYnV0ZXM9ZS5zcXVlZXplVjEzPWUuc3F1ZWV6ZT12b2lkIDA7Y29uc3Qgcj1uKDI1MTcpO2Uuc3F1ZWV6ZT0odCxlLG4pPT57aShlKTtjb25zdCBvPXIuU2hhcGVVdGlsLnNxdWVlemVTaGFwZShlWzBdLmRpbXMsbik7cmV0dXJuW3QucmVzaGFwZVVucGFja2VkKGVbMF0sbyldfSxlLnNxdWVlemVWMTM9KHQsbik9PihvKG4pLCgwLGUuc3F1ZWV6ZSkodCxbblswXV0sQXJyYXkuZnJvbShuWzFdLmludGVnZXJEYXRhKSkpLGUucGFyc2VTcXVlZXplQXR0cmlidXRlcz10PT50LmF0dHJpYnV0ZXMuZ2V0SW50cyhcImF4ZXNcIik7Y29uc3QgaT10PT57aWYoIXR8fDEhPT10Lmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJTcXVlZXplIHJlcXVpcmVzIDEgaW5wdXQuXCIpO2lmKFwic3RyaW5nXCI9PT10WzBdLnR5cGUpdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBpbnB1dCB0ZW5zb3IgdHlwZXMuXCIpfSxvPXQ9PntpZighdHx8MiE9PXQubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIlNxdWVlemUgcmVxdWlyZXMgMiBpbnB1dHMuXCIpO2lmKFwiaW50MzJcIiE9PXRbMV0udHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGlucHV0IHR5cGUuXCIpfX0sNjU1ODoodCxlLG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5zdW09dm9pZCAwO2NvbnN0IHI9big1MDYwKSxpPW4oMjAzOSk7ZS5zdW09KHQsZSk9PnthKGUpO2NvbnN0IG49e25hbWU6XCJTdW1cIixpbnB1dE5hbWVzOmUubWFwKCgodCxlKT0+YFgke2V9YCkpLGlucHV0VHlwZXM6bmV3IEFycmF5KGUubGVuZ3RoKS5maWxsKGkuVGV4dHVyZVR5cGUudW5wYWNrZWQpfTtyZXR1cm5bdC5ydW4oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LG4pLHtnZXQ6KCk9Pm8odCxlLG4pfSksZSldfTtjb25zdCBvPSh0LGUsbik9Pntjb25zdCBvPSgwLHIuZ2V0R2xzbCkodC5zZXNzaW9uLmJhY2tlbmQuZ2xDb250ZXh0LnZlcnNpb24pLGE9ZVswXS5kaW1zLnNsaWNlKCkscz1gXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgdmVjNCByZXN1bHQgPSAke2UubWFwKCgodCxlKT0+YCR7by50ZXh0dXJlMkR9KFgke2V9LFRleENvb3JkcylgKSkuam9pbihcIiArIFwiKX07XFxuICAgICAgICAke28ub3V0cHV0fSA9IHJlc3VsdDtcXG4gICAgICB9XFxuICAgIGA7cmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxuKSx7b3V0cHV0OntkaW1zOmEsdHlwZTplWzBdLnR5cGUsdGV4dHVyZVR5cGU6aS5UZXh0dXJlVHlwZS51bnBhY2tlZH0saGFzTWFpbjohMCxzaGFkZXJTb3VyY2U6c30pfSxhPXQ9PntpZighdHx8MD09PXQubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIlN1bSByZXF1aXJlcyBpbnB1dHMuXCIpO2NvbnN0IGU9dFswXS5kaW1zLmxlbmd0aDtmb3IobGV0IG49MTtuPHQubGVuZ3RoO24rKyl7aWYoZSE9PXRbbl0uZGltcy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiSW5wdXQgc2hhcGVzIGFyZSBtaXNtYXRjaGVkLlwiKTtmb3IobGV0IHI9MDtyPGU7cisrKWlmKHRbMF0uZGltc1tyXSE9PXRbbl0uZGltc1tyXSl0aHJvdyBuZXcgRXJyb3IoXCJJbnB1dCBzaGFwZXMgYXJlIG5vdCBtYXRjaGVkLlwiKX1pZihcImZsb2F0MzJcIiE9PXRbMF0udHlwZSYmXCJmbG9hdDY0XCIhPT10WzBdLnR5cGUpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpbnB1dCB0eXBlLlwiKTtmb3IobGV0IGU9MTtlPHQubGVuZ3RoO2UrKylpZih0WzBdLnR5cGUhPT10W2VdLnR5cGUpdGhyb3cgbmV3IEVycm9yKFwiSW5wdXQgdHlwZXMgYXJlIG5vdCBtYXRjaGVkLlwiKX19LDU3MjM6KHQsZSxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUudGlsZT12b2lkIDA7Y29uc3Qgcj1uKDc4MiksaT1uKDIwMzkpO2UudGlsZT0odCxlKT0+e2EoZSk7Y29uc3Qgbj17bmFtZTpcIlRpbGVcIixpbnB1dE5hbWVzOltcIkFcIl0saW5wdXRUeXBlczpbaS5UZXh0dXJlVHlwZS51bnBhY2tlZF19O3JldHVyblt0LnJ1bihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sbikse2dldDooKT0+byh0LGUsbil9KSxlKV19O2NvbnN0IG89KHQsZSxuKT0+e2NvbnN0IHI9ZVswXS5kaW1zLnNsaWNlKCksbz1uZXcgQXJyYXkoci5sZW5ndGgpLGE9W107Zm9yKGxldCB0PTA7dDxyLmxlbmd0aDt0Kyspb1t0XT1yW3RdKmVbMV0ubnVtYmVyRGF0YVt0XSxhLnB1c2goYGlucHV0SWR4WyR7dH1dID0gaW50KG1vZChmbG9hdChvdXRwdXRJZHhbJHt0fV0pLCAke3JbdF19LikpO2ApO2NvbnN0IHM9by5sZW5ndGgsdT1gXFxuICAgICAgZmxvYXQgcHJvY2VzcyhpbnQgb3V0cHV0SWR4WyR7c31dKSB7XFxuICAgICAgICBpbnQgaW5wdXRJZHhbJHtzfV07XFxuICAgICAgICAke2Euam9pbihcIlxcblwiKX1cXG4gICAgICAgIHJldHVybiBfQShpbnB1dElkeCk7XFxuICAgICAgfVxcbiAgICBgO3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sbikse291dHB1dDp7ZGltczpvLHR5cGU6ZVswXS50eXBlLHRleHR1cmVUeXBlOmkuVGV4dHVyZVR5cGUudW5wYWNrZWR9LHNoYWRlclNvdXJjZTp1fSl9LGE9dD0+e2lmKCF0fHwyIT09dC5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiVGlsZSByZXF1aXJlcyAyIGlucHV0LlwiKTtpZigxIT09dFsxXS5kaW1zLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJUaGUgc2Vjb25kIGlucHV0IHNoYXBlIG11c3QgMSBkaW1lbnNpb24uXCIpO2lmKHRbMV0uZGltc1swXSE9PXRbMF0uZGltcy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpbnB1dCBzaGFwZS5cIik7aWYoLTE9PT1yLk5VTUJFUl9UWVBFUy5pbmRleE9mKHRbMF0udHlwZSkpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpbnB1dCB0eXBlLlwiKTtpZihcImludDMyXCIhPT10WzFdLnR5cGUmJlwiaW50MTZcIiE9PXRbMV0udHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHJlcGVhdCB0eXBlLlwiKX19LDM3Mzg6KHQsZSxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUucGFyc2VUcmFuc3Bvc2VBdHRyaWJ1dGVzPWUudHJhbnNwb3NlPXZvaWQgMDtjb25zdCByPW4oMjQ2KSxpPW4oMjUxNyksbz1uKDIwMzkpLGE9e25hbWU6XCJUcmFuc3Bvc2VcIixpbnB1dE5hbWVzOltcIkFcIl0saW5wdXRUeXBlczpbby5UZXh0dXJlVHlwZS51bnBhY2tlZF19O2UudHJhbnNwb3NlPSh0LGUsbik9PihwKGUpLFt0LnJ1bihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sYSkse2NhY2hlSGludDpuLmNhY2hlS2V5LGdldDooKT0+cyh0LGVbMF0sbi5wZXJtKX0pLGUpXSksZS5wYXJzZVRyYW5zcG9zZUF0dHJpYnV0ZXM9dD0+KDAsci5jcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkpKHtwZXJtOnQuYXR0cmlidXRlcy5nZXRJbnRzKFwicGVybVwiLFtdKX0pO2NvbnN0IHM9KHQsZSxuKT0+e2NvbnN0IHI9ZS5kaW1zO249dShyLG4pO2NvbnN0IGk9YyhyLG4pLHM9ci5sZW5ndGgscD1gXFxuICAgICAgJHtsKFwicGVybVwiLG4scyl9XFxuICAgICAgZmxvYXQgcHJvY2VzcyhpbnQgaW5kaWNlc1ske3N9XSkge1xcbiAgICAgICAgaW50IGFbJHtzfV07XFxuICAgICAgICBwZXJtKGEsIGluZGljZXMpO1xcbiAgICAgICAgcmV0dXJuIF9BKGEpO1xcbiAgICAgIH1gO3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sYSkse291dHB1dDp7ZGltczppLHR5cGU6ZS50eXBlLHRleHR1cmVUeXBlOm8uVGV4dHVyZVR5cGUudW5wYWNrZWR9LHNoYWRlclNvdXJjZTpwfSl9LHU9KHQsZSk9PihlJiZlLmxlbmd0aCE9PXQubGVuZ3RoJiYoZT1bLi4udC5rZXlzKCldLnJldmVyc2UoKSksZSksYz0odCxlKT0+KGU9dSh0LGUpLGkuU2hhcGVVdGlsLnNvcnRCYXNlZE9uUGVybSh0LGUpKSxsPSh0LGUsbik9Pntjb25zdCByPVtdO3IucHVzaChgdm9pZCAke3R9KG91dCBpbnQgYVske259XSwgaW50IHNyY1ske259XSkge2ApO2ZvcihsZXQgdD0wO3Q8bjsrK3Qpci5wdXNoKGBcXHRhWyR7ZVt0XX1dPXNyY1ske3R9XTtgKTtyZXR1cm4gci5wdXNoKFwiXFx0fVwiKSxyLmpvaW4oXCJcXG5cIil9LHA9dD0+e2lmKCF0fHwxIT09dC5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiVHJhbnNwb3NlIHJlcXVpcmVzIDEgaW5wdXQuXCIpO2lmKFwiZmxvYXQzMlwiIT09dFswXS50eXBlJiZcImZsb2F0NjRcIiE9PXRbMF0udHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJpbnB1dCBzaG91bGQgYmUgZmxvYXQgdGVuc29yXCIpfX0sODcxMDoodCxlLG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5lbmNvZGVBc1VpbnQ4PXZvaWQgMDtjb25zdCByPW4oNTA2MCksaT1uKDIwMzkpO2UuZW5jb2RlQXNVaW50OD0odCxlKT0+e2NvbnN0IG49ZS5zaGFwZSxvPSgwLHIuZ2V0R2xzbCkodC5zZXNzaW9uLmJhY2tlbmQuZ2xDb250ZXh0LnZlcnNpb24pLGE9YFxcbiAgICBjb25zdCBmbG9hdCBGTE9BVF9NQVggPSAxLjcwMTQxMTg0ZTM4O1xcbiAgICBjb25zdCBmbG9hdCBGTE9BVF9NSU4gPSAxLjE3NTQ5NDM1ZS0zODtcXG5cXG4gICAgYm9vbCBpc05hTihmbG9hdCB2YWwpIHtcXG4gICAgICByZXR1cm4gKHZhbCA8IDEuMCB8fCAwLjAgPCB2YWwgfHwgdmFsID09IDAuMCkgPyBmYWxzZSA6IHRydWU7XFxuICAgIH1cXG5cXG4gICAgaGlnaHAgdmVjNCBlbmNvZGVBc1VpbnQ4KGhpZ2hwIGZsb2F0IHYpIHtcXG4gICAgICBpZiAoaXNOYU4odikpIHtcXG4gICAgICAgIHJldHVybiB2ZWM0KDI1NSwgMjU1LCAyNTUsIDI1NSk7XFxuICAgICAgfVxcblxcbiAgICAgIGhpZ2hwIGZsb2F0IGF2ID0gYWJzKHYpO1xcblxcbiAgICAgIGlmKGF2IDwgRkxPQVRfTUlOKSB7XFxuICAgICAgICByZXR1cm4gdmVjNCgwLjAsIDAuMCwgMC4wLCAwLjApO1xcbiAgICAgIH0gZWxzZSBpZih2ID4gRkxPQVRfTUFYKSB7XFxuICAgICAgICByZXR1cm4gdmVjNCgwLjAsIDAuMCwgMTI4LjAsIDEyNy4wKSAvIDI1NS4wO1xcbiAgICAgIH0gZWxzZSBpZih2IDwgLUZMT0FUX01BWCkge1xcbiAgICAgICAgcmV0dXJuIHZlYzQoMC4wLCAwLjAsICAxMjguMCwgMjU1LjApIC8gMjU1LjA7XFxuICAgICAgfVxcblxcbiAgICAgIGhpZ2hwIHZlYzQgYyA9IHZlYzQoMCwwLDAsMCk7XFxuXFxuICAgICAgaGlnaHAgZmxvYXQgZSA9IGZsb29yKGxvZzIoYXYpKTtcXG4gICAgICBoaWdocCBmbG9hdCBtID0gZXhwMihmcmFjdChsb2cyKGF2KSkpIC0gMS4wO1xcblxcbiAgICAgIGNbMl0gPSBmbG9vcigxMjguMCAqIG0pO1xcbiAgICAgIG0gLT0gY1syXSAvIDEyOC4wO1xcbiAgICAgIGNbMV0gPSBmbG9vcigzMjc2OC4wICogbSk7XFxuICAgICAgbSAtPSBjWzFdIC8gMzI3NjguMDtcXG4gICAgICBjWzBdID0gZmxvb3IoODM4ODYwOC4wICogbSk7XFxuXFxuICAgICAgaGlnaHAgZmxvYXQgZWJpYXMgPSBlICsgMTI3LjA7XFxuICAgICAgY1szXSA9IGZsb29yKGViaWFzIC8gMi4wKTtcXG4gICAgICBlYmlhcyAtPSBjWzNdICogMi4wO1xcbiAgICAgIGNbMl0gKz0gZmxvb3IoZWJpYXMpICogMTI4LjA7XFxuXFxuICAgICAgY1szXSArPSAxMjguMCAqIHN0ZXAoMC4wLCAtdik7XFxuXFxuICAgICAgcmV0dXJuIGMgLyAyNTUuMDtcXG4gICAgfVxcblxcbiAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgZmxvYXQgdmFsdWUgPSAke28udGV4dHVyZTJEfShYLFRleENvb3JkcykucjtcXG4gICAgICAke28ub3V0cHV0fSA9IGVuY29kZUFzVWludDgodmFsdWUpO1xcbiAgICB9YCxzPXtuYW1lOlwiVWludDhFbmNvZGVcIixpbnB1dFR5cGVzOltpLlRleHR1cmVUeXBlLnVucGFja2VkXSxpbnB1dE5hbWVzOltcIlhcIl0sb3V0cHV0OntkaW1zOm4sdHlwZTplLnRlbnNvci50eXBlLHRleHR1cmVUeXBlOmkuVGV4dHVyZVR5cGUuZG93bmxvYWRVaW50OEFzRmxvYXR9LHNoYWRlclNvdXJjZTphLGhhc01haW46ITB9O3JldHVybiB0LmV4ZWN1dGVQcm9ncmFtKHMsW2UudGVuc29yXSl9fSw0OTA5Oih0LGUsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLnRhbmg9ZS50YW49ZS5zcXJ0PWUuc2luPWUuc2lnbW9pZD1lLnJlbHU9ZS5ub3Q9ZS5uZWc9ZS5sb2c9ZS5wYXJzZUxlYWt5UmVsdUF0dHJpYnV0ZXM9ZS5sZWFreVJlbHU9ZS5pZGVudGl0eT1lLmZsb29yPWUuZXhwPWUucGFyc2VFbHVBdHRyaWJ1dGVzPWUuZWx1PWUuY29zPWUuY2VpbD1lLmNsaXBWMTE9ZS5wYXJzZUNsaXBBdHRyaWJ1dGVzPWUuY2xpcD1lLmF0YW49ZS5hc2luPWUuYWNvcz1lLmFicz1lLmdsc2xUYW5oPWUuZ2xzbFRhbj1lLmdsc2xTcXJ0PWUuZ2xzbFNpZ21vaWQ9ZS5nbHNsUmVsdT1lLmdsc2xTaW49ZS5nbHNsTm90PWUuZ2xzbE5lZz1lLmdsc2xMb2c9ZS5nbHNsTGVha3lSZWx1PWUuZ2xzbElkZW50aXR5PWUuZ2xzbENsaXA9ZS5nbHNsRmxvb3I9ZS5nbHNsRXhwPWUuZ2xzbEVsdT1lLmdsc2xDb3M9ZS5nbHNsQ2VpbD1lLmdsc2xBdGFuPWUuZ2xzbEFzaW49ZS5nbHNsQWNvcz1lLmdsc2xBYnM9dm9pZCAwO2NvbnN0IHI9bigyNDYpLGk9bigyNTE3KSxvPW4oODUyMCksYT1uKDUwNjApLHM9bigyMDM5KTtmdW5jdGlvbiB1KCl7cmV0dXJuIFAoXCJhYnNcIil9ZnVuY3Rpb24gYygpe3JldHVybiBQKFwiYWNvc1wiKX1mdW5jdGlvbiBsKCl7cmV0dXJuIFAoXCJhc2luXCIpfWZ1bmN0aW9uIHAoKXtyZXR1cm4gUChcImF0YW5cIil9ZnVuY3Rpb24gZigpe3JldHVybiBQKFwiY2VpbFwiKX1mdW5jdGlvbiBkKCl7cmV0dXJuIFAoXCJjb3NcIil9ZnVuY3Rpb24gaCh0KXtjb25zdCBlPVwiZWx1XCI7cmV0dXJue2JvZHk6YFxcbiAgY29uc3QgZmxvYXQgYWxwaGEgPSBmbG9hdCgke3R9KTtcXG5cXG4gIGZsb2F0ICR7ZX1fKGZsb2F0IGEpIHtcXG4gICAgcmV0dXJuIGEgPj0gMC4wID8gYTogKGV4cChhKSAtIDEuMCkgKiBhbHBoYTtcXG4gIH1cXG4gIHZlYzQgJHtlfV8odmVjNCB2KSB7XFxuICAgIHJldHVybiB2ZWM0KCR7ZX1fKHYueCksICR7ZX1fKHYueSksICR7ZX1fKHYueiksICR7ZX1fKHYudykpO1xcbiAgfVxcbiAgYCxuYW1lOmUsdHlwZTpvLkZ1bmN0aW9uVHlwZS5WYWx1ZUJhc2VkfX1mdW5jdGlvbiBnKCl7cmV0dXJuIFAoXCJleHBcIil9ZnVuY3Rpb24gYigpe3JldHVybiBQKFwiZmxvb3JcIil9ZnVuY3Rpb24gbSh0LGUpe2NvbnN0IG49XCJjbGlwXCI7cmV0dXJue2JvZHk6YFxcbiAgY29uc3QgZmxvYXQgbWluID0gZmxvYXQoJHt0fSk7XFxuICBjb25zdCBmbG9hdCBtYXggPSBmbG9hdCgke2V9KTtcXG5cXG4gIGZsb2F0ICR7bn1fKGZsb2F0IGEpIHtcXG4gICAgcmV0dXJuIGNsYW1wKGEsIG1pbiwgbWF4KTtcXG4gIH1cXG4gIHZlYzQgJHtufV8odmVjNCB2KSB7XFxuICAgIHJldHVybiBjbGFtcCh2LCBtaW4sIG1heCk7XFxuICB9XFxuICBgLG5hbWU6bix0eXBlOm8uRnVuY3Rpb25UeXBlLlZhbHVlQmFzZWR9fWZ1bmN0aW9uIHkoKXtjb25zdCB0PVwiaW5kZW50aXR5XCI7cmV0dXJue2JvZHk6YFxcbiAgZmxvYXQgJHt0fV8oZmxvYXQgYSkge1xcbiAgICByZXR1cm4gYTtcXG4gIH1cXG4gIHZlYzQgJHt0fV8odmVjNCB2KSB7XFxuICAgIHJldHVybiB2O1xcbiAgfVxcbiAgYCxuYW1lOnQsdHlwZTpvLkZ1bmN0aW9uVHlwZS5WYWx1ZUJhc2VkfX1mdW5jdGlvbiBfKHQpe2NvbnN0IGU9XCJsZWFreVJlbHVcIjtyZXR1cm57Ym9keTpgXFxuICBjb25zdCBmbG9hdCBhbHBoYSA9IGZsb2F0KCR7dH0pO1xcblxcbiAgZmxvYXQgJHtlfV8oZmxvYXQgYSkge1xcbiAgICByZXR1cm4gYSA8IDAuMCA/IGEgKiBhbHBoYSA6IGE7XFxuICB9XFxuICB2ZWM0ICR7ZX1fKHZlYzQgdikge1xcbiAgICByZXR1cm4gdmVjNCgke2V9Xyh2LngpLCAke2V9Xyh2LnkpLCAke2V9Xyh2LnopLCAke2V9Xyh2LncpKTtcXG4gIH1cXG4gIGAsbmFtZTplLHR5cGU6by5GdW5jdGlvblR5cGUuVmFsdWVCYXNlZH19ZnVuY3Rpb24gdigpe3JldHVybiBQKFwibG9nXCIpfWZ1bmN0aW9uIHcoKXtjb25zdCB0PVwibmVnXCI7cmV0dXJue2JvZHk6YFxcbiAgZmxvYXQgJHt0fV8oZmxvYXQgYSkge1xcbiAgICByZXR1cm4gLWE7XFxuICB9XFxuICB2ZWM0ICR7dH1fKHZlYzQgdikge1xcbiAgICByZXR1cm4gLXY7XFxuICB9XFxuICBgLG5hbWU6dCx0eXBlOm8uRnVuY3Rpb25UeXBlLlZhbHVlQmFzZWR9fWZ1bmN0aW9uIHgoKXtjb25zdCB0PVwibm90XCI7cmV0dXJue2JvZHk6YFxcbiAgZmxvYXQgJHt0fV8oZmxvYXQgYSkge1xcbiAgICByZXR1cm4gZmxvYXQoICEgYm9vbChhKSApO1xcbiAgfVxcbiAgYm9vbCAke3R9Xyhib29sIGEpIHtcXG4gICAgcmV0dXJuICFhO1xcbiAgfVxcbiAgdmVjNCAke3R9Xyh2ZWM0IHYpIHtcXG4gICAgcmV0dXJuIHZlYzQoIWJvb2wodi54KSwgIWJvb2wodi55KSwgIWJvb2wodi56KSwgIWJvb2wodi53KSk7XFxuICB9XFxuICBidmVjNCAke3R9XyhidmVjNCB2KSB7XFxuICAgIHJldHVybiBidmVjNCghdi54LCAhdi55LCAhdi56LCAhdi53KTtcXG4gIH1cXG4gIGAsbmFtZTp0LHR5cGU6by5GdW5jdGlvblR5cGUuVmFsdWVCYXNlZH19ZnVuY3Rpb24gVCgpe3JldHVybiBQKFwic2luXCIpfWZ1bmN0aW9uIFMoKXtjb25zdCB0PVwicmVsdVwiO3JldHVybntib2R5OmBcXG4gIGZsb2F0ICR7dH1fKGZsb2F0IGEpIHtcXG4gICAgcmV0dXJuIG1heCggYSwgMC4wICk7XFxuICB9XFxuICB2ZWM0ICR7dH1fKHZlYzQgdikge1xcbiAgICByZXR1cm4gbWF4KCB2LCAwLjAgKTtcXG4gIH1cXG4gIGAsbmFtZTp0LHR5cGU6by5GdW5jdGlvblR5cGUuVmFsdWVCYXNlZH19ZnVuY3Rpb24gTygpe2NvbnN0IHQ9XCJzaWdtb2lkXCI7cmV0dXJue2JvZHk6YFxcbiAgZmxvYXQgJHt0fV8oZmxvYXQgYSkge1xcbiAgICByZXR1cm4gMS4wIC8gKDEuMCArIGV4cCgtYSkpO1xcbiAgfVxcbiAgdmVjNCAke3R9Xyh2ZWM0IHYpIHtcXG4gICAgcmV0dXJuIDEuMCAvICgxLjAgKyBleHAoLXYpKTtcXG4gIH1cXG4gIGAsbmFtZTp0LHR5cGU6by5GdW5jdGlvblR5cGUuVmFsdWVCYXNlZH19ZnVuY3Rpb24gQSgpe3JldHVybiBQKFwic3FydFwiKX1mdW5jdGlvbiBFKCl7cmV0dXJuIFAoXCJ0YW5cIil9ZnVuY3Rpb24gSSgpe2NvbnN0IHQ9XCJ0YW5oXCI7cmV0dXJue2JvZHk6YFxcbiAgZmxvYXQgJHt0fV8oZmxvYXQgYSkge1xcbiAgICBhID0gY2xhbXAoYSwgLTEwLiwgMTAuKTtcXG4gICAgYSA9IGV4cCgyLiphKTtcXG4gICAgcmV0dXJuIChhIC0gMS4pIC8gKGEgKyAxLik7XFxuICB9XFxuICB2ZWM0ICR7dH1fKHZlYzQgdikge1xcbiAgICB2ID0gY2xhbXAodiwgLTEwLiwgMTAuKTtcXG4gICAgdiA9IGV4cCgyLip2KTtcXG4gICAgcmV0dXJuICh2IC0gMS4pIC8gKHYgKyAxLik7XFxuICB9XFxuICBgLG5hbWU6dCx0eXBlOm8uRnVuY3Rpb25UeXBlLlZhbHVlQmFzZWR9fWZ1bmN0aW9uIFAodCl7cmV0dXJue2JvZHk6YFxcbiAgZmxvYXQgJHt0fV8oZmxvYXQgYSkge1xcbiAgICByZXR1cm4gJHt0fShhKTtcXG4gIH1cXG4gIHZlYzQgJHt0fV8odmVjNCB2KSB7XFxuICAgIHJldHVybiAke3R9KHYpO1xcbiAgfVxcbiAgYCxuYW1lOnQsdHlwZTpvLkZ1bmN0aW9uVHlwZS5WYWx1ZUJhc2VkfX1lLmdsc2xBYnM9dSxlLmdsc2xBY29zPWMsZS5nbHNsQXNpbj1sLGUuZ2xzbEF0YW49cCxlLmdsc2xDZWlsPWYsZS5nbHNsQ29zPWQsZS5nbHNsRWx1PWgsZS5nbHNsRXhwPWcsZS5nbHNsRmxvb3I9YixlLmdsc2xDbGlwPW0sZS5nbHNsSWRlbnRpdHk9eSxlLmdsc2xMZWFreVJlbHU9XyxlLmdsc2xMb2c9dixlLmdsc2xOZWc9dyxlLmdsc2xOb3Q9eCxlLmdsc2xTaW49VCxlLmdsc2xSZWx1PVMsZS5nbHNsU2lnbW9pZD1PLGUuZ2xzbFNxcnQ9QSxlLmdsc2xUYW49RSxlLmdsc2xUYW5oPUk7Y29uc3QgRD0odCxlLG4scik9Pntjb25zdCBpPXQuc2Vzc2lvbi5wYWNrP3MuVGV4dHVyZVR5cGUucGFja2VkOnMuVGV4dHVyZVR5cGUudW5wYWNrZWQsbz17bmFtZTpuLm5hbWUsaW5wdXRUeXBlczpbaV0saW5wdXROYW1lczpbXCJBXCJdLGNhY2hlSGludDpyfTtyZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LG8pLHtnZXQ6KCk9PigodCxlLG4scik9Pntjb25zdCBpPXQuc2Vzc2lvbi5wYWNrP3MuVGV4dHVyZVR5cGUucGFja2VkOnMuVGV4dHVyZVR5cGUudW5wYWNrZWQsbz0oMCxhLmdldEdsc2wpKHQuc2Vzc2lvbi5iYWNrZW5kLmdsQ29udGV4dC52ZXJzaW9uKTtyZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LGUpLHtvdXRwdXQ6e2RpbXM6bi5kaW1zLHR5cGU6bi50eXBlLHRleHR1cmVUeXBlOml9LHNoYWRlclNvdXJjZTpgXFxuICAgICAke3IuYm9keX1cXG4gICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgdmVjNCB2ID0gJHtvLnRleHR1cmUyRH0oQSwgVGV4Q29vcmRzKTtcXG4gICAgICAgdiA9ICR7ci5uYW1lfV8odik7XFxuICAgICAgICR7by5vdXRwdXR9ID0gdjtcXG4gICAgIH1cXG4gICAgIGAsaGFzTWFpbjohMH0pfSkodCxvLGUsbil9KX07ZS5hYnM9KHQsZSk9Plt0LnJ1bihEKHQsZVswXSx1KCkpLGUpXSxlLmFjb3M9KHQsZSk9Plt0LnJ1bihEKHQsZVswXSxjKCkpLGUpXSxlLmFzaW49KHQsZSk9Plt0LnJ1bihEKHQsZVswXSxsKCkpLGUpXSxlLmF0YW49KHQsZSk9Plt0LnJ1bihEKHQsZVswXSxwKCkpLGUpXSxlLmNsaXA9KHQsZSxuKT0+W3QucnVuKEQodCxlWzBdLG0obi5taW4sbi5tYXgpLG4uY2FjaGVLZXkpLGUpXSxlLnBhcnNlQ2xpcEF0dHJpYnV0ZXM9dD0+KDAsci5jcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkpKHttaW46dC5hdHRyaWJ1dGVzLmdldEZsb2F0KFwibWluXCIsaS5NSU5fQ0xJUCksbWF4OnQuYXR0cmlidXRlcy5nZXRGbG9hdChcIm1heFwiLGkuTUFYX0NMSVApfSksZS5jbGlwVjExPSh0LG4pPT57Y29uc3Qgcj0kKHQsbik7cmV0dXJuKDAsZS5jbGlwKSh0LFtuWzBdXSxyKX07Y29uc3QgJD0odCxlKT0+e2lmKGUubGVuZ3RoPj0zJiYoIXQuc2Vzc2lvbi5pc0luaXRpYWxpemVyKGVbMV0uZGF0YUlkKXx8IXQuc2Vzc2lvbi5pc0luaXRpYWxpemVyKGVbMl0uZGF0YUlkKSkpdGhyb3cgbmV3IEVycm9yKFwiZHluYW1pYyBjbGlwIGF0dHJpYnV0ZXMgYXJlIG5vdCBhbGxvd2VkXCIpO2NvbnN0IG49ZS5sZW5ndGg+PTM/ZVsxXS5udW1iZXJEYXRhWzBdOmkuTUlOX0NMSVAsbz1lLmxlbmd0aD49Mz9lWzJdLm51bWJlckRhdGFbMF06aS5NQVhfQ0xJUDtyZXR1cm4oMCxyLmNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSkoe21pbjpuLG1heDpvfSl9O2UuY2VpbD0odCxlKT0+W3QucnVuKEQodCxlWzBdLGYoKSksZSldLGUuY29zPSh0LGUpPT5bdC5ydW4oRCh0LGVbMF0sZCgpKSxlKV0sZS5lbHU9KHQsZSxuKT0+W3QucnVuKEQodCxlWzBdLGgobi5hbHBoYSksbi5jYWNoZUtleSksZSldLGUucGFyc2VFbHVBdHRyaWJ1dGVzPXQ9PigwLHIuY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KSh7YWxwaGE6dC5hdHRyaWJ1dGVzLmdldEZsb2F0KFwiYWxwaGFcIiwxKX0pLGUuZXhwPSh0LGUpPT5bdC5ydW4oRCh0LGVbMF0sZygpKSxlKV0sZS5mbG9vcj0odCxlKT0+W3QucnVuKEQodCxlWzBdLGIoKSksZSldLGUuaWRlbnRpdHk9KHQsZSk9Plt0LnJ1bihEKHQsZVswXSx5KCkpLGUpXSxlLmxlYWt5UmVsdT0odCxlLG4pPT5bdC5ydW4oRCh0LGVbMF0sXyhuLmFscGhhKSxuLmNhY2hlS2V5KSxlKV0sZS5wYXJzZUxlYWt5UmVsdUF0dHJpYnV0ZXM9dD0+KDAsci5jcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkpKHthbHBoYTp0LmF0dHJpYnV0ZXMuZ2V0RmxvYXQoXCJhbHBoYVwiLC4wMSl9KSxlLmxvZz0odCxlKT0+W3QucnVuKEQodCxlWzBdLHYoKSksZSldLGUubmVnPSh0LGUpPT5bdC5ydW4oRCh0LGVbMF0sdygpKSxlKV0sZS5ub3Q9KHQsZSk9Plt0LnJ1bihEKHQsZVswXSx4KCkpLGUpXSxlLnJlbHU9KHQsZSk9Plt0LnJ1bihEKHQsZVswXSxTKCkpLGUpXSxlLnNpZ21vaWQ9KHQsZSk9Plt0LnJ1bihEKHQsZVswXSxPKCkpLGUpXSxlLnNpbj0odCxlKT0+W3QucnVuKEQodCxlWzBdLFQoKSksZSldLGUuc3FydD0odCxlKT0+W3QucnVuKEQodCxlWzBdLEEoKSksZSldLGUudGFuPSh0LGUpPT5bdC5ydW4oRCh0LGVbMF0sRSgpKSxlKV0sZS50YW5oPSh0LGUpPT5bdC5ydW4oRCh0LGVbMF0sSSgpKSxlKV19LDU2MTE6KHQsZSxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUuY3JlYXRlVW5wYWNrUHJvZ3JhbUluZm9Mb2FkZXI9ZS5jcmVhdGVVbnBhY2tQcm9ncmFtSW5mbz12b2lkIDA7Y29uc3Qgcj1uKDUwNjApLGk9bigyMDM5KSxvPW4oOTM5MCksYT1uKDI4MjcpLHM9e25hbWU6XCJ1bnBhY2tcIixpbnB1dE5hbWVzOltcIkFcIl0saW5wdXRUeXBlczpbaS5UZXh0dXJlVHlwZS5wYWNrZWRdfTtlLmNyZWF0ZVVucGFja1Byb2dyYW1JbmZvPSh0LGUpPT57Y29uc3Qgbj1lLmRpbXMubGVuZ3RoLHU9KDAsYS5nZXRDaGFubmVscykoXCJyY1wiLG4pLGM9dS5zbGljZSgtMiksbD0oMCxvLmdldENvb3Jkc0RhdGFUeXBlKShuKSxwPSgwLGEudW5wYWNrRnJvbUNoYW5uZWwpKCksZj0wPT09ZS5kaW1zLmxlbmd0aD9cIlwiOmZ1bmN0aW9uKHQsZSl7aWYoMT09PXQpcmV0dXJuXCJyY1wiO2xldCBuPVwiXCI7Zm9yKGxldCByPTA7cjx0O3IrKyluKz1lW3JdLHI8dC0xJiYobis9XCIsXCIpO3JldHVybiBufShuLHUpLGQ9bjw9MT9cInJjXCI6YHZlYzIoJHtjLmpvaW4oXCIsXCIpfSlgLGg9YFxcbiAgICAke3B9XFxuICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAke2x9IHJjID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuXFxuICAgICAgIC8vIFNhbXBsZSB0aGUgdGV4dHVyZSB3aXRoIHRoZSBjb29yZHMgdG8gZ2V0IHRoZSByZ2JhIGNoYW5uZWwgdmFsdWUuXFxuICAgICAgIHZlYzQgcGFja2VkSW5wdXQgPSBnZXRBKCR7Zn0pO1xcblxcbiAgICAgICAkeygwLHIuZ2V0R2xzbCkodC5zZXNzaW9uLmJhY2tlbmQuZ2xDb250ZXh0LnZlcnNpb24pLm91dHB1dH0gPSB2ZWM0KGdldENoYW5uZWwocGFja2VkSW5wdXQsICR7ZH0pLCAwLCAwLCAwKTtcXG4gICAgIH1cXG4gICBgO3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30scykse2hhc01haW46ITAsb3V0cHV0OntkaW1zOmUuZGltcyx0eXBlOmUudHlwZSx0ZXh0dXJlVHlwZTppLlRleHR1cmVUeXBlLnVucGFja2VkfSxzaGFkZXJTb3VyY2U6aH0pfSxlLmNyZWF0ZVVucGFja1Byb2dyYW1JbmZvTG9hZGVyPSh0LG4pPT5PYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30scykse2dldDooKT0+KDAsZS5jcmVhdGVVbnBhY2tQcm9ncmFtSW5mbykodCxuKX0pfSw4NDI4Oih0LGUsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLnBhcnNlVW5zcXVlZXplQXR0cmlidXRlcz1lLnVuc3F1ZWV6ZVYxMz1lLnVuc3F1ZWV6ZT12b2lkIDA7Y29uc3Qgcj1uKDI1MTcpO2UudW5zcXVlZXplPSh0LGUsbik9PntpKGUpO2NvbnN0IG89ci5TaGFwZVV0aWwudW5zcXVlZXplU2hhcGUoZVswXS5kaW1zLG4pO3JldHVyblt0LnJlc2hhcGVVbnBhY2tlZChlWzBdLG8pXX0sZS51bnNxdWVlemVWMTM9KHQsbik9PihvKG4pLCgwLGUudW5zcXVlZXplKSh0LFtuWzBdXSxBcnJheS5mcm9tKG5bMV0uaW50ZWdlckRhdGEpKSksZS5wYXJzZVVuc3F1ZWV6ZUF0dHJpYnV0ZXM9dD0+dC5hdHRyaWJ1dGVzLmdldEludHMoXCJheGVzXCIpO2NvbnN0IGk9dD0+e2lmKCF0fHwxIT09dC5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiVW5zcXVlZXplIHJlcXVpcmVzIDEgaW5wdXQuXCIpO2lmKFwic3RyaW5nXCI9PT10WzBdLnR5cGUpdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBpbnB1dCB0ZW5zb3IgdHlwZXMuXCIpfSxvPXQ9PntpZighdHx8MiE9PXQubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIlVuc3F1ZWV6ZSByZXF1aXJlcyAyIGlucHV0cy5cIik7aWYoXCJpbnQzMlwiIT09dFsxXS50eXBlKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW5wdXQgdHlwZS5cIil9fSw5NzkzOih0LGUsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLnNjYWxlc1ZhbGlkYXRpb249ZS52YWxpZGF0ZUlucHV0cz1lLnBhcnNlVXBzYW1wbGVBdHRyaWJ1dGVzPWUucGFyc2VVcHNhbXBsZUF0dHJpYnV0ZXNWOT1lLnBhcnNlVXBzYW1wbGVBdHRyaWJ1dGVzVjc9ZS51cHNhbXBsZT12b2lkIDA7Y29uc3Qgcj1uKDI0NiksaT1uKDUwNjApLG89bigyMDM5KSxhPXtuYW1lOlwiVXBzYW1wbGVcIixpbnB1dE5hbWVzOltcIlhcIl0saW5wdXRUeXBlczpbby5UZXh0dXJlVHlwZS51bnBhY2tlZF19O2UudXBzYW1wbGU9KHQsbixyKT0+KCgwLGUudmFsaWRhdGVJbnB1dHMpKG4sciksW3QucnVuKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxhKSx7Y2FjaGVIaW50OnIuY2FjaGVLZXksZ2V0OigpPT5zKHQsbixyKX0pLG4pXSksZS5wYXJzZVVwc2FtcGxlQXR0cmlidXRlc1Y3PXQ9PigwLGUucGFyc2VVcHNhbXBsZUF0dHJpYnV0ZXMpKHQsNyksZS5wYXJzZVVwc2FtcGxlQXR0cmlidXRlc1Y5PXQ9PigwLGUucGFyc2VVcHNhbXBsZUF0dHJpYnV0ZXMpKHQsOSksZS5wYXJzZVVwc2FtcGxlQXR0cmlidXRlcz0odCxuKT0+e2NvbnN0IGk9bj49MTAsbz10LmF0dHJpYnV0ZXMuZ2V0U3RyaW5nKFwibW9kZVwiLFwibmVhcmVzdFwiKTtpZihcIm5lYXJlc3RcIiE9PW8mJlwibGluZWFyXCIhPT1vJiYobjwxMXx8XCJjdWJpY1wiIT09bykpdGhyb3cgbmV3IEVycm9yKGB1bnJlY29nbml6ZWQgbW9kZTogJHtvfWApO2xldCBhPVtdO248OSYmKGE9dC5hdHRyaWJ1dGVzLmdldEZsb2F0cyhcInNjYWxlc1wiKSwoMCxlLnNjYWxlc1ZhbGlkYXRpb24pKGEsbyxpKSk7Y29uc3Qgcz10LmF0dHJpYnV0ZXMuZ2V0RmxvYXQoXCJleHRyYXBvbGF0aW9uX3ZhbHVlXCIsMCksdT1uPjEwP3QuYXR0cmlidXRlcy5nZXRTdHJpbmcoXCJjb29yZGluYXRlX3RyYW5zZm9ybWF0aW9uX21vZGVcIixcImhhbGZfcGl4ZWxcIik6XCJhc3ltbWV0cmljXCI7aWYoLTE9PT1bXCJhc3ltbWV0cmljXCIsXCJweXRvcmNoX2hhbGZfcGl4ZWxcIixcInRmX2hhbGZfcGl4ZWxfZm9yX25uXCIsXCJhbGlnbl9jb3JuZXJzXCIsXCJ0Zl9jcm9wX2FuZF9yZXNpemVcIixcImhhbGZfcGl4ZWxcIl0uaW5kZXhPZih1KSl0aHJvdyBuZXcgRXJyb3IoYGNvb3JkaW5hdGVfdHJhbnNmb3JtX21vZGUgJyR7dX0nIGlzIG5vdCBzdXBwb3J0ZWRgKTtjb25zdCBjPVwidGZfY3JvcF9hbmRfcmVzaXplXCI9PT11LGw9YyxwPVwibmVhcmVzdFwiPT09byYmbj49MTE/dC5hdHRyaWJ1dGVzLmdldFN0cmluZyhcIm5lYXJlc3RfbW9kZVwiLFwicm91bmRfcHJlZmVyX2Zsb29yXCIpOlwiXCI7aWYoLTE9PT1bXCJyb3VuZF9wcmVmZXJfZmxvb3JcIixcInJvdW5kX3ByZWZlcl9jZWlsXCIsXCJmbG9vclwiLFwiY2VpbFwiLFwiXCJdLmluZGV4T2YocCkpdGhyb3cgbmV3IEVycm9yKGBuZWFyZXN0X21vZGUgJyR7cH0nIGlzIG5vdCBzdXBwb3J0ZWRgKTtjb25zdCBmPXQuYXR0cmlidXRlcy5nZXRGbG9hdChcImN1YmljX2NvZWZmX2FcIiwtLjc1KSxkPTAhPT10LmF0dHJpYnV0ZXMuZ2V0SW50KFwiZXhjbHVkZV9vdXRzaWRlXCIsMCk7aWYoZCYmXCJjdWJpY1wiIT09byl0aHJvdyBuZXcgRXJyb3IoXCJleGNsdWRlX291dHNpZGUgY2FuIGJlIHNldCB0byAxIG9ubHkgd2hlbiBtb2RlIGlzIENVQklDLlwiKTtjb25zdCBoPW48MTF8fFwibmVhcmVzdFwiPT09byYmXCJhc3ltbWV0cmljXCI9PT11JiZcImZsb29yXCI9PT1wO2xldCBnPTAsYj0wLG09MDtyZXR1cm4gbj4xMD90LmlucHV0cy5sZW5ndGg+Mj8oZz0xLGI9MixtPTMpOihiPTEsbT0yKTo5PT09biYmKGI9MSksKDAsci5jcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkpKHtvcHNldDpuLGlzUmVzaXplOmksbW9kZTpvLHNjYWxlczphLGV4dHJhcG9sYXRpb25WYWx1ZTpzLGNvb3JkaW5hdGVUcmFuc2Zvcm1Nb2RlOnUsdXNlRXh0cmFwb2xhdGlvbjpsLG5lZWRSb2lJbnB1dDpjLG5lYXJlc3RNb2RlOnAsY3ViaWNDb2VmZmljaWVudEE6ZixleGNsdWRlT3V0c2lkZTpkLHVzZU5lYXJlc3QyeE9wdGltaXphdGlvbjpoLHJvaUlucHV0SWR4Omcsc2NhbGVzSW5wdXRJZHg6YixzaXplc0lucHV0SWR4Om19KX07Y29uc3Qgcz0odCxlLG4pPT57Y29uc3Qgcj0oMCxpLmdldEdsc2wpKHQuc2Vzc2lvbi5iYWNrZW5kLmdsQ29udGV4dC52ZXJzaW9uKSxbcyx1XT10LmNhbGN1bGF0ZVRleHR1cmVXaWR0aEFuZEhlaWdodChlWzBdLmRpbXMsby5UZXh0dXJlVHlwZS51bnBhY2tlZCksYz1lWzBdLmRpbXMubWFwKCgodCxlKT0+TWF0aC5mbG9vcih0Km4uc2NhbGVzW2VdKSkpLFtsLHBdPXQuY2FsY3VsYXRlVGV4dHVyZVdpZHRoQW5kSGVpZ2h0KGMsby5UZXh0dXJlVHlwZS51bnBhY2tlZCksZj1jLmxlbmd0aCxkPW5ldyBBcnJheShmKSxoPW5ldyBBcnJheShmKTtsZXQgZz1gXFxuICAgICAgaW50IG91dHB1dF9waXRjaGVzWyR7Zn1dO1xcbiAgICAgIGludCBpbnB1dF9waXRjaGVzWyR7Zn1dO1xcbiAgICAgIGA7Zm9yKGxldCB0PWYtMTt0Pj0wO3QtLSlkW3RdPXQ9PT1mLTE/MTpkW3QrMV0qY1t0KzFdLGhbdF09dD09PWYtMT8xOmhbdCsxXSplWzBdLmRpbXNbdCsxXSxnKz1gXFxuICAgICAgICBvdXRwdXRfcGl0Y2hlc1ske3R9XSA9ICR7ZFt0XX07XFxuICAgICAgICBpbnB1dF9waXRjaGVzWyR7dH1dID0gJHtoW3RdfTtcXG4gICAgICAgIGA7Y29uc3QgYj1gXFxuICAgICAgZmxvYXQgZ2V0SW5wdXRGbG9hdChpbnQgaW5kZXgpIHtcXG4gICAgICAgIHZlYzIgY29vcmRzID0gb2Zmc2V0VG9Db29yZHMoaW5kZXgsICR7c30sICR7dX0pO1xcbiAgICAgICAgZmxvYXQgdmFsdWUgPSBnZXRDb2xvckFzRmxvYXQoJHtyLnRleHR1cmUyRH0oWCwgY29vcmRzKSk7XFxuICAgICAgICByZXR1cm4gdmFsdWU7XFxuICAgICAgfVxcbiAgICAgIGAsbT1cIm5lYXJlc3RcIj09PW4ubW9kZT9gXFxuICAgICR7Yn1cXG4gICAgZmxvYXQgcHJvY2VzcyhpbnQgaW5kaWNlc1ske2Z9XSkge1xcbiAgICAgIGludCBpbnB1dF9pbmRleCA9IDA7XFxuICAgICAgaW50IG91dHB1dF9pbmRleCA9IGNvb3Jkc1RvT2Zmc2V0KFRleENvb3JkcywgJHtsfSwgJHtwfSk7XFxuXFxuICAgICAgJHtnfVxcblxcbiAgICAgIGludCBkLCBtO1xcbiAgICAgIGZvciAoaW50IGRpbSA9IDA7IGRpbSA8ICR7Zn07ICsrZGltKSB7XFxuICAgICAgICBkID0gb3V0cHV0X2luZGV4IC8gb3V0cHV0X3BpdGNoZXNbZGltXTtcXG4gICAgICAgIG0gPSBvdXRwdXRfaW5kZXggLSBkICogb3V0cHV0X3BpdGNoZXNbZGltXTtcXG4gICAgICAgIG91dHB1dF9pbmRleCA9IG07XFxuXFxuICAgICAgICBpZiAoc2NhbGVzW2RpbV0gIT0gMSAmJiBkID4gMCkge1xcbiAgICAgICAgICBpbnQgZDIgPSBkIC8gc2NhbGVzW2RpbV07XFxuICAgICAgICAgIG0gPSBkIC0gZDIgKiBzY2FsZXNbZGltXTtcXG4gICAgICAgICAgZCA9IGQyO1xcbiAgICAgICAgfVxcbiAgICAgICAgaW5wdXRfaW5kZXggKz0gaW5wdXRfcGl0Y2hlc1tkaW1dICogZDtcXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIGdldElucHV0RmxvYXQoaW5wdXRfaW5kZXgpO1xcbiAgICB9YDo0PT09Zj9gXFxuICAgICR7Yn1cXG4gICAgZmxvYXQgcHJvY2VzcyhpbnQgaW5kaWNlc1s0XSkge1xcbiAgICAgIGludCBpbnB1dF9pbmRleCA9IDA7XFxuICAgICAgaW50IG91dHB1dF9pbmRleCA9IGNvb3Jkc1RvT2Zmc2V0KFRleENvb3JkcywgJHtsfSwgJHtwfSk7XFxuXFxuICAgICAgJHtnfVxcblxcbiAgICAgIGludCBtO1xcbiAgICAgIGludCBpbmRleF9vZl9kaW0wLCBpbmRleF9vZl9kaW0xLCBpbmRleF9vZl9kaW0yLCBpbmRleF9vZl9kaW0zO1xcbiAgICAgIGluZGV4X29mX2RpbTAgPSBvdXRwdXRfaW5kZXggLyBvdXRwdXRfcGl0Y2hlc1swXTtcXG4gICAgICBtID0gb3V0cHV0X2luZGV4IC0gaW5kZXhfb2ZfZGltMCAqIG91dHB1dF9waXRjaGVzWzBdO1xcbiAgICAgIGluZGV4X29mX2RpbTEgPSBtIC8gb3V0cHV0X3BpdGNoZXNbMV07XFxuICAgICAgbSA9IG0gLSBpbmRleF9vZl9kaW0xICogb3V0cHV0X3BpdGNoZXNbMV07XFxuICAgICAgaW5kZXhfb2ZfZGltMiA9IG0gLyBvdXRwdXRfcGl0Y2hlc1syXTtcXG4gICAgICBtID0gbSAtIGluZGV4X29mX2RpbTIgKiBvdXRwdXRfcGl0Y2hlc1syXTtcXG4gICAgICBpbmRleF9vZl9kaW0zID0gbTtcXG5cXG4gICAgICBpbnQgaW5kZXhfb2ZfaW5wdXRfZGltMiwgaW5kZXhfb2ZfaW5wdXRfZGltMywgeF9vZmZzZXQsIHlfb2Zmc2V0O1xcbiAgICAgIGluZGV4X29mX2lucHV0X2RpbTIgPSBpbmRleF9vZl9kaW0yIC8gc2NhbGVzWzJdO1xcbiAgICAgIHlfb2Zmc2V0ID0gaW5kZXhfb2ZfZGltMiAtIGluZGV4X29mX2lucHV0X2RpbTIgKiBzY2FsZXNbMl07XFxuICAgICAgaW5kZXhfb2ZfaW5wdXRfZGltMyA9IGluZGV4X29mX2RpbTMgLyBzY2FsZXNbM107XFxuICAgICAgeF9vZmZzZXQgPSBpbmRleF9vZl9kaW0zIC0gaW5kZXhfb2ZfaW5wdXRfZGltMyAqIHNjYWxlc1szXTtcXG5cXG4gICAgICBpbnB1dF9pbmRleCA9IGluZGV4X29mX2RpbTAgKiBpbnB1dF9waXRjaGVzWzBdICtcXG4gICAgICAgICAgICBpbmRleF9vZl9kaW0xICogaW5wdXRfcGl0Y2hlc1sxXSArXFxuICAgICAgICAgICAgaW5kZXhfb2ZfaW5wdXRfZGltMiAqIGlucHV0X3BpdGNoZXNbMl0gK1xcbiAgICAgICAgICAgIGluZGV4X29mX2lucHV0X2RpbTM7XFxuXFxuICAgICAgZmxvYXQgeDAwID0gZ2V0SW5wdXRGbG9hdChpbnB1dF9pbmRleCk7XFxuICAgICAgZmxvYXQgeDEwLCB4MDEsIHgxMTtcXG5cXG4gICAgICBib29sIGVuZF9vZl9kaW0yID0gZmFsc2U7XFxuICAgICAgaWYgKGluZGV4X29mX2lucHV0X2RpbTIgPT0gKCR7ZVswXS5kaW1zWzJdfSAtIDEpKSB7XFxuICAgICAgICAvLyBJdCdzIHRoZSBlbmQgaW4gZGltZW5zaW9uIDJcXG4gICAgICAgIHgwMSA9IHgwMDtcXG4gICAgICAgIGVuZF9vZl9kaW0yID0gdHJ1ZTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgeDAxID0gZ2V0SW5wdXRGbG9hdChpbnB1dF9pbmRleCArIGlucHV0X3BpdGNoZXNbMl0pO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoaW5kZXhfb2ZfaW5wdXRfZGltMyA9PSAoaW5wdXRfcGl0Y2hlc1syXSAtIDEpKSB7XFxuICAgICAgICAvLyBJdCdzIHRoZSBlbmQgaW4gZGltZW5zaW9uIDNcXG4gICAgICAgIHgxMCA9IHgwMDtcXG4gICAgICAgIHgxMSA9IHgwMTtcXG4gICAgICB9XFxuICAgICAgZWxzZSB7XFxuICAgICAgICB4MTAgPSBnZXRJbnB1dEZsb2F0KGlucHV0X2luZGV4ICsgMSk7XFxuICAgICAgICB4MTEgPSBlbmRfb2ZfZGltMiA/IHgxMCA6IGdldElucHV0RmxvYXQoaW5wdXRfaW5kZXggKyBpbnB1dF9waXRjaGVzWzJdICsgMSk7XFxuICAgICAgfVxcblxcbiAgICAgIGZsb2F0IHkwID0geDAwICsgZmxvYXQoeV9vZmZzZXQpICogKHgwMSAtIHgwMCkgLyBmbG9hdChzY2FsZXNbMl0pO1xcbiAgICAgIGZsb2F0IHkxID0geDEwICsgZmxvYXQoeV9vZmZzZXQpICogKHgxMSAtIHgxMCkgLyBmbG9hdChzY2FsZXNbMl0pO1xcbiAgICAgIHJldHVybiB5MCArIGZsb2F0KHhfb2Zmc2V0KSAqICh5MSAtIHkwKSAvIGZsb2F0KHNjYWxlc1szXSk7XFxuICAgIH1gOmBcXG4gICAgJHtifVxcbiAgICBmbG9hdCBwcm9jZXNzKGludCBpbmRpY2VzWzJdKSB7XFxuICAgICAgaW50IGlucHV0X2luZGV4ID0gMDtcXG4gICAgICBpbnQgb3V0cHV0X2luZGV4ID0gY29vcmRzVG9PZmZzZXQoVGV4Q29vcmRzLCAke2x9LCAke3B9KTtcXG5cXG4gICAgICAke2d9XFxuXFxuICAgICAgaW50IG07XFxuICAgICAgaW50IGluZGV4X29mX2RpbTAsIGluZGV4X29mX2RpbTE7XFxuICAgICAgaW5kZXhfb2ZfZGltMCA9IG91dHB1dF9pbmRleCAvIG91dHB1dF9waXRjaGVzWzBdO1xcbiAgICAgIG0gPSBvdXRwdXRfaW5kZXggLSBpbmRleF9vZl9kaW0wICogb3V0cHV0X3BpdGNoZXNbMF07XFxuICAgICAgaW5kZXhfb2ZfZGltMSA9IG07XFxuXFxuICAgICAgaW50IGluZGV4X29mX2lucHV0X2RpbTAsIGluZGV4X29mX2lucHV0X2RpbTEsIHhfb2Zmc2V0LCB5X29mZnNldDtcXG4gICAgICBpbmRleF9vZl9pbnB1dF9kaW0wID0gaW5kZXhfb2ZfZGltMCAvIHNjYWxlc1swXTtcXG4gICAgICB5X29mZnNldCA9IGluZGV4X29mX2RpbTAgLSBpbmRleF9vZl9pbnB1dF9kaW0wICogc2NhbGVzWzBdO1xcbiAgICAgIGluZGV4X29mX2lucHV0X2RpbTEgPSBpbmRleF9vZl9kaW0xIC8gc2NhbGVzWzFdO1xcbiAgICAgIHhfb2Zmc2V0ID0gaW5kZXhfb2ZfZGltMSAtIGluZGV4X29mX2lucHV0X2RpbTEgKiBzY2FsZXNbMV07XFxuXFxuICAgICAgaW5wdXRfaW5kZXggPSBpbmRleF9vZl9pbnB1dF9kaW0wICogaW5wdXRfcGl0Y2hlc1swXSArIGluZGV4X29mX2lucHV0X2RpbTE7XFxuXFxuICAgICAgZmxvYXQgeDAwID0gZ2V0SW5wdXRGbG9hdChpbnB1dF9pbmRleCk7XFxuICAgICAgZmxvYXQgeDEwLCB4MDEsIHgxMTtcXG5cXG4gICAgICBib29sIGVuZF9vZl9kaW0wID0gZmFsc2U7XFxuICAgICAgaWYgKGluZGV4X29mX2lucHV0X2RpbTAgPT0gKCR7ZVswXS5kaW1zWzBdfSAtIDEpKSB7XFxuICAgICAgICAvLyBJdCdzIHRoZSBlbmQgaW4gZGltZW5zaW9uIDBcXG4gICAgICAgIHgwMSA9IHgwMDtcXG4gICAgICAgIGVuZF9vZl9kaW0wID0gdHJ1ZTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgeDAxID0gZ2V0SW5wdXRGbG9hdChpbnB1dF9pbmRleCArIGlucHV0X3BpdGNoZXNbMF0pO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoaW5kZXhfb2ZfaW5wdXRfZGltMSA9PSAoaW5wdXRfcGl0Y2hlc1swXSAtIDEpKSB7XFxuICAgICAgICAvLyBJdCdzIHRoZSBlbmQgaW4gZGltZW5zaW9uIDFcXG4gICAgICAgIHgxMCA9IHgwMDtcXG4gICAgICAgIHgxMSA9IHgwMTtcXG4gICAgICB9XFxuICAgICAgZWxzZSB7XFxuICAgICAgICB4MTAgPSBnZXRJbnB1dEZsb2F0KGlucHV0X2luZGV4ICsgMSk7XFxuICAgICAgICB4MTEgPSBlbmRfb2ZfZGltMCA/IHgxMCA6IGdldElucHV0RmxvYXQoaW5wdXRfaW5kZXggKyBpbnB1dF9waXRjaGVzWzBdICsgMSk7XFxuICAgICAgfVxcblxcbiAgICAgIGZsb2F0IHkwID0geDAwICsgZmxvYXQoeV9vZmZzZXQpICogKHgwMSAtIHgwMCkgLyBmbG9hdChzY2FsZXNbMF0pO1xcbiAgICAgIGZsb2F0IHkxID0geDEwICsgZmxvYXQoeV9vZmZzZXQpICogKHgxMSAtIHgxMCkgLyBmbG9hdChzY2FsZXNbMF0pO1xcbiAgICAgIHJldHVybiB5MCArIGZsb2F0KHhfb2Zmc2V0KSAqICh5MSAtIHkwKSAvIGZsb2F0KHNjYWxlc1sxXSk7XFxuICAgIH1gO3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sYSkse291dHB1dDp7ZGltczpjLHR5cGU6ZVswXS50eXBlLHRleHR1cmVUeXBlOm8uVGV4dHVyZVR5cGUudW5wYWNrZWR9LHNoYWRlclNvdXJjZTptLHZhcmlhYmxlczpbe25hbWU6XCJzY2FsZXNcIix0eXBlOlwiaW50XCIsYXJyYXlMZW5ndGg6bi5zY2FsZXMubGVuZ3RoLGRhdGE6bi5zY2FsZXMubWFwKCh0PT5NYXRoLmNlaWwodCkpKX1dfSl9O2UudmFsaWRhdGVJbnB1dHM9KHQsZSk9PntpZighdHx8ZS5vcHNldDw5JiYxIT09dC5sZW5ndGh8fGUub3BzZXQ+PTkmJmUub3BzZXQ8MTEmJjIhPT10Lmxlbmd0aHx8ZS5vcHNldD49MTEmJnQubGVuZ3RoPDIpdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBpbnB1dHMuXCIpO2lmKGUuc2NhbGVzLmxlbmd0aD4wJiZ0WzBdLmRpbXMubGVuZ3RoIT09ZS5zY2FsZXMubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW5wdXQgc2hhcGUuXCIpO2lmKFwic3RyaW5nXCI9PT10WzBdLnR5cGUpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpbnB1dCB0ZW5zb3IgdHlwZXMuXCIpfSxlLnNjYWxlc1ZhbGlkYXRpb249KHQsZSxuKT0+e2lmKG4pe2Zvcihjb25zdCBlIG9mIHQpaWYoZTw9MCl0aHJvdyBuZXcgRXJyb3IoXCJTY2FsZSB2YWx1ZSBzaG91bGQgYmUgZ3JlYXRlciB0aGFuIDAuXCIpfWVsc2UgZm9yKGNvbnN0IGUgb2YgdClpZihlPDEpdGhyb3cgbmV3IEVycm9yKFwiU2NhbGUgdmFsdWUgc2hvdWxkIGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAxLlwiKTtpZighKFwibGluZWFyXCIhPT1lJiZcImN1YmljXCIhPT1lfHwyPT09dC5sZW5ndGh8fDQ9PT10Lmxlbmd0aCYmMT09PXRbMF0mJjE9PT10WzFdKSl0aHJvdyBuZXcgRXJyb3IoYCdMaW5lYXInIG1vZGUgYW5kICdDdWJpYycgbW9kZSBvbmx5IHN1cHBvcnQgMi1EIGlucHV0cyAoJ0JpbGluZWFyJywgJ0JpY3ViaWMnKSAgICAgICAgIG9yIDQtRCBpbnB1dHMgd2l0aCB0aGUgY29ycmVzcG9uZGluZyBvdXRlcm1vc3QgMiBzY2FsZSB2YWx1ZXMgYmVpbmcgMSAgICAgICAgIGluIHRoZSAke24/XCJSZXNpemVcIjpcIlVwc2FtcGxlXCJ9IG9wZWFydG9yLmApfX0sMTk1ODoodCxlLG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5Qcm9ncmFtTWFuYWdlcj12b2lkIDA7Y29uc3Qgcj1uKDE2NzApLGk9big2MjMxKSxvPW4oODg3OSksYT1uKDUwNjApO2UuUHJvZ3JhbU1hbmFnZXI9Y2xhc3N7Y29uc3RydWN0b3IodCxlLG4pe3RoaXMucHJvZmlsZXI9dCx0aGlzLmdsQ29udGV4dD1lLHRoaXMudGV4dHVyZUxheW91dFN0cmF0ZWd5PW4sdGhpcy5yZXBvPW5ldyBNYXAsdGhpcy5hdHRyaWJ1dGVzQm91bmQ9ITF9Z2V0QXJ0aWZhY3QodCl7cmV0dXJuIHRoaXMucmVwby5nZXQodCl9c2V0QXJ0aWZhY3QodCxlKXt0aGlzLnJlcG8uc2V0KHQsZSl9cnVuKHQsZSxuKXt2YXIgcjt0aGlzLnByb2ZpbGVyLmV2ZW50KFwib3BcIixgUHJvZ3JhbU1hbmFnZXIucnVuICR7bnVsbCE9PShyPXQucHJvZ3JhbUluZm8ubmFtZSkmJnZvaWQgMCE9PXI/cjpcInVua25vd24ga2VybmVsXCJ9YCwoKCk9Pnt2YXIgcjtjb25zdCBvPXRoaXMuZ2xDb250ZXh0LmdsLGE9dC5wcm9ncmFtO28udXNlUHJvZ3JhbShhKTt0cnl7dGhpcy5iaW5kT3V0cHV0KG4pLHRoaXMuYXR0cmlidXRlc0JvdW5kfHx0aGlzLmJpbmRBdHRyaWJ1dGVzKHQuYXR0cmliTG9jYXRpb25zKSx0aGlzLmJpbmRVbmlmb3Jtcyh0LnVuaWZvcm1Mb2NhdGlvbnMsbnVsbCE9PShyPXQucHJvZ3JhbUluZm8udmFyaWFibGVzKSYmdm9pZCAwIT09cj9yOltdLGUpfWNhdGNoKGUpe3Rocm93IGkuTG9nZ2VyLmVycm9yKFwiUHJvZ3JhbU1hbmFnZXJcIix0LnByb2dyYW1JbmZvLnNoYWRlclNvdXJjZSksZX10aGlzLnByb2ZpbGVyLmV2ZW50KFwiYmFja2VuZFwiLFwiR2xDb250ZXh0LmRyYXcoKVwiLCgoKT0+e3RoaXMuZ2xDb250ZXh0LmRyYXcoKX0pKX0pLHRoaXMuZ2xDb250ZXh0KX1kaXNwb3NlKCl7dGhpcy52ZXJ0ZXhTaGFkZXImJnRoaXMuZ2xDb250ZXh0LmRlbGV0ZVNoYWRlcih0aGlzLnZlcnRleFNoYWRlciksdGhpcy5yZXBvLmZvckVhY2goKHQ9PnRoaXMuZ2xDb250ZXh0LmRlbGV0ZVByb2dyYW0odC5wcm9ncmFtKSkpfWJ1aWxkKHQsZSxuKXtyZXR1cm4gdGhpcy5wcm9maWxlci5ldmVudChcImJhY2tlbmRcIixcIlByb2dyYW1NYW5hZ2VyLmJ1aWxkXCIsKCgpPT57Y29uc3Qgcj1uZXcgby5HbHNsUHJlcHJvY2Vzc29yKHRoaXMuZ2xDb250ZXh0LHQsZSxuKSxpPXIucHJlcHJvY2VzcygpLGE9dGhpcy5jb21waWxlKGkpO3JldHVybntwcm9ncmFtSW5mbzp0LHByb2dyYW06YSx1bmlmb3JtTG9jYXRpb25zOnRoaXMuZ2V0VW5pZm9ybUxvY2F0aW9ucyhhLHIuY29udGV4dC5wcm9ncmFtSW5mby5pbnB1dE5hbWVzLHIuY29udGV4dC5wcm9ncmFtSW5mby52YXJpYWJsZXMpLGF0dHJpYkxvY2F0aW9uczp0aGlzLmdldEF0dHJpYkxvY2F0aW9ucyhhKX19KSl9Y29tcGlsZSh0KXtpZighdGhpcy52ZXJ0ZXhTaGFkZXIpe2kuTG9nZ2VyLnZlcmJvc2UoXCJQcm9yZ3JhbU1hbmFnZXJcIixcIkNvbXBpbGluZyBhbmQgY2FjaGluZyBWZXJ0ZXggc2hhZGVyIGZvciB0aGUgZmlyc3QgdGltZVwiKTtjb25zdCB0PSgwLGEuZ2V0VmVydGV4U2hhZGVyU291cmNlKSh0aGlzLmdsQ29udGV4dC52ZXJzaW9uKTt0aGlzLnZlcnRleFNoYWRlcj10aGlzLmdsQ29udGV4dC5jb21waWxlU2hhZGVyKHQsdGhpcy5nbENvbnRleHQuZ2wuVkVSVEVYX1NIQURFUil9ci5lbnYuZGVidWcmJmkuTG9nZ2VyLnZlcmJvc2UoXCJQcm9yZ3JhbU1hbmFnZXJcIixgRnJhZ1NoYWRlcjpcXG4ke3R9XFxuYCk7Y29uc3QgZT10aGlzLmdsQ29udGV4dC5jb21waWxlU2hhZGVyKHQsdGhpcy5nbENvbnRleHQuZ2wuRlJBR01FTlRfU0hBREVSKSxuPXRoaXMuZ2xDb250ZXh0LmNyZWF0ZVByb2dyYW0odGhpcy52ZXJ0ZXhTaGFkZXIsZSk7cmV0dXJuIHRoaXMuZ2xDb250ZXh0LmRlbGV0ZVNoYWRlcihlKSxufWJpbmRPdXRwdXQodCl7Y29uc3QgZT10LndpZHRoLG49dC5oZWlnaHQ7aS5Mb2dnZXIudmVyYm9zZShcIlByb3JncmFtTWFuYWdlclwiLGBCaW5kaW5nIG91dHB1dCB0ZXh0dXJlIHRvIEZyYW1lYnVmZmVyOiB3L2g9JHtlfS8ke259LCBzaGFwZT0ke3Quc2hhcGV9LCB0eXBlPSR7dC50ZW5zb3IudHlwZX1gKSx0aGlzLmdsQ29udGV4dC5hdHRhY2hGcmFtZWJ1ZmZlcih0LnRleHR1cmUsZSxuKX1iaW5kQXR0cmlidXRlcyh0KXtjb25zdCBlPXQucG9zaXRpb24sbj10LnRleHR1cmVDb29yZDt0aGlzLmdsQ29udGV4dC5zZXRWZXJ0ZXhBdHRyaWJ1dGVzKGUsbiksdGhpcy5hdHRyaWJ1dGVzQm91bmQ9ITB9YmluZFVuaWZvcm1zKHQsZSxuKXt2YXIgcjtjb25zdCBpPXRoaXMuZ2xDb250ZXh0LmdsO2xldCBvPTA7Zm9yKGNvbnN0e25hbWU6YSx0eXBlOnMsbG9jYXRpb246dSxhcnJheUxlbmd0aDpjfW9mIHQpe2NvbnN0IHQ9bnVsbD09PShyPWUuZmluZCgodD0+dC5uYW1lPT09YSkpKXx8dm9pZCAwPT09cj92b2lkIDA6ci5kYXRhO2lmKFwic2FtcGxlcjJEXCIhPT1zJiYhdCl0aHJvdyBuZXcgRXJyb3IoYHZhcmlhYmxlICcke2F9JyBkb2VzIG5vdCBoYXZlIGRhdGEgZGVmaW5lZCBpbiBwcm9ncmFtIGluZm9gKTtzd2l0Y2gocyl7Y2FzZVwic2FtcGxlcjJEXCI6dGhpcy5iaW5kVGV4dHVyZShuW29dLHUsbyksbysrO2JyZWFrO2Nhc2VcImZsb2F0XCI6Yz9pLnVuaWZvcm0xZnYodSx0KTppLnVuaWZvcm0xZih1LHQpO2JyZWFrO2Nhc2VcImludFwiOmM/aS51bmlmb3JtMWl2KHUsdCk6aS51bmlmb3JtMWkodSx0KTticmVhaztkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgVW5pZm9ybSBub3QgaW1wbGVtZW50ZWQ6ICR7c31gKX19fWJpbmRUZXh0dXJlKHQsZSxuKXt0aGlzLmdsQ29udGV4dC5iaW5kVGV4dHVyZVRvVW5pZm9ybSh0LnRleHR1cmUsbixlKX1nZXRBdHRyaWJMb2NhdGlvbnModCl7cmV0dXJue3Bvc2l0aW9uOnRoaXMuZ2V0QXR0cmliTG9jYXRpb24odCxcInBvc2l0aW9uXCIpLHRleHR1cmVDb29yZDp0aGlzLmdldEF0dHJpYkxvY2F0aW9uKHQsXCJ0ZXh0dXJlQ29vcmRcIil9fWdldFVuaWZvcm1Mb2NhdGlvbnModCxlLG4pe2NvbnN0IHI9W107aWYoZSlmb3IoY29uc3QgbiBvZiBlKXIucHVzaCh7bmFtZTpuLHR5cGU6XCJzYW1wbGVyMkRcIixsb2NhdGlvbjp0aGlzLmdldFVuaWZvcm1Mb2NhdGlvbih0LG4pfSk7aWYobilmb3IoY29uc3QgZSBvZiBuKXIucHVzaChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sZSkse2xvY2F0aW9uOnRoaXMuZ2V0VW5pZm9ybUxvY2F0aW9uKHQsZS5uYW1lKX0pKTtyZXR1cm4gcn1nZXRVbmlmb3JtTG9jYXRpb24odCxlKXtjb25zdCBuPXRoaXMuZ2xDb250ZXh0LmdsLmdldFVuaWZvcm1Mb2NhdGlvbih0LGUpO2lmKG51bGw9PT1uKXRocm93IG5ldyBFcnJvcihgVW5pZm9ybSAke2V9IG5vdCBmb3VuZC5gKTtyZXR1cm4gbn1nZXRBdHRyaWJMb2NhdGlvbih0LGUpe3JldHVybiB0aGlzLmdsQ29udGV4dC5nbC5nZXRBdHRyaWJMb2NhdGlvbih0LGUpfX19LDY0MTY6KHQsZSxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUuV2ViR0xTZXNzaW9uSGFuZGxlcj12b2lkIDA7Y29uc3Qgcj1uKDYyMzEpLGk9bigxMDQ3KSxvPW4oODMxNiksYT1uKDE2NDApLHM9bigxOTU4KSx1PW4oNzg1OSksYz1uKDU3MDIpO2UuV2ViR0xTZXNzaW9uSGFuZGxlcj1jbGFzc3tjb25zdHJ1Y3Rvcih0LGUpe3RoaXMuYmFja2VuZD10LHRoaXMuY29udGV4dD1lLHRoaXMubGF5b3V0U3RyYXRlZ3k9bmV3IHUuUHJlZmVyTG9naWNhbFN0cmF0ZWd5KHQuZ2xDb250ZXh0Lm1heFRleHR1cmVTaXplKSx0aGlzLnByb2dyYW1NYW5hZ2VyPW5ldyBzLlByb2dyYW1NYW5hZ2VyKHRoaXMuY29udGV4dC5wcm9maWxlcix0LmdsQ29udGV4dCx0aGlzLmxheW91dFN0cmF0ZWd5KSx0aGlzLnRleHR1cmVNYW5hZ2VyPW5ldyBjLlRleHR1cmVNYW5hZ2VyKHQuZ2xDb250ZXh0LHRoaXMubGF5b3V0U3RyYXRlZ3ksdGhpcy5jb250ZXh0LnByb2ZpbGVyLHtyZXVzZVRleHR1cmVzOlwiZnVsbFwiPT09dC50ZXh0dXJlQ2FjaGVNb2RlfSksdGhpcy5wYWNrZWRUZXh0dXJlRGF0YUNhY2hlPW5ldyBNYXAsdGhpcy51bnBhY2tlZFRleHR1cmVEYXRhQ2FjaGU9bmV3IE1hcCx0aGlzLnBhY2s9dC5wYWNrLHRoaXMucGFjazJ1bnBhY2tNYXA9bmV3IE1hcCx0aGlzLnVucGFjazJwYWNrTWFwPW5ldyBNYXB9Y3JlYXRlSW5mZXJlbmNlSGFuZGxlcigpe3JldHVybiBuZXcgby5XZWJHTEluZmVyZW5jZUhhbmRsZXIodGhpcyl9b25HcmFwaEluaXRpYWxpemVkKHQpe2NvbnN0IGU9dC5nZXRWYWx1ZXMoKS5maWx0ZXIoKHQ9Pi0xPT09dC5mcm9tJiZ0LnRlbnNvcikpLm1hcCgodD0+dC50ZW5zb3IuZGF0YUlkKSk7dGhpcy5pbml0aWFsaXplcnM9bmV3IFNldChlKX1pc0luaXRpYWxpemVyKHQpe3JldHVybiEhdGhpcy5pbml0aWFsaXplcnMmJnRoaXMuaW5pdGlhbGl6ZXJzLmhhcyh0KX1hZGRJbml0aWFsaXplcih0KXt0aGlzLmluaXRpYWxpemVycy5hZGQodCl9Z2V0VGV4dHVyZURhdGEodCxlKXtyZXR1cm4gZT90aGlzLnBhY2tlZFRleHR1cmVEYXRhQ2FjaGUuZ2V0KHQpOnRoaXMudW5wYWNrZWRUZXh0dXJlRGF0YUNhY2hlLmdldCh0KX1zZXRUZXh0dXJlRGF0YSh0LGUsbj0hMSl7ci5Mb2dnZXIudmVyYm9zZShcIldlYkdMU2Vzc2lvbkhhbmRsZXJcIixcIlN0b3JpbmcgVGV4dHVyZSBkYXRhIGluIGNhY2hlXCIpLG4/dGhpcy5wYWNrZWRUZXh0dXJlRGF0YUNhY2hlLnNldCh0LGUpOnRoaXMudW5wYWNrZWRUZXh0dXJlRGF0YUNhY2hlLnNldCh0LGUpfWRpc3Bvc2UoKXt0aGlzLnByb2dyYW1NYW5hZ2VyLmRpc3Bvc2UoKSx0aGlzLnRleHR1cmVNYW5hZ2VyLmNsZWFyQWN0aXZlVGV4dHVyZXMoKSx0aGlzLnBhY2tlZFRleHR1cmVEYXRhQ2FjaGUuZm9yRWFjaCgodD0+dGhpcy50ZXh0dXJlTWFuYWdlci5yZWxlYXNlVGV4dHVyZSh0LCEwKSkpLHRoaXMucGFja2VkVGV4dHVyZURhdGFDYWNoZT1uZXcgTWFwLHRoaXMudW5wYWNrZWRUZXh0dXJlRGF0YUNhY2hlLmZvckVhY2goKHQ9PnRoaXMudGV4dHVyZU1hbmFnZXIucmVsZWFzZVRleHR1cmUodCwhMCkpKSx0aGlzLnVucGFja2VkVGV4dHVyZURhdGFDYWNoZT1uZXcgTWFwfXJlc29sdmUodCxlLG4pe2NvbnN0IHI9KDAsaS5yZXNvbHZlT3BlcmF0b3IpKHQsZSxhLldFQkdMX09QX1JFU09MVkVfUlVMRVMpO3JldHVybntpbXBsOnIub3BJbXBsLGNvbnRleHQ6ci5vcEluaXQ/ci5vcEluaXQodCxuKTp0fX19fSw3NzY5Oih0LGUsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLlVpbnQ4RGF0YUVuY29kZXI9ZS5SR0JBRmxvYXREYXRhRW5jb2Rlcj1lLlJlZEZsb2F0MzJEYXRhRW5jb2Rlcj12b2lkIDA7Y29uc3Qgcj1uKDYyMzEpO2UuUmVkRmxvYXQzMkRhdGFFbmNvZGVyPWNsYXNze2NvbnN0cnVjdG9yKHQsZT0xKXtpZigxPT09ZSl0aGlzLmludGVybmFsRm9ybWF0PXQuUjMyRix0aGlzLmZvcm1hdD10LlJFRCx0aGlzLnRleHR1cmVUeXBlPXQuRkxPQVQsdGhpcy5jaGFubmVsU2l6ZT1lO2Vsc2V7aWYoNCE9PWUpdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIG51bWJlciBvZiBjaGFubmVsczogJHtlfWApO3RoaXMuaW50ZXJuYWxGb3JtYXQ9dC5SR0JBMzJGLHRoaXMuZm9ybWF0PXQuUkdCQSx0aGlzLnRleHR1cmVUeXBlPXQuRkxPQVQsdGhpcy5jaGFubmVsU2l6ZT1lfX1lbmNvZGUodCxlKXtsZXQgbixpO3JldHVybiB0LmNvbnN0cnVjdG9yIT09RmxvYXQzMkFycmF5JiYoci5Mb2dnZXIud2FybmluZyhcIkVuY29kZXJcIixcImRhdGEgd2FzIG5vdCBvZiB0eXBlIEZsb2F0MzI7IGNyZWF0aW5nIG5ldyBGbG9hdDMyQXJyYXlcIiksaT1uZXcgRmxvYXQzMkFycmF5KHQpKSxlKnRoaXMuY2hhbm5lbFNpemU+dC5sZW5ndGg/KHIuTG9nZ2VyLndhcm5pbmcoXCJFbmNvZGVyXCIsXCJTb3VyY2UgZGF0YSB0b28gc21hbGwuIEFsbG9jYXRpbmcgbGFyZ2VyIGFycmF5XCIpLGk9dCxuPXRoaXMuYWxsb2NhdGUoZSp0aGlzLmNoYW5uZWxTaXplKSxpLmZvckVhY2goKCh0LGUpPT5uW2VdPXQpKSk6KGk9dCxuPWkpLG59YWxsb2NhdGUodCl7cmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkoNCp0KX1kZWNvZGUodCxlKXtyZXR1cm4gMT09PXRoaXMuY2hhbm5lbFNpemU/dC5maWx0ZXIoKCh0LGUpPT5lJTQ9PTApKS5zdWJhcnJheSgwLGUpOnQuc3ViYXJyYXkoMCxlKX19LGUuUkdCQUZsb2F0RGF0YUVuY29kZXI9Y2xhc3N7Y29uc3RydWN0b3IodCxlPTEsbil7aWYoMSE9PWUmJjQhPT1lKXRocm93IG5ldyBFcnJvcihgSW52YWxpZCBudW1iZXIgb2YgY2hhbm5lbHM6ICR7ZX1gKTt0aGlzLmludGVybmFsRm9ybWF0PXQuUkdCQSx0aGlzLmZvcm1hdD10LlJHQkEsdGhpcy5jaGFubmVsU2l6ZT1lLHRoaXMudGV4dHVyZVR5cGU9bnx8dC5GTE9BVH1lbmNvZGUodCxlKXtsZXQgbj10O3JldHVybiAxPT09dGhpcy5jaGFubmVsU2l6ZSYmKHIuTG9nZ2VyLnZlcmJvc2UoXCJFbmNvZGVyXCIsXCJFeHBsb2RpbmcgaW50byBhIGxhcmdlciBhcnJheVwiKSxuPXRoaXMuYWxsb2NhdGUoZSksdC5mb3JFYWNoKCgodCxlKT0+bls0KmVdPXQpKSksbn1hbGxvY2F0ZSh0KXtyZXR1cm4gbmV3IEZsb2F0MzJBcnJheSg0KnQpfWRlY29kZSh0LGUpe3JldHVybiAxPT09dGhpcy5jaGFubmVsU2l6ZT90LmZpbHRlcigoKHQsZSk9PmUlND09MCkpLnN1YmFycmF5KDAsZSk6dC5zdWJhcnJheSgwLGUpfX0sZS5VaW50OERhdGFFbmNvZGVyPWNsYXNze2NvbnN0cnVjdG9yKHQsZT0xKXtpZih0aGlzLmNoYW5uZWxTaXplPTQsMT09PWUpdGhpcy5pbnRlcm5hbEZvcm1hdD10LkFMUEhBLHRoaXMuZm9ybWF0PXQuQUxQSEEsdGhpcy50ZXh0dXJlVHlwZT10LlVOU0lHTkVEX0JZVEUsdGhpcy5jaGFubmVsU2l6ZT1lO2Vsc2V7aWYoNCE9PWUpdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIG51bWJlciBvZiBjaGFubmVsczogJHtlfWApO3RoaXMuaW50ZXJuYWxGb3JtYXQ9dC5SR0JBLHRoaXMuZm9ybWF0PXQuUkdCQSx0aGlzLnRleHR1cmVUeXBlPXQuVU5TSUdORURfQllURSx0aGlzLmNoYW5uZWxTaXplPWV9fWVuY29kZSh0LGUpe3JldHVybiBuZXcgVWludDhBcnJheSh0LmJ1ZmZlcix0LmJ5dGVPZmZzZXQsdC5ieXRlTGVuZ3RoKX1hbGxvY2F0ZSh0KXtyZXR1cm4gbmV3IFVpbnQ4QXJyYXkodCp0aGlzLmNoYW5uZWxTaXplKX1kZWNvZGUodCxlKXtpZih0IGluc3RhbmNlb2YgVWludDhBcnJheSlyZXR1cm4gdC5zdWJhcnJheSgwLGUpO3Rocm93IG5ldyBFcnJvcihgSW52YWxpZCBhcnJheSB0eXBlOiAke3QuY29uc3RydWN0b3J9YCl9fX0sNzg1OToodCxlLG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5nZXRCYXRjaERpbT1lLnNpemVUb1NxdWFyaXNoU2hhcGU9ZS5nZXRSb3dzQ29scz1lLnNpemVGcm9tU2hhcGU9ZS5pc0ludD1lLnBhcnNlQXhpc1BhcmFtPWUuc3F1ZWV6ZVNoYXBlPWUuUHJlZmVyTG9naWNhbFN0cmF0ZWd5PWUuQWx3YXlzS2VlcE9yaWdpbmFsU2l6ZVN0cmF0ZWd5PXZvaWQgMDtjb25zdCByPW4oNjIzMSksaT1uKDI1MTcpO2Z1bmN0aW9uIG8odCxlKXtjb25zdCBuPVtdLHI9W10saT1udWxsIT1lJiZBcnJheS5pc0FycmF5KGUpJiYwPT09ZS5sZW5ndGgsbz1udWxsPT1lfHxpP251bGw6YShlLHQpLnNvcnQoKTtsZXQgcz0wO2ZvcihsZXQgZT0wO2U8dC5sZW5ndGg7KytlKXtpZihudWxsIT1vKXtpZihvW3NdPT09ZSYmMSE9PXRbZV0pdGhyb3cgbmV3IEVycm9yKGBDYW4ndCBzcXVlZXplIGF4aXMgJHtlfSBzaW5jZSBpdHMgZGltICcke3RbZV19JyBpcyBub3QgMWApOyhudWxsPT1vW3NdfHxvW3NdPmUpJiYxPT09dFtlXSYmKG4ucHVzaCh0W2VdKSxyLnB1c2goZSkpLG9bc108PWUmJnMrK30xIT09dFtlXSYmKG4ucHVzaCh0W2VdKSxyLnB1c2goZSkpfXJldHVybntuZXdTaGFwZTpuLGtlcHREaW1zOnJ9fWZ1bmN0aW9uIGEodCxlKXtjb25zdCBuPWUubGVuZ3RoO3JldHVybiB0PW51bGw9PXQ/ZS5tYXAoKCh0LGUpPT5lKSk6W10uY29uY2F0KHQpLCgwLGkuYXNzZXJ0KSh0LmV2ZXJ5KCh0PT50Pj0tbiYmdDxuKSksKCgpPT5gQWxsIHZhbHVlcyBpbiBheGlzIHBhcmFtIG11c3QgYmUgaW4gcmFuZ2UgWy0ke259LCAke259KSBidXQgZ290IGF4aXMgJHt0fWApKSwoMCxpLmFzc2VydCkodC5ldmVyeShzKSwoKCk9PmBBbGwgdmFsdWVzIGluIGF4aXMgcGFyYW0gbXVzdCBiZSBpbnRlZ2VycyBidXQgZ290IGF4aXMgJHt0fWApKSx0Lm1hcCgodD0+dDwwP24rdDp0KSl9ZnVuY3Rpb24gcyh0KXtyZXR1cm4gdCUxPT0wfWZ1bmN0aW9uIHUodCl7aWYoMD09PXQubGVuZ3RoKXJldHVybiAxO2xldCBlPXRbMF07Zm9yKGxldCBuPTE7bjx0Lmxlbmd0aDtuKyspZSo9dFtuXTtyZXR1cm4gZX1mdW5jdGlvbiBjKHQpe2NvbnN0IGU9TWF0aC5jZWlsKE1hdGguc3FydCh0KSk7cmV0dXJuW2UsTWF0aC5jZWlsKHQvZSldfWUuQWx3YXlzS2VlcE9yaWdpbmFsU2l6ZVN0cmF0ZWd5PWNsYXNze2NvbnN0cnVjdG9yKHQpe3RoaXMubWF4VGV4dHVyZVNpemU9dH1jb21wdXRlVGV4dHVyZVdIKHQsZSl7aWYoMD09PXQubGVuZ3RoKXJldHVyblsxLDFdO2NvbnN0IG49dGhpcy5tYXhUZXh0dXJlU2l6ZTtpZihlJiZ2b2lkIDAhPT1lLmJyZWFrQXhpcyl7Y29uc3QgaT1lLmJyZWFrQXhpcz49dC5sZW5ndGg/MTp0LnNsaWNlKGUuYnJlYWtBeGlzKS5yZWR1Y2UoKCh0LGUpPT50KmUpKSxvPWUuYnJlYWtBeGlzPD0wPzE6dC5zbGljZSgwLGUuYnJlYWtBeGlzKS5yZWR1Y2UoKCh0LGUpPT50KmUpKTtpZighKGk+bnx8bz5uKSlyZXR1cm5baSxvXTtyLkxvZ2dlci52ZXJib3NlKFwiVGV4dHVyZUxheW91dFwiLGBHaXZlbiB3aWR0aC9oZWlnaHQgcHJlZmVyZW5jZXMgd2VyZSB1bmF0dGFpbmFibGU6IHNoYXBlOiR7dH0sIGJyZWFrQXhpczoke2UuYnJlYWtBeGlzfWApfWNvbnN0IGk9dC5yZWR1Y2UoKCh0LGUpPT50KmUpKTtsZXQgbz1NYXRoLmZsb29yKE1hdGguc3FydChpKSk7Zm9yKDtvPG4mJm88aSYmaSVvIT0wO28rKyk7aWYobz49bnx8aSVvIT0wKXRocm93IG5ldyBFcnJvcihgVGhlIGdpdmVuIGRpbWVuc2lvbnMgYXJlIG91dHNpZGUgdGhpcyBHUFUncyBib3VuZGFyaWVzOiAke3R9YCk7cmV0dXJuW28saS9vXX19LGUuUHJlZmVyTG9naWNhbFN0cmF0ZWd5PWNsYXNze2NvbnN0cnVjdG9yKHQpe3RoaXMubWF4VGV4dHVyZVNpemU9dH1jb21wdXRlVGV4dHVyZVdIKHQsZSl7Y29uc3Qgbj10aGlzLmNvbXB1dGVUZXh0dXJlKHQsZSk7cmV0dXJuIGUmJmUuaXNQYWNrZWQmJihuWzBdLz0yLG5bMV0vPTIpLGUmJmUucmV2ZXJzZVdIP1tuWzFdLG5bMF1dOm59Y29tcHV0ZVRleHR1cmUodCxlKXtjb25zdCBuPWUmJmUuaXNQYWNrZWQ7aWYoMD09PXQubGVuZ3RoKXJldHVybiBuP1syLDJdOlsxLDFdO2xldCBpPXRoaXMubWF4VGV4dHVyZVNpemU7aWYoZSYmdm9pZCAwIT09ZS5icmVha0F4aXMpe2NvbnN0IG49ZS5icmVha0F4aXM+PXQubGVuZ3RoPzE6dC5zbGljZShlLmJyZWFrQXhpcykucmVkdWNlKCgodCxlKT0+dCplKSksbz1lLmJyZWFrQXhpczw9MD8xOnQuc2xpY2UoMCxlLmJyZWFrQXhpcykucmVkdWNlKCgodCxlKT0+dCplKSk7aWYoIShuPml8fG8+aSkpcmV0dXJuW24sb107ci5Mb2dnZXIudmVyYm9zZShcIlRleHR1cmVMYXlvdXRcIixgR2l2ZW4gd2lkdGgvaGVpZ2h0IHByZWZlcmVuY2VzIHdlcmUgdW5hdHRhaW5hYmxlOiBzaGFwZToke3R9LCBicmVha0F4aXM6JHtlLmJyZWFrQXhpc31gKX1sZXQgYT10LnNsaWNlKDApO2lmKG4mJihpKj0yLGE9YS5tYXAoKCh0LGUpPT5lPj1hLmxlbmd0aC0yP2FbZV0lMj09MD9hW2VdOmFbZV0rMTphW2VdKSksMT09PWEubGVuZ3RoJiYoYT1bMixhWzBdXSkpLDIhPT1hLmxlbmd0aCl7Y29uc3QgdD1vKGEpO2E9dC5uZXdTaGFwZX1jb25zdCBzPXUoYSk7cmV0dXJuIGEubGVuZ3RoPD0xJiZzPD1pP1sxLHNdOjI9PT1hLmxlbmd0aCYmYVswXTw9aSYmYVsxXTw9aT9hOjM9PT1hLmxlbmd0aCYmYVswXSphWzFdPD1pJiZhWzJdPD1pP1thWzBdKmFbMV0sYVsyXV06Mz09PWEubGVuZ3RoJiZhWzBdPD1pJiZhWzFdKmFbMl08PWk/W2FbMF0sYVsxXSphWzJdXTo0PT09YS5sZW5ndGgmJmFbMF0qYVsxXSphWzJdPD1pJiZhWzNdPD1pP1thWzBdKmFbMV0qYVsyXSxhWzNdXTo0PT09YS5sZW5ndGgmJmFbMF08PWkmJmFbMV0qYVsyXSphWzNdPD1pP1thWzBdLGFbMV0qYVsyXSphWzNdXTpuP2Mocy80KS5tYXAoKHQ9PjIqdCkpOmMocyl9fSxlLnNxdWVlemVTaGFwZT1vLGUucGFyc2VBeGlzUGFyYW09YSxlLmlzSW50PXMsZS5zaXplRnJvbVNoYXBlPXUsZS5nZXRSb3dzQ29scz1mdW5jdGlvbih0KXtpZigwPT09dC5sZW5ndGgpdGhyb3cgRXJyb3IoXCJDYW5ub3QgZ2V0IHJvd3MgYW5kIGNvbHVtbnMgb2YgYW4gZW1wdHkgc2hhcGUgYXJyYXkuXCIpO3JldHVyblt0Lmxlbmd0aD4xP3RbdC5sZW5ndGgtMl06MSx0W3QubGVuZ3RoLTFdXX0sZS5zaXplVG9TcXVhcmlzaFNoYXBlPWMsZS5nZXRCYXRjaERpbT1mdW5jdGlvbih0LGU9Mil7cmV0dXJuIHUodC5zbGljZSgwLHQubGVuZ3RoLWUpKX19LDQwNTc6KHQsZSxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUuY3JlYXRlVGV4dHVyZUxheW91dEZyb21TaGFwZT1lLmNhbGN1bGF0ZVRleHR1cmVXaWR0aEFuZEhlaWdodD1lLmNyZWF0ZVRleHR1cmVMYXlvdXRGcm9tVGV4dHVyZVR5cGU9dm9pZCAwO2NvbnN0IHI9bigyNTE3KSxpPW4oMjAzOSk7ZS5jcmVhdGVUZXh0dXJlTGF5b3V0RnJvbVRleHR1cmVUeXBlPSh0LG4scik9Pntjb25zdCBvPXI9PT1pLlRleHR1cmVUeXBlLnVucGFja2VkfHxyPT09aS5UZXh0dXJlVHlwZS51bnBhY2tlZFJldmVyc2VkPzE6NCxhPXI9PT1pLlRleHR1cmVUeXBlLnBhY2tlZCxzPXI9PT1pLlRleHR1cmVUeXBlLnVucGFja2VkUmV2ZXJzZWR8fHI9PT1pLlRleHR1cmVUeXBlLnBhY2tlZCx1PXI9PT1pLlRleHR1cmVUeXBlLnBhY2tlZExhc3REaW1lbnNpb24/bi5sZW5ndGgtMTp2b2lkIDAsYz1yPT09aS5UZXh0dXJlVHlwZS5wYWNrZWRMYXN0RGltZW5zaW9uP24ubWFwKCgodCxlKT0+ZT09PW4ubGVuZ3RoLTE/NCp0OnQpKTp2b2lkIDA7cmV0dXJuKDAsZS5jcmVhdGVUZXh0dXJlTGF5b3V0RnJvbVNoYXBlKSh0LG4sbyxjLHtpc1BhY2tlZDphLHJldmVyc2VXSDpzLGJyZWFrQXhpczp1fSl9LGUuY2FsY3VsYXRlVGV4dHVyZVdpZHRoQW5kSGVpZ2h0PSh0LG4scik9Pntjb25zdCBpPSgwLGUuY3JlYXRlVGV4dHVyZUxheW91dEZyb21UZXh0dXJlVHlwZSkodCxuLHIpO3JldHVybltpLndpZHRoLGkuaGVpZ2h0XX0sZS5jcmVhdGVUZXh0dXJlTGF5b3V0RnJvbVNoYXBlPSh0LGUsbj0xLGksbyk9Pntjb25zdCBhPSEoIW98fCFvLmlzUGFja2VkKSxbcyx1XT10LmNvbXB1dGVUZXh0dXJlV0goYSYmaXx8ZSxvKSxjPWUubGVuZ3RoO2xldCBsPWUuc2xpY2UoMCk7aWYoMD09PWMmJihsPVsxXSksMT09PW4paT1lO2Vsc2UgaWYoYSl7aWYoNCE9PW4pdGhyb3cgbmV3IEVycm9yKFwiYSBwYWNrZWQgdGV4dHVyZSBtdXN0IGJlIDQtY2hhbm5lbFwiKTtpPWUsYz4wJiYobFtjLTFdPU1hdGguY2VpbChsW2MtMV0vMikpLGM+MSYmKGxbYy0yXT1NYXRoLmNlaWwobFtjLTJdLzIpKX1lbHNlIGlmKCFpKXRocm93IG5ldyBFcnJvcihcIlVucGFja2VkIHNoYXBlIGlzIG5lZWRlZCB3aGVuIHVzaW5nIGNoYW5uZWxzID4gMVwiKTtyZXR1cm57d2lkdGg6cyxoZWlnaHQ6dSxjaGFubmVsczpuLGlzUGFja2VkOmEsc2hhcGU6bCxzdHJpZGVzOnIuU2hhcGVVdGlsLmNvbXB1dGVTdHJpZGVzKGwpLHVucGFja2VkU2hhcGU6aSxyZXZlcnNlZFdIOm8mJm8ucmV2ZXJzZVdIfX19LDU3MDI6KHQsZSxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUuVGV4dHVyZU1hbmFnZXI9dm9pZCAwO2NvbnN0IHI9big2MjMxKTtlLlRleHR1cmVNYW5hZ2VyPWNsYXNze2NvbnN0cnVjdG9yKHQsZSxuLHIpe3RoaXMuZ2xDb250ZXh0PXQsdGhpcy5sYXlvdXRTdHJhdGVneT1lLHRoaXMucHJvZmlsZXI9bix0aGlzLmNvbmZpZz1yLHRoaXMucGVuZGluZ1JlYWQ9bmV3IE1hcCxyLnJldXNlVGV4dHVyZXMmJih0aGlzLmluVXNlVGV4dHVyZXM9bmV3IE1hcCx0aGlzLmlkbGVUZXh0dXJlcz1uZXcgTWFwLHRoaXMudGV4dHVyZUxvb2t1cD1uZXcgTWFwKX1jcmVhdGVUZXh0dXJlRnJvbUxheW91dCh0LGUsbixpKXtjb25zdCBvPXRoaXMudG9FbmNvZGVyVHlwZSh0KSxhPXRoaXMuZ2xDb250ZXh0LmdldEVuY29kZXIobyxlLmNoYW5uZWxzfHwxLGkpO2lmKGUuaXNQYWNrZWQmJjE9PT1pKXRocm93IG5ldyBFcnJvcihcIm5vdCBpbXBsZW1lbnRlZFwiKTtjb25zdCBzPWUud2lkdGgsdT1lLmhlaWdodDtsZXQgYyxsO2lmKHRoaXMuY29uZmlnLnJldXNlVGV4dHVyZXMpe2M9YCR7c314JHt1fV8ke2EuZm9ybWF0fV8ke2EuaW50ZXJuYWxGb3JtYXR9XyR7YS50ZXh0dXJlVHlwZX1gLGw9dGhpcy5pblVzZVRleHR1cmVzLmdldChjKSxsfHwobD1bXSx0aGlzLmluVXNlVGV4dHVyZXMuc2V0KGMsbCkpO2NvbnN0IGU9dGhpcy5pZGxlVGV4dHVyZXMuZ2V0KGMpO2lmKGUmJmUubGVuZ3RoPjApe2NvbnN0IHI9ZS5wb3AoKTtyZXR1cm4gbC5wdXNoKHIpLDE9PT1pJiZ0aGlzLmdsQ29udGV4dC51cGRhdGVUZXh0dXJlKHIscyx1LGEsdGhpcy50b1RleHR1cmVEYXRhKHQsbikpLHJ9fXIuTG9nZ2VyLnZlcmJvc2UoXCJUZXh0dXJlTWFuYWdlclwiLGBDcmVhdGluZyBuZXcgdGV4dHVyZSBvZiBzaXplICR7ZS53aWR0aH14JHtlLmhlaWdodH1gKTtjb25zdCBwPXRoaXMuZ2xDb250ZXh0LmFsbG9jYXRlVGV4dHVyZShzLHUsYSx0aGlzLnRvVGV4dHVyZURhdGEodCxuKSk7cmV0dXJuIHRoaXMuY29uZmlnLnJldXNlVGV4dHVyZXMmJihsLnB1c2gocCksdGhpcy50ZXh0dXJlTG9va3VwLnNldChwLGMpKSxwfXJlYWRUZXh0dXJlKHQsZSxuKXtyZXR1cm4gbnx8KG49MSksdGhpcy5wcm9maWxlci5ldmVudChcImJhY2tlbmRcIixcIlRleHR1cmVNYW5hZ2VyLnJlYWRUZXh0dXJlXCIsKCgpPT57Y29uc3Qgcj10LnNoYXBlLnJlZHVjZSgoKHQsZSk9PnQqZSkpKm4saT10aGlzLmdsQ29udGV4dC5yZWFkVGV4dHVyZSh0LnRleHR1cmUsdC53aWR0aCx0LmhlaWdodCxyLHRoaXMudG9FbmNvZGVyVHlwZShlKSxuKTtyZXR1cm4gdGhpcy50b1RlbnNvckRhdGEoZSxpKX0pKX1hc3luYyByZWFkVGV4dHVyZUFzeW5jKHQsZSxuKXtjb25zdCByPXQudGVuc29yLmRhdGFJZDtpZihufHwobj0xKSx0aGlzLnBlbmRpbmdSZWFkLmhhcyhyKSl7Y29uc3QgdD10aGlzLnBlbmRpbmdSZWFkLmdldChyKTtyZXR1cm4gbmV3IFByb21pc2UoKGU9Pm51bGw9PXQ/dm9pZCAwOnQucHVzaChlKSkpfXJldHVybiB0aGlzLnByb2ZpbGVyLmV2ZW50KFwiYmFja2VuZFwiLFwiVGV4dHVyZU1hbmFnZXIucmVhZFRleHR1cmVBc3luY1wiLChhc3luYygpPT57dGhpcy5wZW5kaW5nUmVhZC5zZXQocixbXSk7Y29uc3QgaT10LnNoYXBlLnJlZHVjZSgoKHQsZSk9PnQqZSkpKm47YXdhaXQgdGhpcy5nbENvbnRleHQuY3JlYXRlQW5kV2FpdEZvckZlbmNlKCk7Y29uc3Qgbz10aGlzLmdsQ29udGV4dC5yZWFkVGV4dHVyZSh0LnRleHR1cmUsdC53aWR0aCx0LmhlaWdodCxpLHRoaXMudG9FbmNvZGVyVHlwZShlKSxuKSxhPXRoaXMudG9UZW5zb3JEYXRhKGUsbykscz10aGlzLnBlbmRpbmdSZWFkLmdldChyKTtyZXR1cm4gdGhpcy5wZW5kaW5nUmVhZC5kZWxldGUociksbnVsbD09c3x8cy5mb3JFYWNoKCh0PT50KGEpKSksYX0pKX1yZWFkVWludDhUZXh0dXJlQXNGbG9hdCh0KXtyZXR1cm4gdGhpcy5wcm9maWxlci5ldmVudChcImJhY2tlbmRcIixcIlRleHR1cmVNYW5hZ2VyLnJlYWRVaW50OFRleHR1cmVBc0Zsb2F0XCIsKCgpPT57Y29uc3QgZT10LnNoYXBlLnJlZHVjZSgoKHQsZSk9PnQqZSkpLG49dGhpcy5nbENvbnRleHQucmVhZFRleHR1cmUodC50ZXh0dXJlLHQud2lkdGgsdC5oZWlnaHQsNCplLFwiYnl0ZVwiLDQpO3JldHVybiBuZXcgRmxvYXQzMkFycmF5KG4uYnVmZmVyLG4uYnl0ZU9mZnNldCxlKX0pKX1yZWxlYXNlVGV4dHVyZSh0LGUpe2xldCBuO2lmKHRoaXMuY29uZmlnLnJldXNlVGV4dHVyZXMmJihuPXRoaXMudGV4dHVyZUxvb2t1cC5nZXQodC50ZXh0dXJlKSxuKSl7ZSYmdGhpcy50ZXh0dXJlTG9va3VwLmRlbGV0ZShuKTtjb25zdCByPXRoaXMuaW5Vc2VUZXh0dXJlcy5nZXQobik7aWYocil7Y29uc3QgZT1yLmluZGV4T2YodC50ZXh0dXJlKTtpZigtMSE9PWUpe3Iuc3BsaWNlKGUsMSk7bGV0IGk9dGhpcy5pZGxlVGV4dHVyZXMuZ2V0KG4pO2l8fChpPVtdLHRoaXMuaWRsZVRleHR1cmVzLnNldChuLGkpKSxpLnB1c2godC50ZXh0dXJlKX19fW4mJiFlfHwoci5Mb2dnZXIudmVyYm9zZShcIlRleHR1cmVNYW5hZ2VyXCIsYERlbGV0aW5nIHRleHR1cmUgb2Ygc2l6ZSAke3Qud2lkdGh9eCR7dC5oZWlnaHR9YCksdGhpcy5nbENvbnRleHQuZGVsZXRlVGV4dHVyZSh0LnRleHR1cmUpKX10b1RlbnNvckRhdGEodCxlKXtzd2l0Y2godCl7Y2FzZVwiaW50MTZcIjpyZXR1cm4gZSBpbnN0YW5jZW9mIEludDE2QXJyYXk/ZTpJbnQxNkFycmF5LmZyb20oZSk7Y2FzZVwiaW50MzJcIjpyZXR1cm4gZSBpbnN0YW5jZW9mIEludDMyQXJyYXk/ZTpJbnQzMkFycmF5LmZyb20oZSk7Y2FzZVwiaW50OFwiOnJldHVybiBlIGluc3RhbmNlb2YgSW50OEFycmF5P2U6SW50OEFycmF5LmZyb20oZSk7Y2FzZVwidWludDE2XCI6cmV0dXJuIGUgaW5zdGFuY2VvZiBVaW50MTZBcnJheT9lOlVpbnQxNkFycmF5LmZyb20oZSk7Y2FzZVwidWludDMyXCI6cmV0dXJuIGUgaW5zdGFuY2VvZiBVaW50MzJBcnJheT9lOlVpbnQzMkFycmF5LmZyb20oZSk7Y2FzZVwidWludDhcIjpjYXNlXCJib29sXCI6cmV0dXJuIGUgaW5zdGFuY2VvZiBVaW50OEFycmF5P2U6VWludDhBcnJheS5mcm9tKGUpO2Nhc2VcImZsb2F0MzJcIjpyZXR1cm4gZSBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheT9lOkZsb2F0MzJBcnJheS5mcm9tKGUpO2Nhc2VcImZsb2F0NjRcIjpyZXR1cm4gZSBpbnN0YW5jZW9mIEZsb2F0NjRBcnJheT9lOkZsb2F0NjRBcnJheS5mcm9tKGUpO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBUZW5zb3JEYXRhIHR5cGUgJHt0fSBpcyBub3Qgc3VwcG9ydGVkYCl9fXRvVGV4dHVyZURhdGEodCxlKXtpZihlKXJldHVybiBlIGluc3RhbmNlb2YgRmxvYXQzMkFycmF5P2U6bmV3IEZsb2F0MzJBcnJheShlKX10b0VuY29kZXJUeXBlKHQpe3JldHVyblwiZmxvYXRcIn1jbGVhckFjdGl2ZVRleHR1cmVzKCl7dGhpcy5nbENvbnRleHQuY2xlYXJBY3RpdmVUZXh0dXJlcygpfX19LDIwMzk6KHQsZSk9PntcInVzZSBzdHJpY3RcIjt2YXIgbjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLlRleHR1cmVUeXBlPXZvaWQgMCwobj1lLlRleHR1cmVUeXBlfHwoZS5UZXh0dXJlVHlwZT17fSkpW24udW5wYWNrZWQ9MF09XCJ1bnBhY2tlZFwiLG5bbi51bnBhY2tlZFJldmVyc2VkPTFdPVwidW5wYWNrZWRSZXZlcnNlZFwiLG5bbi5wYWNrZWQ9Ml09XCJwYWNrZWRcIixuW24uZG93bmxvYWRVaW50OEFzRmxvYXQ9M109XCJkb3dubG9hZFVpbnQ4QXNGbG9hdFwiLG5bbi5wYWNrZWRMYXN0RGltZW5zaW9uPTRdPVwicGFja2VkTGFzdERpbWVuc2lvblwifSw5MzkwOih0LGUsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLmdldEdsQ2hhbm5lbHM9ZS5nZXRDb29yZHNEYXRhVHlwZT1lLmdldFNxdWVlemVkUGFyYW1zPWUuc3F1ZWV6ZUlucHV0U2hhcGU9ZS5nZW5lcmF0ZVNoYWRlckZ1bmNOYW1lRnJvbUlucHV0U2FtcGxlck5hbWVBdE91dENvb3Jkcz1lLmdlbmVyYXRlU2hhZGVyRnVuY05hbWVGcm9tSW5wdXRTYW1wbGVyTmFtZT1lLnJlcGVhdGVkVHJ5PWUuZ2V0UGFja2VkU2hhcGU9dm9pZCAwO2NvbnN0IHI9bigyNTE3KTtlLmdldFBhY2tlZFNoYXBlPWZ1bmN0aW9uKHQpe2NvbnN0IGU9dC5sZW5ndGg7cmV0dXJuIHQuc2xpY2UoMCxlLTEpLmNvbmNhdCh0W2UtMV0vNCl9LGUucmVwZWF0ZWRUcnk9YXN5bmMgZnVuY3Rpb24odCxlPSh0PT4wKSxuKXtyZXR1cm4gbmV3IFByb21pc2UoKChyLGkpPT57bGV0IG89MDtjb25zdCBhPSgpPT57aWYodCgpKXJldHVybiB2b2lkIHIoKTtvKys7Y29uc3Qgcz1lKG8pO251bGwhPW4mJm8+PW4/aSgpOnNldFRpbWVvdXQoYSxzKX07YSgpfSkpfSxlLmdlbmVyYXRlU2hhZGVyRnVuY05hbWVGcm9tSW5wdXRTYW1wbGVyTmFtZT1mdW5jdGlvbih0KXtyZXR1cm4oMCxyLmFzc2VydCkodm9pZCAwIT09dCYmMCE9PXQubGVuZ3RoLCgoKT0+XCJlbXB0eSBzdHJpbmcgZm91bmQgZm9yIHNhbXBsZXIgbmFtZVwiKSksXCJnZXRcIit0LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpK3Quc2xpY2UoMSl9LGUuZ2VuZXJhdGVTaGFkZXJGdW5jTmFtZUZyb21JbnB1dFNhbXBsZXJOYW1lQXRPdXRDb29yZHM9ZnVuY3Rpb24odCl7cmV0dXJuKDAsci5hc3NlcnQpKHZvaWQgMCE9PXQmJjAhPT10Lmxlbmd0aCwoKCk9PlwiZW1wdHkgc3RyaW5nIGZvdW5kIGZvciBzYW1wbGVyIG5hbWVcIikpLFwiZ2V0XCIrdC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSt0LnNsaWNlKDEpK1wiQXRPdXRDb29yZHNcIn0sZS5zcXVlZXplSW5wdXRTaGFwZT1mdW5jdGlvbih0LGUpe2xldCBuPUpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkodCkpO3JldHVybiBuPWUsbn0sZS5nZXRTcXVlZXplZFBhcmFtcz1mdW5jdGlvbih0LGUpe3JldHVybiBlLm1hcCgoZT0+dFtlXSkpLmpvaW4oXCIsIFwiKX0sZS5nZXRDb29yZHNEYXRhVHlwZT1mdW5jdGlvbih0KXtpZih0PD0xKXJldHVyblwiaW50XCI7aWYoMj09PXQpcmV0dXJuXCJpdmVjMlwiO2lmKDM9PT10KXJldHVyblwiaXZlYzNcIjtpZig0PT09dClyZXR1cm5cIml2ZWM0XCI7aWYoNT09PXQpcmV0dXJuXCJpdmVjNVwiO2lmKDY9PT10KXJldHVyblwiaXZlYzZcIjt0aHJvdyBFcnJvcihgR1BVIGZvciByYW5rICR7dH0gaXMgbm90IHlldCBzdXBwb3J0ZWRgKX0sZS5nZXRHbENoYW5uZWxzPWZ1bmN0aW9uKHQ9Nil7cmV0dXJuW1wieFwiLFwieVwiLFwielwiLFwid1wiLFwidVwiLFwidlwiXS5zbGljZSgwLHQpfX0sNzMwNToodCxlLG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5jcmVhdGVOZXdXZWJHTENvbnRleHQ9ZS5jcmVhdGVXZWJHTENvbnRleHQ9dm9pZCAwO2NvbnN0IHI9big2MjMxKSxpPW4oMTcxMyksbz17fTtmdW5jdGlvbiBhKHQpe2NvbnN0IGU9ZnVuY3Rpb24oKXtpZihcInVuZGVmaW5lZFwiPT10eXBlb2YgZG9jdW1lbnQpe2lmKFwidW5kZWZpbmVkXCI9PXR5cGVvZiBPZmZzY3JlZW5DYW52YXMpdGhyb3cgbmV3IFR5cGVFcnJvcihcImZhaWxlZCB0byBjcmVhdGUgY2FudmFzOiBPZmZzY3JlZW5DYW52YXMgaXMgbm90IHN1cHBvcnRlZFwiKTtyZXR1cm4gbmV3IE9mZnNjcmVlbkNhbnZhcygxLDEpfWNvbnN0IHQ9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtyZXR1cm4gdC53aWR0aD0xLHQuaGVpZ2h0PTEsdH0oKTtsZXQgbjtjb25zdCBvPXthbHBoYTohMSxkZXB0aDohMSxhbnRpYWxpYXM6ITEsc3RlbmNpbDohMSxwcmVzZXJ2ZURyYXdpbmdCdWZmZXI6ITEscHJlbXVsdGlwbGllZEFscGhhOiExLGZhaWxJZk1ham9yUGVyZm9ybWFuY2VDYXZlYXQ6ITF9O2lmKCghdHx8XCJ3ZWJnbDJcIj09PXQpJiYobj1lLmdldENvbnRleHQoXCJ3ZWJnbDJcIixvKSxuKSl0cnl7cmV0dXJuIG5ldyBpLldlYkdMQ29udGV4dChuLDIpfWNhdGNoKHQpe3IuTG9nZ2VyLndhcm5pbmcoXCJHbENvbnRleHRGYWN0b3J5XCIsYGZhaWxlZCB0byBjcmVhdGUgV2ViR0xDb250ZXh0IHVzaW5nIGNvbnRleHRJZCAnd2ViZ2wyJy4gRXJyb3I6ICR7dH1gKX1pZigoIXR8fFwid2ViZ2xcIj09PXQpJiYobj1lLmdldENvbnRleHQoXCJ3ZWJnbFwiLG8pfHxlLmdldENvbnRleHQoXCJleHBlcmltZW50YWwtd2ViZ2xcIixvKSxuKSl0cnl7cmV0dXJuIG5ldyBpLldlYkdMQ29udGV4dChuLDEpfWNhdGNoKHQpe3IuTG9nZ2VyLndhcm5pbmcoXCJHbENvbnRleHRGYWN0b3J5XCIsYGZhaWxlZCB0byBjcmVhdGUgV2ViR0xDb250ZXh0IHVzaW5nIGNvbnRleHRJZCAnd2ViZ2wnIG9yICdleHBlcmltZW50YWwtd2ViZ2wnLiBFcnJvcjogJHt0fWApfXRocm93IG5ldyBFcnJvcihcIldlYkdMIGlzIG5vdCBzdXBwb3J0ZWRcIil9ZS5jcmVhdGVXZWJHTENvbnRleHQ9ZnVuY3Rpb24gdChlKXtsZXQgbjtlJiZcIndlYmdsMlwiIT09ZXx8IShcIndlYmdsMlwiaW4gbyk/ZSYmXCJ3ZWJnbFwiIT09ZXx8IShcIndlYmdsXCJpbiBvKXx8KG49by53ZWJnbCk6bj1vLndlYmdsMixuPW58fGEoZSksZT1lfHwxPT09bi52ZXJzaW9uP1wid2ViZ2xcIjpcIndlYmdsMlwiO2NvbnN0IHI9bi5nbDtyZXR1cm4gb1tlXT1uLHIuaXNDb250ZXh0TG9zdCgpPyhkZWxldGUgb1tlXSx0KGUpKTooci5kaXNhYmxlKHIuREVQVEhfVEVTVCksci5kaXNhYmxlKHIuU1RFTkNJTF9URVNUKSxyLmRpc2FibGUoci5CTEVORCksci5kaXNhYmxlKHIuRElUSEVSKSxyLmRpc2FibGUoci5QT0xZR09OX09GRlNFVF9GSUxMKSxyLmRpc2FibGUoci5TQU1QTEVfQ09WRVJBR0UpLHIuZW5hYmxlKHIuU0NJU1NPUl9URVNUKSxyLmVuYWJsZShyLkNVTExfRkFDRSksci5jdWxsRmFjZShyLkJBQ0spLG4pfSxlLmNyZWF0ZU5ld1dlYkdMQ29udGV4dD1hfSwxNzEzOmZ1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjt2YXIgcj10aGlzJiZ0aGlzLl9fY3JlYXRlQmluZGluZ3x8KE9iamVjdC5jcmVhdGU/ZnVuY3Rpb24odCxlLG4scil7dm9pZCAwPT09ciYmKHI9bik7dmFyIGk9T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLG4pO2kmJiEoXCJnZXRcImluIGk/IWUuX19lc01vZHVsZTppLndyaXRhYmxlfHxpLmNvbmZpZ3VyYWJsZSl8fChpPXtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBlW25dfX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LHIsaSl9OmZ1bmN0aW9uKHQsZSxuLHIpe3ZvaWQgMD09PXImJihyPW4pLHRbcl09ZVtuXX0pLGk9dGhpcyYmdGhpcy5fX3NldE1vZHVsZURlZmF1bHR8fChPYmplY3QuY3JlYXRlP2Z1bmN0aW9uKHQsZSl7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJkZWZhdWx0XCIse2VudW1lcmFibGU6ITAsdmFsdWU6ZX0pfTpmdW5jdGlvbih0LGUpe3QuZGVmYXVsdD1lfSksbz10aGlzJiZ0aGlzLl9faW1wb3J0U3Rhcnx8ZnVuY3Rpb24odCl7aWYodCYmdC5fX2VzTW9kdWxlKXJldHVybiB0O3ZhciBlPXt9O2lmKG51bGwhPXQpZm9yKHZhciBuIGluIHQpXCJkZWZhdWx0XCIhPT1uJiZPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCxuKSYmcihlLHQsbik7cmV0dXJuIGkoZSx0KSxlfTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLldlYkdMQ29udGV4dD1lLmxpbmVhclNlYXJjaExhc3RUcnVlPXZvaWQgMDtjb25zdCBhPW4oMTY3MCkscz1vKG4oNzc2OSkpLHU9big5MzkwKTtmdW5jdGlvbiBjKHQpe2xldCBlPTA7Zm9yKDtlPHQubGVuZ3RoJiZ0W2VdKCk7KytlKTtyZXR1cm4gZS0xfWUubGluZWFyU2VhcmNoTGFzdFRydWU9YyxlLldlYkdMQ29udGV4dD1jbGFzc3tjb25zdHJ1Y3Rvcih0LGUpe3RoaXMuZnJhbWVCdWZmZXJCb3VuZD0hMSx0aGlzLml0ZW1zVG9Qb2xsPVtdLHRoaXMuZ2w9dCx0aGlzLnZlcnNpb249ZSx0aGlzLmdldEV4dGVuc2lvbnMoKSx0aGlzLnZlcnRleGJ1ZmZlcj10aGlzLmNyZWF0ZVZlcnRleGJ1ZmZlcigpLHRoaXMuZnJhbWVidWZmZXI9dGhpcy5jcmVhdGVGcmFtZWJ1ZmZlcigpLHRoaXMucXVlcnlWaXRhbFBhcmFtZXRlcnMoKX1hbGxvY2F0ZVRleHR1cmUodCxlLG4scil7Y29uc3QgaT10aGlzLmdsLG89aS5jcmVhdGVUZXh0dXJlKCk7aS5iaW5kVGV4dHVyZShpLlRFWFRVUkVfMkQsbyksaS50ZXhQYXJhbWV0ZXJpKGkuVEVYVFVSRV8yRCxpLlRFWFRVUkVfTUlOX0ZJTFRFUixpLk5FQVJFU1QpLGkudGV4UGFyYW1ldGVyaShpLlRFWFRVUkVfMkQsaS5URVhUVVJFX01BR19GSUxURVIsaS5ORUFSRVNUKSxpLnRleFBhcmFtZXRlcmkoaS5URVhUVVJFXzJELGkuVEVYVFVSRV9XUkFQX1MsaS5DTEFNUF9UT19FREdFKSxpLnRleFBhcmFtZXRlcmkoaS5URVhUVVJFXzJELGkuVEVYVFVSRV9XUkFQX1QsaS5DTEFNUF9UT19FREdFKTtjb25zdCBhPXI/bi5lbmNvZGUocix0KmUpOm51bGw7cmV0dXJuIGkudGV4SW1hZ2UyRChpLlRFWFRVUkVfMkQsMCxuLmludGVybmFsRm9ybWF0LHQsZSwwLG4uZm9ybWF0LG4udGV4dHVyZVR5cGUsYSksdGhpcy5jaGVja0Vycm9yKCksb311cGRhdGVUZXh0dXJlKHQsZSxuLHIsaSl7Y29uc3Qgbz10aGlzLmdsO28uYmluZFRleHR1cmUoby5URVhUVVJFXzJELHQpO2NvbnN0IGE9ci5lbmNvZGUoaSxlKm4pO28udGV4U3ViSW1hZ2UyRChvLlRFWFRVUkVfMkQsMCwwLDAsZSxuLHIuZm9ybWF0LHIudGV4dHVyZVR5cGUsYSksdGhpcy5jaGVja0Vycm9yKCl9YXR0YWNoRnJhbWVidWZmZXIodCxlLG4pe2NvbnN0IHI9dGhpcy5nbDtyLmJpbmRUZXh0dXJlKHIuVEVYVFVSRV8yRCx0KSxyLmJpbmRGcmFtZWJ1ZmZlcihyLkZSQU1FQlVGRkVSLHRoaXMuZnJhbWVidWZmZXIpLHIuZnJhbWVidWZmZXJUZXh0dXJlMkQoci5GUkFNRUJVRkZFUixyLkNPTE9SX0FUVEFDSE1FTlQwLHIuVEVYVFVSRV8yRCx0LDApLHRoaXMuY2hlY2tFcnJvcigpLHIudmlld3BvcnQoMCwwLGUsbiksci5zY2lzc29yKDAsMCxlLG4pfXJlYWRUZXh0dXJlKHQsZSxuLHIsaSxvKXtjb25zdCBhPXRoaXMuZ2w7b3x8KG89MSksdGhpcy5mcmFtZUJ1ZmZlckJvdW5kfHx0aGlzLmF0dGFjaEZyYW1lYnVmZmVyKHQsZSxuKTtjb25zdCBzPXRoaXMuZ2V0RW5jb2RlcihpLG8pLHU9cy5hbGxvY2F0ZShlKm4pO3JldHVybiBhLmJpbmRUZXh0dXJlKGEuVEVYVFVSRV8yRCx0KSxhLmZyYW1lYnVmZmVyVGV4dHVyZTJEKGEuRlJBTUVCVUZGRVIsYS5DT0xPUl9BVFRBQ0hNRU5UMCxhLlRFWFRVUkVfMkQsdCwwKSxhLnJlYWRQaXhlbHMoMCwwLGUsbixhLlJHQkEscy50ZXh0dXJlVHlwZSx1KSx0aGlzLmNoZWNrRXJyb3IoKSxzLmRlY29kZSh1LHIpfWlzRnJhbWVidWZmZXJSZWFkeSgpe3JldHVybiEwfWdldEFjdGl2ZVRleHR1cmUoKXtjb25zdCB0PXRoaXMuZ2w7cmV0dXJuXCJURVhUVVJFXCIrKHQuZ2V0UGFyYW1ldGVyKHRoaXMuZ2wuQUNUSVZFX1RFWFRVUkUpLXQuVEVYVFVSRTApfWdldFRleHR1cmVCaW5kaW5nKCl7cmV0dXJuIHRoaXMuZ2wuZ2V0UGFyYW1ldGVyKHRoaXMuZ2wuVEVYVFVSRV9CSU5ESU5HXzJEKX1nZXRGcmFtZWJ1ZmZlckJpbmRpbmcoKXtyZXR1cm4gdGhpcy5nbC5nZXRQYXJhbWV0ZXIodGhpcy5nbC5GUkFNRUJVRkZFUl9CSU5ESU5HKX1zZXRWZXJ0ZXhBdHRyaWJ1dGVzKHQsZSl7Y29uc3Qgbj10aGlzLmdsO24udmVydGV4QXR0cmliUG9pbnRlcih0LDMsbi5GTE9BVCwhMSwyMCwwKSxuLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHQpLC0xIT09ZSYmKG4udmVydGV4QXR0cmliUG9pbnRlcihlLDIsbi5GTE9BVCwhMSwyMCwxMiksbi5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShlKSksdGhpcy5jaGVja0Vycm9yKCl9Y3JlYXRlUHJvZ3JhbSh0LGUpe2NvbnN0IG49dGhpcy5nbCxyPW4uY3JlYXRlUHJvZ3JhbSgpO3JldHVybiBuLmF0dGFjaFNoYWRlcihyLHQpLG4uYXR0YWNoU2hhZGVyKHIsZSksbi5saW5rUHJvZ3JhbShyKSxyfWNvbXBpbGVTaGFkZXIodCxlKXtjb25zdCBuPXRoaXMuZ2wscj1uLmNyZWF0ZVNoYWRlcihlKTtpZighcil0aHJvdyBuZXcgRXJyb3IoYGNyZWF0ZVNoYWRlcigpIHJldHVybmVkIG51bGwgd2l0aCB0eXBlICR7ZX1gKTtpZihuLnNoYWRlclNvdXJjZShyLHQpLG4uY29tcGlsZVNoYWRlcihyKSwhMT09PW4uZ2V0U2hhZGVyUGFyYW1ldGVyKHIsbi5DT01QSUxFX1NUQVRVUykpdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gY29tcGlsZSBzaGFkZXI6ICR7bi5nZXRTaGFkZXJJbmZvTG9nKHIpfVxcblNoYWRlciBzb3VyY2U6XFxuJHt0fWApO3JldHVybiByfWRlbGV0ZVNoYWRlcih0KXt0aGlzLmdsLmRlbGV0ZVNoYWRlcih0KX1iaW5kVGV4dHVyZVRvVW5pZm9ybSh0LGUsbil7Y29uc3Qgcj10aGlzLmdsO3IuYWN0aXZlVGV4dHVyZShyLlRFWFRVUkUwK2UpLHRoaXMuY2hlY2tFcnJvcigpLHIuYmluZFRleHR1cmUoci5URVhUVVJFXzJELHQpLHRoaXMuY2hlY2tFcnJvcigpLHIudW5pZm9ybTFpKG4sZSksdGhpcy5jaGVja0Vycm9yKCl9ZHJhdygpe3RoaXMuZ2wuZHJhd0FycmF5cyh0aGlzLmdsLlRSSUFOR0xFX1NUUklQLDAsNCksdGhpcy5jaGVja0Vycm9yKCl9Y2hlY2tFcnJvcigpe2lmKGEuZW52LmRlYnVnKXtjb25zdCB0PXRoaXMuZ2wsZT10LmdldEVycm9yKCk7bGV0IG49XCJcIjtzd2l0Y2goZSl7Y2FzZSB0Lk5PX0VSUk9SOnJldHVybjtjYXNlIHQuSU5WQUxJRF9FTlVNOm49XCJJTlZBTElEX0VOVU1cIjticmVhaztjYXNlIHQuSU5WQUxJRF9WQUxVRTpuPVwiSU5WQUxJRF9WQUxVRVwiO2JyZWFrO2Nhc2UgdC5JTlZBTElEX09QRVJBVElPTjpuPVwiSU5WQUxJRF9PUEVSQVRJT05cIjticmVhaztjYXNlIHQuSU5WQUxJRF9GUkFNRUJVRkZFUl9PUEVSQVRJT046bj1cIklOVkFMSURfRlJBTUVCVUZGRVJfT1BFUkFUSU9OXCI7YnJlYWs7Y2FzZSB0Lk9VVF9PRl9NRU1PUlk6bj1cIk9VVF9PRl9NRU1PUllcIjticmVhaztjYXNlIHQuQ09OVEVYVF9MT1NUX1dFQkdMOm49XCJDT05URVhUX0xPU1RfV0VCR0xcIjticmVhaztkZWZhdWx0Om49YFVua25vd24gV2ViR0wgRXJyb3I6ICR7ZS50b1N0cmluZygxNil9YH10aHJvdyBuZXcgRXJyb3Iobil9fWRlbGV0ZVRleHR1cmUodCl7dGhpcy5nbC5kZWxldGVUZXh0dXJlKHQpfWRlbGV0ZVByb2dyYW0odCl7dGhpcy5nbC5kZWxldGVQcm9ncmFtKHQpfWdldEVuY29kZXIodCxlLG49MCl7aWYoMj09PXRoaXMudmVyc2lvbilyZXR1cm4gbmV3IHMuUmVkRmxvYXQzMkRhdGFFbmNvZGVyKHRoaXMuZ2wsZSk7c3dpdGNoKHQpe2Nhc2VcImZsb2F0XCI6cmV0dXJuIDE9PT1ufHx0aGlzLmlzUmVuZGVyRmxvYXQzMlN1cHBvcnRlZD9uZXcgcy5SR0JBRmxvYXREYXRhRW5jb2Rlcih0aGlzLmdsLGUpOm5ldyBzLlJHQkFGbG9hdERhdGFFbmNvZGVyKHRoaXMuZ2wsZSx0aGlzLnRleHR1cmVIYWxmRmxvYXRFeHRlbnNpb24uSEFMRl9GTE9BVF9PRVMpO2Nhc2VcImludFwiOnRocm93IG5ldyBFcnJvcihcIm5vdCBpbXBsZW1lbnRlZFwiKTtjYXNlXCJieXRlXCI6cmV0dXJuIG5ldyBzLlVpbnQ4RGF0YUVuY29kZXIodGhpcy5nbCxlKTtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgSW52YWxpZCBkYXRhVHlwZTogJHt0fWApfX1jbGVhckFjdGl2ZVRleHR1cmVzKCl7Y29uc3QgdD10aGlzLmdsO2ZvcihsZXQgZT0wO2U8dGhpcy5tYXhUZXh0dXJlSW1hZ2VVbml0czsrK2UpdC5hY3RpdmVUZXh0dXJlKHQuVEVYVFVSRTArZSksdC5iaW5kVGV4dHVyZSh0LlRFWFRVUkVfMkQsbnVsbCl9ZGlzcG9zZSgpe2lmKHRoaXMuZGlzcG9zZWQpcmV0dXJuO2NvbnN0IHQ9dGhpcy5nbDt0LmJpbmRGcmFtZWJ1ZmZlcih0LkZSQU1FQlVGRkVSLG51bGwpLHQuZGVsZXRlRnJhbWVidWZmZXIodGhpcy5mcmFtZWJ1ZmZlciksdC5iaW5kQnVmZmVyKHQuQVJSQVlfQlVGRkVSLG51bGwpLHQuZGVsZXRlQnVmZmVyKHRoaXMudmVydGV4YnVmZmVyKSx0LmJpbmRCdWZmZXIodC5FTEVNRU5UX0FSUkFZX0JVRkZFUixudWxsKSx0LmZpbmlzaCgpLHRoaXMuZGlzcG9zZWQ9ITB9Y3JlYXRlRGVmYXVsdEdlb21ldHJ5KCl7cmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkoWy0xLDEsMCwwLDEsLTEsLTEsMCwwLDAsMSwxLDAsMSwxLDEsLTEsMCwxLDBdKX1jcmVhdGVWZXJ0ZXhidWZmZXIoKXtjb25zdCB0PXRoaXMuZ2wsZT10LmNyZWF0ZUJ1ZmZlcigpO2lmKCFlKXRocm93IG5ldyBFcnJvcihcImNyZWF0ZUJ1ZmZlcigpIHJldHVybmVkIG51bGxcIik7Y29uc3Qgbj10aGlzLmNyZWF0ZURlZmF1bHRHZW9tZXRyeSgpO3JldHVybiB0LmJpbmRCdWZmZXIodC5BUlJBWV9CVUZGRVIsZSksdC5idWZmZXJEYXRhKHQuQVJSQVlfQlVGRkVSLG4sdC5TVEFUSUNfRFJBVyksdGhpcy5jaGVja0Vycm9yKCksZX1jcmVhdGVGcmFtZWJ1ZmZlcigpe2NvbnN0IHQ9dGhpcy5nbC5jcmVhdGVGcmFtZWJ1ZmZlcigpO2lmKCF0KXRocm93IG5ldyBFcnJvcihcImNyZWF0ZUZyYW1lYnVmZmVyIHJldHVybmVkIG51bGxcIik7cmV0dXJuIHR9cXVlcnlWaXRhbFBhcmFtZXRlcnMoKXtjb25zdCB0PXRoaXMuZ2w7aWYodGhpcy5pc0Zsb2F0VGV4dHVyZUF0dGFjaGFibGVUb0ZyYW1lQnVmZmVyPXRoaXMuY2hlY2tGbG9hdFRleHR1cmVBdHRhY2hhYmxlVG9GcmFtZUJ1ZmZlcigpLHRoaXMuaXNSZW5kZXJGbG9hdDMyU3VwcG9ydGVkPXRoaXMuY2hlY2tSZW5kZXJGbG9hdDMyKCksdGhpcy5pc0Zsb2F0MzJEb3dubG9hZFN1cHBvcnRlZD10aGlzLmNoZWNrRmxvYXQzMkRvd25sb2FkKCksMT09PXRoaXMudmVyc2lvbiYmIXRoaXMudGV4dHVyZUhhbGZGbG9hdEV4dGVuc2lvbiYmIXRoaXMuaXNSZW5kZXJGbG9hdDMyU3VwcG9ydGVkKXRocm93IG5ldyBFcnJvcihcImJvdGggZmxvYXQzMiBhbmQgZmxvYXQxNiBUZXh0dXJlVHlwZSBhcmUgbm90IHN1cHBvcnRlZFwiKTt0aGlzLmlzQmxlbmRTdXBwb3J0ZWQ9IXRoaXMuaXNSZW5kZXJGbG9hdDMyU3VwcG9ydGVkfHx0aGlzLmNoZWNrRmxvYXQzMkJsZW5kKCksdGhpcy5tYXhUZXh0dXJlU2l6ZT10LmdldFBhcmFtZXRlcih0Lk1BWF9URVhUVVJFX1NJWkUpLHRoaXMubWF4VGV4dHVyZUltYWdlVW5pdHM9dC5nZXRQYXJhbWV0ZXIodC5NQVhfVEVYVFVSRV9JTUFHRV9VTklUUyksdGhpcy52ZXJzaW9ufWdldEV4dGVuc2lvbnMoKXsyPT09dGhpcy52ZXJzaW9uPyh0aGlzLmNvbG9yQnVmZmVyRmxvYXRFeHRlbnNpb249dGhpcy5nbC5nZXRFeHRlbnNpb24oXCJFWFRfY29sb3JfYnVmZmVyX2Zsb2F0XCIpLHRoaXMuZGlzam9pbnRUaW1lclF1ZXJ5V2ViZ2wyRXh0ZW5zaW9uPXRoaXMuZ2wuZ2V0RXh0ZW5zaW9uKFwiRVhUX2Rpc2pvaW50X3RpbWVyX3F1ZXJ5X3dlYmdsMlwiKSk6KHRoaXMudGV4dHVyZUZsb2F0RXh0ZW5zaW9uPXRoaXMuZ2wuZ2V0RXh0ZW5zaW9uKFwiT0VTX3RleHR1cmVfZmxvYXRcIiksdGhpcy50ZXh0dXJlSGFsZkZsb2F0RXh0ZW5zaW9uPXRoaXMuZ2wuZ2V0RXh0ZW5zaW9uKFwiT0VTX3RleHR1cmVfaGFsZl9mbG9hdFwiKSl9Y2hlY2tGbG9hdFRleHR1cmVBdHRhY2hhYmxlVG9GcmFtZUJ1ZmZlcigpe2NvbnN0IHQ9dGhpcy5nbCxlPXQuY3JlYXRlVGV4dHVyZSgpO3QuYmluZFRleHR1cmUodC5URVhUVVJFXzJELGUpO2NvbnN0IG49Mj09PXRoaXMudmVyc2lvbj90LlJHQkEzMkY6dC5SR0JBO3QudGV4SW1hZ2UyRCh0LlRFWFRVUkVfMkQsMCxuLDEsMSwwLHQuUkdCQSx0LkZMT0FULG51bGwpO2NvbnN0IHI9dC5jcmVhdGVGcmFtZWJ1ZmZlcigpO3QuYmluZEZyYW1lYnVmZmVyKHQuRlJBTUVCVUZGRVIsciksdC5mcmFtZWJ1ZmZlclRleHR1cmUyRCh0LkZSQU1FQlVGRkVSLHQuQ09MT1JfQVRUQUNITUVOVDAsdC5URVhUVVJFXzJELGUsMCk7Y29uc3QgaT10LmNoZWNrRnJhbWVidWZmZXJTdGF0dXModC5GUkFNRUJVRkZFUik9PT10LkZSQU1FQlVGRkVSX0NPTVBMRVRFO3JldHVybiB0LmJpbmRUZXh0dXJlKHQuVEVYVFVSRV8yRCxudWxsKSx0LmJpbmRGcmFtZWJ1ZmZlcih0LkZSQU1FQlVGRkVSLG51bGwpLHQuZGVsZXRlVGV4dHVyZShlKSx0LmRlbGV0ZUZyYW1lYnVmZmVyKHIpLGl9Y2hlY2tSZW5kZXJGbG9hdDMyKCl7aWYoMj09PXRoaXMudmVyc2lvbil7aWYoIXRoaXMuY29sb3JCdWZmZXJGbG9hdEV4dGVuc2lvbilyZXR1cm4hMX1lbHNlIGlmKCF0aGlzLnRleHR1cmVGbG9hdEV4dGVuc2lvbilyZXR1cm4hMTtyZXR1cm4gdGhpcy5pc0Zsb2F0VGV4dHVyZUF0dGFjaGFibGVUb0ZyYW1lQnVmZmVyfWNoZWNrRmxvYXQzMkRvd25sb2FkKCl7aWYoMj09PXRoaXMudmVyc2lvbil7aWYoIXRoaXMuY29sb3JCdWZmZXJGbG9hdEV4dGVuc2lvbilyZXR1cm4hMX1lbHNle2lmKCF0aGlzLnRleHR1cmVGbG9hdEV4dGVuc2lvbilyZXR1cm4hMTtpZighdGhpcy5nbC5nZXRFeHRlbnNpb24oXCJXRUJHTF9jb2xvcl9idWZmZXJfZmxvYXRcIikpcmV0dXJuITF9cmV0dXJuIHRoaXMuaXNGbG9hdFRleHR1cmVBdHRhY2hhYmxlVG9GcmFtZUJ1ZmZlcn1jaGVja0Zsb2F0MzJCbGVuZCgpe2NvbnN0IHQ9dGhpcy5nbDtsZXQgZSxuLHIsaSxvO3RyeXtlPXQuY3JlYXRlVGV4dHVyZSgpLG49dC5jcmVhdGVGcmFtZWJ1ZmZlcigpLHQuYmluZFRleHR1cmUodC5URVhUVVJFXzJELGUpO2NvbnN0IGE9Mj09PXRoaXMudmVyc2lvbj90LlJHQkEzMkY6dC5SR0JBO3JldHVybiB0LnRleEltYWdlMkQodC5URVhUVVJFXzJELDAsYSwxLDEsMCx0LlJHQkEsdC5GTE9BVCxudWxsKSx0LmJpbmRGcmFtZWJ1ZmZlcih0LkZSQU1FQlVGRkVSLG4pLHQuZnJhbWVidWZmZXJUZXh0dXJlMkQodC5GUkFNRUJVRkZFUix0LkNPTE9SX0FUVEFDSE1FTlQwLHQuVEVYVFVSRV8yRCxlLDApLHQuZW5hYmxlKHQuQkxFTkQpLHI9dC5jcmVhdGVTaGFkZXIodC5WRVJURVhfU0hBREVSKSwhIXImJih0LnNoYWRlclNvdXJjZShyLFwidm9pZCBtYWluKCl7fVwiKSx0LmNvbXBpbGVTaGFkZXIociksaT10LmNyZWF0ZVNoYWRlcih0LkZSQUdNRU5UX1NIQURFUiksISFpJiYodC5zaGFkZXJTb3VyY2UoaSxcInByZWNpc2lvbiBoaWdocCBmbG9hdDt2b2lkIG1haW4oKXtnbF9GcmFnQ29sb3I9dmVjNCgwLjUpO31cIiksdC5jb21waWxlU2hhZGVyKGkpLG89dC5jcmVhdGVQcm9ncmFtKCksISFvJiYodC5hdHRhY2hTaGFkZXIobyxyKSx0LmF0dGFjaFNoYWRlcihvLGkpLHQubGlua1Byb2dyYW0obyksdC51c2VQcm9ncmFtKG8pLHQuZHJhd0FycmF5cyh0LlBPSU5UUywwLDEpLHQuZ2V0RXJyb3IoKT09PXQuTk9fRVJST1IpKSl9ZmluYWxseXt0LmRpc2FibGUodC5CTEVORCksbyYmdC5kZWxldGVQcm9ncmFtKG8pLHImJnQuZGVsZXRlU2hhZGVyKHIpLGkmJnQuZGVsZXRlU2hhZGVyKGkpLG4mJih0LmJpbmRGcmFtZWJ1ZmZlcih0LkZSQU1FQlVGRkVSLG51bGwpLHQuZGVsZXRlRnJhbWVidWZmZXIobikpLGUmJih0LmJpbmRUZXh0dXJlKHQuVEVYVFVSRV8yRCxudWxsKSx0LmRlbGV0ZVRleHR1cmUoZSkpfX1iZWdpblRpbWVyKCl7aWYoMj09PXRoaXMudmVyc2lvbiYmdGhpcy5kaXNqb2ludFRpbWVyUXVlcnlXZWJnbDJFeHRlbnNpb24pe2NvbnN0IHQ9dGhpcy5nbCxlPXRoaXMuZGlzam9pbnRUaW1lclF1ZXJ5V2ViZ2wyRXh0ZW5zaW9uLG49dC5jcmVhdGVRdWVyeSgpO3JldHVybiB0LmJlZ2luUXVlcnkoZS5USU1FX0VMQVBTRURfRVhULG4pLG59dGhyb3cgbmV3IEVycm9yKFwiV2ViR0wxIHByb2ZpbGluZyBjdXJyZW50bHkgbm90IHN1cHBvcnRlZC5cIil9ZW5kVGltZXIoKXtpZigyIT09dGhpcy52ZXJzaW9ufHwhdGhpcy5kaXNqb2ludFRpbWVyUXVlcnlXZWJnbDJFeHRlbnNpb24pdGhyb3cgbmV3IEVycm9yKFwiV2ViR0wxIHByb2ZpbGluZyBjdXJyZW50bHkgbm90IHN1cHBvcnRlZFwiKTt7Y29uc3QgdD10aGlzLmdsLGU9dGhpcy5kaXNqb2ludFRpbWVyUXVlcnlXZWJnbDJFeHRlbnNpb247dC5lbmRRdWVyeShlLlRJTUVfRUxBUFNFRF9FWFQpfX1pc1RpbWVyUmVzdWx0QXZhaWxhYmxlKHQpe2xldCBlPSExLG49ITE7aWYoMiE9PXRoaXMudmVyc2lvbnx8IXRoaXMuZGlzam9pbnRUaW1lclF1ZXJ5V2ViZ2wyRXh0ZW5zaW9uKXRocm93IG5ldyBFcnJvcihcIldlYkdMMSBwcm9maWxpbmcgY3VycmVudGx5IG5vdCBzdXBwb3J0ZWRcIik7e2NvbnN0IHI9dGhpcy5nbCxpPXRoaXMuZGlzam9pbnRUaW1lclF1ZXJ5V2ViZ2wyRXh0ZW5zaW9uO2U9ci5nZXRRdWVyeVBhcmFtZXRlcih0LHIuUVVFUllfUkVTVUxUX0FWQUlMQUJMRSksbj1yLmdldFBhcmFtZXRlcihpLkdQVV9ESVNKT0lOVF9FWFQpfXJldHVybiBlJiYhbn1nZXRUaW1lclJlc3VsdCh0KXtsZXQgZT0wO2lmKDIhPT10aGlzLnZlcnNpb24pdGhyb3cgbmV3IEVycm9yKFwiV2ViR0wxIHByb2ZpbGluZyBjdXJyZW50bHkgbm90IHN1cHBvcnRlZFwiKTt7Y29uc3Qgbj10aGlzLmdsO2U9bi5nZXRRdWVyeVBhcmFtZXRlcih0LG4uUVVFUllfUkVTVUxUKSxuLmRlbGV0ZVF1ZXJ5KHQpfXJldHVybiBlLzFlNn1hc3luYyB3YWl0Rm9yUXVlcnlBbmRHZXRUaW1lKHQpe3JldHVybiBhd2FpdCgwLHUucmVwZWF0ZWRUcnkpKCgoKT0+dGhpcy5pc1RpbWVyUmVzdWx0QXZhaWxhYmxlKHQpKSksdGhpcy5nZXRUaW1lclJlc3VsdCh0KX1hc3luYyBjcmVhdGVBbmRXYWl0Rm9yRmVuY2UoKXtjb25zdCB0PXRoaXMuY3JlYXRlRmVuY2UodGhpcy5nbCk7cmV0dXJuIHRoaXMucG9sbEZlbmNlKHQpfWNyZWF0ZUZlbmNlKHQpe2xldCBlO2NvbnN0IG49dCxyPW4uZmVuY2VTeW5jKG4uU1lOQ19HUFVfQ09NTUFORFNfQ09NUExFVEUsMCk7cmV0dXJuIHQuZmx1c2goKSxlPW51bGw9PT1yPygpPT4hMDooKT0+e2NvbnN0IHQ9bi5jbGllbnRXYWl0U3luYyhyLDAsMCk7cmV0dXJuIHQ9PT1uLkFMUkVBRFlfU0lHTkFMRUR8fHQ9PT1uLkNPTkRJVElPTl9TQVRJU0ZJRUR9LHtxdWVyeTpyLGlzRmVuY2VQYXNzZWQ6ZX19YXN5bmMgcG9sbEZlbmNlKHQpe3JldHVybiBuZXcgUHJvbWlzZSgoZT0+e3RoaXMuYWRkSXRlbVRvUG9sbCgoKCk9PnQuaXNGZW5jZVBhc3NlZCgpKSwoKCk9PmUoKSkpfSkpfXBvbGxJdGVtcygpe2NvbnN0IHQ9Yyh0aGlzLml0ZW1zVG9Qb2xsLm1hcCgodD0+dC5pc0RvbmVGbikpKTtmb3IobGV0IGU9MDtlPD10OysrZSl7Y29uc3R7cmVzb2x2ZUZuOnR9PXRoaXMuaXRlbXNUb1BvbGxbZV07dCgpfXRoaXMuaXRlbXNUb1BvbGw9dGhpcy5pdGVtc1RvUG9sbC5zbGljZSh0KzEpfWFzeW5jIGFkZEl0ZW1Ub1BvbGwodCxlKXt0aGlzLml0ZW1zVG9Qb2xsLnB1c2goe2lzRG9uZUZuOnQscmVzb2x2ZUZuOmV9KSx0aGlzLml0ZW1zVG9Qb2xsLmxlbmd0aD4xfHxhd2FpdCgwLHUucmVwZWF0ZWRUcnkpKCgoKT0+KHRoaXMucG9sbEl0ZW1zKCksMD09PXRoaXMuaXRlbXNUb1BvbGwubGVuZ3RoKSkpfX19LDEwMzY6KHQsZSxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUuRXhlY3V0aW9uUGxhbj12b2lkIDA7Y29uc3Qgcj1uKDYyMzEpO2NsYXNzIGl7Y29uc3RydWN0b3IodCxlKXt0aGlzLm9wPXQsdGhpcy5ub2RlPWV9fWUuRXhlY3V0aW9uUGxhbj1jbGFzc3tjb25zdHJ1Y3Rvcih0LGUsbil7dGhpcy5ncmFwaD10LHRoaXMucHJvZmlsZXI9bix0aGlzLmluaXRpYWxpemUoZSl9aW5pdGlhbGl6ZSh0KXt0aGlzLnByb2ZpbGVyLmV2ZW50KFwic2Vzc2lvblwiLFwiRXhlY3V0aW9uUGxhbi5pbml0aWFsaXplXCIsKCgpPT57Y29uc3QgZT10aGlzLmdyYXBoLmdldE5vZGVzKCk7aWYoZS5sZW5ndGghPT10Lmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJUaGUgc2l6ZSBvZiBub2RlcyBhbmQgT1BzIGRvIG5vdCBtYXRjaC5cIik7dGhpcy5fb3BzPXQubWFwKCgodCxuKT0+bmV3IGkodCxlW25dKSkpLHRoaXMucmVzZXQoKSx0aGlzLl9zdGFydGVyPVtdLHRoaXMuX29wcy5mb3JFYWNoKCgodCxlKT0+e2xldCBuPSEwO2Zvcihjb25zdCBlIG9mIHQubm9kZS5pbnB1dHMpaWYoIXRoaXMuX3ZhbHVlc1tlXSYmLTE9PT10aGlzLmdyYXBoLmdldElucHV0SW5kaWNlcygpLmluZGV4T2YoZSkpe249ITE7YnJlYWt9biYmdGhpcy5fc3RhcnRlci5wdXNoKGUpfSkpfSkpfXJlc2V0KCl7dGhpcy5fdmFsdWVzPXRoaXMuZ3JhcGguZ2V0VmFsdWVzKCkubWFwKCh0PT50LnRlbnNvcikpfWFzeW5jIGV4ZWN1dGUodCxlKXtyZXR1cm4gdGhpcy5wcm9maWxlci5ldmVudChcInNlc3Npb25cIixcIkV4ZWN1dGlvblBsYW4uZXhlY3V0ZVwiLChhc3luYygpPT57dGhpcy5yZXNldCgpO2NvbnN0IG49dC5jcmVhdGVJbmZlcmVuY2VIYW5kbGVyKCksaT10aGlzLmdyYXBoLmdldElucHV0SW5kaWNlcygpO2lmKGUubGVuZ3RoIT09aS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKGBudW1iZXIgb2YgaW5wdXQgdGVuc29ycyBkb24ndCBtYXRjaCB0aGUgbnVtYmVyIG9mIGlucHV0cyB0byB0aGUgbW9kZWw6IGFjdHVhbDogJHtlLmxlbmd0aH0gZXhwZWN0ZWQ6ICR7aS5sZW5ndGh9YCk7ZS5mb3JFYWNoKCgodCxlKT0+e2NvbnN0IG49aVtlXTt0aGlzLl92YWx1ZXNbbl09dH0pKTtjb25zdCBvPXRoaXMuX3N0YXJ0ZXIuc2xpY2UoMCksYT10aGlzLmdyYXBoLmdldFZhbHVlcygpLHM9dGhpcy5ncmFwaC5nZXROb2RlcygpO2xldCB1PTA7Zm9yKDt1PG8ubGVuZ3RoOyl7Y29uc3QgdD1vW3UrK10sZT10aGlzLl9vcHNbdF0saT1lLm5vZGUuaW5wdXRzLm1hcCgodD0+dGhpcy5fdmFsdWVzW3RdKSk7aWYoLTEhPT1pLmluZGV4T2Yodm9pZCAwKSl0aHJvdyBuZXcgRXJyb3IoYHVucmVzb2x2ZWQgaW5wdXQgZGV0ZWN0ZWQ6IG9wOiAke2Uubm9kZX1gKTtjb25zdCBjPWk7ci5Mb2dnZXIudmVyYm9zZShcIkV4ZWNQbGFuXCIsYFJ1bmluZyBvcDoke2Uubm9kZS5uYW1lfSAoJHtjLm1hcCgoKHQsbik9PmAnJHtlLm5vZGUuaW5wdXRzW25dfSc6ICR7dC50eXBlfVske3QuZGltcy5qb2luKFwiLFwiKX1dYCkpLmpvaW4oXCIsIFwiKX0pYCk7Y29uc3QgbD1hd2FpdCB0aGlzLnByb2ZpbGVyLmV2ZW50KFwibm9kZVwiLGUubm9kZS5uYW1lLChhc3luYygpPT5lLm9wLmltcGwobixjLGUub3AuY29udGV4dCkpKTtpZihsLmxlbmd0aCE9PWUubm9kZS5vdXRwdXRzLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJ0aGUgc2l6ZSBvZiBvdXRwdXQgZG9lcyBub3QgbWF0Y2ggbW9kZWwgZGVmaW5pdGlvbi5cIik7bC5mb3JFYWNoKCgodCxuKT0+e2NvbnN0IHI9ZS5ub2RlLm91dHB1dHNbbl07aWYodGhpcy5fdmFsdWVzW3JdKXRocm93IG5ldyBFcnJvcihgb3V0cHV0IFske3J9XSBhbHJlYWR5IGhhcyB2YWx1ZTogb3A6JHtlLm5vZGUubmFtZX1gKTt0aGlzLl92YWx1ZXNbcl09dH0pKTtjb25zdCBwPW5ldyBTZXQ7bC5mb3JFYWNoKCgodCxuKT0+e2NvbnN0IHI9ZS5ub2RlLm91dHB1dHNbbl07Zm9yKGNvbnN0IHQgb2YgYVtyXS50byl7Y29uc3QgZT1zW3RdO2xldCBuPSEwO2Zvcihjb25zdCB0IG9mIGUuaW5wdXRzKWlmKCF0aGlzLl92YWx1ZXNbdF0pe249ITE7YnJlYWt9biYmcC5hZGQodCl9fSkpLG8ucHVzaCguLi5wKX1jb25zdCBjPVtdO2ZvcihsZXQgdD0wO3Q8dGhpcy5ncmFwaC5nZXRPdXRwdXRJbmRpY2VzKCkubGVuZ3RoO3QrKyl7Y29uc3QgZT10aGlzLmdyYXBoLmdldE91dHB1dEluZGljZXMoKVt0XSxuPXRoaXMuX3ZhbHVlc1tlXTtpZih2b2lkIDA9PT1uKXRocm93IG5ldyBFcnJvcihgcmVxdWlyZWQgb3V0cHV0IFske2V9XSBkb2VzIG5vdCBoYXZlIHZhbHVlYCk7MD09PWU/YXdhaXQgbi5nZXREYXRhKCk6bi5kYXRhLGMucHVzaChuKX1yZXR1cm4gci5Mb2dnZXIudmVyYm9zZShcIkV4ZWNQbGFuXCIsXCJkaXNwb3Npbmcgb2YgaW5mZXJlbmNlSGFuZGxlclwiKSxuLmRpc3Bvc2UoKSxjfSkpfX19LDcwNzA6KHQsZSxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUuR3JhcGg9dm9pZCAwO2NvbnN0IHI9bigxNDQ2KSxpPW4oNzc3OCksbz1uKDkzOTUpLGE9big5MTYyKSxzPW4oMjUxNyk7dmFyIHU9by5vbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzO2UuR3JhcGg9e2Zyb206KHQsZSk9Pm5ldyBwKHQsZSl9O2NsYXNzIGN7Y29uc3RydWN0b3IodCl7dGhpcy5fZnJvbT12b2lkIDAsdGhpcy5fdG89W10sdGhpcy50ZW5zb3I9dm9pZCAwLHRoaXMudHlwZT12b2lkIDAsdCYmKHRoaXMudHlwZT1zLlByb3RvVXRpbC50ZW5zb3JWYWx1ZVR5cGVGcm9tUHJvdG8odC50eXBlLnRlbnNvclR5cGUpKX1nZXQgZnJvbSgpe3JldHVybiB0aGlzLl9mcm9tfWdldCB0bygpe3JldHVybiB0aGlzLl90b319Y2xhc3MgbHtjb25zdHJ1Y3Rvcih0LGUpe3QgaW5zdGFuY2VvZiByLm9ubnguTm9kZVByb3RvPyh0aGlzLm5hbWU9dC5uYW1lLHRoaXMub3BUeXBlPXQub3BUeXBlLHRoaXMuYXR0cmlidXRlcz1uZXcgaS5BdHRyaWJ1dGUodC5hdHRyaWJ1dGUpKTp0IGluc3RhbmNlb2YgdS5Ob2RlJiYodGhpcy5uYW1lPW51bGwhPWU/ZTp0Lm5hbWUoKSx0aGlzLm9wVHlwZT10Lm9wVHlwZSgpLHRoaXMuYXR0cmlidXRlcz1uZXcgaS5BdHRyaWJ1dGUocy5Qcm90b1V0aWwudGVuc29yQXR0cmlidXRlc0Zyb21PUlRGb3JtYXQodCkpKSx0aGlzLmlucHV0cz1bXSx0aGlzLm91dHB1dHM9W10sdGhpcy5leGVjdXRlTm9kZT0hMH19Y2xhc3MgcHtjb25zdHJ1Y3Rvcih0LGUpe2lmKCF0KXRocm93IG5ldyBUeXBlRXJyb3IoXCJncmFwaCBpcyBlbXB0eVwiKTt0aGlzLmJ1aWxkR3JhcGgodCksdGhpcy50cmFuc2Zvcm1HcmFwaChlKSx0aGlzLmNoZWNrSXNBY3ljbGljKCl9Z2V0SW5wdXRJbmRpY2VzKCl7cmV0dXJuIHRoaXMuX2FsbElucHV0SW5kaWNlc31nZXRJbnB1dE5hbWVzKCl7cmV0dXJuIHRoaXMuX2FsbElucHV0TmFtZXN9Z2V0T3V0cHV0SW5kaWNlcygpe3JldHVybiB0aGlzLl9hbGxPdXRwdXRJbmRpY2VzfWdldE91dHB1dE5hbWVzKCl7cmV0dXJuIHRoaXMuX2FsbE91dHB1dE5hbWVzfWdldFZhbHVlcygpe3JldHVybiB0aGlzLl9hbGxEYXRhfWdldE5vZGVzKCl7cmV0dXJuIHRoaXMuX25vZGVzfWJ1aWxkR3JhcGgodCl7aWYodCBpbnN0YW5jZW9mIHIub25ueC5HcmFwaFByb3RvKXRoaXMuYnVpbGRHcmFwaEZyb21Pbm54Rm9ybWF0KHQpO2Vsc2V7aWYoISh0IGluc3RhbmNlb2YgdS5HcmFwaCkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdyYXBoIHR5cGUgaXMgbm90IHN1cHBvcnRlZC5cIik7dGhpcy5idWlsZEdyYXBoRnJvbU9ydEZvcm1hdCh0KX19YnVpbGRHcmFwaEZyb21Pbm54Rm9ybWF0KHQpe2NvbnN0IGU9bmV3IE1hcDt0aGlzLl9hbGxEYXRhPVtdLHRoaXMuX2FsbElucHV0SW5kaWNlcz1bXSx0aGlzLl9hbGxJbnB1dE5hbWVzPVtdLHRoaXMuX2FsbE91dHB1dEluZGljZXM9W10sdGhpcy5fYWxsT3V0cHV0TmFtZXM9W10sdGhpcy5fbm9kZXM9W107Y29uc3Qgbj1uZXcgTWFwO2lmKCF0LmlucHV0KXRocm93IG5ldyBFcnJvcihcIm1pc3NpbmcgaW5mb3JtYXRpb24gaW4gZ3JhcGg6IGlucHV0XCIpO2NvbnN0IHI9W107Zm9yKGNvbnN0IG4gb2YgdC5pbnB1dCl7aWYoZS5oYXMobi5uYW1lKSl0aHJvdyBuZXcgRXJyb3IoYGR1cGxpY2F0ZWQgaW5wdXQgbmFtZTogJHtuLm5hbWV9YCk7Y29uc3QgdD10aGlzLl9hbGxEYXRhLnB1c2gobmV3IGMobikpLTE7ZS5zZXQobi5uYW1lLHQpLHIucHVzaChuLm5hbWUpfWlmKCF0LmluaXRpYWxpemVyKXRocm93IG5ldyBFcnJvcihcIm1pc3NpbmcgaW5mb3JtYXRpb24gaW4gZ3JhcGg6IGluaXRpYWxpemVyXCIpO2Zvcihjb25zdCBuIG9mIHQuaW5pdGlhbGl6ZXIpe2xldCB0PWUuZ2V0KG4ubmFtZSk7aWYodm9pZCAwPT09dCl7Y29uc3Qgcj1uZXcgYztyLnR5cGU9e3NoYXBlOntkaW1zOnMuUHJvdG9VdGlsLnRlbnNvckRpbXNGcm9tUHJvdG8obi5kaW1zKX0sdGVuc29yVHlwZTpzLlByb3RvVXRpbC50ZW5zb3JEYXRhVHlwZUZyb21Qcm90byhuLmRhdGFUeXBlKX0sdD10aGlzLl9hbGxEYXRhLnB1c2gociktMSxlLnNldChuLm5hbWUsdCl9dGhpcy5fYWxsRGF0YVt0XS5fZnJvbT0tMSx0aGlzLl9hbGxEYXRhW3RdLnRlbnNvcj1hLlRlbnNvci5mcm9tUHJvdG8obil9Zm9yKGxldCB0PTA7dDx0aGlzLl9hbGxEYXRhLmxlbmd0aDt0KyspdGhpcy5fYWxsRGF0YVt0XS50ZW5zb3J8fCh0aGlzLl9hbGxJbnB1dEluZGljZXMucHVzaCh0KSx0aGlzLl9hbGxJbnB1dE5hbWVzLnB1c2goclt0XSkpO2lmKCF0Lm91dHB1dCl0aHJvdyBuZXcgRXJyb3IoXCJtaXNzaW5nIGluZm9ybWF0aW9uIGluIGdyYXBoOiBvdXRwdXRcIik7Zm9yKGNvbnN0IG4gb2YgdC5vdXRwdXQpe2lmKGUuaGFzKG4ubmFtZSkpdGhyb3cgbmV3IEVycm9yKGBkdXBsaWNhdGVkIG91dHB1dCBuYW1lOiAke24ubmFtZX1gKTtjb25zdCB0PXRoaXMuX2FsbERhdGEucHVzaChuZXcgYyhuKSktMTtlLnNldChuLm5hbWUsdCksdGhpcy5fYWxsT3V0cHV0SW5kaWNlcy5wdXNoKHQpLHRoaXMuX2FsbE91dHB1dE5hbWVzLnB1c2gobi5uYW1lKX1pZighdC5ub2RlKXRocm93IG5ldyBFcnJvcihcIm1pc3NpbmcgaW5mb3JtYXRpb24gaW4gZ3JhcGg6IG5vZGVcIik7Zm9yKGNvbnN0IGUgb2YgdC5ub2RlKXtpZighZS5uYW1lKWZvcihsZXQgdD0wOzt0Kyspe2NvbnN0IHI9YHVubmFtZWRfJHtlLm9wVHlwZX1fJHt0fWA7aWYoIW4uaGFzKHIpKXtlLm5hbWU9cjticmVha319aWYobi5oYXMoZS5uYW1lKSl0aHJvdyBuZXcgRXJyb3IoYGR1cGxpY2F0ZWQgbm9kZSBuYW1lOiAke2UubmFtZX1gKTtjb25zdCB0PXRoaXMuX25vZGVzLnB1c2gobmV3IGwoZSkpLTE7bi5zZXQoZS5uYW1lLHQpfWZvcihsZXQgbj0wO248dGhpcy5fbm9kZXMubGVuZ3RoO24rKyl7Y29uc3Qgcj10aGlzLl9ub2Rlc1tuXSxpPXQubm9kZVtuXTtpZighaS5vdXRwdXQpdGhyb3cgbmV3IEVycm9yKGBtaXNzaW5nIG91dHB1dCBmb3Igbm9kZTogJHtpLm5hbWV9YCk7Zm9yKGNvbnN0IHQgb2YgaS5vdXRwdXQpe2xldCBvPWUuZ2V0KHQpO2lmKHZvaWQgMD09PW8mJihvPXRoaXMuX2FsbERhdGEucHVzaChuZXcgYyktMSxlLnNldCh0LG8pKSxyLm91dHB1dHMucHVzaChvKSx2b2lkIDAhPT10aGlzLl9hbGxEYXRhW29dLl9mcm9tKXRocm93IG5ldyBFcnJvcihgbXVsdGlwbGUgbm9kZXMgb3V0cHV0IHRvIG9uZSBkYXRhIHZhbHVlOiAke299YCk7aWYodGhpcy5fYWxsRGF0YVtvXS5fZnJvbT1uLFwiQ29uc3RhbnRcIj09PWkub3BUeXBlKXtpZighaS5hdHRyaWJ1dGV8fDEhPT1pLmF0dHJpYnV0ZS5sZW5ndGh8fCFpLmF0dHJpYnV0ZVswXS50KXRocm93IG5ldyBFcnJvcihcIm1pc3NpbmcgYXR0cmlidXRlcyBvciBtaXNzaW5nIHRlbnNvciB2YWx1ZSBpbiBhdHRyaWJ1dGVzIGZvciB0aGlzIENvbnN0YW50IG9wZXJhdG9yXCIpO2lmKCFpLm91dHB1dHx8MSE9PWkub3V0cHV0Lmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJtaXNzaW5nIG91dHB1dCBvciBpbmNvcnJlY3QgbnVtYmVyIG9mIG91dHB1dHMgZm9yIHRoaXMgQ29uc3RhbnQgb3BlcmF0b3JcIik7ci5vdXRwdXRzLnBvcCgpLHIuZXhlY3V0ZU5vZGU9ITEsdGhpcy5fYWxsRGF0YVtvXS5fZnJvbT0tMSx0aGlzLl9hbGxEYXRhW29dLnRlbnNvcj1hLlRlbnNvci5mcm9tUHJvdG8oaS5hdHRyaWJ1dGVbMF0udCl9fX1mb3IobGV0IG49MDtuPHRoaXMuX25vZGVzLmxlbmd0aDtuKyspe2NvbnN0IHI9dGhpcy5fbm9kZXNbbl0saT10Lm5vZGVbbl07aWYoIWkuaW5wdXQpdGhyb3cgbmV3IEVycm9yKGBtaXNzaW5nIGlucHV0IGZvciBub2RlOiAke2kubmFtZX1gKTtmb3IoY29uc3QgdCBvZiBpLmlucHV0KXtjb25zdCBvPWUuZ2V0KHQpO2lmKHZvaWQgMD09PW8pe2lmKFwiXCI9PT10JiYzPT09aS5pbnB1dC5sZW5ndGgmJlwiUmVzaXplXCI9PT1pLm9wVHlwZSljb250aW51ZTt0aHJvdyBuZXcgRXJyb3IoYHVucmVjb2duaXplZCBpbnB1dCAnJHt0fScgZm9yIG5vZGU6ICR7aS5uYW1lfWApfXIuaW5wdXRzLnB1c2gobyksdGhpcy5fYWxsRGF0YVtvXS5fdG8ucHVzaChuKX19cmV0dXJuITB9YnVpbGRHcmFwaEZyb21PcnRGb3JtYXQodCl7dmFyIGUsbixyO2NvbnN0IGk9bmV3IE1hcDt0aGlzLl9hbGxEYXRhPVtdLHRoaXMuX2FsbElucHV0SW5kaWNlcz1bXSx0aGlzLl9hbGxJbnB1dE5hbWVzPVtdLHRoaXMuX2FsbE91dHB1dEluZGljZXM9W10sdGhpcy5fYWxsT3V0cHV0TmFtZXM9W10sdGhpcy5fbm9kZXM9W107Y29uc3Qgbz1uZXcgTWFwLHA9W107Zm9yKGxldCBvPTA7bzx0LmlucHV0c0xlbmd0aCgpO28rKyl7Y29uc3QgYT10LmlucHV0cyhvKTtpZihpLmhhcyhhKSl0aHJvdyBuZXcgRXJyb3IoYGR1cGxpY2F0ZWQgaW5wdXQgbmFtZTogJHthfWApO2ZvcihsZXQgbz0wO288dC5ub2RlQXJnc0xlbmd0aCgpO28rKylpZigobnVsbD09PShlPXQubm9kZUFyZ3MobykpfHx2b2lkIDA9PT1lP3ZvaWQgMDplLm5hbWUoKSk9PT1hKXtjb25zdCBlPW5ldyBjO2lmKChudWxsPT09KHI9bnVsbD09PShuPXQubm9kZUFyZ3MobykpfHx2b2lkIDA9PT1uP3ZvaWQgMDpuLnR5cGUoKSl8fHZvaWQgMD09PXI/dm9pZCAwOnIudmFsdWVUeXBlKCkpIT09dS5UeXBlSW5mb1ZhbHVlLnRlbnNvcl90eXBlKXRocm93IG5ldyBFcnJvcihcIlVuZXhwZWN0ZWQgdmFsdWUgdHlwZSBmb3IgdGhlIG5vZGVBcmcuXCIpO2NvbnN0IGw9dC5ub2RlQXJncyhvKS50eXBlKCkudmFsdWUobmV3IHUuVGVuc29yVHlwZUFuZFNoYXBlKSxmPXMuUHJvdG9VdGlsLnRlbnNvckRhdGFUeXBlRnJvbVByb3RvKGwuZWxlbVR5cGUoKSksZD1sLnNoYXBlKCksaD1bXTtmb3IobGV0IHQ9MDt0PGQuZGltTGVuZ3RoKCk7dCsrKWgucHVzaChzLkxvbmdVdGlsLmxvbmdUb051bWJlcihkLmRpbSh0KS52YWx1ZSgpLmRpbVZhbHVlKCkpKTtlLnR5cGU9e3NoYXBlOntkaW1zOmh9LHRlbnNvclR5cGU6Zn07Y29uc3QgZz10aGlzLl9hbGxEYXRhLnB1c2goZSktMTtpLnNldChhLGcpLHAucHVzaChhKX19Zm9yKGxldCBlPTA7ZTx0LmluaXRpYWxpemVyc0xlbmd0aCgpO2UrKyl7Y29uc3Qgbj10LmluaXRpYWxpemVycyhlKTtsZXQgcj1pLmdldChuLm5hbWUoKSk7aWYodm9pZCAwPT09cil7Y29uc3QgdD1uZXcgYyxlPXMuUHJvdG9VdGlsLnRlbnNvckRpbXNGcm9tT1JURm9ybWF0KG4pLG89cy5Qcm90b1V0aWwudGVuc29yRGF0YVR5cGVGcm9tUHJvdG8obi5kYXRhVHlwZSgpKTt0LnR5cGU9e3NoYXBlOntkaW1zOmV9LHRlbnNvclR5cGU6b30scj10aGlzLl9hbGxEYXRhLnB1c2godCktMSxpLnNldChuLm5hbWUoKSxyKX10aGlzLl9hbGxEYXRhW3JdLl9mcm9tPS0xLHRoaXMuX2FsbERhdGFbcl0udGVuc29yPWEuVGVuc29yLmZyb21PcnRUZW5zb3Iobil9Zm9yKGxldCB0PTA7dDx0aGlzLl9hbGxEYXRhLmxlbmd0aDt0KyspdGhpcy5fYWxsRGF0YVt0XS50ZW5zb3J8fCh0aGlzLl9hbGxJbnB1dEluZGljZXMucHVzaCh0KSx0aGlzLl9hbGxJbnB1dE5hbWVzLnB1c2gocFt0XSkpO2ZvcihsZXQgZT0wO2U8dC5vdXRwdXRzTGVuZ3RoKCk7ZSsrKXtjb25zdCBuPXQub3V0cHV0cyhlKTtpZihpLmhhcyhuKSl0aHJvdyBuZXcgRXJyb3IoYGR1cGxpY2F0ZWQgb3V0cHV0IG5hbWU6ICR7bn1gKTtjb25zdCByPXRoaXMuX2FsbERhdGEucHVzaChuZXcgYyktMTtpLnNldChuLHIpLHRoaXMuX2FsbE91dHB1dEluZGljZXMucHVzaChyKSx0aGlzLl9hbGxPdXRwdXROYW1lcy5wdXNoKG4pfWlmKCF0Lm5vZGVzKXRocm93IG5ldyBFcnJvcihcIm1pc3NpbmcgaW5mb3JtYXRpb24gaW4gZ3JhcGg6IG5vZGVcIik7Zm9yKGxldCBlPTA7ZTx0Lm5vZGVzTGVuZ3RoKCk7ZSsrKXtjb25zdCBuPXQubm9kZXMoZSk7bGV0IHI9bi5uYW1lKCk7aWYoIXIpZm9yKGxldCB0PTA7cj1gdW5uYW1lZF8ke24ub3BUeXBlKCl9XyR7dH1gLG8uaGFzKHIpO3QrKyk7aWYoby5oYXMocikpdGhyb3cgbmV3IEVycm9yKGBkdXBsaWNhdGVkIG5vZGUgbmFtZTogJHtyfWApO2NvbnN0IGk9dGhpcy5fbm9kZXMucHVzaChuZXcgbChuLHIpKS0xO28uc2V0KHIsaSl9Zm9yKGxldCBlPTA7ZTx0aGlzLl9ub2Rlcy5sZW5ndGg7ZSsrKXtjb25zdCBuPXRoaXMuX25vZGVzW2VdLHI9dC5ub2RlcyhlKTtpZihudWxsPT1yKXRocm93IG5ldyBFcnJvcihgTm8gbm9kZSBleGlzdHMgYXQgaW5kZXggJHtlfWApO2lmKDA9PT0obnVsbD09cj92b2lkIDA6ci5vdXRwdXRzTGVuZ3RoKCkpKXRocm93IG5ldyBFcnJvcihgbWlzc2luZyBvdXRwdXQgZm9yIG5vZGU6ICR7ci5uYW1lfWApO2ZvcihsZXQgdD0wO3Q8KG51bGw9PXI/dm9pZCAwOnIub3V0cHV0c0xlbmd0aCgpKTt0Kyspe2NvbnN0IG89bnVsbD09cj92b2lkIDA6ci5vdXRwdXRzKHQpO2xldCBzPWkuZ2V0KG8pO2lmKHZvaWQgMD09PXMmJihzPXRoaXMuX2FsbERhdGEucHVzaChuZXcgYyktMSxpLnNldChvLHMpKSxuLm91dHB1dHMucHVzaChzKSx2b2lkIDAhPT10aGlzLl9hbGxEYXRhW3NdLl9mcm9tKXRocm93IG5ldyBFcnJvcihgbXVsdGlwbGUgbm9kZXMgb3V0cHV0IHRvIG9uZSBkYXRhIHZhbHVlOiAke3N9YCk7aWYodGhpcy5fYWxsRGF0YVtzXS5fZnJvbT1lLFwiQ29uc3RhbnRcIj09PXIub3BUeXBlKCkpe2lmKDEhPT1yLmF0dHJpYnV0ZXNMZW5ndGgoKXx8IXIuYXR0cmlidXRlcygwKS50KCkpdGhyb3cgbmV3IEVycm9yKFwibWlzc2luZyBhdHRyaWJ1dGVzIG9yIG1pc3NpbmcgdGVuc29yIHZhbHVlIGluIGF0dHJpYnV0ZXMgZm9yIHRoaXMgQ29uc3RhbnQgb3BlcmF0b3JcIik7aWYoMSE9PXIub3V0cHV0c0xlbmd0aCgpKXRocm93IG5ldyBFcnJvcihcIm1pc3Npbmcgb3V0cHV0IG9yIGluY29ycmVjdCBudW1iZXIgb2Ygb3V0cHV0cyBmb3IgdGhpcyBDb25zdGFudCBvcGVyYXRvclwiKTtuLm91dHB1dHMucG9wKCksbi5leGVjdXRlTm9kZT0hMSx0aGlzLl9hbGxEYXRhW3NdLl9mcm9tPS0xLHRoaXMuX2FsbERhdGFbc10udGVuc29yPWEuVGVuc29yLmZyb21PcnRUZW5zb3Ioci5hdHRyaWJ1dGVzKDApLnQoKSl9fX1mb3IobGV0IGU9MDtlPHRoaXMuX25vZGVzLmxlbmd0aDtlKyspe2NvbnN0IG49dGhpcy5fbm9kZXNbZV0scj10Lm5vZGVzKGUpO2lmKDA9PT1yLmlucHV0c0xlbmd0aCgpKXRocm93IG5ldyBFcnJvcihgbWlzc2luZyBpbnB1dCBmb3Igbm9kZTogJHtyLm5hbWV9YCk7Zm9yKGxldCB0PTA7dDxyLmlucHV0c0xlbmd0aCgpO3QrKyl7Y29uc3Qgbz1yLmlucHV0cyh0KSxhPWkuZ2V0KG8pO2lmKHZvaWQgMD09PWEpdGhyb3cgbmV3IEVycm9yKGB1bnJlY29nbml6ZWQgaW5wdXQgJyR7b30nIGZvciBub2RlOiAke3IubmFtZSgpfWApO24uaW5wdXRzLnB1c2goYSksdGhpcy5fYWxsRGF0YVthXS5fdG8ucHVzaChlKX19fWNoZWNrSXNBY3ljbGljKCl7Y29uc3QgdD1uZXcgU2V0O3RoaXMuX2FsbElucHV0SW5kaWNlcy5mb3JFYWNoKChlPT57dGhpcy5fYWxsRGF0YVtlXS5fdG8uZm9yRWFjaCgoZT0+e3QuYWRkKGUpfSkpfSkpO2NvbnN0IGU9QXJyYXkuZnJvbSh0KSxuPW5ldyBBcnJheSh0aGlzLl9ub2Rlcy5sZW5ndGgpLmZpbGwoXCJ3aGl0ZVwiKTtmb3IoO2UubGVuZ3RoPjA7KXtjb25zdCB0PWUucG9wKCk7XCJncmF5XCI9PT1uW3RdP25bdF09XCJibGFja1wiOihlLnB1c2godCksblt0XT1cImdyYXlcIix0aGlzLl9ub2Rlc1t0XS5vdXRwdXRzLmZvckVhY2goKHI9Pntjb25zdCBpPXRoaXMuX2FsbERhdGFbcl07aWYodm9pZCAwIT09aS50ZW5zb3IpdGhyb3cgbmV3IEVycm9yKFwibm9kZSBvdXRwdXRzIHNob3VsZCBub3QgYmUgaW5pdGlhbGl6ZWRcIik7aWYoaS5fZnJvbSE9PXQpdGhyb3cgbmV3IEVycm9yKFwiZnJvbSBwcm9wZXJ0eSBvZiB0aGUgVmFsdWUgb2JqZWN0IGRvZXNuJ3QgbWF0Y2ggaW5kZXggb2YgTm9kZSBiZWluZyBwcm9jZXNzZWRcIik7aS5fdG8uZm9yRWFjaCgodD0+e2lmKFwiZ3JheVwiPT09blt0XSl0aHJvdyBuZXcgRXJyb3IoXCJtb2RlbCBncmFwaCBpcyBjeWNsaWNcIik7XCJ3aGl0ZVwiPT09blt0XSYmZS5wdXNoKHQpfSkpfSkpKX19dHJhbnNmb3JtR3JhcGgodCl7dGhpcy5yZW1vdmVBbGxJZGVudGl0eU5vZGVzKCksdGhpcy5yZW1vdmVBbGxEcm9wb3V0Tm9kZXMoKSx0aGlzLmZ1c2VDb252QWN0aXZhdGlvbk5vZGVzKCksdCYmdC50cmFuc2Zvcm1HcmFwaCh0aGlzKSx0aGlzLmZpbmFsaXplR3JhcGgoKX1maW5hbGl6ZUdyYXBoKCl7bGV0IHQ9MDtmb3IobGV0IGU9MDtlPHRoaXMuX25vZGVzLmxlbmd0aDtlKyspdGhpcy5fbm9kZXNbZV0uZXhlY3V0ZU5vZGU/dD4wJiYodGhpcy5fbm9kZXNbZV0uaW5wdXRzLmZvckVhY2goKG49Pntjb25zdCByPXRoaXMuX2FsbERhdGFbbl0uX3RvLmluZGV4T2YoZSt0KTstMSE9PXImJih0aGlzLl9hbGxEYXRhW25dLl90b1tyXT1lKX0pKSx0aGlzLl9ub2Rlc1tlXS5vdXRwdXRzLmZvckVhY2goKG49Pnt0aGlzLl9hbGxEYXRhW25dLl9mcm9tJiZ0aGlzLl9hbGxEYXRhW25dLl9mcm9tPT09ZSt0JiYodGhpcy5fYWxsRGF0YVtuXS5fZnJvbT1lKX0pKSk6KHQrKyx0aGlzLl9ub2Rlc1tlXS5vdXRwdXRzLmZvckVhY2goKHQ9Pnt0aGlzLl9hbGxEYXRhW3RdLl9mcm9tPS0yfSkpLHRoaXMuX25vZGVzLnNwbGljZShlLDEpLGUtLSk7dD0wO2ZvcihsZXQgZT0wO2U8dGhpcy5fYWxsRGF0YS5sZW5ndGg7ZSsrKWlmKC0yIT09dGhpcy5fYWxsRGF0YVtlXS5mcm9tfHwtMSE9PXRoaXMuX2FsbE91dHB1dEluZGljZXMuaW5kZXhPZihlK3QpKXtpZih0PjApe2xldCBuPS0xO3ZvaWQgMCE9PXRoaXMuX2FsbERhdGFbZV0uZnJvbSYmLTEhPT10aGlzLl9hbGxEYXRhW2VdLmZyb20/KG49dGhpcy5fbm9kZXNbdGhpcy5fYWxsRGF0YVtlXS5mcm9tXS5vdXRwdXRzLmluZGV4T2YoZSt0KSwtMSE9PW4mJih0aGlzLl9ub2Rlc1t0aGlzLl9hbGxEYXRhW2VdLmZyb21dLm91dHB1dHNbbl09ZSkpOihuPXRoaXMuX2FsbElucHV0SW5kaWNlcy5pbmRleE9mKGUrdCksLTEhPT1uJiYodGhpcy5fYWxsSW5wdXRJbmRpY2VzW25dPWUpKSx0aGlzLl9hbGxEYXRhW2VdLnRvLmZvckVhY2goKHI9PntuPXRoaXMuX25vZGVzW3JdLmlucHV0cy5pbmRleE9mKGUrdCksLTEhPT1uJiYodGhpcy5fbm9kZXNbcl0uaW5wdXRzW25dPWUpfSkpLDA9PT10aGlzLl9hbGxEYXRhW2VdLnRvLmxlbmd0aCYmKG49dGhpcy5fYWxsT3V0cHV0SW5kaWNlcy5pbmRleE9mKGUrdCksLTEhPT1uJiYodGhpcy5fYWxsT3V0cHV0SW5kaWNlc1tuXT1lKSl9fWVsc2UgdCsrLHRoaXMuX2FsbERhdGEuc3BsaWNlKGUsMSksZS0tfWRlbGV0ZU5vZGUodCl7Y29uc3QgZT10aGlzLl9ub2Rlc1t0XTtpZihlLm91dHB1dHMubGVuZ3RoPjEpZm9yKGxldCB0PTE7dDxlLm91dHB1dHMubGVuZ3RoO3QrKylpZih0aGlzLl9hbGxEYXRhW2Uub3V0cHV0c1t0XV0udG8ubGVuZ3RoPjApdGhyb3cgbmV3IEVycm9yKFwiTm9kZSBkZWxldGlvbiB3aXRoIG1vcmUgdGhhbiBvbmUgb3V0cHV0IGNvbm5lY3RlZCB0byBvdGhlciBub2RlcyBpcyBub3Qgc3VwcG9ydGVkLiBcIik7ZS5leGVjdXRlTm9kZT0hMTtjb25zdCBuPWUuaW5wdXRzWzBdLHI9ZS5vdXRwdXRzWzBdLGk9dGhpcy5fYWxsRGF0YVtyXS50byxvPXRoaXMuX2FsbERhdGFbbl0udG8uaW5kZXhPZih0KTtpZigtMT09PW8pdGhyb3cgbmV3IEVycm9yKFwiVGhlIFZhbHVlIG9iamVjdCBkb2Vzbid0IGhhdmUgdGhlIGN1cnJlbnQgTm9kZSBpbiBpdCdzICd0bycgcHJvcGVydHkgXCIpO3RoaXMuX2FsbERhdGFbbl0udG8uc3BsaWNlKG8sMSksdGhpcy5fYWxsRGF0YVtyXS5fdG89W107Y29uc3QgYT10aGlzLl9hbGxPdXRwdXRJbmRpY2VzLmluZGV4T2Yocik7aWYoLTEhPT1hJiYodGhpcy5fYWxsT3V0cHV0SW5kaWNlc1thXT1uKSxpJiZpLmxlbmd0aD4wKWZvcihjb25zdCB0IG9mIGkpe2NvbnN0IGU9dGhpcy5fbm9kZXNbdF0uaW5wdXRzLmluZGV4T2Yocik7aWYoLTE9PT1lKXRocm93IG5ldyBFcnJvcihcIlRoZSBOb2RlIG9iamVjdCBkb2Vzbid0IGhhdmUgdGhlIG91dHB1dCBWYWx1ZSBpbiBpdCdzICdpbnB1dHMnIHByb3BlcnR5IFwiKTt0aGlzLl9ub2Rlc1t0XS5pbnB1dHNbZV09bix0aGlzLl9hbGxEYXRhW25dLnRvLnB1c2godCl9fXJlbW92ZUFsbERyb3BvdXROb2Rlcygpe2xldCB0PTA7Zm9yKGNvbnN0IGUgb2YgdGhpcy5fbm9kZXMpe2lmKFwiRHJvcG91dFwiPT09ZS5vcFR5cGUpe2lmKDEhPT1lLmlucHV0cy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiRHJvcG91dCBub2RlcyBzaG91bGQgb25seSBjb250YWluIG9uZSBpbnB1dC4gXCIpO2lmKDEhPT1lLm91dHB1dHMubGVuZ3RoJiYyIT09ZS5vdXRwdXRzLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJEcm9wb3V0IG5vZGVzIHNob3VsZCBjb250YWluIGVpdGhlciAxIG9yIDIgb3V0cHV0KHMpXCIpO2lmKDI9PT1lLm91dHB1dHMubGVuZ3RoJiYwIT09dGhpcy5fYWxsRGF0YVtlLm91dHB1dHNbMV1dLl90by5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiRHJvcG91dCBub2RlcydzIHNlY29uZCBvdXRwdXQgc2hvdWxkIG5vdCBiZSByZWZlcmVuY2VkIGJ5IG90aGVyIG5vZGVzXCIpO3RoaXMuZGVsZXRlTm9kZSh0KX10Kyt9fXJlbW92ZUFsbElkZW50aXR5Tm9kZXMoKXtsZXQgdD0wO2Zvcihjb25zdCBlIG9mIHRoaXMuX25vZGVzKVwiSWRlbnRpdHlcIj09PWUub3BUeXBlJiZ0aGlzLmRlbGV0ZU5vZGUodCksdCsrfWlzQWN0aXZhdGlvbih0KXtzd2l0Y2godC5vcFR5cGUpe2Nhc2VcIlJlbHVcIjpjYXNlXCJTaWdtb2lkXCI6Y2FzZVwiQ2xpcFwiOnJldHVybiEwO2RlZmF1bHQ6cmV0dXJuITF9fWZ1c2VDb252QWN0aXZhdGlvbk5vZGVzKCl7Zm9yKGNvbnN0IHQgb2YgdGhpcy5fbm9kZXMpaWYoXCJDb252XCI9PT10Lm9wVHlwZSl7Y29uc3QgZT10aGlzLl9hbGxEYXRhW3Qub3V0cHV0c1swXV0uX3RvO2lmKDE9PT1lLmxlbmd0aCYmdGhpcy5pc0FjdGl2YXRpb24odGhpcy5fbm9kZXNbZVswXV0pKXtjb25zdCBuPXRoaXMuX25vZGVzW2VbMF1dO2lmKFwiQ2xpcFwiPT09bi5vcFR5cGUpaWYoMT09PW4uaW5wdXRzLmxlbmd0aCl0cnl7dC5hdHRyaWJ1dGVzLnNldChcImFjdGl2YXRpb25fcGFyYW1zXCIsXCJmbG9hdHNcIixbbi5hdHRyaWJ1dGVzLmdldEZsb2F0KFwibWluXCIpLG4uYXR0cmlidXRlcy5nZXRGbG9hdChcIm1heFwiKV0pfWNhdGNoKGUpe3QuYXR0cmlidXRlcy5zZXQoXCJhY3RpdmF0aW9uX3BhcmFtc1wiLFwiZmxvYXRzXCIsW3MuTUlOX0NMSVAscy5NQVhfQ0xJUF0pfWVsc2V7aWYoIShuLmlucHV0cy5sZW5ndGg+PTMmJnZvaWQgMCE9PXRoaXMuX2FsbERhdGFbbi5pbnB1dHNbMV1dLnRlbnNvciYmdm9pZCAwIT09dGhpcy5fYWxsRGF0YVtuLmlucHV0c1syXV0udGVuc29yKSljb250aW51ZTt0LmF0dHJpYnV0ZXMuc2V0KFwiYWN0aXZhdGlvbl9wYXJhbXNcIixcImZsb2F0c1wiLFt0aGlzLl9hbGxEYXRhW24uaW5wdXRzWzFdXS50ZW5zb3IuZmxvYXREYXRhWzBdLHRoaXMuX2FsbERhdGFbbi5pbnB1dHNbMl1dLnRlbnNvci5mbG9hdERhdGFbMF1dKX10LmF0dHJpYnV0ZXMuc2V0KFwiYWN0aXZhdGlvblwiLFwic3RyaW5nXCIsbi5vcFR5cGUpLHRoaXMuZGVsZXRlTm9kZShlWzBdKX19fX19LDYyMzE6KHQsZSk9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLm5vdz1lLlByb2ZpbGVyPWUuTG9nZ2VyPXZvaWQgMDtjb25zdCBuPXt2ZXJib3NlOjFlMyxpbmZvOjJlMyx3YXJuaW5nOjRlMyxlcnJvcjo1ZTMsZmF0YWw6NmUzfSxyPXtub25lOm5ldyBjbGFzc3tsb2codCxlLG4pe319LGNvbnNvbGU6bmV3IGNsYXNze2xvZyh0LGUsbil7Y29uc29sZS5sb2coYCR7dGhpcy5jb2xvcih0KX0gJHtuP1wiXHUwMDFiWzM1bVwiK24rXCJcdTAwMWJbMG0gXCI6XCJcIn0ke2V9YCl9Y29sb3IodCl7c3dpdGNoKHQpe2Nhc2VcInZlcmJvc2VcIjpyZXR1cm5cIlx1MDAxYlszNDs0MG12XHUwMDFiWzBtXCI7Y2FzZVwiaW5mb1wiOnJldHVyblwiXHUwMDFiWzMybWlcdTAwMWJbMG1cIjtjYXNlXCJ3YXJuaW5nXCI6cmV0dXJuXCJcdTAwMWJbMzA7NDNtd1x1MDAxYlswbVwiO2Nhc2VcImVycm9yXCI6cmV0dXJuXCJcdTAwMWJbMzE7NDBtZVx1MDAxYlswbVwiO2Nhc2VcImZhdGFsXCI6cmV0dXJuXCJcdTAwMWJbMTAxbWZcdTAwMWJbMG1cIjtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgc2V2ZXJpdHk6ICR7dH1gKX19fX0saT17cHJvdmlkZXI6XCJjb25zb2xlXCIsbWluaW1hbFNldmVyaXR5Olwid2FybmluZ1wiLGxvZ0RhdGVUaW1lOiEwLGxvZ1NvdXJjZUxvY2F0aW9uOiExfTtsZXQgbz17XCJcIjppfTtmdW5jdGlvbiBhKHQsZSxuLHIpe2lmKHZvaWQgMD09PWUpcmV0dXJuIGk9dCx7dmVyYm9zZTphLnZlcmJvc2UuYmluZChudWxsLGkpLGluZm86YS5pbmZvLmJpbmQobnVsbCxpKSx3YXJuaW5nOmEud2FybmluZy5iaW5kKG51bGwsaSksZXJyb3I6YS5lcnJvci5iaW5kKG51bGwsaSksZmF0YWw6YS5mYXRhbC5iaW5kKG51bGwsaSl9O2lmKHZvaWQgMD09PW4pcyh0LGUpO2Vsc2UgaWYoXCJudW1iZXJcIj09dHlwZW9mIG4mJnZvaWQgMD09PXIpcyh0LGUpO2Vsc2UgaWYoXCJzdHJpbmdcIj09dHlwZW9mIG4mJnZvaWQgMD09PXIpcyh0LG4sMCxlKTtlbHNle2lmKFwic3RyaW5nXCIhPXR5cGVvZiBufHxcIm51bWJlclwiIT10eXBlb2Ygcil0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW5wdXQgaXMgdmFsaWRcIik7cyh0LG4sMCxlKX12YXIgaX1mdW5jdGlvbiBzKHQsZSxpLGEpe2NvbnN0IHM9b1thfHxcIlwiXXx8b1tcIlwiXTtuW3RdPG5bcy5taW5pbWFsU2V2ZXJpdHldfHwocy5sb2dEYXRlVGltZSYmKGU9YCR7KG5ldyBEYXRlKS50b0lTT1N0cmluZygpfXwke2V9YCkscy5sb2dTb3VyY2VMb2NhdGlvbixyW3MucHJvdmlkZXJdLmxvZyh0LGUsYSkpfSFmdW5jdGlvbih0KXtmdW5jdGlvbiBlKHQpe289e30sbihcIlwiLHR8fHt9KX1mdW5jdGlvbiBuKHQsbil7aWYoXCIqXCI9PT10KWUobik7ZWxzZXtjb25zdCBlPW9bdF18fGk7b1t0XT17cHJvdmlkZXI6bi5wcm92aWRlcnx8ZS5wcm92aWRlcixtaW5pbWFsU2V2ZXJpdHk6bi5taW5pbWFsU2V2ZXJpdHl8fGUubWluaW1hbFNldmVyaXR5LGxvZ0RhdGVUaW1lOnZvaWQgMD09PW4ubG9nRGF0ZVRpbWU/ZS5sb2dEYXRlVGltZTpuLmxvZ0RhdGVUaW1lLGxvZ1NvdXJjZUxvY2F0aW9uOnZvaWQgMD09PW4ubG9nU291cmNlTG9jYXRpb24/ZS5sb2dTb3VyY2VMb2NhdGlvbjpuLmxvZ1NvdXJjZUxvY2F0aW9ufX19dC52ZXJib3NlPWZ1bmN0aW9uKGUsbil7dChcInZlcmJvc2VcIixlLG4pfSx0LmluZm89ZnVuY3Rpb24oZSxuKXt0KFwiaW5mb1wiLGUsbil9LHQud2FybmluZz1mdW5jdGlvbihlLG4pe3QoXCJ3YXJuaW5nXCIsZSxuKX0sdC5lcnJvcj1mdW5jdGlvbihlLG4pe3QoXCJlcnJvclwiLGUsbil9LHQuZmF0YWw9ZnVuY3Rpb24oZSxuKXt0KFwiZmF0YWxcIixlLG4pfSx0LnJlc2V0PWUsdC5zZXQ9bix0LnNldFdpdGhFbnY9ZnVuY3Rpb24odCl7Y29uc3QgZT17fTt0LmxvZ0xldmVsJiYoZS5taW5pbWFsU2V2ZXJpdHk9dC5sb2dMZXZlbCksbihcIlwiLGUpfX0oYXx8KGE9e30pKSxlLkxvZ2dlcj1hO2NsYXNzIHV7Y29uc3RydWN0b3IodCxlLG4scixpLG8pe3RoaXMuY2F0ZWdvcnk9dCx0aGlzLm5hbWU9ZSx0aGlzLnN0YXJ0VGltZT1uLHRoaXMuZW5kQ2FsbGJhY2s9cix0aGlzLnRpbWVyPWksdGhpcy5jdHg9b31lbmQoKXtyZXR1cm4gdGhpcy5lbmRDYWxsYmFjayh0aGlzKX1hc3luYyBjaGVja1RpbWVyKCl7aWYodm9pZCAwPT09dGhpcy5jdHh8fHZvaWQgMD09PXRoaXMudGltZXIpdGhyb3cgbmV3IEVycm9yKFwiTm8gd2ViZ2wgdGltZXIgZm91bmRcIik7cmV0dXJuIHRoaXMuY3R4LmVuZFRpbWVyKCksdGhpcy5jdHgud2FpdEZvclF1ZXJ5QW5kR2V0VGltZSh0aGlzLnRpbWVyKX19Y2xhc3MgY3tjb25zdHJ1Y3Rvcih0LGUsbixyKXt0aGlzLmNhdGVnb3J5PXQsdGhpcy5uYW1lPWUsdGhpcy5zdGFydFRpbWU9bix0aGlzLmVuZFRpbWU9cn19ZS5Qcm9maWxlcj1jbGFzc3tzdGF0aWMgY3JlYXRlKHQpe3JldHVybiB2b2lkIDA9PT10P25ldyB0aGlzOm5ldyB0aGlzKHQubWF4TnVtYmVyRXZlbnRzLHQuZmx1c2hCYXRjaFNpemUsdC5mbHVzaEludGVydmFsSW5NaWxsaXNlY29uZHMpfWNvbnN0cnVjdG9yKHQsZSxuKXt0aGlzLl9zdGFydGVkPSExLHRoaXMuX2ZsdXNoUG9pbnRlcj0wLHRoaXMuX3N0YXJ0ZWQ9ITEsdGhpcy5fbWF4TnVtYmVyRXZlbnRzPXZvaWQgMD09PXQ/MWU0OnQsdGhpcy5fZmx1c2hCYXRjaFNpemU9dm9pZCAwPT09ZT8xMDplLHRoaXMuX2ZsdXNoSW50ZXJ2YWxJbk1pbGxpc2Vjb25kcz12b2lkIDA9PT1uPzVlMzpufXN0YXJ0KCl7dGhpcy5fc3RhcnRlZD0hMCx0aGlzLl90aW1pbmdFdmVudHM9W10sdGhpcy5fZmx1c2hUaW1lPSgwLGUubm93KSgpLHRoaXMuX2ZsdXNoUG9pbnRlcj0wfXN0b3AoKXtmb3IodGhpcy5fc3RhcnRlZD0hMTt0aGlzLl9mbHVzaFBvaW50ZXI8dGhpcy5fdGltaW5nRXZlbnRzLmxlbmd0aDt0aGlzLl9mbHVzaFBvaW50ZXIrKyl0aGlzLmxvZ09uZUV2ZW50KHRoaXMuX3RpbWluZ0V2ZW50c1t0aGlzLl9mbHVzaFBvaW50ZXJdKX1ldmVudCh0LGUsbixyKXtjb25zdCBpPXRoaXMuX3N0YXJ0ZWQ/dGhpcy5iZWdpbih0LGUscik6dm9pZCAwO2xldCBvPSExO2NvbnN0IGE9bigpO2lmKGEmJlwiZnVuY3Rpb25cIj09dHlwZW9mIGEudGhlbilyZXR1cm4gbz0hMCxuZXcgUHJvbWlzZSgoKHQsZSk9PnthLnRoZW4oKGFzeW5jIGU9PntpJiZhd2FpdCBpLmVuZCgpLHQoZSl9KSwoYXN5bmMgdD0+e2kmJmF3YWl0IGkuZW5kKCksZSh0KX0pKX0pKTtpZighbyYmaSl7Y29uc3QgdD1pLmVuZCgpO2lmKHQmJlwiZnVuY3Rpb25cIj09dHlwZW9mIHQudGhlbilyZXR1cm4gbmV3IFByb21pc2UoKChlLG4pPT57dC50aGVuKCgoKT0+e2UoYSl9KSwodD0+e24odCl9KSl9KSl9cmV0dXJuIGF9YmVnaW4odCxuLHIpe2lmKCF0aGlzLl9zdGFydGVkKXRocm93IG5ldyBFcnJvcihcInByb2ZpbGVyIGlzIG5vdCBzdGFydGVkIHlldFwiKTtpZih2b2lkIDA9PT1yKXtjb25zdCByPSgwLGUubm93KSgpO3JldHVybiB0aGlzLmZsdXNoKHIpLG5ldyB1KHQsbixyLCh0PT50aGlzLmVuZFN5bmModCkpKX17Y29uc3QgZT1yLmJlZ2luVGltZXIoKTtyZXR1cm4gbmV3IHUodCxuLDAsKGFzeW5jIHQ9PnRoaXMuZW5kKHQpKSxlLHIpfX1hc3luYyBlbmQodCl7Y29uc3QgZT1hd2FpdCB0LmNoZWNrVGltZXIoKTt0aGlzLl90aW1pbmdFdmVudHMubGVuZ3RoPHRoaXMuX21heE51bWJlckV2ZW50cyYmKHRoaXMuX3RpbWluZ0V2ZW50cy5wdXNoKG5ldyBjKHQuY2F0ZWdvcnksdC5uYW1lLHQuc3RhcnRUaW1lLGUpKSx0aGlzLmZsdXNoKGUpKX1lbmRTeW5jKHQpe2NvbnN0IG49KDAsZS5ub3cpKCk7dGhpcy5fdGltaW5nRXZlbnRzLmxlbmd0aDx0aGlzLl9tYXhOdW1iZXJFdmVudHMmJih0aGlzLl90aW1pbmdFdmVudHMucHVzaChuZXcgYyh0LmNhdGVnb3J5LHQubmFtZSx0LnN0YXJ0VGltZSxuKSksdGhpcy5mbHVzaChuKSl9bG9nT25lRXZlbnQodCl7ZS5Mb2dnZXIudmVyYm9zZShgUHJvZmlsZXIuJHt0LmNhdGVnb3J5fWAsYCR7KHQuZW5kVGltZS10LnN0YXJ0VGltZSkudG9GaXhlZCgyKX1tcyBvbiBldmVudCAnJHt0Lm5hbWV9JyBhdCAke3QuZW5kVGltZS50b0ZpeGVkKDIpfWApfWZsdXNoKHQpe2lmKHRoaXMuX3RpbWluZ0V2ZW50cy5sZW5ndGgtdGhpcy5fZmx1c2hQb2ludGVyPj10aGlzLl9mbHVzaEJhdGNoU2l6ZXx8dC10aGlzLl9mbHVzaFRpbWU+PXRoaXMuX2ZsdXNoSW50ZXJ2YWxJbk1pbGxpc2Vjb25kcyl7Zm9yKGNvbnN0IHQ9dGhpcy5fZmx1c2hQb2ludGVyO3RoaXMuX2ZsdXNoUG9pbnRlcjx0K3RoaXMuX2ZsdXNoQmF0Y2hTaXplJiZ0aGlzLl9mbHVzaFBvaW50ZXI8dGhpcy5fdGltaW5nRXZlbnRzLmxlbmd0aDt0aGlzLl9mbHVzaFBvaW50ZXIrKyl0aGlzLmxvZ09uZUV2ZW50KHRoaXMuX3RpbWluZ0V2ZW50c1t0aGlzLl9mbHVzaFBvaW50ZXJdKTt0aGlzLl9mbHVzaFRpbWU9KDAsZS5ub3cpKCl9fWdldCBzdGFydGVkKCl7cmV0dXJuIHRoaXMuX3N0YXJ0ZWR9fSxlLm5vdz1cInVuZGVmaW5lZFwiIT10eXBlb2YgcGVyZm9ybWFuY2UmJnBlcmZvcm1hbmNlLm5vdz8oKT0+cGVyZm9ybWFuY2Uubm93KCk6RGF0ZS5ub3d9LDI2NDQ6KHQsZSxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUuTW9kZWw9dm9pZCAwO2NvbnN0IHI9big1Njg2KSxpPW4oMTQ0Niksbz1uKDcwNzApLGE9big5Mzk1KSxzPW4oMjUxNyk7dmFyIHU9YS5vbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzO2UuTW9kZWw9Y2xhc3N7Y29uc3RydWN0b3IoKXt9bG9hZCh0LGUsbil7aWYoIW4pdHJ5e3JldHVybiB2b2lkIHRoaXMubG9hZEZyb21Pbm54Rm9ybWF0KHQsZSl9Y2F0Y2godCl7aWYodm9pZCAwIT09bil0aHJvdyB0fXRoaXMubG9hZEZyb21PcnRGb3JtYXQodCxlKX1sb2FkRnJvbU9ubnhGb3JtYXQodCxlKXtjb25zdCBuPWkub25ueC5Nb2RlbFByb3RvLmRlY29kZSh0KTtpZihzLkxvbmdVdGlsLmxvbmdUb051bWJlcihuLmlyVmVyc2lvbik8Myl0aHJvdyBuZXcgRXJyb3IoXCJvbmx5IHN1cHBvcnQgT05OWCBtb2RlbCB3aXRoIElSX1ZFUlNJT04+PTNcIik7dGhpcy5fb3BzZXRzPW4ub3BzZXRJbXBvcnQubWFwKCh0PT4oe2RvbWFpbjp0LmRvbWFpbix2ZXJzaW9uOnMuTG9uZ1V0aWwubG9uZ1RvTnVtYmVyKHQudmVyc2lvbil9KSkpLHRoaXMuX2dyYXBoPW8uR3JhcGguZnJvbShuLmdyYXBoLGUpfWxvYWRGcm9tT3J0Rm9ybWF0KHQsZSl7Y29uc3Qgbj1uZXcgci5mbGF0YnVmZmVycy5CeXRlQnVmZmVyKHQpLGk9dS5JbmZlcmVuY2VTZXNzaW9uLmdldFJvb3RBc0luZmVyZW5jZVNlc3Npb24obikubW9kZWwoKTtpZihzLkxvbmdVdGlsLmxvbmdUb051bWJlcihpLmlyVmVyc2lvbigpKTwzKXRocm93IG5ldyBFcnJvcihcIm9ubHkgc3VwcG9ydCBPTk5YIG1vZGVsIHdpdGggSVJfVkVSU0lPTj49M1wiKTt0aGlzLl9vcHNldHM9W107Zm9yKGxldCB0PTA7dDxpLm9wc2V0SW1wb3J0TGVuZ3RoKCk7dCsrKXtjb25zdCBlPWkub3BzZXRJbXBvcnQodCk7dGhpcy5fb3BzZXRzLnB1c2goe2RvbWFpbjpudWxsPT1lP3ZvaWQgMDplLmRvbWFpbigpLHZlcnNpb246cy5Mb25nVXRpbC5sb25nVG9OdW1iZXIoZS52ZXJzaW9uKCkpfSl9dGhpcy5fZ3JhcGg9by5HcmFwaC5mcm9tKGkuZ3JhcGgoKSxlKX1nZXQgZ3JhcGgoKXtyZXR1cm4gdGhpcy5fZ3JhcGh9Z2V0IG9wc2V0cygpe3JldHVybiB0aGlzLl9vcHNldHN9fX0sNzgyOih0LGUpPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5GTE9BVF9UWVBFUz1lLklOVF9UWVBFUz1lLk5VTUJFUl9UWVBFUz12b2lkIDAsZS5OVU1CRVJfVFlQRVM9W1wiZmxvYXQzMlwiLFwiZmxvYXQ2NFwiLFwiaW50MzJcIixcImludDE2XCIsXCJpbnQ4XCIsXCJ1aW50MTZcIixcInVpbnQzMlwiLFwidWludDhcIl0sZS5JTlRfVFlQRVM9W1wiaW50MzJcIixcImludDE2XCIsXCJpbnQ4XCIsXCJ1aW50MTZcIixcInVpbnQzMlwiLFwidWludDhcIl0sZS5GTE9BVF9UWVBFUz1bXCJmbG9hdDMyXCIsXCJmbG9hdDY0XCJdfSwxMDQ3Oih0LGUpPT57XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gbih0LGUpe2lmKGUuZW5kc1dpdGgoXCIrXCIpKXtjb25zdCBuPU51bWJlci5wYXJzZUludChlLnN1YnN0cmluZygwLGUubGVuZ3RoLTEpLDEwKTtyZXR1cm4haXNOYU4obikmJm48PXR9aWYoMj09PWUuc3BsaXQoXCItXCIpLmxlbmd0aCl7Y29uc3Qgbj1lLnNwbGl0KFwiLVwiKSxyPU51bWJlci5wYXJzZUludChuWzBdLDEwKSxpPU51bWJlci5wYXJzZUludChuWzFdLDEwKTtyZXR1cm4haXNOYU4ocikmJiFpc05hTihpKSYmcjw9dCYmdDw9aX1yZXR1cm4gTnVtYmVyLnBhcnNlSW50KGUsMTApPT09dH1PYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLnJlc29sdmVPcGVyYXRvcj12b2lkIDAsZS5yZXNvbHZlT3BlcmF0b3I9ZnVuY3Rpb24odCxlLHIpe2Zvcihjb25zdCBpIG9mIHIpe2NvbnN0IHI9aVswXSxvPWlbMV0sYT1pWzJdLHM9aVszXSx1PWlbNF07aWYodC5vcFR5cGU9PT1yKWZvcihjb25zdCB0IG9mIGUpaWYoKHQuZG9tYWluPT09b3x8XCJhaS5vbm54XCI9PT10LmRvbWFpbiYmXCJcIj09PW8pJiZuKHQudmVyc2lvbixhKSlyZXR1cm57b3BJbXBsOnMsb3BJbml0OnV9fXRocm93IG5ldyBUeXBlRXJyb3IoYGNhbm5vdCByZXNvbHZlIG9wZXJhdG9yICcke3Qub3BUeXBlfScgd2l0aCBvcHNldHM6ICR7ZS5tYXAoKHQ9PmAke3QuZG9tYWlufHxcImFpLm9ubnhcIn0gdiR7dC52ZXJzaW9ufWApKS5qb2luKFwiLCBcIil9YCl9fSw5Mzk1Oih0LGUsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLm9ubnhydW50aW1lPXZvaWQgMDtjb25zdCByPW4oNTY4Nik7dmFyIGksbztpPWUub25ueHJ1bnRpbWV8fChlLm9ubnhydW50aW1lPXt9KSxmdW5jdGlvbih0KXtsZXQgZTshZnVuY3Rpb24odCl7dFt0LlVOREVGSU5FRD0wXT1cIlVOREVGSU5FRFwiLHRbdC5GTE9BVD0xXT1cIkZMT0FUXCIsdFt0LklOVD0yXT1cIklOVFwiLHRbdC5TVFJJTkc9M109XCJTVFJJTkdcIix0W3QuVEVOU09SPTRdPVwiVEVOU09SXCIsdFt0LkdSQVBIPTVdPVwiR1JBUEhcIix0W3QuRkxPQVRTPTZdPVwiRkxPQVRTXCIsdFt0LklOVFM9N109XCJJTlRTXCIsdFt0LlNUUklOR1M9OF09XCJTVFJJTkdTXCIsdFt0LlRFTlNPUlM9OV09XCJURU5TT1JTXCIsdFt0LkdSQVBIUz0xMF09XCJHUkFQSFNcIix0W3QuU1BBUlNFX1RFTlNPUj0xMV09XCJTUEFSU0VfVEVOU09SXCIsdFt0LlNQQVJTRV9URU5TT1JTPTEyXT1cIlNQQVJTRV9URU5TT1JTXCJ9KGU9dC5BdHRyaWJ1dGVUeXBlfHwodC5BdHRyaWJ1dGVUeXBlPXt9KSl9KChvPWkuZXhwZXJpbWVudGFsfHwoaS5leHBlcmltZW50YWw9e30pKS5mYnN8fChvLmZicz17fSkpLGZ1bmN0aW9uKHQpeyFmdW5jdGlvbih0KXshZnVuY3Rpb24odCl7bGV0IGU7IWZ1bmN0aW9uKHQpe3RbdC5VTktOT1dOPTBdPVwiVU5LTk9XTlwiLHRbdC5WQUxVRT0xXT1cIlZBTFVFXCIsdFt0LlBBUkFNPTJdPVwiUEFSQU1cIn0oZT10LkRpbWVuc2lvblZhbHVlVHlwZXx8KHQuRGltZW5zaW9uVmFsdWVUeXBlPXt9KSl9KHQuZmJzfHwodC5mYnM9e30pKX0odC5leHBlcmltZW50YWx8fCh0LmV4cGVyaW1lbnRhbD17fSkpfShlLm9ubnhydW50aW1lfHwoZS5vbm54cnVudGltZT17fSkpLGZ1bmN0aW9uKHQpeyFmdW5jdGlvbih0KXshZnVuY3Rpb24odCl7bGV0IGU7IWZ1bmN0aW9uKHQpe3RbdC5VTkRFRklORUQ9MF09XCJVTkRFRklORURcIix0W3QuRkxPQVQ9MV09XCJGTE9BVFwiLHRbdC5VSU5UOD0yXT1cIlVJTlQ4XCIsdFt0LklOVDg9M109XCJJTlQ4XCIsdFt0LlVJTlQxNj00XT1cIlVJTlQxNlwiLHRbdC5JTlQxNj01XT1cIklOVDE2XCIsdFt0LklOVDMyPTZdPVwiSU5UMzJcIix0W3QuSU5UNjQ9N109XCJJTlQ2NFwiLHRbdC5TVFJJTkc9OF09XCJTVFJJTkdcIix0W3QuQk9PTD05XT1cIkJPT0xcIix0W3QuRkxPQVQxNj0xMF09XCJGTE9BVDE2XCIsdFt0LkRPVUJMRT0xMV09XCJET1VCTEVcIix0W3QuVUlOVDMyPTEyXT1cIlVJTlQzMlwiLHRbdC5VSU5UNjQ9MTNdPVwiVUlOVDY0XCIsdFt0LkNPTVBMRVg2ND0xNF09XCJDT01QTEVYNjRcIix0W3QuQ09NUExFWDEyOD0xNV09XCJDT01QTEVYMTI4XCIsdFt0LkJGTE9BVDE2PTE2XT1cIkJGTE9BVDE2XCJ9KGU9dC5UZW5zb3JEYXRhVHlwZXx8KHQuVGVuc29yRGF0YVR5cGU9e30pKX0odC5mYnN8fCh0LmZicz17fSkpfSh0LmV4cGVyaW1lbnRhbHx8KHQuZXhwZXJpbWVudGFsPXt9KSl9KGUub25ueHJ1bnRpbWV8fChlLm9ubnhydW50aW1lPXt9KSksZnVuY3Rpb24odCl7IWZ1bmN0aW9uKHQpeyFmdW5jdGlvbih0KXtsZXQgZTshZnVuY3Rpb24odCl7dFt0LlByaW1pdGl2ZT0wXT1cIlByaW1pdGl2ZVwiLHRbdC5GdXNlZD0xXT1cIkZ1c2VkXCJ9KGU9dC5Ob2RlVHlwZXx8KHQuTm9kZVR5cGU9e30pKX0odC5mYnN8fCh0LmZicz17fSkpfSh0LmV4cGVyaW1lbnRhbHx8KHQuZXhwZXJpbWVudGFsPXt9KSl9KGUub25ueHJ1bnRpbWV8fChlLm9ubnhydW50aW1lPXt9KSksZnVuY3Rpb24odCl7IWZ1bmN0aW9uKHQpeyFmdW5jdGlvbih0KXtsZXQgZTshZnVuY3Rpb24odCl7dFt0Lk5PTkU9MF09XCJOT05FXCIsdFt0LnRlbnNvcl90eXBlPTFdPVwidGVuc29yX3R5cGVcIix0W3Quc2VxdWVuY2VfdHlwZT0yXT1cInNlcXVlbmNlX3R5cGVcIix0W3QubWFwX3R5cGU9M109XCJtYXBfdHlwZVwifShlPXQuVHlwZUluZm9WYWx1ZXx8KHQuVHlwZUluZm9WYWx1ZT17fSkpfSh0LmZic3x8KHQuZmJzPXt9KSl9KHQuZXhwZXJpbWVudGFsfHwodC5leHBlcmltZW50YWw9e30pKX0oZS5vbm54cnVudGltZXx8KGUub25ueHJ1bnRpbWU9e30pKSxmdW5jdGlvbih0KXshZnVuY3Rpb24oZSl7IWZ1bmN0aW9uKGUpe2NsYXNzIG57Y29uc3RydWN0b3IoKXt0aGlzLmJiPW51bGwsdGhpcy5iYl9wb3M9MH1fX2luaXQodCxlKXtyZXR1cm4gdGhpcy5iYl9wb3M9dCx0aGlzLmJiPWUsdGhpc31zdGF0aWMgZ2V0Um9vdEFzU2hhcGUodCxlKXtyZXR1cm4oZXx8bmV3IG4pLl9faW5pdCh0LnJlYWRJbnQzMih0LnBvc2l0aW9uKCkpK3QucG9zaXRpb24oKSx0KX1zdGF0aWMgZ2V0U2l6ZVByZWZpeGVkUm9vdEFzU2hhcGUodCxlKXtyZXR1cm4gdC5zZXRQb3NpdGlvbih0LnBvc2l0aW9uKCkrci5mbGF0YnVmZmVycy5TSVpFX1BSRUZJWF9MRU5HVEgpLChlfHxuZXcgbikuX19pbml0KHQucmVhZEludDMyKHQucG9zaXRpb24oKSkrdC5wb3NpdGlvbigpLHQpfWRpbShlLG4pe2xldCByPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNCk7cmV0dXJuIHI/KG58fG5ldyB0LmV4cGVyaW1lbnRhbC5mYnMuRGltZW5zaW9uKS5fX2luaXQodGhpcy5iYi5fX2luZGlyZWN0KHRoaXMuYmIuX192ZWN0b3IodGhpcy5iYl9wb3MrcikrNCplKSx0aGlzLmJiKTpudWxsfWRpbUxlbmd0aCgpe2xldCB0PXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNCk7cmV0dXJuIHQ/dGhpcy5iYi5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MrdCk6MH1zdGF0aWMgc3RhcnRTaGFwZSh0KXt0LnN0YXJ0T2JqZWN0KDEpfXN0YXRpYyBhZGREaW0odCxlKXt0LmFkZEZpZWxkT2Zmc2V0KDAsZSwwKX1zdGF0aWMgY3JlYXRlRGltVmVjdG9yKHQsZSl7dC5zdGFydFZlY3Rvcig0LGUubGVuZ3RoLDQpO2ZvcihsZXQgbj1lLmxlbmd0aC0xO24+PTA7bi0tKXQuYWRkT2Zmc2V0KGVbbl0pO3JldHVybiB0LmVuZFZlY3RvcigpfXN0YXRpYyBzdGFydERpbVZlY3Rvcih0LGUpe3Quc3RhcnRWZWN0b3IoNCxlLDQpfXN0YXRpYyBlbmRTaGFwZSh0KXtyZXR1cm4gdC5lbmRPYmplY3QoKX1zdGF0aWMgY3JlYXRlU2hhcGUodCxlKXtyZXR1cm4gbi5zdGFydFNoYXBlKHQpLG4uYWRkRGltKHQsZSksbi5lbmRTaGFwZSh0KX19ZS5TaGFwZT1ufShlLmZic3x8KGUuZmJzPXt9KSl9KHQuZXhwZXJpbWVudGFsfHwodC5leHBlcmltZW50YWw9e30pKX0oZS5vbm54cnVudGltZXx8KGUub25ueHJ1bnRpbWU9e30pKSxmdW5jdGlvbih0KXshZnVuY3Rpb24oZSl7IWZ1bmN0aW9uKGUpe2NsYXNzIG57Y29uc3RydWN0b3IoKXt0aGlzLmJiPW51bGwsdGhpcy5iYl9wb3M9MH1fX2luaXQodCxlKXtyZXR1cm4gdGhpcy5iYl9wb3M9dCx0aGlzLmJiPWUsdGhpc31zdGF0aWMgZ2V0Um9vdEFzRGltZW5zaW9uKHQsZSl7cmV0dXJuKGV8fG5ldyBuKS5fX2luaXQodC5yZWFkSW50MzIodC5wb3NpdGlvbigpKSt0LnBvc2l0aW9uKCksdCl9c3RhdGljIGdldFNpemVQcmVmaXhlZFJvb3RBc0RpbWVuc2lvbih0LGUpe3JldHVybiB0LnNldFBvc2l0aW9uKHQucG9zaXRpb24oKStyLmZsYXRidWZmZXJzLlNJWkVfUFJFRklYX0xFTkdUSCksKGV8fG5ldyBuKS5fX2luaXQodC5yZWFkSW50MzIodC5wb3NpdGlvbigpKSt0LnBvc2l0aW9uKCksdCl9dmFsdWUoZSl7bGV0IG49dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw0KTtyZXR1cm4gbj8oZXx8bmV3IHQuZXhwZXJpbWVudGFsLmZicy5EaW1lbnNpb25WYWx1ZSkuX19pbml0KHRoaXMuYmIuX19pbmRpcmVjdCh0aGlzLmJiX3BvcytuKSx0aGlzLmJiKTpudWxsfWRlbm90YXRpb24odCl7bGV0IGU9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw2KTtyZXR1cm4gZT90aGlzLmJiLl9fc3RyaW5nKHRoaXMuYmJfcG9zK2UsdCk6bnVsbH1zdGF0aWMgc3RhcnREaW1lbnNpb24odCl7dC5zdGFydE9iamVjdCgyKX1zdGF0aWMgYWRkVmFsdWUodCxlKXt0LmFkZEZpZWxkT2Zmc2V0KDAsZSwwKX1zdGF0aWMgYWRkRGVub3RhdGlvbih0LGUpe3QuYWRkRmllbGRPZmZzZXQoMSxlLDApfXN0YXRpYyBlbmREaW1lbnNpb24odCl7cmV0dXJuIHQuZW5kT2JqZWN0KCl9c3RhdGljIGNyZWF0ZURpbWVuc2lvbih0LGUscil7cmV0dXJuIG4uc3RhcnREaW1lbnNpb24odCksbi5hZGRWYWx1ZSh0LGUpLG4uYWRkRGVub3RhdGlvbih0LHIpLG4uZW5kRGltZW5zaW9uKHQpfX1lLkRpbWVuc2lvbj1ufShlLmZic3x8KGUuZmJzPXt9KSl9KHQuZXhwZXJpbWVudGFsfHwodC5leHBlcmltZW50YWw9e30pKX0oZS5vbm54cnVudGltZXx8KGUub25ueHJ1bnRpbWU9e30pKSxmdW5jdGlvbih0KXshZnVuY3Rpb24oZSl7IWZ1bmN0aW9uKGUpe2NsYXNzIG57Y29uc3RydWN0b3IoKXt0aGlzLmJiPW51bGwsdGhpcy5iYl9wb3M9MH1fX2luaXQodCxlKXtyZXR1cm4gdGhpcy5iYl9wb3M9dCx0aGlzLmJiPWUsdGhpc31zdGF0aWMgZ2V0Um9vdEFzRGltZW5zaW9uVmFsdWUodCxlKXtyZXR1cm4oZXx8bmV3IG4pLl9faW5pdCh0LnJlYWRJbnQzMih0LnBvc2l0aW9uKCkpK3QucG9zaXRpb24oKSx0KX1zdGF0aWMgZ2V0U2l6ZVByZWZpeGVkUm9vdEFzRGltZW5zaW9uVmFsdWUodCxlKXtyZXR1cm4gdC5zZXRQb3NpdGlvbih0LnBvc2l0aW9uKCkrci5mbGF0YnVmZmVycy5TSVpFX1BSRUZJWF9MRU5HVEgpLChlfHxuZXcgbikuX19pbml0KHQucmVhZEludDMyKHQucG9zaXRpb24oKSkrdC5wb3NpdGlvbigpLHQpfWRpbVR5cGUoKXtsZXQgZT10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDQpO3JldHVybiBlP3RoaXMuYmIucmVhZEludDgodGhpcy5iYl9wb3MrZSk6dC5leHBlcmltZW50YWwuZmJzLkRpbWVuc2lvblZhbHVlVHlwZS5VTktOT1dOfWRpbVZhbHVlKCl7bGV0IHQ9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw2KTtyZXR1cm4gdD90aGlzLmJiLnJlYWRJbnQ2NCh0aGlzLmJiX3Bvcyt0KTp0aGlzLmJiLmNyZWF0ZUxvbmcoMCwwKX1kaW1QYXJhbSh0KXtsZXQgZT10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDgpO3JldHVybiBlP3RoaXMuYmIuX19zdHJpbmcodGhpcy5iYl9wb3MrZSx0KTpudWxsfXN0YXRpYyBzdGFydERpbWVuc2lvblZhbHVlKHQpe3Quc3RhcnRPYmplY3QoMyl9c3RhdGljIGFkZERpbVR5cGUoZSxuKXtlLmFkZEZpZWxkSW50OCgwLG4sdC5leHBlcmltZW50YWwuZmJzLkRpbWVuc2lvblZhbHVlVHlwZS5VTktOT1dOKX1zdGF0aWMgYWRkRGltVmFsdWUodCxlKXt0LmFkZEZpZWxkSW50NjQoMSxlLHQuY3JlYXRlTG9uZygwLDApKX1zdGF0aWMgYWRkRGltUGFyYW0odCxlKXt0LmFkZEZpZWxkT2Zmc2V0KDIsZSwwKX1zdGF0aWMgZW5kRGltZW5zaW9uVmFsdWUodCl7cmV0dXJuIHQuZW5kT2JqZWN0KCl9c3RhdGljIGNyZWF0ZURpbWVuc2lvblZhbHVlKHQsZSxyLGkpe3JldHVybiBuLnN0YXJ0RGltZW5zaW9uVmFsdWUodCksbi5hZGREaW1UeXBlKHQsZSksbi5hZGREaW1WYWx1ZSh0LHIpLG4uYWRkRGltUGFyYW0odCxpKSxuLmVuZERpbWVuc2lvblZhbHVlKHQpfX1lLkRpbWVuc2lvblZhbHVlPW59KGUuZmJzfHwoZS5mYnM9e30pKX0odC5leHBlcmltZW50YWx8fCh0LmV4cGVyaW1lbnRhbD17fSkpfShlLm9ubnhydW50aW1lfHwoZS5vbm54cnVudGltZT17fSkpLGZ1bmN0aW9uKHQpeyFmdW5jdGlvbihlKXshZnVuY3Rpb24oZSl7Y2xhc3Mgbntjb25zdHJ1Y3Rvcigpe3RoaXMuYmI9bnVsbCx0aGlzLmJiX3Bvcz0wfV9faW5pdCh0LGUpe3JldHVybiB0aGlzLmJiX3Bvcz10LHRoaXMuYmI9ZSx0aGlzfXN0YXRpYyBnZXRSb290QXNUZW5zb3JUeXBlQW5kU2hhcGUodCxlKXtyZXR1cm4oZXx8bmV3IG4pLl9faW5pdCh0LnJlYWRJbnQzMih0LnBvc2l0aW9uKCkpK3QucG9zaXRpb24oKSx0KX1zdGF0aWMgZ2V0U2l6ZVByZWZpeGVkUm9vdEFzVGVuc29yVHlwZUFuZFNoYXBlKHQsZSl7cmV0dXJuIHQuc2V0UG9zaXRpb24odC5wb3NpdGlvbigpK3IuZmxhdGJ1ZmZlcnMuU0laRV9QUkVGSVhfTEVOR1RIKSwoZXx8bmV3IG4pLl9faW5pdCh0LnJlYWRJbnQzMih0LnBvc2l0aW9uKCkpK3QucG9zaXRpb24oKSx0KX1lbGVtVHlwZSgpe2xldCBlPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNCk7cmV0dXJuIGU/dGhpcy5iYi5yZWFkSW50MzIodGhpcy5iYl9wb3MrZSk6dC5leHBlcmltZW50YWwuZmJzLlRlbnNvckRhdGFUeXBlLlVOREVGSU5FRH1zaGFwZShlKXtsZXQgbj10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDYpO3JldHVybiBuPyhlfHxuZXcgdC5leHBlcmltZW50YWwuZmJzLlNoYXBlKS5fX2luaXQodGhpcy5iYi5fX2luZGlyZWN0KHRoaXMuYmJfcG9zK24pLHRoaXMuYmIpOm51bGx9c3RhdGljIHN0YXJ0VGVuc29yVHlwZUFuZFNoYXBlKHQpe3Quc3RhcnRPYmplY3QoMil9c3RhdGljIGFkZEVsZW1UeXBlKGUsbil7ZS5hZGRGaWVsZEludDMyKDAsbix0LmV4cGVyaW1lbnRhbC5mYnMuVGVuc29yRGF0YVR5cGUuVU5ERUZJTkVEKX1zdGF0aWMgYWRkU2hhcGUodCxlKXt0LmFkZEZpZWxkT2Zmc2V0KDEsZSwwKX1zdGF0aWMgZW5kVGVuc29yVHlwZUFuZFNoYXBlKHQpe3JldHVybiB0LmVuZE9iamVjdCgpfXN0YXRpYyBjcmVhdGVUZW5zb3JUeXBlQW5kU2hhcGUodCxlLHIpe3JldHVybiBuLnN0YXJ0VGVuc29yVHlwZUFuZFNoYXBlKHQpLG4uYWRkRWxlbVR5cGUodCxlKSxuLmFkZFNoYXBlKHQsciksbi5lbmRUZW5zb3JUeXBlQW5kU2hhcGUodCl9fWUuVGVuc29yVHlwZUFuZFNoYXBlPW59KGUuZmJzfHwoZS5mYnM9e30pKX0odC5leHBlcmltZW50YWx8fCh0LmV4cGVyaW1lbnRhbD17fSkpfShlLm9ubnhydW50aW1lfHwoZS5vbm54cnVudGltZT17fSkpLGZ1bmN0aW9uKHQpeyFmdW5jdGlvbihlKXshZnVuY3Rpb24oZSl7Y2xhc3Mgbntjb25zdHJ1Y3Rvcigpe3RoaXMuYmI9bnVsbCx0aGlzLmJiX3Bvcz0wfV9faW5pdCh0LGUpe3JldHVybiB0aGlzLmJiX3Bvcz10LHRoaXMuYmI9ZSx0aGlzfXN0YXRpYyBnZXRSb290QXNNYXBUeXBlKHQsZSl7cmV0dXJuKGV8fG5ldyBuKS5fX2luaXQodC5yZWFkSW50MzIodC5wb3NpdGlvbigpKSt0LnBvc2l0aW9uKCksdCl9c3RhdGljIGdldFNpemVQcmVmaXhlZFJvb3RBc01hcFR5cGUodCxlKXtyZXR1cm4gdC5zZXRQb3NpdGlvbih0LnBvc2l0aW9uKCkrci5mbGF0YnVmZmVycy5TSVpFX1BSRUZJWF9MRU5HVEgpLChlfHxuZXcgbikuX19pbml0KHQucmVhZEludDMyKHQucG9zaXRpb24oKSkrdC5wb3NpdGlvbigpLHQpfWtleVR5cGUoKXtsZXQgZT10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDQpO3JldHVybiBlP3RoaXMuYmIucmVhZEludDMyKHRoaXMuYmJfcG9zK2UpOnQuZXhwZXJpbWVudGFsLmZicy5UZW5zb3JEYXRhVHlwZS5VTkRFRklORUR9dmFsdWVUeXBlKGUpe2xldCBuPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNik7cmV0dXJuIG4/KGV8fG5ldyB0LmV4cGVyaW1lbnRhbC5mYnMuVHlwZUluZm8pLl9faW5pdCh0aGlzLmJiLl9faW5kaXJlY3QodGhpcy5iYl9wb3MrbiksdGhpcy5iYik6bnVsbH1zdGF0aWMgc3RhcnRNYXBUeXBlKHQpe3Quc3RhcnRPYmplY3QoMil9c3RhdGljIGFkZEtleVR5cGUoZSxuKXtlLmFkZEZpZWxkSW50MzIoMCxuLHQuZXhwZXJpbWVudGFsLmZicy5UZW5zb3JEYXRhVHlwZS5VTkRFRklORUQpfXN0YXRpYyBhZGRWYWx1ZVR5cGUodCxlKXt0LmFkZEZpZWxkT2Zmc2V0KDEsZSwwKX1zdGF0aWMgZW5kTWFwVHlwZSh0KXtyZXR1cm4gdC5lbmRPYmplY3QoKX1zdGF0aWMgY3JlYXRlTWFwVHlwZSh0LGUscil7cmV0dXJuIG4uc3RhcnRNYXBUeXBlKHQpLG4uYWRkS2V5VHlwZSh0LGUpLG4uYWRkVmFsdWVUeXBlKHQsciksbi5lbmRNYXBUeXBlKHQpfX1lLk1hcFR5cGU9bn0oZS5mYnN8fChlLmZicz17fSkpfSh0LmV4cGVyaW1lbnRhbHx8KHQuZXhwZXJpbWVudGFsPXt9KSl9KGUub25ueHJ1bnRpbWV8fChlLm9ubnhydW50aW1lPXt9KSksZnVuY3Rpb24odCl7IWZ1bmN0aW9uKGUpeyFmdW5jdGlvbihlKXtjbGFzcyBue2NvbnN0cnVjdG9yKCl7dGhpcy5iYj1udWxsLHRoaXMuYmJfcG9zPTB9X19pbml0KHQsZSl7cmV0dXJuIHRoaXMuYmJfcG9zPXQsdGhpcy5iYj1lLHRoaXN9c3RhdGljIGdldFJvb3RBc1NlcXVlbmNlVHlwZSh0LGUpe3JldHVybihlfHxuZXcgbikuX19pbml0KHQucmVhZEludDMyKHQucG9zaXRpb24oKSkrdC5wb3NpdGlvbigpLHQpfXN0YXRpYyBnZXRTaXplUHJlZml4ZWRSb290QXNTZXF1ZW5jZVR5cGUodCxlKXtyZXR1cm4gdC5zZXRQb3NpdGlvbih0LnBvc2l0aW9uKCkrci5mbGF0YnVmZmVycy5TSVpFX1BSRUZJWF9MRU5HVEgpLChlfHxuZXcgbikuX19pbml0KHQucmVhZEludDMyKHQucG9zaXRpb24oKSkrdC5wb3NpdGlvbigpLHQpfWVsZW1UeXBlKGUpe2xldCBuPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNCk7cmV0dXJuIG4/KGV8fG5ldyB0LmV4cGVyaW1lbnRhbC5mYnMuVHlwZUluZm8pLl9faW5pdCh0aGlzLmJiLl9faW5kaXJlY3QodGhpcy5iYl9wb3MrbiksdGhpcy5iYik6bnVsbH1zdGF0aWMgc3RhcnRTZXF1ZW5jZVR5cGUodCl7dC5zdGFydE9iamVjdCgxKX1zdGF0aWMgYWRkRWxlbVR5cGUodCxlKXt0LmFkZEZpZWxkT2Zmc2V0KDAsZSwwKX1zdGF0aWMgZW5kU2VxdWVuY2VUeXBlKHQpe3JldHVybiB0LmVuZE9iamVjdCgpfXN0YXRpYyBjcmVhdGVTZXF1ZW5jZVR5cGUodCxlKXtyZXR1cm4gbi5zdGFydFNlcXVlbmNlVHlwZSh0KSxuLmFkZEVsZW1UeXBlKHQsZSksbi5lbmRTZXF1ZW5jZVR5cGUodCl9fWUuU2VxdWVuY2VUeXBlPW59KGUuZmJzfHwoZS5mYnM9e30pKX0odC5leHBlcmltZW50YWx8fCh0LmV4cGVyaW1lbnRhbD17fSkpfShlLm9ubnhydW50aW1lfHwoZS5vbm54cnVudGltZT17fSkpLGZ1bmN0aW9uKHQpeyFmdW5jdGlvbih0KXsodC5mYnN8fCh0LmZicz17fSkpLkVkZ2VFbmQ9Y2xhc3N7Y29uc3RydWN0b3IoKXt0aGlzLmJiPW51bGwsdGhpcy5iYl9wb3M9MH1fX2luaXQodCxlKXtyZXR1cm4gdGhpcy5iYl9wb3M9dCx0aGlzLmJiPWUsdGhpc31ub2RlSW5kZXgoKXtyZXR1cm4gdGhpcy5iYi5yZWFkVWludDMyKHRoaXMuYmJfcG9zKX1zcmNBcmdJbmRleCgpe3JldHVybiB0aGlzLmJiLnJlYWRJbnQzMih0aGlzLmJiX3Bvcys0KX1kc3RBcmdJbmRleCgpe3JldHVybiB0aGlzLmJiLnJlYWRJbnQzMih0aGlzLmJiX3Bvcys4KX1zdGF0aWMgY3JlYXRlRWRnZUVuZCh0LGUsbixyKXtyZXR1cm4gdC5wcmVwKDQsMTIpLHQud3JpdGVJbnQzMihyKSx0LndyaXRlSW50MzIobiksdC53cml0ZUludDMyKGUpLHQub2Zmc2V0KCl9fX0odC5leHBlcmltZW50YWx8fCh0LmV4cGVyaW1lbnRhbD17fSkpfShlLm9ubnhydW50aW1lfHwoZS5vbm54cnVudGltZT17fSkpLGZ1bmN0aW9uKHQpeyFmdW5jdGlvbihlKXshZnVuY3Rpb24oZSl7Y2xhc3Mgbntjb25zdHJ1Y3Rvcigpe3RoaXMuYmI9bnVsbCx0aGlzLmJiX3Bvcz0wfV9faW5pdCh0LGUpe3JldHVybiB0aGlzLmJiX3Bvcz10LHRoaXMuYmI9ZSx0aGlzfXN0YXRpYyBnZXRSb290QXNOb2RlRWRnZSh0LGUpe3JldHVybihlfHxuZXcgbikuX19pbml0KHQucmVhZEludDMyKHQucG9zaXRpb24oKSkrdC5wb3NpdGlvbigpLHQpfXN0YXRpYyBnZXRTaXplUHJlZml4ZWRSb290QXNOb2RlRWRnZSh0LGUpe3JldHVybiB0LnNldFBvc2l0aW9uKHQucG9zaXRpb24oKStyLmZsYXRidWZmZXJzLlNJWkVfUFJFRklYX0xFTkdUSCksKGV8fG5ldyBuKS5fX2luaXQodC5yZWFkSW50MzIodC5wb3NpdGlvbigpKSt0LnBvc2l0aW9uKCksdCl9bm9kZUluZGV4KCl7bGV0IHQ9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw0KTtyZXR1cm4gdD90aGlzLmJiLnJlYWRVaW50MzIodGhpcy5iYl9wb3MrdCk6MH1pbnB1dEVkZ2VzKGUsbil7bGV0IHI9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw2KTtyZXR1cm4gcj8obnx8bmV3IHQuZXhwZXJpbWVudGFsLmZicy5FZGdlRW5kKS5fX2luaXQodGhpcy5iYi5fX3ZlY3Rvcih0aGlzLmJiX3BvcytyKSsxMiplLHRoaXMuYmIpOm51bGx9aW5wdXRFZGdlc0xlbmd0aCgpe2xldCB0PXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNik7cmV0dXJuIHQ/dGhpcy5iYi5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MrdCk6MH1vdXRwdXRFZGdlcyhlLG4pe2xldCByPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsOCk7cmV0dXJuIHI/KG58fG5ldyB0LmV4cGVyaW1lbnRhbC5mYnMuRWRnZUVuZCkuX19pbml0KHRoaXMuYmIuX192ZWN0b3IodGhpcy5iYl9wb3MrcikrMTIqZSx0aGlzLmJiKTpudWxsfW91dHB1dEVkZ2VzTGVuZ3RoKCl7bGV0IHQ9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw4KTtyZXR1cm4gdD90aGlzLmJiLl9fdmVjdG9yX2xlbih0aGlzLmJiX3Bvcyt0KTowfXN0YXRpYyBzdGFydE5vZGVFZGdlKHQpe3Quc3RhcnRPYmplY3QoMyl9c3RhdGljIGFkZE5vZGVJbmRleCh0LGUpe3QuYWRkRmllbGRJbnQzMigwLGUsMCl9c3RhdGljIGFkZElucHV0RWRnZXModCxlKXt0LmFkZEZpZWxkT2Zmc2V0KDEsZSwwKX1zdGF0aWMgc3RhcnRJbnB1dEVkZ2VzVmVjdG9yKHQsZSl7dC5zdGFydFZlY3RvcigxMixlLDQpfXN0YXRpYyBhZGRPdXRwdXRFZGdlcyh0LGUpe3QuYWRkRmllbGRPZmZzZXQoMixlLDApfXN0YXRpYyBzdGFydE91dHB1dEVkZ2VzVmVjdG9yKHQsZSl7dC5zdGFydFZlY3RvcigxMixlLDQpfXN0YXRpYyBlbmROb2RlRWRnZSh0KXtyZXR1cm4gdC5lbmRPYmplY3QoKX1zdGF0aWMgY3JlYXRlTm9kZUVkZ2UodCxlLHIsaSl7cmV0dXJuIG4uc3RhcnROb2RlRWRnZSh0KSxuLmFkZE5vZGVJbmRleCh0LGUpLG4uYWRkSW5wdXRFZGdlcyh0LHIpLG4uYWRkT3V0cHV0RWRnZXModCxpKSxuLmVuZE5vZGVFZGdlKHQpfX1lLk5vZGVFZGdlPW59KGUuZmJzfHwoZS5mYnM9e30pKX0odC5leHBlcmltZW50YWx8fCh0LmV4cGVyaW1lbnRhbD17fSkpfShlLm9ubnhydW50aW1lfHwoZS5vbm54cnVudGltZT17fSkpLGZ1bmN0aW9uKHQpeyFmdW5jdGlvbihlKXshZnVuY3Rpb24oZSl7Y2xhc3Mgbntjb25zdHJ1Y3Rvcigpe3RoaXMuYmI9bnVsbCx0aGlzLmJiX3Bvcz0wfV9faW5pdCh0LGUpe3JldHVybiB0aGlzLmJiX3Bvcz10LHRoaXMuYmI9ZSx0aGlzfXN0YXRpYyBnZXRSb290QXNOb2RlKHQsZSl7cmV0dXJuKGV8fG5ldyBuKS5fX2luaXQodC5yZWFkSW50MzIodC5wb3NpdGlvbigpKSt0LnBvc2l0aW9uKCksdCl9c3RhdGljIGdldFNpemVQcmVmaXhlZFJvb3RBc05vZGUodCxlKXtyZXR1cm4gdC5zZXRQb3NpdGlvbih0LnBvc2l0aW9uKCkrci5mbGF0YnVmZmVycy5TSVpFX1BSRUZJWF9MRU5HVEgpLChlfHxuZXcgbikuX19pbml0KHQucmVhZEludDMyKHQucG9zaXRpb24oKSkrdC5wb3NpdGlvbigpLHQpfW5hbWUodCl7bGV0IGU9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw0KTtyZXR1cm4gZT90aGlzLmJiLl9fc3RyaW5nKHRoaXMuYmJfcG9zK2UsdCk6bnVsbH1kb2NTdHJpbmcodCl7bGV0IGU9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw2KTtyZXR1cm4gZT90aGlzLmJiLl9fc3RyaW5nKHRoaXMuYmJfcG9zK2UsdCk6bnVsbH1kb21haW4odCl7bGV0IGU9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw4KTtyZXR1cm4gZT90aGlzLmJiLl9fc3RyaW5nKHRoaXMuYmJfcG9zK2UsdCk6bnVsbH1zaW5jZVZlcnNpb24oKXtsZXQgdD10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDEwKTtyZXR1cm4gdD90aGlzLmJiLnJlYWRJbnQzMih0aGlzLmJiX3Bvcyt0KTowfWluZGV4KCl7bGV0IHQ9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3BvcywxMik7cmV0dXJuIHQ/dGhpcy5iYi5yZWFkVWludDMyKHRoaXMuYmJfcG9zK3QpOjB9b3BUeXBlKHQpe2xldCBlPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsMTQpO3JldHVybiBlP3RoaXMuYmIuX19zdHJpbmcodGhpcy5iYl9wb3MrZSx0KTpudWxsfXR5cGUoKXtsZXQgZT10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDE2KTtyZXR1cm4gZT90aGlzLmJiLnJlYWRJbnQzMih0aGlzLmJiX3BvcytlKTp0LmV4cGVyaW1lbnRhbC5mYnMuTm9kZVR5cGUuUHJpbWl0aXZlfWV4ZWN1dGlvblByb3ZpZGVyVHlwZSh0KXtsZXQgZT10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDE4KTtyZXR1cm4gZT90aGlzLmJiLl9fc3RyaW5nKHRoaXMuYmJfcG9zK2UsdCk6bnVsbH1pbnB1dHModCxlKXtsZXQgbj10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDIwKTtyZXR1cm4gbj90aGlzLmJiLl9fc3RyaW5nKHRoaXMuYmIuX192ZWN0b3IodGhpcy5iYl9wb3MrbikrNCp0LGUpOm51bGx9aW5wdXRzTGVuZ3RoKCl7bGV0IHQ9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3BvcywyMCk7cmV0dXJuIHQ/dGhpcy5iYi5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MrdCk6MH1vdXRwdXRzKHQsZSl7bGV0IG49dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3BvcywyMik7cmV0dXJuIG4/dGhpcy5iYi5fX3N0cmluZyh0aGlzLmJiLl9fdmVjdG9yKHRoaXMuYmJfcG9zK24pKzQqdCxlKTpudWxsfW91dHB1dHNMZW5ndGgoKXtsZXQgdD10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDIyKTtyZXR1cm4gdD90aGlzLmJiLl9fdmVjdG9yX2xlbih0aGlzLmJiX3Bvcyt0KTowfWF0dHJpYnV0ZXMoZSxuKXtsZXQgcj10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDI0KTtyZXR1cm4gcj8obnx8bmV3IHQuZXhwZXJpbWVudGFsLmZicy5BdHRyaWJ1dGUpLl9faW5pdCh0aGlzLmJiLl9faW5kaXJlY3QodGhpcy5iYi5fX3ZlY3Rvcih0aGlzLmJiX3BvcytyKSs0KmUpLHRoaXMuYmIpOm51bGx9YXR0cmlidXRlc0xlbmd0aCgpe2xldCB0PXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsMjQpO3JldHVybiB0P3RoaXMuYmIuX192ZWN0b3JfbGVuKHRoaXMuYmJfcG9zK3QpOjB9aW5wdXRBcmdDb3VudHModCl7bGV0IGU9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3BvcywyNik7cmV0dXJuIGU/dGhpcy5iYi5yZWFkSW50MzIodGhpcy5iYi5fX3ZlY3Rvcih0aGlzLmJiX3BvcytlKSs0KnQpOjB9aW5wdXRBcmdDb3VudHNMZW5ndGgoKXtsZXQgdD10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDI2KTtyZXR1cm4gdD90aGlzLmJiLl9fdmVjdG9yX2xlbih0aGlzLmJiX3Bvcyt0KTowfWlucHV0QXJnQ291bnRzQXJyYXkoKXtsZXQgdD10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDI2KTtyZXR1cm4gdD9uZXcgSW50MzJBcnJheSh0aGlzLmJiLmJ5dGVzKCkuYnVmZmVyLHRoaXMuYmIuYnl0ZXMoKS5ieXRlT2Zmc2V0K3RoaXMuYmIuX192ZWN0b3IodGhpcy5iYl9wb3MrdCksdGhpcy5iYi5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MrdCkpOm51bGx9aW1wbGljaXRJbnB1dHModCxlKXtsZXQgbj10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDI4KTtyZXR1cm4gbj90aGlzLmJiLl9fc3RyaW5nKHRoaXMuYmIuX192ZWN0b3IodGhpcy5iYl9wb3MrbikrNCp0LGUpOm51bGx9aW1wbGljaXRJbnB1dHNMZW5ndGgoKXtsZXQgdD10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDI4KTtyZXR1cm4gdD90aGlzLmJiLl9fdmVjdG9yX2xlbih0aGlzLmJiX3Bvcyt0KTowfXN0YXRpYyBzdGFydE5vZGUodCl7dC5zdGFydE9iamVjdCgxMyl9c3RhdGljIGFkZE5hbWUodCxlKXt0LmFkZEZpZWxkT2Zmc2V0KDAsZSwwKX1zdGF0aWMgYWRkRG9jU3RyaW5nKHQsZSl7dC5hZGRGaWVsZE9mZnNldCgxLGUsMCl9c3RhdGljIGFkZERvbWFpbih0LGUpe3QuYWRkRmllbGRPZmZzZXQoMixlLDApfXN0YXRpYyBhZGRTaW5jZVZlcnNpb24odCxlKXt0LmFkZEZpZWxkSW50MzIoMyxlLDApfXN0YXRpYyBhZGRJbmRleCh0LGUpe3QuYWRkRmllbGRJbnQzMig0LGUsMCl9c3RhdGljIGFkZE9wVHlwZSh0LGUpe3QuYWRkRmllbGRPZmZzZXQoNSxlLDApfXN0YXRpYyBhZGRUeXBlKGUsbil7ZS5hZGRGaWVsZEludDMyKDYsbix0LmV4cGVyaW1lbnRhbC5mYnMuTm9kZVR5cGUuUHJpbWl0aXZlKX1zdGF0aWMgYWRkRXhlY3V0aW9uUHJvdmlkZXJUeXBlKHQsZSl7dC5hZGRGaWVsZE9mZnNldCg3LGUsMCl9c3RhdGljIGFkZElucHV0cyh0LGUpe3QuYWRkRmllbGRPZmZzZXQoOCxlLDApfXN0YXRpYyBjcmVhdGVJbnB1dHNWZWN0b3IodCxlKXt0LnN0YXJ0VmVjdG9yKDQsZS5sZW5ndGgsNCk7Zm9yKGxldCBuPWUubGVuZ3RoLTE7bj49MDtuLS0pdC5hZGRPZmZzZXQoZVtuXSk7cmV0dXJuIHQuZW5kVmVjdG9yKCl9c3RhdGljIHN0YXJ0SW5wdXRzVmVjdG9yKHQsZSl7dC5zdGFydFZlY3Rvcig0LGUsNCl9c3RhdGljIGFkZE91dHB1dHModCxlKXt0LmFkZEZpZWxkT2Zmc2V0KDksZSwwKX1zdGF0aWMgY3JlYXRlT3V0cHV0c1ZlY3Rvcih0LGUpe3Quc3RhcnRWZWN0b3IoNCxlLmxlbmd0aCw0KTtmb3IobGV0IG49ZS5sZW5ndGgtMTtuPj0wO24tLSl0LmFkZE9mZnNldChlW25dKTtyZXR1cm4gdC5lbmRWZWN0b3IoKX1zdGF0aWMgc3RhcnRPdXRwdXRzVmVjdG9yKHQsZSl7dC5zdGFydFZlY3Rvcig0LGUsNCl9c3RhdGljIGFkZEF0dHJpYnV0ZXModCxlKXt0LmFkZEZpZWxkT2Zmc2V0KDEwLGUsMCl9c3RhdGljIGNyZWF0ZUF0dHJpYnV0ZXNWZWN0b3IodCxlKXt0LnN0YXJ0VmVjdG9yKDQsZS5sZW5ndGgsNCk7Zm9yKGxldCBuPWUubGVuZ3RoLTE7bj49MDtuLS0pdC5hZGRPZmZzZXQoZVtuXSk7cmV0dXJuIHQuZW5kVmVjdG9yKCl9c3RhdGljIHN0YXJ0QXR0cmlidXRlc1ZlY3Rvcih0LGUpe3Quc3RhcnRWZWN0b3IoNCxlLDQpfXN0YXRpYyBhZGRJbnB1dEFyZ0NvdW50cyh0LGUpe3QuYWRkRmllbGRPZmZzZXQoMTEsZSwwKX1zdGF0aWMgY3JlYXRlSW5wdXRBcmdDb3VudHNWZWN0b3IodCxlKXt0LnN0YXJ0VmVjdG9yKDQsZS5sZW5ndGgsNCk7Zm9yKGxldCBuPWUubGVuZ3RoLTE7bj49MDtuLS0pdC5hZGRJbnQzMihlW25dKTtyZXR1cm4gdC5lbmRWZWN0b3IoKX1zdGF0aWMgc3RhcnRJbnB1dEFyZ0NvdW50c1ZlY3Rvcih0LGUpe3Quc3RhcnRWZWN0b3IoNCxlLDQpfXN0YXRpYyBhZGRJbXBsaWNpdElucHV0cyh0LGUpe3QuYWRkRmllbGRPZmZzZXQoMTIsZSwwKX1zdGF0aWMgY3JlYXRlSW1wbGljaXRJbnB1dHNWZWN0b3IodCxlKXt0LnN0YXJ0VmVjdG9yKDQsZS5sZW5ndGgsNCk7Zm9yKGxldCBuPWUubGVuZ3RoLTE7bj49MDtuLS0pdC5hZGRPZmZzZXQoZVtuXSk7cmV0dXJuIHQuZW5kVmVjdG9yKCl9c3RhdGljIHN0YXJ0SW1wbGljaXRJbnB1dHNWZWN0b3IodCxlKXt0LnN0YXJ0VmVjdG9yKDQsZSw0KX1zdGF0aWMgZW5kTm9kZSh0KXtyZXR1cm4gdC5lbmRPYmplY3QoKX1zdGF0aWMgY3JlYXRlTm9kZSh0LGUscixpLG8sYSxzLHUsYyxsLHAsZixkLGgpe3JldHVybiBuLnN0YXJ0Tm9kZSh0KSxuLmFkZE5hbWUodCxlKSxuLmFkZERvY1N0cmluZyh0LHIpLG4uYWRkRG9tYWluKHQsaSksbi5hZGRTaW5jZVZlcnNpb24odCxvKSxuLmFkZEluZGV4KHQsYSksbi5hZGRPcFR5cGUodCxzKSxuLmFkZFR5cGUodCx1KSxuLmFkZEV4ZWN1dGlvblByb3ZpZGVyVHlwZSh0LGMpLG4uYWRkSW5wdXRzKHQsbCksbi5hZGRPdXRwdXRzKHQscCksbi5hZGRBdHRyaWJ1dGVzKHQsZiksbi5hZGRJbnB1dEFyZ0NvdW50cyh0LGQpLG4uYWRkSW1wbGljaXRJbnB1dHModCxoKSxuLmVuZE5vZGUodCl9fWUuTm9kZT1ufShlLmZic3x8KGUuZmJzPXt9KSl9KHQuZXhwZXJpbWVudGFsfHwodC5leHBlcmltZW50YWw9e30pKX0oZS5vbm54cnVudGltZXx8KGUub25ueHJ1bnRpbWU9e30pKSxmdW5jdGlvbih0KXshZnVuY3Rpb24oZSl7IWZ1bmN0aW9uKGUpe2NsYXNzIG57Y29uc3RydWN0b3IoKXt0aGlzLmJiPW51bGwsdGhpcy5iYl9wb3M9MH1fX2luaXQodCxlKXtyZXR1cm4gdGhpcy5iYl9wb3M9dCx0aGlzLmJiPWUsdGhpc31zdGF0aWMgZ2V0Um9vdEFzVmFsdWVJbmZvKHQsZSl7cmV0dXJuKGV8fG5ldyBuKS5fX2luaXQodC5yZWFkSW50MzIodC5wb3NpdGlvbigpKSt0LnBvc2l0aW9uKCksdCl9c3RhdGljIGdldFNpemVQcmVmaXhlZFJvb3RBc1ZhbHVlSW5mbyh0LGUpe3JldHVybiB0LnNldFBvc2l0aW9uKHQucG9zaXRpb24oKStyLmZsYXRidWZmZXJzLlNJWkVfUFJFRklYX0xFTkdUSCksKGV8fG5ldyBuKS5fX2luaXQodC5yZWFkSW50MzIodC5wb3NpdGlvbigpKSt0LnBvc2l0aW9uKCksdCl9bmFtZSh0KXtsZXQgZT10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDQpO3JldHVybiBlP3RoaXMuYmIuX19zdHJpbmcodGhpcy5iYl9wb3MrZSx0KTpudWxsfWRvY1N0cmluZyh0KXtsZXQgZT10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDYpO3JldHVybiBlP3RoaXMuYmIuX19zdHJpbmcodGhpcy5iYl9wb3MrZSx0KTpudWxsfXR5cGUoZSl7bGV0IG49dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw4KTtyZXR1cm4gbj8oZXx8bmV3IHQuZXhwZXJpbWVudGFsLmZicy5UeXBlSW5mbykuX19pbml0KHRoaXMuYmIuX19pbmRpcmVjdCh0aGlzLmJiX3BvcytuKSx0aGlzLmJiKTpudWxsfXN0YXRpYyBzdGFydFZhbHVlSW5mbyh0KXt0LnN0YXJ0T2JqZWN0KDMpfXN0YXRpYyBhZGROYW1lKHQsZSl7dC5hZGRGaWVsZE9mZnNldCgwLGUsMCl9c3RhdGljIGFkZERvY1N0cmluZyh0LGUpe3QuYWRkRmllbGRPZmZzZXQoMSxlLDApfXN0YXRpYyBhZGRUeXBlKHQsZSl7dC5hZGRGaWVsZE9mZnNldCgyLGUsMCl9c3RhdGljIGVuZFZhbHVlSW5mbyh0KXtyZXR1cm4gdC5lbmRPYmplY3QoKX1zdGF0aWMgY3JlYXRlVmFsdWVJbmZvKHQsZSxyLGkpe3JldHVybiBuLnN0YXJ0VmFsdWVJbmZvKHQpLG4uYWRkTmFtZSh0LGUpLG4uYWRkRG9jU3RyaW5nKHQsciksbi5hZGRUeXBlKHQsaSksbi5lbmRWYWx1ZUluZm8odCl9fWUuVmFsdWVJbmZvPW59KGUuZmJzfHwoZS5mYnM9e30pKX0odC5leHBlcmltZW50YWx8fCh0LmV4cGVyaW1lbnRhbD17fSkpfShlLm9ubnhydW50aW1lfHwoZS5vbm54cnVudGltZT17fSkpLGZ1bmN0aW9uKHQpeyFmdW5jdGlvbihlKXshZnVuY3Rpb24oZSl7Y2xhc3Mgbntjb25zdHJ1Y3Rvcigpe3RoaXMuYmI9bnVsbCx0aGlzLmJiX3Bvcz0wfV9faW5pdCh0LGUpe3JldHVybiB0aGlzLmJiX3Bvcz10LHRoaXMuYmI9ZSx0aGlzfXN0YXRpYyBnZXRSb290QXNUeXBlSW5mbyh0LGUpe3JldHVybihlfHxuZXcgbikuX19pbml0KHQucmVhZEludDMyKHQucG9zaXRpb24oKSkrdC5wb3NpdGlvbigpLHQpfXN0YXRpYyBnZXRTaXplUHJlZml4ZWRSb290QXNUeXBlSW5mbyh0LGUpe3JldHVybiB0LnNldFBvc2l0aW9uKHQucG9zaXRpb24oKStyLmZsYXRidWZmZXJzLlNJWkVfUFJFRklYX0xFTkdUSCksKGV8fG5ldyBuKS5fX2luaXQodC5yZWFkSW50MzIodC5wb3NpdGlvbigpKSt0LnBvc2l0aW9uKCksdCl9ZGVub3RhdGlvbih0KXtsZXQgZT10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDQpO3JldHVybiBlP3RoaXMuYmIuX19zdHJpbmcodGhpcy5iYl9wb3MrZSx0KTpudWxsfXZhbHVlVHlwZSgpe2xldCBlPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNik7cmV0dXJuIGU/dGhpcy5iYi5yZWFkVWludDgodGhpcy5iYl9wb3MrZSk6dC5leHBlcmltZW50YWwuZmJzLlR5cGVJbmZvVmFsdWUuTk9ORX12YWx1ZSh0KXtsZXQgZT10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDgpO3JldHVybiBlP3RoaXMuYmIuX191bmlvbih0LHRoaXMuYmJfcG9zK2UpOm51bGx9c3RhdGljIHN0YXJ0VHlwZUluZm8odCl7dC5zdGFydE9iamVjdCgzKX1zdGF0aWMgYWRkRGVub3RhdGlvbih0LGUpe3QuYWRkRmllbGRPZmZzZXQoMCxlLDApfXN0YXRpYyBhZGRWYWx1ZVR5cGUoZSxuKXtlLmFkZEZpZWxkSW50OCgxLG4sdC5leHBlcmltZW50YWwuZmJzLlR5cGVJbmZvVmFsdWUuTk9ORSl9c3RhdGljIGFkZFZhbHVlKHQsZSl7dC5hZGRGaWVsZE9mZnNldCgyLGUsMCl9c3RhdGljIGVuZFR5cGVJbmZvKHQpe3JldHVybiB0LmVuZE9iamVjdCgpfXN0YXRpYyBjcmVhdGVUeXBlSW5mbyh0LGUscixpKXtyZXR1cm4gbi5zdGFydFR5cGVJbmZvKHQpLG4uYWRkRGVub3RhdGlvbih0LGUpLG4uYWRkVmFsdWVUeXBlKHQsciksbi5hZGRWYWx1ZSh0LGkpLG4uZW5kVHlwZUluZm8odCl9fWUuVHlwZUluZm89bn0oZS5mYnN8fChlLmZicz17fSkpfSh0LmV4cGVyaW1lbnRhbHx8KHQuZXhwZXJpbWVudGFsPXt9KSl9KGUub25ueHJ1bnRpbWV8fChlLm9ubnhydW50aW1lPXt9KSksZnVuY3Rpb24odCl7IWZ1bmN0aW9uKHQpeyFmdW5jdGlvbih0KXtjbGFzcyBle2NvbnN0cnVjdG9yKCl7dGhpcy5iYj1udWxsLHRoaXMuYmJfcG9zPTB9X19pbml0KHQsZSl7cmV0dXJuIHRoaXMuYmJfcG9zPXQsdGhpcy5iYj1lLHRoaXN9c3RhdGljIGdldFJvb3RBc09wZXJhdG9yU2V0SWQodCxuKXtyZXR1cm4obnx8bmV3IGUpLl9faW5pdCh0LnJlYWRJbnQzMih0LnBvc2l0aW9uKCkpK3QucG9zaXRpb24oKSx0KX1zdGF0aWMgZ2V0U2l6ZVByZWZpeGVkUm9vdEFzT3BlcmF0b3JTZXRJZCh0LG4pe3JldHVybiB0LnNldFBvc2l0aW9uKHQucG9zaXRpb24oKStyLmZsYXRidWZmZXJzLlNJWkVfUFJFRklYX0xFTkdUSCksKG58fG5ldyBlKS5fX2luaXQodC5yZWFkSW50MzIodC5wb3NpdGlvbigpKSt0LnBvc2l0aW9uKCksdCl9ZG9tYWluKHQpe2xldCBlPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNCk7cmV0dXJuIGU/dGhpcy5iYi5fX3N0cmluZyh0aGlzLmJiX3BvcytlLHQpOm51bGx9dmVyc2lvbigpe2xldCB0PXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNik7cmV0dXJuIHQ/dGhpcy5iYi5yZWFkSW50NjQodGhpcy5iYl9wb3MrdCk6dGhpcy5iYi5jcmVhdGVMb25nKDAsMCl9c3RhdGljIHN0YXJ0T3BlcmF0b3JTZXRJZCh0KXt0LnN0YXJ0T2JqZWN0KDIpfXN0YXRpYyBhZGREb21haW4odCxlKXt0LmFkZEZpZWxkT2Zmc2V0KDAsZSwwKX1zdGF0aWMgYWRkVmVyc2lvbih0LGUpe3QuYWRkRmllbGRJbnQ2NCgxLGUsdC5jcmVhdGVMb25nKDAsMCkpfXN0YXRpYyBlbmRPcGVyYXRvclNldElkKHQpe3JldHVybiB0LmVuZE9iamVjdCgpfXN0YXRpYyBjcmVhdGVPcGVyYXRvclNldElkKHQsbixyKXtyZXR1cm4gZS5zdGFydE9wZXJhdG9yU2V0SWQodCksZS5hZGREb21haW4odCxuKSxlLmFkZFZlcnNpb24odCxyKSxlLmVuZE9wZXJhdG9yU2V0SWQodCl9fXQuT3BlcmF0b3JTZXRJZD1lfSh0LmZic3x8KHQuZmJzPXt9KSl9KHQuZXhwZXJpbWVudGFsfHwodC5leHBlcmltZW50YWw9e30pKX0oZS5vbm54cnVudGltZXx8KGUub25ueHJ1bnRpbWU9e30pKSxmdW5jdGlvbih0KXshZnVuY3Rpb24oZSl7IWZ1bmN0aW9uKGUpe2NsYXNzIG57Y29uc3RydWN0b3IoKXt0aGlzLmJiPW51bGwsdGhpcy5iYl9wb3M9MH1fX2luaXQodCxlKXtyZXR1cm4gdGhpcy5iYl9wb3M9dCx0aGlzLmJiPWUsdGhpc31zdGF0aWMgZ2V0Um9vdEFzVGVuc29yKHQsZSl7cmV0dXJuKGV8fG5ldyBuKS5fX2luaXQodC5yZWFkSW50MzIodC5wb3NpdGlvbigpKSt0LnBvc2l0aW9uKCksdCl9c3RhdGljIGdldFNpemVQcmVmaXhlZFJvb3RBc1RlbnNvcih0LGUpe3JldHVybiB0LnNldFBvc2l0aW9uKHQucG9zaXRpb24oKStyLmZsYXRidWZmZXJzLlNJWkVfUFJFRklYX0xFTkdUSCksKGV8fG5ldyBuKS5fX2luaXQodC5yZWFkSW50MzIodC5wb3NpdGlvbigpKSt0LnBvc2l0aW9uKCksdCl9bmFtZSh0KXtsZXQgZT10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDQpO3JldHVybiBlP3RoaXMuYmIuX19zdHJpbmcodGhpcy5iYl9wb3MrZSx0KTpudWxsfWRvY1N0cmluZyh0KXtsZXQgZT10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDYpO3JldHVybiBlP3RoaXMuYmIuX19zdHJpbmcodGhpcy5iYl9wb3MrZSx0KTpudWxsfWRpbXModCl7bGV0IGU9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw4KTtyZXR1cm4gZT90aGlzLmJiLnJlYWRJbnQ2NCh0aGlzLmJiLl9fdmVjdG9yKHRoaXMuYmJfcG9zK2UpKzgqdCk6dGhpcy5iYi5jcmVhdGVMb25nKDAsMCl9ZGltc0xlbmd0aCgpe2xldCB0PXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsOCk7cmV0dXJuIHQ/dGhpcy5iYi5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MrdCk6MH1kYXRhVHlwZSgpe2xldCBlPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsMTApO3JldHVybiBlP3RoaXMuYmIucmVhZEludDMyKHRoaXMuYmJfcG9zK2UpOnQuZXhwZXJpbWVudGFsLmZicy5UZW5zb3JEYXRhVHlwZS5VTkRFRklORUR9cmF3RGF0YSh0KXtsZXQgZT10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDEyKTtyZXR1cm4gZT90aGlzLmJiLnJlYWRVaW50OCh0aGlzLmJiLl9fdmVjdG9yKHRoaXMuYmJfcG9zK2UpK3QpOjB9cmF3RGF0YUxlbmd0aCgpe2xldCB0PXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsMTIpO3JldHVybiB0P3RoaXMuYmIuX192ZWN0b3JfbGVuKHRoaXMuYmJfcG9zK3QpOjB9cmF3RGF0YUFycmF5KCl7bGV0IHQ9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3BvcywxMik7cmV0dXJuIHQ/bmV3IFVpbnQ4QXJyYXkodGhpcy5iYi5ieXRlcygpLmJ1ZmZlcix0aGlzLmJiLmJ5dGVzKCkuYnl0ZU9mZnNldCt0aGlzLmJiLl9fdmVjdG9yKHRoaXMuYmJfcG9zK3QpLHRoaXMuYmIuX192ZWN0b3JfbGVuKHRoaXMuYmJfcG9zK3QpKTpudWxsfXN0cmluZ0RhdGEodCxlKXtsZXQgbj10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDE0KTtyZXR1cm4gbj90aGlzLmJiLl9fc3RyaW5nKHRoaXMuYmIuX192ZWN0b3IodGhpcy5iYl9wb3MrbikrNCp0LGUpOm51bGx9c3RyaW5nRGF0YUxlbmd0aCgpe2xldCB0PXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsMTQpO3JldHVybiB0P3RoaXMuYmIuX192ZWN0b3JfbGVuKHRoaXMuYmJfcG9zK3QpOjB9c3RhdGljIHN0YXJ0VGVuc29yKHQpe3Quc3RhcnRPYmplY3QoNil9c3RhdGljIGFkZE5hbWUodCxlKXt0LmFkZEZpZWxkT2Zmc2V0KDAsZSwwKX1zdGF0aWMgYWRkRG9jU3RyaW5nKHQsZSl7dC5hZGRGaWVsZE9mZnNldCgxLGUsMCl9c3RhdGljIGFkZERpbXModCxlKXt0LmFkZEZpZWxkT2Zmc2V0KDIsZSwwKX1zdGF0aWMgY3JlYXRlRGltc1ZlY3Rvcih0LGUpe3Quc3RhcnRWZWN0b3IoOCxlLmxlbmd0aCw4KTtmb3IobGV0IG49ZS5sZW5ndGgtMTtuPj0wO24tLSl0LmFkZEludDY0KGVbbl0pO3JldHVybiB0LmVuZFZlY3RvcigpfXN0YXRpYyBzdGFydERpbXNWZWN0b3IodCxlKXt0LnN0YXJ0VmVjdG9yKDgsZSw4KX1zdGF0aWMgYWRkRGF0YVR5cGUoZSxuKXtlLmFkZEZpZWxkSW50MzIoMyxuLHQuZXhwZXJpbWVudGFsLmZicy5UZW5zb3JEYXRhVHlwZS5VTkRFRklORUQpfXN0YXRpYyBhZGRSYXdEYXRhKHQsZSl7dC5hZGRGaWVsZE9mZnNldCg0LGUsMCl9c3RhdGljIGNyZWF0ZVJhd0RhdGFWZWN0b3IodCxlKXt0LnN0YXJ0VmVjdG9yKDEsZS5sZW5ndGgsMSk7Zm9yKGxldCBuPWUubGVuZ3RoLTE7bj49MDtuLS0pdC5hZGRJbnQ4KGVbbl0pO3JldHVybiB0LmVuZFZlY3RvcigpfXN0YXRpYyBzdGFydFJhd0RhdGFWZWN0b3IodCxlKXt0LnN0YXJ0VmVjdG9yKDEsZSwxKX1zdGF0aWMgYWRkU3RyaW5nRGF0YSh0LGUpe3QuYWRkRmllbGRPZmZzZXQoNSxlLDApfXN0YXRpYyBjcmVhdGVTdHJpbmdEYXRhVmVjdG9yKHQsZSl7dC5zdGFydFZlY3Rvcig0LGUubGVuZ3RoLDQpO2ZvcihsZXQgbj1lLmxlbmd0aC0xO24+PTA7bi0tKXQuYWRkT2Zmc2V0KGVbbl0pO3JldHVybiB0LmVuZFZlY3RvcigpfXN0YXRpYyBzdGFydFN0cmluZ0RhdGFWZWN0b3IodCxlKXt0LnN0YXJ0VmVjdG9yKDQsZSw0KX1zdGF0aWMgZW5kVGVuc29yKHQpe3JldHVybiB0LmVuZE9iamVjdCgpfXN0YXRpYyBjcmVhdGVUZW5zb3IodCxlLHIsaSxvLGEscyl7cmV0dXJuIG4uc3RhcnRUZW5zb3IodCksbi5hZGROYW1lKHQsZSksbi5hZGREb2NTdHJpbmcodCxyKSxuLmFkZERpbXModCxpKSxuLmFkZERhdGFUeXBlKHQsbyksbi5hZGRSYXdEYXRhKHQsYSksbi5hZGRTdHJpbmdEYXRhKHQscyksbi5lbmRUZW5zb3IodCl9fWUuVGVuc29yPW59KGUuZmJzfHwoZS5mYnM9e30pKX0odC5leHBlcmltZW50YWx8fCh0LmV4cGVyaW1lbnRhbD17fSkpfShlLm9ubnhydW50aW1lfHwoZS5vbm54cnVudGltZT17fSkpLGZ1bmN0aW9uKHQpeyFmdW5jdGlvbihlKXshZnVuY3Rpb24oZSl7Y2xhc3Mgbntjb25zdHJ1Y3Rvcigpe3RoaXMuYmI9bnVsbCx0aGlzLmJiX3Bvcz0wfV9faW5pdCh0LGUpe3JldHVybiB0aGlzLmJiX3Bvcz10LHRoaXMuYmI9ZSx0aGlzfXN0YXRpYyBnZXRSb290QXNTcGFyc2VUZW5zb3IodCxlKXtyZXR1cm4oZXx8bmV3IG4pLl9faW5pdCh0LnJlYWRJbnQzMih0LnBvc2l0aW9uKCkpK3QucG9zaXRpb24oKSx0KX1zdGF0aWMgZ2V0U2l6ZVByZWZpeGVkUm9vdEFzU3BhcnNlVGVuc29yKHQsZSl7cmV0dXJuIHQuc2V0UG9zaXRpb24odC5wb3NpdGlvbigpK3IuZmxhdGJ1ZmZlcnMuU0laRV9QUkVGSVhfTEVOR1RIKSwoZXx8bmV3IG4pLl9faW5pdCh0LnJlYWRJbnQzMih0LnBvc2l0aW9uKCkpK3QucG9zaXRpb24oKSx0KX12YWx1ZXMoZSl7bGV0IG49dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw0KTtyZXR1cm4gbj8oZXx8bmV3IHQuZXhwZXJpbWVudGFsLmZicy5UZW5zb3IpLl9faW5pdCh0aGlzLmJiLl9faW5kaXJlY3QodGhpcy5iYl9wb3MrbiksdGhpcy5iYik6bnVsbH1pbmRpY2VzKGUpe2xldCBuPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNik7cmV0dXJuIG4/KGV8fG5ldyB0LmV4cGVyaW1lbnRhbC5mYnMuVGVuc29yKS5fX2luaXQodGhpcy5iYi5fX2luZGlyZWN0KHRoaXMuYmJfcG9zK24pLHRoaXMuYmIpOm51bGx9ZGltcyh0KXtsZXQgZT10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDgpO3JldHVybiBlP3RoaXMuYmIucmVhZEludDY0KHRoaXMuYmIuX192ZWN0b3IodGhpcy5iYl9wb3MrZSkrOCp0KTp0aGlzLmJiLmNyZWF0ZUxvbmcoMCwwKX1kaW1zTGVuZ3RoKCl7bGV0IHQ9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw4KTtyZXR1cm4gdD90aGlzLmJiLl9fdmVjdG9yX2xlbih0aGlzLmJiX3Bvcyt0KTowfXN0YXRpYyBzdGFydFNwYXJzZVRlbnNvcih0KXt0LnN0YXJ0T2JqZWN0KDMpfXN0YXRpYyBhZGRWYWx1ZXModCxlKXt0LmFkZEZpZWxkT2Zmc2V0KDAsZSwwKX1zdGF0aWMgYWRkSW5kaWNlcyh0LGUpe3QuYWRkRmllbGRPZmZzZXQoMSxlLDApfXN0YXRpYyBhZGREaW1zKHQsZSl7dC5hZGRGaWVsZE9mZnNldCgyLGUsMCl9c3RhdGljIGNyZWF0ZURpbXNWZWN0b3IodCxlKXt0LnN0YXJ0VmVjdG9yKDgsZS5sZW5ndGgsOCk7Zm9yKGxldCBuPWUubGVuZ3RoLTE7bj49MDtuLS0pdC5hZGRJbnQ2NChlW25dKTtyZXR1cm4gdC5lbmRWZWN0b3IoKX1zdGF0aWMgc3RhcnREaW1zVmVjdG9yKHQsZSl7dC5zdGFydFZlY3Rvcig4LGUsOCl9c3RhdGljIGVuZFNwYXJzZVRlbnNvcih0KXtyZXR1cm4gdC5lbmRPYmplY3QoKX1zdGF0aWMgY3JlYXRlU3BhcnNlVGVuc29yKHQsZSxyLGkpe3JldHVybiBuLnN0YXJ0U3BhcnNlVGVuc29yKHQpLG4uYWRkVmFsdWVzKHQsZSksbi5hZGRJbmRpY2VzKHQsciksbi5hZGREaW1zKHQsaSksbi5lbmRTcGFyc2VUZW5zb3IodCl9fWUuU3BhcnNlVGVuc29yPW59KGUuZmJzfHwoZS5mYnM9e30pKX0odC5leHBlcmltZW50YWx8fCh0LmV4cGVyaW1lbnRhbD17fSkpfShlLm9ubnhydW50aW1lfHwoZS5vbm54cnVudGltZT17fSkpLGZ1bmN0aW9uKHQpeyFmdW5jdGlvbihlKXshZnVuY3Rpb24oZSl7Y2xhc3Mgbntjb25zdHJ1Y3Rvcigpe3RoaXMuYmI9bnVsbCx0aGlzLmJiX3Bvcz0wfV9faW5pdCh0LGUpe3JldHVybiB0aGlzLmJiX3Bvcz10LHRoaXMuYmI9ZSx0aGlzfXN0YXRpYyBnZXRSb290QXNBdHRyaWJ1dGUodCxlKXtyZXR1cm4oZXx8bmV3IG4pLl9faW5pdCh0LnJlYWRJbnQzMih0LnBvc2l0aW9uKCkpK3QucG9zaXRpb24oKSx0KX1zdGF0aWMgZ2V0U2l6ZVByZWZpeGVkUm9vdEFzQXR0cmlidXRlKHQsZSl7cmV0dXJuIHQuc2V0UG9zaXRpb24odC5wb3NpdGlvbigpK3IuZmxhdGJ1ZmZlcnMuU0laRV9QUkVGSVhfTEVOR1RIKSwoZXx8bmV3IG4pLl9faW5pdCh0LnJlYWRJbnQzMih0LnBvc2l0aW9uKCkpK3QucG9zaXRpb24oKSx0KX1uYW1lKHQpe2xldCBlPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNCk7cmV0dXJuIGU/dGhpcy5iYi5fX3N0cmluZyh0aGlzLmJiX3BvcytlLHQpOm51bGx9ZG9jU3RyaW5nKHQpe2xldCBlPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNik7cmV0dXJuIGU/dGhpcy5iYi5fX3N0cmluZyh0aGlzLmJiX3BvcytlLHQpOm51bGx9dHlwZSgpe2xldCBlPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsOCk7cmV0dXJuIGU/dGhpcy5iYi5yZWFkSW50MzIodGhpcy5iYl9wb3MrZSk6dC5leHBlcmltZW50YWwuZmJzLkF0dHJpYnV0ZVR5cGUuVU5ERUZJTkVEfWYoKXtsZXQgdD10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDEwKTtyZXR1cm4gdD90aGlzLmJiLnJlYWRGbG9hdDMyKHRoaXMuYmJfcG9zK3QpOjB9aSgpe2xldCB0PXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsMTIpO3JldHVybiB0P3RoaXMuYmIucmVhZEludDY0KHRoaXMuYmJfcG9zK3QpOnRoaXMuYmIuY3JlYXRlTG9uZygwLDApfXModCl7bGV0IGU9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3BvcywxNCk7cmV0dXJuIGU/dGhpcy5iYi5fX3N0cmluZyh0aGlzLmJiX3BvcytlLHQpOm51bGx9dChlKXtsZXQgbj10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDE2KTtyZXR1cm4gbj8oZXx8bmV3IHQuZXhwZXJpbWVudGFsLmZicy5UZW5zb3IpLl9faW5pdCh0aGlzLmJiLl9faW5kaXJlY3QodGhpcy5iYl9wb3MrbiksdGhpcy5iYik6bnVsbH1nKGUpe2xldCBuPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsMTgpO3JldHVybiBuPyhlfHxuZXcgdC5leHBlcmltZW50YWwuZmJzLkdyYXBoKS5fX2luaXQodGhpcy5iYi5fX2luZGlyZWN0KHRoaXMuYmJfcG9zK24pLHRoaXMuYmIpOm51bGx9ZmxvYXRzKHQpe2xldCBlPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsMjApO3JldHVybiBlP3RoaXMuYmIucmVhZEZsb2F0MzIodGhpcy5iYi5fX3ZlY3Rvcih0aGlzLmJiX3BvcytlKSs0KnQpOjB9ZmxvYXRzTGVuZ3RoKCl7bGV0IHQ9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3BvcywyMCk7cmV0dXJuIHQ/dGhpcy5iYi5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MrdCk6MH1mbG9hdHNBcnJheSgpe2xldCB0PXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsMjApO3JldHVybiB0P25ldyBGbG9hdDMyQXJyYXkodGhpcy5iYi5ieXRlcygpLmJ1ZmZlcix0aGlzLmJiLmJ5dGVzKCkuYnl0ZU9mZnNldCt0aGlzLmJiLl9fdmVjdG9yKHRoaXMuYmJfcG9zK3QpLHRoaXMuYmIuX192ZWN0b3JfbGVuKHRoaXMuYmJfcG9zK3QpKTpudWxsfWludHModCl7bGV0IGU9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3BvcywyMik7cmV0dXJuIGU/dGhpcy5iYi5yZWFkSW50NjQodGhpcy5iYi5fX3ZlY3Rvcih0aGlzLmJiX3BvcytlKSs4KnQpOnRoaXMuYmIuY3JlYXRlTG9uZygwLDApfWludHNMZW5ndGgoKXtsZXQgdD10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDIyKTtyZXR1cm4gdD90aGlzLmJiLl9fdmVjdG9yX2xlbih0aGlzLmJiX3Bvcyt0KTowfXN0cmluZ3ModCxlKXtsZXQgbj10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDI0KTtyZXR1cm4gbj90aGlzLmJiLl9fc3RyaW5nKHRoaXMuYmIuX192ZWN0b3IodGhpcy5iYl9wb3MrbikrNCp0LGUpOm51bGx9c3RyaW5nc0xlbmd0aCgpe2xldCB0PXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsMjQpO3JldHVybiB0P3RoaXMuYmIuX192ZWN0b3JfbGVuKHRoaXMuYmJfcG9zK3QpOjB9dGVuc29ycyhlLG4pe2xldCByPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsMjYpO3JldHVybiByPyhufHxuZXcgdC5leHBlcmltZW50YWwuZmJzLlRlbnNvcikuX19pbml0KHRoaXMuYmIuX19pbmRpcmVjdCh0aGlzLmJiLl9fdmVjdG9yKHRoaXMuYmJfcG9zK3IpKzQqZSksdGhpcy5iYik6bnVsbH10ZW5zb3JzTGVuZ3RoKCl7bGV0IHQ9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3BvcywyNik7cmV0dXJuIHQ/dGhpcy5iYi5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MrdCk6MH1ncmFwaHMoZSxuKXtsZXQgcj10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDI4KTtyZXR1cm4gcj8obnx8bmV3IHQuZXhwZXJpbWVudGFsLmZicy5HcmFwaCkuX19pbml0KHRoaXMuYmIuX19pbmRpcmVjdCh0aGlzLmJiLl9fdmVjdG9yKHRoaXMuYmJfcG9zK3IpKzQqZSksdGhpcy5iYik6bnVsbH1ncmFwaHNMZW5ndGgoKXtsZXQgdD10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDI4KTtyZXR1cm4gdD90aGlzLmJiLl9fdmVjdG9yX2xlbih0aGlzLmJiX3Bvcyt0KTowfXN0YXRpYyBzdGFydEF0dHJpYnV0ZSh0KXt0LnN0YXJ0T2JqZWN0KDEzKX1zdGF0aWMgYWRkTmFtZSh0LGUpe3QuYWRkRmllbGRPZmZzZXQoMCxlLDApfXN0YXRpYyBhZGREb2NTdHJpbmcodCxlKXt0LmFkZEZpZWxkT2Zmc2V0KDEsZSwwKX1zdGF0aWMgYWRkVHlwZShlLG4pe2UuYWRkRmllbGRJbnQzMigyLG4sdC5leHBlcmltZW50YWwuZmJzLkF0dHJpYnV0ZVR5cGUuVU5ERUZJTkVEKX1zdGF0aWMgYWRkRih0LGUpe3QuYWRkRmllbGRGbG9hdDMyKDMsZSwwKX1zdGF0aWMgYWRkSSh0LGUpe3QuYWRkRmllbGRJbnQ2NCg0LGUsdC5jcmVhdGVMb25nKDAsMCkpfXN0YXRpYyBhZGRTKHQsZSl7dC5hZGRGaWVsZE9mZnNldCg1LGUsMCl9c3RhdGljIGFkZFQodCxlKXt0LmFkZEZpZWxkT2Zmc2V0KDYsZSwwKX1zdGF0aWMgYWRkRyh0LGUpe3QuYWRkRmllbGRPZmZzZXQoNyxlLDApfXN0YXRpYyBhZGRGbG9hdHModCxlKXt0LmFkZEZpZWxkT2Zmc2V0KDgsZSwwKX1zdGF0aWMgY3JlYXRlRmxvYXRzVmVjdG9yKHQsZSl7dC5zdGFydFZlY3Rvcig0LGUubGVuZ3RoLDQpO2ZvcihsZXQgbj1lLmxlbmd0aC0xO24+PTA7bi0tKXQuYWRkRmxvYXQzMihlW25dKTtyZXR1cm4gdC5lbmRWZWN0b3IoKX1zdGF0aWMgc3RhcnRGbG9hdHNWZWN0b3IodCxlKXt0LnN0YXJ0VmVjdG9yKDQsZSw0KX1zdGF0aWMgYWRkSW50cyh0LGUpe3QuYWRkRmllbGRPZmZzZXQoOSxlLDApfXN0YXRpYyBjcmVhdGVJbnRzVmVjdG9yKHQsZSl7dC5zdGFydFZlY3Rvcig4LGUubGVuZ3RoLDgpO2ZvcihsZXQgbj1lLmxlbmd0aC0xO24+PTA7bi0tKXQuYWRkSW50NjQoZVtuXSk7cmV0dXJuIHQuZW5kVmVjdG9yKCl9c3RhdGljIHN0YXJ0SW50c1ZlY3Rvcih0LGUpe3Quc3RhcnRWZWN0b3IoOCxlLDgpfXN0YXRpYyBhZGRTdHJpbmdzKHQsZSl7dC5hZGRGaWVsZE9mZnNldCgxMCxlLDApfXN0YXRpYyBjcmVhdGVTdHJpbmdzVmVjdG9yKHQsZSl7dC5zdGFydFZlY3Rvcig0LGUubGVuZ3RoLDQpO2ZvcihsZXQgbj1lLmxlbmd0aC0xO24+PTA7bi0tKXQuYWRkT2Zmc2V0KGVbbl0pO3JldHVybiB0LmVuZFZlY3RvcigpfXN0YXRpYyBzdGFydFN0cmluZ3NWZWN0b3IodCxlKXt0LnN0YXJ0VmVjdG9yKDQsZSw0KX1zdGF0aWMgYWRkVGVuc29ycyh0LGUpe3QuYWRkRmllbGRPZmZzZXQoMTEsZSwwKX1zdGF0aWMgY3JlYXRlVGVuc29yc1ZlY3Rvcih0LGUpe3Quc3RhcnRWZWN0b3IoNCxlLmxlbmd0aCw0KTtmb3IobGV0IG49ZS5sZW5ndGgtMTtuPj0wO24tLSl0LmFkZE9mZnNldChlW25dKTtyZXR1cm4gdC5lbmRWZWN0b3IoKX1zdGF0aWMgc3RhcnRUZW5zb3JzVmVjdG9yKHQsZSl7dC5zdGFydFZlY3Rvcig0LGUsNCl9c3RhdGljIGFkZEdyYXBocyh0LGUpe3QuYWRkRmllbGRPZmZzZXQoMTIsZSwwKX1zdGF0aWMgY3JlYXRlR3JhcGhzVmVjdG9yKHQsZSl7dC5zdGFydFZlY3Rvcig0LGUubGVuZ3RoLDQpO2ZvcihsZXQgbj1lLmxlbmd0aC0xO24+PTA7bi0tKXQuYWRkT2Zmc2V0KGVbbl0pO3JldHVybiB0LmVuZFZlY3RvcigpfXN0YXRpYyBzdGFydEdyYXBoc1ZlY3Rvcih0LGUpe3Quc3RhcnRWZWN0b3IoNCxlLDQpfXN0YXRpYyBlbmRBdHRyaWJ1dGUodCl7cmV0dXJuIHQuZW5kT2JqZWN0KCl9c3RhdGljIGNyZWF0ZUF0dHJpYnV0ZSh0LGUscixpLG8sYSxzLHUsYyxsLHAsZixkLGgpe3JldHVybiBuLnN0YXJ0QXR0cmlidXRlKHQpLG4uYWRkTmFtZSh0LGUpLG4uYWRkRG9jU3RyaW5nKHQsciksbi5hZGRUeXBlKHQsaSksbi5hZGRGKHQsbyksbi5hZGRJKHQsYSksbi5hZGRTKHQscyksbi5hZGRUKHQsdSksbi5hZGRHKHQsYyksbi5hZGRGbG9hdHModCxsKSxuLmFkZEludHModCxwKSxuLmFkZFN0cmluZ3ModCxmKSxuLmFkZFRlbnNvcnModCxkKSxuLmFkZEdyYXBocyh0LGgpLG4uZW5kQXR0cmlidXRlKHQpfX1lLkF0dHJpYnV0ZT1ufShlLmZic3x8KGUuZmJzPXt9KSl9KHQuZXhwZXJpbWVudGFsfHwodC5leHBlcmltZW50YWw9e30pKX0oZS5vbm54cnVudGltZXx8KGUub25ueHJ1bnRpbWU9e30pKSxmdW5jdGlvbih0KXshZnVuY3Rpb24oZSl7IWZ1bmN0aW9uKGUpe2NsYXNzIG57Y29uc3RydWN0b3IoKXt0aGlzLmJiPW51bGwsdGhpcy5iYl9wb3M9MH1fX2luaXQodCxlKXtyZXR1cm4gdGhpcy5iYl9wb3M9dCx0aGlzLmJiPWUsdGhpc31zdGF0aWMgZ2V0Um9vdEFzR3JhcGgodCxlKXtyZXR1cm4oZXx8bmV3IG4pLl9faW5pdCh0LnJlYWRJbnQzMih0LnBvc2l0aW9uKCkpK3QucG9zaXRpb24oKSx0KX1zdGF0aWMgZ2V0U2l6ZVByZWZpeGVkUm9vdEFzR3JhcGgodCxlKXtyZXR1cm4gdC5zZXRQb3NpdGlvbih0LnBvc2l0aW9uKCkrci5mbGF0YnVmZmVycy5TSVpFX1BSRUZJWF9MRU5HVEgpLChlfHxuZXcgbikuX19pbml0KHQucmVhZEludDMyKHQucG9zaXRpb24oKSkrdC5wb3NpdGlvbigpLHQpfWluaXRpYWxpemVycyhlLG4pe2xldCByPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNCk7cmV0dXJuIHI/KG58fG5ldyB0LmV4cGVyaW1lbnRhbC5mYnMuVGVuc29yKS5fX2luaXQodGhpcy5iYi5fX2luZGlyZWN0KHRoaXMuYmIuX192ZWN0b3IodGhpcy5iYl9wb3MrcikrNCplKSx0aGlzLmJiKTpudWxsfWluaXRpYWxpemVyc0xlbmd0aCgpe2xldCB0PXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNCk7cmV0dXJuIHQ/dGhpcy5iYi5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MrdCk6MH1ub2RlQXJncyhlLG4pe2xldCByPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNik7cmV0dXJuIHI/KG58fG5ldyB0LmV4cGVyaW1lbnRhbC5mYnMuVmFsdWVJbmZvKS5fX2luaXQodGhpcy5iYi5fX2luZGlyZWN0KHRoaXMuYmIuX192ZWN0b3IodGhpcy5iYl9wb3MrcikrNCplKSx0aGlzLmJiKTpudWxsfW5vZGVBcmdzTGVuZ3RoKCl7bGV0IHQ9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw2KTtyZXR1cm4gdD90aGlzLmJiLl9fdmVjdG9yX2xlbih0aGlzLmJiX3Bvcyt0KTowfW5vZGVzKGUsbil7bGV0IHI9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw4KTtyZXR1cm4gcj8obnx8bmV3IHQuZXhwZXJpbWVudGFsLmZicy5Ob2RlKS5fX2luaXQodGhpcy5iYi5fX2luZGlyZWN0KHRoaXMuYmIuX192ZWN0b3IodGhpcy5iYl9wb3MrcikrNCplKSx0aGlzLmJiKTpudWxsfW5vZGVzTGVuZ3RoKCl7bGV0IHQ9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw4KTtyZXR1cm4gdD90aGlzLmJiLl9fdmVjdG9yX2xlbih0aGlzLmJiX3Bvcyt0KTowfW1heE5vZGVJbmRleCgpe2xldCB0PXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsMTApO3JldHVybiB0P3RoaXMuYmIucmVhZFVpbnQzMih0aGlzLmJiX3Bvcyt0KTowfW5vZGVFZGdlcyhlLG4pe2xldCByPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsMTIpO3JldHVybiByPyhufHxuZXcgdC5leHBlcmltZW50YWwuZmJzLk5vZGVFZGdlKS5fX2luaXQodGhpcy5iYi5fX2luZGlyZWN0KHRoaXMuYmIuX192ZWN0b3IodGhpcy5iYl9wb3MrcikrNCplKSx0aGlzLmJiKTpudWxsfW5vZGVFZGdlc0xlbmd0aCgpe2xldCB0PXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsMTIpO3JldHVybiB0P3RoaXMuYmIuX192ZWN0b3JfbGVuKHRoaXMuYmJfcG9zK3QpOjB9aW5wdXRzKHQsZSl7bGV0IG49dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3BvcywxNCk7cmV0dXJuIG4/dGhpcy5iYi5fX3N0cmluZyh0aGlzLmJiLl9fdmVjdG9yKHRoaXMuYmJfcG9zK24pKzQqdCxlKTpudWxsfWlucHV0c0xlbmd0aCgpe2xldCB0PXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsMTQpO3JldHVybiB0P3RoaXMuYmIuX192ZWN0b3JfbGVuKHRoaXMuYmJfcG9zK3QpOjB9b3V0cHV0cyh0LGUpe2xldCBuPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsMTYpO3JldHVybiBuP3RoaXMuYmIuX19zdHJpbmcodGhpcy5iYi5fX3ZlY3Rvcih0aGlzLmJiX3BvcytuKSs0KnQsZSk6bnVsbH1vdXRwdXRzTGVuZ3RoKCl7bGV0IHQ9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3BvcywxNik7cmV0dXJuIHQ/dGhpcy5iYi5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MrdCk6MH1zcGFyc2VJbml0aWFsaXplcnMoZSxuKXtsZXQgcj10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDE4KTtyZXR1cm4gcj8obnx8bmV3IHQuZXhwZXJpbWVudGFsLmZicy5TcGFyc2VUZW5zb3IpLl9faW5pdCh0aGlzLmJiLl9faW5kaXJlY3QodGhpcy5iYi5fX3ZlY3Rvcih0aGlzLmJiX3BvcytyKSs0KmUpLHRoaXMuYmIpOm51bGx9c3BhcnNlSW5pdGlhbGl6ZXJzTGVuZ3RoKCl7bGV0IHQ9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3BvcywxOCk7cmV0dXJuIHQ/dGhpcy5iYi5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MrdCk6MH1zdGF0aWMgc3RhcnRHcmFwaCh0KXt0LnN0YXJ0T2JqZWN0KDgpfXN0YXRpYyBhZGRJbml0aWFsaXplcnModCxlKXt0LmFkZEZpZWxkT2Zmc2V0KDAsZSwwKX1zdGF0aWMgY3JlYXRlSW5pdGlhbGl6ZXJzVmVjdG9yKHQsZSl7dC5zdGFydFZlY3Rvcig0LGUubGVuZ3RoLDQpO2ZvcihsZXQgbj1lLmxlbmd0aC0xO24+PTA7bi0tKXQuYWRkT2Zmc2V0KGVbbl0pO3JldHVybiB0LmVuZFZlY3RvcigpfXN0YXRpYyBzdGFydEluaXRpYWxpemVyc1ZlY3Rvcih0LGUpe3Quc3RhcnRWZWN0b3IoNCxlLDQpfXN0YXRpYyBhZGROb2RlQXJncyh0LGUpe3QuYWRkRmllbGRPZmZzZXQoMSxlLDApfXN0YXRpYyBjcmVhdGVOb2RlQXJnc1ZlY3Rvcih0LGUpe3Quc3RhcnRWZWN0b3IoNCxlLmxlbmd0aCw0KTtmb3IobGV0IG49ZS5sZW5ndGgtMTtuPj0wO24tLSl0LmFkZE9mZnNldChlW25dKTtyZXR1cm4gdC5lbmRWZWN0b3IoKX1zdGF0aWMgc3RhcnROb2RlQXJnc1ZlY3Rvcih0LGUpe3Quc3RhcnRWZWN0b3IoNCxlLDQpfXN0YXRpYyBhZGROb2Rlcyh0LGUpe3QuYWRkRmllbGRPZmZzZXQoMixlLDApfXN0YXRpYyBjcmVhdGVOb2Rlc1ZlY3Rvcih0LGUpe3Quc3RhcnRWZWN0b3IoNCxlLmxlbmd0aCw0KTtmb3IobGV0IG49ZS5sZW5ndGgtMTtuPj0wO24tLSl0LmFkZE9mZnNldChlW25dKTtyZXR1cm4gdC5lbmRWZWN0b3IoKX1zdGF0aWMgc3RhcnROb2Rlc1ZlY3Rvcih0LGUpe3Quc3RhcnRWZWN0b3IoNCxlLDQpfXN0YXRpYyBhZGRNYXhOb2RlSW5kZXgodCxlKXt0LmFkZEZpZWxkSW50MzIoMyxlLDApfXN0YXRpYyBhZGROb2RlRWRnZXModCxlKXt0LmFkZEZpZWxkT2Zmc2V0KDQsZSwwKX1zdGF0aWMgY3JlYXRlTm9kZUVkZ2VzVmVjdG9yKHQsZSl7dC5zdGFydFZlY3Rvcig0LGUubGVuZ3RoLDQpO2ZvcihsZXQgbj1lLmxlbmd0aC0xO24+PTA7bi0tKXQuYWRkT2Zmc2V0KGVbbl0pO3JldHVybiB0LmVuZFZlY3RvcigpfXN0YXRpYyBzdGFydE5vZGVFZGdlc1ZlY3Rvcih0LGUpe3Quc3RhcnRWZWN0b3IoNCxlLDQpfXN0YXRpYyBhZGRJbnB1dHModCxlKXt0LmFkZEZpZWxkT2Zmc2V0KDUsZSwwKX1zdGF0aWMgY3JlYXRlSW5wdXRzVmVjdG9yKHQsZSl7dC5zdGFydFZlY3Rvcig0LGUubGVuZ3RoLDQpO2ZvcihsZXQgbj1lLmxlbmd0aC0xO24+PTA7bi0tKXQuYWRkT2Zmc2V0KGVbbl0pO3JldHVybiB0LmVuZFZlY3RvcigpfXN0YXRpYyBzdGFydElucHV0c1ZlY3Rvcih0LGUpe3Quc3RhcnRWZWN0b3IoNCxlLDQpfXN0YXRpYyBhZGRPdXRwdXRzKHQsZSl7dC5hZGRGaWVsZE9mZnNldCg2LGUsMCl9c3RhdGljIGNyZWF0ZU91dHB1dHNWZWN0b3IodCxlKXt0LnN0YXJ0VmVjdG9yKDQsZS5sZW5ndGgsNCk7Zm9yKGxldCBuPWUubGVuZ3RoLTE7bj49MDtuLS0pdC5hZGRPZmZzZXQoZVtuXSk7cmV0dXJuIHQuZW5kVmVjdG9yKCl9c3RhdGljIHN0YXJ0T3V0cHV0c1ZlY3Rvcih0LGUpe3Quc3RhcnRWZWN0b3IoNCxlLDQpfXN0YXRpYyBhZGRTcGFyc2VJbml0aWFsaXplcnModCxlKXt0LmFkZEZpZWxkT2Zmc2V0KDcsZSwwKX1zdGF0aWMgY3JlYXRlU3BhcnNlSW5pdGlhbGl6ZXJzVmVjdG9yKHQsZSl7dC5zdGFydFZlY3Rvcig0LGUubGVuZ3RoLDQpO2ZvcihsZXQgbj1lLmxlbmd0aC0xO24+PTA7bi0tKXQuYWRkT2Zmc2V0KGVbbl0pO3JldHVybiB0LmVuZFZlY3RvcigpfXN0YXRpYyBzdGFydFNwYXJzZUluaXRpYWxpemVyc1ZlY3Rvcih0LGUpe3Quc3RhcnRWZWN0b3IoNCxlLDQpfXN0YXRpYyBlbmRHcmFwaCh0KXtyZXR1cm4gdC5lbmRPYmplY3QoKX1zdGF0aWMgY3JlYXRlR3JhcGgodCxlLHIsaSxvLGEscyx1LGMpe3JldHVybiBuLnN0YXJ0R3JhcGgodCksbi5hZGRJbml0aWFsaXplcnModCxlKSxuLmFkZE5vZGVBcmdzKHQsciksbi5hZGROb2Rlcyh0LGkpLG4uYWRkTWF4Tm9kZUluZGV4KHQsbyksbi5hZGROb2RlRWRnZXModCxhKSxuLmFkZElucHV0cyh0LHMpLG4uYWRkT3V0cHV0cyh0LHUpLG4uYWRkU3BhcnNlSW5pdGlhbGl6ZXJzKHQsYyksbi5lbmRHcmFwaCh0KX19ZS5HcmFwaD1ufShlLmZic3x8KGUuZmJzPXt9KSl9KHQuZXhwZXJpbWVudGFsfHwodC5leHBlcmltZW50YWw9e30pKX0oZS5vbm54cnVudGltZXx8KGUub25ueHJ1bnRpbWU9e30pKSxmdW5jdGlvbih0KXshZnVuY3Rpb24oZSl7IWZ1bmN0aW9uKGUpe2NsYXNzIG57Y29uc3RydWN0b3IoKXt0aGlzLmJiPW51bGwsdGhpcy5iYl9wb3M9MH1fX2luaXQodCxlKXtyZXR1cm4gdGhpcy5iYl9wb3M9dCx0aGlzLmJiPWUsdGhpc31zdGF0aWMgZ2V0Um9vdEFzTW9kZWwodCxlKXtyZXR1cm4oZXx8bmV3IG4pLl9faW5pdCh0LnJlYWRJbnQzMih0LnBvc2l0aW9uKCkpK3QucG9zaXRpb24oKSx0KX1zdGF0aWMgZ2V0U2l6ZVByZWZpeGVkUm9vdEFzTW9kZWwodCxlKXtyZXR1cm4gdC5zZXRQb3NpdGlvbih0LnBvc2l0aW9uKCkrci5mbGF0YnVmZmVycy5TSVpFX1BSRUZJWF9MRU5HVEgpLChlfHxuZXcgbikuX19pbml0KHQucmVhZEludDMyKHQucG9zaXRpb24oKSkrdC5wb3NpdGlvbigpLHQpfWlyVmVyc2lvbigpe2xldCB0PXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNCk7cmV0dXJuIHQ/dGhpcy5iYi5yZWFkSW50NjQodGhpcy5iYl9wb3MrdCk6dGhpcy5iYi5jcmVhdGVMb25nKDAsMCl9b3BzZXRJbXBvcnQoZSxuKXtsZXQgcj10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDYpO3JldHVybiByPyhufHxuZXcgdC5leHBlcmltZW50YWwuZmJzLk9wZXJhdG9yU2V0SWQpLl9faW5pdCh0aGlzLmJiLl9faW5kaXJlY3QodGhpcy5iYi5fX3ZlY3Rvcih0aGlzLmJiX3BvcytyKSs0KmUpLHRoaXMuYmIpOm51bGx9b3BzZXRJbXBvcnRMZW5ndGgoKXtsZXQgdD10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDYpO3JldHVybiB0P3RoaXMuYmIuX192ZWN0b3JfbGVuKHRoaXMuYmJfcG9zK3QpOjB9cHJvZHVjZXJOYW1lKHQpe2xldCBlPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsOCk7cmV0dXJuIGU/dGhpcy5iYi5fX3N0cmluZyh0aGlzLmJiX3BvcytlLHQpOm51bGx9cHJvZHVjZXJWZXJzaW9uKHQpe2xldCBlPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsMTApO3JldHVybiBlP3RoaXMuYmIuX19zdHJpbmcodGhpcy5iYl9wb3MrZSx0KTpudWxsfWRvbWFpbih0KXtsZXQgZT10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDEyKTtyZXR1cm4gZT90aGlzLmJiLl9fc3RyaW5nKHRoaXMuYmJfcG9zK2UsdCk6bnVsbH1tb2RlbFZlcnNpb24oKXtsZXQgdD10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDE0KTtyZXR1cm4gdD90aGlzLmJiLnJlYWRJbnQ2NCh0aGlzLmJiX3Bvcyt0KTp0aGlzLmJiLmNyZWF0ZUxvbmcoMCwwKX1kb2NTdHJpbmcodCl7bGV0IGU9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3BvcywxNik7cmV0dXJuIGU/dGhpcy5iYi5fX3N0cmluZyh0aGlzLmJiX3BvcytlLHQpOm51bGx9Z3JhcGgoZSl7bGV0IG49dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3BvcywxOCk7cmV0dXJuIG4/KGV8fG5ldyB0LmV4cGVyaW1lbnRhbC5mYnMuR3JhcGgpLl9faW5pdCh0aGlzLmJiLl9faW5kaXJlY3QodGhpcy5iYl9wb3MrbiksdGhpcy5iYik6bnVsbH1ncmFwaERvY1N0cmluZyh0KXtsZXQgZT10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDIwKTtyZXR1cm4gZT90aGlzLmJiLl9fc3RyaW5nKHRoaXMuYmJfcG9zK2UsdCk6bnVsbH1zdGF0aWMgc3RhcnRNb2RlbCh0KXt0LnN0YXJ0T2JqZWN0KDkpfXN0YXRpYyBhZGRJclZlcnNpb24odCxlKXt0LmFkZEZpZWxkSW50NjQoMCxlLHQuY3JlYXRlTG9uZygwLDApKX1zdGF0aWMgYWRkT3BzZXRJbXBvcnQodCxlKXt0LmFkZEZpZWxkT2Zmc2V0KDEsZSwwKX1zdGF0aWMgY3JlYXRlT3BzZXRJbXBvcnRWZWN0b3IodCxlKXt0LnN0YXJ0VmVjdG9yKDQsZS5sZW5ndGgsNCk7Zm9yKGxldCBuPWUubGVuZ3RoLTE7bj49MDtuLS0pdC5hZGRPZmZzZXQoZVtuXSk7cmV0dXJuIHQuZW5kVmVjdG9yKCl9c3RhdGljIHN0YXJ0T3BzZXRJbXBvcnRWZWN0b3IodCxlKXt0LnN0YXJ0VmVjdG9yKDQsZSw0KX1zdGF0aWMgYWRkUHJvZHVjZXJOYW1lKHQsZSl7dC5hZGRGaWVsZE9mZnNldCgyLGUsMCl9c3RhdGljIGFkZFByb2R1Y2VyVmVyc2lvbih0LGUpe3QuYWRkRmllbGRPZmZzZXQoMyxlLDApfXN0YXRpYyBhZGREb21haW4odCxlKXt0LmFkZEZpZWxkT2Zmc2V0KDQsZSwwKX1zdGF0aWMgYWRkTW9kZWxWZXJzaW9uKHQsZSl7dC5hZGRGaWVsZEludDY0KDUsZSx0LmNyZWF0ZUxvbmcoMCwwKSl9c3RhdGljIGFkZERvY1N0cmluZyh0LGUpe3QuYWRkRmllbGRPZmZzZXQoNixlLDApfXN0YXRpYyBhZGRHcmFwaCh0LGUpe3QuYWRkRmllbGRPZmZzZXQoNyxlLDApfXN0YXRpYyBhZGRHcmFwaERvY1N0cmluZyh0LGUpe3QuYWRkRmllbGRPZmZzZXQoOCxlLDApfXN0YXRpYyBlbmRNb2RlbCh0KXtyZXR1cm4gdC5lbmRPYmplY3QoKX1zdGF0aWMgY3JlYXRlTW9kZWwodCxlLHIsaSxvLGEscyx1LGMsbCl7cmV0dXJuIG4uc3RhcnRNb2RlbCh0KSxuLmFkZElyVmVyc2lvbih0LGUpLG4uYWRkT3BzZXRJbXBvcnQodCxyKSxuLmFkZFByb2R1Y2VyTmFtZSh0LGkpLG4uYWRkUHJvZHVjZXJWZXJzaW9uKHQsbyksbi5hZGREb21haW4odCxhKSxuLmFkZE1vZGVsVmVyc2lvbih0LHMpLG4uYWRkRG9jU3RyaW5nKHQsdSksbi5hZGRHcmFwaCh0LGMpLG4uYWRkR3JhcGhEb2NTdHJpbmcodCxsKSxuLmVuZE1vZGVsKHQpfX1lLk1vZGVsPW59KGUuZmJzfHwoZS5mYnM9e30pKX0odC5leHBlcmltZW50YWx8fCh0LmV4cGVyaW1lbnRhbD17fSkpfShlLm9ubnhydW50aW1lfHwoZS5vbm54cnVudGltZT17fSkpLGZ1bmN0aW9uKHQpeyFmdW5jdGlvbih0KXshZnVuY3Rpb24odCl7Y2xhc3MgZXtjb25zdHJ1Y3Rvcigpe3RoaXMuYmI9bnVsbCx0aGlzLmJiX3Bvcz0wfV9faW5pdCh0LGUpe3JldHVybiB0aGlzLmJiX3Bvcz10LHRoaXMuYmI9ZSx0aGlzfXN0YXRpYyBnZXRSb290QXNLZXJuZWxDcmVhdGVJbmZvcyh0LG4pe3JldHVybihufHxuZXcgZSkuX19pbml0KHQucmVhZEludDMyKHQucG9zaXRpb24oKSkrdC5wb3NpdGlvbigpLHQpfXN0YXRpYyBnZXRTaXplUHJlZml4ZWRSb290QXNLZXJuZWxDcmVhdGVJbmZvcyh0LG4pe3JldHVybiB0LnNldFBvc2l0aW9uKHQucG9zaXRpb24oKStyLmZsYXRidWZmZXJzLlNJWkVfUFJFRklYX0xFTkdUSCksKG58fG5ldyBlKS5fX2luaXQodC5yZWFkSW50MzIodC5wb3NpdGlvbigpKSt0LnBvc2l0aW9uKCksdCl9bm9kZUluZGljZXModCl7bGV0IGU9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw0KTtyZXR1cm4gZT90aGlzLmJiLnJlYWRVaW50MzIodGhpcy5iYi5fX3ZlY3Rvcih0aGlzLmJiX3BvcytlKSs0KnQpOjB9bm9kZUluZGljZXNMZW5ndGgoKXtsZXQgdD10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDQpO3JldHVybiB0P3RoaXMuYmIuX192ZWN0b3JfbGVuKHRoaXMuYmJfcG9zK3QpOjB9bm9kZUluZGljZXNBcnJheSgpe2xldCB0PXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNCk7cmV0dXJuIHQ/bmV3IFVpbnQzMkFycmF5KHRoaXMuYmIuYnl0ZXMoKS5idWZmZXIsdGhpcy5iYi5ieXRlcygpLmJ5dGVPZmZzZXQrdGhpcy5iYi5fX3ZlY3Rvcih0aGlzLmJiX3Bvcyt0KSx0aGlzLmJiLl9fdmVjdG9yX2xlbih0aGlzLmJiX3Bvcyt0KSk6bnVsbH1rZXJuZWxEZWZIYXNoZXModCl7bGV0IGU9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw2KTtyZXR1cm4gZT90aGlzLmJiLnJlYWRVaW50NjQodGhpcy5iYi5fX3ZlY3Rvcih0aGlzLmJiX3BvcytlKSs4KnQpOnRoaXMuYmIuY3JlYXRlTG9uZygwLDApfWtlcm5lbERlZkhhc2hlc0xlbmd0aCgpe2xldCB0PXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNik7cmV0dXJuIHQ/dGhpcy5iYi5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MrdCk6MH1zdGF0aWMgc3RhcnRLZXJuZWxDcmVhdGVJbmZvcyh0KXt0LnN0YXJ0T2JqZWN0KDIpfXN0YXRpYyBhZGROb2RlSW5kaWNlcyh0LGUpe3QuYWRkRmllbGRPZmZzZXQoMCxlLDApfXN0YXRpYyBjcmVhdGVOb2RlSW5kaWNlc1ZlY3Rvcih0LGUpe3Quc3RhcnRWZWN0b3IoNCxlLmxlbmd0aCw0KTtmb3IobGV0IG49ZS5sZW5ndGgtMTtuPj0wO24tLSl0LmFkZEludDMyKGVbbl0pO3JldHVybiB0LmVuZFZlY3RvcigpfXN0YXRpYyBzdGFydE5vZGVJbmRpY2VzVmVjdG9yKHQsZSl7dC5zdGFydFZlY3Rvcig0LGUsNCl9c3RhdGljIGFkZEtlcm5lbERlZkhhc2hlcyh0LGUpe3QuYWRkRmllbGRPZmZzZXQoMSxlLDApfXN0YXRpYyBjcmVhdGVLZXJuZWxEZWZIYXNoZXNWZWN0b3IodCxlKXt0LnN0YXJ0VmVjdG9yKDgsZS5sZW5ndGgsOCk7Zm9yKGxldCBuPWUubGVuZ3RoLTE7bj49MDtuLS0pdC5hZGRJbnQ2NChlW25dKTtyZXR1cm4gdC5lbmRWZWN0b3IoKX1zdGF0aWMgc3RhcnRLZXJuZWxEZWZIYXNoZXNWZWN0b3IodCxlKXt0LnN0YXJ0VmVjdG9yKDgsZSw4KX1zdGF0aWMgZW5kS2VybmVsQ3JlYXRlSW5mb3ModCl7cmV0dXJuIHQuZW5kT2JqZWN0KCl9c3RhdGljIGNyZWF0ZUtlcm5lbENyZWF0ZUluZm9zKHQsbixyKXtyZXR1cm4gZS5zdGFydEtlcm5lbENyZWF0ZUluZm9zKHQpLGUuYWRkTm9kZUluZGljZXModCxuKSxlLmFkZEtlcm5lbERlZkhhc2hlcyh0LHIpLGUuZW5kS2VybmVsQ3JlYXRlSW5mb3ModCl9fXQuS2VybmVsQ3JlYXRlSW5mb3M9ZX0odC5mYnN8fCh0LmZicz17fSkpfSh0LmV4cGVyaW1lbnRhbHx8KHQuZXhwZXJpbWVudGFsPXt9KSl9KGUub25ueHJ1bnRpbWV8fChlLm9ubnhydW50aW1lPXt9KSksZnVuY3Rpb24odCl7IWZ1bmN0aW9uKGUpeyFmdW5jdGlvbihlKXtjbGFzcyBue2NvbnN0cnVjdG9yKCl7dGhpcy5iYj1udWxsLHRoaXMuYmJfcG9zPTB9X19pbml0KHQsZSl7cmV0dXJuIHRoaXMuYmJfcG9zPXQsdGhpcy5iYj1lLHRoaXN9c3RhdGljIGdldFJvb3RBc1N1YkdyYXBoU2Vzc2lvblN0YXRlKHQsZSl7cmV0dXJuKGV8fG5ldyBuKS5fX2luaXQodC5yZWFkSW50MzIodC5wb3NpdGlvbigpKSt0LnBvc2l0aW9uKCksdCl9c3RhdGljIGdldFNpemVQcmVmaXhlZFJvb3RBc1N1YkdyYXBoU2Vzc2lvblN0YXRlKHQsZSl7cmV0dXJuIHQuc2V0UG9zaXRpb24odC5wb3NpdGlvbigpK3IuZmxhdGJ1ZmZlcnMuU0laRV9QUkVGSVhfTEVOR1RIKSwoZXx8bmV3IG4pLl9faW5pdCh0LnJlYWRJbnQzMih0LnBvc2l0aW9uKCkpK3QucG9zaXRpb24oKSx0KX1ncmFwaElkKHQpe2xldCBlPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNCk7cmV0dXJuIGU/dGhpcy5iYi5fX3N0cmluZyh0aGlzLmJiX3BvcytlLHQpOm51bGx9c2Vzc2lvblN0YXRlKGUpe2xldCBuPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNik7cmV0dXJuIG4/KGV8fG5ldyB0LmV4cGVyaW1lbnRhbC5mYnMuU2Vzc2lvblN0YXRlKS5fX2luaXQodGhpcy5iYi5fX2luZGlyZWN0KHRoaXMuYmJfcG9zK24pLHRoaXMuYmIpOm51bGx9c3RhdGljIHN0YXJ0U3ViR3JhcGhTZXNzaW9uU3RhdGUodCl7dC5zdGFydE9iamVjdCgyKX1zdGF0aWMgYWRkR3JhcGhJZCh0LGUpe3QuYWRkRmllbGRPZmZzZXQoMCxlLDApfXN0YXRpYyBhZGRTZXNzaW9uU3RhdGUodCxlKXt0LmFkZEZpZWxkT2Zmc2V0KDEsZSwwKX1zdGF0aWMgZW5kU3ViR3JhcGhTZXNzaW9uU3RhdGUodCl7bGV0IGU9dC5lbmRPYmplY3QoKTtyZXR1cm4gdC5yZXF1aXJlZEZpZWxkKGUsNCksZX1zdGF0aWMgY3JlYXRlU3ViR3JhcGhTZXNzaW9uU3RhdGUodCxlLHIpe3JldHVybiBuLnN0YXJ0U3ViR3JhcGhTZXNzaW9uU3RhdGUodCksbi5hZGRHcmFwaElkKHQsZSksbi5hZGRTZXNzaW9uU3RhdGUodCxyKSxuLmVuZFN1YkdyYXBoU2Vzc2lvblN0YXRlKHQpfX1lLlN1YkdyYXBoU2Vzc2lvblN0YXRlPW59KGUuZmJzfHwoZS5mYnM9e30pKX0odC5leHBlcmltZW50YWx8fCh0LmV4cGVyaW1lbnRhbD17fSkpfShlLm9ubnhydW50aW1lfHwoZS5vbm54cnVudGltZT17fSkpLGZ1bmN0aW9uKHQpeyFmdW5jdGlvbihlKXshZnVuY3Rpb24oZSl7Y2xhc3Mgbntjb25zdHJ1Y3Rvcigpe3RoaXMuYmI9bnVsbCx0aGlzLmJiX3Bvcz0wfV9faW5pdCh0LGUpe3JldHVybiB0aGlzLmJiX3Bvcz10LHRoaXMuYmI9ZSx0aGlzfXN0YXRpYyBnZXRSb290QXNTZXNzaW9uU3RhdGUodCxlKXtyZXR1cm4oZXx8bmV3IG4pLl9faW5pdCh0LnJlYWRJbnQzMih0LnBvc2l0aW9uKCkpK3QucG9zaXRpb24oKSx0KX1zdGF0aWMgZ2V0U2l6ZVByZWZpeGVkUm9vdEFzU2Vzc2lvblN0YXRlKHQsZSl7cmV0dXJuIHQuc2V0UG9zaXRpb24odC5wb3NpdGlvbigpK3IuZmxhdGJ1ZmZlcnMuU0laRV9QUkVGSVhfTEVOR1RIKSwoZXx8bmV3IG4pLl9faW5pdCh0LnJlYWRJbnQzMih0LnBvc2l0aW9uKCkpK3QucG9zaXRpb24oKSx0KX1rZXJuZWxzKGUpe2xldCBuPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNCk7cmV0dXJuIG4/KGV8fG5ldyB0LmV4cGVyaW1lbnRhbC5mYnMuS2VybmVsQ3JlYXRlSW5mb3MpLl9faW5pdCh0aGlzLmJiLl9faW5kaXJlY3QodGhpcy5iYl9wb3MrbiksdGhpcy5iYik6bnVsbH1zdWJHcmFwaFNlc3Npb25TdGF0ZXMoZSxuKXtsZXQgcj10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDYpO3JldHVybiByPyhufHxuZXcgdC5leHBlcmltZW50YWwuZmJzLlN1YkdyYXBoU2Vzc2lvblN0YXRlKS5fX2luaXQodGhpcy5iYi5fX2luZGlyZWN0KHRoaXMuYmIuX192ZWN0b3IodGhpcy5iYl9wb3MrcikrNCplKSx0aGlzLmJiKTpudWxsfXN1YkdyYXBoU2Vzc2lvblN0YXRlc0xlbmd0aCgpe2xldCB0PXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNik7cmV0dXJuIHQ/dGhpcy5iYi5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MrdCk6MH1zdGF0aWMgc3RhcnRTZXNzaW9uU3RhdGUodCl7dC5zdGFydE9iamVjdCgyKX1zdGF0aWMgYWRkS2VybmVscyh0LGUpe3QuYWRkRmllbGRPZmZzZXQoMCxlLDApfXN0YXRpYyBhZGRTdWJHcmFwaFNlc3Npb25TdGF0ZXModCxlKXt0LmFkZEZpZWxkT2Zmc2V0KDEsZSwwKX1zdGF0aWMgY3JlYXRlU3ViR3JhcGhTZXNzaW9uU3RhdGVzVmVjdG9yKHQsZSl7dC5zdGFydFZlY3Rvcig0LGUubGVuZ3RoLDQpO2ZvcihsZXQgbj1lLmxlbmd0aC0xO24+PTA7bi0tKXQuYWRkT2Zmc2V0KGVbbl0pO3JldHVybiB0LmVuZFZlY3RvcigpfXN0YXRpYyBzdGFydFN1YkdyYXBoU2Vzc2lvblN0YXRlc1ZlY3Rvcih0LGUpe3Quc3RhcnRWZWN0b3IoNCxlLDQpfXN0YXRpYyBlbmRTZXNzaW9uU3RhdGUodCl7cmV0dXJuIHQuZW5kT2JqZWN0KCl9c3RhdGljIGNyZWF0ZVNlc3Npb25TdGF0ZSh0LGUscil7cmV0dXJuIG4uc3RhcnRTZXNzaW9uU3RhdGUodCksbi5hZGRLZXJuZWxzKHQsZSksbi5hZGRTdWJHcmFwaFNlc3Npb25TdGF0ZXModCxyKSxuLmVuZFNlc3Npb25TdGF0ZSh0KX19ZS5TZXNzaW9uU3RhdGU9bn0oZS5mYnN8fChlLmZicz17fSkpfSh0LmV4cGVyaW1lbnRhbHx8KHQuZXhwZXJpbWVudGFsPXt9KSl9KGUub25ueHJ1bnRpbWV8fChlLm9ubnhydW50aW1lPXt9KSksZnVuY3Rpb24odCl7IWZ1bmN0aW9uKGUpeyFmdW5jdGlvbihlKXtjbGFzcyBue2NvbnN0cnVjdG9yKCl7dGhpcy5iYj1udWxsLHRoaXMuYmJfcG9zPTB9X19pbml0KHQsZSl7cmV0dXJuIHRoaXMuYmJfcG9zPXQsdGhpcy5iYj1lLHRoaXN9c3RhdGljIGdldFJvb3RBc0luZmVyZW5jZVNlc3Npb24odCxlKXtyZXR1cm4oZXx8bmV3IG4pLl9faW5pdCh0LnJlYWRJbnQzMih0LnBvc2l0aW9uKCkpK3QucG9zaXRpb24oKSx0KX1zdGF0aWMgZ2V0U2l6ZVByZWZpeGVkUm9vdEFzSW5mZXJlbmNlU2Vzc2lvbih0LGUpe3JldHVybiB0LnNldFBvc2l0aW9uKHQucG9zaXRpb24oKStyLmZsYXRidWZmZXJzLlNJWkVfUFJFRklYX0xFTkdUSCksKGV8fG5ldyBuKS5fX2luaXQodC5yZWFkSW50MzIodC5wb3NpdGlvbigpKSt0LnBvc2l0aW9uKCksdCl9c3RhdGljIGJ1ZmZlckhhc0lkZW50aWZpZXIodCl7cmV0dXJuIHQuX19oYXNfaWRlbnRpZmllcihcIk9SVE1cIil9b3J0VmVyc2lvbih0KXtsZXQgZT10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDQpO3JldHVybiBlP3RoaXMuYmIuX19zdHJpbmcodGhpcy5iYl9wb3MrZSx0KTpudWxsfW1vZGVsKGUpe2xldCBuPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNik7cmV0dXJuIG4/KGV8fG5ldyB0LmV4cGVyaW1lbnRhbC5mYnMuTW9kZWwpLl9faW5pdCh0aGlzLmJiLl9faW5kaXJlY3QodGhpcy5iYl9wb3MrbiksdGhpcy5iYik6bnVsbH1zZXNzaW9uU3RhdGUoZSl7bGV0IG49dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw4KTtyZXR1cm4gbj8oZXx8bmV3IHQuZXhwZXJpbWVudGFsLmZicy5TZXNzaW9uU3RhdGUpLl9faW5pdCh0aGlzLmJiLl9faW5kaXJlY3QodGhpcy5iYl9wb3MrbiksdGhpcy5iYik6bnVsbH1zdGF0aWMgc3RhcnRJbmZlcmVuY2VTZXNzaW9uKHQpe3Quc3RhcnRPYmplY3QoMyl9c3RhdGljIGFkZE9ydFZlcnNpb24odCxlKXt0LmFkZEZpZWxkT2Zmc2V0KDAsZSwwKX1zdGF0aWMgYWRkTW9kZWwodCxlKXt0LmFkZEZpZWxkT2Zmc2V0KDEsZSwwKX1zdGF0aWMgYWRkU2Vzc2lvblN0YXRlKHQsZSl7dC5hZGRGaWVsZE9mZnNldCgyLGUsMCl9c3RhdGljIGVuZEluZmVyZW5jZVNlc3Npb24odCl7cmV0dXJuIHQuZW5kT2JqZWN0KCl9c3RhdGljIGZpbmlzaEluZmVyZW5jZVNlc3Npb25CdWZmZXIodCxlKXt0LmZpbmlzaChlLFwiT1JUTVwiKX1zdGF0aWMgZmluaXNoU2l6ZVByZWZpeGVkSW5mZXJlbmNlU2Vzc2lvbkJ1ZmZlcih0LGUpe3QuZmluaXNoKGUsXCJPUlRNXCIsITApfXN0YXRpYyBjcmVhdGVJbmZlcmVuY2VTZXNzaW9uKHQsZSxyLGkpe3JldHVybiBuLnN0YXJ0SW5mZXJlbmNlU2Vzc2lvbih0KSxuLmFkZE9ydFZlcnNpb24odCxlKSxuLmFkZE1vZGVsKHQsciksbi5hZGRTZXNzaW9uU3RhdGUodCxpKSxuLmVuZEluZmVyZW5jZVNlc3Npb24odCl9fWUuSW5mZXJlbmNlU2Vzc2lvbj1ufShlLmZic3x8KGUuZmJzPXt9KSl9KHQuZXhwZXJpbWVudGFsfHwodC5leHBlcmltZW50YWw9e30pKX0oZS5vbm54cnVudGltZXx8KGUub25ueHJ1bnRpbWU9e30pKX0sNzQ0ODoodCxlLG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5Pbm54anNTZXNzaW9uSGFuZGxlcj12b2lkIDA7Y29uc3Qgcj1uKDE2NzApLGk9big5MTYyKTtlLk9ubnhqc1Nlc3Npb25IYW5kbGVyPWNsYXNze2NvbnN0cnVjdG9yKHQpe3RoaXMuc2Vzc2lvbj10LHRoaXMuaW5wdXROYW1lcz10aGlzLnNlc3Npb24uaW5wdXROYW1lcyx0aGlzLm91dHB1dE5hbWVzPXRoaXMuc2Vzc2lvbi5vdXRwdXROYW1lc31hc3luYyBkaXNwb3NlKCl7fWFzeW5jIHJ1bih0LGUsbil7Y29uc3Qgbz1uZXcgTWFwO2Zvcihjb25zdCBlIGluIHQpaWYoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwodCxlKSl7Y29uc3Qgbj10W2VdO28uc2V0KGUsbmV3IGkuVGVuc29yKG4uZGltcyxuLnR5cGUsdm9pZCAwLHZvaWQgMCxuLmRhdGEpKX1jb25zdCBhPWF3YWl0IHRoaXMuc2Vzc2lvbi5ydW4obykscz17fTtyZXR1cm4gYS5mb3JFYWNoKCgodCxlKT0+e3NbZV09bmV3IHIuVGVuc29yKHQudHlwZSx0LmRhdGEsdC5kaW1zKX0pKSxzfXN0YXJ0UHJvZmlsaW5nKCl7dGhpcy5zZXNzaW9uLnN0YXJ0UHJvZmlsaW5nKCl9ZW5kUHJvZmlsaW5nKCl7dGhpcy5zZXNzaW9uLmVuZFByb2ZpbGluZygpfX19LDY5MTk6KHQsZSxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUuU2Vzc2lvbj12b2lkIDA7Y29uc3Qgcj1uKDcwNjcpLGk9bigxMjk2KSxvPW4oNzA5MSksYT1uKDEwMzYpLHM9big2MjMxKSx1PW4oMjY0NCk7ZS5TZXNzaW9uPWNsYXNze2NvbnN0cnVjdG9yKHQ9e30pe3RoaXMuX2luaXRpYWxpemVkPSExLHRoaXMuYmFja2VuZEhpbnQ9dC5iYWNrZW5kSGludCx0aGlzLnByb2ZpbGVyPXMuUHJvZmlsZXIuY3JlYXRlKHQucHJvZmlsZXIpLHRoaXMuY29udGV4dD17cHJvZmlsZXI6dGhpcy5wcm9maWxlcixncmFwaElucHV0VHlwZXM6W10sZ3JhcGhJbnB1dERpbXM6W119fWdldCBpbnB1dE5hbWVzKCl7cmV0dXJuIHRoaXMuX21vZGVsLmdyYXBoLmdldElucHV0TmFtZXMoKX1nZXQgb3V0cHV0TmFtZXMoKXtyZXR1cm4gdGhpcy5fbW9kZWwuZ3JhcGguZ2V0T3V0cHV0TmFtZXMoKX1zdGFydFByb2ZpbGluZygpe3RoaXMucHJvZmlsZXIuc3RhcnQoKX1lbmRQcm9maWxpbmcoKXt0aGlzLnByb2ZpbGVyLnN0b3AoKX1hc3luYyBsb2FkTW9kZWwodCxlLG4pe2F3YWl0IHRoaXMucHJvZmlsZXIuZXZlbnQoXCJzZXNzaW9uXCIsXCJTZXNzaW9uLmxvYWRNb2RlbFwiLChhc3luYygpPT57Y29uc3QgYT1hd2FpdCgwLG8ucmVzb2x2ZUJhY2tlbmQpKHRoaXMuYmFja2VuZEhpbnQpO2lmKHRoaXMuc2Vzc2lvbkhhbmRsZXI9YS5jcmVhdGVTZXNzaW9uSGFuZGxlcih0aGlzLmNvbnRleHQpLHRoaXMuX21vZGVsPW5ldyB1Lk1vZGVsLFwic3RyaW5nXCI9PXR5cGVvZiB0KXtjb25zdCBlPXQuZW5kc1dpdGgoXCIub3J0XCIpO2lmKFwidW5kZWZpbmVkXCI9PXR5cGVvZiBmZXRjaCl7Y29uc3Qgbj1hd2FpdCgwLGkucHJvbWlzaWZ5KShyLnJlYWRGaWxlKSh0KTt0aGlzLmluaXRpYWxpemUobixlKX1lbHNle2NvbnN0IG49YXdhaXQgZmV0Y2godCkscj1hd2FpdCBuLmFycmF5QnVmZmVyKCk7dGhpcy5pbml0aWFsaXplKG5ldyBVaW50OEFycmF5KHIpLGUpfX1lbHNlIGlmKEFycmF5QnVmZmVyLmlzVmlldyh0KSl0aGlzLmluaXRpYWxpemUodCk7ZWxzZXtjb25zdCByPW5ldyBVaW50OEFycmF5KHQsZXx8MCxufHx0LmJ5dGVMZW5ndGgpO3RoaXMuaW5pdGlhbGl6ZShyKX19KSl9aW5pdGlhbGl6ZSh0LGUpe2lmKHRoaXMuX2luaXRpYWxpemVkKXRocm93IG5ldyBFcnJvcihcImFscmVhZHkgaW5pdGlhbGl6ZWRcIik7dGhpcy5wcm9maWxlci5ldmVudChcInNlc3Npb25cIixcIlNlc3Npb24uaW5pdGlhbGl6ZVwiLCgoKT0+e2NvbnN0IG49dGhpcy5zZXNzaW9uSGFuZGxlci50cmFuc2Zvcm1HcmFwaD90aGlzLnNlc3Npb25IYW5kbGVyOnZvaWQgMDt0aGlzLl9tb2RlbC5sb2FkKHQsbixlKSx0aGlzLnNlc3Npb25IYW5kbGVyLm9uR3JhcGhJbml0aWFsaXplZCYmdGhpcy5zZXNzaW9uSGFuZGxlci5vbkdyYXBoSW5pdGlhbGl6ZWQodGhpcy5fbW9kZWwuZ3JhcGgpLHRoaXMuaW5pdGlhbGl6ZU9wcyh0aGlzLl9tb2RlbC5ncmFwaCksdGhpcy5fZXhlY3V0aW9uUGxhbj1uZXcgYS5FeGVjdXRpb25QbGFuKHRoaXMuX21vZGVsLmdyYXBoLHRoaXMuX29wcyx0aGlzLnByb2ZpbGVyKX0pKSx0aGlzLl9pbml0aWFsaXplZD0hMH1hc3luYyBydW4odCl7aWYoIXRoaXMuX2luaXRpYWxpemVkKXRocm93IG5ldyBFcnJvcihcInNlc3Npb24gbm90IGluaXRpYWxpemVkIHlldFwiKTtyZXR1cm4gdGhpcy5wcm9maWxlci5ldmVudChcInNlc3Npb25cIixcIlNlc3Npb24ucnVuXCIsKGFzeW5jKCk9Pntjb25zdCBlPXRoaXMubm9ybWFsaXplQW5kVmFsaWRhdGVJbnB1dHModCksbj1hd2FpdCB0aGlzLl9leGVjdXRpb25QbGFuLmV4ZWN1dGUodGhpcy5zZXNzaW9uSGFuZGxlcixlKTtyZXR1cm4gdGhpcy5jcmVhdGVPdXRwdXQobil9KSl9bm9ybWFsaXplQW5kVmFsaWRhdGVJbnB1dHModCl7Y29uc3QgZT10aGlzLl9tb2RlbC5ncmFwaC5nZXRJbnB1dE5hbWVzKCk7aWYoQXJyYXkuaXNBcnJheSh0KSl7aWYodC5sZW5ndGghPT1lLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoYGluY29ycmVjdCBpbnB1dCBhcnJheSBsZW5ndGg6IGV4cGVjdGVkICR7ZS5sZW5ndGh9IGJ1dCBnb3QgJHt0Lmxlbmd0aH1gKX1lbHNle2lmKHQuc2l6ZSE9PWUubGVuZ3RoKXRocm93IG5ldyBFcnJvcihgaW5jb3JyZWN0IGlucHV0IG1hcCBzaXplOiBleHBlY3RlZCAke2UubGVuZ3RofSBidXQgZ290ICR7dC5zaXplfWApO2NvbnN0IG49bmV3IEFycmF5KHQuc2l6ZSk7bGV0IHI9MDtmb3IobGV0IGk9MDtpPGUubGVuZ3RoOysraSl7Y29uc3Qgbz10LmdldChlW2ldKTtpZighbyl0aHJvdyBuZXcgRXJyb3IoYG1pc3NpbmcgaW5wdXQgdGVuc29yIGZvcjogJyR7bmFtZX0nYCk7bltyKytdPW99dD1ufWlmKHRoaXMuY29udGV4dC5ncmFwaElucHV0VHlwZXMmJjAhPT10aGlzLmNvbnRleHQuZ3JhcGhJbnB1dFR5cGVzLmxlbmd0aCYmdGhpcy5jb250ZXh0LmdyYXBoSW5wdXREaW1zJiYwIT09dGhpcy5jb250ZXh0LmdyYXBoSW5wdXREaW1zLmxlbmd0aCl0aGlzLnZhbGlkYXRlSW5wdXRUZW5zb3JEaW1zKHRoaXMuY29udGV4dC5ncmFwaElucHV0RGltcyx0LCExKTtlbHNle2NvbnN0IGU9dGhpcy5fbW9kZWwuZ3JhcGguZ2V0SW5wdXRJbmRpY2VzKCksbj10aGlzLl9tb2RlbC5ncmFwaC5nZXRWYWx1ZXMoKSxyPW5ldyBBcnJheShlLmxlbmd0aCk7Zm9yKGxldCBpPTA7aTxlLmxlbmd0aDsrK2kpe2NvbnN0IG89bltlW2ldXTtyW2ldPW8udHlwZS5zaGFwZS5kaW1zLHRoaXMuY29udGV4dC5ncmFwaElucHV0VHlwZXMucHVzaChvLnR5cGUudGVuc29yVHlwZSksdGhpcy5jb250ZXh0LmdyYXBoSW5wdXREaW1zLnB1c2godFtpXS5kaW1zKX10aGlzLnZhbGlkYXRlSW5wdXRUZW5zb3JEaW1zKHIsdCwhMCl9cmV0dXJuIHRoaXMudmFsaWRhdGVJbnB1dFRlbnNvclR5cGVzKHRoaXMuY29udGV4dC5ncmFwaElucHV0VHlwZXMsdCksdH12YWxpZGF0ZUlucHV0VGVuc29yVHlwZXModCxlKXtmb3IobGV0IG49MDtuPGUubGVuZ3RoO24rKyl7Y29uc3Qgcj10W25dLGk9ZVtuXS50eXBlO2lmKHIhPT1pKXRocm93IG5ldyBFcnJvcihgaW5wdXQgdGVuc29yWyR7bn1dIGNoZWNrIGZhaWxlZDogZXhwZWN0ZWQgdHlwZSAnJHtyfScgYnV0IGdvdCAke2l9YCl9fXZhbGlkYXRlSW5wdXRUZW5zb3JEaW1zKHQsZSxuKXtmb3IobGV0IHI9MDtyPGUubGVuZ3RoO3IrKyl7Y29uc3QgaT10W3JdLG89ZVtyXS5kaW1zO2lmKCF0aGlzLmNvbXBhcmVUZW5zb3JEaW1zKGksbyxuKSl0aHJvdyBuZXcgRXJyb3IoYGlucHV0IHRlbnNvclske3J9XSBjaGVjayBmYWlsZWQ6IGV4cGVjdGVkIHNoYXBlICdbJHtpLmpvaW4oXCIsXCIpfV0nIGJ1dCBnb3QgWyR7by5qb2luKFwiLFwiKX1dYCl9fWNvbXBhcmVUZW5zb3JEaW1zKHQsZSxuKXtpZih0Lmxlbmd0aCE9PWUubGVuZ3RoKXJldHVybiExO2ZvcihsZXQgcj0wO3I8dC5sZW5ndGg7KytyKWlmKHRbcl0hPT1lW3JdJiYoIW58fDAhPT10W3JdKSlyZXR1cm4hMTtyZXR1cm4hMH1jcmVhdGVPdXRwdXQodCl7Y29uc3QgZT10aGlzLl9tb2RlbC5ncmFwaC5nZXRPdXRwdXROYW1lcygpO2lmKHQubGVuZ3RoIT09ZS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiZXhwZWN0ZWQgbnVtYmVyIG9mIG91dHB1dHMgZG8gbm90IG1hdGNoIG51bWJlciBvZiBnZW5lcmF0ZWQgb3V0cHV0c1wiKTtjb25zdCBuPW5ldyBNYXA7Zm9yKGxldCByPTA7cjxlLmxlbmd0aDsrK3Ipbi5zZXQoZVtyXSx0W3JdKTtyZXR1cm4gbn1pbml0aWFsaXplT3BzKHQpe2NvbnN0IGU9dC5nZXROb2RlcygpO3RoaXMuX29wcz1uZXcgQXJyYXkoZS5sZW5ndGgpO2ZvcihsZXQgbj0wO248ZS5sZW5ndGg7bisrKXRoaXMuX29wc1tuXT10aGlzLnNlc3Npb25IYW5kbGVyLnJlc29sdmUoZVtuXSx0aGlzLl9tb2RlbC5vcHNldHMsdCl9fX0sOTE2MjpmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7dmFyIHI9dGhpcyYmdGhpcy5fX2ltcG9ydERlZmF1bHR8fGZ1bmN0aW9uKHQpe3JldHVybiB0JiZ0Ll9fZXNNb2R1bGU/dDp7ZGVmYXVsdDp0fX07T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5UZW5zb3I9dm9pZCAwO2NvbnN0IGk9bigzNDQyKSxvPXIobigzNzIwKSksYT1uKDE0NDYpLHM9big5Mzk1KSx1PW4oMjUxNyk7dmFyIGM9cy5vbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzO2NsYXNzIGx7Z2V0IGRhdGEoKXtpZih2b2lkIDA9PT10aGlzLmNhY2hlKXtjb25zdCB0PXRoaXMuZGF0YVByb3ZpZGVyKHRoaXMuZGF0YUlkKTtpZih0Lmxlbmd0aCE9PXRoaXMuc2l6ZSl0aHJvdyBuZXcgRXJyb3IoXCJMZW5ndGggb2YgZGF0YSBwcm92aWRlZCBieSB0aGUgRGF0YSBQcm92aWRlciBpcyBpbmNvbnNpc3RlbnQgd2l0aCB0aGUgZGltcyBvZiB0aGlzIFRlbnNvci5cIik7dGhpcy5jYWNoZT10fXJldHVybiB0aGlzLmNhY2hlfWdldCBzdHJpbmdEYXRhKCl7aWYoXCJzdHJpbmdcIiE9PXRoaXMudHlwZSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiZGF0YSB0eXBlIGlzIG5vdCBzdHJpbmdcIik7cmV0dXJuIHRoaXMuZGF0YX1nZXQgaW50ZWdlckRhdGEoKXtzd2l0Y2godGhpcy50eXBlKXtjYXNlXCJ1aW50OFwiOmNhc2VcImludDhcIjpjYXNlXCJ1aW50MTZcIjpjYXNlXCJpbnQxNlwiOmNhc2VcImludDMyXCI6Y2FzZVwidWludDMyXCI6Y2FzZVwiYm9vbFwiOnJldHVybiB0aGlzLmRhdGE7ZGVmYXVsdDp0aHJvdyBuZXcgVHlwZUVycm9yKFwiZGF0YSB0eXBlIGlzIG5vdCBpbnRlZ2VyICh1aW50OCwgaW50OCwgdWludDE2LCBpbnQxNiwgaW50MzIsIHVpbnQzMiwgYm9vbClcIil9fWdldCBmbG9hdERhdGEoKXtzd2l0Y2godGhpcy50eXBlKXtjYXNlXCJmbG9hdDMyXCI6Y2FzZVwiZmxvYXQ2NFwiOnJldHVybiB0aGlzLmRhdGE7ZGVmYXVsdDp0aHJvdyBuZXcgVHlwZUVycm9yKFwiZGF0YSB0eXBlIGlzIG5vdCBmbG9hdCAoZmxvYXQzMiwgZmxvYXQ2NClcIil9fWdldCBudW1iZXJEYXRhKCl7aWYoXCJzdHJpbmdcIiE9PXRoaXMudHlwZSlyZXR1cm4gdGhpcy5kYXRhO3Rocm93IG5ldyBUeXBlRXJyb3IoXCJ0eXBlIGNhbm5vdCBiZSBub24tbnVtYmVyIChzdHJpbmcpXCIpfWdldCh0KXtyZXR1cm4gdGhpcy5kYXRhW3UuU2hhcGVVdGlsLmluZGljZXNUb09mZnNldCh0LHRoaXMuc3RyaWRlcyldfXNldCh0LGUpe3RoaXMuZGF0YVt1LlNoYXBlVXRpbC5pbmRpY2VzVG9PZmZzZXQodCx0aGlzLnN0cmlkZXMpXT1lfWFzeW5jIGdldERhdGEoKXtyZXR1cm4gdm9pZCAwPT09dGhpcy5jYWNoZSYmKHRoaXMuY2FjaGU9YXdhaXQgdGhpcy5hc3luY0RhdGFQcm92aWRlcih0aGlzLmRhdGFJZCkpLHRoaXMuY2FjaGV9Z2V0IHN0cmlkZXMoKXtyZXR1cm4gdGhpcy5fc3RyaWRlc3x8KHRoaXMuX3N0cmlkZXM9dS5TaGFwZVV0aWwuY29tcHV0ZVN0cmlkZXModGhpcy5kaW1zKSksdGhpcy5fc3RyaWRlc31jb25zdHJ1Y3Rvcih0LGUsbixyLG8sYT1pLkd1aWQuY3JlYXRlKCkpe3RoaXMuZGltcz10LHRoaXMudHlwZT1lLHRoaXMuZGF0YVByb3ZpZGVyPW4sdGhpcy5hc3luY0RhdGFQcm92aWRlcj1yLHRoaXMuY2FjaGU9byx0aGlzLmRhdGFJZD1hLHRoaXMuc2l6ZT11LlNoYXBlVXRpbC52YWxpZGF0ZURpbXNBbmRDYWxjU2l6ZSh0KTtjb25zdCBzPXRoaXMuc2l6ZSxjPXZvaWQgMD09PW4mJnZvaWQgMD09PXImJnZvaWQgMD09PW87aWYodm9pZCAwIT09byYmby5sZW5ndGghPT1zKXRocm93IG5ldyBSYW5nZUVycm9yKFwiSW5wdXQgZGltcyBkb2Vzbid0IG1hdGNoIGRhdGEgbGVuZ3RoLlwiKTtpZihcInN0cmluZ1wiPT09ZSl7aWYoISh2b2lkIDA9PT1vfHxBcnJheS5pc0FycmF5KG8pJiZvLmV2ZXJ5KCh0PT5cInN0cmluZ1wiPT10eXBlb2YgdCkpKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiY2FjaGUgc2hvdWxkIGJlIGEgc3RyaW5nIGFycmF5XCIpO2MmJih0aGlzLmNhY2hlPW5ldyBBcnJheShzKSl9ZWxzZXtpZih2b2lkIDAhPT1vKXtjb25zdCB0PWYoZSk7aWYoIShvIGluc3RhbmNlb2YgdCkpdGhyb3cgbmV3IFR5cGVFcnJvcihgY2FjaGUgc2hvdWxkIGJlIHR5cGUgJHt0Lm5hbWV9YCl9aWYoYyl7Y29uc3QgdD1uZXcgQXJyYXlCdWZmZXIocypmdW5jdGlvbih0KXtzd2l0Y2godCl7Y2FzZVwiYm9vbFwiOmNhc2VcImludDhcIjpjYXNlXCJ1aW50OFwiOnJldHVybiAxO2Nhc2VcImludDE2XCI6Y2FzZVwidWludDE2XCI6cmV0dXJuIDI7Y2FzZVwiaW50MzJcIjpjYXNlXCJ1aW50MzJcIjpjYXNlXCJmbG9hdDMyXCI6cmV0dXJuIDQ7Y2FzZVwiZmxvYXQ2NFwiOnJldHVybiA4O2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBjYW5ub3QgY2FsY3VsYXRlIHNpemVvZigpIG9uIHR5cGUgJHt0fWApfX0oZSkpO3RoaXMuY2FjaGU9ZnVuY3Rpb24odCxlKXtyZXR1cm4gbmV3KGYoZSkpKHQpfSh0LGUpfX19c3RhdGljIGZyb21Qcm90byh0KXtpZighdCl0aHJvdyBuZXcgRXJyb3IoXCJjYW5ub3QgY29uc3RydWN0IFZhbHVlIGZyb20gYW4gZW1wdHkgdGVuc29yXCIpO2NvbnN0IGU9dS5Qcm90b1V0aWwudGVuc29yRGF0YVR5cGVGcm9tUHJvdG8odC5kYXRhVHlwZSksbj11LlByb3RvVXRpbC50ZW5zb3JEaW1zRnJvbVByb3RvKHQuZGltcykscj1uZXcgbChuLGUpO2lmKFwic3RyaW5nXCI9PT1lKXQuc3RyaW5nRGF0YS5mb3JFYWNoKCgodCxlKT0+e3IuZGF0YVtlXT0oMCx1LmRlY29kZVV0ZjhTdHJpbmcpKHQpfSkpO2Vsc2UgaWYodC5yYXdEYXRhJiZcIm51bWJlclwiPT10eXBlb2YgdC5yYXdEYXRhLmJ5dGVMZW5ndGgmJnQucmF3RGF0YS5ieXRlTGVuZ3RoPjApe2NvbnN0IGU9ci5kYXRhLG49bmV3IERhdGFWaWV3KHQucmF3RGF0YS5idWZmZXIsdC5yYXdEYXRhLmJ5dGVPZmZzZXQsdC5yYXdEYXRhLmJ5dGVMZW5ndGgpLGk9cCh0LmRhdGFUeXBlKSxvPXQucmF3RGF0YS5ieXRlTGVuZ3RoL2k7aWYodC5yYXdEYXRhLmJ5dGVMZW5ndGglaSE9MCl0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGJ1ZmZlciBsZW5ndGhcIik7aWYoZS5sZW5ndGghPT1vKXRocm93IG5ldyBFcnJvcihcImJ1ZmZlciBsZW5ndGggbWlzbWF0Y2hcIik7Zm9yKGxldCByPTA7cjxvO3IrKyl7Y29uc3Qgbz1oKG4sdC5kYXRhVHlwZSxyKmkpO2Vbcl09b319ZWxzZXtsZXQgZTtzd2l0Y2godC5kYXRhVHlwZSl7Y2FzZSBhLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuRkxPQVQ6ZT10LmZsb2F0RGF0YTticmVhaztjYXNlIGEub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5JTlQzMjpjYXNlIGEub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5JTlQxNjpjYXNlIGEub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5VSU5UMTY6Y2FzZSBhLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuSU5UODpjYXNlIGEub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5VSU5UODpjYXNlIGEub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5CT09MOmU9dC5pbnQzMkRhdGE7YnJlYWs7Y2FzZSBhLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuSU5UNjQ6ZT10LmludDY0RGF0YTticmVhaztjYXNlIGEub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5ET1VCTEU6ZT10LmRvdWJsZURhdGE7YnJlYWs7Y2FzZSBhLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuVUlOVDMyOmNhc2UgYS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLlVJTlQ2NDplPXQudWludDY0RGF0YTticmVhaztkZWZhdWx0OnRocm93IG5ldyBFcnJvcihcInVuc3BlY2lmaWMgZXJyb3JcIil9aWYobnVsbD09ZSl0aHJvdyBuZXcgRXJyb3IoXCJmYWlsZWQgdG8gcG9wdWxhdGUgZGF0YSBmcm9tIGEgdGVuc29ycHJvdG8gdmFsdWVcIik7Y29uc3Qgbj1yLmRhdGE7aWYobi5sZW5ndGghPT1lLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJhcnJheSBsZW5ndGggbWlzbWF0Y2hcIik7Zm9yKGxldCByPTA7cjxlLmxlbmd0aDtyKyspe2NvbnN0IGk9ZVtyXTtvLmRlZmF1bHQuaXNMb25nKGkpP25bcl09ZChpLHQuZGF0YVR5cGUpOm5bcl09aX19cmV0dXJuIHJ9c3RhdGljIGZyb21EYXRhKHQsZSxuKXtyZXR1cm4gbmV3IGwoZSxuLHZvaWQgMCx2b2lkIDAsdCl9c3RhdGljIGZyb21PcnRUZW5zb3IodCl7aWYoIXQpdGhyb3cgbmV3IEVycm9yKFwiY2Fubm90IGNvbnN0cnVjdCBWYWx1ZSBmcm9tIGFuIGVtcHR5IHRlbnNvclwiKTtjb25zdCBlPXUuUHJvdG9VdGlsLnRlbnNvckRpbXNGcm9tT1JURm9ybWF0KHQpLG49dS5Qcm90b1V0aWwudGVuc29yRGF0YVR5cGVGcm9tUHJvdG8odC5kYXRhVHlwZSgpKSxyPW5ldyBsKGUsbik7aWYoXCJzdHJpbmdcIj09PW4pZm9yKGxldCBlPTA7ZTx0LnN0cmluZ0RhdGFMZW5ndGgoKTtlKyspci5kYXRhW2VdPXQuc3RyaW5nRGF0YShlKTtlbHNlIGlmKHQucmF3RGF0YUFycmF5KCkmJlwibnVtYmVyXCI9PXR5cGVvZiB0LnJhd0RhdGFMZW5ndGgoKSYmdC5yYXdEYXRhTGVuZ3RoKCk+MCl7Y29uc3QgZT1yLmRhdGEsbj1uZXcgRGF0YVZpZXcodC5yYXdEYXRhQXJyYXkoKS5idWZmZXIsdC5yYXdEYXRhQXJyYXkoKS5ieXRlT2Zmc2V0LHQucmF3RGF0YUxlbmd0aCgpKSxpPXAodC5kYXRhVHlwZSgpKSxvPXQucmF3RGF0YUxlbmd0aCgpL2k7aWYodC5yYXdEYXRhTGVuZ3RoKCklaSE9MCl0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGJ1ZmZlciBsZW5ndGhcIik7aWYoZS5sZW5ndGghPT1vKXRocm93IG5ldyBFcnJvcihcImJ1ZmZlciBsZW5ndGggbWlzbWF0Y2hcIik7Zm9yKGxldCByPTA7cjxvO3IrKyl7Y29uc3Qgbz1oKG4sdC5kYXRhVHlwZSgpLHIqaSk7ZVtyXT1vfX1yZXR1cm4gcn19ZnVuY3Rpb24gcCh0KXtzd2l0Y2godCl7Y2FzZSBhLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuVUlOVDg6Y2FzZSBhLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuSU5UODpjYXNlIGEub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5CT09MOnJldHVybiAxO2Nhc2UgYS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLlVJTlQxNjpjYXNlIGEub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5JTlQxNjpyZXR1cm4gMjtjYXNlIGEub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5GTE9BVDpjYXNlIGEub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5JTlQzMjpjYXNlIGEub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5VSU5UMzI6cmV0dXJuIDQ7Y2FzZSBhLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuSU5UNjQ6Y2FzZSBhLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuRE9VQkxFOmNhc2UgYS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLlVJTlQ2NDpyZXR1cm4gODtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgY2Fubm90IGNhbGN1bGF0ZSBzaXplb2YoKSBvbiB0eXBlICR7YS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlW3RdfWApfX1mdW5jdGlvbiBmKHQpe3N3aXRjaCh0KXtjYXNlXCJib29sXCI6Y2FzZVwidWludDhcIjpyZXR1cm4gVWludDhBcnJheTtjYXNlXCJpbnQ4XCI6cmV0dXJuIEludDhBcnJheTtjYXNlXCJpbnQxNlwiOnJldHVybiBJbnQxNkFycmF5O2Nhc2VcInVpbnQxNlwiOnJldHVybiBVaW50MTZBcnJheTtjYXNlXCJpbnQzMlwiOnJldHVybiBJbnQzMkFycmF5O2Nhc2VcInVpbnQzMlwiOnJldHVybiBVaW50MzJBcnJheTtjYXNlXCJmbG9hdDMyXCI6cmV0dXJuIEZsb2F0MzJBcnJheTtjYXNlXCJmbG9hdDY0XCI6cmV0dXJuIEZsb2F0NjRBcnJheTtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihcInVuc3BlY2lmaWVkIGVycm9yXCIpfX1mdW5jdGlvbiBkKHQsZSl7aWYoZT09PWEub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5JTlQ2NHx8ZT09PWMuVGVuc29yRGF0YVR5cGUuSU5UNjQpe2lmKHQuZ3JlYXRlclRoYW5PckVxdWFsKDIxNDc0ODM2NDgpfHx0Lmxlc3NUaGFuKC0yMTQ3NDgzNjQ4KSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW50NjQgaXMgbm90IHN1cHBvcnRlZFwiKX1lbHNle2lmKGUhPT1hLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuVUlOVDMyJiZlIT09Yy5UZW5zb3JEYXRhVHlwZS5VSU5UMzImJmUhPT1hLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuVUlOVDY0JiZlIT09Yy5UZW5zb3JEYXRhVHlwZS5VSU5UNjQpdGhyb3cgbmV3IFR5cGVFcnJvcihgbm90IGEgTE9ORyB0eXBlOiAke2Eub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZVtlXX1gKTtpZih0LmdyZWF0ZXJUaGFuT3JFcXVhbCg0Mjk0OTY3Mjk2KXx8dC5sZXNzVGhhbigwKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwidWludDY0IGlzIG5vdCBzdXBwb3J0ZWRcIil9cmV0dXJuIHQudG9OdW1iZXIoKX1mdW5jdGlvbiBoKHQsZSxuKXtzd2l0Y2goZSl7Y2FzZSBhLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuQk9PTDpjYXNlIGEub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5VSU5UODpyZXR1cm4gdC5nZXRVaW50OChuKTtjYXNlIGEub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5JTlQ4OnJldHVybiB0LmdldEludDgobik7Y2FzZSBhLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuVUlOVDE2OnJldHVybiB0LmdldFVpbnQxNihuLCEwKTtjYXNlIGEub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5JTlQxNjpyZXR1cm4gdC5nZXRJbnQxNihuLCEwKTtjYXNlIGEub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5GTE9BVDpyZXR1cm4gdC5nZXRGbG9hdDMyKG4sITApO2Nhc2UgYS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLklOVDMyOnJldHVybiB0LmdldEludDMyKG4sITApO2Nhc2UgYS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLlVJTlQzMjpyZXR1cm4gdC5nZXRVaW50MzIobiwhMCk7Y2FzZSBhLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuSU5UNjQ6cmV0dXJuIGQoby5kZWZhdWx0LmZyb21CaXRzKHQuZ2V0VWludDMyKG4sITApLHQuZ2V0VWludDMyKG4rNCwhMCksITEpLGUpO2Nhc2UgYS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLkRPVUJMRTpyZXR1cm4gdC5nZXRGbG9hdDY0KG4sITApO2Nhc2UgYS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLlVJTlQ2NDpyZXR1cm4gZChvLmRlZmF1bHQuZnJvbUJpdHModC5nZXRVaW50MzIobiwhMCksdC5nZXRVaW50MzIobis0LCEwKSwhMCksZSk7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYGNhbm5vdCByZWFkIGZyb20gRGF0YVZpZXcgZm9yIHR5cGUgJHthLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGVbZV19YCl9fWUuVGVuc29yPWx9LDI1MTc6ZnVuY3Rpb24odCxlLG4pe1widXNlIHN0cmljdFwiO3ZhciByPXRoaXMmJnRoaXMuX19pbXBvcnREZWZhdWx0fHxmdW5jdGlvbih0KXtyZXR1cm4gdCYmdC5fX2VzTW9kdWxlP3Q6e2RlZmF1bHQ6dH19O09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUuZGVjb2RlVXRmOFN0cmluZz1lLk1BWF9DTElQPWUuTUlOX0NMSVA9ZS5Qb29sQ29udlV0aWw9ZS5SZWR1Y2VVdGlsPWUuU3BsaXRVdGlsPWUuTWF0aFV0aWw9ZS5TaGFwZVV0aWw9ZS5Mb25nVXRpbD1lLlByb3RvVXRpbD1lLkdlbW1VdGlsPWUuYXJyYXlDb3B5SGVscGVyPWUuQnJvYWRjYXN0VXRpbD1lLk1hdE11bFV0aWw9ZS5BcnJheVV0aWw9ZS5hc3NlcnQ9ZS5jaGVja0lucHV0c1NoYXBlPXZvaWQgMDtjb25zdCBpPW4oNTY4Niksbz1yKG4oMzcyMCkpLGE9bigxNDQ2KSxzPW4oOTE2Mik7ZS5jaGVja0lucHV0c1NoYXBlPWZ1bmN0aW9uKHQsLi4uZSl7aWYoIXR8fHQubGVuZ3RoIT09ZS5sZW5ndGgpcmV0dXJuITE7Zm9yKGxldCBuPTA7bjx0Lmxlbmd0aDtuKyspaWYoIXRbbl0uZGltc3x8dFtuXS5kaW1zLmxlbmd0aCE9PWVbbl0pcmV0dXJuITE7cmV0dXJuITB9LGUuYXNzZXJ0PWZ1bmN0aW9uKHQsZSl7aWYoIXQpdGhyb3cgbmV3IEVycm9yKFwic3RyaW5nXCI9PXR5cGVvZiBlP2U6ZSgpKX0sZS5BcnJheVV0aWw9Y2xhc3N7c3RhdGljIGFycmF5c0VxdWFsKHQsZSl7aWYodC5sZW5ndGghPT1lLmxlbmd0aClyZXR1cm4hMTtmb3IobGV0IG49MDtuPHQubGVuZ3RoO24rKylpZih0W25dIT09ZVtuXSlyZXR1cm4hMTtyZXR1cm4hMH19O2NsYXNzIHV7c3RhdGljIHByZXByb2Nlc3NJbnB1dFNoYXBlcyh0LGUpe3JldHVyblsxPT09dC5sZW5ndGg/WzEsdFswXV06dCwxPT09ZS5sZW5ndGg/W2VbMF0sMV06ZV19c3RhdGljIHBvc3Rwcm9jZXNzT3V0cHV0U2hhcGUodCxlLG4pezE9PT1lJiZ0LnNwbGljZSh0Lmxlbmd0aC0yLDEpLDE9PT1uJiZ0LnBvcCgpfXN0YXRpYyBjYWxjTWF0TXVsU2hhcGUodCxlKXtyZXR1cm4gdFsxXSE9PWVbMF0/dm9pZCAwOlt0WzBdLGVbMV1dfX1lLk1hdE11bFV0aWw9dTtjbGFzcyBje3N0YXRpYyBjYWxjU2hhcGUodCxlLG49ITEpe2NvbnN0IHI9dC5sZW5ndGgsaT1lLmxlbmd0aDtpZigwPT09cilyZXR1cm4gZTtpZigwPT09aSlyZXR1cm4gdDtjb25zdCBvPU1hdGgubWF4KHQubGVuZ3RoLGUubGVuZ3RoKSxhPW5ldyBBcnJheShvKTtpZihuKXtpZihyPDJ8fGk8MilyZXR1cm47Y29uc3Qgbj11LmNhbGNNYXRNdWxTaGFwZShbdFtyLTJdLHRbci0xXV0sW2VbaS0yXSxlW2ktMV1dKTtpZih2b2lkIDA9PT1uKXJldHVybjtbYVtvLTJdLGFbby0xXV09bn1mb3IobGV0IHM9bj8zOjE7czw9bztzKyspe2NvbnN0IG49ci1zPDA/MTp0W3Itc10sdT1pLXM8MD8xOmVbaS1zXTtpZihuIT09dSYmbj4xJiZ1PjEpcmV0dXJuO2Fbby1zXT1NYXRoLm1heChuLHUpfXJldHVybiBhfXN0YXRpYyBpbmRleCh0LGUpe2NvbnN0IG49bmV3IEFycmF5KGUubGVuZ3RoKTtyZXR1cm4gYy5maWxsSW5kZXgodCxlLG4pLG59c3RhdGljIGZpbGxJbmRleCh0LGUsbil7Y29uc3Qgcj10Lmxlbmd0aC1lLmxlbmd0aDtmb3IobGV0IGk9MDtpPGUubGVuZ3RoO2krKyluW2ldPXRbcitpXSVlW2ldfXN0YXRpYyBjYWxjKHQsZSxuLHIsaSl7Y29uc3Qgbz1jLmNhbGNTaGFwZSh0LmRpbXMsZS5kaW1zKTtpZihvKXtpZihyJiYhZi5hcmVFcXVhbChvLHQuZGltcykpcmV0dXJuO2NvbnN0IGE9Zi5zaXplKG8pLHU9cj90Om5ldyBzLlRlbnNvcihvLGl8fHQudHlwZSk7aWYoMD09PW8ubGVuZ3RoKXUuc2V0KFtdLG4odC5nZXQoW10pLGUuZ2V0KFtdKSkpO2Vsc2V7Y29uc3Qgcj1uZXcgQXJyYXkoby5sZW5ndGgpLGk9bmV3IEFycmF5KHQuZGltcy5sZW5ndGgpLHM9bmV3IEFycmF5KGUuZGltcy5sZW5ndGgpO2xldCBsLHA9MCxmPTAsZD0hMSxoPSExOzA9PT10LmRpbXMubGVuZ3RoJiYocD10LmdldChbXSksZD0hMCksMD09PWUuZGltcy5sZW5ndGgmJihmPWUuZ2V0KFtdKSxoPSEwKTtmb3IobGV0IGc9MDtnPGE7ZysrKXtsPWc7Zm9yKGxldCB0PW8ubGVuZ3RoLTE7dD49MDt0LS0pclt0XT1sJW9bdF0sbD1NYXRoLmZsb29yKGwvb1t0XSk7ZHx8KGMuZmlsbEluZGV4KHIsdC5kaW1zLGkpLHA9dC5nZXQoaSkpLGh8fChjLmZpbGxJbmRleChyLGUuZGltcyxzKSxmPWUuZ2V0KHMpKSx1LnNldChyLG4ocCxmKSl9fXJldHVybiB1fX1zdGF0aWMgaXNWYWxpZEJyb2FkY2FzdCh0LGUpe2NvbnN0IG49dC5sZW5ndGgscj1lLmxlbmd0aDtpZihuPnIpcmV0dXJuITE7Zm9yKGxldCBpPTE7aTw9bjtpKyspaWYoMSE9PXRbbi1pXSYmdFtuLWldIT09ZVtyLWldKXJldHVybiExO3JldHVybiEwfXN0YXRpYyBnZXRCcm9hZGNhc3REaW1zKHQsZSl7Y29uc3Qgbj10Lmxlbmd0aCxyPVtdO2ZvcihsZXQgaT0wO2k8bjtpKyspe2NvbnN0IG89bi0xLWksYT10W29dfHwxOyhlW2UubGVuZ3RoLTEtaV18fDEpPjEmJjE9PT1hJiZyLnVuc2hpZnQobyl9cmV0dXJuIHJ9fWUuQnJvYWRjYXN0VXRpbD1jLGUuYXJyYXlDb3B5SGVscGVyPWZ1bmN0aW9uKHQsZSxuLHIsaSl7aWYocjwwfHxyPj1lLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJzb3VyY2VJbmRleCBvdXQgb2YgYm91bmRzXCIpO2lmKG48MHx8bj49dC5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwidGFyZ2V0SW5kZXggb3V0IG9mIGJvdW5kc1wiKTtpZihyK2k+ZS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwic291cmNlIGluZGljZXMgdG8gYmUgY29waWVkIGFyZSBvdXRzaWRlIGJvdW5kc1wiKTtpZihuK2k+dC5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwidGFyZ2V0IGFycmF5IGlzIHRvbyBzbWFsbCB0byBob2xkIHJlc3VsdFwiKTtmb3IobGV0IG89MDtvPGk7bysrKXRbbitvXT1lW3Irb119LGUuR2VtbVV0aWw9Y2xhc3N7c3RhdGljIGdldFNoYXBlT2ZHZW1tUmVzdWx0KHQsZSxuLHIsaSl7aWYoMiE9PXQubGVuZ3RofHwyIT09bi5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwic2hhcGUgbmVlZCB0byBiZSBvZiBzaXplIDJcIik7bGV0IG8sYSxzO2U/KG89dFsxXSxhPXRbMF0pOihvPXRbMF0sYT10WzFdKTtsZXQgdT0tMTtpZihyPyhzPW5bMF0sdT0xKToocz1uWzFdLHU9MCksblt1XSE9PWEpdGhyb3cgbmV3IEVycm9yKFwiZGltZW5zaW9uIG1pc21hdGNoXCIpO2lmKG88PTB8fHM8PTB8fGE8PTApdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBzaGFwZSBzcGVjaWZpZWRcIik7aWYoaSYmIWMuaXNWYWxpZEJyb2FkY2FzdChpLFtvLHNdKSl0aHJvdyBuZXcgRXJyb3IoXCJnZW1tOiBpbnZhbGlkIGJpYXMgc2hhcGUgZm9yIGJyb2FkY2FzdFwiKTtyZXR1cm5bbyxzLGFdfX07Y2xhc3MgbHtzdGF0aWMgdGVuc29yRGF0YVR5cGVGcm9tUHJvdG8odCl7c3dpdGNoKHQpe2Nhc2UgYS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLklOVDg6cmV0dXJuXCJpbnQ4XCI7Y2FzZSBhLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuVUlOVDg6cmV0dXJuXCJ1aW50OFwiO2Nhc2UgYS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLkJPT0w6cmV0dXJuXCJib29sXCI7Y2FzZSBhLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuSU5UMTY6cmV0dXJuXCJpbnQxNlwiO2Nhc2UgYS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLlVJTlQxNjpyZXR1cm5cInVpbnQxNlwiO2Nhc2UgYS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLklOVDMyOnJldHVyblwiaW50MzJcIjtjYXNlIGEub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5VSU5UMzI6cmV0dXJuXCJ1aW50MzJcIjtjYXNlIGEub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5GTE9BVDpyZXR1cm5cImZsb2F0MzJcIjtjYXNlIGEub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5ET1VCTEU6cmV0dXJuXCJmbG9hdDY0XCI7Y2FzZSBhLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuU1RSSU5HOnJldHVyblwic3RyaW5nXCI7Y2FzZSBhLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuSU5UNjQ6cmV0dXJuXCJpbnQzMlwiO2Nhc2UgYS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLlVJTlQ2NDpyZXR1cm5cInVpbnQzMlwiO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCBkYXRhIHR5cGU6ICR7YS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlW3RdfWApfX1zdGF0aWMgdGVuc29yRGF0YVR5cGVTdHJpbmdUb0VudW0odCl7c3dpdGNoKHQpe2Nhc2VcImludDhcIjpyZXR1cm4gYS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLklOVDg7Y2FzZVwidWludDhcIjpyZXR1cm4gYS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLlVJTlQ4O2Nhc2VcImJvb2xcIjpyZXR1cm4gYS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLkJPT0w7Y2FzZVwiaW50MTZcIjpyZXR1cm4gYS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLklOVDE2O2Nhc2VcInVpbnQxNlwiOnJldHVybiBhLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuVUlOVDE2O2Nhc2VcImludDMyXCI6cmV0dXJuIGEub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5JTlQzMjtjYXNlXCJ1aW50MzJcIjpyZXR1cm4gYS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLlVJTlQzMjtjYXNlXCJmbG9hdDMyXCI6cmV0dXJuIGEub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5GTE9BVDtjYXNlXCJmbG9hdDY0XCI6cmV0dXJuIGEub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5ET1VCTEU7Y2FzZVwic3RyaW5nXCI6cmV0dXJuIGEub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5TVFJJTkc7Y2FzZVwiaW50NjRcIjpyZXR1cm4gYS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLklOVDY0O2Nhc2VcInVpbnQ2NFwiOnJldHVybiBhLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuVUlOVDY0O2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCBkYXRhIHR5cGU6ICR7dH1gKX19c3RhdGljIHRlbnNvckRpbXNGcm9tUHJvdG8odCl7cmV0dXJuIHQubWFwKCh0PT5vLmRlZmF1bHQuaXNMb25nKHQpP3QudG9OdW1iZXIoKTp0KSl9c3RhdGljIHRlbnNvclZhbHVlVHlwZUZyb21Qcm90byh0KXtyZXR1cm57dGVuc29yVHlwZTpsLnRlbnNvckRhdGFUeXBlRnJvbVByb3RvKHQuZWxlbVR5cGUpLHNoYXBlOntkaW1zOmwudGVuc29yRGltc0Zyb21Qcm90byh0LnNoYXBlLmRpbS5tYXAoKHQ9PnQuZGltVmFsdWUpKSl9fX1zdGF0aWMgdGVuc29yRGltc0Zyb21PUlRGb3JtYXQodCl7Y29uc3QgZT1bXTtmb3IobGV0IG49MDtuPHQuZGltc0xlbmd0aCgpO24rKyllLnB1c2gocC5sb25nVG9OdW1iZXIodC5kaW1zKG4pKSk7cmV0dXJuIGV9c3RhdGljIHRlbnNvckF0dHJpYnV0ZXNGcm9tT1JURm9ybWF0KHQpe2NvbnN0IGU9W107Zm9yKGxldCBuPTA7bjx0LmF0dHJpYnV0ZXNMZW5ndGgoKTtuKyspZS5wdXNoKHQuYXR0cmlidXRlcyhuKSk7cmV0dXJuIGV9fWUuUHJvdG9VdGlsPWw7Y2xhc3MgcHtzdGF0aWMgbG9uZ1RvTnVtYmVyKHQsZSl7cmV0dXJuIG8uZGVmYXVsdC5pc0xvbmcodCk/dC50b051bWJlcigpOnQgaW5zdGFuY2VvZiBpLmZsYXRidWZmZXJzLkxvbmc/by5kZWZhdWx0LmZyb21WYWx1ZSh7bG93OnQubG93LGhpZ2g6dC5oaWdoLHVuc2lnbmVkOm51bGwhPWUmJmV9KS50b051bWJlcigpOnR9c3RhdGljIGlzTG9uZyh0KXtyZXR1cm4gby5kZWZhdWx0LmlzTG9uZyh0KXx8dCBpbnN0YW5jZW9mIGkuZmxhdGJ1ZmZlcnMuTG9uZ319ZS5Mb25nVXRpbD1wO2NsYXNzIGZ7c3RhdGljIHNpemUodCl7cmV0dXJuIGYuZ2V0U2l6ZUZyb21EaW1lbnNpb25SYW5nZSh0LDAsdC5sZW5ndGgpfXN0YXRpYyBzaXplRnJvbURpbWVuc2lvbih0LGUpe2lmKGU8MHx8ZT50Lmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgZGltZW5zaW9uIG9mICR7ZX0gZm9yIHNpemVGcm9tRGltZW5zaW9uIGFzIFRlbnNvciBoYXMgJHt0Lmxlbmd0aH0gZGltZW5zaW9ucy5gKTtyZXR1cm4gZi5nZXRTaXplRnJvbURpbWVuc2lvblJhbmdlKHQsZSx0Lmxlbmd0aCl9c3RhdGljIHNpemVUb0RpbWVuc2lvbih0LGUpe2lmKGU8MHx8ZT50Lmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgZGltZW5zaW9uIG9mICR7ZX0gZm9yIHNpemVUb0RpbWVuc2lvbiBhcyBUZW5zb3IgaGFzICR7dC5sZW5ndGh9IGRpbWVuc2lvbnMuYCk7cmV0dXJuIGYuZ2V0U2l6ZUZyb21EaW1lbnNpb25SYW5nZSh0LDAsZSl9c3RhdGljIGdldFNpemVGcm9tRGltZW5zaW9uUmFuZ2UodCxlLG4pe2xldCByPTE7Zm9yKGxldCBpPWU7aTxuO2krKyl7aWYodFtpXTw9MCl0aHJvdyBuZXcgRXJyb3IoXCJjYW5ub3QgZ2V0IHZhbGlkIHNpemUgZnJvbSBzcGVjaWZpZWQgZGltZW5zaW9uIHJhbmdlLiBNb3N0IGxpa2VseSB0aGUgcmFuZ2UgY29udGFpbnMgMCBvciBuZWdhdGl2ZSB2YWx1ZXMgaW4gdGhlbS5cIik7cio9dFtpXX1yZXR1cm4gcn1zdGF0aWMgY29tcHV0ZVN0cmlkZXModCl7Y29uc3QgZT10Lmxlbmd0aDtpZigwPT09ZSlyZXR1cm5bXTtpZigxPT09ZSlyZXR1cm5bMV07Y29uc3Qgbj1uZXcgQXJyYXkoZSk7bltlLTFdPTEsbltlLTJdPXRbZS0xXTtmb3IobGV0IHI9ZS0zO3I+PTA7LS1yKW5bcl09bltyKzFdKnRbcisxXTtyZXR1cm4gbn1zdGF0aWMgdHJhbnNwb3NlKHQpe3JldHVybiB0LnNsaWNlKCkucmV2ZXJzZSgpfXN0YXRpYyBpbmRpY2VzVG9PZmZzZXQodCxlLG4pe3ZvaWQgMD09PW4mJihuPXQubGVuZ3RoKTtsZXQgcj0wO2ZvcihsZXQgaT0wO2k8bjsrK2kpcis9ZVtpXSp0W2ldO3JldHVybiByfXN0YXRpYyBvZmZzZXRUb0luZGljZXModCxlKXtjb25zdCBuPWUubGVuZ3RoO2lmKDA9PT1uKXJldHVybltdO2lmKDE9PT1uKXJldHVyblt0KmVbMF1dO2NvbnN0IHI9bmV3IEFycmF5KGUubGVuZ3RoKTtmb3IobGV0IG49MDtuPHIubGVuZ3RoLTE7KytuKXJbbl09TWF0aC5mbG9vcih0L2Vbbl0pLHQtPXJbbl0qZVtuXTtyZXR1cm4gcltyLmxlbmd0aC0xXT10LHJ9c3RhdGljIG5vcm1hbGl6ZUF4aXModCxlKXtpZih0PC1lJiZ0Pj1lKXRocm93IG5ldyBFcnJvcihcInVuc3VwcG9ydGVkIGF4aXMgZm9yIHRoaXMgb3BlcmF0aW9uLlwiKTtyZXR1cm4gdDwwP3QrZTp0fXN0YXRpYyBub3JtYWxpemVBeGVzKHQsZSl7cmV0dXJuIHQubWFwKCh0PT50aGlzLm5vcm1hbGl6ZUF4aXModCxlKSkpfXN0YXRpYyBpbmNyZW1lbnRJbmRleCh0LGUsbil7aWYoMD09PWUubGVuZ3RofHwwPT09dC5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiSW5kZXggaW5jcmVtZW50aW5nIHVuc3VwcG9ydGVkIGZvciBzY2FsYXIgVGVuc29yXCIpO2lmKHZvaWQgMD09PW4pbj1lLmxlbmd0aDtlbHNlIGlmKG48PTB8fG4+ZS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiSW5jb3JyZWN0IGF4aXMgdG8gaW5jcmVtZW50IG9uXCIpO2ZvcihsZXQgcj1uLTE7cj49MCYmKHRbcl0rKywhKHRbcl08ZVtyXSkpOy0tcil0W3JdPTB9c3RhdGljIGNhbGN1bGF0ZVJlc2hhcGVkRGltcyh0LGUpe2lmKDA9PT1lLmxlbmd0aCl7aWYoMD09PXQubGVuZ3RofHwxPT09Zi5zaXplKHQpKXJldHVybltdO3Rocm93IG5ldyBFcnJvcihcImNhbm5vdCByZXNoYXBlIHRvIGEgc2NhbGFyIFRlbnNvclwiKX1jb25zdCBuPWUubGVuZ3RoLHI9bmV3IEFycmF5KG4pO2xldCBpPS0xLG89MTtmb3IobGV0IGE9MDthPG47YSsrKXtpZihlW2FdPC0xKXRocm93IG5ldyBFcnJvcihcImEgZGltZW5zaW9uIGluIHNoYXBlIGhpbnRzIGNhbm5vdCBiZSBsZXNzIHRoYW4gLTFcIik7aWYoLTE9PT1lW2FdKXtpZigtMSE9PWkpdGhyb3cgbmV3IEVycm9yKFwiYXQgbW9zdCBvbmUgZGltZW5zaW9uIGluIHNoYXBlIGhpbnRzIGNhbiBiZSAtMVwiKTtpPWF9ZWxzZXtpZigwPT09ZVthXSl7aWYoYT49dC5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwidGhlIGRpbWVuc2lvbiB3aXRoIHZhbHVlIHplcm8gZXhjZWVkcyB0aGUgZGltZW5zaW9uIHNpemUgb2YgdGhlIGlucHV0IHRlbnNvclwiKTtyW2FdPXRbYV19ZWxzZSByW2FdPWVbYV07byo9clthXX19Y29uc3QgYT1mLnNpemUodCk7aWYoLTEhPT1pKXtpZihhJW8hPTApdGhyb3cgbmV3IEVycm9yKGB0aGUgaW5wdXQgdGVuc29yIGNhbm5vdCBiZSByZXNoYXBlZCB0byB0aGUgcmVxdWVzdGVkIHNoYXBlLiBJbnB1dCBzaGFwZTogWyR7dH1dIE91dHB1dCBzaGFwZTogWyR7ZX1dYCk7cltpXT1hL299ZWxzZSBpZihvIT09YSl0aHJvdyBuZXcgRXJyb3IoXCJyZXNoYXBlZERpbXMgYW5kIG9yaWdpbmFsRGltcyBkb24ndCBoYXZlIG1hdGNoaW5nIHNpemVzXCIpO3JldHVybiByfXN0YXRpYyBzb3J0QmFzZWRPblBlcm0odCxlKXtyZXR1cm4gZT9lLm1hcCgoZT0+dFtlXSkpOnQuc2xpY2UoKS5yZXZlcnNlKCl9c3RhdGljIHBhZFNoYXBlKHQsZSl7Y29uc3Qgbj10Lmxlbmd0aDtyZXR1cm4gdC5tYXAoKCh0LHIpPT50K2Vbcl0rZVtyK25dKSl9c3RhdGljIGFyZUVxdWFsKHQsZSl7cmV0dXJuIHQubGVuZ3RoPT09ZS5sZW5ndGgmJnQuZXZlcnkoKCh0LG4pPT50PT09ZVtuXSkpfXN0YXRpYyB2YWxpZGF0ZURpbXNBbmRDYWxjU2l6ZSh0KXtpZih0Lmxlbmd0aD42KXRocm93IG5ldyBUeXBlRXJyb3IoXCJPbmx5IHJhbmsgMCB0byA2IGlzIHN1cHBvcnRlZCBmb3IgdGVuc29yIHNoYXBlLlwiKTtsZXQgZT0xO2Zvcihjb25zdCBuIG9mIHQpe2lmKCFOdW1iZXIuaXNJbnRlZ2VyKG4pKXRocm93IG5ldyBUeXBlRXJyb3IoYEludmFsaWQgc2hhcGU6ICR7bn0gaXMgbm90IGFuIGludGVnZXJgKTtpZihuPDB8fG4+MjE0NzQ4MzY0Nyl0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkIHNoYXBlOiBsZW5ndGggJHtufSBpcyBub3QgYWxsb3dlZGApO2UqPW59cmV0dXJuIGV9c3RhdGljIGZsYXR0ZW5TaGFwZSh0LGUpe2U8MCYmKGUrPXQubGVuZ3RoKTtjb25zdCBuPXQucmVkdWNlKCgodCxlKT0+dCplKSwxKSxyPXQuc2xpY2UoZSkucmVkdWNlKCgodCxlKT0+dCplKSwxKTtyZXR1cm5bbi9yLHJdfXN0YXRpYyBzcXVlZXplU2hhcGUodCxlKXtjb25zdCBuPW5ldyBBcnJheTtlPWYubm9ybWFsaXplQXhlcyhlLHQubGVuZ3RoKTtmb3IobGV0IHI9MDtyPHQubGVuZ3RoO3IrKyl7Y29uc3QgaT1lLmluZGV4T2Yocik+PTA7aWYoaSYmMSE9PXRbcl0pdGhyb3cgbmV3IEVycm9yKFwic3F1ZWV6ZSBhbiBheGlzIG9mIHNpemUgZGlmZmVyZW50IHRoYW4gMVwiKTsoMD09PWUubGVuZ3RoJiZ0W3JdPjF8fGUubGVuZ3RoPjAmJiFpKSYmbi5wdXNoKHRbcl0pfXJldHVybiBufXN0YXRpYyB1bnNxdWVlemVTaGFwZSh0LGUpe2NvbnN0IG49bmV3IEFycmF5KHQubGVuZ3RoK2UubGVuZ3RoKTtuLmZpbGwoMCk7Zm9yKGxldCB0PTA7dDxlLmxlbmd0aDt0Kyspe2NvbnN0IHI9Zi5ub3JtYWxpemVBeGlzKGVbdF0sbi5sZW5ndGgpO2lmKHI+PW4ubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIidheGVzJyBoYXMgYW4gb3V0IG9mIHJhbmdlIGF4aXNcIik7aWYoMCE9PW5bcl0pdGhyb3cgbmV3IEVycm9yKFwiJ2F4ZXMnIGhhcyBhIGR1cGxpY2F0ZSBheGlzXCIpO25bcl09MX1sZXQgcj0wO2ZvcihsZXQgZT0wO2U8bi5sZW5ndGg7ZSsrKTA9PT1uW2VdJiYobltlXT10W3IrK10pO2lmKHIhPT10Lmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJ0aGUgdW5zcXVlZXplZCBkaW1lbnNpb24gY291bGQgbm90IGJlIGVzdGFibGlzaGVkXCIpO3JldHVybiBufX1lLlNoYXBlVXRpbD1mLGUuTWF0aFV0aWw9Y2xhc3N7c3RhdGljIHNxcih0LGUsbixyLGkpe2lmKHI8MHx8cj49ZS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwic291cmNlSW5kZXggb3V0IG9mIGJvdW5kc1wiKTtpZihuPDB8fG4+PXQubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcInRhcmdldEluZGV4IG91dCBvZiBib3VuZHNcIik7aWYocitpPmUubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcInNvdXJjZSBpbmRpY2VzIHRvIGJlIGNvcGllZCBhcmUgb3V0c2lkZSBib3VuZHNcIik7aWYobitpPnQubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcInRhcmdldCBhcnJheSBpcyB0b28gc21hbGwgdG8gaG9sZCByZXN1bHRcIik7Zm9yKGxldCBvPTA7bzxpO28rKyl0W24rb10rPU1hdGgucG93KGVbcitvXSwyKX1zdGF0aWMgYXhweSh0LGUsbixyLGksbyl7aWYocjwwfHxyPj1lLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJzb3VyY2VJbmRleCBvdXQgb2YgYm91bmRzXCIpO2lmKG48MHx8bj49dC5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwidGFyZ2V0SW5kZXggb3V0IG9mIGJvdW5kc1wiKTtpZihyK2k+ZS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwic291cmNlIGluZGljZXMgdG8gYmUgY29waWVkIGFyZSBvdXRzaWRlIGJvdW5kc1wiKTtpZihuK2k+dC5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwidGFyZ2V0IGFycmF5IGlzIHRvbyBzbWFsbCB0byBob2xkIHJlc3VsdFwiKTtmb3IobGV0IGE9MDthPGk7YSsrKXRbbithXSs9byplW3IrYV19c3RhdGljIHBvd3godCxlLG4scixpLG8pe2lmKHI8MHx8cj49ZS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwic291cmNlSW5kZXggb3V0IG9mIGJvdW5kc1wiKTtpZihuPDB8fG4+PXQubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcInRhcmdldEluZGV4IG91dCBvZiBib3VuZHNcIik7aWYocitpPmUubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcInNvdXJjZSBpbmRpY2VzIHRvIGJlIGNvcGllZCBhcmUgb3V0c2lkZSBib3VuZHNcIik7aWYobitpPnQubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcInRhcmdldCBhcnJheSBpcyB0b28gc21hbGwgdG8gaG9sZCByZXN1bHRcIik7Zm9yKGxldCBhPTA7YTxpO2ErKyl0W24rYV09TWF0aC5wb3coZVtyK2FdLG8pfXN0YXRpYyBtdWwodCxlLG4scixpKXtpZihyPDB8fHI+PWUubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcInNvdXJjZUluZGV4IG91dCBvZiBib3VuZHNcIik7aWYobjwwfHxuPj10Lmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJ0YXJnZXRJbmRleCBvdXQgb2YgYm91bmRzXCIpO2lmKHIraT5lLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJzb3VyY2UgaW5kaWNlcyB0byBiZSBjb3BpZWQgYXJlIG91dHNpZGUgYm91bmRzXCIpO2lmKG4raT50Lmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJ0YXJnZXQgYXJyYXkgaXMgdG9vIHNtYWxsIHRvIGhvbGQgcmVzdWx0XCIpO2ZvcihsZXQgbz0wO288aTtvKyspdFtuK29dPWVbcitvXSp0W24rb119fTtjbGFzcyBke3N0YXRpYyBzcGxpdFNoYXBlKHQsZSxuLHIpe2lmKDA9PT1uLmxlbmd0aCl7aWYoIXIpdGhyb3cgbmV3IEVycm9yKFwibmVlZCB0byBrbm93IG51bWJlciBvZiBvdXRwdXRzIHdoZW4gdGhlICdzcGxpdCcgYXR0cmlidXRlIGlzIG5vdCBzcGVjaWZpZWRcIik7ZC5kZXRlcm1pbmVTcGxpdCh0W2VdLHIsbil9Y29uc3QgaT1bXSxvPVswXTtmb3IobGV0IHI9MDtyPG4ubGVuZ3RoOysrcil7MCE9PXImJm8ucHVzaChvW3ItMV0rbltyLTFdKTtjb25zdCBhPXQuc2xpY2UoKTthW2VdPW5bcl0saS5wdXNoKGEpfXJldHVybltpLG9dfXN0YXRpYyBkZXRlcm1pbmVTcGxpdCh0LGUsbil7aWYodCVlIT0wKXRocm93IG5ldyBFcnJvcihcImNhbm5vdCBzcGxpdCB0ZW5zb3IgdG8gZXF1YWwgc2l6ZWQgcGFydHNcIik7Zm9yKGxldCByPTA7cjxlOysrciluLnB1c2godC9lKX19ZS5TcGxpdFV0aWw9ZDtjbGFzcyBoe3N0YXRpYyBjYWxjUmVkdWNlKHQsZSxuLHIsaSl7Y29uc3Qgbz10LmRpbXMuc2xpY2UoMCk7MD09PWUubGVuZ3RoJiZvLmZvckVhY2goKCh0LG4pPT5lLnB1c2gobikpKTtjb25zdCBhPWguY2FsY1JlZHVjZVNoYXBlKG8sZSwhMCksdT1mLnNpemUoYSksbD1uZXcgcy5UZW5zb3IoYSx0LnR5cGUpLHA9Zi5jb21wdXRlU3RyaWRlcyhhKSxkPWYuY29tcHV0ZVN0cmlkZXMobyksZz1uZXcgQXJyYXkoby5sZW5ndGgpO2ZvcihsZXQgbj0wO248dTtuKyspe2NvbnN0IGE9Zi5vZmZzZXRUb0luZGljZXMobixwKTtjLmZpbGxJbmRleChhLG8sZyksbC5zZXQoYSxoLmNhbGNSZWR1Y2VCeUF4aXModC5udW1iZXJEYXRhLGUsbywwLGYuaW5kaWNlc1RvT2Zmc2V0KGcsZCkscixpKSl9cmV0dXJuIG4/bDpuZXcgcy5UZW5zb3IoaC5jYWxjUmVkdWNlU2hhcGUobyxlLG4pLGwudHlwZSx2b2lkIDAsdm9pZCAwLGwuZGF0YSxsLmRhdGFJZCl9c3RhdGljIGNhbGNSZWR1Y2VCeUF4aXModCxlLG4scixpLG8sYSl7bGV0IHM9MDtpZihyPj1lLmxlbmd0aClyZXR1cm4gbyh0W2ldKTtjb25zdCB1PWVbcl0sYz11Pj1uLmxlbmd0aD8xOmYuc2l6ZShuLnNsaWNlKHUrMSkpO2ZvcihsZXQgbD0wO2w8blt1XTtsKyspcz0wPT09bD9oLmNhbGNSZWR1Y2VCeUF4aXModCxlLG4scisxLGksbyxhKTphKHMsaC5jYWxjUmVkdWNlQnlBeGlzKHQsZSxuLHIrMSxpLG8sYSkpLGkrPWM7cmV0dXJuIHN9c3RhdGljIGNhbGNSZWR1Y2VTaGFwZSh0LGUsbil7Y29uc3Qgcj10LnNsaWNlKCk7Zm9yKGxldCB0PTA7dDxlLmxlbmd0aDt0KyspcltlW3RdXT1uPzE6MDtyZXR1cm4gci5maWx0ZXIoKHQ9PjAhPT10KSl9fWUuUmVkdWNlVXRpbD1oO2NsYXNzIGd7c3RhdGljIGFkanVzdFBvb2xBdHRyaWJ1dGVzKHQsZSxuLHIsaSxvKXtpZighdCYmbi5sZW5ndGghPT1lLmxlbmd0aC0yKXRocm93IG5ldyBFcnJvcihcImxlbmd0aCBvZiBzcGVjaWZpZWQga2VybmVsIHNoYXBlcyBzaG91bGQgYmUgMiBsZXNzIHRoYW4gbGVuZ3RoIG9mIGlucHV0IGRpbWVuc2lvbnNcIik7aWYodClmb3IobGV0IHQ9MDt0PGUubGVuZ3RoLTI7dCsrKXQ+PW4ubGVuZ3RoP24ucHVzaChlW3QrMl0pOm5bdF09ZVt0KzJdO2ZvcihsZXQgdD0wO3Q8bi5sZW5ndGg7dCsrKWlmKHQ8ci5sZW5ndGgpe2lmKHJbdF08MCl0aHJvdyBuZXcgRXJyb3IoXCJzdHJpZGVzIHNob3VsZCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMVwiKX1lbHNlIHIucHVzaCgxKTtmb3IobGV0IHQ9MDt0PG4ubGVuZ3RoO3QrKylpZih0PGkubGVuZ3RoKXtpZihpW3RdPDApdGhyb3cgbmV3IEVycm9yKFwiZGlsYXRpb25zIHNob3VsZCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMVwiKX1lbHNlIGkucHVzaCgxKTtmb3IobGV0IHQ9MDt0PDIqbi5sZW5ndGg7dCsrKWlmKHQ8by5sZW5ndGgpe2lmKG9bdF08MCl0aHJvdyBuZXcgRXJyb3IoXCJwYWQgc2hvdWxkIGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAxXCIpfWVsc2Ugby5wdXNoKDApO2ZvcihsZXQgdD0wO3Q8bi5sZW5ndGg7dCsrKXtpZihuW3RdPD0wKXRocm93IG5ldyBFcnJvcihcImtlcm5lbCBzaGFwZXMgbmVlZCB0byBiZSBncmVhdGVyIHRoYW4gMFwiKTtpZihvW3RdPj1uW3RdfHxvW3Qrbi5sZW5ndGhdPj1uW3RdKXRocm93IG5ldyBFcnJvcihcInBhZHMgc2hvdWxkIGJlIHNtYWxsZXIgdGhhbiBrZXJuZWxcIil9fXN0YXRpYyBhZGp1c3RQYWRzQmFzZWRPbkF1dG9QYWQodCxlLG4scixpLG8pe2lmKG8pe2lmKGkubGVuZ3RoIT09MioodC5sZW5ndGgtMikpdGhyb3cgbmV3IEVycm9yKFwibGVuZ3RoIG9mIHBhZHMgc2hvdWxkIGJlIHR3aWNlIHRoZSBsZW5ndGggb2YgZGF0YSBkaW1lbnNpb25zXCIpO2lmKGUubGVuZ3RoIT09dC5sZW5ndGgtMil0aHJvdyBuZXcgRXJyb3IoXCJsZW5ndGggb2Ygc3RyaWRlcyBzaG91bGQgYmUgdGhlIGxlbmd0aCBvZiBkYXRhIGRpbWVuc2lvbnNcIik7aWYoci5sZW5ndGghPT10Lmxlbmd0aC0yKXRocm93IG5ldyBFcnJvcihcImxlbmd0aCBvZiBrZXJuZWwgc2hhcGVzIHNob3VsZCBiZSB0aGUgbGVuZ3RoIG9mIGRhdGEgZGltZW5zaW9uc1wiKTtmb3IobGV0IGE9MDthPHQubGVuZ3RoLTI7YSsrKWcuYWRqdXN0UGFkQW5kUmV0dXJuU2hhcGUodFthKzJdLGVbYV0sblthXSxyW2FdLGksYSxhK3QubGVuZ3RoLTIsbyl9fXN0YXRpYyBjb21wdXRlUG9vbE91dHB1dFNoYXBlKHQsZSxuLHIsaSxvLGEpe2lmKGUubGVuZ3RoPD0wKXRocm93IG5ldyBFcnJvcihcImlucHV0IHNoYXBlIG11c3QgYmUgb2Ygc2l6ZSBncmVhdGVyIHRoYW4gMFwiKTtjb25zdCBzPVtlWzBdLGVbMV1dO3JldHVybiBnLmNvbXB1dGVTaGFwZUhlbHBlcih0LGUscyxuLHIsaSxvLGEpLHN9c3RhdGljIGNvbXB1dGVDb252T3V0cHV0U2hhcGUodCxlLG4scixpLG8sYSl7aWYodC5sZW5ndGg8PTB8fGUubGVuZ3RoPD0wKXRocm93IG5ldyBFcnJvcihcImludmFsaWQgaW5wdXQgdGVuc29yIGRpbXMgb3IgaW52YWxpZCBmaWx0ZXIgdGVuc29yIGRpbXNcIik7Y29uc3Qgcz1bdFswXSxlWzBdXTtyZXR1cm4gZy5jb21wdXRlU2hhcGVIZWxwZXIoITEsdCxzLG4scixpLG8sYSksc31zdGF0aWMgY29tcHV0ZVNoYXBlSGVscGVyKHQsZSxuLHIsaSxvLGEscyl7aWYodClmb3IobGV0IHQ9MDt0PGUubGVuZ3RoLTI7dCsrKW4ucHVzaCgxKTtlbHNlIGZvcihsZXQgdD0wO3Q8ZS5sZW5ndGgtMjt0Kyspbi5wdXNoKGcuYWRqdXN0UGFkQW5kUmV0dXJuU2hhcGUoZVt0KzJdLHJbdF0saVt0XSxvW3RdLGEsdCx0K2UubGVuZ3RoLTIscykpfXN0YXRpYyBhZGp1c3RQYWRBbmRSZXR1cm5TaGFwZSh0LGUsbixyLGksbyxhLHMpe2NvbnN0IHU9biooci0xKSsxO2lmKCFzfHxcIk5PVFNFVFwiPT09cylyZXR1cm4gTWF0aC5mbG9vcigodCtpW29dK2lbYV0tdSkvZSsxKTtzd2l0Y2gocyl7Y2FzZVwiVkFMSURcIjpyZXR1cm4gaVtvXT0wLGlbYV09MCxNYXRoLmZsb29yKCh0LXUpL2UrMSk7Y2FzZVwiU0FNRV9MT1dFUlwiOmNhc2VcIlNBTUVfVVBQRVJcIjppZigxIT09bil0aHJvdyBuZXcgRXJyb3IoXCJEaWxhdGlvbiBub3Qgc3VwcG9ydGVkIGZvciBTQU1FX1VQUEVSIG9yIFNBTUVfTE9XRVJcIik7e2NvbnN0IG49KCh0K2UtMSkvZS0xKSplK3ItdDtyZXR1cm4gaVtvXT1cIlNBTUVfTE9XRVJcIj09PXM/TWF0aC5mbG9vcigobisxKS8yKTpNYXRoLmZsb29yKG4vMiksaVthXT1uLWlbb10sTWF0aC5mbG9vcigodCtuLXIpL2UrMSl9ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCBBdXRvUGFkIHR5cGVcIil9fX1lLlBvb2xDb252VXRpbD1nLGUuTUlOX0NMSVA9LTM0MDI4MjM0NjYzODUyODg2ZTIyLGUuTUFYX0NMSVA9MzQwMjgyMzQ2NjM4NTI4ODZlMjIsZS5kZWNvZGVVdGY4U3RyaW5nPWZ1bmN0aW9uKHQpe3JldHVybihuZXcgVGV4dERlY29kZXIpLmRlY29kZSh0KX19LDc5Njc6KHQsZSk9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLml0ZXJhdGVFeHRyYU9wdGlvbnM9dm9pZCAwLGUuaXRlcmF0ZUV4dHJhT3B0aW9ucz0odCxuLHIsaSk9PntpZihcIm9iamVjdFwiPT10eXBlb2YgdCYmbnVsbCE9PXQpe2lmKHIuaGFzKHQpKXRocm93IG5ldyBFcnJvcihcIkNpcmN1bGFyIHJlZmVyZW5jZSBpbiBvcHRpb25zXCIpO3IuYWRkKHQpfU9iamVjdC5lbnRyaWVzKHQpLmZvckVhY2goKChbdCxvXSk9Pntjb25zdCBhPW4/bit0OnQ7aWYoXCJvYmplY3RcIj09dHlwZW9mIG8pKDAsZS5pdGVyYXRlRXh0cmFPcHRpb25zKShvLGErXCIuXCIscixpKTtlbHNlIGlmKFwic3RyaW5nXCI9PXR5cGVvZiBvfHxcIm51bWJlclwiPT10eXBlb2YgbylpKGEsby50b1N0cmluZygpKTtlbHNle2lmKFwiYm9vbGVhblwiIT10eXBlb2Ygbyl0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBoYW5kbGUgZXh0cmEgY29uZmlnIHR5cGU6IFwiK3R5cGVvZiBvKTtpKGEsbz9cIjFcIjpcIjBcIil9fSkpfX0sMjE1NzpmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7dmFyIHIsaT10aGlzJiZ0aGlzLl9fY3JlYXRlQmluZGluZ3x8KE9iamVjdC5jcmVhdGU/ZnVuY3Rpb24odCxlLG4scil7dm9pZCAwPT09ciYmKHI9bik7dmFyIGk9T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLG4pO2kmJiEoXCJnZXRcImluIGk/IWUuX19lc01vZHVsZTppLndyaXRhYmxlfHxpLmNvbmZpZ3VyYWJsZSl8fChpPXtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBlW25dfX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LHIsaSl9OmZ1bmN0aW9uKHQsZSxuLHIpe3ZvaWQgMD09PXImJihyPW4pLHRbcl09ZVtuXX0pLG89dGhpcyYmdGhpcy5fX3NldE1vZHVsZURlZmF1bHR8fChPYmplY3QuY3JlYXRlP2Z1bmN0aW9uKHQsZSl7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJkZWZhdWx0XCIse2VudW1lcmFibGU6ITAsdmFsdWU6ZX0pfTpmdW5jdGlvbih0LGUpe3QuZGVmYXVsdD1lfSksYT10aGlzJiZ0aGlzLl9faW1wb3J0U3Rhcnx8ZnVuY3Rpb24odCl7aWYodCYmdC5fX2VzTW9kdWxlKXJldHVybiB0O3ZhciBlPXt9O2lmKG51bGwhPXQpZm9yKHZhciBuIGluIHQpXCJkZWZhdWx0XCIhPT1uJiZPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCxuKSYmaShlLHQsbik7cmV0dXJuIG8oZSx0KSxlfTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLmVuZFByb2ZpbGluZz1lLnJ1bj1lLnJlbGVhc2VTZXNzaW9uPWUuY3JlYXRlU2Vzc2lvbj1lLmNyZWF0ZVNlc3Npb25GaW5hbGl6ZT1lLmNyZWF0ZVNlc3Npb25BbGxvY2F0ZT1lLmluaXRPcnQ9ZS5pbml0V2FzbT12b2lkIDA7Y29uc3Qgcz1uKDE2NzApLHU9YShuKDM0OSkpLGM9big2MzYxKSxsPSgpPT4hIXMuZW52Lndhc20ucHJveHkmJlwidW5kZWZpbmVkXCIhPXR5cGVvZiBkb2N1bWVudDtsZXQgcCxmLGQsaD0hMSxnPSExLGI9ITE7Y29uc3QgbT1bXSx5PVtdLF89W10sdj1bXSx3PVtdLHg9W10sVD0oKT0+e2lmKGh8fCFnfHxifHwhcCl0aHJvdyBuZXcgRXJyb3IoXCJ3b3JrZXIgbm90IHJlYWR5XCIpfSxTPXQ9Pntzd2l0Y2godC5kYXRhLnR5cGUpe2Nhc2VcImluaXQtd2FzbVwiOmg9ITEsdC5kYXRhLmVycj8oYj0hMCxmWzFdKHQuZGF0YS5lcnIpKTooZz0hMCxmWzBdKCkpO2JyZWFrO2Nhc2VcImluaXQtb3J0XCI6dC5kYXRhLmVycj9kWzFdKHQuZGF0YS5lcnIpOmRbMF0oKTticmVhaztjYXNlXCJjcmVhdGVfYWxsb2NhdGVcIjp0LmRhdGEuZXJyP20uc2hpZnQoKVsxXSh0LmRhdGEuZXJyKTptLnNoaWZ0KClbMF0odC5kYXRhLm91dCk7YnJlYWs7Y2FzZVwiY3JlYXRlX2ZpbmFsaXplXCI6dC5kYXRhLmVycj95LnNoaWZ0KClbMV0odC5kYXRhLmVycik6eS5zaGlmdCgpWzBdKHQuZGF0YS5vdXQpO2JyZWFrO2Nhc2VcImNyZWF0ZVwiOnQuZGF0YS5lcnI/Xy5zaGlmdCgpWzFdKHQuZGF0YS5lcnIpOl8uc2hpZnQoKVswXSh0LmRhdGEub3V0KTticmVhaztjYXNlXCJyZWxlYXNlXCI6dC5kYXRhLmVycj92LnNoaWZ0KClbMV0odC5kYXRhLmVycik6di5zaGlmdCgpWzBdKCk7YnJlYWs7Y2FzZVwicnVuXCI6dC5kYXRhLmVycj93LnNoaWZ0KClbMV0odC5kYXRhLmVycik6dy5zaGlmdCgpWzBdKHQuZGF0YS5vdXQpO2JyZWFrO2Nhc2VcImVuZC1wcm9maWxpbmdcIjp0LmRhdGEuZXJyP3guc2hpZnQoKVsxXSh0LmRhdGEuZXJyKTp4LnNoaWZ0KClbMF0oKX19LE89XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGRvY3VtZW50P251bGw9PT0ocj1udWxsPT09ZG9jdW1lbnR8fHZvaWQgMD09PWRvY3VtZW50P3ZvaWQgMDpkb2N1bWVudC5jdXJyZW50U2NyaXB0KXx8dm9pZCAwPT09cj92b2lkIDA6ci5zcmM6dm9pZCAwO2UuaW5pdFdhc209YXN5bmMoKT0+e2lmKGwoKSl7aWYoZylyZXR1cm47aWYoaCl0aHJvdyBuZXcgRXJyb3IoXCJtdWx0aXBsZSBjYWxscyB0byAnaW5pdFdhc20oKScgZGV0ZWN0ZWQuXCIpO2lmKGIpdGhyb3cgbmV3IEVycm9yKFwicHJldmlvdXMgY2FsbCB0byAnaW5pdFdhc20oKScgZmFpbGVkLlwiKTtyZXR1cm4gaD0hMCx2b2lkIDA9PT1zLmVudi53YXNtLndhc21QYXRocyYmTyYmMCE9PU8uaW5kZXhPZihcImJsb2I6XCIpJiYocy5lbnYud2FzbS53YXNtUGF0aHM9Ty5zdWJzdHIoMCwrTy5sYXN0SW5kZXhPZihcIi9cIikrMSkpLG5ldyBQcm9taXNlKCgodCxlKT0+e251bGw9PXB8fHAudGVybWluYXRlKCkscD1uKDk3MTApLlooKSxwLm9ubWVzc2FnZT1TLGY9W3QsZV07Y29uc3Qgcj17dHlwZTpcImluaXQtd2FzbVwiLGluOnMuZW52Lndhc219O3AucG9zdE1lc3NhZ2Uocil9KSl9cmV0dXJuKDAsYy5pbml0aWFsaXplV2ViQXNzZW1ibHkpKHMuZW52Lndhc20pfSxlLmluaXRPcnQ9YXN5bmModCxlKT0+e2lmKGwoKSlyZXR1cm4gVCgpLG5ldyBQcm9taXNlKCgobixyKT0+e2Q9W24scl07Y29uc3QgaT17dHlwZTpcImluaXQtb3J0XCIsaW46e251bVRocmVhZHM6dCxsb2dnaW5nTGV2ZWw6ZX19O3AucG9zdE1lc3NhZ2UoaSl9KSk7dS5pbml0T3J0KHQsZSl9LGUuY3JlYXRlU2Vzc2lvbkFsbG9jYXRlPWFzeW5jIHQ9PmwoKT8oVCgpLG5ldyBQcm9taXNlKCgoZSxuKT0+e20ucHVzaChbZSxuXSk7Y29uc3Qgcj17dHlwZTpcImNyZWF0ZV9hbGxvY2F0ZVwiLGluOnttb2RlbDp0fX07cC5wb3N0TWVzc2FnZShyLFt0LmJ1ZmZlcl0pfSkpKTp1LmNyZWF0ZVNlc3Npb25BbGxvY2F0ZSh0KSxlLmNyZWF0ZVNlc3Npb25GaW5hbGl6ZT1hc3luYyh0LGUpPT5sKCk/KFQoKSxuZXcgUHJvbWlzZSgoKG4scik9Pnt5LnB1c2goW24scl0pO2NvbnN0IGk9e3R5cGU6XCJjcmVhdGVfZmluYWxpemVcIixpbjp7bW9kZWxkYXRhOnQsb3B0aW9uczplfX07cC5wb3N0TWVzc2FnZShpKX0pKSk6dS5jcmVhdGVTZXNzaW9uRmluYWxpemUodCxlKSxlLmNyZWF0ZVNlc3Npb249YXN5bmModCxlKT0+bCgpPyhUKCksbmV3IFByb21pc2UoKChuLHIpPT57Xy5wdXNoKFtuLHJdKTtjb25zdCBpPXt0eXBlOlwiY3JlYXRlXCIsaW46e21vZGVsOnQsb3B0aW9uczplfX07cC5wb3N0TWVzc2FnZShpLFt0LmJ1ZmZlcl0pfSkpKTp1LmNyZWF0ZVNlc3Npb24odCxlKSxlLnJlbGVhc2VTZXNzaW9uPWFzeW5jIHQ9PntpZihsKCkpcmV0dXJuIFQoKSxuZXcgUHJvbWlzZSgoKGUsbik9Pnt2LnB1c2goW2Usbl0pO2NvbnN0IHI9e3R5cGU6XCJyZWxlYXNlXCIsaW46dH07cC5wb3N0TWVzc2FnZShyKX0pKTt1LnJlbGVhc2VTZXNzaW9uKHQpfSxlLnJ1bj1hc3luYyh0LGUsbixyLGkpPT5sKCk/KFQoKSxuZXcgUHJvbWlzZSgoKG8sYSk9Pnt3LnB1c2goW28sYV0pO2NvbnN0IHM9e3R5cGU6XCJydW5cIixpbjp7c2Vzc2lvbklkOnQsaW5wdXRJbmRpY2VzOmUsaW5wdXRzOm4sb3V0cHV0SW5kaWNlczpyLG9wdGlvbnM6aX19O3AucG9zdE1lc3NhZ2Uocyx1LmV4dHJhY3RUcmFuc2ZlcmFibGVCdWZmZXJzKG4pKX0pKSk6dS5ydW4odCxlLG4scixpKSxlLmVuZFByb2ZpbGluZz1hc3luYyB0PT57aWYobCgpKXJldHVybiBUKCksbmV3IFByb21pc2UoKChlLG4pPT57eC5wdXNoKFtlLG5dKTtjb25zdCByPXt0eXBlOlwiZW5kLXByb2ZpbGluZ1wiLGluOnR9O3AucG9zdE1lc3NhZ2Uocil9KSk7dS5lbmRQcm9maWxpbmcodCl9fSw1ODY6KHQsZSxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUuc2V0UnVuT3B0aW9ucz12b2lkIDA7Y29uc3Qgcj1uKDc5NjcpLGk9big0OTgzKSxvPW4oNjM2MSk7ZS5zZXRSdW5PcHRpb25zPXQ9Pntjb25zdCBlPSgwLG8uZ2V0SW5zdGFuY2UpKCk7bGV0IG49MDtjb25zdCBhPVtdLHM9dHx8e307dHJ5e2lmKHZvaWQgMD09PShudWxsPT10P3ZvaWQgMDp0LmxvZ1NldmVyaXR5TGV2ZWwpKXMubG9nU2V2ZXJpdHlMZXZlbD0yO2Vsc2UgaWYoXCJudW1iZXJcIiE9dHlwZW9mIHQubG9nU2V2ZXJpdHlMZXZlbHx8IU51bWJlci5pc0ludGVnZXIodC5sb2dTZXZlcml0eUxldmVsKXx8dC5sb2dTZXZlcml0eUxldmVsPDB8fHQubG9nU2V2ZXJpdHlMZXZlbD40KXRocm93IG5ldyBFcnJvcihgbG9nIHNlcnZlcml0eSBsZXZlbCBpcyBub3QgdmFsaWQ6ICR7dC5sb2dTZXZlcml0eUxldmVsfWApO2lmKHZvaWQgMD09PShudWxsPT10P3ZvaWQgMDp0LmxvZ1ZlcmJvc2l0eUxldmVsKSlzLmxvZ1ZlcmJvc2l0eUxldmVsPTA7ZWxzZSBpZihcIm51bWJlclwiIT10eXBlb2YgdC5sb2dWZXJib3NpdHlMZXZlbHx8IU51bWJlci5pc0ludGVnZXIodC5sb2dWZXJib3NpdHlMZXZlbCkpdGhyb3cgbmV3IEVycm9yKGBsb2cgdmVyYm9zaXR5IGxldmVsIGlzIG5vdCB2YWxpZDogJHt0LmxvZ1ZlcmJvc2l0eUxldmVsfWApO3ZvaWQgMD09PShudWxsPT10P3ZvaWQgMDp0LnRlcm1pbmF0ZSkmJihzLnRlcm1pbmF0ZT0hMSk7bGV0IG89MDtpZih2b2lkIDAhPT0obnVsbD09dD92b2lkIDA6dC50YWcpJiYobz0oMCxpLmFsbG9jV2FzbVN0cmluZykodC50YWcsYSkpLG49ZS5fT3J0Q3JlYXRlUnVuT3B0aW9ucyhzLmxvZ1NldmVyaXR5TGV2ZWwscy5sb2dWZXJib3NpdHlMZXZlbCwhIXMudGVybWluYXRlLG8pLDA9PT1uKXRocm93IG5ldyBFcnJvcihcIkNhbid0IGNyZWF0ZSBydW4gb3B0aW9uc1wiKTtyZXR1cm4gdm9pZCAwIT09KG51bGw9PXQ/dm9pZCAwOnQuZXh0cmEpJiYoMCxyLml0ZXJhdGVFeHRyYU9wdGlvbnMpKHQuZXh0cmEsXCJcIixuZXcgV2Vha1NldCwoKHQscik9Pntjb25zdCBvPSgwLGkuYWxsb2NXYXNtU3RyaW5nKSh0LGEpLHM9KDAsaS5hbGxvY1dhc21TdHJpbmcpKHIsYSk7aWYoMCE9PWUuX09ydEFkZFJ1bkNvbmZpZ0VudHJ5KG4sbyxzKSl0aHJvdyBuZXcgRXJyb3IoYENhbid0IHNldCBhIHJ1biBjb25maWcgZW50cnk6ICR7dH0gLSAke3J9YCl9KSksW24sYV19Y2F0Y2godCl7dGhyb3cgMCE9PW4mJmUuX09ydFJlbGVhc2VSdW5PcHRpb25zKG4pLGEuZm9yRWFjaChlLl9mcmVlKSx0fX19LDIzMDY6KHQsZSxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUuT25ueHJ1bnRpbWVXZWJBc3NlbWJseVNlc3Npb25IYW5kbGVyPXZvaWQgMDtjb25zdCByPW4oMjgwNiksaT1uKDE2NzApLG89bigyODUwKSxhPW4oMjE1Nyk7bGV0IHM7ZS5Pbm54cnVudGltZVdlYkFzc2VtYmx5U2Vzc2lvbkhhbmRsZXI9Y2xhc3N7YXN5bmMgY3JlYXRlU2Vzc2lvbkFsbG9jYXRlKHQpe2NvbnN0IGU9YXdhaXQgZmV0Y2godCksbj1hd2FpdCBlLmFycmF5QnVmZmVyKCk7cmV0dXJuKDAsYS5jcmVhdGVTZXNzaW9uQWxsb2NhdGUpKG5ldyBVaW50OEFycmF5KG4pKX1hc3luYyBsb2FkTW9kZWwodCxlKXtpZihzfHwoYXdhaXQoMCxhLmluaXRPcnQpKGkuZW52Lndhc20ubnVtVGhyZWFkcywodD0+e3N3aXRjaCh0KXtjYXNlXCJ2ZXJib3NlXCI6cmV0dXJuIDA7Y2FzZVwiaW5mb1wiOnJldHVybiAxO2Nhc2VcIndhcm5pbmdcIjpyZXR1cm4gMjtjYXNlXCJlcnJvclwiOnJldHVybiAzO2Nhc2VcImZhdGFsXCI6cmV0dXJuIDQ7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIGxvZ2dpbmcgbGV2ZWw6ICR7dH1gKX19KShpLmVudi5sb2dMZXZlbCkpLHM9ITApLFwic3RyaW5nXCI9PXR5cGVvZiB0KWlmKFwidW5kZWZpbmVkXCI9PXR5cGVvZiBmZXRjaCl7Y29uc3Qgbj1hd2FpdCgwLG8ucHJvbWlzaWZ5KShyLnJlYWRGaWxlKSh0KTtbdGhpcy5zZXNzaW9uSWQsdGhpcy5pbnB1dE5hbWVzLHRoaXMub3V0cHV0TmFtZXNdPWF3YWl0KDAsYS5jcmVhdGVTZXNzaW9uKShuLGUpfWVsc2V7Y29uc3Qgbj1hd2FpdCB0aGlzLmNyZWF0ZVNlc3Npb25BbGxvY2F0ZSh0KTtbdGhpcy5zZXNzaW9uSWQsdGhpcy5pbnB1dE5hbWVzLHRoaXMub3V0cHV0TmFtZXNdPWF3YWl0KDAsYS5jcmVhdGVTZXNzaW9uRmluYWxpemUpKG4sZSl9ZWxzZVt0aGlzLnNlc3Npb25JZCx0aGlzLmlucHV0TmFtZXMsdGhpcy5vdXRwdXROYW1lc109YXdhaXQoMCxhLmNyZWF0ZVNlc3Npb24pKHQsZSl9YXN5bmMgZGlzcG9zZSgpe3JldHVybigwLGEucmVsZWFzZVNlc3Npb24pKHRoaXMuc2Vzc2lvbklkKX1hc3luYyBydW4odCxlLG4pe2NvbnN0IHI9W10sbz1bXTtPYmplY3QuZW50cmllcyh0KS5mb3JFYWNoKCh0PT57Y29uc3QgZT10WzBdLG49dFsxXSxpPXRoaXMuaW5wdXROYW1lcy5pbmRleE9mKGUpO2lmKC0xPT09aSl0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgaW5wdXQgJyR7ZX0nYCk7ci5wdXNoKG4pLG8ucHVzaChpKX0pKTtjb25zdCBzPVtdO09iamVjdC5lbnRyaWVzKGUpLmZvckVhY2goKHQ9Pntjb25zdCBlPXRbMF0sbj10aGlzLm91dHB1dE5hbWVzLmluZGV4T2YoZSk7aWYoLTE9PT1uKXRocm93IG5ldyBFcnJvcihgaW52YWxpZCBvdXRwdXQgJyR7ZX0nYCk7cy5wdXNoKG4pfSkpO2NvbnN0IHU9YXdhaXQoMCxhLnJ1bikodGhpcy5zZXNzaW9uSWQsbyxyLm1hcCgodD0+W3QudHlwZSx0LmRpbXMsdC5kYXRhXSkpLHMsbiksYz17fTtmb3IobGV0IHQ9MDt0PHUubGVuZ3RoO3QrKyljW3RoaXMub3V0cHV0TmFtZXNbc1t0XV1dPW5ldyBpLlRlbnNvcih1W3RdWzBdLHVbdF1bMl0sdVt0XVsxXSk7cmV0dXJuIGN9c3RhcnRQcm9maWxpbmcoKXt9ZW5kUHJvZmlsaW5nKCl7KDAsYS5lbmRQcm9maWxpbmcpKHRoaXMuc2Vzc2lvbklkKX19fSw0OTE5Oih0LGUsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLnNldFNlc3Npb25PcHRpb25zPXZvaWQgMDtjb25zdCByPW4oNzk2NyksaT1uKDQ5ODMpLG89big2MzYxKTtlLnNldFNlc3Npb25PcHRpb25zPXQ9Pntjb25zdCBlPSgwLG8uZ2V0SW5zdGFuY2UpKCk7bGV0IG49MDtjb25zdCBhPVtdLHM9dHx8e307KHQ9Pnt0LmV4dHJhfHwodC5leHRyYT17fSksdC5leHRyYS5zZXNzaW9ufHwodC5leHRyYS5zZXNzaW9uPXt9KTtjb25zdCBlPXQuZXh0cmEuc2Vzc2lvbjtlLnVzZV9vcnRfbW9kZWxfYnl0ZXNfZGlyZWN0bHl8fChlLnVzZV9vcnRfbW9kZWxfYnl0ZXNfZGlyZWN0bHk9XCIxXCIpfSkocyk7dHJ5e3ZvaWQgMD09PShudWxsPT10P3ZvaWQgMDp0LmdyYXBoT3B0aW1pemF0aW9uTGV2ZWwpJiYocy5ncmFwaE9wdGltaXphdGlvbkxldmVsPVwiYWxsXCIpO2NvbnN0IHU9KHQ9Pntzd2l0Y2godCl7Y2FzZVwiZGlzYWJsZWRcIjpyZXR1cm4gMDtjYXNlXCJiYXNpY1wiOnJldHVybiAxO2Nhc2VcImV4dGVuZGVkXCI6cmV0dXJuIDI7Y2FzZVwiYWxsXCI6cmV0dXJuIDk5O2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCBncmFwaCBvcHRpbWl6YXRpb24gbGV2ZWw6ICR7dH1gKX19KShzLmdyYXBoT3B0aW1pemF0aW9uTGV2ZWwpO3ZvaWQgMD09PShudWxsPT10P3ZvaWQgMDp0LmVuYWJsZUNwdU1lbUFyZW5hKSYmKHMuZW5hYmxlQ3B1TWVtQXJlbmE9ITApLHZvaWQgMD09PShudWxsPT10P3ZvaWQgMDp0LmVuYWJsZU1lbVBhdHRlcm4pJiYocy5lbmFibGVNZW1QYXR0ZXJuPSEwKSx2b2lkIDA9PT0obnVsbD09dD92b2lkIDA6dC5leGVjdXRpb25Nb2RlKSYmKHMuZXhlY3V0aW9uTW9kZT1cInNlcXVlbnRpYWxcIik7Y29uc3QgYz0odD0+e3N3aXRjaCh0KXtjYXNlXCJzZXF1ZW50aWFsXCI6cmV0dXJuIDA7Y2FzZVwicGFyYWxsZWxcIjpyZXR1cm4gMTtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgZXhlY3V0aW9uIG1vZGU6ICR7dH1gKX19KShzLmV4ZWN1dGlvbk1vZGUpO2xldCBsPTA7aWYodm9pZCAwIT09KG51bGw9PXQ/dm9pZCAwOnQubG9nSWQpJiYobD0oMCxpLmFsbG9jV2FzbVN0cmluZykodC5sb2dJZCxhKSksdm9pZCAwPT09KG51bGw9PXQ/dm9pZCAwOnQubG9nU2V2ZXJpdHlMZXZlbCkpcy5sb2dTZXZlcml0eUxldmVsPTI7ZWxzZSBpZihcIm51bWJlclwiIT10eXBlb2YgdC5sb2dTZXZlcml0eUxldmVsfHwhTnVtYmVyLmlzSW50ZWdlcih0LmxvZ1NldmVyaXR5TGV2ZWwpfHx0LmxvZ1NldmVyaXR5TGV2ZWw8MHx8dC5sb2dTZXZlcml0eUxldmVsPjQpdGhyb3cgbmV3IEVycm9yKGBsb2cgc2VydmVyaXR5IGxldmVsIGlzIG5vdCB2YWxpZDogJHt0LmxvZ1NldmVyaXR5TGV2ZWx9YCk7aWYodm9pZCAwPT09KG51bGw9PXQ/dm9pZCAwOnQubG9nVmVyYm9zaXR5TGV2ZWwpKXMubG9nVmVyYm9zaXR5TGV2ZWw9MDtlbHNlIGlmKFwibnVtYmVyXCIhPXR5cGVvZiB0LmxvZ1ZlcmJvc2l0eUxldmVsfHwhTnVtYmVyLmlzSW50ZWdlcih0LmxvZ1ZlcmJvc2l0eUxldmVsKSl0aHJvdyBuZXcgRXJyb3IoYGxvZyB2ZXJib3NpdHkgbGV2ZWwgaXMgbm90IHZhbGlkOiAke3QubG9nVmVyYm9zaXR5TGV2ZWx9YCk7aWYodm9pZCAwPT09KG51bGw9PXQ/dm9pZCAwOnQuZW5hYmxlUHJvZmlsaW5nKSYmKHMuZW5hYmxlUHJvZmlsaW5nPSExKSxuPWUuX09ydENyZWF0ZVNlc3Npb25PcHRpb25zKHUsISFzLmVuYWJsZUNwdU1lbUFyZW5hLCEhcy5lbmFibGVNZW1QYXR0ZXJuLGMsISFzLmVuYWJsZVByb2ZpbGluZywwLGwscy5sb2dTZXZlcml0eUxldmVsLHMubG9nVmVyYm9zaXR5TGV2ZWwpLDA9PT1uKXRocm93IG5ldyBFcnJvcihcIkNhbid0IGNyZWF0ZSBzZXNzaW9uIG9wdGlvbnNcIik7cmV0dXJuKG51bGw9PXQ/dm9pZCAwOnQuZXhlY3V0aW9uUHJvdmlkZXJzKSYmKCh0LGUsbik9Pntmb3IoY29uc3QgciBvZiBlKXtsZXQgZT1cInN0cmluZ1wiPT10eXBlb2Ygcj9yOnIubmFtZTtzd2l0Y2goZSl7Y2FzZVwieG5ucGFja1wiOmU9XCJYTk5QQUNLXCI7YnJlYWs7Y2FzZVwid2FzbVwiOmNhc2VcImNwdVwiOmNvbnRpbnVlO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBub3Qgc3VwcG9ydGVkIEVQOiAke2V9YCl9Y29uc3QgYT0oMCxpLmFsbG9jV2FzbVN0cmluZykoZSxuKTtpZigwIT09KDAsby5nZXRJbnN0YW5jZSkoKS5fT3J0QXBwZW5kRXhlY3V0aW9uUHJvdmlkZXIodCxhKSl0aHJvdyBuZXcgRXJyb3IoYENhbid0IGFwcGVuZCBleGVjdXRpb24gcHJvdmlkZXI6ICR7ZX1gKX19KShuLHQuZXhlY3V0aW9uUHJvdmlkZXJzLGEpLHZvaWQgMCE9PShudWxsPT10P3ZvaWQgMDp0LmV4dHJhKSYmKDAsci5pdGVyYXRlRXh0cmFPcHRpb25zKSh0LmV4dHJhLFwiXCIsbmV3IFdlYWtTZXQsKCh0LHIpPT57Y29uc3Qgbz0oMCxpLmFsbG9jV2FzbVN0cmluZykodCxhKSxzPSgwLGkuYWxsb2NXYXNtU3RyaW5nKShyLGEpO2lmKDAhPT1lLl9PcnRBZGRTZXNzaW9uQ29uZmlnRW50cnkobixvLHMpKXRocm93IG5ldyBFcnJvcihgQ2FuJ3Qgc2V0IGEgc2Vzc2lvbiBjb25maWcgZW50cnk6ICR7dH0gLSAke3J9YCl9KSksW24sYV19Y2F0Y2godCl7dGhyb3cgMCE9PW4mJmUuX09ydFJlbGVhc2VTZXNzaW9uT3B0aW9ucyhuKSxhLmZvckVhY2goZS5fZnJlZSksdH19fSw0OTgzOih0LGUsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLmFsbG9jV2FzbVN0cmluZz12b2lkIDA7Y29uc3Qgcj1uKDYzNjEpO2UuYWxsb2NXYXNtU3RyaW5nPSh0LGUpPT57Y29uc3Qgbj0oMCxyLmdldEluc3RhbmNlKSgpLGk9bi5sZW5ndGhCeXRlc1VURjgodCkrMSxvPW4uX21hbGxvYyhpKTtyZXR1cm4gbi5zdHJpbmdUb1VURjgodCxvLGkpLGUucHVzaChvKSxvfX0sMzQ5Oih0LGUsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLmV4dHJhY3RUcmFuc2ZlcmFibGVCdWZmZXJzPWUuZW5kUHJvZmlsaW5nPWUucnVuPWUucmVsZWFzZVNlc3Npb249ZS5jcmVhdGVTZXNzaW9uPWUuY3JlYXRlU2Vzc2lvbkZpbmFsaXplPWUuY3JlYXRlU2Vzc2lvbkFsbG9jYXRlPWUuaW5pdE9ydD12b2lkIDA7Y29uc3Qgcj1uKDU4NiksaT1uKDQ5MTkpLG89big0OTgzKSxhPW4oNjM2MSk7ZS5pbml0T3J0PSh0LGUpPT57Y29uc3Qgbj0oMCxhLmdldEluc3RhbmNlKSgpLl9PcnRJbml0KHQsZSk7aWYoMCE9PW4pdGhyb3cgbmV3IEVycm9yKGBDYW4ndCBpbml0aWFsaXplIG9ubnhydW50aW1lLiBlcnJvciBjb2RlID0gJHtufWApfTtjb25zdCBzPW5ldyBNYXA7ZS5jcmVhdGVTZXNzaW9uQWxsb2NhdGU9dD0+e2NvbnN0IGU9KDAsYS5nZXRJbnN0YW5jZSkoKSxuPWUuX21hbGxvYyh0LmJ5dGVMZW5ndGgpO3JldHVybiBlLkhFQVBVOC5zZXQodCxuKSxbbix0LmJ5dGVMZW5ndGhdfSxlLmNyZWF0ZVNlc3Npb25GaW5hbGl6ZT0odCxlKT0+e2NvbnN0IG49KDAsYS5nZXRJbnN0YW5jZSkoKTtsZXQgcj0wLG89MCx1PVtdO3RyeXtpZihbbyx1XT0oMCxpLnNldFNlc3Npb25PcHRpb25zKShlKSxyPW4uX09ydENyZWF0ZVNlc3Npb24odFswXSx0WzFdLG8pLDA9PT1yKXRocm93IG5ldyBFcnJvcihcIkNhbid0IGNyZWF0ZSBhIHNlc3Npb25cIil9ZmluYWxseXtuLl9mcmVlKHRbMF0pLG4uX09ydFJlbGVhc2VTZXNzaW9uT3B0aW9ucyhvKSx1LmZvckVhY2gobi5fZnJlZSl9Y29uc3QgYz1uLl9PcnRHZXRJbnB1dENvdW50KHIpLGw9bi5fT3J0R2V0T3V0cHV0Q291bnQocikscD1bXSxmPVtdLGQ9W10saD1bXTtmb3IobGV0IHQ9MDt0PGM7dCsrKXtjb25zdCBlPW4uX09ydEdldElucHV0TmFtZShyLHQpO2lmKDA9PT1lKXRocm93IG5ldyBFcnJvcihcIkNhbid0IGdldCBhbiBpbnB1dCBuYW1lXCIpO2YucHVzaChlKSxwLnB1c2gobi5VVEY4VG9TdHJpbmcoZSkpfWZvcihsZXQgdD0wO3Q8bDt0Kyspe2NvbnN0IGU9bi5fT3J0R2V0T3V0cHV0TmFtZShyLHQpO2lmKDA9PT1lKXRocm93IG5ldyBFcnJvcihcIkNhbid0IGdldCBhbiBvdXRwdXQgbmFtZVwiKTtoLnB1c2goZSksZC5wdXNoKG4uVVRGOFRvU3RyaW5nKGUpKX1yZXR1cm4gcy5zZXQocixbcixmLGhdKSxbcixwLGRdfSxlLmNyZWF0ZVNlc3Npb249KHQsbik9Pntjb25zdCByPSgwLGUuY3JlYXRlU2Vzc2lvbkFsbG9jYXRlKSh0KTtyZXR1cm4oMCxlLmNyZWF0ZVNlc3Npb25GaW5hbGl6ZSkocixuKX0sZS5yZWxlYXNlU2Vzc2lvbj10PT57Y29uc3QgZT0oMCxhLmdldEluc3RhbmNlKSgpLG49cy5nZXQodCk7aWYoIW4pdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBzZXNzaW9uIGlkXCIpO2NvbnN0IHI9blswXSxpPW5bMV0sbz1uWzJdO2kuZm9yRWFjaChlLl9PcnRGcmVlKSxvLmZvckVhY2goZS5fT3J0RnJlZSksZS5fT3J0UmVsZWFzZVNlc3Npb24ocikscy5kZWxldGUodCl9O2NvbnN0IHU9dD0+e3N3aXRjaCh0KXtjYXNlXCJpbnQ4XCI6cmV0dXJuIDM7Y2FzZVwidWludDhcIjpyZXR1cm4gMjtjYXNlXCJib29sXCI6cmV0dXJuIDk7Y2FzZVwiaW50MTZcIjpyZXR1cm4gNTtjYXNlXCJ1aW50MTZcIjpyZXR1cm4gNDtjYXNlXCJpbnQzMlwiOnJldHVybiA2O2Nhc2VcInVpbnQzMlwiOnJldHVybiAxMjtjYXNlXCJmbG9hdDMyXCI6cmV0dXJuIDE7Y2FzZVwiZmxvYXQ2NFwiOnJldHVybiAxMTtjYXNlXCJzdHJpbmdcIjpyZXR1cm4gODtjYXNlXCJpbnQ2NFwiOnJldHVybiA3O2Nhc2VcInVpbnQ2NFwiOnJldHVybiAxMztkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgZGF0YSB0eXBlOiAke3R9YCl9fSxjPXQ9Pntzd2l0Y2godCl7Y2FzZSAzOnJldHVyblwiaW50OFwiO2Nhc2UgMjpyZXR1cm5cInVpbnQ4XCI7Y2FzZSA5OnJldHVyblwiYm9vbFwiO2Nhc2UgNTpyZXR1cm5cImludDE2XCI7Y2FzZSA0OnJldHVyblwidWludDE2XCI7Y2FzZSA2OnJldHVyblwiaW50MzJcIjtjYXNlIDEyOnJldHVyblwidWludDMyXCI7Y2FzZSAxOnJldHVyblwiZmxvYXQzMlwiO2Nhc2UgMTE6cmV0dXJuXCJmbG9hdDY0XCI7Y2FzZSA4OnJldHVyblwic3RyaW5nXCI7Y2FzZSA3OnJldHVyblwiaW50NjRcIjtjYXNlIDEzOnJldHVyblwidWludDY0XCI7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIGRhdGEgdHlwZTogJHt0fWApfX0sbD10PT57c3dpdGNoKHQpe2Nhc2VcImZsb2F0MzJcIjpyZXR1cm4gRmxvYXQzMkFycmF5O2Nhc2VcInVpbnQ4XCI6Y2FzZVwiYm9vbFwiOnJldHVybiBVaW50OEFycmF5O2Nhc2VcImludDhcIjpyZXR1cm4gSW50OEFycmF5O2Nhc2VcInVpbnQxNlwiOnJldHVybiBVaW50MTZBcnJheTtjYXNlXCJpbnQxNlwiOnJldHVybiBJbnQxNkFycmF5O2Nhc2VcImludDMyXCI6cmV0dXJuIEludDMyQXJyYXk7Y2FzZVwiZmxvYXQ2NFwiOnJldHVybiBGbG9hdDY0QXJyYXk7Y2FzZVwidWludDMyXCI6cmV0dXJuIFVpbnQzMkFycmF5O2Nhc2VcImludDY0XCI6cmV0dXJuIEJpZ0ludDY0QXJyYXk7Y2FzZVwidWludDY0XCI6cmV0dXJuIEJpZ1VpbnQ2NEFycmF5O2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCB0eXBlOiAke3R9YCl9fTtlLnJ1bj0odCxlLG4saSxwKT0+e2NvbnN0IGY9KDAsYS5nZXRJbnN0YW5jZSkoKSxkPXMuZ2V0KHQpO2lmKCFkKXRocm93IG5ldyBFcnJvcihcImludmFsaWQgc2Vzc2lvbiBpZFwiKTtjb25zdCBoPWRbMF0sZz1kWzFdLGI9ZFsyXSxtPWUubGVuZ3RoLHk9aS5sZW5ndGg7bGV0IF89MCx2PVtdO2NvbnN0IHc9W10seD1bXTt0cnl7W18sdl09KDAsci5zZXRSdW5PcHRpb25zKShwKTtmb3IobGV0IHQ9MDt0PG07dCsrKXtjb25zdCBlPW5bdF1bMF0scj1uW3RdWzFdLGk9blt0XVsyXTtsZXQgYSxzO2lmKEFycmF5LmlzQXJyYXkoaSkpe3M9NCppLmxlbmd0aCxhPWYuX21hbGxvYyhzKSx4LnB1c2goYSk7bGV0IHQ9YS80O2ZvcihsZXQgZT0wO2U8aS5sZW5ndGg7ZSsrKXtpZihcInN0cmluZ1wiIT10eXBlb2YgaVtlXSl0aHJvdyBuZXcgVHlwZUVycm9yKGB0ZW5zb3IgZGF0YSBhdCBpbmRleCAke2V9IGlzIG5vdCBhIHN0cmluZ2ApO2YuSEVBUFUzMlt0KytdPSgwLG8uYWxsb2NXYXNtU3RyaW5nKShpW2VdLHgpfX1lbHNlIHM9aS5ieXRlTGVuZ3RoLGE9Zi5fbWFsbG9jKHMpLHgucHVzaChhKSxmLkhFQVBVOC5zZXQobmV3IFVpbnQ4QXJyYXkoaS5idWZmZXIsaS5ieXRlT2Zmc2V0LHMpLGEpO2NvbnN0IGM9Zi5zdGFja1NhdmUoKSxsPWYuc3RhY2tBbGxvYyg0KnIubGVuZ3RoKTt0cnl7bGV0IHQ9bC80O3IuZm9yRWFjaCgoZT0+Zi5IRUFQMzJbdCsrXT1lKSk7Y29uc3Qgbj1mLl9PcnRDcmVhdGVUZW5zb3IodShlKSxhLHMsbCxyLmxlbmd0aCk7aWYoMD09PW4pdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgY3JlYXRlIGEgdGVuc29yXCIpO3cucHVzaChuKX1maW5hbGx5e2Yuc3RhY2tSZXN0b3JlKGMpfX1jb25zdCB0PWYuc3RhY2tTYXZlKCksYT1mLnN0YWNrQWxsb2MoNCptKSxzPWYuc3RhY2tBbGxvYyg0Km0pLGQ9Zi5zdGFja0FsbG9jKDQqeSksVD1mLnN0YWNrQWxsb2MoNCp5KTt0cnl7bGV0IG49YS80LHI9cy80LG89ZC80LHU9VC80O2ZvcihsZXQgdD0wO3Q8bTt0KyspZi5IRUFQVTMyW24rK109d1t0XSxmLkhFQVBVMzJbcisrXT1nW2VbdF1dO2ZvcihsZXQgdD0wO3Q8eTt0KyspZi5IRUFQVTMyW28rK109MCxmLkhFQVBVMzJbdSsrXT1iW2lbdF1dO2xldCBwPWYuX09ydFJ1bihoLHMsYSxtLFQseSxkLF8pO2NvbnN0IHY9W107aWYoMD09PXApZm9yKGxldCB0PTA7dDx5O3QrKyl7Y29uc3QgZT1mLkhFQVBVMzJbZC80K3RdLG49Zi5zdGFja1NhdmUoKSxyPWYuc3RhY2tBbGxvYygxNik7bGV0IGksbz0wO3RyeXtpZihwPWYuX09ydEdldFRlbnNvckRhdGEoZSxyLHIrNCxyKzgscisxMiksMCE9PXApdGhyb3cgbmV3IEVycm9yKGBDYW4ndCBhY2Nlc3Mgb3V0cHV0IHRlbnNvciBkYXRhLiBlcnJvciBjb2RlID0gJHtwfWApO2xldCB0PXIvNDtjb25zdCBhPWYuSEVBUFUzMlt0KytdO289Zi5IRUFQVTMyW3QrK107Y29uc3Qgcz1mLkhFQVBVMzJbdCsrXSx1PWYuSEVBUFUzMlt0KytdLGQ9W107Zm9yKGxldCB0PTA7dDx1O3QrKylkLnB1c2goZi5IRUFQVTMyW3MvNCt0XSk7Zi5fT3J0RnJlZShzKTtjb25zdCBoPTA9PT1kLmxlbmd0aD8xOmQucmVkdWNlKCgodCxlKT0+dCplKSk7aWYoaT1jKGEpLFwic3RyaW5nXCI9PT1pKXtjb25zdCB0PVtdO2xldCBlPW8vNDtmb3IobGV0IG49MDtuPGg7bisrKXtjb25zdCByPWYuSEVBUFUzMltlKytdLGk9bj09PWgtMT92b2lkIDA6Zi5IRUFQVTMyW2VdLXI7dC5wdXNoKGYuVVRGOFRvU3RyaW5nKHIsaSkpfXYucHVzaChbaSxkLHRdKX1lbHNle2NvbnN0IHQ9bmV3KGwoaSkpKGgpO25ldyBVaW50OEFycmF5KHQuYnVmZmVyLHQuYnl0ZU9mZnNldCx0LmJ5dGVMZW5ndGgpLnNldChmLkhFQVBVOC5zdWJhcnJheShvLG8rdC5ieXRlTGVuZ3RoKSksdi5wdXNoKFtpLGQsdF0pfX1maW5hbGx5e2Yuc3RhY2tSZXN0b3JlKG4pLFwic3RyaW5nXCI9PT1pJiZvJiZmLl9mcmVlKG8pLGYuX09ydFJlbGVhc2VUZW5zb3IoZSl9fWlmKDA9PT1wKXJldHVybiB2O3Rocm93IG5ldyBFcnJvcihgZmFpbGVkIHRvIGNhbGwgT3J0UnVuKCkuIGVycm9yIGNvZGUgPSAke3B9LmApfWZpbmFsbHl7Zi5zdGFja1Jlc3RvcmUodCl9fWZpbmFsbHl7dy5mb3JFYWNoKGYuX09ydFJlbGVhc2VUZW5zb3IpLHguZm9yRWFjaChmLl9mcmVlKSxmLl9PcnRSZWxlYXNlUnVuT3B0aW9ucyhfKSx2LmZvckVhY2goZi5fZnJlZSl9fSxlLmVuZFByb2ZpbGluZz10PT57Y29uc3QgZT0oMCxhLmdldEluc3RhbmNlKSgpLG49cy5nZXQodCk7aWYoIW4pdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBzZXNzaW9uIGlkXCIpO2NvbnN0IHI9blswXSxpPWUuX09ydEVuZFByb2ZpbGluZyhyKTtpZigwPT09aSl0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBnZXQgYW4gcHJvZmlsZSBmaWxlIG5hbWVcIik7ZS5fT3J0RnJlZShpKX0sZS5leHRyYWN0VHJhbnNmZXJhYmxlQnVmZmVycz10PT57Y29uc3QgZT1bXTtmb3IoY29uc3QgbiBvZiB0KXtjb25zdCB0PW5bMl07IUFycmF5LmlzQXJyYXkodCkmJnQuYnVmZmVyJiZlLnB1c2godC5idWZmZXIpfXJldHVybiBlfX0sNjM2MTpmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7dmFyIHI9dGhpcyYmdGhpcy5fX2NyZWF0ZUJpbmRpbmd8fChPYmplY3QuY3JlYXRlP2Z1bmN0aW9uKHQsZSxuLHIpe3ZvaWQgMD09PXImJihyPW4pO3ZhciBpPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSxuKTtpJiYhKFwiZ2V0XCJpbiBpPyFlLl9fZXNNb2R1bGU6aS53cml0YWJsZXx8aS5jb25maWd1cmFibGUpfHwoaT17ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gZVtuXX19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCxyLGkpfTpmdW5jdGlvbih0LGUsbixyKXt2b2lkIDA9PT1yJiYocj1uKSx0W3JdPWVbbl19KSxpPXRoaXMmJnRoaXMuX19zZXRNb2R1bGVEZWZhdWx0fHwoT2JqZWN0LmNyZWF0ZT9mdW5jdGlvbih0LGUpe09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiZGVmYXVsdFwiLHtlbnVtZXJhYmxlOiEwLHZhbHVlOmV9KX06ZnVuY3Rpb24odCxlKXt0LmRlZmF1bHQ9ZX0pLG89dGhpcyYmdGhpcy5fX2ltcG9ydFN0YXJ8fGZ1bmN0aW9uKHQpe2lmKHQmJnQuX19lc01vZHVsZSlyZXR1cm4gdDt2YXIgZT17fTtpZihudWxsIT10KWZvcih2YXIgbiBpbiB0KVwiZGVmYXVsdFwiIT09biYmT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQsbikmJnIoZSx0LG4pO3JldHVybiBpKGUsdCksZX0sYT10aGlzJiZ0aGlzLl9faW1wb3J0RGVmYXVsdHx8ZnVuY3Rpb24odCl7cmV0dXJuIHQmJnQuX19lc01vZHVsZT90OntkZWZhdWx0OnR9fTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLmRpc3Bvc2U9ZS5nZXRJbnN0YW5jZT1lLmluaXRpYWxpemVXZWJBc3NlbWJseT12b2lkIDA7Y29uc3Qgcz1vKG4oNjQ0OSkpLHU9YShuKDkzMikpLGM9bigzNDc0KTtsZXQgbCxwPSExLGY9ITEsZD0hMTtjb25zdCBoPSh0LGUpPT5lP3Q/XCJvcnQtd2FzbS1zaW1kLXRocmVhZGVkLndhc21cIjpcIm9ydC13YXNtLXRocmVhZGVkLndhc21cIjp0P1wib3J0LXdhc20tc2ltZC53YXNtXCI6XCJvcnQtd2FzbS53YXNtXCI7ZS5pbml0aWFsaXplV2ViQXNzZW1ibHk9YXN5bmMgdD0+e2lmKHApcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO2lmKGYpdGhyb3cgbmV3IEVycm9yKFwibXVsdGlwbGUgY2FsbHMgdG8gJ2luaXRpYWxpemVXZWJBc3NlbWJseSgpJyBkZXRlY3RlZC5cIik7aWYoZCl0aHJvdyBuZXcgRXJyb3IoXCJwcmV2aW91cyBjYWxsIHRvICdpbml0aWFsaXplV2ViQXNzZW1ibHkoKScgZmFpbGVkLlwiKTtmPSEwO2NvbnN0IGU9dC5pbml0VGltZW91dCxyPXQubnVtVGhyZWFkcyxpPXQuc2ltZCxvPXI+MSYmKCgpPT57dHJ5e3JldHVyblwidW5kZWZpbmVkXCIhPXR5cGVvZiBTaGFyZWRBcnJheUJ1ZmZlciYmKFwidW5kZWZpbmVkXCIhPXR5cGVvZiBNZXNzYWdlQ2hhbm5lbCYmKG5ldyBNZXNzYWdlQ2hhbm5lbCkucG9ydDEucG9zdE1lc3NhZ2UobmV3IFNoYXJlZEFycmF5QnVmZmVyKDEpKSxXZWJBc3NlbWJseS52YWxpZGF0ZShuZXcgVWludDhBcnJheShbMCw5NywxMTUsMTA5LDEsMCwwLDAsMSw0LDEsOTYsMCwwLDMsMiwxLDAsNSw0LDEsMywxLDEsMTAsMTEsMSw5LDAsNjUsMCwyNTQsMTYsMiwwLDI2LDExXSkpKX1jYXRjaCh0KXtyZXR1cm4hMX19KSgpLGE9aSYmKCgpPT57dHJ5e3JldHVybiBXZWJBc3NlbWJseS52YWxpZGF0ZShuZXcgVWludDhBcnJheShbMCw5NywxMTUsMTA5LDEsMCwwLDAsMSw0LDEsOTYsMCwwLDMsMiwxLDAsMTAsMzAsMSwyOCwwLDY1LDAsMjUzLDE1LDI1MywxMiwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDI1MywxODYsMSwyNiwxMV0pKX1jYXRjaCh0KXtyZXR1cm4hMX19KSgpLGc9XCJzdHJpbmdcIj09dHlwZW9mIHQud2FzbVBhdGhzP3Qud2FzbVBhdGhzOnZvaWQgMCxiPWgoITEsbyksbT1oKGEsbykseT1cIm9iamVjdFwiPT10eXBlb2YgdC53YXNtUGF0aHM/dC53YXNtUGF0aHNbbV06dm9pZCAwO2xldCBfPSExO2NvbnN0IHY9W107aWYoZT4wJiZ2LnB1c2gobmV3IFByb21pc2UoKHQ9PntzZXRUaW1lb3V0KCgoKT0+e189ITAsdCgpfSksZSl9KSkpLHYucHVzaChuZXcgUHJvbWlzZSgoKHQsZSk9Pntjb25zdCByPW8/Yzp1LmRlZmF1bHQsaT17bG9jYXRlRmlsZToodCxlKT0+byYmdC5lbmRzV2l0aChcIi53b3JrZXIuanNcIikmJlwidW5kZWZpbmVkXCIhPXR5cGVvZiBCbG9iP1VSTC5jcmVhdGVPYmplY3RVUkwobmV3IEJsb2IoW24oNDE1NCldLHt0eXBlOlwidGV4dC9qYXZhc2NyaXB0XCJ9KSk6dD09PWI/bnVsbCE9eT95OihudWxsIT1nP2c6ZSkrbTplK3R9O2lmKG8paWYoXCJ1bmRlZmluZWRcIj09dHlwZW9mIEJsb2IpaS5tYWluU2NyaXB0VXJsT3JCbG9iPXMuam9pbihcIi9cIixcIm9ydC13YXNtLXRocmVhZGVkLmpzXCIpO2Vsc2V7Y29uc3QgdD1gdmFyIG9ydFdhc21UaHJlYWRlZD0oZnVuY3Rpb24oKXt2YXIgX3NjcmlwdERpcjtyZXR1cm4gJHtyLnRvU3RyaW5nKCl9fSkoKTtgO2kubWFpblNjcmlwdFVybE9yQmxvYj1uZXcgQmxvYihbdF0se3R5cGU6XCJ0ZXh0L2phdmFzY3JpcHRcIn0pfXIoaSkudGhlbigoZT0+e2Y9ITEscD0hMCxsPWUsdCgpfSksKHQ9PntmPSExLGQ9ITAsZSh0KX0pKX0pKSksYXdhaXQgUHJvbWlzZS5yYWNlKHYpLF8pdGhyb3cgbmV3IEVycm9yKGBXZWJBc3NlbWJseSBiYWNrZW5kIGluaXRpYWxpemluZyBmYWlsZWQgZHVlIHRvIHRpbWVvdXQ6ICR7ZX1tc2ApfSxlLmdldEluc3RhbmNlPSgpPT57aWYocCYmbClyZXR1cm4gbDt0aHJvdyBuZXcgRXJyb3IoXCJXZWJBc3NlbWJseSBpcyBub3QgaW5pdGlhbGl6ZWQgeWV0LlwiKX0sZS5kaXNwb3NlPSgpPT57dmFyIHQ7IXB8fGZ8fGR8fChmPSEwLG51bGw9PT0odD1sLlBUaHJlYWQpfHx2b2lkIDA9PT10fHx0LnRlcm1pbmF0ZUFsbFRocmVhZHMoKSxsPXZvaWQgMCxmPSExLHA9ITEsZD0hMCl9fSw5NzEwOih0LGUsbik9PntcInVzZSBzdHJpY3RcIjtuLmQoZSx7WjooKT0+b30pO3ZhciByPW4oNDc3KSxpPW4ubihyKTtmdW5jdGlvbiBvKCl7cmV0dXJuIGkoKSgnLyohXFxuKiBPTk5YIFJ1bnRpbWUgV2ViIHYxLjE0LjBcXG4qIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxcbiogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxcbiovXFxuKCgpPT57dmFyIHQ9ezQ3NDoodCxlLG4pPT57dmFyIF9zY3JpcHREaXIscj0oX3NjcmlwdERpcj0oX3NjcmlwdERpcj1cInVuZGVmaW5lZFwiIT10eXBlb2YgZG9jdW1lbnQmJmRvY3VtZW50LmN1cnJlbnRTY3JpcHQ/ZG9jdW1lbnQuY3VycmVudFNjcmlwdC5zcmM6dm9pZCAwKXx8XCIvaW5kZXguanNcIixmdW5jdGlvbih0KXtmdW5jdGlvbiBlKCl7cmV0dXJuIGouYnVmZmVyIT1EJiZOKGouYnVmZmVyKSxQfWZ1bmN0aW9uIHIoKXtyZXR1cm4gai5idWZmZXIhPUQmJk4oai5idWZmZXIpLFV9ZnVuY3Rpb24gYSgpe3JldHVybiBqLmJ1ZmZlciE9RCYmTihqLmJ1ZmZlciksRn1mdW5jdGlvbiBpKCl7cmV0dXJuIGouYnVmZmVyIT1EJiZOKGouYnVmZmVyKSxJfWZ1bmN0aW9uIG8oKXtyZXR1cm4gai5idWZmZXIhPUQmJk4oai5idWZmZXIpLFd9dmFyIHUsYyxzO3Q9dHx8e30sdXx8KHU9dm9pZCAwIT09dD90Ont9KSx1LnJlYWR5PW5ldyBQcm9taXNlKChmdW5jdGlvbih0LGUpe2M9dCxzPWV9KSk7dmFyIGwsZixwLGgsZCx5LGI9T2JqZWN0LmFzc2lnbih7fSx1KSxtPVwiLi90aGlzLnByb2dyYW1cIixnPSh0LGUpPT57dGhyb3cgZX0sdj1cIm9iamVjdFwiPT10eXBlb2Ygd2luZG93LHc9XCJmdW5jdGlvblwiPT10eXBlb2YgaW1wb3J0U2NyaXB0cyxfPVwib2JqZWN0XCI9PXR5cGVvZiBwcm9jZXNzJiZcIm9iamVjdFwiPT10eXBlb2YgcHJvY2Vzcy52ZXJzaW9ucyYmXCJzdHJpbmdcIj09dHlwZW9mIHByb2Nlc3MudmVyc2lvbnMubm9kZSxPPXUuRU5WSVJPTk1FTlRfSVNfUFRIUkVBRHx8ITEsQT1cIlwiO2Z1bmN0aW9uIFModCl7cmV0dXJuIHUubG9jYXRlRmlsZT91LmxvY2F0ZUZpbGUodCxBKTpBK3R9aWYoXyl7bGV0IGU7QT13P24oOTA4KS5kaXJuYW1lKEEpK1wiL1wiOlwiLy9cIix5PSgpPT57ZHx8KGg9bigzODQpLGQ9big5MDgpKX0sbD1mdW5jdGlvbih0LGUpe3JldHVybiB5KCksdD1kLm5vcm1hbGl6ZSh0KSxoLnJlYWRGaWxlU3luYyh0LGU/dm9pZCAwOlwidXRmOFwiKX0scD10PT4oKHQ9bCh0LCEwKSkuYnVmZmVyfHwodD1uZXcgVWludDhBcnJheSh0KSksdCksZj0odCxlLG4pPT57eSgpLHQ9ZC5ub3JtYWxpemUodCksaC5yZWFkRmlsZSh0LChmdW5jdGlvbih0LHIpe3Q/bih0KTplKHIuYnVmZmVyKX0pKX0sMTxwcm9jZXNzLmFyZ3YubGVuZ3RoJiYobT1wcm9jZXNzLmFyZ3ZbMV0ucmVwbGFjZSgvXFxcXFxcXFwvZyxcIi9cIikpLHByb2Nlc3MuYXJndi5zbGljZSgyKSxwcm9jZXNzLm9uKFwidW5jYXVnaHRFeGNlcHRpb25cIiwoZnVuY3Rpb24odCl7aWYoISh0IGluc3RhbmNlb2YgY3QpKXRocm93IHR9KSkscHJvY2Vzcy5vbihcInVuaGFuZGxlZFJlamVjdGlvblwiLChmdW5jdGlvbih0KXt0aHJvdyB0fSkpLGc9KHQsZSk9PntpZihRKCkpdGhyb3cgcHJvY2Vzcy5leGl0Q29kZT10LGU7ZSBpbnN0YW5jZW9mIGN0fHx4KFwiZXhpdGluZyBkdWUgdG8gZXhjZXB0aW9uOiBcIitlKSxwcm9jZXNzLmV4aXQodCl9LHUuaW5zcGVjdD1mdW5jdGlvbigpe3JldHVyblwiW0Vtc2NyaXB0ZW4gTW9kdWxlIG9iamVjdF1cIn07dHJ5e2U9big5MjUpfWNhdGNoKHQpe3Rocm93IGNvbnNvbGUuZXJyb3IoXFwnVGhlIFwid29ya2VyX3RocmVhZHNcIiBtb2R1bGUgaXMgbm90IHN1cHBvcnRlZCBpbiB0aGlzIG5vZGUuanMgYnVpbGQgLSBwZXJoYXBzIGEgbmV3ZXIgdmVyc2lvbiBpcyBuZWVkZWQ/XFwnKSx0fW4uZy5Xb3JrZXI9ZS5Xb3JrZXJ9ZWxzZSh2fHx3KSYmKHc/QT1zZWxmLmxvY2F0aW9uLmhyZWY6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGRvY3VtZW50JiZkb2N1bWVudC5jdXJyZW50U2NyaXB0JiYoQT1kb2N1bWVudC5jdXJyZW50U2NyaXB0LnNyYyksX3NjcmlwdERpciYmKEE9X3NjcmlwdERpciksQT0wIT09QS5pbmRleE9mKFwiYmxvYjpcIik/QS5zdWJzdHIoMCxBLnJlcGxhY2UoL1s/I10uKi8sXCJcIikubGFzdEluZGV4T2YoXCIvXCIpKzEpOlwiXCIsX3x8KGw9dD0+e3ZhciBlPW5ldyBYTUxIdHRwUmVxdWVzdDtyZXR1cm4gZS5vcGVuKFwiR0VUXCIsdCwhMSksZS5zZW5kKG51bGwpLGUucmVzcG9uc2VUZXh0fSx3JiYocD10PT57dmFyIGU9bmV3IFhNTEh0dHBSZXF1ZXN0O3JldHVybiBlLm9wZW4oXCJHRVRcIix0LCExKSxlLnJlc3BvbnNlVHlwZT1cImFycmF5YnVmZmVyXCIsZS5zZW5kKG51bGwpLG5ldyBVaW50OEFycmF5KGUucmVzcG9uc2UpfSksZj0odCxlLG4pPT57dmFyIHI9bmV3IFhNTEh0dHBSZXF1ZXN0O3Iub3BlbihcIkdFVFwiLHQsITApLHIucmVzcG9uc2VUeXBlPVwiYXJyYXlidWZmZXJcIixyLm9ubG9hZD0oKT0+ezIwMD09ci5zdGF0dXN8fDA9PXIuc3RhdHVzJiZyLnJlc3BvbnNlP2Uoci5yZXNwb25zZSk6bigpfSxyLm9uZXJyb3I9bixyLnNlbmQobnVsbCl9KSk7XyYmXCJ1bmRlZmluZWRcIj09dHlwZW9mIHBlcmZvcm1hbmNlJiYobi5nLnBlcmZvcm1hbmNlPW4oOTUzKS5wZXJmb3JtYW5jZSk7dmFyIFQ9Y29uc29sZS5sb2cuYmluZChjb25zb2xlKSxFPWNvbnNvbGUud2Fybi5iaW5kKGNvbnNvbGUpO18mJih5KCksVD10PT5oLndyaXRlU3luYygxLHQrXCJcXFxcblwiKSxFPXQ9Pmgud3JpdGVTeW5jKDIsdCtcIlxcXFxuXCIpKTt2YXIgTSxDPXUucHJpbnR8fFQseD11LnByaW50RXJyfHxFO09iamVjdC5hc3NpZ24odSxiKSxiPW51bGwsdS50aGlzUHJvZ3JhbSYmKG09dS50aGlzUHJvZ3JhbSksdS5xdWl0JiYoZz11LnF1aXQpLHUud2FzbUJpbmFyeSYmKE09dS53YXNtQmluYXJ5KTt2YXIgUj11Lm5vRXhpdFJ1bnRpbWV8fCExO1wib2JqZWN0XCIhPXR5cGVvZiBXZWJBc3NlbWJseSYmYXQoXCJubyBuYXRpdmUgd2FzbSBzdXBwb3J0IGRldGVjdGVkXCIpO3ZhciBqLGssRCxQLFUsRixJLFcsSD0hMSxMPVwidW5kZWZpbmVkXCIhPXR5cGVvZiBUZXh0RGVjb2Rlcj9uZXcgVGV4dERlY29kZXIoXCJ1dGY4XCIpOnZvaWQgMDtmdW5jdGlvbiB6KHQsZSxuKXt2YXIgcj0oZT4+Pj0wKStuO2ZvcihuPWU7dFtuXSYmIShuPj1yKTspKytuO2lmKDE2PG4tZSYmdC5idWZmZXImJkwpcmV0dXJuIEwuZGVjb2RlKHQuYnVmZmVyIGluc3RhbmNlb2YgU2hhcmVkQXJyYXlCdWZmZXI/dC5zbGljZShlLG4pOnQuc3ViYXJyYXkoZSxuKSk7Zm9yKHI9XCJcIjtlPG47KXt2YXIgYT10W2UrK107aWYoMTI4JmEpe3ZhciBpPTYzJnRbZSsrXTtpZigxOTI9PSgyMjQmYSkpcis9U3RyaW5nLmZyb21DaGFyQ29kZSgoMzEmYSk8PDZ8aSk7ZWxzZXt2YXIgbz02MyZ0W2UrK107NjU1MzY+KGE9MjI0PT0oMjQwJmEpPygxNSZhKTw8MTJ8aTw8NnxvOig3JmEpPDwxOHxpPDwxMnxvPDw2fDYzJnRbZSsrXSk/cis9U3RyaW5nLmZyb21DaGFyQ29kZShhKTooYS09NjU1MzYscis9U3RyaW5nLmZyb21DaGFyQ29kZSg1NTI5NnxhPj4xMCw1NjMyMHwxMDIzJmEpKX19ZWxzZSByKz1TdHJpbmcuZnJvbUNoYXJDb2RlKGEpfXJldHVybiByfWZ1bmN0aW9uIFkodCxlKXtyZXR1cm4odD4+Pj0wKT96KHIoKSx0LGUpOlwiXCJ9ZnVuY3Rpb24gQih0LGUsbixyKXtpZighKDA8cikpcmV0dXJuIDA7dmFyIGE9bj4+Pj0wO3I9bityLTE7Zm9yKHZhciBpPTA7aTx0Lmxlbmd0aDsrK2kpe3ZhciBvPXQuY2hhckNvZGVBdChpKTtpZig1NTI5Njw9byYmNTczNDM+PW8mJihvPTY1NTM2KygoMTAyMyZvKTw8MTApfDEwMjMmdC5jaGFyQ29kZUF0KCsraSkpLDEyNz49byl7aWYobj49cilicmVhaztlW24rKz4+PjBdPW99ZWxzZXtpZigyMDQ3Pj1vKXtpZihuKzE+PXIpYnJlYWs7ZVtuKys+Pj4wXT0xOTJ8bz4+Nn1lbHNle2lmKDY1NTM1Pj1vKXtpZihuKzI+PXIpYnJlYWs7ZVtuKys+Pj4wXT0yMjR8bz4+MTJ9ZWxzZXtpZihuKzM+PXIpYnJlYWs7ZVtuKys+Pj4wXT0yNDB8bz4+MTgsZVtuKys+Pj4wXT0xMjh8bz4+MTImNjN9ZVtuKys+Pj4wXT0xMjh8bz4+NiY2M31lW24rKz4+PjBdPTEyOHw2MyZvfX1yZXR1cm4gZVtuPj4+MF09MCxuLWF9ZnVuY3Rpb24gRyh0KXtmb3IodmFyIGU9MCxuPTA7bjx0Lmxlbmd0aDsrK24pe3ZhciByPXQuY2hhckNvZGVBdChuKTsxMjc+PXI/ZSsrOjIwNDc+PXI/ZSs9Mjo1NTI5Njw9ciYmNTczNDM+PXI/KGUrPTQsKytuKTplKz0zfXJldHVybiBlfWZ1bmN0aW9uIE4odCl7RD10LHUuSEVBUDg9UD1uZXcgSW50OEFycmF5KHQpLHUuSEVBUDE2PW5ldyBJbnQxNkFycmF5KHQpLHUuSEVBUDMyPUY9bmV3IEludDMyQXJyYXkodCksdS5IRUFQVTg9VT1uZXcgVWludDhBcnJheSh0KSx1LkhFQVBVMTY9bmV3IFVpbnQxNkFycmF5KHQpLHUuSEVBUFUzMj1JPW5ldyBVaW50MzJBcnJheSh0KSx1LkhFQVBGMzI9bmV3IEZsb2F0MzJBcnJheSh0KSx1LkhFQVBGNjQ9Vz1uZXcgRmxvYXQ2NEFycmF5KHQpfU8mJihEPXUuYnVmZmVyKTt2YXIgVj11LklOSVRJQUxfTUVNT1JZfHwxNjc3NzIxNjtpZihPKWo9dS53YXNtTWVtb3J5LEQ9dS5idWZmZXI7ZWxzZSBpZih1Lndhc21NZW1vcnkpaj11Lndhc21NZW1vcnk7ZWxzZSBpZighKChqPW5ldyBXZWJBc3NlbWJseS5NZW1vcnkoe2luaXRpYWw6Vi82NTUzNixtYXhpbXVtOjY1NTM2LHNoYXJlZDohMH0pKS5idWZmZXIgaW5zdGFuY2VvZiBTaGFyZWRBcnJheUJ1ZmZlcikpdGhyb3cgeChcInJlcXVlc3RlZCBhIHNoYXJlZCBXZWJBc3NlbWJseS5NZW1vcnkgYnV0IHRoZSByZXR1cm5lZCBidWZmZXIgaXMgbm90IGEgU2hhcmVkQXJyYXlCdWZmZXIsIGluZGljYXRpbmcgdGhhdCB3aGlsZSB0aGUgYnJvd3NlciBoYXMgU2hhcmVkQXJyYXlCdWZmZXIgaXQgZG9lcyBub3QgaGF2ZSBXZWJBc3NlbWJseSB0aHJlYWRzIHN1cHBvcnQgLSB5b3UgbWF5IG5lZWQgdG8gc2V0IGEgZmxhZ1wiKSxfJiZjb25zb2xlLmxvZyhcIihvbiBub2RlIHlvdSBtYXkgbmVlZDogLS1leHBlcmltZW50YWwtd2FzbS10aHJlYWRzIC0tZXhwZXJpbWVudGFsLXdhc20tYnVsay1tZW1vcnkgYW5kIGFsc28gdXNlIGEgcmVjZW50IHZlcnNpb24pXCIpLEVycm9yKFwiYmFkIG1lbW9yeVwiKTtqJiYoRD1qLmJ1ZmZlciksVj1ELmJ5dGVMZW5ndGgsTihEKTt2YXIgJCxxPVtdLFg9W10sSj1bXSxaPVtdO2Z1bmN0aW9uIFEoKXtyZXR1cm4gUnx8ITF9ZnVuY3Rpb24gSygpe3ZhciB0PXUucHJlUnVuLnNoaWZ0KCk7cS51bnNoaWZ0KHQpfXZhciB0dCxldD0wLG50PW51bGwscnQ9bnVsbDtmdW5jdGlvbiBhdCh0KXt0aHJvdyBPP3Bvc3RNZXNzYWdlKHtjbWQ6XCJvbkFib3J0XCIsYXJnOnR9KTp1Lm9uQWJvcnQmJnUub25BYm9ydCh0KSx4KHQ9XCJBYm9ydGVkKFwiK3QrXCIpXCIpLEg9ITAsdD1uZXcgV2ViQXNzZW1ibHkuUnVudGltZUVycm9yKHQrXCIuIEJ1aWxkIHdpdGggLXNBU1NFUlRJT05TIGZvciBtb3JlIGluZm8uXCIpLHModCksdH1mdW5jdGlvbiBpdCgpe3JldHVybiB0dC5zdGFydHNXaXRoKFwiZGF0YTphcHBsaWNhdGlvbi9vY3RldC1zdHJlYW07YmFzZTY0LFwiKX1mdW5jdGlvbiBvdCgpe3ZhciB0PXR0O3RyeXtpZih0PT10dCYmTSlyZXR1cm4gbmV3IFVpbnQ4QXJyYXkoTSk7aWYocClyZXR1cm4gcCh0KTt0aHJvd1wiYm90aCBhc3luYyBhbmQgc3luYyBmZXRjaGluZyBvZiB0aGUgd2FzbSBmYWlsZWRcIn1jYXRjaCh0KXthdCh0KX19dHQ9XCJvcnQtd2FzbS10aHJlYWRlZC53YXNtXCIsaXQoKXx8KHR0PVModHQpKTt2YXIgdXQ9e307ZnVuY3Rpb24gY3QodCl7dGhpcy5uYW1lPVwiRXhpdFN0YXR1c1wiLHRoaXMubWVzc2FnZT1cIlByb2dyYW0gdGVybWluYXRlZCB3aXRoIGV4aXQoXCIrdCtcIilcIix0aGlzLnN0YXR1cz10fWZ1bmN0aW9uIHN0KHQpeyh0PWh0LlZiW3RdKXx8YXQoKSxodC5tYyh0KX1mdW5jdGlvbiBsdCh0KXt2YXIgZT1odC5DYygpO2lmKCFlKXJldHVybiA2O2h0LmFjLnB1c2goZSksaHQuVmJbdC5VYl09ZSxlLlViPXQuVWI7dmFyIG49e2NtZDpcInJ1blwiLHN0YXJ0X3JvdXRpbmU6dC5JYyxhcmc6dC56YyxwdGhyZWFkX3B0cjp0LlVifTtyZXR1cm4gZS4kYj0oKT0+e24udGltZT1wZXJmb3JtYW5jZS5ub3coKSxlLnBvc3RNZXNzYWdlKG4sdC5OYyl9LGUubG9hZGVkJiYoZS4kYigpLGRlbGV0ZSBlLiRiKSwwfWZ1bmN0aW9uIGZ0KHQpe2lmKE8pcmV0dXJuICR0KDEsMSx0KTtRKCl8fChodC5vYygpLHUub25FeGl0JiZ1Lm9uRXhpdCh0KSxIPSEwKSxnKHQsbmV3IGN0KHQpKX1mdW5jdGlvbiBwdCh0LGUpe2lmKCFlJiZPKXRocm93IGJ0KHQpLFwidW53aW5kXCI7USgpfHxPfHwobWUoKSxkdChKKSxiZSgwKSxyZVsxXS5sZW5ndGgmJmFlKDEsMTApLHJlWzJdLmxlbmd0aCYmYWUoMiwxMCksaHQub2MoKSksZnQodCl9dmFyIGh0PXtZYjpbXSxhYzpbXSxxYzpbXSxWYjp7fSxmYzpmdW5jdGlvbigpe08mJmh0LkVjKCl9LFBjOmZ1bmN0aW9uKCl7fSxFYzpmdW5jdGlvbigpe2h0LnJlY2VpdmVPYmplY3RUcmFuc2Zlcj1odC5HYyxodC50aHJlYWRJbml0VExTPWh0LnBjLGh0LnNldEV4aXRTdGF0dXM9aHQubmMsUj0hMX0sbmM6ZnVuY3Rpb24oKXt9LG9jOmZ1bmN0aW9uKCl7Zm9yKHZhciB0IG9mIE9iamVjdC52YWx1ZXMoaHQuVmIpKWh0Lm1jKHQpO2Zvcih0IG9mIGh0LlliKXQudGVybWluYXRlKCk7aHQuWWI9W119LG1jOmZ1bmN0aW9uKHQpe3ZhciBlPXQuVWI7ZGVsZXRlIGh0LlZiW2VdLGh0LlliLnB1c2godCksaHQuYWMuc3BsaWNlKGh0LmFjLmluZGV4T2YodCksMSksdC5VYj0wLE9lKGUpfSxHYzpmdW5jdGlvbigpe30scGM6ZnVuY3Rpb24oKXtodC5xYy5mb3JFYWNoKCh0PT50KCkpKX0sRmM6ZnVuY3Rpb24odCxlKXt0Lm9ubWVzc2FnZT1uPT57dmFyIHI9KG49bi5kYXRhKS5jbWQ7aWYodC5VYiYmKGh0LkJjPXQuVWIpLG4udGFyZ2V0VGhyZWFkJiZuLnRhcmdldFRocmVhZCE9aGUoKSl7dmFyIGE9aHQuVmJbbi5RY107YT9hLnBvc3RNZXNzYWdlKG4sbi50cmFuc2Zlckxpc3QpOngoXFwnSW50ZXJuYWwgZXJyb3IhIFdvcmtlciBzZW50IGEgbWVzc2FnZSBcIlxcJytyK1xcJ1wiIHRvIHRhcmdldCBwdGhyZWFkIFxcJytuLnRhcmdldFRocmVhZCtcIiwgYnV0IHRoYXQgdGhyZWFkIG5vIGxvbmdlciBleGlzdHMhXCIpfWVsc2VcInByb2Nlc3NQcm94eWluZ1F1ZXVlXCI9PT1yP3p0KG4ucXVldWUpOlwic3Bhd25UaHJlYWRcIj09PXI/bHQobik6XCJjbGVhbnVwVGhyZWFkXCI9PT1yP3N0KG4udGhyZWFkKTpcImtpbGxUaHJlYWRcIj09PXI/KG49bi50aHJlYWQscj1odC5WYltuXSxkZWxldGUgaHQuVmJbbl0sci50ZXJtaW5hdGUoKSxPZShuKSxodC5hYy5zcGxpY2UoaHQuYWMuaW5kZXhPZihyKSwxKSxyLlViPTApOlwiY2FuY2VsVGhyZWFkXCI9PT1yP2h0LlZiW24udGhyZWFkXS5wb3N0TWVzc2FnZSh7Y21kOlwiY2FuY2VsXCJ9KTpcImxvYWRlZFwiPT09cj8odC5sb2FkZWQ9ITAsZSYmZSh0KSx0LiRiJiYodC4kYigpLGRlbGV0ZSB0LiRiKSk6XCJwcmludFwiPT09cj9DKFwiVGhyZWFkIFwiK24udGhyZWFkSWQrXCI6IFwiK24udGV4dCk6XCJwcmludEVyclwiPT09cj94KFwiVGhyZWFkIFwiK24udGhyZWFkSWQrXCI6IFwiK24udGV4dCk6XCJhbGVydFwiPT09cj9hbGVydChcIlRocmVhZCBcIituLnRocmVhZElkK1wiOiBcIituLnRleHQpOlwic2V0aW1tZWRpYXRlXCI9PT1uLnRhcmdldD90LnBvc3RNZXNzYWdlKG4pOlwib25BYm9ydFwiPT09cj91Lm9uQWJvcnQmJnUub25BYm9ydChuLmFyZyk6ciYmeChcIndvcmtlciBzZW50IGFuIHVua25vd24gY29tbWFuZCBcIityKTtodC5CYz12b2lkIDB9LHQub25lcnJvcj10PT57dGhyb3cgeChcIndvcmtlciBzZW50IGFuIGVycm9yISBcIit0LmZpbGVuYW1lK1wiOlwiK3QubGluZW5vK1wiOiBcIit0Lm1lc3NhZ2UpLHR9LF8mJih0Lm9uKFwibWVzc2FnZVwiLChmdW5jdGlvbihlKXt0Lm9ubWVzc2FnZSh7ZGF0YTplfSl9KSksdC5vbihcImVycm9yXCIsKGZ1bmN0aW9uKGUpe3Qub25lcnJvcihlKX0pKSx0Lm9uKFwiZGV0YWNoZWRFeGl0XCIsKGZ1bmN0aW9uKCl7fSkpKSx0LnBvc3RNZXNzYWdlKHtjbWQ6XCJsb2FkXCIsdXJsT3JCbG9iOnUubWFpblNjcmlwdFVybE9yQmxvYnx8X3NjcmlwdERpcix3YXNtTWVtb3J5Omosd2FzbU1vZHVsZTprfSl9LHljOmZ1bmN0aW9uKCl7dmFyIHQ9UyhcIm9ydC13YXNtLXRocmVhZGVkLndvcmtlci5qc1wiKTtodC5ZYi5wdXNoKG5ldyBXb3JrZXIodCkpfSxDYzpmdW5jdGlvbigpe3JldHVybiAwPT1odC5ZYi5sZW5ndGgmJihodC55YygpLGh0LkZjKGh0LlliWzBdKSksaHQuWWIucG9wKCl9fTtmdW5jdGlvbiBkdCh0KXtmb3IoOzA8dC5sZW5ndGg7KXQuc2hpZnQoKSh1KX1mdW5jdGlvbiB5dCh0KXt2YXIgZT1FZSgpO3JldHVybiB0PXQoKSxNZShlKSx0fWZ1bmN0aW9uIGJ0KHQpe2lmKE8pcmV0dXJuICR0KDIsMCx0KTt0cnl7cHQodCl9Y2F0Y2godCl7dCBpbnN0YW5jZW9mIGN0fHxcInVud2luZFwiPT10fHxnKDEsdCl9fXUuUFRocmVhZD1odCx1LmVzdGFibGlzaFN0YWNrU3BhY2U9ZnVuY3Rpb24oKXt2YXIgdD1oZSgpLGU9YSgpW3QrNDQ+PjI+Pj4wXTt0PWEoKVt0KzQ4Pj4yPj4+MF0sVGUoZSxlLXQpLE1lKGUpfTt2YXIgbXQ9W107ZnVuY3Rpb24gZ3QodCl7dmFyIGU9bXRbdF07cmV0dXJuIGV8fCh0Pj1tdC5sZW5ndGgmJihtdC5sZW5ndGg9dCsxKSxtdFt0XT1lPSQuZ2V0KHQpKSxlfXUuaW52b2tlRW50cnlQb2ludD1mdW5jdGlvbih0LGUpe3Q9Z3QodCkoZSksUSgpP2h0Lm5jKHQpOkFlKHQpfTt2YXIgdnQsd3QsX3Q9W10sT3Q9MCxBdD0wO2Z1bmN0aW9uIFN0KHQpe3RoaXMuWmI9dCx0aGlzLlNiPXQtMjQsdGhpcy54Yz1mdW5jdGlvbih0KXtpKClbdGhpcy5TYis0Pj4yPj4+MF09dH0sdGhpcy5iYz1mdW5jdGlvbigpe3JldHVybiBpKClbdGhpcy5TYis0Pj4yPj4+MF19LHRoaXMud2M9ZnVuY3Rpb24odCl7aSgpW3RoaXMuU2IrOD4+Mj4+PjBdPXR9LHRoaXMuRGM9ZnVuY3Rpb24oKXtyZXR1cm4gaSgpW3RoaXMuU2IrOD4+Mj4+PjBdfSx0aGlzLnJjPWZ1bmN0aW9uKCl7YSgpW3RoaXMuU2I+PjI+Pj4wXT0wfSx0aGlzLmhjPWZ1bmN0aW9uKHQpe3Q9dD8xOjAsZSgpW3RoaXMuU2IrMTI+PjA+Pj4wXT10fSx0aGlzLnVjPWZ1bmN0aW9uKCl7cmV0dXJuIDAhPWUoKVt0aGlzLlNiKzEyPj4wPj4+MF19LHRoaXMuaWM9ZnVuY3Rpb24odCl7dD10PzE6MCxlKClbdGhpcy5TYisxMz4+MD4+PjBdPXR9LHRoaXMua2M9ZnVuY3Rpb24oKXtyZXR1cm4gMCE9ZSgpW3RoaXMuU2IrMTM+PjA+Pj4wXX0sdGhpcy5mYz1mdW5jdGlvbih0LGUpe3RoaXMuY2MoMCksdGhpcy54Yyh0KSx0aGlzLndjKGUpLHRoaXMucmMoKSx0aGlzLmhjKCExKSx0aGlzLmljKCExKX0sdGhpcy5zYz1mdW5jdGlvbigpe0F0b21pY3MuYWRkKGEoKSx0aGlzLlNiPj4yLDEpfSx0aGlzLkhjPWZ1bmN0aW9uKCl7cmV0dXJuIDE9PT1BdG9taWNzLnN1YihhKCksdGhpcy5TYj4+MiwxKX0sdGhpcy5jYz1mdW5jdGlvbih0KXtpKClbdGhpcy5TYisxNj4+Mj4+PjBdPXR9LHRoaXMudGM9ZnVuY3Rpb24oKXtyZXR1cm4gaSgpW3RoaXMuU2IrMTY+PjI+Pj4wXX0sdGhpcy52Yz1mdW5jdGlvbigpe2lmKFJlKHRoaXMuYmMoKSkpcmV0dXJuIGkoKVt0aGlzLlpiPj4yPj4+MF07dmFyIHQ9dGhpcy50YygpO3JldHVybiAwIT09dD90OnRoaXMuWmJ9fWZ1bmN0aW9uIFR0KHQpe3JldHVybiB5ZShuZXcgU3QodCkuU2IpfWZ1bmN0aW9uIEV0KHQsZSxuLHIpe3JldHVybiBPPyR0KDMsMSx0LGUsbixyKTpNdCh0LGUsbixyKX1mdW5jdGlvbiBNdCh0LGUsbixyKXtpZihcInVuZGVmaW5lZFwiPT10eXBlb2YgU2hhcmVkQXJyYXlCdWZmZXIpcmV0dXJuIHgoXCJDdXJyZW50IGVudmlyb25tZW50IGRvZXMgbm90IHN1cHBvcnQgU2hhcmVkQXJyYXlCdWZmZXIsIHB0aHJlYWRzIGFyZSBub3QgYXZhaWxhYmxlIVwiKSw2O3ZhciBhPVtdO3JldHVybiBPJiYwPT09YS5sZW5ndGg/RXQodCxlLG4scik6KHQ9e0ljOm4sVWI6dCx6YzpyLE5jOmF9LE8/KHQuT2M9XCJzcGF3blRocmVhZFwiLHBvc3RNZXNzYWdlKHQsYSksMCk6bHQodCkpfWZ1bmN0aW9uIEN0KHQsZSxuKXtyZXR1cm4gTz8kdCg0LDEsdCxlLG4pOjB9ZnVuY3Rpb24geHQodCxlKXtpZihPKXJldHVybiAkdCg1LDEsdCxlKX1mdW5jdGlvbiBSdCh0LGUpe2lmKE8pcmV0dXJuICR0KDYsMSx0LGUpfWZ1bmN0aW9uIGp0KHQsZSxuKXtpZihPKXJldHVybiAkdCg3LDEsdCxlLG4pfWZ1bmN0aW9uIGt0KHQsZSxuKXtyZXR1cm4gTz8kdCg4LDEsdCxlLG4pOjB9ZnVuY3Rpb24gRHQodCxlKXtpZihPKXJldHVybiAkdCg5LDEsdCxlKX1mdW5jdGlvbiBQdCh0LGUsbil7aWYoTylyZXR1cm4gJHQoMTAsMSx0LGUsbil9ZnVuY3Rpb24gVXQodCxlLG4scil7aWYoTylyZXR1cm4gJHQoMTEsMSx0LGUsbixyKX1mdW5jdGlvbiBGdCh0LGUsbixyKXtpZihPKXJldHVybiAkdCgxMiwxLHQsZSxuLHIpfWZ1bmN0aW9uIEl0KHQsZSxuLHIpe2lmKE8pcmV0dXJuICR0KDEzLDEsdCxlLG4scil9ZnVuY3Rpb24gV3QodCl7aWYoTylyZXR1cm4gJHQoMTQsMSx0KX1mdW5jdGlvbiBIdCh0LGUpe2lmKE8pcmV0dXJuICR0KDE1LDEsdCxlKX1mdW5jdGlvbiBMdCh0LGUsbil7aWYoTylyZXR1cm4gJHQoMTYsMSx0LGUsbil9ZnVuY3Rpb24genQodCl7QXRvbWljcy5zdG9yZShhKCksdD4+MiwxKSxoZSgpJiZfZSh0KSxBdG9taWNzLmNvbXBhcmVFeGNoYW5nZShhKCksdD4+MiwxLDApfWZ1bmN0aW9uIFl0KHQpe3JldHVybiBpKClbdD4+PjJdKzQyOTQ5NjcyOTYqYSgpW3QrND4+PjJdfWZ1bmN0aW9uIEJ0KHQsZSxuLHIsYSxpKXtyZXR1cm4gTz8kdCgxNywxLHQsZSxuLHIsYSxpKTotNTJ9ZnVuY3Rpb24gR3QodCxlLG4scixhLGkpe2lmKE8pcmV0dXJuICR0KDE4LDEsdCxlLG4scixhLGkpfWZ1bmN0aW9uIE50KHQpe3ZhciBuPUcodCkrMSxyPWRlKG4pO3JldHVybiByJiZCKHQsZSgpLHIsbikscn1mdW5jdGlvbiBWdCh0LGUsbil7ZnVuY3Rpb24gcih0KXtyZXR1cm4odD10LnRvVGltZVN0cmluZygpLm1hdGNoKC9cXFxcKChbQS1aYS16IF0rKVxcXFwpJC8pKT90WzFdOlwiR01UXCJ9aWYoTylyZXR1cm4gJHQoMTksMSx0LGUsbik7dmFyIG89KG5ldyBEYXRlKS5nZXRGdWxsWWVhcigpLHU9bmV3IERhdGUobywwLDEpLGM9bmV3IERhdGUobyw2LDEpO289dS5nZXRUaW1lem9uZU9mZnNldCgpO3ZhciBzPWMuZ2V0VGltZXpvbmVPZmZzZXQoKSxsPU1hdGgubWF4KG8scyk7YSgpW3Q+PjI+Pj4wXT02MCpsLGEoKVtlPj4yPj4+MF09TnVtYmVyKG8hPXMpLHQ9cih1KSxlPXIoYyksdD1OdCh0KSxlPU50KGUpLHM8bz8oaSgpW24+PjI+Pj4wXT10LGkoKVtuKzQ+PjI+Pj4wXT1lKTooaSgpW24+PjI+Pj4wXT1lLGkoKVtuKzQ+PjI+Pj4wXT10KX1mdW5jdGlvbiAkdCh0LGUpe3ZhciBuPWFyZ3VtZW50cy5sZW5ndGgtMixyPWFyZ3VtZW50cztyZXR1cm4geXQoKCgpPT57Zm9yKHZhciBhPUNlKDgqbiksaT1hPj4zLHU9MDt1PG47dSsrKXt2YXIgYz1yWzIrdV07bygpW2krdT4+PjBdPWN9cmV0dXJuIHdlKHQsbixhLGUpfSkpfXUuZXhlY3V0ZU5vdGlmaWVkUHJveHlpbmdRdWV1ZT16dCx3dD1fPygpPT57dmFyIHQ9cHJvY2Vzcy5ocnRpbWUoKTtyZXR1cm4gMWUzKnRbMF0rdFsxXS8xZTZ9Ok8/KCk9PnBlcmZvcm1hbmNlLm5vdygpLXUuX19wZXJmb3JtYW5jZV9ub3dfY2xvY2tfZHJpZnQ6KCk9PnBlcmZvcm1hbmNlLm5vdygpO3ZhciBxdCxYdD1bXSxKdD17fTtmdW5jdGlvbiBadCgpe2lmKCFxdCl7dmFyIHQsZT17VVNFUjpcIndlYl91c2VyXCIsTE9HTkFNRTpcIndlYl91c2VyXCIsUEFUSDpcIi9cIixQV0Q6XCIvXCIsSE9NRTpcIi9ob21lL3dlYl91c2VyXCIsTEFORzooXCJvYmplY3RcIj09dHlwZW9mIG5hdmlnYXRvciYmbmF2aWdhdG9yLmxhbmd1YWdlcyYmbmF2aWdhdG9yLmxhbmd1YWdlc1swXXx8XCJDXCIpLnJlcGxhY2UoXCItXCIsXCJfXCIpK1wiLlVURi04XCIsXzptfHxcIi4vdGhpcy5wcm9ncmFtXCJ9O2Zvcih0IGluIEp0KXZvaWQgMD09PUp0W3RdP2RlbGV0ZSBlW3RdOmVbdF09SnRbdF07dmFyIG49W107Zm9yKHQgaW4gZSluLnB1c2godCtcIj1cIitlW3RdKTtxdD1ufXJldHVybiBxdH1mdW5jdGlvbiBRdCh0LG4pe2lmKE8pcmV0dXJuICR0KDIwLDEsdCxuKTt2YXIgcj0wO3JldHVybiBadCgpLmZvckVhY2goKGZ1bmN0aW9uKGEsbyl7dmFyIHU9bityO2ZvcihvPWkoKVt0KzQqbz4+Mj4+PjBdPXUsdT0wO3U8YS5sZW5ndGg7Kyt1KWUoKVtvKys+PjA+Pj4wXT1hLmNoYXJDb2RlQXQodSk7ZSgpW28+PjA+Pj4wXT0wLHIrPWEubGVuZ3RoKzF9KSksMH1mdW5jdGlvbiBLdCh0LGUpe2lmKE8pcmV0dXJuICR0KDIxLDEsdCxlKTt2YXIgbj1adCgpO2koKVt0Pj4yPj4+MF09bi5sZW5ndGg7dmFyIHI9MDtyZXR1cm4gbi5mb3JFYWNoKChmdW5jdGlvbih0KXtyKz10Lmxlbmd0aCsxfSkpLGkoKVtlPj4yPj4+MF09ciwwfWZ1bmN0aW9uIHRlKHQpe3JldHVybiBPPyR0KDIyLDEsdCk6NTJ9ZnVuY3Rpb24gZWUodCxlLG4scil7cmV0dXJuIE8/JHQoMjMsMSx0LGUsbixyKTo1Mn1mdW5jdGlvbiBuZSh0LGUsbixyLGEpe3JldHVybiBPPyR0KDI0LDEsdCxlLG4scixhKTo3MH12YXIgcmU9W251bGwsW10sW11dO2Z1bmN0aW9uIGFlKHQsZSl7dmFyIG49cmVbdF07MD09PWV8fDEwPT09ZT8oKDE9PT10P0M6eCkoeihuLDApKSxuLmxlbmd0aD0wKTpuLnB1c2goZSl9ZnVuY3Rpb24gaWUodCxlLG4sYSl7aWYoTylyZXR1cm4gJHQoMjUsMSx0LGUsbixhKTtmb3IodmFyIG89MCx1PTA7dTxuO3UrKyl7dmFyIGM9aSgpW2U+PjI+Pj4wXSxzPWkoKVtlKzQ+PjI+Pj4wXTtlKz04O2Zvcih2YXIgbD0wO2w8cztsKyspYWUodCxyKClbYytsPj4+MF0pO28rPXN9cmV0dXJuIGkoKVthPj4yPj4+MF09bywwfXZhciBvZT0wO2Z1bmN0aW9uIHVlKHQpe3JldHVybiAwPT10JTQmJigwIT10JTEwMHx8MD09dCU0MDApfXZhciBjZT1bMzEsMjksMzEsMzAsMzEsMzAsMzEsMzEsMzAsMzEsMzAsMzFdLHNlPVszMSwyOCwzMSwzMCwzMSwzMCwzMSwzMSwzMCwzMSwzMCwzMV07ZnVuY3Rpb24gbGUodCxuLHIsaSl7ZnVuY3Rpb24gbyh0LGUsbil7Zm9yKHQ9XCJudW1iZXJcIj09dHlwZW9mIHQ/dC50b1N0cmluZygpOnR8fFwiXCI7dC5sZW5ndGg8ZTspdD1uWzBdK3Q7cmV0dXJuIHR9ZnVuY3Rpb24gdSh0LGUpe3JldHVybiBvKHQsZSxcIjBcIil9ZnVuY3Rpb24gYyh0LGUpe2Z1bmN0aW9uIG4odCl7cmV0dXJuIDA+dD8tMTowPHQ/MTowfXZhciByO3JldHVybiAwPT09KHI9bih0LmdldEZ1bGxZZWFyKCktZS5nZXRGdWxsWWVhcigpKSkmJjA9PT0ocj1uKHQuZ2V0TW9udGgoKS1lLmdldE1vbnRoKCkpKSYmKHI9bih0LmdldERhdGUoKS1lLmdldERhdGUoKSkpLHJ9ZnVuY3Rpb24gcyh0KXtzd2l0Y2godC5nZXREYXkoKSl7Y2FzZSAwOnJldHVybiBuZXcgRGF0ZSh0LmdldEZ1bGxZZWFyKCktMSwxMSwyOSk7Y2FzZSAxOnJldHVybiB0O2Nhc2UgMjpyZXR1cm4gbmV3IERhdGUodC5nZXRGdWxsWWVhcigpLDAsMyk7Y2FzZSAzOnJldHVybiBuZXcgRGF0ZSh0LmdldEZ1bGxZZWFyKCksMCwyKTtjYXNlIDQ6cmV0dXJuIG5ldyBEYXRlKHQuZ2V0RnVsbFllYXIoKSwwLDEpO2Nhc2UgNTpyZXR1cm4gbmV3IERhdGUodC5nZXRGdWxsWWVhcigpLTEsMTEsMzEpO2Nhc2UgNjpyZXR1cm4gbmV3IERhdGUodC5nZXRGdWxsWWVhcigpLTEsMTEsMzApfX1mdW5jdGlvbiBsKHQpe3ZhciBlPXQuV2I7Zm9yKHQ9bmV3IERhdGUobmV3IERhdGUodC5YYisxOTAwLDAsMSkuZ2V0VGltZSgpKTswPGU7KXt2YXIgbj10LmdldE1vbnRoKCkscj0odWUodC5nZXRGdWxsWWVhcigpKT9jZTpzZSlbbl07aWYoIShlPnItdC5nZXREYXRlKCkpKXt0LnNldERhdGUodC5nZXREYXRlKCkrZSk7YnJlYWt9ZS09ci10LmdldERhdGUoKSsxLHQuc2V0RGF0ZSgxKSwxMT5uP3Quc2V0TW9udGgobisxKToodC5zZXRNb250aCgwKSx0LnNldEZ1bGxZZWFyKHQuZ2V0RnVsbFllYXIoKSsxKSl9cmV0dXJuIG49bmV3IERhdGUodC5nZXRGdWxsWWVhcigpKzEsMCw0KSxlPXMobmV3IERhdGUodC5nZXRGdWxsWWVhcigpLDAsNCkpLG49cyhuKSwwPj1jKGUsdCk/MD49YyhuLHQpP3QuZ2V0RnVsbFllYXIoKSsxOnQuZ2V0RnVsbFllYXIoKTp0LmdldEZ1bGxZZWFyKCktMX12YXIgZj1hKClbaSs0MD4+Mj4+PjBdO2Zvcih2YXIgcCBpbiBpPXtMYzphKClbaT4+Mj4+PjBdLEtjOmEoKVtpKzQ+PjI+Pj4wXSxkYzphKClbaSs4Pj4yPj4+MF0samM6YSgpW2krMTI+PjI+Pj4wXSxlYzphKClbaSsxNj4+Mj4+PjBdLFhiOmEoKVtpKzIwPj4yPj4+MF0sVGI6YSgpW2krMjQ+PjI+Pj4wXSxXYjphKClbaSsyOD4+Mj4+PjBdLFJjOmEoKVtpKzMyPj4yPj4+MF0sSmM6YSgpW2krMzY+PjI+Pj4wXSxNYzpmP1koZik6XCJcIn0scj1ZKHIpLGY9e1wiJWNcIjpcIiVhICViICVkICVIOiVNOiVTICVZXCIsXCIlRFwiOlwiJW0vJWQvJXlcIixcIiVGXCI6XCIlWS0lbS0lZFwiLFwiJWhcIjpcIiViXCIsXCIlclwiOlwiJUk6JU06JVMgJXBcIixcIiVSXCI6XCIlSDolTVwiLFwiJVRcIjpcIiVIOiVNOiVTXCIsXCIleFwiOlwiJW0vJWQvJXlcIixcIiVYXCI6XCIlSDolTTolU1wiLFwiJUVjXCI6XCIlY1wiLFwiJUVDXCI6XCIlQ1wiLFwiJUV4XCI6XCIlbS8lZC8leVwiLFwiJUVYXCI6XCIlSDolTTolU1wiLFwiJUV5XCI6XCIleVwiLFwiJUVZXCI6XCIlWVwiLFwiJU9kXCI6XCIlZFwiLFwiJU9lXCI6XCIlZVwiLFwiJU9IXCI6XCIlSFwiLFwiJU9JXCI6XCIlSVwiLFwiJU9tXCI6XCIlbVwiLFwiJU9NXCI6XCIlTVwiLFwiJU9TXCI6XCIlU1wiLFwiJU91XCI6XCIldVwiLFwiJU9VXCI6XCIlVVwiLFwiJU9WXCI6XCIlVlwiLFwiJU93XCI6XCIld1wiLFwiJU9XXCI6XCIlV1wiLFwiJU95XCI6XCIleVwifSlyPXIucmVwbGFjZShuZXcgUmVnRXhwKHAsXCJnXCIpLGZbcF0pO3ZhciBoPVwiU3VuZGF5IE1vbmRheSBUdWVzZGF5IFdlZG5lc2RheSBUaHVyc2RheSBGcmlkYXkgU2F0dXJkYXlcIi5zcGxpdChcIiBcIiksZD1cIkphbnVhcnkgRmVicnVhcnkgTWFyY2ggQXByaWwgTWF5IEp1bmUgSnVseSBBdWd1c3QgU2VwdGVtYmVyIE9jdG9iZXIgTm92ZW1iZXIgRGVjZW1iZXJcIi5zcGxpdChcIiBcIik7Zm9yKHAgaW4gZj17XCIlYVwiOmZ1bmN0aW9uKHQpe3JldHVybiBoW3QuVGJdLnN1YnN0cmluZygwLDMpfSxcIiVBXCI6ZnVuY3Rpb24odCl7cmV0dXJuIGhbdC5UYl19LFwiJWJcIjpmdW5jdGlvbih0KXtyZXR1cm4gZFt0LmVjXS5zdWJzdHJpbmcoMCwzKX0sXCIlQlwiOmZ1bmN0aW9uKHQpe3JldHVybiBkW3QuZWNdfSxcIiVDXCI6ZnVuY3Rpb24odCl7cmV0dXJuIHUoKHQuWGIrMTkwMCkvMTAwfDAsMil9LFwiJWRcIjpmdW5jdGlvbih0KXtyZXR1cm4gdSh0LmpjLDIpfSxcIiVlXCI6ZnVuY3Rpb24odCl7cmV0dXJuIG8odC5qYywyLFwiIFwiKX0sXCIlZ1wiOmZ1bmN0aW9uKHQpe3JldHVybiBsKHQpLnRvU3RyaW5nKCkuc3Vic3RyaW5nKDIpfSxcIiVHXCI6ZnVuY3Rpb24odCl7cmV0dXJuIGwodCl9LFwiJUhcIjpmdW5jdGlvbih0KXtyZXR1cm4gdSh0LmRjLDIpfSxcIiVJXCI6ZnVuY3Rpb24odCl7cmV0dXJuIDA9PSh0PXQuZGMpP3Q9MTI6MTI8dCYmKHQtPTEyKSx1KHQsMil9LFwiJWpcIjpmdW5jdGlvbih0KXtmb3IodmFyIGU9MCxuPTA7bjw9dC5lYy0xO2UrPSh1ZSh0LlhiKzE5MDApP2NlOnNlKVtuKytdKTtyZXR1cm4gdSh0LmpjK2UsMyl9LFwiJW1cIjpmdW5jdGlvbih0KXtyZXR1cm4gdSh0LmVjKzEsMil9LFwiJU1cIjpmdW5jdGlvbih0KXtyZXR1cm4gdSh0LktjLDIpfSxcIiVuXCI6ZnVuY3Rpb24oKXtyZXR1cm5cIlxcXFxuXCJ9LFwiJXBcIjpmdW5jdGlvbih0KXtyZXR1cm4gMDw9dC5kYyYmMTI+dC5kYz9cIkFNXCI6XCJQTVwifSxcIiVTXCI6ZnVuY3Rpb24odCl7cmV0dXJuIHUodC5MYywyKX0sXCIldFwiOmZ1bmN0aW9uKCl7cmV0dXJuXCJcXFxcdFwifSxcIiV1XCI6ZnVuY3Rpb24odCl7cmV0dXJuIHQuVGJ8fDd9LFwiJVVcIjpmdW5jdGlvbih0KXtyZXR1cm4gdShNYXRoLmZsb29yKCh0LldiKzctdC5UYikvNyksMil9LFwiJVZcIjpmdW5jdGlvbih0KXt2YXIgZT1NYXRoLmZsb29yKCh0LldiKzctKHQuVGIrNiklNykvNyk7aWYoMj49KHQuVGIrMzcxLXQuV2ItMiklNyYmZSsrLGUpNTM9PWUmJig0PT0obj0odC5UYiszNzEtdC5XYiklNyl8fDM9PW4mJnVlKHQuWGIpfHwoZT0xKSk7ZWxzZXtlPTUyO3ZhciBuPSh0LlRiKzctdC5XYi0xKSU3Oyg0PT1ufHw1PT1uJiZ1ZSh0LlhiJTQwMC0xKSkmJmUrK31yZXR1cm4gdShlLDIpfSxcIiV3XCI6ZnVuY3Rpb24odCl7cmV0dXJuIHQuVGJ9LFwiJVdcIjpmdW5jdGlvbih0KXtyZXR1cm4gdShNYXRoLmZsb29yKCh0LldiKzctKHQuVGIrNiklNykvNyksMil9LFwiJXlcIjpmdW5jdGlvbih0KXtyZXR1cm4odC5YYisxOTAwKS50b1N0cmluZygpLnN1YnN0cmluZygyKX0sXCIlWVwiOmZ1bmN0aW9uKHQpe3JldHVybiB0LlhiKzE5MDB9LFwiJXpcIjpmdW5jdGlvbih0KXt2YXIgZT0wPD0odD10LkpjKTtyZXR1cm4gdD1NYXRoLmFicyh0KS82MCwoZT9cIitcIjpcIi1cIikrU3RyaW5nKFwiMDAwMFwiKyh0LzYwKjEwMCt0JTYwKSkuc2xpY2UoLTQpfSxcIiVaXCI6ZnVuY3Rpb24odCl7cmV0dXJuIHQuTWN9LFwiJSVcIjpmdW5jdGlvbigpe3JldHVyblwiJVwifX0scj1yLnJlcGxhY2UoLyUlL2csXCJcXFxcMFxcXFwwXCIpLGYpci5pbmNsdWRlcyhwKSYmKHI9ci5yZXBsYWNlKG5ldyBSZWdFeHAocCxcImdcIiksZltwXShpKSkpO3JldHVybiBwPWZ1bmN0aW9uKHQpe3ZhciBlPUFycmF5KEcodCkrMSk7cmV0dXJuIEIodCxlLDAsZS5sZW5ndGgpLGV9KHI9ci5yZXBsYWNlKC9cXFxcMFxcXFwwL2csXCIlXCIpKSxwLmxlbmd0aD5uPzA6KGZ1bmN0aW9uKHQsbil7ZSgpLnNldCh0LG4+Pj4wKX0ocCx0KSxwLmxlbmd0aC0xKX1odC5mYygpO3ZhciBmZT1bbnVsbCxmdCxidCxFdCxDdCx4dCxSdCxqdCxrdCxEdCxQdCxVdCxGdCxJdCxXdCxIdCxMdCxCdCxHdCxWdCxRdCxLdCx0ZSxlZSxuZSxpZV0scGU9e2I6ZnVuY3Rpb24odCl7cmV0dXJuIGRlKHQrMjQpKzI0fSxuOmZ1bmN0aW9uKHQpe3JldHVybih0PW5ldyBTdCh0KSkudWMoKXx8KHQuaGMoITApLE90LS0pLHQuaWMoITEpLF90LnB1c2godCksdC5zYygpLHQudmMoKX0sbWE6ZnVuY3Rpb24odCl7dGhyb3cgeChcIlVuZXhwZWN0ZWQgZXhjZXB0aW9uIHRocm93biwgdGhpcyBpcyBub3QgcHJvcGVybHkgc3VwcG9ydGVkIC0gYWJvcnRpbmdcIiksSD0hMCx0fSx4OmZ1bmN0aW9uKCl7U2UoMCk7dmFyIHQ9X3QucG9wKCk7aWYodC5IYygpJiYhdC5rYygpKXt2YXIgZT10LkRjKCk7ZSYmZ3QoZSkodC5aYiksVHQodC5aYil9QXQ9MH0sZTpmdW5jdGlvbigpe3ZhciB0PUF0O2lmKCF0KXJldHVybiBvZT0wO3ZhciBlPW5ldyBTdCh0KTtlLmNjKHQpO3ZhciBuPWUuYmMoKTtpZighbilyZXR1cm4gb2U9MCx0O2Zvcih2YXIgcj1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpLGE9MDthPHIubGVuZ3RoO2ErKyl7dmFyIGk9clthXTtpZigwPT09aXx8aT09PW4pYnJlYWs7aWYoeGUoaSxuLGUuU2IrMTYpKXJldHVybiBvZT1pLHR9cmV0dXJuIG9lPW4sdH0sbDpmdW5jdGlvbigpe3ZhciB0PUF0O2lmKCF0KXJldHVybiBvZT0wO3ZhciBlPW5ldyBTdCh0KTtlLmNjKHQpO3ZhciBuPWUuYmMoKTtpZighbilyZXR1cm4gb2U9MCx0O2Zvcih2YXIgcj1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpLGE9MDthPHIubGVuZ3RoO2ErKyl7dmFyIGk9clthXTtpZigwPT09aXx8aT09PW4pYnJlYWs7aWYoeGUoaSxuLGUuU2IrMTYpKXJldHVybiBvZT1pLHR9cmV0dXJuIG9lPW4sdH0saDpmdW5jdGlvbigpe3ZhciB0PUF0O2lmKCF0KXJldHVybiBvZT0wO3ZhciBlPW5ldyBTdCh0KTtlLmNjKHQpO3ZhciBuPWUuYmMoKTtpZighbilyZXR1cm4gb2U9MCx0O2Zvcih2YXIgcj1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpLGE9MDthPHIubGVuZ3RoO2ErKyl7dmFyIGk9clthXTtpZigwPT09aXx8aT09PW4pYnJlYWs7aWYoeGUoaSxuLGUuU2IrMTYpKXJldHVybiBvZT1pLHR9cmV0dXJuIG9lPW4sdH0sdDpUdCxNOmZ1bmN0aW9uKCl7dmFyIHQ9X3QucG9wKCk7dHx8YXQoXCJubyBleGNlcHRpb24gdG8gdGhyb3dcIik7dmFyIGU9dC5aYjt0aHJvdyB0LmtjKCl8fChfdC5wdXNoKHQpLHQuaWMoITApLHQuaGMoITEpLE90KyspLEF0PWUsZX0sYzpmdW5jdGlvbih0LGUsbil7dGhyb3cgbmV3IFN0KHQpLmZjKGUsbiksQXQ9dCxPdCsrLHR9LHBhOmZ1bmN0aW9uKCl7cmV0dXJuIE90fSxGYTpmdW5jdGlvbih0KXtnZSh0LCF3LDEsIXYpLGh0LnBjKCl9LFQ6ZnVuY3Rpb24odCl7Tz9wb3N0TWVzc2FnZSh7Y21kOlwiY2xlYW51cFRocmVhZFwiLHRocmVhZDp0fSk6c3QodCl9LHhhOk10LGo6ZnVuY3Rpb24odCl7dGhyb3cgQXR8fChBdD10KSx0fSxIOkN0LE1hOnh0LHVhOlJ0LHdhOmp0LG9hOmt0LEthOkR0LENhOlB0LEphOlV0LFY6RnQsdmE6SXQsc2E6V3QsTGE6SHQsdGE6THQsVGE6ZnVuY3Rpb24oKXt9LFg6ZnVuY3Rpb24oKXthdChcIlRvIHVzZSBkbG9wZW4sIHlvdSBuZWVkIGVuYWJsZSBkeW5hbWljIGxpbmtpbmcsIHNlZSBodHRwczovL2dpdGh1Yi5jb20vZW1zY3JpcHRlbi1jb3JlL2Vtc2NyaXB0ZW4vd2lraS9MaW5raW5nXCIpfSxVYTpmdW5jdGlvbigpe2F0KFwiVG8gdXNlIGRsb3BlbiwgeW91IG5lZWQgZW5hYmxlIGR5bmFtaWMgbGlua2luZywgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9lbXNjcmlwdGVuLWNvcmUvZW1zY3JpcHRlbi93aWtpL0xpbmtpbmdcIil9LFc6ZnVuY3Rpb24oKXtyZXR1cm4gRGF0ZS5ub3coKX0seWE6ZnVuY3Rpb24oKXtyZXR1cm4gMjA5NzE1Mn0sT2E6ZnVuY3Rpb24oKXtyZXR1cm4hMH0semE6ZnVuY3Rpb24odCxlLG4scil7aWYodD09ZSlzZXRUaW1lb3V0KCgoKT0+enQocikpKTtlbHNlIGlmKE8pcG9zdE1lc3NhZ2Uoe3RhcmdldFRocmVhZDp0LGNtZDpcInByb2Nlc3NQcm94eWluZ1F1ZXVlXCIscXVldWU6cn0pO2Vsc2V7aWYoISh0PWh0LlZiW3RdKSlyZXR1cm47dC5wb3N0TWVzc2FnZSh7Y21kOlwicHJvY2Vzc1Byb3h5aW5nUXVldWVcIixxdWV1ZTpyfSl9cmV0dXJuIDF9LEVhOmZ1bmN0aW9uKCl7cmV0dXJuLTF9LFBhOmZ1bmN0aW9uKHQsZSl7dD1uZXcgRGF0ZSgxZTMqWXQodCkpLGEoKVtlPj4yPj4+MF09dC5nZXRVVENTZWNvbmRzKCksYSgpW2UrND4+Mj4+PjBdPXQuZ2V0VVRDTWludXRlcygpLGEoKVtlKzg+PjI+Pj4wXT10LmdldFVUQ0hvdXJzKCksYSgpW2UrMTI+PjI+Pj4wXT10LmdldFVUQ0RhdGUoKSxhKClbZSsxNj4+Mj4+PjBdPXQuZ2V0VVRDTW9udGgoKSxhKClbZSsyMD4+Mj4+PjBdPXQuZ2V0VVRDRnVsbFllYXIoKS0xOTAwLGEoKVtlKzI0Pj4yPj4+MF09dC5nZXRVVENEYXkoKSx0PSh0LmdldFRpbWUoKS1EYXRlLlVUQyh0LmdldFVUQ0Z1bGxZZWFyKCksMCwxLDAsMCwwLDApKS84NjRlNXwwLGEoKVtlKzI4Pj4yPj4+MF09dH0sUWE6ZnVuY3Rpb24odCxlKXt0PW5ldyBEYXRlKDFlMypZdCh0KSksYSgpW2U+PjI+Pj4wXT10LmdldFNlY29uZHMoKSxhKClbZSs0Pj4yPj4+MF09dC5nZXRNaW51dGVzKCksYSgpW2UrOD4+Mj4+PjBdPXQuZ2V0SG91cnMoKSxhKClbZSsxMj4+Mj4+PjBdPXQuZ2V0RGF0ZSgpLGEoKVtlKzE2Pj4yPj4+MF09dC5nZXRNb250aCgpLGEoKVtlKzIwPj4yPj4+MF09dC5nZXRGdWxsWWVhcigpLTE5MDAsYSgpW2UrMjQ+PjI+Pj4wXT10LmdldERheSgpO3ZhciBuPW5ldyBEYXRlKHQuZ2V0RnVsbFllYXIoKSwwLDEpLHI9KHQuZ2V0VGltZSgpLW4uZ2V0VGltZSgpKS84NjRlNXwwO2EoKVtlKzI4Pj4yPj4+MF09cixhKClbZSszNj4+Mj4+PjBdPS02MCp0LmdldFRpbWV6b25lT2Zmc2V0KCkscj1uZXcgRGF0ZSh0LmdldEZ1bGxZZWFyKCksNiwxKS5nZXRUaW1lem9uZU9mZnNldCgpLHQ9MHwociE9KG49bi5nZXRUaW1lem9uZU9mZnNldCgpKSYmdC5nZXRUaW1lem9uZU9mZnNldCgpPT1NYXRoLm1pbihuLHIpKSxhKClbZSszMj4+Mj4+PjBdPXR9LFJhOmZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBEYXRlKGEoKVt0KzIwPj4yPj4+MF0rMTkwMCxhKClbdCsxNj4+Mj4+PjBdLGEoKVt0KzEyPj4yPj4+MF0sYSgpW3QrOD4+Mj4+PjBdLGEoKVt0KzQ+PjI+Pj4wXSxhKClbdD4+Mj4+PjBdLDApLG49YSgpW3QrMzI+PjI+Pj4wXSxyPWUuZ2V0VGltZXpvbmVPZmZzZXQoKSxpPW5ldyBEYXRlKGUuZ2V0RnVsbFllYXIoKSwwLDEpLG89bmV3IERhdGUoZS5nZXRGdWxsWWVhcigpLDYsMSkuZ2V0VGltZXpvbmVPZmZzZXQoKSx1PWkuZ2V0VGltZXpvbmVPZmZzZXQoKSxjPU1hdGgubWluKHUsbyk7cmV0dXJuIDA+bj9hKClbdCszMj4+Mj4+PjBdPU51bWJlcihvIT11JiZjPT1yKTowPG4hPShjPT1yKSYmKG89TWF0aC5tYXgodSxvKSxlLnNldFRpbWUoZS5nZXRUaW1lKCkrNmU0KigoMDxuP2M6byktcikpKSxhKClbdCsyND4+Mj4+PjBdPWUuZ2V0RGF5KCksbj0oZS5nZXRUaW1lKCktaS5nZXRUaW1lKCkpLzg2NGU1fDAsYSgpW3QrMjg+PjI+Pj4wXT1uLGEoKVt0Pj4yPj4+MF09ZS5nZXRTZWNvbmRzKCksYSgpW3QrND4+Mj4+PjBdPWUuZ2V0TWludXRlcygpLGEoKVt0Kzg+PjI+Pj4wXT1lLmdldEhvdXJzKCksYSgpW3QrMTI+PjI+Pj4wXT1lLmdldERhdGUoKSxhKClbdCsxNj4+Mj4+PjBdPWUuZ2V0TW9udGgoKSxlLmdldFRpbWUoKS8xZTN8MH0sQWE6QnQsQmE6R3QsU2E6ZnVuY3Rpb24gdChlLG4scil7dC5BY3x8KHQuQWM9ITAsVnQoZSxuLHIpKX0seTpmdW5jdGlvbigpe2F0KFwiXCIpfSxVOmZ1bmN0aW9uKCl7aWYoIV8mJiF3KXt2YXIgdD1cIkJsb2NraW5nIG9uIHRoZSBtYWluIHRocmVhZCBpcyB2ZXJ5IGRhbmdlcm91cywgc2VlIGh0dHBzOi8vZW1zY3JpcHRlbi5vcmcvZG9jcy9wb3J0aW5nL3B0aHJlYWRzLmh0bWwjYmxvY2tpbmctb24tdGhlLW1haW4tYnJvd3Nlci10aHJlYWRcIjt2dHx8KHZ0PXt9KSx2dFt0XXx8KHZ0W3RdPTEsXyYmKHQ9XCJ3YXJuaW5nOiBcIit0KSx4KHQpKX19LHJhOmZ1bmN0aW9uKCl7cmV0dXJuIDQyOTQ5MDE3NjB9LEI6d3QsSWE6ZnVuY3Rpb24odCxlLG4pe3IoKS5jb3B5V2l0aGluKHQ+Pj4wLGU+Pj4wLGUrbj4+PjApfSxGOmZ1bmN0aW9uKCl7cmV0dXJuIF8/big5OTMpLmNwdXMoKS5sZW5ndGg6bmF2aWdhdG9yLmhhcmR3YXJlQ29uY3VycmVuY3l9LERhOmZ1bmN0aW9uKHQsZSxuKXtYdC5sZW5ndGg9ZSxuPj49Mztmb3IodmFyIHI9MDtyPGU7cisrKVh0W3JdPW8oKVtuK3I+Pj4wXTtyZXR1cm4oMD50P3V0Wy10LTFdOmZlW3RdKS5hcHBseShudWxsLFh0KX0scWE6ZnVuY3Rpb24odCl7dmFyIGU9cigpLmxlbmd0aDtpZigodD4+Pj0wKTw9ZXx8NDI5NDkwMTc2MDx0KXJldHVybiExO2Zvcih2YXIgbj0xOzQ+PW47bio9Mil7dmFyIGE9ZSooMSsuMi9uKTthPU1hdGgubWluKGEsdCsxMDA2NjMyOTYpO3ZhciBpPU1hdGg7YT1NYXRoLm1heCh0LGEpLGk9aS5taW4uY2FsbChpLDQyOTQ5MDE3NjAsYSsoNjU1MzYtYSU2NTUzNiklNjU1MzYpO3Q6e3RyeXtqLmdyb3coaS1ELmJ5dGVMZW5ndGgrNjU1MzU+Pj4xNiksTihqLmJ1ZmZlcik7dmFyIG89MTticmVhayB0fWNhdGNoKHQpe31vPXZvaWQgMH1pZihvKXJldHVybiEwfXJldHVybiExfSxOYTpmdW5jdGlvbigpe3Rocm93XCJ1bndpbmRcIn0sR2E6UXQsSGE6S3QsSjpwdCxJOnRlLFM6ZWUsZ2E6bmUsUjppZSxkOmZ1bmN0aW9uKCl7cmV0dXJuIG9lfSxuYTpmdW5jdGlvbiB0KHIsYSl7dC5sY3x8KHQubGM9ZnVuY3Rpb24oKXtpZihcIm9iamVjdFwiPT10eXBlb2YgY3J5cHRvJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKXt2YXIgdD1uZXcgVWludDhBcnJheSgxKTtyZXR1cm4oKT0+KGNyeXB0by5nZXRSYW5kb21WYWx1ZXModCksdFswXSl9aWYoXyl0cnl7dmFyIGU9bihPYmplY3QoZnVuY3Rpb24oKXt2YXIgdD1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgXFwnY3J5cHRvXFwnXCIpO3Rocm93IHQuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIix0fSgpKSk7cmV0dXJuKCk9PmUucmFuZG9tQnl0ZXMoMSlbMF19Y2F0Y2godCl7fXJldHVybigpPT5hdChcInJhbmRvbURldmljZVwiKX0oKSk7Zm9yKHZhciBpPTA7aTxhO2krKyllKClbcitpPj4wPj4+MF09dC5sYygpO3JldHVybiAwfSxpYTpmdW5jdGlvbih0LGUsbil7dmFyIHI9RWUoKTt0cnl7cmV0dXJuIGd0KHQpKGUsbil9Y2F0Y2godCl7aWYoTWUociksdCE9PXQrMCl0aHJvdyB0O1NlKDEsMCl9fSxqYTpmdW5jdGlvbih0LGUsbil7dmFyIHI9RWUoKTt0cnl7cmV0dXJuIGd0KHQpKGUsbil9Y2F0Y2godCl7aWYoTWUociksdCE9PXQrMCl0aHJvdyB0O1NlKDEsMCl9fSxLOmZ1bmN0aW9uKHQpe3ZhciBlPUVlKCk7dHJ5e3JldHVybiBndCh0KSgpfWNhdGNoKHQpe2lmKE1lKGUpLHQhPT10KzApdGhyb3cgdDtTZSgxLDApfX0sZjpmdW5jdGlvbih0LGUpe3ZhciBuPUVlKCk7dHJ5e3JldHVybiBndCh0KShlKX1jYXRjaCh0KXtpZihNZShuKSx0IT09dCswKXRocm93IHQ7U2UoMSwwKX19LFA6ZnVuY3Rpb24odCxlLG4pe3ZhciByPUVlKCk7dHJ5e3JldHVybiBndCh0KShlLG4pfWNhdGNoKHQpe2lmKE1lKHIpLHQhPT10KzApdGhyb3cgdDtTZSgxLDApfX0sUTpmdW5jdGlvbih0LGUsbil7dmFyIHI9RWUoKTt0cnl7cmV0dXJuIGd0KHQpKGUsbil9Y2F0Y2godCl7aWYoTWUociksdCE9PXQrMCl0aHJvdyB0O1NlKDEsMCl9fSxrOmZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1FZSgpO3RyeXtyZXR1cm4gZ3QodCkoZSxuKX1jYXRjaCh0KXtpZihNZShyKSx0IT09dCswKXRocm93IHQ7U2UoMSwwKX19LHA6ZnVuY3Rpb24odCxlLG4scil7dmFyIGE9RWUoKTt0cnl7cmV0dXJuIGd0KHQpKGUsbixyKX1jYXRjaCh0KXtpZihNZShhKSx0IT09dCswKXRocm93IHQ7U2UoMSwwKX19LHE6ZnVuY3Rpb24odCxlLG4scixhKXt2YXIgaT1FZSgpO3RyeXtyZXR1cm4gZ3QodCkoZSxuLHIsYSl9Y2F0Y2godCl7aWYoTWUoaSksdCE9PXQrMCl0aHJvdyB0O1NlKDEsMCl9fSxOOmZ1bmN0aW9uKHQsZSxuLHIsYSxpKXt2YXIgbz1FZSgpO3RyeXtyZXR1cm4gZ3QodCkoZSxuLHIsYSxpKX1jYXRjaCh0KXtpZihNZShvKSx0IT09dCswKXRocm93IHQ7U2UoMSwwKX19LHM6ZnVuY3Rpb24odCxlLG4scixhLGkpe3ZhciBvPUVlKCk7dHJ5e3JldHVybiBndCh0KShlLG4scixhLGkpfWNhdGNoKHQpe2lmKE1lKG8pLHQhPT10KzApdGhyb3cgdDtTZSgxLDApfX0sdzpmdW5jdGlvbih0LGUsbixyLGEsaSxvKXt2YXIgdT1FZSgpO3RyeXtyZXR1cm4gZ3QodCkoZSxuLHIsYSxpLG8pfWNhdGNoKHQpe2lmKE1lKHUpLHQhPT10KzApdGhyb3cgdDtTZSgxLDApfX0sTDpmdW5jdGlvbih0LGUsbixyLGEsaSxvLHUpe3ZhciBjPUVlKCk7dHJ5e3JldHVybiBndCh0KShlLG4scixhLGksbyx1KX1jYXRjaCh0KXtpZihNZShjKSx0IT09dCswKXRocm93IHQ7U2UoMSwwKX19LEU6ZnVuY3Rpb24odCxlLG4scixhLGksbyx1LGMscyxsLGYpe3ZhciBwPUVlKCk7dHJ5e3JldHVybiBndCh0KShlLG4scixhLGksbyx1LGMscyxsLGYpfWNhdGNoKHQpe2lmKE1lKHApLHQhPT10KzApdGhyb3cgdDtTZSgxLDApfX0sYWE6ZnVuY3Rpb24odCxlLG4scixhLGksbyx1KXt2YXIgYz1FZSgpO3RyeXtyZXR1cm4gSGUodCxlLG4scixhLGksbyx1KX1jYXRjaCh0KXtpZihNZShjKSx0IT09dCswKXRocm93IHQ7U2UoMSwwKX19LF86ZnVuY3Rpb24odCxlLG4scixhLGksbyl7dmFyIHU9RWUoKTt0cnl7cmV0dXJuIGtlKHQsZSxuLHIsYSxpLG8pfWNhdGNoKHQpe2lmKE1lKHUpLHQhPT10KzApdGhyb3cgdDtTZSgxLDApfX0sWjpmdW5jdGlvbih0LGUsbixyLGEpe3ZhciBpPUVlKCk7dHJ5e3JldHVybiBMZSh0LGUsbixyLGEpfWNhdGNoKHQpe2lmKE1lKGkpLHQhPT10KzApdGhyb3cgdDtTZSgxLDApfX0sY2E6ZnVuY3Rpb24odCxlLG4scil7dmFyIGE9RWUoKTt0cnl7cmV0dXJuIEllKHQsZSxuLHIpfWNhdGNoKHQpe2lmKE1lKGEpLHQhPT10KzApdGhyb3cgdDtTZSgxLDApfX0sJDpmdW5jdGlvbih0KXt2YXIgZT1FZSgpO3RyeXtyZXR1cm4gamUodCl9Y2F0Y2godCl7aWYoTWUoZSksdCE9PXQrMCl0aHJvdyB0O1NlKDEsMCl9fSxiYTpmdW5jdGlvbih0LGUpe3ZhciBuPUVlKCk7dHJ5e3JldHVybiBXZSh0LGUpfWNhdGNoKHQpe2lmKE1lKG4pLHQhPT10KzApdGhyb3cgdDtTZSgxLDApfX0sWTpmdW5jdGlvbih0LGUsbil7dmFyIHI9RWUoKTt0cnl7cmV0dXJuIERlKHQsZSxuKX1jYXRjaCh0KXtpZihNZShyKSx0IT09dCswKXRocm93IHQ7U2UoMSwwKX19LGc6ZnVuY3Rpb24odCl7dmFyIGU9RWUoKTt0cnl7Z3QodCkoKX1jYXRjaCh0KXtpZihNZShlKSx0IT09dCswKXRocm93IHQ7U2UoMSwwKX19LHI6ZnVuY3Rpb24odCxlKXt2YXIgbj1FZSgpO3RyeXtndCh0KShlKX1jYXRjaCh0KXtpZihNZShuKSx0IT09dCswKXRocm93IHQ7U2UoMSwwKX19LGk6ZnVuY3Rpb24odCxlLG4pe3ZhciByPUVlKCk7dHJ5e2d0KHQpKGUsbil9Y2F0Y2godCl7aWYoTWUociksdCE9PXQrMCl0aHJvdyB0O1NlKDEsMCl9fSxoYTpmdW5jdGlvbih0LGUsbixyKXt2YXIgYT1FZSgpO3RyeXtndCh0KShlLG4scil9Y2F0Y2godCl7aWYoTWUoYSksdCE9PXQrMCl0aHJvdyB0O1NlKDEsMCl9fSxtOmZ1bmN0aW9uKHQsZSxuLHIpe3ZhciBhPUVlKCk7dHJ5e2d0KHQpKGUsbixyKX1jYXRjaCh0KXtpZihNZShhKSx0IT09dCswKXRocm93IHQ7U2UoMSwwKX19LHY6ZnVuY3Rpb24odCxlLG4scixhKXt2YXIgaT1FZSgpO3RyeXtndCh0KShlLG4scixhKX1jYXRjaCh0KXtpZihNZShpKSx0IT09dCswKXRocm93IHQ7U2UoMSwwKX19LHU6ZnVuY3Rpb24odCxlLG4scixhLGkpe3ZhciBvPUVlKCk7dHJ5e2d0KHQpKGUsbixyLGEsaSl9Y2F0Y2godCl7aWYoTWUobyksdCE9PXQrMCl0aHJvdyB0O1NlKDEsMCl9fSxPOmZ1bmN0aW9uKHQsZSxuLHIsYSxpLG8pe3ZhciB1PUVlKCk7dHJ5e2d0KHQpKGUsbixyLGEsaSxvKX1jYXRjaCh0KXtpZihNZSh1KSx0IT09dCswKXRocm93IHQ7U2UoMSwwKX19LEE6ZnVuY3Rpb24odCxlLG4scixhLGksbyx1KXt2YXIgYz1FZSgpO3RyeXtndCh0KShlLG4scixhLGksbyx1KX1jYXRjaCh0KXtpZihNZShjKSx0IT09dCswKXRocm93IHQ7U2UoMSwwKX19LGthOmZ1bmN0aW9uKHQsZSxuLHIsYSxpLG8sdSxjKXt2YXIgcz1FZSgpO3RyeXtndCh0KShlLG4scixhLGksbyx1LGMpfWNhdGNoKHQpe2lmKE1lKHMpLHQhPT10KzApdGhyb3cgdDtTZSgxLDApfX0sQzpmdW5jdGlvbih0LGUsbixyLGEsaSxvLHUsYyxzLGwpe3ZhciBmPUVlKCk7dHJ5e2d0KHQpKGUsbixyLGEsaSxvLHUsYyxzLGwpfWNhdGNoKHQpe2lmKE1lKGYpLHQhPT10KzApdGhyb3cgdDtTZSgxLDApfX0sRDpmdW5jdGlvbih0LGUsbixyLGEsaSxvLHUsYyxzLGwsZixwLGgsZCx5KXt2YXIgYj1FZSgpO3RyeXtndCh0KShlLG4scixhLGksbyx1LGMscyxsLGYscCxoLGQseSl9Y2F0Y2godCl7aWYoTWUoYiksdCE9PXQrMCl0aHJvdyB0O1NlKDEsMCl9fSxmYTpmdW5jdGlvbih0LGUsbixyLGEsaSxvLHUpe3ZhciBjPUVlKCk7dHJ5e1BlKHQsZSxuLHIsYSxpLG8sdSl9Y2F0Y2godCl7aWYoTWUoYyksdCE9PXQrMCl0aHJvdyB0O1NlKDEsMCl9fSxkYTpmdW5jdGlvbih0LGUsbixyLGEsaSxvLHUsYyxzLGwsZil7dmFyIHA9RWUoKTt0cnl7RmUodCxlLG4scixhLGksbyx1LGMscyxsLGYpfWNhdGNoKHQpe2lmKE1lKHApLHQhPT10KzApdGhyb3cgdDtTZSgxLDApfX0sZWE6ZnVuY3Rpb24odCxlLG4scixhLGkpe3ZhciBvPUVlKCk7dHJ5e1VlKHQsZSxuLHIsYSxpKX1jYXRjaCh0KXtpZihNZShvKSx0IT09dCswKXRocm93IHQ7U2UoMSwwKX19LG86ZnVuY3Rpb24odCl7cmV0dXJuIHR9LGE6anx8dS53YXNtTWVtb3J5LEc6ZnVuY3Rpb24odCl7b2U9dH0sbGE6bGUsejpmdW5jdGlvbih0LGUsbixyKXtyZXR1cm4gbGUodCxlLG4scil9fTshZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQsZSl7dS5hc209dC5leHBvcnRzLGh0LnFjLnB1c2godS5hc20uc2IpLCQ9dS5hc20udWIsWC51bnNoaWZ0KHUuYXNtLlZhKSxrPWUsT3x8KGV0LS0sdS5tb25pdG9yUnVuRGVwZW5kZW5jaWVzJiZ1Lm1vbml0b3JSdW5EZXBlbmRlbmNpZXMoZXQpLDA9PWV0JiYobnVsbCE9PW50JiYoY2xlYXJJbnRlcnZhbChudCksbnQ9bnVsbCkscnQmJih0PXJ0LHJ0PW51bGwsdCgpKSkpfWZ1bmN0aW9uIGUoZSl7dChlLmluc3RhbmNlLGUubW9kdWxlKX1mdW5jdGlvbiBuKHQpe3JldHVybiBmdW5jdGlvbigpe2lmKCFNJiYodnx8dykpe2lmKFwiZnVuY3Rpb25cIj09dHlwZW9mIGZldGNoJiYhdHQuc3RhcnRzV2l0aChcImZpbGU6Ly9cIikpcmV0dXJuIGZldGNoKHR0LHtjcmVkZW50aWFsczpcInNhbWUtb3JpZ2luXCJ9KS50aGVuKChmdW5jdGlvbih0KXtpZighdC5vayl0aHJvd1wiZmFpbGVkIHRvIGxvYWQgd2FzbSBiaW5hcnkgZmlsZSBhdCBcXCdcIit0dCtcIlxcJ1wiO3JldHVybiB0LmFycmF5QnVmZmVyKCl9KSkuY2F0Y2goKGZ1bmN0aW9uKCl7cmV0dXJuIG90KCl9KSk7aWYoZilyZXR1cm4gbmV3IFByb21pc2UoKGZ1bmN0aW9uKHQsZSl7Zih0dCwoZnVuY3Rpb24oZSl7dChuZXcgVWludDhBcnJheShlKSl9KSxlKX0pKX1yZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoZnVuY3Rpb24oKXtyZXR1cm4gb3QoKX0pKX0oKS50aGVuKChmdW5jdGlvbih0KXtyZXR1cm4gV2ViQXNzZW1ibHkuaW5zdGFudGlhdGUodCxyKX0pKS50aGVuKChmdW5jdGlvbih0KXtyZXR1cm4gdH0pKS50aGVuKHQsKGZ1bmN0aW9uKHQpe3goXCJmYWlsZWQgdG8gYXN5bmNocm9ub3VzbHkgcHJlcGFyZSB3YXNtOiBcIit0KSxhdCh0KX0pKX12YXIgcj17YTpwZX07aWYoT3x8KGV0KyssdS5tb25pdG9yUnVuRGVwZW5kZW5jaWVzJiZ1Lm1vbml0b3JSdW5EZXBlbmRlbmNpZXMoZXQpKSx1Lmluc3RhbnRpYXRlV2FzbSl0cnl7cmV0dXJuIHUuaW5zdGFudGlhdGVXYXNtKHIsdCl9Y2F0Y2godCl7cmV0dXJuIHgoXCJNb2R1bGUuaW5zdGFudGlhdGVXYXNtIGNhbGxiYWNrIGZhaWxlZCB3aXRoIGVycm9yOiBcIit0KSwhMX0oTXx8XCJmdW5jdGlvblwiIT10eXBlb2YgV2ViQXNzZW1ibHkuaW5zdGFudGlhdGVTdHJlYW1pbmd8fGl0KCl8fHR0LnN0YXJ0c1dpdGgoXCJmaWxlOi8vXCIpfHxffHxcImZ1bmN0aW9uXCIhPXR5cGVvZiBmZXRjaD9uKGUpOmZldGNoKHR0LHtjcmVkZW50aWFsczpcInNhbWUtb3JpZ2luXCJ9KS50aGVuKChmdW5jdGlvbih0KXtyZXR1cm4gV2ViQXNzZW1ibHkuaW5zdGFudGlhdGVTdHJlYW1pbmcodCxyKS50aGVuKGUsKGZ1bmN0aW9uKHQpe3JldHVybiB4KFwid2FzbSBzdHJlYW1pbmcgY29tcGlsZSBmYWlsZWQ6IFwiK3QpLHgoXCJmYWxsaW5nIGJhY2sgdG8gQXJyYXlCdWZmZXIgaW5zdGFudGlhdGlvblwiKSxuKGUpfSkpfSkpKS5jYXRjaChzKX0oKSx1Ll9fX3dhc21fY2FsbF9jdG9ycz1mdW5jdGlvbigpe3JldHVybih1Ll9fX3dhc21fY2FsbF9jdG9ycz11LmFzbS5WYSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSx1Ll9PcnRJbml0PWZ1bmN0aW9uKCl7cmV0dXJuKHUuX09ydEluaXQ9dS5hc20uV2EpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sdS5fT3J0Q3JlYXRlU2Vzc2lvbk9wdGlvbnM9ZnVuY3Rpb24oKXtyZXR1cm4odS5fT3J0Q3JlYXRlU2Vzc2lvbk9wdGlvbnM9dS5hc20uWGEpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sdS5fT3J0QXBwZW5kRXhlY3V0aW9uUHJvdmlkZXI9ZnVuY3Rpb24oKXtyZXR1cm4odS5fT3J0QXBwZW5kRXhlY3V0aW9uUHJvdmlkZXI9dS5hc20uWWEpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sdS5fT3J0QWRkU2Vzc2lvbkNvbmZpZ0VudHJ5PWZ1bmN0aW9uKCl7cmV0dXJuKHUuX09ydEFkZFNlc3Npb25Db25maWdFbnRyeT11LmFzbS5aYSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSx1Ll9PcnRSZWxlYXNlU2Vzc2lvbk9wdGlvbnM9ZnVuY3Rpb24oKXtyZXR1cm4odS5fT3J0UmVsZWFzZVNlc3Npb25PcHRpb25zPXUuYXNtLl9hKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHUuX09ydENyZWF0ZVNlc3Npb249ZnVuY3Rpb24oKXtyZXR1cm4odS5fT3J0Q3JlYXRlU2Vzc2lvbj11LmFzbS4kYSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSx1Ll9PcnRSZWxlYXNlU2Vzc2lvbj1mdW5jdGlvbigpe3JldHVybih1Ll9PcnRSZWxlYXNlU2Vzc2lvbj11LmFzbS5hYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSx1Ll9PcnRHZXRJbnB1dENvdW50PWZ1bmN0aW9uKCl7cmV0dXJuKHUuX09ydEdldElucHV0Q291bnQ9dS5hc20uYmIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sdS5fT3J0R2V0T3V0cHV0Q291bnQ9ZnVuY3Rpb24oKXtyZXR1cm4odS5fT3J0R2V0T3V0cHV0Q291bnQ9dS5hc20uY2IpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sdS5fT3J0R2V0SW5wdXROYW1lPWZ1bmN0aW9uKCl7cmV0dXJuKHUuX09ydEdldElucHV0TmFtZT11LmFzbS5kYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSx1Ll9PcnRHZXRPdXRwdXROYW1lPWZ1bmN0aW9uKCl7cmV0dXJuKHUuX09ydEdldE91dHB1dE5hbWU9dS5hc20uZWIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sdS5fT3J0RnJlZT1mdW5jdGlvbigpe3JldHVybih1Ll9PcnRGcmVlPXUuYXNtLmZiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHUuX09ydENyZWF0ZVRlbnNvcj1mdW5jdGlvbigpe3JldHVybih1Ll9PcnRDcmVhdGVUZW5zb3I9dS5hc20uZ2IpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sdS5fT3J0R2V0VGVuc29yRGF0YT1mdW5jdGlvbigpe3JldHVybih1Ll9PcnRHZXRUZW5zb3JEYXRhPXUuYXNtLmhiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHUuX09ydFJlbGVhc2VUZW5zb3I9ZnVuY3Rpb24oKXtyZXR1cm4odS5fT3J0UmVsZWFzZVRlbnNvcj11LmFzbS5pYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSx1Ll9PcnRDcmVhdGVSdW5PcHRpb25zPWZ1bmN0aW9uKCl7cmV0dXJuKHUuX09ydENyZWF0ZVJ1bk9wdGlvbnM9dS5hc20uamIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sdS5fT3J0QWRkUnVuQ29uZmlnRW50cnk9ZnVuY3Rpb24oKXtyZXR1cm4odS5fT3J0QWRkUnVuQ29uZmlnRW50cnk9dS5hc20ua2IpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sdS5fT3J0UmVsZWFzZVJ1bk9wdGlvbnM9ZnVuY3Rpb24oKXtyZXR1cm4odS5fT3J0UmVsZWFzZVJ1bk9wdGlvbnM9dS5hc20ubGIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sdS5fT3J0UnVuPWZ1bmN0aW9uKCl7cmV0dXJuKHUuX09ydFJ1bj11LmFzbS5tYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSx1Ll9PcnRFbmRQcm9maWxpbmc9ZnVuY3Rpb24oKXtyZXR1cm4odS5fT3J0RW5kUHJvZmlsaW5nPXUuYXNtLm5iKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O3ZhciBoZT11Ll9wdGhyZWFkX3NlbGY9ZnVuY3Rpb24oKXtyZXR1cm4oaGU9dS5fcHRocmVhZF9zZWxmPXUuYXNtLm9iKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGRlPXUuX21hbGxvYz1mdW5jdGlvbigpe3JldHVybihkZT11Ll9tYWxsb2M9dS5hc20ucGIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0seWU9dS5fZnJlZT1mdW5jdGlvbigpe3JldHVybih5ZT11Ll9mcmVlPXUuYXNtLnFiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGJlPXUuX2ZmbHVzaD1mdW5jdGlvbigpe3JldHVybihiZT11Ll9mZmx1c2g9dS5hc20ucmIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX07dS5fX2Vtc2NyaXB0ZW5fdGxzX2luaXQ9ZnVuY3Rpb24oKXtyZXR1cm4odS5fX2Vtc2NyaXB0ZW5fdGxzX2luaXQ9dS5hc20uc2IpLmFwcGx5KG51bGwsYXJndW1lbnRzKX07dmFyIG1lPXUuX19fZnVuY3Nfb25fZXhpdD1mdW5jdGlvbigpe3JldHVybihtZT11Ll9fX2Z1bmNzX29uX2V4aXQ9dS5hc20udGIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sZ2U9dS5fX2Vtc2NyaXB0ZW5fdGhyZWFkX2luaXQ9ZnVuY3Rpb24oKXtyZXR1cm4oZ2U9dS5fX2Vtc2NyaXB0ZW5fdGhyZWFkX2luaXQ9dS5hc20udmIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX07dS5fX2Vtc2NyaXB0ZW5fdGhyZWFkX2NyYXNoZWQ9ZnVuY3Rpb24oKXtyZXR1cm4odS5fX2Vtc2NyaXB0ZW5fdGhyZWFkX2NyYXNoZWQ9dS5hc20ud2IpLmFwcGx5KG51bGwsYXJndW1lbnRzKX07dmFyIHZlLHdlPXUuX2Vtc2NyaXB0ZW5fcnVuX2luX21haW5fcnVudGltZV90aHJlYWRfanM9ZnVuY3Rpb24oKXtyZXR1cm4od2U9dS5fZW1zY3JpcHRlbl9ydW5faW5fbWFpbl9ydW50aW1lX3RocmVhZF9qcz11LmFzbS54YikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxfZT11Ll9fZW1zY3JpcHRlbl9wcm94eV9leGVjdXRlX3Rhc2tfcXVldWU9ZnVuY3Rpb24oKXtyZXR1cm4oX2U9dS5fX2Vtc2NyaXB0ZW5fcHJveHlfZXhlY3V0ZV90YXNrX3F1ZXVlPXUuYXNtLnliKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LE9lPXUuX19lbXNjcmlwdGVuX3RocmVhZF9mcmVlX2RhdGE9ZnVuY3Rpb24oKXtyZXR1cm4oT2U9dS5fX2Vtc2NyaXB0ZW5fdGhyZWFkX2ZyZWVfZGF0YT11LmFzbS56YikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxBZT11Ll9fZW1zY3JpcHRlbl90aHJlYWRfZXhpdD1mdW5jdGlvbigpe3JldHVybihBZT11Ll9fZW1zY3JpcHRlbl90aHJlYWRfZXhpdD11LmFzbS5BYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxTZT11Ll9zZXRUaHJldz1mdW5jdGlvbigpe3JldHVybihTZT11Ll9zZXRUaHJldz11LmFzbS5CYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxUZT11Ll9lbXNjcmlwdGVuX3N0YWNrX3NldF9saW1pdHM9ZnVuY3Rpb24oKXtyZXR1cm4oVGU9dS5fZW1zY3JpcHRlbl9zdGFja19zZXRfbGltaXRzPXUuYXNtLkNiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LEVlPXUuc3RhY2tTYXZlPWZ1bmN0aW9uKCl7cmV0dXJuKEVlPXUuc3RhY2tTYXZlPXUuYXNtLkRiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LE1lPXUuc3RhY2tSZXN0b3JlPWZ1bmN0aW9uKCl7cmV0dXJuKE1lPXUuc3RhY2tSZXN0b3JlPXUuYXNtLkViKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LENlPXUuc3RhY2tBbGxvYz1mdW5jdGlvbigpe3JldHVybihDZT11LnN0YWNrQWxsb2M9dS5hc20uRmIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0seGU9dS5fX19jeGFfY2FuX2NhdGNoPWZ1bmN0aW9uKCl7cmV0dXJuKHhlPXUuX19fY3hhX2Nhbl9jYXRjaD11LmFzbS5HYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxSZT11Ll9fX2N4YV9pc19wb2ludGVyX3R5cGU9ZnVuY3Rpb24oKXtyZXR1cm4oUmU9dS5fX19jeGFfaXNfcG9pbnRlcl90eXBlPXUuYXNtLkhiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGplPXUuZHluQ2FsbF9qPWZ1bmN0aW9uKCl7cmV0dXJuKGplPXUuZHluQ2FsbF9qPXUuYXNtLkliKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGtlPXUuZHluQ2FsbF9paWlpaWo9ZnVuY3Rpb24oKXtyZXR1cm4oa2U9dS5keW5DYWxsX2lpaWlpaj11LmFzbS5KYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxEZT11LmR5bkNhbGxfamlpPWZ1bmN0aW9uKCl7cmV0dXJuKERlPXUuZHluQ2FsbF9qaWk9dS5hc20uS2IpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sUGU9dS5keW5DYWxsX3ZpaWlpaWo9ZnVuY3Rpb24oKXtyZXR1cm4oUGU9dS5keW5DYWxsX3ZpaWlpaWo9dS5hc20uTGIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sVWU9dS5keW5DYWxsX3Zqamk9ZnVuY3Rpb24oKXtyZXR1cm4oVWU9dS5keW5DYWxsX3Zqamk9dS5hc20uTWIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sRmU9dS5keW5DYWxsX3ZpaWlqamppaT1mdW5jdGlvbigpe3JldHVybihGZT11LmR5bkNhbGxfdmlpaWpqamlpPXUuYXNtLk5iKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LEllPXUuZHluQ2FsbF9paWo9ZnVuY3Rpb24oKXtyZXR1cm4oSWU9dS5keW5DYWxsX2lpaj11LmFzbS5PYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxXZT11LmR5bkNhbGxfamk9ZnVuY3Rpb24oKXtyZXR1cm4oV2U9dS5keW5DYWxsX2ppPXUuYXNtLlBiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LEhlPXUuZHluQ2FsbF9paWlpaWlqPWZ1bmN0aW9uKCl7cmV0dXJuKEhlPXUuZHluQ2FsbF9paWlpaWlqPXUuYXNtLlFiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LExlPXUuZHluQ2FsbF9paWlqPWZ1bmN0aW9uKCl7cmV0dXJuKExlPXUuZHluQ2FsbF9paWlqPXUuYXNtLlJiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O2Z1bmN0aW9uIHplKCl7ZnVuY3Rpb24gdCgpe2lmKCF2ZSYmKHZlPSEwLHUuY2FsbGVkUnVuPSEwLCFIKSYmKE98fGR0KFgpLGModSksdS5vblJ1bnRpbWVJbml0aWFsaXplZCYmdS5vblJ1bnRpbWVJbml0aWFsaXplZCgpLCFPKSl7aWYodS5wb3N0UnVuKWZvcihcImZ1bmN0aW9uXCI9PXR5cGVvZiB1LnBvc3RSdW4mJih1LnBvc3RSdW49W3UucG9zdFJ1bl0pO3UucG9zdFJ1bi5sZW5ndGg7KXt2YXIgdD11LnBvc3RSdW4uc2hpZnQoKTtaLnVuc2hpZnQodCl9ZHQoWil9fWlmKCEoMDxldCkpaWYoTyljKHUpLE98fGR0KFgpLHBvc3RNZXNzYWdlKHtjbWQ6XCJsb2FkZWRcIn0pO2Vsc2V7aWYodS5wcmVSdW4pZm9yKFwiZnVuY3Rpb25cIj09dHlwZW9mIHUucHJlUnVuJiYodS5wcmVSdW49W3UucHJlUnVuXSk7dS5wcmVSdW4ubGVuZ3RoOylLKCk7ZHQocSksMDxldHx8KHUuc2V0U3RhdHVzPyh1LnNldFN0YXR1cyhcIlJ1bm5pbmcuLi5cIiksc2V0VGltZW91dCgoZnVuY3Rpb24oKXtzZXRUaW1lb3V0KChmdW5jdGlvbigpe3Uuc2V0U3RhdHVzKFwiXCIpfSksMSksdCgpfSksMSkpOnQoKSl9fWlmKHUuVVRGOFRvU3RyaW5nPVksdS5zdHJpbmdUb1VURjg9ZnVuY3Rpb24odCxlLG4pe3JldHVybiBCKHQscigpLGUsbil9LHUubGVuZ3RoQnl0ZXNVVEY4PUcsdS5rZWVwUnVudGltZUFsaXZlPVEsdS53YXNtTWVtb3J5PWosdS5zdGFja1NhdmU9RWUsdS5zdGFja1Jlc3RvcmU9TWUsdS5zdGFja0FsbG9jPUNlLHUuRXhpdFN0YXR1cz1jdCx1LlBUaHJlYWQ9aHQscnQ9ZnVuY3Rpb24gdCgpe3ZlfHx6ZSgpLHZlfHwocnQ9dCl9LHUucHJlSW5pdClmb3IoXCJmdW5jdGlvblwiPT10eXBlb2YgdS5wcmVJbml0JiYodS5wcmVJbml0PVt1LnByZUluaXRdKTswPHUucHJlSW5pdC5sZW5ndGg7KXUucHJlSW5pdC5wb3AoKSgpO3JldHVybiB6ZSgpLHQucmVhZHl9KTt0LmV4cG9ydHM9cn0sOTMyOih0LGUsbik9Pnt2YXIgX3NjcmlwdERpcixyPShfc2NyaXB0RGlyPShfc2NyaXB0RGlyPVwidW5kZWZpbmVkXCIhPXR5cGVvZiBkb2N1bWVudCYmZG9jdW1lbnQuY3VycmVudFNjcmlwdD9kb2N1bWVudC5jdXJyZW50U2NyaXB0LnNyYzp2b2lkIDApfHxcIi9pbmRleC5qc1wiLGZ1bmN0aW9uKHQpe3ZhciBlLHIsYTt0PXR8fHt9LGV8fChlPXZvaWQgMCE9PXQ/dDp7fSksZS5yZWFkeT1uZXcgUHJvbWlzZSgoZnVuY3Rpb24odCxlKXtyPXQsYT1lfSkpO3ZhciBpLG8sdSxjLHMsbCxmPU9iamVjdC5hc3NpZ24oe30sZSkscD1cIi4vdGhpcy5wcm9ncmFtXCIsaD0odCxlKT0+e3Rocm93IGV9LGQ9XCJvYmplY3RcIj09dHlwZW9mIHdpbmRvdyx5PVwiZnVuY3Rpb25cIj09dHlwZW9mIGltcG9ydFNjcmlwdHMsYj1cIm9iamVjdFwiPT10eXBlb2YgcHJvY2VzcyYmXCJvYmplY3RcIj09dHlwZW9mIHByb2Nlc3MudmVyc2lvbnMmJlwic3RyaW5nXCI9PXR5cGVvZiBwcm9jZXNzLnZlcnNpb25zLm5vZGUsbT1cIlwiO2I/KG09eT9uKDkwOCkuZGlybmFtZShtKStcIi9cIjpcIi8vXCIsbD0oKT0+e3N8fChjPW4oMzg0KSxzPW4oOTA4KSl9LGk9ZnVuY3Rpb24odCxlKXtyZXR1cm4gbCgpLHQ9cy5ub3JtYWxpemUodCksYy5yZWFkRmlsZVN5bmModCxlP3ZvaWQgMDpcInV0ZjhcIil9LHU9dD0+KCh0PWkodCwhMCkpLmJ1ZmZlcnx8KHQ9bmV3IFVpbnQ4QXJyYXkodCkpLHQpLG89KHQsZSxuKT0+e2woKSx0PXMubm9ybWFsaXplKHQpLGMucmVhZEZpbGUodCwoZnVuY3Rpb24odCxyKXt0P24odCk6ZShyLmJ1ZmZlcil9KSl9LDE8cHJvY2Vzcy5hcmd2Lmxlbmd0aCYmKHA9cHJvY2Vzcy5hcmd2WzFdLnJlcGxhY2UoL1xcXFxcXFxcL2csXCIvXCIpKSxwcm9jZXNzLmFyZ3Yuc2xpY2UoMikscHJvY2Vzcy5vbihcInVuY2F1Z2h0RXhjZXB0aW9uXCIsKGZ1bmN0aW9uKHQpe2lmKCEodCBpbnN0YW5jZW9mIEopKXRocm93IHR9KSkscHJvY2Vzcy5vbihcInVuaGFuZGxlZFJlamVjdGlvblwiLChmdW5jdGlvbih0KXt0aHJvdyB0fSkpLGg9KHQsZSk9PntpZihffHwwPEwpdGhyb3cgcHJvY2Vzcy5leGl0Q29kZT10LGU7ZSBpbnN0YW5jZW9mIEp8fHcoXCJleGl0aW5nIGR1ZSB0byBleGNlcHRpb246IFwiK2UpLHByb2Nlc3MuZXhpdCh0KX0sZS5pbnNwZWN0PWZ1bmN0aW9uKCl7cmV0dXJuXCJbRW1zY3JpcHRlbiBNb2R1bGUgb2JqZWN0XVwifSk6KGR8fHkpJiYoeT9tPXNlbGYubG9jYXRpb24uaHJlZjpcInVuZGVmaW5lZFwiIT10eXBlb2YgZG9jdW1lbnQmJmRvY3VtZW50LmN1cnJlbnRTY3JpcHQmJihtPWRvY3VtZW50LmN1cnJlbnRTY3JpcHQuc3JjKSxfc2NyaXB0RGlyJiYobT1fc2NyaXB0RGlyKSxtPTAhPT1tLmluZGV4T2YoXCJibG9iOlwiKT9tLnN1YnN0cigwLG0ucmVwbGFjZSgvWz8jXS4qLyxcIlwiKS5sYXN0SW5kZXhPZihcIi9cIikrMSk6XCJcIixpPXQ9Pnt2YXIgZT1uZXcgWE1MSHR0cFJlcXVlc3Q7cmV0dXJuIGUub3BlbihcIkdFVFwiLHQsITEpLGUuc2VuZChudWxsKSxlLnJlc3BvbnNlVGV4dH0seSYmKHU9dD0+e3ZhciBlPW5ldyBYTUxIdHRwUmVxdWVzdDtyZXR1cm4gZS5vcGVuKFwiR0VUXCIsdCwhMSksZS5yZXNwb25zZVR5cGU9XCJhcnJheWJ1ZmZlclwiLGUuc2VuZChudWxsKSxuZXcgVWludDhBcnJheShlLnJlc3BvbnNlKX0pLG89KHQsZSxuKT0+e3ZhciByPW5ldyBYTUxIdHRwUmVxdWVzdDtyLm9wZW4oXCJHRVRcIix0LCEwKSxyLnJlc3BvbnNlVHlwZT1cImFycmF5YnVmZmVyXCIsci5vbmxvYWQ9KCk9PnsyMDA9PXIuc3RhdHVzfHwwPT1yLnN0YXR1cyYmci5yZXNwb25zZT9lKHIucmVzcG9uc2UpOm4oKX0sci5vbmVycm9yPW4sci5zZW5kKG51bGwpfSk7dmFyIGcsdj1lLnByaW50fHxjb25zb2xlLmxvZy5iaW5kKGNvbnNvbGUpLHc9ZS5wcmludEVycnx8Y29uc29sZS53YXJuLmJpbmQoY29uc29sZSk7T2JqZWN0LmFzc2lnbihlLGYpLGY9bnVsbCxlLnRoaXNQcm9ncmFtJiYocD1lLnRoaXNQcm9ncmFtKSxlLnF1aXQmJihoPWUucXVpdCksZS53YXNtQmluYXJ5JiYoZz1lLndhc21CaW5hcnkpO3ZhciBfPWUubm9FeGl0UnVudGltZXx8ITE7XCJvYmplY3RcIiE9dHlwZW9mIFdlYkFzc2VtYmx5JiZWKFwibm8gbmF0aXZlIHdhc20gc3VwcG9ydCBkZXRlY3RlZFwiKTt2YXIgTyxBLFMsVCxFLE0sQz0hMSx4PVwidW5kZWZpbmVkXCIhPXR5cGVvZiBUZXh0RGVjb2Rlcj9uZXcgVGV4dERlY29kZXIoXCJ1dGY4XCIpOnZvaWQgMDtmdW5jdGlvbiBSKHQsZSxuKXt2YXIgcj0oZT4+Pj0wKStuO2ZvcihuPWU7dFtuXSYmIShuPj1yKTspKytuO2lmKDE2PG4tZSYmdC5idWZmZXImJngpcmV0dXJuIHguZGVjb2RlKHQuc3ViYXJyYXkoZSxuKSk7Zm9yKHI9XCJcIjtlPG47KXt2YXIgYT10W2UrK107aWYoMTI4JmEpe3ZhciBpPTYzJnRbZSsrXTtpZigxOTI9PSgyMjQmYSkpcis9U3RyaW5nLmZyb21DaGFyQ29kZSgoMzEmYSk8PDZ8aSk7ZWxzZXt2YXIgbz02MyZ0W2UrK107NjU1MzY+KGE9MjI0PT0oMjQwJmEpPygxNSZhKTw8MTJ8aTw8NnxvOig3JmEpPDwxOHxpPDwxMnxvPDw2fDYzJnRbZSsrXSk/cis9U3RyaW5nLmZyb21DaGFyQ29kZShhKTooYS09NjU1MzYscis9U3RyaW5nLmZyb21DaGFyQ29kZSg1NTI5NnxhPj4xMCw1NjMyMHwxMDIzJmEpKX19ZWxzZSByKz1TdHJpbmcuZnJvbUNoYXJDb2RlKGEpfXJldHVybiByfWZ1bmN0aW9uIGoodCxlKXtyZXR1cm4odD4+Pj0wKT9SKFQsdCxlKTpcIlwifWZ1bmN0aW9uIGsodCxlLG4scil7aWYoISgwPHIpKXJldHVybiAwO3ZhciBhPW4+Pj49MDtyPW4rci0xO2Zvcih2YXIgaT0wO2k8dC5sZW5ndGg7KytpKXt2YXIgbz10LmNoYXJDb2RlQXQoaSk7aWYoNTUyOTY8PW8mJjU3MzQzPj1vJiYobz02NTUzNisoKDEwMjMmbyk8PDEwKXwxMDIzJnQuY2hhckNvZGVBdCgrK2kpKSwxMjc+PW8pe2lmKG4+PXIpYnJlYWs7ZVtuKys+Pj4wXT1vfWVsc2V7aWYoMjA0Nz49byl7aWYobisxPj1yKWJyZWFrO2VbbisrPj4+MF09MTkyfG8+PjZ9ZWxzZXtpZig2NTUzNT49byl7aWYobisyPj1yKWJyZWFrO2VbbisrPj4+MF09MjI0fG8+PjEyfWVsc2V7aWYobiszPj1yKWJyZWFrO2VbbisrPj4+MF09MjQwfG8+PjE4LGVbbisrPj4+MF09MTI4fG8+PjEyJjYzfWVbbisrPj4+MF09MTI4fG8+PjYmNjN9ZVtuKys+Pj4wXT0xMjh8NjMmb319cmV0dXJuIGVbbj4+PjBdPTAsbi1hfWZ1bmN0aW9uIEQodCl7Zm9yKHZhciBlPTAsbj0wO248dC5sZW5ndGg7KytuKXt2YXIgcj10LmNoYXJDb2RlQXQobik7MTI3Pj1yP2UrKzoyMDQ3Pj1yP2UrPTI6NTUyOTY8PXImJjU3MzQzPj1yPyhlKz00LCsrbik6ZSs9M31yZXR1cm4gZX1mdW5jdGlvbiBQKCl7dmFyIHQ9Ty5idWZmZXI7QT10LGUuSEVBUDg9Uz1uZXcgSW50OEFycmF5KHQpLGUuSEVBUDE2PW5ldyBJbnQxNkFycmF5KHQpLGUuSEVBUDMyPUU9bmV3IEludDMyQXJyYXkodCksZS5IRUFQVTg9VD1uZXcgVWludDhBcnJheSh0KSxlLkhFQVBVMTY9bmV3IFVpbnQxNkFycmF5KHQpLGUuSEVBUFUzMj1NPW5ldyBVaW50MzJBcnJheSh0KSxlLkhFQVBGMzI9bmV3IEZsb2F0MzJBcnJheSh0KSxlLkhFQVBGNjQ9bmV3IEZsb2F0NjRBcnJheSh0KX12YXIgVSxGPVtdLEk9W10sVz1bXSxIPVtdLEw9MDtmdW5jdGlvbiB6KCl7dmFyIHQ9ZS5wcmVSdW4uc2hpZnQoKTtGLnVuc2hpZnQodCl9dmFyIFksQj0wLEc9bnVsbCxOPW51bGw7ZnVuY3Rpb24gVih0KXt0aHJvdyBlLm9uQWJvcnQmJmUub25BYm9ydCh0KSx3KHQ9XCJBYm9ydGVkKFwiK3QrXCIpXCIpLEM9ITAsdD1uZXcgV2ViQXNzZW1ibHkuUnVudGltZUVycm9yKHQrXCIuIEJ1aWxkIHdpdGggLXNBU1NFUlRJT05TIGZvciBtb3JlIGluZm8uXCIpLGEodCksdH1mdW5jdGlvbiAkKCl7cmV0dXJuIFkuc3RhcnRzV2l0aChcImRhdGE6YXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtO2Jhc2U2NCxcIil9aWYoWT1cIm9ydC13YXNtLndhc21cIiwhJCgpKXt2YXIgcT1ZO1k9ZS5sb2NhdGVGaWxlP2UubG9jYXRlRmlsZShxLG0pOm0rcX1mdW5jdGlvbiBYKCl7dmFyIHQ9WTt0cnl7aWYodD09WSYmZylyZXR1cm4gbmV3IFVpbnQ4QXJyYXkoZyk7aWYodSlyZXR1cm4gdSh0KTt0aHJvd1wiYm90aCBhc3luYyBhbmQgc3luYyBmZXRjaGluZyBvZiB0aGUgd2FzbSBmYWlsZWRcIn1jYXRjaCh0KXtWKHQpfX1mdW5jdGlvbiBKKHQpe3RoaXMubmFtZT1cIkV4aXRTdGF0dXNcIix0aGlzLm1lc3NhZ2U9XCJQcm9ncmFtIHRlcm1pbmF0ZWQgd2l0aCBleGl0KFwiK3QrXCIpXCIsdGhpcy5zdGF0dXM9dH1mdW5jdGlvbiBaKHQpe2Zvcig7MDx0Lmxlbmd0aDspdC5zaGlmdCgpKGUpfXZhciBRPVtdLEs9MCx0dD0wO2Z1bmN0aW9uIGV0KHQpe3RoaXMuRGI9dCx0aGlzLnpiPXQtMjQsdGhpcy5VYj1mdW5jdGlvbih0KXtNW3RoaXMuemIrND4+Mj4+PjBdPXR9LHRoaXMuRWI9ZnVuY3Rpb24oKXtyZXR1cm4gTVt0aGlzLnpiKzQ+PjI+Pj4wXX0sdGhpcy5TYj1mdW5jdGlvbih0KXtNW3RoaXMuemIrOD4+Mj4+PjBdPXR9LHRoaXMuV2I9ZnVuY3Rpb24oKXtyZXR1cm4gTVt0aGlzLnpiKzg+PjI+Pj4wXX0sdGhpcy5UYj1mdW5jdGlvbigpe0VbdGhpcy56Yj4+Mj4+PjBdPTB9LHRoaXMuSWI9ZnVuY3Rpb24odCl7U1t0aGlzLnpiKzEyPj4wPj4+MF09dD8xOjB9LHRoaXMuUGI9ZnVuY3Rpb24oKXtyZXR1cm4gMCE9U1t0aGlzLnpiKzEyPj4wPj4+MF19LHRoaXMuSmI9ZnVuY3Rpb24odCl7U1t0aGlzLnpiKzEzPj4wPj4+MF09dD8xOjB9LHRoaXMuTGI9ZnVuY3Rpb24oKXtyZXR1cm4gMCE9U1t0aGlzLnpiKzEzPj4wPj4+MF19LHRoaXMuUmI9ZnVuY3Rpb24odCxlKXt0aGlzLkZiKDApLHRoaXMuVWIodCksdGhpcy5TYihlKSx0aGlzLlRiKCksdGhpcy5JYighMSksdGhpcy5KYighMSl9LHRoaXMuTmI9ZnVuY3Rpb24oKXtFW3RoaXMuemI+PjI+Pj4wXSs9MX0sdGhpcy5YYj1mdW5jdGlvbigpe3ZhciB0PUVbdGhpcy56Yj4+Mj4+PjBdO3JldHVybiBFW3RoaXMuemI+PjI+Pj4wXT10LTEsMT09PXR9LHRoaXMuRmI9ZnVuY3Rpb24odCl7TVt0aGlzLnpiKzE2Pj4yPj4+MF09dH0sdGhpcy5PYj1mdW5jdGlvbigpe3JldHVybiBNW3RoaXMuemIrMTY+PjI+Pj4wXX0sdGhpcy5RYj1mdW5jdGlvbigpe2lmKE10KHRoaXMuRWIoKSkpcmV0dXJuIE1bdGhpcy5EYj4+Mj4+PjBdO3ZhciB0PXRoaXMuT2IoKTtyZXR1cm4gMCE9PXQ/dDp0aGlzLkRifX1mdW5jdGlvbiBudCh0KXtyZXR1cm4gdnQobmV3IGV0KHQpLnpiKX12YXIgcnQ9W107ZnVuY3Rpb24gYXQodCl7dmFyIGU9cnRbdF07cmV0dXJuIGV8fCh0Pj1ydC5sZW5ndGgmJihydC5sZW5ndGg9dCsxKSxydFt0XT1lPVUuZ2V0KHQpKSxlfWZ1bmN0aW9uIGl0KHQpe3ZhciBlPUQodCkrMSxuPWd0KGUpO3JldHVybiBuJiZrKHQsUyxuLGUpLG59dmFyIG90PXt9O2Z1bmN0aW9uIHV0KCl7aWYoIWN0KXt2YXIgdCxlPXtVU0VSOlwid2ViX3VzZXJcIixMT0dOQU1FOlwid2ViX3VzZXJcIixQQVRIOlwiL1wiLFBXRDpcIi9cIixIT01FOlwiL2hvbWUvd2ViX3VzZXJcIixMQU5HOihcIm9iamVjdFwiPT10eXBlb2YgbmF2aWdhdG9yJiZuYXZpZ2F0b3IubGFuZ3VhZ2VzJiZuYXZpZ2F0b3IubGFuZ3VhZ2VzWzBdfHxcIkNcIikucmVwbGFjZShcIi1cIixcIl9cIikrXCIuVVRGLThcIixfOnB8fFwiLi90aGlzLnByb2dyYW1cIn07Zm9yKHQgaW4gb3Qpdm9pZCAwPT09b3RbdF0/ZGVsZXRlIGVbdF06ZVt0XT1vdFt0XTt2YXIgbj1bXTtmb3IodCBpbiBlKW4ucHVzaCh0K1wiPVwiK2VbdF0pO2N0PW59cmV0dXJuIGN0fXZhciBjdCxzdD1bbnVsbCxbXSxbXV07ZnVuY3Rpb24gbHQodCxlKXt2YXIgbj1zdFt0XTswPT09ZXx8MTA9PT1lPygoMT09PXQ/djp3KShSKG4sMCkpLG4ubGVuZ3RoPTApOm4ucHVzaChlKX12YXIgZnQ9MDtmdW5jdGlvbiBwdCh0KXtyZXR1cm4gMD09dCU0JiYoMCE9dCUxMDB8fDA9PXQlNDAwKX12YXIgaHQ9WzMxLDI5LDMxLDMwLDMxLDMwLDMxLDMxLDMwLDMxLDMwLDMxXSxkdD1bMzEsMjgsMzEsMzAsMzEsMzAsMzEsMzEsMzAsMzEsMzAsMzFdO2Z1bmN0aW9uIHl0KHQsZSxuLHIpe2Z1bmN0aW9uIGEodCxlLG4pe2Zvcih0PVwibnVtYmVyXCI9PXR5cGVvZiB0P3QudG9TdHJpbmcoKTp0fHxcIlwiO3QubGVuZ3RoPGU7KXQ9blswXSt0O3JldHVybiB0fWZ1bmN0aW9uIGkodCxlKXtyZXR1cm4gYSh0LGUsXCIwXCIpfWZ1bmN0aW9uIG8odCxlKXtmdW5jdGlvbiBuKHQpe3JldHVybiAwPnQ/LTE6MDx0PzE6MH12YXIgcjtyZXR1cm4gMD09PShyPW4odC5nZXRGdWxsWWVhcigpLWUuZ2V0RnVsbFllYXIoKSkpJiYwPT09KHI9bih0LmdldE1vbnRoKCktZS5nZXRNb250aCgpKSkmJihyPW4odC5nZXREYXRlKCktZS5nZXREYXRlKCkpKSxyfWZ1bmN0aW9uIHUodCl7c3dpdGNoKHQuZ2V0RGF5KCkpe2Nhc2UgMDpyZXR1cm4gbmV3IERhdGUodC5nZXRGdWxsWWVhcigpLTEsMTEsMjkpO2Nhc2UgMTpyZXR1cm4gdDtjYXNlIDI6cmV0dXJuIG5ldyBEYXRlKHQuZ2V0RnVsbFllYXIoKSwwLDMpO2Nhc2UgMzpyZXR1cm4gbmV3IERhdGUodC5nZXRGdWxsWWVhcigpLDAsMik7Y2FzZSA0OnJldHVybiBuZXcgRGF0ZSh0LmdldEZ1bGxZZWFyKCksMCwxKTtjYXNlIDU6cmV0dXJuIG5ldyBEYXRlKHQuZ2V0RnVsbFllYXIoKS0xLDExLDMxKTtjYXNlIDY6cmV0dXJuIG5ldyBEYXRlKHQuZ2V0RnVsbFllYXIoKS0xLDExLDMwKX19ZnVuY3Rpb24gYyh0KXt2YXIgZT10LkJiO2Zvcih0PW5ldyBEYXRlKG5ldyBEYXRlKHQuQ2IrMTkwMCwwLDEpLmdldFRpbWUoKSk7MDxlOyl7dmFyIG49dC5nZXRNb250aCgpLHI9KHB0KHQuZ2V0RnVsbFllYXIoKSk/aHQ6ZHQpW25dO2lmKCEoZT5yLXQuZ2V0RGF0ZSgpKSl7dC5zZXREYXRlKHQuZ2V0RGF0ZSgpK2UpO2JyZWFrfWUtPXItdC5nZXREYXRlKCkrMSx0LnNldERhdGUoMSksMTE+bj90LnNldE1vbnRoKG4rMSk6KHQuc2V0TW9udGgoMCksdC5zZXRGdWxsWWVhcih0LmdldEZ1bGxZZWFyKCkrMSkpfXJldHVybiBuPW5ldyBEYXRlKHQuZ2V0RnVsbFllYXIoKSsxLDAsNCksZT11KG5ldyBEYXRlKHQuZ2V0RnVsbFllYXIoKSwwLDQpKSxuPXUobiksMD49byhlLHQpPzA+PW8obix0KT90LmdldEZ1bGxZZWFyKCkrMTp0LmdldEZ1bGxZZWFyKCk6dC5nZXRGdWxsWWVhcigpLTF9dmFyIHM9RVtyKzQwPj4yPj4+MF07Zm9yKHZhciBsIGluIHI9eyRiOkVbcj4+Mj4+PjBdLFpiOkVbcis0Pj4yPj4+MF0sR2I6RVtyKzg+PjI+Pj4wXSxLYjpFW3IrMTI+PjI+Pj4wXSxIYjpFW3IrMTY+PjI+Pj4wXSxDYjpFW3IrMjA+PjI+Pj4wXSxBYjpFW3IrMjQ+PjI+Pj4wXSxCYjpFW3IrMjg+PjI+Pj4wXSxiYzpFW3IrMzI+PjI+Pj4wXSxZYjpFW3IrMzY+PjI+Pj4wXSxhYzpzP2oocyk6XCJcIn0sbj1qKG4pLHM9e1wiJWNcIjpcIiVhICViICVkICVIOiVNOiVTICVZXCIsXCIlRFwiOlwiJW0vJWQvJXlcIixcIiVGXCI6XCIlWS0lbS0lZFwiLFwiJWhcIjpcIiViXCIsXCIlclwiOlwiJUk6JU06JVMgJXBcIixcIiVSXCI6XCIlSDolTVwiLFwiJVRcIjpcIiVIOiVNOiVTXCIsXCIleFwiOlwiJW0vJWQvJXlcIixcIiVYXCI6XCIlSDolTTolU1wiLFwiJUVjXCI6XCIlY1wiLFwiJUVDXCI6XCIlQ1wiLFwiJUV4XCI6XCIlbS8lZC8leVwiLFwiJUVYXCI6XCIlSDolTTolU1wiLFwiJUV5XCI6XCIleVwiLFwiJUVZXCI6XCIlWVwiLFwiJU9kXCI6XCIlZFwiLFwiJU9lXCI6XCIlZVwiLFwiJU9IXCI6XCIlSFwiLFwiJU9JXCI6XCIlSVwiLFwiJU9tXCI6XCIlbVwiLFwiJU9NXCI6XCIlTVwiLFwiJU9TXCI6XCIlU1wiLFwiJU91XCI6XCIldVwiLFwiJU9VXCI6XCIlVVwiLFwiJU9WXCI6XCIlVlwiLFwiJU93XCI6XCIld1wiLFwiJU9XXCI6XCIlV1wiLFwiJU95XCI6XCIleVwifSluPW4ucmVwbGFjZShuZXcgUmVnRXhwKGwsXCJnXCIpLHNbbF0pO3ZhciBmPVwiU3VuZGF5IE1vbmRheSBUdWVzZGF5IFdlZG5lc2RheSBUaHVyc2RheSBGcmlkYXkgU2F0dXJkYXlcIi5zcGxpdChcIiBcIikscD1cIkphbnVhcnkgRmVicnVhcnkgTWFyY2ggQXByaWwgTWF5IEp1bmUgSnVseSBBdWd1c3QgU2VwdGVtYmVyIE9jdG9iZXIgTm92ZW1iZXIgRGVjZW1iZXJcIi5zcGxpdChcIiBcIik7Zm9yKGwgaW4gcz17XCIlYVwiOmZ1bmN0aW9uKHQpe3JldHVybiBmW3QuQWJdLnN1YnN0cmluZygwLDMpfSxcIiVBXCI6ZnVuY3Rpb24odCl7cmV0dXJuIGZbdC5BYl19LFwiJWJcIjpmdW5jdGlvbih0KXtyZXR1cm4gcFt0LkhiXS5zdWJzdHJpbmcoMCwzKX0sXCIlQlwiOmZ1bmN0aW9uKHQpe3JldHVybiBwW3QuSGJdfSxcIiVDXCI6ZnVuY3Rpb24odCl7cmV0dXJuIGkoKHQuQ2IrMTkwMCkvMTAwfDAsMil9LFwiJWRcIjpmdW5jdGlvbih0KXtyZXR1cm4gaSh0LktiLDIpfSxcIiVlXCI6ZnVuY3Rpb24odCl7cmV0dXJuIGEodC5LYiwyLFwiIFwiKX0sXCIlZ1wiOmZ1bmN0aW9uKHQpe3JldHVybiBjKHQpLnRvU3RyaW5nKCkuc3Vic3RyaW5nKDIpfSxcIiVHXCI6ZnVuY3Rpb24odCl7cmV0dXJuIGModCl9LFwiJUhcIjpmdW5jdGlvbih0KXtyZXR1cm4gaSh0LkdiLDIpfSxcIiVJXCI6ZnVuY3Rpb24odCl7cmV0dXJuIDA9PSh0PXQuR2IpP3Q9MTI6MTI8dCYmKHQtPTEyKSxpKHQsMil9LFwiJWpcIjpmdW5jdGlvbih0KXtmb3IodmFyIGU9MCxuPTA7bjw9dC5IYi0xO2UrPShwdCh0LkNiKzE5MDApP2h0OmR0KVtuKytdKTtyZXR1cm4gaSh0LktiK2UsMyl9LFwiJW1cIjpmdW5jdGlvbih0KXtyZXR1cm4gaSh0LkhiKzEsMil9LFwiJU1cIjpmdW5jdGlvbih0KXtyZXR1cm4gaSh0LlpiLDIpfSxcIiVuXCI6ZnVuY3Rpb24oKXtyZXR1cm5cIlxcXFxuXCJ9LFwiJXBcIjpmdW5jdGlvbih0KXtyZXR1cm4gMDw9dC5HYiYmMTI+dC5HYj9cIkFNXCI6XCJQTVwifSxcIiVTXCI6ZnVuY3Rpb24odCl7cmV0dXJuIGkodC4kYiwyKX0sXCIldFwiOmZ1bmN0aW9uKCl7cmV0dXJuXCJcXFxcdFwifSxcIiV1XCI6ZnVuY3Rpb24odCl7cmV0dXJuIHQuQWJ8fDd9LFwiJVVcIjpmdW5jdGlvbih0KXtyZXR1cm4gaShNYXRoLmZsb29yKCh0LkJiKzctdC5BYikvNyksMil9LFwiJVZcIjpmdW5jdGlvbih0KXt2YXIgZT1NYXRoLmZsb29yKCh0LkJiKzctKHQuQWIrNiklNykvNyk7aWYoMj49KHQuQWIrMzcxLXQuQmItMiklNyYmZSsrLGUpNTM9PWUmJig0PT0obj0odC5BYiszNzEtdC5CYiklNyl8fDM9PW4mJnB0KHQuQ2IpfHwoZT0xKSk7ZWxzZXtlPTUyO3ZhciBuPSh0LkFiKzctdC5CYi0xKSU3Oyg0PT1ufHw1PT1uJiZwdCh0LkNiJTQwMC0xKSkmJmUrK31yZXR1cm4gaShlLDIpfSxcIiV3XCI6ZnVuY3Rpb24odCl7cmV0dXJuIHQuQWJ9LFwiJVdcIjpmdW5jdGlvbih0KXtyZXR1cm4gaShNYXRoLmZsb29yKCh0LkJiKzctKHQuQWIrNiklNykvNyksMil9LFwiJXlcIjpmdW5jdGlvbih0KXtyZXR1cm4odC5DYisxOTAwKS50b1N0cmluZygpLnN1YnN0cmluZygyKX0sXCIlWVwiOmZ1bmN0aW9uKHQpe3JldHVybiB0LkNiKzE5MDB9LFwiJXpcIjpmdW5jdGlvbih0KXt2YXIgZT0wPD0odD10LlliKTtyZXR1cm4gdD1NYXRoLmFicyh0KS82MCwoZT9cIitcIjpcIi1cIikrU3RyaW5nKFwiMDAwMFwiKyh0LzYwKjEwMCt0JTYwKSkuc2xpY2UoLTQpfSxcIiVaXCI6ZnVuY3Rpb24odCl7cmV0dXJuIHQuYWN9LFwiJSVcIjpmdW5jdGlvbigpe3JldHVyblwiJVwifX0sbj1uLnJlcGxhY2UoLyUlL2csXCJcXFxcMFxcXFwwXCIpLHMpbi5pbmNsdWRlcyhsKSYmKG49bi5yZXBsYWNlKG5ldyBSZWdFeHAobCxcImdcIiksc1tsXShyKSkpO3JldHVybiBsPWZ1bmN0aW9uKHQpe3ZhciBlPUFycmF5KEQodCkrMSk7cmV0dXJuIGsodCxlLDAsZS5sZW5ndGgpLGV9KG49bi5yZXBsYWNlKC9cXFxcMFxcXFwwL2csXCIlXCIpKSxsLmxlbmd0aD5lPzA6KFMuc2V0KGwsdD4+PjApLGwubGVuZ3RoLTEpfXZhciBidD17YTpmdW5jdGlvbih0KXtyZXR1cm4gZ3QodCsyNCkrMjR9LG06ZnVuY3Rpb24odCl7cmV0dXJuKHQ9bmV3IGV0KHQpKS5QYigpfHwodC5JYighMCksSy0tKSx0LkpiKCExKSxRLnB1c2godCksdC5OYigpLHQuUWIoKX0saWE6ZnVuY3Rpb24odCl7dGhyb3cgdyhcIlVuZXhwZWN0ZWQgZXhjZXB0aW9uIHRocm93biwgdGhpcyBpcyBub3QgcHJvcGVybHkgc3VwcG9ydGVkIC0gYWJvcnRpbmdcIiksQz0hMCx0fSx3OmZ1bmN0aW9uKCl7T3QoMCk7dmFyIHQ9US5wb3AoKTtpZih0LlhiKCkmJiF0LkxiKCkpe3ZhciBlPXQuV2IoKTtlJiZhdChlKSh0LkRiKSxudCh0LkRiKX10dD0wfSxkOmZ1bmN0aW9uKCl7dmFyIHQ9dHQ7aWYoIXQpcmV0dXJuIGZ0PTA7dmFyIGU9bmV3IGV0KHQpO2UuRmIodCk7dmFyIG49ZS5FYigpO2lmKCFuKXJldHVybiBmdD0wLHQ7Zm9yKHZhciByPUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyksYT0wO2E8ci5sZW5ndGg7YSsrKXt2YXIgaT1yW2FdO2lmKDA9PT1pfHxpPT09bilicmVhaztpZihFdChpLG4sZS56YisxNikpcmV0dXJuIGZ0PWksdH1yZXR1cm4gZnQ9bix0fSxrOmZ1bmN0aW9uKCl7dmFyIHQ9dHQ7aWYoIXQpcmV0dXJuIGZ0PTA7dmFyIGU9bmV3IGV0KHQpO2UuRmIodCk7dmFyIG49ZS5FYigpO2lmKCFuKXJldHVybiBmdD0wLHQ7Zm9yKHZhciByPUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyksYT0wO2E8ci5sZW5ndGg7YSsrKXt2YXIgaT1yW2FdO2lmKDA9PT1pfHxpPT09bilicmVhaztpZihFdChpLG4sZS56YisxNikpcmV0dXJuIGZ0PWksdH1yZXR1cm4gZnQ9bix0fSxnOmZ1bmN0aW9uKCl7dmFyIHQ9dHQ7aWYoIXQpcmV0dXJuIGZ0PTA7dmFyIGU9bmV3IGV0KHQpO2UuRmIodCk7dmFyIG49ZS5FYigpO2lmKCFuKXJldHVybiBmdD0wLHQ7Zm9yKHZhciByPUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyksYT0wO2E8ci5sZW5ndGg7YSsrKXt2YXIgaT1yW2FdO2lmKDA9PT1pfHxpPT09bilicmVhaztpZihFdChpLG4sZS56YisxNikpcmV0dXJuIGZ0PWksdH1yZXR1cm4gZnQ9bix0fSxzOm50LEw6ZnVuY3Rpb24oKXt2YXIgdD1RLnBvcCgpO3R8fFYoXCJubyBleGNlcHRpb24gdG8gdGhyb3dcIik7dmFyIGU9dC5EYjt0aHJvdyB0LkxiKCl8fChRLnB1c2godCksdC5KYighMCksdC5JYighMSksSysrKSx0dD1lLGV9LGI6ZnVuY3Rpb24odCxlLG4pe3Rocm93IG5ldyBldCh0KS5SYihlLG4pLHR0PXQsSysrLHR9LGxhOmZ1bmN0aW9uKCl7cmV0dXJuIEt9LGk6ZnVuY3Rpb24odCl7dGhyb3cgdHR8fCh0dD10KSx0fSxIOmZ1bmN0aW9uKCl7cmV0dXJuIDB9LEJhOmZ1bmN0aW9uKCl7fSxwYTpmdW5jdGlvbigpe30scmE6ZnVuY3Rpb24oKXt9LGthOmZ1bmN0aW9uKCl7cmV0dXJuIDB9LHphOmZ1bmN0aW9uKCl7fSx1YTpmdW5jdGlvbigpe30seWE6ZnVuY3Rpb24oKXt9LFI6ZnVuY3Rpb24oKXt9LHFhOmZ1bmN0aW9uKCl7fSxuYTpmdW5jdGlvbigpe30sQWE6ZnVuY3Rpb24oKXt9LG9hOmZ1bmN0aW9uKCl7fSxIYTpmdW5jdGlvbigpe30sSmE6ZnVuY3Rpb24oKXtWKFwiVG8gdXNlIGRsb3BlbiwgeW91IG5lZWQgZW5hYmxlIGR5bmFtaWMgbGlua2luZywgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9lbXNjcmlwdGVuLWNvcmUvZW1zY3JpcHRlbi93aWtpL0xpbmtpbmdcIil9LElhOmZ1bmN0aW9uKCl7VihcIlRvIHVzZSBkbG9wZW4sIHlvdSBuZWVkIGVuYWJsZSBkeW5hbWljIGxpbmtpbmcsIHNlZSBodHRwczovL2dpdGh1Yi5jb20vZW1zY3JpcHRlbi1jb3JlL2Vtc2NyaXB0ZW4vd2lraS9MaW5raW5nXCIpfSxTOmZ1bmN0aW9uKCl7cmV0dXJuIERhdGUubm93KCl9LENhOmZ1bmN0aW9uKCl7cmV0dXJuITB9LERhOmZ1bmN0aW9uKHQsZSl7dD1uZXcgRGF0ZSgxZTMqKE1bdD4+PjJdKzQyOTQ5NjcyOTYqRVt0KzQ+Pj4yXSkpLEVbZT4+Mj4+PjBdPXQuZ2V0VVRDU2Vjb25kcygpLEVbZSs0Pj4yPj4+MF09dC5nZXRVVENNaW51dGVzKCksRVtlKzg+PjI+Pj4wXT10LmdldFVUQ0hvdXJzKCksRVtlKzEyPj4yPj4+MF09dC5nZXRVVENEYXRlKCksRVtlKzE2Pj4yPj4+MF09dC5nZXRVVENNb250aCgpLEVbZSsyMD4+Mj4+PjBdPXQuZ2V0VVRDRnVsbFllYXIoKS0xOTAwLEVbZSsyND4+Mj4+PjBdPXQuZ2V0VVRDRGF5KCksRVtlKzI4Pj4yPj4+MF09KHQuZ2V0VGltZSgpLURhdGUuVVRDKHQuZ2V0VVRDRnVsbFllYXIoKSwwLDEsMCwwLDAsMCkpLzg2NGU1fDB9LEVhOmZ1bmN0aW9uKHQsZSl7dD1uZXcgRGF0ZSgxZTMqKE1bdD4+PjJdKzQyOTQ5NjcyOTYqRVt0KzQ+Pj4yXSkpLEVbZT4+Mj4+PjBdPXQuZ2V0U2Vjb25kcygpLEVbZSs0Pj4yPj4+MF09dC5nZXRNaW51dGVzKCksRVtlKzg+PjI+Pj4wXT10LmdldEhvdXJzKCksRVtlKzEyPj4yPj4+MF09dC5nZXREYXRlKCksRVtlKzE2Pj4yPj4+MF09dC5nZXRNb250aCgpLEVbZSsyMD4+Mj4+PjBdPXQuZ2V0RnVsbFllYXIoKS0xOTAwLEVbZSsyND4+Mj4+PjBdPXQuZ2V0RGF5KCk7dmFyIG49bmV3IERhdGUodC5nZXRGdWxsWWVhcigpLDAsMSk7RVtlKzI4Pj4yPj4+MF09KHQuZ2V0VGltZSgpLW4uZ2V0VGltZSgpKS84NjRlNXwwLEVbZSszNj4+Mj4+PjBdPS02MCp0LmdldFRpbWV6b25lT2Zmc2V0KCk7dmFyIHI9bmV3IERhdGUodC5nZXRGdWxsWWVhcigpLDYsMSkuZ2V0VGltZXpvbmVPZmZzZXQoKTtuPW4uZ2V0VGltZXpvbmVPZmZzZXQoKSxFW2UrMzI+PjI+Pj4wXT0wfChyIT1uJiZ0LmdldFRpbWV6b25lT2Zmc2V0KCk9PU1hdGgubWluKG4scikpfSxGYTpmdW5jdGlvbih0KXt2YXIgZT1uZXcgRGF0ZShFW3QrMjA+PjI+Pj4wXSsxOTAwLEVbdCsxNj4+Mj4+PjBdLEVbdCsxMj4+Mj4+PjBdLEVbdCs4Pj4yPj4+MF0sRVt0KzQ+PjI+Pj4wXSxFW3Q+PjI+Pj4wXSwwKSxuPUVbdCszMj4+Mj4+PjBdLHI9ZS5nZXRUaW1lem9uZU9mZnNldCgpLGE9bmV3IERhdGUoZS5nZXRGdWxsWWVhcigpLDAsMSksaT1uZXcgRGF0ZShlLmdldEZ1bGxZZWFyKCksNiwxKS5nZXRUaW1lem9uZU9mZnNldCgpLG89YS5nZXRUaW1lem9uZU9mZnNldCgpLHU9TWF0aC5taW4obyxpKTtyZXR1cm4gMD5uP0VbdCszMj4+Mj4+PjBdPU51bWJlcihpIT1vJiZ1PT1yKTowPG4hPSh1PT1yKSYmKGk9TWF0aC5tYXgobyxpKSxlLnNldFRpbWUoZS5nZXRUaW1lKCkrNmU0KigoMDxuP3U6aSktcikpKSxFW3QrMjQ+PjI+Pj4wXT1lLmdldERheSgpLEVbdCsyOD4+Mj4+PjBdPShlLmdldFRpbWUoKS1hLmdldFRpbWUoKSkvODY0ZTV8MCxFW3Q+PjI+Pj4wXT1lLmdldFNlY29uZHMoKSxFW3QrND4+Mj4+PjBdPWUuZ2V0TWludXRlcygpLEVbdCs4Pj4yPj4+MF09ZS5nZXRIb3VycygpLEVbdCsxMj4+Mj4+PjBdPWUuZ2V0RGF0ZSgpLEVbdCsxNj4+Mj4+PjBdPWUuZ2V0TW9udGgoKSxlLmdldFRpbWUoKS8xZTN8MH0sc2E6ZnVuY3Rpb24oKXtyZXR1cm4tNTJ9LHRhOmZ1bmN0aW9uKCl7fSxHYTpmdW5jdGlvbiB0KGUsbixyKXt0LlZifHwodC5WYj0hMCxmdW5jdGlvbih0LGUsbil7ZnVuY3Rpb24gcih0KXtyZXR1cm4odD10LnRvVGltZVN0cmluZygpLm1hdGNoKC9cXFxcKChbQS1aYS16IF0rKVxcXFwpJC8pKT90WzFdOlwiR01UXCJ9dmFyIGE9KG5ldyBEYXRlKS5nZXRGdWxsWWVhcigpLGk9bmV3IERhdGUoYSwwLDEpLG89bmV3IERhdGUoYSw2LDEpO2E9aS5nZXRUaW1lem9uZU9mZnNldCgpO3ZhciB1PW8uZ2V0VGltZXpvbmVPZmZzZXQoKTtFW3Q+PjI+Pj4wXT02MCpNYXRoLm1heChhLHUpLEVbZT4+Mj4+PjBdPU51bWJlcihhIT11KSx0PXIoaSksZT1yKG8pLHQ9aXQodCksZT1pdChlKSx1PGE/KE1bbj4+Mj4+PjBdPXQsTVtuKzQ+PjI+Pj4wXT1lKTooTVtuPj4yPj4+MF09ZSxNW24rND4+Mj4+PjBdPXQpfShlLG4scikpfSxCOmZ1bmN0aW9uKCl7VihcIlwiKX0sbWE6ZnVuY3Rpb24oKXtyZXR1cm4gNDI5NDkwMTc2MH0sSTpiPygpPT57dmFyIHQ9cHJvY2Vzcy5ocnRpbWUoKTtyZXR1cm4gMWUzKnRbMF0rdFsxXS8xZTZ9OigpPT5wZXJmb3JtYW5jZS5ub3coKSx4YTpmdW5jdGlvbih0LGUsbil7VC5jb3B5V2l0aGluKHQ+Pj4wLGU+Pj4wLGUrbj4+PjApfSxHOmZ1bmN0aW9uKHQpe3ZhciBlPVQubGVuZ3RoO2lmKDQyOTQ5MDE3NjA8KHQ+Pj49MCkpcmV0dXJuITE7Zm9yKHZhciBuPTE7ND49bjtuKj0yKXt2YXIgcj1lKigxKy4yL24pO3I9TWF0aC5taW4ocix0KzEwMDY2MzI5Nik7dmFyIGE9TWF0aDtyPU1hdGgubWF4KHQsciksYT1hLm1pbi5jYWxsKGEsNDI5NDkwMTc2MCxyKyg2NTUzNi1yJTY1NTM2KSU2NTUzNik7dDp7dHJ5e08uZ3JvdyhhLUEuYnl0ZUxlbmd0aCs2NTUzNT4+PjE2KSxQKCk7dmFyIGk9MTticmVhayB0fWNhdGNoKHQpe31pPXZvaWQgMH1pZihpKXJldHVybiEwfXJldHVybiExfSx2YTpmdW5jdGlvbih0LGUpe3ZhciBuPTA7cmV0dXJuIHV0KCkuZm9yRWFjaCgoZnVuY3Rpb24ocixhKXt2YXIgaT1lK247Zm9yKGE9TVt0KzQqYT4+Mj4+PjBdPWksaT0wO2k8ci5sZW5ndGg7KytpKVNbYSsrPj4wPj4+MF09ci5jaGFyQ29kZUF0KGkpO1NbYT4+MD4+PjBdPTAsbis9ci5sZW5ndGgrMX0pKSwwfSx3YTpmdW5jdGlvbih0LGUpe3ZhciBuPXV0KCk7TVt0Pj4yPj4+MF09bi5sZW5ndGg7dmFyIHI9MDtyZXR1cm4gbi5mb3JFYWNoKChmdW5jdGlvbih0KXtyKz10Lmxlbmd0aCsxfSkpLE1bZT4+Mj4+PjBdPXIsMH0sYmE6ZnVuY3Rpb24odCl7X3x8MDxMfHwoX3QoKSxaKFcpLHd0KDApLHN0WzFdLmxlbmd0aCYmbHQoMSwxMCksc3RbMl0ubGVuZ3RoJiZsdCgyLDEwKSksX3x8MDxMfHwoZS5vbkV4aXQmJmUub25FeGl0KHQpLEM9ITApLGgodCxuZXcgSih0KSl9LEU6ZnVuY3Rpb24oKXtyZXR1cm4gNTJ9LFE6ZnVuY3Rpb24oKXtyZXR1cm4gNTJ9LGNhOmZ1bmN0aW9uKCl7cmV0dXJuIDcwfSxQOmZ1bmN0aW9uKHQsZSxuLHIpe2Zvcih2YXIgYT0wLGk9MDtpPG47aSsrKXt2YXIgbz1NW2U+PjI+Pj4wXSx1PU1bZSs0Pj4yPj4+MF07ZSs9ODtmb3IodmFyIGM9MDtjPHU7YysrKWx0KHQsVFtvK2M+Pj4wXSk7YSs9dX1yZXR1cm4gTVtyPj4yPj4+MF09YSwwfSxjOmZ1bmN0aW9uKCl7cmV0dXJuIGZ0fSxqYTpmdW5jdGlvbiB0KGUscil7dC5NYnx8KHQuTWI9ZnVuY3Rpb24oKXtpZihcIm9iamVjdFwiPT10eXBlb2YgY3J5cHRvJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKXt2YXIgdD1uZXcgVWludDhBcnJheSgxKTtyZXR1cm4oKT0+KGNyeXB0by5nZXRSYW5kb21WYWx1ZXModCksdFswXSl9aWYoYil0cnl7dmFyIGU9bihPYmplY3QoZnVuY3Rpb24oKXt2YXIgdD1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgXFwnY3J5cHRvXFwnXCIpO3Rocm93IHQuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIix0fSgpKSk7cmV0dXJuKCk9PmUucmFuZG9tQnl0ZXMoMSlbMF19Y2F0Y2godCl7fXJldHVybigpPT5WKFwicmFuZG9tRGV2aWNlXCIpfSgpKTtmb3IodmFyIGE9MDthPHI7YSsrKVNbZSthPj4wPj4+MF09dC5NYigpO3JldHVybiAwfSxlYTpmdW5jdGlvbih0LGUsbil7dmFyIHI9QXQoKTt0cnl7cmV0dXJuIGF0KHQpKGUsbil9Y2F0Y2godCl7aWYoU3QociksdCE9PXQrMCl0aHJvdyB0O090KDEsMCl9fSxmYTpmdW5jdGlvbih0LGUsbil7dmFyIHI9QXQoKTt0cnl7cmV0dXJuIGF0KHQpKGUsbil9Y2F0Y2godCl7aWYoU3QociksdCE9PXQrMCl0aHJvdyB0O090KDEsMCl9fSxKOmZ1bmN0aW9uKHQpe3ZhciBlPUF0KCk7dHJ5e3JldHVybiBhdCh0KSgpfWNhdGNoKHQpe2lmKFN0KGUpLHQhPT10KzApdGhyb3cgdDtPdCgxLDApfX0sZTpmdW5jdGlvbih0LGUpe3ZhciBuPUF0KCk7dHJ5e3JldHVybiBhdCh0KShlKX1jYXRjaCh0KXtpZihTdChuKSx0IT09dCswKXRocm93IHQ7T3QoMSwwKX19LE46ZnVuY3Rpb24odCxlLG4pe3ZhciByPUF0KCk7dHJ5e3JldHVybiBhdCh0KShlLG4pfWNhdGNoKHQpe2lmKFN0KHIpLHQhPT10KzApdGhyb3cgdDtPdCgxLDApfX0sTzpmdW5jdGlvbih0LGUsbil7dmFyIHI9QXQoKTt0cnl7cmV0dXJuIGF0KHQpKGUsbil9Y2F0Y2godCl7aWYoU3QociksdCE9PXQrMCl0aHJvdyB0O090KDEsMCl9fSxqOmZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1BdCgpO3RyeXtyZXR1cm4gYXQodCkoZSxuKX1jYXRjaCh0KXtpZihTdChyKSx0IT09dCswKXRocm93IHQ7T3QoMSwwKX19LG86ZnVuY3Rpb24odCxlLG4scil7dmFyIGE9QXQoKTt0cnl7cmV0dXJuIGF0KHQpKGUsbixyKX1jYXRjaCh0KXtpZihTdChhKSx0IT09dCswKXRocm93IHQ7T3QoMSwwKX19LHA6ZnVuY3Rpb24odCxlLG4scixhKXt2YXIgaT1BdCgpO3RyeXtyZXR1cm4gYXQodCkoZSxuLHIsYSl9Y2F0Y2godCl7aWYoU3QoaSksdCE9PXQrMCl0aHJvdyB0O090KDEsMCl9fSxNOmZ1bmN0aW9uKHQsZSxuLHIsYSxpKXt2YXIgbz1BdCgpO3RyeXtyZXR1cm4gYXQodCkoZSxuLHIsYSxpKX1jYXRjaCh0KXtpZihTdChvKSx0IT09dCswKXRocm93IHQ7T3QoMSwwKX19LHI6ZnVuY3Rpb24odCxlLG4scixhLGkpe3ZhciBvPUF0KCk7dHJ5e3JldHVybiBhdCh0KShlLG4scixhLGkpfWNhdGNoKHQpe2lmKFN0KG8pLHQhPT10KzApdGhyb3cgdDtPdCgxLDApfX0sdjpmdW5jdGlvbih0LGUsbixyLGEsaSxvKXt2YXIgdT1BdCgpO3RyeXtyZXR1cm4gYXQodCkoZSxuLHIsYSxpLG8pfWNhdGNoKHQpe2lmKFN0KHUpLHQhPT10KzApdGhyb3cgdDtPdCgxLDApfX0sSzpmdW5jdGlvbih0LGUsbixyLGEsaSxvLHUpe3ZhciBjPUF0KCk7dHJ5e3JldHVybiBhdCh0KShlLG4scixhLGksbyx1KX1jYXRjaCh0KXtpZihTdChjKSx0IT09dCswKXRocm93IHQ7T3QoMSwwKX19LEQ6ZnVuY3Rpb24odCxlLG4scixhLGksbyx1LGMscyxsLGYpe3ZhciBwPUF0KCk7dHJ5e3JldHVybiBhdCh0KShlLG4scixhLGksbyx1LGMscyxsLGYpfWNhdGNoKHQpe2lmKFN0KHApLHQhPT10KzApdGhyb3cgdDtPdCgxLDApfX0sWDpmdW5jdGlvbih0LGUsbixyLGEsaSxvLHUpe3ZhciBjPUF0KCk7dHJ5e3JldHVybiBGdCh0LGUsbixyLGEsaSxvLHUpfWNhdGNoKHQpe2lmKFN0KGMpLHQhPT10KzApdGhyb3cgdDtPdCgxLDApfX0sVjpmdW5jdGlvbih0LGUsbixyLGEsaSxvKXt2YXIgdT1BdCgpO3RyeXtyZXR1cm4geHQodCxlLG4scixhLGksbyl9Y2F0Y2godCl7aWYoU3QodSksdCE9PXQrMCl0aHJvdyB0O090KDEsMCl9fSxVOmZ1bmN0aW9uKHQsZSxuLHIsYSl7dmFyIGk9QXQoKTt0cnl7cmV0dXJuIEl0KHQsZSxuLHIsYSl9Y2F0Y2godCl7aWYoU3QoaSksdCE9PXQrMCl0aHJvdyB0O090KDEsMCl9fSxaOmZ1bmN0aW9uKHQsZSxuLHIpe3ZhciBhPUF0KCk7dHJ5e3JldHVybiBQdCh0LGUsbixyKX1jYXRjaCh0KXtpZihTdChhKSx0IT09dCswKXRocm93IHQ7T3QoMSwwKX19LFc6ZnVuY3Rpb24odCl7dmFyIGU9QXQoKTt0cnl7cmV0dXJuIEN0KHQpfWNhdGNoKHQpe2lmKFN0KGUpLHQhPT10KzApdGhyb3cgdDtPdCgxLDApfX0sWTpmdW5jdGlvbih0LGUpe3ZhciBuPUF0KCk7dHJ5e3JldHVybiBVdCh0LGUpfWNhdGNoKHQpe2lmKFN0KG4pLHQhPT10KzApdGhyb3cgdDtPdCgxLDApfX0sVDpmdW5jdGlvbih0LGUsbil7dmFyIHI9QXQoKTt0cnl7cmV0dXJuIFJ0KHQsZSxuKX1jYXRjaCh0KXtpZihTdChyKSx0IT09dCswKXRocm93IHQ7T3QoMSwwKX19LGY6ZnVuY3Rpb24odCl7dmFyIGU9QXQoKTt0cnl7YXQodCkoKX1jYXRjaCh0KXtpZihTdChlKSx0IT09dCswKXRocm93IHQ7T3QoMSwwKX19LHE6ZnVuY3Rpb24odCxlKXt2YXIgbj1BdCgpO3RyeXthdCh0KShlKX1jYXRjaCh0KXtpZihTdChuKSx0IT09dCswKXRocm93IHQ7T3QoMSwwKX19LGg6ZnVuY3Rpb24odCxlLG4pe3ZhciByPUF0KCk7dHJ5e2F0KHQpKGUsbil9Y2F0Y2godCl7aWYoU3QociksdCE9PXQrMCl0aHJvdyB0O090KDEsMCl9fSxkYTpmdW5jdGlvbih0LGUsbixyKXt2YXIgYT1BdCgpO3RyeXthdCh0KShlLG4scil9Y2F0Y2godCl7aWYoU3QoYSksdCE9PXQrMCl0aHJvdyB0O090KDEsMCl9fSxsOmZ1bmN0aW9uKHQsZSxuLHIpe3ZhciBhPUF0KCk7dHJ5e2F0KHQpKGUsbixyKX1jYXRjaCh0KXtpZihTdChhKSx0IT09dCswKXRocm93IHQ7T3QoMSwwKX19LHQ6ZnVuY3Rpb24odCxlLG4scixhKXt2YXIgaT1BdCgpO3RyeXthdCh0KShlLG4scixhKX1jYXRjaCh0KXtpZihTdChpKSx0IT09dCswKXRocm93IHQ7T3QoMSwwKX19LHU6ZnVuY3Rpb24odCxlLG4scixhLGkpe3ZhciBvPUF0KCk7dHJ5e2F0KHQpKGUsbixyLGEsaSl9Y2F0Y2godCl7aWYoU3QobyksdCE9PXQrMCl0aHJvdyB0O090KDEsMCl9fSx4OmZ1bmN0aW9uKHQsZSxuLHIsYSxpLG8pe3ZhciB1PUF0KCk7dHJ5e2F0KHQpKGUsbixyLGEsaSxvKX1jYXRjaCh0KXtpZihTdCh1KSx0IT09dCswKXRocm93IHQ7T3QoMSwwKX19LHo6ZnVuY3Rpb24odCxlLG4scixhLGksbyx1KXt2YXIgYz1BdCgpO3RyeXthdCh0KShlLG4scixhLGksbyx1KX1jYXRjaCh0KXtpZihTdChjKSx0IT09dCswKXRocm93IHQ7T3QoMSwwKX19LGdhOmZ1bmN0aW9uKHQsZSxuLHIsYSxpLG8sdSxjKXt2YXIgcz1BdCgpO3RyeXthdCh0KShlLG4scixhLGksbyx1LGMpfWNhdGNoKHQpe2lmKFN0KHMpLHQhPT10KzApdGhyb3cgdDtPdCgxLDApfX0sQTpmdW5jdGlvbih0LGUsbixyLGEsaSxvLHUsYyxzLGwpe3ZhciBmPUF0KCk7dHJ5e2F0KHQpKGUsbixyLGEsaSxvLHUsYyxzLGwpfWNhdGNoKHQpe2lmKFN0KGYpLHQhPT10KzApdGhyb3cgdDtPdCgxLDApfX0sQzpmdW5jdGlvbih0LGUsbixyLGEsaSxvLHUsYyxzLGwsZixwLGgsZCx5KXt2YXIgYj1BdCgpO3RyeXthdCh0KShlLG4scixhLGksbyx1LGMscyxsLGYscCxoLGQseSl9Y2F0Y2godCl7aWYoU3QoYiksdCE9PXQrMCl0aHJvdyB0O090KDEsMCl9fSxhYTpmdW5jdGlvbih0LGUsbixyLGEsaSxvLHUpe3ZhciBjPUF0KCk7dHJ5e2p0KHQsZSxuLHIsYSxpLG8sdSl9Y2F0Y2godCl7aWYoU3QoYyksdCE9PXQrMCl0aHJvdyB0O090KDEsMCl9fSxfOmZ1bmN0aW9uKHQsZSxuLHIsYSxpLG8sdSxjLHMsbCxmKXt2YXIgcD1BdCgpO3RyeXtEdCh0LGUsbixyLGEsaSxvLHUsYyxzLGwsZil9Y2F0Y2godCl7aWYoU3QocCksdCE9PXQrMCl0aHJvdyB0O090KDEsMCl9fSwkOmZ1bmN0aW9uKHQsZSxuLHIsYSxpKXt2YXIgbz1BdCgpO3RyeXtrdCh0LGUsbixyLGEsaSl9Y2F0Y2godCl7aWYoU3QobyksdCE9PXQrMCl0aHJvdyB0O090KDEsMCl9fSxuOmZ1bmN0aW9uKHQpe3JldHVybiB0fSxGOmZ1bmN0aW9uKHQpe2Z0PXR9LGhhOnl0LHk6ZnVuY3Rpb24odCxlLG4scil7cmV0dXJuIHl0KHQsZSxuLHIpfX07IWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0KXtlLmFzbT10LmV4cG9ydHMsTz1lLmFzbS5LYSxQKCksVT1lLmFzbS5pYixJLnVuc2hpZnQoZS5hc20uTGEpLEItLSxlLm1vbml0b3JSdW5EZXBlbmRlbmNpZXMmJmUubW9uaXRvclJ1bkRlcGVuZGVuY2llcyhCKSwwPT1CJiYobnVsbCE9PUcmJihjbGVhckludGVydmFsKEcpLEc9bnVsbCksTiYmKHQ9TixOPW51bGwsdCgpKSl9ZnVuY3Rpb24gbihlKXt0KGUuaW5zdGFuY2UpfWZ1bmN0aW9uIHIodCl7cmV0dXJuIGZ1bmN0aW9uKCl7aWYoIWcmJihkfHx5KSl7aWYoXCJmdW5jdGlvblwiPT10eXBlb2YgZmV0Y2gmJiFZLnN0YXJ0c1dpdGgoXCJmaWxlOi8vXCIpKXJldHVybiBmZXRjaChZLHtjcmVkZW50aWFsczpcInNhbWUtb3JpZ2luXCJ9KS50aGVuKChmdW5jdGlvbih0KXtpZighdC5vayl0aHJvd1wiZmFpbGVkIHRvIGxvYWQgd2FzbSBiaW5hcnkgZmlsZSBhdCBcXCdcIitZK1wiXFwnXCI7cmV0dXJuIHQuYXJyYXlCdWZmZXIoKX0pKS5jYXRjaCgoZnVuY3Rpb24oKXtyZXR1cm4gWCgpfSkpO2lmKG8pcmV0dXJuIG5ldyBQcm9taXNlKChmdW5jdGlvbih0LGUpe28oWSwoZnVuY3Rpb24oZSl7dChuZXcgVWludDhBcnJheShlKSl9KSxlKX0pKX1yZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoZnVuY3Rpb24oKXtyZXR1cm4gWCgpfSkpfSgpLnRoZW4oKGZ1bmN0aW9uKHQpe3JldHVybiBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZSh0LGkpfSkpLnRoZW4oKGZ1bmN0aW9uKHQpe3JldHVybiB0fSkpLnRoZW4odCwoZnVuY3Rpb24odCl7dyhcImZhaWxlZCB0byBhc3luY2hyb25vdXNseSBwcmVwYXJlIHdhc206IFwiK3QpLFYodCl9KSl9dmFyIGk9e2E6YnR9O2lmKEIrKyxlLm1vbml0b3JSdW5EZXBlbmRlbmNpZXMmJmUubW9uaXRvclJ1bkRlcGVuZGVuY2llcyhCKSxlLmluc3RhbnRpYXRlV2FzbSl0cnl7cmV0dXJuIGUuaW5zdGFudGlhdGVXYXNtKGksdCl9Y2F0Y2godCl7cmV0dXJuIHcoXCJNb2R1bGUuaW5zdGFudGlhdGVXYXNtIGNhbGxiYWNrIGZhaWxlZCB3aXRoIGVycm9yOiBcIit0KSwhMX0oZ3x8XCJmdW5jdGlvblwiIT10eXBlb2YgV2ViQXNzZW1ibHkuaW5zdGFudGlhdGVTdHJlYW1pbmd8fCQoKXx8WS5zdGFydHNXaXRoKFwiZmlsZTovL1wiKXx8Ynx8XCJmdW5jdGlvblwiIT10eXBlb2YgZmV0Y2g/cihuKTpmZXRjaChZLHtjcmVkZW50aWFsczpcInNhbWUtb3JpZ2luXCJ9KS50aGVuKChmdW5jdGlvbih0KXtyZXR1cm4gV2ViQXNzZW1ibHkuaW5zdGFudGlhdGVTdHJlYW1pbmcodCxpKS50aGVuKG4sKGZ1bmN0aW9uKHQpe3JldHVybiB3KFwid2FzbSBzdHJlYW1pbmcgY29tcGlsZSBmYWlsZWQ6IFwiK3QpLHcoXCJmYWxsaW5nIGJhY2sgdG8gQXJyYXlCdWZmZXIgaW5zdGFudGlhdGlvblwiKSxyKG4pfSkpfSkpKS5jYXRjaChhKX0oKSxlLl9fX3dhc21fY2FsbF9jdG9ycz1mdW5jdGlvbigpe3JldHVybihlLl9fX3dhc21fY2FsbF9jdG9ycz1lLmFzbS5MYSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxlLl9PcnRJbml0PWZ1bmN0aW9uKCl7cmV0dXJuKGUuX09ydEluaXQ9ZS5hc20uTWEpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sZS5fT3J0Q3JlYXRlU2Vzc2lvbk9wdGlvbnM9ZnVuY3Rpb24oKXtyZXR1cm4oZS5fT3J0Q3JlYXRlU2Vzc2lvbk9wdGlvbnM9ZS5hc20uTmEpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sZS5fT3J0QXBwZW5kRXhlY3V0aW9uUHJvdmlkZXI9ZnVuY3Rpb24oKXtyZXR1cm4oZS5fT3J0QXBwZW5kRXhlY3V0aW9uUHJvdmlkZXI9ZS5hc20uT2EpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sZS5fT3J0QWRkU2Vzc2lvbkNvbmZpZ0VudHJ5PWZ1bmN0aW9uKCl7cmV0dXJuKGUuX09ydEFkZFNlc3Npb25Db25maWdFbnRyeT1lLmFzbS5QYSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxlLl9PcnRSZWxlYXNlU2Vzc2lvbk9wdGlvbnM9ZnVuY3Rpb24oKXtyZXR1cm4oZS5fT3J0UmVsZWFzZVNlc3Npb25PcHRpb25zPWUuYXNtLlFhKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGUuX09ydENyZWF0ZVNlc3Npb249ZnVuY3Rpb24oKXtyZXR1cm4oZS5fT3J0Q3JlYXRlU2Vzc2lvbj1lLmFzbS5SYSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxlLl9PcnRSZWxlYXNlU2Vzc2lvbj1mdW5jdGlvbigpe3JldHVybihlLl9PcnRSZWxlYXNlU2Vzc2lvbj1lLmFzbS5TYSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxlLl9PcnRHZXRJbnB1dENvdW50PWZ1bmN0aW9uKCl7cmV0dXJuKGUuX09ydEdldElucHV0Q291bnQ9ZS5hc20uVGEpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sZS5fT3J0R2V0T3V0cHV0Q291bnQ9ZnVuY3Rpb24oKXtyZXR1cm4oZS5fT3J0R2V0T3V0cHV0Q291bnQ9ZS5hc20uVWEpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sZS5fT3J0R2V0SW5wdXROYW1lPWZ1bmN0aW9uKCl7cmV0dXJuKGUuX09ydEdldElucHV0TmFtZT1lLmFzbS5WYSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxlLl9PcnRHZXRPdXRwdXROYW1lPWZ1bmN0aW9uKCl7cmV0dXJuKGUuX09ydEdldE91dHB1dE5hbWU9ZS5hc20uV2EpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sZS5fT3J0RnJlZT1mdW5jdGlvbigpe3JldHVybihlLl9PcnRGcmVlPWUuYXNtLlhhKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGUuX09ydENyZWF0ZVRlbnNvcj1mdW5jdGlvbigpe3JldHVybihlLl9PcnRDcmVhdGVUZW5zb3I9ZS5hc20uWWEpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sZS5fT3J0R2V0VGVuc29yRGF0YT1mdW5jdGlvbigpe3JldHVybihlLl9PcnRHZXRUZW5zb3JEYXRhPWUuYXNtLlphKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGUuX09ydFJlbGVhc2VUZW5zb3I9ZnVuY3Rpb24oKXtyZXR1cm4oZS5fT3J0UmVsZWFzZVRlbnNvcj1lLmFzbS5fYSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxlLl9PcnRDcmVhdGVSdW5PcHRpb25zPWZ1bmN0aW9uKCl7cmV0dXJuKGUuX09ydENyZWF0ZVJ1bk9wdGlvbnM9ZS5hc20uJGEpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sZS5fT3J0QWRkUnVuQ29uZmlnRW50cnk9ZnVuY3Rpb24oKXtyZXR1cm4oZS5fT3J0QWRkUnVuQ29uZmlnRW50cnk9ZS5hc20uYWIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sZS5fT3J0UmVsZWFzZVJ1bk9wdGlvbnM9ZnVuY3Rpb24oKXtyZXR1cm4oZS5fT3J0UmVsZWFzZVJ1bk9wdGlvbnM9ZS5hc20uYmIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sZS5fT3J0UnVuPWZ1bmN0aW9uKCl7cmV0dXJuKGUuX09ydFJ1bj1lLmFzbS5jYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxlLl9PcnRFbmRQcm9maWxpbmc9ZnVuY3Rpb24oKXtyZXR1cm4oZS5fT3J0RW5kUHJvZmlsaW5nPWUuYXNtLmRiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O3ZhciBtdCxndD1lLl9tYWxsb2M9ZnVuY3Rpb24oKXtyZXR1cm4oZ3Q9ZS5fbWFsbG9jPWUuYXNtLmViKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHZ0PWUuX2ZyZWU9ZnVuY3Rpb24oKXtyZXR1cm4odnQ9ZS5fZnJlZT1lLmFzbS5mYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSx3dD1lLl9mZmx1c2g9ZnVuY3Rpb24oKXtyZXR1cm4od3Q9ZS5fZmZsdXNoPWUuYXNtLmdiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LF90PWUuX19fZnVuY3Nfb25fZXhpdD1mdW5jdGlvbigpe3JldHVybihfdD1lLl9fX2Z1bmNzX29uX2V4aXQ9ZS5hc20uaGIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sT3Q9ZS5fc2V0VGhyZXc9ZnVuY3Rpb24oKXtyZXR1cm4oT3Q9ZS5fc2V0VGhyZXc9ZS5hc20uamIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sQXQ9ZS5zdGFja1NhdmU9ZnVuY3Rpb24oKXtyZXR1cm4oQXQ9ZS5zdGFja1NhdmU9ZS5hc20ua2IpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sU3Q9ZS5zdGFja1Jlc3RvcmU9ZnVuY3Rpb24oKXtyZXR1cm4oU3Q9ZS5zdGFja1Jlc3RvcmU9ZS5hc20ubGIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sVHQ9ZS5zdGFja0FsbG9jPWZ1bmN0aW9uKCl7cmV0dXJuKFR0PWUuc3RhY2tBbGxvYz1lLmFzbS5tYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxFdD1lLl9fX2N4YV9jYW5fY2F0Y2g9ZnVuY3Rpb24oKXtyZXR1cm4oRXQ9ZS5fX19jeGFfY2FuX2NhdGNoPWUuYXNtLm5iKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LE10PWUuX19fY3hhX2lzX3BvaW50ZXJfdHlwZT1mdW5jdGlvbigpe3JldHVybihNdD1lLl9fX2N4YV9pc19wb2ludGVyX3R5cGU9ZS5hc20ub2IpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sQ3Q9ZS5keW5DYWxsX2o9ZnVuY3Rpb24oKXtyZXR1cm4oQ3Q9ZS5keW5DYWxsX2o9ZS5hc20ucGIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0seHQ9ZS5keW5DYWxsX2lpaWlpaj1mdW5jdGlvbigpe3JldHVybih4dD1lLmR5bkNhbGxfaWlpaWlqPWUuYXNtLnFiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LFJ0PWUuZHluQ2FsbF9qaWk9ZnVuY3Rpb24oKXtyZXR1cm4oUnQ9ZS5keW5DYWxsX2ppaT1lLmFzbS5yYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxqdD1lLmR5bkNhbGxfdmlpaWlpaj1mdW5jdGlvbigpe3JldHVybihqdD1lLmR5bkNhbGxfdmlpaWlpaj1lLmFzbS5zYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxrdD1lLmR5bkNhbGxfdmpqaT1mdW5jdGlvbigpe3JldHVybihrdD1lLmR5bkNhbGxfdmpqaT1lLmFzbS50YikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxEdD1lLmR5bkNhbGxfdmlpaWpqamlpPWZ1bmN0aW9uKCl7cmV0dXJuKER0PWUuZHluQ2FsbF92aWlpampqaWk9ZS5hc20udWIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sUHQ9ZS5keW5DYWxsX2lpaj1mdW5jdGlvbigpe3JldHVybihQdD1lLmR5bkNhbGxfaWlqPWUuYXNtLnZiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LFV0PWUuZHluQ2FsbF9qaT1mdW5jdGlvbigpe3JldHVybihVdD1lLmR5bkNhbGxfamk9ZS5hc20ud2IpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sRnQ9ZS5keW5DYWxsX2lpaWlpaWo9ZnVuY3Rpb24oKXtyZXR1cm4oRnQ9ZS5keW5DYWxsX2lpaWlpaWo9ZS5hc20ueGIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sSXQ9ZS5keW5DYWxsX2lpaWo9ZnVuY3Rpb24oKXtyZXR1cm4oSXQ9ZS5keW5DYWxsX2lpaWo9ZS5hc20ueWIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX07ZnVuY3Rpb24gV3QoKXtmdW5jdGlvbiB0KCl7aWYoIW10JiYobXQ9ITAsZS5jYWxsZWRSdW49ITAsIUMpKXtpZihaKEkpLHIoZSksZS5vblJ1bnRpbWVJbml0aWFsaXplZCYmZS5vblJ1bnRpbWVJbml0aWFsaXplZCgpLGUucG9zdFJ1bilmb3IoXCJmdW5jdGlvblwiPT10eXBlb2YgZS5wb3N0UnVuJiYoZS5wb3N0UnVuPVtlLnBvc3RSdW5dKTtlLnBvc3RSdW4ubGVuZ3RoOyl7dmFyIHQ9ZS5wb3N0UnVuLnNoaWZ0KCk7SC51bnNoaWZ0KHQpfVooSCl9fWlmKCEoMDxCKSl7aWYoZS5wcmVSdW4pZm9yKFwiZnVuY3Rpb25cIj09dHlwZW9mIGUucHJlUnVuJiYoZS5wcmVSdW49W2UucHJlUnVuXSk7ZS5wcmVSdW4ubGVuZ3RoOyl6KCk7WihGKSwwPEJ8fChlLnNldFN0YXR1cz8oZS5zZXRTdGF0dXMoXCJSdW5uaW5nLi4uXCIpLHNldFRpbWVvdXQoKGZ1bmN0aW9uKCl7c2V0VGltZW91dCgoZnVuY3Rpb24oKXtlLnNldFN0YXR1cyhcIlwiKX0pLDEpLHQoKX0pLDEpKTp0KCkpfX1pZihlLlVURjhUb1N0cmluZz1qLGUuc3RyaW5nVG9VVEY4PWZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gayh0LFQsZSxuKX0sZS5sZW5ndGhCeXRlc1VURjg9RCxlLnN0YWNrU2F2ZT1BdCxlLnN0YWNrUmVzdG9yZT1TdCxlLnN0YWNrQWxsb2M9VHQsTj1mdW5jdGlvbiB0KCl7bXR8fFd0KCksbXR8fChOPXQpfSxlLnByZUluaXQpZm9yKFwiZnVuY3Rpb25cIj09dHlwZW9mIGUucHJlSW5pdCYmKGUucHJlSW5pdD1bZS5wcmVJbml0XSk7MDxlLnByZUluaXQubGVuZ3RoOyllLnByZUluaXQucG9wKCkoKTtyZXR1cm4gV3QoKSx0LnJlYWR5fSk7dC5leHBvcnRzPXJ9LDk2NzoodCxlKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUuaXRlcmF0ZUV4dHJhT3B0aW9ucz12b2lkIDAsZS5pdGVyYXRlRXh0cmFPcHRpb25zPSh0LG4scixhKT0+e2lmKFwib2JqZWN0XCI9PXR5cGVvZiB0JiZudWxsIT09dCl7aWYoci5oYXModCkpdGhyb3cgbmV3IEVycm9yKFwiQ2lyY3VsYXIgcmVmZXJlbmNlIGluIG9wdGlvbnNcIik7ci5hZGQodCl9T2JqZWN0LmVudHJpZXModCkuZm9yRWFjaCgoKFt0LGldKT0+e2NvbnN0IG89bj9uK3Q6dDtpZihcIm9iamVjdFwiPT10eXBlb2YgaSkoMCxlLml0ZXJhdGVFeHRyYU9wdGlvbnMpKGksbytcIi5cIixyLGEpO2Vsc2UgaWYoXCJzdHJpbmdcIj09dHlwZW9mIGl8fFwibnVtYmVyXCI9PXR5cGVvZiBpKWEobyxpLnRvU3RyaW5nKCkpO2Vsc2V7aWYoXCJib29sZWFuXCIhPXR5cGVvZiBpKXRocm93IG5ldyBFcnJvcihcIkNhblxcJ3QgaGFuZGxlIGV4dHJhIGNvbmZpZyB0eXBlOiBcIit0eXBlb2YgaSk7YShvLGk/XCIxXCI6XCIwXCIpfX0pKX19LDU4NjoodCxlLG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5zZXRSdW5PcHRpb25zPXZvaWQgMDtjb25zdCByPW4oOTY3KSxhPW4oOTgzKSxpPW4oMzYxKTtlLnNldFJ1bk9wdGlvbnM9dD0+e2NvbnN0IGU9KDAsaS5nZXRJbnN0YW5jZSkoKTtsZXQgbj0wO2NvbnN0IG89W10sdT10fHx7fTt0cnl7aWYodm9pZCAwPT09KG51bGw9PXQ/dm9pZCAwOnQubG9nU2V2ZXJpdHlMZXZlbCkpdS5sb2dTZXZlcml0eUxldmVsPTI7ZWxzZSBpZihcIm51bWJlclwiIT10eXBlb2YgdC5sb2dTZXZlcml0eUxldmVsfHwhTnVtYmVyLmlzSW50ZWdlcih0LmxvZ1NldmVyaXR5TGV2ZWwpfHx0LmxvZ1NldmVyaXR5TGV2ZWw8MHx8dC5sb2dTZXZlcml0eUxldmVsPjQpdGhyb3cgbmV3IEVycm9yKGBsb2cgc2VydmVyaXR5IGxldmVsIGlzIG5vdCB2YWxpZDogJHt0LmxvZ1NldmVyaXR5TGV2ZWx9YCk7aWYodm9pZCAwPT09KG51bGw9PXQ/dm9pZCAwOnQubG9nVmVyYm9zaXR5TGV2ZWwpKXUubG9nVmVyYm9zaXR5TGV2ZWw9MDtlbHNlIGlmKFwibnVtYmVyXCIhPXR5cGVvZiB0LmxvZ1ZlcmJvc2l0eUxldmVsfHwhTnVtYmVyLmlzSW50ZWdlcih0LmxvZ1ZlcmJvc2l0eUxldmVsKSl0aHJvdyBuZXcgRXJyb3IoYGxvZyB2ZXJib3NpdHkgbGV2ZWwgaXMgbm90IHZhbGlkOiAke3QubG9nVmVyYm9zaXR5TGV2ZWx9YCk7dm9pZCAwPT09KG51bGw9PXQ/dm9pZCAwOnQudGVybWluYXRlKSYmKHUudGVybWluYXRlPSExKTtsZXQgaT0wO2lmKHZvaWQgMCE9PShudWxsPT10P3ZvaWQgMDp0LnRhZykmJihpPSgwLGEuYWxsb2NXYXNtU3RyaW5nKSh0LnRhZyxvKSksbj1lLl9PcnRDcmVhdGVSdW5PcHRpb25zKHUubG9nU2V2ZXJpdHlMZXZlbCx1LmxvZ1ZlcmJvc2l0eUxldmVsLCEhdS50ZXJtaW5hdGUsaSksMD09PW4pdGhyb3cgbmV3IEVycm9yKFwiQ2FuXFwndCBjcmVhdGUgcnVuIG9wdGlvbnNcIik7cmV0dXJuIHZvaWQgMCE9PShudWxsPT10P3ZvaWQgMDp0LmV4dHJhKSYmKDAsci5pdGVyYXRlRXh0cmFPcHRpb25zKSh0LmV4dHJhLFwiXCIsbmV3IFdlYWtTZXQsKCh0LHIpPT57Y29uc3QgaT0oMCxhLmFsbG9jV2FzbVN0cmluZykodCxvKSx1PSgwLGEuYWxsb2NXYXNtU3RyaW5nKShyLG8pO2lmKDAhPT1lLl9PcnRBZGRSdW5Db25maWdFbnRyeShuLGksdSkpdGhyb3cgbmV3IEVycm9yKGBDYW5cXCd0IHNldCBhIHJ1biBjb25maWcgZW50cnk6ICR7dH0gLSAke3J9YCl9KSksW24sb119Y2F0Y2godCl7dGhyb3cgMCE9PW4mJmUuX09ydFJlbGVhc2VSdW5PcHRpb25zKG4pLG8uZm9yRWFjaChlLl9mcmVlKSx0fX19LDkxOToodCxlLG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5zZXRTZXNzaW9uT3B0aW9ucz12b2lkIDA7Y29uc3Qgcj1uKDk2NyksYT1uKDk4MyksaT1uKDM2MSk7ZS5zZXRTZXNzaW9uT3B0aW9ucz10PT57Y29uc3QgZT0oMCxpLmdldEluc3RhbmNlKSgpO2xldCBuPTA7Y29uc3Qgbz1bXSx1PXR8fHt9Oyh0PT57dC5leHRyYXx8KHQuZXh0cmE9e30pLHQuZXh0cmEuc2Vzc2lvbnx8KHQuZXh0cmEuc2Vzc2lvbj17fSk7Y29uc3QgZT10LmV4dHJhLnNlc3Npb247ZS51c2Vfb3J0X21vZGVsX2J5dGVzX2RpcmVjdGx5fHwoZS51c2Vfb3J0X21vZGVsX2J5dGVzX2RpcmVjdGx5PVwiMVwiKX0pKHUpO3RyeXt2b2lkIDA9PT0obnVsbD09dD92b2lkIDA6dC5ncmFwaE9wdGltaXphdGlvbkxldmVsKSYmKHUuZ3JhcGhPcHRpbWl6YXRpb25MZXZlbD1cImFsbFwiKTtjb25zdCBjPSh0PT57c3dpdGNoKHQpe2Nhc2VcImRpc2FibGVkXCI6cmV0dXJuIDA7Y2FzZVwiYmFzaWNcIjpyZXR1cm4gMTtjYXNlXCJleHRlbmRlZFwiOnJldHVybiAyO2Nhc2VcImFsbFwiOnJldHVybiA5OTtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgZ3JhcGggb3B0aW1pemF0aW9uIGxldmVsOiAke3R9YCl9fSkodS5ncmFwaE9wdGltaXphdGlvbkxldmVsKTt2b2lkIDA9PT0obnVsbD09dD92b2lkIDA6dC5lbmFibGVDcHVNZW1BcmVuYSkmJih1LmVuYWJsZUNwdU1lbUFyZW5hPSEwKSx2b2lkIDA9PT0obnVsbD09dD92b2lkIDA6dC5lbmFibGVNZW1QYXR0ZXJuKSYmKHUuZW5hYmxlTWVtUGF0dGVybj0hMCksdm9pZCAwPT09KG51bGw9PXQ/dm9pZCAwOnQuZXhlY3V0aW9uTW9kZSkmJih1LmV4ZWN1dGlvbk1vZGU9XCJzZXF1ZW50aWFsXCIpO2NvbnN0IHM9KHQ9Pntzd2l0Y2godCl7Y2FzZVwic2VxdWVudGlhbFwiOnJldHVybiAwO2Nhc2VcInBhcmFsbGVsXCI6cmV0dXJuIDE7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIGV4ZWN1dGlvbiBtb2RlOiAke3R9YCl9fSkodS5leGVjdXRpb25Nb2RlKTtsZXQgbD0wO2lmKHZvaWQgMCE9PShudWxsPT10P3ZvaWQgMDp0LmxvZ0lkKSYmKGw9KDAsYS5hbGxvY1dhc21TdHJpbmcpKHQubG9nSWQsbykpLHZvaWQgMD09PShudWxsPT10P3ZvaWQgMDp0LmxvZ1NldmVyaXR5TGV2ZWwpKXUubG9nU2V2ZXJpdHlMZXZlbD0yO2Vsc2UgaWYoXCJudW1iZXJcIiE9dHlwZW9mIHQubG9nU2V2ZXJpdHlMZXZlbHx8IU51bWJlci5pc0ludGVnZXIodC5sb2dTZXZlcml0eUxldmVsKXx8dC5sb2dTZXZlcml0eUxldmVsPDB8fHQubG9nU2V2ZXJpdHlMZXZlbD40KXRocm93IG5ldyBFcnJvcihgbG9nIHNlcnZlcml0eSBsZXZlbCBpcyBub3QgdmFsaWQ6ICR7dC5sb2dTZXZlcml0eUxldmVsfWApO2lmKHZvaWQgMD09PShudWxsPT10P3ZvaWQgMDp0LmxvZ1ZlcmJvc2l0eUxldmVsKSl1LmxvZ1ZlcmJvc2l0eUxldmVsPTA7ZWxzZSBpZihcIm51bWJlclwiIT10eXBlb2YgdC5sb2dWZXJib3NpdHlMZXZlbHx8IU51bWJlci5pc0ludGVnZXIodC5sb2dWZXJib3NpdHlMZXZlbCkpdGhyb3cgbmV3IEVycm9yKGBsb2cgdmVyYm9zaXR5IGxldmVsIGlzIG5vdCB2YWxpZDogJHt0LmxvZ1ZlcmJvc2l0eUxldmVsfWApO2lmKHZvaWQgMD09PShudWxsPT10P3ZvaWQgMDp0LmVuYWJsZVByb2ZpbGluZykmJih1LmVuYWJsZVByb2ZpbGluZz0hMSksbj1lLl9PcnRDcmVhdGVTZXNzaW9uT3B0aW9ucyhjLCEhdS5lbmFibGVDcHVNZW1BcmVuYSwhIXUuZW5hYmxlTWVtUGF0dGVybixzLCEhdS5lbmFibGVQcm9maWxpbmcsMCxsLHUubG9nU2V2ZXJpdHlMZXZlbCx1LmxvZ1ZlcmJvc2l0eUxldmVsKSwwPT09bil0aHJvdyBuZXcgRXJyb3IoXCJDYW5cXCd0IGNyZWF0ZSBzZXNzaW9uIG9wdGlvbnNcIik7cmV0dXJuKG51bGw9PXQ/dm9pZCAwOnQuZXhlY3V0aW9uUHJvdmlkZXJzKSYmKCh0LGUsbik9Pntmb3IoY29uc3QgciBvZiBlKXtsZXQgZT1cInN0cmluZ1wiPT10eXBlb2Ygcj9yOnIubmFtZTtzd2l0Y2goZSl7Y2FzZVwieG5ucGFja1wiOmU9XCJYTk5QQUNLXCI7YnJlYWs7Y2FzZVwid2FzbVwiOmNhc2VcImNwdVwiOmNvbnRpbnVlO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBub3Qgc3VwcG9ydGVkIEVQOiAke2V9YCl9Y29uc3Qgbz0oMCxhLmFsbG9jV2FzbVN0cmluZykoZSxuKTtpZigwIT09KDAsaS5nZXRJbnN0YW5jZSkoKS5fT3J0QXBwZW5kRXhlY3V0aW9uUHJvdmlkZXIodCxvKSl0aHJvdyBuZXcgRXJyb3IoYENhblxcJ3QgYXBwZW5kIGV4ZWN1dGlvbiBwcm92aWRlcjogJHtlfWApfX0pKG4sdC5leGVjdXRpb25Qcm92aWRlcnMsbyksdm9pZCAwIT09KG51bGw9PXQ/dm9pZCAwOnQuZXh0cmEpJiYoMCxyLml0ZXJhdGVFeHRyYU9wdGlvbnMpKHQuZXh0cmEsXCJcIixuZXcgV2Vha1NldCwoKHQscik9Pntjb25zdCBpPSgwLGEuYWxsb2NXYXNtU3RyaW5nKSh0LG8pLHU9KDAsYS5hbGxvY1dhc21TdHJpbmcpKHIsbyk7aWYoMCE9PWUuX09ydEFkZFNlc3Npb25Db25maWdFbnRyeShuLGksdSkpdGhyb3cgbmV3IEVycm9yKGBDYW5cXCd0IHNldCBhIHNlc3Npb24gY29uZmlnIGVudHJ5OiAke3R9IC0gJHtyfWApfSkpLFtuLG9dfWNhdGNoKHQpe3Rocm93IDAhPT1uJiZlLl9PcnRSZWxlYXNlU2Vzc2lvbk9wdGlvbnMobiksby5mb3JFYWNoKGUuX2ZyZWUpLHR9fX0sOTgzOih0LGUsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLmFsbG9jV2FzbVN0cmluZz12b2lkIDA7Y29uc3Qgcj1uKDM2MSk7ZS5hbGxvY1dhc21TdHJpbmc9KHQsZSk9Pntjb25zdCBuPSgwLHIuZ2V0SW5zdGFuY2UpKCksYT1uLmxlbmd0aEJ5dGVzVVRGOCh0KSsxLGk9bi5fbWFsbG9jKGEpO3JldHVybiBuLnN0cmluZ1RvVVRGOCh0LGksYSksZS5wdXNoKGkpLGl9fSwzNDk6KHQsZSxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUuZXh0cmFjdFRyYW5zZmVyYWJsZUJ1ZmZlcnM9ZS5lbmRQcm9maWxpbmc9ZS5ydW49ZS5yZWxlYXNlU2Vzc2lvbj1lLmNyZWF0ZVNlc3Npb249ZS5jcmVhdGVTZXNzaW9uRmluYWxpemU9ZS5jcmVhdGVTZXNzaW9uQWxsb2NhdGU9ZS5pbml0T3J0PXZvaWQgMDtjb25zdCByPW4oNTg2KSxhPW4oOTE5KSxpPW4oOTgzKSxvPW4oMzYxKTtlLmluaXRPcnQ9KHQsZSk9Pntjb25zdCBuPSgwLG8uZ2V0SW5zdGFuY2UpKCkuX09ydEluaXQodCxlKTtpZigwIT09bil0aHJvdyBuZXcgRXJyb3IoYENhblxcJ3QgaW5pdGlhbGl6ZSBvbm54cnVudGltZS4gZXJyb3IgY29kZSA9ICR7bn1gKX07Y29uc3QgdT1uZXcgTWFwO2UuY3JlYXRlU2Vzc2lvbkFsbG9jYXRlPXQ9Pntjb25zdCBlPSgwLG8uZ2V0SW5zdGFuY2UpKCksbj1lLl9tYWxsb2ModC5ieXRlTGVuZ3RoKTtyZXR1cm4gZS5IRUFQVTguc2V0KHQsbiksW24sdC5ieXRlTGVuZ3RoXX0sZS5jcmVhdGVTZXNzaW9uRmluYWxpemU9KHQsZSk9Pntjb25zdCBuPSgwLG8uZ2V0SW5zdGFuY2UpKCk7bGV0IHI9MCxpPTAsYz1bXTt0cnl7aWYoW2ksY109KDAsYS5zZXRTZXNzaW9uT3B0aW9ucykoZSkscj1uLl9PcnRDcmVhdGVTZXNzaW9uKHRbMF0sdFsxXSxpKSwwPT09cil0aHJvdyBuZXcgRXJyb3IoXCJDYW5cXCd0IGNyZWF0ZSBhIHNlc3Npb25cIil9ZmluYWxseXtuLl9mcmVlKHRbMF0pLG4uX09ydFJlbGVhc2VTZXNzaW9uT3B0aW9ucyhpKSxjLmZvckVhY2gobi5fZnJlZSl9Y29uc3Qgcz1uLl9PcnRHZXRJbnB1dENvdW50KHIpLGw9bi5fT3J0R2V0T3V0cHV0Q291bnQociksZj1bXSxwPVtdLGg9W10sZD1bXTtmb3IobGV0IHQ9MDt0PHM7dCsrKXtjb25zdCBlPW4uX09ydEdldElucHV0TmFtZShyLHQpO2lmKDA9PT1lKXRocm93IG5ldyBFcnJvcihcIkNhblxcJ3QgZ2V0IGFuIGlucHV0IG5hbWVcIik7cC5wdXNoKGUpLGYucHVzaChuLlVURjhUb1N0cmluZyhlKSl9Zm9yKGxldCB0PTA7dDxsO3QrKyl7Y29uc3QgZT1uLl9PcnRHZXRPdXRwdXROYW1lKHIsdCk7aWYoMD09PWUpdGhyb3cgbmV3IEVycm9yKFwiQ2FuXFwndCBnZXQgYW4gb3V0cHV0IG5hbWVcIik7ZC5wdXNoKGUpLGgucHVzaChuLlVURjhUb1N0cmluZyhlKSl9cmV0dXJuIHUuc2V0KHIsW3IscCxkXSksW3IsZixoXX0sZS5jcmVhdGVTZXNzaW9uPSh0LG4pPT57Y29uc3Qgcj0oMCxlLmNyZWF0ZVNlc3Npb25BbGxvY2F0ZSkodCk7cmV0dXJuKDAsZS5jcmVhdGVTZXNzaW9uRmluYWxpemUpKHIsbil9LGUucmVsZWFzZVNlc3Npb249dD0+e2NvbnN0IGU9KDAsby5nZXRJbnN0YW5jZSkoKSxuPXUuZ2V0KHQpO2lmKCFuKXRocm93IG5ldyBFcnJvcihcImludmFsaWQgc2Vzc2lvbiBpZFwiKTtjb25zdCByPW5bMF0sYT1uWzFdLGk9blsyXTthLmZvckVhY2goZS5fT3J0RnJlZSksaS5mb3JFYWNoKGUuX09ydEZyZWUpLGUuX09ydFJlbGVhc2VTZXNzaW9uKHIpLHUuZGVsZXRlKHQpfTtjb25zdCBjPXQ9Pntzd2l0Y2godCl7Y2FzZVwiaW50OFwiOnJldHVybiAzO2Nhc2VcInVpbnQ4XCI6cmV0dXJuIDI7Y2FzZVwiYm9vbFwiOnJldHVybiA5O2Nhc2VcImludDE2XCI6cmV0dXJuIDU7Y2FzZVwidWludDE2XCI6cmV0dXJuIDQ7Y2FzZVwiaW50MzJcIjpyZXR1cm4gNjtjYXNlXCJ1aW50MzJcIjpyZXR1cm4gMTI7Y2FzZVwiZmxvYXQzMlwiOnJldHVybiAxO2Nhc2VcImZsb2F0NjRcIjpyZXR1cm4gMTE7Y2FzZVwic3RyaW5nXCI6cmV0dXJuIDg7Y2FzZVwiaW50NjRcIjpyZXR1cm4gNztjYXNlXCJ1aW50NjRcIjpyZXR1cm4gMTM7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIGRhdGEgdHlwZTogJHt0fWApfX0scz10PT57c3dpdGNoKHQpe2Nhc2UgMzpyZXR1cm5cImludDhcIjtjYXNlIDI6cmV0dXJuXCJ1aW50OFwiO2Nhc2UgOTpyZXR1cm5cImJvb2xcIjtjYXNlIDU6cmV0dXJuXCJpbnQxNlwiO2Nhc2UgNDpyZXR1cm5cInVpbnQxNlwiO2Nhc2UgNjpyZXR1cm5cImludDMyXCI7Y2FzZSAxMjpyZXR1cm5cInVpbnQzMlwiO2Nhc2UgMTpyZXR1cm5cImZsb2F0MzJcIjtjYXNlIDExOnJldHVyblwiZmxvYXQ2NFwiO2Nhc2UgODpyZXR1cm5cInN0cmluZ1wiO2Nhc2UgNzpyZXR1cm5cImludDY0XCI7Y2FzZSAxMzpyZXR1cm5cInVpbnQ2NFwiO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCBkYXRhIHR5cGU6ICR7dH1gKX19LGw9dD0+e3N3aXRjaCh0KXtjYXNlXCJmbG9hdDMyXCI6cmV0dXJuIEZsb2F0MzJBcnJheTtjYXNlXCJ1aW50OFwiOmNhc2VcImJvb2xcIjpyZXR1cm4gVWludDhBcnJheTtjYXNlXCJpbnQ4XCI6cmV0dXJuIEludDhBcnJheTtjYXNlXCJ1aW50MTZcIjpyZXR1cm4gVWludDE2QXJyYXk7Y2FzZVwiaW50MTZcIjpyZXR1cm4gSW50MTZBcnJheTtjYXNlXCJpbnQzMlwiOnJldHVybiBJbnQzMkFycmF5O2Nhc2VcImZsb2F0NjRcIjpyZXR1cm4gRmxvYXQ2NEFycmF5O2Nhc2VcInVpbnQzMlwiOnJldHVybiBVaW50MzJBcnJheTtjYXNlXCJpbnQ2NFwiOnJldHVybiBCaWdJbnQ2NEFycmF5O2Nhc2VcInVpbnQ2NFwiOnJldHVybiBCaWdVaW50NjRBcnJheTtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgdHlwZTogJHt0fWApfX07ZS5ydW49KHQsZSxuLGEsZik9Pntjb25zdCBwPSgwLG8uZ2V0SW5zdGFuY2UpKCksaD11LmdldCh0KTtpZighaCl0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHNlc3Npb24gaWRcIik7Y29uc3QgZD1oWzBdLHk9aFsxXSxiPWhbMl0sbT1lLmxlbmd0aCxnPWEubGVuZ3RoO2xldCB2PTAsdz1bXTtjb25zdCBfPVtdLE89W107dHJ5e1t2LHddPSgwLHIuc2V0UnVuT3B0aW9ucykoZik7Zm9yKGxldCB0PTA7dDxtO3QrKyl7Y29uc3QgZT1uW3RdWzBdLHI9blt0XVsxXSxhPW5bdF1bMl07bGV0IG8sdTtpZihBcnJheS5pc0FycmF5KGEpKXt1PTQqYS5sZW5ndGgsbz1wLl9tYWxsb2ModSksTy5wdXNoKG8pO2xldCB0PW8vNDtmb3IobGV0IGU9MDtlPGEubGVuZ3RoO2UrKyl7aWYoXCJzdHJpbmdcIiE9dHlwZW9mIGFbZV0pdGhyb3cgbmV3IFR5cGVFcnJvcihgdGVuc29yIGRhdGEgYXQgaW5kZXggJHtlfSBpcyBub3QgYSBzdHJpbmdgKTtwLkhFQVBVMzJbdCsrXT0oMCxpLmFsbG9jV2FzbVN0cmluZykoYVtlXSxPKX19ZWxzZSB1PWEuYnl0ZUxlbmd0aCxvPXAuX21hbGxvYyh1KSxPLnB1c2gobykscC5IRUFQVTguc2V0KG5ldyBVaW50OEFycmF5KGEuYnVmZmVyLGEuYnl0ZU9mZnNldCx1KSxvKTtjb25zdCBzPXAuc3RhY2tTYXZlKCksbD1wLnN0YWNrQWxsb2MoNCpyLmxlbmd0aCk7dHJ5e2xldCB0PWwvNDtyLmZvckVhY2goKGU9PnAuSEVBUDMyW3QrK109ZSkpO2NvbnN0IG49cC5fT3J0Q3JlYXRlVGVuc29yKGMoZSksbyx1LGwsci5sZW5ndGgpO2lmKDA9PT1uKXRocm93IG5ldyBFcnJvcihcIkNhblxcJ3QgY3JlYXRlIGEgdGVuc29yXCIpO18ucHVzaChuKX1maW5hbGx5e3Auc3RhY2tSZXN0b3JlKHMpfX1jb25zdCB0PXAuc3RhY2tTYXZlKCksbz1wLnN0YWNrQWxsb2MoNCptKSx1PXAuc3RhY2tBbGxvYyg0Km0pLGg9cC5zdGFja0FsbG9jKDQqZyksQT1wLnN0YWNrQWxsb2MoNCpnKTt0cnl7bGV0IG49by80LHI9dS80LGk9aC80LGM9QS80O2ZvcihsZXQgdD0wO3Q8bTt0KyspcC5IRUFQVTMyW24rK109X1t0XSxwLkhFQVBVMzJbcisrXT15W2VbdF1dO2ZvcihsZXQgdD0wO3Q8Zzt0KyspcC5IRUFQVTMyW2krK109MCxwLkhFQVBVMzJbYysrXT1iW2FbdF1dO2xldCBmPXAuX09ydFJ1bihkLHUsbyxtLEEsZyxoLHYpO2NvbnN0IHc9W107aWYoMD09PWYpZm9yKGxldCB0PTA7dDxnO3QrKyl7Y29uc3QgZT1wLkhFQVBVMzJbaC80K3RdLG49cC5zdGFja1NhdmUoKSxyPXAuc3RhY2tBbGxvYygxNik7bGV0IGEsaT0wO3RyeXtpZihmPXAuX09ydEdldFRlbnNvckRhdGEoZSxyLHIrNCxyKzgscisxMiksMCE9PWYpdGhyb3cgbmV3IEVycm9yKGBDYW5cXCd0IGFjY2VzcyBvdXRwdXQgdGVuc29yIGRhdGEuIGVycm9yIGNvZGUgPSAke2Z9YCk7bGV0IHQ9ci80O2NvbnN0IG89cC5IRUFQVTMyW3QrK107aT1wLkhFQVBVMzJbdCsrXTtjb25zdCB1PXAuSEVBUFUzMlt0KytdLGM9cC5IRUFQVTMyW3QrK10saD1bXTtmb3IobGV0IHQ9MDt0PGM7dCsrKWgucHVzaChwLkhFQVBVMzJbdS80K3RdKTtwLl9PcnRGcmVlKHUpO2NvbnN0IGQ9MD09PWgubGVuZ3RoPzE6aC5yZWR1Y2UoKCh0LGUpPT50KmUpKTtpZihhPXMobyksXCJzdHJpbmdcIj09PWEpe2NvbnN0IHQ9W107bGV0IGU9aS80O2ZvcihsZXQgbj0wO248ZDtuKyspe2NvbnN0IHI9cC5IRUFQVTMyW2UrK10sYT1uPT09ZC0xP3ZvaWQgMDpwLkhFQVBVMzJbZV0tcjt0LnB1c2gocC5VVEY4VG9TdHJpbmcocixhKSl9dy5wdXNoKFthLGgsdF0pfWVsc2V7Y29uc3QgdD1uZXcobChhKSkoZCk7bmV3IFVpbnQ4QXJyYXkodC5idWZmZXIsdC5ieXRlT2Zmc2V0LHQuYnl0ZUxlbmd0aCkuc2V0KHAuSEVBUFU4LnN1YmFycmF5KGksaSt0LmJ5dGVMZW5ndGgpKSx3LnB1c2goW2EsaCx0XSl9fWZpbmFsbHl7cC5zdGFja1Jlc3RvcmUobiksXCJzdHJpbmdcIj09PWEmJmkmJnAuX2ZyZWUoaSkscC5fT3J0UmVsZWFzZVRlbnNvcihlKX19aWYoMD09PWYpcmV0dXJuIHc7dGhyb3cgbmV3IEVycm9yKGBmYWlsZWQgdG8gY2FsbCBPcnRSdW4oKS4gZXJyb3IgY29kZSA9ICR7Zn0uYCl9ZmluYWxseXtwLnN0YWNrUmVzdG9yZSh0KX19ZmluYWxseXtfLmZvckVhY2gocC5fT3J0UmVsZWFzZVRlbnNvciksTy5mb3JFYWNoKHAuX2ZyZWUpLHAuX09ydFJlbGVhc2VSdW5PcHRpb25zKHYpLHcuZm9yRWFjaChwLl9mcmVlKX19LGUuZW5kUHJvZmlsaW5nPXQ9Pntjb25zdCBlPSgwLG8uZ2V0SW5zdGFuY2UpKCksbj11LmdldCh0KTtpZighbil0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHNlc3Npb24gaWRcIik7Y29uc3Qgcj1uWzBdLGE9ZS5fT3J0RW5kUHJvZmlsaW5nKHIpO2lmKDA9PT1hKXRocm93IG5ldyBFcnJvcihcIkNhblxcJ3QgZ2V0IGFuIHByb2ZpbGUgZmlsZSBuYW1lXCIpO2UuX09ydEZyZWUoYSl9LGUuZXh0cmFjdFRyYW5zZmVyYWJsZUJ1ZmZlcnM9dD0+e2NvbnN0IGU9W107Zm9yKGNvbnN0IG4gb2YgdCl7Y29uc3QgdD1uWzJdOyFBcnJheS5pc0FycmF5KHQpJiZ0LmJ1ZmZlciYmZS5wdXNoKHQuYnVmZmVyKX1yZXR1cm4gZX19LDM2MTpmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7dmFyIHI9dGhpcyYmdGhpcy5fX2NyZWF0ZUJpbmRpbmd8fChPYmplY3QuY3JlYXRlP2Z1bmN0aW9uKHQsZSxuLHIpe3ZvaWQgMD09PXImJihyPW4pO3ZhciBhPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSxuKTthJiYhKFwiZ2V0XCJpbiBhPyFlLl9fZXNNb2R1bGU6YS53cml0YWJsZXx8YS5jb25maWd1cmFibGUpfHwoYT17ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gZVtuXX19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCxyLGEpfTpmdW5jdGlvbih0LGUsbixyKXt2b2lkIDA9PT1yJiYocj1uKSx0W3JdPWVbbl19KSxhPXRoaXMmJnRoaXMuX19zZXRNb2R1bGVEZWZhdWx0fHwoT2JqZWN0LmNyZWF0ZT9mdW5jdGlvbih0LGUpe09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiZGVmYXVsdFwiLHtlbnVtZXJhYmxlOiEwLHZhbHVlOmV9KX06ZnVuY3Rpb24odCxlKXt0LmRlZmF1bHQ9ZX0pLGk9dGhpcyYmdGhpcy5fX2ltcG9ydFN0YXJ8fGZ1bmN0aW9uKHQpe2lmKHQmJnQuX19lc01vZHVsZSlyZXR1cm4gdDt2YXIgZT17fTtpZihudWxsIT10KWZvcih2YXIgbiBpbiB0KVwiZGVmYXVsdFwiIT09biYmT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQsbikmJnIoZSx0LG4pO3JldHVybiBhKGUsdCksZX0sbz10aGlzJiZ0aGlzLl9faW1wb3J0RGVmYXVsdHx8ZnVuY3Rpb24odCl7cmV0dXJuIHQmJnQuX19lc01vZHVsZT90OntkZWZhdWx0OnR9fTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLmRpc3Bvc2U9ZS5nZXRJbnN0YW5jZT1lLmluaXRpYWxpemVXZWJBc3NlbWJseT12b2lkIDA7Y29uc3QgdT1pKG4oNDQ5KSksYz1vKG4oOTMyKSkscz1uKDQ3NCk7bGV0IGwsZj0hMSxwPSExLGg9ITE7Y29uc3QgZD0odCxlKT0+ZT90P1wib3J0LXdhc20tc2ltZC10aHJlYWRlZC53YXNtXCI6XCJvcnQtd2FzbS10aHJlYWRlZC53YXNtXCI6dD9cIm9ydC13YXNtLXNpbWQud2FzbVwiOlwib3J0LXdhc20ud2FzbVwiO2UuaW5pdGlhbGl6ZVdlYkFzc2VtYmx5PWFzeW5jIHQ9PntpZihmKXJldHVybiBQcm9taXNlLnJlc29sdmUoKTtpZihwKXRocm93IG5ldyBFcnJvcihcIm11bHRpcGxlIGNhbGxzIHRvIFxcJ2luaXRpYWxpemVXZWJBc3NlbWJseSgpXFwnIGRldGVjdGVkLlwiKTtpZihoKXRocm93IG5ldyBFcnJvcihcInByZXZpb3VzIGNhbGwgdG8gXFwnaW5pdGlhbGl6ZVdlYkFzc2VtYmx5KClcXCcgZmFpbGVkLlwiKTtwPSEwO2NvbnN0IGU9dC5pbml0VGltZW91dCxyPXQubnVtVGhyZWFkcyxhPXQuc2ltZCxpPXI+MSYmKCgpPT57dHJ5e3JldHVyblwidW5kZWZpbmVkXCIhPXR5cGVvZiBTaGFyZWRBcnJheUJ1ZmZlciYmKFwidW5kZWZpbmVkXCIhPXR5cGVvZiBNZXNzYWdlQ2hhbm5lbCYmKG5ldyBNZXNzYWdlQ2hhbm5lbCkucG9ydDEucG9zdE1lc3NhZ2UobmV3IFNoYXJlZEFycmF5QnVmZmVyKDEpKSxXZWJBc3NlbWJseS52YWxpZGF0ZShuZXcgVWludDhBcnJheShbMCw5NywxMTUsMTA5LDEsMCwwLDAsMSw0LDEsOTYsMCwwLDMsMiwxLDAsNSw0LDEsMywxLDEsMTAsMTEsMSw5LDAsNjUsMCwyNTQsMTYsMiwwLDI2LDExXSkpKX1jYXRjaCh0KXtyZXR1cm4hMX19KSgpLG89YSYmKCgpPT57dHJ5e3JldHVybiBXZWJBc3NlbWJseS52YWxpZGF0ZShuZXcgVWludDhBcnJheShbMCw5NywxMTUsMTA5LDEsMCwwLDAsMSw0LDEsOTYsMCwwLDMsMiwxLDAsMTAsMzAsMSwyOCwwLDY1LDAsMjUzLDE1LDI1MywxMiwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDI1MywxODYsMSwyNiwxMV0pKX1jYXRjaCh0KXtyZXR1cm4hMX19KSgpLHk9XCJzdHJpbmdcIj09dHlwZW9mIHQud2FzbVBhdGhzP3Qud2FzbVBhdGhzOnZvaWQgMCxiPWQoITEsaSksbT1kKG8saSksZz1cIm9iamVjdFwiPT10eXBlb2YgdC53YXNtUGF0aHM/dC53YXNtUGF0aHNbbV06dm9pZCAwO2xldCB2PSExO2NvbnN0IHc9W107aWYoZT4wJiZ3LnB1c2gobmV3IFByb21pc2UoKHQ9PntzZXRUaW1lb3V0KCgoKT0+e3Y9ITAsdCgpfSksZSl9KSkpLHcucHVzaChuZXcgUHJvbWlzZSgoKHQsZSk9Pntjb25zdCByPWk/czpjLmRlZmF1bHQsYT17bG9jYXRlRmlsZToodCxlKT0+aSYmdC5lbmRzV2l0aChcIi53b3JrZXIuanNcIikmJlwidW5kZWZpbmVkXCIhPXR5cGVvZiBCbG9iP1VSTC5jcmVhdGVPYmplY3RVUkwobmV3IEJsb2IoW24oMTU0KV0se3R5cGU6XCJ0ZXh0L2phdmFzY3JpcHRcIn0pKTp0PT09Yj9udWxsIT1nP2c6KG51bGwhPXk/eTplKSttOmUrdH07aWYoaSlpZihcInVuZGVmaW5lZFwiPT10eXBlb2YgQmxvYilhLm1haW5TY3JpcHRVcmxPckJsb2I9dS5qb2luKFwiL1wiLFwib3J0LXdhc20tdGhyZWFkZWQuanNcIik7ZWxzZXtjb25zdCB0PWB2YXIgb3J0V2FzbVRocmVhZGVkPShmdW5jdGlvbigpe3ZhciBfc2NyaXB0RGlyO3JldHVybiAke3IudG9TdHJpbmcoKX19KSgpO2A7YS5tYWluU2NyaXB0VXJsT3JCbG9iPW5ldyBCbG9iKFt0XSx7dHlwZTpcInRleHQvamF2YXNjcmlwdFwifSl9cihhKS50aGVuKChlPT57cD0hMSxmPSEwLGw9ZSx0KCl9KSwodD0+e3A9ITEsaD0hMCxlKHQpfSkpfSkpKSxhd2FpdCBQcm9taXNlLnJhY2Uodyksdil0aHJvdyBuZXcgRXJyb3IoYFdlYkFzc2VtYmx5IGJhY2tlbmQgaW5pdGlhbGl6aW5nIGZhaWxlZCBkdWUgdG8gdGltZW91dDogJHtlfW1zYCl9LGUuZ2V0SW5zdGFuY2U9KCk9PntpZihmJiZsKXJldHVybiBsO3Rocm93IG5ldyBFcnJvcihcIldlYkFzc2VtYmx5IGlzIG5vdCBpbml0aWFsaXplZCB5ZXQuXCIpfSxlLmRpc3Bvc2U9KCk9Pnt2YXIgdDshZnx8cHx8aHx8KHA9ITAsbnVsbD09PSh0PWwuUFRocmVhZCl8fHZvaWQgMD09PXR8fHQudGVybWluYXRlQWxsVGhyZWFkcygpLGw9dm9pZCAwLHA9ITEsZj0hMSxoPSEwKX19LDE1NDp0PT57XCJ1c2Ugc3RyaWN0XCI7dC5leHBvcnRzPVxcJ1widXNlIHN0cmljdFwiO3ZhciBlPXt9LHQ9XCJvYmplY3RcIj09dHlwZW9mIHByb2Nlc3MmJlwib2JqZWN0XCI9PXR5cGVvZiBwcm9jZXNzLnZlcnNpb25zJiZcInN0cmluZ1wiPT10eXBlb2YgcHJvY2Vzcy52ZXJzaW9ucy5ub2RlO2lmKHQpe3ZhciByPXJlcXVpcmUoXCJ3b3JrZXJfdGhyZWFkc1wiKSxhPXIucGFyZW50UG9ydDthLm9uKFwibWVzc2FnZVwiLChlPT5vbm1lc3NhZ2Uoe2RhdGE6ZX0pKSk7dmFyIG89cmVxdWlyZShcImZzXCIpO09iamVjdC5hc3NpZ24oZ2xvYmFsLHtzZWxmOmdsb2JhbCxyZXF1aXJlOnJlcXVpcmUsTW9kdWxlOmUsbG9jYXRpb246e2hyZWY6X19maWxlbmFtZX0sV29ya2VyOnIuV29ya2VyLGltcG9ydFNjcmlwdHM6ZnVuY3Rpb24oZSl7KDAsZXZhbCkoby5yZWFkRmlsZVN5bmMoZSxcInV0ZjhcIikpfSxwb3N0TWVzc2FnZTpmdW5jdGlvbihlKXthLnBvc3RNZXNzYWdlKGUpfSxwZXJmb3JtYW5jZTpnbG9iYWwucGVyZm9ybWFuY2V8fHtub3c6ZnVuY3Rpb24oKXtyZXR1cm4gRGF0ZS5ub3coKX19fSl9dmFyIHM9ITEsbj1bXSxpPWZ1bmN0aW9uKCl7dmFyIGU9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKS5qb2luKFwiIFwiKTt0P28ud3JpdGVTeW5jKDIsZStcIlxcXFxcXFxcblwiKTpjb25zb2xlLmVycm9yKGUpfTtzZWxmLmFsZXJ0PWZ1bmN0aW9uKCl7dmFyIHQ9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKS5qb2luKFwiIFwiKTtwb3N0TWVzc2FnZSh7Y21kOlwiYWxlcnRcIix0ZXh0OnQsdGhyZWFkSWQ6ZS5fcHRocmVhZF9zZWxmKCl9KX0sZS5pbnN0YW50aWF0ZVdhc209KHQscik9Pnt2YXIgYT1uZXcgV2ViQXNzZW1ibHkuSW5zdGFuY2UoZS53YXNtTW9kdWxlLHQpO3JldHVybiByKGEpLGUud2FzbU1vZHVsZT1udWxsLGEuZXhwb3J0c30sc2VsZi5vbnVuaGFuZGxlZHJlamVjdGlvbj1lPT57dGhyb3cgZS5yZWFzb24/P2V9LHNlbGYub25tZXNzYWdlPXQ9Pnt0cnl7aWYoXCJsb2FkXCI9PT10LmRhdGEuY21kKXtpZihlLndhc21Nb2R1bGU9dC5kYXRhLndhc21Nb2R1bGUsZS53YXNtTWVtb3J5PXQuZGF0YS53YXNtTWVtb3J5LGUuYnVmZmVyPWUud2FzbU1lbW9yeS5idWZmZXIsZS5FTlZJUk9OTUVOVF9JU19QVEhSRUFEPSEwLFwic3RyaW5nXCI9PXR5cGVvZiB0LmRhdGEudXJsT3JCbG9iKWltcG9ydFNjcmlwdHModC5kYXRhLnVybE9yQmxvYik7ZWxzZXt2YXIgcj1VUkwuY3JlYXRlT2JqZWN0VVJMKHQuZGF0YS51cmxPckJsb2IpO2ltcG9ydFNjcmlwdHMociksVVJMLnJldm9rZU9iamVjdFVSTChyKX1vcnRXYXNtVGhyZWFkZWQoZSkudGhlbigoZnVuY3Rpb24odCl7ZT10fSkpfWVsc2UgaWYoXCJydW5cIj09PXQuZGF0YS5jbWQpe2UuX19wZXJmb3JtYW5jZV9ub3dfY2xvY2tfZHJpZnQ9cGVyZm9ybWFuY2Uubm93KCktdC5kYXRhLnRpbWUsZS5fX2Vtc2NyaXB0ZW5fdGhyZWFkX2luaXQodC5kYXRhLnB0aHJlYWRfcHRyLDAsMCwxKSxlLmVzdGFibGlzaFN0YWNrU3BhY2UoKSxlLlBUaHJlYWQucmVjZWl2ZU9iamVjdFRyYW5zZmVyKHQuZGF0YSksZS5QVGhyZWFkLnRocmVhZEluaXRUTFMoKSxzfHwobi5mb3JFYWNoKCh0PT57ZS5leGVjdXRlTm90aWZpZWRQcm94eWluZ1F1ZXVlKHQpfSkpLG49W10scz0hMCk7dHJ5e2UuaW52b2tlRW50cnlQb2ludCh0LmRhdGEuc3RhcnRfcm91dGluZSx0LmRhdGEuYXJnKX1jYXRjaCh0KXtpZihcInVud2luZFwiIT10KXtpZighKHQgaW5zdGFuY2VvZiBlLkV4aXRTdGF0dXMpKXRocm93IHQ7ZS5rZWVwUnVudGltZUFsaXZlKCl8fGUuX19lbXNjcmlwdGVuX3RocmVhZF9leGl0KHQuc3RhdHVzKX19fWVsc2VcImNhbmNlbFwiPT09dC5kYXRhLmNtZD9lLl9wdGhyZWFkX3NlbGYoKSYmZS5fX2Vtc2NyaXB0ZW5fdGhyZWFkX2V4aXQoLTEpOlwic2V0aW1tZWRpYXRlXCI9PT10LmRhdGEudGFyZ2V0fHwoXCJwcm9jZXNzUHJveHlpbmdRdWV1ZVwiPT09dC5kYXRhLmNtZD9zP2UuZXhlY3V0ZU5vdGlmaWVkUHJveHlpbmdRdWV1ZSh0LmRhdGEucXVldWUpOm4ucHVzaCh0LmRhdGEucXVldWUpOihpKFwid29ya2VyLmpzIHJlY2VpdmVkIHVua25vd24gY29tbWFuZCBcIit0LmRhdGEuY21kKSxpKHQuZGF0YSkpKX1jYXRjaCh0KXt0aHJvdyBpKFwid29ya2VyLmpzIG9ubWVzc2FnZSgpIGNhcHR1cmVkIGFuIHVuY2F1Z2h0IGV4Y2VwdGlvbjogXCIrdCksdCYmdC5zdGFjayYmaSh0LnN0YWNrKSxlLl9fZW1zY3JpcHRlbl90aHJlYWRfY3Jhc2hlZCYmZS5fX2Vtc2NyaXB0ZW5fdGhyZWFkX2NyYXNoZWQoKSx0fX07XFxcXG5cXCd9LDM4NDooKT0+e30sOTkzOigpPT57fSw5MDg6KCk9Pnt9LDk1MzooKT0+e30sOTI1OigpPT57fSw0NDk6KCk9Pnt9fSxlPXt9O2Z1bmN0aW9uIG4ocil7dmFyIGE9ZVtyXTtpZih2b2lkIDAhPT1hKXJldHVybiBhLmV4cG9ydHM7dmFyIGk9ZVtyXT17ZXhwb3J0czp7fX07cmV0dXJuIHRbcl0uY2FsbChpLmV4cG9ydHMsaSxpLmV4cG9ydHMsbiksaS5leHBvcnRzfW4uZz1mdW5jdGlvbigpe2lmKFwib2JqZWN0XCI9PXR5cGVvZiBnbG9iYWxUaGlzKXJldHVybiBnbG9iYWxUaGlzO3RyeXtyZXR1cm4gdGhpc3x8bmV3IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKX1jYXRjaCh0KXtpZihcIm9iamVjdFwiPT10eXBlb2Ygd2luZG93KXJldHVybiB3aW5kb3d9fSgpLCgoKT0+e1widXNlIHN0cmljdFwiO2NvbnN0IHQ9bigzNDkpLGU9bigzNjEpO3NlbGYub25tZXNzYWdlPW49Pntzd2l0Y2gobi5kYXRhLnR5cGUpe2Nhc2VcImluaXQtd2FzbVwiOigwLGUuaW5pdGlhbGl6ZVdlYkFzc2VtYmx5KShuLmRhdGEuaW4pLnRoZW4oKCgpPT5wb3N0TWVzc2FnZSh7dHlwZTpcImluaXQtd2FzbVwifSkpLCh0PT5wb3N0TWVzc2FnZSh7dHlwZTpcImluaXQtd2FzbVwiLGVycjp0fSkpKTticmVhaztjYXNlXCJpbml0LW9ydFwiOnRyeXtjb25zdHtudW1UaHJlYWRzOmUsbG9nZ2luZ0xldmVsOnJ9PW4uZGF0YS5pbjsoMCx0LmluaXRPcnQpKGUscikscG9zdE1lc3NhZ2Uoe3R5cGU6XCJpbml0LW9ydFwifSl9Y2F0Y2godCl7cG9zdE1lc3NhZ2Uoe3R5cGU6XCJpbml0LW9ydFwiLGVycjp0fSl9YnJlYWs7Y2FzZVwiY3JlYXRlX2FsbG9jYXRlXCI6dHJ5e2NvbnN0e21vZGVsOmV9PW4uZGF0YS5pbixyPSgwLHQuY3JlYXRlU2Vzc2lvbkFsbG9jYXRlKShlKTtwb3N0TWVzc2FnZSh7dHlwZTpcImNyZWF0ZV9hbGxvY2F0ZVwiLG91dDpyfSl9Y2F0Y2godCl7cG9zdE1lc3NhZ2Uoe3R5cGU6XCJjcmVhdGVfYWxsb2NhdGVcIixlcnI6dH0pfWJyZWFrO2Nhc2VcImNyZWF0ZV9maW5hbGl6ZVwiOnRyeXtjb25zdHttb2RlbGRhdGE6ZSxvcHRpb25zOnJ9PW4uZGF0YS5pbixhPSgwLHQuY3JlYXRlU2Vzc2lvbkZpbmFsaXplKShlLHIpO3Bvc3RNZXNzYWdlKHt0eXBlOlwiY3JlYXRlX2ZpbmFsaXplXCIsb3V0OmF9KX1jYXRjaCh0KXtwb3N0TWVzc2FnZSh7dHlwZTpcImNyZWF0ZV9maW5hbGl6ZVwiLGVycjp0fSl9YnJlYWs7Y2FzZVwiY3JlYXRlXCI6dHJ5e2NvbnN0e21vZGVsOmUsb3B0aW9uczpyfT1uLmRhdGEuaW4sYT0oMCx0LmNyZWF0ZVNlc3Npb24pKGUscik7cG9zdE1lc3NhZ2Uoe3R5cGU6XCJjcmVhdGVcIixvdXQ6YX0pfWNhdGNoKHQpe3Bvc3RNZXNzYWdlKHt0eXBlOlwiY3JlYXRlXCIsZXJyOnR9KX1icmVhaztjYXNlXCJyZWxlYXNlXCI6dHJ5e2NvbnN0IGU9bi5kYXRhLmluOygwLHQucmVsZWFzZVNlc3Npb24pKGUpLHBvc3RNZXNzYWdlKHt0eXBlOlwicmVsZWFzZVwifSl9Y2F0Y2godCl7cG9zdE1lc3NhZ2Uoe3R5cGU6XCJyZWxlYXNlXCIsZXJyOnR9KX1icmVhaztjYXNlXCJydW5cIjp0cnl7Y29uc3R7c2Vzc2lvbklkOmUsaW5wdXRJbmRpY2VzOnIsaW5wdXRzOmEsb3V0cHV0SW5kaWNlczppLG9wdGlvbnM6b309bi5kYXRhLmluLHU9KDAsdC5ydW4pKGUscixhLGksbyk7cG9zdE1lc3NhZ2Uoe3R5cGU6XCJydW5cIixvdXQ6dX0sKDAsdC5leHRyYWN0VHJhbnNmZXJhYmxlQnVmZmVycykodSkpfWNhdGNoKHQpe3Bvc3RNZXNzYWdlKHt0eXBlOlwicnVuXCIsZXJyOnR9KX1icmVhaztjYXNlXCJlbmQtcHJvZmlsaW5nXCI6dHJ5e2NvbnN0IGU9bi5kYXRhLmluOygwLHQuZW5kUHJvZmlsaW5nKShlKSxwb3N0TWVzc2FnZSh7dHlwZTpcImVuZC1wcm9maWxpbmdcIn0pfWNhdGNoKHQpe3Bvc3RNZXNzYWdlKHt0eXBlOlwiZW5kLXByb2ZpbGluZ1wiLGVycjp0fSl9fX19KSgpfSkoKTtcXG4nLFwiV29ya2VyXCIsdm9pZCAwLHZvaWQgMCl9fSw0Nzc6dD0+e1widXNlIHN0cmljdFwiO3QuZXhwb3J0cz1mdW5jdGlvbih0LGUsbixyKXt2YXIgaT1zZWxmfHx3aW5kb3c7dHJ5e3RyeXt2YXIgbzt0cnl7bz1uZXcgaS5CbG9iKFt0XSl9Y2F0Y2goZSl7KG89bmV3KGkuQmxvYkJ1aWxkZXJ8fGkuV2ViS2l0QmxvYkJ1aWxkZXJ8fGkuTW96QmxvYkJ1aWxkZXJ8fGkuTVNCbG9iQnVpbGRlcikpLmFwcGVuZCh0KSxvPW8uZ2V0QmxvYigpfXZhciBhPWkuVVJMfHxpLndlYmtpdFVSTCxzPWEuY3JlYXRlT2JqZWN0VVJMKG8pLHU9bmV3IGlbZV0ocyxuKTtyZXR1cm4gYS5yZXZva2VPYmplY3RVUkwocyksdX1jYXRjaChyKXtyZXR1cm4gbmV3IGlbZV0oXCJkYXRhOmFwcGxpY2F0aW9uL2phdmFzY3JpcHQsXCIuY29uY2F0KGVuY29kZVVSSUNvbXBvbmVudCh0KSksbil9fWNhdGNoKHQpe2lmKCFyKXRocm93IEVycm9yKFwiSW5saW5lIHdvcmtlciBpcyBub3Qgc3VwcG9ydGVkXCIpO3JldHVybiBuZXcgaVtlXShyLG4pfX19LDQxNTQ6dD0+e1widXNlIHN0cmljdFwiO3QuZXhwb3J0cz0nXCJ1c2Ugc3RyaWN0XCI7dmFyIGU9e30sdD1cIm9iamVjdFwiPT10eXBlb2YgcHJvY2VzcyYmXCJvYmplY3RcIj09dHlwZW9mIHByb2Nlc3MudmVyc2lvbnMmJlwic3RyaW5nXCI9PXR5cGVvZiBwcm9jZXNzLnZlcnNpb25zLm5vZGU7aWYodCl7dmFyIHI9cmVxdWlyZShcIndvcmtlcl90aHJlYWRzXCIpLGE9ci5wYXJlbnRQb3J0O2Eub24oXCJtZXNzYWdlXCIsKGU9Pm9ubWVzc2FnZSh7ZGF0YTplfSkpKTt2YXIgbz1yZXF1aXJlKFwiZnNcIik7T2JqZWN0LmFzc2lnbihnbG9iYWwse3NlbGY6Z2xvYmFsLHJlcXVpcmU6cmVxdWlyZSxNb2R1bGU6ZSxsb2NhdGlvbjp7aHJlZjpfX2ZpbGVuYW1lfSxXb3JrZXI6ci5Xb3JrZXIsaW1wb3J0U2NyaXB0czpmdW5jdGlvbihlKXsoMCxldmFsKShvLnJlYWRGaWxlU3luYyhlLFwidXRmOFwiKSl9LHBvc3RNZXNzYWdlOmZ1bmN0aW9uKGUpe2EucG9zdE1lc3NhZ2UoZSl9LHBlcmZvcm1hbmNlOmdsb2JhbC5wZXJmb3JtYW5jZXx8e25vdzpmdW5jdGlvbigpe3JldHVybiBEYXRlLm5vdygpfX19KX12YXIgcz0hMSxuPVtdLGk9ZnVuY3Rpb24oKXt2YXIgZT1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpLmpvaW4oXCIgXCIpO3Q/by53cml0ZVN5bmMoMixlK1wiXFxcXG5cIik6Y29uc29sZS5lcnJvcihlKX07c2VsZi5hbGVydD1mdW5jdGlvbigpe3ZhciB0PUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykuam9pbihcIiBcIik7cG9zdE1lc3NhZ2Uoe2NtZDpcImFsZXJ0XCIsdGV4dDp0LHRocmVhZElkOmUuX3B0aHJlYWRfc2VsZigpfSl9LGUuaW5zdGFudGlhdGVXYXNtPSh0LHIpPT57dmFyIGE9bmV3IFdlYkFzc2VtYmx5Lkluc3RhbmNlKGUud2FzbU1vZHVsZSx0KTtyZXR1cm4gcihhKSxlLndhc21Nb2R1bGU9bnVsbCxhLmV4cG9ydHN9LHNlbGYub251bmhhbmRsZWRyZWplY3Rpb249ZT0+e3Rocm93IGUucmVhc29uPz9lfSxzZWxmLm9ubWVzc2FnZT10PT57dHJ5e2lmKFwibG9hZFwiPT09dC5kYXRhLmNtZCl7aWYoZS53YXNtTW9kdWxlPXQuZGF0YS53YXNtTW9kdWxlLGUud2FzbU1lbW9yeT10LmRhdGEud2FzbU1lbW9yeSxlLmJ1ZmZlcj1lLndhc21NZW1vcnkuYnVmZmVyLGUuRU5WSVJPTk1FTlRfSVNfUFRIUkVBRD0hMCxcInN0cmluZ1wiPT10eXBlb2YgdC5kYXRhLnVybE9yQmxvYilpbXBvcnRTY3JpcHRzKHQuZGF0YS51cmxPckJsb2IpO2Vsc2V7dmFyIHI9VVJMLmNyZWF0ZU9iamVjdFVSTCh0LmRhdGEudXJsT3JCbG9iKTtpbXBvcnRTY3JpcHRzKHIpLFVSTC5yZXZva2VPYmplY3RVUkwocil9b3J0V2FzbVRocmVhZGVkKGUpLnRoZW4oKGZ1bmN0aW9uKHQpe2U9dH0pKX1lbHNlIGlmKFwicnVuXCI9PT10LmRhdGEuY21kKXtlLl9fcGVyZm9ybWFuY2Vfbm93X2Nsb2NrX2RyaWZ0PXBlcmZvcm1hbmNlLm5vdygpLXQuZGF0YS50aW1lLGUuX19lbXNjcmlwdGVuX3RocmVhZF9pbml0KHQuZGF0YS5wdGhyZWFkX3B0ciwwLDAsMSksZS5lc3RhYmxpc2hTdGFja1NwYWNlKCksZS5QVGhyZWFkLnJlY2VpdmVPYmplY3RUcmFuc2Zlcih0LmRhdGEpLGUuUFRocmVhZC50aHJlYWRJbml0VExTKCksc3x8KG4uZm9yRWFjaCgodD0+e2UuZXhlY3V0ZU5vdGlmaWVkUHJveHlpbmdRdWV1ZSh0KX0pKSxuPVtdLHM9ITApO3RyeXtlLmludm9rZUVudHJ5UG9pbnQodC5kYXRhLnN0YXJ0X3JvdXRpbmUsdC5kYXRhLmFyZyl9Y2F0Y2godCl7aWYoXCJ1bndpbmRcIiE9dCl7aWYoISh0IGluc3RhbmNlb2YgZS5FeGl0U3RhdHVzKSl0aHJvdyB0O2Uua2VlcFJ1bnRpbWVBbGl2ZSgpfHxlLl9fZW1zY3JpcHRlbl90aHJlYWRfZXhpdCh0LnN0YXR1cyl9fX1lbHNlXCJjYW5jZWxcIj09PXQuZGF0YS5jbWQ/ZS5fcHRocmVhZF9zZWxmKCkmJmUuX19lbXNjcmlwdGVuX3RocmVhZF9leGl0KC0xKTpcInNldGltbWVkaWF0ZVwiPT09dC5kYXRhLnRhcmdldHx8KFwicHJvY2Vzc1Byb3h5aW5nUXVldWVcIj09PXQuZGF0YS5jbWQ/cz9lLmV4ZWN1dGVOb3RpZmllZFByb3h5aW5nUXVldWUodC5kYXRhLnF1ZXVlKTpuLnB1c2godC5kYXRhLnF1ZXVlKTooaShcIndvcmtlci5qcyByZWNlaXZlZCB1bmtub3duIGNvbW1hbmQgXCIrdC5kYXRhLmNtZCksaSh0LmRhdGEpKSl9Y2F0Y2godCl7dGhyb3cgaShcIndvcmtlci5qcyBvbm1lc3NhZ2UoKSBjYXB0dXJlZCBhbiB1bmNhdWdodCBleGNlcHRpb246IFwiK3QpLHQmJnQuc3RhY2smJmkodC5zdGFjayksZS5fX2Vtc2NyaXB0ZW5fdGhyZWFkX2NyYXNoZWQmJmUuX19lbXNjcmlwdGVuX3RocmVhZF9jcmFzaGVkKCksdH19O1xcbid9LDE2NzA6dD0+e1widXNlIHN0cmljdFwiO3QuZXhwb3J0cz1fX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX18xNjcwX199LDcwNjc6KCk9Pnt9LDEyOTY6KCk9Pnt9LDEzODQ6KCk9Pnt9LDM5OTM6KCk9Pnt9LDkwODooKT0+e30sNjk1MzooKT0+e30sOTkyNTooKT0+e30sMjgwNjooKT0+e30sNjQ0OTooKT0+e30sMjg1MDooKT0+e30sNTM4MTooKT0+e30sNTY4NjoodCxlLG4pPT57XCJ1c2Ugc3RyaWN0XCI7bi5yKGUpLG4uZChlLHtmbGF0YnVmZmVyczooKT0+cn0pO3ZhciByPXt9O3IuT2Zmc2V0LHIuVGFibGUsci5TSVpFT0ZfU0hPUlQ9MixyLlNJWkVPRl9JTlQ9NCxyLkZJTEVfSURFTlRJRklFUl9MRU5HVEg9NCxyLlNJWkVfUFJFRklYX0xFTkdUSD00LHIuRW5jb2Rpbmc9e1VURjhfQllURVM6MSxVVEYxNl9TVFJJTkc6Mn0sci5pbnQzMj1uZXcgSW50MzJBcnJheSgyKSxyLmZsb2F0MzI9bmV3IEZsb2F0MzJBcnJheShyLmludDMyLmJ1ZmZlciksci5mbG9hdDY0PW5ldyBGbG9hdDY0QXJyYXkoci5pbnQzMi5idWZmZXIpLHIuaXNMaXR0bGVFbmRpYW49MT09PW5ldyBVaW50MTZBcnJheShuZXcgVWludDhBcnJheShbMSwwXSkuYnVmZmVyKVswXSxyLkxvbmc9ZnVuY3Rpb24odCxlKXt0aGlzLmxvdz0wfHQsdGhpcy5oaWdoPTB8ZX0sci5Mb25nLmNyZWF0ZT1mdW5jdGlvbih0LGUpe3JldHVybiAwPT10JiYwPT1lP3IuTG9uZy5aRVJPOm5ldyByLkxvbmcodCxlKX0sci5Mb25nLnByb3RvdHlwZS50b0Zsb2F0NjQ9ZnVuY3Rpb24oKXtyZXR1cm4odGhpcy5sb3c+Pj4wKSs0Mjk0OTY3Mjk2KnRoaXMuaGlnaH0sci5Mb25nLnByb3RvdHlwZS5lcXVhbHM9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMubG93PT10LmxvdyYmdGhpcy5oaWdoPT10LmhpZ2h9LHIuTG9uZy5aRVJPPW5ldyByLkxvbmcoMCwwKSxyLkJ1aWxkZXI9ZnVuY3Rpb24odCl7aWYodCllPXQ7ZWxzZSB2YXIgZT0xMDI0O3RoaXMuYmI9ci5CeXRlQnVmZmVyLmFsbG9jYXRlKGUpLHRoaXMuc3BhY2U9ZSx0aGlzLm1pbmFsaWduPTEsdGhpcy52dGFibGU9bnVsbCx0aGlzLnZ0YWJsZV9pbl91c2U9MCx0aGlzLmlzTmVzdGVkPSExLHRoaXMub2JqZWN0X3N0YXJ0PTAsdGhpcy52dGFibGVzPVtdLHRoaXMudmVjdG9yX251bV9lbGVtcz0wLHRoaXMuZm9yY2VfZGVmYXVsdHM9ITF9LHIuQnVpbGRlci5wcm90b3R5cGUuY2xlYXI9ZnVuY3Rpb24oKXt0aGlzLmJiLmNsZWFyKCksdGhpcy5zcGFjZT10aGlzLmJiLmNhcGFjaXR5KCksdGhpcy5taW5hbGlnbj0xLHRoaXMudnRhYmxlPW51bGwsdGhpcy52dGFibGVfaW5fdXNlPTAsdGhpcy5pc05lc3RlZD0hMSx0aGlzLm9iamVjdF9zdGFydD0wLHRoaXMudnRhYmxlcz1bXSx0aGlzLnZlY3Rvcl9udW1fZWxlbXM9MCx0aGlzLmZvcmNlX2RlZmF1bHRzPSExfSxyLkJ1aWxkZXIucHJvdG90eXBlLmZvcmNlRGVmYXVsdHM9ZnVuY3Rpb24odCl7dGhpcy5mb3JjZV9kZWZhdWx0cz10fSxyLkJ1aWxkZXIucHJvdG90eXBlLmRhdGFCdWZmZXI9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5iYn0sci5CdWlsZGVyLnByb3RvdHlwZS5hc1VpbnQ4QXJyYXk9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5iYi5ieXRlcygpLnN1YmFycmF5KHRoaXMuYmIucG9zaXRpb24oKSx0aGlzLmJiLnBvc2l0aW9uKCkrdGhpcy5vZmZzZXQoKSl9LHIuQnVpbGRlci5wcm90b3R5cGUucHJlcD1mdW5jdGlvbih0LGUpe3Q+dGhpcy5taW5hbGlnbiYmKHRoaXMubWluYWxpZ249dCk7Zm9yKHZhciBuPTErfih0aGlzLmJiLmNhcGFjaXR5KCktdGhpcy5zcGFjZStlKSZ0LTE7dGhpcy5zcGFjZTxuK3QrZTspe3ZhciBpPXRoaXMuYmIuY2FwYWNpdHkoKTt0aGlzLmJiPXIuQnVpbGRlci5ncm93Qnl0ZUJ1ZmZlcih0aGlzLmJiKSx0aGlzLnNwYWNlKz10aGlzLmJiLmNhcGFjaXR5KCktaX10aGlzLnBhZChuKX0sci5CdWlsZGVyLnByb3RvdHlwZS5wYWQ9ZnVuY3Rpb24odCl7Zm9yKHZhciBlPTA7ZTx0O2UrKyl0aGlzLmJiLndyaXRlSW50OCgtLXRoaXMuc3BhY2UsMCl9LHIuQnVpbGRlci5wcm90b3R5cGUud3JpdGVJbnQ4PWZ1bmN0aW9uKHQpe3RoaXMuYmIud3JpdGVJbnQ4KHRoaXMuc3BhY2UtPTEsdCl9LHIuQnVpbGRlci5wcm90b3R5cGUud3JpdGVJbnQxNj1mdW5jdGlvbih0KXt0aGlzLmJiLndyaXRlSW50MTYodGhpcy5zcGFjZS09Mix0KX0sci5CdWlsZGVyLnByb3RvdHlwZS53cml0ZUludDMyPWZ1bmN0aW9uKHQpe3RoaXMuYmIud3JpdGVJbnQzMih0aGlzLnNwYWNlLT00LHQpfSxyLkJ1aWxkZXIucHJvdG90eXBlLndyaXRlSW50NjQ9ZnVuY3Rpb24odCl7dGhpcy5iYi53cml0ZUludDY0KHRoaXMuc3BhY2UtPTgsdCl9LHIuQnVpbGRlci5wcm90b3R5cGUud3JpdGVGbG9hdDMyPWZ1bmN0aW9uKHQpe3RoaXMuYmIud3JpdGVGbG9hdDMyKHRoaXMuc3BhY2UtPTQsdCl9LHIuQnVpbGRlci5wcm90b3R5cGUud3JpdGVGbG9hdDY0PWZ1bmN0aW9uKHQpe3RoaXMuYmIud3JpdGVGbG9hdDY0KHRoaXMuc3BhY2UtPTgsdCl9LHIuQnVpbGRlci5wcm90b3R5cGUuYWRkSW50OD1mdW5jdGlvbih0KXt0aGlzLnByZXAoMSwwKSx0aGlzLndyaXRlSW50OCh0KX0sci5CdWlsZGVyLnByb3RvdHlwZS5hZGRJbnQxNj1mdW5jdGlvbih0KXt0aGlzLnByZXAoMiwwKSx0aGlzLndyaXRlSW50MTYodCl9LHIuQnVpbGRlci5wcm90b3R5cGUuYWRkSW50MzI9ZnVuY3Rpb24odCl7dGhpcy5wcmVwKDQsMCksdGhpcy53cml0ZUludDMyKHQpfSxyLkJ1aWxkZXIucHJvdG90eXBlLmFkZEludDY0PWZ1bmN0aW9uKHQpe3RoaXMucHJlcCg4LDApLHRoaXMud3JpdGVJbnQ2NCh0KX0sci5CdWlsZGVyLnByb3RvdHlwZS5hZGRGbG9hdDMyPWZ1bmN0aW9uKHQpe3RoaXMucHJlcCg0LDApLHRoaXMud3JpdGVGbG9hdDMyKHQpfSxyLkJ1aWxkZXIucHJvdG90eXBlLmFkZEZsb2F0NjQ9ZnVuY3Rpb24odCl7dGhpcy5wcmVwKDgsMCksdGhpcy53cml0ZUZsb2F0NjQodCl9LHIuQnVpbGRlci5wcm90b3R5cGUuYWRkRmllbGRJbnQ4PWZ1bmN0aW9uKHQsZSxuKXsodGhpcy5mb3JjZV9kZWZhdWx0c3x8ZSE9bikmJih0aGlzLmFkZEludDgoZSksdGhpcy5zbG90KHQpKX0sci5CdWlsZGVyLnByb3RvdHlwZS5hZGRGaWVsZEludDE2PWZ1bmN0aW9uKHQsZSxuKXsodGhpcy5mb3JjZV9kZWZhdWx0c3x8ZSE9bikmJih0aGlzLmFkZEludDE2KGUpLHRoaXMuc2xvdCh0KSl9LHIuQnVpbGRlci5wcm90b3R5cGUuYWRkRmllbGRJbnQzMj1mdW5jdGlvbih0LGUsbil7KHRoaXMuZm9yY2VfZGVmYXVsdHN8fGUhPW4pJiYodGhpcy5hZGRJbnQzMihlKSx0aGlzLnNsb3QodCkpfSxyLkJ1aWxkZXIucHJvdG90eXBlLmFkZEZpZWxkSW50NjQ9ZnVuY3Rpb24odCxlLG4peyF0aGlzLmZvcmNlX2RlZmF1bHRzJiZlLmVxdWFscyhuKXx8KHRoaXMuYWRkSW50NjQoZSksdGhpcy5zbG90KHQpKX0sci5CdWlsZGVyLnByb3RvdHlwZS5hZGRGaWVsZEZsb2F0MzI9ZnVuY3Rpb24odCxlLG4peyh0aGlzLmZvcmNlX2RlZmF1bHRzfHxlIT1uKSYmKHRoaXMuYWRkRmxvYXQzMihlKSx0aGlzLnNsb3QodCkpfSxyLkJ1aWxkZXIucHJvdG90eXBlLmFkZEZpZWxkRmxvYXQ2ND1mdW5jdGlvbih0LGUsbil7KHRoaXMuZm9yY2VfZGVmYXVsdHN8fGUhPW4pJiYodGhpcy5hZGRGbG9hdDY0KGUpLHRoaXMuc2xvdCh0KSl9LHIuQnVpbGRlci5wcm90b3R5cGUuYWRkRmllbGRPZmZzZXQ9ZnVuY3Rpb24odCxlLG4peyh0aGlzLmZvcmNlX2RlZmF1bHRzfHxlIT1uKSYmKHRoaXMuYWRkT2Zmc2V0KGUpLHRoaXMuc2xvdCh0KSl9LHIuQnVpbGRlci5wcm90b3R5cGUuYWRkRmllbGRTdHJ1Y3Q9ZnVuY3Rpb24odCxlLG4pe2UhPW4mJih0aGlzLm5lc3RlZChlKSx0aGlzLnNsb3QodCkpfSxyLkJ1aWxkZXIucHJvdG90eXBlLm5lc3RlZD1mdW5jdGlvbih0KXtpZih0IT10aGlzLm9mZnNldCgpKXRocm93IG5ldyBFcnJvcihcIkZsYXRCdWZmZXJzOiBzdHJ1Y3QgbXVzdCBiZSBzZXJpYWxpemVkIGlubGluZS5cIil9LHIuQnVpbGRlci5wcm90b3R5cGUubm90TmVzdGVkPWZ1bmN0aW9uKCl7aWYodGhpcy5pc05lc3RlZCl0aHJvdyBuZXcgRXJyb3IoXCJGbGF0QnVmZmVyczogb2JqZWN0IHNlcmlhbGl6YXRpb24gbXVzdCBub3QgYmUgbmVzdGVkLlwiKX0sci5CdWlsZGVyLnByb3RvdHlwZS5zbG90PWZ1bmN0aW9uKHQpe3RoaXMudnRhYmxlW3RdPXRoaXMub2Zmc2V0KCl9LHIuQnVpbGRlci5wcm90b3R5cGUub2Zmc2V0PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuYmIuY2FwYWNpdHkoKS10aGlzLnNwYWNlfSxyLkJ1aWxkZXIuZ3Jvd0J5dGVCdWZmZXI9ZnVuY3Rpb24odCl7dmFyIGU9dC5jYXBhY2l0eSgpO2lmKDMyMjEyMjU0NzImZSl0aHJvdyBuZXcgRXJyb3IoXCJGbGF0QnVmZmVyczogY2Fubm90IGdyb3cgYnVmZmVyIGJleW9uZCAyIGdpZ2FieXRlcy5cIik7dmFyIG49ZTw8MSxpPXIuQnl0ZUJ1ZmZlci5hbGxvY2F0ZShuKTtyZXR1cm4gaS5zZXRQb3NpdGlvbihuLWUpLGkuYnl0ZXMoKS5zZXQodC5ieXRlcygpLG4tZSksaX0sci5CdWlsZGVyLnByb3RvdHlwZS5hZGRPZmZzZXQ9ZnVuY3Rpb24odCl7dGhpcy5wcmVwKHIuU0laRU9GX0lOVCwwKSx0aGlzLndyaXRlSW50MzIodGhpcy5vZmZzZXQoKS10K3IuU0laRU9GX0lOVCl9LHIuQnVpbGRlci5wcm90b3R5cGUuc3RhcnRPYmplY3Q9ZnVuY3Rpb24odCl7dGhpcy5ub3ROZXN0ZWQoKSxudWxsPT10aGlzLnZ0YWJsZSYmKHRoaXMudnRhYmxlPVtdKSx0aGlzLnZ0YWJsZV9pbl91c2U9dDtmb3IodmFyIGU9MDtlPHQ7ZSsrKXRoaXMudnRhYmxlW2VdPTA7dGhpcy5pc05lc3RlZD0hMCx0aGlzLm9iamVjdF9zdGFydD10aGlzLm9mZnNldCgpfSxyLkJ1aWxkZXIucHJvdG90eXBlLmVuZE9iamVjdD1mdW5jdGlvbigpe2lmKG51bGw9PXRoaXMudnRhYmxlfHwhdGhpcy5pc05lc3RlZCl0aHJvdyBuZXcgRXJyb3IoXCJGbGF0QnVmZmVyczogZW5kT2JqZWN0IGNhbGxlZCB3aXRob3V0IHN0YXJ0T2JqZWN0XCIpO3RoaXMuYWRkSW50MzIoMCk7Zm9yKHZhciB0PXRoaXMub2Zmc2V0KCksZT10aGlzLnZ0YWJsZV9pbl91c2UtMTtlPj0wJiYwPT10aGlzLnZ0YWJsZVtlXTtlLS0pO2Zvcih2YXIgbj1lKzE7ZT49MDtlLS0pdGhpcy5hZGRJbnQxNigwIT10aGlzLnZ0YWJsZVtlXT90LXRoaXMudnRhYmxlW2VdOjApO3RoaXMuYWRkSW50MTYodC10aGlzLm9iamVjdF9zdGFydCk7dmFyIGk9KG4rMikqci5TSVpFT0ZfU0hPUlQ7dGhpcy5hZGRJbnQxNihpKTt2YXIgbz0wLGE9dGhpcy5zcGFjZTt0OmZvcihlPTA7ZTx0aGlzLnZ0YWJsZXMubGVuZ3RoO2UrKyl7dmFyIHM9dGhpcy5iYi5jYXBhY2l0eSgpLXRoaXMudnRhYmxlc1tlXTtpZihpPT10aGlzLmJiLnJlYWRJbnQxNihzKSl7Zm9yKHZhciB1PXIuU0laRU9GX1NIT1JUO3U8aTt1Kz1yLlNJWkVPRl9TSE9SVClpZih0aGlzLmJiLnJlYWRJbnQxNihhK3UpIT10aGlzLmJiLnJlYWRJbnQxNihzK3UpKWNvbnRpbnVlIHQ7bz10aGlzLnZ0YWJsZXNbZV07YnJlYWt9fXJldHVybiBvPyh0aGlzLnNwYWNlPXRoaXMuYmIuY2FwYWNpdHkoKS10LHRoaXMuYmIud3JpdGVJbnQzMih0aGlzLnNwYWNlLG8tdCkpOih0aGlzLnZ0YWJsZXMucHVzaCh0aGlzLm9mZnNldCgpKSx0aGlzLmJiLndyaXRlSW50MzIodGhpcy5iYi5jYXBhY2l0eSgpLXQsdGhpcy5vZmZzZXQoKS10KSksdGhpcy5pc05lc3RlZD0hMSx0fSxyLkJ1aWxkZXIucHJvdG90eXBlLmZpbmlzaD1mdW5jdGlvbih0LGUsbil7dmFyIGk9bj9yLlNJWkVfUFJFRklYX0xFTkdUSDowO2lmKGUpe3ZhciBvPWU7aWYodGhpcy5wcmVwKHRoaXMubWluYWxpZ24sci5TSVpFT0ZfSU5UK3IuRklMRV9JREVOVElGSUVSX0xFTkdUSCtpKSxvLmxlbmd0aCE9ci5GSUxFX0lERU5USUZJRVJfTEVOR1RIKXRocm93IG5ldyBFcnJvcihcIkZsYXRCdWZmZXJzOiBmaWxlIGlkZW50aWZpZXIgbXVzdCBiZSBsZW5ndGggXCIrci5GSUxFX0lERU5USUZJRVJfTEVOR1RIKTtmb3IodmFyIGE9ci5GSUxFX0lERU5USUZJRVJfTEVOR1RILTE7YT49MDthLS0pdGhpcy53cml0ZUludDgoby5jaGFyQ29kZUF0KGEpKX10aGlzLnByZXAodGhpcy5taW5hbGlnbixyLlNJWkVPRl9JTlQraSksdGhpcy5hZGRPZmZzZXQodCksaSYmdGhpcy5hZGRJbnQzMih0aGlzLmJiLmNhcGFjaXR5KCktdGhpcy5zcGFjZSksdGhpcy5iYi5zZXRQb3NpdGlvbih0aGlzLnNwYWNlKX0sci5CdWlsZGVyLnByb3RvdHlwZS5maW5pc2hTaXplUHJlZml4ZWQ9ZnVuY3Rpb24odCxlKXt0aGlzLmZpbmlzaCh0LGUsITApfSxyLkJ1aWxkZXIucHJvdG90eXBlLnJlcXVpcmVkRmllbGQ9ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzLmJiLmNhcGFjaXR5KCktdCxyPW4tdGhpcy5iYi5yZWFkSW50MzIobik7aWYoMD09dGhpcy5iYi5yZWFkSW50MTYocitlKSl0aHJvdyBuZXcgRXJyb3IoXCJGbGF0QnVmZmVyczogZmllbGQgXCIrZStcIiBtdXN0IGJlIHNldFwiKX0sci5CdWlsZGVyLnByb3RvdHlwZS5zdGFydFZlY3Rvcj1mdW5jdGlvbih0LGUsbil7dGhpcy5ub3ROZXN0ZWQoKSx0aGlzLnZlY3Rvcl9udW1fZWxlbXM9ZSx0aGlzLnByZXAoci5TSVpFT0ZfSU5ULHQqZSksdGhpcy5wcmVwKG4sdCplKX0sci5CdWlsZGVyLnByb3RvdHlwZS5lbmRWZWN0b3I9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy53cml0ZUludDMyKHRoaXMudmVjdG9yX251bV9lbGVtcyksdGhpcy5vZmZzZXQoKX0sci5CdWlsZGVyLnByb3RvdHlwZS5jcmVhdGVTdHJpbmc9ZnVuY3Rpb24odCl7aWYodCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpdmFyIGU9dDtlbHNle2U9W107Zm9yKHZhciBuPTA7bjx0Lmxlbmd0aDspe3ZhciByLGk9dC5jaGFyQ29kZUF0KG4rKyk7KHI9aTw1NTI5Nnx8aT49NTYzMjA/aTooaTw8MTApK3QuY2hhckNvZGVBdChuKyspKy01NjYxMzg4OCk8MTI4P2UucHVzaChyKToocjwyMDQ4P2UucHVzaChyPj42JjMxfDE5Mik6KHI8NjU1MzY/ZS5wdXNoKHI+PjEyJjE1fDIyNCk6ZS5wdXNoKHI+PjE4Jjd8MjQwLHI+PjEyJjYzfDEyOCksZS5wdXNoKHI+PjYmNjN8MTI4KSksZS5wdXNoKDYzJnJ8MTI4KSl9fXRoaXMuYWRkSW50OCgwKSx0aGlzLnN0YXJ0VmVjdG9yKDEsZS5sZW5ndGgsMSksdGhpcy5iYi5zZXRQb3NpdGlvbih0aGlzLnNwYWNlLT1lLmxlbmd0aCksbj0wO2Zvcih2YXIgbz10aGlzLnNwYWNlLGE9dGhpcy5iYi5ieXRlcygpO248ZS5sZW5ndGg7bisrKWFbbysrXT1lW25dO3JldHVybiB0aGlzLmVuZFZlY3RvcigpfSxyLkJ1aWxkZXIucHJvdG90eXBlLmNyZWF0ZUxvbmc9ZnVuY3Rpb24odCxlKXtyZXR1cm4gci5Mb25nLmNyZWF0ZSh0LGUpfSxyLkJ5dGVCdWZmZXI9ZnVuY3Rpb24odCl7dGhpcy5ieXRlc189dCx0aGlzLnBvc2l0aW9uXz0wfSxyLkJ5dGVCdWZmZXIuYWxsb2NhdGU9ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyByLkJ5dGVCdWZmZXIobmV3IFVpbnQ4QXJyYXkodCkpfSxyLkJ5dGVCdWZmZXIucHJvdG90eXBlLmNsZWFyPWZ1bmN0aW9uKCl7dGhpcy5wb3NpdGlvbl89MH0sci5CeXRlQnVmZmVyLnByb3RvdHlwZS5ieXRlcz1mdW5jdGlvbigpe3JldHVybiB0aGlzLmJ5dGVzX30sci5CeXRlQnVmZmVyLnByb3RvdHlwZS5wb3NpdGlvbj1mdW5jdGlvbigpe3JldHVybiB0aGlzLnBvc2l0aW9uX30sci5CeXRlQnVmZmVyLnByb3RvdHlwZS5zZXRQb3NpdGlvbj1mdW5jdGlvbih0KXt0aGlzLnBvc2l0aW9uXz10fSxyLkJ5dGVCdWZmZXIucHJvdG90eXBlLmNhcGFjaXR5PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuYnl0ZXNfLmxlbmd0aH0sci5CeXRlQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5yZWFkVWludDgodCk8PDI0Pj4yNH0sci5CeXRlQnVmZmVyLnByb3RvdHlwZS5yZWFkVWludDg9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuYnl0ZXNfW3RdfSxyLkJ5dGVCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNj1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5yZWFkVWludDE2KHQpPDwxNj4+MTZ9LHIuQnl0ZUJ1ZmZlci5wcm90b3R5cGUucmVhZFVpbnQxNj1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5ieXRlc19bdF18dGhpcy5ieXRlc19bdCsxXTw8OH0sci5CeXRlQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzI9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuYnl0ZXNfW3RdfHRoaXMuYnl0ZXNfW3QrMV08PDh8dGhpcy5ieXRlc19bdCsyXTw8MTZ8dGhpcy5ieXRlc19bdCszXTw8MjR9LHIuQnl0ZUJ1ZmZlci5wcm90b3R5cGUucmVhZFVpbnQzMj1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5yZWFkSW50MzIodCk+Pj4wfSxyLkJ5dGVCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQ2ND1mdW5jdGlvbih0KXtyZXR1cm4gbmV3IHIuTG9uZyh0aGlzLnJlYWRJbnQzMih0KSx0aGlzLnJlYWRJbnQzMih0KzQpKX0sci5CeXRlQnVmZmVyLnByb3RvdHlwZS5yZWFkVWludDY0PWZ1bmN0aW9uKHQpe3JldHVybiBuZXcgci5Mb25nKHRoaXMucmVhZFVpbnQzMih0KSx0aGlzLnJlYWRVaW50MzIodCs0KSl9LHIuQnl0ZUJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0MzI9ZnVuY3Rpb24odCl7cmV0dXJuIHIuaW50MzJbMF09dGhpcy5yZWFkSW50MzIodCksci5mbG9hdDMyWzBdfSxyLkJ5dGVCdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdDY0PWZ1bmN0aW9uKHQpe3JldHVybiByLmludDMyW3IuaXNMaXR0bGVFbmRpYW4/MDoxXT10aGlzLnJlYWRJbnQzMih0KSxyLmludDMyW3IuaXNMaXR0bGVFbmRpYW4/MTowXT10aGlzLnJlYWRJbnQzMih0KzQpLHIuZmxvYXQ2NFswXX0sci5CeXRlQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDg9ZnVuY3Rpb24odCxlKXt0aGlzLmJ5dGVzX1t0XT1lfSxyLkJ5dGVCdWZmZXIucHJvdG90eXBlLndyaXRlVWludDg9ZnVuY3Rpb24odCxlKXt0aGlzLmJ5dGVzX1t0XT1lfSxyLkJ5dGVCdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTY9ZnVuY3Rpb24odCxlKXt0aGlzLmJ5dGVzX1t0XT1lLHRoaXMuYnl0ZXNfW3QrMV09ZT4+OH0sci5CeXRlQnVmZmVyLnByb3RvdHlwZS53cml0ZVVpbnQxNj1mdW5jdGlvbih0LGUpe3RoaXMuYnl0ZXNfW3RdPWUsdGhpcy5ieXRlc19bdCsxXT1lPj44fSxyLkJ5dGVCdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzI9ZnVuY3Rpb24odCxlKXt0aGlzLmJ5dGVzX1t0XT1lLHRoaXMuYnl0ZXNfW3QrMV09ZT4+OCx0aGlzLmJ5dGVzX1t0KzJdPWU+PjE2LHRoaXMuYnl0ZXNfW3QrM109ZT4+MjR9LHIuQnl0ZUJ1ZmZlci5wcm90b3R5cGUud3JpdGVVaW50MzI9ZnVuY3Rpb24odCxlKXt0aGlzLmJ5dGVzX1t0XT1lLHRoaXMuYnl0ZXNfW3QrMV09ZT4+OCx0aGlzLmJ5dGVzX1t0KzJdPWU+PjE2LHRoaXMuYnl0ZXNfW3QrM109ZT4+MjR9LHIuQnl0ZUJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ2ND1mdW5jdGlvbih0LGUpe3RoaXMud3JpdGVJbnQzMih0LGUubG93KSx0aGlzLndyaXRlSW50MzIodCs0LGUuaGlnaCl9LHIuQnl0ZUJ1ZmZlci5wcm90b3R5cGUud3JpdGVVaW50NjQ9ZnVuY3Rpb24odCxlKXt0aGlzLndyaXRlVWludDMyKHQsZS5sb3cpLHRoaXMud3JpdGVVaW50MzIodCs0LGUuaGlnaCl9LHIuQnl0ZUJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdDMyPWZ1bmN0aW9uKHQsZSl7ci5mbG9hdDMyWzBdPWUsdGhpcy53cml0ZUludDMyKHQsci5pbnQzMlswXSl9LHIuQnl0ZUJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdDY0PWZ1bmN0aW9uKHQsZSl7ci5mbG9hdDY0WzBdPWUsdGhpcy53cml0ZUludDMyKHQsci5pbnQzMltyLmlzTGl0dGxlRW5kaWFuPzA6MV0pLHRoaXMud3JpdGVJbnQzMih0KzQsci5pbnQzMltyLmlzTGl0dGxlRW5kaWFuPzE6MF0pfSxyLkJ5dGVCdWZmZXIucHJvdG90eXBlLmdldEJ1ZmZlcklkZW50aWZpZXI9ZnVuY3Rpb24oKXtpZih0aGlzLmJ5dGVzXy5sZW5ndGg8dGhpcy5wb3NpdGlvbl8rci5TSVpFT0ZfSU5UK3IuRklMRV9JREVOVElGSUVSX0xFTkdUSCl0aHJvdyBuZXcgRXJyb3IoXCJGbGF0QnVmZmVyczogQnl0ZUJ1ZmZlciBpcyB0b28gc2hvcnQgdG8gY29udGFpbiBhbiBpZGVudGlmaWVyLlwiKTtmb3IodmFyIHQ9XCJcIixlPTA7ZTxyLkZJTEVfSURFTlRJRklFUl9MRU5HVEg7ZSsrKXQrPVN0cmluZy5mcm9tQ2hhckNvZGUodGhpcy5yZWFkSW50OCh0aGlzLnBvc2l0aW9uXytyLlNJWkVPRl9JTlQrZSkpO3JldHVybiB0fSxyLkJ5dGVCdWZmZXIucHJvdG90eXBlLl9fb2Zmc2V0PWZ1bmN0aW9uKHQsZSl7dmFyIG49dC10aGlzLnJlYWRJbnQzMih0KTtyZXR1cm4gZTx0aGlzLnJlYWRJbnQxNihuKT90aGlzLnJlYWRJbnQxNihuK2UpOjB9LHIuQnl0ZUJ1ZmZlci5wcm90b3R5cGUuX191bmlvbj1mdW5jdGlvbih0LGUpe3JldHVybiB0LmJiX3Bvcz1lK3RoaXMucmVhZEludDMyKGUpLHQuYmI9dGhpcyx0fSxyLkJ5dGVCdWZmZXIucHJvdG90eXBlLl9fc3RyaW5nPWZ1bmN0aW9uKHQsZSl7dCs9dGhpcy5yZWFkSW50MzIodCk7dmFyIG49dGhpcy5yZWFkSW50MzIodCksaT1cIlwiLG89MDtpZih0Kz1yLlNJWkVPRl9JTlQsZT09PXIuRW5jb2RpbmcuVVRGOF9CWVRFUylyZXR1cm4gdGhpcy5ieXRlc18uc3ViYXJyYXkodCx0K24pO2Zvcig7bzxuOyl7dmFyIGEscz10aGlzLnJlYWRVaW50OCh0K28rKyk7aWYoczwxOTIpYT1zO2Vsc2V7dmFyIHU9dGhpcy5yZWFkVWludDgodCtvKyspO2lmKHM8MjI0KWE9KDMxJnMpPDw2fDYzJnU7ZWxzZXt2YXIgYz10aGlzLnJlYWRVaW50OCh0K28rKyk7YT1zPDI0MD8oMTUmcyk8PDEyfCg2MyZ1KTw8Nnw2MyZjOig3JnMpPDwxOHwoNjMmdSk8PDEyfCg2MyZjKTw8Nnw2MyZ0aGlzLnJlYWRVaW50OCh0K28rKyl9fWE8NjU1MzY/aSs9U3RyaW5nLmZyb21DaGFyQ29kZShhKTooYS09NjU1MzYsaSs9U3RyaW5nLmZyb21DaGFyQ29kZSg1NTI5NisoYT4+MTApLDU2MzIwKygxMDIzJmEpKSl9cmV0dXJuIGl9LHIuQnl0ZUJ1ZmZlci5wcm90b3R5cGUuX19pbmRpcmVjdD1mdW5jdGlvbih0KXtyZXR1cm4gdCt0aGlzLnJlYWRJbnQzMih0KX0sci5CeXRlQnVmZmVyLnByb3RvdHlwZS5fX3ZlY3Rvcj1mdW5jdGlvbih0KXtyZXR1cm4gdCt0aGlzLnJlYWRJbnQzMih0KStyLlNJWkVPRl9JTlR9LHIuQnl0ZUJ1ZmZlci5wcm90b3R5cGUuX192ZWN0b3JfbGVuPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnJlYWRJbnQzMih0K3RoaXMucmVhZEludDMyKHQpKX0sci5CeXRlQnVmZmVyLnByb3RvdHlwZS5fX2hhc19pZGVudGlmaWVyPWZ1bmN0aW9uKHQpe2lmKHQubGVuZ3RoIT1yLkZJTEVfSURFTlRJRklFUl9MRU5HVEgpdGhyb3cgbmV3IEVycm9yKFwiRmxhdEJ1ZmZlcnM6IGZpbGUgaWRlbnRpZmllciBtdXN0IGJlIGxlbmd0aCBcIityLkZJTEVfSURFTlRJRklFUl9MRU5HVEgpO2Zvcih2YXIgZT0wO2U8ci5GSUxFX0lERU5USUZJRVJfTEVOR1RIO2UrKylpZih0LmNoYXJDb2RlQXQoZSkhPXRoaXMucmVhZEludDgodGhpcy5wb3NpdGlvbl8rci5TSVpFT0ZfSU5UK2UpKXJldHVybiExO3JldHVybiEwfSxyLkJ5dGVCdWZmZXIucHJvdG90eXBlLmNyZWF0ZUxvbmc9ZnVuY3Rpb24odCxlKXtyZXR1cm4gci5Mb25nLmNyZWF0ZSh0LGUpfX19LF9fd2VicGFja19tb2R1bGVfY2FjaGVfXz17fTtmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKHQpe3ZhciBlPV9fd2VicGFja19tb2R1bGVfY2FjaGVfX1t0XTtpZih2b2lkIDAhPT1lKXJldHVybiBlLmV4cG9ydHM7dmFyIG49X193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW3RdPXtleHBvcnRzOnt9fTtyZXR1cm4gX193ZWJwYWNrX21vZHVsZXNfX1t0XS5jYWxsKG4uZXhwb3J0cyxuLG4uZXhwb3J0cyxfX3dlYnBhY2tfcmVxdWlyZV9fKSxuLmV4cG9ydHN9X193ZWJwYWNrX3JlcXVpcmVfXy5uPXQ9Pnt2YXIgZT10JiZ0Ll9fZXNNb2R1bGU/KCk9PnQuZGVmYXVsdDooKT0+dDtyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXy5kKGUse2E6ZX0pLGV9LF9fd2VicGFja19yZXF1aXJlX18uZD0odCxlKT0+e2Zvcih2YXIgbiBpbiBlKV9fd2VicGFja19yZXF1aXJlX18ubyhlLG4pJiYhX193ZWJwYWNrX3JlcXVpcmVfXy5vKHQsbikmJk9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LG4se2VudW1lcmFibGU6ITAsZ2V0OmVbbl19KX0sX193ZWJwYWNrX3JlcXVpcmVfXy5nPWZ1bmN0aW9uKCl7aWYoXCJvYmplY3RcIj09dHlwZW9mIGdsb2JhbFRoaXMpcmV0dXJuIGdsb2JhbFRoaXM7dHJ5e3JldHVybiB0aGlzfHxuZXcgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpfWNhdGNoKHQpe2lmKFwib2JqZWN0XCI9PXR5cGVvZiB3aW5kb3cpcmV0dXJuIHdpbmRvd319KCksX193ZWJwYWNrX3JlcXVpcmVfXy5vPSh0LGUpPT5PYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCxlKSxfX3dlYnBhY2tfcmVxdWlyZV9fLnI9dD0+e1widW5kZWZpbmVkXCIhPXR5cGVvZiBTeW1ib2wmJlN5bWJvbC50b1N0cmluZ1RhZyYmT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsU3ltYm9sLnRvU3RyaW5nVGFnLHt2YWx1ZTpcIk1vZHVsZVwifSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSl9O3ZhciBfX3dlYnBhY2tfZXhwb3J0c19fPV9fd2VicGFja19yZXF1aXJlX18oNjAxOCk7cmV0dXJuIF9fd2VicGFja19leHBvcnRzX199KSgpKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1vcnQtd2ViLm1pbi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/onnxruntime-web/dist/ort-web.min.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@xenova/transformers/src/backends/onnx.js":
/*!****************************************************************!*\
  !*** ./node_modules/@xenova/transformers/src/backends/onnx.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("var onnxruntime_node__WEBPACK_IMPORTED_MODULE_0___namespace_cache;\nvar onnxruntime_web__WEBPACK_IMPORTED_MODULE_1___namespace_cache;\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ONNX: function() { return /* binding */ ONNX; },\n/* harmony export */   executionProviders: function() { return /* binding */ executionProviders; }\n/* harmony export */ });\n/* harmony import */ var onnxruntime_node__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! onnxruntime-node */ \"?c7c8\");\n/* harmony import */ var onnxruntime_web__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! onnxruntime-web */ \"(app-pages-browser)/./node_modules/onnxruntime-web/dist/ort-web.min.js\");\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n/**\n * @file Handler file for choosing the correct version of ONNX Runtime, based on the environment.\n * Ideally, we could import the `onnxruntime-web` and `onnxruntime-node` packages only when needed,\n * but dynamic imports don't seem to work with the current webpack version and/or configuration.\n * This is possibly due to the experimental nature of top-level await statements.\n * So, we just import both packages, and use the appropriate one based on the environment:\n *   - When running in node, we use `onnxruntime-node`.\n *   - When running in the browser, we use `onnxruntime-web` (`onnxruntime-node` is not bundled).\n * \n * This module is not directly exported, but can be accessed through the environment variables:\n * ```javascript\n * import { env } from '@xenova/transformers';\n * console.log(env.backends.onnx);\n * ```\n * \n * @module backends/onnx\n */\n\n// NOTE: Import order matters here. We need to import `onnxruntime-node` before `onnxruntime-web`.\n// In either case, we select the default export if it exists, otherwise we use the named export.\n\n\n\n/** @type {module} The ONNX runtime module. */\nlet ONNX;\n\nconst executionProviders = [\n    // 'webgpu',\n    'wasm'\n];\n\nif (typeof process !== 'undefined' && process?.release?.name === 'node') {\n    // Running in a node-like environment.\n    ONNX = onnxruntime_node__WEBPACK_IMPORTED_MODULE_0__ ?? /*#__PURE__*/ (onnxruntime_node__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (onnxruntime_node__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(onnxruntime_node__WEBPACK_IMPORTED_MODULE_0__, 2)));\n\n    // Add `cpu` execution provider, with higher precedence that `wasm`.\n    executionProviders.unshift('cpu');\n\n} else {\n    // Running in a browser-environment\n    ONNX = onnxruntime_web__WEBPACK_IMPORTED_MODULE_1__ ?? /*#__PURE__*/ (onnxruntime_web__WEBPACK_IMPORTED_MODULE_1___namespace_cache || (onnxruntime_web__WEBPACK_IMPORTED_MODULE_1___namespace_cache = __webpack_require__.t(onnxruntime_web__WEBPACK_IMPORTED_MODULE_1__, 2)));\n\n    // SIMD for WebAssembly does not operate correctly in some recent versions of iOS (16.4.x).\n    // As a temporary fix, we disable it for now.\n    // For more information, see: https://github.com/microsoft/onnxruntime/issues/15644\n    const isIOS = typeof navigator !== 'undefined' && /iP(hone|od|ad).+16_4.+AppleWebKit/.test(navigator.userAgent);\n    if (isIOS) {\n        ONNX.env.wasm.simd = false;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AeGVub3ZhL3RyYW5zZm9ybWVycy9zcmMvYmFja2VuZHMvb25ueC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksTUFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDOEM7QUFDRjs7QUFFNUMsV0FBVyxRQUFRO0FBQ1o7O0FBRUE7QUFDUDtBQUNBO0FBQ0E7O0FBRUEsV0FBVyxPQUFPLG9CQUFvQixPQUFPO0FBQzdDO0FBQ0EsV0FBVyw2Q0FBaUIsSUFBSSwwTkFBUzs7QUFFekM7QUFDQTs7QUFFQSxFQUFFO0FBQ0Y7QUFDQSxXQUFXLDRDQUFnQixJQUFJLHVOQUFROztBQUV2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AeGVub3ZhL3RyYW5zZm9ybWVycy9zcmMvYmFja2VuZHMvb25ueC5qcz9hZjE4Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGZpbGUgSGFuZGxlciBmaWxlIGZvciBjaG9vc2luZyB0aGUgY29ycmVjdCB2ZXJzaW9uIG9mIE9OTlggUnVudGltZSwgYmFzZWQgb24gdGhlIGVudmlyb25tZW50LlxuICogSWRlYWxseSwgd2UgY291bGQgaW1wb3J0IHRoZSBgb25ueHJ1bnRpbWUtd2ViYCBhbmQgYG9ubnhydW50aW1lLW5vZGVgIHBhY2thZ2VzIG9ubHkgd2hlbiBuZWVkZWQsXG4gKiBidXQgZHluYW1pYyBpbXBvcnRzIGRvbid0IHNlZW0gdG8gd29yayB3aXRoIHRoZSBjdXJyZW50IHdlYnBhY2sgdmVyc2lvbiBhbmQvb3IgY29uZmlndXJhdGlvbi5cbiAqIFRoaXMgaXMgcG9zc2libHkgZHVlIHRvIHRoZSBleHBlcmltZW50YWwgbmF0dXJlIG9mIHRvcC1sZXZlbCBhd2FpdCBzdGF0ZW1lbnRzLlxuICogU28sIHdlIGp1c3QgaW1wb3J0IGJvdGggcGFja2FnZXMsIGFuZCB1c2UgdGhlIGFwcHJvcHJpYXRlIG9uZSBiYXNlZCBvbiB0aGUgZW52aXJvbm1lbnQ6XG4gKiAgIC0gV2hlbiBydW5uaW5nIGluIG5vZGUsIHdlIHVzZSBgb25ueHJ1bnRpbWUtbm9kZWAuXG4gKiAgIC0gV2hlbiBydW5uaW5nIGluIHRoZSBicm93c2VyLCB3ZSB1c2UgYG9ubnhydW50aW1lLXdlYmAgKGBvbm54cnVudGltZS1ub2RlYCBpcyBub3QgYnVuZGxlZCkuXG4gKiBcbiAqIFRoaXMgbW9kdWxlIGlzIG5vdCBkaXJlY3RseSBleHBvcnRlZCwgYnV0IGNhbiBiZSBhY2Nlc3NlZCB0aHJvdWdoIHRoZSBlbnZpcm9ubWVudCB2YXJpYWJsZXM6XG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBpbXBvcnQgeyBlbnYgfSBmcm9tICdAeGVub3ZhL3RyYW5zZm9ybWVycyc7XG4gKiBjb25zb2xlLmxvZyhlbnYuYmFja2VuZHMub25ueCk7XG4gKiBgYGBcbiAqIFxuICogQG1vZHVsZSBiYWNrZW5kcy9vbm54XG4gKi9cblxuLy8gTk9URTogSW1wb3J0IG9yZGVyIG1hdHRlcnMgaGVyZS4gV2UgbmVlZCB0byBpbXBvcnQgYG9ubnhydW50aW1lLW5vZGVgIGJlZm9yZSBgb25ueHJ1bnRpbWUtd2ViYC5cbi8vIEluIGVpdGhlciBjYXNlLCB3ZSBzZWxlY3QgdGhlIGRlZmF1bHQgZXhwb3J0IGlmIGl0IGV4aXN0cywgb3RoZXJ3aXNlIHdlIHVzZSB0aGUgbmFtZWQgZXhwb3J0LlxuaW1wb3J0ICogYXMgT05OWF9OT0RFIGZyb20gJ29ubnhydW50aW1lLW5vZGUnO1xuaW1wb3J0ICogYXMgT05OWF9XRUIgZnJvbSAnb25ueHJ1bnRpbWUtd2ViJztcblxuLyoqIEB0eXBlIHttb2R1bGV9IFRoZSBPTk5YIHJ1bnRpbWUgbW9kdWxlLiAqL1xuZXhwb3J0IGxldCBPTk5YO1xuXG5leHBvcnQgY29uc3QgZXhlY3V0aW9uUHJvdmlkZXJzID0gW1xuICAgIC8vICd3ZWJncHUnLFxuICAgICd3YXNtJ1xuXTtcblxuaWYgKHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiBwcm9jZXNzPy5yZWxlYXNlPy5uYW1lID09PSAnbm9kZScpIHtcbiAgICAvLyBSdW5uaW5nIGluIGEgbm9kZS1saWtlIGVudmlyb25tZW50LlxuICAgIE9OTlggPSBPTk5YX05PREUuZGVmYXVsdCA/PyBPTk5YX05PREU7XG5cbiAgICAvLyBBZGQgYGNwdWAgZXhlY3V0aW9uIHByb3ZpZGVyLCB3aXRoIGhpZ2hlciBwcmVjZWRlbmNlIHRoYXQgYHdhc21gLlxuICAgIGV4ZWN1dGlvblByb3ZpZGVycy51bnNoaWZ0KCdjcHUnKTtcblxufSBlbHNlIHtcbiAgICAvLyBSdW5uaW5nIGluIGEgYnJvd3Nlci1lbnZpcm9ubWVudFxuICAgIE9OTlggPSBPTk5YX1dFQi5kZWZhdWx0ID8/IE9OTlhfV0VCO1xuXG4gICAgLy8gU0lNRCBmb3IgV2ViQXNzZW1ibHkgZG9lcyBub3Qgb3BlcmF0ZSBjb3JyZWN0bHkgaW4gc29tZSByZWNlbnQgdmVyc2lvbnMgb2YgaU9TICgxNi40LngpLlxuICAgIC8vIEFzIGEgdGVtcG9yYXJ5IGZpeCwgd2UgZGlzYWJsZSBpdCBmb3Igbm93LlxuICAgIC8vIEZvciBtb3JlIGluZm9ybWF0aW9uLCBzZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9taWNyb3NvZnQvb25ueHJ1bnRpbWUvaXNzdWVzLzE1NjQ0XG4gICAgY29uc3QgaXNJT1MgPSB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiAvaVAoaG9uZXxvZHxhZCkuKzE2XzQuK0FwcGxlV2ViS2l0Ly50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuICAgIGlmIChpc0lPUykge1xuICAgICAgICBPTk5YLmVudi53YXNtLnNpbWQgPSBmYWxzZTtcbiAgICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@xenova/transformers/src/backends/onnx.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@xenova/transformers/src/configs.js":
/*!**********************************************************!*\
  !*** ./node_modules/@xenova/transformers/src/configs.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AutoConfig: function() { return /* binding */ AutoConfig; },\n/* harmony export */   PretrainedConfig: function() { return /* binding */ PretrainedConfig; }\n/* harmony export */ });\n/* harmony import */ var _utils_hub_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/hub.js */ \"(app-pages-browser)/./node_modules/@xenova/transformers/src/utils/hub.js\");\n\n/**\n * @file Helper module for using model configs. For more information, see the corresponding\n * [Python documentation](https://huggingface.co/docs/transformers/main/en/model_doc/auto#transformers.AutoConfig).\n * \n * **Example:** Load an `AutoConfig`.\n * \n * ```javascript\n * import { AutoConfig } from '@xenova/transformers';\n * let config = await AutoConfig.from_pretrained('bert-base-uncased');\n * console.log(config);\n * // PretrainedConfig {\n * //   \"model_type\": \"bert\",\n * //   \"is_encoder_decoder\": false,\n * //   \"architectures\": [\n * //       \"BertForMaskedLM\"\n * //   ],\n * //   \"vocab_size\": 30522\n * //   \"num_attention_heads\": 12,\n * //   \"num_hidden_layers\": 12,\n * //   \"hidden_size\": 768,\n * //   \"max_position_embeddings\": 512,\n * //   ...\n * // }\n * ```\n * \n * @module configs\n */\n\n\n\n/**\n * @typedef {import('./utils/hub.js').PretrainedOptions} PretrainedOptions\n */\n\n\n/**\n * Loads a config from the specified path.\n * @param {string} pretrained_model_name_or_path The path to the config directory.\n * @param {PretrainedOptions} options Additional options for loading the config.\n * @returns {Promise<Array>} A promise that resolves with information about the loaded config.\n */\nasync function loadConfig(pretrained_model_name_or_path, options) {\n    let info = await (0,_utils_hub_js__WEBPACK_IMPORTED_MODULE_0__.getModelJSON)(pretrained_model_name_or_path, 'config.json', true, options);\n    return info;\n}\n\n/**\n * Base class for all configuration classes. For more information, see the corresponding\n * [Python documentation](https://huggingface.co/docs/transformers/main/en/main_classes/configuration#transformers.PretrainedConfig).\n */\nclass PretrainedConfig {\n    // NOTE: Typo in original\n\n    /**\n     * Create a new PreTrainedTokenizer instance.\n     * @param {Object} configJSON The JSON of the config.\n     */\n    constructor(configJSON) {\n        this.model_type = null;\n        this.is_encoder_decoder = false;\n\n        Object.assign(this, configJSON);\n    }\n\n    /**\n     * Loads a pre-trained config from the given `pretrained_model_name_or_path`. \n     * \n     * @param {string} pretrained_model_name_or_path The path to the pre-trained config.\n     * @param {PretrainedOptions} options Additional options for loading the config.\n     * @throws {Error} Throws an error if the config.json is not found in the `pretrained_model_name_or_path`.\n     * \n     * @returns {Promise<PretrainedConfig>} A new instance of the `PretrainedConfig` class.\n     */\n    static async from_pretrained(pretrained_model_name_or_path, {\n        progress_callback = null,\n        config = null,\n        cache_dir = null,\n        local_files_only = false,\n        revision = 'main',\n    } = {}) {\n\n        let data = config ?? await loadConfig(pretrained_model_name_or_path, {\n            progress_callback,\n            config,\n            cache_dir,\n            local_files_only,\n            revision,\n        })\n        return new this(data);\n    }\n}\n\n/**\n * Helper class which is used to instantiate pretrained configs with the `from_pretrained` function.\n * \n * @example\n * let config = await AutoConfig.from_pretrained('bert-base-uncased'); \n */\nclass AutoConfig {\n    /** @type {PretrainedConfig.from_pretrained} */\n    static async from_pretrained(...args) {\n        return PretrainedConfig.from_pretrained(...args);\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AeGVub3ZhL3RyYW5zZm9ybWVycy9zcmMvY29uZmlncy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGFBQWE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBSXdCOztBQUV4QjtBQUNBLGFBQWEsNENBQTRDO0FBQ3pEOzs7QUFHQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsbUJBQW1CO0FBQzlCLGFBQWEsZ0JBQWdCO0FBQzdCO0FBQ0E7QUFDQSxxQkFBcUIsMkRBQVk7QUFDakM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLG1CQUFtQjtBQUNsQyxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBLGlCQUFpQiwyQkFBMkI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLElBQUk7O0FBRVY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLGVBQWUsa0NBQWtDO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AeGVub3ZhL3RyYW5zZm9ybWVycy9zcmMvY29uZmlncy5qcz80MjI0Il0sInNvdXJjZXNDb250ZW50IjpbIlxuLyoqXG4gKiBAZmlsZSBIZWxwZXIgbW9kdWxlIGZvciB1c2luZyBtb2RlbCBjb25maWdzLiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgc2VlIHRoZSBjb3JyZXNwb25kaW5nXG4gKiBbUHl0aG9uIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vaHVnZ2luZ2ZhY2UuY28vZG9jcy90cmFuc2Zvcm1lcnMvbWFpbi9lbi9tb2RlbF9kb2MvYXV0byN0cmFuc2Zvcm1lcnMuQXV0b0NvbmZpZykuXG4gKiBcbiAqICoqRXhhbXBsZToqKiBMb2FkIGFuIGBBdXRvQ29uZmlnYC5cbiAqIFxuICogYGBgamF2YXNjcmlwdFxuICogaW1wb3J0IHsgQXV0b0NvbmZpZyB9IGZyb20gJ0B4ZW5vdmEvdHJhbnNmb3JtZXJzJztcbiAqIGxldCBjb25maWcgPSBhd2FpdCBBdXRvQ29uZmlnLmZyb21fcHJldHJhaW5lZCgnYmVydC1iYXNlLXVuY2FzZWQnKTtcbiAqIGNvbnNvbGUubG9nKGNvbmZpZyk7XG4gKiAvLyBQcmV0cmFpbmVkQ29uZmlnIHtcbiAqIC8vICAgXCJtb2RlbF90eXBlXCI6IFwiYmVydFwiLFxuICogLy8gICBcImlzX2VuY29kZXJfZGVjb2RlclwiOiBmYWxzZSxcbiAqIC8vICAgXCJhcmNoaXRlY3R1cmVzXCI6IFtcbiAqIC8vICAgICAgIFwiQmVydEZvck1hc2tlZExNXCJcbiAqIC8vICAgXSxcbiAqIC8vICAgXCJ2b2NhYl9zaXplXCI6IDMwNTIyXG4gKiAvLyAgIFwibnVtX2F0dGVudGlvbl9oZWFkc1wiOiAxMixcbiAqIC8vICAgXCJudW1faGlkZGVuX2xheWVyc1wiOiAxMixcbiAqIC8vICAgXCJoaWRkZW5fc2l6ZVwiOiA3NjgsXG4gKiAvLyAgIFwibWF4X3Bvc2l0aW9uX2VtYmVkZGluZ3NcIjogNTEyLFxuICogLy8gICAuLi5cbiAqIC8vIH1cbiAqIGBgYFxuICogXG4gKiBAbW9kdWxlIGNvbmZpZ3NcbiAqL1xuXG5pbXBvcnQge1xuICAgIGdldE1vZGVsSlNPTixcbn0gZnJvbSAnLi91dGlscy9odWIuanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJy4vdXRpbHMvaHViLmpzJykuUHJldHJhaW5lZE9wdGlvbnN9IFByZXRyYWluZWRPcHRpb25zXG4gKi9cblxuXG4vKipcbiAqIExvYWRzIGEgY29uZmlnIGZyb20gdGhlIHNwZWNpZmllZCBwYXRoLlxuICogQHBhcmFtIHtzdHJpbmd9IHByZXRyYWluZWRfbW9kZWxfbmFtZV9vcl9wYXRoIFRoZSBwYXRoIHRvIHRoZSBjb25maWcgZGlyZWN0b3J5LlxuICogQHBhcmFtIHtQcmV0cmFpbmVkT3B0aW9uc30gb3B0aW9ucyBBZGRpdGlvbmFsIG9wdGlvbnMgZm9yIGxvYWRpbmcgdGhlIGNvbmZpZy5cbiAqIEByZXR1cm5zIHtQcm9taXNlPEFycmF5Pn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgbG9hZGVkIGNvbmZpZy5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gbG9hZENvbmZpZyhwcmV0cmFpbmVkX21vZGVsX25hbWVfb3JfcGF0aCwgb3B0aW9ucykge1xuICAgIGxldCBpbmZvID0gYXdhaXQgZ2V0TW9kZWxKU09OKHByZXRyYWluZWRfbW9kZWxfbmFtZV9vcl9wYXRoLCAnY29uZmlnLmpzb24nLCB0cnVlLCBvcHRpb25zKTtcbiAgICByZXR1cm4gaW5mbztcbn1cblxuLyoqXG4gKiBCYXNlIGNsYXNzIGZvciBhbGwgY29uZmlndXJhdGlvbiBjbGFzc2VzLiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgc2VlIHRoZSBjb3JyZXNwb25kaW5nXG4gKiBbUHl0aG9uIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vaHVnZ2luZ2ZhY2UuY28vZG9jcy90cmFuc2Zvcm1lcnMvbWFpbi9lbi9tYWluX2NsYXNzZXMvY29uZmlndXJhdGlvbiN0cmFuc2Zvcm1lcnMuUHJldHJhaW5lZENvbmZpZykuXG4gKi9cbmV4cG9ydCBjbGFzcyBQcmV0cmFpbmVkQ29uZmlnIHtcbiAgICAvLyBOT1RFOiBUeXBvIGluIG9yaWdpbmFsXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgUHJlVHJhaW5lZFRva2VuaXplciBpbnN0YW5jZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnSlNPTiBUaGUgSlNPTiBvZiB0aGUgY29uZmlnLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ0pTT04pIHtcbiAgICAgICAgdGhpcy5tb2RlbF90eXBlID0gbnVsbDtcbiAgICAgICAgdGhpcy5pc19lbmNvZGVyX2RlY29kZXIgPSBmYWxzZTtcblxuICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMsIGNvbmZpZ0pTT04pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExvYWRzIGEgcHJlLXRyYWluZWQgY29uZmlnIGZyb20gdGhlIGdpdmVuIGBwcmV0cmFpbmVkX21vZGVsX25hbWVfb3JfcGF0aGAuIFxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcmV0cmFpbmVkX21vZGVsX25hbWVfb3JfcGF0aCBUaGUgcGF0aCB0byB0aGUgcHJlLXRyYWluZWQgY29uZmlnLlxuICAgICAqIEBwYXJhbSB7UHJldHJhaW5lZE9wdGlvbnN9IG9wdGlvbnMgQWRkaXRpb25hbCBvcHRpb25zIGZvciBsb2FkaW5nIHRoZSBjb25maWcuXG4gICAgICogQHRocm93cyB7RXJyb3J9IFRocm93cyBhbiBlcnJvciBpZiB0aGUgY29uZmlnLmpzb24gaXMgbm90IGZvdW5kIGluIHRoZSBgcHJldHJhaW5lZF9tb2RlbF9uYW1lX29yX3BhdGhgLlxuICAgICAqIFxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFByZXRyYWluZWRDb25maWc+fSBBIG5ldyBpbnN0YW5jZSBvZiB0aGUgYFByZXRyYWluZWRDb25maWdgIGNsYXNzLlxuICAgICAqL1xuICAgIHN0YXRpYyBhc3luYyBmcm9tX3ByZXRyYWluZWQocHJldHJhaW5lZF9tb2RlbF9uYW1lX29yX3BhdGgsIHtcbiAgICAgICAgcHJvZ3Jlc3NfY2FsbGJhY2sgPSBudWxsLFxuICAgICAgICBjb25maWcgPSBudWxsLFxuICAgICAgICBjYWNoZV9kaXIgPSBudWxsLFxuICAgICAgICBsb2NhbF9maWxlc19vbmx5ID0gZmFsc2UsXG4gICAgICAgIHJldmlzaW9uID0gJ21haW4nLFxuICAgIH0gPSB7fSkge1xuXG4gICAgICAgIGxldCBkYXRhID0gY29uZmlnID8/IGF3YWl0IGxvYWRDb25maWcocHJldHJhaW5lZF9tb2RlbF9uYW1lX29yX3BhdGgsIHtcbiAgICAgICAgICAgIHByb2dyZXNzX2NhbGxiYWNrLFxuICAgICAgICAgICAgY29uZmlnLFxuICAgICAgICAgICAgY2FjaGVfZGlyLFxuICAgICAgICAgICAgbG9jYWxfZmlsZXNfb25seSxcbiAgICAgICAgICAgIHJldmlzaW9uLFxuICAgICAgICB9KVxuICAgICAgICByZXR1cm4gbmV3IHRoaXMoZGF0YSk7XG4gICAgfVxufVxuXG4vKipcbiAqIEhlbHBlciBjbGFzcyB3aGljaCBpcyB1c2VkIHRvIGluc3RhbnRpYXRlIHByZXRyYWluZWQgY29uZmlncyB3aXRoIHRoZSBgZnJvbV9wcmV0cmFpbmVkYCBmdW5jdGlvbi5cbiAqIFxuICogQGV4YW1wbGVcbiAqIGxldCBjb25maWcgPSBhd2FpdCBBdXRvQ29uZmlnLmZyb21fcHJldHJhaW5lZCgnYmVydC1iYXNlLXVuY2FzZWQnKTsgXG4gKi9cbmV4cG9ydCBjbGFzcyBBdXRvQ29uZmlnIHtcbiAgICAvKiogQHR5cGUge1ByZXRyYWluZWRDb25maWcuZnJvbV9wcmV0cmFpbmVkfSAqL1xuICAgIHN0YXRpYyBhc3luYyBmcm9tX3ByZXRyYWluZWQoLi4uYXJncykge1xuICAgICAgICByZXR1cm4gUHJldHJhaW5lZENvbmZpZy5mcm9tX3ByZXRyYWluZWQoLi4uYXJncyk7XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@xenova/transformers/src/configs.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@xenova/transformers/src/env.js":
/*!******************************************************!*\
  !*** ./node_modules/@xenova/transformers/src/env.js ***!
  \******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   env: function() { return /* binding */ env; }\n/* harmony export */ });\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fs */ \"?85d5\");\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! path */ \"?373b\");\n/* harmony import */ var url__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! url */ \"(app-pages-browser)/./node_modules/next/dist/compiled/native-url/index.js\");\n/* harmony import */ var _backends_onnx_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./backends/onnx.js */ \"(app-pages-browser)/./node_modules/@xenova/transformers/src/backends/onnx.js\");\n/**\n * @file Module used to configure Transformers.js.\n * \n * **Example:** Disable remote models.\n * ```javascript\n * import { env } from '@xenova/transformers';\n * env.allowRemoteModels = false;\n * ```\n * \n * **Example:** Set local model path.\n * ```javascript\n * import { env } from '@xenova/transformers';\n * env.localModelPath = '/path/to/local/models/';\n * ```\n * \n * **Example:** Set cache directory.\n * ```javascript\n * import { env } from '@xenova/transformers';\n * env.cacheDir = '/path/to/cache/directory/';\n * ```\n * \n * @module env\n */\n\n\n\n\n\n\nconst { env: onnx_env } = _backends_onnx_js__WEBPACK_IMPORTED_MODULE_3__.ONNX;\n\nconst VERSION = '2.4.2';\n\n// Check if various APIs are available (depends on environment)\nconst WEB_CACHE_AVAILABLE = typeof self !== 'undefined' && 'caches' in self;\nconst FS_AVAILABLE = !isEmpty(fs__WEBPACK_IMPORTED_MODULE_0__); // check if file system is available\nconst PATH_AVAILABLE = !isEmpty(path__WEBPACK_IMPORTED_MODULE_1__); // check if path is available\n\nconst RUNNING_LOCALLY = FS_AVAILABLE && PATH_AVAILABLE;\n\nconst __dirname = RUNNING_LOCALLY\n    ? path__WEBPACK_IMPORTED_MODULE_1__.dirname(path__WEBPACK_IMPORTED_MODULE_1__.dirname(url__WEBPACK_IMPORTED_MODULE_2__.fileURLToPath(\"file:///Users/jovisaib/code/sides/transformersjs-playground/node_modules/@xenova/transformers/src/env.js\")))\n    : './';\n\n// Only used for environments with access to file system\nconst DEFAULT_CACHE_DIR = RUNNING_LOCALLY\n    ? path__WEBPACK_IMPORTED_MODULE_1__.join(__dirname, '/.cache/')\n    : null;\n\n// Set local model path, based on available APIs\nconst DEFAULT_LOCAL_MODEL_PATH = '/models/';\nconst localModelPath = RUNNING_LOCALLY\n    ? path__WEBPACK_IMPORTED_MODULE_1__.join(__dirname, DEFAULT_LOCAL_MODEL_PATH)\n    : DEFAULT_LOCAL_MODEL_PATH;\n\n// Set path to wasm files. This is needed when running in a web worker.\n// https://onnxruntime.ai/docs/api/js/interfaces/Env.WebAssemblyFlags.html#wasmPaths\n// We use remote wasm files by default to make it easier for newer users.\n// In practice, users should probably self-host the necessary .wasm files.\nonnx_env.wasm.wasmPaths = RUNNING_LOCALLY\n    ? path__WEBPACK_IMPORTED_MODULE_1__.join(__dirname, '/dist/')\n    : `https://cdn.jsdelivr.net/npm/@xenova/transformers@${VERSION}/dist/`;\n\n\n/**\n * Global variable used to control execution. This provides users a simple way to configure Transformers.js.\n * @property {Object} backends Expose environment variables of different backends,\n * allowing users to set these variables if they want to.\n * @property {string} __dirname Directory name of module. Useful for resolving local paths.\n * @property {string} version This version of Transformers.js.\n * @property {boolean} allowRemoteModels Whether to allow loading of remote files, defaults to `true`.\n * If set to `false`, it will have the same effect as setting `local_files_only=true` when loading pipelines, models, tokenizers, processors, etc.\n * @property {string} remoteHost Host URL to load models from. Defaults to the Hugging Face Hub.\n * @property {string} remotePathTemplate Path template to fill in and append to `remoteHost` when loading models.\n * @property {boolean} allowLocalModels Whether to allow loading of local files, defaults to `true`.\n * If set to `false`, it will skip the local file check and try to load the model from the remote host.\n * @property {string} localModelPath Path to load local models from. Defaults to `/models/`.\n * @property {boolean} useFS Whether to use the file system to load files. By default, it is `true` if available.\n * @property {boolean} useBrowserCache Whether to use Cache API to cache models. By default, it is `true` if available.\n * @property {boolean} useFSCache Whether to use the file system to cache files. By default, it is `true` if available.\n * @property {string} cacheDir The directory to use for caching files with the file system. By default, it is `./.cache`.\n*/\nconst env = {\n    /////////////////// Backends settings ///////////////////\n    backends: {\n        // onnxruntime-web/onnxruntime-node\n        onnx: onnx_env,\n\n        // TensorFlow.js\n        tfjs: {},\n    },\n\n    __dirname,\n    version: VERSION,\n\n    /////////////////// Model settings ///////////////////\n    allowRemoteModels: true,\n    remoteHost: 'https://huggingface.co/',\n    remotePathTemplate: '{model}/resolve/{revision}/',\n\n    allowLocalModels: true,\n    localModelPath: localModelPath,\n    useFS: FS_AVAILABLE,\n\n    /////////////////// Cache settings ///////////////////\n    useBrowserCache: WEB_CACHE_AVAILABLE,\n    useFSCache: FS_AVAILABLE,\n    cacheDir: DEFAULT_CACHE_DIR,\n\n    //////////////////////////////////////////////////////\n}\n\n\n/**\n * @param {Object} obj\n * @private\n */\nfunction isEmpty(obj) {\n    return Object.keys(obj).length === 0;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AeGVub3ZhL3RyYW5zZm9ybWVycy9zcmMvZW52LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksTUFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE1BQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFb0I7QUFDSTtBQUNGOztBQUVvQjtBQUMxQyxRQUFRLGdCQUFnQixFQUFFLG1EQUFJOztBQUU5Qjs7QUFFQTtBQUNBO0FBQ0EsOEJBQThCLCtCQUFFLEdBQUc7QUFDbkMsZ0NBQWdDLGlDQUFJLEdBQUc7O0FBRXZDOztBQUVBO0FBQ0EsTUFBTSx5Q0FBWSxDQUFDLHlDQUFZLENBQUMsOENBQWlCLENBQUMsMEdBQWU7QUFDakU7O0FBRUE7QUFDQTtBQUNBLE1BQU0sc0NBQVM7QUFDZjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLHNDQUFTO0FBQ2Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sc0NBQVM7QUFDZiwyREFBMkQsUUFBUTs7O0FBR25FO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsU0FBUztBQUN2QjtBQUNBLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsU0FBUztBQUN2QixjQUFjLFNBQVM7QUFDdkIsY0FBYyxTQUFTO0FBQ3ZCLGNBQWMsUUFBUTtBQUN0QjtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0I7QUFDaEIsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixNQUFNLFVBQVUsU0FBUzs7QUFFbkQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B4ZW5vdmEvdHJhbnNmb3JtZXJzL3NyYy9lbnYuanM/ZGM0YSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBmaWxlIE1vZHVsZSB1c2VkIHRvIGNvbmZpZ3VyZSBUcmFuc2Zvcm1lcnMuanMuXG4gKiBcbiAqICoqRXhhbXBsZToqKiBEaXNhYmxlIHJlbW90ZSBtb2RlbHMuXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBpbXBvcnQgeyBlbnYgfSBmcm9tICdAeGVub3ZhL3RyYW5zZm9ybWVycyc7XG4gKiBlbnYuYWxsb3dSZW1vdGVNb2RlbHMgPSBmYWxzZTtcbiAqIGBgYFxuICogXG4gKiAqKkV4YW1wbGU6KiogU2V0IGxvY2FsIG1vZGVsIHBhdGguXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBpbXBvcnQgeyBlbnYgfSBmcm9tICdAeGVub3ZhL3RyYW5zZm9ybWVycyc7XG4gKiBlbnYubG9jYWxNb2RlbFBhdGggPSAnL3BhdGgvdG8vbG9jYWwvbW9kZWxzLyc7XG4gKiBgYGBcbiAqIFxuICogKipFeGFtcGxlOioqIFNldCBjYWNoZSBkaXJlY3RvcnkuXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBpbXBvcnQgeyBlbnYgfSBmcm9tICdAeGVub3ZhL3RyYW5zZm9ybWVycyc7XG4gKiBlbnYuY2FjaGVEaXIgPSAnL3BhdGgvdG8vY2FjaGUvZGlyZWN0b3J5Lyc7XG4gKiBgYGBcbiAqIFxuICogQG1vZHVsZSBlbnZcbiAqL1xuXG5pbXBvcnQgZnMgZnJvbSAnZnMnO1xuaW1wb3J0IHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgdXJsIGZyb20gJ3VybCc7XG5cbmltcG9ydCB7IE9OTlggfSBmcm9tICcuL2JhY2tlbmRzL29ubnguanMnO1xuY29uc3QgeyBlbnY6IG9ubnhfZW52IH0gPSBPTk5YO1xuXG5jb25zdCBWRVJTSU9OID0gJzIuNC4yJztcblxuLy8gQ2hlY2sgaWYgdmFyaW91cyBBUElzIGFyZSBhdmFpbGFibGUgKGRlcGVuZHMgb24gZW52aXJvbm1lbnQpXG5jb25zdCBXRUJfQ0FDSEVfQVZBSUxBQkxFID0gdHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnICYmICdjYWNoZXMnIGluIHNlbGY7XG5jb25zdCBGU19BVkFJTEFCTEUgPSAhaXNFbXB0eShmcyk7IC8vIGNoZWNrIGlmIGZpbGUgc3lzdGVtIGlzIGF2YWlsYWJsZVxuY29uc3QgUEFUSF9BVkFJTEFCTEUgPSAhaXNFbXB0eShwYXRoKTsgLy8gY2hlY2sgaWYgcGF0aCBpcyBhdmFpbGFibGVcblxuY29uc3QgUlVOTklOR19MT0NBTExZID0gRlNfQVZBSUxBQkxFICYmIFBBVEhfQVZBSUxBQkxFO1xuXG5jb25zdCBfX2Rpcm5hbWUgPSBSVU5OSU5HX0xPQ0FMTFlcbiAgICA/IHBhdGguZGlybmFtZShwYXRoLmRpcm5hbWUodXJsLmZpbGVVUkxUb1BhdGgoaW1wb3J0Lm1ldGEudXJsKSkpXG4gICAgOiAnLi8nO1xuXG4vLyBPbmx5IHVzZWQgZm9yIGVudmlyb25tZW50cyB3aXRoIGFjY2VzcyB0byBmaWxlIHN5c3RlbVxuY29uc3QgREVGQVVMVF9DQUNIRV9ESVIgPSBSVU5OSU5HX0xPQ0FMTFlcbiAgICA/IHBhdGguam9pbihfX2Rpcm5hbWUsICcvLmNhY2hlLycpXG4gICAgOiBudWxsO1xuXG4vLyBTZXQgbG9jYWwgbW9kZWwgcGF0aCwgYmFzZWQgb24gYXZhaWxhYmxlIEFQSXNcbmNvbnN0IERFRkFVTFRfTE9DQUxfTU9ERUxfUEFUSCA9ICcvbW9kZWxzLyc7XG5jb25zdCBsb2NhbE1vZGVsUGF0aCA9IFJVTk5JTkdfTE9DQUxMWVxuICAgID8gcGF0aC5qb2luKF9fZGlybmFtZSwgREVGQVVMVF9MT0NBTF9NT0RFTF9QQVRIKVxuICAgIDogREVGQVVMVF9MT0NBTF9NT0RFTF9QQVRIO1xuXG4vLyBTZXQgcGF0aCB0byB3YXNtIGZpbGVzLiBUaGlzIGlzIG5lZWRlZCB3aGVuIHJ1bm5pbmcgaW4gYSB3ZWIgd29ya2VyLlxuLy8gaHR0cHM6Ly9vbm54cnVudGltZS5haS9kb2NzL2FwaS9qcy9pbnRlcmZhY2VzL0Vudi5XZWJBc3NlbWJseUZsYWdzLmh0bWwjd2FzbVBhdGhzXG4vLyBXZSB1c2UgcmVtb3RlIHdhc20gZmlsZXMgYnkgZGVmYXVsdCB0byBtYWtlIGl0IGVhc2llciBmb3IgbmV3ZXIgdXNlcnMuXG4vLyBJbiBwcmFjdGljZSwgdXNlcnMgc2hvdWxkIHByb2JhYmx5IHNlbGYtaG9zdCB0aGUgbmVjZXNzYXJ5IC53YXNtIGZpbGVzLlxub25ueF9lbnYud2FzbS53YXNtUGF0aHMgPSBSVU5OSU5HX0xPQ0FMTFlcbiAgICA/IHBhdGguam9pbihfX2Rpcm5hbWUsICcvZGlzdC8nKVxuICAgIDogYGh0dHBzOi8vY2RuLmpzZGVsaXZyLm5ldC9ucG0vQHhlbm92YS90cmFuc2Zvcm1lcnNAJHtWRVJTSU9OfS9kaXN0L2A7XG5cblxuLyoqXG4gKiBHbG9iYWwgdmFyaWFibGUgdXNlZCB0byBjb250cm9sIGV4ZWN1dGlvbi4gVGhpcyBwcm92aWRlcyB1c2VycyBhIHNpbXBsZSB3YXkgdG8gY29uZmlndXJlIFRyYW5zZm9ybWVycy5qcy5cbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBiYWNrZW5kcyBFeHBvc2UgZW52aXJvbm1lbnQgdmFyaWFibGVzIG9mIGRpZmZlcmVudCBiYWNrZW5kcyxcbiAqIGFsbG93aW5nIHVzZXJzIHRvIHNldCB0aGVzZSB2YXJpYWJsZXMgaWYgdGhleSB3YW50IHRvLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IF9fZGlybmFtZSBEaXJlY3RvcnkgbmFtZSBvZiBtb2R1bGUuIFVzZWZ1bCBmb3IgcmVzb2x2aW5nIGxvY2FsIHBhdGhzLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IHZlcnNpb24gVGhpcyB2ZXJzaW9uIG9mIFRyYW5zZm9ybWVycy5qcy5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gYWxsb3dSZW1vdGVNb2RlbHMgV2hldGhlciB0byBhbGxvdyBsb2FkaW5nIG9mIHJlbW90ZSBmaWxlcywgZGVmYXVsdHMgdG8gYHRydWVgLlxuICogSWYgc2V0IHRvIGBmYWxzZWAsIGl0IHdpbGwgaGF2ZSB0aGUgc2FtZSBlZmZlY3QgYXMgc2V0dGluZyBgbG9jYWxfZmlsZXNfb25seT10cnVlYCB3aGVuIGxvYWRpbmcgcGlwZWxpbmVzLCBtb2RlbHMsIHRva2VuaXplcnMsIHByb2Nlc3NvcnMsIGV0Yy5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSByZW1vdGVIb3N0IEhvc3QgVVJMIHRvIGxvYWQgbW9kZWxzIGZyb20uIERlZmF1bHRzIHRvIHRoZSBIdWdnaW5nIEZhY2UgSHViLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IHJlbW90ZVBhdGhUZW1wbGF0ZSBQYXRoIHRlbXBsYXRlIHRvIGZpbGwgaW4gYW5kIGFwcGVuZCB0byBgcmVtb3RlSG9zdGAgd2hlbiBsb2FkaW5nIG1vZGVscy5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gYWxsb3dMb2NhbE1vZGVscyBXaGV0aGVyIHRvIGFsbG93IGxvYWRpbmcgb2YgbG9jYWwgZmlsZXMsIGRlZmF1bHRzIHRvIGB0cnVlYC5cbiAqIElmIHNldCB0byBgZmFsc2VgLCBpdCB3aWxsIHNraXAgdGhlIGxvY2FsIGZpbGUgY2hlY2sgYW5kIHRyeSB0byBsb2FkIHRoZSBtb2RlbCBmcm9tIHRoZSByZW1vdGUgaG9zdC5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBsb2NhbE1vZGVsUGF0aCBQYXRoIHRvIGxvYWQgbG9jYWwgbW9kZWxzIGZyb20uIERlZmF1bHRzIHRvIGAvbW9kZWxzL2AuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IHVzZUZTIFdoZXRoZXIgdG8gdXNlIHRoZSBmaWxlIHN5c3RlbSB0byBsb2FkIGZpbGVzLiBCeSBkZWZhdWx0LCBpdCBpcyBgdHJ1ZWAgaWYgYXZhaWxhYmxlLlxuICogQHByb3BlcnR5IHtib29sZWFufSB1c2VCcm93c2VyQ2FjaGUgV2hldGhlciB0byB1c2UgQ2FjaGUgQVBJIHRvIGNhY2hlIG1vZGVscy4gQnkgZGVmYXVsdCwgaXQgaXMgYHRydWVgIGlmIGF2YWlsYWJsZS5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gdXNlRlNDYWNoZSBXaGV0aGVyIHRvIHVzZSB0aGUgZmlsZSBzeXN0ZW0gdG8gY2FjaGUgZmlsZXMuIEJ5IGRlZmF1bHQsIGl0IGlzIGB0cnVlYCBpZiBhdmFpbGFibGUuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gY2FjaGVEaXIgVGhlIGRpcmVjdG9yeSB0byB1c2UgZm9yIGNhY2hpbmcgZmlsZXMgd2l0aCB0aGUgZmlsZSBzeXN0ZW0uIEJ5IGRlZmF1bHQsIGl0IGlzIGAuLy5jYWNoZWAuXG4qL1xuZXhwb3J0IGNvbnN0IGVudiA9IHtcbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vIEJhY2tlbmRzIHNldHRpbmdzIC8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICBiYWNrZW5kczoge1xuICAgICAgICAvLyBvbm54cnVudGltZS13ZWIvb25ueHJ1bnRpbWUtbm9kZVxuICAgICAgICBvbm54OiBvbm54X2VudixcblxuICAgICAgICAvLyBUZW5zb3JGbG93LmpzXG4gICAgICAgIHRmanM6IHt9LFxuICAgIH0sXG5cbiAgICBfX2Rpcm5hbWUsXG4gICAgdmVyc2lvbjogVkVSU0lPTixcblxuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8gTW9kZWwgc2V0dGluZ3MgLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgIGFsbG93UmVtb3RlTW9kZWxzOiB0cnVlLFxuICAgIHJlbW90ZUhvc3Q6ICdodHRwczovL2h1Z2dpbmdmYWNlLmNvLycsXG4gICAgcmVtb3RlUGF0aFRlbXBsYXRlOiAne21vZGVsfS9yZXNvbHZlL3tyZXZpc2lvbn0vJyxcblxuICAgIGFsbG93TG9jYWxNb2RlbHM6IHRydWUsXG4gICAgbG9jYWxNb2RlbFBhdGg6IGxvY2FsTW9kZWxQYXRoLFxuICAgIHVzZUZTOiBGU19BVkFJTEFCTEUsXG5cbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vIENhY2hlIHNldHRpbmdzIC8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICB1c2VCcm93c2VyQ2FjaGU6IFdFQl9DQUNIRV9BVkFJTEFCTEUsXG4gICAgdXNlRlNDYWNoZTogRlNfQVZBSUxBQkxFLFxuICAgIGNhY2hlRGlyOiBERUZBVUxUX0NBQ0hFX0RJUixcblxuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xufVxuXG5cbi8qKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gaXNFbXB0eShvYmopIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMob2JqKS5sZW5ndGggPT09IDA7XG59XG5cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@xenova/transformers/src/env.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@xenova/transformers/src/models.js":
/*!*********************************************************!*\
  !*** ./node_modules/@xenova/transformers/src/models.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AlbertForMaskedLM: function() { return /* binding */ AlbertForMaskedLM; },\n/* harmony export */   AlbertForQuestionAnswering: function() { return /* binding */ AlbertForQuestionAnswering; },\n/* harmony export */   AlbertForSequenceClassification: function() { return /* binding */ AlbertForSequenceClassification; },\n/* harmony export */   AlbertModel: function() { return /* binding */ AlbertModel; },\n/* harmony export */   AlbertPreTrainedModel: function() { return /* binding */ AlbertPreTrainedModel; },\n/* harmony export */   AutoModel: function() { return /* binding */ AutoModel; },\n/* harmony export */   AutoModelForCausalLM: function() { return /* binding */ AutoModelForCausalLM; },\n/* harmony export */   AutoModelForImageClassification: function() { return /* binding */ AutoModelForImageClassification; },\n/* harmony export */   AutoModelForImageSegmentation: function() { return /* binding */ AutoModelForImageSegmentation; },\n/* harmony export */   AutoModelForMaskGeneration: function() { return /* binding */ AutoModelForMaskGeneration; },\n/* harmony export */   AutoModelForMaskedLM: function() { return /* binding */ AutoModelForMaskedLM; },\n/* harmony export */   AutoModelForObjectDetection: function() { return /* binding */ AutoModelForObjectDetection; },\n/* harmony export */   AutoModelForQuestionAnswering: function() { return /* binding */ AutoModelForQuestionAnswering; },\n/* harmony export */   AutoModelForSeq2SeqLM: function() { return /* binding */ AutoModelForSeq2SeqLM; },\n/* harmony export */   AutoModelForSequenceClassification: function() { return /* binding */ AutoModelForSequenceClassification; },\n/* harmony export */   AutoModelForTokenClassification: function() { return /* binding */ AutoModelForTokenClassification; },\n/* harmony export */   AutoModelForVision2Seq: function() { return /* binding */ AutoModelForVision2Seq; },\n/* harmony export */   BartForConditionalGeneration: function() { return /* binding */ BartForConditionalGeneration; },\n/* harmony export */   BartForSequenceClassification: function() { return /* binding */ BartForSequenceClassification; },\n/* harmony export */   BartModel: function() { return /* binding */ BartModel; },\n/* harmony export */   BartPretrainedModel: function() { return /* binding */ BartPretrainedModel; },\n/* harmony export */   BaseModelOutput: function() { return /* binding */ BaseModelOutput; },\n/* harmony export */   BertForMaskedLM: function() { return /* binding */ BertForMaskedLM; },\n/* harmony export */   BertForQuestionAnswering: function() { return /* binding */ BertForQuestionAnswering; },\n/* harmony export */   BertForSequenceClassification: function() { return /* binding */ BertForSequenceClassification; },\n/* harmony export */   BertForTokenClassification: function() { return /* binding */ BertForTokenClassification; },\n/* harmony export */   BertModel: function() { return /* binding */ BertModel; },\n/* harmony export */   BertPreTrainedModel: function() { return /* binding */ BertPreTrainedModel; },\n/* harmony export */   CLIPModel: function() { return /* binding */ CLIPModel; },\n/* harmony export */   CLIPPreTrainedModel: function() { return /* binding */ CLIPPreTrainedModel; },\n/* harmony export */   CausalLMOutputWithPast: function() { return /* binding */ CausalLMOutputWithPast; },\n/* harmony export */   CodeGenForCausalLM: function() { return /* binding */ CodeGenForCausalLM; },\n/* harmony export */   CodeGenModel: function() { return /* binding */ CodeGenModel; },\n/* harmony export */   CodeGenPreTrainedModel: function() { return /* binding */ CodeGenPreTrainedModel; },\n/* harmony export */   DetrForObjectDetection: function() { return /* binding */ DetrForObjectDetection; },\n/* harmony export */   DetrForSegmentation: function() { return /* binding */ DetrForSegmentation; },\n/* harmony export */   DetrObjectDetectionOutput: function() { return /* binding */ DetrObjectDetectionOutput; },\n/* harmony export */   DetrPreTrainedModel: function() { return /* binding */ DetrPreTrainedModel; },\n/* harmony export */   DetrSegmentationOutput: function() { return /* binding */ DetrSegmentationOutput; },\n/* harmony export */   DistilBertForMaskedLM: function() { return /* binding */ DistilBertForMaskedLM; },\n/* harmony export */   DistilBertForQuestionAnswering: function() { return /* binding */ DistilBertForQuestionAnswering; },\n/* harmony export */   DistilBertForSequenceClassification: function() { return /* binding */ DistilBertForSequenceClassification; },\n/* harmony export */   DistilBertForTokenClassification: function() { return /* binding */ DistilBertForTokenClassification; },\n/* harmony export */   DistilBertModel: function() { return /* binding */ DistilBertModel; },\n/* harmony export */   DistilBertPreTrainedModel: function() { return /* binding */ DistilBertPreTrainedModel; },\n/* harmony export */   GPT2LMHeadModel: function() { return /* binding */ GPT2LMHeadModel; },\n/* harmony export */   GPT2Model: function() { return /* binding */ GPT2Model; },\n/* harmony export */   GPT2PreTrainedModel: function() { return /* binding */ GPT2PreTrainedModel; },\n/* harmony export */   GPTNeoForCausalLM: function() { return /* binding */ GPTNeoForCausalLM; },\n/* harmony export */   GPTNeoModel: function() { return /* binding */ GPTNeoModel; },\n/* harmony export */   GPTNeoPreTrainedModel: function() { return /* binding */ GPTNeoPreTrainedModel; },\n/* harmony export */   M2M100ForConditionalGeneration: function() { return /* binding */ M2M100ForConditionalGeneration; },\n/* harmony export */   M2M100Model: function() { return /* binding */ M2M100Model; },\n/* harmony export */   M2M100PreTrainedModel: function() { return /* binding */ M2M100PreTrainedModel; },\n/* harmony export */   MT5ForConditionalGeneration: function() { return /* binding */ MT5ForConditionalGeneration; },\n/* harmony export */   MT5Model: function() { return /* binding */ MT5Model; },\n/* harmony export */   MT5PreTrainedModel: function() { return /* binding */ MT5PreTrainedModel; },\n/* harmony export */   MarianMTModel: function() { return /* binding */ MarianMTModel; },\n/* harmony export */   MarianModel: function() { return /* binding */ MarianModel; },\n/* harmony export */   MarianPreTrainedModel: function() { return /* binding */ MarianPreTrainedModel; },\n/* harmony export */   MaskedLMOutput: function() { return /* binding */ MaskedLMOutput; },\n/* harmony export */   MobileBertForMaskedLM: function() { return /* binding */ MobileBertForMaskedLM; },\n/* harmony export */   MobileBertForQuestionAnswering: function() { return /* binding */ MobileBertForQuestionAnswering; },\n/* harmony export */   MobileBertForSequenceClassification: function() { return /* binding */ MobileBertForSequenceClassification; },\n/* harmony export */   MobileBertModel: function() { return /* binding */ MobileBertModel; },\n/* harmony export */   MobileBertPreTrainedModel: function() { return /* binding */ MobileBertPreTrainedModel; },\n/* harmony export */   MobileViTForImageClassification: function() { return /* binding */ MobileViTForImageClassification; },\n/* harmony export */   MobileViTPreTrainedModel: function() { return /* binding */ MobileViTPreTrainedModel; },\n/* harmony export */   ModelOutput: function() { return /* binding */ ModelOutput; },\n/* harmony export */   PreTrainedModel: function() { return /* binding */ PreTrainedModel; },\n/* harmony export */   PretrainedMixin: function() { return /* binding */ PretrainedMixin; },\n/* harmony export */   QuestionAnsweringModelOutput: function() { return /* binding */ QuestionAnsweringModelOutput; },\n/* harmony export */   RobertaForMaskedLM: function() { return /* binding */ RobertaForMaskedLM; },\n/* harmony export */   RobertaForQuestionAnswering: function() { return /* binding */ RobertaForQuestionAnswering; },\n/* harmony export */   RobertaForSequenceClassification: function() { return /* binding */ RobertaForSequenceClassification; },\n/* harmony export */   RobertaForTokenClassification: function() { return /* binding */ RobertaForTokenClassification; },\n/* harmony export */   RobertaModel: function() { return /* binding */ RobertaModel; },\n/* harmony export */   RobertaPreTrainedModel: function() { return /* binding */ RobertaPreTrainedModel; },\n/* harmony export */   SamImageSegmentationOutput: function() { return /* binding */ SamImageSegmentationOutput; },\n/* harmony export */   SamModel: function() { return /* binding */ SamModel; },\n/* harmony export */   SamPreTrainedModel: function() { return /* binding */ SamPreTrainedModel; },\n/* harmony export */   Seq2SeqLMOutput: function() { return /* binding */ Seq2SeqLMOutput; },\n/* harmony export */   SequenceClassifierOutput: function() { return /* binding */ SequenceClassifierOutput; },\n/* harmony export */   SqueezeBertForMaskedLM: function() { return /* binding */ SqueezeBertForMaskedLM; },\n/* harmony export */   SqueezeBertForQuestionAnswering: function() { return /* binding */ SqueezeBertForQuestionAnswering; },\n/* harmony export */   SqueezeBertForSequenceClassification: function() { return /* binding */ SqueezeBertForSequenceClassification; },\n/* harmony export */   SqueezeBertModel: function() { return /* binding */ SqueezeBertModel; },\n/* harmony export */   SqueezeBertPreTrainedModel: function() { return /* binding */ SqueezeBertPreTrainedModel; },\n/* harmony export */   T5ForConditionalGeneration: function() { return /* binding */ T5ForConditionalGeneration; },\n/* harmony export */   T5Model: function() { return /* binding */ T5Model; },\n/* harmony export */   T5PreTrainedModel: function() { return /* binding */ T5PreTrainedModel; },\n/* harmony export */   TokenClassifierOutput: function() { return /* binding */ TokenClassifierOutput; },\n/* harmony export */   ViTForImageClassification: function() { return /* binding */ ViTForImageClassification; },\n/* harmony export */   ViTPreTrainedModel: function() { return /* binding */ ViTPreTrainedModel; },\n/* harmony export */   VisionEncoderDecoderModel: function() { return /* binding */ VisionEncoderDecoderModel; },\n/* harmony export */   WhisperForConditionalGeneration: function() { return /* binding */ WhisperForConditionalGeneration; },\n/* harmony export */   WhisperModel: function() { return /* binding */ WhisperModel; },\n/* harmony export */   WhisperPreTrainedModel: function() { return /* binding */ WhisperPreTrainedModel; },\n/* harmony export */   XLMRobertaForMaskedLM: function() { return /* binding */ XLMRobertaForMaskedLM; },\n/* harmony export */   XLMRobertaForQuestionAnswering: function() { return /* binding */ XLMRobertaForQuestionAnswering; },\n/* harmony export */   XLMRobertaForSequenceClassification: function() { return /* binding */ XLMRobertaForSequenceClassification; },\n/* harmony export */   XLMRobertaForTokenClassification: function() { return /* binding */ XLMRobertaForTokenClassification; },\n/* harmony export */   XLMRobertaModel: function() { return /* binding */ XLMRobertaModel; },\n/* harmony export */   XLMRobertaPreTrainedModel: function() { return /* binding */ XLMRobertaPreTrainedModel; }\n/* harmony export */ });\n/* harmony import */ var _configs_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./configs.js */ \"(app-pages-browser)/./node_modules/@xenova/transformers/src/configs.js\");\n/* harmony import */ var _utils_core_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/core.js */ \"(app-pages-browser)/./node_modules/@xenova/transformers/src/utils/core.js\");\n/* harmony import */ var _utils_hub_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/hub.js */ \"(app-pages-browser)/./node_modules/@xenova/transformers/src/utils/hub.js\");\n/* harmony import */ var _utils_generation_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/generation.js */ \"(app-pages-browser)/./node_modules/@xenova/transformers/src/utils/generation.js\");\n/* harmony import */ var _utils_tensor_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils/tensor.js */ \"(app-pages-browser)/./node_modules/@xenova/transformers/src/utils/tensor.js\");\n/* harmony import */ var _backends_onnx_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./backends/onnx.js */ \"(app-pages-browser)/./node_modules/@xenova/transformers/src/backends/onnx.js\");\n/* harmony import */ var _transformers_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./transformers.js */ \"(app-pages-browser)/./node_modules/@xenova/transformers/src/transformers.js\");\n\n/**\n * @file Definitions of all models available in Transformers.js.\n * \n * **Example:** Load and run an `AutoModel`.\n * \n * ```javascript\n * import { AutoModel, AutoTokenizer } from '@xenova/transformers';\n *\n * let tokenizer = await AutoTokenizer.from_pretrained('Xenova/bert-base-uncased');\n * let model = await AutoModel.from_pretrained('Xenova/bert-base-uncased');\n *\n * let inputs = await tokenizer('I love transformers!');\n * let { logits } = await model(inputs);\n * // Tensor {\n * //     data: Float32Array(183132) [-7.117443084716797, -7.107812881469727, -7.092104911804199, ...]\n * //     dims: (3) [1, 6, 30522],\n * //     type: \"float32\",\n * //     size: 183132,\n * // }\n * ```\n * \n * We also provide other `AutoModel`s (listed below), which you can use in the same way as the Python library. For example:\n * \n * **Example:** Load and run a `AutoModelForSeq2SeqLM`.\n * ```javascript\n * import { AutoModelForSeq2SeqLM, AutoTokenizer } from '@xenova/transformers';\n * \n * let tokenizer = await AutoTokenizer.from_pretrained('Xenova/t5-small');\n * let model = await AutoModelForSeq2SeqLM.from_pretrained('Xenova/t5-small');\n *\n * let { input_ids } = await tokenizer('translate English to German: I love transformers!');\n * let outputs = await model.generate(input_ids);\n * let decoded = tokenizer.decode(outputs[0], { skip_special_tokens: true });\n * // 'Ich liebe Transformatoren!'\n * ```\n * \n * @module models\n */\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst { InferenceSession, Tensor: ONNXTensor } = _backends_onnx_js__WEBPACK_IMPORTED_MODULE_5__.ONNX;\n\n/**\n * @typedef {import('./utils/hub.js').PretrainedOptions} PretrainedOptions\n */\n\n\n//////////////////////////////////////////////////\n// Model types: used internally\nclass ModelType { };\n\n// Either encoder-only or encoder-decoder (and will be decided by `model.config.is_encoder_decoder`)\nclass EncoderOnlyModelType extends ModelType { };\nclass EncoderDecoderModelType extends ModelType { };\nclass Seq2SeqModelType extends EncoderDecoderModelType { };\nclass DecoderOnlyModelType extends ModelType { };\n//////////////////////////////////////////////////\n\n\n//////////////////////////////////////////////////\n// Helper functions\n\n// Will be populated later\nconst MODEL_TYPE_MAPPING = new Map();\nconst MODEL_CLASS_MAPPING = new Map();\n\n/**\n * Helper function to determine which `forward` method to run for a specific model.\n * @param {Object} self The calling object\n * @param {Object} model_inputs The inputs to be sent to the model\n * @returns {Promise<Object>} The model output\n */\nasync function forward(self, model_inputs) {\n    if (MODEL_TYPE_MAPPING.get(self.constructor.name) === DecoderOnlyModelType) {\n        return await decoderForward(self, model_inputs);\n    } else {\n        return await encoderForward(self, model_inputs);\n    }\n}\n\n/**\n * Constructs an InferenceSession using a model file located at the specified path.\n * @param {string} pretrained_model_name_or_path The path to the directory containing the model file.\n * @param {string} fileName The name of the model file.\n * @param {PretrainedOptions} options Additional options for loading the model.\n * @returns {Promise<InferenceSession>} A Promise that resolves to an InferenceSession object.\n * @private\n */\nasync function constructSession(pretrained_model_name_or_path, fileName, options) {\n    // TODO add option for user to force specify their desired execution provider\n    let modelFileName = `onnx/${fileName}${options.quantized ? '_quantized' : ''}.onnx`;\n    let buffer = await (0,_utils_hub_js__WEBPACK_IMPORTED_MODULE_2__.getModelFile)(pretrained_model_name_or_path, modelFileName, true, options);\n\n    try {\n        return await InferenceSession.create(buffer, {\n            executionProviders: _backends_onnx_js__WEBPACK_IMPORTED_MODULE_5__.executionProviders,\n        });\n    } catch (err) {\n        // If the execution provided was only wasm, throw the error\n        if (_backends_onnx_js__WEBPACK_IMPORTED_MODULE_5__.executionProviders.length === 1 && _backends_onnx_js__WEBPACK_IMPORTED_MODULE_5__.executionProviders[0] === 'wasm') {\n            throw err;\n        }\n\n        console.warn(err);\n        console.warn(\n            'Something went wrong during model construction (most likely a missing operation). ' +\n            'Using `wasm` as a fallback. '\n        )\n        return await InferenceSession.create(buffer, {\n            executionProviders: ['wasm']\n        });\n    }\n}\n\n/**\n * Validate model inputs\n * @param {InferenceSession} session The InferenceSession object that will be run.\n * @param {Object} inputs The inputs to check.\n * @returns {Promise<Object>} A Promise that resolves to the checked inputs.\n * @throws {Error} If any inputs are missing.\n * @private\n */\nasync function validateInputs(session, inputs) {\n    // NOTE: Only create a shallow copy\n    const checkedInputs = {};\n    const missingInputs = [];\n    for (let inputName of session.inputNames) {\n        if (inputs[inputName] === undefined) {\n            missingInputs.push(inputName);\n        } else {\n            checkedInputs[inputName] = inputs[inputName];\n        }\n    }\n    if (missingInputs.length > 0) {\n        throw new Error(\n            `An error occurred during model execution: \"Missing the following inputs: ${missingInputs.join(', ')}.`);\n    }\n\n    const numInputsProvided = Object.keys(inputs).length;\n    const numInputsNeeded = session.inputNames.length;\n    if (numInputsProvided > numInputsNeeded) {\n        // No missing inputs, but too many inputs were provided.\n        // Warn the user and ignore the extra inputs.\n        let ignored = Object.keys(inputs).filter(inputName => !session.inputNames.includes(inputName));\n        console.warn(`WARNING: Too many inputs were provided (${numInputsProvided} > ${numInputsNeeded}). The following inputs will be ignored: \"${ignored.join(', ')}\".`);\n    }\n\n    return checkedInputs;\n}\n\n/**\n * Executes an InferenceSession using the specified inputs.\n * NOTE: `inputs` must contain at least the input names of the model.\n *  - If additional inputs are passed, they will be ignored.\n *  - If inputs are missing, an error will be thrown.\n * \n * @param {InferenceSession} session The InferenceSession object to run.\n * @param {Object} inputs An object that maps input names to input tensors.\n * @returns {Promise<Object>} A Promise that resolves to an object that maps output names to output tensors.\n * @private\n */\nasync function sessionRun(session, inputs) {\n    const checkedInputs = await validateInputs(session, inputs);\n    try {\n        let output = await session.run(checkedInputs);\n        output = replaceTensors(output);\n        return output;\n    } catch (e) {\n        // This usually occurs when the inputs are of the wrong type.\n        console.error(`An error occurred during model execution: \"${e}\".`);\n        console.error('Inputs given to model:', checkedInputs);\n        throw e;\n    }\n}\n\n/**\n * Replaces ONNX Tensor objects with custom Tensor objects to support additional functions.\n * @param {Object} obj The object to replace tensor objects in.\n * @returns {Object} The object with tensor objects replaced by custom Tensor objects.\n * @private\n */\nfunction replaceTensors(obj) {\n    for (let prop in obj) {\n        if (obj[prop] instanceof ONNXTensor) {\n            obj[prop] = new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_4__.Tensor(obj[prop]);\n        } else if (typeof obj[prop] === 'object') {\n            replaceTensors(obj[prop]);\n        }\n    }\n    return obj;\n}\n\n\n/**\n * Converts an array or Tensor of integers to an int64 Tensor.\n * @param {Array|Tensor} items The input integers to be converted.\n * @returns {Tensor} The int64 Tensor with the converted values.\n * @throws {Error} If the input array is empty or the input is a batched Tensor and not all sequences have the same length.\n * @private\n */\nfunction toI64Tensor(items) {\n    if (items instanceof _utils_tensor_js__WEBPACK_IMPORTED_MODULE_4__.Tensor) {\n        return items;\n    }\n    // items is an array\n    if (items.length === 0) {\n        throw Error(\"items must be non-empty\");\n    }\n\n    if (Array.isArray(items[0])) {\n        // batched\n        if (items.some(x => x.length !== items[0].length)) {\n            throw Error(\"Unable to create tensor, you should probably activate truncation and/or padding with 'padding=True' and/or 'truncation=True' to have batched tensors with the same length.\")\n        }\n\n        return new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_4__.Tensor('int64',\n            BigInt64Array.from(items.flat().map(x => BigInt(x))),\n            [items.length, items[0].length]\n        );\n    } else {\n        //flat\n        return new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_4__.Tensor('int64',\n            BigInt64Array.from(items.map(x => BigInt(x))),\n            [1, items.length]\n        );\n    }\n}\n\n/**\n * Prepares an attention mask for a sequence of tokens based on configuration options.\n * @param {Object} self The calling object instance.\n * @param {Tensor} tokens The input tokens.\n * @returns {Tensor} The attention mask tensor.\n * @private\n */\nfunction prepareAttentionMask(self, tokens) {\n\n    // Prepare attention mask\n    let pad_token_id = self.config.pad_token_id ?? null;\n    let eos_token_id = self.config.eos_token_id ?? null;\n    if ((0,_utils_core_js__WEBPACK_IMPORTED_MODULE_1__.isIntegralNumber)(eos_token_id)) {\n        eos_token_id = [eos_token_id];\n    }\n\n    let is_pad_token_in_inputs = tokens.indexOf(pad_token_id) !== -1;\n    let is_pad_token_not_equal_to_eos_token_id = (eos_token_id === null) || !eos_token_id.includes(pad_token_id)\n\n    if (is_pad_token_in_inputs && is_pad_token_not_equal_to_eos_token_id) {\n        let data = BigInt64Array.from(\n            // Note: != so that int matches bigint\n            tokens.data.map(x => x != pad_token_id)\n        )\n        return new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_4__.Tensor('int64', data, tokens.dims)\n    } else {\n        return new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_4__.Tensor(\n            'int64',\n            new BigInt64Array(tokens.data.length).fill(1n),\n            tokens.dims\n        )\n    }\n}\n\n/**\n * Creates a boolean tensor with a single value.\n * @param {boolean} value The value of the tensor.\n * @returns {Tensor} The boolean tensor.\n * @private\n */\nfunction boolTensor(value) {\n    return new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_4__.Tensor('bool', [value], [1]);\n}\n\n// JS doesn't support mixins, so we define some reused functions here, and allow \"this\" to be passed in\n/**\n * Perform forward pass on the seq2seq model (both encoder and decoder).\n * @param {Object} self The seq2seq model object.\n * @param {Object} model_inputs The input object for the model containing encoder and decoder inputs.\n * @param {Object} options The options\n * @param {boolean} [options.add_decoder_pkv=true] Flag to add the decoder past key values.\n * @returns {Promise<Seq2SeqLMOutput>} Promise that resolves with the output of the seq2seq model.\n * @private\n */\nasync function seq2seqForward(self, model_inputs, {\n    add_decoder_pkv = true\n} = {}) {\n    let { encoder_outputs, past_key_values } = model_inputs;\n\n    if (!encoder_outputs) {\n        // Encoder outputs are not given, so we must compute them.\n        encoder_outputs = (await encoderForward(self, model_inputs)).last_hidden_state;\n    }\n    let decoderFeeds = {\n        input_ids: model_inputs.decoder_input_ids,\n        encoder_hidden_states: encoder_outputs,\n        use_cache_branch: boolTensor(!!past_key_values)\n    };\n\n    if (self.decoder_merged_session.inputNames.includes('encoder_attention_mask')) {\n        decoderFeeds.encoder_attention_mask = model_inputs.attention_mask\n    }\n    self.addPastKeyValues(decoderFeeds, past_key_values, add_decoder_pkv);\n\n    const decoderResults = await sessionRun(self.decoder_merged_session, decoderFeeds);\n    let logits = decoderResults.logits;\n    past_key_values = self.getPastKeyValues(decoderResults, past_key_values);\n\n    // Get cross attention and/or decoder attentions if they are present\n    const attns = self.getAttentions(decoderResults);\n\n    return new Seq2SeqLMOutput({ logits, past_key_values, encoder_outputs, ...attns });\n}\n\n/**\n * Start the beam search process for the seq2seq model.\n * @param {Object} self The seq2seq model object.\n * @param {Object[]} inputTokenIds Array of input token ids for each input sequence.\n * @param {number} numOutputTokens The maximum number of output tokens for the model.\n * @param {boolean} [requires_attention_mask=true] Flag to indicate if the model requires an attention mask.\n * @returns {Object[]} Array of beam search objects.\n * @private\n */\nfunction seq2seqStartBeams(self, inputTokenIds, numOutputTokens, requires_attention_mask = true) {\n    let beams = [];\n    let beamId = 0;\n\n    // decoder_input_ids == output_token_ids\n    let decoder_input_ids = self.config.decoder_start_token_id;\n    if (!Array.isArray(decoder_input_ids)) {\n        decoder_input_ids = [decoder_input_ids];\n    }\n\n    for (let tokens of inputTokenIds) {\n        // TODO: Improve\n        // Currently, just add back batch dimension.\n        // In future, allow for true parallel execution\n        tokens.dims = [1, ...tokens.dims]\n\n        // Create beam\n        let start = {\n            inputs: tokens,\n            encoder_outputs: null,\n            prev_model_outputs: null,\n\n            output_token_ids: decoder_input_ids,\n            done: false,\n            score: 0,\n            id: beamId++ // assign unique id to beams\n        }\n\n        if (requires_attention_mask) {\n            start.attention_mask = prepareAttentionMask(self, tokens);\n        }\n\n        beams.push(start);\n    }\n\n    return beams;\n}\n\n/**\n * Run beam search on the seq2seq model for a single beam.\n * @param {Object} self The seq2seq model object.\n * @param {Object} beam The beam search object for which to run the model.\n * @param {Object} options options\n * @param {string} [options.input_name='input_ids'] The name of the input tensor for the encoder.\n * @returns {Promise<Object>} Promise that resolves with the output of the seq2seq model for the given beam.\n * @private\n */\nasync function seq2seqRunBeam(self, beam, {\n    input_name = 'input_ids',\n} = {}\n) {\n    // 1. Prepare\n    let model_inputs = {\n        [input_name]: beam.inputs,\n        decoder_input_ids: toI64Tensor(beam.output_token_ids.slice(-1)),\n        encoder_outputs: beam.encoder_outputs,\n        past_key_values: beam.prev_model_outputs?.past_key_values,\n    }\n    if (beam.attention_mask) {\n        model_inputs.attention_mask = beam.attention_mask\n    }\n\n    // 2. Run\n    let output = await self.forward(model_inputs);\n\n    // 3. Update\n    beam.prev_model_outputs = output;\n    beam.encoder_outputs = output.encoder_outputs;\n\n    return output;\n}\n\n/**\n * Forward pass of an encoder model.\n * @param {Object} self The encoder model.\n * @param {Object} model_inputs The input data to be used for the forward pass.\n * @returns {Promise<Object>} Promise that resolves with an object containing the model's outputs.\n * @private\n */\nasync function encoderForward(self, model_inputs) {\n    let encoderFeeds = {};\n    for (let key of self.session.inputNames) {\n        encoderFeeds[key] = model_inputs[key];\n    }\n    return await sessionRun(self.session, encoderFeeds);\n}\n\n\n/**\n * Forward pass of a decoder model.\n * @param {Object} self The decoder model.\n * @param {Object} model_inputs The input data to be used for the forward pass.\n * @returns {Promise<Object>} Promise that resolves with an object containing the logits and past key values.\n * @private\n */\nasync function decoderForward(self, model_inputs) {\n    let { input_ids, past_key_values, attention_mask } = model_inputs;\n    let decoderFeeds = {\n        input_ids: input_ids,\n        attention_mask: attention_mask ?? prepareAttentionMask(self, input_ids),\n        use_cache_branch: boolTensor(past_key_values !== null)\n    }\n\n    self.addPastKeyValues(decoderFeeds, past_key_values);\n\n    let decoderResults = await sessionRun(self.session, decoderFeeds);\n\n    let logits = decoderResults.logits;\n\n    past_key_values = self.getPastKeyValues(decoderResults, past_key_values);\n    return { logits, past_key_values };\n}\n\n/**\n * Starts the generation of text by initializing the beams for the given input token IDs.\n * @param {Object} self The text generation model object.\n * @param {any} inputTokenIds An array of input token IDs to generate text from.\n * @param {number} numOutputTokens The maximum number of tokens to generate for each beam.\n * @param {Tensor} [inputs_attention_mask] The attention mask tensor for the input token IDs.\n * @returns {Object[]} An array of beams initialized with the given inputs and parameters.\n * @private\n */\nfunction decoderStartBeams(self, inputTokenIds, numOutputTokens, inputs_attention_mask) {\n    let beams = [];\n\n    let beamId = 0;\n    for (let tokens of inputTokenIds) {\n        let output_token_ids = tokens.tolist().map(Number);\n\n        // TODO: Improve\n        // Currently, just add back batch dimension.\n        // In future, allow for true parallel execution\n        tokens.dims = [1, ...tokens.dims]\n\n        let attn_mask;\n        if (inputs_attention_mask) {\n            attn_mask = inputs_attention_mask[beamId];\n            attn_mask.dims = [1, ...attn_mask.dims]\n\n        } else {\n            attn_mask = prepareAttentionMask(self, tokens)\n        }\n\n        let start = {\n            input: tokens,\n            model_input_ids: tokens,\n            attention_mask: attn_mask,\n            prev_model_outputs: null,\n\n            output_token_ids: output_token_ids,\n            num_output_tokens: numOutputTokens,\n\n            done: false,\n            score: 0,\n            id: beamId++ // assign unique id to beams\n        }\n\n        beams.push(start);\n    }\n    return beams;\n}\n\n/**\n * Runs a single step of the text generation process for a given beam.\n *\n * @param {Object} self The decoder object.\n * @param {Object} beam The beam to run.\n * @param {Tensor} beam.input The input tensor.\n * @param {Tensor} beam.model_input_ids The input ids to the model.\n * @param {Tensor} beam.attention_mask The attention mask.\n * @param {Object} beam.prev_model_outputs The past key values.\n * @param {number[]} beam.output_token_ids The output token ids.\n * @returns {Promise<Object>} The output of the generation step.\n * @private\n */\nasync function decoderRunBeam(self, beam) {\n    let attnMaskData = new BigInt64Array(beam.output_token_ids.length).fill(1n)\n\n    // 1. Prepare\n    let model_inputs = {\n        input_ids: beam.model_input_ids,\n        attention_mask: new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_4__.Tensor(\n            'int64',\n            attnMaskData,\n            [1, attnMaskData.length]\n        ),\n        past_key_values: beam.prev_model_outputs?.past_key_values,\n    }\n\n    // 2. Run\n    let output = await self.forward(model_inputs);\n\n    // 3. Update\n    beam.prev_model_outputs = output;\n\n    return output;\n}\n\n/**\n * Update a beam with a new token ID.\n * @param {Object} beam The beam to update.\n * @param {number} newTokenId The new token ID to add to the beam's output.\n * @private\n */\nfunction decoderUpdatebeam(beam, newTokenId) {\n    beam.output_token_ids = [...beam.output_token_ids, newTokenId];\n    beam.model_input_ids = new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_4__.Tensor('int64', [BigInt(newTokenId)], [1, 1]);\n}\n//////////////////////////////////////////////////\n\n//////////////////////////////////////////////////\n/**\n * A base class for pre-trained models that provides the model configuration and an ONNX session.\n * @extends Callable\n */\nclass PreTrainedModel extends _utils_core_js__WEBPACK_IMPORTED_MODULE_1__.Callable {\n\n    /**\n     * Creates a new instance of the `PreTrainedModel` class.\n     * @param {Object} config The model configuration.\n     * @param {any} session session for the model.\n     */\n    constructor(config, session) {\n        super();\n\n        this.config = config;\n        this.session = session;\n    }\n\n    /**\n    * Disposes of all the ONNX sessions that were created during inference.\n    * @returns {Promise<unknown[]>} An array of promises, one for each ONNX session that is being disposed.\n    * @todo Use https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/FinalizationRegistry\n    */\n    async dispose() {\n        let promises = [];\n        for (let key of Object.keys(this)) {\n            let item = this[key];\n            if (item instanceof InferenceSession) {\n                promises.push(item.handler.dispose())\n            }\n        }\n        return await Promise.all(promises);\n    }\n\n    /**\n     * Instantiate one of the model classes of the library from a pretrained model.\n     * \n     * The model class to instantiate is selected based on the `model_type` property of the config object\n     * (either passed as an argument or loaded from `pretrained_model_name_or_path` if possible)\n     * \n     * @param {string} pretrained_model_name_or_path The name or path of the pretrained model. Can be either:\n     * - A string, the *model id* of a pretrained model hosted inside a model repo on huggingface.co.\n     *   Valid model ids can be located at the root-level, like `bert-base-uncased`, or namespaced under a\n     *   user or organization name, like `dbmdz/bert-base-german-cased`.\n     * - A path to a *directory* containing model weights, e.g., `./my_model_directory/`.\n     * @param {PretrainedOptions} options Additional options for loading the model.\n     * \n     * @returns {Promise<PreTrainedModel>} A new instance of the `PreTrainedModel` class.\n     */\n    static async from_pretrained(pretrained_model_name_or_path, {\n        quantized = true,\n        progress_callback = null,\n        config = null,\n        cache_dir = null,\n        local_files_only = false,\n        revision = 'main',\n    } = {}) {\n\n        let options = {\n            quantized,\n            progress_callback,\n            config,\n            cache_dir,\n            local_files_only,\n            revision,\n        }\n\n        let modelType = MODEL_TYPE_MAPPING.get(this.name);\n\n        let info;\n        if (modelType === DecoderOnlyModelType) {\n            info = await Promise.all([\n                _configs_js__WEBPACK_IMPORTED_MODULE_0__.AutoConfig.from_pretrained(pretrained_model_name_or_path, options),\n                constructSession(pretrained_model_name_or_path, 'decoder_model_merged', options),\n            ]);\n\n        } else if (modelType === Seq2SeqModelType) {\n            info = await Promise.all([\n                _configs_js__WEBPACK_IMPORTED_MODULE_0__.AutoConfig.from_pretrained(pretrained_model_name_or_path, options),\n                constructSession(pretrained_model_name_or_path, 'encoder_model', options),\n                constructSession(pretrained_model_name_or_path, 'decoder_model_merged', options),\n                (0,_utils_hub_js__WEBPACK_IMPORTED_MODULE_2__.getModelJSON)(pretrained_model_name_or_path, 'generation_config.json', false, options),\n            ]);\n\n        } else if (modelType === EncoderDecoderModelType) {\n            info = await Promise.all([\n                _configs_js__WEBPACK_IMPORTED_MODULE_0__.AutoConfig.from_pretrained(pretrained_model_name_or_path, options),\n                constructSession(pretrained_model_name_or_path, 'encoder_model', options),\n                constructSession(pretrained_model_name_or_path, 'decoder_model_merged', options),\n            ]);\n\n        } else if (modelType === EncoderOnlyModelType) {\n            info = await Promise.all([\n                _configs_js__WEBPACK_IMPORTED_MODULE_0__.AutoConfig.from_pretrained(pretrained_model_name_or_path, options),\n                constructSession(pretrained_model_name_or_path, 'model', options)\n            ]);\n\n        } else {\n            console.warn('Malformed class definition.', this);\n            throw Error(`Unable to load model: ${pretrained_model_name_or_path}. Please report this bug at https://github.com/xenova/transformers.js/issues/new/choose.`);\n        }\n\n        // @ts-ignore\n        return new this(...info);\n    }\n\n    /**\n     * Runs the model with the provided inputs\n     * @param {Object} model_inputs Object containing input tensors\n     * @returns {Promise<Object>} Object containing output tensors\n     */\n    async _call(model_inputs) {\n        return await this.forward(model_inputs);\n    }\n\n    /**\n     * Forward method for a pretrained model. If not overridden by a subclass, the correct forward method\n     * will be chosen based on the model type.\n     * @param {Object} model_inputs The input data to the model in the format specified in the ONNX model.\n     * @returns {Promise<Object>} The output data from the model in the format specified in the ONNX model.\n     * @throws {Error} This method must be implemented in subclasses.\n     */\n    async forward(model_inputs) {\n        return await forward(this, model_inputs);\n    }\n\n    /**\n     * @param {GenerationConfig} generation_config \n     * @param {number} input_ids_seq_length The starting sequence length for the input ids.\n     * @returns {LogitsProcessorList}\n     */\n    _get_logits_processor(\n        generation_config,\n        input_ids_seq_length,\n        // encoder_input_ids, TODO\n        // prefix_allowed_tokens_fn, TODO\n        logits_processor = null\n    ) {\n        const processors = new _utils_generation_js__WEBPACK_IMPORTED_MODULE_3__.LogitsProcessorList();\n\n        // if (generation_config.diversity_penalty !== null && generation_config.diversity_penalty > 0.0) {\n        //     processors.push(new HammingDiversityLogitsProcessor(\n        //         generation_config.diversity_penalty,\n        //         generation_config.num_beams,\n        //         generation_config.num_beam_groups\n        //     ));\n        // }\n\n        // if (generation_config.encoder_repetition_penalty !== null && generation_config.encoder_repetition_penalty !== 1.0) {\n        //     processors.push(new EncoderRepetitionPenaltyLogitsProcessor(\n        //         generation_config.encoder_repetition_penalty,\n        //         encoder_input_ids\n        //     ));\n        // }\n\n        if (generation_config.repetition_penalty !== null && generation_config.repetition_penalty !== 1.0) {\n            processors.push(new _utils_generation_js__WEBPACK_IMPORTED_MODULE_3__.RepetitionPenaltyLogitsProcessor(generation_config.repetition_penalty));\n        }\n\n        if (generation_config.no_repeat_ngram_size !== null && generation_config.no_repeat_ngram_size > 0) {\n            processors.push(new _utils_generation_js__WEBPACK_IMPORTED_MODULE_3__.NoRepeatNGramLogitsProcessor(generation_config.no_repeat_ngram_size));\n        }\n\n        // if (generation_config.encoder_no_repeat_ngram_size !== null && generation_config.encoder_no_repeat_ngram_size > 0) {\n        //     if (this.config.is_encoder_decoder) {\n        //         processors.push(new EncoderNoRepeatNGramLogitsProcessor(\n        //             generation_config.encoder_no_repeat_ngram_size,\n        //             encoder_input_ids\n        //         ));\n        //     } else {\n        //         throw new Error(\"It's impossible to use `encoder_no_repeat_ngram_size` with decoder-only architecture\");\n        //     }\n        // }\n\n        // if (generation_config.bad_words_ids !== null) {\n        //     processors.push(new NoBadWordsLogitsProcessor(generation_config.bad_words_ids, generation_config.eos_token_id));\n        // }\n\n        // if (generation_config.min_length !== null && generation_config.eos_token_id !== null && generation_config.min_length > 0) {\n        //     processors.push(new MinLengthLogitsProcessor(generation_config.min_length, generation_config.eos_token_id));\n        // }\n\n        // if (generation_config.min_new_tokens !== null && generation_config.eos_token_id !== null && generation_config.min_new_tokens > 0) {\n        //     processors.push(new MinNewTokensLengthLogitsProcessor(\n        //         input_ids_seq_length,\n        //         generation_config.min_new_tokens,\n        //         generation_config.eos_token_id\n        //     ));\n        // }\n\n        // if (prefix_allowed_tokens_fn !== null) {\n        //     processors.push(new PrefixConstrainedLogitsProcessor(\n        //         prefix_allowed_tokens_fn,\n        //         generation_config.num_beams / generation_config.num_beam_groups\n        //     ));\n        // }\n\n\n        if (generation_config.forced_bos_token_id !== null) {\n            processors.push(new _utils_generation_js__WEBPACK_IMPORTED_MODULE_3__.ForcedBOSTokenLogitsProcessor(generation_config.forced_bos_token_id));\n        }\n\n        if (generation_config.forced_eos_token_id !== null) {\n            processors.push(new _utils_generation_js__WEBPACK_IMPORTED_MODULE_3__.ForcedEOSTokenLogitsProcessor(\n                generation_config.max_length,\n                generation_config.forced_eos_token_id\n            ));\n        }\n\n        // if (generation_config.remove_invalid_values === true) {\n        //     processors.push(new InfNanRemoveLogitsProcessor());\n        // }\n\n        // if (generation_config.exponential_decay_length_penalty !== null) {\n        //     processors.push(new ExponentialDecayLengthPenalty(\n        //         generation_config.exponential_decay_length_penalty,\n        //         generation_config.eos_token_id,\n        //         input_ids_seq_length\n        //     ));\n        // }\n\n        // if (generation_config.suppress_tokens !== null) {\n        //     processors.push(new SuppressTokensLogitsProcessor(generation_config.suppress_tokens));\n        // }\n\n        if (generation_config.begin_suppress_tokens !== null) {\n            let begin_index = (input_ids_seq_length > 1 || generation_config.forced_bos_token_id === null)\n                ? input_ids_seq_length\n                : input_ids_seq_length + 1;\n\n            if (generation_config.forced_decoder_ids !== null) {\n                // generation starts after the last token that is forced\n                begin_index += generation_config.forced_decoder_ids[generation_config.forced_decoder_ids.length - 1][0];\n            }\n            processors.push(new _utils_generation_js__WEBPACK_IMPORTED_MODULE_3__.SuppressTokensAtBeginLogitsProcessor(generation_config.begin_suppress_tokens, begin_index));\n        }\n\n        if (generation_config.forced_decoder_ids !== null) {\n            processors.push(new _utils_generation_js__WEBPACK_IMPORTED_MODULE_3__.ForceTokensLogitsProcessor(generation_config.forced_decoder_ids));\n        }\n\n        if (logits_processor !== null) {\n            processors.extend(logits_processor)\n        }\n\n        // `LogitNormalization` should always be the last logit processor, when present\n        // if (generation_config.renormalize_logits === true) {\n        //     processors.push(new LogitNormalization());\n        // }\n\n        return processors;\n    }\n\n    /**\n   * This function merges multiple generation configs together to form a final generation config to be used by the model for text generation.\n   * It first creates an empty `GenerationConfig` object, then it applies the model's own `generation_config` property to it. Finally, if a `generation_config` object was passed in the arguments, it overwrites the corresponding properties in the final config with those of the passed config object.\n   *\n   * @param {GenerationConfig} generation_config A `GenerationConfig` object containing generation parameters.\n   * @returns {GenerationConfig} The final generation config object to be used by the model for text generation.\n   */\n    _get_generation_config(generation_config) {\n        // Create empty generation config (contains defaults)\n        let gen_config = new _utils_generation_js__WEBPACK_IMPORTED_MODULE_3__.GenerationConfig();\n\n        // Apply model's generation config, if it exists\n        if ('generation_config' in this) {\n            Object.assign(gen_config, this.generation_config);\n        }\n\n        // Finally, use any generation config specified by the user\n        // when calling `generate`\n        if (generation_config !== null) {\n            Object.assign(gen_config, generation_config);\n        }\n        return gen_config;\n    }\n\n    /**\n     * @typedef {import('./utils/maths.js').TypedArray} TypedArray\n     */\n\n    /**\n     * @typedef {{ sequences: Tensor, decoder_attentions: Tensor, cross_attentions: Tensor }} EncoderDecoderOutput\n     * @typedef {Object} DecoderOutput\n     * \n     * Generates text based on the given inputs and generation configuration using the model.\n     * @param {Tensor|Array|TypedArray} inputs An array of input token IDs.\n     * @param {Object|GenerationConfig|null} generation_config The generation configuration to use. If null, default configuration will be used.\n     * @param {Object|null} logits_processor An optional logits processor to use. If null, a new LogitsProcessorList instance will be created.\n     * @param {Object} options options\n     * @param {Object} [options.inputs_attention_mask=null] An optional attention mask for the inputs.\n     * @returns {Promise<number[][]|EncoderDecoderOutput|DecoderOutput>} An array of generated output sequences, where each sequence is an array of token IDs.\n     * @throws {Error} Throws an error if the inputs array is empty.\n     */\n    async generate(\n        inputs,\n        generation_config = null,\n        logits_processor = null,\n        {\n            inputs_attention_mask = null\n        } = {},\n    ) {\n\n        if (!(inputs instanceof _utils_tensor_js__WEBPACK_IMPORTED_MODULE_4__.Tensor) && !(0,_utils_core_js__WEBPACK_IMPORTED_MODULE_1__.isTypedArray)(inputs) && !Array.isArray(inputs)) {\n            throw Error(`\\`inputs\\` must be a Tensor, TypedArray, or Array, but is \"${inputs.constructor.name}\".`);\n        }\n\n        let input_ids_seq_length;\n\n        // Prepare `input_ids` which will be used for auto-regressive generation\n        // TODO: Update to align with HF transformers' implementation\n        if (this.config.is_encoder_decoder) {\n            // Generating from the encoder outputs\n            input_ids_seq_length = 0;\n\n        } else {\n            input_ids_seq_length = inputs instanceof _utils_tensor_js__WEBPACK_IMPORTED_MODULE_4__.Tensor ? inputs.dims[0] : inputs.length;\n\n            // decoder-only\n            if (input_ids_seq_length === 0) {\n                throw Error(\"Must supply a non-empty array of input token ids.\")\n            }\n        }\n\n        // Update generation config with defaults\n        generation_config = this._get_generation_config(generation_config);\n\n        logits_processor = logits_processor ?? new _utils_generation_js__WEBPACK_IMPORTED_MODULE_3__.LogitsProcessorList()\n\n        // Update logits processor\n        logits_processor = this._get_logits_processor(\n            generation_config,\n            input_ids_seq_length,\n            logits_processor\n        )\n\n        // TODO implement early_stopping\n        // https://huggingface.co/blog/how-to-generate\n\n        let numOutputTokens = 1;\n        const maxOutputTokens = numOutputTokens + (generation_config.max_new_tokens ?? Infinity);\n\n        // Only use max length if max_new_tokens is not provided\n        const useMaxLength = Number.isInteger(generation_config.max_length) && (generation_config.max_new_tokens ?? null) === null;\n        let sampler = _utils_generation_js__WEBPACK_IMPORTED_MODULE_3__.Sampler.getSampler(generation_config);\n\n        // @ts-ignore\n        let beams = this.getStartBeams(inputs, numOutputTokens, inputs_attention_mask);\n\n        while (beams.some(x => !x.done) && numOutputTokens < maxOutputTokens) {\n            let newest_beams = [];\n            for (let beam of beams) {\n                if (beam.done) {\n                    // Add this beam back into the pool\n                    newest_beams.push(beam);\n                    continue\n                }\n                if (useMaxLength && beam.output_token_ids.length >= generation_config.max_length) {\n                    // Set this beam to done and add it back into the pool\n                    beam.done = true;\n                    newest_beams.push(beam);\n                    continue\n                }\n\n                // @ts-ignore\n                let output = await this.runBeam(beam);\n\n                // add attentions/scores to beam only if user requested\n                if (generation_config.output_attentions) {\n                    this.addAttentionsToBeam(beam, output);\n                }\n                if (generation_config.output_scores) {\n                    // TODO add\n                }\n\n                // Logits are of the form [batch_size, out_seq_length, vocab_size]\n                // In most cases, this will be [batch_size, 1, vocab_size]\n                // So, we select the last token's logits:\n                // (equivalent to `logits = outputs.logits[:, -1, :]`)\n                let logits = output.logits.slice(null, -1, null);\n\n                // Apply logits processor\n                logits_processor(beam.output_token_ids, logits);\n\n                let sampledTokens = sampler(logits);\n                for (let [newTokenId, logProb] of sampledTokens) {\n                    // use previous beam as a starting point\n                    let newBeam = { ...beam };\n\n                    // update new beam\n                    // @ts-ignore\n                    this.updateBeam(newBeam, newTokenId);\n\n                    newBeam.score += logProb;\n\n                    if (newTokenId === this.config.eos_token_id) {\n                        newBeam.done = true;\n                    }\n\n                    newest_beams.push(newBeam);\n                }\n            }\n            ++numOutputTokens;\n\n            // Next, we get the best beams, per ID\n            newest_beams = this.groupBeams(newest_beams).map(\n                group => group\n                    .sort((a, b) => b.score - a.score)      // sort by score\n                    .slice(0, generation_config.num_beams)  // remove outside beam width\n            );\n\n            // Flatten beams\n            beams = newest_beams.flat();\n\n            // Run callback\n            if (generation_config.callback_function) {\n                generation_config.callback_function(beams);\n            }\n        }\n\n        // TODO: Ensure that we can return non-batched outputs\n\n        const groupedBeams = this.groupBeams(beams);\n\n        const getFlattened = (key) => groupedBeams.map(\n            batch => {\n                if (generation_config.num_return_sequences > 1) {\n                    return batch.slice(0, generation_config.num_return_sequences).map(x => x[key]);\n                } else {\n                    return [batch[0][key]];\n                }\n            }\n        ).flat(); // Flatten across batches (depth=1)\n\n        const sequences = getFlattened('output_token_ids'); // [1, seqLength]\n\n        if (generation_config.return_dict_in_generate) {\n            // NOTE: `decoder_attentions` and `cross_attentions` should be:\n            //    list (one element for each generated token)\n            //    of list (one element for each layer of the decoder)\n            //    of torch.FloatTensor of shape (batch_size, num_heads, generated_length, sequence_length)\n            // However, since we are only generating one batch at a time, they are of the form:\n            //   list (batches)\n            //   of list (one element for each generated token)\n            //   of list (one element for each layer of the decoder)\n            //   of torch.FloatTensor of shape (1, num_heads, generated_length, sequence_length)\n            // \n            // TODO: In future (when true parallelism, we should be able to return the correct shape)\n\n            const decoder_attentions = getFlattened('decoder_attentions');\n            const cross_attentions = getFlattened('cross_attentions');\n\n            return {\n                sequences,\n\n                decoder_attentions,\n                cross_attentions,\n            }\n        } else {\n            return sequences;\n        }\n    }\n\n    /**\n     * Helper function to add attentions to beam\n     * @param {Object} beam \n     * @param {Object} output\n     * @private \n     */\n    addAttentionsToBeam(beam, output) {\n        if (this.config.is_encoder_decoder) {\n            if (!output.cross_attentions || output.cross_attentions.length === 0) {\n                throw Error(\n                    \"`output_attentions` is true, but the model did not produce cross-attentions. \" +\n                    \"This is most likely because the model was not exported with `output_attentions=True`.\"\n                )\n            }\n            if (!beam.cross_attentions) {\n                beam.cross_attentions = [];\n            }\n            beam.cross_attentions.push(output.cross_attentions);\n        }\n\n        if (!output.decoder_attentions || output.decoder_attentions.length === 0) {\n            throw Error(\n                \"`output_attentions` is true, but the model did not produce decoder-attentions. \" +\n                \"This is most likely because the model was not exported with `output_attentions=True`.\"\n            )\n        }\n        if (!beam.decoder_attentions) {\n            beam.decoder_attentions = [];\n        }\n        beam.decoder_attentions.push(output.decoder_attentions);\n    }\n\n    /**\n     * Groups an array of beam objects by their ids.\n     *\n     * @param {Array} beams The array of beam objects to group.\n     * @returns {Array} An array of arrays, where each inner array contains beam objects with the same id.\n     */\n    groupBeams(beams) {\n        // Group beams by their ids\n        const groups = Object.create(null);\n        for (const obj of beams) {\n            if (groups[obj.id] === undefined) {\n                groups[obj.id] = [obj];\n            } else {\n                groups[obj.id].push(obj);\n            }\n        }\n\n        return Object.values(groups);\n    }\n\n    /**\n     * Returns an object containing past key values from the given decoder results object.\n     *\n     * @param {Object} decoderResults The decoder results object.\n     * @param {Object} pastKeyValues The previous past key values.\n     * @returns {Object} An object containing past key values.\n     * @private\n     */\n    getPastKeyValues(decoderResults, pastKeyValues) {\n\n        const pkvs = Object.create(null);\n\n        for (const name in decoderResults) {\n            if (name.startsWith('present')) {\n                let newName = name.replace('present', 'past_key_values');\n\n                if (pastKeyValues && name.includes('encoder')) {\n                    // Optimization introduced by optimum to reuse past key values. So, we just replace the constant\n                    // outputs with the previous past key values.\n                    // https://github.com/huggingface/optimum/blob/0bf2c05fb7e1182b52d21b703cfc95fd9e4ea3dc/optimum/onnxruntime/base.py#L677-L704\n                    pkvs[newName] = pastKeyValues[newName];\n                } else {\n                    pkvs[newName] = decoderResults[name];\n                }\n            }\n        }\n        return pkvs;\n    }\n\n    /**\n     * Returns an object containing attentions from the given decoder results object.\n     *\n     * @param {Object} decoderResults The decoder results object.\n     * @returns {Object} An object containing attentions.\n     * @private\n     */\n    getAttentions(decoderResults) {\n        const attns = Object.create(null);\n\n        for (const attnName of ['cross_attentions', 'decoder_attentions']) {\n            const result = [];\n            for (const name in decoderResults) {\n                if (name.startsWith(attnName)) {\n                    const index = name.split('.').pop()\n                    result[index] = decoderResults[name];\n                }\n            }\n            attns[attnName] = result;\n        }\n        return attns;\n    }\n\n    /**\n     * Adds past key values to the decoder feeds object. If pastKeyValues is null, creates new tensors for past key values.\n     *\n     * @param {Object} decoderFeeds The decoder feeds object to add past key values to.\n     * @param {Object} pastKeyValues An object containing past key values.\n     * @param {boolean} [hasDecoder=false] Whether the model has a decoder.\n     */\n    addPastKeyValues(decoderFeeds, pastKeyValues, hasDecoder = false) {\n        if (pastKeyValues) {\n            Object.assign(decoderFeeds, pastKeyValues)\n        } else {\n            // TODO support batches (i.e., batch_size > 1)\n            if (hasDecoder) {\n                // @ts-ignore\n                let encoder_dims = [1, this.num_encoder_heads, 0, this.encoder_dim_kv];\n                // @ts-ignore\n                for (let i = 0; i < this.num_encoder_layers; ++i) {\n                    decoderFeeds[`past_key_values.${i}.encoder.key`] = new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_4__.Tensor('float32', [], encoder_dims)\n                    decoderFeeds[`past_key_values.${i}.encoder.value`] = new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_4__.Tensor('float32', [], encoder_dims)\n                }\n\n                // @ts-ignore\n                let decoder_dims = [1, this.num_decoder_heads, 0, this.decoder_dim_kv];\n                // @ts-ignore\n                for (let i = 0; i < this.num_decoder_layers; ++i) {\n                    decoderFeeds[`past_key_values.${i}.decoder.key`] = new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_4__.Tensor('float32', [], decoder_dims)\n                    decoderFeeds[`past_key_values.${i}.decoder.value`] = new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_4__.Tensor('float32', [], decoder_dims)\n                }\n\n            } else {\n                // @ts-ignore\n                let dims = [1, this.num_heads, 0, this.dim_kv]\n                // @ts-ignore\n                for (let i = 0; i < this.num_layers; ++i) {\n                    decoderFeeds[`past_key_values.${i}.key`] = new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_4__.Tensor('float32', [], dims)\n                    decoderFeeds[`past_key_values.${i}.value`] = new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_4__.Tensor('float32', [], dims)\n                }\n            }\n        }\n    }\n}\n//////////////////////////////////////////////////\n// Base model output class\nclass ModelOutput { }\n\n/**\n * Base class for model's outputs, with potential hidden states and attentions.\n */\nclass BaseModelOutput extends ModelOutput {\n    /**\n     * @param {Object} output The output of the model.\n     * @param {Tensor} output.last_hidden_state Sequence of hidden-states at the output of the last layer of the model.\n     * @param {Tensor} [output.hidden_states] Hidden-states of the model at the output of each layer plus the optional initial embedding outputs.\n     * @param {Tensor} [output.attentions] Attentions weights after the attention softmax, used to compute the weighted average in the self-attention heads.\n     */\n    constructor({ last_hidden_state, hidden_states = null, attentions = null }) {\n        super();\n        this.last_hidden_state = last_hidden_state;\n        this.hidden_states = hidden_states;\n        this.attentions = attentions;\n    }\n}\n//////////////////////////////////////////////////\n// Bert models\nclass BertPreTrainedModel extends PreTrainedModel { }\nclass BertModel extends BertPreTrainedModel { }\n\n/**\n * BertForMaskedLM is a class representing a BERT model for masked language modeling.\n * @extends BertPreTrainedModel\n */\nclass BertForMaskedLM extends BertPreTrainedModel {\n    /**\n     * Calls the model on new inputs.\n     *\n     * @param {Object} model_inputs The inputs to the model.\n     * @returns {Promise<MaskedLMOutput>} An object containing the model's output logits for masked language modeling.\n     */\n    async _call(model_inputs) {\n        return new MaskedLMOutput(await super._call(model_inputs));\n    }\n}\n\n/**\n * BertForSequenceClassification is a class representing a BERT model for sequence classification.\n * @extends BertPreTrainedModel\n */\nclass BertForSequenceClassification extends BertPreTrainedModel {\n    /**\n     * Calls the model on new inputs.\n     *\n     * @param {Object} model_inputs The inputs to the model.\n     * @returns {Promise<SequenceClassifierOutput>} An object containing the model's output logits for sequence classification.\n     */\n    async _call(model_inputs) {\n        return new SequenceClassifierOutput(await super._call(model_inputs));\n    }\n}\n\n/**\n * BertForTokenClassification is a class representing a BERT model for token classification.\n * @extends BertPreTrainedModel\n */\nclass BertForTokenClassification extends BertPreTrainedModel {\n    /**\n     * Calls the model on new inputs.\n     *\n     * @param {Object} model_inputs The inputs to the model.\n     * @returns {Promise<TokenClassifierOutput>} An object containing the model's output logits for token classification.\n     */\n    async _call(model_inputs) {\n        return new TokenClassifierOutput(await super._call(model_inputs));\n    }\n}\n\n/**\n * BertForQuestionAnswering is a class representing a BERT model for question answering.\n * @extends BertPreTrainedModel\n */\nclass BertForQuestionAnswering extends BertPreTrainedModel {\n    /**\n     * Calls the model on new inputs.\n     *\n     * @param {Object} model_inputs The inputs to the model.\n     * @returns {Promise<QuestionAnsweringModelOutput>} An object containing the model's output logits for question answering.\n     */\n    async _call(model_inputs) {\n        return new QuestionAnsweringModelOutput(await super._call(model_inputs));\n    }\n}\n//////////////////////////////////////////////////\n\n//////////////////////////////////////////////////\n// DistilBert models\nclass DistilBertPreTrainedModel extends PreTrainedModel { }\nclass DistilBertModel extends DistilBertPreTrainedModel { }\n\n/**\n * DistilBertForSequenceClassification is a class representing a DistilBERT model for sequence classification.\n * @extends DistilBertPreTrainedModel\n */\nclass DistilBertForSequenceClassification extends DistilBertPreTrainedModel {\n    /**\n     * Calls the model on new inputs.\n     *\n     * @param {Object} model_inputs The inputs to the model.\n     * @returns {Promise<SequenceClassifierOutput>} An object containing the model's output logits for sequence classification.\n     */\n    async _call(model_inputs) {\n        return new SequenceClassifierOutput(await super._call(model_inputs));\n    }\n}\n\n/**\n * DistilBertForTokenClassification is a class representing a DistilBERT model for token classification.\n * @extends DistilBertPreTrainedModel\n */\nclass DistilBertForTokenClassification extends DistilBertPreTrainedModel {\n    /**\n     * Calls the model on new inputs.\n     *\n     * @param {Object} model_inputs The inputs to the model.\n     * @returns {Promise<TokenClassifierOutput>} An object containing the model's output logits for token classification.\n     */\n    async _call(model_inputs) {\n        return new TokenClassifierOutput(await super._call(model_inputs));\n    }\n}\n\n\n/**\n * DistilBertForQuestionAnswering is a class representing a DistilBERT model for question answering.\n * @extends DistilBertPreTrainedModel\n */\nclass DistilBertForQuestionAnswering extends DistilBertPreTrainedModel {\n    /**\n     * Calls the model on new inputs.\n     *\n     * @param {Object} model_inputs The inputs to the model.\n     * @returns {Promise<QuestionAnsweringModelOutput>} An object containing the model's output logits for question answering.\n     */\n    async _call(model_inputs) {\n        return new QuestionAnsweringModelOutput(await super._call(model_inputs));\n    }\n}\n\n/**\n * DistilBertForMaskedLM is a class representing a DistilBERT model for masking task.\n * @extends DistilBertPreTrainedModel\n */\nclass DistilBertForMaskedLM extends DistilBertPreTrainedModel {\n    /**\n     * Calls the model on new inputs.\n     *\n     * @param {Object} model_inputs The inputs to the model.\n     * @returns {Promise<MaskedLMOutput>} returned object\n     */\n    async _call(model_inputs) {\n        return new MaskedLMOutput(await super._call(model_inputs));\n    }\n}\n//////////////////////////////////////////////////\n\n\n//////////////////////////////////////////////////\n// MobileBert models\nclass MobileBertPreTrainedModel extends PreTrainedModel { }\nclass MobileBertModel extends MobileBertPreTrainedModel { }\n\n/**\n * MobileBertForMaskedLM is a class representing a MobileBERT model for masking task.\n * @extends MobileBertPreTrainedModel\n */\nclass MobileBertForMaskedLM extends MobileBertPreTrainedModel {\n    /**\n     * Calls the model on new inputs.\n     *\n     * @param {Object} model_inputs The inputs to the model.\n     * @returns {Promise<MaskedLMOutput>} returned object\n     */\n    async _call(model_inputs) {\n        return new MaskedLMOutput(await super._call(model_inputs));\n    }\n}\n\n/**\n * @extends MobileBertPreTrainedModel\n */\nclass MobileBertForSequenceClassification extends MobileBertPreTrainedModel {\n    /**\n     * Calls the model on new inputs.\n     *\n     * @param {Object} model_inputs The inputs to the model.\n     * @returns {Promise<SequenceClassifierOutput>} returned object\n     */\n    async _call(model_inputs) {\n        return new SequenceClassifierOutput(await super._call(model_inputs));\n    }\n}\n\n/**\n * @extends MobileBertPreTrainedModel\n */\nclass MobileBertForQuestionAnswering extends MobileBertPreTrainedModel {\n    /**\n     * Calls the model on new inputs.\n     *\n     * @param {Object} model_inputs The inputs to the model.\n     * @returns {Promise<QuestionAnsweringModelOutput>} returned object\n     */\n    async _call(model_inputs) {\n        return new QuestionAnsweringModelOutput(await super._call(model_inputs));\n    }\n}\n//////////////////////////////////////////////////\n\n\n//////////////////////////////////////////////////\n// SqueezeBert models\nclass SqueezeBertPreTrainedModel extends PreTrainedModel { }\nclass SqueezeBertModel extends SqueezeBertPreTrainedModel { }\nclass SqueezeBertForMaskedLM extends SqueezeBertPreTrainedModel {\n    /**\n     * Calls the model on new inputs.\n     *\n     * @param {Object} model_inputs The inputs to the model.\n     * @returns {Promise<MaskedLMOutput>} returned object\n     */\n    async _call(model_inputs) {\n        return new MaskedLMOutput(await super._call(model_inputs));\n    }\n}\nclass SqueezeBertForSequenceClassification extends SqueezeBertPreTrainedModel {\n    /**\n     * Calls the model on new inputs.\n     *\n     * @param {Object} model_inputs The inputs to the model.\n     * @returns {Promise<SequenceClassifierOutput>} returned object\n     */\n    async _call(model_inputs) {\n        return new SequenceClassifierOutput(await super._call(model_inputs));\n    }\n}\nclass SqueezeBertForQuestionAnswering extends SqueezeBertPreTrainedModel {\n    /**\n     * Calls the model on new inputs.\n     *\n     * @param {Object} model_inputs The inputs to the model.\n     * @returns {Promise<QuestionAnsweringModelOutput>} returned object\n     */\n    async _call(model_inputs) {\n        return new QuestionAnsweringModelOutput(await super._call(model_inputs));\n    }\n}\n//////////////////////////////////////////////////\n\n\n//////////////////////////////////////////////////\n// Albert models\nclass AlbertPreTrainedModel extends PreTrainedModel { }\nclass AlbertModel extends AlbertPreTrainedModel { }\nclass AlbertForSequenceClassification extends AlbertPreTrainedModel {\n    /**\n     * Calls the model on new inputs.\n     *\n     * @param {Object} model_inputs The inputs to the model.\n     * @returns {Promise<SequenceClassifierOutput>} returned object\n     */\n    async _call(model_inputs) {\n        return new SequenceClassifierOutput(await super._call(model_inputs));\n    }\n}\nclass AlbertForQuestionAnswering extends AlbertPreTrainedModel {\n    /**\n     * Calls the model on new inputs.\n     *\n     * @param {Object} model_inputs The inputs to the model.\n     * @returns {Promise<QuestionAnsweringModelOutput>} returned object\n     */\n    async _call(model_inputs) {\n        return new QuestionAnsweringModelOutput(await super._call(model_inputs));\n    }\n}\nclass AlbertForMaskedLM extends AlbertPreTrainedModel {\n    /**\n     * Calls the model on new inputs.\n     *\n     * @param {Object} model_inputs The inputs to the model.\n     * @returns {Promise<MaskedLMOutput>} returned object\n     */\n    async _call(model_inputs) {\n        return new MaskedLMOutput(await super._call(model_inputs));\n    }\n}\n//////////////////////////////////////////////////\n\n\n//////////////////////////////////////////////////\n// T5 models\nclass T5PreTrainedModel extends PreTrainedModel { };\n\nclass T5Model extends T5PreTrainedModel {\n    /**\n     * Generates text based on the provided arguments.\n     * @throws {Error} Throws an error as the current model class (T5Model) is not compatible with `.generate()`.\n     * @returns {Promise<any>}\n     * @param {any[]} args\n     */\n    async generate(...args) {\n        throw Error(\n            \"The current model class (T5Model) is not compatible with `.generate()`, as it doesn't have a language model head. Please use one of the following classes instead: {'T5ForConditionalGeneration'}\"\n        )\n    }\n}\n\n/**\n * T5Model is a class representing a T5 model for conditional generation.\n * @extends T5PreTrainedModel\n */\nclass T5ForConditionalGeneration extends T5PreTrainedModel {\n\n    /**\n     * Creates a new instance of the `T5ForConditionalGeneration` class.\n     * @param {Object} config The model configuration.\n     * @param {any} session session for the model.\n     * @param {any} decoder_merged_session session for the decoder.\n     * @param {GenerationConfig} generation_config The generation configuration.\n     */\n    constructor(config, session, decoder_merged_session, generation_config) {\n        super(config, session);\n        this.decoder_merged_session = decoder_merged_session;\n        this.generation_config = generation_config;\n\n        this.num_decoder_layers = this.config.num_decoder_layers;\n        this.num_decoder_heads = this.config.num_heads;\n        this.decoder_dim_kv = this.config.d_kv;\n\n        this.num_encoder_layers = this.config.num_layers;\n        this.num_encoder_heads = this.config.num_heads;\n        this.encoder_dim_kv = this.config.d_kv;\n    }\n\n    /**\n     * Generates the start beams for a given set of inputs and output length.\n     * @param {number[][]} inputs The input token IDs.\n     * @param {number} numOutputTokens The desired output length.\n     * @returns {Array} The start beams.\n     */\n    getStartBeams(inputs, numOutputTokens, ...args) {\n        return seq2seqStartBeams(this, inputs, numOutputTokens);\n    }\n\n    /**\n     * Runs a single step of the beam search generation algorithm.\n     * @param {any} beam The current beam being generated.\n     * @returns {Promise<any>} The updated beam after a single generation step.\n     */\n    async runBeam(beam) {\n        return await seq2seqRunBeam(this, beam);\n    }\n\n    /**\n     * Updates the given beam with a new token ID.\n     * @param {any} beam The current beam.\n     * @param {number} newTokenId The new token ID to add to the output sequence.\n     */\n    updateBeam(beam, newTokenId) {\n        beam.output_token_ids = [...beam.output_token_ids, newTokenId];\n    }\n\n    /**\n     * Runs the forward pass of the model for a given set of inputs.\n     * @param {Object} model_inputs The model inputs.\n     * @returns {Promise<Object>} The model output.\n     */\n    async forward(model_inputs) {\n        return await seq2seqForward(this, model_inputs);\n    }\n}\n//////////////////////////////////////////////////\n\n//////////////////////////////////////////////////\n// MT5 models\nclass MT5PreTrainedModel extends PreTrainedModel { };\n\nclass MT5Model extends MT5PreTrainedModel {\n    /**\n     * \n     * @param  {...any} args\n     * @returns {Promise<any>}\n     * @throws {Error}\n     */\n    async generate(...args) {\n        throw Error(\n            \"The current model class (MT5Model) is not compatible with `.generate()`, as it doesn't have a language model head. Please use one of the following classes instead: {'MT5ForConditionalGeneration'}\"\n        )\n    }\n}\n\n/**\n * A class representing a conditional sequence-to-sequence model based on the MT5 architecture.\n *\n * @extends MT5PreTrainedModel\n */\nclass MT5ForConditionalGeneration extends MT5PreTrainedModel {\n\n    /**\n     * Creates a new instance of the `MT5ForConditionalGeneration` class.\n     * @param {any} config The model configuration.\n     * @param {any} session The ONNX session containing the encoder weights.\n     * @param {any} decoder_merged_session The ONNX session containing the merged decoder weights.\n     * @param {GenerationConfig} generation_config The generation configuration.\n     */\n    constructor(config, session, decoder_merged_session, generation_config) {\n        super(config, session);\n        this.decoder_merged_session = decoder_merged_session;\n        this.generation_config = generation_config;\n\n        this.num_decoder_layers = this.config.num_decoder_layers;\n        this.num_decoder_heads = this.config.num_heads;\n        this.decoder_dim_kv = this.config.d_kv;\n\n        this.num_encoder_layers = this.config.num_layers;\n        this.num_encoder_heads = this.config.num_heads;\n        this.encoder_dim_kv = this.config.d_kv;\n    }\n\n    /**\n   * Generates the start beams for the given input tokens and output sequence length.\n   *\n   * @param {any[]} inputs The input sequence.\n   * @param {number} numOutputTokens The desired length of the output sequence.\n   * @param {...*} args Additional arguments to pass to the `seq2seqStartBeams` function.\n   * @returns {any[]} An array of `Beam` objects representing the start beams.\n   */\n    getStartBeams(inputs, numOutputTokens, ...args) {\n        return seq2seqStartBeams(this, inputs, numOutputTokens);\n    }\n\n    /**\n     * Runs a single step of the beam search generation algorithm.\n     * @param {any} beam The current beam being generated.\n     * @returns {Promise<any>} The updated beam after a single generation step.\n     */\n    async runBeam(beam) {\n        return await seq2seqRunBeam(this, beam);\n    }\n\n    /**\n     * Updates the given beam with the new predicted token.\n     * @param {any} beam The beam to update.\n     * @param {number} newTokenId The index of the predicted token.\n    */\n    updateBeam(beam, newTokenId) {\n        beam.output_token_ids = [...beam.output_token_ids, newTokenId];\n    }\n\n    /**\n    * Runs the forward pass of the model on the given inputs.\n    * @param {any} model_inputs The model inputs.\n    * @returns {Promise<any>} A Promise that resolves to the model outputs.\n    */\n    async forward(model_inputs) {\n        return await seq2seqForward(this, model_inputs);\n    }\n}\n//////////////////////////////////////////////////\n\n//////////////////////////////////////////////////\n// Bart models\nclass BartPretrainedModel extends PreTrainedModel { };\n\n/**\n * BART encoder and decoder model.\n * \n * @hideconstructor\n * @extends BartPretrainedModel\n */\nclass BartModel extends BartPretrainedModel {\n    /**\n     * Throws an error because the current model class (BartModel) is not compatible with `.generate()`.\n     * \n     * @throws {Error} The current model class (BartModel) is not compatible with `.generate()`.\n     * @returns {Promise<any>}\n     */\n    async generate(...args) {\n        throw Error(\n            \"The current model class (BartModel) is not compatible with `.generate()`, as it doesn't have a language model head. Please use one of the following classes instead: {'BartForConditionalGeneration'}\"\n        )\n    }\n}\n\n/**\n * BART model with a language model head for conditional generation.\n * @extends BartPretrainedModel\n */\nclass BartForConditionalGeneration extends BartPretrainedModel {\n\n    /**\n     * Creates a new instance of the `BartForConditionalGeneration` class.\n     * @param {Object} config The configuration object for the Bart model.\n     * @param {Object} session The ONNX session used to execute the model.\n     * @param {Object} decoder_merged_session The ONNX session used to execute the decoder.\n     * @param {Object} generation_config The generation configuration object.\n     */\n    constructor(config, session, decoder_merged_session, generation_config) {\n        super(config, session);\n        this.decoder_merged_session = decoder_merged_session;\n        this.generation_config = generation_config;\n\n        this.num_decoder_layers = this.config.decoder_layers;\n        this.num_decoder_heads = this.config.decoder_attention_heads;\n        this.decoder_dim_kv = this.config.d_model / this.num_decoder_heads;\n\n        this.num_encoder_layers = this.config.encoder_layers;\n        this.num_encoder_heads = this.config.encoder_attention_heads;\n        this.encoder_dim_kv = this.config.d_model / this.num_encoder_heads;\n    }\n\n    /**\n     * Returns the initial beam for generating output text.\n     * @param {Object} inputs The input object containing the encoded input text.\n     * @param {number} numOutputTokens The maximum number of output tokens to generate.\n     * @param  {...any} args Additional arguments to pass to the sequence-to-sequence generation function.\n     * @returns {any} The initial beam for generating output text.\n     */\n    getStartBeams(inputs, numOutputTokens, ...args) {\n        return seq2seqStartBeams(this, inputs, numOutputTokens);\n    }\n\n    /**\n     * Runs a single step of the beam search generation algorithm.\n     * @param {any} beam The current beam being generated.\n     * @returns {Promise<any>} The updated beam after a single generation step.\n     */\n    async runBeam(beam) {\n        return await seq2seqRunBeam(this, beam);\n    }\n\n    /**\n     * Updates the beam by appending the newly generated token ID to the list of output token IDs.\n     * @param {any} beam The current beam being generated.\n     * @param {number} newTokenId The ID of the newly generated token to append to the list of output token IDs.\n     */\n    updateBeam(beam, newTokenId) {\n        beam.output_token_ids = [...beam.output_token_ids, newTokenId];\n    }\n\n    /**\n     * Runs the forward pass of the model for a given set of inputs.\n     * @param {Object} model_inputs The model inputs.\n     * @returns {Promise<Object>} The model output.\n     */\n    async forward(model_inputs) {\n        return await seq2seqForward(this, model_inputs);\n    }\n}\n\nclass BartForSequenceClassification extends BartPretrainedModel {\n    /**\n     * Calls the model on new inputs.\n     *\n     * @param {Object} model_inputs The inputs to the model.\n     * @returns {Promise<SequenceClassifierOutput>} An object containing the model's output logits for sequence classification.\n     */\n    async _call(model_inputs) {\n        return new SequenceClassifierOutput(await super._call(model_inputs));\n    }\n}\n\n//////////////////////////////////////////////////\n\n//////////////////////////////////////////////////\n// Roberta models\nclass RobertaPreTrainedModel extends PreTrainedModel { }\nclass RobertaModel extends RobertaPreTrainedModel { }\n\n/**\n * RobertaForMaskedLM class for performing masked language modeling on Roberta models.\n * @extends RobertaPreTrainedModel\n */\nclass RobertaForMaskedLM extends RobertaPreTrainedModel {\n    /**\n     * Calls the model on new inputs.\n     *\n     * @param {Object} model_inputs The inputs to the model.\n     * @returns {Promise<MaskedLMOutput>} returned object\n     */\n    async _call(model_inputs) {\n        return new MaskedLMOutput(await super._call(model_inputs));\n    }\n}\n\n/**\n * RobertaForSequenceClassification class for performing sequence classification on Roberta models.\n * @extends RobertaPreTrainedModel\n */\nclass RobertaForSequenceClassification extends RobertaPreTrainedModel {\n    /**\n     * Calls the model on new inputs.\n     *\n     * @param {Object} model_inputs The inputs to the model.\n     * @returns {Promise<SequenceClassifierOutput>} returned object\n     */\n    async _call(model_inputs) {\n        return new SequenceClassifierOutput(await super._call(model_inputs));\n    }\n}\n\n/**\n * RobertaForTokenClassification class for performing token classification on Roberta models.\n * @extends RobertaPreTrainedModel\n */\nclass RobertaForTokenClassification extends RobertaPreTrainedModel {\n    /**\n     * Calls the model on new inputs.\n     *\n     * @param {Object} model_inputs The inputs to the model.\n     * @returns {Promise<TokenClassifierOutput>} An object containing the model's output logits for token classification.\n     */\n    async _call(model_inputs) {\n        return new TokenClassifierOutput(await super._call(model_inputs));\n    }\n}\n\n/**\n * RobertaForQuestionAnswering class for performing question answering on Roberta models.\n * @extends RobertaPreTrainedModel\n */\nclass RobertaForQuestionAnswering extends RobertaPreTrainedModel {\n    /**\n     * Calls the model on new inputs.\n     *\n     * @param {Object} model_inputs The inputs to the model.\n     * @returns {Promise<QuestionAnsweringModelOutput>} returned object\n     */\n    async _call(model_inputs) {\n        return new QuestionAnsweringModelOutput(await super._call(model_inputs));\n    }\n}\n//////////////////////////////////////////////////\n\n//////////////////////////////////////////////////\n// XLMRoberta models\nclass XLMRobertaPreTrainedModel extends PreTrainedModel { }\nclass XLMRobertaModel extends XLMRobertaPreTrainedModel { }\n\n/**\n * XLMRobertaForMaskedLM class for performing masked language modeling on XLMRoberta models.\n * @extends XLMRobertaPreTrainedModel\n */\nclass XLMRobertaForMaskedLM extends XLMRobertaPreTrainedModel {\n    /**\n     * Calls the model on new inputs.\n     *\n     * @param {Object} model_inputs The inputs to the model.\n     * @returns {Promise<MaskedLMOutput>} returned object\n     */\n    async _call(model_inputs) {\n        return new MaskedLMOutput(await super._call(model_inputs));\n    }\n}\n\n/**\n * XLMRobertaForSequenceClassification class for performing sequence classification on XLMRoberta models.\n * @extends XLMRobertaPreTrainedModel\n */\nclass XLMRobertaForSequenceClassification extends XLMRobertaPreTrainedModel {\n    /**\n     * Calls the model on new inputs.\n     *\n     * @param {Object} model_inputs The inputs to the model.\n     * @returns {Promise<SequenceClassifierOutput>} returned object\n     */\n    async _call(model_inputs) {\n        return new SequenceClassifierOutput(await super._call(model_inputs));\n    }\n}\n\n/**\n * XLMRobertaForTokenClassification class for performing token classification on XLMRoberta models.\n * @extends XLMRobertaPreTrainedModel\n */\nclass XLMRobertaForTokenClassification extends XLMRobertaPreTrainedModel {\n    /**\n     * Calls the model on new inputs.\n     *\n     * @param {Object} model_inputs The inputs to the model.\n     * @returns {Promise<TokenClassifierOutput>} An object containing the model's output logits for token classification.\n     */\n    async _call(model_inputs) {\n        return new TokenClassifierOutput(await super._call(model_inputs));\n    }\n}\n\n/**\n * XLMRobertaForQuestionAnswering class for performing question answering on XLMRoberta models.\n * @extends XLMRobertaPreTrainedModel\n */\nclass XLMRobertaForQuestionAnswering extends XLMRobertaPreTrainedModel {\n    /**\n     * Calls the model on new inputs.\n     *\n     * @param {Object} model_inputs The inputs to the model.\n     * @returns {Promise<QuestionAnsweringModelOutput>} returned object\n     */\n    async _call(model_inputs) {\n        return new QuestionAnsweringModelOutput(await super._call(model_inputs));\n    }\n}\n//////////////////////////////////////////////////\n\n//////////////////////////////////////////////////\n// T5 models\nclass WhisperPreTrainedModel extends PreTrainedModel { };\n\n/**\n * WhisperModel class for training Whisper models without a language model head.\n * @extends WhisperPreTrainedModel\n */\nclass WhisperModel extends WhisperPreTrainedModel {\n    /**\n     * Throws an error when attempting to generate output since this model doesn't have a language model head.\n     * @throws Error\n     * @returns {Promise<any>}\n     * @param {any[]} args\n     */\n    async generate(...args) {\n        throw Error(\n            \"The current model class (WhisperModel) is not compatible with `.generate()`, as it doesn't have a language model head. Please use one of the following classes instead: {'WhisperForConditionalGeneration'}\"\n        )\n    }\n}\n\n/**\n * WhisperForConditionalGeneration class for generating conditional outputs from Whisper models.\n * @extends WhisperPreTrainedModel\n */\nclass WhisperForConditionalGeneration extends WhisperPreTrainedModel {\n\n    /**\n     * Creates a new instance of the `WhisperForConditionalGeneration` class.\n     * @param {Object} config Configuration object for the model.\n     * @param {Object} session ONNX Session object for the model.\n     * @param {Object} decoder_merged_session ONNX Session object for the decoder.\n     * @param {Object} generation_config Configuration object for the generation process.\n     */\n    constructor(config, session, decoder_merged_session, generation_config) {\n        super(config, session);\n        this.decoder_merged_session = decoder_merged_session;\n        this.generation_config = generation_config;\n\n        this.num_decoder_layers = this.config.decoder_layers;\n        this.num_decoder_heads = this.config.decoder_attention_heads;\n        this.decoder_dim_kv = this.config.d_model / this.num_decoder_heads;\n\n        this.num_encoder_layers = this.config.encoder_layers;\n        this.num_encoder_heads = this.config.encoder_attention_heads;\n        this.encoder_dim_kv = this.config.d_model / this.num_encoder_heads;\n\n\n    }\n\n    /**\n     * Generates outputs based on input and generation configuration.\n     * @param {Object} inputs Input data for the model.\n     * @param {Object} generation_config Configuration object for the generation process.\n     * @param {Object} logits_processor Optional logits processor object.\n     * @param {Object} options options\n     * @param {Object} [options.return_timestamps=null] Whether to return the timestamps with the text. This enables the `WhisperTimestampsLogitsProcessor`.\n     * @param {Object} [options.return_token_timestamps=null] Whether to return token-level timestamps\n     * with the text. This can be used with or without the `return_timestamps` option. To get word-level\n     * timestamps, use the tokenizer to group the tokens into words.\n     * @returns {Promise<Object>} Promise object represents the generated outputs.\n     */\n    // @ts-ignore\n    async generate(\n        inputs,\n        generation_config = null,\n        logits_processor = null,\n        // {\n        //     return_timestamps = null,\n        //     return_token_timestamps = null,\n        //     language = null,\n        //     task = null,\n        // } = {},\n    ) {\n        // Create generation config object\n        generation_config = this._get_generation_config(generation_config);\n\n\n        // Whisper has additional options for returning timestamps\n        generation_config.return_timestamps ??= false;\n\n        // TODO add language and task\n\n        if (generation_config.return_timestamps) {\n            logits_processor = [new _utils_generation_js__WEBPACK_IMPORTED_MODULE_3__.WhisperTimeStampLogitsProcessor(generation_config)]\n        }\n\n        if (generation_config.return_token_timestamps) {\n            generation_config.output_attentions = true;\n            generation_config.return_dict_in_generate = true;\n\n            if (generation_config.task === 'translate') {\n                console.warn(\"Token-level timestamps may not be reliable for task 'translate'.\")\n            }\n\n            if (!generation_config.alignment_heads) {\n                throw new Error(\n                    \"Model generation config has no `alignment_heads`, token-level timestamps not available. \" +\n                    \"See https://gist.github.com/hollance/42e32852f24243b748ae6bc1f985b13a on how to add this property to the generation config.\"\n                )\n            }\n        }\n\n        const outputs = await super.generate(inputs, generation_config, logits_processor);\n\n        if (generation_config.return_token_timestamps && generation_config.alignment_heads) {\n            outputs[\"token_timestamps\"] = this._extract_token_timestamps(outputs, generation_config.alignment_heads)\n        }\n\n        return outputs\n    }\n\n    /**\n     * Gets the start beams for generating outputs.\n     * @param {Array} inputTokenIds Array of input token IDs.\n     * @param {number} numOutputTokens Number of output tokens to generate.\n     * @returns {Array} Array of start beams.\n     */\n    getStartBeams(inputTokenIds, numOutputTokens, ...args) {\n        // arguments ignored in this case\n        return seq2seqStartBeams(this, inputTokenIds, numOutputTokens, false);\n    }\n\n    /**\n     * Runs a single step of the beam search generation algorithm.\n     * @param {any} beam The current beam being generated.\n     * @returns {Promise<any>} The updated beam after a single generation step.\n     */\n    async runBeam(beam) {\n        return await seq2seqRunBeam(this, beam, {\n            input_name: 'input_features',\n        });\n    }\n\n    /**\n     * Updates the beam by appending the newly generated token ID to the list of output token IDs.\n     * @param {any} beam The current beam being generated.\n     * @param {number} newTokenId The ID of the newly generated token to append to the list of output token IDs.\n     */\n    updateBeam(beam, newTokenId) {\n        beam.output_token_ids = [...beam.output_token_ids, newTokenId];\n    }\n\n    /**\n     * Runs the forward pass of the model for a given set of inputs.\n     * @param {Object} model_inputs The model inputs.\n     * @returns {Promise<Object>} The model output.\n     */\n    async forward(model_inputs) {\n        return await seq2seqForward(this, model_inputs);\n    }\n\n    /**\n     * Calculates token-level timestamps using the encoder-decoder cross-attentions and\n     * dynamic time-warping (DTW) to map each output token to a position in the input audio.\n     * @param {Object} generate_outputs Outputs generated by the model\n     * @param {Tensor[][][]} generate_outputs.cross_attentions The cross attentions output by the model\n     * @param {Tensor[][][]} generate_outputs.decoder_attentions The decoder attentions output by the model\n     * @param {number[][]} generate_outputs.sequences The sequences output by the model\n     * @param {number[][]} alignment_heads Alignment heads of the model\n     * @param {number} time_precision Precision of the timestamps in seconds\n     * @returns {Tensor} tensor containing the timestamps in seconds for each predicted token\n     */\n    _extract_token_timestamps(generate_outputs, alignment_heads, time_precision = 0.02) {\n        if (!generate_outputs.cross_attentions) {\n            throw new Error(\n                \"Model outputs must contain cross attentions to extract timestamps. \" +\n                \"This is most likely because the model was not exported with `output_attentions=True`.\"\n            )\n        }\n\n        let median_filter_width = this.config.median_filter_width;\n        if (median_filter_width === undefined) {\n            console.warn(\"Model config has no `median_filter_width`, using default value of 7.\")\n            median_filter_width = 7;\n        }\n\n        const batchedMatrices = generate_outputs.cross_attentions.map(batch => {\n            // Create a list with `decoder_layers` elements, each a tensor of shape\n            // (batch size, attention_heads, output length, input length).\n            let cross_attentions = Array.from({ length: this.config.decoder_layers },\n                (_, i) => (0,_utils_tensor_js__WEBPACK_IMPORTED_MODULE_4__.cat)(batch.map(x => x[i]), 2)\n            );\n\n            let weights = (0,_utils_tensor_js__WEBPACK_IMPORTED_MODULE_4__.stack)(alignment_heads.map(([l, h]) => cross_attentions[l].slice(null, h)));\n            weights = weights.transpose(1, 0, 2, 3)\n\n            let [std, calculatedMean] = (0,_utils_tensor_js__WEBPACK_IMPORTED_MODULE_4__.std_mean)(weights, -2, 0, true);\n\n            // Normalize and smoothen the weights.\n            let smoothedWeights = weights.clone(); // [1, 8, seqLength, 1500]\n\n            for (let a = 0; a < smoothedWeights.dims[0]; ++a) {\n                let aTensor = smoothedWeights[a]; // [8, seqLength, 1500]\n\n                for (let b = 0; b < aTensor.dims[0]; ++b) {\n                    let bTensor = aTensor[b]; // [seqLength, 1500]\n\n                    const stdTensor = std[a][b][0]; // [1500]\n                    const meanTensor = calculatedMean[a][b][0]; // [1500]\n\n                    for (let c = 0; c < bTensor.dims[0]; ++c) {\n\n                        let cTensor = bTensor[c]; // [1500]\n                        for (let d = 0; d < cTensor.data.length; ++d) {\n                            cTensor.data[d] = (cTensor.data[d] - meanTensor.data[d]) / stdTensor.data[d]\n                        }\n\n                        // Apply median filter.\n                        cTensor.data.set((0,_transformers_js__WEBPACK_IMPORTED_MODULE_6__.medianFilter)(cTensor.data, median_filter_width))\n                    }\n                }\n            }\n\n            // Average the different cross-attention heads.\n            const matrix = (0,_utils_tensor_js__WEBPACK_IMPORTED_MODULE_4__.mean)(smoothedWeights, 1);\n            return matrix;\n        });\n\n        const timestampsShape = [generate_outputs.sequences.length, generate_outputs.sequences[0].length];\n\n        const timestamps = new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_4__.Tensor(\n            'float32',\n            new Float32Array(timestampsShape[0] * timestampsShape[1]),\n            timestampsShape\n        );\n\n        // Perform dynamic time warping on each element of the batch.\n        for (let batch_idx = 0; batch_idx < timestampsShape[0]; ++batch_idx) {\n            // NOTE: Since we run only one batch at a time, we can squeeze to get the same dimensions\n            // as the python implementation\n            const matrix = batchedMatrices[batch_idx].neg().squeeze_(0);\n            let [text_indices, time_indices] = (0,_utils_tensor_js__WEBPACK_IMPORTED_MODULE_4__.dynamicTimeWarping)(matrix);\n\n            let diffs = Array.from({ length: text_indices.length - 1 }, (v, i) => text_indices[i + 1] - text_indices[i]);\n            let jumps = (0,_utils_core_js__WEBPACK_IMPORTED_MODULE_1__.mergeArrays)([1], diffs).map(x => !!x); // convert to boolean\n\n            let jump_times = [];\n            for (let i = 0; i < jumps.length; ++i) {\n                if (jumps[i]) {\n                    jump_times.push(time_indices[i] * time_precision);\n                    // NOTE: No point in rounding here, since we set to Float32Array later\n                }\n            }\n            timestamps[batch_idx].data.set(jump_times, 1)\n        }\n\n        return timestamps;\n    }\n}\n//////////////////////////////////////////////////\n\n//////////////////////////////////////////////////\n/**\n * Vision Encoder-Decoder model based on OpenAI's GPT architecture for image captioning and other vision tasks\n * @extends PreTrainedModel\n */\nclass VisionEncoderDecoderModel extends PreTrainedModel {\n    /**\n     * Creates a new instance of the `VisionEncoderDecoderModel` class.\n     * @param {Object} config The configuration object specifying the hyperparameters and other model settings.\n     * @param {Object} session The ONNX session containing the encoder model.\n     * @param {any} decoder_merged_session The ONNX session containing the merged decoder model.\n     */\n    constructor(config, session, decoder_merged_session) {\n        super(config, session);\n        this.decoder_merged_session = decoder_merged_session;\n\n        this.num_layers = this.config.decoder.n_layer;\n        this.num_heads = this.config.decoder.n_head;\n        this.dim_kv = this.config.decoder.n_embd / this.num_heads;\n    }\n\n    /**\n     * Generate beam search outputs for the given input pixels and number of output tokens.\n     *\n     * @param {array} inputs The input pixels as a Tensor.\n     * @param {number} numOutputTokens The number of output tokens to generate.\n     * @param {...*} args Optional additional arguments to pass to seq2seqStartBeams.\n     * @returns {any} An array of Beam objects representing the top-K output sequences.\n     */\n    getStartBeams(inputs, numOutputTokens, ...args) {\n        return seq2seqStartBeams(this, inputs, numOutputTokens);\n    }\n\n    /**\n     * Runs a single step of the beam search generation algorithm.\n     * @param {any} beam The current beam being generated.\n     * @returns {Promise<any>} The updated beam after a single generation step.\n     */\n    async runBeam(beam) {\n        return seq2seqRunBeam(this, beam, {\n            input_name: 'pixel_values',\n        });\n    }\n\n    /**\n     * Update the given beam with the additional predicted token ID.\n     *\n     * @param {any} beam The current beam.\n     * @param {number} newTokenId The new predicted token ID to add to the beam's output sequence.\n     */\n    updateBeam(beam, newTokenId) {\n        beam.output_token_ids = [...beam.output_token_ids, newTokenId];\n    }\n\n    /**\n     * Compute the forward pass of the model on the given input tensors.\n     *\n     * @param {Object} model_inputs The input tensors as an object with keys 'pixel_values' and 'decoder_input_ids'.\n     * @returns {Promise<any>} The output tensor of the model.\n     */\n    async forward(model_inputs) {\n        return await seq2seqForward(this, model_inputs, {\n            add_decoder_pkv: false\n        })\n    }\n}\n//////////////////////////////////////////////////\n\n//////////////////////////////////////////////////\n// CLIP models\nclass CLIPPreTrainedModel extends PreTrainedModel { }\nclass CLIPModel extends CLIPPreTrainedModel {\n\n}\n\n//////////////////////////////////////////////////\n\n//////////////////////////////////////////////////\n// GPT2 models\nclass GPT2PreTrainedModel extends PreTrainedModel {\n    /**\n     * Creates a new instance of the `GPT2PreTrainedModel` class.\n     * @param {Object} config The configuration of the model.\n     * @param {any} session The ONNX session containing the model weights.\n     */\n    constructor(config, session) {\n        super(config, session);\n\n        // config doesn't contain pad_token_id, so we assume it is the eos_token_id\n        this.config.pad_token_id = this.config.eos_token_id\n\n        this.num_heads = this.config.n_head\n        this.num_layers = this.config.n_layer\n        this.dim_kv = this.config.n_embd / this.num_heads;\n    }\n}\n\nclass GPT2Model extends GPT2PreTrainedModel {\n\n    /**\n     * GPT2Model is not compatible with `.generate()`, as it doesn't have a language model head.\n     * @param  {...any} args \n     * @throws {Error}\n     * @returns {Promise<any>}\n     */\n    async generate(...args) {\n        throw Error(\n            \"The current model class (GPT2Model) is not compatible with `.generate()`, as it doesn't have a language model head. Please use one of the following classes instead: {'GPT2LMHeadModel'}\"\n        )\n    }\n}\n\n/**\n * GPT-2 language model head on top of the GPT-2 base model. This model is suitable for text generation tasks.\n * @extends GPT2PreTrainedModel\n */\nclass GPT2LMHeadModel extends GPT2PreTrainedModel {\n\n    /**\n     * Initializes and returns the beam for text generation task\n     * @param {Tensor} inputTokenIds The input token ids.\n     * @param {number} numOutputTokens The number of tokens to be generated.\n     * @param {Tensor} inputs_attention_mask Optional input attention mask.\n     * @returns {any} A Beam object representing the initialized beam.\n     */\n    getStartBeams(inputTokenIds, numOutputTokens, inputs_attention_mask) {\n        return decoderStartBeams(this, inputTokenIds, numOutputTokens, inputs_attention_mask)\n    }\n\n    /**\n     * Runs a single step of the beam search generation algorithm.\n     * @param {any} beam The current beam being generated.\n     * @returns {Promise<any>} The updated beam after a single generation step.\n     */\n    async runBeam(beam) {\n        return await decoderRunBeam(this, beam);\n    }\n\n    /**\n     * Updates the given beam with the new generated token id.\n     * @param {any} beam The Beam object representing the beam.\n     * @param {number} newTokenId The new generated token id to be added to the beam.\n     */\n    updateBeam(beam, newTokenId) {\n        return decoderUpdatebeam(beam, newTokenId);\n    }\n\n    /**\n     * Forward pass for the model.\n     * @param {Object} model_inputs The inputs for the model.\n     * @returns {Promise<any>} The output tensor of the model.\n     */\n    async forward(model_inputs) {\n        return await decoderForward(this, model_inputs);\n    }\n\n}\n// export class GPT2ForSequenceClassification extends GPT2PreTrainedModel {\n// TODO\n// }\n//////////////////////////////////////////////////\nclass GPTNeoPreTrainedModel extends PreTrainedModel {\n    /**\n     * Creates a new instance of the `GPTNeoPreTrainedModel` class.\n     * @param {Object} config The configuration of the model.\n     * @param {any} session The ONNX session containing the model weights.\n     */\n    constructor(config, session) {\n        super(config, session);\n\n        // config doesn't contain pad_token_id, so we assume it is the eos_token_id\n        this.config.pad_token_id = this.config.eos_token_id\n\n        this.num_heads = this.config.num_heads;\n        this.num_layers = this.config.num_layers;\n        this.dim_kv = this.config.hidden_size / this.num_heads;\n    }\n}\nclass GPTNeoModel extends GPTNeoPreTrainedModel {\n    /**\n     * \n     * @param  {...any} args \n     * @throws {Error}\n     * @returns {Promise<any>}\n     */\n    async generate(...args) {\n        throw Error(\n            \"The current model class (GPTNeoModel) is not compatible with `.generate()`, as it doesn't have a language model head. Please use one of the following classes instead: {'GPTNeoForCausalLM'}\"\n        )\n    }\n}\n\nclass GPTNeoForCausalLM extends GPTNeoPreTrainedModel {\n\n    /**\n     * Initializes and returns the beam for text generation task\n     * @param {Tensor} inputTokenIds The input token ids.\n     * @param {number} numOutputTokens The number of tokens to be generated.\n     * @param {Tensor} inputs_attention_mask Optional input attention mask.\n     * @returns {any} A Beam object representing the initialized beam.\n     */\n    getStartBeams(inputTokenIds, numOutputTokens, inputs_attention_mask) {\n        return decoderStartBeams(this, inputTokenIds, numOutputTokens, inputs_attention_mask)\n    }\n\n    /**\n     * Runs a single step of the beam search generation algorithm.\n     * @param {any} beam The current beam being generated.\n     * @returns {Promise<any>} The updated beam after a single generation step.\n     */\n    async runBeam(beam) {\n        return await decoderRunBeam(this, beam);\n    }\n\n    /**\n     * Updates the given beam with the new generated token id.\n     * @param {any} beam The Beam object representing the beam.\n     * @param {number} newTokenId The new generated token id to be added to the beam.\n     */\n    updateBeam(beam, newTokenId) {\n        return decoderUpdatebeam(beam, newTokenId);\n    }\n\n    /**\n     * Forward pass for the model.\n     * @param {Object} model_inputs The inputs for the model.\n     * @returns {Promise<any>} The output tensor of the model.\n     */\n    async forward(model_inputs) {\n        return await decoderForward(this, model_inputs);\n    }\n}\n\n//////////////////////////////////////////////////\n// CodeGen models\nclass CodeGenPreTrainedModel extends PreTrainedModel {\n    /**\n     * Creates a new instance of the `CodeGenPreTrainedModel` class.\n    * @param {Object} config The model configuration object.\n    * @param {Object} session The ONNX session object.\n    */\n    constructor(config, session) {\n        super(config, session);\n\n        // config doesn't contain pad_token_id, so we assume it is the eos_token_id\n        this.config.pad_token_id = this.config.eos_token_id\n\n        this.num_heads = this.config.n_head\n        this.num_layers = this.config.n_layer\n        this.dim_kv = this.config.n_embd / this.num_heads;\n    }\n}\n/**\n * CodeGenModel is a class representing a code generation model without a language model head.\n * \n * @extends CodeGenPreTrainedModel\n */\nclass CodeGenModel extends CodeGenPreTrainedModel {\n    /**\n     * Throws an error indicating that the current model class is not compatible with `.generate()`,\n     * as it doesn't have a language model head.\n     * \n     * @throws {Error} The current model class is not compatible with `.generate()`\n     * \n     * @param  {...any} args Arguments passed to the generate function\n     * @returns {Promise<any>}\n     */\n    async generate(...args) {\n        throw Error(\n            \"The current model class (CodeGenModel) is not compatible with `.generate()`, as it doesn't have a language model head. Please use one of the following classes instead: {'CodeGenForCausalLM'}\"\n        )\n    }\n}\n\n/**\n * CodeGenForCausalLM is a class that represents a code generation model based on the GPT-2 architecture. It extends the `CodeGenPreTrainedModel` class.\n * @extends CodeGenPreTrainedModel\n */\nclass CodeGenForCausalLM extends CodeGenPreTrainedModel {\n\n    /**\n     * Initializes and returns the beam for text generation task\n     * @param {Tensor} inputTokenIds The input token ids.\n     * @param {number} numOutputTokens The number of tokens to be generated.\n     * @param {Tensor} inputs_attention_mask Optional input attention mask.\n     * @returns {any} A Beam object representing the initialized beam.\n     */\n    getStartBeams(inputTokenIds, numOutputTokens, inputs_attention_mask) {\n        return decoderStartBeams(this, inputTokenIds, numOutputTokens, inputs_attention_mask)\n    }\n\n    /**\n     * Runs a single step of the beam search generation algorithm.\n     * @param {any} beam The current beam being generated.\n     * @returns {Promise<any>} The updated beam after a single generation step.\n     */\n    async runBeam(beam) {\n        return await decoderRunBeam(this, beam);\n    }\n\n    /**\n     * Updates the given beam with the new generated token id.\n     * @param {any} beam The Beam object representing the beam.\n     * @param {number} newTokenId The new generated token id to be added to the beam.\n     */\n    updateBeam(beam, newTokenId) {\n        return decoderUpdatebeam(beam, newTokenId);\n    }\n\n    /**\n     * Forward pass for the model.\n     * @param {Object} model_inputs The inputs for the model.\n     * @returns {Promise<any>} The output tensor of the model.\n     */\n    async forward(model_inputs) {\n        return await decoderForward(this, model_inputs);\n    }\n\n}\n//////////////////////////////////////////////////\n\n//////////////////////////////////////////////////\nclass ViTPreTrainedModel extends PreTrainedModel { }\nclass ViTForImageClassification extends ViTPreTrainedModel {\n    /**\n     * @param {any} model_inputs\n     */\n    async _call(model_inputs) {\n        return new SequenceClassifierOutput(await super._call(model_inputs));\n    }\n}\n//////////////////////////////////////////////////\n\n//////////////////////////////////////////////////\nclass MobileViTPreTrainedModel extends PreTrainedModel { }\nclass MobileViTForImageClassification extends MobileViTPreTrainedModel {\n    /**\n     * @param {any} model_inputs\n     */\n    async _call(model_inputs) {\n        return new SequenceClassifierOutput(await super._call(model_inputs));\n    }\n}\n// TODO: MobileViTForSemanticSegmentation\n\n//////////////////////////////////////////////////\n\n\n\n//////////////////////////////////////////////////\nclass DetrPreTrainedModel extends PreTrainedModel { }\nclass DetrForObjectDetection extends DetrPreTrainedModel {\n    /**\n     * @param {any} model_inputs\n     */\n    async _call(model_inputs) {\n        return new DetrObjectDetectionOutput(await super._call(model_inputs));\n    }\n}\n\nclass DetrForSegmentation extends DetrPreTrainedModel {\n    /**\n     * Runs the model with the provided inputs\n     * @param {Object} model_inputs Model inputs\n     * @returns {Promise<DetrSegmentationOutput>} Object containing segmentation outputs\n     */\n    async _call(model_inputs) {\n        return new DetrSegmentationOutput(await super._call(model_inputs));\n    }\n}\n\nclass DetrObjectDetectionOutput extends ModelOutput {\n    /**\n     * @param {Object} output The output of the model.\n     * @param {Tensor} output.logits Classification logits (including no-object) for all queries.\n     * @param {Tensor} output.pred_boxes Normalized boxes coordinates for all queries, represented as (center_x, center_y, width, height).\n     * These values are normalized in [0, 1], relative to the size of each individual image in the batch (disregarding possible padding).\n     */\n    constructor({ logits, pred_boxes }) {\n        super();\n        this.logits = logits;\n        this.pred_boxes = pred_boxes;\n    }\n}\n\nclass DetrSegmentationOutput extends ModelOutput {\n    /**\n     * @param {Object} output The output of the model.\n     * @param {Tensor} output.logits The output logits of the model.\n     * @param {Tensor} output.pred_boxes Predicted boxes.\n     * @param {Tensor} output.pred_masks Predicted masks.\n     */\n    constructor({ logits, pred_boxes, pred_masks }) {\n        super();\n        this.logits = logits;\n        this.pred_boxes = pred_boxes;\n        this.pred_masks = pred_masks;\n    }\n}\n//////////////////////////////////////////////////\n\n\n//////////////////////////////////////////////////\nclass SamPreTrainedModel extends PreTrainedModel { }\nclass SamModel extends SamPreTrainedModel {\n    /**\n     * @param {Object} model_inputs\n     * @param {Tensor} model_inputs.pixel_values Pixel values as a Tensor with shape `(batch_size, num_channels, height, width)`.\n     * @param {Tensor} model_inputs.input_points Input 2D spatial points with shape `(batch_size, num_points, 2)`. This is used by the prompt encoder to encode the prompt.\n     * @todo Add support for `input_labels`, `input_boxes`, `input_masks`, and `image_embeddings`.\n     */\n    async _call(model_inputs) {\n        return new SamImageSegmentationOutput(await super._call(model_inputs));\n    }\n}\n\n\n/**\n * Base class for Segment-Anything model's output.\n */\nclass SamImageSegmentationOutput extends ModelOutput {\n    /**\n     * @param {Object} output The output of the model.\n     * @param {Tensor} output.iou_scores The output logits of the model.\n     * @param {Tensor} output.pred_masks Predicted boxes.\n     */\n    constructor({ iou_scores, pred_masks }) {\n        super();\n        this.iou_scores = iou_scores;\n        this.pred_masks = pred_masks;\n    }\n}\n//////////////////////////////////////////////////\n\n\n//////////////////////////////////////////////////\n// MarianMT models\nclass MarianPreTrainedModel extends PreTrainedModel { };\n\nclass MarianModel extends MarianPreTrainedModel {\n    /**\n     * \n     * @param  {...any} args \n     * @throws {Error}\n     * @returns {Promise<any>}\n     */\n    async generate(...args) {\n        throw Error(\n            \"The current model class (MarianModel) is not compatible with `.generate()`, as it doesn't have a language model head. Please use one of the following classes instead: {'MarianMTModel'}\"\n        )\n    }\n}\n\nclass MarianMTModel extends MarianPreTrainedModel {\n\n    /**\n     * Creates a new instance of the `MarianMTModel` class.\n    * @param {Object} config The model configuration object.\n    * @param {Object} session The ONNX session object.\n    * @param {any} decoder_merged_session \n    * @param {any} generation_config \n    */\n    constructor(config, session, decoder_merged_session, generation_config) {\n        super(config, session);\n        this.decoder_merged_session = decoder_merged_session;\n        this.generation_config = generation_config;\n\n        this.num_decoder_layers = this.config.decoder_layers;\n        this.num_decoder_heads = this.config.decoder_attention_heads;\n        this.decoder_dim_kv = this.config.d_model / this.num_decoder_heads;\n\n        this.num_encoder_layers = this.config.encoder_layers;\n        this.num_encoder_heads = this.config.encoder_attention_heads;\n        this.encoder_dim_kv = this.config.d_model / this.num_encoder_heads;\n    }\n\n    /**\n     * Initializes and returns the beam for text generation task\n     * @param {any[]} inputs The input token ids.\n     * @param {number} numOutputTokens The number of tokens to be generated.\n     * @returns {any} A Beam object representing the initialized beam.\n     * @param {any[]} args\n     */\n    getStartBeams(inputs, numOutputTokens, ...args) {\n        return seq2seqStartBeams(this, inputs, numOutputTokens);\n    }\n\n    /**\n     * Runs a single step of the beam search generation algorithm.\n     * @param {any} beam The current beam being generated.\n     * @returns {Promise<any>} The updated beam after a single generation step.\n     */\n    async runBeam(beam) {\n        return await seq2seqRunBeam(this, beam);\n    }\n\n    /**\n     * @param {any} beam\n     * @param {any} newTokenId\n     */\n    updateBeam(beam, newTokenId) {\n        beam.output_token_ids = [...beam.output_token_ids, newTokenId];\n    }\n\n    /**\n     * @param {any} model_inputs\n     * @returns {Promise<Seq2SeqLMOutput>}\n     */\n    async forward(model_inputs) {\n        return await seq2seqForward(this, model_inputs);\n    }\n}\n//////////////////////////////////////////////////\n\n//////////////////////////////////////////////////\n// M2M100 models\nclass M2M100PreTrainedModel extends PreTrainedModel { };\n\nclass M2M100Model extends M2M100PreTrainedModel {\n    /**\n     * \n     * @param  {...any} args \n     * @throws {Error}\n     * @returns {Promise<any>}\n     */\n    async generate(...args) {\n        throw Error(\n            \"The current model class (M2M100Model) is not compatible with `.generate()`, as it doesn't have a language model head. Please use one of the following classes instead: {'M2M100ForConditionalGeneration'}\"\n        )\n    }\n}\n\nclass M2M100ForConditionalGeneration extends M2M100PreTrainedModel {\n\n    /**\n     * Creates a new instance of the `M2M100ForConditionalGeneration` class.\n    * @param {Object} config The model configuration object.\n    * @param {Object} session The ONNX session object.\n    * @param {any} decoder_merged_session \n    * @param {any} generation_config \n    */\n    constructor(config, session, decoder_merged_session, generation_config) {\n        super(config, session);\n        this.decoder_merged_session = decoder_merged_session;\n        this.generation_config = generation_config;\n\n        this.num_decoder_layers = this.config.decoder_layers;\n        this.num_decoder_heads = this.config.decoder_attention_heads;\n        this.decoder_dim_kv = this.config.d_model / this.num_decoder_heads;\n\n        this.num_encoder_layers = this.config.encoder_layers;\n        this.num_encoder_heads = this.config.encoder_attention_heads;\n        this.encoder_dim_kv = this.config.d_model / this.num_encoder_heads;\n    }\n\n\n    /**\n     * Initializes and returns the beam for text generation task\n     * @param {any[]} inputs The input token ids.\n     * @param {number} numOutputTokens The number of tokens to be generated.\n     * @returns {any} A Beam object representing the initialized beam.\n     * @param {any[]} args\n     */\n    getStartBeams(inputs, numOutputTokens, ...args) {\n        return seq2seqStartBeams(this, inputs, numOutputTokens);\n    }\n\n    /**\n     * Runs a single step of the beam search generation algorithm.\n     * @param {any} beam The current beam being generated.\n     * @returns {Promise<any>} The updated beam after a single generation step.\n     */\n    async runBeam(beam) {\n        return await seq2seqRunBeam(this, beam);\n    }\n\n    /**\n     * @param {any} beam\n     * @param {any} newTokenId\n     */\n    updateBeam(beam, newTokenId) {\n        beam.output_token_ids = [...beam.output_token_ids, newTokenId];\n    }\n\n    /**\n     * @param {any} model_inputs\n     * @returns {Promise<Seq2SeqLMOutput>}\n     */\n    async forward(model_inputs) {\n        return await seq2seqForward(this, model_inputs);\n    }\n}\n//////////////////////////////////////////////////\n\n\n//////////////////////////////////////////////////\n// AutoModels, used to simplify construction of PreTrainedModels\n// (uses config to instantiate correct class)\n\n/**\n * Base class of all AutoModels. Contains the `from_pretrained` function\n * which is used to instantiate pretrained models.\n */\nclass PretrainedMixin {\n    /**\n     * Mapping from model type to model class.\n     * @type {Map<string, Object>[]}\n     */\n    static MODEL_CLASS_MAPPINGS = null;\n\n    /**\n     * Whether to attempt to instantiate the base class (`PretrainedModel`) if \n     * the model type is not found in the mapping.\n     */\n    static BASE_IF_FAIL = false;\n\n\n    /** @type {PreTrainedModel.from_pretrained} */\n    static async from_pretrained(pretrained_model_name_or_path, {\n        quantized = true,\n        progress_callback = null,\n        config = null,\n        cache_dir = null,\n        local_files_only = false,\n        revision = 'main',\n    } = {}) {\n\n        let options = {\n            quantized,\n            progress_callback,\n            config,\n            cache_dir,\n            local_files_only,\n            revision,\n        }\n        config = await _configs_js__WEBPACK_IMPORTED_MODULE_0__.AutoConfig.from_pretrained(pretrained_model_name_or_path, options);\n\n        if (!this.MODEL_CLASS_MAPPINGS) {\n            throw new Error(\"`MODEL_CLASS_MAPPINGS` not implemented for this type of `AutoClass`: \" + this.name);\n        }\n\n        let modelClass;\n        for (let MODEL_CLASS_MAPPING of this.MODEL_CLASS_MAPPINGS) {\n            modelClass = MODEL_CLASS_MAPPING.get(config.model_type);\n            if (!modelClass) {\n                continue; // Item not found in this mapping\n            }\n\n            return await modelClass.from_pretrained(pretrained_model_name_or_path, options);\n        }\n\n        if (this.BASE_IF_FAIL) {\n            console.warn(`Unknown model class \"${config.model_type}\", attempting to construct from base class.`);\n            return await PreTrainedModel.from_pretrained(pretrained_model_name_or_path, options);\n        } else {\n            throw Error(`Unsupported model type: ${config.model_type}`)\n        }\n    }\n}\n\nconst MODEL_MAPPING_NAMES_ENCODER_ONLY = new Map([\n    ['bert', BertModel],\n    ['albert', AlbertModel],\n    ['distilbert', DistilBertModel],\n    ['roberta', RobertaModel],\n    ['xlm-roberta', XLMRobertaModel],\n    ['clip', CLIPModel],\n    ['mobilebert', MobileBertModel],\n    ['squeezebert', SqueezeBertModel],\n\n    ['sam', SamModel], // TODO change to encoder-decoder when model is split correctly\n]);\n\nconst MODEL_MAPPING_NAMES_ENCODER_DECODER = new Map([\n    ['t5', T5Model],\n    ['mt5', MT5Model],\n    ['bart', BartModel],\n    ['marian', MarianModel],\n    ['whisper', WhisperModel],\n    ['m2m_100', M2M100Model],\n]);\n\n\nconst MODEL_MAPPING_NAMES_DECODER_ONLY = new Map([\n    ['gpt2', GPT2Model],\n    ['gpt_neo', GPTNeoModel],\n    ['codegen', CodeGenModel],\n]);\n\nconst MODEL_FOR_SEQUENCE_CLASSIFICATION_MAPPING_NAMES = new Map([\n    ['bert', BertForSequenceClassification],\n    ['albert', AlbertForSequenceClassification],\n    ['distilbert', DistilBertForSequenceClassification],\n    ['roberta', RobertaForSequenceClassification],\n    ['xlm-roberta', XLMRobertaForSequenceClassification],\n    ['bart', BartForSequenceClassification],\n    ['mobilebert', MobileBertForSequenceClassification],\n    ['squeezebert', SqueezeBertForSequenceClassification],\n]);\n\nconst MODEL_FOR_TOKEN_CLASSIFICATION_MAPPING_NAMES = new Map([\n    ['bert', BertForTokenClassification],\n    ['distilbert', DistilBertForTokenClassification],\n    ['roberta', RobertaForTokenClassification],\n    ['xlm-roberta', XLMRobertaForTokenClassification],\n]);\n\nconst MODEL_FOR_SEQ_2_SEQ_MAPPING_NAMES = new Map([\n    ['t5', T5ForConditionalGeneration],\n    ['mt5', MT5ForConditionalGeneration],\n    ['bart', BartForConditionalGeneration],\n    ['whisper', WhisperForConditionalGeneration],\n    ['marian', MarianMTModel],\n    ['m2m_100', M2M100ForConditionalGeneration],\n]);\n\nconst MODEL_WITH_LM_HEAD_MAPPING_NAMES = new Map([\n    ['gpt2', GPT2LMHeadModel],\n    ['gpt_neo', GPTNeoForCausalLM],\n    ['codegen', CodeGenForCausalLM],\n]);\n\nconst MODEL_FOR_MASKED_LM_MAPPING_NAMES = new Map([\n    ['bert', BertForMaskedLM],\n    ['albert', AlbertForMaskedLM],\n    ['distilbert', DistilBertForMaskedLM],\n    ['roberta', RobertaForMaskedLM],\n    ['xlm-roberta', XLMRobertaForMaskedLM],\n    ['mobilebert', MobileBertForMaskedLM],\n    ['squeezebert', SqueezeBertForMaskedLM],\n]);\n\nconst MODEL_FOR_QUESTION_ANSWERING_MAPPING_NAMES = new Map([\n    ['bert', BertForQuestionAnswering],\n    ['albert', AlbertForQuestionAnswering],\n    ['distilbert', DistilBertForQuestionAnswering],\n    ['roberta', RobertaForQuestionAnswering],\n    ['xlm-roberta', XLMRobertaForQuestionAnswering],\n    ['mobilebert', MobileBertForQuestionAnswering],\n    ['squeezebert', SqueezeBertForQuestionAnswering],\n]);\n\nconst MODEL_FOR_VISION_2_SEQ_MAPPING_NAMES = new Map([\n    ['vision-encoder-decoder', VisionEncoderDecoderModel],\n]);\n\nconst MODEL_FOR_IMAGE_CLASSIFICATION_MAPPING_NAMES = new Map([\n    ['vit', ViTForImageClassification],\n    ['mobilevit', MobileViTForImageClassification],\n]);\n\nconst MODEL_FOR_OBJECT_DETECTION_MAPPING_NAMES = new Map([\n    ['detr', DetrForObjectDetection],\n]);\n\nconst MODEL_FOR_IMAGE_SEGMENTATION_MAPPING_NAMES = new Map([\n    ['detr', DetrForSegmentation],\n]);\n\nconst MODEL_FOR_MASK_GENERATION_MAPPING_NAMES = new Map([\n    ['sam', SamModel],\n]);\n\nconst MODEL_CLASS_TYPE_MAPPING = [\n    [MODEL_MAPPING_NAMES_ENCODER_ONLY, EncoderOnlyModelType],\n    [MODEL_MAPPING_NAMES_ENCODER_DECODER, EncoderDecoderModelType],\n    [MODEL_MAPPING_NAMES_DECODER_ONLY, DecoderOnlyModelType],\n    [MODEL_FOR_SEQUENCE_CLASSIFICATION_MAPPING_NAMES, EncoderOnlyModelType],\n    [MODEL_FOR_TOKEN_CLASSIFICATION_MAPPING_NAMES, EncoderOnlyModelType],\n    [MODEL_FOR_SEQ_2_SEQ_MAPPING_NAMES, Seq2SeqModelType],\n    [MODEL_WITH_LM_HEAD_MAPPING_NAMES, DecoderOnlyModelType],\n    [MODEL_FOR_MASKED_LM_MAPPING_NAMES, EncoderOnlyModelType],\n    [MODEL_FOR_QUESTION_ANSWERING_MAPPING_NAMES, EncoderOnlyModelType],\n    [MODEL_FOR_VISION_2_SEQ_MAPPING_NAMES, EncoderDecoderModelType],\n    [MODEL_FOR_IMAGE_CLASSIFICATION_MAPPING_NAMES, EncoderOnlyModelType],\n    [MODEL_FOR_IMAGE_SEGMENTATION_MAPPING_NAMES, EncoderOnlyModelType],\n    [MODEL_FOR_OBJECT_DETECTION_MAPPING_NAMES, EncoderOnlyModelType],\n    [MODEL_FOR_MASK_GENERATION_MAPPING_NAMES, EncoderOnlyModelType],\n];\n\nfor (let [mappings, type] of MODEL_CLASS_TYPE_MAPPING) {\n    // @ts-ignore\n    for (let [name, model] of mappings.entries()) {\n        MODEL_TYPE_MAPPING.set(model.name, type);\n        MODEL_CLASS_MAPPING.set(model.name, name);\n    }\n}\n\n/**\n * Helper class which is used to instantiate pretrained models with the `from_pretrained` function.\n * The chosen model class is determined by the type specified in the model config.\n * \n * @example\n * let model = await AutoModel.from_pretrained('bert-base-uncased');\n */\nclass AutoModel extends PretrainedMixin {\n    static MODEL_CLASS_MAPPINGS = [MODEL_MAPPING_NAMES_ENCODER_ONLY, MODEL_MAPPING_NAMES_ENCODER_DECODER, MODEL_MAPPING_NAMES_DECODER_ONLY];\n    static BASE_IF_FAIL = true;\n}\n\n/**\n * Helper class which is used to instantiate pretrained sequence classification models with the `from_pretrained` function.\n * The chosen model class is determined by the type specified in the model config.\n * \n * @example\n * let model = await AutoModelForSequenceClassification.from_pretrained('distilbert-base-uncased-finetuned-sst-2-english');\n */\nclass AutoModelForSequenceClassification extends PretrainedMixin {\n    static MODEL_CLASS_MAPPINGS = [MODEL_FOR_SEQUENCE_CLASSIFICATION_MAPPING_NAMES];\n}\n\n/**\n * Helper class which is used to instantiate pretrained token classification models with the `from_pretrained` function.\n * The chosen model class is determined by the type specified in the model config.\n * \n * @example\n * let model = await AutoModelForTokenClassification.from_pretrained('Davlan/distilbert-base-multilingual-cased-ner-hrl');\n */\nclass AutoModelForTokenClassification extends PretrainedMixin {\n    static MODEL_CLASS_MAPPINGS = [MODEL_FOR_TOKEN_CLASSIFICATION_MAPPING_NAMES];\n}\n\n/**\n * Helper class which is used to instantiate pretrained sequence-to-sequence models with the `from_pretrained` function.\n * The chosen model class is determined by the type specified in the model config.\n * \n * @example\n * let model = await AutoModelForSeq2SeqLM.from_pretrained('t5-small');\n */\nclass AutoModelForSeq2SeqLM extends PretrainedMixin {\n    static MODEL_CLASS_MAPPINGS = [MODEL_FOR_SEQ_2_SEQ_MAPPING_NAMES];\n}\n\n/**\n * Helper class which is used to instantiate pretrained causal language models with the `from_pretrained` function.\n * The chosen model class is determined by the type specified in the model config.\n * \n * @example\n * let model = await AutoModelForCausalLM.from_pretrained('gpt2');\n */\nclass AutoModelForCausalLM extends PretrainedMixin {\n    static MODEL_CLASS_MAPPINGS = [MODEL_WITH_LM_HEAD_MAPPING_NAMES];\n}\n\n/**\n * Helper class which is used to instantiate pretrained masked language models with the `from_pretrained` function.\n * The chosen model class is determined by the type specified in the model config.\n * \n * @example\n * let model = await AutoModelForMaskedLM.from_pretrained('bert-base-uncased');\n */\nclass AutoModelForMaskedLM extends PretrainedMixin {\n    static MODEL_CLASS_MAPPINGS = [MODEL_FOR_MASKED_LM_MAPPING_NAMES];\n}\n\n/**\n * Helper class which is used to instantiate pretrained question answering models with the `from_pretrained` function.\n * The chosen model class is determined by the type specified in the model config.\n * \n * @example\n * let model = await AutoModelForQuestionAnswering.from_pretrained('distilbert-base-cased-distilled-squad');\n */\nclass AutoModelForQuestionAnswering extends PretrainedMixin {\n    static MODEL_CLASS_MAPPINGS = [MODEL_FOR_QUESTION_ANSWERING_MAPPING_NAMES];\n}\n\n/**\n * Helper class which is used to instantiate pretrained vision-to-sequence models with the `from_pretrained` function.\n * The chosen model class is determined by the type specified in the model config.\n * \n * @example\n * let model = await AutoModelForVision2Seq.from_pretrained('nlpconnect/vit-gpt2-image-captioning');\n */\nclass AutoModelForVision2Seq extends PretrainedMixin {\n    static MODEL_CLASS_MAPPINGS = [MODEL_FOR_VISION_2_SEQ_MAPPING_NAMES];\n}\n\n/**\n * Helper class which is used to instantiate pretrained image classification models with the `from_pretrained` function.\n * The chosen model class is determined by the type specified in the model config.\n * \n * @example\n * let model = await AutoModelForImageClassification.from_pretrained('google/vit-base-patch16-224');\n */\nclass AutoModelForImageClassification extends PretrainedMixin {\n    static MODEL_CLASS_MAPPINGS = [MODEL_FOR_IMAGE_CLASSIFICATION_MAPPING_NAMES];\n}\n\n/**\n * Helper class which is used to instantiate pretrained image segmentation models with the `from_pretrained` function.\n * The chosen model class is determined by the type specified in the model config.\n * \n * @example\n * let model = await AutoModelForImageSegmentation.from_pretrained('facebook/detr-resnet-50-panoptic');\n */\nclass AutoModelForImageSegmentation extends PretrainedMixin {\n    static MODEL_CLASS_MAPPINGS = [MODEL_FOR_IMAGE_SEGMENTATION_MAPPING_NAMES];\n}\n\n/**\n * Helper class which is used to instantiate pretrained object detection models with the `from_pretrained` function.\n * The chosen model class is determined by the type specified in the model config.\n * \n * @example\n * let model = await AutoModelForObjectDetection.from_pretrained('facebook/detr-resnet-50');\n */\nclass AutoModelForObjectDetection extends PretrainedMixin {\n    static MODEL_CLASS_MAPPINGS = [MODEL_FOR_OBJECT_DETECTION_MAPPING_NAMES];\n}\n\n/**\n * Helper class which is used to instantiate pretrained object detection models with the `from_pretrained` function.\n * The chosen model class is determined by the type specified in the model config.\n * \n * @example\n * let model = await AutoModelForMaskGeneration.from_pretrained('Xenova/sam-vit-base');\n */\nclass AutoModelForMaskGeneration extends PretrainedMixin {\n    static MODEL_CLASS_MAPPINGS = [MODEL_FOR_MASK_GENERATION_MAPPING_NAMES];\n}\n//////////////////////////////////////////////////\n\n//////////////////////////////////////////////////\nclass Seq2SeqLMOutput extends ModelOutput {\n    /**\n     * @param {Object} output The output of the model.\n     * @param {Tensor} output.logits The output logits of the model.\n     * @param {Tensor} output.past_key_values An tensor of key/value pairs that represent the previous state of the model.\n     * @param {Tensor} output.encoder_outputs The output of the encoder in a sequence-to-sequence model.\n     * @param {Tensor} [output.decoder_attentions] Attentions weights of the decoder, after the attention softmax, used to compute the weighted average in the self-attention heads.\n     * @param {Tensor} [output.cross_attentions] Attentions weights of the decoder's cross-attention layer, after the attention softmax, used to compute the weighted average in the cross-attention heads.\n     */\n    constructor({ logits, past_key_values, encoder_outputs, decoder_attentions = null, cross_attentions = null }) {\n        super();\n        this.logits = logits;\n        this.past_key_values = past_key_values;\n        this.encoder_outputs = encoder_outputs;\n        this.decoder_attentions = decoder_attentions;\n        this.cross_attentions = cross_attentions;\n    }\n}\n\n/**\n * Base class for outputs of sentence classification models.\n */\nclass SequenceClassifierOutput extends ModelOutput {\n    /**\n     * @param {Object} output The output of the model.\n     * @param {Tensor} output.logits classification (or regression if config.num_labels==1) scores (before SoftMax).\n     */\n    constructor({ logits }) {\n        super();\n        this.logits = logits;\n    }\n}\n\n/**\n * Base class for outputs of token classification models.\n */\nclass TokenClassifierOutput extends ModelOutput {\n    /**\n     * @param {Object} output The output of the model.\n     * @param {Tensor} output.logits Classification scores (before SoftMax).\n     */\n    constructor({ logits }) {\n        super();\n        this.logits = logits;\n    }\n}\n\n/**\n * Base class for masked language models outputs.\n */\nclass MaskedLMOutput extends ModelOutput {\n    /**\n     * @param {Object} output The output of the model.\n     * @param {Tensor} output.logits Prediction scores of the language modeling head (scores for each vocabulary token before SoftMax).\n     */\n    constructor({ logits }) {\n        super();\n        this.logits = logits;\n    }\n}\n\n/**\n * Base class for outputs of question answering models.\n */\nclass QuestionAnsweringModelOutput extends ModelOutput {\n    /**\n     * @param {Object} output The output of the model.\n     * @param {Tensor} output.start_logits Span-start scores (before SoftMax).\n     * @param {Tensor} output.end_logits Span-end scores (before SoftMax).\n     */\n    constructor({ start_logits, end_logits }) {\n        super();\n        this.start_logits = start_logits;\n        this.end_logits = end_logits;\n    }\n}\n\n\n/**\n * Base class for causal language model (or autoregressive) outputs.\n */\nclass CausalLMOutputWithPast extends ModelOutput {\n    /**\n     * @param {Object} output The output of the model.\n     * @param {Tensor} output.logits Prediction scores of the language modeling head (scores for each vocabulary token before softmax).\n     * @param {Tensor} output.past_key_values Contains pre-computed hidden-states (key and values in the self-attention blocks)\n     * that can be used (see `past_key_values` input) to speed up sequential decoding.\n     */\n    constructor({ logits, past_key_values }) {\n        super();\n        this.logits = logits;\n        this.past_key_values = past_key_values;\n    }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AeGVub3ZhL3RyYW5zZm9ybWVycy9zcmMvbW9kZWxzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDJCQUEyQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxTQUFTO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksdUNBQXVDO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxZQUFZO0FBQ3JCO0FBQ0EsZ0RBQWdELDJCQUEyQjtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUlzQjs7QUFPRzs7QUFLRDs7QUFjTzs7QUFTSjs7QUFFbUM7QUFDTjtBQUN4RCxRQUFRLHVDQUF1QyxFQUFFLG1EQUFJOztBQUVyRDtBQUNBLGFBQWEsNENBQTRDO0FBQ3pEOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixhQUFhLGlCQUFpQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxtQkFBbUI7QUFDOUIsYUFBYSwyQkFBMkI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsU0FBUyxFQUFFLHNDQUFzQztBQUNqRix1QkFBdUIsMkRB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QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7O0FBRWxCLDREQUE0RDs7QUFFNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxR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Q1A7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0Esa0JBQWtCLFFBQVE7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQSxrQkFBa0IsUUFBUTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGtCQUFrQixRQUFRO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGtCQUFrQiwwQkFBMEI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQSxrQkFBa0IseUJBQXlCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B4ZW5vdmEvdHJhbnNmb3JtZXJzL3NyYy9tb2RlbHMuanM/MTUwNSJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qKlxuICogQGZpbGUgRGVmaW5pdGlvbnMgb2YgYWxsIG1vZGVscyBhdmFpbGFibGUgaW4gVHJhbnNmb3JtZXJzLmpzLlxuICogXG4gKiAqKkV4YW1wbGU6KiogTG9hZCBhbmQgcnVuIGFuIGBBdXRvTW9kZWxgLlxuICogXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBpbXBvcnQgeyBBdXRvTW9kZWwsIEF1dG9Ub2tlbml6ZXIgfSBmcm9tICdAeGVub3ZhL3RyYW5zZm9ybWVycyc7XG4gKlxuICogbGV0IHRva2VuaXplciA9IGF3YWl0IEF1dG9Ub2tlbml6ZXIuZnJvbV9wcmV0cmFpbmVkKCdYZW5vdmEvYmVydC1iYXNlLXVuY2FzZWQnKTtcbiAqIGxldCBtb2RlbCA9IGF3YWl0IEF1dG9Nb2RlbC5mcm9tX3ByZXRyYWluZWQoJ1hlbm92YS9iZXJ0LWJhc2UtdW5jYXNlZCcpO1xuICpcbiAqIGxldCBpbnB1dHMgPSBhd2FpdCB0b2tlbml6ZXIoJ0kgbG92ZSB0cmFuc2Zvcm1lcnMhJyk7XG4gKiBsZXQgeyBsb2dpdHMgfSA9IGF3YWl0IG1vZGVsKGlucHV0cyk7XG4gKiAvLyBUZW5zb3Ige1xuICogLy8gICAgIGRhdGE6IEZsb2F0MzJBcnJheSgxODMxMzIpIFstNy4xMTc0NDMwODQ3MTY3OTcsIC03LjEwNzgxMjg4MTQ2OTcyNywgLTcuMDkyMTA0OTExODA0MTk5LCAuLi5dXG4gKiAvLyAgICAgZGltczogKDMpIFsxLCA2LCAzMDUyMl0sXG4gKiAvLyAgICAgdHlwZTogXCJmbG9hdDMyXCIsXG4gKiAvLyAgICAgc2l6ZTogMTgzMTMyLFxuICogLy8gfVxuICogYGBgXG4gKiBcbiAqIFdlIGFsc28gcHJvdmlkZSBvdGhlciBgQXV0b01vZGVsYHMgKGxpc3RlZCBiZWxvdyksIHdoaWNoIHlvdSBjYW4gdXNlIGluIHRoZSBzYW1lIHdheSBhcyB0aGUgUHl0aG9uIGxpYnJhcnkuIEZvciBleGFtcGxlOlxuICogXG4gKiAqKkV4YW1wbGU6KiogTG9hZCBhbmQgcnVuIGEgYEF1dG9Nb2RlbEZvclNlcTJTZXFMTWAuXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBpbXBvcnQgeyBBdXRvTW9kZWxGb3JTZXEyU2VxTE0sIEF1dG9Ub2tlbml6ZXIgfSBmcm9tICdAeGVub3ZhL3RyYW5zZm9ybWVycyc7XG4gKiBcbiAqIGxldCB0b2tlbml6ZXIgPSBhd2FpdCBBdXRvVG9rZW5pemVyLmZyb21fcHJldHJhaW5lZCgnWGVub3ZhL3Q1LXNtYWxsJyk7XG4gKiBsZXQgbW9kZWwgPSBhd2FpdCBBdXRvTW9kZWxGb3JTZXEyU2VxTE0uZnJvbV9wcmV0cmFpbmVkKCdYZW5vdmEvdDUtc21hbGwnKTtcbiAqXG4gKiBsZXQgeyBpbnB1dF9pZHMgfSA9IGF3YWl0IHRva2VuaXplcigndHJhbnNsYXRlIEVuZ2xpc2ggdG8gR2VybWFuOiBJIGxvdmUgdHJhbnNmb3JtZXJzIScpO1xuICogbGV0IG91dHB1dHMgPSBhd2FpdCBtb2RlbC5nZW5lcmF0ZShpbnB1dF9pZHMpO1xuICogbGV0IGRlY29kZWQgPSB0b2tlbml6ZXIuZGVjb2RlKG91dHB1dHNbMF0sIHsgc2tpcF9zcGVjaWFsX3Rva2VuczogdHJ1ZSB9KTtcbiAqIC8vICdJY2ggbGllYmUgVHJhbnNmb3JtYXRvcmVuISdcbiAqIGBgYFxuICogXG4gKiBAbW9kdWxlIG1vZGVsc1xuICovXG5cbmltcG9ydCB7XG4gICAgQXV0b0NvbmZpZyxcbn0gZnJvbSAnLi9jb25maWdzLmpzJztcblxuaW1wb3J0IHtcbiAgICBDYWxsYWJsZSxcbiAgICBpc0ludGVncmFsTnVtYmVyLFxuICAgIGlzVHlwZWRBcnJheSxcbiAgICBtZXJnZUFycmF5cyxcbn0gZnJvbSAnLi91dGlscy9jb3JlLmpzJztcblxuaW1wb3J0IHtcbiAgICBnZXRNb2RlbEZpbGUsXG4gICAgZ2V0TW9kZWxKU09OLFxufSBmcm9tICcuL3V0aWxzL2h1Yi5qcyc7XG5cbmltcG9ydCB7XG4gICAgTG9naXRzUHJvY2Vzc29yTGlzdCxcbiAgICBHZW5lcmF0aW9uQ29uZmlnLFxuICAgIEZvcmNlVG9rZW5zTG9naXRzUHJvY2Vzc29yLFxuICAgIEZvcmNlZEJPU1Rva2VuTG9naXRzUHJvY2Vzc29yLFxuICAgIEZvcmNlZEVPU1Rva2VuTG9naXRzUHJvY2Vzc29yLFxuICAgIFN1cHByZXNzVG9rZW5zQXRCZWdpbkxvZ2l0c1Byb2Nlc3NvcixcbiAgICBXaGlzcGVyVGltZVN0YW1wTG9naXRzUHJvY2Vzc29yLFxuICAgIE5vUmVwZWF0TkdyYW1Mb2dpdHNQcm9jZXNzb3IsXG4gICAgUmVwZXRpdGlvblBlbmFsdHlMb2dpdHNQcm9jZXNzb3IsXG5cbiAgICBTYW1wbGVyLFxufSBmcm9tICcuL3V0aWxzL2dlbmVyYXRpb24uanMnO1xuXG5pbXBvcnQge1xuICAgIGNhdCxcbiAgICBkeW5hbWljVGltZVdhcnBpbmcsXG4gICAgbWVhbixcbiAgICBzdGFjayxcbiAgICBzdGRfbWVhbixcbiAgICBUZW5zb3IsXG59IGZyb20gJy4vdXRpbHMvdGVuc29yLmpzJztcblxuaW1wb3J0IHsgZXhlY3V0aW9uUHJvdmlkZXJzLCBPTk5YIH0gZnJvbSAnLi9iYWNrZW5kcy9vbm54LmpzJztcbmltcG9ydCB7IG1lZGlhbkZpbHRlciwgcm91bmQgfSBmcm9tICcuL3RyYW5zZm9ybWVycy5qcyc7XG5jb25zdCB7IEluZmVyZW5jZVNlc3Npb24sIFRlbnNvcjogT05OWFRlbnNvciB9ID0gT05OWDtcblxuLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuL3V0aWxzL2h1Yi5qcycpLlByZXRyYWluZWRPcHRpb25zfSBQcmV0cmFpbmVkT3B0aW9uc1xuICovXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIE1vZGVsIHR5cGVzOiB1c2VkIGludGVybmFsbHlcbmNsYXNzIE1vZGVsVHlwZSB7IH07XG5cbi8vIEVpdGhlciBlbmNvZGVyLW9ubHkgb3IgZW5jb2Rlci1kZWNvZGVyIChhbmQgd2lsbCBiZSBkZWNpZGVkIGJ5IGBtb2RlbC5jb25maWcuaXNfZW5jb2Rlcl9kZWNvZGVyYClcbmNsYXNzIEVuY29kZXJPbmx5TW9kZWxUeXBlIGV4dGVuZHMgTW9kZWxUeXBlIHsgfTtcbmNsYXNzIEVuY29kZXJEZWNvZGVyTW9kZWxUeXBlIGV4dGVuZHMgTW9kZWxUeXBlIHsgfTtcbmNsYXNzIFNlcTJTZXFNb2RlbFR5cGUgZXh0ZW5kcyBFbmNvZGVyRGVjb2Rlck1vZGVsVHlwZSB7IH07XG5jbGFzcyBEZWNvZGVyT25seU1vZGVsVHlwZSBleHRlbmRzIE1vZGVsVHlwZSB7IH07XG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBIZWxwZXIgZnVuY3Rpb25zXG5cbi8vIFdpbGwgYmUgcG9wdWxhdGVkIGxhdGVyXG5jb25zdCBNT0RFTF9UWVBFX01BUFBJTkcgPSBuZXcgTWFwKCk7XG5jb25zdCBNT0RFTF9DTEFTU19NQVBQSU5HID0gbmV3IE1hcCgpO1xuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0byBkZXRlcm1pbmUgd2hpY2ggYGZvcndhcmRgIG1ldGhvZCB0byBydW4gZm9yIGEgc3BlY2lmaWMgbW9kZWwuXG4gKiBAcGFyYW0ge09iamVjdH0gc2VsZiBUaGUgY2FsbGluZyBvYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBtb2RlbF9pbnB1dHMgVGhlIGlucHV0cyB0byBiZSBzZW50IHRvIHRoZSBtb2RlbFxuICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0Pn0gVGhlIG1vZGVsIG91dHB1dFxuICovXG5hc3luYyBmdW5jdGlvbiBmb3J3YXJkKHNlbGYsIG1vZGVsX2lucHV0cykge1xuICAgIGlmIChNT0RFTF9UWVBFX01BUFBJTkcuZ2V0KHNlbGYuY29uc3RydWN0b3IubmFtZSkgPT09IERlY29kZXJPbmx5TW9kZWxUeXBlKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCBkZWNvZGVyRm9yd2FyZChzZWxmLCBtb2RlbF9pbnB1dHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBhd2FpdCBlbmNvZGVyRm9yd2FyZChzZWxmLCBtb2RlbF9pbnB1dHMpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGFuIEluZmVyZW5jZVNlc3Npb24gdXNpbmcgYSBtb2RlbCBmaWxlIGxvY2F0ZWQgYXQgdGhlIHNwZWNpZmllZCBwYXRoLlxuICogQHBhcmFtIHtzdHJpbmd9IHByZXRyYWluZWRfbW9kZWxfbmFtZV9vcl9wYXRoIFRoZSBwYXRoIHRvIHRoZSBkaXJlY3RvcnkgY29udGFpbmluZyB0aGUgbW9kZWwgZmlsZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBmaWxlTmFtZSBUaGUgbmFtZSBvZiB0aGUgbW9kZWwgZmlsZS5cbiAqIEBwYXJhbSB7UHJldHJhaW5lZE9wdGlvbnN9IG9wdGlvbnMgQWRkaXRpb25hbCBvcHRpb25zIGZvciBsb2FkaW5nIHRoZSBtb2RlbC5cbiAqIEByZXR1cm5zIHtQcm9taXNlPEluZmVyZW5jZVNlc3Npb24+fSBBIFByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhbiBJbmZlcmVuY2VTZXNzaW9uIG9iamVjdC5cbiAqIEBwcml2YXRlXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGNvbnN0cnVjdFNlc3Npb24ocHJldHJhaW5lZF9tb2RlbF9uYW1lX29yX3BhdGgsIGZpbGVOYW1lLCBvcHRpb25zKSB7XG4gICAgLy8gVE9ETyBhZGQgb3B0aW9uIGZvciB1c2VyIHRvIGZvcmNlIHNwZWNpZnkgdGhlaXIgZGVzaXJlZCBleGVjdXRpb24gcHJvdmlkZXJcbiAgICBsZXQgbW9kZWxGaWxlTmFtZSA9IGBvbm54LyR7ZmlsZU5hbWV9JHtvcHRpb25zLnF1YW50aXplZCA/ICdfcXVhbnRpemVkJyA6ICcnfS5vbm54YDtcbiAgICBsZXQgYnVmZmVyID0gYXdhaXQgZ2V0TW9kZWxGaWxlKHByZXRyYWluZWRfbW9kZWxfbmFtZV9vcl9wYXRoLCBtb2RlbEZpbGVOYW1lLCB0cnVlLCBvcHRpb25zKTtcblxuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBhd2FpdCBJbmZlcmVuY2VTZXNzaW9uLmNyZWF0ZShidWZmZXIsIHtcbiAgICAgICAgICAgIGV4ZWN1dGlvblByb3ZpZGVycyxcbiAgICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIC8vIElmIHRoZSBleGVjdXRpb24gcHJvdmlkZWQgd2FzIG9ubHkgd2FzbSwgdGhyb3cgdGhlIGVycm9yXG4gICAgICAgIGlmIChleGVjdXRpb25Qcm92aWRlcnMubGVuZ3RoID09PSAxICYmIGV4ZWN1dGlvblByb3ZpZGVyc1swXSA9PT0gJ3dhc20nKSB7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zb2xlLndhcm4oZXJyKTtcbiAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgJ1NvbWV0aGluZyB3ZW50IHdyb25nIGR1cmluZyBtb2RlbCBjb25zdHJ1Y3Rpb24gKG1vc3QgbGlrZWx5IGEgbWlzc2luZyBvcGVyYXRpb24pLiAnICtcbiAgICAgICAgICAgICdVc2luZyBgd2FzbWAgYXMgYSBmYWxsYmFjay4gJ1xuICAgICAgICApXG4gICAgICAgIHJldHVybiBhd2FpdCBJbmZlcmVuY2VTZXNzaW9uLmNyZWF0ZShidWZmZXIsIHtcbiAgICAgICAgICAgIGV4ZWN1dGlvblByb3ZpZGVyczogWyd3YXNtJ11cbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG4vKipcbiAqIFZhbGlkYXRlIG1vZGVsIGlucHV0c1xuICogQHBhcmFtIHtJbmZlcmVuY2VTZXNzaW9ufSBzZXNzaW9uIFRoZSBJbmZlcmVuY2VTZXNzaW9uIG9iamVjdCB0aGF0IHdpbGwgYmUgcnVuLlxuICogQHBhcmFtIHtPYmplY3R9IGlucHV0cyBUaGUgaW5wdXRzIHRvIGNoZWNrLlxuICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0Pn0gQSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIGNoZWNrZWQgaW5wdXRzLlxuICogQHRocm93cyB7RXJyb3J9IElmIGFueSBpbnB1dHMgYXJlIG1pc3NpbmcuXG4gKiBAcHJpdmF0ZVxuICovXG5hc3luYyBmdW5jdGlvbiB2YWxpZGF0ZUlucHV0cyhzZXNzaW9uLCBpbnB1dHMpIHtcbiAgICAvLyBOT1RFOiBPbmx5IGNyZWF0ZSBhIHNoYWxsb3cgY29weVxuICAgIGNvbnN0IGNoZWNrZWRJbnB1dHMgPSB7fTtcbiAgICBjb25zdCBtaXNzaW5nSW5wdXRzID0gW107XG4gICAgZm9yIChsZXQgaW5wdXROYW1lIG9mIHNlc3Npb24uaW5wdXROYW1lcykge1xuICAgICAgICBpZiAoaW5wdXRzW2lucHV0TmFtZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbWlzc2luZ0lucHV0cy5wdXNoKGlucHV0TmFtZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjaGVja2VkSW5wdXRzW2lucHV0TmFtZV0gPSBpbnB1dHNbaW5wdXROYW1lXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAobWlzc2luZ0lucHV0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGBBbiBlcnJvciBvY2N1cnJlZCBkdXJpbmcgbW9kZWwgZXhlY3V0aW9uOiBcIk1pc3NpbmcgdGhlIGZvbGxvd2luZyBpbnB1dHM6ICR7bWlzc2luZ0lucHV0cy5qb2luKCcsICcpfS5gKTtcbiAgICB9XG5cbiAgICBjb25zdCBudW1JbnB1dHNQcm92aWRlZCA9IE9iamVjdC5rZXlzKGlucHV0cykubGVuZ3RoO1xuICAgIGNvbnN0IG51bUlucHV0c05lZWRlZCA9IHNlc3Npb24uaW5wdXROYW1lcy5sZW5ndGg7XG4gICAgaWYgKG51bUlucHV0c1Byb3ZpZGVkID4gbnVtSW5wdXRzTmVlZGVkKSB7XG4gICAgICAgIC8vIE5vIG1pc3NpbmcgaW5wdXRzLCBidXQgdG9vIG1hbnkgaW5wdXRzIHdlcmUgcHJvdmlkZWQuXG4gICAgICAgIC8vIFdhcm4gdGhlIHVzZXIgYW5kIGlnbm9yZSB0aGUgZXh0cmEgaW5wdXRzLlxuICAgICAgICBsZXQgaWdub3JlZCA9IE9iamVjdC5rZXlzKGlucHV0cykuZmlsdGVyKGlucHV0TmFtZSA9PiAhc2Vzc2lvbi5pbnB1dE5hbWVzLmluY2x1ZGVzKGlucHV0TmFtZSkpO1xuICAgICAgICBjb25zb2xlLndhcm4oYFdBUk5JTkc6IFRvbyBtYW55IGlucHV0cyB3ZXJlIHByb3ZpZGVkICgke251bUlucHV0c1Byb3ZpZGVkfSA+ICR7bnVtSW5wdXRzTmVlZGVkfSkuIFRoZSBmb2xsb3dpbmcgaW5wdXRzIHdpbGwgYmUgaWdub3JlZDogXCIke2lnbm9yZWQuam9pbignLCAnKX1cIi5gKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY2hlY2tlZElucHV0cztcbn1cblxuLyoqXG4gKiBFeGVjdXRlcyBhbiBJbmZlcmVuY2VTZXNzaW9uIHVzaW5nIHRoZSBzcGVjaWZpZWQgaW5wdXRzLlxuICogTk9URTogYGlucHV0c2AgbXVzdCBjb250YWluIGF0IGxlYXN0IHRoZSBpbnB1dCBuYW1lcyBvZiB0aGUgbW9kZWwuXG4gKiAgLSBJZiBhZGRpdGlvbmFsIGlucHV0cyBhcmUgcGFzc2VkLCB0aGV5IHdpbGwgYmUgaWdub3JlZC5cbiAqICAtIElmIGlucHV0cyBhcmUgbWlzc2luZywgYW4gZXJyb3Igd2lsbCBiZSB0aHJvd24uXG4gKiBcbiAqIEBwYXJhbSB7SW5mZXJlbmNlU2Vzc2lvbn0gc2Vzc2lvbiBUaGUgSW5mZXJlbmNlU2Vzc2lvbiBvYmplY3QgdG8gcnVuLlxuICogQHBhcmFtIHtPYmplY3R9IGlucHV0cyBBbiBvYmplY3QgdGhhdCBtYXBzIGlucHV0IG5hbWVzIHRvIGlucHV0IHRlbnNvcnMuXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fSBBIFByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhbiBvYmplY3QgdGhhdCBtYXBzIG91dHB1dCBuYW1lcyB0byBvdXRwdXQgdGVuc29ycy5cbiAqIEBwcml2YXRlXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHNlc3Npb25SdW4oc2Vzc2lvbiwgaW5wdXRzKSB7XG4gICAgY29uc3QgY2hlY2tlZElucHV0cyA9IGF3YWl0IHZhbGlkYXRlSW5wdXRzKHNlc3Npb24sIGlucHV0cyk7XG4gICAgdHJ5IHtcbiAgICAgICAgbGV0IG91dHB1dCA9IGF3YWl0IHNlc3Npb24ucnVuKGNoZWNrZWRJbnB1dHMpO1xuICAgICAgICBvdXRwdXQgPSByZXBsYWNlVGVuc29ycyhvdXRwdXQpO1xuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gVGhpcyB1c3VhbGx5IG9jY3VycyB3aGVuIHRoZSBpbnB1dHMgYXJlIG9mIHRoZSB3cm9uZyB0eXBlLlxuICAgICAgICBjb25zb2xlLmVycm9yKGBBbiBlcnJvciBvY2N1cnJlZCBkdXJpbmcgbW9kZWwgZXhlY3V0aW9uOiBcIiR7ZX1cIi5gKTtcbiAgICAgICAgY29uc29sZS5lcnJvcignSW5wdXRzIGdpdmVuIHRvIG1vZGVsOicsIGNoZWNrZWRJbnB1dHMpO1xuICAgICAgICB0aHJvdyBlO1xuICAgIH1cbn1cblxuLyoqXG4gKiBSZXBsYWNlcyBPTk5YIFRlbnNvciBvYmplY3RzIHdpdGggY3VzdG9tIFRlbnNvciBvYmplY3RzIHRvIHN1cHBvcnQgYWRkaXRpb25hbCBmdW5jdGlvbnMuXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gcmVwbGFjZSB0ZW5zb3Igb2JqZWN0cyBpbi5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBvYmplY3Qgd2l0aCB0ZW5zb3Igb2JqZWN0cyByZXBsYWNlZCBieSBjdXN0b20gVGVuc29yIG9iamVjdHMuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiByZXBsYWNlVGVuc29ycyhvYmopIHtcbiAgICBmb3IgKGxldCBwcm9wIGluIG9iaikge1xuICAgICAgICBpZiAob2JqW3Byb3BdIGluc3RhbmNlb2YgT05OWFRlbnNvcikge1xuICAgICAgICAgICAgb2JqW3Byb3BdID0gbmV3IFRlbnNvcihvYmpbcHJvcF0pO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBvYmpbcHJvcF0gPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICByZXBsYWNlVGVuc29ycyhvYmpbcHJvcF0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG59XG5cblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBhcnJheSBvciBUZW5zb3Igb2YgaW50ZWdlcnMgdG8gYW4gaW50NjQgVGVuc29yLlxuICogQHBhcmFtIHtBcnJheXxUZW5zb3J9IGl0ZW1zIFRoZSBpbnB1dCBpbnRlZ2VycyB0byBiZSBjb252ZXJ0ZWQuXG4gKiBAcmV0dXJucyB7VGVuc29yfSBUaGUgaW50NjQgVGVuc29yIHdpdGggdGhlIGNvbnZlcnRlZCB2YWx1ZXMuXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIGlucHV0IGFycmF5IGlzIGVtcHR5IG9yIHRoZSBpbnB1dCBpcyBhIGJhdGNoZWQgVGVuc29yIGFuZCBub3QgYWxsIHNlcXVlbmNlcyBoYXZlIHRoZSBzYW1lIGxlbmd0aC5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHRvSTY0VGVuc29yKGl0ZW1zKSB7XG4gICAgaWYgKGl0ZW1zIGluc3RhbmNlb2YgVGVuc29yKSB7XG4gICAgICAgIHJldHVybiBpdGVtcztcbiAgICB9XG4gICAgLy8gaXRlbXMgaXMgYW4gYXJyYXlcbiAgICBpZiAoaXRlbXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRocm93IEVycm9yKFwiaXRlbXMgbXVzdCBiZSBub24tZW1wdHlcIik7XG4gICAgfVxuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoaXRlbXNbMF0pKSB7XG4gICAgICAgIC8vIGJhdGNoZWRcbiAgICAgICAgaWYgKGl0ZW1zLnNvbWUoeCA9PiB4Lmxlbmd0aCAhPT0gaXRlbXNbMF0ubGVuZ3RoKSkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJVbmFibGUgdG8gY3JlYXRlIHRlbnNvciwgeW91IHNob3VsZCBwcm9iYWJseSBhY3RpdmF0ZSB0cnVuY2F0aW9uIGFuZC9vciBwYWRkaW5nIHdpdGggJ3BhZGRpbmc9VHJ1ZScgYW5kL29yICd0cnVuY2F0aW9uPVRydWUnIHRvIGhhdmUgYmF0Y2hlZCB0ZW5zb3JzIHdpdGggdGhlIHNhbWUgbGVuZ3RoLlwiKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5ldyBUZW5zb3IoJ2ludDY0JyxcbiAgICAgICAgICAgIEJpZ0ludDY0QXJyYXkuZnJvbShpdGVtcy5mbGF0KCkubWFwKHggPT4gQmlnSW50KHgpKSksXG4gICAgICAgICAgICBbaXRlbXMubGVuZ3RoLCBpdGVtc1swXS5sZW5ndGhdXG4gICAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy9mbGF0XG4gICAgICAgIHJldHVybiBuZXcgVGVuc29yKCdpbnQ2NCcsXG4gICAgICAgICAgICBCaWdJbnQ2NEFycmF5LmZyb20oaXRlbXMubWFwKHggPT4gQmlnSW50KHgpKSksXG4gICAgICAgICAgICBbMSwgaXRlbXMubGVuZ3RoXVxuICAgICAgICApO1xuICAgIH1cbn1cblxuLyoqXG4gKiBQcmVwYXJlcyBhbiBhdHRlbnRpb24gbWFzayBmb3IgYSBzZXF1ZW5jZSBvZiB0b2tlbnMgYmFzZWQgb24gY29uZmlndXJhdGlvbiBvcHRpb25zLlxuICogQHBhcmFtIHtPYmplY3R9IHNlbGYgVGhlIGNhbGxpbmcgb2JqZWN0IGluc3RhbmNlLlxuICogQHBhcmFtIHtUZW5zb3J9IHRva2VucyBUaGUgaW5wdXQgdG9rZW5zLlxuICogQHJldHVybnMge1RlbnNvcn0gVGhlIGF0dGVudGlvbiBtYXNrIHRlbnNvci5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHByZXBhcmVBdHRlbnRpb25NYXNrKHNlbGYsIHRva2Vucykge1xuXG4gICAgLy8gUHJlcGFyZSBhdHRlbnRpb24gbWFza1xuICAgIGxldCBwYWRfdG9rZW5faWQgPSBzZWxmLmNvbmZpZy5wYWRfdG9rZW5faWQgPz8gbnVsbDtcbiAgICBsZXQgZW9zX3Rva2VuX2lkID0gc2VsZi5jb25maWcuZW9zX3Rva2VuX2lkID8/IG51bGw7XG4gICAgaWYgKGlzSW50ZWdyYWxOdW1iZXIoZW9zX3Rva2VuX2lkKSkge1xuICAgICAgICBlb3NfdG9rZW5faWQgPSBbZW9zX3Rva2VuX2lkXTtcbiAgICB9XG5cbiAgICBsZXQgaXNfcGFkX3Rva2VuX2luX2lucHV0cyA9IHRva2Vucy5pbmRleE9mKHBhZF90b2tlbl9pZCkgIT09IC0xO1xuICAgIGxldCBpc19wYWRfdG9rZW5fbm90X2VxdWFsX3RvX2Vvc190b2tlbl9pZCA9IChlb3NfdG9rZW5faWQgPT09IG51bGwpIHx8ICFlb3NfdG9rZW5faWQuaW5jbHVkZXMocGFkX3Rva2VuX2lkKVxuXG4gICAgaWYgKGlzX3BhZF90b2tlbl9pbl9pbnB1dHMgJiYgaXNfcGFkX3Rva2VuX25vdF9lcXVhbF90b19lb3NfdG9rZW5faWQpIHtcbiAgICAgICAgbGV0IGRhdGEgPSBCaWdJbnQ2NEFycmF5LmZyb20oXG4gICAgICAgICAgICAvLyBOb3RlOiAhPSBzbyB0aGF0IGludCBtYXRjaGVzIGJpZ2ludFxuICAgICAgICAgICAgdG9rZW5zLmRhdGEubWFwKHggPT4geCAhPSBwYWRfdG9rZW5faWQpXG4gICAgICAgIClcbiAgICAgICAgcmV0dXJuIG5ldyBUZW5zb3IoJ2ludDY0JywgZGF0YSwgdG9rZW5zLmRpbXMpXG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUZW5zb3IoXG4gICAgICAgICAgICAnaW50NjQnLFxuICAgICAgICAgICAgbmV3IEJpZ0ludDY0QXJyYXkodG9rZW5zLmRhdGEubGVuZ3RoKS5maWxsKDFuKSxcbiAgICAgICAgICAgIHRva2Vucy5kaW1zXG4gICAgICAgIClcbiAgICB9XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGJvb2xlYW4gdGVuc29yIHdpdGggYSBzaW5nbGUgdmFsdWUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHZhbHVlIFRoZSB2YWx1ZSBvZiB0aGUgdGVuc29yLlxuICogQHJldHVybnMge1RlbnNvcn0gVGhlIGJvb2xlYW4gdGVuc29yLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gYm9vbFRlbnNvcih2YWx1ZSkge1xuICAgIHJldHVybiBuZXcgVGVuc29yKCdib29sJywgW3ZhbHVlXSwgWzFdKTtcbn1cblxuLy8gSlMgZG9lc24ndCBzdXBwb3J0IG1peGlucywgc28gd2UgZGVmaW5lIHNvbWUgcmV1c2VkIGZ1bmN0aW9ucyBoZXJlLCBhbmQgYWxsb3cgXCJ0aGlzXCIgdG8gYmUgcGFzc2VkIGluXG4vKipcbiAqIFBlcmZvcm0gZm9yd2FyZCBwYXNzIG9uIHRoZSBzZXEyc2VxIG1vZGVsIChib3RoIGVuY29kZXIgYW5kIGRlY29kZXIpLlxuICogQHBhcmFtIHtPYmplY3R9IHNlbGYgVGhlIHNlcTJzZXEgbW9kZWwgb2JqZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IG1vZGVsX2lucHV0cyBUaGUgaW5wdXQgb2JqZWN0IGZvciB0aGUgbW9kZWwgY29udGFpbmluZyBlbmNvZGVyIGFuZCBkZWNvZGVyIGlucHV0cy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIFRoZSBvcHRpb25zXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmFkZF9kZWNvZGVyX3Brdj10cnVlXSBGbGFnIHRvIGFkZCB0aGUgZGVjb2RlciBwYXN0IGtleSB2YWx1ZXMuXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxTZXEyU2VxTE1PdXRwdXQ+fSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgb3V0cHV0IG9mIHRoZSBzZXEyc2VxIG1vZGVsLlxuICogQHByaXZhdGVcbiAqL1xuYXN5bmMgZnVuY3Rpb24gc2VxMnNlcUZvcndhcmQoc2VsZiwgbW9kZWxfaW5wdXRzLCB7XG4gICAgYWRkX2RlY29kZXJfcGt2ID0gdHJ1ZVxufSA9IHt9KSB7XG4gICAgbGV0IHsgZW5jb2Rlcl9vdXRwdXRzLCBwYXN0X2tleV92YWx1ZXMgfSA9IG1vZGVsX2lucHV0cztcblxuICAgIGlmICghZW5jb2Rlcl9vdXRwdXRzKSB7XG4gICAgICAgIC8vIEVuY29kZXIgb3V0cHV0cyBhcmUgbm90IGdpdmVuLCBzbyB3ZSBtdXN0IGNvbXB1dGUgdGhlbS5cbiAgICAgICAgZW5jb2Rlcl9vdXRwdXRzID0gKGF3YWl0IGVuY29kZXJGb3J3YXJkKHNlbGYsIG1vZGVsX2lucHV0cykpLmxhc3RfaGlkZGVuX3N0YXRlO1xuICAgIH1cbiAgICBsZXQgZGVjb2RlckZlZWRzID0ge1xuICAgICAgICBpbnB1dF9pZHM6IG1vZGVsX2lucHV0cy5kZWNvZGVyX2lucHV0X2lkcyxcbiAgICAgICAgZW5jb2Rlcl9oaWRkZW5fc3RhdGVzOiBlbmNvZGVyX291dHB1dHMsXG4gICAgICAgIHVzZV9jYWNoZV9icmFuY2g6IGJvb2xUZW5zb3IoISFwYXN0X2tleV92YWx1ZXMpXG4gICAgfTtcblxuICAgIGlmIChzZWxmLmRlY29kZXJfbWVyZ2VkX3Nlc3Npb24uaW5wdXROYW1lcy5pbmNsdWRlcygnZW5jb2Rlcl9hdHRlbnRpb25fbWFzaycpKSB7XG4gICAgICAgIGRlY29kZXJGZWVkcy5lbmNvZGVyX2F0dGVudGlvbl9tYXNrID0gbW9kZWxfaW5wdXRzLmF0dGVudGlvbl9tYXNrXG4gICAgfVxuICAgIHNlbGYuYWRkUGFzdEtleVZhbHVlcyhkZWNvZGVyRmVlZHMsIHBhc3Rfa2V5X3ZhbHVlcywgYWRkX2RlY29kZXJfcGt2KTtcblxuICAgIGNvbnN0IGRlY29kZXJSZXN1bHRzID0gYXdhaXQgc2Vzc2lvblJ1bihzZWxmLmRlY29kZXJfbWVyZ2VkX3Nlc3Npb24sIGRlY29kZXJGZWVkcyk7XG4gICAgbGV0IGxvZ2l0cyA9IGRlY29kZXJSZXN1bHRzLmxvZ2l0cztcbiAgICBwYXN0X2tleV92YWx1ZXMgPSBzZWxmLmdldFBhc3RLZXlWYWx1ZXMoZGVjb2RlclJlc3VsdHMsIHBhc3Rfa2V5X3ZhbHVlcyk7XG5cbiAgICAvLyBHZXQgY3Jvc3MgYXR0ZW50aW9uIGFuZC9vciBkZWNvZGVyIGF0dGVudGlvbnMgaWYgdGhleSBhcmUgcHJlc2VudFxuICAgIGNvbnN0IGF0dG5zID0gc2VsZi5nZXRBdHRlbnRpb25zKGRlY29kZXJSZXN1bHRzKTtcblxuICAgIHJldHVybiBuZXcgU2VxMlNlcUxNT3V0cHV0KHsgbG9naXRzLCBwYXN0X2tleV92YWx1ZXMsIGVuY29kZXJfb3V0cHV0cywgLi4uYXR0bnMgfSk7XG59XG5cbi8qKlxuICogU3RhcnQgdGhlIGJlYW0gc2VhcmNoIHByb2Nlc3MgZm9yIHRoZSBzZXEyc2VxIG1vZGVsLlxuICogQHBhcmFtIHtPYmplY3R9IHNlbGYgVGhlIHNlcTJzZXEgbW9kZWwgb2JqZWN0LlxuICogQHBhcmFtIHtPYmplY3RbXX0gaW5wdXRUb2tlbklkcyBBcnJheSBvZiBpbnB1dCB0b2tlbiBpZHMgZm9yIGVhY2ggaW5wdXQgc2VxdWVuY2UuXG4gKiBAcGFyYW0ge251bWJlcn0gbnVtT3V0cHV0VG9rZW5zIFRoZSBtYXhpbXVtIG51bWJlciBvZiBvdXRwdXQgdG9rZW5zIGZvciB0aGUgbW9kZWwuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtyZXF1aXJlc19hdHRlbnRpb25fbWFzaz10cnVlXSBGbGFnIHRvIGluZGljYXRlIGlmIHRoZSBtb2RlbCByZXF1aXJlcyBhbiBhdHRlbnRpb24gbWFzay5cbiAqIEByZXR1cm5zIHtPYmplY3RbXX0gQXJyYXkgb2YgYmVhbSBzZWFyY2ggb2JqZWN0cy5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHNlcTJzZXFTdGFydEJlYW1zKHNlbGYsIGlucHV0VG9rZW5JZHMsIG51bU91dHB1dFRva2VucywgcmVxdWlyZXNfYXR0ZW50aW9uX21hc2sgPSB0cnVlKSB7XG4gICAgbGV0IGJlYW1zID0gW107XG4gICAgbGV0IGJlYW1JZCA9IDA7XG5cbiAgICAvLyBkZWNvZGVyX2lucHV0X2lkcyA9PSBvdXRwdXRfdG9rZW5faWRzXG4gICAgbGV0IGRlY29kZXJfaW5wdXRfaWRzID0gc2VsZi5jb25maWcuZGVjb2Rlcl9zdGFydF90b2tlbl9pZDtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoZGVjb2Rlcl9pbnB1dF9pZHMpKSB7XG4gICAgICAgIGRlY29kZXJfaW5wdXRfaWRzID0gW2RlY29kZXJfaW5wdXRfaWRzXTtcbiAgICB9XG5cbiAgICBmb3IgKGxldCB0b2tlbnMgb2YgaW5wdXRUb2tlbklkcykge1xuICAgICAgICAvLyBUT0RPOiBJbXByb3ZlXG4gICAgICAgIC8vIEN1cnJlbnRseSwganVzdCBhZGQgYmFjayBiYXRjaCBkaW1lbnNpb24uXG4gICAgICAgIC8vIEluIGZ1dHVyZSwgYWxsb3cgZm9yIHRydWUgcGFyYWxsZWwgZXhlY3V0aW9uXG4gICAgICAgIHRva2Vucy5kaW1zID0gWzEsIC4uLnRva2Vucy5kaW1zXVxuXG4gICAgICAgIC8vIENyZWF0ZSBiZWFtXG4gICAgICAgIGxldCBzdGFydCA9IHtcbiAgICAgICAgICAgIGlucHV0czogdG9rZW5zLFxuICAgICAgICAgICAgZW5jb2Rlcl9vdXRwdXRzOiBudWxsLFxuICAgICAgICAgICAgcHJldl9tb2RlbF9vdXRwdXRzOiBudWxsLFxuXG4gICAgICAgICAgICBvdXRwdXRfdG9rZW5faWRzOiBkZWNvZGVyX2lucHV0X2lkcyxcbiAgICAgICAgICAgIGRvbmU6IGZhbHNlLFxuICAgICAgICAgICAgc2NvcmU6IDAsXG4gICAgICAgICAgICBpZDogYmVhbUlkKysgLy8gYXNzaWduIHVuaXF1ZSBpZCB0byBiZWFtc1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlcXVpcmVzX2F0dGVudGlvbl9tYXNrKSB7XG4gICAgICAgICAgICBzdGFydC5hdHRlbnRpb25fbWFzayA9IHByZXBhcmVBdHRlbnRpb25NYXNrKHNlbGYsIHRva2Vucyk7XG4gICAgICAgIH1cblxuICAgICAgICBiZWFtcy5wdXNoKHN0YXJ0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gYmVhbXM7XG59XG5cbi8qKlxuICogUnVuIGJlYW0gc2VhcmNoIG9uIHRoZSBzZXEyc2VxIG1vZGVsIGZvciBhIHNpbmdsZSBiZWFtLlxuICogQHBhcmFtIHtPYmplY3R9IHNlbGYgVGhlIHNlcTJzZXEgbW9kZWwgb2JqZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IGJlYW0gVGhlIGJlYW0gc2VhcmNoIG9iamVjdCBmb3Igd2hpY2ggdG8gcnVuIHRoZSBtb2RlbC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIG9wdGlvbnNcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5pbnB1dF9uYW1lPSdpbnB1dF9pZHMnXSBUaGUgbmFtZSBvZiB0aGUgaW5wdXQgdGVuc29yIGZvciB0aGUgZW5jb2Rlci5cbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD59IFByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSBvdXRwdXQgb2YgdGhlIHNlcTJzZXEgbW9kZWwgZm9yIHRoZSBnaXZlbiBiZWFtLlxuICogQHByaXZhdGVcbiAqL1xuYXN5bmMgZnVuY3Rpb24gc2VxMnNlcVJ1bkJlYW0oc2VsZiwgYmVhbSwge1xuICAgIGlucHV0X25hbWUgPSAnaW5wdXRfaWRzJyxcbn0gPSB7fVxuKSB7XG4gICAgLy8gMS4gUHJlcGFyZVxuICAgIGxldCBtb2RlbF9pbnB1dHMgPSB7XG4gICAgICAgIFtpbnB1dF9uYW1lXTogYmVhbS5pbnB1dHMsXG4gICAgICAgIGRlY29kZXJfaW5wdXRfaWRzOiB0b0k2NFRlbnNvcihiZWFtLm91dHB1dF90b2tlbl9pZHMuc2xpY2UoLTEpKSxcbiAgICAgICAgZW5jb2Rlcl9vdXRwdXRzOiBiZWFtLmVuY29kZXJfb3V0cHV0cyxcbiAgICAgICAgcGFzdF9rZXlfdmFsdWVzOiBiZWFtLnByZXZfbW9kZWxfb3V0cHV0cz8ucGFzdF9rZXlfdmFsdWVzLFxuICAgIH1cbiAgICBpZiAoYmVhbS5hdHRlbnRpb25fbWFzaykge1xuICAgICAgICBtb2RlbF9pbnB1dHMuYXR0ZW50aW9uX21hc2sgPSBiZWFtLmF0dGVudGlvbl9tYXNrXG4gICAgfVxuXG4gICAgLy8gMi4gUnVuXG4gICAgbGV0IG91dHB1dCA9IGF3YWl0IHNlbGYuZm9yd2FyZChtb2RlbF9pbnB1dHMpO1xuXG4gICAgLy8gMy4gVXBkYXRlXG4gICAgYmVhbS5wcmV2X21vZGVsX291dHB1dHMgPSBvdXRwdXQ7XG4gICAgYmVhbS5lbmNvZGVyX291dHB1dHMgPSBvdXRwdXQuZW5jb2Rlcl9vdXRwdXRzO1xuXG4gICAgcmV0dXJuIG91dHB1dDtcbn1cblxuLyoqXG4gKiBGb3J3YXJkIHBhc3Mgb2YgYW4gZW5jb2RlciBtb2RlbC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzZWxmIFRoZSBlbmNvZGVyIG1vZGVsLlxuICogQHBhcmFtIHtPYmplY3R9IG1vZGVsX2lucHV0cyBUaGUgaW5wdXQgZGF0YSB0byBiZSB1c2VkIGZvciB0aGUgZm9yd2FyZCBwYXNzLlxuICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0Pn0gUHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggYW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIG1vZGVsJ3Mgb3V0cHV0cy5cbiAqIEBwcml2YXRlXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGVuY29kZXJGb3J3YXJkKHNlbGYsIG1vZGVsX2lucHV0cykge1xuICAgIGxldCBlbmNvZGVyRmVlZHMgPSB7fTtcbiAgICBmb3IgKGxldCBrZXkgb2Ygc2VsZi5zZXNzaW9uLmlucHV0TmFtZXMpIHtcbiAgICAgICAgZW5jb2RlckZlZWRzW2tleV0gPSBtb2RlbF9pbnB1dHNba2V5XTtcbiAgICB9XG4gICAgcmV0dXJuIGF3YWl0IHNlc3Npb25SdW4oc2VsZi5zZXNzaW9uLCBlbmNvZGVyRmVlZHMpO1xufVxuXG5cbi8qKlxuICogRm9yd2FyZCBwYXNzIG9mIGEgZGVjb2RlciBtb2RlbC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzZWxmIFRoZSBkZWNvZGVyIG1vZGVsLlxuICogQHBhcmFtIHtPYmplY3R9IG1vZGVsX2lucHV0cyBUaGUgaW5wdXQgZGF0YSB0byBiZSB1c2VkIGZvciB0aGUgZm9yd2FyZCBwYXNzLlxuICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0Pn0gUHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggYW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGxvZ2l0cyBhbmQgcGFzdCBrZXkgdmFsdWVzLlxuICogQHByaXZhdGVcbiAqL1xuYXN5bmMgZnVuY3Rpb24gZGVjb2RlckZvcndhcmQoc2VsZiwgbW9kZWxfaW5wdXRzKSB7XG4gICAgbGV0IHsgaW5wdXRfaWRzLCBwYXN0X2tleV92YWx1ZXMsIGF0dGVudGlvbl9tYXNrIH0gPSBtb2RlbF9pbnB1dHM7XG4gICAgbGV0IGRlY29kZXJGZWVkcyA9IHtcbiAgICAgICAgaW5wdXRfaWRzOiBpbnB1dF9pZHMsXG4gICAgICAgIGF0dGVudGlvbl9tYXNrOiBhdHRlbnRpb25fbWFzayA/PyBwcmVwYXJlQXR0ZW50aW9uTWFzayhzZWxmLCBpbnB1dF9pZHMpLFxuICAgICAgICB1c2VfY2FjaGVfYnJhbmNoOiBib29sVGVuc29yKHBhc3Rfa2V5X3ZhbHVlcyAhPT0gbnVsbClcbiAgICB9XG5cbiAgICBzZWxmLmFkZFBhc3RLZXlWYWx1ZXMoZGVjb2RlckZlZWRzLCBwYXN0X2tleV92YWx1ZXMpO1xuXG4gICAgbGV0IGRlY29kZXJSZXN1bHRzID0gYXdhaXQgc2Vzc2lvblJ1bihzZWxmLnNlc3Npb24sIGRlY29kZXJGZWVkcyk7XG5cbiAgICBsZXQgbG9naXRzID0gZGVjb2RlclJlc3VsdHMubG9naXRzO1xuXG4gICAgcGFzdF9rZXlfdmFsdWVzID0gc2VsZi5nZXRQYXN0S2V5VmFsdWVzKGRlY29kZXJSZXN1bHRzLCBwYXN0X2tleV92YWx1ZXMpO1xuICAgIHJldHVybiB7IGxvZ2l0cywgcGFzdF9rZXlfdmFsdWVzIH07XG59XG5cbi8qKlxuICogU3RhcnRzIHRoZSBnZW5lcmF0aW9uIG9mIHRleHQgYnkgaW5pdGlhbGl6aW5nIHRoZSBiZWFtcyBmb3IgdGhlIGdpdmVuIGlucHV0IHRva2VuIElEcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzZWxmIFRoZSB0ZXh0IGdlbmVyYXRpb24gbW9kZWwgb2JqZWN0LlxuICogQHBhcmFtIHthbnl9IGlucHV0VG9rZW5JZHMgQW4gYXJyYXkgb2YgaW5wdXQgdG9rZW4gSURzIHRvIGdlbmVyYXRlIHRleHQgZnJvbS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBudW1PdXRwdXRUb2tlbnMgVGhlIG1heGltdW0gbnVtYmVyIG9mIHRva2VucyB0byBnZW5lcmF0ZSBmb3IgZWFjaCBiZWFtLlxuICogQHBhcmFtIHtUZW5zb3J9IFtpbnB1dHNfYXR0ZW50aW9uX21hc2tdIFRoZSBhdHRlbnRpb24gbWFzayB0ZW5zb3IgZm9yIHRoZSBpbnB1dCB0b2tlbiBJRHMuXG4gKiBAcmV0dXJucyB7T2JqZWN0W119IEFuIGFycmF5IG9mIGJlYW1zIGluaXRpYWxpemVkIHdpdGggdGhlIGdpdmVuIGlucHV0cyBhbmQgcGFyYW1ldGVycy5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGRlY29kZXJTdGFydEJlYW1zKHNlbGYsIGlucHV0VG9rZW5JZHMsIG51bU91dHB1dFRva2VucywgaW5wdXRzX2F0dGVudGlvbl9tYXNrKSB7XG4gICAgbGV0IGJlYW1zID0gW107XG5cbiAgICBsZXQgYmVhbUlkID0gMDtcbiAgICBmb3IgKGxldCB0b2tlbnMgb2YgaW5wdXRUb2tlbklkcykge1xuICAgICAgICBsZXQgb3V0cHV0X3Rva2VuX2lkcyA9IHRva2Vucy50b2xpc3QoKS5tYXAoTnVtYmVyKTtcblxuICAgICAgICAvLyBUT0RPOiBJbXByb3ZlXG4gICAgICAgIC8vIEN1cnJlbnRseSwganVzdCBhZGQgYmFjayBiYXRjaCBkaW1lbnNpb24uXG4gICAgICAgIC8vIEluIGZ1dHVyZSwgYWxsb3cgZm9yIHRydWUgcGFyYWxsZWwgZXhlY3V0aW9uXG4gICAgICAgIHRva2Vucy5kaW1zID0gWzEsIC4uLnRva2Vucy5kaW1zXVxuXG4gICAgICAgIGxldCBhdHRuX21hc2s7XG4gICAgICAgIGlmIChpbnB1dHNfYXR0ZW50aW9uX21hc2spIHtcbiAgICAgICAgICAgIGF0dG5fbWFzayA9IGlucHV0c19hdHRlbnRpb25fbWFza1tiZWFtSWRdO1xuICAgICAgICAgICAgYXR0bl9tYXNrLmRpbXMgPSBbMSwgLi4uYXR0bl9tYXNrLmRpbXNdXG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGF0dG5fbWFzayA9IHByZXBhcmVBdHRlbnRpb25NYXNrKHNlbGYsIHRva2VucylcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBzdGFydCA9IHtcbiAgICAgICAgICAgIGlucHV0OiB0b2tlbnMsXG4gICAgICAgICAgICBtb2RlbF9pbnB1dF9pZHM6IHRva2VucyxcbiAgICAgICAgICAgIGF0dGVudGlvbl9tYXNrOiBhdHRuX21hc2ssXG4gICAgICAgICAgICBwcmV2X21vZGVsX291dHB1dHM6IG51bGwsXG5cbiAgICAgICAgICAgIG91dHB1dF90b2tlbl9pZHM6IG91dHB1dF90b2tlbl9pZHMsXG4gICAgICAgICAgICBudW1fb3V0cHV0X3Rva2VuczogbnVtT3V0cHV0VG9rZW5zLFxuXG4gICAgICAgICAgICBkb25lOiBmYWxzZSxcbiAgICAgICAgICAgIHNjb3JlOiAwLFxuICAgICAgICAgICAgaWQ6IGJlYW1JZCsrIC8vIGFzc2lnbiB1bmlxdWUgaWQgdG8gYmVhbXNcbiAgICAgICAgfVxuXG4gICAgICAgIGJlYW1zLnB1c2goc3RhcnQpO1xuICAgIH1cbiAgICByZXR1cm4gYmVhbXM7XG59XG5cbi8qKlxuICogUnVucyBhIHNpbmdsZSBzdGVwIG9mIHRoZSB0ZXh0IGdlbmVyYXRpb24gcHJvY2VzcyBmb3IgYSBnaXZlbiBiZWFtLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBzZWxmIFRoZSBkZWNvZGVyIG9iamVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBiZWFtIFRoZSBiZWFtIHRvIHJ1bi5cbiAqIEBwYXJhbSB7VGVuc29yfSBiZWFtLmlucHV0IFRoZSBpbnB1dCB0ZW5zb3IuXG4gKiBAcGFyYW0ge1RlbnNvcn0gYmVhbS5tb2RlbF9pbnB1dF9pZHMgVGhlIGlucHV0IGlkcyB0byB0aGUgbW9kZWwuXG4gKiBAcGFyYW0ge1RlbnNvcn0gYmVhbS5hdHRlbnRpb25fbWFzayBUaGUgYXR0ZW50aW9uIG1hc2suXG4gKiBAcGFyYW0ge09iamVjdH0gYmVhbS5wcmV2X21vZGVsX291dHB1dHMgVGhlIHBhc3Qga2V5IHZhbHVlcy5cbiAqIEBwYXJhbSB7bnVtYmVyW119IGJlYW0ub3V0cHV0X3Rva2VuX2lkcyBUaGUgb3V0cHV0IHRva2VuIGlkcy5cbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD59IFRoZSBvdXRwdXQgb2YgdGhlIGdlbmVyYXRpb24gc3RlcC5cbiAqIEBwcml2YXRlXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGRlY29kZXJSdW5CZWFtKHNlbGYsIGJlYW0pIHtcbiAgICBsZXQgYXR0bk1hc2tEYXRhID0gbmV3IEJpZ0ludDY0QXJyYXkoYmVhbS5vdXRwdXRfdG9rZW5faWRzLmxlbmd0aCkuZmlsbCgxbilcblxuICAgIC8vIDEuIFByZXBhcmVcbiAgICBsZXQgbW9kZWxfaW5wdXRzID0ge1xuICAgICAgICBpbnB1dF9pZHM6IGJlYW0ubW9kZWxfaW5wdXRfaWRzLFxuICAgICAgICBhdHRlbnRpb25fbWFzazogbmV3IFRlbnNvcihcbiAgICAgICAgICAgICdpbnQ2NCcsXG4gICAgICAgICAgICBhdHRuTWFza0RhdGEsXG4gICAgICAgICAgICBbMSwgYXR0bk1hc2tEYXRhLmxlbmd0aF1cbiAgICAgICAgKSxcbiAgICAgICAgcGFzdF9rZXlfdmFsdWVzOiBiZWFtLnByZXZfbW9kZWxfb3V0cHV0cz8ucGFzdF9rZXlfdmFsdWVzLFxuICAgIH1cblxuICAgIC8vIDIuIFJ1blxuICAgIGxldCBvdXRwdXQgPSBhd2FpdCBzZWxmLmZvcndhcmQobW9kZWxfaW5wdXRzKTtcblxuICAgIC8vIDMuIFVwZGF0ZVxuICAgIGJlYW0ucHJldl9tb2RlbF9vdXRwdXRzID0gb3V0cHV0O1xuXG4gICAgcmV0dXJuIG91dHB1dDtcbn1cblxuLyoqXG4gKiBVcGRhdGUgYSBiZWFtIHdpdGggYSBuZXcgdG9rZW4gSUQuXG4gKiBAcGFyYW0ge09iamVjdH0gYmVhbSBUaGUgYmVhbSB0byB1cGRhdGUuXG4gKiBAcGFyYW0ge251bWJlcn0gbmV3VG9rZW5JZCBUaGUgbmV3IHRva2VuIElEIHRvIGFkZCB0byB0aGUgYmVhbSdzIG91dHB1dC5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGRlY29kZXJVcGRhdGViZWFtKGJlYW0sIG5ld1Rva2VuSWQpIHtcbiAgICBiZWFtLm91dHB1dF90b2tlbl9pZHMgPSBbLi4uYmVhbS5vdXRwdXRfdG9rZW5faWRzLCBuZXdUb2tlbklkXTtcbiAgICBiZWFtLm1vZGVsX2lucHV0X2lkcyA9IG5ldyBUZW5zb3IoJ2ludDY0JywgW0JpZ0ludChuZXdUb2tlbklkKV0sIFsxLCAxXSk7XG59XG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLyoqXG4gKiBBIGJhc2UgY2xhc3MgZm9yIHByZS10cmFpbmVkIG1vZGVscyB0aGF0IHByb3ZpZGVzIHRoZSBtb2RlbCBjb25maWd1cmF0aW9uIGFuZCBhbiBPTk5YIHNlc3Npb24uXG4gKiBAZXh0ZW5kcyBDYWxsYWJsZVxuICovXG5leHBvcnQgY2xhc3MgUHJlVHJhaW5lZE1vZGVsIGV4dGVuZHMgQ2FsbGFibGUge1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiB0aGUgYFByZVRyYWluZWRNb2RlbGAgY2xhc3MuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBUaGUgbW9kZWwgY29uZmlndXJhdGlvbi5cbiAgICAgKiBAcGFyYW0ge2FueX0gc2Vzc2lvbiBzZXNzaW9uIGZvciB0aGUgbW9kZWwuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY29uZmlnLCBzZXNzaW9uKSB7XG4gICAgICAgIHN1cGVyKCk7XG5cbiAgICAgICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgICAgIHRoaXMuc2Vzc2lvbiA9IHNlc3Npb247XG4gICAgfVxuXG4gICAgLyoqXG4gICAgKiBEaXNwb3NlcyBvZiBhbGwgdGhlIE9OTlggc2Vzc2lvbnMgdGhhdCB3ZXJlIGNyZWF0ZWQgZHVyaW5nIGluZmVyZW5jZS5cbiAgICAqIEByZXR1cm5zIHtQcm9taXNlPHVua25vd25bXT59IEFuIGFycmF5IG9mIHByb21pc2VzLCBvbmUgZm9yIGVhY2ggT05OWCBzZXNzaW9uIHRoYXQgaXMgYmVpbmcgZGlzcG9zZWQuXG4gICAgKiBAdG9kbyBVc2UgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRmluYWxpemF0aW9uUmVnaXN0cnlcbiAgICAqL1xuICAgIGFzeW5jIGRpc3Bvc2UoKSB7XG4gICAgICAgIGxldCBwcm9taXNlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBrZXkgb2YgT2JqZWN0LmtleXModGhpcykpIHtcbiAgICAgICAgICAgIGxldCBpdGVtID0gdGhpc1trZXldO1xuICAgICAgICAgICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBJbmZlcmVuY2VTZXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaChpdGVtLmhhbmRsZXIuZGlzcG9zZSgpKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhd2FpdCBQcm9taXNlLmFsbChwcm9taXNlcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5zdGFudGlhdGUgb25lIG9mIHRoZSBtb2RlbCBjbGFzc2VzIG9mIHRoZSBsaWJyYXJ5IGZyb20gYSBwcmV0cmFpbmVkIG1vZGVsLlxuICAgICAqIFxuICAgICAqIFRoZSBtb2RlbCBjbGFzcyB0byBpbnN0YW50aWF0ZSBpcyBzZWxlY3RlZCBiYXNlZCBvbiB0aGUgYG1vZGVsX3R5cGVgIHByb3BlcnR5IG9mIHRoZSBjb25maWcgb2JqZWN0XG4gICAgICogKGVpdGhlciBwYXNzZWQgYXMgYW4gYXJndW1lbnQgb3IgbG9hZGVkIGZyb20gYHByZXRyYWluZWRfbW9kZWxfbmFtZV9vcl9wYXRoYCBpZiBwb3NzaWJsZSlcbiAgICAgKiBcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJldHJhaW5lZF9tb2RlbF9uYW1lX29yX3BhdGggVGhlIG5hbWUgb3IgcGF0aCBvZiB0aGUgcHJldHJhaW5lZCBtb2RlbC4gQ2FuIGJlIGVpdGhlcjpcbiAgICAgKiAtIEEgc3RyaW5nLCB0aGUgKm1vZGVsIGlkKiBvZiBhIHByZXRyYWluZWQgbW9kZWwgaG9zdGVkIGluc2lkZSBhIG1vZGVsIHJlcG8gb24gaHVnZ2luZ2ZhY2UuY28uXG4gICAgICogICBWYWxpZCBtb2RlbCBpZHMgY2FuIGJlIGxvY2F0ZWQgYXQgdGhlIHJvb3QtbGV2ZWwsIGxpa2UgYGJlcnQtYmFzZS11bmNhc2VkYCwgb3IgbmFtZXNwYWNlZCB1bmRlciBhXG4gICAgICogICB1c2VyIG9yIG9yZ2FuaXphdGlvbiBuYW1lLCBsaWtlIGBkYm1kei9iZXJ0LWJhc2UtZ2VybWFuLWNhc2VkYC5cbiAgICAgKiAtIEEgcGF0aCB0byBhICpkaXJlY3RvcnkqIGNvbnRhaW5pbmcgbW9kZWwgd2VpZ2h0cywgZS5nLiwgYC4vbXlfbW9kZWxfZGlyZWN0b3J5L2AuXG4gICAgICogQHBhcmFtIHtQcmV0cmFpbmVkT3B0aW9uc30gb3B0aW9ucyBBZGRpdGlvbmFsIG9wdGlvbnMgZm9yIGxvYWRpbmcgdGhlIG1vZGVsLlxuICAgICAqIFxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFByZVRyYWluZWRNb2RlbD59IEEgbmV3IGluc3RhbmNlIG9mIHRoZSBgUHJlVHJhaW5lZE1vZGVsYCBjbGFzcy5cbiAgICAgKi9cbiAgICBzdGF0aWMgYXN5bmMgZnJvbV9wcmV0cmFpbmVkKHByZXRyYWluZWRfbW9kZWxfbmFtZV9vcl9wYXRoLCB7XG4gICAgICAgIHF1YW50aXplZCA9IHRydWUsXG4gICAgICAgIHByb2dyZXNzX2NhbGxiYWNrID0gbnVsbCxcbiAgICAgICAgY29uZmlnID0gbnVsbCxcbiAgICAgICAgY2FjaGVfZGlyID0gbnVsbCxcbiAgICAgICAgbG9jYWxfZmlsZXNfb25seSA9IGZhbHNlLFxuICAgICAgICByZXZpc2lvbiA9ICdtYWluJyxcbiAgICB9ID0ge30pIHtcblxuICAgICAgICBsZXQgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIHF1YW50aXplZCxcbiAgICAgICAgICAgIHByb2dyZXNzX2NhbGxiYWNrLFxuICAgICAgICAgICAgY29uZmlnLFxuICAgICAgICAgICAgY2FjaGVfZGlyLFxuICAgICAgICAgICAgbG9jYWxfZmlsZXNfb25seSxcbiAgICAgICAgICAgIHJldmlzaW9uLFxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IG1vZGVsVHlwZSA9IE1PREVMX1RZUEVfTUFQUElORy5nZXQodGhpcy5uYW1lKTtcblxuICAgICAgICBsZXQgaW5mbztcbiAgICAgICAgaWYgKG1vZGVsVHlwZSA9PT0gRGVjb2Rlck9ubHlNb2RlbFR5cGUpIHtcbiAgICAgICAgICAgIGluZm8gPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICAgICAgQXV0b0NvbmZpZy5mcm9tX3ByZXRyYWluZWQocHJldHJhaW5lZF9tb2RlbF9uYW1lX29yX3BhdGgsIG9wdGlvbnMpLFxuICAgICAgICAgICAgICAgIGNvbnN0cnVjdFNlc3Npb24ocHJldHJhaW5lZF9tb2RlbF9uYW1lX29yX3BhdGgsICdkZWNvZGVyX21vZGVsX21lcmdlZCcsIG9wdGlvbnMpLFxuICAgICAgICAgICAgXSk7XG5cbiAgICAgICAgfSBlbHNlIGlmIChtb2RlbFR5cGUgPT09IFNlcTJTZXFNb2RlbFR5cGUpIHtcbiAgICAgICAgICAgIGluZm8gPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICAgICAgQXV0b0NvbmZpZy5mcm9tX3ByZXRyYWluZWQocHJldHJhaW5lZF9tb2RlbF9uYW1lX29yX3BhdGgsIG9wdGlvbnMpLFxuICAgICAgICAgICAgICAgIGNvbnN0cnVjdFNlc3Npb24ocHJldHJhaW5lZF9tb2RlbF9uYW1lX29yX3BhdGgsICdlbmNvZGVyX21vZGVsJywgb3B0aW9ucyksXG4gICAgICAgICAgICAgICAgY29uc3RydWN0U2Vzc2lvbihwcmV0cmFpbmVkX21vZGVsX25hbWVfb3JfcGF0aCwgJ2RlY29kZXJfbW9kZWxfbWVyZ2VkJywgb3B0aW9ucyksXG4gICAgICAgICAgICAgICAgZ2V0TW9kZWxKU09OKHByZXRyYWluZWRfbW9kZWxfbmFtZV9vcl9wYXRoLCAnZ2VuZXJhdGlvbl9jb25maWcuanNvbicsIGZhbHNlLCBvcHRpb25zKSxcbiAgICAgICAgICAgIF0pO1xuXG4gICAgICAgIH0gZWxzZSBpZiAobW9kZWxUeXBlID09PSBFbmNvZGVyRGVjb2Rlck1vZGVsVHlwZSkge1xuICAgICAgICAgICAgaW5mbyA9IGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgICAgICBBdXRvQ29uZmlnLmZyb21fcHJldHJhaW5lZChwcmV0cmFpbmVkX21vZGVsX25hbWVfb3JfcGF0aCwgb3B0aW9ucyksXG4gICAgICAgICAgICAgICAgY29uc3RydWN0U2Vzc2lvbihwcmV0cmFpbmVkX21vZGVsX25hbWVfb3JfcGF0aCwgJ2VuY29kZXJfbW9kZWwnLCBvcHRpb25zKSxcbiAgICAgICAgICAgICAgICBjb25zdHJ1Y3RTZXNzaW9uKHByZXRyYWluZWRfbW9kZWxfbmFtZV9vcl9wYXRoLCAnZGVjb2Rlcl9tb2RlbF9tZXJnZWQnLCBvcHRpb25zKSxcbiAgICAgICAgICAgIF0pO1xuXG4gICAgICAgIH0gZWxzZSBpZiAobW9kZWxUeXBlID09PSBFbmNvZGVyT25seU1vZGVsVHlwZSkge1xuICAgICAgICAgICAgaW5mbyA9IGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgICAgICBBdXRvQ29uZmlnLmZyb21fcHJldHJhaW5lZChwcmV0cmFpbmVkX21vZGVsX25hbWVfb3JfcGF0aCwgb3B0aW9ucyksXG4gICAgICAgICAgICAgICAgY29uc3RydWN0U2Vzc2lvbihwcmV0cmFpbmVkX21vZGVsX25hbWVfb3JfcGF0aCwgJ21vZGVsJywgb3B0aW9ucylcbiAgICAgICAgICAgIF0pO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ01hbGZvcm1lZCBjbGFzcyBkZWZpbml0aW9uLicsIHRoaXMpO1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoYFVuYWJsZSB0byBsb2FkIG1vZGVsOiAke3ByZXRyYWluZWRfbW9kZWxfbmFtZV9vcl9wYXRofS4gUGxlYXNlIHJlcG9ydCB0aGlzIGJ1ZyBhdCBodHRwczovL2dpdGh1Yi5jb20veGVub3ZhL3RyYW5zZm9ybWVycy5qcy9pc3N1ZXMvbmV3L2Nob29zZS5gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgcmV0dXJuIG5ldyB0aGlzKC4uLmluZm8pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJ1bnMgdGhlIG1vZGVsIHdpdGggdGhlIHByb3ZpZGVkIGlucHV0c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtb2RlbF9pbnB1dHMgT2JqZWN0IGNvbnRhaW5pbmcgaW5wdXQgdGVuc29yc1xuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD59IE9iamVjdCBjb250YWluaW5nIG91dHB1dCB0ZW5zb3JzXG4gICAgICovXG4gICAgYXN5bmMgX2NhbGwobW9kZWxfaW5wdXRzKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmZvcndhcmQobW9kZWxfaW5wdXRzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGb3J3YXJkIG1ldGhvZCBmb3IgYSBwcmV0cmFpbmVkIG1vZGVsLiBJZiBub3Qgb3ZlcnJpZGRlbiBieSBhIHN1YmNsYXNzLCB0aGUgY29ycmVjdCBmb3J3YXJkIG1ldGhvZFxuICAgICAqIHdpbGwgYmUgY2hvc2VuIGJhc2VkIG9uIHRoZSBtb2RlbCB0eXBlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtb2RlbF9pbnB1dHMgVGhlIGlucHV0IGRhdGEgdG8gdGhlIG1vZGVsIGluIHRoZSBmb3JtYXQgc3BlY2lmaWVkIGluIHRoZSBPTk5YIG1vZGVsLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD59IFRoZSBvdXRwdXQgZGF0YSBmcm9tIHRoZSBtb2RlbCBpbiB0aGUgZm9ybWF0IHNwZWNpZmllZCBpbiB0aGUgT05OWCBtb2RlbC5cbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gVGhpcyBtZXRob2QgbXVzdCBiZSBpbXBsZW1lbnRlZCBpbiBzdWJjbGFzc2VzLlxuICAgICAqL1xuICAgIGFzeW5jIGZvcndhcmQobW9kZWxfaW5wdXRzKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCBmb3J3YXJkKHRoaXMsIG1vZGVsX2lucHV0cyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtHZW5lcmF0aW9uQ29uZmlnfSBnZW5lcmF0aW9uX2NvbmZpZyBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5wdXRfaWRzX3NlcV9sZW5ndGggVGhlIHN0YXJ0aW5nIHNlcXVlbmNlIGxlbmd0aCBmb3IgdGhlIGlucHV0IGlkcy5cbiAgICAgKiBAcmV0dXJucyB7TG9naXRzUHJvY2Vzc29yTGlzdH1cbiAgICAgKi9cbiAgICBfZ2V0X2xvZ2l0c19wcm9jZXNzb3IoXG4gICAgICAgIGdlbmVyYXRpb25fY29uZmlnLFxuICAgICAgICBpbnB1dF9pZHNfc2VxX2xlbmd0aCxcbiAgICAgICAgLy8gZW5jb2Rlcl9pbnB1dF9pZHMsIFRPRE9cbiAgICAgICAgLy8gcHJlZml4X2FsbG93ZWRfdG9rZW5zX2ZuLCBUT0RPXG4gICAgICAgIGxvZ2l0c19wcm9jZXNzb3IgPSBudWxsXG4gICAgKSB7XG4gICAgICAgIGNvbnN0IHByb2Nlc3NvcnMgPSBuZXcgTG9naXRzUHJvY2Vzc29yTGlzdCgpO1xuXG4gICAgICAgIC8vIGlmIChnZW5lcmF0aW9uX2NvbmZpZy5kaXZlcnNpdHlfcGVuYWx0eSAhPT0gbnVsbCAmJiBnZW5lcmF0aW9uX2NvbmZpZy5kaXZlcnNpdHlfcGVuYWx0eSA+IDAuMCkge1xuICAgICAgICAvLyAgICAgcHJvY2Vzc29ycy5wdXNoKG5ldyBIYW1taW5nRGl2ZXJzaXR5TG9naXRzUHJvY2Vzc29yKFxuICAgICAgICAvLyAgICAgICAgIGdlbmVyYXRpb25fY29uZmlnLmRpdmVyc2l0eV9wZW5hbHR5LFxuICAgICAgICAvLyAgICAgICAgIGdlbmVyYXRpb25fY29uZmlnLm51bV9iZWFtcyxcbiAgICAgICAgLy8gICAgICAgICBnZW5lcmF0aW9uX2NvbmZpZy5udW1fYmVhbV9ncm91cHNcbiAgICAgICAgLy8gICAgICkpO1xuICAgICAgICAvLyB9XG5cbiAgICAgICAgLy8gaWYgKGdlbmVyYXRpb25fY29uZmlnLmVuY29kZXJfcmVwZXRpdGlvbl9wZW5hbHR5ICE9PSBudWxsICYmIGdlbmVyYXRpb25fY29uZmlnLmVuY29kZXJfcmVwZXRpdGlvbl9wZW5hbHR5ICE9PSAxLjApIHtcbiAgICAgICAgLy8gICAgIHByb2Nlc3NvcnMucHVzaChuZXcgRW5jb2RlclJlcGV0aXRpb25QZW5hbHR5TG9naXRzUHJvY2Vzc29yKFxuICAgICAgICAvLyAgICAgICAgIGdlbmVyYXRpb25fY29uZmlnLmVuY29kZXJfcmVwZXRpdGlvbl9wZW5hbHR5LFxuICAgICAgICAvLyAgICAgICAgIGVuY29kZXJfaW5wdXRfaWRzXG4gICAgICAgIC8vICAgICApKTtcbiAgICAgICAgLy8gfVxuXG4gICAgICAgIGlmIChnZW5lcmF0aW9uX2NvbmZpZy5yZXBldGl0aW9uX3BlbmFsdHkgIT09IG51bGwgJiYgZ2VuZXJhdGlvbl9jb25maWcucmVwZXRpdGlvbl9wZW5hbHR5ICE9PSAxLjApIHtcbiAgICAgICAgICAgIHByb2Nlc3NvcnMucHVzaChuZXcgUmVwZXRpdGlvblBlbmFsdHlMb2dpdHNQcm9jZXNzb3IoZ2VuZXJhdGlvbl9jb25maWcucmVwZXRpdGlvbl9wZW5hbHR5KSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZ2VuZXJhdGlvbl9jb25maWcubm9fcmVwZWF0X25ncmFtX3NpemUgIT09IG51bGwgJiYgZ2VuZXJhdGlvbl9jb25maWcubm9fcmVwZWF0X25ncmFtX3NpemUgPiAwKSB7XG4gICAgICAgICAgICBwcm9jZXNzb3JzLnB1c2gobmV3IE5vUmVwZWF0TkdyYW1Mb2dpdHNQcm9jZXNzb3IoZ2VuZXJhdGlvbl9jb25maWcubm9fcmVwZWF0X25ncmFtX3NpemUpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIChnZW5lcmF0aW9uX2NvbmZpZy5lbmNvZGVyX25vX3JlcGVhdF9uZ3JhbV9zaXplICE9PSBudWxsICYmIGdlbmVyYXRpb25fY29uZmlnLmVuY29kZXJfbm9fcmVwZWF0X25ncmFtX3NpemUgPiAwKSB7XG4gICAgICAgIC8vICAgICBpZiAodGhpcy5jb25maWcuaXNfZW5jb2Rlcl9kZWNvZGVyKSB7XG4gICAgICAgIC8vICAgICAgICAgcHJvY2Vzc29ycy5wdXNoKG5ldyBFbmNvZGVyTm9SZXBlYXROR3JhbUxvZ2l0c1Byb2Nlc3NvcihcbiAgICAgICAgLy8gICAgICAgICAgICAgZ2VuZXJhdGlvbl9jb25maWcuZW5jb2Rlcl9ub19yZXBlYXRfbmdyYW1fc2l6ZSxcbiAgICAgICAgLy8gICAgICAgICAgICAgZW5jb2Rlcl9pbnB1dF9pZHNcbiAgICAgICAgLy8gICAgICAgICApKTtcbiAgICAgICAgLy8gICAgIH0gZWxzZSB7XG4gICAgICAgIC8vICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSXQncyBpbXBvc3NpYmxlIHRvIHVzZSBgZW5jb2Rlcl9ub19yZXBlYXRfbmdyYW1fc2l6ZWAgd2l0aCBkZWNvZGVyLW9ubHkgYXJjaGl0ZWN0dXJlXCIpO1xuICAgICAgICAvLyAgICAgfVxuICAgICAgICAvLyB9XG5cbiAgICAgICAgLy8gaWYgKGdlbmVyYXRpb25fY29uZmlnLmJhZF93b3Jkc19pZHMgIT09IG51bGwpIHtcbiAgICAgICAgLy8gICAgIHByb2Nlc3NvcnMucHVzaChuZXcgTm9CYWRXb3Jkc0xvZ2l0c1Byb2Nlc3NvcihnZW5lcmF0aW9uX2NvbmZpZy5iYWRfd29yZHNfaWRzLCBnZW5lcmF0aW9uX2NvbmZpZy5lb3NfdG9rZW5faWQpKTtcbiAgICAgICAgLy8gfVxuXG4gICAgICAgIC8vIGlmIChnZW5lcmF0aW9uX2NvbmZpZy5taW5fbGVuZ3RoICE9PSBudWxsICYmIGdlbmVyYXRpb25fY29uZmlnLmVvc190b2tlbl9pZCAhPT0gbnVsbCAmJiBnZW5lcmF0aW9uX2NvbmZpZy5taW5fbGVuZ3RoID4gMCkge1xuICAgICAgICAvLyAgICAgcHJvY2Vzc29ycy5wdXNoKG5ldyBNaW5MZW5ndGhMb2dpdHNQcm9jZXNzb3IoZ2VuZXJhdGlvbl9jb25maWcubWluX2xlbmd0aCwgZ2VuZXJhdGlvbl9jb25maWcuZW9zX3Rva2VuX2lkKSk7XG4gICAgICAgIC8vIH1cblxuICAgICAgICAvLyBpZiAoZ2VuZXJhdGlvbl9jb25maWcubWluX25ld190b2tlbnMgIT09IG51bGwgJiYgZ2VuZXJhdGlvbl9jb25maWcuZW9zX3Rva2VuX2lkICE9PSBudWxsICYmIGdlbmVyYXRpb25fY29uZmlnLm1pbl9uZXdfdG9rZW5zID4gMCkge1xuICAgICAgICAvLyAgICAgcHJvY2Vzc29ycy5wdXNoKG5ldyBNaW5OZXdUb2tlbnNMZW5ndGhMb2dpdHNQcm9jZXNzb3IoXG4gICAgICAgIC8vICAgICAgICAgaW5wdXRfaWRzX3NlcV9sZW5ndGgsXG4gICAgICAgIC8vICAgICAgICAgZ2VuZXJhdGlvbl9jb25maWcubWluX25ld190b2tlbnMsXG4gICAgICAgIC8vICAgICAgICAgZ2VuZXJhdGlvbl9jb25maWcuZW9zX3Rva2VuX2lkXG4gICAgICAgIC8vICAgICApKTtcbiAgICAgICAgLy8gfVxuXG4gICAgICAgIC8vIGlmIChwcmVmaXhfYWxsb3dlZF90b2tlbnNfZm4gIT09IG51bGwpIHtcbiAgICAgICAgLy8gICAgIHByb2Nlc3NvcnMucHVzaChuZXcgUHJlZml4Q29uc3RyYWluZWRMb2dpdHNQcm9jZXNzb3IoXG4gICAgICAgIC8vICAgICAgICAgcHJlZml4X2FsbG93ZWRfdG9rZW5zX2ZuLFxuICAgICAgICAvLyAgICAgICAgIGdlbmVyYXRpb25fY29uZmlnLm51bV9iZWFtcyAvIGdlbmVyYXRpb25fY29uZmlnLm51bV9iZWFtX2dyb3Vwc1xuICAgICAgICAvLyAgICAgKSk7XG4gICAgICAgIC8vIH1cblxuXG4gICAgICAgIGlmIChnZW5lcmF0aW9uX2NvbmZpZy5mb3JjZWRfYm9zX3Rva2VuX2lkICE9PSBudWxsKSB7XG4gICAgICAgICAgICBwcm9jZXNzb3JzLnB1c2gobmV3IEZvcmNlZEJPU1Rva2VuTG9naXRzUHJvY2Vzc29yKGdlbmVyYXRpb25fY29uZmlnLmZvcmNlZF9ib3NfdG9rZW5faWQpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChnZW5lcmF0aW9uX2NvbmZpZy5mb3JjZWRfZW9zX3Rva2VuX2lkICE9PSBudWxsKSB7XG4gICAgICAgICAgICBwcm9jZXNzb3JzLnB1c2gobmV3IEZvcmNlZEVPU1Rva2VuTG9naXRzUHJvY2Vzc29yKFxuICAgICAgICAgICAgICAgIGdlbmVyYXRpb25fY29uZmlnLm1heF9sZW5ndGgsXG4gICAgICAgICAgICAgICAgZ2VuZXJhdGlvbl9jb25maWcuZm9yY2VkX2Vvc190b2tlbl9pZFxuICAgICAgICAgICAgKSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiAoZ2VuZXJhdGlvbl9jb25maWcucmVtb3ZlX2ludmFsaWRfdmFsdWVzID09PSB0cnVlKSB7XG4gICAgICAgIC8vICAgICBwcm9jZXNzb3JzLnB1c2gobmV3IEluZk5hblJlbW92ZUxvZ2l0c1Byb2Nlc3NvcigpKTtcbiAgICAgICAgLy8gfVxuXG4gICAgICAgIC8vIGlmIChnZW5lcmF0aW9uX2NvbmZpZy5leHBvbmVudGlhbF9kZWNheV9sZW5ndGhfcGVuYWx0eSAhPT0gbnVsbCkge1xuICAgICAgICAvLyAgICAgcHJvY2Vzc29ycy5wdXNoKG5ldyBFeHBvbmVudGlhbERlY2F5TGVuZ3RoUGVuYWx0eShcbiAgICAgICAgLy8gICAgICAgICBnZW5lcmF0aW9uX2NvbmZpZy5leHBvbmVudGlhbF9kZWNheV9sZW5ndGhfcGVuYWx0eSxcbiAgICAgICAgLy8gICAgICAgICBnZW5lcmF0aW9uX2NvbmZpZy5lb3NfdG9rZW5faWQsXG4gICAgICAgIC8vICAgICAgICAgaW5wdXRfaWRzX3NlcV9sZW5ndGhcbiAgICAgICAgLy8gICAgICkpO1xuICAgICAgICAvLyB9XG5cbiAgICAgICAgLy8gaWYgKGdlbmVyYXRpb25fY29uZmlnLnN1cHByZXNzX3Rva2VucyAhPT0gbnVsbCkge1xuICAgICAgICAvLyAgICAgcHJvY2Vzc29ycy5wdXNoKG5ldyBTdXBwcmVzc1Rva2Vuc0xvZ2l0c1Byb2Nlc3NvcihnZW5lcmF0aW9uX2NvbmZpZy5zdXBwcmVzc190b2tlbnMpKTtcbiAgICAgICAgLy8gfVxuXG4gICAgICAgIGlmIChnZW5lcmF0aW9uX2NvbmZpZy5iZWdpbl9zdXBwcmVzc190b2tlbnMgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGxldCBiZWdpbl9pbmRleCA9IChpbnB1dF9pZHNfc2VxX2xlbmd0aCA+IDEgfHwgZ2VuZXJhdGlvbl9jb25maWcuZm9yY2VkX2Jvc190b2tlbl9pZCA9PT0gbnVsbClcbiAgICAgICAgICAgICAgICA/IGlucHV0X2lkc19zZXFfbGVuZ3RoXG4gICAgICAgICAgICAgICAgOiBpbnB1dF9pZHNfc2VxX2xlbmd0aCArIDE7XG5cbiAgICAgICAgICAgIGlmIChnZW5lcmF0aW9uX2NvbmZpZy5mb3JjZWRfZGVjb2Rlcl9pZHMgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyBnZW5lcmF0aW9uIHN0YXJ0cyBhZnRlciB0aGUgbGFzdCB0b2tlbiB0aGF0IGlzIGZvcmNlZFxuICAgICAgICAgICAgICAgIGJlZ2luX2luZGV4ICs9IGdlbmVyYXRpb25fY29uZmlnLmZvcmNlZF9kZWNvZGVyX2lkc1tnZW5lcmF0aW9uX2NvbmZpZy5mb3JjZWRfZGVjb2Rlcl9pZHMubGVuZ3RoIC0gMV1bMF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcm9jZXNzb3JzLnB1c2gobmV3IFN1cHByZXNzVG9rZW5zQXRCZWdpbkxvZ2l0c1Byb2Nlc3NvcihnZW5lcmF0aW9uX2NvbmZpZy5iZWdpbl9zdXBwcmVzc190b2tlbnMsIGJlZ2luX2luZGV4KSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZ2VuZXJhdGlvbl9jb25maWcuZm9yY2VkX2RlY29kZXJfaWRzICE9PSBudWxsKSB7XG4gICAgICAgICAgICBwcm9jZXNzb3JzLnB1c2gobmV3IEZvcmNlVG9rZW5zTG9naXRzUHJvY2Vzc29yKGdlbmVyYXRpb25fY29uZmlnLmZvcmNlZF9kZWNvZGVyX2lkcykpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxvZ2l0c19wcm9jZXNzb3IgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHByb2Nlc3NvcnMuZXh0ZW5kKGxvZ2l0c19wcm9jZXNzb3IpXG4gICAgICAgIH1cblxuICAgICAgICAvLyBgTG9naXROb3JtYWxpemF0aW9uYCBzaG91bGQgYWx3YXlzIGJlIHRoZSBsYXN0IGxvZ2l0IHByb2Nlc3Nvciwgd2hlbiBwcmVzZW50XG4gICAgICAgIC8vIGlmIChnZW5lcmF0aW9uX2NvbmZpZy5yZW5vcm1hbGl6ZV9sb2dpdHMgPT09IHRydWUpIHtcbiAgICAgICAgLy8gICAgIHByb2Nlc3NvcnMucHVzaChuZXcgTG9naXROb3JtYWxpemF0aW9uKCkpO1xuICAgICAgICAvLyB9XG5cbiAgICAgICAgcmV0dXJuIHByb2Nlc3NvcnM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAqIFRoaXMgZnVuY3Rpb24gbWVyZ2VzIG11bHRpcGxlIGdlbmVyYXRpb24gY29uZmlncyB0b2dldGhlciB0byBmb3JtIGEgZmluYWwgZ2VuZXJhdGlvbiBjb25maWcgdG8gYmUgdXNlZCBieSB0aGUgbW9kZWwgZm9yIHRleHQgZ2VuZXJhdGlvbi5cbiAgICogSXQgZmlyc3QgY3JlYXRlcyBhbiBlbXB0eSBgR2VuZXJhdGlvbkNvbmZpZ2Agb2JqZWN0LCB0aGVuIGl0IGFwcGxpZXMgdGhlIG1vZGVsJ3Mgb3duIGBnZW5lcmF0aW9uX2NvbmZpZ2AgcHJvcGVydHkgdG8gaXQuIEZpbmFsbHksIGlmIGEgYGdlbmVyYXRpb25fY29uZmlnYCBvYmplY3Qgd2FzIHBhc3NlZCBpbiB0aGUgYXJndW1lbnRzLCBpdCBvdmVyd3JpdGVzIHRoZSBjb3JyZXNwb25kaW5nIHByb3BlcnRpZXMgaW4gdGhlIGZpbmFsIGNvbmZpZyB3aXRoIHRob3NlIG9mIHRoZSBwYXNzZWQgY29uZmlnIG9iamVjdC5cbiAgICpcbiAgICogQHBhcmFtIHtHZW5lcmF0aW9uQ29uZmlnfSBnZW5lcmF0aW9uX2NvbmZpZyBBIGBHZW5lcmF0aW9uQ29uZmlnYCBvYmplY3QgY29udGFpbmluZyBnZW5lcmF0aW9uIHBhcmFtZXRlcnMuXG4gICAqIEByZXR1cm5zIHtHZW5lcmF0aW9uQ29uZmlnfSBUaGUgZmluYWwgZ2VuZXJhdGlvbiBjb25maWcgb2JqZWN0IHRvIGJlIHVzZWQgYnkgdGhlIG1vZGVsIGZvciB0ZXh0IGdlbmVyYXRpb24uXG4gICAqL1xuICAgIF9nZXRfZ2VuZXJhdGlvbl9jb25maWcoZ2VuZXJhdGlvbl9jb25maWcpIHtcbiAgICAgICAgLy8gQ3JlYXRlIGVtcHR5IGdlbmVyYXRpb24gY29uZmlnIChjb250YWlucyBkZWZhdWx0cylcbiAgICAgICAgbGV0IGdlbl9jb25maWcgPSBuZXcgR2VuZXJhdGlvbkNvbmZpZygpO1xuXG4gICAgICAgIC8vIEFwcGx5IG1vZGVsJ3MgZ2VuZXJhdGlvbiBjb25maWcsIGlmIGl0IGV4aXN0c1xuICAgICAgICBpZiAoJ2dlbmVyYXRpb25fY29uZmlnJyBpbiB0aGlzKSB7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKGdlbl9jb25maWcsIHRoaXMuZ2VuZXJhdGlvbl9jb25maWcpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRmluYWxseSwgdXNlIGFueSBnZW5lcmF0aW9uIGNvbmZpZyBzcGVjaWZpZWQgYnkgdGhlIHVzZXJcbiAgICAgICAgLy8gd2hlbiBjYWxsaW5nIGBnZW5lcmF0ZWBcbiAgICAgICAgaWYgKGdlbmVyYXRpb25fY29uZmlnICE9PSBudWxsKSB7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKGdlbl9jb25maWcsIGdlbmVyYXRpb25fY29uZmlnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZ2VuX2NvbmZpZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZWRlZiB7aW1wb3J0KCcuL3V0aWxzL21hdGhzLmpzJykuVHlwZWRBcnJheX0gVHlwZWRBcnJheVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQHR5cGVkZWYge3sgc2VxdWVuY2VzOiBUZW5zb3IsIGRlY29kZXJfYXR0ZW50aW9uczogVGVuc29yLCBjcm9zc19hdHRlbnRpb25zOiBUZW5zb3IgfX0gRW5jb2RlckRlY29kZXJPdXRwdXRcbiAgICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBEZWNvZGVyT3V0cHV0XG4gICAgICogXG4gICAgICogR2VuZXJhdGVzIHRleHQgYmFzZWQgb24gdGhlIGdpdmVuIGlucHV0cyBhbmQgZ2VuZXJhdGlvbiBjb25maWd1cmF0aW9uIHVzaW5nIHRoZSBtb2RlbC5cbiAgICAgKiBAcGFyYW0ge1RlbnNvcnxBcnJheXxUeXBlZEFycmF5fSBpbnB1dHMgQW4gYXJyYXkgb2YgaW5wdXQgdG9rZW4gSURzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fEdlbmVyYXRpb25Db25maWd8bnVsbH0gZ2VuZXJhdGlvbl9jb25maWcgVGhlIGdlbmVyYXRpb24gY29uZmlndXJhdGlvbiB0byB1c2UuIElmIG51bGwsIGRlZmF1bHQgY29uZmlndXJhdGlvbiB3aWxsIGJlIHVzZWQuXG4gICAgICogQHBhcmFtIHtPYmplY3R8bnVsbH0gbG9naXRzX3Byb2Nlc3NvciBBbiBvcHRpb25hbCBsb2dpdHMgcHJvY2Vzc29yIHRvIHVzZS4gSWYgbnVsbCwgYSBuZXcgTG9naXRzUHJvY2Vzc29yTGlzdCBpbnN0YW5jZSB3aWxsIGJlIGNyZWF0ZWQuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5pbnB1dHNfYXR0ZW50aW9uX21hc2s9bnVsbF0gQW4gb3B0aW9uYWwgYXR0ZW50aW9uIG1hc2sgZm9yIHRoZSBpbnB1dHMuXG4gICAgICogQHJldHVybnMge1Byb21pc2U8bnVtYmVyW11bXXxFbmNvZGVyRGVjb2Rlck91dHB1dHxEZWNvZGVyT3V0cHV0Pn0gQW4gYXJyYXkgb2YgZ2VuZXJhdGVkIG91dHB1dCBzZXF1ZW5jZXMsIHdoZXJlIGVhY2ggc2VxdWVuY2UgaXMgYW4gYXJyYXkgb2YgdG9rZW4gSURzLlxuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBUaHJvd3MgYW4gZXJyb3IgaWYgdGhlIGlucHV0cyBhcnJheSBpcyBlbXB0eS5cbiAgICAgKi9cbiAgICBhc3luYyBnZW5lcmF0ZShcbiAgICAgICAgaW5wdXRzLFxuICAgICAgICBnZW5lcmF0aW9uX2NvbmZpZyA9IG51bGwsXG4gICAgICAgIGxvZ2l0c19wcm9jZXNzb3IgPSBudWxsLFxuICAgICAgICB7XG4gICAgICAgICAgICBpbnB1dHNfYXR0ZW50aW9uX21hc2sgPSBudWxsXG4gICAgICAgIH0gPSB7fSxcbiAgICApIHtcblxuICAgICAgICBpZiAoIShpbnB1dHMgaW5zdGFuY2VvZiBUZW5zb3IpICYmICFpc1R5cGVkQXJyYXkoaW5wdXRzKSAmJiAhQXJyYXkuaXNBcnJheShpbnB1dHMpKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihgXFxgaW5wdXRzXFxgIG11c3QgYmUgYSBUZW5zb3IsIFR5cGVkQXJyYXksIG9yIEFycmF5LCBidXQgaXMgXCIke2lucHV0cy5jb25zdHJ1Y3Rvci5uYW1lfVwiLmApO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGlucHV0X2lkc19zZXFfbGVuZ3RoO1xuXG4gICAgICAgIC8vIFByZXBhcmUgYGlucHV0X2lkc2Agd2hpY2ggd2lsbCBiZSB1c2VkIGZvciBhdXRvLXJlZ3Jlc3NpdmUgZ2VuZXJhdGlvblxuICAgICAgICAvLyBUT0RPOiBVcGRhdGUgdG8gYWxpZ24gd2l0aCBIRiB0cmFuc2Zvcm1lcnMnIGltcGxlbWVudGF0aW9uXG4gICAgICAgIGlmICh0aGlzLmNvbmZpZy5pc19lbmNvZGVyX2RlY29kZXIpIHtcbiAgICAgICAgICAgIC8vIEdlbmVyYXRpbmcgZnJvbSB0aGUgZW5jb2RlciBvdXRwdXRzXG4gICAgICAgICAgICBpbnB1dF9pZHNfc2VxX2xlbmd0aCA9IDA7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlucHV0X2lkc19zZXFfbGVuZ3RoID0gaW5wdXRzIGluc3RhbmNlb2YgVGVuc29yID8gaW5wdXRzLmRpbXNbMF0gOiBpbnB1dHMubGVuZ3RoO1xuXG4gICAgICAgICAgICAvLyBkZWNvZGVyLW9ubHlcbiAgICAgICAgICAgIGlmIChpbnB1dF9pZHNfc2VxX2xlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiTXVzdCBzdXBwbHkgYSBub24tZW1wdHkgYXJyYXkgb2YgaW5wdXQgdG9rZW4gaWRzLlwiKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gVXBkYXRlIGdlbmVyYXRpb24gY29uZmlnIHdpdGggZGVmYXVsdHNcbiAgICAgICAgZ2VuZXJhdGlvbl9jb25maWcgPSB0aGlzLl9nZXRfZ2VuZXJhdGlvbl9jb25maWcoZ2VuZXJhdGlvbl9jb25maWcpO1xuXG4gICAgICAgIGxvZ2l0c19wcm9jZXNzb3IgPSBsb2dpdHNfcHJvY2Vzc29yID8/IG5ldyBMb2dpdHNQcm9jZXNzb3JMaXN0KClcblxuICAgICAgICAvLyBVcGRhdGUgbG9naXRzIHByb2Nlc3NvclxuICAgICAgICBsb2dpdHNfcHJvY2Vzc29yID0gdGhpcy5fZ2V0X2xvZ2l0c19wcm9jZXNzb3IoXG4gICAgICAgICAgICBnZW5lcmF0aW9uX2NvbmZpZyxcbiAgICAgICAgICAgIGlucHV0X2lkc19zZXFfbGVuZ3RoLFxuICAgICAgICAgICAgbG9naXRzX3Byb2Nlc3NvclxuICAgICAgICApXG5cbiAgICAgICAgLy8gVE9ETyBpbXBsZW1lbnQgZWFybHlfc3RvcHBpbmdcbiAgICAgICAgLy8gaHR0cHM6Ly9odWdnaW5nZmFjZS5jby9ibG9nL2hvdy10by1nZW5lcmF0ZVxuXG4gICAgICAgIGxldCBudW1PdXRwdXRUb2tlbnMgPSAxO1xuICAgICAgICBjb25zdCBtYXhPdXRwdXRUb2tlbnMgPSBudW1PdXRwdXRUb2tlbnMgKyAoZ2VuZXJhdGlvbl9jb25maWcubWF4X25ld190b2tlbnMgPz8gSW5maW5pdHkpO1xuXG4gICAgICAgIC8vIE9ubHkgdXNlIG1heCBsZW5ndGggaWYgbWF4X25ld190b2tlbnMgaXMgbm90IHByb3ZpZGVkXG4gICAgICAgIGNvbnN0IHVzZU1heExlbmd0aCA9IE51bWJlci5pc0ludGVnZXIoZ2VuZXJhdGlvbl9jb25maWcubWF4X2xlbmd0aCkgJiYgKGdlbmVyYXRpb25fY29uZmlnLm1heF9uZXdfdG9rZW5zID8/IG51bGwpID09PSBudWxsO1xuICAgICAgICBsZXQgc2FtcGxlciA9IFNhbXBsZXIuZ2V0U2FtcGxlcihnZW5lcmF0aW9uX2NvbmZpZyk7XG5cbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBsZXQgYmVhbXMgPSB0aGlzLmdldFN0YXJ0QmVhbXMoaW5wdXRzLCBudW1PdXRwdXRUb2tlbnMsIGlucHV0c19hdHRlbnRpb25fbWFzayk7XG5cbiAgICAgICAgd2hpbGUgKGJlYW1zLnNvbWUoeCA9PiAheC5kb25lKSAmJiBudW1PdXRwdXRUb2tlbnMgPCBtYXhPdXRwdXRUb2tlbnMpIHtcbiAgICAgICAgICAgIGxldCBuZXdlc3RfYmVhbXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAobGV0IGJlYW0gb2YgYmVhbXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoYmVhbS5kb25lKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEFkZCB0aGlzIGJlYW0gYmFjayBpbnRvIHRoZSBwb29sXG4gICAgICAgICAgICAgICAgICAgIG5ld2VzdF9iZWFtcy5wdXNoKGJlYW0pO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodXNlTWF4TGVuZ3RoICYmIGJlYW0ub3V0cHV0X3Rva2VuX2lkcy5sZW5ndGggPj0gZ2VuZXJhdGlvbl9jb25maWcubWF4X2xlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBTZXQgdGhpcyBiZWFtIHRvIGRvbmUgYW5kIGFkZCBpdCBiYWNrIGludG8gdGhlIHBvb2xcbiAgICAgICAgICAgICAgICAgICAgYmVhbS5kb25lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgbmV3ZXN0X2JlYW1zLnB1c2goYmVhbSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgIGxldCBvdXRwdXQgPSBhd2FpdCB0aGlzLnJ1bkJlYW0oYmVhbSk7XG5cbiAgICAgICAgICAgICAgICAvLyBhZGQgYXR0ZW50aW9ucy9zY29yZXMgdG8gYmVhbSBvbmx5IGlmIHVzZXIgcmVxdWVzdGVkXG4gICAgICAgICAgICAgICAgaWYgKGdlbmVyYXRpb25fY29uZmlnLm91dHB1dF9hdHRlbnRpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkQXR0ZW50aW9uc1RvQmVhbShiZWFtLCBvdXRwdXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZ2VuZXJhdGlvbl9jb25maWcub3V0cHV0X3Njb3Jlcykge1xuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPIGFkZFxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIExvZ2l0cyBhcmUgb2YgdGhlIGZvcm0gW2JhdGNoX3NpemUsIG91dF9zZXFfbGVuZ3RoLCB2b2NhYl9zaXplXVxuICAgICAgICAgICAgICAgIC8vIEluIG1vc3QgY2FzZXMsIHRoaXMgd2lsbCBiZSBbYmF0Y2hfc2l6ZSwgMSwgdm9jYWJfc2l6ZV1cbiAgICAgICAgICAgICAgICAvLyBTbywgd2Ugc2VsZWN0IHRoZSBsYXN0IHRva2VuJ3MgbG9naXRzOlxuICAgICAgICAgICAgICAgIC8vIChlcXVpdmFsZW50IHRvIGBsb2dpdHMgPSBvdXRwdXRzLmxvZ2l0c1s6LCAtMSwgOl1gKVxuICAgICAgICAgICAgICAgIGxldCBsb2dpdHMgPSBvdXRwdXQubG9naXRzLnNsaWNlKG51bGwsIC0xLCBudWxsKTtcblxuICAgICAgICAgICAgICAgIC8vIEFwcGx5IGxvZ2l0cyBwcm9jZXNzb3JcbiAgICAgICAgICAgICAgICBsb2dpdHNfcHJvY2Vzc29yKGJlYW0ub3V0cHV0X3Rva2VuX2lkcywgbG9naXRzKTtcblxuICAgICAgICAgICAgICAgIGxldCBzYW1wbGVkVG9rZW5zID0gc2FtcGxlcihsb2dpdHMpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IFtuZXdUb2tlbklkLCBsb2dQcm9iXSBvZiBzYW1wbGVkVG9rZW5zKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHVzZSBwcmV2aW91cyBiZWFtIGFzIGEgc3RhcnRpbmcgcG9pbnRcbiAgICAgICAgICAgICAgICAgICAgbGV0IG5ld0JlYW0gPSB7IC4uLmJlYW0gfTtcblxuICAgICAgICAgICAgICAgICAgICAvLyB1cGRhdGUgbmV3IGJlYW1cbiAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUJlYW0obmV3QmVhbSwgbmV3VG9rZW5JZCk7XG5cbiAgICAgICAgICAgICAgICAgICAgbmV3QmVhbS5zY29yZSArPSBsb2dQcm9iO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXdUb2tlbklkID09PSB0aGlzLmNvbmZpZy5lb3NfdG9rZW5faWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0JlYW0uZG9uZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBuZXdlc3RfYmVhbXMucHVzaChuZXdCZWFtKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICArK251bU91dHB1dFRva2VucztcblxuICAgICAgICAgICAgLy8gTmV4dCwgd2UgZ2V0IHRoZSBiZXN0IGJlYW1zLCBwZXIgSURcbiAgICAgICAgICAgIG5ld2VzdF9iZWFtcyA9IHRoaXMuZ3JvdXBCZWFtcyhuZXdlc3RfYmVhbXMpLm1hcChcbiAgICAgICAgICAgICAgICBncm91cCA9PiBncm91cFxuICAgICAgICAgICAgICAgICAgICAuc29ydCgoYSwgYikgPT4gYi5zY29yZSAtIGEuc2NvcmUpICAgICAgLy8gc29ydCBieSBzY29yZVxuICAgICAgICAgICAgICAgICAgICAuc2xpY2UoMCwgZ2VuZXJhdGlvbl9jb25maWcubnVtX2JlYW1zKSAgLy8gcmVtb3ZlIG91dHNpZGUgYmVhbSB3aWR0aFxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgLy8gRmxhdHRlbiBiZWFtc1xuICAgICAgICAgICAgYmVhbXMgPSBuZXdlc3RfYmVhbXMuZmxhdCgpO1xuXG4gICAgICAgICAgICAvLyBSdW4gY2FsbGJhY2tcbiAgICAgICAgICAgIGlmIChnZW5lcmF0aW9uX2NvbmZpZy5jYWxsYmFja19mdW5jdGlvbikge1xuICAgICAgICAgICAgICAgIGdlbmVyYXRpb25fY29uZmlnLmNhbGxiYWNrX2Z1bmN0aW9uKGJlYW1zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRPRE86IEVuc3VyZSB0aGF0IHdlIGNhbiByZXR1cm4gbm9uLWJhdGNoZWQgb3V0cHV0c1xuXG4gICAgICAgIGNvbnN0IGdyb3VwZWRCZWFtcyA9IHRoaXMuZ3JvdXBCZWFtcyhiZWFtcyk7XG5cbiAgICAgICAgY29uc3QgZ2V0RmxhdHRlbmVkID0gKGtleSkgPT4gZ3JvdXBlZEJlYW1zLm1hcChcbiAgICAgICAgICAgIGJhdGNoID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZ2VuZXJhdGlvbl9jb25maWcubnVtX3JldHVybl9zZXF1ZW5jZXMgPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBiYXRjaC5zbGljZSgwLCBnZW5lcmF0aW9uX2NvbmZpZy5udW1fcmV0dXJuX3NlcXVlbmNlcykubWFwKHggPT4geFtrZXldKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW2JhdGNoWzBdW2tleV1dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgKS5mbGF0KCk7IC8vIEZsYXR0ZW4gYWNyb3NzIGJhdGNoZXMgKGRlcHRoPTEpXG5cbiAgICAgICAgY29uc3Qgc2VxdWVuY2VzID0gZ2V0RmxhdHRlbmVkKCdvdXRwdXRfdG9rZW5faWRzJyk7IC8vIFsxLCBzZXFMZW5ndGhdXG5cbiAgICAgICAgaWYgKGdlbmVyYXRpb25fY29uZmlnLnJldHVybl9kaWN0X2luX2dlbmVyYXRlKSB7XG4gICAgICAgICAgICAvLyBOT1RFOiBgZGVjb2Rlcl9hdHRlbnRpb25zYCBhbmQgYGNyb3NzX2F0dGVudGlvbnNgIHNob3VsZCBiZTpcbiAgICAgICAgICAgIC8vICAgIGxpc3QgKG9uZSBlbGVtZW50IGZvciBlYWNoIGdlbmVyYXRlZCB0b2tlbilcbiAgICAgICAgICAgIC8vICAgIG9mIGxpc3QgKG9uZSBlbGVtZW50IGZvciBlYWNoIGxheWVyIG9mIHRoZSBkZWNvZGVyKVxuICAgICAgICAgICAgLy8gICAgb2YgdG9yY2guRmxvYXRUZW5zb3Igb2Ygc2hhcGUgKGJhdGNoX3NpemUsIG51bV9oZWFkcywgZ2VuZXJhdGVkX2xlbmd0aCwgc2VxdWVuY2VfbGVuZ3RoKVxuICAgICAgICAgICAgLy8gSG93ZXZlciwgc2luY2Ugd2UgYXJlIG9ubHkgZ2VuZXJhdGluZyBvbmUgYmF0Y2ggYXQgYSB0aW1lLCB0aGV5IGFyZSBvZiB0aGUgZm9ybTpcbiAgICAgICAgICAgIC8vICAgbGlzdCAoYmF0Y2hlcylcbiAgICAgICAgICAgIC8vICAgb2YgbGlzdCAob25lIGVsZW1lbnQgZm9yIGVhY2ggZ2VuZXJhdGVkIHRva2VuKVxuICAgICAgICAgICAgLy8gICBvZiBsaXN0IChvbmUgZWxlbWVudCBmb3IgZWFjaCBsYXllciBvZiB0aGUgZGVjb2RlcilcbiAgICAgICAgICAgIC8vICAgb2YgdG9yY2guRmxvYXRUZW5zb3Igb2Ygc2hhcGUgKDEsIG51bV9oZWFkcywgZ2VuZXJhdGVkX2xlbmd0aCwgc2VxdWVuY2VfbGVuZ3RoKVxuICAgICAgICAgICAgLy8gXG4gICAgICAgICAgICAvLyBUT0RPOiBJbiBmdXR1cmUgKHdoZW4gdHJ1ZSBwYXJhbGxlbGlzbSwgd2Ugc2hvdWxkIGJlIGFibGUgdG8gcmV0dXJuIHRoZSBjb3JyZWN0IHNoYXBlKVxuXG4gICAgICAgICAgICBjb25zdCBkZWNvZGVyX2F0dGVudGlvbnMgPSBnZXRGbGF0dGVuZWQoJ2RlY29kZXJfYXR0ZW50aW9ucycpO1xuICAgICAgICAgICAgY29uc3QgY3Jvc3NfYXR0ZW50aW9ucyA9IGdldEZsYXR0ZW5lZCgnY3Jvc3NfYXR0ZW50aW9ucycpO1xuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHNlcXVlbmNlcyxcblxuICAgICAgICAgICAgICAgIGRlY29kZXJfYXR0ZW50aW9ucyxcbiAgICAgICAgICAgICAgICBjcm9zc19hdHRlbnRpb25zLFxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHNlcXVlbmNlcztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhlbHBlciBmdW5jdGlvbiB0byBhZGQgYXR0ZW50aW9ucyB0byBiZWFtXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGJlYW0gXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG91dHB1dFxuICAgICAqIEBwcml2YXRlIFxuICAgICAqL1xuICAgIGFkZEF0dGVudGlvbnNUb0JlYW0oYmVhbSwgb3V0cHV0KSB7XG4gICAgICAgIGlmICh0aGlzLmNvbmZpZy5pc19lbmNvZGVyX2RlY29kZXIpIHtcbiAgICAgICAgICAgIGlmICghb3V0cHV0LmNyb3NzX2F0dGVudGlvbnMgfHwgb3V0cHV0LmNyb3NzX2F0dGVudGlvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgIFwiYG91dHB1dF9hdHRlbnRpb25zYCBpcyB0cnVlLCBidXQgdGhlIG1vZGVsIGRpZCBub3QgcHJvZHVjZSBjcm9zcy1hdHRlbnRpb25zLiBcIiArXG4gICAgICAgICAgICAgICAgICAgIFwiVGhpcyBpcyBtb3N0IGxpa2VseSBiZWNhdXNlIHRoZSBtb2RlbCB3YXMgbm90IGV4cG9ydGVkIHdpdGggYG91dHB1dF9hdHRlbnRpb25zPVRydWVgLlwiXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFiZWFtLmNyb3NzX2F0dGVudGlvbnMpIHtcbiAgICAgICAgICAgICAgICBiZWFtLmNyb3NzX2F0dGVudGlvbnMgPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJlYW0uY3Jvc3NfYXR0ZW50aW9ucy5wdXNoKG91dHB1dC5jcm9zc19hdHRlbnRpb25zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghb3V0cHV0LmRlY29kZXJfYXR0ZW50aW9ucyB8fCBvdXRwdXQuZGVjb2Rlcl9hdHRlbnRpb25zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgICAgXCJgb3V0cHV0X2F0dGVudGlvbnNgIGlzIHRydWUsIGJ1dCB0aGUgbW9kZWwgZGlkIG5vdCBwcm9kdWNlIGRlY29kZXItYXR0ZW50aW9ucy4gXCIgK1xuICAgICAgICAgICAgICAgIFwiVGhpcyBpcyBtb3N0IGxpa2VseSBiZWNhdXNlIHRoZSBtb2RlbCB3YXMgbm90IGV4cG9ydGVkIHdpdGggYG91dHB1dF9hdHRlbnRpb25zPVRydWVgLlwiXG4gICAgICAgICAgICApXG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFiZWFtLmRlY29kZXJfYXR0ZW50aW9ucykge1xuICAgICAgICAgICAgYmVhbS5kZWNvZGVyX2F0dGVudGlvbnMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBiZWFtLmRlY29kZXJfYXR0ZW50aW9ucy5wdXNoKG91dHB1dC5kZWNvZGVyX2F0dGVudGlvbnMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdyb3VwcyBhbiBhcnJheSBvZiBiZWFtIG9iamVjdHMgYnkgdGhlaXIgaWRzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheX0gYmVhbXMgVGhlIGFycmF5IG9mIGJlYW0gb2JqZWN0cyB0byBncm91cC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IEFuIGFycmF5IG9mIGFycmF5cywgd2hlcmUgZWFjaCBpbm5lciBhcnJheSBjb250YWlucyBiZWFtIG9iamVjdHMgd2l0aCB0aGUgc2FtZSBpZC5cbiAgICAgKi9cbiAgICBncm91cEJlYW1zKGJlYW1zKSB7XG4gICAgICAgIC8vIEdyb3VwIGJlYW1zIGJ5IHRoZWlyIGlkc1xuICAgICAgICBjb25zdCBncm91cHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICBmb3IgKGNvbnN0IG9iaiBvZiBiZWFtcykge1xuICAgICAgICAgICAgaWYgKGdyb3Vwc1tvYmouaWRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBncm91cHNbb2JqLmlkXSA9IFtvYmpdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBncm91cHNbb2JqLmlkXS5wdXNoKG9iaik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gT2JqZWN0LnZhbHVlcyhncm91cHMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gb2JqZWN0IGNvbnRhaW5pbmcgcGFzdCBrZXkgdmFsdWVzIGZyb20gdGhlIGdpdmVuIGRlY29kZXIgcmVzdWx0cyBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGVjb2RlclJlc3VsdHMgVGhlIGRlY29kZXIgcmVzdWx0cyBvYmplY3QuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBhc3RLZXlWYWx1ZXMgVGhlIHByZXZpb3VzIHBhc3Qga2V5IHZhbHVlcy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBBbiBvYmplY3QgY29udGFpbmluZyBwYXN0IGtleSB2YWx1ZXMuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBnZXRQYXN0S2V5VmFsdWVzKGRlY29kZXJSZXN1bHRzLCBwYXN0S2V5VmFsdWVzKSB7XG5cbiAgICAgICAgY29uc3QgcGt2cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgICAgICAgZm9yIChjb25zdCBuYW1lIGluIGRlY29kZXJSZXN1bHRzKSB7XG4gICAgICAgICAgICBpZiAobmFtZS5zdGFydHNXaXRoKCdwcmVzZW50JykpIHtcbiAgICAgICAgICAgICAgICBsZXQgbmV3TmFtZSA9IG5hbWUucmVwbGFjZSgncHJlc2VudCcsICdwYXN0X2tleV92YWx1ZXMnKTtcblxuICAgICAgICAgICAgICAgIGlmIChwYXN0S2V5VmFsdWVzICYmIG5hbWUuaW5jbHVkZXMoJ2VuY29kZXInKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBPcHRpbWl6YXRpb24gaW50cm9kdWNlZCBieSBvcHRpbXVtIHRvIHJldXNlIHBhc3Qga2V5IHZhbHVlcy4gU28sIHdlIGp1c3QgcmVwbGFjZSB0aGUgY29uc3RhbnRcbiAgICAgICAgICAgICAgICAgICAgLy8gb3V0cHV0cyB3aXRoIHRoZSBwcmV2aW91cyBwYXN0IGtleSB2YWx1ZXMuXG4gICAgICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9odWdnaW5nZmFjZS9vcHRpbXVtL2Jsb2IvMGJmMmMwNWZiN2UxMTgyYjUyZDIxYjcwM2NmYzk1ZmQ5ZTRlYTNkYy9vcHRpbXVtL29ubnhydW50aW1lL2Jhc2UucHkjTDY3Ny1MNzA0XG4gICAgICAgICAgICAgICAgICAgIHBrdnNbbmV3TmFtZV0gPSBwYXN0S2V5VmFsdWVzW25ld05hbWVdO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHBrdnNbbmV3TmFtZV0gPSBkZWNvZGVyUmVzdWx0c1tuYW1lXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBrdnM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBvYmplY3QgY29udGFpbmluZyBhdHRlbnRpb25zIGZyb20gdGhlIGdpdmVuIGRlY29kZXIgcmVzdWx0cyBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGVjb2RlclJlc3VsdHMgVGhlIGRlY29kZXIgcmVzdWx0cyBvYmplY3QuXG4gICAgICogQHJldHVybnMge09iamVjdH0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgYXR0ZW50aW9ucy5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGdldEF0dGVudGlvbnMoZGVjb2RlclJlc3VsdHMpIHtcbiAgICAgICAgY29uc3QgYXR0bnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gICAgICAgIGZvciAoY29uc3QgYXR0bk5hbWUgb2YgWydjcm9zc19hdHRlbnRpb25zJywgJ2RlY29kZXJfYXR0ZW50aW9ucyddKSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgbmFtZSBpbiBkZWNvZGVyUmVzdWx0cykge1xuICAgICAgICAgICAgICAgIGlmIChuYW1lLnN0YXJ0c1dpdGgoYXR0bk5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gbmFtZS5zcGxpdCgnLicpLnBvcCgpXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtpbmRleF0gPSBkZWNvZGVyUmVzdWx0c1tuYW1lXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhdHRuc1thdHRuTmFtZV0gPSByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGF0dG5zO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZHMgcGFzdCBrZXkgdmFsdWVzIHRvIHRoZSBkZWNvZGVyIGZlZWRzIG9iamVjdC4gSWYgcGFzdEtleVZhbHVlcyBpcyBudWxsLCBjcmVhdGVzIG5ldyB0ZW5zb3JzIGZvciBwYXN0IGtleSB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGVjb2RlckZlZWRzIFRoZSBkZWNvZGVyIGZlZWRzIG9iamVjdCB0byBhZGQgcGFzdCBrZXkgdmFsdWVzIHRvLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXN0S2V5VmFsdWVzIEFuIG9iamVjdCBjb250YWluaW5nIHBhc3Qga2V5IHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtoYXNEZWNvZGVyPWZhbHNlXSBXaGV0aGVyIHRoZSBtb2RlbCBoYXMgYSBkZWNvZGVyLlxuICAgICAqL1xuICAgIGFkZFBhc3RLZXlWYWx1ZXMoZGVjb2RlckZlZWRzLCBwYXN0S2V5VmFsdWVzLCBoYXNEZWNvZGVyID0gZmFsc2UpIHtcbiAgICAgICAgaWYgKHBhc3RLZXlWYWx1ZXMpIHtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oZGVjb2RlckZlZWRzLCBwYXN0S2V5VmFsdWVzKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gVE9ETyBzdXBwb3J0IGJhdGNoZXMgKGkuZS4sIGJhdGNoX3NpemUgPiAxKVxuICAgICAgICAgICAgaWYgKGhhc0RlY29kZXIpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgbGV0IGVuY29kZXJfZGltcyA9IFsxLCB0aGlzLm51bV9lbmNvZGVyX2hlYWRzLCAwLCB0aGlzLmVuY29kZXJfZGltX2t2XTtcbiAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm51bV9lbmNvZGVyX2xheWVyczsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlY29kZXJGZWVkc1tgcGFzdF9rZXlfdmFsdWVzLiR7aX0uZW5jb2Rlci5rZXlgXSA9IG5ldyBUZW5zb3IoJ2Zsb2F0MzInLCBbXSwgZW5jb2Rlcl9kaW1zKVxuICAgICAgICAgICAgICAgICAgICBkZWNvZGVyRmVlZHNbYHBhc3Rfa2V5X3ZhbHVlcy4ke2l9LmVuY29kZXIudmFsdWVgXSA9IG5ldyBUZW5zb3IoJ2Zsb2F0MzInLCBbXSwgZW5jb2Rlcl9kaW1zKVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICBsZXQgZGVjb2Rlcl9kaW1zID0gWzEsIHRoaXMubnVtX2RlY29kZXJfaGVhZHMsIDAsIHRoaXMuZGVjb2Rlcl9kaW1fa3ZdO1xuICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubnVtX2RlY29kZXJfbGF5ZXJzOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVjb2RlckZlZWRzW2BwYXN0X2tleV92YWx1ZXMuJHtpfS5kZWNvZGVyLmtleWBdID0gbmV3IFRlbnNvcignZmxvYXQzMicsIFtdLCBkZWNvZGVyX2RpbXMpXG4gICAgICAgICAgICAgICAgICAgIGRlY29kZXJGZWVkc1tgcGFzdF9rZXlfdmFsdWVzLiR7aX0uZGVjb2Rlci52YWx1ZWBdID0gbmV3IFRlbnNvcignZmxvYXQzMicsIFtdLCBkZWNvZGVyX2RpbXMpXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICBsZXQgZGltcyA9IFsxLCB0aGlzLm51bV9oZWFkcywgMCwgdGhpcy5kaW1fa3ZdXG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5udW1fbGF5ZXJzOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVjb2RlckZlZWRzW2BwYXN0X2tleV92YWx1ZXMuJHtpfS5rZXlgXSA9IG5ldyBUZW5zb3IoJ2Zsb2F0MzInLCBbXSwgZGltcylcbiAgICAgICAgICAgICAgICAgICAgZGVjb2RlckZlZWRzW2BwYXN0X2tleV92YWx1ZXMuJHtpfS52YWx1ZWBdID0gbmV3IFRlbnNvcignZmxvYXQzMicsIFtdLCBkaW1zKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBCYXNlIG1vZGVsIG91dHB1dCBjbGFzc1xuZXhwb3J0IGNsYXNzIE1vZGVsT3V0cHV0IHsgfVxuXG4vKipcbiAqIEJhc2UgY2xhc3MgZm9yIG1vZGVsJ3Mgb3V0cHV0cywgd2l0aCBwb3RlbnRpYWwgaGlkZGVuIHN0YXRlcyBhbmQgYXR0ZW50aW9ucy5cbiAqL1xuZXhwb3J0IGNsYXNzIEJhc2VNb2RlbE91dHB1dCBleHRlbmRzIE1vZGVsT3V0cHV0IHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3V0cHV0IFRoZSBvdXRwdXQgb2YgdGhlIG1vZGVsLlxuICAgICAqIEBwYXJhbSB7VGVuc29yfSBvdXRwdXQubGFzdF9oaWRkZW5fc3RhdGUgU2VxdWVuY2Ugb2YgaGlkZGVuLXN0YXRlcyBhdCB0aGUgb3V0cHV0IG9mIHRoZSBsYXN0IGxheWVyIG9mIHRoZSBtb2RlbC5cbiAgICAgKiBAcGFyYW0ge1RlbnNvcn0gW291dHB1dC5oaWRkZW5fc3RhdGVzXSBIaWRkZW4tc3RhdGVzIG9mIHRoZSBtb2RlbCBhdCB0aGUgb3V0cHV0IG9mIGVhY2ggbGF5ZXIgcGx1cyB0aGUgb3B0aW9uYWwgaW5pdGlhbCBlbWJlZGRpbmcgb3V0cHV0cy5cbiAgICAgKiBAcGFyYW0ge1RlbnNvcn0gW291dHB1dC5hdHRlbnRpb25zXSBBdHRlbnRpb25zIHdlaWdodHMgYWZ0ZXIgdGhlIGF0dGVudGlvbiBzb2Z0bWF4LCB1c2VkIHRvIGNvbXB1dGUgdGhlIHdlaWdodGVkIGF2ZXJhZ2UgaW4gdGhlIHNlbGYtYXR0ZW50aW9uIGhlYWRzLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHsgbGFzdF9oaWRkZW5fc3RhdGUsIGhpZGRlbl9zdGF0ZXMgPSBudWxsLCBhdHRlbnRpb25zID0gbnVsbCB9KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMubGFzdF9oaWRkZW5fc3RhdGUgPSBsYXN0X2hpZGRlbl9zdGF0ZTtcbiAgICAgICAgdGhpcy5oaWRkZW5fc3RhdGVzID0gaGlkZGVuX3N0YXRlcztcbiAgICAgICAgdGhpcy5hdHRlbnRpb25zID0gYXR0ZW50aW9ucztcbiAgICB9XG59XG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gQmVydCBtb2RlbHNcbmV4cG9ydCBjbGFzcyBCZXJ0UHJlVHJhaW5lZE1vZGVsIGV4dGVuZHMgUHJlVHJhaW5lZE1vZGVsIHsgfVxuZXhwb3J0IGNsYXNzIEJlcnRNb2RlbCBleHRlbmRzIEJlcnRQcmVUcmFpbmVkTW9kZWwgeyB9XG5cbi8qKlxuICogQmVydEZvck1hc2tlZExNIGlzIGEgY2xhc3MgcmVwcmVzZW50aW5nIGEgQkVSVCBtb2RlbCBmb3IgbWFza2VkIGxhbmd1YWdlIG1vZGVsaW5nLlxuICogQGV4dGVuZHMgQmVydFByZVRyYWluZWRNb2RlbFxuICovXG5leHBvcnQgY2xhc3MgQmVydEZvck1hc2tlZExNIGV4dGVuZHMgQmVydFByZVRyYWluZWRNb2RlbCB7XG4gICAgLyoqXG4gICAgICogQ2FsbHMgdGhlIG1vZGVsIG9uIG5ldyBpbnB1dHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbW9kZWxfaW5wdXRzIFRoZSBpbnB1dHMgdG8gdGhlIG1vZGVsLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPE1hc2tlZExNT3V0cHV0Pn0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIG1vZGVsJ3Mgb3V0cHV0IGxvZ2l0cyBmb3IgbWFza2VkIGxhbmd1YWdlIG1vZGVsaW5nLlxuICAgICAqL1xuICAgIGFzeW5jIF9jYWxsKG1vZGVsX2lucHV0cykge1xuICAgICAgICByZXR1cm4gbmV3IE1hc2tlZExNT3V0cHV0KGF3YWl0IHN1cGVyLl9jYWxsKG1vZGVsX2lucHV0cykpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBCZXJ0Rm9yU2VxdWVuY2VDbGFzc2lmaWNhdGlvbiBpcyBhIGNsYXNzIHJlcHJlc2VudGluZyBhIEJFUlQgbW9kZWwgZm9yIHNlcXVlbmNlIGNsYXNzaWZpY2F0aW9uLlxuICogQGV4dGVuZHMgQmVydFByZVRyYWluZWRNb2RlbFxuICovXG5leHBvcnQgY2xhc3MgQmVydEZvclNlcXVlbmNlQ2xhc3NpZmljYXRpb24gZXh0ZW5kcyBCZXJ0UHJlVHJhaW5lZE1vZGVsIHtcbiAgICAvKipcbiAgICAgKiBDYWxscyB0aGUgbW9kZWwgb24gbmV3IGlucHV0cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtb2RlbF9pbnB1dHMgVGhlIGlucHV0cyB0byB0aGUgbW9kZWwuXG4gICAgICogQHJldHVybnMge1Byb21pc2U8U2VxdWVuY2VDbGFzc2lmaWVyT3V0cHV0Pn0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIG1vZGVsJ3Mgb3V0cHV0IGxvZ2l0cyBmb3Igc2VxdWVuY2UgY2xhc3NpZmljYXRpb24uXG4gICAgICovXG4gICAgYXN5bmMgX2NhbGwobW9kZWxfaW5wdXRzKSB7XG4gICAgICAgIHJldHVybiBuZXcgU2VxdWVuY2VDbGFzc2lmaWVyT3V0cHV0KGF3YWl0IHN1cGVyLl9jYWxsKG1vZGVsX2lucHV0cykpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBCZXJ0Rm9yVG9rZW5DbGFzc2lmaWNhdGlvbiBpcyBhIGNsYXNzIHJlcHJlc2VudGluZyBhIEJFUlQgbW9kZWwgZm9yIHRva2VuIGNsYXNzaWZpY2F0aW9uLlxuICogQGV4dGVuZHMgQmVydFByZVRyYWluZWRNb2RlbFxuICovXG5leHBvcnQgY2xhc3MgQmVydEZvclRva2VuQ2xhc3NpZmljYXRpb24gZXh0ZW5kcyBCZXJ0UHJlVHJhaW5lZE1vZGVsIHtcbiAgICAvKipcbiAgICAgKiBDYWxscyB0aGUgbW9kZWwgb24gbmV3IGlucHV0cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtb2RlbF9pbnB1dHMgVGhlIGlucHV0cyB0byB0aGUgbW9kZWwuXG4gICAgICogQHJldHVybnMge1Byb21pc2U8VG9rZW5DbGFzc2lmaWVyT3V0cHV0Pn0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIG1vZGVsJ3Mgb3V0cHV0IGxvZ2l0cyBmb3IgdG9rZW4gY2xhc3NpZmljYXRpb24uXG4gICAgICovXG4gICAgYXN5bmMgX2NhbGwobW9kZWxfaW5wdXRzKSB7XG4gICAgICAgIHJldHVybiBuZXcgVG9rZW5DbGFzc2lmaWVyT3V0cHV0KGF3YWl0IHN1cGVyLl9jYWxsKG1vZGVsX2lucHV0cykpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBCZXJ0Rm9yUXVlc3Rpb25BbnN3ZXJpbmcgaXMgYSBjbGFzcyByZXByZXNlbnRpbmcgYSBCRVJUIG1vZGVsIGZvciBxdWVzdGlvbiBhbnN3ZXJpbmcuXG4gKiBAZXh0ZW5kcyBCZXJ0UHJlVHJhaW5lZE1vZGVsXG4gKi9cbmV4cG9ydCBjbGFzcyBCZXJ0Rm9yUXVlc3Rpb25BbnN3ZXJpbmcgZXh0ZW5kcyBCZXJ0UHJlVHJhaW5lZE1vZGVsIHtcbiAgICAvKipcbiAgICAgKiBDYWxscyB0aGUgbW9kZWwgb24gbmV3IGlucHV0cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtb2RlbF9pbnB1dHMgVGhlIGlucHV0cyB0byB0aGUgbW9kZWwuXG4gICAgICogQHJldHVybnMge1Byb21pc2U8UXVlc3Rpb25BbnN3ZXJpbmdNb2RlbE91dHB1dD59IEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBtb2RlbCdzIG91dHB1dCBsb2dpdHMgZm9yIHF1ZXN0aW9uIGFuc3dlcmluZy5cbiAgICAgKi9cbiAgICBhc3luYyBfY2FsbChtb2RlbF9pbnB1dHMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBRdWVzdGlvbkFuc3dlcmluZ01vZGVsT3V0cHV0KGF3YWl0IHN1cGVyLl9jYWxsKG1vZGVsX2lucHV0cykpO1xuICAgIH1cbn1cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBEaXN0aWxCZXJ0IG1vZGVsc1xuZXhwb3J0IGNsYXNzIERpc3RpbEJlcnRQcmVUcmFpbmVkTW9kZWwgZXh0ZW5kcyBQcmVUcmFpbmVkTW9kZWwgeyB9XG5leHBvcnQgY2xhc3MgRGlzdGlsQmVydE1vZGVsIGV4dGVuZHMgRGlzdGlsQmVydFByZVRyYWluZWRNb2RlbCB7IH1cblxuLyoqXG4gKiBEaXN0aWxCZXJ0Rm9yU2VxdWVuY2VDbGFzc2lmaWNhdGlvbiBpcyBhIGNsYXNzIHJlcHJlc2VudGluZyBhIERpc3RpbEJFUlQgbW9kZWwgZm9yIHNlcXVlbmNlIGNsYXNzaWZpY2F0aW9uLlxuICogQGV4dGVuZHMgRGlzdGlsQmVydFByZVRyYWluZWRNb2RlbFxuICovXG5leHBvcnQgY2xhc3MgRGlzdGlsQmVydEZvclNlcXVlbmNlQ2xhc3NpZmljYXRpb24gZXh0ZW5kcyBEaXN0aWxCZXJ0UHJlVHJhaW5lZE1vZGVsIHtcbiAgICAvKipcbiAgICAgKiBDYWxscyB0aGUgbW9kZWwgb24gbmV3IGlucHV0cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtb2RlbF9pbnB1dHMgVGhlIGlucHV0cyB0byB0aGUgbW9kZWwuXG4gICAgICogQHJldHVybnMge1Byb21pc2U8U2VxdWVuY2VDbGFzc2lmaWVyT3V0cHV0Pn0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIG1vZGVsJ3Mgb3V0cHV0IGxvZ2l0cyBmb3Igc2VxdWVuY2UgY2xhc3NpZmljYXRpb24uXG4gICAgICovXG4gICAgYXN5bmMgX2NhbGwobW9kZWxfaW5wdXRzKSB7XG4gICAgICAgIHJldHVybiBuZXcgU2VxdWVuY2VDbGFzc2lmaWVyT3V0cHV0KGF3YWl0IHN1cGVyLl9jYWxsKG1vZGVsX2lucHV0cykpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBEaXN0aWxCZXJ0Rm9yVG9rZW5DbGFzc2lmaWNhdGlvbiBpcyBhIGNsYXNzIHJlcHJlc2VudGluZyBhIERpc3RpbEJFUlQgbW9kZWwgZm9yIHRva2VuIGNsYXNzaWZpY2F0aW9uLlxuICogQGV4dGVuZHMgRGlzdGlsQmVydFByZVRyYWluZWRNb2RlbFxuICovXG5leHBvcnQgY2xhc3MgRGlzdGlsQmVydEZvclRva2VuQ2xhc3NpZmljYXRpb24gZXh0ZW5kcyBEaXN0aWxCZXJ0UHJlVHJhaW5lZE1vZGVsIHtcbiAgICAvKipcbiAgICAgKiBDYWxscyB0aGUgbW9kZWwgb24gbmV3IGlucHV0cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtb2RlbF9pbnB1dHMgVGhlIGlucHV0cyB0byB0aGUgbW9kZWwuXG4gICAgICogQHJldHVybnMge1Byb21pc2U8VG9rZW5DbGFzc2lmaWVyT3V0cHV0Pn0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIG1vZGVsJ3Mgb3V0cHV0IGxvZ2l0cyBmb3IgdG9rZW4gY2xhc3NpZmljYXRpb24uXG4gICAgICovXG4gICAgYXN5bmMgX2NhbGwobW9kZWxfaW5wdXRzKSB7XG4gICAgICAgIHJldHVybiBuZXcgVG9rZW5DbGFzc2lmaWVyT3V0cHV0KGF3YWl0IHN1cGVyLl9jYWxsKG1vZGVsX2lucHV0cykpO1xuICAgIH1cbn1cblxuXG4vKipcbiAqIERpc3RpbEJlcnRGb3JRdWVzdGlvbkFuc3dlcmluZyBpcyBhIGNsYXNzIHJlcHJlc2VudGluZyBhIERpc3RpbEJFUlQgbW9kZWwgZm9yIHF1ZXN0aW9uIGFuc3dlcmluZy5cbiAqIEBleHRlbmRzIERpc3RpbEJlcnRQcmVUcmFpbmVkTW9kZWxcbiAqL1xuZXhwb3J0IGNsYXNzIERpc3RpbEJlcnRGb3JRdWVzdGlvbkFuc3dlcmluZyBleHRlbmRzIERpc3RpbEJlcnRQcmVUcmFpbmVkTW9kZWwge1xuICAgIC8qKlxuICAgICAqIENhbGxzIHRoZSBtb2RlbCBvbiBuZXcgaW5wdXRzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1vZGVsX2lucHV0cyBUaGUgaW5wdXRzIHRvIHRoZSBtb2RlbC5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxRdWVzdGlvbkFuc3dlcmluZ01vZGVsT3V0cHV0Pn0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIG1vZGVsJ3Mgb3V0cHV0IGxvZ2l0cyBmb3IgcXVlc3Rpb24gYW5zd2VyaW5nLlxuICAgICAqL1xuICAgIGFzeW5jIF9jYWxsKG1vZGVsX2lucHV0cykge1xuICAgICAgICByZXR1cm4gbmV3IFF1ZXN0aW9uQW5zd2VyaW5nTW9kZWxPdXRwdXQoYXdhaXQgc3VwZXIuX2NhbGwobW9kZWxfaW5wdXRzKSk7XG4gICAgfVxufVxuXG4vKipcbiAqIERpc3RpbEJlcnRGb3JNYXNrZWRMTSBpcyBhIGNsYXNzIHJlcHJlc2VudGluZyBhIERpc3RpbEJFUlQgbW9kZWwgZm9yIG1hc2tpbmcgdGFzay5cbiAqIEBleHRlbmRzIERpc3RpbEJlcnRQcmVUcmFpbmVkTW9kZWxcbiAqL1xuZXhwb3J0IGNsYXNzIERpc3RpbEJlcnRGb3JNYXNrZWRMTSBleHRlbmRzIERpc3RpbEJlcnRQcmVUcmFpbmVkTW9kZWwge1xuICAgIC8qKlxuICAgICAqIENhbGxzIHRoZSBtb2RlbCBvbiBuZXcgaW5wdXRzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1vZGVsX2lucHV0cyBUaGUgaW5wdXRzIHRvIHRoZSBtb2RlbC5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxNYXNrZWRMTU91dHB1dD59IHJldHVybmVkIG9iamVjdFxuICAgICAqL1xuICAgIGFzeW5jIF9jYWxsKG1vZGVsX2lucHV0cykge1xuICAgICAgICByZXR1cm4gbmV3IE1hc2tlZExNT3V0cHV0KGF3YWl0IHN1cGVyLl9jYWxsKG1vZGVsX2lucHV0cykpO1xuICAgIH1cbn1cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIE1vYmlsZUJlcnQgbW9kZWxzXG5leHBvcnQgY2xhc3MgTW9iaWxlQmVydFByZVRyYWluZWRNb2RlbCBleHRlbmRzIFByZVRyYWluZWRNb2RlbCB7IH1cbmV4cG9ydCBjbGFzcyBNb2JpbGVCZXJ0TW9kZWwgZXh0ZW5kcyBNb2JpbGVCZXJ0UHJlVHJhaW5lZE1vZGVsIHsgfVxuXG4vKipcbiAqIE1vYmlsZUJlcnRGb3JNYXNrZWRMTSBpcyBhIGNsYXNzIHJlcHJlc2VudGluZyBhIE1vYmlsZUJFUlQgbW9kZWwgZm9yIG1hc2tpbmcgdGFzay5cbiAqIEBleHRlbmRzIE1vYmlsZUJlcnRQcmVUcmFpbmVkTW9kZWxcbiAqL1xuZXhwb3J0IGNsYXNzIE1vYmlsZUJlcnRGb3JNYXNrZWRMTSBleHRlbmRzIE1vYmlsZUJlcnRQcmVUcmFpbmVkTW9kZWwge1xuICAgIC8qKlxuICAgICAqIENhbGxzIHRoZSBtb2RlbCBvbiBuZXcgaW5wdXRzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1vZGVsX2lucHV0cyBUaGUgaW5wdXRzIHRvIHRoZSBtb2RlbC5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxNYXNrZWRMTU91dHB1dD59IHJldHVybmVkIG9iamVjdFxuICAgICAqL1xuICAgIGFzeW5jIF9jYWxsKG1vZGVsX2lucHV0cykge1xuICAgICAgICByZXR1cm4gbmV3IE1hc2tlZExNT3V0cHV0KGF3YWl0IHN1cGVyLl9jYWxsKG1vZGVsX2lucHV0cykpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAZXh0ZW5kcyBNb2JpbGVCZXJ0UHJlVHJhaW5lZE1vZGVsXG4gKi9cbmV4cG9ydCBjbGFzcyBNb2JpbGVCZXJ0Rm9yU2VxdWVuY2VDbGFzc2lmaWNhdGlvbiBleHRlbmRzIE1vYmlsZUJlcnRQcmVUcmFpbmVkTW9kZWwge1xuICAgIC8qKlxuICAgICAqIENhbGxzIHRoZSBtb2RlbCBvbiBuZXcgaW5wdXRzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1vZGVsX2lucHV0cyBUaGUgaW5wdXRzIHRvIHRoZSBtb2RlbC5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxTZXF1ZW5jZUNsYXNzaWZpZXJPdXRwdXQ+fSByZXR1cm5lZCBvYmplY3RcbiAgICAgKi9cbiAgICBhc3luYyBfY2FsbChtb2RlbF9pbnB1dHMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTZXF1ZW5jZUNsYXNzaWZpZXJPdXRwdXQoYXdhaXQgc3VwZXIuX2NhbGwobW9kZWxfaW5wdXRzKSk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBleHRlbmRzIE1vYmlsZUJlcnRQcmVUcmFpbmVkTW9kZWxcbiAqL1xuZXhwb3J0IGNsYXNzIE1vYmlsZUJlcnRGb3JRdWVzdGlvbkFuc3dlcmluZyBleHRlbmRzIE1vYmlsZUJlcnRQcmVUcmFpbmVkTW9kZWwge1xuICAgIC8qKlxuICAgICAqIENhbGxzIHRoZSBtb2RlbCBvbiBuZXcgaW5wdXRzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1vZGVsX2lucHV0cyBUaGUgaW5wdXRzIHRvIHRoZSBtb2RlbC5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxRdWVzdGlvbkFuc3dlcmluZ01vZGVsT3V0cHV0Pn0gcmV0dXJuZWQgb2JqZWN0XG4gICAgICovXG4gICAgYXN5bmMgX2NhbGwobW9kZWxfaW5wdXRzKSB7XG4gICAgICAgIHJldHVybiBuZXcgUXVlc3Rpb25BbnN3ZXJpbmdNb2RlbE91dHB1dChhd2FpdCBzdXBlci5fY2FsbChtb2RlbF9pbnB1dHMpKTtcbiAgICB9XG59XG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBTcXVlZXplQmVydCBtb2RlbHNcbmV4cG9ydCBjbGFzcyBTcXVlZXplQmVydFByZVRyYWluZWRNb2RlbCBleHRlbmRzIFByZVRyYWluZWRNb2RlbCB7IH1cbmV4cG9ydCBjbGFzcyBTcXVlZXplQmVydE1vZGVsIGV4dGVuZHMgU3F1ZWV6ZUJlcnRQcmVUcmFpbmVkTW9kZWwgeyB9XG5leHBvcnQgY2xhc3MgU3F1ZWV6ZUJlcnRGb3JNYXNrZWRMTSBleHRlbmRzIFNxdWVlemVCZXJ0UHJlVHJhaW5lZE1vZGVsIHtcbiAgICAvKipcbiAgICAgKiBDYWxscyB0aGUgbW9kZWwgb24gbmV3IGlucHV0cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtb2RlbF9pbnB1dHMgVGhlIGlucHV0cyB0byB0aGUgbW9kZWwuXG4gICAgICogQHJldHVybnMge1Byb21pc2U8TWFza2VkTE1PdXRwdXQ+fSByZXR1cm5lZCBvYmplY3RcbiAgICAgKi9cbiAgICBhc3luYyBfY2FsbChtb2RlbF9pbnB1dHMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBNYXNrZWRMTU91dHB1dChhd2FpdCBzdXBlci5fY2FsbChtb2RlbF9pbnB1dHMpKTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgU3F1ZWV6ZUJlcnRGb3JTZXF1ZW5jZUNsYXNzaWZpY2F0aW9uIGV4dGVuZHMgU3F1ZWV6ZUJlcnRQcmVUcmFpbmVkTW9kZWwge1xuICAgIC8qKlxuICAgICAqIENhbGxzIHRoZSBtb2RlbCBvbiBuZXcgaW5wdXRzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1vZGVsX2lucHV0cyBUaGUgaW5wdXRzIHRvIHRoZSBtb2RlbC5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxTZXF1ZW5jZUNsYXNzaWZpZXJPdXRwdXQ+fSByZXR1cm5lZCBvYmplY3RcbiAgICAgKi9cbiAgICBhc3luYyBfY2FsbChtb2RlbF9pbnB1dHMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTZXF1ZW5jZUNsYXNzaWZpZXJPdXRwdXQoYXdhaXQgc3VwZXIuX2NhbGwobW9kZWxfaW5wdXRzKSk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIFNxdWVlemVCZXJ0Rm9yUXVlc3Rpb25BbnN3ZXJpbmcgZXh0ZW5kcyBTcXVlZXplQmVydFByZVRyYWluZWRNb2RlbCB7XG4gICAgLyoqXG4gICAgICogQ2FsbHMgdGhlIG1vZGVsIG9uIG5ldyBpbnB1dHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbW9kZWxfaW5wdXRzIFRoZSBpbnB1dHMgdG8gdGhlIG1vZGVsLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFF1ZXN0aW9uQW5zd2VyaW5nTW9kZWxPdXRwdXQ+fSByZXR1cm5lZCBvYmplY3RcbiAgICAgKi9cbiAgICBhc3luYyBfY2FsbChtb2RlbF9pbnB1dHMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBRdWVzdGlvbkFuc3dlcmluZ01vZGVsT3V0cHV0KGF3YWl0IHN1cGVyLl9jYWxsKG1vZGVsX2lucHV0cykpO1xuICAgIH1cbn1cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIEFsYmVydCBtb2RlbHNcbmV4cG9ydCBjbGFzcyBBbGJlcnRQcmVUcmFpbmVkTW9kZWwgZXh0ZW5kcyBQcmVUcmFpbmVkTW9kZWwgeyB9XG5leHBvcnQgY2xhc3MgQWxiZXJ0TW9kZWwgZXh0ZW5kcyBBbGJlcnRQcmVUcmFpbmVkTW9kZWwgeyB9XG5leHBvcnQgY2xhc3MgQWxiZXJ0Rm9yU2VxdWVuY2VDbGFzc2lmaWNhdGlvbiBleHRlbmRzIEFsYmVydFByZVRyYWluZWRNb2RlbCB7XG4gICAgLyoqXG4gICAgICogQ2FsbHMgdGhlIG1vZGVsIG9uIG5ldyBpbnB1dHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbW9kZWxfaW5wdXRzIFRoZSBpbnB1dHMgdG8gdGhlIG1vZGVsLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFNlcXVlbmNlQ2xhc3NpZmllck91dHB1dD59IHJldHVybmVkIG9iamVjdFxuICAgICAqL1xuICAgIGFzeW5jIF9jYWxsKG1vZGVsX2lucHV0cykge1xuICAgICAgICByZXR1cm4gbmV3IFNlcXVlbmNlQ2xhc3NpZmllck91dHB1dChhd2FpdCBzdXBlci5fY2FsbChtb2RlbF9pbnB1dHMpKTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgQWxiZXJ0Rm9yUXVlc3Rpb25BbnN3ZXJpbmcgZXh0ZW5kcyBBbGJlcnRQcmVUcmFpbmVkTW9kZWwge1xuICAgIC8qKlxuICAgICAqIENhbGxzIHRoZSBtb2RlbCBvbiBuZXcgaW5wdXRzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1vZGVsX2lucHV0cyBUaGUgaW5wdXRzIHRvIHRoZSBtb2RlbC5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxRdWVzdGlvbkFuc3dlcmluZ01vZGVsT3V0cHV0Pn0gcmV0dXJuZWQgb2JqZWN0XG4gICAgICovXG4gICAgYXN5bmMgX2NhbGwobW9kZWxfaW5wdXRzKSB7XG4gICAgICAgIHJldHVybiBuZXcgUXVlc3Rpb25BbnN3ZXJpbmdNb2RlbE91dHB1dChhd2FpdCBzdXBlci5fY2FsbChtb2RlbF9pbnB1dHMpKTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgQWxiZXJ0Rm9yTWFza2VkTE0gZXh0ZW5kcyBBbGJlcnRQcmVUcmFpbmVkTW9kZWwge1xuICAgIC8qKlxuICAgICAqIENhbGxzIHRoZSBtb2RlbCBvbiBuZXcgaW5wdXRzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1vZGVsX2lucHV0cyBUaGUgaW5wdXRzIHRvIHRoZSBtb2RlbC5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxNYXNrZWRMTU91dHB1dD59IHJldHVybmVkIG9iamVjdFxuICAgICAqL1xuICAgIGFzeW5jIF9jYWxsKG1vZGVsX2lucHV0cykge1xuICAgICAgICByZXR1cm4gbmV3IE1hc2tlZExNT3V0cHV0KGF3YWl0IHN1cGVyLl9jYWxsKG1vZGVsX2lucHV0cykpO1xuICAgIH1cbn1cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFQ1IG1vZGVsc1xuZXhwb3J0IGNsYXNzIFQ1UHJlVHJhaW5lZE1vZGVsIGV4dGVuZHMgUHJlVHJhaW5lZE1vZGVsIHsgfTtcblxuZXhwb3J0IGNsYXNzIFQ1TW9kZWwgZXh0ZW5kcyBUNVByZVRyYWluZWRNb2RlbCB7XG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIHRleHQgYmFzZWQgb24gdGhlIHByb3ZpZGVkIGFyZ3VtZW50cy5cbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gVGhyb3dzIGFuIGVycm9yIGFzIHRoZSBjdXJyZW50IG1vZGVsIGNsYXNzIChUNU1vZGVsKSBpcyBub3QgY29tcGF0aWJsZSB3aXRoIGAuZ2VuZXJhdGUoKWAuXG4gICAgICogQHJldHVybnMge1Byb21pc2U8YW55Pn1cbiAgICAgKiBAcGFyYW0ge2FueVtdfSBhcmdzXG4gICAgICovXG4gICAgYXN5bmMgZ2VuZXJhdGUoLi4uYXJncykge1xuICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgIFwiVGhlIGN1cnJlbnQgbW9kZWwgY2xhc3MgKFQ1TW9kZWwpIGlzIG5vdCBjb21wYXRpYmxlIHdpdGggYC5nZW5lcmF0ZSgpYCwgYXMgaXQgZG9lc24ndCBoYXZlIGEgbGFuZ3VhZ2UgbW9kZWwgaGVhZC4gUGxlYXNlIHVzZSBvbmUgb2YgdGhlIGZvbGxvd2luZyBjbGFzc2VzIGluc3RlYWQ6IHsnVDVGb3JDb25kaXRpb25hbEdlbmVyYXRpb24nfVwiXG4gICAgICAgIClcbiAgICB9XG59XG5cbi8qKlxuICogVDVNb2RlbCBpcyBhIGNsYXNzIHJlcHJlc2VudGluZyBhIFQ1IG1vZGVsIGZvciBjb25kaXRpb25hbCBnZW5lcmF0aW9uLlxuICogQGV4dGVuZHMgVDVQcmVUcmFpbmVkTW9kZWxcbiAqL1xuZXhwb3J0IGNsYXNzIFQ1Rm9yQ29uZGl0aW9uYWxHZW5lcmF0aW9uIGV4dGVuZHMgVDVQcmVUcmFpbmVkTW9kZWwge1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiB0aGUgYFQ1Rm9yQ29uZGl0aW9uYWxHZW5lcmF0aW9uYCBjbGFzcy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIFRoZSBtb2RlbCBjb25maWd1cmF0aW9uLlxuICAgICAqIEBwYXJhbSB7YW55fSBzZXNzaW9uIHNlc3Npb24gZm9yIHRoZSBtb2RlbC5cbiAgICAgKiBAcGFyYW0ge2FueX0gZGVjb2Rlcl9tZXJnZWRfc2Vzc2lvbiBzZXNzaW9uIGZvciB0aGUgZGVjb2Rlci5cbiAgICAgKiBAcGFyYW0ge0dlbmVyYXRpb25Db25maWd9IGdlbmVyYXRpb25fY29uZmlnIFRoZSBnZW5lcmF0aW9uIGNvbmZpZ3VyYXRpb24uXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY29uZmlnLCBzZXNzaW9uLCBkZWNvZGVyX21lcmdlZF9zZXNzaW9uLCBnZW5lcmF0aW9uX2NvbmZpZykge1xuICAgICAgICBzdXBlcihjb25maWcsIHNlc3Npb24pO1xuICAgICAgICB0aGlzLmRlY29kZXJfbWVyZ2VkX3Nlc3Npb24gPSBkZWNvZGVyX21lcmdlZF9zZXNzaW9uO1xuICAgICAgICB0aGlzLmdlbmVyYXRpb25fY29uZmlnID0gZ2VuZXJhdGlvbl9jb25maWc7XG5cbiAgICAgICAgdGhpcy5udW1fZGVjb2Rlcl9sYXllcnMgPSB0aGlzLmNvbmZpZy5udW1fZGVjb2Rlcl9sYXllcnM7XG4gICAgICAgIHRoaXMubnVtX2RlY29kZXJfaGVhZHMgPSB0aGlzLmNvbmZpZy5udW1faGVhZHM7XG4gICAgICAgIHRoaXMuZGVjb2Rlcl9kaW1fa3YgPSB0aGlzLmNvbmZpZy5kX2t2O1xuXG4gICAgICAgIHRoaXMubnVtX2VuY29kZXJfbGF5ZXJzID0gdGhpcy5jb25maWcubnVtX2xheWVycztcbiAgICAgICAgdGhpcy5udW1fZW5jb2Rlcl9oZWFkcyA9IHRoaXMuY29uZmlnLm51bV9oZWFkcztcbiAgICAgICAgdGhpcy5lbmNvZGVyX2RpbV9rdiA9IHRoaXMuY29uZmlnLmRfa3Y7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIHRoZSBzdGFydCBiZWFtcyBmb3IgYSBnaXZlbiBzZXQgb2YgaW5wdXRzIGFuZCBvdXRwdXQgbGVuZ3RoLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyW11bXX0gaW5wdXRzIFRoZSBpbnB1dCB0b2tlbiBJRHMuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG51bU91dHB1dFRva2VucyBUaGUgZGVzaXJlZCBvdXRwdXQgbGVuZ3RoLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gVGhlIHN0YXJ0IGJlYW1zLlxuICAgICAqL1xuICAgIGdldFN0YXJ0QmVhbXMoaW5wdXRzLCBudW1PdXRwdXRUb2tlbnMsIC4uLmFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIHNlcTJzZXFTdGFydEJlYW1zKHRoaXMsIGlucHV0cywgbnVtT3V0cHV0VG9rZW5zKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSdW5zIGEgc2luZ2xlIHN0ZXAgb2YgdGhlIGJlYW0gc2VhcmNoIGdlbmVyYXRpb24gYWxnb3JpdGhtLlxuICAgICAqIEBwYXJhbSB7YW55fSBiZWFtIFRoZSBjdXJyZW50IGJlYW0gYmVpbmcgZ2VuZXJhdGVkLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPGFueT59IFRoZSB1cGRhdGVkIGJlYW0gYWZ0ZXIgYSBzaW5nbGUgZ2VuZXJhdGlvbiBzdGVwLlxuICAgICAqL1xuICAgIGFzeW5jIHJ1bkJlYW0oYmVhbSkge1xuICAgICAgICByZXR1cm4gYXdhaXQgc2VxMnNlcVJ1bkJlYW0odGhpcywgYmVhbSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgZ2l2ZW4gYmVhbSB3aXRoIGEgbmV3IHRva2VuIElELlxuICAgICAqIEBwYXJhbSB7YW55fSBiZWFtIFRoZSBjdXJyZW50IGJlYW0uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG5ld1Rva2VuSWQgVGhlIG5ldyB0b2tlbiBJRCB0byBhZGQgdG8gdGhlIG91dHB1dCBzZXF1ZW5jZS5cbiAgICAgKi9cbiAgICB1cGRhdGVCZWFtKGJlYW0sIG5ld1Rva2VuSWQpIHtcbiAgICAgICAgYmVhbS5vdXRwdXRfdG9rZW5faWRzID0gWy4uLmJlYW0ub3V0cHV0X3Rva2VuX2lkcywgbmV3VG9rZW5JZF07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUnVucyB0aGUgZm9yd2FyZCBwYXNzIG9mIHRoZSBtb2RlbCBmb3IgYSBnaXZlbiBzZXQgb2YgaW5wdXRzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtb2RlbF9pbnB1dHMgVGhlIG1vZGVsIGlucHV0cy5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fSBUaGUgbW9kZWwgb3V0cHV0LlxuICAgICAqL1xuICAgIGFzeW5jIGZvcndhcmQobW9kZWxfaW5wdXRzKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCBzZXEyc2VxRm9yd2FyZCh0aGlzLCBtb2RlbF9pbnB1dHMpO1xuICAgIH1cbn1cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBNVDUgbW9kZWxzXG5leHBvcnQgY2xhc3MgTVQ1UHJlVHJhaW5lZE1vZGVsIGV4dGVuZHMgUHJlVHJhaW5lZE1vZGVsIHsgfTtcblxuZXhwb3J0IGNsYXNzIE1UNU1vZGVsIGV4dGVuZHMgTVQ1UHJlVHJhaW5lZE1vZGVsIHtcbiAgICAvKipcbiAgICAgKiBcbiAgICAgKiBAcGFyYW0gIHsuLi5hbnl9IGFyZ3NcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxhbnk+fVxuICAgICAqIEB0aHJvd3Mge0Vycm9yfVxuICAgICAqL1xuICAgIGFzeW5jIGdlbmVyYXRlKC4uLmFyZ3MpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICBcIlRoZSBjdXJyZW50IG1vZGVsIGNsYXNzIChNVDVNb2RlbCkgaXMgbm90IGNvbXBhdGlibGUgd2l0aCBgLmdlbmVyYXRlKClgLCBhcyBpdCBkb2Vzbid0IGhhdmUgYSBsYW5ndWFnZSBtb2RlbCBoZWFkLiBQbGVhc2UgdXNlIG9uZSBvZiB0aGUgZm9sbG93aW5nIGNsYXNzZXMgaW5zdGVhZDogeydNVDVGb3JDb25kaXRpb25hbEdlbmVyYXRpb24nfVwiXG4gICAgICAgIClcbiAgICB9XG59XG5cbi8qKlxuICogQSBjbGFzcyByZXByZXNlbnRpbmcgYSBjb25kaXRpb25hbCBzZXF1ZW5jZS10by1zZXF1ZW5jZSBtb2RlbCBiYXNlZCBvbiB0aGUgTVQ1IGFyY2hpdGVjdHVyZS5cbiAqXG4gKiBAZXh0ZW5kcyBNVDVQcmVUcmFpbmVkTW9kZWxcbiAqL1xuZXhwb3J0IGNsYXNzIE1UNUZvckNvbmRpdGlvbmFsR2VuZXJhdGlvbiBleHRlbmRzIE1UNVByZVRyYWluZWRNb2RlbCB7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIHRoZSBgTVQ1Rm9yQ29uZGl0aW9uYWxHZW5lcmF0aW9uYCBjbGFzcy5cbiAgICAgKiBAcGFyYW0ge2FueX0gY29uZmlnIFRoZSBtb2RlbCBjb25maWd1cmF0aW9uLlxuICAgICAqIEBwYXJhbSB7YW55fSBzZXNzaW9uIFRoZSBPTk5YIHNlc3Npb24gY29udGFpbmluZyB0aGUgZW5jb2RlciB3ZWlnaHRzLlxuICAgICAqIEBwYXJhbSB7YW55fSBkZWNvZGVyX21lcmdlZF9zZXNzaW9uIFRoZSBPTk5YIHNlc3Npb24gY29udGFpbmluZyB0aGUgbWVyZ2VkIGRlY29kZXIgd2VpZ2h0cy5cbiAgICAgKiBAcGFyYW0ge0dlbmVyYXRpb25Db25maWd9IGdlbmVyYXRpb25fY29uZmlnIFRoZSBnZW5lcmF0aW9uIGNvbmZpZ3VyYXRpb24uXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY29uZmlnLCBzZXNzaW9uLCBkZWNvZGVyX21lcmdlZF9zZXNzaW9uLCBnZW5lcmF0aW9uX2NvbmZpZykge1xuICAgICAgICBzdXBlcihjb25maWcsIHNlc3Npb24pO1xuICAgICAgICB0aGlzLmRlY29kZXJfbWVyZ2VkX3Nlc3Npb24gPSBkZWNvZGVyX21lcmdlZF9zZXNzaW9uO1xuICAgICAgICB0aGlzLmdlbmVyYXRpb25fY29uZmlnID0gZ2VuZXJhdGlvbl9jb25maWc7XG5cbiAgICAgICAgdGhpcy5udW1fZGVjb2Rlcl9sYXllcnMgPSB0aGlzLmNvbmZpZy5udW1fZGVjb2Rlcl9sYXllcnM7XG4gICAgICAgIHRoaXMubnVtX2RlY29kZXJfaGVhZHMgPSB0aGlzLmNvbmZpZy5udW1faGVhZHM7XG4gICAgICAgIHRoaXMuZGVjb2Rlcl9kaW1fa3YgPSB0aGlzLmNvbmZpZy5kX2t2O1xuXG4gICAgICAgIHRoaXMubnVtX2VuY29kZXJfbGF5ZXJzID0gdGhpcy5jb25maWcubnVtX2xheWVycztcbiAgICAgICAgdGhpcy5udW1fZW5jb2Rlcl9oZWFkcyA9IHRoaXMuY29uZmlnLm51bV9oZWFkcztcbiAgICAgICAgdGhpcy5lbmNvZGVyX2RpbV9rdiA9IHRoaXMuY29uZmlnLmRfa3Y7XG4gICAgfVxuXG4gICAgLyoqXG4gICAqIEdlbmVyYXRlcyB0aGUgc3RhcnQgYmVhbXMgZm9yIHRoZSBnaXZlbiBpbnB1dCB0b2tlbnMgYW5kIG91dHB1dCBzZXF1ZW5jZSBsZW5ndGguXG4gICAqXG4gICAqIEBwYXJhbSB7YW55W119IGlucHV0cyBUaGUgaW5wdXQgc2VxdWVuY2UuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBudW1PdXRwdXRUb2tlbnMgVGhlIGRlc2lyZWQgbGVuZ3RoIG9mIHRoZSBvdXRwdXQgc2VxdWVuY2UuXG4gICAqIEBwYXJhbSB7Li4uKn0gYXJncyBBZGRpdGlvbmFsIGFyZ3VtZW50cyB0byBwYXNzIHRvIHRoZSBgc2VxMnNlcVN0YXJ0QmVhbXNgIGZ1bmN0aW9uLlxuICAgKiBAcmV0dXJucyB7YW55W119IEFuIGFycmF5IG9mIGBCZWFtYCBvYmplY3RzIHJlcHJlc2VudGluZyB0aGUgc3RhcnQgYmVhbXMuXG4gICAqL1xuICAgIGdldFN0YXJ0QmVhbXMoaW5wdXRzLCBudW1PdXRwdXRUb2tlbnMsIC4uLmFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIHNlcTJzZXFTdGFydEJlYW1zKHRoaXMsIGlucHV0cywgbnVtT3V0cHV0VG9rZW5zKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSdW5zIGEgc2luZ2xlIHN0ZXAgb2YgdGhlIGJlYW0gc2VhcmNoIGdlbmVyYXRpb24gYWxnb3JpdGhtLlxuICAgICAqIEBwYXJhbSB7YW55fSBiZWFtIFRoZSBjdXJyZW50IGJlYW0gYmVpbmcgZ2VuZXJhdGVkLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPGFueT59IFRoZSB1cGRhdGVkIGJlYW0gYWZ0ZXIgYSBzaW5nbGUgZ2VuZXJhdGlvbiBzdGVwLlxuICAgICAqL1xuICAgIGFzeW5jIHJ1bkJlYW0oYmVhbSkge1xuICAgICAgICByZXR1cm4gYXdhaXQgc2VxMnNlcVJ1bkJlYW0odGhpcywgYmVhbSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgZ2l2ZW4gYmVhbSB3aXRoIHRoZSBuZXcgcHJlZGljdGVkIHRva2VuLlxuICAgICAqIEBwYXJhbSB7YW55fSBiZWFtIFRoZSBiZWFtIHRvIHVwZGF0ZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbmV3VG9rZW5JZCBUaGUgaW5kZXggb2YgdGhlIHByZWRpY3RlZCB0b2tlbi5cbiAgICAqL1xuICAgIHVwZGF0ZUJlYW0oYmVhbSwgbmV3VG9rZW5JZCkge1xuICAgICAgICBiZWFtLm91dHB1dF90b2tlbl9pZHMgPSBbLi4uYmVhbS5vdXRwdXRfdG9rZW5faWRzLCBuZXdUb2tlbklkXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAqIFJ1bnMgdGhlIGZvcndhcmQgcGFzcyBvZiB0aGUgbW9kZWwgb24gdGhlIGdpdmVuIGlucHV0cy5cbiAgICAqIEBwYXJhbSB7YW55fSBtb2RlbF9pbnB1dHMgVGhlIG1vZGVsIGlucHV0cy5cbiAgICAqIEByZXR1cm5zIHtQcm9taXNlPGFueT59IEEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSBtb2RlbCBvdXRwdXRzLlxuICAgICovXG4gICAgYXN5bmMgZm9yd2FyZChtb2RlbF9pbnB1dHMpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHNlcTJzZXFGb3J3YXJkKHRoaXMsIG1vZGVsX2lucHV0cyk7XG4gICAgfVxufVxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIEJhcnQgbW9kZWxzXG5leHBvcnQgY2xhc3MgQmFydFByZXRyYWluZWRNb2RlbCBleHRlbmRzIFByZVRyYWluZWRNb2RlbCB7IH07XG5cbi8qKlxuICogQkFSVCBlbmNvZGVyIGFuZCBkZWNvZGVyIG1vZGVsLlxuICogXG4gKiBAaGlkZWNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBCYXJ0UHJldHJhaW5lZE1vZGVsXG4gKi9cbmV4cG9ydCBjbGFzcyBCYXJ0TW9kZWwgZXh0ZW5kcyBCYXJ0UHJldHJhaW5lZE1vZGVsIHtcbiAgICAvKipcbiAgICAgKiBUaHJvd3MgYW4gZXJyb3IgYmVjYXVzZSB0aGUgY3VycmVudCBtb2RlbCBjbGFzcyAoQmFydE1vZGVsKSBpcyBub3QgY29tcGF0aWJsZSB3aXRoIGAuZ2VuZXJhdGUoKWAuXG4gICAgICogXG4gICAgICogQHRocm93cyB7RXJyb3J9IFRoZSBjdXJyZW50IG1vZGVsIGNsYXNzIChCYXJ0TW9kZWwpIGlzIG5vdCBjb21wYXRpYmxlIHdpdGggYC5nZW5lcmF0ZSgpYC5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxhbnk+fVxuICAgICAqL1xuICAgIGFzeW5jIGdlbmVyYXRlKC4uLmFyZ3MpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICBcIlRoZSBjdXJyZW50IG1vZGVsIGNsYXNzIChCYXJ0TW9kZWwpIGlzIG5vdCBjb21wYXRpYmxlIHdpdGggYC5nZW5lcmF0ZSgpYCwgYXMgaXQgZG9lc24ndCBoYXZlIGEgbGFuZ3VhZ2UgbW9kZWwgaGVhZC4gUGxlYXNlIHVzZSBvbmUgb2YgdGhlIGZvbGxvd2luZyBjbGFzc2VzIGluc3RlYWQ6IHsnQmFydEZvckNvbmRpdGlvbmFsR2VuZXJhdGlvbid9XCJcbiAgICAgICAgKVxuICAgIH1cbn1cblxuLyoqXG4gKiBCQVJUIG1vZGVsIHdpdGggYSBsYW5ndWFnZSBtb2RlbCBoZWFkIGZvciBjb25kaXRpb25hbCBnZW5lcmF0aW9uLlxuICogQGV4dGVuZHMgQmFydFByZXRyYWluZWRNb2RlbFxuICovXG5leHBvcnQgY2xhc3MgQmFydEZvckNvbmRpdGlvbmFsR2VuZXJhdGlvbiBleHRlbmRzIEJhcnRQcmV0cmFpbmVkTW9kZWwge1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiB0aGUgYEJhcnRGb3JDb25kaXRpb25hbEdlbmVyYXRpb25gIGNsYXNzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgVGhlIGNvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciB0aGUgQmFydCBtb2RlbC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc2Vzc2lvbiBUaGUgT05OWCBzZXNzaW9uIHVzZWQgdG8gZXhlY3V0ZSB0aGUgbW9kZWwuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRlY29kZXJfbWVyZ2VkX3Nlc3Npb24gVGhlIE9OTlggc2Vzc2lvbiB1c2VkIHRvIGV4ZWN1dGUgdGhlIGRlY29kZXIuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGdlbmVyYXRpb25fY29uZmlnIFRoZSBnZW5lcmF0aW9uIGNvbmZpZ3VyYXRpb24gb2JqZWN0LlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZywgc2Vzc2lvbiwgZGVjb2Rlcl9tZXJnZWRfc2Vzc2lvbiwgZ2VuZXJhdGlvbl9jb25maWcpIHtcbiAgICAgICAgc3VwZXIoY29uZmlnLCBzZXNzaW9uKTtcbiAgICAgICAgdGhpcy5kZWNvZGVyX21lcmdlZF9zZXNzaW9uID0gZGVjb2Rlcl9tZXJnZWRfc2Vzc2lvbjtcbiAgICAgICAgdGhpcy5nZW5lcmF0aW9uX2NvbmZpZyA9IGdlbmVyYXRpb25fY29uZmlnO1xuXG4gICAgICAgIHRoaXMubnVtX2RlY29kZXJfbGF5ZXJzID0gdGhpcy5jb25maWcuZGVjb2Rlcl9sYXllcnM7XG4gICAgICAgIHRoaXMubnVtX2RlY29kZXJfaGVhZHMgPSB0aGlzLmNvbmZpZy5kZWNvZGVyX2F0dGVudGlvbl9oZWFkcztcbiAgICAgICAgdGhpcy5kZWNvZGVyX2RpbV9rdiA9IHRoaXMuY29uZmlnLmRfbW9kZWwgLyB0aGlzLm51bV9kZWNvZGVyX2hlYWRzO1xuXG4gICAgICAgIHRoaXMubnVtX2VuY29kZXJfbGF5ZXJzID0gdGhpcy5jb25maWcuZW5jb2Rlcl9sYXllcnM7XG4gICAgICAgIHRoaXMubnVtX2VuY29kZXJfaGVhZHMgPSB0aGlzLmNvbmZpZy5lbmNvZGVyX2F0dGVudGlvbl9oZWFkcztcbiAgICAgICAgdGhpcy5lbmNvZGVyX2RpbV9rdiA9IHRoaXMuY29uZmlnLmRfbW9kZWwgLyB0aGlzLm51bV9lbmNvZGVyX2hlYWRzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGluaXRpYWwgYmVhbSBmb3IgZ2VuZXJhdGluZyBvdXRwdXQgdGV4dC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXRzIFRoZSBpbnB1dCBvYmplY3QgY29udGFpbmluZyB0aGUgZW5jb2RlZCBpbnB1dCB0ZXh0LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBudW1PdXRwdXRUb2tlbnMgVGhlIG1heGltdW0gbnVtYmVyIG9mIG91dHB1dCB0b2tlbnMgdG8gZ2VuZXJhdGUuXG4gICAgICogQHBhcmFtICB7Li4uYW55fSBhcmdzIEFkZGl0aW9uYWwgYXJndW1lbnRzIHRvIHBhc3MgdG8gdGhlIHNlcXVlbmNlLXRvLXNlcXVlbmNlIGdlbmVyYXRpb24gZnVuY3Rpb24uXG4gICAgICogQHJldHVybnMge2FueX0gVGhlIGluaXRpYWwgYmVhbSBmb3IgZ2VuZXJhdGluZyBvdXRwdXQgdGV4dC5cbiAgICAgKi9cbiAgICBnZXRTdGFydEJlYW1zKGlucHV0cywgbnVtT3V0cHV0VG9rZW5zLCAuLi5hcmdzKSB7XG4gICAgICAgIHJldHVybiBzZXEyc2VxU3RhcnRCZWFtcyh0aGlzLCBpbnB1dHMsIG51bU91dHB1dFRva2Vucyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUnVucyBhIHNpbmdsZSBzdGVwIG9mIHRoZSBiZWFtIHNlYXJjaCBnZW5lcmF0aW9uIGFsZ29yaXRobS5cbiAgICAgKiBAcGFyYW0ge2FueX0gYmVhbSBUaGUgY3VycmVudCBiZWFtIGJlaW5nIGdlbmVyYXRlZC5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxhbnk+fSBUaGUgdXBkYXRlZCBiZWFtIGFmdGVyIGEgc2luZ2xlIGdlbmVyYXRpb24gc3RlcC5cbiAgICAgKi9cbiAgICBhc3luYyBydW5CZWFtKGJlYW0pIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHNlcTJzZXFSdW5CZWFtKHRoaXMsIGJlYW0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIGJlYW0gYnkgYXBwZW5kaW5nIHRoZSBuZXdseSBnZW5lcmF0ZWQgdG9rZW4gSUQgdG8gdGhlIGxpc3Qgb2Ygb3V0cHV0IHRva2VuIElEcy5cbiAgICAgKiBAcGFyYW0ge2FueX0gYmVhbSBUaGUgY3VycmVudCBiZWFtIGJlaW5nIGdlbmVyYXRlZC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbmV3VG9rZW5JZCBUaGUgSUQgb2YgdGhlIG5ld2x5IGdlbmVyYXRlZCB0b2tlbiB0byBhcHBlbmQgdG8gdGhlIGxpc3Qgb2Ygb3V0cHV0IHRva2VuIElEcy5cbiAgICAgKi9cbiAgICB1cGRhdGVCZWFtKGJlYW0sIG5ld1Rva2VuSWQpIHtcbiAgICAgICAgYmVhbS5vdXRwdXRfdG9rZW5faWRzID0gWy4uLmJlYW0ub3V0cHV0X3Rva2VuX2lkcywgbmV3VG9rZW5JZF07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUnVucyB0aGUgZm9yd2FyZCBwYXNzIG9mIHRoZSBtb2RlbCBmb3IgYSBnaXZlbiBzZXQgb2YgaW5wdXRzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtb2RlbF9pbnB1dHMgVGhlIG1vZGVsIGlucHV0cy5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fSBUaGUgbW9kZWwgb3V0cHV0LlxuICAgICAqL1xuICAgIGFzeW5jIGZvcndhcmQobW9kZWxfaW5wdXRzKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCBzZXEyc2VxRm9yd2FyZCh0aGlzLCBtb2RlbF9pbnB1dHMpO1xuICAgIH1cbn1cblxuZXhwb3J0IGNsYXNzIEJhcnRGb3JTZXF1ZW5jZUNsYXNzaWZpY2F0aW9uIGV4dGVuZHMgQmFydFByZXRyYWluZWRNb2RlbCB7XG4gICAgLyoqXG4gICAgICogQ2FsbHMgdGhlIG1vZGVsIG9uIG5ldyBpbnB1dHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbW9kZWxfaW5wdXRzIFRoZSBpbnB1dHMgdG8gdGhlIG1vZGVsLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFNlcXVlbmNlQ2xhc3NpZmllck91dHB1dD59IEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBtb2RlbCdzIG91dHB1dCBsb2dpdHMgZm9yIHNlcXVlbmNlIGNsYXNzaWZpY2F0aW9uLlxuICAgICAqL1xuICAgIGFzeW5jIF9jYWxsKG1vZGVsX2lucHV0cykge1xuICAgICAgICByZXR1cm4gbmV3IFNlcXVlbmNlQ2xhc3NpZmllck91dHB1dChhd2FpdCBzdXBlci5fY2FsbChtb2RlbF9pbnB1dHMpKTtcbiAgICB9XG59XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBSb2JlcnRhIG1vZGVsc1xuZXhwb3J0IGNsYXNzIFJvYmVydGFQcmVUcmFpbmVkTW9kZWwgZXh0ZW5kcyBQcmVUcmFpbmVkTW9kZWwgeyB9XG5leHBvcnQgY2xhc3MgUm9iZXJ0YU1vZGVsIGV4dGVuZHMgUm9iZXJ0YVByZVRyYWluZWRNb2RlbCB7IH1cblxuLyoqXG4gKiBSb2JlcnRhRm9yTWFza2VkTE0gY2xhc3MgZm9yIHBlcmZvcm1pbmcgbWFza2VkIGxhbmd1YWdlIG1vZGVsaW5nIG9uIFJvYmVydGEgbW9kZWxzLlxuICogQGV4dGVuZHMgUm9iZXJ0YVByZVRyYWluZWRNb2RlbFxuICovXG5leHBvcnQgY2xhc3MgUm9iZXJ0YUZvck1hc2tlZExNIGV4dGVuZHMgUm9iZXJ0YVByZVRyYWluZWRNb2RlbCB7XG4gICAgLyoqXG4gICAgICogQ2FsbHMgdGhlIG1vZGVsIG9uIG5ldyBpbnB1dHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbW9kZWxfaW5wdXRzIFRoZSBpbnB1dHMgdG8gdGhlIG1vZGVsLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPE1hc2tlZExNT3V0cHV0Pn0gcmV0dXJuZWQgb2JqZWN0XG4gICAgICovXG4gICAgYXN5bmMgX2NhbGwobW9kZWxfaW5wdXRzKSB7XG4gICAgICAgIHJldHVybiBuZXcgTWFza2VkTE1PdXRwdXQoYXdhaXQgc3VwZXIuX2NhbGwobW9kZWxfaW5wdXRzKSk7XG4gICAgfVxufVxuXG4vKipcbiAqIFJvYmVydGFGb3JTZXF1ZW5jZUNsYXNzaWZpY2F0aW9uIGNsYXNzIGZvciBwZXJmb3JtaW5nIHNlcXVlbmNlIGNsYXNzaWZpY2F0aW9uIG9uIFJvYmVydGEgbW9kZWxzLlxuICogQGV4dGVuZHMgUm9iZXJ0YVByZVRyYWluZWRNb2RlbFxuICovXG5leHBvcnQgY2xhc3MgUm9iZXJ0YUZvclNlcXVlbmNlQ2xhc3NpZmljYXRpb24gZXh0ZW5kcyBSb2JlcnRhUHJlVHJhaW5lZE1vZGVsIHtcbiAgICAvKipcbiAgICAgKiBDYWxscyB0aGUgbW9kZWwgb24gbmV3IGlucHV0cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtb2RlbF9pbnB1dHMgVGhlIGlucHV0cyB0byB0aGUgbW9kZWwuXG4gICAgICogQHJldHVybnMge1Byb21pc2U8U2VxdWVuY2VDbGFzc2lmaWVyT3V0cHV0Pn0gcmV0dXJuZWQgb2JqZWN0XG4gICAgICovXG4gICAgYXN5bmMgX2NhbGwobW9kZWxfaW5wdXRzKSB7XG4gICAgICAgIHJldHVybiBuZXcgU2VxdWVuY2VDbGFzc2lmaWVyT3V0cHV0KGF3YWl0IHN1cGVyLl9jYWxsKG1vZGVsX2lucHV0cykpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBSb2JlcnRhRm9yVG9rZW5DbGFzc2lmaWNhdGlvbiBjbGFzcyBmb3IgcGVyZm9ybWluZyB0b2tlbiBjbGFzc2lmaWNhdGlvbiBvbiBSb2JlcnRhIG1vZGVscy5cbiAqIEBleHRlbmRzIFJvYmVydGFQcmVUcmFpbmVkTW9kZWxcbiAqL1xuZXhwb3J0IGNsYXNzIFJvYmVydGFGb3JUb2tlbkNsYXNzaWZpY2F0aW9uIGV4dGVuZHMgUm9iZXJ0YVByZVRyYWluZWRNb2RlbCB7XG4gICAgLyoqXG4gICAgICogQ2FsbHMgdGhlIG1vZGVsIG9uIG5ldyBpbnB1dHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbW9kZWxfaW5wdXRzIFRoZSBpbnB1dHMgdG8gdGhlIG1vZGVsLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFRva2VuQ2xhc3NpZmllck91dHB1dD59IEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBtb2RlbCdzIG91dHB1dCBsb2dpdHMgZm9yIHRva2VuIGNsYXNzaWZpY2F0aW9uLlxuICAgICAqL1xuICAgIGFzeW5jIF9jYWxsKG1vZGVsX2lucHV0cykge1xuICAgICAgICByZXR1cm4gbmV3IFRva2VuQ2xhc3NpZmllck91dHB1dChhd2FpdCBzdXBlci5fY2FsbChtb2RlbF9pbnB1dHMpKTtcbiAgICB9XG59XG5cbi8qKlxuICogUm9iZXJ0YUZvclF1ZXN0aW9uQW5zd2VyaW5nIGNsYXNzIGZvciBwZXJmb3JtaW5nIHF1ZXN0aW9uIGFuc3dlcmluZyBvbiBSb2JlcnRhIG1vZGVscy5cbiAqIEBleHRlbmRzIFJvYmVydGFQcmVUcmFpbmVkTW9kZWxcbiAqL1xuZXhwb3J0IGNsYXNzIFJvYmVydGFGb3JRdWVzdGlvbkFuc3dlcmluZyBleHRlbmRzIFJvYmVydGFQcmVUcmFpbmVkTW9kZWwge1xuICAgIC8qKlxuICAgICAqIENhbGxzIHRoZSBtb2RlbCBvbiBuZXcgaW5wdXRzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1vZGVsX2lucHV0cyBUaGUgaW5wdXRzIHRvIHRoZSBtb2RlbC5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxRdWVzdGlvbkFuc3dlcmluZ01vZGVsT3V0cHV0Pn0gcmV0dXJuZWQgb2JqZWN0XG4gICAgICovXG4gICAgYXN5bmMgX2NhbGwobW9kZWxfaW5wdXRzKSB7XG4gICAgICAgIHJldHVybiBuZXcgUXVlc3Rpb25BbnN3ZXJpbmdNb2RlbE91dHB1dChhd2FpdCBzdXBlci5fY2FsbChtb2RlbF9pbnB1dHMpKTtcbiAgICB9XG59XG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gWExNUm9iZXJ0YSBtb2RlbHNcbmV4cG9ydCBjbGFzcyBYTE1Sb2JlcnRhUHJlVHJhaW5lZE1vZGVsIGV4dGVuZHMgUHJlVHJhaW5lZE1vZGVsIHsgfVxuZXhwb3J0IGNsYXNzIFhMTVJvYmVydGFNb2RlbCBleHRlbmRzIFhMTVJvYmVydGFQcmVUcmFpbmVkTW9kZWwgeyB9XG5cbi8qKlxuICogWExNUm9iZXJ0YUZvck1hc2tlZExNIGNsYXNzIGZvciBwZXJmb3JtaW5nIG1hc2tlZCBsYW5ndWFnZSBtb2RlbGluZyBvbiBYTE1Sb2JlcnRhIG1vZGVscy5cbiAqIEBleHRlbmRzIFhMTVJvYmVydGFQcmVUcmFpbmVkTW9kZWxcbiAqL1xuZXhwb3J0IGNsYXNzIFhMTVJvYmVydGFGb3JNYXNrZWRMTSBleHRlbmRzIFhMTVJvYmVydGFQcmVUcmFpbmVkTW9kZWwge1xuICAgIC8qKlxuICAgICAqIENhbGxzIHRoZSBtb2RlbCBvbiBuZXcgaW5wdXRzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1vZGVsX2lucHV0cyBUaGUgaW5wdXRzIHRvIHRoZSBtb2RlbC5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxNYXNrZWRMTU91dHB1dD59IHJldHVybmVkIG9iamVjdFxuICAgICAqL1xuICAgIGFzeW5jIF9jYWxsKG1vZGVsX2lucHV0cykge1xuICAgICAgICByZXR1cm4gbmV3IE1hc2tlZExNT3V0cHV0KGF3YWl0IHN1cGVyLl9jYWxsKG1vZGVsX2lucHV0cykpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBYTE1Sb2JlcnRhRm9yU2VxdWVuY2VDbGFzc2lmaWNhdGlvbiBjbGFzcyBmb3IgcGVyZm9ybWluZyBzZXF1ZW5jZSBjbGFzc2lmaWNhdGlvbiBvbiBYTE1Sb2JlcnRhIG1vZGVscy5cbiAqIEBleHRlbmRzIFhMTVJvYmVydGFQcmVUcmFpbmVkTW9kZWxcbiAqL1xuZXhwb3J0IGNsYXNzIFhMTVJvYmVydGFGb3JTZXF1ZW5jZUNsYXNzaWZpY2F0aW9uIGV4dGVuZHMgWExNUm9iZXJ0YVByZVRyYWluZWRNb2RlbCB7XG4gICAgLyoqXG4gICAgICogQ2FsbHMgdGhlIG1vZGVsIG9uIG5ldyBpbnB1dHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbW9kZWxfaW5wdXRzIFRoZSBpbnB1dHMgdG8gdGhlIG1vZGVsLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFNlcXVlbmNlQ2xhc3NpZmllck91dHB1dD59IHJldHVybmVkIG9iamVjdFxuICAgICAqL1xuICAgIGFzeW5jIF9jYWxsKG1vZGVsX2lucHV0cykge1xuICAgICAgICByZXR1cm4gbmV3IFNlcXVlbmNlQ2xhc3NpZmllck91dHB1dChhd2FpdCBzdXBlci5fY2FsbChtb2RlbF9pbnB1dHMpKTtcbiAgICB9XG59XG5cbi8qKlxuICogWExNUm9iZXJ0YUZvclRva2VuQ2xhc3NpZmljYXRpb24gY2xhc3MgZm9yIHBlcmZvcm1pbmcgdG9rZW4gY2xhc3NpZmljYXRpb24gb24gWExNUm9iZXJ0YSBtb2RlbHMuXG4gKiBAZXh0ZW5kcyBYTE1Sb2JlcnRhUHJlVHJhaW5lZE1vZGVsXG4gKi9cbmV4cG9ydCBjbGFzcyBYTE1Sb2JlcnRhRm9yVG9rZW5DbGFzc2lmaWNhdGlvbiBleHRlbmRzIFhMTVJvYmVydGFQcmVUcmFpbmVkTW9kZWwge1xuICAgIC8qKlxuICAgICAqIENhbGxzIHRoZSBtb2RlbCBvbiBuZXcgaW5wdXRzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1vZGVsX2lucHV0cyBUaGUgaW5wdXRzIHRvIHRoZSBtb2RlbC5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxUb2tlbkNsYXNzaWZpZXJPdXRwdXQ+fSBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgbW9kZWwncyBvdXRwdXQgbG9naXRzIGZvciB0b2tlbiBjbGFzc2lmaWNhdGlvbi5cbiAgICAgKi9cbiAgICBhc3luYyBfY2FsbChtb2RlbF9pbnB1dHMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUb2tlbkNsYXNzaWZpZXJPdXRwdXQoYXdhaXQgc3VwZXIuX2NhbGwobW9kZWxfaW5wdXRzKSk7XG4gICAgfVxufVxuXG4vKipcbiAqIFhMTVJvYmVydGFGb3JRdWVzdGlvbkFuc3dlcmluZyBjbGFzcyBmb3IgcGVyZm9ybWluZyBxdWVzdGlvbiBhbnN3ZXJpbmcgb24gWExNUm9iZXJ0YSBtb2RlbHMuXG4gKiBAZXh0ZW5kcyBYTE1Sb2JlcnRhUHJlVHJhaW5lZE1vZGVsXG4gKi9cbmV4cG9ydCBjbGFzcyBYTE1Sb2JlcnRhRm9yUXVlc3Rpb25BbnN3ZXJpbmcgZXh0ZW5kcyBYTE1Sb2JlcnRhUHJlVHJhaW5lZE1vZGVsIHtcbiAgICAvKipcbiAgICAgKiBDYWxscyB0aGUgbW9kZWwgb24gbmV3IGlucHV0cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtb2RlbF9pbnB1dHMgVGhlIGlucHV0cyB0byB0aGUgbW9kZWwuXG4gICAgICogQHJldHVybnMge1Byb21pc2U8UXVlc3Rpb25BbnN3ZXJpbmdNb2RlbE91dHB1dD59IHJldHVybmVkIG9iamVjdFxuICAgICAqL1xuICAgIGFzeW5jIF9jYWxsKG1vZGVsX2lucHV0cykge1xuICAgICAgICByZXR1cm4gbmV3IFF1ZXN0aW9uQW5zd2VyaW5nTW9kZWxPdXRwdXQoYXdhaXQgc3VwZXIuX2NhbGwobW9kZWxfaW5wdXRzKSk7XG4gICAgfVxufVxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFQ1IG1vZGVsc1xuZXhwb3J0IGNsYXNzIFdoaXNwZXJQcmVUcmFpbmVkTW9kZWwgZXh0ZW5kcyBQcmVUcmFpbmVkTW9kZWwgeyB9O1xuXG4vKipcbiAqIFdoaXNwZXJNb2RlbCBjbGFzcyBmb3IgdHJhaW5pbmcgV2hpc3BlciBtb2RlbHMgd2l0aG91dCBhIGxhbmd1YWdlIG1vZGVsIGhlYWQuXG4gKiBAZXh0ZW5kcyBXaGlzcGVyUHJlVHJhaW5lZE1vZGVsXG4gKi9cbmV4cG9ydCBjbGFzcyBXaGlzcGVyTW9kZWwgZXh0ZW5kcyBXaGlzcGVyUHJlVHJhaW5lZE1vZGVsIHtcbiAgICAvKipcbiAgICAgKiBUaHJvd3MgYW4gZXJyb3Igd2hlbiBhdHRlbXB0aW5nIHRvIGdlbmVyYXRlIG91dHB1dCBzaW5jZSB0aGlzIG1vZGVsIGRvZXNuJ3QgaGF2ZSBhIGxhbmd1YWdlIG1vZGVsIGhlYWQuXG4gICAgICogQHRocm93cyBFcnJvclxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPGFueT59XG4gICAgICogQHBhcmFtIHthbnlbXX0gYXJnc1xuICAgICAqL1xuICAgIGFzeW5jIGdlbmVyYXRlKC4uLmFyZ3MpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICBcIlRoZSBjdXJyZW50IG1vZGVsIGNsYXNzIChXaGlzcGVyTW9kZWwpIGlzIG5vdCBjb21wYXRpYmxlIHdpdGggYC5nZW5lcmF0ZSgpYCwgYXMgaXQgZG9lc24ndCBoYXZlIGEgbGFuZ3VhZ2UgbW9kZWwgaGVhZC4gUGxlYXNlIHVzZSBvbmUgb2YgdGhlIGZvbGxvd2luZyBjbGFzc2VzIGluc3RlYWQ6IHsnV2hpc3BlckZvckNvbmRpdGlvbmFsR2VuZXJhdGlvbid9XCJcbiAgICAgICAgKVxuICAgIH1cbn1cblxuLyoqXG4gKiBXaGlzcGVyRm9yQ29uZGl0aW9uYWxHZW5lcmF0aW9uIGNsYXNzIGZvciBnZW5lcmF0aW5nIGNvbmRpdGlvbmFsIG91dHB1dHMgZnJvbSBXaGlzcGVyIG1vZGVscy5cbiAqIEBleHRlbmRzIFdoaXNwZXJQcmVUcmFpbmVkTW9kZWxcbiAqL1xuZXhwb3J0IGNsYXNzIFdoaXNwZXJGb3JDb25kaXRpb25hbEdlbmVyYXRpb24gZXh0ZW5kcyBXaGlzcGVyUHJlVHJhaW5lZE1vZGVsIHtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgdGhlIGBXaGlzcGVyRm9yQ29uZGl0aW9uYWxHZW5lcmF0aW9uYCBjbGFzcy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIENvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciB0aGUgbW9kZWwuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNlc3Npb24gT05OWCBTZXNzaW9uIG9iamVjdCBmb3IgdGhlIG1vZGVsLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkZWNvZGVyX21lcmdlZF9zZXNzaW9uIE9OTlggU2Vzc2lvbiBvYmplY3QgZm9yIHRoZSBkZWNvZGVyLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBnZW5lcmF0aW9uX2NvbmZpZyBDb25maWd1cmF0aW9uIG9iamVjdCBmb3IgdGhlIGdlbmVyYXRpb24gcHJvY2Vzcy5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihjb25maWcsIHNlc3Npb24sIGRlY29kZXJfbWVyZ2VkX3Nlc3Npb24sIGdlbmVyYXRpb25fY29uZmlnKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZywgc2Vzc2lvbik7XG4gICAgICAgIHRoaXMuZGVjb2Rlcl9tZXJnZWRfc2Vzc2lvbiA9IGRlY29kZXJfbWVyZ2VkX3Nlc3Npb247XG4gICAgICAgIHRoaXMuZ2VuZXJhdGlvbl9jb25maWcgPSBnZW5lcmF0aW9uX2NvbmZpZztcblxuICAgICAgICB0aGlzLm51bV9kZWNvZGVyX2xheWVycyA9IHRoaXMuY29uZmlnLmRlY29kZXJfbGF5ZXJzO1xuICAgICAgICB0aGlzLm51bV9kZWNvZGVyX2hlYWRzID0gdGhpcy5jb25maWcuZGVjb2Rlcl9hdHRlbnRpb25faGVhZHM7XG4gICAgICAgIHRoaXMuZGVjb2Rlcl9kaW1fa3YgPSB0aGlzLmNvbmZpZy5kX21vZGVsIC8gdGhpcy5udW1fZGVjb2Rlcl9oZWFkcztcblxuICAgICAgICB0aGlzLm51bV9lbmNvZGVyX2xheWVycyA9IHRoaXMuY29uZmlnLmVuY29kZXJfbGF5ZXJzO1xuICAgICAgICB0aGlzLm51bV9lbmNvZGVyX2hlYWRzID0gdGhpcy5jb25maWcuZW5jb2Rlcl9hdHRlbnRpb25faGVhZHM7XG4gICAgICAgIHRoaXMuZW5jb2Rlcl9kaW1fa3YgPSB0aGlzLmNvbmZpZy5kX21vZGVsIC8gdGhpcy5udW1fZW5jb2Rlcl9oZWFkcztcblxuXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIG91dHB1dHMgYmFzZWQgb24gaW5wdXQgYW5kIGdlbmVyYXRpb24gY29uZmlndXJhdGlvbi5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXRzIElucHV0IGRhdGEgZm9yIHRoZSBtb2RlbC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZ2VuZXJhdGlvbl9jb25maWcgQ29uZmlndXJhdGlvbiBvYmplY3QgZm9yIHRoZSBnZW5lcmF0aW9uIHByb2Nlc3MuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGxvZ2l0c19wcm9jZXNzb3IgT3B0aW9uYWwgbG9naXRzIHByb2Nlc3NvciBvYmplY3QuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5yZXR1cm5fdGltZXN0YW1wcz1udWxsXSBXaGV0aGVyIHRvIHJldHVybiB0aGUgdGltZXN0YW1wcyB3aXRoIHRoZSB0ZXh0LiBUaGlzIGVuYWJsZXMgdGhlIGBXaGlzcGVyVGltZXN0YW1wc0xvZ2l0c1Byb2Nlc3NvcmAuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLnJldHVybl90b2tlbl90aW1lc3RhbXBzPW51bGxdIFdoZXRoZXIgdG8gcmV0dXJuIHRva2VuLWxldmVsIHRpbWVzdGFtcHNcbiAgICAgKiB3aXRoIHRoZSB0ZXh0LiBUaGlzIGNhbiBiZSB1c2VkIHdpdGggb3Igd2l0aG91dCB0aGUgYHJldHVybl90aW1lc3RhbXBzYCBvcHRpb24uIFRvIGdldCB3b3JkLWxldmVsXG4gICAgICogdGltZXN0YW1wcywgdXNlIHRoZSB0b2tlbml6ZXIgdG8gZ3JvdXAgdGhlIHRva2VucyBpbnRvIHdvcmRzLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD59IFByb21pc2Ugb2JqZWN0IHJlcHJlc2VudHMgdGhlIGdlbmVyYXRlZCBvdXRwdXRzLlxuICAgICAqL1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBhc3luYyBnZW5lcmF0ZShcbiAgICAgICAgaW5wdXRzLFxuICAgICAgICBnZW5lcmF0aW9uX2NvbmZpZyA9IG51bGwsXG4gICAgICAgIGxvZ2l0c19wcm9jZXNzb3IgPSBudWxsLFxuICAgICAgICAvLyB7XG4gICAgICAgIC8vICAgICByZXR1cm5fdGltZXN0YW1wcyA9IG51bGwsXG4gICAgICAgIC8vICAgICByZXR1cm5fdG9rZW5fdGltZXN0YW1wcyA9IG51bGwsXG4gICAgICAgIC8vICAgICBsYW5ndWFnZSA9IG51bGwsXG4gICAgICAgIC8vICAgICB0YXNrID0gbnVsbCxcbiAgICAgICAgLy8gfSA9IHt9LFxuICAgICkge1xuICAgICAgICAvLyBDcmVhdGUgZ2VuZXJhdGlvbiBjb25maWcgb2JqZWN0XG4gICAgICAgIGdlbmVyYXRpb25fY29uZmlnID0gdGhpcy5fZ2V0X2dlbmVyYXRpb25fY29uZmlnKGdlbmVyYXRpb25fY29uZmlnKTtcblxuXG4gICAgICAgIC8vIFdoaXNwZXIgaGFzIGFkZGl0aW9uYWwgb3B0aW9ucyBmb3IgcmV0dXJuaW5nIHRpbWVzdGFtcHNcbiAgICAgICAgZ2VuZXJhdGlvbl9jb25maWcucmV0dXJuX3RpbWVzdGFtcHMgPz89IGZhbHNlO1xuXG4gICAgICAgIC8vIFRPRE8gYWRkIGxhbmd1YWdlIGFuZCB0YXNrXG5cbiAgICAgICAgaWYgKGdlbmVyYXRpb25fY29uZmlnLnJldHVybl90aW1lc3RhbXBzKSB7XG4gICAgICAgICAgICBsb2dpdHNfcHJvY2Vzc29yID0gW25ldyBXaGlzcGVyVGltZVN0YW1wTG9naXRzUHJvY2Vzc29yKGdlbmVyYXRpb25fY29uZmlnKV1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChnZW5lcmF0aW9uX2NvbmZpZy5yZXR1cm5fdG9rZW5fdGltZXN0YW1wcykge1xuICAgICAgICAgICAgZ2VuZXJhdGlvbl9jb25maWcub3V0cHV0X2F0dGVudGlvbnMgPSB0cnVlO1xuICAgICAgICAgICAgZ2VuZXJhdGlvbl9jb25maWcucmV0dXJuX2RpY3RfaW5fZ2VuZXJhdGUgPSB0cnVlO1xuXG4gICAgICAgICAgICBpZiAoZ2VuZXJhdGlvbl9jb25maWcudGFzayA9PT0gJ3RyYW5zbGF0ZScpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJUb2tlbi1sZXZlbCB0aW1lc3RhbXBzIG1heSBub3QgYmUgcmVsaWFibGUgZm9yIHRhc2sgJ3RyYW5zbGF0ZScuXCIpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghZ2VuZXJhdGlvbl9jb25maWcuYWxpZ25tZW50X2hlYWRzKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgICAgICBcIk1vZGVsIGdlbmVyYXRpb24gY29uZmlnIGhhcyBubyBgYWxpZ25tZW50X2hlYWRzYCwgdG9rZW4tbGV2ZWwgdGltZXN0YW1wcyBub3QgYXZhaWxhYmxlLiBcIiArXG4gICAgICAgICAgICAgICAgICAgIFwiU2VlIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL2hvbGxhbmNlLzQyZTMyODUyZjI0MjQzYjc0OGFlNmJjMWY5ODViMTNhIG9uIGhvdyB0byBhZGQgdGhpcyBwcm9wZXJ0eSB0byB0aGUgZ2VuZXJhdGlvbiBjb25maWcuXCJcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBvdXRwdXRzID0gYXdhaXQgc3VwZXIuZ2VuZXJhdGUoaW5wdXRzLCBnZW5lcmF0aW9uX2NvbmZpZywgbG9naXRzX3Byb2Nlc3Nvcik7XG5cbiAgICAgICAgaWYgKGdlbmVyYXRpb25fY29uZmlnLnJldHVybl90b2tlbl90aW1lc3RhbXBzICYmIGdlbmVyYXRpb25fY29uZmlnLmFsaWdubWVudF9oZWFkcykge1xuICAgICAgICAgICAgb3V0cHV0c1tcInRva2VuX3RpbWVzdGFtcHNcIl0gPSB0aGlzLl9leHRyYWN0X3Rva2VuX3RpbWVzdGFtcHMob3V0cHV0cywgZ2VuZXJhdGlvbl9jb25maWcuYWxpZ25tZW50X2hlYWRzKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG91dHB1dHNcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBzdGFydCBiZWFtcyBmb3IgZ2VuZXJhdGluZyBvdXRwdXRzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGlucHV0VG9rZW5JZHMgQXJyYXkgb2YgaW5wdXQgdG9rZW4gSURzLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBudW1PdXRwdXRUb2tlbnMgTnVtYmVyIG9mIG91dHB1dCB0b2tlbnMgdG8gZ2VuZXJhdGUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBBcnJheSBvZiBzdGFydCBiZWFtcy5cbiAgICAgKi9cbiAgICBnZXRTdGFydEJlYW1zKGlucHV0VG9rZW5JZHMsIG51bU91dHB1dFRva2VucywgLi4uYXJncykge1xuICAgICAgICAvLyBhcmd1bWVudHMgaWdub3JlZCBpbiB0aGlzIGNhc2VcbiAgICAgICAgcmV0dXJuIHNlcTJzZXFTdGFydEJlYW1zKHRoaXMsIGlucHV0VG9rZW5JZHMsIG51bU91dHB1dFRva2VucywgZmFsc2UpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJ1bnMgYSBzaW5nbGUgc3RlcCBvZiB0aGUgYmVhbSBzZWFyY2ggZ2VuZXJhdGlvbiBhbGdvcml0aG0uXG4gICAgICogQHBhcmFtIHthbnl9IGJlYW0gVGhlIGN1cnJlbnQgYmVhbSBiZWluZyBnZW5lcmF0ZWQuXG4gICAgICogQHJldHVybnMge1Byb21pc2U8YW55Pn0gVGhlIHVwZGF0ZWQgYmVhbSBhZnRlciBhIHNpbmdsZSBnZW5lcmF0aW9uIHN0ZXAuXG4gICAgICovXG4gICAgYXN5bmMgcnVuQmVhbShiZWFtKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCBzZXEyc2VxUnVuQmVhbSh0aGlzLCBiZWFtLCB7XG4gICAgICAgICAgICBpbnB1dF9uYW1lOiAnaW5wdXRfZmVhdHVyZXMnLFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSBiZWFtIGJ5IGFwcGVuZGluZyB0aGUgbmV3bHkgZ2VuZXJhdGVkIHRva2VuIElEIHRvIHRoZSBsaXN0IG9mIG91dHB1dCB0b2tlbiBJRHMuXG4gICAgICogQHBhcmFtIHthbnl9IGJlYW0gVGhlIGN1cnJlbnQgYmVhbSBiZWluZyBnZW5lcmF0ZWQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG5ld1Rva2VuSWQgVGhlIElEIG9mIHRoZSBuZXdseSBnZW5lcmF0ZWQgdG9rZW4gdG8gYXBwZW5kIHRvIHRoZSBsaXN0IG9mIG91dHB1dCB0b2tlbiBJRHMuXG4gICAgICovXG4gICAgdXBkYXRlQmVhbShiZWFtLCBuZXdUb2tlbklkKSB7XG4gICAgICAgIGJlYW0ub3V0cHV0X3Rva2VuX2lkcyA9IFsuLi5iZWFtLm91dHB1dF90b2tlbl9pZHMsIG5ld1Rva2VuSWRdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJ1bnMgdGhlIGZvcndhcmQgcGFzcyBvZiB0aGUgbW9kZWwgZm9yIGEgZ2l2ZW4gc2V0IG9mIGlucHV0cy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbW9kZWxfaW5wdXRzIFRoZSBtb2RlbCBpbnB1dHMuXG4gICAgICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0Pn0gVGhlIG1vZGVsIG91dHB1dC5cbiAgICAgKi9cbiAgICBhc3luYyBmb3J3YXJkKG1vZGVsX2lucHV0cykge1xuICAgICAgICByZXR1cm4gYXdhaXQgc2VxMnNlcUZvcndhcmQodGhpcywgbW9kZWxfaW5wdXRzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGVzIHRva2VuLWxldmVsIHRpbWVzdGFtcHMgdXNpbmcgdGhlIGVuY29kZXItZGVjb2RlciBjcm9zcy1hdHRlbnRpb25zIGFuZFxuICAgICAqIGR5bmFtaWMgdGltZS13YXJwaW5nIChEVFcpIHRvIG1hcCBlYWNoIG91dHB1dCB0b2tlbiB0byBhIHBvc2l0aW9uIGluIHRoZSBpbnB1dCBhdWRpby5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZ2VuZXJhdGVfb3V0cHV0cyBPdXRwdXRzIGdlbmVyYXRlZCBieSB0aGUgbW9kZWxcbiAgICAgKiBAcGFyYW0ge1RlbnNvcltdW11bXX0gZ2VuZXJhdGVfb3V0cHV0cy5jcm9zc19hdHRlbnRpb25zIFRoZSBjcm9zcyBhdHRlbnRpb25zIG91dHB1dCBieSB0aGUgbW9kZWxcbiAgICAgKiBAcGFyYW0ge1RlbnNvcltdW11bXX0gZ2VuZXJhdGVfb3V0cHV0cy5kZWNvZGVyX2F0dGVudGlvbnMgVGhlIGRlY29kZXIgYXR0ZW50aW9ucyBvdXRwdXQgYnkgdGhlIG1vZGVsXG4gICAgICogQHBhcmFtIHtudW1iZXJbXVtdfSBnZW5lcmF0ZV9vdXRwdXRzLnNlcXVlbmNlcyBUaGUgc2VxdWVuY2VzIG91dHB1dCBieSB0aGUgbW9kZWxcbiAgICAgKiBAcGFyYW0ge251bWJlcltdW119IGFsaWdubWVudF9oZWFkcyBBbGlnbm1lbnQgaGVhZHMgb2YgdGhlIG1vZGVsXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRpbWVfcHJlY2lzaW9uIFByZWNpc2lvbiBvZiB0aGUgdGltZXN0YW1wcyBpbiBzZWNvbmRzXG4gICAgICogQHJldHVybnMge1RlbnNvcn0gdGVuc29yIGNvbnRhaW5pbmcgdGhlIHRpbWVzdGFtcHMgaW4gc2Vjb25kcyBmb3IgZWFjaCBwcmVkaWN0ZWQgdG9rZW5cbiAgICAgKi9cbiAgICBfZXh0cmFjdF90b2tlbl90aW1lc3RhbXBzKGdlbmVyYXRlX291dHB1dHMsIGFsaWdubWVudF9oZWFkcywgdGltZV9wcmVjaXNpb24gPSAwLjAyKSB7XG4gICAgICAgIGlmICghZ2VuZXJhdGVfb3V0cHV0cy5jcm9zc19hdHRlbnRpb25zKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgXCJNb2RlbCBvdXRwdXRzIG11c3QgY29udGFpbiBjcm9zcyBhdHRlbnRpb25zIHRvIGV4dHJhY3QgdGltZXN0YW1wcy4gXCIgK1xuICAgICAgICAgICAgICAgIFwiVGhpcyBpcyBtb3N0IGxpa2VseSBiZWNhdXNlIHRoZSBtb2RlbCB3YXMgbm90IGV4cG9ydGVkIHdpdGggYG91dHB1dF9hdHRlbnRpb25zPVRydWVgLlwiXG4gICAgICAgICAgICApXG4gICAgICAgIH1cblxuICAgICAgICBsZXQgbWVkaWFuX2ZpbHRlcl93aWR0aCA9IHRoaXMuY29uZmlnLm1lZGlhbl9maWx0ZXJfd2lkdGg7XG4gICAgICAgIGlmIChtZWRpYW5fZmlsdGVyX3dpZHRoID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIk1vZGVsIGNvbmZpZyBoYXMgbm8gYG1lZGlhbl9maWx0ZXJfd2lkdGhgLCB1c2luZyBkZWZhdWx0IHZhbHVlIG9mIDcuXCIpXG4gICAgICAgICAgICBtZWRpYW5fZmlsdGVyX3dpZHRoID0gNztcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGJhdGNoZWRNYXRyaWNlcyA9IGdlbmVyYXRlX291dHB1dHMuY3Jvc3NfYXR0ZW50aW9ucy5tYXAoYmF0Y2ggPT4ge1xuICAgICAgICAgICAgLy8gQ3JlYXRlIGEgbGlzdCB3aXRoIGBkZWNvZGVyX2xheWVyc2AgZWxlbWVudHMsIGVhY2ggYSB0ZW5zb3Igb2Ygc2hhcGVcbiAgICAgICAgICAgIC8vIChiYXRjaCBzaXplLCBhdHRlbnRpb25faGVhZHMsIG91dHB1dCBsZW5ndGgsIGlucHV0IGxlbmd0aCkuXG4gICAgICAgICAgICBsZXQgY3Jvc3NfYXR0ZW50aW9ucyA9IEFycmF5LmZyb20oeyBsZW5ndGg6IHRoaXMuY29uZmlnLmRlY29kZXJfbGF5ZXJzIH0sXG4gICAgICAgICAgICAgICAgKF8sIGkpID0+IGNhdChiYXRjaC5tYXAoeCA9PiB4W2ldKSwgMilcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGxldCB3ZWlnaHRzID0gc3RhY2soYWxpZ25tZW50X2hlYWRzLm1hcCgoW2wsIGhdKSA9PiBjcm9zc19hdHRlbnRpb25zW2xdLnNsaWNlKG51bGwsIGgpKSk7XG4gICAgICAgICAgICB3ZWlnaHRzID0gd2VpZ2h0cy50cmFuc3Bvc2UoMSwgMCwgMiwgMylcblxuICAgICAgICAgICAgbGV0IFtzdGQsIGNhbGN1bGF0ZWRNZWFuXSA9IHN0ZF9tZWFuKHdlaWdodHMsIC0yLCAwLCB0cnVlKTtcblxuICAgICAgICAgICAgLy8gTm9ybWFsaXplIGFuZCBzbW9vdGhlbiB0aGUgd2VpZ2h0cy5cbiAgICAgICAgICAgIGxldCBzbW9vdGhlZFdlaWdodHMgPSB3ZWlnaHRzLmNsb25lKCk7IC8vIFsxLCA4LCBzZXFMZW5ndGgsIDE1MDBdXG5cbiAgICAgICAgICAgIGZvciAobGV0IGEgPSAwOyBhIDwgc21vb3RoZWRXZWlnaHRzLmRpbXNbMF07ICsrYSkge1xuICAgICAgICAgICAgICAgIGxldCBhVGVuc29yID0gc21vb3RoZWRXZWlnaHRzW2FdOyAvLyBbOCwgc2VxTGVuZ3RoLCAxNTAwXVxuXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgYiA9IDA7IGIgPCBhVGVuc29yLmRpbXNbMF07ICsrYikge1xuICAgICAgICAgICAgICAgICAgICBsZXQgYlRlbnNvciA9IGFUZW5zb3JbYl07IC8vIFtzZXFMZW5ndGgsIDE1MDBdXG5cbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3RkVGVuc29yID0gc3RkW2FdW2JdWzBdOyAvLyBbMTUwMF1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbWVhblRlbnNvciA9IGNhbGN1bGF0ZWRNZWFuW2FdW2JdWzBdOyAvLyBbMTUwMF1cblxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBjID0gMDsgYyA8IGJUZW5zb3IuZGltc1swXTsgKytjKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjVGVuc29yID0gYlRlbnNvcltjXTsgLy8gWzE1MDBdXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBkID0gMDsgZCA8IGNUZW5zb3IuZGF0YS5sZW5ndGg7ICsrZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNUZW5zb3IuZGF0YVtkXSA9IChjVGVuc29yLmRhdGFbZF0gLSBtZWFuVGVuc29yLmRhdGFbZF0pIC8gc3RkVGVuc29yLmRhdGFbZF1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQXBwbHkgbWVkaWFuIGZpbHRlci5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNUZW5zb3IuZGF0YS5zZXQobWVkaWFuRmlsdGVyKGNUZW5zb3IuZGF0YSwgbWVkaWFuX2ZpbHRlcl93aWR0aCkpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEF2ZXJhZ2UgdGhlIGRpZmZlcmVudCBjcm9zcy1hdHRlbnRpb24gaGVhZHMuXG4gICAgICAgICAgICBjb25zdCBtYXRyaXggPSBtZWFuKHNtb290aGVkV2VpZ2h0cywgMSk7XG4gICAgICAgICAgICByZXR1cm4gbWF0cml4O1xuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCB0aW1lc3RhbXBzU2hhcGUgPSBbZ2VuZXJhdGVfb3V0cHV0cy5zZXF1ZW5jZXMubGVuZ3RoLCBnZW5lcmF0ZV9vdXRwdXRzLnNlcXVlbmNlc1swXS5sZW5ndGhdO1xuXG4gICAgICAgIGNvbnN0IHRpbWVzdGFtcHMgPSBuZXcgVGVuc29yKFxuICAgICAgICAgICAgJ2Zsb2F0MzInLFxuICAgICAgICAgICAgbmV3IEZsb2F0MzJBcnJheSh0aW1lc3RhbXBzU2hhcGVbMF0gKiB0aW1lc3RhbXBzU2hhcGVbMV0pLFxuICAgICAgICAgICAgdGltZXN0YW1wc1NoYXBlXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gUGVyZm9ybSBkeW5hbWljIHRpbWUgd2FycGluZyBvbiBlYWNoIGVsZW1lbnQgb2YgdGhlIGJhdGNoLlxuICAgICAgICBmb3IgKGxldCBiYXRjaF9pZHggPSAwOyBiYXRjaF9pZHggPCB0aW1lc3RhbXBzU2hhcGVbMF07ICsrYmF0Y2hfaWR4KSB7XG4gICAgICAgICAgICAvLyBOT1RFOiBTaW5jZSB3ZSBydW4gb25seSBvbmUgYmF0Y2ggYXQgYSB0aW1lLCB3ZSBjYW4gc3F1ZWV6ZSB0byBnZXQgdGhlIHNhbWUgZGltZW5zaW9uc1xuICAgICAgICAgICAgLy8gYXMgdGhlIHB5dGhvbiBpbXBsZW1lbnRhdGlvblxuICAgICAgICAgICAgY29uc3QgbWF0cml4ID0gYmF0Y2hlZE1hdHJpY2VzW2JhdGNoX2lkeF0ubmVnKCkuc3F1ZWV6ZV8oMCk7XG4gICAgICAgICAgICBsZXQgW3RleHRfaW5kaWNlcywgdGltZV9pbmRpY2VzXSA9IGR5bmFtaWNUaW1lV2FycGluZyhtYXRyaXgpO1xuXG4gICAgICAgICAgICBsZXQgZGlmZnMgPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiB0ZXh0X2luZGljZXMubGVuZ3RoIC0gMSB9LCAodiwgaSkgPT4gdGV4dF9pbmRpY2VzW2kgKyAxXSAtIHRleHRfaW5kaWNlc1tpXSk7XG4gICAgICAgICAgICBsZXQganVtcHMgPSBtZXJnZUFycmF5cyhbMV0sIGRpZmZzKS5tYXAoeCA9PiAhIXgpOyAvLyBjb252ZXJ0IHRvIGJvb2xlYW5cblxuICAgICAgICAgICAgbGV0IGp1bXBfdGltZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwganVtcHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBpZiAoanVtcHNbaV0pIHtcbiAgICAgICAgICAgICAgICAgICAganVtcF90aW1lcy5wdXNoKHRpbWVfaW5kaWNlc1tpXSAqIHRpbWVfcHJlY2lzaW9uKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gTk9URTogTm8gcG9pbnQgaW4gcm91bmRpbmcgaGVyZSwgc2luY2Ugd2Ugc2V0IHRvIEZsb2F0MzJBcnJheSBsYXRlclxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRpbWVzdGFtcHNbYmF0Y2hfaWR4XS5kYXRhLnNldChqdW1wX3RpbWVzLCAxKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRpbWVzdGFtcHM7XG4gICAgfVxufVxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8qKlxuICogVmlzaW9uIEVuY29kZXItRGVjb2RlciBtb2RlbCBiYXNlZCBvbiBPcGVuQUkncyBHUFQgYXJjaGl0ZWN0dXJlIGZvciBpbWFnZSBjYXB0aW9uaW5nIGFuZCBvdGhlciB2aXNpb24gdGFza3NcbiAqIEBleHRlbmRzIFByZVRyYWluZWRNb2RlbFxuICovXG5leHBvcnQgY2xhc3MgVmlzaW9uRW5jb2RlckRlY29kZXJNb2RlbCBleHRlbmRzIFByZVRyYWluZWRNb2RlbCB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiB0aGUgYFZpc2lvbkVuY29kZXJEZWNvZGVyTW9kZWxgIGNsYXNzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgVGhlIGNvbmZpZ3VyYXRpb24gb2JqZWN0IHNwZWNpZnlpbmcgdGhlIGh5cGVycGFyYW1ldGVycyBhbmQgb3RoZXIgbW9kZWwgc2V0dGluZ3MuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNlc3Npb24gVGhlIE9OTlggc2Vzc2lvbiBjb250YWluaW5nIHRoZSBlbmNvZGVyIG1vZGVsLlxuICAgICAqIEBwYXJhbSB7YW55fSBkZWNvZGVyX21lcmdlZF9zZXNzaW9uIFRoZSBPTk5YIHNlc3Npb24gY29udGFpbmluZyB0aGUgbWVyZ2VkIGRlY29kZXIgbW9kZWwuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY29uZmlnLCBzZXNzaW9uLCBkZWNvZGVyX21lcmdlZF9zZXNzaW9uKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZywgc2Vzc2lvbik7XG4gICAgICAgIHRoaXMuZGVjb2Rlcl9tZXJnZWRfc2Vzc2lvbiA9IGRlY29kZXJfbWVyZ2VkX3Nlc3Npb247XG5cbiAgICAgICAgdGhpcy5udW1fbGF5ZXJzID0gdGhpcy5jb25maWcuZGVjb2Rlci5uX2xheWVyO1xuICAgICAgICB0aGlzLm51bV9oZWFkcyA9IHRoaXMuY29uZmlnLmRlY29kZXIubl9oZWFkO1xuICAgICAgICB0aGlzLmRpbV9rdiA9IHRoaXMuY29uZmlnLmRlY29kZXIubl9lbWJkIC8gdGhpcy5udW1faGVhZHM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2VuZXJhdGUgYmVhbSBzZWFyY2ggb3V0cHV0cyBmb3IgdGhlIGdpdmVuIGlucHV0IHBpeGVscyBhbmQgbnVtYmVyIG9mIG91dHB1dCB0b2tlbnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2FycmF5fSBpbnB1dHMgVGhlIGlucHV0IHBpeGVscyBhcyBhIFRlbnNvci5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbnVtT3V0cHV0VG9rZW5zIFRoZSBudW1iZXIgb2Ygb3V0cHV0IHRva2VucyB0byBnZW5lcmF0ZS5cbiAgICAgKiBAcGFyYW0gey4uLip9IGFyZ3MgT3B0aW9uYWwgYWRkaXRpb25hbCBhcmd1bWVudHMgdG8gcGFzcyB0byBzZXEyc2VxU3RhcnRCZWFtcy5cbiAgICAgKiBAcmV0dXJucyB7YW55fSBBbiBhcnJheSBvZiBCZWFtIG9iamVjdHMgcmVwcmVzZW50aW5nIHRoZSB0b3AtSyBvdXRwdXQgc2VxdWVuY2VzLlxuICAgICAqL1xuICAgIGdldFN0YXJ0QmVhbXMoaW5wdXRzLCBudW1PdXRwdXRUb2tlbnMsIC4uLmFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIHNlcTJzZXFTdGFydEJlYW1zKHRoaXMsIGlucHV0cywgbnVtT3V0cHV0VG9rZW5zKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSdW5zIGEgc2luZ2xlIHN0ZXAgb2YgdGhlIGJlYW0gc2VhcmNoIGdlbmVyYXRpb24gYWxnb3JpdGhtLlxuICAgICAqIEBwYXJhbSB7YW55fSBiZWFtIFRoZSBjdXJyZW50IGJlYW0gYmVpbmcgZ2VuZXJhdGVkLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPGFueT59IFRoZSB1cGRhdGVkIGJlYW0gYWZ0ZXIgYSBzaW5nbGUgZ2VuZXJhdGlvbiBzdGVwLlxuICAgICAqL1xuICAgIGFzeW5jIHJ1bkJlYW0oYmVhbSkge1xuICAgICAgICByZXR1cm4gc2VxMnNlcVJ1bkJlYW0odGhpcywgYmVhbSwge1xuICAgICAgICAgICAgaW5wdXRfbmFtZTogJ3BpeGVsX3ZhbHVlcycsXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSB0aGUgZ2l2ZW4gYmVhbSB3aXRoIHRoZSBhZGRpdGlvbmFsIHByZWRpY3RlZCB0b2tlbiBJRC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7YW55fSBiZWFtIFRoZSBjdXJyZW50IGJlYW0uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG5ld1Rva2VuSWQgVGhlIG5ldyBwcmVkaWN0ZWQgdG9rZW4gSUQgdG8gYWRkIHRvIHRoZSBiZWFtJ3Mgb3V0cHV0IHNlcXVlbmNlLlxuICAgICAqL1xuICAgIHVwZGF0ZUJlYW0oYmVhbSwgbmV3VG9rZW5JZCkge1xuICAgICAgICBiZWFtLm91dHB1dF90b2tlbl9pZHMgPSBbLi4uYmVhbS5vdXRwdXRfdG9rZW5faWRzLCBuZXdUb2tlbklkXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb21wdXRlIHRoZSBmb3J3YXJkIHBhc3Mgb2YgdGhlIG1vZGVsIG9uIHRoZSBnaXZlbiBpbnB1dCB0ZW5zb3JzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1vZGVsX2lucHV0cyBUaGUgaW5wdXQgdGVuc29ycyBhcyBhbiBvYmplY3Qgd2l0aCBrZXlzICdwaXhlbF92YWx1ZXMnIGFuZCAnZGVjb2Rlcl9pbnB1dF9pZHMnLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPGFueT59IFRoZSBvdXRwdXQgdGVuc29yIG9mIHRoZSBtb2RlbC5cbiAgICAgKi9cbiAgICBhc3luYyBmb3J3YXJkKG1vZGVsX2lucHV0cykge1xuICAgICAgICByZXR1cm4gYXdhaXQgc2VxMnNlcUZvcndhcmQodGhpcywgbW9kZWxfaW5wdXRzLCB7XG4gICAgICAgICAgICBhZGRfZGVjb2Rlcl9wa3Y6IGZhbHNlXG4gICAgICAgIH0pXG4gICAgfVxufVxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIENMSVAgbW9kZWxzXG5leHBvcnQgY2xhc3MgQ0xJUFByZVRyYWluZWRNb2RlbCBleHRlbmRzIFByZVRyYWluZWRNb2RlbCB7IH1cbmV4cG9ydCBjbGFzcyBDTElQTW9kZWwgZXh0ZW5kcyBDTElQUHJlVHJhaW5lZE1vZGVsIHtcblxufVxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gR1BUMiBtb2RlbHNcbmV4cG9ydCBjbGFzcyBHUFQyUHJlVHJhaW5lZE1vZGVsIGV4dGVuZHMgUHJlVHJhaW5lZE1vZGVsIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIHRoZSBgR1BUMlByZVRyYWluZWRNb2RlbGAgY2xhc3MuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBUaGUgY29uZmlndXJhdGlvbiBvZiB0aGUgbW9kZWwuXG4gICAgICogQHBhcmFtIHthbnl9IHNlc3Npb24gVGhlIE9OTlggc2Vzc2lvbiBjb250YWluaW5nIHRoZSBtb2RlbCB3ZWlnaHRzLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZywgc2Vzc2lvbikge1xuICAgICAgICBzdXBlcihjb25maWcsIHNlc3Npb24pO1xuXG4gICAgICAgIC8vIGNvbmZpZyBkb2Vzbid0IGNvbnRhaW4gcGFkX3Rva2VuX2lkLCBzbyB3ZSBhc3N1bWUgaXQgaXMgdGhlIGVvc190b2tlbl9pZFxuICAgICAgICB0aGlzLmNvbmZpZy5wYWRfdG9rZW5faWQgPSB0aGlzLmNvbmZpZy5lb3NfdG9rZW5faWRcblxuICAgICAgICB0aGlzLm51bV9oZWFkcyA9IHRoaXMuY29uZmlnLm5faGVhZFxuICAgICAgICB0aGlzLm51bV9sYXllcnMgPSB0aGlzLmNvbmZpZy5uX2xheWVyXG4gICAgICAgIHRoaXMuZGltX2t2ID0gdGhpcy5jb25maWcubl9lbWJkIC8gdGhpcy5udW1faGVhZHM7XG4gICAgfVxufVxuXG5leHBvcnQgY2xhc3MgR1BUMk1vZGVsIGV4dGVuZHMgR1BUMlByZVRyYWluZWRNb2RlbCB7XG5cbiAgICAvKipcbiAgICAgKiBHUFQyTW9kZWwgaXMgbm90IGNvbXBhdGlibGUgd2l0aCBgLmdlbmVyYXRlKClgLCBhcyBpdCBkb2Vzbid0IGhhdmUgYSBsYW5ndWFnZSBtb2RlbCBoZWFkLlxuICAgICAqIEBwYXJhbSAgey4uLmFueX0gYXJncyBcbiAgICAgKiBAdGhyb3dzIHtFcnJvcn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxhbnk+fVxuICAgICAqL1xuICAgIGFzeW5jIGdlbmVyYXRlKC4uLmFyZ3MpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICBcIlRoZSBjdXJyZW50IG1vZGVsIGNsYXNzIChHUFQyTW9kZWwpIGlzIG5vdCBjb21wYXRpYmxlIHdpdGggYC5nZW5lcmF0ZSgpYCwgYXMgaXQgZG9lc24ndCBoYXZlIGEgbGFuZ3VhZ2UgbW9kZWwgaGVhZC4gUGxlYXNlIHVzZSBvbmUgb2YgdGhlIGZvbGxvd2luZyBjbGFzc2VzIGluc3RlYWQ6IHsnR1BUMkxNSGVhZE1vZGVsJ31cIlxuICAgICAgICApXG4gICAgfVxufVxuXG4vKipcbiAqIEdQVC0yIGxhbmd1YWdlIG1vZGVsIGhlYWQgb24gdG9wIG9mIHRoZSBHUFQtMiBiYXNlIG1vZGVsLiBUaGlzIG1vZGVsIGlzIHN1aXRhYmxlIGZvciB0ZXh0IGdlbmVyYXRpb24gdGFza3MuXG4gKiBAZXh0ZW5kcyBHUFQyUHJlVHJhaW5lZE1vZGVsXG4gKi9cbmV4cG9ydCBjbGFzcyBHUFQyTE1IZWFkTW9kZWwgZXh0ZW5kcyBHUFQyUHJlVHJhaW5lZE1vZGVsIHtcblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIGFuZCByZXR1cm5zIHRoZSBiZWFtIGZvciB0ZXh0IGdlbmVyYXRpb24gdGFza1xuICAgICAqIEBwYXJhbSB7VGVuc29yfSBpbnB1dFRva2VuSWRzIFRoZSBpbnB1dCB0b2tlbiBpZHMuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG51bU91dHB1dFRva2VucyBUaGUgbnVtYmVyIG9mIHRva2VucyB0byBiZSBnZW5lcmF0ZWQuXG4gICAgICogQHBhcmFtIHtUZW5zb3J9IGlucHV0c19hdHRlbnRpb25fbWFzayBPcHRpb25hbCBpbnB1dCBhdHRlbnRpb24gbWFzay5cbiAgICAgKiBAcmV0dXJucyB7YW55fSBBIEJlYW0gb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgaW5pdGlhbGl6ZWQgYmVhbS5cbiAgICAgKi9cbiAgICBnZXRTdGFydEJlYW1zKGlucHV0VG9rZW5JZHMsIG51bU91dHB1dFRva2VucywgaW5wdXRzX2F0dGVudGlvbl9tYXNrKSB7XG4gICAgICAgIHJldHVybiBkZWNvZGVyU3RhcnRCZWFtcyh0aGlzLCBpbnB1dFRva2VuSWRzLCBudW1PdXRwdXRUb2tlbnMsIGlucHV0c19hdHRlbnRpb25fbWFzaylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSdW5zIGEgc2luZ2xlIHN0ZXAgb2YgdGhlIGJlYW0gc2VhcmNoIGdlbmVyYXRpb24gYWxnb3JpdGhtLlxuICAgICAqIEBwYXJhbSB7YW55fSBiZWFtIFRoZSBjdXJyZW50IGJlYW0gYmVpbmcgZ2VuZXJhdGVkLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPGFueT59IFRoZSB1cGRhdGVkIGJlYW0gYWZ0ZXIgYSBzaW5nbGUgZ2VuZXJhdGlvbiBzdGVwLlxuICAgICAqL1xuICAgIGFzeW5jIHJ1bkJlYW0oYmVhbSkge1xuICAgICAgICByZXR1cm4gYXdhaXQgZGVjb2RlclJ1bkJlYW0odGhpcywgYmVhbSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgZ2l2ZW4gYmVhbSB3aXRoIHRoZSBuZXcgZ2VuZXJhdGVkIHRva2VuIGlkLlxuICAgICAqIEBwYXJhbSB7YW55fSBiZWFtIFRoZSBCZWFtIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIGJlYW0uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG5ld1Rva2VuSWQgVGhlIG5ldyBnZW5lcmF0ZWQgdG9rZW4gaWQgdG8gYmUgYWRkZWQgdG8gdGhlIGJlYW0uXG4gICAgICovXG4gICAgdXBkYXRlQmVhbShiZWFtLCBuZXdUb2tlbklkKSB7XG4gICAgICAgIHJldHVybiBkZWNvZGVyVXBkYXRlYmVhbShiZWFtLCBuZXdUb2tlbklkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGb3J3YXJkIHBhc3MgZm9yIHRoZSBtb2RlbC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbW9kZWxfaW5wdXRzIFRoZSBpbnB1dHMgZm9yIHRoZSBtb2RlbC5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxhbnk+fSBUaGUgb3V0cHV0IHRlbnNvciBvZiB0aGUgbW9kZWwuXG4gICAgICovXG4gICAgYXN5bmMgZm9yd2FyZChtb2RlbF9pbnB1dHMpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IGRlY29kZXJGb3J3YXJkKHRoaXMsIG1vZGVsX2lucHV0cyk7XG4gICAgfVxuXG59XG4vLyBleHBvcnQgY2xhc3MgR1BUMkZvclNlcXVlbmNlQ2xhc3NpZmljYXRpb24gZXh0ZW5kcyBHUFQyUHJlVHJhaW5lZE1vZGVsIHtcbi8vIFRPRE9cbi8vIH1cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5leHBvcnQgY2xhc3MgR1BUTmVvUHJlVHJhaW5lZE1vZGVsIGV4dGVuZHMgUHJlVHJhaW5lZE1vZGVsIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIHRoZSBgR1BUTmVvUHJlVHJhaW5lZE1vZGVsYCBjbGFzcy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIFRoZSBjb25maWd1cmF0aW9uIG9mIHRoZSBtb2RlbC5cbiAgICAgKiBAcGFyYW0ge2FueX0gc2Vzc2lvbiBUaGUgT05OWCBzZXNzaW9uIGNvbnRhaW5pbmcgdGhlIG1vZGVsIHdlaWdodHMuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY29uZmlnLCBzZXNzaW9uKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZywgc2Vzc2lvbik7XG5cbiAgICAgICAgLy8gY29uZmlnIGRvZXNuJ3QgY29udGFpbiBwYWRfdG9rZW5faWQsIHNvIHdlIGFzc3VtZSBpdCBpcyB0aGUgZW9zX3Rva2VuX2lkXG4gICAgICAgIHRoaXMuY29uZmlnLnBhZF90b2tlbl9pZCA9IHRoaXMuY29uZmlnLmVvc190b2tlbl9pZFxuXG4gICAgICAgIHRoaXMubnVtX2hlYWRzID0gdGhpcy5jb25maWcubnVtX2hlYWRzO1xuICAgICAgICB0aGlzLm51bV9sYXllcnMgPSB0aGlzLmNvbmZpZy5udW1fbGF5ZXJzO1xuICAgICAgICB0aGlzLmRpbV9rdiA9IHRoaXMuY29uZmlnLmhpZGRlbl9zaXplIC8gdGhpcy5udW1faGVhZHM7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIEdQVE5lb01vZGVsIGV4dGVuZHMgR1BUTmVvUHJlVHJhaW5lZE1vZGVsIHtcbiAgICAvKipcbiAgICAgKiBcbiAgICAgKiBAcGFyYW0gIHsuLi5hbnl9IGFyZ3MgXG4gICAgICogQHRocm93cyB7RXJyb3J9XG4gICAgICogQHJldHVybnMge1Byb21pc2U8YW55Pn1cbiAgICAgKi9cbiAgICBhc3luYyBnZW5lcmF0ZSguLi5hcmdzKSB7XG4gICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgXCJUaGUgY3VycmVudCBtb2RlbCBjbGFzcyAoR1BUTmVvTW9kZWwpIGlzIG5vdCBjb21wYXRpYmxlIHdpdGggYC5nZW5lcmF0ZSgpYCwgYXMgaXQgZG9lc24ndCBoYXZlIGEgbGFuZ3VhZ2UgbW9kZWwgaGVhZC4gUGxlYXNlIHVzZSBvbmUgb2YgdGhlIGZvbGxvd2luZyBjbGFzc2VzIGluc3RlYWQ6IHsnR1BUTmVvRm9yQ2F1c2FsTE0nfVwiXG4gICAgICAgIClcbiAgICB9XG59XG5cbmV4cG9ydCBjbGFzcyBHUFROZW9Gb3JDYXVzYWxMTSBleHRlbmRzIEdQVE5lb1ByZVRyYWluZWRNb2RlbCB7XG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyBhbmQgcmV0dXJucyB0aGUgYmVhbSBmb3IgdGV4dCBnZW5lcmF0aW9uIHRhc2tcbiAgICAgKiBAcGFyYW0ge1RlbnNvcn0gaW5wdXRUb2tlbklkcyBUaGUgaW5wdXQgdG9rZW4gaWRzLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBudW1PdXRwdXRUb2tlbnMgVGhlIG51bWJlciBvZiB0b2tlbnMgdG8gYmUgZ2VuZXJhdGVkLlxuICAgICAqIEBwYXJhbSB7VGVuc29yfSBpbnB1dHNfYXR0ZW50aW9uX21hc2sgT3B0aW9uYWwgaW5wdXQgYXR0ZW50aW9uIG1hc2suXG4gICAgICogQHJldHVybnMge2FueX0gQSBCZWFtIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIGluaXRpYWxpemVkIGJlYW0uXG4gICAgICovXG4gICAgZ2V0U3RhcnRCZWFtcyhpbnB1dFRva2VuSWRzLCBudW1PdXRwdXRUb2tlbnMsIGlucHV0c19hdHRlbnRpb25fbWFzaykge1xuICAgICAgICByZXR1cm4gZGVjb2RlclN0YXJ0QmVhbXModGhpcywgaW5wdXRUb2tlbklkcywgbnVtT3V0cHV0VG9rZW5zLCBpbnB1dHNfYXR0ZW50aW9uX21hc2spXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUnVucyBhIHNpbmdsZSBzdGVwIG9mIHRoZSBiZWFtIHNlYXJjaCBnZW5lcmF0aW9uIGFsZ29yaXRobS5cbiAgICAgKiBAcGFyYW0ge2FueX0gYmVhbSBUaGUgY3VycmVudCBiZWFtIGJlaW5nIGdlbmVyYXRlZC5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxhbnk+fSBUaGUgdXBkYXRlZCBiZWFtIGFmdGVyIGEgc2luZ2xlIGdlbmVyYXRpb24gc3RlcC5cbiAgICAgKi9cbiAgICBhc3luYyBydW5CZWFtKGJlYW0pIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IGRlY29kZXJSdW5CZWFtKHRoaXMsIGJlYW0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIGdpdmVuIGJlYW0gd2l0aCB0aGUgbmV3IGdlbmVyYXRlZCB0b2tlbiBpZC5cbiAgICAgKiBAcGFyYW0ge2FueX0gYmVhbSBUaGUgQmVhbSBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBiZWFtLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuZXdUb2tlbklkIFRoZSBuZXcgZ2VuZXJhdGVkIHRva2VuIGlkIHRvIGJlIGFkZGVkIHRvIHRoZSBiZWFtLlxuICAgICAqL1xuICAgIHVwZGF0ZUJlYW0oYmVhbSwgbmV3VG9rZW5JZCkge1xuICAgICAgICByZXR1cm4gZGVjb2RlclVwZGF0ZWJlYW0oYmVhbSwgbmV3VG9rZW5JZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRm9yd2FyZCBwYXNzIGZvciB0aGUgbW9kZWwuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1vZGVsX2lucHV0cyBUaGUgaW5wdXRzIGZvciB0aGUgbW9kZWwuXG4gICAgICogQHJldHVybnMge1Byb21pc2U8YW55Pn0gVGhlIG91dHB1dCB0ZW5zb3Igb2YgdGhlIG1vZGVsLlxuICAgICAqL1xuICAgIGFzeW5jIGZvcndhcmQobW9kZWxfaW5wdXRzKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCBkZWNvZGVyRm9yd2FyZCh0aGlzLCBtb2RlbF9pbnB1dHMpO1xuICAgIH1cbn1cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIENvZGVHZW4gbW9kZWxzXG5leHBvcnQgY2xhc3MgQ29kZUdlblByZVRyYWluZWRNb2RlbCBleHRlbmRzIFByZVRyYWluZWRNb2RlbCB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiB0aGUgYENvZGVHZW5QcmVUcmFpbmVkTW9kZWxgIGNsYXNzLlxuICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBUaGUgbW9kZWwgY29uZmlndXJhdGlvbiBvYmplY3QuXG4gICAgKiBAcGFyYW0ge09iamVjdH0gc2Vzc2lvbiBUaGUgT05OWCBzZXNzaW9uIG9iamVjdC5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZywgc2Vzc2lvbikge1xuICAgICAgICBzdXBlcihjb25maWcsIHNlc3Npb24pO1xuXG4gICAgICAgIC8vIGNvbmZpZyBkb2Vzbid0IGNvbnRhaW4gcGFkX3Rva2VuX2lkLCBzbyB3ZSBhc3N1bWUgaXQgaXMgdGhlIGVvc190b2tlbl9pZFxuICAgICAgICB0aGlzLmNvbmZpZy5wYWRfdG9rZW5faWQgPSB0aGlzLmNvbmZpZy5lb3NfdG9rZW5faWRcblxuICAgICAgICB0aGlzLm51bV9oZWFkcyA9IHRoaXMuY29uZmlnLm5faGVhZFxuICAgICAgICB0aGlzLm51bV9sYXllcnMgPSB0aGlzLmNvbmZpZy5uX2xheWVyXG4gICAgICAgIHRoaXMuZGltX2t2ID0gdGhpcy5jb25maWcubl9lbWJkIC8gdGhpcy5udW1faGVhZHM7XG4gICAgfVxufVxuLyoqXG4gKiBDb2RlR2VuTW9kZWwgaXMgYSBjbGFzcyByZXByZXNlbnRpbmcgYSBjb2RlIGdlbmVyYXRpb24gbW9kZWwgd2l0aG91dCBhIGxhbmd1YWdlIG1vZGVsIGhlYWQuXG4gKiBcbiAqIEBleHRlbmRzIENvZGVHZW5QcmVUcmFpbmVkTW9kZWxcbiAqL1xuZXhwb3J0IGNsYXNzIENvZGVHZW5Nb2RlbCBleHRlbmRzIENvZGVHZW5QcmVUcmFpbmVkTW9kZWwge1xuICAgIC8qKlxuICAgICAqIFRocm93cyBhbiBlcnJvciBpbmRpY2F0aW5nIHRoYXQgdGhlIGN1cnJlbnQgbW9kZWwgY2xhc3MgaXMgbm90IGNvbXBhdGlibGUgd2l0aCBgLmdlbmVyYXRlKClgLFxuICAgICAqIGFzIGl0IGRvZXNuJ3QgaGF2ZSBhIGxhbmd1YWdlIG1vZGVsIGhlYWQuXG4gICAgICogXG4gICAgICogQHRocm93cyB7RXJyb3J9IFRoZSBjdXJyZW50IG1vZGVsIGNsYXNzIGlzIG5vdCBjb21wYXRpYmxlIHdpdGggYC5nZW5lcmF0ZSgpYFxuICAgICAqIFxuICAgICAqIEBwYXJhbSAgey4uLmFueX0gYXJncyBBcmd1bWVudHMgcGFzc2VkIHRvIHRoZSBnZW5lcmF0ZSBmdW5jdGlvblxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPGFueT59XG4gICAgICovXG4gICAgYXN5bmMgZ2VuZXJhdGUoLi4uYXJncykge1xuICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgIFwiVGhlIGN1cnJlbnQgbW9kZWwgY2xhc3MgKENvZGVHZW5Nb2RlbCkgaXMgbm90IGNvbXBhdGlibGUgd2l0aCBgLmdlbmVyYXRlKClgLCBhcyBpdCBkb2Vzbid0IGhhdmUgYSBsYW5ndWFnZSBtb2RlbCBoZWFkLiBQbGVhc2UgdXNlIG9uZSBvZiB0aGUgZm9sbG93aW5nIGNsYXNzZXMgaW5zdGVhZDogeydDb2RlR2VuRm9yQ2F1c2FsTE0nfVwiXG4gICAgICAgIClcbiAgICB9XG59XG5cbi8qKlxuICogQ29kZUdlbkZvckNhdXNhbExNIGlzIGEgY2xhc3MgdGhhdCByZXByZXNlbnRzIGEgY29kZSBnZW5lcmF0aW9uIG1vZGVsIGJhc2VkIG9uIHRoZSBHUFQtMiBhcmNoaXRlY3R1cmUuIEl0IGV4dGVuZHMgdGhlIGBDb2RlR2VuUHJlVHJhaW5lZE1vZGVsYCBjbGFzcy5cbiAqIEBleHRlbmRzIENvZGVHZW5QcmVUcmFpbmVkTW9kZWxcbiAqL1xuZXhwb3J0IGNsYXNzIENvZGVHZW5Gb3JDYXVzYWxMTSBleHRlbmRzIENvZGVHZW5QcmVUcmFpbmVkTW9kZWwge1xuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgYW5kIHJldHVybnMgdGhlIGJlYW0gZm9yIHRleHQgZ2VuZXJhdGlvbiB0YXNrXG4gICAgICogQHBhcmFtIHtUZW5zb3J9IGlucHV0VG9rZW5JZHMgVGhlIGlucHV0IHRva2VuIGlkcy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbnVtT3V0cHV0VG9rZW5zIFRoZSBudW1iZXIgb2YgdG9rZW5zIHRvIGJlIGdlbmVyYXRlZC5cbiAgICAgKiBAcGFyYW0ge1RlbnNvcn0gaW5wdXRzX2F0dGVudGlvbl9tYXNrIE9wdGlvbmFsIGlucHV0IGF0dGVudGlvbiBtYXNrLlxuICAgICAqIEByZXR1cm5zIHthbnl9IEEgQmVhbSBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBpbml0aWFsaXplZCBiZWFtLlxuICAgICAqL1xuICAgIGdldFN0YXJ0QmVhbXMoaW5wdXRUb2tlbklkcywgbnVtT3V0cHV0VG9rZW5zLCBpbnB1dHNfYXR0ZW50aW9uX21hc2spIHtcbiAgICAgICAgcmV0dXJuIGRlY29kZXJTdGFydEJlYW1zKHRoaXMsIGlucHV0VG9rZW5JZHMsIG51bU91dHB1dFRva2VucywgaW5wdXRzX2F0dGVudGlvbl9tYXNrKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJ1bnMgYSBzaW5nbGUgc3RlcCBvZiB0aGUgYmVhbSBzZWFyY2ggZ2VuZXJhdGlvbiBhbGdvcml0aG0uXG4gICAgICogQHBhcmFtIHthbnl9IGJlYW0gVGhlIGN1cnJlbnQgYmVhbSBiZWluZyBnZW5lcmF0ZWQuXG4gICAgICogQHJldHVybnMge1Byb21pc2U8YW55Pn0gVGhlIHVwZGF0ZWQgYmVhbSBhZnRlciBhIHNpbmdsZSBnZW5lcmF0aW9uIHN0ZXAuXG4gICAgICovXG4gICAgYXN5bmMgcnVuQmVhbShiZWFtKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCBkZWNvZGVyUnVuQmVhbSh0aGlzLCBiZWFtKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSBnaXZlbiBiZWFtIHdpdGggdGhlIG5ldyBnZW5lcmF0ZWQgdG9rZW4gaWQuXG4gICAgICogQHBhcmFtIHthbnl9IGJlYW0gVGhlIEJlYW0gb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgYmVhbS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbmV3VG9rZW5JZCBUaGUgbmV3IGdlbmVyYXRlZCB0b2tlbiBpZCB0byBiZSBhZGRlZCB0byB0aGUgYmVhbS5cbiAgICAgKi9cbiAgICB1cGRhdGVCZWFtKGJlYW0sIG5ld1Rva2VuSWQpIHtcbiAgICAgICAgcmV0dXJuIGRlY29kZXJVcGRhdGViZWFtKGJlYW0sIG5ld1Rva2VuSWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZvcndhcmQgcGFzcyBmb3IgdGhlIG1vZGVsLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtb2RlbF9pbnB1dHMgVGhlIGlucHV0cyBmb3IgdGhlIG1vZGVsLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPGFueT59IFRoZSBvdXRwdXQgdGVuc29yIG9mIHRoZSBtb2RlbC5cbiAgICAgKi9cbiAgICBhc3luYyBmb3J3YXJkKG1vZGVsX2lucHV0cykge1xuICAgICAgICByZXR1cm4gYXdhaXQgZGVjb2RlckZvcndhcmQodGhpcywgbW9kZWxfaW5wdXRzKTtcbiAgICB9XG5cbn1cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5leHBvcnQgY2xhc3MgVmlUUHJlVHJhaW5lZE1vZGVsIGV4dGVuZHMgUHJlVHJhaW5lZE1vZGVsIHsgfVxuZXhwb3J0IGNsYXNzIFZpVEZvckltYWdlQ2xhc3NpZmljYXRpb24gZXh0ZW5kcyBWaVRQcmVUcmFpbmVkTW9kZWwge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7YW55fSBtb2RlbF9pbnB1dHNcbiAgICAgKi9cbiAgICBhc3luYyBfY2FsbChtb2RlbF9pbnB1dHMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTZXF1ZW5jZUNsYXNzaWZpZXJPdXRwdXQoYXdhaXQgc3VwZXIuX2NhbGwobW9kZWxfaW5wdXRzKSk7XG4gICAgfVxufVxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbmV4cG9ydCBjbGFzcyBNb2JpbGVWaVRQcmVUcmFpbmVkTW9kZWwgZXh0ZW5kcyBQcmVUcmFpbmVkTW9kZWwgeyB9XG5leHBvcnQgY2xhc3MgTW9iaWxlVmlURm9ySW1hZ2VDbGFzc2lmaWNhdGlvbiBleHRlbmRzIE1vYmlsZVZpVFByZVRyYWluZWRNb2RlbCB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHthbnl9IG1vZGVsX2lucHV0c1xuICAgICAqL1xuICAgIGFzeW5jIF9jYWxsKG1vZGVsX2lucHV0cykge1xuICAgICAgICByZXR1cm4gbmV3IFNlcXVlbmNlQ2xhc3NpZmllck91dHB1dChhd2FpdCBzdXBlci5fY2FsbChtb2RlbF9pbnB1dHMpKTtcbiAgICB9XG59XG4vLyBUT0RPOiBNb2JpbGVWaVRGb3JTZW1hbnRpY1NlZ21lbnRhdGlvblxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbmV4cG9ydCBjbGFzcyBEZXRyUHJlVHJhaW5lZE1vZGVsIGV4dGVuZHMgUHJlVHJhaW5lZE1vZGVsIHsgfVxuZXhwb3J0IGNsYXNzIERldHJGb3JPYmplY3REZXRlY3Rpb24gZXh0ZW5kcyBEZXRyUHJlVHJhaW5lZE1vZGVsIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge2FueX0gbW9kZWxfaW5wdXRzXG4gICAgICovXG4gICAgYXN5bmMgX2NhbGwobW9kZWxfaW5wdXRzKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGV0ck9iamVjdERldGVjdGlvbk91dHB1dChhd2FpdCBzdXBlci5fY2FsbChtb2RlbF9pbnB1dHMpKTtcbiAgICB9XG59XG5cbmV4cG9ydCBjbGFzcyBEZXRyRm9yU2VnbWVudGF0aW9uIGV4dGVuZHMgRGV0clByZVRyYWluZWRNb2RlbCB7XG4gICAgLyoqXG4gICAgICogUnVucyB0aGUgbW9kZWwgd2l0aCB0aGUgcHJvdmlkZWQgaW5wdXRzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1vZGVsX2lucHV0cyBNb2RlbCBpbnB1dHNcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxEZXRyU2VnbWVudGF0aW9uT3V0cHV0Pn0gT2JqZWN0IGNvbnRhaW5pbmcgc2VnbWVudGF0aW9uIG91dHB1dHNcbiAgICAgKi9cbiAgICBhc3luYyBfY2FsbChtb2RlbF9pbnB1dHMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEZXRyU2VnbWVudGF0aW9uT3V0cHV0KGF3YWl0IHN1cGVyLl9jYWxsKG1vZGVsX2lucHV0cykpO1xuICAgIH1cbn1cblxuZXhwb3J0IGNsYXNzIERldHJPYmplY3REZXRlY3Rpb25PdXRwdXQgZXh0ZW5kcyBNb2RlbE91dHB1dCB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG91dHB1dCBUaGUgb3V0cHV0IG9mIHRoZSBtb2RlbC5cbiAgICAgKiBAcGFyYW0ge1RlbnNvcn0gb3V0cHV0LmxvZ2l0cyBDbGFzc2lmaWNhdGlvbiBsb2dpdHMgKGluY2x1ZGluZyBuby1vYmplY3QpIGZvciBhbGwgcXVlcmllcy5cbiAgICAgKiBAcGFyYW0ge1RlbnNvcn0gb3V0cHV0LnByZWRfYm94ZXMgTm9ybWFsaXplZCBib3hlcyBjb29yZGluYXRlcyBmb3IgYWxsIHF1ZXJpZXMsIHJlcHJlc2VudGVkIGFzIChjZW50ZXJfeCwgY2VudGVyX3ksIHdpZHRoLCBoZWlnaHQpLlxuICAgICAqIFRoZXNlIHZhbHVlcyBhcmUgbm9ybWFsaXplZCBpbiBbMCwgMV0sIHJlbGF0aXZlIHRvIHRoZSBzaXplIG9mIGVhY2ggaW5kaXZpZHVhbCBpbWFnZSBpbiB0aGUgYmF0Y2ggKGRpc3JlZ2FyZGluZyBwb3NzaWJsZSBwYWRkaW5nKS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih7IGxvZ2l0cywgcHJlZF9ib3hlcyB9KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMubG9naXRzID0gbG9naXRzO1xuICAgICAgICB0aGlzLnByZWRfYm94ZXMgPSBwcmVkX2JveGVzO1xuICAgIH1cbn1cblxuZXhwb3J0IGNsYXNzIERldHJTZWdtZW50YXRpb25PdXRwdXQgZXh0ZW5kcyBNb2RlbE91dHB1dCB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG91dHB1dCBUaGUgb3V0cHV0IG9mIHRoZSBtb2RlbC5cbiAgICAgKiBAcGFyYW0ge1RlbnNvcn0gb3V0cHV0LmxvZ2l0cyBUaGUgb3V0cHV0IGxvZ2l0cyBvZiB0aGUgbW9kZWwuXG4gICAgICogQHBhcmFtIHtUZW5zb3J9IG91dHB1dC5wcmVkX2JveGVzIFByZWRpY3RlZCBib3hlcy5cbiAgICAgKiBAcGFyYW0ge1RlbnNvcn0gb3V0cHV0LnByZWRfbWFza3MgUHJlZGljdGVkIG1hc2tzLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHsgbG9naXRzLCBwcmVkX2JveGVzLCBwcmVkX21hc2tzIH0pIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5sb2dpdHMgPSBsb2dpdHM7XG4gICAgICAgIHRoaXMucHJlZF9ib3hlcyA9IHByZWRfYm94ZXM7XG4gICAgICAgIHRoaXMucHJlZF9tYXNrcyA9IHByZWRfbWFza3M7XG4gICAgfVxufVxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuZXhwb3J0IGNsYXNzIFNhbVByZVRyYWluZWRNb2RlbCBleHRlbmRzIFByZVRyYWluZWRNb2RlbCB7IH1cbmV4cG9ydCBjbGFzcyBTYW1Nb2RlbCBleHRlbmRzIFNhbVByZVRyYWluZWRNb2RlbCB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1vZGVsX2lucHV0c1xuICAgICAqIEBwYXJhbSB7VGVuc29yfSBtb2RlbF9pbnB1dHMucGl4ZWxfdmFsdWVzIFBpeGVsIHZhbHVlcyBhcyBhIFRlbnNvciB3aXRoIHNoYXBlIGAoYmF0Y2hfc2l6ZSwgbnVtX2NoYW5uZWxzLCBoZWlnaHQsIHdpZHRoKWAuXG4gICAgICogQHBhcmFtIHtUZW5zb3J9IG1vZGVsX2lucHV0cy5pbnB1dF9wb2ludHMgSW5wdXQgMkQgc3BhdGlhbCBwb2ludHMgd2l0aCBzaGFwZSBgKGJhdGNoX3NpemUsIG51bV9wb2ludHMsIDIpYC4gVGhpcyBpcyB1c2VkIGJ5IHRoZSBwcm9tcHQgZW5jb2RlciB0byBlbmNvZGUgdGhlIHByb21wdC5cbiAgICAgKiBAdG9kbyBBZGQgc3VwcG9ydCBmb3IgYGlucHV0X2xhYmVsc2AsIGBpbnB1dF9ib3hlc2AsIGBpbnB1dF9tYXNrc2AsIGFuZCBgaW1hZ2VfZW1iZWRkaW5nc2AuXG4gICAgICovXG4gICAgYXN5bmMgX2NhbGwobW9kZWxfaW5wdXRzKSB7XG4gICAgICAgIHJldHVybiBuZXcgU2FtSW1hZ2VTZWdtZW50YXRpb25PdXRwdXQoYXdhaXQgc3VwZXIuX2NhbGwobW9kZWxfaW5wdXRzKSk7XG4gICAgfVxufVxuXG5cbi8qKlxuICogQmFzZSBjbGFzcyBmb3IgU2VnbWVudC1Bbnl0aGluZyBtb2RlbCdzIG91dHB1dC5cbiAqL1xuZXhwb3J0IGNsYXNzIFNhbUltYWdlU2VnbWVudGF0aW9uT3V0cHV0IGV4dGVuZHMgTW9kZWxPdXRwdXQge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvdXRwdXQgVGhlIG91dHB1dCBvZiB0aGUgbW9kZWwuXG4gICAgICogQHBhcmFtIHtUZW5zb3J9IG91dHB1dC5pb3Vfc2NvcmVzIFRoZSBvdXRwdXQgbG9naXRzIG9mIHRoZSBtb2RlbC5cbiAgICAgKiBAcGFyYW0ge1RlbnNvcn0gb3V0cHV0LnByZWRfbWFza3MgUHJlZGljdGVkIGJveGVzLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHsgaW91X3Njb3JlcywgcHJlZF9tYXNrcyB9KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuaW91X3Njb3JlcyA9IGlvdV9zY29yZXM7XG4gICAgICAgIHRoaXMucHJlZF9tYXNrcyA9IHByZWRfbWFza3M7XG4gICAgfVxufVxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gTWFyaWFuTVQgbW9kZWxzXG5leHBvcnQgY2xhc3MgTWFyaWFuUHJlVHJhaW5lZE1vZGVsIGV4dGVuZHMgUHJlVHJhaW5lZE1vZGVsIHsgfTtcblxuZXhwb3J0IGNsYXNzIE1hcmlhbk1vZGVsIGV4dGVuZHMgTWFyaWFuUHJlVHJhaW5lZE1vZGVsIHtcbiAgICAvKipcbiAgICAgKiBcbiAgICAgKiBAcGFyYW0gIHsuLi5hbnl9IGFyZ3MgXG4gICAgICogQHRocm93cyB7RXJyb3J9XG4gICAgICogQHJldHVybnMge1Byb21pc2U8YW55Pn1cbiAgICAgKi9cbiAgICBhc3luYyBnZW5lcmF0ZSguLi5hcmdzKSB7XG4gICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgXCJUaGUgY3VycmVudCBtb2RlbCBjbGFzcyAoTWFyaWFuTW9kZWwpIGlzIG5vdCBjb21wYXRpYmxlIHdpdGggYC5nZW5lcmF0ZSgpYCwgYXMgaXQgZG9lc24ndCBoYXZlIGEgbGFuZ3VhZ2UgbW9kZWwgaGVhZC4gUGxlYXNlIHVzZSBvbmUgb2YgdGhlIGZvbGxvd2luZyBjbGFzc2VzIGluc3RlYWQ6IHsnTWFyaWFuTVRNb2RlbCd9XCJcbiAgICAgICAgKVxuICAgIH1cbn1cblxuZXhwb3J0IGNsYXNzIE1hcmlhbk1UTW9kZWwgZXh0ZW5kcyBNYXJpYW5QcmVUcmFpbmVkTW9kZWwge1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiB0aGUgYE1hcmlhbk1UTW9kZWxgIGNsYXNzLlxuICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBUaGUgbW9kZWwgY29uZmlndXJhdGlvbiBvYmplY3QuXG4gICAgKiBAcGFyYW0ge09iamVjdH0gc2Vzc2lvbiBUaGUgT05OWCBzZXNzaW9uIG9iamVjdC5cbiAgICAqIEBwYXJhbSB7YW55fSBkZWNvZGVyX21lcmdlZF9zZXNzaW9uIFxuICAgICogQHBhcmFtIHthbnl9IGdlbmVyYXRpb25fY29uZmlnIFxuICAgICovXG4gICAgY29uc3RydWN0b3IoY29uZmlnLCBzZXNzaW9uLCBkZWNvZGVyX21lcmdlZF9zZXNzaW9uLCBnZW5lcmF0aW9uX2NvbmZpZykge1xuICAgICAgICBzdXBlcihjb25maWcsIHNlc3Npb24pO1xuICAgICAgICB0aGlzLmRlY29kZXJfbWVyZ2VkX3Nlc3Npb24gPSBkZWNvZGVyX21lcmdlZF9zZXNzaW9uO1xuICAgICAgICB0aGlzLmdlbmVyYXRpb25fY29uZmlnID0gZ2VuZXJhdGlvbl9jb25maWc7XG5cbiAgICAgICAgdGhpcy5udW1fZGVjb2Rlcl9sYXllcnMgPSB0aGlzLmNvbmZpZy5kZWNvZGVyX2xheWVycztcbiAgICAgICAgdGhpcy5udW1fZGVjb2Rlcl9oZWFkcyA9IHRoaXMuY29uZmlnLmRlY29kZXJfYXR0ZW50aW9uX2hlYWRzO1xuICAgICAgICB0aGlzLmRlY29kZXJfZGltX2t2ID0gdGhpcy5jb25maWcuZF9tb2RlbCAvIHRoaXMubnVtX2RlY29kZXJfaGVhZHM7XG5cbiAgICAgICAgdGhpcy5udW1fZW5jb2Rlcl9sYXllcnMgPSB0aGlzLmNvbmZpZy5lbmNvZGVyX2xheWVycztcbiAgICAgICAgdGhpcy5udW1fZW5jb2Rlcl9oZWFkcyA9IHRoaXMuY29uZmlnLmVuY29kZXJfYXR0ZW50aW9uX2hlYWRzO1xuICAgICAgICB0aGlzLmVuY29kZXJfZGltX2t2ID0gdGhpcy5jb25maWcuZF9tb2RlbCAvIHRoaXMubnVtX2VuY29kZXJfaGVhZHM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgYW5kIHJldHVybnMgdGhlIGJlYW0gZm9yIHRleHQgZ2VuZXJhdGlvbiB0YXNrXG4gICAgICogQHBhcmFtIHthbnlbXX0gaW5wdXRzIFRoZSBpbnB1dCB0b2tlbiBpZHMuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG51bU91dHB1dFRva2VucyBUaGUgbnVtYmVyIG9mIHRva2VucyB0byBiZSBnZW5lcmF0ZWQuXG4gICAgICogQHJldHVybnMge2FueX0gQSBCZWFtIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIGluaXRpYWxpemVkIGJlYW0uXG4gICAgICogQHBhcmFtIHthbnlbXX0gYXJnc1xuICAgICAqL1xuICAgIGdldFN0YXJ0QmVhbXMoaW5wdXRzLCBudW1PdXRwdXRUb2tlbnMsIC4uLmFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIHNlcTJzZXFTdGFydEJlYW1zKHRoaXMsIGlucHV0cywgbnVtT3V0cHV0VG9rZW5zKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSdW5zIGEgc2luZ2xlIHN0ZXAgb2YgdGhlIGJlYW0gc2VhcmNoIGdlbmVyYXRpb24gYWxnb3JpdGhtLlxuICAgICAqIEBwYXJhbSB7YW55fSBiZWFtIFRoZSBjdXJyZW50IGJlYW0gYmVpbmcgZ2VuZXJhdGVkLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPGFueT59IFRoZSB1cGRhdGVkIGJlYW0gYWZ0ZXIgYSBzaW5nbGUgZ2VuZXJhdGlvbiBzdGVwLlxuICAgICAqL1xuICAgIGFzeW5jIHJ1bkJlYW0oYmVhbSkge1xuICAgICAgICByZXR1cm4gYXdhaXQgc2VxMnNlcVJ1bkJlYW0odGhpcywgYmVhbSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHthbnl9IGJlYW1cbiAgICAgKiBAcGFyYW0ge2FueX0gbmV3VG9rZW5JZFxuICAgICAqL1xuICAgIHVwZGF0ZUJlYW0oYmVhbSwgbmV3VG9rZW5JZCkge1xuICAgICAgICBiZWFtLm91dHB1dF90b2tlbl9pZHMgPSBbLi4uYmVhbS5vdXRwdXRfdG9rZW5faWRzLCBuZXdUb2tlbklkXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge2FueX0gbW9kZWxfaW5wdXRzXG4gICAgICogQHJldHVybnMge1Byb21pc2U8U2VxMlNlcUxNT3V0cHV0Pn1cbiAgICAgKi9cbiAgICBhc3luYyBmb3J3YXJkKG1vZGVsX2lucHV0cykge1xuICAgICAgICByZXR1cm4gYXdhaXQgc2VxMnNlcUZvcndhcmQodGhpcywgbW9kZWxfaW5wdXRzKTtcbiAgICB9XG59XG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gTTJNMTAwIG1vZGVsc1xuZXhwb3J0IGNsYXNzIE0yTTEwMFByZVRyYWluZWRNb2RlbCBleHRlbmRzIFByZVRyYWluZWRNb2RlbCB7IH07XG5cbmV4cG9ydCBjbGFzcyBNMk0xMDBNb2RlbCBleHRlbmRzIE0yTTEwMFByZVRyYWluZWRNb2RlbCB7XG4gICAgLyoqXG4gICAgICogXG4gICAgICogQHBhcmFtICB7Li4uYW55fSBhcmdzIFxuICAgICAqIEB0aHJvd3Mge0Vycm9yfVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPGFueT59XG4gICAgICovXG4gICAgYXN5bmMgZ2VuZXJhdGUoLi4uYXJncykge1xuICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgIFwiVGhlIGN1cnJlbnQgbW9kZWwgY2xhc3MgKE0yTTEwME1vZGVsKSBpcyBub3QgY29tcGF0aWJsZSB3aXRoIGAuZ2VuZXJhdGUoKWAsIGFzIGl0IGRvZXNuJ3QgaGF2ZSBhIGxhbmd1YWdlIG1vZGVsIGhlYWQuIFBsZWFzZSB1c2Ugb25lIG9mIHRoZSBmb2xsb3dpbmcgY2xhc3NlcyBpbnN0ZWFkOiB7J00yTTEwMEZvckNvbmRpdGlvbmFsR2VuZXJhdGlvbid9XCJcbiAgICAgICAgKVxuICAgIH1cbn1cblxuZXhwb3J0IGNsYXNzIE0yTTEwMEZvckNvbmRpdGlvbmFsR2VuZXJhdGlvbiBleHRlbmRzIE0yTTEwMFByZVRyYWluZWRNb2RlbCB7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIHRoZSBgTTJNMTAwRm9yQ29uZGl0aW9uYWxHZW5lcmF0aW9uYCBjbGFzcy5cbiAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgVGhlIG1vZGVsIGNvbmZpZ3VyYXRpb24gb2JqZWN0LlxuICAgICogQHBhcmFtIHtPYmplY3R9IHNlc3Npb24gVGhlIE9OTlggc2Vzc2lvbiBvYmplY3QuXG4gICAgKiBAcGFyYW0ge2FueX0gZGVjb2Rlcl9tZXJnZWRfc2Vzc2lvbiBcbiAgICAqIEBwYXJhbSB7YW55fSBnZW5lcmF0aW9uX2NvbmZpZyBcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZywgc2Vzc2lvbiwgZGVjb2Rlcl9tZXJnZWRfc2Vzc2lvbiwgZ2VuZXJhdGlvbl9jb25maWcpIHtcbiAgICAgICAgc3VwZXIoY29uZmlnLCBzZXNzaW9uKTtcbiAgICAgICAgdGhpcy5kZWNvZGVyX21lcmdlZF9zZXNzaW9uID0gZGVjb2Rlcl9tZXJnZWRfc2Vzc2lvbjtcbiAgICAgICAgdGhpcy5nZW5lcmF0aW9uX2NvbmZpZyA9IGdlbmVyYXRpb25fY29uZmlnO1xuXG4gICAgICAgIHRoaXMubnVtX2RlY29kZXJfbGF5ZXJzID0gdGhpcy5jb25maWcuZGVjb2Rlcl9sYXllcnM7XG4gICAgICAgIHRoaXMubnVtX2RlY29kZXJfaGVhZHMgPSB0aGlzLmNvbmZpZy5kZWNvZGVyX2F0dGVudGlvbl9oZWFkcztcbiAgICAgICAgdGhpcy5kZWNvZGVyX2RpbV9rdiA9IHRoaXMuY29uZmlnLmRfbW9kZWwgLyB0aGlzLm51bV9kZWNvZGVyX2hlYWRzO1xuXG4gICAgICAgIHRoaXMubnVtX2VuY29kZXJfbGF5ZXJzID0gdGhpcy5jb25maWcuZW5jb2Rlcl9sYXllcnM7XG4gICAgICAgIHRoaXMubnVtX2VuY29kZXJfaGVhZHMgPSB0aGlzLmNvbmZpZy5lbmNvZGVyX2F0dGVudGlvbl9oZWFkcztcbiAgICAgICAgdGhpcy5lbmNvZGVyX2RpbV9rdiA9IHRoaXMuY29uZmlnLmRfbW9kZWwgLyB0aGlzLm51bV9lbmNvZGVyX2hlYWRzO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgYW5kIHJldHVybnMgdGhlIGJlYW0gZm9yIHRleHQgZ2VuZXJhdGlvbiB0YXNrXG4gICAgICogQHBhcmFtIHthbnlbXX0gaW5wdXRzIFRoZSBpbnB1dCB0b2tlbiBpZHMuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG51bU91dHB1dFRva2VucyBUaGUgbnVtYmVyIG9mIHRva2VucyB0byBiZSBnZW5lcmF0ZWQuXG4gICAgICogQHJldHVybnMge2FueX0gQSBCZWFtIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIGluaXRpYWxpemVkIGJlYW0uXG4gICAgICogQHBhcmFtIHthbnlbXX0gYXJnc1xuICAgICAqL1xuICAgIGdldFN0YXJ0QmVhbXMoaW5wdXRzLCBudW1PdXRwdXRUb2tlbnMsIC4uLmFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIHNlcTJzZXFTdGFydEJlYW1zKHRoaXMsIGlucHV0cywgbnVtT3V0cHV0VG9rZW5zKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSdW5zIGEgc2luZ2xlIHN0ZXAgb2YgdGhlIGJlYW0gc2VhcmNoIGdlbmVyYXRpb24gYWxnb3JpdGhtLlxuICAgICAqIEBwYXJhbSB7YW55fSBiZWFtIFRoZSBjdXJyZW50IGJlYW0gYmVpbmcgZ2VuZXJhdGVkLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPGFueT59IFRoZSB1cGRhdGVkIGJlYW0gYWZ0ZXIgYSBzaW5nbGUgZ2VuZXJhdGlvbiBzdGVwLlxuICAgICAqL1xuICAgIGFzeW5jIHJ1bkJlYW0oYmVhbSkge1xuICAgICAgICByZXR1cm4gYXdhaXQgc2VxMnNlcVJ1bkJlYW0odGhpcywgYmVhbSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHthbnl9IGJlYW1cbiAgICAgKiBAcGFyYW0ge2FueX0gbmV3VG9rZW5JZFxuICAgICAqL1xuICAgIHVwZGF0ZUJlYW0oYmVhbSwgbmV3VG9rZW5JZCkge1xuICAgICAgICBiZWFtLm91dHB1dF90b2tlbl9pZHMgPSBbLi4uYmVhbS5vdXRwdXRfdG9rZW5faWRzLCBuZXdUb2tlbklkXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge2FueX0gbW9kZWxfaW5wdXRzXG4gICAgICogQHJldHVybnMge1Byb21pc2U8U2VxMlNlcUxNT3V0cHV0Pn1cbiAgICAgKi9cbiAgICBhc3luYyBmb3J3YXJkKG1vZGVsX2lucHV0cykge1xuICAgICAgICByZXR1cm4gYXdhaXQgc2VxMnNlcUZvcndhcmQodGhpcywgbW9kZWxfaW5wdXRzKTtcbiAgICB9XG59XG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBBdXRvTW9kZWxzLCB1c2VkIHRvIHNpbXBsaWZ5IGNvbnN0cnVjdGlvbiBvZiBQcmVUcmFpbmVkTW9kZWxzXG4vLyAodXNlcyBjb25maWcgdG8gaW5zdGFudGlhdGUgY29ycmVjdCBjbGFzcylcblxuLyoqXG4gKiBCYXNlIGNsYXNzIG9mIGFsbCBBdXRvTW9kZWxzLiBDb250YWlucyB0aGUgYGZyb21fcHJldHJhaW5lZGAgZnVuY3Rpb25cbiAqIHdoaWNoIGlzIHVzZWQgdG8gaW5zdGFudGlhdGUgcHJldHJhaW5lZCBtb2RlbHMuXG4gKi9cbmV4cG9ydCBjbGFzcyBQcmV0cmFpbmVkTWl4aW4ge1xuICAgIC8qKlxuICAgICAqIE1hcHBpbmcgZnJvbSBtb2RlbCB0eXBlIHRvIG1vZGVsIGNsYXNzLlxuICAgICAqIEB0eXBlIHtNYXA8c3RyaW5nLCBPYmplY3Q+W119XG4gICAgICovXG4gICAgc3RhdGljIE1PREVMX0NMQVNTX01BUFBJTkdTID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdG8gYXR0ZW1wdCB0byBpbnN0YW50aWF0ZSB0aGUgYmFzZSBjbGFzcyAoYFByZXRyYWluZWRNb2RlbGApIGlmIFxuICAgICAqIHRoZSBtb2RlbCB0eXBlIGlzIG5vdCBmb3VuZCBpbiB0aGUgbWFwcGluZy5cbiAgICAgKi9cbiAgICBzdGF0aWMgQkFTRV9JRl9GQUlMID0gZmFsc2U7XG5cblxuICAgIC8qKiBAdHlwZSB7UHJlVHJhaW5lZE1vZGVsLmZyb21fcHJldHJhaW5lZH0gKi9cbiAgICBzdGF0aWMgYXN5bmMgZnJvbV9wcmV0cmFpbmVkKHByZXRyYWluZWRfbW9kZWxfbmFtZV9vcl9wYXRoLCB7XG4gICAgICAgIHF1YW50aXplZCA9IHRydWUsXG4gICAgICAgIHByb2dyZXNzX2NhbGxiYWNrID0gbnVsbCxcbiAgICAgICAgY29uZmlnID0gbnVsbCxcbiAgICAgICAgY2FjaGVfZGlyID0gbnVsbCxcbiAgICAgICAgbG9jYWxfZmlsZXNfb25seSA9IGZhbHNlLFxuICAgICAgICByZXZpc2lvbiA9ICdtYWluJyxcbiAgICB9ID0ge30pIHtcblxuICAgICAgICBsZXQgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIHF1YW50aXplZCxcbiAgICAgICAgICAgIHByb2dyZXNzX2NhbGxiYWNrLFxuICAgICAgICAgICAgY29uZmlnLFxuICAgICAgICAgICAgY2FjaGVfZGlyLFxuICAgICAgICAgICAgbG9jYWxfZmlsZXNfb25seSxcbiAgICAgICAgICAgIHJldmlzaW9uLFxuICAgICAgICB9XG4gICAgICAgIGNvbmZpZyA9IGF3YWl0IEF1dG9Db25maWcuZnJvbV9wcmV0cmFpbmVkKHByZXRyYWluZWRfbW9kZWxfbmFtZV9vcl9wYXRoLCBvcHRpb25zKTtcblxuICAgICAgICBpZiAoIXRoaXMuTU9ERUxfQ0xBU1NfTUFQUElOR1MpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImBNT0RFTF9DTEFTU19NQVBQSU5HU2Agbm90IGltcGxlbWVudGVkIGZvciB0aGlzIHR5cGUgb2YgYEF1dG9DbGFzc2A6IFwiICsgdGhpcy5uYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBtb2RlbENsYXNzO1xuICAgICAgICBmb3IgKGxldCBNT0RFTF9DTEFTU19NQVBQSU5HIG9mIHRoaXMuTU9ERUxfQ0xBU1NfTUFQUElOR1MpIHtcbiAgICAgICAgICAgIG1vZGVsQ2xhc3MgPSBNT0RFTF9DTEFTU19NQVBQSU5HLmdldChjb25maWcubW9kZWxfdHlwZSk7XG4gICAgICAgICAgICBpZiAoIW1vZGVsQ2xhc3MpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTsgLy8gSXRlbSBub3QgZm91bmQgaW4gdGhpcyBtYXBwaW5nXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBhd2FpdCBtb2RlbENsYXNzLmZyb21fcHJldHJhaW5lZChwcmV0cmFpbmVkX21vZGVsX25hbWVfb3JfcGF0aCwgb3B0aW9ucyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5CQVNFX0lGX0ZBSUwpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgVW5rbm93biBtb2RlbCBjbGFzcyBcIiR7Y29uZmlnLm1vZGVsX3R5cGV9XCIsIGF0dGVtcHRpbmcgdG8gY29uc3RydWN0IGZyb20gYmFzZSBjbGFzcy5gKTtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCBQcmVUcmFpbmVkTW9kZWwuZnJvbV9wcmV0cmFpbmVkKHByZXRyYWluZWRfbW9kZWxfbmFtZV9vcl9wYXRoLCBvcHRpb25zKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKGBVbnN1cHBvcnRlZCBtb2RlbCB0eXBlOiAke2NvbmZpZy5tb2RlbF90eXBlfWApXG4gICAgICAgIH1cbiAgICB9XG59XG5cbmNvbnN0IE1PREVMX01BUFBJTkdfTkFNRVNfRU5DT0RFUl9PTkxZID0gbmV3IE1hcChbXG4gICAgWydiZXJ0JywgQmVydE1vZGVsXSxcbiAgICBbJ2FsYmVydCcsIEFsYmVydE1vZGVsXSxcbiAgICBbJ2Rpc3RpbGJlcnQnLCBEaXN0aWxCZXJ0TW9kZWxdLFxuICAgIFsncm9iZXJ0YScsIFJvYmVydGFNb2RlbF0sXG4gICAgWyd4bG0tcm9iZXJ0YScsIFhMTVJvYmVydGFNb2RlbF0sXG4gICAgWydjbGlwJywgQ0xJUE1vZGVsXSxcbiAgICBbJ21vYmlsZWJlcnQnLCBNb2JpbGVCZXJ0TW9kZWxdLFxuICAgIFsnc3F1ZWV6ZWJlcnQnLCBTcXVlZXplQmVydE1vZGVsXSxcblxuICAgIFsnc2FtJywgU2FtTW9kZWxdLCAvLyBUT0RPIGNoYW5nZSB0byBlbmNvZGVyLWRlY29kZXIgd2hlbiBtb2RlbCBpcyBzcGxpdCBjb3JyZWN0bHlcbl0pO1xuXG5jb25zdCBNT0RFTF9NQVBQSU5HX05BTUVTX0VOQ09ERVJfREVDT0RFUiA9IG5ldyBNYXAoW1xuICAgIFsndDUnLCBUNU1vZGVsXSxcbiAgICBbJ210NScsIE1UNU1vZGVsXSxcbiAgICBbJ2JhcnQnLCBCYXJ0TW9kZWxdLFxuICAgIFsnbWFyaWFuJywgTWFyaWFuTW9kZWxdLFxuICAgIFsnd2hpc3BlcicsIFdoaXNwZXJNb2RlbF0sXG4gICAgWydtMm1fMTAwJywgTTJNMTAwTW9kZWxdLFxuXSk7XG5cblxuY29uc3QgTU9ERUxfTUFQUElOR19OQU1FU19ERUNPREVSX09OTFkgPSBuZXcgTWFwKFtcbiAgICBbJ2dwdDInLCBHUFQyTW9kZWxdLFxuICAgIFsnZ3B0X25lbycsIEdQVE5lb01vZGVsXSxcbiAgICBbJ2NvZGVnZW4nLCBDb2RlR2VuTW9kZWxdLFxuXSk7XG5cbmNvbnN0IE1PREVMX0ZPUl9TRVFVRU5DRV9DTEFTU0lGSUNBVElPTl9NQVBQSU5HX05BTUVTID0gbmV3IE1hcChbXG4gICAgWydiZXJ0JywgQmVydEZvclNlcXVlbmNlQ2xhc3NpZmljYXRpb25dLFxuICAgIFsnYWxiZXJ0JywgQWxiZXJ0Rm9yU2VxdWVuY2VDbGFzc2lmaWNhdGlvbl0sXG4gICAgWydkaXN0aWxiZXJ0JywgRGlzdGlsQmVydEZvclNlcXVlbmNlQ2xhc3NpZmljYXRpb25dLFxuICAgIFsncm9iZXJ0YScsIFJvYmVydGFGb3JTZXF1ZW5jZUNsYXNzaWZpY2F0aW9uXSxcbiAgICBbJ3hsbS1yb2JlcnRhJywgWExNUm9iZXJ0YUZvclNlcXVlbmNlQ2xhc3NpZmljYXRpb25dLFxuICAgIFsnYmFydCcsIEJhcnRGb3JTZXF1ZW5jZUNsYXNzaWZpY2F0aW9uXSxcbiAgICBbJ21vYmlsZWJlcnQnLCBNb2JpbGVCZXJ0Rm9yU2VxdWVuY2VDbGFzc2lmaWNhdGlvbl0sXG4gICAgWydzcXVlZXplYmVydCcsIFNxdWVlemVCZXJ0Rm9yU2VxdWVuY2VDbGFzc2lmaWNhdGlvbl0sXG5dKTtcblxuY29uc3QgTU9ERUxfRk9SX1RPS0VOX0NMQVNTSUZJQ0FUSU9OX01BUFBJTkdfTkFNRVMgPSBuZXcgTWFwKFtcbiAgICBbJ2JlcnQnLCBCZXJ0Rm9yVG9rZW5DbGFzc2lmaWNhdGlvbl0sXG4gICAgWydkaXN0aWxiZXJ0JywgRGlzdGlsQmVydEZvclRva2VuQ2xhc3NpZmljYXRpb25dLFxuICAgIFsncm9iZXJ0YScsIFJvYmVydGFGb3JUb2tlbkNsYXNzaWZpY2F0aW9uXSxcbiAgICBbJ3hsbS1yb2JlcnRhJywgWExNUm9iZXJ0YUZvclRva2VuQ2xhc3NpZmljYXRpb25dLFxuXSk7XG5cbmNvbnN0IE1PREVMX0ZPUl9TRVFfMl9TRVFfTUFQUElOR19OQU1FUyA9IG5ldyBNYXAoW1xuICAgIFsndDUnLCBUNUZvckNvbmRpdGlvbmFsR2VuZXJhdGlvbl0sXG4gICAgWydtdDUnLCBNVDVGb3JDb25kaXRpb25hbEdlbmVyYXRpb25dLFxuICAgIFsnYmFydCcsIEJhcnRGb3JDb25kaXRpb25hbEdlbmVyYXRpb25dLFxuICAgIFsnd2hpc3BlcicsIFdoaXNwZXJGb3JDb25kaXRpb25hbEdlbmVyYXRpb25dLFxuICAgIFsnbWFyaWFuJywgTWFyaWFuTVRNb2RlbF0sXG4gICAgWydtMm1fMTAwJywgTTJNMTAwRm9yQ29uZGl0aW9uYWxHZW5lcmF0aW9uXSxcbl0pO1xuXG5jb25zdCBNT0RFTF9XSVRIX0xNX0hFQURfTUFQUElOR19OQU1FUyA9IG5ldyBNYXAoW1xuICAgIFsnZ3B0MicsIEdQVDJMTUhlYWRNb2RlbF0sXG4gICAgWydncHRfbmVvJywgR1BUTmVvRm9yQ2F1c2FsTE1dLFxuICAgIFsnY29kZWdlbicsIENvZGVHZW5Gb3JDYXVzYWxMTV0sXG5dKTtcblxuY29uc3QgTU9ERUxfRk9SX01BU0tFRF9MTV9NQVBQSU5HX05BTUVTID0gbmV3IE1hcChbXG4gICAgWydiZXJ0JywgQmVydEZvck1hc2tlZExNXSxcbiAgICBbJ2FsYmVydCcsIEFsYmVydEZvck1hc2tlZExNXSxcbiAgICBbJ2Rpc3RpbGJlcnQnLCBEaXN0aWxCZXJ0Rm9yTWFza2VkTE1dLFxuICAgIFsncm9iZXJ0YScsIFJvYmVydGFGb3JNYXNrZWRMTV0sXG4gICAgWyd4bG0tcm9iZXJ0YScsIFhMTVJvYmVydGFGb3JNYXNrZWRMTV0sXG4gICAgWydtb2JpbGViZXJ0JywgTW9iaWxlQmVydEZvck1hc2tlZExNXSxcbiAgICBbJ3NxdWVlemViZXJ0JywgU3F1ZWV6ZUJlcnRGb3JNYXNrZWRMTV0sXG5dKTtcblxuY29uc3QgTU9ERUxfRk9SX1FVRVNUSU9OX0FOU1dFUklOR19NQVBQSU5HX05BTUVTID0gbmV3IE1hcChbXG4gICAgWydiZXJ0JywgQmVydEZvclF1ZXN0aW9uQW5zd2VyaW5nXSxcbiAgICBbJ2FsYmVydCcsIEFsYmVydEZvclF1ZXN0aW9uQW5zd2VyaW5nXSxcbiAgICBbJ2Rpc3RpbGJlcnQnLCBEaXN0aWxCZXJ0Rm9yUXVlc3Rpb25BbnN3ZXJpbmddLFxuICAgIFsncm9iZXJ0YScsIFJvYmVydGFGb3JRdWVzdGlvbkFuc3dlcmluZ10sXG4gICAgWyd4bG0tcm9iZXJ0YScsIFhMTVJvYmVydGFGb3JRdWVzdGlvbkFuc3dlcmluZ10sXG4gICAgWydtb2JpbGViZXJ0JywgTW9iaWxlQmVydEZvclF1ZXN0aW9uQW5zd2VyaW5nXSxcbiAgICBbJ3NxdWVlemViZXJ0JywgU3F1ZWV6ZUJlcnRGb3JRdWVzdGlvbkFuc3dlcmluZ10sXG5dKTtcblxuY29uc3QgTU9ERUxfRk9SX1ZJU0lPTl8yX1NFUV9NQVBQSU5HX05BTUVTID0gbmV3IE1hcChbXG4gICAgWyd2aXNpb24tZW5jb2Rlci1kZWNvZGVyJywgVmlzaW9uRW5jb2RlckRlY29kZXJNb2RlbF0sXG5dKTtcblxuY29uc3QgTU9ERUxfRk9SX0lNQUdFX0NMQVNTSUZJQ0FUSU9OX01BUFBJTkdfTkFNRVMgPSBuZXcgTWFwKFtcbiAgICBbJ3ZpdCcsIFZpVEZvckltYWdlQ2xhc3NpZmljYXRpb25dLFxuICAgIFsnbW9iaWxldml0JywgTW9iaWxlVmlURm9ySW1hZ2VDbGFzc2lmaWNhdGlvbl0sXG5dKTtcblxuY29uc3QgTU9ERUxfRk9SX09CSkVDVF9ERVRFQ1RJT05fTUFQUElOR19OQU1FUyA9IG5ldyBNYXAoW1xuICAgIFsnZGV0cicsIERldHJGb3JPYmplY3REZXRlY3Rpb25dLFxuXSk7XG5cbmNvbnN0IE1PREVMX0ZPUl9JTUFHRV9TRUdNRU5UQVRJT05fTUFQUElOR19OQU1FUyA9IG5ldyBNYXAoW1xuICAgIFsnZGV0cicsIERldHJGb3JTZWdtZW50YXRpb25dLFxuXSk7XG5cbmNvbnN0IE1PREVMX0ZPUl9NQVNLX0dFTkVSQVRJT05fTUFQUElOR19OQU1FUyA9IG5ldyBNYXAoW1xuICAgIFsnc2FtJywgU2FtTW9kZWxdLFxuXSk7XG5cbmNvbnN0IE1PREVMX0NMQVNTX1RZUEVfTUFQUElORyA9IFtcbiAgICBbTU9ERUxfTUFQUElOR19OQU1FU19FTkNPREVSX09OTFksIEVuY29kZXJPbmx5TW9kZWxUeXBlXSxcbiAgICBbTU9ERUxfTUFQUElOR19OQU1FU19FTkNPREVSX0RFQ09ERVIsIEVuY29kZXJEZWNvZGVyTW9kZWxUeXBlXSxcbiAgICBbTU9ERUxfTUFQUElOR19OQU1FU19ERUNPREVSX09OTFksIERlY29kZXJPbmx5TW9kZWxUeXBlXSxcbiAgICBbTU9ERUxfRk9SX1NFUVVFTkNFX0NMQVNTSUZJQ0FUSU9OX01BUFBJTkdfTkFNRVMsIEVuY29kZXJPbmx5TW9kZWxUeXBlXSxcbiAgICBbTU9ERUxfRk9SX1RPS0VOX0NMQVNTSUZJQ0FUSU9OX01BUFBJTkdfTkFNRVMsIEVuY29kZXJPbmx5TW9kZWxUeXBlXSxcbiAgICBbTU9ERUxfRk9SX1NFUV8yX1NFUV9NQVBQSU5HX05BTUVTLCBTZXEyU2VxTW9kZWxUeXBlXSxcbiAgICBbTU9ERUxfV0lUSF9MTV9IRUFEX01BUFBJTkdfTkFNRVMsIERlY29kZXJPbmx5TW9kZWxUeXBlXSxcbiAgICBbTU9ERUxfRk9SX01BU0tFRF9MTV9NQVBQSU5HX05BTUVTLCBFbmNvZGVyT25seU1vZGVsVHlwZV0sXG4gICAgW01PREVMX0ZPUl9RVUVTVElPTl9BTlNXRVJJTkdfTUFQUElOR19OQU1FUywgRW5jb2Rlck9ubHlNb2RlbFR5cGVdLFxuICAgIFtNT0RFTF9GT1JfVklTSU9OXzJfU0VRX01BUFBJTkdfTkFNRVMsIEVuY29kZXJEZWNvZGVyTW9kZWxUeXBlXSxcbiAgICBbTU9ERUxfRk9SX0lNQUdFX0NMQVNTSUZJQ0FUSU9OX01BUFBJTkdfTkFNRVMsIEVuY29kZXJPbmx5TW9kZWxUeXBlXSxcbiAgICBbTU9ERUxfRk9SX0lNQUdFX1NFR01FTlRBVElPTl9NQVBQSU5HX05BTUVTLCBFbmNvZGVyT25seU1vZGVsVHlwZV0sXG4gICAgW01PREVMX0ZPUl9PQkpFQ1RfREVURUNUSU9OX01BUFBJTkdfTkFNRVMsIEVuY29kZXJPbmx5TW9kZWxUeXBlXSxcbiAgICBbTU9ERUxfRk9SX01BU0tfR0VORVJBVElPTl9NQVBQSU5HX05BTUVTLCBFbmNvZGVyT25seU1vZGVsVHlwZV0sXG5dO1xuXG5mb3IgKGxldCBbbWFwcGluZ3MsIHR5cGVdIG9mIE1PREVMX0NMQVNTX1RZUEVfTUFQUElORykge1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBmb3IgKGxldCBbbmFtZSwgbW9kZWxdIG9mIG1hcHBpbmdzLmVudHJpZXMoKSkge1xuICAgICAgICBNT0RFTF9UWVBFX01BUFBJTkcuc2V0KG1vZGVsLm5hbWUsIHR5cGUpO1xuICAgICAgICBNT0RFTF9DTEFTU19NQVBQSU5HLnNldChtb2RlbC5uYW1lLCBuYW1lKTtcbiAgICB9XG59XG5cbi8qKlxuICogSGVscGVyIGNsYXNzIHdoaWNoIGlzIHVzZWQgdG8gaW5zdGFudGlhdGUgcHJldHJhaW5lZCBtb2RlbHMgd2l0aCB0aGUgYGZyb21fcHJldHJhaW5lZGAgZnVuY3Rpb24uXG4gKiBUaGUgY2hvc2VuIG1vZGVsIGNsYXNzIGlzIGRldGVybWluZWQgYnkgdGhlIHR5cGUgc3BlY2lmaWVkIGluIHRoZSBtb2RlbCBjb25maWcuXG4gKiBcbiAqIEBleGFtcGxlXG4gKiBsZXQgbW9kZWwgPSBhd2FpdCBBdXRvTW9kZWwuZnJvbV9wcmV0cmFpbmVkKCdiZXJ0LWJhc2UtdW5jYXNlZCcpO1xuICovXG5leHBvcnQgY2xhc3MgQXV0b01vZGVsIGV4dGVuZHMgUHJldHJhaW5lZE1peGluIHtcbiAgICBzdGF0aWMgTU9ERUxfQ0xBU1NfTUFQUElOR1MgPSBbTU9ERUxfTUFQUElOR19OQU1FU19FTkNPREVSX09OTFksIE1PREVMX01BUFBJTkdfTkFNRVNfRU5DT0RFUl9ERUNPREVSLCBNT0RFTF9NQVBQSU5HX05BTUVTX0RFQ09ERVJfT05MWV07XG4gICAgc3RhdGljIEJBU0VfSUZfRkFJTCA9IHRydWU7XG59XG5cbi8qKlxuICogSGVscGVyIGNsYXNzIHdoaWNoIGlzIHVzZWQgdG8gaW5zdGFudGlhdGUgcHJldHJhaW5lZCBzZXF1ZW5jZSBjbGFzc2lmaWNhdGlvbiBtb2RlbHMgd2l0aCB0aGUgYGZyb21fcHJldHJhaW5lZGAgZnVuY3Rpb24uXG4gKiBUaGUgY2hvc2VuIG1vZGVsIGNsYXNzIGlzIGRldGVybWluZWQgYnkgdGhlIHR5cGUgc3BlY2lmaWVkIGluIHRoZSBtb2RlbCBjb25maWcuXG4gKiBcbiAqIEBleGFtcGxlXG4gKiBsZXQgbW9kZWwgPSBhd2FpdCBBdXRvTW9kZWxGb3JTZXF1ZW5jZUNsYXNzaWZpY2F0aW9uLmZyb21fcHJldHJhaW5lZCgnZGlzdGlsYmVydC1iYXNlLXVuY2FzZWQtZmluZXR1bmVkLXNzdC0yLWVuZ2xpc2gnKTtcbiAqL1xuZXhwb3J0IGNsYXNzIEF1dG9Nb2RlbEZvclNlcXVlbmNlQ2xhc3NpZmljYXRpb24gZXh0ZW5kcyBQcmV0cmFpbmVkTWl4aW4ge1xuICAgIHN0YXRpYyBNT0RFTF9DTEFTU19NQVBQSU5HUyA9IFtNT0RFTF9GT1JfU0VRVUVOQ0VfQ0xBU1NJRklDQVRJT05fTUFQUElOR19OQU1FU107XG59XG5cbi8qKlxuICogSGVscGVyIGNsYXNzIHdoaWNoIGlzIHVzZWQgdG8gaW5zdGFudGlhdGUgcHJldHJhaW5lZCB0b2tlbiBjbGFzc2lmaWNhdGlvbiBtb2RlbHMgd2l0aCB0aGUgYGZyb21fcHJldHJhaW5lZGAgZnVuY3Rpb24uXG4gKiBUaGUgY2hvc2VuIG1vZGVsIGNsYXNzIGlzIGRldGVybWluZWQgYnkgdGhlIHR5cGUgc3BlY2lmaWVkIGluIHRoZSBtb2RlbCBjb25maWcuXG4gKiBcbiAqIEBleGFtcGxlXG4gKiBsZXQgbW9kZWwgPSBhd2FpdCBBdXRvTW9kZWxGb3JUb2tlbkNsYXNzaWZpY2F0aW9uLmZyb21fcHJldHJhaW5lZCgnRGF2bGFuL2Rpc3RpbGJlcnQtYmFzZS1tdWx0aWxpbmd1YWwtY2FzZWQtbmVyLWhybCcpO1xuICovXG5leHBvcnQgY2xhc3MgQXV0b01vZGVsRm9yVG9rZW5DbGFzc2lmaWNhdGlvbiBleHRlbmRzIFByZXRyYWluZWRNaXhpbiB7XG4gICAgc3RhdGljIE1PREVMX0NMQVNTX01BUFBJTkdTID0gW01PREVMX0ZPUl9UT0tFTl9DTEFTU0lGSUNBVElPTl9NQVBQSU5HX05BTUVTXTtcbn1cblxuLyoqXG4gKiBIZWxwZXIgY2xhc3Mgd2hpY2ggaXMgdXNlZCB0byBpbnN0YW50aWF0ZSBwcmV0cmFpbmVkIHNlcXVlbmNlLXRvLXNlcXVlbmNlIG1vZGVscyB3aXRoIHRoZSBgZnJvbV9wcmV0cmFpbmVkYCBmdW5jdGlvbi5cbiAqIFRoZSBjaG9zZW4gbW9kZWwgY2xhc3MgaXMgZGV0ZXJtaW5lZCBieSB0aGUgdHlwZSBzcGVjaWZpZWQgaW4gdGhlIG1vZGVsIGNvbmZpZy5cbiAqIFxuICogQGV4YW1wbGVcbiAqIGxldCBtb2RlbCA9IGF3YWl0IEF1dG9Nb2RlbEZvclNlcTJTZXFMTS5mcm9tX3ByZXRyYWluZWQoJ3Q1LXNtYWxsJyk7XG4gKi9cbmV4cG9ydCBjbGFzcyBBdXRvTW9kZWxGb3JTZXEyU2VxTE0gZXh0ZW5kcyBQcmV0cmFpbmVkTWl4aW4ge1xuICAgIHN0YXRpYyBNT0RFTF9DTEFTU19NQVBQSU5HUyA9IFtNT0RFTF9GT1JfU0VRXzJfU0VRX01BUFBJTkdfTkFNRVNdO1xufVxuXG4vKipcbiAqIEhlbHBlciBjbGFzcyB3aGljaCBpcyB1c2VkIHRvIGluc3RhbnRpYXRlIHByZXRyYWluZWQgY2F1c2FsIGxhbmd1YWdlIG1vZGVscyB3aXRoIHRoZSBgZnJvbV9wcmV0cmFpbmVkYCBmdW5jdGlvbi5cbiAqIFRoZSBjaG9zZW4gbW9kZWwgY2xhc3MgaXMgZGV0ZXJtaW5lZCBieSB0aGUgdHlwZSBzcGVjaWZpZWQgaW4gdGhlIG1vZGVsIGNvbmZpZy5cbiAqIFxuICogQGV4YW1wbGVcbiAqIGxldCBtb2RlbCA9IGF3YWl0IEF1dG9Nb2RlbEZvckNhdXNhbExNLmZyb21fcHJldHJhaW5lZCgnZ3B0MicpO1xuICovXG5leHBvcnQgY2xhc3MgQXV0b01vZGVsRm9yQ2F1c2FsTE0gZXh0ZW5kcyBQcmV0cmFpbmVkTWl4aW4ge1xuICAgIHN0YXRpYyBNT0RFTF9DTEFTU19NQVBQSU5HUyA9IFtNT0RFTF9XSVRIX0xNX0hFQURfTUFQUElOR19OQU1FU107XG59XG5cbi8qKlxuICogSGVscGVyIGNsYXNzIHdoaWNoIGlzIHVzZWQgdG8gaW5zdGFudGlhdGUgcHJldHJhaW5lZCBtYXNrZWQgbGFuZ3VhZ2UgbW9kZWxzIHdpdGggdGhlIGBmcm9tX3ByZXRyYWluZWRgIGZ1bmN0aW9uLlxuICogVGhlIGNob3NlbiBtb2RlbCBjbGFzcyBpcyBkZXRlcm1pbmVkIGJ5IHRoZSB0eXBlIHNwZWNpZmllZCBpbiB0aGUgbW9kZWwgY29uZmlnLlxuICogXG4gKiBAZXhhbXBsZVxuICogbGV0IG1vZGVsID0gYXdhaXQgQXV0b01vZGVsRm9yTWFza2VkTE0uZnJvbV9wcmV0cmFpbmVkKCdiZXJ0LWJhc2UtdW5jYXNlZCcpO1xuICovXG5leHBvcnQgY2xhc3MgQXV0b01vZGVsRm9yTWFza2VkTE0gZXh0ZW5kcyBQcmV0cmFpbmVkTWl4aW4ge1xuICAgIHN0YXRpYyBNT0RFTF9DTEFTU19NQVBQSU5HUyA9IFtNT0RFTF9GT1JfTUFTS0VEX0xNX01BUFBJTkdfTkFNRVNdO1xufVxuXG4vKipcbiAqIEhlbHBlciBjbGFzcyB3aGljaCBpcyB1c2VkIHRvIGluc3RhbnRpYXRlIHByZXRyYWluZWQgcXVlc3Rpb24gYW5zd2VyaW5nIG1vZGVscyB3aXRoIHRoZSBgZnJvbV9wcmV0cmFpbmVkYCBmdW5jdGlvbi5cbiAqIFRoZSBjaG9zZW4gbW9kZWwgY2xhc3MgaXMgZGV0ZXJtaW5lZCBieSB0aGUgdHlwZSBzcGVjaWZpZWQgaW4gdGhlIG1vZGVsIGNvbmZpZy5cbiAqIFxuICogQGV4YW1wbGVcbiAqIGxldCBtb2RlbCA9IGF3YWl0IEF1dG9Nb2RlbEZvclF1ZXN0aW9uQW5zd2VyaW5nLmZyb21fcHJldHJhaW5lZCgnZGlzdGlsYmVydC1iYXNlLWNhc2VkLWRpc3RpbGxlZC1zcXVhZCcpO1xuICovXG5leHBvcnQgY2xhc3MgQXV0b01vZGVsRm9yUXVlc3Rpb25BbnN3ZXJpbmcgZXh0ZW5kcyBQcmV0cmFpbmVkTWl4aW4ge1xuICAgIHN0YXRpYyBNT0RFTF9DTEFTU19NQVBQSU5HUyA9IFtNT0RFTF9GT1JfUVVFU1RJT05fQU5TV0VSSU5HX01BUFBJTkdfTkFNRVNdO1xufVxuXG4vKipcbiAqIEhlbHBlciBjbGFzcyB3aGljaCBpcyB1c2VkIHRvIGluc3RhbnRpYXRlIHByZXRyYWluZWQgdmlzaW9uLXRvLXNlcXVlbmNlIG1vZGVscyB3aXRoIHRoZSBgZnJvbV9wcmV0cmFpbmVkYCBmdW5jdGlvbi5cbiAqIFRoZSBjaG9zZW4gbW9kZWwgY2xhc3MgaXMgZGV0ZXJtaW5lZCBieSB0aGUgdHlwZSBzcGVjaWZpZWQgaW4gdGhlIG1vZGVsIGNvbmZpZy5cbiAqIFxuICogQGV4YW1wbGVcbiAqIGxldCBtb2RlbCA9IGF3YWl0IEF1dG9Nb2RlbEZvclZpc2lvbjJTZXEuZnJvbV9wcmV0cmFpbmVkKCdubHBjb25uZWN0L3ZpdC1ncHQyLWltYWdlLWNhcHRpb25pbmcnKTtcbiAqL1xuZXhwb3J0IGNsYXNzIEF1dG9Nb2RlbEZvclZpc2lvbjJTZXEgZXh0ZW5kcyBQcmV0cmFpbmVkTWl4aW4ge1xuICAgIHN0YXRpYyBNT0RFTF9DTEFTU19NQVBQSU5HUyA9IFtNT0RFTF9GT1JfVklTSU9OXzJfU0VRX01BUFBJTkdfTkFNRVNdO1xufVxuXG4vKipcbiAqIEhlbHBlciBjbGFzcyB3aGljaCBpcyB1c2VkIHRvIGluc3RhbnRpYXRlIHByZXRyYWluZWQgaW1hZ2UgY2xhc3NpZmljYXRpb24gbW9kZWxzIHdpdGggdGhlIGBmcm9tX3ByZXRyYWluZWRgIGZ1bmN0aW9uLlxuICogVGhlIGNob3NlbiBtb2RlbCBjbGFzcyBpcyBkZXRlcm1pbmVkIGJ5IHRoZSB0eXBlIHNwZWNpZmllZCBpbiB0aGUgbW9kZWwgY29uZmlnLlxuICogXG4gKiBAZXhhbXBsZVxuICogbGV0IG1vZGVsID0gYXdhaXQgQXV0b01vZGVsRm9ySW1hZ2VDbGFzc2lmaWNhdGlvbi5mcm9tX3ByZXRyYWluZWQoJ2dvb2dsZS92aXQtYmFzZS1wYXRjaDE2LTIyNCcpO1xuICovXG5leHBvcnQgY2xhc3MgQXV0b01vZGVsRm9ySW1hZ2VDbGFzc2lmaWNhdGlvbiBleHRlbmRzIFByZXRyYWluZWRNaXhpbiB7XG4gICAgc3RhdGljIE1PREVMX0NMQVNTX01BUFBJTkdTID0gW01PREVMX0ZPUl9JTUFHRV9DTEFTU0lGSUNBVElPTl9NQVBQSU5HX05BTUVTXTtcbn1cblxuLyoqXG4gKiBIZWxwZXIgY2xhc3Mgd2hpY2ggaXMgdXNlZCB0byBpbnN0YW50aWF0ZSBwcmV0cmFpbmVkIGltYWdlIHNlZ21lbnRhdGlvbiBtb2RlbHMgd2l0aCB0aGUgYGZyb21fcHJldHJhaW5lZGAgZnVuY3Rpb24uXG4gKiBUaGUgY2hvc2VuIG1vZGVsIGNsYXNzIGlzIGRldGVybWluZWQgYnkgdGhlIHR5cGUgc3BlY2lmaWVkIGluIHRoZSBtb2RlbCBjb25maWcuXG4gKiBcbiAqIEBleGFtcGxlXG4gKiBsZXQgbW9kZWwgPSBhd2FpdCBBdXRvTW9kZWxGb3JJbWFnZVNlZ21lbnRhdGlvbi5mcm9tX3ByZXRyYWluZWQoJ2ZhY2Vib29rL2RldHItcmVzbmV0LTUwLXBhbm9wdGljJyk7XG4gKi9cbmV4cG9ydCBjbGFzcyBBdXRvTW9kZWxGb3JJbWFnZVNlZ21lbnRhdGlvbiBleHRlbmRzIFByZXRyYWluZWRNaXhpbiB7XG4gICAgc3RhdGljIE1PREVMX0NMQVNTX01BUFBJTkdTID0gW01PREVMX0ZPUl9JTUFHRV9TRUdNRU5UQVRJT05fTUFQUElOR19OQU1FU107XG59XG5cbi8qKlxuICogSGVscGVyIGNsYXNzIHdoaWNoIGlzIHVzZWQgdG8gaW5zdGFudGlhdGUgcHJldHJhaW5lZCBvYmplY3QgZGV0ZWN0aW9uIG1vZGVscyB3aXRoIHRoZSBgZnJvbV9wcmV0cmFpbmVkYCBmdW5jdGlvbi5cbiAqIFRoZSBjaG9zZW4gbW9kZWwgY2xhc3MgaXMgZGV0ZXJtaW5lZCBieSB0aGUgdHlwZSBzcGVjaWZpZWQgaW4gdGhlIG1vZGVsIGNvbmZpZy5cbiAqIFxuICogQGV4YW1wbGVcbiAqIGxldCBtb2RlbCA9IGF3YWl0IEF1dG9Nb2RlbEZvck9iamVjdERldGVjdGlvbi5mcm9tX3ByZXRyYWluZWQoJ2ZhY2Vib29rL2RldHItcmVzbmV0LTUwJyk7XG4gKi9cbmV4cG9ydCBjbGFzcyBBdXRvTW9kZWxGb3JPYmplY3REZXRlY3Rpb24gZXh0ZW5kcyBQcmV0cmFpbmVkTWl4aW4ge1xuICAgIHN0YXRpYyBNT0RFTF9DTEFTU19NQVBQSU5HUyA9IFtNT0RFTF9GT1JfT0JKRUNUX0RFVEVDVElPTl9NQVBQSU5HX05BTUVTXTtcbn1cblxuLyoqXG4gKiBIZWxwZXIgY2xhc3Mgd2hpY2ggaXMgdXNlZCB0byBpbnN0YW50aWF0ZSBwcmV0cmFpbmVkIG9iamVjdCBkZXRlY3Rpb24gbW9kZWxzIHdpdGggdGhlIGBmcm9tX3ByZXRyYWluZWRgIGZ1bmN0aW9uLlxuICogVGhlIGNob3NlbiBtb2RlbCBjbGFzcyBpcyBkZXRlcm1pbmVkIGJ5IHRoZSB0eXBlIHNwZWNpZmllZCBpbiB0aGUgbW9kZWwgY29uZmlnLlxuICogXG4gKiBAZXhhbXBsZVxuICogbGV0IG1vZGVsID0gYXdhaXQgQXV0b01vZGVsRm9yTWFza0dlbmVyYXRpb24uZnJvbV9wcmV0cmFpbmVkKCdYZW5vdmEvc2FtLXZpdC1iYXNlJyk7XG4gKi9cbmV4cG9ydCBjbGFzcyBBdXRvTW9kZWxGb3JNYXNrR2VuZXJhdGlvbiBleHRlbmRzIFByZXRyYWluZWRNaXhpbiB7XG4gICAgc3RhdGljIE1PREVMX0NMQVNTX01BUFBJTkdTID0gW01PREVMX0ZPUl9NQVNLX0dFTkVSQVRJT05fTUFQUElOR19OQU1FU107XG59XG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuZXhwb3J0IGNsYXNzIFNlcTJTZXFMTU91dHB1dCBleHRlbmRzIE1vZGVsT3V0cHV0IHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3V0cHV0IFRoZSBvdXRwdXQgb2YgdGhlIG1vZGVsLlxuICAgICAqIEBwYXJhbSB7VGVuc29yfSBvdXRwdXQubG9naXRzIFRoZSBvdXRwdXQgbG9naXRzIG9mIHRoZSBtb2RlbC5cbiAgICAgKiBAcGFyYW0ge1RlbnNvcn0gb3V0cHV0LnBhc3Rfa2V5X3ZhbHVlcyBBbiB0ZW5zb3Igb2Yga2V5L3ZhbHVlIHBhaXJzIHRoYXQgcmVwcmVzZW50IHRoZSBwcmV2aW91cyBzdGF0ZSBvZiB0aGUgbW9kZWwuXG4gICAgICogQHBhcmFtIHtUZW5zb3J9IG91dHB1dC5lbmNvZGVyX291dHB1dHMgVGhlIG91dHB1dCBvZiB0aGUgZW5jb2RlciBpbiBhIHNlcXVlbmNlLXRvLXNlcXVlbmNlIG1vZGVsLlxuICAgICAqIEBwYXJhbSB7VGVuc29yfSBbb3V0cHV0LmRlY29kZXJfYXR0ZW50aW9uc10gQXR0ZW50aW9ucyB3ZWlnaHRzIG9mIHRoZSBkZWNvZGVyLCBhZnRlciB0aGUgYXR0ZW50aW9uIHNvZnRtYXgsIHVzZWQgdG8gY29tcHV0ZSB0aGUgd2VpZ2h0ZWQgYXZlcmFnZSBpbiB0aGUgc2VsZi1hdHRlbnRpb24gaGVhZHMuXG4gICAgICogQHBhcmFtIHtUZW5zb3J9IFtvdXRwdXQuY3Jvc3NfYXR0ZW50aW9uc10gQXR0ZW50aW9ucyB3ZWlnaHRzIG9mIHRoZSBkZWNvZGVyJ3MgY3Jvc3MtYXR0ZW50aW9uIGxheWVyLCBhZnRlciB0aGUgYXR0ZW50aW9uIHNvZnRtYXgsIHVzZWQgdG8gY29tcHV0ZSB0aGUgd2VpZ2h0ZWQgYXZlcmFnZSBpbiB0aGUgY3Jvc3MtYXR0ZW50aW9uIGhlYWRzLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHsgbG9naXRzLCBwYXN0X2tleV92YWx1ZXMsIGVuY29kZXJfb3V0cHV0cywgZGVjb2Rlcl9hdHRlbnRpb25zID0gbnVsbCwgY3Jvc3NfYXR0ZW50aW9ucyA9IG51bGwgfSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmxvZ2l0cyA9IGxvZ2l0cztcbiAgICAgICAgdGhpcy5wYXN0X2tleV92YWx1ZXMgPSBwYXN0X2tleV92YWx1ZXM7XG4gICAgICAgIHRoaXMuZW5jb2Rlcl9vdXRwdXRzID0gZW5jb2Rlcl9vdXRwdXRzO1xuICAgICAgICB0aGlzLmRlY29kZXJfYXR0ZW50aW9ucyA9IGRlY29kZXJfYXR0ZW50aW9ucztcbiAgICAgICAgdGhpcy5jcm9zc19hdHRlbnRpb25zID0gY3Jvc3NfYXR0ZW50aW9ucztcbiAgICB9XG59XG5cbi8qKlxuICogQmFzZSBjbGFzcyBmb3Igb3V0cHV0cyBvZiBzZW50ZW5jZSBjbGFzc2lmaWNhdGlvbiBtb2RlbHMuXG4gKi9cbmV4cG9ydCBjbGFzcyBTZXF1ZW5jZUNsYXNzaWZpZXJPdXRwdXQgZXh0ZW5kcyBNb2RlbE91dHB1dCB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG91dHB1dCBUaGUgb3V0cHV0IG9mIHRoZSBtb2RlbC5cbiAgICAgKiBAcGFyYW0ge1RlbnNvcn0gb3V0cHV0LmxvZ2l0cyBjbGFzc2lmaWNhdGlvbiAob3IgcmVncmVzc2lvbiBpZiBjb25maWcubnVtX2xhYmVscz09MSkgc2NvcmVzIChiZWZvcmUgU29mdE1heCkuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoeyBsb2dpdHMgfSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmxvZ2l0cyA9IGxvZ2l0cztcbiAgICB9XG59XG5cbi8qKlxuICogQmFzZSBjbGFzcyBmb3Igb3V0cHV0cyBvZiB0b2tlbiBjbGFzc2lmaWNhdGlvbiBtb2RlbHMuXG4gKi9cbmV4cG9ydCBjbGFzcyBUb2tlbkNsYXNzaWZpZXJPdXRwdXQgZXh0ZW5kcyBNb2RlbE91dHB1dCB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG91dHB1dCBUaGUgb3V0cHV0IG9mIHRoZSBtb2RlbC5cbiAgICAgKiBAcGFyYW0ge1RlbnNvcn0gb3V0cHV0LmxvZ2l0cyBDbGFzc2lmaWNhdGlvbiBzY29yZXMgKGJlZm9yZSBTb2Z0TWF4KS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih7IGxvZ2l0cyB9KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMubG9naXRzID0gbG9naXRzO1xuICAgIH1cbn1cblxuLyoqXG4gKiBCYXNlIGNsYXNzIGZvciBtYXNrZWQgbGFuZ3VhZ2UgbW9kZWxzIG91dHB1dHMuXG4gKi9cbmV4cG9ydCBjbGFzcyBNYXNrZWRMTU91dHB1dCBleHRlbmRzIE1vZGVsT3V0cHV0IHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3V0cHV0IFRoZSBvdXRwdXQgb2YgdGhlIG1vZGVsLlxuICAgICAqIEBwYXJhbSB7VGVuc29yfSBvdXRwdXQubG9naXRzIFByZWRpY3Rpb24gc2NvcmVzIG9mIHRoZSBsYW5ndWFnZSBtb2RlbGluZyBoZWFkIChzY29yZXMgZm9yIGVhY2ggdm9jYWJ1bGFyeSB0b2tlbiBiZWZvcmUgU29mdE1heCkuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoeyBsb2dpdHMgfSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmxvZ2l0cyA9IGxvZ2l0cztcbiAgICB9XG59XG5cbi8qKlxuICogQmFzZSBjbGFzcyBmb3Igb3V0cHV0cyBvZiBxdWVzdGlvbiBhbnN3ZXJpbmcgbW9kZWxzLlxuICovXG5leHBvcnQgY2xhc3MgUXVlc3Rpb25BbnN3ZXJpbmdNb2RlbE91dHB1dCBleHRlbmRzIE1vZGVsT3V0cHV0IHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3V0cHV0IFRoZSBvdXRwdXQgb2YgdGhlIG1vZGVsLlxuICAgICAqIEBwYXJhbSB7VGVuc29yfSBvdXRwdXQuc3RhcnRfbG9naXRzIFNwYW4tc3RhcnQgc2NvcmVzIChiZWZvcmUgU29mdE1heCkuXG4gICAgICogQHBhcmFtIHtUZW5zb3J9IG91dHB1dC5lbmRfbG9naXRzIFNwYW4tZW5kIHNjb3JlcyAoYmVmb3JlIFNvZnRNYXgpLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHsgc3RhcnRfbG9naXRzLCBlbmRfbG9naXRzIH0pIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5zdGFydF9sb2dpdHMgPSBzdGFydF9sb2dpdHM7XG4gICAgICAgIHRoaXMuZW5kX2xvZ2l0cyA9IGVuZF9sb2dpdHM7XG4gICAgfVxufVxuXG5cbi8qKlxuICogQmFzZSBjbGFzcyBmb3IgY2F1c2FsIGxhbmd1YWdlIG1vZGVsIChvciBhdXRvcmVncmVzc2l2ZSkgb3V0cHV0cy5cbiAqL1xuZXhwb3J0IGNsYXNzIENhdXNhbExNT3V0cHV0V2l0aFBhc3QgZXh0ZW5kcyBNb2RlbE91dHB1dCB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG91dHB1dCBUaGUgb3V0cHV0IG9mIHRoZSBtb2RlbC5cbiAgICAgKiBAcGFyYW0ge1RlbnNvcn0gb3V0cHV0LmxvZ2l0cyBQcmVkaWN0aW9uIHNjb3JlcyBvZiB0aGUgbGFuZ3VhZ2UgbW9kZWxpbmcgaGVhZCAoc2NvcmVzIGZvciBlYWNoIHZvY2FidWxhcnkgdG9rZW4gYmVmb3JlIHNvZnRtYXgpLlxuICAgICAqIEBwYXJhbSB7VGVuc29yfSBvdXRwdXQucGFzdF9rZXlfdmFsdWVzIENvbnRhaW5zIHByZS1jb21wdXRlZCBoaWRkZW4tc3RhdGVzIChrZXkgYW5kIHZhbHVlcyBpbiB0aGUgc2VsZi1hdHRlbnRpb24gYmxvY2tzKVxuICAgICAqIHRoYXQgY2FuIGJlIHVzZWQgKHNlZSBgcGFzdF9rZXlfdmFsdWVzYCBpbnB1dCkgdG8gc3BlZWQgdXAgc2VxdWVudGlhbCBkZWNvZGluZy5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih7IGxvZ2l0cywgcGFzdF9rZXlfdmFsdWVzIH0pIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5sb2dpdHMgPSBsb2dpdHM7XG4gICAgICAgIHRoaXMucGFzdF9rZXlfdmFsdWVzID0gcGFzdF9rZXlfdmFsdWVzO1xuICAgIH1cbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@xenova/transformers/src/models.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@xenova/transformers/src/pipelines.js":
/*!************************************************************!*\
  !*** ./node_modules/@xenova/transformers/src/pipelines.js ***!
  \************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AutomaticSpeechRecognitionPipeline: function() { return /* binding */ AutomaticSpeechRecognitionPipeline; },\n/* harmony export */   FeatureExtractionPipeline: function() { return /* binding */ FeatureExtractionPipeline; },\n/* harmony export */   FillMaskPipeline: function() { return /* binding */ FillMaskPipeline; },\n/* harmony export */   ImageClassificationPipeline: function() { return /* binding */ ImageClassificationPipeline; },\n/* harmony export */   ImageSegmentationPipeline: function() { return /* binding */ ImageSegmentationPipeline; },\n/* harmony export */   ImageToTextPipeline: function() { return /* binding */ ImageToTextPipeline; },\n/* harmony export */   ObjectDetectionPipeline: function() { return /* binding */ ObjectDetectionPipeline; },\n/* harmony export */   Pipeline: function() { return /* binding */ Pipeline; },\n/* harmony export */   QuestionAnsweringPipeline: function() { return /* binding */ QuestionAnsweringPipeline; },\n/* harmony export */   SummarizationPipeline: function() { return /* binding */ SummarizationPipeline; },\n/* harmony export */   Text2TextGenerationPipeline: function() { return /* binding */ Text2TextGenerationPipeline; },\n/* harmony export */   TextClassificationPipeline: function() { return /* binding */ TextClassificationPipeline; },\n/* harmony export */   TextGenerationPipeline: function() { return /* binding */ TextGenerationPipeline; },\n/* harmony export */   TokenClassificationPipeline: function() { return /* binding */ TokenClassificationPipeline; },\n/* harmony export */   TranslationPipeline: function() { return /* binding */ TranslationPipeline; },\n/* harmony export */   ZeroShotClassificationPipeline: function() { return /* binding */ ZeroShotClassificationPipeline; },\n/* harmony export */   ZeroShotImageClassificationPipeline: function() { return /* binding */ ZeroShotImageClassificationPipeline; },\n/* harmony export */   pipeline: function() { return /* binding */ pipeline; }\n/* harmony export */ });\n/* harmony import */ var _tokenizers_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tokenizers.js */ \"(app-pages-browser)/./node_modules/@xenova/transformers/src/tokenizers.js\");\n/* harmony import */ var _models_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./models.js */ \"(app-pages-browser)/./node_modules/@xenova/transformers/src/models.js\");\n/* harmony import */ var _processors_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./processors.js */ \"(app-pages-browser)/./node_modules/@xenova/transformers/src/processors.js\");\n/* harmony import */ var _utils_core_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/core.js */ \"(app-pages-browser)/./node_modules/@xenova/transformers/src/utils/core.js\");\n/* harmony import */ var _utils_maths_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils/maths.js */ \"(app-pages-browser)/./node_modules/@xenova/transformers/src/utils/maths.js\");\n/* harmony import */ var _utils_audio_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./utils/audio.js */ \"(app-pages-browser)/./node_modules/@xenova/transformers/src/utils/audio.js\");\n/* harmony import */ var _utils_tensor_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./utils/tensor.js */ \"(app-pages-browser)/./node_modules/@xenova/transformers/src/utils/tensor.js\");\n/* harmony import */ var _utils_image_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./utils/image.js */ \"(app-pages-browser)/./node_modules/@xenova/transformers/src/utils/image.js\");\n/**\n * @file Pipelines provide a high-level, easy to use, API for running machine learning models.\n * \n * **Example:** Instantiate pipeline using the `pipeline` function.\n * ```javascript\n * import { pipeline } from '@xenova/transformers';\n * \n * let classifier = await pipeline('sentiment-analysis');\n * let result = await classifier('I love transformers!');\n * // [{'label': 'POSITIVE', 'score': 0.999817686}]\n * ```\n * \n * @module pipelines\n */\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * Prepare images for further tasks.\n * @param {any[]} images images to prepare.\n * @returns {Promise<any[]>} returns processed images.\n * @private\n */\nasync function prepareImages(images) {\n    if (!Array.isArray(images)) {\n        images = [images];\n    }\n\n    // Possibly convert any non-images to images\n    images = await Promise.all(images.map(x => _utils_image_js__WEBPACK_IMPORTED_MODULE_7__.RawImage.read(x)));\n    return images;\n}\n\n/**\n * The Pipeline class is the class from which all pipelines inherit.\n * Refer to this class for methods shared across different pipelines.\n * @extends Callable\n */\nclass Pipeline extends _utils_core_js__WEBPACK_IMPORTED_MODULE_3__.Callable {\n    /**\n     * Create a new Pipeline.\n     * @param {string} task The task of the pipeline. Useful for specifying subtasks.\n     * @param {PreTrainedTokenizer} tokenizer The tokenizer to use.\n     * @param {PreTrainedModel} model The model to use.\n     */\n    constructor(task, tokenizer, model) {\n        super();\n        this.task = task;\n        this.tokenizer = tokenizer;\n        this.model = model;\n    }\n\n    /**\n     * Disposes the model.\n     * @returns {Promise<void>} A promise that resolves when the model has been disposed.\n     */\n    async dispose() {\n        await this.model.dispose();\n    }\n\n    /**\n     * Executes the task associated with the pipeline.\n     * @param {any} texts The input texts to be processed.\n     * @returns {Promise<any>} A promise that resolves to an array containing the inputs and outputs of the task.\n     */\n    async _call(texts) {\n        // Run tokenization\n        let inputs = this.tokenizer(texts, {\n            padding: true,\n            truncation: true\n        });\n\n        // Run model\n        let outputs = await this.model(inputs)\n\n        return [inputs, outputs];\n    }\n}\n\n/**\n * Text classification pipeline using any `ModelForSequenceClassification`.\n * @extends Pipeline\n */\nclass TextClassificationPipeline extends Pipeline {\n    /**\n     * Executes the text classification task.\n     * @param {any} texts The input texts to be classified.\n     * @param {Object} options An optional object containing the following properties:\n     * @param {number} [options.topk=1] The number of top predictions to be returned.\n     * @returns {Promise<Object[]|Object>} A promise that resolves to an array or object containing the predicted labels and scores.\n     */\n    async _call(texts, {\n        topk = 1\n    } = {}) {\n\n        let [inputs, outputs] = await super._call(texts);\n\n        let id2label = this.model.config.id2label;\n        let toReturn = [];\n        for (let batch of outputs.logits) {\n            let scores = (0,_utils_maths_js__WEBPACK_IMPORTED_MODULE_4__.getTopItems)((0,_utils_maths_js__WEBPACK_IMPORTED_MODULE_4__.softmax)(batch.data), topk);\n\n            let vals = scores.map(function (x) {\n                return {\n                    label: id2label[x[0]],\n                    score: x[1],\n                }\n            });\n            if (topk === 1) {\n                toReturn.push(...vals);\n            } else {\n                toReturn.push(vals);\n            }\n        }\n\n        return Array.isArray(texts) || topk === 1 ? toReturn : toReturn[0];\n    }\n}\n\n\n/**\n * Named Entity Recognition pipeline using any `ModelForTokenClassification`.\n * @extends Pipeline\n */\nclass TokenClassificationPipeline extends Pipeline {\n    /**\n     * Executes the token classification task.\n     * @param {any} texts The input texts to be classified.\n     * @param {Object} options An optional object containing the following properties:\n     * @returns {Promise<Object[]|Object>} A promise that resolves to an array or object containing the predicted labels and scores.\n     */\n    async _call(texts, {\n        ignore_labels = ['O'], // TODO init param?\n    } = {}) {\n\n        let isBatched = Array.isArray(texts);\n\n        if (!isBatched) {\n            texts = [texts];\n        }\n\n        let tokenizer = this.tokenizer;\n        let [inputs, outputs] = await super._call(texts);\n\n        let logits = outputs.logits;\n        let id2label = this.model.config.id2label;\n\n        let toReturn = [];\n        for (let i = 0; i < logits.dims[0]; ++i) {\n            let ids = inputs.input_ids[i];\n            let batch = logits[i];\n\n            // List of tokens that aren't ignored\n            let tokens = [];\n            for (let j = 0; j < batch.dims[0]; ++j) {\n                let tokenData = batch[j];\n                let topScoreIndex = (0,_utils_maths_js__WEBPACK_IMPORTED_MODULE_4__.max)(tokenData.data)[1];\n\n                let entity = id2label[topScoreIndex];\n                if (ignore_labels.includes(entity)) {\n                    // We predicted a token that should be ignored. So, we skip it.\n                    continue;\n                }\n\n                // TODO add option to keep special tokens?\n                let word = tokenizer.decode([ids[j].item()], { skip_special_tokens: true });\n                if (word === '') {\n                    // Was a special token. So, we skip it.\n                    continue;\n                }\n\n                let scores = (0,_utils_maths_js__WEBPACK_IMPORTED_MODULE_4__.softmax)(tokenData.data);\n\n                tokens.push({\n                    entity: entity,\n                    score: scores[topScoreIndex],\n                    index: j,\n                    word: word,\n\n                    // TODO: null for now, but will add\n                    start: null,\n                    end: null,\n                });\n            }\n            toReturn.push(tokens);\n        }\n        return isBatched ? toReturn : toReturn[0];\n    }\n}\n/**\n * Question Answering pipeline using any `ModelForQuestionAnswering`.\n * \n * **Example:** Run question answering with `distilbert-base-uncased-distilled-squad`.\n * ```javascript\n * let question = 'Who was Jim Henson?';\n * let context = 'Jim Henson was a nice puppet.';\n * \n * let answerer = await pipeline('question-answering', 'Xenova/distilbert-base-uncased-distilled-squad');\n * let outputs = await answerer(question, context);\n * console.log(outputs);\n * // {\n * //     \"answer\": \"a nice puppet\",\n * //     \"score\": 0.5768911502526741\n * // }\n * ```\n * @extends Pipeline\n */\nclass QuestionAnsweringPipeline extends Pipeline {\n    /**\n     * Executes the question answering task.\n     * @param {string|string[]} question The question(s) to be answered.\n     * @param {string|string[]} context The context(s) where the answer(s) can be found.\n     * @param {Object} options An optional object containing the following properties:\n     * @param {number} [options.topk=1] The number of top answer predictions to be returned.\n     * @returns {Promise<any>} A promise that resolves to an array or object containing the predicted answers and scores.\n     */\n    // @ts-ignore\n    async _call(question, context, {\n        topk = 1\n    } = {}) {\n\n        // Run tokenization\n        let inputs = this.tokenizer(question, {\n            text_pair: context,\n            padding: true,\n            truncation: true\n        });\n\n        let output = await this.model(inputs);\n\n        let toReturn = [];\n        for (let j = 0; j < output.start_logits.dims[0]; ++j) {\n            let ids = inputs.input_ids[j];\n            let sepIndex = ids.indexOf(this.tokenizer.sep_token_id);\n\n            let s1 = Array.from((0,_utils_maths_js__WEBPACK_IMPORTED_MODULE_4__.softmax)(output.start_logits[j].data))\n                .map((x, i) => [x, i])\n                .filter(x => x[1] > sepIndex);\n            let e1 = Array.from((0,_utils_maths_js__WEBPACK_IMPORTED_MODULE_4__.softmax)(output.end_logits[j].data))\n                .map((x, i) => [x, i])\n                .filter(x => x[1] > sepIndex);\n\n            let options = product(s1, e1)\n                .filter(x => x[0][1] <= x[1][1])\n                .map(x => [x[0][1], x[1][1], x[0][0] * x[1][0]])\n                .sort((a, b) => b[2] - a[2]);\n\n            for (let k = 0; k < Math.min(options.length, topk); ++k) {\n                let [start, end, score] = options[k];\n\n                let answer_tokens = [...ids].slice(start, end + 1)\n\n                let answer = this.tokenizer.decode(answer_tokens, {\n                    skip_special_tokens: true,\n                });\n\n                // TODO add start and end?\n                // NOTE: HF returns character index\n                toReturn.push({\n                    answer, score\n                });\n            }\n        }\n\n        // Mimic HF's return type based on topk\n        return (topk === 1) ? toReturn[0] : toReturn;\n\n    }\n}\n\n/**\n * Masked language modeling prediction pipeline using any `ModelWithLMHead`.\n * @extends Pipeline\n */\nclass FillMaskPipeline extends Pipeline {\n    /**\n     * Fill the masked token in the text(s) given as inputs.\n     * @param {any} texts The masked input texts.\n     * @param {Object} options An optional object containing the following properties:\n     * @param {number} [options.topk=5] The number of top predictions to be returned.\n     * @returns {Promise<Object[]|Object>} A promise that resolves to an array or object containing the predicted tokens and scores.\n     */\n    async _call(texts, {\n        topk = 5\n    } = {}) {\n        // Run tokenization\n        let [inputs, outputs] = await super._call(texts);\n\n        // Determine indices of mask tokens\n        // let mask_token_indices = inputs.input_ids.data.map(x => )\n\n        // let logits = reshape(outputs.logits.data, outputs.logits.dims);\n\n        let tokenizer = this.tokenizer;\n\n        let toReturn = [];\n\n        for (let i = 0; i < inputs.input_ids.dims[0]; ++i) {\n            let ids = inputs.input_ids[i];\n            let mask_token_index = ids.indexOf(this.tokenizer.mask_token_id)\n\n            if (mask_token_index === -1) {\n                throw Error(`Mask token (${tokenizer.mask_token}) not found in text.`)\n            }\n            let logits = outputs.logits[i];\n            let itemLogits = logits[mask_token_index];\n\n            let scores = (0,_utils_maths_js__WEBPACK_IMPORTED_MODULE_4__.getTopItems)((0,_utils_maths_js__WEBPACK_IMPORTED_MODULE_4__.softmax)(itemLogits.data), topk);\n\n            toReturn.push(scores.map(x => {\n                let sequence = [...ids];\n                sequence[mask_token_index] = x[0];\n\n                return {\n                    score: x[1],\n                    token: x[0],\n                    token_str: tokenizer.model.vocab[x[0]],\n                    sequence: tokenizer.decode(sequence, { skip_special_tokens: true }),\n                }\n            }));\n        }\n        return Array.isArray(texts) ? toReturn : toReturn[0];\n    }\n}\n\n/**\n * Text2TextGenerationPipeline class for generating text using a model that performs text-to-text generation tasks.\n * @extends Pipeline\n */\nclass Text2TextGenerationPipeline extends Pipeline {\n    _key = null;\n\n    /**\n     * Fill the masked token in the text(s) given as inputs.\n     * @param {string|string[]} texts The text or array of texts to be processed.\n     * @param {Object} [options={}] Options for the fill-mask pipeline.\n     * @param {number} [options.topk=5] The number of top-k predictions to return.\n     * @returns {Promise<any>} An array of objects containing the score, predicted token, predicted token string,\n     * and the sequence with the predicted token filled in, or an array of such arrays (one for each input text).\n     * If only one input text is given, the output will be an array of objects.\n     * @throws {Error} When the mask token is not found in the input text.\n     */\n    async _call(texts, generate_kwargs = {}) {\n        if (!Array.isArray(texts)) {\n            texts = [texts];\n        }\n\n        // Add global prefix, if present\n        if (this.model.config.prefix) {\n            texts = texts.map(x => this.model.config.prefix + x)\n        }\n\n        // Handle task specific params:\n        let task_specific_params = this.model.config.task_specific_params\n        if (task_specific_params && task_specific_params[this.task]) {\n            // Add prefixes, if present\n            if (task_specific_params[this.task].prefix) {\n                texts = texts.map(x => task_specific_params[this.task].prefix + x)\n            }\n\n            // TODO update generation config\n        }\n\n        let tokenizer_options = {\n            padding: true,\n            truncation: true,\n        }\n        let input_ids;\n        if (this instanceof TranslationPipeline && '_build_translation_inputs' in this.tokenizer) {\n            // TODO: move to Translation pipeline?\n            // Currently put here to avoid code duplication\n            // @ts-ignore\n            input_ids = this.tokenizer._build_translation_inputs(texts, tokenizer_options, generate_kwargs).input_ids;\n\n        } else {\n            input_ids = this.tokenizer(texts, tokenizer_options).input_ids;\n        }\n\n        let outputTokenIds = await this.model.generate(input_ids, generate_kwargs);\n\n        /**\n         * @type {any[]}\n         */\n        let toReturn = this.tokenizer.batch_decode(outputTokenIds, {\n            skip_special_tokens: true,\n        });\n        if (this._key !== null) {\n            toReturn = toReturn.map(text => {\n                return (this._key === null) ? text : { [this._key]: text }\n            })\n        }\n        return toReturn\n    }\n}\n\n\n/**\n * A pipeline for summarization tasks, inheriting from Text2TextGenerationPipeline.\n * @extends Text2TextGenerationPipeline\n */\nclass SummarizationPipeline extends Text2TextGenerationPipeline {\n    _key = 'summary_text';\n}\n\n/**\n * TranslationPipeline class to translate text from one language to another using the provided model and tokenizer.\n * @extends Text2TextGenerationPipeline\n */\nclass TranslationPipeline extends Text2TextGenerationPipeline {\n    _key = 'translation_text';\n}\n\n/**\n * Language generation pipeline using any `ModelWithLMHead` or `ModelForCausalLM`.\n * This pipeline predicts the words that will follow a specified text prompt.\n * NOTE: For the full list of generation parameters, see [`GenerationConfig`](./utils/generation#module_utils/generation.GenerationConfig).\n * \n * **Example:** Text generation with `Xenova/distilgpt2` (default settings).\n * ```javascript\n * let text = 'I enjoy walking with my cute dog,';\n * let generator = await pipeline('text-generation', 'Xenova/distilgpt2');\n * let output = await generator(text);\n * console.log(output);\n * // [{ generated_text: \"I enjoy walking with my cute dog, and I love to play with the other dogs.\" }]\n * ```\n * \n * **Example:** Text generation with `Xenova/distilgpt2` (custom settings).\n * ```javascript\n * let text = 'Once upon a time, there was';\n * let generator = await pipeline('text-generation', 'Xenova/distilgpt2');\n * let output = await generator(text, {\n *     temperature: 2,\n *     max_new_tokens: 10,\n *     repetition_penalty: 1.5,\n *     no_repeat_ngram_size: 2,\n *     num_beams: 2,\n *     num_return_sequences: 2,\n * });\n * console.log(output);\n * // [{\n * //   \"generated_text\": \"Once upon a time, there was an abundance of information about the history and activities that\"\n * // }, {\n * //   \"generated_text\": \"Once upon a time, there was an abundance of information about the most important and influential\"\n * // }]\n * ```\n * \n * **Example:** Run code generation with `Xenova/codegen-350M-mono`.\n * ```javascript\n * let text = 'def fib(n):';\n * let generator = await pipeline('text-generation', 'Xenova/codegen-350M-mono');\n * let output = await generator(text, {\n *     max_new_tokens: 40,\n * });\n * console.log(output[0].generated_text);\n * // def fib(n):\n * //     if n == 0:\n * //         return 0\n * //     if n == 1:\n * //         return 1\n * //     return fib(n-1) + fib(n-2)\n * ```\n * \n * @extends Pipeline\n */\nclass TextGenerationPipeline extends Pipeline {\n    /**\n     * Generates text based on an input prompt.\n     * @param {any} texts The input prompt or prompts to generate text from.\n     * @param {Object} [generate_kwargs={}] Additional arguments for text generation.\n     * @returns {Promise<any>} The generated text or texts.\n     */\n    async _call(texts, generate_kwargs = {}) {\n        let stringInput = typeof texts === 'string' || texts instanceof String;\n        if (stringInput) {\n            texts = [texts];\n        }\n\n        this.tokenizer.padding_side = 'left';\n        let inputs = this.tokenizer(texts, {\n            padding: true,\n            truncation: true,\n        });\n\n        let input_ids = inputs.input_ids;\n        let attention_mask = inputs.attention_mask;\n\n        let outputTokenIds = await this.model.generate(input_ids, generate_kwargs, null, {\n            inputs_attention_mask: attention_mask\n        });\n\n        const decoded = this.tokenizer.batch_decode(outputTokenIds, {\n            skip_special_tokens: true,\n        });\n        const toReturn = Array.from({ length: texts.length }, _ => []);\n        for (let i = 0; i < decoded.length; ++i) {\n            const textIndex = Math.floor(i / outputTokenIds.length * texts.length);\n\n            toReturn[textIndex].push({\n                generated_text: decoded[i]\n            });\n        }\n        return (stringInput && toReturn.length === 1) ? toReturn[0] : toReturn;\n    }\n}\n\n/**\n * NLI-based zero-shot classification pipeline using a `ModelForSequenceClassification`\n * trained on NLI (natural language inference) tasks. Equivalent of `text-classification`\n * pipelines, but these models don't require a hardcoded number of potential classes, they\n * can be chosen at runtime. It usually means it's slower but it is **much** more flexible.\n * @extends Pipeline\n */\nclass ZeroShotClassificationPipeline extends Pipeline {\n\n    /**\n     * Create a new ZeroShotClassificationPipeline.\n     * @param {string} task The task of the pipeline. Useful for specifying subtasks.\n     * @param {PreTrainedTokenizer} tokenizer The tokenizer to use.\n     * @param {PreTrainedModel} model The model to use.\n     */\n    constructor(task, tokenizer, model) {\n        super(task, tokenizer, model);\n\n        // Use model config to get label2id mapping\n        this.label2id = Object.fromEntries(\n            Object.entries(this.model.config.label2id).map(\n                ([k, v]) => [k.toLowerCase(), v]\n            )\n        );\n\n        this.entailment_id = this.label2id['entailment'];\n        if (this.entailment_id === undefined) {\n            console.warn(\"Could not find 'entailment' in label2id mapping. Using 2 as entailment_id.\");\n            this.entailment_id = 2;\n        }\n\n        this.contradiction_id = this.label2id['contradiction'];\n        if (this.contradiction_id === undefined) {\n            console.warn(\"Could not find 'contradiction' in label2id mapping. Using 0 as contradiction_id.\");\n            this.contradiction_id = 0;\n        }\n    }\n    /**\n     * @param {any[]} texts\n     * @param {string[]} candidate_labels\n     * @param {Object} options Additional options:\n     * @param {string} [options.hypothesis_template=\"This example is {}.\"] The template used to turn each\n     * candidate label into an NLI-style hypothesis. The candidate label will replace the {} placeholder.\n     * @param {boolean} [options.multi_label=false] Whether or not multiple candidate labels can be true.\n     * If `false`, the scores are normalized such that the sum of the label likelihoods for each sequence\n     * is 1. If `true`, the labels are considered independent and probabilities are normalized for each\n     * candidate by doing a softmax of the entailment score vs. the contradiction score.\n     * @return {Promise<Object|Object[]>} The prediction(s), as a map (or list of maps) from label to score.\n     */\n    // @ts-ignore\n    async _call(texts, candidate_labels, {\n        hypothesis_template = \"This example is {}.\",\n        multi_label = false,\n    } = {}) {\n\n        let isBatched = Array.isArray(texts);\n\n        if (!isBatched) {\n            texts = [texts];\n        }\n        if (!Array.isArray(candidate_labels)) {\n            candidate_labels = [candidate_labels];\n        }\n\n        // Insert labels into hypothesis template\n        let hypotheses = candidate_labels.map(\n            x => hypothesis_template.replace('{}', x)\n        );\n\n        // How to perform the softmax over the logits:\n        //  - true:  softmax over the entailment vs. contradiction dim for each label independently\n        //  - false: softmax the \"entailment\" logits over all candidate labels\n        let softmaxEach = multi_label || candidate_labels.length === 1;\n\n        let toReturn = [];\n        for (let premise of texts) {\n            let entails_logits = [];\n\n            for (let hypothesis of hypotheses) {\n                let inputs = this.tokenizer(premise, {\n                    text_pair: hypothesis,\n                    padding: true,\n                    truncation: true,\n                })\n                let outputs = await this.model(inputs)\n\n                if (softmaxEach) {\n                    entails_logits.push([\n                        outputs.logits.data[this.contradiction_id],\n                        outputs.logits.data[this.entailment_id]\n                    ])\n                } else {\n                    entails_logits.push(outputs.logits.data[this.entailment_id])\n                }\n            }\n\n            let scores;\n            if (softmaxEach) {\n                scores = entails_logits.map(x => (0,_utils_maths_js__WEBPACK_IMPORTED_MODULE_4__.softmax)(x)[1]);\n            } else {\n                scores = (0,_utils_maths_js__WEBPACK_IMPORTED_MODULE_4__.softmax)(entails_logits);\n            }\n\n            // Sort by scores (desc) and return scores with indices\n            let scores_sorted = scores\n                .map((x, i) => [x, i])\n                .sort((a, b) => {\n                    return b[0] - a[0];\n                });\n\n            toReturn.push({\n                sequence: premise,\n                labels: scores_sorted.map(x => candidate_labels[x[1]]),\n                scores: scores_sorted.map(x => x[0]),\n            });\n        }\n        return isBatched ? toReturn : toReturn[0];\n    }\n}\n\n\n/**\n * Feature extraction pipeline using no model head. This pipeline extracts the hidden\n * states from the base transformer, which can be used as features in downstream tasks.\n * \n * **Example:** Run feature extraction with `bert-base-uncased` (without pooling/normalization).\n * ```javascript\n * let extractor = await pipeline('feature-extraction', 'Xenova/bert-base-uncased', { revision: 'default' });\n * let result = await extractor('This is a simple test.');\n * console.log(result);\n * // Tensor {\n * //     type: 'float32',\n * //     data: Float32Array [0.05939924716949463, 0.021655935794115067, ...],\n * //     dims: [1, 8, 768]\n * // }\n * ```\n * \n * **Example:** Run feature extraction with `bert-base-uncased` (with pooling/normalization).\n * ```javascript\n * let extractor = await pipeline('feature-extraction', 'Xenova/bert-base-uncased', { revision: 'default' });\n * let result = await extractor('This is a simple test.', { pooling: 'mean', normalize: true });\n * console.log(result);\n * // Tensor {\n * //     type: 'float32',\n * //     data: Float32Array [0.03373778983950615, -0.010106077417731285, ...],\n * //     dims: [1, 768]\n * // }\n * ```\n * \n * **Example:** Calculating embeddings with `sentence-transformers` models.\n * ```javascript\n * let extractor = await pipeline('feature-extraction', 'Xenova/all-MiniLM-L6-v2');\n * let result = await extractor('This is a simple test.', { pooling: 'mean', normalize: true });\n * console.log(result);\n * // Tensor {\n * //     type: 'float32',\n * //     data: Float32Array [0.09094982594251633, -0.014774246141314507, ...],\n * //     dims: [1, 384]\n * // }\n * ```\n * @extends Pipeline\n */\nclass FeatureExtractionPipeline extends Pipeline {\n\n    /**\n     * Extract the features of the input(s).\n     * \n     * @param {string|string[]} texts The input texts\n     * @param {Object} options Additional options:\n     * @param {string} [options.pooling=\"none\"] The pooling method to use. Can be one of: \"none\", \"mean\".\n     * @param {boolean} [options.normalize=false] Whether or not to normalize the embeddings in the last dimension.\n     * @returns The features computed by the model.\n     */\n    async _call(texts, {\n        pooling = 'none',\n        normalize = false,\n    } = {}) {\n        let [inputs, outputs] = await super._call(texts);\n\n        // TODO: Provide warning to the user that they might be using model which was not exported\n        // specifically for feature extraction\n        // console.log(this.model.config)\n        // console.log(outputs)\n\n        let result = outputs.last_hidden_state ?? outputs.logits;\n        if (pooling === 'none') {\n            // Skip pooling\n        } else if (pooling === 'mean') {\n            result = (0,_utils_tensor_js__WEBPACK_IMPORTED_MODULE_6__.mean_pooling)(result, inputs.attention_mask);\n        } else {\n            throw Error(`Pooling method '${pooling}' not supported.`);\n        }\n\n        if (normalize) {\n            result = result.normalize(2, -1);\n        }\n\n        return result;\n    }\n}\n\n// TODO\n// export class SentenceSimilarityPipeline extends Pipeline {\n// }\n\n\n/**\n * Pipeline that aims at extracting spoken text contained within some audio.\n *\n * **Example:** Transcribe English.\n * ```javascript\n * let url = 'https://huggingface.co/datasets/Xenova/transformers.js-docs/resolve/main/jfk.wav';\n * let transcriber = await pipeline('automatic-speech-recognition', 'Xenova/whisper-tiny.en');\n * let output = await transcriber(url);\n * // { text: \" And so my fellow Americans ask not what your country can do for you, ask what you can do for your country.\" }\n * ```\n * \n * **Example:** Transcribe English w/ timestamps.\n * ```javascript\n * let url = 'https://huggingface.co/datasets/Xenova/transformers.js-docs/resolve/main/jfk.wav';\n * let transcriber = await pipeline('automatic-speech-recognition', 'Xenova/whisper-tiny.en');\n * let output = await transcriber(url, { return_timestamps: true });\n * // {\n * //   text: \" And so my fellow Americans ask not what your country can do for you, ask what you can do for your country.\"\n * //   chunks: [\n * //     { timestamp: [0, 8],  text: \" And so my fellow Americans ask not what your country can do for you\" }\n * //     { timestamp: [8, 11], text: \" ask what you can do for your country.\" }\n * //   ]\n * // }\n * ```\n * \n * **Example:** Transcribe English w/ word-level timestamps.\n * ```javascript\n * let url = 'https://huggingface.co/datasets/Xenova/transformers.js-docs/resolve/main/jfk.wav';\n * let transcriber = await pipeline('automatic-speech-recognition', 'Xenova/whisper-tiny.en', {\n *     revision: 'output_attentions',\n * });\n * let output = await transcriber(url, { return_timestamps: 'word' });\n * // {\n * //   \"text\": \" And so my fellow Americans ask not what your country can do for you ask what you can do for your country.\",\n * //   \"chunks\": [\n * //     { \"text\": \" And\", \"timestamp\": [0, 0.78] },\n * //     { \"text\": \" so\", \"timestamp\": [0.78, 1.06] },\n * //     { \"text\": \" my\", \"timestamp\": [1.06, 1.46] },\n * //     ...\n * //     { \"text\": \" for\", \"timestamp\": [9.72, 9.92] },\n * //     { \"text\": \" your\", \"timestamp\": [9.92, 10.22] },\n * //     { \"text\": \" country.\", \"timestamp\": [10.22, 13.5] }\n * //   ]\n * // }\n * ```\n * \n * **Example:** Transcribe French.\n * ```javascript\n * let url = 'https://huggingface.co/datasets/Xenova/transformers.js-docs/resolve/main/french-audio.mp3';\n * let transcriber = await pipeline('automatic-speech-recognition', 'Xenova/whisper-small');\n * let output = await transcriber(url, { language: 'french', task: 'transcribe' });\n * // { text: \" J'adore, j'aime, je n'aime pas, je déteste.\" }\n * ```\n * \n * **Example:** Translate French to English.\n * ```javascript\n * let url = 'https://huggingface.co/datasets/Xenova/transformers.js-docs/resolve/main/french-audio.mp3';\n * let transcriber = await pipeline('automatic-speech-recognition', 'Xenova/whisper-small');\n * let output = await transcriber(url, { language: 'french', task: 'translate' });\n * // { text: \" I love, I like, I don't like, I hate.\" }\n * ```\n * \n * **Example:** Transcribe/translate audio longer than 30 seconds.\n * ```javascript\n * let url = 'https://huggingface.co/datasets/Xenova/transformers.js-docs/resolve/main/ted_60.wav';\n * let transcriber = await pipeline('automatic-speech-recognition', 'Xenova/whisper-tiny.en');\n * let output = await transcriber(url, { chunk_length_s: 30, stride_length_s: 5 });\n * // { text: \" So in college, I was a government major, which means [...] So I'd start off light and I'd bump it up\" }\n * ```\n * @extends Pipeline\n */\nclass AutomaticSpeechRecognitionPipeline extends Pipeline {\n\n    /**\n     * Create a new AutomaticSpeechRecognitionPipeline.\n     * @param {string} task The task of the pipeline. Useful for specifying subtasks.\n     * @param {PreTrainedTokenizer} tokenizer The tokenizer to use.\n     * @param {PreTrainedModel} model The model to use.\n     * @param {Processor} processor The processor to use.\n     */\n    constructor(task, tokenizer, model, processor) {\n        super(task, tokenizer, model);\n        this.processor = processor;\n    }\n\n    /**\n     * Preprocesses the input audio for the AutomaticSpeechRecognitionPipeline.\n     * @param {any} audio The audio to be preprocessed.\n     * @param {number} sampling_rate The sampling rate of the audio.\n     * @returns {Promise<Float32Array>} A promise that resolves to the preprocessed audio data.\n     * @private\n     */\n    async _preprocess(audio, sampling_rate) {\n        if ((0,_utils_core_js__WEBPACK_IMPORTED_MODULE_3__.isString)(audio)) {\n            audio = await (0,_utils_audio_js__WEBPACK_IMPORTED_MODULE_5__.read_audio)(audio, sampling_rate);\n        }\n\n        return audio;\n    }\n\n    /**\n     * @typedef {import('./utils/tensor.js').Tensor} Tensor\n     * @typedef {{stride: number[], input_features: Tensor, is_last: boolean, tokens?: number[], token_timestamps?: number[]}} Chunk\n     * \n     * @callback ChunkCallback\n     * @param {Chunk} chunk The chunk to process.\n     */\n\n    /**\n     * Asynchronously processes audio and generates text transcription using the model.\n     * @param {Float32Array|Float32Array[]} audio The audio to be transcribed. Can be a single Float32Array or an array of Float32Arrays.\n     * @param {Object} [kwargs={}] Optional arguments.\n     * @param {boolean|'word'} [kwargs.return_timestamps] Whether to return timestamps or not. Default is `false`.\n     * @param {number} [kwargs.chunk_length_s] The length of audio chunks to process in seconds. Default is 0 (no chunking).\n     * @param {number} [kwargs.stride_length_s] The length of overlap between consecutive audio chunks in seconds. If not provided, defaults to `chunk_length_s / 6`.\n     * @param {ChunkCallback} [kwargs.chunk_callback] Callback function to be called with each chunk processed.\n     * @param {boolean} [kwargs.force_full_sequences] Whether to force outputting full sequences or not. Default is `false`.\n     * @param {string} [kwargs.language] The source language. Default is `null`, meaning it should be auto-detected. Use this to potentially improve performance if the source language is known.\n     * @param {string} [kwargs.task] The task to perform. Default is `null`, meaning it should be auto-detected.\n     * @param {number[][]} [kwargs.forced_decoder_ids] A list of pairs of integers which indicates a mapping from generation indices to token indices\n     * that will be forced before sampling. For example, [[1, 123]] means the second generated token will always be a token of index 123.\n     * @returns {Promise<Object>} A Promise that resolves to an object containing the transcription text and optionally timestamps if `return_timestamps` is `true`.\n     */\n    async _call(audio, kwargs = {}) {\n        let return_timestamps = kwargs.return_timestamps ?? false;\n        let chunk_length_s = kwargs.chunk_length_s ?? 0;\n        let stride_length_s = kwargs.stride_length_s ?? null;\n        let chunk_callback = kwargs.chunk_callback ?? null;\n        let force_full_sequences = kwargs.force_full_sequences ?? false;\n\n        if (return_timestamps === 'word') {\n            kwargs['return_token_timestamps'] = true;\n        }\n\n        let language = (0,_utils_core_js__WEBPACK_IMPORTED_MODULE_3__.pop)(kwargs, 'language', null);\n        let task = (0,_utils_core_js__WEBPACK_IMPORTED_MODULE_3__.pop)(kwargs, 'task', null);\n\n        if (language || task || return_timestamps) {\n            if (kwargs.forced_decoder_ids) {\n                throw new Error(\"Cannot specify `language`/`task`/`return_timestamps` and `forced_decoder_ids` at the same time.\")\n            }\n            // @ts-ignore\n            let decoder_prompt_ids = this.tokenizer.get_decoder_prompt_ids({ language, task, no_timestamps: !return_timestamps })\n            if (decoder_prompt_ids.length > 0) {\n                kwargs.forced_decoder_ids = decoder_prompt_ids;\n            }\n        }\n\n        let single = !Array.isArray(audio);\n        if (single) {\n            // @ts-ignore\n            audio = [audio];\n        }\n\n        const sampling_rate = this.processor.feature_extractor.config.sampling_rate;\n        const time_precision = this.processor.feature_extractor.config.chunk_length / this.model.config.max_source_positions;\n\n        let toReturn = [];\n        for (let aud of audio) {\n            aud = await this._preprocess(aud, sampling_rate)\n\n            /** @type {Chunk[]} */\n            let chunks = [];\n            if (chunk_length_s > 0) {\n                if (stride_length_s === null) {\n                    stride_length_s = chunk_length_s / 6;\n                } else if (chunk_length_s <= stride_length_s) {\n                    throw Error(\"`chunk_length_s` must be larger than `stride_length_s`.\")\n                }\n\n                // TODO support different stride_length_s (for left and right)\n\n                const window = sampling_rate * chunk_length_s;\n                const stride = sampling_rate * stride_length_s;\n                const jump = window - 2 * stride;\n                let offset = 0;\n\n                // Create subarrays of audio with overlaps\n\n                while (offset < aud.length) {\n                    let subarr = aud.subarray(offset, offset + window);\n                    let feature = await this.processor(subarr);\n\n                    let isFirst = offset === 0;\n                    let isLast = offset + jump >= aud.length;\n                    chunks.push({\n                        stride: [\n                            subarr.length,\n                            isFirst ? 0 : stride,\n                            isLast ? 0 : stride\n                        ],\n                        input_features: feature.input_features,\n                        is_last: isLast\n                    })\n                    offset += jump;\n                }\n\n            } else {\n                chunks = [{\n                    stride: [aud.length, 0, 0],\n                    input_features: (await this.processor(aud)).input_features,\n                    is_last: true\n                }]\n            }\n\n            // Generate for each set of input features\n            for (let chunk of chunks) {\n                // NOTE: doing sequentially for now\n                let data = await this.model.generate(chunk.input_features, kwargs);\n\n                // TODO: Right now we only get top beam\n                if (return_timestamps === 'word') {\n                    chunk.tokens = data.sequences[0];\n                    chunk.token_timestamps = data.token_timestamps.tolist()[0].map(\n                        x => (0,_utils_maths_js__WEBPACK_IMPORTED_MODULE_4__.round)(x, 2)\n                    );\n\n                } else {\n                    chunk.tokens = data[0];\n                }\n\n                // convert stride to seconds\n                chunk.stride = chunk.stride.map(x => x / sampling_rate);\n\n                if (chunk_callback !== null) {\n                    chunk_callback(chunk)\n                }\n            }\n\n            // Merge text chunks\n            // @ts-ignore\n            let [full_text, optional] = this.tokenizer._decode_asr(chunks, {\n                time_precision, return_timestamps, force_full_sequences\n            });\n\n            toReturn.push({ text: full_text, ...optional })\n        }\n        return single ? toReturn[0] : toReturn;\n    }\n}\n\n/**\n * Image To Text pipeline using a `AutoModelForVision2Seq`. This pipeline predicts a caption for a given image.\n * @extends Pipeline\n */\nclass ImageToTextPipeline extends Pipeline {\n    /**\n     * Create a new ImageToTextPipeline.\n     * @param {string} task The task of the pipeline. Useful for specifying subtasks.\n     * @param {PreTrainedTokenizer} tokenizer The tokenizer to use.\n     * @param {PreTrainedModel} model The model to use.\n     * @param {Processor} processor The processor to use.\n     */\n    constructor(task, tokenizer, model, processor) {\n        super(task, tokenizer, model);\n        this.processor = processor;\n    }\n\n    /**\n     * Assign labels to the image(s) passed as inputs.\n     * @param {any[]} images The images to be captioned.\n     * @param {Object} [generate_kwargs={}] Optional generation arguments.\n     * @returns {Promise<Object|Object[]>} A Promise that resolves to an object (or array of objects) containing the generated text(s).\n     */\n    async _call(images, generate_kwargs = {}) {\n        let isBatched = Array.isArray(images);\n\n        images = await prepareImages(images);\n\n        let { pixel_values } = await this.processor(images);\n\n        let toReturn = [];\n        for (let batch of pixel_values) {\n            batch.dims = [1, ...batch.dims]\n            let output = await this.model.generate(batch, generate_kwargs);\n            let decoded = this.tokenizer.batch_decode(output, {\n                skip_special_tokens: true,\n            }).map(x => {\n                return { generated_text: x.trim() }\n            })\n            toReturn.push(decoded);\n        }\n\n        return isBatched ? toReturn : toReturn[0];\n    }\n}\n\n/**\n * Image classification pipeline using any `AutoModelForImageClassification`.\n * This pipeline predicts the class of an image.\n * \n * **Example:** Classify an image.\n * ```javascript\n * let classifier = await pipeline('image-classification', 'Xenova/vit-base-patch16-224');\n * let url = 'https://huggingface.co/datasets/Xenova/transformers.js-docs/resolve/main/tiger.jpg';\n * let outputs = await classifier(url);\n * // Array(1) [\n * //   {label: 'tiger, Panthera tigris', score: 0.632695734500885},\n * // ]\n * ```\n * \n * **Example:** Classify an image and return top `n` classes.\n * ```javascript\n * let classifier = await pipeline('image-classification', 'Xenova/vit-base-patch16-224');\n * let url = 'https://huggingface.co/datasets/Xenova/transformers.js-docs/resolve/main/tiger.jpg';\n * let outputs = await classifier(url, { topk: 3 });\n * // Array(3) [\n * //   {label: 'tiger, Panthera tigris', score: 0.632695734500885},\n * //   {label: 'tiger cat', score: 0.3634825646877289},\n * //   {label: 'lion, king of beasts, Panthera leo', score: 0.00045060308184474707},\n * // ]\n * ```\n * \n * **Example:** Classify an image and return all classes.\n * ```javascript\n * let classifier = await pipeline('image-classification', 'Xenova/vit-base-patch16-224');\n * let url = 'https://huggingface.co/datasets/Xenova/transformers.js-docs/resolve/main/tiger.jpg';\n * let outputs = await classifier(url, { topk: 0 });\n * // Array(1000) [\n * //   {label: 'tiger, Panthera tigris', score: 0.632695734500885},\n * //   {label: 'tiger cat', score: 0.3634825646877289},\n * //   {label: 'lion, king of beasts, Panthera leo', score: 0.00045060308184474707},\n * //   {label: 'jaguar, panther, Panthera onca, Felis onca', score: 0.00035465499968267977},\n * //   ...\n * // ]\n * ```\n * @extends Pipeline\n */\nclass ImageClassificationPipeline extends Pipeline {\n    /**\n     * Create a new ImageClassificationPipeline.\n     * @param {string} task The task of the pipeline. Useful for specifying subtasks.\n     * @param {PreTrainedModel} model The model to use.\n     * @param {Processor} processor The processor to use.\n     */\n    constructor(task, model, processor) {\n        super(task, null, model); // TODO tokenizer\n        this.processor = processor;\n    }\n\n    /**\n     * Classify the given images.\n     * @param {any} images The images to classify.\n     * @param {Object} options The options to use for classification.\n     * @param {number} [options.topk=1] The number of top results to return.\n     * @returns {Promise<any>} The top classification results for the images.\n     */\n    async _call(images, {\n        topk = 1\n    } = {}) {\n        let isBatched = Array.isArray(images);\n        images = await prepareImages(images);\n\n        let { pixel_values } = await this.processor(images);\n        let output = await this.model({ pixel_values });\n\n        let id2label = this.model.config.id2label;\n        let toReturn = [];\n        for (let batch of output.logits) {\n            let scores = (0,_utils_maths_js__WEBPACK_IMPORTED_MODULE_4__.getTopItems)((0,_utils_maths_js__WEBPACK_IMPORTED_MODULE_4__.softmax)(batch.data), topk);\n\n            let vals = scores.map(function (x) {\n                return {\n                    label: id2label[x[0]],\n                    score: x[1],\n                }\n            });\n            if (topk === 1) {\n                toReturn.push(...vals);\n            } else {\n                toReturn.push(vals);\n            }\n        }\n\n        return isBatched || topk === 1 ? toReturn : toReturn[0];\n    }\n\n}\n\n/**\n * Image segmentation pipeline using any `AutoModelForXXXSegmentation`.\n * This pipeline predicts masks of objects and their classes.\n * @extends Pipeline\n */\nclass ImageSegmentationPipeline extends Pipeline {\n    /**\n     * Create a new ImageSegmentationPipeline.\n     * @param {string} task The task of the pipeline. Useful for specifying subtasks.\n     * @param {PreTrainedModel} model The model to use.\n     * @param {Processor} processor The processor to use.\n     */\n    constructor(task, model, processor) {\n        super(task, null, model); // TODO tokenizer\n        this.processor = processor;\n\n        this.subtasks_mapping = {\n            // Mapping of subtasks to their corresponding post-processing function names.\n            panoptic: 'post_process_panoptic_segmentation',\n            instance: 'post_process_instance_segmentation',\n            semantic: 'post_process_semantic_segmentation'\n        }\n    }\n\n    /**\n     * Segment the input images.\n     * @param {Array} images The input images.\n     * @param {Object} options The options to use for segmentation.\n     * @param {number} [options.threshold=0.5] Probability threshold to filter out predicted masks.\n     * @param {number} [options.mask_threshold=0.5] Threshold to use when turning the predicted masks into binary values.\n     * @param {number} [options.overlap_mask_area_threshold=0.8] Mask overlap threshold to eliminate small, disconnected segments.\n     * @param {null|string} [options.subtask=null] Segmentation task to be performed. One of [`panoptic`, `instance`, and `semantic`], depending on model capabilities. If not set, the pipeline will attempt to resolve (in that order).\n     * @param {Array} [options.label_ids_to_fuse=null] List of label ids to fuse. If not set, do not fuse any labels.\n     * @param {Array} [options.target_sizes=null] List of target sizes for the input images. If not set, use the original image sizes.\n     * @returns {Promise<Array>} The annotated segments.\n     */\n    async _call(images, {\n        threshold = 0.5,\n        mask_threshold = 0.5,\n        overlap_mask_area_threshold = 0.8,\n        label_ids_to_fuse = null,\n        target_sizes = null,\n        subtask = null, // TODO use\n    } = {}) {\n        let isBatched = Array.isArray(images);\n\n        if (isBatched && images.length !== 1) {\n            throw Error(\"Image segmentation pipeline currently only supports a batch size of 1.\");\n        }\n\n        images = await prepareImages(images);\n        let imageSizes = images.map(x => [x.height, x.width]);\n\n        let { pixel_values, pixel_mask } = await this.processor(images);\n        let output = await this.model({ pixel_values, pixel_mask });\n\n        let fn = null;\n        if (subtask !== null) {\n            fn = this.subtasks_mapping[subtask];\n        } else {\n            for (let [task, func] of Object.entries(this.subtasks_mapping)) {\n                if (func in this.processor.feature_extractor) {\n                    fn = this.processor.feature_extractor[func].bind(this.processor.feature_extractor);\n                    subtask = task;\n                    break;\n                }\n            }\n        }\n\n        // add annotations\n        let annotation = [];\n\n        if (subtask === 'panoptic' || subtask === 'instance') {\n\n            let processed = fn(\n                output,\n                threshold,\n                mask_threshold,\n                overlap_mask_area_threshold,\n                label_ids_to_fuse,\n                target_sizes ?? imageSizes, // TODO FIX?\n            )[0];\n\n            let segmentation = processed.segmentation;\n            let id2label = this.model.config.id2label;\n\n            for (let segment of processed.segments_info) {\n                let maskData = new Uint8ClampedArray(segmentation.data.length);\n                for (let i = 0; i < segmentation.data.length; ++i) {\n                    if (segmentation.data[i] === segment.id) {\n                        maskData[i] = 255;\n                    }\n                }\n\n                let mask = new _utils_image_js__WEBPACK_IMPORTED_MODULE_7__.RawImage(maskData, segmentation.dims[1], segmentation.dims[0], 1)\n\n                annotation.push({\n                    score: segment.score,\n                    label: id2label[segment.label_id],\n                    mask: mask\n                })\n            }\n\n        } else if (subtask === 'semantic') {\n            throw Error(`semantic segmentation not yet supported.`);\n\n        } else {\n            throw Error(`Subtask ${subtask} not supported.`);\n        }\n\n        return annotation;\n    }\n}\n\n\n/**\n * Zero shot image classification pipeline. This pipeline predicts the class of\n * an image when you provide an image and a set of `candidate_labels`.\n * @extends Pipeline\n */\nclass ZeroShotImageClassificationPipeline extends Pipeline {\n\n    /**\n     * Create a new ZeroShotImageClassificationPipeline.\n     * @param {string} task The task of the pipeline. Useful for specifying subtasks.\n     * @param {PreTrainedTokenizer} tokenizer The tokenizer to use.\n     * @param {PreTrainedModel} model The model to use.\n     * @param {Processor} processor The processor to use.\n     */\n    constructor(task, tokenizer, model, processor) {\n        super(task, tokenizer, model);\n        this.processor = processor;\n    }\n\n    /**\n     * Classify the input images with candidate labels using a zero-shot approach.\n     * @param {Array} images The input images.\n     * @param {Array} candidate_labels The candidate labels.\n     * @param {Object} options The options for the classification.\n     * @param {string} [options.hypothesis_template] The hypothesis template to use for zero-shot classification. Default: \"This is a photo of {}\".\n     * @returns {Promise<any>} An array of classifications for each input image or a single classification object if only one input image is provided.\n     */\n    // @ts-ignore\n    async _call(images, candidate_labels, {\n        hypothesis_template = \"This is a photo of {}\"\n    } = {}) {\n        let isBatched = Array.isArray(images);\n        images = await prepareImages(images);\n\n        // Insert label into hypothesis template \n        let texts = candidate_labels.map(\n            x => hypothesis_template.replace('{}', x)\n        );\n\n        // Run tokenization\n        let text_inputs = this.tokenizer(texts, {\n            padding: true,\n            truncation: true\n        });\n\n        // Run processor\n        let { pixel_values } = await this.processor(images);\n\n        // Run model with both text and pixel inputs\n        let output = await this.model({ ...text_inputs, pixel_values });\n\n        // Compare each image with each candidate label\n        let toReturn = [];\n        for (let batch of output.logits_per_image) {\n            // Compute softmax per image\n            let probs = (0,_utils_maths_js__WEBPACK_IMPORTED_MODULE_4__.softmax)(batch.data);\n\n            toReturn.push([...probs].map((x, i) => {\n                return {\n                    score: x,\n                    label: candidate_labels[i]\n                }\n            }));\n        }\n\n        return isBatched ? toReturn : toReturn[0];\n    }\n}\n\n/**\n * Object detection pipeline using any `AutoModelForObjectDetection`.\n * This pipeline predicts bounding boxes of objects and their classes.\n * \n * **Example:** Run object-detection with `facebook/detr-resnet-50`.\n * ```javascript\n * let img = 'https://huggingface.co/datasets/Xenova/transformers.js-docs/resolve/main/cats.jpg';\n * \n * let detector = await pipeline('object-detection', 'Xenova/detr-resnet-50');\n * let output = await detector(img, { threshold: 0.9 });\n * // [{\n * //   \"score\": 0.9976370930671692,\n * //   \"label\": \"remote\",\n * //   \"box\": { \"xmin\": 31, \"ymin\": 68, \"xmax\": 190, \"ymax\": 118 }\n * // },\n * // ...\n * // {\n * //   \"score\": 0.9984092116355896,\n * //   \"label\": \"cat\",\n * //   \"box\": { \"xmin\": 331, \"ymin\": 19, \"xmax\": 649, \"ymax\": 371 }\n * // }]\n * ```\n * \n * @extends Pipeline\n */\nclass ObjectDetectionPipeline extends Pipeline {\n    /**\n     * Create a new ObjectDetectionPipeline.\n     * @param {string} task The task of the pipeline. Useful for specifying subtasks.\n     * @param {PreTrainedModel} model The model to use.\n     * @param {Processor} processor The processor to use.\n     */\n    constructor(task, model, processor) {\n        super(task, null, model); // TODO tokenizer\n        this.processor = processor;\n    }\n\n    /**\n     * Detect objects (bounding boxes & classes) in the image(s) passed as inputs.\n     * @param {any[]} images The input images.\n     * @param {Object} options The options for the object detection.\n     * @param {number} [options.threshold=0.9] The threshold used to filter boxes by score.\n     * @param {boolean} [options.percentage=false] Whether to return the boxes coordinates in percentage (true) or in pixels (false).\n     */\n    async _call(images, {\n        threshold = 0.9,\n        percentage = false,\n    } = {}) {\n        let isBatched = Array.isArray(images);\n\n        if (isBatched && images.length !== 1) {\n            throw Error(\"Object detection pipeline currently only supports a batch size of 1.\");\n        }\n        images = await prepareImages(images);\n\n        let imageSizes = percentage ? null : images.map(x => [x.height, x.width]);\n\n        let { pixel_values, pixel_mask } = await this.processor(images);\n        let output = await this.model({ pixel_values, pixel_mask });\n\n        // @ts-ignore\n        let processed = this.processor.feature_extractor.post_process_object_detection(output, threshold, imageSizes);\n\n        // Add labels\n        let id2label = this.model.config.id2label;\n\n        // Format output\n        const result = processed.map(batch => {\n            return batch.boxes.map((box, i) => {\n                return {\n                    score: batch.scores[i],\n                    label: id2label[batch.classes[i]],\n                    box: this._get_bounding_box(box, !percentage),\n                }\n            })\n        })\n\n        return isBatched ? result : result[0];\n    }\n\n    /**\n     * Helper function to convert list [xmin, xmax, ymin, ymax] into object { \"xmin\": xmin, ... }\n     * @param {number[]} box The bounding box as a list.\n     * @param {boolean} asInteger Whether to cast to integers.\n     * @returns {Object} The bounding box as an object.\n     * @private\n     */\n    _get_bounding_box(box, asInteger) {\n        if (asInteger) {\n            box = box.map(x => x | 0);\n        }\n        const [xmin, ymin, xmax, ymax] = box;\n\n        return { xmin, ymin, xmax, ymax };\n    }\n}\n\nconst SUPPORTED_TASKS = {\n    \"text-classification\": {\n        \"tokenizer\": _tokenizers_js__WEBPACK_IMPORTED_MODULE_0__.AutoTokenizer,\n        \"pipeline\": TextClassificationPipeline,\n        \"model\": _models_js__WEBPACK_IMPORTED_MODULE_1__.AutoModelForSequenceClassification,\n        \"default\": {\n            // TODO: replace with original\n            // \"model\": \"distilbert-base-uncased-finetuned-sst-2-english\",\n            \"model\": \"Xenova/distilbert-base-uncased-finetuned-sst-2-english\",\n        },\n        \"type\": \"text\",\n    },\n    \"token-classification\": {\n        \"tokenizer\": _tokenizers_js__WEBPACK_IMPORTED_MODULE_0__.AutoTokenizer,\n        \"pipeline\": TokenClassificationPipeline,\n        \"model\": _models_js__WEBPACK_IMPORTED_MODULE_1__.AutoModelForTokenClassification,\n        \"default\": {\n            // TODO: replace with original\n            // \"model\": \"Davlan/bert-base-multilingual-cased-ner-hrl\",\n            \"model\": \"Xenova/bert-base-multilingual-cased-ner-hrl\",\n        },\n        \"type\": \"text\",\n    },\n    \"question-answering\": {\n        \"tokenizer\": _tokenizers_js__WEBPACK_IMPORTED_MODULE_0__.AutoTokenizer,\n        \"pipeline\": QuestionAnsweringPipeline,\n        \"model\": _models_js__WEBPACK_IMPORTED_MODULE_1__.AutoModelForQuestionAnswering,\n        \"default\": {\n            // TODO: replace with original\n            // \"model\": \"distilbert-base-cased-distilled-squad\",\n            \"model\": \"Xenova/distilbert-base-cased-distilled-squad\",\n        },\n        \"type\": \"text\",\n    },\n\n    \"fill-mask\": {\n        \"tokenizer\": _tokenizers_js__WEBPACK_IMPORTED_MODULE_0__.AutoTokenizer,\n        \"pipeline\": FillMaskPipeline,\n        \"model\": _models_js__WEBPACK_IMPORTED_MODULE_1__.AutoModelForMaskedLM,\n        \"default\": {\n            // TODO: replace with original\n            // \"model\": \"bert-base-uncased\",\n            \"model\": \"Xenova/bert-base-uncased\",\n        },\n        \"type\": \"text\",\n    },\n    \"summarization\": {\n        \"tokenizer\": _tokenizers_js__WEBPACK_IMPORTED_MODULE_0__.AutoTokenizer,\n        \"pipeline\": SummarizationPipeline,\n        \"model\": _models_js__WEBPACK_IMPORTED_MODULE_1__.AutoModelForSeq2SeqLM,\n        \"default\": {\n            // TODO: replace with original\n            // \"model\": \"sshleifer/distilbart-cnn-6-6\",\n            \"model\": \"Xenova/distilbart-cnn-6-6\",\n        },\n        \"type\": \"text\",\n    },\n    \"translation\": {\n        \"tokenizer\": _tokenizers_js__WEBPACK_IMPORTED_MODULE_0__.AutoTokenizer,\n        \"pipeline\": TranslationPipeline,\n        \"model\": _models_js__WEBPACK_IMPORTED_MODULE_1__.AutoModelForSeq2SeqLM,\n        \"default\": {\n            // TODO: replace with original\n            // \"model\": \"t5-small\",\n            \"model\": \"Xenova/t5-small\",\n        },\n        \"type\": \"text\",\n    },\n    \"text2text-generation\": {\n        \"tokenizer\": _tokenizers_js__WEBPACK_IMPORTED_MODULE_0__.AutoTokenizer,\n        \"pipeline\": Text2TextGenerationPipeline,\n        \"model\": _models_js__WEBPACK_IMPORTED_MODULE_1__.AutoModelForSeq2SeqLM,\n        \"default\": {\n            // TODO: replace with original\n            // \"model\": \"google/flan-t5-small\",\n            \"model\": \"Xenova/flan-t5-small\",\n        },\n        \"type\": \"text\",\n    },\n    \"text-generation\": {\n        \"tokenizer\": _tokenizers_js__WEBPACK_IMPORTED_MODULE_0__.AutoTokenizer,\n        \"pipeline\": TextGenerationPipeline,\n        \"model\": _models_js__WEBPACK_IMPORTED_MODULE_1__.AutoModelForCausalLM,\n        \"default\": {\n            // TODO: replace with original\n            // \"model\": \"gpt2\",\n            \"model\": \"Xenova/gpt2\",\n        },\n        \"type\": \"text\",\n    },\n    \"zero-shot-classification\": {\n        \"tokenizer\": _tokenizers_js__WEBPACK_IMPORTED_MODULE_0__.AutoTokenizer,\n        \"pipeline\": ZeroShotClassificationPipeline,\n        \"model\": _models_js__WEBPACK_IMPORTED_MODULE_1__.AutoModelForSequenceClassification,\n        \"default\": {\n            // TODO: replace with original\n            // \"model\": \"typeform/distilbert-base-uncased-mnli\",\n            \"model\": \"Xenova/distilbert-base-uncased-mnli\",\n        },\n        \"type\": \"text\",\n    },\n\n    \"automatic-speech-recognition\": {\n        \"tokenizer\": _tokenizers_js__WEBPACK_IMPORTED_MODULE_0__.AutoTokenizer,\n        \"pipeline\": AutomaticSpeechRecognitionPipeline,\n        \"model\": _models_js__WEBPACK_IMPORTED_MODULE_1__.AutoModelForSeq2SeqLM,\n        \"processor\": _processors_js__WEBPACK_IMPORTED_MODULE_2__.AutoProcessor,\n        \"default\": {\n            // TODO: replace with original\n            // \"model\": \"openai/whisper-tiny.en\",\n            \"model\": \"Xenova/whisper-tiny.en\",\n        },\n        \"type\": \"multimodal\",\n    },\n\n    \"image-to-text\": {\n        \"tokenizer\": _tokenizers_js__WEBPACK_IMPORTED_MODULE_0__.AutoTokenizer,\n        \"pipeline\": ImageToTextPipeline,\n        \"model\": _models_js__WEBPACK_IMPORTED_MODULE_1__.AutoModelForVision2Seq,\n        \"processor\": _processors_js__WEBPACK_IMPORTED_MODULE_2__.AutoProcessor,\n        \"default\": {\n            // TODO: replace with original\n            // \"model\": \"nlpconnect/vit-gpt2-image-captioning\",\n            \"model\": \"Xenova/vit-gpt2-image-captioning\",\n        },\n        \"type\": \"multimodal\",\n    },\n\n    \"image-classification\": {\n        // no tokenizer\n        \"pipeline\": ImageClassificationPipeline,\n        \"model\": _models_js__WEBPACK_IMPORTED_MODULE_1__.AutoModelForImageClassification,\n        \"processor\": _processors_js__WEBPACK_IMPORTED_MODULE_2__.AutoProcessor,\n        \"default\": {\n            // TODO: replace with original\n            // \"model\": \"google/vit-base-patch16-224\",\n            \"model\": \"Xenova/vit-base-patch16-224\",\n        },\n        \"type\": \"multimodal\",\n    },\n\n    \"image-segmentation\": {\n        // no tokenizer\n        \"pipeline\": ImageSegmentationPipeline,\n        \"model\": _models_js__WEBPACK_IMPORTED_MODULE_1__.AutoModelForImageSegmentation,\n        \"processor\": _processors_js__WEBPACK_IMPORTED_MODULE_2__.AutoProcessor,\n        \"default\": {\n            // TODO: replace with original\n            // \"model\": \"facebook/detr-resnet-50-panoptic\",\n            \"model\": \"Xenova/detr-resnet-50-panoptic\",\n        },\n        \"type\": \"multimodal\",\n    },\n\n    \"zero-shot-image-classification\": {\n        // no tokenizer\n        \"tokenizer\": _tokenizers_js__WEBPACK_IMPORTED_MODULE_0__.AutoTokenizer,\n        \"pipeline\": ZeroShotImageClassificationPipeline,\n        \"model\": _models_js__WEBPACK_IMPORTED_MODULE_1__.AutoModel,\n        \"processor\": _processors_js__WEBPACK_IMPORTED_MODULE_2__.AutoProcessor,\n        \"default\": {\n            // TODO: replace with original\n            // \"model\": \"openai/clip-vit-base-patch32\",\n            \"model\": \"Xenova/clip-vit-base-patch32\",\n        },\n        \"type\": \"multimodal\",\n    },\n\n    \"object-detection\": {\n        // no tokenizer\n        \"pipeline\": ObjectDetectionPipeline,\n        \"model\": _models_js__WEBPACK_IMPORTED_MODULE_1__.AutoModelForObjectDetection,\n        \"processor\": _processors_js__WEBPACK_IMPORTED_MODULE_2__.AutoProcessor,\n        \"default\": {\n            // TODO: replace with original\n            // \"model\": \"facebook/detr-resnet-50\",\n            \"model\": \"Xenova/detr-resnet-50\",\n        },\n        \"type\": \"multimodal\",\n    },\n\n    // This task serves as a useful interface for dealing with sentence-transformers (https://huggingface.co/sentence-transformers).\n    \"feature-extraction\": {\n        \"tokenizer\": _tokenizers_js__WEBPACK_IMPORTED_MODULE_0__.AutoTokenizer,\n        \"pipeline\": FeatureExtractionPipeline,\n        \"model\": _models_js__WEBPACK_IMPORTED_MODULE_1__.AutoModel,\n        \"default\": {\n            // TODO: replace with original\n            // \"model\": \"sentence-transformers/all-MiniLM-L6-v2\",\n            \"model\": \"Xenova/all-MiniLM-L6-v2\",\n        },\n        \"type\": \"text\",\n    },\n}\n\n\nconst TASK_ALIASES = {\n    \"sentiment-analysis\": \"text-classification\",\n    \"ner\": \"token-classification\",\n    \"vqa\": \"visual-question-answering\",\n    \"asr\": \"automatic-speech-recognition\",\n\n    // Add for backwards compatibility\n    \"embeddings\": \"feature-extraction\",\n}\n\n/**\n * @typedef {import('./utils/hub.js').PretrainedOptions} PretrainedOptions\n */\n\n/**\n * Utility factory method to build a [`Pipeline`] object.\n *\n * @param {string} task The task of the pipeline.\n * @param {string} [model=null] The name of the pre-trained model to use. If not specified, the default model for the task will be used.\n * @param {PretrainedOptions} [options] Optional parameters for the pipeline.\n * @returns {Promise<Pipeline>} A Pipeline object for the specified task.\n * @throws {Error} If an unsupported pipeline is requested.\n */\nasync function pipeline(\n    task,\n    model = null,\n    {\n        quantized = true,\n        progress_callback = null,\n        config = null,\n        cache_dir = null,\n        local_files_only = false,\n        revision = 'main',\n    } = {}\n) {\n    // Helper method to construct pipeline\n\n    // Apply aliases\n    task = TASK_ALIASES[task] ?? task;\n\n    // Get pipeline info\n    let pipelineInfo = SUPPORTED_TASKS[task.split('_', 1)[0]];\n    if (!pipelineInfo) {\n        throw Error(`Unsupported pipeline: ${task}. Must be one of [${Object.keys(SUPPORTED_TASKS)}]`)\n    }\n\n    // Use model if specified, otherwise, use default\n    if (!model) {\n        model = pipelineInfo.default.model\n        console.log(`No model specified. Using default model: \"${model}\".`);\n    }\n\n    let tokenizerClass = pipelineInfo.tokenizer;\n    let modelClass = pipelineInfo.model;\n    let pipelineClass = pipelineInfo.pipeline;\n    let processorClass = pipelineInfo.processor;\n\n    let promises = [];\n\n    let pretrainedOptions = {\n        quantized,\n        progress_callback,\n        config,\n        cache_dir,\n        local_files_only,\n        revision,\n    }\n    if (tokenizerClass) {\n        promises.push(\n            tokenizerClass.from_pretrained(model, pretrainedOptions),\n        )\n    }\n    if (modelClass) {\n        promises.push(\n            modelClass.from_pretrained(model, pretrainedOptions)\n        )\n    }\n\n    if (processorClass) {\n        promises.push(\n            processorClass.from_pretrained(model, pretrainedOptions)\n        )\n    }\n\n    // Load tokenizer and model\n    let items = await Promise.all(promises)\n\n    ;(0,_utils_core_js__WEBPACK_IMPORTED_MODULE_3__.dispatchCallback)(progress_callback, {\n        'status': 'ready',\n        'task': task,\n        'model': model,\n    });\n\n    return new pipelineClass(task, ...items);\n\n}\n\n/**\n * Compute the Cartesian product of given arrays\n * @param {...Array} a Arrays to compute the product\n * @returns {Array} Returns the computed Cartesian product as an array\n * @private\n */\nfunction product(...a) {\n    // Cartesian product of items\n    // Adapted from https://stackoverflow.com/a/43053803\n    return a.reduce((a, b) => a.flatMap(d => b.map(e => [d, e])));\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AeGVub3ZhL3RyYW5zZm9ybWVycy9zcmMvcGlwZWxpbmVzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksV0FBVztBQUN2QjtBQUNBO0FBQ0E7QUFDQSxRQUFRLDBDQUEwQztBQUNsRDtBQUNBO0FBQ0E7QUFDQTs7QUFLeUI7QUFjSjtBQUlJOzs7QUFRQTtBQU1DO0FBR0E7QUFHQztBQUNpQjs7QUFFNUM7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhLGdCQUFnQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwrQ0FBK0MscURBQVE7QUFDdkQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sdUJBQXVCLG9EQUFRO0FBQ3RDO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxxQkFBcUI7QUFDcEMsZUFBZSxpQkFBaUI7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixlQUFlO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLEtBQUs7QUFDcEIsaUJBQWlCLGNBQWM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLGVBQWUsS0FBSztBQUNwQixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQiwwQkFBMEI7QUFDM0M7QUFDQTtBQUNBO0FBQ0EsTUFBTSxJQUFJOztBQUVWOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qiw0REFBVyxDQUFDLHdEQUFPOztBQUU1QztBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFFTDtBQUNBO0FBQ0EscUJBQXFCLHlEQUFhO0FBQ2xDO0FBQ0EsaUJBQWlCLGlEQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsNENBQTRDO0FBQ3pEOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxtQkFBbUI7QUFDOUIsYUFBYSxtQkFBbUI7QUFDaEMsWUFBWSxPQUFPO0FBQ25CO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxLQUFLLG9CQUFvQiw2QkFBNkI7QUFDbkc7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLE1BQU07QUFDdkU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxJQUFJLGlFQUFnQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AeGVub3ZhL3RyYW5zZm9ybWVycy9zcmMvcGlwZWxpbmVzLmpzP2NlZmEiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAZmlsZSBQaXBlbGluZXMgcHJvdmlkZSBhIGhpZ2gtbGV2ZWwsIGVhc3kgdG8gdXNlLCBBUEkgZm9yIHJ1bm5pbmcgbWFjaGluZSBsZWFybmluZyBtb2RlbHMuXG4gKiBcbiAqICoqRXhhbXBsZToqKiBJbnN0YW50aWF0ZSBwaXBlbGluZSB1c2luZyB0aGUgYHBpcGVsaW5lYCBmdW5jdGlvbi5cbiAqIGBgYGphdmFzY3JpcHRcbiAqIGltcG9ydCB7IHBpcGVsaW5lIH0gZnJvbSAnQHhlbm92YS90cmFuc2Zvcm1lcnMnO1xuICogXG4gKiBsZXQgY2xhc3NpZmllciA9IGF3YWl0IHBpcGVsaW5lKCdzZW50aW1lbnQtYW5hbHlzaXMnKTtcbiAqIGxldCByZXN1bHQgPSBhd2FpdCBjbGFzc2lmaWVyKCdJIGxvdmUgdHJhbnNmb3JtZXJzIScpO1xuICogLy8gW3snbGFiZWwnOiAnUE9TSVRJVkUnLCAnc2NvcmUnOiAwLjk5OTgxNzY4Nn1dXG4gKiBgYGBcbiAqIFxuICogQG1vZHVsZSBwaXBlbGluZXNcbiAqL1xuXG5pbXBvcnQge1xuICAgIEF1dG9Ub2tlbml6ZXIsXG4gICAgUHJlVHJhaW5lZFRva2VuaXplcixcbn0gZnJvbSAnLi90b2tlbml6ZXJzLmpzJztcbmltcG9ydCB7XG4gICAgQXV0b01vZGVsLFxuICAgIEF1dG9Nb2RlbEZvclNlcXVlbmNlQ2xhc3NpZmljYXRpb24sXG4gICAgQXV0b01vZGVsRm9yVG9rZW5DbGFzc2lmaWNhdGlvbixcbiAgICBBdXRvTW9kZWxGb3JRdWVzdGlvbkFuc3dlcmluZyxcbiAgICBBdXRvTW9kZWxGb3JNYXNrZWRMTSxcbiAgICBBdXRvTW9kZWxGb3JTZXEyU2VxTE0sXG4gICAgQXV0b01vZGVsRm9yQ2F1c2FsTE0sXG4gICAgQXV0b01vZGVsRm9yVmlzaW9uMlNlcSxcbiAgICBBdXRvTW9kZWxGb3JJbWFnZUNsYXNzaWZpY2F0aW9uLFxuICAgIEF1dG9Nb2RlbEZvckltYWdlU2VnbWVudGF0aW9uLFxuICAgIEF1dG9Nb2RlbEZvck9iamVjdERldGVjdGlvbixcbiAgICBQcmVUcmFpbmVkTW9kZWwsXG59IGZyb20gJy4vbW9kZWxzLmpzJztcbmltcG9ydCB7XG4gICAgQXV0b1Byb2Nlc3NvcixcbiAgICBQcm9jZXNzb3Jcbn0gZnJvbSAnLi9wcm9jZXNzb3JzLmpzJztcblxuXG5pbXBvcnQge1xuICAgIENhbGxhYmxlLFxuICAgIGlzU3RyaW5nLFxuICAgIGRpc3BhdGNoQ2FsbGJhY2ssXG4gICAgcG9wLFxufSBmcm9tICcuL3V0aWxzL2NvcmUuanMnO1xuaW1wb3J0IHtcbiAgICBzb2Z0bWF4LFxuICAgIG1heCxcbiAgICBnZXRUb3BJdGVtcyxcbiAgICByb3VuZCxcbn0gZnJvbSAnLi91dGlscy9tYXRocy5qcyc7XG5pbXBvcnQge1xuICAgIHJlYWRfYXVkaW9cbn0gZnJvbSAnLi91dGlscy9hdWRpby5qcyc7XG5pbXBvcnQge1xuICAgIG1lYW5fcG9vbGluZyxcbn0gZnJvbSAnLi91dGlscy90ZW5zb3IuanMnO1xuaW1wb3J0IHsgUmF3SW1hZ2UgfSBmcm9tICcuL3V0aWxzL2ltYWdlLmpzJztcblxuLyoqXG4gKiBQcmVwYXJlIGltYWdlcyBmb3IgZnVydGhlciB0YXNrcy5cbiAqIEBwYXJhbSB7YW55W119IGltYWdlcyBpbWFnZXMgdG8gcHJlcGFyZS5cbiAqIEByZXR1cm5zIHtQcm9taXNlPGFueVtdPn0gcmV0dXJucyBwcm9jZXNzZWQgaW1hZ2VzLlxuICogQHByaXZhdGVcbiAqL1xuYXN5bmMgZnVuY3Rpb24gcHJlcGFyZUltYWdlcyhpbWFnZXMpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoaW1hZ2VzKSkge1xuICAgICAgICBpbWFnZXMgPSBbaW1hZ2VzXTtcbiAgICB9XG5cbiAgICAvLyBQb3NzaWJseSBjb252ZXJ0IGFueSBub24taW1hZ2VzIHRvIGltYWdlc1xuICAgIGltYWdlcyA9IGF3YWl0IFByb21pc2UuYWxsKGltYWdlcy5tYXAoeCA9PiBSYXdJbWFnZS5yZWFkKHgpKSk7XG4gICAgcmV0dXJuIGltYWdlcztcbn1cblxuLyoqXG4gKiBUaGUgUGlwZWxpbmUgY2xhc3MgaXMgdGhlIGNsYXNzIGZyb20gd2hpY2ggYWxsIHBpcGVsaW5lcyBpbmhlcml0LlxuICogUmVmZXIgdG8gdGhpcyBjbGFzcyBmb3IgbWV0aG9kcyBzaGFyZWQgYWNyb3NzIGRpZmZlcmVudCBwaXBlbGluZXMuXG4gKiBAZXh0ZW5kcyBDYWxsYWJsZVxuICovXG5leHBvcnQgY2xhc3MgUGlwZWxpbmUgZXh0ZW5kcyBDYWxsYWJsZSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IFBpcGVsaW5lLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0YXNrIFRoZSB0YXNrIG9mIHRoZSBwaXBlbGluZS4gVXNlZnVsIGZvciBzcGVjaWZ5aW5nIHN1YnRhc2tzLlxuICAgICAqIEBwYXJhbSB7UHJlVHJhaW5lZFRva2VuaXplcn0gdG9rZW5pemVyIFRoZSB0b2tlbml6ZXIgdG8gdXNlLlxuICAgICAqIEBwYXJhbSB7UHJlVHJhaW5lZE1vZGVsfSBtb2RlbCBUaGUgbW9kZWwgdG8gdXNlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHRhc2ssIHRva2VuaXplciwgbW9kZWwpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy50YXNrID0gdGFzaztcbiAgICAgICAgdGhpcy50b2tlbml6ZXIgPSB0b2tlbml6ZXI7XG4gICAgICAgIHRoaXMubW9kZWwgPSBtb2RlbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEaXNwb3NlcyB0aGUgbW9kZWwuXG4gICAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdoZW4gdGhlIG1vZGVsIGhhcyBiZWVuIGRpc3Bvc2VkLlxuICAgICAqL1xuICAgIGFzeW5jIGRpc3Bvc2UoKSB7XG4gICAgICAgIGF3YWl0IHRoaXMubW9kZWwuZGlzcG9zZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV4ZWN1dGVzIHRoZSB0YXNrIGFzc29jaWF0ZWQgd2l0aCB0aGUgcGlwZWxpbmUuXG4gICAgICogQHBhcmFtIHthbnl9IHRleHRzIFRoZSBpbnB1dCB0ZXh0cyB0byBiZSBwcm9jZXNzZWQuXG4gICAgICogQHJldHVybnMge1Byb21pc2U8YW55Pn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYW4gYXJyYXkgY29udGFpbmluZyB0aGUgaW5wdXRzIGFuZCBvdXRwdXRzIG9mIHRoZSB0YXNrLlxuICAgICAqL1xuICAgIGFzeW5jIF9jYWxsKHRleHRzKSB7XG4gICAgICAgIC8vIFJ1biB0b2tlbml6YXRpb25cbiAgICAgICAgbGV0IGlucHV0cyA9IHRoaXMudG9rZW5pemVyKHRleHRzLCB7XG4gICAgICAgICAgICBwYWRkaW5nOiB0cnVlLFxuICAgICAgICAgICAgdHJ1bmNhdGlvbjogdHJ1ZVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBSdW4gbW9kZWxcbiAgICAgICAgbGV0IG91dHB1dHMgPSBhd2FpdCB0aGlzLm1vZGVsKGlucHV0cylcblxuICAgICAgICByZXR1cm4gW2lucHV0cywgb3V0cHV0c107XG4gICAgfVxufVxuXG4vKipcbiAqIFRleHQgY2xhc3NpZmljYXRpb24gcGlwZWxpbmUgdXNpbmcgYW55IGBNb2RlbEZvclNlcXVlbmNlQ2xhc3NpZmljYXRpb25gLlxuICogQGV4dGVuZHMgUGlwZWxpbmVcbiAqL1xuZXhwb3J0IGNsYXNzIFRleHRDbGFzc2lmaWNhdGlvblBpcGVsaW5lIGV4dGVuZHMgUGlwZWxpbmUge1xuICAgIC8qKlxuICAgICAqIEV4ZWN1dGVzIHRoZSB0ZXh0IGNsYXNzaWZpY2F0aW9uIHRhc2suXG4gICAgICogQHBhcmFtIHthbnl9IHRleHRzIFRoZSBpbnB1dCB0ZXh0cyB0byBiZSBjbGFzc2lmaWVkLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIEFuIG9wdGlvbmFsIG9iamVjdCBjb250YWluaW5nIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMudG9waz0xXSBUaGUgbnVtYmVyIG9mIHRvcCBwcmVkaWN0aW9ucyB0byBiZSByZXR1cm5lZC5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3RbXXxPYmplY3Q+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhbiBhcnJheSBvciBvYmplY3QgY29udGFpbmluZyB0aGUgcHJlZGljdGVkIGxhYmVscyBhbmQgc2NvcmVzLlxuICAgICAqL1xuICAgIGFzeW5jIF9jYWxsKHRleHRzLCB7XG4gICAgICAgIHRvcGsgPSAxXG4gICAgfSA9IHt9KSB7XG5cbiAgICAgICAgbGV0IFtpbnB1dHMsIG91dHB1dHNdID0gYXdhaXQgc3VwZXIuX2NhbGwodGV4dHMpO1xuXG4gICAgICAgIGxldCBpZDJsYWJlbCA9IHRoaXMubW9kZWwuY29uZmlnLmlkMmxhYmVsO1xuICAgICAgICBsZXQgdG9SZXR1cm4gPSBbXTtcbiAgICAgICAgZm9yIChsZXQgYmF0Y2ggb2Ygb3V0cHV0cy5sb2dpdHMpIHtcbiAgICAgICAgICAgIGxldCBzY29yZXMgPSBnZXRUb3BJdGVtcyhzb2Z0bWF4KGJhdGNoLmRhdGEpLCB0b3BrKTtcblxuICAgICAgICAgICAgbGV0IHZhbHMgPSBzY29yZXMubWFwKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgbGFiZWw6IGlkMmxhYmVsW3hbMF1dLFxuICAgICAgICAgICAgICAgICAgICBzY29yZTogeFsxXSxcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICh0b3BrID09PSAxKSB7XG4gICAgICAgICAgICAgICAgdG9SZXR1cm4ucHVzaCguLi52YWxzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdG9SZXR1cm4ucHVzaCh2YWxzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KHRleHRzKSB8fCB0b3BrID09PSAxID8gdG9SZXR1cm4gOiB0b1JldHVyblswXTtcbiAgICB9XG59XG5cblxuLyoqXG4gKiBOYW1lZCBFbnRpdHkgUmVjb2duaXRpb24gcGlwZWxpbmUgdXNpbmcgYW55IGBNb2RlbEZvclRva2VuQ2xhc3NpZmljYXRpb25gLlxuICogQGV4dGVuZHMgUGlwZWxpbmVcbiAqL1xuZXhwb3J0IGNsYXNzIFRva2VuQ2xhc3NpZmljYXRpb25QaXBlbGluZSBleHRlbmRzIFBpcGVsaW5lIHtcbiAgICAvKipcbiAgICAgKiBFeGVjdXRlcyB0aGUgdG9rZW4gY2xhc3NpZmljYXRpb24gdGFzay5cbiAgICAgKiBAcGFyYW0ge2FueX0gdGV4dHMgVGhlIGlucHV0IHRleHRzIHRvIGJlIGNsYXNzaWZpZWQuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgQW4gb3B0aW9uYWwgb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdFtdfE9iamVjdD59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGFuIGFycmF5IG9yIG9iamVjdCBjb250YWluaW5nIHRoZSBwcmVkaWN0ZWQgbGFiZWxzIGFuZCBzY29yZXMuXG4gICAgICovXG4gICAgYXN5bmMgX2NhbGwodGV4dHMsIHtcbiAgICAgICAgaWdub3JlX2xhYmVscyA9IFsnTyddLCAvLyBUT0RPIGluaXQgcGFyYW0/XG4gICAgfSA9IHt9KSB7XG5cbiAgICAgICAgbGV0IGlzQmF0Y2hlZCA9IEFycmF5LmlzQXJyYXkodGV4dHMpO1xuXG4gICAgICAgIGlmICghaXNCYXRjaGVkKSB7XG4gICAgICAgICAgICB0ZXh0cyA9IFt0ZXh0c107XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgdG9rZW5pemVyID0gdGhpcy50b2tlbml6ZXI7XG4gICAgICAgIGxldCBbaW5wdXRzLCBvdXRwdXRzXSA9IGF3YWl0IHN1cGVyLl9jYWxsKHRleHRzKTtcblxuICAgICAgICBsZXQgbG9naXRzID0gb3V0cHV0cy5sb2dpdHM7XG4gICAgICAgIGxldCBpZDJsYWJlbCA9IHRoaXMubW9kZWwuY29uZmlnLmlkMmxhYmVsO1xuXG4gICAgICAgIGxldCB0b1JldHVybiA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxvZ2l0cy5kaW1zWzBdOyArK2kpIHtcbiAgICAgICAgICAgIGxldCBpZHMgPSBpbnB1dHMuaW5wdXRfaWRzW2ldO1xuICAgICAgICAgICAgbGV0IGJhdGNoID0gbG9naXRzW2ldO1xuXG4gICAgICAgICAgICAvLyBMaXN0IG9mIHRva2VucyB0aGF0IGFyZW4ndCBpZ25vcmVkXG4gICAgICAgICAgICBsZXQgdG9rZW5zID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGJhdGNoLmRpbXNbMF07ICsraikge1xuICAgICAgICAgICAgICAgIGxldCB0b2tlbkRhdGEgPSBiYXRjaFtqXTtcbiAgICAgICAgICAgICAgICBsZXQgdG9wU2NvcmVJbmRleCA9IG1heCh0b2tlbkRhdGEuZGF0YSlbMV07XG5cbiAgICAgICAgICAgICAgICBsZXQgZW50aXR5ID0gaWQybGFiZWxbdG9wU2NvcmVJbmRleF07XG4gICAgICAgICAgICAgICAgaWYgKGlnbm9yZV9sYWJlbHMuaW5jbHVkZXMoZW50aXR5KSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBXZSBwcmVkaWN0ZWQgYSB0b2tlbiB0aGF0IHNob3VsZCBiZSBpZ25vcmVkLiBTbywgd2Ugc2tpcCBpdC5cbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gVE9ETyBhZGQgb3B0aW9uIHRvIGtlZXAgc3BlY2lhbCB0b2tlbnM/XG4gICAgICAgICAgICAgICAgbGV0IHdvcmQgPSB0b2tlbml6ZXIuZGVjb2RlKFtpZHNbal0uaXRlbSgpXSwgeyBza2lwX3NwZWNpYWxfdG9rZW5zOiB0cnVlIH0pO1xuICAgICAgICAgICAgICAgIGlmICh3b3JkID09PSAnJykge1xuICAgICAgICAgICAgICAgICAgICAvLyBXYXMgYSBzcGVjaWFsIHRva2VuLiBTbywgd2Ugc2tpcCBpdC5cbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbGV0IHNjb3JlcyA9IHNvZnRtYXgodG9rZW5EYXRhLmRhdGEpO1xuXG4gICAgICAgICAgICAgICAgdG9rZW5zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBlbnRpdHk6IGVudGl0eSxcbiAgICAgICAgICAgICAgICAgICAgc2NvcmU6IHNjb3Jlc1t0b3BTY29yZUluZGV4XSxcbiAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGosXG4gICAgICAgICAgICAgICAgICAgIHdvcmQ6IHdvcmQsXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogbnVsbCBmb3Igbm93LCBidXQgd2lsbCBhZGRcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIGVuZDogbnVsbCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRvUmV0dXJuLnB1c2godG9rZW5zKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXNCYXRjaGVkID8gdG9SZXR1cm4gOiB0b1JldHVyblswXTtcbiAgICB9XG59XG4vKipcbiAqIFF1ZXN0aW9uIEFuc3dlcmluZyBwaXBlbGluZSB1c2luZyBhbnkgYE1vZGVsRm9yUXVlc3Rpb25BbnN3ZXJpbmdgLlxuICogXG4gKiAqKkV4YW1wbGU6KiogUnVuIHF1ZXN0aW9uIGFuc3dlcmluZyB3aXRoIGBkaXN0aWxiZXJ0LWJhc2UtdW5jYXNlZC1kaXN0aWxsZWQtc3F1YWRgLlxuICogYGBgamF2YXNjcmlwdFxuICogbGV0IHF1ZXN0aW9uID0gJ1dobyB3YXMgSmltIEhlbnNvbj8nO1xuICogbGV0IGNvbnRleHQgPSAnSmltIEhlbnNvbiB3YXMgYSBuaWNlIHB1cHBldC4nO1xuICogXG4gKiBsZXQgYW5zd2VyZXIgPSBhd2FpdCBwaXBlbGluZSgncXVlc3Rpb24tYW5zd2VyaW5nJywgJ1hlbm92YS9kaXN0aWxiZXJ0LWJhc2UtdW5jYXNlZC1kaXN0aWxsZWQtc3F1YWQnKTtcbiAqIGxldCBvdXRwdXRzID0gYXdhaXQgYW5zd2VyZXIocXVlc3Rpb24sIGNvbnRleHQpO1xuICogY29uc29sZS5sb2cob3V0cHV0cyk7XG4gKiAvLyB7XG4gKiAvLyAgICAgXCJhbnN3ZXJcIjogXCJhIG5pY2UgcHVwcGV0XCIsXG4gKiAvLyAgICAgXCJzY29yZVwiOiAwLjU3Njg5MTE1MDI1MjY3NDFcbiAqIC8vIH1cbiAqIGBgYFxuICogQGV4dGVuZHMgUGlwZWxpbmVcbiAqL1xuZXhwb3J0IGNsYXNzIFF1ZXN0aW9uQW5zd2VyaW5nUGlwZWxpbmUgZXh0ZW5kcyBQaXBlbGluZSB7XG4gICAgLyoqXG4gICAgICogRXhlY3V0ZXMgdGhlIHF1ZXN0aW9uIGFuc3dlcmluZyB0YXNrLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfHN0cmluZ1tdfSBxdWVzdGlvbiBUaGUgcXVlc3Rpb24ocykgdG8gYmUgYW5zd2VyZWQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IGNvbnRleHQgVGhlIGNvbnRleHQocykgd2hlcmUgdGhlIGFuc3dlcihzKSBjYW4gYmUgZm91bmQuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgQW4gb3B0aW9uYWwgb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy50b3BrPTFdIFRoZSBudW1iZXIgb2YgdG9wIGFuc3dlciBwcmVkaWN0aW9ucyB0byBiZSByZXR1cm5lZC5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxhbnk+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhbiBhcnJheSBvciBvYmplY3QgY29udGFpbmluZyB0aGUgcHJlZGljdGVkIGFuc3dlcnMgYW5kIHNjb3Jlcy5cbiAgICAgKi9cbiAgICAvLyBAdHMtaWdub3JlXG4gICAgYXN5bmMgX2NhbGwocXVlc3Rpb24sIGNvbnRleHQsIHtcbiAgICAgICAgdG9wayA9IDFcbiAgICB9ID0ge30pIHtcblxuICAgICAgICAvLyBSdW4gdG9rZW5pemF0aW9uXG4gICAgICAgIGxldCBpbnB1dHMgPSB0aGlzLnRva2VuaXplcihxdWVzdGlvbiwge1xuICAgICAgICAgICAgdGV4dF9wYWlyOiBjb250ZXh0LFxuICAgICAgICAgICAgcGFkZGluZzogdHJ1ZSxcbiAgICAgICAgICAgIHRydW5jYXRpb246IHRydWVcbiAgICAgICAgfSk7XG5cbiAgICAgICAgbGV0IG91dHB1dCA9IGF3YWl0IHRoaXMubW9kZWwoaW5wdXRzKTtcblxuICAgICAgICBsZXQgdG9SZXR1cm4gPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBvdXRwdXQuc3RhcnRfbG9naXRzLmRpbXNbMF07ICsraikge1xuICAgICAgICAgICAgbGV0IGlkcyA9IGlucHV0cy5pbnB1dF9pZHNbal07XG4gICAgICAgICAgICBsZXQgc2VwSW5kZXggPSBpZHMuaW5kZXhPZih0aGlzLnRva2VuaXplci5zZXBfdG9rZW5faWQpO1xuXG4gICAgICAgICAgICBsZXQgczEgPSBBcnJheS5mcm9tKHNvZnRtYXgob3V0cHV0LnN0YXJ0X2xvZ2l0c1tqXS5kYXRhKSlcbiAgICAgICAgICAgICAgICAubWFwKCh4LCBpKSA9PiBbeCwgaV0pXG4gICAgICAgICAgICAgICAgLmZpbHRlcih4ID0+IHhbMV0gPiBzZXBJbmRleCk7XG4gICAgICAgICAgICBsZXQgZTEgPSBBcnJheS5mcm9tKHNvZnRtYXgob3V0cHV0LmVuZF9sb2dpdHNbal0uZGF0YSkpXG4gICAgICAgICAgICAgICAgLm1hcCgoeCwgaSkgPT4gW3gsIGldKVxuICAgICAgICAgICAgICAgIC5maWx0ZXIoeCA9PiB4WzFdID4gc2VwSW5kZXgpO1xuXG4gICAgICAgICAgICBsZXQgb3B0aW9ucyA9IHByb2R1Y3QoczEsIGUxKVxuICAgICAgICAgICAgICAgIC5maWx0ZXIoeCA9PiB4WzBdWzFdIDw9IHhbMV1bMV0pXG4gICAgICAgICAgICAgICAgLm1hcCh4ID0+IFt4WzBdWzFdLCB4WzFdWzFdLCB4WzBdWzBdICogeFsxXVswXV0pXG4gICAgICAgICAgICAgICAgLnNvcnQoKGEsIGIpID0+IGJbMl0gLSBhWzJdKTtcblxuICAgICAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCBNYXRoLm1pbihvcHRpb25zLmxlbmd0aCwgdG9wayk7ICsraykge1xuICAgICAgICAgICAgICAgIGxldCBbc3RhcnQsIGVuZCwgc2NvcmVdID0gb3B0aW9uc1trXTtcblxuICAgICAgICAgICAgICAgIGxldCBhbnN3ZXJfdG9rZW5zID0gWy4uLmlkc10uc2xpY2Uoc3RhcnQsIGVuZCArIDEpXG5cbiAgICAgICAgICAgICAgICBsZXQgYW5zd2VyID0gdGhpcy50b2tlbml6ZXIuZGVjb2RlKGFuc3dlcl90b2tlbnMsIHtcbiAgICAgICAgICAgICAgICAgICAgc2tpcF9zcGVjaWFsX3Rva2VuczogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIC8vIFRPRE8gYWRkIHN0YXJ0IGFuZCBlbmQ/XG4gICAgICAgICAgICAgICAgLy8gTk9URTogSEYgcmV0dXJucyBjaGFyYWN0ZXIgaW5kZXhcbiAgICAgICAgICAgICAgICB0b1JldHVybi5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgYW5zd2VyLCBzY29yZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gTWltaWMgSEYncyByZXR1cm4gdHlwZSBiYXNlZCBvbiB0b3BrXG4gICAgICAgIHJldHVybiAodG9wayA9PT0gMSkgPyB0b1JldHVyblswXSA6IHRvUmV0dXJuO1xuXG4gICAgfVxufVxuXG4vKipcbiAqIE1hc2tlZCBsYW5ndWFnZSBtb2RlbGluZyBwcmVkaWN0aW9uIHBpcGVsaW5lIHVzaW5nIGFueSBgTW9kZWxXaXRoTE1IZWFkYC5cbiAqIEBleHRlbmRzIFBpcGVsaW5lXG4gKi9cbmV4cG9ydCBjbGFzcyBGaWxsTWFza1BpcGVsaW5lIGV4dGVuZHMgUGlwZWxpbmUge1xuICAgIC8qKlxuICAgICAqIEZpbGwgdGhlIG1hc2tlZCB0b2tlbiBpbiB0aGUgdGV4dChzKSBnaXZlbiBhcyBpbnB1dHMuXG4gICAgICogQHBhcmFtIHthbnl9IHRleHRzIFRoZSBtYXNrZWQgaW5wdXQgdGV4dHMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgQW4gb3B0aW9uYWwgb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy50b3BrPTVdIFRoZSBudW1iZXIgb2YgdG9wIHByZWRpY3Rpb25zIHRvIGJlIHJldHVybmVkLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdFtdfE9iamVjdD59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGFuIGFycmF5IG9yIG9iamVjdCBjb250YWluaW5nIHRoZSBwcmVkaWN0ZWQgdG9rZW5zIGFuZCBzY29yZXMuXG4gICAgICovXG4gICAgYXN5bmMgX2NhbGwodGV4dHMsIHtcbiAgICAgICAgdG9wayA9IDVcbiAgICB9ID0ge30pIHtcbiAgICAgICAgLy8gUnVuIHRva2VuaXphdGlvblxuICAgICAgICBsZXQgW2lucHV0cywgb3V0cHV0c10gPSBhd2FpdCBzdXBlci5fY2FsbCh0ZXh0cyk7XG5cbiAgICAgICAgLy8gRGV0ZXJtaW5lIGluZGljZXMgb2YgbWFzayB0b2tlbnNcbiAgICAgICAgLy8gbGV0IG1hc2tfdG9rZW5faW5kaWNlcyA9IGlucHV0cy5pbnB1dF9pZHMuZGF0YS5tYXAoeCA9PiApXG5cbiAgICAgICAgLy8gbGV0IGxvZ2l0cyA9IHJlc2hhcGUob3V0cHV0cy5sb2dpdHMuZGF0YSwgb3V0cHV0cy5sb2dpdHMuZGltcyk7XG5cbiAgICAgICAgbGV0IHRva2VuaXplciA9IHRoaXMudG9rZW5pemVyO1xuXG4gICAgICAgIGxldCB0b1JldHVybiA9IFtdO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5wdXRzLmlucHV0X2lkcy5kaW1zWzBdOyArK2kpIHtcbiAgICAgICAgICAgIGxldCBpZHMgPSBpbnB1dHMuaW5wdXRfaWRzW2ldO1xuICAgICAgICAgICAgbGV0IG1hc2tfdG9rZW5faW5kZXggPSBpZHMuaW5kZXhPZih0aGlzLnRva2VuaXplci5tYXNrX3Rva2VuX2lkKVxuXG4gICAgICAgICAgICBpZiAobWFza190b2tlbl9pbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihgTWFzayB0b2tlbiAoJHt0b2tlbml6ZXIubWFza190b2tlbn0pIG5vdCBmb3VuZCBpbiB0ZXh0LmApXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgbG9naXRzID0gb3V0cHV0cy5sb2dpdHNbaV07XG4gICAgICAgICAgICBsZXQgaXRlbUxvZ2l0cyA9IGxvZ2l0c1ttYXNrX3Rva2VuX2luZGV4XTtcblxuICAgICAgICAgICAgbGV0IHNjb3JlcyA9IGdldFRvcEl0ZW1zKHNvZnRtYXgoaXRlbUxvZ2l0cy5kYXRhKSwgdG9wayk7XG5cbiAgICAgICAgICAgIHRvUmV0dXJuLnB1c2goc2NvcmVzLm1hcCh4ID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgc2VxdWVuY2UgPSBbLi4uaWRzXTtcbiAgICAgICAgICAgICAgICBzZXF1ZW5jZVttYXNrX3Rva2VuX2luZGV4XSA9IHhbMF07XG5cbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBzY29yZTogeFsxXSxcbiAgICAgICAgICAgICAgICAgICAgdG9rZW46IHhbMF0sXG4gICAgICAgICAgICAgICAgICAgIHRva2VuX3N0cjogdG9rZW5pemVyLm1vZGVsLnZvY2FiW3hbMF1dLFxuICAgICAgICAgICAgICAgICAgICBzZXF1ZW5jZTogdG9rZW5pemVyLmRlY29kZShzZXF1ZW5jZSwgeyBza2lwX3NwZWNpYWxfdG9rZW5zOiB0cnVlIH0pLFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh0ZXh0cykgPyB0b1JldHVybiA6IHRvUmV0dXJuWzBdO1xuICAgIH1cbn1cblxuLyoqXG4gKiBUZXh0MlRleHRHZW5lcmF0aW9uUGlwZWxpbmUgY2xhc3MgZm9yIGdlbmVyYXRpbmcgdGV4dCB1c2luZyBhIG1vZGVsIHRoYXQgcGVyZm9ybXMgdGV4dC10by10ZXh0IGdlbmVyYXRpb24gdGFza3MuXG4gKiBAZXh0ZW5kcyBQaXBlbGluZVxuICovXG5leHBvcnQgY2xhc3MgVGV4dDJUZXh0R2VuZXJhdGlvblBpcGVsaW5lIGV4dGVuZHMgUGlwZWxpbmUge1xuICAgIF9rZXkgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogRmlsbCB0aGUgbWFza2VkIHRva2VuIGluIHRoZSB0ZXh0KHMpIGdpdmVuIGFzIGlucHV0cy5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXX0gdGV4dHMgVGhlIHRleHQgb3IgYXJyYXkgb2YgdGV4dHMgdG8gYmUgcHJvY2Vzc2VkLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gT3B0aW9ucyBmb3IgdGhlIGZpbGwtbWFzayBwaXBlbGluZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMudG9waz01XSBUaGUgbnVtYmVyIG9mIHRvcC1rIHByZWRpY3Rpb25zIHRvIHJldHVybi5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxhbnk+fSBBbiBhcnJheSBvZiBvYmplY3RzIGNvbnRhaW5pbmcgdGhlIHNjb3JlLCBwcmVkaWN0ZWQgdG9rZW4sIHByZWRpY3RlZCB0b2tlbiBzdHJpbmcsXG4gICAgICogYW5kIHRoZSBzZXF1ZW5jZSB3aXRoIHRoZSBwcmVkaWN0ZWQgdG9rZW4gZmlsbGVkIGluLCBvciBhbiBhcnJheSBvZiBzdWNoIGFycmF5cyAob25lIGZvciBlYWNoIGlucHV0IHRleHQpLlxuICAgICAqIElmIG9ubHkgb25lIGlucHV0IHRleHQgaXMgZ2l2ZW4sIHRoZSBvdXRwdXQgd2lsbCBiZSBhbiBhcnJheSBvZiBvYmplY3RzLlxuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBXaGVuIHRoZSBtYXNrIHRva2VuIGlzIG5vdCBmb3VuZCBpbiB0aGUgaW5wdXQgdGV4dC5cbiAgICAgKi9cbiAgICBhc3luYyBfY2FsbCh0ZXh0cywgZ2VuZXJhdGVfa3dhcmdzID0ge30pIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHRleHRzKSkge1xuICAgICAgICAgICAgdGV4dHMgPSBbdGV4dHNdO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQWRkIGdsb2JhbCBwcmVmaXgsIGlmIHByZXNlbnRcbiAgICAgICAgaWYgKHRoaXMubW9kZWwuY29uZmlnLnByZWZpeCkge1xuICAgICAgICAgICAgdGV4dHMgPSB0ZXh0cy5tYXAoeCA9PiB0aGlzLm1vZGVsLmNvbmZpZy5wcmVmaXggKyB4KVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gSGFuZGxlIHRhc2sgc3BlY2lmaWMgcGFyYW1zOlxuICAgICAgICBsZXQgdGFza19zcGVjaWZpY19wYXJhbXMgPSB0aGlzLm1vZGVsLmNvbmZpZy50YXNrX3NwZWNpZmljX3BhcmFtc1xuICAgICAgICBpZiAodGFza19zcGVjaWZpY19wYXJhbXMgJiYgdGFza19zcGVjaWZpY19wYXJhbXNbdGhpcy50YXNrXSkge1xuICAgICAgICAgICAgLy8gQWRkIHByZWZpeGVzLCBpZiBwcmVzZW50XG4gICAgICAgICAgICBpZiAodGFza19zcGVjaWZpY19wYXJhbXNbdGhpcy50YXNrXS5wcmVmaXgpIHtcbiAgICAgICAgICAgICAgICB0ZXh0cyA9IHRleHRzLm1hcCh4ID0+IHRhc2tfc3BlY2lmaWNfcGFyYW1zW3RoaXMudGFza10ucHJlZml4ICsgeClcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gVE9ETyB1cGRhdGUgZ2VuZXJhdGlvbiBjb25maWdcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCB0b2tlbml6ZXJfb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIHBhZGRpbmc6IHRydWUsXG4gICAgICAgICAgICB0cnVuY2F0aW9uOiB0cnVlLFxuICAgICAgICB9XG4gICAgICAgIGxldCBpbnB1dF9pZHM7XG4gICAgICAgIGlmICh0aGlzIGluc3RhbmNlb2YgVHJhbnNsYXRpb25QaXBlbGluZSAmJiAnX2J1aWxkX3RyYW5zbGF0aW9uX2lucHV0cycgaW4gdGhpcy50b2tlbml6ZXIpIHtcbiAgICAgICAgICAgIC8vIFRPRE86IG1vdmUgdG8gVHJhbnNsYXRpb24gcGlwZWxpbmU/XG4gICAgICAgICAgICAvLyBDdXJyZW50bHkgcHV0IGhlcmUgdG8gYXZvaWQgY29kZSBkdXBsaWNhdGlvblxuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgaW5wdXRfaWRzID0gdGhpcy50b2tlbml6ZXIuX2J1aWxkX3RyYW5zbGF0aW9uX2lucHV0cyh0ZXh0cywgdG9rZW5pemVyX29wdGlvbnMsIGdlbmVyYXRlX2t3YXJncykuaW5wdXRfaWRzO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpbnB1dF9pZHMgPSB0aGlzLnRva2VuaXplcih0ZXh0cywgdG9rZW5pemVyX29wdGlvbnMpLmlucHV0X2lkcztcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBvdXRwdXRUb2tlbklkcyA9IGF3YWl0IHRoaXMubW9kZWwuZ2VuZXJhdGUoaW5wdXRfaWRzLCBnZW5lcmF0ZV9rd2FyZ3MpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7YW55W119XG4gICAgICAgICAqL1xuICAgICAgICBsZXQgdG9SZXR1cm4gPSB0aGlzLnRva2VuaXplci5iYXRjaF9kZWNvZGUob3V0cHV0VG9rZW5JZHMsIHtcbiAgICAgICAgICAgIHNraXBfc3BlY2lhbF90b2tlbnM6IHRydWUsXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodGhpcy5fa2V5ICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0b1JldHVybiA9IHRvUmV0dXJuLm1hcCh0ZXh0ID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKHRoaXMuX2tleSA9PT0gbnVsbCkgPyB0ZXh0IDogeyBbdGhpcy5fa2V5XTogdGV4dCB9XG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b1JldHVyblxuICAgIH1cbn1cblxuXG4vKipcbiAqIEEgcGlwZWxpbmUgZm9yIHN1bW1hcml6YXRpb24gdGFza3MsIGluaGVyaXRpbmcgZnJvbSBUZXh0MlRleHRHZW5lcmF0aW9uUGlwZWxpbmUuXG4gKiBAZXh0ZW5kcyBUZXh0MlRleHRHZW5lcmF0aW9uUGlwZWxpbmVcbiAqL1xuZXhwb3J0IGNsYXNzIFN1bW1hcml6YXRpb25QaXBlbGluZSBleHRlbmRzIFRleHQyVGV4dEdlbmVyYXRpb25QaXBlbGluZSB7XG4gICAgX2tleSA9ICdzdW1tYXJ5X3RleHQnO1xufVxuXG4vKipcbiAqIFRyYW5zbGF0aW9uUGlwZWxpbmUgY2xhc3MgdG8gdHJhbnNsYXRlIHRleHQgZnJvbSBvbmUgbGFuZ3VhZ2UgdG8gYW5vdGhlciB1c2luZyB0aGUgcHJvdmlkZWQgbW9kZWwgYW5kIHRva2VuaXplci5cbiAqIEBleHRlbmRzIFRleHQyVGV4dEdlbmVyYXRpb25QaXBlbGluZVxuICovXG5leHBvcnQgY2xhc3MgVHJhbnNsYXRpb25QaXBlbGluZSBleHRlbmRzIFRleHQyVGV4dEdlbmVyYXRpb25QaXBlbGluZSB7XG4gICAgX2tleSA9ICd0cmFuc2xhdGlvbl90ZXh0Jztcbn1cblxuLyoqXG4gKiBMYW5ndWFnZSBnZW5lcmF0aW9uIHBpcGVsaW5lIHVzaW5nIGFueSBgTW9kZWxXaXRoTE1IZWFkYCBvciBgTW9kZWxGb3JDYXVzYWxMTWAuXG4gKiBUaGlzIHBpcGVsaW5lIHByZWRpY3RzIHRoZSB3b3JkcyB0aGF0IHdpbGwgZm9sbG93IGEgc3BlY2lmaWVkIHRleHQgcHJvbXB0LlxuICogTk9URTogRm9yIHRoZSBmdWxsIGxpc3Qgb2YgZ2VuZXJhdGlvbiBwYXJhbWV0ZXJzLCBzZWUgW2BHZW5lcmF0aW9uQ29uZmlnYF0oLi91dGlscy9nZW5lcmF0aW9uI21vZHVsZV91dGlscy9nZW5lcmF0aW9uLkdlbmVyYXRpb25Db25maWcpLlxuICogXG4gKiAqKkV4YW1wbGU6KiogVGV4dCBnZW5lcmF0aW9uIHdpdGggYFhlbm92YS9kaXN0aWxncHQyYCAoZGVmYXVsdCBzZXR0aW5ncykuXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBsZXQgdGV4dCA9ICdJIGVuam95IHdhbGtpbmcgd2l0aCBteSBjdXRlIGRvZywnO1xuICogbGV0IGdlbmVyYXRvciA9IGF3YWl0IHBpcGVsaW5lKCd0ZXh0LWdlbmVyYXRpb24nLCAnWGVub3ZhL2Rpc3RpbGdwdDInKTtcbiAqIGxldCBvdXRwdXQgPSBhd2FpdCBnZW5lcmF0b3IodGV4dCk7XG4gKiBjb25zb2xlLmxvZyhvdXRwdXQpO1xuICogLy8gW3sgZ2VuZXJhdGVkX3RleHQ6IFwiSSBlbmpveSB3YWxraW5nIHdpdGggbXkgY3V0ZSBkb2csIGFuZCBJIGxvdmUgdG8gcGxheSB3aXRoIHRoZSBvdGhlciBkb2dzLlwiIH1dXG4gKiBgYGBcbiAqIFxuICogKipFeGFtcGxlOioqIFRleHQgZ2VuZXJhdGlvbiB3aXRoIGBYZW5vdmEvZGlzdGlsZ3B0MmAgKGN1c3RvbSBzZXR0aW5ncykuXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBsZXQgdGV4dCA9ICdPbmNlIHVwb24gYSB0aW1lLCB0aGVyZSB3YXMnO1xuICogbGV0IGdlbmVyYXRvciA9IGF3YWl0IHBpcGVsaW5lKCd0ZXh0LWdlbmVyYXRpb24nLCAnWGVub3ZhL2Rpc3RpbGdwdDInKTtcbiAqIGxldCBvdXRwdXQgPSBhd2FpdCBnZW5lcmF0b3IodGV4dCwge1xuICogICAgIHRlbXBlcmF0dXJlOiAyLFxuICogICAgIG1heF9uZXdfdG9rZW5zOiAxMCxcbiAqICAgICByZXBldGl0aW9uX3BlbmFsdHk6IDEuNSxcbiAqICAgICBub19yZXBlYXRfbmdyYW1fc2l6ZTogMixcbiAqICAgICBudW1fYmVhbXM6IDIsXG4gKiAgICAgbnVtX3JldHVybl9zZXF1ZW5jZXM6IDIsXG4gKiB9KTtcbiAqIGNvbnNvbGUubG9nKG91dHB1dCk7XG4gKiAvLyBbe1xuICogLy8gICBcImdlbmVyYXRlZF90ZXh0XCI6IFwiT25jZSB1cG9uIGEgdGltZSwgdGhlcmUgd2FzIGFuIGFidW5kYW5jZSBvZiBpbmZvcm1hdGlvbiBhYm91dCB0aGUgaGlzdG9yeSBhbmQgYWN0aXZpdGllcyB0aGF0XCJcbiAqIC8vIH0sIHtcbiAqIC8vICAgXCJnZW5lcmF0ZWRfdGV4dFwiOiBcIk9uY2UgdXBvbiBhIHRpbWUsIHRoZXJlIHdhcyBhbiBhYnVuZGFuY2Ugb2YgaW5mb3JtYXRpb24gYWJvdXQgdGhlIG1vc3QgaW1wb3J0YW50IGFuZCBpbmZsdWVudGlhbFwiXG4gKiAvLyB9XVxuICogYGBgXG4gKiBcbiAqICoqRXhhbXBsZToqKiBSdW4gY29kZSBnZW5lcmF0aW9uIHdpdGggYFhlbm92YS9jb2RlZ2VuLTM1ME0tbW9ub2AuXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBsZXQgdGV4dCA9ICdkZWYgZmliKG4pOic7XG4gKiBsZXQgZ2VuZXJhdG9yID0gYXdhaXQgcGlwZWxpbmUoJ3RleHQtZ2VuZXJhdGlvbicsICdYZW5vdmEvY29kZWdlbi0zNTBNLW1vbm8nKTtcbiAqIGxldCBvdXRwdXQgPSBhd2FpdCBnZW5lcmF0b3IodGV4dCwge1xuICogICAgIG1heF9uZXdfdG9rZW5zOiA0MCxcbiAqIH0pO1xuICogY29uc29sZS5sb2cob3V0cHV0WzBdLmdlbmVyYXRlZF90ZXh0KTtcbiAqIC8vIGRlZiBmaWIobik6XG4gKiAvLyAgICAgaWYgbiA9PSAwOlxuICogLy8gICAgICAgICByZXR1cm4gMFxuICogLy8gICAgIGlmIG4gPT0gMTpcbiAqIC8vICAgICAgICAgcmV0dXJuIDFcbiAqIC8vICAgICByZXR1cm4gZmliKG4tMSkgKyBmaWIobi0yKVxuICogYGBgXG4gKiBcbiAqIEBleHRlbmRzIFBpcGVsaW5lXG4gKi9cbmV4cG9ydCBjbGFzcyBUZXh0R2VuZXJhdGlvblBpcGVsaW5lIGV4dGVuZHMgUGlwZWxpbmUge1xuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyB0ZXh0IGJhc2VkIG9uIGFuIGlucHV0IHByb21wdC5cbiAgICAgKiBAcGFyYW0ge2FueX0gdGV4dHMgVGhlIGlucHV0IHByb21wdCBvciBwcm9tcHRzIHRvIGdlbmVyYXRlIHRleHQgZnJvbS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2dlbmVyYXRlX2t3YXJncz17fV0gQWRkaXRpb25hbCBhcmd1bWVudHMgZm9yIHRleHQgZ2VuZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxhbnk+fSBUaGUgZ2VuZXJhdGVkIHRleHQgb3IgdGV4dHMuXG4gICAgICovXG4gICAgYXN5bmMgX2NhbGwodGV4dHMsIGdlbmVyYXRlX2t3YXJncyA9IHt9KSB7XG4gICAgICAgIGxldCBzdHJpbmdJbnB1dCA9IHR5cGVvZiB0ZXh0cyA9PT0gJ3N0cmluZycgfHwgdGV4dHMgaW5zdGFuY2VvZiBTdHJpbmc7XG4gICAgICAgIGlmIChzdHJpbmdJbnB1dCkge1xuICAgICAgICAgICAgdGV4dHMgPSBbdGV4dHNdO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy50b2tlbml6ZXIucGFkZGluZ19zaWRlID0gJ2xlZnQnO1xuICAgICAgICBsZXQgaW5wdXRzID0gdGhpcy50b2tlbml6ZXIodGV4dHMsIHtcbiAgICAgICAgICAgIHBhZGRpbmc6IHRydWUsXG4gICAgICAgICAgICB0cnVuY2F0aW9uOiB0cnVlLFxuICAgICAgICB9KTtcblxuICAgICAgICBsZXQgaW5wdXRfaWRzID0gaW5wdXRzLmlucHV0X2lkcztcbiAgICAgICAgbGV0IGF0dGVudGlvbl9tYXNrID0gaW5wdXRzLmF0dGVudGlvbl9tYXNrO1xuXG4gICAgICAgIGxldCBvdXRwdXRUb2tlbklkcyA9IGF3YWl0IHRoaXMubW9kZWwuZ2VuZXJhdGUoaW5wdXRfaWRzLCBnZW5lcmF0ZV9rd2FyZ3MsIG51bGwsIHtcbiAgICAgICAgICAgIGlucHV0c19hdHRlbnRpb25fbWFzazogYXR0ZW50aW9uX21hc2tcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgZGVjb2RlZCA9IHRoaXMudG9rZW5pemVyLmJhdGNoX2RlY29kZShvdXRwdXRUb2tlbklkcywge1xuICAgICAgICAgICAgc2tpcF9zcGVjaWFsX3Rva2VuczogdHJ1ZSxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHRvUmV0dXJuID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogdGV4dHMubGVuZ3RoIH0sIF8gPT4gW10pO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRlY29kZWQubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IHRleHRJbmRleCA9IE1hdGguZmxvb3IoaSAvIG91dHB1dFRva2VuSWRzLmxlbmd0aCAqIHRleHRzLmxlbmd0aCk7XG5cbiAgICAgICAgICAgIHRvUmV0dXJuW3RleHRJbmRleF0ucHVzaCh7XG4gICAgICAgICAgICAgICAgZ2VuZXJhdGVkX3RleHQ6IGRlY29kZWRbaV1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoc3RyaW5nSW5wdXQgJiYgdG9SZXR1cm4ubGVuZ3RoID09PSAxKSA/IHRvUmV0dXJuWzBdIDogdG9SZXR1cm47XG4gICAgfVxufVxuXG4vKipcbiAqIE5MSS1iYXNlZCB6ZXJvLXNob3QgY2xhc3NpZmljYXRpb24gcGlwZWxpbmUgdXNpbmcgYSBgTW9kZWxGb3JTZXF1ZW5jZUNsYXNzaWZpY2F0aW9uYFxuICogdHJhaW5lZCBvbiBOTEkgKG5hdHVyYWwgbGFuZ3VhZ2UgaW5mZXJlbmNlKSB0YXNrcy4gRXF1aXZhbGVudCBvZiBgdGV4dC1jbGFzc2lmaWNhdGlvbmBcbiAqIHBpcGVsaW5lcywgYnV0IHRoZXNlIG1vZGVscyBkb24ndCByZXF1aXJlIGEgaGFyZGNvZGVkIG51bWJlciBvZiBwb3RlbnRpYWwgY2xhc3NlcywgdGhleVxuICogY2FuIGJlIGNob3NlbiBhdCBydW50aW1lLiBJdCB1c3VhbGx5IG1lYW5zIGl0J3Mgc2xvd2VyIGJ1dCBpdCBpcyAqKm11Y2gqKiBtb3JlIGZsZXhpYmxlLlxuICogQGV4dGVuZHMgUGlwZWxpbmVcbiAqL1xuZXhwb3J0IGNsYXNzIFplcm9TaG90Q2xhc3NpZmljYXRpb25QaXBlbGluZSBleHRlbmRzIFBpcGVsaW5lIHtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBaZXJvU2hvdENsYXNzaWZpY2F0aW9uUGlwZWxpbmUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRhc2sgVGhlIHRhc2sgb2YgdGhlIHBpcGVsaW5lLiBVc2VmdWwgZm9yIHNwZWNpZnlpbmcgc3VidGFza3MuXG4gICAgICogQHBhcmFtIHtQcmVUcmFpbmVkVG9rZW5pemVyfSB0b2tlbml6ZXIgVGhlIHRva2VuaXplciB0byB1c2UuXG4gICAgICogQHBhcmFtIHtQcmVUcmFpbmVkTW9kZWx9IG1vZGVsIFRoZSBtb2RlbCB0byB1c2UuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IodGFzaywgdG9rZW5pemVyLCBtb2RlbCkge1xuICAgICAgICBzdXBlcih0YXNrLCB0b2tlbml6ZXIsIG1vZGVsKTtcblxuICAgICAgICAvLyBVc2UgbW9kZWwgY29uZmlnIHRvIGdldCBsYWJlbDJpZCBtYXBwaW5nXG4gICAgICAgIHRoaXMubGFiZWwyaWQgPSBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgICAgICAgICBPYmplY3QuZW50cmllcyh0aGlzLm1vZGVsLmNvbmZpZy5sYWJlbDJpZCkubWFwKFxuICAgICAgICAgICAgICAgIChbaywgdl0pID0+IFtrLnRvTG93ZXJDYXNlKCksIHZdXG4gICAgICAgICAgICApXG4gICAgICAgICk7XG5cbiAgICAgICAgdGhpcy5lbnRhaWxtZW50X2lkID0gdGhpcy5sYWJlbDJpZFsnZW50YWlsbWVudCddO1xuICAgICAgICBpZiAodGhpcy5lbnRhaWxtZW50X2lkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIkNvdWxkIG5vdCBmaW5kICdlbnRhaWxtZW50JyBpbiBsYWJlbDJpZCBtYXBwaW5nLiBVc2luZyAyIGFzIGVudGFpbG1lbnRfaWQuXCIpO1xuICAgICAgICAgICAgdGhpcy5lbnRhaWxtZW50X2lkID0gMjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY29udHJhZGljdGlvbl9pZCA9IHRoaXMubGFiZWwyaWRbJ2NvbnRyYWRpY3Rpb24nXTtcbiAgICAgICAgaWYgKHRoaXMuY29udHJhZGljdGlvbl9pZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJDb3VsZCBub3QgZmluZCAnY29udHJhZGljdGlvbicgaW4gbGFiZWwyaWQgbWFwcGluZy4gVXNpbmcgMCBhcyBjb250cmFkaWN0aW9uX2lkLlwiKTtcbiAgICAgICAgICAgIHRoaXMuY29udHJhZGljdGlvbl9pZCA9IDA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHthbnlbXX0gdGV4dHNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBjYW5kaWRhdGVfbGFiZWxzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgQWRkaXRpb25hbCBvcHRpb25zOlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5oeXBvdGhlc2lzX3RlbXBsYXRlPVwiVGhpcyBleGFtcGxlIGlzIHt9LlwiXSBUaGUgdGVtcGxhdGUgdXNlZCB0byB0dXJuIGVhY2hcbiAgICAgKiBjYW5kaWRhdGUgbGFiZWwgaW50byBhbiBOTEktc3R5bGUgaHlwb3RoZXNpcy4gVGhlIGNhbmRpZGF0ZSBsYWJlbCB3aWxsIHJlcGxhY2UgdGhlIHt9IHBsYWNlaG9sZGVyLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMubXVsdGlfbGFiZWw9ZmFsc2VdIFdoZXRoZXIgb3Igbm90IG11bHRpcGxlIGNhbmRpZGF0ZSBsYWJlbHMgY2FuIGJlIHRydWUuXG4gICAgICogSWYgYGZhbHNlYCwgdGhlIHNjb3JlcyBhcmUgbm9ybWFsaXplZCBzdWNoIHRoYXQgdGhlIHN1bSBvZiB0aGUgbGFiZWwgbGlrZWxpaG9vZHMgZm9yIGVhY2ggc2VxdWVuY2VcbiAgICAgKiBpcyAxLiBJZiBgdHJ1ZWAsIHRoZSBsYWJlbHMgYXJlIGNvbnNpZGVyZWQgaW5kZXBlbmRlbnQgYW5kIHByb2JhYmlsaXRpZXMgYXJlIG5vcm1hbGl6ZWQgZm9yIGVhY2hcbiAgICAgKiBjYW5kaWRhdGUgYnkgZG9pbmcgYSBzb2Z0bWF4IG9mIHRoZSBlbnRhaWxtZW50IHNjb3JlIHZzLiB0aGUgY29udHJhZGljdGlvbiBzY29yZS5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlPE9iamVjdHxPYmplY3RbXT59IFRoZSBwcmVkaWN0aW9uKHMpLCBhcyBhIG1hcCAob3IgbGlzdCBvZiBtYXBzKSBmcm9tIGxhYmVsIHRvIHNjb3JlLlxuICAgICAqL1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBhc3luYyBfY2FsbCh0ZXh0cywgY2FuZGlkYXRlX2xhYmVscywge1xuICAgICAgICBoeXBvdGhlc2lzX3RlbXBsYXRlID0gXCJUaGlzIGV4YW1wbGUgaXMge30uXCIsXG4gICAgICAgIG11bHRpX2xhYmVsID0gZmFsc2UsXG4gICAgfSA9IHt9KSB7XG5cbiAgICAgICAgbGV0IGlzQmF0Y2hlZCA9IEFycmF5LmlzQXJyYXkodGV4dHMpO1xuXG4gICAgICAgIGlmICghaXNCYXRjaGVkKSB7XG4gICAgICAgICAgICB0ZXh0cyA9IFt0ZXh0c107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGNhbmRpZGF0ZV9sYWJlbHMpKSB7XG4gICAgICAgICAgICBjYW5kaWRhdGVfbGFiZWxzID0gW2NhbmRpZGF0ZV9sYWJlbHNdO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSW5zZXJ0IGxhYmVscyBpbnRvIGh5cG90aGVzaXMgdGVtcGxhdGVcbiAgICAgICAgbGV0IGh5cG90aGVzZXMgPSBjYW5kaWRhdGVfbGFiZWxzLm1hcChcbiAgICAgICAgICAgIHggPT4gaHlwb3RoZXNpc190ZW1wbGF0ZS5yZXBsYWNlKCd7fScsIHgpXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gSG93IHRvIHBlcmZvcm0gdGhlIHNvZnRtYXggb3ZlciB0aGUgbG9naXRzOlxuICAgICAgICAvLyAgLSB0cnVlOiAgc29mdG1heCBvdmVyIHRoZSBlbnRhaWxtZW50IHZzLiBjb250cmFkaWN0aW9uIGRpbSBmb3IgZWFjaCBsYWJlbCBpbmRlcGVuZGVudGx5XG4gICAgICAgIC8vICAtIGZhbHNlOiBzb2Z0bWF4IHRoZSBcImVudGFpbG1lbnRcIiBsb2dpdHMgb3ZlciBhbGwgY2FuZGlkYXRlIGxhYmVsc1xuICAgICAgICBsZXQgc29mdG1heEVhY2ggPSBtdWx0aV9sYWJlbCB8fCBjYW5kaWRhdGVfbGFiZWxzLmxlbmd0aCA9PT0gMTtcblxuICAgICAgICBsZXQgdG9SZXR1cm4gPSBbXTtcbiAgICAgICAgZm9yIChsZXQgcHJlbWlzZSBvZiB0ZXh0cykge1xuICAgICAgICAgICAgbGV0IGVudGFpbHNfbG9naXRzID0gW107XG5cbiAgICAgICAgICAgIGZvciAobGV0IGh5cG90aGVzaXMgb2YgaHlwb3RoZXNlcykge1xuICAgICAgICAgICAgICAgIGxldCBpbnB1dHMgPSB0aGlzLnRva2VuaXplcihwcmVtaXNlLCB7XG4gICAgICAgICAgICAgICAgICAgIHRleHRfcGFpcjogaHlwb3RoZXNpcyxcbiAgICAgICAgICAgICAgICAgICAgcGFkZGluZzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgdHJ1bmNhdGlvbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIGxldCBvdXRwdXRzID0gYXdhaXQgdGhpcy5tb2RlbChpbnB1dHMpXG5cbiAgICAgICAgICAgICAgICBpZiAoc29mdG1heEVhY2gpIHtcbiAgICAgICAgICAgICAgICAgICAgZW50YWlsc19sb2dpdHMucHVzaChbXG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXRzLmxvZ2l0cy5kYXRhW3RoaXMuY29udHJhZGljdGlvbl9pZF0sXG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXRzLmxvZ2l0cy5kYXRhW3RoaXMuZW50YWlsbWVudF9pZF1cbiAgICAgICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBlbnRhaWxzX2xvZ2l0cy5wdXNoKG91dHB1dHMubG9naXRzLmRhdGFbdGhpcy5lbnRhaWxtZW50X2lkXSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxldCBzY29yZXM7XG4gICAgICAgICAgICBpZiAoc29mdG1heEVhY2gpIHtcbiAgICAgICAgICAgICAgICBzY29yZXMgPSBlbnRhaWxzX2xvZ2l0cy5tYXAoeCA9PiBzb2Z0bWF4KHgpWzFdKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc2NvcmVzID0gc29mdG1heChlbnRhaWxzX2xvZ2l0cyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFNvcnQgYnkgc2NvcmVzIChkZXNjKSBhbmQgcmV0dXJuIHNjb3JlcyB3aXRoIGluZGljZXNcbiAgICAgICAgICAgIGxldCBzY29yZXNfc29ydGVkID0gc2NvcmVzXG4gICAgICAgICAgICAgICAgLm1hcCgoeCwgaSkgPT4gW3gsIGldKVxuICAgICAgICAgICAgICAgIC5zb3J0KChhLCBiKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBiWzBdIC0gYVswXTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdG9SZXR1cm4ucHVzaCh7XG4gICAgICAgICAgICAgICAgc2VxdWVuY2U6IHByZW1pc2UsXG4gICAgICAgICAgICAgICAgbGFiZWxzOiBzY29yZXNfc29ydGVkLm1hcCh4ID0+IGNhbmRpZGF0ZV9sYWJlbHNbeFsxXV0pLFxuICAgICAgICAgICAgICAgIHNjb3Jlczogc2NvcmVzX3NvcnRlZC5tYXAoeCA9PiB4WzBdKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpc0JhdGNoZWQgPyB0b1JldHVybiA6IHRvUmV0dXJuWzBdO1xuICAgIH1cbn1cblxuXG4vKipcbiAqIEZlYXR1cmUgZXh0cmFjdGlvbiBwaXBlbGluZSB1c2luZyBubyBtb2RlbCBoZWFkLiBUaGlzIHBpcGVsaW5lIGV4dHJhY3RzIHRoZSBoaWRkZW5cbiAqIHN0YXRlcyBmcm9tIHRoZSBiYXNlIHRyYW5zZm9ybWVyLCB3aGljaCBjYW4gYmUgdXNlZCBhcyBmZWF0dXJlcyBpbiBkb3duc3RyZWFtIHRhc2tzLlxuICogXG4gKiAqKkV4YW1wbGU6KiogUnVuIGZlYXR1cmUgZXh0cmFjdGlvbiB3aXRoIGBiZXJ0LWJhc2UtdW5jYXNlZGAgKHdpdGhvdXQgcG9vbGluZy9ub3JtYWxpemF0aW9uKS5cbiAqIGBgYGphdmFzY3JpcHRcbiAqIGxldCBleHRyYWN0b3IgPSBhd2FpdCBwaXBlbGluZSgnZmVhdHVyZS1leHRyYWN0aW9uJywgJ1hlbm92YS9iZXJ0LWJhc2UtdW5jYXNlZCcsIHsgcmV2aXNpb246ICdkZWZhdWx0JyB9KTtcbiAqIGxldCByZXN1bHQgPSBhd2FpdCBleHRyYWN0b3IoJ1RoaXMgaXMgYSBzaW1wbGUgdGVzdC4nKTtcbiAqIGNvbnNvbGUubG9nKHJlc3VsdCk7XG4gKiAvLyBUZW5zb3Ige1xuICogLy8gICAgIHR5cGU6ICdmbG9hdDMyJyxcbiAqIC8vICAgICBkYXRhOiBGbG9hdDMyQXJyYXkgWzAuMDU5Mzk5MjQ3MTY5NDk0NjMsIDAuMDIxNjU1OTM1Nzk0MTE1MDY3LCAuLi5dLFxuICogLy8gICAgIGRpbXM6IFsxLCA4LCA3NjhdXG4gKiAvLyB9XG4gKiBgYGBcbiAqIFxuICogKipFeGFtcGxlOioqIFJ1biBmZWF0dXJlIGV4dHJhY3Rpb24gd2l0aCBgYmVydC1iYXNlLXVuY2FzZWRgICh3aXRoIHBvb2xpbmcvbm9ybWFsaXphdGlvbikuXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBsZXQgZXh0cmFjdG9yID0gYXdhaXQgcGlwZWxpbmUoJ2ZlYXR1cmUtZXh0cmFjdGlvbicsICdYZW5vdmEvYmVydC1iYXNlLXVuY2FzZWQnLCB7IHJldmlzaW9uOiAnZGVmYXVsdCcgfSk7XG4gKiBsZXQgcmVzdWx0ID0gYXdhaXQgZXh0cmFjdG9yKCdUaGlzIGlzIGEgc2ltcGxlIHRlc3QuJywgeyBwb29saW5nOiAnbWVhbicsIG5vcm1hbGl6ZTogdHJ1ZSB9KTtcbiAqIGNvbnNvbGUubG9nKHJlc3VsdCk7XG4gKiAvLyBUZW5zb3Ige1xuICogLy8gICAgIHR5cGU6ICdmbG9hdDMyJyxcbiAqIC8vICAgICBkYXRhOiBGbG9hdDMyQXJyYXkgWzAuMDMzNzM3Nzg5ODM5NTA2MTUsIC0wLjAxMDEwNjA3NzQxNzczMTI4NSwgLi4uXSxcbiAqIC8vICAgICBkaW1zOiBbMSwgNzY4XVxuICogLy8gfVxuICogYGBgXG4gKiBcbiAqICoqRXhhbXBsZToqKiBDYWxjdWxhdGluZyBlbWJlZGRpbmdzIHdpdGggYHNlbnRlbmNlLXRyYW5zZm9ybWVyc2AgbW9kZWxzLlxuICogYGBgamF2YXNjcmlwdFxuICogbGV0IGV4dHJhY3RvciA9IGF3YWl0IHBpcGVsaW5lKCdmZWF0dXJlLWV4dHJhY3Rpb24nLCAnWGVub3ZhL2FsbC1NaW5pTE0tTDYtdjInKTtcbiAqIGxldCByZXN1bHQgPSBhd2FpdCBleHRyYWN0b3IoJ1RoaXMgaXMgYSBzaW1wbGUgdGVzdC4nLCB7IHBvb2xpbmc6ICdtZWFuJywgbm9ybWFsaXplOiB0cnVlIH0pO1xuICogY29uc29sZS5sb2cocmVzdWx0KTtcbiAqIC8vIFRlbnNvciB7XG4gKiAvLyAgICAgdHlwZTogJ2Zsb2F0MzInLFxuICogLy8gICAgIGRhdGE6IEZsb2F0MzJBcnJheSBbMC4wOTA5NDk4MjU5NDI1MTYzMywgLTAuMDE0Nzc0MjQ2MTQxMzE0NTA3LCAuLi5dLFxuICogLy8gICAgIGRpbXM6IFsxLCAzODRdXG4gKiAvLyB9XG4gKiBgYGBcbiAqIEBleHRlbmRzIFBpcGVsaW5lXG4gKi9cbmV4cG9ydCBjbGFzcyBGZWF0dXJlRXh0cmFjdGlvblBpcGVsaW5lIGV4dGVuZHMgUGlwZWxpbmUge1xuXG4gICAgLyoqXG4gICAgICogRXh0cmFjdCB0aGUgZmVhdHVyZXMgb2YgdGhlIGlucHV0KHMpLlxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfHN0cmluZ1tdfSB0ZXh0cyBUaGUgaW5wdXQgdGV4dHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBBZGRpdGlvbmFsIG9wdGlvbnM6XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnBvb2xpbmc9XCJub25lXCJdIFRoZSBwb29saW5nIG1ldGhvZCB0byB1c2UuIENhbiBiZSBvbmUgb2Y6IFwibm9uZVwiLCBcIm1lYW5cIi5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLm5vcm1hbGl6ZT1mYWxzZV0gV2hldGhlciBvciBub3QgdG8gbm9ybWFsaXplIHRoZSBlbWJlZGRpbmdzIGluIHRoZSBsYXN0IGRpbWVuc2lvbi5cbiAgICAgKiBAcmV0dXJucyBUaGUgZmVhdHVyZXMgY29tcHV0ZWQgYnkgdGhlIG1vZGVsLlxuICAgICAqL1xuICAgIGFzeW5jIF9jYWxsKHRleHRzLCB7XG4gICAgICAgIHBvb2xpbmcgPSAnbm9uZScsXG4gICAgICAgIG5vcm1hbGl6ZSA9IGZhbHNlLFxuICAgIH0gPSB7fSkge1xuICAgICAgICBsZXQgW2lucHV0cywgb3V0cHV0c10gPSBhd2FpdCBzdXBlci5fY2FsbCh0ZXh0cyk7XG5cbiAgICAgICAgLy8gVE9ETzogUHJvdmlkZSB3YXJuaW5nIHRvIHRoZSB1c2VyIHRoYXQgdGhleSBtaWdodCBiZSB1c2luZyBtb2RlbCB3aGljaCB3YXMgbm90IGV4cG9ydGVkXG4gICAgICAgIC8vIHNwZWNpZmljYWxseSBmb3IgZmVhdHVyZSBleHRyYWN0aW9uXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKHRoaXMubW9kZWwuY29uZmlnKVxuICAgICAgICAvLyBjb25zb2xlLmxvZyhvdXRwdXRzKVxuXG4gICAgICAgIGxldCByZXN1bHQgPSBvdXRwdXRzLmxhc3RfaGlkZGVuX3N0YXRlID8/IG91dHB1dHMubG9naXRzO1xuICAgICAgICBpZiAocG9vbGluZyA9PT0gJ25vbmUnKSB7XG4gICAgICAgICAgICAvLyBTa2lwIHBvb2xpbmdcbiAgICAgICAgfSBlbHNlIGlmIChwb29saW5nID09PSAnbWVhbicpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IG1lYW5fcG9vbGluZyhyZXN1bHQsIGlucHV0cy5hdHRlbnRpb25fbWFzayk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihgUG9vbGluZyBtZXRob2QgJyR7cG9vbGluZ30nIG5vdCBzdXBwb3J0ZWQuYCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobm9ybWFsaXplKSB7XG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHQubm9ybWFsaXplKDIsIC0xKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuXG4vLyBUT0RPXG4vLyBleHBvcnQgY2xhc3MgU2VudGVuY2VTaW1pbGFyaXR5UGlwZWxpbmUgZXh0ZW5kcyBQaXBlbGluZSB7XG4vLyB9XG5cblxuLyoqXG4gKiBQaXBlbGluZSB0aGF0IGFpbXMgYXQgZXh0cmFjdGluZyBzcG9rZW4gdGV4dCBjb250YWluZWQgd2l0aGluIHNvbWUgYXVkaW8uXG4gKlxuICogKipFeGFtcGxlOioqIFRyYW5zY3JpYmUgRW5nbGlzaC5cbiAqIGBgYGphdmFzY3JpcHRcbiAqIGxldCB1cmwgPSAnaHR0cHM6Ly9odWdnaW5nZmFjZS5jby9kYXRhc2V0cy9YZW5vdmEvdHJhbnNmb3JtZXJzLmpzLWRvY3MvcmVzb2x2ZS9tYWluL2pmay53YXYnO1xuICogbGV0IHRyYW5zY3JpYmVyID0gYXdhaXQgcGlwZWxpbmUoJ2F1dG9tYXRpYy1zcGVlY2gtcmVjb2duaXRpb24nLCAnWGVub3ZhL3doaXNwZXItdGlueS5lbicpO1xuICogbGV0IG91dHB1dCA9IGF3YWl0IHRyYW5zY3JpYmVyKHVybCk7XG4gKiAvLyB7IHRleHQ6IFwiIEFuZCBzbyBteSBmZWxsb3cgQW1lcmljYW5zIGFzayBub3Qgd2hhdCB5b3VyIGNvdW50cnkgY2FuIGRvIGZvciB5b3UsIGFzayB3aGF0IHlvdSBjYW4gZG8gZm9yIHlvdXIgY291bnRyeS5cIiB9XG4gKiBgYGBcbiAqIFxuICogKipFeGFtcGxlOioqIFRyYW5zY3JpYmUgRW5nbGlzaCB3LyB0aW1lc3RhbXBzLlxuICogYGBgamF2YXNjcmlwdFxuICogbGV0IHVybCA9ICdodHRwczovL2h1Z2dpbmdmYWNlLmNvL2RhdGFzZXRzL1hlbm92YS90cmFuc2Zvcm1lcnMuanMtZG9jcy9yZXNvbHZlL21haW4vamZrLndhdic7XG4gKiBsZXQgdHJhbnNjcmliZXIgPSBhd2FpdCBwaXBlbGluZSgnYXV0b21hdGljLXNwZWVjaC1yZWNvZ25pdGlvbicsICdYZW5vdmEvd2hpc3Blci10aW55LmVuJyk7XG4gKiBsZXQgb3V0cHV0ID0gYXdhaXQgdHJhbnNjcmliZXIodXJsLCB7IHJldHVybl90aW1lc3RhbXBzOiB0cnVlIH0pO1xuICogLy8ge1xuICogLy8gICB0ZXh0OiBcIiBBbmQgc28gbXkgZmVsbG93IEFtZXJpY2FucyBhc2sgbm90IHdoYXQgeW91ciBjb3VudHJ5IGNhbiBkbyBmb3IgeW91LCBhc2sgd2hhdCB5b3UgY2FuIGRvIGZvciB5b3VyIGNvdW50cnkuXCJcbiAqIC8vICAgY2h1bmtzOiBbXG4gKiAvLyAgICAgeyB0aW1lc3RhbXA6IFswLCA4XSwgIHRleHQ6IFwiIEFuZCBzbyBteSBmZWxsb3cgQW1lcmljYW5zIGFzayBub3Qgd2hhdCB5b3VyIGNvdW50cnkgY2FuIGRvIGZvciB5b3VcIiB9XG4gKiAvLyAgICAgeyB0aW1lc3RhbXA6IFs4LCAxMV0sIHRleHQ6IFwiIGFzayB3aGF0IHlvdSBjYW4gZG8gZm9yIHlvdXIgY291bnRyeS5cIiB9XG4gKiAvLyAgIF1cbiAqIC8vIH1cbiAqIGBgYFxuICogXG4gKiAqKkV4YW1wbGU6KiogVHJhbnNjcmliZSBFbmdsaXNoIHcvIHdvcmQtbGV2ZWwgdGltZXN0YW1wcy5cbiAqIGBgYGphdmFzY3JpcHRcbiAqIGxldCB1cmwgPSAnaHR0cHM6Ly9odWdnaW5nZmFjZS5jby9kYXRhc2V0cy9YZW5vdmEvdHJhbnNmb3JtZXJzLmpzLWRvY3MvcmVzb2x2ZS9tYWluL2pmay53YXYnO1xuICogbGV0IHRyYW5zY3JpYmVyID0gYXdhaXQgcGlwZWxpbmUoJ2F1dG9tYXRpYy1zcGVlY2gtcmVjb2duaXRpb24nLCAnWGVub3ZhL3doaXNwZXItdGlueS5lbicsIHtcbiAqICAgICByZXZpc2lvbjogJ291dHB1dF9hdHRlbnRpb25zJyxcbiAqIH0pO1xuICogbGV0IG91dHB1dCA9IGF3YWl0IHRyYW5zY3JpYmVyKHVybCwgeyByZXR1cm5fdGltZXN0YW1wczogJ3dvcmQnIH0pO1xuICogLy8ge1xuICogLy8gICBcInRleHRcIjogXCIgQW5kIHNvIG15IGZlbGxvdyBBbWVyaWNhbnMgYXNrIG5vdCB3aGF0IHlvdXIgY291bnRyeSBjYW4gZG8gZm9yIHlvdSBhc2sgd2hhdCB5b3UgY2FuIGRvIGZvciB5b3VyIGNvdW50cnkuXCIsXG4gKiAvLyAgIFwiY2h1bmtzXCI6IFtcbiAqIC8vICAgICB7IFwidGV4dFwiOiBcIiBBbmRcIiwgXCJ0aW1lc3RhbXBcIjogWzAsIDAuNzhdIH0sXG4gKiAvLyAgICAgeyBcInRleHRcIjogXCIgc29cIiwgXCJ0aW1lc3RhbXBcIjogWzAuNzgsIDEuMDZdIH0sXG4gKiAvLyAgICAgeyBcInRleHRcIjogXCIgbXlcIiwgXCJ0aW1lc3RhbXBcIjogWzEuMDYsIDEuNDZdIH0sXG4gKiAvLyAgICAgLi4uXG4gKiAvLyAgICAgeyBcInRleHRcIjogXCIgZm9yXCIsIFwidGltZXN0YW1wXCI6IFs5LjcyLCA5LjkyXSB9LFxuICogLy8gICAgIHsgXCJ0ZXh0XCI6IFwiIHlvdXJcIiwgXCJ0aW1lc3RhbXBcIjogWzkuOTIsIDEwLjIyXSB9LFxuICogLy8gICAgIHsgXCJ0ZXh0XCI6IFwiIGNvdW50cnkuXCIsIFwidGltZXN0YW1wXCI6IFsxMC4yMiwgMTMuNV0gfVxuICogLy8gICBdXG4gKiAvLyB9XG4gKiBgYGBcbiAqIFxuICogKipFeGFtcGxlOioqIFRyYW5zY3JpYmUgRnJlbmNoLlxuICogYGBgamF2YXNjcmlwdFxuICogbGV0IHVybCA9ICdodHRwczovL2h1Z2dpbmdmYWNlLmNvL2RhdGFzZXRzL1hlbm92YS90cmFuc2Zvcm1lcnMuanMtZG9jcy9yZXNvbHZlL21haW4vZnJlbmNoLWF1ZGlvLm1wMyc7XG4gKiBsZXQgdHJhbnNjcmliZXIgPSBhd2FpdCBwaXBlbGluZSgnYXV0b21hdGljLXNwZWVjaC1yZWNvZ25pdGlvbicsICdYZW5vdmEvd2hpc3Blci1zbWFsbCcpO1xuICogbGV0IG91dHB1dCA9IGF3YWl0IHRyYW5zY3JpYmVyKHVybCwgeyBsYW5ndWFnZTogJ2ZyZW5jaCcsIHRhc2s6ICd0cmFuc2NyaWJlJyB9KTtcbiAqIC8vIHsgdGV4dDogXCIgSidhZG9yZSwgaidhaW1lLCBqZSBuJ2FpbWUgcGFzLCBqZSBkw6l0ZXN0ZS5cIiB9XG4gKiBgYGBcbiAqIFxuICogKipFeGFtcGxlOioqIFRyYW5zbGF0ZSBGcmVuY2ggdG8gRW5nbGlzaC5cbiAqIGBgYGphdmFzY3JpcHRcbiAqIGxldCB1cmwgPSAnaHR0cHM6Ly9odWdnaW5nZmFjZS5jby9kYXRhc2V0cy9YZW5vdmEvdHJhbnNmb3JtZXJzLmpzLWRvY3MvcmVzb2x2ZS9tYWluL2ZyZW5jaC1hdWRpby5tcDMnO1xuICogbGV0IHRyYW5zY3JpYmVyID0gYXdhaXQgcGlwZWxpbmUoJ2F1dG9tYXRpYy1zcGVlY2gtcmVjb2duaXRpb24nLCAnWGVub3ZhL3doaXNwZXItc21hbGwnKTtcbiAqIGxldCBvdXRwdXQgPSBhd2FpdCB0cmFuc2NyaWJlcih1cmwsIHsgbGFuZ3VhZ2U6ICdmcmVuY2gnLCB0YXNrOiAndHJhbnNsYXRlJyB9KTtcbiAqIC8vIHsgdGV4dDogXCIgSSBsb3ZlLCBJIGxpa2UsIEkgZG9uJ3QgbGlrZSwgSSBoYXRlLlwiIH1cbiAqIGBgYFxuICogXG4gKiAqKkV4YW1wbGU6KiogVHJhbnNjcmliZS90cmFuc2xhdGUgYXVkaW8gbG9uZ2VyIHRoYW4gMzAgc2Vjb25kcy5cbiAqIGBgYGphdmFzY3JpcHRcbiAqIGxldCB1cmwgPSAnaHR0cHM6Ly9odWdnaW5nZmFjZS5jby9kYXRhc2V0cy9YZW5vdmEvdHJhbnNmb3JtZXJzLmpzLWRvY3MvcmVzb2x2ZS9tYWluL3RlZF82MC53YXYnO1xuICogbGV0IHRyYW5zY3JpYmVyID0gYXdhaXQgcGlwZWxpbmUoJ2F1dG9tYXRpYy1zcGVlY2gtcmVjb2duaXRpb24nLCAnWGVub3ZhL3doaXNwZXItdGlueS5lbicpO1xuICogbGV0IG91dHB1dCA9IGF3YWl0IHRyYW5zY3JpYmVyKHVybCwgeyBjaHVua19sZW5ndGhfczogMzAsIHN0cmlkZV9sZW5ndGhfczogNSB9KTtcbiAqIC8vIHsgdGV4dDogXCIgU28gaW4gY29sbGVnZSwgSSB3YXMgYSBnb3Zlcm5tZW50IG1ham9yLCB3aGljaCBtZWFucyBbLi4uXSBTbyBJJ2Qgc3RhcnQgb2ZmIGxpZ2h0IGFuZCBJJ2QgYnVtcCBpdCB1cFwiIH1cbiAqIGBgYFxuICogQGV4dGVuZHMgUGlwZWxpbmVcbiAqL1xuZXhwb3J0IGNsYXNzIEF1dG9tYXRpY1NwZWVjaFJlY29nbml0aW9uUGlwZWxpbmUgZXh0ZW5kcyBQaXBlbGluZSB7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgQXV0b21hdGljU3BlZWNoUmVjb2duaXRpb25QaXBlbGluZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGFzayBUaGUgdGFzayBvZiB0aGUgcGlwZWxpbmUuIFVzZWZ1bCBmb3Igc3BlY2lmeWluZyBzdWJ0YXNrcy5cbiAgICAgKiBAcGFyYW0ge1ByZVRyYWluZWRUb2tlbml6ZXJ9IHRva2VuaXplciBUaGUgdG9rZW5pemVyIHRvIHVzZS5cbiAgICAgKiBAcGFyYW0ge1ByZVRyYWluZWRNb2RlbH0gbW9kZWwgVGhlIG1vZGVsIHRvIHVzZS5cbiAgICAgKiBAcGFyYW0ge1Byb2Nlc3Nvcn0gcHJvY2Vzc29yIFRoZSBwcm9jZXNzb3IgdG8gdXNlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHRhc2ssIHRva2VuaXplciwgbW9kZWwsIHByb2Nlc3Nvcikge1xuICAgICAgICBzdXBlcih0YXNrLCB0b2tlbml6ZXIsIG1vZGVsKTtcbiAgICAgICAgdGhpcy5wcm9jZXNzb3IgPSBwcm9jZXNzb3I7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHJlcHJvY2Vzc2VzIHRoZSBpbnB1dCBhdWRpbyBmb3IgdGhlIEF1dG9tYXRpY1NwZWVjaFJlY29nbml0aW9uUGlwZWxpbmUuXG4gICAgICogQHBhcmFtIHthbnl9IGF1ZGlvIFRoZSBhdWRpbyB0byBiZSBwcmVwcm9jZXNzZWQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNhbXBsaW5nX3JhdGUgVGhlIHNhbXBsaW5nIHJhdGUgb2YgdGhlIGF1ZGlvLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEZsb2F0MzJBcnJheT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSBwcmVwcm9jZXNzZWQgYXVkaW8gZGF0YS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGFzeW5jIF9wcmVwcm9jZXNzKGF1ZGlvLCBzYW1wbGluZ19yYXRlKSB7XG4gICAgICAgIGlmIChpc1N0cmluZyhhdWRpbykpIHtcbiAgICAgICAgICAgIGF1ZGlvID0gYXdhaXQgcmVhZF9hdWRpbyhhdWRpbywgc2FtcGxpbmdfcmF0ZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXVkaW87XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHR5cGVkZWYge2ltcG9ydCgnLi91dGlscy90ZW5zb3IuanMnKS5UZW5zb3J9IFRlbnNvclxuICAgICAqIEB0eXBlZGVmIHt7c3RyaWRlOiBudW1iZXJbXSwgaW5wdXRfZmVhdHVyZXM6IFRlbnNvciwgaXNfbGFzdDogYm9vbGVhbiwgdG9rZW5zPzogbnVtYmVyW10sIHRva2VuX3RpbWVzdGFtcHM/OiBudW1iZXJbXX19IENodW5rXG4gICAgICogXG4gICAgICogQGNhbGxiYWNrIENodW5rQ2FsbGJhY2tcbiAgICAgKiBAcGFyYW0ge0NodW5rfSBjaHVuayBUaGUgY2h1bmsgdG8gcHJvY2Vzcy5cbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEFzeW5jaHJvbm91c2x5IHByb2Nlc3NlcyBhdWRpbyBhbmQgZ2VuZXJhdGVzIHRleHQgdHJhbnNjcmlwdGlvbiB1c2luZyB0aGUgbW9kZWwuXG4gICAgICogQHBhcmFtIHtGbG9hdDMyQXJyYXl8RmxvYXQzMkFycmF5W119IGF1ZGlvIFRoZSBhdWRpbyB0byBiZSB0cmFuc2NyaWJlZC4gQ2FuIGJlIGEgc2luZ2xlIEZsb2F0MzJBcnJheSBvciBhbiBhcnJheSBvZiBGbG9hdDMyQXJyYXlzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBba3dhcmdzPXt9XSBPcHRpb25hbCBhcmd1bWVudHMuXG4gICAgICogQHBhcmFtIHtib29sZWFufCd3b3JkJ30gW2t3YXJncy5yZXR1cm5fdGltZXN0YW1wc10gV2hldGhlciB0byByZXR1cm4gdGltZXN0YW1wcyBvciBub3QuIERlZmF1bHQgaXMgYGZhbHNlYC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2t3YXJncy5jaHVua19sZW5ndGhfc10gVGhlIGxlbmd0aCBvZiBhdWRpbyBjaHVua3MgdG8gcHJvY2VzcyBpbiBzZWNvbmRzLiBEZWZhdWx0IGlzIDAgKG5vIGNodW5raW5nKS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2t3YXJncy5zdHJpZGVfbGVuZ3RoX3NdIFRoZSBsZW5ndGggb2Ygb3ZlcmxhcCBiZXR3ZWVuIGNvbnNlY3V0aXZlIGF1ZGlvIGNodW5rcyBpbiBzZWNvbmRzLiBJZiBub3QgcHJvdmlkZWQsIGRlZmF1bHRzIHRvIGBjaHVua19sZW5ndGhfcyAvIDZgLlxuICAgICAqIEBwYXJhbSB7Q2h1bmtDYWxsYmFja30gW2t3YXJncy5jaHVua19jYWxsYmFja10gQ2FsbGJhY2sgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIHdpdGggZWFjaCBjaHVuayBwcm9jZXNzZWQuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBba3dhcmdzLmZvcmNlX2Z1bGxfc2VxdWVuY2VzXSBXaGV0aGVyIHRvIGZvcmNlIG91dHB1dHRpbmcgZnVsbCBzZXF1ZW5jZXMgb3Igbm90LiBEZWZhdWx0IGlzIGBmYWxzZWAuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtrd2FyZ3MubGFuZ3VhZ2VdIFRoZSBzb3VyY2UgbGFuZ3VhZ2UuIERlZmF1bHQgaXMgYG51bGxgLCBtZWFuaW5nIGl0IHNob3VsZCBiZSBhdXRvLWRldGVjdGVkLiBVc2UgdGhpcyB0byBwb3RlbnRpYWxseSBpbXByb3ZlIHBlcmZvcm1hbmNlIGlmIHRoZSBzb3VyY2UgbGFuZ3VhZ2UgaXMga25vd24uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtrd2FyZ3MudGFza10gVGhlIHRhc2sgdG8gcGVyZm9ybS4gRGVmYXVsdCBpcyBgbnVsbGAsIG1lYW5pbmcgaXQgc2hvdWxkIGJlIGF1dG8tZGV0ZWN0ZWQuXG4gICAgICogQHBhcmFtIHtudW1iZXJbXVtdfSBba3dhcmdzLmZvcmNlZF9kZWNvZGVyX2lkc10gQSBsaXN0IG9mIHBhaXJzIG9mIGludGVnZXJzIHdoaWNoIGluZGljYXRlcyBhIG1hcHBpbmcgZnJvbSBnZW5lcmF0aW9uIGluZGljZXMgdG8gdG9rZW4gaW5kaWNlc1xuICAgICAqIHRoYXQgd2lsbCBiZSBmb3JjZWQgYmVmb3JlIHNhbXBsaW5nLiBGb3IgZXhhbXBsZSwgW1sxLCAxMjNdXSBtZWFucyB0aGUgc2Vjb25kIGdlbmVyYXRlZCB0b2tlbiB3aWxsIGFsd2F5cyBiZSBhIHRva2VuIG9mIGluZGV4IDEyMy5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fSBBIFByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhbiBvYmplY3QgY29udGFpbmluZyB0aGUgdHJhbnNjcmlwdGlvbiB0ZXh0IGFuZCBvcHRpb25hbGx5IHRpbWVzdGFtcHMgaWYgYHJldHVybl90aW1lc3RhbXBzYCBpcyBgdHJ1ZWAuXG4gICAgICovXG4gICAgYXN5bmMgX2NhbGwoYXVkaW8sIGt3YXJncyA9IHt9KSB7XG4gICAgICAgIGxldCByZXR1cm5fdGltZXN0YW1wcyA9IGt3YXJncy5yZXR1cm5fdGltZXN0YW1wcyA/PyBmYWxzZTtcbiAgICAgICAgbGV0IGNodW5rX2xlbmd0aF9zID0ga3dhcmdzLmNodW5rX2xlbmd0aF9zID8/IDA7XG4gICAgICAgIGxldCBzdHJpZGVfbGVuZ3RoX3MgPSBrd2FyZ3Muc3RyaWRlX2xlbmd0aF9zID8/IG51bGw7XG4gICAgICAgIGxldCBjaHVua19jYWxsYmFjayA9IGt3YXJncy5jaHVua19jYWxsYmFjayA/PyBudWxsO1xuICAgICAgICBsZXQgZm9yY2VfZnVsbF9zZXF1ZW5jZXMgPSBrd2FyZ3MuZm9yY2VfZnVsbF9zZXF1ZW5jZXMgPz8gZmFsc2U7XG5cbiAgICAgICAgaWYgKHJldHVybl90aW1lc3RhbXBzID09PSAnd29yZCcpIHtcbiAgICAgICAgICAgIGt3YXJnc1sncmV0dXJuX3Rva2VuX3RpbWVzdGFtcHMnXSA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgbGFuZ3VhZ2UgPSBwb3Aoa3dhcmdzLCAnbGFuZ3VhZ2UnLCBudWxsKTtcbiAgICAgICAgbGV0IHRhc2sgPSBwb3Aoa3dhcmdzLCAndGFzaycsIG51bGwpO1xuXG4gICAgICAgIGlmIChsYW5ndWFnZSB8fCB0YXNrIHx8IHJldHVybl90aW1lc3RhbXBzKSB7XG4gICAgICAgICAgICBpZiAoa3dhcmdzLmZvcmNlZF9kZWNvZGVyX2lkcykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBzcGVjaWZ5IGBsYW5ndWFnZWAvYHRhc2tgL2ByZXR1cm5fdGltZXN0YW1wc2AgYW5kIGBmb3JjZWRfZGVjb2Rlcl9pZHNgIGF0IHRoZSBzYW1lIHRpbWUuXCIpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBsZXQgZGVjb2Rlcl9wcm9tcHRfaWRzID0gdGhpcy50b2tlbml6ZXIuZ2V0X2RlY29kZXJfcHJvbXB0X2lkcyh7IGxhbmd1YWdlLCB0YXNrLCBub190aW1lc3RhbXBzOiAhcmV0dXJuX3RpbWVzdGFtcHMgfSlcbiAgICAgICAgICAgIGlmIChkZWNvZGVyX3Byb21wdF9pZHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGt3YXJncy5mb3JjZWRfZGVjb2Rlcl9pZHMgPSBkZWNvZGVyX3Byb21wdF9pZHM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgc2luZ2xlID0gIUFycmF5LmlzQXJyYXkoYXVkaW8pO1xuICAgICAgICBpZiAoc2luZ2xlKSB7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBhdWRpbyA9IFthdWRpb107XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBzYW1wbGluZ19yYXRlID0gdGhpcy5wcm9jZXNzb3IuZmVhdHVyZV9leHRyYWN0b3IuY29uZmlnLnNhbXBsaW5nX3JhdGU7XG4gICAgICAgIGNvbnN0IHRpbWVfcHJlY2lzaW9uID0gdGhpcy5wcm9jZXNzb3IuZmVhdHVyZV9leHRyYWN0b3IuY29uZmlnLmNodW5rX2xlbmd0aCAvIHRoaXMubW9kZWwuY29uZmlnLm1heF9zb3VyY2VfcG9zaXRpb25zO1xuXG4gICAgICAgIGxldCB0b1JldHVybiA9IFtdO1xuICAgICAgICBmb3IgKGxldCBhdWQgb2YgYXVkaW8pIHtcbiAgICAgICAgICAgIGF1ZCA9IGF3YWl0IHRoaXMuX3ByZXByb2Nlc3MoYXVkLCBzYW1wbGluZ19yYXRlKVxuXG4gICAgICAgICAgICAvKiogQHR5cGUge0NodW5rW119ICovXG4gICAgICAgICAgICBsZXQgY2h1bmtzID0gW107XG4gICAgICAgICAgICBpZiAoY2h1bmtfbGVuZ3RoX3MgPiAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0cmlkZV9sZW5ndGhfcyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBzdHJpZGVfbGVuZ3RoX3MgPSBjaHVua19sZW5ndGhfcyAvIDY7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjaHVua19sZW5ndGhfcyA8PSBzdHJpZGVfbGVuZ3RoX3MpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJgY2h1bmtfbGVuZ3RoX3NgIG11c3QgYmUgbGFyZ2VyIHRoYW4gYHN0cmlkZV9sZW5ndGhfc2AuXCIpXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gVE9ETyBzdXBwb3J0IGRpZmZlcmVudCBzdHJpZGVfbGVuZ3RoX3MgKGZvciBsZWZ0IGFuZCByaWdodClcblxuICAgICAgICAgICAgICAgIGNvbnN0IHdpbmRvdyA9IHNhbXBsaW5nX3JhdGUgKiBjaHVua19sZW5ndGhfcztcbiAgICAgICAgICAgICAgICBjb25zdCBzdHJpZGUgPSBzYW1wbGluZ19yYXRlICogc3RyaWRlX2xlbmd0aF9zO1xuICAgICAgICAgICAgICAgIGNvbnN0IGp1bXAgPSB3aW5kb3cgLSAyICogc3RyaWRlO1xuICAgICAgICAgICAgICAgIGxldCBvZmZzZXQgPSAwO1xuXG4gICAgICAgICAgICAgICAgLy8gQ3JlYXRlIHN1YmFycmF5cyBvZiBhdWRpbyB3aXRoIG92ZXJsYXBzXG5cbiAgICAgICAgICAgICAgICB3aGlsZSAob2Zmc2V0IDwgYXVkLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgc3ViYXJyID0gYXVkLnN1YmFycmF5KG9mZnNldCwgb2Zmc2V0ICsgd2luZG93KTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGZlYXR1cmUgPSBhd2FpdCB0aGlzLnByb2Nlc3NvcihzdWJhcnIpO1xuXG4gICAgICAgICAgICAgICAgICAgIGxldCBpc0ZpcnN0ID0gb2Zmc2V0ID09PSAwO1xuICAgICAgICAgICAgICAgICAgICBsZXQgaXNMYXN0ID0gb2Zmc2V0ICsganVtcCA+PSBhdWQubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBjaHVua3MucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJpZGU6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJhcnIubGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzRmlyc3QgPyAwIDogc3RyaWRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzTGFzdCA/IDAgOiBzdHJpZGVcbiAgICAgICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnB1dF9mZWF0dXJlczogZmVhdHVyZS5pbnB1dF9mZWF0dXJlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzX2xhc3Q6IGlzTGFzdFxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICBvZmZzZXQgKz0ganVtcDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY2h1bmtzID0gW3tcbiAgICAgICAgICAgICAgICAgICAgc3RyaWRlOiBbYXVkLmxlbmd0aCwgMCwgMF0sXG4gICAgICAgICAgICAgICAgICAgIGlucHV0X2ZlYXR1cmVzOiAoYXdhaXQgdGhpcy5wcm9jZXNzb3IoYXVkKSkuaW5wdXRfZmVhdHVyZXMsXG4gICAgICAgICAgICAgICAgICAgIGlzX2xhc3Q6IHRydWVcbiAgICAgICAgICAgICAgICB9XVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBHZW5lcmF0ZSBmb3IgZWFjaCBzZXQgb2YgaW5wdXQgZmVhdHVyZXNcbiAgICAgICAgICAgIGZvciAobGV0IGNodW5rIG9mIGNodW5rcykge1xuICAgICAgICAgICAgICAgIC8vIE5PVEU6IGRvaW5nIHNlcXVlbnRpYWxseSBmb3Igbm93XG4gICAgICAgICAgICAgICAgbGV0IGRhdGEgPSBhd2FpdCB0aGlzLm1vZGVsLmdlbmVyYXRlKGNodW5rLmlucHV0X2ZlYXR1cmVzLCBrd2FyZ3MpO1xuXG4gICAgICAgICAgICAgICAgLy8gVE9ETzogUmlnaHQgbm93IHdlIG9ubHkgZ2V0IHRvcCBiZWFtXG4gICAgICAgICAgICAgICAgaWYgKHJldHVybl90aW1lc3RhbXBzID09PSAnd29yZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgY2h1bmsudG9rZW5zID0gZGF0YS5zZXF1ZW5jZXNbMF07XG4gICAgICAgICAgICAgICAgICAgIGNodW5rLnRva2VuX3RpbWVzdGFtcHMgPSBkYXRhLnRva2VuX3RpbWVzdGFtcHMudG9saXN0KClbMF0ubWFwKFxuICAgICAgICAgICAgICAgICAgICAgICAgeCA9PiByb3VuZCh4LCAyKVxuICAgICAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY2h1bmsudG9rZW5zID0gZGF0YVswXTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBjb252ZXJ0IHN0cmlkZSB0byBzZWNvbmRzXG4gICAgICAgICAgICAgICAgY2h1bmsuc3RyaWRlID0gY2h1bmsuc3RyaWRlLm1hcCh4ID0+IHggLyBzYW1wbGluZ19yYXRlKTtcblxuICAgICAgICAgICAgICAgIGlmIChjaHVua19jYWxsYmFjayAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBjaHVua19jYWxsYmFjayhjaHVuaylcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIE1lcmdlIHRleHQgY2h1bmtzXG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBsZXQgW2Z1bGxfdGV4dCwgb3B0aW9uYWxdID0gdGhpcy50b2tlbml6ZXIuX2RlY29kZV9hc3IoY2h1bmtzLCB7XG4gICAgICAgICAgICAgICAgdGltZV9wcmVjaXNpb24sIHJldHVybl90aW1lc3RhbXBzLCBmb3JjZV9mdWxsX3NlcXVlbmNlc1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHRvUmV0dXJuLnB1c2goeyB0ZXh0OiBmdWxsX3RleHQsIC4uLm9wdGlvbmFsIH0pXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNpbmdsZSA/IHRvUmV0dXJuWzBdIDogdG9SZXR1cm47XG4gICAgfVxufVxuXG4vKipcbiAqIEltYWdlIFRvIFRleHQgcGlwZWxpbmUgdXNpbmcgYSBgQXV0b01vZGVsRm9yVmlzaW9uMlNlcWAuIFRoaXMgcGlwZWxpbmUgcHJlZGljdHMgYSBjYXB0aW9uIGZvciBhIGdpdmVuIGltYWdlLlxuICogQGV4dGVuZHMgUGlwZWxpbmVcbiAqL1xuZXhwb3J0IGNsYXNzIEltYWdlVG9UZXh0UGlwZWxpbmUgZXh0ZW5kcyBQaXBlbGluZSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IEltYWdlVG9UZXh0UGlwZWxpbmUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRhc2sgVGhlIHRhc2sgb2YgdGhlIHBpcGVsaW5lLiBVc2VmdWwgZm9yIHNwZWNpZnlpbmcgc3VidGFza3MuXG4gICAgICogQHBhcmFtIHtQcmVUcmFpbmVkVG9rZW5pemVyfSB0b2tlbml6ZXIgVGhlIHRva2VuaXplciB0byB1c2UuXG4gICAgICogQHBhcmFtIHtQcmVUcmFpbmVkTW9kZWx9IG1vZGVsIFRoZSBtb2RlbCB0byB1c2UuXG4gICAgICogQHBhcmFtIHtQcm9jZXNzb3J9IHByb2Nlc3NvciBUaGUgcHJvY2Vzc29yIHRvIHVzZS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih0YXNrLCB0b2tlbml6ZXIsIG1vZGVsLCBwcm9jZXNzb3IpIHtcbiAgICAgICAgc3VwZXIodGFzaywgdG9rZW5pemVyLCBtb2RlbCk7XG4gICAgICAgIHRoaXMucHJvY2Vzc29yID0gcHJvY2Vzc29yO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFzc2lnbiBsYWJlbHMgdG8gdGhlIGltYWdlKHMpIHBhc3NlZCBhcyBpbnB1dHMuXG4gICAgICogQHBhcmFtIHthbnlbXX0gaW1hZ2VzIFRoZSBpbWFnZXMgdG8gYmUgY2FwdGlvbmVkLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbZ2VuZXJhdGVfa3dhcmdzPXt9XSBPcHRpb25hbCBnZW5lcmF0aW9uIGFyZ3VtZW50cy5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3R8T2JqZWN0W10+fSBBIFByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhbiBvYmplY3QgKG9yIGFycmF5IG9mIG9iamVjdHMpIGNvbnRhaW5pbmcgdGhlIGdlbmVyYXRlZCB0ZXh0KHMpLlxuICAgICAqL1xuICAgIGFzeW5jIF9jYWxsKGltYWdlcywgZ2VuZXJhdGVfa3dhcmdzID0ge30pIHtcbiAgICAgICAgbGV0IGlzQmF0Y2hlZCA9IEFycmF5LmlzQXJyYXkoaW1hZ2VzKTtcblxuICAgICAgICBpbWFnZXMgPSBhd2FpdCBwcmVwYXJlSW1hZ2VzKGltYWdlcyk7XG5cbiAgICAgICAgbGV0IHsgcGl4ZWxfdmFsdWVzIH0gPSBhd2FpdCB0aGlzLnByb2Nlc3NvcihpbWFnZXMpO1xuXG4gICAgICAgIGxldCB0b1JldHVybiA9IFtdO1xuICAgICAgICBmb3IgKGxldCBiYXRjaCBvZiBwaXhlbF92YWx1ZXMpIHtcbiAgICAgICAgICAgIGJhdGNoLmRpbXMgPSBbMSwgLi4uYmF0Y2guZGltc11cbiAgICAgICAgICAgIGxldCBvdXRwdXQgPSBhd2FpdCB0aGlzLm1vZGVsLmdlbmVyYXRlKGJhdGNoLCBnZW5lcmF0ZV9rd2FyZ3MpO1xuICAgICAgICAgICAgbGV0IGRlY29kZWQgPSB0aGlzLnRva2VuaXplci5iYXRjaF9kZWNvZGUob3V0cHV0LCB7XG4gICAgICAgICAgICAgICAgc2tpcF9zcGVjaWFsX3Rva2VuczogdHJ1ZSxcbiAgICAgICAgICAgIH0pLm1hcCh4ID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBnZW5lcmF0ZWRfdGV4dDogeC50cmltKCkgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIHRvUmV0dXJuLnB1c2goZGVjb2RlZCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaXNCYXRjaGVkID8gdG9SZXR1cm4gOiB0b1JldHVyblswXTtcbiAgICB9XG59XG5cbi8qKlxuICogSW1hZ2UgY2xhc3NpZmljYXRpb24gcGlwZWxpbmUgdXNpbmcgYW55IGBBdXRvTW9kZWxGb3JJbWFnZUNsYXNzaWZpY2F0aW9uYC5cbiAqIFRoaXMgcGlwZWxpbmUgcHJlZGljdHMgdGhlIGNsYXNzIG9mIGFuIGltYWdlLlxuICogXG4gKiAqKkV4YW1wbGU6KiogQ2xhc3NpZnkgYW4gaW1hZ2UuXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBsZXQgY2xhc3NpZmllciA9IGF3YWl0IHBpcGVsaW5lKCdpbWFnZS1jbGFzc2lmaWNhdGlvbicsICdYZW5vdmEvdml0LWJhc2UtcGF0Y2gxNi0yMjQnKTtcbiAqIGxldCB1cmwgPSAnaHR0cHM6Ly9odWdnaW5nZmFjZS5jby9kYXRhc2V0cy9YZW5vdmEvdHJhbnNmb3JtZXJzLmpzLWRvY3MvcmVzb2x2ZS9tYWluL3RpZ2VyLmpwZyc7XG4gKiBsZXQgb3V0cHV0cyA9IGF3YWl0IGNsYXNzaWZpZXIodXJsKTtcbiAqIC8vIEFycmF5KDEpIFtcbiAqIC8vICAge2xhYmVsOiAndGlnZXIsIFBhbnRoZXJhIHRpZ3JpcycsIHNjb3JlOiAwLjYzMjY5NTczNDUwMDg4NX0sXG4gKiAvLyBdXG4gKiBgYGBcbiAqIFxuICogKipFeGFtcGxlOioqIENsYXNzaWZ5IGFuIGltYWdlIGFuZCByZXR1cm4gdG9wIGBuYCBjbGFzc2VzLlxuICogYGBgamF2YXNjcmlwdFxuICogbGV0IGNsYXNzaWZpZXIgPSBhd2FpdCBwaXBlbGluZSgnaW1hZ2UtY2xhc3NpZmljYXRpb24nLCAnWGVub3ZhL3ZpdC1iYXNlLXBhdGNoMTYtMjI0Jyk7XG4gKiBsZXQgdXJsID0gJ2h0dHBzOi8vaHVnZ2luZ2ZhY2UuY28vZGF0YXNldHMvWGVub3ZhL3RyYW5zZm9ybWVycy5qcy1kb2NzL3Jlc29sdmUvbWFpbi90aWdlci5qcGcnO1xuICogbGV0IG91dHB1dHMgPSBhd2FpdCBjbGFzc2lmaWVyKHVybCwgeyB0b3BrOiAzIH0pO1xuICogLy8gQXJyYXkoMykgW1xuICogLy8gICB7bGFiZWw6ICd0aWdlciwgUGFudGhlcmEgdGlncmlzJywgc2NvcmU6IDAuNjMyNjk1NzM0NTAwODg1fSxcbiAqIC8vICAge2xhYmVsOiAndGlnZXIgY2F0Jywgc2NvcmU6IDAuMzYzNDgyNTY0Njg3NzI4OX0sXG4gKiAvLyAgIHtsYWJlbDogJ2xpb24sIGtpbmcgb2YgYmVhc3RzLCBQYW50aGVyYSBsZW8nLCBzY29yZTogMC4wMDA0NTA2MDMwODE4NDQ3NDcwN30sXG4gKiAvLyBdXG4gKiBgYGBcbiAqIFxuICogKipFeGFtcGxlOioqIENsYXNzaWZ5IGFuIGltYWdlIGFuZCByZXR1cm4gYWxsIGNsYXNzZXMuXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBsZXQgY2xhc3NpZmllciA9IGF3YWl0IHBpcGVsaW5lKCdpbWFnZS1jbGFzc2lmaWNhdGlvbicsICdYZW5vdmEvdml0LWJhc2UtcGF0Y2gxNi0yMjQnKTtcbiAqIGxldCB1cmwgPSAnaHR0cHM6Ly9odWdnaW5nZmFjZS5jby9kYXRhc2V0cy9YZW5vdmEvdHJhbnNmb3JtZXJzLmpzLWRvY3MvcmVzb2x2ZS9tYWluL3RpZ2VyLmpwZyc7XG4gKiBsZXQgb3V0cHV0cyA9IGF3YWl0IGNsYXNzaWZpZXIodXJsLCB7IHRvcGs6IDAgfSk7XG4gKiAvLyBBcnJheSgxMDAwKSBbXG4gKiAvLyAgIHtsYWJlbDogJ3RpZ2VyLCBQYW50aGVyYSB0aWdyaXMnLCBzY29yZTogMC42MzI2OTU3MzQ1MDA4ODV9LFxuICogLy8gICB7bGFiZWw6ICd0aWdlciBjYXQnLCBzY29yZTogMC4zNjM0ODI1NjQ2ODc3Mjg5fSxcbiAqIC8vICAge2xhYmVsOiAnbGlvbiwga2luZyBvZiBiZWFzdHMsIFBhbnRoZXJhIGxlbycsIHNjb3JlOiAwLjAwMDQ1MDYwMzA4MTg0NDc0NzA3fSxcbiAqIC8vICAge2xhYmVsOiAnamFndWFyLCBwYW50aGVyLCBQYW50aGVyYSBvbmNhLCBGZWxpcyBvbmNhJywgc2NvcmU6IDAuMDAwMzU0NjU0OTk5NjgyNjc5Nzd9LFxuICogLy8gICAuLi5cbiAqIC8vIF1cbiAqIGBgYFxuICogQGV4dGVuZHMgUGlwZWxpbmVcbiAqL1xuZXhwb3J0IGNsYXNzIEltYWdlQ2xhc3NpZmljYXRpb25QaXBlbGluZSBleHRlbmRzIFBpcGVsaW5lIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgSW1hZ2VDbGFzc2lmaWNhdGlvblBpcGVsaW5lLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0YXNrIFRoZSB0YXNrIG9mIHRoZSBwaXBlbGluZS4gVXNlZnVsIGZvciBzcGVjaWZ5aW5nIHN1YnRhc2tzLlxuICAgICAqIEBwYXJhbSB7UHJlVHJhaW5lZE1vZGVsfSBtb2RlbCBUaGUgbW9kZWwgdG8gdXNlLlxuICAgICAqIEBwYXJhbSB7UHJvY2Vzc29yfSBwcm9jZXNzb3IgVGhlIHByb2Nlc3NvciB0byB1c2UuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IodGFzaywgbW9kZWwsIHByb2Nlc3Nvcikge1xuICAgICAgICBzdXBlcih0YXNrLCBudWxsLCBtb2RlbCk7IC8vIFRPRE8gdG9rZW5pemVyXG4gICAgICAgIHRoaXMucHJvY2Vzc29yID0gcHJvY2Vzc29yO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENsYXNzaWZ5IHRoZSBnaXZlbiBpbWFnZXMuXG4gICAgICogQHBhcmFtIHthbnl9IGltYWdlcyBUaGUgaW1hZ2VzIHRvIGNsYXNzaWZ5LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIFRoZSBvcHRpb25zIHRvIHVzZSBmb3IgY2xhc3NpZmljYXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnRvcGs9MV0gVGhlIG51bWJlciBvZiB0b3AgcmVzdWx0cyB0byByZXR1cm4uXG4gICAgICogQHJldHVybnMge1Byb21pc2U8YW55Pn0gVGhlIHRvcCBjbGFzc2lmaWNhdGlvbiByZXN1bHRzIGZvciB0aGUgaW1hZ2VzLlxuICAgICAqL1xuICAgIGFzeW5jIF9jYWxsKGltYWdlcywge1xuICAgICAgICB0b3BrID0gMVxuICAgIH0gPSB7fSkge1xuICAgICAgICBsZXQgaXNCYXRjaGVkID0gQXJyYXkuaXNBcnJheShpbWFnZXMpO1xuICAgICAgICBpbWFnZXMgPSBhd2FpdCBwcmVwYXJlSW1hZ2VzKGltYWdlcyk7XG5cbiAgICAgICAgbGV0IHsgcGl4ZWxfdmFsdWVzIH0gPSBhd2FpdCB0aGlzLnByb2Nlc3NvcihpbWFnZXMpO1xuICAgICAgICBsZXQgb3V0cHV0ID0gYXdhaXQgdGhpcy5tb2RlbCh7IHBpeGVsX3ZhbHVlcyB9KTtcblxuICAgICAgICBsZXQgaWQybGFiZWwgPSB0aGlzLm1vZGVsLmNvbmZpZy5pZDJsYWJlbDtcbiAgICAgICAgbGV0IHRvUmV0dXJuID0gW107XG4gICAgICAgIGZvciAobGV0IGJhdGNoIG9mIG91dHB1dC5sb2dpdHMpIHtcbiAgICAgICAgICAgIGxldCBzY29yZXMgPSBnZXRUb3BJdGVtcyhzb2Z0bWF4KGJhdGNoLmRhdGEpLCB0b3BrKTtcblxuICAgICAgICAgICAgbGV0IHZhbHMgPSBzY29yZXMubWFwKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgbGFiZWw6IGlkMmxhYmVsW3hbMF1dLFxuICAgICAgICAgICAgICAgICAgICBzY29yZTogeFsxXSxcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICh0b3BrID09PSAxKSB7XG4gICAgICAgICAgICAgICAgdG9SZXR1cm4ucHVzaCguLi52YWxzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdG9SZXR1cm4ucHVzaCh2YWxzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpc0JhdGNoZWQgfHwgdG9wayA9PT0gMSA/IHRvUmV0dXJuIDogdG9SZXR1cm5bMF07XG4gICAgfVxuXG59XG5cbi8qKlxuICogSW1hZ2Ugc2VnbWVudGF0aW9uIHBpcGVsaW5lIHVzaW5nIGFueSBgQXV0b01vZGVsRm9yWFhYU2VnbWVudGF0aW9uYC5cbiAqIFRoaXMgcGlwZWxpbmUgcHJlZGljdHMgbWFza3Mgb2Ygb2JqZWN0cyBhbmQgdGhlaXIgY2xhc3Nlcy5cbiAqIEBleHRlbmRzIFBpcGVsaW5lXG4gKi9cbmV4cG9ydCBjbGFzcyBJbWFnZVNlZ21lbnRhdGlvblBpcGVsaW5lIGV4dGVuZHMgUGlwZWxpbmUge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBJbWFnZVNlZ21lbnRhdGlvblBpcGVsaW5lLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0YXNrIFRoZSB0YXNrIG9mIHRoZSBwaXBlbGluZS4gVXNlZnVsIGZvciBzcGVjaWZ5aW5nIHN1YnRhc2tzLlxuICAgICAqIEBwYXJhbSB7UHJlVHJhaW5lZE1vZGVsfSBtb2RlbCBUaGUgbW9kZWwgdG8gdXNlLlxuICAgICAqIEBwYXJhbSB7UHJvY2Vzc29yfSBwcm9jZXNzb3IgVGhlIHByb2Nlc3NvciB0byB1c2UuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IodGFzaywgbW9kZWwsIHByb2Nlc3Nvcikge1xuICAgICAgICBzdXBlcih0YXNrLCBudWxsLCBtb2RlbCk7IC8vIFRPRE8gdG9rZW5pemVyXG4gICAgICAgIHRoaXMucHJvY2Vzc29yID0gcHJvY2Vzc29yO1xuXG4gICAgICAgIHRoaXMuc3VidGFza3NfbWFwcGluZyA9IHtcbiAgICAgICAgICAgIC8vIE1hcHBpbmcgb2Ygc3VidGFza3MgdG8gdGhlaXIgY29ycmVzcG9uZGluZyBwb3N0LXByb2Nlc3NpbmcgZnVuY3Rpb24gbmFtZXMuXG4gICAgICAgICAgICBwYW5vcHRpYzogJ3Bvc3RfcHJvY2Vzc19wYW5vcHRpY19zZWdtZW50YXRpb24nLFxuICAgICAgICAgICAgaW5zdGFuY2U6ICdwb3N0X3Byb2Nlc3NfaW5zdGFuY2Vfc2VnbWVudGF0aW9uJyxcbiAgICAgICAgICAgIHNlbWFudGljOiAncG9zdF9wcm9jZXNzX3NlbWFudGljX3NlZ21lbnRhdGlvbidcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNlZ21lbnQgdGhlIGlucHV0IGltYWdlcy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBpbWFnZXMgVGhlIGlucHV0IGltYWdlcy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBUaGUgb3B0aW9ucyB0byB1c2UgZm9yIHNlZ21lbnRhdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMudGhyZXNob2xkPTAuNV0gUHJvYmFiaWxpdHkgdGhyZXNob2xkIHRvIGZpbHRlciBvdXQgcHJlZGljdGVkIG1hc2tzLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5tYXNrX3RocmVzaG9sZD0wLjVdIFRocmVzaG9sZCB0byB1c2Ugd2hlbiB0dXJuaW5nIHRoZSBwcmVkaWN0ZWQgbWFza3MgaW50byBiaW5hcnkgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5vdmVybGFwX21hc2tfYXJlYV90aHJlc2hvbGQ9MC44XSBNYXNrIG92ZXJsYXAgdGhyZXNob2xkIHRvIGVsaW1pbmF0ZSBzbWFsbCwgZGlzY29ubmVjdGVkIHNlZ21lbnRzLlxuICAgICAqIEBwYXJhbSB7bnVsbHxzdHJpbmd9IFtvcHRpb25zLnN1YnRhc2s9bnVsbF0gU2VnbWVudGF0aW9uIHRhc2sgdG8gYmUgcGVyZm9ybWVkLiBPbmUgb2YgW2BwYW5vcHRpY2AsIGBpbnN0YW5jZWAsIGFuZCBgc2VtYW50aWNgXSwgZGVwZW5kaW5nIG9uIG1vZGVsIGNhcGFiaWxpdGllcy4gSWYgbm90IHNldCwgdGhlIHBpcGVsaW5lIHdpbGwgYXR0ZW1wdCB0byByZXNvbHZlIChpbiB0aGF0IG9yZGVyKS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbb3B0aW9ucy5sYWJlbF9pZHNfdG9fZnVzZT1udWxsXSBMaXN0IG9mIGxhYmVsIGlkcyB0byBmdXNlLiBJZiBub3Qgc2V0LCBkbyBub3QgZnVzZSBhbnkgbGFiZWxzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtvcHRpb25zLnRhcmdldF9zaXplcz1udWxsXSBMaXN0IG9mIHRhcmdldCBzaXplcyBmb3IgdGhlIGlucHV0IGltYWdlcy4gSWYgbm90IHNldCwgdXNlIHRoZSBvcmlnaW5hbCBpbWFnZSBzaXplcy5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxBcnJheT59IFRoZSBhbm5vdGF0ZWQgc2VnbWVudHMuXG4gICAgICovXG4gICAgYXN5bmMgX2NhbGwoaW1hZ2VzLCB7XG4gICAgICAgIHRocmVzaG9sZCA9IDAuNSxcbiAgICAgICAgbWFza190aHJlc2hvbGQgPSAwLjUsXG4gICAgICAgIG92ZXJsYXBfbWFza19hcmVhX3RocmVzaG9sZCA9IDAuOCxcbiAgICAgICAgbGFiZWxfaWRzX3RvX2Z1c2UgPSBudWxsLFxuICAgICAgICB0YXJnZXRfc2l6ZXMgPSBudWxsLFxuICAgICAgICBzdWJ0YXNrID0gbnVsbCwgLy8gVE9ETyB1c2VcbiAgICB9ID0ge30pIHtcbiAgICAgICAgbGV0IGlzQmF0Y2hlZCA9IEFycmF5LmlzQXJyYXkoaW1hZ2VzKTtcblxuICAgICAgICBpZiAoaXNCYXRjaGVkICYmIGltYWdlcy5sZW5ndGggIT09IDEpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKFwiSW1hZ2Ugc2VnbWVudGF0aW9uIHBpcGVsaW5lIGN1cnJlbnRseSBvbmx5IHN1cHBvcnRzIGEgYmF0Y2ggc2l6ZSBvZiAxLlwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGltYWdlcyA9IGF3YWl0IHByZXBhcmVJbWFnZXMoaW1hZ2VzKTtcbiAgICAgICAgbGV0IGltYWdlU2l6ZXMgPSBpbWFnZXMubWFwKHggPT4gW3guaGVpZ2h0LCB4LndpZHRoXSk7XG5cbiAgICAgICAgbGV0IHsgcGl4ZWxfdmFsdWVzLCBwaXhlbF9tYXNrIH0gPSBhd2FpdCB0aGlzLnByb2Nlc3NvcihpbWFnZXMpO1xuICAgICAgICBsZXQgb3V0cHV0ID0gYXdhaXQgdGhpcy5tb2RlbCh7IHBpeGVsX3ZhbHVlcywgcGl4ZWxfbWFzayB9KTtcblxuICAgICAgICBsZXQgZm4gPSBudWxsO1xuICAgICAgICBpZiAoc3VidGFzayAhPT0gbnVsbCkge1xuICAgICAgICAgICAgZm4gPSB0aGlzLnN1YnRhc2tzX21hcHBpbmdbc3VidGFza107XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGxldCBbdGFzaywgZnVuY10gb2YgT2JqZWN0LmVudHJpZXModGhpcy5zdWJ0YXNrc19tYXBwaW5nKSkge1xuICAgICAgICAgICAgICAgIGlmIChmdW5jIGluIHRoaXMucHJvY2Vzc29yLmZlYXR1cmVfZXh0cmFjdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGZuID0gdGhpcy5wcm9jZXNzb3IuZmVhdHVyZV9leHRyYWN0b3JbZnVuY10uYmluZCh0aGlzLnByb2Nlc3Nvci5mZWF0dXJlX2V4dHJhY3Rvcik7XG4gICAgICAgICAgICAgICAgICAgIHN1YnRhc2sgPSB0YXNrO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhZGQgYW5ub3RhdGlvbnNcbiAgICAgICAgbGV0IGFubm90YXRpb24gPSBbXTtcblxuICAgICAgICBpZiAoc3VidGFzayA9PT0gJ3Bhbm9wdGljJyB8fCBzdWJ0YXNrID09PSAnaW5zdGFuY2UnKSB7XG5cbiAgICAgICAgICAgIGxldCBwcm9jZXNzZWQgPSBmbihcbiAgICAgICAgICAgICAgICBvdXRwdXQsXG4gICAgICAgICAgICAgICAgdGhyZXNob2xkLFxuICAgICAgICAgICAgICAgIG1hc2tfdGhyZXNob2xkLFxuICAgICAgICAgICAgICAgIG92ZXJsYXBfbWFza19hcmVhX3RocmVzaG9sZCxcbiAgICAgICAgICAgICAgICBsYWJlbF9pZHNfdG9fZnVzZSxcbiAgICAgICAgICAgICAgICB0YXJnZXRfc2l6ZXMgPz8gaW1hZ2VTaXplcywgLy8gVE9ETyBGSVg/XG4gICAgICAgICAgICApWzBdO1xuXG4gICAgICAgICAgICBsZXQgc2VnbWVudGF0aW9uID0gcHJvY2Vzc2VkLnNlZ21lbnRhdGlvbjtcbiAgICAgICAgICAgIGxldCBpZDJsYWJlbCA9IHRoaXMubW9kZWwuY29uZmlnLmlkMmxhYmVsO1xuXG4gICAgICAgICAgICBmb3IgKGxldCBzZWdtZW50IG9mIHByb2Nlc3NlZC5zZWdtZW50c19pbmZvKSB7XG4gICAgICAgICAgICAgICAgbGV0IG1hc2tEYXRhID0gbmV3IFVpbnQ4Q2xhbXBlZEFycmF5KHNlZ21lbnRhdGlvbi5kYXRhLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWdtZW50YXRpb24uZGF0YS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VnbWVudGF0aW9uLmRhdGFbaV0gPT09IHNlZ21lbnQuaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hc2tEYXRhW2ldID0gMjU1O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbGV0IG1hc2sgPSBuZXcgUmF3SW1hZ2UobWFza0RhdGEsIHNlZ21lbnRhdGlvbi5kaW1zWzFdLCBzZWdtZW50YXRpb24uZGltc1swXSwgMSlcblxuICAgICAgICAgICAgICAgIGFubm90YXRpb24ucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHNjb3JlOiBzZWdtZW50LnNjb3JlLFxuICAgICAgICAgICAgICAgICAgICBsYWJlbDogaWQybGFiZWxbc2VnbWVudC5sYWJlbF9pZF0sXG4gICAgICAgICAgICAgICAgICAgIG1hc2s6IG1hc2tcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0gZWxzZSBpZiAoc3VidGFzayA9PT0gJ3NlbWFudGljJykge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoYHNlbWFudGljIHNlZ21lbnRhdGlvbiBub3QgeWV0IHN1cHBvcnRlZC5gKTtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoYFN1YnRhc2sgJHtzdWJ0YXNrfSBub3Qgc3VwcG9ydGVkLmApO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGFubm90YXRpb247XG4gICAgfVxufVxuXG5cbi8qKlxuICogWmVybyBzaG90IGltYWdlIGNsYXNzaWZpY2F0aW9uIHBpcGVsaW5lLiBUaGlzIHBpcGVsaW5lIHByZWRpY3RzIHRoZSBjbGFzcyBvZlxuICogYW4gaW1hZ2Ugd2hlbiB5b3UgcHJvdmlkZSBhbiBpbWFnZSBhbmQgYSBzZXQgb2YgYGNhbmRpZGF0ZV9sYWJlbHNgLlxuICogQGV4dGVuZHMgUGlwZWxpbmVcbiAqL1xuZXhwb3J0IGNsYXNzIFplcm9TaG90SW1hZ2VDbGFzc2lmaWNhdGlvblBpcGVsaW5lIGV4dGVuZHMgUGlwZWxpbmUge1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IFplcm9TaG90SW1hZ2VDbGFzc2lmaWNhdGlvblBpcGVsaW5lLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0YXNrIFRoZSB0YXNrIG9mIHRoZSBwaXBlbGluZS4gVXNlZnVsIGZvciBzcGVjaWZ5aW5nIHN1YnRhc2tzLlxuICAgICAqIEBwYXJhbSB7UHJlVHJhaW5lZFRva2VuaXplcn0gdG9rZW5pemVyIFRoZSB0b2tlbml6ZXIgdG8gdXNlLlxuICAgICAqIEBwYXJhbSB7UHJlVHJhaW5lZE1vZGVsfSBtb2RlbCBUaGUgbW9kZWwgdG8gdXNlLlxuICAgICAqIEBwYXJhbSB7UHJvY2Vzc29yfSBwcm9jZXNzb3IgVGhlIHByb2Nlc3NvciB0byB1c2UuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IodGFzaywgdG9rZW5pemVyLCBtb2RlbCwgcHJvY2Vzc29yKSB7XG4gICAgICAgIHN1cGVyKHRhc2ssIHRva2VuaXplciwgbW9kZWwpO1xuICAgICAgICB0aGlzLnByb2Nlc3NvciA9IHByb2Nlc3NvcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDbGFzc2lmeSB0aGUgaW5wdXQgaW1hZ2VzIHdpdGggY2FuZGlkYXRlIGxhYmVscyB1c2luZyBhIHplcm8tc2hvdCBhcHByb2FjaC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBpbWFnZXMgVGhlIGlucHV0IGltYWdlcy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBjYW5kaWRhdGVfbGFiZWxzIFRoZSBjYW5kaWRhdGUgbGFiZWxzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIFRoZSBvcHRpb25zIGZvciB0aGUgY2xhc3NpZmljYXRpb24uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmh5cG90aGVzaXNfdGVtcGxhdGVdIFRoZSBoeXBvdGhlc2lzIHRlbXBsYXRlIHRvIHVzZSBmb3IgemVyby1zaG90IGNsYXNzaWZpY2F0aW9uLiBEZWZhdWx0OiBcIlRoaXMgaXMgYSBwaG90byBvZiB7fVwiLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPGFueT59IEFuIGFycmF5IG9mIGNsYXNzaWZpY2F0aW9ucyBmb3IgZWFjaCBpbnB1dCBpbWFnZSBvciBhIHNpbmdsZSBjbGFzc2lmaWNhdGlvbiBvYmplY3QgaWYgb25seSBvbmUgaW5wdXQgaW1hZ2UgaXMgcHJvdmlkZWQuXG4gICAgICovXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGFzeW5jIF9jYWxsKGltYWdlcywgY2FuZGlkYXRlX2xhYmVscywge1xuICAgICAgICBoeXBvdGhlc2lzX3RlbXBsYXRlID0gXCJUaGlzIGlzIGEgcGhvdG8gb2Yge31cIlxuICAgIH0gPSB7fSkge1xuICAgICAgICBsZXQgaXNCYXRjaGVkID0gQXJyYXkuaXNBcnJheShpbWFnZXMpO1xuICAgICAgICBpbWFnZXMgPSBhd2FpdCBwcmVwYXJlSW1hZ2VzKGltYWdlcyk7XG5cbiAgICAgICAgLy8gSW5zZXJ0IGxhYmVsIGludG8gaHlwb3RoZXNpcyB0ZW1wbGF0ZSBcbiAgICAgICAgbGV0IHRleHRzID0gY2FuZGlkYXRlX2xhYmVscy5tYXAoXG4gICAgICAgICAgICB4ID0+IGh5cG90aGVzaXNfdGVtcGxhdGUucmVwbGFjZSgne30nLCB4KVxuICAgICAgICApO1xuXG4gICAgICAgIC8vIFJ1biB0b2tlbml6YXRpb25cbiAgICAgICAgbGV0IHRleHRfaW5wdXRzID0gdGhpcy50b2tlbml6ZXIodGV4dHMsIHtcbiAgICAgICAgICAgIHBhZGRpbmc6IHRydWUsXG4gICAgICAgICAgICB0cnVuY2F0aW9uOiB0cnVlXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFJ1biBwcm9jZXNzb3JcbiAgICAgICAgbGV0IHsgcGl4ZWxfdmFsdWVzIH0gPSBhd2FpdCB0aGlzLnByb2Nlc3NvcihpbWFnZXMpO1xuXG4gICAgICAgIC8vIFJ1biBtb2RlbCB3aXRoIGJvdGggdGV4dCBhbmQgcGl4ZWwgaW5wdXRzXG4gICAgICAgIGxldCBvdXRwdXQgPSBhd2FpdCB0aGlzLm1vZGVsKHsgLi4udGV4dF9pbnB1dHMsIHBpeGVsX3ZhbHVlcyB9KTtcblxuICAgICAgICAvLyBDb21wYXJlIGVhY2ggaW1hZ2Ugd2l0aCBlYWNoIGNhbmRpZGF0ZSBsYWJlbFxuICAgICAgICBsZXQgdG9SZXR1cm4gPSBbXTtcbiAgICAgICAgZm9yIChsZXQgYmF0Y2ggb2Ygb3V0cHV0LmxvZ2l0c19wZXJfaW1hZ2UpIHtcbiAgICAgICAgICAgIC8vIENvbXB1dGUgc29mdG1heCBwZXIgaW1hZ2VcbiAgICAgICAgICAgIGxldCBwcm9icyA9IHNvZnRtYXgoYmF0Y2guZGF0YSk7XG5cbiAgICAgICAgICAgIHRvUmV0dXJuLnB1c2goWy4uLnByb2JzXS5tYXAoKHgsIGkpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBzY29yZTogeCxcbiAgICAgICAgICAgICAgICAgICAgbGFiZWw6IGNhbmRpZGF0ZV9sYWJlbHNbaV1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaXNCYXRjaGVkID8gdG9SZXR1cm4gOiB0b1JldHVyblswXTtcbiAgICB9XG59XG5cbi8qKlxuICogT2JqZWN0IGRldGVjdGlvbiBwaXBlbGluZSB1c2luZyBhbnkgYEF1dG9Nb2RlbEZvck9iamVjdERldGVjdGlvbmAuXG4gKiBUaGlzIHBpcGVsaW5lIHByZWRpY3RzIGJvdW5kaW5nIGJveGVzIG9mIG9iamVjdHMgYW5kIHRoZWlyIGNsYXNzZXMuXG4gKiBcbiAqICoqRXhhbXBsZToqKiBSdW4gb2JqZWN0LWRldGVjdGlvbiB3aXRoIGBmYWNlYm9vay9kZXRyLXJlc25ldC01MGAuXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBsZXQgaW1nID0gJ2h0dHBzOi8vaHVnZ2luZ2ZhY2UuY28vZGF0YXNldHMvWGVub3ZhL3RyYW5zZm9ybWVycy5qcy1kb2NzL3Jlc29sdmUvbWFpbi9jYXRzLmpwZyc7XG4gKiBcbiAqIGxldCBkZXRlY3RvciA9IGF3YWl0IHBpcGVsaW5lKCdvYmplY3QtZGV0ZWN0aW9uJywgJ1hlbm92YS9kZXRyLXJlc25ldC01MCcpO1xuICogbGV0IG91dHB1dCA9IGF3YWl0IGRldGVjdG9yKGltZywgeyB0aHJlc2hvbGQ6IDAuOSB9KTtcbiAqIC8vIFt7XG4gKiAvLyAgIFwic2NvcmVcIjogMC45OTc2MzcwOTMwNjcxNjkyLFxuICogLy8gICBcImxhYmVsXCI6IFwicmVtb3RlXCIsXG4gKiAvLyAgIFwiYm94XCI6IHsgXCJ4bWluXCI6IDMxLCBcInltaW5cIjogNjgsIFwieG1heFwiOiAxOTAsIFwieW1heFwiOiAxMTggfVxuICogLy8gfSxcbiAqIC8vIC4uLlxuICogLy8ge1xuICogLy8gICBcInNjb3JlXCI6IDAuOTk4NDA5MjExNjM1NTg5NixcbiAqIC8vICAgXCJsYWJlbFwiOiBcImNhdFwiLFxuICogLy8gICBcImJveFwiOiB7IFwieG1pblwiOiAzMzEsIFwieW1pblwiOiAxOSwgXCJ4bWF4XCI6IDY0OSwgXCJ5bWF4XCI6IDM3MSB9XG4gKiAvLyB9XVxuICogYGBgXG4gKiBcbiAqIEBleHRlbmRzIFBpcGVsaW5lXG4gKi9cbmV4cG9ydCBjbGFzcyBPYmplY3REZXRlY3Rpb25QaXBlbGluZSBleHRlbmRzIFBpcGVsaW5lIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgT2JqZWN0RGV0ZWN0aW9uUGlwZWxpbmUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRhc2sgVGhlIHRhc2sgb2YgdGhlIHBpcGVsaW5lLiBVc2VmdWwgZm9yIHNwZWNpZnlpbmcgc3VidGFza3MuXG4gICAgICogQHBhcmFtIHtQcmVUcmFpbmVkTW9kZWx9IG1vZGVsIFRoZSBtb2RlbCB0byB1c2UuXG4gICAgICogQHBhcmFtIHtQcm9jZXNzb3J9IHByb2Nlc3NvciBUaGUgcHJvY2Vzc29yIHRvIHVzZS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih0YXNrLCBtb2RlbCwgcHJvY2Vzc29yKSB7XG4gICAgICAgIHN1cGVyKHRhc2ssIG51bGwsIG1vZGVsKTsgLy8gVE9ETyB0b2tlbml6ZXJcbiAgICAgICAgdGhpcy5wcm9jZXNzb3IgPSBwcm9jZXNzb3I7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGV0ZWN0IG9iamVjdHMgKGJvdW5kaW5nIGJveGVzICYgY2xhc3NlcykgaW4gdGhlIGltYWdlKHMpIHBhc3NlZCBhcyBpbnB1dHMuXG4gICAgICogQHBhcmFtIHthbnlbXX0gaW1hZ2VzIFRoZSBpbnB1dCBpbWFnZXMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgVGhlIG9wdGlvbnMgZm9yIHRoZSBvYmplY3QgZGV0ZWN0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy50aHJlc2hvbGQ9MC45XSBUaGUgdGhyZXNob2xkIHVzZWQgdG8gZmlsdGVyIGJveGVzIGJ5IHNjb3JlLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMucGVyY2VudGFnZT1mYWxzZV0gV2hldGhlciB0byByZXR1cm4gdGhlIGJveGVzIGNvb3JkaW5hdGVzIGluIHBlcmNlbnRhZ2UgKHRydWUpIG9yIGluIHBpeGVscyAoZmFsc2UpLlxuICAgICAqL1xuICAgIGFzeW5jIF9jYWxsKGltYWdlcywge1xuICAgICAgICB0aHJlc2hvbGQgPSAwLjksXG4gICAgICAgIHBlcmNlbnRhZ2UgPSBmYWxzZSxcbiAgICB9ID0ge30pIHtcbiAgICAgICAgbGV0IGlzQmF0Y2hlZCA9IEFycmF5LmlzQXJyYXkoaW1hZ2VzKTtcblxuICAgICAgICBpZiAoaXNCYXRjaGVkICYmIGltYWdlcy5sZW5ndGggIT09IDEpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKFwiT2JqZWN0IGRldGVjdGlvbiBwaXBlbGluZSBjdXJyZW50bHkgb25seSBzdXBwb3J0cyBhIGJhdGNoIHNpemUgb2YgMS5cIik7XG4gICAgICAgIH1cbiAgICAgICAgaW1hZ2VzID0gYXdhaXQgcHJlcGFyZUltYWdlcyhpbWFnZXMpO1xuXG4gICAgICAgIGxldCBpbWFnZVNpemVzID0gcGVyY2VudGFnZSA/IG51bGwgOiBpbWFnZXMubWFwKHggPT4gW3guaGVpZ2h0LCB4LndpZHRoXSk7XG5cbiAgICAgICAgbGV0IHsgcGl4ZWxfdmFsdWVzLCBwaXhlbF9tYXNrIH0gPSBhd2FpdCB0aGlzLnByb2Nlc3NvcihpbWFnZXMpO1xuICAgICAgICBsZXQgb3V0cHV0ID0gYXdhaXQgdGhpcy5tb2RlbCh7IHBpeGVsX3ZhbHVlcywgcGl4ZWxfbWFzayB9KTtcblxuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGxldCBwcm9jZXNzZWQgPSB0aGlzLnByb2Nlc3Nvci5mZWF0dXJlX2V4dHJhY3Rvci5wb3N0X3Byb2Nlc3Nfb2JqZWN0X2RldGVjdGlvbihvdXRwdXQsIHRocmVzaG9sZCwgaW1hZ2VTaXplcyk7XG5cbiAgICAgICAgLy8gQWRkIGxhYmVsc1xuICAgICAgICBsZXQgaWQybGFiZWwgPSB0aGlzLm1vZGVsLmNvbmZpZy5pZDJsYWJlbDtcblxuICAgICAgICAvLyBGb3JtYXQgb3V0cHV0XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHByb2Nlc3NlZC5tYXAoYmF0Y2ggPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGJhdGNoLmJveGVzLm1hcCgoYm94LCBpKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgc2NvcmU6IGJhdGNoLnNjb3Jlc1tpXSxcbiAgICAgICAgICAgICAgICAgICAgbGFiZWw6IGlkMmxhYmVsW2JhdGNoLmNsYXNzZXNbaV1dLFxuICAgICAgICAgICAgICAgICAgICBib3g6IHRoaXMuX2dldF9ib3VuZGluZ19ib3goYm94LCAhcGVyY2VudGFnZSksXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfSlcblxuICAgICAgICByZXR1cm4gaXNCYXRjaGVkID8gcmVzdWx0IDogcmVzdWx0WzBdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhlbHBlciBmdW5jdGlvbiB0byBjb252ZXJ0IGxpc3QgW3htaW4sIHhtYXgsIHltaW4sIHltYXhdIGludG8gb2JqZWN0IHsgXCJ4bWluXCI6IHhtaW4sIC4uLiB9XG4gICAgICogQHBhcmFtIHtudW1iZXJbXX0gYm94IFRoZSBib3VuZGluZyBib3ggYXMgYSBsaXN0LlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gYXNJbnRlZ2VyIFdoZXRoZXIgdG8gY2FzdCB0byBpbnRlZ2Vycy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgYm91bmRpbmcgYm94IGFzIGFuIG9iamVjdC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9nZXRfYm91bmRpbmdfYm94KGJveCwgYXNJbnRlZ2VyKSB7XG4gICAgICAgIGlmIChhc0ludGVnZXIpIHtcbiAgICAgICAgICAgIGJveCA9IGJveC5tYXAoeCA9PiB4IHwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgW3htaW4sIHltaW4sIHhtYXgsIHltYXhdID0gYm94O1xuXG4gICAgICAgIHJldHVybiB7IHhtaW4sIHltaW4sIHhtYXgsIHltYXggfTtcbiAgICB9XG59XG5cbmNvbnN0IFNVUFBPUlRFRF9UQVNLUyA9IHtcbiAgICBcInRleHQtY2xhc3NpZmljYXRpb25cIjoge1xuICAgICAgICBcInRva2VuaXplclwiOiBBdXRvVG9rZW5pemVyLFxuICAgICAgICBcInBpcGVsaW5lXCI6IFRleHRDbGFzc2lmaWNhdGlvblBpcGVsaW5lLFxuICAgICAgICBcIm1vZGVsXCI6IEF1dG9Nb2RlbEZvclNlcXVlbmNlQ2xhc3NpZmljYXRpb24sXG4gICAgICAgIFwiZGVmYXVsdFwiOiB7XG4gICAgICAgICAgICAvLyBUT0RPOiByZXBsYWNlIHdpdGggb3JpZ2luYWxcbiAgICAgICAgICAgIC8vIFwibW9kZWxcIjogXCJkaXN0aWxiZXJ0LWJhc2UtdW5jYXNlZC1maW5ldHVuZWQtc3N0LTItZW5nbGlzaFwiLFxuICAgICAgICAgICAgXCJtb2RlbFwiOiBcIlhlbm92YS9kaXN0aWxiZXJ0LWJhc2UtdW5jYXNlZC1maW5ldHVuZWQtc3N0LTItZW5nbGlzaFwiLFxuICAgICAgICB9LFxuICAgICAgICBcInR5cGVcIjogXCJ0ZXh0XCIsXG4gICAgfSxcbiAgICBcInRva2VuLWNsYXNzaWZpY2F0aW9uXCI6IHtcbiAgICAgICAgXCJ0b2tlbml6ZXJcIjogQXV0b1Rva2VuaXplcixcbiAgICAgICAgXCJwaXBlbGluZVwiOiBUb2tlbkNsYXNzaWZpY2F0aW9uUGlwZWxpbmUsXG4gICAgICAgIFwibW9kZWxcIjogQXV0b01vZGVsRm9yVG9rZW5DbGFzc2lmaWNhdGlvbixcbiAgICAgICAgXCJkZWZhdWx0XCI6IHtcbiAgICAgICAgICAgIC8vIFRPRE86IHJlcGxhY2Ugd2l0aCBvcmlnaW5hbFxuICAgICAgICAgICAgLy8gXCJtb2RlbFwiOiBcIkRhdmxhbi9iZXJ0LWJhc2UtbXVsdGlsaW5ndWFsLWNhc2VkLW5lci1ocmxcIixcbiAgICAgICAgICAgIFwibW9kZWxcIjogXCJYZW5vdmEvYmVydC1iYXNlLW11bHRpbGluZ3VhbC1jYXNlZC1uZXItaHJsXCIsXG4gICAgICAgIH0sXG4gICAgICAgIFwidHlwZVwiOiBcInRleHRcIixcbiAgICB9LFxuICAgIFwicXVlc3Rpb24tYW5zd2VyaW5nXCI6IHtcbiAgICAgICAgXCJ0b2tlbml6ZXJcIjogQXV0b1Rva2VuaXplcixcbiAgICAgICAgXCJwaXBlbGluZVwiOiBRdWVzdGlvbkFuc3dlcmluZ1BpcGVsaW5lLFxuICAgICAgICBcIm1vZGVsXCI6IEF1dG9Nb2RlbEZvclF1ZXN0aW9uQW5zd2VyaW5nLFxuICAgICAgICBcImRlZmF1bHRcIjoge1xuICAgICAgICAgICAgLy8gVE9ETzogcmVwbGFjZSB3aXRoIG9yaWdpbmFsXG4gICAgICAgICAgICAvLyBcIm1vZGVsXCI6IFwiZGlzdGlsYmVydC1iYXNlLWNhc2VkLWRpc3RpbGxlZC1zcXVhZFwiLFxuICAgICAgICAgICAgXCJtb2RlbFwiOiBcIlhlbm92YS9kaXN0aWxiZXJ0LWJhc2UtY2FzZWQtZGlzdGlsbGVkLXNxdWFkXCIsXG4gICAgICAgIH0sXG4gICAgICAgIFwidHlwZVwiOiBcInRleHRcIixcbiAgICB9LFxuXG4gICAgXCJmaWxsLW1hc2tcIjoge1xuICAgICAgICBcInRva2VuaXplclwiOiBBdXRvVG9rZW5pemVyLFxuICAgICAgICBcInBpcGVsaW5lXCI6IEZpbGxNYXNrUGlwZWxpbmUsXG4gICAgICAgIFwibW9kZWxcIjogQXV0b01vZGVsRm9yTWFza2VkTE0sXG4gICAgICAgIFwiZGVmYXVsdFwiOiB7XG4gICAgICAgICAgICAvLyBUT0RPOiByZXBsYWNlIHdpdGggb3JpZ2luYWxcbiAgICAgICAgICAgIC8vIFwibW9kZWxcIjogXCJiZXJ0LWJhc2UtdW5jYXNlZFwiLFxuICAgICAgICAgICAgXCJtb2RlbFwiOiBcIlhlbm92YS9iZXJ0LWJhc2UtdW5jYXNlZFwiLFxuICAgICAgICB9LFxuICAgICAgICBcInR5cGVcIjogXCJ0ZXh0XCIsXG4gICAgfSxcbiAgICBcInN1bW1hcml6YXRpb25cIjoge1xuICAgICAgICBcInRva2VuaXplclwiOiBBdXRvVG9rZW5pemVyLFxuICAgICAgICBcInBpcGVsaW5lXCI6IFN1bW1hcml6YXRpb25QaXBlbGluZSxcbiAgICAgICAgXCJtb2RlbFwiOiBBdXRvTW9kZWxGb3JTZXEyU2VxTE0sXG4gICAgICAgIFwiZGVmYXVsdFwiOiB7XG4gICAgICAgICAgICAvLyBUT0RPOiByZXBsYWNlIHdpdGggb3JpZ2luYWxcbiAgICAgICAgICAgIC8vIFwibW9kZWxcIjogXCJzc2hsZWlmZXIvZGlzdGlsYmFydC1jbm4tNi02XCIsXG4gICAgICAgICAgICBcIm1vZGVsXCI6IFwiWGVub3ZhL2Rpc3RpbGJhcnQtY25uLTYtNlwiLFxuICAgICAgICB9LFxuICAgICAgICBcInR5cGVcIjogXCJ0ZXh0XCIsXG4gICAgfSxcbiAgICBcInRyYW5zbGF0aW9uXCI6IHtcbiAgICAgICAgXCJ0b2tlbml6ZXJcIjogQXV0b1Rva2VuaXplcixcbiAgICAgICAgXCJwaXBlbGluZVwiOiBUcmFuc2xhdGlvblBpcGVsaW5lLFxuICAgICAgICBcIm1vZGVsXCI6IEF1dG9Nb2RlbEZvclNlcTJTZXFMTSxcbiAgICAgICAgXCJkZWZhdWx0XCI6IHtcbiAgICAgICAgICAgIC8vIFRPRE86IHJlcGxhY2Ugd2l0aCBvcmlnaW5hbFxuICAgICAgICAgICAgLy8gXCJtb2RlbFwiOiBcInQ1LXNtYWxsXCIsXG4gICAgICAgICAgICBcIm1vZGVsXCI6IFwiWGVub3ZhL3Q1LXNtYWxsXCIsXG4gICAgICAgIH0sXG4gICAgICAgIFwidHlwZVwiOiBcInRleHRcIixcbiAgICB9LFxuICAgIFwidGV4dDJ0ZXh0LWdlbmVyYXRpb25cIjoge1xuICAgICAgICBcInRva2VuaXplclwiOiBBdXRvVG9rZW5pemVyLFxuICAgICAgICBcInBpcGVsaW5lXCI6IFRleHQyVGV4dEdlbmVyYXRpb25QaXBlbGluZSxcbiAgICAgICAgXCJtb2RlbFwiOiBBdXRvTW9kZWxGb3JTZXEyU2VxTE0sXG4gICAgICAgIFwiZGVmYXVsdFwiOiB7XG4gICAgICAgICAgICAvLyBUT0RPOiByZXBsYWNlIHdpdGggb3JpZ2luYWxcbiAgICAgICAgICAgIC8vIFwibW9kZWxcIjogXCJnb29nbGUvZmxhbi10NS1zbWFsbFwiLFxuICAgICAgICAgICAgXCJtb2RlbFwiOiBcIlhlbm92YS9mbGFuLXQ1LXNtYWxsXCIsXG4gICAgICAgIH0sXG4gICAgICAgIFwidHlwZVwiOiBcInRleHRcIixcbiAgICB9LFxuICAgIFwidGV4dC1nZW5lcmF0aW9uXCI6IHtcbiAgICAgICAgXCJ0b2tlbml6ZXJcIjogQXV0b1Rva2VuaXplcixcbiAgICAgICAgXCJwaXBlbGluZVwiOiBUZXh0R2VuZXJhdGlvblBpcGVsaW5lLFxuICAgICAgICBcIm1vZGVsXCI6IEF1dG9Nb2RlbEZvckNhdXNhbExNLFxuICAgICAgICBcImRlZmF1bHRcIjoge1xuICAgICAgICAgICAgLy8gVE9ETzogcmVwbGFjZSB3aXRoIG9yaWdpbmFsXG4gICAgICAgICAgICAvLyBcIm1vZGVsXCI6IFwiZ3B0MlwiLFxuICAgICAgICAgICAgXCJtb2RlbFwiOiBcIlhlbm92YS9ncHQyXCIsXG4gICAgICAgIH0sXG4gICAgICAgIFwidHlwZVwiOiBcInRleHRcIixcbiAgICB9LFxuICAgIFwiemVyby1zaG90LWNsYXNzaWZpY2F0aW9uXCI6IHtcbiAgICAgICAgXCJ0b2tlbml6ZXJcIjogQXV0b1Rva2VuaXplcixcbiAgICAgICAgXCJwaXBlbGluZVwiOiBaZXJvU2hvdENsYXNzaWZpY2F0aW9uUGlwZWxpbmUsXG4gICAgICAgIFwibW9kZWxcIjogQXV0b01vZGVsRm9yU2VxdWVuY2VDbGFzc2lmaWNhdGlvbixcbiAgICAgICAgXCJkZWZhdWx0XCI6IHtcbiAgICAgICAgICAgIC8vIFRPRE86IHJlcGxhY2Ugd2l0aCBvcmlnaW5hbFxuICAgICAgICAgICAgLy8gXCJtb2RlbFwiOiBcInR5cGVmb3JtL2Rpc3RpbGJlcnQtYmFzZS11bmNhc2VkLW1ubGlcIixcbiAgICAgICAgICAgIFwibW9kZWxcIjogXCJYZW5vdmEvZGlzdGlsYmVydC1iYXNlLXVuY2FzZWQtbW5saVwiLFxuICAgICAgICB9LFxuICAgICAgICBcInR5cGVcIjogXCJ0ZXh0XCIsXG4gICAgfSxcblxuICAgIFwiYXV0b21hdGljLXNwZWVjaC1yZWNvZ25pdGlvblwiOiB7XG4gICAgICAgIFwidG9rZW5pemVyXCI6IEF1dG9Ub2tlbml6ZXIsXG4gICAgICAgIFwicGlwZWxpbmVcIjogQXV0b21hdGljU3BlZWNoUmVjb2duaXRpb25QaXBlbGluZSxcbiAgICAgICAgXCJtb2RlbFwiOiBBdXRvTW9kZWxGb3JTZXEyU2VxTE0sXG4gICAgICAgIFwicHJvY2Vzc29yXCI6IEF1dG9Qcm9jZXNzb3IsXG4gICAgICAgIFwiZGVmYXVsdFwiOiB7XG4gICAgICAgICAgICAvLyBUT0RPOiByZXBsYWNlIHdpdGggb3JpZ2luYWxcbiAgICAgICAgICAgIC8vIFwibW9kZWxcIjogXCJvcGVuYWkvd2hpc3Blci10aW55LmVuXCIsXG4gICAgICAgICAgICBcIm1vZGVsXCI6IFwiWGVub3ZhL3doaXNwZXItdGlueS5lblwiLFxuICAgICAgICB9LFxuICAgICAgICBcInR5cGVcIjogXCJtdWx0aW1vZGFsXCIsXG4gICAgfSxcblxuICAgIFwiaW1hZ2UtdG8tdGV4dFwiOiB7XG4gICAgICAgIFwidG9rZW5pemVyXCI6IEF1dG9Ub2tlbml6ZXIsXG4gICAgICAgIFwicGlwZWxpbmVcIjogSW1hZ2VUb1RleHRQaXBlbGluZSxcbiAgICAgICAgXCJtb2RlbFwiOiBBdXRvTW9kZWxGb3JWaXNpb24yU2VxLFxuICAgICAgICBcInByb2Nlc3NvclwiOiBBdXRvUHJvY2Vzc29yLFxuICAgICAgICBcImRlZmF1bHRcIjoge1xuICAgICAgICAgICAgLy8gVE9ETzogcmVwbGFjZSB3aXRoIG9yaWdpbmFsXG4gICAgICAgICAgICAvLyBcIm1vZGVsXCI6IFwibmxwY29ubmVjdC92aXQtZ3B0Mi1pbWFnZS1jYXB0aW9uaW5nXCIsXG4gICAgICAgICAgICBcIm1vZGVsXCI6IFwiWGVub3ZhL3ZpdC1ncHQyLWltYWdlLWNhcHRpb25pbmdcIixcbiAgICAgICAgfSxcbiAgICAgICAgXCJ0eXBlXCI6IFwibXVsdGltb2RhbFwiLFxuICAgIH0sXG5cbiAgICBcImltYWdlLWNsYXNzaWZpY2F0aW9uXCI6IHtcbiAgICAgICAgLy8gbm8gdG9rZW5pemVyXG4gICAgICAgIFwicGlwZWxpbmVcIjogSW1hZ2VDbGFzc2lmaWNhdGlvblBpcGVsaW5lLFxuICAgICAgICBcIm1vZGVsXCI6IEF1dG9Nb2RlbEZvckltYWdlQ2xhc3NpZmljYXRpb24sXG4gICAgICAgIFwicHJvY2Vzc29yXCI6IEF1dG9Qcm9jZXNzb3IsXG4gICAgICAgIFwiZGVmYXVsdFwiOiB7XG4gICAgICAgICAgICAvLyBUT0RPOiByZXBsYWNlIHdpdGggb3JpZ2luYWxcbiAgICAgICAgICAgIC8vIFwibW9kZWxcIjogXCJnb29nbGUvdml0LWJhc2UtcGF0Y2gxNi0yMjRcIixcbiAgICAgICAgICAgIFwibW9kZWxcIjogXCJYZW5vdmEvdml0LWJhc2UtcGF0Y2gxNi0yMjRcIixcbiAgICAgICAgfSxcbiAgICAgICAgXCJ0eXBlXCI6IFwibXVsdGltb2RhbFwiLFxuICAgIH0sXG5cbiAgICBcImltYWdlLXNlZ21lbnRhdGlvblwiOiB7XG4gICAgICAgIC8vIG5vIHRva2VuaXplclxuICAgICAgICBcInBpcGVsaW5lXCI6IEltYWdlU2VnbWVudGF0aW9uUGlwZWxpbmUsXG4gICAgICAgIFwibW9kZWxcIjogQXV0b01vZGVsRm9ySW1hZ2VTZWdtZW50YXRpb24sXG4gICAgICAgIFwicHJvY2Vzc29yXCI6IEF1dG9Qcm9jZXNzb3IsXG4gICAgICAgIFwiZGVmYXVsdFwiOiB7XG4gICAgICAgICAgICAvLyBUT0RPOiByZXBsYWNlIHdpdGggb3JpZ2luYWxcbiAgICAgICAgICAgIC8vIFwibW9kZWxcIjogXCJmYWNlYm9vay9kZXRyLXJlc25ldC01MC1wYW5vcHRpY1wiLFxuICAgICAgICAgICAgXCJtb2RlbFwiOiBcIlhlbm92YS9kZXRyLXJlc25ldC01MC1wYW5vcHRpY1wiLFxuICAgICAgICB9LFxuICAgICAgICBcInR5cGVcIjogXCJtdWx0aW1vZGFsXCIsXG4gICAgfSxcblxuICAgIFwiemVyby1zaG90LWltYWdlLWNsYXNzaWZpY2F0aW9uXCI6IHtcbiAgICAgICAgLy8gbm8gdG9rZW5pemVyXG4gICAgICAgIFwidG9rZW5pemVyXCI6IEF1dG9Ub2tlbml6ZXIsXG4gICAgICAgIFwicGlwZWxpbmVcIjogWmVyb1Nob3RJbWFnZUNsYXNzaWZpY2F0aW9uUGlwZWxpbmUsXG4gICAgICAgIFwibW9kZWxcIjogQXV0b01vZGVsLFxuICAgICAgICBcInByb2Nlc3NvclwiOiBBdXRvUHJvY2Vzc29yLFxuICAgICAgICBcImRlZmF1bHRcIjoge1xuICAgICAgICAgICAgLy8gVE9ETzogcmVwbGFjZSB3aXRoIG9yaWdpbmFsXG4gICAgICAgICAgICAvLyBcIm1vZGVsXCI6IFwib3BlbmFpL2NsaXAtdml0LWJhc2UtcGF0Y2gzMlwiLFxuICAgICAgICAgICAgXCJtb2RlbFwiOiBcIlhlbm92YS9jbGlwLXZpdC1iYXNlLXBhdGNoMzJcIixcbiAgICAgICAgfSxcbiAgICAgICAgXCJ0eXBlXCI6IFwibXVsdGltb2RhbFwiLFxuICAgIH0sXG5cbiAgICBcIm9iamVjdC1kZXRlY3Rpb25cIjoge1xuICAgICAgICAvLyBubyB0b2tlbml6ZXJcbiAgICAgICAgXCJwaXBlbGluZVwiOiBPYmplY3REZXRlY3Rpb25QaXBlbGluZSxcbiAgICAgICAgXCJtb2RlbFwiOiBBdXRvTW9kZWxGb3JPYmplY3REZXRlY3Rpb24sXG4gICAgICAgIFwicHJvY2Vzc29yXCI6IEF1dG9Qcm9jZXNzb3IsXG4gICAgICAgIFwiZGVmYXVsdFwiOiB7XG4gICAgICAgICAgICAvLyBUT0RPOiByZXBsYWNlIHdpdGggb3JpZ2luYWxcbiAgICAgICAgICAgIC8vIFwibW9kZWxcIjogXCJmYWNlYm9vay9kZXRyLXJlc25ldC01MFwiLFxuICAgICAgICAgICAgXCJtb2RlbFwiOiBcIlhlbm92YS9kZXRyLXJlc25ldC01MFwiLFxuICAgICAgICB9LFxuICAgICAgICBcInR5cGVcIjogXCJtdWx0aW1vZGFsXCIsXG4gICAgfSxcblxuICAgIC8vIFRoaXMgdGFzayBzZXJ2ZXMgYXMgYSB1c2VmdWwgaW50ZXJmYWNlIGZvciBkZWFsaW5nIHdpdGggc2VudGVuY2UtdHJhbnNmb3JtZXJzIChodHRwczovL2h1Z2dpbmdmYWNlLmNvL3NlbnRlbmNlLXRyYW5zZm9ybWVycykuXG4gICAgXCJmZWF0dXJlLWV4dHJhY3Rpb25cIjoge1xuICAgICAgICBcInRva2VuaXplclwiOiBBdXRvVG9rZW5pemVyLFxuICAgICAgICBcInBpcGVsaW5lXCI6IEZlYXR1cmVFeHRyYWN0aW9uUGlwZWxpbmUsXG4gICAgICAgIFwibW9kZWxcIjogQXV0b01vZGVsLFxuICAgICAgICBcImRlZmF1bHRcIjoge1xuICAgICAgICAgICAgLy8gVE9ETzogcmVwbGFjZSB3aXRoIG9yaWdpbmFsXG4gICAgICAgICAgICAvLyBcIm1vZGVsXCI6IFwic2VudGVuY2UtdHJhbnNmb3JtZXJzL2FsbC1NaW5pTE0tTDYtdjJcIixcbiAgICAgICAgICAgIFwibW9kZWxcIjogXCJYZW5vdmEvYWxsLU1pbmlMTS1MNi12MlwiLFxuICAgICAgICB9LFxuICAgICAgICBcInR5cGVcIjogXCJ0ZXh0XCIsXG4gICAgfSxcbn1cblxuXG5jb25zdCBUQVNLX0FMSUFTRVMgPSB7XG4gICAgXCJzZW50aW1lbnQtYW5hbHlzaXNcIjogXCJ0ZXh0LWNsYXNzaWZpY2F0aW9uXCIsXG4gICAgXCJuZXJcIjogXCJ0b2tlbi1jbGFzc2lmaWNhdGlvblwiLFxuICAgIFwidnFhXCI6IFwidmlzdWFsLXF1ZXN0aW9uLWFuc3dlcmluZ1wiLFxuICAgIFwiYXNyXCI6IFwiYXV0b21hdGljLXNwZWVjaC1yZWNvZ25pdGlvblwiLFxuXG4gICAgLy8gQWRkIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuICAgIFwiZW1iZWRkaW5nc1wiOiBcImZlYXR1cmUtZXh0cmFjdGlvblwiLFxufVxuXG4vKipcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJy4vdXRpbHMvaHViLmpzJykuUHJldHJhaW5lZE9wdGlvbnN9IFByZXRyYWluZWRPcHRpb25zXG4gKi9cblxuLyoqXG4gKiBVdGlsaXR5IGZhY3RvcnkgbWV0aG9kIHRvIGJ1aWxkIGEgW2BQaXBlbGluZWBdIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdGFzayBUaGUgdGFzayBvZiB0aGUgcGlwZWxpbmUuXG4gKiBAcGFyYW0ge3N0cmluZ30gW21vZGVsPW51bGxdIFRoZSBuYW1lIG9mIHRoZSBwcmUtdHJhaW5lZCBtb2RlbCB0byB1c2UuIElmIG5vdCBzcGVjaWZpZWQsIHRoZSBkZWZhdWx0IG1vZGVsIGZvciB0aGUgdGFzayB3aWxsIGJlIHVzZWQuXG4gKiBAcGFyYW0ge1ByZXRyYWluZWRPcHRpb25zfSBbb3B0aW9uc10gT3B0aW9uYWwgcGFyYW1ldGVycyBmb3IgdGhlIHBpcGVsaW5lLlxuICogQHJldHVybnMge1Byb21pc2U8UGlwZWxpbmU+fSBBIFBpcGVsaW5lIG9iamVjdCBmb3IgdGhlIHNwZWNpZmllZCB0YXNrLlxuICogQHRocm93cyB7RXJyb3J9IElmIGFuIHVuc3VwcG9ydGVkIHBpcGVsaW5lIGlzIHJlcXVlc3RlZC5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHBpcGVsaW5lKFxuICAgIHRhc2ssXG4gICAgbW9kZWwgPSBudWxsLFxuICAgIHtcbiAgICAgICAgcXVhbnRpemVkID0gdHJ1ZSxcbiAgICAgICAgcHJvZ3Jlc3NfY2FsbGJhY2sgPSBudWxsLFxuICAgICAgICBjb25maWcgPSBudWxsLFxuICAgICAgICBjYWNoZV9kaXIgPSBudWxsLFxuICAgICAgICBsb2NhbF9maWxlc19vbmx5ID0gZmFsc2UsXG4gICAgICAgIHJldmlzaW9uID0gJ21haW4nLFxuICAgIH0gPSB7fVxuKSB7XG4gICAgLy8gSGVscGVyIG1ldGhvZCB0byBjb25zdHJ1Y3QgcGlwZWxpbmVcblxuICAgIC8vIEFwcGx5IGFsaWFzZXNcbiAgICB0YXNrID0gVEFTS19BTElBU0VTW3Rhc2tdID8/IHRhc2s7XG5cbiAgICAvLyBHZXQgcGlwZWxpbmUgaW5mb1xuICAgIGxldCBwaXBlbGluZUluZm8gPSBTVVBQT1JURURfVEFTS1NbdGFzay5zcGxpdCgnXycsIDEpWzBdXTtcbiAgICBpZiAoIXBpcGVsaW5lSW5mbykge1xuICAgICAgICB0aHJvdyBFcnJvcihgVW5zdXBwb3J0ZWQgcGlwZWxpbmU6ICR7dGFza30uIE11c3QgYmUgb25lIG9mIFske09iamVjdC5rZXlzKFNVUFBPUlRFRF9UQVNLUyl9XWApXG4gICAgfVxuXG4gICAgLy8gVXNlIG1vZGVsIGlmIHNwZWNpZmllZCwgb3RoZXJ3aXNlLCB1c2UgZGVmYXVsdFxuICAgIGlmICghbW9kZWwpIHtcbiAgICAgICAgbW9kZWwgPSBwaXBlbGluZUluZm8uZGVmYXVsdC5tb2RlbFxuICAgICAgICBjb25zb2xlLmxvZyhgTm8gbW9kZWwgc3BlY2lmaWVkLiBVc2luZyBkZWZhdWx0IG1vZGVsOiBcIiR7bW9kZWx9XCIuYCk7XG4gICAgfVxuXG4gICAgbGV0IHRva2VuaXplckNsYXNzID0gcGlwZWxpbmVJbmZvLnRva2VuaXplcjtcbiAgICBsZXQgbW9kZWxDbGFzcyA9IHBpcGVsaW5lSW5mby5tb2RlbDtcbiAgICBsZXQgcGlwZWxpbmVDbGFzcyA9IHBpcGVsaW5lSW5mby5waXBlbGluZTtcbiAgICBsZXQgcHJvY2Vzc29yQ2xhc3MgPSBwaXBlbGluZUluZm8ucHJvY2Vzc29yO1xuXG4gICAgbGV0IHByb21pc2VzID0gW107XG5cbiAgICBsZXQgcHJldHJhaW5lZE9wdGlvbnMgPSB7XG4gICAgICAgIHF1YW50aXplZCxcbiAgICAgICAgcHJvZ3Jlc3NfY2FsbGJhY2ssXG4gICAgICAgIGNvbmZpZyxcbiAgICAgICAgY2FjaGVfZGlyLFxuICAgICAgICBsb2NhbF9maWxlc19vbmx5LFxuICAgICAgICByZXZpc2lvbixcbiAgICB9XG4gICAgaWYgKHRva2VuaXplckNsYXNzKSB7XG4gICAgICAgIHByb21pc2VzLnB1c2goXG4gICAgICAgICAgICB0b2tlbml6ZXJDbGFzcy5mcm9tX3ByZXRyYWluZWQobW9kZWwsIHByZXRyYWluZWRPcHRpb25zKSxcbiAgICAgICAgKVxuICAgIH1cbiAgICBpZiAobW9kZWxDbGFzcykge1xuICAgICAgICBwcm9taXNlcy5wdXNoKFxuICAgICAgICAgICAgbW9kZWxDbGFzcy5mcm9tX3ByZXRyYWluZWQobW9kZWwsIHByZXRyYWluZWRPcHRpb25zKVxuICAgICAgICApXG4gICAgfVxuXG4gICAgaWYgKHByb2Nlc3NvckNsYXNzKSB7XG4gICAgICAgIHByb21pc2VzLnB1c2goXG4gICAgICAgICAgICBwcm9jZXNzb3JDbGFzcy5mcm9tX3ByZXRyYWluZWQobW9kZWwsIHByZXRyYWluZWRPcHRpb25zKVxuICAgICAgICApXG4gICAgfVxuXG4gICAgLy8gTG9hZCB0b2tlbml6ZXIgYW5kIG1vZGVsXG4gICAgbGV0IGl0ZW1zID0gYXdhaXQgUHJvbWlzZS5hbGwocHJvbWlzZXMpXG5cbiAgICBkaXNwYXRjaENhbGxiYWNrKHByb2dyZXNzX2NhbGxiYWNrLCB7XG4gICAgICAgICdzdGF0dXMnOiAncmVhZHknLFxuICAgICAgICAndGFzayc6IHRhc2ssXG4gICAgICAgICdtb2RlbCc6IG1vZGVsLFxuICAgIH0pO1xuXG4gICAgcmV0dXJuIG5ldyBwaXBlbGluZUNsYXNzKHRhc2ssIC4uLml0ZW1zKTtcblxufVxuXG4vKipcbiAqIENvbXB1dGUgdGhlIENhcnRlc2lhbiBwcm9kdWN0IG9mIGdpdmVuIGFycmF5c1xuICogQHBhcmFtIHsuLi5BcnJheX0gYSBBcnJheXMgdG8gY29tcHV0ZSB0aGUgcHJvZHVjdFxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBjb21wdXRlZCBDYXJ0ZXNpYW4gcHJvZHVjdCBhcyBhbiBhcnJheVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcHJvZHVjdCguLi5hKSB7XG4gICAgLy8gQ2FydGVzaWFuIHByb2R1Y3Qgb2YgaXRlbXNcbiAgICAvLyBBZGFwdGVkIGZyb20gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzQzMDUzODAzXG4gICAgcmV0dXJuIGEucmVkdWNlKChhLCBiKSA9PiBhLmZsYXRNYXAoZCA9PiBiLm1hcChlID0+IFtkLCBlXSkpKTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@xenova/transformers/src/pipelines.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@xenova/transformers/src/processors.js":
/*!*************************************************************!*\
  !*** ./node_modules/@xenova/transformers/src/processors.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AutoProcessor: function() { return /* binding */ AutoProcessor; },\n/* harmony export */   DetrFeatureExtractor: function() { return /* binding */ DetrFeatureExtractor; },\n/* harmony export */   FeatureExtractor: function() { return /* binding */ FeatureExtractor; },\n/* harmony export */   ImageFeatureExtractor: function() { return /* binding */ ImageFeatureExtractor; },\n/* harmony export */   MobileViTFeatureExtractor: function() { return /* binding */ MobileViTFeatureExtractor; },\n/* harmony export */   Processor: function() { return /* binding */ Processor; },\n/* harmony export */   SamImageProcessor: function() { return /* binding */ SamImageProcessor; },\n/* harmony export */   SamProcessor: function() { return /* binding */ SamProcessor; },\n/* harmony export */   ViTFeatureExtractor: function() { return /* binding */ ViTFeatureExtractor; },\n/* harmony export */   WhisperFeatureExtractor: function() { return /* binding */ WhisperFeatureExtractor; },\n/* harmony export */   WhisperProcessor: function() { return /* binding */ WhisperProcessor; }\n/* harmony export */ });\n/* harmony import */ var _utils_core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/core.js */ \"(app-pages-browser)/./node_modules/@xenova/transformers/src/utils/core.js\");\n/* harmony import */ var _utils_hub_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/hub.js */ \"(app-pages-browser)/./node_modules/@xenova/transformers/src/utils/hub.js\");\n/* harmony import */ var _utils_maths_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/maths.js */ \"(app-pages-browser)/./node_modules/@xenova/transformers/src/utils/maths.js\");\n/* harmony import */ var _utils_tensor_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/tensor.js */ \"(app-pages-browser)/./node_modules/@xenova/transformers/src/utils/tensor.js\");\n/* harmony import */ var _utils_image_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils/image.js */ \"(app-pages-browser)/./node_modules/@xenova/transformers/src/utils/image.js\");\n/* harmony import */ var _utils_audio_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./utils/audio.js */ \"(app-pages-browser)/./node_modules/@xenova/transformers/src/utils/audio.js\");\n\n/**\n * @file Processors are used to prepare non-textual inputs (e.g., image or audio) for a model.\n * \n * **Example:** Using a `WhisperProcessor` to prepare an audio input for a model.\n * ```javascript\n * import { AutoProcessor, read_audio } from '@xenova/transformers';\n *\n * let processor = await AutoProcessor.from_pretrained('openai/whisper-tiny.en');\n * let audio = await read_audio('https://huggingface.co/datasets/Narsil/asr_dummy/resolve/main/mlk.flac', 16000);\n * let { input_features } = await processor(audio);\n * // Tensor {\n * //   data: Float32Array(240000) [0.4752984642982483, 0.5597258806228638, 0.56434166431427, ...],\n * //   dims: [1, 80, 3000],\n * //   type: 'float32',\n * //   size: 240000,\n * // }\n * ```\n * \n * @module processors\n */\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * Base class for feature extractors.\n *\n * @extends Callable\n */\nclass FeatureExtractor extends _utils_core_js__WEBPACK_IMPORTED_MODULE_0__.Callable {\n    /**\n     * Constructs a new FeatureExtractor instance.\n     *\n     * @param {Object} config The configuration for the feature extractor.\n     */\n    constructor(config) {\n        super();\n        this.config = config\n    }\n}\n\n/**\n * Feature extractor for image models.\n *\n * @extends FeatureExtractor\n */\nclass ImageFeatureExtractor extends FeatureExtractor {\n\n    /**\n     * Constructs a new ImageFeatureExtractor instance.\n     *\n     * @param {Object} config The configuration for the feature extractor.\n     * @param {number[]} config.image_mean The mean values for image normalization.\n     * @param {number[]} config.image_std The standard deviation values for image normalization.\n     * @param {boolean} config.do_rescale Whether to rescale the image pixel values to the [0,1] range.\n     * @param {number} config.rescale_factor The factor to use for rescaling the image pixel values.\n     * @param {boolean} config.do_normalize Whether to normalize the image pixel values.\n     * @param {boolean} config.do_resize Whether to resize the image.\n     * @param {number} config.resample What method to use for resampling.\n     * @param {number} config.size The size to resize the image to.\n     */\n    constructor(config) {\n        super(config);\n\n        this.image_mean = this.config.image_mean;\n        this.image_std = this.config.image_std;\n\n        this.resample = this.config.resample ?? 2; // 2 => bilinear\n        this.do_rescale = this.config.do_rescale ?? true;\n        this.rescale_factor = this.config.rescale_factor ?? (1 / 255);\n        this.do_normalize = this.config.do_normalize;\n\n        this.do_resize = this.config.do_resize;\n        this.size = this.config.size;\n\n        this.do_center_crop = this.config.do_center_crop;\n        this.crop_size = this.config.crop_size;\n        this.do_convert_rgb = this.config.do_convert_rgb ?? true;\n\n        this.pad_size = this.config.pad_size;\n        this.do_pad = (this.config.do_pad ?? false) && this.pad_size;\n    }\n\n    /**\n     * Preprocesses the given image.\n     *\n     * @param {RawImage} image The image to preprocess.\n     * @returns {Promise<any>} The preprocessed image as a Tensor.\n     */\n    async preprocess(image) {\n\n        // First, convert image to RGB if specified in config.\n        if (this.do_convert_rgb) {\n            image = image.rgb();\n        }\n\n        const srcWidth = image.width;   // original width\n        const srcHeight = image.height; // original height\n\n        // Next, resize all images\n        if (this.do_resize) {\n            // TODO:\n            // For efficiency reasons, it might be best to merge the resize and center crop operations into one.\n\n            // `this.size` comes in many forms, so we need to handle them all here:\n            // 1. `this.size` is an integer, in which case we resize the image to be a square \n\n            let shortest_edge;\n            let longest_edge;\n\n            // Support both formats for backwards compatibility\n            if (Number.isInteger(this.size)) {\n                shortest_edge = this.size;\n                longest_edge = this.config.max_size ?? shortest_edge;\n\n            } else {\n                // Extract known properties from `this.size`\n                shortest_edge = this.size.shortest_edge;\n                longest_edge = this.size.longest_edge;\n            }\n\n            // If `longest_edge` and `shortest_edge` are set, maintain aspect ratio and resize to `shortest_edge`\n            // while keeping the largest dimension <= `longest_edge`\n            if (shortest_edge !== undefined || longest_edge !== undefined) {\n                // http://opensourcehacker.com/2011/12/01/calculate-aspect-ratio-conserving-resize-for-images-in-javascript/\n                // Try resize so that shortest edge is `this.shortest_edge` (target)\n                const shortResizeFactor = shortest_edge === undefined\n                    ? 1 // If `shortest_edge` is not set, don't upscale\n                    : Math.max(shortest_edge / srcWidth, shortest_edge / srcHeight);\n\n                const newWidth = srcWidth * shortResizeFactor;\n                const newHeight = srcHeight * shortResizeFactor;\n\n                // The new width and height might be greater than `this.longest_edge`, so\n                // we downscale again to ensure the largest dimension is `this.longest_edge` \n                const longResizeFactor = longest_edge === undefined\n                    ? 1 // If `longest_edge` is not set, don't downscale\n                    : Math.min(longest_edge / newWidth, longest_edge / newHeight);\n\n                // Perform resize\n                image = await image.resize(Math.floor(newWidth * longResizeFactor), Math.floor(newHeight * longResizeFactor), {\n                    resample: this.resample,\n                });\n\n            } else if (this.size.width !== undefined && this.size.height !== undefined) {\n                // If `width` and `height` are set, resize to those dimensions\n                image = await image.resize(this.size.width, this.size.height, {\n                    resample: this.resample,\n                });\n            } else {\n                throw new Error(`Could not resize image due to unsupported \\`this.size\\` option in config: ${JSON.stringify(this.size)}`);\n            }\n        }\n\n        if (this.do_center_crop) {\n\n            let crop_width;\n            let crop_height;\n            if (Number.isInteger(this.crop_size)) {\n                crop_width = this.crop_size;\n                crop_height = this.crop_size;\n            } else {\n                crop_width = this.crop_size.width;\n                crop_height = this.crop_size.height;\n            }\n\n            image = await image.center_crop(crop_width, crop_height);\n        }\n\n        let reshaped_input_size = [image.height, image.width];\n\n        // TODO is it okay to pad before rescaling/normalizing?\n        if (this.do_pad) {\n            let left = 0;\n            let right = this.pad_size.width - image.width;\n            let top = 0;\n            let bottom = this.pad_size.height - image.height;\n\n            image = await image.pad([left, right, top, bottom]);\n        }\n\n        const pixelData = Float32Array.from(image.data);\n\n        if (this.do_rescale) {\n            for (let i = 0; i < pixelData.length; ++i) {\n                pixelData[i] = this.rescale_factor * pixelData[i];\n            }\n        }\n\n        if (this.do_normalize) {\n            let image_mean = this.image_mean;\n            if (!Array.isArray(this.image_mean)) {\n                image_mean = new Array(image.channels).fill(image_mean);\n            }\n\n            let image_std = this.image_std;\n            if (!Array.isArray(this.image_std)) {\n                image_std = new Array(image.channels).fill(image_mean);\n            }\n\n            if (image_mean.length !== image.channels || image_std.length !== image.channels) {\n                throw new Error(`When set to arrays, the length of \\`image_mean\\` (${image_mean.length}) and \\`image_std\\` (${image_std.length}) must match the number of channels in the image (${image.channels}).`);\n            }\n\n            for (let i = 0; i < pixelData.length; i += image.channels) {\n                for (let j = 0; j < image.channels; ++j) {\n                    pixelData[i + j] = (pixelData[i + j] - this.image_mean[j]) / this.image_std[j];\n                }\n            }\n        }\n\n        // convert to channel dimension format:\n        let imgDims = [image.height, image.width, image.channels];\n        let img = new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_3__.Tensor('float32', pixelData, imgDims);\n        let transposed = (0,_utils_tensor_js__WEBPACK_IMPORTED_MODULE_3__.transpose)(img, [2, 0, 1]); // hwc -> chw\n\n        return {\n            original_size: [srcHeight, srcWidth],\n            reshaped_input_size: reshaped_input_size,\n            pixel_values: transposed,\n        }\n    }\n\n    /**\n     * Calls the feature extraction process on an array of image\n     * URLs, preprocesses each image, and concatenates the resulting\n     * features into a single Tensor.\n     * @param {any} images The URL(s) of the image(s) to extract features from.\n     * @returns {Promise<Object>} An object containing the concatenated pixel values (and other metadata) of the preprocessed images.\n     */\n    async _call(images) {\n        if (!Array.isArray(images)) {\n            images = [images];\n        }\n\n        let imageData = await Promise.all(images.map(x => this.preprocess(x)));\n\n        // TODO:\n\n        // Concatenate pixel values\n        // TEMP: Add batch dimension so that concat works\n        imageData.forEach(x => x.pixel_values.dims = [1, ...x.pixel_values.dims]);\n        let pixel_values = (0,_utils_tensor_js__WEBPACK_IMPORTED_MODULE_3__.cat)(imageData.map(x => x.pixel_values));\n\n        return {\n            pixel_values: pixel_values,\n\n            // Original sizes of images\n            original_sizes: imageData.map(x => x.original_size),\n\n            // Reshaped sizes of images, before padding or cropping\n            reshaped_input_sizes: imageData.map(x => x.reshaped_input_size),\n        }\n    }\n\n}\n\nclass ViTFeatureExtractor extends ImageFeatureExtractor { }\nclass MobileViTFeatureExtractor extends ImageFeatureExtractor { }\n\n/**\n * Detr Feature Extractor.\n *\n * @extends ImageFeatureExtractor\n */\nclass DetrFeatureExtractor extends ImageFeatureExtractor {\n    /**\n     * Calls the feature extraction process on an array of image\n     * URLs, preprocesses each image, and concatenates the resulting\n     * features into a single Tensor.\n     * @param {any} urls The URL(s) of the image(s) to extract features from.\n     * @returns {Promise<Object>} An object containing the concatenated pixel values of the preprocessed images.\n     */\n    async _call(urls) {\n        let result = await super._call(urls);\n\n        // TODO support differently-sized images, for now assume all images are the same size.\n        // TODO support different mask sizes (not just 64x64)\n        // Currently, just fill pixel mask with 1s\n        let maskSize = [result.pixel_values.dims[0], 64, 64];\n        result.pixel_mask = new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_3__.Tensor(\n            'int64',\n            // TODO: fix error below\n            new BigInt64Array(maskSize.reduce((a, b) => a * b)).fill(1n),\n            maskSize\n        );\n\n        return result;\n    }\n\n    /**\n     * @param {number[]} arr The URL(s) of the image(s) to extract features from.\n     * @returns {number[]} An object containing the concatenated pixel values of the preprocessed images.\n     */\n    center_to_corners_format([centerX, centerY, width, height]) {\n        return [\n            centerX - width / 2,\n            centerY - height / 2,\n            centerX + width / 2,\n            centerY + height / 2\n        ];\n    }\n\n    /**\n     * Post-processes the outputs of the model (for object detection).\n     * @param {Object} outputs The outputs of the model that must be post-processed\n     * @param {Tensor} outputs.logits The logits\n     * @param {Tensor} outputs.pred_boxes The predicted boxes.\n     * @return {Object[]} An array of objects containing the post-processed outputs.\n     */\n    post_process_object_detection(outputs, threshold = 0.5, target_sizes = null) {\n        const out_logits = outputs.logits;\n        const out_bbox = outputs.pred_boxes;\n        const [batch_size, num_boxes, num_classes] = out_logits.dims;\n\n        if (target_sizes !== null && target_sizes.length !== batch_size) {\n            throw Error(\"Make sure that you pass in as many target sizes as the batch dimension of the logits\")\n        }\n        let toReturn = [];\n        for (let i = 0; i < batch_size; ++i) {\n            let target_size = target_sizes !== null ? target_sizes[i] : null;\n            let info = {\n                boxes: [],\n                classes: [],\n                scores: []\n            }\n            let logits = out_logits[i];\n            let bbox = out_bbox[i];\n\n            for (let j = 0; j < num_boxes; ++j) {\n                let logit = logits[j];\n\n                // Get most probable class\n                let maxIndex = (0,_utils_maths_js__WEBPACK_IMPORTED_MODULE_2__.max)(logit.data)[1];\n\n                if (maxIndex === num_classes - 1) {\n                    // This is the background class, skip it\n                    continue;\n                }\n\n                // Compute softmax over classes\n                let probs = (0,_utils_maths_js__WEBPACK_IMPORTED_MODULE_2__.softmax)(logit.data);\n\n                let score = probs[maxIndex];\n                if (score > threshold) {\n                    // Some class has a high enough probability\n                    /** @type {number[]} */\n                    let box = bbox[j].data;\n\n                    // convert to [x0, y0, x1, y1] format\n                    box = this.center_to_corners_format(box)\n                    if (target_size !== null) {\n                        box = box.map((x, i) => x * target_size[(i + 1) % 2])\n                    }\n\n                    info.boxes.push(box);\n                    info.classes.push(maxIndex);\n                    info.scores.push(score);\n                }\n            }\n            toReturn.push(info);\n        }\n        return toReturn;\n    }\n\n    /**\n     * Binarize the given masks using `object_mask_threshold`, it returns the associated values of `masks`, `scores` and `labels`.\n     * @param {Tensor} class_logits The class logits.\n     * @param {Tensor} mask_logits The mask logits.\n     * @param {number} object_mask_threshold A number between 0 and 1 used to binarize the masks.\n     * @param {number} num_labels The number of labels.\n     * @returns {[Tensor[], number[], number[]]} The binarized masks, the scores, and the labels.\n     */\n    remove_low_and_no_objects(class_logits, mask_logits, object_mask_threshold, num_labels) {\n\n        let mask_probs_item = [];\n        let pred_scores_item = [];\n        let pred_labels_item = [];\n\n        for (let j = 0; j < class_logits.dims[0]; ++j) {\n            let cls = class_logits[j];\n            let mask = mask_logits[j];\n\n            let pred_label = (0,_utils_maths_js__WEBPACK_IMPORTED_MODULE_2__.max)(cls.data)[1];\n            if (pred_label === num_labels) {\n                // Is the background, so we ignore it\n                continue;\n            }\n\n            let scores = (0,_utils_maths_js__WEBPACK_IMPORTED_MODULE_2__.softmax)(cls.data);\n            let pred_score = scores[pred_label];\n            if (pred_score > object_mask_threshold) {\n                mask_probs_item.push(mask);\n                pred_scores_item.push(pred_score);\n                pred_labels_item.push(pred_label);\n            }\n        }\n\n        return [mask_probs_item, pred_scores_item, pred_labels_item];\n\n    }\n\n    /**\n     * Checks whether the segment is valid or not.\n     * @param {Int32Array} mask_labels Labels for each pixel in the mask.\n     * @param {Tensor[]} mask_probs Probabilities for each pixel in the masks.\n     * @param {number} k The class id of the segment.\n     * @param {number} mask_threshold The mask threshold.\n     * @param {number} overlap_mask_area_threshold The overlap mask area threshold.\n     * @returns {[boolean, number[]]} Whether the segment is valid or not, and the indices of the valid labels.\n     */\n    check_segment_validity(\n        mask_labels,\n        mask_probs,\n        k,\n        mask_threshold = 0.5,\n        overlap_mask_area_threshold = 0.8\n    ) {\n        // mask_k is a 1D array of indices, indicating where the mask is equal to k\n        let mask_k = [];\n        let mask_k_area = 0;\n        let original_area = 0;\n\n        // Compute the area of all the stuff in query k\n        for (let i = 0; i < mask_labels.length; ++i) {\n            if (mask_labels[i] === k) {\n                mask_k.push(i);\n                ++mask_k_area;\n            }\n\n            if (mask_probs[k].data[i] >= mask_threshold) {\n                ++original_area;\n            }\n        }\n        let mask_exists = mask_k_area > 0 && original_area > 0;\n\n        // Eliminate disconnected tiny segments\n        if (mask_exists) {\n            // Perform additional check\n            let area_ratio = mask_k_area / original_area;\n            mask_exists = area_ratio > overlap_mask_area_threshold;\n        }\n\n        return [mask_exists, mask_k]\n    }\n\n    /**\n     * Computes the segments.\n     * @param {Tensor[]} mask_probs The mask probabilities.\n     * @param {number[]} pred_scores The predicted scores.\n     * @param {number[]} pred_labels The predicted labels.\n     * @param {number} mask_threshold The mask threshold.\n     * @param {number} overlap_mask_area_threshold The overlap mask area threshold.\n     * @param {Set<number>} label_ids_to_fuse The label ids to fuse.\n     * @param {number[]} target_size The target size of the image.\n     * @returns {[Tensor, Array<{id: number, label_id: number, score: number}>]} The computed segments.\n     */\n    compute_segments(\n        mask_probs,\n        pred_scores,\n        pred_labels,\n        mask_threshold,\n        overlap_mask_area_threshold,\n        label_ids_to_fuse = null,\n        target_size = null,\n    ) {\n        let [height, width] = target_size ?? mask_probs[0].dims;\n\n        let segmentation = new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_3__.Tensor(\n            'int32',\n            new Int32Array(height * width),\n            [height, width]\n        );\n        let segments = [];\n\n        // 1. If target_size is not null, we need to resize the masks to the target size\n        if (target_size !== null) {\n            // resize the masks to the target size\n            for (let i = 0; i < mask_probs.length; ++i) {\n                mask_probs[i] = (0,_utils_tensor_js__WEBPACK_IMPORTED_MODULE_3__.interpolate)(mask_probs[i], target_size, 'bilinear', false);\n            }\n        }\n\n        // 2. Weigh each mask by its prediction score\n        // NOTE: `mask_probs` is updated in-place\n        // \n        // Temporary storage for the best label/scores for each pixel ([height, width]):\n        let mask_labels = new Int32Array(mask_probs[0].data.length);\n        let bestScores = new Float32Array(mask_probs[0].data.length);\n\n        for (let i = 0; i < mask_probs.length; ++i) {\n            let score = pred_scores[i];\n\n            for (let j = 0; j < mask_probs[i].data.length; ++j) {\n                mask_probs[i].data[j] *= score\n                if (mask_probs[i].data[j] > bestScores[j]) {\n                    mask_labels[j] = i;\n                    bestScores[j] = mask_probs[i].data[j];\n                }\n            }\n        }\n\n        let current_segment_id = 0;\n\n        // let stuff_memory_list = {}\n        for (let k = 0; k < pred_labels.length; ++k) {\n            let pred_class = pred_labels[k];\n\n            // TODO add `should_fuse`\n            // let should_fuse = pred_class in label_ids_to_fuse\n\n            // Check if mask exists and large enough to be a segment\n            let [mask_exists, mask_k] = this.check_segment_validity(\n                mask_labels,\n                mask_probs,\n                k,\n                mask_threshold,\n                overlap_mask_area_threshold\n            )\n\n            if (!mask_exists) {\n                // Nothing to see here\n                continue;\n            }\n\n            // TODO\n            // if (pred_class in stuff_memory_list) {\n            //     current_segment_id = stuff_memory_list[pred_class]\n            // } else {\n            //     current_segment_id += 1;\n            // }\n            ++current_segment_id;\n\n\n            // Add current object segment to final segmentation map\n            for (let index of mask_k) {\n                segmentation.data[index] = current_segment_id;\n            }\n\n            segments.push({\n                id: current_segment_id,\n                label_id: pred_class,\n                // was_fused: should_fuse, TODO\n                score: pred_scores[k],\n            })\n\n            // TODO\n            // if(should_fuse){\n            //     stuff_memory_list[pred_class] = current_segment_id\n            // }\n        }\n\n        return [segmentation, segments];\n    }\n\n    /**\n     * Post-process the model output to generate the final panoptic segmentation.\n     * @param {*} outputs The model output to post process\n     * @param {number} [threshold=0.5] The probability score threshold to keep predicted instance masks.\n     * @param {number} [mask_threshold=0.5] Threshold to use when turning the predicted masks into binary values.\n     * @param {number} [overlap_mask_area_threshold=0.8] The overlap mask area threshold to merge or discard small disconnected parts within each binary instance mask.\n     * @param {Set<number>} [label_ids_to_fuse=null] The labels in this state will have all their instances be fused together.\n     * @param {number[][]} [target_sizes=null] The target sizes to resize the masks to.\n     * @returns {Array<{ segmentation: Tensor, segments_info: Array<{id: number, label_id: number, score: number}>}>}\n     */\n    post_process_panoptic_segmentation(\n        outputs,\n        threshold = 0.5,\n        mask_threshold = 0.5,\n        overlap_mask_area_threshold = 0.8,\n        label_ids_to_fuse = null,\n        target_sizes = null,\n    ) {\n        if (label_ids_to_fuse === null) {\n            console.warn(\"`label_ids_to_fuse` unset. No instance will be fused.\")\n            label_ids_to_fuse = new Set();\n        }\n\n        const class_queries_logits = outputs.logits; // [batch_size, num_queries, num_classes+1]\n        const masks_queries_logits = outputs.pred_masks; // [batch_size, num_queries, height, width]\n\n        const mask_probs = masks_queries_logits.sigmoid()  // [batch_size, num_queries, height, width]\n\n        let [batch_size, num_queries, num_labels] = class_queries_logits.dims;\n        num_labels -= 1; // Remove last class (background)\n\n        if (target_sizes !== null && target_sizes.length !== batch_size) {\n            throw Error(\"Make sure that you pass in as many target sizes as the batch dimension of the logits\")\n        }\n\n        let toReturn = [];\n        for (let i = 0; i < batch_size; ++i) {\n            let target_size = target_sizes !== null ? target_sizes[i] : null;\n\n            let class_logits = class_queries_logits[i];\n            let mask_logits = mask_probs[i];\n\n            let [mask_probs_item, pred_scores_item, pred_labels_item] = this.remove_low_and_no_objects(class_logits, mask_logits, threshold, num_labels);\n\n            if (pred_labels_item.length === 0) {\n                // No mask found\n                let [height, width] = target_size ?? mask_logits.dims.slice(-2);\n\n                let segmentation = new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_3__.Tensor(\n                    'int32',\n                    new Int32Array(height * width).fill(-1),\n                    [height, width]\n                )\n                toReturn.push({\n                    segmentation: segmentation,\n                    segments_info: []\n                });\n                continue;\n            }\n\n\n            // Get segmentation map and segment information of batch item\n            let [segmentation, segments] = this.compute_segments(\n                mask_probs_item,\n                pred_scores_item,\n                pred_labels_item,\n                mask_threshold,\n                overlap_mask_area_threshold,\n                label_ids_to_fuse,\n                target_size,\n            )\n\n            toReturn.push({\n                segmentation: segmentation,\n                segments_info: segments\n            })\n        }\n\n        return toReturn;\n    }\n\n    post_process_instance_segmentation() {\n        // TODO\n        throw Error(\"Not implemented yet\");\n    }\n}\n\nclass SamImageProcessor extends ImageFeatureExtractor {\n    async _call(images, input_points) {\n        let {\n            pixel_values,\n            original_sizes,\n            reshaped_input_sizes,\n        } = await super._call(images);\n\n        let shape = (0,_utils_core_js__WEBPACK_IMPORTED_MODULE_0__.calculateDimensions)(input_points);\n\n        if (shape.length === 3) {\n            // Correct user's input\n            shape = [1, ...shape];\n            input_points = [input_points];\n        } else if (shape.length !== 4) {\n            throw Error(\"The input_points must be a 4D tensor of shape `batch_size`, `point_batch_size`, `nb_points_per_image`, `2`.\")\n        }\n\n        // Reshape input points\n        for (let i = 0; i < input_points.length; ++i) { // batch_size\n            let originalImageSize = original_sizes[i];\n            let reshapedImageSize = reshaped_input_sizes[i];\n\n            let resizeFactors = [\n                reshapedImageSize[0] / originalImageSize[0],\n                reshapedImageSize[1] / originalImageSize[1]\n            ]\n\n            for (let j = 0; j < input_points[i].length; ++j) { // point_batch_size\n                for (let k = 0; k < input_points[i][j].length; ++k) { // nb_points_per_image\n                    for (let w = 0; w < input_points[i][j][k].length; ++w) { // 2\n                        input_points[i][j][k][w] *= resizeFactors[w];\n                    }\n                }\n            }\n        }\n\n        let input_points_tensor = new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_3__.Tensor(\n            'int64',\n            BigInt64Array.from(input_points.flat(Infinity)\n                .map(x => BigInt(Math.round(x)))),\n            shape\n        )\n\n        // TODO: allowed to be floats?\n        // let input_points_tensor = new Tensor(\n        //     'float32',\n        //     Float32Array.from(input_points.flat(Infinity)),\n        //     shape\n        // )\n\n        return {\n            pixel_values,\n            original_sizes: original_sizes,\n            reshaped_input_sizes: reshaped_input_sizes,\n            input_points: input_points_tensor\n        }\n    }\n\n    /**\n     * Remove padding and upscale masks to the original image size.\n     * @param {Tensor} masks Batched masks from the mask_decoder in (batch_size, num_channels, height, width) format.\n     * @param {number[][]} original_sizes The original sizes of each image before it was resized to the model's expected input shape, in (height, width) format.\n     * @param {number[][]} reshaped_input_sizes The size of each image as it is fed to the model, in (height, width) format. Used to remove padding.\n     * @param {Object} options Optional parameters for post-processing.\n     * @param {number} [options.mask_threshold] The threshold to use for binarizing the masks.\n     * @param {boolean} [options.binarize] Whether to binarize the masks.\n     * @param {Object} [options.pad_size] The target size the images were padded to before being passed to the model. If `null`, the target size is assumed to be the processor's `pad_size`.\n     * @param {number} [options.pad_size.height] The height the images were padded to.\n     * @param {number} [options.pad_size.width] The width the images were padded to.\n     * @returns {Tensor[]} Batched masks in batch_size, num_channels, height, width) format, where (height, width) is given by original_size.\n     */\n    post_process_masks(masks, original_sizes, reshaped_input_sizes, {\n        mask_threshold = 0.0,\n        binarize = true,\n        pad_size = null,\n    } = {}) {\n        // masks: [1, 1, 3, 256, 256]\n\n        let output_masks = [];\n\n        pad_size = pad_size ?? this.pad_size;\n\n        let target_image_size = [pad_size.height, pad_size.width];\n\n        for (let i = 0; i < original_sizes.length; ++i) {\n            let original_size = original_sizes[i];\n            let reshaped_input_size = reshaped_input_sizes[i];\n\n            let mask = masks[i]; // [b, c, h, w]\n\n            // TODO: improve\n            let interpolated_masks = [];\n            for (let j = 0; j < mask.dims[0]; ++j) {\n                let m = mask[j]; // 3d tensor\n\n                // Upscale mask to padded size\n                let interpolated_mask = (0,_utils_tensor_js__WEBPACK_IMPORTED_MODULE_3__.interpolate)(m, target_image_size, 'bilinear', false);\n\n                // Crop mask\n                interpolated_mask = interpolated_mask.slice(null, [0, reshaped_input_size[0]], [0, reshaped_input_size[1]]);\n\n                // Downscale mask\n                interpolated_mask = (0,_utils_tensor_js__WEBPACK_IMPORTED_MODULE_3__.interpolate)(mask, original_size, 'bilinear', false);\n\n                if (binarize) {\n                    interpolated_mask = new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_3__.Tensor(\n                        'bool',\n                        Array.from(interpolated_mask.data).map(x => x > mask_threshold),\n                        interpolated_mask.dims\n                    )\n                }\n\n                // add back batch dim for concat\n                interpolated_mask.dims = [1, ...interpolated_mask.dims];\n\n                interpolated_masks.push(interpolated_mask);\n            }\n\n            let concatenated = (0,_utils_tensor_js__WEBPACK_IMPORTED_MODULE_3__.cat)(interpolated_masks);\n            output_masks.push(concatenated);\n        }\n\n        return output_masks;\n\n    }\n}\n\n\nclass WhisperFeatureExtractor extends FeatureExtractor {\n\n    constructor(config) {\n        super(config);\n\n        // Prefer given `mel_filters` from preprocessor_config.json, or calculate them if they don't exist.\n        this.config.mel_filters ??= (0,_utils_audio_js__WEBPACK_IMPORTED_MODULE_5__.getMelFilters)(this.config.sampling_rate, this.config.n_fft, this.config.feature_size);\n    }\n    /**\n     * Calculates the index offset for a given index and window size.\n     * @param {number} i The index.\n     * @param {number} w The window size.\n     * @returns {number} The index offset.\n     */\n    calcOffset(i, w) {\n        return Math.abs((i + w) % (2 * w) - w);\n    }\n\n    /**\n     * Pads an array with a reflected version of itself on both ends.\n     * @param {Float32Array} array The array to pad.\n     * @param {number} left The amount of padding to add to the left.\n     * @param {number} right The amount of padding to add to the right.\n     * @returns {Float32Array} The padded array.\n     */\n    padReflect(array, left, right) {\n        const padded = new Float32Array(array.length + left + right);\n        const w = array.length - 1;\n\n        for (let i = 0; i < array.length; ++i) {\n            padded[left + i] = array[i];\n        }\n\n        for (let i = 1; i <= left; ++i) {\n            padded[left - i] = array[this.calcOffset(i, w)];\n        }\n\n        for (let i = 1; i <= right; ++i) {\n            padded[w + left + i] = array[this.calcOffset(w - i, w)];\n        }\n\n        return padded;\n    }\n\n    /**\n     * Calculates the complex Short-Time Fourier Transform (STFT) of the given framed signal.\n     * \n     * @param {number[][]} frames A 2D array representing the signal frames.\n     * @param {number[]} window A 1D array representing the window to be applied to the frames.\n     * @returns {Object} An object with the following properties:\n     * - data: A 1D array representing the complex STFT of the signal.\n     * - dims: An array representing the dimensions of the STFT data, i.e. [num_frames, num_fft_bins].\n     */\n    stft(frames, window) {\n        // Calculates the complex Short-Time Fourier Transform (STFT) of the given framed signal.\n        // \n        // NOTE: Since the window width is not a power of 2, we must \n        // perform Fast Fourier Transform with chirp-z transform:\n        // https://math.stackexchange.com/questions/77118/non-power-of-2-ffts/77156#77156\n\n        // Helper variables\n        const fft_size = this.config.n_fft;\n        const a = 2 * (fft_size - 1);\n        const b = 2 * (2 * fft_size - 1);\n        const nextP2 = 2 ** (Math.ceil(Math.log2(b)))\n        const num_fft_bins = fft_size + 2;\n\n        // Preallocate array to store output\n        // double since we store complex numbers\n        const data = new Float32Array(num_fft_bins * frames.length);\n\n        // Define buffers\n        // Compute chirp for transform\n        const chirp = new Float32Array(b);\n        const ichirp = new Float32Array(nextP2);\n        const buffer1 = new Float32Array(nextP2);\n        const buffer2 = new Float32Array(nextP2);\n        const outBuffer = new Float32Array(nextP2);\n        const outBuffer2 = new Float32Array(nextP2);\n        const outBuffer3 = new Float32Array(nextP2);\n\n        // Compute complex exponentiation\n        const theta = -2 * Math.PI / fft_size;\n        const baseR = Math.cos(theta);\n        const baseI = Math.sin(theta);\n\n        // Precompute helper for chirp-z transform\n        for (let i = 0; i < b >> 1; ++i) {\n            // Compute complex power:\n            const e = (i + 1 - fft_size) ** 2 / 2.0;\n\n            // Compute the modulus and argument of the result\n            const result_mod = Math.sqrt(baseR ** 2 + baseI ** 2) ** e;\n            const result_arg = e * Math.atan2(baseI, baseR);\n\n            // Convert the result back to rectangular form\n            // and assign to chirp and ichirp\n            let i2 = 2 * i;\n            chirp[i2] = result_mod * Math.cos(result_arg);\n            chirp[i2 + 1] = result_mod * Math.sin(result_arg);\n\n            // conjugate\n            ichirp[i2] = chirp[i2];\n            ichirp[i2 + 1] = - chirp[i2 + 1];\n        }\n        const slicedChirp = chirp.subarray(a, b);\n\n        // create object to perform Fast Fourier Transforms\n        // with `nextP2` complex numbers\n        const f = new _utils_maths_js__WEBPACK_IMPORTED_MODULE_2__.FFT(nextP2 >> 1);\n        // TODO: decide between Float32Array and Float64Array\n        f.transform(outBuffer, ichirp);\n\n        for (let i = 0; i < frames.length; ++i) {\n            const frame = frames[i];\n\n            for (let j = 0; j < slicedChirp.length; j += 2) {\n                const j2 = j + 1\n                const j3 = j >> 1;\n\n                const a_real = frame[j3] * window[j3];\n                buffer1[j] = a_real * slicedChirp[j];\n                buffer1[j2] = a_real * slicedChirp[j2];\n            }\n            // TODO: decide between Float32Array and Float64Array\n            f.transform(outBuffer2, buffer1);\n\n            for (let j = 0; j < outBuffer.length; j += 2) {\n                const j2 = j + 1;\n\n                buffer2[j] = outBuffer2[j] * outBuffer[j] - outBuffer2[j2] * outBuffer[j2]\n                buffer2[j2] = outBuffer2[j] * outBuffer[j2] + outBuffer2[j2] * outBuffer[j]\n            }\n            // TODO: decide between Float32Array and Float64Array\n            f.inverseTransform(outBuffer3, buffer2)\n\n            const offset = i * num_fft_bins;\n            for (let j = 0; j < num_fft_bins; j += 2) {\n                const a_real = outBuffer3[j + a];\n                const a_imag = outBuffer3[j + a + 1];\n                const b_real = slicedChirp[j];\n                const b_imag = slicedChirp[j + 1];\n\n                // TODO write as transpose\n                const o1 = offset + j;\n                data[o1] = a_real * b_real - a_imag * b_imag\n                data[o1 + 1] = a_real * b_imag + a_imag * b_real\n            }\n        }\n\n        return {\n            data: data,\n            dims: [frames.length, num_fft_bins] // [3001, 402]\n        };\n    }\n\n    /**\n     * Creates an array of frames from a given waveform.\n     *\n     * @param {Float32Array} waveform The waveform to create frames from.\n     * @param {boolean} [center=true] Whether to center the frames on their corresponding positions in the waveform. Defaults to true.\n     * @returns {Array} An array of frames.\n     */\n    fram_wave(waveform, center = true) {\n        const frames = [];\n        const half_window = Math.floor((this.config.n_fft - 1) / 2) + 1;\n        const waveformLength = waveform.length;\n\n        for (let i = 0; i < waveformLength + 1; i += this.config.hop_length) {\n\n            let frame;\n            if (center) {\n\n                let frameStart = i > half_window ? i - half_window : 0;\n                let frameEnd =\n                    i < waveformLength - half_window\n                        ? i + half_window\n                        : waveformLength;\n\n                frame = waveform.subarray(frameStart, frameEnd)\n\n                if (frameStart === 0) {\n                    frame = this.padReflect(\n                        frame,\n                        -i + half_window,\n                        0\n                    )\n\n                } else if (frameEnd === waveformLength) {\n                    frame = this.padReflect(\n                        frame,\n                        0,\n                        i - waveformLength + half_window\n                    )\n                }\n\n            } else {\n                frame = new Float32Array(this.config.n_fft);\n                const frameArray = waveform.subarray(i, i + this.config.n_fft);\n\n                if (frameArray.length < this.config.n_fft) {\n                    frame.set(frameArray);\n                    frame.fill(0, frameArray.length, this.config.n_fft)\n                } else {\n                    frame = frameArray;\n                }\n\n            }\n            frames.push(frame);\n        }\n\n        return frames;\n    }\n\n    /**\n     * Generates a Hanning window of length M.\n     *\n     * @param {number} M The length of the Hanning window to generate.\n     * @returns {*} The generated Hanning window.\n     */\n    hanning(M) {\n        if (M < 1) {\n            return [];\n        }\n        if (M === 1) {\n            return [1];\n        }\n        const denom = M - 1;\n        const cos_vals = new Float32Array(denom);\n        for (let i = 0; i < denom; ++i) {\n            const n = 2 * i - M + 1;\n            cos_vals[i] = 0.5 + 0.5 * Math.cos(Math.PI * n / denom);\n        }\n        return cos_vals;\n    }\n\n    /**\n     * Computes the log-Mel spectrogram of the provided audio waveform.\n     * @param {Float32Array|Float64Array} waveform The audio waveform to process.\n     * @returns {{data: Float32Array, dims: number[]}} An object containing the log-Mel spectrogram data as a Float32Array and its dimensions as an array of numbers.\n     */\n    _extract_fbank_features(waveform) {\n        // Compute the log-Mel spectrogram of the provided audio\n\n        const buffer = new Float32Array(this.config.n_samples);\n        buffer.set(waveform)\n\n        const window = this.hanning(this.config.n_fft + 1)\n        const frames = this.fram_wave(buffer)\n\n        const stft = this.stft(frames, window)\n\n        const stftData = stft.data;\n        const d1 = stft.dims[0] - 1; // Ignore last row\n        const d2 = stft.dims[1] >> 1; // Only need to store real numbers now\n\n        // compute magnitudes\n        // NOTE: Unlike the original implementation, we do not\n        // transpose since we perform matrix multiplication later\n        const magnitudes = new Float32Array(d1 * d2);\n        for (let i = 0; i < d1; ++i) {\n            for (let j = 0; j < d2; ++j) {\n                // let outOffset = (j * d1 + i); // transpose\n                let outOffset = i * d2 + j;\n                let inOffset = outOffset << 1; // * 2 since complex\n                let magnitude = stftData[inOffset] ** 2 + stftData[inOffset + 1] ** 2\n                magnitudes[outOffset] = magnitude;\n            }\n        }\n\n        const mel_filters = this.config.mel_filters;\n        const num_mel_filters = mel_filters.length;\n\n        const mel_spec = new Float32Array(num_mel_filters * d1);\n        let mIndex = 0;\n\n        // Perform matrix muliplication:\n        // mel_spec = filters @ magnitudes\n        //  - filters.shape=(80, 201)\n        //  - magnitudes.shape=(201, 3000)\n        //  - mel_spec.shape=(80, 3000)\n        for (let i = 0; i < num_mel_filters; ++i) {\n            const mel_filter = mel_filters[i];\n\n            for (let j = 0; j < d1; ++j) {\n                let sum = 0;\n\n                // perform dot product\n                for (let k = 0; k < d2; ++k) {\n                    sum += mel_filter[k] * magnitudes[j * d2 + k];\n                }\n\n                mel_spec[mIndex++] = sum;\n            }\n        }\n\n        const a_min = 1e-10;\n        const log_spec = new Float32Array(mel_spec.length);\n\n        let maxLogSpec = 0;\n        for (let i = 0; i < mel_spec.length; ++i) {\n            const clipped = Math.max(a_min, mel_spec[i]);\n            const log10 = Math.log10(clipped);\n            log_spec[i] = log10;\n            maxLogSpec = Math.max(log10, maxLogSpec)\n        }\n\n        for (let i = 0; i < log_spec.length; ++i) {\n            log_spec[i] = Math.max(log_spec[i], maxLogSpec - 8);\n            log_spec[i] = (log_spec[i] + 4) / 4;\n        }\n\n        return {\n            data: log_spec,\n            dims: [num_mel_filters, d1]\n        };\n    }\n\n    /**\n     * Asynchronously extracts features from a given audio using the provided configuration.\n     * @param {Float32Array|Float64Array} audio The audio data as a Float32Array.\n     * @returns {Promise<{ input_features: Tensor }>} A Promise resolving to an object containing the extracted input features as a Tensor.\n    */\n    async _call(audio) {\n        if (!(audio instanceof Float32Array || audio instanceof Float64Array)) {\n            throw new Error(\n                // @ts-ignore\n                `WhisperFeatureExtractor expects input to be a Float32Array or a Float64Array, but got ${audio?.constructor?.name ?? typeof audio} instead.` +\n                `If using the feature extractor directly, remember to use \\`read_audio(url, sampling_rate)\\` to obtain the raw audio data of the file/url.`\n            )\n        }\n\n        if (audio.length > this.config.n_samples) {\n            console.warn(\n                \"Attempting to extract features for audio longer than 30 seconds. \" +\n                \"If using a pipeline to extract transcript from a long audio clip, \" +\n                \"remember to specify `chunk_length_s` and/or `stride_length_s`.\"\n            );\n        }\n        let waveform = audio.slice(0, this.config.n_samples);\n\n        let features = this._extract_fbank_features(waveform);\n\n        return {\n            input_features: new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_3__.Tensor('float32',\n                features.data,\n                [1, ...features.dims]\n            )\n        };\n    }\n}\n\n/**\n * Represents a Processor that extracts features from an input.\n * @extends Callable\n */\nclass Processor extends _utils_core_js__WEBPACK_IMPORTED_MODULE_0__.Callable {\n    /**\n     * Creates a new Processor with the given feature extractor.\n     * @param {FeatureExtractor} feature_extractor The function used to extract features from the input.\n     */\n    constructor(feature_extractor) {\n        super();\n        this.feature_extractor = feature_extractor;\n        // TODO use tokenizer here?\n    }\n\n    /**\n     * Calls the feature_extractor function with the given input.\n     * @param {any} input The input to extract features from.\n     * @returns {Promise<any>} A Promise that resolves with the extracted features.\n     */\n    async _call(input) {\n        return await this.feature_extractor(input);\n    }\n}\n\nclass SamProcessor extends Processor {\n\n    async _call(images, input_points) {\n        return await this.feature_extractor(images, input_points);\n    }\n\n    /**\n     * @borrows SamImageProcessor#post_process_masks as post_process_masks\n     */\n    post_process_masks(...args) {\n        // @ts-ignore\n        return this.feature_extractor.post_process_masks(...args);\n    }\n}\n\n/**\n * Represents a WhisperProcessor that extracts features from an audio input.\n * @extends Processor\n */\nclass WhisperProcessor extends Processor {\n    /**\n     * Calls the feature_extractor function with the given audio input.\n     * @param {any} audio The audio input to extract features from.\n     * @returns {Promise<any>} A Promise that resolves with the extracted features.\n     */\n    async _call(audio) {\n        return await this.feature_extractor(audio)\n    }\n}\n\n//////////////////////////////////////////////////\n/**\n * @typedef {import('./utils/hub.js').PretrainedOptions} PretrainedOptions\n */\n/**\n * Helper class which is used to instantiate pretrained processors with the `from_pretrained` function.\n * The chosen processor class is determined by the type specified in the processor config.\n * \n * **Example:** Load a processor using `from_pretrained`.\n * ```javascript\n * let processor = await AutoProcessor.from_pretrained('openai/whisper-tiny.en');\n * ```\n * \n * **Example:** Run an image through a processor.\n * ```javascript\n * let processor = await AutoProcessor.from_pretrained('Xenova/clip-vit-base-patch16');\n * let image = await RawImage.read('https://huggingface.co/datasets/Xenova/transformers.js-docs/resolve/main/football-match.jpg');\n * let image_inputs = await processor(image);\n * // {\n * //   \"pixel_values\": {\n * //     \"dims\": [ 1, 3, 224, 224 ],\n * //     \"type\": \"float32\",\n * //     \"data\": Float32Array [ -1.558687686920166, -1.558687686920166, -1.5440893173217773, ... ],\n * //     \"size\": 150528\n * //   },\n * //   \"original_sizes\": [\n * //     [ 533, 800 ]\n * //   ],\n * //   \"reshaped_input_sizes\": [\n * //     [ 224, 224 ]\n * //   ]\n * // }\n * ```\n */\nclass AutoProcessor {\n    static FEATURE_EXTRACTOR_CLASS_MAPPING = {\n        'WhisperFeatureExtractor': WhisperFeatureExtractor,\n        'ViTFeatureExtractor': ViTFeatureExtractor,\n        'MobileViTFeatureExtractor': MobileViTFeatureExtractor,\n        'DetrFeatureExtractor': DetrFeatureExtractor,\n\n        'SamImageProcessor': SamImageProcessor,\n    }\n\n    static PROCESSOR_CLASS_MAPPING = {\n        'WhisperProcessor': WhisperProcessor,\n        'SamProcessor': SamProcessor,\n    }\n\n    /**\n     * Instantiate one of the processor classes of the library from a pretrained model.\n     * \n     * The processor class to instantiate is selected based on the `feature_extractor_type` property of the config object\n     * (either passed as an argument or loaded from `pretrained_model_name_or_path` if possible)\n     * \n     * @param {string} pretrained_model_name_or_path The name or path of the pretrained model. Can be either:\n     * - A string, the *model id* of a pretrained processor hosted inside a model repo on huggingface.co.\n     *   Valid model ids can be located at the root-level, like `bert-base-uncased`, or namespaced under a\n     *   user or organization name, like `dbmdz/bert-base-german-cased`.\n     * - A path to a *directory* containing processor files, e.g., `./my_model_directory/`.\n     * @param {PretrainedOptions} options Additional options for loading the processor.\n     * \n     * @returns {Promise<Processor>} A new instance of the Processor class.\n     */\n    static async from_pretrained(pretrained_model_name_or_path, {\n        progress_callback = null,\n        config = null,\n        cache_dir = null,\n        local_files_only = false,\n        revision = 'main',\n    } = {}) {\n\n        let preprocessorConfig = config ?? await (0,_utils_hub_js__WEBPACK_IMPORTED_MODULE_1__.getModelJSON)(pretrained_model_name_or_path, 'preprocessor_config.json', true, {\n            progress_callback,\n            config,\n            cache_dir,\n            local_files_only,\n            revision,\n        })\n\n        // Determine feature extractor class\n        // TODO: Ensure backwards compatibility with old configs\n        let key = preprocessorConfig.feature_extractor_type ?? preprocessorConfig.image_processor_type;\n        let feature_extractor_class = this.FEATURE_EXTRACTOR_CLASS_MAPPING[key];\n\n        if (!feature_extractor_class) {\n            if (preprocessorConfig.size !== undefined) {\n                // Assume ImageFeatureExtractor\n                console.warn('Feature extractor type not specified, assuming ImageFeatureExtractor due to size parameter in config.');\n                feature_extractor_class = ImageFeatureExtractor;\n            } else {\n                throw new Error(`Unknown Feature Extractor type: ${preprocessorConfig.feature_extractor_type}`);\n            }\n        }\n\n        // If no associated processor class, use default\n        let processor_class = this.PROCESSOR_CLASS_MAPPING[preprocessorConfig.processor_class] ?? Processor;\n\n        // Instantiate processor and feature extractor\n        let feature_extractor = new feature_extractor_class(preprocessorConfig);\n        return new processor_class(feature_extractor);\n    }\n}\n//////////////////////////////////////////////////\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AeGVub3ZhL3RyYW5zZm9ybWVycy9zcmMvcHJvY2Vzc29ycy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSw0QkFBNEI7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsU0FBUyxpQkFBaUI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJeUI7O0FBSUQ7O0FBTUU7OztBQUc4Qzs7QUFFNUI7QUFDSzs7O0FBR2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTywrQkFBK0Isb0RBQVE7QUFDOUM7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087O0FBRVA7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsVUFBVTtBQUN6QixlQUFlLFVBQVU7QUFDekIsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFNBQVM7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCLGlCQUFpQixjQUFjO0FBQy9CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0NBQXdDO0FBQ3hDLHdDQUF3Qzs7QUFFeEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsY0FBYztBQUNkLDZHQUE2RywwQkFBMEI7QUFDdkk7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsNEJBQTRCLHNCQUFzQjtBQUNsRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFGQUFxRixrQkFBa0IsdUJBQXVCLGlCQUFpQixvREFBb0QsZUFBZTtBQUNsTjs7QUFFQSw0QkFBNEIsc0JBQXNCO0FBQ2xELGdDQUFnQyxvQkFBb0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNCQUFzQixvREFBTTtBQUM1Qix5QkFBeUIsMkRBQVMsa0JBQWtCOztBQUVwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEtBQUs7QUFDcEIsaUJBQWlCLGlCQUFpQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixxREFBRzs7QUFFOUI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVPO0FBQ0E7O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEtBQUs7QUFDcEIsaUJBQWlCLGlCQUFpQjtBQUNsQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0Msb0RBQU07QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCLGlCQUFpQixVQUFVO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZ0JBQWdCLFVBQVU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixnQkFBZ0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0QkFBNEIsZUFBZTtBQUMzQzs7QUFFQTtBQUNBLCtCQUErQixvREFBRzs7QUFFbEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0QkFBNEIsd0RBQU87O0FBRW5DO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixVQUFVO0FBQ3pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLGdDQUFnQztBQUNqRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0IsMEJBQTBCO0FBQ2xEO0FBQ0E7O0FBRUEsNkJBQTZCLG9EQUFHO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlCQUF5Qix3REFBTztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCLGVBQWUsVUFBVTtBQUN6QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIscUJBQXFCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdCQUF3Qix3QkFBd0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCLGVBQWUsVUFBVTtBQUN6QixlQUFlLFVBQVU7QUFDekIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLGFBQWE7QUFDNUIsZUFBZSxVQUFVO0FBQ3pCLGlCQUFpQixnQkFBZ0IsNENBQTRDLElBQUk7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwrQkFBK0Isb0RBQU07QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsdUJBQXVCO0FBQ25ELGdDQUFnQyw2REFBVztBQUMzQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0IsdUJBQXVCO0FBQy9DOztBQUVBLDRCQUE0QiwrQkFBK0I7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSx3QkFBd0Isd0JBQXdCO0FBQ2hEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsR0FBRztBQUNsQixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLGFBQWE7QUFDNUIsZUFBZSxZQUFZO0FBQzNCLGlCQUFpQixRQUFRLDRDQUE0Qyw0Q0FBNEMsRUFBRTtBQUNuSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxREFBcUQ7QUFDckQseURBQXlEOztBQUV6RDs7QUFFQTtBQUNBLHlCQUF5Qjs7QUFFekI7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCLGdCQUFnQjtBQUN4Qzs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx1Q0FBdUMsb0RBQU07QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVOztBQUVWLG9CQUFvQixtRUFBbUI7O0FBRXZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0IseUJBQXlCLE9BQU87QUFDeEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0QkFBNEIsNEJBQTRCLE9BQU87QUFDL0QsZ0NBQWdDLCtCQUErQixPQUFPO0FBQ3RFLG9DQUFvQyxrQ0FBa0MsT0FBTztBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNDQUFzQyxvREFBTTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsWUFBWTtBQUMzQixlQUFlLFlBQVk7QUFDM0IsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFNBQVM7QUFDeEIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLFVBQVU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sSUFBSTtBQUNWOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHdCQUF3QiwyQkFBMkI7QUFDbkQ7QUFDQTs7QUFFQSxpQ0FBaUM7O0FBRWpDO0FBQ0E7QUFDQSw0QkFBNEIsa0JBQWtCO0FBQzlDLGlDQUFpQzs7QUFFakM7QUFDQSx3Q0FBd0MsNkRBQVc7O0FBRW5EO0FBQ0E7O0FBRUE7QUFDQSxvQ0FBb0MsNkRBQVc7O0FBRS9DO0FBQ0EsNENBQTRDLG9EQUFNO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLCtCQUErQixxREFBRztBQUNsQztBQUNBOztBQUVBOztBQUVBO0FBQ0E7OztBQUdPOztBQUVQO0FBQ0E7O0FBRUE7QUFDQSxvQ0FBb0MsOERBQWE7QUFDakQ7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxjQUFjO0FBQzdCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLGNBQWM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCLGtCQUFrQjtBQUMxQztBQUNBOztBQUVBLHdCQUF3QixXQUFXO0FBQ25DO0FBQ0E7O0FBRUEsd0JBQXdCLFlBQVk7QUFDcEM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsWUFBWTtBQUMzQixlQUFlLFVBQVU7QUFDekIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCLFlBQVk7QUFDcEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQkFBc0IsZ0RBQUc7QUFDekI7QUFDQTs7QUFFQSx3QkFBd0IsbUJBQW1CO0FBQzNDOztBQUVBLDRCQUE0Qix3QkFBd0I7QUFDcEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNEJBQTRCLHNCQUFzQjtBQUNsRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCLGtCQUFrQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGNBQWM7QUFDN0IsZUFBZSxTQUFTO0FBQ3hCLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCLHdCQUF3Qjs7QUFFaEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsR0FBRztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixXQUFXO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsMkJBQTJCO0FBQzFDLGtCQUFrQixxQ0FBcUM7QUFDdkQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLHFDQUFxQztBQUNyQyxzQ0FBc0M7O0FBRXRDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEMsNEJBQTRCLFFBQVE7QUFDcEMsaURBQWlEO0FBQ2pEO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHFCQUFxQjtBQUM3Qzs7QUFFQSw0QkFBNEIsUUFBUTtBQUNwQzs7QUFFQTtBQUNBLGdDQUFnQyxRQUFRO0FBQ3hDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0IscUJBQXFCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCLHFCQUFxQjtBQUM3QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSwyQkFBMkI7QUFDMUMsaUJBQWlCLFVBQVUsd0JBQXdCLEdBQUc7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlHQUF5RywwQ0FBMEM7QUFDbko7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxnQ0FBZ0Msb0RBQU07QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sd0JBQXdCLG9EQUFRO0FBQ3ZDO0FBQ0E7QUFDQSxlQUFlLGtCQUFrQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsS0FBSztBQUNwQixpQkFBaUIsY0FBYztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPOztBQUVQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0EsZUFBZSxLQUFLO0FBQ3BCLGlCQUFpQixjQUFjO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsNENBQTRDO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG1CQUFtQjtBQUNsQztBQUNBLGlCQUFpQixvQkFBb0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLElBQUk7O0FBRVYsaURBQWlELDJEQUFZO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsbUVBQW1FLDBDQUEwQztBQUM3RztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AeGVub3ZhL3RyYW5zZm9ybWVycy9zcmMvcHJvY2Vzc29ycy5qcz9lNWNmIl0sInNvdXJjZXNDb250ZW50IjpbIlxuLyoqXG4gKiBAZmlsZSBQcm9jZXNzb3JzIGFyZSB1c2VkIHRvIHByZXBhcmUgbm9uLXRleHR1YWwgaW5wdXRzIChlLmcuLCBpbWFnZSBvciBhdWRpbykgZm9yIGEgbW9kZWwuXG4gKiBcbiAqICoqRXhhbXBsZToqKiBVc2luZyBhIGBXaGlzcGVyUHJvY2Vzc29yYCB0byBwcmVwYXJlIGFuIGF1ZGlvIGlucHV0IGZvciBhIG1vZGVsLlxuICogYGBgamF2YXNjcmlwdFxuICogaW1wb3J0IHsgQXV0b1Byb2Nlc3NvciwgcmVhZF9hdWRpbyB9IGZyb20gJ0B4ZW5vdmEvdHJhbnNmb3JtZXJzJztcbiAqXG4gKiBsZXQgcHJvY2Vzc29yID0gYXdhaXQgQXV0b1Byb2Nlc3Nvci5mcm9tX3ByZXRyYWluZWQoJ29wZW5haS93aGlzcGVyLXRpbnkuZW4nKTtcbiAqIGxldCBhdWRpbyA9IGF3YWl0IHJlYWRfYXVkaW8oJ2h0dHBzOi8vaHVnZ2luZ2ZhY2UuY28vZGF0YXNldHMvTmFyc2lsL2Fzcl9kdW1teS9yZXNvbHZlL21haW4vbWxrLmZsYWMnLCAxNjAwMCk7XG4gKiBsZXQgeyBpbnB1dF9mZWF0dXJlcyB9ID0gYXdhaXQgcHJvY2Vzc29yKGF1ZGlvKTtcbiAqIC8vIFRlbnNvciB7XG4gKiAvLyAgIGRhdGE6IEZsb2F0MzJBcnJheSgyNDAwMDApIFswLjQ3NTI5ODQ2NDI5ODI0ODMsIDAuNTU5NzI1ODgwNjIyODYzOCwgMC41NjQzNDE2NjQzMTQyNywgLi4uXSxcbiAqIC8vICAgZGltczogWzEsIDgwLCAzMDAwXSxcbiAqIC8vICAgdHlwZTogJ2Zsb2F0MzInLFxuICogLy8gICBzaXplOiAyNDAwMDAsXG4gKiAvLyB9XG4gKiBgYGBcbiAqIFxuICogQG1vZHVsZSBwcm9jZXNzb3JzXG4gKi9cbmltcG9ydCB7XG4gICAgQ2FsbGFibGUsXG4gICAgY2FsY3VsYXRlRGltZW5zaW9ucyxcbn0gZnJvbSAnLi91dGlscy9jb3JlLmpzJztcblxuaW1wb3J0IHtcbiAgICBnZXRNb2RlbEpTT04sXG59IGZyb20gJy4vdXRpbHMvaHViLmpzJztcblxuaW1wb3J0IHtcbiAgICBtYXgsXG4gICAgc29mdG1heCxcbiAgICBGRlRcbn0gZnJvbSAnLi91dGlscy9tYXRocy5qcyc7XG5cblxuaW1wb3J0IHsgVGVuc29yLCB0cmFuc3Bvc2UsIGNhdCwgaW50ZXJwb2xhdGUgfSBmcm9tICcuL3V0aWxzL3RlbnNvci5qcyc7XG5cbmltcG9ydCB7IFJhd0ltYWdlIH0gZnJvbSAnLi91dGlscy9pbWFnZS5qcyc7XG5pbXBvcnQgeyBnZXRNZWxGaWx0ZXJzIH0gZnJvbSAnLi91dGlscy9hdWRpby5qcyc7XG5cblxuLyoqXG4gKiBCYXNlIGNsYXNzIGZvciBmZWF0dXJlIGV4dHJhY3RvcnMuXG4gKlxuICogQGV4dGVuZHMgQ2FsbGFibGVcbiAqL1xuZXhwb3J0IGNsYXNzIEZlYXR1cmVFeHRyYWN0b3IgZXh0ZW5kcyBDYWxsYWJsZSB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0cyBhIG5ldyBGZWF0dXJlRXh0cmFjdG9yIGluc3RhbmNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBUaGUgY29uZmlndXJhdGlvbiBmb3IgdGhlIGZlYXR1cmUgZXh0cmFjdG9yLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZ1xuICAgIH1cbn1cblxuLyoqXG4gKiBGZWF0dXJlIGV4dHJhY3RvciBmb3IgaW1hZ2UgbW9kZWxzLlxuICpcbiAqIEBleHRlbmRzIEZlYXR1cmVFeHRyYWN0b3JcbiAqL1xuZXhwb3J0IGNsYXNzIEltYWdlRmVhdHVyZUV4dHJhY3RvciBleHRlbmRzIEZlYXR1cmVFeHRyYWN0b3Ige1xuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0cyBhIG5ldyBJbWFnZUZlYXR1cmVFeHRyYWN0b3IgaW5zdGFuY2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIFRoZSBjb25maWd1cmF0aW9uIGZvciB0aGUgZmVhdHVyZSBleHRyYWN0b3IuXG4gICAgICogQHBhcmFtIHtudW1iZXJbXX0gY29uZmlnLmltYWdlX21lYW4gVGhlIG1lYW4gdmFsdWVzIGZvciBpbWFnZSBub3JtYWxpemF0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyW119IGNvbmZpZy5pbWFnZV9zdGQgVGhlIHN0YW5kYXJkIGRldmlhdGlvbiB2YWx1ZXMgZm9yIGltYWdlIG5vcm1hbGl6YXRpb24uXG4gICAgICogQHBhcmFtIHtib29sZWFufSBjb25maWcuZG9fcmVzY2FsZSBXaGV0aGVyIHRvIHJlc2NhbGUgdGhlIGltYWdlIHBpeGVsIHZhbHVlcyB0byB0aGUgWzAsMV0gcmFuZ2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNvbmZpZy5yZXNjYWxlX2ZhY3RvciBUaGUgZmFjdG9yIHRvIHVzZSBmb3IgcmVzY2FsaW5nIHRoZSBpbWFnZSBwaXhlbCB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBjb25maWcuZG9fbm9ybWFsaXplIFdoZXRoZXIgdG8gbm9ybWFsaXplIHRoZSBpbWFnZSBwaXhlbCB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBjb25maWcuZG9fcmVzaXplIFdoZXRoZXIgdG8gcmVzaXplIHRoZSBpbWFnZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY29uZmlnLnJlc2FtcGxlIFdoYXQgbWV0aG9kIHRvIHVzZSBmb3IgcmVzYW1wbGluZy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY29uZmlnLnNpemUgVGhlIHNpemUgdG8gcmVzaXplIHRoZSBpbWFnZSB0by5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICAgICAgc3VwZXIoY29uZmlnKTtcblxuICAgICAgICB0aGlzLmltYWdlX21lYW4gPSB0aGlzLmNvbmZpZy5pbWFnZV9tZWFuO1xuICAgICAgICB0aGlzLmltYWdlX3N0ZCA9IHRoaXMuY29uZmlnLmltYWdlX3N0ZDtcblxuICAgICAgICB0aGlzLnJlc2FtcGxlID0gdGhpcy5jb25maWcucmVzYW1wbGUgPz8gMjsgLy8gMiA9PiBiaWxpbmVhclxuICAgICAgICB0aGlzLmRvX3Jlc2NhbGUgPSB0aGlzLmNvbmZpZy5kb19yZXNjYWxlID8/IHRydWU7XG4gICAgICAgIHRoaXMucmVzY2FsZV9mYWN0b3IgPSB0aGlzLmNvbmZpZy5yZXNjYWxlX2ZhY3RvciA/PyAoMSAvIDI1NSk7XG4gICAgICAgIHRoaXMuZG9fbm9ybWFsaXplID0gdGhpcy5jb25maWcuZG9fbm9ybWFsaXplO1xuXG4gICAgICAgIHRoaXMuZG9fcmVzaXplID0gdGhpcy5jb25maWcuZG9fcmVzaXplO1xuICAgICAgICB0aGlzLnNpemUgPSB0aGlzLmNvbmZpZy5zaXplO1xuXG4gICAgICAgIHRoaXMuZG9fY2VudGVyX2Nyb3AgPSB0aGlzLmNvbmZpZy5kb19jZW50ZXJfY3JvcDtcbiAgICAgICAgdGhpcy5jcm9wX3NpemUgPSB0aGlzLmNvbmZpZy5jcm9wX3NpemU7XG4gICAgICAgIHRoaXMuZG9fY29udmVydF9yZ2IgPSB0aGlzLmNvbmZpZy5kb19jb252ZXJ0X3JnYiA/PyB0cnVlO1xuXG4gICAgICAgIHRoaXMucGFkX3NpemUgPSB0aGlzLmNvbmZpZy5wYWRfc2l6ZTtcbiAgICAgICAgdGhpcy5kb19wYWQgPSAodGhpcy5jb25maWcuZG9fcGFkID8/IGZhbHNlKSAmJiB0aGlzLnBhZF9zaXplO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFByZXByb2Nlc3NlcyB0aGUgZ2l2ZW4gaW1hZ2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1Jhd0ltYWdlfSBpbWFnZSBUaGUgaW1hZ2UgdG8gcHJlcHJvY2Vzcy5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxhbnk+fSBUaGUgcHJlcHJvY2Vzc2VkIGltYWdlIGFzIGEgVGVuc29yLlxuICAgICAqL1xuICAgIGFzeW5jIHByZXByb2Nlc3MoaW1hZ2UpIHtcblxuICAgICAgICAvLyBGaXJzdCwgY29udmVydCBpbWFnZSB0byBSR0IgaWYgc3BlY2lmaWVkIGluIGNvbmZpZy5cbiAgICAgICAgaWYgKHRoaXMuZG9fY29udmVydF9yZ2IpIHtcbiAgICAgICAgICAgIGltYWdlID0gaW1hZ2UucmdiKCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBzcmNXaWR0aCA9IGltYWdlLndpZHRoOyAgIC8vIG9yaWdpbmFsIHdpZHRoXG4gICAgICAgIGNvbnN0IHNyY0hlaWdodCA9IGltYWdlLmhlaWdodDsgLy8gb3JpZ2luYWwgaGVpZ2h0XG5cbiAgICAgICAgLy8gTmV4dCwgcmVzaXplIGFsbCBpbWFnZXNcbiAgICAgICAgaWYgKHRoaXMuZG9fcmVzaXplKSB7XG4gICAgICAgICAgICAvLyBUT0RPOlxuICAgICAgICAgICAgLy8gRm9yIGVmZmljaWVuY3kgcmVhc29ucywgaXQgbWlnaHQgYmUgYmVzdCB0byBtZXJnZSB0aGUgcmVzaXplIGFuZCBjZW50ZXIgY3JvcCBvcGVyYXRpb25zIGludG8gb25lLlxuXG4gICAgICAgICAgICAvLyBgdGhpcy5zaXplYCBjb21lcyBpbiBtYW55IGZvcm1zLCBzbyB3ZSBuZWVkIHRvIGhhbmRsZSB0aGVtIGFsbCBoZXJlOlxuICAgICAgICAgICAgLy8gMS4gYHRoaXMuc2l6ZWAgaXMgYW4gaW50ZWdlciwgaW4gd2hpY2ggY2FzZSB3ZSByZXNpemUgdGhlIGltYWdlIHRvIGJlIGEgc3F1YXJlIFxuXG4gICAgICAgICAgICBsZXQgc2hvcnRlc3RfZWRnZTtcbiAgICAgICAgICAgIGxldCBsb25nZXN0X2VkZ2U7XG5cbiAgICAgICAgICAgIC8vIFN1cHBvcnQgYm90aCBmb3JtYXRzIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuICAgICAgICAgICAgaWYgKE51bWJlci5pc0ludGVnZXIodGhpcy5zaXplKSkge1xuICAgICAgICAgICAgICAgIHNob3J0ZXN0X2VkZ2UgPSB0aGlzLnNpemU7XG4gICAgICAgICAgICAgICAgbG9uZ2VzdF9lZGdlID0gdGhpcy5jb25maWcubWF4X3NpemUgPz8gc2hvcnRlc3RfZWRnZTtcblxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBFeHRyYWN0IGtub3duIHByb3BlcnRpZXMgZnJvbSBgdGhpcy5zaXplYFxuICAgICAgICAgICAgICAgIHNob3J0ZXN0X2VkZ2UgPSB0aGlzLnNpemUuc2hvcnRlc3RfZWRnZTtcbiAgICAgICAgICAgICAgICBsb25nZXN0X2VkZ2UgPSB0aGlzLnNpemUubG9uZ2VzdF9lZGdlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBJZiBgbG9uZ2VzdF9lZGdlYCBhbmQgYHNob3J0ZXN0X2VkZ2VgIGFyZSBzZXQsIG1haW50YWluIGFzcGVjdCByYXRpbyBhbmQgcmVzaXplIHRvIGBzaG9ydGVzdF9lZGdlYFxuICAgICAgICAgICAgLy8gd2hpbGUga2VlcGluZyB0aGUgbGFyZ2VzdCBkaW1lbnNpb24gPD0gYGxvbmdlc3RfZWRnZWBcbiAgICAgICAgICAgIGlmIChzaG9ydGVzdF9lZGdlICE9PSB1bmRlZmluZWQgfHwgbG9uZ2VzdF9lZGdlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBodHRwOi8vb3BlbnNvdXJjZWhhY2tlci5jb20vMjAxMS8xMi8wMS9jYWxjdWxhdGUtYXNwZWN0LXJhdGlvLWNvbnNlcnZpbmctcmVzaXplLWZvci1pbWFnZXMtaW4tamF2YXNjcmlwdC9cbiAgICAgICAgICAgICAgICAvLyBUcnkgcmVzaXplIHNvIHRoYXQgc2hvcnRlc3QgZWRnZSBpcyBgdGhpcy5zaG9ydGVzdF9lZGdlYCAodGFyZ2V0KVxuICAgICAgICAgICAgICAgIGNvbnN0IHNob3J0UmVzaXplRmFjdG9yID0gc2hvcnRlc3RfZWRnZSA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgID8gMSAvLyBJZiBgc2hvcnRlc3RfZWRnZWAgaXMgbm90IHNldCwgZG9uJ3QgdXBzY2FsZVxuICAgICAgICAgICAgICAgICAgICA6IE1hdGgubWF4KHNob3J0ZXN0X2VkZ2UgLyBzcmNXaWR0aCwgc2hvcnRlc3RfZWRnZSAvIHNyY0hlaWdodCk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBuZXdXaWR0aCA9IHNyY1dpZHRoICogc2hvcnRSZXNpemVGYWN0b3I7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3SGVpZ2h0ID0gc3JjSGVpZ2h0ICogc2hvcnRSZXNpemVGYWN0b3I7XG5cbiAgICAgICAgICAgICAgICAvLyBUaGUgbmV3IHdpZHRoIGFuZCBoZWlnaHQgbWlnaHQgYmUgZ3JlYXRlciB0aGFuIGB0aGlzLmxvbmdlc3RfZWRnZWAsIHNvXG4gICAgICAgICAgICAgICAgLy8gd2UgZG93bnNjYWxlIGFnYWluIHRvIGVuc3VyZSB0aGUgbGFyZ2VzdCBkaW1lbnNpb24gaXMgYHRoaXMubG9uZ2VzdF9lZGdlYCBcbiAgICAgICAgICAgICAgICBjb25zdCBsb25nUmVzaXplRmFjdG9yID0gbG9uZ2VzdF9lZGdlID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgPyAxIC8vIElmIGBsb25nZXN0X2VkZ2VgIGlzIG5vdCBzZXQsIGRvbid0IGRvd25zY2FsZVxuICAgICAgICAgICAgICAgICAgICA6IE1hdGgubWluKGxvbmdlc3RfZWRnZSAvIG5ld1dpZHRoLCBsb25nZXN0X2VkZ2UgLyBuZXdIZWlnaHQpO1xuXG4gICAgICAgICAgICAgICAgLy8gUGVyZm9ybSByZXNpemVcbiAgICAgICAgICAgICAgICBpbWFnZSA9IGF3YWl0IGltYWdlLnJlc2l6ZShNYXRoLmZsb29yKG5ld1dpZHRoICogbG9uZ1Jlc2l6ZUZhY3RvciksIE1hdGguZmxvb3IobmV3SGVpZ2h0ICogbG9uZ1Jlc2l6ZUZhY3RvciksIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzYW1wbGU6IHRoaXMucmVzYW1wbGUsXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5zaXplLndpZHRoICE9PSB1bmRlZmluZWQgJiYgdGhpcy5zaXplLmhlaWdodCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgYHdpZHRoYCBhbmQgYGhlaWdodGAgYXJlIHNldCwgcmVzaXplIHRvIHRob3NlIGRpbWVuc2lvbnNcbiAgICAgICAgICAgICAgICBpbWFnZSA9IGF3YWl0IGltYWdlLnJlc2l6ZSh0aGlzLnNpemUud2lkdGgsIHRoaXMuc2l6ZS5oZWlnaHQsIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzYW1wbGU6IHRoaXMucmVzYW1wbGUsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IHJlc2l6ZSBpbWFnZSBkdWUgdG8gdW5zdXBwb3J0ZWQgXFxgdGhpcy5zaXplXFxgIG9wdGlvbiBpbiBjb25maWc6ICR7SlNPTi5zdHJpbmdpZnkodGhpcy5zaXplKX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmRvX2NlbnRlcl9jcm9wKSB7XG5cbiAgICAgICAgICAgIGxldCBjcm9wX3dpZHRoO1xuICAgICAgICAgICAgbGV0IGNyb3BfaGVpZ2h0O1xuICAgICAgICAgICAgaWYgKE51bWJlci5pc0ludGVnZXIodGhpcy5jcm9wX3NpemUpKSB7XG4gICAgICAgICAgICAgICAgY3JvcF93aWR0aCA9IHRoaXMuY3JvcF9zaXplO1xuICAgICAgICAgICAgICAgIGNyb3BfaGVpZ2h0ID0gdGhpcy5jcm9wX3NpemU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNyb3Bfd2lkdGggPSB0aGlzLmNyb3Bfc2l6ZS53aWR0aDtcbiAgICAgICAgICAgICAgICBjcm9wX2hlaWdodCA9IHRoaXMuY3JvcF9zaXplLmhlaWdodDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaW1hZ2UgPSBhd2FpdCBpbWFnZS5jZW50ZXJfY3JvcChjcm9wX3dpZHRoLCBjcm9wX2hlaWdodCk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgcmVzaGFwZWRfaW5wdXRfc2l6ZSA9IFtpbWFnZS5oZWlnaHQsIGltYWdlLndpZHRoXTtcblxuICAgICAgICAvLyBUT0RPIGlzIGl0IG9rYXkgdG8gcGFkIGJlZm9yZSByZXNjYWxpbmcvbm9ybWFsaXppbmc/XG4gICAgICAgIGlmICh0aGlzLmRvX3BhZCkge1xuICAgICAgICAgICAgbGV0IGxlZnQgPSAwO1xuICAgICAgICAgICAgbGV0IHJpZ2h0ID0gdGhpcy5wYWRfc2l6ZS53aWR0aCAtIGltYWdlLndpZHRoO1xuICAgICAgICAgICAgbGV0IHRvcCA9IDA7XG4gICAgICAgICAgICBsZXQgYm90dG9tID0gdGhpcy5wYWRfc2l6ZS5oZWlnaHQgLSBpbWFnZS5oZWlnaHQ7XG5cbiAgICAgICAgICAgIGltYWdlID0gYXdhaXQgaW1hZ2UucGFkKFtsZWZ0LCByaWdodCwgdG9wLCBib3R0b21dKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHBpeGVsRGF0YSA9IEZsb2F0MzJBcnJheS5mcm9tKGltYWdlLmRhdGEpO1xuXG4gICAgICAgIGlmICh0aGlzLmRvX3Jlc2NhbGUpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGl4ZWxEYXRhLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgcGl4ZWxEYXRhW2ldID0gdGhpcy5yZXNjYWxlX2ZhY3RvciAqIHBpeGVsRGF0YVtpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmRvX25vcm1hbGl6ZSkge1xuICAgICAgICAgICAgbGV0IGltYWdlX21lYW4gPSB0aGlzLmltYWdlX21lYW47XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodGhpcy5pbWFnZV9tZWFuKSkge1xuICAgICAgICAgICAgICAgIGltYWdlX21lYW4gPSBuZXcgQXJyYXkoaW1hZ2UuY2hhbm5lbHMpLmZpbGwoaW1hZ2VfbWVhbik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxldCBpbWFnZV9zdGQgPSB0aGlzLmltYWdlX3N0ZDtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh0aGlzLmltYWdlX3N0ZCkpIHtcbiAgICAgICAgICAgICAgICBpbWFnZV9zdGQgPSBuZXcgQXJyYXkoaW1hZ2UuY2hhbm5lbHMpLmZpbGwoaW1hZ2VfbWVhbik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChpbWFnZV9tZWFuLmxlbmd0aCAhPT0gaW1hZ2UuY2hhbm5lbHMgfHwgaW1hZ2Vfc3RkLmxlbmd0aCAhPT0gaW1hZ2UuY2hhbm5lbHMpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFdoZW4gc2V0IHRvIGFycmF5cywgdGhlIGxlbmd0aCBvZiBcXGBpbWFnZV9tZWFuXFxgICgke2ltYWdlX21lYW4ubGVuZ3RofSkgYW5kIFxcYGltYWdlX3N0ZFxcYCAoJHtpbWFnZV9zdGQubGVuZ3RofSkgbXVzdCBtYXRjaCB0aGUgbnVtYmVyIG9mIGNoYW5uZWxzIGluIHRoZSBpbWFnZSAoJHtpbWFnZS5jaGFubmVsc30pLmApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBpeGVsRGF0YS5sZW5ndGg7IGkgKz0gaW1hZ2UuY2hhbm5lbHMpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGltYWdlLmNoYW5uZWxzOyArK2opIHtcbiAgICAgICAgICAgICAgICAgICAgcGl4ZWxEYXRhW2kgKyBqXSA9IChwaXhlbERhdGFbaSArIGpdIC0gdGhpcy5pbWFnZV9tZWFuW2pdKSAvIHRoaXMuaW1hZ2Vfc3RkW2pdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNvbnZlcnQgdG8gY2hhbm5lbCBkaW1lbnNpb24gZm9ybWF0OlxuICAgICAgICBsZXQgaW1nRGltcyA9IFtpbWFnZS5oZWlnaHQsIGltYWdlLndpZHRoLCBpbWFnZS5jaGFubmVsc107XG4gICAgICAgIGxldCBpbWcgPSBuZXcgVGVuc29yKCdmbG9hdDMyJywgcGl4ZWxEYXRhLCBpbWdEaW1zKTtcbiAgICAgICAgbGV0IHRyYW5zcG9zZWQgPSB0cmFuc3Bvc2UoaW1nLCBbMiwgMCwgMV0pOyAvLyBod2MgLT4gY2h3XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG9yaWdpbmFsX3NpemU6IFtzcmNIZWlnaHQsIHNyY1dpZHRoXSxcbiAgICAgICAgICAgIHJlc2hhcGVkX2lucHV0X3NpemU6IHJlc2hhcGVkX2lucHV0X3NpemUsXG4gICAgICAgICAgICBwaXhlbF92YWx1ZXM6IHRyYW5zcG9zZWQsXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxscyB0aGUgZmVhdHVyZSBleHRyYWN0aW9uIHByb2Nlc3Mgb24gYW4gYXJyYXkgb2YgaW1hZ2VcbiAgICAgKiBVUkxzLCBwcmVwcm9jZXNzZXMgZWFjaCBpbWFnZSwgYW5kIGNvbmNhdGVuYXRlcyB0aGUgcmVzdWx0aW5nXG4gICAgICogZmVhdHVyZXMgaW50byBhIHNpbmdsZSBUZW5zb3IuXG4gICAgICogQHBhcmFtIHthbnl9IGltYWdlcyBUaGUgVVJMKHMpIG9mIHRoZSBpbWFnZShzKSB0byBleHRyYWN0IGZlYXR1cmVzIGZyb20uXG4gICAgICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0Pn0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGNvbmNhdGVuYXRlZCBwaXhlbCB2YWx1ZXMgKGFuZCBvdGhlciBtZXRhZGF0YSkgb2YgdGhlIHByZXByb2Nlc3NlZCBpbWFnZXMuXG4gICAgICovXG4gICAgYXN5bmMgX2NhbGwoaW1hZ2VzKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShpbWFnZXMpKSB7XG4gICAgICAgICAgICBpbWFnZXMgPSBbaW1hZ2VzXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBpbWFnZURhdGEgPSBhd2FpdCBQcm9taXNlLmFsbChpbWFnZXMubWFwKHggPT4gdGhpcy5wcmVwcm9jZXNzKHgpKSk7XG5cbiAgICAgICAgLy8gVE9ETzpcblxuICAgICAgICAvLyBDb25jYXRlbmF0ZSBwaXhlbCB2YWx1ZXNcbiAgICAgICAgLy8gVEVNUDogQWRkIGJhdGNoIGRpbWVuc2lvbiBzbyB0aGF0IGNvbmNhdCB3b3Jrc1xuICAgICAgICBpbWFnZURhdGEuZm9yRWFjaCh4ID0+IHgucGl4ZWxfdmFsdWVzLmRpbXMgPSBbMSwgLi4ueC5waXhlbF92YWx1ZXMuZGltc10pO1xuICAgICAgICBsZXQgcGl4ZWxfdmFsdWVzID0gY2F0KGltYWdlRGF0YS5tYXAoeCA9PiB4LnBpeGVsX3ZhbHVlcykpO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwaXhlbF92YWx1ZXM6IHBpeGVsX3ZhbHVlcyxcblxuICAgICAgICAgICAgLy8gT3JpZ2luYWwgc2l6ZXMgb2YgaW1hZ2VzXG4gICAgICAgICAgICBvcmlnaW5hbF9zaXplczogaW1hZ2VEYXRhLm1hcCh4ID0+IHgub3JpZ2luYWxfc2l6ZSksXG5cbiAgICAgICAgICAgIC8vIFJlc2hhcGVkIHNpemVzIG9mIGltYWdlcywgYmVmb3JlIHBhZGRpbmcgb3IgY3JvcHBpbmdcbiAgICAgICAgICAgIHJlc2hhcGVkX2lucHV0X3NpemVzOiBpbWFnZURhdGEubWFwKHggPT4geC5yZXNoYXBlZF9pbnB1dF9zaXplKSxcbiAgICAgICAgfVxuICAgIH1cblxufVxuXG5leHBvcnQgY2xhc3MgVmlURmVhdHVyZUV4dHJhY3RvciBleHRlbmRzIEltYWdlRmVhdHVyZUV4dHJhY3RvciB7IH1cbmV4cG9ydCBjbGFzcyBNb2JpbGVWaVRGZWF0dXJlRXh0cmFjdG9yIGV4dGVuZHMgSW1hZ2VGZWF0dXJlRXh0cmFjdG9yIHsgfVxuXG4vKipcbiAqIERldHIgRmVhdHVyZSBFeHRyYWN0b3IuXG4gKlxuICogQGV4dGVuZHMgSW1hZ2VGZWF0dXJlRXh0cmFjdG9yXG4gKi9cbmV4cG9ydCBjbGFzcyBEZXRyRmVhdHVyZUV4dHJhY3RvciBleHRlbmRzIEltYWdlRmVhdHVyZUV4dHJhY3RvciB7XG4gICAgLyoqXG4gICAgICogQ2FsbHMgdGhlIGZlYXR1cmUgZXh0cmFjdGlvbiBwcm9jZXNzIG9uIGFuIGFycmF5IG9mIGltYWdlXG4gICAgICogVVJMcywgcHJlcHJvY2Vzc2VzIGVhY2ggaW1hZ2UsIGFuZCBjb25jYXRlbmF0ZXMgdGhlIHJlc3VsdGluZ1xuICAgICAqIGZlYXR1cmVzIGludG8gYSBzaW5nbGUgVGVuc29yLlxuICAgICAqIEBwYXJhbSB7YW55fSB1cmxzIFRoZSBVUkwocykgb2YgdGhlIGltYWdlKHMpIHRvIGV4dHJhY3QgZmVhdHVyZXMgZnJvbS5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fSBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgY29uY2F0ZW5hdGVkIHBpeGVsIHZhbHVlcyBvZiB0aGUgcHJlcHJvY2Vzc2VkIGltYWdlcy5cbiAgICAgKi9cbiAgICBhc3luYyBfY2FsbCh1cmxzKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBhd2FpdCBzdXBlci5fY2FsbCh1cmxzKTtcblxuICAgICAgICAvLyBUT0RPIHN1cHBvcnQgZGlmZmVyZW50bHktc2l6ZWQgaW1hZ2VzLCBmb3Igbm93IGFzc3VtZSBhbGwgaW1hZ2VzIGFyZSB0aGUgc2FtZSBzaXplLlxuICAgICAgICAvLyBUT0RPIHN1cHBvcnQgZGlmZmVyZW50IG1hc2sgc2l6ZXMgKG5vdCBqdXN0IDY0eDY0KVxuICAgICAgICAvLyBDdXJyZW50bHksIGp1c3QgZmlsbCBwaXhlbCBtYXNrIHdpdGggMXNcbiAgICAgICAgbGV0IG1hc2tTaXplID0gW3Jlc3VsdC5waXhlbF92YWx1ZXMuZGltc1swXSwgNjQsIDY0XTtcbiAgICAgICAgcmVzdWx0LnBpeGVsX21hc2sgPSBuZXcgVGVuc29yKFxuICAgICAgICAgICAgJ2ludDY0JyxcbiAgICAgICAgICAgIC8vIFRPRE86IGZpeCBlcnJvciBiZWxvd1xuICAgICAgICAgICAgbmV3IEJpZ0ludDY0QXJyYXkobWFza1NpemUucmVkdWNlKChhLCBiKSA9PiBhICogYikpLmZpbGwoMW4pLFxuICAgICAgICAgICAgbWFza1NpemVcbiAgICAgICAgKTtcblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyW119IGFyciBUaGUgVVJMKHMpIG9mIHRoZSBpbWFnZShzKSB0byBleHRyYWN0IGZlYXR1cmVzIGZyb20uXG4gICAgICogQHJldHVybnMge251bWJlcltdfSBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgY29uY2F0ZW5hdGVkIHBpeGVsIHZhbHVlcyBvZiB0aGUgcHJlcHJvY2Vzc2VkIGltYWdlcy5cbiAgICAgKi9cbiAgICBjZW50ZXJfdG9fY29ybmVyc19mb3JtYXQoW2NlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHRdKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBjZW50ZXJYIC0gd2lkdGggLyAyLFxuICAgICAgICAgICAgY2VudGVyWSAtIGhlaWdodCAvIDIsXG4gICAgICAgICAgICBjZW50ZXJYICsgd2lkdGggLyAyLFxuICAgICAgICAgICAgY2VudGVyWSArIGhlaWdodCAvIDJcbiAgICAgICAgXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQb3N0LXByb2Nlc3NlcyB0aGUgb3V0cHV0cyBvZiB0aGUgbW9kZWwgKGZvciBvYmplY3QgZGV0ZWN0aW9uKS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3V0cHV0cyBUaGUgb3V0cHV0cyBvZiB0aGUgbW9kZWwgdGhhdCBtdXN0IGJlIHBvc3QtcHJvY2Vzc2VkXG4gICAgICogQHBhcmFtIHtUZW5zb3J9IG91dHB1dHMubG9naXRzIFRoZSBsb2dpdHNcbiAgICAgKiBAcGFyYW0ge1RlbnNvcn0gb3V0cHV0cy5wcmVkX2JveGVzIFRoZSBwcmVkaWN0ZWQgYm94ZXMuXG4gICAgICogQHJldHVybiB7T2JqZWN0W119IEFuIGFycmF5IG9mIG9iamVjdHMgY29udGFpbmluZyB0aGUgcG9zdC1wcm9jZXNzZWQgb3V0cHV0cy5cbiAgICAgKi9cbiAgICBwb3N0X3Byb2Nlc3Nfb2JqZWN0X2RldGVjdGlvbihvdXRwdXRzLCB0aHJlc2hvbGQgPSAwLjUsIHRhcmdldF9zaXplcyA9IG51bGwpIHtcbiAgICAgICAgY29uc3Qgb3V0X2xvZ2l0cyA9IG91dHB1dHMubG9naXRzO1xuICAgICAgICBjb25zdCBvdXRfYmJveCA9IG91dHB1dHMucHJlZF9ib3hlcztcbiAgICAgICAgY29uc3QgW2JhdGNoX3NpemUsIG51bV9ib3hlcywgbnVtX2NsYXNzZXNdID0gb3V0X2xvZ2l0cy5kaW1zO1xuXG4gICAgICAgIGlmICh0YXJnZXRfc2l6ZXMgIT09IG51bGwgJiYgdGFyZ2V0X3NpemVzLmxlbmd0aCAhPT0gYmF0Y2hfc2l6ZSkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJNYWtlIHN1cmUgdGhhdCB5b3UgcGFzcyBpbiBhcyBtYW55IHRhcmdldCBzaXplcyBhcyB0aGUgYmF0Y2ggZGltZW5zaW9uIG9mIHRoZSBsb2dpdHNcIilcbiAgICAgICAgfVxuICAgICAgICBsZXQgdG9SZXR1cm4gPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBiYXRjaF9zaXplOyArK2kpIHtcbiAgICAgICAgICAgIGxldCB0YXJnZXRfc2l6ZSA9IHRhcmdldF9zaXplcyAhPT0gbnVsbCA/IHRhcmdldF9zaXplc1tpXSA6IG51bGw7XG4gICAgICAgICAgICBsZXQgaW5mbyA9IHtcbiAgICAgICAgICAgICAgICBib3hlczogW10sXG4gICAgICAgICAgICAgICAgY2xhc3NlczogW10sXG4gICAgICAgICAgICAgICAgc2NvcmVzOiBbXVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGxvZ2l0cyA9IG91dF9sb2dpdHNbaV07XG4gICAgICAgICAgICBsZXQgYmJveCA9IG91dF9iYm94W2ldO1xuXG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG51bV9ib3hlczsgKytqKSB7XG4gICAgICAgICAgICAgICAgbGV0IGxvZ2l0ID0gbG9naXRzW2pdO1xuXG4gICAgICAgICAgICAgICAgLy8gR2V0IG1vc3QgcHJvYmFibGUgY2xhc3NcbiAgICAgICAgICAgICAgICBsZXQgbWF4SW5kZXggPSBtYXgobG9naXQuZGF0YSlbMV07XG5cbiAgICAgICAgICAgICAgICBpZiAobWF4SW5kZXggPT09IG51bV9jbGFzc2VzIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIHRoZSBiYWNrZ3JvdW5kIGNsYXNzLCBza2lwIGl0XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIENvbXB1dGUgc29mdG1heCBvdmVyIGNsYXNzZXNcbiAgICAgICAgICAgICAgICBsZXQgcHJvYnMgPSBzb2Z0bWF4KGxvZ2l0LmRhdGEpO1xuXG4gICAgICAgICAgICAgICAgbGV0IHNjb3JlID0gcHJvYnNbbWF4SW5kZXhdO1xuICAgICAgICAgICAgICAgIGlmIChzY29yZSA+IHRocmVzaG9sZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBTb21lIGNsYXNzIGhhcyBhIGhpZ2ggZW5vdWdoIHByb2JhYmlsaXR5XG4gICAgICAgICAgICAgICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyW119ICovXG4gICAgICAgICAgICAgICAgICAgIGxldCBib3ggPSBiYm94W2pdLmRhdGE7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gY29udmVydCB0byBbeDAsIHkwLCB4MSwgeTFdIGZvcm1hdFxuICAgICAgICAgICAgICAgICAgICBib3ggPSB0aGlzLmNlbnRlcl90b19jb3JuZXJzX2Zvcm1hdChib3gpXG4gICAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXRfc2l6ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYm94ID0gYm94Lm1hcCgoeCwgaSkgPT4geCAqIHRhcmdldF9zaXplWyhpICsgMSkgJSAyXSlcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGluZm8uYm94ZXMucHVzaChib3gpO1xuICAgICAgICAgICAgICAgICAgICBpbmZvLmNsYXNzZXMucHVzaChtYXhJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIGluZm8uc2NvcmVzLnB1c2goc2NvcmUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRvUmV0dXJuLnB1c2goaW5mbyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRvUmV0dXJuO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEJpbmFyaXplIHRoZSBnaXZlbiBtYXNrcyB1c2luZyBgb2JqZWN0X21hc2tfdGhyZXNob2xkYCwgaXQgcmV0dXJucyB0aGUgYXNzb2NpYXRlZCB2YWx1ZXMgb2YgYG1hc2tzYCwgYHNjb3Jlc2AgYW5kIGBsYWJlbHNgLlxuICAgICAqIEBwYXJhbSB7VGVuc29yfSBjbGFzc19sb2dpdHMgVGhlIGNsYXNzIGxvZ2l0cy5cbiAgICAgKiBAcGFyYW0ge1RlbnNvcn0gbWFza19sb2dpdHMgVGhlIG1hc2sgbG9naXRzLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvYmplY3RfbWFza190aHJlc2hvbGQgQSBudW1iZXIgYmV0d2VlbiAwIGFuZCAxIHVzZWQgdG8gYmluYXJpemUgdGhlIG1hc2tzLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBudW1fbGFiZWxzIFRoZSBudW1iZXIgb2YgbGFiZWxzLlxuICAgICAqIEByZXR1cm5zIHtbVGVuc29yW10sIG51bWJlcltdLCBudW1iZXJbXV19IFRoZSBiaW5hcml6ZWQgbWFza3MsIHRoZSBzY29yZXMsIGFuZCB0aGUgbGFiZWxzLlxuICAgICAqL1xuICAgIHJlbW92ZV9sb3dfYW5kX25vX29iamVjdHMoY2xhc3NfbG9naXRzLCBtYXNrX2xvZ2l0cywgb2JqZWN0X21hc2tfdGhyZXNob2xkLCBudW1fbGFiZWxzKSB7XG5cbiAgICAgICAgbGV0IG1hc2tfcHJvYnNfaXRlbSA9IFtdO1xuICAgICAgICBsZXQgcHJlZF9zY29yZXNfaXRlbSA9IFtdO1xuICAgICAgICBsZXQgcHJlZF9sYWJlbHNfaXRlbSA9IFtdO1xuXG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgY2xhc3NfbG9naXRzLmRpbXNbMF07ICsraikge1xuICAgICAgICAgICAgbGV0IGNscyA9IGNsYXNzX2xvZ2l0c1tqXTtcbiAgICAgICAgICAgIGxldCBtYXNrID0gbWFza19sb2dpdHNbal07XG5cbiAgICAgICAgICAgIGxldCBwcmVkX2xhYmVsID0gbWF4KGNscy5kYXRhKVsxXTtcbiAgICAgICAgICAgIGlmIChwcmVkX2xhYmVsID09PSBudW1fbGFiZWxzKSB7XG4gICAgICAgICAgICAgICAgLy8gSXMgdGhlIGJhY2tncm91bmQsIHNvIHdlIGlnbm9yZSBpdFxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQgc2NvcmVzID0gc29mdG1heChjbHMuZGF0YSk7XG4gICAgICAgICAgICBsZXQgcHJlZF9zY29yZSA9IHNjb3Jlc1twcmVkX2xhYmVsXTtcbiAgICAgICAgICAgIGlmIChwcmVkX3Njb3JlID4gb2JqZWN0X21hc2tfdGhyZXNob2xkKSB7XG4gICAgICAgICAgICAgICAgbWFza19wcm9ic19pdGVtLnB1c2gobWFzayk7XG4gICAgICAgICAgICAgICAgcHJlZF9zY29yZXNfaXRlbS5wdXNoKHByZWRfc2NvcmUpO1xuICAgICAgICAgICAgICAgIHByZWRfbGFiZWxzX2l0ZW0ucHVzaChwcmVkX2xhYmVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBbbWFza19wcm9ic19pdGVtLCBwcmVkX3Njb3Jlc19pdGVtLCBwcmVkX2xhYmVsc19pdGVtXTtcblxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBzZWdtZW50IGlzIHZhbGlkIG9yIG5vdC5cbiAgICAgKiBAcGFyYW0ge0ludDMyQXJyYXl9IG1hc2tfbGFiZWxzIExhYmVscyBmb3IgZWFjaCBwaXhlbCBpbiB0aGUgbWFzay5cbiAgICAgKiBAcGFyYW0ge1RlbnNvcltdfSBtYXNrX3Byb2JzIFByb2JhYmlsaXRpZXMgZm9yIGVhY2ggcGl4ZWwgaW4gdGhlIG1hc2tzLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBrIFRoZSBjbGFzcyBpZCBvZiB0aGUgc2VnbWVudC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbWFza190aHJlc2hvbGQgVGhlIG1hc2sgdGhyZXNob2xkLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvdmVybGFwX21hc2tfYXJlYV90aHJlc2hvbGQgVGhlIG92ZXJsYXAgbWFzayBhcmVhIHRocmVzaG9sZC5cbiAgICAgKiBAcmV0dXJucyB7W2Jvb2xlYW4sIG51bWJlcltdXX0gV2hldGhlciB0aGUgc2VnbWVudCBpcyB2YWxpZCBvciBub3QsIGFuZCB0aGUgaW5kaWNlcyBvZiB0aGUgdmFsaWQgbGFiZWxzLlxuICAgICAqL1xuICAgIGNoZWNrX3NlZ21lbnRfdmFsaWRpdHkoXG4gICAgICAgIG1hc2tfbGFiZWxzLFxuICAgICAgICBtYXNrX3Byb2JzLFxuICAgICAgICBrLFxuICAgICAgICBtYXNrX3RocmVzaG9sZCA9IDAuNSxcbiAgICAgICAgb3ZlcmxhcF9tYXNrX2FyZWFfdGhyZXNob2xkID0gMC44XG4gICAgKSB7XG4gICAgICAgIC8vIG1hc2tfayBpcyBhIDFEIGFycmF5IG9mIGluZGljZXMsIGluZGljYXRpbmcgd2hlcmUgdGhlIG1hc2sgaXMgZXF1YWwgdG8ga1xuICAgICAgICBsZXQgbWFza19rID0gW107XG4gICAgICAgIGxldCBtYXNrX2tfYXJlYSA9IDA7XG4gICAgICAgIGxldCBvcmlnaW5hbF9hcmVhID0gMDtcblxuICAgICAgICAvLyBDb21wdXRlIHRoZSBhcmVhIG9mIGFsbCB0aGUgc3R1ZmYgaW4gcXVlcnkga1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1hc2tfbGFiZWxzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBpZiAobWFza19sYWJlbHNbaV0gPT09IGspIHtcbiAgICAgICAgICAgICAgICBtYXNrX2sucHVzaChpKTtcbiAgICAgICAgICAgICAgICArK21hc2tfa19hcmVhO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobWFza19wcm9ic1trXS5kYXRhW2ldID49IG1hc2tfdGhyZXNob2xkKSB7XG4gICAgICAgICAgICAgICAgKytvcmlnaW5hbF9hcmVhO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBtYXNrX2V4aXN0cyA9IG1hc2tfa19hcmVhID4gMCAmJiBvcmlnaW5hbF9hcmVhID4gMDtcblxuICAgICAgICAvLyBFbGltaW5hdGUgZGlzY29ubmVjdGVkIHRpbnkgc2VnbWVudHNcbiAgICAgICAgaWYgKG1hc2tfZXhpc3RzKSB7XG4gICAgICAgICAgICAvLyBQZXJmb3JtIGFkZGl0aW9uYWwgY2hlY2tcbiAgICAgICAgICAgIGxldCBhcmVhX3JhdGlvID0gbWFza19rX2FyZWEgLyBvcmlnaW5hbF9hcmVhO1xuICAgICAgICAgICAgbWFza19leGlzdHMgPSBhcmVhX3JhdGlvID4gb3ZlcmxhcF9tYXNrX2FyZWFfdGhyZXNob2xkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFttYXNrX2V4aXN0cywgbWFza19rXVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIHRoZSBzZWdtZW50cy5cbiAgICAgKiBAcGFyYW0ge1RlbnNvcltdfSBtYXNrX3Byb2JzIFRoZSBtYXNrIHByb2JhYmlsaXRpZXMuXG4gICAgICogQHBhcmFtIHtudW1iZXJbXX0gcHJlZF9zY29yZXMgVGhlIHByZWRpY3RlZCBzY29yZXMuXG4gICAgICogQHBhcmFtIHtudW1iZXJbXX0gcHJlZF9sYWJlbHMgVGhlIHByZWRpY3RlZCBsYWJlbHMuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1hc2tfdGhyZXNob2xkIFRoZSBtYXNrIHRocmVzaG9sZC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb3ZlcmxhcF9tYXNrX2FyZWFfdGhyZXNob2xkIFRoZSBvdmVybGFwIG1hc2sgYXJlYSB0aHJlc2hvbGQuXG4gICAgICogQHBhcmFtIHtTZXQ8bnVtYmVyPn0gbGFiZWxfaWRzX3RvX2Z1c2UgVGhlIGxhYmVsIGlkcyB0byBmdXNlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyW119IHRhcmdldF9zaXplIFRoZSB0YXJnZXQgc2l6ZSBvZiB0aGUgaW1hZ2UuXG4gICAgICogQHJldHVybnMge1tUZW5zb3IsIEFycmF5PHtpZDogbnVtYmVyLCBsYWJlbF9pZDogbnVtYmVyLCBzY29yZTogbnVtYmVyfT5dfSBUaGUgY29tcHV0ZWQgc2VnbWVudHMuXG4gICAgICovXG4gICAgY29tcHV0ZV9zZWdtZW50cyhcbiAgICAgICAgbWFza19wcm9icyxcbiAgICAgICAgcHJlZF9zY29yZXMsXG4gICAgICAgIHByZWRfbGFiZWxzLFxuICAgICAgICBtYXNrX3RocmVzaG9sZCxcbiAgICAgICAgb3ZlcmxhcF9tYXNrX2FyZWFfdGhyZXNob2xkLFxuICAgICAgICBsYWJlbF9pZHNfdG9fZnVzZSA9IG51bGwsXG4gICAgICAgIHRhcmdldF9zaXplID0gbnVsbCxcbiAgICApIHtcbiAgICAgICAgbGV0IFtoZWlnaHQsIHdpZHRoXSA9IHRhcmdldF9zaXplID8/IG1hc2tfcHJvYnNbMF0uZGltcztcblxuICAgICAgICBsZXQgc2VnbWVudGF0aW9uID0gbmV3IFRlbnNvcihcbiAgICAgICAgICAgICdpbnQzMicsXG4gICAgICAgICAgICBuZXcgSW50MzJBcnJheShoZWlnaHQgKiB3aWR0aCksXG4gICAgICAgICAgICBbaGVpZ2h0LCB3aWR0aF1cbiAgICAgICAgKTtcbiAgICAgICAgbGV0IHNlZ21lbnRzID0gW107XG5cbiAgICAgICAgLy8gMS4gSWYgdGFyZ2V0X3NpemUgaXMgbm90IG51bGwsIHdlIG5lZWQgdG8gcmVzaXplIHRoZSBtYXNrcyB0byB0aGUgdGFyZ2V0IHNpemVcbiAgICAgICAgaWYgKHRhcmdldF9zaXplICE9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyByZXNpemUgdGhlIG1hc2tzIHRvIHRoZSB0YXJnZXQgc2l6ZVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXNrX3Byb2JzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgbWFza19wcm9ic1tpXSA9IGludGVycG9sYXRlKG1hc2tfcHJvYnNbaV0sIHRhcmdldF9zaXplLCAnYmlsaW5lYXInLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyAyLiBXZWlnaCBlYWNoIG1hc2sgYnkgaXRzIHByZWRpY3Rpb24gc2NvcmVcbiAgICAgICAgLy8gTk9URTogYG1hc2tfcHJvYnNgIGlzIHVwZGF0ZWQgaW4tcGxhY2VcbiAgICAgICAgLy8gXG4gICAgICAgIC8vIFRlbXBvcmFyeSBzdG9yYWdlIGZvciB0aGUgYmVzdCBsYWJlbC9zY29yZXMgZm9yIGVhY2ggcGl4ZWwgKFtoZWlnaHQsIHdpZHRoXSk6XG4gICAgICAgIGxldCBtYXNrX2xhYmVscyA9IG5ldyBJbnQzMkFycmF5KG1hc2tfcHJvYnNbMF0uZGF0YS5sZW5ndGgpO1xuICAgICAgICBsZXQgYmVzdFNjb3JlcyA9IG5ldyBGbG9hdDMyQXJyYXkobWFza19wcm9ic1swXS5kYXRhLmxlbmd0aCk7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXNrX3Byb2JzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBsZXQgc2NvcmUgPSBwcmVkX3Njb3Jlc1tpXTtcblxuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBtYXNrX3Byb2JzW2ldLmRhdGEubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICAgICAgICBtYXNrX3Byb2JzW2ldLmRhdGFbal0gKj0gc2NvcmVcbiAgICAgICAgICAgICAgICBpZiAobWFza19wcm9ic1tpXS5kYXRhW2pdID4gYmVzdFNjb3Jlc1tqXSkge1xuICAgICAgICAgICAgICAgICAgICBtYXNrX2xhYmVsc1tqXSA9IGk7XG4gICAgICAgICAgICAgICAgICAgIGJlc3RTY29yZXNbal0gPSBtYXNrX3Byb2JzW2ldLmRhdGFbal07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGN1cnJlbnRfc2VnbWVudF9pZCA9IDA7XG5cbiAgICAgICAgLy8gbGV0IHN0dWZmX21lbW9yeV9saXN0ID0ge31cbiAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCBwcmVkX2xhYmVscy5sZW5ndGg7ICsraykge1xuICAgICAgICAgICAgbGV0IHByZWRfY2xhc3MgPSBwcmVkX2xhYmVsc1trXTtcblxuICAgICAgICAgICAgLy8gVE9ETyBhZGQgYHNob3VsZF9mdXNlYFxuICAgICAgICAgICAgLy8gbGV0IHNob3VsZF9mdXNlID0gcHJlZF9jbGFzcyBpbiBsYWJlbF9pZHNfdG9fZnVzZVxuXG4gICAgICAgICAgICAvLyBDaGVjayBpZiBtYXNrIGV4aXN0cyBhbmQgbGFyZ2UgZW5vdWdoIHRvIGJlIGEgc2VnbWVudFxuICAgICAgICAgICAgbGV0IFttYXNrX2V4aXN0cywgbWFza19rXSA9IHRoaXMuY2hlY2tfc2VnbWVudF92YWxpZGl0eShcbiAgICAgICAgICAgICAgICBtYXNrX2xhYmVscyxcbiAgICAgICAgICAgICAgICBtYXNrX3Byb2JzLFxuICAgICAgICAgICAgICAgIGssXG4gICAgICAgICAgICAgICAgbWFza190aHJlc2hvbGQsXG4gICAgICAgICAgICAgICAgb3ZlcmxhcF9tYXNrX2FyZWFfdGhyZXNob2xkXG4gICAgICAgICAgICApXG5cbiAgICAgICAgICAgIGlmICghbWFza19leGlzdHMpIHtcbiAgICAgICAgICAgICAgICAvLyBOb3RoaW5nIHRvIHNlZSBoZXJlXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFRPRE9cbiAgICAgICAgICAgIC8vIGlmIChwcmVkX2NsYXNzIGluIHN0dWZmX21lbW9yeV9saXN0KSB7XG4gICAgICAgICAgICAvLyAgICAgY3VycmVudF9zZWdtZW50X2lkID0gc3R1ZmZfbWVtb3J5X2xpc3RbcHJlZF9jbGFzc11cbiAgICAgICAgICAgIC8vIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyAgICAgY3VycmVudF9zZWdtZW50X2lkICs9IDE7XG4gICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICArK2N1cnJlbnRfc2VnbWVudF9pZDtcblxuXG4gICAgICAgICAgICAvLyBBZGQgY3VycmVudCBvYmplY3Qgc2VnbWVudCB0byBmaW5hbCBzZWdtZW50YXRpb24gbWFwXG4gICAgICAgICAgICBmb3IgKGxldCBpbmRleCBvZiBtYXNrX2spIHtcbiAgICAgICAgICAgICAgICBzZWdtZW50YXRpb24uZGF0YVtpbmRleF0gPSBjdXJyZW50X3NlZ21lbnRfaWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNlZ21lbnRzLnB1c2goe1xuICAgICAgICAgICAgICAgIGlkOiBjdXJyZW50X3NlZ21lbnRfaWQsXG4gICAgICAgICAgICAgICAgbGFiZWxfaWQ6IHByZWRfY2xhc3MsXG4gICAgICAgICAgICAgICAgLy8gd2FzX2Z1c2VkOiBzaG91bGRfZnVzZSwgVE9ET1xuICAgICAgICAgICAgICAgIHNjb3JlOiBwcmVkX3Njb3Jlc1trXSxcbiAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgIC8vIFRPRE9cbiAgICAgICAgICAgIC8vIGlmKHNob3VsZF9mdXNlKXtcbiAgICAgICAgICAgIC8vICAgICBzdHVmZl9tZW1vcnlfbGlzdFtwcmVkX2NsYXNzXSA9IGN1cnJlbnRfc2VnbWVudF9pZFxuICAgICAgICAgICAgLy8gfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFtzZWdtZW50YXRpb24sIHNlZ21lbnRzXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQb3N0LXByb2Nlc3MgdGhlIG1vZGVsIG91dHB1dCB0byBnZW5lcmF0ZSB0aGUgZmluYWwgcGFub3B0aWMgc2VnbWVudGF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gb3V0cHV0cyBUaGUgbW9kZWwgb3V0cHV0IHRvIHBvc3QgcHJvY2Vzc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbdGhyZXNob2xkPTAuNV0gVGhlIHByb2JhYmlsaXR5IHNjb3JlIHRocmVzaG9sZCB0byBrZWVwIHByZWRpY3RlZCBpbnN0YW5jZSBtYXNrcy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW21hc2tfdGhyZXNob2xkPTAuNV0gVGhyZXNob2xkIHRvIHVzZSB3aGVuIHR1cm5pbmcgdGhlIHByZWRpY3RlZCBtYXNrcyBpbnRvIGJpbmFyeSB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvdmVybGFwX21hc2tfYXJlYV90aHJlc2hvbGQ9MC44XSBUaGUgb3ZlcmxhcCBtYXNrIGFyZWEgdGhyZXNob2xkIHRvIG1lcmdlIG9yIGRpc2NhcmQgc21hbGwgZGlzY29ubmVjdGVkIHBhcnRzIHdpdGhpbiBlYWNoIGJpbmFyeSBpbnN0YW5jZSBtYXNrLlxuICAgICAqIEBwYXJhbSB7U2V0PG51bWJlcj59IFtsYWJlbF9pZHNfdG9fZnVzZT1udWxsXSBUaGUgbGFiZWxzIGluIHRoaXMgc3RhdGUgd2lsbCBoYXZlIGFsbCB0aGVpciBpbnN0YW5jZXMgYmUgZnVzZWQgdG9nZXRoZXIuXG4gICAgICogQHBhcmFtIHtudW1iZXJbXVtdfSBbdGFyZ2V0X3NpemVzPW51bGxdIFRoZSB0YXJnZXQgc2l6ZXMgdG8gcmVzaXplIHRoZSBtYXNrcyB0by5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXk8eyBzZWdtZW50YXRpb246IFRlbnNvciwgc2VnbWVudHNfaW5mbzogQXJyYXk8e2lkOiBudW1iZXIsIGxhYmVsX2lkOiBudW1iZXIsIHNjb3JlOiBudW1iZXJ9Pn0+fVxuICAgICAqL1xuICAgIHBvc3RfcHJvY2Vzc19wYW5vcHRpY19zZWdtZW50YXRpb24oXG4gICAgICAgIG91dHB1dHMsXG4gICAgICAgIHRocmVzaG9sZCA9IDAuNSxcbiAgICAgICAgbWFza190aHJlc2hvbGQgPSAwLjUsXG4gICAgICAgIG92ZXJsYXBfbWFza19hcmVhX3RocmVzaG9sZCA9IDAuOCxcbiAgICAgICAgbGFiZWxfaWRzX3RvX2Z1c2UgPSBudWxsLFxuICAgICAgICB0YXJnZXRfc2l6ZXMgPSBudWxsLFxuICAgICkge1xuICAgICAgICBpZiAobGFiZWxfaWRzX3RvX2Z1c2UgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcImBsYWJlbF9pZHNfdG9fZnVzZWAgdW5zZXQuIE5vIGluc3RhbmNlIHdpbGwgYmUgZnVzZWQuXCIpXG4gICAgICAgICAgICBsYWJlbF9pZHNfdG9fZnVzZSA9IG5ldyBTZXQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGNsYXNzX3F1ZXJpZXNfbG9naXRzID0gb3V0cHV0cy5sb2dpdHM7IC8vIFtiYXRjaF9zaXplLCBudW1fcXVlcmllcywgbnVtX2NsYXNzZXMrMV1cbiAgICAgICAgY29uc3QgbWFza3NfcXVlcmllc19sb2dpdHMgPSBvdXRwdXRzLnByZWRfbWFza3M7IC8vIFtiYXRjaF9zaXplLCBudW1fcXVlcmllcywgaGVpZ2h0LCB3aWR0aF1cblxuICAgICAgICBjb25zdCBtYXNrX3Byb2JzID0gbWFza3NfcXVlcmllc19sb2dpdHMuc2lnbW9pZCgpICAvLyBbYmF0Y2hfc2l6ZSwgbnVtX3F1ZXJpZXMsIGhlaWdodCwgd2lkdGhdXG5cbiAgICAgICAgbGV0IFtiYXRjaF9zaXplLCBudW1fcXVlcmllcywgbnVtX2xhYmVsc10gPSBjbGFzc19xdWVyaWVzX2xvZ2l0cy5kaW1zO1xuICAgICAgICBudW1fbGFiZWxzIC09IDE7IC8vIFJlbW92ZSBsYXN0IGNsYXNzIChiYWNrZ3JvdW5kKVxuXG4gICAgICAgIGlmICh0YXJnZXRfc2l6ZXMgIT09IG51bGwgJiYgdGFyZ2V0X3NpemVzLmxlbmd0aCAhPT0gYmF0Y2hfc2l6ZSkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJNYWtlIHN1cmUgdGhhdCB5b3UgcGFzcyBpbiBhcyBtYW55IHRhcmdldCBzaXplcyBhcyB0aGUgYmF0Y2ggZGltZW5zaW9uIG9mIHRoZSBsb2dpdHNcIilcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCB0b1JldHVybiA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJhdGNoX3NpemU7ICsraSkge1xuICAgICAgICAgICAgbGV0IHRhcmdldF9zaXplID0gdGFyZ2V0X3NpemVzICE9PSBudWxsID8gdGFyZ2V0X3NpemVzW2ldIDogbnVsbDtcblxuICAgICAgICAgICAgbGV0IGNsYXNzX2xvZ2l0cyA9IGNsYXNzX3F1ZXJpZXNfbG9naXRzW2ldO1xuICAgICAgICAgICAgbGV0IG1hc2tfbG9naXRzID0gbWFza19wcm9ic1tpXTtcblxuICAgICAgICAgICAgbGV0IFttYXNrX3Byb2JzX2l0ZW0sIHByZWRfc2NvcmVzX2l0ZW0sIHByZWRfbGFiZWxzX2l0ZW1dID0gdGhpcy5yZW1vdmVfbG93X2FuZF9ub19vYmplY3RzKGNsYXNzX2xvZ2l0cywgbWFza19sb2dpdHMsIHRocmVzaG9sZCwgbnVtX2xhYmVscyk7XG5cbiAgICAgICAgICAgIGlmIChwcmVkX2xhYmVsc19pdGVtLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIC8vIE5vIG1hc2sgZm91bmRcbiAgICAgICAgICAgICAgICBsZXQgW2hlaWdodCwgd2lkdGhdID0gdGFyZ2V0X3NpemUgPz8gbWFza19sb2dpdHMuZGltcy5zbGljZSgtMik7XG5cbiAgICAgICAgICAgICAgICBsZXQgc2VnbWVudGF0aW9uID0gbmV3IFRlbnNvcihcbiAgICAgICAgICAgICAgICAgICAgJ2ludDMyJyxcbiAgICAgICAgICAgICAgICAgICAgbmV3IEludDMyQXJyYXkoaGVpZ2h0ICogd2lkdGgpLmZpbGwoLTEpLFxuICAgICAgICAgICAgICAgICAgICBbaGVpZ2h0LCB3aWR0aF1cbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgdG9SZXR1cm4ucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHNlZ21lbnRhdGlvbjogc2VnbWVudGF0aW9uLFxuICAgICAgICAgICAgICAgICAgICBzZWdtZW50c19pbmZvOiBbXVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG5cbiAgICAgICAgICAgIC8vIEdldCBzZWdtZW50YXRpb24gbWFwIGFuZCBzZWdtZW50IGluZm9ybWF0aW9uIG9mIGJhdGNoIGl0ZW1cbiAgICAgICAgICAgIGxldCBbc2VnbWVudGF0aW9uLCBzZWdtZW50c10gPSB0aGlzLmNvbXB1dGVfc2VnbWVudHMoXG4gICAgICAgICAgICAgICAgbWFza19wcm9ic19pdGVtLFxuICAgICAgICAgICAgICAgIHByZWRfc2NvcmVzX2l0ZW0sXG4gICAgICAgICAgICAgICAgcHJlZF9sYWJlbHNfaXRlbSxcbiAgICAgICAgICAgICAgICBtYXNrX3RocmVzaG9sZCxcbiAgICAgICAgICAgICAgICBvdmVybGFwX21hc2tfYXJlYV90aHJlc2hvbGQsXG4gICAgICAgICAgICAgICAgbGFiZWxfaWRzX3RvX2Z1c2UsXG4gICAgICAgICAgICAgICAgdGFyZ2V0X3NpemUsXG4gICAgICAgICAgICApXG5cbiAgICAgICAgICAgIHRvUmV0dXJuLnB1c2goe1xuICAgICAgICAgICAgICAgIHNlZ21lbnRhdGlvbjogc2VnbWVudGF0aW9uLFxuICAgICAgICAgICAgICAgIHNlZ21lbnRzX2luZm86IHNlZ21lbnRzXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRvUmV0dXJuO1xuICAgIH1cblxuICAgIHBvc3RfcHJvY2Vzc19pbnN0YW5jZV9zZWdtZW50YXRpb24oKSB7XG4gICAgICAgIC8vIFRPRE9cbiAgICAgICAgdGhyb3cgRXJyb3IoXCJOb3QgaW1wbGVtZW50ZWQgeWV0XCIpO1xuICAgIH1cbn1cblxuZXhwb3J0IGNsYXNzIFNhbUltYWdlUHJvY2Vzc29yIGV4dGVuZHMgSW1hZ2VGZWF0dXJlRXh0cmFjdG9yIHtcbiAgICBhc3luYyBfY2FsbChpbWFnZXMsIGlucHV0X3BvaW50cykge1xuICAgICAgICBsZXQge1xuICAgICAgICAgICAgcGl4ZWxfdmFsdWVzLFxuICAgICAgICAgICAgb3JpZ2luYWxfc2l6ZXMsXG4gICAgICAgICAgICByZXNoYXBlZF9pbnB1dF9zaXplcyxcbiAgICAgICAgfSA9IGF3YWl0IHN1cGVyLl9jYWxsKGltYWdlcyk7XG5cbiAgICAgICAgbGV0IHNoYXBlID0gY2FsY3VsYXRlRGltZW5zaW9ucyhpbnB1dF9wb2ludHMpO1xuXG4gICAgICAgIGlmIChzaGFwZS5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgICAgIC8vIENvcnJlY3QgdXNlcidzIGlucHV0XG4gICAgICAgICAgICBzaGFwZSA9IFsxLCAuLi5zaGFwZV07XG4gICAgICAgICAgICBpbnB1dF9wb2ludHMgPSBbaW5wdXRfcG9pbnRzXTtcbiAgICAgICAgfSBlbHNlIGlmIChzaGFwZS5sZW5ndGggIT09IDQpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKFwiVGhlIGlucHV0X3BvaW50cyBtdXN0IGJlIGEgNEQgdGVuc29yIG9mIHNoYXBlIGBiYXRjaF9zaXplYCwgYHBvaW50X2JhdGNoX3NpemVgLCBgbmJfcG9pbnRzX3Blcl9pbWFnZWAsIGAyYC5cIilcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJlc2hhcGUgaW5wdXQgcG9pbnRzXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5wdXRfcG9pbnRzLmxlbmd0aDsgKytpKSB7IC8vIGJhdGNoX3NpemVcbiAgICAgICAgICAgIGxldCBvcmlnaW5hbEltYWdlU2l6ZSA9IG9yaWdpbmFsX3NpemVzW2ldO1xuICAgICAgICAgICAgbGV0IHJlc2hhcGVkSW1hZ2VTaXplID0gcmVzaGFwZWRfaW5wdXRfc2l6ZXNbaV07XG5cbiAgICAgICAgICAgIGxldCByZXNpemVGYWN0b3JzID0gW1xuICAgICAgICAgICAgICAgIHJlc2hhcGVkSW1hZ2VTaXplWzBdIC8gb3JpZ2luYWxJbWFnZVNpemVbMF0sXG4gICAgICAgICAgICAgICAgcmVzaGFwZWRJbWFnZVNpemVbMV0gLyBvcmlnaW5hbEltYWdlU2l6ZVsxXVxuICAgICAgICAgICAgXVxuXG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGlucHV0X3BvaW50c1tpXS5sZW5ndGg7ICsraikgeyAvLyBwb2ludF9iYXRjaF9zaXplXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCBpbnB1dF9wb2ludHNbaV1bal0ubGVuZ3RoOyArK2spIHsgLy8gbmJfcG9pbnRzX3Blcl9pbWFnZVxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCB3ID0gMDsgdyA8IGlucHV0X3BvaW50c1tpXVtqXVtrXS5sZW5ndGg7ICsrdykgeyAvLyAyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnB1dF9wb2ludHNbaV1bal1ba11bd10gKj0gcmVzaXplRmFjdG9yc1t3XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBpbnB1dF9wb2ludHNfdGVuc29yID0gbmV3IFRlbnNvcihcbiAgICAgICAgICAgICdpbnQ2NCcsXG4gICAgICAgICAgICBCaWdJbnQ2NEFycmF5LmZyb20oaW5wdXRfcG9pbnRzLmZsYXQoSW5maW5pdHkpXG4gICAgICAgICAgICAgICAgLm1hcCh4ID0+IEJpZ0ludChNYXRoLnJvdW5kKHgpKSkpLFxuICAgICAgICAgICAgc2hhcGVcbiAgICAgICAgKVxuXG4gICAgICAgIC8vIFRPRE86IGFsbG93ZWQgdG8gYmUgZmxvYXRzP1xuICAgICAgICAvLyBsZXQgaW5wdXRfcG9pbnRzX3RlbnNvciA9IG5ldyBUZW5zb3IoXG4gICAgICAgIC8vICAgICAnZmxvYXQzMicsXG4gICAgICAgIC8vICAgICBGbG9hdDMyQXJyYXkuZnJvbShpbnB1dF9wb2ludHMuZmxhdChJbmZpbml0eSkpLFxuICAgICAgICAvLyAgICAgc2hhcGVcbiAgICAgICAgLy8gKVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwaXhlbF92YWx1ZXMsXG4gICAgICAgICAgICBvcmlnaW5hbF9zaXplczogb3JpZ2luYWxfc2l6ZXMsXG4gICAgICAgICAgICByZXNoYXBlZF9pbnB1dF9zaXplczogcmVzaGFwZWRfaW5wdXRfc2l6ZXMsXG4gICAgICAgICAgICBpbnB1dF9wb2ludHM6IGlucHV0X3BvaW50c190ZW5zb3JcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBwYWRkaW5nIGFuZCB1cHNjYWxlIG1hc2tzIHRvIHRoZSBvcmlnaW5hbCBpbWFnZSBzaXplLlxuICAgICAqIEBwYXJhbSB7VGVuc29yfSBtYXNrcyBCYXRjaGVkIG1hc2tzIGZyb20gdGhlIG1hc2tfZGVjb2RlciBpbiAoYmF0Y2hfc2l6ZSwgbnVtX2NoYW5uZWxzLCBoZWlnaHQsIHdpZHRoKSBmb3JtYXQuXG4gICAgICogQHBhcmFtIHtudW1iZXJbXVtdfSBvcmlnaW5hbF9zaXplcyBUaGUgb3JpZ2luYWwgc2l6ZXMgb2YgZWFjaCBpbWFnZSBiZWZvcmUgaXQgd2FzIHJlc2l6ZWQgdG8gdGhlIG1vZGVsJ3MgZXhwZWN0ZWQgaW5wdXQgc2hhcGUsIGluIChoZWlnaHQsIHdpZHRoKSBmb3JtYXQuXG4gICAgICogQHBhcmFtIHtudW1iZXJbXVtdfSByZXNoYXBlZF9pbnB1dF9zaXplcyBUaGUgc2l6ZSBvZiBlYWNoIGltYWdlIGFzIGl0IGlzIGZlZCB0byB0aGUgbW9kZWwsIGluIChoZWlnaHQsIHdpZHRoKSBmb3JtYXQuIFVzZWQgdG8gcmVtb3ZlIHBhZGRpbmcuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgT3B0aW9uYWwgcGFyYW1ldGVycyBmb3IgcG9zdC1wcm9jZXNzaW5nLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5tYXNrX3RocmVzaG9sZF0gVGhlIHRocmVzaG9sZCB0byB1c2UgZm9yIGJpbmFyaXppbmcgdGhlIG1hc2tzLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuYmluYXJpemVdIFdoZXRoZXIgdG8gYmluYXJpemUgdGhlIG1hc2tzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5wYWRfc2l6ZV0gVGhlIHRhcmdldCBzaXplIHRoZSBpbWFnZXMgd2VyZSBwYWRkZWQgdG8gYmVmb3JlIGJlaW5nIHBhc3NlZCB0byB0aGUgbW9kZWwuIElmIGBudWxsYCwgdGhlIHRhcmdldCBzaXplIGlzIGFzc3VtZWQgdG8gYmUgdGhlIHByb2Nlc3NvcidzIGBwYWRfc2l6ZWAuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnBhZF9zaXplLmhlaWdodF0gVGhlIGhlaWdodCB0aGUgaW1hZ2VzIHdlcmUgcGFkZGVkIHRvLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5wYWRfc2l6ZS53aWR0aF0gVGhlIHdpZHRoIHRoZSBpbWFnZXMgd2VyZSBwYWRkZWQgdG8uXG4gICAgICogQHJldHVybnMge1RlbnNvcltdfSBCYXRjaGVkIG1hc2tzIGluIGJhdGNoX3NpemUsIG51bV9jaGFubmVscywgaGVpZ2h0LCB3aWR0aCkgZm9ybWF0LCB3aGVyZSAoaGVpZ2h0LCB3aWR0aCkgaXMgZ2l2ZW4gYnkgb3JpZ2luYWxfc2l6ZS5cbiAgICAgKi9cbiAgICBwb3N0X3Byb2Nlc3NfbWFza3MobWFza3MsIG9yaWdpbmFsX3NpemVzLCByZXNoYXBlZF9pbnB1dF9zaXplcywge1xuICAgICAgICBtYXNrX3RocmVzaG9sZCA9IDAuMCxcbiAgICAgICAgYmluYXJpemUgPSB0cnVlLFxuICAgICAgICBwYWRfc2l6ZSA9IG51bGwsXG4gICAgfSA9IHt9KSB7XG4gICAgICAgIC8vIG1hc2tzOiBbMSwgMSwgMywgMjU2LCAyNTZdXG5cbiAgICAgICAgbGV0IG91dHB1dF9tYXNrcyA9IFtdO1xuXG4gICAgICAgIHBhZF9zaXplID0gcGFkX3NpemUgPz8gdGhpcy5wYWRfc2l6ZTtcblxuICAgICAgICBsZXQgdGFyZ2V0X2ltYWdlX3NpemUgPSBbcGFkX3NpemUuaGVpZ2h0LCBwYWRfc2l6ZS53aWR0aF07XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvcmlnaW5hbF9zaXplcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgbGV0IG9yaWdpbmFsX3NpemUgPSBvcmlnaW5hbF9zaXplc1tpXTtcbiAgICAgICAgICAgIGxldCByZXNoYXBlZF9pbnB1dF9zaXplID0gcmVzaGFwZWRfaW5wdXRfc2l6ZXNbaV07XG5cbiAgICAgICAgICAgIGxldCBtYXNrID0gbWFza3NbaV07IC8vIFtiLCBjLCBoLCB3XVxuXG4gICAgICAgICAgICAvLyBUT0RPOiBpbXByb3ZlXG4gICAgICAgICAgICBsZXQgaW50ZXJwb2xhdGVkX21hc2tzID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG1hc2suZGltc1swXTsgKytqKSB7XG4gICAgICAgICAgICAgICAgbGV0IG0gPSBtYXNrW2pdOyAvLyAzZCB0ZW5zb3JcblxuICAgICAgICAgICAgICAgIC8vIFVwc2NhbGUgbWFzayB0byBwYWRkZWQgc2l6ZVxuICAgICAgICAgICAgICAgIGxldCBpbnRlcnBvbGF0ZWRfbWFzayA9IGludGVycG9sYXRlKG0sIHRhcmdldF9pbWFnZV9zaXplLCAnYmlsaW5lYXInLCBmYWxzZSk7XG5cbiAgICAgICAgICAgICAgICAvLyBDcm9wIG1hc2tcbiAgICAgICAgICAgICAgICBpbnRlcnBvbGF0ZWRfbWFzayA9IGludGVycG9sYXRlZF9tYXNrLnNsaWNlKG51bGwsIFswLCByZXNoYXBlZF9pbnB1dF9zaXplWzBdXSwgWzAsIHJlc2hhcGVkX2lucHV0X3NpemVbMV1dKTtcblxuICAgICAgICAgICAgICAgIC8vIERvd25zY2FsZSBtYXNrXG4gICAgICAgICAgICAgICAgaW50ZXJwb2xhdGVkX21hc2sgPSBpbnRlcnBvbGF0ZShtYXNrLCBvcmlnaW5hbF9zaXplLCAnYmlsaW5lYXInLCBmYWxzZSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoYmluYXJpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgaW50ZXJwb2xhdGVkX21hc2sgPSBuZXcgVGVuc29yKFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2Jvb2wnLFxuICAgICAgICAgICAgICAgICAgICAgICAgQXJyYXkuZnJvbShpbnRlcnBvbGF0ZWRfbWFzay5kYXRhKS5tYXAoeCA9PiB4ID4gbWFza190aHJlc2hvbGQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJwb2xhdGVkX21hc2suZGltc1xuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gYWRkIGJhY2sgYmF0Y2ggZGltIGZvciBjb25jYXRcbiAgICAgICAgICAgICAgICBpbnRlcnBvbGF0ZWRfbWFzay5kaW1zID0gWzEsIC4uLmludGVycG9sYXRlZF9tYXNrLmRpbXNdO1xuXG4gICAgICAgICAgICAgICAgaW50ZXJwb2xhdGVkX21hc2tzLnB1c2goaW50ZXJwb2xhdGVkX21hc2spO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQgY29uY2F0ZW5hdGVkID0gY2F0KGludGVycG9sYXRlZF9tYXNrcyk7XG4gICAgICAgICAgICBvdXRwdXRfbWFza3MucHVzaChjb25jYXRlbmF0ZWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG91dHB1dF9tYXNrcztcblxuICAgIH1cbn1cblxuXG5leHBvcnQgY2xhc3MgV2hpc3BlckZlYXR1cmVFeHRyYWN0b3IgZXh0ZW5kcyBGZWF0dXJlRXh0cmFjdG9yIHtcblxuICAgIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgICAgICBzdXBlcihjb25maWcpO1xuXG4gICAgICAgIC8vIFByZWZlciBnaXZlbiBgbWVsX2ZpbHRlcnNgIGZyb20gcHJlcHJvY2Vzc29yX2NvbmZpZy5qc29uLCBvciBjYWxjdWxhdGUgdGhlbSBpZiB0aGV5IGRvbid0IGV4aXN0LlxuICAgICAgICB0aGlzLmNvbmZpZy5tZWxfZmlsdGVycyA/Pz0gZ2V0TWVsRmlsdGVycyh0aGlzLmNvbmZpZy5zYW1wbGluZ19yYXRlLCB0aGlzLmNvbmZpZy5uX2ZmdCwgdGhpcy5jb25maWcuZmVhdHVyZV9zaXplKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlcyB0aGUgaW5kZXggb2Zmc2V0IGZvciBhIGdpdmVuIGluZGV4IGFuZCB3aW5kb3cgc2l6ZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaSBUaGUgaW5kZXguXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHcgVGhlIHdpbmRvdyBzaXplLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSBpbmRleCBvZmZzZXQuXG4gICAgICovXG4gICAgY2FsY09mZnNldChpLCB3KSB7XG4gICAgICAgIHJldHVybiBNYXRoLmFicygoaSArIHcpICUgKDIgKiB3KSAtIHcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBhZHMgYW4gYXJyYXkgd2l0aCBhIHJlZmxlY3RlZCB2ZXJzaW9uIG9mIGl0c2VsZiBvbiBib3RoIGVuZHMuXG4gICAgICogQHBhcmFtIHtGbG9hdDMyQXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBwYWQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxlZnQgVGhlIGFtb3VudCBvZiBwYWRkaW5nIHRvIGFkZCB0byB0aGUgbGVmdC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcmlnaHQgVGhlIGFtb3VudCBvZiBwYWRkaW5nIHRvIGFkZCB0byB0aGUgcmlnaHQuXG4gICAgICogQHJldHVybnMge0Zsb2F0MzJBcnJheX0gVGhlIHBhZGRlZCBhcnJheS5cbiAgICAgKi9cbiAgICBwYWRSZWZsZWN0KGFycmF5LCBsZWZ0LCByaWdodCkge1xuICAgICAgICBjb25zdCBwYWRkZWQgPSBuZXcgRmxvYXQzMkFycmF5KGFycmF5Lmxlbmd0aCArIGxlZnQgKyByaWdodCk7XG4gICAgICAgIGNvbnN0IHcgPSBhcnJheS5sZW5ndGggLSAxO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHBhZGRlZFtsZWZ0ICsgaV0gPSBhcnJheVtpXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDw9IGxlZnQ7ICsraSkge1xuICAgICAgICAgICAgcGFkZGVkW2xlZnQgLSBpXSA9IGFycmF5W3RoaXMuY2FsY09mZnNldChpLCB3KV07XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8PSByaWdodDsgKytpKSB7XG4gICAgICAgICAgICBwYWRkZWRbdyArIGxlZnQgKyBpXSA9IGFycmF5W3RoaXMuY2FsY09mZnNldCh3IC0gaSwgdyldO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBhZGRlZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGVzIHRoZSBjb21wbGV4IFNob3J0LVRpbWUgRm91cmllciBUcmFuc2Zvcm0gKFNURlQpIG9mIHRoZSBnaXZlbiBmcmFtZWQgc2lnbmFsLlxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7bnVtYmVyW11bXX0gZnJhbWVzIEEgMkQgYXJyYXkgcmVwcmVzZW50aW5nIHRoZSBzaWduYWwgZnJhbWVzLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyW119IHdpbmRvdyBBIDFEIGFycmF5IHJlcHJlc2VudGluZyB0aGUgd2luZG93IHRvIGJlIGFwcGxpZWQgdG8gdGhlIGZyYW1lcy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBBbiBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gICAgICogLSBkYXRhOiBBIDFEIGFycmF5IHJlcHJlc2VudGluZyB0aGUgY29tcGxleCBTVEZUIG9mIHRoZSBzaWduYWwuXG4gICAgICogLSBkaW1zOiBBbiBhcnJheSByZXByZXNlbnRpbmcgdGhlIGRpbWVuc2lvbnMgb2YgdGhlIFNURlQgZGF0YSwgaS5lLiBbbnVtX2ZyYW1lcywgbnVtX2ZmdF9iaW5zXS5cbiAgICAgKi9cbiAgICBzdGZ0KGZyYW1lcywgd2luZG93KSB7XG4gICAgICAgIC8vIENhbGN1bGF0ZXMgdGhlIGNvbXBsZXggU2hvcnQtVGltZSBGb3VyaWVyIFRyYW5zZm9ybSAoU1RGVCkgb2YgdGhlIGdpdmVuIGZyYW1lZCBzaWduYWwuXG4gICAgICAgIC8vIFxuICAgICAgICAvLyBOT1RFOiBTaW5jZSB0aGUgd2luZG93IHdpZHRoIGlzIG5vdCBhIHBvd2VyIG9mIDIsIHdlIG11c3QgXG4gICAgICAgIC8vIHBlcmZvcm0gRmFzdCBGb3VyaWVyIFRyYW5zZm9ybSB3aXRoIGNoaXJwLXogdHJhbnNmb3JtOlxuICAgICAgICAvLyBodHRwczovL21hdGguc3RhY2tleGNoYW5nZS5jb20vcXVlc3Rpb25zLzc3MTE4L25vbi1wb3dlci1vZi0yLWZmdHMvNzcxNTYjNzcxNTZcblxuICAgICAgICAvLyBIZWxwZXIgdmFyaWFibGVzXG4gICAgICAgIGNvbnN0IGZmdF9zaXplID0gdGhpcy5jb25maWcubl9mZnQ7XG4gICAgICAgIGNvbnN0IGEgPSAyICogKGZmdF9zaXplIC0gMSk7XG4gICAgICAgIGNvbnN0IGIgPSAyICogKDIgKiBmZnRfc2l6ZSAtIDEpO1xuICAgICAgICBjb25zdCBuZXh0UDIgPSAyICoqIChNYXRoLmNlaWwoTWF0aC5sb2cyKGIpKSlcbiAgICAgICAgY29uc3QgbnVtX2ZmdF9iaW5zID0gZmZ0X3NpemUgKyAyO1xuXG4gICAgICAgIC8vIFByZWFsbG9jYXRlIGFycmF5IHRvIHN0b3JlIG91dHB1dFxuICAgICAgICAvLyBkb3VibGUgc2luY2Ugd2Ugc3RvcmUgY29tcGxleCBudW1iZXJzXG4gICAgICAgIGNvbnN0IGRhdGEgPSBuZXcgRmxvYXQzMkFycmF5KG51bV9mZnRfYmlucyAqIGZyYW1lcy5sZW5ndGgpO1xuXG4gICAgICAgIC8vIERlZmluZSBidWZmZXJzXG4gICAgICAgIC8vIENvbXB1dGUgY2hpcnAgZm9yIHRyYW5zZm9ybVxuICAgICAgICBjb25zdCBjaGlycCA9IG5ldyBGbG9hdDMyQXJyYXkoYik7XG4gICAgICAgIGNvbnN0IGljaGlycCA9IG5ldyBGbG9hdDMyQXJyYXkobmV4dFAyKTtcbiAgICAgICAgY29uc3QgYnVmZmVyMSA9IG5ldyBGbG9hdDMyQXJyYXkobmV4dFAyKTtcbiAgICAgICAgY29uc3QgYnVmZmVyMiA9IG5ldyBGbG9hdDMyQXJyYXkobmV4dFAyKTtcbiAgICAgICAgY29uc3Qgb3V0QnVmZmVyID0gbmV3IEZsb2F0MzJBcnJheShuZXh0UDIpO1xuICAgICAgICBjb25zdCBvdXRCdWZmZXIyID0gbmV3IEZsb2F0MzJBcnJheShuZXh0UDIpO1xuICAgICAgICBjb25zdCBvdXRCdWZmZXIzID0gbmV3IEZsb2F0MzJBcnJheShuZXh0UDIpO1xuXG4gICAgICAgIC8vIENvbXB1dGUgY29tcGxleCBleHBvbmVudGlhdGlvblxuICAgICAgICBjb25zdCB0aGV0YSA9IC0yICogTWF0aC5QSSAvIGZmdF9zaXplO1xuICAgICAgICBjb25zdCBiYXNlUiA9IE1hdGguY29zKHRoZXRhKTtcbiAgICAgICAgY29uc3QgYmFzZUkgPSBNYXRoLnNpbih0aGV0YSk7XG5cbiAgICAgICAgLy8gUHJlY29tcHV0ZSBoZWxwZXIgZm9yIGNoaXJwLXogdHJhbnNmb3JtXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYiA+PiAxOyArK2kpIHtcbiAgICAgICAgICAgIC8vIENvbXB1dGUgY29tcGxleCBwb3dlcjpcbiAgICAgICAgICAgIGNvbnN0IGUgPSAoaSArIDEgLSBmZnRfc2l6ZSkgKiogMiAvIDIuMDtcblxuICAgICAgICAgICAgLy8gQ29tcHV0ZSB0aGUgbW9kdWx1cyBhbmQgYXJndW1lbnQgb2YgdGhlIHJlc3VsdFxuICAgICAgICAgICAgY29uc3QgcmVzdWx0X21vZCA9IE1hdGguc3FydChiYXNlUiAqKiAyICsgYmFzZUkgKiogMikgKiogZTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdF9hcmcgPSBlICogTWF0aC5hdGFuMihiYXNlSSwgYmFzZVIpO1xuXG4gICAgICAgICAgICAvLyBDb252ZXJ0IHRoZSByZXN1bHQgYmFjayB0byByZWN0YW5ndWxhciBmb3JtXG4gICAgICAgICAgICAvLyBhbmQgYXNzaWduIHRvIGNoaXJwIGFuZCBpY2hpcnBcbiAgICAgICAgICAgIGxldCBpMiA9IDIgKiBpO1xuICAgICAgICAgICAgY2hpcnBbaTJdID0gcmVzdWx0X21vZCAqIE1hdGguY29zKHJlc3VsdF9hcmcpO1xuICAgICAgICAgICAgY2hpcnBbaTIgKyAxXSA9IHJlc3VsdF9tb2QgKiBNYXRoLnNpbihyZXN1bHRfYXJnKTtcblxuICAgICAgICAgICAgLy8gY29uanVnYXRlXG4gICAgICAgICAgICBpY2hpcnBbaTJdID0gY2hpcnBbaTJdO1xuICAgICAgICAgICAgaWNoaXJwW2kyICsgMV0gPSAtIGNoaXJwW2kyICsgMV07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2xpY2VkQ2hpcnAgPSBjaGlycC5zdWJhcnJheShhLCBiKTtcblxuICAgICAgICAvLyBjcmVhdGUgb2JqZWN0IHRvIHBlcmZvcm0gRmFzdCBGb3VyaWVyIFRyYW5zZm9ybXNcbiAgICAgICAgLy8gd2l0aCBgbmV4dFAyYCBjb21wbGV4IG51bWJlcnNcbiAgICAgICAgY29uc3QgZiA9IG5ldyBGRlQobmV4dFAyID4+IDEpO1xuICAgICAgICAvLyBUT0RPOiBkZWNpZGUgYmV0d2VlbiBGbG9hdDMyQXJyYXkgYW5kIEZsb2F0NjRBcnJheVxuICAgICAgICBmLnRyYW5zZm9ybShvdXRCdWZmZXIsIGljaGlycCk7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmcmFtZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IGZyYW1lID0gZnJhbWVzW2ldO1xuXG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHNsaWNlZENoaXJwLmxlbmd0aDsgaiArPSAyKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgajIgPSBqICsgMVxuICAgICAgICAgICAgICAgIGNvbnN0IGozID0gaiA+PiAxO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgYV9yZWFsID0gZnJhbWVbajNdICogd2luZG93W2ozXTtcbiAgICAgICAgICAgICAgICBidWZmZXIxW2pdID0gYV9yZWFsICogc2xpY2VkQ2hpcnBbal07XG4gICAgICAgICAgICAgICAgYnVmZmVyMVtqMl0gPSBhX3JlYWwgKiBzbGljZWRDaGlycFtqMl07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBUT0RPOiBkZWNpZGUgYmV0d2VlbiBGbG9hdDMyQXJyYXkgYW5kIEZsb2F0NjRBcnJheVxuICAgICAgICAgICAgZi50cmFuc2Zvcm0ob3V0QnVmZmVyMiwgYnVmZmVyMSk7XG5cbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgb3V0QnVmZmVyLmxlbmd0aDsgaiArPSAyKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgajIgPSBqICsgMTtcblxuICAgICAgICAgICAgICAgIGJ1ZmZlcjJbal0gPSBvdXRCdWZmZXIyW2pdICogb3V0QnVmZmVyW2pdIC0gb3V0QnVmZmVyMltqMl0gKiBvdXRCdWZmZXJbajJdXG4gICAgICAgICAgICAgICAgYnVmZmVyMltqMl0gPSBvdXRCdWZmZXIyW2pdICogb3V0QnVmZmVyW2oyXSArIG91dEJ1ZmZlcjJbajJdICogb3V0QnVmZmVyW2pdXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBUT0RPOiBkZWNpZGUgYmV0d2VlbiBGbG9hdDMyQXJyYXkgYW5kIEZsb2F0NjRBcnJheVxuICAgICAgICAgICAgZi5pbnZlcnNlVHJhbnNmb3JtKG91dEJ1ZmZlcjMsIGJ1ZmZlcjIpXG5cbiAgICAgICAgICAgIGNvbnN0IG9mZnNldCA9IGkgKiBudW1fZmZ0X2JpbnM7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG51bV9mZnRfYmluczsgaiArPSAyKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYV9yZWFsID0gb3V0QnVmZmVyM1tqICsgYV07XG4gICAgICAgICAgICAgICAgY29uc3QgYV9pbWFnID0gb3V0QnVmZmVyM1tqICsgYSArIDFdO1xuICAgICAgICAgICAgICAgIGNvbnN0IGJfcmVhbCA9IHNsaWNlZENoaXJwW2pdO1xuICAgICAgICAgICAgICAgIGNvbnN0IGJfaW1hZyA9IHNsaWNlZENoaXJwW2ogKyAxXTtcblxuICAgICAgICAgICAgICAgIC8vIFRPRE8gd3JpdGUgYXMgdHJhbnNwb3NlXG4gICAgICAgICAgICAgICAgY29uc3QgbzEgPSBvZmZzZXQgKyBqO1xuICAgICAgICAgICAgICAgIGRhdGFbbzFdID0gYV9yZWFsICogYl9yZWFsIC0gYV9pbWFnICogYl9pbWFnXG4gICAgICAgICAgICAgICAgZGF0YVtvMSArIDFdID0gYV9yZWFsICogYl9pbWFnICsgYV9pbWFnICogYl9yZWFsXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgICAgIGRpbXM6IFtmcmFtZXMubGVuZ3RoLCBudW1fZmZ0X2JpbnNdIC8vIFszMDAxLCA0MDJdXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBmcmFtZXMgZnJvbSBhIGdpdmVuIHdhdmVmb3JtLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtGbG9hdDMyQXJyYXl9IHdhdmVmb3JtIFRoZSB3YXZlZm9ybSB0byBjcmVhdGUgZnJhbWVzIGZyb20uXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbY2VudGVyPXRydWVdIFdoZXRoZXIgdG8gY2VudGVyIHRoZSBmcmFtZXMgb24gdGhlaXIgY29ycmVzcG9uZGluZyBwb3NpdGlvbnMgaW4gdGhlIHdhdmVmb3JtLiBEZWZhdWx0cyB0byB0cnVlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gQW4gYXJyYXkgb2YgZnJhbWVzLlxuICAgICAqL1xuICAgIGZyYW1fd2F2ZSh3YXZlZm9ybSwgY2VudGVyID0gdHJ1ZSkge1xuICAgICAgICBjb25zdCBmcmFtZXMgPSBbXTtcbiAgICAgICAgY29uc3QgaGFsZl93aW5kb3cgPSBNYXRoLmZsb29yKCh0aGlzLmNvbmZpZy5uX2ZmdCAtIDEpIC8gMikgKyAxO1xuICAgICAgICBjb25zdCB3YXZlZm9ybUxlbmd0aCA9IHdhdmVmb3JtLmxlbmd0aDtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHdhdmVmb3JtTGVuZ3RoICsgMTsgaSArPSB0aGlzLmNvbmZpZy5ob3BfbGVuZ3RoKSB7XG5cbiAgICAgICAgICAgIGxldCBmcmFtZTtcbiAgICAgICAgICAgIGlmIChjZW50ZXIpIHtcblxuICAgICAgICAgICAgICAgIGxldCBmcmFtZVN0YXJ0ID0gaSA+IGhhbGZfd2luZG93ID8gaSAtIGhhbGZfd2luZG93IDogMDtcbiAgICAgICAgICAgICAgICBsZXQgZnJhbWVFbmQgPVxuICAgICAgICAgICAgICAgICAgICBpIDwgd2F2ZWZvcm1MZW5ndGggLSBoYWxmX3dpbmRvd1xuICAgICAgICAgICAgICAgICAgICAgICAgPyBpICsgaGFsZl93aW5kb3dcbiAgICAgICAgICAgICAgICAgICAgICAgIDogd2F2ZWZvcm1MZW5ndGg7XG5cbiAgICAgICAgICAgICAgICBmcmFtZSA9IHdhdmVmb3JtLnN1YmFycmF5KGZyYW1lU3RhcnQsIGZyYW1lRW5kKVxuXG4gICAgICAgICAgICAgICAgaWYgKGZyYW1lU3RhcnQgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZnJhbWUgPSB0aGlzLnBhZFJlZmxlY3QoXG4gICAgICAgICAgICAgICAgICAgICAgICBmcmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC1pICsgaGFsZl93aW5kb3csXG4gICAgICAgICAgICAgICAgICAgICAgICAwXG4gICAgICAgICAgICAgICAgICAgIClcblxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZnJhbWVFbmQgPT09IHdhdmVmb3JtTGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGZyYW1lID0gdGhpcy5wYWRSZWZsZWN0KFxuICAgICAgICAgICAgICAgICAgICAgICAgZnJhbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgaSAtIHdhdmVmb3JtTGVuZ3RoICsgaGFsZl93aW5kb3dcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmcmFtZSA9IG5ldyBGbG9hdDMyQXJyYXkodGhpcy5jb25maWcubl9mZnQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGZyYW1lQXJyYXkgPSB3YXZlZm9ybS5zdWJhcnJheShpLCBpICsgdGhpcy5jb25maWcubl9mZnQpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGZyYW1lQXJyYXkubGVuZ3RoIDwgdGhpcy5jb25maWcubl9mZnQpIHtcbiAgICAgICAgICAgICAgICAgICAgZnJhbWUuc2V0KGZyYW1lQXJyYXkpO1xuICAgICAgICAgICAgICAgICAgICBmcmFtZS5maWxsKDAsIGZyYW1lQXJyYXkubGVuZ3RoLCB0aGlzLmNvbmZpZy5uX2ZmdClcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmcmFtZSA9IGZyYW1lQXJyYXk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmcmFtZXMucHVzaChmcmFtZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZnJhbWVzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyBhIEhhbm5pbmcgd2luZG93IG9mIGxlbmd0aCBNLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IE0gVGhlIGxlbmd0aCBvZiB0aGUgSGFubmluZyB3aW5kb3cgdG8gZ2VuZXJhdGUuXG4gICAgICogQHJldHVybnMgeyp9IFRoZSBnZW5lcmF0ZWQgSGFubmluZyB3aW5kb3cuXG4gICAgICovXG4gICAgaGFubmluZyhNKSB7XG4gICAgICAgIGlmIChNIDwgMSkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChNID09PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gWzFdO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRlbm9tID0gTSAtIDE7XG4gICAgICAgIGNvbnN0IGNvc192YWxzID0gbmV3IEZsb2F0MzJBcnJheShkZW5vbSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGVub207ICsraSkge1xuICAgICAgICAgICAgY29uc3QgbiA9IDIgKiBpIC0gTSArIDE7XG4gICAgICAgICAgICBjb3NfdmFsc1tpXSA9IDAuNSArIDAuNSAqIE1hdGguY29zKE1hdGguUEkgKiBuIC8gZGVub20pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb3NfdmFscztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyB0aGUgbG9nLU1lbCBzcGVjdHJvZ3JhbSBvZiB0aGUgcHJvdmlkZWQgYXVkaW8gd2F2ZWZvcm0uXG4gICAgICogQHBhcmFtIHtGbG9hdDMyQXJyYXl8RmxvYXQ2NEFycmF5fSB3YXZlZm9ybSBUaGUgYXVkaW8gd2F2ZWZvcm0gdG8gcHJvY2Vzcy5cbiAgICAgKiBAcmV0dXJucyB7e2RhdGE6IEZsb2F0MzJBcnJheSwgZGltczogbnVtYmVyW119fSBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgbG9nLU1lbCBzcGVjdHJvZ3JhbSBkYXRhIGFzIGEgRmxvYXQzMkFycmF5IGFuZCBpdHMgZGltZW5zaW9ucyBhcyBhbiBhcnJheSBvZiBudW1iZXJzLlxuICAgICAqL1xuICAgIF9leHRyYWN0X2ZiYW5rX2ZlYXR1cmVzKHdhdmVmb3JtKSB7XG4gICAgICAgIC8vIENvbXB1dGUgdGhlIGxvZy1NZWwgc3BlY3Ryb2dyYW0gb2YgdGhlIHByb3ZpZGVkIGF1ZGlvXG5cbiAgICAgICAgY29uc3QgYnVmZmVyID0gbmV3IEZsb2F0MzJBcnJheSh0aGlzLmNvbmZpZy5uX3NhbXBsZXMpO1xuICAgICAgICBidWZmZXIuc2V0KHdhdmVmb3JtKVxuXG4gICAgICAgIGNvbnN0IHdpbmRvdyA9IHRoaXMuaGFubmluZyh0aGlzLmNvbmZpZy5uX2ZmdCArIDEpXG4gICAgICAgIGNvbnN0IGZyYW1lcyA9IHRoaXMuZnJhbV93YXZlKGJ1ZmZlcilcblxuICAgICAgICBjb25zdCBzdGZ0ID0gdGhpcy5zdGZ0KGZyYW1lcywgd2luZG93KVxuXG4gICAgICAgIGNvbnN0IHN0ZnREYXRhID0gc3RmdC5kYXRhO1xuICAgICAgICBjb25zdCBkMSA9IHN0ZnQuZGltc1swXSAtIDE7IC8vIElnbm9yZSBsYXN0IHJvd1xuICAgICAgICBjb25zdCBkMiA9IHN0ZnQuZGltc1sxXSA+PiAxOyAvLyBPbmx5IG5lZWQgdG8gc3RvcmUgcmVhbCBudW1iZXJzIG5vd1xuXG4gICAgICAgIC8vIGNvbXB1dGUgbWFnbml0dWRlc1xuICAgICAgICAvLyBOT1RFOiBVbmxpa2UgdGhlIG9yaWdpbmFsIGltcGxlbWVudGF0aW9uLCB3ZSBkbyBub3RcbiAgICAgICAgLy8gdHJhbnNwb3NlIHNpbmNlIHdlIHBlcmZvcm0gbWF0cml4IG11bHRpcGxpY2F0aW9uIGxhdGVyXG4gICAgICAgIGNvbnN0IG1hZ25pdHVkZXMgPSBuZXcgRmxvYXQzMkFycmF5KGQxICogZDIpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGQxOyArK2kpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgZDI7ICsraikge1xuICAgICAgICAgICAgICAgIC8vIGxldCBvdXRPZmZzZXQgPSAoaiAqIGQxICsgaSk7IC8vIHRyYW5zcG9zZVxuICAgICAgICAgICAgICAgIGxldCBvdXRPZmZzZXQgPSBpICogZDIgKyBqO1xuICAgICAgICAgICAgICAgIGxldCBpbk9mZnNldCA9IG91dE9mZnNldCA8PCAxOyAvLyAqIDIgc2luY2UgY29tcGxleFxuICAgICAgICAgICAgICAgIGxldCBtYWduaXR1ZGUgPSBzdGZ0RGF0YVtpbk9mZnNldF0gKiogMiArIHN0ZnREYXRhW2luT2Zmc2V0ICsgMV0gKiogMlxuICAgICAgICAgICAgICAgIG1hZ25pdHVkZXNbb3V0T2Zmc2V0XSA9IG1hZ25pdHVkZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG1lbF9maWx0ZXJzID0gdGhpcy5jb25maWcubWVsX2ZpbHRlcnM7XG4gICAgICAgIGNvbnN0IG51bV9tZWxfZmlsdGVycyA9IG1lbF9maWx0ZXJzLmxlbmd0aDtcblxuICAgICAgICBjb25zdCBtZWxfc3BlYyA9IG5ldyBGbG9hdDMyQXJyYXkobnVtX21lbF9maWx0ZXJzICogZDEpO1xuICAgICAgICBsZXQgbUluZGV4ID0gMDtcblxuICAgICAgICAvLyBQZXJmb3JtIG1hdHJpeCBtdWxpcGxpY2F0aW9uOlxuICAgICAgICAvLyBtZWxfc3BlYyA9IGZpbHRlcnMgQCBtYWduaXR1ZGVzXG4gICAgICAgIC8vICAtIGZpbHRlcnMuc2hhcGU9KDgwLCAyMDEpXG4gICAgICAgIC8vICAtIG1hZ25pdHVkZXMuc2hhcGU9KDIwMSwgMzAwMClcbiAgICAgICAgLy8gIC0gbWVsX3NwZWMuc2hhcGU9KDgwLCAzMDAwKVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bV9tZWxfZmlsdGVyczsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCBtZWxfZmlsdGVyID0gbWVsX2ZpbHRlcnNbaV07XG5cbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgZDE7ICsraikge1xuICAgICAgICAgICAgICAgIGxldCBzdW0gPSAwO1xuXG4gICAgICAgICAgICAgICAgLy8gcGVyZm9ybSBkb3QgcHJvZHVjdFxuICAgICAgICAgICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgZDI7ICsraykge1xuICAgICAgICAgICAgICAgICAgICBzdW0gKz0gbWVsX2ZpbHRlcltrXSAqIG1hZ25pdHVkZXNbaiAqIGQyICsga107XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbWVsX3NwZWNbbUluZGV4KytdID0gc3VtO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgYV9taW4gPSAxZS0xMDtcbiAgICAgICAgY29uc3QgbG9nX3NwZWMgPSBuZXcgRmxvYXQzMkFycmF5KG1lbF9zcGVjLmxlbmd0aCk7XG5cbiAgICAgICAgbGV0IG1heExvZ1NwZWMgPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1lbF9zcGVjLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCBjbGlwcGVkID0gTWF0aC5tYXgoYV9taW4sIG1lbF9zcGVjW2ldKTtcbiAgICAgICAgICAgIGNvbnN0IGxvZzEwID0gTWF0aC5sb2cxMChjbGlwcGVkKTtcbiAgICAgICAgICAgIGxvZ19zcGVjW2ldID0gbG9nMTA7XG4gICAgICAgICAgICBtYXhMb2dTcGVjID0gTWF0aC5tYXgobG9nMTAsIG1heExvZ1NwZWMpXG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxvZ19zcGVjLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBsb2dfc3BlY1tpXSA9IE1hdGgubWF4KGxvZ19zcGVjW2ldLCBtYXhMb2dTcGVjIC0gOCk7XG4gICAgICAgICAgICBsb2dfc3BlY1tpXSA9IChsb2dfc3BlY1tpXSArIDQpIC8gNDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkYXRhOiBsb2dfc3BlYyxcbiAgICAgICAgICAgIGRpbXM6IFtudW1fbWVsX2ZpbHRlcnMsIGQxXVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFzeW5jaHJvbm91c2x5IGV4dHJhY3RzIGZlYXR1cmVzIGZyb20gYSBnaXZlbiBhdWRpbyB1c2luZyB0aGUgcHJvdmlkZWQgY29uZmlndXJhdGlvbi5cbiAgICAgKiBAcGFyYW0ge0Zsb2F0MzJBcnJheXxGbG9hdDY0QXJyYXl9IGF1ZGlvIFRoZSBhdWRpbyBkYXRhIGFzIGEgRmxvYXQzMkFycmF5LlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPHsgaW5wdXRfZmVhdHVyZXM6IFRlbnNvciB9Pn0gQSBQcm9taXNlIHJlc29sdmluZyB0byBhbiBvYmplY3QgY29udGFpbmluZyB0aGUgZXh0cmFjdGVkIGlucHV0IGZlYXR1cmVzIGFzIGEgVGVuc29yLlxuICAgICovXG4gICAgYXN5bmMgX2NhbGwoYXVkaW8pIHtcbiAgICAgICAgaWYgKCEoYXVkaW8gaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkgfHwgYXVkaW8gaW5zdGFuY2VvZiBGbG9hdDY0QXJyYXkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgIGBXaGlzcGVyRmVhdHVyZUV4dHJhY3RvciBleHBlY3RzIGlucHV0IHRvIGJlIGEgRmxvYXQzMkFycmF5IG9yIGEgRmxvYXQ2NEFycmF5LCBidXQgZ290ICR7YXVkaW8/LmNvbnN0cnVjdG9yPy5uYW1lID8/IHR5cGVvZiBhdWRpb30gaW5zdGVhZC5gICtcbiAgICAgICAgICAgICAgICBgSWYgdXNpbmcgdGhlIGZlYXR1cmUgZXh0cmFjdG9yIGRpcmVjdGx5LCByZW1lbWJlciB0byB1c2UgXFxgcmVhZF9hdWRpbyh1cmwsIHNhbXBsaW5nX3JhdGUpXFxgIHRvIG9idGFpbiB0aGUgcmF3IGF1ZGlvIGRhdGEgb2YgdGhlIGZpbGUvdXJsLmBcbiAgICAgICAgICAgIClcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhdWRpby5sZW5ndGggPiB0aGlzLmNvbmZpZy5uX3NhbXBsZXMpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgICAgICBcIkF0dGVtcHRpbmcgdG8gZXh0cmFjdCBmZWF0dXJlcyBmb3IgYXVkaW8gbG9uZ2VyIHRoYW4gMzAgc2Vjb25kcy4gXCIgK1xuICAgICAgICAgICAgICAgIFwiSWYgdXNpbmcgYSBwaXBlbGluZSB0byBleHRyYWN0IHRyYW5zY3JpcHQgZnJvbSBhIGxvbmcgYXVkaW8gY2xpcCwgXCIgK1xuICAgICAgICAgICAgICAgIFwicmVtZW1iZXIgdG8gc3BlY2lmeSBgY2h1bmtfbGVuZ3RoX3NgIGFuZC9vciBgc3RyaWRlX2xlbmd0aF9zYC5cIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgd2F2ZWZvcm0gPSBhdWRpby5zbGljZSgwLCB0aGlzLmNvbmZpZy5uX3NhbXBsZXMpO1xuXG4gICAgICAgIGxldCBmZWF0dXJlcyA9IHRoaXMuX2V4dHJhY3RfZmJhbmtfZmVhdHVyZXMod2F2ZWZvcm0pO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpbnB1dF9mZWF0dXJlczogbmV3IFRlbnNvcignZmxvYXQzMicsXG4gICAgICAgICAgICAgICAgZmVhdHVyZXMuZGF0YSxcbiAgICAgICAgICAgICAgICBbMSwgLi4uZmVhdHVyZXMuZGltc11cbiAgICAgICAgICAgIClcbiAgICAgICAgfTtcbiAgICB9XG59XG5cbi8qKlxuICogUmVwcmVzZW50cyBhIFByb2Nlc3NvciB0aGF0IGV4dHJhY3RzIGZlYXR1cmVzIGZyb20gYW4gaW5wdXQuXG4gKiBAZXh0ZW5kcyBDYWxsYWJsZVxuICovXG5leHBvcnQgY2xhc3MgUHJvY2Vzc29yIGV4dGVuZHMgQ2FsbGFibGUge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgUHJvY2Vzc29yIHdpdGggdGhlIGdpdmVuIGZlYXR1cmUgZXh0cmFjdG9yLlxuICAgICAqIEBwYXJhbSB7RmVhdHVyZUV4dHJhY3Rvcn0gZmVhdHVyZV9leHRyYWN0b3IgVGhlIGZ1bmN0aW9uIHVzZWQgdG8gZXh0cmFjdCBmZWF0dXJlcyBmcm9tIHRoZSBpbnB1dC5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihmZWF0dXJlX2V4dHJhY3Rvcikge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmZlYXR1cmVfZXh0cmFjdG9yID0gZmVhdHVyZV9leHRyYWN0b3I7XG4gICAgICAgIC8vIFRPRE8gdXNlIHRva2VuaXplciBoZXJlP1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGxzIHRoZSBmZWF0dXJlX2V4dHJhY3RvciBmdW5jdGlvbiB3aXRoIHRoZSBnaXZlbiBpbnB1dC5cbiAgICAgKiBAcGFyYW0ge2FueX0gaW5wdXQgVGhlIGlucHV0IHRvIGV4dHJhY3QgZmVhdHVyZXMgZnJvbS5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxhbnk+fSBBIFByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSBleHRyYWN0ZWQgZmVhdHVyZXMuXG4gICAgICovXG4gICAgYXN5bmMgX2NhbGwoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZmVhdHVyZV9leHRyYWN0b3IoaW5wdXQpO1xuICAgIH1cbn1cblxuZXhwb3J0IGNsYXNzIFNhbVByb2Nlc3NvciBleHRlbmRzIFByb2Nlc3NvciB7XG5cbiAgICBhc3luYyBfY2FsbChpbWFnZXMsIGlucHV0X3BvaW50cykge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5mZWF0dXJlX2V4dHJhY3RvcihpbWFnZXMsIGlucHV0X3BvaW50cyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGJvcnJvd3MgU2FtSW1hZ2VQcm9jZXNzb3IjcG9zdF9wcm9jZXNzX21hc2tzIGFzIHBvc3RfcHJvY2Vzc19tYXNrc1xuICAgICAqL1xuICAgIHBvc3RfcHJvY2Vzc19tYXNrcyguLi5hcmdzKSB7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgcmV0dXJuIHRoaXMuZmVhdHVyZV9leHRyYWN0b3IucG9zdF9wcm9jZXNzX21hc2tzKC4uLmFyZ3MpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgV2hpc3BlclByb2Nlc3NvciB0aGF0IGV4dHJhY3RzIGZlYXR1cmVzIGZyb20gYW4gYXVkaW8gaW5wdXQuXG4gKiBAZXh0ZW5kcyBQcm9jZXNzb3JcbiAqL1xuZXhwb3J0IGNsYXNzIFdoaXNwZXJQcm9jZXNzb3IgZXh0ZW5kcyBQcm9jZXNzb3Ige1xuICAgIC8qKlxuICAgICAqIENhbGxzIHRoZSBmZWF0dXJlX2V4dHJhY3RvciBmdW5jdGlvbiB3aXRoIHRoZSBnaXZlbiBhdWRpbyBpbnB1dC5cbiAgICAgKiBAcGFyYW0ge2FueX0gYXVkaW8gVGhlIGF1ZGlvIGlucHV0IHRvIGV4dHJhY3QgZmVhdHVyZXMgZnJvbS5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxhbnk+fSBBIFByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSBleHRyYWN0ZWQgZmVhdHVyZXMuXG4gICAgICovXG4gICAgYXN5bmMgX2NhbGwoYXVkaW8pIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZmVhdHVyZV9leHRyYWN0b3IoYXVkaW8pXG4gICAgfVxufVxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuL3V0aWxzL2h1Yi5qcycpLlByZXRyYWluZWRPcHRpb25zfSBQcmV0cmFpbmVkT3B0aW9uc1xuICovXG4vKipcbiAqIEhlbHBlciBjbGFzcyB3aGljaCBpcyB1c2VkIHRvIGluc3RhbnRpYXRlIHByZXRyYWluZWQgcHJvY2Vzc29ycyB3aXRoIHRoZSBgZnJvbV9wcmV0cmFpbmVkYCBmdW5jdGlvbi5cbiAqIFRoZSBjaG9zZW4gcHJvY2Vzc29yIGNsYXNzIGlzIGRldGVybWluZWQgYnkgdGhlIHR5cGUgc3BlY2lmaWVkIGluIHRoZSBwcm9jZXNzb3IgY29uZmlnLlxuICogXG4gKiAqKkV4YW1wbGU6KiogTG9hZCBhIHByb2Nlc3NvciB1c2luZyBgZnJvbV9wcmV0cmFpbmVkYC5cbiAqIGBgYGphdmFzY3JpcHRcbiAqIGxldCBwcm9jZXNzb3IgPSBhd2FpdCBBdXRvUHJvY2Vzc29yLmZyb21fcHJldHJhaW5lZCgnb3BlbmFpL3doaXNwZXItdGlueS5lbicpO1xuICogYGBgXG4gKiBcbiAqICoqRXhhbXBsZToqKiBSdW4gYW4gaW1hZ2UgdGhyb3VnaCBhIHByb2Nlc3Nvci5cbiAqIGBgYGphdmFzY3JpcHRcbiAqIGxldCBwcm9jZXNzb3IgPSBhd2FpdCBBdXRvUHJvY2Vzc29yLmZyb21fcHJldHJhaW5lZCgnWGVub3ZhL2NsaXAtdml0LWJhc2UtcGF0Y2gxNicpO1xuICogbGV0IGltYWdlID0gYXdhaXQgUmF3SW1hZ2UucmVhZCgnaHR0cHM6Ly9odWdnaW5nZmFjZS5jby9kYXRhc2V0cy9YZW5vdmEvdHJhbnNmb3JtZXJzLmpzLWRvY3MvcmVzb2x2ZS9tYWluL2Zvb3RiYWxsLW1hdGNoLmpwZycpO1xuICogbGV0IGltYWdlX2lucHV0cyA9IGF3YWl0IHByb2Nlc3NvcihpbWFnZSk7XG4gKiAvLyB7XG4gKiAvLyAgIFwicGl4ZWxfdmFsdWVzXCI6IHtcbiAqIC8vICAgICBcImRpbXNcIjogWyAxLCAzLCAyMjQsIDIyNCBdLFxuICogLy8gICAgIFwidHlwZVwiOiBcImZsb2F0MzJcIixcbiAqIC8vICAgICBcImRhdGFcIjogRmxvYXQzMkFycmF5IFsgLTEuNTU4Njg3Njg2OTIwMTY2LCAtMS41NTg2ODc2ODY5MjAxNjYsIC0xLjU0NDA4OTMxNzMyMTc3NzMsIC4uLiBdLFxuICogLy8gICAgIFwic2l6ZVwiOiAxNTA1MjhcbiAqIC8vICAgfSxcbiAqIC8vICAgXCJvcmlnaW5hbF9zaXplc1wiOiBbXG4gKiAvLyAgICAgWyA1MzMsIDgwMCBdXG4gKiAvLyAgIF0sXG4gKiAvLyAgIFwicmVzaGFwZWRfaW5wdXRfc2l6ZXNcIjogW1xuICogLy8gICAgIFsgMjI0LCAyMjQgXVxuICogLy8gICBdXG4gKiAvLyB9XG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIEF1dG9Qcm9jZXNzb3Ige1xuICAgIHN0YXRpYyBGRUFUVVJFX0VYVFJBQ1RPUl9DTEFTU19NQVBQSU5HID0ge1xuICAgICAgICAnV2hpc3BlckZlYXR1cmVFeHRyYWN0b3InOiBXaGlzcGVyRmVhdHVyZUV4dHJhY3RvcixcbiAgICAgICAgJ1ZpVEZlYXR1cmVFeHRyYWN0b3InOiBWaVRGZWF0dXJlRXh0cmFjdG9yLFxuICAgICAgICAnTW9iaWxlVmlURmVhdHVyZUV4dHJhY3Rvcic6IE1vYmlsZVZpVEZlYXR1cmVFeHRyYWN0b3IsXG4gICAgICAgICdEZXRyRmVhdHVyZUV4dHJhY3Rvcic6IERldHJGZWF0dXJlRXh0cmFjdG9yLFxuXG4gICAgICAgICdTYW1JbWFnZVByb2Nlc3Nvcic6IFNhbUltYWdlUHJvY2Vzc29yLFxuICAgIH1cblxuICAgIHN0YXRpYyBQUk9DRVNTT1JfQ0xBU1NfTUFQUElORyA9IHtcbiAgICAgICAgJ1doaXNwZXJQcm9jZXNzb3InOiBXaGlzcGVyUHJvY2Vzc29yLFxuICAgICAgICAnU2FtUHJvY2Vzc29yJzogU2FtUHJvY2Vzc29yLFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluc3RhbnRpYXRlIG9uZSBvZiB0aGUgcHJvY2Vzc29yIGNsYXNzZXMgb2YgdGhlIGxpYnJhcnkgZnJvbSBhIHByZXRyYWluZWQgbW9kZWwuXG4gICAgICogXG4gICAgICogVGhlIHByb2Nlc3NvciBjbGFzcyB0byBpbnN0YW50aWF0ZSBpcyBzZWxlY3RlZCBiYXNlZCBvbiB0aGUgYGZlYXR1cmVfZXh0cmFjdG9yX3R5cGVgIHByb3BlcnR5IG9mIHRoZSBjb25maWcgb2JqZWN0XG4gICAgICogKGVpdGhlciBwYXNzZWQgYXMgYW4gYXJndW1lbnQgb3IgbG9hZGVkIGZyb20gYHByZXRyYWluZWRfbW9kZWxfbmFtZV9vcl9wYXRoYCBpZiBwb3NzaWJsZSlcbiAgICAgKiBcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJldHJhaW5lZF9tb2RlbF9uYW1lX29yX3BhdGggVGhlIG5hbWUgb3IgcGF0aCBvZiB0aGUgcHJldHJhaW5lZCBtb2RlbC4gQ2FuIGJlIGVpdGhlcjpcbiAgICAgKiAtIEEgc3RyaW5nLCB0aGUgKm1vZGVsIGlkKiBvZiBhIHByZXRyYWluZWQgcHJvY2Vzc29yIGhvc3RlZCBpbnNpZGUgYSBtb2RlbCByZXBvIG9uIGh1Z2dpbmdmYWNlLmNvLlxuICAgICAqICAgVmFsaWQgbW9kZWwgaWRzIGNhbiBiZSBsb2NhdGVkIGF0IHRoZSByb290LWxldmVsLCBsaWtlIGBiZXJ0LWJhc2UtdW5jYXNlZGAsIG9yIG5hbWVzcGFjZWQgdW5kZXIgYVxuICAgICAqICAgdXNlciBvciBvcmdhbml6YXRpb24gbmFtZSwgbGlrZSBgZGJtZHovYmVydC1iYXNlLWdlcm1hbi1jYXNlZGAuXG4gICAgICogLSBBIHBhdGggdG8gYSAqZGlyZWN0b3J5KiBjb250YWluaW5nIHByb2Nlc3NvciBmaWxlcywgZS5nLiwgYC4vbXlfbW9kZWxfZGlyZWN0b3J5L2AuXG4gICAgICogQHBhcmFtIHtQcmV0cmFpbmVkT3B0aW9uc30gb3B0aW9ucyBBZGRpdGlvbmFsIG9wdGlvbnMgZm9yIGxvYWRpbmcgdGhlIHByb2Nlc3Nvci5cbiAgICAgKiBcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxQcm9jZXNzb3I+fSBBIG5ldyBpbnN0YW5jZSBvZiB0aGUgUHJvY2Vzc29yIGNsYXNzLlxuICAgICAqL1xuICAgIHN0YXRpYyBhc3luYyBmcm9tX3ByZXRyYWluZWQocHJldHJhaW5lZF9tb2RlbF9uYW1lX29yX3BhdGgsIHtcbiAgICAgICAgcHJvZ3Jlc3NfY2FsbGJhY2sgPSBudWxsLFxuICAgICAgICBjb25maWcgPSBudWxsLFxuICAgICAgICBjYWNoZV9kaXIgPSBudWxsLFxuICAgICAgICBsb2NhbF9maWxlc19vbmx5ID0gZmFsc2UsXG4gICAgICAgIHJldmlzaW9uID0gJ21haW4nLFxuICAgIH0gPSB7fSkge1xuXG4gICAgICAgIGxldCBwcmVwcm9jZXNzb3JDb25maWcgPSBjb25maWcgPz8gYXdhaXQgZ2V0TW9kZWxKU09OKHByZXRyYWluZWRfbW9kZWxfbmFtZV9vcl9wYXRoLCAncHJlcHJvY2Vzc29yX2NvbmZpZy5qc29uJywgdHJ1ZSwge1xuICAgICAgICAgICAgcHJvZ3Jlc3NfY2FsbGJhY2ssXG4gICAgICAgICAgICBjb25maWcsXG4gICAgICAgICAgICBjYWNoZV9kaXIsXG4gICAgICAgICAgICBsb2NhbF9maWxlc19vbmx5LFxuICAgICAgICAgICAgcmV2aXNpb24sXG4gICAgICAgIH0pXG5cbiAgICAgICAgLy8gRGV0ZXJtaW5lIGZlYXR1cmUgZXh0cmFjdG9yIGNsYXNzXG4gICAgICAgIC8vIFRPRE86IEVuc3VyZSBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSB3aXRoIG9sZCBjb25maWdzXG4gICAgICAgIGxldCBrZXkgPSBwcmVwcm9jZXNzb3JDb25maWcuZmVhdHVyZV9leHRyYWN0b3JfdHlwZSA/PyBwcmVwcm9jZXNzb3JDb25maWcuaW1hZ2VfcHJvY2Vzc29yX3R5cGU7XG4gICAgICAgIGxldCBmZWF0dXJlX2V4dHJhY3Rvcl9jbGFzcyA9IHRoaXMuRkVBVFVSRV9FWFRSQUNUT1JfQ0xBU1NfTUFQUElOR1trZXldO1xuXG4gICAgICAgIGlmICghZmVhdHVyZV9leHRyYWN0b3JfY2xhc3MpIHtcbiAgICAgICAgICAgIGlmIChwcmVwcm9jZXNzb3JDb25maWcuc2l6ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgLy8gQXNzdW1lIEltYWdlRmVhdHVyZUV4dHJhY3RvclxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignRmVhdHVyZSBleHRyYWN0b3IgdHlwZSBub3Qgc3BlY2lmaWVkLCBhc3N1bWluZyBJbWFnZUZlYXR1cmVFeHRyYWN0b3IgZHVlIHRvIHNpemUgcGFyYW1ldGVyIGluIGNvbmZpZy4nKTtcbiAgICAgICAgICAgICAgICBmZWF0dXJlX2V4dHJhY3Rvcl9jbGFzcyA9IEltYWdlRmVhdHVyZUV4dHJhY3RvcjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIEZlYXR1cmUgRXh0cmFjdG9yIHR5cGU6ICR7cHJlcHJvY2Vzc29yQ29uZmlnLmZlYXR1cmVfZXh0cmFjdG9yX3R5cGV9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiBubyBhc3NvY2lhdGVkIHByb2Nlc3NvciBjbGFzcywgdXNlIGRlZmF1bHRcbiAgICAgICAgbGV0IHByb2Nlc3Nvcl9jbGFzcyA9IHRoaXMuUFJPQ0VTU09SX0NMQVNTX01BUFBJTkdbcHJlcHJvY2Vzc29yQ29uZmlnLnByb2Nlc3Nvcl9jbGFzc10gPz8gUHJvY2Vzc29yO1xuXG4gICAgICAgIC8vIEluc3RhbnRpYXRlIHByb2Nlc3NvciBhbmQgZmVhdHVyZSBleHRyYWN0b3JcbiAgICAgICAgbGV0IGZlYXR1cmVfZXh0cmFjdG9yID0gbmV3IGZlYXR1cmVfZXh0cmFjdG9yX2NsYXNzKHByZXByb2Nlc3NvckNvbmZpZyk7XG4gICAgICAgIHJldHVybiBuZXcgcHJvY2Vzc29yX2NsYXNzKGZlYXR1cmVfZXh0cmFjdG9yKTtcbiAgICB9XG59XG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@xenova/transformers/src/processors.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@xenova/transformers/src/tokenizers.js":
/*!*************************************************************!*\
  !*** ./node_modules/@xenova/transformers/src/tokenizers.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AlbertTokenizer: function() { return /* binding */ AlbertTokenizer; },\n/* harmony export */   AutoTokenizer: function() { return /* binding */ AutoTokenizer; },\n/* harmony export */   BartTokenizer: function() { return /* binding */ BartTokenizer; },\n/* harmony export */   BertTokenizer: function() { return /* binding */ BertTokenizer; },\n/* harmony export */   BloomTokenizer: function() { return /* binding */ BloomTokenizer; },\n/* harmony export */   CLIPTokenizer: function() { return /* binding */ CLIPTokenizer; },\n/* harmony export */   CodeGenTokenizer: function() { return /* binding */ CodeGenTokenizer; },\n/* harmony export */   DistilBertTokenizer: function() { return /* binding */ DistilBertTokenizer; },\n/* harmony export */   FalconTokenizer: function() { return /* binding */ FalconTokenizer; },\n/* harmony export */   GPT2Tokenizer: function() { return /* binding */ GPT2Tokenizer; },\n/* harmony export */   GPTNeoXTokenizer: function() { return /* binding */ GPTNeoXTokenizer; },\n/* harmony export */   LlamaTokenizer: function() { return /* binding */ LlamaTokenizer; },\n/* harmony export */   MPNetTokenizer: function() { return /* binding */ MPNetTokenizer; },\n/* harmony export */   MarianTokenizer: function() { return /* binding */ MarianTokenizer; },\n/* harmony export */   MobileBertTokenizer: function() { return /* binding */ MobileBertTokenizer; },\n/* harmony export */   NllbTokenizer: function() { return /* binding */ NllbTokenizer; },\n/* harmony export */   PreTrainedTokenizer: function() { return /* binding */ PreTrainedTokenizer; },\n/* harmony export */   RobertaTokenizer: function() { return /* binding */ RobertaTokenizer; },\n/* harmony export */   SqueezeBertTokenizer: function() { return /* binding */ SqueezeBertTokenizer; },\n/* harmony export */   T5Tokenizer: function() { return /* binding */ T5Tokenizer; },\n/* harmony export */   TokenizerModel: function() { return /* binding */ TokenizerModel; },\n/* harmony export */   WhisperTokenizer: function() { return /* binding */ WhisperTokenizer; },\n/* harmony export */   XLMRobertaTokenizer: function() { return /* binding */ XLMRobertaTokenizer; }\n/* harmony export */ });\n/* harmony import */ var _utils_core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/core.js */ \"(app-pages-browser)/./node_modules/@xenova/transformers/src/utils/core.js\");\n/* harmony import */ var _utils_hub_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/hub.js */ \"(app-pages-browser)/./node_modules/@xenova/transformers/src/utils/hub.js\");\n/* harmony import */ var _utils_maths_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/maths.js */ \"(app-pages-browser)/./node_modules/@xenova/transformers/src/utils/maths.js\");\n/* harmony import */ var _utils_tensor_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/tensor.js */ \"(app-pages-browser)/./node_modules/@xenova/transformers/src/utils/tensor.js\");\n\n/**\n * @file Tokenizers are used to prepare textual inputs for a model.\n * \n * **Example:** Create an `AutoTokenizer` and use it to tokenize a sentence.\n * This will automatically detect the tokenizer type based on the tokenizer class defined in `tokenizer.json`.\n * ```javascript\n * import { AutoTokenizer } from '@xenova/transformers';\n * \n * let tokenizer = await AutoTokenizer.from_pretrained('bert-base-uncased');\n * let { input_ids } = await tokenizer('I love transformers!');\n * // Tensor {\n * //   data: BigInt64Array(6) [101n, 1045n, 2293n, 19081n, 999n, 102n],\n * //   dims: [1, 6],\n * //   type: 'int64',\n * //   size: 6,\n * // }\n * ```\n * \n * @module tokenizers\n */\n\n\n\n\n\n\n\n\n/**\n * @typedef {import('./utils/hub.js').PretrainedOptions} PretrainedOptions\n */\n\n/**\n * Loads a tokenizer from the specified path.\n * @param {string} pretrained_model_name_or_path The path to the tokenizer directory.\n * @param {PretrainedOptions} options Additional options for loading the tokenizer.\n * @returns {Promise<Array>} A promise that resolves with information about the loaded tokenizer.\n */\nasync function loadTokenizer(pretrained_model_name_or_path, options) {\n\n    let info = await Promise.all([\n        (0,_utils_hub_js__WEBPACK_IMPORTED_MODULE_1__.getModelJSON)(pretrained_model_name_or_path, 'tokenizer.json', true, options),\n        (0,_utils_hub_js__WEBPACK_IMPORTED_MODULE_1__.getModelJSON)(pretrained_model_name_or_path, 'tokenizer_config.json', true, options),\n    ])\n    return info;\n}\n\n/**\n * Helper method to construct a pattern from a config object.\n * @param {Object} pattern The pattern object.\n * @param {boolean} invert Whether to invert the pattern (only applicable for Regex patterns).\n * @returns {RegExp|string|null} The compiled pattern.\n */\nfunction createPattern(pattern, invert = true) {\n\n    if (pattern.Regex) {\n        // NOTE: if invert is true, we wrap the pattern in a group so that it is kept when performing .split()\n        return new RegExp(invert ? pattern.Regex : `(${pattern.Regex})`, 'gu');\n\n    } else if (pattern.String) {\n        return pattern.String;\n\n    } else {\n        console.warn('Unknown pattern type:', pattern)\n        return null;\n    }\n}\n\n/**\n * Clean up a list of simple English tokenization artifacts like spaces before punctuations and abbreviated forms\n * @param {string} text The text to clean up.\n * @returns {string} The cleaned up text.\n */\nfunction clean_up_tokenization(text) {\n    // Clean up a list of simple English tokenization artifacts\n    // like spaces before punctuations and abbreviated forms\n    return text.replace(/ \\./g, '.')\n        .replace(/ \\?/g, '?')\n        .replace(/ \\!/g, '!')\n        .replace(/ ,/g, ',')\n        .replace(/ \\' /g, \"'\")\n        .replace(/ n\\'t/g, \"n't\")\n        .replace(/ \\'m/g, \"'m\")\n        .replace(/ \\'s/g, \"'s\")\n        .replace(/ \\'ve/g, \"'ve\")\n        .replace(/ \\'re/g, \"'re\");\n}\n\n/**\n * Helper function to fuse consecutive values in an array equal to the specified value.\n * @param {Array} arr The input array\n * @param {any} value The value to fuse on.\n */\nfunction fuse(arr, value) {\n    let fused = [];\n    let i = 0;\n    while (i < arr.length) {\n        fused.push(arr[i])\n        if (arr[i] !== value) {\n            ++i;\n            continue;\n        }\n\n        while (i < arr.length && arr[i] === value) {\n            ++i;\n        }\n    }\n\n    return fused;\n}\n\n/**\n * Split a string on whitespace.\n * @param {string} text The text to split.\n * @returns {string[]} The split string.\n */\nfunction whitespace_split(text) {\n    return text.match(/\\S+/g) || [];\n}\n\nconst PUNCTUATION_REGEX = '\\\\p{P}\\\\u0021-\\\\u002F\\\\u003A-\\\\u0040\\\\u005B-\\\\u0060\\\\u007B-\\\\u007E';\n\n/**\n * Abstract base class for tokenizer models.\n *\n * @extends Callable\n */\nclass TokenizerModel extends _utils_core_js__WEBPACK_IMPORTED_MODULE_0__.Callable {\n    /**\n     * Creates a new instance of TokenizerModel.\n     * @param {Object} config The configuration object for the TokenizerModel.\n     */\n    constructor(config) {\n        super();\n        this.config = config;\n\n        /** @type {string[]} */\n        this.vocab = [];\n\n        /**\n         * A mapping of tokens to ids.\n         * @type {Map<string, number>}\n         */\n        this.tokens_to_ids = new Map();\n\n        this.unk_token_id = undefined;\n        this.unk_token = undefined;\n        this.end_of_word_suffix = undefined;\n\n        /** @type {boolean} Whether to fuse unknown tokens when encoding. Defaults to false. */\n        this.fuse_unk = false;\n    }\n\n    /**\n     * Instantiates a new TokenizerModel instance based on the configuration object provided.\n     * @param {Object} config The configuration object for the TokenizerModel.\n     * @param {...*} args Optional arguments to pass to the specific TokenizerModel constructor.\n     * @returns {TokenizerModel} A new instance of a TokenizerModel.\n     * @throws Will throw an error if the TokenizerModel type in the config is not recognized.\n     */\n    static fromConfig(config, ...args) {\n        switch (config.type) {\n            case 'WordPiece':\n                return new WordPieceTokenizer(config);\n            case 'Unigram':\n                // @ts-ignore\n                return new Unigram(config, ...args);\n\n            case 'BPE':\n                // @ts-ignore\n                return new BPE(config, ...args);\n            default:\n                throw new Error(`Unknown TokenizerModel type: ${config.type}`);\n        }\n    }\n\n    /**\n     * Internal function to call the TokenizerModel instance.\n     * @param {string[]} tokens The tokens to encode.\n     * @returns {number[]} The encoded token IDs.\n     */\n    _call(tokens) {\n        return this.encode(tokens);\n    }\n\n    /**\n     * Encodes a list of tokens into a list of token IDs.\n     * @param {string[]} tokens The tokens to encode.\n     * @returns {number[]} The encoded token IDs.\n     * @throws Will throw an error if not implemented in a subclass.\n     */\n    encode(tokens) {\n        throw Error(\"encode should be implemented in subclass.\")\n    }\n\n    /**\n     * Converts a list of tokens into a list of token IDs.\n     * @param {string[]} tokens The tokens to convert.\n     * @returns {number[]} The converted token IDs.\n     */\n    convert_tokens_to_ids(tokens) {\n        let ids = tokens.map(t => this.tokens_to_ids.get(t) ?? this.unk_token_id);\n\n        if (this.fuse_unk) {\n            // Fuse unknown tokens\n            ids = fuse(ids, this.unk_token_id);\n        }\n        return ids;\n    }\n\n    /**\n     * Converts a list of token IDs into a list of tokens.\n     * @param {number[]} ids The token IDs to convert.\n     * @returns {string[]} The converted tokens.\n     */\n    convert_ids_to_tokens(ids) {\n        return ids.map(i => this.vocab[i] ?? this.unk_token);\n    }\n}\n\n/**\n * A subclass of TokenizerModel that uses WordPiece encoding to encode tokens.\n * @extends TokenizerModel\n */\nclass WordPieceTokenizer extends TokenizerModel {\n    /**\n     * @param {Object} config The configuration object.\n     * @param {Map<string, number>} config.vocab A mapping of tokens to ids.\n     * @param {string} config.unk_token The unknown token string.\n     * @param {string} config.continuing_subword_prefix The prefix to use for continuing subwords.\n     */\n    constructor(config) {\n        super(config);\n        /**\n         * A mapping of tokens to ids.\n         * @type {Map<string, number>}\n         */\n        this.tokens_to_ids = config.vocab;\n\n        /**\n         * The id of the unknown token.\n         * @type {number}\n         */\n        this.unk_token_id = this.tokens_to_ids.get(config.unk_token);\n\n        /**\n         * The unknown token string.\n         * @type {string}\n         */\n        this.unk_token = config.unk_token;\n\n        /**\n         * An array of tokens.\n         * @type {string[]}\n         */\n        this.vocab = new Array(this.tokens_to_ids.size);\n\n        for (const [key, value] of this.tokens_to_ids) {\n            this.vocab[value] = key;\n        }\n    }\n\n    /**\n     * Encodes an array of tokens using WordPiece encoding.\n     * @param {Array} tokens The tokens to encode.\n     * @returns {Array} An array of encoded tokens.\n     */\n    encode(tokens) {\n        let outputTokens = [];\n        for (let token of tokens) {\n            let chars = [...token];\n            // TODO add\n            // if len(chars) > self.max_input_chars_per_word:\n            //     output_tokens.append(self.unk_token)\n            //     continue\n\n            let isUnknown = false;\n            let start = 0;\n            let subTokens = [];\n\n            while (start < chars.length) {\n                let end = chars.length;\n                let currentSubstring = null;\n                while (start < end) {\n                    let substr = chars.slice(start, end).join('');\n\n                    if (start > 0) {\n                        substr = this.config.continuing_subword_prefix + substr;\n                    }\n                    if (this.tokens_to_ids.has(substr)) {\n                        currentSubstring = substr;\n                        break;\n                    }\n\n                    --end;\n                }\n                if (currentSubstring === null) {\n                    isUnknown = true;\n                    break;\n                }\n                subTokens.push(currentSubstring);\n                start = end;\n            }\n            if (isUnknown) {\n                outputTokens.push(this.unk_token);\n            } else {\n                outputTokens.push(...subTokens);\n            }\n        }\n\n        return outputTokens;\n    }\n\n}\n\n/**\n * Class representing a Unigram tokenizer model.\n * @extends TokenizerModel\n */\nclass Unigram extends TokenizerModel {\n    /**\n     * Create a new Unigram tokenizer model.\n     * @param {Object} config The configuration object for the Unigram model.\n     * @param {number} config.unk_id The ID of the unknown token\n     * @param {Map<string, number>} config.vocab A mapping of tokens to scores.\n     * @param {Object} moreConfig Additional configuration object for the Unigram model.\n     */\n    constructor(config, moreConfig) {\n        super(config);\n\n        this.vocab = new Array(config.vocab.size);\n        this.scores = new Array(config.vocab.size);\n        let count = 0;\n        config.vocab.forEach((value, key) => {\n            this.vocab[count] = key;\n            this.scores[count] = value;\n            ++count;\n        });\n\n        this.unk_token_id = config.unk_id;\n        this.unk_token = this.vocab[config.unk_id];\n\n        this.tokens_to_ids = new Map(this.vocab.map((x, i) => [x, i]));\n        this.bosToken = ' '; // beginning of a sentence token\n\n        this.bosTokenId = this.tokens_to_ids.get(this.bosToken); // NOTE: may be undefined\n        this.eosToken = moreConfig.eos_token;\n\n        this.eosTokenId = this.tokens_to_ids.get(this.eosToken);\n        this.unkToken = this.vocab[this.unk_token_id];\n\n        this.minScore = (0,_utils_maths_js__WEBPACK_IMPORTED_MODULE_2__.min)(this.scores)[0];\n\n        this.unkScore = this.minScore - 10.0;\n        this.scores[this.unk_token_id] = this.unkScore;\n\n        this.trie = new CharTrie();\n        this.trie.extend(this.vocab);\n\n        // NOTE: `fuse_unk` is hardcoded to true for Unigram models\n        // See: https://github.com/huggingface/tokenizers/blob/b58227c7f1ccf8b73ee2268354336da56d91e492/tokenizers/src/models/unigram/model.rs#L119\n        this.fuse_unk = true;\n    }\n\n    /**\n     * Populates lattice nodes.\n     * @param {TokenLattice} lattice The token lattice to populate with nodes.\n     */\n    populateNodes(lattice) {\n        const sentence = lattice.sentence;\n        const len = sentence.length;\n        let beginPos = 0;\n        while (beginPos < len) {\n            const mblen = 1;\n            let hasSingleNode = false;\n            const tokens = [];\n\n            for (let token of this.trie.commonPrefixSearch(sentence.slice(beginPos))) {\n                tokens.push(token);\n                const tokenId = this.tokens_to_ids.get(token);\n                const tokenScore = this.scores[tokenId];\n                const n = token.length;\n                lattice.insert(beginPos, n, tokenScore, tokenId);\n                if (!hasSingleNode && n === mblen) {\n                    hasSingleNode = true;\n                }\n            }\n            if (!hasSingleNode) {\n                lattice.insert(beginPos, mblen, this.unkScore, this.unk_token_id);\n            }\n            beginPos += mblen;\n        }\n    }\n\n    /**\n     * Encodes an array of tokens into an array of subtokens using the unigram model.\n     *\n     * @param {string} normalized The normalized string.\n     * @returns {string[]} An array of subtokens obtained by encoding the input tokens using the unigram model.\n     */\n    tokenize(normalized) {\n        const lattice = new TokenLattice(normalized, this.bosTokenId, this.eosTokenId);\n        this.populateNodes(lattice);\n        return lattice.tokens();\n    }\n\n    /**\n     * Encodes an array of tokens using WordPiece encoding.\n     * @param {Array} tokens The tokens to encode.\n     * @returns {Array} An array of encoded tokens.\n     */\n    encode(tokens) {\n        let toReturn = [];\n        for (let token of tokens) {\n            const tokenized = this.tokenize(token);\n            toReturn.push(...tokenized);\n        }\n        return toReturn;\n    }\n\n}\n\n/**\n * Returns list of utf-8 byte and a mapping to unicode strings.\n * Specifically avoids mapping to whitespace/control characters the BPE code barfs on.\n * @returns {Object} Object with utf-8 byte keys and unicode string values.\n */\nconst BYTES_TO_UNICODE = (() => {\n    // Returns list of utf-8 byte and a mapping to unicode strings.\n    // We specifically avoids mapping to whitespace/control characters\n    // the bpe code barfs on.\n\n    const bs = [\n        ...Array.from({ length: \"~\".charCodeAt(0) - \"!\".charCodeAt(0) + 1 }, (_, i) => i + \"!\".charCodeAt(0)),\n        ...Array.from({ length: \"¬\".charCodeAt(0) - \"¡\".charCodeAt(0) + 1 }, (_, i) => i + \"¡\".charCodeAt(0)),\n        ...Array.from({ length: \"ÿ\".charCodeAt(0) - \"®\".charCodeAt(0) + 1 }, (_, i) => i + \"®\".charCodeAt(0)),\n    ];\n    let cs = bs.slice();\n    let n = 0;\n    for (let b = 0; b < 256; ++b) {\n        if (!bs.includes(b)) {\n            bs.push(b);\n            cs.push(256 + n);\n            n += 1;\n        }\n    }\n    let ccs = cs.map(n => String.fromCharCode(n));\n    return Object.fromEntries(bs.map((b, i) => [b, ccs[i]]));\n})();\n\nconst UNICODE_TO_BYTES = (0,_utils_core_js__WEBPACK_IMPORTED_MODULE_0__.reverseDictionary)(BYTES_TO_UNICODE);\n\n/**\n * BPE class for encoding text into Byte-Pair-Encoding (BPE) tokens.\n * @extends TokenizerModel\n */\nclass BPE extends TokenizerModel {\n    /**\n     * Create a BPE instance.\n     * @param {Object} config The configuration object for BPE.\n     * @param {Map<string, number>} config.vocab A mapping of tokens to ids.\n     * @param {string} config.unk_token The unknown token used for out of vocabulary words.\n     * @param {string} config.end_of_word_suffix The suffix to place at the end of each word.\n     * @param {Array} config.merges An array of BPE merges as strings.\n     */\n    constructor(config) {\n        super(config);\n\n        this.BPE_SPLIT_TOKEN = ' ';\n\n        this.tokens_to_ids = config.vocab;\n\n        this.unk_token_id = this.tokens_to_ids.get(config.unk_token);\n        this.unk_token = config.unk_token;\n\n        this.vocab = new Array(this.tokens_to_ids.size);\n        for (const [key, value] of this.tokens_to_ids) {\n            this.vocab[value] = key;\n        }\n\n        this.bpe_ranks = Object.fromEntries(config.merges.map((x, i) => [x, i]));\n        this.merges = config.merges.map(x => x.split(this.BPE_SPLIT_TOKEN));\n\n        this.end_of_word_suffix = config.end_of_word_suffix;\n\n        this.byte_fallback = this.config.byte_fallback ?? false;\n\n        if (this.byte_fallback) {\n            this.text_encoder = new TextEncoder();\n        }\n\n        this.cache = Object.create(null);\n\n        this.fuse_unk ??= this.config.fuse_unk;\n    }\n\n    /**\n     * Get all the possible pairs of characters in a word.\n     * @param {string[]} word The word to get pairs from.\n     * @returns {Array} An array of pairs.\n     */\n    get_pairs(word) {\n        let pairs = new Set();\n        let prev_char = word[0];\n        for (let i = 1; i < word.length; ++i) {\n            let char = word[i];\n            pairs.add(prev_char + this.BPE_SPLIT_TOKEN + char);\n            prev_char = char;\n        }\n        return Array.from(pairs);\n    }\n\n    /**\n     * Apply Byte-Pair-Encoding (BPE) to a given token.\n     * @param {string} token The token to encode.\n     * @returns {string} The BPE encoded token.\n     */\n    bpe(token) {\n        if (token in this.cache) {\n            return this.cache[token];\n        }\n        let word = Array.from(token);\n        if (this.end_of_word_suffix) {\n            word[word.length - 1] += this.end_of_word_suffix;\n        }\n        let pairs = this.get_pairs(word);\n\n        if (!pairs.length) {\n            if (this.end_of_word_suffix) {\n                token += this.end_of_word_suffix;\n            }\n            return token;\n        }\n\n        while (true) {\n            let bigram = pairs.reduce((a, b) => {\n                let c = this.bpe_ranks[a] ?? Infinity\n                let d = this.bpe_ranks[b] ?? Infinity\n                return c <= d ? a : b;\n            });\n            if (!(bigram in this.bpe_ranks)) {\n                break;\n            }\n            let [first, second] = bigram.split(this.BPE_SPLIT_TOKEN);\n            let new_word = [];\n            let i = 0;\n            let j = -1;\n\n            while (i < word.length) {\n                try {\n                    j = word.indexOf(first, i);\n                    if (j === -1) throw \"Error\";\n                } catch (e) {\n                    new_word.push(...word.slice(i));\n                    break;\n                }\n                new_word.push(...word.slice(i, j));\n                i = j;\n\n                if (word[i] === first && i < word.length - 1 && word[i + 1] === second) {\n                    new_word.push(first + second);\n                    i += 2;\n                } else {\n                    new_word.push(word[i]);\n                    i += 1;\n                }\n            }\n            word = new_word\n            if (word.length === 1) {\n                break;\n            } else {\n                pairs = this.get_pairs(word);\n            }\n        }\n        let final_word = word.join(this.BPE_SPLIT_TOKEN);\n        this.cache[token] = final_word;\n        return final_word;\n    }\n\n    /**\n     * Encodes the input sequence of tokens using the BPE algorithm and returns the resulting subword tokens.\n     * @param {Array} tokens The input sequence of tokens to encode.\n     * @returns {Array} The resulting subword tokens after applying the BPE algorithm to the input sequence of tokens.\n     */\n    encode(tokens) {\n        let outputTokens = [];\n\n        for (let token of tokens) {\n            let bpe_token_list = this.bpe(token).split(this.BPE_SPLIT_TOKEN);\n\n            for (let t of bpe_token_list) {\n                if (this.tokens_to_ids.has(t)) {\n                    outputTokens.push(t);\n                } else {\n                    if (this.byte_fallback) {\n                        outputTokens.push(\n                            ...Array.from(this.text_encoder.encode(t))\n                                .map(x => `<0x${x.toString(16).toUpperCase().padStart(2, '0')}>`)\n                        );\n                    } else {\n                        outputTokens.push(this.unk_token);\n                    }\n                }\n            }\n        }\n\n        return outputTokens;\n    }\n\n}\n\n/**\n * A base class for text normalization.\n * @abstract\n */\nclass Normalizer extends _utils_core_js__WEBPACK_IMPORTED_MODULE_0__.Callable {\n    /**\n     * @param {Object} config The configuration object for the normalizer.\n     */\n    constructor(config) {\n        super();\n        this.config = config;\n    }\n\n    /**\n     * Factory method for creating normalizers from config objects.\n     * @static\n     * @param {Object} config The configuration object for the normalizer.\n     * @returns {Normalizer} A Normalizer object.\n     * @throws {Error} If an unknown Normalizer type is specified in the config.\n     */\n    static fromConfig(config) {\n        if (config === null) return null;\n        switch (config.type) {\n            case 'BertNormalizer':\n                return new BertNormalizer(config);\n            case 'Precompiled':\n                return new Precompiled(config);\n            case 'Sequence':\n                return new NormalizerSequence(config);\n            case 'Replace':\n                return new Replace(config);\n            case 'NFC':\n                return new NFC(config);\n            case 'NFKD':\n                return new NFKD(config);\n            case 'StripAccents':\n                return new StripAccents(config);\n            case 'Lowercase':\n                return new Lowercase(config);\n            case 'Prepend':\n                return new Prepend(config);\n            default:\n                throw new Error(`Unknown Normalizer type: ${config.type}`);\n        }\n    }\n\n    /**\n     * Normalize the input text.\n     * @abstract\n     * @param {string} text The text to normalize.\n     * @returns {string} The normalized text.\n     * @throws {Error} If this method is not implemented in a subclass.\n     */\n    normalize(text) {\n        throw Error(\"normalize should be implemented in subclass.\")\n    }\n\n    /**\n     * Alias for {@link Normalizer#normalize}.\n     * @param {string} text The text to normalize.\n     * @returns {string} The normalized text.\n     */\n    _call(text) {\n        return this.normalize(text);\n    }\n\n}\n\n/**\n * Replace normalizer that replaces occurrences of a pattern with a given string or regular expression.\n * @extends Normalizer\n */\nclass Replace extends Normalizer {\n    /**\n     * Normalize the input text by replacing the pattern with the content.\n     * @param {string} text The input text to be normalized.\n     * @returns {string} The normalized text after replacing the pattern with the content.\n     */\n    normalize(text) {\n        let pattern = createPattern(this.config.pattern);\n        if (pattern === null) {\n            return text;\n        }\n\n        text = text.replaceAll(pattern, this.config.content)\n\n        return text;\n    }\n}\n\n/**\n * A normalizer that applies Unicode normalization form C (NFC) to the input text.\n * @extends Normalizer\n */\nclass NFC extends Normalizer {\n    /**\n     * Normalize the input text by applying Unicode normalization form C (NFC).\n     * @param {string} text The input text to be normalized.\n     * @returns {string} The normalized text.\n     */\n    normalize(text) {\n        text = text.normalize('NFC')\n        return text;\n    }\n}\n\n/**\n * NFKD Normalizer.\n * @extends Normalizer\n */\nclass NFKD extends Normalizer {\n    /**\n     * Normalize text using NFKD normalization.\n     * @param {string} text The text to be normalized.\n     * @returns {string} The normalized text.\n     */\n    normalize(text) {\n        text = text.normalize('NFKD')\n        return text;\n    }\n}\n\n/**\n * StripAccents normalizer removes all accents from the text.\n * @extends Normalizer\n */\nclass StripAccents extends Normalizer {\n    /**\n     * Remove all accents from the text.\n     * @param {string} text The input text.\n     * @returns {string} The normalized text without accents.\n     */\n    normalize(text) {\n        text = text.replace(/[\\u0300-\\u036f]/g, '');\n        return text;\n    }\n}\n\n/**\n * A Normalizer that lowercases the input string.\n * @extends Normalizer\n */\nclass Lowercase extends Normalizer {\n    /**\n     * Lowercases the input string.\n     * @param {string} text The text to normalize.\n     * @returns {string} The normalized text.\n     */\n    normalize(text) {\n        text = text.toLowerCase();\n        return text;\n    }\n}\n\n/**\n * A Normalizer that prepends a string to the input string.\n * @extends Normalizer\n */\nclass Prepend extends Normalizer {\n    /**\n     * Prepends the input string.\n     * @param {string} text The text to normalize.\n     * @returns {string} The normalized text.\n     */\n    normalize(text) {\n        text = this.config.prepend + text;\n        return text;\n    }\n}\n\n/**\n * A Normalizer that applies a sequence of Normalizers.\n * @extends Normalizer\n */\nclass NormalizerSequence extends Normalizer {\n    /**\n   * Create a new instance of NormalizerSequence.\n   * @param {Object} config The configuration object.\n   * @param {Object[]} config.normalizers An array of Normalizer configuration objects.\n   */\n    constructor(config) {\n        super(config);\n        this.normalizers = config.normalizers.map(x => Normalizer.fromConfig(x));\n    }\n    /**\n    * Apply a sequence of Normalizers to the input text.\n    * @param {string} text The text to normalize.\n    * @returns {string} The normalized text.\n    */\n    normalize(text) {\n        return this.normalizers.reduce((t, normalizer) => {\n            return normalizer.normalize(t);\n        }, text);\n    }\n}\n\n/**\n * A class representing a normalizer used in BERT tokenization.\n * @extends Normalizer\n */\nclass BertNormalizer extends Normalizer {\n    /**\n     * Adds whitespace around any CJK (Chinese, Japanese, or Korean) character in the input text.\n     *\n     * @param {string} text The input text to tokenize.\n     * @returns {string} The tokenized text with whitespace added around CJK characters.\n     */\n    _tokenize_chinese_chars(text) {\n        /* Adds whitespace around any CJK character. */\n        let output = [];\n        for (let i = 0; i < text.length; ++i) {\n            let char = text[i];\n            let cp = char.charCodeAt(0);\n            if (this._is_chinese_char(cp)) {\n                output.push(\" \");\n                output.push(char);\n                output.push(\" \");\n            } else {\n                output.push(char);\n            }\n        }\n        return output.join(\"\");\n    }\n\n    /**\n     * Checks whether the given Unicode codepoint represents a CJK (Chinese, Japanese, or Korean) character.\n     *\n     * A \"chinese character\" is defined as anything in the CJK Unicode block:\n     * https://en.wikipedia.org/wiki/CJK_Unified_Ideographs_(Unicode_block)\n     *\n     * Note that the CJK Unicode block is NOT all Japanese and Korean characters, despite its name.\n     * The modern Korean Hangul alphabet is a different block, as is Japanese Hiragana and Katakana.\n     * Those alphabets are used to write space-separated words, so they are not treated specially\n     * and are handled like all other languages.\n     *\n     * @param {number} cp The Unicode codepoint to check.\n     * @returns {boolean} True if the codepoint represents a CJK character, false otherwise.\n     */\n    _is_chinese_char(cp) {\n        return (\n            (cp >= 0x4E00 && cp <= 0x9FFF)\n            || (cp >= 0x3400 && cp <= 0x4DBF)\n            || (cp >= 0x20000 && cp <= 0x2A6DF)\n            || (cp >= 0x2A700 && cp <= 0x2B73F)\n            || (cp >= 0x2B740 && cp <= 0x2B81F)\n            || (cp >= 0x2B820 && cp <= 0x2CEAF)\n            || (cp >= 0xF900 && cp <= 0xFAFF)\n            || (cp >= 0x2F800 && cp <= 0x2FA1F)\n        )\n    }\n    /**\n     * Strips accents from the given text.\n     * @param {string} text The text to strip accents from.\n     * @returns {string} The text with accents removed.\n     */\n    stripAccents(text) {\n        return text.normalize('NFD').replace(/[\\u0300-\\u036f]/g, '');\n    }\n\n    /**\n     * Normalizes the given text based on the configuration.\n     * @param {string} text The text to normalize.\n     * @returns {string} The normalized text.\n     */\n    normalize(text) {\n        // TODO use rest of config\n        // config.clean_text,\n        // config.handle_chinese_chars,\n        // config.strip_accents,\n        // config.lowercase,\n\n        if (this.config.handle_chinese_chars) {\n            text = this._tokenize_chinese_chars(text);\n        }\n\n        if (this.config.lowercase) {\n            text = text.toLowerCase();\n\n            if (this.config.strip_accents !== false) {\n                text = this.stripAccents(text);\n            }\n        } else if (this.config.strip_accents) {\n            text = this.stripAccents(text);\n        }\n\n        return text;\n    }\n}\n\n/**\n * A callable class representing a pre-tokenizer used in tokenization. Subclasses\n * should implement the `pre_tokenize_text` method to define the specific pre-tokenization logic.\n * @extends Callable\n */\nclass PreTokenizer extends _utils_core_js__WEBPACK_IMPORTED_MODULE_0__.Callable {\n    /**\n   * Factory method that returns an instance of a subclass of `PreTokenizer` based on the provided configuration.\n   *\n   * @static\n   * @param {Object} config A configuration object for the pre-tokenizer.\n   * @returns {PreTokenizer} An instance of a subclass of `PreTokenizer`.\n   * @throws {Error} If the provided configuration object does not correspond to any known pre-tokenizer.\n   */\n    static fromConfig(config) {\n        if (config === null) return null;\n\n        switch (config.type) {\n            case 'BertPreTokenizer':\n                return new BertPreTokenizer(config);\n            case 'Sequence':\n                return new PreTokenizerSequence(config);\n            case 'WhitespaceSplit':\n                return new WhitespaceSplit(config);\n            case 'Metaspace':\n                return new MetaspacePreTokenizer(config);\n\n            case 'ByteLevel':\n                return new ByteLevelPreTokenizer(config);\n            case 'Split':\n                return new SplitPreTokenizer(config);\n            case 'Punctuation':\n                return new PunctuationPreTokenizer(config);\n            case 'Digits':\n                return new DigitsPreTokenizer(config);\n            default:\n                throw new Error(`Unknown PreTokenizer type: ${config.type}`);\n        }\n    }\n\n    /**\n   * Method that should be implemented by subclasses to define the specific pre-tokenization logic.\n   *\n   * @abstract\n   * @param {string} text The text to pre-tokenize.\n   * @returns {string[]} The pre-tokenized text.\n   * @throws {Error} If the method is not implemented in the subclass.\n   */\n    pre_tokenize_text(text) {\n        throw Error(\"pre_tokenize_text should be implemented in subclass.\")\n    }\n\n    /**\n     * Tokenizes the given text into pre-tokens.\n     * @param {string|string[]} text The text or array of texts to pre-tokenize.\n     * @returns {string[]} An array of pre-tokens.\n     */\n    pre_tokenize(text) {\n        let result = [];\n        if (Array.isArray(text)) {\n            result = text.map(x => this.pre_tokenize_text(x))\n        } else {\n            result = this.pre_tokenize_text(text);\n        }\n        return result.flat();\n    }\n\n    /**\n     * Alias for {@link PreTokenizer#pre_tokenize}.\n     * @param {string|string[]} text The text or array of texts to pre-tokenize.\n     * @returns {string[]} An array of pre-tokens.\n     */\n    _call(text) {\n        return this.pre_tokenize(text);\n    }\n}\n\n/**\n * @extends PreTokenizer\n */\nclass BertPreTokenizer extends PreTokenizer {\n    /**\n     * A PreTokenizer that splits text into wordpieces using a basic tokenization scheme\n     * similar to that used in the original implementation of BERT.\n     * \n     * @param {Object} config The configuration object.\n     */\n    constructor(config) {\n        super();\n        // Construct a pattern which matches the rust implementation:\n        // https://github.com/huggingface/tokenizers/blob/b4fcc9ce6e4ad5806e82826f816acfdfdc4fcc67/tokenizers/src/pre_tokenizers/bert.rs#L11\n        // Equivalent to removing whitespace and splitting on punctuation (both \\p{P} and other ascii characters)\n        this.pattern = new RegExp(`[^\\\\s${PUNCTUATION_REGEX}]+|[${PUNCTUATION_REGEX}]`, 'gu');\n    }\n    /**\n     * Tokenizes a single text using the BERT pre-tokenization scheme.\n     * \n     * @param {string} text The text to tokenize.\n     * @returns {string[]} An array of tokens.\n     */\n    pre_tokenize_text(text) {\n        return text.trim().match(this.pattern) || [];\n    }\n}\n\n/**\n * A pre-tokenizer that splits text into Byte-Pair-Encoding (BPE) subwords.\n * @extends PreTokenizer\n */\nclass ByteLevelPreTokenizer extends PreTokenizer {\n    /**\n     * Creates a new instance of the `ByteLevelPreTokenizer` class.\n     * @param {Object} config The configuration object.\n     */\n    constructor(config) {\n        super();\n        this.config = config;\n\n        /**\n         * @type {boolean} Whether to add a leading space to the first word.\n         * This allows to treat the leading word just as any other word.\n         */\n        this.add_prefix_space = this.config.add_prefix_space;\n\n        /**\n         * @type {boolean} Whether the post processing step should trim offsets\n         * to avoid including whitespaces.\n         * @todo Use this in the pretokenization step.\n         */\n        this.trim_offsets = this.config.trim_offsets;\n\n        /**\n         * @type {boolean} Whether to use the standard GPT2 regex for whitespace splitting.\n         * Set it to False if you want to use your own splitting. Defaults to true.\n         */\n        this.use_regex = this.config.use_regex ?? true;\n        this.pattern = /'s|'t|'re|'ve|'m|'ll|'d| ?\\p{L}+| ?\\p{N}+| ?[^\\s\\p{L}\\p{N}]+|\\s+(?!\\S)|\\s+/gu;\n\n        this.byte_encoder = BYTES_TO_UNICODE;\n        this.text_encoder = new TextEncoder();\n    }\n\n    /**\n     * Tokenizes a single piece of text using byte-level tokenization.\n     * @param {string} text The text to tokenize.\n     * @returns {string[]} An array of tokens.\n     */\n    pre_tokenize_text(text) {\n        // Split on whitespace and punctuation\n        let tokens = this.use_regex ? (text.match(this.pattern) || []) : [text];\n\n        return tokens.map(token => {\n            if (this.add_prefix_space && !token.startsWith(' ')) {\n                token = ' ' + token;\n            }\n\n            // Maps all our bytes to unicode strings, avoiding control tokens of the BPE (spaces in our case)\n            token = Array.from(this.text_encoder.encode(token), byte => this.byte_encoder[byte]).join('');\n\n            return token;\n        });\n    }\n}\n\n/**\n * @typedef {'removed'|'isolated'|'mergedWithPrevious'|'mergedWithNext'|'contiguous'} SplitDelimiterBehavior\n */\n\n/**\n * Splits text using a given pattern.\n * @extends PreTokenizer\n */\nclass SplitPreTokenizer extends PreTokenizer {\n    /**\n     * @param {Object} config The configuration options for the pre-tokenizer.\n     * @param {Object} config.pattern The pattern used to split the text. Can be a string or a regex object.\n     * @param {string|undefined} config.pattern.String The string to use for splitting. Only defined if the pattern is a string.\n     * @param {string|undefined} config.pattern.Regex The regex to use for splitting. Only defined if the pattern is a regex.\n     * @param {SplitDelimiterBehavior} config.behavior The behavior to use when splitting.\n     * @param {boolean} config.invert Whether to split (invert=false) or match (invert=true) the pattern.\n     */\n    constructor(config) {\n        super();\n        this.config = config;\n        // TODO support all behaviours (config.behavior)\n\n        this.pattern = createPattern(this.config.pattern, this.config.invert);\n    }\n\n    /**\n     * Tokenizes text by splitting it using the given pattern.\n     * @param {string} text The text to tokenize.\n     * @returns {string[]} An array of tokens.\n     */\n    pre_tokenize_text(text) {\n        if (this.pattern === null) {\n            return [];\n        }\n\n        if (this.config.invert) {\n            return text.match(this.pattern) || [];\n        } else {\n            return text.split(this.pattern).filter(x => x);\n        }\n    }\n}\n\n/**\n * Splits text based on punctuation.\n * @extends PreTokenizer\n */\nclass PunctuationPreTokenizer extends PreTokenizer {\n    /**\n     * @param {Object} config The configuration options for the pre-tokenizer.\n     * @param {SplitDelimiterBehavior} config.behavior The behavior to use when splitting.\n     */\n    constructor(config) {\n        super();\n        this.config = config;\n        this.pattern = new RegExp(`[^${PUNCTUATION_REGEX}]+|[${PUNCTUATION_REGEX}]+`, 'gu');\n    }\n\n    /**\n     * Tokenizes text by splitting it using the given pattern.\n     * @param {string} text The text to tokenize.\n     * @returns {string[]} An array of tokens.\n     */\n    pre_tokenize_text(text) {\n        return text.match(this.pattern) || [];\n    }\n}\n\n\n/**\n * Splits text based on digits.\n * @extends PreTokenizer\n */\nclass DigitsPreTokenizer extends PreTokenizer {\n    /**\n     * @param {Object} config The configuration options for the pre-tokenizer.\n     * @param {boolean} config.individual_digits Whether to split on individual digits.\n     */\n    constructor(config) {\n        super();\n        this.config = config;\n\n        // Construct a pattern which matches the rust implementation:\n        const digit_pattern = `[^\\\\d]+|\\\\d${this.config.individual_digits ? '' : '+'}`;\n        this.pattern = new RegExp(digit_pattern, 'gu');\n    }\n\n    /**\n     * Tokenizes text by splitting it using the given pattern.\n     * @param {string} text The text to tokenize.\n     * @returns {string[]} An array of tokens.\n     */\n    pre_tokenize_text(text) {\n        return text.match(this.pattern) || [];\n    }\n}\n\n/**\n * @extends Callable\n */\nclass PostProcessor extends _utils_core_js__WEBPACK_IMPORTED_MODULE_0__.Callable {\n\n    /**\n     * @param {Object} config The configuration for the post-processor.\n     */\n    constructor(config) {\n        super();\n        this.config = config;\n    }\n\n    /**\n     * Factory method to create a PostProcessor object from a configuration object.\n     *\n     * @param {Object} config Configuration object representing a PostProcessor.\n     * @returns {PostProcessor} A PostProcessor object created from the given configuration.\n     * @throws {Error} If an unknown PostProcessor type is encountered.\n     */\n    static fromConfig(config) {\n        if (config === null) return null;\n        switch (config.type) {\n            case 'TemplateProcessing':\n                return new TemplateProcessing(config);\n\n            case 'ByteLevel':\n                return new ByteLevelPostProcessor(config);\n\n            case 'RobertaProcessing':\n                return new RobertaProcessing(config);\n\n            default:\n                throw new Error(`Unknown PostProcessor type: ${config.type}`);\n        }\n    }\n\n    /**\n     * Method to be implemented in subclass to apply post-processing on the given tokens.\n     *\n     * @param {Array} tokens The input tokens to be post-processed.\n     * @param {...*} args Additional arguments required by the post-processing logic.\n     * @returns {Array} The post-processed tokens.\n     * @throws {Error} If the method is not implemented in subclass.\n     */\n    post_process(tokens, ...args) {\n        throw Error(\"post_process should be implemented in subclass.\")\n    }\n\n    /**\n     * Alias for {@link PostProcessor#post_process}.\n     * @param {Array} tokens The text or array of texts to post-process.\n     * @param {...*} args Additional arguments required by the post-processing logic.\n     * @returns {Array} An array of post-processed tokens.\n     */\n    _call(tokens, ...args) {\n        return this.post_process(tokens, ...args);\n    }\n}\n\n/**\n * A post-processor that adds special tokens to the beginning and end of the input.\n * @extends PostProcessor\n */\nclass RobertaProcessing extends PostProcessor {\n    /**\n     * @param {Object} config The configuration for the post-processor.\n     * @param {string[]} config.cls The special tokens to add to the beginning of the input.\n     * @param {string[]} config.sep The special tokens to add to the end of the input.\n     */\n    constructor(config) {\n        super(config);\n        // TODO use all of config: add_prefix_space, trim_offsets\n\n        this.cls = config.cls[0];\n        this.sep = config.sep[0];\n    }\n\n    /**\n     * Adds the special tokens to the beginning and end of the input.\n     * @param {string[]} tokens The input tokens.\n     * @param {string[]|null} tokens_pair An optional second set of input tokens.\n     * @returns {string[]} The input tokens with the special tokens added to the beginning and end.\n     */\n    post_process(tokens, tokens_pair = null) {\n        tokens = (0,_utils_core_js__WEBPACK_IMPORTED_MODULE_0__.mergeArrays)([this.cls], tokens, [this.sep]);\n\n        // NOTE: It is intended to add 2 EOS tokens after the first set of tokens\n        // https://github.com/huggingface/tokenizers/issues/983\n        if (tokens_pair !== null) {\n            tokens = (0,_utils_core_js__WEBPACK_IMPORTED_MODULE_0__.mergeArrays)(tokens, [this.sep], tokens_pair, [this.sep]);\n        }\n        return tokens;\n    }\n}\n\n/**\n * Post processor that replaces special tokens in a template with actual tokens.\n * @extends PostProcessor\n */\nclass TemplateProcessing extends PostProcessor {\n    /**\n     * Creates a new instance of `TemplateProcessing`.\n     * @param {Object} config The configuration options for the post processor.\n     * @param {Array} config.single The template for a single sequence of tokens.\n     * @param {Array} config.pair The template for a pair of sequences of tokens.\n     */\n    constructor(config) {\n        super(config);\n\n        this.single = config.single;\n        this.pair = config.pair;\n    }\n\n    /**\n     * Replaces special tokens in the template with actual tokens.\n     * @param {Array} tokens The list of tokens for the first sequence.\n     * @param {Array} [tokens_pair=null] The list of tokens for the second sequence (optional).\n     * @returns {Array} The list of tokens with the special tokens replaced with actual tokens.\n     */\n    post_process(tokens, tokens_pair = null) {\n        let type = tokens_pair === null ? this.single : this.pair\n\n        let toReturn = [];\n        for (let item of type) {\n            if ('SpecialToken' in item) {\n                toReturn.push(item.SpecialToken.id);\n\n            } else if ('Sequence' in item) {\n                if (item.Sequence.id === 'A') {\n                    toReturn = (0,_utils_core_js__WEBPACK_IMPORTED_MODULE_0__.mergeArrays)(toReturn, tokens);\n\n                } else if (item.Sequence.id === 'B') {\n                    toReturn = (0,_utils_core_js__WEBPACK_IMPORTED_MODULE_0__.mergeArrays)(toReturn, tokens_pair);\n                }\n            }\n        }\n        return toReturn;\n    }\n}\n\n/**\n * A PostProcessor that returns the given tokens as is.\n * @extends PostProcessor\n */\nclass ByteLevelPostProcessor extends PostProcessor {\n    /**\n     * Post process the given tokens.\n     * @param {string[]} tokens The tokens to be post processed.\n     * @returns {string[]} The post processed tokens.\n     */\n    post_process(tokens) {\n        return tokens;\n    }\n}\n\n/**\n * The base class for token decoders.\n * @extends Callable\n */\nclass Decoder extends _utils_core_js__WEBPACK_IMPORTED_MODULE_0__.Callable {\n\n    /**\n    * Creates an instance of `Decoder`.\n    *\n    * @param {Object} config The configuration object.\n    */\n    constructor(config) {\n        super();\n        this.config = config;\n\n        this.added_tokens = [];\n        this.end_of_word_suffix = null;\n        this.trim_offsets = config.trim_offsets;\n    }\n\n    /**\n   * Creates a decoder instance based on the provided configuration.\n   *\n   * @param {Object} config The configuration object.\n   * @returns {Decoder} A decoder instance.\n   * @throws {Error} If an unknown decoder type is provided.\n   */\n    static fromConfig(config) {\n        switch (config.type) {\n            case 'WordPiece':\n                return new WordPieceDecoder(config);\n            case 'Metaspace':\n                return new MetaspaceDecoder(config);\n            case 'ByteLevel':\n                return new ByteLevelDecoder(config);\n\n            case 'Replace':\n                return new ReplaceDecoder(config);\n            case 'ByteFallback':\n                return new ByteFallback(config);\n            case 'Fuse':\n                return new FuseDecoder(config);\n            case 'Strip':\n                return new StripDecoder(config);\n\n            case 'Sequence':\n                return new DecoderSequence(config);\n\n            default:\n                throw new Error(`Unknown Decoder type: ${config.type}`);\n        }\n    }\n\n    /**\n    * Calls the `decode` method.\n    *\n    * @param {string[]} tokens The list of tokens.\n    * @returns {string} The decoded string.\n    */\n    _call(tokens) {\n        return this.decode(tokens);\n    }\n\n    /**\n    * Decodes a list of tokens.\n    * @param {string[]} tokens The list of tokens.\n    * @returns {string} The decoded string.\n    */\n    decode(tokens) {\n        return this.decode_chain(tokens).join('');\n    }\n\n    /**\n     * Apply the decoder to a list of tokens.\n     * \n     * @param {string[]} tokens The list of tokens.\n     * @returns {string[]} The decoded list of tokens.\n     * @throws {Error} If the `decode_chain` method is not implemented in the subclass.\n     */\n    decode_chain(tokens) {\n        throw Error(\"`decode_chain` should be implemented in subclass.\")\n    }\n\n}\n\nclass ReplaceDecoder extends Decoder {\n    constructor(config) {\n        super(config);\n    }\n\n    /** @type {Decoder['decode_chain']} */\n    decode_chain(tokens) {\n        let pattern = createPattern(this.config.pattern);\n        if (pattern === null) {\n            return tokens;\n        }\n\n        return tokens.map(token => token.replaceAll(pattern, this.config.content))\n    }\n}\n\n\nclass ByteFallback extends Decoder {\n    constructor(config) {\n        super(config);\n\n        this.text_decoder = new TextDecoder();\n    }\n\n    /** @type {Decoder['decode_chain']} */\n    decode_chain(tokens) {\n\n        let new_tokens = [];\n        let previous_byte_tokens = [];\n\n        for (let token of tokens) {\n            let bytes = null;\n            if (token.length === 6 && token.startsWith('<0x') && token.endsWith('>')) {\n                let byte = parseInt(token.slice(3, 5), 16);\n                if (!isNaN(byte)) {\n                    bytes = byte;\n                }\n            }\n            if (bytes !== null) {\n                previous_byte_tokens.push(bytes);\n            } else {\n                if (previous_byte_tokens.length > 0) {\n                    let string = this.text_decoder.decode(Uint8Array.from(previous_byte_tokens));\n                    new_tokens.push(string);\n                    previous_byte_tokens = [];\n                }\n                new_tokens.push(token);\n            }\n        }\n        if (previous_byte_tokens.length > 0) {\n            let string = this.text_decoder.decode(Uint8Array.from(previous_byte_tokens));\n            new_tokens.push(string);\n            previous_byte_tokens = [];\n        }\n\n        return new_tokens;\n    }\n}\n\n/**\n * Fuse simply fuses all tokens into one big string.\n * It's usually the last decoding step anyway, but this decoder\n * exists incase some decoders need to happen after that step\n */\nclass FuseDecoder extends Decoder {\n    constructor(config) {\n        super(config);\n    }\n\n    /** @type {Decoder['decode_chain']} */\n    decode_chain(tokens) {\n        return [tokens.join('')];\n    }\n}\n\nclass StripDecoder extends Decoder {\n    constructor(config) {\n        super(config);\n\n        this.content = this.config.content;\n        this.start = this.config.start;\n        this.stop = this.config.stop;\n    }\n\n    /** @type {Decoder['decode_chain']} */\n    decode_chain(tokens) {\n        return tokens.map(token => {\n            let start_cut = 0;\n            for (let i = 0; i < this.start; ++i) {\n                if (token[i] === this.content) {\n                    start_cut = i + 1;\n                    continue;\n                } else {\n                    break;\n                }\n            }\n\n            let stop_cut = token.length;\n            for (let i = 0; i < this.stop; ++i) {\n                const index = token.length - i - 1;\n                if (token[index] === this.content) {\n                    stop_cut = index;\n                    continue;\n                } else {\n                    break;\n                }\n            }\n\n            return token.slice(start_cut, stop_cut)\n        });\n    }\n}\n\n/**\n * A decoder that decodes a list of WordPiece tokens into a single string.\n * @extends Decoder\n */\nclass WordPieceDecoder extends Decoder {\n\n    /**\n     * Creates a new instance of WordPieceDecoder.\n     * @param {Object} config The configuration object.\n     * @param {string} config.prefix The prefix used for WordPiece encoding.\n     * @param {boolean} config.cleanup Whether to cleanup the decoded string.\n     */\n    constructor(config) {\n        super(config);\n        this.cleanup = config.cleanup;\n    }\n\n    /** @type {Decoder['decode_chain']} */\n    decode_chain(tokens) {\n        return tokens.map((token, i) => {\n            if (i !== 0) {\n                if (token.startsWith(this.config.prefix)) {\n                    // NOTE: .replace() is intended; only replace first occurrence\n                    token = token.replace(this.config.prefix, '');\n                } else {\n                    token = ' ' + token;\n                }\n            }\n            if (this.cleanup) {\n                token = clean_up_tokenization(token)\n            }\n\n            return token;\n        });\n    }\n}\n\n/**\n * Byte-level decoder for tokenization output. Inherits from the `Decoder` class.\n * @extends Decoder\n */\nclass ByteLevelDecoder extends Decoder {\n\n    /**\n     * Create a `ByteLevelDecoder` object.\n     * @param {Object} config Configuration object.\n     */\n    constructor(config) {\n        super(config);\n\n        this.byte_decoder = UNICODE_TO_BYTES;\n        this.text_decoder = new TextDecoder(\"utf-8\", {\n            fatal: false,\n            ignoreBOM: true,\n        });\n\n        this.end_of_word_suffix = null;\n    }\n\n    /**\n     * Convert an array of tokens to string by decoding each byte.\n     * @param {string[]} tokens Array of tokens to be decoded.\n     * @returns {string} The decoded string.\n     */\n    convert_tokens_to_string(tokens) {\n        let text = tokens.join('');\n\n        let byteArray = new Uint8Array([...text].map(c => this.byte_decoder[c]));\n        let decoded_text = this.text_decoder.decode(byteArray);\n        return decoded_text;\n    }\n\n    /** @type {Decoder['decode_chain']} */\n    decode_chain(tokens) {\n        // TODO move to base class (like HF)\n        // tokens === filtered_tokens\n\n        // To avoid mixing byte-level and unicode for byte-level BPT\n        // we need to build string separately for added tokens and byte-level tokens\n        // cf. https://github.com/huggingface/transformers/issues/1133\n        let sub_texts = [];\n        let current_sub_text = [];\n        for (let token of tokens) {\n            // tokens sent here are already filtered, so we don't need to do this\n            // if (skip_special_tokens && this.all_special_ids.includes(token)) {\n            //     continue;\n            // }\n\n            if (this.added_tokens.includes(token)) {\n                if (current_sub_text.length > 0) {\n                    sub_texts.push(this.convert_tokens_to_string(current_sub_text));\n                    current_sub_text = [];\n                }\n                sub_texts.push(token);\n            } else {\n                current_sub_text.push(token);\n            }\n        }\n        if (current_sub_text.length > 0) {\n            sub_texts.push(this.convert_tokens_to_string(current_sub_text));\n        }\n\n        // TODO add spaces_between_special_tokens and clean_up_tokenization_spaces options\n\n        return sub_texts;\n    }\n}\n\n\n/**\n * Apply a sequence of decoders.\n * @extends Decoder\n */\nclass DecoderSequence extends Decoder {\n\n    /**\n     * Creates a new instance of DecoderSequence.\n     * @param {Object} config The configuration object.\n     * @param {Decoder[]} config.decoders The list of decoders to apply.\n     */\n    constructor(config) {\n        super(config);\n        this.decoders = config.decoders.map(x => Decoder.fromConfig(x));\n    }\n\n    /** @type {Decoder['decode_chain']} */\n    decode_chain(tokens) {\n        // Use reduce to apply each decoder to the tokens\n        return this.decoders.reduce((toks, decoder) => {\n            return decoder.decode_chain(toks);\n        }, tokens);\n    }\n\n}\n\n/**\n * This PreTokenizer replaces spaces with the given replacement character, adds a prefix space if requested,\n * and returns a list of tokens.\n * @extends PreTokenizer\n */\nclass MetaspacePreTokenizer extends PreTokenizer {\n    /**\n     * @param {Object} config The configuration object for the MetaspacePreTokenizer.\n     * @param {boolean} config.add_prefix_space Whether to add a prefix space to the first token.\n     * @param {string} config.replacement The character to replace spaces with.\n     * @param {string} [config.str_rep=config.replacement] An optional string representation of the replacement character.\n     */\n    constructor(config) {\n        super();\n\n        this.addPrefixSpace = config.add_prefix_space;\n        this.replacement = config.replacement;\n        this.strRep = config.str_rep || this.replacement;\n    }\n\n    /**\n     * This method takes a list of normalized tokens, replaces spaces with the replacement character,\n     * adds a prefix space if requested, and returns a new list of tokens.\n     * @param {string[]|string} normalizedTokens The list of normalized tokens to pre-tokenize.\n     * @returns {string[]} A new list of pre-tokenized tokens.\n     */\n    pre_tokenize(normalizedTokens) {\n        if (typeof normalizedTokens === 'string') {\n            // Metaspace acts on a list of tokens. If passing in a string, first split on whitespace\n            // NOTE: For some reason, metaspace includes trailing whitespace, so we only trim leading whitespace.\n            // See: https://github.com/huggingface/tokenizers/issues/1250\n            normalizedTokens = normalizedTokens.trimStart().split(/\\s+/);\n        }\n\n        const result = [];\n        for (let token of normalizedTokens) {\n            let normalized = token.replaceAll(' ', this.strRep);\n            if (this.addPrefixSpace && !normalized.startsWith(this.replacement)) {\n                normalized = this.strRep + normalized;\n            }\n            result.push(normalized);\n        }\n        return result;\n    }\n}\n\n/**\n * MetaspaceDecoder class extends the Decoder class and decodes Metaspace tokenization.\n * @extends Decoder\n */\nclass MetaspaceDecoder extends Decoder {\n    /**\n     * Constructs a new MetaspaceDecoder object.\n     * @param {Object} config The configuration object for the MetaspaceDecoder.\n     * @param {boolean} config.add_prefix_space Whether to add a prefix space to the decoded string.\n     * @param {string} config.replacement The string to replace spaces with.\n     */\n    constructor(config) {\n        super(config);\n\n        this.addPrefixSpace = config.add_prefix_space;\n        this.replacement = config.replacement;\n    }\n\n    /** @type {Decoder['decode_chain']} */\n    decode_chain(tokens) {\n        let result = [];\n        for (let i = 0; i < tokens.length; ++i) {\n            let normalized = tokens[i].replaceAll(this.replacement, ' ');\n            if (this.addPrefixSpace && i == 0 && normalized.startsWith(' ')) {\n                normalized = normalized.substring(1);\n            }\n            result.push(normalized);\n        }\n        return result;\n    }\n}\n\n/**\n * A normalizer that applies a precompiled charsmap.\n * This is useful for applying complex normalizations in C++ and exposing them to JavaScript.\n * @extends Normalizer\n * @param {Object} config The configuration object for the Precompiled normalizer.\n * @param {Object} config.precompiled_charsmap The precompiled charsmap object.\n */\nclass Precompiled extends Normalizer {\n    /**\n     * Create a new instance of Precompiled normalizer.\n     * @param {Object} config The configuration object.\n     * @param {any} config.precompiled_charsmap Precompiled chars mapping.\n     */\n    constructor(config) {\n        super(config);\n        this.charsmap = config.precompiled_charsmap;\n    }\n\n    /**\n     * Normalizes the given text by applying the precompiled charsmap.\n     * @param {string} text The text to normalize.\n     * @returns {string} The normalized text.\n     */\n    normalize(text) {\n        // TODO use this.charsmap\n        // For now, we just apply NFKC normalization\n        // https://github.com/huggingface/tokenizers/blob/291b2e23ae81cf94738835852213ce120152d121/bindings/python/py_src/tokenizers/implementations/sentencepiece_bpe.py#L34\n        text = text.normalize('NFKC');\n        return text;\n    }\n}\n\n/**\n * A pre-tokenizer that applies a sequence of pre-tokenizers to the input text.\n * @extends PreTokenizer\n */\nclass PreTokenizerSequence extends PreTokenizer {\n    /**\n     * Creates an instance of PreTokenizerSequence.\n     * @param {Object} config The configuration object for the pre-tokenizer sequence.\n     * @param {Object[]} config.pretokenizers An array of pre-tokenizer configurations.\n     */\n    constructor(config) {\n        super();\n        this.tokenizers = config.pretokenizers.map(x => PreTokenizer.fromConfig(x));\n    }\n\n    /**\n     * Applies each pre-tokenizer in the sequence to the input text in turn.\n     * @param {string|string[]} text The text(s) to pre-tokenize.\n     * @returns {string[]} The pre-tokenized text.\n     */\n    pre_tokenize_text(text) {\n        if (typeof text === 'string') {\n            text = [text];\n        }\n        // Use reduce to apply each tokenizer to the text\n        return this.tokenizers.reduce((preTokenizedText, tokenizer) => {\n            return tokenizer.pre_tokenize(preTokenizedText);\n        }, text);\n    }\n}\n\n/**\n * Splits a string of text by whitespace characters into individual tokens.\n * @extends PreTokenizer\n */\nclass WhitespaceSplit extends PreTokenizer {\n    /**\n     * Creates an instance of WhitespaceSplit.\n     * @param {Object} config The configuration object for the pre-tokenizer sequence.\n     */\n    constructor(config) {\n        super();\n    }\n    /**\n     * Pre-tokenizes the input text by splitting it on whitespace characters.\n     * @param {string} text The text to be pre-tokenized.\n     * @returns {string[]} An array of tokens produced by splitting the input text on whitespace.\n     */\n    pre_tokenize_text(text) {\n        return whitespace_split(text);\n    }\n}\n\nclass PreTrainedTokenizer extends _utils_core_js__WEBPACK_IMPORTED_MODULE_0__.Callable {\n    /**\n     * Create a new PreTrainedTokenizer instance.\n     * @param {Object} tokenizerJSON The JSON of the tokenizer.\n     * @param {Object} tokenizerConfig The config of the tokenizer.\n     */\n    constructor(tokenizerJSON, tokenizerConfig) {\n        super();\n\n        // Construct parts of the tokenizer from the JSON\n        this.normalizer = Normalizer.fromConfig(tokenizerJSON.normalizer);\n        this.pre_tokenizer = PreTokenizer.fromConfig(tokenizerJSON.pre_tokenizer);\n\n        // Convert the vocabulary to a map, if it exists\n        if (tokenizerJSON.model.vocab) {\n            if (!Array.isArray(tokenizerJSON.model.vocab)) {\n                tokenizerJSON.model.vocab = Object.entries(tokenizerJSON.model.vocab);\n            }\n            tokenizerJSON.model.vocab = new Map(tokenizerJSON.model.vocab);\n        }\n        this.model = TokenizerModel.fromConfig(tokenizerJSON.model, tokenizerConfig);\n        this.post_processor = PostProcessor.fromConfig(tokenizerJSON.post_processor);\n\n        // TODO: maybe, allow this to be null; in which case, we use model as decoder too?\n        this.decoder = Decoder.fromConfig(tokenizerJSON.decoder);\n\n\n        // Another slight hack to add `end_of_word_suffix` (if present) to the decoder\n        // This is needed for cases where BPE model and ByteLevel decoder are used\n        // For more information, see https://github.com/xenova/transformers.js/issues/74\n        // TODO: save this to the decoder when exporting?\n        this.decoder.end_of_word_suffix = this.model.end_of_word_suffix;\n\n        // Add added_tokens to model\n        this.special_tokens = [];\n        this.all_special_ids = [];\n        this.added_tokens = [];\n        for (let addedToken of tokenizerJSON.added_tokens) {\n            let id = addedToken.id;\n            let content = addedToken.content;\n\n            this.added_tokens.push(content);\n\n            this.model.tokens_to_ids.set(content, id);\n            this.model.vocab[id] = content;\n\n            if (addedToken.special) {\n                this.special_tokens.push(content);\n                this.all_special_ids.push(id);\n            }\n        }\n\n        // Slight hack, but it prevents code duplication:\n        this.decoder.added_tokens = this.added_tokens;\n\n        this.added_tokens_regex = new RegExp(\n            '(' + this.added_tokens.map(_utils_core_js__WEBPACK_IMPORTED_MODULE_0__.escapeRegExp).join('|') + ')'\n        );\n\n        // Set mask token if present (otherwise will be undefined, which is fine)\n        this.mask_token = this.getToken(tokenizerConfig, 'mask_token');\n        this.mask_token_id = this.model.tokens_to_ids.get(this.mask_token);\n\n        this.pad_token = this.getToken(tokenizerConfig, 'pad_token', 'eos_token');\n        this.pad_token_id = this.model.tokens_to_ids.get(this.pad_token);\n\n        this.sep_token = this.getToken(tokenizerConfig, 'sep_token');\n        this.sep_token_id = this.model.tokens_to_ids.get(this.sep_token);\n\n        this.model_max_length = tokenizerConfig.model_max_length;\n\n        /** @type {boolean} Whether or not to strip the text when tokenizing (removing excess spaces before and after the string). */\n        this.remove_space = tokenizerConfig.remove_space;\n\n        this.clean_up_tokenization_spaces = tokenizerConfig.clean_up_tokenization_spaces ?? true;\n\n        // TODO allow user to change this\n        this.padding_side = 'right';\n    }\n\n    /**\n     * Returns the value of the first matching key in the tokenizer config object.\n     * @param {...string} keys One or more keys to search for in the tokenizer config object.\n     * @returns {string|null} The value associated with the first matching key, or null if no match is found.\n     * @throws {Error} If an object is found for a matching key and its __type property is not \"AddedToken\".\n     */\n    getToken(tokenizerConfig, ...keys) {\n        for (let key of keys) {\n            let item = tokenizerConfig[key];\n\n            if (!item) continue;\n\n            if (typeof item === 'object') {\n                if (item.__type === 'AddedToken') {\n                    return item.content;\n                } else {\n                    throw Error(`Unknown token: ${item}`);\n                }\n            } else {\n                return item;\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Loads a pre-trained tokenizer from the given `pretrained_model_name_or_path`. \n     * \n     * @param {string} pretrained_model_name_or_path The path to the pre-trained tokenizer.\n     * @param {PretrainedOptions} options Additional options for loading the tokenizer.\n     * \n     * @throws {Error} Throws an error if the tokenizer.json or tokenizer_config.json files are not found in the `pretrained_model_name_or_path`.\n     * @returns {Promise<PreTrainedTokenizer>} A new instance of the `PreTrainedTokenizer` class.\n     */\n    static async from_pretrained(pretrained_model_name_or_path, {\n        progress_callback = null,\n        config = null,\n        cache_dir = null,\n        local_files_only = false,\n        revision = 'main',\n    } = {}) {\n\n        let info = await loadTokenizer(pretrained_model_name_or_path, {\n            progress_callback,\n            config,\n            cache_dir,\n            local_files_only,\n            revision,\n        })\n\n        // @ts-ignore\n        return new this(...info);\n    }\n\n    /**\n     * This function can be overridden by a subclass to apply additional preprocessing\n     * to a model's input data.\n     * @param {Object} inputs An object containing input data as properties.\n     * @returns {Object} The modified inputs object.\n     */\n    prepare_model_inputs(inputs) {\n        return inputs;\n    }\n\n    /**\n     * Encode/tokenize the given text(s).\n     * @param {string|string[]} text The text to tokenize.\n     * @param {Object} options An optional object containing the following properties:\n     * @param {string|string[]} [options.text_pair=null] Optional second sequence to be encoded. If set, must be the same type as text.\n     * @param {boolean} [options.padding=false] Whether to pad the input sequences.\n     * @param {boolean} [options.truncation=null] Whether to truncate the input sequences.\n     * @param {number} [options.max_length=null] Maximum length of the returned list and optionally padding length.\n     * @param {boolean} [options.return_tensor=true] Whether to return the results as Tensors or arrays.\n     * @returns {{ input_ids: number[]|number[][]|Tensor, attention_mask: any[]|Tensor }} Object to be passed to the model.\n     */\n    _call(\n        // Required positional arguments\n        text,\n\n        // Optional keyword arguments\n        {\n            text_pair = null,\n            // add_special_tokens = true, // TODO\n            padding = false,\n            truncation = null,\n            max_length = null,\n            return_tensor = true, // Different to HF\n        } = {},\n    ) {\n\n        /** @type {number[]|number[][]|Tensor} */\n        let tokens;\n\n        if (Array.isArray(text)) {\n            if (text.length === 0) {\n                throw Error('text array must be non-empty')\n            }\n\n            if (text_pair !== null) {\n                if (!Array.isArray(text_pair)) {\n                    throw Error('text_pair must also be an array')\n\n                } else if (text.length !== text_pair.length) {\n                    throw Error('text and text_pair must have the same length')\n                }\n\n                tokens = text.map(\n                    (t, i) => this.encode(t, text_pair[i])\n                )\n\n            } else {\n                tokens = text.map(x => this.encode(x));\n            }\n\n        } else {\n            if (text === null) {\n                throw Error('text may not be null')\n            }\n\n            if (Array.isArray(text_pair)) {\n                throw Error('When specifying `text_pair`, since `text` is a string, `text_pair` must also be a string (i.e., not an array).')\n            }\n\n            // For single input, we just wrap in an array, and then unwrap later.\n            tokens = [this.encode(text, text_pair)];\n        }\n        // At this point, tokens is batched: [batch_size, tokens]\n        // However, array may be jagged. So, we pad to max_length\n\n        let maxLengthOfBatch = (0,_utils_maths_js__WEBPACK_IMPORTED_MODULE_2__.max)(tokens.map(x => x.length))[0];\n\n        // If null, we calculate max length from sequences\n        if (max_length === null) {\n            max_length = maxLengthOfBatch;\n        }\n\n        // Ensure it is less than model max length\n        max_length = Math.min(max_length, this.model_max_length)\n\n        /** @type {any[]|Tensor} */\n        let attention_mask = [];\n        if (padding || truncation) {\n            // Perform padding and/or truncation\n            for (let i = 0; i < tokens.length; ++i) {\n                if (tokens[i].length === max_length) {\n                    attention_mask.push(new Array(tokens[i].length).fill(1))\n                    continue;\n\n                } else if (tokens[i].length > max_length) {\n                    // possibly truncate\n                    if (truncation) {\n                        tokens[i] = tokens[i].slice(0, max_length);\n                    }\n                    attention_mask.push(new Array(tokens[i].length).fill(1))\n\n                } else { // t.length < max_length\n                    if (padding) {\n                        let diff = max_length - tokens[i].length;\n\n                        if (this.padding_side === 'right') {\n                            attention_mask.push(\n                                (new Array(tokens[i].length).fill(1)).concat(new Array(diff).fill(0))\n                            )\n                            tokens[i].push(...new Array(diff).fill(this.pad_token_id))\n                        } else { // left\n                            attention_mask.push(\n                                (new Array(diff).fill(0)).concat(new Array(tokens[i].length).fill(1))\n                            )\n                            tokens[i].unshift(...new Array(diff).fill(this.pad_token_id))\n                        }\n\n                    } else {\n                        attention_mask.push(new Array(tokens[i].length).fill(1))\n                    }\n                }\n            }\n        } else {\n            attention_mask = tokens.map(x => new Array(x.length).fill(1))\n        }\n\n        if (return_tensor) {\n            if (!(padding && truncation)) {\n                // Not, guaranteed that all items have same length, so\n                // we perform additional check\n\n                if (tokens.some(x => x.length !== tokens[0].length)) {\n                    throw Error(\n                        \"Unable to create tensor, you should probably activate truncation and/or padding \" +\n                        \"with 'padding=true' and 'truncation=true' to have batched tensors with the same length.\"\n                    )\n                }\n            }\n\n            // Now we actually convert to tensor\n            // NOTE: In the same way as the python library, we return a batched tensor, regardless of\n            // whether we have a single input or multiple inputs.\n            let dims = [tokens.length, tokens[0].length];\n\n            tokens = new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_3__.Tensor('int64',\n                BigInt64Array.from(tokens.flat().map(BigInt)),\n                dims\n            );\n\n            attention_mask = new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_3__.Tensor(\n                'int64',\n                BigInt64Array.from(attention_mask.flat().map(BigInt)),\n                dims\n            )\n        } else {\n            // If not returning a tensor, we match the input type\n            if (!Array.isArray(text)) {\n                // Input was not batched, so we unwrap\n                tokens = tokens[0];\n                attention_mask = attention_mask[0];\n            }\n        }\n\n\n        // Finally, add attention mask, and possibly model-specific parameters\n        let modelInputs = {\n            input_ids: tokens,\n            attention_mask: attention_mask\n        }\n\n        // Optional post-processing\n        modelInputs = this.prepare_model_inputs(modelInputs);\n\n        return modelInputs\n    }\n\n    /**\n     * Encodes a single text using the preprocessor pipeline of the tokenizer.\n     *\n     * @param {string|null} text The text to encode.\n     * @returns {string[]|null} The encoded tokens.\n     */\n    _encode_text(text) {\n        if (text === null) return null;\n\n        // Actual function which does encoding, for a single text\n        // First, we take care of special tokens. Needed to avoid issues arising from\n        // normalization and/or pretokenization (which may not preserve special tokens)\n        const sections = text.split(this.added_tokens_regex).filter(x => x);\n\n        let tokens = sections.map(x => {\n            if (this.added_tokens.includes(x)) {\n                // Ignore added tokens\n                return x\n            } else {\n                if (this.remove_space === true) {\n                    x = x.trim().split(/\\s+/).join(' ');\n                }\n\n                if (this.normalizer !== null) {\n                    x = this.normalizer(x);\n                }\n\n                let sectionTokens = (this.pre_tokenizer !== null) ? this.pre_tokenizer(x) : [x];\n\n                let tokens = this.model(sectionTokens);\n\n                return tokens;\n            }\n        }).flat();\n\n        return tokens;\n    }\n\n    /**\n     * Encodes a single text or a pair of texts using the model's tokenizer.\n     *\n     * @param {string} text The text to encode.\n     * @param {string|null} text_pair The optional second text to encode.\n     * @returns {number[]} An array of token IDs representing the encoded text(s).\n     */\n    encode(text, text_pair = null) {\n        // Function called by users to encode possibly multiple texts\n        let tokens = this._encode_text(text);\n        let tokens2 = this._encode_text(text_pair);\n\n        let combinedTokens = (this.post_processor !== null)\n            ? this.post_processor(tokens, tokens2)\n            : (0,_utils_core_js__WEBPACK_IMPORTED_MODULE_0__.mergeArrays)(tokens ?? [], tokens2 ?? []);\n\n        let ids = this.model.convert_tokens_to_ids(combinedTokens);\n        return ids;\n    }\n\n    /**\n     * Decode a batch of tokenized sequences.\n     * @param {number[][]} batch List of tokenized input sequences.\n     * @param {Object} decode_args (Optional) Object with decoding arguments.\n     * @returns {string[]} List of decoded sequences.\n     */\n    batch_decode(batch, decode_args = {}) {\n        return batch.map(x => this.decode(x, decode_args));\n    }\n\n    /**\n     * Decodes a sequence of token IDs back to a string.\n     *\n     * @param {number[]} token_ids List of token IDs to decode.\n     * @param {Object} [decode_args={}]\n     * @param {boolean} [decode_args.skip_special_tokens=false] If true, special tokens are removed from the output string.\n     * @param {boolean} [decode_args.clean_up_tokenization_spaces=true] If true, spaces before punctuations and abbreviated forms are removed.\n     *\n     * @returns {string} The decoded string.\n     * @throws {Error} If `token_ids` is not a non-empty array of integers.\n     */\n    decode(\n        token_ids,\n        decode_args = {},\n    ) {\n        if (!Array.isArray(token_ids) || token_ids.length === 0 || !(0,_utils_core_js__WEBPACK_IMPORTED_MODULE_0__.isIntegralNumber)(token_ids[0])) {\n            throw Error(\"token_ids must be a non-empty array of integers.\");\n        }\n\n        return this.decode_single(token_ids, decode_args)\n    }\n\n    /**\n     * Decode a single list of token ids to a string.\n     * @param {number[]} token_ids List of token ids to decode\n     * @param {Object} decode_args Optional arguments for decoding\n     * @param {boolean} [decode_args.skip_special_tokens=false] Whether to skip special tokens during decoding\n     * @param {boolean} [decode_args.clean_up_tokenization_spaces=null] Whether to clean up tokenization spaces during decoding.\n     * If null, the value is set to `this.decoder.cleanup` if it exists, falling back to `this.clean_up_tokenization_spaces` if it exists, falling back to `true`.\n     * @returns {string} The decoded string\n     */\n    decode_single(\n        token_ids,\n        {\n            skip_special_tokens = false,\n            clean_up_tokenization_spaces = null,\n        }\n    ) {\n        let tokens = this.model.convert_ids_to_tokens(token_ids);\n        if (skip_special_tokens) {\n            tokens = tokens.filter(x => !this.special_tokens.includes(x));\n        }\n\n        /** @type {string} */\n        let decoded = this.decoder(tokens);\n\n\n        // Slight hack, but prevents having to pass `skip_special_tokens` to\n        // each call to `decode`, which would lead to code duplication.\n        if (this.decoder.end_of_word_suffix) {\n            decoded = decoded.replaceAll(this.decoder.end_of_word_suffix, ' ');\n            if (skip_special_tokens) {\n                decoded = decoded.trim();\n            }\n        }\n\n        if (clean_up_tokenization_spaces ?? this.clean_up_tokenization_spaces) {\n            decoded = clean_up_tokenization(decoded);\n        }\n\n        return decoded;\n    }\n\n}\n\n/**\n* Helper method for adding `token_type_ids` to model inputs\n* @param {Object} inputs An object containing the input ids and attention mask.\n* @returns {Object} The prepared inputs object.\n*/\nfunction add_token_types(inputs) {\n    // TODO ensure correctness when token pair is present\n    if (inputs.input_ids instanceof _utils_tensor_js__WEBPACK_IMPORTED_MODULE_3__.Tensor) {\n        inputs.token_type_ids = new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_3__.Tensor(\n            'int64',\n            new BigInt64Array(inputs.input_ids.data.length),\n            inputs.input_ids.dims\n        )\n    } else if (Array.isArray(inputs.input_ids)) {\n\n        if (Array.isArray(inputs.input_ids[0])) {\n            // This means input is batched, so we need to batch the token_type_ids as well\n            inputs.token_type_ids = inputs.input_ids.map(\n                x => new Array(x.length).fill(0)\n            )\n        } else {\n            inputs.token_type_ids = new Array(inputs.input_ids.length).fill(0);\n        }\n    } else {\n        throw new Error('Input ids must be a Tensor or an Array')\n    }\n\n    return inputs;\n}\n\n/**\n * BertTokenizer is a class used to tokenize text for BERT models.\n * @extends PreTrainedTokenizer\n */\nclass BertTokenizer extends PreTrainedTokenizer {\n    /** @type {add_token_types} */\n    prepare_model_inputs(inputs) {\n        return add_token_types(inputs);\n    }\n}\n/**\n * Albert tokenizer\n * @extends PreTrainedTokenizer\n */\nclass AlbertTokenizer extends PreTrainedTokenizer {\n    /** @type {add_token_types} */\n    prepare_model_inputs(inputs) {\n        return add_token_types(inputs);\n    }\n}\nclass MobileBertTokenizer extends PreTrainedTokenizer {\n    /** @type {add_token_types} */\n    prepare_model_inputs(inputs) {\n        return add_token_types(inputs);\n    }\n}\nclass SqueezeBertTokenizer extends PreTrainedTokenizer {\n    /** @type {add_token_types} */\n    prepare_model_inputs(inputs) {\n        return add_token_types(inputs);\n    }\n}\nclass DistilBertTokenizer extends PreTrainedTokenizer { }\nclass T5Tokenizer extends PreTrainedTokenizer { }\nclass GPT2Tokenizer extends PreTrainedTokenizer { }\nclass BartTokenizer extends PreTrainedTokenizer { }\nclass RobertaTokenizer extends PreTrainedTokenizer { }\n\nclass BloomTokenizer extends PreTrainedTokenizer { }\nclass LlamaTokenizer extends PreTrainedTokenizer { }\n\nclass XLMRobertaTokenizer extends PreTrainedTokenizer { }\nclass MPNetTokenizer extends PreTrainedTokenizer { }\n\nclass FalconTokenizer extends PreTrainedTokenizer {\n    /** @type {add_token_types} */\n    prepare_model_inputs(inputs) {\n        return add_token_types(inputs);\n    }\n}\n\nclass GPTNeoXTokenizer extends PreTrainedTokenizer { }\n\n/**\n * The NllbTokenizer class is used to tokenize text for NLLB (\"No Language Left Behind\") models.\n * \n * No Language Left Behind (NLLB) is a first-of-its-kind, AI breakthrough project\n * that open-sources models capable of delivering high-quality translations directly\n * between any pair of 200+ languages — including low-resource languages like Asturian,\n * Luganda, Urdu and more. It aims to help people communicate with anyone, anywhere,\n * regardless of their language preferences. For more information, check out their\n * [paper](https://arxiv.org/abs/2207.04672).\n * \n * For a list of supported languages (along with their language codes),\n * @see {@link https://github.com/facebookresearch/flores/blob/main/flores200/README.md#languages-in-flores-200}\n */\nclass NllbTokenizer extends PreTrainedTokenizer {\n\n    constructor(tokenizerJSON, tokenizerConfig) {\n        super(tokenizerJSON, tokenizerConfig);\n\n        this.languageRegex = /^[a-z]{3}_[A-Z][a-z]{3}$/;\n        this.language_codes = this.special_tokens.filter(x => this.languageRegex.test(x));\n    }\n\n    /**\n     * Helper function to build translation inputs for an `NllbTokenizer`.\n     * @param {string|string[]} raw_inputs The text to tokenize.\n     * @param {Object} tokenizer_options Options to be sent to the tokenizer\n     * @param {Object} generate_kwargs Generation options.\n     * @returns {Object} Object to be passed to the model.\n     */\n    _build_translation_inputs(raw_inputs, tokenizer_options, generate_kwargs) {\n\n\n        // Check that the target language is valid:\n        if (!this.language_codes.includes(generate_kwargs.tgt_lang)) {\n            throw new Error(`Target language code \"${generate_kwargs.tgt_lang}\" is not valid. Must be one of: {${this.language_codes.join(', ')}}`);\n        }\n\n        // Allow `src_lang` to be optional. If not set, we'll use the tokenizer's default.\n        if (generate_kwargs.src_lang !== undefined) {\n            // Check that the source language is valid:\n            if (!this.language_codes.includes(generate_kwargs.src_lang)) {\n                throw new Error(`Source language code \"${generate_kwargs.src_lang}\" is not valid. Must be one of: {${this.language_codes.join(', ')}}`);\n            }\n\n            // In the same way as the Python library, we override the post-processor\n            // to force the source language to be first:\n            for (let item of this.post_processor.config.single) {\n                if ('SpecialToken' in item && this.languageRegex.test(item.SpecialToken.id)) {\n                    item.SpecialToken.id = generate_kwargs.src_lang;\n                    break;\n                }\n            }\n        }\n\n        // Override the `forced_bos_token_id` to force the correct language\n        generate_kwargs.forced_bos_token_id = this.model.convert_tokens_to_ids([generate_kwargs.tgt_lang])[0];\n\n        return this._call(raw_inputs, tokenizer_options);\n    }\n}\n\n\nconst WHISPER_LANGUAGES = [\n    [\"en\", \"english\"],\n    [\"zh\", \"chinese\"],\n    [\"de\", \"german\"],\n    [\"es\", \"spanish\"],\n    [\"ru\", \"russian\"],\n    [\"ko\", \"korean\"],\n    [\"fr\", \"french\"],\n    [\"ja\", \"japanese\"],\n    [\"pt\", \"portuguese\"],\n    [\"tr\", \"turkish\"],\n    [\"pl\", \"polish\"],\n    [\"ca\", \"catalan\"],\n    [\"nl\", \"dutch\"],\n    [\"ar\", \"arabic\"],\n    [\"sv\", \"swedish\"],\n    [\"it\", \"italian\"],\n    [\"id\", \"indonesian\"],\n    [\"hi\", \"hindi\"],\n    [\"fi\", \"finnish\"],\n    [\"vi\", \"vietnamese\"],\n    [\"he\", \"hebrew\"],\n    [\"uk\", \"ukrainian\"],\n    [\"el\", \"greek\"],\n    [\"ms\", \"malay\"],\n    [\"cs\", \"czech\"],\n    [\"ro\", \"romanian\"],\n    [\"da\", \"danish\"],\n    [\"hu\", \"hungarian\"],\n    [\"ta\", \"tamil\"],\n    [\"no\", \"norwegian\"],\n    [\"th\", \"thai\"],\n    [\"ur\", \"urdu\"],\n    [\"hr\", \"croatian\"],\n    [\"bg\", \"bulgarian\"],\n    [\"lt\", \"lithuanian\"],\n    [\"la\", \"latin\"],\n    [\"mi\", \"maori\"],\n    [\"ml\", \"malayalam\"],\n    [\"cy\", \"welsh\"],\n    [\"sk\", \"slovak\"],\n    [\"te\", \"telugu\"],\n    [\"fa\", \"persian\"],\n    [\"lv\", \"latvian\"],\n    [\"bn\", \"bengali\"],\n    [\"sr\", \"serbian\"],\n    [\"az\", \"azerbaijani\"],\n    [\"sl\", \"slovenian\"],\n    [\"kn\", \"kannada\"],\n    [\"et\", \"estonian\"],\n    [\"mk\", \"macedonian\"],\n    [\"br\", \"breton\"],\n    [\"eu\", \"basque\"],\n    [\"is\", \"icelandic\"],\n    [\"hy\", \"armenian\"],\n    [\"ne\", \"nepali\"],\n    [\"mn\", \"mongolian\"],\n    [\"bs\", \"bosnian\"],\n    [\"kk\", \"kazakh\"],\n    [\"sq\", \"albanian\"],\n    [\"sw\", \"swahili\"],\n    [\"gl\", \"galician\"],\n    [\"mr\", \"marathi\"],\n    [\"pa\", \"punjabi\"],\n    [\"si\", \"sinhala\"],\n    [\"km\", \"khmer\"],\n    [\"sn\", \"shona\"],\n    [\"yo\", \"yoruba\"],\n    [\"so\", \"somali\"],\n    [\"af\", \"afrikaans\"],\n    [\"oc\", \"occitan\"],\n    [\"ka\", \"georgian\"],\n    [\"be\", \"belarusian\"],\n    [\"tg\", \"tajik\"],\n    [\"sd\", \"sindhi\"],\n    [\"gu\", \"gujarati\"],\n    [\"am\", \"amharic\"],\n    [\"yi\", \"yiddish\"],\n    [\"lo\", \"lao\"],\n    [\"uz\", \"uzbek\"],\n    [\"fo\", \"faroese\"],\n    [\"ht\", \"haitian creole\"],\n    [\"ps\", \"pashto\"],\n    [\"tk\", \"turkmen\"],\n    [\"nn\", \"nynorsk\"],\n    [\"mt\", \"maltese\"],\n    [\"sa\", \"sanskrit\"],\n    [\"lb\", \"luxembourgish\"],\n    [\"my\", \"myanmar\"],\n    [\"bo\", \"tibetan\"],\n    [\"tl\", \"tagalog\"],\n    [\"mg\", \"malagasy\"],\n    [\"as\", \"assamese\"],\n    [\"tt\", \"tatar\"],\n    [\"haw\", \"hawaiian\"],\n    [\"ln\", \"lingala\"],\n    [\"ha\", \"hausa\"],\n    [\"ba\", \"bashkir\"],\n    [\"jw\", \"javanese\"],\n    [\"su\", \"sundanese\"],\n]\n\n// @ts-ignore\nconst WHISPER_LANGUAGE_MAPPING = new Map(WHISPER_LANGUAGES);\n// @ts-ignore\nconst WHISPER_TO_LANGUAGE_CODE_MAPPING = new Map([\n    ...WHISPER_LANGUAGES.map(([k, v]) => [v, k]),\n    ...[\n        [\"burmese\", \"my\"],\n        [\"valencian\", \"ca\"],\n        [\"flemish\", \"nl\"],\n        [\"haitian\", \"ht\"],\n        [\"letzeburgesch\", \"lb\"],\n        [\"pushto\", \"ps\"],\n        [\"panjabi\", \"pa\"],\n        [\"moldavian\", \"ro\"],\n        [\"moldovan\", \"ro\"],\n        [\"sinhalese\", \"si\"],\n        [\"castilian\", \"es\"],\n    ]\n]);\n\n/**\n * WhisperTokenizer tokenizer\n * @extends PreTrainedTokenizer\n */\nclass WhisperTokenizer extends PreTrainedTokenizer {\n\n    /**\n     * Decodes automatic speech recognition (ASR) sequences.\n     * @param {Array<{tokens: number[], token_timestamps?: number[], stride: number[]}>} sequences The sequences to decode.\n     * @param {Object} options The options to use for decoding.\n     * @returns {Array<string|{chunks?: undefined|Array<{language: string|null, timestamp: Array<number|null>, text: string}>}>} The decoded sequences.\n     */\n    _decode_asr(sequences, {\n        return_timestamps = false,\n        return_language = false,\n        time_precision = null,\n        force_full_sequences = true\n    } = {}) {\n        // Set force_full_sequences=false if you want streaming\n        // TODO add support for `return_language`\n\n        // Internal method meant to only be used by asr pipeline.\n        // Handles all the little quirks specific to whisper to handle\n        // the various options not allowed in other seq2seq models\n\n        // =========== Overview ============\n        // - iterate over all outputs\n        // - all tokens within output\n        // - Each token can be\n        //   - language token\n        //   - special token\n        //   - timestamp token\n        //   - text token\n        // - We accumulate the text tokens.\n        // - We split on end timestamps\n        // - Lots of complexity comes from stride and timestamps\n\n        if (time_precision === null) {\n            throw Error(\"Must specify time_precision\")\n        }\n        let last_language = null;\n\n        const returnWordTimestamps = return_timestamps === \"word\";\n\n        function new_chunk() {\n            return { \"language\": last_language, \"timestamp\": [null, null], \"text\": \"\" };\n        }\n\n        // Welcome to the state machine!\n        const chunks = [];\n        let chunk = new_chunk();\n        let time_offset = 0.0;\n        const timestamp_begin = this.model.convert_tokens_to_ids([\"<|notimestamps|>\"])[0] + 1;\n\n        let previous_tokens = [];\n        let previous_token_timestamps = [];\n\n        let skip = false;\n        let right_stride_start = null;\n\n\n        const all_special_ids = new Set(this.all_special_ids);\n\n        for (let output of sequences) {\n            // NOTE: python version has batches, so it uses [0]\n            const token_ids = output.tokens;\n            const token_timestamps = returnWordTimestamps ? output.token_timestamps : null;\n\n            // These keep track of timestamps within strides, which need\n            // to be skipped and resolve all tokens in a single chunk.\n            let last_timestamp = null;\n            let first_timestamp = timestamp_begin;\n\n            if (\"stride\" in output) {\n                const [chunk_len, stride_left, stride_right] = output.stride;\n\n                // Offset the timings to account for the other `model_outputs`.\n                time_offset -= stride_left;\n                right_stride_start = chunk_len - stride_right;\n\n                // Keeping track of timestamps within strides\n                // We're going to NOT split on those, and delay until we're\n                // out of BOTH stride. Otherwise lots of issues occur and\n                // corner cases\n                if (stride_left) {\n                    first_timestamp = stride_left / time_precision + timestamp_begin;\n                }\n\n                if (stride_right) {\n                    for (let i = token_ids.length - 1; i >= 0; --i) {\n                        const token = token_ids[i];\n                        if (token >= timestamp_begin) {\n                            // There can be several token in the right stride\n                            // But the last one is ALWAYS going to be skipped\n                            if (last_timestamp !== null && (token - timestamp_begin) * time_precision < right_stride_start) {\n                                break;\n                            }\n                            last_timestamp = token;\n                        }\n                    }\n                }\n            }\n\n            let current_tokens = [];\n            let current_token_timestamps = [];\n\n            // - all tokens within output\n            for (let i = 0; i < token_ids.length; ++i) {\n                const token = token_ids[i];\n                // 4 possible states for each token\n                // - 1/ Language code\n                // - 2/ all other special tokens (which we ignore)\n                // - 3/ Timestamp\n                // - 4/ Regular text\n\n                if (all_special_ids.has(token)) {\n                    const text = this.decode([token]);\n                    if (text[0] === \"[\" && text[text.length - 1] === \"]\") {\n                        const language = WHISPER_LANGUAGE_MAPPING.get(text.slice(1, -1));\n\n                        if (language !== undefined) {\n                            // 1/ Indeed some language\n                            // TODO Handle when language is different from the previous\n                            // one, and we cannot use timestamped tokens to create chunks\n                            if (last_language !== null && language !== last_language && !return_timestamps) {\n                                previous_tokens.push(current_tokens);\n                                const resolved_tokens = this.findLongestCommonSequence(previous_tokens)[0];\n                                const resolved_text = this.decode(resolved_tokens);\n                                chunk.text = resolved_text;\n                                chunks.push(chunk);\n\n                                // Flush all our temporary context\n                                previous_tokens = [];\n                                current_tokens = [];\n                                chunk = new_chunk();\n                            }\n\n                            last_language = chunk.language = language;\n                        } else {\n                            // 2/ This is a regular special token, ignoring it\n                        }\n                    }\n                } else if (token >= timestamp_begin) {\n                    // 3/ Timestamp token\n                    const time = (token - timestamp_begin) * time_precision + time_offset;\n                    const rounded_time = (0,_utils_maths_js__WEBPACK_IMPORTED_MODULE_2__.round)(time, 2);\n\n                    if (last_timestamp !== null && token >= last_timestamp) {\n                        // Whisper outputted a timestamp token, but it falls within\n                        // our stride, so we're going to skip it for the time being\n                        // and resolve this later\n                        // Skip is necessary because timestamp tokens always come\n                        // by pair, so we need to skip the next one too (which would mark the start of another chunk).\n                        skip = true;\n                    } else if (skip || (previous_tokens.length > 0 && token < first_timestamp)) {\n                        skip = false;\n                    } else if (chunk.timestamp[0] === null) {\n                        chunk.timestamp[0] = rounded_time;\n                    } else {\n                        // This is the end of the timestamp chunk\n                        if (rounded_time === chunk.timestamp[0]) {\n                            // This is a bug in timestamp token output\n                            // where we're taking the duplicate token\n                            // as a stop where it should be a start.\n                            // This is an issue in the underlying model output\n                            // Let's just skip it so it becomes de-factor a start agin\n                        } else {\n                            chunk.timestamp[1] = rounded_time;\n\n                            // Handling merges\n                            previous_tokens.push(current_tokens)\n\n                            if (returnWordTimestamps) {\n                                previous_token_timestamps.push(current_token_timestamps);\n                            }\n                            const [resolved_tokens, resolved_token_timestamps] = this.findLongestCommonSequence(\n                                previous_tokens, previous_token_timestamps\n                            )\n\n                            const resolved_text = this.decode(resolved_tokens)\n                            chunk.text = resolved_text\n\n                            if (returnWordTimestamps) {\n                                chunk.words = this.collateWordTimestamps(\n                                    resolved_tokens, resolved_token_timestamps, last_language,\n                                )\n                            }\n\n                            chunks.push(chunk)\n\n                            // Flush all our temporary context\n                            previous_tokens = []\n                            current_tokens = []\n                            previous_token_timestamps = []\n                            current_token_timestamps = []\n                            chunk = new_chunk()\n                        }\n                    }\n\n                } else {\n                    // 4/ Regular token\n                    // We just append to the list of all tokens so we can handle\n                    // merges later and decode into text.\n                    current_tokens.push(token)\n\n                    if (returnWordTimestamps) {\n                        let start_time = (0,_utils_maths_js__WEBPACK_IMPORTED_MODULE_2__.round)(token_timestamps[i] + time_offset, 2);\n\n                        let end_time;\n                        if (i + 1 < token_timestamps.length) {\n                            end_time = (0,_utils_maths_js__WEBPACK_IMPORTED_MODULE_2__.round)(token_timestamps[i + 1] + time_offset, 2);\n                        } else {\n                            // should never happen\n                            end_time = null;\n                        }\n                        current_token_timestamps.push([start_time, end_time]);\n                    }\n\n                }\n            }\n\n            if ('stride' in output) {\n                const [chunk_len, stride_left, stride_right] = output.stride;\n                time_offset += chunk_len - stride_right\n            }\n\n            // Leftover tokens\n            if (current_tokens.length > 0) {\n                previous_tokens.push(current_tokens)\n                if (returnWordTimestamps) {\n                    previous_token_timestamps.push(current_token_timestamps);\n                }\n            } else if (previous_tokens.every(p => p.length === 0)) {\n                // Flushing previous tokens (END)\"\n                chunk = new_chunk()\n                previous_tokens = []\n                current_tokens = []\n                previous_token_timestamps = [];\n                current_token_timestamps = [];\n            }\n\n        }\n\n        if (previous_tokens.length > 0) {\n            if (force_full_sequences && return_timestamps) {\n                // Last token should always be timestamps, so there shouldn't be\n                // leftover\n                throw new Error(\n                    \"Whisper did not predict an ending timestamp, which can happen if audio is cut off in the middle of a word. \" +\n                    \"Also make sure WhisperTimeStampLogitsProcessor was used during generation.\"\n                );\n            }\n\n            // Happens when we don't use timestamps\n            const [resolved_tokens, resolved_token_timestamps] = this.findLongestCommonSequence(previous_tokens, previous_token_timestamps);\n\n            // Flushing previous tokens (FINAL)\n            const resolved_text = this.decode(resolved_tokens);\n            chunk.text = resolved_text;\n            if (returnWordTimestamps) {\n                chunk.words = this.collateWordTimestamps(\n                    resolved_tokens, resolved_token_timestamps, last_language,\n                )\n            }\n            chunks.push(chunk);\n        }\n\n        let optional = Object.create(null);\n\n        // Preparing and cleaning up the pipeline output\n        const full_text = chunks.map(chunk => chunk.text).join('');\n        if (return_timestamps || return_language) {\n            for (let i = 0; i < chunks.length; ++i) {\n                const chunk = chunks[i];\n                if (!return_timestamps) {\n                    delete chunk[\"timestamp\"];\n                }\n\n                if (!return_language) {\n                    delete chunk[\"language\"];\n                }\n            }\n            if (returnWordTimestamps) {\n                let new_chunks = [];\n                for (let chunk of chunks) {\n                    for (let word of chunk.words) {\n                        new_chunks.push(word);\n                    }\n                }\n                optional = { \"chunks\": new_chunks };\n            } else {\n                optional = { \"chunks\": chunks };\n            }\n        }\n        return [full_text, optional];\n\n    }\n\n    /**\n     * Finds the longest common sequence among the provided sequences.\n     * @param {number[][]} sequences An array of sequences of token ids to compare.\n     * @returns {number[][]} The longest common sequence found.\n     * @throws {Error} If there is a bug within the function.\n     * @private\n     */\n    findLongestCommonSequence(sequences, token_timestamp_sequences = null) {\n        // It would be much harder to do O(n) because of fault tolerance.\n        // We actually have a really good property which is that the total sequence\n        // MUST be those subsequences in order.\n        // If token_timestamp_sequences is provided, will split those sequences in\n        // exactly the same way.\n        let leftSequence = sequences[0];\n        let leftLength = leftSequence.length;\n        let totalSequence = [];\n\n        const use_token_timestamp_sequences = Array.isArray(token_timestamp_sequences) && token_timestamp_sequences.length > 0;\n        let total_token_timestamp_sequence = use_token_timestamp_sequences ? [] : null;\n        let left_token_timestamp_sequence = use_token_timestamp_sequences ? token_timestamp_sequences[0] : null;\n        for (let i = 1; i < sequences.length; ++i) {\n            const rightSequence = sequences[i];\n            let max = 0.0;\n            let maxIndices = [leftLength, leftLength, 0, 0];\n            // Here we're sliding matches\n            // [a, b, c, d]\n            //          [c, d, f]\n            // =        [c] == [d]\n\n            // [a, b, c, d]\n            //       [c, d, f]\n            // =     [c, d] == [c, d]\n\n\n            // [a, b, c, d]\n            //    [c, d, f]\n\n            // =  [b, c, d] == [c, d, f]\n\n            // [a, b, c, d]\n            // [c, d, f]\n\n            // [a, b, c] == [c, d, f]\n\n            // [a, b, c, d]\n            // [d, f]\n\n            // [a, b] == [d, f]\n\n            // [a, b, c, d]\n            // [f]\n\n            // [a] == [f]\n\n            const rightLength = rightSequence.length;\n            for (let j = 1; j < leftLength + rightLength; ++j) {\n                const eps = j / 10000.0;\n                const leftStart = Math.max(0, leftLength - j);\n                const leftStop = Math.min(leftLength, leftLength + rightLength - j);\n                const left = leftSequence.slice(leftStart, leftStop);\n                const rightStart = Math.max(0, j - leftLength);\n                const rightStop = Math.min(rightLength, j);\n                const right = rightSequence.slice(rightStart, rightStop);\n                if (left.length !== right.length) {\n                    throw new Error(\"There is a bug within whisper `decode_asr` function, please report it. Dropping to prevent bad inference.\");\n                }\n                const matches = left.filter((elem, idx) => elem === right[idx]).length;\n                const matching = matches / j + eps;\n                if (matches > 1 && matching > max) {\n                    max = matching;\n                    maxIndices = [leftStart, leftStop, rightStart, rightStop];\n                }\n            }\n            const [leftStart, leftStop, rightStart, rightStop] = maxIndices;\n            const leftMid = Math.floor((leftStop + leftStart) / 2);\n            const rightMid = Math.floor((rightStop + rightStart) / 2);\n            totalSequence.push(...leftSequence.slice(0, leftMid));\n            leftSequence = rightSequence.slice(rightMid);\n            leftLength = leftSequence.length;\n\n            if (use_token_timestamp_sequences) {\n                total_token_timestamp_sequence.push(...left_token_timestamp_sequence.slice(0, leftMid));\n                left_token_timestamp_sequence = token_timestamp_sequences[i].slice(rightMid);\n            }\n        }\n        totalSequence.push(...leftSequence);\n\n        if (use_token_timestamp_sequences) {\n            total_token_timestamp_sequence.push(...left_token_timestamp_sequence);\n            return [totalSequence, total_token_timestamp_sequence];\n        } else {\n            return [totalSequence, []];\n        }\n    }\n\n    /** @private */\n    collateWordTimestamps(tokens, token_timestamps, language) {\n\n        let [words, _, token_indices] = this.combineTokensIntoWords(tokens, language);\n\n        let timings = [];\n        for (let i = 0; i < words.length; ++i) {\n            const indices = token_indices[i];\n            timings.push({\n                text: words[i],\n                timestamp: [\n                    token_timestamps[indices.at(0)][0],\n                    token_timestamps[indices.at(-1)][1],\n                ],\n            });\n        }\n        return timings;\n    }\n\n    /**\n     * Groups tokens by word. Returns a tuple containing a list of strings with the words,\n     * and a list of `token_id` sequences with the tokens making up each word.\n     * @param {number[]} tokens \n     * @param {string} [language] \n     * @param {string} prepend_punctionations \n     * @param {string} append_punctuations \n     * \n     * @private\n     */\n    combineTokensIntoWords(tokens, language, prepend_punctionations = \"\\\"'“¡¿([{-\", append_punctuations = \"\\\"'.。,，!！?？:：”)]}、\") {\n        language = language ?? 'english';\n\n        let words, word_tokens, token_indices;\n\n        if ([\"chinese\", \"japanese\", \"thai\", \"lao\", \"myanmar\"].includes(language)) {\n            // These languages don't typically use spaces.\n\n            [words, word_tokens, token_indices] = this.splitTokensOnUnicode(tokens)\n        } else {\n            [words, word_tokens, token_indices] = this.splitTokensOnSpaces(tokens)\n        }\n\n        return this.mergePunctuations(words, word_tokens, token_indices, prepend_punctionations, append_punctuations);\n    }\n\n    /** @type {PreTrainedTokenizer['decode']} */\n    decode(\n        token_ids,\n        decode_args,\n    ) {\n        let text;\n        // @ts-ignore\n        if (decode_args && decode_args.decode_with_timestamps) {\n            text = this.decodeWithTimestamps(token_ids, decode_args);\n        } else {\n            text = super.decode(token_ids, decode_args);\n        }\n        // TODO: implement offsets\n        // if (decode_args.output_offsets) {\n        //     let offsets = this.computeOffsets\n        // }\n        return text;\n    }\n\n    /**\n     * @param {number[]} token_ids List of token IDs to decode.\n     * @param {Object} decode_args Optional arguments for decoding\n     * @private\n     */\n    decodeWithTimestamps(token_ids, decode_args) {\n        const time_precision = decode_args?.time_precision ?? 0.02;\n\n        const timestamp_begin = Array.from(this.all_special_ids).at(-1) + 1;\n        /**@type {Array} */\n        let outputs = [[]];\n        for (let token of token_ids) {\n            if (token >= timestamp_begin) {\n                let timestamp = (token - timestamp_begin) * time_precision;\n                timestamp = (0,_utils_maths_js__WEBPACK_IMPORTED_MODULE_2__.round)(timestamp, 2);\n                outputs.push(`<|${timestamp}|>`);\n                outputs.push([]);\n            } else {\n                outputs[outputs.length - 1].push(token);\n            }\n        }\n        outputs = outputs.map(\n            s => {\n                if (typeof s === 'string') {\n                    return s;\n                } else {\n                    return super.decode(s, decode_args);\n                }\n            }\n        )\n\n        return outputs.join('');\n    }\n\n    /**\n     * Combine tokens into words by splitting at any position where the tokens are decoded as valid unicode points.\n     * @param {number[]} tokens \n     * @returns {*}\n     * @private\n     */\n    splitTokensOnUnicode(tokens) {\n        const decoded_full = this.decode(tokens, {\n            // @ts-ignore\n            decode_with_timestamps: true,\n        });\n        const replacement_char = '\\uFFFD';\n\n        let words = []\n        let word_tokens = []\n        let token_indices = []\n        let current_tokens = []\n        let current_indices = []\n        let unicode_offset = 0\n\n        for (let token_idx = 0; token_idx < tokens.length; ++token_idx) {\n            const token = tokens[token_idx];\n\n            current_tokens.push(token);\n            current_indices.push(token_idx);\n\n            const decoded = this.decode(current_tokens, {\n                // @ts-ignore\n                decode_with_timestamps: true,\n            });\n\n            if (!decoded.includes(replacement_char) || decoded_full[unicode_offset + decoded.indexOf(replacement_char)] === replacement_char) {\n                words.push(decoded)\n                word_tokens.push(current_tokens)\n                token_indices.push(current_indices)\n                current_tokens = []\n                current_indices = []\n                unicode_offset += decoded.length;\n            }\n\n        }\n\n        return [words, word_tokens, token_indices]\n    }\n\n    /**\n     * Combine tokens into words by splitting at whitespace and punctuation tokens.\n     * @param {number[]} tokens \n     * @private\n     */\n    splitTokensOnSpaces(tokens) {\n\n        let [subwords, subword_tokens_list, subword_indices_list] = this.splitTokensOnUnicode(tokens);\n\n        let words = []\n        let word_tokens = []\n        let token_indices = []\n\n        const punctuationRegex = new RegExp(`[${PUNCTUATION_REGEX}]`)\n\n        for (let i = 0; i < subwords.length; ++i) {\n\n            const subword = subwords[i];\n            const subword_tokens = subword_tokens_list[i];\n            const subword_indices = subword_indices_list[i];\n\n            // @ts-ignore\n            const special = subword_tokens[0] >= this.model.tokens_to_ids.get('<|endoftext|>');\n            const with_space = subword.startsWith(' ');\n            const trimmed = subword.trim();\n            const punctuation = punctuationRegex.test(trimmed);\n\n            if (special || with_space || punctuation || words.length === 0) {\n                words.push(subword);\n                word_tokens.push(subword_tokens);\n                token_indices.push(subword_indices);\n            } else {\n                const ix = words.length - 1;\n                words[ix] += subword;\n                word_tokens[ix].push(...subword_tokens);\n                token_indices[ix].push(...subword_indices);\n            }\n        }\n\n        return [words, word_tokens, token_indices];\n\n    }\n\n    /**\n     * Merges punctuation tokens with neighboring words.\n     * @param {string[]} words \n     * @param {number[][]} tokens \n     * @param {number[][]} indices \n     * @param {string} prepended \n     * @param {string} appended \n     * @private\n     */\n    mergePunctuations(words, tokens, indices, prepended, appended) {\n\n        let newWords = structuredClone(words);\n        let newTokens = structuredClone(tokens);\n        let newIndices = structuredClone(indices);\n\n\n        // prepend punctuations\n        let i = newWords.length - 2;\n        let j = newWords.length - 1;\n\n        while (i >= 0) {\n            if (newWords[i].startsWith(' ') && prepended.includes(newWords[i].trim())) {\n                newWords[j] = newWords[i] + newWords[j];\n                newTokens[j] = (0,_utils_core_js__WEBPACK_IMPORTED_MODULE_0__.mergeArrays)(newTokens[i], newTokens[j]);\n                newIndices[j] = (0,_utils_core_js__WEBPACK_IMPORTED_MODULE_0__.mergeArrays)(newIndices[i], newIndices[j]);\n                newWords[i] = '';\n                newTokens[i] = [];\n                newIndices[i] = [];\n            } else {\n                j = i;\n            }\n            --i;\n        }\n\n        // append punctuations\n        i = 0;\n        j = 1;\n        while (j < newWords.length) {\n            if (!newWords[i].endsWith(' ') && appended.includes(newWords[j])) {\n                newWords[i] += newWords[j];\n                newTokens[i] = (0,_utils_core_js__WEBPACK_IMPORTED_MODULE_0__.mergeArrays)(newTokens[i], newTokens[j]);\n                newIndices[i] = (0,_utils_core_js__WEBPACK_IMPORTED_MODULE_0__.mergeArrays)(newIndices[i], newIndices[j]);\n                newWords[j] = '';\n                newTokens[j] = [];\n                newIndices[j] = [];\n            } else {\n                i = j;\n            }\n            ++j;\n        }\n\n        return [\n            newWords.filter(x => x),\n            newTokens.filter(x => x.length > 0),\n            newIndices.filter(x => x.length > 0),\n        ]\n    }\n\n    /**\n     * Helper function to build translation inputs for a `WhisperTokenizer`,\n     * depending on the language, task, and whether to predict timestamp tokens.\n     * \n     * Used to override the prefix tokens appended to the start of the label sequence.\n     * \n     * **Example: Get ids for a language**\n     * ```javascript\n     * // instantiate the tokenizer and set the prefix token to Spanish\n     * let tokenizer = await WhisperTokenizer.from_pretrained('Xenova/whisper-tiny');\n     * let forced_decoder_ids = tokenizer.get_decoder_prompt_ids({ language: 'spanish' });\n     * // [(1, 50262), (2, 50363)]\n     * ```\n     * \n     * @param {Object} options Options to generate the decoder prompt.\n     * @param {string} [options.language] The language of the transcription text.\n     * The corresponding language id token is appended to the start of the sequence for multilingual\n     * speech recognition and speech translation tasks, e.g. for \"Spanish\" the token \"<|es|>\" is appended\n     * to the start of sequence.\n     * @param {string} [options.task] Task identifier to append at the start of sequence (if any).\n     * This should be used for mulitlingual fine-tuning, with \"transcribe\" for speech recognition and\n     * \"translate\" for speech translation.\n     * @param {boolean} [options.no_timestamps] Whether to add the <|notimestamps|> token at the start of the sequence.\n     * @returns {number[][]} The decoder prompt ids.\n     */\n    get_decoder_prompt_ids({\n        language = null,\n        task = null,\n        no_timestamps = true,\n    } = {}) {\n\n        // <|lang_id|> <|task|> <|notimestamps|>\n\n        let forced_decoder_ids = [];\n\n        if (language) {\n            // User wishes to specify the language\n            language = language.toLowerCase();\n\n            // Map to code from user-friendly name (e.g., \"english\" -> \"en\")\n            let language_code = WHISPER_TO_LANGUAGE_CODE_MAPPING.get(language);\n\n            if (language_code === undefined) {\n                // User provided something that is not a language name\n\n                if (WHISPER_LANGUAGE_MAPPING.has(language)) {\n                    // User provided the language code directly (e.g., \"en\")\n                    language_code = language;\n\n                } else {\n                    // User provided something that is not a language code or name\n                    const is_language_code = language.length === 2;\n                    const langs = is_language_code ? WHISPER_LANGUAGE_MAPPING.keys() : WHISPER_LANGUAGE_MAPPING.values();\n\n                    throw new Error(`Language \"${language}\" is not supported. Must be one of: ${JSON.stringify(langs)}`);\n                }\n            }\n\n            let language_token_id = this.model.tokens_to_ids.get(`<|${language_code}|>`);\n            if (language_token_id === undefined) {\n                throw new Error(`Unable to find language \"${language_code}\" in model vocabulary. Please report this issue at https://github.com/xenova/transformers.js/issues/new/choose.`)\n            }\n\n            forced_decoder_ids.push(language_token_id);\n        } else {\n            // No token will be forced, which leaves the model to predict the language\n            forced_decoder_ids.push(null);\n        }\n\n        if (task) {\n            task = task.toLowerCase();\n            if (task !== 'transcribe' && task !== 'translate') {\n                throw new Error(`Task \"${task}\" is not supported. Must be one of: [\"transcribe\", \"translate\"]`);\n            }\n\n            let task_token_id = this.model.tokens_to_ids.get(`<|${task}|>`);\n            if (task_token_id === undefined) {\n                throw new Error(`Unable to find task \"${task}\" in model vocabulary. Please report this issue at https://github.com/xenova/transformers.js/issues/new/choose.`)\n            }\n\n            forced_decoder_ids.push(task_token_id);\n        } else {\n            // No token will be forced, which leaves the model to predict the task\n            forced_decoder_ids.push(null);\n        }\n\n        if (no_timestamps) {\n            let no_timestamps_id = this.model.tokens_to_ids.get(`<|notimestamps|>`);\n            if (no_timestamps_id === undefined) {\n                throw new Error('Unable to find \"<|notimestamps|>\" in model vocabulary. Please report this issue at https://github.com/xenova/transformers.js/issues/new/choose.')\n            }\n\n            forced_decoder_ids.push(no_timestamps_id);\n        }\n\n        return forced_decoder_ids.map((x, i) => [i + 1, x]).filter(x => x[1] !== null);\n\n    }\n}\nclass CodeGenTokenizer extends PreTrainedTokenizer { }\nclass CLIPTokenizer extends PreTrainedTokenizer { }\n\n\n/**\n * @todo This model is not yet supported by Hugging Face's \"fast\" tokenizers library (https://github.com/huggingface/tokenizers).\n * Therefore, this implementation (which is based on fast tokenizers) may produce slightly inaccurate results.\n */\nclass MarianTokenizer extends PreTrainedTokenizer {\n    /**\n     * Create a new MarianTokenizer instance.\n     * @param {Object} tokenizerJSON The JSON of the tokenizer.\n     * @param {Object} tokenizerConfig The config of the tokenizer.\n     */\n    constructor(tokenizerJSON, tokenizerConfig) {\n        super(tokenizerJSON, tokenizerConfig);\n\n        this.languageRegex = /^(>>\\w+<<)\\s*/g;\n\n        this.supported_language_codes = this.model.vocab.filter(\n            x => this.languageRegex.test(x)\n        );\n\n        console.warn('WARNING: `MarianTokenizer` is not yet supported by Hugging Face\\'s \"fast\" tokenizers library. Therefore, you may experience slightly inaccurate results.')\n    }\n\n    /**\n     * Encodes a single text. Overriding this method is necessary since the language codes\n     * must be removed before encoding with sentencepiece model.\n     * @see https://github.com/huggingface/transformers/blob/12d51db243a00726a548a43cc333390ebae731e3/src/transformers/models/marian/tokenization_marian.py#L204-L213\n     *\n     * @param {string|null} text The text to encode.\n     * @returns {Array} The encoded tokens.\n     */\n    _encode_text(text) {\n        if (text === null) return null;\n\n        // Check if text starts with language code:\n        let [matchInfo, ...remainder] = text.trim().split(this.languageRegex);\n\n        if (remainder.length === 0) {\n            // No language code, encode normally\n            return super._encode_text(matchInfo);\n\n        } else if (remainder.length === 2) {\n            // Text starts with language code, so we do not encode it with sentencepiece.\n            let [language, text] = remainder;\n\n            if (!this.supported_language_codes.includes(language)) {\n                console.warn(`Unsupported language code \"${language}\" detected, which may lead to unexpected behavior. Should be one of: ${JSON.stringify(this.supported_language_codes)}`)\n            }\n            return (0,_utils_core_js__WEBPACK_IMPORTED_MODULE_0__.mergeArrays)([language], super._encode_text(text));\n        }\n    }\n\n}\n\n/**\n * A trie structure to efficiently store and search for strings.\n */\nclass CharTrie {\n    constructor() {\n        this.root = CharTrieNode.default();\n    }\n\n    /**\n     * Adds one or more `texts` to the trie.\n     * @param {string[]} texts The strings to add to the trie.\n     */\n    extend(texts) {\n        for (let text of texts) {\n            this.push(text);\n        }\n    }\n\n    /**\n     * Adds one or more `texts` to the trie.\n     * @param {*} text The strings to add to the trie.\n     */\n    push(text) {\n        let node = this.root;\n        for (let ch of text) {\n            let child = node.children.get(ch);\n            if (child === undefined) {\n                child = CharTrieNode.default();\n                node.children.set(ch, child);\n            }\n            node = child;\n        }\n        node.isLeaf = true;\n    }\n\n    /**\n     * Searches the trie for all strings with a common prefix of `text`.\n     * @param {string} text The common prefix to search for.\n     * @yields {string} Each string in the trie that has `text` as a prefix.\n     */\n    *commonPrefixSearch(text) {\n        let node = this.root;\n        let prefix = \"\";\n        for (let i = 0; i < text.length && node !== undefined; ++i) {\n            const ch = text[i];\n            prefix += ch;\n            node = node.children.get(ch);\n            if (node !== undefined && node.isLeaf) {\n                yield prefix;\n            }\n        }\n    }\n}\n\n/**\n * Represents a node in a character trie.\n * @param {boolean} isLeaf Whether the node is a leaf node or not.\n * @param {Map<string, CharTrieNode>} children A map containing the node's children, where the key is a character and the value is a `CharTrieNode`.\n */\nclass CharTrieNode {\n    constructor(isLeaf, children) {\n        this.isLeaf = isLeaf;\n        this.children = children;\n    }\n\n    /**\n     * Returns a new `CharTrieNode` instance with default values.\n     * @returns {CharTrieNode} A new `CharTrieNode` instance with `isLeaf` set to `false` and an empty `children` map.\n     */\n    static default() {\n        return new CharTrieNode(false, new Map());\n    }\n}\n\nclass TokenLattice {\n    /**\n     * Creates a new TokenLattice instance.\n     *\n     * @param {string} sentence The input sentence to be tokenized.\n     * @param {number} bosTokenId The beginning-of-sequence token ID.\n     * @param {number} eosTokenId The end-of-sequence token ID.\n     */\n    constructor(sentence, bosTokenId, eosTokenId) {\n        this.sentence = sentence;\n        this.len = sentence.length;\n        this.bosTokenId = bosTokenId;\n        this.eosTokenId = eosTokenId;\n        this.nodes = [];\n        this.beginNodes = new Array(this.len + 1);\n        this.endNodes = new Array(this.len + 1);\n        for (let i = 0; i < this.len + 1; ++i) {\n            this.beginNodes[i] = [];\n            this.endNodes[i] = [];\n        }\n        const bos = new TokenLatticeNode(this.bosTokenId, 0, 0, 0, 0.0);\n        const eos = new TokenLatticeNode(this.eosTokenId, 1, this.len, 0, 0.0);\n        this.nodes.push(bos.clone());\n        this.nodes.push(eos.clone());\n        this.beginNodes[this.len].push(eos);\n        this.endNodes[0].push(bos);\n    }\n\n    /**\n     * Inserts a new token node into the token lattice.\n     *\n     * @param {number} pos The starting position of the token.\n     * @param {number} length The length of the token.\n     * @param {number} score The score of the token.\n     * @param {number} tokenId The token ID of the token.\n     */\n    insert(pos, length, score, tokenId) {\n        const nodeId = this.nodes.length;\n        const node = new TokenLatticeNode(tokenId, nodeId, pos, length, score);\n        this.beginNodes[pos].push(node);\n        this.endNodes[pos + length].push(node);\n        this.nodes.push(node);\n    }\n\n    /**\n     * Implements the Viterbi algorithm to compute the most likely sequence of tokens.\n     *\n     * @returns {TokenLatticeNode[]} The array of nodes representing the most likely sequence of tokens.\n     */\n    viterbi() {\n        const len = this.len;\n        let pos = 0;\n        while (pos <= len) {\n            if (this.beginNodes[pos].length == 0) {\n                return [];\n            }\n            for (let rnode of this.beginNodes[pos]) {\n                rnode.prev = null;\n                let bestScore = 0.0;\n                let bestNode = null;\n                for (let lnode of this.endNodes[pos]) {\n                    const score = lnode.backtraceScore + rnode.score;\n                    if (bestNode === null || score > bestScore) {\n                        bestNode = lnode.clone();\n                        bestScore = score;\n                    }\n                }\n\n                if (bestNode !== null) {\n                    rnode.prev = bestNode;\n                    rnode.backtraceScore = bestScore;\n                } else {\n                    return [];\n                }\n            }\n            ++pos;\n        }\n\n        const results = [];\n        const root = this.beginNodes[len][0];\n        const prev = root.prev;\n        if (prev === null) {\n            return [];\n        }\n\n        let node = prev.clone();\n        while (node.prev !== null) {\n            results.push(node.clone());\n            const n = node.clone();\n            node = n.prev.clone();\n        }\n\n        results.reverse();\n        return results;\n    }\n\n    /**\n     * @param {TokenLatticeNode} node\n     * @returns {string} The array of nodes representing the most likely sequence of tokens.\n     */\n    piece(node) {\n        return this.sentence.slice(node.pos, node.pos + node.length);\n    }\n\n    /**\n     * @returns {Array} The array of nodes representing the most likely sequence of tokens.\n     */\n    tokens() {\n        const nodes = this.viterbi();\n        return nodes.map(x => this.piece(x));\n    }\n\n    /**\n     * @returns {Array} The array of nodes representing the most likely sequence of tokens.\n     */\n    tokenIds() {\n        const nodes = this.viterbi();\n        return nodes.map(x => x.tokenId);\n    }\n}\nclass TokenLatticeNode {\n    /**\n     * Represents a node in a token lattice for a given sentence.\n     * @param {number} tokenId The ID of the token associated with this node.\n     * @param {number} nodeId The ID of this node.\n     * @param {number} pos The starting position of the token in the sentence.\n     * @param {number} length The length of the token.\n     * @param {number} score The score associated with the token.\n     */\n    constructor(tokenId, nodeId, pos, length, score) {\n        this.tokenId = tokenId;\n        this.nodeId = nodeId;\n        this.pos = pos;\n        this.length = length;\n        this.score = score;\n        this.prev = null;\n        this.backtraceScore = 0.0;\n    }\n\n    /**\n     * Returns a clone of this node.\n     * @returns {TokenLatticeNode} A clone of this node.\n     */\n    clone() {\n        const n = new TokenLatticeNode(this.tokenId, this.nodeId, this.pos, this.length, this.score);\n        n.prev = this.prev;\n        n.backtraceScore = this.backtraceScore;\n        return n;\n    }\n}\n\n/**\n * Helper class which is used to instantiate pretrained tokenizers with the `from_pretrained` function.\n * The chosen tokenizer class is determined by the type specified in the tokenizer config.\n * \n * @example\n * let tokenizer = await AutoTokenizer.from_pretrained('bert-base-uncased');\n */\nclass AutoTokenizer {\n    static TOKENIZER_CLASS_MAPPING = {\n        'T5Tokenizer': T5Tokenizer,\n        'DistilBertTokenizer': DistilBertTokenizer,\n        'BertTokenizer': BertTokenizer,\n        'MobileBertTokenizer': MobileBertTokenizer,\n        'SqueezeBertTokenizer': SqueezeBertTokenizer,\n        'AlbertTokenizer': AlbertTokenizer,\n        'GPT2Tokenizer': GPT2Tokenizer,\n        'BartTokenizer': BartTokenizer,\n        'RobertaTokenizer': RobertaTokenizer,\n        'WhisperTokenizer': WhisperTokenizer,\n        'CodeGenTokenizer': CodeGenTokenizer,\n        'CLIPTokenizer': CLIPTokenizer,\n        'MarianTokenizer': MarianTokenizer,\n        'BloomTokenizer': BloomTokenizer,\n        'NllbTokenizer': NllbTokenizer,\n        'LlamaTokenizer': LlamaTokenizer,\n        'XLMRobertaTokenizer': XLMRobertaTokenizer,\n        'MPNetTokenizer': MPNetTokenizer,\n        'FalconTokenizer': FalconTokenizer,\n        'GPTNeoXTokenizer': GPTNeoXTokenizer,\n\n        // Base case:\n        'PreTrainedTokenizer': PreTrainedTokenizer,\n    }\n\n\n    /**\n     * Instantiate one of the tokenizer classes of the library from a pretrained model.\n     * \n     * The tokenizer class to instantiate is selected based on the `tokenizer_class` property of the config object\n     * (either passed as an argument or loaded from `pretrained_model_name_or_path` if possible)\n     * \n     * @param {string} pretrained_model_name_or_path The name or path of the pretrained model. Can be either:\n     * - A string, the *model id* of a pretrained tokenizer hosted inside a model repo on huggingface.co.\n     *   Valid model ids can be located at the root-level, like `bert-base-uncased`, or namespaced under a\n     *   user or organization name, like `dbmdz/bert-base-german-cased`.\n     * - A path to a *directory* containing tokenizer files, e.g., `./my_model_directory/`.\n     * @param {PretrainedOptions} options Additional options for loading the tokenizer.\n     * \n     * @returns {Promise<PreTrainedTokenizer>} A new instance of the PreTrainedTokenizer class.\n     */\n    static async from_pretrained(pretrained_model_name_or_path, {\n        quantized = true,\n        progress_callback = null,\n        config = null,\n        cache_dir = null,\n        local_files_only = false,\n        revision = 'main',\n    } = {}) {\n\n        let [tokenizerJSON, tokenizerConfig] = await loadTokenizer(pretrained_model_name_or_path, {\n            quantized,\n            progress_callback,\n            config,\n            cache_dir,\n            local_files_only,\n            revision,\n        })\n\n        // Some tokenizers are saved with the \"Fast\" suffix, so we remove that if present.\n        let tokenizerName = tokenizerConfig.tokenizer_class.replace(/Fast$/, '');\n\n        let cls = this.TOKENIZER_CLASS_MAPPING[tokenizerName];\n        if (!cls) {\n            console.warn(`Unknown tokenizer class \"${tokenizerName}\", attempting to construct from base class.`);\n            cls = PreTrainedTokenizer;\n        }\n        return new cls(tokenizerJSON, tokenizerConfig);\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AeGVub3ZhL3RyYW5zZm9ybWVycy9zcmMvdG9rZW5pemVycy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnQkFBZ0I7QUFDNUI7QUFDQTtBQUNBLFNBQVMsWUFBWTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFReUI7O0FBSUQ7O0FBRTJCO0FBQ1I7O0FBRTNDO0FBQ0EsYUFBYSw0Q0FBNEM7QUFDekQ7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLG1CQUFtQjtBQUM5QixhQUFhLGdCQUFnQjtBQUM3QjtBQUNBOztBQUVBO0FBQ0EsUUFBUSwyREFBWTtBQUNwQixRQUFRLDJEQUFZO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQixhQUFhLG9CQUFvQjtBQUNqQztBQUNBOztBQUVBO0FBQ0E7QUFDQSx1REFBdUQsY0FBYzs7QUFFckUsTUFBTTtBQUNOOztBQUVBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLEtBQUs7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsVUFBVTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdURBQXVELFFBQVE7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSw0QkFBNEIsc0JBQXNCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EseUNBQXlDLHNEQUFLOztBQUU5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5Q0FBeUMsc0RBQUs7O0FBRTlDO0FBQ0E7QUFDQSx1Q0FBdUMsc0RBQUs7QUFDNUMsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG1CQUFtQjtBQUNsQztBQUNBLGlCQUFpQiw4QkFBOEI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sSUFBSTs7QUFFVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscURBQXFELGNBQWM7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHhlbm92YS90cmFuc2Zvcm1lcnMvc3JjL3Rva2VuaXplcnMuanM/MjEzZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qKlxuICogQGZpbGUgVG9rZW5pemVycyBhcmUgdXNlZCB0byBwcmVwYXJlIHRleHR1YWwgaW5wdXRzIGZvciBhIG1vZGVsLlxuICogXG4gKiAqKkV4YW1wbGU6KiogQ3JlYXRlIGFuIGBBdXRvVG9rZW5pemVyYCBhbmQgdXNlIGl0IHRvIHRva2VuaXplIGEgc2VudGVuY2UuXG4gKiBUaGlzIHdpbGwgYXV0b21hdGljYWxseSBkZXRlY3QgdGhlIHRva2VuaXplciB0eXBlIGJhc2VkIG9uIHRoZSB0b2tlbml6ZXIgY2xhc3MgZGVmaW5lZCBpbiBgdG9rZW5pemVyLmpzb25gLlxuICogYGBgamF2YXNjcmlwdFxuICogaW1wb3J0IHsgQXV0b1Rva2VuaXplciB9IGZyb20gJ0B4ZW5vdmEvdHJhbnNmb3JtZXJzJztcbiAqIFxuICogbGV0IHRva2VuaXplciA9IGF3YWl0IEF1dG9Ub2tlbml6ZXIuZnJvbV9wcmV0cmFpbmVkKCdiZXJ0LWJhc2UtdW5jYXNlZCcpO1xuICogbGV0IHsgaW5wdXRfaWRzIH0gPSBhd2FpdCB0b2tlbml6ZXIoJ0kgbG92ZSB0cmFuc2Zvcm1lcnMhJyk7XG4gKiAvLyBUZW5zb3Ige1xuICogLy8gICBkYXRhOiBCaWdJbnQ2NEFycmF5KDYpIFsxMDFuLCAxMDQ1biwgMjI5M24sIDE5MDgxbiwgOTk5biwgMTAybl0sXG4gKiAvLyAgIGRpbXM6IFsxLCA2XSxcbiAqIC8vICAgdHlwZTogJ2ludDY0JyxcbiAqIC8vICAgc2l6ZTogNixcbiAqIC8vIH1cbiAqIGBgYFxuICogXG4gKiBAbW9kdWxlIHRva2VuaXplcnNcbiAqL1xuXG5pbXBvcnQge1xuICAgIENhbGxhYmxlLFxuICAgIHJldmVyc2VEaWN0aW9uYXJ5LFxuICAgIGVzY2FwZVJlZ0V4cCxcbiAgICBpc0ludGVncmFsTnVtYmVyLFxuICAgIG1lcmdlQXJyYXlzLFxufSBmcm9tICcuL3V0aWxzL2NvcmUuanMnO1xuXG5pbXBvcnQge1xuICAgIGdldE1vZGVsSlNPTixcbn0gZnJvbSAnLi91dGlscy9odWIuanMnO1xuXG5pbXBvcnQgeyBtYXgsIG1pbiwgcm91bmQgfSBmcm9tICcuL3V0aWxzL21hdGhzLmpzJztcbmltcG9ydCB7IFRlbnNvciB9IGZyb20gJy4vdXRpbHMvdGVuc29yLmpzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuL3V0aWxzL2h1Yi5qcycpLlByZXRyYWluZWRPcHRpb25zfSBQcmV0cmFpbmVkT3B0aW9uc1xuICovXG5cbi8qKlxuICogTG9hZHMgYSB0b2tlbml6ZXIgZnJvbSB0aGUgc3BlY2lmaWVkIHBhdGguXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJldHJhaW5lZF9tb2RlbF9uYW1lX29yX3BhdGggVGhlIHBhdGggdG8gdGhlIHRva2VuaXplciBkaXJlY3RvcnkuXG4gKiBAcGFyYW0ge1ByZXRyYWluZWRPcHRpb25zfSBvcHRpb25zIEFkZGl0aW9uYWwgb3B0aW9ucyBmb3IgbG9hZGluZyB0aGUgdG9rZW5pemVyLlxuICogQHJldHVybnMge1Byb21pc2U8QXJyYXk+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIGluZm9ybWF0aW9uIGFib3V0IHRoZSBsb2FkZWQgdG9rZW5pemVyLlxuICovXG5hc3luYyBmdW5jdGlvbiBsb2FkVG9rZW5pemVyKHByZXRyYWluZWRfbW9kZWxfbmFtZV9vcl9wYXRoLCBvcHRpb25zKSB7XG5cbiAgICBsZXQgaW5mbyA9IGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgZ2V0TW9kZWxKU09OKHByZXRyYWluZWRfbW9kZWxfbmFtZV9vcl9wYXRoLCAndG9rZW5pemVyLmpzb24nLCB0cnVlLCBvcHRpb25zKSxcbiAgICAgICAgZ2V0TW9kZWxKU09OKHByZXRyYWluZWRfbW9kZWxfbmFtZV9vcl9wYXRoLCAndG9rZW5pemVyX2NvbmZpZy5qc29uJywgdHJ1ZSwgb3B0aW9ucyksXG4gICAgXSlcbiAgICByZXR1cm4gaW5mbztcbn1cblxuLyoqXG4gKiBIZWxwZXIgbWV0aG9kIHRvIGNvbnN0cnVjdCBhIHBhdHRlcm4gZnJvbSBhIGNvbmZpZyBvYmplY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gcGF0dGVybiBUaGUgcGF0dGVybiBvYmplY3QuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGludmVydCBXaGV0aGVyIHRvIGludmVydCB0aGUgcGF0dGVybiAob25seSBhcHBsaWNhYmxlIGZvciBSZWdleCBwYXR0ZXJucykuXG4gKiBAcmV0dXJucyB7UmVnRXhwfHN0cmluZ3xudWxsfSBUaGUgY29tcGlsZWQgcGF0dGVybi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlUGF0dGVybihwYXR0ZXJuLCBpbnZlcnQgPSB0cnVlKSB7XG5cbiAgICBpZiAocGF0dGVybi5SZWdleCkge1xuICAgICAgICAvLyBOT1RFOiBpZiBpbnZlcnQgaXMgdHJ1ZSwgd2Ugd3JhcCB0aGUgcGF0dGVybiBpbiBhIGdyb3VwIHNvIHRoYXQgaXQgaXMga2VwdCB3aGVuIHBlcmZvcm1pbmcgLnNwbGl0KClcbiAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAoaW52ZXJ0ID8gcGF0dGVybi5SZWdleCA6IGAoJHtwYXR0ZXJuLlJlZ2V4fSlgLCAnZ3UnKTtcblxuICAgIH0gZWxzZSBpZiAocGF0dGVybi5TdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIHBhdHRlcm4uU3RyaW5nO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdVbmtub3duIHBhdHRlcm4gdHlwZTonLCBwYXR0ZXJuKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG5cbi8qKlxuICogQ2xlYW4gdXAgYSBsaXN0IG9mIHNpbXBsZSBFbmdsaXNoIHRva2VuaXphdGlvbiBhcnRpZmFjdHMgbGlrZSBzcGFjZXMgYmVmb3JlIHB1bmN0dWF0aW9ucyBhbmQgYWJicmV2aWF0ZWQgZm9ybXNcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IFRoZSB0ZXh0IHRvIGNsZWFuIHVwLlxuICogQHJldHVybnMge3N0cmluZ30gVGhlIGNsZWFuZWQgdXAgdGV4dC5cbiAqL1xuZnVuY3Rpb24gY2xlYW5fdXBfdG9rZW5pemF0aW9uKHRleHQpIHtcbiAgICAvLyBDbGVhbiB1cCBhIGxpc3Qgb2Ygc2ltcGxlIEVuZ2xpc2ggdG9rZW5pemF0aW9uIGFydGlmYWN0c1xuICAgIC8vIGxpa2Ugc3BhY2VzIGJlZm9yZSBwdW5jdHVhdGlvbnMgYW5kIGFiYnJldmlhdGVkIGZvcm1zXG4gICAgcmV0dXJuIHRleHQucmVwbGFjZSgvIFxcLi9nLCAnLicpXG4gICAgICAgIC5yZXBsYWNlKC8gXFw/L2csICc/JylcbiAgICAgICAgLnJlcGxhY2UoLyBcXCEvZywgJyEnKVxuICAgICAgICAucmVwbGFjZSgvICwvZywgJywnKVxuICAgICAgICAucmVwbGFjZSgvIFxcJyAvZywgXCInXCIpXG4gICAgICAgIC5yZXBsYWNlKC8gblxcJ3QvZywgXCJuJ3RcIilcbiAgICAgICAgLnJlcGxhY2UoLyBcXCdtL2csIFwiJ21cIilcbiAgICAgICAgLnJlcGxhY2UoLyBcXCdzL2csIFwiJ3NcIilcbiAgICAgICAgLnJlcGxhY2UoLyBcXCd2ZS9nLCBcIid2ZVwiKVxuICAgICAgICAucmVwbGFjZSgvIFxcJ3JlL2csIFwiJ3JlXCIpO1xufVxuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0byBmdXNlIGNvbnNlY3V0aXZlIHZhbHVlcyBpbiBhbiBhcnJheSBlcXVhbCB0byB0aGUgc3BlY2lmaWVkIHZhbHVlLlxuICogQHBhcmFtIHtBcnJheX0gYXJyIFRoZSBpbnB1dCBhcnJheVxuICogQHBhcmFtIHthbnl9IHZhbHVlIFRoZSB2YWx1ZSB0byBmdXNlIG9uLlxuICovXG5mdW5jdGlvbiBmdXNlKGFyciwgdmFsdWUpIHtcbiAgICBsZXQgZnVzZWQgPSBbXTtcbiAgICBsZXQgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBhcnIubGVuZ3RoKSB7XG4gICAgICAgIGZ1c2VkLnB1c2goYXJyW2ldKVxuICAgICAgICBpZiAoYXJyW2ldICE9PSB2YWx1ZSkge1xuICAgICAgICAgICAgKytpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICB3aGlsZSAoaSA8IGFyci5sZW5ndGggJiYgYXJyW2ldID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgKytpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1c2VkO1xufVxuXG4vKipcbiAqIFNwbGl0IGEgc3RyaW5nIG9uIHdoaXRlc3BhY2UuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dCBUaGUgdGV4dCB0byBzcGxpdC5cbiAqIEByZXR1cm5zIHtzdHJpbmdbXX0gVGhlIHNwbGl0IHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gd2hpdGVzcGFjZV9zcGxpdCh0ZXh0KSB7XG4gICAgcmV0dXJuIHRleHQubWF0Y2goL1xcUysvZykgfHwgW107XG59XG5cbmNvbnN0IFBVTkNUVUFUSU9OX1JFR0VYID0gJ1xcXFxwe1B9XFxcXHUwMDIxLVxcXFx1MDAyRlxcXFx1MDAzQS1cXFxcdTAwNDBcXFxcdTAwNUItXFxcXHUwMDYwXFxcXHUwMDdCLVxcXFx1MDA3RSc7XG5cbi8qKlxuICogQWJzdHJhY3QgYmFzZSBjbGFzcyBmb3IgdG9rZW5pemVyIG1vZGVscy5cbiAqXG4gKiBAZXh0ZW5kcyBDYWxsYWJsZVxuICovXG5leHBvcnQgY2xhc3MgVG9rZW5pemVyTW9kZWwgZXh0ZW5kcyBDYWxsYWJsZSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBUb2tlbml6ZXJNb2RlbC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIFRoZSBjb25maWd1cmF0aW9uIG9iamVjdCBmb3IgdGhlIFRva2VuaXplck1vZGVsLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcblxuICAgICAgICAvKiogQHR5cGUge3N0cmluZ1tdfSAqL1xuICAgICAgICB0aGlzLnZvY2FiID0gW107XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgbWFwcGluZyBvZiB0b2tlbnMgdG8gaWRzLlxuICAgICAgICAgKiBAdHlwZSB7TWFwPHN0cmluZywgbnVtYmVyPn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudG9rZW5zX3RvX2lkcyA9IG5ldyBNYXAoKTtcblxuICAgICAgICB0aGlzLnVua190b2tlbl9pZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy51bmtfdG9rZW4gPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuZW5kX29mX3dvcmRfc3VmZml4ID0gdW5kZWZpbmVkO1xuXG4gICAgICAgIC8qKiBAdHlwZSB7Ym9vbGVhbn0gV2hldGhlciB0byBmdXNlIHVua25vd24gdG9rZW5zIHdoZW4gZW5jb2RpbmcuIERlZmF1bHRzIHRvIGZhbHNlLiAqL1xuICAgICAgICB0aGlzLmZ1c2VfdW5rID0gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5zdGFudGlhdGVzIGEgbmV3IFRva2VuaXplck1vZGVsIGluc3RhbmNlIGJhc2VkIG9uIHRoZSBjb25maWd1cmF0aW9uIG9iamVjdCBwcm92aWRlZC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIFRoZSBjb25maWd1cmF0aW9uIG9iamVjdCBmb3IgdGhlIFRva2VuaXplck1vZGVsLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gYXJncyBPcHRpb25hbCBhcmd1bWVudHMgdG8gcGFzcyB0byB0aGUgc3BlY2lmaWMgVG9rZW5pemVyTW9kZWwgY29uc3RydWN0b3IuXG4gICAgICogQHJldHVybnMge1Rva2VuaXplck1vZGVsfSBBIG5ldyBpbnN0YW5jZSBvZiBhIFRva2VuaXplck1vZGVsLlxuICAgICAqIEB0aHJvd3MgV2lsbCB0aHJvdyBhbiBlcnJvciBpZiB0aGUgVG9rZW5pemVyTW9kZWwgdHlwZSBpbiB0aGUgY29uZmlnIGlzIG5vdCByZWNvZ25pemVkLlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tQ29uZmlnKGNvbmZpZywgLi4uYXJncykge1xuICAgICAgICBzd2l0Y2ggKGNvbmZpZy50eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdXb3JkUGllY2UnOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgV29yZFBpZWNlVG9rZW5pemVyKGNvbmZpZyk7XG4gICAgICAgICAgICBjYXNlICdVbmlncmFtJzpcbiAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBVbmlncmFtKGNvbmZpZywgLi4uYXJncyk7XG5cbiAgICAgICAgICAgIGNhc2UgJ0JQRSc6XG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQlBFKGNvbmZpZywgLi4uYXJncyk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBUb2tlbml6ZXJNb2RlbCB0eXBlOiAke2NvbmZpZy50eXBlfWApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW50ZXJuYWwgZnVuY3Rpb24gdG8gY2FsbCB0aGUgVG9rZW5pemVyTW9kZWwgaW5zdGFuY2UuXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gdG9rZW5zIFRoZSB0b2tlbnMgdG8gZW5jb2RlLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJbXX0gVGhlIGVuY29kZWQgdG9rZW4gSURzLlxuICAgICAqL1xuICAgIF9jYWxsKHRva2Vucykge1xuICAgICAgICByZXR1cm4gdGhpcy5lbmNvZGUodG9rZW5zKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFbmNvZGVzIGEgbGlzdCBvZiB0b2tlbnMgaW50byBhIGxpc3Qgb2YgdG9rZW4gSURzLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IHRva2VucyBUaGUgdG9rZW5zIHRvIGVuY29kZS5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyW119IFRoZSBlbmNvZGVkIHRva2VuIElEcy5cbiAgICAgKiBAdGhyb3dzIFdpbGwgdGhyb3cgYW4gZXJyb3IgaWYgbm90IGltcGxlbWVudGVkIGluIGEgc3ViY2xhc3MuXG4gICAgICovXG4gICAgZW5jb2RlKHRva2Vucykge1xuICAgICAgICB0aHJvdyBFcnJvcihcImVuY29kZSBzaG91bGQgYmUgaW1wbGVtZW50ZWQgaW4gc3ViY2xhc3MuXCIpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYSBsaXN0IG9mIHRva2VucyBpbnRvIGEgbGlzdCBvZiB0b2tlbiBJRHMuXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gdG9rZW5zIFRoZSB0b2tlbnMgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyW119IFRoZSBjb252ZXJ0ZWQgdG9rZW4gSURzLlxuICAgICAqL1xuICAgIGNvbnZlcnRfdG9rZW5zX3RvX2lkcyh0b2tlbnMpIHtcbiAgICAgICAgbGV0IGlkcyA9IHRva2Vucy5tYXAodCA9PiB0aGlzLnRva2Vuc190b19pZHMuZ2V0KHQpID8/IHRoaXMudW5rX3Rva2VuX2lkKTtcblxuICAgICAgICBpZiAodGhpcy5mdXNlX3Vuaykge1xuICAgICAgICAgICAgLy8gRnVzZSB1bmtub3duIHRva2Vuc1xuICAgICAgICAgICAgaWRzID0gZnVzZShpZHMsIHRoaXMudW5rX3Rva2VuX2lkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaWRzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGEgbGlzdCBvZiB0b2tlbiBJRHMgaW50byBhIGxpc3Qgb2YgdG9rZW5zLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyW119IGlkcyBUaGUgdG9rZW4gSURzIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge3N0cmluZ1tdfSBUaGUgY29udmVydGVkIHRva2Vucy5cbiAgICAgKi9cbiAgICBjb252ZXJ0X2lkc190b190b2tlbnMoaWRzKSB7XG4gICAgICAgIHJldHVybiBpZHMubWFwKGkgPT4gdGhpcy52b2NhYltpXSA/PyB0aGlzLnVua190b2tlbik7XG4gICAgfVxufVxuXG4vKipcbiAqIEEgc3ViY2xhc3Mgb2YgVG9rZW5pemVyTW9kZWwgdGhhdCB1c2VzIFdvcmRQaWVjZSBlbmNvZGluZyB0byBlbmNvZGUgdG9rZW5zLlxuICogQGV4dGVuZHMgVG9rZW5pemVyTW9kZWxcbiAqL1xuY2xhc3MgV29yZFBpZWNlVG9rZW5pemVyIGV4dGVuZHMgVG9rZW5pemVyTW9kZWwge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgVGhlIGNvbmZpZ3VyYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7TWFwPHN0cmluZywgbnVtYmVyPn0gY29uZmlnLnZvY2FiIEEgbWFwcGluZyBvZiB0b2tlbnMgdG8gaWRzLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb25maWcudW5rX3Rva2VuIFRoZSB1bmtub3duIHRva2VuIHN0cmluZy5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29uZmlnLmNvbnRpbnVpbmdfc3Vid29yZF9wcmVmaXggVGhlIHByZWZpeCB0byB1c2UgZm9yIGNvbnRpbnVpbmcgc3Vid29yZHMuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZyk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIG1hcHBpbmcgb2YgdG9rZW5zIHRvIGlkcy5cbiAgICAgICAgICogQHR5cGUge01hcDxzdHJpbmcsIG51bWJlcj59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnRva2Vuc190b19pZHMgPSBjb25maWcudm9jYWI7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBpZCBvZiB0aGUgdW5rbm93biB0b2tlbi5cbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudW5rX3Rva2VuX2lkID0gdGhpcy50b2tlbnNfdG9faWRzLmdldChjb25maWcudW5rX3Rva2VuKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHVua25vd24gdG9rZW4gc3RyaW5nLlxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy51bmtfdG9rZW4gPSBjb25maWcudW5rX3Rva2VuO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbiBhcnJheSBvZiB0b2tlbnMuXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmdbXX1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudm9jYWIgPSBuZXcgQXJyYXkodGhpcy50b2tlbnNfdG9faWRzLnNpemUpO1xuXG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIHRoaXMudG9rZW5zX3RvX2lkcykge1xuICAgICAgICAgICAgdGhpcy52b2NhYlt2YWx1ZV0gPSBrZXk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFbmNvZGVzIGFuIGFycmF5IG9mIHRva2VucyB1c2luZyBXb3JkUGllY2UgZW5jb2RpbmcuXG4gICAgICogQHBhcmFtIHtBcnJheX0gdG9rZW5zIFRoZSB0b2tlbnMgdG8gZW5jb2RlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gQW4gYXJyYXkgb2YgZW5jb2RlZCB0b2tlbnMuXG4gICAgICovXG4gICAgZW5jb2RlKHRva2Vucykge1xuICAgICAgICBsZXQgb3V0cHV0VG9rZW5zID0gW107XG4gICAgICAgIGZvciAobGV0IHRva2VuIG9mIHRva2Vucykge1xuICAgICAgICAgICAgbGV0IGNoYXJzID0gWy4uLnRva2VuXTtcbiAgICAgICAgICAgIC8vIFRPRE8gYWRkXG4gICAgICAgICAgICAvLyBpZiBsZW4oY2hhcnMpID4gc2VsZi5tYXhfaW5wdXRfY2hhcnNfcGVyX3dvcmQ6XG4gICAgICAgICAgICAvLyAgICAgb3V0cHV0X3Rva2Vucy5hcHBlbmQoc2VsZi51bmtfdG9rZW4pXG4gICAgICAgICAgICAvLyAgICAgY29udGludWVcblxuICAgICAgICAgICAgbGV0IGlzVW5rbm93biA9IGZhbHNlO1xuICAgICAgICAgICAgbGV0IHN0YXJ0ID0gMDtcbiAgICAgICAgICAgIGxldCBzdWJUb2tlbnMgPSBbXTtcblxuICAgICAgICAgICAgd2hpbGUgKHN0YXJ0IDwgY2hhcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgbGV0IGVuZCA9IGNoYXJzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBsZXQgY3VycmVudFN1YnN0cmluZyA9IG51bGw7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHN0YXJ0IDwgZW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBzdWJzdHIgPSBjaGFycy5zbGljZShzdGFydCwgZW5kKS5qb2luKCcnKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhcnQgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJzdHIgPSB0aGlzLmNvbmZpZy5jb250aW51aW5nX3N1YndvcmRfcHJlZml4ICsgc3Vic3RyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnRva2Vuc190b19pZHMuaGFzKHN1YnN0cikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTdWJzdHJpbmcgPSBzdWJzdHI7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC0tZW5kO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudFN1YnN0cmluZyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBpc1Vua25vd24gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3ViVG9rZW5zLnB1c2goY3VycmVudFN1YnN0cmluZyk7XG4gICAgICAgICAgICAgICAgc3RhcnQgPSBlbmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNVbmtub3duKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0VG9rZW5zLnB1c2godGhpcy51bmtfdG9rZW4pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBvdXRwdXRUb2tlbnMucHVzaCguLi5zdWJUb2tlbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG91dHB1dFRva2VucztcbiAgICB9XG5cbn1cblxuLyoqXG4gKiBDbGFzcyByZXByZXNlbnRpbmcgYSBVbmlncmFtIHRva2VuaXplciBtb2RlbC5cbiAqIEBleHRlbmRzIFRva2VuaXplck1vZGVsXG4gKi9cbmNsYXNzIFVuaWdyYW0gZXh0ZW5kcyBUb2tlbml6ZXJNb2RlbCB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IFVuaWdyYW0gdG9rZW5pemVyIG1vZGVsLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgVGhlIGNvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciB0aGUgVW5pZ3JhbSBtb2RlbC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY29uZmlnLnVua19pZCBUaGUgSUQgb2YgdGhlIHVua25vd24gdG9rZW5cbiAgICAgKiBAcGFyYW0ge01hcDxzdHJpbmcsIG51bWJlcj59IGNvbmZpZy52b2NhYiBBIG1hcHBpbmcgb2YgdG9rZW5zIHRvIHNjb3Jlcy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbW9yZUNvbmZpZyBBZGRpdGlvbmFsIGNvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciB0aGUgVW5pZ3JhbSBtb2RlbC5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihjb25maWcsIG1vcmVDb25maWcpIHtcbiAgICAgICAgc3VwZXIoY29uZmlnKTtcblxuICAgICAgICB0aGlzLnZvY2FiID0gbmV3IEFycmF5KGNvbmZpZy52b2NhYi5zaXplKTtcbiAgICAgICAgdGhpcy5zY29yZXMgPSBuZXcgQXJyYXkoY29uZmlnLnZvY2FiLnNpemUpO1xuICAgICAgICBsZXQgY291bnQgPSAwO1xuICAgICAgICBjb25maWcudm9jYWIuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuICAgICAgICAgICAgdGhpcy52b2NhYltjb3VudF0gPSBrZXk7XG4gICAgICAgICAgICB0aGlzLnNjb3Jlc1tjb3VudF0gPSB2YWx1ZTtcbiAgICAgICAgICAgICsrY291bnQ7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMudW5rX3Rva2VuX2lkID0gY29uZmlnLnVua19pZDtcbiAgICAgICAgdGhpcy51bmtfdG9rZW4gPSB0aGlzLnZvY2FiW2NvbmZpZy51bmtfaWRdO1xuXG4gICAgICAgIHRoaXMudG9rZW5zX3RvX2lkcyA9IG5ldyBNYXAodGhpcy52b2NhYi5tYXAoKHgsIGkpID0+IFt4LCBpXSkpO1xuICAgICAgICB0aGlzLmJvc1Rva2VuID0gJyAnOyAvLyBiZWdpbm5pbmcgb2YgYSBzZW50ZW5jZSB0b2tlblxuXG4gICAgICAgIHRoaXMuYm9zVG9rZW5JZCA9IHRoaXMudG9rZW5zX3RvX2lkcy5nZXQodGhpcy5ib3NUb2tlbik7IC8vIE5PVEU6IG1heSBiZSB1bmRlZmluZWRcbiAgICAgICAgdGhpcy5lb3NUb2tlbiA9IG1vcmVDb25maWcuZW9zX3Rva2VuO1xuXG4gICAgICAgIHRoaXMuZW9zVG9rZW5JZCA9IHRoaXMudG9rZW5zX3RvX2lkcy5nZXQodGhpcy5lb3NUb2tlbik7XG4gICAgICAgIHRoaXMudW5rVG9rZW4gPSB0aGlzLnZvY2FiW3RoaXMudW5rX3Rva2VuX2lkXTtcblxuICAgICAgICB0aGlzLm1pblNjb3JlID0gbWluKHRoaXMuc2NvcmVzKVswXTtcblxuICAgICAgICB0aGlzLnVua1Njb3JlID0gdGhpcy5taW5TY29yZSAtIDEwLjA7XG4gICAgICAgIHRoaXMuc2NvcmVzW3RoaXMudW5rX3Rva2VuX2lkXSA9IHRoaXMudW5rU2NvcmU7XG5cbiAgICAgICAgdGhpcy50cmllID0gbmV3IENoYXJUcmllKCk7XG4gICAgICAgIHRoaXMudHJpZS5leHRlbmQodGhpcy52b2NhYik7XG5cbiAgICAgICAgLy8gTk9URTogYGZ1c2VfdW5rYCBpcyBoYXJkY29kZWQgdG8gdHJ1ZSBmb3IgVW5pZ3JhbSBtb2RlbHNcbiAgICAgICAgLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vaHVnZ2luZ2ZhY2UvdG9rZW5pemVycy9ibG9iL2I1ODIyN2M3ZjFjY2Y4YjczZWUyMjY4MzU0MzM2ZGE1NmQ5MWU0OTIvdG9rZW5pemVycy9zcmMvbW9kZWxzL3VuaWdyYW0vbW9kZWwucnMjTDExOVxuICAgICAgICB0aGlzLmZ1c2VfdW5rID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQb3B1bGF0ZXMgbGF0dGljZSBub2Rlcy5cbiAgICAgKiBAcGFyYW0ge1Rva2VuTGF0dGljZX0gbGF0dGljZSBUaGUgdG9rZW4gbGF0dGljZSB0byBwb3B1bGF0ZSB3aXRoIG5vZGVzLlxuICAgICAqL1xuICAgIHBvcHVsYXRlTm9kZXMobGF0dGljZSkge1xuICAgICAgICBjb25zdCBzZW50ZW5jZSA9IGxhdHRpY2Uuc2VudGVuY2U7XG4gICAgICAgIGNvbnN0IGxlbiA9IHNlbnRlbmNlLmxlbmd0aDtcbiAgICAgICAgbGV0IGJlZ2luUG9zID0gMDtcbiAgICAgICAgd2hpbGUgKGJlZ2luUG9zIDwgbGVuKSB7XG4gICAgICAgICAgICBjb25zdCBtYmxlbiA9IDE7XG4gICAgICAgICAgICBsZXQgaGFzU2luZ2xlTm9kZSA9IGZhbHNlO1xuICAgICAgICAgICAgY29uc3QgdG9rZW5zID0gW107XG5cbiAgICAgICAgICAgIGZvciAobGV0IHRva2VuIG9mIHRoaXMudHJpZS5jb21tb25QcmVmaXhTZWFyY2goc2VudGVuY2Uuc2xpY2UoYmVnaW5Qb3MpKSkge1xuICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0b2tlbklkID0gdGhpcy50b2tlbnNfdG9faWRzLmdldCh0b2tlbik7XG4gICAgICAgICAgICAgICAgY29uc3QgdG9rZW5TY29yZSA9IHRoaXMuc2NvcmVzW3Rva2VuSWRdO1xuICAgICAgICAgICAgICAgIGNvbnN0IG4gPSB0b2tlbi5sZW5ndGg7XG4gICAgICAgICAgICAgICAgbGF0dGljZS5pbnNlcnQoYmVnaW5Qb3MsIG4sIHRva2VuU2NvcmUsIHRva2VuSWQpO1xuICAgICAgICAgICAgICAgIGlmICghaGFzU2luZ2xlTm9kZSAmJiBuID09PSBtYmxlbikge1xuICAgICAgICAgICAgICAgICAgICBoYXNTaW5nbGVOb2RlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWhhc1NpbmdsZU5vZGUpIHtcbiAgICAgICAgICAgICAgICBsYXR0aWNlLmluc2VydChiZWdpblBvcywgbWJsZW4sIHRoaXMudW5rU2NvcmUsIHRoaXMudW5rX3Rva2VuX2lkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJlZ2luUG9zICs9IG1ibGVuO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRW5jb2RlcyBhbiBhcnJheSBvZiB0b2tlbnMgaW50byBhbiBhcnJheSBvZiBzdWJ0b2tlbnMgdXNpbmcgdGhlIHVuaWdyYW0gbW9kZWwuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbm9ybWFsaXplZCBUaGUgbm9ybWFsaXplZCBzdHJpbmcuXG4gICAgICogQHJldHVybnMge3N0cmluZ1tdfSBBbiBhcnJheSBvZiBzdWJ0b2tlbnMgb2J0YWluZWQgYnkgZW5jb2RpbmcgdGhlIGlucHV0IHRva2VucyB1c2luZyB0aGUgdW5pZ3JhbSBtb2RlbC5cbiAgICAgKi9cbiAgICB0b2tlbml6ZShub3JtYWxpemVkKSB7XG4gICAgICAgIGNvbnN0IGxhdHRpY2UgPSBuZXcgVG9rZW5MYXR0aWNlKG5vcm1hbGl6ZWQsIHRoaXMuYm9zVG9rZW5JZCwgdGhpcy5lb3NUb2tlbklkKTtcbiAgICAgICAgdGhpcy5wb3B1bGF0ZU5vZGVzKGxhdHRpY2UpO1xuICAgICAgICByZXR1cm4gbGF0dGljZS50b2tlbnMoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFbmNvZGVzIGFuIGFycmF5IG9mIHRva2VucyB1c2luZyBXb3JkUGllY2UgZW5jb2RpbmcuXG4gICAgICogQHBhcmFtIHtBcnJheX0gdG9rZW5zIFRoZSB0b2tlbnMgdG8gZW5jb2RlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gQW4gYXJyYXkgb2YgZW5jb2RlZCB0b2tlbnMuXG4gICAgICovXG4gICAgZW5jb2RlKHRva2Vucykge1xuICAgICAgICBsZXQgdG9SZXR1cm4gPSBbXTtcbiAgICAgICAgZm9yIChsZXQgdG9rZW4gb2YgdG9rZW5zKSB7XG4gICAgICAgICAgICBjb25zdCB0b2tlbml6ZWQgPSB0aGlzLnRva2VuaXplKHRva2VuKTtcbiAgICAgICAgICAgIHRvUmV0dXJuLnB1c2goLi4udG9rZW5pemVkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG9SZXR1cm47XG4gICAgfVxuXG59XG5cbi8qKlxuICogUmV0dXJucyBsaXN0IG9mIHV0Zi04IGJ5dGUgYW5kIGEgbWFwcGluZyB0byB1bmljb2RlIHN0cmluZ3MuXG4gKiBTcGVjaWZpY2FsbHkgYXZvaWRzIG1hcHBpbmcgdG8gd2hpdGVzcGFjZS9jb250cm9sIGNoYXJhY3RlcnMgdGhlIEJQRSBjb2RlIGJhcmZzIG9uLlxuICogQHJldHVybnMge09iamVjdH0gT2JqZWN0IHdpdGggdXRmLTggYnl0ZSBrZXlzIGFuZCB1bmljb2RlIHN0cmluZyB2YWx1ZXMuXG4gKi9cbmNvbnN0IEJZVEVTX1RPX1VOSUNPREUgPSAoKCkgPT4ge1xuICAgIC8vIFJldHVybnMgbGlzdCBvZiB1dGYtOCBieXRlIGFuZCBhIG1hcHBpbmcgdG8gdW5pY29kZSBzdHJpbmdzLlxuICAgIC8vIFdlIHNwZWNpZmljYWxseSBhdm9pZHMgbWFwcGluZyB0byB3aGl0ZXNwYWNlL2NvbnRyb2wgY2hhcmFjdGVyc1xuICAgIC8vIHRoZSBicGUgY29kZSBiYXJmcyBvbi5cblxuICAgIGNvbnN0IGJzID0gW1xuICAgICAgICAuLi5BcnJheS5mcm9tKHsgbGVuZ3RoOiBcIn5cIi5jaGFyQ29kZUF0KDApIC0gXCIhXCIuY2hhckNvZGVBdCgwKSArIDEgfSwgKF8sIGkpID0+IGkgKyBcIiFcIi5jaGFyQ29kZUF0KDApKSxcbiAgICAgICAgLi4uQXJyYXkuZnJvbSh7IGxlbmd0aDogXCLCrFwiLmNoYXJDb2RlQXQoMCkgLSBcIsKhXCIuY2hhckNvZGVBdCgwKSArIDEgfSwgKF8sIGkpID0+IGkgKyBcIsKhXCIuY2hhckNvZGVBdCgwKSksXG4gICAgICAgIC4uLkFycmF5LmZyb20oeyBsZW5ndGg6IFwiw79cIi5jaGFyQ29kZUF0KDApIC0gXCLCrlwiLmNoYXJDb2RlQXQoMCkgKyAxIH0sIChfLCBpKSA9PiBpICsgXCLCrlwiLmNoYXJDb2RlQXQoMCkpLFxuICAgIF07XG4gICAgbGV0IGNzID0gYnMuc2xpY2UoKTtcbiAgICBsZXQgbiA9IDA7XG4gICAgZm9yIChsZXQgYiA9IDA7IGIgPCAyNTY7ICsrYikge1xuICAgICAgICBpZiAoIWJzLmluY2x1ZGVzKGIpKSB7XG4gICAgICAgICAgICBicy5wdXNoKGIpO1xuICAgICAgICAgICAgY3MucHVzaCgyNTYgKyBuKTtcbiAgICAgICAgICAgIG4gKz0gMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXQgY2NzID0gY3MubWFwKG4gPT4gU3RyaW5nLmZyb21DaGFyQ29kZShuKSk7XG4gICAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhicy5tYXAoKGIsIGkpID0+IFtiLCBjY3NbaV1dKSk7XG59KSgpO1xuXG5jb25zdCBVTklDT0RFX1RPX0JZVEVTID0gcmV2ZXJzZURpY3Rpb25hcnkoQllURVNfVE9fVU5JQ09ERSk7XG5cbi8qKlxuICogQlBFIGNsYXNzIGZvciBlbmNvZGluZyB0ZXh0IGludG8gQnl0ZS1QYWlyLUVuY29kaW5nIChCUEUpIHRva2Vucy5cbiAqIEBleHRlbmRzIFRva2VuaXplck1vZGVsXG4gKi9cbmNsYXNzIEJQRSBleHRlbmRzIFRva2VuaXplck1vZGVsIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBCUEUgaW5zdGFuY2UuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBUaGUgY29uZmlndXJhdGlvbiBvYmplY3QgZm9yIEJQRS5cbiAgICAgKiBAcGFyYW0ge01hcDxzdHJpbmcsIG51bWJlcj59IGNvbmZpZy52b2NhYiBBIG1hcHBpbmcgb2YgdG9rZW5zIHRvIGlkcy5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29uZmlnLnVua190b2tlbiBUaGUgdW5rbm93biB0b2tlbiB1c2VkIGZvciBvdXQgb2Ygdm9jYWJ1bGFyeSB3b3Jkcy5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29uZmlnLmVuZF9vZl93b3JkX3N1ZmZpeCBUaGUgc3VmZml4IHRvIHBsYWNlIGF0IHRoZSBlbmQgb2YgZWFjaCB3b3JkLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGNvbmZpZy5tZXJnZXMgQW4gYXJyYXkgb2YgQlBFIG1lcmdlcyBhcyBzdHJpbmdzLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgICAgICBzdXBlcihjb25maWcpO1xuXG4gICAgICAgIHRoaXMuQlBFX1NQTElUX1RPS0VOID0gJyAnO1xuXG4gICAgICAgIHRoaXMudG9rZW5zX3RvX2lkcyA9IGNvbmZpZy52b2NhYjtcblxuICAgICAgICB0aGlzLnVua190b2tlbl9pZCA9IHRoaXMudG9rZW5zX3RvX2lkcy5nZXQoY29uZmlnLnVua190b2tlbik7XG4gICAgICAgIHRoaXMudW5rX3Rva2VuID0gY29uZmlnLnVua190b2tlbjtcblxuICAgICAgICB0aGlzLnZvY2FiID0gbmV3IEFycmF5KHRoaXMudG9rZW5zX3RvX2lkcy5zaXplKTtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgdGhpcy50b2tlbnNfdG9faWRzKSB7XG4gICAgICAgICAgICB0aGlzLnZvY2FiW3ZhbHVlXSA9IGtleTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuYnBlX3JhbmtzID0gT2JqZWN0LmZyb21FbnRyaWVzKGNvbmZpZy5tZXJnZXMubWFwKCh4LCBpKSA9PiBbeCwgaV0pKTtcbiAgICAgICAgdGhpcy5tZXJnZXMgPSBjb25maWcubWVyZ2VzLm1hcCh4ID0+IHguc3BsaXQodGhpcy5CUEVfU1BMSVRfVE9LRU4pKTtcblxuICAgICAgICB0aGlzLmVuZF9vZl93b3JkX3N1ZmZpeCA9IGNvbmZpZy5lbmRfb2Zfd29yZF9zdWZmaXg7XG5cbiAgICAgICAgdGhpcy5ieXRlX2ZhbGxiYWNrID0gdGhpcy5jb25maWcuYnl0ZV9mYWxsYmFjayA/PyBmYWxzZTtcblxuICAgICAgICBpZiAodGhpcy5ieXRlX2ZhbGxiYWNrKSB7XG4gICAgICAgICAgICB0aGlzLnRleHRfZW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgICAgICAgdGhpcy5mdXNlX3VuayA/Pz0gdGhpcy5jb25maWcuZnVzZV91bms7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IGFsbCB0aGUgcG9zc2libGUgcGFpcnMgb2YgY2hhcmFjdGVycyBpbiBhIHdvcmQuXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gd29yZCBUaGUgd29yZCB0byBnZXQgcGFpcnMgZnJvbS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IEFuIGFycmF5IG9mIHBhaXJzLlxuICAgICAqL1xuICAgIGdldF9wYWlycyh3b3JkKSB7XG4gICAgICAgIGxldCBwYWlycyA9IG5ldyBTZXQoKTtcbiAgICAgICAgbGV0IHByZXZfY2hhciA9IHdvcmRbMF07XG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgd29yZC5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgbGV0IGNoYXIgPSB3b3JkW2ldO1xuICAgICAgICAgICAgcGFpcnMuYWRkKHByZXZfY2hhciArIHRoaXMuQlBFX1NQTElUX1RPS0VOICsgY2hhcik7XG4gICAgICAgICAgICBwcmV2X2NoYXIgPSBjaGFyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKHBhaXJzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBcHBseSBCeXRlLVBhaXItRW5jb2RpbmcgKEJQRSkgdG8gYSBnaXZlbiB0b2tlbi5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdG9rZW4gVGhlIHRva2VuIHRvIGVuY29kZS5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgQlBFIGVuY29kZWQgdG9rZW4uXG4gICAgICovXG4gICAgYnBlKHRva2VuKSB7XG4gICAgICAgIGlmICh0b2tlbiBpbiB0aGlzLmNhY2hlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jYWNoZVt0b2tlbl07XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHdvcmQgPSBBcnJheS5mcm9tKHRva2VuKTtcbiAgICAgICAgaWYgKHRoaXMuZW5kX29mX3dvcmRfc3VmZml4KSB7XG4gICAgICAgICAgICB3b3JkW3dvcmQubGVuZ3RoIC0gMV0gKz0gdGhpcy5lbmRfb2Zfd29yZF9zdWZmaXg7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHBhaXJzID0gdGhpcy5nZXRfcGFpcnMod29yZCk7XG5cbiAgICAgICAgaWYgKCFwYWlycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmVuZF9vZl93b3JkX3N1ZmZpeCkge1xuICAgICAgICAgICAgICAgIHRva2VuICs9IHRoaXMuZW5kX29mX3dvcmRfc3VmZml4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgICAgICB9XG5cbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIGxldCBiaWdyYW0gPSBwYWlycy5yZWR1Y2UoKGEsIGIpID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgYyA9IHRoaXMuYnBlX3JhbmtzW2FdID8/IEluZmluaXR5XG4gICAgICAgICAgICAgICAgbGV0IGQgPSB0aGlzLmJwZV9yYW5rc1tiXSA/PyBJbmZpbml0eVxuICAgICAgICAgICAgICAgIHJldHVybiBjIDw9IGQgPyBhIDogYjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKCEoYmlncmFtIGluIHRoaXMuYnBlX3JhbmtzKSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IFtmaXJzdCwgc2Vjb25kXSA9IGJpZ3JhbS5zcGxpdCh0aGlzLkJQRV9TUExJVF9UT0tFTik7XG4gICAgICAgICAgICBsZXQgbmV3X3dvcmQgPSBbXTtcbiAgICAgICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgICAgIGxldCBqID0gLTE7XG5cbiAgICAgICAgICAgIHdoaWxlIChpIDwgd29yZC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBqID0gd29yZC5pbmRleE9mKGZpcnN0LCBpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGogPT09IC0xKSB0aHJvdyBcIkVycm9yXCI7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBuZXdfd29yZC5wdXNoKC4uLndvcmQuc2xpY2UoaSkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbmV3X3dvcmQucHVzaCguLi53b3JkLnNsaWNlKGksIGopKTtcbiAgICAgICAgICAgICAgICBpID0gajtcblxuICAgICAgICAgICAgICAgIGlmICh3b3JkW2ldID09PSBmaXJzdCAmJiBpIDwgd29yZC5sZW5ndGggLSAxICYmIHdvcmRbaSArIDFdID09PSBzZWNvbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3X3dvcmQucHVzaChmaXJzdCArIHNlY29uZCk7XG4gICAgICAgICAgICAgICAgICAgIGkgKz0gMjtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBuZXdfd29yZC5wdXNoKHdvcmRbaV0pO1xuICAgICAgICAgICAgICAgICAgICBpICs9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd29yZCA9IG5ld193b3JkXG4gICAgICAgICAgICBpZiAod29yZC5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcGFpcnMgPSB0aGlzLmdldF9wYWlycyh3b3JkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgZmluYWxfd29yZCA9IHdvcmQuam9pbih0aGlzLkJQRV9TUExJVF9UT0tFTik7XG4gICAgICAgIHRoaXMuY2FjaGVbdG9rZW5dID0gZmluYWxfd29yZDtcbiAgICAgICAgcmV0dXJuIGZpbmFsX3dvcmQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRW5jb2RlcyB0aGUgaW5wdXQgc2VxdWVuY2Ugb2YgdG9rZW5zIHVzaW5nIHRoZSBCUEUgYWxnb3JpdGhtIGFuZCByZXR1cm5zIHRoZSByZXN1bHRpbmcgc3Vid29yZCB0b2tlbnMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gdG9rZW5zIFRoZSBpbnB1dCBzZXF1ZW5jZSBvZiB0b2tlbnMgdG8gZW5jb2RlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gVGhlIHJlc3VsdGluZyBzdWJ3b3JkIHRva2VucyBhZnRlciBhcHBseWluZyB0aGUgQlBFIGFsZ29yaXRobSB0byB0aGUgaW5wdXQgc2VxdWVuY2Ugb2YgdG9rZW5zLlxuICAgICAqL1xuICAgIGVuY29kZSh0b2tlbnMpIHtcbiAgICAgICAgbGV0IG91dHB1dFRva2VucyA9IFtdO1xuXG4gICAgICAgIGZvciAobGV0IHRva2VuIG9mIHRva2Vucykge1xuICAgICAgICAgICAgbGV0IGJwZV90b2tlbl9saXN0ID0gdGhpcy5icGUodG9rZW4pLnNwbGl0KHRoaXMuQlBFX1NQTElUX1RPS0VOKTtcblxuICAgICAgICAgICAgZm9yIChsZXQgdCBvZiBicGVfdG9rZW5fbGlzdCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnRva2Vuc190b19pZHMuaGFzKHQpKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dFRva2Vucy5wdXNoKHQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmJ5dGVfZmFsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dFRva2Vucy5wdXNoKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLkFycmF5LmZyb20odGhpcy50ZXh0X2VuY29kZXIuZW5jb2RlKHQpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAubWFwKHggPT4gYDwweCR7eC50b1N0cmluZygxNikudG9VcHBlckNhc2UoKS5wYWRTdGFydCgyLCAnMCcpfT5gKVxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dFRva2Vucy5wdXNoKHRoaXMudW5rX3Rva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvdXRwdXRUb2tlbnM7XG4gICAgfVxuXG59XG5cbi8qKlxuICogQSBiYXNlIGNsYXNzIGZvciB0ZXh0IG5vcm1hbGl6YXRpb24uXG4gKiBAYWJzdHJhY3RcbiAqL1xuY2xhc3MgTm9ybWFsaXplciBleHRlbmRzIENhbGxhYmxlIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIFRoZSBjb25maWd1cmF0aW9uIG9iamVjdCBmb3IgdGhlIG5vcm1hbGl6ZXIuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZhY3RvcnkgbWV0aG9kIGZvciBjcmVhdGluZyBub3JtYWxpemVycyBmcm9tIGNvbmZpZyBvYmplY3RzLlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIFRoZSBjb25maWd1cmF0aW9uIG9iamVjdCBmb3IgdGhlIG5vcm1hbGl6ZXIuXG4gICAgICogQHJldHVybnMge05vcm1hbGl6ZXJ9IEEgTm9ybWFsaXplciBvYmplY3QuXG4gICAgICogQHRocm93cyB7RXJyb3J9IElmIGFuIHVua25vd24gTm9ybWFsaXplciB0eXBlIGlzIHNwZWNpZmllZCBpbiB0aGUgY29uZmlnLlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tQ29uZmlnKGNvbmZpZykge1xuICAgICAgICBpZiAoY29uZmlnID09PSBudWxsKSByZXR1cm4gbnVsbDtcbiAgICAgICAgc3dpdGNoIChjb25maWcudHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnQmVydE5vcm1hbGl6ZXInOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQmVydE5vcm1hbGl6ZXIoY29uZmlnKTtcbiAgICAgICAgICAgIGNhc2UgJ1ByZWNvbXBpbGVkJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByZWNvbXBpbGVkKGNvbmZpZyk7XG4gICAgICAgICAgICBjYXNlICdTZXF1ZW5jZSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBOb3JtYWxpemVyU2VxdWVuY2UoY29uZmlnKTtcbiAgICAgICAgICAgIGNhc2UgJ1JlcGxhY2UnOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUmVwbGFjZShjb25maWcpO1xuICAgICAgICAgICAgY2FzZSAnTkZDJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IE5GQyhjb25maWcpO1xuICAgICAgICAgICAgY2FzZSAnTkZLRCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBORktEKGNvbmZpZyk7XG4gICAgICAgICAgICBjYXNlICdTdHJpcEFjY2VudHMnOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU3RyaXBBY2NlbnRzKGNvbmZpZyk7XG4gICAgICAgICAgICBjYXNlICdMb3dlcmNhc2UnOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgTG93ZXJjYXNlKGNvbmZpZyk7XG4gICAgICAgICAgICBjYXNlICdQcmVwZW5kJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByZXBlbmQoY29uZmlnKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIE5vcm1hbGl6ZXIgdHlwZTogJHtjb25maWcudHlwZX1gKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE5vcm1hbGl6ZSB0aGUgaW5wdXQgdGV4dC5cbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCBUaGUgdGV4dCB0byBub3JtYWxpemUuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gVGhlIG5vcm1hbGl6ZWQgdGV4dC5cbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhpcyBtZXRob2QgaXMgbm90IGltcGxlbWVudGVkIGluIGEgc3ViY2xhc3MuXG4gICAgICovXG4gICAgbm9ybWFsaXplKHRleHQpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJub3JtYWxpemUgc2hvdWxkIGJlIGltcGxlbWVudGVkIGluIHN1YmNsYXNzLlwiKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFsaWFzIGZvciB7QGxpbmsgTm9ybWFsaXplciNub3JtYWxpemV9LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IFRoZSB0ZXh0IHRvIG5vcm1hbGl6ZS5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgbm9ybWFsaXplZCB0ZXh0LlxuICAgICAqL1xuICAgIF9jYWxsKHRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubm9ybWFsaXplKHRleHQpO1xuICAgIH1cblxufVxuXG4vKipcbiAqIFJlcGxhY2Ugbm9ybWFsaXplciB0aGF0IHJlcGxhY2VzIG9jY3VycmVuY2VzIG9mIGEgcGF0dGVybiB3aXRoIGEgZ2l2ZW4gc3RyaW5nIG9yIHJlZ3VsYXIgZXhwcmVzc2lvbi5cbiAqIEBleHRlbmRzIE5vcm1hbGl6ZXJcbiAqL1xuY2xhc3MgUmVwbGFjZSBleHRlbmRzIE5vcm1hbGl6ZXIge1xuICAgIC8qKlxuICAgICAqIE5vcm1hbGl6ZSB0aGUgaW5wdXQgdGV4dCBieSByZXBsYWNpbmcgdGhlIHBhdHRlcm4gd2l0aCB0aGUgY29udGVudC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCBUaGUgaW5wdXQgdGV4dCB0byBiZSBub3JtYWxpemVkLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBub3JtYWxpemVkIHRleHQgYWZ0ZXIgcmVwbGFjaW5nIHRoZSBwYXR0ZXJuIHdpdGggdGhlIGNvbnRlbnQuXG4gICAgICovXG4gICAgbm9ybWFsaXplKHRleHQpIHtcbiAgICAgICAgbGV0IHBhdHRlcm4gPSBjcmVhdGVQYXR0ZXJuKHRoaXMuY29uZmlnLnBhdHRlcm4pO1xuICAgICAgICBpZiAocGF0dGVybiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgICAgIH1cblxuICAgICAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlQWxsKHBhdHRlcm4sIHRoaXMuY29uZmlnLmNvbnRlbnQpXG5cbiAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfVxufVxuXG4vKipcbiAqIEEgbm9ybWFsaXplciB0aGF0IGFwcGxpZXMgVW5pY29kZSBub3JtYWxpemF0aW9uIGZvcm0gQyAoTkZDKSB0byB0aGUgaW5wdXQgdGV4dC5cbiAqIEBleHRlbmRzIE5vcm1hbGl6ZXJcbiAqL1xuY2xhc3MgTkZDIGV4dGVuZHMgTm9ybWFsaXplciB7XG4gICAgLyoqXG4gICAgICogTm9ybWFsaXplIHRoZSBpbnB1dCB0ZXh0IGJ5IGFwcGx5aW5nIFVuaWNvZGUgbm9ybWFsaXphdGlvbiBmb3JtIEMgKE5GQykuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgVGhlIGlucHV0IHRleHQgdG8gYmUgbm9ybWFsaXplZC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgbm9ybWFsaXplZCB0ZXh0LlxuICAgICAqL1xuICAgIG5vcm1hbGl6ZSh0ZXh0KSB7XG4gICAgICAgIHRleHQgPSB0ZXh0Lm5vcm1hbGl6ZSgnTkZDJylcbiAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfVxufVxuXG4vKipcbiAqIE5GS0QgTm9ybWFsaXplci5cbiAqIEBleHRlbmRzIE5vcm1hbGl6ZXJcbiAqL1xuY2xhc3MgTkZLRCBleHRlbmRzIE5vcm1hbGl6ZXIge1xuICAgIC8qKlxuICAgICAqIE5vcm1hbGl6ZSB0ZXh0IHVzaW5nIE5GS0Qgbm9ybWFsaXphdGlvbi5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCBUaGUgdGV4dCB0byBiZSBub3JtYWxpemVkLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBub3JtYWxpemVkIHRleHQuXG4gICAgICovXG4gICAgbm9ybWFsaXplKHRleHQpIHtcbiAgICAgICAgdGV4dCA9IHRleHQubm9ybWFsaXplKCdORktEJylcbiAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfVxufVxuXG4vKipcbiAqIFN0cmlwQWNjZW50cyBub3JtYWxpemVyIHJlbW92ZXMgYWxsIGFjY2VudHMgZnJvbSB0aGUgdGV4dC5cbiAqIEBleHRlbmRzIE5vcm1hbGl6ZXJcbiAqL1xuY2xhc3MgU3RyaXBBY2NlbnRzIGV4dGVuZHMgTm9ybWFsaXplciB7XG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGFsbCBhY2NlbnRzIGZyb20gdGhlIHRleHQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgVGhlIGlucHV0IHRleHQuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gVGhlIG5vcm1hbGl6ZWQgdGV4dCB3aXRob3V0IGFjY2VudHMuXG4gICAgICovXG4gICAgbm9ybWFsaXplKHRleHQpIHtcbiAgICAgICAgdGV4dCA9IHRleHQucmVwbGFjZSgvW1xcdTAzMDAtXFx1MDM2Zl0vZywgJycpO1xuICAgICAgICByZXR1cm4gdGV4dDtcbiAgICB9XG59XG5cbi8qKlxuICogQSBOb3JtYWxpemVyIHRoYXQgbG93ZXJjYXNlcyB0aGUgaW5wdXQgc3RyaW5nLlxuICogQGV4dGVuZHMgTm9ybWFsaXplclxuICovXG5jbGFzcyBMb3dlcmNhc2UgZXh0ZW5kcyBOb3JtYWxpemVyIHtcbiAgICAvKipcbiAgICAgKiBMb3dlcmNhc2VzIHRoZSBpbnB1dCBzdHJpbmcuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgVGhlIHRleHQgdG8gbm9ybWFsaXplLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBub3JtYWxpemVkIHRleHQuXG4gICAgICovXG4gICAgbm9ybWFsaXplKHRleHQpIHtcbiAgICAgICAgdGV4dCA9IHRleHQudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfVxufVxuXG4vKipcbiAqIEEgTm9ybWFsaXplciB0aGF0IHByZXBlbmRzIGEgc3RyaW5nIHRvIHRoZSBpbnB1dCBzdHJpbmcuXG4gKiBAZXh0ZW5kcyBOb3JtYWxpemVyXG4gKi9cbmNsYXNzIFByZXBlbmQgZXh0ZW5kcyBOb3JtYWxpemVyIHtcbiAgICAvKipcbiAgICAgKiBQcmVwZW5kcyB0aGUgaW5wdXQgc3RyaW5nLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IFRoZSB0ZXh0IHRvIG5vcm1hbGl6ZS5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgbm9ybWFsaXplZCB0ZXh0LlxuICAgICAqL1xuICAgIG5vcm1hbGl6ZSh0ZXh0KSB7XG4gICAgICAgIHRleHQgPSB0aGlzLmNvbmZpZy5wcmVwZW5kICsgdGV4dDtcbiAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfVxufVxuXG4vKipcbiAqIEEgTm9ybWFsaXplciB0aGF0IGFwcGxpZXMgYSBzZXF1ZW5jZSBvZiBOb3JtYWxpemVycy5cbiAqIEBleHRlbmRzIE5vcm1hbGl6ZXJcbiAqL1xuY2xhc3MgTm9ybWFsaXplclNlcXVlbmNlIGV4dGVuZHMgTm9ybWFsaXplciB7XG4gICAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBpbnN0YW5jZSBvZiBOb3JtYWxpemVyU2VxdWVuY2UuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgVGhlIGNvbmZpZ3VyYXRpb24gb2JqZWN0LlxuICAgKiBAcGFyYW0ge09iamVjdFtdfSBjb25maWcubm9ybWFsaXplcnMgQW4gYXJyYXkgb2YgTm9ybWFsaXplciBjb25maWd1cmF0aW9uIG9iamVjdHMuXG4gICAqL1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgICAgICBzdXBlcihjb25maWcpO1xuICAgICAgICB0aGlzLm5vcm1hbGl6ZXJzID0gY29uZmlnLm5vcm1hbGl6ZXJzLm1hcCh4ID0+IE5vcm1hbGl6ZXIuZnJvbUNvbmZpZyh4KSk7XG4gICAgfVxuICAgIC8qKlxuICAgICogQXBwbHkgYSBzZXF1ZW5jZSBvZiBOb3JtYWxpemVycyB0byB0aGUgaW5wdXQgdGV4dC5cbiAgICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IFRoZSB0ZXh0IHRvIG5vcm1hbGl6ZS5cbiAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBub3JtYWxpemVkIHRleHQuXG4gICAgKi9cbiAgICBub3JtYWxpemUodGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ub3JtYWxpemVycy5yZWR1Y2UoKHQsIG5vcm1hbGl6ZXIpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBub3JtYWxpemVyLm5vcm1hbGl6ZSh0KTtcbiAgICAgICAgfSwgdGV4dCk7XG4gICAgfVxufVxuXG4vKipcbiAqIEEgY2xhc3MgcmVwcmVzZW50aW5nIGEgbm9ybWFsaXplciB1c2VkIGluIEJFUlQgdG9rZW5pemF0aW9uLlxuICogQGV4dGVuZHMgTm9ybWFsaXplclxuICovXG5jbGFzcyBCZXJ0Tm9ybWFsaXplciBleHRlbmRzIE5vcm1hbGl6ZXIge1xuICAgIC8qKlxuICAgICAqIEFkZHMgd2hpdGVzcGFjZSBhcm91bmQgYW55IENKSyAoQ2hpbmVzZSwgSmFwYW5lc2UsIG9yIEtvcmVhbikgY2hhcmFjdGVyIGluIHRoZSBpbnB1dCB0ZXh0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgVGhlIGlucHV0IHRleHQgdG8gdG9rZW5pemUuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gVGhlIHRva2VuaXplZCB0ZXh0IHdpdGggd2hpdGVzcGFjZSBhZGRlZCBhcm91bmQgQ0pLIGNoYXJhY3RlcnMuXG4gICAgICovXG4gICAgX3Rva2VuaXplX2NoaW5lc2VfY2hhcnModGV4dCkge1xuICAgICAgICAvKiBBZGRzIHdoaXRlc3BhY2UgYXJvdW5kIGFueSBDSksgY2hhcmFjdGVyLiAqL1xuICAgICAgICBsZXQgb3V0cHV0ID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGV4dC5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgbGV0IGNoYXIgPSB0ZXh0W2ldO1xuICAgICAgICAgICAgbGV0IGNwID0gY2hhci5jaGFyQ29kZUF0KDApO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2lzX2NoaW5lc2VfY2hhcihjcCkpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQucHVzaChcIiBcIik7XG4gICAgICAgICAgICAgICAgb3V0cHV0LnB1c2goY2hhcik7XG4gICAgICAgICAgICAgICAgb3V0cHV0LnB1c2goXCIgXCIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQucHVzaChjaGFyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0cHV0LmpvaW4oXCJcIik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIFVuaWNvZGUgY29kZXBvaW50IHJlcHJlc2VudHMgYSBDSksgKENoaW5lc2UsIEphcGFuZXNlLCBvciBLb3JlYW4pIGNoYXJhY3Rlci5cbiAgICAgKlxuICAgICAqIEEgXCJjaGluZXNlIGNoYXJhY3RlclwiIGlzIGRlZmluZWQgYXMgYW55dGhpbmcgaW4gdGhlIENKSyBVbmljb2RlIGJsb2NrOlxuICAgICAqIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NKS19VbmlmaWVkX0lkZW9ncmFwaHNfKFVuaWNvZGVfYmxvY2spXG4gICAgICpcbiAgICAgKiBOb3RlIHRoYXQgdGhlIENKSyBVbmljb2RlIGJsb2NrIGlzIE5PVCBhbGwgSmFwYW5lc2UgYW5kIEtvcmVhbiBjaGFyYWN0ZXJzLCBkZXNwaXRlIGl0cyBuYW1lLlxuICAgICAqIFRoZSBtb2Rlcm4gS29yZWFuIEhhbmd1bCBhbHBoYWJldCBpcyBhIGRpZmZlcmVudCBibG9jaywgYXMgaXMgSmFwYW5lc2UgSGlyYWdhbmEgYW5kIEthdGFrYW5hLlxuICAgICAqIFRob3NlIGFscGhhYmV0cyBhcmUgdXNlZCB0byB3cml0ZSBzcGFjZS1zZXBhcmF0ZWQgd29yZHMsIHNvIHRoZXkgYXJlIG5vdCB0cmVhdGVkIHNwZWNpYWxseVxuICAgICAqIGFuZCBhcmUgaGFuZGxlZCBsaWtlIGFsbCBvdGhlciBsYW5ndWFnZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY3AgVGhlIFVuaWNvZGUgY29kZXBvaW50IHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSBjb2RlcG9pbnQgcmVwcmVzZW50cyBhIENKSyBjaGFyYWN0ZXIsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBfaXNfY2hpbmVzZV9jaGFyKGNwKSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAoY3AgPj0gMHg0RTAwICYmIGNwIDw9IDB4OUZGRilcbiAgICAgICAgICAgIHx8IChjcCA+PSAweDM0MDAgJiYgY3AgPD0gMHg0REJGKVxuICAgICAgICAgICAgfHwgKGNwID49IDB4MjAwMDAgJiYgY3AgPD0gMHgyQTZERilcbiAgICAgICAgICAgIHx8IChjcCA+PSAweDJBNzAwICYmIGNwIDw9IDB4MkI3M0YpXG4gICAgICAgICAgICB8fCAoY3AgPj0gMHgyQjc0MCAmJiBjcCA8PSAweDJCODFGKVxuICAgICAgICAgICAgfHwgKGNwID49IDB4MkI4MjAgJiYgY3AgPD0gMHgyQ0VBRilcbiAgICAgICAgICAgIHx8IChjcCA+PSAweEY5MDAgJiYgY3AgPD0gMHhGQUZGKVxuICAgICAgICAgICAgfHwgKGNwID49IDB4MkY4MDAgJiYgY3AgPD0gMHgyRkExRilcbiAgICAgICAgKVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdHJpcHMgYWNjZW50cyBmcm9tIHRoZSBnaXZlbiB0ZXh0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IFRoZSB0ZXh0IHRvIHN0cmlwIGFjY2VudHMgZnJvbS5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgdGV4dCB3aXRoIGFjY2VudHMgcmVtb3ZlZC5cbiAgICAgKi9cbiAgICBzdHJpcEFjY2VudHModGV4dCkge1xuICAgICAgICByZXR1cm4gdGV4dC5ub3JtYWxpemUoJ05GRCcpLnJlcGxhY2UoL1tcXHUwMzAwLVxcdTAzNmZdL2csICcnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBOb3JtYWxpemVzIHRoZSBnaXZlbiB0ZXh0IGJhc2VkIG9uIHRoZSBjb25maWd1cmF0aW9uLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IFRoZSB0ZXh0IHRvIG5vcm1hbGl6ZS5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgbm9ybWFsaXplZCB0ZXh0LlxuICAgICAqL1xuICAgIG5vcm1hbGl6ZSh0ZXh0KSB7XG4gICAgICAgIC8vIFRPRE8gdXNlIHJlc3Qgb2YgY29uZmlnXG4gICAgICAgIC8vIGNvbmZpZy5jbGVhbl90ZXh0LFxuICAgICAgICAvLyBjb25maWcuaGFuZGxlX2NoaW5lc2VfY2hhcnMsXG4gICAgICAgIC8vIGNvbmZpZy5zdHJpcF9hY2NlbnRzLFxuICAgICAgICAvLyBjb25maWcubG93ZXJjYXNlLFxuXG4gICAgICAgIGlmICh0aGlzLmNvbmZpZy5oYW5kbGVfY2hpbmVzZV9jaGFycykge1xuICAgICAgICAgICAgdGV4dCA9IHRoaXMuX3Rva2VuaXplX2NoaW5lc2VfY2hhcnModGV4dCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5jb25maWcubG93ZXJjYXNlKSB7XG4gICAgICAgICAgICB0ZXh0ID0gdGV4dC50b0xvd2VyQ2FzZSgpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWcuc3RyaXBfYWNjZW50cyAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICB0ZXh0ID0gdGhpcy5zdHJpcEFjY2VudHModGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5jb25maWcuc3RyaXBfYWNjZW50cykge1xuICAgICAgICAgICAgdGV4dCA9IHRoaXMuc3RyaXBBY2NlbnRzKHRleHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfVxufVxuXG4vKipcbiAqIEEgY2FsbGFibGUgY2xhc3MgcmVwcmVzZW50aW5nIGEgcHJlLXRva2VuaXplciB1c2VkIGluIHRva2VuaXphdGlvbi4gU3ViY2xhc3Nlc1xuICogc2hvdWxkIGltcGxlbWVudCB0aGUgYHByZV90b2tlbml6ZV90ZXh0YCBtZXRob2QgdG8gZGVmaW5lIHRoZSBzcGVjaWZpYyBwcmUtdG9rZW5pemF0aW9uIGxvZ2ljLlxuICogQGV4dGVuZHMgQ2FsbGFibGVcbiAqL1xuY2xhc3MgUHJlVG9rZW5pemVyIGV4dGVuZHMgQ2FsbGFibGUge1xuICAgIC8qKlxuICAgKiBGYWN0b3J5IG1ldGhvZCB0aGF0IHJldHVybnMgYW4gaW5zdGFuY2Ugb2YgYSBzdWJjbGFzcyBvZiBgUHJlVG9rZW5pemVyYCBiYXNlZCBvbiB0aGUgcHJvdmlkZWQgY29uZmlndXJhdGlvbi5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIEEgY29uZmlndXJhdGlvbiBvYmplY3QgZm9yIHRoZSBwcmUtdG9rZW5pemVyLlxuICAgKiBAcmV0dXJucyB7UHJlVG9rZW5pemVyfSBBbiBpbnN0YW5jZSBvZiBhIHN1YmNsYXNzIG9mIGBQcmVUb2tlbml6ZXJgLlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHByb3ZpZGVkIGNvbmZpZ3VyYXRpb24gb2JqZWN0IGRvZXMgbm90IGNvcnJlc3BvbmQgdG8gYW55IGtub3duIHByZS10b2tlbml6ZXIuXG4gICAqL1xuICAgIHN0YXRpYyBmcm9tQ29uZmlnKGNvbmZpZykge1xuICAgICAgICBpZiAoY29uZmlnID09PSBudWxsKSByZXR1cm4gbnVsbDtcblxuICAgICAgICBzd2l0Y2ggKGNvbmZpZy50eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdCZXJ0UHJlVG9rZW5pemVyJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEJlcnRQcmVUb2tlbml6ZXIoY29uZmlnKTtcbiAgICAgICAgICAgIGNhc2UgJ1NlcXVlbmNlJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByZVRva2VuaXplclNlcXVlbmNlKGNvbmZpZyk7XG4gICAgICAgICAgICBjYXNlICdXaGl0ZXNwYWNlU3BsaXQnOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgV2hpdGVzcGFjZVNwbGl0KGNvbmZpZyk7XG4gICAgICAgICAgICBjYXNlICdNZXRhc3BhY2UnOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgTWV0YXNwYWNlUHJlVG9rZW5pemVyKGNvbmZpZyk7XG5cbiAgICAgICAgICAgIGNhc2UgJ0J5dGVMZXZlbCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBCeXRlTGV2ZWxQcmVUb2tlbml6ZXIoY29uZmlnKTtcbiAgICAgICAgICAgIGNhc2UgJ1NwbGl0JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFNwbGl0UHJlVG9rZW5pemVyKGNvbmZpZyk7XG4gICAgICAgICAgICBjYXNlICdQdW5jdHVhdGlvbic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQdW5jdHVhdGlvblByZVRva2VuaXplcihjb25maWcpO1xuICAgICAgICAgICAgY2FzZSAnRGlnaXRzJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IERpZ2l0c1ByZVRva2VuaXplcihjb25maWcpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gUHJlVG9rZW5pemVyIHR5cGU6ICR7Y29uZmlnLnR5cGV9YCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICogTWV0aG9kIHRoYXQgc2hvdWxkIGJlIGltcGxlbWVudGVkIGJ5IHN1YmNsYXNzZXMgdG8gZGVmaW5lIHRoZSBzcGVjaWZpYyBwcmUtdG9rZW5pemF0aW9uIGxvZ2ljLlxuICAgKlxuICAgKiBAYWJzdHJhY3RcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgVGhlIHRleHQgdG8gcHJlLXRva2VuaXplLlxuICAgKiBAcmV0dXJucyB7c3RyaW5nW119IFRoZSBwcmUtdG9rZW5pemVkIHRleHQuXG4gICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgbWV0aG9kIGlzIG5vdCBpbXBsZW1lbnRlZCBpbiB0aGUgc3ViY2xhc3MuXG4gICAqL1xuICAgIHByZV90b2tlbml6ZV90ZXh0KHRleHQpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJwcmVfdG9rZW5pemVfdGV4dCBzaG91bGQgYmUgaW1wbGVtZW50ZWQgaW4gc3ViY2xhc3MuXCIpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVG9rZW5pemVzIHRoZSBnaXZlbiB0ZXh0IGludG8gcHJlLXRva2Vucy5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXX0gdGV4dCBUaGUgdGV4dCBvciBhcnJheSBvZiB0ZXh0cyB0byBwcmUtdG9rZW5pemUuXG4gICAgICogQHJldHVybnMge3N0cmluZ1tdfSBBbiBhcnJheSBvZiBwcmUtdG9rZW5zLlxuICAgICAqL1xuICAgIHByZV90b2tlbml6ZSh0ZXh0KSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodGV4dCkpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRleHQubWFwKHggPT4gdGhpcy5wcmVfdG9rZW5pemVfdGV4dCh4KSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMucHJlX3Rva2VuaXplX3RleHQodGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdC5mbGF0KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWxpYXMgZm9yIHtAbGluayBQcmVUb2tlbml6ZXIjcHJlX3Rva2VuaXplfS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXX0gdGV4dCBUaGUgdGV4dCBvciBhcnJheSBvZiB0ZXh0cyB0byBwcmUtdG9rZW5pemUuXG4gICAgICogQHJldHVybnMge3N0cmluZ1tdfSBBbiBhcnJheSBvZiBwcmUtdG9rZW5zLlxuICAgICAqL1xuICAgIF9jYWxsKHRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJlX3Rva2VuaXplKHRleHQpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAZXh0ZW5kcyBQcmVUb2tlbml6ZXJcbiAqL1xuY2xhc3MgQmVydFByZVRva2VuaXplciBleHRlbmRzIFByZVRva2VuaXplciB7XG4gICAgLyoqXG4gICAgICogQSBQcmVUb2tlbml6ZXIgdGhhdCBzcGxpdHMgdGV4dCBpbnRvIHdvcmRwaWVjZXMgdXNpbmcgYSBiYXNpYyB0b2tlbml6YXRpb24gc2NoZW1lXG4gICAgICogc2ltaWxhciB0byB0aGF0IHVzZWQgaW4gdGhlIG9yaWdpbmFsIGltcGxlbWVudGF0aW9uIG9mIEJFUlQuXG4gICAgICogXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBUaGUgY29uZmlndXJhdGlvbiBvYmplY3QuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIC8vIENvbnN0cnVjdCBhIHBhdHRlcm4gd2hpY2ggbWF0Y2hlcyB0aGUgcnVzdCBpbXBsZW1lbnRhdGlvbjpcbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2h1Z2dpbmdmYWNlL3Rva2VuaXplcnMvYmxvYi9iNGZjYzljZTZlNGFkNTgwNmU4MjgyNmY4MTZhY2ZkZmRjNGZjYzY3L3Rva2VuaXplcnMvc3JjL3ByZV90b2tlbml6ZXJzL2JlcnQucnMjTDExXG4gICAgICAgIC8vIEVxdWl2YWxlbnQgdG8gcmVtb3Zpbmcgd2hpdGVzcGFjZSBhbmQgc3BsaXR0aW5nIG9uIHB1bmN0dWF0aW9uIChib3RoIFxccHtQfSBhbmQgb3RoZXIgYXNjaWkgY2hhcmFjdGVycylcbiAgICAgICAgdGhpcy5wYXR0ZXJuID0gbmV3IFJlZ0V4cChgW15cXFxccyR7UFVOQ1RVQVRJT05fUkVHRVh9XSt8WyR7UFVOQ1RVQVRJT05fUkVHRVh9XWAsICdndScpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUb2tlbml6ZXMgYSBzaW5nbGUgdGV4dCB1c2luZyB0aGUgQkVSVCBwcmUtdG9rZW5pemF0aW9uIHNjaGVtZS5cbiAgICAgKiBcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCBUaGUgdGV4dCB0byB0b2tlbml6ZS5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nW119IEFuIGFycmF5IG9mIHRva2Vucy5cbiAgICAgKi9cbiAgICBwcmVfdG9rZW5pemVfdGV4dCh0ZXh0KSB7XG4gICAgICAgIHJldHVybiB0ZXh0LnRyaW0oKS5tYXRjaCh0aGlzLnBhdHRlcm4pIHx8IFtdO1xuICAgIH1cbn1cblxuLyoqXG4gKiBBIHByZS10b2tlbml6ZXIgdGhhdCBzcGxpdHMgdGV4dCBpbnRvIEJ5dGUtUGFpci1FbmNvZGluZyAoQlBFKSBzdWJ3b3Jkcy5cbiAqIEBleHRlbmRzIFByZVRva2VuaXplclxuICovXG5jbGFzcyBCeXRlTGV2ZWxQcmVUb2tlbml6ZXIgZXh0ZW5kcyBQcmVUb2tlbml6ZXIge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgdGhlIGBCeXRlTGV2ZWxQcmVUb2tlbml6ZXJgIGNsYXNzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgVGhlIGNvbmZpZ3VyYXRpb24gb2JqZWN0LlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59IFdoZXRoZXIgdG8gYWRkIGEgbGVhZGluZyBzcGFjZSB0byB0aGUgZmlyc3Qgd29yZC5cbiAgICAgICAgICogVGhpcyBhbGxvd3MgdG8gdHJlYXQgdGhlIGxlYWRpbmcgd29yZCBqdXN0IGFzIGFueSBvdGhlciB3b3JkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5hZGRfcHJlZml4X3NwYWNlID0gdGhpcy5jb25maWcuYWRkX3ByZWZpeF9zcGFjZTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59IFdoZXRoZXIgdGhlIHBvc3QgcHJvY2Vzc2luZyBzdGVwIHNob3VsZCB0cmltIG9mZnNldHNcbiAgICAgICAgICogdG8gYXZvaWQgaW5jbHVkaW5nIHdoaXRlc3BhY2VzLlxuICAgICAgICAgKiBAdG9kbyBVc2UgdGhpcyBpbiB0aGUgcHJldG9rZW5pemF0aW9uIHN0ZXAuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnRyaW1fb2Zmc2V0cyA9IHRoaXMuY29uZmlnLnRyaW1fb2Zmc2V0cztcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59IFdoZXRoZXIgdG8gdXNlIHRoZSBzdGFuZGFyZCBHUFQyIHJlZ2V4IGZvciB3aGl0ZXNwYWNlIHNwbGl0dGluZy5cbiAgICAgICAgICogU2V0IGl0IHRvIEZhbHNlIGlmIHlvdSB3YW50IHRvIHVzZSB5b3VyIG93biBzcGxpdHRpbmcuIERlZmF1bHRzIHRvIHRydWUuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnVzZV9yZWdleCA9IHRoaXMuY29uZmlnLnVzZV9yZWdleCA/PyB0cnVlO1xuICAgICAgICB0aGlzLnBhdHRlcm4gPSAvJ3N8J3R8J3JlfCd2ZXwnbXwnbGx8J2R8ID9cXHB7TH0rfCA/XFxwe059K3wgP1teXFxzXFxwe0x9XFxwe059XSt8XFxzKyg/IVxcUyl8XFxzKy9ndTtcblxuICAgICAgICB0aGlzLmJ5dGVfZW5jb2RlciA9IEJZVEVTX1RPX1VOSUNPREU7XG4gICAgICAgIHRoaXMudGV4dF9lbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVG9rZW5pemVzIGEgc2luZ2xlIHBpZWNlIG9mIHRleHQgdXNpbmcgYnl0ZS1sZXZlbCB0b2tlbml6YXRpb24uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgVGhlIHRleHQgdG8gdG9rZW5pemUuXG4gICAgICogQHJldHVybnMge3N0cmluZ1tdfSBBbiBhcnJheSBvZiB0b2tlbnMuXG4gICAgICovXG4gICAgcHJlX3Rva2VuaXplX3RleHQodGV4dCkge1xuICAgICAgICAvLyBTcGxpdCBvbiB3aGl0ZXNwYWNlIGFuZCBwdW5jdHVhdGlvblxuICAgICAgICBsZXQgdG9rZW5zID0gdGhpcy51c2VfcmVnZXggPyAodGV4dC5tYXRjaCh0aGlzLnBhdHRlcm4pIHx8IFtdKSA6IFt0ZXh0XTtcblxuICAgICAgICByZXR1cm4gdG9rZW5zLm1hcCh0b2tlbiA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5hZGRfcHJlZml4X3NwYWNlICYmICF0b2tlbi5zdGFydHNXaXRoKCcgJykpIHtcbiAgICAgICAgICAgICAgICB0b2tlbiA9ICcgJyArIHRva2VuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBNYXBzIGFsbCBvdXIgYnl0ZXMgdG8gdW5pY29kZSBzdHJpbmdzLCBhdm9pZGluZyBjb250cm9sIHRva2VucyBvZiB0aGUgQlBFIChzcGFjZXMgaW4gb3VyIGNhc2UpXG4gICAgICAgICAgICB0b2tlbiA9IEFycmF5LmZyb20odGhpcy50ZXh0X2VuY29kZXIuZW5jb2RlKHRva2VuKSwgYnl0ZSA9PiB0aGlzLmJ5dGVfZW5jb2RlcltieXRlXSkuam9pbignJyk7XG5cbiAgICAgICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG4vKipcbiAqIEB0eXBlZGVmIHsncmVtb3ZlZCd8J2lzb2xhdGVkJ3wnbWVyZ2VkV2l0aFByZXZpb3VzJ3wnbWVyZ2VkV2l0aE5leHQnfCdjb250aWd1b3VzJ30gU3BsaXREZWxpbWl0ZXJCZWhhdmlvclxuICovXG5cbi8qKlxuICogU3BsaXRzIHRleHQgdXNpbmcgYSBnaXZlbiBwYXR0ZXJuLlxuICogQGV4dGVuZHMgUHJlVG9rZW5pemVyXG4gKi9cbmNsYXNzIFNwbGl0UHJlVG9rZW5pemVyIGV4dGVuZHMgUHJlVG9rZW5pemVyIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIFRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgZm9yIHRoZSBwcmUtdG9rZW5pemVyLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcucGF0dGVybiBUaGUgcGF0dGVybiB1c2VkIHRvIHNwbGl0IHRoZSB0ZXh0LiBDYW4gYmUgYSBzdHJpbmcgb3IgYSByZWdleCBvYmplY3QuXG4gICAgICogQHBhcmFtIHtzdHJpbmd8dW5kZWZpbmVkfSBjb25maWcucGF0dGVybi5TdHJpbmcgVGhlIHN0cmluZyB0byB1c2UgZm9yIHNwbGl0dGluZy4gT25seSBkZWZpbmVkIGlmIHRoZSBwYXR0ZXJuIGlzIGEgc3RyaW5nLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfHVuZGVmaW5lZH0gY29uZmlnLnBhdHRlcm4uUmVnZXggVGhlIHJlZ2V4IHRvIHVzZSBmb3Igc3BsaXR0aW5nLiBPbmx5IGRlZmluZWQgaWYgdGhlIHBhdHRlcm4gaXMgYSByZWdleC5cbiAgICAgKiBAcGFyYW0ge1NwbGl0RGVsaW1pdGVyQmVoYXZpb3J9IGNvbmZpZy5iZWhhdmlvciBUaGUgYmVoYXZpb3IgdG8gdXNlIHdoZW4gc3BsaXR0aW5nLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gY29uZmlnLmludmVydCBXaGV0aGVyIHRvIHNwbGl0IChpbnZlcnQ9ZmFsc2UpIG9yIG1hdGNoIChpbnZlcnQ9dHJ1ZSkgdGhlIHBhdHRlcm4uXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgICAgICAvLyBUT0RPIHN1cHBvcnQgYWxsIGJlaGF2aW91cnMgKGNvbmZpZy5iZWhhdmlvcilcblxuICAgICAgICB0aGlzLnBhdHRlcm4gPSBjcmVhdGVQYXR0ZXJuKHRoaXMuY29uZmlnLnBhdHRlcm4sIHRoaXMuY29uZmlnLmludmVydCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVG9rZW5pemVzIHRleHQgYnkgc3BsaXR0aW5nIGl0IHVzaW5nIHRoZSBnaXZlbiBwYXR0ZXJuLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IFRoZSB0ZXh0IHRvIHRva2VuaXplLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmdbXX0gQW4gYXJyYXkgb2YgdG9rZW5zLlxuICAgICAqL1xuICAgIHByZV90b2tlbml6ZV90ZXh0KHRleHQpIHtcbiAgICAgICAgaWYgKHRoaXMucGF0dGVybiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuY29uZmlnLmludmVydCkge1xuICAgICAgICAgICAgcmV0dXJuIHRleHQubWF0Y2godGhpcy5wYXR0ZXJuKSB8fCBbXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0ZXh0LnNwbGl0KHRoaXMucGF0dGVybikuZmlsdGVyKHggPT4geCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKlxuICogU3BsaXRzIHRleHQgYmFzZWQgb24gcHVuY3R1YXRpb24uXG4gKiBAZXh0ZW5kcyBQcmVUb2tlbml6ZXJcbiAqL1xuY2xhc3MgUHVuY3R1YXRpb25QcmVUb2tlbml6ZXIgZXh0ZW5kcyBQcmVUb2tlbml6ZXIge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyBmb3IgdGhlIHByZS10b2tlbml6ZXIuXG4gICAgICogQHBhcmFtIHtTcGxpdERlbGltaXRlckJlaGF2aW9yfSBjb25maWcuYmVoYXZpb3IgVGhlIGJlaGF2aW9yIHRvIHVzZSB3aGVuIHNwbGl0dGluZy5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgICAgIHRoaXMucGF0dGVybiA9IG5ldyBSZWdFeHAoYFteJHtQVU5DVFVBVElPTl9SRUdFWH1dK3xbJHtQVU5DVFVBVElPTl9SRUdFWH1dK2AsICdndScpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRva2VuaXplcyB0ZXh0IGJ5IHNwbGl0dGluZyBpdCB1c2luZyB0aGUgZ2l2ZW4gcGF0dGVybi5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCBUaGUgdGV4dCB0byB0b2tlbml6ZS5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nW119IEFuIGFycmF5IG9mIHRva2Vucy5cbiAgICAgKi9cbiAgICBwcmVfdG9rZW5pemVfdGV4dCh0ZXh0KSB7XG4gICAgICAgIHJldHVybiB0ZXh0Lm1hdGNoKHRoaXMucGF0dGVybikgfHwgW107XG4gICAgfVxufVxuXG5cbi8qKlxuICogU3BsaXRzIHRleHQgYmFzZWQgb24gZGlnaXRzLlxuICogQGV4dGVuZHMgUHJlVG9rZW5pemVyXG4gKi9cbmNsYXNzIERpZ2l0c1ByZVRva2VuaXplciBleHRlbmRzIFByZVRva2VuaXplciB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBUaGUgY29uZmlndXJhdGlvbiBvcHRpb25zIGZvciB0aGUgcHJlLXRva2VuaXplci5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGNvbmZpZy5pbmRpdmlkdWFsX2RpZ2l0cyBXaGV0aGVyIHRvIHNwbGl0IG9uIGluZGl2aWR1YWwgZGlnaXRzLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcblxuICAgICAgICAvLyBDb25zdHJ1Y3QgYSBwYXR0ZXJuIHdoaWNoIG1hdGNoZXMgdGhlIHJ1c3QgaW1wbGVtZW50YXRpb246XG4gICAgICAgIGNvbnN0IGRpZ2l0X3BhdHRlcm4gPSBgW15cXFxcZF0rfFxcXFxkJHt0aGlzLmNvbmZpZy5pbmRpdmlkdWFsX2RpZ2l0cyA/ICcnIDogJysnfWA7XG4gICAgICAgIHRoaXMucGF0dGVybiA9IG5ldyBSZWdFeHAoZGlnaXRfcGF0dGVybiwgJ2d1Jyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVG9rZW5pemVzIHRleHQgYnkgc3BsaXR0aW5nIGl0IHVzaW5nIHRoZSBnaXZlbiBwYXR0ZXJuLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IFRoZSB0ZXh0IHRvIHRva2VuaXplLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmdbXX0gQW4gYXJyYXkgb2YgdG9rZW5zLlxuICAgICAqL1xuICAgIHByZV90b2tlbml6ZV90ZXh0KHRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRleHQubWF0Y2godGhpcy5wYXR0ZXJuKSB8fCBbXTtcbiAgICB9XG59XG5cbi8qKlxuICogQGV4dGVuZHMgQ2FsbGFibGVcbiAqL1xuY2xhc3MgUG9zdFByb2Nlc3NvciBleHRlbmRzIENhbGxhYmxlIHtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgVGhlIGNvbmZpZ3VyYXRpb24gZm9yIHRoZSBwb3N0LXByb2Nlc3Nvci5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmFjdG9yeSBtZXRob2QgdG8gY3JlYXRlIGEgUG9zdFByb2Nlc3NvciBvYmplY3QgZnJvbSBhIGNvbmZpZ3VyYXRpb24gb2JqZWN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBDb25maWd1cmF0aW9uIG9iamVjdCByZXByZXNlbnRpbmcgYSBQb3N0UHJvY2Vzc29yLlxuICAgICAqIEByZXR1cm5zIHtQb3N0UHJvY2Vzc29yfSBBIFBvc3RQcm9jZXNzb3Igb2JqZWN0IGNyZWF0ZWQgZnJvbSB0aGUgZ2l2ZW4gY29uZmlndXJhdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgYW4gdW5rbm93biBQb3N0UHJvY2Vzc29yIHR5cGUgaXMgZW5jb3VudGVyZWQuXG4gICAgICovXG4gICAgc3RhdGljIGZyb21Db25maWcoY29uZmlnKSB7XG4gICAgICAgIGlmIChjb25maWcgPT09IG51bGwpIHJldHVybiBudWxsO1xuICAgICAgICBzd2l0Y2ggKGNvbmZpZy50eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdUZW1wbGF0ZVByb2Nlc3NpbmcnOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVGVtcGxhdGVQcm9jZXNzaW5nKGNvbmZpZyk7XG5cbiAgICAgICAgICAgIGNhc2UgJ0J5dGVMZXZlbCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBCeXRlTGV2ZWxQb3N0UHJvY2Vzc29yKGNvbmZpZyk7XG5cbiAgICAgICAgICAgIGNhc2UgJ1JvYmVydGFQcm9jZXNzaW5nJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFJvYmVydGFQcm9jZXNzaW5nKGNvbmZpZyk7XG5cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIFBvc3RQcm9jZXNzb3IgdHlwZTogJHtjb25maWcudHlwZX1gKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB0byBiZSBpbXBsZW1lbnRlZCBpbiBzdWJjbGFzcyB0byBhcHBseSBwb3N0LXByb2Nlc3Npbmcgb24gdGhlIGdpdmVuIHRva2Vucy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHRva2VucyBUaGUgaW5wdXQgdG9rZW5zIHRvIGJlIHBvc3QtcHJvY2Vzc2VkLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gYXJncyBBZGRpdGlvbmFsIGFyZ3VtZW50cyByZXF1aXJlZCBieSB0aGUgcG9zdC1wcm9jZXNzaW5nIGxvZ2ljLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gVGhlIHBvc3QtcHJvY2Vzc2VkIHRva2Vucy5cbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIG1ldGhvZCBpcyBub3QgaW1wbGVtZW50ZWQgaW4gc3ViY2xhc3MuXG4gICAgICovXG4gICAgcG9zdF9wcm9jZXNzKHRva2VucywgLi4uYXJncykge1xuICAgICAgICB0aHJvdyBFcnJvcihcInBvc3RfcHJvY2VzcyBzaG91bGQgYmUgaW1wbGVtZW50ZWQgaW4gc3ViY2xhc3MuXCIpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWxpYXMgZm9yIHtAbGluayBQb3N0UHJvY2Vzc29yI3Bvc3RfcHJvY2Vzc30uXG4gICAgICogQHBhcmFtIHtBcnJheX0gdG9rZW5zIFRoZSB0ZXh0IG9yIGFycmF5IG9mIHRleHRzIHRvIHBvc3QtcHJvY2Vzcy5cbiAgICAgKiBAcGFyYW0gey4uLip9IGFyZ3MgQWRkaXRpb25hbCBhcmd1bWVudHMgcmVxdWlyZWQgYnkgdGhlIHBvc3QtcHJvY2Vzc2luZyBsb2dpYy5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IEFuIGFycmF5IG9mIHBvc3QtcHJvY2Vzc2VkIHRva2Vucy5cbiAgICAgKi9cbiAgICBfY2FsbCh0b2tlbnMsIC4uLmFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucG9zdF9wcm9jZXNzKHRva2VucywgLi4uYXJncyk7XG4gICAgfVxufVxuXG4vKipcbiAqIEEgcG9zdC1wcm9jZXNzb3IgdGhhdCBhZGRzIHNwZWNpYWwgdG9rZW5zIHRvIHRoZSBiZWdpbm5pbmcgYW5kIGVuZCBvZiB0aGUgaW5wdXQuXG4gKiBAZXh0ZW5kcyBQb3N0UHJvY2Vzc29yXG4gKi9cbmNsYXNzIFJvYmVydGFQcm9jZXNzaW5nIGV4dGVuZHMgUG9zdFByb2Nlc3NvciB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBUaGUgY29uZmlndXJhdGlvbiBmb3IgdGhlIHBvc3QtcHJvY2Vzc29yLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IGNvbmZpZy5jbHMgVGhlIHNwZWNpYWwgdG9rZW5zIHRvIGFkZCB0byB0aGUgYmVnaW5uaW5nIG9mIHRoZSBpbnB1dC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBjb25maWcuc2VwIFRoZSBzcGVjaWFsIHRva2VucyB0byBhZGQgdG8gdGhlIGVuZCBvZiB0aGUgaW5wdXQuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZyk7XG4gICAgICAgIC8vIFRPRE8gdXNlIGFsbCBvZiBjb25maWc6IGFkZF9wcmVmaXhfc3BhY2UsIHRyaW1fb2Zmc2V0c1xuXG4gICAgICAgIHRoaXMuY2xzID0gY29uZmlnLmNsc1swXTtcbiAgICAgICAgdGhpcy5zZXAgPSBjb25maWcuc2VwWzBdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZHMgdGhlIHNwZWNpYWwgdG9rZW5zIHRvIHRoZSBiZWdpbm5pbmcgYW5kIGVuZCBvZiB0aGUgaW5wdXQuXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gdG9rZW5zIFRoZSBpbnB1dCB0b2tlbnMuXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXXxudWxsfSB0b2tlbnNfcGFpciBBbiBvcHRpb25hbCBzZWNvbmQgc2V0IG9mIGlucHV0IHRva2Vucy5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nW119IFRoZSBpbnB1dCB0b2tlbnMgd2l0aCB0aGUgc3BlY2lhbCB0b2tlbnMgYWRkZWQgdG8gdGhlIGJlZ2lubmluZyBhbmQgZW5kLlxuICAgICAqL1xuICAgIHBvc3RfcHJvY2Vzcyh0b2tlbnMsIHRva2Vuc19wYWlyID0gbnVsbCkge1xuICAgICAgICB0b2tlbnMgPSBtZXJnZUFycmF5cyhbdGhpcy5jbHNdLCB0b2tlbnMsIFt0aGlzLnNlcF0pO1xuXG4gICAgICAgIC8vIE5PVEU6IEl0IGlzIGludGVuZGVkIHRvIGFkZCAyIEVPUyB0b2tlbnMgYWZ0ZXIgdGhlIGZpcnN0IHNldCBvZiB0b2tlbnNcbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2h1Z2dpbmdmYWNlL3Rva2VuaXplcnMvaXNzdWVzLzk4M1xuICAgICAgICBpZiAodG9rZW5zX3BhaXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRva2VucyA9IG1lcmdlQXJyYXlzKHRva2VucywgW3RoaXMuc2VwXSwgdG9rZW5zX3BhaXIsIFt0aGlzLnNlcF0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b2tlbnM7XG4gICAgfVxufVxuXG4vKipcbiAqIFBvc3QgcHJvY2Vzc29yIHRoYXQgcmVwbGFjZXMgc3BlY2lhbCB0b2tlbnMgaW4gYSB0ZW1wbGF0ZSB3aXRoIGFjdHVhbCB0b2tlbnMuXG4gKiBAZXh0ZW5kcyBQb3N0UHJvY2Vzc29yXG4gKi9cbmNsYXNzIFRlbXBsYXRlUHJvY2Vzc2luZyBleHRlbmRzIFBvc3RQcm9jZXNzb3Ige1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgYFRlbXBsYXRlUHJvY2Vzc2luZ2AuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBUaGUgY29uZmlndXJhdGlvbiBvcHRpb25zIGZvciB0aGUgcG9zdCBwcm9jZXNzb3IuXG4gICAgICogQHBhcmFtIHtBcnJheX0gY29uZmlnLnNpbmdsZSBUaGUgdGVtcGxhdGUgZm9yIGEgc2luZ2xlIHNlcXVlbmNlIG9mIHRva2Vucy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBjb25maWcucGFpciBUaGUgdGVtcGxhdGUgZm9yIGEgcGFpciBvZiBzZXF1ZW5jZXMgb2YgdG9rZW5zLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgICAgICBzdXBlcihjb25maWcpO1xuXG4gICAgICAgIHRoaXMuc2luZ2xlID0gY29uZmlnLnNpbmdsZTtcbiAgICAgICAgdGhpcy5wYWlyID0gY29uZmlnLnBhaXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVwbGFjZXMgc3BlY2lhbCB0b2tlbnMgaW4gdGhlIHRlbXBsYXRlIHdpdGggYWN0dWFsIHRva2Vucy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSB0b2tlbnMgVGhlIGxpc3Qgb2YgdG9rZW5zIGZvciB0aGUgZmlyc3Qgc2VxdWVuY2UuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3Rva2Vuc19wYWlyPW51bGxdIFRoZSBsaXN0IG9mIHRva2VucyBmb3IgdGhlIHNlY29uZCBzZXF1ZW5jZSAob3B0aW9uYWwpLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gVGhlIGxpc3Qgb2YgdG9rZW5zIHdpdGggdGhlIHNwZWNpYWwgdG9rZW5zIHJlcGxhY2VkIHdpdGggYWN0dWFsIHRva2Vucy5cbiAgICAgKi9cbiAgICBwb3N0X3Byb2Nlc3ModG9rZW5zLCB0b2tlbnNfcGFpciA9IG51bGwpIHtcbiAgICAgICAgbGV0IHR5cGUgPSB0b2tlbnNfcGFpciA9PT0gbnVsbCA/IHRoaXMuc2luZ2xlIDogdGhpcy5wYWlyXG5cbiAgICAgICAgbGV0IHRvUmV0dXJuID0gW107XG4gICAgICAgIGZvciAobGV0IGl0ZW0gb2YgdHlwZSkge1xuICAgICAgICAgICAgaWYgKCdTcGVjaWFsVG9rZW4nIGluIGl0ZW0pIHtcbiAgICAgICAgICAgICAgICB0b1JldHVybi5wdXNoKGl0ZW0uU3BlY2lhbFRva2VuLmlkKTtcblxuICAgICAgICAgICAgfSBlbHNlIGlmICgnU2VxdWVuY2UnIGluIGl0ZW0pIHtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbS5TZXF1ZW5jZS5pZCA9PT0gJ0EnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvUmV0dXJuID0gbWVyZ2VBcnJheXModG9SZXR1cm4sIHRva2Vucyk7XG5cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGl0ZW0uU2VxdWVuY2UuaWQgPT09ICdCJykge1xuICAgICAgICAgICAgICAgICAgICB0b1JldHVybiA9IG1lcmdlQXJyYXlzKHRvUmV0dXJuLCB0b2tlbnNfcGFpcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b1JldHVybjtcbiAgICB9XG59XG5cbi8qKlxuICogQSBQb3N0UHJvY2Vzc29yIHRoYXQgcmV0dXJucyB0aGUgZ2l2ZW4gdG9rZW5zIGFzIGlzLlxuICogQGV4dGVuZHMgUG9zdFByb2Nlc3NvclxuICovXG5jbGFzcyBCeXRlTGV2ZWxQb3N0UHJvY2Vzc29yIGV4dGVuZHMgUG9zdFByb2Nlc3NvciB7XG4gICAgLyoqXG4gICAgICogUG9zdCBwcm9jZXNzIHRoZSBnaXZlbiB0b2tlbnMuXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gdG9rZW5zIFRoZSB0b2tlbnMgdG8gYmUgcG9zdCBwcm9jZXNzZWQuXG4gICAgICogQHJldHVybnMge3N0cmluZ1tdfSBUaGUgcG9zdCBwcm9jZXNzZWQgdG9rZW5zLlxuICAgICAqL1xuICAgIHBvc3RfcHJvY2Vzcyh0b2tlbnMpIHtcbiAgICAgICAgcmV0dXJuIHRva2VucztcbiAgICB9XG59XG5cbi8qKlxuICogVGhlIGJhc2UgY2xhc3MgZm9yIHRva2VuIGRlY29kZXJzLlxuICogQGV4dGVuZHMgQ2FsbGFibGVcbiAqL1xuY2xhc3MgRGVjb2RlciBleHRlbmRzIENhbGxhYmxlIHtcblxuICAgIC8qKlxuICAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBgRGVjb2RlcmAuXG4gICAgKlxuICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBUaGUgY29uZmlndXJhdGlvbiBvYmplY3QuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5jb25maWcgPSBjb25maWc7XG5cbiAgICAgICAgdGhpcy5hZGRlZF90b2tlbnMgPSBbXTtcbiAgICAgICAgdGhpcy5lbmRfb2Zfd29yZF9zdWZmaXggPSBudWxsO1xuICAgICAgICB0aGlzLnRyaW1fb2Zmc2V0cyA9IGNvbmZpZy50cmltX29mZnNldHM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAqIENyZWF0ZXMgYSBkZWNvZGVyIGluc3RhbmNlIGJhc2VkIG9uIHRoZSBwcm92aWRlZCBjb25maWd1cmF0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIFRoZSBjb25maWd1cmF0aW9uIG9iamVjdC5cbiAgICogQHJldHVybnMge0RlY29kZXJ9IEEgZGVjb2RlciBpbnN0YW5jZS5cbiAgICogQHRocm93cyB7RXJyb3J9IElmIGFuIHVua25vd24gZGVjb2RlciB0eXBlIGlzIHByb3ZpZGVkLlxuICAgKi9cbiAgICBzdGF0aWMgZnJvbUNvbmZpZyhjb25maWcpIHtcbiAgICAgICAgc3dpdGNoIChjb25maWcudHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnV29yZFBpZWNlJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFdvcmRQaWVjZURlY29kZXIoY29uZmlnKTtcbiAgICAgICAgICAgIGNhc2UgJ01ldGFzcGFjZSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBNZXRhc3BhY2VEZWNvZGVyKGNvbmZpZyk7XG4gICAgICAgICAgICBjYXNlICdCeXRlTGV2ZWwnOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQnl0ZUxldmVsRGVjb2Rlcihjb25maWcpO1xuXG4gICAgICAgICAgICBjYXNlICdSZXBsYWNlJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFJlcGxhY2VEZWNvZGVyKGNvbmZpZyk7XG4gICAgICAgICAgICBjYXNlICdCeXRlRmFsbGJhY2snOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQnl0ZUZhbGxiYWNrKGNvbmZpZyk7XG4gICAgICAgICAgICBjYXNlICdGdXNlJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEZ1c2VEZWNvZGVyKGNvbmZpZyk7XG4gICAgICAgICAgICBjYXNlICdTdHJpcCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTdHJpcERlY29kZXIoY29uZmlnKTtcblxuICAgICAgICAgICAgY2FzZSAnU2VxdWVuY2UnOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRGVjb2RlclNlcXVlbmNlKGNvbmZpZyk7XG5cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIERlY29kZXIgdHlwZTogJHtjb25maWcudHlwZX1gKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICogQ2FsbHMgdGhlIGBkZWNvZGVgIG1ldGhvZC5cbiAgICAqXG4gICAgKiBAcGFyYW0ge3N0cmluZ1tdfSB0b2tlbnMgVGhlIGxpc3Qgb2YgdG9rZW5zLlxuICAgICogQHJldHVybnMge3N0cmluZ30gVGhlIGRlY29kZWQgc3RyaW5nLlxuICAgICovXG4gICAgX2NhbGwodG9rZW5zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlY29kZSh0b2tlbnMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICogRGVjb2RlcyBhIGxpc3Qgb2YgdG9rZW5zLlxuICAgICogQHBhcmFtIHtzdHJpbmdbXX0gdG9rZW5zIFRoZSBsaXN0IG9mIHRva2Vucy5cbiAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBkZWNvZGVkIHN0cmluZy5cbiAgICAqL1xuICAgIGRlY29kZSh0b2tlbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVjb2RlX2NoYWluKHRva2Vucykuam9pbignJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXBwbHkgdGhlIGRlY29kZXIgdG8gYSBsaXN0IG9mIHRva2Vucy5cbiAgICAgKiBcbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSB0b2tlbnMgVGhlIGxpc3Qgb2YgdG9rZW5zLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmdbXX0gVGhlIGRlY29kZWQgbGlzdCBvZiB0b2tlbnMuXG4gICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBgZGVjb2RlX2NoYWluYCBtZXRob2QgaXMgbm90IGltcGxlbWVudGVkIGluIHRoZSBzdWJjbGFzcy5cbiAgICAgKi9cbiAgICBkZWNvZGVfY2hhaW4odG9rZW5zKSB7XG4gICAgICAgIHRocm93IEVycm9yKFwiYGRlY29kZV9jaGFpbmAgc2hvdWxkIGJlIGltcGxlbWVudGVkIGluIHN1YmNsYXNzLlwiKVxuICAgIH1cblxufVxuXG5jbGFzcyBSZXBsYWNlRGVjb2RlciBleHRlbmRzIERlY29kZXIge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgICAgICBzdXBlcihjb25maWcpO1xuICAgIH1cblxuICAgIC8qKiBAdHlwZSB7RGVjb2RlclsnZGVjb2RlX2NoYWluJ119ICovXG4gICAgZGVjb2RlX2NoYWluKHRva2Vucykge1xuICAgICAgICBsZXQgcGF0dGVybiA9IGNyZWF0ZVBhdHRlcm4odGhpcy5jb25maWcucGF0dGVybik7XG4gICAgICAgIGlmIChwYXR0ZXJuID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdG9rZW5zO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRva2Vucy5tYXAodG9rZW4gPT4gdG9rZW4ucmVwbGFjZUFsbChwYXR0ZXJuLCB0aGlzLmNvbmZpZy5jb250ZW50KSlcbiAgICB9XG59XG5cblxuY2xhc3MgQnl0ZUZhbGxiYWNrIGV4dGVuZHMgRGVjb2RlciB7XG4gICAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZyk7XG5cbiAgICAgICAgdGhpcy50ZXh0X2RlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoKTtcbiAgICB9XG5cbiAgICAvKiogQHR5cGUge0RlY29kZXJbJ2RlY29kZV9jaGFpbiddfSAqL1xuICAgIGRlY29kZV9jaGFpbih0b2tlbnMpIHtcblxuICAgICAgICBsZXQgbmV3X3Rva2VucyA9IFtdO1xuICAgICAgICBsZXQgcHJldmlvdXNfYnl0ZV90b2tlbnMgPSBbXTtcblxuICAgICAgICBmb3IgKGxldCB0b2tlbiBvZiB0b2tlbnMpIHtcbiAgICAgICAgICAgIGxldCBieXRlcyA9IG51bGw7XG4gICAgICAgICAgICBpZiAodG9rZW4ubGVuZ3RoID09PSA2ICYmIHRva2VuLnN0YXJ0c1dpdGgoJzwweCcpICYmIHRva2VuLmVuZHNXaXRoKCc+JykpIHtcbiAgICAgICAgICAgICAgICBsZXQgYnl0ZSA9IHBhcnNlSW50KHRva2VuLnNsaWNlKDMsIDUpLCAxNik7XG4gICAgICAgICAgICAgICAgaWYgKCFpc05hTihieXRlKSkge1xuICAgICAgICAgICAgICAgICAgICBieXRlcyA9IGJ5dGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGJ5dGVzICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcHJldmlvdXNfYnl0ZV90b2tlbnMucHVzaChieXRlcyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChwcmV2aW91c19ieXRlX3Rva2Vucy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBzdHJpbmcgPSB0aGlzLnRleHRfZGVjb2Rlci5kZWNvZGUoVWludDhBcnJheS5mcm9tKHByZXZpb3VzX2J5dGVfdG9rZW5zKSk7XG4gICAgICAgICAgICAgICAgICAgIG5ld190b2tlbnMucHVzaChzdHJpbmcpO1xuICAgICAgICAgICAgICAgICAgICBwcmV2aW91c19ieXRlX3Rva2VucyA9IFtdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBuZXdfdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChwcmV2aW91c19ieXRlX3Rva2Vucy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBsZXQgc3RyaW5nID0gdGhpcy50ZXh0X2RlY29kZXIuZGVjb2RlKFVpbnQ4QXJyYXkuZnJvbShwcmV2aW91c19ieXRlX3Rva2VucykpO1xuICAgICAgICAgICAgbmV3X3Rva2Vucy5wdXNoKHN0cmluZyk7XG4gICAgICAgICAgICBwcmV2aW91c19ieXRlX3Rva2VucyA9IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5ld190b2tlbnM7XG4gICAgfVxufVxuXG4vKipcbiAqIEZ1c2Ugc2ltcGx5IGZ1c2VzIGFsbCB0b2tlbnMgaW50byBvbmUgYmlnIHN0cmluZy5cbiAqIEl0J3MgdXN1YWxseSB0aGUgbGFzdCBkZWNvZGluZyBzdGVwIGFueXdheSwgYnV0IHRoaXMgZGVjb2RlclxuICogZXhpc3RzIGluY2FzZSBzb21lIGRlY29kZXJzIG5lZWQgdG8gaGFwcGVuIGFmdGVyIHRoYXQgc3RlcFxuICovXG5jbGFzcyBGdXNlRGVjb2RlciBleHRlbmRzIERlY29kZXIge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgICAgICBzdXBlcihjb25maWcpO1xuICAgIH1cblxuICAgIC8qKiBAdHlwZSB7RGVjb2RlclsnZGVjb2RlX2NoYWluJ119ICovXG4gICAgZGVjb2RlX2NoYWluKHRva2Vucykge1xuICAgICAgICByZXR1cm4gW3Rva2Vucy5qb2luKCcnKV07XG4gICAgfVxufVxuXG5jbGFzcyBTdHJpcERlY29kZXIgZXh0ZW5kcyBEZWNvZGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICAgICAgc3VwZXIoY29uZmlnKTtcblxuICAgICAgICB0aGlzLmNvbnRlbnQgPSB0aGlzLmNvbmZpZy5jb250ZW50O1xuICAgICAgICB0aGlzLnN0YXJ0ID0gdGhpcy5jb25maWcuc3RhcnQ7XG4gICAgICAgIHRoaXMuc3RvcCA9IHRoaXMuY29uZmlnLnN0b3A7XG4gICAgfVxuXG4gICAgLyoqIEB0eXBlIHtEZWNvZGVyWydkZWNvZGVfY2hhaW4nXX0gKi9cbiAgICBkZWNvZGVfY2hhaW4odG9rZW5zKSB7XG4gICAgICAgIHJldHVybiB0b2tlbnMubWFwKHRva2VuID0+IHtcbiAgICAgICAgICAgIGxldCBzdGFydF9jdXQgPSAwO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnN0YXJ0OyArK2kpIHtcbiAgICAgICAgICAgICAgICBpZiAodG9rZW5baV0gPT09IHRoaXMuY29udGVudCkge1xuICAgICAgICAgICAgICAgICAgICBzdGFydF9jdXQgPSBpICsgMTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQgc3RvcF9jdXQgPSB0b2tlbi5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc3RvcDsgKytpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5kZXggPSB0b2tlbi5sZW5ndGggLSBpIC0gMTtcbiAgICAgICAgICAgICAgICBpZiAodG9rZW5baW5kZXhdID09PSB0aGlzLmNvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RvcF9jdXQgPSBpbmRleDtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdG9rZW4uc2xpY2Uoc3RhcnRfY3V0LCBzdG9wX2N1dClcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG4vKipcbiAqIEEgZGVjb2RlciB0aGF0IGRlY29kZXMgYSBsaXN0IG9mIFdvcmRQaWVjZSB0b2tlbnMgaW50byBhIHNpbmdsZSBzdHJpbmcuXG4gKiBAZXh0ZW5kcyBEZWNvZGVyXG4gKi9cbmNsYXNzIFdvcmRQaWVjZURlY29kZXIgZXh0ZW5kcyBEZWNvZGVyIHtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgV29yZFBpZWNlRGVjb2Rlci5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIFRoZSBjb25maWd1cmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29uZmlnLnByZWZpeCBUaGUgcHJlZml4IHVzZWQgZm9yIFdvcmRQaWVjZSBlbmNvZGluZy5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGNvbmZpZy5jbGVhbnVwIFdoZXRoZXIgdG8gY2xlYW51cCB0aGUgZGVjb2RlZCBzdHJpbmcuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZyk7XG4gICAgICAgIHRoaXMuY2xlYW51cCA9IGNvbmZpZy5jbGVhbnVwO1xuICAgIH1cblxuICAgIC8qKiBAdHlwZSB7RGVjb2RlclsnZGVjb2RlX2NoYWluJ119ICovXG4gICAgZGVjb2RlX2NoYWluKHRva2Vucykge1xuICAgICAgICByZXR1cm4gdG9rZW5zLm1hcCgodG9rZW4sIGkpID0+IHtcbiAgICAgICAgICAgIGlmIChpICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRva2VuLnN0YXJ0c1dpdGgodGhpcy5jb25maWcucHJlZml4KSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBOT1RFOiAucmVwbGFjZSgpIGlzIGludGVuZGVkOyBvbmx5IHJlcGxhY2UgZmlyc3Qgb2NjdXJyZW5jZVxuICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IHRva2VuLnJlcGxhY2UodGhpcy5jb25maWcucHJlZml4LCAnJyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSAnICcgKyB0b2tlbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jbGVhbnVwKSB7XG4gICAgICAgICAgICAgICAgdG9rZW4gPSBjbGVhbl91cF90b2tlbml6YXRpb24odG9rZW4pXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG4vKipcbiAqIEJ5dGUtbGV2ZWwgZGVjb2RlciBmb3IgdG9rZW5pemF0aW9uIG91dHB1dC4gSW5oZXJpdHMgZnJvbSB0aGUgYERlY29kZXJgIGNsYXNzLlxuICogQGV4dGVuZHMgRGVjb2RlclxuICovXG5jbGFzcyBCeXRlTGV2ZWxEZWNvZGVyIGV4dGVuZHMgRGVjb2RlciB7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBgQnl0ZUxldmVsRGVjb2RlcmAgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgQ29uZmlndXJhdGlvbiBvYmplY3QuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZyk7XG5cbiAgICAgICAgdGhpcy5ieXRlX2RlY29kZXIgPSBVTklDT0RFX1RPX0JZVEVTO1xuICAgICAgICB0aGlzLnRleHRfZGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcihcInV0Zi04XCIsIHtcbiAgICAgICAgICAgIGZhdGFsOiBmYWxzZSxcbiAgICAgICAgICAgIGlnbm9yZUJPTTogdHJ1ZSxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5lbmRfb2Zfd29yZF9zdWZmaXggPSBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnQgYW4gYXJyYXkgb2YgdG9rZW5zIHRvIHN0cmluZyBieSBkZWNvZGluZyBlYWNoIGJ5dGUuXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gdG9rZW5zIEFycmF5IG9mIHRva2VucyB0byBiZSBkZWNvZGVkLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBkZWNvZGVkIHN0cmluZy5cbiAgICAgKi9cbiAgICBjb252ZXJ0X3Rva2Vuc190b19zdHJpbmcodG9rZW5zKSB7XG4gICAgICAgIGxldCB0ZXh0ID0gdG9rZW5zLmpvaW4oJycpO1xuXG4gICAgICAgIGxldCBieXRlQXJyYXkgPSBuZXcgVWludDhBcnJheShbLi4udGV4dF0ubWFwKGMgPT4gdGhpcy5ieXRlX2RlY29kZXJbY10pKTtcbiAgICAgICAgbGV0IGRlY29kZWRfdGV4dCA9IHRoaXMudGV4dF9kZWNvZGVyLmRlY29kZShieXRlQXJyYXkpO1xuICAgICAgICByZXR1cm4gZGVjb2RlZF90ZXh0O1xuICAgIH1cblxuICAgIC8qKiBAdHlwZSB7RGVjb2RlclsnZGVjb2RlX2NoYWluJ119ICovXG4gICAgZGVjb2RlX2NoYWluKHRva2Vucykge1xuICAgICAgICAvLyBUT0RPIG1vdmUgdG8gYmFzZSBjbGFzcyAobGlrZSBIRilcbiAgICAgICAgLy8gdG9rZW5zID09PSBmaWx0ZXJlZF90b2tlbnNcblxuICAgICAgICAvLyBUbyBhdm9pZCBtaXhpbmcgYnl0ZS1sZXZlbCBhbmQgdW5pY29kZSBmb3IgYnl0ZS1sZXZlbCBCUFRcbiAgICAgICAgLy8gd2UgbmVlZCB0byBidWlsZCBzdHJpbmcgc2VwYXJhdGVseSBmb3IgYWRkZWQgdG9rZW5zIGFuZCBieXRlLWxldmVsIHRva2Vuc1xuICAgICAgICAvLyBjZi4gaHR0cHM6Ly9naXRodWIuY29tL2h1Z2dpbmdmYWNlL3RyYW5zZm9ybWVycy9pc3N1ZXMvMTEzM1xuICAgICAgICBsZXQgc3ViX3RleHRzID0gW107XG4gICAgICAgIGxldCBjdXJyZW50X3N1Yl90ZXh0ID0gW107XG4gICAgICAgIGZvciAobGV0IHRva2VuIG9mIHRva2Vucykge1xuICAgICAgICAgICAgLy8gdG9rZW5zIHNlbnQgaGVyZSBhcmUgYWxyZWFkeSBmaWx0ZXJlZCwgc28gd2UgZG9uJ3QgbmVlZCB0byBkbyB0aGlzXG4gICAgICAgICAgICAvLyBpZiAoc2tpcF9zcGVjaWFsX3Rva2VucyAmJiB0aGlzLmFsbF9zcGVjaWFsX2lkcy5pbmNsdWRlcyh0b2tlbikpIHtcbiAgICAgICAgICAgIC8vICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIC8vIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMuYWRkZWRfdG9rZW5zLmluY2x1ZGVzKHRva2VuKSkge1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50X3N1Yl90ZXh0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgc3ViX3RleHRzLnB1c2godGhpcy5jb252ZXJ0X3Rva2Vuc190b19zdHJpbmcoY3VycmVudF9zdWJfdGV4dCkpO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50X3N1Yl90ZXh0ID0gW107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN1Yl90ZXh0cy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY3VycmVudF9zdWJfdGV4dC5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY3VycmVudF9zdWJfdGV4dC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBzdWJfdGV4dHMucHVzaCh0aGlzLmNvbnZlcnRfdG9rZW5zX3RvX3N0cmluZyhjdXJyZW50X3N1Yl90ZXh0KSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUT0RPIGFkZCBzcGFjZXNfYmV0d2Vlbl9zcGVjaWFsX3Rva2VucyBhbmQgY2xlYW5fdXBfdG9rZW5pemF0aW9uX3NwYWNlcyBvcHRpb25zXG5cbiAgICAgICAgcmV0dXJuIHN1Yl90ZXh0cztcbiAgICB9XG59XG5cblxuLyoqXG4gKiBBcHBseSBhIHNlcXVlbmNlIG9mIGRlY29kZXJzLlxuICogQGV4dGVuZHMgRGVjb2RlclxuICovXG5jbGFzcyBEZWNvZGVyU2VxdWVuY2UgZXh0ZW5kcyBEZWNvZGVyIHtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgRGVjb2RlclNlcXVlbmNlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgVGhlIGNvbmZpZ3VyYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7RGVjb2RlcltdfSBjb25maWcuZGVjb2RlcnMgVGhlIGxpc3Qgb2YgZGVjb2RlcnMgdG8gYXBwbHkuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZyk7XG4gICAgICAgIHRoaXMuZGVjb2RlcnMgPSBjb25maWcuZGVjb2RlcnMubWFwKHggPT4gRGVjb2Rlci5mcm9tQ29uZmlnKHgpKTtcbiAgICB9XG5cbiAgICAvKiogQHR5cGUge0RlY29kZXJbJ2RlY29kZV9jaGFpbiddfSAqL1xuICAgIGRlY29kZV9jaGFpbih0b2tlbnMpIHtcbiAgICAgICAgLy8gVXNlIHJlZHVjZSB0byBhcHBseSBlYWNoIGRlY29kZXIgdG8gdGhlIHRva2Vuc1xuICAgICAgICByZXR1cm4gdGhpcy5kZWNvZGVycy5yZWR1Y2UoKHRva3MsIGRlY29kZXIpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBkZWNvZGVyLmRlY29kZV9jaGFpbih0b2tzKTtcbiAgICAgICAgfSwgdG9rZW5zKTtcbiAgICB9XG5cbn1cblxuLyoqXG4gKiBUaGlzIFByZVRva2VuaXplciByZXBsYWNlcyBzcGFjZXMgd2l0aCB0aGUgZ2l2ZW4gcmVwbGFjZW1lbnQgY2hhcmFjdGVyLCBhZGRzIGEgcHJlZml4IHNwYWNlIGlmIHJlcXVlc3RlZCxcbiAqIGFuZCByZXR1cm5zIGEgbGlzdCBvZiB0b2tlbnMuXG4gKiBAZXh0ZW5kcyBQcmVUb2tlbml6ZXJcbiAqL1xuY2xhc3MgTWV0YXNwYWNlUHJlVG9rZW5pemVyIGV4dGVuZHMgUHJlVG9rZW5pemVyIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIFRoZSBjb25maWd1cmF0aW9uIG9iamVjdCBmb3IgdGhlIE1ldGFzcGFjZVByZVRva2VuaXplci5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGNvbmZpZy5hZGRfcHJlZml4X3NwYWNlIFdoZXRoZXIgdG8gYWRkIGEgcHJlZml4IHNwYWNlIHRvIHRoZSBmaXJzdCB0b2tlbi5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29uZmlnLnJlcGxhY2VtZW50IFRoZSBjaGFyYWN0ZXIgdG8gcmVwbGFjZSBzcGFjZXMgd2l0aC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2NvbmZpZy5zdHJfcmVwPWNvbmZpZy5yZXBsYWNlbWVudF0gQW4gb3B0aW9uYWwgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSByZXBsYWNlbWVudCBjaGFyYWN0ZXIuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgICAgIHN1cGVyKCk7XG5cbiAgICAgICAgdGhpcy5hZGRQcmVmaXhTcGFjZSA9IGNvbmZpZy5hZGRfcHJlZml4X3NwYWNlO1xuICAgICAgICB0aGlzLnJlcGxhY2VtZW50ID0gY29uZmlnLnJlcGxhY2VtZW50O1xuICAgICAgICB0aGlzLnN0clJlcCA9IGNvbmZpZy5zdHJfcmVwIHx8IHRoaXMucmVwbGFjZW1lbnQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgdGFrZXMgYSBsaXN0IG9mIG5vcm1hbGl6ZWQgdG9rZW5zLCByZXBsYWNlcyBzcGFjZXMgd2l0aCB0aGUgcmVwbGFjZW1lbnQgY2hhcmFjdGVyLFxuICAgICAqIGFkZHMgYSBwcmVmaXggc3BhY2UgaWYgcmVxdWVzdGVkLCBhbmQgcmV0dXJucyBhIG5ldyBsaXN0IG9mIHRva2Vucy5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfHN0cmluZ30gbm9ybWFsaXplZFRva2VucyBUaGUgbGlzdCBvZiBub3JtYWxpemVkIHRva2VucyB0byBwcmUtdG9rZW5pemUuXG4gICAgICogQHJldHVybnMge3N0cmluZ1tdfSBBIG5ldyBsaXN0IG9mIHByZS10b2tlbml6ZWQgdG9rZW5zLlxuICAgICAqL1xuICAgIHByZV90b2tlbml6ZShub3JtYWxpemVkVG9rZW5zKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygbm9ybWFsaXplZFRva2VucyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIC8vIE1ldGFzcGFjZSBhY3RzIG9uIGEgbGlzdCBvZiB0b2tlbnMuIElmIHBhc3NpbmcgaW4gYSBzdHJpbmcsIGZpcnN0IHNwbGl0IG9uIHdoaXRlc3BhY2VcbiAgICAgICAgICAgIC8vIE5PVEU6IEZvciBzb21lIHJlYXNvbiwgbWV0YXNwYWNlIGluY2x1ZGVzIHRyYWlsaW5nIHdoaXRlc3BhY2UsIHNvIHdlIG9ubHkgdHJpbSBsZWFkaW5nIHdoaXRlc3BhY2UuXG4gICAgICAgICAgICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9odWdnaW5nZmFjZS90b2tlbml6ZXJzL2lzc3Vlcy8xMjUwXG4gICAgICAgICAgICBub3JtYWxpemVkVG9rZW5zID0gbm9ybWFsaXplZFRva2Vucy50cmltU3RhcnQoKS5zcGxpdCgvXFxzKy8pO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAobGV0IHRva2VuIG9mIG5vcm1hbGl6ZWRUb2tlbnMpIHtcbiAgICAgICAgICAgIGxldCBub3JtYWxpemVkID0gdG9rZW4ucmVwbGFjZUFsbCgnICcsIHRoaXMuc3RyUmVwKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmFkZFByZWZpeFNwYWNlICYmICFub3JtYWxpemVkLnN0YXJ0c1dpdGgodGhpcy5yZXBsYWNlbWVudCkpIHtcbiAgICAgICAgICAgICAgICBub3JtYWxpemVkID0gdGhpcy5zdHJSZXAgKyBub3JtYWxpemVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0LnB1c2gobm9ybWFsaXplZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG5cbi8qKlxuICogTWV0YXNwYWNlRGVjb2RlciBjbGFzcyBleHRlbmRzIHRoZSBEZWNvZGVyIGNsYXNzIGFuZCBkZWNvZGVzIE1ldGFzcGFjZSB0b2tlbml6YXRpb24uXG4gKiBAZXh0ZW5kcyBEZWNvZGVyXG4gKi9cbmNsYXNzIE1ldGFzcGFjZURlY29kZXIgZXh0ZW5kcyBEZWNvZGVyIHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RzIGEgbmV3IE1ldGFzcGFjZURlY29kZXIgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgVGhlIGNvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciB0aGUgTWV0YXNwYWNlRGVjb2Rlci5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGNvbmZpZy5hZGRfcHJlZml4X3NwYWNlIFdoZXRoZXIgdG8gYWRkIGEgcHJlZml4IHNwYWNlIHRvIHRoZSBkZWNvZGVkIHN0cmluZy5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29uZmlnLnJlcGxhY2VtZW50IFRoZSBzdHJpbmcgdG8gcmVwbGFjZSBzcGFjZXMgd2l0aC5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICAgICAgc3VwZXIoY29uZmlnKTtcblxuICAgICAgICB0aGlzLmFkZFByZWZpeFNwYWNlID0gY29uZmlnLmFkZF9wcmVmaXhfc3BhY2U7XG4gICAgICAgIHRoaXMucmVwbGFjZW1lbnQgPSBjb25maWcucmVwbGFjZW1lbnQ7XG4gICAgfVxuXG4gICAgLyoqIEB0eXBlIHtEZWNvZGVyWydkZWNvZGVfY2hhaW4nXX0gKi9cbiAgICBkZWNvZGVfY2hhaW4odG9rZW5zKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGxldCBub3JtYWxpemVkID0gdG9rZW5zW2ldLnJlcGxhY2VBbGwodGhpcy5yZXBsYWNlbWVudCwgJyAnKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmFkZFByZWZpeFNwYWNlICYmIGkgPT0gMCAmJiBub3JtYWxpemVkLnN0YXJ0c1dpdGgoJyAnKSkge1xuICAgICAgICAgICAgICAgIG5vcm1hbGl6ZWQgPSBub3JtYWxpemVkLnN1YnN0cmluZygxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5vcm1hbGl6ZWQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuXG4vKipcbiAqIEEgbm9ybWFsaXplciB0aGF0IGFwcGxpZXMgYSBwcmVjb21waWxlZCBjaGFyc21hcC5cbiAqIFRoaXMgaXMgdXNlZnVsIGZvciBhcHBseWluZyBjb21wbGV4IG5vcm1hbGl6YXRpb25zIGluIEMrKyBhbmQgZXhwb3NpbmcgdGhlbSB0byBKYXZhU2NyaXB0LlxuICogQGV4dGVuZHMgTm9ybWFsaXplclxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBUaGUgY29uZmlndXJhdGlvbiBvYmplY3QgZm9yIHRoZSBQcmVjb21waWxlZCBub3JtYWxpemVyLlxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZy5wcmVjb21waWxlZF9jaGFyc21hcCBUaGUgcHJlY29tcGlsZWQgY2hhcnNtYXAgb2JqZWN0LlxuICovXG5jbGFzcyBQcmVjb21waWxlZCBleHRlbmRzIE5vcm1hbGl6ZXIge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBpbnN0YW5jZSBvZiBQcmVjb21waWxlZCBub3JtYWxpemVyLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgVGhlIGNvbmZpZ3VyYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7YW55fSBjb25maWcucHJlY29tcGlsZWRfY2hhcnNtYXAgUHJlY29tcGlsZWQgY2hhcnMgbWFwcGluZy5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICAgICAgc3VwZXIoY29uZmlnKTtcbiAgICAgICAgdGhpcy5jaGFyc21hcCA9IGNvbmZpZy5wcmVjb21waWxlZF9jaGFyc21hcDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBOb3JtYWxpemVzIHRoZSBnaXZlbiB0ZXh0IGJ5IGFwcGx5aW5nIHRoZSBwcmVjb21waWxlZCBjaGFyc21hcC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCBUaGUgdGV4dCB0byBub3JtYWxpemUuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gVGhlIG5vcm1hbGl6ZWQgdGV4dC5cbiAgICAgKi9cbiAgICBub3JtYWxpemUodGV4dCkge1xuICAgICAgICAvLyBUT0RPIHVzZSB0aGlzLmNoYXJzbWFwXG4gICAgICAgIC8vIEZvciBub3csIHdlIGp1c3QgYXBwbHkgTkZLQyBub3JtYWxpemF0aW9uXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9odWdnaW5nZmFjZS90b2tlbml6ZXJzL2Jsb2IvMjkxYjJlMjNhZTgxY2Y5NDczODgzNTg1MjIxM2NlMTIwMTUyZDEyMS9iaW5kaW5ncy9weXRob24vcHlfc3JjL3Rva2VuaXplcnMvaW1wbGVtZW50YXRpb25zL3NlbnRlbmNlcGllY2VfYnBlLnB5I0wzNFxuICAgICAgICB0ZXh0ID0gdGV4dC5ub3JtYWxpemUoJ05GS0MnKTtcbiAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfVxufVxuXG4vKipcbiAqIEEgcHJlLXRva2VuaXplciB0aGF0IGFwcGxpZXMgYSBzZXF1ZW5jZSBvZiBwcmUtdG9rZW5pemVycyB0byB0aGUgaW5wdXQgdGV4dC5cbiAqIEBleHRlbmRzIFByZVRva2VuaXplclxuICovXG5jbGFzcyBQcmVUb2tlbml6ZXJTZXF1ZW5jZSBleHRlbmRzIFByZVRva2VuaXplciB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBQcmVUb2tlbml6ZXJTZXF1ZW5jZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIFRoZSBjb25maWd1cmF0aW9uIG9iamVjdCBmb3IgdGhlIHByZS10b2tlbml6ZXIgc2VxdWVuY2UuXG4gICAgICogQHBhcmFtIHtPYmplY3RbXX0gY29uZmlnLnByZXRva2VuaXplcnMgQW4gYXJyYXkgb2YgcHJlLXRva2VuaXplciBjb25maWd1cmF0aW9ucy5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy50b2tlbml6ZXJzID0gY29uZmlnLnByZXRva2VuaXplcnMubWFwKHggPT4gUHJlVG9rZW5pemVyLmZyb21Db25maWcoeCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFwcGxpZXMgZWFjaCBwcmUtdG9rZW5pemVyIGluIHRoZSBzZXF1ZW5jZSB0byB0aGUgaW5wdXQgdGV4dCBpbiB0dXJuLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfHN0cmluZ1tdfSB0ZXh0IFRoZSB0ZXh0KHMpIHRvIHByZS10b2tlbml6ZS5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nW119IFRoZSBwcmUtdG9rZW5pemVkIHRleHQuXG4gICAgICovXG4gICAgcHJlX3Rva2VuaXplX3RleHQodGV4dCkge1xuICAgICAgICBpZiAodHlwZW9mIHRleHQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0ZXh0ID0gW3RleHRdO1xuICAgICAgICB9XG4gICAgICAgIC8vIFVzZSByZWR1Y2UgdG8gYXBwbHkgZWFjaCB0b2tlbml6ZXIgdG8gdGhlIHRleHRcbiAgICAgICAgcmV0dXJuIHRoaXMudG9rZW5pemVycy5yZWR1Y2UoKHByZVRva2VuaXplZFRleHQsIHRva2VuaXplcikgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRva2VuaXplci5wcmVfdG9rZW5pemUocHJlVG9rZW5pemVkVGV4dCk7XG4gICAgICAgIH0sIHRleHQpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBTcGxpdHMgYSBzdHJpbmcgb2YgdGV4dCBieSB3aGl0ZXNwYWNlIGNoYXJhY3RlcnMgaW50byBpbmRpdmlkdWFsIHRva2Vucy5cbiAqIEBleHRlbmRzIFByZVRva2VuaXplclxuICovXG5jbGFzcyBXaGl0ZXNwYWNlU3BsaXQgZXh0ZW5kcyBQcmVUb2tlbml6ZXIge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgV2hpdGVzcGFjZVNwbGl0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgVGhlIGNvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciB0aGUgcHJlLXRva2VuaXplciBzZXF1ZW5jZS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJlLXRva2VuaXplcyB0aGUgaW5wdXQgdGV4dCBieSBzcGxpdHRpbmcgaXQgb24gd2hpdGVzcGFjZSBjaGFyYWN0ZXJzLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IFRoZSB0ZXh0IHRvIGJlIHByZS10b2tlbml6ZWQuXG4gICAgICogQHJldHVybnMge3N0cmluZ1tdfSBBbiBhcnJheSBvZiB0b2tlbnMgcHJvZHVjZWQgYnkgc3BsaXR0aW5nIHRoZSBpbnB1dCB0ZXh0IG9uIHdoaXRlc3BhY2UuXG4gICAgICovXG4gICAgcHJlX3Rva2VuaXplX3RleHQodGV4dCkge1xuICAgICAgICByZXR1cm4gd2hpdGVzcGFjZV9zcGxpdCh0ZXh0KTtcbiAgICB9XG59XG5cbmV4cG9ydCBjbGFzcyBQcmVUcmFpbmVkVG9rZW5pemVyIGV4dGVuZHMgQ2FsbGFibGUge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBQcmVUcmFpbmVkVG9rZW5pemVyIGluc3RhbmNlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0b2tlbml6ZXJKU09OIFRoZSBKU09OIG9mIHRoZSB0b2tlbml6ZXIuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHRva2VuaXplckNvbmZpZyBUaGUgY29uZmlnIG9mIHRoZSB0b2tlbml6ZXIuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IodG9rZW5pemVySlNPTiwgdG9rZW5pemVyQ29uZmlnKSB7XG4gICAgICAgIHN1cGVyKCk7XG5cbiAgICAgICAgLy8gQ29uc3RydWN0IHBhcnRzIG9mIHRoZSB0b2tlbml6ZXIgZnJvbSB0aGUgSlNPTlxuICAgICAgICB0aGlzLm5vcm1hbGl6ZXIgPSBOb3JtYWxpemVyLmZyb21Db25maWcodG9rZW5pemVySlNPTi5ub3JtYWxpemVyKTtcbiAgICAgICAgdGhpcy5wcmVfdG9rZW5pemVyID0gUHJlVG9rZW5pemVyLmZyb21Db25maWcodG9rZW5pemVySlNPTi5wcmVfdG9rZW5pemVyKTtcblxuICAgICAgICAvLyBDb252ZXJ0IHRoZSB2b2NhYnVsYXJ5IHRvIGEgbWFwLCBpZiBpdCBleGlzdHNcbiAgICAgICAgaWYgKHRva2VuaXplckpTT04ubW9kZWwudm9jYWIpIHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh0b2tlbml6ZXJKU09OLm1vZGVsLnZvY2FiKSkge1xuICAgICAgICAgICAgICAgIHRva2VuaXplckpTT04ubW9kZWwudm9jYWIgPSBPYmplY3QuZW50cmllcyh0b2tlbml6ZXJKU09OLm1vZGVsLnZvY2FiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRva2VuaXplckpTT04ubW9kZWwudm9jYWIgPSBuZXcgTWFwKHRva2VuaXplckpTT04ubW9kZWwudm9jYWIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubW9kZWwgPSBUb2tlbml6ZXJNb2RlbC5mcm9tQ29uZmlnKHRva2VuaXplckpTT04ubW9kZWwsIHRva2VuaXplckNvbmZpZyk7XG4gICAgICAgIHRoaXMucG9zdF9wcm9jZXNzb3IgPSBQb3N0UHJvY2Vzc29yLmZyb21Db25maWcodG9rZW5pemVySlNPTi5wb3N0X3Byb2Nlc3Nvcik7XG5cbiAgICAgICAgLy8gVE9ETzogbWF5YmUsIGFsbG93IHRoaXMgdG8gYmUgbnVsbDsgaW4gd2hpY2ggY2FzZSwgd2UgdXNlIG1vZGVsIGFzIGRlY29kZXIgdG9vP1xuICAgICAgICB0aGlzLmRlY29kZXIgPSBEZWNvZGVyLmZyb21Db25maWcodG9rZW5pemVySlNPTi5kZWNvZGVyKTtcblxuXG4gICAgICAgIC8vIEFub3RoZXIgc2xpZ2h0IGhhY2sgdG8gYWRkIGBlbmRfb2Zfd29yZF9zdWZmaXhgIChpZiBwcmVzZW50KSB0byB0aGUgZGVjb2RlclxuICAgICAgICAvLyBUaGlzIGlzIG5lZWRlZCBmb3IgY2FzZXMgd2hlcmUgQlBFIG1vZGVsIGFuZCBCeXRlTGV2ZWwgZGVjb2RlciBhcmUgdXNlZFxuICAgICAgICAvLyBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS94ZW5vdmEvdHJhbnNmb3JtZXJzLmpzL2lzc3Vlcy83NFxuICAgICAgICAvLyBUT0RPOiBzYXZlIHRoaXMgdG8gdGhlIGRlY29kZXIgd2hlbiBleHBvcnRpbmc/XG4gICAgICAgIHRoaXMuZGVjb2Rlci5lbmRfb2Zfd29yZF9zdWZmaXggPSB0aGlzLm1vZGVsLmVuZF9vZl93b3JkX3N1ZmZpeDtcblxuICAgICAgICAvLyBBZGQgYWRkZWRfdG9rZW5zIHRvIG1vZGVsXG4gICAgICAgIHRoaXMuc3BlY2lhbF90b2tlbnMgPSBbXTtcbiAgICAgICAgdGhpcy5hbGxfc3BlY2lhbF9pZHMgPSBbXTtcbiAgICAgICAgdGhpcy5hZGRlZF90b2tlbnMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgYWRkZWRUb2tlbiBvZiB0b2tlbml6ZXJKU09OLmFkZGVkX3Rva2Vucykge1xuICAgICAgICAgICAgbGV0IGlkID0gYWRkZWRUb2tlbi5pZDtcbiAgICAgICAgICAgIGxldCBjb250ZW50ID0gYWRkZWRUb2tlbi5jb250ZW50O1xuXG4gICAgICAgICAgICB0aGlzLmFkZGVkX3Rva2Vucy5wdXNoKGNvbnRlbnQpO1xuXG4gICAgICAgICAgICB0aGlzLm1vZGVsLnRva2Vuc190b19pZHMuc2V0KGNvbnRlbnQsIGlkKTtcbiAgICAgICAgICAgIHRoaXMubW9kZWwudm9jYWJbaWRdID0gY29udGVudDtcblxuICAgICAgICAgICAgaWYgKGFkZGVkVG9rZW4uc3BlY2lhbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3BlY2lhbF90b2tlbnMucHVzaChjb250ZW50KTtcbiAgICAgICAgICAgICAgICB0aGlzLmFsbF9zcGVjaWFsX2lkcy5wdXNoKGlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNsaWdodCBoYWNrLCBidXQgaXQgcHJldmVudHMgY29kZSBkdXBsaWNhdGlvbjpcbiAgICAgICAgdGhpcy5kZWNvZGVyLmFkZGVkX3Rva2VucyA9IHRoaXMuYWRkZWRfdG9rZW5zO1xuXG4gICAgICAgIHRoaXMuYWRkZWRfdG9rZW5zX3JlZ2V4ID0gbmV3IFJlZ0V4cChcbiAgICAgICAgICAgICcoJyArIHRoaXMuYWRkZWRfdG9rZW5zLm1hcChlc2NhcGVSZWdFeHApLmpvaW4oJ3wnKSArICcpJ1xuICAgICAgICApO1xuXG4gICAgICAgIC8vIFNldCBtYXNrIHRva2VuIGlmIHByZXNlbnQgKG90aGVyd2lzZSB3aWxsIGJlIHVuZGVmaW5lZCwgd2hpY2ggaXMgZmluZSlcbiAgICAgICAgdGhpcy5tYXNrX3Rva2VuID0gdGhpcy5nZXRUb2tlbih0b2tlbml6ZXJDb25maWcsICdtYXNrX3Rva2VuJyk7XG4gICAgICAgIHRoaXMubWFza190b2tlbl9pZCA9IHRoaXMubW9kZWwudG9rZW5zX3RvX2lkcy5nZXQodGhpcy5tYXNrX3Rva2VuKTtcblxuICAgICAgICB0aGlzLnBhZF90b2tlbiA9IHRoaXMuZ2V0VG9rZW4odG9rZW5pemVyQ29uZmlnLCAncGFkX3Rva2VuJywgJ2Vvc190b2tlbicpO1xuICAgICAgICB0aGlzLnBhZF90b2tlbl9pZCA9IHRoaXMubW9kZWwudG9rZW5zX3RvX2lkcy5nZXQodGhpcy5wYWRfdG9rZW4pO1xuXG4gICAgICAgIHRoaXMuc2VwX3Rva2VuID0gdGhpcy5nZXRUb2tlbih0b2tlbml6ZXJDb25maWcsICdzZXBfdG9rZW4nKTtcbiAgICAgICAgdGhpcy5zZXBfdG9rZW5faWQgPSB0aGlzLm1vZGVsLnRva2Vuc190b19pZHMuZ2V0KHRoaXMuc2VwX3Rva2VuKTtcblxuICAgICAgICB0aGlzLm1vZGVsX21heF9sZW5ndGggPSB0b2tlbml6ZXJDb25maWcubW9kZWxfbWF4X2xlbmd0aDtcblxuICAgICAgICAvKiogQHR5cGUge2Jvb2xlYW59IFdoZXRoZXIgb3Igbm90IHRvIHN0cmlwIHRoZSB0ZXh0IHdoZW4gdG9rZW5pemluZyAocmVtb3ZpbmcgZXhjZXNzIHNwYWNlcyBiZWZvcmUgYW5kIGFmdGVyIHRoZSBzdHJpbmcpLiAqL1xuICAgICAgICB0aGlzLnJlbW92ZV9zcGFjZSA9IHRva2VuaXplckNvbmZpZy5yZW1vdmVfc3BhY2U7XG5cbiAgICAgICAgdGhpcy5jbGVhbl91cF90b2tlbml6YXRpb25fc3BhY2VzID0gdG9rZW5pemVyQ29uZmlnLmNsZWFuX3VwX3Rva2VuaXphdGlvbl9zcGFjZXMgPz8gdHJ1ZTtcblxuICAgICAgICAvLyBUT0RPIGFsbG93IHVzZXIgdG8gY2hhbmdlIHRoaXNcbiAgICAgICAgdGhpcy5wYWRkaW5nX3NpZGUgPSAncmlnaHQnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHZhbHVlIG9mIHRoZSBmaXJzdCBtYXRjaGluZyBrZXkgaW4gdGhlIHRva2VuaXplciBjb25maWcgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Li4uc3RyaW5nfSBrZXlzIE9uZSBvciBtb3JlIGtleXMgdG8gc2VhcmNoIGZvciBpbiB0aGUgdG9rZW5pemVyIGNvbmZpZyBvYmplY3QuXG4gICAgICogQHJldHVybnMge3N0cmluZ3xudWxsfSBUaGUgdmFsdWUgYXNzb2NpYXRlZCB3aXRoIHRoZSBmaXJzdCBtYXRjaGluZyBrZXksIG9yIG51bGwgaWYgbm8gbWF0Y2ggaXMgZm91bmQuXG4gICAgICogQHRocm93cyB7RXJyb3J9IElmIGFuIG9iamVjdCBpcyBmb3VuZCBmb3IgYSBtYXRjaGluZyBrZXkgYW5kIGl0cyBfX3R5cGUgcHJvcGVydHkgaXMgbm90IFwiQWRkZWRUb2tlblwiLlxuICAgICAqL1xuICAgIGdldFRva2VuKHRva2VuaXplckNvbmZpZywgLi4ua2V5cykge1xuICAgICAgICBmb3IgKGxldCBrZXkgb2Yga2V5cykge1xuICAgICAgICAgICAgbGV0IGl0ZW0gPSB0b2tlbml6ZXJDb25maWdba2V5XTtcblxuICAgICAgICAgICAgaWYgKCFpdGVtKSBjb250aW51ZTtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBpdGVtID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIGlmIChpdGVtLl9fdHlwZSA9PT0gJ0FkZGVkVG9rZW4nKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpdGVtLmNvbnRlbnQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoYFVua25vd24gdG9rZW46ICR7aXRlbX1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExvYWRzIGEgcHJlLXRyYWluZWQgdG9rZW5pemVyIGZyb20gdGhlIGdpdmVuIGBwcmV0cmFpbmVkX21vZGVsX25hbWVfb3JfcGF0aGAuIFxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcmV0cmFpbmVkX21vZGVsX25hbWVfb3JfcGF0aCBUaGUgcGF0aCB0byB0aGUgcHJlLXRyYWluZWQgdG9rZW5pemVyLlxuICAgICAqIEBwYXJhbSB7UHJldHJhaW5lZE9wdGlvbnN9IG9wdGlvbnMgQWRkaXRpb25hbCBvcHRpb25zIGZvciBsb2FkaW5nIHRoZSB0b2tlbml6ZXIuXG4gICAgICogXG4gICAgICogQHRocm93cyB7RXJyb3J9IFRocm93cyBhbiBlcnJvciBpZiB0aGUgdG9rZW5pemVyLmpzb24gb3IgdG9rZW5pemVyX2NvbmZpZy5qc29uIGZpbGVzIGFyZSBub3QgZm91bmQgaW4gdGhlIGBwcmV0cmFpbmVkX21vZGVsX25hbWVfb3JfcGF0aGAuXG4gICAgICogQHJldHVybnMge1Byb21pc2U8UHJlVHJhaW5lZFRva2VuaXplcj59IEEgbmV3IGluc3RhbmNlIG9mIHRoZSBgUHJlVHJhaW5lZFRva2VuaXplcmAgY2xhc3MuXG4gICAgICovXG4gICAgc3RhdGljIGFzeW5jIGZyb21fcHJldHJhaW5lZChwcmV0cmFpbmVkX21vZGVsX25hbWVfb3JfcGF0aCwge1xuICAgICAgICBwcm9ncmVzc19jYWxsYmFjayA9IG51bGwsXG4gICAgICAgIGNvbmZpZyA9IG51bGwsXG4gICAgICAgIGNhY2hlX2RpciA9IG51bGwsXG4gICAgICAgIGxvY2FsX2ZpbGVzX29ubHkgPSBmYWxzZSxcbiAgICAgICAgcmV2aXNpb24gPSAnbWFpbicsXG4gICAgfSA9IHt9KSB7XG5cbiAgICAgICAgbGV0IGluZm8gPSBhd2FpdCBsb2FkVG9rZW5pemVyKHByZXRyYWluZWRfbW9kZWxfbmFtZV9vcl9wYXRoLCB7XG4gICAgICAgICAgICBwcm9ncmVzc19jYWxsYmFjayxcbiAgICAgICAgICAgIGNvbmZpZyxcbiAgICAgICAgICAgIGNhY2hlX2RpcixcbiAgICAgICAgICAgIGxvY2FsX2ZpbGVzX29ubHksXG4gICAgICAgICAgICByZXZpc2lvbixcbiAgICAgICAgfSlcblxuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIHJldHVybiBuZXcgdGhpcyguLi5pbmZvKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGNhbiBiZSBvdmVycmlkZGVuIGJ5IGEgc3ViY2xhc3MgdG8gYXBwbHkgYWRkaXRpb25hbCBwcmVwcm9jZXNzaW5nXG4gICAgICogdG8gYSBtb2RlbCdzIGlucHV0IGRhdGEuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0cyBBbiBvYmplY3QgY29udGFpbmluZyBpbnB1dCBkYXRhIGFzIHByb3BlcnRpZXMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gVGhlIG1vZGlmaWVkIGlucHV0cyBvYmplY3QuXG4gICAgICovXG4gICAgcHJlcGFyZV9tb2RlbF9pbnB1dHMoaW5wdXRzKSB7XG4gICAgICAgIHJldHVybiBpbnB1dHM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRW5jb2RlL3Rva2VuaXplIHRoZSBnaXZlbiB0ZXh0KHMpLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfHN0cmluZ1tdfSB0ZXh0IFRoZSB0ZXh0IHRvIHRva2VuaXplLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIEFuIG9wdGlvbmFsIG9iamVjdCBjb250YWluaW5nIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXX0gW29wdGlvbnMudGV4dF9wYWlyPW51bGxdIE9wdGlvbmFsIHNlY29uZCBzZXF1ZW5jZSB0byBiZSBlbmNvZGVkLiBJZiBzZXQsIG11c3QgYmUgdGhlIHNhbWUgdHlwZSBhcyB0ZXh0LlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMucGFkZGluZz1mYWxzZV0gV2hldGhlciB0byBwYWQgdGhlIGlucHV0IHNlcXVlbmNlcy5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnRydW5jYXRpb249bnVsbF0gV2hldGhlciB0byB0cnVuY2F0ZSB0aGUgaW5wdXQgc2VxdWVuY2VzLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5tYXhfbGVuZ3RoPW51bGxdIE1heGltdW0gbGVuZ3RoIG9mIHRoZSByZXR1cm5lZCBsaXN0IGFuZCBvcHRpb25hbGx5IHBhZGRpbmcgbGVuZ3RoLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMucmV0dXJuX3RlbnNvcj10cnVlXSBXaGV0aGVyIHRvIHJldHVybiB0aGUgcmVzdWx0cyBhcyBUZW5zb3JzIG9yIGFycmF5cy5cbiAgICAgKiBAcmV0dXJucyB7eyBpbnB1dF9pZHM6IG51bWJlcltdfG51bWJlcltdW118VGVuc29yLCBhdHRlbnRpb25fbWFzazogYW55W118VGVuc29yIH19IE9iamVjdCB0byBiZSBwYXNzZWQgdG8gdGhlIG1vZGVsLlxuICAgICAqL1xuICAgIF9jYWxsKFxuICAgICAgICAvLyBSZXF1aXJlZCBwb3NpdGlvbmFsIGFyZ3VtZW50c1xuICAgICAgICB0ZXh0LFxuXG4gICAgICAgIC8vIE9wdGlvbmFsIGtleXdvcmQgYXJndW1lbnRzXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRleHRfcGFpciA9IG51bGwsXG4gICAgICAgICAgICAvLyBhZGRfc3BlY2lhbF90b2tlbnMgPSB0cnVlLCAvLyBUT0RPXG4gICAgICAgICAgICBwYWRkaW5nID0gZmFsc2UsXG4gICAgICAgICAgICB0cnVuY2F0aW9uID0gbnVsbCxcbiAgICAgICAgICAgIG1heF9sZW5ndGggPSBudWxsLFxuICAgICAgICAgICAgcmV0dXJuX3RlbnNvciA9IHRydWUsIC8vIERpZmZlcmVudCB0byBIRlxuICAgICAgICB9ID0ge30sXG4gICAgKSB7XG5cbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJbXXxudW1iZXJbXVtdfFRlbnNvcn0gKi9cbiAgICAgICAgbGV0IHRva2VucztcblxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0ZXh0KSkge1xuICAgICAgICAgICAgaWYgKHRleHQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ3RleHQgYXJyYXkgbXVzdCBiZSBub24tZW1wdHknKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGV4dF9wYWlyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHRleHRfcGFpcikpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ3RleHRfcGFpciBtdXN0IGFsc28gYmUgYW4gYXJyYXknKVxuXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0ZXh0Lmxlbmd0aCAhPT0gdGV4dF9wYWlyLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcigndGV4dCBhbmQgdGV4dF9wYWlyIG11c3QgaGF2ZSB0aGUgc2FtZSBsZW5ndGgnKVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRva2VucyA9IHRleHQubWFwKFxuICAgICAgICAgICAgICAgICAgICAodCwgaSkgPT4gdGhpcy5lbmNvZGUodCwgdGV4dF9wYWlyW2ldKVxuICAgICAgICAgICAgICAgIClcblxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0b2tlbnMgPSB0ZXh0Lm1hcCh4ID0+IHRoaXMuZW5jb2RlKHgpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRleHQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcigndGV4dCBtYXkgbm90IGJlIG51bGwnKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0ZXh0X3BhaXIpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ1doZW4gc3BlY2lmeWluZyBgdGV4dF9wYWlyYCwgc2luY2UgYHRleHRgIGlzIGEgc3RyaW5nLCBgdGV4dF9wYWlyYCBtdXN0IGFsc28gYmUgYSBzdHJpbmcgKGkuZS4sIG5vdCBhbiBhcnJheSkuJylcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRm9yIHNpbmdsZSBpbnB1dCwgd2UganVzdCB3cmFwIGluIGFuIGFycmF5LCBhbmQgdGhlbiB1bndyYXAgbGF0ZXIuXG4gICAgICAgICAgICB0b2tlbnMgPSBbdGhpcy5lbmNvZGUodGV4dCwgdGV4dF9wYWlyKV07XG4gICAgICAgIH1cbiAgICAgICAgLy8gQXQgdGhpcyBwb2ludCwgdG9rZW5zIGlzIGJhdGNoZWQ6IFtiYXRjaF9zaXplLCB0b2tlbnNdXG4gICAgICAgIC8vIEhvd2V2ZXIsIGFycmF5IG1heSBiZSBqYWdnZWQuIFNvLCB3ZSBwYWQgdG8gbWF4X2xlbmd0aFxuXG4gICAgICAgIGxldCBtYXhMZW5ndGhPZkJhdGNoID0gbWF4KHRva2Vucy5tYXAoeCA9PiB4Lmxlbmd0aCkpWzBdO1xuXG4gICAgICAgIC8vIElmIG51bGwsIHdlIGNhbGN1bGF0ZSBtYXggbGVuZ3RoIGZyb20gc2VxdWVuY2VzXG4gICAgICAgIGlmIChtYXhfbGVuZ3RoID09PSBudWxsKSB7XG4gICAgICAgICAgICBtYXhfbGVuZ3RoID0gbWF4TGVuZ3RoT2ZCYXRjaDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEVuc3VyZSBpdCBpcyBsZXNzIHRoYW4gbW9kZWwgbWF4IGxlbmd0aFxuICAgICAgICBtYXhfbGVuZ3RoID0gTWF0aC5taW4obWF4X2xlbmd0aCwgdGhpcy5tb2RlbF9tYXhfbGVuZ3RoKVxuXG4gICAgICAgIC8qKiBAdHlwZSB7YW55W118VGVuc29yfSAqL1xuICAgICAgICBsZXQgYXR0ZW50aW9uX21hc2sgPSBbXTtcbiAgICAgICAgaWYgKHBhZGRpbmcgfHwgdHJ1bmNhdGlvbikge1xuICAgICAgICAgICAgLy8gUGVyZm9ybSBwYWRkaW5nIGFuZC9vciB0cnVuY2F0aW9uXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIGlmICh0b2tlbnNbaV0ubGVuZ3RoID09PSBtYXhfbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGF0dGVudGlvbl9tYXNrLnB1c2gobmV3IEFycmF5KHRva2Vuc1tpXS5sZW5ndGgpLmZpbGwoMSkpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0b2tlbnNbaV0ubGVuZ3RoID4gbWF4X2xlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBwb3NzaWJseSB0cnVuY2F0ZVxuICAgICAgICAgICAgICAgICAgICBpZiAodHJ1bmNhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW5zW2ldID0gdG9rZW5zW2ldLnNsaWNlKDAsIG1heF9sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGF0dGVudGlvbl9tYXNrLnB1c2gobmV3IEFycmF5KHRva2Vuc1tpXS5sZW5ndGgpLmZpbGwoMSkpXG5cbiAgICAgICAgICAgICAgICB9IGVsc2UgeyAvLyB0Lmxlbmd0aCA8IG1heF9sZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhZGRpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBkaWZmID0gbWF4X2xlbmd0aCAtIHRva2Vuc1tpXS5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnBhZGRpbmdfc2lkZSA9PT0gJ3JpZ2h0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dGVudGlvbl9tYXNrLnB1c2goXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChuZXcgQXJyYXkodG9rZW5zW2ldLmxlbmd0aCkuZmlsbCgxKSkuY29uY2F0KG5ldyBBcnJheShkaWZmKS5maWxsKDApKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b2tlbnNbaV0ucHVzaCguLi5uZXcgQXJyYXkoZGlmZikuZmlsbCh0aGlzLnBhZF90b2tlbl9pZCkpXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgeyAvLyBsZWZ0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0ZW50aW9uX21hc2sucHVzaChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKG5ldyBBcnJheShkaWZmKS5maWxsKDApKS5jb25jYXQobmV3IEFycmF5KHRva2Vuc1tpXS5sZW5ndGgpLmZpbGwoMSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRva2Vuc1tpXS51bnNoaWZ0KC4uLm5ldyBBcnJheShkaWZmKS5maWxsKHRoaXMucGFkX3Rva2VuX2lkKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXR0ZW50aW9uX21hc2sucHVzaChuZXcgQXJyYXkodG9rZW5zW2ldLmxlbmd0aCkuZmlsbCgxKSlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGF0dGVudGlvbl9tYXNrID0gdG9rZW5zLm1hcCh4ID0+IG5ldyBBcnJheSh4Lmxlbmd0aCkuZmlsbCgxKSlcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZXR1cm5fdGVuc29yKSB7XG4gICAgICAgICAgICBpZiAoIShwYWRkaW5nICYmIHRydW5jYXRpb24pKSB7XG4gICAgICAgICAgICAgICAgLy8gTm90LCBndWFyYW50ZWVkIHRoYXQgYWxsIGl0ZW1zIGhhdmUgc2FtZSBsZW5ndGgsIHNvXG4gICAgICAgICAgICAgICAgLy8gd2UgcGVyZm9ybSBhZGRpdGlvbmFsIGNoZWNrXG5cbiAgICAgICAgICAgICAgICBpZiAodG9rZW5zLnNvbWUoeCA9PiB4Lmxlbmd0aCAhPT0gdG9rZW5zWzBdLmxlbmd0aCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICAgICBcIlVuYWJsZSB0byBjcmVhdGUgdGVuc29yLCB5b3Ugc2hvdWxkIHByb2JhYmx5IGFjdGl2YXRlIHRydW5jYXRpb24gYW5kL29yIHBhZGRpbmcgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJ3aXRoICdwYWRkaW5nPXRydWUnIGFuZCAndHJ1bmNhdGlvbj10cnVlJyB0byBoYXZlIGJhdGNoZWQgdGVuc29ycyB3aXRoIHRoZSBzYW1lIGxlbmd0aC5cIlxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBOb3cgd2UgYWN0dWFsbHkgY29udmVydCB0byB0ZW5zb3JcbiAgICAgICAgICAgIC8vIE5PVEU6IEluIHRoZSBzYW1lIHdheSBhcyB0aGUgcHl0aG9uIGxpYnJhcnksIHdlIHJldHVybiBhIGJhdGNoZWQgdGVuc29yLCByZWdhcmRsZXNzIG9mXG4gICAgICAgICAgICAvLyB3aGV0aGVyIHdlIGhhdmUgYSBzaW5nbGUgaW5wdXQgb3IgbXVsdGlwbGUgaW5wdXRzLlxuICAgICAgICAgICAgbGV0IGRpbXMgPSBbdG9rZW5zLmxlbmd0aCwgdG9rZW5zWzBdLmxlbmd0aF07XG5cbiAgICAgICAgICAgIHRva2VucyA9IG5ldyBUZW5zb3IoJ2ludDY0JyxcbiAgICAgICAgICAgICAgICBCaWdJbnQ2NEFycmF5LmZyb20odG9rZW5zLmZsYXQoKS5tYXAoQmlnSW50KSksXG4gICAgICAgICAgICAgICAgZGltc1xuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgYXR0ZW50aW9uX21hc2sgPSBuZXcgVGVuc29yKFxuICAgICAgICAgICAgICAgICdpbnQ2NCcsXG4gICAgICAgICAgICAgICAgQmlnSW50NjRBcnJheS5mcm9tKGF0dGVudGlvbl9tYXNrLmZsYXQoKS5tYXAoQmlnSW50KSksXG4gICAgICAgICAgICAgICAgZGltc1xuICAgICAgICAgICAgKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gSWYgbm90IHJldHVybmluZyBhIHRlbnNvciwgd2UgbWF0Y2ggdGhlIGlucHV0IHR5cGVcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh0ZXh0KSkge1xuICAgICAgICAgICAgICAgIC8vIElucHV0IHdhcyBub3QgYmF0Y2hlZCwgc28gd2UgdW53cmFwXG4gICAgICAgICAgICAgICAgdG9rZW5zID0gdG9rZW5zWzBdO1xuICAgICAgICAgICAgICAgIGF0dGVudGlvbl9tYXNrID0gYXR0ZW50aW9uX21hc2tbMF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuXG4gICAgICAgIC8vIEZpbmFsbHksIGFkZCBhdHRlbnRpb24gbWFzaywgYW5kIHBvc3NpYmx5IG1vZGVsLXNwZWNpZmljIHBhcmFtZXRlcnNcbiAgICAgICAgbGV0IG1vZGVsSW5wdXRzID0ge1xuICAgICAgICAgICAgaW5wdXRfaWRzOiB0b2tlbnMsXG4gICAgICAgICAgICBhdHRlbnRpb25fbWFzazogYXR0ZW50aW9uX21hc2tcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE9wdGlvbmFsIHBvc3QtcHJvY2Vzc2luZ1xuICAgICAgICBtb2RlbElucHV0cyA9IHRoaXMucHJlcGFyZV9tb2RlbF9pbnB1dHMobW9kZWxJbnB1dHMpO1xuXG4gICAgICAgIHJldHVybiBtb2RlbElucHV0c1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVuY29kZXMgYSBzaW5nbGUgdGV4dCB1c2luZyB0aGUgcHJlcHJvY2Vzc29yIHBpcGVsaW5lIG9mIHRoZSB0b2tlbml6ZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xudWxsfSB0ZXh0IFRoZSB0ZXh0IHRvIGVuY29kZS5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nW118bnVsbH0gVGhlIGVuY29kZWQgdG9rZW5zLlxuICAgICAqL1xuICAgIF9lbmNvZGVfdGV4dCh0ZXh0KSB7XG4gICAgICAgIGlmICh0ZXh0ID09PSBudWxsKSByZXR1cm4gbnVsbDtcblxuICAgICAgICAvLyBBY3R1YWwgZnVuY3Rpb24gd2hpY2ggZG9lcyBlbmNvZGluZywgZm9yIGEgc2luZ2xlIHRleHRcbiAgICAgICAgLy8gRmlyc3QsIHdlIHRha2UgY2FyZSBvZiBzcGVjaWFsIHRva2Vucy4gTmVlZGVkIHRvIGF2b2lkIGlzc3VlcyBhcmlzaW5nIGZyb21cbiAgICAgICAgLy8gbm9ybWFsaXphdGlvbiBhbmQvb3IgcHJldG9rZW5pemF0aW9uICh3aGljaCBtYXkgbm90IHByZXNlcnZlIHNwZWNpYWwgdG9rZW5zKVxuICAgICAgICBjb25zdCBzZWN0aW9ucyA9IHRleHQuc3BsaXQodGhpcy5hZGRlZF90b2tlbnNfcmVnZXgpLmZpbHRlcih4ID0+IHgpO1xuXG4gICAgICAgIGxldCB0b2tlbnMgPSBzZWN0aW9ucy5tYXAoeCA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5hZGRlZF90b2tlbnMuaW5jbHVkZXMoeCkpIHtcbiAgICAgICAgICAgICAgICAvLyBJZ25vcmUgYWRkZWQgdG9rZW5zXG4gICAgICAgICAgICAgICAgcmV0dXJuIHhcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucmVtb3ZlX3NwYWNlID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHggPSB4LnRyaW0oKS5zcGxpdCgvXFxzKy8pLmpvaW4oJyAnKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5ub3JtYWxpemVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHggPSB0aGlzLm5vcm1hbGl6ZXIoeCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbGV0IHNlY3Rpb25Ub2tlbnMgPSAodGhpcy5wcmVfdG9rZW5pemVyICE9PSBudWxsKSA/IHRoaXMucHJlX3Rva2VuaXplcih4KSA6IFt4XTtcblxuICAgICAgICAgICAgICAgIGxldCB0b2tlbnMgPSB0aGlzLm1vZGVsKHNlY3Rpb25Ub2tlbnMpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRva2VucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkuZmxhdCgpO1xuXG4gICAgICAgIHJldHVybiB0b2tlbnM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRW5jb2RlcyBhIHNpbmdsZSB0ZXh0IG9yIGEgcGFpciBvZiB0ZXh0cyB1c2luZyB0aGUgbW9kZWwncyB0b2tlbml6ZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCBUaGUgdGV4dCB0byBlbmNvZGUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd8bnVsbH0gdGV4dF9wYWlyIFRoZSBvcHRpb25hbCBzZWNvbmQgdGV4dCB0byBlbmNvZGUuXG4gICAgICogQHJldHVybnMge251bWJlcltdfSBBbiBhcnJheSBvZiB0b2tlbiBJRHMgcmVwcmVzZW50aW5nIHRoZSBlbmNvZGVkIHRleHQocykuXG4gICAgICovXG4gICAgZW5jb2RlKHRleHQsIHRleHRfcGFpciA9IG51bGwpIHtcbiAgICAgICAgLy8gRnVuY3Rpb24gY2FsbGVkIGJ5IHVzZXJzIHRvIGVuY29kZSBwb3NzaWJseSBtdWx0aXBsZSB0ZXh0c1xuICAgICAgICBsZXQgdG9rZW5zID0gdGhpcy5fZW5jb2RlX3RleHQodGV4dCk7XG4gICAgICAgIGxldCB0b2tlbnMyID0gdGhpcy5fZW5jb2RlX3RleHQodGV4dF9wYWlyKTtcblxuICAgICAgICBsZXQgY29tYmluZWRUb2tlbnMgPSAodGhpcy5wb3N0X3Byb2Nlc3NvciAhPT0gbnVsbClcbiAgICAgICAgICAgID8gdGhpcy5wb3N0X3Byb2Nlc3Nvcih0b2tlbnMsIHRva2VuczIpXG4gICAgICAgICAgICA6IG1lcmdlQXJyYXlzKHRva2VucyA/PyBbXSwgdG9rZW5zMiA/PyBbXSk7XG5cbiAgICAgICAgbGV0IGlkcyA9IHRoaXMubW9kZWwuY29udmVydF90b2tlbnNfdG9faWRzKGNvbWJpbmVkVG9rZW5zKTtcbiAgICAgICAgcmV0dXJuIGlkcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZWNvZGUgYSBiYXRjaCBvZiB0b2tlbml6ZWQgc2VxdWVuY2VzLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyW11bXX0gYmF0Y2ggTGlzdCBvZiB0b2tlbml6ZWQgaW5wdXQgc2VxdWVuY2VzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkZWNvZGVfYXJncyAoT3B0aW9uYWwpIE9iamVjdCB3aXRoIGRlY29kaW5nIGFyZ3VtZW50cy5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nW119IExpc3Qgb2YgZGVjb2RlZCBzZXF1ZW5jZXMuXG4gICAgICovXG4gICAgYmF0Y2hfZGVjb2RlKGJhdGNoLCBkZWNvZGVfYXJncyA9IHt9KSB7XG4gICAgICAgIHJldHVybiBiYXRjaC5tYXAoeCA9PiB0aGlzLmRlY29kZSh4LCBkZWNvZGVfYXJncykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlY29kZXMgYSBzZXF1ZW5jZSBvZiB0b2tlbiBJRHMgYmFjayB0byBhIHN0cmluZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyW119IHRva2VuX2lkcyBMaXN0IG9mIHRva2VuIElEcyB0byBkZWNvZGUuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtkZWNvZGVfYXJncz17fV1cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtkZWNvZGVfYXJncy5za2lwX3NwZWNpYWxfdG9rZW5zPWZhbHNlXSBJZiB0cnVlLCBzcGVjaWFsIHRva2VucyBhcmUgcmVtb3ZlZCBmcm9tIHRoZSBvdXRwdXQgc3RyaW5nLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2RlY29kZV9hcmdzLmNsZWFuX3VwX3Rva2VuaXphdGlvbl9zcGFjZXM9dHJ1ZV0gSWYgdHJ1ZSwgc3BhY2VzIGJlZm9yZSBwdW5jdHVhdGlvbnMgYW5kIGFiYnJldmlhdGVkIGZvcm1zIGFyZSByZW1vdmVkLlxuICAgICAqXG4gICAgICogQHJldHVybnMge3N0cmluZ30gVGhlIGRlY29kZWQgc3RyaW5nLlxuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiBgdG9rZW5faWRzYCBpcyBub3QgYSBub24tZW1wdHkgYXJyYXkgb2YgaW50ZWdlcnMuXG4gICAgICovXG4gICAgZGVjb2RlKFxuICAgICAgICB0b2tlbl9pZHMsXG4gICAgICAgIGRlY29kZV9hcmdzID0ge30sXG4gICAgKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh0b2tlbl9pZHMpIHx8IHRva2VuX2lkcy5sZW5ndGggPT09IDAgfHwgIWlzSW50ZWdyYWxOdW1iZXIodG9rZW5faWRzWzBdKSkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJ0b2tlbl9pZHMgbXVzdCBiZSBhIG5vbi1lbXB0eSBhcnJheSBvZiBpbnRlZ2Vycy5cIik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5kZWNvZGVfc2luZ2xlKHRva2VuX2lkcywgZGVjb2RlX2FyZ3MpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVjb2RlIGEgc2luZ2xlIGxpc3Qgb2YgdG9rZW4gaWRzIHRvIGEgc3RyaW5nLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyW119IHRva2VuX2lkcyBMaXN0IG9mIHRva2VuIGlkcyB0byBkZWNvZGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGVjb2RlX2FyZ3MgT3B0aW9uYWwgYXJndW1lbnRzIGZvciBkZWNvZGluZ1xuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2RlY29kZV9hcmdzLnNraXBfc3BlY2lhbF90b2tlbnM9ZmFsc2VdIFdoZXRoZXIgdG8gc2tpcCBzcGVjaWFsIHRva2VucyBkdXJpbmcgZGVjb2RpbmdcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtkZWNvZGVfYXJncy5jbGVhbl91cF90b2tlbml6YXRpb25fc3BhY2VzPW51bGxdIFdoZXRoZXIgdG8gY2xlYW4gdXAgdG9rZW5pemF0aW9uIHNwYWNlcyBkdXJpbmcgZGVjb2RpbmcuXG4gICAgICogSWYgbnVsbCwgdGhlIHZhbHVlIGlzIHNldCB0byBgdGhpcy5kZWNvZGVyLmNsZWFudXBgIGlmIGl0IGV4aXN0cywgZmFsbGluZyBiYWNrIHRvIGB0aGlzLmNsZWFuX3VwX3Rva2VuaXphdGlvbl9zcGFjZXNgIGlmIGl0IGV4aXN0cywgZmFsbGluZyBiYWNrIHRvIGB0cnVlYC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgZGVjb2RlZCBzdHJpbmdcbiAgICAgKi9cbiAgICBkZWNvZGVfc2luZ2xlKFxuICAgICAgICB0b2tlbl9pZHMsXG4gICAgICAgIHtcbiAgICAgICAgICAgIHNraXBfc3BlY2lhbF90b2tlbnMgPSBmYWxzZSxcbiAgICAgICAgICAgIGNsZWFuX3VwX3Rva2VuaXphdGlvbl9zcGFjZXMgPSBudWxsLFxuICAgICAgICB9XG4gICAgKSB7XG4gICAgICAgIGxldCB0b2tlbnMgPSB0aGlzLm1vZGVsLmNvbnZlcnRfaWRzX3RvX3Rva2Vucyh0b2tlbl9pZHMpO1xuICAgICAgICBpZiAoc2tpcF9zcGVjaWFsX3Rva2Vucykge1xuICAgICAgICAgICAgdG9rZW5zID0gdG9rZW5zLmZpbHRlcih4ID0+ICF0aGlzLnNwZWNpYWxfdG9rZW5zLmluY2x1ZGVzKHgpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xuICAgICAgICBsZXQgZGVjb2RlZCA9IHRoaXMuZGVjb2Rlcih0b2tlbnMpO1xuXG5cbiAgICAgICAgLy8gU2xpZ2h0IGhhY2ssIGJ1dCBwcmV2ZW50cyBoYXZpbmcgdG8gcGFzcyBgc2tpcF9zcGVjaWFsX3Rva2Vuc2AgdG9cbiAgICAgICAgLy8gZWFjaCBjYWxsIHRvIGBkZWNvZGVgLCB3aGljaCB3b3VsZCBsZWFkIHRvIGNvZGUgZHVwbGljYXRpb24uXG4gICAgICAgIGlmICh0aGlzLmRlY29kZXIuZW5kX29mX3dvcmRfc3VmZml4KSB7XG4gICAgICAgICAgICBkZWNvZGVkID0gZGVjb2RlZC5yZXBsYWNlQWxsKHRoaXMuZGVjb2Rlci5lbmRfb2Zfd29yZF9zdWZmaXgsICcgJyk7XG4gICAgICAgICAgICBpZiAoc2tpcF9zcGVjaWFsX3Rva2Vucykge1xuICAgICAgICAgICAgICAgIGRlY29kZWQgPSBkZWNvZGVkLnRyaW0oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjbGVhbl91cF90b2tlbml6YXRpb25fc3BhY2VzID8/IHRoaXMuY2xlYW5fdXBfdG9rZW5pemF0aW9uX3NwYWNlcykge1xuICAgICAgICAgICAgZGVjb2RlZCA9IGNsZWFuX3VwX3Rva2VuaXphdGlvbihkZWNvZGVkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkZWNvZGVkO1xuICAgIH1cblxufVxuXG4vKipcbiogSGVscGVyIG1ldGhvZCBmb3IgYWRkaW5nIGB0b2tlbl90eXBlX2lkc2AgdG8gbW9kZWwgaW5wdXRzXG4qIEBwYXJhbSB7T2JqZWN0fSBpbnB1dHMgQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGlucHV0IGlkcyBhbmQgYXR0ZW50aW9uIG1hc2suXG4qIEByZXR1cm5zIHtPYmplY3R9IFRoZSBwcmVwYXJlZCBpbnB1dHMgb2JqZWN0LlxuKi9cbmZ1bmN0aW9uIGFkZF90b2tlbl90eXBlcyhpbnB1dHMpIHtcbiAgICAvLyBUT0RPIGVuc3VyZSBjb3JyZWN0bmVzcyB3aGVuIHRva2VuIHBhaXIgaXMgcHJlc2VudFxuICAgIGlmIChpbnB1dHMuaW5wdXRfaWRzIGluc3RhbmNlb2YgVGVuc29yKSB7XG4gICAgICAgIGlucHV0cy50b2tlbl90eXBlX2lkcyA9IG5ldyBUZW5zb3IoXG4gICAgICAgICAgICAnaW50NjQnLFxuICAgICAgICAgICAgbmV3IEJpZ0ludDY0QXJyYXkoaW5wdXRzLmlucHV0X2lkcy5kYXRhLmxlbmd0aCksXG4gICAgICAgICAgICBpbnB1dHMuaW5wdXRfaWRzLmRpbXNcbiAgICAgICAgKVxuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShpbnB1dHMuaW5wdXRfaWRzKSkge1xuXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGlucHV0cy5pbnB1dF9pZHNbMF0pKSB7XG4gICAgICAgICAgICAvLyBUaGlzIG1lYW5zIGlucHV0IGlzIGJhdGNoZWQsIHNvIHdlIG5lZWQgdG8gYmF0Y2ggdGhlIHRva2VuX3R5cGVfaWRzIGFzIHdlbGxcbiAgICAgICAgICAgIGlucHV0cy50b2tlbl90eXBlX2lkcyA9IGlucHV0cy5pbnB1dF9pZHMubWFwKFxuICAgICAgICAgICAgICAgIHggPT4gbmV3IEFycmF5KHgubGVuZ3RoKS5maWxsKDApXG4gICAgICAgICAgICApXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpbnB1dHMudG9rZW5fdHlwZV9pZHMgPSBuZXcgQXJyYXkoaW5wdXRzLmlucHV0X2lkcy5sZW5ndGgpLmZpbGwoMCk7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IGlkcyBtdXN0IGJlIGEgVGVuc29yIG9yIGFuIEFycmF5JylcbiAgICB9XG5cbiAgICByZXR1cm4gaW5wdXRzO1xufVxuXG4vKipcbiAqIEJlcnRUb2tlbml6ZXIgaXMgYSBjbGFzcyB1c2VkIHRvIHRva2VuaXplIHRleHQgZm9yIEJFUlQgbW9kZWxzLlxuICogQGV4dGVuZHMgUHJlVHJhaW5lZFRva2VuaXplclxuICovXG5leHBvcnQgY2xhc3MgQmVydFRva2VuaXplciBleHRlbmRzIFByZVRyYWluZWRUb2tlbml6ZXIge1xuICAgIC8qKiBAdHlwZSB7YWRkX3Rva2VuX3R5cGVzfSAqL1xuICAgIHByZXBhcmVfbW9kZWxfaW5wdXRzKGlucHV0cykge1xuICAgICAgICByZXR1cm4gYWRkX3Rva2VuX3R5cGVzKGlucHV0cyk7XG4gICAgfVxufVxuLyoqXG4gKiBBbGJlcnQgdG9rZW5pemVyXG4gKiBAZXh0ZW5kcyBQcmVUcmFpbmVkVG9rZW5pemVyXG4gKi9cbmV4cG9ydCBjbGFzcyBBbGJlcnRUb2tlbml6ZXIgZXh0ZW5kcyBQcmVUcmFpbmVkVG9rZW5pemVyIHtcbiAgICAvKiogQHR5cGUge2FkZF90b2tlbl90eXBlc30gKi9cbiAgICBwcmVwYXJlX21vZGVsX2lucHV0cyhpbnB1dHMpIHtcbiAgICAgICAgcmV0dXJuIGFkZF90b2tlbl90eXBlcyhpbnB1dHMpO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBNb2JpbGVCZXJ0VG9rZW5pemVyIGV4dGVuZHMgUHJlVHJhaW5lZFRva2VuaXplciB7XG4gICAgLyoqIEB0eXBlIHthZGRfdG9rZW5fdHlwZXN9ICovXG4gICAgcHJlcGFyZV9tb2RlbF9pbnB1dHMoaW5wdXRzKSB7XG4gICAgICAgIHJldHVybiBhZGRfdG9rZW5fdHlwZXMoaW5wdXRzKTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgU3F1ZWV6ZUJlcnRUb2tlbml6ZXIgZXh0ZW5kcyBQcmVUcmFpbmVkVG9rZW5pemVyIHtcbiAgICAvKiogQHR5cGUge2FkZF90b2tlbl90eXBlc30gKi9cbiAgICBwcmVwYXJlX21vZGVsX2lucHV0cyhpbnB1dHMpIHtcbiAgICAgICAgcmV0dXJuIGFkZF90b2tlbl90eXBlcyhpbnB1dHMpO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBEaXN0aWxCZXJ0VG9rZW5pemVyIGV4dGVuZHMgUHJlVHJhaW5lZFRva2VuaXplciB7IH1cbmV4cG9ydCBjbGFzcyBUNVRva2VuaXplciBleHRlbmRzIFByZVRyYWluZWRUb2tlbml6ZXIgeyB9XG5leHBvcnQgY2xhc3MgR1BUMlRva2VuaXplciBleHRlbmRzIFByZVRyYWluZWRUb2tlbml6ZXIgeyB9XG5leHBvcnQgY2xhc3MgQmFydFRva2VuaXplciBleHRlbmRzIFByZVRyYWluZWRUb2tlbml6ZXIgeyB9XG5leHBvcnQgY2xhc3MgUm9iZXJ0YVRva2VuaXplciBleHRlbmRzIFByZVRyYWluZWRUb2tlbml6ZXIgeyB9XG5cbmV4cG9ydCBjbGFzcyBCbG9vbVRva2VuaXplciBleHRlbmRzIFByZVRyYWluZWRUb2tlbml6ZXIgeyB9XG5leHBvcnQgY2xhc3MgTGxhbWFUb2tlbml6ZXIgZXh0ZW5kcyBQcmVUcmFpbmVkVG9rZW5pemVyIHsgfVxuXG5leHBvcnQgY2xhc3MgWExNUm9iZXJ0YVRva2VuaXplciBleHRlbmRzIFByZVRyYWluZWRUb2tlbml6ZXIgeyB9XG5leHBvcnQgY2xhc3MgTVBOZXRUb2tlbml6ZXIgZXh0ZW5kcyBQcmVUcmFpbmVkVG9rZW5pemVyIHsgfVxuXG5leHBvcnQgY2xhc3MgRmFsY29uVG9rZW5pemVyIGV4dGVuZHMgUHJlVHJhaW5lZFRva2VuaXplciB7XG4gICAgLyoqIEB0eXBlIHthZGRfdG9rZW5fdHlwZXN9ICovXG4gICAgcHJlcGFyZV9tb2RlbF9pbnB1dHMoaW5wdXRzKSB7XG4gICAgICAgIHJldHVybiBhZGRfdG9rZW5fdHlwZXMoaW5wdXRzKTtcbiAgICB9XG59XG5cbmV4cG9ydCBjbGFzcyBHUFROZW9YVG9rZW5pemVyIGV4dGVuZHMgUHJlVHJhaW5lZFRva2VuaXplciB7IH1cblxuLyoqXG4gKiBUaGUgTmxsYlRva2VuaXplciBjbGFzcyBpcyB1c2VkIHRvIHRva2VuaXplIHRleHQgZm9yIE5MTEIgKFwiTm8gTGFuZ3VhZ2UgTGVmdCBCZWhpbmRcIikgbW9kZWxzLlxuICogXG4gKiBObyBMYW5ndWFnZSBMZWZ0IEJlaGluZCAoTkxMQikgaXMgYSBmaXJzdC1vZi1pdHMta2luZCwgQUkgYnJlYWt0aHJvdWdoIHByb2plY3RcbiAqIHRoYXQgb3Blbi1zb3VyY2VzIG1vZGVscyBjYXBhYmxlIG9mIGRlbGl2ZXJpbmcgaGlnaC1xdWFsaXR5IHRyYW5zbGF0aW9ucyBkaXJlY3RseVxuICogYmV0d2VlbiBhbnkgcGFpciBvZiAyMDArIGxhbmd1YWdlcyDigJQgaW5jbHVkaW5nIGxvdy1yZXNvdXJjZSBsYW5ndWFnZXMgbGlrZSBBc3R1cmlhbixcbiAqIEx1Z2FuZGEsIFVyZHUgYW5kIG1vcmUuIEl0IGFpbXMgdG8gaGVscCBwZW9wbGUgY29tbXVuaWNhdGUgd2l0aCBhbnlvbmUsIGFueXdoZXJlLFxuICogcmVnYXJkbGVzcyBvZiB0aGVpciBsYW5ndWFnZSBwcmVmZXJlbmNlcy4gRm9yIG1vcmUgaW5mb3JtYXRpb24sIGNoZWNrIG91dCB0aGVpclxuICogW3BhcGVyXShodHRwczovL2FyeGl2Lm9yZy9hYnMvMjIwNy4wNDY3MikuXG4gKiBcbiAqIEZvciBhIGxpc3Qgb2Ygc3VwcG9ydGVkIGxhbmd1YWdlcyAoYWxvbmcgd2l0aCB0aGVpciBsYW5ndWFnZSBjb2RlcyksXG4gKiBAc2VlIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2tyZXNlYXJjaC9mbG9yZXMvYmxvYi9tYWluL2Zsb3JlczIwMC9SRUFETUUubWQjbGFuZ3VhZ2VzLWluLWZsb3Jlcy0yMDB9XG4gKi9cbmV4cG9ydCBjbGFzcyBObGxiVG9rZW5pemVyIGV4dGVuZHMgUHJlVHJhaW5lZFRva2VuaXplciB7XG5cbiAgICBjb25zdHJ1Y3Rvcih0b2tlbml6ZXJKU09OLCB0b2tlbml6ZXJDb25maWcpIHtcbiAgICAgICAgc3VwZXIodG9rZW5pemVySlNPTiwgdG9rZW5pemVyQ29uZmlnKTtcblxuICAgICAgICB0aGlzLmxhbmd1YWdlUmVnZXggPSAvXlthLXpdezN9X1tBLVpdW2Etel17M30kLztcbiAgICAgICAgdGhpcy5sYW5ndWFnZV9jb2RlcyA9IHRoaXMuc3BlY2lhbF90b2tlbnMuZmlsdGVyKHggPT4gdGhpcy5sYW5ndWFnZVJlZ2V4LnRlc3QoeCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhlbHBlciBmdW5jdGlvbiB0byBidWlsZCB0cmFuc2xhdGlvbiBpbnB1dHMgZm9yIGFuIGBObGxiVG9rZW5pemVyYC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXX0gcmF3X2lucHV0cyBUaGUgdGV4dCB0byB0b2tlbml6ZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdG9rZW5pemVyX29wdGlvbnMgT3B0aW9ucyB0byBiZSBzZW50IHRvIHRoZSB0b2tlbml6ZXJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZ2VuZXJhdGVfa3dhcmdzIEdlbmVyYXRpb24gb3B0aW9ucy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBPYmplY3QgdG8gYmUgcGFzc2VkIHRvIHRoZSBtb2RlbC5cbiAgICAgKi9cbiAgICBfYnVpbGRfdHJhbnNsYXRpb25faW5wdXRzKHJhd19pbnB1dHMsIHRva2VuaXplcl9vcHRpb25zLCBnZW5lcmF0ZV9rd2FyZ3MpIHtcblxuXG4gICAgICAgIC8vIENoZWNrIHRoYXQgdGhlIHRhcmdldCBsYW5ndWFnZSBpcyB2YWxpZDpcbiAgICAgICAgaWYgKCF0aGlzLmxhbmd1YWdlX2NvZGVzLmluY2x1ZGVzKGdlbmVyYXRlX2t3YXJncy50Z3RfbGFuZykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVGFyZ2V0IGxhbmd1YWdlIGNvZGUgXCIke2dlbmVyYXRlX2t3YXJncy50Z3RfbGFuZ31cIiBpcyBub3QgdmFsaWQuIE11c3QgYmUgb25lIG9mOiB7JHt0aGlzLmxhbmd1YWdlX2NvZGVzLmpvaW4oJywgJyl9fWApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQWxsb3cgYHNyY19sYW5nYCB0byBiZSBvcHRpb25hbC4gSWYgbm90IHNldCwgd2UnbGwgdXNlIHRoZSB0b2tlbml6ZXIncyBkZWZhdWx0LlxuICAgICAgICBpZiAoZ2VuZXJhdGVfa3dhcmdzLnNyY19sYW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIENoZWNrIHRoYXQgdGhlIHNvdXJjZSBsYW5ndWFnZSBpcyB2YWxpZDpcbiAgICAgICAgICAgIGlmICghdGhpcy5sYW5ndWFnZV9jb2Rlcy5pbmNsdWRlcyhnZW5lcmF0ZV9rd2FyZ3Muc3JjX2xhbmcpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBTb3VyY2UgbGFuZ3VhZ2UgY29kZSBcIiR7Z2VuZXJhdGVfa3dhcmdzLnNyY19sYW5nfVwiIGlzIG5vdCB2YWxpZC4gTXVzdCBiZSBvbmUgb2Y6IHske3RoaXMubGFuZ3VhZ2VfY29kZXMuam9pbignLCAnKX19YCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEluIHRoZSBzYW1lIHdheSBhcyB0aGUgUHl0aG9uIGxpYnJhcnksIHdlIG92ZXJyaWRlIHRoZSBwb3N0LXByb2Nlc3NvclxuICAgICAgICAgICAgLy8gdG8gZm9yY2UgdGhlIHNvdXJjZSBsYW5ndWFnZSB0byBiZSBmaXJzdDpcbiAgICAgICAgICAgIGZvciAobGV0IGl0ZW0gb2YgdGhpcy5wb3N0X3Byb2Nlc3Nvci5jb25maWcuc2luZ2xlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCdTcGVjaWFsVG9rZW4nIGluIGl0ZW0gJiYgdGhpcy5sYW5ndWFnZVJlZ2V4LnRlc3QoaXRlbS5TcGVjaWFsVG9rZW4uaWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0uU3BlY2lhbFRva2VuLmlkID0gZ2VuZXJhdGVfa3dhcmdzLnNyY19sYW5nO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBPdmVycmlkZSB0aGUgYGZvcmNlZF9ib3NfdG9rZW5faWRgIHRvIGZvcmNlIHRoZSBjb3JyZWN0IGxhbmd1YWdlXG4gICAgICAgIGdlbmVyYXRlX2t3YXJncy5mb3JjZWRfYm9zX3Rva2VuX2lkID0gdGhpcy5tb2RlbC5jb252ZXJ0X3Rva2Vuc190b19pZHMoW2dlbmVyYXRlX2t3YXJncy50Z3RfbGFuZ10pWzBdO1xuXG4gICAgICAgIHJldHVybiB0aGlzLl9jYWxsKHJhd19pbnB1dHMsIHRva2VuaXplcl9vcHRpb25zKTtcbiAgICB9XG59XG5cblxuY29uc3QgV0hJU1BFUl9MQU5HVUFHRVMgPSBbXG4gICAgW1wiZW5cIiwgXCJlbmdsaXNoXCJdLFxuICAgIFtcInpoXCIsIFwiY2hpbmVzZVwiXSxcbiAgICBbXCJkZVwiLCBcImdlcm1hblwiXSxcbiAgICBbXCJlc1wiLCBcInNwYW5pc2hcIl0sXG4gICAgW1wicnVcIiwgXCJydXNzaWFuXCJdLFxuICAgIFtcImtvXCIsIFwia29yZWFuXCJdLFxuICAgIFtcImZyXCIsIFwiZnJlbmNoXCJdLFxuICAgIFtcImphXCIsIFwiamFwYW5lc2VcIl0sXG4gICAgW1wicHRcIiwgXCJwb3J0dWd1ZXNlXCJdLFxuICAgIFtcInRyXCIsIFwidHVya2lzaFwiXSxcbiAgICBbXCJwbFwiLCBcInBvbGlzaFwiXSxcbiAgICBbXCJjYVwiLCBcImNhdGFsYW5cIl0sXG4gICAgW1wibmxcIiwgXCJkdXRjaFwiXSxcbiAgICBbXCJhclwiLCBcImFyYWJpY1wiXSxcbiAgICBbXCJzdlwiLCBcInN3ZWRpc2hcIl0sXG4gICAgW1wiaXRcIiwgXCJpdGFsaWFuXCJdLFxuICAgIFtcImlkXCIsIFwiaW5kb25lc2lhblwiXSxcbiAgICBbXCJoaVwiLCBcImhpbmRpXCJdLFxuICAgIFtcImZpXCIsIFwiZmlubmlzaFwiXSxcbiAgICBbXCJ2aVwiLCBcInZpZXRuYW1lc2VcIl0sXG4gICAgW1wiaGVcIiwgXCJoZWJyZXdcIl0sXG4gICAgW1widWtcIiwgXCJ1a3JhaW5pYW5cIl0sXG4gICAgW1wiZWxcIiwgXCJncmVla1wiXSxcbiAgICBbXCJtc1wiLCBcIm1hbGF5XCJdLFxuICAgIFtcImNzXCIsIFwiY3plY2hcIl0sXG4gICAgW1wicm9cIiwgXCJyb21hbmlhblwiXSxcbiAgICBbXCJkYVwiLCBcImRhbmlzaFwiXSxcbiAgICBbXCJodVwiLCBcImh1bmdhcmlhblwiXSxcbiAgICBbXCJ0YVwiLCBcInRhbWlsXCJdLFxuICAgIFtcIm5vXCIsIFwibm9yd2VnaWFuXCJdLFxuICAgIFtcInRoXCIsIFwidGhhaVwiXSxcbiAgICBbXCJ1clwiLCBcInVyZHVcIl0sXG4gICAgW1wiaHJcIiwgXCJjcm9hdGlhblwiXSxcbiAgICBbXCJiZ1wiLCBcImJ1bGdhcmlhblwiXSxcbiAgICBbXCJsdFwiLCBcImxpdGh1YW5pYW5cIl0sXG4gICAgW1wibGFcIiwgXCJsYXRpblwiXSxcbiAgICBbXCJtaVwiLCBcIm1hb3JpXCJdLFxuICAgIFtcIm1sXCIsIFwibWFsYXlhbGFtXCJdLFxuICAgIFtcImN5XCIsIFwid2Vsc2hcIl0sXG4gICAgW1wic2tcIiwgXCJzbG92YWtcIl0sXG4gICAgW1widGVcIiwgXCJ0ZWx1Z3VcIl0sXG4gICAgW1wiZmFcIiwgXCJwZXJzaWFuXCJdLFxuICAgIFtcImx2XCIsIFwibGF0dmlhblwiXSxcbiAgICBbXCJiblwiLCBcImJlbmdhbGlcIl0sXG4gICAgW1wic3JcIiwgXCJzZXJiaWFuXCJdLFxuICAgIFtcImF6XCIsIFwiYXplcmJhaWphbmlcIl0sXG4gICAgW1wic2xcIiwgXCJzbG92ZW5pYW5cIl0sXG4gICAgW1wia25cIiwgXCJrYW5uYWRhXCJdLFxuICAgIFtcImV0XCIsIFwiZXN0b25pYW5cIl0sXG4gICAgW1wibWtcIiwgXCJtYWNlZG9uaWFuXCJdLFxuICAgIFtcImJyXCIsIFwiYnJldG9uXCJdLFxuICAgIFtcImV1XCIsIFwiYmFzcXVlXCJdLFxuICAgIFtcImlzXCIsIFwiaWNlbGFuZGljXCJdLFxuICAgIFtcImh5XCIsIFwiYXJtZW5pYW5cIl0sXG4gICAgW1wibmVcIiwgXCJuZXBhbGlcIl0sXG4gICAgW1wibW5cIiwgXCJtb25nb2xpYW5cIl0sXG4gICAgW1wiYnNcIiwgXCJib3NuaWFuXCJdLFxuICAgIFtcImtrXCIsIFwia2F6YWtoXCJdLFxuICAgIFtcInNxXCIsIFwiYWxiYW5pYW5cIl0sXG4gICAgW1wic3dcIiwgXCJzd2FoaWxpXCJdLFxuICAgIFtcImdsXCIsIFwiZ2FsaWNpYW5cIl0sXG4gICAgW1wibXJcIiwgXCJtYXJhdGhpXCJdLFxuICAgIFtcInBhXCIsIFwicHVuamFiaVwiXSxcbiAgICBbXCJzaVwiLCBcInNpbmhhbGFcIl0sXG4gICAgW1wia21cIiwgXCJraG1lclwiXSxcbiAgICBbXCJzblwiLCBcInNob25hXCJdLFxuICAgIFtcInlvXCIsIFwieW9ydWJhXCJdLFxuICAgIFtcInNvXCIsIFwic29tYWxpXCJdLFxuICAgIFtcImFmXCIsIFwiYWZyaWthYW5zXCJdLFxuICAgIFtcIm9jXCIsIFwib2NjaXRhblwiXSxcbiAgICBbXCJrYVwiLCBcImdlb3JnaWFuXCJdLFxuICAgIFtcImJlXCIsIFwiYmVsYXJ1c2lhblwiXSxcbiAgICBbXCJ0Z1wiLCBcInRhamlrXCJdLFxuICAgIFtcInNkXCIsIFwic2luZGhpXCJdLFxuICAgIFtcImd1XCIsIFwiZ3VqYXJhdGlcIl0sXG4gICAgW1wiYW1cIiwgXCJhbWhhcmljXCJdLFxuICAgIFtcInlpXCIsIFwieWlkZGlzaFwiXSxcbiAgICBbXCJsb1wiLCBcImxhb1wiXSxcbiAgICBbXCJ1elwiLCBcInV6YmVrXCJdLFxuICAgIFtcImZvXCIsIFwiZmFyb2VzZVwiXSxcbiAgICBbXCJodFwiLCBcImhhaXRpYW4gY3Jlb2xlXCJdLFxuICAgIFtcInBzXCIsIFwicGFzaHRvXCJdLFxuICAgIFtcInRrXCIsIFwidHVya21lblwiXSxcbiAgICBbXCJublwiLCBcIm55bm9yc2tcIl0sXG4gICAgW1wibXRcIiwgXCJtYWx0ZXNlXCJdLFxuICAgIFtcInNhXCIsIFwic2Fuc2tyaXRcIl0sXG4gICAgW1wibGJcIiwgXCJsdXhlbWJvdXJnaXNoXCJdLFxuICAgIFtcIm15XCIsIFwibXlhbm1hclwiXSxcbiAgICBbXCJib1wiLCBcInRpYmV0YW5cIl0sXG4gICAgW1widGxcIiwgXCJ0YWdhbG9nXCJdLFxuICAgIFtcIm1nXCIsIFwibWFsYWdhc3lcIl0sXG4gICAgW1wiYXNcIiwgXCJhc3NhbWVzZVwiXSxcbiAgICBbXCJ0dFwiLCBcInRhdGFyXCJdLFxuICAgIFtcImhhd1wiLCBcImhhd2FpaWFuXCJdLFxuICAgIFtcImxuXCIsIFwibGluZ2FsYVwiXSxcbiAgICBbXCJoYVwiLCBcImhhdXNhXCJdLFxuICAgIFtcImJhXCIsIFwiYmFzaGtpclwiXSxcbiAgICBbXCJqd1wiLCBcImphdmFuZXNlXCJdLFxuICAgIFtcInN1XCIsIFwic3VuZGFuZXNlXCJdLFxuXVxuXG4vLyBAdHMtaWdub3JlXG5jb25zdCBXSElTUEVSX0xBTkdVQUdFX01BUFBJTkcgPSBuZXcgTWFwKFdISVNQRVJfTEFOR1VBR0VTKTtcbi8vIEB0cy1pZ25vcmVcbmNvbnN0IFdISVNQRVJfVE9fTEFOR1VBR0VfQ09ERV9NQVBQSU5HID0gbmV3IE1hcChbXG4gICAgLi4uV0hJU1BFUl9MQU5HVUFHRVMubWFwKChbaywgdl0pID0+IFt2LCBrXSksXG4gICAgLi4uW1xuICAgICAgICBbXCJidXJtZXNlXCIsIFwibXlcIl0sXG4gICAgICAgIFtcInZhbGVuY2lhblwiLCBcImNhXCJdLFxuICAgICAgICBbXCJmbGVtaXNoXCIsIFwibmxcIl0sXG4gICAgICAgIFtcImhhaXRpYW5cIiwgXCJodFwiXSxcbiAgICAgICAgW1wibGV0emVidXJnZXNjaFwiLCBcImxiXCJdLFxuICAgICAgICBbXCJwdXNodG9cIiwgXCJwc1wiXSxcbiAgICAgICAgW1wicGFuamFiaVwiLCBcInBhXCJdLFxuICAgICAgICBbXCJtb2xkYXZpYW5cIiwgXCJyb1wiXSxcbiAgICAgICAgW1wibW9sZG92YW5cIiwgXCJyb1wiXSxcbiAgICAgICAgW1wic2luaGFsZXNlXCIsIFwic2lcIl0sXG4gICAgICAgIFtcImNhc3RpbGlhblwiLCBcImVzXCJdLFxuICAgIF1cbl0pO1xuXG4vKipcbiAqIFdoaXNwZXJUb2tlbml6ZXIgdG9rZW5pemVyXG4gKiBAZXh0ZW5kcyBQcmVUcmFpbmVkVG9rZW5pemVyXG4gKi9cbmV4cG9ydCBjbGFzcyBXaGlzcGVyVG9rZW5pemVyIGV4dGVuZHMgUHJlVHJhaW5lZFRva2VuaXplciB7XG5cbiAgICAvKipcbiAgICAgKiBEZWNvZGVzIGF1dG9tYXRpYyBzcGVlY2ggcmVjb2duaXRpb24gKEFTUikgc2VxdWVuY2VzLlxuICAgICAqIEBwYXJhbSB7QXJyYXk8e3Rva2VuczogbnVtYmVyW10sIHRva2VuX3RpbWVzdGFtcHM/OiBudW1iZXJbXSwgc3RyaWRlOiBudW1iZXJbXX0+fSBzZXF1ZW5jZXMgVGhlIHNlcXVlbmNlcyB0byBkZWNvZGUuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgVGhlIG9wdGlvbnMgdG8gdXNlIGZvciBkZWNvZGluZy5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXk8c3RyaW5nfHtjaHVua3M/OiB1bmRlZmluZWR8QXJyYXk8e2xhbmd1YWdlOiBzdHJpbmd8bnVsbCwgdGltZXN0YW1wOiBBcnJheTxudW1iZXJ8bnVsbD4sIHRleHQ6IHN0cmluZ30+fT59IFRoZSBkZWNvZGVkIHNlcXVlbmNlcy5cbiAgICAgKi9cbiAgICBfZGVjb2RlX2FzcihzZXF1ZW5jZXMsIHtcbiAgICAgICAgcmV0dXJuX3RpbWVzdGFtcHMgPSBmYWxzZSxcbiAgICAgICAgcmV0dXJuX2xhbmd1YWdlID0gZmFsc2UsXG4gICAgICAgIHRpbWVfcHJlY2lzaW9uID0gbnVsbCxcbiAgICAgICAgZm9yY2VfZnVsbF9zZXF1ZW5jZXMgPSB0cnVlXG4gICAgfSA9IHt9KSB7XG4gICAgICAgIC8vIFNldCBmb3JjZV9mdWxsX3NlcXVlbmNlcz1mYWxzZSBpZiB5b3Ugd2FudCBzdHJlYW1pbmdcbiAgICAgICAgLy8gVE9ETyBhZGQgc3VwcG9ydCBmb3IgYHJldHVybl9sYW5ndWFnZWBcblxuICAgICAgICAvLyBJbnRlcm5hbCBtZXRob2QgbWVhbnQgdG8gb25seSBiZSB1c2VkIGJ5IGFzciBwaXBlbGluZS5cbiAgICAgICAgLy8gSGFuZGxlcyBhbGwgdGhlIGxpdHRsZSBxdWlya3Mgc3BlY2lmaWMgdG8gd2hpc3BlciB0byBoYW5kbGVcbiAgICAgICAgLy8gdGhlIHZhcmlvdXMgb3B0aW9ucyBub3QgYWxsb3dlZCBpbiBvdGhlciBzZXEyc2VxIG1vZGVsc1xuXG4gICAgICAgIC8vID09PT09PT09PT09IE92ZXJ2aWV3ID09PT09PT09PT09PVxuICAgICAgICAvLyAtIGl0ZXJhdGUgb3ZlciBhbGwgb3V0cHV0c1xuICAgICAgICAvLyAtIGFsbCB0b2tlbnMgd2l0aGluIG91dHB1dFxuICAgICAgICAvLyAtIEVhY2ggdG9rZW4gY2FuIGJlXG4gICAgICAgIC8vICAgLSBsYW5ndWFnZSB0b2tlblxuICAgICAgICAvLyAgIC0gc3BlY2lhbCB0b2tlblxuICAgICAgICAvLyAgIC0gdGltZXN0YW1wIHRva2VuXG4gICAgICAgIC8vICAgLSB0ZXh0IHRva2VuXG4gICAgICAgIC8vIC0gV2UgYWNjdW11bGF0ZSB0aGUgdGV4dCB0b2tlbnMuXG4gICAgICAgIC8vIC0gV2Ugc3BsaXQgb24gZW5kIHRpbWVzdGFtcHNcbiAgICAgICAgLy8gLSBMb3RzIG9mIGNvbXBsZXhpdHkgY29tZXMgZnJvbSBzdHJpZGUgYW5kIHRpbWVzdGFtcHNcblxuICAgICAgICBpZiAodGltZV9wcmVjaXNpb24gPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKFwiTXVzdCBzcGVjaWZ5IHRpbWVfcHJlY2lzaW9uXCIpXG4gICAgICAgIH1cbiAgICAgICAgbGV0IGxhc3RfbGFuZ3VhZ2UgPSBudWxsO1xuXG4gICAgICAgIGNvbnN0IHJldHVybldvcmRUaW1lc3RhbXBzID0gcmV0dXJuX3RpbWVzdGFtcHMgPT09IFwid29yZFwiO1xuXG4gICAgICAgIGZ1bmN0aW9uIG5ld19jaHVuaygpIHtcbiAgICAgICAgICAgIHJldHVybiB7IFwibGFuZ3VhZ2VcIjogbGFzdF9sYW5ndWFnZSwgXCJ0aW1lc3RhbXBcIjogW251bGwsIG51bGxdLCBcInRleHRcIjogXCJcIiB9O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gV2VsY29tZSB0byB0aGUgc3RhdGUgbWFjaGluZSFcbiAgICAgICAgY29uc3QgY2h1bmtzID0gW107XG4gICAgICAgIGxldCBjaHVuayA9IG5ld19jaHVuaygpO1xuICAgICAgICBsZXQgdGltZV9vZmZzZXQgPSAwLjA7XG4gICAgICAgIGNvbnN0IHRpbWVzdGFtcF9iZWdpbiA9IHRoaXMubW9kZWwuY29udmVydF90b2tlbnNfdG9faWRzKFtcIjx8bm90aW1lc3RhbXBzfD5cIl0pWzBdICsgMTtcblxuICAgICAgICBsZXQgcHJldmlvdXNfdG9rZW5zID0gW107XG4gICAgICAgIGxldCBwcmV2aW91c190b2tlbl90aW1lc3RhbXBzID0gW107XG5cbiAgICAgICAgbGV0IHNraXAgPSBmYWxzZTtcbiAgICAgICAgbGV0IHJpZ2h0X3N0cmlkZV9zdGFydCA9IG51bGw7XG5cblxuICAgICAgICBjb25zdCBhbGxfc3BlY2lhbF9pZHMgPSBuZXcgU2V0KHRoaXMuYWxsX3NwZWNpYWxfaWRzKTtcblxuICAgICAgICBmb3IgKGxldCBvdXRwdXQgb2Ygc2VxdWVuY2VzKSB7XG4gICAgICAgICAgICAvLyBOT1RFOiBweXRob24gdmVyc2lvbiBoYXMgYmF0Y2hlcywgc28gaXQgdXNlcyBbMF1cbiAgICAgICAgICAgIGNvbnN0IHRva2VuX2lkcyA9IG91dHB1dC50b2tlbnM7XG4gICAgICAgICAgICBjb25zdCB0b2tlbl90aW1lc3RhbXBzID0gcmV0dXJuV29yZFRpbWVzdGFtcHMgPyBvdXRwdXQudG9rZW5fdGltZXN0YW1wcyA6IG51bGw7XG5cbiAgICAgICAgICAgIC8vIFRoZXNlIGtlZXAgdHJhY2sgb2YgdGltZXN0YW1wcyB3aXRoaW4gc3RyaWRlcywgd2hpY2ggbmVlZFxuICAgICAgICAgICAgLy8gdG8gYmUgc2tpcHBlZCBhbmQgcmVzb2x2ZSBhbGwgdG9rZW5zIGluIGEgc2luZ2xlIGNodW5rLlxuICAgICAgICAgICAgbGV0IGxhc3RfdGltZXN0YW1wID0gbnVsbDtcbiAgICAgICAgICAgIGxldCBmaXJzdF90aW1lc3RhbXAgPSB0aW1lc3RhbXBfYmVnaW47XG5cbiAgICAgICAgICAgIGlmIChcInN0cmlkZVwiIGluIG91dHB1dCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IFtjaHVua19sZW4sIHN0cmlkZV9sZWZ0LCBzdHJpZGVfcmlnaHRdID0gb3V0cHV0LnN0cmlkZTtcblxuICAgICAgICAgICAgICAgIC8vIE9mZnNldCB0aGUgdGltaW5ncyB0byBhY2NvdW50IGZvciB0aGUgb3RoZXIgYG1vZGVsX291dHB1dHNgLlxuICAgICAgICAgICAgICAgIHRpbWVfb2Zmc2V0IC09IHN0cmlkZV9sZWZ0O1xuICAgICAgICAgICAgICAgIHJpZ2h0X3N0cmlkZV9zdGFydCA9IGNodW5rX2xlbiAtIHN0cmlkZV9yaWdodDtcblxuICAgICAgICAgICAgICAgIC8vIEtlZXBpbmcgdHJhY2sgb2YgdGltZXN0YW1wcyB3aXRoaW4gc3RyaWRlc1xuICAgICAgICAgICAgICAgIC8vIFdlJ3JlIGdvaW5nIHRvIE5PVCBzcGxpdCBvbiB0aG9zZSwgYW5kIGRlbGF5IHVudGlsIHdlJ3JlXG4gICAgICAgICAgICAgICAgLy8gb3V0IG9mIEJPVEggc3RyaWRlLiBPdGhlcndpc2UgbG90cyBvZiBpc3N1ZXMgb2NjdXIgYW5kXG4gICAgICAgICAgICAgICAgLy8gY29ybmVyIGNhc2VzXG4gICAgICAgICAgICAgICAgaWYgKHN0cmlkZV9sZWZ0KSB7XG4gICAgICAgICAgICAgICAgICAgIGZpcnN0X3RpbWVzdGFtcCA9IHN0cmlkZV9sZWZ0IC8gdGltZV9wcmVjaXNpb24gKyB0aW1lc3RhbXBfYmVnaW47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHN0cmlkZV9yaWdodCkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gdG9rZW5faWRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0b2tlbiA9IHRva2VuX2lkc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0b2tlbiA+PSB0aW1lc3RhbXBfYmVnaW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGVyZSBjYW4gYmUgc2V2ZXJhbCB0b2tlbiBpbiB0aGUgcmlnaHQgc3RyaWRlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQnV0IHRoZSBsYXN0IG9uZSBpcyBBTFdBWVMgZ29pbmcgdG8gYmUgc2tpcHBlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsYXN0X3RpbWVzdGFtcCAhPT0gbnVsbCAmJiAodG9rZW4gLSB0aW1lc3RhbXBfYmVnaW4pICogdGltZV9wcmVjaXNpb24gPCByaWdodF9zdHJpZGVfc3RhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RfdGltZXN0YW1wID0gdG9rZW47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxldCBjdXJyZW50X3Rva2VucyA9IFtdO1xuICAgICAgICAgICAgbGV0IGN1cnJlbnRfdG9rZW5fdGltZXN0YW1wcyA9IFtdO1xuXG4gICAgICAgICAgICAvLyAtIGFsbCB0b2tlbnMgd2l0aGluIG91dHB1dFxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0b2tlbl9pZHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0b2tlbiA9IHRva2VuX2lkc1tpXTtcbiAgICAgICAgICAgICAgICAvLyA0IHBvc3NpYmxlIHN0YXRlcyBmb3IgZWFjaCB0b2tlblxuICAgICAgICAgICAgICAgIC8vIC0gMS8gTGFuZ3VhZ2UgY29kZVxuICAgICAgICAgICAgICAgIC8vIC0gMi8gYWxsIG90aGVyIHNwZWNpYWwgdG9rZW5zICh3aGljaCB3ZSBpZ25vcmUpXG4gICAgICAgICAgICAgICAgLy8gLSAzLyBUaW1lc3RhbXBcbiAgICAgICAgICAgICAgICAvLyAtIDQvIFJlZ3VsYXIgdGV4dFxuXG4gICAgICAgICAgICAgICAgaWYgKGFsbF9zcGVjaWFsX2lkcy5oYXModG9rZW4pKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRleHQgPSB0aGlzLmRlY29kZShbdG9rZW5dKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRleHRbMF0gPT09IFwiW1wiICYmIHRleHRbdGV4dC5sZW5ndGggLSAxXSA9PT0gXCJdXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGxhbmd1YWdlID0gV0hJU1BFUl9MQU5HVUFHRV9NQVBQSU5HLmdldCh0ZXh0LnNsaWNlKDEsIC0xKSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsYW5ndWFnZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMS8gSW5kZWVkIHNvbWUgbGFuZ3VhZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPIEhhbmRsZSB3aGVuIGxhbmd1YWdlIGlzIGRpZmZlcmVudCBmcm9tIHRoZSBwcmV2aW91c1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9uZSwgYW5kIHdlIGNhbm5vdCB1c2UgdGltZXN0YW1wZWQgdG9rZW5zIHRvIGNyZWF0ZSBjaHVua3NcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobGFzdF9sYW5ndWFnZSAhPT0gbnVsbCAmJiBsYW5ndWFnZSAhPT0gbGFzdF9sYW5ndWFnZSAmJiAhcmV0dXJuX3RpbWVzdGFtcHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJldmlvdXNfdG9rZW5zLnB1c2goY3VycmVudF90b2tlbnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNvbHZlZF90b2tlbnMgPSB0aGlzLmZpbmRMb25nZXN0Q29tbW9uU2VxdWVuY2UocHJldmlvdXNfdG9rZW5zKVswXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzb2x2ZWRfdGV4dCA9IHRoaXMuZGVjb2RlKHJlc29sdmVkX3Rva2Vucyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNodW5rLnRleHQgPSByZXNvbHZlZF90ZXh0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaHVua3MucHVzaChjaHVuayk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRmx1c2ggYWxsIG91ciB0ZW1wb3JhcnkgY29udGV4dFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmV2aW91c190b2tlbnMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudF90b2tlbnMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2h1bmsgPSBuZXdfY2h1bmsoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0X2xhbmd1YWdlID0gY2h1bmsubGFuZ3VhZ2UgPSBsYW5ndWFnZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMi8gVGhpcyBpcyBhIHJlZ3VsYXIgc3BlY2lhbCB0b2tlbiwgaWdub3JpbmcgaXRcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodG9rZW4gPj0gdGltZXN0YW1wX2JlZ2luKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIDMvIFRpbWVzdGFtcCB0b2tlblxuICAgICAgICAgICAgICAgICAgICBjb25zdCB0aW1lID0gKHRva2VuIC0gdGltZXN0YW1wX2JlZ2luKSAqIHRpbWVfcHJlY2lzaW9uICsgdGltZV9vZmZzZXQ7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJvdW5kZWRfdGltZSA9IHJvdW5kKHRpbWUsIDIpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChsYXN0X3RpbWVzdGFtcCAhPT0gbnVsbCAmJiB0b2tlbiA+PSBsYXN0X3RpbWVzdGFtcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2hpc3BlciBvdXRwdXR0ZWQgYSB0aW1lc3RhbXAgdG9rZW4sIGJ1dCBpdCBmYWxscyB3aXRoaW5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG91ciBzdHJpZGUsIHNvIHdlJ3JlIGdvaW5nIHRvIHNraXAgaXQgZm9yIHRoZSB0aW1lIGJlaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhbmQgcmVzb2x2ZSB0aGlzIGxhdGVyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTa2lwIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHRpbWVzdGFtcCB0b2tlbnMgYWx3YXlzIGNvbWVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJ5IHBhaXIsIHNvIHdlIG5lZWQgdG8gc2tpcCB0aGUgbmV4dCBvbmUgdG9vICh3aGljaCB3b3VsZCBtYXJrIHRoZSBzdGFydCBvZiBhbm90aGVyIGNodW5rKS5cbiAgICAgICAgICAgICAgICAgICAgICAgIHNraXAgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHNraXAgfHwgKHByZXZpb3VzX3Rva2Vucy5sZW5ndGggPiAwICYmIHRva2VuIDwgZmlyc3RfdGltZXN0YW1wKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2tpcCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNodW5rLnRpbWVzdGFtcFswXSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2h1bmsudGltZXN0YW1wWzBdID0gcm91bmRlZF90aW1lO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBpcyB0aGUgZW5kIG9mIHRoZSB0aW1lc3RhbXAgY2h1bmtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyb3VuZGVkX3RpbWUgPT09IGNodW5rLnRpbWVzdGFtcFswXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgYSBidWcgaW4gdGltZXN0YW1wIHRva2VuIG91dHB1dFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdoZXJlIHdlJ3JlIHRha2luZyB0aGUgZHVwbGljYXRlIHRva2VuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYXMgYSBzdG9wIHdoZXJlIGl0IHNob3VsZCBiZSBhIHN0YXJ0LlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgYW4gaXNzdWUgaW4gdGhlIHVuZGVybHlpbmcgbW9kZWwgb3V0cHV0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTGV0J3MganVzdCBza2lwIGl0IHNvIGl0IGJlY29tZXMgZGUtZmFjdG9yIGEgc3RhcnQgYWdpblxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaHVuay50aW1lc3RhbXBbMV0gPSByb3VuZGVkX3RpbWU7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBIYW5kbGluZyBtZXJnZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmV2aW91c190b2tlbnMucHVzaChjdXJyZW50X3Rva2VucylcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXR1cm5Xb3JkVGltZXN0YW1wcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmV2aW91c190b2tlbl90aW1lc3RhbXBzLnB1c2goY3VycmVudF90b2tlbl90aW1lc3RhbXBzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgW3Jlc29sdmVkX3Rva2VucywgcmVzb2x2ZWRfdG9rZW5fdGltZXN0YW1wc10gPSB0aGlzLmZpbmRMb25nZXN0Q29tbW9uU2VxdWVuY2UoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXZpb3VzX3Rva2VucywgcHJldmlvdXNfdG9rZW5fdGltZXN0YW1wc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc29sdmVkX3RleHQgPSB0aGlzLmRlY29kZShyZXNvbHZlZF90b2tlbnMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2h1bmsudGV4dCA9IHJlc29sdmVkX3RleHRcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXR1cm5Xb3JkVGltZXN0YW1wcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaHVuay53b3JkcyA9IHRoaXMuY29sbGF0ZVdvcmRUaW1lc3RhbXBzKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZWRfdG9rZW5zLCByZXNvbHZlZF90b2tlbl90aW1lc3RhbXBzLCBsYXN0X2xhbmd1YWdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2h1bmtzLnB1c2goY2h1bmspXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBGbHVzaCBhbGwgb3VyIHRlbXBvcmFyeSBjb250ZXh0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJldmlvdXNfdG9rZW5zID0gW11cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50X3Rva2VucyA9IFtdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJldmlvdXNfdG9rZW5fdGltZXN0YW1wcyA9IFtdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudF90b2tlbl90aW1lc3RhbXBzID0gW11cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaHVuayA9IG5ld19jaHVuaygpXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIDQvIFJlZ3VsYXIgdG9rZW5cbiAgICAgICAgICAgICAgICAgICAgLy8gV2UganVzdCBhcHBlbmQgdG8gdGhlIGxpc3Qgb2YgYWxsIHRva2VucyBzbyB3ZSBjYW4gaGFuZGxlXG4gICAgICAgICAgICAgICAgICAgIC8vIG1lcmdlcyBsYXRlciBhbmQgZGVjb2RlIGludG8gdGV4dC5cbiAgICAgICAgICAgICAgICAgICAgY3VycmVudF90b2tlbnMucHVzaCh0b2tlbilcblxuICAgICAgICAgICAgICAgICAgICBpZiAocmV0dXJuV29yZFRpbWVzdGFtcHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBzdGFydF90aW1lID0gcm91bmQodG9rZW5fdGltZXN0YW1wc1tpXSArIHRpbWVfb2Zmc2V0LCAyKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGVuZF90aW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkgKyAxIDwgdG9rZW5fdGltZXN0YW1wcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmRfdGltZSA9IHJvdW5kKHRva2VuX3RpbWVzdGFtcHNbaSArIDFdICsgdGltZV9vZmZzZXQsIDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzaG91bGQgbmV2ZXIgaGFwcGVuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kX3RpbWUgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudF90b2tlbl90aW1lc3RhbXBzLnB1c2goW3N0YXJ0X3RpbWUsIGVuZF90aW1lXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCdzdHJpZGUnIGluIG91dHB1dCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IFtjaHVua19sZW4sIHN0cmlkZV9sZWZ0LCBzdHJpZGVfcmlnaHRdID0gb3V0cHV0LnN0cmlkZTtcbiAgICAgICAgICAgICAgICB0aW1lX29mZnNldCArPSBjaHVua19sZW4gLSBzdHJpZGVfcmlnaHRcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gTGVmdG92ZXIgdG9rZW5zXG4gICAgICAgICAgICBpZiAoY3VycmVudF90b2tlbnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHByZXZpb3VzX3Rva2Vucy5wdXNoKGN1cnJlbnRfdG9rZW5zKVxuICAgICAgICAgICAgICAgIGlmIChyZXR1cm5Xb3JkVGltZXN0YW1wcykge1xuICAgICAgICAgICAgICAgICAgICBwcmV2aW91c190b2tlbl90aW1lc3RhbXBzLnB1c2goY3VycmVudF90b2tlbl90aW1lc3RhbXBzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHByZXZpb3VzX3Rva2Vucy5ldmVyeShwID0+IHAubGVuZ3RoID09PSAwKSkge1xuICAgICAgICAgICAgICAgIC8vIEZsdXNoaW5nIHByZXZpb3VzIHRva2VucyAoRU5EKVwiXG4gICAgICAgICAgICAgICAgY2h1bmsgPSBuZXdfY2h1bmsoKVxuICAgICAgICAgICAgICAgIHByZXZpb3VzX3Rva2VucyA9IFtdXG4gICAgICAgICAgICAgICAgY3VycmVudF90b2tlbnMgPSBbXVxuICAgICAgICAgICAgICAgIHByZXZpb3VzX3Rva2VuX3RpbWVzdGFtcHMgPSBbXTtcbiAgICAgICAgICAgICAgICBjdXJyZW50X3Rva2VuX3RpbWVzdGFtcHMgPSBbXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHByZXZpb3VzX3Rva2Vucy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBpZiAoZm9yY2VfZnVsbF9zZXF1ZW5jZXMgJiYgcmV0dXJuX3RpbWVzdGFtcHMpIHtcbiAgICAgICAgICAgICAgICAvLyBMYXN0IHRva2VuIHNob3VsZCBhbHdheXMgYmUgdGltZXN0YW1wcywgc28gdGhlcmUgc2hvdWxkbid0IGJlXG4gICAgICAgICAgICAgICAgLy8gbGVmdG92ZXJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgIFwiV2hpc3BlciBkaWQgbm90IHByZWRpY3QgYW4gZW5kaW5nIHRpbWVzdGFtcCwgd2hpY2ggY2FuIGhhcHBlbiBpZiBhdWRpbyBpcyBjdXQgb2ZmIGluIHRoZSBtaWRkbGUgb2YgYSB3b3JkLiBcIiArXG4gICAgICAgICAgICAgICAgICAgIFwiQWxzbyBtYWtlIHN1cmUgV2hpc3BlclRpbWVTdGFtcExvZ2l0c1Byb2Nlc3NvciB3YXMgdXNlZCBkdXJpbmcgZ2VuZXJhdGlvbi5cIlxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEhhcHBlbnMgd2hlbiB3ZSBkb24ndCB1c2UgdGltZXN0YW1wc1xuICAgICAgICAgICAgY29uc3QgW3Jlc29sdmVkX3Rva2VucywgcmVzb2x2ZWRfdG9rZW5fdGltZXN0YW1wc10gPSB0aGlzLmZpbmRMb25nZXN0Q29tbW9uU2VxdWVuY2UocHJldmlvdXNfdG9rZW5zLCBwcmV2aW91c190b2tlbl90aW1lc3RhbXBzKTtcblxuICAgICAgICAgICAgLy8gRmx1c2hpbmcgcHJldmlvdXMgdG9rZW5zIChGSU5BTClcbiAgICAgICAgICAgIGNvbnN0IHJlc29sdmVkX3RleHQgPSB0aGlzLmRlY29kZShyZXNvbHZlZF90b2tlbnMpO1xuICAgICAgICAgICAgY2h1bmsudGV4dCA9IHJlc29sdmVkX3RleHQ7XG4gICAgICAgICAgICBpZiAocmV0dXJuV29yZFRpbWVzdGFtcHMpIHtcbiAgICAgICAgICAgICAgICBjaHVuay53b3JkcyA9IHRoaXMuY29sbGF0ZVdvcmRUaW1lc3RhbXBzKFxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlZF90b2tlbnMsIHJlc29sdmVkX3Rva2VuX3RpbWVzdGFtcHMsIGxhc3RfbGFuZ3VhZ2UsXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2h1bmtzLnB1c2goY2h1bmspO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IG9wdGlvbmFsID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICAgICAgICAvLyBQcmVwYXJpbmcgYW5kIGNsZWFuaW5nIHVwIHRoZSBwaXBlbGluZSBvdXRwdXRcbiAgICAgICAgY29uc3QgZnVsbF90ZXh0ID0gY2h1bmtzLm1hcChjaHVuayA9PiBjaHVuay50ZXh0KS5qb2luKCcnKTtcbiAgICAgICAgaWYgKHJldHVybl90aW1lc3RhbXBzIHx8IHJldHVybl9sYW5ndWFnZSkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaHVua3MubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjaHVuayA9IGNodW5rc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoIXJldHVybl90aW1lc3RhbXBzKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBjaHVua1tcInRpbWVzdGFtcFwiXTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIXJldHVybl9sYW5ndWFnZSkge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgY2h1bmtbXCJsYW5ndWFnZVwiXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmV0dXJuV29yZFRpbWVzdGFtcHMpIHtcbiAgICAgICAgICAgICAgICBsZXQgbmV3X2NodW5rcyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGNodW5rIG9mIGNodW5rcykge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCB3b3JkIG9mIGNodW5rLndvcmRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdfY2h1bmtzLnB1c2god29yZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb3B0aW9uYWwgPSB7IFwiY2h1bmtzXCI6IG5ld19jaHVua3MgfTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgb3B0aW9uYWwgPSB7IFwiY2h1bmtzXCI6IGNodW5rcyB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbZnVsbF90ZXh0LCBvcHRpb25hbF07XG5cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGaW5kcyB0aGUgbG9uZ2VzdCBjb21tb24gc2VxdWVuY2UgYW1vbmcgdGhlIHByb3ZpZGVkIHNlcXVlbmNlcy5cbiAgICAgKiBAcGFyYW0ge251bWJlcltdW119IHNlcXVlbmNlcyBBbiBhcnJheSBvZiBzZXF1ZW5jZXMgb2YgdG9rZW4gaWRzIHRvIGNvbXBhcmUuXG4gICAgICogQHJldHVybnMge251bWJlcltdW119IFRoZSBsb25nZXN0IGNvbW1vbiBzZXF1ZW5jZSBmb3VuZC5cbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlcmUgaXMgYSBidWcgd2l0aGluIHRoZSBmdW5jdGlvbi5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGZpbmRMb25nZXN0Q29tbW9uU2VxdWVuY2Uoc2VxdWVuY2VzLCB0b2tlbl90aW1lc3RhbXBfc2VxdWVuY2VzID0gbnVsbCkge1xuICAgICAgICAvLyBJdCB3b3VsZCBiZSBtdWNoIGhhcmRlciB0byBkbyBPKG4pIGJlY2F1c2Ugb2YgZmF1bHQgdG9sZXJhbmNlLlxuICAgICAgICAvLyBXZSBhY3R1YWxseSBoYXZlIGEgcmVhbGx5IGdvb2QgcHJvcGVydHkgd2hpY2ggaXMgdGhhdCB0aGUgdG90YWwgc2VxdWVuY2VcbiAgICAgICAgLy8gTVVTVCBiZSB0aG9zZSBzdWJzZXF1ZW5jZXMgaW4gb3JkZXIuXG4gICAgICAgIC8vIElmIHRva2VuX3RpbWVzdGFtcF9zZXF1ZW5jZXMgaXMgcHJvdmlkZWQsIHdpbGwgc3BsaXQgdGhvc2Ugc2VxdWVuY2VzIGluXG4gICAgICAgIC8vIGV4YWN0bHkgdGhlIHNhbWUgd2F5LlxuICAgICAgICBsZXQgbGVmdFNlcXVlbmNlID0gc2VxdWVuY2VzWzBdO1xuICAgICAgICBsZXQgbGVmdExlbmd0aCA9IGxlZnRTZXF1ZW5jZS5sZW5ndGg7XG4gICAgICAgIGxldCB0b3RhbFNlcXVlbmNlID0gW107XG5cbiAgICAgICAgY29uc3QgdXNlX3Rva2VuX3RpbWVzdGFtcF9zZXF1ZW5jZXMgPSBBcnJheS5pc0FycmF5KHRva2VuX3RpbWVzdGFtcF9zZXF1ZW5jZXMpICYmIHRva2VuX3RpbWVzdGFtcF9zZXF1ZW5jZXMubGVuZ3RoID4gMDtcbiAgICAgICAgbGV0IHRvdGFsX3Rva2VuX3RpbWVzdGFtcF9zZXF1ZW5jZSA9IHVzZV90b2tlbl90aW1lc3RhbXBfc2VxdWVuY2VzID8gW10gOiBudWxsO1xuICAgICAgICBsZXQgbGVmdF90b2tlbl90aW1lc3RhbXBfc2VxdWVuY2UgPSB1c2VfdG9rZW5fdGltZXN0YW1wX3NlcXVlbmNlcyA/IHRva2VuX3RpbWVzdGFtcF9zZXF1ZW5jZXNbMF0gOiBudWxsO1xuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHNlcXVlbmNlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgY29uc3QgcmlnaHRTZXF1ZW5jZSA9IHNlcXVlbmNlc1tpXTtcbiAgICAgICAgICAgIGxldCBtYXggPSAwLjA7XG4gICAgICAgICAgICBsZXQgbWF4SW5kaWNlcyA9IFtsZWZ0TGVuZ3RoLCBsZWZ0TGVuZ3RoLCAwLCAwXTtcbiAgICAgICAgICAgIC8vIEhlcmUgd2UncmUgc2xpZGluZyBtYXRjaGVzXG4gICAgICAgICAgICAvLyBbYSwgYiwgYywgZF1cbiAgICAgICAgICAgIC8vICAgICAgICAgIFtjLCBkLCBmXVxuICAgICAgICAgICAgLy8gPSAgICAgICAgW2NdID09IFtkXVxuXG4gICAgICAgICAgICAvLyBbYSwgYiwgYywgZF1cbiAgICAgICAgICAgIC8vICAgICAgIFtjLCBkLCBmXVxuICAgICAgICAgICAgLy8gPSAgICAgW2MsIGRdID09IFtjLCBkXVxuXG5cbiAgICAgICAgICAgIC8vIFthLCBiLCBjLCBkXVxuICAgICAgICAgICAgLy8gICAgW2MsIGQsIGZdXG5cbiAgICAgICAgICAgIC8vID0gIFtiLCBjLCBkXSA9PSBbYywgZCwgZl1cblxuICAgICAgICAgICAgLy8gW2EsIGIsIGMsIGRdXG4gICAgICAgICAgICAvLyBbYywgZCwgZl1cblxuICAgICAgICAgICAgLy8gW2EsIGIsIGNdID09IFtjLCBkLCBmXVxuXG4gICAgICAgICAgICAvLyBbYSwgYiwgYywgZF1cbiAgICAgICAgICAgIC8vIFtkLCBmXVxuXG4gICAgICAgICAgICAvLyBbYSwgYl0gPT0gW2QsIGZdXG5cbiAgICAgICAgICAgIC8vIFthLCBiLCBjLCBkXVxuICAgICAgICAgICAgLy8gW2ZdXG5cbiAgICAgICAgICAgIC8vIFthXSA9PSBbZl1cblxuICAgICAgICAgICAgY29uc3QgcmlnaHRMZW5ndGggPSByaWdodFNlcXVlbmNlLmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAxOyBqIDwgbGVmdExlbmd0aCArIHJpZ2h0TGVuZ3RoOyArK2opIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlcHMgPSBqIC8gMTAwMDAuMDtcbiAgICAgICAgICAgICAgICBjb25zdCBsZWZ0U3RhcnQgPSBNYXRoLm1heCgwLCBsZWZ0TGVuZ3RoIC0gaik7XG4gICAgICAgICAgICAgICAgY29uc3QgbGVmdFN0b3AgPSBNYXRoLm1pbihsZWZ0TGVuZ3RoLCBsZWZ0TGVuZ3RoICsgcmlnaHRMZW5ndGggLSBqKTtcbiAgICAgICAgICAgICAgICBjb25zdCBsZWZ0ID0gbGVmdFNlcXVlbmNlLnNsaWNlKGxlZnRTdGFydCwgbGVmdFN0b3ApO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJpZ2h0U3RhcnQgPSBNYXRoLm1heCgwLCBqIC0gbGVmdExlbmd0aCk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmlnaHRTdG9wID0gTWF0aC5taW4ocmlnaHRMZW5ndGgsIGopO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJpZ2h0ID0gcmlnaHRTZXF1ZW5jZS5zbGljZShyaWdodFN0YXJ0LCByaWdodFN0b3ApO1xuICAgICAgICAgICAgICAgIGlmIChsZWZ0Lmxlbmd0aCAhPT0gcmlnaHQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZXJlIGlzIGEgYnVnIHdpdGhpbiB3aGlzcGVyIGBkZWNvZGVfYXNyYCBmdW5jdGlvbiwgcGxlYXNlIHJlcG9ydCBpdC4gRHJvcHBpbmcgdG8gcHJldmVudCBiYWQgaW5mZXJlbmNlLlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgbWF0Y2hlcyA9IGxlZnQuZmlsdGVyKChlbGVtLCBpZHgpID0+IGVsZW0gPT09IHJpZ2h0W2lkeF0pLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBjb25zdCBtYXRjaGluZyA9IG1hdGNoZXMgLyBqICsgZXBzO1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaGVzID4gMSAmJiBtYXRjaGluZyA+IG1heCkge1xuICAgICAgICAgICAgICAgICAgICBtYXggPSBtYXRjaGluZztcbiAgICAgICAgICAgICAgICAgICAgbWF4SW5kaWNlcyA9IFtsZWZ0U3RhcnQsIGxlZnRTdG9wLCByaWdodFN0YXJ0LCByaWdodFN0b3BdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IFtsZWZ0U3RhcnQsIGxlZnRTdG9wLCByaWdodFN0YXJ0LCByaWdodFN0b3BdID0gbWF4SW5kaWNlcztcbiAgICAgICAgICAgIGNvbnN0IGxlZnRNaWQgPSBNYXRoLmZsb29yKChsZWZ0U3RvcCArIGxlZnRTdGFydCkgLyAyKTtcbiAgICAgICAgICAgIGNvbnN0IHJpZ2h0TWlkID0gTWF0aC5mbG9vcigocmlnaHRTdG9wICsgcmlnaHRTdGFydCkgLyAyKTtcbiAgICAgICAgICAgIHRvdGFsU2VxdWVuY2UucHVzaCguLi5sZWZ0U2VxdWVuY2Uuc2xpY2UoMCwgbGVmdE1pZCkpO1xuICAgICAgICAgICAgbGVmdFNlcXVlbmNlID0gcmlnaHRTZXF1ZW5jZS5zbGljZShyaWdodE1pZCk7XG4gICAgICAgICAgICBsZWZ0TGVuZ3RoID0gbGVmdFNlcXVlbmNlLmxlbmd0aDtcblxuICAgICAgICAgICAgaWYgKHVzZV90b2tlbl90aW1lc3RhbXBfc2VxdWVuY2VzKSB7XG4gICAgICAgICAgICAgICAgdG90YWxfdG9rZW5fdGltZXN0YW1wX3NlcXVlbmNlLnB1c2goLi4ubGVmdF90b2tlbl90aW1lc3RhbXBfc2VxdWVuY2Uuc2xpY2UoMCwgbGVmdE1pZCkpO1xuICAgICAgICAgICAgICAgIGxlZnRfdG9rZW5fdGltZXN0YW1wX3NlcXVlbmNlID0gdG9rZW5fdGltZXN0YW1wX3NlcXVlbmNlc1tpXS5zbGljZShyaWdodE1pZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdG90YWxTZXF1ZW5jZS5wdXNoKC4uLmxlZnRTZXF1ZW5jZSk7XG5cbiAgICAgICAgaWYgKHVzZV90b2tlbl90aW1lc3RhbXBfc2VxdWVuY2VzKSB7XG4gICAgICAgICAgICB0b3RhbF90b2tlbl90aW1lc3RhbXBfc2VxdWVuY2UucHVzaCguLi5sZWZ0X3Rva2VuX3RpbWVzdGFtcF9zZXF1ZW5jZSk7XG4gICAgICAgICAgICByZXR1cm4gW3RvdGFsU2VxdWVuY2UsIHRvdGFsX3Rva2VuX3RpbWVzdGFtcF9zZXF1ZW5jZV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gW3RvdGFsU2VxdWVuY2UsIFtdXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKiBAcHJpdmF0ZSAqL1xuICAgIGNvbGxhdGVXb3JkVGltZXN0YW1wcyh0b2tlbnMsIHRva2VuX3RpbWVzdGFtcHMsIGxhbmd1YWdlKSB7XG5cbiAgICAgICAgbGV0IFt3b3JkcywgXywgdG9rZW5faW5kaWNlc10gPSB0aGlzLmNvbWJpbmVUb2tlbnNJbnRvV29yZHModG9rZW5zLCBsYW5ndWFnZSk7XG5cbiAgICAgICAgbGV0IHRpbWluZ3MgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB3b3Jkcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgY29uc3QgaW5kaWNlcyA9IHRva2VuX2luZGljZXNbaV07XG4gICAgICAgICAgICB0aW1pbmdzLnB1c2goe1xuICAgICAgICAgICAgICAgIHRleHQ6IHdvcmRzW2ldLFxuICAgICAgICAgICAgICAgIHRpbWVzdGFtcDogW1xuICAgICAgICAgICAgICAgICAgICB0b2tlbl90aW1lc3RhbXBzW2luZGljZXMuYXQoMCldWzBdLFxuICAgICAgICAgICAgICAgICAgICB0b2tlbl90aW1lc3RhbXBzW2luZGljZXMuYXQoLTEpXVsxXSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRpbWluZ3M7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR3JvdXBzIHRva2VucyBieSB3b3JkLiBSZXR1cm5zIGEgdHVwbGUgY29udGFpbmluZyBhIGxpc3Qgb2Ygc3RyaW5ncyB3aXRoIHRoZSB3b3JkcyxcbiAgICAgKiBhbmQgYSBsaXN0IG9mIGB0b2tlbl9pZGAgc2VxdWVuY2VzIHdpdGggdGhlIHRva2VucyBtYWtpbmcgdXAgZWFjaCB3b3JkLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyW119IHRva2VucyBcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2xhbmd1YWdlXSBcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJlcGVuZF9wdW5jdGlvbmF0aW9ucyBcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYXBwZW5kX3B1bmN0dWF0aW9ucyBcbiAgICAgKiBcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGNvbWJpbmVUb2tlbnNJbnRvV29yZHModG9rZW5zLCBsYW5ndWFnZSwgcHJlcGVuZF9wdW5jdGlvbmF0aW9ucyA9IFwiXFxcIifigJzCocK/KFt7LVwiLCBhcHBlbmRfcHVuY3R1YXRpb25zID0gXCJcXFwiJy7jgIIs77yMIe+8gT/vvJ8677ya4oCdKV1944CBXCIpIHtcbiAgICAgICAgbGFuZ3VhZ2UgPSBsYW5ndWFnZSA/PyAnZW5nbGlzaCc7XG5cbiAgICAgICAgbGV0IHdvcmRzLCB3b3JkX3Rva2VucywgdG9rZW5faW5kaWNlcztcblxuICAgICAgICBpZiAoW1wiY2hpbmVzZVwiLCBcImphcGFuZXNlXCIsIFwidGhhaVwiLCBcImxhb1wiLCBcIm15YW5tYXJcIl0uaW5jbHVkZXMobGFuZ3VhZ2UpKSB7XG4gICAgICAgICAgICAvLyBUaGVzZSBsYW5ndWFnZXMgZG9uJ3QgdHlwaWNhbGx5IHVzZSBzcGFjZXMuXG5cbiAgICAgICAgICAgIFt3b3Jkcywgd29yZF90b2tlbnMsIHRva2VuX2luZGljZXNdID0gdGhpcy5zcGxpdFRva2Vuc09uVW5pY29kZSh0b2tlbnMpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBbd29yZHMsIHdvcmRfdG9rZW5zLCB0b2tlbl9pbmRpY2VzXSA9IHRoaXMuc3BsaXRUb2tlbnNPblNwYWNlcyh0b2tlbnMpXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5tZXJnZVB1bmN0dWF0aW9ucyh3b3Jkcywgd29yZF90b2tlbnMsIHRva2VuX2luZGljZXMsIHByZXBlbmRfcHVuY3Rpb25hdGlvbnMsIGFwcGVuZF9wdW5jdHVhdGlvbnMpO1xuICAgIH1cblxuICAgIC8qKiBAdHlwZSB7UHJlVHJhaW5lZFRva2VuaXplclsnZGVjb2RlJ119ICovXG4gICAgZGVjb2RlKFxuICAgICAgICB0b2tlbl9pZHMsXG4gICAgICAgIGRlY29kZV9hcmdzLFxuICAgICkge1xuICAgICAgICBsZXQgdGV4dDtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBpZiAoZGVjb2RlX2FyZ3MgJiYgZGVjb2RlX2FyZ3MuZGVjb2RlX3dpdGhfdGltZXN0YW1wcykge1xuICAgICAgICAgICAgdGV4dCA9IHRoaXMuZGVjb2RlV2l0aFRpbWVzdGFtcHModG9rZW5faWRzLCBkZWNvZGVfYXJncyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0ZXh0ID0gc3VwZXIuZGVjb2RlKHRva2VuX2lkcywgZGVjb2RlX2FyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRPRE86IGltcGxlbWVudCBvZmZzZXRzXG4gICAgICAgIC8vIGlmIChkZWNvZGVfYXJncy5vdXRwdXRfb2Zmc2V0cykge1xuICAgICAgICAvLyAgICAgbGV0IG9mZnNldHMgPSB0aGlzLmNvbXB1dGVPZmZzZXRzXG4gICAgICAgIC8vIH1cbiAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtudW1iZXJbXX0gdG9rZW5faWRzIExpc3Qgb2YgdG9rZW4gSURzIHRvIGRlY29kZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGVjb2RlX2FyZ3MgT3B0aW9uYWwgYXJndW1lbnRzIGZvciBkZWNvZGluZ1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZGVjb2RlV2l0aFRpbWVzdGFtcHModG9rZW5faWRzLCBkZWNvZGVfYXJncykge1xuICAgICAgICBjb25zdCB0aW1lX3ByZWNpc2lvbiA9IGRlY29kZV9hcmdzPy50aW1lX3ByZWNpc2lvbiA/PyAwLjAyO1xuXG4gICAgICAgIGNvbnN0IHRpbWVzdGFtcF9iZWdpbiA9IEFycmF5LmZyb20odGhpcy5hbGxfc3BlY2lhbF9pZHMpLmF0KC0xKSArIDE7XG4gICAgICAgIC8qKkB0eXBlIHtBcnJheX0gKi9cbiAgICAgICAgbGV0IG91dHB1dHMgPSBbW11dO1xuICAgICAgICBmb3IgKGxldCB0b2tlbiBvZiB0b2tlbl9pZHMpIHtcbiAgICAgICAgICAgIGlmICh0b2tlbiA+PSB0aW1lc3RhbXBfYmVnaW4pIHtcbiAgICAgICAgICAgICAgICBsZXQgdGltZXN0YW1wID0gKHRva2VuIC0gdGltZXN0YW1wX2JlZ2luKSAqIHRpbWVfcHJlY2lzaW9uO1xuICAgICAgICAgICAgICAgIHRpbWVzdGFtcCA9IHJvdW5kKHRpbWVzdGFtcCwgMik7XG4gICAgICAgICAgICAgICAgb3V0cHV0cy5wdXNoKGA8fCR7dGltZXN0YW1wfXw+YCk7XG4gICAgICAgICAgICAgICAgb3V0cHV0cy5wdXNoKFtdKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0c1tvdXRwdXRzLmxlbmd0aCAtIDFdLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG91dHB1dHMgPSBvdXRwdXRzLm1hcChcbiAgICAgICAgICAgIHMgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHM7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN1cGVyLmRlY29kZShzLCBkZWNvZGVfYXJncyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICApXG5cbiAgICAgICAgcmV0dXJuIG91dHB1dHMuam9pbignJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29tYmluZSB0b2tlbnMgaW50byB3b3JkcyBieSBzcGxpdHRpbmcgYXQgYW55IHBvc2l0aW9uIHdoZXJlIHRoZSB0b2tlbnMgYXJlIGRlY29kZWQgYXMgdmFsaWQgdW5pY29kZSBwb2ludHMuXG4gICAgICogQHBhcmFtIHtudW1iZXJbXX0gdG9rZW5zIFxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgc3BsaXRUb2tlbnNPblVuaWNvZGUodG9rZW5zKSB7XG4gICAgICAgIGNvbnN0IGRlY29kZWRfZnVsbCA9IHRoaXMuZGVjb2RlKHRva2Vucywge1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgZGVjb2RlX3dpdGhfdGltZXN0YW1wczogdHJ1ZSxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHJlcGxhY2VtZW50X2NoYXIgPSAnXFx1RkZGRCc7XG5cbiAgICAgICAgbGV0IHdvcmRzID0gW11cbiAgICAgICAgbGV0IHdvcmRfdG9rZW5zID0gW11cbiAgICAgICAgbGV0IHRva2VuX2luZGljZXMgPSBbXVxuICAgICAgICBsZXQgY3VycmVudF90b2tlbnMgPSBbXVxuICAgICAgICBsZXQgY3VycmVudF9pbmRpY2VzID0gW11cbiAgICAgICAgbGV0IHVuaWNvZGVfb2Zmc2V0ID0gMFxuXG4gICAgICAgIGZvciAobGV0IHRva2VuX2lkeCA9IDA7IHRva2VuX2lkeCA8IHRva2Vucy5sZW5ndGg7ICsrdG9rZW5faWR4KSB7XG4gICAgICAgICAgICBjb25zdCB0b2tlbiA9IHRva2Vuc1t0b2tlbl9pZHhdO1xuXG4gICAgICAgICAgICBjdXJyZW50X3Rva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgIGN1cnJlbnRfaW5kaWNlcy5wdXNoKHRva2VuX2lkeCk7XG5cbiAgICAgICAgICAgIGNvbnN0IGRlY29kZWQgPSB0aGlzLmRlY29kZShjdXJyZW50X3Rva2Vucywge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICBkZWNvZGVfd2l0aF90aW1lc3RhbXBzOiB0cnVlLFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmICghZGVjb2RlZC5pbmNsdWRlcyhyZXBsYWNlbWVudF9jaGFyKSB8fCBkZWNvZGVkX2Z1bGxbdW5pY29kZV9vZmZzZXQgKyBkZWNvZGVkLmluZGV4T2YocmVwbGFjZW1lbnRfY2hhcildID09PSByZXBsYWNlbWVudF9jaGFyKSB7XG4gICAgICAgICAgICAgICAgd29yZHMucHVzaChkZWNvZGVkKVxuICAgICAgICAgICAgICAgIHdvcmRfdG9rZW5zLnB1c2goY3VycmVudF90b2tlbnMpXG4gICAgICAgICAgICAgICAgdG9rZW5faW5kaWNlcy5wdXNoKGN1cnJlbnRfaW5kaWNlcylcbiAgICAgICAgICAgICAgICBjdXJyZW50X3Rva2VucyA9IFtdXG4gICAgICAgICAgICAgICAgY3VycmVudF9pbmRpY2VzID0gW11cbiAgICAgICAgICAgICAgICB1bmljb2RlX29mZnNldCArPSBkZWNvZGVkLmxlbmd0aDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFt3b3Jkcywgd29yZF90b2tlbnMsIHRva2VuX2luZGljZXNdXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29tYmluZSB0b2tlbnMgaW50byB3b3JkcyBieSBzcGxpdHRpbmcgYXQgd2hpdGVzcGFjZSBhbmQgcHVuY3R1YXRpb24gdG9rZW5zLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyW119IHRva2VucyBcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHNwbGl0VG9rZW5zT25TcGFjZXModG9rZW5zKSB7XG5cbiAgICAgICAgbGV0IFtzdWJ3b3Jkcywgc3Vid29yZF90b2tlbnNfbGlzdCwgc3Vid29yZF9pbmRpY2VzX2xpc3RdID0gdGhpcy5zcGxpdFRva2Vuc09uVW5pY29kZSh0b2tlbnMpO1xuXG4gICAgICAgIGxldCB3b3JkcyA9IFtdXG4gICAgICAgIGxldCB3b3JkX3Rva2VucyA9IFtdXG4gICAgICAgIGxldCB0b2tlbl9pbmRpY2VzID0gW11cblxuICAgICAgICBjb25zdCBwdW5jdHVhdGlvblJlZ2V4ID0gbmV3IFJlZ0V4cChgWyR7UFVOQ1RVQVRJT05fUkVHRVh9XWApXG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdWJ3b3Jkcy5sZW5ndGg7ICsraSkge1xuXG4gICAgICAgICAgICBjb25zdCBzdWJ3b3JkID0gc3Vid29yZHNbaV07XG4gICAgICAgICAgICBjb25zdCBzdWJ3b3JkX3Rva2VucyA9IHN1YndvcmRfdG9rZW5zX2xpc3RbaV07XG4gICAgICAgICAgICBjb25zdCBzdWJ3b3JkX2luZGljZXMgPSBzdWJ3b3JkX2luZGljZXNfbGlzdFtpXTtcblxuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgY29uc3Qgc3BlY2lhbCA9IHN1YndvcmRfdG9rZW5zWzBdID49IHRoaXMubW9kZWwudG9rZW5zX3RvX2lkcy5nZXQoJzx8ZW5kb2Z0ZXh0fD4nKTtcbiAgICAgICAgICAgIGNvbnN0IHdpdGhfc3BhY2UgPSBzdWJ3b3JkLnN0YXJ0c1dpdGgoJyAnKTtcbiAgICAgICAgICAgIGNvbnN0IHRyaW1tZWQgPSBzdWJ3b3JkLnRyaW0oKTtcbiAgICAgICAgICAgIGNvbnN0IHB1bmN0dWF0aW9uID0gcHVuY3R1YXRpb25SZWdleC50ZXN0KHRyaW1tZWQpO1xuXG4gICAgICAgICAgICBpZiAoc3BlY2lhbCB8fCB3aXRoX3NwYWNlIHx8IHB1bmN0dWF0aW9uIHx8IHdvcmRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHdvcmRzLnB1c2goc3Vid29yZCk7XG4gICAgICAgICAgICAgICAgd29yZF90b2tlbnMucHVzaChzdWJ3b3JkX3Rva2Vucyk7XG4gICAgICAgICAgICAgICAgdG9rZW5faW5kaWNlcy5wdXNoKHN1YndvcmRfaW5kaWNlcyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IGl4ID0gd29yZHMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgICB3b3Jkc1tpeF0gKz0gc3Vid29yZDtcbiAgICAgICAgICAgICAgICB3b3JkX3Rva2Vuc1tpeF0ucHVzaCguLi5zdWJ3b3JkX3Rva2Vucyk7XG4gICAgICAgICAgICAgICAgdG9rZW5faW5kaWNlc1tpeF0ucHVzaCguLi5zdWJ3b3JkX2luZGljZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFt3b3Jkcywgd29yZF90b2tlbnMsIHRva2VuX2luZGljZXNdO1xuXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWVyZ2VzIHB1bmN0dWF0aW9uIHRva2VucyB3aXRoIG5laWdoYm9yaW5nIHdvcmRzLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IHdvcmRzIFxuICAgICAqIEBwYXJhbSB7bnVtYmVyW11bXX0gdG9rZW5zIFxuICAgICAqIEBwYXJhbSB7bnVtYmVyW11bXX0gaW5kaWNlcyBcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJlcGVuZGVkIFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhcHBlbmRlZCBcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIG1lcmdlUHVuY3R1YXRpb25zKHdvcmRzLCB0b2tlbnMsIGluZGljZXMsIHByZXBlbmRlZCwgYXBwZW5kZWQpIHtcblxuICAgICAgICBsZXQgbmV3V29yZHMgPSBzdHJ1Y3R1cmVkQ2xvbmUod29yZHMpO1xuICAgICAgICBsZXQgbmV3VG9rZW5zID0gc3RydWN0dXJlZENsb25lKHRva2Vucyk7XG4gICAgICAgIGxldCBuZXdJbmRpY2VzID0gc3RydWN0dXJlZENsb25lKGluZGljZXMpO1xuXG5cbiAgICAgICAgLy8gcHJlcGVuZCBwdW5jdHVhdGlvbnNcbiAgICAgICAgbGV0IGkgPSBuZXdXb3Jkcy5sZW5ndGggLSAyO1xuICAgICAgICBsZXQgaiA9IG5ld1dvcmRzLmxlbmd0aCAtIDE7XG5cbiAgICAgICAgd2hpbGUgKGkgPj0gMCkge1xuICAgICAgICAgICAgaWYgKG5ld1dvcmRzW2ldLnN0YXJ0c1dpdGgoJyAnKSAmJiBwcmVwZW5kZWQuaW5jbHVkZXMobmV3V29yZHNbaV0udHJpbSgpKSkge1xuICAgICAgICAgICAgICAgIG5ld1dvcmRzW2pdID0gbmV3V29yZHNbaV0gKyBuZXdXb3Jkc1tqXTtcbiAgICAgICAgICAgICAgICBuZXdUb2tlbnNbal0gPSBtZXJnZUFycmF5cyhuZXdUb2tlbnNbaV0sIG5ld1Rva2Vuc1tqXSk7XG4gICAgICAgICAgICAgICAgbmV3SW5kaWNlc1tqXSA9IG1lcmdlQXJyYXlzKG5ld0luZGljZXNbaV0sIG5ld0luZGljZXNbal0pO1xuICAgICAgICAgICAgICAgIG5ld1dvcmRzW2ldID0gJyc7XG4gICAgICAgICAgICAgICAgbmV3VG9rZW5zW2ldID0gW107XG4gICAgICAgICAgICAgICAgbmV3SW5kaWNlc1tpXSA9IFtdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBqID0gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC0taTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFwcGVuZCBwdW5jdHVhdGlvbnNcbiAgICAgICAgaSA9IDA7XG4gICAgICAgIGogPSAxO1xuICAgICAgICB3aGlsZSAoaiA8IG5ld1dvcmRzLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKCFuZXdXb3Jkc1tpXS5lbmRzV2l0aCgnICcpICYmIGFwcGVuZGVkLmluY2x1ZGVzKG5ld1dvcmRzW2pdKSkge1xuICAgICAgICAgICAgICAgIG5ld1dvcmRzW2ldICs9IG5ld1dvcmRzW2pdO1xuICAgICAgICAgICAgICAgIG5ld1Rva2Vuc1tpXSA9IG1lcmdlQXJyYXlzKG5ld1Rva2Vuc1tpXSwgbmV3VG9rZW5zW2pdKTtcbiAgICAgICAgICAgICAgICBuZXdJbmRpY2VzW2ldID0gbWVyZ2VBcnJheXMobmV3SW5kaWNlc1tpXSwgbmV3SW5kaWNlc1tqXSk7XG4gICAgICAgICAgICAgICAgbmV3V29yZHNbal0gPSAnJztcbiAgICAgICAgICAgICAgICBuZXdUb2tlbnNbal0gPSBbXTtcbiAgICAgICAgICAgICAgICBuZXdJbmRpY2VzW2pdID0gW107XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGkgPSBqO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKytqO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIG5ld1dvcmRzLmZpbHRlcih4ID0+IHgpLFxuICAgICAgICAgICAgbmV3VG9rZW5zLmZpbHRlcih4ID0+IHgubGVuZ3RoID4gMCksXG4gICAgICAgICAgICBuZXdJbmRpY2VzLmZpbHRlcih4ID0+IHgubGVuZ3RoID4gMCksXG4gICAgICAgIF1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIZWxwZXIgZnVuY3Rpb24gdG8gYnVpbGQgdHJhbnNsYXRpb24gaW5wdXRzIGZvciBhIGBXaGlzcGVyVG9rZW5pemVyYCxcbiAgICAgKiBkZXBlbmRpbmcgb24gdGhlIGxhbmd1YWdlLCB0YXNrLCBhbmQgd2hldGhlciB0byBwcmVkaWN0IHRpbWVzdGFtcCB0b2tlbnMuXG4gICAgICogXG4gICAgICogVXNlZCB0byBvdmVycmlkZSB0aGUgcHJlZml4IHRva2VucyBhcHBlbmRlZCB0byB0aGUgc3RhcnQgb2YgdGhlIGxhYmVsIHNlcXVlbmNlLlxuICAgICAqIFxuICAgICAqICoqRXhhbXBsZTogR2V0IGlkcyBmb3IgYSBsYW5ndWFnZSoqXG4gICAgICogYGBgamF2YXNjcmlwdFxuICAgICAqIC8vIGluc3RhbnRpYXRlIHRoZSB0b2tlbml6ZXIgYW5kIHNldCB0aGUgcHJlZml4IHRva2VuIHRvIFNwYW5pc2hcbiAgICAgKiBsZXQgdG9rZW5pemVyID0gYXdhaXQgV2hpc3BlclRva2VuaXplci5mcm9tX3ByZXRyYWluZWQoJ1hlbm92YS93aGlzcGVyLXRpbnknKTtcbiAgICAgKiBsZXQgZm9yY2VkX2RlY29kZXJfaWRzID0gdG9rZW5pemVyLmdldF9kZWNvZGVyX3Byb21wdF9pZHMoeyBsYW5ndWFnZTogJ3NwYW5pc2gnIH0pO1xuICAgICAqIC8vIFsoMSwgNTAyNjIpLCAoMiwgNTAzNjMpXVxuICAgICAqIGBgYFxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIE9wdGlvbnMgdG8gZ2VuZXJhdGUgdGhlIGRlY29kZXIgcHJvbXB0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5sYW5ndWFnZV0gVGhlIGxhbmd1YWdlIG9mIHRoZSB0cmFuc2NyaXB0aW9uIHRleHQuXG4gICAgICogVGhlIGNvcnJlc3BvbmRpbmcgbGFuZ3VhZ2UgaWQgdG9rZW4gaXMgYXBwZW5kZWQgdG8gdGhlIHN0YXJ0IG9mIHRoZSBzZXF1ZW5jZSBmb3IgbXVsdGlsaW5ndWFsXG4gICAgICogc3BlZWNoIHJlY29nbml0aW9uIGFuZCBzcGVlY2ggdHJhbnNsYXRpb24gdGFza3MsIGUuZy4gZm9yIFwiU3BhbmlzaFwiIHRoZSB0b2tlbiBcIjx8ZXN8PlwiIGlzIGFwcGVuZGVkXG4gICAgICogdG8gdGhlIHN0YXJ0IG9mIHNlcXVlbmNlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy50YXNrXSBUYXNrIGlkZW50aWZpZXIgdG8gYXBwZW5kIGF0IHRoZSBzdGFydCBvZiBzZXF1ZW5jZSAoaWYgYW55KS5cbiAgICAgKiBUaGlzIHNob3VsZCBiZSB1c2VkIGZvciBtdWxpdGxpbmd1YWwgZmluZS10dW5pbmcsIHdpdGggXCJ0cmFuc2NyaWJlXCIgZm9yIHNwZWVjaCByZWNvZ25pdGlvbiBhbmRcbiAgICAgKiBcInRyYW5zbGF0ZVwiIGZvciBzcGVlY2ggdHJhbnNsYXRpb24uXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5ub190aW1lc3RhbXBzXSBXaGV0aGVyIHRvIGFkZCB0aGUgPHxub3RpbWVzdGFtcHN8PiB0b2tlbiBhdCB0aGUgc3RhcnQgb2YgdGhlIHNlcXVlbmNlLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJbXVtdfSBUaGUgZGVjb2RlciBwcm9tcHQgaWRzLlxuICAgICAqL1xuICAgIGdldF9kZWNvZGVyX3Byb21wdF9pZHMoe1xuICAgICAgICBsYW5ndWFnZSA9IG51bGwsXG4gICAgICAgIHRhc2sgPSBudWxsLFxuICAgICAgICBub190aW1lc3RhbXBzID0gdHJ1ZSxcbiAgICB9ID0ge30pIHtcblxuICAgICAgICAvLyA8fGxhbmdfaWR8PiA8fHRhc2t8PiA8fG5vdGltZXN0YW1wc3w+XG5cbiAgICAgICAgbGV0IGZvcmNlZF9kZWNvZGVyX2lkcyA9IFtdO1xuXG4gICAgICAgIGlmIChsYW5ndWFnZSkge1xuICAgICAgICAgICAgLy8gVXNlciB3aXNoZXMgdG8gc3BlY2lmeSB0aGUgbGFuZ3VhZ2VcbiAgICAgICAgICAgIGxhbmd1YWdlID0gbGFuZ3VhZ2UudG9Mb3dlckNhc2UoKTtcblxuICAgICAgICAgICAgLy8gTWFwIHRvIGNvZGUgZnJvbSB1c2VyLWZyaWVuZGx5IG5hbWUgKGUuZy4sIFwiZW5nbGlzaFwiIC0+IFwiZW5cIilcbiAgICAgICAgICAgIGxldCBsYW5ndWFnZV9jb2RlID0gV0hJU1BFUl9UT19MQU5HVUFHRV9DT0RFX01BUFBJTkcuZ2V0KGxhbmd1YWdlKTtcblxuICAgICAgICAgICAgaWYgKGxhbmd1YWdlX2NvZGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIC8vIFVzZXIgcHJvdmlkZWQgc29tZXRoaW5nIHRoYXQgaXMgbm90IGEgbGFuZ3VhZ2UgbmFtZVxuXG4gICAgICAgICAgICAgICAgaWYgKFdISVNQRVJfTEFOR1VBR0VfTUFQUElORy5oYXMobGFuZ3VhZ2UpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFVzZXIgcHJvdmlkZWQgdGhlIGxhbmd1YWdlIGNvZGUgZGlyZWN0bHkgKGUuZy4sIFwiZW5cIilcbiAgICAgICAgICAgICAgICAgICAgbGFuZ3VhZ2VfY29kZSA9IGxhbmd1YWdlO1xuXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVXNlciBwcm92aWRlZCBzb21ldGhpbmcgdGhhdCBpcyBub3QgYSBsYW5ndWFnZSBjb2RlIG9yIG5hbWVcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaXNfbGFuZ3VhZ2VfY29kZSA9IGxhbmd1YWdlLmxlbmd0aCA9PT0gMjtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGFuZ3MgPSBpc19sYW5ndWFnZV9jb2RlID8gV0hJU1BFUl9MQU5HVUFHRV9NQVBQSU5HLmtleXMoKSA6IFdISVNQRVJfTEFOR1VBR0VfTUFQUElORy52YWx1ZXMoKTtcblxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYExhbmd1YWdlIFwiJHtsYW5ndWFnZX1cIiBpcyBub3Qgc3VwcG9ydGVkLiBNdXN0IGJlIG9uZSBvZjogJHtKU09OLnN0cmluZ2lmeShsYW5ncyl9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQgbGFuZ3VhZ2VfdG9rZW5faWQgPSB0aGlzLm1vZGVsLnRva2Vuc190b19pZHMuZ2V0KGA8fCR7bGFuZ3VhZ2VfY29kZX18PmApO1xuICAgICAgICAgICAgaWYgKGxhbmd1YWdlX3Rva2VuX2lkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuYWJsZSB0byBmaW5kIGxhbmd1YWdlIFwiJHtsYW5ndWFnZV9jb2RlfVwiIGluIG1vZGVsIHZvY2FidWxhcnkuIFBsZWFzZSByZXBvcnQgdGhpcyBpc3N1ZSBhdCBodHRwczovL2dpdGh1Yi5jb20veGVub3ZhL3RyYW5zZm9ybWVycy5qcy9pc3N1ZXMvbmV3L2Nob29zZS5gKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3JjZWRfZGVjb2Rlcl9pZHMucHVzaChsYW5ndWFnZV90b2tlbl9pZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBObyB0b2tlbiB3aWxsIGJlIGZvcmNlZCwgd2hpY2ggbGVhdmVzIHRoZSBtb2RlbCB0byBwcmVkaWN0IHRoZSBsYW5ndWFnZVxuICAgICAgICAgICAgZm9yY2VkX2RlY29kZXJfaWRzLnB1c2gobnVsbCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGFzaykge1xuICAgICAgICAgICAgdGFzayA9IHRhc2sudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIGlmICh0YXNrICE9PSAndHJhbnNjcmliZScgJiYgdGFzayAhPT0gJ3RyYW5zbGF0ZScpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRhc2sgXCIke3Rhc2t9XCIgaXMgbm90IHN1cHBvcnRlZC4gTXVzdCBiZSBvbmUgb2Y6IFtcInRyYW5zY3JpYmVcIiwgXCJ0cmFuc2xhdGVcIl1gKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV0IHRhc2tfdG9rZW5faWQgPSB0aGlzLm1vZGVsLnRva2Vuc190b19pZHMuZ2V0KGA8fCR7dGFza318PmApO1xuICAgICAgICAgICAgaWYgKHRhc2tfdG9rZW5faWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5hYmxlIHRvIGZpbmQgdGFzayBcIiR7dGFza31cIiBpbiBtb2RlbCB2b2NhYnVsYXJ5LiBQbGVhc2UgcmVwb3J0IHRoaXMgaXNzdWUgYXQgaHR0cHM6Ly9naXRodWIuY29tL3hlbm92YS90cmFuc2Zvcm1lcnMuanMvaXNzdWVzL25ldy9jaG9vc2UuYClcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yY2VkX2RlY29kZXJfaWRzLnB1c2godGFza190b2tlbl9pZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBObyB0b2tlbiB3aWxsIGJlIGZvcmNlZCwgd2hpY2ggbGVhdmVzIHRoZSBtb2RlbCB0byBwcmVkaWN0IHRoZSB0YXNrXG4gICAgICAgICAgICBmb3JjZWRfZGVjb2Rlcl9pZHMucHVzaChudWxsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChub190aW1lc3RhbXBzKSB7XG4gICAgICAgICAgICBsZXQgbm9fdGltZXN0YW1wc19pZCA9IHRoaXMubW9kZWwudG9rZW5zX3RvX2lkcy5nZXQoYDx8bm90aW1lc3RhbXBzfD5gKTtcbiAgICAgICAgICAgIGlmIChub190aW1lc3RhbXBzX2lkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBmaW5kIFwiPHxub3RpbWVzdGFtcHN8PlwiIGluIG1vZGVsIHZvY2FidWxhcnkuIFBsZWFzZSByZXBvcnQgdGhpcyBpc3N1ZSBhdCBodHRwczovL2dpdGh1Yi5jb20veGVub3ZhL3RyYW5zZm9ybWVycy5qcy9pc3N1ZXMvbmV3L2Nob29zZS4nKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3JjZWRfZGVjb2Rlcl9pZHMucHVzaChub190aW1lc3RhbXBzX2lkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmb3JjZWRfZGVjb2Rlcl9pZHMubWFwKCh4LCBpKSA9PiBbaSArIDEsIHhdKS5maWx0ZXIoeCA9PiB4WzFdICE9PSBudWxsKTtcblxuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBDb2RlR2VuVG9rZW5pemVyIGV4dGVuZHMgUHJlVHJhaW5lZFRva2VuaXplciB7IH1cbmV4cG9ydCBjbGFzcyBDTElQVG9rZW5pemVyIGV4dGVuZHMgUHJlVHJhaW5lZFRva2VuaXplciB7IH1cblxuXG4vKipcbiAqIEB0b2RvIFRoaXMgbW9kZWwgaXMgbm90IHlldCBzdXBwb3J0ZWQgYnkgSHVnZ2luZyBGYWNlJ3MgXCJmYXN0XCIgdG9rZW5pemVycyBsaWJyYXJ5IChodHRwczovL2dpdGh1Yi5jb20vaHVnZ2luZ2ZhY2UvdG9rZW5pemVycykuXG4gKiBUaGVyZWZvcmUsIHRoaXMgaW1wbGVtZW50YXRpb24gKHdoaWNoIGlzIGJhc2VkIG9uIGZhc3QgdG9rZW5pemVycykgbWF5IHByb2R1Y2Ugc2xpZ2h0bHkgaW5hY2N1cmF0ZSByZXN1bHRzLlxuICovXG5leHBvcnQgY2xhc3MgTWFyaWFuVG9rZW5pemVyIGV4dGVuZHMgUHJlVHJhaW5lZFRva2VuaXplciB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IE1hcmlhblRva2VuaXplciBpbnN0YW5jZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdG9rZW5pemVySlNPTiBUaGUgSlNPTiBvZiB0aGUgdG9rZW5pemVyLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0b2tlbml6ZXJDb25maWcgVGhlIGNvbmZpZyBvZiB0aGUgdG9rZW5pemVyLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHRva2VuaXplckpTT04sIHRva2VuaXplckNvbmZpZykge1xuICAgICAgICBzdXBlcih0b2tlbml6ZXJKU09OLCB0b2tlbml6ZXJDb25maWcpO1xuXG4gICAgICAgIHRoaXMubGFuZ3VhZ2VSZWdleCA9IC9eKD4+XFx3Kzw8KVxccyovZztcblxuICAgICAgICB0aGlzLnN1cHBvcnRlZF9sYW5ndWFnZV9jb2RlcyA9IHRoaXMubW9kZWwudm9jYWIuZmlsdGVyKFxuICAgICAgICAgICAgeCA9PiB0aGlzLmxhbmd1YWdlUmVnZXgudGVzdCh4KVxuICAgICAgICApO1xuXG4gICAgICAgIGNvbnNvbGUud2FybignV0FSTklORzogYE1hcmlhblRva2VuaXplcmAgaXMgbm90IHlldCBzdXBwb3J0ZWQgYnkgSHVnZ2luZyBGYWNlXFwncyBcImZhc3RcIiB0b2tlbml6ZXJzIGxpYnJhcnkuIFRoZXJlZm9yZSwgeW91IG1heSBleHBlcmllbmNlIHNsaWdodGx5IGluYWNjdXJhdGUgcmVzdWx0cy4nKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVuY29kZXMgYSBzaW5nbGUgdGV4dC4gT3ZlcnJpZGluZyB0aGlzIG1ldGhvZCBpcyBuZWNlc3Nhcnkgc2luY2UgdGhlIGxhbmd1YWdlIGNvZGVzXG4gICAgICogbXVzdCBiZSByZW1vdmVkIGJlZm9yZSBlbmNvZGluZyB3aXRoIHNlbnRlbmNlcGllY2UgbW9kZWwuXG4gICAgICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vaHVnZ2luZ2ZhY2UvdHJhbnNmb3JtZXJzL2Jsb2IvMTJkNTFkYjI0M2EwMDcyNmE1NDhhNDNjYzMzMzM5MGViYWU3MzFlMy9zcmMvdHJhbnNmb3JtZXJzL21vZGVscy9tYXJpYW4vdG9rZW5pemF0aW9uX21hcmlhbi5weSNMMjA0LUwyMTNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfG51bGx9IHRleHQgVGhlIHRleHQgdG8gZW5jb2RlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gVGhlIGVuY29kZWQgdG9rZW5zLlxuICAgICAqL1xuICAgIF9lbmNvZGVfdGV4dCh0ZXh0KSB7XG4gICAgICAgIGlmICh0ZXh0ID09PSBudWxsKSByZXR1cm4gbnVsbDtcblxuICAgICAgICAvLyBDaGVjayBpZiB0ZXh0IHN0YXJ0cyB3aXRoIGxhbmd1YWdlIGNvZGU6XG4gICAgICAgIGxldCBbbWF0Y2hJbmZvLCAuLi5yZW1haW5kZXJdID0gdGV4dC50cmltKCkuc3BsaXQodGhpcy5sYW5ndWFnZVJlZ2V4KTtcblxuICAgICAgICBpZiAocmVtYWluZGVyLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgLy8gTm8gbGFuZ3VhZ2UgY29kZSwgZW5jb2RlIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gc3VwZXIuX2VuY29kZV90ZXh0KG1hdGNoSW5mbyk7XG5cbiAgICAgICAgfSBlbHNlIGlmIChyZW1haW5kZXIubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICAvLyBUZXh0IHN0YXJ0cyB3aXRoIGxhbmd1YWdlIGNvZGUsIHNvIHdlIGRvIG5vdCBlbmNvZGUgaXQgd2l0aCBzZW50ZW5jZXBpZWNlLlxuICAgICAgICAgICAgbGV0IFtsYW5ndWFnZSwgdGV4dF0gPSByZW1haW5kZXI7XG5cbiAgICAgICAgICAgIGlmICghdGhpcy5zdXBwb3J0ZWRfbGFuZ3VhZ2VfY29kZXMuaW5jbHVkZXMobGFuZ3VhZ2UpKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBVbnN1cHBvcnRlZCBsYW5ndWFnZSBjb2RlIFwiJHtsYW5ndWFnZX1cIiBkZXRlY3RlZCwgd2hpY2ggbWF5IGxlYWQgdG8gdW5leHBlY3RlZCBiZWhhdmlvci4gU2hvdWxkIGJlIG9uZSBvZjogJHtKU09OLnN0cmluZ2lmeSh0aGlzLnN1cHBvcnRlZF9sYW5ndWFnZV9jb2Rlcyl9YClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtZXJnZUFycmF5cyhbbGFuZ3VhZ2VdLCBzdXBlci5fZW5jb2RlX3RleHQodGV4dCkpO1xuICAgICAgICB9XG4gICAgfVxuXG59XG5cbi8qKlxuICogQSB0cmllIHN0cnVjdHVyZSB0byBlZmZpY2llbnRseSBzdG9yZSBhbmQgc2VhcmNoIGZvciBzdHJpbmdzLlxuICovXG5jbGFzcyBDaGFyVHJpZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMucm9vdCA9IENoYXJUcmllTm9kZS5kZWZhdWx0KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkcyBvbmUgb3IgbW9yZSBgdGV4dHNgIHRvIHRoZSB0cmllLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IHRleHRzIFRoZSBzdHJpbmdzIHRvIGFkZCB0byB0aGUgdHJpZS5cbiAgICAgKi9cbiAgICBleHRlbmQodGV4dHMpIHtcbiAgICAgICAgZm9yIChsZXQgdGV4dCBvZiB0ZXh0cykge1xuICAgICAgICAgICAgdGhpcy5wdXNoKHRleHQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkcyBvbmUgb3IgbW9yZSBgdGV4dHNgIHRvIHRoZSB0cmllLlxuICAgICAqIEBwYXJhbSB7Kn0gdGV4dCBUaGUgc3RyaW5ncyB0byBhZGQgdG8gdGhlIHRyaWUuXG4gICAgICovXG4gICAgcHVzaCh0ZXh0KSB7XG4gICAgICAgIGxldCBub2RlID0gdGhpcy5yb290O1xuICAgICAgICBmb3IgKGxldCBjaCBvZiB0ZXh0KSB7XG4gICAgICAgICAgICBsZXQgY2hpbGQgPSBub2RlLmNoaWxkcmVuLmdldChjaCk7XG4gICAgICAgICAgICBpZiAoY2hpbGQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGNoaWxkID0gQ2hhclRyaWVOb2RlLmRlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICBub2RlLmNoaWxkcmVuLnNldChjaCwgY2hpbGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbm9kZSA9IGNoaWxkO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUuaXNMZWFmID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZWFyY2hlcyB0aGUgdHJpZSBmb3IgYWxsIHN0cmluZ3Mgd2l0aCBhIGNvbW1vbiBwcmVmaXggb2YgYHRleHRgLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IFRoZSBjb21tb24gcHJlZml4IHRvIHNlYXJjaCBmb3IuXG4gICAgICogQHlpZWxkcyB7c3RyaW5nfSBFYWNoIHN0cmluZyBpbiB0aGUgdHJpZSB0aGF0IGhhcyBgdGV4dGAgYXMgYSBwcmVmaXguXG4gICAgICovXG4gICAgKmNvbW1vblByZWZpeFNlYXJjaCh0ZXh0KSB7XG4gICAgICAgIGxldCBub2RlID0gdGhpcy5yb290O1xuICAgICAgICBsZXQgcHJlZml4ID0gXCJcIjtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0ZXh0Lmxlbmd0aCAmJiBub2RlICE9PSB1bmRlZmluZWQ7ICsraSkge1xuICAgICAgICAgICAgY29uc3QgY2ggPSB0ZXh0W2ldO1xuICAgICAgICAgICAgcHJlZml4ICs9IGNoO1xuICAgICAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGRyZW4uZ2V0KGNoKTtcbiAgICAgICAgICAgIGlmIChub2RlICE9PSB1bmRlZmluZWQgJiYgbm9kZS5pc0xlYWYpIHtcbiAgICAgICAgICAgICAgICB5aWVsZCBwcmVmaXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKlxuICogUmVwcmVzZW50cyBhIG5vZGUgaW4gYSBjaGFyYWN0ZXIgdHJpZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNMZWFmIFdoZXRoZXIgdGhlIG5vZGUgaXMgYSBsZWFmIG5vZGUgb3Igbm90LlxuICogQHBhcmFtIHtNYXA8c3RyaW5nLCBDaGFyVHJpZU5vZGU+fSBjaGlsZHJlbiBBIG1hcCBjb250YWluaW5nIHRoZSBub2RlJ3MgY2hpbGRyZW4sIHdoZXJlIHRoZSBrZXkgaXMgYSBjaGFyYWN0ZXIgYW5kIHRoZSB2YWx1ZSBpcyBhIGBDaGFyVHJpZU5vZGVgLlxuICovXG5jbGFzcyBDaGFyVHJpZU5vZGUge1xuICAgIGNvbnN0cnVjdG9yKGlzTGVhZiwgY2hpbGRyZW4pIHtcbiAgICAgICAgdGhpcy5pc0xlYWYgPSBpc0xlYWY7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbmV3IGBDaGFyVHJpZU5vZGVgIGluc3RhbmNlIHdpdGggZGVmYXVsdCB2YWx1ZXMuXG4gICAgICogQHJldHVybnMge0NoYXJUcmllTm9kZX0gQSBuZXcgYENoYXJUcmllTm9kZWAgaW5zdGFuY2Ugd2l0aCBgaXNMZWFmYCBzZXQgdG8gYGZhbHNlYCBhbmQgYW4gZW1wdHkgYGNoaWxkcmVuYCBtYXAuXG4gICAgICovXG4gICAgc3RhdGljIGRlZmF1bHQoKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ2hhclRyaWVOb2RlKGZhbHNlLCBuZXcgTWFwKCkpO1xuICAgIH1cbn1cblxuY2xhc3MgVG9rZW5MYXR0aWNlIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IFRva2VuTGF0dGljZSBpbnN0YW5jZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzZW50ZW5jZSBUaGUgaW5wdXQgc2VudGVuY2UgdG8gYmUgdG9rZW5pemVkLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBib3NUb2tlbklkIFRoZSBiZWdpbm5pbmctb2Ytc2VxdWVuY2UgdG9rZW4gSUQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGVvc1Rva2VuSWQgVGhlIGVuZC1vZi1zZXF1ZW5jZSB0b2tlbiBJRC5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihzZW50ZW5jZSwgYm9zVG9rZW5JZCwgZW9zVG9rZW5JZCkge1xuICAgICAgICB0aGlzLnNlbnRlbmNlID0gc2VudGVuY2U7XG4gICAgICAgIHRoaXMubGVuID0gc2VudGVuY2UubGVuZ3RoO1xuICAgICAgICB0aGlzLmJvc1Rva2VuSWQgPSBib3NUb2tlbklkO1xuICAgICAgICB0aGlzLmVvc1Rva2VuSWQgPSBlb3NUb2tlbklkO1xuICAgICAgICB0aGlzLm5vZGVzID0gW107XG4gICAgICAgIHRoaXMuYmVnaW5Ob2RlcyA9IG5ldyBBcnJheSh0aGlzLmxlbiArIDEpO1xuICAgICAgICB0aGlzLmVuZE5vZGVzID0gbmV3IEFycmF5KHRoaXMubGVuICsgMSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5sZW4gKyAxOyArK2kpIHtcbiAgICAgICAgICAgIHRoaXMuYmVnaW5Ob2Rlc1tpXSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5lbmROb2Rlc1tpXSA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJvcyA9IG5ldyBUb2tlbkxhdHRpY2VOb2RlKHRoaXMuYm9zVG9rZW5JZCwgMCwgMCwgMCwgMC4wKTtcbiAgICAgICAgY29uc3QgZW9zID0gbmV3IFRva2VuTGF0dGljZU5vZGUodGhpcy5lb3NUb2tlbklkLCAxLCB0aGlzLmxlbiwgMCwgMC4wKTtcbiAgICAgICAgdGhpcy5ub2Rlcy5wdXNoKGJvcy5jbG9uZSgpKTtcbiAgICAgICAgdGhpcy5ub2Rlcy5wdXNoKGVvcy5jbG9uZSgpKTtcbiAgICAgICAgdGhpcy5iZWdpbk5vZGVzW3RoaXMubGVuXS5wdXNoKGVvcyk7XG4gICAgICAgIHRoaXMuZW5kTm9kZXNbMF0ucHVzaChib3MpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluc2VydHMgYSBuZXcgdG9rZW4gbm9kZSBpbnRvIHRoZSB0b2tlbiBsYXR0aWNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBvcyBUaGUgc3RhcnRpbmcgcG9zaXRpb24gb2YgdGhlIHRva2VuLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsZW5ndGggVGhlIGxlbmd0aCBvZiB0aGUgdG9rZW4uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNjb3JlIFRoZSBzY29yZSBvZiB0aGUgdG9rZW4uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRva2VuSWQgVGhlIHRva2VuIElEIG9mIHRoZSB0b2tlbi5cbiAgICAgKi9cbiAgICBpbnNlcnQocG9zLCBsZW5ndGgsIHNjb3JlLCB0b2tlbklkKSB7XG4gICAgICAgIGNvbnN0IG5vZGVJZCA9IHRoaXMubm9kZXMubGVuZ3RoO1xuICAgICAgICBjb25zdCBub2RlID0gbmV3IFRva2VuTGF0dGljZU5vZGUodG9rZW5JZCwgbm9kZUlkLCBwb3MsIGxlbmd0aCwgc2NvcmUpO1xuICAgICAgICB0aGlzLmJlZ2luTm9kZXNbcG9zXS5wdXNoKG5vZGUpO1xuICAgICAgICB0aGlzLmVuZE5vZGVzW3BvcyArIGxlbmd0aF0ucHVzaChub2RlKTtcbiAgICAgICAgdGhpcy5ub2Rlcy5wdXNoKG5vZGUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEltcGxlbWVudHMgdGhlIFZpdGVyYmkgYWxnb3JpdGhtIHRvIGNvbXB1dGUgdGhlIG1vc3QgbGlrZWx5IHNlcXVlbmNlIG9mIHRva2Vucy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtUb2tlbkxhdHRpY2VOb2RlW119IFRoZSBhcnJheSBvZiBub2RlcyByZXByZXNlbnRpbmcgdGhlIG1vc3QgbGlrZWx5IHNlcXVlbmNlIG9mIHRva2Vucy5cbiAgICAgKi9cbiAgICB2aXRlcmJpKCkge1xuICAgICAgICBjb25zdCBsZW4gPSB0aGlzLmxlbjtcbiAgICAgICAgbGV0IHBvcyA9IDA7XG4gICAgICAgIHdoaWxlIChwb3MgPD0gbGVuKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5iZWdpbk5vZGVzW3Bvc10ubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBybm9kZSBvZiB0aGlzLmJlZ2luTm9kZXNbcG9zXSkge1xuICAgICAgICAgICAgICAgIHJub2RlLnByZXYgPSBudWxsO1xuICAgICAgICAgICAgICAgIGxldCBiZXN0U2NvcmUgPSAwLjA7XG4gICAgICAgICAgICAgICAgbGV0IGJlc3ROb2RlID0gbnVsbDtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBsbm9kZSBvZiB0aGlzLmVuZE5vZGVzW3Bvc10pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2NvcmUgPSBsbm9kZS5iYWNrdHJhY2VTY29yZSArIHJub2RlLnNjb3JlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYmVzdE5vZGUgPT09IG51bGwgfHwgc2NvcmUgPiBiZXN0U2NvcmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlc3ROb2RlID0gbG5vZGUuY2xvbmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RTY29yZSA9IHNjb3JlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGJlc3ROb2RlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJub2RlLnByZXYgPSBiZXN0Tm9kZTtcbiAgICAgICAgICAgICAgICAgICAgcm5vZGUuYmFja3RyYWNlU2NvcmUgPSBiZXN0U2NvcmU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICsrcG9zO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcmVzdWx0cyA9IFtdO1xuICAgICAgICBjb25zdCByb290ID0gdGhpcy5iZWdpbk5vZGVzW2xlbl1bMF07XG4gICAgICAgIGNvbnN0IHByZXYgPSByb290LnByZXY7XG4gICAgICAgIGlmIChwcmV2ID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgbm9kZSA9IHByZXYuY2xvbmUoKTtcbiAgICAgICAgd2hpbGUgKG5vZGUucHJldiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKG5vZGUuY2xvbmUoKSk7XG4gICAgICAgICAgICBjb25zdCBuID0gbm9kZS5jbG9uZSgpO1xuICAgICAgICAgICAgbm9kZSA9IG4ucHJldi5jbG9uZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0cy5yZXZlcnNlKCk7XG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7VG9rZW5MYXR0aWNlTm9kZX0gbm9kZVxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBhcnJheSBvZiBub2RlcyByZXByZXNlbnRpbmcgdGhlIG1vc3QgbGlrZWx5IHNlcXVlbmNlIG9mIHRva2Vucy5cbiAgICAgKi9cbiAgICBwaWVjZShub2RlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbnRlbmNlLnNsaWNlKG5vZGUucG9zLCBub2RlLnBvcyArIG5vZGUubGVuZ3RoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFRoZSBhcnJheSBvZiBub2RlcyByZXByZXNlbnRpbmcgdGhlIG1vc3QgbGlrZWx5IHNlcXVlbmNlIG9mIHRva2Vucy5cbiAgICAgKi9cbiAgICB0b2tlbnMoKSB7XG4gICAgICAgIGNvbnN0IG5vZGVzID0gdGhpcy52aXRlcmJpKCk7XG4gICAgICAgIHJldHVybiBub2Rlcy5tYXAoeCA9PiB0aGlzLnBpZWNlKHgpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFRoZSBhcnJheSBvZiBub2RlcyByZXByZXNlbnRpbmcgdGhlIG1vc3QgbGlrZWx5IHNlcXVlbmNlIG9mIHRva2Vucy5cbiAgICAgKi9cbiAgICB0b2tlbklkcygpIHtcbiAgICAgICAgY29uc3Qgbm9kZXMgPSB0aGlzLnZpdGVyYmkoKTtcbiAgICAgICAgcmV0dXJuIG5vZGVzLm1hcCh4ID0+IHgudG9rZW5JZCk7XG4gICAgfVxufVxuY2xhc3MgVG9rZW5MYXR0aWNlTm9kZSB7XG4gICAgLyoqXG4gICAgICogUmVwcmVzZW50cyBhIG5vZGUgaW4gYSB0b2tlbiBsYXR0aWNlIGZvciBhIGdpdmVuIHNlbnRlbmNlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0b2tlbklkIFRoZSBJRCBvZiB0aGUgdG9rZW4gYXNzb2NpYXRlZCB3aXRoIHRoaXMgbm9kZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbm9kZUlkIFRoZSBJRCBvZiB0aGlzIG5vZGUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBvcyBUaGUgc3RhcnRpbmcgcG9zaXRpb24gb2YgdGhlIHRva2VuIGluIHRoZSBzZW50ZW5jZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbGVuZ3RoIFRoZSBsZW5ndGggb2YgdGhlIHRva2VuLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzY29yZSBUaGUgc2NvcmUgYXNzb2NpYXRlZCB3aXRoIHRoZSB0b2tlbi5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih0b2tlbklkLCBub2RlSWQsIHBvcywgbGVuZ3RoLCBzY29yZSkge1xuICAgICAgICB0aGlzLnRva2VuSWQgPSB0b2tlbklkO1xuICAgICAgICB0aGlzLm5vZGVJZCA9IG5vZGVJZDtcbiAgICAgICAgdGhpcy5wb3MgPSBwb3M7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gbGVuZ3RoO1xuICAgICAgICB0aGlzLnNjb3JlID0gc2NvcmU7XG4gICAgICAgIHRoaXMucHJldiA9IG51bGw7XG4gICAgICAgIHRoaXMuYmFja3RyYWNlU2NvcmUgPSAwLjA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGNsb25lIG9mIHRoaXMgbm9kZS5cbiAgICAgKiBAcmV0dXJucyB7VG9rZW5MYXR0aWNlTm9kZX0gQSBjbG9uZSBvZiB0aGlzIG5vZGUuXG4gICAgICovXG4gICAgY2xvbmUoKSB7XG4gICAgICAgIGNvbnN0IG4gPSBuZXcgVG9rZW5MYXR0aWNlTm9kZSh0aGlzLnRva2VuSWQsIHRoaXMubm9kZUlkLCB0aGlzLnBvcywgdGhpcy5sZW5ndGgsIHRoaXMuc2NvcmUpO1xuICAgICAgICBuLnByZXYgPSB0aGlzLnByZXY7XG4gICAgICAgIG4uYmFja3RyYWNlU2NvcmUgPSB0aGlzLmJhY2t0cmFjZVNjb3JlO1xuICAgICAgICByZXR1cm4gbjtcbiAgICB9XG59XG5cbi8qKlxuICogSGVscGVyIGNsYXNzIHdoaWNoIGlzIHVzZWQgdG8gaW5zdGFudGlhdGUgcHJldHJhaW5lZCB0b2tlbml6ZXJzIHdpdGggdGhlIGBmcm9tX3ByZXRyYWluZWRgIGZ1bmN0aW9uLlxuICogVGhlIGNob3NlbiB0b2tlbml6ZXIgY2xhc3MgaXMgZGV0ZXJtaW5lZCBieSB0aGUgdHlwZSBzcGVjaWZpZWQgaW4gdGhlIHRva2VuaXplciBjb25maWcuXG4gKiBcbiAqIEBleGFtcGxlXG4gKiBsZXQgdG9rZW5pemVyID0gYXdhaXQgQXV0b1Rva2VuaXplci5mcm9tX3ByZXRyYWluZWQoJ2JlcnQtYmFzZS11bmNhc2VkJyk7XG4gKi9cbmV4cG9ydCBjbGFzcyBBdXRvVG9rZW5pemVyIHtcbiAgICBzdGF0aWMgVE9LRU5JWkVSX0NMQVNTX01BUFBJTkcgPSB7XG4gICAgICAgICdUNVRva2VuaXplcic6IFQ1VG9rZW5pemVyLFxuICAgICAgICAnRGlzdGlsQmVydFRva2VuaXplcic6IERpc3RpbEJlcnRUb2tlbml6ZXIsXG4gICAgICAgICdCZXJ0VG9rZW5pemVyJzogQmVydFRva2VuaXplcixcbiAgICAgICAgJ01vYmlsZUJlcnRUb2tlbml6ZXInOiBNb2JpbGVCZXJ0VG9rZW5pemVyLFxuICAgICAgICAnU3F1ZWV6ZUJlcnRUb2tlbml6ZXInOiBTcXVlZXplQmVydFRva2VuaXplcixcbiAgICAgICAgJ0FsYmVydFRva2VuaXplcic6IEFsYmVydFRva2VuaXplcixcbiAgICAgICAgJ0dQVDJUb2tlbml6ZXInOiBHUFQyVG9rZW5pemVyLFxuICAgICAgICAnQmFydFRva2VuaXplcic6IEJhcnRUb2tlbml6ZXIsXG4gICAgICAgICdSb2JlcnRhVG9rZW5pemVyJzogUm9iZXJ0YVRva2VuaXplcixcbiAgICAgICAgJ1doaXNwZXJUb2tlbml6ZXInOiBXaGlzcGVyVG9rZW5pemVyLFxuICAgICAgICAnQ29kZUdlblRva2VuaXplcic6IENvZGVHZW5Ub2tlbml6ZXIsXG4gICAgICAgICdDTElQVG9rZW5pemVyJzogQ0xJUFRva2VuaXplcixcbiAgICAgICAgJ01hcmlhblRva2VuaXplcic6IE1hcmlhblRva2VuaXplcixcbiAgICAgICAgJ0Jsb29tVG9rZW5pemVyJzogQmxvb21Ub2tlbml6ZXIsXG4gICAgICAgICdObGxiVG9rZW5pemVyJzogTmxsYlRva2VuaXplcixcbiAgICAgICAgJ0xsYW1hVG9rZW5pemVyJzogTGxhbWFUb2tlbml6ZXIsXG4gICAgICAgICdYTE1Sb2JlcnRhVG9rZW5pemVyJzogWExNUm9iZXJ0YVRva2VuaXplcixcbiAgICAgICAgJ01QTmV0VG9rZW5pemVyJzogTVBOZXRUb2tlbml6ZXIsXG4gICAgICAgICdGYWxjb25Ub2tlbml6ZXInOiBGYWxjb25Ub2tlbml6ZXIsXG4gICAgICAgICdHUFROZW9YVG9rZW5pemVyJzogR1BUTmVvWFRva2VuaXplcixcblxuICAgICAgICAvLyBCYXNlIGNhc2U6XG4gICAgICAgICdQcmVUcmFpbmVkVG9rZW5pemVyJzogUHJlVHJhaW5lZFRva2VuaXplcixcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIEluc3RhbnRpYXRlIG9uZSBvZiB0aGUgdG9rZW5pemVyIGNsYXNzZXMgb2YgdGhlIGxpYnJhcnkgZnJvbSBhIHByZXRyYWluZWQgbW9kZWwuXG4gICAgICogXG4gICAgICogVGhlIHRva2VuaXplciBjbGFzcyB0byBpbnN0YW50aWF0ZSBpcyBzZWxlY3RlZCBiYXNlZCBvbiB0aGUgYHRva2VuaXplcl9jbGFzc2AgcHJvcGVydHkgb2YgdGhlIGNvbmZpZyBvYmplY3RcbiAgICAgKiAoZWl0aGVyIHBhc3NlZCBhcyBhbiBhcmd1bWVudCBvciBsb2FkZWQgZnJvbSBgcHJldHJhaW5lZF9tb2RlbF9uYW1lX29yX3BhdGhgIGlmIHBvc3NpYmxlKVxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcmV0cmFpbmVkX21vZGVsX25hbWVfb3JfcGF0aCBUaGUgbmFtZSBvciBwYXRoIG9mIHRoZSBwcmV0cmFpbmVkIG1vZGVsLiBDYW4gYmUgZWl0aGVyOlxuICAgICAqIC0gQSBzdHJpbmcsIHRoZSAqbW9kZWwgaWQqIG9mIGEgcHJldHJhaW5lZCB0b2tlbml6ZXIgaG9zdGVkIGluc2lkZSBhIG1vZGVsIHJlcG8gb24gaHVnZ2luZ2ZhY2UuY28uXG4gICAgICogICBWYWxpZCBtb2RlbCBpZHMgY2FuIGJlIGxvY2F0ZWQgYXQgdGhlIHJvb3QtbGV2ZWwsIGxpa2UgYGJlcnQtYmFzZS11bmNhc2VkYCwgb3IgbmFtZXNwYWNlZCB1bmRlciBhXG4gICAgICogICB1c2VyIG9yIG9yZ2FuaXphdGlvbiBuYW1lLCBsaWtlIGBkYm1kei9iZXJ0LWJhc2UtZ2VybWFuLWNhc2VkYC5cbiAgICAgKiAtIEEgcGF0aCB0byBhICpkaXJlY3RvcnkqIGNvbnRhaW5pbmcgdG9rZW5pemVyIGZpbGVzLCBlLmcuLCBgLi9teV9tb2RlbF9kaXJlY3RvcnkvYC5cbiAgICAgKiBAcGFyYW0ge1ByZXRyYWluZWRPcHRpb25zfSBvcHRpb25zIEFkZGl0aW9uYWwgb3B0aW9ucyBmb3IgbG9hZGluZyB0aGUgdG9rZW5pemVyLlxuICAgICAqIFxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFByZVRyYWluZWRUb2tlbml6ZXI+fSBBIG5ldyBpbnN0YW5jZSBvZiB0aGUgUHJlVHJhaW5lZFRva2VuaXplciBjbGFzcy5cbiAgICAgKi9cbiAgICBzdGF0aWMgYXN5bmMgZnJvbV9wcmV0cmFpbmVkKHByZXRyYWluZWRfbW9kZWxfbmFtZV9vcl9wYXRoLCB7XG4gICAgICAgIHF1YW50aXplZCA9IHRydWUsXG4gICAgICAgIHByb2dyZXNzX2NhbGxiYWNrID0gbnVsbCxcbiAgICAgICAgY29uZmlnID0gbnVsbCxcbiAgICAgICAgY2FjaGVfZGlyID0gbnVsbCxcbiAgICAgICAgbG9jYWxfZmlsZXNfb25seSA9IGZhbHNlLFxuICAgICAgICByZXZpc2lvbiA9ICdtYWluJyxcbiAgICB9ID0ge30pIHtcblxuICAgICAgICBsZXQgW3Rva2VuaXplckpTT04sIHRva2VuaXplckNvbmZpZ10gPSBhd2FpdCBsb2FkVG9rZW5pemVyKHByZXRyYWluZWRfbW9kZWxfbmFtZV9vcl9wYXRoLCB7XG4gICAgICAgICAgICBxdWFudGl6ZWQsXG4gICAgICAgICAgICBwcm9ncmVzc19jYWxsYmFjayxcbiAgICAgICAgICAgIGNvbmZpZyxcbiAgICAgICAgICAgIGNhY2hlX2RpcixcbiAgICAgICAgICAgIGxvY2FsX2ZpbGVzX29ubHksXG4gICAgICAgICAgICByZXZpc2lvbixcbiAgICAgICAgfSlcblxuICAgICAgICAvLyBTb21lIHRva2VuaXplcnMgYXJlIHNhdmVkIHdpdGggdGhlIFwiRmFzdFwiIHN1ZmZpeCwgc28gd2UgcmVtb3ZlIHRoYXQgaWYgcHJlc2VudC5cbiAgICAgICAgbGV0IHRva2VuaXplck5hbWUgPSB0b2tlbml6ZXJDb25maWcudG9rZW5pemVyX2NsYXNzLnJlcGxhY2UoL0Zhc3QkLywgJycpO1xuXG4gICAgICAgIGxldCBjbHMgPSB0aGlzLlRPS0VOSVpFUl9DTEFTU19NQVBQSU5HW3Rva2VuaXplck5hbWVdO1xuICAgICAgICBpZiAoIWNscykge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGBVbmtub3duIHRva2VuaXplciBjbGFzcyBcIiR7dG9rZW5pemVyTmFtZX1cIiwgYXR0ZW1wdGluZyB0byBjb25zdHJ1Y3QgZnJvbSBiYXNlIGNsYXNzLmApO1xuICAgICAgICAgICAgY2xzID0gUHJlVHJhaW5lZFRva2VuaXplcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IGNscyh0b2tlbml6ZXJKU09OLCB0b2tlbml6ZXJDb25maWcpO1xuICAgIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@xenova/transformers/src/tokenizers.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@xenova/transformers/src/transformers.js":
/*!***************************************************************!*\
  !*** ./node_modules/@xenova/transformers/src/transformers.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AlbertForMaskedLM: function() { return /* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.AlbertForMaskedLM; },\n/* harmony export */   AlbertForQuestionAnswering: function() { return /* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.AlbertForQuestionAnswering; },\n/* harmony export */   AlbertForSequenceClassification: function() { return /* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.AlbertForSequenceClassification; },\n/* harmony export */   AlbertModel: function() { return /* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.AlbertModel; },\n/* harmony export */   AlbertPreTrainedModel: function() { return /* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.AlbertPreTrainedModel; },\n/* harmony export */   AlbertTokenizer: function() { return /* reexport safe */ _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.AlbertTokenizer; },\n/* harmony export */   AutoConfig: function() { return /* reexport safe */ _configs_js__WEBPACK_IMPORTED_MODULE_5__.AutoConfig; },\n/* harmony export */   AutoModel: function() { return /* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.AutoModel; },\n/* harmony export */   AutoModelForCausalLM: function() { return /* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.AutoModelForCausalLM; },\n/* harmony export */   AutoModelForImageClassification: function() { return /* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.AutoModelForImageClassification; },\n/* harmony export */   AutoModelForImageSegmentation: function() { return /* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.AutoModelForImageSegmentation; },\n/* harmony export */   AutoModelForMaskGeneration: function() { return /* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.AutoModelForMaskGeneration; },\n/* harmony export */   AutoModelForMaskedLM: function() { return /* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.AutoModelForMaskedLM; },\n/* harmony export */   AutoModelForObjectDetection: function() { return /* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.AutoModelForObjectDetection; },\n/* harmony export */   AutoModelForQuestionAnswering: function() { return /* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.AutoModelForQuestionAnswering; },\n/* harmony export */   AutoModelForSeq2SeqLM: function() { return /* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.AutoModelForSeq2SeqLM; },\n/* harmony export */   AutoModelForSequenceClassification: function() { return /* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.AutoModelForSequenceClassification; },\n/* harmony export */   AutoModelForTokenClassification: function() { return /* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.AutoModelForTokenClassification; },\n/* harmony export */   AutoModelForVision2Seq: function() { return /* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.AutoModelForVision2Seq; },\n/* harmony export */   AutoProcessor: function() { return /* reexport safe */ _processors_js__WEBPACK_IMPORTED_MODULE_4__.AutoProcessor; },\n/* harmony export */   AutoTokenizer: function() { return /* reexport safe */ _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.AutoTokenizer; },\n/* harmony export */   AutomaticSpeechRecognitionPipeline: function() { return /* reexport safe */ _pipelines_js__WEBPACK_IMPORTED_MODULE_0__.AutomaticSpeechRecognitionPipeline; },\n/* harmony export */   BartForConditionalGeneration: function() { return /* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.BartForConditionalGeneration; },\n/* harmony export */   BartForSequenceClassification: function() { return /* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.BartForSequenceClassification; },\n/* harmony export */   BartModel: function() { return /* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.BartModel; },\n/* harmony export */   BartPretrainedModel: function() { return /* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.BartPretrainedModel; },\n/* harmony export */   BartTokenizer: function() { return /* reexport safe */ _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.BartTokenizer; },\n/* harmony export */   BaseModelOutput: function() { return /* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.BaseModelOutput; },\n/* harmony export */   BertForMaskedLM: function() { return /* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.BertForMaskedLM; },\n/* harmony export */   BertForQuestionAnswering: function() { return /* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.BertForQuestionAnswering; },\n/* harmony export */   BertForSequenceClassification: function() { return /* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.BertForSequenceClassification; },\n/* harmony export */   BertForTokenClassification: function() { return /* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.BertForTokenClassification; },\n/* harmony export */   BertModel: function() { return /* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.BertModel; },\n/* harmony export */   BertPreTrainedModel: function() { return /* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.BertPreTrainedModel; },\n/* harmony export */   BertTokenizer: function() { return /* reexport safe */ _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.BertTokenizer; },\n/* harmony export */   BloomTokenizer: function() { return /* reexport safe */ _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.BloomTokenizer; },\n/* harmony export */   CLIPModel: function() { return /* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.CLIPModel; },\n/* harmony export */   CLIPPreTrainedModel: function() { return /* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.CLIPPreTrainedModel; },\n/* harmony export */   CLIPTokenizer: function() { return /* reexport safe */ _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.CLIPTokenizer; },\n/* harmony export */   CausalLMOutputWithPast: function() { return /* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.CausalLMOutputWithPast; },\n/* harmony export */   CodeGenForCausalLM: function() { return /* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.CodeGenForCausalLM; },\n/* harmony export */   CodeGenModel: function() { return /* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.CodeGenModel; },\n/* harmony export */   CodeGenPreTrainedModel: function() { return /* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.CodeGenPreTrainedModel; },\n/* harmony export */   CodeGenTokenizer: function() { return /* reexport safe */ _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.CodeGenTokenizer; },\n/* harmony export */   DetrFeatureExtractor: function() { return /* reexport safe */ _processors_js__WEBPACK_IMPORTED_MODULE_4__.DetrFeatureExtractor; },\n/* harmony export */   DetrForObjectDetection: function() { return /* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.DetrForObjectDetection; },\n/* harmony export */   DetrForSegmentation: function() { return /* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.DetrForSegmentation; },\n/* harmony export */   DetrObjectDetectionOutput: function() { return /* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.DetrObjectDetectionOutput; },\n/* harmony export */   DetrPreTrainedModel: function() { return /* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.DetrPreTrainedModel; },\n/* harmony export */   DetrSegmentationOutput: function() { return /* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.DetrSegmentationOutput; },\n/* harmony export */   DistilBertForMaskedLM: function() { return /* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.DistilBertForMaskedLM; },\n/* harmony export */   DistilBertForQuestionAnswering: function() { return /* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.DistilBertForQuestionAnswering; },\n/* harmony export */   DistilBertForSequenceClassification: function() { return /* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.DistilBertForSequenceClassification; },\n/* harmony export */   DistilBertForTokenClassification: function() { return /* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.DistilBertForTokenClassification; },\n/* harmony export */   DistilBertModel: function() { return /* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.DistilBertModel; },\n/* harmony export */   DistilBertPreTrainedModel: function() { return /* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.DistilBertPreTrainedModel; },\n/* harmony export */   DistilBertTokenizer: function() { return /* reexport safe */ _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.DistilBertTokenizer; },\n/* harmony export */   FFT: function() { return /* reexport safe */ _utils_maths_js__WEBPACK_IMPORTED_MODULE_9__.FFT; },\n/* harmony export */   FalconTokenizer: function() { return /* reexport safe */ _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.FalconTokenizer; },\n/* harmony export */   FeatureExtractionPipeline: function() { return /* reexport safe */ _pipelines_js__WEBPACK_IMPORTED_MODULE_0__.FeatureExtractionPipeline; },\n/* harmony export */   FeatureExtractor: function() { return /* reexport safe */ _processors_js__WEBPACK_IMPORTED_MODULE_4__.FeatureExtractor; },\n/* harmony export */   FillMaskPipeline: function() { return /* reexport safe */ _pipelines_js__WEBPACK_IMPORTED_MODULE_0__.FillMaskPipeline; },\n/* harmony export */   GPT2LMHeadModel: function() { return /* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.GPT2LMHeadModel; },\n/* harmony export */   GPT2Model: function() { return /* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.GPT2Model; },\n/* harmony export */   GPT2PreTrainedModel: function() { return /* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.GPT2PreTrainedModel; },\n/* harmony export */   GPT2Tokenizer: function() { return /* reexport safe */ _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.GPT2Tokenizer; },\n/* harmony export */   GPTNeoForCausalLM: function() { return /* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.GPTNeoForCausalLM; },\n/* harmony export */   GPTNeoModel: function() { return /* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.GPTNeoModel; },\n/* harmony export */   GPTNeoPreTrainedModel: function() { return /* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.GPTNeoPreTrainedModel; },\n/* harmony export */   GPTNeoXTokenizer: function() { return /* reexport safe */ _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.GPTNeoXTokenizer; },\n/* harmony export */   ImageClassificationPipeline: function() { return /* reexport safe */ _pipelines_js__WEBPACK_IMPORTED_MODULE_0__.ImageClassificationPipeline; },\n/* harmony export */   ImageFeatureExtractor: function() { return /* reexport safe */ _processors_js__WEBPACK_IMPORTED_MODULE_4__.ImageFeatureExtractor; },\n/* harmony export */   ImageSegmentationPipeline: function() { return /* reexport safe */ _pipelines_js__WEBPACK_IMPORTED_MODULE_0__.ImageSegmentationPipeline; },\n/* harmony export */   ImageToTextPipeline: function() { return /* reexport safe */ _pipelines_js__WEBPACK_IMPORTED_MODULE_0__.ImageToTextPipeline; },\n/* harmony export */   LlamaTokenizer: function() { return /* reexport safe */ _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.LlamaTokenizer; },\n/* harmony export */   M2M100ForConditionalGeneration: function() { return /* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.M2M100ForConditionalGeneration; },\n/* harmony export */   M2M100Model: function() { return /* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.M2M100Model; },\n/* harmony export */   M2M100PreTrainedModel: function() { return /* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.M2M100PreTrainedModel; },\n/* harmony export */   MPNetTokenizer: function() { return /* reexport safe */ _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.MPNetTokenizer; },\n/* harmony export */   MT5ForConditionalGeneration: function() { return /* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.MT5ForConditionalGeneration; },\n/* harmony export */   MT5Model: function() { return /* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.MT5Model; },\n/* harmony export */   MT5PreTrainedModel: function() { return /* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.MT5PreTrainedModel; },\n/* harmony export */   MarianMTModel: function() { return /* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.MarianMTModel; },\n/* harmony export */   MarianModel: function() { return /* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.MarianModel; },\n/* harmony export */   MarianPreTrainedModel: function() { return /* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.MarianPreTrainedModel; },\n/* harmony export */   MarianTokenizer: function() { return /* reexport safe */ _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.MarianTokenizer; },\n/* harmony export */   MaskedLMOutput: function() { return /* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.MaskedLMOutput; },\n/* harmony export */   MobileBertForMaskedLM: function() { return /* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.MobileBertForMaskedLM; },\n/* harmony export */   MobileBertForQuestionAnswering: function() { return /* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.MobileBertForQuestionAnswering; },\n/* harmony export */   MobileBertForSequenceClassification: function() { return /* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.MobileBertForSequenceClassification; },\n/* harmony export */   MobileBertModel: function() { return /* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.MobileBertModel; },\n/* harmony export */   MobileBertPreTrainedModel: function() { return /* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.MobileBertPreTrainedModel; },\n/* harmony export */   MobileBertTokenizer: function() { return /* reexport safe */ _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.MobileBertTokenizer; },\n/* harmony export */   MobileViTFeatureExtractor: function() { return /* reexport safe */ _processors_js__WEBPACK_IMPORTED_MODULE_4__.MobileViTFeatureExtractor; },\n/* harmony export */   MobileViTForImageClassification: function() { return /* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.MobileViTForImageClassification; },\n/* harmony export */   MobileViTPreTrainedModel: function() { return /* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.MobileViTPreTrainedModel; },\n/* harmony export */   ModelOutput: function() { return /* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.ModelOutput; },\n/* harmony export */   NllbTokenizer: function() { return /* reexport safe */ _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.NllbTokenizer; },\n/* harmony export */   ObjectDetectionPipeline: function() { return /* reexport safe */ _pipelines_js__WEBPACK_IMPORTED_MODULE_0__.ObjectDetectionPipeline; },\n/* harmony export */   Pipeline: function() { return /* reexport safe */ _pipelines_js__WEBPACK_IMPORTED_MODULE_0__.Pipeline; },\n/* harmony export */   PreTrainedModel: function() { return /* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.PreTrainedModel; },\n/* harmony export */   PreTrainedTokenizer: function() { return /* reexport safe */ _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.PreTrainedTokenizer; },\n/* harmony export */   PretrainedConfig: function() { return /* reexport safe */ _configs_js__WEBPACK_IMPORTED_MODULE_5__.PretrainedConfig; },\n/* harmony export */   PretrainedMixin: function() { return /* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.PretrainedMixin; },\n/* harmony export */   Processor: function() { return /* reexport safe */ _processors_js__WEBPACK_IMPORTED_MODULE_4__.Processor; },\n/* harmony export */   QuestionAnsweringModelOutput: function() { return /* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.QuestionAnsweringModelOutput; },\n/* harmony export */   QuestionAnsweringPipeline: function() { return /* reexport safe */ _pipelines_js__WEBPACK_IMPORTED_MODULE_0__.QuestionAnsweringPipeline; },\n/* harmony export */   RawImage: function() { return /* reexport safe */ _utils_image_js__WEBPACK_IMPORTED_MODULE_7__.RawImage; },\n/* harmony export */   RobertaForMaskedLM: function() { return /* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.RobertaForMaskedLM; },\n/* harmony export */   RobertaForQuestionAnswering: function() { return /* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.RobertaForQuestionAnswering; },\n/* harmony export */   RobertaForSequenceClassification: function() { return /* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.RobertaForSequenceClassification; },\n/* harmony export */   RobertaForTokenClassification: function() { return /* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.RobertaForTokenClassification; },\n/* harmony export */   RobertaModel: function() { return /* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.RobertaModel; },\n/* harmony export */   RobertaPreTrainedModel: function() { return /* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.RobertaPreTrainedModel; },\n/* harmony export */   RobertaTokenizer: function() { return /* reexport safe */ _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.RobertaTokenizer; },\n/* harmony export */   SamImageProcessor: function() { return /* reexport safe */ _processors_js__WEBPACK_IMPORTED_MODULE_4__.SamImageProcessor; },\n/* harmony export */   SamImageSegmentationOutput: function() { return /* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.SamImageSegmentationOutput; },\n/* harmony export */   SamModel: function() { return /* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.SamModel; },\n/* harmony export */   SamPreTrainedModel: function() { return /* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.SamPreTrainedModel; },\n/* harmony export */   SamProcessor: function() { return /* reexport safe */ _processors_js__WEBPACK_IMPORTED_MODULE_4__.SamProcessor; },\n/* harmony export */   Seq2SeqLMOutput: function() { return /* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.Seq2SeqLMOutput; },\n/* harmony export */   SequenceClassifierOutput: function() { return /* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.SequenceClassifierOutput; },\n/* harmony export */   SqueezeBertForMaskedLM: function() { return /* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.SqueezeBertForMaskedLM; },\n/* harmony export */   SqueezeBertForQuestionAnswering: function() { return /* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.SqueezeBertForQuestionAnswering; },\n/* harmony export */   SqueezeBertForSequenceClassification: function() { return /* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.SqueezeBertForSequenceClassification; },\n/* harmony export */   SqueezeBertModel: function() { return /* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.SqueezeBertModel; },\n/* harmony export */   SqueezeBertPreTrainedModel: function() { return /* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.SqueezeBertPreTrainedModel; },\n/* harmony export */   SqueezeBertTokenizer: function() { return /* reexport safe */ _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.SqueezeBertTokenizer; },\n/* harmony export */   SummarizationPipeline: function() { return /* reexport safe */ _pipelines_js__WEBPACK_IMPORTED_MODULE_0__.SummarizationPipeline; },\n/* harmony export */   T5ForConditionalGeneration: function() { return /* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.T5ForConditionalGeneration; },\n/* harmony export */   T5Model: function() { return /* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.T5Model; },\n/* harmony export */   T5PreTrainedModel: function() { return /* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.T5PreTrainedModel; },\n/* harmony export */   T5Tokenizer: function() { return /* reexport safe */ _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.T5Tokenizer; },\n/* harmony export */   Tensor: function() { return /* reexport safe */ _utils_tensor_js__WEBPACK_IMPORTED_MODULE_8__.Tensor; },\n/* harmony export */   Text2TextGenerationPipeline: function() { return /* reexport safe */ _pipelines_js__WEBPACK_IMPORTED_MODULE_0__.Text2TextGenerationPipeline; },\n/* harmony export */   TextClassificationPipeline: function() { return /* reexport safe */ _pipelines_js__WEBPACK_IMPORTED_MODULE_0__.TextClassificationPipeline; },\n/* harmony export */   TextGenerationPipeline: function() { return /* reexport safe */ _pipelines_js__WEBPACK_IMPORTED_MODULE_0__.TextGenerationPipeline; },\n/* harmony export */   TokenClassificationPipeline: function() { return /* reexport safe */ _pipelines_js__WEBPACK_IMPORTED_MODULE_0__.TokenClassificationPipeline; },\n/* harmony export */   TokenClassifierOutput: function() { return /* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.TokenClassifierOutput; },\n/* harmony export */   TokenizerModel: function() { return /* reexport safe */ _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.TokenizerModel; },\n/* harmony export */   TranslationPipeline: function() { return /* reexport safe */ _pipelines_js__WEBPACK_IMPORTED_MODULE_0__.TranslationPipeline; },\n/* harmony export */   ViTFeatureExtractor: function() { return /* reexport safe */ _processors_js__WEBPACK_IMPORTED_MODULE_4__.ViTFeatureExtractor; },\n/* harmony export */   ViTForImageClassification: function() { return /* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.ViTForImageClassification; },\n/* harmony export */   ViTPreTrainedModel: function() { return /* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.ViTPreTrainedModel; },\n/* harmony export */   VisionEncoderDecoderModel: function() { return /* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.VisionEncoderDecoderModel; },\n/* harmony export */   WhisperFeatureExtractor: function() { return /* reexport safe */ _processors_js__WEBPACK_IMPORTED_MODULE_4__.WhisperFeatureExtractor; },\n/* harmony export */   WhisperForConditionalGeneration: function() { return /* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.WhisperForConditionalGeneration; },\n/* harmony export */   WhisperModel: function() { return /* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.WhisperModel; },\n/* harmony export */   WhisperPreTrainedModel: function() { return /* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.WhisperPreTrainedModel; },\n/* harmony export */   WhisperProcessor: function() { return /* reexport safe */ _processors_js__WEBPACK_IMPORTED_MODULE_4__.WhisperProcessor; },\n/* harmony export */   WhisperTokenizer: function() { return /* reexport safe */ _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.WhisperTokenizer; },\n/* harmony export */   XLMRobertaForMaskedLM: function() { return /* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.XLMRobertaForMaskedLM; },\n/* harmony export */   XLMRobertaForQuestionAnswering: function() { return /* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.XLMRobertaForQuestionAnswering; },\n/* harmony export */   XLMRobertaForSequenceClassification: function() { return /* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.XLMRobertaForSequenceClassification; },\n/* harmony export */   XLMRobertaForTokenClassification: function() { return /* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.XLMRobertaForTokenClassification; },\n/* harmony export */   XLMRobertaModel: function() { return /* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.XLMRobertaModel; },\n/* harmony export */   XLMRobertaPreTrainedModel: function() { return /* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.XLMRobertaPreTrainedModel; },\n/* harmony export */   XLMRobertaTokenizer: function() { return /* reexport safe */ _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.XLMRobertaTokenizer; },\n/* harmony export */   ZeroShotClassificationPipeline: function() { return /* reexport safe */ _pipelines_js__WEBPACK_IMPORTED_MODULE_0__.ZeroShotClassificationPipeline; },\n/* harmony export */   ZeroShotImageClassificationPipeline: function() { return /* reexport safe */ _pipelines_js__WEBPACK_IMPORTED_MODULE_0__.ZeroShotImageClassificationPipeline; },\n/* harmony export */   cat: function() { return /* reexport safe */ _utils_tensor_js__WEBPACK_IMPORTED_MODULE_8__.cat; },\n/* harmony export */   cos_sim: function() { return /* reexport safe */ _utils_maths_js__WEBPACK_IMPORTED_MODULE_9__.cos_sim; },\n/* harmony export */   dot: function() { return /* reexport safe */ _utils_maths_js__WEBPACK_IMPORTED_MODULE_9__.dot; },\n/* harmony export */   dynamicTimeWarping: function() { return /* reexport safe */ _utils_tensor_js__WEBPACK_IMPORTED_MODULE_8__.dynamicTimeWarping; },\n/* harmony export */   env: function() { return /* reexport safe */ _env_js__WEBPACK_IMPORTED_MODULE_1__.env; },\n/* harmony export */   getMelFilters: function() { return /* reexport safe */ _utils_audio_js__WEBPACK_IMPORTED_MODULE_6__.getMelFilters; },\n/* harmony export */   getTopItems: function() { return /* reexport safe */ _utils_maths_js__WEBPACK_IMPORTED_MODULE_9__.getTopItems; },\n/* harmony export */   interpolate: function() { return /* reexport safe */ _utils_tensor_js__WEBPACK_IMPORTED_MODULE_8__.interpolate; },\n/* harmony export */   interpolate_data: function() { return /* reexport safe */ _utils_maths_js__WEBPACK_IMPORTED_MODULE_9__.interpolate_data; },\n/* harmony export */   log_softmax: function() { return /* reexport safe */ _utils_maths_js__WEBPACK_IMPORTED_MODULE_9__.log_softmax; },\n/* harmony export */   magnitude: function() { return /* reexport safe */ _utils_maths_js__WEBPACK_IMPORTED_MODULE_9__.magnitude; },\n/* harmony export */   max: function() { return /* reexport safe */ _utils_maths_js__WEBPACK_IMPORTED_MODULE_9__.max; },\n/* harmony export */   mean: function() { return /* reexport safe */ _utils_tensor_js__WEBPACK_IMPORTED_MODULE_8__.mean; },\n/* harmony export */   mean_pooling: function() { return /* reexport safe */ _utils_tensor_js__WEBPACK_IMPORTED_MODULE_8__.mean_pooling; },\n/* harmony export */   medianFilter: function() { return /* reexport safe */ _utils_maths_js__WEBPACK_IMPORTED_MODULE_9__.medianFilter; },\n/* harmony export */   min: function() { return /* reexport safe */ _utils_maths_js__WEBPACK_IMPORTED_MODULE_9__.min; },\n/* harmony export */   pipeline: function() { return /* reexport safe */ _pipelines_js__WEBPACK_IMPORTED_MODULE_0__.pipeline; },\n/* harmony export */   read_audio: function() { return /* reexport safe */ _utils_audio_js__WEBPACK_IMPORTED_MODULE_6__.read_audio; },\n/* harmony export */   rfftfreq: function() { return /* reexport safe */ _utils_maths_js__WEBPACK_IMPORTED_MODULE_9__.rfftfreq; },\n/* harmony export */   round: function() { return /* reexport safe */ _utils_maths_js__WEBPACK_IMPORTED_MODULE_9__.round; },\n/* harmony export */   softmax: function() { return /* reexport safe */ _utils_maths_js__WEBPACK_IMPORTED_MODULE_9__.softmax; },\n/* harmony export */   stack: function() { return /* reexport safe */ _utils_tensor_js__WEBPACK_IMPORTED_MODULE_8__.stack; },\n/* harmony export */   std_mean: function() { return /* reexport safe */ _utils_tensor_js__WEBPACK_IMPORTED_MODULE_8__.std_mean; },\n/* harmony export */   transpose: function() { return /* reexport safe */ _utils_tensor_js__WEBPACK_IMPORTED_MODULE_8__.transpose; },\n/* harmony export */   transpose_data: function() { return /* reexport safe */ _utils_maths_js__WEBPACK_IMPORTED_MODULE_9__.transpose_data; }\n/* harmony export */ });\n/* harmony import */ var _pipelines_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./pipelines.js */ \"(app-pages-browser)/./node_modules/@xenova/transformers/src/pipelines.js\");\n/* harmony import */ var _env_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./env.js */ \"(app-pages-browser)/./node_modules/@xenova/transformers/src/env.js\");\n/* harmony import */ var _models_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./models.js */ \"(app-pages-browser)/./node_modules/@xenova/transformers/src/models.js\");\n/* harmony import */ var _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./tokenizers.js */ \"(app-pages-browser)/./node_modules/@xenova/transformers/src/tokenizers.js\");\n/* harmony import */ var _processors_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./processors.js */ \"(app-pages-browser)/./node_modules/@xenova/transformers/src/processors.js\");\n/* harmony import */ var _configs_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./configs.js */ \"(app-pages-browser)/./node_modules/@xenova/transformers/src/configs.js\");\n/* harmony import */ var _utils_audio_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./utils/audio.js */ \"(app-pages-browser)/./node_modules/@xenova/transformers/src/utils/audio.js\");\n/* harmony import */ var _utils_image_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./utils/image.js */ \"(app-pages-browser)/./node_modules/@xenova/transformers/src/utils/image.js\");\n/* harmony import */ var _utils_tensor_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./utils/tensor.js */ \"(app-pages-browser)/./node_modules/@xenova/transformers/src/utils/tensor.js\");\n/* harmony import */ var _utils_maths_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./utils/maths.js */ \"(app-pages-browser)/./node_modules/@xenova/transformers/src/utils/maths.js\");\n// @ts-nocheck\n\n/**\n * @file Entry point for the Transformers.js library. Only the exports from this file\n * are available to the end user, and are grouped as follows:\n * \n * 1. [Pipelines](./pipelines)\n * 2. [Environment variables](./env)\n * 3. [Models](./models)\n * 4. [Tokenizers](./tokenizers)\n * 5. [Processors](./processors)\n * \n * @module transformers\n */\n\n\n\n\n\n\n\n\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AeGVub3ZhL3RyYW5zZm9ybWVycy9zcmMvdHJhbnNmb3JtZXJzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFK0I7QUFDTjtBQUNHO0FBQ0k7QUFDQTtBQUNIOztBQUVJO0FBQ0E7QUFDQztBQUNEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AeGVub3ZhL3RyYW5zZm9ybWVycy9zcmMvdHJhbnNmb3JtZXJzLmpzPzMzNDYiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQHRzLW5vY2hlY2tcblxuLyoqXG4gKiBAZmlsZSBFbnRyeSBwb2ludCBmb3IgdGhlIFRyYW5zZm9ybWVycy5qcyBsaWJyYXJ5LiBPbmx5IHRoZSBleHBvcnRzIGZyb20gdGhpcyBmaWxlXG4gKiBhcmUgYXZhaWxhYmxlIHRvIHRoZSBlbmQgdXNlciwgYW5kIGFyZSBncm91cGVkIGFzIGZvbGxvd3M6XG4gKiBcbiAqIDEuIFtQaXBlbGluZXNdKC4vcGlwZWxpbmVzKVxuICogMi4gW0Vudmlyb25tZW50IHZhcmlhYmxlc10oLi9lbnYpXG4gKiAzLiBbTW9kZWxzXSguL21vZGVscylcbiAqIDQuIFtUb2tlbml6ZXJzXSguL3Rva2VuaXplcnMpXG4gKiA1LiBbUHJvY2Vzc29yc10oLi9wcm9jZXNzb3JzKVxuICogXG4gKiBAbW9kdWxlIHRyYW5zZm9ybWVyc1xuICovXG5cbmV4cG9ydCAqIGZyb20gJy4vcGlwZWxpbmVzLmpzJztcbmV4cG9ydCAqIGZyb20gJy4vZW52LmpzJztcbmV4cG9ydCAqIGZyb20gJy4vbW9kZWxzLmpzJztcbmV4cG9ydCAqIGZyb20gJy4vdG9rZW5pemVycy5qcyc7XG5leHBvcnQgKiBmcm9tICcuL3Byb2Nlc3NvcnMuanMnO1xuZXhwb3J0ICogZnJvbSAnLi9jb25maWdzLmpzJztcblxuZXhwb3J0ICogZnJvbSAnLi91dGlscy9hdWRpby5qcyc7XG5leHBvcnQgKiBmcm9tICcuL3V0aWxzL2ltYWdlLmpzJztcbmV4cG9ydCAqIGZyb20gJy4vdXRpbHMvdGVuc29yLmpzJztcbmV4cG9ydCAqIGZyb20gJy4vdXRpbHMvbWF0aHMuanMnO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@xenova/transformers/src/transformers.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@xenova/transformers/src/utils/audio.js":
/*!**************************************************************!*\
  !*** ./node_modules/@xenova/transformers/src/utils/audio.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getMelFilters: function() { return /* binding */ getMelFilters; },\n/* harmony export */   read_audio: function() { return /* binding */ read_audio; }\n/* harmony export */ });\n/* harmony import */ var _hub_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./hub.js */ \"(app-pages-browser)/./node_modules/@xenova/transformers/src/utils/hub.js\");\n/* harmony import */ var _maths_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./maths.js */ \"(app-pages-browser)/./node_modules/@xenova/transformers/src/utils/maths.js\");\n/**\n * @file Helper module for audio processing. \n * \n * These functions and classes are only used internally, \n * meaning an end-user shouldn't need to access anything here.\n * \n * @module utils/audio\n */\n\n\n\n\n/**\n * Helper function to read audio from a path/URL.\n * @param {string|URL} url The path/URL to load the audio from.\n * @param {number} sampling_rate The sampling rate to use when decoding the audio.\n * @returns {Promise<Float32Array>} The decoded audio as a `Float32Array`.\n */\nasync function read_audio(url, sampling_rate) {\n    if (typeof AudioContext === 'undefined') {\n        // Running in node or an environment without AudioContext\n        throw Error(\n            \"Unable to load audio from path/URL since `AudioContext` is not available in your environment. \" +\n            \"Instead, audio data should be passed directly to the pipeline/processor. \" +\n            \"For more information and some example code, see https://huggingface.co/docs/transformers.js/tutorials/node-audio-processing.\"\n        )\n    }\n\n    const response = await (await (0,_hub_js__WEBPACK_IMPORTED_MODULE_0__.getFile)(url)).arrayBuffer();\n    const audioCTX = new AudioContext({ sampleRate: sampling_rate });\n    if (typeof sampling_rate === 'undefined') {\n        console.warn(`No sampling rate provided, using default of ${audioCTX.sampleRate}Hz.`)\n    }\n    const decoded = await audioCTX.decodeAudioData(response);\n    let audio;\n\n    // We now replicate HuggingFace's `ffmpeg_read` method:\n    if (decoded.numberOfChannels === 2) {\n        // When downmixing a stereo audio file to mono using the -ac 1 option in FFmpeg,\n        // the audio signal is summed across both channels to create a single mono channel.\n        // However, if the audio is at full scale (i.e. the highest possible volume level),\n        // the summing of the two channels can cause the audio signal to clip or distort.\n\n        // To prevent this clipping, FFmpeg applies a scaling factor of 1/sqrt(2) (~ 0.707)\n        // to the audio signal before summing the two channels. This scaling factor ensures\n        // that the combined audio signal will not exceed the maximum possible level, even\n        // if both channels are at full scale.\n\n        // After applying this scaling factor, the audio signal from both channels is summed\n        // to create a single mono channel. It's worth noting that this scaling factor is\n        // only applied when downmixing stereo audio to mono using the -ac 1 option in FFmpeg.\n        // If you're using a different downmixing method, or if you're not downmixing the\n        // audio at all, this scaling factor may not be needed.\n        const SCALING_FACTOR = Math.sqrt(2);\n\n        let left = decoded.getChannelData(0);\n        let right = decoded.getChannelData(1);\n\n        audio = new Float32Array(left.length);\n        for (let i = 0; i < decoded.length; ++i) {\n            audio[i] = SCALING_FACTOR * (left[i] + right[i]) / 2;\n        }\n\n    } else {\n        // If the audio is not stereo, we can just use the first channel:\n        audio = decoded.getChannelData(0);\n    }\n\n    return audio;\n}\n\n/**\n * Creates a frequency bin conversion matrix used to obtain a mel spectrogram.\n * @param {number} sr Sample rate of the audio waveform.\n * @param {number} n_fft Number of frequencies used to compute the spectrogram (should be the same as in `stft`).\n * @param {number} n_mels Number of mel filters to generate.\n * @returns {number[][]} Projection matrix to go from a spectrogram to a mel spectrogram.\n */\nfunction getMelFilters(sr, n_fft, n_mels = 128) {\n    n_mels = Math.floor(n_mels);\n\n    // Initialize the weights\n    const mel_size = Math.floor(1 + n_fft / 2);\n    const weights = new Array(n_mels);\n\n    // Center freqs of each FFT bin\n    const fftfreqs = (0,_maths_js__WEBPACK_IMPORTED_MODULE_1__.rfftfreq)(n_fft, 1 / sr);\n\n    // 'Center freqs' of mel bands - uniformly spaced between limits\n    const min_mel = 0.0;\n    const max_mel = 45.245640471924965;\n    const mel_range = max_mel - min_mel;\n    const mel_scale = mel_range / (n_mels + 1);\n\n    // Fill in the linear scale\n    const f_min = 0.0;\n    const f_sp = 200.0 / 3;\n    const freqs = new Array(n_mels + 2);\n\n    // And now the nonlinear scale\n    const min_log_hz = 1000.0; // beginning of log region (Hz)\n    const min_log_mel = (min_log_hz - f_min) / f_sp; // same (Mels)\n    const logstep = Math.log(6.4) / 27.0; // step size for log region\n\n    const ramps = new Array(freqs.length);\n    for (let i = 0; i < freqs.length; ++i) {\n        const mel = i * mel_scale + min_mel;\n        if (mel >= min_log_mel) {\n            freqs[i] = min_log_hz * Math.exp(logstep * (mel - min_log_mel));\n        } else {\n            freqs[i] = f_min + f_sp * mel;\n        }\n        ramps[i] = fftfreqs.map(k => freqs[i] - k);\n    }\n\n    const fdiffinv = freqs.slice(1).map((v, i) => 1 / (v - freqs[i]));\n\n    for (let i = 0; i < weights.length; ++i) {\n        weights[i] = new Array(mel_size);\n\n        const a = fdiffinv[i];\n        const b = fdiffinv[i + 1];\n        const c = ramps[i];\n        const d = ramps[i + 2];\n\n        // Slaney-style mel is scaled to be approx constant energy per channel\n        const enorm = 2.0 / (freqs[i + 2] - freqs[i]);\n\n        for (let j = 0; j < weights[i].length; ++j) {\n            // lower and upper slopes for all bins\n            const lower = -c[j] * a;\n            const upper = d[j] * b;\n            weights[i][j] = Math.max(0, Math.min(lower, upper)) * enorm;\n        }\n    }\n\n    return weights;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AeGVub3ZhL3RyYW5zZm9ybWVycy9zcmMvdXRpbHMvYXVkaW8uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBSWtCO0FBQ29COztBQUV0QztBQUNBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCLFdBQVcsUUFBUTtBQUNuQixhQUFhLHVCQUF1QjtBQUNwQztBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQ0FBa0MsZ0RBQU87QUFDekMsd0NBQXdDLDJCQUEyQjtBQUNuRTtBQUNBLG9FQUFvRSxvQkFBb0I7QUFDeEY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHdCQUF3QixvQkFBb0I7QUFDNUM7QUFDQTs7QUFFQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLGFBQWEsWUFBWTtBQUN6QjtBQUNPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUJBQXFCLG1EQUFROztBQUU3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsK0JBQStCO0FBQy9CLHFEQUFxRDtBQUNyRCwwQ0FBMEM7O0FBRTFDO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsb0JBQW9CLG9CQUFvQjtBQUN4Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHdCQUF3Qix1QkFBdUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B4ZW5vdmEvdHJhbnNmb3JtZXJzL3NyYy91dGlscy9hdWRpby5qcz8yM2Y0Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGZpbGUgSGVscGVyIG1vZHVsZSBmb3IgYXVkaW8gcHJvY2Vzc2luZy4gXG4gKiBcbiAqIFRoZXNlIGZ1bmN0aW9ucyBhbmQgY2xhc3NlcyBhcmUgb25seSB1c2VkIGludGVybmFsbHksIFxuICogbWVhbmluZyBhbiBlbmQtdXNlciBzaG91bGRuJ3QgbmVlZCB0byBhY2Nlc3MgYW55dGhpbmcgaGVyZS5cbiAqIFxuICogQG1vZHVsZSB1dGlscy9hdWRpb1xuICovXG5cbmltcG9ydCB7XG4gICAgZ2V0RmlsZSxcbn0gZnJvbSAnLi9odWIuanMnO1xuaW1wb3J0IHsgcmZmdGZyZXEgfSBmcm9tICcuL21hdGhzLmpzJztcblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdG8gcmVhZCBhdWRpbyBmcm9tIGEgcGF0aC9VUkwuXG4gKiBAcGFyYW0ge3N0cmluZ3xVUkx9IHVybCBUaGUgcGF0aC9VUkwgdG8gbG9hZCB0aGUgYXVkaW8gZnJvbS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzYW1wbGluZ19yYXRlIFRoZSBzYW1wbGluZyByYXRlIHRvIHVzZSB3aGVuIGRlY29kaW5nIHRoZSBhdWRpby5cbiAqIEByZXR1cm5zIHtQcm9taXNlPEZsb2F0MzJBcnJheT59IFRoZSBkZWNvZGVkIGF1ZGlvIGFzIGEgYEZsb2F0MzJBcnJheWAuXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiByZWFkX2F1ZGlvKHVybCwgc2FtcGxpbmdfcmF0ZSkge1xuICAgIGlmICh0eXBlb2YgQXVkaW9Db250ZXh0ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAvLyBSdW5uaW5nIGluIG5vZGUgb3IgYW4gZW52aXJvbm1lbnQgd2l0aG91dCBBdWRpb0NvbnRleHRcbiAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICBcIlVuYWJsZSB0byBsb2FkIGF1ZGlvIGZyb20gcGF0aC9VUkwgc2luY2UgYEF1ZGlvQ29udGV4dGAgaXMgbm90IGF2YWlsYWJsZSBpbiB5b3VyIGVudmlyb25tZW50LiBcIiArXG4gICAgICAgICAgICBcIkluc3RlYWQsIGF1ZGlvIGRhdGEgc2hvdWxkIGJlIHBhc3NlZCBkaXJlY3RseSB0byB0aGUgcGlwZWxpbmUvcHJvY2Vzc29yLiBcIiArXG4gICAgICAgICAgICBcIkZvciBtb3JlIGluZm9ybWF0aW9uIGFuZCBzb21lIGV4YW1wbGUgY29kZSwgc2VlIGh0dHBzOi8vaHVnZ2luZ2ZhY2UuY28vZG9jcy90cmFuc2Zvcm1lcnMuanMvdHV0b3JpYWxzL25vZGUtYXVkaW8tcHJvY2Vzc2luZy5cIlxuICAgICAgICApXG4gICAgfVxuXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCAoYXdhaXQgZ2V0RmlsZSh1cmwpKS5hcnJheUJ1ZmZlcigpO1xuICAgIGNvbnN0IGF1ZGlvQ1RYID0gbmV3IEF1ZGlvQ29udGV4dCh7IHNhbXBsZVJhdGU6IHNhbXBsaW5nX3JhdGUgfSk7XG4gICAgaWYgKHR5cGVvZiBzYW1wbGluZ19yYXRlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBjb25zb2xlLndhcm4oYE5vIHNhbXBsaW5nIHJhdGUgcHJvdmlkZWQsIHVzaW5nIGRlZmF1bHQgb2YgJHthdWRpb0NUWC5zYW1wbGVSYXRlfUh6LmApXG4gICAgfVxuICAgIGNvbnN0IGRlY29kZWQgPSBhd2FpdCBhdWRpb0NUWC5kZWNvZGVBdWRpb0RhdGEocmVzcG9uc2UpO1xuICAgIGxldCBhdWRpbztcblxuICAgIC8vIFdlIG5vdyByZXBsaWNhdGUgSHVnZ2luZ0ZhY2UncyBgZmZtcGVnX3JlYWRgIG1ldGhvZDpcbiAgICBpZiAoZGVjb2RlZC5udW1iZXJPZkNoYW5uZWxzID09PSAyKSB7XG4gICAgICAgIC8vIFdoZW4gZG93bm1peGluZyBhIHN0ZXJlbyBhdWRpbyBmaWxlIHRvIG1vbm8gdXNpbmcgdGhlIC1hYyAxIG9wdGlvbiBpbiBGRm1wZWcsXG4gICAgICAgIC8vIHRoZSBhdWRpbyBzaWduYWwgaXMgc3VtbWVkIGFjcm9zcyBib3RoIGNoYW5uZWxzIHRvIGNyZWF0ZSBhIHNpbmdsZSBtb25vIGNoYW5uZWwuXG4gICAgICAgIC8vIEhvd2V2ZXIsIGlmIHRoZSBhdWRpbyBpcyBhdCBmdWxsIHNjYWxlIChpLmUuIHRoZSBoaWdoZXN0IHBvc3NpYmxlIHZvbHVtZSBsZXZlbCksXG4gICAgICAgIC8vIHRoZSBzdW1taW5nIG9mIHRoZSB0d28gY2hhbm5lbHMgY2FuIGNhdXNlIHRoZSBhdWRpbyBzaWduYWwgdG8gY2xpcCBvciBkaXN0b3J0LlxuXG4gICAgICAgIC8vIFRvIHByZXZlbnQgdGhpcyBjbGlwcGluZywgRkZtcGVnIGFwcGxpZXMgYSBzY2FsaW5nIGZhY3RvciBvZiAxL3NxcnQoMikgKH4gMC43MDcpXG4gICAgICAgIC8vIHRvIHRoZSBhdWRpbyBzaWduYWwgYmVmb3JlIHN1bW1pbmcgdGhlIHR3byBjaGFubmVscy4gVGhpcyBzY2FsaW5nIGZhY3RvciBlbnN1cmVzXG4gICAgICAgIC8vIHRoYXQgdGhlIGNvbWJpbmVkIGF1ZGlvIHNpZ25hbCB3aWxsIG5vdCBleGNlZWQgdGhlIG1heGltdW0gcG9zc2libGUgbGV2ZWwsIGV2ZW5cbiAgICAgICAgLy8gaWYgYm90aCBjaGFubmVscyBhcmUgYXQgZnVsbCBzY2FsZS5cblxuICAgICAgICAvLyBBZnRlciBhcHBseWluZyB0aGlzIHNjYWxpbmcgZmFjdG9yLCB0aGUgYXVkaW8gc2lnbmFsIGZyb20gYm90aCBjaGFubmVscyBpcyBzdW1tZWRcbiAgICAgICAgLy8gdG8gY3JlYXRlIGEgc2luZ2xlIG1vbm8gY2hhbm5lbC4gSXQncyB3b3J0aCBub3RpbmcgdGhhdCB0aGlzIHNjYWxpbmcgZmFjdG9yIGlzXG4gICAgICAgIC8vIG9ubHkgYXBwbGllZCB3aGVuIGRvd25taXhpbmcgc3RlcmVvIGF1ZGlvIHRvIG1vbm8gdXNpbmcgdGhlIC1hYyAxIG9wdGlvbiBpbiBGRm1wZWcuXG4gICAgICAgIC8vIElmIHlvdSdyZSB1c2luZyBhIGRpZmZlcmVudCBkb3dubWl4aW5nIG1ldGhvZCwgb3IgaWYgeW91J3JlIG5vdCBkb3dubWl4aW5nIHRoZVxuICAgICAgICAvLyBhdWRpbyBhdCBhbGwsIHRoaXMgc2NhbGluZyBmYWN0b3IgbWF5IG5vdCBiZSBuZWVkZWQuXG4gICAgICAgIGNvbnN0IFNDQUxJTkdfRkFDVE9SID0gTWF0aC5zcXJ0KDIpO1xuXG4gICAgICAgIGxldCBsZWZ0ID0gZGVjb2RlZC5nZXRDaGFubmVsRGF0YSgwKTtcbiAgICAgICAgbGV0IHJpZ2h0ID0gZGVjb2RlZC5nZXRDaGFubmVsRGF0YSgxKTtcblxuICAgICAgICBhdWRpbyA9IG5ldyBGbG9hdDMyQXJyYXkobGVmdC5sZW5ndGgpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRlY29kZWQubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGF1ZGlvW2ldID0gU0NBTElOR19GQUNUT1IgKiAobGVmdFtpXSArIHJpZ2h0W2ldKSAvIDI7XG4gICAgICAgIH1cblxuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIElmIHRoZSBhdWRpbyBpcyBub3Qgc3RlcmVvLCB3ZSBjYW4ganVzdCB1c2UgdGhlIGZpcnN0IGNoYW5uZWw6XG4gICAgICAgIGF1ZGlvID0gZGVjb2RlZC5nZXRDaGFubmVsRGF0YSgwKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXVkaW87XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZyZXF1ZW5jeSBiaW4gY29udmVyc2lvbiBtYXRyaXggdXNlZCB0byBvYnRhaW4gYSBtZWwgc3BlY3Ryb2dyYW0uXG4gKiBAcGFyYW0ge251bWJlcn0gc3IgU2FtcGxlIHJhdGUgb2YgdGhlIGF1ZGlvIHdhdmVmb3JtLlxuICogQHBhcmFtIHtudW1iZXJ9IG5fZmZ0IE51bWJlciBvZiBmcmVxdWVuY2llcyB1c2VkIHRvIGNvbXB1dGUgdGhlIHNwZWN0cm9ncmFtIChzaG91bGQgYmUgdGhlIHNhbWUgYXMgaW4gYHN0ZnRgKS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBuX21lbHMgTnVtYmVyIG9mIG1lbCBmaWx0ZXJzIHRvIGdlbmVyYXRlLlxuICogQHJldHVybnMge251bWJlcltdW119IFByb2plY3Rpb24gbWF0cml4IHRvIGdvIGZyb20gYSBzcGVjdHJvZ3JhbSB0byBhIG1lbCBzcGVjdHJvZ3JhbS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldE1lbEZpbHRlcnMoc3IsIG5fZmZ0LCBuX21lbHMgPSAxMjgpIHtcbiAgICBuX21lbHMgPSBNYXRoLmZsb29yKG5fbWVscyk7XG5cbiAgICAvLyBJbml0aWFsaXplIHRoZSB3ZWlnaHRzXG4gICAgY29uc3QgbWVsX3NpemUgPSBNYXRoLmZsb29yKDEgKyBuX2ZmdCAvIDIpO1xuICAgIGNvbnN0IHdlaWdodHMgPSBuZXcgQXJyYXkobl9tZWxzKTtcblxuICAgIC8vIENlbnRlciBmcmVxcyBvZiBlYWNoIEZGVCBiaW5cbiAgICBjb25zdCBmZnRmcmVxcyA9IHJmZnRmcmVxKG5fZmZ0LCAxIC8gc3IpO1xuXG4gICAgLy8gJ0NlbnRlciBmcmVxcycgb2YgbWVsIGJhbmRzIC0gdW5pZm9ybWx5IHNwYWNlZCBiZXR3ZWVuIGxpbWl0c1xuICAgIGNvbnN0IG1pbl9tZWwgPSAwLjA7XG4gICAgY29uc3QgbWF4X21lbCA9IDQ1LjI0NTY0MDQ3MTkyNDk2NTtcbiAgICBjb25zdCBtZWxfcmFuZ2UgPSBtYXhfbWVsIC0gbWluX21lbDtcbiAgICBjb25zdCBtZWxfc2NhbGUgPSBtZWxfcmFuZ2UgLyAobl9tZWxzICsgMSk7XG5cbiAgICAvLyBGaWxsIGluIHRoZSBsaW5lYXIgc2NhbGVcbiAgICBjb25zdCBmX21pbiA9IDAuMDtcbiAgICBjb25zdCBmX3NwID0gMjAwLjAgLyAzO1xuICAgIGNvbnN0IGZyZXFzID0gbmV3IEFycmF5KG5fbWVscyArIDIpO1xuXG4gICAgLy8gQW5kIG5vdyB0aGUgbm9ubGluZWFyIHNjYWxlXG4gICAgY29uc3QgbWluX2xvZ19oeiA9IDEwMDAuMDsgLy8gYmVnaW5uaW5nIG9mIGxvZyByZWdpb24gKEh6KVxuICAgIGNvbnN0IG1pbl9sb2dfbWVsID0gKG1pbl9sb2dfaHogLSBmX21pbikgLyBmX3NwOyAvLyBzYW1lIChNZWxzKVxuICAgIGNvbnN0IGxvZ3N0ZXAgPSBNYXRoLmxvZyg2LjQpIC8gMjcuMDsgLy8gc3RlcCBzaXplIGZvciBsb2cgcmVnaW9uXG5cbiAgICBjb25zdCByYW1wcyA9IG5ldyBBcnJheShmcmVxcy5sZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZnJlcXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY29uc3QgbWVsID0gaSAqIG1lbF9zY2FsZSArIG1pbl9tZWw7XG4gICAgICAgIGlmIChtZWwgPj0gbWluX2xvZ19tZWwpIHtcbiAgICAgICAgICAgIGZyZXFzW2ldID0gbWluX2xvZ19oeiAqIE1hdGguZXhwKGxvZ3N0ZXAgKiAobWVsIC0gbWluX2xvZ19tZWwpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZyZXFzW2ldID0gZl9taW4gKyBmX3NwICogbWVsO1xuICAgICAgICB9XG4gICAgICAgIHJhbXBzW2ldID0gZmZ0ZnJlcXMubWFwKGsgPT4gZnJlcXNbaV0gLSBrKTtcbiAgICB9XG5cbiAgICBjb25zdCBmZGlmZmludiA9IGZyZXFzLnNsaWNlKDEpLm1hcCgodiwgaSkgPT4gMSAvICh2IC0gZnJlcXNbaV0pKTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgd2VpZ2h0cy5sZW5ndGg7ICsraSkge1xuICAgICAgICB3ZWlnaHRzW2ldID0gbmV3IEFycmF5KG1lbF9zaXplKTtcblxuICAgICAgICBjb25zdCBhID0gZmRpZmZpbnZbaV07XG4gICAgICAgIGNvbnN0IGIgPSBmZGlmZmludltpICsgMV07XG4gICAgICAgIGNvbnN0IGMgPSByYW1wc1tpXTtcbiAgICAgICAgY29uc3QgZCA9IHJhbXBzW2kgKyAyXTtcblxuICAgICAgICAvLyBTbGFuZXktc3R5bGUgbWVsIGlzIHNjYWxlZCB0byBiZSBhcHByb3ggY29uc3RhbnQgZW5lcmd5IHBlciBjaGFubmVsXG4gICAgICAgIGNvbnN0IGVub3JtID0gMi4wIC8gKGZyZXFzW2kgKyAyXSAtIGZyZXFzW2ldKTtcblxuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHdlaWdodHNbaV0ubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICAgIC8vIGxvd2VyIGFuZCB1cHBlciBzbG9wZXMgZm9yIGFsbCBiaW5zXG4gICAgICAgICAgICBjb25zdCBsb3dlciA9IC1jW2pdICogYTtcbiAgICAgICAgICAgIGNvbnN0IHVwcGVyID0gZFtqXSAqIGI7XG4gICAgICAgICAgICB3ZWlnaHRzW2ldW2pdID0gTWF0aC5tYXgoMCwgTWF0aC5taW4obG93ZXIsIHVwcGVyKSkgKiBlbm9ybTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB3ZWlnaHRzO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@xenova/transformers/src/utils/audio.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@xenova/transformers/src/utils/core.js":
/*!*************************************************************!*\
  !*** ./node_modules/@xenova/transformers/src/utils/core.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Callable: function() { return /* binding */ Callable; },\n/* harmony export */   calculateDimensions: function() { return /* binding */ calculateDimensions; },\n/* harmony export */   dispatchCallback: function() { return /* binding */ dispatchCallback; },\n/* harmony export */   escapeRegExp: function() { return /* binding */ escapeRegExp; },\n/* harmony export */   exists: function() { return /* binding */ exists; },\n/* harmony export */   isIntegralNumber: function() { return /* binding */ isIntegralNumber; },\n/* harmony export */   isString: function() { return /* binding */ isString; },\n/* harmony export */   isTypedArray: function() { return /* binding */ isTypedArray; },\n/* harmony export */   mergeArrays: function() { return /* binding */ mergeArrays; },\n/* harmony export */   pop: function() { return /* binding */ pop; },\n/* harmony export */   reverseDictionary: function() { return /* binding */ reverseDictionary; }\n/* harmony export */ });\n\n/**\n * @file Core utility functions/classes for Transformers.js.\n * \n * These are only used internally, meaning an end-user shouldn't\n * need to access anything here.\n * \n * @module utils/core\n */\n\n/**\n * Helper function to dispatch progress callbacks.\n *\n * @param {function} progress_callback The progress callback function to dispatch.\n * @param {any} data The data to pass to the progress callback function.\n * @returns {void}\n * @private\n */\nfunction dispatchCallback(progress_callback, data) {\n    if (progress_callback !== null) progress_callback(data);\n}\n\n/**\n * Reverses the keys and values of an object.\n *\n * @param {Object} data The object to reverse.\n * @returns {Object} The reversed object.\n * @see https://ultimatecourses.com/blog/reverse-object-keys-and-values-in-javascript\n */\nfunction reverseDictionary(data) {\n    // https://ultimatecourses.com/blog/reverse-object-keys-and-values-in-javascript\n    return Object.fromEntries(Object.entries(data).map(([key, value]) => [value, key]));\n}\n\n/**\n * Escapes regular expression special characters from a string by replacing them with their escaped counterparts.\n *\n * @param {string} string The string to escape.\n * @returns {string} The escaped string.\n */\nfunction escapeRegExp(string) {\n    return string.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&'); // $& means the whole matched string\n}\n\n/**\n * A base class for creating callable objects.\n * \n * @type {new () => {(...args: any[]): any, _call(...args: any[]): any}}\n */\nconst Callable = /** @type {any} */ (class {\n    /**\n    * Creates a new instance of the Callable class.\n    */\n    constructor() {\n        /**\n         * Creates a closure that delegates to a private method '_call' with the given arguments.\n         * @type {any}\n         * @param {...any} args Zero or more arguments to pass to the '_call' method.\n         * @returns {*} The result of calling the '_call' method.\n         */\n        let closure = function (...args) {\n            return closure._call(...args)\n        }\n        return Object.setPrototypeOf(closure, new.target.prototype)\n    }\n\n    /**\n     * This method should be implemented in subclasses to provide the\n     * functionality of the callable object.\n     *\n     * @param {any[]} args\n     * @throws {Error} If the subclass does not implement the `_call` method.\n     */\n    _call(...args) {\n        throw Error('Must implement _call method in subclass')\n    }\n});\n\n\n/**\n * Check if a value is a string.\n * @param {*} text The value to check.\n * @returns {boolean} True if the value is a string, false otherwise.\n */\nfunction isString(text) {\n    return typeof text === 'string' || text instanceof String\n}\n\n\n/**\n * Check if a value is a typed array.\n * @param {*} val The value to check.\n * @returns {boolean} True if the value is a `TypedArray`, false otherwise.\n * \n * Adapted from https://stackoverflow.com/a/71091338/13989043\n */\nfunction isTypedArray(val) {\n    return val?.prototype?.__proto__?.constructor?.name === 'TypedArray';\n}\n\n\n/**\n * Check if a value is an integer.\n * @param {*} x The value to check.\n * @returns {boolean} True if the value is a string, false otherwise.\n */\nfunction isIntegralNumber(x) {\n    return Number.isInteger(x) || typeof x === 'bigint'\n}\n\n/**\n * Check if a value is exists.\n * @param {*} x The value to check.\n * @returns {boolean} True if the value exists, false otherwise.\n */\nfunction exists(x) {\n    return x !== undefined && x !== null;\n}\n\n/**\n * Calculates the dimensions of a nested array.\n *\n * @param {Array} arr The nested array to calculate dimensions for.\n * @returns {Array} An array containing the dimensions of the input array.\n */\nfunction calculateDimensions(arr) {\n    const dimensions = [];\n    let current = arr;\n    while (Array.isArray(current)) {\n        dimensions.push(current.length);\n        current = current[0];\n    }\n    return dimensions;\n}\n\n/**\n * Replicate python's .pop() method for objects.\n * @param {Object} obj The object to pop from.\n * @param {string} key The key to pop.\n * @param {*} defaultValue The default value to return if the key does not exist.\n * @returns {*} The value of the popped key.\n * @throws {Error} If the key does not exist and no default value is provided.\n */\nfunction pop(obj, key, defaultValue = undefined) {\n    const value = obj[key];\n    if (value !== undefined) {\n        delete obj[key];\n        return value;\n    }\n    if (defaultValue === undefined) {\n        throw Error(`Key ${key} does not exist in object.`)\n    }\n    return defaultValue;\n}\n\n/**\n * Efficiently merge arrays, creating a new copy.\n * Adapted from https://stackoverflow.com/a/6768642/13989043\n * @param  {...any} arrs Arrays to merge.\n * @returns The merged array.\n */\nfunction mergeArrays(...arrs) {\n    return Array.prototype.concat.apply([], arrs);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AeGVub3ZhL3RyYW5zZm9ybWVycy9zcmMvdXRpbHMvY29yZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQixXQUFXLEtBQUs7QUFDaEIsYUFBYTtBQUNiO0FBQ0E7QUFDTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsUUFBUTtBQUNyQjtBQUNPO0FBQ1Asb0NBQW9DLHNCQUFzQjtBQUMxRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFdBQVc7QUFDckI7QUFDTyw0QkFBNEIsS0FBSztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEIsbUJBQW1CLFFBQVE7QUFDM0IscUJBQXFCLEdBQUc7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLGFBQWEsU0FBUztBQUN0QjtBQUNPO0FBQ1A7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxhQUFhLFNBQVM7QUFDdEI7QUFDTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLGFBQWEsU0FBUztBQUN0QjtBQUNPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsR0FBRztBQUNkLGFBQWEsR0FBRztBQUNoQixZQUFZLE9BQU87QUFDbkI7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixLQUFLO0FBQ2hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNPO0FBQ1A7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHhlbm92YS90cmFuc2Zvcm1lcnMvc3JjL3V0aWxzL2NvcmUuanM/NmIyOSJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qKlxuICogQGZpbGUgQ29yZSB1dGlsaXR5IGZ1bmN0aW9ucy9jbGFzc2VzIGZvciBUcmFuc2Zvcm1lcnMuanMuXG4gKiBcbiAqIFRoZXNlIGFyZSBvbmx5IHVzZWQgaW50ZXJuYWxseSwgbWVhbmluZyBhbiBlbmQtdXNlciBzaG91bGRuJ3RcbiAqIG5lZWQgdG8gYWNjZXNzIGFueXRoaW5nIGhlcmUuXG4gKiBcbiAqIEBtb2R1bGUgdXRpbHMvY29yZVxuICovXG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRvIGRpc3BhdGNoIHByb2dyZXNzIGNhbGxiYWNrcy5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBwcm9ncmVzc19jYWxsYmFjayBUaGUgcHJvZ3Jlc3MgY2FsbGJhY2sgZnVuY3Rpb24gdG8gZGlzcGF0Y2guXG4gKiBAcGFyYW0ge2FueX0gZGF0YSBUaGUgZGF0YSB0byBwYXNzIHRvIHRoZSBwcm9ncmVzcyBjYWxsYmFjayBmdW5jdGlvbi5cbiAqIEByZXR1cm5zIHt2b2lkfVxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRpc3BhdGNoQ2FsbGJhY2socHJvZ3Jlc3NfY2FsbGJhY2ssIGRhdGEpIHtcbiAgICBpZiAocHJvZ3Jlc3NfY2FsbGJhY2sgIT09IG51bGwpIHByb2dyZXNzX2NhbGxiYWNrKGRhdGEpO1xufVxuXG4vKipcbiAqIFJldmVyc2VzIHRoZSBrZXlzIGFuZCB2YWx1ZXMgb2YgYW4gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIFRoZSBvYmplY3QgdG8gcmV2ZXJzZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSByZXZlcnNlZCBvYmplY3QuXG4gKiBAc2VlIGh0dHBzOi8vdWx0aW1hdGVjb3Vyc2VzLmNvbS9ibG9nL3JldmVyc2Utb2JqZWN0LWtleXMtYW5kLXZhbHVlcy1pbi1qYXZhc2NyaXB0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXZlcnNlRGljdGlvbmFyeShkYXRhKSB7XG4gICAgLy8gaHR0cHM6Ly91bHRpbWF0ZWNvdXJzZXMuY29tL2Jsb2cvcmV2ZXJzZS1vYmplY3Qta2V5cy1hbmQtdmFsdWVzLWluLWphdmFzY3JpcHRcbiAgICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKE9iamVjdC5lbnRyaWVzKGRhdGEpLm1hcCgoW2tleSwgdmFsdWVdKSA9PiBbdmFsdWUsIGtleV0pKTtcbn1cblxuLyoqXG4gKiBFc2NhcGVzIHJlZ3VsYXIgZXhwcmVzc2lvbiBzcGVjaWFsIGNoYXJhY3RlcnMgZnJvbSBhIHN0cmluZyBieSByZXBsYWNpbmcgdGhlbSB3aXRoIHRoZWlyIGVzY2FwZWQgY291bnRlcnBhcnRzLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBlc2NhcGUuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgZXNjYXBlZCBzdHJpbmcuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlc2NhcGVSZWdFeHAoc3RyaW5nKSB7XG4gICAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKC9bLiorP14ke30oKXxbXFxdXFxcXF0vZywgJ1xcXFwkJicpOyAvLyAkJiBtZWFucyB0aGUgd2hvbGUgbWF0Y2hlZCBzdHJpbmdcbn1cblxuLyoqXG4gKiBBIGJhc2UgY2xhc3MgZm9yIGNyZWF0aW5nIGNhbGxhYmxlIG9iamVjdHMuXG4gKiBcbiAqIEB0eXBlIHtuZXcgKCkgPT4geyguLi5hcmdzOiBhbnlbXSk6IGFueSwgX2NhbGwoLi4uYXJnczogYW55W10pOiBhbnl9fVxuICovXG5leHBvcnQgY29uc3QgQ2FsbGFibGUgPSAvKiogQHR5cGUge2FueX0gKi8gKGNsYXNzIHtcbiAgICAvKipcbiAgICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgdGhlIENhbGxhYmxlIGNsYXNzLlxuICAgICovXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgY2xvc3VyZSB0aGF0IGRlbGVnYXRlcyB0byBhIHByaXZhdGUgbWV0aG9kICdfY2FsbCcgd2l0aCB0aGUgZ2l2ZW4gYXJndW1lbnRzLlxuICAgICAgICAgKiBAdHlwZSB7YW55fVxuICAgICAgICAgKiBAcGFyYW0gey4uLmFueX0gYXJncyBaZXJvIG9yIG1vcmUgYXJndW1lbnRzIHRvIHBhc3MgdG8gdGhlICdfY2FsbCcgbWV0aG9kLlxuICAgICAgICAgKiBAcmV0dXJucyB7Kn0gVGhlIHJlc3VsdCBvZiBjYWxsaW5nIHRoZSAnX2NhbGwnIG1ldGhvZC5cbiAgICAgICAgICovXG4gICAgICAgIGxldCBjbG9zdXJlID0gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgICAgIHJldHVybiBjbG9zdXJlLl9jYWxsKC4uLmFyZ3MpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE9iamVjdC5zZXRQcm90b3R5cGVPZihjbG9zdXJlLCBuZXcudGFyZ2V0LnByb3RvdHlwZSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBzaG91bGQgYmUgaW1wbGVtZW50ZWQgaW4gc3ViY2xhc3NlcyB0byBwcm92aWRlIHRoZVxuICAgICAqIGZ1bmN0aW9uYWxpdHkgb2YgdGhlIGNhbGxhYmxlIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7YW55W119IGFyZ3NcbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHN1YmNsYXNzIGRvZXMgbm90IGltcGxlbWVudCB0aGUgYF9jYWxsYCBtZXRob2QuXG4gICAgICovXG4gICAgX2NhbGwoLi4uYXJncykge1xuICAgICAgICB0aHJvdyBFcnJvcignTXVzdCBpbXBsZW1lbnQgX2NhbGwgbWV0aG9kIGluIHN1YmNsYXNzJylcbiAgICB9XG59KTtcblxuXG4vKipcbiAqIENoZWNrIGlmIGEgdmFsdWUgaXMgYSBzdHJpbmcuXG4gKiBAcGFyYW0geyp9IHRleHQgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIHZhbHVlIGlzIGEgc3RyaW5nLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1N0cmluZyh0ZXh0KSB7XG4gICAgcmV0dXJuIHR5cGVvZiB0ZXh0ID09PSAnc3RyaW5nJyB8fCB0ZXh0IGluc3RhbmNlb2YgU3RyaW5nXG59XG5cblxuLyoqXG4gKiBDaGVjayBpZiBhIHZhbHVlIGlzIGEgdHlwZWQgYXJyYXkuXG4gKiBAcGFyYW0geyp9IHZhbCBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgdmFsdWUgaXMgYSBgVHlwZWRBcnJheWAsIGZhbHNlIG90aGVyd2lzZS5cbiAqIFxuICogQWRhcHRlZCBmcm9tIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS83MTA5MTMzOC8xMzk4OTA0M1xuICovXG5leHBvcnQgZnVuY3Rpb24gaXNUeXBlZEFycmF5KHZhbCkge1xuICAgIHJldHVybiB2YWw/LnByb3RvdHlwZT8uX19wcm90b19fPy5jb25zdHJ1Y3Rvcj8ubmFtZSA9PT0gJ1R5cGVkQXJyYXknO1xufVxuXG5cbi8qKlxuICogQ2hlY2sgaWYgYSB2YWx1ZSBpcyBhbiBpbnRlZ2VyLlxuICogQHBhcmFtIHsqfSB4IFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSB2YWx1ZSBpcyBhIHN0cmluZywgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNJbnRlZ3JhbE51bWJlcih4KSB7XG4gICAgcmV0dXJuIE51bWJlci5pc0ludGVnZXIoeCkgfHwgdHlwZW9mIHggPT09ICdiaWdpbnQnXG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYSB2YWx1ZSBpcyBleGlzdHMuXG4gKiBAcGFyYW0geyp9IHggVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIHZhbHVlIGV4aXN0cywgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZXhpc3RzKHgpIHtcbiAgICByZXR1cm4geCAhPT0gdW5kZWZpbmVkICYmIHggIT09IG51bGw7XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgZGltZW5zaW9ucyBvZiBhIG5lc3RlZCBhcnJheS5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhcnIgVGhlIG5lc3RlZCBhcnJheSB0byBjYWxjdWxhdGUgZGltZW5zaW9ucyBmb3IuXG4gKiBAcmV0dXJucyB7QXJyYXl9IEFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIGRpbWVuc2lvbnMgb2YgdGhlIGlucHV0IGFycmF5LlxuICovXG5leHBvcnQgZnVuY3Rpb24gY2FsY3VsYXRlRGltZW5zaW9ucyhhcnIpIHtcbiAgICBjb25zdCBkaW1lbnNpb25zID0gW107XG4gICAgbGV0IGN1cnJlbnQgPSBhcnI7XG4gICAgd2hpbGUgKEFycmF5LmlzQXJyYXkoY3VycmVudCkpIHtcbiAgICAgICAgZGltZW5zaW9ucy5wdXNoKGN1cnJlbnQubGVuZ3RoKTtcbiAgICAgICAgY3VycmVudCA9IGN1cnJlbnRbMF07XG4gICAgfVxuICAgIHJldHVybiBkaW1lbnNpb25zO1xufVxuXG4vKipcbiAqIFJlcGxpY2F0ZSBweXRob24ncyAucG9wKCkgbWV0aG9kIGZvciBvYmplY3RzLlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRvIHBvcCBmcm9tLlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IHRvIHBvcC5cbiAqIEBwYXJhbSB7Kn0gZGVmYXVsdFZhbHVlIFRoZSBkZWZhdWx0IHZhbHVlIHRvIHJldHVybiBpZiB0aGUga2V5IGRvZXMgbm90IGV4aXN0LlxuICogQHJldHVybnMgeyp9IFRoZSB2YWx1ZSBvZiB0aGUgcG9wcGVkIGtleS5cbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUga2V5IGRvZXMgbm90IGV4aXN0IGFuZCBubyBkZWZhdWx0IHZhbHVlIGlzIHByb3ZpZGVkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcG9wKG9iaiwga2V5LCBkZWZhdWx0VmFsdWUgPSB1bmRlZmluZWQpIHtcbiAgICBjb25zdCB2YWx1ZSA9IG9ialtrZXldO1xuICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGRlbGV0ZSBvYmpba2V5XTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBpZiAoZGVmYXVsdFZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoYEtleSAke2tleX0gZG9lcyBub3QgZXhpc3QgaW4gb2JqZWN0LmApXG4gICAgfVxuICAgIHJldHVybiBkZWZhdWx0VmFsdWU7XG59XG5cbi8qKlxuICogRWZmaWNpZW50bHkgbWVyZ2UgYXJyYXlzLCBjcmVhdGluZyBhIG5ldyBjb3B5LlxuICogQWRhcHRlZCBmcm9tIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS82NzY4NjQyLzEzOTg5MDQzXG4gKiBAcGFyYW0gIHsuLi5hbnl9IGFycnMgQXJyYXlzIHRvIG1lcmdlLlxuICogQHJldHVybnMgVGhlIG1lcmdlZCBhcnJheS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlQXJyYXlzKC4uLmFycnMpIHtcbiAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmNvbmNhdC5hcHBseShbXSwgYXJycyk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@xenova/transformers/src/utils/core.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@xenova/transformers/src/utils/generation.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@xenova/transformers/src/utils/generation.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ForceTokensLogitsProcessor: function() { return /* binding */ ForceTokensLogitsProcessor; },\n/* harmony export */   ForcedBOSTokenLogitsProcessor: function() { return /* binding */ ForcedBOSTokenLogitsProcessor; },\n/* harmony export */   ForcedEOSTokenLogitsProcessor: function() { return /* binding */ ForcedEOSTokenLogitsProcessor; },\n/* harmony export */   GenerationConfig: function() { return /* binding */ GenerationConfig; },\n/* harmony export */   LogitsProcessor: function() { return /* binding */ LogitsProcessor; },\n/* harmony export */   LogitsProcessorList: function() { return /* binding */ LogitsProcessorList; },\n/* harmony export */   NoRepeatNGramLogitsProcessor: function() { return /* binding */ NoRepeatNGramLogitsProcessor; },\n/* harmony export */   RepetitionPenaltyLogitsProcessor: function() { return /* binding */ RepetitionPenaltyLogitsProcessor; },\n/* harmony export */   Sampler: function() { return /* binding */ Sampler; },\n/* harmony export */   SuppressTokensAtBeginLogitsProcessor: function() { return /* binding */ SuppressTokensAtBeginLogitsProcessor; },\n/* harmony export */   WhisperTimeStampLogitsProcessor: function() { return /* binding */ WhisperTimeStampLogitsProcessor; }\n/* harmony export */ });\n/* harmony import */ var _tensor_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tensor.js */ \"(app-pages-browser)/./node_modules/@xenova/transformers/src/utils/tensor.js\");\n/* harmony import */ var _core_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./core.js */ \"(app-pages-browser)/./node_modules/@xenova/transformers/src/utils/core.js\");\n/* harmony import */ var _maths_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./maths.js */ \"(app-pages-browser)/./node_modules/@xenova/transformers/src/utils/maths.js\");\n\n/**\n * @file Classes, functions, and utilities for generation.\n * \n * @todo Describe how to create a custom `GenerationConfig`.\n * \n * @module utils/generation\n */\n\n\n\n\n/**\n * A class representing a list of logits processors. A logits processor is a function that modifies the logits\n * output of a language model. This class provides methods for adding new processors and applying all processors to a\n * batch of logits.\n *\n * @extends Callable\n */\nclass LogitsProcessorList extends _core_js__WEBPACK_IMPORTED_MODULE_1__.Callable {\n    /**\n     * Constructs a new instance of `LogitsProcessorList`.\n     */\n    constructor() {\n        super();\n        this.processors = [];\n    }\n\n    /**\n     * Adds a new logits processor to the list.\n     *\n     * @param {LogitsProcessor} item The logits processor function to add.\n     */\n    push(item) {\n        this.processors.push(item);\n    }\n\n    /**\n     * Adds multiple logits processors to the list.\n     *\n     * @param {LogitsProcessor[]} items The logits processor functions to add.\n     */\n    extend(items) {\n        this.processors.push(...items);\n    }\n\n    /**\n     * Applies all logits processors in the list to a batch of logits, modifying them in-place.\n     *\n     * @param {number[]} input_ids The input IDs for the language model.\n     * @param {number[][]} batchedLogits A 2D array of logits, where each row corresponds to a single\n     *                                                input sequence in the batch.\n     */\n    _call(input_ids, batchedLogits) {\n        // NOTE: This is different from the Python code, since vanilla JS does not support vectorized operations. \n        // As a result, we apply each processor to each item in the batch.\n        for (let logits of batchedLogits) {\n            // Modifies logits inplace\n            this.processors.forEach(\n                func => func(input_ids, logits)\n            )\n        }\n    }\n\n    [Symbol.iterator]() {\n        return this.processors.values();\n    }\n}\n\n/**\n * Base class for processing logits.\n * @extends Callable\n */\nclass LogitsProcessor extends _core_js__WEBPACK_IMPORTED_MODULE_1__.Callable {\n    /**\n     * Apply the processor to the input logits.\n     *\n     * @abstract\n     * @param {Array} input_ids The input ids.\n     * @param {Tensor} logits The logits to process.\n     * @throws {Error} Throws an error if `_call` is not implemented in the subclass.\n     */\n    _call(input_ids, logits) {\n        throw Error(\"`_call` should be implemented in a subclass\")\n    }\n}\n\n/**\n * A logits processor that forces a specific token to be generated by the decoder.\n * \n * @extends LogitsProcessor\n */\nclass ForceTokensLogitsProcessor extends LogitsProcessor {\n    /**\n     * Constructs a new instance of `ForceTokensLogitsProcessor`.\n     * \n     * @param {Array} forced_decoder_ids The ids of tokens that should be forced.\n     */\n    constructor(forced_decoder_ids) {\n        super();\n        this.force_token_map = Object.fromEntries(forced_decoder_ids ?? []);\n    }\n\n    /**\n     * Apply the processor to the input logits.\n     *\n     * @param {Array} input_ids The input ids.\n     * @param {Tensor} logits The logits to process.\n     * @returns {Tensor} The processed logits.\n     */\n    _call(input_ids, logits) {\n        let map = this.force_token_map[input_ids.length];\n        if ((0,_core_js__WEBPACK_IMPORTED_MODULE_1__.exists)(map)) { // There exists a mapping\n            logits.data.fill(-Infinity)\n            logits.data[map] = 0;\n        }\n        return logits;\n    }\n}\n\n/**\n * A LogitsProcessor that forces a BOS token at the beginning of the generated sequence.\n * @extends LogitsProcessor\n */\nclass ForcedBOSTokenLogitsProcessor extends LogitsProcessor {\n    /**\n     * Create a ForcedBOSTokenLogitsProcessor.\n     * @param {number} bos_token_id The ID of the beginning-of-sequence token to be forced.\n     */\n    constructor(bos_token_id) {\n        super();\n        this.bos_token_id = bos_token_id;\n    }\n\n    /**\n     * Apply the BOS token forcing to the logits.\n     * @param {Array} input_ids The input IDs.\n     * @param {Object} logits The logits.\n     * @returns {Object} The logits with BOS token forcing.\n     */\n    _call(input_ids, logits) {\n        if (input_ids.length === 1) {\n            logits.data.fill(-Infinity)\n            logits.data[this.bos_token_id] = 0;\n        }\n        return logits;\n    }\n}\n\n/**\n * A logits processor that forces end-of-sequence token probability to 1.\n * \n * @extends LogitsProcessor\n */\nclass ForcedEOSTokenLogitsProcessor extends LogitsProcessor {\n    /**\n     * Create a ForcedEOSTokenLogitsProcessor.\n     * @param {number} max_length Max length of the sequence.\n     * @param {number|number[]} forced_eos_token_id The ID of the end-of-sequence token to be forced.\n     */\n    constructor(max_length, forced_eos_token_id) {\n        super();\n        this.max_length = max_length;\n        this.forced_eos_token_id = forced_eos_token_id;\n    }\n\n    /**\n     * Apply the processor to input_ids and logits.\n     * \n     * @param {number[]} input_ids The input ids.\n     * @param {Tensor} logits The logits tensor.\n     */\n    _call(input_ids, logits) {\n        // console.log('call ForcedEOSTokenLogitsProcessor')\n        // TODO\n    }\n}\n\n/**\n * A LogitsProcessor that suppresses a list of tokens as soon as the `generate` function starts\n * generating using `begin_index` tokens. This should ensure that the tokens defined by\n * `begin_suppress_tokens` at not sampled at the begining of the generation.\n * @extends LogitsProcessor\n */\nclass SuppressTokensAtBeginLogitsProcessor extends LogitsProcessor {\n    /**\n     * Create a SuppressTokensAtBeginLogitsProcessor.\n     * @param {number[]} begin_suppress_tokens The IDs of the tokens to suppress.\n     * @param {number} begin_index The number of tokens to generate before suppressing tokens.\n     */\n    constructor(begin_suppress_tokens, begin_index) {\n        super();\n        this.begin_suppress_tokens = begin_suppress_tokens;\n        this.begin_index = begin_index;\n    }\n\n    /**\n     * Apply the BOS token forcing to the logits.\n     * @param {Array} input_ids The input IDs.\n     * @param {Object} logits The logits.\n     * @returns {Object} The logits with BOS token forcing.\n     */\n    _call(input_ids, logits) {\n        if (input_ids.length === this.begin_index) {\n            for (let token_id of this.begin_suppress_tokens) {\n                logits.data[token_id] = -Infinity;\n            }\n        }\n        return logits;\n    }\n}\n\n/**\n * A LogitsProcessor that handles adding timestamps to generated text.\n * @extends LogitsProcessor\n */\nclass WhisperTimeStampLogitsProcessor extends LogitsProcessor {\n    /**\n     * Constructs a new WhisperTimeStampLogitsProcessor.\n     * @param {Object} generate_config The config object passed to the `generate()` method of a transformer model.\n     * @param {number} generate_config.eos_token_id The ID of the end-of-sequence token.\n     * @param {number} generate_config.no_timestamps_token_id The ID of the token used to indicate that a token should not have a timestamp.\n     * @param {number[][]} [generate_config.forced_decoder_ids] An array of two-element arrays representing decoder IDs that are forced to appear in the output. The second element of each array indicates whether the token is a timestamp.\n     * @param {number} [generate_config.max_initial_timestamp_index] The maximum index at which an initial timestamp can appear.\n     */\n    constructor(generate_config) {\n        super();\n        this.eos_token_id = generate_config.eos_token_id;\n        this.no_timestamps_token_id = generate_config.no_timestamps_token_id;\n        this.timestamp_begin = this.no_timestamps_token_id + 1;\n\n        this.begin_index = (generate_config.forced_decoder_ids || []).length + 2;\n        if (generate_config.forced_decoder_ids.slice(-1)[0][1] === this.no_timestamps_token_id) {\n            this.begin_index -= 1;\n        }\n        this.max_initial_timestamp_index = generate_config.max_initial_timestamp_index;\n\n    }\n\n    /**\n     * Modify the logits to handle timestamp tokens.\n     * @param {Array} input_ids The input sequence of tokens.\n     * @param {Tensor} logits The logits output by the model.\n     * @returns {Tensor} The modified logits.\n     */\n    _call(input_ids, logits) {\n        // suppress <|notimestamps|> which is handled by without_timestamps\n        logits.data[this.no_timestamps_token_id] = -Infinity;\n\n        if (input_ids.length === this.begin_index - 1) {\n            logits.data.fill(-Infinity);\n            logits.data[this.timestamp_begin] = 0;\n            return logits;\n        }\n\n        // timestamps have to appear in pairs, except directly before eos_token; mask logits accordingly\n        const seq = input_ids.slice(this.begin_index);\n        const last_was_timestamp = seq.length >= 1 && seq[seq.length - 1] >= this.timestamp_begin;\n        const penultimate_was_timestamp = seq.length < 2 || seq[seq.length - 2] >= this.timestamp_begin;\n\n        if (last_was_timestamp) {\n            if (penultimate_was_timestamp) { // has to be non-timestamp\n                logits.data.subarray(this.timestamp_begin).fill(-Infinity);\n            } else { // cannot be normal text tokens\n                logits.data.subarray(0, this.eos_token_id).fill(-Infinity);\n            }\n        }\n\n        // apply the `max_initial_timestamp` option\n        if (input_ids.length === this.begin_index && this.max_initial_timestamp_index !== null) {\n            const last_allowed = this.timestamp_begin + this.max_initial_timestamp_index;\n            logits.data.subarray(last_allowed + 1).fill(-Infinity);\n        }\n\n        // if sum of probability over timestamps is above any other token, sample timestamp\n        const logprobs = (0,_maths_js__WEBPACK_IMPORTED_MODULE_2__.log_softmax)(logits.data);\n        const timestamp_logprob = Math.log(logprobs.subarray(this.timestamp_begin).map(Math.exp).reduce((a, b) => a + b));\n        const max_text_token_logprob = (0,_maths_js__WEBPACK_IMPORTED_MODULE_2__.max)(logprobs.subarray(0, this.timestamp_begin))[0];\n\n        if (timestamp_logprob > max_text_token_logprob) {\n            logits.data.subarray(0, this.timestamp_begin).fill(-Infinity);\n        }\n\n        return logits;\n    }\n}\n\n/**\n * A logits processor that disallows ngrams of a certain size to be repeated.\n * \n * @extends LogitsProcessor\n */\nclass NoRepeatNGramLogitsProcessor extends LogitsProcessor {\n    /**\n     * Create a NoRepeatNGramLogitsProcessor.\n     * @param {number} no_repeat_ngram_size The no-repeat-ngram size. All ngrams of this size can only occur once.\n     */\n    constructor(no_repeat_ngram_size) {\n        super();\n        this.no_repeat_ngram_size = no_repeat_ngram_size;\n    }\n\n    /**\n     * Generate n-grams from a sequence of token ids.\n     * @param {number[]} prevInputIds List of previous input ids\n     * @returns {Map<string, number[]>} Map of generated n-grams\n     */\n    getNgrams(prevInputIds) {\n        const curLen = prevInputIds.length;\n\n        /**@type {number[][]} */\n        const ngrams = [];\n        for (let j = 0; j < curLen + 1 - this.no_repeat_ngram_size; ++j) {\n            const ngram = [];\n            for (let k = 0; k < this.no_repeat_ngram_size; ++k) {\n                ngram.push(prevInputIds[j + k]);\n            }\n            ngrams.push(ngram);\n        }\n\n        /** @type {Map<string, number[]>} */\n        const generatedNgram = new Map();\n        for (const ngram of ngrams) {\n            const prevNgram = ngram.slice(0, ngram.length - 1);\n            const prevNgramKey = JSON.stringify(prevNgram);\n            const prevNgramValue = generatedNgram.get(prevNgramKey) ?? [];\n            prevNgramValue.push(ngram[ngram.length - 1]);\n            generatedNgram.set(prevNgramKey, prevNgramValue);\n        }\n        return generatedNgram;\n    }\n\n    /**\n     * Generate n-grams from a sequence of token ids.\n     * @param {Map<string, number[]>} bannedNgrams Map of banned n-grams\n     * @param {number[]} prevInputIds List of previous input ids\n     * @returns {number[]} Map of generated n-grams\n     */\n    getGeneratedNgrams(bannedNgrams, prevInputIds) {\n        const ngramIdx = prevInputIds.slice(prevInputIds.length + 1 - this.no_repeat_ngram_size, prevInputIds.length);\n        const banned = bannedNgrams.get(JSON.stringify(ngramIdx)) ?? [];\n        return banned;\n    }\n\n    /**\n     * Calculate banned n-gram tokens\n     * @param {number[]} prevInputIds List of previous input ids\n     * @returns {number[]} Map of generated n-grams\n     */\n    calcBannedNgramTokens(prevInputIds) {\n        const bannedTokens = [];\n        if (prevInputIds.length + 1 < this.no_repeat_ngram_size) {\n            // return no banned tokens if we haven't generated no_repeat_ngram_size tokens yet\n            return bannedTokens;\n\n        } else {\n            const generatedNgrams = this.getNgrams(prevInputIds);\n            const bannedTokens = this.getGeneratedNgrams(generatedNgrams, prevInputIds);\n            return bannedTokens;\n        }\n    }\n\n    /**\n     * Apply the no-repeat-ngram processor to the logits.\n     * @param {Array} input_ids The input IDs.\n     * @param {Object} logits The logits.\n     * @returns {Object} The logits with no-repeat-ngram processing.\n     */\n    _call(input_ids, logits) {\n        const bannedTokens = this.calcBannedNgramTokens(input_ids);\n\n        for (const token of bannedTokens) {\n            logits.data[token] = -Infinity;\n        }\n        return logits;\n    }\n}\n\n/**\n * A logits processor that penalises repeated output tokens.\n * \n * @extends LogitsProcessor\n */\nclass RepetitionPenaltyLogitsProcessor extends LogitsProcessor {\n    /**\n     * Create a RepetitionPenaltyLogitsProcessor.\n     * @param {number} penalty The penalty to apply for repeated tokens.\n     */\n    constructor(penalty) {\n        super();\n        this.penalty = penalty;\n    }\n\n    /**\n     * Apply the repetition penalty to the logits.\n     * @param {Array} input_ids The input IDs.\n     * @param {Object} logits The logits.\n     * @returns {Object} The logits with repetition penalty processing.\n     */\n    _call(input_ids, logits) {\n        // Modify the logits corresponding to each element in `input_ids`.\n        // As a consequence, the logits corresponding to tokens that appear\n        // many times in the output will be penalised more.\n        for (const input_id of input_ids) {\n            if (logits.data[input_id] < 0) {\n                logits.data[input_id] *= this.penalty;\n            } else {\n                logits.data[input_id] /= this.penalty;\n            }\n        }\n        return logits\n    }\n}\n\n/**\n * Class that holds a configuration for a generation task.\n */\nclass GenerationConfig {\n    /**\n     * Create a GenerationConfig object\n     * @param {Object} [kwargs={}] The configuration parameters. If not set, the default values are used.\n     * @param {number} [kwargs.max_length=20] The maximum length the generated tokens can have. Corresponds to the length of the input prompt + `max_new_tokens`. Its effect is overridden by `max_new_tokens`, if also set.\n     * @param {number} [kwargs.max_new_tokens=null] The maximum numbers of tokens to generate, ignoring the number of tokens in the prompt.\n     * @param {number} [kwargs.min_length=0] The minimum length of the sequence to be generated. Corresponds to the length of the input prompt + `min_new_tokens`. Its effect is overridden by `min_new_tokens`, if also set.\n     * @param {number} [kwargs.min_new_tokens=null] The minimum numbers of tokens to generate, ignoring the number of tokens in the prompt.\n     * @param {boolean|\"never\"} [kwargs.early_stopping=false] Controls the stopping condition for beam-based methods, like beam-search. It accepts the following values:\n     * - `true`, where the generation stops as soon as there are `num_beams` complete candidates;\n     * - `false`, where an heuristic is applied and the generation stops when is it very unlikely to find better candidates;\n     * - `\"never\"`, where the beam search procedure only stops when there cannot be better candidates (canonical beam search algorithm).\n     * @param {number} [kwargs.max_time=null] The maximum amount of time you allow the computation to run for in seconds. Generation will still finish the current pass after allocated time has been passed.\n     *\n     * @param {boolean} [kwargs.do_sample=false] Whether or not to use sampling; use greedy decoding otherwise.\n     * @param {number} [kwargs.num_beams=1] Number of beams for beam search. 1 means no beam search.\n     * @param {number} [kwargs.num_beam_groups=1] Number of groups to divide `num_beams` into in order to ensure diversity among different groups of beams. See [this paper](https://arxiv.org/pdf/1610.02424.pdf) for more details.\n     * @param {number} [kwargs.penalty_alpha=null] The values balance the model confidence and the degeneration penalty in contrastive search decoding.\n     * @param {boolean} [kwargs.use_cache=true] Whether or not the model should use the past last key/values attentions (if applicable to the model) to speed up decoding.\n     *\n     * @param {number} [kwargs.temperature=1.0] The value used to modulate the next token probabilities.\n     * @param {number} [kwargs.top_k=50] The number of highest probability vocabulary tokens to keep for top-k-filtering.\n     * @param {number} [kwargs.top_p=1.0] If set to float < 1, only the smallest set of most probable tokens with probabilities that add up to `top_p` or higher are kept for generation.\n     * @param {number} [kwargs.typical_p=1.0] Local typicality measures how similar the conditional probability of predicting a target token next is to the expected conditional probability of predicting a random token next, given the partial text already generated. If set to float < 1, the smallest set of the most locally typical tokens with probabilities that add up to `typical_p` or higher are kept for generation. See [this paper](https://arxiv.org/pdf/2202.00666.pdf) for more details.\n     * @param {number} [kwargs.epsilon_cutoff=0.0] If set to float strictly between 0 and 1, only tokens with a conditional probability greater than `epsilon_cutoff` will be sampled. In the paper, suggested values range from 3e-4 to 9e-4, depending on the size of the model. See [Truncation Sampling as Language Model Desmoothing](https://arxiv.org/abs/2210.15191) for more details.\n     * @param {number} [kwargs.eta_cutoff=0.0] Eta sampling is a hybrid of locally typical sampling and epsilon sampling. If set to float strictly between 0 and 1, a token is only considered if it is greater than either `eta_cutoff` or `sqrt(eta_cutoff) * exp(-entropy(softmax(next_token_logits)))`. The latter term is intuitively the expected next token probability, scaled by `sqrt(eta_cutoff)`. In the paper, suggested values range from 3e-4 to 2e-3, depending on the size of the model. See [Truncation Sampling as Language Model Desmoothing](https://arxiv.org/abs/2210.15191) for more details.\n     * @param {number} [kwargs.diversity_penalty=0.0] This value is subtracted from a beam's score if it generates a token same as any beam from other group at a particular time. Note that `diversity_penalty` is only effective if `group beam search` is enabled.\n     * @param {number} [kwargs.repetition_penalty=1.0] The parameter for repetition penalty. 1.0 means no penalty. See [this paper](https://arxiv.org/pdf/1909.05858.pdf) for more details.\n     * @param {number} [kwargs.encoder_repetition_penalty=1.0] The paramater for encoder_repetition_penalty. An exponential penalty on sequences that are not in the original input. 1.0 means no penalty.\n     * @param {number} [kwargs.length_penalty=1.0] Exponential penalty to the length that is used with beam-based generation. It is applied as an exponent to the sequence length, which in turn is used to divide the score of the sequence. Since the score is the log likelihood of the sequence (i.e. negative), `length_penalty` > 0.0 promotes longer sequences, while `length_penalty` < 0.0 encourages shorter sequences.\n     * @param {number} [kwargs.no_repeat_ngram_size=0] If set to int > 0, all ngrams of that size can only occur once.\n     * @param {number[][]} [kwargs.bad_words_ids=null] List of token ids that are not allowed to be generated. In order to get the token ids of the words that should not appear in the generated text, use `(await tokenizer(bad_words, {add_prefix_space: true, add_special_tokens: false})).input_ids`.\n     * @param {number[][]|number[][][]} [kwargs.force_words_ids=null] List of token ids that must be generated. If given a `number[][]`, this is treated as a simple list of words that must be included, the opposite to `bad_words_ids`. If given `number[][][]`, this triggers a [disjunctive constraint](https://github.com/huggingface/transformers/issues/14081), where one can allow different forms of each word.\n     * @param {boolean} [kwargs.renormalize_logits=false] Whether to renormalize the logits after applying all the logits processors or warpers (including the custom ones). It's highly recommended to set this flag to `true` as the search algorithms suppose the score logits are normalized but some logit processors or warpers break the normalization.\n     * @param {Object[]} [kwargs.constraints=null] Custom constraints that can be added to the generation to ensure that the output will contain the use of certain tokens as defined by `Constraint` objects, in the most sensible way possible.\n     * \n     * @param {number} [kwargs.forced_bos_token_id=null] The id of the token to force as the first generated token after the `decoder_start_token_id`. Useful for multilingual models like mBART where the first generated token needs to be the target language token.\n     * @param {number|number[]} [kwargs.forced_eos_token_id=null] The id of the token to force as the last generated token when `max_length` is reached. Optionally, use a list to set multiple *end-of-sequence* tokens.\n     * @param {boolean} [kwargs.remove_invalid_values=false] Whether to remove possible *nan* and *inf* outputs of the model to prevent the generation method to crash. Note that using `remove_invalid_values` can slow down generation.\n     * @param {number[]} [kwargs.exponential_decay_length_penalty=null] This Tuple adds an exponentially increasing length penalty, after a certain amount of tokens have been generated. The tuple shall consist of: `(start_index, decay_factor)` where `start_index` indicates where penalty starts and `decay_factor` represents the factor of exponential decay.\n     * @param {number[]} [kwargs.suppress_tokens=null] A list of tokens that will be suppressed at generation. The `SupressTokens` logit processor will set their log probs to `-inf` so that they are not sampled.\n     * @param {number[]} [kwargs.begin_suppress_tokens=null] A list of tokens that will be suppressed at the beginning of the generation. The `SupressBeginTokens` logit processor will set their log probs to `-inf` so that they are not sampled.\n     * @param {number[][]} [kwargs.forced_decoder_ids=null] A list of pairs of integers which indicates a mapping from generation indices to token indices that will be forced before sampling. For example, `[[1, 123]]` means the second generated token will always be a token of index 123.\n     * \n     * @param {number} [kwargs.num_return_sequences=1] The number of independently computed returned sequences for each element in the batch.\n     * @param {boolean} [kwargs.output_attentions=false] Whether or not to return the attentions tensors of all attention layers. See `attentions` under returned tensors for more details.\n     * @param {boolean} [kwargs.output_hidden_states=false] Whether or not to return the hidden states of all layers. See `hidden_states` under returned tensors for more details.\n     * @param {boolean} [kwargs.output_scores=false] Whether or not to return the prediction scores. See `scores` under returned tensors for more details.\n     * @param {boolean} [kwargs.return_dict_in_generate=false] Whether or not to return a `ModelOutput` instead of a plain tuple.\n     * \n     * @param {number} [kwargs.pad_token_id=null] The id of the *padding* token.\n     * @param {number} [kwargs.bos_token_id=null] The id of the *beginning-of-sequence* token.\n     * @param {number|number[]} [kwargs.eos_token_id=null] The id of the *end-of-sequence* token. Optionally, use a list to set multiple *end-of-sequence* tokens.\n     * \n     * @param {number} [kwargs.encoder_no_repeat_ngram_size=0] If set to int > 0, all ngrams of that size that occur in the `encoder_input_ids` cannot occur in the `decoder_input_ids`.\n     * @param {number} [kwargs.decoder_start_token_id=null] If an encoder-decoder model starts decoding with a different token than *bos*, the id of that token.\n     * \n     * @param {Object} [kwargs.generation_kwargs={}] Additional generation kwargs will be forwarded to the `generate` function of the model. Kwargs that are not present in `generate`'s signature will be used in the model forward pass.\n     */\n    constructor(kwargs = {}) {\n        // Parameters that control the length of the output\n        this.max_length = kwargs.max_length ?? 20;\n        this.max_new_tokens = kwargs.max_new_tokens ?? null;\n        this.min_length = kwargs.min_length ?? 0;\n        this.min_new_tokens = kwargs.min_new_tokens ?? null;\n        this.early_stopping = kwargs.early_stopping ?? false;\n        this.max_time = kwargs.max_time ?? null;\n\n        // Parameters that control the generation strategy used\n        this.do_sample = kwargs.do_sample ?? false;\n        this.num_beams = kwargs.num_beams ?? 1;\n        this.num_beam_groups = kwargs.num_beam_groups ?? 1;\n        this.penalty_alpha = kwargs.penalty_alpha ?? null;\n        this.use_cache = kwargs.use_cache ?? true;\n\n        // Parameters for manipulation of the model output logits\n        this.temperature = kwargs.temperature ?? 1.0;\n        this.top_k = kwargs.top_k ?? 50;\n        this.top_p = kwargs.top_p ?? 1.0;\n        this.typical_p = kwargs.typical_p ?? 1.0;\n        this.epsilon_cutoff = kwargs.epsilon_cutoff ?? 0.0;\n        this.eta_cutoff = kwargs.eta_cutoff ?? 0.0;\n        this.diversity_penalty = kwargs.diversity_penalty ?? 0.0;\n        this.repetition_penalty = kwargs.repetition_penalty ?? 1.0;\n        this.encoder_repetition_penalty = kwargs.encoder_repetition_penalty ?? 1.0;\n        this.length_penalty = kwargs.length_penalty ?? 1.0;\n        this.no_repeat_ngram_size = kwargs.no_repeat_ngram_size ?? 0;\n        this.bad_words_ids = kwargs.bad_words_ids ?? null;\n        this.force_words_ids = kwargs.force_words_ids ?? null;\n        this.renormalize_logits = kwargs.renormalize_logits ?? false;\n        this.constraints = kwargs.constraints ?? null;\n        this.forced_bos_token_id = kwargs.forced_bos_token_id ?? null;\n        this.forced_eos_token_id = kwargs.forced_eos_token_id ?? null;\n        this.remove_invalid_values = kwargs.remove_invalid_values ?? false;\n        this.exponential_decay_length_penalty = kwargs.exponential_decay_length_penalty ?? null;\n        this.suppress_tokens = kwargs.suppress_tokens ?? null;\n        this.begin_suppress_tokens = kwargs.begin_suppress_tokens ?? null;\n        this.forced_decoder_ids = kwargs.forced_decoder_ids ?? null;\n\n        // Parameters that define the output variables of `generate`\n        this.num_return_sequences = kwargs.num_return_sequences ?? 1;\n        this.output_attentions = kwargs.output_attentions ?? false;\n        this.output_hidden_states = kwargs.output_hidden_states ?? false;\n        this.output_scores = kwargs.output_scores ?? false;\n        this.return_dict_in_generate = kwargs.return_dict_in_generate ?? false;\n\n        // Special tokens that can be used at generation time\n        this.pad_token_id = kwargs.pad_token_id ?? null;\n        this.bos_token_id = kwargs.bos_token_id ?? null;\n        this.eos_token_id = kwargs.eos_token_id ?? null;\n\n        // Generation parameters exclusive to encoder-decoder models\n        this.encoder_no_repeat_ngram_size = kwargs.encoder_no_repeat_ngram_size ?? 0;\n        this.decoder_start_token_id = kwargs.decoder_start_token_id ?? null;\n\n        // Wild card\n        this.generation_kwargs = kwargs.generation_kwargs ?? {};\n    }\n}\n\n\n/**\n * Sampler is a base class for all sampling methods used for text generation.\n */\nclass Sampler extends _core_js__WEBPACK_IMPORTED_MODULE_1__.Callable {\n    /**\n     * Creates a new Sampler object with the specified generation config.\n     * @param {GenerationConfig} generation_config The generation config.\n     */\n    constructor(generation_config) {\n        super();\n        this.generation_config = generation_config;\n    }\n\n    /**\n     * Executes the sampler, using the specified logits.\n     * @param {Tensor} logits\n     * @param {number} index\n     * @returns {void}\n     */\n    _call(logits, index = -1) {\n        // Sample from logits, of dims [batch, sequence_length, vocab_size].\n        // If index is specified, sample from [batch, index, vocab_size].\n        return this.sample(logits, index);\n    }\n\n    /**\n     * Abstract method for sampling the logits.\n     * @param {Tensor} logits\n     * @param {number} index\n     * @throws {Error}\n     */\n    sample(logits, index) {\n        throw Error(\"sample should be implemented in subclasses.\")\n    }\n\n    /**\n     * Returns the specified logits as an array, with temperature applied.\n     * @param {Tensor} logits\n     * @param {number} index\n     * @returns {Array}\n     */\n    getLogits(logits, index) {\n        let vocabSize = logits.dims.at(-1);\n\n        let logs = logits.data;\n\n        if (index === -1) {\n            logs = logs.slice(-vocabSize);\n        } else {\n            let startIndex = index * vocabSize;\n            logs = logs.slice(startIndex, startIndex + vocabSize);\n        }\n\n        // add temperature\n        if (this.generation_config.temperature > 0) {\n            logs = logs.map(x => x / this.generation_config.temperature)\n        }\n        return logs;\n    }\n\n    /**\n     * Selects an item randomly based on the specified probabilities.\n     * @param {Array} probabilities An array of probabilities to use for selection.\n     * @returns {number} The index of the selected item.\n     */\n    randomSelect(probabilities) {\n        // Return index of chosen item\n        let sumProbabilities = probabilities.reduce((acc, curr) => acc + curr, 0);\n\n        let r = Math.random() * sumProbabilities;\n        for (let i = 0; i < probabilities.length; ++i) {\n            r -= probabilities[i];\n            if (r <= 0) {\n                return i;\n            }\n        }\n        return 0; // return first (most probable) as a fallback\n    }\n\n    /**\n     * Returns a Sampler object based on the specified options.\n     * @param {GenerationConfig} generation_config An object containing options for the sampler.\n     * @returns {Sampler} A Sampler object.\n     */\n    static getSampler(generation_config) {\n        // - *greedy decoding*: `num_beams=1` and `do_sample=False`\n        // - *contrastive search*: `penalty_alpha>0` and `top_k>1`\n        // - *multinomial sampling*: `num_beams=1` and `do_sample=True`\n        // - *beam-search decoding*: `num_beams>1` and `do_sample=False`\n        // - *beam-search multinomial sampling*: `num_beams>1` and `do_sample=True`\n        // - *diverse beam-search decoding*: `num_beams>1` and `num_beam_groups>1`\n        // - *constrained beam-search decoding*: `constraints!=None` or `force_words_ids!=None`\n\n        // NOTE: beam search is implemented directly into the generation function\n        if (generation_config.do_sample) {\n            return new MultinomialSampler(generation_config);\n\n        } else if (generation_config.num_beams > 1) {\n            return new BeamSearchSampler(generation_config);\n\n        } else {\n            if (generation_config.num_return_sequences > 1) {\n                throw Error(`num_return_sequences has to be 1 when doing greedy search, but is ${generation_config.num_return_sequences}.`)\n            }\n            return new GreedySampler(generation_config);\n        }\n    }\n}\n\n/**\n * Class representing a Greedy Sampler.\n * @extends Sampler\n */\nclass GreedySampler extends Sampler {\n    /**\n     * Sample the maximum probability of a given logits tensor.\n     * @param {Tensor} logits\n     * @param {number} [index=-1]\n     * @returns {Array} An array with a single tuple, containing the index of the maximum value and a meaningless score (since this is a greedy search).\n     */\n    sample(logits, index = -1) {\n        // NOTE: no need to do log_softmax here since we only take the maximum\n        let logs = this.getLogits(logits, index);\n        let argmax = (0,_maths_js__WEBPACK_IMPORTED_MODULE_2__.max)(logs)[1];\n\n        // Note: score is meaningless in this context, since we are performing\n        // greedy search (p = 1 => log(p) = 0)\n        return [\n            [argmax, 0]\n        ];\n    }\n}\n\n/**\n * Class representing a MultinomialSampler.\n * @extends Sampler\n */\nclass MultinomialSampler extends Sampler {\n\n    /**\n     * Sample from the logits.\n     * @param {Tensor} logits\n     * @param {number} index\n     * @returns {Array}\n     */\n    sample(logits, index = -1) {\n        let k = logits.dims.at(-1); // defaults to vocab size\n        if (this.generation_config.top_k > 0) {\n            k = Math.min(this.generation_config.top_k, k);\n        }\n\n        // Get logits of nth token\n        const logs = this.getLogits(logits, index);\n\n        // Get top k tokens\n        const topLogits = (0,_maths_js__WEBPACK_IMPORTED_MODULE_2__.getTopItems)(logs, k);\n\n        // Compute softmax over logits\n        const probabilities = (0,_maths_js__WEBPACK_IMPORTED_MODULE_2__.softmax)(topLogits.map(x => x[1]));\n\n        return Array.from({ length: this.generation_config.num_beams }, () => {\n            const sampledIndex = this.randomSelect(probabilities);\n            return [\n                topLogits[sampledIndex][0], // token id\n                Math.log(probabilities[sampledIndex]), // score\n            ];\n        });\n    }\n}\n\n\n/**\n * Class representing a BeamSearchSampler.\n * @extends Sampler\n */\nclass BeamSearchSampler extends Sampler {\n\n    /**\n     * Sample from the logits.\n     * @param {Tensor} logits\n     * @param {number} index\n     * @returns {Array}\n     */\n    sample(logits, index = -1) {\n        let k = logits.dims.at(-1); // defaults to vocab size\n        if (this.generation_config.top_k > 0) {\n            k = Math.min(this.generation_config.top_k, k);\n        }\n\n        // Get logits of nth token\n        const logs = this.getLogits(logits, index);\n\n        // Get top k tokens\n        const topLogits = (0,_maths_js__WEBPACK_IMPORTED_MODULE_2__.getTopItems)(logs, k);\n\n        // Compute softmax over logits\n        const probabilities = (0,_maths_js__WEBPACK_IMPORTED_MODULE_2__.softmax)(topLogits.map(x => x[1]));\n\n        return Array.from({ length: this.generation_config.num_beams }, (_, i) => {\n            return [\n                topLogits[i][0], // token id\n                Math.log(probabilities[i]), // score\n            ];\n        });\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AeGVub3ZhL3RyYW5zZm9ybWVycy9zcmMvdXRpbHMvZ2VuZXJhdGlvbi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNxQztBQUlsQjtBQU1DOztBQUVwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLGtDQUFrQyw4Q0FBUTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGlCQUFpQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG1CQUFtQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFVBQVU7QUFDekIsZUFBZSxZQUFZO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLDhCQUE4Qiw4Q0FBUTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLFFBQVE7QUFDdkIsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLFlBQVksZ0RBQU0sU0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FB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Q0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLFVBQVU7QUFDVjs7QUFFQSxVQUFVO0FBQ1Y7QUFDQSxpR0FBaUcsdUNBQXVDO0FBQ3hJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDhDQUFHOztBQUV4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsMEJBQTBCLHNEQUFXOztBQUVyQztBQUNBLDhCQUE4QixrREFBTzs7QUFFckMsNEJBQTRCLDBDQUEwQztBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSwwQkFBMEIsc0RBQVc7O0FBRXJDO0FBQ0EsOEJBQThCLGtEQUFPOztBQUVyQyw0QkFBNEIsMENBQTBDO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B4ZW5vdmEvdHJhbnNmb3JtZXJzL3NyYy91dGlscy9nZW5lcmF0aW9uLmpzP2E3YzQiXSwic291cmNlc0NvbnRlbnQiOlsiXG4vKipcbiAqIEBmaWxlIENsYXNzZXMsIGZ1bmN0aW9ucywgYW5kIHV0aWxpdGllcyBmb3IgZ2VuZXJhdGlvbi5cbiAqIFxuICogQHRvZG8gRGVzY3JpYmUgaG93IHRvIGNyZWF0ZSBhIGN1c3RvbSBgR2VuZXJhdGlvbkNvbmZpZ2AuXG4gKiBcbiAqIEBtb2R1bGUgdXRpbHMvZ2VuZXJhdGlvblxuICovXG5pbXBvcnQgeyBUZW5zb3IgfSBmcm9tICcuL3RlbnNvci5qcyc7XG5pbXBvcnQge1xuICAgIENhbGxhYmxlLFxuICAgIGV4aXN0cyxcbn0gZnJvbSAnLi9jb3JlLmpzJztcbmltcG9ydCB7XG4gICAgbWF4LFxuICAgIHNvZnRtYXgsXG4gICAgbG9nX3NvZnRtYXgsXG4gICAgZ2V0VG9wSXRlbXMsXG59IGZyb20gJy4vbWF0aHMuanMnO1xuXG4vKipcbiAqIEEgY2xhc3MgcmVwcmVzZW50aW5nIGEgbGlzdCBvZiBsb2dpdHMgcHJvY2Vzc29ycy4gQSBsb2dpdHMgcHJvY2Vzc29yIGlzIGEgZnVuY3Rpb24gdGhhdCBtb2RpZmllcyB0aGUgbG9naXRzXG4gKiBvdXRwdXQgb2YgYSBsYW5ndWFnZSBtb2RlbC4gVGhpcyBjbGFzcyBwcm92aWRlcyBtZXRob2RzIGZvciBhZGRpbmcgbmV3IHByb2Nlc3NvcnMgYW5kIGFwcGx5aW5nIGFsbCBwcm9jZXNzb3JzIHRvIGFcbiAqIGJhdGNoIG9mIGxvZ2l0cy5cbiAqXG4gKiBAZXh0ZW5kcyBDYWxsYWJsZVxuICovXG5leHBvcnQgY2xhc3MgTG9naXRzUHJvY2Vzc29yTGlzdCBleHRlbmRzIENhbGxhYmxlIHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RzIGEgbmV3IGluc3RhbmNlIG9mIGBMb2dpdHNQcm9jZXNzb3JMaXN0YC5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5wcm9jZXNzb3JzID0gW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkcyBhIG5ldyBsb2dpdHMgcHJvY2Vzc29yIHRvIHRoZSBsaXN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtMb2dpdHNQcm9jZXNzb3J9IGl0ZW0gVGhlIGxvZ2l0cyBwcm9jZXNzb3IgZnVuY3Rpb24gdG8gYWRkLlxuICAgICAqL1xuICAgIHB1c2goaXRlbSkge1xuICAgICAgICB0aGlzLnByb2Nlc3NvcnMucHVzaChpdGVtKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIG11bHRpcGxlIGxvZ2l0cyBwcm9jZXNzb3JzIHRvIHRoZSBsaXN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtMb2dpdHNQcm9jZXNzb3JbXX0gaXRlbXMgVGhlIGxvZ2l0cyBwcm9jZXNzb3IgZnVuY3Rpb25zIHRvIGFkZC5cbiAgICAgKi9cbiAgICBleHRlbmQoaXRlbXMpIHtcbiAgICAgICAgdGhpcy5wcm9jZXNzb3JzLnB1c2goLi4uaXRlbXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFwcGxpZXMgYWxsIGxvZ2l0cyBwcm9jZXNzb3JzIGluIHRoZSBsaXN0IHRvIGEgYmF0Y2ggb2YgbG9naXRzLCBtb2RpZnlpbmcgdGhlbSBpbi1wbGFjZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyW119IGlucHV0X2lkcyBUaGUgaW5wdXQgSURzIGZvciB0aGUgbGFuZ3VhZ2UgbW9kZWwuXG4gICAgICogQHBhcmFtIHtudW1iZXJbXVtdfSBiYXRjaGVkTG9naXRzIEEgMkQgYXJyYXkgb2YgbG9naXRzLCB3aGVyZSBlYWNoIHJvdyBjb3JyZXNwb25kcyB0byBhIHNpbmdsZVxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXQgc2VxdWVuY2UgaW4gdGhlIGJhdGNoLlxuICAgICAqL1xuICAgIF9jYWxsKGlucHV0X2lkcywgYmF0Y2hlZExvZ2l0cykge1xuICAgICAgICAvLyBOT1RFOiBUaGlzIGlzIGRpZmZlcmVudCBmcm9tIHRoZSBQeXRob24gY29kZSwgc2luY2UgdmFuaWxsYSBKUyBkb2VzIG5vdCBzdXBwb3J0IHZlY3Rvcml6ZWQgb3BlcmF0aW9ucy4gXG4gICAgICAgIC8vIEFzIGEgcmVzdWx0LCB3ZSBhcHBseSBlYWNoIHByb2Nlc3NvciB0byBlYWNoIGl0ZW0gaW4gdGhlIGJhdGNoLlxuICAgICAgICBmb3IgKGxldCBsb2dpdHMgb2YgYmF0Y2hlZExvZ2l0cykge1xuICAgICAgICAgICAgLy8gTW9kaWZpZXMgbG9naXRzIGlucGxhY2VcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzc29ycy5mb3JFYWNoKFxuICAgICAgICAgICAgICAgIGZ1bmMgPT4gZnVuYyhpbnB1dF9pZHMsIGxvZ2l0cylcbiAgICAgICAgICAgIClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcm9jZXNzb3JzLnZhbHVlcygpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBCYXNlIGNsYXNzIGZvciBwcm9jZXNzaW5nIGxvZ2l0cy5cbiAqIEBleHRlbmRzIENhbGxhYmxlXG4gKi9cbmV4cG9ydCBjbGFzcyBMb2dpdHNQcm9jZXNzb3IgZXh0ZW5kcyBDYWxsYWJsZSB7XG4gICAgLyoqXG4gICAgICogQXBwbHkgdGhlIHByb2Nlc3NvciB0byB0aGUgaW5wdXQgbG9naXRzLlxuICAgICAqXG4gICAgICogQGFic3RyYWN0XG4gICAgICogQHBhcmFtIHtBcnJheX0gaW5wdXRfaWRzIFRoZSBpbnB1dCBpZHMuXG4gICAgICogQHBhcmFtIHtUZW5zb3J9IGxvZ2l0cyBUaGUgbG9naXRzIHRvIHByb2Nlc3MuXG4gICAgICogQHRocm93cyB7RXJyb3J9IFRocm93cyBhbiBlcnJvciBpZiBgX2NhbGxgIGlzIG5vdCBpbXBsZW1lbnRlZCBpbiB0aGUgc3ViY2xhc3MuXG4gICAgICovXG4gICAgX2NhbGwoaW5wdXRfaWRzLCBsb2dpdHMpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJgX2NhbGxgIHNob3VsZCBiZSBpbXBsZW1lbnRlZCBpbiBhIHN1YmNsYXNzXCIpXG4gICAgfVxufVxuXG4vKipcbiAqIEEgbG9naXRzIHByb2Nlc3NvciB0aGF0IGZvcmNlcyBhIHNwZWNpZmljIHRva2VuIHRvIGJlIGdlbmVyYXRlZCBieSB0aGUgZGVjb2Rlci5cbiAqIFxuICogQGV4dGVuZHMgTG9naXRzUHJvY2Vzc29yXG4gKi9cbmV4cG9ydCBjbGFzcyBGb3JjZVRva2Vuc0xvZ2l0c1Byb2Nlc3NvciBleHRlbmRzIExvZ2l0c1Byb2Nlc3NvciB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0cyBhIG5ldyBpbnN0YW5jZSBvZiBgRm9yY2VUb2tlbnNMb2dpdHNQcm9jZXNzb3JgLlxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGZvcmNlZF9kZWNvZGVyX2lkcyBUaGUgaWRzIG9mIHRva2VucyB0aGF0IHNob3VsZCBiZSBmb3JjZWQuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZm9yY2VkX2RlY29kZXJfaWRzKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuZm9yY2VfdG9rZW5fbWFwID0gT2JqZWN0LmZyb21FbnRyaWVzKGZvcmNlZF9kZWNvZGVyX2lkcyA/PyBbXSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXBwbHkgdGhlIHByb2Nlc3NvciB0byB0aGUgaW5wdXQgbG9naXRzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheX0gaW5wdXRfaWRzIFRoZSBpbnB1dCBpZHMuXG4gICAgICogQHBhcmFtIHtUZW5zb3J9IGxvZ2l0cyBUaGUgbG9naXRzIHRvIHByb2Nlc3MuXG4gICAgICogQHJldHVybnMge1RlbnNvcn0gVGhlIHByb2Nlc3NlZCBsb2dpdHMuXG4gICAgICovXG4gICAgX2NhbGwoaW5wdXRfaWRzLCBsb2dpdHMpIHtcbiAgICAgICAgbGV0IG1hcCA9IHRoaXMuZm9yY2VfdG9rZW5fbWFwW2lucHV0X2lkcy5sZW5ndGhdO1xuICAgICAgICBpZiAoZXhpc3RzKG1hcCkpIHsgLy8gVGhlcmUgZXhpc3RzIGEgbWFwcGluZ1xuICAgICAgICAgICAgbG9naXRzLmRhdGEuZmlsbCgtSW5maW5pdHkpXG4gICAgICAgICAgICBsb2dpdHMuZGF0YVttYXBdID0gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbG9naXRzO1xuICAgIH1cbn1cblxuLyoqXG4gKiBBIExvZ2l0c1Byb2Nlc3NvciB0aGF0IGZvcmNlcyBhIEJPUyB0b2tlbiBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBnZW5lcmF0ZWQgc2VxdWVuY2UuXG4gKiBAZXh0ZW5kcyBMb2dpdHNQcm9jZXNzb3JcbiAqL1xuZXhwb3J0IGNsYXNzIEZvcmNlZEJPU1Rva2VuTG9naXRzUHJvY2Vzc29yIGV4dGVuZHMgTG9naXRzUHJvY2Vzc29yIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBGb3JjZWRCT1NUb2tlbkxvZ2l0c1Byb2Nlc3Nvci5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYm9zX3Rva2VuX2lkIFRoZSBJRCBvZiB0aGUgYmVnaW5uaW5nLW9mLXNlcXVlbmNlIHRva2VuIHRvIGJlIGZvcmNlZC5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihib3NfdG9rZW5faWQpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5ib3NfdG9rZW5faWQgPSBib3NfdG9rZW5faWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXBwbHkgdGhlIEJPUyB0b2tlbiBmb3JjaW5nIHRvIHRoZSBsb2dpdHMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gaW5wdXRfaWRzIFRoZSBpbnB1dCBJRHMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGxvZ2l0cyBUaGUgbG9naXRzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBsb2dpdHMgd2l0aCBCT1MgdG9rZW4gZm9yY2luZy5cbiAgICAgKi9cbiAgICBfY2FsbChpbnB1dF9pZHMsIGxvZ2l0cykge1xuICAgICAgICBpZiAoaW5wdXRfaWRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgbG9naXRzLmRhdGEuZmlsbCgtSW5maW5pdHkpXG4gICAgICAgICAgICBsb2dpdHMuZGF0YVt0aGlzLmJvc190b2tlbl9pZF0gPSAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsb2dpdHM7XG4gICAgfVxufVxuXG4vKipcbiAqIEEgbG9naXRzIHByb2Nlc3NvciB0aGF0IGZvcmNlcyBlbmQtb2Ytc2VxdWVuY2UgdG9rZW4gcHJvYmFiaWxpdHkgdG8gMS5cbiAqIFxuICogQGV4dGVuZHMgTG9naXRzUHJvY2Vzc29yXG4gKi9cbmV4cG9ydCBjbGFzcyBGb3JjZWRFT1NUb2tlbkxvZ2l0c1Byb2Nlc3NvciBleHRlbmRzIExvZ2l0c1Byb2Nlc3NvciB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgRm9yY2VkRU9TVG9rZW5Mb2dpdHNQcm9jZXNzb3IuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1heF9sZW5ndGggTWF4IGxlbmd0aCBvZiB0aGUgc2VxdWVuY2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ8bnVtYmVyW119IGZvcmNlZF9lb3NfdG9rZW5faWQgVGhlIElEIG9mIHRoZSBlbmQtb2Ytc2VxdWVuY2UgdG9rZW4gdG8gYmUgZm9yY2VkLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG1heF9sZW5ndGgsIGZvcmNlZF9lb3NfdG9rZW5faWQpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5tYXhfbGVuZ3RoID0gbWF4X2xlbmd0aDtcbiAgICAgICAgdGhpcy5mb3JjZWRfZW9zX3Rva2VuX2lkID0gZm9yY2VkX2Vvc190b2tlbl9pZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBcHBseSB0aGUgcHJvY2Vzc29yIHRvIGlucHV0X2lkcyBhbmQgbG9naXRzLlxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7bnVtYmVyW119IGlucHV0X2lkcyBUaGUgaW5wdXQgaWRzLlxuICAgICAqIEBwYXJhbSB7VGVuc29yfSBsb2dpdHMgVGhlIGxvZ2l0cyB0ZW5zb3IuXG4gICAgICovXG4gICAgX2NhbGwoaW5wdXRfaWRzLCBsb2dpdHMpIHtcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ2NhbGwgRm9yY2VkRU9TVG9rZW5Mb2dpdHNQcm9jZXNzb3InKVxuICAgICAgICAvLyBUT0RPXG4gICAgfVxufVxuXG4vKipcbiAqIEEgTG9naXRzUHJvY2Vzc29yIHRoYXQgc3VwcHJlc3NlcyBhIGxpc3Qgb2YgdG9rZW5zIGFzIHNvb24gYXMgdGhlIGBnZW5lcmF0ZWAgZnVuY3Rpb24gc3RhcnRzXG4gKiBnZW5lcmF0aW5nIHVzaW5nIGBiZWdpbl9pbmRleGAgdG9rZW5zLiBUaGlzIHNob3VsZCBlbnN1cmUgdGhhdCB0aGUgdG9rZW5zIGRlZmluZWQgYnlcbiAqIGBiZWdpbl9zdXBwcmVzc190b2tlbnNgIGF0IG5vdCBzYW1wbGVkIGF0IHRoZSBiZWdpbmluZyBvZiB0aGUgZ2VuZXJhdGlvbi5cbiAqIEBleHRlbmRzIExvZ2l0c1Byb2Nlc3NvclxuICovXG5leHBvcnQgY2xhc3MgU3VwcHJlc3NUb2tlbnNBdEJlZ2luTG9naXRzUHJvY2Vzc29yIGV4dGVuZHMgTG9naXRzUHJvY2Vzc29yIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBTdXBwcmVzc1Rva2Vuc0F0QmVnaW5Mb2dpdHNQcm9jZXNzb3IuXG4gICAgICogQHBhcmFtIHtudW1iZXJbXX0gYmVnaW5fc3VwcHJlc3NfdG9rZW5zIFRoZSBJRHMgb2YgdGhlIHRva2VucyB0byBzdXBwcmVzcy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYmVnaW5faW5kZXggVGhlIG51bWJlciBvZiB0b2tlbnMgdG8gZ2VuZXJhdGUgYmVmb3JlIHN1cHByZXNzaW5nIHRva2Vucy5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihiZWdpbl9zdXBwcmVzc190b2tlbnMsIGJlZ2luX2luZGV4KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuYmVnaW5fc3VwcHJlc3NfdG9rZW5zID0gYmVnaW5fc3VwcHJlc3NfdG9rZW5zO1xuICAgICAgICB0aGlzLmJlZ2luX2luZGV4ID0gYmVnaW5faW5kZXg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXBwbHkgdGhlIEJPUyB0b2tlbiBmb3JjaW5nIHRvIHRoZSBsb2dpdHMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gaW5wdXRfaWRzIFRoZSBpbnB1dCBJRHMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGxvZ2l0cyBUaGUgbG9naXRzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBsb2dpdHMgd2l0aCBCT1MgdG9rZW4gZm9yY2luZy5cbiAgICAgKi9cbiAgICBfY2FsbChpbnB1dF9pZHMsIGxvZ2l0cykge1xuICAgICAgICBpZiAoaW5wdXRfaWRzLmxlbmd0aCA9PT0gdGhpcy5iZWdpbl9pbmRleCkge1xuICAgICAgICAgICAgZm9yIChsZXQgdG9rZW5faWQgb2YgdGhpcy5iZWdpbl9zdXBwcmVzc190b2tlbnMpIHtcbiAgICAgICAgICAgICAgICBsb2dpdHMuZGF0YVt0b2tlbl9pZF0gPSAtSW5maW5pdHk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxvZ2l0cztcbiAgICB9XG59XG5cbi8qKlxuICogQSBMb2dpdHNQcm9jZXNzb3IgdGhhdCBoYW5kbGVzIGFkZGluZyB0aW1lc3RhbXBzIHRvIGdlbmVyYXRlZCB0ZXh0LlxuICogQGV4dGVuZHMgTG9naXRzUHJvY2Vzc29yXG4gKi9cbmV4cG9ydCBjbGFzcyBXaGlzcGVyVGltZVN0YW1wTG9naXRzUHJvY2Vzc29yIGV4dGVuZHMgTG9naXRzUHJvY2Vzc29yIHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RzIGEgbmV3IFdoaXNwZXJUaW1lU3RhbXBMb2dpdHNQcm9jZXNzb3IuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGdlbmVyYXRlX2NvbmZpZyBUaGUgY29uZmlnIG9iamVjdCBwYXNzZWQgdG8gdGhlIGBnZW5lcmF0ZSgpYCBtZXRob2Qgb2YgYSB0cmFuc2Zvcm1lciBtb2RlbC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZ2VuZXJhdGVfY29uZmlnLmVvc190b2tlbl9pZCBUaGUgSUQgb2YgdGhlIGVuZC1vZi1zZXF1ZW5jZSB0b2tlbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZ2VuZXJhdGVfY29uZmlnLm5vX3RpbWVzdGFtcHNfdG9rZW5faWQgVGhlIElEIG9mIHRoZSB0b2tlbiB1c2VkIHRvIGluZGljYXRlIHRoYXQgYSB0b2tlbiBzaG91bGQgbm90IGhhdmUgYSB0aW1lc3RhbXAuXG4gICAgICogQHBhcmFtIHtudW1iZXJbXVtdfSBbZ2VuZXJhdGVfY29uZmlnLmZvcmNlZF9kZWNvZGVyX2lkc10gQW4gYXJyYXkgb2YgdHdvLWVsZW1lbnQgYXJyYXlzIHJlcHJlc2VudGluZyBkZWNvZGVyIElEcyB0aGF0IGFyZSBmb3JjZWQgdG8gYXBwZWFyIGluIHRoZSBvdXRwdXQuIFRoZSBzZWNvbmQgZWxlbWVudCBvZiBlYWNoIGFycmF5IGluZGljYXRlcyB3aGV0aGVyIHRoZSB0b2tlbiBpcyBhIHRpbWVzdGFtcC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2dlbmVyYXRlX2NvbmZpZy5tYXhfaW5pdGlhbF90aW1lc3RhbXBfaW5kZXhdIFRoZSBtYXhpbXVtIGluZGV4IGF0IHdoaWNoIGFuIGluaXRpYWwgdGltZXN0YW1wIGNhbiBhcHBlYXIuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZ2VuZXJhdGVfY29uZmlnKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuZW9zX3Rva2VuX2lkID0gZ2VuZXJhdGVfY29uZmlnLmVvc190b2tlbl9pZDtcbiAgICAgICAgdGhpcy5ub190aW1lc3RhbXBzX3Rva2VuX2lkID0gZ2VuZXJhdGVfY29uZmlnLm5vX3RpbWVzdGFtcHNfdG9rZW5faWQ7XG4gICAgICAgIHRoaXMudGltZXN0YW1wX2JlZ2luID0gdGhpcy5ub190aW1lc3RhbXBzX3Rva2VuX2lkICsgMTtcblxuICAgICAgICB0aGlzLmJlZ2luX2luZGV4ID0gKGdlbmVyYXRlX2NvbmZpZy5mb3JjZWRfZGVjb2Rlcl9pZHMgfHwgW10pLmxlbmd0aCArIDI7XG4gICAgICAgIGlmIChnZW5lcmF0ZV9jb25maWcuZm9yY2VkX2RlY29kZXJfaWRzLnNsaWNlKC0xKVswXVsxXSA9PT0gdGhpcy5ub190aW1lc3RhbXBzX3Rva2VuX2lkKSB7XG4gICAgICAgICAgICB0aGlzLmJlZ2luX2luZGV4IC09IDE7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tYXhfaW5pdGlhbF90aW1lc3RhbXBfaW5kZXggPSBnZW5lcmF0ZV9jb25maWcubWF4X2luaXRpYWxfdGltZXN0YW1wX2luZGV4O1xuXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTW9kaWZ5IHRoZSBsb2dpdHMgdG8gaGFuZGxlIHRpbWVzdGFtcCB0b2tlbnMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gaW5wdXRfaWRzIFRoZSBpbnB1dCBzZXF1ZW5jZSBvZiB0b2tlbnMuXG4gICAgICogQHBhcmFtIHtUZW5zb3J9IGxvZ2l0cyBUaGUgbG9naXRzIG91dHB1dCBieSB0aGUgbW9kZWwuXG4gICAgICogQHJldHVybnMge1RlbnNvcn0gVGhlIG1vZGlmaWVkIGxvZ2l0cy5cbiAgICAgKi9cbiAgICBfY2FsbChpbnB1dF9pZHMsIGxvZ2l0cykge1xuICAgICAgICAvLyBzdXBwcmVzcyA8fG5vdGltZXN0YW1wc3w+IHdoaWNoIGlzIGhhbmRsZWQgYnkgd2l0aG91dF90aW1lc3RhbXBzXG4gICAgICAgIGxvZ2l0cy5kYXRhW3RoaXMubm9fdGltZXN0YW1wc190b2tlbl9pZF0gPSAtSW5maW5pdHk7XG5cbiAgICAgICAgaWYgKGlucHV0X2lkcy5sZW5ndGggPT09IHRoaXMuYmVnaW5faW5kZXggLSAxKSB7XG4gICAgICAgICAgICBsb2dpdHMuZGF0YS5maWxsKC1JbmZpbml0eSk7XG4gICAgICAgICAgICBsb2dpdHMuZGF0YVt0aGlzLnRpbWVzdGFtcF9iZWdpbl0gPSAwO1xuICAgICAgICAgICAgcmV0dXJuIGxvZ2l0cztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHRpbWVzdGFtcHMgaGF2ZSB0byBhcHBlYXIgaW4gcGFpcnMsIGV4Y2VwdCBkaXJlY3RseSBiZWZvcmUgZW9zX3Rva2VuOyBtYXNrIGxvZ2l0cyBhY2NvcmRpbmdseVxuICAgICAgICBjb25zdCBzZXEgPSBpbnB1dF9pZHMuc2xpY2UodGhpcy5iZWdpbl9pbmRleCk7XG4gICAgICAgIGNvbnN0IGxhc3Rfd2FzX3RpbWVzdGFtcCA9IHNlcS5sZW5ndGggPj0gMSAmJiBzZXFbc2VxLmxlbmd0aCAtIDFdID49IHRoaXMudGltZXN0YW1wX2JlZ2luO1xuICAgICAgICBjb25zdCBwZW51bHRpbWF0ZV93YXNfdGltZXN0YW1wID0gc2VxLmxlbmd0aCA8IDIgfHwgc2VxW3NlcS5sZW5ndGggLSAyXSA+PSB0aGlzLnRpbWVzdGFtcF9iZWdpbjtcblxuICAgICAgICBpZiAobGFzdF93YXNfdGltZXN0YW1wKSB7XG4gICAgICAgICAgICBpZiAocGVudWx0aW1hdGVfd2FzX3RpbWVzdGFtcCkgeyAvLyBoYXMgdG8gYmUgbm9uLXRpbWVzdGFtcFxuICAgICAgICAgICAgICAgIGxvZ2l0cy5kYXRhLnN1YmFycmF5KHRoaXMudGltZXN0YW1wX2JlZ2luKS5maWxsKC1JbmZpbml0eSk7XG4gICAgICAgICAgICB9IGVsc2UgeyAvLyBjYW5ub3QgYmUgbm9ybWFsIHRleHQgdG9rZW5zXG4gICAgICAgICAgICAgICAgbG9naXRzLmRhdGEuc3ViYXJyYXkoMCwgdGhpcy5lb3NfdG9rZW5faWQpLmZpbGwoLUluZmluaXR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFwcGx5IHRoZSBgbWF4X2luaXRpYWxfdGltZXN0YW1wYCBvcHRpb25cbiAgICAgICAgaWYgKGlucHV0X2lkcy5sZW5ndGggPT09IHRoaXMuYmVnaW5faW5kZXggJiYgdGhpcy5tYXhfaW5pdGlhbF90aW1lc3RhbXBfaW5kZXggIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IGxhc3RfYWxsb3dlZCA9IHRoaXMudGltZXN0YW1wX2JlZ2luICsgdGhpcy5tYXhfaW5pdGlhbF90aW1lc3RhbXBfaW5kZXg7XG4gICAgICAgICAgICBsb2dpdHMuZGF0YS5zdWJhcnJheShsYXN0X2FsbG93ZWQgKyAxKS5maWxsKC1JbmZpbml0eSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiBzdW0gb2YgcHJvYmFiaWxpdHkgb3ZlciB0aW1lc3RhbXBzIGlzIGFib3ZlIGFueSBvdGhlciB0b2tlbiwgc2FtcGxlIHRpbWVzdGFtcFxuICAgICAgICBjb25zdCBsb2dwcm9icyA9IGxvZ19zb2Z0bWF4KGxvZ2l0cy5kYXRhKTtcbiAgICAgICAgY29uc3QgdGltZXN0YW1wX2xvZ3Byb2IgPSBNYXRoLmxvZyhsb2dwcm9icy5zdWJhcnJheSh0aGlzLnRpbWVzdGFtcF9iZWdpbikubWFwKE1hdGguZXhwKS5yZWR1Y2UoKGEsIGIpID0+IGEgKyBiKSk7XG4gICAgICAgIGNvbnN0IG1heF90ZXh0X3Rva2VuX2xvZ3Byb2IgPSBtYXgobG9ncHJvYnMuc3ViYXJyYXkoMCwgdGhpcy50aW1lc3RhbXBfYmVnaW4pKVswXTtcblxuICAgICAgICBpZiAodGltZXN0YW1wX2xvZ3Byb2IgPiBtYXhfdGV4dF90b2tlbl9sb2dwcm9iKSB7XG4gICAgICAgICAgICBsb2dpdHMuZGF0YS5zdWJhcnJheSgwLCB0aGlzLnRpbWVzdGFtcF9iZWdpbikuZmlsbCgtSW5maW5pdHkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGxvZ2l0cztcbiAgICB9XG59XG5cbi8qKlxuICogQSBsb2dpdHMgcHJvY2Vzc29yIHRoYXQgZGlzYWxsb3dzIG5ncmFtcyBvZiBhIGNlcnRhaW4gc2l6ZSB0byBiZSByZXBlYXRlZC5cbiAqIFxuICogQGV4dGVuZHMgTG9naXRzUHJvY2Vzc29yXG4gKi9cbmV4cG9ydCBjbGFzcyBOb1JlcGVhdE5HcmFtTG9naXRzUHJvY2Vzc29yIGV4dGVuZHMgTG9naXRzUHJvY2Vzc29yIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBOb1JlcGVhdE5HcmFtTG9naXRzUHJvY2Vzc29yLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBub19yZXBlYXRfbmdyYW1fc2l6ZSBUaGUgbm8tcmVwZWF0LW5ncmFtIHNpemUuIEFsbCBuZ3JhbXMgb2YgdGhpcyBzaXplIGNhbiBvbmx5IG9jY3VyIG9uY2UuXG4gICAgICovXG4gICAgY29uc3RydWN0b3Iobm9fcmVwZWF0X25ncmFtX3NpemUpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5ub19yZXBlYXRfbmdyYW1fc2l6ZSA9IG5vX3JlcGVhdF9uZ3JhbV9zaXplO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlIG4tZ3JhbXMgZnJvbSBhIHNlcXVlbmNlIG9mIHRva2VuIGlkcy5cbiAgICAgKiBAcGFyYW0ge251bWJlcltdfSBwcmV2SW5wdXRJZHMgTGlzdCBvZiBwcmV2aW91cyBpbnB1dCBpZHNcbiAgICAgKiBAcmV0dXJucyB7TWFwPHN0cmluZywgbnVtYmVyW10+fSBNYXAgb2YgZ2VuZXJhdGVkIG4tZ3JhbXNcbiAgICAgKi9cbiAgICBnZXROZ3JhbXMocHJldklucHV0SWRzKSB7XG4gICAgICAgIGNvbnN0IGN1ckxlbiA9IHByZXZJbnB1dElkcy5sZW5ndGg7XG5cbiAgICAgICAgLyoqQHR5cGUge251bWJlcltdW119ICovXG4gICAgICAgIGNvbnN0IG5ncmFtcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGN1ckxlbiArIDEgLSB0aGlzLm5vX3JlcGVhdF9uZ3JhbV9zaXplOyArK2opIHtcbiAgICAgICAgICAgIGNvbnN0IG5ncmFtID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IHRoaXMubm9fcmVwZWF0X25ncmFtX3NpemU7ICsraykge1xuICAgICAgICAgICAgICAgIG5ncmFtLnB1c2gocHJldklucHV0SWRzW2ogKyBrXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZ3JhbXMucHVzaChuZ3JhbSk7XG4gICAgICAgIH1cblxuICAgICAgICAvKiogQHR5cGUge01hcDxzdHJpbmcsIG51bWJlcltdPn0gKi9cbiAgICAgICAgY29uc3QgZ2VuZXJhdGVkTmdyYW0gPSBuZXcgTWFwKCk7XG4gICAgICAgIGZvciAoY29uc3QgbmdyYW0gb2YgbmdyYW1zKSB7XG4gICAgICAgICAgICBjb25zdCBwcmV2TmdyYW0gPSBuZ3JhbS5zbGljZSgwLCBuZ3JhbS5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgIGNvbnN0IHByZXZOZ3JhbUtleSA9IEpTT04uc3RyaW5naWZ5KHByZXZOZ3JhbSk7XG4gICAgICAgICAgICBjb25zdCBwcmV2TmdyYW1WYWx1ZSA9IGdlbmVyYXRlZE5ncmFtLmdldChwcmV2TmdyYW1LZXkpID8/IFtdO1xuICAgICAgICAgICAgcHJldk5ncmFtVmFsdWUucHVzaChuZ3JhbVtuZ3JhbS5sZW5ndGggLSAxXSk7XG4gICAgICAgICAgICBnZW5lcmF0ZWROZ3JhbS5zZXQocHJldk5ncmFtS2V5LCBwcmV2TmdyYW1WYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGdlbmVyYXRlZE5ncmFtO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlIG4tZ3JhbXMgZnJvbSBhIHNlcXVlbmNlIG9mIHRva2VuIGlkcy5cbiAgICAgKiBAcGFyYW0ge01hcDxzdHJpbmcsIG51bWJlcltdPn0gYmFubmVkTmdyYW1zIE1hcCBvZiBiYW5uZWQgbi1ncmFtc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyW119IHByZXZJbnB1dElkcyBMaXN0IG9mIHByZXZpb3VzIGlucHV0IGlkc1xuICAgICAqIEByZXR1cm5zIHtudW1iZXJbXX0gTWFwIG9mIGdlbmVyYXRlZCBuLWdyYW1zXG4gICAgICovXG4gICAgZ2V0R2VuZXJhdGVkTmdyYW1zKGJhbm5lZE5ncmFtcywgcHJldklucHV0SWRzKSB7XG4gICAgICAgIGNvbnN0IG5ncmFtSWR4ID0gcHJldklucHV0SWRzLnNsaWNlKHByZXZJbnB1dElkcy5sZW5ndGggKyAxIC0gdGhpcy5ub19yZXBlYXRfbmdyYW1fc2l6ZSwgcHJldklucHV0SWRzLmxlbmd0aCk7XG4gICAgICAgIGNvbnN0IGJhbm5lZCA9IGJhbm5lZE5ncmFtcy5nZXQoSlNPTi5zdHJpbmdpZnkobmdyYW1JZHgpKSA/PyBbXTtcbiAgICAgICAgcmV0dXJuIGJhbm5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgYmFubmVkIG4tZ3JhbSB0b2tlbnNcbiAgICAgKiBAcGFyYW0ge251bWJlcltdfSBwcmV2SW5wdXRJZHMgTGlzdCBvZiBwcmV2aW91cyBpbnB1dCBpZHNcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyW119IE1hcCBvZiBnZW5lcmF0ZWQgbi1ncmFtc1xuICAgICAqL1xuICAgIGNhbGNCYW5uZWROZ3JhbVRva2VucyhwcmV2SW5wdXRJZHMpIHtcbiAgICAgICAgY29uc3QgYmFubmVkVG9rZW5zID0gW107XG4gICAgICAgIGlmIChwcmV2SW5wdXRJZHMubGVuZ3RoICsgMSA8IHRoaXMubm9fcmVwZWF0X25ncmFtX3NpemUpIHtcbiAgICAgICAgICAgIC8vIHJldHVybiBubyBiYW5uZWQgdG9rZW5zIGlmIHdlIGhhdmVuJ3QgZ2VuZXJhdGVkIG5vX3JlcGVhdF9uZ3JhbV9zaXplIHRva2VucyB5ZXRcbiAgICAgICAgICAgIHJldHVybiBiYW5uZWRUb2tlbnM7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGdlbmVyYXRlZE5ncmFtcyA9IHRoaXMuZ2V0TmdyYW1zKHByZXZJbnB1dElkcyk7XG4gICAgICAgICAgICBjb25zdCBiYW5uZWRUb2tlbnMgPSB0aGlzLmdldEdlbmVyYXRlZE5ncmFtcyhnZW5lcmF0ZWROZ3JhbXMsIHByZXZJbnB1dElkcyk7XG4gICAgICAgICAgICByZXR1cm4gYmFubmVkVG9rZW5zO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXBwbHkgdGhlIG5vLXJlcGVhdC1uZ3JhbSBwcm9jZXNzb3IgdG8gdGhlIGxvZ2l0cy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBpbnB1dF9pZHMgVGhlIGlucHV0IElEcy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbG9naXRzIFRoZSBsb2dpdHMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gVGhlIGxvZ2l0cyB3aXRoIG5vLXJlcGVhdC1uZ3JhbSBwcm9jZXNzaW5nLlxuICAgICAqL1xuICAgIF9jYWxsKGlucHV0X2lkcywgbG9naXRzKSB7XG4gICAgICAgIGNvbnN0IGJhbm5lZFRva2VucyA9IHRoaXMuY2FsY0Jhbm5lZE5ncmFtVG9rZW5zKGlucHV0X2lkcyk7XG5cbiAgICAgICAgZm9yIChjb25zdCB0b2tlbiBvZiBiYW5uZWRUb2tlbnMpIHtcbiAgICAgICAgICAgIGxvZ2l0cy5kYXRhW3Rva2VuXSA9IC1JbmZpbml0eTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbG9naXRzO1xuICAgIH1cbn1cblxuLyoqXG4gKiBBIGxvZ2l0cyBwcm9jZXNzb3IgdGhhdCBwZW5hbGlzZXMgcmVwZWF0ZWQgb3V0cHV0IHRva2Vucy5cbiAqIFxuICogQGV4dGVuZHMgTG9naXRzUHJvY2Vzc29yXG4gKi9cbmV4cG9ydCBjbGFzcyBSZXBldGl0aW9uUGVuYWx0eUxvZ2l0c1Byb2Nlc3NvciBleHRlbmRzIExvZ2l0c1Byb2Nlc3NvciB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgUmVwZXRpdGlvblBlbmFsdHlMb2dpdHNQcm9jZXNzb3IuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBlbmFsdHkgVGhlIHBlbmFsdHkgdG8gYXBwbHkgZm9yIHJlcGVhdGVkIHRva2Vucy5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihwZW5hbHR5KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMucGVuYWx0eSA9IHBlbmFsdHk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXBwbHkgdGhlIHJlcGV0aXRpb24gcGVuYWx0eSB0byB0aGUgbG9naXRzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGlucHV0X2lkcyBUaGUgaW5wdXQgSURzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBsb2dpdHMgVGhlIGxvZ2l0cy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgbG9naXRzIHdpdGggcmVwZXRpdGlvbiBwZW5hbHR5IHByb2Nlc3NpbmcuXG4gICAgICovXG4gICAgX2NhbGwoaW5wdXRfaWRzLCBsb2dpdHMpIHtcbiAgICAgICAgLy8gTW9kaWZ5IHRoZSBsb2dpdHMgY29ycmVzcG9uZGluZyB0byBlYWNoIGVsZW1lbnQgaW4gYGlucHV0X2lkc2AuXG4gICAgICAgIC8vIEFzIGEgY29uc2VxdWVuY2UsIHRoZSBsb2dpdHMgY29ycmVzcG9uZGluZyB0byB0b2tlbnMgdGhhdCBhcHBlYXJcbiAgICAgICAgLy8gbWFueSB0aW1lcyBpbiB0aGUgb3V0cHV0IHdpbGwgYmUgcGVuYWxpc2VkIG1vcmUuXG4gICAgICAgIGZvciAoY29uc3QgaW5wdXRfaWQgb2YgaW5wdXRfaWRzKSB7XG4gICAgICAgICAgICBpZiAobG9naXRzLmRhdGFbaW5wdXRfaWRdIDwgMCkge1xuICAgICAgICAgICAgICAgIGxvZ2l0cy5kYXRhW2lucHV0X2lkXSAqPSB0aGlzLnBlbmFsdHk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGxvZ2l0cy5kYXRhW2lucHV0X2lkXSAvPSB0aGlzLnBlbmFsdHk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxvZ2l0c1xuICAgIH1cbn1cblxuLyoqXG4gKiBDbGFzcyB0aGF0IGhvbGRzIGEgY29uZmlndXJhdGlvbiBmb3IgYSBnZW5lcmF0aW9uIHRhc2suXG4gKi9cbmV4cG9ydCBjbGFzcyBHZW5lcmF0aW9uQ29uZmlnIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBHZW5lcmF0aW9uQ29uZmlnIG9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBba3dhcmdzPXt9XSBUaGUgY29uZmlndXJhdGlvbiBwYXJhbWV0ZXJzLiBJZiBub3Qgc2V0LCB0aGUgZGVmYXVsdCB2YWx1ZXMgYXJlIHVzZWQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtrd2FyZ3MubWF4X2xlbmd0aD0yMF0gVGhlIG1heGltdW0gbGVuZ3RoIHRoZSBnZW5lcmF0ZWQgdG9rZW5zIGNhbiBoYXZlLiBDb3JyZXNwb25kcyB0byB0aGUgbGVuZ3RoIG9mIHRoZSBpbnB1dCBwcm9tcHQgKyBgbWF4X25ld190b2tlbnNgLiBJdHMgZWZmZWN0IGlzIG92ZXJyaWRkZW4gYnkgYG1heF9uZXdfdG9rZW5zYCwgaWYgYWxzbyBzZXQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtrd2FyZ3MubWF4X25ld190b2tlbnM9bnVsbF0gVGhlIG1heGltdW0gbnVtYmVycyBvZiB0b2tlbnMgdG8gZ2VuZXJhdGUsIGlnbm9yaW5nIHRoZSBudW1iZXIgb2YgdG9rZW5zIGluIHRoZSBwcm9tcHQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtrd2FyZ3MubWluX2xlbmd0aD0wXSBUaGUgbWluaW11bSBsZW5ndGggb2YgdGhlIHNlcXVlbmNlIHRvIGJlIGdlbmVyYXRlZC4gQ29ycmVzcG9uZHMgdG8gdGhlIGxlbmd0aCBvZiB0aGUgaW5wdXQgcHJvbXB0ICsgYG1pbl9uZXdfdG9rZW5zYC4gSXRzIGVmZmVjdCBpcyBvdmVycmlkZGVuIGJ5IGBtaW5fbmV3X3Rva2Vuc2AsIGlmIGFsc28gc2V0LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBba3dhcmdzLm1pbl9uZXdfdG9rZW5zPW51bGxdIFRoZSBtaW5pbXVtIG51bWJlcnMgb2YgdG9rZW5zIHRvIGdlbmVyYXRlLCBpZ25vcmluZyB0aGUgbnVtYmVyIG9mIHRva2VucyBpbiB0aGUgcHJvbXB0LlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbnxcIm5ldmVyXCJ9IFtrd2FyZ3MuZWFybHlfc3RvcHBpbmc9ZmFsc2VdIENvbnRyb2xzIHRoZSBzdG9wcGluZyBjb25kaXRpb24gZm9yIGJlYW0tYmFzZWQgbWV0aG9kcywgbGlrZSBiZWFtLXNlYXJjaC4gSXQgYWNjZXB0cyB0aGUgZm9sbG93aW5nIHZhbHVlczpcbiAgICAgKiAtIGB0cnVlYCwgd2hlcmUgdGhlIGdlbmVyYXRpb24gc3RvcHMgYXMgc29vbiBhcyB0aGVyZSBhcmUgYG51bV9iZWFtc2AgY29tcGxldGUgY2FuZGlkYXRlcztcbiAgICAgKiAtIGBmYWxzZWAsIHdoZXJlIGFuIGhldXJpc3RpYyBpcyBhcHBsaWVkIGFuZCB0aGUgZ2VuZXJhdGlvbiBzdG9wcyB3aGVuIGlzIGl0IHZlcnkgdW5saWtlbHkgdG8gZmluZCBiZXR0ZXIgY2FuZGlkYXRlcztcbiAgICAgKiAtIGBcIm5ldmVyXCJgLCB3aGVyZSB0aGUgYmVhbSBzZWFyY2ggcHJvY2VkdXJlIG9ubHkgc3RvcHMgd2hlbiB0aGVyZSBjYW5ub3QgYmUgYmV0dGVyIGNhbmRpZGF0ZXMgKGNhbm9uaWNhbCBiZWFtIHNlYXJjaCBhbGdvcml0aG0pLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBba3dhcmdzLm1heF90aW1lPW51bGxdIFRoZSBtYXhpbXVtIGFtb3VudCBvZiB0aW1lIHlvdSBhbGxvdyB0aGUgY29tcHV0YXRpb24gdG8gcnVuIGZvciBpbiBzZWNvbmRzLiBHZW5lcmF0aW9uIHdpbGwgc3RpbGwgZmluaXNoIHRoZSBjdXJyZW50IHBhc3MgYWZ0ZXIgYWxsb2NhdGVkIHRpbWUgaGFzIGJlZW4gcGFzc2VkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtib29sZWFufSBba3dhcmdzLmRvX3NhbXBsZT1mYWxzZV0gV2hldGhlciBvciBub3QgdG8gdXNlIHNhbXBsaW5nOyB1c2UgZ3JlZWR5IGRlY29kaW5nIG90aGVyd2lzZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2t3YXJncy5udW1fYmVhbXM9MV0gTnVtYmVyIG9mIGJlYW1zIGZvciBiZWFtIHNlYXJjaC4gMSBtZWFucyBubyBiZWFtIHNlYXJjaC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2t3YXJncy5udW1fYmVhbV9ncm91cHM9MV0gTnVtYmVyIG9mIGdyb3VwcyB0byBkaXZpZGUgYG51bV9iZWFtc2AgaW50byBpbiBvcmRlciB0byBlbnN1cmUgZGl2ZXJzaXR5IGFtb25nIGRpZmZlcmVudCBncm91cHMgb2YgYmVhbXMuIFNlZSBbdGhpcyBwYXBlcl0oaHR0cHM6Ly9hcnhpdi5vcmcvcGRmLzE2MTAuMDI0MjQucGRmKSBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBba3dhcmdzLnBlbmFsdHlfYWxwaGE9bnVsbF0gVGhlIHZhbHVlcyBiYWxhbmNlIHRoZSBtb2RlbCBjb25maWRlbmNlIGFuZCB0aGUgZGVnZW5lcmF0aW9uIHBlbmFsdHkgaW4gY29udHJhc3RpdmUgc2VhcmNoIGRlY29kaW5nLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2t3YXJncy51c2VfY2FjaGU9dHJ1ZV0gV2hldGhlciBvciBub3QgdGhlIG1vZGVsIHNob3VsZCB1c2UgdGhlIHBhc3QgbGFzdCBrZXkvdmFsdWVzIGF0dGVudGlvbnMgKGlmIGFwcGxpY2FibGUgdG8gdGhlIG1vZGVsKSB0byBzcGVlZCB1cCBkZWNvZGluZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBba3dhcmdzLnRlbXBlcmF0dXJlPTEuMF0gVGhlIHZhbHVlIHVzZWQgdG8gbW9kdWxhdGUgdGhlIG5leHQgdG9rZW4gcHJvYmFiaWxpdGllcy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2t3YXJncy50b3Bfaz01MF0gVGhlIG51bWJlciBvZiBoaWdoZXN0IHByb2JhYmlsaXR5IHZvY2FidWxhcnkgdG9rZW5zIHRvIGtlZXAgZm9yIHRvcC1rLWZpbHRlcmluZy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2t3YXJncy50b3BfcD0xLjBdIElmIHNldCB0byBmbG9hdCA8IDEsIG9ubHkgdGhlIHNtYWxsZXN0IHNldCBvZiBtb3N0IHByb2JhYmxlIHRva2VucyB3aXRoIHByb2JhYmlsaXRpZXMgdGhhdCBhZGQgdXAgdG8gYHRvcF9wYCBvciBoaWdoZXIgYXJlIGtlcHQgZm9yIGdlbmVyYXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtrd2FyZ3MudHlwaWNhbF9wPTEuMF0gTG9jYWwgdHlwaWNhbGl0eSBtZWFzdXJlcyBob3cgc2ltaWxhciB0aGUgY29uZGl0aW9uYWwgcHJvYmFiaWxpdHkgb2YgcHJlZGljdGluZyBhIHRhcmdldCB0b2tlbiBuZXh0IGlzIHRvIHRoZSBleHBlY3RlZCBjb25kaXRpb25hbCBwcm9iYWJpbGl0eSBvZiBwcmVkaWN0aW5nIGEgcmFuZG9tIHRva2VuIG5leHQsIGdpdmVuIHRoZSBwYXJ0aWFsIHRleHQgYWxyZWFkeSBnZW5lcmF0ZWQuIElmIHNldCB0byBmbG9hdCA8IDEsIHRoZSBzbWFsbGVzdCBzZXQgb2YgdGhlIG1vc3QgbG9jYWxseSB0eXBpY2FsIHRva2VucyB3aXRoIHByb2JhYmlsaXRpZXMgdGhhdCBhZGQgdXAgdG8gYHR5cGljYWxfcGAgb3IgaGlnaGVyIGFyZSBrZXB0IGZvciBnZW5lcmF0aW9uLiBTZWUgW3RoaXMgcGFwZXJdKGh0dHBzOi8vYXJ4aXYub3JnL3BkZi8yMjAyLjAwNjY2LnBkZikgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2t3YXJncy5lcHNpbG9uX2N1dG9mZj0wLjBdIElmIHNldCB0byBmbG9hdCBzdHJpY3RseSBiZXR3ZWVuIDAgYW5kIDEsIG9ubHkgdG9rZW5zIHdpdGggYSBjb25kaXRpb25hbCBwcm9iYWJpbGl0eSBncmVhdGVyIHRoYW4gYGVwc2lsb25fY3V0b2ZmYCB3aWxsIGJlIHNhbXBsZWQuIEluIHRoZSBwYXBlciwgc3VnZ2VzdGVkIHZhbHVlcyByYW5nZSBmcm9tIDNlLTQgdG8gOWUtNCwgZGVwZW5kaW5nIG9uIHRoZSBzaXplIG9mIHRoZSBtb2RlbC4gU2VlIFtUcnVuY2F0aW9uIFNhbXBsaW5nIGFzIExhbmd1YWdlIE1vZGVsIERlc21vb3RoaW5nXShodHRwczovL2FyeGl2Lm9yZy9hYnMvMjIxMC4xNTE5MSkgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2t3YXJncy5ldGFfY3V0b2ZmPTAuMF0gRXRhIHNhbXBsaW5nIGlzIGEgaHlicmlkIG9mIGxvY2FsbHkgdHlwaWNhbCBzYW1wbGluZyBhbmQgZXBzaWxvbiBzYW1wbGluZy4gSWYgc2V0IHRvIGZsb2F0IHN0cmljdGx5IGJldHdlZW4gMCBhbmQgMSwgYSB0b2tlbiBpcyBvbmx5IGNvbnNpZGVyZWQgaWYgaXQgaXMgZ3JlYXRlciB0aGFuIGVpdGhlciBgZXRhX2N1dG9mZmAgb3IgYHNxcnQoZXRhX2N1dG9mZikgKiBleHAoLWVudHJvcHkoc29mdG1heChuZXh0X3Rva2VuX2xvZ2l0cykpKWAuIFRoZSBsYXR0ZXIgdGVybSBpcyBpbnR1aXRpdmVseSB0aGUgZXhwZWN0ZWQgbmV4dCB0b2tlbiBwcm9iYWJpbGl0eSwgc2NhbGVkIGJ5IGBzcXJ0KGV0YV9jdXRvZmYpYC4gSW4gdGhlIHBhcGVyLCBzdWdnZXN0ZWQgdmFsdWVzIHJhbmdlIGZyb20gM2UtNCB0byAyZS0zLCBkZXBlbmRpbmcgb24gdGhlIHNpemUgb2YgdGhlIG1vZGVsLiBTZWUgW1RydW5jYXRpb24gU2FtcGxpbmcgYXMgTGFuZ3VhZ2UgTW9kZWwgRGVzbW9vdGhpbmddKGh0dHBzOi8vYXJ4aXYub3JnL2Ficy8yMjEwLjE1MTkxKSBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBba3dhcmdzLmRpdmVyc2l0eV9wZW5hbHR5PTAuMF0gVGhpcyB2YWx1ZSBpcyBzdWJ0cmFjdGVkIGZyb20gYSBiZWFtJ3Mgc2NvcmUgaWYgaXQgZ2VuZXJhdGVzIGEgdG9rZW4gc2FtZSBhcyBhbnkgYmVhbSBmcm9tIG90aGVyIGdyb3VwIGF0IGEgcGFydGljdWxhciB0aW1lLiBOb3RlIHRoYXQgYGRpdmVyc2l0eV9wZW5hbHR5YCBpcyBvbmx5IGVmZmVjdGl2ZSBpZiBgZ3JvdXAgYmVhbSBzZWFyY2hgIGlzIGVuYWJsZWQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtrd2FyZ3MucmVwZXRpdGlvbl9wZW5hbHR5PTEuMF0gVGhlIHBhcmFtZXRlciBmb3IgcmVwZXRpdGlvbiBwZW5hbHR5LiAxLjAgbWVhbnMgbm8gcGVuYWx0eS4gU2VlIFt0aGlzIHBhcGVyXShodHRwczovL2FyeGl2Lm9yZy9wZGYvMTkwOS4wNTg1OC5wZGYpIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtrd2FyZ3MuZW5jb2Rlcl9yZXBldGl0aW9uX3BlbmFsdHk9MS4wXSBUaGUgcGFyYW1hdGVyIGZvciBlbmNvZGVyX3JlcGV0aXRpb25fcGVuYWx0eS4gQW4gZXhwb25lbnRpYWwgcGVuYWx0eSBvbiBzZXF1ZW5jZXMgdGhhdCBhcmUgbm90IGluIHRoZSBvcmlnaW5hbCBpbnB1dC4gMS4wIG1lYW5zIG5vIHBlbmFsdHkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtrd2FyZ3MubGVuZ3RoX3BlbmFsdHk9MS4wXSBFeHBvbmVudGlhbCBwZW5hbHR5IHRvIHRoZSBsZW5ndGggdGhhdCBpcyB1c2VkIHdpdGggYmVhbS1iYXNlZCBnZW5lcmF0aW9uLiBJdCBpcyBhcHBsaWVkIGFzIGFuIGV4cG9uZW50IHRvIHRoZSBzZXF1ZW5jZSBsZW5ndGgsIHdoaWNoIGluIHR1cm4gaXMgdXNlZCB0byBkaXZpZGUgdGhlIHNjb3JlIG9mIHRoZSBzZXF1ZW5jZS4gU2luY2UgdGhlIHNjb3JlIGlzIHRoZSBsb2cgbGlrZWxpaG9vZCBvZiB0aGUgc2VxdWVuY2UgKGkuZS4gbmVnYXRpdmUpLCBgbGVuZ3RoX3BlbmFsdHlgID4gMC4wIHByb21vdGVzIGxvbmdlciBzZXF1ZW5jZXMsIHdoaWxlIGBsZW5ndGhfcGVuYWx0eWAgPCAwLjAgZW5jb3VyYWdlcyBzaG9ydGVyIHNlcXVlbmNlcy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2t3YXJncy5ub19yZXBlYXRfbmdyYW1fc2l6ZT0wXSBJZiBzZXQgdG8gaW50ID4gMCwgYWxsIG5ncmFtcyBvZiB0aGF0IHNpemUgY2FuIG9ubHkgb2NjdXIgb25jZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcltdW119IFtrd2FyZ3MuYmFkX3dvcmRzX2lkcz1udWxsXSBMaXN0IG9mIHRva2VuIGlkcyB0aGF0IGFyZSBub3QgYWxsb3dlZCB0byBiZSBnZW5lcmF0ZWQuIEluIG9yZGVyIHRvIGdldCB0aGUgdG9rZW4gaWRzIG9mIHRoZSB3b3JkcyB0aGF0IHNob3VsZCBub3QgYXBwZWFyIGluIHRoZSBnZW5lcmF0ZWQgdGV4dCwgdXNlIGAoYXdhaXQgdG9rZW5pemVyKGJhZF93b3Jkcywge2FkZF9wcmVmaXhfc3BhY2U6IHRydWUsIGFkZF9zcGVjaWFsX3Rva2VuczogZmFsc2V9KSkuaW5wdXRfaWRzYC5cbiAgICAgKiBAcGFyYW0ge251bWJlcltdW118bnVtYmVyW11bXVtdfSBba3dhcmdzLmZvcmNlX3dvcmRzX2lkcz1udWxsXSBMaXN0IG9mIHRva2VuIGlkcyB0aGF0IG11c3QgYmUgZ2VuZXJhdGVkLiBJZiBnaXZlbiBhIGBudW1iZXJbXVtdYCwgdGhpcyBpcyB0cmVhdGVkIGFzIGEgc2ltcGxlIGxpc3Qgb2Ygd29yZHMgdGhhdCBtdXN0IGJlIGluY2x1ZGVkLCB0aGUgb3Bwb3NpdGUgdG8gYGJhZF93b3Jkc19pZHNgLiBJZiBnaXZlbiBgbnVtYmVyW11bXVtdYCwgdGhpcyB0cmlnZ2VycyBhIFtkaXNqdW5jdGl2ZSBjb25zdHJhaW50XShodHRwczovL2dpdGh1Yi5jb20vaHVnZ2luZ2ZhY2UvdHJhbnNmb3JtZXJzL2lzc3Vlcy8xNDA4MSksIHdoZXJlIG9uZSBjYW4gYWxsb3cgZGlmZmVyZW50IGZvcm1zIG9mIGVhY2ggd29yZC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtrd2FyZ3MucmVub3JtYWxpemVfbG9naXRzPWZhbHNlXSBXaGV0aGVyIHRvIHJlbm9ybWFsaXplIHRoZSBsb2dpdHMgYWZ0ZXIgYXBwbHlpbmcgYWxsIHRoZSBsb2dpdHMgcHJvY2Vzc29ycyBvciB3YXJwZXJzIChpbmNsdWRpbmcgdGhlIGN1c3RvbSBvbmVzKS4gSXQncyBoaWdobHkgcmVjb21tZW5kZWQgdG8gc2V0IHRoaXMgZmxhZyB0byBgdHJ1ZWAgYXMgdGhlIHNlYXJjaCBhbGdvcml0aG1zIHN1cHBvc2UgdGhlIHNjb3JlIGxvZ2l0cyBhcmUgbm9ybWFsaXplZCBidXQgc29tZSBsb2dpdCBwcm9jZXNzb3JzIG9yIHdhcnBlcnMgYnJlYWsgdGhlIG5vcm1hbGl6YXRpb24uXG4gICAgICogQHBhcmFtIHtPYmplY3RbXX0gW2t3YXJncy5jb25zdHJhaW50cz1udWxsXSBDdXN0b20gY29uc3RyYWludHMgdGhhdCBjYW4gYmUgYWRkZWQgdG8gdGhlIGdlbmVyYXRpb24gdG8gZW5zdXJlIHRoYXQgdGhlIG91dHB1dCB3aWxsIGNvbnRhaW4gdGhlIHVzZSBvZiBjZXJ0YWluIHRva2VucyBhcyBkZWZpbmVkIGJ5IGBDb25zdHJhaW50YCBvYmplY3RzLCBpbiB0aGUgbW9zdCBzZW5zaWJsZSB3YXkgcG9zc2libGUuXG4gICAgICogXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtrd2FyZ3MuZm9yY2VkX2Jvc190b2tlbl9pZD1udWxsXSBUaGUgaWQgb2YgdGhlIHRva2VuIHRvIGZvcmNlIGFzIHRoZSBmaXJzdCBnZW5lcmF0ZWQgdG9rZW4gYWZ0ZXIgdGhlIGBkZWNvZGVyX3N0YXJ0X3Rva2VuX2lkYC4gVXNlZnVsIGZvciBtdWx0aWxpbmd1YWwgbW9kZWxzIGxpa2UgbUJBUlQgd2hlcmUgdGhlIGZpcnN0IGdlbmVyYXRlZCB0b2tlbiBuZWVkcyB0byBiZSB0aGUgdGFyZ2V0IGxhbmd1YWdlIHRva2VuLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfG51bWJlcltdfSBba3dhcmdzLmZvcmNlZF9lb3NfdG9rZW5faWQ9bnVsbF0gVGhlIGlkIG9mIHRoZSB0b2tlbiB0byBmb3JjZSBhcyB0aGUgbGFzdCBnZW5lcmF0ZWQgdG9rZW4gd2hlbiBgbWF4X2xlbmd0aGAgaXMgcmVhY2hlZC4gT3B0aW9uYWxseSwgdXNlIGEgbGlzdCB0byBzZXQgbXVsdGlwbGUgKmVuZC1vZi1zZXF1ZW5jZSogdG9rZW5zLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2t3YXJncy5yZW1vdmVfaW52YWxpZF92YWx1ZXM9ZmFsc2VdIFdoZXRoZXIgdG8gcmVtb3ZlIHBvc3NpYmxlICpuYW4qIGFuZCAqaW5mKiBvdXRwdXRzIG9mIHRoZSBtb2RlbCB0byBwcmV2ZW50IHRoZSBnZW5lcmF0aW9uIG1ldGhvZCB0byBjcmFzaC4gTm90ZSB0aGF0IHVzaW5nIGByZW1vdmVfaW52YWxpZF92YWx1ZXNgIGNhbiBzbG93IGRvd24gZ2VuZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcltdfSBba3dhcmdzLmV4cG9uZW50aWFsX2RlY2F5X2xlbmd0aF9wZW5hbHR5PW51bGxdIFRoaXMgVHVwbGUgYWRkcyBhbiBleHBvbmVudGlhbGx5IGluY3JlYXNpbmcgbGVuZ3RoIHBlbmFsdHksIGFmdGVyIGEgY2VydGFpbiBhbW91bnQgb2YgdG9rZW5zIGhhdmUgYmVlbiBnZW5lcmF0ZWQuIFRoZSB0dXBsZSBzaGFsbCBjb25zaXN0IG9mOiBgKHN0YXJ0X2luZGV4LCBkZWNheV9mYWN0b3IpYCB3aGVyZSBgc3RhcnRfaW5kZXhgIGluZGljYXRlcyB3aGVyZSBwZW5hbHR5IHN0YXJ0cyBhbmQgYGRlY2F5X2ZhY3RvcmAgcmVwcmVzZW50cyB0aGUgZmFjdG9yIG9mIGV4cG9uZW50aWFsIGRlY2F5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyW119IFtrd2FyZ3Muc3VwcHJlc3NfdG9rZW5zPW51bGxdIEEgbGlzdCBvZiB0b2tlbnMgdGhhdCB3aWxsIGJlIHN1cHByZXNzZWQgYXQgZ2VuZXJhdGlvbi4gVGhlIGBTdXByZXNzVG9rZW5zYCBsb2dpdCBwcm9jZXNzb3Igd2lsbCBzZXQgdGhlaXIgbG9nIHByb2JzIHRvIGAtaW5mYCBzbyB0aGF0IHRoZXkgYXJlIG5vdCBzYW1wbGVkLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyW119IFtrd2FyZ3MuYmVnaW5fc3VwcHJlc3NfdG9rZW5zPW51bGxdIEEgbGlzdCBvZiB0b2tlbnMgdGhhdCB3aWxsIGJlIHN1cHByZXNzZWQgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgZ2VuZXJhdGlvbi4gVGhlIGBTdXByZXNzQmVnaW5Ub2tlbnNgIGxvZ2l0IHByb2Nlc3NvciB3aWxsIHNldCB0aGVpciBsb2cgcHJvYnMgdG8gYC1pbmZgIHNvIHRoYXQgdGhleSBhcmUgbm90IHNhbXBsZWQuXG4gICAgICogQHBhcmFtIHtudW1iZXJbXVtdfSBba3dhcmdzLmZvcmNlZF9kZWNvZGVyX2lkcz1udWxsXSBBIGxpc3Qgb2YgcGFpcnMgb2YgaW50ZWdlcnMgd2hpY2ggaW5kaWNhdGVzIGEgbWFwcGluZyBmcm9tIGdlbmVyYXRpb24gaW5kaWNlcyB0byB0b2tlbiBpbmRpY2VzIHRoYXQgd2lsbCBiZSBmb3JjZWQgYmVmb3JlIHNhbXBsaW5nLiBGb3IgZXhhbXBsZSwgYFtbMSwgMTIzXV1gIG1lYW5zIHRoZSBzZWNvbmQgZ2VuZXJhdGVkIHRva2VuIHdpbGwgYWx3YXlzIGJlIGEgdG9rZW4gb2YgaW5kZXggMTIzLlxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBba3dhcmdzLm51bV9yZXR1cm5fc2VxdWVuY2VzPTFdIFRoZSBudW1iZXIgb2YgaW5kZXBlbmRlbnRseSBjb21wdXRlZCByZXR1cm5lZCBzZXF1ZW5jZXMgZm9yIGVhY2ggZWxlbWVudCBpbiB0aGUgYmF0Y2guXG4gICAgICogQHBhcmFtIHtib29sZWFufSBba3dhcmdzLm91dHB1dF9hdHRlbnRpb25zPWZhbHNlXSBXaGV0aGVyIG9yIG5vdCB0byByZXR1cm4gdGhlIGF0dGVudGlvbnMgdGVuc29ycyBvZiBhbGwgYXR0ZW50aW9uIGxheWVycy4gU2VlIGBhdHRlbnRpb25zYCB1bmRlciByZXR1cm5lZCB0ZW5zb3JzIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBba3dhcmdzLm91dHB1dF9oaWRkZW5fc3RhdGVzPWZhbHNlXSBXaGV0aGVyIG9yIG5vdCB0byByZXR1cm4gdGhlIGhpZGRlbiBzdGF0ZXMgb2YgYWxsIGxheWVycy4gU2VlIGBoaWRkZW5fc3RhdGVzYCB1bmRlciByZXR1cm5lZCB0ZW5zb3JzIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBba3dhcmdzLm91dHB1dF9zY29yZXM9ZmFsc2VdIFdoZXRoZXIgb3Igbm90IHRvIHJldHVybiB0aGUgcHJlZGljdGlvbiBzY29yZXMuIFNlZSBgc2NvcmVzYCB1bmRlciByZXR1cm5lZCB0ZW5zb3JzIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBba3dhcmdzLnJldHVybl9kaWN0X2luX2dlbmVyYXRlPWZhbHNlXSBXaGV0aGVyIG9yIG5vdCB0byByZXR1cm4gYSBgTW9kZWxPdXRwdXRgIGluc3RlYWQgb2YgYSBwbGFpbiB0dXBsZS5cbiAgICAgKiBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2t3YXJncy5wYWRfdG9rZW5faWQ9bnVsbF0gVGhlIGlkIG9mIHRoZSAqcGFkZGluZyogdG9rZW4uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtrd2FyZ3MuYm9zX3Rva2VuX2lkPW51bGxdIFRoZSBpZCBvZiB0aGUgKmJlZ2lubmluZy1vZi1zZXF1ZW5jZSogdG9rZW4uXG4gICAgICogQHBhcmFtIHtudW1iZXJ8bnVtYmVyW119IFtrd2FyZ3MuZW9zX3Rva2VuX2lkPW51bGxdIFRoZSBpZCBvZiB0aGUgKmVuZC1vZi1zZXF1ZW5jZSogdG9rZW4uIE9wdGlvbmFsbHksIHVzZSBhIGxpc3QgdG8gc2V0IG11bHRpcGxlICplbmQtb2Ytc2VxdWVuY2UqIHRva2Vucy5cbiAgICAgKiBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2t3YXJncy5lbmNvZGVyX25vX3JlcGVhdF9uZ3JhbV9zaXplPTBdIElmIHNldCB0byBpbnQgPiAwLCBhbGwgbmdyYW1zIG9mIHRoYXQgc2l6ZSB0aGF0IG9jY3VyIGluIHRoZSBgZW5jb2Rlcl9pbnB1dF9pZHNgIGNhbm5vdCBvY2N1ciBpbiB0aGUgYGRlY29kZXJfaW5wdXRfaWRzYC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2t3YXJncy5kZWNvZGVyX3N0YXJ0X3Rva2VuX2lkPW51bGxdIElmIGFuIGVuY29kZXItZGVjb2RlciBtb2RlbCBzdGFydHMgZGVjb2Rpbmcgd2l0aCBhIGRpZmZlcmVudCB0b2tlbiB0aGFuICpib3MqLCB0aGUgaWQgb2YgdGhhdCB0b2tlbi5cbiAgICAgKiBcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2t3YXJncy5nZW5lcmF0aW9uX2t3YXJncz17fV0gQWRkaXRpb25hbCBnZW5lcmF0aW9uIGt3YXJncyB3aWxsIGJlIGZvcndhcmRlZCB0byB0aGUgYGdlbmVyYXRlYCBmdW5jdGlvbiBvZiB0aGUgbW9kZWwuIEt3YXJncyB0aGF0IGFyZSBub3QgcHJlc2VudCBpbiBgZ2VuZXJhdGVgJ3Mgc2lnbmF0dXJlIHdpbGwgYmUgdXNlZCBpbiB0aGUgbW9kZWwgZm9yd2FyZCBwYXNzLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGt3YXJncyA9IHt9KSB7XG4gICAgICAgIC8vIFBhcmFtZXRlcnMgdGhhdCBjb250cm9sIHRoZSBsZW5ndGggb2YgdGhlIG91dHB1dFxuICAgICAgICB0aGlzLm1heF9sZW5ndGggPSBrd2FyZ3MubWF4X2xlbmd0aCA/PyAyMDtcbiAgICAgICAgdGhpcy5tYXhfbmV3X3Rva2VucyA9IGt3YXJncy5tYXhfbmV3X3Rva2VucyA/PyBudWxsO1xuICAgICAgICB0aGlzLm1pbl9sZW5ndGggPSBrd2FyZ3MubWluX2xlbmd0aCA/PyAwO1xuICAgICAgICB0aGlzLm1pbl9uZXdfdG9rZW5zID0ga3dhcmdzLm1pbl9uZXdfdG9rZW5zID8/IG51bGw7XG4gICAgICAgIHRoaXMuZWFybHlfc3RvcHBpbmcgPSBrd2FyZ3MuZWFybHlfc3RvcHBpbmcgPz8gZmFsc2U7XG4gICAgICAgIHRoaXMubWF4X3RpbWUgPSBrd2FyZ3MubWF4X3RpbWUgPz8gbnVsbDtcblxuICAgICAgICAvLyBQYXJhbWV0ZXJzIHRoYXQgY29udHJvbCB0aGUgZ2VuZXJhdGlvbiBzdHJhdGVneSB1c2VkXG4gICAgICAgIHRoaXMuZG9fc2FtcGxlID0ga3dhcmdzLmRvX3NhbXBsZSA/PyBmYWxzZTtcbiAgICAgICAgdGhpcy5udW1fYmVhbXMgPSBrd2FyZ3MubnVtX2JlYW1zID8/IDE7XG4gICAgICAgIHRoaXMubnVtX2JlYW1fZ3JvdXBzID0ga3dhcmdzLm51bV9iZWFtX2dyb3VwcyA/PyAxO1xuICAgICAgICB0aGlzLnBlbmFsdHlfYWxwaGEgPSBrd2FyZ3MucGVuYWx0eV9hbHBoYSA/PyBudWxsO1xuICAgICAgICB0aGlzLnVzZV9jYWNoZSA9IGt3YXJncy51c2VfY2FjaGUgPz8gdHJ1ZTtcblxuICAgICAgICAvLyBQYXJhbWV0ZXJzIGZvciBtYW5pcHVsYXRpb24gb2YgdGhlIG1vZGVsIG91dHB1dCBsb2dpdHNcbiAgICAgICAgdGhpcy50ZW1wZXJhdHVyZSA9IGt3YXJncy50ZW1wZXJhdHVyZSA/PyAxLjA7XG4gICAgICAgIHRoaXMudG9wX2sgPSBrd2FyZ3MudG9wX2sgPz8gNTA7XG4gICAgICAgIHRoaXMudG9wX3AgPSBrd2FyZ3MudG9wX3AgPz8gMS4wO1xuICAgICAgICB0aGlzLnR5cGljYWxfcCA9IGt3YXJncy50eXBpY2FsX3AgPz8gMS4wO1xuICAgICAgICB0aGlzLmVwc2lsb25fY3V0b2ZmID0ga3dhcmdzLmVwc2lsb25fY3V0b2ZmID8/IDAuMDtcbiAgICAgICAgdGhpcy5ldGFfY3V0b2ZmID0ga3dhcmdzLmV0YV9jdXRvZmYgPz8gMC4wO1xuICAgICAgICB0aGlzLmRpdmVyc2l0eV9wZW5hbHR5ID0ga3dhcmdzLmRpdmVyc2l0eV9wZW5hbHR5ID8/IDAuMDtcbiAgICAgICAgdGhpcy5yZXBldGl0aW9uX3BlbmFsdHkgPSBrd2FyZ3MucmVwZXRpdGlvbl9wZW5hbHR5ID8/IDEuMDtcbiAgICAgICAgdGhpcy5lbmNvZGVyX3JlcGV0aXRpb25fcGVuYWx0eSA9IGt3YXJncy5lbmNvZGVyX3JlcGV0aXRpb25fcGVuYWx0eSA/PyAxLjA7XG4gICAgICAgIHRoaXMubGVuZ3RoX3BlbmFsdHkgPSBrd2FyZ3MubGVuZ3RoX3BlbmFsdHkgPz8gMS4wO1xuICAgICAgICB0aGlzLm5vX3JlcGVhdF9uZ3JhbV9zaXplID0ga3dhcmdzLm5vX3JlcGVhdF9uZ3JhbV9zaXplID8/IDA7XG4gICAgICAgIHRoaXMuYmFkX3dvcmRzX2lkcyA9IGt3YXJncy5iYWRfd29yZHNfaWRzID8/IG51bGw7XG4gICAgICAgIHRoaXMuZm9yY2Vfd29yZHNfaWRzID0ga3dhcmdzLmZvcmNlX3dvcmRzX2lkcyA/PyBudWxsO1xuICAgICAgICB0aGlzLnJlbm9ybWFsaXplX2xvZ2l0cyA9IGt3YXJncy5yZW5vcm1hbGl6ZV9sb2dpdHMgPz8gZmFsc2U7XG4gICAgICAgIHRoaXMuY29uc3RyYWludHMgPSBrd2FyZ3MuY29uc3RyYWludHMgPz8gbnVsbDtcbiAgICAgICAgdGhpcy5mb3JjZWRfYm9zX3Rva2VuX2lkID0ga3dhcmdzLmZvcmNlZF9ib3NfdG9rZW5faWQgPz8gbnVsbDtcbiAgICAgICAgdGhpcy5mb3JjZWRfZW9zX3Rva2VuX2lkID0ga3dhcmdzLmZvcmNlZF9lb3NfdG9rZW5faWQgPz8gbnVsbDtcbiAgICAgICAgdGhpcy5yZW1vdmVfaW52YWxpZF92YWx1ZXMgPSBrd2FyZ3MucmVtb3ZlX2ludmFsaWRfdmFsdWVzID8/IGZhbHNlO1xuICAgICAgICB0aGlzLmV4cG9uZW50aWFsX2RlY2F5X2xlbmd0aF9wZW5hbHR5ID0ga3dhcmdzLmV4cG9uZW50aWFsX2RlY2F5X2xlbmd0aF9wZW5hbHR5ID8/IG51bGw7XG4gICAgICAgIHRoaXMuc3VwcHJlc3NfdG9rZW5zID0ga3dhcmdzLnN1cHByZXNzX3Rva2VucyA/PyBudWxsO1xuICAgICAgICB0aGlzLmJlZ2luX3N1cHByZXNzX3Rva2VucyA9IGt3YXJncy5iZWdpbl9zdXBwcmVzc190b2tlbnMgPz8gbnVsbDtcbiAgICAgICAgdGhpcy5mb3JjZWRfZGVjb2Rlcl9pZHMgPSBrd2FyZ3MuZm9yY2VkX2RlY29kZXJfaWRzID8/IG51bGw7XG5cbiAgICAgICAgLy8gUGFyYW1ldGVycyB0aGF0IGRlZmluZSB0aGUgb3V0cHV0IHZhcmlhYmxlcyBvZiBgZ2VuZXJhdGVgXG4gICAgICAgIHRoaXMubnVtX3JldHVybl9zZXF1ZW5jZXMgPSBrd2FyZ3MubnVtX3JldHVybl9zZXF1ZW5jZXMgPz8gMTtcbiAgICAgICAgdGhpcy5vdXRwdXRfYXR0ZW50aW9ucyA9IGt3YXJncy5vdXRwdXRfYXR0ZW50aW9ucyA/PyBmYWxzZTtcbiAgICAgICAgdGhpcy5vdXRwdXRfaGlkZGVuX3N0YXRlcyA9IGt3YXJncy5vdXRwdXRfaGlkZGVuX3N0YXRlcyA/PyBmYWxzZTtcbiAgICAgICAgdGhpcy5vdXRwdXRfc2NvcmVzID0ga3dhcmdzLm91dHB1dF9zY29yZXMgPz8gZmFsc2U7XG4gICAgICAgIHRoaXMucmV0dXJuX2RpY3RfaW5fZ2VuZXJhdGUgPSBrd2FyZ3MucmV0dXJuX2RpY3RfaW5fZ2VuZXJhdGUgPz8gZmFsc2U7XG5cbiAgICAgICAgLy8gU3BlY2lhbCB0b2tlbnMgdGhhdCBjYW4gYmUgdXNlZCBhdCBnZW5lcmF0aW9uIHRpbWVcbiAgICAgICAgdGhpcy5wYWRfdG9rZW5faWQgPSBrd2FyZ3MucGFkX3Rva2VuX2lkID8/IG51bGw7XG4gICAgICAgIHRoaXMuYm9zX3Rva2VuX2lkID0ga3dhcmdzLmJvc190b2tlbl9pZCA/PyBudWxsO1xuICAgICAgICB0aGlzLmVvc190b2tlbl9pZCA9IGt3YXJncy5lb3NfdG9rZW5faWQgPz8gbnVsbDtcblxuICAgICAgICAvLyBHZW5lcmF0aW9uIHBhcmFtZXRlcnMgZXhjbHVzaXZlIHRvIGVuY29kZXItZGVjb2RlciBtb2RlbHNcbiAgICAgICAgdGhpcy5lbmNvZGVyX25vX3JlcGVhdF9uZ3JhbV9zaXplID0ga3dhcmdzLmVuY29kZXJfbm9fcmVwZWF0X25ncmFtX3NpemUgPz8gMDtcbiAgICAgICAgdGhpcy5kZWNvZGVyX3N0YXJ0X3Rva2VuX2lkID0ga3dhcmdzLmRlY29kZXJfc3RhcnRfdG9rZW5faWQgPz8gbnVsbDtcblxuICAgICAgICAvLyBXaWxkIGNhcmRcbiAgICAgICAgdGhpcy5nZW5lcmF0aW9uX2t3YXJncyA9IGt3YXJncy5nZW5lcmF0aW9uX2t3YXJncyA/PyB7fTtcbiAgICB9XG59XG5cblxuLyoqXG4gKiBTYW1wbGVyIGlzIGEgYmFzZSBjbGFzcyBmb3IgYWxsIHNhbXBsaW5nIG1ldGhvZHMgdXNlZCBmb3IgdGV4dCBnZW5lcmF0aW9uLlxuICovXG5leHBvcnQgY2xhc3MgU2FtcGxlciBleHRlbmRzIENhbGxhYmxlIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IFNhbXBsZXIgb2JqZWN0IHdpdGggdGhlIHNwZWNpZmllZCBnZW5lcmF0aW9uIGNvbmZpZy5cbiAgICAgKiBAcGFyYW0ge0dlbmVyYXRpb25Db25maWd9IGdlbmVyYXRpb25fY29uZmlnIFRoZSBnZW5lcmF0aW9uIGNvbmZpZy5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihnZW5lcmF0aW9uX2NvbmZpZykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmdlbmVyYXRpb25fY29uZmlnID0gZ2VuZXJhdGlvbl9jb25maWc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXhlY3V0ZXMgdGhlIHNhbXBsZXIsIHVzaW5nIHRoZSBzcGVjaWZpZWQgbG9naXRzLlxuICAgICAqIEBwYXJhbSB7VGVuc29yfSBsb2dpdHNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICAgKi9cbiAgICBfY2FsbChsb2dpdHMsIGluZGV4ID0gLTEpIHtcbiAgICAgICAgLy8gU2FtcGxlIGZyb20gbG9naXRzLCBvZiBkaW1zIFtiYXRjaCwgc2VxdWVuY2VfbGVuZ3RoLCB2b2NhYl9zaXplXS5cbiAgICAgICAgLy8gSWYgaW5kZXggaXMgc3BlY2lmaWVkLCBzYW1wbGUgZnJvbSBbYmF0Y2gsIGluZGV4LCB2b2NhYl9zaXplXS5cbiAgICAgICAgcmV0dXJuIHRoaXMuc2FtcGxlKGxvZ2l0cywgaW5kZXgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFic3RyYWN0IG1ldGhvZCBmb3Igc2FtcGxpbmcgdGhlIGxvZ2l0cy5cbiAgICAgKiBAcGFyYW0ge1RlbnNvcn0gbG9naXRzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gICAgICogQHRocm93cyB7RXJyb3J9XG4gICAgICovXG4gICAgc2FtcGxlKGxvZ2l0cywgaW5kZXgpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJzYW1wbGUgc2hvdWxkIGJlIGltcGxlbWVudGVkIGluIHN1YmNsYXNzZXMuXCIpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgc3BlY2lmaWVkIGxvZ2l0cyBhcyBhbiBhcnJheSwgd2l0aCB0ZW1wZXJhdHVyZSBhcHBsaWVkLlxuICAgICAqIEBwYXJhbSB7VGVuc29yfSBsb2dpdHNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9XG4gICAgICovXG4gICAgZ2V0TG9naXRzKGxvZ2l0cywgaW5kZXgpIHtcbiAgICAgICAgbGV0IHZvY2FiU2l6ZSA9IGxvZ2l0cy5kaW1zLmF0KC0xKTtcblxuICAgICAgICBsZXQgbG9ncyA9IGxvZ2l0cy5kYXRhO1xuXG4gICAgICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgIGxvZ3MgPSBsb2dzLnNsaWNlKC12b2NhYlNpemUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGV0IHN0YXJ0SW5kZXggPSBpbmRleCAqIHZvY2FiU2l6ZTtcbiAgICAgICAgICAgIGxvZ3MgPSBsb2dzLnNsaWNlKHN0YXJ0SW5kZXgsIHN0YXJ0SW5kZXggKyB2b2NhYlNpemUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYWRkIHRlbXBlcmF0dXJlXG4gICAgICAgIGlmICh0aGlzLmdlbmVyYXRpb25fY29uZmlnLnRlbXBlcmF0dXJlID4gMCkge1xuICAgICAgICAgICAgbG9ncyA9IGxvZ3MubWFwKHggPT4geCAvIHRoaXMuZ2VuZXJhdGlvbl9jb25maWcudGVtcGVyYXR1cmUpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxvZ3M7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2VsZWN0cyBhbiBpdGVtIHJhbmRvbWx5IGJhc2VkIG9uIHRoZSBzcGVjaWZpZWQgcHJvYmFiaWxpdGllcy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwcm9iYWJpbGl0aWVzIEFuIGFycmF5IG9mIHByb2JhYmlsaXRpZXMgdG8gdXNlIGZvciBzZWxlY3Rpb24uXG4gICAgICogQHJldHVybnMge251bWJlcn0gVGhlIGluZGV4IG9mIHRoZSBzZWxlY3RlZCBpdGVtLlxuICAgICAqL1xuICAgIHJhbmRvbVNlbGVjdChwcm9iYWJpbGl0aWVzKSB7XG4gICAgICAgIC8vIFJldHVybiBpbmRleCBvZiBjaG9zZW4gaXRlbVxuICAgICAgICBsZXQgc3VtUHJvYmFiaWxpdGllcyA9IHByb2JhYmlsaXRpZXMucmVkdWNlKChhY2MsIGN1cnIpID0+IGFjYyArIGN1cnIsIDApO1xuXG4gICAgICAgIGxldCByID0gTWF0aC5yYW5kb20oKSAqIHN1bVByb2JhYmlsaXRpZXM7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJvYmFiaWxpdGllcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgciAtPSBwcm9iYWJpbGl0aWVzW2ldO1xuICAgICAgICAgICAgaWYgKHIgPD0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAwOyAvLyByZXR1cm4gZmlyc3QgKG1vc3QgcHJvYmFibGUpIGFzIGEgZmFsbGJhY2tcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgU2FtcGxlciBvYmplY3QgYmFzZWQgb24gdGhlIHNwZWNpZmllZCBvcHRpb25zLlxuICAgICAqIEBwYXJhbSB7R2VuZXJhdGlvbkNvbmZpZ30gZ2VuZXJhdGlvbl9jb25maWcgQW4gb2JqZWN0IGNvbnRhaW5pbmcgb3B0aW9ucyBmb3IgdGhlIHNhbXBsZXIuXG4gICAgICogQHJldHVybnMge1NhbXBsZXJ9IEEgU2FtcGxlciBvYmplY3QuXG4gICAgICovXG4gICAgc3RhdGljIGdldFNhbXBsZXIoZ2VuZXJhdGlvbl9jb25maWcpIHtcbiAgICAgICAgLy8gLSAqZ3JlZWR5IGRlY29kaW5nKjogYG51bV9iZWFtcz0xYCBhbmQgYGRvX3NhbXBsZT1GYWxzZWBcbiAgICAgICAgLy8gLSAqY29udHJhc3RpdmUgc2VhcmNoKjogYHBlbmFsdHlfYWxwaGE+MGAgYW5kIGB0b3Bfaz4xYFxuICAgICAgICAvLyAtICptdWx0aW5vbWlhbCBzYW1wbGluZyo6IGBudW1fYmVhbXM9MWAgYW5kIGBkb19zYW1wbGU9VHJ1ZWBcbiAgICAgICAgLy8gLSAqYmVhbS1zZWFyY2ggZGVjb2RpbmcqOiBgbnVtX2JlYW1zPjFgIGFuZCBgZG9fc2FtcGxlPUZhbHNlYFxuICAgICAgICAvLyAtICpiZWFtLXNlYXJjaCBtdWx0aW5vbWlhbCBzYW1wbGluZyo6IGBudW1fYmVhbXM+MWAgYW5kIGBkb19zYW1wbGU9VHJ1ZWBcbiAgICAgICAgLy8gLSAqZGl2ZXJzZSBiZWFtLXNlYXJjaCBkZWNvZGluZyo6IGBudW1fYmVhbXM+MWAgYW5kIGBudW1fYmVhbV9ncm91cHM+MWBcbiAgICAgICAgLy8gLSAqY29uc3RyYWluZWQgYmVhbS1zZWFyY2ggZGVjb2RpbmcqOiBgY29uc3RyYWludHMhPU5vbmVgIG9yIGBmb3JjZV93b3Jkc19pZHMhPU5vbmVgXG5cbiAgICAgICAgLy8gTk9URTogYmVhbSBzZWFyY2ggaXMgaW1wbGVtZW50ZWQgZGlyZWN0bHkgaW50byB0aGUgZ2VuZXJhdGlvbiBmdW5jdGlvblxuICAgICAgICBpZiAoZ2VuZXJhdGlvbl9jb25maWcuZG9fc2FtcGxlKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IE11bHRpbm9taWFsU2FtcGxlcihnZW5lcmF0aW9uX2NvbmZpZyk7XG5cbiAgICAgICAgfSBlbHNlIGlmIChnZW5lcmF0aW9uX2NvbmZpZy5udW1fYmVhbXMgPiAxKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEJlYW1TZWFyY2hTYW1wbGVyKGdlbmVyYXRpb25fY29uZmlnKTtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGdlbmVyYXRpb25fY29uZmlnLm51bV9yZXR1cm5fc2VxdWVuY2VzID4gMSkge1xuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKGBudW1fcmV0dXJuX3NlcXVlbmNlcyBoYXMgdG8gYmUgMSB3aGVuIGRvaW5nIGdyZWVkeSBzZWFyY2gsIGJ1dCBpcyAke2dlbmVyYXRpb25fY29uZmlnLm51bV9yZXR1cm5fc2VxdWVuY2VzfS5gKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBHcmVlZHlTYW1wbGVyKGdlbmVyYXRpb25fY29uZmlnKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG4gKiBDbGFzcyByZXByZXNlbnRpbmcgYSBHcmVlZHkgU2FtcGxlci5cbiAqIEBleHRlbmRzIFNhbXBsZXJcbiAqL1xuY2xhc3MgR3JlZWR5U2FtcGxlciBleHRlbmRzIFNhbXBsZXIge1xuICAgIC8qKlxuICAgICAqIFNhbXBsZSB0aGUgbWF4aW11bSBwcm9iYWJpbGl0eSBvZiBhIGdpdmVuIGxvZ2l0cyB0ZW5zb3IuXG4gICAgICogQHBhcmFtIHtUZW5zb3J9IGxvZ2l0c1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbaW5kZXg9LTFdXG4gICAgICogQHJldHVybnMge0FycmF5fSBBbiBhcnJheSB3aXRoIGEgc2luZ2xlIHR1cGxlLCBjb250YWluaW5nIHRoZSBpbmRleCBvZiB0aGUgbWF4aW11bSB2YWx1ZSBhbmQgYSBtZWFuaW5nbGVzcyBzY29yZSAoc2luY2UgdGhpcyBpcyBhIGdyZWVkeSBzZWFyY2gpLlxuICAgICAqL1xuICAgIHNhbXBsZShsb2dpdHMsIGluZGV4ID0gLTEpIHtcbiAgICAgICAgLy8gTk9URTogbm8gbmVlZCB0byBkbyBsb2dfc29mdG1heCBoZXJlIHNpbmNlIHdlIG9ubHkgdGFrZSB0aGUgbWF4aW11bVxuICAgICAgICBsZXQgbG9ncyA9IHRoaXMuZ2V0TG9naXRzKGxvZ2l0cywgaW5kZXgpO1xuICAgICAgICBsZXQgYXJnbWF4ID0gbWF4KGxvZ3MpWzFdO1xuXG4gICAgICAgIC8vIE5vdGU6IHNjb3JlIGlzIG1lYW5pbmdsZXNzIGluIHRoaXMgY29udGV4dCwgc2luY2Ugd2UgYXJlIHBlcmZvcm1pbmdcbiAgICAgICAgLy8gZ3JlZWR5IHNlYXJjaCAocCA9IDEgPT4gbG9nKHApID0gMClcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIFthcmdtYXgsIDBdXG4gICAgICAgIF07XG4gICAgfVxufVxuXG4vKipcbiAqIENsYXNzIHJlcHJlc2VudGluZyBhIE11bHRpbm9taWFsU2FtcGxlci5cbiAqIEBleHRlbmRzIFNhbXBsZXJcbiAqL1xuY2xhc3MgTXVsdGlub21pYWxTYW1wbGVyIGV4dGVuZHMgU2FtcGxlciB7XG5cbiAgICAvKipcbiAgICAgKiBTYW1wbGUgZnJvbSB0aGUgbG9naXRzLlxuICAgICAqIEBwYXJhbSB7VGVuc29yfSBsb2dpdHNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9XG4gICAgICovXG4gICAgc2FtcGxlKGxvZ2l0cywgaW5kZXggPSAtMSkge1xuICAgICAgICBsZXQgayA9IGxvZ2l0cy5kaW1zLmF0KC0xKTsgLy8gZGVmYXVsdHMgdG8gdm9jYWIgc2l6ZVxuICAgICAgICBpZiAodGhpcy5nZW5lcmF0aW9uX2NvbmZpZy50b3BfayA+IDApIHtcbiAgICAgICAgICAgIGsgPSBNYXRoLm1pbih0aGlzLmdlbmVyYXRpb25fY29uZmlnLnRvcF9rLCBrKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEdldCBsb2dpdHMgb2YgbnRoIHRva2VuXG4gICAgICAgIGNvbnN0IGxvZ3MgPSB0aGlzLmdldExvZ2l0cyhsb2dpdHMsIGluZGV4KTtcblxuICAgICAgICAvLyBHZXQgdG9wIGsgdG9rZW5zXG4gICAgICAgIGNvbnN0IHRvcExvZ2l0cyA9IGdldFRvcEl0ZW1zKGxvZ3MsIGspO1xuXG4gICAgICAgIC8vIENvbXB1dGUgc29mdG1heCBvdmVyIGxvZ2l0c1xuICAgICAgICBjb25zdCBwcm9iYWJpbGl0aWVzID0gc29mdG1heCh0b3BMb2dpdHMubWFwKHggPT4geFsxXSkpO1xuXG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKHsgbGVuZ3RoOiB0aGlzLmdlbmVyYXRpb25fY29uZmlnLm51bV9iZWFtcyB9LCAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBzYW1wbGVkSW5kZXggPSB0aGlzLnJhbmRvbVNlbGVjdChwcm9iYWJpbGl0aWVzKTtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgdG9wTG9naXRzW3NhbXBsZWRJbmRleF1bMF0sIC8vIHRva2VuIGlkXG4gICAgICAgICAgICAgICAgTWF0aC5sb2cocHJvYmFiaWxpdGllc1tzYW1wbGVkSW5kZXhdKSwgLy8gc2NvcmVcbiAgICAgICAgICAgIF07XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuXG4vKipcbiAqIENsYXNzIHJlcHJlc2VudGluZyBhIEJlYW1TZWFyY2hTYW1wbGVyLlxuICogQGV4dGVuZHMgU2FtcGxlclxuICovXG5jbGFzcyBCZWFtU2VhcmNoU2FtcGxlciBleHRlbmRzIFNhbXBsZXIge1xuXG4gICAgLyoqXG4gICAgICogU2FtcGxlIGZyb20gdGhlIGxvZ2l0cy5cbiAgICAgKiBAcGFyYW0ge1RlbnNvcn0gbG9naXRzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gICAgICogQHJldHVybnMge0FycmF5fVxuICAgICAqL1xuICAgIHNhbXBsZShsb2dpdHMsIGluZGV4ID0gLTEpIHtcbiAgICAgICAgbGV0IGsgPSBsb2dpdHMuZGltcy5hdCgtMSk7IC8vIGRlZmF1bHRzIHRvIHZvY2FiIHNpemVcbiAgICAgICAgaWYgKHRoaXMuZ2VuZXJhdGlvbl9jb25maWcudG9wX2sgPiAwKSB7XG4gICAgICAgICAgICBrID0gTWF0aC5taW4odGhpcy5nZW5lcmF0aW9uX2NvbmZpZy50b3Bfaywgayk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBHZXQgbG9naXRzIG9mIG50aCB0b2tlblxuICAgICAgICBjb25zdCBsb2dzID0gdGhpcy5nZXRMb2dpdHMobG9naXRzLCBpbmRleCk7XG5cbiAgICAgICAgLy8gR2V0IHRvcCBrIHRva2Vuc1xuICAgICAgICBjb25zdCB0b3BMb2dpdHMgPSBnZXRUb3BJdGVtcyhsb2dzLCBrKTtcblxuICAgICAgICAvLyBDb21wdXRlIHNvZnRtYXggb3ZlciBsb2dpdHNcbiAgICAgICAgY29uc3QgcHJvYmFiaWxpdGllcyA9IHNvZnRtYXgodG9wTG9naXRzLm1hcCh4ID0+IHhbMV0pKTtcblxuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbSh7IGxlbmd0aDogdGhpcy5nZW5lcmF0aW9uX2NvbmZpZy5udW1fYmVhbXMgfSwgKF8sIGkpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgdG9wTG9naXRzW2ldWzBdLCAvLyB0b2tlbiBpZFxuICAgICAgICAgICAgICAgIE1hdGgubG9nKHByb2JhYmlsaXRpZXNbaV0pLCAvLyBzY29yZVxuICAgICAgICAgICAgXTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@xenova/transformers/src/utils/generation.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@xenova/transformers/src/utils/hub.js":
/*!************************************************************!*\
  !*** ./node_modules/@xenova/transformers/src/utils/hub.js ***!
  \************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getFile: function() { return /* binding */ getFile; },\n/* harmony export */   getModelFile: function() { return /* binding */ getModelFile; },\n/* harmony export */   getModelJSON: function() { return /* binding */ getModelJSON; }\n/* harmony export */ });\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fs */ \"?8373\");\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! path */ \"?441f\");\n/* harmony import */ var stream_web__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! stream/web */ \"?3951\");\n/* harmony import */ var _env_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../env.js */ \"(app-pages-browser)/./node_modules/@xenova/transformers/src/env.js\");\n/* harmony import */ var _core_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./core.js */ \"(app-pages-browser)/./node_modules/@xenova/transformers/src/utils/core.js\");\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"(app-pages-browser)/./node_modules/buffer/index.js\")[\"Buffer\"];\n\n/**\n * @file Utility functions to interact with the Hugging Face Hub (https://huggingface.co/models)\n * \n * @module utils/hub\n */\n\n\n\n\n\n\n\n\nif (!globalThis.ReadableStream) {\n    // @ts-ignore\n    globalThis.ReadableStream = stream_web__WEBPACK_IMPORTED_MODULE_2__.ReadableStream; // ReadableStream is not a global with Node 16\n}\n\n/**\n * @typedef {Object} PretrainedOptions Options for loading a pretrained model.     \n * @property {boolean?} [options.quantized=true] Whether to load the 8-bit quantized version of the model (only applicable when loading model files).\n * @property {function} [options.progress_callback=null] If specified, this function will be called during model construction, to provide the user with progress updates.\n * @property {Object} [options.config=null] Configuration for the model to use instead of an automatically loaded configuration. Configuration can be automatically loaded when:\n * - The model is a model provided by the library (loaded with the *model id* string of a pretrained model).\n * - The model is loaded by supplying a local directory as `pretrained_model_name_or_path` and a configuration JSON file named *config.json* is found in the directory.\n * @property {string} [options.cache_dir=null] Path to a directory in which a downloaded pretrained model configuration should be cached if the standard cache should not be used.\n * @property {boolean} [options.local_files_only=false] Whether or not to only look at local files (e.g., not try downloading the model).\n * @property {string} [options.revision='main'] The specific model version to use. It can be a branch name, a tag name, or a commit id,\n * since we use a git-based system for storing models and other artifacts on huggingface.co, so `revision` can be any identifier allowed by git.\n * NOTE: This setting is ignored for local requests.\n */\n\nclass FileResponse {\n    /**\n     * Mapping from file extensions to MIME types.\n     */\n    _CONTENT_TYPE_MAP = {\n        'txt': 'text/plain',\n        'html': 'text/html',\n        'css': 'text/css',\n        'js': 'text/javascript',\n        'json': 'application/json',\n        'png': 'image/png',\n        'jpg': 'image/jpeg',\n        'jpeg': 'image/jpeg',\n        'gif': 'image/gif',\n    }\n    /**\n     * Creates a new `FileResponse` object.\n     * @param {string|URL} filePath\n     */\n    constructor(filePath) {\n        this.filePath = filePath;\n        this.headers = new Headers();\n\n        this.exists = fs__WEBPACK_IMPORTED_MODULE_0__.existsSync(filePath);\n        if (this.exists) {\n            this.status = 200;\n            this.statusText = 'OK';\n\n            let stats = fs__WEBPACK_IMPORTED_MODULE_0__.statSync(filePath);\n            this.headers.set('content-length', stats.size.toString());\n\n            this.updateContentType();\n\n            let self = this;\n            this.body = new ReadableStream({\n                start(controller) {\n                    self.arrayBuffer().then(buffer => {\n                        controller.enqueue(new Uint8Array(buffer));\n                        controller.close();\n                    })\n                }\n            });\n        } else {\n            this.status = 404;\n            this.statusText = 'Not Found';\n            this.body = null;\n        }\n    }\n\n    /**\n     * Updates the 'content-type' header property of the response based on the extension of\n     * the file specified by the filePath property of the current object.\n     * @returns {void}\n     */\n    updateContentType() {\n        // Set content-type header based on file extension\n        const extension = this.filePath.toString().split('.').pop().toLowerCase();\n        this.headers.set('content-type', this._CONTENT_TYPE_MAP[extension] ?? 'application/octet-stream');\n    }\n\n    /**\n     * Clone the current FileResponse object.\n     * @returns {FileResponse} A new FileResponse object with the same properties as the current object.\n     */\n    clone() {\n        let response = new FileResponse(this.filePath);\n        response.exists = this.exists;\n        response.status = this.status;\n        response.statusText = this.statusText;\n        response.headers = new Headers(this.headers);\n        return response;\n    }\n\n    /**\n     * Reads the contents of the file specified by the filePath property and returns a Promise that\n     * resolves with an ArrayBuffer containing the file's contents.\n     * @returns {Promise<ArrayBuffer>} A Promise that resolves with an ArrayBuffer containing the file's contents.\n     * @throws {Error} If the file cannot be read.\n     */\n    async arrayBuffer() {\n        const data = await fs__WEBPACK_IMPORTED_MODULE_0__.promises.readFile(this.filePath);\n        return data.buffer;\n    }\n\n    /**\n     * Reads the contents of the file specified by the filePath property and returns a Promise that\n     * resolves with a Blob containing the file's contents.\n     * @returns {Promise<Blob>} A Promise that resolves with a Blob containing the file's contents.\n     * @throws {Error} If the file cannot be read.\n     */\n    async blob() {\n        const data = await fs__WEBPACK_IMPORTED_MODULE_0__.promises.readFile(this.filePath);\n        return new Blob([data], { type: this.headers.get('content-type') });\n    }\n\n    /**\n     * Reads the contents of the file specified by the filePath property and returns a Promise that\n     * resolves with a string containing the file's contents.\n     * @returns {Promise<string>} A Promise that resolves with a string containing the file's contents.\n     * @throws {Error} If the file cannot be read.\n     */\n    async text() {\n        const data = await fs__WEBPACK_IMPORTED_MODULE_0__.promises.readFile(this.filePath, 'utf8');\n        return data;\n    }\n\n    /**\n     * Reads the contents of the file specified by the filePath property and returns a Promise that\n     * resolves with a parsed JavaScript object containing the file's contents.\n     * \n     * @returns {Promise<Object>} A Promise that resolves with a parsed JavaScript object containing the file's contents.\n     * @throws {Error} If the file cannot be read.\n     */\n    async json() {\n        return JSON.parse(await this.text());\n    }\n}\n\n/**\n * Determines whether the given string is a valid HTTP or HTTPS URL.\n * @param {string|URL} string The string to test for validity as an HTTP or HTTPS URL.\n * @param {string[]} [validHosts=null] A list of valid hostnames. If specified, the URL's hostname must be in this list.\n * @returns {boolean} True if the string is a valid HTTP or HTTPS URL, false otherwise.\n */\nfunction isValidHttpUrl(string, validHosts = null) {\n    // https://stackoverflow.com/a/43467144\n    let url;\n    try {\n        url = new URL(string);\n    } catch (_) {\n        return false;\n    }\n    if (validHosts && !validHosts.includes(url.hostname)) {\n        return false;\n    }\n    return url.protocol === \"http:\" || url.protocol === \"https:\";\n}\n\n/**\n * Helper function to get a file, using either the Fetch API or FileSystem API.\n *\n * @param {URL|string} urlOrPath The URL/path of the file to get.\n * @returns {Promise<FileResponse|Response>} A promise that resolves to a FileResponse object (if the file is retrieved using the FileSystem API), or a Response object (if the file is retrieved using the Fetch API).\n */\nasync function getFile(urlOrPath) {\n\n    if (_env_js__WEBPACK_IMPORTED_MODULE_3__.env.useFS && !isValidHttpUrl(urlOrPath)) {\n        return new FileResponse(urlOrPath);\n\n    } else if (typeof process !== 'undefined' && process?.release?.name === 'node') {\n        const IS_CI = !!process.env?.TESTING_REMOTELY;\n        const version = _env_js__WEBPACK_IMPORTED_MODULE_3__.env.version;\n\n        const headers = new Headers();\n        headers.set('User-Agent', `transformers.js/${version}; is_ci/${IS_CI};`);\n\n        // Check whether we are making a request to the Hugging Face Hub.\n        const isHFURL = isValidHttpUrl(urlOrPath, ['huggingface.co', 'hf.co']);\n        if (isHFURL) {\n            // If an access token is present in the environment variables,\n            // we add it to the request headers.\n            const token = process.env?.HF_ACCESS_TOKEN;\n            if (token) {\n                headers.set('Authorization', `Bearer ${token}`);\n            }\n        }\n        return fetch(urlOrPath, { headers });\n    } else {\n        // Running in a browser-environment, so we use default headers\n        // NOTE: We do not allow passing authorization headers in the browser,\n        // since this would require exposing the token to the client.\n        return fetch(urlOrPath);\n    }\n}\n\nconst ERROR_MAPPING = {\n    // 4xx errors (https://developer.mozilla.org/en-US/docs/Web/HTTP/Status#client_error_responses)\n    400: 'Bad request error occurred while trying to load file',\n    401: 'Unauthorized access to file',\n    403: 'Forbidden access to file',\n    404: 'Could not locate file',\n    408: 'Request timeout error occurred while trying to load file',\n\n    // 5xx errors (https://developer.mozilla.org/en-US/docs/Web/HTTP/Status#server_error_responses)\n    500: 'Internal server error error occurred while trying to load file',\n    502: 'Bad gateway error occurred while trying to load file',\n    503: 'Service unavailable error occurred while trying to load file',\n    504: 'Gateway timeout error occurred while trying to load file',\n}\n/**\n * Helper method to handle fatal errors that occur while trying to load a file from the Hugging Face Hub.\n * @param {number} status The HTTP status code of the error.\n * @param {string} remoteURL The URL of the file that could not be loaded.\n * @param {boolean} fatal Whether to raise an error if the file could not be loaded.\n * @returns {null} Returns `null` if `fatal = true`.\n * @throws {Error} If `fatal = false`.\n */\nfunction handleError(status, remoteURL, fatal) {\n    if (!fatal) {\n        // File was not loaded correctly, but it is optional.\n        // TODO in future, cache the response?\n        return null;\n    }\n\n    const message = ERROR_MAPPING[status] ?? `Error (${status}) occurred while trying to load file`;\n    throw Error(`${message}: \"${remoteURL}\".`);\n}\n\nclass FileCache {\n    /**\n     * Instantiate a `FileCache` object.\n     * @param {string} path \n     */\n    constructor(path) {\n        this.path = path;\n    }\n\n    /**\n     * Checks whether the given request is in the cache.\n     * @param {string} request \n     * @returns {Promise<FileResponse | undefined>}\n     */\n    async match(request) {\n\n        let filePath = path__WEBPACK_IMPORTED_MODULE_1__.join(this.path, request);\n        let file = new FileResponse(filePath);\n\n        if (file.exists) {\n            return file;\n        } else {\n            return undefined;\n        }\n    }\n\n    /**\n     * Adds the given response to the cache.\n     * @param {string} request \n     * @param {Response|FileResponse} response \n     * @returns {Promise<void>}\n     */\n    async put(request, response) {\n        const buffer = Buffer.from(await response.arrayBuffer());\n\n        let outputPath = path__WEBPACK_IMPORTED_MODULE_1__.join(this.path, request);\n\n        try {\n            await fs__WEBPACK_IMPORTED_MODULE_0__.promises.mkdir(path__WEBPACK_IMPORTED_MODULE_1__.dirname(outputPath), { recursive: true });\n            await fs__WEBPACK_IMPORTED_MODULE_0__.promises.writeFile(outputPath, buffer);\n\n        } catch (err) {\n            console.warn('An error occurred while writing the file to cache:', err)\n        }\n    }\n\n    // TODO add the rest?\n    // addAll(requests: RequestInfo[]): Promise<void>;\n    // delete(request: RequestInfo | URL, options?: CacheQueryOptions): Promise<boolean>;\n    // keys(request?: RequestInfo | URL, options?: CacheQueryOptions): Promise<ReadonlyArray<Request>>;\n    // match(request: RequestInfo | URL, options?: CacheQueryOptions): Promise<Response | undefined>;\n    // matchAll(request?: RequestInfo | URL, options?: CacheQueryOptions): Promise<ReadonlyArray<Response>>;\n}\n\n/**\n * \n * @param {FileCache|Cache} cache The cache to search\n * @param {string[]} names The names of the item to search for\n * @returns {Promise<FileResponse|Response|undefined>} The item from the cache, or undefined if not found.\n */\nasync function tryCache(cache, ...names) {\n    for (let name of names) {\n        try {\n            let result = await cache.match(name);\n            if (result) return result;\n        } catch (e) {\n            continue;\n        }\n    }\n    return undefined;\n}\n\n/**\n * \n * Retrieves a file from either a remote URL using the Fetch API or from the local file system using the FileSystem API.\n * If the filesystem is available and `env.useCache = true`, the file will be downloaded and cached.\n * \n * @param {string} path_or_repo_id This can be either:\n * - a string, the *model id* of a model repo on huggingface.co.\n * - a path to a *directory* potentially containing the file.\n * @param {string} filename The name of the file to locate in `path_or_repo`.\n * @param {boolean} [fatal=true] Whether to throw an error if the file is not found.\n * @param {PretrainedOptions} [options] An object containing optional parameters.\n * \n * @throws Will throw an error if the file is not found and `fatal` is true.\n * @returns {Promise} A Promise that resolves with the file content as a buffer.\n */\nasync function getModelFile(path_or_repo_id, filename, fatal = true, options = {}) {\n\n    if (!_env_js__WEBPACK_IMPORTED_MODULE_3__.env.allowLocalModels) {\n        // User has disabled local models, so we just make sure other settings are correct.\n\n        if (options.local_files_only) {\n            throw Error(\"Invalid configuration detected: local models are disabled (`env.allowLocalModels=false`) but you have requested to only use local models (`local_files_only=true`).\")\n        } else if (!_env_js__WEBPACK_IMPORTED_MODULE_3__.env.allowRemoteModels) {\n            throw Error(\"Invalid configuration detected: both local and remote models are disabled. Fix by setting `env.allowLocalModels` or `env.allowRemoteModels` to `true`.\")\n        }\n    }\n\n    // Initiate file retrieval\n    (0,_core_js__WEBPACK_IMPORTED_MODULE_4__.dispatchCallback)(options.progress_callback, {\n        status: 'initiate',\n        name: path_or_repo_id,\n        file: filename\n    })\n\n    // First, check if the a caching backend is available\n    // If no caching mechanism available, will download the file every time\n    let cache;\n    if (!cache && _env_js__WEBPACK_IMPORTED_MODULE_3__.env.useBrowserCache) {\n        if (typeof caches === 'undefined') {\n            throw Error('Browser cache is not available in this environment.')\n        }\n        try {\n            // In some cases, the browser cache may be visible, but not accessible due to security restrictions.\n            // For example, when running an application in an iframe, if a user attempts to load the page in\n            // incognito mode, the following error is thrown: `DOMException: Failed to execute 'open' on 'CacheStorage':\n            // An attempt was made to break through the security policy of the user agent.`\n            // So, instead of crashing, we just ignore the error and continue without using the cache.\n            cache = await caches.open('transformers-cache');\n        } catch (e) {\n            console.warn('An error occurred while opening the browser cache:', e);\n        }\n    }\n\n    if (!cache && _env_js__WEBPACK_IMPORTED_MODULE_3__.env.useFSCache) {\n        // TODO throw error if not available\n\n        // If `cache_dir` is not specified, use the default cache directory\n        cache = new FileCache(options.cache_dir ?? _env_js__WEBPACK_IMPORTED_MODULE_3__.env.cacheDir);\n    }\n\n    const revision = options.revision ?? 'main';\n\n    let requestURL = pathJoin(path_or_repo_id, filename);\n    let localPath = pathJoin(_env_js__WEBPACK_IMPORTED_MODULE_3__.env.localModelPath, requestURL);\n\n    let remoteURL = pathJoin(\n        _env_js__WEBPACK_IMPORTED_MODULE_3__.env.remoteHost,\n        _env_js__WEBPACK_IMPORTED_MODULE_3__.env.remotePathTemplate\n            .replaceAll('{model}', path_or_repo_id)\n            .replaceAll('{revision}', revision),\n        filename\n    );\n\n    // Choose cache key for filesystem cache\n    // When using the main revision (default), we use the request URL as the cache key.\n    // If a specific revision is requested, we account for this in the cache key.\n    let fsCacheKey = revision === 'main' ? requestURL : pathJoin(path_or_repo_id, revision, filename);\n\n    /** @type {string} */\n    let cacheKey;\n    let proposedCacheKey = cache instanceof FileCache ? fsCacheKey : remoteURL;\n\n    /** @type {Response|undefined} */\n    let responseToCache;\n\n    /** @type {Response|FileResponse|undefined} */\n    let response;\n\n    if (cache) {\n        // A caching system is available, so we try to get the file from it.\n        //  1. We first try to get from cache using the local path. In some environments (like deno),\n        //     non-URL cache keys are not allowed. In these cases, `response` will be undefined.\n        //  2. If no response is found, we try to get from cache using the remote URL or file system cache.\n        response = await tryCache(cache, localPath, proposedCacheKey);\n    }\n\n    if (response === undefined) {\n        // Caching not available, or file is not cached, so we perform the request\n\n        if (_env_js__WEBPACK_IMPORTED_MODULE_3__.env.allowLocalModels) {\n            // Accessing local models is enabled, so we try to get the file locally.\n            // If request is a valid HTTP URL, we skip the local file check. Otherwise, we try to get the file locally.\n            const isURL = isValidHttpUrl(requestURL);\n            if (!isURL) {\n                try {\n                    response = await getFile(localPath);\n                    cacheKey = localPath; // Update the cache key to be the local path\n                } catch (e) {\n                    // Something went wrong while trying to get the file locally.\n                    // NOTE: error handling is done in the next step (since `response` will be undefined)\n                    console.warn(`Unable to load from local path \"${localPath}\": \"${e}\"`);\n                }\n            } else if (options.local_files_only) {\n                throw new Error(`\\`local_files_only=true\\`, but attempted to load a remote file from: ${requestURL}.`);\n            } else if (!_env_js__WEBPACK_IMPORTED_MODULE_3__.env.allowRemoteModels) {\n                throw new Error(`\\`env.allowRemoteModels=false\\`, but attempted to load a remote file from: ${requestURL}.`);\n            }\n        }\n\n        if (response === undefined || response.status === 404) {\n            // File not found locally. This means either:\n            // - The user has disabled local file access (`env.allowLocalModels=false`)\n            // - the path is a valid HTTP url (`response === undefined`)\n            // - the path is not a valid HTTP url and the file is not present on the file system or local server (`response.status === 404`)\n\n            if (options.local_files_only || !_env_js__WEBPACK_IMPORTED_MODULE_3__.env.allowRemoteModels) {\n                // User requested local files only, but the file is not found locally.\n                if (fatal) {\n                    throw Error(`\\`local_files_only=true\\` or \\`env.allowRemoteModels=false\\` and file was not found locally at \"${localPath}\".`);\n                } else {\n                    // File not found, but this file is optional.\n                    // TODO in future, cache the response?\n                    return null;\n                }\n            }\n\n            // File not found locally, so we try to download it from the remote server\n            response = await getFile(remoteURL);\n\n            if (response.status !== 200) {\n                return handleError(response.status, remoteURL, fatal);\n            }\n\n            // Success! We use the proposed cache key from earlier\n            cacheKey = proposedCacheKey;\n        }\n\n\n        if (cache && response instanceof Response && response.status === 200) {\n            // only clone if cache available, and response is valid\n            responseToCache = response.clone();\n        }\n    }\n\n\n    // Start downloading\n    (0,_core_js__WEBPACK_IMPORTED_MODULE_4__.dispatchCallback)(options.progress_callback, {\n        status: 'download',\n        name: path_or_repo_id,\n        file: filename\n    })\n\n    const buffer = await readResponse(response, data => {\n        ;(0,_core_js__WEBPACK_IMPORTED_MODULE_4__.dispatchCallback)(options.progress_callback, {\n            status: 'progress',\n            ...data,\n            name: path_or_repo_id,\n            file: filename\n        })\n    })\n\n\n    if (\n        // Only cache web responses\n        // i.e., do not cache FileResponses (prevents duplication)\n        responseToCache && cacheKey\n        &&\n        // Check again whether request is in cache. If not, we add the response to the cache\n        (await cache.match(cacheKey) === undefined)\n    ) {\n        await cache.put(cacheKey, responseToCache)\n            .catch(err => {\n                // Do not crash if unable to add to cache (e.g., QuotaExceededError).\n                // Rather, log a warning and proceed with execution.\n                console.warn(`Unable to add response to browser cache: ${err}.`);\n            });\n\n    }\n\n    (0,_core_js__WEBPACK_IMPORTED_MODULE_4__.dispatchCallback)(options.progress_callback, {\n        status: 'done',\n        name: path_or_repo_id,\n        file: filename\n    });\n\n    return buffer;\n}\n\n/**\n * Fetches a JSON file from a given path and file name.\n *\n * @param {string} modelPath The path to the directory containing the file.\n * @param {string} fileName The name of the file to fetch.\n * @param {boolean} [fatal=true] Whether to throw an error if the file is not found.\n * @param {PretrainedOptions} [options] An object containing optional parameters.\n * @returns {Promise<Object>} The JSON data parsed into a JavaScript object.\n * @throws Will throw an error if the file is not found and `fatal` is true.\n */\nasync function getModelJSON(modelPath, fileName, fatal = true, options = {}) {\n    let buffer = await getModelFile(modelPath, fileName, fatal, options);\n    if (buffer === null) {\n        // Return empty object\n        return {}\n    }\n\n    let decoder = new TextDecoder('utf-8');\n    let jsonData = decoder.decode(buffer);\n\n    return JSON.parse(jsonData);\n}\n\n/**\n * Read and track progress when reading a Response object\n *\n * @param {any} response The Response object to read\n * @param {function} progress_callback The function to call with progress updates\n * @returns {Promise<Uint8Array>} A Promise that resolves with the Uint8Array buffer\n */\nasync function readResponse(response, progress_callback) {\n    // Read and track progress when reading a Response object\n\n    const contentLength = response.headers.get('Content-Length');\n    if (contentLength === null) {\n        console.warn('Unable to determine content-length from response headers. Will expand buffer when needed.')\n    }\n    let total = parseInt(contentLength ?? '0');\n    let buffer = new Uint8Array(total);\n    let loaded = 0;\n\n    const reader = response.body.getReader();\n    async function read() {\n        const { done, value } = await reader.read();\n        if (done) return;\n\n        let newLoaded = loaded + value.length;\n        if (newLoaded > total) {\n            total = newLoaded;\n\n            // Adding the new data will overflow buffer.\n            // In this case, we extend the buffer\n            let newBuffer = new Uint8Array(total);\n\n            // copy contents\n            newBuffer.set(buffer);\n\n            buffer = newBuffer;\n        }\n        buffer.set(value, loaded)\n        loaded = newLoaded;\n\n        const progress = (loaded / total) * 100;\n\n        // Call your function here\n        progress_callback({\n            progress: progress,\n            loaded: loaded,\n            total: total,\n        })\n\n        return read();\n    }\n\n    // Actually read\n    await read();\n\n    return buffer;\n}\n\n/**\n * Joins multiple parts of a path into a single path, while handling leading and trailing slashes.\n *\n * @param {...string} parts Multiple parts of a path.\n * @returns {string} A string representing the joined path.\n */\nfunction pathJoin(...parts) {\n    // https://stackoverflow.com/a/55142565\n    parts = parts.map((part, index) => {\n        if (index) {\n            part = part.replace(new RegExp('^/'), '');\n        }\n        if (index !== parts.length - 1) {\n            part = part.replace(new RegExp('/$'), '');\n        }\n        return part;\n    })\n    return parts.join('/');\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AeGVub3ZhL3RyYW5zZm9ybWVycy9zcmMvdXRpbHMvaHViLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFb0I7QUFDSTtBQUNROztBQUVBO0FBQ2E7O0FBRTdDO0FBQ0E7QUFDQSxnQ0FBZ0Msc0RBQXFCLEVBQUU7QUFDdkQ7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckIsY0FBYyxVQUFVO0FBQ3hCLGNBQWMsVUFBVTtBQUN4QixjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixjQUFjLFNBQVM7QUFDdkIsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNCQUFzQiwwQ0FBYTtBQUNuQztBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCLHdDQUFXO0FBQ25DOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGFBQWE7QUFDYixVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsY0FBYztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHNCQUFzQjtBQUN2QyxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0EsMkJBQTJCLHdDQUFXO0FBQ3RDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGVBQWU7QUFDaEMsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBLDJCQUEyQix3Q0FBVztBQUN0QyxrQ0FBa0Msd0NBQXdDO0FBQzFFOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixpQkFBaUI7QUFDbEMsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBLDJCQUEyQix3Q0FBVztBQUN0QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGlCQUFpQjtBQUNsQyxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFlBQVk7QUFDdkIsV0FBVyxVQUFVO0FBQ3JCLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCLGFBQWEsZ0NBQWdDO0FBQzdDO0FBQ087O0FBRVAsUUFBUSx3Q0FBRztBQUNYOztBQUVBLE1BQU0sZ0JBQWdCLE9BQU8sb0JBQW9CLE9BQU87QUFDeEQsd0JBQXdCLE9BQU87QUFDL0Isd0JBQXdCLHdDQUFHOztBQUUzQjtBQUNBLHFEQUFxRCxVQUFVLFFBQVEsT0FBTzs7QUFFOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixPQUFPO0FBQ2pDO0FBQ0EsdURBQXVELE1BQU07QUFDN0Q7QUFDQTtBQUNBLGtDQUFrQyxTQUFTO0FBQzNDLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCLGFBQWEsTUFBTTtBQUNuQixZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdURBQXVELE9BQU87QUFDOUQsbUJBQW1CLFFBQVEsS0FBSyxVQUFVO0FBQzFDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBOztBQUVBLHVCQUF1QixzQ0FBUztBQUNoQzs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsdUJBQXVCO0FBQ3RDLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsdUJBQXVCLE1BQU07O0FBRTdCLHlCQUF5QixzQ0FBUzs7QUFFbEM7QUFDQSxrQkFBa0Isd0NBQVcsT0FBTyx5Q0FBWSxnQkFBZ0IsaUJBQWlCO0FBQ2pGLGtCQUFrQix3Q0FBVzs7QUFFN0IsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxpQkFBaUI7QUFDNUIsV0FBVyxVQUFVO0FBQ3JCLGFBQWEsMENBQTBDO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxtQkFBbUI7QUFDOUI7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNPLGlGQUFpRjs7QUFFeEYsU0FBUyx3Q0FBRztBQUNaOztBQUVBO0FBQ0E7QUFDQSxVQUFVLFVBQVUsd0NBQUc7QUFDdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSSwwREFBZ0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isd0NBQUc7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBLGtCQUFrQix3Q0FBRztBQUNyQjs7QUFFQTtBQUNBLG1EQUFtRCx3Q0FBRztBQUN0RDs7QUFFQTs7QUFFQTtBQUNBLDZCQUE2Qix3Q0FBRzs7QUFFaEM7QUFDQSxRQUFRLHdDQUFHO0FBQ1gsUUFBUSx3Q0FBRztBQUNYLDBCQUEwQixNQUFNO0FBQ2hDLDBCQUEwQixTQUFTO0FBQ25DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7O0FBRUEsZUFBZSxvQkFBb0I7QUFDbkM7O0FBRUEsZUFBZSxpQ0FBaUM7QUFDaEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxZQUFZLHdDQUFHO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0Esb0VBQW9FLFVBQVUsTUFBTSxFQUFFO0FBQ3RGO0FBQ0EsY0FBYztBQUNkLHdHQUF3RyxXQUFXO0FBQ25ILGNBQWMsVUFBVSx3Q0FBRztBQUMzQiw4R0FBOEcsV0FBVztBQUN6SDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNkNBQTZDLHdDQUFHO0FBQ2hEO0FBQ0E7QUFDQSxtSUFBbUksVUFBVTtBQUM3SSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0EsSUFBSSwwREFBZ0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLFFBQVEsMkRBQWdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7OztBQUdMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RSxJQUFJO0FBQzdFLGFBQWE7O0FBRWI7O0FBRUEsSUFBSSwwREFBZ0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsbUJBQW1CO0FBQzlCLGFBQWEsaUJBQWlCO0FBQzlCO0FBQ0E7QUFDTywyRUFBMkU7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsVUFBVTtBQUNyQixhQUFhLHFCQUFxQjtBQUNsQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQixjQUFjO0FBQzlCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFdBQVc7QUFDdEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHhlbm92YS90cmFuc2Zvcm1lcnMvc3JjL3V0aWxzL2h1Yi5qcz82OTY1Il0sInNvdXJjZXNDb250ZW50IjpbIlxuLyoqXG4gKiBAZmlsZSBVdGlsaXR5IGZ1bmN0aW9ucyB0byBpbnRlcmFjdCB3aXRoIHRoZSBIdWdnaW5nIEZhY2UgSHViIChodHRwczovL2h1Z2dpbmdmYWNlLmNvL21vZGVscylcbiAqIFxuICogQG1vZHVsZSB1dGlscy9odWJcbiAqL1xuXG5pbXBvcnQgZnMgZnJvbSAnZnMnO1xuaW1wb3J0IHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgc3RyZWFtIGZyb20gJ3N0cmVhbS93ZWInO1xuXG5pbXBvcnQgeyBlbnYgfSBmcm9tICcuLi9lbnYuanMnO1xuaW1wb3J0IHsgZGlzcGF0Y2hDYWxsYmFjayB9IGZyb20gJy4vY29yZS5qcyc7XG5cbmlmICghZ2xvYmFsVGhpcy5SZWFkYWJsZVN0cmVhbSkge1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBnbG9iYWxUaGlzLlJlYWRhYmxlU3RyZWFtID0gc3RyZWFtLlJlYWRhYmxlU3RyZWFtOyAvLyBSZWFkYWJsZVN0cmVhbSBpcyBub3QgYSBnbG9iYWwgd2l0aCBOb2RlIDE2XG59XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gUHJldHJhaW5lZE9wdGlvbnMgT3B0aW9ucyBmb3IgbG9hZGluZyBhIHByZXRyYWluZWQgbW9kZWwuICAgICBcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbj99IFtvcHRpb25zLnF1YW50aXplZD10cnVlXSBXaGV0aGVyIHRvIGxvYWQgdGhlIDgtYml0IHF1YW50aXplZCB2ZXJzaW9uIG9mIHRoZSBtb2RlbCAob25seSBhcHBsaWNhYmxlIHdoZW4gbG9hZGluZyBtb2RlbCBmaWxlcykuXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9ufSBbb3B0aW9ucy5wcm9ncmVzc19jYWxsYmFjaz1udWxsXSBJZiBzcGVjaWZpZWQsIHRoaXMgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgZHVyaW5nIG1vZGVsIGNvbnN0cnVjdGlvbiwgdG8gcHJvdmlkZSB0aGUgdXNlciB3aXRoIHByb2dyZXNzIHVwZGF0ZXMuXG4gKiBAcHJvcGVydHkge09iamVjdH0gW29wdGlvbnMuY29uZmlnPW51bGxdIENvbmZpZ3VyYXRpb24gZm9yIHRoZSBtb2RlbCB0byB1c2UgaW5zdGVhZCBvZiBhbiBhdXRvbWF0aWNhbGx5IGxvYWRlZCBjb25maWd1cmF0aW9uLiBDb25maWd1cmF0aW9uIGNhbiBiZSBhdXRvbWF0aWNhbGx5IGxvYWRlZCB3aGVuOlxuICogLSBUaGUgbW9kZWwgaXMgYSBtb2RlbCBwcm92aWRlZCBieSB0aGUgbGlicmFyeSAobG9hZGVkIHdpdGggdGhlICptb2RlbCBpZCogc3RyaW5nIG9mIGEgcHJldHJhaW5lZCBtb2RlbCkuXG4gKiAtIFRoZSBtb2RlbCBpcyBsb2FkZWQgYnkgc3VwcGx5aW5nIGEgbG9jYWwgZGlyZWN0b3J5IGFzIGBwcmV0cmFpbmVkX21vZGVsX25hbWVfb3JfcGF0aGAgYW5kIGEgY29uZmlndXJhdGlvbiBKU09OIGZpbGUgbmFtZWQgKmNvbmZpZy5qc29uKiBpcyBmb3VuZCBpbiB0aGUgZGlyZWN0b3J5LlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtvcHRpb25zLmNhY2hlX2Rpcj1udWxsXSBQYXRoIHRvIGEgZGlyZWN0b3J5IGluIHdoaWNoIGEgZG93bmxvYWRlZCBwcmV0cmFpbmVkIG1vZGVsIGNvbmZpZ3VyYXRpb24gc2hvdWxkIGJlIGNhY2hlZCBpZiB0aGUgc3RhbmRhcmQgY2FjaGUgc2hvdWxkIG5vdCBiZSB1c2VkLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbb3B0aW9ucy5sb2NhbF9maWxlc19vbmx5PWZhbHNlXSBXaGV0aGVyIG9yIG5vdCB0byBvbmx5IGxvb2sgYXQgbG9jYWwgZmlsZXMgKGUuZy4sIG5vdCB0cnkgZG93bmxvYWRpbmcgdGhlIG1vZGVsKS5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbb3B0aW9ucy5yZXZpc2lvbj0nbWFpbiddIFRoZSBzcGVjaWZpYyBtb2RlbCB2ZXJzaW9uIHRvIHVzZS4gSXQgY2FuIGJlIGEgYnJhbmNoIG5hbWUsIGEgdGFnIG5hbWUsIG9yIGEgY29tbWl0IGlkLFxuICogc2luY2Ugd2UgdXNlIGEgZ2l0LWJhc2VkIHN5c3RlbSBmb3Igc3RvcmluZyBtb2RlbHMgYW5kIG90aGVyIGFydGlmYWN0cyBvbiBodWdnaW5nZmFjZS5jbywgc28gYHJldmlzaW9uYCBjYW4gYmUgYW55IGlkZW50aWZpZXIgYWxsb3dlZCBieSBnaXQuXG4gKiBOT1RFOiBUaGlzIHNldHRpbmcgaXMgaWdub3JlZCBmb3IgbG9jYWwgcmVxdWVzdHMuXG4gKi9cblxuY2xhc3MgRmlsZVJlc3BvbnNlIHtcbiAgICAvKipcbiAgICAgKiBNYXBwaW5nIGZyb20gZmlsZSBleHRlbnNpb25zIHRvIE1JTUUgdHlwZXMuXG4gICAgICovXG4gICAgX0NPTlRFTlRfVFlQRV9NQVAgPSB7XG4gICAgICAgICd0eHQnOiAndGV4dC9wbGFpbicsXG4gICAgICAgICdodG1sJzogJ3RleHQvaHRtbCcsXG4gICAgICAgICdjc3MnOiAndGV4dC9jc3MnLFxuICAgICAgICAnanMnOiAndGV4dC9qYXZhc2NyaXB0JyxcbiAgICAgICAgJ2pzb24nOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICdwbmcnOiAnaW1hZ2UvcG5nJyxcbiAgICAgICAgJ2pwZyc6ICdpbWFnZS9qcGVnJyxcbiAgICAgICAgJ2pwZWcnOiAnaW1hZ2UvanBlZycsXG4gICAgICAgICdnaWYnOiAnaW1hZ2UvZ2lmJyxcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBgRmlsZVJlc3BvbnNlYCBvYmplY3QuXG4gICAgICogQHBhcmFtIHtzdHJpbmd8VVJMfSBmaWxlUGF0aFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGZpbGVQYXRoKSB7XG4gICAgICAgIHRoaXMuZmlsZVBhdGggPSBmaWxlUGF0aDtcbiAgICAgICAgdGhpcy5oZWFkZXJzID0gbmV3IEhlYWRlcnMoKTtcblxuICAgICAgICB0aGlzLmV4aXN0cyA9IGZzLmV4aXN0c1N5bmMoZmlsZVBhdGgpO1xuICAgICAgICBpZiAodGhpcy5leGlzdHMpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdHVzID0gMjAwO1xuICAgICAgICAgICAgdGhpcy5zdGF0dXNUZXh0ID0gJ09LJztcblxuICAgICAgICAgICAgbGV0IHN0YXRzID0gZnMuc3RhdFN5bmMoZmlsZVBhdGgpO1xuICAgICAgICAgICAgdGhpcy5oZWFkZXJzLnNldCgnY29udGVudC1sZW5ndGgnLCBzdGF0cy5zaXplLnRvU3RyaW5nKCkpO1xuXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUNvbnRlbnRUeXBlKCk7XG5cbiAgICAgICAgICAgIGxldCBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMuYm9keSA9IG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgICAgICAgICAgICAgc3RhcnQoY29udHJvbGxlcikge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmFycmF5QnVmZmVyKCkudGhlbihidWZmZXIgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKG5ldyBVaW50OEFycmF5KGJ1ZmZlcikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5jbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zdGF0dXMgPSA0MDQ7XG4gICAgICAgICAgICB0aGlzLnN0YXR1c1RleHQgPSAnTm90IEZvdW5kJztcbiAgICAgICAgICAgIHRoaXMuYm9keSA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSAnY29udGVudC10eXBlJyBoZWFkZXIgcHJvcGVydHkgb2YgdGhlIHJlc3BvbnNlIGJhc2VkIG9uIHRoZSBleHRlbnNpb24gb2ZcbiAgICAgKiB0aGUgZmlsZSBzcGVjaWZpZWQgYnkgdGhlIGZpbGVQYXRoIHByb3BlcnR5IG9mIHRoZSBjdXJyZW50IG9iamVjdC5cbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICAgKi9cbiAgICB1cGRhdGVDb250ZW50VHlwZSgpIHtcbiAgICAgICAgLy8gU2V0IGNvbnRlbnQtdHlwZSBoZWFkZXIgYmFzZWQgb24gZmlsZSBleHRlbnNpb25cbiAgICAgICAgY29uc3QgZXh0ZW5zaW9uID0gdGhpcy5maWxlUGF0aC50b1N0cmluZygpLnNwbGl0KCcuJykucG9wKCkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgdGhpcy5oZWFkZXJzLnNldCgnY29udGVudC10eXBlJywgdGhpcy5fQ09OVEVOVF9UWVBFX01BUFtleHRlbnNpb25dID8/ICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDbG9uZSB0aGUgY3VycmVudCBGaWxlUmVzcG9uc2Ugb2JqZWN0LlxuICAgICAqIEByZXR1cm5zIHtGaWxlUmVzcG9uc2V9IEEgbmV3IEZpbGVSZXNwb25zZSBvYmplY3Qgd2l0aCB0aGUgc2FtZSBwcm9wZXJ0aWVzIGFzIHRoZSBjdXJyZW50IG9iamVjdC5cbiAgICAgKi9cbiAgICBjbG9uZSgpIHtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gbmV3IEZpbGVSZXNwb25zZSh0aGlzLmZpbGVQYXRoKTtcbiAgICAgICAgcmVzcG9uc2UuZXhpc3RzID0gdGhpcy5leGlzdHM7XG4gICAgICAgIHJlc3BvbnNlLnN0YXR1cyA9IHRoaXMuc3RhdHVzO1xuICAgICAgICByZXNwb25zZS5zdGF0dXNUZXh0ID0gdGhpcy5zdGF0dXNUZXh0O1xuICAgICAgICByZXNwb25zZS5oZWFkZXJzID0gbmV3IEhlYWRlcnModGhpcy5oZWFkZXJzKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlYWRzIHRoZSBjb250ZW50cyBvZiB0aGUgZmlsZSBzcGVjaWZpZWQgYnkgdGhlIGZpbGVQYXRoIHByb3BlcnR5IGFuZCByZXR1cm5zIGEgUHJvbWlzZSB0aGF0XG4gICAgICogcmVzb2x2ZXMgd2l0aCBhbiBBcnJheUJ1ZmZlciBjb250YWluaW5nIHRoZSBmaWxlJ3MgY29udGVudHMuXG4gICAgICogQHJldHVybnMge1Byb21pc2U8QXJyYXlCdWZmZXI+fSBBIFByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIGFuIEFycmF5QnVmZmVyIGNvbnRhaW5pbmcgdGhlIGZpbGUncyBjb250ZW50cy5cbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIGZpbGUgY2Fubm90IGJlIHJlYWQuXG4gICAgICovXG4gICAgYXN5bmMgYXJyYXlCdWZmZXIoKSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBmcy5wcm9taXNlcy5yZWFkRmlsZSh0aGlzLmZpbGVQYXRoKTtcbiAgICAgICAgcmV0dXJuIGRhdGEuYnVmZmVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlYWRzIHRoZSBjb250ZW50cyBvZiB0aGUgZmlsZSBzcGVjaWZpZWQgYnkgdGhlIGZpbGVQYXRoIHByb3BlcnR5IGFuZCByZXR1cm5zIGEgUHJvbWlzZSB0aGF0XG4gICAgICogcmVzb2x2ZXMgd2l0aCBhIEJsb2IgY29udGFpbmluZyB0aGUgZmlsZSdzIGNvbnRlbnRzLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEJsb2I+fSBBIFByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIGEgQmxvYiBjb250YWluaW5nIHRoZSBmaWxlJ3MgY29udGVudHMuXG4gICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBmaWxlIGNhbm5vdCBiZSByZWFkLlxuICAgICAqL1xuICAgIGFzeW5jIGJsb2IoKSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBmcy5wcm9taXNlcy5yZWFkRmlsZSh0aGlzLmZpbGVQYXRoKTtcbiAgICAgICAgcmV0dXJuIG5ldyBCbG9iKFtkYXRhXSwgeyB0eXBlOiB0aGlzLmhlYWRlcnMuZ2V0KCdjb250ZW50LXR5cGUnKSB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWFkcyB0aGUgY29udGVudHMgb2YgdGhlIGZpbGUgc3BlY2lmaWVkIGJ5IHRoZSBmaWxlUGF0aCBwcm9wZXJ0eSBhbmQgcmV0dXJucyBhIFByb21pc2UgdGhhdFxuICAgICAqIHJlc29sdmVzIHdpdGggYSBzdHJpbmcgY29udGFpbmluZyB0aGUgZmlsZSdzIGNvbnRlbnRzLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPHN0cmluZz59IEEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggYSBzdHJpbmcgY29udGFpbmluZyB0aGUgZmlsZSdzIGNvbnRlbnRzLlxuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgZmlsZSBjYW5ub3QgYmUgcmVhZC5cbiAgICAgKi9cbiAgICBhc3luYyB0ZXh0KCkge1xuICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgZnMucHJvbWlzZXMucmVhZEZpbGUodGhpcy5maWxlUGF0aCwgJ3V0ZjgnKTtcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVhZHMgdGhlIGNvbnRlbnRzIG9mIHRoZSBmaWxlIHNwZWNpZmllZCBieSB0aGUgZmlsZVBhdGggcHJvcGVydHkgYW5kIHJldHVybnMgYSBQcm9taXNlIHRoYXRcbiAgICAgKiByZXNvbHZlcyB3aXRoIGEgcGFyc2VkIEphdmFTY3JpcHQgb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGZpbGUncyBjb250ZW50cy5cbiAgICAgKiBcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fSBBIFByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIGEgcGFyc2VkIEphdmFTY3JpcHQgb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGZpbGUncyBjb250ZW50cy5cbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIGZpbGUgY2Fubm90IGJlIHJlYWQuXG4gICAgICovXG4gICAgYXN5bmMganNvbigpIHtcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoYXdhaXQgdGhpcy50ZXh0KCkpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIGdpdmVuIHN0cmluZyBpcyBhIHZhbGlkIEhUVFAgb3IgSFRUUFMgVVJMLlxuICogQHBhcmFtIHtzdHJpbmd8VVJMfSBzdHJpbmcgVGhlIHN0cmluZyB0byB0ZXN0IGZvciB2YWxpZGl0eSBhcyBhbiBIVFRQIG9yIEhUVFBTIFVSTC5cbiAqIEBwYXJhbSB7c3RyaW5nW119IFt2YWxpZEhvc3RzPW51bGxdIEEgbGlzdCBvZiB2YWxpZCBob3N0bmFtZXMuIElmIHNwZWNpZmllZCwgdGhlIFVSTCdzIGhvc3RuYW1lIG11c3QgYmUgaW4gdGhpcyBsaXN0LlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIHN0cmluZyBpcyBhIHZhbGlkIEhUVFAgb3IgSFRUUFMgVVJMLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWRIdHRwVXJsKHN0cmluZywgdmFsaWRIb3N0cyA9IG51bGwpIHtcbiAgICAvLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvNDM0NjcxNDRcbiAgICBsZXQgdXJsO1xuICAgIHRyeSB7XG4gICAgICAgIHVybCA9IG5ldyBVUkwoc3RyaW5nKTtcbiAgICB9IGNhdGNoIChfKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHZhbGlkSG9zdHMgJiYgIXZhbGlkSG9zdHMuaW5jbHVkZXModXJsLmhvc3RuYW1lKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB1cmwucHJvdG9jb2wgPT09IFwiaHR0cDpcIiB8fCB1cmwucHJvdG9jb2wgPT09IFwiaHR0cHM6XCI7XG59XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRvIGdldCBhIGZpbGUsIHVzaW5nIGVpdGhlciB0aGUgRmV0Y2ggQVBJIG9yIEZpbGVTeXN0ZW0gQVBJLlxuICpcbiAqIEBwYXJhbSB7VVJMfHN0cmluZ30gdXJsT3JQYXRoIFRoZSBVUkwvcGF0aCBvZiB0aGUgZmlsZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxGaWxlUmVzcG9uc2V8UmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIEZpbGVSZXNwb25zZSBvYmplY3QgKGlmIHRoZSBmaWxlIGlzIHJldHJpZXZlZCB1c2luZyB0aGUgRmlsZVN5c3RlbSBBUEkpLCBvciBhIFJlc3BvbnNlIG9iamVjdCAoaWYgdGhlIGZpbGUgaXMgcmV0cmlldmVkIHVzaW5nIHRoZSBGZXRjaCBBUEkpLlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0RmlsZSh1cmxPclBhdGgpIHtcblxuICAgIGlmIChlbnYudXNlRlMgJiYgIWlzVmFsaWRIdHRwVXJsKHVybE9yUGF0aCkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBGaWxlUmVzcG9uc2UodXJsT3JQYXRoKTtcblxuICAgIH0gZWxzZSBpZiAodHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIHByb2Nlc3M/LnJlbGVhc2U/Lm5hbWUgPT09ICdub2RlJykge1xuICAgICAgICBjb25zdCBJU19DSSA9ICEhcHJvY2Vzcy5lbnY/LlRFU1RJTkdfUkVNT1RFTFk7XG4gICAgICAgIGNvbnN0IHZlcnNpb24gPSBlbnYudmVyc2lvbjtcblxuICAgICAgICBjb25zdCBoZWFkZXJzID0gbmV3IEhlYWRlcnMoKTtcbiAgICAgICAgaGVhZGVycy5zZXQoJ1VzZXItQWdlbnQnLCBgdHJhbnNmb3JtZXJzLmpzLyR7dmVyc2lvbn07IGlzX2NpLyR7SVNfQ0l9O2ApO1xuXG4gICAgICAgIC8vIENoZWNrIHdoZXRoZXIgd2UgYXJlIG1ha2luZyBhIHJlcXVlc3QgdG8gdGhlIEh1Z2dpbmcgRmFjZSBIdWIuXG4gICAgICAgIGNvbnN0IGlzSEZVUkwgPSBpc1ZhbGlkSHR0cFVybCh1cmxPclBhdGgsIFsnaHVnZ2luZ2ZhY2UuY28nLCAnaGYuY28nXSk7XG4gICAgICAgIGlmIChpc0hGVVJMKSB7XG4gICAgICAgICAgICAvLyBJZiBhbiBhY2Nlc3MgdG9rZW4gaXMgcHJlc2VudCBpbiB0aGUgZW52aXJvbm1lbnQgdmFyaWFibGVzLFxuICAgICAgICAgICAgLy8gd2UgYWRkIGl0IHRvIHRoZSByZXF1ZXN0IGhlYWRlcnMuXG4gICAgICAgICAgICBjb25zdCB0b2tlbiA9IHByb2Nlc3MuZW52Py5IRl9BQ0NFU1NfVE9LRU47XG4gICAgICAgICAgICBpZiAodG9rZW4pIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzLnNldCgnQXV0aG9yaXphdGlvbicsIGBCZWFyZXIgJHt0b2tlbn1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmV0Y2godXJsT3JQYXRoLCB7IGhlYWRlcnMgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gUnVubmluZyBpbiBhIGJyb3dzZXItZW52aXJvbm1lbnQsIHNvIHdlIHVzZSBkZWZhdWx0IGhlYWRlcnNcbiAgICAgICAgLy8gTk9URTogV2UgZG8gbm90IGFsbG93IHBhc3NpbmcgYXV0aG9yaXphdGlvbiBoZWFkZXJzIGluIHRoZSBicm93c2VyLFxuICAgICAgICAvLyBzaW5jZSB0aGlzIHdvdWxkIHJlcXVpcmUgZXhwb3NpbmcgdGhlIHRva2VuIHRvIHRoZSBjbGllbnQuXG4gICAgICAgIHJldHVybiBmZXRjaCh1cmxPclBhdGgpO1xuICAgIH1cbn1cblxuY29uc3QgRVJST1JfTUFQUElORyA9IHtcbiAgICAvLyA0eHggZXJyb3JzIChodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVFRQL1N0YXR1cyNjbGllbnRfZXJyb3JfcmVzcG9uc2VzKVxuICAgIDQwMDogJ0JhZCByZXF1ZXN0IGVycm9yIG9jY3VycmVkIHdoaWxlIHRyeWluZyB0byBsb2FkIGZpbGUnLFxuICAgIDQwMTogJ1VuYXV0aG9yaXplZCBhY2Nlc3MgdG8gZmlsZScsXG4gICAgNDAzOiAnRm9yYmlkZGVuIGFjY2VzcyB0byBmaWxlJyxcbiAgICA0MDQ6ICdDb3VsZCBub3QgbG9jYXRlIGZpbGUnLFxuICAgIDQwODogJ1JlcXVlc3QgdGltZW91dCBlcnJvciBvY2N1cnJlZCB3aGlsZSB0cnlpbmcgdG8gbG9hZCBmaWxlJyxcblxuICAgIC8vIDV4eCBlcnJvcnMgKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUVFAvU3RhdHVzI3NlcnZlcl9lcnJvcl9yZXNwb25zZXMpXG4gICAgNTAwOiAnSW50ZXJuYWwgc2VydmVyIGVycm9yIGVycm9yIG9jY3VycmVkIHdoaWxlIHRyeWluZyB0byBsb2FkIGZpbGUnLFxuICAgIDUwMjogJ0JhZCBnYXRld2F5IGVycm9yIG9jY3VycmVkIHdoaWxlIHRyeWluZyB0byBsb2FkIGZpbGUnLFxuICAgIDUwMzogJ1NlcnZpY2UgdW5hdmFpbGFibGUgZXJyb3Igb2NjdXJyZWQgd2hpbGUgdHJ5aW5nIHRvIGxvYWQgZmlsZScsXG4gICAgNTA0OiAnR2F0ZXdheSB0aW1lb3V0IGVycm9yIG9jY3VycmVkIHdoaWxlIHRyeWluZyB0byBsb2FkIGZpbGUnLFxufVxuLyoqXG4gKiBIZWxwZXIgbWV0aG9kIHRvIGhhbmRsZSBmYXRhbCBlcnJvcnMgdGhhdCBvY2N1ciB3aGlsZSB0cnlpbmcgdG8gbG9hZCBhIGZpbGUgZnJvbSB0aGUgSHVnZ2luZyBGYWNlIEh1Yi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdGF0dXMgVGhlIEhUVFAgc3RhdHVzIGNvZGUgb2YgdGhlIGVycm9yLlxuICogQHBhcmFtIHtzdHJpbmd9IHJlbW90ZVVSTCBUaGUgVVJMIG9mIHRoZSBmaWxlIHRoYXQgY291bGQgbm90IGJlIGxvYWRlZC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gZmF0YWwgV2hldGhlciB0byByYWlzZSBhbiBlcnJvciBpZiB0aGUgZmlsZSBjb3VsZCBub3QgYmUgbG9hZGVkLlxuICogQHJldHVybnMge251bGx9IFJldHVybnMgYG51bGxgIGlmIGBmYXRhbCA9IHRydWVgLlxuICogQHRocm93cyB7RXJyb3J9IElmIGBmYXRhbCA9IGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFuZGxlRXJyb3Ioc3RhdHVzLCByZW1vdGVVUkwsIGZhdGFsKSB7XG4gICAgaWYgKCFmYXRhbCkge1xuICAgICAgICAvLyBGaWxlIHdhcyBub3QgbG9hZGVkIGNvcnJlY3RseSwgYnV0IGl0IGlzIG9wdGlvbmFsLlxuICAgICAgICAvLyBUT0RPIGluIGZ1dHVyZSwgY2FjaGUgdGhlIHJlc3BvbnNlP1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBjb25zdCBtZXNzYWdlID0gRVJST1JfTUFQUElOR1tzdGF0dXNdID8/IGBFcnJvciAoJHtzdGF0dXN9KSBvY2N1cnJlZCB3aGlsZSB0cnlpbmcgdG8gbG9hZCBmaWxlYDtcbiAgICB0aHJvdyBFcnJvcihgJHttZXNzYWdlfTogXCIke3JlbW90ZVVSTH1cIi5gKTtcbn1cblxuY2xhc3MgRmlsZUNhY2hlIHtcbiAgICAvKipcbiAgICAgKiBJbnN0YW50aWF0ZSBhIGBGaWxlQ2FjaGVgIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihwYXRoKSB7XG4gICAgICAgIHRoaXMucGF0aCA9IHBhdGg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIHJlcXVlc3QgaXMgaW4gdGhlIGNhY2hlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSByZXF1ZXN0IFxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEZpbGVSZXNwb25zZSB8IHVuZGVmaW5lZD59XG4gICAgICovXG4gICAgYXN5bmMgbWF0Y2gocmVxdWVzdCkge1xuXG4gICAgICAgIGxldCBmaWxlUGF0aCA9IHBhdGguam9pbih0aGlzLnBhdGgsIHJlcXVlc3QpO1xuICAgICAgICBsZXQgZmlsZSA9IG5ldyBGaWxlUmVzcG9uc2UoZmlsZVBhdGgpO1xuXG4gICAgICAgIGlmIChmaWxlLmV4aXN0cykge1xuICAgICAgICAgICAgcmV0dXJuIGZpbGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkcyB0aGUgZ2l2ZW4gcmVzcG9uc2UgdG8gdGhlIGNhY2hlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSByZXF1ZXN0IFxuICAgICAqIEBwYXJhbSB7UmVzcG9uc2V8RmlsZVJlc3BvbnNlfSByZXNwb25zZSBcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAgICAgKi9cbiAgICBhc3luYyBwdXQocmVxdWVzdCwgcmVzcG9uc2UpIHtcbiAgICAgICAgY29uc3QgYnVmZmVyID0gQnVmZmVyLmZyb20oYXdhaXQgcmVzcG9uc2UuYXJyYXlCdWZmZXIoKSk7XG5cbiAgICAgICAgbGV0IG91dHB1dFBhdGggPSBwYXRoLmpvaW4odGhpcy5wYXRoLCByZXF1ZXN0KTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgZnMucHJvbWlzZXMubWtkaXIocGF0aC5kaXJuYW1lKG91dHB1dFBhdGgpLCB7IHJlY3Vyc2l2ZTogdHJ1ZSB9KTtcbiAgICAgICAgICAgIGF3YWl0IGZzLnByb21pc2VzLndyaXRlRmlsZShvdXRwdXRQYXRoLCBidWZmZXIpO1xuXG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdBbiBlcnJvciBvY2N1cnJlZCB3aGlsZSB3cml0aW5nIHRoZSBmaWxlIHRvIGNhY2hlOicsIGVycilcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRPRE8gYWRkIHRoZSByZXN0P1xuICAgIC8vIGFkZEFsbChyZXF1ZXN0czogUmVxdWVzdEluZm9bXSk6IFByb21pc2U8dm9pZD47XG4gICAgLy8gZGVsZXRlKHJlcXVlc3Q6IFJlcXVlc3RJbmZvIHwgVVJMLCBvcHRpb25zPzogQ2FjaGVRdWVyeU9wdGlvbnMpOiBQcm9taXNlPGJvb2xlYW4+O1xuICAgIC8vIGtleXMocmVxdWVzdD86IFJlcXVlc3RJbmZvIHwgVVJMLCBvcHRpb25zPzogQ2FjaGVRdWVyeU9wdGlvbnMpOiBQcm9taXNlPFJlYWRvbmx5QXJyYXk8UmVxdWVzdD4+O1xuICAgIC8vIG1hdGNoKHJlcXVlc3Q6IFJlcXVlc3RJbmZvIHwgVVJMLCBvcHRpb25zPzogQ2FjaGVRdWVyeU9wdGlvbnMpOiBQcm9taXNlPFJlc3BvbnNlIHwgdW5kZWZpbmVkPjtcbiAgICAvLyBtYXRjaEFsbChyZXF1ZXN0PzogUmVxdWVzdEluZm8gfCBVUkwsIG9wdGlvbnM/OiBDYWNoZVF1ZXJ5T3B0aW9ucyk6IFByb21pc2U8UmVhZG9ubHlBcnJheTxSZXNwb25zZT4+O1xufVxuXG4vKipcbiAqIFxuICogQHBhcmFtIHtGaWxlQ2FjaGV8Q2FjaGV9IGNhY2hlIFRoZSBjYWNoZSB0byBzZWFyY2hcbiAqIEBwYXJhbSB7c3RyaW5nW119IG5hbWVzIFRoZSBuYW1lcyBvZiB0aGUgaXRlbSB0byBzZWFyY2ggZm9yXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxGaWxlUmVzcG9uc2V8UmVzcG9uc2V8dW5kZWZpbmVkPn0gVGhlIGl0ZW0gZnJvbSB0aGUgY2FjaGUsIG9yIHVuZGVmaW5lZCBpZiBub3QgZm91bmQuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHRyeUNhY2hlKGNhY2hlLCAuLi5uYW1lcykge1xuICAgIGZvciAobGV0IG5hbWUgb2YgbmFtZXMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBhd2FpdCBjYWNoZS5tYXRjaChuYW1lKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQpIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogXG4gKiBSZXRyaWV2ZXMgYSBmaWxlIGZyb20gZWl0aGVyIGEgcmVtb3RlIFVSTCB1c2luZyB0aGUgRmV0Y2ggQVBJIG9yIGZyb20gdGhlIGxvY2FsIGZpbGUgc3lzdGVtIHVzaW5nIHRoZSBGaWxlU3lzdGVtIEFQSS5cbiAqIElmIHRoZSBmaWxlc3lzdGVtIGlzIGF2YWlsYWJsZSBhbmQgYGVudi51c2VDYWNoZSA9IHRydWVgLCB0aGUgZmlsZSB3aWxsIGJlIGRvd25sb2FkZWQgYW5kIGNhY2hlZC5cbiAqIFxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGhfb3JfcmVwb19pZCBUaGlzIGNhbiBiZSBlaXRoZXI6XG4gKiAtIGEgc3RyaW5nLCB0aGUgKm1vZGVsIGlkKiBvZiBhIG1vZGVsIHJlcG8gb24gaHVnZ2luZ2ZhY2UuY28uXG4gKiAtIGEgcGF0aCB0byBhICpkaXJlY3RvcnkqIHBvdGVudGlhbGx5IGNvbnRhaW5pbmcgdGhlIGZpbGUuXG4gKiBAcGFyYW0ge3N0cmluZ30gZmlsZW5hbWUgVGhlIG5hbWUgb2YgdGhlIGZpbGUgdG8gbG9jYXRlIGluIGBwYXRoX29yX3JlcG9gLlxuICogQHBhcmFtIHtib29sZWFufSBbZmF0YWw9dHJ1ZV0gV2hldGhlciB0byB0aHJvdyBhbiBlcnJvciBpZiB0aGUgZmlsZSBpcyBub3QgZm91bmQuXG4gKiBAcGFyYW0ge1ByZXRyYWluZWRPcHRpb25zfSBbb3B0aW9uc10gQW4gb2JqZWN0IGNvbnRhaW5pbmcgb3B0aW9uYWwgcGFyYW1ldGVycy5cbiAqIFxuICogQHRocm93cyBXaWxsIHRocm93IGFuIGVycm9yIGlmIHRoZSBmaWxlIGlzIG5vdCBmb3VuZCBhbmQgYGZhdGFsYCBpcyB0cnVlLlxuICogQHJldHVybnMge1Byb21pc2V9IEEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggdGhlIGZpbGUgY29udGVudCBhcyBhIGJ1ZmZlci5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldE1vZGVsRmlsZShwYXRoX29yX3JlcG9faWQsIGZpbGVuYW1lLCBmYXRhbCA9IHRydWUsIG9wdGlvbnMgPSB7fSkge1xuXG4gICAgaWYgKCFlbnYuYWxsb3dMb2NhbE1vZGVscykge1xuICAgICAgICAvLyBVc2VyIGhhcyBkaXNhYmxlZCBsb2NhbCBtb2RlbHMsIHNvIHdlIGp1c3QgbWFrZSBzdXJlIG90aGVyIHNldHRpbmdzIGFyZSBjb3JyZWN0LlxuXG4gICAgICAgIGlmIChvcHRpb25zLmxvY2FsX2ZpbGVzX29ubHkpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKFwiSW52YWxpZCBjb25maWd1cmF0aW9uIGRldGVjdGVkOiBsb2NhbCBtb2RlbHMgYXJlIGRpc2FibGVkIChgZW52LmFsbG93TG9jYWxNb2RlbHM9ZmFsc2VgKSBidXQgeW91IGhhdmUgcmVxdWVzdGVkIHRvIG9ubHkgdXNlIGxvY2FsIG1vZGVscyAoYGxvY2FsX2ZpbGVzX29ubHk9dHJ1ZWApLlwiKVxuICAgICAgICB9IGVsc2UgaWYgKCFlbnYuYWxsb3dSZW1vdGVNb2RlbHMpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKFwiSW52YWxpZCBjb25maWd1cmF0aW9uIGRldGVjdGVkOiBib3RoIGxvY2FsIGFuZCByZW1vdGUgbW9kZWxzIGFyZSBkaXNhYmxlZC4gRml4IGJ5IHNldHRpbmcgYGVudi5hbGxvd0xvY2FsTW9kZWxzYCBvciBgZW52LmFsbG93UmVtb3RlTW9kZWxzYCB0byBgdHJ1ZWAuXCIpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJbml0aWF0ZSBmaWxlIHJldHJpZXZhbFxuICAgIGRpc3BhdGNoQ2FsbGJhY2sob3B0aW9ucy5wcm9ncmVzc19jYWxsYmFjaywge1xuICAgICAgICBzdGF0dXM6ICdpbml0aWF0ZScsXG4gICAgICAgIG5hbWU6IHBhdGhfb3JfcmVwb19pZCxcbiAgICAgICAgZmlsZTogZmlsZW5hbWVcbiAgICB9KVxuXG4gICAgLy8gRmlyc3QsIGNoZWNrIGlmIHRoZSBhIGNhY2hpbmcgYmFja2VuZCBpcyBhdmFpbGFibGVcbiAgICAvLyBJZiBubyBjYWNoaW5nIG1lY2hhbmlzbSBhdmFpbGFibGUsIHdpbGwgZG93bmxvYWQgdGhlIGZpbGUgZXZlcnkgdGltZVxuICAgIGxldCBjYWNoZTtcbiAgICBpZiAoIWNhY2hlICYmIGVudi51c2VCcm93c2VyQ2FjaGUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjYWNoZXMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcignQnJvd3NlciBjYWNoZSBpcyBub3QgYXZhaWxhYmxlIGluIHRoaXMgZW52aXJvbm1lbnQuJylcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gSW4gc29tZSBjYXNlcywgdGhlIGJyb3dzZXIgY2FjaGUgbWF5IGJlIHZpc2libGUsIGJ1dCBub3QgYWNjZXNzaWJsZSBkdWUgdG8gc2VjdXJpdHkgcmVzdHJpY3Rpb25zLlxuICAgICAgICAgICAgLy8gRm9yIGV4YW1wbGUsIHdoZW4gcnVubmluZyBhbiBhcHBsaWNhdGlvbiBpbiBhbiBpZnJhbWUsIGlmIGEgdXNlciBhdHRlbXB0cyB0byBsb2FkIHRoZSBwYWdlIGluXG4gICAgICAgICAgICAvLyBpbmNvZ25pdG8gbW9kZSwgdGhlIGZvbGxvd2luZyBlcnJvciBpcyB0aHJvd246IGBET01FeGNlcHRpb246IEZhaWxlZCB0byBleGVjdXRlICdvcGVuJyBvbiAnQ2FjaGVTdG9yYWdlJzpcbiAgICAgICAgICAgIC8vIEFuIGF0dGVtcHQgd2FzIG1hZGUgdG8gYnJlYWsgdGhyb3VnaCB0aGUgc2VjdXJpdHkgcG9saWN5IG9mIHRoZSB1c2VyIGFnZW50LmBcbiAgICAgICAgICAgIC8vIFNvLCBpbnN0ZWFkIG9mIGNyYXNoaW5nLCB3ZSBqdXN0IGlnbm9yZSB0aGUgZXJyb3IgYW5kIGNvbnRpbnVlIHdpdGhvdXQgdXNpbmcgdGhlIGNhY2hlLlxuICAgICAgICAgICAgY2FjaGUgPSBhd2FpdCBjYWNoZXMub3BlbigndHJhbnNmb3JtZXJzLWNhY2hlJyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignQW4gZXJyb3Igb2NjdXJyZWQgd2hpbGUgb3BlbmluZyB0aGUgYnJvd3NlciBjYWNoZTonLCBlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmICghY2FjaGUgJiYgZW52LnVzZUZTQ2FjaGUpIHtcbiAgICAgICAgLy8gVE9ETyB0aHJvdyBlcnJvciBpZiBub3QgYXZhaWxhYmxlXG5cbiAgICAgICAgLy8gSWYgYGNhY2hlX2RpcmAgaXMgbm90IHNwZWNpZmllZCwgdXNlIHRoZSBkZWZhdWx0IGNhY2hlIGRpcmVjdG9yeVxuICAgICAgICBjYWNoZSA9IG5ldyBGaWxlQ2FjaGUob3B0aW9ucy5jYWNoZV9kaXIgPz8gZW52LmNhY2hlRGlyKTtcbiAgICB9XG5cbiAgICBjb25zdCByZXZpc2lvbiA9IG9wdGlvbnMucmV2aXNpb24gPz8gJ21haW4nO1xuXG4gICAgbGV0IHJlcXVlc3RVUkwgPSBwYXRoSm9pbihwYXRoX29yX3JlcG9faWQsIGZpbGVuYW1lKTtcbiAgICBsZXQgbG9jYWxQYXRoID0gcGF0aEpvaW4oZW52LmxvY2FsTW9kZWxQYXRoLCByZXF1ZXN0VVJMKTtcblxuICAgIGxldCByZW1vdGVVUkwgPSBwYXRoSm9pbihcbiAgICAgICAgZW52LnJlbW90ZUhvc3QsXG4gICAgICAgIGVudi5yZW1vdGVQYXRoVGVtcGxhdGVcbiAgICAgICAgICAgIC5yZXBsYWNlQWxsKCd7bW9kZWx9JywgcGF0aF9vcl9yZXBvX2lkKVxuICAgICAgICAgICAgLnJlcGxhY2VBbGwoJ3tyZXZpc2lvbn0nLCByZXZpc2lvbiksXG4gICAgICAgIGZpbGVuYW1lXG4gICAgKTtcblxuICAgIC8vIENob29zZSBjYWNoZSBrZXkgZm9yIGZpbGVzeXN0ZW0gY2FjaGVcbiAgICAvLyBXaGVuIHVzaW5nIHRoZSBtYWluIHJldmlzaW9uIChkZWZhdWx0KSwgd2UgdXNlIHRoZSByZXF1ZXN0IFVSTCBhcyB0aGUgY2FjaGUga2V5LlxuICAgIC8vIElmIGEgc3BlY2lmaWMgcmV2aXNpb24gaXMgcmVxdWVzdGVkLCB3ZSBhY2NvdW50IGZvciB0aGlzIGluIHRoZSBjYWNoZSBrZXkuXG4gICAgbGV0IGZzQ2FjaGVLZXkgPSByZXZpc2lvbiA9PT0gJ21haW4nID8gcmVxdWVzdFVSTCA6IHBhdGhKb2luKHBhdGhfb3JfcmVwb19pZCwgcmV2aXNpb24sIGZpbGVuYW1lKTtcblxuICAgIC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xuICAgIGxldCBjYWNoZUtleTtcbiAgICBsZXQgcHJvcG9zZWRDYWNoZUtleSA9IGNhY2hlIGluc3RhbmNlb2YgRmlsZUNhY2hlID8gZnNDYWNoZUtleSA6IHJlbW90ZVVSTDtcblxuICAgIC8qKiBAdHlwZSB7UmVzcG9uc2V8dW5kZWZpbmVkfSAqL1xuICAgIGxldCByZXNwb25zZVRvQ2FjaGU7XG5cbiAgICAvKiogQHR5cGUge1Jlc3BvbnNlfEZpbGVSZXNwb25zZXx1bmRlZmluZWR9ICovXG4gICAgbGV0IHJlc3BvbnNlO1xuXG4gICAgaWYgKGNhY2hlKSB7XG4gICAgICAgIC8vIEEgY2FjaGluZyBzeXN0ZW0gaXMgYXZhaWxhYmxlLCBzbyB3ZSB0cnkgdG8gZ2V0IHRoZSBmaWxlIGZyb20gaXQuXG4gICAgICAgIC8vICAxLiBXZSBmaXJzdCB0cnkgdG8gZ2V0IGZyb20gY2FjaGUgdXNpbmcgdGhlIGxvY2FsIHBhdGguIEluIHNvbWUgZW52aXJvbm1lbnRzIChsaWtlIGRlbm8pLFxuICAgICAgICAvLyAgICAgbm9uLVVSTCBjYWNoZSBrZXlzIGFyZSBub3QgYWxsb3dlZC4gSW4gdGhlc2UgY2FzZXMsIGByZXNwb25zZWAgd2lsbCBiZSB1bmRlZmluZWQuXG4gICAgICAgIC8vICAyLiBJZiBubyByZXNwb25zZSBpcyBmb3VuZCwgd2UgdHJ5IHRvIGdldCBmcm9tIGNhY2hlIHVzaW5nIHRoZSByZW1vdGUgVVJMIG9yIGZpbGUgc3lzdGVtIGNhY2hlLlxuICAgICAgICByZXNwb25zZSA9IGF3YWl0IHRyeUNhY2hlKGNhY2hlLCBsb2NhbFBhdGgsIHByb3Bvc2VkQ2FjaGVLZXkpO1xuICAgIH1cblxuICAgIGlmIChyZXNwb25zZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIENhY2hpbmcgbm90IGF2YWlsYWJsZSwgb3IgZmlsZSBpcyBub3QgY2FjaGVkLCBzbyB3ZSBwZXJmb3JtIHRoZSByZXF1ZXN0XG5cbiAgICAgICAgaWYgKGVudi5hbGxvd0xvY2FsTW9kZWxzKSB7XG4gICAgICAgICAgICAvLyBBY2Nlc3NpbmcgbG9jYWwgbW9kZWxzIGlzIGVuYWJsZWQsIHNvIHdlIHRyeSB0byBnZXQgdGhlIGZpbGUgbG9jYWxseS5cbiAgICAgICAgICAgIC8vIElmIHJlcXVlc3QgaXMgYSB2YWxpZCBIVFRQIFVSTCwgd2Ugc2tpcCB0aGUgbG9jYWwgZmlsZSBjaGVjay4gT3RoZXJ3aXNlLCB3ZSB0cnkgdG8gZ2V0IHRoZSBmaWxlIGxvY2FsbHkuXG4gICAgICAgICAgICBjb25zdCBpc1VSTCA9IGlzVmFsaWRIdHRwVXJsKHJlcXVlc3RVUkwpO1xuICAgICAgICAgICAgaWYgKCFpc1VSTCkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gYXdhaXQgZ2V0RmlsZShsb2NhbFBhdGgpO1xuICAgICAgICAgICAgICAgICAgICBjYWNoZUtleSA9IGxvY2FsUGF0aDsgLy8gVXBkYXRlIHRoZSBjYWNoZSBrZXkgdG8gYmUgdGhlIGxvY2FsIHBhdGhcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNvbWV0aGluZyB3ZW50IHdyb25nIHdoaWxlIHRyeWluZyB0byBnZXQgdGhlIGZpbGUgbG9jYWxseS5cbiAgICAgICAgICAgICAgICAgICAgLy8gTk9URTogZXJyb3IgaGFuZGxpbmcgaXMgZG9uZSBpbiB0aGUgbmV4dCBzdGVwIChzaW5jZSBgcmVzcG9uc2VgIHdpbGwgYmUgdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYFVuYWJsZSB0byBsb2FkIGZyb20gbG9jYWwgcGF0aCBcIiR7bG9jYWxQYXRofVwiOiBcIiR7ZX1cImApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy5sb2NhbF9maWxlc19vbmx5KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBcXGBsb2NhbF9maWxlc19vbmx5PXRydWVcXGAsIGJ1dCBhdHRlbXB0ZWQgdG8gbG9hZCBhIHJlbW90ZSBmaWxlIGZyb206ICR7cmVxdWVzdFVSTH0uYCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFlbnYuYWxsb3dSZW1vdGVNb2RlbHMpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFxcYGVudi5hbGxvd1JlbW90ZU1vZGVscz1mYWxzZVxcYCwgYnV0IGF0dGVtcHRlZCB0byBsb2FkIGEgcmVtb3RlIGZpbGUgZnJvbTogJHtyZXF1ZXN0VVJMfS5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZXNwb25zZSA9PT0gdW5kZWZpbmVkIHx8IHJlc3BvbnNlLnN0YXR1cyA9PT0gNDA0KSB7XG4gICAgICAgICAgICAvLyBGaWxlIG5vdCBmb3VuZCBsb2NhbGx5LiBUaGlzIG1lYW5zIGVpdGhlcjpcbiAgICAgICAgICAgIC8vIC0gVGhlIHVzZXIgaGFzIGRpc2FibGVkIGxvY2FsIGZpbGUgYWNjZXNzIChgZW52LmFsbG93TG9jYWxNb2RlbHM9ZmFsc2VgKVxuICAgICAgICAgICAgLy8gLSB0aGUgcGF0aCBpcyBhIHZhbGlkIEhUVFAgdXJsIChgcmVzcG9uc2UgPT09IHVuZGVmaW5lZGApXG4gICAgICAgICAgICAvLyAtIHRoZSBwYXRoIGlzIG5vdCBhIHZhbGlkIEhUVFAgdXJsIGFuZCB0aGUgZmlsZSBpcyBub3QgcHJlc2VudCBvbiB0aGUgZmlsZSBzeXN0ZW0gb3IgbG9jYWwgc2VydmVyIChgcmVzcG9uc2Uuc3RhdHVzID09PSA0MDRgKVxuXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5sb2NhbF9maWxlc19vbmx5IHx8ICFlbnYuYWxsb3dSZW1vdGVNb2RlbHMpIHtcbiAgICAgICAgICAgICAgICAvLyBVc2VyIHJlcXVlc3RlZCBsb2NhbCBmaWxlcyBvbmx5LCBidXQgdGhlIGZpbGUgaXMgbm90IGZvdW5kIGxvY2FsbHkuXG4gICAgICAgICAgICAgICAgaWYgKGZhdGFsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKGBcXGBsb2NhbF9maWxlc19vbmx5PXRydWVcXGAgb3IgXFxgZW52LmFsbG93UmVtb3RlTW9kZWxzPWZhbHNlXFxgIGFuZCBmaWxlIHdhcyBub3QgZm91bmQgbG9jYWxseSBhdCBcIiR7bG9jYWxQYXRofVwiLmApO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEZpbGUgbm90IGZvdW5kLCBidXQgdGhpcyBmaWxlIGlzIG9wdGlvbmFsLlxuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPIGluIGZ1dHVyZSwgY2FjaGUgdGhlIHJlc3BvbnNlP1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEZpbGUgbm90IGZvdW5kIGxvY2FsbHksIHNvIHdlIHRyeSB0byBkb3dubG9hZCBpdCBmcm9tIHRoZSByZW1vdGUgc2VydmVyXG4gICAgICAgICAgICByZXNwb25zZSA9IGF3YWl0IGdldEZpbGUocmVtb3RlVVJMKTtcblxuICAgICAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyAhPT0gMjAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZUVycm9yKHJlc3BvbnNlLnN0YXR1cywgcmVtb3RlVVJMLCBmYXRhbCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFN1Y2Nlc3MhIFdlIHVzZSB0aGUgcHJvcG9zZWQgY2FjaGUga2V5IGZyb20gZWFybGllclxuICAgICAgICAgICAgY2FjaGVLZXkgPSBwcm9wb3NlZENhY2hlS2V5O1xuICAgICAgICB9XG5cblxuICAgICAgICBpZiAoY2FjaGUgJiYgcmVzcG9uc2UgaW5zdGFuY2VvZiBSZXNwb25zZSAmJiByZXNwb25zZS5zdGF0dXMgPT09IDIwMCkge1xuICAgICAgICAgICAgLy8gb25seSBjbG9uZSBpZiBjYWNoZSBhdmFpbGFibGUsIGFuZCByZXNwb25zZSBpcyB2YWxpZFxuICAgICAgICAgICAgcmVzcG9uc2VUb0NhY2hlID0gcmVzcG9uc2UuY2xvbmUoKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgLy8gU3RhcnQgZG93bmxvYWRpbmdcbiAgICBkaXNwYXRjaENhbGxiYWNrKG9wdGlvbnMucHJvZ3Jlc3NfY2FsbGJhY2ssIHtcbiAgICAgICAgc3RhdHVzOiAnZG93bmxvYWQnLFxuICAgICAgICBuYW1lOiBwYXRoX29yX3JlcG9faWQsXG4gICAgICAgIGZpbGU6IGZpbGVuYW1lXG4gICAgfSlcblxuICAgIGNvbnN0IGJ1ZmZlciA9IGF3YWl0IHJlYWRSZXNwb25zZShyZXNwb25zZSwgZGF0YSA9PiB7XG4gICAgICAgIGRpc3BhdGNoQ2FsbGJhY2sob3B0aW9ucy5wcm9ncmVzc19jYWxsYmFjaywge1xuICAgICAgICAgICAgc3RhdHVzOiAncHJvZ3Jlc3MnLFxuICAgICAgICAgICAgLi4uZGF0YSxcbiAgICAgICAgICAgIG5hbWU6IHBhdGhfb3JfcmVwb19pZCxcbiAgICAgICAgICAgIGZpbGU6IGZpbGVuYW1lXG4gICAgICAgIH0pXG4gICAgfSlcblxuXG4gICAgaWYgKFxuICAgICAgICAvLyBPbmx5IGNhY2hlIHdlYiByZXNwb25zZXNcbiAgICAgICAgLy8gaS5lLiwgZG8gbm90IGNhY2hlIEZpbGVSZXNwb25zZXMgKHByZXZlbnRzIGR1cGxpY2F0aW9uKVxuICAgICAgICByZXNwb25zZVRvQ2FjaGUgJiYgY2FjaGVLZXlcbiAgICAgICAgJiZcbiAgICAgICAgLy8gQ2hlY2sgYWdhaW4gd2hldGhlciByZXF1ZXN0IGlzIGluIGNhY2hlLiBJZiBub3QsIHdlIGFkZCB0aGUgcmVzcG9uc2UgdG8gdGhlIGNhY2hlXG4gICAgICAgIChhd2FpdCBjYWNoZS5tYXRjaChjYWNoZUtleSkgPT09IHVuZGVmaW5lZClcbiAgICApIHtcbiAgICAgICAgYXdhaXQgY2FjaGUucHV0KGNhY2hlS2V5LCByZXNwb25zZVRvQ2FjaGUpXG4gICAgICAgICAgICAuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgICAgICAgICAvLyBEbyBub3QgY3Jhc2ggaWYgdW5hYmxlIHRvIGFkZCB0byBjYWNoZSAoZS5nLiwgUXVvdGFFeGNlZWRlZEVycm9yKS5cbiAgICAgICAgICAgICAgICAvLyBSYXRoZXIsIGxvZyBhIHdhcm5pbmcgYW5kIHByb2NlZWQgd2l0aCBleGVjdXRpb24uXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBVbmFibGUgdG8gYWRkIHJlc3BvbnNlIHRvIGJyb3dzZXIgY2FjaGU6ICR7ZXJyfS5gKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgfVxuXG4gICAgZGlzcGF0Y2hDYWxsYmFjayhvcHRpb25zLnByb2dyZXNzX2NhbGxiYWNrLCB7XG4gICAgICAgIHN0YXR1czogJ2RvbmUnLFxuICAgICAgICBuYW1lOiBwYXRoX29yX3JlcG9faWQsXG4gICAgICAgIGZpbGU6IGZpbGVuYW1lXG4gICAgfSk7XG5cbiAgICByZXR1cm4gYnVmZmVyO1xufVxuXG4vKipcbiAqIEZldGNoZXMgYSBKU09OIGZpbGUgZnJvbSBhIGdpdmVuIHBhdGggYW5kIGZpbGUgbmFtZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbW9kZWxQYXRoIFRoZSBwYXRoIHRvIHRoZSBkaXJlY3RvcnkgY29udGFpbmluZyB0aGUgZmlsZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBmaWxlTmFtZSBUaGUgbmFtZSBvZiB0aGUgZmlsZSB0byBmZXRjaC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2ZhdGFsPXRydWVdIFdoZXRoZXIgdG8gdGhyb3cgYW4gZXJyb3IgaWYgdGhlIGZpbGUgaXMgbm90IGZvdW5kLlxuICogQHBhcmFtIHtQcmV0cmFpbmVkT3B0aW9uc30gW29wdGlvbnNdIEFuIG9iamVjdCBjb250YWluaW5nIG9wdGlvbmFsIHBhcmFtZXRlcnMuXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fSBUaGUgSlNPTiBkYXRhIHBhcnNlZCBpbnRvIGEgSmF2YVNjcmlwdCBvYmplY3QuXG4gKiBAdGhyb3dzIFdpbGwgdGhyb3cgYW4gZXJyb3IgaWYgdGhlIGZpbGUgaXMgbm90IGZvdW5kIGFuZCBgZmF0YWxgIGlzIHRydWUuXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRNb2RlbEpTT04obW9kZWxQYXRoLCBmaWxlTmFtZSwgZmF0YWwgPSB0cnVlLCBvcHRpb25zID0ge30pIHtcbiAgICBsZXQgYnVmZmVyID0gYXdhaXQgZ2V0TW9kZWxGaWxlKG1vZGVsUGF0aCwgZmlsZU5hbWUsIGZhdGFsLCBvcHRpb25zKTtcbiAgICBpZiAoYnVmZmVyID09PSBudWxsKSB7XG4gICAgICAgIC8vIFJldHVybiBlbXB0eSBvYmplY3RcbiAgICAgICAgcmV0dXJuIHt9XG4gICAgfVxuXG4gICAgbGV0IGRlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoJ3V0Zi04Jyk7XG4gICAgbGV0IGpzb25EYXRhID0gZGVjb2Rlci5kZWNvZGUoYnVmZmVyKTtcblxuICAgIHJldHVybiBKU09OLnBhcnNlKGpzb25EYXRhKTtcbn1cblxuLyoqXG4gKiBSZWFkIGFuZCB0cmFjayBwcm9ncmVzcyB3aGVuIHJlYWRpbmcgYSBSZXNwb25zZSBvYmplY3RcbiAqXG4gKiBAcGFyYW0ge2FueX0gcmVzcG9uc2UgVGhlIFJlc3BvbnNlIG9iamVjdCB0byByZWFkXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBwcm9ncmVzc19jYWxsYmFjayBUaGUgZnVuY3Rpb24gdG8gY2FsbCB3aXRoIHByb2dyZXNzIHVwZGF0ZXNcbiAqIEByZXR1cm5zIHtQcm9taXNlPFVpbnQ4QXJyYXk+fSBBIFByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSBVaW50OEFycmF5IGJ1ZmZlclxuICovXG5hc3luYyBmdW5jdGlvbiByZWFkUmVzcG9uc2UocmVzcG9uc2UsIHByb2dyZXNzX2NhbGxiYWNrKSB7XG4gICAgLy8gUmVhZCBhbmQgdHJhY2sgcHJvZ3Jlc3Mgd2hlbiByZWFkaW5nIGEgUmVzcG9uc2Ugb2JqZWN0XG5cbiAgICBjb25zdCBjb250ZW50TGVuZ3RoID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoJ0NvbnRlbnQtTGVuZ3RoJyk7XG4gICAgaWYgKGNvbnRlbnRMZW5ndGggPT09IG51bGwpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdVbmFibGUgdG8gZGV0ZXJtaW5lIGNvbnRlbnQtbGVuZ3RoIGZyb20gcmVzcG9uc2UgaGVhZGVycy4gV2lsbCBleHBhbmQgYnVmZmVyIHdoZW4gbmVlZGVkLicpXG4gICAgfVxuICAgIGxldCB0b3RhbCA9IHBhcnNlSW50KGNvbnRlbnRMZW5ndGggPz8gJzAnKTtcbiAgICBsZXQgYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkodG90YWwpO1xuICAgIGxldCBsb2FkZWQgPSAwO1xuXG4gICAgY29uc3QgcmVhZGVyID0gcmVzcG9uc2UuYm9keS5nZXRSZWFkZXIoKTtcbiAgICBhc3luYyBmdW5jdGlvbiByZWFkKCkge1xuICAgICAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuICAgICAgICBpZiAoZG9uZSkgcmV0dXJuO1xuXG4gICAgICAgIGxldCBuZXdMb2FkZWQgPSBsb2FkZWQgKyB2YWx1ZS5sZW5ndGg7XG4gICAgICAgIGlmIChuZXdMb2FkZWQgPiB0b3RhbCkge1xuICAgICAgICAgICAgdG90YWwgPSBuZXdMb2FkZWQ7XG5cbiAgICAgICAgICAgIC8vIEFkZGluZyB0aGUgbmV3IGRhdGEgd2lsbCBvdmVyZmxvdyBidWZmZXIuXG4gICAgICAgICAgICAvLyBJbiB0aGlzIGNhc2UsIHdlIGV4dGVuZCB0aGUgYnVmZmVyXG4gICAgICAgICAgICBsZXQgbmV3QnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkodG90YWwpO1xuXG4gICAgICAgICAgICAvLyBjb3B5IGNvbnRlbnRzXG4gICAgICAgICAgICBuZXdCdWZmZXIuc2V0KGJ1ZmZlcik7XG5cbiAgICAgICAgICAgIGJ1ZmZlciA9IG5ld0J1ZmZlcjtcbiAgICAgICAgfVxuICAgICAgICBidWZmZXIuc2V0KHZhbHVlLCBsb2FkZWQpXG4gICAgICAgIGxvYWRlZCA9IG5ld0xvYWRlZDtcblxuICAgICAgICBjb25zdCBwcm9ncmVzcyA9IChsb2FkZWQgLyB0b3RhbCkgKiAxMDA7XG5cbiAgICAgICAgLy8gQ2FsbCB5b3VyIGZ1bmN0aW9uIGhlcmVcbiAgICAgICAgcHJvZ3Jlc3NfY2FsbGJhY2soe1xuICAgICAgICAgICAgcHJvZ3Jlc3M6IHByb2dyZXNzLFxuICAgICAgICAgICAgbG9hZGVkOiBsb2FkZWQsXG4gICAgICAgICAgICB0b3RhbDogdG90YWwsXG4gICAgICAgIH0pXG5cbiAgICAgICAgcmV0dXJuIHJlYWQoKTtcbiAgICB9XG5cbiAgICAvLyBBY3R1YWxseSByZWFkXG4gICAgYXdhaXQgcmVhZCgpO1xuXG4gICAgcmV0dXJuIGJ1ZmZlcjtcbn1cblxuLyoqXG4gKiBKb2lucyBtdWx0aXBsZSBwYXJ0cyBvZiBhIHBhdGggaW50byBhIHNpbmdsZSBwYXRoLCB3aGlsZSBoYW5kbGluZyBsZWFkaW5nIGFuZCB0cmFpbGluZyBzbGFzaGVzLlxuICpcbiAqIEBwYXJhbSB7Li4uc3RyaW5nfSBwYXJ0cyBNdWx0aXBsZSBwYXJ0cyBvZiBhIHBhdGguXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGpvaW5lZCBwYXRoLlxuICovXG5mdW5jdGlvbiBwYXRoSm9pbiguLi5wYXJ0cykge1xuICAgIC8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS81NTE0MjU2NVxuICAgIHBhcnRzID0gcGFydHMubWFwKChwYXJ0LCBpbmRleCkgPT4ge1xuICAgICAgICBpZiAoaW5kZXgpIHtcbiAgICAgICAgICAgIHBhcnQgPSBwYXJ0LnJlcGxhY2UobmV3IFJlZ0V4cCgnXi8nKSwgJycpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbmRleCAhPT0gcGFydHMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgcGFydCA9IHBhcnQucmVwbGFjZShuZXcgUmVnRXhwKCcvJCcpLCAnJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcnQ7XG4gICAgfSlcbiAgICByZXR1cm4gcGFydHMuam9pbignLycpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@xenova/transformers/src/utils/hub.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@xenova/transformers/src/utils/image.js":
/*!**************************************************************!*\
  !*** ./node_modules/@xenova/transformers/src/utils/image.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RawImage: function() { return /* binding */ RawImage; }\n/* harmony export */ });\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fs */ \"?8373\");\n/* harmony import */ var _core_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./core.js */ \"(app-pages-browser)/./node_modules/@xenova/transformers/src/utils/core.js\");\n/* harmony import */ var _hub_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./hub.js */ \"(app-pages-browser)/./node_modules/@xenova/transformers/src/utils/hub.js\");\n/* harmony import */ var _env_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../env.js */ \"(app-pages-browser)/./node_modules/@xenova/transformers/src/env.js\");\n/* harmony import */ var sharp__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! sharp */ \"?1170\");\n\n/**\n * @file Helper module for image processing. \n * \n * These functions and classes are only used internally, \n * meaning an end-user shouldn't need to access anything here.\n * \n * @module utils/image\n */\n\n\n\n\n\n\n// Will be empty (or not used) if running in browser or web-worker\n\n\nconst BROWSER_ENV = typeof self !== 'undefined';\n\nlet createCanvasFunction;\nlet ImageDataClass;\nlet loadImageFunction;\nif (BROWSER_ENV) {\n    // Running in browser or web-worker\n    createCanvasFunction = (/** @type {number} */ width, /** @type {number} */ height) => {\n        if (!self.OffscreenCanvas) {\n            throw new Error('OffscreenCanvas not supported by this browser.');\n        }\n        return new self.OffscreenCanvas(width, height)\n    };\n    loadImageFunction = self.createImageBitmap;\n    ImageDataClass = self.ImageData;\n\n} else if (sharp__WEBPACK_IMPORTED_MODULE_4__) {\n    // Running in Node.js, electron, or other non-browser environment\n\n    loadImageFunction = async (/**@type {sharp.Sharp}*/img) => {\n        const metadata = await img.metadata();\n        const rawChannels = metadata.channels;\n\n        let { data, info } = await img.raw().toBuffer({ resolveWithObject: true });\n\n        const newImage = new RawImage(new Uint8ClampedArray(data), info.width, info.height, info.channels);\n        if (rawChannels !== undefined && rawChannels !== info.channels) {\n            // Make sure the new image has the same number of channels as the input image.\n            // This is necessary for grayscale images.\n            newImage.convert(rawChannels);\n        }\n        return newImage;\n    }\n\n} else {\n    throw new Error('Unable to load image processing library.');\n}\n\n\n// Defined here: https://github.com/python-pillow/Pillow/blob/a405e8406b83f8bfb8916e93971edc7407b8b1ff/src/libImaging/Imaging.h#L262-L268\nconst RESAMPLING_MAPPING = {\n    0: 'nearest',\n    1: 'lanczos',\n    2: 'bilinear',\n    3: 'bicubic',\n    4: 'box',\n    5: 'hamming',\n}\n\nclass RawImage {\n\n    /**\n     * Create a new `RawImage` object.\n     * @param {Uint8ClampedArray} data The pixel data.\n     * @param {number} width The width of the image.\n     * @param {number} height The height of the image.\n     * @param {1|2|3|4} channels The number of channels.\n     */\n    constructor(data, width, height, channels) {\n        this._update(data, width, height, channels);\n    }\n\n    /**\n     * Helper method for reading an image from a variety of input types.\n     * @param {RawImage|string|URL} input \n     * @returns The image object.\n     * \n     * **Example:** Read image from a URL.\n     * ```javascript\n     * let image = await RawImage.read('https://huggingface.co/datasets/Xenova/transformers.js-docs/resolve/main/football-match.jpg');\n     * // test {\n     * //   \"data\": Uint8ClampedArray [ 25, 25, 25, 19, 19, 19, ... ],\n     * //   \"width\": 800,\n     * //   \"height\": 533,\n     * //   \"channels\": 3\n     * // }\n     * ```\n     */\n    static async read(input) {\n        if (input instanceof RawImage) {\n            return input;\n        } else if ((0,_core_js__WEBPACK_IMPORTED_MODULE_1__.isString)(input) || input instanceof URL) {\n            return await this.fromURL(input);\n        } else {\n            throw new Error(`Unsupported input type: ${typeof input}`);\n        }\n    }\n\n\n    /**\n     * Read an image from a URL or file path.\n     * @param {string|URL} url The URL or file path to read the image from.\n     * @returns {Promise<RawImage>} The image object.\n     */\n    static async fromURL(url) {\n        let response = await (0,_hub_js__WEBPACK_IMPORTED_MODULE_2__.getFile)(url);\n        let blob = await response.blob();\n        return this.fromBlob(blob);\n    }\n\n    /**\n     * Helper method to create a new Image from a blob.\n     * @param {Blob} blob The blob to read the image from.\n     * @returns {Promise<RawImage>} The image object.\n     */\n    static async fromBlob(blob) {\n        if (BROWSER_ENV) {\n            // Running in environment with canvas\n            let img = await loadImageFunction(blob);\n\n            const ctx = createCanvasFunction(img.width, img.height).getContext('2d');\n\n            // Draw image to context\n            ctx.drawImage(img, 0, 0);\n\n            return new this(ctx.getImageData(0, 0, img.width, img.height).data, img.width, img.height, 4);\n\n        } else {\n            // Use sharp.js to read (and possible resize) the image.\n            let img = sharp__WEBPACK_IMPORTED_MODULE_4__(await blob.arrayBuffer());\n\n            return await loadImageFunction(img);\n        }\n    }\n\n    /**\n     * Convert the image to grayscale format.\n     * @returns {RawImage} `this` to support chaining.\n     */\n    grayscale() {\n        if (this.channels === 1) {\n            return this;\n        }\n\n        let newData = new Uint8ClampedArray(this.width * this.height * 1);\n        switch (this.channels) {\n            case 3: // rgb to grayscale\n            case 4: // rgba to grayscale\n                for (let i = 0, offset = 0; i < this.data.length; i += this.channels) {\n                    const red = this.data[i];\n                    const green = this.data[i + 1];\n                    const blue = this.data[i + 2];\n\n                    newData[offset++] = Math.round(0.2989 * red + 0.5870 * green + 0.1140 * blue);\n                }\n                break;\n            default:\n                throw new Error(`Conversion failed due to unsupported number of channels: ${this.channels}`);\n        }\n        return this._update(newData, this.width, this.height, 1);\n    }\n\n    /**\n     * Convert the image to RGB format.\n     * @returns {RawImage} `this` to support chaining.\n     */\n    rgb() {\n        if (this.channels === 3) {\n            return this;\n        }\n\n        let newData = new Uint8ClampedArray(this.width * this.height * 3);\n\n        switch (this.channels) {\n            case 1: // grayscale to rgb\n                for (let i = 0, offset = 0; i < this.data.length; ++i) {\n                    newData[offset++] = this.data[i];\n                    newData[offset++] = this.data[i];\n                    newData[offset++] = this.data[i];\n                }\n                break;\n            case 4: // rgba to rgb\n                for (let i = 0, offset = 0; i < this.data.length; i += 4) {\n                    newData[offset++] = this.data[i];\n                    newData[offset++] = this.data[i + 1];\n                    newData[offset++] = this.data[i + 2];\n                }\n                break;\n            default:\n                throw new Error(`Conversion failed due to unsupported number of channels: ${this.channels}`);\n        }\n        return this._update(newData, this.width, this.height, 3);\n\n    }\n\n    /**\n     * Convert the image to RGBA format.\n     * @returns {RawImage} `this` to support chaining.\n     */\n    rgba() {\n        if (this.channels === 4) {\n            return this;\n        }\n\n        let newData = new Uint8ClampedArray(this.width * this.height * 4);\n\n        switch (this.channels) {\n            case 1: // grayscale to rgba\n                for (let i = 0, offset = 0; i < this.data.length; ++i) {\n                    newData[offset++] = this.data[i];\n                    newData[offset++] = this.data[i];\n                    newData[offset++] = this.data[i];\n                    newData[offset++] = 255;\n                }\n                break;\n            case 3: // rgb to rgba\n                for (let i = 0, offset = 0; i < this.data.length; i += 3) {\n                    newData[offset++] = this.data[i];\n                    newData[offset++] = this.data[i + 1];\n                    newData[offset++] = this.data[i + 2];\n                    newData[offset++] = 255;\n                }\n                break;\n            default:\n                throw new Error(`Conversion failed due to unsupported number of channels: ${this.channels}`);\n        }\n\n        return this._update(newData, this.width, this.height, 4);\n    }\n\n    /**\n     * Resize the image to the given dimensions. This method uses the canvas API to perform the resizing.\n     * @param {number} width The width of the new image.\n     * @param {number} height The height of the new image.\n     * @param {Object} options Additional options for resizing.\n     * @param {0|1|2|3|4|5|string} [options.resample] The resampling method to use.\n     * @returns {Promise<RawImage>} `this` to support chaining.\n     */\n    async resize(width, height, {\n        resample = 2,\n    } = {}) {\n\n        // Ensure resample method is a string\n        let resampleMethod = RESAMPLING_MAPPING[resample] ?? resample;\n\n        if (BROWSER_ENV) {\n            // TODO use `resample` in browser environment\n\n            // Store number of channels before resizing\n            let numChannels = this.channels;\n\n            // Create canvas object for this image\n            let canvas = this.toCanvas();\n\n            // Actually perform resizing using the canvas API\n            const ctx = createCanvasFunction(width, height).getContext('2d');\n\n            // Draw image to context, resizing in the process\n            ctx.drawImage(canvas, 0, 0, width, height);\n\n            // Create image from the resized data\n            let resizedImage = new RawImage(ctx.getImageData(0, 0, width, height).data, width, height, 4);\n\n            // Convert back so that image has the same number of channels as before\n            return resizedImage.convert(numChannels);\n\n        } else {\n            // Create sharp image from raw data, and resize\n            let img = sharp__WEBPACK_IMPORTED_MODULE_4__(this.data, {\n                raw: {\n                    width: this.width,\n                    height: this.height,\n                    channels: this.channels\n                }\n            });\n\n            switch (resampleMethod) {\n                case 'box':\n                case 'hamming':\n                    if (resampleMethod === 'box' || resampleMethod === 'hamming') {\n                        console.warn(`Resampling method ${resampleMethod} is not yet supported. Using bilinear instead.`);\n                        resampleMethod = 'bilinear';\n                    }\n\n                case 'nearest':\n                case 'bilinear':\n                case 'bicubic':\n                    // Perform resizing using affine transform. \n                    // This matches how the python Pillow library does it.\n                    img = img.affine([width / this.width, 0, 0, height / this.height], {\n                        interpolator: resampleMethod\n                    });\n                    break;\n\n                case 'lanczos':\n                    // https://github.com/python-pillow/Pillow/discussions/5519\n                    // https://github.com/lovell/sharp/blob/main/docs/api-resize.md\n                    img = img.resize({\n                        width, height,\n                        fit: 'fill',\n                        kernel: 'lanczos3', // PIL Lanczos uses a kernel size of 3 \n                    });\n                    break;\n\n                default:\n                    throw new Error(`Resampling method ${resampleMethod} is not supported.`);\n            }\n\n            return await loadImageFunction(img);\n        }\n\n    }\n\n    async pad([left, right, top, bottom]) {\n        left = Math.max(left, 0);\n        right = Math.max(right, 0);\n        top = Math.max(top, 0);\n        bottom = Math.max(bottom, 0);\n\n        if (left === 0 && right === 0 && top === 0 && bottom === 0) {\n            // No padding needed\n            return this;\n        }\n\n        if (BROWSER_ENV) {\n            // Store number of channels before padding\n            let numChannels = this.channels;\n\n            // Create canvas object for this image\n            let canvas = this.toCanvas();\n\n            let newWidth = this.width + left + right;\n            let newHeight = this.height + top + bottom;\n\n            // Create a new canvas of the desired size.\n            const ctx = createCanvasFunction(newWidth, newHeight).getContext('2d');\n\n            // Draw image to context, padding in the process\n            ctx.drawImage(canvas,\n                0, 0, this.width, this.height,\n                left, top, newWidth, newHeight\n            );\n\n            // Create image from the padded data\n            let paddedImage = new RawImage(\n                ctx.getImageData(0, 0, newWidth, newHeight).data,\n                newWidth, newHeight, 4);\n\n            // Convert back so that image has the same number of channels as before\n            return paddedImage.convert(numChannels);\n\n        } else {\n            let img = sharp__WEBPACK_IMPORTED_MODULE_4__(this.data, {\n                raw: {\n                    width: this.width,\n                    height: this.height,\n                    channels: this.channels\n                }\n            }).extend({ left, right, top, bottom });\n            return await loadImageFunction(img);\n        }\n    }\n\n    async center_crop(crop_width, crop_height) {\n        // If the image is already the desired size, return it\n        if (this.width === crop_width && this.height === crop_height) {\n            return this;\n        }\n\n        // Determine bounds of the image in the new canvas\n        let width_offset = (this.width - crop_width) / 2;\n        let height_offset = (this.height - crop_height) / 2;\n\n\n        if (BROWSER_ENV) {\n            // Store number of channels before resizing\n            let numChannels = this.channels;\n\n            // Create canvas object for this image\n            let canvas = this.toCanvas();\n\n            // Create a new canvas of the desired size. This is needed since if the \n            // image is too small, we need to pad it with black pixels.\n            const ctx = createCanvasFunction(crop_width, crop_height).getContext('2d');\n\n            let sourceX = 0;\n            let sourceY = 0;\n            let destX = 0;\n            let destY = 0;\n\n            if (width_offset >= 0) {\n                sourceX = width_offset;\n            } else {\n                destX = -width_offset;\n            }\n\n            if (height_offset >= 0) {\n                sourceY = height_offset;\n            } else {\n                destY = -height_offset;\n            }\n\n            // Draw image to context, cropping in the process\n            ctx.drawImage(canvas,\n                sourceX, sourceY, crop_width, crop_height,\n                destX, destY, crop_width, crop_height\n            );\n\n            // Create image from the resized data\n            let resizedImage = new RawImage(ctx.getImageData(0, 0, crop_width, crop_height).data, crop_width, crop_height, 4);\n\n            // Convert back so that image has the same number of channels as before\n            return resizedImage.convert(numChannels);\n\n        } else {\n            // Create sharp image from raw data\n            let img = sharp__WEBPACK_IMPORTED_MODULE_4__(this.data, {\n                raw: {\n                    width: this.width,\n                    height: this.height,\n                    channels: this.channels\n                }\n            });\n\n            if (width_offset >= 0 && height_offset >= 0) {\n                // Cropped image lies entirely within the original image\n                img = img.extract({\n                    left: Math.floor(width_offset),\n                    top: Math.floor(height_offset),\n                    width: crop_width,\n                    height: crop_height,\n                })\n            } else if (width_offset <= 0 && height_offset <= 0) {\n                // Cropped image lies entirely outside the original image,\n                // so we add padding\n                let top = Math.floor(-height_offset);\n                let left = Math.floor(-width_offset);\n                img = img.extend({\n                    top: top,\n                    left: left,\n\n                    // Ensures the resulting image has the desired dimensions\n                    right: crop_width - this.width - left,\n                    bottom: crop_height - this.height - top,\n                });\n            } else {\n                // Cropped image lies partially outside the original image.\n                // We first pad, then crop.\n\n                let y_padding = [0, 0];\n                let y_extract = 0;\n                if (height_offset < 0) {\n                    y_padding[0] = Math.floor(-height_offset);\n                    y_padding[1] = crop_height - this.height - y_padding[0];\n                } else {\n                    y_extract = Math.floor(height_offset);\n                }\n\n                let x_padding = [0, 0];\n                let x_extract = 0;\n                if (width_offset < 0) {\n                    x_padding[0] = Math.floor(-width_offset);\n                    x_padding[1] = crop_width - this.width - x_padding[0];\n                } else {\n                    x_extract = Math.floor(width_offset);\n                }\n\n                img = img.extend({\n                    top: y_padding[0],\n                    bottom: y_padding[1],\n                    left: x_padding[0],\n                    right: x_padding[1],\n                }).extract({\n                    left: x_extract,\n                    top: y_extract,\n                    width: crop_width,\n                    height: crop_height,\n                })\n            }\n\n            return await loadImageFunction(img);\n        }\n    }\n\n    toCanvas() {\n        // Clone, and convert data to RGBA before drawing to canvas.\n        // This is because the canvas API only supports RGBA\n        let cloned = this.clone().rgba();\n\n        // Create canvas object for the cloned image\n        let clonedCanvas = createCanvasFunction(cloned.width, cloned.height);\n\n        // Draw image to context\n        let data = new ImageDataClass(cloned.data, cloned.width, cloned.height);\n        clonedCanvas.getContext('2d').putImageData(data, 0, 0);\n\n        return clonedCanvas;\n    }\n\n    /**\n     * Helper method to update the image data.\n     * @param {Uint8ClampedArray} data The new image data.\n     * @param {number} width The new width of the image.\n     * @param {number} height The new height of the image.\n     * @param {1|2|3|4} channels The new number of channels of the image.\n     */\n    _update(data, width, height, channels = null) {\n        this.data = data;\n        this.width = width;\n        this.height = height;\n        if (channels !== null) {\n            this.channels = channels;\n        }\n        return this;\n    }\n\n    /**\n     * Clone the image\n     * @returns {RawImage} The cloned image\n     */\n    clone() {\n        return new RawImage(this.data.slice(), this.width, this.height, this.channels);\n    }\n\n    /**\n     * Helper method for converting image to have a certain number of channels\n     * @param {number} numChannels The number of channels. Must be 1, 3, or 4.\n     * @returns {RawImage} `this` to support chaining.\n     */\n    convert(numChannels) {\n        if (this.channels === numChannels) return this; // Already correct number of channels\n\n        switch (numChannels) {\n            case 1:\n                this.grayscale();\n                break;\n            case 3:\n                this.rgb();\n                break;\n            case 4:\n                this.rgba();\n                break;\n            default:\n                throw new Error(`Conversion failed due to unsupported number of channels: ${this.channels}`);\n        }\n        return this;\n    }\n\n    /**\n     * Save the image to the given path. This method is only available in environments with access to the FileSystem.\n     * @param {string|Buffer|URL} path The path to save the image to.\n     * @param {string} [mime='image/png'] The mime type of the image.\n     */\n    save(path, mime = 'image/png') {\n        if (!_env_js__WEBPACK_IMPORTED_MODULE_3__.env.useFS) {\n            throw new Error('Unable to save the image because filesystem is disabled in this environment.')\n        }\n\n        let canvas = this.toCanvas();\n        const buffer = canvas.toBuffer(mime);\n        fs__WEBPACK_IMPORTED_MODULE_0__.writeFileSync(path, buffer);\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AeGVub3ZhL3RyYW5zZm9ybWVycy9zcmMvdXRpbHMvaW1hZ2UuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRW9CO0FBQ2lCO0FBQ0Y7QUFDSDs7QUFFaEM7QUFDMEI7O0FBRTFCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsUUFBUSxxQkFBcUIsUUFBUTtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxFQUFFLFNBQVMsa0NBQUs7QUFDaEI7O0FBRUEseUNBQXlDLFlBQVk7QUFDckQ7QUFDQTs7QUFFQSxjQUFjLGFBQWEsNkJBQTZCLHlCQUF5Qjs7QUFFakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxFQUFFO0FBQ0Y7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPOztBQUVQO0FBQ0E7QUFDQSxlQUFlLG1CQUFtQjtBQUNsQyxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxxQkFBcUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFNBQVMsa0RBQVE7QUFDM0I7QUFDQSxVQUFVO0FBQ1YsdURBQXVELGFBQWE7QUFDcEU7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLGVBQWUsWUFBWTtBQUMzQixpQkFBaUIsbUJBQW1CO0FBQ3BDO0FBQ0E7QUFDQSw2QkFBNkIsZ0RBQU87QUFDcEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckIsaUJBQWlCLG1C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QUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxtQkFBbUI7QUFDbEMsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixVQUFVO0FBQzNCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLFVBQVU7QUFDM0I7QUFDQTtBQUNBLHdEQUF3RDs7QUFFeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRGQUE0RixjQUFjO0FBQzFHO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxtQkFBbUI7QUFDbEMsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQSxhQUFhLHdDQUFHO0FBQ2hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVEsNkNBQWdCO0FBQ3hCO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B4ZW5vdmEvdHJhbnNmb3JtZXJzL3NyYy91dGlscy9pbWFnZS5qcz8zZDcwIl0sInNvdXJjZXNDb250ZW50IjpbIlxuLyoqXG4gKiBAZmlsZSBIZWxwZXIgbW9kdWxlIGZvciBpbWFnZSBwcm9jZXNzaW5nLiBcbiAqIFxuICogVGhlc2UgZnVuY3Rpb25zIGFuZCBjbGFzc2VzIGFyZSBvbmx5IHVzZWQgaW50ZXJuYWxseSwgXG4gKiBtZWFuaW5nIGFuIGVuZC11c2VyIHNob3VsZG4ndCBuZWVkIHRvIGFjY2VzcyBhbnl0aGluZyBoZXJlLlxuICogXG4gKiBAbW9kdWxlIHV0aWxzL2ltYWdlXG4gKi9cblxuaW1wb3J0IGZzIGZyb20gJ2ZzJztcbmltcG9ydCB7IGlzU3RyaW5nIH0gZnJvbSAnLi9jb3JlLmpzJztcbmltcG9ydCB7IGdldEZpbGUgfSBmcm9tICcuL2h1Yi5qcyc7XG5pbXBvcnQgeyBlbnYgfSBmcm9tICcuLi9lbnYuanMnO1xuXG4vLyBXaWxsIGJlIGVtcHR5IChvciBub3QgdXNlZCkgaWYgcnVubmluZyBpbiBicm93c2VyIG9yIHdlYi13b3JrZXJcbmltcG9ydCBzaGFycCBmcm9tICdzaGFycCc7XG5cbmNvbnN0IEJST1dTRVJfRU5WID0gdHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnO1xuXG5sZXQgY3JlYXRlQ2FudmFzRnVuY3Rpb247XG5sZXQgSW1hZ2VEYXRhQ2xhc3M7XG5sZXQgbG9hZEltYWdlRnVuY3Rpb247XG5pZiAoQlJPV1NFUl9FTlYpIHtcbiAgICAvLyBSdW5uaW5nIGluIGJyb3dzZXIgb3Igd2ViLXdvcmtlclxuICAgIGNyZWF0ZUNhbnZhc0Z1bmN0aW9uID0gKC8qKiBAdHlwZSB7bnVtYmVyfSAqLyB3aWR0aCwgLyoqIEB0eXBlIHtudW1iZXJ9ICovIGhlaWdodCkgPT4ge1xuICAgICAgICBpZiAoIXNlbGYuT2Zmc2NyZWVuQ2FudmFzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ09mZnNjcmVlbkNhbnZhcyBub3Qgc3VwcG9ydGVkIGJ5IHRoaXMgYnJvd3Nlci4nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IHNlbGYuT2Zmc2NyZWVuQ2FudmFzKHdpZHRoLCBoZWlnaHQpXG4gICAgfTtcbiAgICBsb2FkSW1hZ2VGdW5jdGlvbiA9IHNlbGYuY3JlYXRlSW1hZ2VCaXRtYXA7XG4gICAgSW1hZ2VEYXRhQ2xhc3MgPSBzZWxmLkltYWdlRGF0YTtcblxufSBlbHNlIGlmIChzaGFycCkge1xuICAgIC8vIFJ1bm5pbmcgaW4gTm9kZS5qcywgZWxlY3Ryb24sIG9yIG90aGVyIG5vbi1icm93c2VyIGVudmlyb25tZW50XG5cbiAgICBsb2FkSW1hZ2VGdW5jdGlvbiA9IGFzeW5jICgvKipAdHlwZSB7c2hhcnAuU2hhcnB9Ki9pbWcpID0+IHtcbiAgICAgICAgY29uc3QgbWV0YWRhdGEgPSBhd2FpdCBpbWcubWV0YWRhdGEoKTtcbiAgICAgICAgY29uc3QgcmF3Q2hhbm5lbHMgPSBtZXRhZGF0YS5jaGFubmVscztcblxuICAgICAgICBsZXQgeyBkYXRhLCBpbmZvIH0gPSBhd2FpdCBpbWcucmF3KCkudG9CdWZmZXIoeyByZXNvbHZlV2l0aE9iamVjdDogdHJ1ZSB9KTtcblxuICAgICAgICBjb25zdCBuZXdJbWFnZSA9IG5ldyBSYXdJbWFnZShuZXcgVWludDhDbGFtcGVkQXJyYXkoZGF0YSksIGluZm8ud2lkdGgsIGluZm8uaGVpZ2h0LCBpbmZvLmNoYW5uZWxzKTtcbiAgICAgICAgaWYgKHJhd0NoYW5uZWxzICE9PSB1bmRlZmluZWQgJiYgcmF3Q2hhbm5lbHMgIT09IGluZm8uY2hhbm5lbHMpIHtcbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0aGUgbmV3IGltYWdlIGhhcyB0aGUgc2FtZSBudW1iZXIgb2YgY2hhbm5lbHMgYXMgdGhlIGlucHV0IGltYWdlLlxuICAgICAgICAgICAgLy8gVGhpcyBpcyBuZWNlc3NhcnkgZm9yIGdyYXlzY2FsZSBpbWFnZXMuXG4gICAgICAgICAgICBuZXdJbWFnZS5jb252ZXJ0KHJhd0NoYW5uZWxzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3SW1hZ2U7XG4gICAgfVxuXG59IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGxvYWQgaW1hZ2UgcHJvY2Vzc2luZyBsaWJyYXJ5LicpO1xufVxuXG5cbi8vIERlZmluZWQgaGVyZTogaHR0cHM6Ly9naXRodWIuY29tL3B5dGhvbi1waWxsb3cvUGlsbG93L2Jsb2IvYTQwNWU4NDA2YjgzZjhiZmI4OTE2ZTkzOTcxZWRjNzQwN2I4YjFmZi9zcmMvbGliSW1hZ2luZy9JbWFnaW5nLmgjTDI2Mi1MMjY4XG5jb25zdCBSRVNBTVBMSU5HX01BUFBJTkcgPSB7XG4gICAgMDogJ25lYXJlc3QnLFxuICAgIDE6ICdsYW5jem9zJyxcbiAgICAyOiAnYmlsaW5lYXInLFxuICAgIDM6ICdiaWN1YmljJyxcbiAgICA0OiAnYm94JyxcbiAgICA1OiAnaGFtbWluZycsXG59XG5cbmV4cG9ydCBjbGFzcyBSYXdJbWFnZSB7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgYFJhd0ltYWdlYCBvYmplY3QuXG4gICAgICogQHBhcmFtIHtVaW50OENsYW1wZWRBcnJheX0gZGF0YSBUaGUgcGl4ZWwgZGF0YS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gd2lkdGggVGhlIHdpZHRoIG9mIHRoZSBpbWFnZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IFRoZSBoZWlnaHQgb2YgdGhlIGltYWdlLlxuICAgICAqIEBwYXJhbSB7MXwyfDN8NH0gY2hhbm5lbHMgVGhlIG51bWJlciBvZiBjaGFubmVscy5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihkYXRhLCB3aWR0aCwgaGVpZ2h0LCBjaGFubmVscykge1xuICAgICAgICB0aGlzLl91cGRhdGUoZGF0YSwgd2lkdGgsIGhlaWdodCwgY2hhbm5lbHMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhlbHBlciBtZXRob2QgZm9yIHJlYWRpbmcgYW4gaW1hZ2UgZnJvbSBhIHZhcmlldHkgb2YgaW5wdXQgdHlwZXMuXG4gICAgICogQHBhcmFtIHtSYXdJbWFnZXxzdHJpbmd8VVJMfSBpbnB1dCBcbiAgICAgKiBAcmV0dXJucyBUaGUgaW1hZ2Ugb2JqZWN0LlxuICAgICAqIFxuICAgICAqICoqRXhhbXBsZToqKiBSZWFkIGltYWdlIGZyb20gYSBVUkwuXG4gICAgICogYGBgamF2YXNjcmlwdFxuICAgICAqIGxldCBpbWFnZSA9IGF3YWl0IFJhd0ltYWdlLnJlYWQoJ2h0dHBzOi8vaHVnZ2luZ2ZhY2UuY28vZGF0YXNldHMvWGVub3ZhL3RyYW5zZm9ybWVycy5qcy1kb2NzL3Jlc29sdmUvbWFpbi9mb290YmFsbC1tYXRjaC5qcGcnKTtcbiAgICAgKiAvLyB0ZXN0IHtcbiAgICAgKiAvLyAgIFwiZGF0YVwiOiBVaW50OENsYW1wZWRBcnJheSBbIDI1LCAyNSwgMjUsIDE5LCAxOSwgMTksIC4uLiBdLFxuICAgICAqIC8vICAgXCJ3aWR0aFwiOiA4MDAsXG4gICAgICogLy8gICBcImhlaWdodFwiOiA1MzMsXG4gICAgICogLy8gICBcImNoYW5uZWxzXCI6IDNcbiAgICAgKiAvLyB9XG4gICAgICogYGBgXG4gICAgICovXG4gICAgc3RhdGljIGFzeW5jIHJlYWQoaW5wdXQpIHtcbiAgICAgICAgaWYgKGlucHV0IGluc3RhbmNlb2YgUmF3SW1hZ2UpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dDtcbiAgICAgICAgfSBlbHNlIGlmIChpc1N0cmluZyhpbnB1dCkgfHwgaW5wdXQgaW5zdGFuY2VvZiBVUkwpIHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmZyb21VUkwoaW5wdXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBpbnB1dCB0eXBlOiAke3R5cGVvZiBpbnB1dH1gKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogUmVhZCBhbiBpbWFnZSBmcm9tIGEgVVJMIG9yIGZpbGUgcGF0aC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xVUkx9IHVybCBUaGUgVVJMIG9yIGZpbGUgcGF0aCB0byByZWFkIHRoZSBpbWFnZSBmcm9tLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFJhd0ltYWdlPn0gVGhlIGltYWdlIG9iamVjdC5cbiAgICAgKi9cbiAgICBzdGF0aWMgYXN5bmMgZnJvbVVSTCh1cmwpIHtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgZ2V0RmlsZSh1cmwpO1xuICAgICAgICBsZXQgYmxvYiA9IGF3YWl0IHJlc3BvbnNlLmJsb2IoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZnJvbUJsb2IoYmxvYik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGVscGVyIG1ldGhvZCB0byBjcmVhdGUgYSBuZXcgSW1hZ2UgZnJvbSBhIGJsb2IuXG4gICAgICogQHBhcmFtIHtCbG9ifSBibG9iIFRoZSBibG9iIHRvIHJlYWQgdGhlIGltYWdlIGZyb20uXG4gICAgICogQHJldHVybnMge1Byb21pc2U8UmF3SW1hZ2U+fSBUaGUgaW1hZ2Ugb2JqZWN0LlxuICAgICAqL1xuICAgIHN0YXRpYyBhc3luYyBmcm9tQmxvYihibG9iKSB7XG4gICAgICAgIGlmIChCUk9XU0VSX0VOVikge1xuICAgICAgICAgICAgLy8gUnVubmluZyBpbiBlbnZpcm9ubWVudCB3aXRoIGNhbnZhc1xuICAgICAgICAgICAgbGV0IGltZyA9IGF3YWl0IGxvYWRJbWFnZUZ1bmN0aW9uKGJsb2IpO1xuXG4gICAgICAgICAgICBjb25zdCBjdHggPSBjcmVhdGVDYW52YXNGdW5jdGlvbihpbWcud2lkdGgsIGltZy5oZWlnaHQpLmdldENvbnRleHQoJzJkJyk7XG5cbiAgICAgICAgICAgIC8vIERyYXcgaW1hZ2UgdG8gY29udGV4dFxuICAgICAgICAgICAgY3R4LmRyYXdJbWFnZShpbWcsIDAsIDApO1xuXG4gICAgICAgICAgICByZXR1cm4gbmV3IHRoaXMoY3R4LmdldEltYWdlRGF0YSgwLCAwLCBpbWcud2lkdGgsIGltZy5oZWlnaHQpLmRhdGEsIGltZy53aWR0aCwgaW1nLmhlaWdodCwgNCk7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFVzZSBzaGFycC5qcyB0byByZWFkIChhbmQgcG9zc2libGUgcmVzaXplKSB0aGUgaW1hZ2UuXG4gICAgICAgICAgICBsZXQgaW1nID0gc2hhcnAoYXdhaXQgYmxvYi5hcnJheUJ1ZmZlcigpKTtcblxuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IGxvYWRJbWFnZUZ1bmN0aW9uKGltZyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IHRoZSBpbWFnZSB0byBncmF5c2NhbGUgZm9ybWF0LlxuICAgICAqIEByZXR1cm5zIHtSYXdJbWFnZX0gYHRoaXNgIHRvIHN1cHBvcnQgY2hhaW5pbmcuXG4gICAgICovXG4gICAgZ3JheXNjYWxlKCkge1xuICAgICAgICBpZiAodGhpcy5jaGFubmVscyA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgbmV3RGF0YSA9IG5ldyBVaW50OENsYW1wZWRBcnJheSh0aGlzLndpZHRoICogdGhpcy5oZWlnaHQgKiAxKTtcbiAgICAgICAgc3dpdGNoICh0aGlzLmNoYW5uZWxzKSB7XG4gICAgICAgICAgICBjYXNlIDM6IC8vIHJnYiB0byBncmF5c2NhbGVcbiAgICAgICAgICAgIGNhc2UgNDogLy8gcmdiYSB0byBncmF5c2NhbGVcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgb2Zmc2V0ID0gMDsgaSA8IHRoaXMuZGF0YS5sZW5ndGg7IGkgKz0gdGhpcy5jaGFubmVscykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZWQgPSB0aGlzLmRhdGFbaV07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGdyZWVuID0gdGhpcy5kYXRhW2kgKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYmx1ZSA9IHRoaXMuZGF0YVtpICsgMl07XG5cbiAgICAgICAgICAgICAgICAgICAgbmV3RGF0YVtvZmZzZXQrK10gPSBNYXRoLnJvdW5kKDAuMjk4OSAqIHJlZCArIDAuNTg3MCAqIGdyZWVuICsgMC4xMTQwICogYmx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvbnZlcnNpb24gZmFpbGVkIGR1ZSB0byB1bnN1cHBvcnRlZCBudW1iZXIgb2YgY2hhbm5lbHM6ICR7dGhpcy5jaGFubmVsc31gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fdXBkYXRlKG5ld0RhdGEsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0LCAxKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IHRoZSBpbWFnZSB0byBSR0IgZm9ybWF0LlxuICAgICAqIEByZXR1cm5zIHtSYXdJbWFnZX0gYHRoaXNgIHRvIHN1cHBvcnQgY2hhaW5pbmcuXG4gICAgICovXG4gICAgcmdiKCkge1xuICAgICAgICBpZiAodGhpcy5jaGFubmVscyA9PT0gMykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgbmV3RGF0YSA9IG5ldyBVaW50OENsYW1wZWRBcnJheSh0aGlzLndpZHRoICogdGhpcy5oZWlnaHQgKiAzKTtcblxuICAgICAgICBzd2l0Y2ggKHRoaXMuY2hhbm5lbHMpIHtcbiAgICAgICAgICAgIGNhc2UgMTogLy8gZ3JheXNjYWxlIHRvIHJnYlxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBvZmZzZXQgPSAwOyBpIDwgdGhpcy5kYXRhLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld0RhdGFbb2Zmc2V0KytdID0gdGhpcy5kYXRhW2ldO1xuICAgICAgICAgICAgICAgICAgICBuZXdEYXRhW29mZnNldCsrXSA9IHRoaXMuZGF0YVtpXTtcbiAgICAgICAgICAgICAgICAgICAgbmV3RGF0YVtvZmZzZXQrK10gPSB0aGlzLmRhdGFbaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA0OiAvLyByZ2JhIHRvIHJnYlxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBvZmZzZXQgPSAwOyBpIDwgdGhpcy5kYXRhLmxlbmd0aDsgaSArPSA0KSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld0RhdGFbb2Zmc2V0KytdID0gdGhpcy5kYXRhW2ldO1xuICAgICAgICAgICAgICAgICAgICBuZXdEYXRhW29mZnNldCsrXSA9IHRoaXMuZGF0YVtpICsgMV07XG4gICAgICAgICAgICAgICAgICAgIG5ld0RhdGFbb2Zmc2V0KytdID0gdGhpcy5kYXRhW2kgKyAyXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ29udmVyc2lvbiBmYWlsZWQgZHVlIHRvIHVuc3VwcG9ydGVkIG51bWJlciBvZiBjaGFubmVsczogJHt0aGlzLmNoYW5uZWxzfWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl91cGRhdGUobmV3RGF0YSwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQsIDMpO1xuXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydCB0aGUgaW1hZ2UgdG8gUkdCQSBmb3JtYXQuXG4gICAgICogQHJldHVybnMge1Jhd0ltYWdlfSBgdGhpc2AgdG8gc3VwcG9ydCBjaGFpbmluZy5cbiAgICAgKi9cbiAgICByZ2JhKCkge1xuICAgICAgICBpZiAodGhpcy5jaGFubmVscyA9PT0gNCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgbmV3RGF0YSA9IG5ldyBVaW50OENsYW1wZWRBcnJheSh0aGlzLndpZHRoICogdGhpcy5oZWlnaHQgKiA0KTtcblxuICAgICAgICBzd2l0Y2ggKHRoaXMuY2hhbm5lbHMpIHtcbiAgICAgICAgICAgIGNhc2UgMTogLy8gZ3JheXNjYWxlIHRvIHJnYmFcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgb2Zmc2V0ID0gMDsgaSA8IHRoaXMuZGF0YS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBuZXdEYXRhW29mZnNldCsrXSA9IHRoaXMuZGF0YVtpXTtcbiAgICAgICAgICAgICAgICAgICAgbmV3RGF0YVtvZmZzZXQrK10gPSB0aGlzLmRhdGFbaV07XG4gICAgICAgICAgICAgICAgICAgIG5ld0RhdGFbb2Zmc2V0KytdID0gdGhpcy5kYXRhW2ldO1xuICAgICAgICAgICAgICAgICAgICBuZXdEYXRhW29mZnNldCsrXSA9IDI1NTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDM6IC8vIHJnYiB0byByZ2JhXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIG9mZnNldCA9IDA7IGkgPCB0aGlzLmRhdGEubGVuZ3RoOyBpICs9IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3RGF0YVtvZmZzZXQrK10gPSB0aGlzLmRhdGFbaV07XG4gICAgICAgICAgICAgICAgICAgIG5ld0RhdGFbb2Zmc2V0KytdID0gdGhpcy5kYXRhW2kgKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgbmV3RGF0YVtvZmZzZXQrK10gPSB0aGlzLmRhdGFbaSArIDJdO1xuICAgICAgICAgICAgICAgICAgICBuZXdEYXRhW29mZnNldCsrXSA9IDI1NTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ29udmVyc2lvbiBmYWlsZWQgZHVlIHRvIHVuc3VwcG9ydGVkIG51bWJlciBvZiBjaGFubmVsczogJHt0aGlzLmNoYW5uZWxzfWApO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX3VwZGF0ZShuZXdEYXRhLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCwgNCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVzaXplIHRoZSBpbWFnZSB0byB0aGUgZ2l2ZW4gZGltZW5zaW9ucy4gVGhpcyBtZXRob2QgdXNlcyB0aGUgY2FudmFzIEFQSSB0byBwZXJmb3JtIHRoZSByZXNpemluZy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gd2lkdGggVGhlIHdpZHRoIG9mIHRoZSBuZXcgaW1hZ2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCBUaGUgaGVpZ2h0IG9mIHRoZSBuZXcgaW1hZ2UuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgQWRkaXRpb25hbCBvcHRpb25zIGZvciByZXNpemluZy5cbiAgICAgKiBAcGFyYW0gezB8MXwyfDN8NHw1fHN0cmluZ30gW29wdGlvbnMucmVzYW1wbGVdIFRoZSByZXNhbXBsaW5nIG1ldGhvZCB0byB1c2UuXG4gICAgICogQHJldHVybnMge1Byb21pc2U8UmF3SW1hZ2U+fSBgdGhpc2AgdG8gc3VwcG9ydCBjaGFpbmluZy5cbiAgICAgKi9cbiAgICBhc3luYyByZXNpemUod2lkdGgsIGhlaWdodCwge1xuICAgICAgICByZXNhbXBsZSA9IDIsXG4gICAgfSA9IHt9KSB7XG5cbiAgICAgICAgLy8gRW5zdXJlIHJlc2FtcGxlIG1ldGhvZCBpcyBhIHN0cmluZ1xuICAgICAgICBsZXQgcmVzYW1wbGVNZXRob2QgPSBSRVNBTVBMSU5HX01BUFBJTkdbcmVzYW1wbGVdID8/IHJlc2FtcGxlO1xuXG4gICAgICAgIGlmIChCUk9XU0VSX0VOVikge1xuICAgICAgICAgICAgLy8gVE9ETyB1c2UgYHJlc2FtcGxlYCBpbiBicm93c2VyIGVudmlyb25tZW50XG5cbiAgICAgICAgICAgIC8vIFN0b3JlIG51bWJlciBvZiBjaGFubmVscyBiZWZvcmUgcmVzaXppbmdcbiAgICAgICAgICAgIGxldCBudW1DaGFubmVscyA9IHRoaXMuY2hhbm5lbHM7XG5cbiAgICAgICAgICAgIC8vIENyZWF0ZSBjYW52YXMgb2JqZWN0IGZvciB0aGlzIGltYWdlXG4gICAgICAgICAgICBsZXQgY2FudmFzID0gdGhpcy50b0NhbnZhcygpO1xuXG4gICAgICAgICAgICAvLyBBY3R1YWxseSBwZXJmb3JtIHJlc2l6aW5nIHVzaW5nIHRoZSBjYW52YXMgQVBJXG4gICAgICAgICAgICBjb25zdCBjdHggPSBjcmVhdGVDYW52YXNGdW5jdGlvbih3aWR0aCwgaGVpZ2h0KS5nZXRDb250ZXh0KCcyZCcpO1xuXG4gICAgICAgICAgICAvLyBEcmF3IGltYWdlIHRvIGNvbnRleHQsIHJlc2l6aW5nIGluIHRoZSBwcm9jZXNzXG4gICAgICAgICAgICBjdHguZHJhd0ltYWdlKGNhbnZhcywgMCwgMCwgd2lkdGgsIGhlaWdodCk7XG5cbiAgICAgICAgICAgIC8vIENyZWF0ZSBpbWFnZSBmcm9tIHRoZSByZXNpemVkIGRhdGFcbiAgICAgICAgICAgIGxldCByZXNpemVkSW1hZ2UgPSBuZXcgUmF3SW1hZ2UoY3R4LmdldEltYWdlRGF0YSgwLCAwLCB3aWR0aCwgaGVpZ2h0KS5kYXRhLCB3aWR0aCwgaGVpZ2h0LCA0KTtcblxuICAgICAgICAgICAgLy8gQ29udmVydCBiYWNrIHNvIHRoYXQgaW1hZ2UgaGFzIHRoZSBzYW1lIG51bWJlciBvZiBjaGFubmVscyBhcyBiZWZvcmVcbiAgICAgICAgICAgIHJldHVybiByZXNpemVkSW1hZ2UuY29udmVydChudW1DaGFubmVscyk7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIENyZWF0ZSBzaGFycCBpbWFnZSBmcm9tIHJhdyBkYXRhLCBhbmQgcmVzaXplXG4gICAgICAgICAgICBsZXQgaW1nID0gc2hhcnAodGhpcy5kYXRhLCB7XG4gICAgICAgICAgICAgICAgcmF3OiB7XG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiB0aGlzLndpZHRoLFxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IHRoaXMuaGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICBjaGFubmVsczogdGhpcy5jaGFubmVsc1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBzd2l0Y2ggKHJlc2FtcGxlTWV0aG9kKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnYm94JzpcbiAgICAgICAgICAgICAgICBjYXNlICdoYW1taW5nJzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc2FtcGxlTWV0aG9kID09PSAnYm94JyB8fCByZXNhbXBsZU1ldGhvZCA9PT0gJ2hhbW1pbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYFJlc2FtcGxpbmcgbWV0aG9kICR7cmVzYW1wbGVNZXRob2R9IGlzIG5vdCB5ZXQgc3VwcG9ydGVkLiBVc2luZyBiaWxpbmVhciBpbnN0ZWFkLmApO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzYW1wbGVNZXRob2QgPSAnYmlsaW5lYXInO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjYXNlICduZWFyZXN0JzpcbiAgICAgICAgICAgICAgICBjYXNlICdiaWxpbmVhcic6XG4gICAgICAgICAgICAgICAgY2FzZSAnYmljdWJpYyc6XG4gICAgICAgICAgICAgICAgICAgIC8vIFBlcmZvcm0gcmVzaXppbmcgdXNpbmcgYWZmaW5lIHRyYW5zZm9ybS4gXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgbWF0Y2hlcyBob3cgdGhlIHB5dGhvbiBQaWxsb3cgbGlicmFyeSBkb2VzIGl0LlxuICAgICAgICAgICAgICAgICAgICBpbWcgPSBpbWcuYWZmaW5lKFt3aWR0aCAvIHRoaXMud2lkdGgsIDAsIDAsIGhlaWdodCAvIHRoaXMuaGVpZ2h0XSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJwb2xhdG9yOiByZXNhbXBsZU1ldGhvZFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlICdsYW5jem9zJzpcbiAgICAgICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3B5dGhvbi1waWxsb3cvUGlsbG93L2Rpc2N1c3Npb25zLzU1MTlcbiAgICAgICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2xvdmVsbC9zaGFycC9ibG9iL21haW4vZG9jcy9hcGktcmVzaXplLm1kXG4gICAgICAgICAgICAgICAgICAgIGltZyA9IGltZy5yZXNpemUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGgsIGhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpdDogJ2ZpbGwnLFxuICAgICAgICAgICAgICAgICAgICAgICAga2VybmVsOiAnbGFuY3pvczMnLCAvLyBQSUwgTGFuY3pvcyB1c2VzIGEga2VybmVsIHNpemUgb2YgMyBcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBSZXNhbXBsaW5nIG1ldGhvZCAke3Jlc2FtcGxlTWV0aG9kfSBpcyBub3Qgc3VwcG9ydGVkLmApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgbG9hZEltYWdlRnVuY3Rpb24oaW1nKTtcbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgYXN5bmMgcGFkKFtsZWZ0LCByaWdodCwgdG9wLCBib3R0b21dKSB7XG4gICAgICAgIGxlZnQgPSBNYXRoLm1heChsZWZ0LCAwKTtcbiAgICAgICAgcmlnaHQgPSBNYXRoLm1heChyaWdodCwgMCk7XG4gICAgICAgIHRvcCA9IE1hdGgubWF4KHRvcCwgMCk7XG4gICAgICAgIGJvdHRvbSA9IE1hdGgubWF4KGJvdHRvbSwgMCk7XG5cbiAgICAgICAgaWYgKGxlZnQgPT09IDAgJiYgcmlnaHQgPT09IDAgJiYgdG9wID09PSAwICYmIGJvdHRvbSA9PT0gMCkge1xuICAgICAgICAgICAgLy8gTm8gcGFkZGluZyBuZWVkZWRcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKEJST1dTRVJfRU5WKSB7XG4gICAgICAgICAgICAvLyBTdG9yZSBudW1iZXIgb2YgY2hhbm5lbHMgYmVmb3JlIHBhZGRpbmdcbiAgICAgICAgICAgIGxldCBudW1DaGFubmVscyA9IHRoaXMuY2hhbm5lbHM7XG5cbiAgICAgICAgICAgIC8vIENyZWF0ZSBjYW52YXMgb2JqZWN0IGZvciB0aGlzIGltYWdlXG4gICAgICAgICAgICBsZXQgY2FudmFzID0gdGhpcy50b0NhbnZhcygpO1xuXG4gICAgICAgICAgICBsZXQgbmV3V2lkdGggPSB0aGlzLndpZHRoICsgbGVmdCArIHJpZ2h0O1xuICAgICAgICAgICAgbGV0IG5ld0hlaWdodCA9IHRoaXMuaGVpZ2h0ICsgdG9wICsgYm90dG9tO1xuXG4gICAgICAgICAgICAvLyBDcmVhdGUgYSBuZXcgY2FudmFzIG9mIHRoZSBkZXNpcmVkIHNpemUuXG4gICAgICAgICAgICBjb25zdCBjdHggPSBjcmVhdGVDYW52YXNGdW5jdGlvbihuZXdXaWR0aCwgbmV3SGVpZ2h0KS5nZXRDb250ZXh0KCcyZCcpO1xuXG4gICAgICAgICAgICAvLyBEcmF3IGltYWdlIHRvIGNvbnRleHQsIHBhZGRpbmcgaW4gdGhlIHByb2Nlc3NcbiAgICAgICAgICAgIGN0eC5kcmF3SW1hZ2UoY2FudmFzLFxuICAgICAgICAgICAgICAgIDAsIDAsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0LFxuICAgICAgICAgICAgICAgIGxlZnQsIHRvcCwgbmV3V2lkdGgsIG5ld0hlaWdodFxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgLy8gQ3JlYXRlIGltYWdlIGZyb20gdGhlIHBhZGRlZCBkYXRhXG4gICAgICAgICAgICBsZXQgcGFkZGVkSW1hZ2UgPSBuZXcgUmF3SW1hZ2UoXG4gICAgICAgICAgICAgICAgY3R4LmdldEltYWdlRGF0YSgwLCAwLCBuZXdXaWR0aCwgbmV3SGVpZ2h0KS5kYXRhLFxuICAgICAgICAgICAgICAgIG5ld1dpZHRoLCBuZXdIZWlnaHQsIDQpO1xuXG4gICAgICAgICAgICAvLyBDb252ZXJ0IGJhY2sgc28gdGhhdCBpbWFnZSBoYXMgdGhlIHNhbWUgbnVtYmVyIG9mIGNoYW5uZWxzIGFzIGJlZm9yZVxuICAgICAgICAgICAgcmV0dXJuIHBhZGRlZEltYWdlLmNvbnZlcnQobnVtQ2hhbm5lbHMpO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgaW1nID0gc2hhcnAodGhpcy5kYXRhLCB7XG4gICAgICAgICAgICAgICAgcmF3OiB7XG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiB0aGlzLndpZHRoLFxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IHRoaXMuaGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICBjaGFubmVsczogdGhpcy5jaGFubmVsc1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pLmV4dGVuZCh7IGxlZnQsIHJpZ2h0LCB0b3AsIGJvdHRvbSB9KTtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCBsb2FkSW1hZ2VGdW5jdGlvbihpbWcpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYXN5bmMgY2VudGVyX2Nyb3AoY3JvcF93aWR0aCwgY3JvcF9oZWlnaHQpIHtcbiAgICAgICAgLy8gSWYgdGhlIGltYWdlIGlzIGFscmVhZHkgdGhlIGRlc2lyZWQgc2l6ZSwgcmV0dXJuIGl0XG4gICAgICAgIGlmICh0aGlzLndpZHRoID09PSBjcm9wX3dpZHRoICYmIHRoaXMuaGVpZ2h0ID09PSBjcm9wX2hlaWdodCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEZXRlcm1pbmUgYm91bmRzIG9mIHRoZSBpbWFnZSBpbiB0aGUgbmV3IGNhbnZhc1xuICAgICAgICBsZXQgd2lkdGhfb2Zmc2V0ID0gKHRoaXMud2lkdGggLSBjcm9wX3dpZHRoKSAvIDI7XG4gICAgICAgIGxldCBoZWlnaHRfb2Zmc2V0ID0gKHRoaXMuaGVpZ2h0IC0gY3JvcF9oZWlnaHQpIC8gMjtcblxuXG4gICAgICAgIGlmIChCUk9XU0VSX0VOVikge1xuICAgICAgICAgICAgLy8gU3RvcmUgbnVtYmVyIG9mIGNoYW5uZWxzIGJlZm9yZSByZXNpemluZ1xuICAgICAgICAgICAgbGV0IG51bUNoYW5uZWxzID0gdGhpcy5jaGFubmVscztcblxuICAgICAgICAgICAgLy8gQ3JlYXRlIGNhbnZhcyBvYmplY3QgZm9yIHRoaXMgaW1hZ2VcbiAgICAgICAgICAgIGxldCBjYW52YXMgPSB0aGlzLnRvQ2FudmFzKCk7XG5cbiAgICAgICAgICAgIC8vIENyZWF0ZSBhIG5ldyBjYW52YXMgb2YgdGhlIGRlc2lyZWQgc2l6ZS4gVGhpcyBpcyBuZWVkZWQgc2luY2UgaWYgdGhlIFxuICAgICAgICAgICAgLy8gaW1hZ2UgaXMgdG9vIHNtYWxsLCB3ZSBuZWVkIHRvIHBhZCBpdCB3aXRoIGJsYWNrIHBpeGVscy5cbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IGNyZWF0ZUNhbnZhc0Z1bmN0aW9uKGNyb3Bfd2lkdGgsIGNyb3BfaGVpZ2h0KS5nZXRDb250ZXh0KCcyZCcpO1xuXG4gICAgICAgICAgICBsZXQgc291cmNlWCA9IDA7XG4gICAgICAgICAgICBsZXQgc291cmNlWSA9IDA7XG4gICAgICAgICAgICBsZXQgZGVzdFggPSAwO1xuICAgICAgICAgICAgbGV0IGRlc3RZID0gMDtcblxuICAgICAgICAgICAgaWYgKHdpZHRoX29mZnNldCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgc291cmNlWCA9IHdpZHRoX29mZnNldDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZGVzdFggPSAtd2lkdGhfb2Zmc2V0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaGVpZ2h0X29mZnNldCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgc291cmNlWSA9IGhlaWdodF9vZmZzZXQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRlc3RZID0gLWhlaWdodF9vZmZzZXQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIERyYXcgaW1hZ2UgdG8gY29udGV4dCwgY3JvcHBpbmcgaW4gdGhlIHByb2Nlc3NcbiAgICAgICAgICAgIGN0eC5kcmF3SW1hZ2UoY2FudmFzLFxuICAgICAgICAgICAgICAgIHNvdXJjZVgsIHNvdXJjZVksIGNyb3Bfd2lkdGgsIGNyb3BfaGVpZ2h0LFxuICAgICAgICAgICAgICAgIGRlc3RYLCBkZXN0WSwgY3JvcF93aWR0aCwgY3JvcF9oZWlnaHRcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIC8vIENyZWF0ZSBpbWFnZSBmcm9tIHRoZSByZXNpemVkIGRhdGFcbiAgICAgICAgICAgIGxldCByZXNpemVkSW1hZ2UgPSBuZXcgUmF3SW1hZ2UoY3R4LmdldEltYWdlRGF0YSgwLCAwLCBjcm9wX3dpZHRoLCBjcm9wX2hlaWdodCkuZGF0YSwgY3JvcF93aWR0aCwgY3JvcF9oZWlnaHQsIDQpO1xuXG4gICAgICAgICAgICAvLyBDb252ZXJ0IGJhY2sgc28gdGhhdCBpbWFnZSBoYXMgdGhlIHNhbWUgbnVtYmVyIG9mIGNoYW5uZWxzIGFzIGJlZm9yZVxuICAgICAgICAgICAgcmV0dXJuIHJlc2l6ZWRJbWFnZS5jb252ZXJ0KG51bUNoYW5uZWxzKTtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gQ3JlYXRlIHNoYXJwIGltYWdlIGZyb20gcmF3IGRhdGFcbiAgICAgICAgICAgIGxldCBpbWcgPSBzaGFycCh0aGlzLmRhdGEsIHtcbiAgICAgICAgICAgICAgICByYXc6IHtcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHRoaXMud2lkdGgsXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogdGhpcy5oZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgIGNoYW5uZWxzOiB0aGlzLmNoYW5uZWxzXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmICh3aWR0aF9vZmZzZXQgPj0gMCAmJiBoZWlnaHRfb2Zmc2V0ID49IDApIHtcbiAgICAgICAgICAgICAgICAvLyBDcm9wcGVkIGltYWdlIGxpZXMgZW50aXJlbHkgd2l0aGluIHRoZSBvcmlnaW5hbCBpbWFnZVxuICAgICAgICAgICAgICAgIGltZyA9IGltZy5leHRyYWN0KHtcbiAgICAgICAgICAgICAgICAgICAgbGVmdDogTWF0aC5mbG9vcih3aWR0aF9vZmZzZXQpLFxuICAgICAgICAgICAgICAgICAgICB0b3A6IE1hdGguZmxvb3IoaGVpZ2h0X29mZnNldCksXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiBjcm9wX3dpZHRoLFxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGNyb3BfaGVpZ2h0LFxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHdpZHRoX29mZnNldCA8PSAwICYmIGhlaWdodF9vZmZzZXQgPD0gMCkge1xuICAgICAgICAgICAgICAgIC8vIENyb3BwZWQgaW1hZ2UgbGllcyBlbnRpcmVseSBvdXRzaWRlIHRoZSBvcmlnaW5hbCBpbWFnZSxcbiAgICAgICAgICAgICAgICAvLyBzbyB3ZSBhZGQgcGFkZGluZ1xuICAgICAgICAgICAgICAgIGxldCB0b3AgPSBNYXRoLmZsb29yKC1oZWlnaHRfb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBsZXQgbGVmdCA9IE1hdGguZmxvb3IoLXdpZHRoX29mZnNldCk7XG4gICAgICAgICAgICAgICAgaW1nID0gaW1nLmV4dGVuZCh7XG4gICAgICAgICAgICAgICAgICAgIHRvcDogdG9wLFxuICAgICAgICAgICAgICAgICAgICBsZWZ0OiBsZWZ0LFxuXG4gICAgICAgICAgICAgICAgICAgIC8vIEVuc3VyZXMgdGhlIHJlc3VsdGluZyBpbWFnZSBoYXMgdGhlIGRlc2lyZWQgZGltZW5zaW9uc1xuICAgICAgICAgICAgICAgICAgICByaWdodDogY3JvcF93aWR0aCAtIHRoaXMud2lkdGggLSBsZWZ0LFxuICAgICAgICAgICAgICAgICAgICBib3R0b206IGNyb3BfaGVpZ2h0IC0gdGhpcy5oZWlnaHQgLSB0b3AsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIENyb3BwZWQgaW1hZ2UgbGllcyBwYXJ0aWFsbHkgb3V0c2lkZSB0aGUgb3JpZ2luYWwgaW1hZ2UuXG4gICAgICAgICAgICAgICAgLy8gV2UgZmlyc3QgcGFkLCB0aGVuIGNyb3AuXG5cbiAgICAgICAgICAgICAgICBsZXQgeV9wYWRkaW5nID0gWzAsIDBdO1xuICAgICAgICAgICAgICAgIGxldCB5X2V4dHJhY3QgPSAwO1xuICAgICAgICAgICAgICAgIGlmIChoZWlnaHRfb2Zmc2V0IDwgMCkge1xuICAgICAgICAgICAgICAgICAgICB5X3BhZGRpbmdbMF0gPSBNYXRoLmZsb29yKC1oZWlnaHRfb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgeV9wYWRkaW5nWzFdID0gY3JvcF9oZWlnaHQgLSB0aGlzLmhlaWdodCAtIHlfcGFkZGluZ1swXTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB5X2V4dHJhY3QgPSBNYXRoLmZsb29yKGhlaWdodF9vZmZzZXQpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGxldCB4X3BhZGRpbmcgPSBbMCwgMF07XG4gICAgICAgICAgICAgICAgbGV0IHhfZXh0cmFjdCA9IDA7XG4gICAgICAgICAgICAgICAgaWYgKHdpZHRoX29mZnNldCA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgeF9wYWRkaW5nWzBdID0gTWF0aC5mbG9vcigtd2lkdGhfb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgeF9wYWRkaW5nWzFdID0gY3JvcF93aWR0aCAtIHRoaXMud2lkdGggLSB4X3BhZGRpbmdbMF07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgeF9leHRyYWN0ID0gTWF0aC5mbG9vcih3aWR0aF9vZmZzZXQpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGltZyA9IGltZy5leHRlbmQoe1xuICAgICAgICAgICAgICAgICAgICB0b3A6IHlfcGFkZGluZ1swXSxcbiAgICAgICAgICAgICAgICAgICAgYm90dG9tOiB5X3BhZGRpbmdbMV0sXG4gICAgICAgICAgICAgICAgICAgIGxlZnQ6IHhfcGFkZGluZ1swXSxcbiAgICAgICAgICAgICAgICAgICAgcmlnaHQ6IHhfcGFkZGluZ1sxXSxcbiAgICAgICAgICAgICAgICB9KS5leHRyYWN0KHtcbiAgICAgICAgICAgICAgICAgICAgbGVmdDogeF9leHRyYWN0LFxuICAgICAgICAgICAgICAgICAgICB0b3A6IHlfZXh0cmFjdCxcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IGNyb3Bfd2lkdGgsXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogY3JvcF9oZWlnaHQsXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IGxvYWRJbWFnZUZ1bmN0aW9uKGltZyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0b0NhbnZhcygpIHtcbiAgICAgICAgLy8gQ2xvbmUsIGFuZCBjb252ZXJ0IGRhdGEgdG8gUkdCQSBiZWZvcmUgZHJhd2luZyB0byBjYW52YXMuXG4gICAgICAgIC8vIFRoaXMgaXMgYmVjYXVzZSB0aGUgY2FudmFzIEFQSSBvbmx5IHN1cHBvcnRzIFJHQkFcbiAgICAgICAgbGV0IGNsb25lZCA9IHRoaXMuY2xvbmUoKS5yZ2JhKCk7XG5cbiAgICAgICAgLy8gQ3JlYXRlIGNhbnZhcyBvYmplY3QgZm9yIHRoZSBjbG9uZWQgaW1hZ2VcbiAgICAgICAgbGV0IGNsb25lZENhbnZhcyA9IGNyZWF0ZUNhbnZhc0Z1bmN0aW9uKGNsb25lZC53aWR0aCwgY2xvbmVkLmhlaWdodCk7XG5cbiAgICAgICAgLy8gRHJhdyBpbWFnZSB0byBjb250ZXh0XG4gICAgICAgIGxldCBkYXRhID0gbmV3IEltYWdlRGF0YUNsYXNzKGNsb25lZC5kYXRhLCBjbG9uZWQud2lkdGgsIGNsb25lZC5oZWlnaHQpO1xuICAgICAgICBjbG9uZWRDYW52YXMuZ2V0Q29udGV4dCgnMmQnKS5wdXRJbWFnZURhdGEoZGF0YSwgMCwgMCk7XG5cbiAgICAgICAgcmV0dXJuIGNsb25lZENhbnZhcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIZWxwZXIgbWV0aG9kIHRvIHVwZGF0ZSB0aGUgaW1hZ2UgZGF0YS5cbiAgICAgKiBAcGFyYW0ge1VpbnQ4Q2xhbXBlZEFycmF5fSBkYXRhIFRoZSBuZXcgaW1hZ2UgZGF0YS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gd2lkdGggVGhlIG5ldyB3aWR0aCBvZiB0aGUgaW1hZ2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCBUaGUgbmV3IGhlaWdodCBvZiB0aGUgaW1hZ2UuXG4gICAgICogQHBhcmFtIHsxfDJ8M3w0fSBjaGFubmVscyBUaGUgbmV3IG51bWJlciBvZiBjaGFubmVscyBvZiB0aGUgaW1hZ2UuXG4gICAgICovXG4gICAgX3VwZGF0ZShkYXRhLCB3aWR0aCwgaGVpZ2h0LCBjaGFubmVscyA9IG51bGwpIHtcbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgaWYgKGNoYW5uZWxzICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmNoYW5uZWxzID0gY2hhbm5lbHM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2xvbmUgdGhlIGltYWdlXG4gICAgICogQHJldHVybnMge1Jhd0ltYWdlfSBUaGUgY2xvbmVkIGltYWdlXG4gICAgICovXG4gICAgY2xvbmUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmF3SW1hZ2UodGhpcy5kYXRhLnNsaWNlKCksIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0LCB0aGlzLmNoYW5uZWxzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIZWxwZXIgbWV0aG9kIGZvciBjb252ZXJ0aW5nIGltYWdlIHRvIGhhdmUgYSBjZXJ0YWluIG51bWJlciBvZiBjaGFubmVsc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBudW1DaGFubmVscyBUaGUgbnVtYmVyIG9mIGNoYW5uZWxzLiBNdXN0IGJlIDEsIDMsIG9yIDQuXG4gICAgICogQHJldHVybnMge1Jhd0ltYWdlfSBgdGhpc2AgdG8gc3VwcG9ydCBjaGFpbmluZy5cbiAgICAgKi9cbiAgICBjb252ZXJ0KG51bUNoYW5uZWxzKSB7XG4gICAgICAgIGlmICh0aGlzLmNoYW5uZWxzID09PSBudW1DaGFubmVscykgcmV0dXJuIHRoaXM7IC8vIEFscmVhZHkgY29ycmVjdCBudW1iZXIgb2YgY2hhbm5lbHNcblxuICAgICAgICBzd2l0Y2ggKG51bUNoYW5uZWxzKSB7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgdGhpcy5ncmF5c2NhbGUoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICB0aGlzLnJnYigpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgIHRoaXMucmdiYSgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvbnZlcnNpb24gZmFpbGVkIGR1ZSB0byB1bnN1cHBvcnRlZCBudW1iZXIgb2YgY2hhbm5lbHM6ICR7dGhpcy5jaGFubmVsc31gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTYXZlIHRoZSBpbWFnZSB0byB0aGUgZ2l2ZW4gcGF0aC4gVGhpcyBtZXRob2QgaXMgb25seSBhdmFpbGFibGUgaW4gZW52aXJvbm1lbnRzIHdpdGggYWNjZXNzIHRvIHRoZSBGaWxlU3lzdGVtLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfEJ1ZmZlcnxVUkx9IHBhdGggVGhlIHBhdGggdG8gc2F2ZSB0aGUgaW1hZ2UgdG8uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFttaW1lPSdpbWFnZS9wbmcnXSBUaGUgbWltZSB0eXBlIG9mIHRoZSBpbWFnZS5cbiAgICAgKi9cbiAgICBzYXZlKHBhdGgsIG1pbWUgPSAnaW1hZ2UvcG5nJykge1xuICAgICAgICBpZiAoIWVudi51c2VGUykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gc2F2ZSB0aGUgaW1hZ2UgYmVjYXVzZSBmaWxlc3lzdGVtIGlzIGRpc2FibGVkIGluIHRoaXMgZW52aXJvbm1lbnQuJylcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBjYW52YXMgPSB0aGlzLnRvQ2FudmFzKCk7XG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IGNhbnZhcy50b0J1ZmZlcihtaW1lKTtcbiAgICAgICAgZnMud3JpdGVGaWxlU3luYyhwYXRoLCBidWZmZXIpO1xuICAgIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@xenova/transformers/src/utils/image.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@xenova/transformers/src/utils/maths.js":
/*!**************************************************************!*\
  !*** ./node_modules/@xenova/transformers/src/utils/maths.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FFT: function() { return /* binding */ FFT; },\n/* harmony export */   cos_sim: function() { return /* binding */ cos_sim; },\n/* harmony export */   dot: function() { return /* binding */ dot; },\n/* harmony export */   getTopItems: function() { return /* binding */ getTopItems; },\n/* harmony export */   interpolate_data: function() { return /* binding */ interpolate_data; },\n/* harmony export */   log_softmax: function() { return /* binding */ log_softmax; },\n/* harmony export */   magnitude: function() { return /* binding */ magnitude; },\n/* harmony export */   max: function() { return /* binding */ max; },\n/* harmony export */   medianFilter: function() { return /* binding */ medianFilter; },\n/* harmony export */   min: function() { return /* binding */ min; },\n/* harmony export */   rfftfreq: function() { return /* binding */ rfftfreq; },\n/* harmony export */   round: function() { return /* binding */ round; },\n/* harmony export */   softmax: function() { return /* binding */ softmax; },\n/* harmony export */   transpose_data: function() { return /* binding */ transpose_data; }\n/* harmony export */ });\n\n/**\n * @file Helper module for mathematical processing. \n * \n * These functions and classes are only used internally, \n * meaning an end-user shouldn't need to access anything here.\n * \n * @module utils/maths\n */\n\n/**\n * @typedef {Int8Array | Uint8Array | Uint8ClampedArray | Int16Array | Uint16Array | Int32Array | Uint32Array | Float32Array | Float64Array} TypedArray\n * @typedef {BigInt64Array | BigUint64Array} BigTypedArray\n * @typedef {TypedArray | BigTypedArray} AnyTypedArray\n */\n\n/**\n * @param {TypedArray} input\n */\nfunction interpolate_data(input, [in_channels, in_height, in_width], [out_height, out_width], mode = 'bilinear', align_corners = false) {\n    // TODO use mode and align_corners\n\n    // Output image dimensions\n    const x_scale = out_width / in_width;\n    const y_scale = out_height / in_height;\n\n    // Output image\n    // @ts-ignore\n    const out_img = new input.constructor(out_height * out_width * in_channels);\n\n    // Pre-calculate strides\n    const inStride = in_height * in_width;\n    const outStride = out_height * out_width;\n\n    for (let i = 0; i < out_height; ++i) {\n        for (let j = 0; j < out_width; ++j) {\n            // Calculate output offset\n            const outOffset = i * out_width + j;\n\n            // Calculate input pixel coordinates\n            const x = (j + 0.5) / x_scale - 0.5;\n            const y = (i + 0.5) / y_scale - 0.5;\n\n            // Calculate the four nearest input pixels\n            // We also check if the input pixel coordinates are within the image bounds\n            let x1 = Math.floor(x);\n            let y1 = Math.floor(y);\n            const x2 = Math.min(x1 + 1, in_width - 1);\n            const y2 = Math.min(y1 + 1, in_height - 1);\n\n            x1 = Math.max(x1, 0);\n            y1 = Math.max(y1, 0);\n\n\n            // Calculate the fractional distances between the input pixel and the four nearest pixels\n            const s = x - x1;\n            const t = y - y1;\n\n            // Perform bilinear interpolation\n            const w1 = (1 - s) * (1 - t);\n            const w2 = s * (1 - t);\n            const w3 = (1 - s) * t;\n            const w4 = s * t;\n\n            // Calculate the four nearest input pixel indices\n            const yStride = y1 * in_width;\n            const xStride = y2 * in_width;\n            const idx1 = yStride + x1;\n            const idx2 = yStride + x2;\n            const idx3 = xStride + x1;\n            const idx4 = xStride + x2;\n\n            for (let k = 0; k < in_channels; ++k) {\n                // Calculate channel offset\n                const cOffset = k * inStride;\n\n                out_img[k * outStride + outOffset] =\n                    w1 * input[cOffset + idx1] +\n                    w2 * input[cOffset + idx2] +\n                    w3 * input[cOffset + idx3] +\n                    w4 * input[cOffset + idx4];\n            }\n        }\n    }\n\n    return out_img;\n}\n\n\n/**\n * Helper method to transpose a `AnyTypedArray` directly\n * @param {T} array \n * @template {AnyTypedArray} T \n * @param {number[]} dims \n * @param {number[]} axes \n * @returns {[T, number[]]} The transposed array and the new shape.\n */\nfunction transpose_data(array, dims, axes) {\n    // Calculate the new shape of the transposed array\n    // and the stride of the original array\n    const shape = new Array(axes.length);\n    const stride = new Array(axes.length);\n\n    for (let i = axes.length - 1, s = 1; i >= 0; --i) {\n        stride[i] = s;\n        shape[i] = dims[axes[i]];\n        s *= shape[i];\n    }\n\n    // Precompute inverse mapping of stride\n    const invStride = axes.map((_, i) => stride[axes.indexOf(i)]);\n\n    // Create the transposed array with the new shape\n    // @ts-ignore\n    const transposedData = new array.constructor(array.length);\n\n    // Transpose the original array to the new array\n    for (let i = 0; i < array.length; ++i) {\n        let newIndex = 0;\n        for (let j = dims.length - 1, k = i; j >= 0; --j) {\n            newIndex += (k % dims[j]) * invStride[j];\n            k = Math.floor(k / dims[j]);\n        }\n        transposedData[newIndex] = array[i];\n    }\n\n    return [transposedData, shape];\n}\n\n\n/**\n * Compute the softmax of an array of numbers.\n *\n * @param {number[]} arr The array of numbers to compute the softmax of.\n * @returns {number[]} The softmax array.\n */\nfunction softmax(arr) {\n    // Compute the maximum value in the array\n    const maxVal = max(arr)[0];\n\n    // Compute the exponentials of the array values\n    const exps = arr.map(x => Math.exp(x - maxVal));\n\n    // Compute the sum of the exponentials\n    const sumExps = exps.reduce((acc, val) => acc + val, 0);\n\n    // Compute the softmax values\n    const softmaxArr = exps.map(x => x / sumExps);\n\n    return softmaxArr;\n}\n\n/**\n * Calculates the logarithm of the softmax function for the input array.\n * @param {number[]} arr The input array to calculate the log_softmax function for.\n * @returns {any} The resulting log_softmax array.\n */\nfunction log_softmax(arr) {\n    // Compute the softmax values\n    const softmaxArr = softmax(arr);\n\n    // Apply log formula to each element\n    const logSoftmaxArr = softmaxArr.map(x => Math.log(x));\n\n    return logSoftmaxArr;\n}\n\n/**\n * Calculates the dot product of two arrays.\n * @param {number[]} arr1 The first array.\n * @param {number[]} arr2 The second array.\n * @returns {number} The dot product of arr1 and arr2.\n */\nfunction dot(arr1, arr2) {\n    return arr1.reduce((acc, val, i) => acc + val * arr2[i], 0);\n}\n\n\n/**\n * Get the top k items from an iterable, sorted by descending order\n *\n * @param {Array} items The items to be sorted\n * @param {number} [top_k=0] The number of top items to return (default: 0 = return all)\n * @returns {Array} The top k items, sorted by descending order\n */\nfunction getTopItems(items, top_k = 0) {\n    // if top == 0, return all\n\n    items = Array.from(items)\n        .map((x, i) => [i, x])            // Get indices ([index, score])\n        .sort((a, b) => b[1] - a[1])      // Sort by log probabilities\n\n    if (top_k > 0) {\n        items = items.slice(0, top_k);    // Get top k items\n    }\n\n    return items\n}\n\n/**\n * Computes the cosine similarity between two arrays.\n *\n * @param {number[]} arr1 The first array.\n * @param {number[]} arr2 The second array.\n * @returns {number} The cosine similarity between the two arrays.\n */\nfunction cos_sim(arr1, arr2) {\n    // Calculate dot product of the two arrays\n    const dotProduct = dot(arr1, arr2);\n\n    // Calculate the magnitude of the first array\n    const magnitudeA = magnitude(arr1);\n\n    // Calculate the magnitude of the second array\n    const magnitudeB = magnitude(arr2);\n\n    // Calculate the cosine similarity\n    const cosineSimilarity = dotProduct / (magnitudeA * magnitudeB);\n\n    return cosineSimilarity;\n}\n\n/**\n * Calculates the magnitude of a given array.\n * @param {number[]} arr The array to calculate the magnitude of.\n * @returns {number} The magnitude of the array.\n */\nfunction magnitude(arr) {\n    return Math.sqrt(arr.reduce((acc, val) => acc + val * val, 0));\n}\n\n\n/**\n * Returns the value and index of the minimum element in an array.\n * @param {number[]} arr array of numbers.\n * @returns {number[]} the value and index of the minimum element, of the form: [valueOfMin, indexOfMin]\n * @throws {Error} If array is empty.\n */\nfunction min(arr) {\n    if (arr.length === 0) throw Error('Array must not be empty');\n    let min = arr[0];\n    let indexOfMin = 0;\n    for (let i = 1; i < arr.length; ++i) {\n        if (arr[i] < min) {\n            min = arr[i];\n            indexOfMin = i;\n        }\n    }\n    return [min, indexOfMin];\n}\n\n\n/**\n * Returns the value and index of the maximum element in an array.\n * @param {number[]} arr array of numbers.\n * @returns {number[]} the value and index of the maximum element, of the form: [valueOfMax, indexOfMax]\n * @throws {Error} If array is empty.\n */\nfunction max(arr) {\n    if (arr.length === 0) throw Error('Array must not be empty');\n    let max = arr[0];\n    let indexOfMax = 0;\n    for (let i = 1; i < arr.length; ++i) {\n        if (arr[i] > max) {\n            max = arr[i];\n            indexOfMax = i;\n        }\n    }\n    return [max, indexOfMax];\n}\n\n/**\n * Return the Discrete Fourier Transform sample frequencies.\n * \n * Code adapted from https://github.com/numpy/numpy/blob/25908cacd19915bf3ddd659c28be28a41bd97a54/numpy/fft/helper.py#L173-L221\n * Original Python doc: https://numpy.org/doc/stable/reference/generated/numpy.fft.rfftfreq.html\n * @example\n * rfftfreq(400, 1 / 16000) // (201) [0, 40, 80, 120, 160, 200, ..., 8000]\n * @param {number} n Window length\n * @param {number} [d = 1.0] Sample spacing (inverse of the sampling rate). Defaults to 1.\n * @throws {TypeError} If n is not an integer.\n * @returns {number[]} Array of length `Math.floor(n / 2) + 1;` containing the sample frequencies.\n */\nfunction rfftfreq(n, d = 1.0) {\n    if (!Number.isInteger(n)) {\n        throw new TypeError(`n should be an integer, but ${n} given.`);\n    }\n    const val = 1.0 / (n * d);\n    const len = Math.floor(n / 2) + 1;\n    const results = new Array(len);\n    for (let i = 0; i < len; ++i) {\n        results[i] = i * val;\n    }\n    return results;\n}\n\n/**\n * FFT class provides functionality for performing Fast Fourier Transform on arrays\n * Code adapted from https://www.npmjs.com/package/fft.js\n */\nclass FFT {\n    /**\n     * @param {number} size The size of the input array. Must be a power of two and bigger than 1.\n     * @throws {Error} FFT size must be a power of two and bigger than 1.\n     */\n    constructor(size) {\n        this.size = size | 0; // convert to a 32-bit signed integer\n        if (this.size <= 1 || (this.size & (this.size - 1)) !== 0)\n            throw new Error('FFT size must be a power of two and bigger than 1');\n\n        this._csize = size << 1;\n\n        this.table = new Float32Array(this.size * 2);\n        for (let i = 0; i < this.table.length; i += 2) {\n            const angle = Math.PI * i / this.size;\n            this.table[i] = Math.cos(angle);\n            this.table[i + 1] = -Math.sin(angle);\n        }\n\n        // Find size's power of two\n        let power = 0;\n        for (let t = 1; this.size > t; t <<= 1)\n            ++power;\n\n        // Calculate initial step's width:\n        //   * If we are full radix-4, it is 2x smaller to give inital len=8\n        //   * Otherwise it is the same as `power` to give len=4\n        this._width = power % 2 === 0 ? power - 1 : power;\n\n        // Pre-compute bit-reversal patterns\n        this._bitrev = new Int32Array(1 << this._width);\n        for (let j = 0; j < this._bitrev.length; ++j) {\n            this._bitrev[j] = 0;\n            for (let shift = 0; shift < this._width; shift += 2) {\n                const revShift = this._width - shift - 2;\n                this._bitrev[j] |= ((j >>> shift) & 3) << revShift;\n            }\n        }\n    }\n\n    /**\n     * Create a complex number array with size `2 * size`\n     *\n     * @returns {Float32Array} A complex number array with size `2 * size`\n     */\n    createComplexArray() {\n        return new Float32Array(this._csize);\n    }\n\n    /**\n     * Converts a complex number representation stored in a Float32Array to an array of real numbers.\n     * \n     * @param {Float32Array} complex The complex number representation to be converted.\n     * @param {number[]} [storage] An optional array to store the result in.\n     * @returns {number[]} An array of real numbers representing the input complex number representation.\n     */\n    fromComplexArray(complex, storage) {\n        const res = storage || new Array(complex.length >>> 1);\n        for (let i = 0; i < complex.length; i += 2)\n            res[i >>> 1] = complex[i];\n        return res;\n    }\n\n    /**\n     * Convert a real-valued input array to a complex-valued output array.\n     * @param {Float32Array} input The real-valued input array.\n     * @param {Float32Array} [storage] Optional buffer to store the output array.\n     * @returns {Float32Array} The complex-valued output array.\n     */\n    toComplexArray(input, storage) {\n        const res = storage || this.createComplexArray();\n        for (let i = 0; i < res.length; i += 2) {\n            res[i] = input[i >>> 1];\n            res[i + 1] = 0;\n        }\n        return res;\n    }\n\n    /**\n     * Completes the spectrum by adding its mirrored negative frequency components.\n     * @param {Float32Array} spectrum The input spectrum.\n     * @returns {void}\n     */\n    completeSpectrum(spectrum) {\n        const size = this._csize;\n        const half = size >>> 1;\n        for (let i = 2; i < half; i += 2) {\n            spectrum[size - i] = spectrum[i];\n            spectrum[size - i + 1] = -spectrum[i + 1];\n        }\n    }\n\n    /**\n     * Performs a Fast Fourier Transform (FFT) on the given input data and stores the result in the output buffer.\n     * \n     * @param {Float32Array} out The output buffer to store the result.\n     * @param {Float32Array} data The input data to transform.\n     * \n     * @throws {Error} Input and output buffers must be different.\n     * \n     * @returns {void}\n     */\n    transform(out, data) {\n        if (out === data)\n            throw new Error('Input and output buffers must be different');\n\n        this._transform4(out, data, 1 /* DONE */);\n    }\n\n    /**\n     * Performs a real-valued forward FFT on the given input buffer and stores the result in the given output buffer.\n     * The input buffer must contain real values only, while the output buffer will contain complex values. The input and\n     * output buffers must be different.\n     *\n     * @param {Float32Array} out The output buffer.\n     * @param {Float32Array} data The input buffer containing real values.\n     *\n     * @throws {Error} If the input and output buffers are the same.\n     */\n    realTransform(out, data) {\n        if (out === data)\n            throw new Error('Input and output buffers must be different');\n\n        this._realTransform4(out, data, 1 /* DONE */);\n    }\n\n    /**\n     * Performs an inverse FFT transformation on the given `data` array, and stores the result in `out`.\n     * The `out` array must be a different buffer than the `data` array. The `out` array will contain the\n     * result of the transformation. The `data` array will not be modified.\n     * \n     * @param {Float32Array} out The output buffer for the transformed data.\n     * @param {Float32Array} data The input data to transform.\n     * @throws {Error} If `out` and `data` refer to the same buffer.\n     * @returns {void}\n     */\n    inverseTransform(out, data) {\n        if (out === data)\n            throw new Error('Input and output buffers must be different');\n\n        this._transform4(out, data, -1 /* DONE */);\n        for (let i = 0; i < out.length; ++i)\n            out[i] /= this.size;\n    }\n\n    /**\n     * Performs a radix-4 implementation of a discrete Fourier transform on a given set of data.\n     *\n     * @param {Float32Array} out The output buffer for the transformed data.\n     * @param {Float32Array} data The input buffer of data to be transformed.\n     * @param {number} inv A scaling factor to apply to the transform.\n     * @returns {void}\n     */\n    _transform4(out, data, inv) {\n        // radix-4 implementation\n\n        const size = this._csize;\n\n        // Initial step (permute and transform)\n        const width = this._width;\n        let step = 1 << width;\n        let len = (size / step) << 1;\n\n        let outOff;\n        let t;\n        let bitrev = this._bitrev;\n        if (len === 4) {\n            for (outOff = 0, t = 0; outOff < size; outOff += len, ++t) {\n                const off = bitrev[t];\n                this._singleTransform2(data, out, outOff, off, step);\n            }\n        } else {\n            // len === 8\n            for (outOff = 0, t = 0; outOff < size; outOff += len, ++t) {\n                const off = bitrev[t];\n                this._singleTransform4(data, out, outOff, off, step, inv);\n            }\n        }\n\n        // Loop through steps in decreasing order\n        for (step >>= 2; step >= 2; step >>= 2) {\n            len = (size / step) << 1;\n            let quarterLen = len >>> 2;\n\n            // Loop through offsets in the data\n            for (outOff = 0; outOff < size; outOff += len) {\n                // Full case\n                let limit = outOff + quarterLen;\n                for (let i = outOff, k = 0; i < limit; i += 2, k += step) {\n                    const A = i;\n                    const B = A + quarterLen;\n                    const C = B + quarterLen;\n                    const D = C + quarterLen;\n\n                    // Original values\n                    const Ar = out[A];\n                    const Ai = out[A + 1];\n                    const Br = out[B];\n                    const Bi = out[B + 1];\n                    const Cr = out[C];\n                    const Ci = out[C + 1];\n                    const Dr = out[D];\n                    const Di = out[D + 1];\n\n                    const tableBr = this.table[k];\n                    const tableBi = inv * this.table[k + 1];\n                    const MBr = Br * tableBr - Bi * tableBi;\n                    const MBi = Br * tableBi + Bi * tableBr;\n\n                    const tableCr = this.table[2 * k];\n                    const tableCi = inv * this.table[2 * k + 1];\n                    const MCr = Cr * tableCr - Ci * tableCi;\n                    const MCi = Cr * tableCi + Ci * tableCr;\n\n                    const tableDr = this.table[3 * k];\n                    const tableDi = inv * this.table[3 * k + 1];\n                    const MDr = Dr * tableDr - Di * tableDi;\n                    const MDi = Dr * tableDi + Di * tableDr;\n\n                    // Pre-Final values\n                    const T0r = Ar + MCr;\n                    const T0i = Ai + MCi;\n                    const T1r = Ar - MCr;\n                    const T1i = Ai - MCi;\n                    const T2r = MBr + MDr;\n                    const T2i = MBi + MDi;\n                    const T3r = inv * (MBr - MDr);\n                    const T3i = inv * (MBi - MDi);\n\n                    // Final values\n                    out[A] = T0r + T2r;\n                    out[A + 1] = T0i + T2i;\n                    out[B] = T1r + T3i;\n                    out[B + 1] = T1i - T3r;\n                    out[C] = T0r - T2r;\n                    out[C + 1] = T0i - T2i;\n                    out[D] = T1r - T3i;\n                    out[D + 1] = T1i + T3r;\n                }\n            }\n        }\n    }\n\n    /**\n     * Performs a radix-2 implementation of a discrete Fourier transform on a given set of data.\n     *\n     * @param {Float32Array} data The input buffer of data to be transformed.\n     * @param {Float32Array} out The output buffer for the transformed data.\n     * @param {number} outOff The offset at which to write the output data.\n     * @param {number} off The offset at which to begin reading the input data.\n     * @param {number} step The step size for indexing the input data.\n     * @returns {void}\n     */\n    _singleTransform2(data, out, outOff, off, step) {\n        // radix-2 implementation\n        // NOTE: Only called for len=4\n\n        const evenR = data[off];\n        const evenI = data[off + 1];\n        const oddR = data[off + step];\n        const oddI = data[off + step + 1];\n\n        out[outOff] = evenR + oddR;\n        out[outOff + 1] = evenI + oddI;\n        out[outOff + 2] = evenR - oddR;\n        out[outOff + 3] = evenI - oddI;\n    }\n\n    /**\n     * Performs radix-4 transformation on input data of length 8\n     *\n     * @param {Float32Array} data Input data array of length 8\n     * @param {Float32Array} out Output data array of length 8\n     * @param {number} outOff Index of output array to start writing from\n     * @param {number} off Index of input array to start reading from\n     * @param {number} step Step size between elements in input array\n     * @param {number} inv Scaling factor for inverse transform\n     * \n     * @returns {void}\n     */\n    _singleTransform4(data, out, outOff, off, step, inv) {\n        // radix-4\n        // NOTE: Only called for len=8\n        const step2 = step * 2;\n        const step3 = step * 3;\n\n        // Original values\n        const Ar = data[off];\n        const Ai = data[off + 1];\n        const Br = data[off + step];\n        const Bi = data[off + step + 1];\n        const Cr = data[off + step2];\n        const Ci = data[off + step2 + 1];\n        const Dr = data[off + step3];\n        const Di = data[off + step3 + 1];\n\n        // Pre-Final values\n        const T0r = Ar + Cr;\n        const T0i = Ai + Ci;\n        const T1r = Ar - Cr;\n        const T1i = Ai - Ci;\n        const T2r = Br + Dr;\n        const T2i = Bi + Di;\n        const T3r = inv * (Br - Dr);\n        const T3i = inv * (Bi - Di);\n\n        // Final values\n        out[outOff] = T0r + T2r;\n        out[outOff + 1] = T0i + T2i;\n        out[outOff + 2] = T1r + T3i;\n        out[outOff + 3] = T1i - T3r;\n        out[outOff + 4] = T0r - T2r;\n        out[outOff + 5] = T0i - T2i;\n        out[outOff + 6] = T1r - T3i;\n        out[outOff + 7] = T1i + T3r;\n    }\n\n    /**\n     * Real input radix-4 implementation\n     * @param {Float32Array} out Output array for the transformed data\n     * @param {Float32Array} data Input array of real data to be transformed\n     * @param {number} inv The scale factor used to normalize the inverse transform\n     */\n    _realTransform4(out, data, inv) {\n        // Real input radix-4 implementation\n        const size = this._csize;\n\n        // Initial step (permute and transform)\n        const width = this._width;\n        let step = 1 << width;\n        let len = (size / step) << 1;\n\n        var outOff;\n        var t;\n        var bitrev = this._bitrev;\n        if (len === 4) {\n            for (outOff = 0, t = 0; outOff < size; outOff += len, ++t) {\n                const off = bitrev[t];\n                this._singleRealTransform2(data, out, outOff, off >>> 1, step >>> 1);\n            }\n        } else {\n            // len === 8\n            for (outOff = 0, t = 0; outOff < size; outOff += len, ++t) {\n                const off = bitrev[t];\n                this._singleRealTransform4(data, out, outOff, off >>> 1, step >>> 1, inv);\n            }\n        }\n\n        // Loop through steps in decreasing order\n        for (step >>= 2; step >= 2; step >>= 2) {\n            len = (size / step) << 1;\n            const halfLen = len >>> 1;\n            const quarterLen = halfLen >>> 1;\n            const hquarterLen = quarterLen >>> 1;\n\n            // Loop through offsets in the data\n            for (outOff = 0; outOff < size; outOff += len) {\n                for (let i = 0, k = 0; i <= hquarterLen; i += 2, k += step) {\n                    const A = outOff + i;\n                    const B = A + quarterLen;\n                    const C = B + quarterLen;\n                    const D = C + quarterLen;\n\n                    // Original values\n                    const Ar = out[A];\n                    const Ai = out[A + 1];\n                    const Br = out[B];\n                    const Bi = out[B + 1];\n                    const Cr = out[C];\n                    const Ci = out[C + 1];\n                    const Dr = out[D];\n                    const Di = out[D + 1];\n\n                    const tableBr = this.table[k];\n                    const tableBi = inv * this.table[k + 1];\n                    const MBr = Br * tableBr - Bi * tableBi;\n                    const MBi = Br * tableBi + Bi * tableBr;\n\n                    const tableCr = this.table[2 * k];\n                    const tableCi = inv * this.table[2 * k + 1];\n                    const MCr = Cr * tableCr - Ci * tableCi;\n                    const MCi = Cr * tableCi + Ci * tableCr;\n\n                    const tableDr = this.table[3 * k];\n                    const tableDi = inv * this.table[3 * k + 1];\n                    const MDr = Dr * tableDr - Di * tableDi;\n                    const MDi = Dr * tableDi + Di * tableDr;\n\n                    // Pre-Final values\n                    const T0r = Ar + MCr;\n                    const T0i = Ai + MCi;\n                    const T1r = Ar - MCr;\n                    const T1i = Ai - MCi;\n                    const T2r = MBr + MDr;\n                    const T2i = MBi + MDi;\n                    const T3r = inv * (MBr - MDr);\n                    const T3i = inv * (MBi - MDi);\n\n                    // Final values\n                    out[A] = T0r + T2r;\n                    out[A + 1] = T0i + T2i;\n                    out[B] = T1r + T3i;\n                    out[B + 1] = T1i - T3r;\n\n                    // Output final middle point\n                    if (i === 0) {\n                        out[C] = T0r - T2r;\n                        out[C + 1] = T0i - T2i;\n                        continue;\n                    }\n\n                    // Do not overwrite ourselves\n                    if (i === hquarterLen)\n                        continue;\n\n                    const SA = outOff + quarterLen - i;\n                    const SB = outOff + halfLen - i;\n\n                    out[SA] = T1r + -inv * T3i;\n                    out[SA + 1] = -T1i - inv * T3r;\n                    out[SB] = T0r + -inv * T2r;\n                    out[SB + 1] = -T0i + inv * T2i;\n                }\n            }\n        }\n    }\n\n    /**\n     * Performs a single real input radix-2 transformation on the provided data\n     * \n     * @param {Float32Array} data The input data array\n     * @param {Float32Array} out The output data array\n     * @param {number} outOff The output offset\n     * @param {number} off The input offset\n     * @param {number} step The step\n     * \n     * @returns {void}\n     */\n    _singleRealTransform2(data, out, outOff, off, step) {\n        // radix-2 implementation\n        // NOTE: Only called for len=4\n\n        const evenR = data[off];\n        const oddR = data[off + step];\n\n        out[outOff] = evenR + oddR;\n        out[outOff + 1] = 0;\n        out[outOff + 2] = evenR - oddR;\n        out[outOff + 3] = 0;\n    }\n\n    /**\n     * Computes a single real-valued transform using radix-4 algorithm.\n     * This method is only called for len=8.\n     *\n     * @param {Float32Array} data The input data array.\n     * @param {Float32Array} out The output data array.\n     * @param {number} outOff The offset into the output array.\n     * @param {number} off The offset into the input array.\n     * @param {number} step The step size for the input array.\n     * @param {number} inv The value of inverse.\n     */\n    _singleRealTransform4(data, out, outOff, off, step, inv) {\n        // radix-4\n        // NOTE: Only called for len=8\n        const step2 = step * 2;\n        const step3 = step * 3;\n\n        // Original values\n        const Ar = data[off];\n        const Br = data[off + step];\n        const Cr = data[off + step2];\n        const Dr = data[off + step3];\n\n        // Pre-Final values\n        const T0r = Ar + Cr;\n        const T1r = Ar - Cr;\n        const T2r = Br + Dr;\n        const T3r = inv * (Br - Dr);\n\n        // Final values\n        out[outOff] = T0r + T2r;\n        out[outOff + 1] = 0;\n        out[outOff + 2] = T1r;\n        out[outOff + 3] = -T3r;\n        out[outOff + 4] = T0r - T2r;\n        out[outOff + 5] = 0;\n        out[outOff + 6] = T1r;\n        out[outOff + 7] = T3r;\n    }\n}\n\n/**\n * Performs median filter on the provided data. Padding is done by mirroring the data.\n * @param {AnyTypedArray} data The input array\n * @param {number} windowSize The window size\n */\nfunction medianFilter(data, windowSize) {\n\n    if (windowSize % 2 === 0 || windowSize <= 0) {\n        throw new Error('Window size must be a positive odd number');\n    }\n\n    // @ts-ignore\n    const outputArray = new data.constructor(data.length);\n\n    // @ts-ignore\n    const buffer = new data.constructor(windowSize); // Reusable array for storing values\n\n    const halfWindowSize = Math.floor(windowSize / 2);\n\n    for (let i = 0; i < data.length; ++i) {\n        let valuesIndex = 0;\n\n        for (let j = -halfWindowSize; j <= halfWindowSize; ++j) {\n            let index = i + j;\n            if (index < 0) {\n                index = Math.abs(index);\n            } else if (index >= data.length) {\n                index = 2 * (data.length - 1) - index;\n            }\n\n            buffer[valuesIndex++] = data[index];\n        }\n\n        buffer.sort();\n        outputArray[i] = buffer[halfWindowSize];\n    }\n\n    return outputArray;\n}\n\n/**\n * Helper function to round a number to a given number of decimals\n * @param {number} num The number to round\n * @param {number} decimals The number of decimals\n * @returns {number} The rounded number\n */\nfunction round(num, decimals) {\n    const pow = Math.pow(10, decimals);\n    return Math.round(num * pow) / pow;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AeGVub3ZhL3RyYW5zZm9ybWVycy9zcmMvdXRpbHMvbWF0aHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsZ0lBQWdJO0FBQzdJLGFBQWEsZ0NBQWdDO0FBQzdDLGFBQWEsNEJBQTRCO0FBQ3pDOztBQUVBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCO0FBQ087QUFDUDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDLHdCQUF3QixlQUFlO0FBQ3ZDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0QkFBNEIsaUJBQWlCO0FBQzdDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsY0FBYyxlQUFlO0FBQzdCLFdBQVcsVUFBVTtBQUNyQixXQUFXLFVBQVU7QUFDckIsYUFBYSxlQUFlO0FBQzVCO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5Q0FBeUMsUUFBUTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQSw2Q0FBNkMsUUFBUTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQixhQUFh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dHJhbnNmb3JtZXJzL3NyYy91dGlscy9tYXRocy5qcz9kZGU3Il0sInNvdXJjZXNDb250ZW50IjpbIlxuLyoqXG4gKiBAZmlsZSBIZWxwZXIgbW9kdWxlIGZvciBtYXRoZW1hdGljYWwgcHJvY2Vzc2luZy4gXG4gKiBcbiAqIFRoZXNlIGZ1bmN0aW9ucyBhbmQgY2xhc3NlcyBhcmUgb25seSB1c2VkIGludGVybmFsbHksIFxuICogbWVhbmluZyBhbiBlbmQtdXNlciBzaG91bGRuJ3QgbmVlZCB0byBhY2Nlc3MgYW55dGhpbmcgaGVyZS5cbiAqIFxuICogQG1vZHVsZSB1dGlscy9tYXRoc1xuICovXG5cbi8qKlxuICogQHR5cGVkZWYge0ludDhBcnJheSB8IFVpbnQ4QXJyYXkgfCBVaW50OENsYW1wZWRBcnJheSB8IEludDE2QXJyYXkgfCBVaW50MTZBcnJheSB8IEludDMyQXJyYXkgfCBVaW50MzJBcnJheSB8IEZsb2F0MzJBcnJheSB8IEZsb2F0NjRBcnJheX0gVHlwZWRBcnJheVxuICogQHR5cGVkZWYge0JpZ0ludDY0QXJyYXkgfCBCaWdVaW50NjRBcnJheX0gQmlnVHlwZWRBcnJheVxuICogQHR5cGVkZWYge1R5cGVkQXJyYXkgfCBCaWdUeXBlZEFycmF5fSBBbnlUeXBlZEFycmF5XG4gKi9cblxuLyoqXG4gKiBAcGFyYW0ge1R5cGVkQXJyYXl9IGlucHV0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbnRlcnBvbGF0ZV9kYXRhKGlucHV0LCBbaW5fY2hhbm5lbHMsIGluX2hlaWdodCwgaW5fd2lkdGhdLCBbb3V0X2hlaWdodCwgb3V0X3dpZHRoXSwgbW9kZSA9ICdiaWxpbmVhcicsIGFsaWduX2Nvcm5lcnMgPSBmYWxzZSkge1xuICAgIC8vIFRPRE8gdXNlIG1vZGUgYW5kIGFsaWduX2Nvcm5lcnNcblxuICAgIC8vIE91dHB1dCBpbWFnZSBkaW1lbnNpb25zXG4gICAgY29uc3QgeF9zY2FsZSA9IG91dF93aWR0aCAvIGluX3dpZHRoO1xuICAgIGNvbnN0IHlfc2NhbGUgPSBvdXRfaGVpZ2h0IC8gaW5faGVpZ2h0O1xuXG4gICAgLy8gT3V0cHV0IGltYWdlXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGNvbnN0IG91dF9pbWcgPSBuZXcgaW5wdXQuY29uc3RydWN0b3Iob3V0X2hlaWdodCAqIG91dF93aWR0aCAqIGluX2NoYW5uZWxzKTtcblxuICAgIC8vIFByZS1jYWxjdWxhdGUgc3RyaWRlc1xuICAgIGNvbnN0IGluU3RyaWRlID0gaW5faGVpZ2h0ICogaW5fd2lkdGg7XG4gICAgY29uc3Qgb3V0U3RyaWRlID0gb3V0X2hlaWdodCAqIG91dF93aWR0aDtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3V0X2hlaWdodDsgKytpKSB7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgb3V0X3dpZHRoOyArK2opIHtcbiAgICAgICAgICAgIC8vIENhbGN1bGF0ZSBvdXRwdXQgb2Zmc2V0XG4gICAgICAgICAgICBjb25zdCBvdXRPZmZzZXQgPSBpICogb3V0X3dpZHRoICsgajtcblxuICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIGlucHV0IHBpeGVsIGNvb3JkaW5hdGVzXG4gICAgICAgICAgICBjb25zdCB4ID0gKGogKyAwLjUpIC8geF9zY2FsZSAtIDAuNTtcbiAgICAgICAgICAgIGNvbnN0IHkgPSAoaSArIDAuNSkgLyB5X3NjYWxlIC0gMC41O1xuXG4gICAgICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIGZvdXIgbmVhcmVzdCBpbnB1dCBwaXhlbHNcbiAgICAgICAgICAgIC8vIFdlIGFsc28gY2hlY2sgaWYgdGhlIGlucHV0IHBpeGVsIGNvb3JkaW5hdGVzIGFyZSB3aXRoaW4gdGhlIGltYWdlIGJvdW5kc1xuICAgICAgICAgICAgbGV0IHgxID0gTWF0aC5mbG9vcih4KTtcbiAgICAgICAgICAgIGxldCB5MSA9IE1hdGguZmxvb3IoeSk7XG4gICAgICAgICAgICBjb25zdCB4MiA9IE1hdGgubWluKHgxICsgMSwgaW5fd2lkdGggLSAxKTtcbiAgICAgICAgICAgIGNvbnN0IHkyID0gTWF0aC5taW4oeTEgKyAxLCBpbl9oZWlnaHQgLSAxKTtcblxuICAgICAgICAgICAgeDEgPSBNYXRoLm1heCh4MSwgMCk7XG4gICAgICAgICAgICB5MSA9IE1hdGgubWF4KHkxLCAwKTtcblxuXG4gICAgICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIGZyYWN0aW9uYWwgZGlzdGFuY2VzIGJldHdlZW4gdGhlIGlucHV0IHBpeGVsIGFuZCB0aGUgZm91ciBuZWFyZXN0IHBpeGVsc1xuICAgICAgICAgICAgY29uc3QgcyA9IHggLSB4MTtcbiAgICAgICAgICAgIGNvbnN0IHQgPSB5IC0geTE7XG5cbiAgICAgICAgICAgIC8vIFBlcmZvcm0gYmlsaW5lYXIgaW50ZXJwb2xhdGlvblxuICAgICAgICAgICAgY29uc3QgdzEgPSAoMSAtIHMpICogKDEgLSB0KTtcbiAgICAgICAgICAgIGNvbnN0IHcyID0gcyAqICgxIC0gdCk7XG4gICAgICAgICAgICBjb25zdCB3MyA9ICgxIC0gcykgKiB0O1xuICAgICAgICAgICAgY29uc3QgdzQgPSBzICogdDtcblxuICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBmb3VyIG5lYXJlc3QgaW5wdXQgcGl4ZWwgaW5kaWNlc1xuICAgICAgICAgICAgY29uc3QgeVN0cmlkZSA9IHkxICogaW5fd2lkdGg7XG4gICAgICAgICAgICBjb25zdCB4U3RyaWRlID0geTIgKiBpbl93aWR0aDtcbiAgICAgICAgICAgIGNvbnN0IGlkeDEgPSB5U3RyaWRlICsgeDE7XG4gICAgICAgICAgICBjb25zdCBpZHgyID0geVN0cmlkZSArIHgyO1xuICAgICAgICAgICAgY29uc3QgaWR4MyA9IHhTdHJpZGUgKyB4MTtcbiAgICAgICAgICAgIGNvbnN0IGlkeDQgPSB4U3RyaWRlICsgeDI7XG5cbiAgICAgICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgaW5fY2hhbm5lbHM7ICsraykge1xuICAgICAgICAgICAgICAgIC8vIENhbGN1bGF0ZSBjaGFubmVsIG9mZnNldFxuICAgICAgICAgICAgICAgIGNvbnN0IGNPZmZzZXQgPSBrICogaW5TdHJpZGU7XG5cbiAgICAgICAgICAgICAgICBvdXRfaW1nW2sgKiBvdXRTdHJpZGUgKyBvdXRPZmZzZXRdID1cbiAgICAgICAgICAgICAgICAgICAgdzEgKiBpbnB1dFtjT2Zmc2V0ICsgaWR4MV0gK1xuICAgICAgICAgICAgICAgICAgICB3MiAqIGlucHV0W2NPZmZzZXQgKyBpZHgyXSArXG4gICAgICAgICAgICAgICAgICAgIHczICogaW5wdXRbY09mZnNldCArIGlkeDNdICtcbiAgICAgICAgICAgICAgICAgICAgdzQgKiBpbnB1dFtjT2Zmc2V0ICsgaWR4NF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gb3V0X2ltZztcbn1cblxuXG4vKipcbiAqIEhlbHBlciBtZXRob2QgdG8gdHJhbnNwb3NlIGEgYEFueVR5cGVkQXJyYXlgIGRpcmVjdGx5XG4gKiBAcGFyYW0ge1R9IGFycmF5IFxuICogQHRlbXBsYXRlIHtBbnlUeXBlZEFycmF5fSBUIFxuICogQHBhcmFtIHtudW1iZXJbXX0gZGltcyBcbiAqIEBwYXJhbSB7bnVtYmVyW119IGF4ZXMgXG4gKiBAcmV0dXJucyB7W1QsIG51bWJlcltdXX0gVGhlIHRyYW5zcG9zZWQgYXJyYXkgYW5kIHRoZSBuZXcgc2hhcGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc3Bvc2VfZGF0YShhcnJheSwgZGltcywgYXhlcykge1xuICAgIC8vIENhbGN1bGF0ZSB0aGUgbmV3IHNoYXBlIG9mIHRoZSB0cmFuc3Bvc2VkIGFycmF5XG4gICAgLy8gYW5kIHRoZSBzdHJpZGUgb2YgdGhlIG9yaWdpbmFsIGFycmF5XG4gICAgY29uc3Qgc2hhcGUgPSBuZXcgQXJyYXkoYXhlcy5sZW5ndGgpO1xuICAgIGNvbnN0IHN0cmlkZSA9IG5ldyBBcnJheShheGVzLmxlbmd0aCk7XG5cbiAgICBmb3IgKGxldCBpID0gYXhlcy5sZW5ndGggLSAxLCBzID0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgc3RyaWRlW2ldID0gcztcbiAgICAgICAgc2hhcGVbaV0gPSBkaW1zW2F4ZXNbaV1dO1xuICAgICAgICBzICo9IHNoYXBlW2ldO1xuICAgIH1cblxuICAgIC8vIFByZWNvbXB1dGUgaW52ZXJzZSBtYXBwaW5nIG9mIHN0cmlkZVxuICAgIGNvbnN0IGludlN0cmlkZSA9IGF4ZXMubWFwKChfLCBpKSA9PiBzdHJpZGVbYXhlcy5pbmRleE9mKGkpXSk7XG5cbiAgICAvLyBDcmVhdGUgdGhlIHRyYW5zcG9zZWQgYXJyYXkgd2l0aCB0aGUgbmV3IHNoYXBlXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGNvbnN0IHRyYW5zcG9zZWREYXRhID0gbmV3IGFycmF5LmNvbnN0cnVjdG9yKGFycmF5Lmxlbmd0aCk7XG5cbiAgICAvLyBUcmFuc3Bvc2UgdGhlIG9yaWdpbmFsIGFycmF5IHRvIHRoZSBuZXcgYXJyYXlcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGxldCBuZXdJbmRleCA9IDA7XG4gICAgICAgIGZvciAobGV0IGogPSBkaW1zLmxlbmd0aCAtIDEsIGsgPSBpOyBqID49IDA7IC0taikge1xuICAgICAgICAgICAgbmV3SW5kZXggKz0gKGsgJSBkaW1zW2pdKSAqIGludlN0cmlkZVtqXTtcbiAgICAgICAgICAgIGsgPSBNYXRoLmZsb29yKGsgLyBkaW1zW2pdKTtcbiAgICAgICAgfVxuICAgICAgICB0cmFuc3Bvc2VkRGF0YVtuZXdJbmRleF0gPSBhcnJheVtpXTtcbiAgICB9XG5cbiAgICByZXR1cm4gW3RyYW5zcG9zZWREYXRhLCBzaGFwZV07XG59XG5cblxuLyoqXG4gKiBDb21wdXRlIHRoZSBzb2Z0bWF4IG9mIGFuIGFycmF5IG9mIG51bWJlcnMuXG4gKlxuICogQHBhcmFtIHtudW1iZXJbXX0gYXJyIFRoZSBhcnJheSBvZiBudW1iZXJzIHRvIGNvbXB1dGUgdGhlIHNvZnRtYXggb2YuXG4gKiBAcmV0dXJucyB7bnVtYmVyW119IFRoZSBzb2Z0bWF4IGFycmF5LlxuICovXG5leHBvcnQgZnVuY3Rpb24gc29mdG1heChhcnIpIHtcbiAgICAvLyBDb21wdXRlIHRoZSBtYXhpbXVtIHZhbHVlIGluIHRoZSBhcnJheVxuICAgIGNvbnN0IG1heFZhbCA9IG1heChhcnIpWzBdO1xuXG4gICAgLy8gQ29tcHV0ZSB0aGUgZXhwb25lbnRpYWxzIG9mIHRoZSBhcnJheSB2YWx1ZXNcbiAgICBjb25zdCBleHBzID0gYXJyLm1hcCh4ID0+IE1hdGguZXhwKHggLSBtYXhWYWwpKTtcblxuICAgIC8vIENvbXB1dGUgdGhlIHN1bSBvZiB0aGUgZXhwb25lbnRpYWxzXG4gICAgY29uc3Qgc3VtRXhwcyA9IGV4cHMucmVkdWNlKChhY2MsIHZhbCkgPT4gYWNjICsgdmFsLCAwKTtcblxuICAgIC8vIENvbXB1dGUgdGhlIHNvZnRtYXggdmFsdWVzXG4gICAgY29uc3Qgc29mdG1heEFyciA9IGV4cHMubWFwKHggPT4geCAvIHN1bUV4cHMpO1xuXG4gICAgcmV0dXJuIHNvZnRtYXhBcnI7XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgbG9nYXJpdGhtIG9mIHRoZSBzb2Z0bWF4IGZ1bmN0aW9uIGZvciB0aGUgaW5wdXQgYXJyYXkuXG4gKiBAcGFyYW0ge251bWJlcltdfSBhcnIgVGhlIGlucHV0IGFycmF5IHRvIGNhbGN1bGF0ZSB0aGUgbG9nX3NvZnRtYXggZnVuY3Rpb24gZm9yLlxuICogQHJldHVybnMge2FueX0gVGhlIHJlc3VsdGluZyBsb2dfc29mdG1heCBhcnJheS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxvZ19zb2Z0bWF4KGFycikge1xuICAgIC8vIENvbXB1dGUgdGhlIHNvZnRtYXggdmFsdWVzXG4gICAgY29uc3Qgc29mdG1heEFyciA9IHNvZnRtYXgoYXJyKTtcblxuICAgIC8vIEFwcGx5IGxvZyBmb3JtdWxhIHRvIGVhY2ggZWxlbWVudFxuICAgIGNvbnN0IGxvZ1NvZnRtYXhBcnIgPSBzb2Z0bWF4QXJyLm1hcCh4ID0+IE1hdGgubG9nKHgpKTtcblxuICAgIHJldHVybiBsb2dTb2Z0bWF4QXJyO1xufVxuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGRvdCBwcm9kdWN0IG9mIHR3byBhcnJheXMuXG4gKiBAcGFyYW0ge251bWJlcltdfSBhcnIxIFRoZSBmaXJzdCBhcnJheS5cbiAqIEBwYXJhbSB7bnVtYmVyW119IGFycjIgVGhlIHNlY29uZCBhcnJheS5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSBkb3QgcHJvZHVjdCBvZiBhcnIxIGFuZCBhcnIyLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZG90KGFycjEsIGFycjIpIHtcbiAgICByZXR1cm4gYXJyMS5yZWR1Y2UoKGFjYywgdmFsLCBpKSA9PiBhY2MgKyB2YWwgKiBhcnIyW2ldLCAwKTtcbn1cblxuXG4vKipcbiAqIEdldCB0aGUgdG9wIGsgaXRlbXMgZnJvbSBhbiBpdGVyYWJsZSwgc29ydGVkIGJ5IGRlc2NlbmRpbmcgb3JkZXJcbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBpdGVtcyBUaGUgaXRlbXMgdG8gYmUgc29ydGVkXG4gKiBAcGFyYW0ge251bWJlcn0gW3RvcF9rPTBdIFRoZSBudW1iZXIgb2YgdG9wIGl0ZW1zIHRvIHJldHVybiAoZGVmYXVsdDogMCA9IHJldHVybiBhbGwpXG4gKiBAcmV0dXJucyB7QXJyYXl9IFRoZSB0b3AgayBpdGVtcywgc29ydGVkIGJ5IGRlc2NlbmRpbmcgb3JkZXJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFRvcEl0ZW1zKGl0ZW1zLCB0b3BfayA9IDApIHtcbiAgICAvLyBpZiB0b3AgPT0gMCwgcmV0dXJuIGFsbFxuXG4gICAgaXRlbXMgPSBBcnJheS5mcm9tKGl0ZW1zKVxuICAgICAgICAubWFwKCh4LCBpKSA9PiBbaSwgeF0pICAgICAgICAgICAgLy8gR2V0IGluZGljZXMgKFtpbmRleCwgc2NvcmVdKVxuICAgICAgICAuc29ydCgoYSwgYikgPT4gYlsxXSAtIGFbMV0pICAgICAgLy8gU29ydCBieSBsb2cgcHJvYmFiaWxpdGllc1xuXG4gICAgaWYgKHRvcF9rID4gMCkge1xuICAgICAgICBpdGVtcyA9IGl0ZW1zLnNsaWNlKDAsIHRvcF9rKTsgICAgLy8gR2V0IHRvcCBrIGl0ZW1zXG4gICAgfVxuXG4gICAgcmV0dXJuIGl0ZW1zXG59XG5cbi8qKlxuICogQ29tcHV0ZXMgdGhlIGNvc2luZSBzaW1pbGFyaXR5IGJldHdlZW4gdHdvIGFycmF5cy5cbiAqXG4gKiBAcGFyYW0ge251bWJlcltdfSBhcnIxIFRoZSBmaXJzdCBhcnJheS5cbiAqIEBwYXJhbSB7bnVtYmVyW119IGFycjIgVGhlIHNlY29uZCBhcnJheS5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSBjb3NpbmUgc2ltaWxhcml0eSBiZXR3ZWVuIHRoZSB0d28gYXJyYXlzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY29zX3NpbShhcnIxLCBhcnIyKSB7XG4gICAgLy8gQ2FsY3VsYXRlIGRvdCBwcm9kdWN0IG9mIHRoZSB0d28gYXJyYXlzXG4gICAgY29uc3QgZG90UHJvZHVjdCA9IGRvdChhcnIxLCBhcnIyKTtcblxuICAgIC8vIENhbGN1bGF0ZSB0aGUgbWFnbml0dWRlIG9mIHRoZSBmaXJzdCBhcnJheVxuICAgIGNvbnN0IG1hZ25pdHVkZUEgPSBtYWduaXR1ZGUoYXJyMSk7XG5cbiAgICAvLyBDYWxjdWxhdGUgdGhlIG1hZ25pdHVkZSBvZiB0aGUgc2Vjb25kIGFycmF5XG4gICAgY29uc3QgbWFnbml0dWRlQiA9IG1hZ25pdHVkZShhcnIyKTtcblxuICAgIC8vIENhbGN1bGF0ZSB0aGUgY29zaW5lIHNpbWlsYXJpdHlcbiAgICBjb25zdCBjb3NpbmVTaW1pbGFyaXR5ID0gZG90UHJvZHVjdCAvIChtYWduaXR1ZGVBICogbWFnbml0dWRlQik7XG5cbiAgICByZXR1cm4gY29zaW5lU2ltaWxhcml0eTtcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBtYWduaXR1ZGUgb2YgYSBnaXZlbiBhcnJheS5cbiAqIEBwYXJhbSB7bnVtYmVyW119IGFyciBUaGUgYXJyYXkgdG8gY2FsY3VsYXRlIHRoZSBtYWduaXR1ZGUgb2YuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgbWFnbml0dWRlIG9mIHRoZSBhcnJheS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1hZ25pdHVkZShhcnIpIHtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KGFyci5yZWR1Y2UoKGFjYywgdmFsKSA9PiBhY2MgKyB2YWwgKiB2YWwsIDApKTtcbn1cblxuXG4vKipcbiAqIFJldHVybnMgdGhlIHZhbHVlIGFuZCBpbmRleCBvZiB0aGUgbWluaW11bSBlbGVtZW50IGluIGFuIGFycmF5LlxuICogQHBhcmFtIHtudW1iZXJbXX0gYXJyIGFycmF5IG9mIG51bWJlcnMuXG4gKiBAcmV0dXJucyB7bnVtYmVyW119IHRoZSB2YWx1ZSBhbmQgaW5kZXggb2YgdGhlIG1pbmltdW0gZWxlbWVudCwgb2YgdGhlIGZvcm06IFt2YWx1ZU9mTWluLCBpbmRleE9mTWluXVxuICogQHRocm93cyB7RXJyb3J9IElmIGFycmF5IGlzIGVtcHR5LlxuICovXG5leHBvcnQgZnVuY3Rpb24gbWluKGFycikge1xuICAgIGlmIChhcnIubGVuZ3RoID09PSAwKSB0aHJvdyBFcnJvcignQXJyYXkgbXVzdCBub3QgYmUgZW1wdHknKTtcbiAgICBsZXQgbWluID0gYXJyWzBdO1xuICAgIGxldCBpbmRleE9mTWluID0gMDtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IGFyci5sZW5ndGg7ICsraSkge1xuICAgICAgICBpZiAoYXJyW2ldIDwgbWluKSB7XG4gICAgICAgICAgICBtaW4gPSBhcnJbaV07XG4gICAgICAgICAgICBpbmRleE9mTWluID0gaTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gW21pbiwgaW5kZXhPZk1pbl07XG59XG5cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSB2YWx1ZSBhbmQgaW5kZXggb2YgdGhlIG1heGltdW0gZWxlbWVudCBpbiBhbiBhcnJheS5cbiAqIEBwYXJhbSB7bnVtYmVyW119IGFyciBhcnJheSBvZiBudW1iZXJzLlxuICogQHJldHVybnMge251bWJlcltdfSB0aGUgdmFsdWUgYW5kIGluZGV4IG9mIHRoZSBtYXhpbXVtIGVsZW1lbnQsIG9mIHRoZSBmb3JtOiBbdmFsdWVPZk1heCwgaW5kZXhPZk1heF1cbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiBhcnJheSBpcyBlbXB0eS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1heChhcnIpIHtcbiAgICBpZiAoYXJyLmxlbmd0aCA9PT0gMCkgdGhyb3cgRXJyb3IoJ0FycmF5IG11c3Qgbm90IGJlIGVtcHR5Jyk7XG4gICAgbGV0IG1heCA9IGFyclswXTtcbiAgICBsZXQgaW5kZXhPZk1heCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBhcnIubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaWYgKGFycltpXSA+IG1heCkge1xuICAgICAgICAgICAgbWF4ID0gYXJyW2ldO1xuICAgICAgICAgICAgaW5kZXhPZk1heCA9IGk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFttYXgsIGluZGV4T2ZNYXhdO1xufVxuXG4vKipcbiAqIFJldHVybiB0aGUgRGlzY3JldGUgRm91cmllciBUcmFuc2Zvcm0gc2FtcGxlIGZyZXF1ZW5jaWVzLlxuICogXG4gKiBDb2RlIGFkYXB0ZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vbnVtcHkvbnVtcHkvYmxvYi8yNTkwOGNhY2QxOTkxNWJmM2RkZDY1OWMyOGJlMjhhNDFiZDk3YTU0L251bXB5L2ZmdC9oZWxwZXIucHkjTDE3My1MMjIxXG4gKiBPcmlnaW5hbCBQeXRob24gZG9jOiBodHRwczovL251bXB5Lm9yZy9kb2Mvc3RhYmxlL3JlZmVyZW5jZS9nZW5lcmF0ZWQvbnVtcHkuZmZ0LnJmZnRmcmVxLmh0bWxcbiAqIEBleGFtcGxlXG4gKiByZmZ0ZnJlcSg0MDAsIDEgLyAxNjAwMCkgLy8gKDIwMSnCoFswLCA0MCwgODAsIDEyMCwgMTYwLCAyMDAsIC4uLiwgODAwMF1cbiAqIEBwYXJhbSB7bnVtYmVyfSBuIFdpbmRvdyBsZW5ndGhcbiAqIEBwYXJhbSB7bnVtYmVyfSBbZCA9IDEuMF0gU2FtcGxlIHNwYWNpbmcgKGludmVyc2Ugb2YgdGhlIHNhbXBsaW5nIHJhdGUpLiBEZWZhdWx0cyB0byAxLlxuICogQHRocm93cyB7VHlwZUVycm9yfSBJZiBuIGlzIG5vdCBhbiBpbnRlZ2VyLlxuICogQHJldHVybnMge251bWJlcltdfSBBcnJheSBvZiBsZW5ndGggYE1hdGguZmxvb3IobiAvIDIpICsgMTtgIGNvbnRhaW5pbmcgdGhlIHNhbXBsZSBmcmVxdWVuY2llcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJmZnRmcmVxKG4sIGQgPSAxLjApIHtcbiAgICBpZiAoIU51bWJlci5pc0ludGVnZXIobikpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgbiBzaG91bGQgYmUgYW4gaW50ZWdlciwgYnV0ICR7bn0gZ2l2ZW4uYCk7XG4gICAgfVxuICAgIGNvbnN0IHZhbCA9IDEuMCAvIChuICogZCk7XG4gICAgY29uc3QgbGVuID0gTWF0aC5mbG9vcihuIC8gMikgKyAxO1xuICAgIGNvbnN0IHJlc3VsdHMgPSBuZXcgQXJyYXkobGVuKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgIHJlc3VsdHNbaV0gPSBpICogdmFsO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0cztcbn1cblxuLyoqXG4gKiBGRlQgY2xhc3MgcHJvdmlkZXMgZnVuY3Rpb25hbGl0eSBmb3IgcGVyZm9ybWluZyBGYXN0IEZvdXJpZXIgVHJhbnNmb3JtIG9uIGFycmF5c1xuICogQ29kZSBhZGFwdGVkIGZyb20gaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvZmZ0LmpzXG4gKi9cbmV4cG9ydCBjbGFzcyBGRlQge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzaXplIFRoZSBzaXplIG9mIHRoZSBpbnB1dCBhcnJheS4gTXVzdCBiZSBhIHBvd2VyIG9mIHR3byBhbmQgYmlnZ2VyIHRoYW4gMS5cbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gRkZUIHNpemUgbXVzdCBiZSBhIHBvd2VyIG9mIHR3byBhbmQgYmlnZ2VyIHRoYW4gMS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihzaXplKSB7XG4gICAgICAgIHRoaXMuc2l6ZSA9IHNpemUgfCAwOyAvLyBjb252ZXJ0IHRvIGEgMzItYml0IHNpZ25lZCBpbnRlZ2VyXG4gICAgICAgIGlmICh0aGlzLnNpemUgPD0gMSB8fCAodGhpcy5zaXplICYgKHRoaXMuc2l6ZSAtIDEpKSAhPT0gMClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRkZUIHNpemUgbXVzdCBiZSBhIHBvd2VyIG9mIHR3byBhbmQgYmlnZ2VyIHRoYW4gMScpO1xuXG4gICAgICAgIHRoaXMuX2NzaXplID0gc2l6ZSA8PCAxO1xuXG4gICAgICAgIHRoaXMudGFibGUgPSBuZXcgRmxvYXQzMkFycmF5KHRoaXMuc2l6ZSAqIDIpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMudGFibGUubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgICAgIGNvbnN0IGFuZ2xlID0gTWF0aC5QSSAqIGkgLyB0aGlzLnNpemU7XG4gICAgICAgICAgICB0aGlzLnRhYmxlW2ldID0gTWF0aC5jb3MoYW5nbGUpO1xuICAgICAgICAgICAgdGhpcy50YWJsZVtpICsgMV0gPSAtTWF0aC5zaW4oYW5nbGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRmluZCBzaXplJ3MgcG93ZXIgb2YgdHdvXG4gICAgICAgIGxldCBwb3dlciA9IDA7XG4gICAgICAgIGZvciAobGV0IHQgPSAxOyB0aGlzLnNpemUgPiB0OyB0IDw8PSAxKVxuICAgICAgICAgICAgKytwb3dlcjtcblxuICAgICAgICAvLyBDYWxjdWxhdGUgaW5pdGlhbCBzdGVwJ3Mgd2lkdGg6XG4gICAgICAgIC8vICAgKiBJZiB3ZSBhcmUgZnVsbCByYWRpeC00LCBpdCBpcyAyeCBzbWFsbGVyIHRvIGdpdmUgaW5pdGFsIGxlbj04XG4gICAgICAgIC8vICAgKiBPdGhlcndpc2UgaXQgaXMgdGhlIHNhbWUgYXMgYHBvd2VyYCB0byBnaXZlIGxlbj00XG4gICAgICAgIHRoaXMuX3dpZHRoID0gcG93ZXIgJSAyID09PSAwID8gcG93ZXIgLSAxIDogcG93ZXI7XG5cbiAgICAgICAgLy8gUHJlLWNvbXB1dGUgYml0LXJldmVyc2FsIHBhdHRlcm5zXG4gICAgICAgIHRoaXMuX2JpdHJldiA9IG5ldyBJbnQzMkFycmF5KDEgPDwgdGhpcy5fd2lkdGgpO1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRoaXMuX2JpdHJldi5sZW5ndGg7ICsraikge1xuICAgICAgICAgICAgdGhpcy5fYml0cmV2W2pdID0gMDtcbiAgICAgICAgICAgIGZvciAobGV0IHNoaWZ0ID0gMDsgc2hpZnQgPCB0aGlzLl93aWR0aDsgc2hpZnQgKz0gMikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJldlNoaWZ0ID0gdGhpcy5fd2lkdGggLSBzaGlmdCAtIDI7XG4gICAgICAgICAgICAgICAgdGhpcy5fYml0cmV2W2pdIHw9ICgoaiA+Pj4gc2hpZnQpICYgMykgPDwgcmV2U2hpZnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBjb21wbGV4IG51bWJlciBhcnJheSB3aXRoIHNpemUgYDIgKiBzaXplYFxuICAgICAqXG4gICAgICogQHJldHVybnMge0Zsb2F0MzJBcnJheX0gQSBjb21wbGV4IG51bWJlciBhcnJheSB3aXRoIHNpemUgYDIgKiBzaXplYFxuICAgICAqL1xuICAgIGNyZWF0ZUNvbXBsZXhBcnJheSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkodGhpcy5fY3NpemUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGEgY29tcGxleCBudW1iZXIgcmVwcmVzZW50YXRpb24gc3RvcmVkIGluIGEgRmxvYXQzMkFycmF5IHRvIGFuIGFycmF5IG9mIHJlYWwgbnVtYmVycy5cbiAgICAgKiBcbiAgICAgKiBAcGFyYW0ge0Zsb2F0MzJBcnJheX0gY29tcGxleCBUaGUgY29tcGxleCBudW1iZXIgcmVwcmVzZW50YXRpb24gdG8gYmUgY29udmVydGVkLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyW119IFtzdG9yYWdlXSBBbiBvcHRpb25hbCBhcnJheSB0byBzdG9yZSB0aGUgcmVzdWx0IGluLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJbXX0gQW4gYXJyYXkgb2YgcmVhbCBudW1iZXJzIHJlcHJlc2VudGluZyB0aGUgaW5wdXQgY29tcGxleCBudW1iZXIgcmVwcmVzZW50YXRpb24uXG4gICAgICovXG4gICAgZnJvbUNvbXBsZXhBcnJheShjb21wbGV4LCBzdG9yYWdlKSB7XG4gICAgICAgIGNvbnN0IHJlcyA9IHN0b3JhZ2UgfHwgbmV3IEFycmF5KGNvbXBsZXgubGVuZ3RoID4+PiAxKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb21wbGV4Lmxlbmd0aDsgaSArPSAyKVxuICAgICAgICAgICAgcmVzW2kgPj4+IDFdID0gY29tcGxleFtpXTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IGEgcmVhbC12YWx1ZWQgaW5wdXQgYXJyYXkgdG8gYSBjb21wbGV4LXZhbHVlZCBvdXRwdXQgYXJyYXkuXG4gICAgICogQHBhcmFtIHtGbG9hdDMyQXJyYXl9IGlucHV0IFRoZSByZWFsLXZhbHVlZCBpbnB1dCBhcnJheS5cbiAgICAgKiBAcGFyYW0ge0Zsb2F0MzJBcnJheX0gW3N0b3JhZ2VdIE9wdGlvbmFsIGJ1ZmZlciB0byBzdG9yZSB0aGUgb3V0cHV0IGFycmF5LlxuICAgICAqIEByZXR1cm5zIHtGbG9hdDMyQXJyYXl9IFRoZSBjb21wbGV4LXZhbHVlZCBvdXRwdXQgYXJyYXkuXG4gICAgICovXG4gICAgdG9Db21wbGV4QXJyYXkoaW5wdXQsIHN0b3JhZ2UpIHtcbiAgICAgICAgY29uc3QgcmVzID0gc3RvcmFnZSB8fCB0aGlzLmNyZWF0ZUNvbXBsZXhBcnJheSgpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgICAgcmVzW2ldID0gaW5wdXRbaSA+Pj4gMV07XG4gICAgICAgICAgICByZXNbaSArIDFdID0gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbXBsZXRlcyB0aGUgc3BlY3RydW0gYnkgYWRkaW5nIGl0cyBtaXJyb3JlZCBuZWdhdGl2ZSBmcmVxdWVuY3kgY29tcG9uZW50cy5cbiAgICAgKiBAcGFyYW0ge0Zsb2F0MzJBcnJheX0gc3BlY3RydW0gVGhlIGlucHV0IHNwZWN0cnVtLlxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxuICAgICAqL1xuICAgIGNvbXBsZXRlU3BlY3RydW0oc3BlY3RydW0pIHtcbiAgICAgICAgY29uc3Qgc2l6ZSA9IHRoaXMuX2NzaXplO1xuICAgICAgICBjb25zdCBoYWxmID0gc2l6ZSA+Pj4gMTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDI7IGkgPCBoYWxmOyBpICs9IDIpIHtcbiAgICAgICAgICAgIHNwZWN0cnVtW3NpemUgLSBpXSA9IHNwZWN0cnVtW2ldO1xuICAgICAgICAgICAgc3BlY3RydW1bc2l6ZSAtIGkgKyAxXSA9IC1zcGVjdHJ1bVtpICsgMV07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtcyBhIEZhc3QgRm91cmllciBUcmFuc2Zvcm0gKEZGVCkgb24gdGhlIGdpdmVuIGlucHV0IGRhdGEgYW5kIHN0b3JlcyB0aGUgcmVzdWx0IGluIHRoZSBvdXRwdXQgYnVmZmVyLlxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fSBvdXQgVGhlIG91dHB1dCBidWZmZXIgdG8gc3RvcmUgdGhlIHJlc3VsdC5cbiAgICAgKiBAcGFyYW0ge0Zsb2F0MzJBcnJheX0gZGF0YSBUaGUgaW5wdXQgZGF0YSB0byB0cmFuc2Zvcm0uXG4gICAgICogXG4gICAgICogQHRocm93cyB7RXJyb3J9IElucHV0IGFuZCBvdXRwdXQgYnVmZmVycyBtdXN0IGJlIGRpZmZlcmVudC5cbiAgICAgKiBcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICAgKi9cbiAgICB0cmFuc2Zvcm0ob3V0LCBkYXRhKSB7XG4gICAgICAgIGlmIChvdXQgPT09IGRhdGEpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IGFuZCBvdXRwdXQgYnVmZmVycyBtdXN0IGJlIGRpZmZlcmVudCcpO1xuXG4gICAgICAgIHRoaXMuX3RyYW5zZm9ybTQob3V0LCBkYXRhLCAxIC8qIERPTkUgKi8pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBlcmZvcm1zIGEgcmVhbC12YWx1ZWQgZm9yd2FyZCBGRlQgb24gdGhlIGdpdmVuIGlucHV0IGJ1ZmZlciBhbmQgc3RvcmVzIHRoZSByZXN1bHQgaW4gdGhlIGdpdmVuIG91dHB1dCBidWZmZXIuXG4gICAgICogVGhlIGlucHV0IGJ1ZmZlciBtdXN0IGNvbnRhaW4gcmVhbCB2YWx1ZXMgb25seSwgd2hpbGUgdGhlIG91dHB1dCBidWZmZXIgd2lsbCBjb250YWluIGNvbXBsZXggdmFsdWVzLiBUaGUgaW5wdXQgYW5kXG4gICAgICogb3V0cHV0IGJ1ZmZlcnMgbXVzdCBiZSBkaWZmZXJlbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Zsb2F0MzJBcnJheX0gb3V0IFRoZSBvdXRwdXQgYnVmZmVyLlxuICAgICAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fSBkYXRhIFRoZSBpbnB1dCBidWZmZXIgY29udGFpbmluZyByZWFsIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgaW5wdXQgYW5kIG91dHB1dCBidWZmZXJzIGFyZSB0aGUgc2FtZS5cbiAgICAgKi9cbiAgICByZWFsVHJhbnNmb3JtKG91dCwgZGF0YSkge1xuICAgICAgICBpZiAob3V0ID09PSBkYXRhKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBhbmQgb3V0cHV0IGJ1ZmZlcnMgbXVzdCBiZSBkaWZmZXJlbnQnKTtcblxuICAgICAgICB0aGlzLl9yZWFsVHJhbnNmb3JtNChvdXQsIGRhdGEsIDEgLyogRE9ORSAqLyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGVyZm9ybXMgYW4gaW52ZXJzZSBGRlQgdHJhbnNmb3JtYXRpb24gb24gdGhlIGdpdmVuIGBkYXRhYCBhcnJheSwgYW5kIHN0b3JlcyB0aGUgcmVzdWx0IGluIGBvdXRgLlxuICAgICAqIFRoZSBgb3V0YCBhcnJheSBtdXN0IGJlIGEgZGlmZmVyZW50IGJ1ZmZlciB0aGFuIHRoZSBgZGF0YWAgYXJyYXkuIFRoZSBgb3V0YCBhcnJheSB3aWxsIGNvbnRhaW4gdGhlXG4gICAgICogcmVzdWx0IG9mIHRoZSB0cmFuc2Zvcm1hdGlvbi4gVGhlIGBkYXRhYCBhcnJheSB3aWxsIG5vdCBiZSBtb2RpZmllZC5cbiAgICAgKiBcbiAgICAgKiBAcGFyYW0ge0Zsb2F0MzJBcnJheX0gb3V0IFRoZSBvdXRwdXQgYnVmZmVyIGZvciB0aGUgdHJhbnNmb3JtZWQgZGF0YS5cbiAgICAgKiBAcGFyYW0ge0Zsb2F0MzJBcnJheX0gZGF0YSBUaGUgaW5wdXQgZGF0YSB0byB0cmFuc2Zvcm0uXG4gICAgICogQHRocm93cyB7RXJyb3J9IElmIGBvdXRgIGFuZCBgZGF0YWAgcmVmZXIgdG8gdGhlIHNhbWUgYnVmZmVyLlxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxuICAgICAqL1xuICAgIGludmVyc2VUcmFuc2Zvcm0ob3V0LCBkYXRhKSB7XG4gICAgICAgIGlmIChvdXQgPT09IGRhdGEpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IGFuZCBvdXRwdXQgYnVmZmVycyBtdXN0IGJlIGRpZmZlcmVudCcpO1xuXG4gICAgICAgIHRoaXMuX3RyYW5zZm9ybTQob3V0LCBkYXRhLCAtMSAvKiBET05FICovKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvdXQubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICBvdXRbaV0gLz0gdGhpcy5zaXplO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBlcmZvcm1zIGEgcmFkaXgtNCBpbXBsZW1lbnRhdGlvbiBvZiBhIGRpc2NyZXRlIEZvdXJpZXIgdHJhbnNmb3JtIG9uIGEgZ2l2ZW4gc2V0IG9mIGRhdGEuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Zsb2F0MzJBcnJheX0gb3V0IFRoZSBvdXRwdXQgYnVmZmVyIGZvciB0aGUgdHJhbnNmb3JtZWQgZGF0YS5cbiAgICAgKiBAcGFyYW0ge0Zsb2F0MzJBcnJheX0gZGF0YSBUaGUgaW5wdXQgYnVmZmVyIG9mIGRhdGEgdG8gYmUgdHJhbnNmb3JtZWQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGludiBBIHNjYWxpbmcgZmFjdG9yIHRvIGFwcGx5IHRvIHRoZSB0cmFuc2Zvcm0uXG4gICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICovXG4gICAgX3RyYW5zZm9ybTQob3V0LCBkYXRhLCBpbnYpIHtcbiAgICAgICAgLy8gcmFkaXgtNCBpbXBsZW1lbnRhdGlvblxuXG4gICAgICAgIGNvbnN0IHNpemUgPSB0aGlzLl9jc2l6ZTtcblxuICAgICAgICAvLyBJbml0aWFsIHN0ZXAgKHBlcm11dGUgYW5kIHRyYW5zZm9ybSlcbiAgICAgICAgY29uc3Qgd2lkdGggPSB0aGlzLl93aWR0aDtcbiAgICAgICAgbGV0IHN0ZXAgPSAxIDw8IHdpZHRoO1xuICAgICAgICBsZXQgbGVuID0gKHNpemUgLyBzdGVwKSA8PCAxO1xuXG4gICAgICAgIGxldCBvdXRPZmY7XG4gICAgICAgIGxldCB0O1xuICAgICAgICBsZXQgYml0cmV2ID0gdGhpcy5fYml0cmV2O1xuICAgICAgICBpZiAobGVuID09PSA0KSB7XG4gICAgICAgICAgICBmb3IgKG91dE9mZiA9IDAsIHQgPSAwOyBvdXRPZmYgPCBzaXplOyBvdXRPZmYgKz0gbGVuLCArK3QpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvZmYgPSBiaXRyZXZbdF07XG4gICAgICAgICAgICAgICAgdGhpcy5fc2luZ2xlVHJhbnNmb3JtMihkYXRhLCBvdXQsIG91dE9mZiwgb2ZmLCBzdGVwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGxlbiA9PT0gOFxuICAgICAgICAgICAgZm9yIChvdXRPZmYgPSAwLCB0ID0gMDsgb3V0T2ZmIDwgc2l6ZTsgb3V0T2ZmICs9IGxlbiwgKyt0KSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb2ZmID0gYml0cmV2W3RdO1xuICAgICAgICAgICAgICAgIHRoaXMuX3NpbmdsZVRyYW5zZm9ybTQoZGF0YSwgb3V0LCBvdXRPZmYsIG9mZiwgc3RlcCwgaW52KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIExvb3AgdGhyb3VnaCBzdGVwcyBpbiBkZWNyZWFzaW5nIG9yZGVyXG4gICAgICAgIGZvciAoc3RlcCA+Pj0gMjsgc3RlcCA+PSAyOyBzdGVwID4+PSAyKSB7XG4gICAgICAgICAgICBsZW4gPSAoc2l6ZSAvIHN0ZXApIDw8IDE7XG4gICAgICAgICAgICBsZXQgcXVhcnRlckxlbiA9IGxlbiA+Pj4gMjtcblxuICAgICAgICAgICAgLy8gTG9vcCB0aHJvdWdoIG9mZnNldHMgaW4gdGhlIGRhdGFcbiAgICAgICAgICAgIGZvciAob3V0T2ZmID0gMDsgb3V0T2ZmIDwgc2l6ZTsgb3V0T2ZmICs9IGxlbikge1xuICAgICAgICAgICAgICAgIC8vIEZ1bGwgY2FzZVxuICAgICAgICAgICAgICAgIGxldCBsaW1pdCA9IG91dE9mZiArIHF1YXJ0ZXJMZW47XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IG91dE9mZiwgayA9IDA7IGkgPCBsaW1pdDsgaSArPSAyLCBrICs9IHN0ZXApIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgQSA9IGk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IEIgPSBBICsgcXVhcnRlckxlbjtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgQyA9IEIgKyBxdWFydGVyTGVuO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBEID0gQyArIHF1YXJ0ZXJMZW47XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gT3JpZ2luYWwgdmFsdWVzXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IEFyID0gb3V0W0FdO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBBaSA9IG91dFtBICsgMV07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IEJyID0gb3V0W0JdO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBCaSA9IG91dFtCICsgMV07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IENyID0gb3V0W0NdO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBDaSA9IG91dFtDICsgMV07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IERyID0gb3V0W0RdO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBEaSA9IG91dFtEICsgMV07XG5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGFibGVCciA9IHRoaXMudGFibGVba107XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRhYmxlQmkgPSBpbnYgKiB0aGlzLnRhYmxlW2sgKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgTUJyID0gQnIgKiB0YWJsZUJyIC0gQmkgKiB0YWJsZUJpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBNQmkgPSBCciAqIHRhYmxlQmkgKyBCaSAqIHRhYmxlQnI7XG5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGFibGVDciA9IHRoaXMudGFibGVbMiAqIGtdO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0YWJsZUNpID0gaW52ICogdGhpcy50YWJsZVsyICogayArIDFdO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBNQ3IgPSBDciAqIHRhYmxlQ3IgLSBDaSAqIHRhYmxlQ2k7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IE1DaSA9IENyICogdGFibGVDaSArIENpICogdGFibGVDcjtcblxuICAgICAgICAgICAgICAgICAgICBjb25zdCB0YWJsZURyID0gdGhpcy50YWJsZVszICoga107XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRhYmxlRGkgPSBpbnYgKiB0aGlzLnRhYmxlWzMgKiBrICsgMV07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IE1EciA9IERyICogdGFibGVEciAtIERpICogdGFibGVEaTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgTURpID0gRHIgKiB0YWJsZURpICsgRGkgKiB0YWJsZURyO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFByZS1GaW5hbCB2YWx1ZXNcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgVDByID0gQXIgKyBNQ3I7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IFQwaSA9IEFpICsgTUNpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBUMXIgPSBBciAtIE1DcjtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgVDFpID0gQWkgLSBNQ2k7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IFQyciA9IE1CciArIE1EcjtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgVDJpID0gTUJpICsgTURpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBUM3IgPSBpbnYgKiAoTUJyIC0gTURyKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgVDNpID0gaW52ICogKE1CaSAtIE1EaSk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gRmluYWwgdmFsdWVzXG4gICAgICAgICAgICAgICAgICAgIG91dFtBXSA9IFQwciArIFQycjtcbiAgICAgICAgICAgICAgICAgICAgb3V0W0EgKyAxXSA9IFQwaSArIFQyaTtcbiAgICAgICAgICAgICAgICAgICAgb3V0W0JdID0gVDFyICsgVDNpO1xuICAgICAgICAgICAgICAgICAgICBvdXRbQiArIDFdID0gVDFpIC0gVDNyO1xuICAgICAgICAgICAgICAgICAgICBvdXRbQ10gPSBUMHIgLSBUMnI7XG4gICAgICAgICAgICAgICAgICAgIG91dFtDICsgMV0gPSBUMGkgLSBUMmk7XG4gICAgICAgICAgICAgICAgICAgIG91dFtEXSA9IFQxciAtIFQzaTtcbiAgICAgICAgICAgICAgICAgICAgb3V0W0QgKyAxXSA9IFQxaSArIFQzcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtcyBhIHJhZGl4LTIgaW1wbGVtZW50YXRpb24gb2YgYSBkaXNjcmV0ZSBGb3VyaWVyIHRyYW5zZm9ybSBvbiBhIGdpdmVuIHNldCBvZiBkYXRhLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtGbG9hdDMyQXJyYXl9IGRhdGEgVGhlIGlucHV0IGJ1ZmZlciBvZiBkYXRhIHRvIGJlIHRyYW5zZm9ybWVkLlxuICAgICAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fSBvdXQgVGhlIG91dHB1dCBidWZmZXIgZm9yIHRoZSB0cmFuc2Zvcm1lZCBkYXRhLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvdXRPZmYgVGhlIG9mZnNldCBhdCB3aGljaCB0byB3cml0ZSB0aGUgb3V0cHV0IGRhdGEuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG9mZiBUaGUgb2Zmc2V0IGF0IHdoaWNoIHRvIGJlZ2luIHJlYWRpbmcgdGhlIGlucHV0IGRhdGEuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0ZXAgVGhlIHN0ZXAgc2l6ZSBmb3IgaW5kZXhpbmcgdGhlIGlucHV0IGRhdGEuXG4gICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICovXG4gICAgX3NpbmdsZVRyYW5zZm9ybTIoZGF0YSwgb3V0LCBvdXRPZmYsIG9mZiwgc3RlcCkge1xuICAgICAgICAvLyByYWRpeC0yIGltcGxlbWVudGF0aW9uXG4gICAgICAgIC8vIE5PVEU6IE9ubHkgY2FsbGVkIGZvciBsZW49NFxuXG4gICAgICAgIGNvbnN0IGV2ZW5SID0gZGF0YVtvZmZdO1xuICAgICAgICBjb25zdCBldmVuSSA9IGRhdGFbb2ZmICsgMV07XG4gICAgICAgIGNvbnN0IG9kZFIgPSBkYXRhW29mZiArIHN0ZXBdO1xuICAgICAgICBjb25zdCBvZGRJID0gZGF0YVtvZmYgKyBzdGVwICsgMV07XG5cbiAgICAgICAgb3V0W291dE9mZl0gPSBldmVuUiArIG9kZFI7XG4gICAgICAgIG91dFtvdXRPZmYgKyAxXSA9IGV2ZW5JICsgb2RkSTtcbiAgICAgICAgb3V0W291dE9mZiArIDJdID0gZXZlblIgLSBvZGRSO1xuICAgICAgICBvdXRbb3V0T2ZmICsgM10gPSBldmVuSSAtIG9kZEk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGVyZm9ybXMgcmFkaXgtNCB0cmFuc2Zvcm1hdGlvbiBvbiBpbnB1dCBkYXRhIG9mIGxlbmd0aCA4XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Zsb2F0MzJBcnJheX0gZGF0YSBJbnB1dCBkYXRhIGFycmF5IG9mIGxlbmd0aCA4XG4gICAgICogQHBhcmFtIHtGbG9hdDMyQXJyYXl9IG91dCBPdXRwdXQgZGF0YSBhcnJheSBvZiBsZW5ndGggOFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvdXRPZmYgSW5kZXggb2Ygb3V0cHV0IGFycmF5IHRvIHN0YXJ0IHdyaXRpbmcgZnJvbVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvZmYgSW5kZXggb2YgaW5wdXQgYXJyYXkgdG8gc3RhcnQgcmVhZGluZyBmcm9tXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0ZXAgU3RlcCBzaXplIGJldHdlZW4gZWxlbWVudHMgaW4gaW5wdXQgYXJyYXlcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW52IFNjYWxpbmcgZmFjdG9yIGZvciBpbnZlcnNlIHRyYW5zZm9ybVxuICAgICAqIFxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxuICAgICAqL1xuICAgIF9zaW5nbGVUcmFuc2Zvcm00KGRhdGEsIG91dCwgb3V0T2ZmLCBvZmYsIHN0ZXAsIGludikge1xuICAgICAgICAvLyByYWRpeC00XG4gICAgICAgIC8vIE5PVEU6IE9ubHkgY2FsbGVkIGZvciBsZW49OFxuICAgICAgICBjb25zdCBzdGVwMiA9IHN0ZXAgKiAyO1xuICAgICAgICBjb25zdCBzdGVwMyA9IHN0ZXAgKiAzO1xuXG4gICAgICAgIC8vIE9yaWdpbmFsIHZhbHVlc1xuICAgICAgICBjb25zdCBBciA9IGRhdGFbb2ZmXTtcbiAgICAgICAgY29uc3QgQWkgPSBkYXRhW29mZiArIDFdO1xuICAgICAgICBjb25zdCBCciA9IGRhdGFbb2ZmICsgc3RlcF07XG4gICAgICAgIGNvbnN0IEJpID0gZGF0YVtvZmYgKyBzdGVwICsgMV07XG4gICAgICAgIGNvbnN0IENyID0gZGF0YVtvZmYgKyBzdGVwMl07XG4gICAgICAgIGNvbnN0IENpID0gZGF0YVtvZmYgKyBzdGVwMiArIDFdO1xuICAgICAgICBjb25zdCBEciA9IGRhdGFbb2ZmICsgc3RlcDNdO1xuICAgICAgICBjb25zdCBEaSA9IGRhdGFbb2ZmICsgc3RlcDMgKyAxXTtcblxuICAgICAgICAvLyBQcmUtRmluYWwgdmFsdWVzXG4gICAgICAgIGNvbnN0IFQwciA9IEFyICsgQ3I7XG4gICAgICAgIGNvbnN0IFQwaSA9IEFpICsgQ2k7XG4gICAgICAgIGNvbnN0IFQxciA9IEFyIC0gQ3I7XG4gICAgICAgIGNvbnN0IFQxaSA9IEFpIC0gQ2k7XG4gICAgICAgIGNvbnN0IFQyciA9IEJyICsgRHI7XG4gICAgICAgIGNvbnN0IFQyaSA9IEJpICsgRGk7XG4gICAgICAgIGNvbnN0IFQzciA9IGludiAqIChCciAtIERyKTtcbiAgICAgICAgY29uc3QgVDNpID0gaW52ICogKEJpIC0gRGkpO1xuXG4gICAgICAgIC8vIEZpbmFsIHZhbHVlc1xuICAgICAgICBvdXRbb3V0T2ZmXSA9IFQwciArIFQycjtcbiAgICAgICAgb3V0W291dE9mZiArIDFdID0gVDBpICsgVDJpO1xuICAgICAgICBvdXRbb3V0T2ZmICsgMl0gPSBUMXIgKyBUM2k7XG4gICAgICAgIG91dFtvdXRPZmYgKyAzXSA9IFQxaSAtIFQzcjtcbiAgICAgICAgb3V0W291dE9mZiArIDRdID0gVDByIC0gVDJyO1xuICAgICAgICBvdXRbb3V0T2ZmICsgNV0gPSBUMGkgLSBUMmk7XG4gICAgICAgIG91dFtvdXRPZmYgKyA2XSA9IFQxciAtIFQzaTtcbiAgICAgICAgb3V0W291dE9mZiArIDddID0gVDFpICsgVDNyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlYWwgaW5wdXQgcmFkaXgtNCBpbXBsZW1lbnRhdGlvblxuICAgICAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fSBvdXQgT3V0cHV0IGFycmF5IGZvciB0aGUgdHJhbnNmb3JtZWQgZGF0YVxuICAgICAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fSBkYXRhIElucHV0IGFycmF5IG9mIHJlYWwgZGF0YSB0byBiZSB0cmFuc2Zvcm1lZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbnYgVGhlIHNjYWxlIGZhY3RvciB1c2VkIHRvIG5vcm1hbGl6ZSB0aGUgaW52ZXJzZSB0cmFuc2Zvcm1cbiAgICAgKi9cbiAgICBfcmVhbFRyYW5zZm9ybTQob3V0LCBkYXRhLCBpbnYpIHtcbiAgICAgICAgLy8gUmVhbCBpbnB1dCByYWRpeC00IGltcGxlbWVudGF0aW9uXG4gICAgICAgIGNvbnN0IHNpemUgPSB0aGlzLl9jc2l6ZTtcblxuICAgICAgICAvLyBJbml0aWFsIHN0ZXAgKHBlcm11dGUgYW5kIHRyYW5zZm9ybSlcbiAgICAgICAgY29uc3Qgd2lkdGggPSB0aGlzLl93aWR0aDtcbiAgICAgICAgbGV0IHN0ZXAgPSAxIDw8IHdpZHRoO1xuICAgICAgICBsZXQgbGVuID0gKHNpemUgLyBzdGVwKSA8PCAxO1xuXG4gICAgICAgIHZhciBvdXRPZmY7XG4gICAgICAgIHZhciB0O1xuICAgICAgICB2YXIgYml0cmV2ID0gdGhpcy5fYml0cmV2O1xuICAgICAgICBpZiAobGVuID09PSA0KSB7XG4gICAgICAgICAgICBmb3IgKG91dE9mZiA9IDAsIHQgPSAwOyBvdXRPZmYgPCBzaXplOyBvdXRPZmYgKz0gbGVuLCArK3QpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvZmYgPSBiaXRyZXZbdF07XG4gICAgICAgICAgICAgICAgdGhpcy5fc2luZ2xlUmVhbFRyYW5zZm9ybTIoZGF0YSwgb3V0LCBvdXRPZmYsIG9mZiA+Pj4gMSwgc3RlcCA+Pj4gMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBsZW4gPT09IDhcbiAgICAgICAgICAgIGZvciAob3V0T2ZmID0gMCwgdCA9IDA7IG91dE9mZiA8IHNpemU7IG91dE9mZiArPSBsZW4sICsrdCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG9mZiA9IGJpdHJldlt0XTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zaW5nbGVSZWFsVHJhbnNmb3JtNChkYXRhLCBvdXQsIG91dE9mZiwgb2ZmID4+PiAxLCBzdGVwID4+PiAxLCBpbnYpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gTG9vcCB0aHJvdWdoIHN0ZXBzIGluIGRlY3JlYXNpbmcgb3JkZXJcbiAgICAgICAgZm9yIChzdGVwID4+PSAyOyBzdGVwID49IDI7IHN0ZXAgPj49IDIpIHtcbiAgICAgICAgICAgIGxlbiA9IChzaXplIC8gc3RlcCkgPDwgMTtcbiAgICAgICAgICAgIGNvbnN0IGhhbGZMZW4gPSBsZW4gPj4+IDE7XG4gICAgICAgICAgICBjb25zdCBxdWFydGVyTGVuID0gaGFsZkxlbiA+Pj4gMTtcbiAgICAgICAgICAgIGNvbnN0IGhxdWFydGVyTGVuID0gcXVhcnRlckxlbiA+Pj4gMTtcblxuICAgICAgICAgICAgLy8gTG9vcCB0aHJvdWdoIG9mZnNldHMgaW4gdGhlIGRhdGFcbiAgICAgICAgICAgIGZvciAob3V0T2ZmID0gMDsgb3V0T2ZmIDwgc2l6ZTsgb3V0T2ZmICs9IGxlbikge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBrID0gMDsgaSA8PSBocXVhcnRlckxlbjsgaSArPSAyLCBrICs9IHN0ZXApIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgQSA9IG91dE9mZiArIGk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IEIgPSBBICsgcXVhcnRlckxlbjtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgQyA9IEIgKyBxdWFydGVyTGVuO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBEID0gQyArIHF1YXJ0ZXJMZW47XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gT3JpZ2luYWwgdmFsdWVzXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IEFyID0gb3V0W0FdO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBBaSA9IG91dFtBICsgMV07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IEJyID0gb3V0W0JdO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBCaSA9IG91dFtCICsgMV07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IENyID0gb3V0W0NdO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBDaSA9IG91dFtDICsgMV07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IERyID0gb3V0W0RdO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBEaSA9IG91dFtEICsgMV07XG5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGFibGVCciA9IHRoaXMudGFibGVba107XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRhYmxlQmkgPSBpbnYgKiB0aGlzLnRhYmxlW2sgKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgTUJyID0gQnIgKiB0YWJsZUJyIC0gQmkgKiB0YWJsZUJpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBNQmkgPSBCciAqIHRhYmxlQmkgKyBCaSAqIHRhYmxlQnI7XG5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGFibGVDciA9IHRoaXMudGFibGVbMiAqIGtdO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0YWJsZUNpID0gaW52ICogdGhpcy50YWJsZVsyICogayArIDFdO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBNQ3IgPSBDciAqIHRhYmxlQ3IgLSBDaSAqIHRhYmxlQ2k7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IE1DaSA9IENyICogdGFibGVDaSArIENpICogdGFibGVDcjtcblxuICAgICAgICAgICAgICAgICAgICBjb25zdCB0YWJsZURyID0gdGhpcy50YWJsZVszICoga107XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRhYmxlRGkgPSBpbnYgKiB0aGlzLnRhYmxlWzMgKiBrICsgMV07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IE1EciA9IERyICogdGFibGVEciAtIERpICogdGFibGVEaTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgTURpID0gRHIgKiB0YWJsZURpICsgRGkgKiB0YWJsZURyO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFByZS1GaW5hbCB2YWx1ZXNcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgVDByID0gQXIgKyBNQ3I7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IFQwaSA9IEFpICsgTUNpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBUMXIgPSBBciAtIE1DcjtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgVDFpID0gQWkgLSBNQ2k7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IFQyciA9IE1CciArIE1EcjtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgVDJpID0gTUJpICsgTURpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBUM3IgPSBpbnYgKiAoTUJyIC0gTURyKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgVDNpID0gaW52ICogKE1CaSAtIE1EaSk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gRmluYWwgdmFsdWVzXG4gICAgICAgICAgICAgICAgICAgIG91dFtBXSA9IFQwciArIFQycjtcbiAgICAgICAgICAgICAgICAgICAgb3V0W0EgKyAxXSA9IFQwaSArIFQyaTtcbiAgICAgICAgICAgICAgICAgICAgb3V0W0JdID0gVDFyICsgVDNpO1xuICAgICAgICAgICAgICAgICAgICBvdXRbQiArIDFdID0gVDFpIC0gVDNyO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIE91dHB1dCBmaW5hbCBtaWRkbGUgcG9pbnRcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dFtDXSA9IFQwciAtIFQycjtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dFtDICsgMV0gPSBUMGkgLSBUMmk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIERvIG5vdCBvdmVyd3JpdGUgb3Vyc2VsdmVzXG4gICAgICAgICAgICAgICAgICAgIGlmIChpID09PSBocXVhcnRlckxlbilcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IFNBID0gb3V0T2ZmICsgcXVhcnRlckxlbiAtIGk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IFNCID0gb3V0T2ZmICsgaGFsZkxlbiAtIGk7XG5cbiAgICAgICAgICAgICAgICAgICAgb3V0W1NBXSA9IFQxciArIC1pbnYgKiBUM2k7XG4gICAgICAgICAgICAgICAgICAgIG91dFtTQSArIDFdID0gLVQxaSAtIGludiAqIFQzcjtcbiAgICAgICAgICAgICAgICAgICAgb3V0W1NCXSA9IFQwciArIC1pbnYgKiBUMnI7XG4gICAgICAgICAgICAgICAgICAgIG91dFtTQiArIDFdID0gLVQwaSArIGludiAqIFQyaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtcyBhIHNpbmdsZSByZWFsIGlucHV0IHJhZGl4LTIgdHJhbnNmb3JtYXRpb24gb24gdGhlIHByb3ZpZGVkIGRhdGFcbiAgICAgKiBcbiAgICAgKiBAcGFyYW0ge0Zsb2F0MzJBcnJheX0gZGF0YSBUaGUgaW5wdXQgZGF0YSBhcnJheVxuICAgICAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fSBvdXQgVGhlIG91dHB1dCBkYXRhIGFycmF5XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG91dE9mZiBUaGUgb3V0cHV0IG9mZnNldFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvZmYgVGhlIGlucHV0IG9mZnNldFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGVwIFRoZSBzdGVwXG4gICAgICogXG4gICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICovXG4gICAgX3NpbmdsZVJlYWxUcmFuc2Zvcm0yKGRhdGEsIG91dCwgb3V0T2ZmLCBvZmYsIHN0ZXApIHtcbiAgICAgICAgLy8gcmFkaXgtMiBpbXBsZW1lbnRhdGlvblxuICAgICAgICAvLyBOT1RFOiBPbmx5IGNhbGxlZCBmb3IgbGVuPTRcblxuICAgICAgICBjb25zdCBldmVuUiA9IGRhdGFbb2ZmXTtcbiAgICAgICAgY29uc3Qgb2RkUiA9IGRhdGFbb2ZmICsgc3RlcF07XG5cbiAgICAgICAgb3V0W291dE9mZl0gPSBldmVuUiArIG9kZFI7XG4gICAgICAgIG91dFtvdXRPZmYgKyAxXSA9IDA7XG4gICAgICAgIG91dFtvdXRPZmYgKyAyXSA9IGV2ZW5SIC0gb2RkUjtcbiAgICAgICAgb3V0W291dE9mZiArIDNdID0gMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyBhIHNpbmdsZSByZWFsLXZhbHVlZCB0cmFuc2Zvcm0gdXNpbmcgcmFkaXgtNCBhbGdvcml0aG0uXG4gICAgICogVGhpcyBtZXRob2QgaXMgb25seSBjYWxsZWQgZm9yIGxlbj04LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtGbG9hdDMyQXJyYXl9IGRhdGEgVGhlIGlucHV0IGRhdGEgYXJyYXkuXG4gICAgICogQHBhcmFtIHtGbG9hdDMyQXJyYXl9IG91dCBUaGUgb3V0cHV0IGRhdGEgYXJyYXkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG91dE9mZiBUaGUgb2Zmc2V0IGludG8gdGhlIG91dHB1dCBhcnJheS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb2ZmIFRoZSBvZmZzZXQgaW50byB0aGUgaW5wdXQgYXJyYXkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0ZXAgVGhlIHN0ZXAgc2l6ZSBmb3IgdGhlIGlucHV0IGFycmF5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbnYgVGhlIHZhbHVlIG9mIGludmVyc2UuXG4gICAgICovXG4gICAgX3NpbmdsZVJlYWxUcmFuc2Zvcm00KGRhdGEsIG91dCwgb3V0T2ZmLCBvZmYsIHN0ZXAsIGludikge1xuICAgICAgICAvLyByYWRpeC00XG4gICAgICAgIC8vIE5PVEU6IE9ubHkgY2FsbGVkIGZvciBsZW49OFxuICAgICAgICBjb25zdCBzdGVwMiA9IHN0ZXAgKiAyO1xuICAgICAgICBjb25zdCBzdGVwMyA9IHN0ZXAgKiAzO1xuXG4gICAgICAgIC8vIE9yaWdpbmFsIHZhbHVlc1xuICAgICAgICBjb25zdCBBciA9IGRhdGFbb2ZmXTtcbiAgICAgICAgY29uc3QgQnIgPSBkYXRhW29mZiArIHN0ZXBdO1xuICAgICAgICBjb25zdCBDciA9IGRhdGFbb2ZmICsgc3RlcDJdO1xuICAgICAgICBjb25zdCBEciA9IGRhdGFbb2ZmICsgc3RlcDNdO1xuXG4gICAgICAgIC8vIFByZS1GaW5hbCB2YWx1ZXNcbiAgICAgICAgY29uc3QgVDByID0gQXIgKyBDcjtcbiAgICAgICAgY29uc3QgVDFyID0gQXIgLSBDcjtcbiAgICAgICAgY29uc3QgVDJyID0gQnIgKyBEcjtcbiAgICAgICAgY29uc3QgVDNyID0gaW52ICogKEJyIC0gRHIpO1xuXG4gICAgICAgIC8vIEZpbmFsIHZhbHVlc1xuICAgICAgICBvdXRbb3V0T2ZmXSA9IFQwciArIFQycjtcbiAgICAgICAgb3V0W291dE9mZiArIDFdID0gMDtcbiAgICAgICAgb3V0W291dE9mZiArIDJdID0gVDFyO1xuICAgICAgICBvdXRbb3V0T2ZmICsgM10gPSAtVDNyO1xuICAgICAgICBvdXRbb3V0T2ZmICsgNF0gPSBUMHIgLSBUMnI7XG4gICAgICAgIG91dFtvdXRPZmYgKyA1XSA9IDA7XG4gICAgICAgIG91dFtvdXRPZmYgKyA2XSA9IFQxcjtcbiAgICAgICAgb3V0W291dE9mZiArIDddID0gVDNyO1xuICAgIH1cbn1cblxuLyoqXG4gKiBQZXJmb3JtcyBtZWRpYW4gZmlsdGVyIG9uIHRoZSBwcm92aWRlZCBkYXRhLiBQYWRkaW5nIGlzIGRvbmUgYnkgbWlycm9yaW5nIHRoZSBkYXRhLlxuICogQHBhcmFtIHtBbnlUeXBlZEFycmF5fSBkYXRhIFRoZSBpbnB1dCBhcnJheVxuICogQHBhcmFtIHtudW1iZXJ9IHdpbmRvd1NpemUgVGhlIHdpbmRvdyBzaXplXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtZWRpYW5GaWx0ZXIoZGF0YSwgd2luZG93U2l6ZSkge1xuXG4gICAgaWYgKHdpbmRvd1NpemUgJSAyID09PSAwIHx8IHdpbmRvd1NpemUgPD0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dpbmRvdyBzaXplIG11c3QgYmUgYSBwb3NpdGl2ZSBvZGQgbnVtYmVyJyk7XG4gICAgfVxuXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGNvbnN0IG91dHB1dEFycmF5ID0gbmV3IGRhdGEuY29uc3RydWN0b3IoZGF0YS5sZW5ndGgpO1xuXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGNvbnN0IGJ1ZmZlciA9IG5ldyBkYXRhLmNvbnN0cnVjdG9yKHdpbmRvd1NpemUpOyAvLyBSZXVzYWJsZSBhcnJheSBmb3Igc3RvcmluZyB2YWx1ZXNcblxuICAgIGNvbnN0IGhhbGZXaW5kb3dTaXplID0gTWF0aC5mbG9vcih3aW5kb3dTaXplIC8gMik7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgbGV0IHZhbHVlc0luZGV4ID0gMDtcblxuICAgICAgICBmb3IgKGxldCBqID0gLWhhbGZXaW5kb3dTaXplOyBqIDw9IGhhbGZXaW5kb3dTaXplOyArK2opIHtcbiAgICAgICAgICAgIGxldCBpbmRleCA9IGkgKyBqO1xuICAgICAgICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gTWF0aC5hYnMoaW5kZXgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpbmRleCA+PSBkYXRhLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gMiAqIChkYXRhLmxlbmd0aCAtIDEpIC0gaW5kZXg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJ1ZmZlclt2YWx1ZXNJbmRleCsrXSA9IGRhdGFbaW5kZXhdO1xuICAgICAgICB9XG5cbiAgICAgICAgYnVmZmVyLnNvcnQoKTtcbiAgICAgICAgb3V0cHV0QXJyYXlbaV0gPSBidWZmZXJbaGFsZldpbmRvd1NpemVdO1xuICAgIH1cblxuICAgIHJldHVybiBvdXRwdXRBcnJheTtcbn1cblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdG8gcm91bmQgYSBudW1iZXIgdG8gYSBnaXZlbiBudW1iZXIgb2YgZGVjaW1hbHNcbiAqIEBwYXJhbSB7bnVtYmVyfSBudW0gVGhlIG51bWJlciB0byByb3VuZFxuICogQHBhcmFtIHtudW1iZXJ9IGRlY2ltYWxzIFRoZSBudW1iZXIgb2YgZGVjaW1hbHNcbiAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSByb3VuZGVkIG51bWJlclxuICovXG5leHBvcnQgZnVuY3Rpb24gcm91bmQobnVtLCBkZWNpbWFscykge1xuICAgIGNvbnN0IHBvdyA9IE1hdGgucG93KDEwLCBkZWNpbWFscyk7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobnVtICogcG93KSAvIHBvdztcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@xenova/transformers/src/utils/maths.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@xenova/transformers/src/utils/tensor.js":
/*!***************************************************************!*\
  !*** ./node_modules/@xenova/transformers/src/utils/tensor.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Tensor: function() { return /* binding */ Tensor; },\n/* harmony export */   cat: function() { return /* binding */ cat; },\n/* harmony export */   dynamicTimeWarping: function() { return /* binding */ dynamicTimeWarping; },\n/* harmony export */   interpolate: function() { return /* binding */ interpolate; },\n/* harmony export */   mean: function() { return /* binding */ mean; },\n/* harmony export */   mean_pooling: function() { return /* binding */ mean_pooling; },\n/* harmony export */   stack: function() { return /* binding */ stack; },\n/* harmony export */   std_mean: function() { return /* binding */ std_mean; },\n/* harmony export */   transpose: function() { return /* binding */ transpose; }\n/* harmony export */ });\n/* harmony import */ var _backends_onnx_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../backends/onnx.js */ \"(app-pages-browser)/./node_modules/@xenova/transformers/src/backends/onnx.js\");\n/* harmony import */ var _maths_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./maths.js */ \"(app-pages-browser)/./node_modules/@xenova/transformers/src/utils/maths.js\");\n/**\n * @file Helper module for `Tensor` processing.\n * \n * These functions and classes are only used internally, \n * meaning an end-user shouldn't need to access anything here.\n * \n * @module utils/tensor\n */\n\n\n\n\n\n\n/**\n * @typedef {import('./maths.js').AnyTypedArray} AnyTypedArray\n */\n\n/** @type {Object} */\nconst ONNXTensor = _backends_onnx_js__WEBPACK_IMPORTED_MODULE_0__.ONNX.Tensor;\n\nclass Tensor extends ONNXTensor {\n    /**\n     * Create a new Tensor or copy an existing Tensor.\n     * @param {[string, Array|AnyTypedArray, number[]]|[ONNXTensor]} args\n     */\n    constructor(...args) {\n        if (args[0] instanceof _backends_onnx_js__WEBPACK_IMPORTED_MODULE_0__.ONNX.Tensor) {\n            // Create shallow copy\n            super(args[0].type, args[0].data, args[0].dims);\n\n        } else {\n            // Create new\n            super(...args);\n        }\n\n        return new Proxy(this, {\n            get: (obj, key) => {\n                if (typeof key === 'string') {\n                    let index = Number(key);\n                    if (Number.isInteger(index)) {\n                        // key is an integer (i.e., index)\n                        return obj._getitem(index);\n                    }\n                }\n                // @ts-ignore\n                return obj[key];\n            },\n            set: (obj, key, value) => {\n                // TODO allow setting of data\n\n                // @ts-ignore\n                return obj[key] = value;\n            }\n        });\n    }\n\n    /**\n     * Returns an iterator object for iterating over the tensor data in row-major order.\n     * If the tensor has more than one dimension, the iterator will yield subarrays.\n     * @returns {Iterator} An iterator object for iterating over the tensor data in row-major order.\n     */\n    *[Symbol.iterator]() {\n        const [iterLength, ...iterDims] = this.dims;\n\n        if (iterDims.length > 0) {\n            const iterSize = iterDims.reduce((a, b) => a * b);\n            for (let i = 0; i < iterLength; ++i) {\n                yield this._subarray(i, iterSize, iterDims);\n            }\n        } else {\n            yield* this.data\n        }\n\n    }\n\n    /**\n     * Index into a Tensor object.\n     * @param {number} index The index to access.\n     * @returns {Tensor} The data at the specified index.\n     */\n    _getitem(index) {\n        const [iterLength, ...iterDims] = this.dims;\n\n        index = safeIndex(index, iterLength);\n\n        if (iterDims.length > 0) {\n            const iterSize = iterDims.reduce((a, b) => a * b);\n            return this._subarray(index, iterSize, iterDims);\n        } else {\n            return new Tensor(this.type, [this.data[index]], iterDims);\n        }\n    }\n\n    /**\n     * @param {number|bigint} item The item to search for in the tensor\n     * @returns {number} The index of the first occurrence of item in the tensor data.\n     */\n    indexOf(item) {\n        for (let index = 0; index < this.data.length; ++index) {\n            // Note: == instead of === so we can match Ints with BigInts\n            if (this.data[index] == item) {\n                return index;\n            }\n        }\n        return -1;\n    }\n\n    /**\n     * @param {number} index \n     * @param {number} iterSize \n     * @param {any} iterDims \n     * @returns {Tensor}\n     */\n    _subarray(index, iterSize, iterDims) {\n        let data = this.data.subarray(index * iterSize, (index + 1) * iterSize);\n        return new Tensor(this.type, data, iterDims);\n    }\n\n    /**\n     * Returns the value of this tensor as a standard JavaScript Number. This only works\n     * for tensors with one element. For other cases, see `Tensor.tolist()`.\n     * @returns {number} The value of this tensor as a standard JavaScript Number.\n     * @throws {Error} If the tensor has more than one element.\n     */\n    item() {\n        if (this.data.length !== 1) {\n            throw new Error(`a Tensor with ${this.data.length} elements cannot be converted to Scalar`);\n        }\n        return this.data[0];\n    }\n\n    /**\n     * Convert tensor data to a n-dimensional JS list\n     * @returns {Array}\n     */\n    tolist() {\n        return reshape(this.data, this.dims)\n    }\n\n    /**\n     * Return a new Tensor with the sigmoid function applied to each element.\n     * @returns {Tensor} The tensor with the sigmoid function applied.\n     */\n    sigmoid() {\n        return this.clone().sigmoid_();\n    }\n\n    /**\n     * Applies the sigmoid function to the tensor in place.\n     * @returns {Tensor} Returns `this`.\n     */\n    sigmoid_() {\n        for (let i = 0; i < this.data.length; ++i) {\n            this.data[i] = 1 / (1 + Math.exp(-this.data[i]));\n        }\n        return this;\n    }\n\n    clone() {\n        return new Tensor(this.type, this.data.slice(), this.dims.slice());\n    }\n\n    slice(...slices) {\n        // This allows for slicing with ranges and numbers\n        let newTensorDims = [];\n        let newOffsets = [];\n\n        // slices is an array of numbers or arrays of numbers\n        // e.g., slices = [0, [1, 3], null, [0, 3]]\n        for (let sliceIndex = 0; sliceIndex < this.dims.length; ++sliceIndex) {\n            let slice = slices[sliceIndex];\n\n            if (slice === null || slice === undefined) {\n                // null or undefined means take the whole dimension\n                newOffsets.push([0, this.dims[sliceIndex]]);\n                newTensorDims.push(this.dims[sliceIndex]);\n\n            } else if (typeof slice === 'number') {\n                slice = safeIndex(slice, this.dims[sliceIndex], sliceIndex);\n\n                // A number means take a single element\n                newOffsets.push([slice, slice + 1]);\n\n            } else if (Array.isArray(slice) && slice.length === 2) {\n                // An array of length 2 means take a range of elements\n\n                if (slice[0] > slice[1]) {\n                    throw new Error(`Invalid slice: ${slice}`);\n                }\n\n                let offsets = [\n                    Math.max(slice[0], 0),\n                    Math.min(slice[1], this.dims[sliceIndex])\n                ];\n\n                newOffsets.push(offsets);\n                newTensorDims.push(offsets[1] - offsets[0]);\n\n            } else {\n                throw new Error(`Invalid slice: ${slice}`);\n            }\n        }\n\n        let newDims = newOffsets.map(([start, end]) => end - start);\n        let newBufferSize = newDims.reduce((a, b) => a * b);\n\n        // Allocate memory\n        let data = new this.data.constructor(newBufferSize);\n\n        // Precompute strides\n        const stride = this.stride();\n\n        for (let i = 0; i < newBufferSize; ++i) {\n            let originalIndex = 0;\n            for (let j = newDims.length - 1, num = i; j >= 0; --j) {\n                const size = newDims[j];\n                originalIndex += ((num % size) + newOffsets[j][0]) * stride[j];\n                num = Math.floor(num / size);\n            }\n            data[i] = this.data[originalIndex];\n        }\n        return new Tensor(this.type, data, newTensorDims);\n\n    }\n\n    /**\n     * Return a transposed version of this Tensor, according to the provided dimensions.\n     * @param  {...number} dims Dimensions to transpose.\n     * @returns {Tensor} The transposed tensor.\n     */\n    transpose(...dims) {\n        return transpose(this, dims);\n    }\n\n    // TODO: rename transpose to permute\n    // TODO: implement transpose\n\n    // TODO add .max() and .min() methods\n\n    /**\n     * Returns the sum of each row of the input tensor in the given dimension dim.\n     * \n     * @param {number} [dim=null] The dimension or dimensions to reduce. If `null`, all dimensions are reduced.\n     * @param {boolean} keepdim Whether the output tensor has `dim` retained or not.\n     * @returns The summed tensor\n     */\n    sum(dim = null, keepdim = false) {\n        return this.norm(1, dim, keepdim);\n    }\n\n    /**\n     * Returns the matrix norm or vector norm of a given tensor.\n     * @param {number|string} [p='fro'] The order of norm\n     * @param {number} [dim=null] Specifies which dimension of the tensor to calculate the norm across.\n     * If dim is None, the norm will be calculated across all dimensions of input.\n     * @param {boolean} [keepdim=false] Whether the output tensors have dim retained or not.\n     * @returns {Tensor} The norm of the tensor.\n     */\n    norm(p = 'fro', dim = null, keepdim = false) {\n        if (p === 'fro') {\n            // NOTE: Since we only support integer dims, Frobenius norm produces the same result as p=2.\n            p = 2;\n        } else if (typeof p === 'string') {\n            throw Error(`Unsupported norm: ${p}`);\n        }\n\n        if (dim === null) {\n            // @ts-ignore\n            let val = this.data.reduce((a, b) => a + (b ** p), 0) ** (1 / p);\n            return new Tensor(this.type, [val], []);\n        }\n\n        // Negative indexing\n        dim = safeIndex(dim, this.dims.length);\n\n        // Calculate the shape of the resulting array after summation\n        const resultDims = this.dims.slice(); // Copy the original dimensions\n        resultDims[dim] = 1; // Remove the specified axis\n\n        // Create a new array to store the accumulated values\n        const result = new this.data.constructor(this.data.length / this.dims[dim]);\n\n        // Iterate over the data array\n        for (let i = 0; i < this.data.length; ++i) {\n\n            // Calculate the index in the resulting array\n            let resultIndex = 0;\n\n            for (let j = this.dims.length - 1, num = i, resultMultiplier = 1; j >= 0; --j) {\n                const size = this.dims[j];\n                if (j !== dim) {\n                    const index = num % size;\n                    resultIndex += index * resultMultiplier;\n                    resultMultiplier *= resultDims[j];\n                }\n                num = Math.floor(num / size);\n            }\n\n            // Accumulate the value at the current index\n            result[resultIndex] += (this.data[i]) ** p;\n        }\n\n        if (p !== 1) {\n            for (let i = 0; i < result.length; ++i) {\n                result[i] = result[i] ** (1 / p);\n            }\n        }\n\n        if (!keepdim) {\n            resultDims.splice(dim, 1);\n        }\n\n        return new Tensor(this.type, result, resultDims);\n    }\n\n    /**\n     * Performs `L_p` normalization of inputs over specified dimension. Operates in place.\n     * @param {number} [p=2] The exponent value in the norm formulation\n     * @param {number} [dim=1] The dimension to reduce\n     * @returns {Tensor} `this` for operation chaining.\n     */\n    normalize_(p = 2.0, dim = 1) {\n        dim = safeIndex(dim, this.dims.length);\n\n        const norm = this.norm(p, dim, true);\n\n        for (let i = 0; i < this.data.length; ++i) {\n\n            // Calculate the index in the resulting array\n            let resultIndex = 0;\n\n            for (let j = this.dims.length - 1, num = i, resultMultiplier = 1; j >= 0; --j) {\n                const size = this.dims[j];\n                if (j !== dim) {\n                    const index = num % size;\n                    resultIndex += index * resultMultiplier;\n                    resultMultiplier *= this.dims[j];\n                }\n                num = Math.floor(num / size);\n            }\n\n            // Divide by normalized value\n            this.data[i] /= norm.data[resultIndex];\n        }\n\n        return this;\n    }\n\n    /**\n     * Performs `L_p` normalization of inputs over specified dimension.\n     * @param {number} [p=2] The exponent value in the norm formulation\n     * @param {number} [dim=1] The dimension to reduce\n     * @returns {Tensor} The normalized tensor.\n     */\n    normalize(p = 2.0, dim = 1) {\n        return this.clone().normalize_(p, dim);\n    }\n\n    /**\n     * Compute and return the stride of this tensor.\n     * Stride is the jump necessary to go from one element to the next one in the specified dimension dim.\n     * @returns {number[]} The stride of this tensor.\n     */\n    stride() {\n        return dimsToStride(this.dims);\n    }\n\n    /**\n     * Returns a tensor with all specified dimensions of input of size 1 removed.\n     * \n     * NOTE: The returned tensor shares the storage with the input tensor, so changing the contents of one will change the contents of the other.\n     * If you would like a copy, use `tensor.clone()` before squeezing.\n     * \n     * @param {number} [dim=null] If given, the input will be squeezed only in the specified dimensions.\n     * @returns The squeezed tensor\n     */\n    squeeze(dim = null) {\n        return new Tensor(\n            this.type,\n            this.data,\n            calc_squeeze_dims(this.dims, dim)\n        )\n    }\n\n    /**\n     * In-place version of @see {@link Tensor.squeeze}\n     */\n    squeeze_(dim = null) {\n        this.dims = calc_squeeze_dims(this.dims, dim);\n        return this;\n    }\n\n    /**\n     * Returns a new tensor with a dimension of size one inserted at the specified position.\n     * \n     * NOTE: The returned tensor shares the same underlying data with this tensor.\n     * \n     * @param {number} dim The index at which to insert the singleton dimension\n     * @returns The unsqueezed tensor\n     */\n    unsqueeze(dim = null) {\n        return new Tensor(\n            this.type,\n            this.data,\n            calc_unsqueeze_dims(this.dims, dim)\n        );\n    }\n\n    /**\n     * In-place version of @see {@link Tensor.unsqueeze}\n     */\n    unsqueeze_(dim = null) {\n        this.dims = calc_unsqueeze_dims(this.dims, dim);\n        return this;\n    }\n\n    /**\n     * In-place version of @see {@link Tensor.flatten}\n     */\n    flatten_(start_dim = 0, end_dim = -1) {\n        // TODO validate inputs\n        end_dim = (end_dim + this.dims.length) % this.dims.length;\n\n        let dimsToKeepBefore = this.dims.slice(0, start_dim);\n        let dimsToFlatten = this.dims.slice(start_dim, end_dim + 1);\n        let dimsToKeepAfter = this.dims.slice(end_dim + 1);\n\n        this.dims = [...dimsToKeepBefore, dimsToFlatten.reduce((a, b) => a * b, 1), ...dimsToKeepAfter]\n        return this;\n    }\n\n    /**\n     * Flattens input by reshaping it into a one-dimensional tensor.\n     * If `start_dim` or `end_dim` are passed, only dimensions starting with `start_dim`\n     * and ending with `end_dim` are flattened. The order of elements in input is unchanged.\n     * @param {number} start_dim the first dim to flatten\n     * @param {number} end_dim the last dim to flatten\n     * @returns The flattened tensor.\n     */\n    flatten(start_dim = 0, end_dim = -1) {\n        return this.clone().flatten_(start_dim, end_dim);\n    }\n\n    /**\n     * Returns a new tensor with the same data as the `self` tensor but of a different `shape`.\n     * @param  {...number} dims the desired size\n     * @returns {Tensor} The tensor with the same data but different shape\n     */\n    view(...dims) {\n        // TODO: validate dims\n        let inferredIndex = -1;\n        for (let i = 0; i < dims.length; ++i) {\n            if (dims[i] === -1) {\n                if (inferredIndex !== -1) {\n                    throw new Error(\"Only one dimension can be inferred\");\n                }\n                inferredIndex = i;\n            }\n        }\n\n        if (inferredIndex !== -1) {\n            // Some dimension must be inferred\n            const productOther = dims.reduce((product, curr, index) => {\n                return index !== inferredIndex ? product * curr : product\n            }, 1);\n\n            dims[inferredIndex] = this.data.length / productOther;\n        }\n        return new Tensor(this.type, this.data, dims); // NOTE: uses same underlying storage\n    }\n\n    neg_() {\n        for (let i = 0; i < this.data.length; ++i) {\n            this.data[i] = -this.data[i];\n        }\n        return this;\n    }\n    neg() {\n        return this.clone().neg_();\n    }\n}\n\n/**\n * This creates a nested array of a given type and depth (see examples).\n * \n * @example\n *   NestArray<string, 1>; // string[]\n * @example\n *   NestArray<number, 2>; // number[][]\n * @example\n *   NestArray<string, 3>; // string[][][] etc.\n * @template T\n * @template {number} Depth\n * @template {never[]} [Acc=[]]\n * @typedef {Acc['length'] extends Depth ? T : NestArray<T[], Depth, [...Acc, never]>} NestArray\n */\n\n/**\n * Reshapes a 1-dimensional array into an n-dimensional array, according to the provided dimensions.\n *\n * @example\n *   reshape([10                    ], [1      ]); // Type: number[]      Value: [10]\n *   reshape([1, 2, 3, 4            ], [2, 2   ]); // Type: number[][]    Value: [[1, 2], [3, 4]]\n *   reshape([1, 2, 3, 4, 5, 6, 7, 8], [2, 2, 2]); // Type: number[][][]  Value: [[[1, 2], [3, 4]], [[5, 6], [7, 8]]]\n *   reshape([1, 2, 3, 4, 5, 6, 7, 8], [4, 2   ]); // Type: number[][]    Value: [[1, 2], [3, 4], [5, 6], [7, 8]]\n * @param {T[]} data The input array to reshape.\n * @param {DIM} dimensions The target shape/dimensions.\n * @template T\n * @template {[number]|[number, number]|[number, number, number]|[number, number, number, number]} DIM\n * @returns {NestArray<T, DIM[\"length\"]>} The reshaped array.\n */\nfunction reshape(data, dimensions) {\n\n    const totalElements = data.length;\n    const dimensionSize = dimensions.reduce((a, b) => a * b);\n\n    if (totalElements !== dimensionSize) {\n        throw Error(`cannot reshape array of size ${totalElements} into shape (${dimensions})`);\n    }\n\n    /** @type {any} */\n    let reshapedArray = data;\n\n    for (let i = dimensions.length - 1; i >= 0; i--) {\n        reshapedArray = reshapedArray.reduce((acc, val) => {\n            let lastArray = acc[acc.length - 1];\n\n            if (lastArray.length < dimensions[i]) {\n                lastArray.push(val);\n            } else {\n                acc.push([val]);\n            }\n\n            return acc;\n        }, [[]]);\n    }\n\n    return reshapedArray[0];\n}\n\n/**\n * Transposes a tensor according to the provided axes.\n * @param {any} tensor The input tensor to transpose.\n * @param {Array} axes The axes to transpose the tensor along.\n * @returns {Tensor} The transposed tensor.\n */\nfunction transpose(tensor, axes) {\n    const [transposedData, shape] = (0,_maths_js__WEBPACK_IMPORTED_MODULE_1__.transpose_data)(tensor.data, tensor.dims, axes);\n    return new Tensor(tensor.type, transposedData, shape);\n}\n\n\n/**\n * Interpolates an Tensor to the given size.\n * @param {Tensor} input The input tensor to interpolate. Data must be channel-first (i.e., [c, h, w])\n * @param {number[]} size The output size of the image\n * @param {string} mode The interpolation mode\n * @param {boolean} align_corners Whether to align corners.\n * @returns {Tensor} The interpolated tensor.\n */\nfunction interpolate(input, [out_height, out_width], mode = 'bilinear', align_corners = false) {\n\n    // Input image dimensions\n    const in_channels = input.dims.at(-3) ?? 1;\n    const in_height = input.dims.at(-2);\n    const in_width = input.dims.at(-1);\n\n    let output = (0,_maths_js__WEBPACK_IMPORTED_MODULE_1__.interpolate_data)(\n        input.data,\n        [in_channels, in_height, in_width],\n        [out_height, out_width],\n        mode,\n        align_corners\n    );\n    return new Tensor(input.type, output, [in_channels, out_height, out_width]);\n}\n\n/**\n * Perform mean pooling of the last hidden state followed by a normalization step.\n * @param {Tensor} last_hidden_state Tensor of shape [batchSize, seqLength, embedDim]\n * @param {Tensor} attention_mask Tensor of shape [batchSize, seqLength]\n * @returns {Tensor} Returns a new Tensor of shape [batchSize, embedDim].\n */\nfunction mean_pooling(last_hidden_state, attention_mask) {\n    // last_hidden_state: [batchSize, seqLength, embedDim]\n    // attention_mask:    [batchSize, seqLength]\n\n    let shape = [last_hidden_state.dims[0], last_hidden_state.dims[2]];\n    let returnedData = new last_hidden_state.data.constructor(shape[0] * shape[1]);\n    let [batchSize, seqLength, embedDim] = last_hidden_state.dims;\n\n    let outIndex = 0;\n    for (let i = 0; i < batchSize; ++i) {\n        let offset = i * embedDim * seqLength;\n\n        for (let k = 0; k < embedDim; ++k) {\n            let sum = 0;\n            let count = 0;\n\n            let attnMaskOffset = i * seqLength;\n            let offset2 = offset + k;\n            // Pool over all words in sequence\n            for (let j = 0; j < seqLength; ++j) {\n                // index into attention mask\n                let attn = Number(attention_mask.data[attnMaskOffset + j]);\n\n                count += attn;\n                sum += last_hidden_state.data[offset2 + j * embedDim] * attn;\n            }\n\n            let avg = sum / count;\n            returnedData[outIndex++] = avg;\n        }\n    }\n\n    return new Tensor(\n        last_hidden_state.type,\n        returnedData,\n        shape\n    )\n}\n\n/**\n * Helper function to calculate new dimensions when performing a squeeze operation.\n * @param {number[]} dims The dimensions of the tensor.\n * @param {number|number[]|null} dim The dimension(s) to squeeze.\n * @returns The new dimensions.\n * @private\n */\nfunction calc_squeeze_dims(dims, dim) {\n    dims = dims.slice();\n    if (dim === null) {\n        dims = dims.filter((d) => d !== 1);\n    } else if (typeof dim === 'number') {\n        if (dims[dim] === 1) {\n            dims.splice(dim, 1);\n        }\n    } else if (Array.isArray(dim)) {\n        dims = dims.filter((x, i) => {\n            return x !== 1 || !dim.includes(i);\n        });\n    }\n    return dims;\n}\n\n/**\n * Helper function to calculate new dimensions when performing an unsqueeze operation.\n * @param {number[]} dims The dimensions of the tensor.\n * @param {number} dim The dimension to unsqueeze.\n * @returns The new dimensions.\n * @private\n */\nfunction calc_unsqueeze_dims(dims, dim) {\n    // Dimension out of range (e.g., \"expected to be in range of [-4, 3], but got 4\")\n    // + 1 since we allow inserting at the end (i.e. dim = -1)\n    dim = safeIndex(dim, dims.length + 1);\n    dims = dims.slice();\n    // Insert 1 into specified dimension\n    dims.splice(dim, 0, 1);\n    return dims;\n}\n\n/**\n * Safely calculate the index for an array of a given size, allowing negative indexing.\n * @param {number} index The index that will be used.\n * @param {number} size The size of the array.\n * @param {number} [dimension=null] The dimension that the index is for (optional).\n * @returns {number} The index, guaranteed to be non-negative and less than `arrayLength`.\n * \n * @throws {Error} If the index is out of range.\n * @private\n */\nfunction safeIndex(index, size, dimension = null) {\n    if (index < -size || index >= size) {\n        throw new Error(`IndexError: index ${index} is out of bounds for dimension${dimension === null ? '' : ' ' + dimension} with size ${size}`);\n    }\n\n    if (index < 0) {\n        // Negative indexing, ensuring positive index\n        index = ((index % size) + size) % size;\n    }\n    return index;\n}\n\n/**\n * Concatenates an array of tensors along a specified dimension.\n * @param {Tensor[]} tensors The array of tensors to concatenate.\n * @param {number} dim The dimension to concatenate along.\n * @returns {Tensor} The concatenated tensor.\n */\nfunction cat(tensors, dim = 0) {\n    dim = safeIndex(dim, tensors[0].dims.length);\n\n    // TODO do validation of shapes\n\n    const resultDims = tensors[0].dims.slice();\n    resultDims[dim] = tensors.reduce((a, b) => a + b.dims[dim], 0);\n\n    // Create a new array to store the accumulated values\n    const resultSize = resultDims.reduce((a, b) => a * b, 1);\n    const result = new tensors[0].data.constructor(resultSize);\n\n    // Create output tensor of same type as first\n    const resultType = tensors[0].type;\n\n    if (dim === 0) {\n        // Handle special case for performance reasons\n\n        let offset = 0;\n        for (let t of tensors) {\n            result.set(t.data, offset);\n            offset += t.data.length;\n        }\n\n    } else {\n\n        let currentDim = 0;\n\n        for (let t = 0; t < tensors.length; ++t) {\n            let tensor = tensors[t];\n\n            // Iterate over the data array\n            for (let i = 0; i < tensor.data.length; ++i) {\n                // Calculate the index in the resulting array\n                let resultIndex = 0;\n\n                for (let j = tensor.dims.length - 1, num = i, resultMultiplier = 1; j >= 0; --j) {\n                    const size = tensor.dims[j];\n                    let index = num % size;\n                    if (j === dim) {\n                        index += currentDim;\n                    }\n                    resultIndex += index * resultMultiplier;\n                    resultMultiplier *= resultDims[j];\n                    num = Math.floor(num / size);\n                }\n                // Accumulate the value at the current index\n                result[resultIndex] = tensor.data[i];\n            }\n\n            currentDim += tensor.dims[dim];\n        }\n    }\n    return new Tensor(resultType, result, resultDims);\n}\n\n/**\n * Stack an array of tensors along a specified dimension.\n * @param {Tensor[]} tensors The array of tensors to stack.\n * @param {number} dim The dimension to stack along.\n * @returns {Tensor} The stacked tensor.\n */\nfunction stack(tensors, dim = 0) {\n    // TODO do validation of shapes\n    // NOTE: stack expects each tensor to be equal size\n    return cat(tensors.map(t => t.unsqueeze(dim)), dim);\n}\n\n\n/**\n * Calculates the standard deviation and mean over the dimensions specified by dim. dim can be a single dimension or `null` to reduce over all dimensions.\n * @param {Tensor} input the input tenso\n * @param {number|null} dim the dimension to reduce. If None, all dimensions are reduced.\n * @param {number} correction difference between the sample size and sample degrees of freedom. Defaults to Bessel's correction, correction=1.\n * @param {boolean} keepdim whether the output tensor has dim retained or not.\n * @returns {Tensor[]} A tuple of (std, mean) tensors.\n */\nfunction std_mean(input, dim = null, correction = 1, keepdim = false) {\n\n    if (dim === null) {\n        // None to reduce over all dimensions.\n        const sum = input.data.reduce((a, b) => a + b, 0);\n        const mean = sum / input.data.length;\n        const std = Math.sqrt(input.data.reduce((a, b) => a + (b - mean) ** 2, 0) / (input.data.length - correction));\n\n        const meanTensor = new Tensor(input.type, [mean], [/* scalar */]);\n        const stdTensor = new Tensor(input.type, [std], [/* scalar */]);\n\n        return [stdTensor, meanTensor];\n    }\n\n    // Negative indexing\n    dim = safeIndex(dim, input.dims.length);\n\n    const meanTensor = mean(input, dim, keepdim);\n\n    // Calculate the shape of the resulting array after summation\n    const resultDims = input.dims.slice(); // Copy the original dimensions\n    resultDims[dim] = 1; // Remove the specified axis\n\n    // Create a new array to store the accumulated values\n    const result = new input.data.constructor(input.data.length / input.dims[dim]);\n\n    // Iterate over the data array\n    for (let i = 0; i < input.data.length; ++i) {\n\n        // Calculate the index in the resulting array\n        let resultIndex = 0;\n\n        for (let j = input.dims.length - 1, num = i, resultMultiplier = 1; j >= 0; --j) {\n            const size = input.dims[j];\n            if (j !== dim) {\n                const index = num % size;\n                resultIndex += index * resultMultiplier;\n                resultMultiplier *= resultDims[j];\n            }\n            num = Math.floor(num / size);\n        }\n\n        // Accumulate the value at the current index\n        result[resultIndex] += (input.data[i] - meanTensor.data[resultIndex]) ** 2;\n    }\n\n    for (let i = 0; i < result.length; ++i) {\n        result[i] = Math.sqrt(result[i] / (input.dims[dim] - correction));\n    }\n\n    if (!keepdim) {\n        resultDims.splice(dim, 1);\n    }\n\n    const stdTensor = new Tensor(input.type, result, resultDims);\n\n    return [stdTensor, meanTensor];\n}\n\n\n/**\n * Returns the mean value of each row of the input tensor in the given dimension dim.\n * @param {Tensor} input the input tensor.\n * @param {number|null} dim the dimension to reduce.\n * @param {boolean} keepdim whether the output tensor has dim retained or not.\n * @returns A new tensor with means taken along the specified dimension.\n */\nfunction mean(input, dim = null, keepdim = false) {\n\n    if (dim === null) {\n        // None to reduce over all dimensions.\n        let val = input.data.reduce((a, b) => a + b, 0);\n        return new Tensor(input.type, [val / input.data.length], [/* scalar */]);\n    }\n\n    // Negative indexing\n    dim = safeIndex(dim, input.dims.length);\n\n    // Calculate the shape of the resulting array after summation\n    const resultDims = input.dims.slice(); // Copy the original dimensions\n    resultDims[dim] = 1; // Remove the specified axis\n\n    // Create a new array to store the accumulated values\n    const result = new input.data.constructor(input.data.length / input.dims[dim]);\n\n    // Iterate over the data array\n    for (let i = 0; i < input.data.length; ++i) {\n\n        // Calculate the index in the resulting array\n        let resultIndex = 0;\n\n        for (let j = input.dims.length - 1, num = i, resultMultiplier = 1; j >= 0; --j) {\n            const size = input.dims[j];\n            if (j !== dim) {\n                const index = num % size;\n                resultIndex += index * resultMultiplier;\n                resultMultiplier *= resultDims[j];\n            }\n            num = Math.floor(num / size);\n        }\n\n        // Accumulate the value at the current index\n        result[resultIndex] += input.data[i];\n    }\n\n    if (input.dims[dim] !== 1) {\n        for (let i = 0; i < result.length; ++i) {\n            result[i] = result[i] / input.dims[dim];\n        }\n    }\n\n    if (!keepdim) {\n        resultDims.splice(dim, 1);\n    }\n\n    return new Tensor(input.type, result, resultDims);\n}\n\n\n/**\n *\n * Measures similarity between two temporal sequences (e.g., input audio and output tokens\n * to generate token-level timestamps).\n * @param {Tensor} matrix \n * @returns {number[][]}\n */\nfunction dynamicTimeWarping(matrix) {\n    const [output_length, input_length] = matrix.dims;\n\n    const outputShape = [output_length + 1, input_length + 1];\n\n    const cost = new Tensor(\n        'float32',\n        new Float32Array(outputShape[0] * outputShape[1]).fill(Infinity),\n        outputShape\n    );\n\n    const trace = new Tensor(\n        'float32',\n        new Float32Array(outputShape[0] * outputShape[1]).fill(-1),\n        outputShape\n    )\n\n    // same as `cost[0][0] = 0`;\n    cost[0].data[0] = 0;\n\n    for (let j = 1; j < input_length + 1; ++j) {\n        for (let i = 1; i < output_length + 1; ++i) {\n\n            const c0 = cost[i - 1][j - 1].item();\n            const c1 = cost[i - 1][j].item();\n            const c2 = cost[i][j - 1].item();\n\n            let c, t;\n            if (c0 < c1 && c0 < c2) {\n                c = c0;\n                t = 0;\n            } else if (c1 < c0 && c1 < c2) {\n                c = c1;\n                t = 1;\n            } else {\n                c = c2;\n                t = 2;\n            }\n\n            cost[i].data[j] = matrix[i - 1][j - 1].item() + c;\n            trace[i].data[j] = t;\n        }\n    }\n\n    // backtrace\n    let i = output_length;\n    let j = input_length;\n\n    trace.data.fill(2, 0, outputShape[1]) // trace[0, :] = 2\n    for (let i = 0; i < outputShape[0]; ++i) { // trace[:, 0] = 1\n        trace[i].data[0] = 1;\n    }\n\n    let text_indices = [];\n    let time_indices = [];\n\n    while (i > 0 || j > 0) {\n        text_indices.push(i - 1);\n        time_indices.push(j - 1);\n\n        const t = trace[i][j].item();\n        switch (t) {\n            case 0:\n                --i; --j;\n                break;\n            case 1:\n                --i;\n                break;\n            case 2:\n                --j;\n                break;\n            default:\n                throw new Error(\n                    `Internal error in dynamic time warping. Unexpected trace[${i}, ${j}]. Please file a bug report.`\n                )\n        }\n    }\n\n    text_indices.reverse();\n    time_indices.reverse();\n\n    return [text_indices, time_indices];\n\n}\n\nfunction dimsToStride(dims) {\n    const stride = new Array(dims.length);\n    for (let i = dims.length - 1, s2 = 1; i >= 0; --i) {\n        stride[i] = s2;\n        s2 *= dims[i];\n    }\n    return stride;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AeGVub3ZhL3RyYW5zZm9ybWVycy9zcmMvdXRpbHMvdGVuc29yLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFMkM7O0FBS3ZCOzs7QUFHcEI7QUFDQSxhQUFhLG9DQUFvQztBQUNqRDs7QUFFQSxXQUFXLFFBQVE7QUFDbkIsbUJBQW1CLG1EQUFJOztBQUVoQjtBQUNQO0FBQ0E7QUFDQSxlQUFlLHNEQUFzRDtBQUNyRTtBQUNBO0FBQ0EsK0JBQStCLG1EQUFJO0FBQ25DO0FBQ0E7O0FBRUEsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixVQUFVO0FBQzNCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNEJBQTRCLGdCQUFnQjtBQUM1QztBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsZUFBZTtBQUM5QixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0EsNEJBQTRCLDBCQUEwQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxLQUFLO0FBQ3BCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixR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QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDJDQUEyQztBQUMzQyx5QkFBeUI7O0FBRXpCO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsdUJBQXVCOztBQUUzQztBQUNBOztBQUVBLDJFQUEyRSxRQUFRO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCLG1CQUFtQjtBQUMzQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNPO0FBQ1A7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsb0JBQW9CLHNCQUFzQjtBQUMxQyx3QkFBd0IsdUJBQXVCOztBQUUvQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLG9CQUFvQixPQUFPO0FBQy9DO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdGQUFnRixFQUFFLElBQUksRUFBRTtBQUN4RjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsMENBQTBDLFFBQVE7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHhlbm92YS90cmFuc2Zvcm1lcnMvc3JjL3V0aWxzL3RlbnNvci5qcz8yZmIwIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGZpbGUgSGVscGVyIG1vZHVsZSBmb3IgYFRlbnNvcmAgcHJvY2Vzc2luZy5cbiAqIFxuICogVGhlc2UgZnVuY3Rpb25zIGFuZCBjbGFzc2VzIGFyZSBvbmx5IHVzZWQgaW50ZXJuYWxseSwgXG4gKiBtZWFuaW5nIGFuIGVuZC11c2VyIHNob3VsZG4ndCBuZWVkIHRvIGFjY2VzcyBhbnl0aGluZyBoZXJlLlxuICogXG4gKiBAbW9kdWxlIHV0aWxzL3RlbnNvclxuICovXG5cbmltcG9ydCB7IE9OTlggfSBmcm9tICcuLi9iYWNrZW5kcy9vbm54LmpzJztcblxuaW1wb3J0IHtcbiAgICBpbnRlcnBvbGF0ZV9kYXRhLFxuICAgIHRyYW5zcG9zZV9kYXRhXG59IGZyb20gJy4vbWF0aHMuanMnO1xuXG5cbi8qKlxuICogQHR5cGVkZWYge2ltcG9ydCgnLi9tYXRocy5qcycpLkFueVR5cGVkQXJyYXl9IEFueVR5cGVkQXJyYXlcbiAqL1xuXG4vKiogQHR5cGUge09iamVjdH0gKi9cbmNvbnN0IE9OTlhUZW5zb3IgPSBPTk5YLlRlbnNvcjtcblxuZXhwb3J0IGNsYXNzIFRlbnNvciBleHRlbmRzIE9OTlhUZW5zb3Ige1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBUZW5zb3Igb3IgY29weSBhbiBleGlzdGluZyBUZW5zb3IuXG4gICAgICogQHBhcmFtIHtbc3RyaW5nLCBBcnJheXxBbnlUeXBlZEFycmF5LCBudW1iZXJbXV18W09OTlhUZW5zb3JdfSBhcmdzXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgICAgICBpZiAoYXJnc1swXSBpbnN0YW5jZW9mIE9OTlguVGVuc29yKSB7XG4gICAgICAgICAgICAvLyBDcmVhdGUgc2hhbGxvdyBjb3B5XG4gICAgICAgICAgICBzdXBlcihhcmdzWzBdLnR5cGUsIGFyZ3NbMF0uZGF0YSwgYXJnc1swXS5kaW1zKTtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gQ3JlYXRlIG5ld1xuICAgICAgICAgICAgc3VwZXIoLi4uYXJncyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3IFByb3h5KHRoaXMsIHtcbiAgICAgICAgICAgIGdldDogKG9iaiwga2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBpbmRleCA9IE51bWJlcihrZXkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoTnVtYmVyLmlzSW50ZWdlcihpbmRleCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGtleSBpcyBhbiBpbnRlZ2VyIChpLmUuLCBpbmRleClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvYmouX2dldGl0ZW0oaW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqW2tleV07XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0OiAob2JqLCBrZXksIHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gVE9ETyBhbGxvdyBzZXR0aW5nIG9mIGRhdGFcblxuICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBpdGVyYXRvciBvYmplY3QgZm9yIGl0ZXJhdGluZyBvdmVyIHRoZSB0ZW5zb3IgZGF0YSBpbiByb3ctbWFqb3Igb3JkZXIuXG4gICAgICogSWYgdGhlIHRlbnNvciBoYXMgbW9yZSB0aGFuIG9uZSBkaW1lbnNpb24sIHRoZSBpdGVyYXRvciB3aWxsIHlpZWxkIHN1YmFycmF5cy5cbiAgICAgKiBAcmV0dXJucyB7SXRlcmF0b3J9IEFuIGl0ZXJhdG9yIG9iamVjdCBmb3IgaXRlcmF0aW5nIG92ZXIgdGhlIHRlbnNvciBkYXRhIGluIHJvdy1tYWpvciBvcmRlci5cbiAgICAgKi9cbiAgICAqW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgICAgIGNvbnN0IFtpdGVyTGVuZ3RoLCAuLi5pdGVyRGltc10gPSB0aGlzLmRpbXM7XG5cbiAgICAgICAgaWYgKGl0ZXJEaW1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGl0ZXJTaXplID0gaXRlckRpbXMucmVkdWNlKChhLCBiKSA9PiBhICogYik7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGl0ZXJMZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMuX3N1YmFycmF5KGksIGl0ZXJTaXplLCBpdGVyRGltcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB5aWVsZCogdGhpcy5kYXRhXG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluZGV4IGludG8gYSBUZW5zb3Igb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBUaGUgaW5kZXggdG8gYWNjZXNzLlxuICAgICAqIEByZXR1cm5zIHtUZW5zb3J9IFRoZSBkYXRhIGF0IHRoZSBzcGVjaWZpZWQgaW5kZXguXG4gICAgICovXG4gICAgX2dldGl0ZW0oaW5kZXgpIHtcbiAgICAgICAgY29uc3QgW2l0ZXJMZW5ndGgsIC4uLml0ZXJEaW1zXSA9IHRoaXMuZGltcztcblxuICAgICAgICBpbmRleCA9IHNhZmVJbmRleChpbmRleCwgaXRlckxlbmd0aCk7XG5cbiAgICAgICAgaWYgKGl0ZXJEaW1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGl0ZXJTaXplID0gaXRlckRpbXMucmVkdWNlKChhLCBiKSA9PiBhICogYik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc3ViYXJyYXkoaW5kZXgsIGl0ZXJTaXplLCBpdGVyRGltcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFRlbnNvcih0aGlzLnR5cGUsIFt0aGlzLmRhdGFbaW5kZXhdXSwgaXRlckRpbXMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtudW1iZXJ8YmlnaW50fSBpdGVtIFRoZSBpdGVtIHRvIHNlYXJjaCBmb3IgaW4gdGhlIHRlbnNvclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSBpbmRleCBvZiB0aGUgZmlyc3Qgb2NjdXJyZW5jZSBvZiBpdGVtIGluIHRoZSB0ZW5zb3IgZGF0YS5cbiAgICAgKi9cbiAgICBpbmRleE9mKGl0ZW0pIHtcbiAgICAgICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IHRoaXMuZGF0YS5sZW5ndGg7ICsraW5kZXgpIHtcbiAgICAgICAgICAgIC8vIE5vdGU6ID09IGluc3RlYWQgb2YgPT09IHNvIHdlIGNhbiBtYXRjaCBJbnRzIHdpdGggQmlnSW50c1xuICAgICAgICAgICAgaWYgKHRoaXMuZGF0YVtpbmRleF0gPT0gaXRlbSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpdGVyU2l6ZSBcbiAgICAgKiBAcGFyYW0ge2FueX0gaXRlckRpbXMgXG4gICAgICogQHJldHVybnMge1RlbnNvcn1cbiAgICAgKi9cbiAgICBfc3ViYXJyYXkoaW5kZXgsIGl0ZXJTaXplLCBpdGVyRGltcykge1xuICAgICAgICBsZXQgZGF0YSA9IHRoaXMuZGF0YS5zdWJhcnJheShpbmRleCAqIGl0ZXJTaXplLCAoaW5kZXggKyAxKSAqIGl0ZXJTaXplKTtcbiAgICAgICAgcmV0dXJuIG5ldyBUZW5zb3IodGhpcy50eXBlLCBkYXRhLCBpdGVyRGltcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgdmFsdWUgb2YgdGhpcyB0ZW5zb3IgYXMgYSBzdGFuZGFyZCBKYXZhU2NyaXB0IE51bWJlci4gVGhpcyBvbmx5IHdvcmtzXG4gICAgICogZm9yIHRlbnNvcnMgd2l0aCBvbmUgZWxlbWVudC4gRm9yIG90aGVyIGNhc2VzLCBzZWUgYFRlbnNvci50b2xpc3QoKWAuXG4gICAgICogQHJldHVybnMge251bWJlcn0gVGhlIHZhbHVlIG9mIHRoaXMgdGVuc29yIGFzIGEgc3RhbmRhcmQgSmF2YVNjcmlwdCBOdW1iZXIuXG4gICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSB0ZW5zb3IgaGFzIG1vcmUgdGhhbiBvbmUgZWxlbWVudC5cbiAgICAgKi9cbiAgICBpdGVtKCkge1xuICAgICAgICBpZiAodGhpcy5kYXRhLmxlbmd0aCAhPT0gMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBhIFRlbnNvciB3aXRoICR7dGhpcy5kYXRhLmxlbmd0aH0gZWxlbWVudHMgY2Fubm90IGJlIGNvbnZlcnRlZCB0byBTY2FsYXJgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5kYXRhWzBdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnQgdGVuc29yIGRhdGEgdG8gYSBuLWRpbWVuc2lvbmFsIEpTIGxpc3RcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9XG4gICAgICovXG4gICAgdG9saXN0KCkge1xuICAgICAgICByZXR1cm4gcmVzaGFwZSh0aGlzLmRhdGEsIHRoaXMuZGltcylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSBuZXcgVGVuc29yIHdpdGggdGhlIHNpZ21vaWQgZnVuY3Rpb24gYXBwbGllZCB0byBlYWNoIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge1RlbnNvcn0gVGhlIHRlbnNvciB3aXRoIHRoZSBzaWdtb2lkIGZ1bmN0aW9uIGFwcGxpZWQuXG4gICAgICovXG4gICAgc2lnbW9pZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5zaWdtb2lkXygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFwcGxpZXMgdGhlIHNpZ21vaWQgZnVuY3Rpb24gdG8gdGhlIHRlbnNvciBpbiBwbGFjZS5cbiAgICAgKiBAcmV0dXJucyB7VGVuc29yfSBSZXR1cm5zIGB0aGlzYC5cbiAgICAgKi9cbiAgICBzaWdtb2lkXygpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmRhdGEubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHRoaXMuZGF0YVtpXSA9IDEgLyAoMSArIE1hdGguZXhwKC10aGlzLmRhdGFbaV0pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBjbG9uZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUZW5zb3IodGhpcy50eXBlLCB0aGlzLmRhdGEuc2xpY2UoKSwgdGhpcy5kaW1zLnNsaWNlKCkpO1xuICAgIH1cblxuICAgIHNsaWNlKC4uLnNsaWNlcykge1xuICAgICAgICAvLyBUaGlzIGFsbG93cyBmb3Igc2xpY2luZyB3aXRoIHJhbmdlcyBhbmQgbnVtYmVyc1xuICAgICAgICBsZXQgbmV3VGVuc29yRGltcyA9IFtdO1xuICAgICAgICBsZXQgbmV3T2Zmc2V0cyA9IFtdO1xuXG4gICAgICAgIC8vIHNsaWNlcyBpcyBhbiBhcnJheSBvZiBudW1iZXJzIG9yIGFycmF5cyBvZiBudW1iZXJzXG4gICAgICAgIC8vIGUuZy4sIHNsaWNlcyA9IFswLCBbMSwgM10sIG51bGwsIFswLCAzXV1cbiAgICAgICAgZm9yIChsZXQgc2xpY2VJbmRleCA9IDA7IHNsaWNlSW5kZXggPCB0aGlzLmRpbXMubGVuZ3RoOyArK3NsaWNlSW5kZXgpIHtcbiAgICAgICAgICAgIGxldCBzbGljZSA9IHNsaWNlc1tzbGljZUluZGV4XTtcblxuICAgICAgICAgICAgaWYgKHNsaWNlID09PSBudWxsIHx8IHNsaWNlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBudWxsIG9yIHVuZGVmaW5lZCBtZWFucyB0YWtlIHRoZSB3aG9sZSBkaW1lbnNpb25cbiAgICAgICAgICAgICAgICBuZXdPZmZzZXRzLnB1c2goWzAsIHRoaXMuZGltc1tzbGljZUluZGV4XV0pO1xuICAgICAgICAgICAgICAgIG5ld1RlbnNvckRpbXMucHVzaCh0aGlzLmRpbXNbc2xpY2VJbmRleF0pO1xuXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBzbGljZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICBzbGljZSA9IHNhZmVJbmRleChzbGljZSwgdGhpcy5kaW1zW3NsaWNlSW5kZXhdLCBzbGljZUluZGV4KTtcblxuICAgICAgICAgICAgICAgIC8vIEEgbnVtYmVyIG1lYW5zIHRha2UgYSBzaW5nbGUgZWxlbWVudFxuICAgICAgICAgICAgICAgIG5ld09mZnNldHMucHVzaChbc2xpY2UsIHNsaWNlICsgMV0pO1xuXG4gICAgICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoc2xpY2UpICYmIHNsaWNlLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgICAgIC8vIEFuIGFycmF5IG9mIGxlbmd0aCAyIG1lYW5zIHRha2UgYSByYW5nZSBvZiBlbGVtZW50c1xuXG4gICAgICAgICAgICAgICAgaWYgKHNsaWNlWzBdID4gc2xpY2VbMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHNsaWNlOiAke3NsaWNlfWApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGxldCBvZmZzZXRzID0gW1xuICAgICAgICAgICAgICAgICAgICBNYXRoLm1heChzbGljZVswXSwgMCksXG4gICAgICAgICAgICAgICAgICAgIE1hdGgubWluKHNsaWNlWzFdLCB0aGlzLmRpbXNbc2xpY2VJbmRleF0pXG4gICAgICAgICAgICAgICAgXTtcblxuICAgICAgICAgICAgICAgIG5ld09mZnNldHMucHVzaChvZmZzZXRzKTtcbiAgICAgICAgICAgICAgICBuZXdUZW5zb3JEaW1zLnB1c2gob2Zmc2V0c1sxXSAtIG9mZnNldHNbMF0pO1xuXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBzbGljZTogJHtzbGljZX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBuZXdEaW1zID0gbmV3T2Zmc2V0cy5tYXAoKFtzdGFydCwgZW5kXSkgPT4gZW5kIC0gc3RhcnQpO1xuICAgICAgICBsZXQgbmV3QnVmZmVyU2l6ZSA9IG5ld0RpbXMucmVkdWNlKChhLCBiKSA9PiBhICogYik7XG5cbiAgICAgICAgLy8gQWxsb2NhdGUgbWVtb3J5XG4gICAgICAgIGxldCBkYXRhID0gbmV3IHRoaXMuZGF0YS5jb25zdHJ1Y3RvcihuZXdCdWZmZXJTaXplKTtcblxuICAgICAgICAvLyBQcmVjb21wdXRlIHN0cmlkZXNcbiAgICAgICAgY29uc3Qgc3RyaWRlID0gdGhpcy5zdHJpZGUoKTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5ld0J1ZmZlclNpemU7ICsraSkge1xuICAgICAgICAgICAgbGV0IG9yaWdpbmFsSW5kZXggPSAwO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IG5ld0RpbXMubGVuZ3RoIC0gMSwgbnVtID0gaTsgaiA+PSAwOyAtLWopIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzaXplID0gbmV3RGltc1tqXTtcbiAgICAgICAgICAgICAgICBvcmlnaW5hbEluZGV4ICs9ICgobnVtICUgc2l6ZSkgKyBuZXdPZmZzZXRzW2pdWzBdKSAqIHN0cmlkZVtqXTtcbiAgICAgICAgICAgICAgICBudW0gPSBNYXRoLmZsb29yKG51bSAvIHNpemUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGF0YVtpXSA9IHRoaXMuZGF0YVtvcmlnaW5hbEluZGV4XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFRlbnNvcih0aGlzLnR5cGUsIGRhdGEsIG5ld1RlbnNvckRpbXMpO1xuXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIGEgdHJhbnNwb3NlZCB2ZXJzaW9uIG9mIHRoaXMgVGVuc29yLCBhY2NvcmRpbmcgdG8gdGhlIHByb3ZpZGVkIGRpbWVuc2lvbnMuXG4gICAgICogQHBhcmFtICB7Li4ubnVtYmVyfSBkaW1zIERpbWVuc2lvbnMgdG8gdHJhbnNwb3NlLlxuICAgICAqIEByZXR1cm5zIHtUZW5zb3J9IFRoZSB0cmFuc3Bvc2VkIHRlbnNvci5cbiAgICAgKi9cbiAgICB0cmFuc3Bvc2UoLi4uZGltcykge1xuICAgICAgICByZXR1cm4gdHJhbnNwb3NlKHRoaXMsIGRpbXMpO1xuICAgIH1cblxuICAgIC8vIFRPRE86IHJlbmFtZSB0cmFuc3Bvc2UgdG8gcGVybXV0ZVxuICAgIC8vIFRPRE86IGltcGxlbWVudCB0cmFuc3Bvc2VcblxuICAgIC8vIFRPRE8gYWRkIC5tYXgoKSBhbmQgLm1pbigpIG1ldGhvZHNcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHN1bSBvZiBlYWNoIHJvdyBvZiB0aGUgaW5wdXQgdGVuc29yIGluIHRoZSBnaXZlbiBkaW1lbnNpb24gZGltLlxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZGltPW51bGxdIFRoZSBkaW1lbnNpb24gb3IgZGltZW5zaW9ucyB0byByZWR1Y2UuIElmIGBudWxsYCwgYWxsIGRpbWVuc2lvbnMgYXJlIHJlZHVjZWQuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBrZWVwZGltIFdoZXRoZXIgdGhlIG91dHB1dCB0ZW5zb3IgaGFzIGBkaW1gIHJldGFpbmVkIG9yIG5vdC5cbiAgICAgKiBAcmV0dXJucyBUaGUgc3VtbWVkIHRlbnNvclxuICAgICAqL1xuICAgIHN1bShkaW0gPSBudWxsLCBrZWVwZGltID0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubm9ybSgxLCBkaW0sIGtlZXBkaW0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG1hdHJpeCBub3JtIG9yIHZlY3RvciBub3JtIG9mIGEgZ2l2ZW4gdGVuc29yLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gW3A9J2ZybyddIFRoZSBvcmRlciBvZiBub3JtXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtkaW09bnVsbF0gU3BlY2lmaWVzIHdoaWNoIGRpbWVuc2lvbiBvZiB0aGUgdGVuc29yIHRvIGNhbGN1bGF0ZSB0aGUgbm9ybSBhY3Jvc3MuXG4gICAgICogSWYgZGltIGlzIE5vbmUsIHRoZSBub3JtIHdpbGwgYmUgY2FsY3VsYXRlZCBhY3Jvc3MgYWxsIGRpbWVuc2lvbnMgb2YgaW5wdXQuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBba2VlcGRpbT1mYWxzZV0gV2hldGhlciB0aGUgb3V0cHV0IHRlbnNvcnMgaGF2ZSBkaW0gcmV0YWluZWQgb3Igbm90LlxuICAgICAqIEByZXR1cm5zIHtUZW5zb3J9IFRoZSBub3JtIG9mIHRoZSB0ZW5zb3IuXG4gICAgICovXG4gICAgbm9ybShwID0gJ2ZybycsIGRpbSA9IG51bGwsIGtlZXBkaW0gPSBmYWxzZSkge1xuICAgICAgICBpZiAocCA9PT0gJ2ZybycpIHtcbiAgICAgICAgICAgIC8vIE5PVEU6IFNpbmNlIHdlIG9ubHkgc3VwcG9ydCBpbnRlZ2VyIGRpbXMsIEZyb2Jlbml1cyBub3JtIHByb2R1Y2VzIHRoZSBzYW1lIHJlc3VsdCBhcyBwPTIuXG4gICAgICAgICAgICBwID0gMjtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgcCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKGBVbnN1cHBvcnRlZCBub3JtOiAke3B9YCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGltID09PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBsZXQgdmFsID0gdGhpcy5kYXRhLnJlZHVjZSgoYSwgYikgPT4gYSArIChiICoqIHApLCAwKSAqKiAoMSAvIHApO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBUZW5zb3IodGhpcy50eXBlLCBbdmFsXSwgW10pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTmVnYXRpdmUgaW5kZXhpbmdcbiAgICAgICAgZGltID0gc2FmZUluZGV4KGRpbSwgdGhpcy5kaW1zLmxlbmd0aCk7XG5cbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBzaGFwZSBvZiB0aGUgcmVzdWx0aW5nIGFycmF5IGFmdGVyIHN1bW1hdGlvblxuICAgICAgICBjb25zdCByZXN1bHREaW1zID0gdGhpcy5kaW1zLnNsaWNlKCk7IC8vIENvcHkgdGhlIG9yaWdpbmFsIGRpbWVuc2lvbnNcbiAgICAgICAgcmVzdWx0RGltc1tkaW1dID0gMTsgLy8gUmVtb3ZlIHRoZSBzcGVjaWZpZWQgYXhpc1xuXG4gICAgICAgIC8vIENyZWF0ZSBhIG5ldyBhcnJheSB0byBzdG9yZSB0aGUgYWNjdW11bGF0ZWQgdmFsdWVzXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyB0aGlzLmRhdGEuY29uc3RydWN0b3IodGhpcy5kYXRhLmxlbmd0aCAvIHRoaXMuZGltc1tkaW1dKTtcblxuICAgICAgICAvLyBJdGVyYXRlIG92ZXIgdGhlIGRhdGEgYXJyYXlcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmRhdGEubGVuZ3RoOyArK2kpIHtcblxuICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBpbmRleCBpbiB0aGUgcmVzdWx0aW5nIGFycmF5XG4gICAgICAgICAgICBsZXQgcmVzdWx0SW5kZXggPSAwO1xuXG4gICAgICAgICAgICBmb3IgKGxldCBqID0gdGhpcy5kaW1zLmxlbmd0aCAtIDEsIG51bSA9IGksIHJlc3VsdE11bHRpcGxpZXIgPSAxOyBqID49IDA7IC0taikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNpemUgPSB0aGlzLmRpbXNbal07XG4gICAgICAgICAgICAgICAgaWYgKGogIT09IGRpbSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpbmRleCA9IG51bSAlIHNpemU7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdEluZGV4ICs9IGluZGV4ICogcmVzdWx0TXVsdGlwbGllcjtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0TXVsdGlwbGllciAqPSByZXN1bHREaW1zW2pdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBudW0gPSBNYXRoLmZsb29yKG51bSAvIHNpemUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBBY2N1bXVsYXRlIHRoZSB2YWx1ZSBhdCB0aGUgY3VycmVudCBpbmRleFxuICAgICAgICAgICAgcmVzdWx0W3Jlc3VsdEluZGV4XSArPSAodGhpcy5kYXRhW2ldKSAqKiBwO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHAgIT09IDEpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVzdWx0Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W2ldID0gcmVzdWx0W2ldICoqICgxIC8gcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWtlZXBkaW0pIHtcbiAgICAgICAgICAgIHJlc3VsdERpbXMuc3BsaWNlKGRpbSwgMSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3IFRlbnNvcih0aGlzLnR5cGUsIHJlc3VsdCwgcmVzdWx0RGltcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGVyZm9ybXMgYExfcGAgbm9ybWFsaXphdGlvbiBvZiBpbnB1dHMgb3ZlciBzcGVjaWZpZWQgZGltZW5zaW9uLiBPcGVyYXRlcyBpbiBwbGFjZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3A9Ml0gVGhlIGV4cG9uZW50IHZhbHVlIGluIHRoZSBub3JtIGZvcm11bGF0aW9uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtkaW09MV0gVGhlIGRpbWVuc2lvbiB0byByZWR1Y2VcbiAgICAgKiBAcmV0dXJucyB7VGVuc29yfSBgdGhpc2AgZm9yIG9wZXJhdGlvbiBjaGFpbmluZy5cbiAgICAgKi9cbiAgICBub3JtYWxpemVfKHAgPSAyLjAsIGRpbSA9IDEpIHtcbiAgICAgICAgZGltID0gc2FmZUluZGV4KGRpbSwgdGhpcy5kaW1zLmxlbmd0aCk7XG5cbiAgICAgICAgY29uc3Qgbm9ybSA9IHRoaXMubm9ybShwLCBkaW0sIHRydWUpO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5kYXRhLmxlbmd0aDsgKytpKSB7XG5cbiAgICAgICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgaW5kZXggaW4gdGhlIHJlc3VsdGluZyBhcnJheVxuICAgICAgICAgICAgbGV0IHJlc3VsdEluZGV4ID0gMDtcblxuICAgICAgICAgICAgZm9yIChsZXQgaiA9IHRoaXMuZGltcy5sZW5ndGggLSAxLCBudW0gPSBpLCByZXN1bHRNdWx0aXBsaWVyID0gMTsgaiA+PSAwOyAtLWopIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzaXplID0gdGhpcy5kaW1zW2pdO1xuICAgICAgICAgICAgICAgIGlmIChqICE9PSBkaW0pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5kZXggPSBudW0gJSBzaXplO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRJbmRleCArPSBpbmRleCAqIHJlc3VsdE11bHRpcGxpZXI7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdE11bHRpcGxpZXIgKj0gdGhpcy5kaW1zW2pdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBudW0gPSBNYXRoLmZsb29yKG51bSAvIHNpemUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBEaXZpZGUgYnkgbm9ybWFsaXplZCB2YWx1ZVxuICAgICAgICAgICAgdGhpcy5kYXRhW2ldIC89IG5vcm0uZGF0YVtyZXN1bHRJbmRleF07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtcyBgTF9wYCBub3JtYWxpemF0aW9uIG9mIGlucHV0cyBvdmVyIHNwZWNpZmllZCBkaW1lbnNpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtwPTJdIFRoZSBleHBvbmVudCB2YWx1ZSBpbiB0aGUgbm9ybSBmb3JtdWxhdGlvblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZGltPTFdIFRoZSBkaW1lbnNpb24gdG8gcmVkdWNlXG4gICAgICogQHJldHVybnMge1RlbnNvcn0gVGhlIG5vcm1hbGl6ZWQgdGVuc29yLlxuICAgICAqL1xuICAgIG5vcm1hbGl6ZShwID0gMi4wLCBkaW0gPSAxKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsb25lKCkubm9ybWFsaXplXyhwLCBkaW0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbXB1dGUgYW5kIHJldHVybiB0aGUgc3RyaWRlIG9mIHRoaXMgdGVuc29yLlxuICAgICAqIFN0cmlkZSBpcyB0aGUganVtcCBuZWNlc3NhcnkgdG8gZ28gZnJvbSBvbmUgZWxlbWVudCB0byB0aGUgbmV4dCBvbmUgaW4gdGhlIHNwZWNpZmllZCBkaW1lbnNpb24gZGltLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJbXX0gVGhlIHN0cmlkZSBvZiB0aGlzIHRlbnNvci5cbiAgICAgKi9cbiAgICBzdHJpZGUoKSB7XG4gICAgICAgIHJldHVybiBkaW1zVG9TdHJpZGUodGhpcy5kaW1zKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgdGVuc29yIHdpdGggYWxsIHNwZWNpZmllZCBkaW1lbnNpb25zIG9mIGlucHV0IG9mIHNpemUgMSByZW1vdmVkLlxuICAgICAqIFxuICAgICAqIE5PVEU6IFRoZSByZXR1cm5lZCB0ZW5zb3Igc2hhcmVzIHRoZSBzdG9yYWdlIHdpdGggdGhlIGlucHV0IHRlbnNvciwgc28gY2hhbmdpbmcgdGhlIGNvbnRlbnRzIG9mIG9uZSB3aWxsIGNoYW5nZSB0aGUgY29udGVudHMgb2YgdGhlIG90aGVyLlxuICAgICAqIElmIHlvdSB3b3VsZCBsaWtlIGEgY29weSwgdXNlIGB0ZW5zb3IuY2xvbmUoKWAgYmVmb3JlIHNxdWVlemluZy5cbiAgICAgKiBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2RpbT1udWxsXSBJZiBnaXZlbiwgdGhlIGlucHV0IHdpbGwgYmUgc3F1ZWV6ZWQgb25seSBpbiB0aGUgc3BlY2lmaWVkIGRpbWVuc2lvbnMuXG4gICAgICogQHJldHVybnMgVGhlIHNxdWVlemVkIHRlbnNvclxuICAgICAqL1xuICAgIHNxdWVlemUoZGltID0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbmV3IFRlbnNvcihcbiAgICAgICAgICAgIHRoaXMudHlwZSxcbiAgICAgICAgICAgIHRoaXMuZGF0YSxcbiAgICAgICAgICAgIGNhbGNfc3F1ZWV6ZV9kaW1zKHRoaXMuZGltcywgZGltKVxuICAgICAgICApXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW4tcGxhY2UgdmVyc2lvbiBvZiBAc2VlIHtAbGluayBUZW5zb3Iuc3F1ZWV6ZX1cbiAgICAgKi9cbiAgICBzcXVlZXplXyhkaW0gPSBudWxsKSB7XG4gICAgICAgIHRoaXMuZGltcyA9IGNhbGNfc3F1ZWV6ZV9kaW1zKHRoaXMuZGltcywgZGltKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIG5ldyB0ZW5zb3Igd2l0aCBhIGRpbWVuc2lvbiBvZiBzaXplIG9uZSBpbnNlcnRlZCBhdCB0aGUgc3BlY2lmaWVkIHBvc2l0aW9uLlxuICAgICAqIFxuICAgICAqIE5PVEU6IFRoZSByZXR1cm5lZCB0ZW5zb3Igc2hhcmVzIHRoZSBzYW1lIHVuZGVybHlpbmcgZGF0YSB3aXRoIHRoaXMgdGVuc29yLlxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkaW0gVGhlIGluZGV4IGF0IHdoaWNoIHRvIGluc2VydCB0aGUgc2luZ2xldG9uIGRpbWVuc2lvblxuICAgICAqIEByZXR1cm5zIFRoZSB1bnNxdWVlemVkIHRlbnNvclxuICAgICAqL1xuICAgIHVuc3F1ZWV6ZShkaW0gPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBuZXcgVGVuc29yKFxuICAgICAgICAgICAgdGhpcy50eXBlLFxuICAgICAgICAgICAgdGhpcy5kYXRhLFxuICAgICAgICAgICAgY2FsY191bnNxdWVlemVfZGltcyh0aGlzLmRpbXMsIGRpbSlcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbi1wbGFjZSB2ZXJzaW9uIG9mIEBzZWUge0BsaW5rIFRlbnNvci51bnNxdWVlemV9XG4gICAgICovXG4gICAgdW5zcXVlZXplXyhkaW0gPSBudWxsKSB7XG4gICAgICAgIHRoaXMuZGltcyA9IGNhbGNfdW5zcXVlZXplX2RpbXModGhpcy5kaW1zLCBkaW0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbi1wbGFjZSB2ZXJzaW9uIG9mIEBzZWUge0BsaW5rIFRlbnNvci5mbGF0dGVufVxuICAgICAqL1xuICAgIGZsYXR0ZW5fKHN0YXJ0X2RpbSA9IDAsIGVuZF9kaW0gPSAtMSkge1xuICAgICAgICAvLyBUT0RPIHZhbGlkYXRlIGlucHV0c1xuICAgICAgICBlbmRfZGltID0gKGVuZF9kaW0gKyB0aGlzLmRpbXMubGVuZ3RoKSAlIHRoaXMuZGltcy5sZW5ndGg7XG5cbiAgICAgICAgbGV0IGRpbXNUb0tlZXBCZWZvcmUgPSB0aGlzLmRpbXMuc2xpY2UoMCwgc3RhcnRfZGltKTtcbiAgICAgICAgbGV0IGRpbXNUb0ZsYXR0ZW4gPSB0aGlzLmRpbXMuc2xpY2Uoc3RhcnRfZGltLCBlbmRfZGltICsgMSk7XG4gICAgICAgIGxldCBkaW1zVG9LZWVwQWZ0ZXIgPSB0aGlzLmRpbXMuc2xpY2UoZW5kX2RpbSArIDEpO1xuXG4gICAgICAgIHRoaXMuZGltcyA9IFsuLi5kaW1zVG9LZWVwQmVmb3JlLCBkaW1zVG9GbGF0dGVuLnJlZHVjZSgoYSwgYikgPT4gYSAqIGIsIDEpLCAuLi5kaW1zVG9LZWVwQWZ0ZXJdXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZsYXR0ZW5zIGlucHV0IGJ5IHJlc2hhcGluZyBpdCBpbnRvIGEgb25lLWRpbWVuc2lvbmFsIHRlbnNvci5cbiAgICAgKiBJZiBgc3RhcnRfZGltYCBvciBgZW5kX2RpbWAgYXJlIHBhc3NlZCwgb25seSBkaW1lbnNpb25zIHN0YXJ0aW5nIHdpdGggYHN0YXJ0X2RpbWBcbiAgICAgKiBhbmQgZW5kaW5nIHdpdGggYGVuZF9kaW1gIGFyZSBmbGF0dGVuZWQuIFRoZSBvcmRlciBvZiBlbGVtZW50cyBpbiBpbnB1dCBpcyB1bmNoYW5nZWQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0X2RpbSB0aGUgZmlyc3QgZGltIHRvIGZsYXR0ZW5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZW5kX2RpbSB0aGUgbGFzdCBkaW0gdG8gZmxhdHRlblxuICAgICAqIEByZXR1cm5zIFRoZSBmbGF0dGVuZWQgdGVuc29yLlxuICAgICAqL1xuICAgIGZsYXR0ZW4oc3RhcnRfZGltID0gMCwgZW5kX2RpbSA9IC0xKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsb25lKCkuZmxhdHRlbl8oc3RhcnRfZGltLCBlbmRfZGltKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbmV3IHRlbnNvciB3aXRoIHRoZSBzYW1lIGRhdGEgYXMgdGhlIGBzZWxmYCB0ZW5zb3IgYnV0IG9mIGEgZGlmZmVyZW50IGBzaGFwZWAuXG4gICAgICogQHBhcmFtICB7Li4ubnVtYmVyfSBkaW1zIHRoZSBkZXNpcmVkIHNpemVcbiAgICAgKiBAcmV0dXJucyB7VGVuc29yfSBUaGUgdGVuc29yIHdpdGggdGhlIHNhbWUgZGF0YSBidXQgZGlmZmVyZW50IHNoYXBlXG4gICAgICovXG4gICAgdmlldyguLi5kaW1zKSB7XG4gICAgICAgIC8vIFRPRE86IHZhbGlkYXRlIGRpbXNcbiAgICAgICAgbGV0IGluZmVycmVkSW5kZXggPSAtMTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkaW1zLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBpZiAoZGltc1tpXSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5mZXJyZWRJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiT25seSBvbmUgZGltZW5zaW9uIGNhbiBiZSBpbmZlcnJlZFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaW5mZXJyZWRJbmRleCA9IGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaW5mZXJyZWRJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgIC8vIFNvbWUgZGltZW5zaW9uIG11c3QgYmUgaW5mZXJyZWRcbiAgICAgICAgICAgIGNvbnN0IHByb2R1Y3RPdGhlciA9IGRpbXMucmVkdWNlKChwcm9kdWN0LCBjdXJyLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBpbmRleCAhPT0gaW5mZXJyZWRJbmRleCA/IHByb2R1Y3QgKiBjdXJyIDogcHJvZHVjdFxuICAgICAgICAgICAgfSwgMSk7XG5cbiAgICAgICAgICAgIGRpbXNbaW5mZXJyZWRJbmRleF0gPSB0aGlzLmRhdGEubGVuZ3RoIC8gcHJvZHVjdE90aGVyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgVGVuc29yKHRoaXMudHlwZSwgdGhpcy5kYXRhLCBkaW1zKTsgLy8gTk9URTogdXNlcyBzYW1lIHVuZGVybHlpbmcgc3RvcmFnZVxuICAgIH1cblxuICAgIG5lZ18oKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5kYXRhLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB0aGlzLmRhdGFbaV0gPSAtdGhpcy5kYXRhW2ldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBuZWcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsb25lKCkubmVnXygpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBUaGlzIGNyZWF0ZXMgYSBuZXN0ZWQgYXJyYXkgb2YgYSBnaXZlbiB0eXBlIGFuZCBkZXB0aCAoc2VlIGV4YW1wbGVzKS5cbiAqIFxuICogQGV4YW1wbGVcbiAqICAgTmVzdEFycmF5PHN0cmluZywgMT47IC8vIHN0cmluZ1tdXG4gKiBAZXhhbXBsZVxuICogICBOZXN0QXJyYXk8bnVtYmVyLCAyPjsgLy8gbnVtYmVyW11bXVxuICogQGV4YW1wbGVcbiAqICAgTmVzdEFycmF5PHN0cmluZywgMz47IC8vIHN0cmluZ1tdW11bXSBldGMuXG4gKiBAdGVtcGxhdGUgVFxuICogQHRlbXBsYXRlIHtudW1iZXJ9IERlcHRoXG4gKiBAdGVtcGxhdGUge25ldmVyW119IFtBY2M9W11dXG4gKiBAdHlwZWRlZiB7QWNjWydsZW5ndGgnXSBleHRlbmRzIERlcHRoID8gVCA6IE5lc3RBcnJheTxUW10sIERlcHRoLCBbLi4uQWNjLCBuZXZlcl0+fSBOZXN0QXJyYXlcbiAqL1xuXG4vKipcbiAqIFJlc2hhcGVzIGEgMS1kaW1lbnNpb25hbCBhcnJheSBpbnRvIGFuIG4tZGltZW5zaW9uYWwgYXJyYXksIGFjY29yZGluZyB0byB0aGUgcHJvdmlkZWQgZGltZW5zaW9ucy5cbiAqXG4gKiBAZXhhbXBsZVxuICogICByZXNoYXBlKFsxMCAgICAgICAgICAgICAgICAgICAgXSwgWzEgICAgICBdKTsgLy8gVHlwZTogbnVtYmVyW10gICAgICBWYWx1ZTogWzEwXVxuICogICByZXNoYXBlKFsxLCAyLCAzLCA0ICAgICAgICAgICAgXSwgWzIsIDIgICBdKTsgLy8gVHlwZTogbnVtYmVyW11bXSAgICBWYWx1ZTogW1sxLCAyXSwgWzMsIDRdXVxuICogICByZXNoYXBlKFsxLCAyLCAzLCA0LCA1LCA2LCA3LCA4XSwgWzIsIDIsIDJdKTsgLy8gVHlwZTogbnVtYmVyW11bXVtdICBWYWx1ZTogW1tbMSwgMl0sIFszLCA0XV0sIFtbNSwgNl0sIFs3LCA4XV1dXG4gKiAgIHJlc2hhcGUoWzEsIDIsIDMsIDQsIDUsIDYsIDcsIDhdLCBbNCwgMiAgIF0pOyAvLyBUeXBlOiBudW1iZXJbXVtdICAgIFZhbHVlOiBbWzEsIDJdLCBbMywgNF0sIFs1LCA2XSwgWzcsIDhdXVxuICogQHBhcmFtIHtUW119IGRhdGEgVGhlIGlucHV0IGFycmF5IHRvIHJlc2hhcGUuXG4gKiBAcGFyYW0ge0RJTX0gZGltZW5zaW9ucyBUaGUgdGFyZ2V0IHNoYXBlL2RpbWVuc2lvbnMuXG4gKiBAdGVtcGxhdGUgVFxuICogQHRlbXBsYXRlIHtbbnVtYmVyXXxbbnVtYmVyLCBudW1iZXJdfFtudW1iZXIsIG51bWJlciwgbnVtYmVyXXxbbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyXX0gRElNXG4gKiBAcmV0dXJucyB7TmVzdEFycmF5PFQsIERJTVtcImxlbmd0aFwiXT59IFRoZSByZXNoYXBlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gcmVzaGFwZShkYXRhLCBkaW1lbnNpb25zKSB7XG5cbiAgICBjb25zdCB0b3RhbEVsZW1lbnRzID0gZGF0YS5sZW5ndGg7XG4gICAgY29uc3QgZGltZW5zaW9uU2l6ZSA9IGRpbWVuc2lvbnMucmVkdWNlKChhLCBiKSA9PiBhICogYik7XG5cbiAgICBpZiAodG90YWxFbGVtZW50cyAhPT0gZGltZW5zaW9uU2l6ZSkge1xuICAgICAgICB0aHJvdyBFcnJvcihgY2Fubm90IHJlc2hhcGUgYXJyYXkgb2Ygc2l6ZSAke3RvdGFsRWxlbWVudHN9IGludG8gc2hhcGUgKCR7ZGltZW5zaW9uc30pYCk7XG4gICAgfVxuXG4gICAgLyoqIEB0eXBlIHthbnl9ICovXG4gICAgbGV0IHJlc2hhcGVkQXJyYXkgPSBkYXRhO1xuXG4gICAgZm9yIChsZXQgaSA9IGRpbWVuc2lvbnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgcmVzaGFwZWRBcnJheSA9IHJlc2hhcGVkQXJyYXkucmVkdWNlKChhY2MsIHZhbCkgPT4ge1xuICAgICAgICAgICAgbGV0IGxhc3RBcnJheSA9IGFjY1thY2MubGVuZ3RoIC0gMV07XG5cbiAgICAgICAgICAgIGlmIChsYXN0QXJyYXkubGVuZ3RoIDwgZGltZW5zaW9uc1tpXSkge1xuICAgICAgICAgICAgICAgIGxhc3RBcnJheS5wdXNoKHZhbCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGFjYy5wdXNoKFt2YWxdKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgfSwgW1tdXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc2hhcGVkQXJyYXlbMF07XG59XG5cbi8qKlxuICogVHJhbnNwb3NlcyBhIHRlbnNvciBhY2NvcmRpbmcgdG8gdGhlIHByb3ZpZGVkIGF4ZXMuXG4gKiBAcGFyYW0ge2FueX0gdGVuc29yIFRoZSBpbnB1dCB0ZW5zb3IgdG8gdHJhbnNwb3NlLlxuICogQHBhcmFtIHtBcnJheX0gYXhlcyBUaGUgYXhlcyB0byB0cmFuc3Bvc2UgdGhlIHRlbnNvciBhbG9uZy5cbiAqIEByZXR1cm5zIHtUZW5zb3J9IFRoZSB0cmFuc3Bvc2VkIHRlbnNvci5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zcG9zZSh0ZW5zb3IsIGF4ZXMpIHtcbiAgICBjb25zdCBbdHJhbnNwb3NlZERhdGEsIHNoYXBlXSA9IHRyYW5zcG9zZV9kYXRhKHRlbnNvci5kYXRhLCB0ZW5zb3IuZGltcywgYXhlcyk7XG4gICAgcmV0dXJuIG5ldyBUZW5zb3IodGVuc29yLnR5cGUsIHRyYW5zcG9zZWREYXRhLCBzaGFwZSk7XG59XG5cblxuLyoqXG4gKiBJbnRlcnBvbGF0ZXMgYW4gVGVuc29yIHRvIHRoZSBnaXZlbiBzaXplLlxuICogQHBhcmFtIHtUZW5zb3J9IGlucHV0IFRoZSBpbnB1dCB0ZW5zb3IgdG8gaW50ZXJwb2xhdGUuIERhdGEgbXVzdCBiZSBjaGFubmVsLWZpcnN0IChpLmUuLCBbYywgaCwgd10pXG4gKiBAcGFyYW0ge251bWJlcltdfSBzaXplIFRoZSBvdXRwdXQgc2l6ZSBvZiB0aGUgaW1hZ2VcbiAqIEBwYXJhbSB7c3RyaW5nfSBtb2RlIFRoZSBpbnRlcnBvbGF0aW9uIG1vZGVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gYWxpZ25fY29ybmVycyBXaGV0aGVyIHRvIGFsaWduIGNvcm5lcnMuXG4gKiBAcmV0dXJucyB7VGVuc29yfSBUaGUgaW50ZXJwb2xhdGVkIHRlbnNvci5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGludGVycG9sYXRlKGlucHV0LCBbb3V0X2hlaWdodCwgb3V0X3dpZHRoXSwgbW9kZSA9ICdiaWxpbmVhcicsIGFsaWduX2Nvcm5lcnMgPSBmYWxzZSkge1xuXG4gICAgLy8gSW5wdXQgaW1hZ2UgZGltZW5zaW9uc1xuICAgIGNvbnN0IGluX2NoYW5uZWxzID0gaW5wdXQuZGltcy5hdCgtMykgPz8gMTtcbiAgICBjb25zdCBpbl9oZWlnaHQgPSBpbnB1dC5kaW1zLmF0KC0yKTtcbiAgICBjb25zdCBpbl93aWR0aCA9IGlucHV0LmRpbXMuYXQoLTEpO1xuXG4gICAgbGV0IG91dHB1dCA9IGludGVycG9sYXRlX2RhdGEoXG4gICAgICAgIGlucHV0LmRhdGEsXG4gICAgICAgIFtpbl9jaGFubmVscywgaW5faGVpZ2h0LCBpbl93aWR0aF0sXG4gICAgICAgIFtvdXRfaGVpZ2h0LCBvdXRfd2lkdGhdLFxuICAgICAgICBtb2RlLFxuICAgICAgICBhbGlnbl9jb3JuZXJzXG4gICAgKTtcbiAgICByZXR1cm4gbmV3IFRlbnNvcihpbnB1dC50eXBlLCBvdXRwdXQsIFtpbl9jaGFubmVscywgb3V0X2hlaWdodCwgb3V0X3dpZHRoXSk7XG59XG5cbi8qKlxuICogUGVyZm9ybSBtZWFuIHBvb2xpbmcgb2YgdGhlIGxhc3QgaGlkZGVuIHN0YXRlIGZvbGxvd2VkIGJ5IGEgbm9ybWFsaXphdGlvbiBzdGVwLlxuICogQHBhcmFtIHtUZW5zb3J9IGxhc3RfaGlkZGVuX3N0YXRlIFRlbnNvciBvZiBzaGFwZSBbYmF0Y2hTaXplLCBzZXFMZW5ndGgsIGVtYmVkRGltXVxuICogQHBhcmFtIHtUZW5zb3J9IGF0dGVudGlvbl9tYXNrIFRlbnNvciBvZiBzaGFwZSBbYmF0Y2hTaXplLCBzZXFMZW5ndGhdXG4gKiBAcmV0dXJucyB7VGVuc29yfSBSZXR1cm5zIGEgbmV3IFRlbnNvciBvZiBzaGFwZSBbYmF0Y2hTaXplLCBlbWJlZERpbV0uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtZWFuX3Bvb2xpbmcobGFzdF9oaWRkZW5fc3RhdGUsIGF0dGVudGlvbl9tYXNrKSB7XG4gICAgLy8gbGFzdF9oaWRkZW5fc3RhdGU6IFtiYXRjaFNpemUsIHNlcUxlbmd0aCwgZW1iZWREaW1dXG4gICAgLy8gYXR0ZW50aW9uX21hc2s6ICAgIFtiYXRjaFNpemUsIHNlcUxlbmd0aF1cblxuICAgIGxldCBzaGFwZSA9IFtsYXN0X2hpZGRlbl9zdGF0ZS5kaW1zWzBdLCBsYXN0X2hpZGRlbl9zdGF0ZS5kaW1zWzJdXTtcbiAgICBsZXQgcmV0dXJuZWREYXRhID0gbmV3IGxhc3RfaGlkZGVuX3N0YXRlLmRhdGEuY29uc3RydWN0b3Ioc2hhcGVbMF0gKiBzaGFwZVsxXSk7XG4gICAgbGV0IFtiYXRjaFNpemUsIHNlcUxlbmd0aCwgZW1iZWREaW1dID0gbGFzdF9oaWRkZW5fc3RhdGUuZGltcztcblxuICAgIGxldCBvdXRJbmRleCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBiYXRjaFNpemU7ICsraSkge1xuICAgICAgICBsZXQgb2Zmc2V0ID0gaSAqIGVtYmVkRGltICogc2VxTGVuZ3RoO1xuXG4gICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgZW1iZWREaW07ICsraykge1xuICAgICAgICAgICAgbGV0IHN1bSA9IDA7XG4gICAgICAgICAgICBsZXQgY291bnQgPSAwO1xuXG4gICAgICAgICAgICBsZXQgYXR0bk1hc2tPZmZzZXQgPSBpICogc2VxTGVuZ3RoO1xuICAgICAgICAgICAgbGV0IG9mZnNldDIgPSBvZmZzZXQgKyBrO1xuICAgICAgICAgICAgLy8gUG9vbCBvdmVyIGFsbCB3b3JkcyBpbiBzZXF1ZW5jZVxuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBzZXFMZW5ndGg7ICsraikge1xuICAgICAgICAgICAgICAgIC8vIGluZGV4IGludG8gYXR0ZW50aW9uIG1hc2tcbiAgICAgICAgICAgICAgICBsZXQgYXR0biA9IE51bWJlcihhdHRlbnRpb25fbWFzay5kYXRhW2F0dG5NYXNrT2Zmc2V0ICsgal0pO1xuXG4gICAgICAgICAgICAgICAgY291bnQgKz0gYXR0bjtcbiAgICAgICAgICAgICAgICBzdW0gKz0gbGFzdF9oaWRkZW5fc3RhdGUuZGF0YVtvZmZzZXQyICsgaiAqIGVtYmVkRGltXSAqIGF0dG47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxldCBhdmcgPSBzdW0gLyBjb3VudDtcbiAgICAgICAgICAgIHJldHVybmVkRGF0YVtvdXRJbmRleCsrXSA9IGF2ZztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBuZXcgVGVuc29yKFxuICAgICAgICBsYXN0X2hpZGRlbl9zdGF0ZS50eXBlLFxuICAgICAgICByZXR1cm5lZERhdGEsXG4gICAgICAgIHNoYXBlXG4gICAgKVxufVxuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0byBjYWxjdWxhdGUgbmV3IGRpbWVuc2lvbnMgd2hlbiBwZXJmb3JtaW5nIGEgc3F1ZWV6ZSBvcGVyYXRpb24uXG4gKiBAcGFyYW0ge251bWJlcltdfSBkaW1zIFRoZSBkaW1lbnNpb25zIG9mIHRoZSB0ZW5zb3IuXG4gKiBAcGFyYW0ge251bWJlcnxudW1iZXJbXXxudWxsfSBkaW0gVGhlIGRpbWVuc2lvbihzKSB0byBzcXVlZXplLlxuICogQHJldHVybnMgVGhlIG5ldyBkaW1lbnNpb25zLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY2FsY19zcXVlZXplX2RpbXMoZGltcywgZGltKSB7XG4gICAgZGltcyA9IGRpbXMuc2xpY2UoKTtcbiAgICBpZiAoZGltID09PSBudWxsKSB7XG4gICAgICAgIGRpbXMgPSBkaW1zLmZpbHRlcigoZCkgPT4gZCAhPT0gMSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZGltID09PSAnbnVtYmVyJykge1xuICAgICAgICBpZiAoZGltc1tkaW1dID09PSAxKSB7XG4gICAgICAgICAgICBkaW1zLnNwbGljZShkaW0sIDEpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGRpbSkpIHtcbiAgICAgICAgZGltcyA9IGRpbXMuZmlsdGVyKCh4LCBpKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4geCAhPT0gMSB8fCAhZGltLmluY2x1ZGVzKGkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGRpbXM7XG59XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRvIGNhbGN1bGF0ZSBuZXcgZGltZW5zaW9ucyB3aGVuIHBlcmZvcm1pbmcgYW4gdW5zcXVlZXplIG9wZXJhdGlvbi5cbiAqIEBwYXJhbSB7bnVtYmVyW119IGRpbXMgVGhlIGRpbWVuc2lvbnMgb2YgdGhlIHRlbnNvci5cbiAqIEBwYXJhbSB7bnVtYmVyfSBkaW0gVGhlIGRpbWVuc2lvbiB0byB1bnNxdWVlemUuXG4gKiBAcmV0dXJucyBUaGUgbmV3IGRpbWVuc2lvbnMuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjYWxjX3Vuc3F1ZWV6ZV9kaW1zKGRpbXMsIGRpbSkge1xuICAgIC8vIERpbWVuc2lvbiBvdXQgb2YgcmFuZ2UgKGUuZy4sIFwiZXhwZWN0ZWQgdG8gYmUgaW4gcmFuZ2Ugb2YgWy00LCAzXSwgYnV0IGdvdCA0XCIpXG4gICAgLy8gKyAxIHNpbmNlIHdlIGFsbG93IGluc2VydGluZyBhdCB0aGUgZW5kIChpLmUuIGRpbSA9IC0xKVxuICAgIGRpbSA9IHNhZmVJbmRleChkaW0sIGRpbXMubGVuZ3RoICsgMSk7XG4gICAgZGltcyA9IGRpbXMuc2xpY2UoKTtcbiAgICAvLyBJbnNlcnQgMSBpbnRvIHNwZWNpZmllZCBkaW1lbnNpb25cbiAgICBkaW1zLnNwbGljZShkaW0sIDAsIDEpO1xuICAgIHJldHVybiBkaW1zO1xufVxuXG4vKipcbiAqIFNhZmVseSBjYWxjdWxhdGUgdGhlIGluZGV4IGZvciBhbiBhcnJheSBvZiBhIGdpdmVuIHNpemUsIGFsbG93aW5nIG5lZ2F0aXZlIGluZGV4aW5nLlxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IFRoZSBpbmRleCB0aGF0IHdpbGwgYmUgdXNlZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzaXplIFRoZSBzaXplIG9mIHRoZSBhcnJheS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbZGltZW5zaW9uPW51bGxdIFRoZSBkaW1lbnNpb24gdGhhdCB0aGUgaW5kZXggaXMgZm9yIChvcHRpb25hbCkuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgaW5kZXgsIGd1YXJhbnRlZWQgdG8gYmUgbm9uLW5lZ2F0aXZlIGFuZCBsZXNzIHRoYW4gYGFycmF5TGVuZ3RoYC5cbiAqIFxuICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBpbmRleCBpcyBvdXQgb2YgcmFuZ2UuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBzYWZlSW5kZXgoaW5kZXgsIHNpemUsIGRpbWVuc2lvbiA9IG51bGwpIHtcbiAgICBpZiAoaW5kZXggPCAtc2l6ZSB8fCBpbmRleCA+PSBzaXplKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW5kZXhFcnJvcjogaW5kZXggJHtpbmRleH0gaXMgb3V0IG9mIGJvdW5kcyBmb3IgZGltZW5zaW9uJHtkaW1lbnNpb24gPT09IG51bGwgPyAnJyA6ICcgJyArIGRpbWVuc2lvbn0gd2l0aCBzaXplICR7c2l6ZX1gKTtcbiAgICB9XG5cbiAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgIC8vIE5lZ2F0aXZlIGluZGV4aW5nLCBlbnN1cmluZyBwb3NpdGl2ZSBpbmRleFxuICAgICAgICBpbmRleCA9ICgoaW5kZXggJSBzaXplKSArIHNpemUpICUgc2l6ZTtcbiAgICB9XG4gICAgcmV0dXJuIGluZGV4O1xufVxuXG4vKipcbiAqIENvbmNhdGVuYXRlcyBhbiBhcnJheSBvZiB0ZW5zb3JzIGFsb25nIGEgc3BlY2lmaWVkIGRpbWVuc2lvbi5cbiAqIEBwYXJhbSB7VGVuc29yW119IHRlbnNvcnMgVGhlIGFycmF5IG9mIHRlbnNvcnMgdG8gY29uY2F0ZW5hdGUuXG4gKiBAcGFyYW0ge251bWJlcn0gZGltIFRoZSBkaW1lbnNpb24gdG8gY29uY2F0ZW5hdGUgYWxvbmcuXG4gKiBAcmV0dXJucyB7VGVuc29yfSBUaGUgY29uY2F0ZW5hdGVkIHRlbnNvci5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNhdCh0ZW5zb3JzLCBkaW0gPSAwKSB7XG4gICAgZGltID0gc2FmZUluZGV4KGRpbSwgdGVuc29yc1swXS5kaW1zLmxlbmd0aCk7XG5cbiAgICAvLyBUT0RPIGRvIHZhbGlkYXRpb24gb2Ygc2hhcGVzXG5cbiAgICBjb25zdCByZXN1bHREaW1zID0gdGVuc29yc1swXS5kaW1zLnNsaWNlKCk7XG4gICAgcmVzdWx0RGltc1tkaW1dID0gdGVuc29ycy5yZWR1Y2UoKGEsIGIpID0+IGEgKyBiLmRpbXNbZGltXSwgMCk7XG5cbiAgICAvLyBDcmVhdGUgYSBuZXcgYXJyYXkgdG8gc3RvcmUgdGhlIGFjY3VtdWxhdGVkIHZhbHVlc1xuICAgIGNvbnN0IHJlc3VsdFNpemUgPSByZXN1bHREaW1zLnJlZHVjZSgoYSwgYikgPT4gYSAqIGIsIDEpO1xuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyB0ZW5zb3JzWzBdLmRhdGEuY29uc3RydWN0b3IocmVzdWx0U2l6ZSk7XG5cbiAgICAvLyBDcmVhdGUgb3V0cHV0IHRlbnNvciBvZiBzYW1lIHR5cGUgYXMgZmlyc3RcbiAgICBjb25zdCByZXN1bHRUeXBlID0gdGVuc29yc1swXS50eXBlO1xuXG4gICAgaWYgKGRpbSA9PT0gMCkge1xuICAgICAgICAvLyBIYW5kbGUgc3BlY2lhbCBjYXNlIGZvciBwZXJmb3JtYW5jZSByZWFzb25zXG5cbiAgICAgICAgbGV0IG9mZnNldCA9IDA7XG4gICAgICAgIGZvciAobGV0IHQgb2YgdGVuc29ycykge1xuICAgICAgICAgICAgcmVzdWx0LnNldCh0LmRhdGEsIG9mZnNldCk7XG4gICAgICAgICAgICBvZmZzZXQgKz0gdC5kYXRhLmxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgfSBlbHNlIHtcblxuICAgICAgICBsZXQgY3VycmVudERpbSA9IDA7XG5cbiAgICAgICAgZm9yIChsZXQgdCA9IDA7IHQgPCB0ZW5zb3JzLmxlbmd0aDsgKyt0KSB7XG4gICAgICAgICAgICBsZXQgdGVuc29yID0gdGVuc29yc1t0XTtcblxuICAgICAgICAgICAgLy8gSXRlcmF0ZSBvdmVyIHRoZSBkYXRhIGFycmF5XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRlbnNvci5kYXRhLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBpbmRleCBpbiB0aGUgcmVzdWx0aW5nIGFycmF5XG4gICAgICAgICAgICAgICAgbGV0IHJlc3VsdEluZGV4ID0gMDtcblxuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSB0ZW5zb3IuZGltcy5sZW5ndGggLSAxLCBudW0gPSBpLCByZXN1bHRNdWx0aXBsaWVyID0gMTsgaiA+PSAwOyAtLWopIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2l6ZSA9IHRlbnNvci5kaW1zW2pdO1xuICAgICAgICAgICAgICAgICAgICBsZXQgaW5kZXggPSBudW0gJSBzaXplO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaiA9PT0gZGltKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleCArPSBjdXJyZW50RGltO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdEluZGV4ICs9IGluZGV4ICogcmVzdWx0TXVsdGlwbGllcjtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0TXVsdGlwbGllciAqPSByZXN1bHREaW1zW2pdO1xuICAgICAgICAgICAgICAgICAgICBudW0gPSBNYXRoLmZsb29yKG51bSAvIHNpemUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBBY2N1bXVsYXRlIHRoZSB2YWx1ZSBhdCB0aGUgY3VycmVudCBpbmRleFxuICAgICAgICAgICAgICAgIHJlc3VsdFtyZXN1bHRJbmRleF0gPSB0ZW5zb3IuZGF0YVtpXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY3VycmVudERpbSArPSB0ZW5zb3IuZGltc1tkaW1dO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXcgVGVuc29yKHJlc3VsdFR5cGUsIHJlc3VsdCwgcmVzdWx0RGltcyk7XG59XG5cbi8qKlxuICogU3RhY2sgYW4gYXJyYXkgb2YgdGVuc29ycyBhbG9uZyBhIHNwZWNpZmllZCBkaW1lbnNpb24uXG4gKiBAcGFyYW0ge1RlbnNvcltdfSB0ZW5zb3JzIFRoZSBhcnJheSBvZiB0ZW5zb3JzIHRvIHN0YWNrLlxuICogQHBhcmFtIHtudW1iZXJ9IGRpbSBUaGUgZGltZW5zaW9uIHRvIHN0YWNrIGFsb25nLlxuICogQHJldHVybnMge1RlbnNvcn0gVGhlIHN0YWNrZWQgdGVuc29yLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc3RhY2sodGVuc29ycywgZGltID0gMCkge1xuICAgIC8vIFRPRE8gZG8gdmFsaWRhdGlvbiBvZiBzaGFwZXNcbiAgICAvLyBOT1RFOiBzdGFjayBleHBlY3RzIGVhY2ggdGVuc29yIHRvIGJlIGVxdWFsIHNpemVcbiAgICByZXR1cm4gY2F0KHRlbnNvcnMubWFwKHQgPT4gdC51bnNxdWVlemUoZGltKSksIGRpbSk7XG59XG5cblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBzdGFuZGFyZCBkZXZpYXRpb24gYW5kIG1lYW4gb3ZlciB0aGUgZGltZW5zaW9ucyBzcGVjaWZpZWQgYnkgZGltLiBkaW0gY2FuIGJlIGEgc2luZ2xlIGRpbWVuc2lvbiBvciBgbnVsbGAgdG8gcmVkdWNlIG92ZXIgYWxsIGRpbWVuc2lvbnMuXG4gKiBAcGFyYW0ge1RlbnNvcn0gaW5wdXQgdGhlIGlucHV0IHRlbnNvXG4gKiBAcGFyYW0ge251bWJlcnxudWxsfSBkaW0gdGhlIGRpbWVuc2lvbiB0byByZWR1Y2UuIElmIE5vbmUsIGFsbCBkaW1lbnNpb25zIGFyZSByZWR1Y2VkLlxuICogQHBhcmFtIHtudW1iZXJ9IGNvcnJlY3Rpb24gZGlmZmVyZW5jZSBiZXR3ZWVuIHRoZSBzYW1wbGUgc2l6ZSBhbmQgc2FtcGxlIGRlZ3JlZXMgb2YgZnJlZWRvbS4gRGVmYXVsdHMgdG8gQmVzc2VsJ3MgY29ycmVjdGlvbiwgY29ycmVjdGlvbj0xLlxuICogQHBhcmFtIHtib29sZWFufSBrZWVwZGltIHdoZXRoZXIgdGhlIG91dHB1dCB0ZW5zb3IgaGFzIGRpbSByZXRhaW5lZCBvciBub3QuXG4gKiBAcmV0dXJucyB7VGVuc29yW119IEEgdHVwbGUgb2YgKHN0ZCwgbWVhbikgdGVuc29ycy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0ZF9tZWFuKGlucHV0LCBkaW0gPSBudWxsLCBjb3JyZWN0aW9uID0gMSwga2VlcGRpbSA9IGZhbHNlKSB7XG5cbiAgICBpZiAoZGltID09PSBudWxsKSB7XG4gICAgICAgIC8vIE5vbmUgdG8gcmVkdWNlIG92ZXIgYWxsIGRpbWVuc2lvbnMuXG4gICAgICAgIGNvbnN0IHN1bSA9IGlucHV0LmRhdGEucmVkdWNlKChhLCBiKSA9PiBhICsgYiwgMCk7XG4gICAgICAgIGNvbnN0IG1lYW4gPSBzdW0gLyBpbnB1dC5kYXRhLmxlbmd0aDtcbiAgICAgICAgY29uc3Qgc3RkID0gTWF0aC5zcXJ0KGlucHV0LmRhdGEucmVkdWNlKChhLCBiKSA9PiBhICsgKGIgLSBtZWFuKSAqKiAyLCAwKSAvIChpbnB1dC5kYXRhLmxlbmd0aCAtIGNvcnJlY3Rpb24pKTtcblxuICAgICAgICBjb25zdCBtZWFuVGVuc29yID0gbmV3IFRlbnNvcihpbnB1dC50eXBlLCBbbWVhbl0sIFsvKiBzY2FsYXIgKi9dKTtcbiAgICAgICAgY29uc3Qgc3RkVGVuc29yID0gbmV3IFRlbnNvcihpbnB1dC50eXBlLCBbc3RkXSwgWy8qIHNjYWxhciAqL10pO1xuXG4gICAgICAgIHJldHVybiBbc3RkVGVuc29yLCBtZWFuVGVuc29yXTtcbiAgICB9XG5cbiAgICAvLyBOZWdhdGl2ZSBpbmRleGluZ1xuICAgIGRpbSA9IHNhZmVJbmRleChkaW0sIGlucHV0LmRpbXMubGVuZ3RoKTtcblxuICAgIGNvbnN0IG1lYW5UZW5zb3IgPSBtZWFuKGlucHV0LCBkaW0sIGtlZXBkaW0pO1xuXG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBzaGFwZSBvZiB0aGUgcmVzdWx0aW5nIGFycmF5IGFmdGVyIHN1bW1hdGlvblxuICAgIGNvbnN0IHJlc3VsdERpbXMgPSBpbnB1dC5kaW1zLnNsaWNlKCk7IC8vIENvcHkgdGhlIG9yaWdpbmFsIGRpbWVuc2lvbnNcbiAgICByZXN1bHREaW1zW2RpbV0gPSAxOyAvLyBSZW1vdmUgdGhlIHNwZWNpZmllZCBheGlzXG5cbiAgICAvLyBDcmVhdGUgYSBuZXcgYXJyYXkgdG8gc3RvcmUgdGhlIGFjY3VtdWxhdGVkIHZhbHVlc1xuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBpbnB1dC5kYXRhLmNvbnN0cnVjdG9yKGlucHV0LmRhdGEubGVuZ3RoIC8gaW5wdXQuZGltc1tkaW1dKTtcblxuICAgIC8vIEl0ZXJhdGUgb3ZlciB0aGUgZGF0YSBhcnJheVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5wdXQuZGF0YS5sZW5ndGg7ICsraSkge1xuXG4gICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgaW5kZXggaW4gdGhlIHJlc3VsdGluZyBhcnJheVxuICAgICAgICBsZXQgcmVzdWx0SW5kZXggPSAwO1xuXG4gICAgICAgIGZvciAobGV0IGogPSBpbnB1dC5kaW1zLmxlbmd0aCAtIDEsIG51bSA9IGksIHJlc3VsdE11bHRpcGxpZXIgPSAxOyBqID49IDA7IC0taikge1xuICAgICAgICAgICAgY29uc3Qgc2l6ZSA9IGlucHV0LmRpbXNbal07XG4gICAgICAgICAgICBpZiAoaiAhPT0gZGltKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5kZXggPSBudW0gJSBzaXplO1xuICAgICAgICAgICAgICAgIHJlc3VsdEluZGV4ICs9IGluZGV4ICogcmVzdWx0TXVsdGlwbGllcjtcbiAgICAgICAgICAgICAgICByZXN1bHRNdWx0aXBsaWVyICo9IHJlc3VsdERpbXNbal07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBudW0gPSBNYXRoLmZsb29yKG51bSAvIHNpemUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQWNjdW11bGF0ZSB0aGUgdmFsdWUgYXQgdGhlIGN1cnJlbnQgaW5kZXhcbiAgICAgICAgcmVzdWx0W3Jlc3VsdEluZGV4XSArPSAoaW5wdXQuZGF0YVtpXSAtIG1lYW5UZW5zb3IuZGF0YVtyZXN1bHRJbmRleF0pICoqIDI7XG4gICAgfVxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXN1bHQubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgcmVzdWx0W2ldID0gTWF0aC5zcXJ0KHJlc3VsdFtpXSAvIChpbnB1dC5kaW1zW2RpbV0gLSBjb3JyZWN0aW9uKSk7XG4gICAgfVxuXG4gICAgaWYgKCFrZWVwZGltKSB7XG4gICAgICAgIHJlc3VsdERpbXMuc3BsaWNlKGRpbSwgMSk7XG4gICAgfVxuXG4gICAgY29uc3Qgc3RkVGVuc29yID0gbmV3IFRlbnNvcihpbnB1dC50eXBlLCByZXN1bHQsIHJlc3VsdERpbXMpO1xuXG4gICAgcmV0dXJuIFtzdGRUZW5zb3IsIG1lYW5UZW5zb3JdO1xufVxuXG5cbi8qKlxuICogUmV0dXJucyB0aGUgbWVhbiB2YWx1ZSBvZiBlYWNoIHJvdyBvZiB0aGUgaW5wdXQgdGVuc29yIGluIHRoZSBnaXZlbiBkaW1lbnNpb24gZGltLlxuICogQHBhcmFtIHtUZW5zb3J9IGlucHV0IHRoZSBpbnB1dCB0ZW5zb3IuXG4gKiBAcGFyYW0ge251bWJlcnxudWxsfSBkaW0gdGhlIGRpbWVuc2lvbiB0byByZWR1Y2UuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGtlZXBkaW0gd2hldGhlciB0aGUgb3V0cHV0IHRlbnNvciBoYXMgZGltIHJldGFpbmVkIG9yIG5vdC5cbiAqIEByZXR1cm5zIEEgbmV3IHRlbnNvciB3aXRoIG1lYW5zIHRha2VuIGFsb25nIHRoZSBzcGVjaWZpZWQgZGltZW5zaW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbWVhbihpbnB1dCwgZGltID0gbnVsbCwga2VlcGRpbSA9IGZhbHNlKSB7XG5cbiAgICBpZiAoZGltID09PSBudWxsKSB7XG4gICAgICAgIC8vIE5vbmUgdG8gcmVkdWNlIG92ZXIgYWxsIGRpbWVuc2lvbnMuXG4gICAgICAgIGxldCB2YWwgPSBpbnB1dC5kYXRhLnJlZHVjZSgoYSwgYikgPT4gYSArIGIsIDApO1xuICAgICAgICByZXR1cm4gbmV3IFRlbnNvcihpbnB1dC50eXBlLCBbdmFsIC8gaW5wdXQuZGF0YS5sZW5ndGhdLCBbLyogc2NhbGFyICovXSk7XG4gICAgfVxuXG4gICAgLy8gTmVnYXRpdmUgaW5kZXhpbmdcbiAgICBkaW0gPSBzYWZlSW5kZXgoZGltLCBpbnB1dC5kaW1zLmxlbmd0aCk7XG5cbiAgICAvLyBDYWxjdWxhdGUgdGhlIHNoYXBlIG9mIHRoZSByZXN1bHRpbmcgYXJyYXkgYWZ0ZXIgc3VtbWF0aW9uXG4gICAgY29uc3QgcmVzdWx0RGltcyA9IGlucHV0LmRpbXMuc2xpY2UoKTsgLy8gQ29weSB0aGUgb3JpZ2luYWwgZGltZW5zaW9uc1xuICAgIHJlc3VsdERpbXNbZGltXSA9IDE7IC8vIFJlbW92ZSB0aGUgc3BlY2lmaWVkIGF4aXNcblxuICAgIC8vIENyZWF0ZSBhIG5ldyBhcnJheSB0byBzdG9yZSB0aGUgYWNjdW11bGF0ZWQgdmFsdWVzXG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IGlucHV0LmRhdGEuY29uc3RydWN0b3IoaW5wdXQuZGF0YS5sZW5ndGggLyBpbnB1dC5kaW1zW2RpbV0pO1xuXG4gICAgLy8gSXRlcmF0ZSBvdmVyIHRoZSBkYXRhIGFycmF5XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnB1dC5kYXRhLmxlbmd0aDsgKytpKSB7XG5cbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBpbmRleCBpbiB0aGUgcmVzdWx0aW5nIGFycmF5XG4gICAgICAgIGxldCByZXN1bHRJbmRleCA9IDA7XG5cbiAgICAgICAgZm9yIChsZXQgaiA9IGlucHV0LmRpbXMubGVuZ3RoIC0gMSwgbnVtID0gaSwgcmVzdWx0TXVsdGlwbGllciA9IDE7IGogPj0gMDsgLS1qKSB7XG4gICAgICAgICAgICBjb25zdCBzaXplID0gaW5wdXQuZGltc1tqXTtcbiAgICAgICAgICAgIGlmIChqICE9PSBkaW0pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpbmRleCA9IG51bSAlIHNpemU7XG4gICAgICAgICAgICAgICAgcmVzdWx0SW5kZXggKz0gaW5kZXggKiByZXN1bHRNdWx0aXBsaWVyO1xuICAgICAgICAgICAgICAgIHJlc3VsdE11bHRpcGxpZXIgKj0gcmVzdWx0RGltc1tqXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG51bSA9IE1hdGguZmxvb3IobnVtIC8gc2l6ZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBY2N1bXVsYXRlIHRoZSB2YWx1ZSBhdCB0aGUgY3VycmVudCBpbmRleFxuICAgICAgICByZXN1bHRbcmVzdWx0SW5kZXhdICs9IGlucHV0LmRhdGFbaV07XG4gICAgfVxuXG4gICAgaWYgKGlucHV0LmRpbXNbZGltXSAhPT0gMSkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlc3VsdC5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgcmVzdWx0W2ldID0gcmVzdWx0W2ldIC8gaW5wdXQuZGltc1tkaW1dO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFrZWVwZGltKSB7XG4gICAgICAgIHJlc3VsdERpbXMuc3BsaWNlKGRpbSwgMSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBUZW5zb3IoaW5wdXQudHlwZSwgcmVzdWx0LCByZXN1bHREaW1zKTtcbn1cblxuXG4vKipcbiAqXG4gKiBNZWFzdXJlcyBzaW1pbGFyaXR5IGJldHdlZW4gdHdvIHRlbXBvcmFsIHNlcXVlbmNlcyAoZS5nLiwgaW5wdXQgYXVkaW8gYW5kIG91dHB1dCB0b2tlbnNcbiAqIHRvIGdlbmVyYXRlIHRva2VuLWxldmVsIHRpbWVzdGFtcHMpLlxuICogQHBhcmFtIHtUZW5zb3J9IG1hdHJpeCBcbiAqIEByZXR1cm5zIHtudW1iZXJbXVtdfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZHluYW1pY1RpbWVXYXJwaW5nKG1hdHJpeCkge1xuICAgIGNvbnN0IFtvdXRwdXRfbGVuZ3RoLCBpbnB1dF9sZW5ndGhdID0gbWF0cml4LmRpbXM7XG5cbiAgICBjb25zdCBvdXRwdXRTaGFwZSA9IFtvdXRwdXRfbGVuZ3RoICsgMSwgaW5wdXRfbGVuZ3RoICsgMV07XG5cbiAgICBjb25zdCBjb3N0ID0gbmV3IFRlbnNvcihcbiAgICAgICAgJ2Zsb2F0MzInLFxuICAgICAgICBuZXcgRmxvYXQzMkFycmF5KG91dHB1dFNoYXBlWzBdICogb3V0cHV0U2hhcGVbMV0pLmZpbGwoSW5maW5pdHkpLFxuICAgICAgICBvdXRwdXRTaGFwZVxuICAgICk7XG5cbiAgICBjb25zdCB0cmFjZSA9IG5ldyBUZW5zb3IoXG4gICAgICAgICdmbG9hdDMyJyxcbiAgICAgICAgbmV3IEZsb2F0MzJBcnJheShvdXRwdXRTaGFwZVswXSAqIG91dHB1dFNoYXBlWzFdKS5maWxsKC0xKSxcbiAgICAgICAgb3V0cHV0U2hhcGVcbiAgICApXG5cbiAgICAvLyBzYW1lIGFzIGBjb3N0WzBdWzBdID0gMGA7XG4gICAgY29zdFswXS5kYXRhWzBdID0gMDtcblxuICAgIGZvciAobGV0IGogPSAxOyBqIDwgaW5wdXRfbGVuZ3RoICsgMTsgKytqKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgb3V0cHV0X2xlbmd0aCArIDE7ICsraSkge1xuXG4gICAgICAgICAgICBjb25zdCBjMCA9IGNvc3RbaSAtIDFdW2ogLSAxXS5pdGVtKCk7XG4gICAgICAgICAgICBjb25zdCBjMSA9IGNvc3RbaSAtIDFdW2pdLml0ZW0oKTtcbiAgICAgICAgICAgIGNvbnN0IGMyID0gY29zdFtpXVtqIC0gMV0uaXRlbSgpO1xuXG4gICAgICAgICAgICBsZXQgYywgdDtcbiAgICAgICAgICAgIGlmIChjMCA8IGMxICYmIGMwIDwgYzIpIHtcbiAgICAgICAgICAgICAgICBjID0gYzA7XG4gICAgICAgICAgICAgICAgdCA9IDA7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGMxIDwgYzAgJiYgYzEgPCBjMikge1xuICAgICAgICAgICAgICAgIGMgPSBjMTtcbiAgICAgICAgICAgICAgICB0ID0gMTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYyA9IGMyO1xuICAgICAgICAgICAgICAgIHQgPSAyO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb3N0W2ldLmRhdGFbal0gPSBtYXRyaXhbaSAtIDFdW2ogLSAxXS5pdGVtKCkgKyBjO1xuICAgICAgICAgICAgdHJhY2VbaV0uZGF0YVtqXSA9IHQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBiYWNrdHJhY2VcbiAgICBsZXQgaSA9IG91dHB1dF9sZW5ndGg7XG4gICAgbGV0IGogPSBpbnB1dF9sZW5ndGg7XG5cbiAgICB0cmFjZS5kYXRhLmZpbGwoMiwgMCwgb3V0cHV0U2hhcGVbMV0pIC8vIHRyYWNlWzAsIDpdID0gMlxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3V0cHV0U2hhcGVbMF07ICsraSkgeyAvLyB0cmFjZVs6LCAwXSA9IDFcbiAgICAgICAgdHJhY2VbaV0uZGF0YVswXSA9IDE7XG4gICAgfVxuXG4gICAgbGV0IHRleHRfaW5kaWNlcyA9IFtdO1xuICAgIGxldCB0aW1lX2luZGljZXMgPSBbXTtcblxuICAgIHdoaWxlIChpID4gMCB8fCBqID4gMCkge1xuICAgICAgICB0ZXh0X2luZGljZXMucHVzaChpIC0gMSk7XG4gICAgICAgIHRpbWVfaW5kaWNlcy5wdXNoKGogLSAxKTtcblxuICAgICAgICBjb25zdCB0ID0gdHJhY2VbaV1bal0uaXRlbSgpO1xuICAgICAgICBzd2l0Y2ggKHQpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAtLWk7IC0tajtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAtLWk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgLS1qO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgIGBJbnRlcm5hbCBlcnJvciBpbiBkeW5hbWljIHRpbWUgd2FycGluZy4gVW5leHBlY3RlZCB0cmFjZVske2l9LCAke2p9XS4gUGxlYXNlIGZpbGUgYSBidWcgcmVwb3J0LmBcbiAgICAgICAgICAgICAgICApXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0ZXh0X2luZGljZXMucmV2ZXJzZSgpO1xuICAgIHRpbWVfaW5kaWNlcy5yZXZlcnNlKCk7XG5cbiAgICByZXR1cm4gW3RleHRfaW5kaWNlcywgdGltZV9pbmRpY2VzXTtcblxufVxuXG5mdW5jdGlvbiBkaW1zVG9TdHJpZGUoZGltcykge1xuICAgIGNvbnN0IHN0cmlkZSA9IG5ldyBBcnJheShkaW1zLmxlbmd0aCk7XG4gICAgZm9yIChsZXQgaSA9IGRpbXMubGVuZ3RoIC0gMSwgczIgPSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICBzdHJpZGVbaV0gPSBzMjtcbiAgICAgICAgczIgKj0gZGltc1tpXTtcbiAgICB9XG4gICAgcmV0dXJuIHN0cmlkZTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@xenova/transformers/src/utils/tensor.js\n"));

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			if (cachedModule.error !== undefined) throw cachedModule.error;
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		var threw = true;
/******/ 		try {
/******/ 			var execOptions = { id: moduleId, module: module, factory: __webpack_modules__[moduleId], require: __webpack_require__ };
/******/ 			__webpack_require__.i.forEach(function(handler) { handler(execOptions); });
/******/ 			module = execOptions.module;
/******/ 			execOptions.factory.call(module.exports, module, module.exports, execOptions.require);
/******/ 			threw = false;
/******/ 		} finally {
/******/ 			if(threw) delete __webpack_module_cache__[moduleId];
/******/ 		}
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = __webpack_module_cache__;
/******/ 	
/******/ 	// expose the module execution interceptor
/******/ 	__webpack_require__.i = [];
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/create fake namespace object */
/******/ 	!function() {
/******/ 		var getProto = Object.getPrototypeOf ? function(obj) { return Object.getPrototypeOf(obj); } : function(obj) { return obj.__proto__; };
/******/ 		var leafPrototypes;
/******/ 		// create a fake namespace object
/******/ 		// mode & 1: value is a module id, require it
/******/ 		// mode & 2: merge all properties of value into the ns
/******/ 		// mode & 4: return value when already ns object
/******/ 		// mode & 16: return value when it's Promise-like
/******/ 		// mode & 8|1: behave like require
/******/ 		__webpack_require__.t = function(value, mode) {
/******/ 			if(mode & 1) value = this(value);
/******/ 			if(mode & 8) return value;
/******/ 			if(typeof value === 'object' && value) {
/******/ 				if((mode & 4) && value.__esModule) return value;
/******/ 				if((mode & 16) && typeof value.then === 'function') return value;
/******/ 			}
/******/ 			var ns = Object.create(null);
/******/ 			__webpack_require__.r(ns);
/******/ 			var def = {};
/******/ 			leafPrototypes = leafPrototypes || [null, getProto({}), getProto([]), getProto(getProto)];
/******/ 			for(var current = mode & 2 && value; typeof current == 'object' && !~leafPrototypes.indexOf(current); current = getProto(current)) {
/******/ 				Object.getOwnPropertyNames(current).forEach(function(key) { def[key] = function() { return value[key]; }; });
/******/ 			}
/******/ 			def['default'] = function() { return value; };
/******/ 			__webpack_require__.d(ns, def);
/******/ 			return ns;
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	!function() {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = function(exports, definition) {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/get javascript update chunk filename */
/******/ 	!function() {
/******/ 		// This function allow to reference all chunks
/******/ 		__webpack_require__.hu = function(chunkId) {
/******/ 			// return url for filenames based on template
/******/ 			return "static/webpack/" + chunkId + "." + __webpack_require__.h() + ".hot-update.js";
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/get mini-css chunk filename */
/******/ 	!function() {
/******/ 		// This function allow to reference all chunks
/******/ 		__webpack_require__.miniCssF = function(chunkId) {
/******/ 			// return url for filenames based on template
/******/ 			return undefined;
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/get update manifest filename */
/******/ 	!function() {
/******/ 		__webpack_require__.hmrF = function() { return "static/webpack/" + __webpack_require__.h() + ".ed2a60d7ac2a0936.hot-update.json"; };
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/getFullHash */
/******/ 	!function() {
/******/ 		__webpack_require__.h = function() { return "80d162e0df5d4d67"; }
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	!function() {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	!function() {
/******/ 		__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	!function() {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = function(exports) {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/trusted types policy */
/******/ 	!function() {
/******/ 		var policy;
/******/ 		__webpack_require__.tt = function() {
/******/ 			// Create Trusted Type policy if Trusted Types are available and the policy doesn't exist yet.
/******/ 			if (policy === undefined) {
/******/ 				policy = {
/******/ 					createScript: function(script) { return script; },
/******/ 					createScriptURL: function(url) { return url; }
/******/ 				};
/******/ 				if (typeof trustedTypes !== "undefined" && trustedTypes.createPolicy) {
/******/ 					policy = trustedTypes.createPolicy("nextjs#bundler", policy);
/******/ 				}
/******/ 			}
/******/ 			return policy;
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/trusted types script */
/******/ 	!function() {
/******/ 		__webpack_require__.ts = function(script) { return __webpack_require__.tt().createScript(script); };
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/trusted types script url */
/******/ 	!function() {
/******/ 		__webpack_require__.tu = function(url) { return __webpack_require__.tt().createScriptURL(url); };
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/hot module replacement */
/******/ 	!function() {
/******/ 		var currentModuleData = {};
/******/ 		var installedModules = __webpack_require__.c;
/******/ 		
/******/ 		// module and require creation
/******/ 		var currentChildModule;
/******/ 		var currentParents = [];
/******/ 		
/******/ 		// status
/******/ 		var registeredStatusHandlers = [];
/******/ 		var currentStatus = "idle";
/******/ 		
/******/ 		// while downloading
/******/ 		var blockingPromises = 0;
/******/ 		var blockingPromisesWaiting = [];
/******/ 		
/******/ 		// The update info
/******/ 		var currentUpdateApplyHandlers;
/******/ 		var queuedInvalidatedModules;
/******/ 		
/******/ 		// eslint-disable-next-line no-unused-vars
/******/ 		__webpack_require__.hmrD = currentModuleData;
/******/ 		
/******/ 		__webpack_require__.i.push(function (options) {
/******/ 			var module = options.module;
/******/ 			var require = createRequire(options.require, options.id);
/******/ 			module.hot = createModuleHotObject(options.id, module);
/******/ 			module.parents = currentParents;
/******/ 			module.children = [];
/******/ 			currentParents = [];
/******/ 			options.require = require;
/******/ 		});
/******/ 		
/******/ 		__webpack_require__.hmrC = {};
/******/ 		__webpack_require__.hmrI = {};
/******/ 		
/******/ 		function createRequire(require, moduleId) {
/******/ 			var me = installedModules[moduleId];
/******/ 			if (!me) return require;
/******/ 			var fn = function (request) {
/******/ 				if (me.hot.active) {
/******/ 					if (installedModules[request]) {
/******/ 						var parents = installedModules[request].parents;
/******/ 						if (parents.indexOf(moduleId) === -1) {
/******/ 							parents.push(moduleId);
/******/ 						}
/******/ 					} else {
/******/ 						currentParents = [moduleId];
/******/ 						currentChildModule = request;
/******/ 					}
/******/ 					if (me.children.indexOf(request) === -1) {
/******/ 						me.children.push(request);
/******/ 					}
/******/ 				} else {
/******/ 					console.warn(
/******/ 						"[HMR] unexpected require(" +
/******/ 							request +
/******/ 							") from disposed module " +
/******/ 							moduleId
/******/ 					);
/******/ 					currentParents = [];
/******/ 				}
/******/ 				return require(request);
/******/ 			};
/******/ 			var createPropertyDescriptor = function (name) {
/******/ 				return {
/******/ 					configurable: true,
/******/ 					enumerable: true,
/******/ 					get: function () {
/******/ 						return require[name];
/******/ 					},
/******/ 					set: function (value) {
/******/ 						require[name] = value;
/******/ 					}
/******/ 				};
/******/ 			};
/******/ 			for (var name in require) {
/******/ 				if (Object.prototype.hasOwnProperty.call(require, name) && name !== "e") {
/******/ 					Object.defineProperty(fn, name, createPropertyDescriptor(name));
/******/ 				}
/******/ 			}
/******/ 			fn.e = function (chunkId) {
/******/ 				return trackBlockingPromise(require.e(chunkId));
/******/ 			};
/******/ 			return fn;
/******/ 		}
/******/ 		
/******/ 		function createModuleHotObject(moduleId, me) {
/******/ 			var _main = currentChildModule !== moduleId;
/******/ 			var hot = {
/******/ 				// private stuff
/******/ 				_acceptedDependencies: {},
/******/ 				_acceptedErrorHandlers: {},
/******/ 				_declinedDependencies: {},
/******/ 				_selfAccepted: false,
/******/ 				_selfDeclined: false,
/******/ 				_selfInvalidated: false,
/******/ 				_disposeHandlers: [],
/******/ 				_main: _main,
/******/ 				_requireSelf: function () {
/******/ 					currentParents = me.parents.slice();
/******/ 					currentChildModule = _main ? undefined : moduleId;
/******/ 					__webpack_require__(moduleId);
/******/ 				},
/******/ 		
/******/ 				// Module API
/******/ 				active: true,
/******/ 				accept: function (dep, callback, errorHandler) {
/******/ 					if (dep === undefined) hot._selfAccepted = true;
/******/ 					else if (typeof dep === "function") hot._selfAccepted = dep;
/******/ 					else if (typeof dep === "object" && dep !== null) {
/******/ 						for (var i = 0; i < dep.length; i++) {
/******/ 							hot._acceptedDependencies[dep[i]] = callback || function () {};
/******/ 							hot._acceptedErrorHandlers[dep[i]] = errorHandler;
/******/ 						}
/******/ 					} else {
/******/ 						hot._acceptedDependencies[dep] = callback || function () {};
/******/ 						hot._acceptedErrorHandlers[dep] = errorHandler;
/******/ 					}
/******/ 				},
/******/ 				decline: function (dep) {
/******/ 					if (dep === undefined) hot._selfDeclined = true;
/******/ 					else if (typeof dep === "object" && dep !== null)
/******/ 						for (var i = 0; i < dep.length; i++)
/******/ 							hot._declinedDependencies[dep[i]] = true;
/******/ 					else hot._declinedDependencies[dep] = true;
/******/ 				},
/******/ 				dispose: function (callback) {
/******/ 					hot._disposeHandlers.push(callback);
/******/ 				},
/******/ 				addDisposeHandler: function (callback) {
/******/ 					hot._disposeHandlers.push(callback);
/******/ 				},
/******/ 				removeDisposeHandler: function (callback) {
/******/ 					var idx = hot._disposeHandlers.indexOf(callback);
/******/ 					if (idx >= 0) hot._disposeHandlers.splice(idx, 1);
/******/ 				},
/******/ 				invalidate: function () {
/******/ 					this._selfInvalidated = true;
/******/ 					switch (currentStatus) {
/******/ 						case "idle":
/******/ 							currentUpdateApplyHandlers = [];
/******/ 							Object.keys(__webpack_require__.hmrI).forEach(function (key) {
/******/ 								__webpack_require__.hmrI[key](
/******/ 									moduleId,
/******/ 									currentUpdateApplyHandlers
/******/ 								);
/******/ 							});
/******/ 							setStatus("ready");
/******/ 							break;
/******/ 						case "ready":
/******/ 							Object.keys(__webpack_require__.hmrI).forEach(function (key) {
/******/ 								__webpack_require__.hmrI[key](
/******/ 									moduleId,
/******/ 									currentUpdateApplyHandlers
/******/ 								);
/******/ 							});
/******/ 							break;
/******/ 						case "prepare":
/******/ 						case "check":
/******/ 						case "dispose":
/******/ 						case "apply":
/******/ 							(queuedInvalidatedModules = queuedInvalidatedModules || []).push(
/******/ 								moduleId
/******/ 							);
/******/ 							break;
/******/ 						default:
/******/ 							// ignore requests in error states
/******/ 							break;
/******/ 					}
/******/ 				},
/******/ 		
/******/ 				// Management API
/******/ 				check: hotCheck,
/******/ 				apply: hotApply,
/******/ 				status: function (l) {
/******/ 					if (!l) return currentStatus;
/******/ 					registeredStatusHandlers.push(l);
/******/ 				},
/******/ 				addStatusHandler: function (l) {
/******/ 					registeredStatusHandlers.push(l);
/******/ 				},
/******/ 				removeStatusHandler: function (l) {
/******/ 					var idx = registeredStatusHandlers.indexOf(l);
/******/ 					if (idx >= 0) registeredStatusHandlers.splice(idx, 1);
/******/ 				},
/******/ 		
/******/ 				//inherit from previous dispose call
/******/ 				data: currentModuleData[moduleId]
/******/ 			};
/******/ 			currentChildModule = undefined;
/******/ 			return hot;
/******/ 		}
/******/ 		
/******/ 		function setStatus(newStatus) {
/******/ 			currentStatus = newStatus;
/******/ 			var results = [];
/******/ 		
/******/ 			for (var i = 0; i < registeredStatusHandlers.length; i++)
/******/ 				results[i] = registeredStatusHandlers[i].call(null, newStatus);
/******/ 		
/******/ 			return Promise.all(results);
/******/ 		}
/******/ 		
/******/ 		function unblock() {
/******/ 			if (--blockingPromises === 0) {
/******/ 				setStatus("ready").then(function () {
/******/ 					if (blockingPromises === 0) {
/******/ 						var list = blockingPromisesWaiting;
/******/ 						blockingPromisesWaiting = [];
/******/ 						for (var i = 0; i < list.length; i++) {
/******/ 							list[i]();
/******/ 						}
/******/ 					}
/******/ 				});
/******/ 			}
/******/ 		}
/******/ 		
/******/ 		function trackBlockingPromise(promise) {
/******/ 			switch (currentStatus) {
/******/ 				case "ready":
/******/ 					setStatus("prepare");
/******/ 				/* fallthrough */
/******/ 				case "prepare":
/******/ 					blockingPromises++;
/******/ 					promise.then(unblock, unblock);
/******/ 					return promise;
/******/ 				default:
/******/ 					return promise;
/******/ 			}
/******/ 		}
/******/ 		
/******/ 		function waitForBlockingPromises(fn) {
/******/ 			if (blockingPromises === 0) return fn();
/******/ 			return new Promise(function (resolve) {
/******/ 				blockingPromisesWaiting.push(function () {
/******/ 					resolve(fn());
/******/ 				});
/******/ 			});
/******/ 		}
/******/ 		
/******/ 		function hotCheck(applyOnUpdate) {
/******/ 			if (currentStatus !== "idle") {
/******/ 				throw new Error("check() is only allowed in idle status");
/******/ 			}
/******/ 			return setStatus("check")
/******/ 				.then(__webpack_require__.hmrM)
/******/ 				.then(function (update) {
/******/ 					if (!update) {
/******/ 						return setStatus(applyInvalidatedModules() ? "ready" : "idle").then(
/******/ 							function () {
/******/ 								return null;
/******/ 							}
/******/ 						);
/******/ 					}
/******/ 		
/******/ 					return setStatus("prepare").then(function () {
/******/ 						var updatedModules = [];
/******/ 						currentUpdateApplyHandlers = [];
/******/ 		
/******/ 						return Promise.all(
/******/ 							Object.keys(__webpack_require__.hmrC).reduce(function (
/******/ 								promises,
/******/ 								key
/******/ 							) {
/******/ 								__webpack_require__.hmrC[key](
/******/ 									update.c,
/******/ 									update.r,
/******/ 									update.m,
/******/ 									promises,
/******/ 									currentUpdateApplyHandlers,
/******/ 									updatedModules
/******/ 								);
/******/ 								return promises;
/******/ 							},
/******/ 							[])
/******/ 						).then(function () {
/******/ 							return waitForBlockingPromises(function () {
/******/ 								if (applyOnUpdate) {
/******/ 									return internalApply(applyOnUpdate);
/******/ 								} else {
/******/ 									return setStatus("ready").then(function () {
/******/ 										return updatedModules;
/******/ 									});
/******/ 								}
/******/ 							});
/******/ 						});
/******/ 					});
/******/ 				});
/******/ 		}
/******/ 		
/******/ 		function hotApply(options) {
/******/ 			if (currentStatus !== "ready") {
/******/ 				return Promise.resolve().then(function () {
/******/ 					throw new Error(
/******/ 						"apply() is only allowed in ready status (state: " +
/******/ 							currentStatus +
/******/ 							")"
/******/ 					);
/******/ 				});
/******/ 			}
/******/ 			return internalApply(options);
/******/ 		}
/******/ 		
/******/ 		function internalApply(options) {
/******/ 			options = options || {};
/******/ 		
/******/ 			applyInvalidatedModules();
/******/ 		
/******/ 			var results = currentUpdateApplyHandlers.map(function (handler) {
/******/ 				return handler(options);
/******/ 			});
/******/ 			currentUpdateApplyHandlers = undefined;
/******/ 		
/******/ 			var errors = results
/******/ 				.map(function (r) {
/******/ 					return r.error;
/******/ 				})
/******/ 				.filter(Boolean);
/******/ 		
/******/ 			if (errors.length > 0) {
/******/ 				return setStatus("abort").then(function () {
/******/ 					throw errors[0];
/******/ 				});
/******/ 			}
/******/ 		
/******/ 			// Now in "dispose" phase
/******/ 			var disposePromise = setStatus("dispose");
/******/ 		
/******/ 			results.forEach(function (result) {
/******/ 				if (result.dispose) result.dispose();
/******/ 			});
/******/ 		
/******/ 			// Now in "apply" phase
/******/ 			var applyPromise = setStatus("apply");
/******/ 		
/******/ 			var error;
/******/ 			var reportError = function (err) {
/******/ 				if (!error) error = err;
/******/ 			};
/******/ 		
/******/ 			var outdatedModules = [];
/******/ 			results.forEach(function (result) {
/******/ 				if (result.apply) {
/******/ 					var modules = result.apply(reportError);
/******/ 					if (modules) {
/******/ 						for (var i = 0; i < modules.length; i++) {
/******/ 							outdatedModules.push(modules[i]);
/******/ 						}
/******/ 					}
/******/ 				}
/******/ 			});
/******/ 		
/******/ 			return Promise.all([disposePromise, applyPromise]).then(function () {
/******/ 				// handle errors in accept handlers and self accepted module load
/******/ 				if (error) {
/******/ 					return setStatus("fail").then(function () {
/******/ 						throw error;
/******/ 					});
/******/ 				}
/******/ 		
/******/ 				if (queuedInvalidatedModules) {
/******/ 					return internalApply(options).then(function (list) {
/******/ 						outdatedModules.forEach(function (moduleId) {
/******/ 							if (list.indexOf(moduleId) < 0) list.push(moduleId);
/******/ 						});
/******/ 						return list;
/******/ 					});
/******/ 				}
/******/ 		
/******/ 				return setStatus("idle").then(function () {
/******/ 					return outdatedModules;
/******/ 				});
/******/ 			});
/******/ 		}
/******/ 		
/******/ 		function applyInvalidatedModules() {
/******/ 			if (queuedInvalidatedModules) {
/******/ 				if (!currentUpdateApplyHandlers) currentUpdateApplyHandlers = [];
/******/ 				Object.keys(__webpack_require__.hmrI).forEach(function (key) {
/******/ 					queuedInvalidatedModules.forEach(function (moduleId) {
/******/ 						__webpack_require__.hmrI[key](
/******/ 							moduleId,
/******/ 							currentUpdateApplyHandlers
/******/ 						);
/******/ 					});
/******/ 				});
/******/ 				queuedInvalidatedModules = undefined;
/******/ 				return true;
/******/ 			}
/******/ 		}
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	!function() {
/******/ 		__webpack_require__.p = "/_next/";
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/react refresh */
/******/ 	!function() {
/******/ 		if (__webpack_require__.i) {
/******/ 		__webpack_require__.i.push(function(options) {
/******/ 			var originalFactory = options.factory;
/******/ 			options.factory = function(moduleObject, moduleExports, webpackRequire) {
/******/ 				var hasRefresh = typeof self !== "undefined" && !!self.$RefreshInterceptModuleExecution$;
/******/ 				var cleanup = hasRefresh ? self.$RefreshInterceptModuleExecution$(moduleObject.id) : function() {};
/******/ 				try {
/******/ 					originalFactory.call(this, moduleObject, moduleExports, webpackRequire);
/******/ 				} finally {
/******/ 					cleanup();
/******/ 				}
/******/ 			}
/******/ 		})
/******/ 		}
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/compat */
/******/ 	
/******/ 	
/******/ 	// noop fns to prevent runtime errors during initialization
/******/ 	if (typeof self !== "undefined") {
/******/ 		self.$RefreshReg$ = function () {};
/******/ 		self.$RefreshSig$ = function () {
/******/ 			return function (type) {
/******/ 				return type;
/******/ 			};
/******/ 		};
/******/ 	}
/******/ 	
/******/ 	/* webpack/runtime/css loading */
/******/ 	!function() {
/******/ 		var createStylesheet = function(chunkId, fullhref, resolve, reject) {
/******/ 			var linkTag = document.createElement("link");
/******/ 		
/******/ 			linkTag.rel = "stylesheet";
/******/ 			linkTag.type = "text/css";
/******/ 			var onLinkComplete = function(event) {
/******/ 				// avoid mem leaks.
/******/ 				linkTag.onerror = linkTag.onload = null;
/******/ 				if (event.type === 'load') {
/******/ 					resolve();
/******/ 				} else {
/******/ 					var errorType = event && (event.type === 'load' ? 'missing' : event.type);
/******/ 					var realHref = event && event.target && event.target.href || fullhref;
/******/ 					var err = new Error("Loading CSS chunk " + chunkId + " failed.\n(" + realHref + ")");
/******/ 					err.code = "CSS_CHUNK_LOAD_FAILED";
/******/ 					err.type = errorType;
/******/ 					err.request = realHref;
/******/ 					linkTag.parentNode.removeChild(linkTag)
/******/ 					reject(err);
/******/ 				}
/******/ 			}
/******/ 			linkTag.onerror = linkTag.onload = onLinkComplete;
/******/ 			linkTag.href = fullhref;
/******/ 		
/******/ 			document.head.appendChild(linkTag);
/******/ 			return linkTag;
/******/ 		};
/******/ 		var findStylesheet = function(href, fullhref) {
/******/ 			var existingLinkTags = document.getElementsByTagName("link");
/******/ 			for(var i = 0; i < existingLinkTags.length; i++) {
/******/ 				var tag = existingLinkTags[i];
/******/ 				var dataHref = tag.getAttribute("data-href") || tag.getAttribute("href");
/******/ 				if(tag.rel === "stylesheet" && (dataHref === href || dataHref === fullhref)) return tag;
/******/ 			}
/******/ 			var existingStyleTags = document.getElementsByTagName("style");
/******/ 			for(var i = 0; i < existingStyleTags.length; i++) {
/******/ 				var tag = existingStyleTags[i];
/******/ 				var dataHref = tag.getAttribute("data-href");
/******/ 				if(dataHref === href || dataHref === fullhref) return tag;
/******/ 			}
/******/ 		};
/******/ 		var loadStylesheet = function(chunkId) {
/******/ 			return new Promise(function(resolve, reject) {
/******/ 				var href = __webpack_require__.miniCssF(chunkId);
/******/ 				var fullhref = __webpack_require__.p + href;
/******/ 				if(findStylesheet(href, fullhref)) return resolve();
/******/ 				createStylesheet(chunkId, fullhref, resolve, reject);
/******/ 			});
/******/ 		}
/******/ 		// no chunk loading
/******/ 		
/******/ 		var oldTags = [];
/******/ 		var newTags = [];
/******/ 		var applyHandler = function(options) {
/******/ 			return { dispose: function() {
/******/ 				for(var i = 0; i < oldTags.length; i++) {
/******/ 					var oldTag = oldTags[i];
/******/ 					if(oldTag.parentNode) oldTag.parentNode.removeChild(oldTag);
/******/ 				}
/******/ 				oldTags.length = 0;
/******/ 			}, apply: function() {
/******/ 				for(var i = 0; i < newTags.length; i++) newTags[i].rel = "stylesheet";
/******/ 				newTags.length = 0;
/******/ 			} };
/******/ 		}
/******/ 		__webpack_require__.hmrC.miniCss = function(chunkIds, removedChunks, removedModules, promises, applyHandlers, updatedModulesList) {
/******/ 			applyHandlers.push(applyHandler);
/******/ 			chunkIds.forEach(function(chunkId) {
/******/ 				var href = __webpack_require__.miniCssF(chunkId);
/******/ 				var fullhref = __webpack_require__.p + href;
/******/ 				var oldTag = findStylesheet(href, fullhref);
/******/ 				if(!oldTag) return;
/******/ 				promises.push(new Promise(function(resolve, reject) {
/******/ 					var tag = createStylesheet(chunkId, fullhref, function() {
/******/ 						tag.as = "style";
/******/ 						tag.rel = "preload";
/******/ 						resolve();
/******/ 					}, reject);
/******/ 					oldTags.push(oldTag);
/******/ 					newTags.push(tag);
/******/ 				}));
/******/ 			});
/******/ 		}
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/importScripts chunk loading */
/******/ 	!function() {
/******/ 		// no baseURI
/******/ 		
/******/ 		// object to store loaded chunks
/******/ 		// "1" means "already loaded"
/******/ 		var installedChunks = __webpack_require__.hmrS_importScripts = __webpack_require__.hmrS_importScripts || {
/******/ 			"_app-pages-browser_src_app_worker_js": 1
/******/ 		};
/******/ 		
/******/ 		// no chunk install function needed
/******/ 		// no chunk loading
/******/ 		
/******/ 		function loadUpdateChunk(chunkId, updatedModulesList) {
/******/ 			var success = false;
/******/ 			self["webpackHotUpdate_N_E"] = function(_, moreModules, runtime) {
/******/ 				for(var moduleId in moreModules) {
/******/ 					if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 						currentUpdate[moduleId] = moreModules[moduleId];
/******/ 						if(updatedModulesList) updatedModulesList.push(moduleId);
/******/ 					}
/******/ 				}
/******/ 				if(runtime) currentUpdateRuntime.push(runtime);
/******/ 				success = true;
/******/ 			};
/******/ 			// start update chunk loading
/******/ 			importScripts(__webpack_require__.tu(__webpack_require__.p + __webpack_require__.hu(chunkId)));
/******/ 			if(!success) throw new Error("Loading update chunk failed for unknown reason");
/******/ 		}
/******/ 		
/******/ 		var currentUpdateChunks;
/******/ 		var currentUpdate;
/******/ 		var currentUpdateRemovedChunks;
/******/ 		var currentUpdateRuntime;
/******/ 		function applyHandler(options) {
/******/ 			if (__webpack_require__.f) delete __webpack_require__.f.importScripsHmr;
/******/ 			currentUpdateChunks = undefined;
/******/ 			function getAffectedModuleEffects(updateModuleId) {
/******/ 				var outdatedModules = [updateModuleId];
/******/ 				var outdatedDependencies = {};
/******/ 		
/******/ 				var queue = outdatedModules.map(function (id) {
/******/ 					return {
/******/ 						chain: [id],
/******/ 						id: id
/******/ 					};
/******/ 				});
/******/ 				while (queue.length > 0) {
/******/ 					var queueItem = queue.pop();
/******/ 					var moduleId = queueItem.id;
/******/ 					var chain = queueItem.chain;
/******/ 					var module = __webpack_require__.c[moduleId];
/******/ 					if (
/******/ 						!module ||
/******/ 						(module.hot._selfAccepted && !module.hot._selfInvalidated)
/******/ 					)
/******/ 						continue;
/******/ 					if (module.hot._selfDeclined) {
/******/ 						return {
/******/ 							type: "self-declined",
/******/ 							chain: chain,
/******/ 							moduleId: moduleId
/******/ 						};
/******/ 					}
/******/ 					if (module.hot._main) {
/******/ 						return {
/******/ 							type: "unaccepted",
/******/ 							chain: chain,
/******/ 							moduleId: moduleId
/******/ 						};
/******/ 					}
/******/ 					for (var i = 0; i < module.parents.length; i++) {
/******/ 						var parentId = module.parents[i];
/******/ 						var parent = __webpack_require__.c[parentId];
/******/ 						if (!parent) continue;
/******/ 						if (parent.hot._declinedDependencies[moduleId]) {
/******/ 							return {
/******/ 								type: "declined",
/******/ 								chain: chain.concat([parentId]),
/******/ 								moduleId: moduleId,
/******/ 								parentId: parentId
/******/ 							};
/******/ 						}
/******/ 						if (outdatedModules.indexOf(parentId) !== -1) continue;
/******/ 						if (parent.hot._acceptedDependencies[moduleId]) {
/******/ 							if (!outdatedDependencies[parentId])
/******/ 								outdatedDependencies[parentId] = [];
/******/ 							addAllToSet(outdatedDependencies[parentId], [moduleId]);
/******/ 							continue;
/******/ 						}
/******/ 						delete outdatedDependencies[parentId];
/******/ 						outdatedModules.push(parentId);
/******/ 						queue.push({
/******/ 							chain: chain.concat([parentId]),
/******/ 							id: parentId
/******/ 						});
/******/ 					}
/******/ 				}
/******/ 		
/******/ 				return {
/******/ 					type: "accepted",
/******/ 					moduleId: updateModuleId,
/******/ 					outdatedModules: outdatedModules,
/******/ 					outdatedDependencies: outdatedDependencies
/******/ 				};
/******/ 			}
/******/ 		
/******/ 			function addAllToSet(a, b) {
/******/ 				for (var i = 0; i < b.length; i++) {
/******/ 					var item = b[i];
/******/ 					if (a.indexOf(item) === -1) a.push(item);
/******/ 				}
/******/ 			}
/******/ 		
/******/ 			// at begin all updates modules are outdated
/******/ 			// the "outdated" status can propagate to parents if they don't accept the children
/******/ 			var outdatedDependencies = {};
/******/ 			var outdatedModules = [];
/******/ 			var appliedUpdate = {};
/******/ 		
/******/ 			var warnUnexpectedRequire = function warnUnexpectedRequire(module) {
/******/ 				console.warn(
/******/ 					"[HMR] unexpected require(" + module.id + ") to disposed module"
/******/ 				);
/******/ 			};
/******/ 		
/******/ 			for (var moduleId in currentUpdate) {
/******/ 				if (__webpack_require__.o(currentUpdate, moduleId)) {
/******/ 					var newModuleFactory = currentUpdate[moduleId];
/******/ 					/** @type {TODO} */
/******/ 					var result;
/******/ 					if (newModuleFactory) {
/******/ 						result = getAffectedModuleEffects(moduleId);
/******/ 					} else {
/******/ 						result = {
/******/ 							type: "disposed",
/******/ 							moduleId: moduleId
/******/ 						};
/******/ 					}
/******/ 					/** @type {Error|false} */
/******/ 					var abortError = false;
/******/ 					var doApply = false;
/******/ 					var doDispose = false;
/******/ 					var chainInfo = "";
/******/ 					if (result.chain) {
/******/ 						chainInfo = "\nUpdate propagation: " + result.chain.join(" -> ");
/******/ 					}
/******/ 					switch (result.type) {
/******/ 						case "self-declined":
/******/ 							if (options.onDeclined) options.onDeclined(result);
/******/ 							if (!options.ignoreDeclined)
/******/ 								abortError = new Error(
/******/ 									"Aborted because of self decline: " +
/******/ 										result.moduleId +
/******/ 										chainInfo
/******/ 								);
/******/ 							break;
/******/ 						case "declined":
/******/ 							if (options.onDeclined) options.onDeclined(result);
/******/ 							if (!options.ignoreDeclined)
/******/ 								abortError = new Error(
/******/ 									"Aborted because of declined dependency: " +
/******/ 										result.moduleId +
/******/ 										" in " +
/******/ 										result.parentId +
/******/ 										chainInfo
/******/ 								);
/******/ 							break;
/******/ 						case "unaccepted":
/******/ 							if (options.onUnaccepted) options.onUnaccepted(result);
/******/ 							if (!options.ignoreUnaccepted)
/******/ 								abortError = new Error(
/******/ 									"Aborted because " + moduleId + " is not accepted" + chainInfo
/******/ 								);
/******/ 							break;
/******/ 						case "accepted":
/******/ 							if (options.onAccepted) options.onAccepted(result);
/******/ 							doApply = true;
/******/ 							break;
/******/ 						case "disposed":
/******/ 							if (options.onDisposed) options.onDisposed(result);
/******/ 							doDispose = true;
/******/ 							break;
/******/ 						default:
/******/ 							throw new Error("Unexception type " + result.type);
/******/ 					}
/******/ 					if (abortError) {
/******/ 						return {
/******/ 							error: abortError
/******/ 						};
/******/ 					}
/******/ 					if (doApply) {
/******/ 						appliedUpdate[moduleId] = newModuleFactory;
/******/ 						addAllToSet(outdatedModules, result.outdatedModules);
/******/ 						for (moduleId in result.outdatedDependencies) {
/******/ 							if (__webpack_require__.o(result.outdatedDependencies, moduleId)) {
/******/ 								if (!outdatedDependencies[moduleId])
/******/ 									outdatedDependencies[moduleId] = [];
/******/ 								addAllToSet(
/******/ 									outdatedDependencies[moduleId],
/******/ 									result.outdatedDependencies[moduleId]
/******/ 								);
/******/ 							}
/******/ 						}
/******/ 					}
/******/ 					if (doDispose) {
/******/ 						addAllToSet(outdatedModules, [result.moduleId]);
/******/ 						appliedUpdate[moduleId] = warnUnexpectedRequire;
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 			currentUpdate = undefined;
/******/ 		
/******/ 			// Store self accepted outdated modules to require them later by the module system
/******/ 			var outdatedSelfAcceptedModules = [];
/******/ 			for (var j = 0; j < outdatedModules.length; j++) {
/******/ 				var outdatedModuleId = outdatedModules[j];
/******/ 				var module = __webpack_require__.c[outdatedModuleId];
/******/ 				if (
/******/ 					module &&
/******/ 					(module.hot._selfAccepted || module.hot._main) &&
/******/ 					// removed self-accepted modules should not be required
/******/ 					appliedUpdate[outdatedModuleId] !== warnUnexpectedRequire &&
/******/ 					// when called invalidate self-accepting is not possible
/******/ 					!module.hot._selfInvalidated
/******/ 				) {
/******/ 					outdatedSelfAcceptedModules.push({
/******/ 						module: outdatedModuleId,
/******/ 						require: module.hot._requireSelf,
/******/ 						errorHandler: module.hot._selfAccepted
/******/ 					});
/******/ 				}
/******/ 			}
/******/ 		
/******/ 			var moduleOutdatedDependencies;
/******/ 		
/******/ 			return {
/******/ 				dispose: function () {
/******/ 					currentUpdateRemovedChunks.forEach(function (chunkId) {
/******/ 						delete installedChunks[chunkId];
/******/ 					});
/******/ 					currentUpdateRemovedChunks = undefined;
/******/ 		
/******/ 					var idx;
/******/ 					var queue = outdatedModules.slice();
/******/ 					while (queue.length > 0) {
/******/ 						var moduleId = queue.pop();
/******/ 						var module = __webpack_require__.c[moduleId];
/******/ 						if (!module) continue;
/******/ 		
/******/ 						var data = {};
/******/ 		
/******/ 						// Call dispose handlers
/******/ 						var disposeHandlers = module.hot._disposeHandlers;
/******/ 						for (j = 0; j < disposeHandlers.length; j++) {
/******/ 							disposeHandlers[j].call(null, data);
/******/ 						}
/******/ 						__webpack_require__.hmrD[moduleId] = data;
/******/ 		
/******/ 						// disable module (this disables requires from this module)
/******/ 						module.hot.active = false;
/******/ 		
/******/ 						// remove module from cache
/******/ 						delete __webpack_require__.c[moduleId];
/******/ 		
/******/ 						// when disposing there is no need to call dispose handler
/******/ 						delete outdatedDependencies[moduleId];
/******/ 		
/******/ 						// remove "parents" references from all children
/******/ 						for (j = 0; j < module.children.length; j++) {
/******/ 							var child = __webpack_require__.c[module.children[j]];
/******/ 							if (!child) continue;
/******/ 							idx = child.parents.indexOf(moduleId);
/******/ 							if (idx >= 0) {
/******/ 								child.parents.splice(idx, 1);
/******/ 							}
/******/ 						}
/******/ 					}
/******/ 		
/******/ 					// remove outdated dependency from module children
/******/ 					var dependency;
/******/ 					for (var outdatedModuleId in outdatedDependencies) {
/******/ 						if (__webpack_require__.o(outdatedDependencies, outdatedModuleId)) {
/******/ 							module = __webpack_require__.c[outdatedModuleId];
/******/ 							if (module) {
/******/ 								moduleOutdatedDependencies =
/******/ 									outdatedDependencies[outdatedModuleId];
/******/ 								for (j = 0; j < moduleOutdatedDependencies.length; j++) {
/******/ 									dependency = moduleOutdatedDependencies[j];
/******/ 									idx = module.children.indexOf(dependency);
/******/ 									if (idx >= 0) module.children.splice(idx, 1);
/******/ 								}
/******/ 							}
/******/ 						}
/******/ 					}
/******/ 				},
/******/ 				apply: function (reportError) {
/******/ 					// insert new code
/******/ 					for (var updateModuleId in appliedUpdate) {
/******/ 						if (__webpack_require__.o(appliedUpdate, updateModuleId)) {
/******/ 							__webpack_require__.m[updateModuleId] = appliedUpdate[updateModuleId];
/******/ 						}
/******/ 					}
/******/ 		
/******/ 					// run new runtime modules
/******/ 					for (var i = 0; i < currentUpdateRuntime.length; i++) {
/******/ 						currentUpdateRuntime[i](__webpack_require__);
/******/ 					}
/******/ 		
/******/ 					// call accept handlers
/******/ 					for (var outdatedModuleId in outdatedDependencies) {
/******/ 						if (__webpack_require__.o(outdatedDependencies, outdatedModuleId)) {
/******/ 							var module = __webpack_require__.c[outdatedModuleId];
/******/ 							if (module) {
/******/ 								moduleOutdatedDependencies =
/******/ 									outdatedDependencies[outdatedModuleId];
/******/ 								var callbacks = [];
/******/ 								var errorHandlers = [];
/******/ 								var dependenciesForCallbacks = [];
/******/ 								for (var j = 0; j < moduleOutdatedDependencies.length; j++) {
/******/ 									var dependency = moduleOutdatedDependencies[j];
/******/ 									var acceptCallback =
/******/ 										module.hot._acceptedDependencies[dependency];
/******/ 									var errorHandler =
/******/ 										module.hot._acceptedErrorHandlers[dependency];
/******/ 									if (acceptCallback) {
/******/ 										if (callbacks.indexOf(acceptCallback) !== -1) continue;
/******/ 										callbacks.push(acceptCallback);
/******/ 										errorHandlers.push(errorHandler);
/******/ 										dependenciesForCallbacks.push(dependency);
/******/ 									}
/******/ 								}
/******/ 								for (var k = 0; k < callbacks.length; k++) {
/******/ 									try {
/******/ 										callbacks[k].call(null, moduleOutdatedDependencies);
/******/ 									} catch (err) {
/******/ 										if (typeof errorHandlers[k] === "function") {
/******/ 											try {
/******/ 												errorHandlers[k](err, {
/******/ 													moduleId: outdatedModuleId,
/******/ 													dependencyId: dependenciesForCallbacks[k]
/******/ 												});
/******/ 											} catch (err2) {
/******/ 												if (options.onErrored) {
/******/ 													options.onErrored({
/******/ 														type: "accept-error-handler-errored",
/******/ 														moduleId: outdatedModuleId,
/******/ 														dependencyId: dependenciesForCallbacks[k],
/******/ 														error: err2,
/******/ 														originalError: err
/******/ 													});
/******/ 												}
/******/ 												if (!options.ignoreErrored) {
/******/ 													reportError(err2);
/******/ 													reportError(err);
/******/ 												}
/******/ 											}
/******/ 										} else {
/******/ 											if (options.onErrored) {
/******/ 												options.onErrored({
/******/ 													type: "accept-errored",
/******/ 													moduleId: outdatedModuleId,
/******/ 													dependencyId: dependenciesForCallbacks[k],
/******/ 													error: err
/******/ 												});
/******/ 											}
/******/ 											if (!options.ignoreErrored) {
/******/ 												reportError(err);
/******/ 											}
/******/ 										}
/******/ 									}
/******/ 								}
/******/ 							}
/******/ 						}
/******/ 					}
/******/ 		
/******/ 					// Load self accepted modules
/******/ 					for (var o = 0; o < outdatedSelfAcceptedModules.length; o++) {
/******/ 						var item = outdatedSelfAcceptedModules[o];
/******/ 						var moduleId = item.module;
/******/ 						try {
/******/ 							item.require(moduleId);
/******/ 						} catch (err) {
/******/ 							if (typeof item.errorHandler === "function") {
/******/ 								try {
/******/ 									item.errorHandler(err, {
/******/ 										moduleId: moduleId,
/******/ 										module: __webpack_require__.c[moduleId]
/******/ 									});
/******/ 								} catch (err2) {
/******/ 									if (options.onErrored) {
/******/ 										options.onErrored({
/******/ 											type: "self-accept-error-handler-errored",
/******/ 											moduleId: moduleId,
/******/ 											error: err2,
/******/ 											originalError: err
/******/ 										});
/******/ 									}
/******/ 									if (!options.ignoreErrored) {
/******/ 										reportError(err2);
/******/ 										reportError(err);
/******/ 									}
/******/ 								}
/******/ 							} else {
/******/ 								if (options.onErrored) {
/******/ 									options.onErrored({
/******/ 										type: "self-accept-errored",
/******/ 										moduleId: moduleId,
/******/ 										error: err
/******/ 									});
/******/ 								}
/******/ 								if (!options.ignoreErrored) {
/******/ 									reportError(err);
/******/ 								}
/******/ 							}
/******/ 						}
/******/ 					}
/******/ 		
/******/ 					return outdatedModules;
/******/ 				}
/******/ 			};
/******/ 		}
/******/ 		__webpack_require__.hmrI.importScrips = function (moduleId, applyHandlers) {
/******/ 			if (!currentUpdate) {
/******/ 				currentUpdate = {};
/******/ 				currentUpdateRuntime = [];
/******/ 				currentUpdateRemovedChunks = [];
/******/ 				applyHandlers.push(applyHandler);
/******/ 			}
/******/ 			if (!__webpack_require__.o(currentUpdate, moduleId)) {
/******/ 				currentUpdate[moduleId] = __webpack_require__.m[moduleId];
/******/ 			}
/******/ 		};
/******/ 		__webpack_require__.hmrC.importScrips = function (
/******/ 			chunkIds,
/******/ 			removedChunks,
/******/ 			removedModules,
/******/ 			promises,
/******/ 			applyHandlers,
/******/ 			updatedModulesList
/******/ 		) {
/******/ 			applyHandlers.push(applyHandler);
/******/ 			currentUpdateChunks = {};
/******/ 			currentUpdateRemovedChunks = removedChunks;
/******/ 			currentUpdate = removedModules.reduce(function (obj, key) {
/******/ 				obj[key] = false;
/******/ 				return obj;
/******/ 			}, {});
/******/ 			currentUpdateRuntime = [];
/******/ 			chunkIds.forEach(function (chunkId) {
/******/ 				if (
/******/ 					__webpack_require__.o(installedChunks, chunkId) &&
/******/ 					installedChunks[chunkId] !== undefined
/******/ 				) {
/******/ 					promises.push(loadUpdateChunk(chunkId, updatedModulesList));
/******/ 					currentUpdateChunks[chunkId] = true;
/******/ 				} else {
/******/ 					currentUpdateChunks[chunkId] = false;
/******/ 				}
/******/ 			});
/******/ 			if (__webpack_require__.f) {
/******/ 				__webpack_require__.f.importScripsHmr = function (chunkId, promises) {
/******/ 					if (
/******/ 						currentUpdateChunks &&
/******/ 						__webpack_require__.o(currentUpdateChunks, chunkId) &&
/******/ 						!currentUpdateChunks[chunkId]
/******/ 					) {
/******/ 						promises.push(loadUpdateChunk(chunkId));
/******/ 						currentUpdateChunks[chunkId] = true;
/******/ 					}
/******/ 				};
/******/ 			}
/******/ 		};
/******/ 		
/******/ 		__webpack_require__.hmrM = function() {
/******/ 			if (typeof fetch === "undefined") throw new Error("No browser support: need fetch API");
/******/ 			return fetch(__webpack_require__.p + __webpack_require__.hmrF()).then(function(response) {
/******/ 				if(response.status === 404) return; // no update available
/******/ 				if(!response.ok) throw new Error("Failed to fetch update manifest " + response.statusText);
/******/ 				return response.json();
/******/ 			});
/******/ 		};
/******/ 	}();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// module cache are used so entry inlining is disabled
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	var __webpack_exports__ = __webpack_require__("(app-pages-browser)/./src/app/worker.js");
/******/ 	_N_E = __webpack_exports__;
/******/ 	
/******/ })()
;