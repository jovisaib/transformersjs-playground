/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "crypto":
/*!*************************!*\
  !*** external "crypto" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("crypto");

/***/ }),

/***/ "fs":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/***/ ((module) => {

"use strict";
module.exports = require("fs");

/***/ }),

/***/ "os":
/*!*********************!*\
  !*** external "os" ***!
  \*********************/
/***/ ((module) => {

"use strict";
module.exports = require("os");

/***/ }),

/***/ "path":
/*!***********************!*\
  !*** external "path" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("path");

/***/ }),

/***/ "perf_hooks":
/*!*****************************!*\
  !*** external "perf_hooks" ***!
  \*****************************/
/***/ ((module) => {

"use strict";
module.exports = require("perf_hooks");

/***/ }),

/***/ "stream/web":
/*!*****************************!*\
  !*** external "stream/web" ***!
  \*****************************/
/***/ ((module) => {

"use strict";
module.exports = require("stream/web");

/***/ }),

/***/ "url":
/*!**********************!*\
  !*** external "url" ***!
  \**********************/
/***/ ((module) => {

"use strict";
module.exports = require("url");

/***/ }),

/***/ "util":
/*!***********************!*\
  !*** external "util" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("util");

/***/ }),

/***/ "worker_threads":
/*!*********************************!*\
  !*** external "worker_threads" ***!
  \*********************************/
/***/ ((module) => {

"use strict";
module.exports = require("worker_threads");

/***/ }),

/***/ "?c7c8":
/*!**********************************!*\
  !*** onnxruntime-node (ignored) ***!
  \**********************************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?1170":
/*!***********************!*\
  !*** sharp (ignored) ***!
  \***********************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "(ssr)/./src/app/worker.js":
/*!***************************!*\
  !*** ./src/app/worker.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _xenova_transformers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @xenova/transformers */ \"(ssr)/./node_modules/@xenova/transformers/src/transformers.js\");\n\n// Skip local model check\n_xenova_transformers__WEBPACK_IMPORTED_MODULE_0__.env.allowLocalModels = false;\n// Use the Singleton pattern to enable lazy construction of the pipeline.\nclass PipelineSingleton {\n    static{\n        this.task = \"text-classification\";\n    }\n    static{\n        this.model = \"Xenova/distilbert-base-uncased-finetuned-sst-2-english\";\n    }\n    static{\n        this.instance = null;\n    }\n    static async getInstance(progress_callback = null) {\n        if (this.instance === null) {\n            this.instance = (0,_xenova_transformers__WEBPACK_IMPORTED_MODULE_0__.pipeline)(this.task, this.model, {\n                progress_callback\n            });\n        }\n        return this.instance;\n    }\n}\n// Listen for messages from the main thread\nself.addEventListener(\"message\", async (event)=>{\n    // Retrieve the classification pipeline. When called for the first time,\n    // this will load the pipeline and save it for future use.\n    let classifier = await PipelineSingleton.getInstance((x)=>{\n        // We also add a progress callback to the pipeline so that we can\n        // track model loading.\n        self.postMessage(x);\n    });\n    // Actually perform the classification\n    let output = await classifier(event.data.text);\n    // Send the output back to the main thread\n    self.postMessage({\n        status: \"complete\",\n        output: output\n    });\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9zcmMvYXBwL3dvcmtlci5qcyIsIm1hcHBpbmdzIjoiOztBQUFxRDtBQUVyRCx5QkFBeUI7QUFDekJDLHFEQUFHQSxDQUFDQyxnQkFBZ0IsR0FBRztBQUV2Qix5RUFBeUU7QUFDekUsTUFBTUM7O2FBQ0tDLE9BQU87OzthQUNQQyxRQUFROzs7YUFDUkMsV0FBVzs7SUFFbEIsYUFBYUMsWUFBWUMsb0JBQW9CLElBQUksRUFBRTtRQUMvQyxJQUFJLElBQUksQ0FBQ0YsUUFBUSxLQUFLLE1BQU07WUFDeEIsSUFBSSxDQUFDQSxRQUFRLEdBQUdOLDhEQUFRQSxDQUFDLElBQUksQ0FBQ0ksSUFBSSxFQUFFLElBQUksQ0FBQ0MsS0FBSyxFQUFFO2dCQUFFRztZQUFrQjtRQUN4RTtRQUNBLE9BQU8sSUFBSSxDQUFDRixRQUFRO0lBQ3hCO0FBQ0o7QUFFQSwyQ0FBMkM7QUFDM0NHLEtBQUtDLGdCQUFnQixDQUFDLFdBQVcsT0FBT0M7SUFDcEMsd0VBQXdFO0lBQ3hFLDBEQUEwRDtJQUMxRCxJQUFJQyxhQUFhLE1BQU1ULGtCQUFrQkksV0FBVyxDQUFDTSxDQUFBQTtRQUNqRCxpRUFBaUU7UUFDakUsdUJBQXVCO1FBQ3ZCSixLQUFLSyxXQUFXLENBQUNEO0lBQ3JCO0lBRUEsc0NBQXNDO0lBQ3RDLElBQUlFLFNBQVMsTUFBTUgsV0FBV0QsTUFBTUssSUFBSSxDQUFDQyxJQUFJO0lBRTdDLDBDQUEwQztJQUMxQ1IsS0FBS0ssV0FBVyxDQUFDO1FBQ2JJLFFBQVE7UUFDUkgsUUFBUUE7SUFDWjtBQUNKIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdHJhbnNmb3JtZXJzanMtcGxheWdyb3VuZC8uL3NyYy9hcHAvd29ya2VyLmpzP2VkMDkiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgcGlwZWxpbmUsIGVudiB9IGZyb20gXCJAeGVub3ZhL3RyYW5zZm9ybWVyc1wiO1xuXG4vLyBTa2lwIGxvY2FsIG1vZGVsIGNoZWNrXG5lbnYuYWxsb3dMb2NhbE1vZGVscyA9IGZhbHNlO1xuXG4vLyBVc2UgdGhlIFNpbmdsZXRvbiBwYXR0ZXJuIHRvIGVuYWJsZSBsYXp5IGNvbnN0cnVjdGlvbiBvZiB0aGUgcGlwZWxpbmUuXG5jbGFzcyBQaXBlbGluZVNpbmdsZXRvbiB7XG4gICAgc3RhdGljIHRhc2sgPSAndGV4dC1jbGFzc2lmaWNhdGlvbic7XG4gICAgc3RhdGljIG1vZGVsID0gJ1hlbm92YS9kaXN0aWxiZXJ0LWJhc2UtdW5jYXNlZC1maW5ldHVuZWQtc3N0LTItZW5nbGlzaCc7XG4gICAgc3RhdGljIGluc3RhbmNlID0gbnVsbDtcblxuICAgIHN0YXRpYyBhc3luYyBnZXRJbnN0YW5jZShwcm9ncmVzc19jYWxsYmFjayA9IG51bGwpIHtcbiAgICAgICAgaWYgKHRoaXMuaW5zdGFuY2UgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuaW5zdGFuY2UgPSBwaXBlbGluZSh0aGlzLnRhc2ssIHRoaXMubW9kZWwsIHsgcHJvZ3Jlc3NfY2FsbGJhY2sgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuaW5zdGFuY2U7XG4gICAgfVxufVxuXG4vLyBMaXN0ZW4gZm9yIG1lc3NhZ2VzIGZyb20gdGhlIG1haW4gdGhyZWFkXG5zZWxmLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBhc3luYyAoZXZlbnQpID0+IHtcbiAgICAvLyBSZXRyaWV2ZSB0aGUgY2xhc3NpZmljYXRpb24gcGlwZWxpbmUuIFdoZW4gY2FsbGVkIGZvciB0aGUgZmlyc3QgdGltZSxcbiAgICAvLyB0aGlzIHdpbGwgbG9hZCB0aGUgcGlwZWxpbmUgYW5kIHNhdmUgaXQgZm9yIGZ1dHVyZSB1c2UuXG4gICAgbGV0IGNsYXNzaWZpZXIgPSBhd2FpdCBQaXBlbGluZVNpbmdsZXRvbi5nZXRJbnN0YW5jZSh4ID0+IHtcbiAgICAgICAgLy8gV2UgYWxzbyBhZGQgYSBwcm9ncmVzcyBjYWxsYmFjayB0byB0aGUgcGlwZWxpbmUgc28gdGhhdCB3ZSBjYW5cbiAgICAgICAgLy8gdHJhY2sgbW9kZWwgbG9hZGluZy5cbiAgICAgICAgc2VsZi5wb3N0TWVzc2FnZSh4KTtcbiAgICB9KTtcblxuICAgIC8vIEFjdHVhbGx5IHBlcmZvcm0gdGhlIGNsYXNzaWZpY2F0aW9uXG4gICAgbGV0IG91dHB1dCA9IGF3YWl0IGNsYXNzaWZpZXIoZXZlbnQuZGF0YS50ZXh0KTtcblxuICAgIC8vIFNlbmQgdGhlIG91dHB1dCBiYWNrIHRvIHRoZSBtYWluIHRocmVhZFxuICAgIHNlbGYucG9zdE1lc3NhZ2Uoe1xuICAgICAgICBzdGF0dXM6ICdjb21wbGV0ZScsXG4gICAgICAgIG91dHB1dDogb3V0cHV0LFxuICAgIH0pO1xufSk7Il0sIm5hbWVzIjpbInBpcGVsaW5lIiwiZW52IiwiYWxsb3dMb2NhbE1vZGVscyIsIlBpcGVsaW5lU2luZ2xldG9uIiwidGFzayIsIm1vZGVsIiwiaW5zdGFuY2UiLCJnZXRJbnN0YW5jZSIsInByb2dyZXNzX2NhbGxiYWNrIiwic2VsZiIsImFkZEV2ZW50TGlzdGVuZXIiLCJldmVudCIsImNsYXNzaWZpZXIiLCJ4IiwicG9zdE1lc3NhZ2UiLCJvdXRwdXQiLCJkYXRhIiwidGV4dCIsInN0YXR1cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./src/app/worker.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/onnxruntime-common/dist/ort-common.node.js":
/*!*****************************************************************!*\
  !*** ./node_modules/onnxruntime-common/dist/ort-common.node.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("/*!\n * ONNX Runtime Common v1.14.0\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n(()=>{\"use strict\";var e={d:(t,r)=>{for(var n in r)e.o(r,n)&&!e.o(t,n)&&Object.defineProperty(t,n,{enumerable:!0,get:r[n]})},o:(e,t)=>Object.prototype.hasOwnProperty.call(e,t),r:e=>{\"undefined\"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:\"Module\"}),Object.defineProperty(e,\"__esModule\",{value:!0})}},t={};e.r(t),e.d(t,{InferenceSession:()=>c,Tensor:()=>g,env:()=>i,registerBackend:()=>o});const r={},n=[],o=(e,t,o)=>{if(!t||\"function\"!=typeof t.init||\"function\"!=typeof t.createSessionHandler)throw new TypeError(\"not a valid backend\");{const i=r[e];if(void 0===i)r[e]={backend:t,priority:o};else{if(i.priority>o)return;if(i.priority===o&&i.backend!==t)throw new Error(`cannot register backend \"${e}\" using priority ${o}`)}if(o>=0){const t=n.indexOf(e);-1!==t&&n.splice(t,1);for(let t=0;t<n.length;t++)if(r[n[t]].priority<=o)return void n.splice(t,0,e);n.push(e)}}},i=new class{constructor(){this.wasm={},this.webgl={},this.logLevelInternal=\"warning\"}set logLevel(e){if(void 0!==e){if(\"string\"!=typeof e||-1===[\"verbose\",\"info\",\"warning\",\"error\",\"fatal\"].indexOf(e))throw new Error(`Unsupported logging level: ${e}`);this.logLevelInternal=e}}get logLevel(){return this.logLevelInternal}},a=\"undefined\"!=typeof BigInt64Array&&\"function\"==typeof BigInt64Array.from,s=\"undefined\"!=typeof BigUint64Array&&\"function\"==typeof BigUint64Array.from,d=new Map([[\"float32\",Float32Array],[\"uint8\",Uint8Array],[\"int8\",Int8Array],[\"uint16\",Uint16Array],[\"int16\",Int16Array],[\"int32\",Int32Array],[\"bool\",Uint8Array],[\"float64\",Float64Array],[\"uint32\",Uint32Array]]),f=new Map([[Float32Array,\"float32\"],[Uint8Array,\"uint8\"],[Int8Array,\"int8\"],[Uint16Array,\"uint16\"],[Int16Array,\"int16\"],[Int32Array,\"int32\"],[Float64Array,\"float64\"],[Uint32Array,\"uint32\"]]);a&&(d.set(\"int64\",BigInt64Array),f.set(BigInt64Array,\"int64\")),s&&(d.set(\"uint64\",BigUint64Array),f.set(BigUint64Array,\"uint64\"));class h{constructor(e,t,r){let n,o,i;if(\"string\"==typeof e)if(n=e,i=r,\"string\"===e){if(!Array.isArray(t))throw new TypeError(\"A string tensor's data must be a string array.\");o=t}else{const r=d.get(e);if(void 0===r)throw new TypeError(`Unsupported tensor type: ${e}.`);if(Array.isArray(t))o=r.from(t);else{if(!(t instanceof r))throw new TypeError(`A ${n} tensor's data must be type of ${r}`);o=t}}else if(i=t,Array.isArray(e)){if(0===e.length)throw new TypeError(\"Tensor type cannot be inferred from an empty array.\");const t=typeof e[0];if(\"string\"===t)n=\"string\",o=e;else{if(\"boolean\"!==t)throw new TypeError(`Invalid element type of data array: ${t}.`);n=\"bool\",o=Uint8Array.from(e)}}else{const t=f.get(e.constructor);if(void 0===t)throw new TypeError(`Unsupported type for tensor data: ${e.constructor}.`);n=t,o=e}if(void 0===i)i=[o.length];else if(!Array.isArray(i))throw new TypeError(\"A tensor's dims must be a number array\");const a=(e=>{let t=1;for(let r=0;r<e.length;r++){const n=e[r];if(\"number\"!=typeof n||!Number.isSafeInteger(n))throw new TypeError(`dims[${r}] must be an integer, got: ${n}`);if(n<0)throw new RangeError(`dims[${r}] must be a non-negative integer, got: ${n}`);t*=n}return t})(i);if(a!==o.length)throw new Error(`Tensor's size(${a}) does not match data length(${o.length}).`);this.dims=i,this.type=n,this.data=o,this.size=a}static bufferToTensor(e,t){if(void 0===e)throw new Error(\"Image buffer must be defined\");if(void 0===t.height||void 0===t.width)throw new Error(\"Image height and width must be defined\");const{height:r,width:n}=t,o=t.norm;let i,a;i=void 0===o||void 0===o.mean?255:o.mean,a=void 0===o||void 0===o.bias?0:o.bias;const s=void 0!==t.bitmapFormat?t.bitmapFormat:\"RGBA\",d=void 0!==t.tensorFormat&&void 0!==t.tensorFormat?t.tensorFormat:\"RGB\",f=r*n,g=\"RGBA\"===d?new Float32Array(4*f):new Float32Array(3*f);let m=4,c=0,l=1,w=2,u=3,p=0,y=f,b=2*f,v=-1;\"RGB\"===s&&(m=3,c=0,l=1,w=2,u=-1),\"RGBA\"===d?v=3*f:\"RBG\"===d?(p=0,b=f,y=2*f):\"BGR\"===d&&(b=0,y=f,p=2*f);for(let t=0;t<f;t++,c+=m,w+=m,l+=m,u+=m)g[p++]=(e[c]+a)/i,g[y++]=(e[l]+a)/i,g[b++]=(e[w]+a)/i,-1!==v&&-1!==u&&(g[v++]=(e[u]+a)/i);return new h(\"float32\",g,\"RGBA\"===d?[1,4,r,n]:[1,3,r,n])}static async fromImage(e,t){const r=\"undefined\"!=typeof HTMLImageElement&&e instanceof HTMLImageElement,n=\"undefined\"!=typeof ImageData&&e instanceof ImageData,o=\"undefined\"!=typeof ImageBitmap&&e instanceof ImageBitmap,i=\"undefined\"!=typeof String&&(e instanceof String||\"string\"==typeof e);let a,s={};if(r){const r=document.createElement(\"canvas\"),n=r.getContext(\"2d\");if(null==n)throw new Error(\"Can not access image data\");{let o=e.naturalHeight,i=e.naturalWidth;if(void 0!==t&&void 0!==t.resizedHeight&&void 0!==t.resizedWidth&&(o=t.resizedHeight,i=t.resizedWidth),void 0!==t){if(s=t,void 0!==t.tensorFormat)throw new Error(\"Image input config format must be RGBA for HTMLImageElement\");if(s.tensorFormat=\"RGBA\",void 0!==t.height&&t.height!==o)throw new Error(\"Image input config height doesn't match HTMLImageElement height\");if(s.height=o,void 0!==t.width&&t.width!==i)throw new Error(\"Image input config width doesn't match HTMLImageElement width\");s.width=i}else s.tensorFormat=\"RGBA\",s.height=o,s.width=i;r.width=i,r.height=o,n.drawImage(e,0,0,i,o),a=n.getImageData(0,0,i,o).data}}else{if(!n){if(o){if(void 0===t)throw new Error(\"Please provide image config with format for Imagebitmap\");if(void 0!==t.bitmapFormat)throw new Error(\"Image input config format must be defined for ImageBitmap\");const r=document.createElement(\"canvas\").getContext(\"2d\");if(null!=r){const n=e.height,o=e.width;if(r.drawImage(e,0,0,o,n),a=r.getImageData(0,0,o,n).data,void 0!==t){if(void 0!==t.height&&t.height!==n)throw new Error(\"Image input config height doesn't match ImageBitmap height\");if(s.height=n,void 0!==t.width&&t.width!==o)throw new Error(\"Image input config width doesn't match ImageBitmap width\");s.width=o}else s.height=n,s.width=o;return h.bufferToTensor(a,s)}throw new Error(\"Can not access image data\")}if(i)return new Promise(((r,n)=>{const o=document.createElement(\"canvas\"),i=o.getContext(\"2d\");if(!e||!i)return n();const a=new Image;a.crossOrigin=\"Anonymous\",a.src=e,a.onload=()=>{o.width=a.width,o.height=a.height,i.drawImage(a,0,0,o.width,o.height);const e=i.getImageData(0,0,o.width,o.height);if(void 0!==t){if(void 0!==t.height&&t.height!==o.height)throw new Error(\"Image input config height doesn't match ImageBitmap height\");if(s.height=o.height,void 0!==t.width&&t.width!==o.width)throw new Error(\"Image input config width doesn't match ImageBitmap width\");s.width=o.width}else s.height=o.height,s.width=o.width;r(h.bufferToTensor(e.data,s))}}));throw new Error(\"Input data provided is not supported - aborted tensor creation\")}{const r=\"RGBA\";let n,o;if(void 0!==t&&void 0!==t.resizedWidth&&void 0!==t.resizedHeight?(n=t.resizedHeight,o=t.resizedWidth):(n=e.height,o=e.width),void 0!==t){if(s=t,void 0!==t.bitmapFormat&&t.bitmapFormat!==r)throw new Error(\"Image input config format must be RGBA for ImageData\");s.bitmapFormat=\"RGBA\"}else s.bitmapFormat=\"RGBA\";if(s.height=n,s.width=o,void 0!==t){const t=document.createElement(\"canvas\");t.width=o,t.height=n;const r=t.getContext(\"2d\");if(null==r)throw new Error(\"Can not access image data\");r.putImageData(e,0,0),a=r.getImageData(0,0,o,n).data}else a=e.data}}if(void 0!==a)return h.bufferToTensor(a,s);throw new Error(\"Input data provided is not supported - aborted tensor creation\")}toImageData(e){var t,r;const n=document.createElement(\"canvas\").getContext(\"2d\");let o;if(null==n)throw new Error(\"Can not access image data\");{const i=this.dims[3],a=this.dims[2],s=this.dims[1],d=void 0!==e&&void 0!==e.format?e.format:\"RGB\",f=void 0!==e&&void 0!==(null===(t=e.norm)||void 0===t?void 0:t.mean)?e.norm.mean:255,h=void 0!==e&&void 0!==(null===(r=e.norm)||void 0===r?void 0:r.bias)?e.norm.bias:0,g=a*i;if(void 0!==e){if(void 0!==e.height&&e.height!==a)throw new Error(\"Image output config height doesn't match tensor height\");if(void 0!==e.width&&e.width!==i)throw new Error(\"Image output config width doesn't match tensor width\");if(void 0!==e.format&&4===s&&\"RGBA\"!==e.format||3===s&&\"RGB\"!==e.format&&\"BGR\"!==e.format)throw new Error(\"Tensor format doesn't match input tensor dims\")}const m=4;let c=0,l=1,w=2,u=3,p=0,y=g,b=2*g,v=-1;\"RGBA\"===d?(p=0,y=g,b=2*g,v=3*g):\"RGB\"===d?(p=0,y=g,b=2*g):\"RBG\"===d&&(p=0,b=g,y=2*g),o=n.createImageData(i,a);for(let e=0;e<a*i;c+=m,l+=m,w+=m,u+=m,e++)o.data[c]=(this.data[p++]-h)*f,o.data[l]=(this.data[y++]-h)*f,o.data[w]=(this.data[b++]-h)*f,o.data[u]=-1===v?255:(this.data[v++]-h)*f}return o}reshape(e){return new h(this.type,this.data,e)}}const g=h;class m{constructor(e){this.handler=e}async run(e,t,r){const n={};let o={};if(\"object\"!=typeof e||null===e||e instanceof g||Array.isArray(e))throw new TypeError(\"'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.\");let i=!0;if(\"object\"==typeof t){if(null===t)throw new TypeError(\"Unexpected argument[1]: cannot be null.\");if(t instanceof g)throw new TypeError(\"'fetches' cannot be a Tensor\");if(Array.isArray(t)){if(0===t.length)throw new TypeError(\"'fetches' cannot be an empty array.\");i=!1;for(const e of t){if(\"string\"!=typeof e)throw new TypeError(\"'fetches' must be a string array or an object.\");if(-1===this.outputNames.indexOf(e))throw new RangeError(`'fetches' contains invalid output name: ${e}.`);n[e]=null}if(\"object\"==typeof r&&null!==r)o=r;else if(void 0!==r)throw new TypeError(\"'options' must be an object.\")}else{let e=!1;const a=Object.getOwnPropertyNames(t);for(const r of this.outputNames)if(-1!==a.indexOf(r)){const o=t[r];(null===o||o instanceof g)&&(e=!0,i=!1,n[r]=o)}if(e){if(\"object\"==typeof r&&null!==r)o=r;else if(void 0!==r)throw new TypeError(\"'options' must be an object.\")}else o=t}}else if(void 0!==t)throw new TypeError(\"Unexpected argument[1]: must be 'fetches' or 'options'.\");for(const t of this.inputNames)if(void 0===e[t])throw new Error(`input '${t}' is missing in 'feeds'.`);if(i)for(const e of this.outputNames)n[e]=null;const a=await this.handler.run(e,n,o),s={};for(const e in a)Object.hasOwnProperty.call(a,e)&&(s[e]=new g(a[e].type,a[e].data,a[e].dims));return s}static async create(e,t,o,i){let a,s={};if(\"string\"==typeof e){if(a=e,\"object\"==typeof t&&null!==t)s=t;else if(void 0!==t)throw new TypeError(\"'options' must be an object.\")}else if(e instanceof Uint8Array){if(a=e,\"object\"==typeof t&&null!==t)s=t;else if(void 0!==t)throw new TypeError(\"'options' must be an object.\")}else{if(!(e instanceof ArrayBuffer||\"undefined\"!=typeof SharedArrayBuffer&&e instanceof SharedArrayBuffer))throw new TypeError(\"Unexpected argument[0]: must be 'path' or 'buffer'.\");{const r=e;let n=0,d=e.byteLength;if(\"object\"==typeof t&&null!==t)s=t;else if(\"number\"==typeof t){if(n=t,!Number.isSafeInteger(n))throw new RangeError(\"'byteOffset' must be an integer.\");if(n<0||n>=r.byteLength)throw new RangeError(`'byteOffset' is out of range [0, ${r.byteLength}).`);if(d=e.byteLength-n,\"number\"==typeof o){if(d=o,!Number.isSafeInteger(d))throw new RangeError(\"'byteLength' must be an integer.\");if(d<=0||n+d>r.byteLength)throw new RangeError(`'byteLength' is out of range (0, ${r.byteLength-n}].`);if(\"object\"==typeof i&&null!==i)s=i;else if(void 0!==i)throw new TypeError(\"'options' must be an object.\")}else if(void 0!==o)throw new TypeError(\"'byteLength' must be a number.\")}else if(void 0!==t)throw new TypeError(\"'options' must be an object.\");a=new Uint8Array(r,n,d)}}const d=(s.executionProviders||[]).map((e=>\"string\"==typeof e?e:e.name)),f=await(async e=>{const t=0===e.length?n:e,o=[];for(const e of t){const t=r[e];if(t){if(t.initialized)return t.backend;if(t.aborted)continue;const r=!!t.initPromise;try{return r||(t.initPromise=t.backend.init()),await t.initPromise,t.initialized=!0,t.backend}catch(n){r||o.push({name:e,err:n}),t.aborted=!0}finally{delete t.initPromise}}}throw new Error(`no available backend found. ERR: ${o.map((e=>`[${e.name}] ${e.err}`)).join(\", \")}`)})(d),h=await f.createSessionHandler(a,s);return new m(h)}startProfiling(){this.handler.startProfiling()}endProfiling(){this.handler.endProfiling()}get inputNames(){return this.handler.inputNames}get outputNames(){return this.handler.outputNames}}const c=m;var l=exports;for(var w in t)l[w]=t[w];t.__esModule&&Object.defineProperty(l,\"__esModule\",{value:!0})})();\n//# sourceMappingURL=ort-common.node.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb25ueHJ1bnRpbWUtY29tbW9uL2Rpc3Qvb3J0LWNvbW1vbi5ub2RlLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLGFBQWEsT0FBTyxVQUFVLCtEQUErRCx1QkFBdUIsRUFBRSwwREFBMEQsNEZBQTRGLGVBQWUsd0NBQXdDLFNBQVMsR0FBRyxNQUFNLGNBQWMsb0VBQW9FLEVBQUUsVUFBVSxrQkFBa0Isd0hBQXdILGFBQWEsb0JBQW9CLHNCQUFzQixLQUFLLHVCQUF1Qiw2RUFBNkUsRUFBRSxtQkFBbUIsRUFBRSxHQUFHLFNBQVMscUJBQXFCLHNCQUFzQixZQUFZLFdBQVcsdURBQXVELFlBQVksYUFBYSxjQUFjLFlBQVksY0FBYyxpQ0FBaUMsZ0JBQWdCLGVBQWUsa0lBQWtJLEVBQUUsR0FBRyx5QkFBeUIsZUFBZSw4QkFBOEIsMmlCQUEyaUIsa0lBQWtJLFFBQVEsbUJBQW1CLFVBQVUsK0NBQStDLDJGQUEyRixJQUFJLEtBQUssaUJBQWlCLDhEQUE4RCxFQUFFLElBQUksZ0NBQWdDLEtBQUssOENBQThDLEdBQUcsZ0NBQWdDLEVBQUUsR0FBRyxLQUFLLDhCQUE4QiwyRkFBMkYsb0JBQW9CLCtCQUErQixLQUFLLDRFQUE0RSxFQUFFLElBQUksK0JBQStCLEtBQUssNkJBQTZCLHVFQUF1RSxjQUFjLElBQUksUUFBUSwyQkFBMkIsd0ZBQXdGLGFBQWEsUUFBUSxZQUFZLFdBQVcsS0FBSyxhQUFhLDRFQUE0RSxFQUFFLDZCQUE2QixFQUFFLEdBQUcsb0NBQW9DLEVBQUUseUNBQXlDLEVBQUUsR0FBRyxLQUFLLFNBQVMsS0FBSyxpREFBaUQsRUFBRSwrQkFBK0IsU0FBUyxLQUFLLGdEQUFnRCwyQkFBMkIsOERBQThELGlHQUFpRyxNQUFNLGlCQUFpQixZQUFZLFFBQVEsZ0ZBQWdGLDZMQUE2TCwyQ0FBMkMsd0dBQXdHLFlBQVksSUFBSSxrSEFBa0gseURBQXlELDRCQUE0Qix3UUFBd1EsV0FBVyxNQUFNLDhEQUE4RCx5REFBeUQsdUNBQXVDLG1IQUFtSCw4R0FBOEcsNElBQTRJLDZIQUE2SCxVQUFVLGdEQUFnRCw0RUFBNEUsS0FBSyxPQUFPLE1BQU0seUZBQXlGLHdHQUF3RywwREFBMEQsWUFBWSwyQkFBMkIscUVBQXFFLGlIQUFpSCx3SEFBd0gsVUFBVSwwQkFBMEIsNkJBQTZCLDZDQUE2QyxpQ0FBaUMsOERBQThELHFCQUFxQixrQkFBa0IsZ0RBQWdELHNFQUFzRSw2Q0FBNkMsZUFBZSx3SEFBd0gscUlBQXFJLGdCQUFnQix1Q0FBdUMsK0JBQStCLEdBQUcsbUZBQW1GLGVBQWUsUUFBUSx5SUFBeUksMkhBQTJILHNCQUFzQiwyQkFBMkIsb0NBQW9DLHlDQUF5QyxxQkFBcUIsMkJBQTJCLHdEQUF3RCxxREFBcUQsZUFBZSwyQ0FBMkMsa0ZBQWtGLGVBQWUsUUFBUSwwREFBMEQsTUFBTSx5REFBeUQsZ1JBQWdSLGVBQWUsNkdBQTZHLHlHQUF5RywySkFBMkosVUFBVSx1Q0FBdUMsK0dBQStHLFlBQVksTUFBTSwrSkFBK0osU0FBUyxXQUFXLHFDQUFxQyxVQUFVLFFBQVEsZUFBZSxlQUFlLGlCQUFpQixXQUFXLFNBQVMsdUxBQXVMLFNBQVMsdUJBQXVCLDJFQUEyRSxzRUFBc0UscUJBQXFCLDJFQUEyRSxLQUFLLGtCQUFrQiw0RkFBNEYsb0dBQW9HLEVBQUUsSUFBSSxVQUFVLG9DQUFvQyx1RUFBdUUsS0FBSyxTQUFTLHNDQUFzQyxzREFBc0QsYUFBYSwrQ0FBK0MsTUFBTSxvQ0FBb0MsdUVBQXVFLFVBQVUsa0dBQWtHLDBFQUEwRSxFQUFFLDJCQUEyQiwrQ0FBK0MsMkNBQTJDLDhGQUE4RixTQUFTLDZCQUE2QixXQUFXLHVCQUF1Qix3Q0FBd0MsdUVBQXVFLGlDQUFpQyx3Q0FBd0MsdUVBQXVFLEtBQUssa0xBQWtMLFVBQVUsdUJBQXVCLG9DQUFvQyw0QkFBNEIseUZBQXlGLGlGQUFpRixhQUFhLEtBQUssd0NBQXdDLHlGQUF5RixtRkFBbUYsZUFBZSxLQUFLLG9DQUFvQyx1RUFBdUUseUVBQXlFLHVFQUF1RSx5QkFBeUIsMkZBQTJGLDhCQUE4QixrQkFBa0IsYUFBYSxNQUFNLGtDQUFrQyxzQkFBc0Isd0JBQXdCLElBQUksMEZBQTBGLFNBQVMsV0FBVyxhQUFhLGVBQWUsUUFBUSx1QkFBdUIsb0RBQW9ELGNBQWMsT0FBTyxJQUFJLE1BQU0sZUFBZSxHQUFHLHlDQUF5QyxnQkFBZ0IsaUJBQWlCLDhCQUE4QixlQUFlLDRCQUE0QixpQkFBaUIsK0JBQStCLGtCQUFrQixpQ0FBaUMsVUFBVSxjQUFjLHlCQUF5QixvREFBb0QsU0FBUyxFQUFFO0FBQ2wvWCIsInNvdXJjZXMiOlsid2VicGFjazovL3RyYW5zZm9ybWVyc2pzLXBsYXlncm91bmQvLi9ub2RlX21vZHVsZXMvb25ueHJ1bnRpbWUtY29tbW9uL2Rpc3Qvb3J0LWNvbW1vbi5ub2RlLmpzPzQ4OGMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBPTk5YIFJ1bnRpbWUgQ29tbW9uIHYxLjE0LjBcbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG4oKCk9PntcInVzZSBzdHJpY3RcIjt2YXIgZT17ZDoodCxyKT0+e2Zvcih2YXIgbiBpbiByKWUubyhyLG4pJiYhZS5vKHQsbikmJk9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LG4se2VudW1lcmFibGU6ITAsZ2V0OnJbbl19KX0sbzooZSx0KT0+T2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsdCkscjplPT57XCJ1bmRlZmluZWRcIiE9dHlwZW9mIFN5bWJvbCYmU3ltYm9sLnRvU3RyaW5nVGFnJiZPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxTeW1ib2wudG9TdHJpbmdUYWcse3ZhbHVlOlwiTW9kdWxlXCJ9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KX19LHQ9e307ZS5yKHQpLGUuZCh0LHtJbmZlcmVuY2VTZXNzaW9uOigpPT5jLFRlbnNvcjooKT0+ZyxlbnY6KCk9PmkscmVnaXN0ZXJCYWNrZW5kOigpPT5vfSk7Y29uc3Qgcj17fSxuPVtdLG89KGUsdCxvKT0+e2lmKCF0fHxcImZ1bmN0aW9uXCIhPXR5cGVvZiB0LmluaXR8fFwiZnVuY3Rpb25cIiE9dHlwZW9mIHQuY3JlYXRlU2Vzc2lvbkhhbmRsZXIpdGhyb3cgbmV3IFR5cGVFcnJvcihcIm5vdCBhIHZhbGlkIGJhY2tlbmRcIik7e2NvbnN0IGk9cltlXTtpZih2b2lkIDA9PT1pKXJbZV09e2JhY2tlbmQ6dCxwcmlvcml0eTpvfTtlbHNle2lmKGkucHJpb3JpdHk+bylyZXR1cm47aWYoaS5wcmlvcml0eT09PW8mJmkuYmFja2VuZCE9PXQpdGhyb3cgbmV3IEVycm9yKGBjYW5ub3QgcmVnaXN0ZXIgYmFja2VuZCBcIiR7ZX1cIiB1c2luZyBwcmlvcml0eSAke299YCl9aWYobz49MCl7Y29uc3QgdD1uLmluZGV4T2YoZSk7LTEhPT10JiZuLnNwbGljZSh0LDEpO2ZvcihsZXQgdD0wO3Q8bi5sZW5ndGg7dCsrKWlmKHJbblt0XV0ucHJpb3JpdHk8PW8pcmV0dXJuIHZvaWQgbi5zcGxpY2UodCwwLGUpO24ucHVzaChlKX19fSxpPW5ldyBjbGFzc3tjb25zdHJ1Y3Rvcigpe3RoaXMud2FzbT17fSx0aGlzLndlYmdsPXt9LHRoaXMubG9nTGV2ZWxJbnRlcm5hbD1cIndhcm5pbmdcIn1zZXQgbG9nTGV2ZWwoZSl7aWYodm9pZCAwIT09ZSl7aWYoXCJzdHJpbmdcIiE9dHlwZW9mIGV8fC0xPT09W1widmVyYm9zZVwiLFwiaW5mb1wiLFwid2FybmluZ1wiLFwiZXJyb3JcIixcImZhdGFsXCJdLmluZGV4T2YoZSkpdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBsb2dnaW5nIGxldmVsOiAke2V9YCk7dGhpcy5sb2dMZXZlbEludGVybmFsPWV9fWdldCBsb2dMZXZlbCgpe3JldHVybiB0aGlzLmxvZ0xldmVsSW50ZXJuYWx9fSxhPVwidW5kZWZpbmVkXCIhPXR5cGVvZiBCaWdJbnQ2NEFycmF5JiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBCaWdJbnQ2NEFycmF5LmZyb20scz1cInVuZGVmaW5lZFwiIT10eXBlb2YgQmlnVWludDY0QXJyYXkmJlwiZnVuY3Rpb25cIj09dHlwZW9mIEJpZ1VpbnQ2NEFycmF5LmZyb20sZD1uZXcgTWFwKFtbXCJmbG9hdDMyXCIsRmxvYXQzMkFycmF5XSxbXCJ1aW50OFwiLFVpbnQ4QXJyYXldLFtcImludDhcIixJbnQ4QXJyYXldLFtcInVpbnQxNlwiLFVpbnQxNkFycmF5XSxbXCJpbnQxNlwiLEludDE2QXJyYXldLFtcImludDMyXCIsSW50MzJBcnJheV0sW1wiYm9vbFwiLFVpbnQ4QXJyYXldLFtcImZsb2F0NjRcIixGbG9hdDY0QXJyYXldLFtcInVpbnQzMlwiLFVpbnQzMkFycmF5XV0pLGY9bmV3IE1hcChbW0Zsb2F0MzJBcnJheSxcImZsb2F0MzJcIl0sW1VpbnQ4QXJyYXksXCJ1aW50OFwiXSxbSW50OEFycmF5LFwiaW50OFwiXSxbVWludDE2QXJyYXksXCJ1aW50MTZcIl0sW0ludDE2QXJyYXksXCJpbnQxNlwiXSxbSW50MzJBcnJheSxcImludDMyXCJdLFtGbG9hdDY0QXJyYXksXCJmbG9hdDY0XCJdLFtVaW50MzJBcnJheSxcInVpbnQzMlwiXV0pO2EmJihkLnNldChcImludDY0XCIsQmlnSW50NjRBcnJheSksZi5zZXQoQmlnSW50NjRBcnJheSxcImludDY0XCIpKSxzJiYoZC5zZXQoXCJ1aW50NjRcIixCaWdVaW50NjRBcnJheSksZi5zZXQoQmlnVWludDY0QXJyYXksXCJ1aW50NjRcIikpO2NsYXNzIGh7Y29uc3RydWN0b3IoZSx0LHIpe2xldCBuLG8saTtpZihcInN0cmluZ1wiPT10eXBlb2YgZSlpZihuPWUsaT1yLFwic3RyaW5nXCI9PT1lKXtpZighQXJyYXkuaXNBcnJheSh0KSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQSBzdHJpbmcgdGVuc29yJ3MgZGF0YSBtdXN0IGJlIGEgc3RyaW5nIGFycmF5LlwiKTtvPXR9ZWxzZXtjb25zdCByPWQuZ2V0KGUpO2lmKHZvaWQgMD09PXIpdGhyb3cgbmV3IFR5cGVFcnJvcihgVW5zdXBwb3J0ZWQgdGVuc29yIHR5cGU6ICR7ZX0uYCk7aWYoQXJyYXkuaXNBcnJheSh0KSlvPXIuZnJvbSh0KTtlbHNle2lmKCEodCBpbnN0YW5jZW9mIHIpKXRocm93IG5ldyBUeXBlRXJyb3IoYEEgJHtufSB0ZW5zb3IncyBkYXRhIG11c3QgYmUgdHlwZSBvZiAke3J9YCk7bz10fX1lbHNlIGlmKGk9dCxBcnJheS5pc0FycmF5KGUpKXtpZigwPT09ZS5sZW5ndGgpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlRlbnNvciB0eXBlIGNhbm5vdCBiZSBpbmZlcnJlZCBmcm9tIGFuIGVtcHR5IGFycmF5LlwiKTtjb25zdCB0PXR5cGVvZiBlWzBdO2lmKFwic3RyaW5nXCI9PT10KW49XCJzdHJpbmdcIixvPWU7ZWxzZXtpZihcImJvb2xlYW5cIiE9PXQpdGhyb3cgbmV3IFR5cGVFcnJvcihgSW52YWxpZCBlbGVtZW50IHR5cGUgb2YgZGF0YSBhcnJheTogJHt0fS5gKTtuPVwiYm9vbFwiLG89VWludDhBcnJheS5mcm9tKGUpfX1lbHNle2NvbnN0IHQ9Zi5nZXQoZS5jb25zdHJ1Y3Rvcik7aWYodm9pZCAwPT09dCl0aHJvdyBuZXcgVHlwZUVycm9yKGBVbnN1cHBvcnRlZCB0eXBlIGZvciB0ZW5zb3IgZGF0YTogJHtlLmNvbnN0cnVjdG9yfS5gKTtuPXQsbz1lfWlmKHZvaWQgMD09PWkpaT1bby5sZW5ndGhdO2Vsc2UgaWYoIUFycmF5LmlzQXJyYXkoaSkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkEgdGVuc29yJ3MgZGltcyBtdXN0IGJlIGEgbnVtYmVyIGFycmF5XCIpO2NvbnN0IGE9KGU9PntsZXQgdD0xO2ZvcihsZXQgcj0wO3I8ZS5sZW5ndGg7cisrKXtjb25zdCBuPWVbcl07aWYoXCJudW1iZXJcIiE9dHlwZW9mIG58fCFOdW1iZXIuaXNTYWZlSW50ZWdlcihuKSl0aHJvdyBuZXcgVHlwZUVycm9yKGBkaW1zWyR7cn1dIG11c3QgYmUgYW4gaW50ZWdlciwgZ290OiAke259YCk7aWYobjwwKXRocm93IG5ldyBSYW5nZUVycm9yKGBkaW1zWyR7cn1dIG11c3QgYmUgYSBub24tbmVnYXRpdmUgaW50ZWdlciwgZ290OiAke259YCk7dCo9bn1yZXR1cm4gdH0pKGkpO2lmKGEhPT1vLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoYFRlbnNvcidzIHNpemUoJHthfSkgZG9lcyBub3QgbWF0Y2ggZGF0YSBsZW5ndGgoJHtvLmxlbmd0aH0pLmApO3RoaXMuZGltcz1pLHRoaXMudHlwZT1uLHRoaXMuZGF0YT1vLHRoaXMuc2l6ZT1hfXN0YXRpYyBidWZmZXJUb1RlbnNvcihlLHQpe2lmKHZvaWQgMD09PWUpdGhyb3cgbmV3IEVycm9yKFwiSW1hZ2UgYnVmZmVyIG11c3QgYmUgZGVmaW5lZFwiKTtpZih2b2lkIDA9PT10LmhlaWdodHx8dm9pZCAwPT09dC53aWR0aCl0aHJvdyBuZXcgRXJyb3IoXCJJbWFnZSBoZWlnaHQgYW5kIHdpZHRoIG11c3QgYmUgZGVmaW5lZFwiKTtjb25zdHtoZWlnaHQ6cix3aWR0aDpufT10LG89dC5ub3JtO2xldCBpLGE7aT12b2lkIDA9PT1vfHx2b2lkIDA9PT1vLm1lYW4/MjU1Om8ubWVhbixhPXZvaWQgMD09PW98fHZvaWQgMD09PW8uYmlhcz8wOm8uYmlhcztjb25zdCBzPXZvaWQgMCE9PXQuYml0bWFwRm9ybWF0P3QuYml0bWFwRm9ybWF0OlwiUkdCQVwiLGQ9dm9pZCAwIT09dC50ZW5zb3JGb3JtYXQmJnZvaWQgMCE9PXQudGVuc29yRm9ybWF0P3QudGVuc29yRm9ybWF0OlwiUkdCXCIsZj1yKm4sZz1cIlJHQkFcIj09PWQ/bmV3IEZsb2F0MzJBcnJheSg0KmYpOm5ldyBGbG9hdDMyQXJyYXkoMypmKTtsZXQgbT00LGM9MCxsPTEsdz0yLHU9MyxwPTAseT1mLGI9MipmLHY9LTE7XCJSR0JcIj09PXMmJihtPTMsYz0wLGw9MSx3PTIsdT0tMSksXCJSR0JBXCI9PT1kP3Y9MypmOlwiUkJHXCI9PT1kPyhwPTAsYj1mLHk9MipmKTpcIkJHUlwiPT09ZCYmKGI9MCx5PWYscD0yKmYpO2ZvcihsZXQgdD0wO3Q8Zjt0KyssYys9bSx3Kz1tLGwrPW0sdSs9bSlnW3ArK109KGVbY10rYSkvaSxnW3krK109KGVbbF0rYSkvaSxnW2IrK109KGVbd10rYSkvaSwtMSE9PXYmJi0xIT09dSYmKGdbdisrXT0oZVt1XSthKS9pKTtyZXR1cm4gbmV3IGgoXCJmbG9hdDMyXCIsZyxcIlJHQkFcIj09PWQ/WzEsNCxyLG5dOlsxLDMscixuXSl9c3RhdGljIGFzeW5jIGZyb21JbWFnZShlLHQpe2NvbnN0IHI9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIEhUTUxJbWFnZUVsZW1lbnQmJmUgaW5zdGFuY2VvZiBIVE1MSW1hZ2VFbGVtZW50LG49XCJ1bmRlZmluZWRcIiE9dHlwZW9mIEltYWdlRGF0YSYmZSBpbnN0YW5jZW9mIEltYWdlRGF0YSxvPVwidW5kZWZpbmVkXCIhPXR5cGVvZiBJbWFnZUJpdG1hcCYmZSBpbnN0YW5jZW9mIEltYWdlQml0bWFwLGk9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIFN0cmluZyYmKGUgaW5zdGFuY2VvZiBTdHJpbmd8fFwic3RyaW5nXCI9PXR5cGVvZiBlKTtsZXQgYSxzPXt9O2lmKHIpe2NvbnN0IHI9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKSxuPXIuZ2V0Q29udGV4dChcIjJkXCIpO2lmKG51bGw9PW4pdGhyb3cgbmV3IEVycm9yKFwiQ2FuIG5vdCBhY2Nlc3MgaW1hZ2UgZGF0YVwiKTt7bGV0IG89ZS5uYXR1cmFsSGVpZ2h0LGk9ZS5uYXR1cmFsV2lkdGg7aWYodm9pZCAwIT09dCYmdm9pZCAwIT09dC5yZXNpemVkSGVpZ2h0JiZ2b2lkIDAhPT10LnJlc2l6ZWRXaWR0aCYmKG89dC5yZXNpemVkSGVpZ2h0LGk9dC5yZXNpemVkV2lkdGgpLHZvaWQgMCE9PXQpe2lmKHM9dCx2b2lkIDAhPT10LnRlbnNvckZvcm1hdCl0aHJvdyBuZXcgRXJyb3IoXCJJbWFnZSBpbnB1dCBjb25maWcgZm9ybWF0IG11c3QgYmUgUkdCQSBmb3IgSFRNTEltYWdlRWxlbWVudFwiKTtpZihzLnRlbnNvckZvcm1hdD1cIlJHQkFcIix2b2lkIDAhPT10LmhlaWdodCYmdC5oZWlnaHQhPT1vKXRocm93IG5ldyBFcnJvcihcIkltYWdlIGlucHV0IGNvbmZpZyBoZWlnaHQgZG9lc24ndCBtYXRjaCBIVE1MSW1hZ2VFbGVtZW50IGhlaWdodFwiKTtpZihzLmhlaWdodD1vLHZvaWQgMCE9PXQud2lkdGgmJnQud2lkdGghPT1pKXRocm93IG5ldyBFcnJvcihcIkltYWdlIGlucHV0IGNvbmZpZyB3aWR0aCBkb2Vzbid0IG1hdGNoIEhUTUxJbWFnZUVsZW1lbnQgd2lkdGhcIik7cy53aWR0aD1pfWVsc2Ugcy50ZW5zb3JGb3JtYXQ9XCJSR0JBXCIscy5oZWlnaHQ9byxzLndpZHRoPWk7ci53aWR0aD1pLHIuaGVpZ2h0PW8sbi5kcmF3SW1hZ2UoZSwwLDAsaSxvKSxhPW4uZ2V0SW1hZ2VEYXRhKDAsMCxpLG8pLmRhdGF9fWVsc2V7aWYoIW4pe2lmKG8pe2lmKHZvaWQgMD09PXQpdGhyb3cgbmV3IEVycm9yKFwiUGxlYXNlIHByb3ZpZGUgaW1hZ2UgY29uZmlnIHdpdGggZm9ybWF0IGZvciBJbWFnZWJpdG1hcFwiKTtpZih2b2lkIDAhPT10LmJpdG1hcEZvcm1hdCl0aHJvdyBuZXcgRXJyb3IoXCJJbWFnZSBpbnB1dCBjb25maWcgZm9ybWF0IG11c3QgYmUgZGVmaW5lZCBmb3IgSW1hZ2VCaXRtYXBcIik7Y29uc3Qgcj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpLmdldENvbnRleHQoXCIyZFwiKTtpZihudWxsIT1yKXtjb25zdCBuPWUuaGVpZ2h0LG89ZS53aWR0aDtpZihyLmRyYXdJbWFnZShlLDAsMCxvLG4pLGE9ci5nZXRJbWFnZURhdGEoMCwwLG8sbikuZGF0YSx2b2lkIDAhPT10KXtpZih2b2lkIDAhPT10LmhlaWdodCYmdC5oZWlnaHQhPT1uKXRocm93IG5ldyBFcnJvcihcIkltYWdlIGlucHV0IGNvbmZpZyBoZWlnaHQgZG9lc24ndCBtYXRjaCBJbWFnZUJpdG1hcCBoZWlnaHRcIik7aWYocy5oZWlnaHQ9bix2b2lkIDAhPT10LndpZHRoJiZ0LndpZHRoIT09byl0aHJvdyBuZXcgRXJyb3IoXCJJbWFnZSBpbnB1dCBjb25maWcgd2lkdGggZG9lc24ndCBtYXRjaCBJbWFnZUJpdG1hcCB3aWR0aFwiKTtzLndpZHRoPW99ZWxzZSBzLmhlaWdodD1uLHMud2lkdGg9bztyZXR1cm4gaC5idWZmZXJUb1RlbnNvcihhLHMpfXRocm93IG5ldyBFcnJvcihcIkNhbiBub3QgYWNjZXNzIGltYWdlIGRhdGFcIil9aWYoaSlyZXR1cm4gbmV3IFByb21pc2UoKChyLG4pPT57Y29uc3Qgbz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpLGk9by5nZXRDb250ZXh0KFwiMmRcIik7aWYoIWV8fCFpKXJldHVybiBuKCk7Y29uc3QgYT1uZXcgSW1hZ2U7YS5jcm9zc09yaWdpbj1cIkFub255bW91c1wiLGEuc3JjPWUsYS5vbmxvYWQ9KCk9PntvLndpZHRoPWEud2lkdGgsby5oZWlnaHQ9YS5oZWlnaHQsaS5kcmF3SW1hZ2UoYSwwLDAsby53aWR0aCxvLmhlaWdodCk7Y29uc3QgZT1pLmdldEltYWdlRGF0YSgwLDAsby53aWR0aCxvLmhlaWdodCk7aWYodm9pZCAwIT09dCl7aWYodm9pZCAwIT09dC5oZWlnaHQmJnQuaGVpZ2h0IT09by5oZWlnaHQpdGhyb3cgbmV3IEVycm9yKFwiSW1hZ2UgaW5wdXQgY29uZmlnIGhlaWdodCBkb2Vzbid0IG1hdGNoIEltYWdlQml0bWFwIGhlaWdodFwiKTtpZihzLmhlaWdodD1vLmhlaWdodCx2b2lkIDAhPT10LndpZHRoJiZ0LndpZHRoIT09by53aWR0aCl0aHJvdyBuZXcgRXJyb3IoXCJJbWFnZSBpbnB1dCBjb25maWcgd2lkdGggZG9lc24ndCBtYXRjaCBJbWFnZUJpdG1hcCB3aWR0aFwiKTtzLndpZHRoPW8ud2lkdGh9ZWxzZSBzLmhlaWdodD1vLmhlaWdodCxzLndpZHRoPW8ud2lkdGg7cihoLmJ1ZmZlclRvVGVuc29yKGUuZGF0YSxzKSl9fSkpO3Rocm93IG5ldyBFcnJvcihcIklucHV0IGRhdGEgcHJvdmlkZWQgaXMgbm90IHN1cHBvcnRlZCAtIGFib3J0ZWQgdGVuc29yIGNyZWF0aW9uXCIpfXtjb25zdCByPVwiUkdCQVwiO2xldCBuLG87aWYodm9pZCAwIT09dCYmdm9pZCAwIT09dC5yZXNpemVkV2lkdGgmJnZvaWQgMCE9PXQucmVzaXplZEhlaWdodD8obj10LnJlc2l6ZWRIZWlnaHQsbz10LnJlc2l6ZWRXaWR0aCk6KG49ZS5oZWlnaHQsbz1lLndpZHRoKSx2b2lkIDAhPT10KXtpZihzPXQsdm9pZCAwIT09dC5iaXRtYXBGb3JtYXQmJnQuYml0bWFwRm9ybWF0IT09cil0aHJvdyBuZXcgRXJyb3IoXCJJbWFnZSBpbnB1dCBjb25maWcgZm9ybWF0IG11c3QgYmUgUkdCQSBmb3IgSW1hZ2VEYXRhXCIpO3MuYml0bWFwRm9ybWF0PVwiUkdCQVwifWVsc2Ugcy5iaXRtYXBGb3JtYXQ9XCJSR0JBXCI7aWYocy5oZWlnaHQ9bixzLndpZHRoPW8sdm9pZCAwIT09dCl7Y29uc3QgdD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO3Qud2lkdGg9byx0LmhlaWdodD1uO2NvbnN0IHI9dC5nZXRDb250ZXh0KFwiMmRcIik7aWYobnVsbD09cil0aHJvdyBuZXcgRXJyb3IoXCJDYW4gbm90IGFjY2VzcyBpbWFnZSBkYXRhXCIpO3IucHV0SW1hZ2VEYXRhKGUsMCwwKSxhPXIuZ2V0SW1hZ2VEYXRhKDAsMCxvLG4pLmRhdGF9ZWxzZSBhPWUuZGF0YX19aWYodm9pZCAwIT09YSlyZXR1cm4gaC5idWZmZXJUb1RlbnNvcihhLHMpO3Rocm93IG5ldyBFcnJvcihcIklucHV0IGRhdGEgcHJvdmlkZWQgaXMgbm90IHN1cHBvcnRlZCAtIGFib3J0ZWQgdGVuc29yIGNyZWF0aW9uXCIpfXRvSW1hZ2VEYXRhKGUpe3ZhciB0LHI7Y29uc3Qgbj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpLmdldENvbnRleHQoXCIyZFwiKTtsZXQgbztpZihudWxsPT1uKXRocm93IG5ldyBFcnJvcihcIkNhbiBub3QgYWNjZXNzIGltYWdlIGRhdGFcIik7e2NvbnN0IGk9dGhpcy5kaW1zWzNdLGE9dGhpcy5kaW1zWzJdLHM9dGhpcy5kaW1zWzFdLGQ9dm9pZCAwIT09ZSYmdm9pZCAwIT09ZS5mb3JtYXQ/ZS5mb3JtYXQ6XCJSR0JcIixmPXZvaWQgMCE9PWUmJnZvaWQgMCE9PShudWxsPT09KHQ9ZS5ub3JtKXx8dm9pZCAwPT09dD92b2lkIDA6dC5tZWFuKT9lLm5vcm0ubWVhbjoyNTUsaD12b2lkIDAhPT1lJiZ2b2lkIDAhPT0obnVsbD09PShyPWUubm9ybSl8fHZvaWQgMD09PXI/dm9pZCAwOnIuYmlhcyk/ZS5ub3JtLmJpYXM6MCxnPWEqaTtpZih2b2lkIDAhPT1lKXtpZih2b2lkIDAhPT1lLmhlaWdodCYmZS5oZWlnaHQhPT1hKXRocm93IG5ldyBFcnJvcihcIkltYWdlIG91dHB1dCBjb25maWcgaGVpZ2h0IGRvZXNuJ3QgbWF0Y2ggdGVuc29yIGhlaWdodFwiKTtpZih2b2lkIDAhPT1lLndpZHRoJiZlLndpZHRoIT09aSl0aHJvdyBuZXcgRXJyb3IoXCJJbWFnZSBvdXRwdXQgY29uZmlnIHdpZHRoIGRvZXNuJ3QgbWF0Y2ggdGVuc29yIHdpZHRoXCIpO2lmKHZvaWQgMCE9PWUuZm9ybWF0JiY0PT09cyYmXCJSR0JBXCIhPT1lLmZvcm1hdHx8Mz09PXMmJlwiUkdCXCIhPT1lLmZvcm1hdCYmXCJCR1JcIiE9PWUuZm9ybWF0KXRocm93IG5ldyBFcnJvcihcIlRlbnNvciBmb3JtYXQgZG9lc24ndCBtYXRjaCBpbnB1dCB0ZW5zb3IgZGltc1wiKX1jb25zdCBtPTQ7bGV0IGM9MCxsPTEsdz0yLHU9MyxwPTAseT1nLGI9MipnLHY9LTE7XCJSR0JBXCI9PT1kPyhwPTAseT1nLGI9MipnLHY9MypnKTpcIlJHQlwiPT09ZD8ocD0wLHk9ZyxiPTIqZyk6XCJSQkdcIj09PWQmJihwPTAsYj1nLHk9MipnKSxvPW4uY3JlYXRlSW1hZ2VEYXRhKGksYSk7Zm9yKGxldCBlPTA7ZTxhKmk7Yys9bSxsKz1tLHcrPW0sdSs9bSxlKyspby5kYXRhW2NdPSh0aGlzLmRhdGFbcCsrXS1oKSpmLG8uZGF0YVtsXT0odGhpcy5kYXRhW3krK10taCkqZixvLmRhdGFbd109KHRoaXMuZGF0YVtiKytdLWgpKmYsby5kYXRhW3VdPS0xPT09dj8yNTU6KHRoaXMuZGF0YVt2KytdLWgpKmZ9cmV0dXJuIG99cmVzaGFwZShlKXtyZXR1cm4gbmV3IGgodGhpcy50eXBlLHRoaXMuZGF0YSxlKX19Y29uc3QgZz1oO2NsYXNzIG17Y29uc3RydWN0b3IoZSl7dGhpcy5oYW5kbGVyPWV9YXN5bmMgcnVuKGUsdCxyKXtjb25zdCBuPXt9O2xldCBvPXt9O2lmKFwib2JqZWN0XCIhPXR5cGVvZiBlfHxudWxsPT09ZXx8ZSBpbnN0YW5jZW9mIGd8fEFycmF5LmlzQXJyYXkoZSkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIidmZWVkcycgbXVzdCBiZSBhbiBvYmplY3QgdGhhdCB1c2UgaW5wdXQgbmFtZXMgYXMga2V5cyBhbmQgT25ueFZhbHVlIGFzIGNvcnJlc3BvbmRpbmcgdmFsdWVzLlwiKTtsZXQgaT0hMDtpZihcIm9iamVjdFwiPT10eXBlb2YgdCl7aWYobnVsbD09PXQpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlVuZXhwZWN0ZWQgYXJndW1lbnRbMV06IGNhbm5vdCBiZSBudWxsLlwiKTtpZih0IGluc3RhbmNlb2YgZyl0aHJvdyBuZXcgVHlwZUVycm9yKFwiJ2ZldGNoZXMnIGNhbm5vdCBiZSBhIFRlbnNvclwiKTtpZihBcnJheS5pc0FycmF5KHQpKXtpZigwPT09dC5sZW5ndGgpdGhyb3cgbmV3IFR5cGVFcnJvcihcIidmZXRjaGVzJyBjYW5ub3QgYmUgYW4gZW1wdHkgYXJyYXkuXCIpO2k9ITE7Zm9yKGNvbnN0IGUgb2YgdCl7aWYoXCJzdHJpbmdcIiE9dHlwZW9mIGUpdGhyb3cgbmV3IFR5cGVFcnJvcihcIidmZXRjaGVzJyBtdXN0IGJlIGEgc3RyaW5nIGFycmF5IG9yIGFuIG9iamVjdC5cIik7aWYoLTE9PT10aGlzLm91dHB1dE5hbWVzLmluZGV4T2YoZSkpdGhyb3cgbmV3IFJhbmdlRXJyb3IoYCdmZXRjaGVzJyBjb250YWlucyBpbnZhbGlkIG91dHB1dCBuYW1lOiAke2V9LmApO25bZV09bnVsbH1pZihcIm9iamVjdFwiPT10eXBlb2YgciYmbnVsbCE9PXIpbz1yO2Vsc2UgaWYodm9pZCAwIT09cil0aHJvdyBuZXcgVHlwZUVycm9yKFwiJ29wdGlvbnMnIG11c3QgYmUgYW4gb2JqZWN0LlwiKX1lbHNle2xldCBlPSExO2NvbnN0IGE9T2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModCk7Zm9yKGNvbnN0IHIgb2YgdGhpcy5vdXRwdXROYW1lcylpZigtMSE9PWEuaW5kZXhPZihyKSl7Y29uc3Qgbz10W3JdOyhudWxsPT09b3x8byBpbnN0YW5jZW9mIGcpJiYoZT0hMCxpPSExLG5bcl09byl9aWYoZSl7aWYoXCJvYmplY3RcIj09dHlwZW9mIHImJm51bGwhPT1yKW89cjtlbHNlIGlmKHZvaWQgMCE9PXIpdGhyb3cgbmV3IFR5cGVFcnJvcihcIidvcHRpb25zJyBtdXN0IGJlIGFuIG9iamVjdC5cIil9ZWxzZSBvPXR9fWVsc2UgaWYodm9pZCAwIT09dCl0aHJvdyBuZXcgVHlwZUVycm9yKFwiVW5leHBlY3RlZCBhcmd1bWVudFsxXTogbXVzdCBiZSAnZmV0Y2hlcycgb3IgJ29wdGlvbnMnLlwiKTtmb3IoY29uc3QgdCBvZiB0aGlzLmlucHV0TmFtZXMpaWYodm9pZCAwPT09ZVt0XSl0aHJvdyBuZXcgRXJyb3IoYGlucHV0ICcke3R9JyBpcyBtaXNzaW5nIGluICdmZWVkcycuYCk7aWYoaSlmb3IoY29uc3QgZSBvZiB0aGlzLm91dHB1dE5hbWVzKW5bZV09bnVsbDtjb25zdCBhPWF3YWl0IHRoaXMuaGFuZGxlci5ydW4oZSxuLG8pLHM9e307Zm9yKGNvbnN0IGUgaW4gYSlPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChhLGUpJiYoc1tlXT1uZXcgZyhhW2VdLnR5cGUsYVtlXS5kYXRhLGFbZV0uZGltcykpO3JldHVybiBzfXN0YXRpYyBhc3luYyBjcmVhdGUoZSx0LG8saSl7bGV0IGEscz17fTtpZihcInN0cmluZ1wiPT10eXBlb2YgZSl7aWYoYT1lLFwib2JqZWN0XCI9PXR5cGVvZiB0JiZudWxsIT09dClzPXQ7ZWxzZSBpZih2b2lkIDAhPT10KXRocm93IG5ldyBUeXBlRXJyb3IoXCInb3B0aW9ucycgbXVzdCBiZSBhbiBvYmplY3QuXCIpfWVsc2UgaWYoZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpe2lmKGE9ZSxcIm9iamVjdFwiPT10eXBlb2YgdCYmbnVsbCE9PXQpcz10O2Vsc2UgaWYodm9pZCAwIT09dCl0aHJvdyBuZXcgVHlwZUVycm9yKFwiJ29wdGlvbnMnIG11c3QgYmUgYW4gb2JqZWN0LlwiKX1lbHNle2lmKCEoZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyfHxcInVuZGVmaW5lZFwiIT10eXBlb2YgU2hhcmVkQXJyYXlCdWZmZXImJmUgaW5zdGFuY2VvZiBTaGFyZWRBcnJheUJ1ZmZlcikpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlVuZXhwZWN0ZWQgYXJndW1lbnRbMF06IG11c3QgYmUgJ3BhdGgnIG9yICdidWZmZXInLlwiKTt7Y29uc3Qgcj1lO2xldCBuPTAsZD1lLmJ5dGVMZW5ndGg7aWYoXCJvYmplY3RcIj09dHlwZW9mIHQmJm51bGwhPT10KXM9dDtlbHNlIGlmKFwibnVtYmVyXCI9PXR5cGVvZiB0KXtpZihuPXQsIU51bWJlci5pc1NhZmVJbnRlZ2VyKG4pKXRocm93IG5ldyBSYW5nZUVycm9yKFwiJ2J5dGVPZmZzZXQnIG11c3QgYmUgYW4gaW50ZWdlci5cIik7aWYobjwwfHxuPj1yLmJ5dGVMZW5ndGgpdGhyb3cgbmV3IFJhbmdlRXJyb3IoYCdieXRlT2Zmc2V0JyBpcyBvdXQgb2YgcmFuZ2UgWzAsICR7ci5ieXRlTGVuZ3RofSkuYCk7aWYoZD1lLmJ5dGVMZW5ndGgtbixcIm51bWJlclwiPT10eXBlb2Ygbyl7aWYoZD1vLCFOdW1iZXIuaXNTYWZlSW50ZWdlcihkKSl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIidieXRlTGVuZ3RoJyBtdXN0IGJlIGFuIGludGVnZXIuXCIpO2lmKGQ8PTB8fG4rZD5yLmJ5dGVMZW5ndGgpdGhyb3cgbmV3IFJhbmdlRXJyb3IoYCdieXRlTGVuZ3RoJyBpcyBvdXQgb2YgcmFuZ2UgKDAsICR7ci5ieXRlTGVuZ3RoLW59XS5gKTtpZihcIm9iamVjdFwiPT10eXBlb2YgaSYmbnVsbCE9PWkpcz1pO2Vsc2UgaWYodm9pZCAwIT09aSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiJ29wdGlvbnMnIG11c3QgYmUgYW4gb2JqZWN0LlwiKX1lbHNlIGlmKHZvaWQgMCE9PW8pdGhyb3cgbmV3IFR5cGVFcnJvcihcIidieXRlTGVuZ3RoJyBtdXN0IGJlIGEgbnVtYmVyLlwiKX1lbHNlIGlmKHZvaWQgMCE9PXQpdGhyb3cgbmV3IFR5cGVFcnJvcihcIidvcHRpb25zJyBtdXN0IGJlIGFuIG9iamVjdC5cIik7YT1uZXcgVWludDhBcnJheShyLG4sZCl9fWNvbnN0IGQ9KHMuZXhlY3V0aW9uUHJvdmlkZXJzfHxbXSkubWFwKChlPT5cInN0cmluZ1wiPT10eXBlb2YgZT9lOmUubmFtZSkpLGY9YXdhaXQoYXN5bmMgZT0+e2NvbnN0IHQ9MD09PWUubGVuZ3RoP246ZSxvPVtdO2Zvcihjb25zdCBlIG9mIHQpe2NvbnN0IHQ9cltlXTtpZih0KXtpZih0LmluaXRpYWxpemVkKXJldHVybiB0LmJhY2tlbmQ7aWYodC5hYm9ydGVkKWNvbnRpbnVlO2NvbnN0IHI9ISF0LmluaXRQcm9taXNlO3RyeXtyZXR1cm4gcnx8KHQuaW5pdFByb21pc2U9dC5iYWNrZW5kLmluaXQoKSksYXdhaXQgdC5pbml0UHJvbWlzZSx0LmluaXRpYWxpemVkPSEwLHQuYmFja2VuZH1jYXRjaChuKXtyfHxvLnB1c2goe25hbWU6ZSxlcnI6bn0pLHQuYWJvcnRlZD0hMH1maW5hbGx5e2RlbGV0ZSB0LmluaXRQcm9taXNlfX19dGhyb3cgbmV3IEVycm9yKGBubyBhdmFpbGFibGUgYmFja2VuZCBmb3VuZC4gRVJSOiAke28ubWFwKChlPT5gWyR7ZS5uYW1lfV0gJHtlLmVycn1gKSkuam9pbihcIiwgXCIpfWApfSkoZCksaD1hd2FpdCBmLmNyZWF0ZVNlc3Npb25IYW5kbGVyKGEscyk7cmV0dXJuIG5ldyBtKGgpfXN0YXJ0UHJvZmlsaW5nKCl7dGhpcy5oYW5kbGVyLnN0YXJ0UHJvZmlsaW5nKCl9ZW5kUHJvZmlsaW5nKCl7dGhpcy5oYW5kbGVyLmVuZFByb2ZpbGluZygpfWdldCBpbnB1dE5hbWVzKCl7cmV0dXJuIHRoaXMuaGFuZGxlci5pbnB1dE5hbWVzfWdldCBvdXRwdXROYW1lcygpe3JldHVybiB0aGlzLmhhbmRsZXIub3V0cHV0TmFtZXN9fWNvbnN0IGM9bTt2YXIgbD1leHBvcnRzO2Zvcih2YXIgdyBpbiB0KWxbd109dFt3XTt0Ll9fZXNNb2R1bGUmJk9iamVjdC5kZWZpbmVQcm9wZXJ0eShsLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pfSkoKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9ydC1jb21tb24ubm9kZS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/onnxruntime-common/dist/ort-common.node.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/onnxruntime-web/dist/ort-web.node.js":
/*!***********************************************************!*\
  !*** ./node_modules/onnxruntime-web/dist/ort-web.node.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/*!\n* ONNX Runtime Web v1.14.0\n* Copyright (c) Microsoft Corporation. All rights reserved.\n* Licensed under the MIT License.\n*/\n(()=>{var __webpack_modules__={3474:(t,e,n)=>{var _scriptDir,r=(_scriptDir=(_scriptDir=\"undefined\"!=typeof document&&document.currentScript?document.currentScript.src:void 0)||__filename,function(t){function e(){return $.buffer!=C&&H($.buffer),F}function r(){return $.buffer!=C&&H($.buffer),N}function i(){return $.buffer!=C&&H($.buffer),R}function o(){return $.buffer!=C&&H($.buffer),L}function a(){return $.buffer!=C&&H($.buffer),M}var s,u,c;t=t||{},s||(s=void 0!==t?t:{}),s.ready=new Promise((function(t,e){u=t,c=e}));var l,p,f,d,h,g,b=Object.assign({},s),m=\"./this.program\",y=(t,e)=>{throw e},_=\"object\"==typeof window,v=\"function\"==typeof importScripts,w=\"object\"==typeof process&&\"object\"==typeof process.versions&&\"string\"==typeof process.versions.node,x=s.ENVIRONMENT_IS_PTHREAD||!1,T=\"\";function S(t){return s.locateFile?s.locateFile(t,T):T+t}if(w){let e;T=v?n(1423).dirname(T)+\"/\":__dirname+\"/\",g=()=>{h||(d=n(6231),h=n(1423))},l=function(t,e){return g(),t=h.normalize(t),d.readFileSync(t,e?void 0:\"utf8\")},f=t=>((t=l(t,!0)).buffer||(t=new Uint8Array(t)),t),p=(t,e,n)=>{g(),t=h.normalize(t),d.readFile(t,(function(t,r){t?n(t):e(r.buffer)}))},1<process.argv.length&&(m=process.argv[1].replace(/\\\\/g,\"/\")),process.argv.slice(2),process.on(\"uncaughtException\",(function(t){if(!(t instanceof ut))throw t})),process.on(\"unhandledRejection\",(function(t){throw t})),y=(t,e)=>{if(J())throw process.exitCode=t,e;e instanceof ut||P(\"exiting due to exception: \"+e),process.exit(t)},s.inspect=function(){return\"[Emscripten Module object]\"};try{e=n(4564)}catch(t){throw console.error('The \"worker_threads\" module is not supported in this node.js build - perhaps a newer version is needed?'),t}global.Worker=e.Worker}else(_||v)&&(v?T=self.location.href:\"undefined\"!=typeof document&&document.currentScript&&(T=document.currentScript.src),_scriptDir&&(T=_scriptDir),T=0!==T.indexOf(\"blob:\")?T.substr(0,T.replace(/[?#].*/,\"\").lastIndexOf(\"/\")+1):\"\",w||(l=t=>{var e=new XMLHttpRequest;return e.open(\"GET\",t,!1),e.send(null),e.responseText},v&&(f=t=>{var e=new XMLHttpRequest;return e.open(\"GET\",t,!1),e.responseType=\"arraybuffer\",e.send(null),new Uint8Array(e.response)}),p=(t,e,n)=>{var r=new XMLHttpRequest;r.open(\"GET\",t,!0),r.responseType=\"arraybuffer\",r.onload=()=>{200==r.status||0==r.status&&r.response?e(r.response):n()},r.onerror=n,r.send(null)}));w&&\"undefined\"==typeof performance&&(global.performance=n(498).performance);var O=console.log.bind(console),A=console.warn.bind(console);w&&(g(),O=t=>d.writeSync(1,t+\"\\n\"),A=t=>d.writeSync(2,t+\"\\n\"));var E,I=s.print||O,P=s.printErr||A;Object.assign(s,b),b=null,s.thisProgram&&(m=s.thisProgram),s.quit&&(y=s.quit),s.wasmBinary&&(E=s.wasmBinary);var D=s.noExitRuntime||!1;\"object\"!=typeof WebAssembly&&it(\"no native wasm support detected\");var $,k,C,F,N,R,L,M,j=!1,U=\"undefined\"!=typeof TextDecoder?new TextDecoder(\"utf8\"):void 0;function V(t,e,n){var r=(e>>>=0)+n;for(n=e;t[n]&&!(n>=r);)++n;if(16<n-e&&t.buffer&&U)return U.decode(t.buffer instanceof SharedArrayBuffer?t.slice(e,n):t.subarray(e,n));for(r=\"\";e<n;){var i=t[e++];if(128&i){var o=63&t[e++];if(192==(224&i))r+=String.fromCharCode((31&i)<<6|o);else{var a=63&t[e++];65536>(i=224==(240&i)?(15&i)<<12|o<<6|a:(7&i)<<18|o<<12|a<<6|63&t[e++])?r+=String.fromCharCode(i):(i-=65536,r+=String.fromCharCode(55296|i>>10,56320|1023&i))}}else r+=String.fromCharCode(i)}return r}function B(t,e){return(t>>>=0)?V(r(),t,e):\"\"}function z(t,e,n,r){if(!(0<r))return 0;var i=n>>>=0;r=n+r-1;for(var o=0;o<t.length;++o){var a=t.charCodeAt(o);if(55296<=a&&57343>=a&&(a=65536+((1023&a)<<10)|1023&t.charCodeAt(++o)),127>=a){if(n>=r)break;e[n++>>>0]=a}else{if(2047>=a){if(n+1>=r)break;e[n++>>>0]=192|a>>6}else{if(65535>=a){if(n+2>=r)break;e[n++>>>0]=224|a>>12}else{if(n+3>=r)break;e[n++>>>0]=240|a>>18,e[n++>>>0]=128|a>>12&63}e[n++>>>0]=128|a>>6&63}e[n++>>>0]=128|63&a}}return e[n>>>0]=0,n-i}function G(t){for(var e=0,n=0;n<t.length;++n){var r=t.charCodeAt(n);127>=r?e++:2047>=r?e+=2:55296<=r&&57343>=r?(e+=4,++n):e+=3}return e}function H(t){C=t,s.HEAP8=F=new Int8Array(t),s.HEAP16=new Int16Array(t),s.HEAP32=R=new Int32Array(t),s.HEAPU8=N=new Uint8Array(t),s.HEAPU16=new Uint16Array(t),s.HEAPU32=L=new Uint32Array(t),s.HEAPF32=new Float32Array(t),s.HEAPF64=M=new Float64Array(t)}x&&(C=s.buffer);var q=s.INITIAL_MEMORY||16777216;if(x)$=s.wasmMemory,C=s.buffer;else if(s.wasmMemory)$=s.wasmMemory;else if(!(($=new WebAssembly.Memory({initial:q/65536,maximum:65536,shared:!0})).buffer instanceof SharedArrayBuffer))throw P(\"requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag\"),w&&console.log(\"(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and also use a recent version)\"),Error(\"bad memory\");$&&(C=$.buffer),q=C.byteLength,H(C);var W,X=[],Y=[],K=[],Z=[];function J(){return D||!1}function Q(){var t=s.preRun.shift();X.unshift(t)}var tt,et=0,nt=null,rt=null;function it(t){throw x?postMessage({cmd:\"onAbort\",arg:t}):s.onAbort&&s.onAbort(t),P(t=\"Aborted(\"+t+\")\"),j=!0,t=new WebAssembly.RuntimeError(t+\". Build with -sASSERTIONS for more info.\"),c(t),t}function ot(){return tt.startsWith(\"data:application/octet-stream;base64,\")}function at(){var t=tt;try{if(t==tt&&E)return new Uint8Array(E);if(f)return f(t);throw\"both async and sync fetching of the wasm failed\"}catch(t){it(t)}}tt=\"ort-wasm-threaded.wasm\",ot()||(tt=S(tt));var st={};function ut(t){this.name=\"ExitStatus\",this.message=\"Program terminated with exit(\"+t+\")\",this.status=t}function ct(t){(t=dt.Vb[t])||it(),dt.mc(t)}function lt(t){var e=dt.Cc();if(!e)return 6;dt.ac.push(e),dt.Vb[t.Ub]=e,e.Ub=t.Ub;var n={cmd:\"run\",start_routine:t.Ic,arg:t.zc,pthread_ptr:t.Ub};return e.$b=()=>{n.time=performance.now(),e.postMessage(n,t.Nc)},e.loaded&&(e.$b(),delete e.$b),0}function pt(t){if(x)return Wt(1,1,t);J()||(dt.oc(),s.onExit&&s.onExit(t),j=!0),y(t,new ut(t))}function ft(t,e){if(!e&&x)throw bt(t),\"unwind\";J()||x||(me(),ht(K),be(0),re[1].length&&ie(1,10),re[2].length&&ie(2,10),dt.oc()),pt(t)}var dt={Yb:[],ac:[],qc:[],Vb:{},fc:function(){x&&dt.Ec()},Pc:function(){},Ec:function(){dt.receiveObjectTransfer=dt.Gc,dt.threadInitTLS=dt.pc,dt.setExitStatus=dt.nc,D=!1},nc:function(){},oc:function(){for(var t of Object.values(dt.Vb))dt.mc(t);for(t of dt.Yb)t.terminate();dt.Yb=[]},mc:function(t){var e=t.Ub;delete dt.Vb[e],dt.Yb.push(t),dt.ac.splice(dt.ac.indexOf(t),1),t.Ub=0,xe(e)},Gc:function(){},pc:function(){dt.qc.forEach((t=>t()))},Fc:function(t,e){t.onmessage=n=>{var r=(n=n.data).cmd;if(t.Ub&&(dt.Bc=t.Ub),n.targetThread&&n.targetThread!=de()){var i=dt.Vb[n.Qc];i?i.postMessage(n,n.transferList):P('Internal error! Worker sent a message \"'+r+'\" to target pthread '+n.targetThread+\", but that thread no longer exists!\")}else\"processProxyingQueue\"===r?Vt(n.queue):\"spawnThread\"===r?lt(n):\"cleanupThread\"===r?ct(n.thread):\"killThread\"===r?(n=n.thread,r=dt.Vb[n],delete dt.Vb[n],r.terminate(),xe(n),dt.ac.splice(dt.ac.indexOf(r),1),r.Ub=0):\"cancelThread\"===r?dt.Vb[n.thread].postMessage({cmd:\"cancel\"}):\"loaded\"===r?(t.loaded=!0,e&&e(t),t.$b&&(t.$b(),delete t.$b)):\"print\"===r?I(\"Thread \"+n.threadId+\": \"+n.text):\"printErr\"===r?P(\"Thread \"+n.threadId+\": \"+n.text):\"alert\"===r?alert(\"Thread \"+n.threadId+\": \"+n.text):\"setimmediate\"===n.target?t.postMessage(n):\"onAbort\"===r?s.onAbort&&s.onAbort(n.arg):r&&P(\"worker sent an unknown command \"+r);dt.Bc=void 0},t.onerror=t=>{throw P(\"worker sent an error! \"+t.filename+\":\"+t.lineno+\": \"+t.message),t},w&&(t.on(\"message\",(function(e){t.onmessage({data:e})})),t.on(\"error\",(function(e){t.onerror(e)})),t.on(\"detachedExit\",(function(){}))),t.postMessage({cmd:\"load\",urlOrBlob:s.mainScriptUrlOrBlob||_scriptDir,wasmMemory:$,wasmModule:k})},yc:function(){var t=S(\"ort-wasm-threaded.worker.js\");dt.Yb.push(new Worker(t))},Cc:function(){return 0==dt.Yb.length&&(dt.yc(),dt.Fc(dt.Yb[0])),dt.Yb.pop()}};function ht(t){for(;0<t.length;)t.shift()(s)}function gt(t){var e=Ae();return t=t(),Ee(e),t}function bt(t){if(x)return Wt(2,0,t);try{ft(t)}catch(t){t instanceof ut||\"unwind\"==t||y(1,t)}}s.PThread=dt,s.establishStackSpace=function(){var t=de(),e=i()[t+44>>2>>>0];t=i()[t+48>>2>>>0],Oe(e,e-t),Ee(e)};var mt=[];function yt(t){var e=mt[t];return e||(t>=mt.length&&(mt.length=t+1),mt[t]=e=W.get(t)),e}s.invokeEntryPoint=function(t,e){t=yt(t)(e),J()?dt.nc(t):Te(t)};var _t,vt,wt=[],xt=0,Tt=0;function St(t){this.Zb=t,this.Sb=t-24,this.xc=function(t){o()[this.Sb+4>>2>>>0]=t},this.bc=function(){return o()[this.Sb+4>>2>>>0]},this.wc=function(t){o()[this.Sb+8>>2>>>0]=t},this.Dc=function(){return o()[this.Sb+8>>2>>>0]},this.rc=function(){i()[this.Sb>>2>>>0]=0},this.hc=function(t){t=t?1:0,e()[this.Sb+12>>0>>>0]=t},this.uc=function(){return 0!=e()[this.Sb+12>>0>>>0]},this.ic=function(t){t=t?1:0,e()[this.Sb+13>>0>>>0]=t},this.kc=function(){return 0!=e()[this.Sb+13>>0>>>0]},this.fc=function(t,e){this.cc(0),this.xc(t),this.wc(e),this.rc(),this.hc(!1),this.ic(!1)},this.sc=function(){Atomics.add(i(),this.Sb>>2,1)},this.Hc=function(){return 1===Atomics.sub(i(),this.Sb>>2,1)},this.cc=function(t){o()[this.Sb+16>>2>>>0]=t},this.tc=function(){return o()[this.Sb+16>>2>>>0]},this.vc=function(){if(De(this.bc()))return o()[this.Zb>>2>>>0];var t=this.tc();return 0!==t?t:this.Zb}}function Ot(t){return ge(new St(t).Sb)}function At(t,e,n,r){return x?Wt(3,1,t,e,n,r):Et(t,e,n,r)}function Et(t,e,n,r){if(\"undefined\"==typeof SharedArrayBuffer)return P(\"Current environment does not support SharedArrayBuffer, pthreads are not available!\"),6;var i=[];return x&&0===i.length?At(t,e,n,r):(t={Ic:n,Ub:t,zc:r,Nc:i},x?(t.Oc=\"spawnThread\",postMessage(t,i),0):lt(t))}function It(t,e,n){return x?Wt(4,1,t,e,n):0}function Pt(t,e){if(x)return Wt(5,1,t,e)}function Dt(t,e){if(x)return Wt(6,1,t,e)}function $t(t,e,n){if(x)return Wt(7,1,t,e,n)}function kt(t,e,n){return x?Wt(8,1,t,e,n):0}function Ct(t,e){if(x)return Wt(9,1,t,e)}function Ft(t,e,n){if(x)return Wt(10,1,t,e,n)}function Nt(t,e,n,r){if(x)return Wt(11,1,t,e,n,r)}function Rt(t,e,n,r){if(x)return Wt(12,1,t,e,n,r)}function Lt(t,e,n,r){if(x)return Wt(13,1,t,e,n,r)}function Mt(t){if(x)return Wt(14,1,t)}function jt(t,e){if(x)return Wt(15,1,t,e)}function Ut(t,e,n){if(x)return Wt(16,1,t,e,n)}function Vt(t){Atomics.store(i(),t>>2,1),de()&&we(t),Atomics.compareExchange(i(),t>>2,1,0)}function Bt(t){return o()[t>>>2]+4294967296*i()[t+4>>>2]}function zt(t,e,n,r,i,o){return x?Wt(17,1,t,e,n,r,i,o):-52}function Gt(t,e,n,r,i,o){if(x)return Wt(18,1,t,e,n,r,i,o)}function Ht(t){var n=G(t)+1,r=he(n);return r&&z(t,e(),r,n),r}function qt(t,e,n){function r(t){return(t=t.toTimeString().match(/\\(([A-Za-z ]+)\\)$/))?t[1]:\"GMT\"}if(x)return Wt(19,1,t,e,n);var a=(new Date).getFullYear(),s=new Date(a,0,1),u=new Date(a,6,1);a=s.getTimezoneOffset();var c=u.getTimezoneOffset(),l=Math.max(a,c);i()[t>>2>>>0]=60*l,i()[e>>2>>>0]=Number(a!=c),t=r(s),e=r(u),t=Ht(t),e=Ht(e),c<a?(o()[n>>2>>>0]=t,o()[n+4>>2>>>0]=e):(o()[n>>2>>>0]=e,o()[n+4>>2>>>0]=t)}function Wt(t,e){var n=arguments.length-2,r=arguments;return gt((()=>{for(var i=Ie(8*n),o=i>>3,s=0;s<n;s++){var u=r[2+s];a()[o+s>>>0]=u}return ve(t,n,i,e)}))}s.executeNotifiedProxyingQueue=Vt,vt=w?()=>{var t=process.hrtime();return 1e3*t[0]+t[1]/1e6}:x?()=>performance.now()-s.__performance_now_clock_drift:()=>performance.now();var Xt,Yt=[],Kt={};function Zt(){if(!Xt){var t,e={USER:\"web_user\",LOGNAME:\"web_user\",PATH:\"/\",PWD:\"/\",HOME:\"/home/web_user\",LANG:(\"object\"==typeof navigator&&navigator.languages&&navigator.languages[0]||\"C\").replace(\"-\",\"_\")+\".UTF-8\",_:m||\"./this.program\"};for(t in Kt)void 0===Kt[t]?delete e[t]:e[t]=Kt[t];var n=[];for(t in e)n.push(t+\"=\"+e[t]);Xt=n}return Xt}function Jt(t,n){if(x)return Wt(20,1,t,n);var r=0;return Zt().forEach((function(i,a){var s=n+r;for(a=o()[t+4*a>>2>>>0]=s,s=0;s<i.length;++s)e()[a++>>0>>>0]=i.charCodeAt(s);e()[a>>0>>>0]=0,r+=i.length+1})),0}function Qt(t,e){if(x)return Wt(21,1,t,e);var n=Zt();o()[t>>2>>>0]=n.length;var r=0;return n.forEach((function(t){r+=t.length+1})),o()[e>>2>>>0]=r,0}function te(t){return x?Wt(22,1,t):52}function ee(t,e,n,r){return x?Wt(23,1,t,e,n,r):52}function ne(t,e,n,r,i){return x?Wt(24,1,t,e,n,r,i):70}var re=[null,[],[]];function ie(t,e){var n=re[t];0===e||10===e?((1===t?I:P)(V(n,0)),n.length=0):n.push(e)}function oe(t,e,n,i){if(x)return Wt(25,1,t,e,n,i);for(var a=0,s=0;s<n;s++){var u=o()[e>>2>>>0],c=o()[e+4>>2>>>0];e+=8;for(var l=0;l<c;l++)ie(t,r()[u+l>>>0]);a+=c}return o()[i>>2>>>0]=a,0}var ae=0;function se(t){return 0==t%4&&(0!=t%100||0==t%400)}var ue=[31,29,31,30,31,30,31,31,30,31,30,31],ce=[31,28,31,30,31,30,31,31,30,31,30,31];function le(t,n,r,o){function a(t,e,n){for(t=\"number\"==typeof t?t.toString():t||\"\";t.length<e;)t=n[0]+t;return t}function s(t,e){return a(t,e,\"0\")}function u(t,e){function n(t){return 0>t?-1:0<t?1:0}var r;return 0===(r=n(t.getFullYear()-e.getFullYear()))&&0===(r=n(t.getMonth()-e.getMonth()))&&(r=n(t.getDate()-e.getDate())),r}function c(t){switch(t.getDay()){case 0:return new Date(t.getFullYear()-1,11,29);case 1:return t;case 2:return new Date(t.getFullYear(),0,3);case 3:return new Date(t.getFullYear(),0,2);case 4:return new Date(t.getFullYear(),0,1);case 5:return new Date(t.getFullYear()-1,11,31);case 6:return new Date(t.getFullYear()-1,11,30)}}function l(t){var e=t.Wb;for(t=new Date(new Date(t.Xb+1900,0,1).getTime());0<e;){var n=t.getMonth(),r=(se(t.getFullYear())?ue:ce)[n];if(!(e>r-t.getDate())){t.setDate(t.getDate()+e);break}e-=r-t.getDate()+1,t.setDate(1),11>n?t.setMonth(n+1):(t.setMonth(0),t.setFullYear(t.getFullYear()+1))}return n=new Date(t.getFullYear()+1,0,4),e=c(new Date(t.getFullYear(),0,4)),n=c(n),0>=u(e,t)?0>=u(n,t)?t.getFullYear()+1:t.getFullYear():t.getFullYear()-1}var p=i()[o+40>>2>>>0];for(var f in o={Lc:i()[o>>2>>>0],Kc:i()[o+4>>2>>>0],dc:i()[o+8>>2>>>0],jc:i()[o+12>>2>>>0],ec:i()[o+16>>2>>>0],Xb:i()[o+20>>2>>>0],Tb:i()[o+24>>2>>>0],Wb:i()[o+28>>2>>>0],Rc:i()[o+32>>2>>>0],Jc:i()[o+36>>2>>>0],Mc:p?B(p):\"\"},r=B(r),p={\"%c\":\"%a %b %d %H:%M:%S %Y\",\"%D\":\"%m/%d/%y\",\"%F\":\"%Y-%m-%d\",\"%h\":\"%b\",\"%r\":\"%I:%M:%S %p\",\"%R\":\"%H:%M\",\"%T\":\"%H:%M:%S\",\"%x\":\"%m/%d/%y\",\"%X\":\"%H:%M:%S\",\"%Ec\":\"%c\",\"%EC\":\"%C\",\"%Ex\":\"%m/%d/%y\",\"%EX\":\"%H:%M:%S\",\"%Ey\":\"%y\",\"%EY\":\"%Y\",\"%Od\":\"%d\",\"%Oe\":\"%e\",\"%OH\":\"%H\",\"%OI\":\"%I\",\"%Om\":\"%m\",\"%OM\":\"%M\",\"%OS\":\"%S\",\"%Ou\":\"%u\",\"%OU\":\"%U\",\"%OV\":\"%V\",\"%Ow\":\"%w\",\"%OW\":\"%W\",\"%Oy\":\"%y\"})r=r.replace(new RegExp(f,\"g\"),p[f]);var d=\"Sunday Monday Tuesday Wednesday Thursday Friday Saturday\".split(\" \"),h=\"January February March April May June July August September October November December\".split(\" \");for(f in p={\"%a\":function(t){return d[t.Tb].substring(0,3)},\"%A\":function(t){return d[t.Tb]},\"%b\":function(t){return h[t.ec].substring(0,3)},\"%B\":function(t){return h[t.ec]},\"%C\":function(t){return s((t.Xb+1900)/100|0,2)},\"%d\":function(t){return s(t.jc,2)},\"%e\":function(t){return a(t.jc,2,\" \")},\"%g\":function(t){return l(t).toString().substring(2)},\"%G\":function(t){return l(t)},\"%H\":function(t){return s(t.dc,2)},\"%I\":function(t){return 0==(t=t.dc)?t=12:12<t&&(t-=12),s(t,2)},\"%j\":function(t){for(var e=0,n=0;n<=t.ec-1;e+=(se(t.Xb+1900)?ue:ce)[n++]);return s(t.jc+e,3)},\"%m\":function(t){return s(t.ec+1,2)},\"%M\":function(t){return s(t.Kc,2)},\"%n\":function(){return\"\\n\"},\"%p\":function(t){return 0<=t.dc&&12>t.dc?\"AM\":\"PM\"},\"%S\":function(t){return s(t.Lc,2)},\"%t\":function(){return\"\\t\"},\"%u\":function(t){return t.Tb||7},\"%U\":function(t){return s(Math.floor((t.Wb+7-t.Tb)/7),2)},\"%V\":function(t){var e=Math.floor((t.Wb+7-(t.Tb+6)%7)/7);if(2>=(t.Tb+371-t.Wb-2)%7&&e++,e)53==e&&(4==(n=(t.Tb+371-t.Wb)%7)||3==n&&se(t.Xb)||(e=1));else{e=52;var n=(t.Tb+7-t.Wb-1)%7;(4==n||5==n&&se(t.Xb%400-1))&&e++}return s(e,2)},\"%w\":function(t){return t.Tb},\"%W\":function(t){return s(Math.floor((t.Wb+7-(t.Tb+6)%7)/7),2)},\"%y\":function(t){return(t.Xb+1900).toString().substring(2)},\"%Y\":function(t){return t.Xb+1900},\"%z\":function(t){var e=0<=(t=t.Jc);return t=Math.abs(t)/60,(e?\"+\":\"-\")+String(\"0000\"+(t/60*100+t%60)).slice(-4)},\"%Z\":function(t){return t.Mc},\"%%\":function(){return\"%\"}},r=r.replace(/%%/g,\"\\0\\0\"),p)r.includes(f)&&(r=r.replace(new RegExp(f,\"g\"),p[f](o)));return f=function(t){var e=Array(G(t)+1);return z(t,e,0,e.length),e}(r=r.replace(/\\0\\0/g,\"%\")),f.length>n?0:(function(t,n){e().set(t,n>>>0)}(f,t),f.length-1)}dt.fc();var pe=[null,pt,bt,At,It,Pt,Dt,$t,kt,Ct,Ft,Nt,Rt,Lt,Mt,jt,Ut,zt,Gt,qt,Jt,Qt,te,ee,ne,oe],fe={b:function(t){return he(t+24)+24},n:function(t){return(t=new St(t)).uc()||(t.hc(!0),xt--),t.ic(!1),wt.push(t),t.sc(),t.vc()},ma:function(t){throw P(\"Unexpected exception thrown, this is not properly supported - aborting\"),j=!0,t},x:function(){Se(0);var t=wt.pop();if(t.Hc()&&!t.kc()){var e=t.Dc();e&&yt(e)(t.Zb),Ot(t.Zb)}Tt=0},e:function(){var t=Tt;if(!t)return ae=0;var e=new St(t);e.cc(t);var n=e.bc();if(!n)return ae=0,t;for(var r=Array.prototype.slice.call(arguments),i=0;i<r.length;i++){var o=r[i];if(0===o||o===n)break;if(Pe(o,n,e.Sb+16))return ae=o,t}return ae=n,t},l:function(){var t=Tt;if(!t)return ae=0;var e=new St(t);e.cc(t);var n=e.bc();if(!n)return ae=0,t;for(var r=Array.prototype.slice.call(arguments),i=0;i<r.length;i++){var o=r[i];if(0===o||o===n)break;if(Pe(o,n,e.Sb+16))return ae=o,t}return ae=n,t},h:function(){var t=Tt;if(!t)return ae=0;var e=new St(t);e.cc(t);var n=e.bc();if(!n)return ae=0,t;for(var r=Array.prototype.slice.call(arguments),i=0;i<r.length;i++){var o=r[i];if(0===o||o===n)break;if(Pe(o,n,e.Sb+16))return ae=o,t}return ae=n,t},t:Ot,M:function(){var t=wt.pop();t||it(\"no exception to throw\");var e=t.Zb;throw t.kc()||(wt.push(t),t.ic(!0),t.hc(!1),xt++),Tt=e,e},c:function(t,e,n){throw new St(t).fc(e,n),Tt=t,xt++,t},pa:function(){return xt},Fa:function(t){ye(t,!v,1,!_),dt.pc()},T:function(t){x?postMessage({cmd:\"cleanupThread\",thread:t}):ct(t)},xa:Et,j:function(t){throw Tt||(Tt=t),t},H:It,Ma:Pt,ua:Dt,wa:$t,oa:kt,Ka:Ct,Ca:Ft,Ja:Nt,V:Rt,va:Lt,sa:Mt,La:jt,ta:Ut,Ta:function(){},X:function(){it(\"To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking\")},Ua:function(){it(\"To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking\")},W:function(){return Date.now()},ya:function(){return 2097152},Oa:function(){return!0},za:function(t,e,n,r){if(t==e)setTimeout((()=>Vt(r)));else if(x)postMessage({targetThread:t,cmd:\"processProxyingQueue\",queue:r});else{if(!(t=dt.Vb[t]))return;t.postMessage({cmd:\"processProxyingQueue\",queue:r})}return 1},Ea:function(){return-1},Pa:function(t,e){t=new Date(1e3*Bt(t)),i()[e>>2>>>0]=t.getUTCSeconds(),i()[e+4>>2>>>0]=t.getUTCMinutes(),i()[e+8>>2>>>0]=t.getUTCHours(),i()[e+12>>2>>>0]=t.getUTCDate(),i()[e+16>>2>>>0]=t.getUTCMonth(),i()[e+20>>2>>>0]=t.getUTCFullYear()-1900,i()[e+24>>2>>>0]=t.getUTCDay(),t=(t.getTime()-Date.UTC(t.getUTCFullYear(),0,1,0,0,0,0))/864e5|0,i()[e+28>>2>>>0]=t},Qa:function(t,e){t=new Date(1e3*Bt(t)),i()[e>>2>>>0]=t.getSeconds(),i()[e+4>>2>>>0]=t.getMinutes(),i()[e+8>>2>>>0]=t.getHours(),i()[e+12>>2>>>0]=t.getDate(),i()[e+16>>2>>>0]=t.getMonth(),i()[e+20>>2>>>0]=t.getFullYear()-1900,i()[e+24>>2>>>0]=t.getDay();var n=new Date(t.getFullYear(),0,1),r=(t.getTime()-n.getTime())/864e5|0;i()[e+28>>2>>>0]=r,i()[e+36>>2>>>0]=-60*t.getTimezoneOffset(),r=new Date(t.getFullYear(),6,1).getTimezoneOffset(),t=0|(r!=(n=n.getTimezoneOffset())&&t.getTimezoneOffset()==Math.min(n,r)),i()[e+32>>2>>>0]=t},Ra:function(t){var e=new Date(i()[t+20>>2>>>0]+1900,i()[t+16>>2>>>0],i()[t+12>>2>>>0],i()[t+8>>2>>>0],i()[t+4>>2>>>0],i()[t>>2>>>0],0),n=i()[t+32>>2>>>0],r=e.getTimezoneOffset(),o=new Date(e.getFullYear(),0,1),a=new Date(e.getFullYear(),6,1).getTimezoneOffset(),s=o.getTimezoneOffset(),u=Math.min(s,a);return 0>n?i()[t+32>>2>>>0]=Number(a!=s&&u==r):0<n!=(u==r)&&(a=Math.max(s,a),e.setTime(e.getTime()+6e4*((0<n?u:a)-r))),i()[t+24>>2>>>0]=e.getDay(),n=(e.getTime()-o.getTime())/864e5|0,i()[t+28>>2>>>0]=n,i()[t>>2>>>0]=e.getSeconds(),i()[t+4>>2>>>0]=e.getMinutes(),i()[t+8>>2>>>0]=e.getHours(),i()[t+12>>2>>>0]=e.getDate(),i()[t+16>>2>>>0]=e.getMonth(),e.getTime()/1e3|0},Aa:zt,Ba:Gt,Sa:function t(e,n,r){t.Ac||(t.Ac=!0,qt(e,n,r))},y:function(){it(\"\")},U:function(){if(!w&&!v){var t=\"Blocking on the main thread is very dangerous, see https://emscripten.org/docs/porting/pthreads.html#blocking-on-the-main-browser-thread\";_t||(_t={}),_t[t]||(_t[t]=1,w&&(t=\"warning: \"+t),P(t))}},ra:function(){return 4294901760},B:vt,Ia:function(t,e,n){r().copyWithin(t>>>0,e>>>0,e+n>>>0)},F:function(){return w?n(9719).cpus().length:navigator.hardwareConcurrency},Da:function(t,e,n){Yt.length=e,n>>=3;for(var r=0;r<e;r++)Yt[r]=a()[n+r>>>0];return(0>t?st[-t-1]:pe[t]).apply(null,Yt)},qa:function(t){var e=r().length;if((t>>>=0)<=e||4294901760<t)return!1;for(var n=1;4>=n;n*=2){var i=e*(1+.2/n);i=Math.min(i,t+100663296);var o=Math;i=Math.max(t,i),o=o.min.call(o,4294901760,i+(65536-i%65536)%65536);t:{try{$.grow(o-C.byteLength+65535>>>16),H($.buffer);var a=1;break t}catch(t){}a=void 0}if(a)return!0}return!1},Na:function(){throw\"unwind\"},Ga:Jt,Ha:Qt,J:ft,I:te,S:ee,ga:ne,R:oe,d:function(){return ae},na:function t(r,i){t.lc||(t.lc=function(){if(\"object\"==typeof crypto&&\"function\"==typeof crypto.getRandomValues){var t=new Uint8Array(1);return()=>(crypto.getRandomValues(t),t[0])}if(w)try{var e=n(6113);return()=>e.randomBytes(1)[0]}catch(t){}return()=>it(\"randomDevice\")}());for(var o=0;o<i;o++)e()[r+o>>0>>>0]=t.lc();return 0},ia:function(t,e,n){var r=Ae();try{return yt(t)(e,n)}catch(t){if(Ee(r),t!==t+0)throw t;Se(1,0)}},ja:function(t,e,n){var r=Ae();try{return yt(t)(e,n)}catch(t){if(Ee(r),t!==t+0)throw t;Se(1,0)}},K:function(t){var e=Ae();try{return yt(t)()}catch(t){if(Ee(e),t!==t+0)throw t;Se(1,0)}},f:function(t,e){var n=Ae();try{return yt(t)(e)}catch(t){if(Ee(n),t!==t+0)throw t;Se(1,0)}},P:function(t,e,n){var r=Ae();try{return yt(t)(e,n)}catch(t){if(Ee(r),t!==t+0)throw t;Se(1,0)}},Q:function(t,e,n){var r=Ae();try{return yt(t)(e,n)}catch(t){if(Ee(r),t!==t+0)throw t;Se(1,0)}},k:function(t,e,n){var r=Ae();try{return yt(t)(e,n)}catch(t){if(Ee(r),t!==t+0)throw t;Se(1,0)}},p:function(t,e,n,r){var i=Ae();try{return yt(t)(e,n,r)}catch(t){if(Ee(i),t!==t+0)throw t;Se(1,0)}},q:function(t,e,n,r,i){var o=Ae();try{return yt(t)(e,n,r,i)}catch(t){if(Ee(o),t!==t+0)throw t;Se(1,0)}},N:function(t,e,n,r,i,o){var a=Ae();try{return yt(t)(e,n,r,i,o)}catch(t){if(Ee(a),t!==t+0)throw t;Se(1,0)}},s:function(t,e,n,r,i,o){var a=Ae();try{return yt(t)(e,n,r,i,o)}catch(t){if(Ee(a),t!==t+0)throw t;Se(1,0)}},w:function(t,e,n,r,i,o,a){var s=Ae();try{return yt(t)(e,n,r,i,o,a)}catch(t){if(Ee(s),t!==t+0)throw t;Se(1,0)}},L:function(t,e,n,r,i,o,a,s){var u=Ae();try{return yt(t)(e,n,r,i,o,a,s)}catch(t){if(Ee(u),t!==t+0)throw t;Se(1,0)}},E:function(t,e,n,r,i,o,a,s,u,c,l,p){var f=Ae();try{return yt(t)(e,n,r,i,o,a,s,u,c,l,p)}catch(t){if(Ee(f),t!==t+0)throw t;Se(1,0)}},aa:function(t,e,n,r,i,o,a,s){var u=Ae();try{return je(t,e,n,r,i,o,a,s)}catch(t){if(Ee(u),t!==t+0)throw t;Se(1,0)}},_:function(t,e,n,r,i,o,a){var s=Ae();try{return ke(t,e,n,r,i,o,a)}catch(t){if(Ee(s),t!==t+0)throw t;Se(1,0)}},Z:function(t,e,n,r,i){var o=Ae();try{return Ue(t,e,n,r,i)}catch(t){if(Ee(o),t!==t+0)throw t;Se(1,0)}},ca:function(t,e,n,r){var i=Ae();try{return Le(t,e,n,r)}catch(t){if(Ee(i),t!==t+0)throw t;Se(1,0)}},$:function(t){var e=Ae();try{return $e(t)}catch(t){if(Ee(e),t!==t+0)throw t;Se(1,0)}},ba:function(t,e){var n=Ae();try{return Me(t,e)}catch(t){if(Ee(n),t!==t+0)throw t;Se(1,0)}},Y:function(t,e,n){var r=Ae();try{return Ce(t,e,n)}catch(t){if(Ee(r),t!==t+0)throw t;Se(1,0)}},g:function(t){var e=Ae();try{yt(t)()}catch(t){if(Ee(e),t!==t+0)throw t;Se(1,0)}},r:function(t,e){var n=Ae();try{yt(t)(e)}catch(t){if(Ee(n),t!==t+0)throw t;Se(1,0)}},i:function(t,e,n){var r=Ae();try{yt(t)(e,n)}catch(t){if(Ee(r),t!==t+0)throw t;Se(1,0)}},ha:function(t,e,n,r){var i=Ae();try{yt(t)(e,n,r)}catch(t){if(Ee(i),t!==t+0)throw t;Se(1,0)}},m:function(t,e,n,r){var i=Ae();try{yt(t)(e,n,r)}catch(t){if(Ee(i),t!==t+0)throw t;Se(1,0)}},v:function(t,e,n,r,i){var o=Ae();try{yt(t)(e,n,r,i)}catch(t){if(Ee(o),t!==t+0)throw t;Se(1,0)}},u:function(t,e,n,r,i,o){var a=Ae();try{yt(t)(e,n,r,i,o)}catch(t){if(Ee(a),t!==t+0)throw t;Se(1,0)}},O:function(t,e,n,r,i,o,a){var s=Ae();try{yt(t)(e,n,r,i,o,a)}catch(t){if(Ee(s),t!==t+0)throw t;Se(1,0)}},A:function(t,e,n,r,i,o,a,s){var u=Ae();try{yt(t)(e,n,r,i,o,a,s)}catch(t){if(Ee(u),t!==t+0)throw t;Se(1,0)}},ka:function(t,e,n,r,i,o,a,s,u){var c=Ae();try{yt(t)(e,n,r,i,o,a,s,u)}catch(t){if(Ee(c),t!==t+0)throw t;Se(1,0)}},C:function(t,e,n,r,i,o,a,s,u,c,l){var p=Ae();try{yt(t)(e,n,r,i,o,a,s,u,c,l)}catch(t){if(Ee(p),t!==t+0)throw t;Se(1,0)}},D:function(t,e,n,r,i,o,a,s,u,c,l,p,f,d,h,g){var b=Ae();try{yt(t)(e,n,r,i,o,a,s,u,c,l,p,f,d,h,g)}catch(t){if(Ee(b),t!==t+0)throw t;Se(1,0)}},fa:function(t,e,n,r,i,o,a,s){var u=Ae();try{Fe(t,e,n,r,i,o,a,s)}catch(t){if(Ee(u),t!==t+0)throw t;Se(1,0)}},da:function(t,e,n,r,i,o,a,s,u,c,l,p){var f=Ae();try{Re(t,e,n,r,i,o,a,s,u,c,l,p)}catch(t){if(Ee(f),t!==t+0)throw t;Se(1,0)}},ea:function(t,e,n,r,i,o){var a=Ae();try{Ne(t,e,n,r,i,o)}catch(t){if(Ee(a),t!==t+0)throw t;Se(1,0)}},o:function(t){return t},a:$||s.wasmMemory,G:function(t){ae=t},la:le,z:function(t,e,n,r){return le(t,e,n,r)}};!function(){function t(t,e){s.asm=t.exports,dt.qc.push(s.asm.sb),W=s.asm.ub,Y.unshift(s.asm.Va),k=e,x||(et--,s.monitorRunDependencies&&s.monitorRunDependencies(et),0==et&&(null!==nt&&(clearInterval(nt),nt=null),rt&&(t=rt,rt=null,t())))}function e(e){t(e.instance,e.module)}function n(t){return function(){if(!E&&(_||v)){if(\"function\"==typeof fetch&&!tt.startsWith(\"file://\"))return fetch(tt,{credentials:\"same-origin\"}).then((function(t){if(!t.ok)throw\"failed to load wasm binary file at '\"+tt+\"'\";return t.arrayBuffer()})).catch((function(){return at()}));if(p)return new Promise((function(t,e){p(tt,(function(e){t(new Uint8Array(e))}),e)}))}return Promise.resolve().then((function(){return at()}))}().then((function(t){return WebAssembly.instantiate(t,r)})).then((function(t){return t})).then(t,(function(t){P(\"failed to asynchronously prepare wasm: \"+t),it(t)}))}var r={a:fe};if(x||(et++,s.monitorRunDependencies&&s.monitorRunDependencies(et)),s.instantiateWasm)try{return s.instantiateWasm(r,t)}catch(t){return P(\"Module.instantiateWasm callback failed with error: \"+t),!1}(E||\"function\"!=typeof WebAssembly.instantiateStreaming||ot()||tt.startsWith(\"file://\")||w||\"function\"!=typeof fetch?n(e):fetch(tt,{credentials:\"same-origin\"}).then((function(t){return WebAssembly.instantiateStreaming(t,r).then(e,(function(t){return P(\"wasm streaming compile failed: \"+t),P(\"falling back to ArrayBuffer instantiation\"),n(e)}))}))).catch(c)}(),s.___wasm_call_ctors=function(){return(s.___wasm_call_ctors=s.asm.Va).apply(null,arguments)},s._OrtInit=function(){return(s._OrtInit=s.asm.Wa).apply(null,arguments)},s._OrtCreateSessionOptions=function(){return(s._OrtCreateSessionOptions=s.asm.Xa).apply(null,arguments)},s._OrtAppendExecutionProvider=function(){return(s._OrtAppendExecutionProvider=s.asm.Ya).apply(null,arguments)},s._OrtAddSessionConfigEntry=function(){return(s._OrtAddSessionConfigEntry=s.asm.Za).apply(null,arguments)},s._OrtReleaseSessionOptions=function(){return(s._OrtReleaseSessionOptions=s.asm._a).apply(null,arguments)},s._OrtCreateSession=function(){return(s._OrtCreateSession=s.asm.$a).apply(null,arguments)},s._OrtReleaseSession=function(){return(s._OrtReleaseSession=s.asm.ab).apply(null,arguments)},s._OrtGetInputCount=function(){return(s._OrtGetInputCount=s.asm.bb).apply(null,arguments)},s._OrtGetOutputCount=function(){return(s._OrtGetOutputCount=s.asm.cb).apply(null,arguments)},s._OrtGetInputName=function(){return(s._OrtGetInputName=s.asm.db).apply(null,arguments)},s._OrtGetOutputName=function(){return(s._OrtGetOutputName=s.asm.eb).apply(null,arguments)},s._OrtFree=function(){return(s._OrtFree=s.asm.fb).apply(null,arguments)},s._OrtCreateTensor=function(){return(s._OrtCreateTensor=s.asm.gb).apply(null,arguments)},s._OrtGetTensorData=function(){return(s._OrtGetTensorData=s.asm.hb).apply(null,arguments)},s._OrtReleaseTensor=function(){return(s._OrtReleaseTensor=s.asm.ib).apply(null,arguments)},s._OrtCreateRunOptions=function(){return(s._OrtCreateRunOptions=s.asm.jb).apply(null,arguments)},s._OrtAddRunConfigEntry=function(){return(s._OrtAddRunConfigEntry=s.asm.kb).apply(null,arguments)},s._OrtReleaseRunOptions=function(){return(s._OrtReleaseRunOptions=s.asm.lb).apply(null,arguments)},s._OrtRun=function(){return(s._OrtRun=s.asm.mb).apply(null,arguments)},s._OrtEndProfiling=function(){return(s._OrtEndProfiling=s.asm.nb).apply(null,arguments)};var de=s._pthread_self=function(){return(de=s._pthread_self=s.asm.ob).apply(null,arguments)},he=s._malloc=function(){return(he=s._malloc=s.asm.pb).apply(null,arguments)},ge=s._free=function(){return(ge=s._free=s.asm.qb).apply(null,arguments)},be=s._fflush=function(){return(be=s._fflush=s.asm.rb).apply(null,arguments)};s.__emscripten_tls_init=function(){return(s.__emscripten_tls_init=s.asm.sb).apply(null,arguments)};var me=s.___funcs_on_exit=function(){return(me=s.___funcs_on_exit=s.asm.tb).apply(null,arguments)},ye=s.__emscripten_thread_init=function(){return(ye=s.__emscripten_thread_init=s.asm.vb).apply(null,arguments)};s.__emscripten_thread_crashed=function(){return(s.__emscripten_thread_crashed=s.asm.wb).apply(null,arguments)};var _e,ve=s._emscripten_run_in_main_runtime_thread_js=function(){return(ve=s._emscripten_run_in_main_runtime_thread_js=s.asm.xb).apply(null,arguments)},we=s.__emscripten_proxy_execute_task_queue=function(){return(we=s.__emscripten_proxy_execute_task_queue=s.asm.yb).apply(null,arguments)},xe=s.__emscripten_thread_free_data=function(){return(xe=s.__emscripten_thread_free_data=s.asm.zb).apply(null,arguments)},Te=s.__emscripten_thread_exit=function(){return(Te=s.__emscripten_thread_exit=s.asm.Ab).apply(null,arguments)},Se=s._setThrew=function(){return(Se=s._setThrew=s.asm.Bb).apply(null,arguments)},Oe=s._emscripten_stack_set_limits=function(){return(Oe=s._emscripten_stack_set_limits=s.asm.Cb).apply(null,arguments)},Ae=s.stackSave=function(){return(Ae=s.stackSave=s.asm.Db).apply(null,arguments)},Ee=s.stackRestore=function(){return(Ee=s.stackRestore=s.asm.Eb).apply(null,arguments)},Ie=s.stackAlloc=function(){return(Ie=s.stackAlloc=s.asm.Fb).apply(null,arguments)},Pe=s.___cxa_can_catch=function(){return(Pe=s.___cxa_can_catch=s.asm.Gb).apply(null,arguments)},De=s.___cxa_is_pointer_type=function(){return(De=s.___cxa_is_pointer_type=s.asm.Hb).apply(null,arguments)},$e=s.dynCall_j=function(){return($e=s.dynCall_j=s.asm.Ib).apply(null,arguments)},ke=s.dynCall_iiiiij=function(){return(ke=s.dynCall_iiiiij=s.asm.Jb).apply(null,arguments)},Ce=s.dynCall_jii=function(){return(Ce=s.dynCall_jii=s.asm.Kb).apply(null,arguments)},Fe=s.dynCall_viiiiij=function(){return(Fe=s.dynCall_viiiiij=s.asm.Lb).apply(null,arguments)},Ne=s.dynCall_vjji=function(){return(Ne=s.dynCall_vjji=s.asm.Mb).apply(null,arguments)},Re=s.dynCall_viiijjjii=function(){return(Re=s.dynCall_viiijjjii=s.asm.Nb).apply(null,arguments)},Le=s.dynCall_iij=function(){return(Le=s.dynCall_iij=s.asm.Ob).apply(null,arguments)},Me=s.dynCall_ji=function(){return(Me=s.dynCall_ji=s.asm.Pb).apply(null,arguments)},je=s.dynCall_iiiiiij=function(){return(je=s.dynCall_iiiiiij=s.asm.Qb).apply(null,arguments)},Ue=s.dynCall_iiij=function(){return(Ue=s.dynCall_iiij=s.asm.Rb).apply(null,arguments)};function Ve(){function t(){if(!_e&&(_e=!0,s.calledRun=!0,!j)&&(x||ht(Y),u(s),s.onRuntimeInitialized&&s.onRuntimeInitialized(),!x)){if(s.postRun)for(\"function\"==typeof s.postRun&&(s.postRun=[s.postRun]);s.postRun.length;){var t=s.postRun.shift();Z.unshift(t)}ht(Z)}}if(!(0<et))if(x)u(s),x||ht(Y),postMessage({cmd:\"loaded\"});else{if(s.preRun)for(\"function\"==typeof s.preRun&&(s.preRun=[s.preRun]);s.preRun.length;)Q();ht(X),0<et||(s.setStatus?(s.setStatus(\"Running...\"),setTimeout((function(){setTimeout((function(){s.setStatus(\"\")}),1),t()}),1)):t())}}if(s.UTF8ToString=B,s.stringToUTF8=function(t,e,n){return z(t,r(),e,n)},s.lengthBytesUTF8=G,s.keepRuntimeAlive=J,s.wasmMemory=$,s.stackSave=Ae,s.stackRestore=Ee,s.stackAlloc=Ie,s.ExitStatus=ut,s.PThread=dt,rt=function t(){_e||Ve(),_e||(rt=t)},s.preInit)for(\"function\"==typeof s.preInit&&(s.preInit=[s.preInit]);0<s.preInit.length;)s.preInit.pop()();return Ve(),t.ready});t.exports=r},932:(t,e,n)=>{var _scriptDir,r=(_scriptDir=(_scriptDir=\"undefined\"!=typeof document&&document.currentScript?document.currentScript.src:void 0)||__filename,function(t){var e,r,i;t=t||{},e||(e=void 0!==t?t:{}),e.ready=new Promise((function(t,e){r=t,i=e}));var o,a,s,u,c,l,p=Object.assign({},e),f=\"./this.program\",d=(t,e)=>{throw e},h=\"object\"==typeof window,g=\"function\"==typeof importScripts,b=\"object\"==typeof process&&\"object\"==typeof process.versions&&\"string\"==typeof process.versions.node,m=\"\";b?(m=g?n(1423).dirname(m)+\"/\":__dirname+\"/\",l=()=>{c||(u=n(6231),c=n(1423))},o=function(t,e){return l(),t=c.normalize(t),u.readFileSync(t,e?void 0:\"utf8\")},s=t=>((t=o(t,!0)).buffer||(t=new Uint8Array(t)),t),a=(t,e,n)=>{l(),t=c.normalize(t),u.readFile(t,(function(t,r){t?n(t):e(r.buffer)}))},1<process.argv.length&&(f=process.argv[1].replace(/\\\\/g,\"/\")),process.argv.slice(2),process.on(\"uncaughtException\",(function(t){if(!(t instanceof K))throw t})),process.on(\"unhandledRejection\",(function(t){throw t})),d=(t,e)=>{if(w||0<U)throw process.exitCode=t,e;e instanceof K||v(\"exiting due to exception: \"+e),process.exit(t)},e.inspect=function(){return\"[Emscripten Module object]\"}):(h||g)&&(g?m=self.location.href:\"undefined\"!=typeof document&&document.currentScript&&(m=document.currentScript.src),_scriptDir&&(m=_scriptDir),m=0!==m.indexOf(\"blob:\")?m.substr(0,m.replace(/[?#].*/,\"\").lastIndexOf(\"/\")+1):\"\",o=t=>{var e=new XMLHttpRequest;return e.open(\"GET\",t,!1),e.send(null),e.responseText},g&&(s=t=>{var e=new XMLHttpRequest;return e.open(\"GET\",t,!1),e.responseType=\"arraybuffer\",e.send(null),new Uint8Array(e.response)}),a=(t,e,n)=>{var r=new XMLHttpRequest;r.open(\"GET\",t,!0),r.responseType=\"arraybuffer\",r.onload=()=>{200==r.status||0==r.status&&r.response?e(r.response):n()},r.onerror=n,r.send(null)});var y,_=e.print||console.log.bind(console),v=e.printErr||console.warn.bind(console);Object.assign(e,p),p=null,e.thisProgram&&(f=e.thisProgram),e.quit&&(d=e.quit),e.wasmBinary&&(y=e.wasmBinary);var w=e.noExitRuntime||!1;\"object\"!=typeof WebAssembly&&q(\"no native wasm support detected\");var x,T,S,O,A,E,I=!1,P=\"undefined\"!=typeof TextDecoder?new TextDecoder(\"utf8\"):void 0;function D(t,e,n){var r=(e>>>=0)+n;for(n=e;t[n]&&!(n>=r);)++n;if(16<n-e&&t.buffer&&P)return P.decode(t.subarray(e,n));for(r=\"\";e<n;){var i=t[e++];if(128&i){var o=63&t[e++];if(192==(224&i))r+=String.fromCharCode((31&i)<<6|o);else{var a=63&t[e++];65536>(i=224==(240&i)?(15&i)<<12|o<<6|a:(7&i)<<18|o<<12|a<<6|63&t[e++])?r+=String.fromCharCode(i):(i-=65536,r+=String.fromCharCode(55296|i>>10,56320|1023&i))}}else r+=String.fromCharCode(i)}return r}function $(t,e){return(t>>>=0)?D(O,t,e):\"\"}function k(t,e,n,r){if(!(0<r))return 0;var i=n>>>=0;r=n+r-1;for(var o=0;o<t.length;++o){var a=t.charCodeAt(o);if(55296<=a&&57343>=a&&(a=65536+((1023&a)<<10)|1023&t.charCodeAt(++o)),127>=a){if(n>=r)break;e[n++>>>0]=a}else{if(2047>=a){if(n+1>=r)break;e[n++>>>0]=192|a>>6}else{if(65535>=a){if(n+2>=r)break;e[n++>>>0]=224|a>>12}else{if(n+3>=r)break;e[n++>>>0]=240|a>>18,e[n++>>>0]=128|a>>12&63}e[n++>>>0]=128|a>>6&63}e[n++>>>0]=128|63&a}}return e[n>>>0]=0,n-i}function C(t){for(var e=0,n=0;n<t.length;++n){var r=t.charCodeAt(n);127>=r?e++:2047>=r?e+=2:55296<=r&&57343>=r?(e+=4,++n):e+=3}return e}function F(){var t=x.buffer;T=t,e.HEAP8=S=new Int8Array(t),e.HEAP16=new Int16Array(t),e.HEAP32=A=new Int32Array(t),e.HEAPU8=O=new Uint8Array(t),e.HEAPU16=new Uint16Array(t),e.HEAPU32=E=new Uint32Array(t),e.HEAPF32=new Float32Array(t),e.HEAPF64=new Float64Array(t)}var N,R=[],L=[],M=[],j=[],U=0;function V(){var t=e.preRun.shift();R.unshift(t)}var B,z=0,G=null,H=null;function q(t){throw e.onAbort&&e.onAbort(t),v(t=\"Aborted(\"+t+\")\"),I=!0,t=new WebAssembly.RuntimeError(t+\". Build with -sASSERTIONS for more info.\"),i(t),t}function W(){return B.startsWith(\"data:application/octet-stream;base64,\")}if(B=\"ort-wasm.wasm\",!W()){var X=B;B=e.locateFile?e.locateFile(X,m):m+X}function Y(){var t=B;try{if(t==B&&y)return new Uint8Array(y);if(s)return s(t);throw\"both async and sync fetching of the wasm failed\"}catch(t){q(t)}}function K(t){this.name=\"ExitStatus\",this.message=\"Program terminated with exit(\"+t+\")\",this.status=t}function Z(t){for(;0<t.length;)t.shift()(e)}var J=[],Q=0,tt=0;function et(t){this.Db=t,this.zb=t-24,this.Ub=function(t){E[this.zb+4>>2>>>0]=t},this.Eb=function(){return E[this.zb+4>>2>>>0]},this.Sb=function(t){E[this.zb+8>>2>>>0]=t},this.Wb=function(){return E[this.zb+8>>2>>>0]},this.Tb=function(){A[this.zb>>2>>>0]=0},this.Ib=function(t){S[this.zb+12>>0>>>0]=t?1:0},this.Pb=function(){return 0!=S[this.zb+12>>0>>>0]},this.Jb=function(t){S[this.zb+13>>0>>>0]=t?1:0},this.Lb=function(){return 0!=S[this.zb+13>>0>>>0]},this.Rb=function(t,e){this.Fb(0),this.Ub(t),this.Sb(e),this.Tb(),this.Ib(!1),this.Jb(!1)},this.Nb=function(){A[this.zb>>2>>>0]+=1},this.Xb=function(){var t=A[this.zb>>2>>>0];return A[this.zb>>2>>>0]=t-1,1===t},this.Fb=function(t){E[this.zb+16>>2>>>0]=t},this.Ob=function(){return E[this.zb+16>>2>>>0]},this.Qb=function(){if(Et(this.Eb()))return E[this.Db>>2>>>0];var t=this.Ob();return 0!==t?t:this.Db}}function nt(t){return _t(new et(t).zb)}var rt=[];function it(t){var e=rt[t];return e||(t>=rt.length&&(rt.length=t+1),rt[t]=e=N.get(t)),e}function ot(t){var e=C(t)+1,n=yt(e);return n&&k(t,S,n,e),n}var at={};function st(){if(!ut){var t,e={USER:\"web_user\",LOGNAME:\"web_user\",PATH:\"/\",PWD:\"/\",HOME:\"/home/web_user\",LANG:(\"object\"==typeof navigator&&navigator.languages&&navigator.languages[0]||\"C\").replace(\"-\",\"_\")+\".UTF-8\",_:f||\"./this.program\"};for(t in at)void 0===at[t]?delete e[t]:e[t]=at[t];var n=[];for(t in e)n.push(t+\"=\"+e[t]);ut=n}return ut}var ut,ct=[null,[],[]];function lt(t,e){var n=ct[t];0===e||10===e?((1===t?_:v)(D(n,0)),n.length=0):n.push(e)}var pt=0;function ft(t){return 0==t%4&&(0!=t%100||0==t%400)}var dt=[31,29,31,30,31,30,31,31,30,31,30,31],ht=[31,28,31,30,31,30,31,31,30,31,30,31];function gt(t,e,n,r){function i(t,e,n){for(t=\"number\"==typeof t?t.toString():t||\"\";t.length<e;)t=n[0]+t;return t}function o(t,e){return i(t,e,\"0\")}function a(t,e){function n(t){return 0>t?-1:0<t?1:0}var r;return 0===(r=n(t.getFullYear()-e.getFullYear()))&&0===(r=n(t.getMonth()-e.getMonth()))&&(r=n(t.getDate()-e.getDate())),r}function s(t){switch(t.getDay()){case 0:return new Date(t.getFullYear()-1,11,29);case 1:return t;case 2:return new Date(t.getFullYear(),0,3);case 3:return new Date(t.getFullYear(),0,2);case 4:return new Date(t.getFullYear(),0,1);case 5:return new Date(t.getFullYear()-1,11,31);case 6:return new Date(t.getFullYear()-1,11,30)}}function u(t){var e=t.Bb;for(t=new Date(new Date(t.Cb+1900,0,1).getTime());0<e;){var n=t.getMonth(),r=(ft(t.getFullYear())?dt:ht)[n];if(!(e>r-t.getDate())){t.setDate(t.getDate()+e);break}e-=r-t.getDate()+1,t.setDate(1),11>n?t.setMonth(n+1):(t.setMonth(0),t.setFullYear(t.getFullYear()+1))}return n=new Date(t.getFullYear()+1,0,4),e=s(new Date(t.getFullYear(),0,4)),n=s(n),0>=a(e,t)?0>=a(n,t)?t.getFullYear()+1:t.getFullYear():t.getFullYear()-1}var c=A[r+40>>2>>>0];for(var l in r={$b:A[r>>2>>>0],Zb:A[r+4>>2>>>0],Gb:A[r+8>>2>>>0],Kb:A[r+12>>2>>>0],Hb:A[r+16>>2>>>0],Cb:A[r+20>>2>>>0],Ab:A[r+24>>2>>>0],Bb:A[r+28>>2>>>0],bc:A[r+32>>2>>>0],Yb:A[r+36>>2>>>0],ac:c?$(c):\"\"},n=$(n),c={\"%c\":\"%a %b %d %H:%M:%S %Y\",\"%D\":\"%m/%d/%y\",\"%F\":\"%Y-%m-%d\",\"%h\":\"%b\",\"%r\":\"%I:%M:%S %p\",\"%R\":\"%H:%M\",\"%T\":\"%H:%M:%S\",\"%x\":\"%m/%d/%y\",\"%X\":\"%H:%M:%S\",\"%Ec\":\"%c\",\"%EC\":\"%C\",\"%Ex\":\"%m/%d/%y\",\"%EX\":\"%H:%M:%S\",\"%Ey\":\"%y\",\"%EY\":\"%Y\",\"%Od\":\"%d\",\"%Oe\":\"%e\",\"%OH\":\"%H\",\"%OI\":\"%I\",\"%Om\":\"%m\",\"%OM\":\"%M\",\"%OS\":\"%S\",\"%Ou\":\"%u\",\"%OU\":\"%U\",\"%OV\":\"%V\",\"%Ow\":\"%w\",\"%OW\":\"%W\",\"%Oy\":\"%y\"})n=n.replace(new RegExp(l,\"g\"),c[l]);var p=\"Sunday Monday Tuesday Wednesday Thursday Friday Saturday\".split(\" \"),f=\"January February March April May June July August September October November December\".split(\" \");for(l in c={\"%a\":function(t){return p[t.Ab].substring(0,3)},\"%A\":function(t){return p[t.Ab]},\"%b\":function(t){return f[t.Hb].substring(0,3)},\"%B\":function(t){return f[t.Hb]},\"%C\":function(t){return o((t.Cb+1900)/100|0,2)},\"%d\":function(t){return o(t.Kb,2)},\"%e\":function(t){return i(t.Kb,2,\" \")},\"%g\":function(t){return u(t).toString().substring(2)},\"%G\":function(t){return u(t)},\"%H\":function(t){return o(t.Gb,2)},\"%I\":function(t){return 0==(t=t.Gb)?t=12:12<t&&(t-=12),o(t,2)},\"%j\":function(t){for(var e=0,n=0;n<=t.Hb-1;e+=(ft(t.Cb+1900)?dt:ht)[n++]);return o(t.Kb+e,3)},\"%m\":function(t){return o(t.Hb+1,2)},\"%M\":function(t){return o(t.Zb,2)},\"%n\":function(){return\"\\n\"},\"%p\":function(t){return 0<=t.Gb&&12>t.Gb?\"AM\":\"PM\"},\"%S\":function(t){return o(t.$b,2)},\"%t\":function(){return\"\\t\"},\"%u\":function(t){return t.Ab||7},\"%U\":function(t){return o(Math.floor((t.Bb+7-t.Ab)/7),2)},\"%V\":function(t){var e=Math.floor((t.Bb+7-(t.Ab+6)%7)/7);if(2>=(t.Ab+371-t.Bb-2)%7&&e++,e)53==e&&(4==(n=(t.Ab+371-t.Bb)%7)||3==n&&ft(t.Cb)||(e=1));else{e=52;var n=(t.Ab+7-t.Bb-1)%7;(4==n||5==n&&ft(t.Cb%400-1))&&e++}return o(e,2)},\"%w\":function(t){return t.Ab},\"%W\":function(t){return o(Math.floor((t.Bb+7-(t.Ab+6)%7)/7),2)},\"%y\":function(t){return(t.Cb+1900).toString().substring(2)},\"%Y\":function(t){return t.Cb+1900},\"%z\":function(t){var e=0<=(t=t.Yb);return t=Math.abs(t)/60,(e?\"+\":\"-\")+String(\"0000\"+(t/60*100+t%60)).slice(-4)},\"%Z\":function(t){return t.ac},\"%%\":function(){return\"%\"}},n=n.replace(/%%/g,\"\\0\\0\"),c)n.includes(l)&&(n=n.replace(new RegExp(l,\"g\"),c[l](r)));return l=function(t){var e=Array(C(t)+1);return k(t,e,0,e.length),e}(n=n.replace(/\\0\\0/g,\"%\")),l.length>e?0:(S.set(l,t>>>0),l.length-1)}var bt={a:function(t){return yt(t+24)+24},m:function(t){return(t=new et(t)).Pb()||(t.Ib(!0),Q--),t.Jb(!1),J.push(t),t.Nb(),t.Qb()},ia:function(t){throw v(\"Unexpected exception thrown, this is not properly supported - aborting\"),I=!0,t},w:function(){xt(0);var t=J.pop();if(t.Xb()&&!t.Lb()){var e=t.Wb();e&&it(e)(t.Db),nt(t.Db)}tt=0},d:function(){var t=tt;if(!t)return pt=0;var e=new et(t);e.Fb(t);var n=e.Eb();if(!n)return pt=0,t;for(var r=Array.prototype.slice.call(arguments),i=0;i<r.length;i++){var o=r[i];if(0===o||o===n)break;if(At(o,n,e.zb+16))return pt=o,t}return pt=n,t},k:function(){var t=tt;if(!t)return pt=0;var e=new et(t);e.Fb(t);var n=e.Eb();if(!n)return pt=0,t;for(var r=Array.prototype.slice.call(arguments),i=0;i<r.length;i++){var o=r[i];if(0===o||o===n)break;if(At(o,n,e.zb+16))return pt=o,t}return pt=n,t},g:function(){var t=tt;if(!t)return pt=0;var e=new et(t);e.Fb(t);var n=e.Eb();if(!n)return pt=0,t;for(var r=Array.prototype.slice.call(arguments),i=0;i<r.length;i++){var o=r[i];if(0===o||o===n)break;if(At(o,n,e.zb+16))return pt=o,t}return pt=n,t},s:nt,L:function(){var t=J.pop();t||q(\"no exception to throw\");var e=t.Db;throw t.Lb()||(J.push(t),t.Jb(!0),t.Ib(!1),Q++),tt=e,e},b:function(t,e,n){throw new et(t).Rb(e,n),tt=t,Q++,t},la:function(){return Q},i:function(t){throw tt||(tt=t),t},H:function(){return 0},Ba:function(){},pa:function(){},ra:function(){},ka:function(){return 0},za:function(){},ua:function(){},ya:function(){},R:function(){},qa:function(){},na:function(){},Aa:function(){},oa:function(){},Ha:function(){},Ja:function(){q(\"To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking\")},Ia:function(){q(\"To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking\")},S:function(){return Date.now()},Ca:function(){return!0},Da:function(t,e){t=new Date(1e3*(E[t>>>2]+4294967296*A[t+4>>>2])),A[e>>2>>>0]=t.getUTCSeconds(),A[e+4>>2>>>0]=t.getUTCMinutes(),A[e+8>>2>>>0]=t.getUTCHours(),A[e+12>>2>>>0]=t.getUTCDate(),A[e+16>>2>>>0]=t.getUTCMonth(),A[e+20>>2>>>0]=t.getUTCFullYear()-1900,A[e+24>>2>>>0]=t.getUTCDay(),A[e+28>>2>>>0]=(t.getTime()-Date.UTC(t.getUTCFullYear(),0,1,0,0,0,0))/864e5|0},Ea:function(t,e){t=new Date(1e3*(E[t>>>2]+4294967296*A[t+4>>>2])),A[e>>2>>>0]=t.getSeconds(),A[e+4>>2>>>0]=t.getMinutes(),A[e+8>>2>>>0]=t.getHours(),A[e+12>>2>>>0]=t.getDate(),A[e+16>>2>>>0]=t.getMonth(),A[e+20>>2>>>0]=t.getFullYear()-1900,A[e+24>>2>>>0]=t.getDay();var n=new Date(t.getFullYear(),0,1);A[e+28>>2>>>0]=(t.getTime()-n.getTime())/864e5|0,A[e+36>>2>>>0]=-60*t.getTimezoneOffset();var r=new Date(t.getFullYear(),6,1).getTimezoneOffset();n=n.getTimezoneOffset(),A[e+32>>2>>>0]=0|(r!=n&&t.getTimezoneOffset()==Math.min(n,r))},Fa:function(t){var e=new Date(A[t+20>>2>>>0]+1900,A[t+16>>2>>>0],A[t+12>>2>>>0],A[t+8>>2>>>0],A[t+4>>2>>>0],A[t>>2>>>0],0),n=A[t+32>>2>>>0],r=e.getTimezoneOffset(),i=new Date(e.getFullYear(),0,1),o=new Date(e.getFullYear(),6,1).getTimezoneOffset(),a=i.getTimezoneOffset(),s=Math.min(a,o);return 0>n?A[t+32>>2>>>0]=Number(o!=a&&s==r):0<n!=(s==r)&&(o=Math.max(a,o),e.setTime(e.getTime()+6e4*((0<n?s:o)-r))),A[t+24>>2>>>0]=e.getDay(),A[t+28>>2>>>0]=(e.getTime()-i.getTime())/864e5|0,A[t>>2>>>0]=e.getSeconds(),A[t+4>>2>>>0]=e.getMinutes(),A[t+8>>2>>>0]=e.getHours(),A[t+12>>2>>>0]=e.getDate(),A[t+16>>2>>>0]=e.getMonth(),e.getTime()/1e3|0},sa:function(){return-52},ta:function(){},Ga:function t(e,n,r){t.Vb||(t.Vb=!0,function(t,e,n){function r(t){return(t=t.toTimeString().match(/\\(([A-Za-z ]+)\\)$/))?t[1]:\"GMT\"}var i=(new Date).getFullYear(),o=new Date(i,0,1),a=new Date(i,6,1);i=o.getTimezoneOffset();var s=a.getTimezoneOffset();A[t>>2>>>0]=60*Math.max(i,s),A[e>>2>>>0]=Number(i!=s),t=r(o),e=r(a),t=ot(t),e=ot(e),s<i?(E[n>>2>>>0]=t,E[n+4>>2>>>0]=e):(E[n>>2>>>0]=e,E[n+4>>2>>>0]=t)}(e,n,r))},B:function(){q(\"\")},ma:function(){return 4294901760},I:b?()=>{var t=process.hrtime();return 1e3*t[0]+t[1]/1e6}:()=>performance.now(),xa:function(t,e,n){O.copyWithin(t>>>0,e>>>0,e+n>>>0)},G:function(t){var e=O.length;if(4294901760<(t>>>=0))return!1;for(var n=1;4>=n;n*=2){var r=e*(1+.2/n);r=Math.min(r,t+100663296);var i=Math;r=Math.max(t,r),i=i.min.call(i,4294901760,r+(65536-r%65536)%65536);t:{try{x.grow(i-T.byteLength+65535>>>16),F();var o=1;break t}catch(t){}o=void 0}if(o)return!0}return!1},va:function(t,e){var n=0;return st().forEach((function(r,i){var o=e+n;for(i=E[t+4*i>>2>>>0]=o,o=0;o<r.length;++o)S[i++>>0>>>0]=r.charCodeAt(o);S[i>>0>>>0]=0,n+=r.length+1})),0},wa:function(t,e){var n=st();E[t>>2>>>0]=n.length;var r=0;return n.forEach((function(t){r+=t.length+1})),E[e>>2>>>0]=r,0},ba:function(t){w||0<U||(wt(),Z(M),vt(0),ct[1].length&&lt(1,10),ct[2].length&&lt(2,10)),w||0<U||(e.onExit&&e.onExit(t),I=!0),d(t,new K(t))},E:function(){return 52},Q:function(){return 52},ca:function(){return 70},P:function(t,e,n,r){for(var i=0,o=0;o<n;o++){var a=E[e>>2>>>0],s=E[e+4>>2>>>0];e+=8;for(var u=0;u<s;u++)lt(t,O[a+u>>>0]);i+=s}return E[r>>2>>>0]=i,0},c:function(){return pt},ja:function t(e,r){t.Mb||(t.Mb=function(){if(\"object\"==typeof crypto&&\"function\"==typeof crypto.getRandomValues){var t=new Uint8Array(1);return()=>(crypto.getRandomValues(t),t[0])}if(b)try{var e=n(6113);return()=>e.randomBytes(1)[0]}catch(t){}return()=>q(\"randomDevice\")}());for(var i=0;i<r;i++)S[e+i>>0>>>0]=t.Mb();return 0},ea:function(t,e,n){var r=Tt();try{return it(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;xt(1,0)}},fa:function(t,e,n){var r=Tt();try{return it(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;xt(1,0)}},J:function(t){var e=Tt();try{return it(t)()}catch(t){if(St(e),t!==t+0)throw t;xt(1,0)}},e:function(t,e){var n=Tt();try{return it(t)(e)}catch(t){if(St(n),t!==t+0)throw t;xt(1,0)}},N:function(t,e,n){var r=Tt();try{return it(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;xt(1,0)}},O:function(t,e,n){var r=Tt();try{return it(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;xt(1,0)}},j:function(t,e,n){var r=Tt();try{return it(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;xt(1,0)}},o:function(t,e,n,r){var i=Tt();try{return it(t)(e,n,r)}catch(t){if(St(i),t!==t+0)throw t;xt(1,0)}},p:function(t,e,n,r,i){var o=Tt();try{return it(t)(e,n,r,i)}catch(t){if(St(o),t!==t+0)throw t;xt(1,0)}},M:function(t,e,n,r,i,o){var a=Tt();try{return it(t)(e,n,r,i,o)}catch(t){if(St(a),t!==t+0)throw t;xt(1,0)}},r:function(t,e,n,r,i,o){var a=Tt();try{return it(t)(e,n,r,i,o)}catch(t){if(St(a),t!==t+0)throw t;xt(1,0)}},v:function(t,e,n,r,i,o,a){var s=Tt();try{return it(t)(e,n,r,i,o,a)}catch(t){if(St(s),t!==t+0)throw t;xt(1,0)}},K:function(t,e,n,r,i,o,a,s){var u=Tt();try{return it(t)(e,n,r,i,o,a,s)}catch(t){if(St(u),t!==t+0)throw t;xt(1,0)}},D:function(t,e,n,r,i,o,a,s,u,c,l,p){var f=Tt();try{return it(t)(e,n,r,i,o,a,s,u,c,l,p)}catch(t){if(St(f),t!==t+0)throw t;xt(1,0)}},X:function(t,e,n,r,i,o,a,s){var u=Tt();try{return Rt(t,e,n,r,i,o,a,s)}catch(t){if(St(u),t!==t+0)throw t;xt(1,0)}},V:function(t,e,n,r,i,o,a){var s=Tt();try{return Pt(t,e,n,r,i,o,a)}catch(t){if(St(s),t!==t+0)throw t;xt(1,0)}},U:function(t,e,n,r,i){var o=Tt();try{return Lt(t,e,n,r,i)}catch(t){if(St(o),t!==t+0)throw t;xt(1,0)}},Z:function(t,e,n,r){var i=Tt();try{return Ft(t,e,n,r)}catch(t){if(St(i),t!==t+0)throw t;xt(1,0)}},W:function(t){var e=Tt();try{return It(t)}catch(t){if(St(e),t!==t+0)throw t;xt(1,0)}},Y:function(t,e){var n=Tt();try{return Nt(t,e)}catch(t){if(St(n),t!==t+0)throw t;xt(1,0)}},T:function(t,e,n){var r=Tt();try{return Dt(t,e,n)}catch(t){if(St(r),t!==t+0)throw t;xt(1,0)}},f:function(t){var e=Tt();try{it(t)()}catch(t){if(St(e),t!==t+0)throw t;xt(1,0)}},q:function(t,e){var n=Tt();try{it(t)(e)}catch(t){if(St(n),t!==t+0)throw t;xt(1,0)}},h:function(t,e,n){var r=Tt();try{it(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;xt(1,0)}},da:function(t,e,n,r){var i=Tt();try{it(t)(e,n,r)}catch(t){if(St(i),t!==t+0)throw t;xt(1,0)}},l:function(t,e,n,r){var i=Tt();try{it(t)(e,n,r)}catch(t){if(St(i),t!==t+0)throw t;xt(1,0)}},t:function(t,e,n,r,i){var o=Tt();try{it(t)(e,n,r,i)}catch(t){if(St(o),t!==t+0)throw t;xt(1,0)}},u:function(t,e,n,r,i,o){var a=Tt();try{it(t)(e,n,r,i,o)}catch(t){if(St(a),t!==t+0)throw t;xt(1,0)}},x:function(t,e,n,r,i,o,a){var s=Tt();try{it(t)(e,n,r,i,o,a)}catch(t){if(St(s),t!==t+0)throw t;xt(1,0)}},z:function(t,e,n,r,i,o,a,s){var u=Tt();try{it(t)(e,n,r,i,o,a,s)}catch(t){if(St(u),t!==t+0)throw t;xt(1,0)}},ga:function(t,e,n,r,i,o,a,s,u){var c=Tt();try{it(t)(e,n,r,i,o,a,s,u)}catch(t){if(St(c),t!==t+0)throw t;xt(1,0)}},A:function(t,e,n,r,i,o,a,s,u,c,l){var p=Tt();try{it(t)(e,n,r,i,o,a,s,u,c,l)}catch(t){if(St(p),t!==t+0)throw t;xt(1,0)}},C:function(t,e,n,r,i,o,a,s,u,c,l,p,f,d,h,g){var b=Tt();try{it(t)(e,n,r,i,o,a,s,u,c,l,p,f,d,h,g)}catch(t){if(St(b),t!==t+0)throw t;xt(1,0)}},aa:function(t,e,n,r,i,o,a,s){var u=Tt();try{$t(t,e,n,r,i,o,a,s)}catch(t){if(St(u),t!==t+0)throw t;xt(1,0)}},_:function(t,e,n,r,i,o,a,s,u,c,l,p){var f=Tt();try{Ct(t,e,n,r,i,o,a,s,u,c,l,p)}catch(t){if(St(f),t!==t+0)throw t;xt(1,0)}},$:function(t,e,n,r,i,o){var a=Tt();try{kt(t,e,n,r,i,o)}catch(t){if(St(a),t!==t+0)throw t;xt(1,0)}},n:function(t){return t},F:function(t){pt=t},ha:gt,y:function(t,e,n,r){return gt(t,e,n,r)}};!function(){function t(t){e.asm=t.exports,x=e.asm.Ka,F(),N=e.asm.ib,L.unshift(e.asm.La),z--,e.monitorRunDependencies&&e.monitorRunDependencies(z),0==z&&(null!==G&&(clearInterval(G),G=null),H&&(t=H,H=null,t()))}function n(e){t(e.instance)}function r(t){return function(){if(!y&&(h||g)){if(\"function\"==typeof fetch&&!B.startsWith(\"file://\"))return fetch(B,{credentials:\"same-origin\"}).then((function(t){if(!t.ok)throw\"failed to load wasm binary file at '\"+B+\"'\";return t.arrayBuffer()})).catch((function(){return Y()}));if(a)return new Promise((function(t,e){a(B,(function(e){t(new Uint8Array(e))}),e)}))}return Promise.resolve().then((function(){return Y()}))}().then((function(t){return WebAssembly.instantiate(t,o)})).then((function(t){return t})).then(t,(function(t){v(\"failed to asynchronously prepare wasm: \"+t),q(t)}))}var o={a:bt};if(z++,e.monitorRunDependencies&&e.monitorRunDependencies(z),e.instantiateWasm)try{return e.instantiateWasm(o,t)}catch(t){return v(\"Module.instantiateWasm callback failed with error: \"+t),!1}(y||\"function\"!=typeof WebAssembly.instantiateStreaming||W()||B.startsWith(\"file://\")||b||\"function\"!=typeof fetch?r(n):fetch(B,{credentials:\"same-origin\"}).then((function(t){return WebAssembly.instantiateStreaming(t,o).then(n,(function(t){return v(\"wasm streaming compile failed: \"+t),v(\"falling back to ArrayBuffer instantiation\"),r(n)}))}))).catch(i)}(),e.___wasm_call_ctors=function(){return(e.___wasm_call_ctors=e.asm.La).apply(null,arguments)},e._OrtInit=function(){return(e._OrtInit=e.asm.Ma).apply(null,arguments)},e._OrtCreateSessionOptions=function(){return(e._OrtCreateSessionOptions=e.asm.Na).apply(null,arguments)},e._OrtAppendExecutionProvider=function(){return(e._OrtAppendExecutionProvider=e.asm.Oa).apply(null,arguments)},e._OrtAddSessionConfigEntry=function(){return(e._OrtAddSessionConfigEntry=e.asm.Pa).apply(null,arguments)},e._OrtReleaseSessionOptions=function(){return(e._OrtReleaseSessionOptions=e.asm.Qa).apply(null,arguments)},e._OrtCreateSession=function(){return(e._OrtCreateSession=e.asm.Ra).apply(null,arguments)},e._OrtReleaseSession=function(){return(e._OrtReleaseSession=e.asm.Sa).apply(null,arguments)},e._OrtGetInputCount=function(){return(e._OrtGetInputCount=e.asm.Ta).apply(null,arguments)},e._OrtGetOutputCount=function(){return(e._OrtGetOutputCount=e.asm.Ua).apply(null,arguments)},e._OrtGetInputName=function(){return(e._OrtGetInputName=e.asm.Va).apply(null,arguments)},e._OrtGetOutputName=function(){return(e._OrtGetOutputName=e.asm.Wa).apply(null,arguments)},e._OrtFree=function(){return(e._OrtFree=e.asm.Xa).apply(null,arguments)},e._OrtCreateTensor=function(){return(e._OrtCreateTensor=e.asm.Ya).apply(null,arguments)},e._OrtGetTensorData=function(){return(e._OrtGetTensorData=e.asm.Za).apply(null,arguments)},e._OrtReleaseTensor=function(){return(e._OrtReleaseTensor=e.asm._a).apply(null,arguments)},e._OrtCreateRunOptions=function(){return(e._OrtCreateRunOptions=e.asm.$a).apply(null,arguments)},e._OrtAddRunConfigEntry=function(){return(e._OrtAddRunConfigEntry=e.asm.ab).apply(null,arguments)},e._OrtReleaseRunOptions=function(){return(e._OrtReleaseRunOptions=e.asm.bb).apply(null,arguments)},e._OrtRun=function(){return(e._OrtRun=e.asm.cb).apply(null,arguments)},e._OrtEndProfiling=function(){return(e._OrtEndProfiling=e.asm.db).apply(null,arguments)};var mt,yt=e._malloc=function(){return(yt=e._malloc=e.asm.eb).apply(null,arguments)},_t=e._free=function(){return(_t=e._free=e.asm.fb).apply(null,arguments)},vt=e._fflush=function(){return(vt=e._fflush=e.asm.gb).apply(null,arguments)},wt=e.___funcs_on_exit=function(){return(wt=e.___funcs_on_exit=e.asm.hb).apply(null,arguments)},xt=e._setThrew=function(){return(xt=e._setThrew=e.asm.jb).apply(null,arguments)},Tt=e.stackSave=function(){return(Tt=e.stackSave=e.asm.kb).apply(null,arguments)},St=e.stackRestore=function(){return(St=e.stackRestore=e.asm.lb).apply(null,arguments)},Ot=e.stackAlloc=function(){return(Ot=e.stackAlloc=e.asm.mb).apply(null,arguments)},At=e.___cxa_can_catch=function(){return(At=e.___cxa_can_catch=e.asm.nb).apply(null,arguments)},Et=e.___cxa_is_pointer_type=function(){return(Et=e.___cxa_is_pointer_type=e.asm.ob).apply(null,arguments)},It=e.dynCall_j=function(){return(It=e.dynCall_j=e.asm.pb).apply(null,arguments)},Pt=e.dynCall_iiiiij=function(){return(Pt=e.dynCall_iiiiij=e.asm.qb).apply(null,arguments)},Dt=e.dynCall_jii=function(){return(Dt=e.dynCall_jii=e.asm.rb).apply(null,arguments)},$t=e.dynCall_viiiiij=function(){return($t=e.dynCall_viiiiij=e.asm.sb).apply(null,arguments)},kt=e.dynCall_vjji=function(){return(kt=e.dynCall_vjji=e.asm.tb).apply(null,arguments)},Ct=e.dynCall_viiijjjii=function(){return(Ct=e.dynCall_viiijjjii=e.asm.ub).apply(null,arguments)},Ft=e.dynCall_iij=function(){return(Ft=e.dynCall_iij=e.asm.vb).apply(null,arguments)},Nt=e.dynCall_ji=function(){return(Nt=e.dynCall_ji=e.asm.wb).apply(null,arguments)},Rt=e.dynCall_iiiiiij=function(){return(Rt=e.dynCall_iiiiiij=e.asm.xb).apply(null,arguments)},Lt=e.dynCall_iiij=function(){return(Lt=e.dynCall_iiij=e.asm.yb).apply(null,arguments)};function Mt(){function t(){if(!mt&&(mt=!0,e.calledRun=!0,!I)){if(Z(L),r(e),e.onRuntimeInitialized&&e.onRuntimeInitialized(),e.postRun)for(\"function\"==typeof e.postRun&&(e.postRun=[e.postRun]);e.postRun.length;){var t=e.postRun.shift();j.unshift(t)}Z(j)}}if(!(0<z)){if(e.preRun)for(\"function\"==typeof e.preRun&&(e.preRun=[e.preRun]);e.preRun.length;)V();Z(R),0<z||(e.setStatus?(e.setStatus(\"Running...\"),setTimeout((function(){setTimeout((function(){e.setStatus(\"\")}),1),t()}),1)):t())}}if(e.UTF8ToString=$,e.stringToUTF8=function(t,e,n){return k(t,O,e,n)},e.lengthBytesUTF8=C,e.stackSave=Tt,e.stackRestore=St,e.stackAlloc=Ot,H=function t(){mt||Mt(),mt||(H=t)},e.preInit)for(\"function\"==typeof e.preInit&&(e.preInit=[e.preInit]);0<e.preInit.length;)e.preInit.pop()();return Mt(),t.ready});t.exports=r},4537:t=>{\"use strict\";t.exports=function(t,e){for(var n=new Array(arguments.length-1),r=0,i=2,o=!0;i<arguments.length;)n[r++]=arguments[i++];return new Promise((function(i,a){n[r]=function(t){if(o)if(o=!1,t)a(t);else{for(var e=new Array(arguments.length-1),n=0;n<e.length;)e[n++]=arguments[n];i.apply(null,e)}};try{t.apply(e||null,n)}catch(t){o&&(o=!1,a(t))}}))}},7419:(t,e)=>{\"use strict\";var n=e;n.length=function(t){var e=t.length;if(!e)return 0;for(var n=0;--e%4>1&&\"=\"===t.charAt(e);)++n;return Math.ceil(3*t.length)/4-n};for(var r=new Array(64),i=new Array(123),o=0;o<64;)i[r[o]=o<26?o+65:o<52?o+71:o<62?o-4:o-59|43]=o++;n.encode=function(t,e,n){for(var i,o=null,a=[],s=0,u=0;e<n;){var c=t[e++];switch(u){case 0:a[s++]=r[c>>2],i=(3&c)<<4,u=1;break;case 1:a[s++]=r[i|c>>4],i=(15&c)<<2,u=2;break;case 2:a[s++]=r[i|c>>6],a[s++]=r[63&c],u=0}s>8191&&((o||(o=[])).push(String.fromCharCode.apply(String,a)),s=0)}return u&&(a[s++]=r[i],a[s++]=61,1===u&&(a[s++]=61)),o?(s&&o.push(String.fromCharCode.apply(String,a.slice(0,s))),o.join(\"\")):String.fromCharCode.apply(String,a.slice(0,s))};var a=\"invalid encoding\";n.decode=function(t,e,n){for(var r,o=n,s=0,u=0;u<t.length;){var c=t.charCodeAt(u++);if(61===c&&s>1)break;if(void 0===(c=i[c]))throw Error(a);switch(s){case 0:r=c,s=1;break;case 1:e[n++]=r<<2|(48&c)>>4,r=c,s=2;break;case 2:e[n++]=(15&r)<<4|(60&c)>>2,r=c,s=3;break;case 3:e[n++]=(3&r)<<6|c,s=0}}if(1===s)throw Error(a);return n-o},n.test=function(t){return/^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(t)}},9211:t=>{\"use strict\";function e(){this._listeners={}}t.exports=e,e.prototype.on=function(t,e,n){return(this._listeners[t]||(this._listeners[t]=[])).push({fn:e,ctx:n||this}),this},e.prototype.off=function(t,e){if(void 0===t)this._listeners={};else if(void 0===e)this._listeners[t]=[];else for(var n=this._listeners[t],r=0;r<n.length;)n[r].fn===e?n.splice(r,1):++r;return this},e.prototype.emit=function(t){var e=this._listeners[t];if(e){for(var n=[],r=1;r<arguments.length;)n.push(arguments[r++]);for(r=0;r<e.length;)e[r].fn.apply(e[r++].ctx,n)}return this}},945:t=>{\"use strict\";function e(t){return\"undefined\"!=typeof Float32Array?function(){var e=new Float32Array([-0]),n=new Uint8Array(e.buffer),r=128===n[3];function i(t,r,i){e[0]=t,r[i]=n[0],r[i+1]=n[1],r[i+2]=n[2],r[i+3]=n[3]}function o(t,r,i){e[0]=t,r[i]=n[3],r[i+1]=n[2],r[i+2]=n[1],r[i+3]=n[0]}function a(t,r){return n[0]=t[r],n[1]=t[r+1],n[2]=t[r+2],n[3]=t[r+3],e[0]}function s(t,r){return n[3]=t[r],n[2]=t[r+1],n[1]=t[r+2],n[0]=t[r+3],e[0]}t.writeFloatLE=r?i:o,t.writeFloatBE=r?o:i,t.readFloatLE=r?a:s,t.readFloatBE=r?s:a}():function(){function e(t,e,n,r){var i=e<0?1:0;if(i&&(e=-e),0===e)t(1/e>0?0:2147483648,n,r);else if(isNaN(e))t(2143289344,n,r);else if(e>34028234663852886e22)t((i<<31|2139095040)>>>0,n,r);else if(e<11754943508222875e-54)t((i<<31|Math.round(e/1401298464324817e-60))>>>0,n,r);else{var o=Math.floor(Math.log(e)/Math.LN2);t((i<<31|o+127<<23|8388607&Math.round(e*Math.pow(2,-o)*8388608))>>>0,n,r)}}function a(t,e,n){var r=t(e,n),i=2*(r>>31)+1,o=r>>>23&255,a=8388607&r;return 255===o?a?NaN:i*(1/0):0===o?1401298464324817e-60*i*a:i*Math.pow(2,o-150)*(a+8388608)}t.writeFloatLE=e.bind(null,n),t.writeFloatBE=e.bind(null,r),t.readFloatLE=a.bind(null,i),t.readFloatBE=a.bind(null,o)}(),\"undefined\"!=typeof Float64Array?function(){var e=new Float64Array([-0]),n=new Uint8Array(e.buffer),r=128===n[7];function i(t,r,i){e[0]=t,r[i]=n[0],r[i+1]=n[1],r[i+2]=n[2],r[i+3]=n[3],r[i+4]=n[4],r[i+5]=n[5],r[i+6]=n[6],r[i+7]=n[7]}function o(t,r,i){e[0]=t,r[i]=n[7],r[i+1]=n[6],r[i+2]=n[5],r[i+3]=n[4],r[i+4]=n[3],r[i+5]=n[2],r[i+6]=n[1],r[i+7]=n[0]}function a(t,r){return n[0]=t[r],n[1]=t[r+1],n[2]=t[r+2],n[3]=t[r+3],n[4]=t[r+4],n[5]=t[r+5],n[6]=t[r+6],n[7]=t[r+7],e[0]}function s(t,r){return n[7]=t[r],n[6]=t[r+1],n[5]=t[r+2],n[4]=t[r+3],n[3]=t[r+4],n[2]=t[r+5],n[1]=t[r+6],n[0]=t[r+7],e[0]}t.writeDoubleLE=r?i:o,t.writeDoubleBE=r?o:i,t.readDoubleLE=r?a:s,t.readDoubleBE=r?s:a}():function(){function e(t,e,n,r,i,o){var a=r<0?1:0;if(a&&(r=-r),0===r)t(0,i,o+e),t(1/r>0?0:2147483648,i,o+n);else if(isNaN(r))t(0,i,o+e),t(2146959360,i,o+n);else if(r>17976931348623157e292)t(0,i,o+e),t((a<<31|2146435072)>>>0,i,o+n);else{var s;if(r<22250738585072014e-324)t((s=r/5e-324)>>>0,i,o+e),t((a<<31|s/4294967296)>>>0,i,o+n);else{var u=Math.floor(Math.log(r)/Math.LN2);1024===u&&(u=1023),t(4503599627370496*(s=r*Math.pow(2,-u))>>>0,i,o+e),t((a<<31|u+1023<<20|1048576*s&1048575)>>>0,i,o+n)}}}function a(t,e,n,r,i){var o=t(r,i+e),a=t(r,i+n),s=2*(a>>31)+1,u=a>>>20&2047,c=4294967296*(1048575&a)+o;return 2047===u?c?NaN:s*(1/0):0===u?5e-324*s*c:s*Math.pow(2,u-1075)*(c+4503599627370496)}t.writeDoubleLE=e.bind(null,n,0,4),t.writeDoubleBE=e.bind(null,r,4,0),t.readDoubleLE=a.bind(null,i,0,4),t.readDoubleBE=a.bind(null,o,4,0)}(),t}function n(t,e,n){e[n]=255&t,e[n+1]=t>>>8&255,e[n+2]=t>>>16&255,e[n+3]=t>>>24}function r(t,e,n){e[n]=t>>>24,e[n+1]=t>>>16&255,e[n+2]=t>>>8&255,e[n+3]=255&t}function i(t,e){return(t[e]|t[e+1]<<8|t[e+2]<<16|t[e+3]<<24)>>>0}function o(t,e){return(t[e]<<24|t[e+1]<<16|t[e+2]<<8|t[e+3])>>>0}t.exports=e(e)},7199:module=>{\"use strict\";function inquire(moduleName){try{var mod=eval(\"quire\".replace(/^/,\"re\"))(moduleName);if(mod&&(mod.length||Object.keys(mod).length))return mod}catch(t){}return null}module.exports=inquire},6662:t=>{\"use strict\";t.exports=function(t,e,n){var r=n||8192,i=r>>>1,o=null,a=r;return function(n){if(n<1||n>i)return t(n);a+n>r&&(o=t(r),a=0);var s=e.call(o,a,a+=n);return 7&a&&(a=1+(7|a)),s}}},4997:(t,e)=>{\"use strict\";var n=e;n.length=function(t){for(var e=0,n=0,r=0;r<t.length;++r)(n=t.charCodeAt(r))<128?e+=1:n<2048?e+=2:55296==(64512&n)&&56320==(64512&t.charCodeAt(r+1))?(++r,e+=4):e+=3;return e},n.read=function(t,e,n){if(n-e<1)return\"\";for(var r,i=null,o=[],a=0;e<n;)(r=t[e++])<128?o[a++]=r:r>191&&r<224?o[a++]=(31&r)<<6|63&t[e++]:r>239&&r<365?(r=((7&r)<<18|(63&t[e++])<<12|(63&t[e++])<<6|63&t[e++])-65536,o[a++]=55296+(r>>10),o[a++]=56320+(1023&r)):o[a++]=(15&r)<<12|(63&t[e++])<<6|63&t[e++],a>8191&&((i||(i=[])).push(String.fromCharCode.apply(String,o)),a=0);return i?(a&&i.push(String.fromCharCode.apply(String,o.slice(0,a))),i.join(\"\")):String.fromCharCode.apply(String,o.slice(0,a))},n.write=function(t,e,n){for(var r,i,o=n,a=0;a<t.length;++a)(r=t.charCodeAt(a))<128?e[n++]=r:r<2048?(e[n++]=r>>6|192,e[n++]=63&r|128):55296==(64512&r)&&56320==(64512&(i=t.charCodeAt(a+1)))?(r=65536+((1023&r)<<10)+(1023&i),++a,e[n++]=r>>18|240,e[n++]=r>>12&63|128,e[n++]=r>>6&63|128,e[n++]=63&r|128):(e[n++]=r>>12|224,e[n++]=r>>6&63|128,e[n++]=63&r|128);return n-o}},3442:(t,e)=>{\"use strict\";e.__esModule=!0;var n=function(){function t(e){if(!e)throw new TypeError(\"Invalid argument; `value` has no value.\");this.value=t.EMPTY,e&&t.isGuid(e)&&(this.value=e)}return t.isGuid=function(e){var n=e.toString();return e&&(e instanceof t||t.validator.test(n))},t.create=function(){return new t([t.gen(2),t.gen(1),t.gen(1),t.gen(1),t.gen(3)].join(\"-\"))},t.createEmpty=function(){return new t(\"emptyguid\")},t.parse=function(e){return new t(e)},t.raw=function(){return[t.gen(2),t.gen(1),t.gen(1),t.gen(1),t.gen(3)].join(\"-\")},t.gen=function(t){for(var e=\"\",n=0;n<t;n++)e+=(65536*(1+Math.random())|0).toString(16).substring(1);return e},t.prototype.equals=function(e){return t.isGuid(e)&&this.value===e.toString()},t.prototype.isEmpty=function(){return this.value===t.EMPTY},t.prototype.toString=function(){return this.value},t.prototype.toJSON=function(){return{value:this.value}},t.validator=new RegExp(\"^[a-z0-9]{8}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{12}$\",\"i\"),t.EMPTY=\"00000000-0000-0000-0000-000000000000\",t}();e.Guid=n},3720:t=>{t.exports=n;var e=null;try{e=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch(t){}function n(t,e,n){this.low=0|t,this.high=0|e,this.unsigned=!!n}function r(t){return!0===(t&&t.__isLong__)}n.prototype.__isLong__,Object.defineProperty(n.prototype,\"__isLong__\",{value:!0}),n.isLong=r;var i={},o={};function a(t,e){var n,r,a;return e?(a=0<=(t>>>=0)&&t<256)&&(r=o[t])?r:(n=u(t,(0|t)<0?-1:0,!0),a&&(o[t]=n),n):(a=-128<=(t|=0)&&t<128)&&(r=i[t])?r:(n=u(t,t<0?-1:0,!1),a&&(i[t]=n),n)}function s(t,e){if(isNaN(t))return e?m:b;if(e){if(t<0)return m;if(t>=d)return x}else{if(t<=-h)return T;if(t+1>=h)return w}return t<0?s(-t,e).neg():u(t%f|0,t/f|0,e)}function u(t,e,r){return new n(t,e,r)}n.fromInt=a,n.fromNumber=s,n.fromBits=u;var c=Math.pow;function l(t,e,n){if(0===t.length)throw Error(\"empty string\");if(\"NaN\"===t||\"Infinity\"===t||\"+Infinity\"===t||\"-Infinity\"===t)return b;if(\"number\"==typeof e?(n=e,e=!1):e=!!e,(n=n||10)<2||36<n)throw RangeError(\"radix\");var r;if((r=t.indexOf(\"-\"))>0)throw Error(\"interior hyphen\");if(0===r)return l(t.substring(1),e,n).neg();for(var i=s(c(n,8)),o=b,a=0;a<t.length;a+=8){var u=Math.min(8,t.length-a),p=parseInt(t.substring(a,a+u),n);if(u<8){var f=s(c(n,u));o=o.mul(f).add(s(p))}else o=(o=o.mul(i)).add(s(p))}return o.unsigned=e,o}function p(t,e){return\"number\"==typeof t?s(t,e):\"string\"==typeof t?l(t,e):u(t.low,t.high,\"boolean\"==typeof e?e:t.unsigned)}n.fromString=l,n.fromValue=p;var f=4294967296,d=f*f,h=d/2,g=a(1<<24),b=a(0);n.ZERO=b;var m=a(0,!0);n.UZERO=m;var y=a(1);n.ONE=y;var _=a(1,!0);n.UONE=_;var v=a(-1);n.NEG_ONE=v;var w=u(-1,2147483647,!1);n.MAX_VALUE=w;var x=u(-1,-1,!0);n.MAX_UNSIGNED_VALUE=x;var T=u(0,-2147483648,!1);n.MIN_VALUE=T;var S=n.prototype;S.toInt=function(){return this.unsigned?this.low>>>0:this.low},S.toNumber=function(){return this.unsigned?(this.high>>>0)*f+(this.low>>>0):this.high*f+(this.low>>>0)},S.toString=function(t){if((t=t||10)<2||36<t)throw RangeError(\"radix\");if(this.isZero())return\"0\";if(this.isNegative()){if(this.eq(T)){var e=s(t),n=this.div(e),r=n.mul(e).sub(this);return n.toString(t)+r.toInt().toString(t)}return\"-\"+this.neg().toString(t)}for(var i=s(c(t,6),this.unsigned),o=this,a=\"\";;){var u=o.div(i),l=(o.sub(u.mul(i)).toInt()>>>0).toString(t);if((o=u).isZero())return l+a;for(;l.length<6;)l=\"0\"+l;a=\"\"+l+a}},S.getHighBits=function(){return this.high},S.getHighBitsUnsigned=function(){return this.high>>>0},S.getLowBits=function(){return this.low},S.getLowBitsUnsigned=function(){return this.low>>>0},S.getNumBitsAbs=function(){if(this.isNegative())return this.eq(T)?64:this.neg().getNumBitsAbs();for(var t=0!=this.high?this.high:this.low,e=31;e>0&&0==(t&1<<e);e--);return 0!=this.high?e+33:e+1},S.isZero=function(){return 0===this.high&&0===this.low},S.eqz=S.isZero,S.isNegative=function(){return!this.unsigned&&this.high<0},S.isPositive=function(){return this.unsigned||this.high>=0},S.isOdd=function(){return 1==(1&this.low)},S.isEven=function(){return 0==(1&this.low)},S.equals=function(t){return r(t)||(t=p(t)),(this.unsigned===t.unsigned||this.high>>>31!=1||t.high>>>31!=1)&&this.high===t.high&&this.low===t.low},S.eq=S.equals,S.notEquals=function(t){return!this.eq(t)},S.neq=S.notEquals,S.ne=S.notEquals,S.lessThan=function(t){return this.comp(t)<0},S.lt=S.lessThan,S.lessThanOrEqual=function(t){return this.comp(t)<=0},S.lte=S.lessThanOrEqual,S.le=S.lessThanOrEqual,S.greaterThan=function(t){return this.comp(t)>0},S.gt=S.greaterThan,S.greaterThanOrEqual=function(t){return this.comp(t)>=0},S.gte=S.greaterThanOrEqual,S.ge=S.greaterThanOrEqual,S.compare=function(t){if(r(t)||(t=p(t)),this.eq(t))return 0;var e=this.isNegative(),n=t.isNegative();return e&&!n?-1:!e&&n?1:this.unsigned?t.high>>>0>this.high>>>0||t.high===this.high&&t.low>>>0>this.low>>>0?-1:1:this.sub(t).isNegative()?-1:1},S.comp=S.compare,S.negate=function(){return!this.unsigned&&this.eq(T)?T:this.not().add(y)},S.neg=S.negate,S.add=function(t){r(t)||(t=p(t));var e=this.high>>>16,n=65535&this.high,i=this.low>>>16,o=65535&this.low,a=t.high>>>16,s=65535&t.high,c=t.low>>>16,l=0,f=0,d=0,h=0;return d+=(h+=o+(65535&t.low))>>>16,f+=(d+=i+c)>>>16,l+=(f+=n+s)>>>16,l+=e+a,u((d&=65535)<<16|(h&=65535),(l&=65535)<<16|(f&=65535),this.unsigned)},S.subtract=function(t){return r(t)||(t=p(t)),this.add(t.neg())},S.sub=S.subtract,S.multiply=function(t){if(this.isZero())return b;if(r(t)||(t=p(t)),e)return u(e.mul(this.low,this.high,t.low,t.high),e.get_high(),this.unsigned);if(t.isZero())return b;if(this.eq(T))return t.isOdd()?T:b;if(t.eq(T))return this.isOdd()?T:b;if(this.isNegative())return t.isNegative()?this.neg().mul(t.neg()):this.neg().mul(t).neg();if(t.isNegative())return this.mul(t.neg()).neg();if(this.lt(g)&&t.lt(g))return s(this.toNumber()*t.toNumber(),this.unsigned);var n=this.high>>>16,i=65535&this.high,o=this.low>>>16,a=65535&this.low,c=t.high>>>16,l=65535&t.high,f=t.low>>>16,d=65535&t.low,h=0,m=0,y=0,_=0;return y+=(_+=a*d)>>>16,m+=(y+=o*d)>>>16,y&=65535,m+=(y+=a*f)>>>16,h+=(m+=i*d)>>>16,m&=65535,h+=(m+=o*f)>>>16,m&=65535,h+=(m+=a*l)>>>16,h+=n*d+i*f+o*l+a*c,u((y&=65535)<<16|(_&=65535),(h&=65535)<<16|(m&=65535),this.unsigned)},S.mul=S.multiply,S.divide=function(t){if(r(t)||(t=p(t)),t.isZero())throw Error(\"division by zero\");var n,i,o;if(e)return this.unsigned||-2147483648!==this.high||-1!==t.low||-1!==t.high?u((this.unsigned?e.div_u:e.div_s)(this.low,this.high,t.low,t.high),e.get_high(),this.unsigned):this;if(this.isZero())return this.unsigned?m:b;if(this.unsigned){if(t.unsigned||(t=t.toUnsigned()),t.gt(this))return m;if(t.gt(this.shru(1)))return _;o=m}else{if(this.eq(T))return t.eq(y)||t.eq(v)?T:t.eq(T)?y:(n=this.shr(1).div(t).shl(1)).eq(b)?t.isNegative()?y:v:(i=this.sub(t.mul(n)),o=n.add(i.div(t)));if(t.eq(T))return this.unsigned?m:b;if(this.isNegative())return t.isNegative()?this.neg().div(t.neg()):this.neg().div(t).neg();if(t.isNegative())return this.div(t.neg()).neg();o=b}for(i=this;i.gte(t);){n=Math.max(1,Math.floor(i.toNumber()/t.toNumber()));for(var a=Math.ceil(Math.log(n)/Math.LN2),l=a<=48?1:c(2,a-48),f=s(n),d=f.mul(t);d.isNegative()||d.gt(i);)d=(f=s(n-=l,this.unsigned)).mul(t);f.isZero()&&(f=y),o=o.add(f),i=i.sub(d)}return o},S.div=S.divide,S.modulo=function(t){return r(t)||(t=p(t)),e?u((this.unsigned?e.rem_u:e.rem_s)(this.low,this.high,t.low,t.high),e.get_high(),this.unsigned):this.sub(this.div(t).mul(t))},S.mod=S.modulo,S.rem=S.modulo,S.not=function(){return u(~this.low,~this.high,this.unsigned)},S.and=function(t){return r(t)||(t=p(t)),u(this.low&t.low,this.high&t.high,this.unsigned)},S.or=function(t){return r(t)||(t=p(t)),u(this.low|t.low,this.high|t.high,this.unsigned)},S.xor=function(t){return r(t)||(t=p(t)),u(this.low^t.low,this.high^t.high,this.unsigned)},S.shiftLeft=function(t){return r(t)&&(t=t.toInt()),0==(t&=63)?this:t<32?u(this.low<<t,this.high<<t|this.low>>>32-t,this.unsigned):u(0,this.low<<t-32,this.unsigned)},S.shl=S.shiftLeft,S.shiftRight=function(t){return r(t)&&(t=t.toInt()),0==(t&=63)?this:t<32?u(this.low>>>t|this.high<<32-t,this.high>>t,this.unsigned):u(this.high>>t-32,this.high>=0?0:-1,this.unsigned)},S.shr=S.shiftRight,S.shiftRightUnsigned=function(t){if(r(t)&&(t=t.toInt()),0==(t&=63))return this;var e=this.high;return t<32?u(this.low>>>t|e<<32-t,e>>>t,this.unsigned):u(32===t?e:e>>>t-32,0,this.unsigned)},S.shru=S.shiftRightUnsigned,S.shr_u=S.shiftRightUnsigned,S.toSigned=function(){return this.unsigned?u(this.low,this.high,!1):this},S.toUnsigned=function(){return this.unsigned?this:u(this.low,this.high,!0)},S.toBytes=function(t){return t?this.toBytesLE():this.toBytesBE()},S.toBytesLE=function(){var t=this.high,e=this.low;return[255&e,e>>>8&255,e>>>16&255,e>>>24,255&t,t>>>8&255,t>>>16&255,t>>>24]},S.toBytesBE=function(){var t=this.high,e=this.low;return[t>>>24,t>>>16&255,t>>>8&255,255&t,e>>>24,e>>>16&255,e>>>8&255,255&e]},n.fromBytes=function(t,e,r){return r?n.fromBytesLE(t,e):n.fromBytesBE(t,e)},n.fromBytesLE=function(t,e){return new n(t[0]|t[1]<<8|t[2]<<16|t[3]<<24,t[4]|t[5]<<8|t[6]<<16|t[7]<<24,e)},n.fromBytesBE=function(t,e){return new n(t[4]<<24|t[5]<<16|t[6]<<8|t[7],t[0]<<24|t[1]<<16|t[2]<<8|t[3],e)}},1446:(t,e,n)=>{\"use strict\";var r,i,o,a=n(2100),s=a.Reader,u=a.Writer,c=a.util,l=a.roots.default||(a.roots.default={});l.onnx=((o={}).Version=(r={},(i=Object.create(r))[r[0]=\"_START_VERSION\"]=0,i[r[1]=\"IR_VERSION_2017_10_10\"]=1,i[r[2]=\"IR_VERSION_2017_10_30\"]=2,i[r[3]=\"IR_VERSION_2017_11_3\"]=3,i[r[4]=\"IR_VERSION_2019_1_22\"]=4,i[r[5]=\"IR_VERSION\"]=5,i),o.AttributeProto=function(){function t(t){if(this.floats=[],this.ints=[],this.strings=[],this.tensors=[],this.graphs=[],t)for(var e=Object.keys(t),n=0;n<e.length;++n)null!=t[e[n]]&&(this[e[n]]=t[e[n]])}return t.prototype.name=\"\",t.prototype.refAttrName=\"\",t.prototype.docString=\"\",t.prototype.type=0,t.prototype.f=0,t.prototype.i=c.Long?c.Long.fromBits(0,0,!1):0,t.prototype.s=c.newBuffer([]),t.prototype.t=null,t.prototype.g=null,t.prototype.floats=c.emptyArray,t.prototype.ints=c.emptyArray,t.prototype.strings=c.emptyArray,t.prototype.tensors=c.emptyArray,t.prototype.graphs=c.emptyArray,t.create=function(e){return new t(e)},t.encode=function(t,e){if(e||(e=u.create()),null!=t.name&&t.hasOwnProperty(\"name\")&&e.uint32(10).string(t.name),null!=t.f&&t.hasOwnProperty(\"f\")&&e.uint32(21).float(t.f),null!=t.i&&t.hasOwnProperty(\"i\")&&e.uint32(24).int64(t.i),null!=t.s&&t.hasOwnProperty(\"s\")&&e.uint32(34).bytes(t.s),null!=t.t&&t.hasOwnProperty(\"t\")&&l.onnx.TensorProto.encode(t.t,e.uint32(42).fork()).ldelim(),null!=t.g&&t.hasOwnProperty(\"g\")&&l.onnx.GraphProto.encode(t.g,e.uint32(50).fork()).ldelim(),null!=t.floats&&t.floats.length){e.uint32(58).fork();for(var n=0;n<t.floats.length;++n)e.float(t.floats[n]);e.ldelim()}if(null!=t.ints&&t.ints.length){for(e.uint32(66).fork(),n=0;n<t.ints.length;++n)e.int64(t.ints[n]);e.ldelim()}if(null!=t.strings&&t.strings.length)for(n=0;n<t.strings.length;++n)e.uint32(74).bytes(t.strings[n]);if(null!=t.tensors&&t.tensors.length)for(n=0;n<t.tensors.length;++n)l.onnx.TensorProto.encode(t.tensors[n],e.uint32(82).fork()).ldelim();if(null!=t.graphs&&t.graphs.length)for(n=0;n<t.graphs.length;++n)l.onnx.GraphProto.encode(t.graphs[n],e.uint32(90).fork()).ldelim();return null!=t.docString&&t.hasOwnProperty(\"docString\")&&e.uint32(106).string(t.docString),null!=t.type&&t.hasOwnProperty(\"type\")&&e.uint32(160).int32(t.type),null!=t.refAttrName&&t.hasOwnProperty(\"refAttrName\")&&e.uint32(170).string(t.refAttrName),e},t.encodeDelimited=function(t,e){return this.encode(t,e).ldelim()},t.decode=function(t,e){t instanceof s||(t=s.create(t));for(var n=void 0===e?t.len:t.pos+e,r=new l.onnx.AttributeProto;t.pos<n;){var i=t.uint32();switch(i>>>3){case 1:r.name=t.string();break;case 21:r.refAttrName=t.string();break;case 13:r.docString=t.string();break;case 20:r.type=t.int32();break;case 2:r.f=t.float();break;case 3:r.i=t.int64();break;case 4:r.s=t.bytes();break;case 5:r.t=l.onnx.TensorProto.decode(t,t.uint32());break;case 6:r.g=l.onnx.GraphProto.decode(t,t.uint32());break;case 7:if(r.floats&&r.floats.length||(r.floats=[]),2==(7&i))for(var o=t.uint32()+t.pos;t.pos<o;)r.floats.push(t.float());else r.floats.push(t.float());break;case 8:if(r.ints&&r.ints.length||(r.ints=[]),2==(7&i))for(o=t.uint32()+t.pos;t.pos<o;)r.ints.push(t.int64());else r.ints.push(t.int64());break;case 9:r.strings&&r.strings.length||(r.strings=[]),r.strings.push(t.bytes());break;case 10:r.tensors&&r.tensors.length||(r.tensors=[]),r.tensors.push(l.onnx.TensorProto.decode(t,t.uint32()));break;case 11:r.graphs&&r.graphs.length||(r.graphs=[]),r.graphs.push(l.onnx.GraphProto.decode(t,t.uint32()));break;default:t.skipType(7&i)}}return r},t.decodeDelimited=function(t){return t instanceof s||(t=new s(t)),this.decode(t,t.uint32())},t.verify=function(t){if(\"object\"!=typeof t||null===t)return\"object expected\";if(null!=t.name&&t.hasOwnProperty(\"name\")&&!c.isString(t.name))return\"name: string expected\";if(null!=t.refAttrName&&t.hasOwnProperty(\"refAttrName\")&&!c.isString(t.refAttrName))return\"refAttrName: string expected\";if(null!=t.docString&&t.hasOwnProperty(\"docString\")&&!c.isString(t.docString))return\"docString: string expected\";if(null!=t.type&&t.hasOwnProperty(\"type\"))switch(t.type){default:return\"type: enum value expected\";case 0:case 1:case 2:case 3:case 4:case 5:case 6:case 7:case 8:case 9:case 10:}if(null!=t.f&&t.hasOwnProperty(\"f\")&&\"number\"!=typeof t.f)return\"f: number expected\";if(null!=t.i&&t.hasOwnProperty(\"i\")&&!(c.isInteger(t.i)||t.i&&c.isInteger(t.i.low)&&c.isInteger(t.i.high)))return\"i: integer|Long expected\";if(null!=t.s&&t.hasOwnProperty(\"s\")&&!(t.s&&\"number\"==typeof t.s.length||c.isString(t.s)))return\"s: buffer expected\";if(null!=t.t&&t.hasOwnProperty(\"t\")&&(n=l.onnx.TensorProto.verify(t.t)))return\"t.\"+n;if(null!=t.g&&t.hasOwnProperty(\"g\")&&(n=l.onnx.GraphProto.verify(t.g)))return\"g.\"+n;if(null!=t.floats&&t.hasOwnProperty(\"floats\")){if(!Array.isArray(t.floats))return\"floats: array expected\";for(var e=0;e<t.floats.length;++e)if(\"number\"!=typeof t.floats[e])return\"floats: number[] expected\"}if(null!=t.ints&&t.hasOwnProperty(\"ints\")){if(!Array.isArray(t.ints))return\"ints: array expected\";for(e=0;e<t.ints.length;++e)if(!(c.isInteger(t.ints[e])||t.ints[e]&&c.isInteger(t.ints[e].low)&&c.isInteger(t.ints[e].high)))return\"ints: integer|Long[] expected\"}if(null!=t.strings&&t.hasOwnProperty(\"strings\")){if(!Array.isArray(t.strings))return\"strings: array expected\";for(e=0;e<t.strings.length;++e)if(!(t.strings[e]&&\"number\"==typeof t.strings[e].length||c.isString(t.strings[e])))return\"strings: buffer[] expected\"}if(null!=t.tensors&&t.hasOwnProperty(\"tensors\")){if(!Array.isArray(t.tensors))return\"tensors: array expected\";for(e=0;e<t.tensors.length;++e)if(n=l.onnx.TensorProto.verify(t.tensors[e]))return\"tensors.\"+n}if(null!=t.graphs&&t.hasOwnProperty(\"graphs\")){if(!Array.isArray(t.graphs))return\"graphs: array expected\";for(e=0;e<t.graphs.length;++e){var n;if(n=l.onnx.GraphProto.verify(t.graphs[e]))return\"graphs.\"+n}}return null},t.fromObject=function(t){if(t instanceof l.onnx.AttributeProto)return t;var e=new l.onnx.AttributeProto;switch(null!=t.name&&(e.name=String(t.name)),null!=t.refAttrName&&(e.refAttrName=String(t.refAttrName)),null!=t.docString&&(e.docString=String(t.docString)),t.type){case\"UNDEFINED\":case 0:e.type=0;break;case\"FLOAT\":case 1:e.type=1;break;case\"INT\":case 2:e.type=2;break;case\"STRING\":case 3:e.type=3;break;case\"TENSOR\":case 4:e.type=4;break;case\"GRAPH\":case 5:e.type=5;break;case\"FLOATS\":case 6:e.type=6;break;case\"INTS\":case 7:e.type=7;break;case\"STRINGS\":case 8:e.type=8;break;case\"TENSORS\":case 9:e.type=9;break;case\"GRAPHS\":case 10:e.type=10}if(null!=t.f&&(e.f=Number(t.f)),null!=t.i&&(c.Long?(e.i=c.Long.fromValue(t.i)).unsigned=!1:\"string\"==typeof t.i?e.i=parseInt(t.i,10):\"number\"==typeof t.i?e.i=t.i:\"object\"==typeof t.i&&(e.i=new c.LongBits(t.i.low>>>0,t.i.high>>>0).toNumber())),null!=t.s&&(\"string\"==typeof t.s?c.base64.decode(t.s,e.s=c.newBuffer(c.base64.length(t.s)),0):t.s.length&&(e.s=t.s)),null!=t.t){if(\"object\"!=typeof t.t)throw TypeError(\".onnx.AttributeProto.t: object expected\");e.t=l.onnx.TensorProto.fromObject(t.t)}if(null!=t.g){if(\"object\"!=typeof t.g)throw TypeError(\".onnx.AttributeProto.g: object expected\");e.g=l.onnx.GraphProto.fromObject(t.g)}if(t.floats){if(!Array.isArray(t.floats))throw TypeError(\".onnx.AttributeProto.floats: array expected\");e.floats=[];for(var n=0;n<t.floats.length;++n)e.floats[n]=Number(t.floats[n])}if(t.ints){if(!Array.isArray(t.ints))throw TypeError(\".onnx.AttributeProto.ints: array expected\");for(e.ints=[],n=0;n<t.ints.length;++n)c.Long?(e.ints[n]=c.Long.fromValue(t.ints[n])).unsigned=!1:\"string\"==typeof t.ints[n]?e.ints[n]=parseInt(t.ints[n],10):\"number\"==typeof t.ints[n]?e.ints[n]=t.ints[n]:\"object\"==typeof t.ints[n]&&(e.ints[n]=new c.LongBits(t.ints[n].low>>>0,t.ints[n].high>>>0).toNumber())}if(t.strings){if(!Array.isArray(t.strings))throw TypeError(\".onnx.AttributeProto.strings: array expected\");for(e.strings=[],n=0;n<t.strings.length;++n)\"string\"==typeof t.strings[n]?c.base64.decode(t.strings[n],e.strings[n]=c.newBuffer(c.base64.length(t.strings[n])),0):t.strings[n].length&&(e.strings[n]=t.strings[n])}if(t.tensors){if(!Array.isArray(t.tensors))throw TypeError(\".onnx.AttributeProto.tensors: array expected\");for(e.tensors=[],n=0;n<t.tensors.length;++n){if(\"object\"!=typeof t.tensors[n])throw TypeError(\".onnx.AttributeProto.tensors: object expected\");e.tensors[n]=l.onnx.TensorProto.fromObject(t.tensors[n])}}if(t.graphs){if(!Array.isArray(t.graphs))throw TypeError(\".onnx.AttributeProto.graphs: array expected\");for(e.graphs=[],n=0;n<t.graphs.length;++n){if(\"object\"!=typeof t.graphs[n])throw TypeError(\".onnx.AttributeProto.graphs: object expected\");e.graphs[n]=l.onnx.GraphProto.fromObject(t.graphs[n])}}return e},t.toObject=function(t,e){e||(e={});var n={};if((e.arrays||e.defaults)&&(n.floats=[],n.ints=[],n.strings=[],n.tensors=[],n.graphs=[]),e.defaults){if(n.name=\"\",n.f=0,c.Long){var r=new c.Long(0,0,!1);n.i=e.longs===String?r.toString():e.longs===Number?r.toNumber():r}else n.i=e.longs===String?\"0\":0;e.bytes===String?n.s=\"\":(n.s=[],e.bytes!==Array&&(n.s=c.newBuffer(n.s))),n.t=null,n.g=null,n.docString=\"\",n.type=e.enums===String?\"UNDEFINED\":0,n.refAttrName=\"\"}if(null!=t.name&&t.hasOwnProperty(\"name\")&&(n.name=t.name),null!=t.f&&t.hasOwnProperty(\"f\")&&(n.f=e.json&&!isFinite(t.f)?String(t.f):t.f),null!=t.i&&t.hasOwnProperty(\"i\")&&(\"number\"==typeof t.i?n.i=e.longs===String?String(t.i):t.i:n.i=e.longs===String?c.Long.prototype.toString.call(t.i):e.longs===Number?new c.LongBits(t.i.low>>>0,t.i.high>>>0).toNumber():t.i),null!=t.s&&t.hasOwnProperty(\"s\")&&(n.s=e.bytes===String?c.base64.encode(t.s,0,t.s.length):e.bytes===Array?Array.prototype.slice.call(t.s):t.s),null!=t.t&&t.hasOwnProperty(\"t\")&&(n.t=l.onnx.TensorProto.toObject(t.t,e)),null!=t.g&&t.hasOwnProperty(\"g\")&&(n.g=l.onnx.GraphProto.toObject(t.g,e)),t.floats&&t.floats.length){n.floats=[];for(var i=0;i<t.floats.length;++i)n.floats[i]=e.json&&!isFinite(t.floats[i])?String(t.floats[i]):t.floats[i]}if(t.ints&&t.ints.length)for(n.ints=[],i=0;i<t.ints.length;++i)\"number\"==typeof t.ints[i]?n.ints[i]=e.longs===String?String(t.ints[i]):t.ints[i]:n.ints[i]=e.longs===String?c.Long.prototype.toString.call(t.ints[i]):e.longs===Number?new c.LongBits(t.ints[i].low>>>0,t.ints[i].high>>>0).toNumber():t.ints[i];if(t.strings&&t.strings.length)for(n.strings=[],i=0;i<t.strings.length;++i)n.strings[i]=e.bytes===String?c.base64.encode(t.strings[i],0,t.strings[i].length):e.bytes===Array?Array.prototype.slice.call(t.strings[i]):t.strings[i];if(t.tensors&&t.tensors.length)for(n.tensors=[],i=0;i<t.tensors.length;++i)n.tensors[i]=l.onnx.TensorProto.toObject(t.tensors[i],e);if(t.graphs&&t.graphs.length)for(n.graphs=[],i=0;i<t.graphs.length;++i)n.graphs[i]=l.onnx.GraphProto.toObject(t.graphs[i],e);return null!=t.docString&&t.hasOwnProperty(\"docString\")&&(n.docString=t.docString),null!=t.type&&t.hasOwnProperty(\"type\")&&(n.type=e.enums===String?l.onnx.AttributeProto.AttributeType[t.type]:t.type),null!=t.refAttrName&&t.hasOwnProperty(\"refAttrName\")&&(n.refAttrName=t.refAttrName),n},t.prototype.toJSON=function(){return this.constructor.toObject(this,a.util.toJSONOptions)},t.AttributeType=function(){var t={},e=Object.create(t);return e[t[0]=\"UNDEFINED\"]=0,e[t[1]=\"FLOAT\"]=1,e[t[2]=\"INT\"]=2,e[t[3]=\"STRING\"]=3,e[t[4]=\"TENSOR\"]=4,e[t[5]=\"GRAPH\"]=5,e[t[6]=\"FLOATS\"]=6,e[t[7]=\"INTS\"]=7,e[t[8]=\"STRINGS\"]=8,e[t[9]=\"TENSORS\"]=9,e[t[10]=\"GRAPHS\"]=10,e}(),t}(),o.ValueInfoProto=function(){function t(t){if(t)for(var e=Object.keys(t),n=0;n<e.length;++n)null!=t[e[n]]&&(this[e[n]]=t[e[n]])}return t.prototype.name=\"\",t.prototype.type=null,t.prototype.docString=\"\",t.create=function(e){return new t(e)},t.encode=function(t,e){return e||(e=u.create()),null!=t.name&&t.hasOwnProperty(\"name\")&&e.uint32(10).string(t.name),null!=t.type&&t.hasOwnProperty(\"type\")&&l.onnx.TypeProto.encode(t.type,e.uint32(18).fork()).ldelim(),null!=t.docString&&t.hasOwnProperty(\"docString\")&&e.uint32(26).string(t.docString),e},t.encodeDelimited=function(t,e){return this.encode(t,e).ldelim()},t.decode=function(t,e){t instanceof s||(t=s.create(t));for(var n=void 0===e?t.len:t.pos+e,r=new l.onnx.ValueInfoProto;t.pos<n;){var i=t.uint32();switch(i>>>3){case 1:r.name=t.string();break;case 2:r.type=l.onnx.TypeProto.decode(t,t.uint32());break;case 3:r.docString=t.string();break;default:t.skipType(7&i)}}return r},t.decodeDelimited=function(t){return t instanceof s||(t=new s(t)),this.decode(t,t.uint32())},t.verify=function(t){if(\"object\"!=typeof t||null===t)return\"object expected\";if(null!=t.name&&t.hasOwnProperty(\"name\")&&!c.isString(t.name))return\"name: string expected\";if(null!=t.type&&t.hasOwnProperty(\"type\")){var e=l.onnx.TypeProto.verify(t.type);if(e)return\"type.\"+e}return null!=t.docString&&t.hasOwnProperty(\"docString\")&&!c.isString(t.docString)?\"docString: string expected\":null},t.fromObject=function(t){if(t instanceof l.onnx.ValueInfoProto)return t;var e=new l.onnx.ValueInfoProto;if(null!=t.name&&(e.name=String(t.name)),null!=t.type){if(\"object\"!=typeof t.type)throw TypeError(\".onnx.ValueInfoProto.type: object expected\");e.type=l.onnx.TypeProto.fromObject(t.type)}return null!=t.docString&&(e.docString=String(t.docString)),e},t.toObject=function(t,e){e||(e={});var n={};return e.defaults&&(n.name=\"\",n.type=null,n.docString=\"\"),null!=t.name&&t.hasOwnProperty(\"name\")&&(n.name=t.name),null!=t.type&&t.hasOwnProperty(\"type\")&&(n.type=l.onnx.TypeProto.toObject(t.type,e)),null!=t.docString&&t.hasOwnProperty(\"docString\")&&(n.docString=t.docString),n},t.prototype.toJSON=function(){return this.constructor.toObject(this,a.util.toJSONOptions)},t}(),o.NodeProto=function(){function t(t){if(this.input=[],this.output=[],this.attribute=[],t)for(var e=Object.keys(t),n=0;n<e.length;++n)null!=t[e[n]]&&(this[e[n]]=t[e[n]])}return t.prototype.input=c.emptyArray,t.prototype.output=c.emptyArray,t.prototype.name=\"\",t.prototype.opType=\"\",t.prototype.domain=\"\",t.prototype.attribute=c.emptyArray,t.prototype.docString=\"\",t.create=function(e){return new t(e)},t.encode=function(t,e){if(e||(e=u.create()),null!=t.input&&t.input.length)for(var n=0;n<t.input.length;++n)e.uint32(10).string(t.input[n]);if(null!=t.output&&t.output.length)for(n=0;n<t.output.length;++n)e.uint32(18).string(t.output[n]);if(null!=t.name&&t.hasOwnProperty(\"name\")&&e.uint32(26).string(t.name),null!=t.opType&&t.hasOwnProperty(\"opType\")&&e.uint32(34).string(t.opType),null!=t.attribute&&t.attribute.length)for(n=0;n<t.attribute.length;++n)l.onnx.AttributeProto.encode(t.attribute[n],e.uint32(42).fork()).ldelim();return null!=t.docString&&t.hasOwnProperty(\"docString\")&&e.uint32(50).string(t.docString),null!=t.domain&&t.hasOwnProperty(\"domain\")&&e.uint32(58).string(t.domain),e},t.encodeDelimited=function(t,e){return this.encode(t,e).ldelim()},t.decode=function(t,e){t instanceof s||(t=s.create(t));for(var n=void 0===e?t.len:t.pos+e,r=new l.onnx.NodeProto;t.pos<n;){var i=t.uint32();switch(i>>>3){case 1:r.input&&r.input.length||(r.input=[]),r.input.push(t.string());break;case 2:r.output&&r.output.length||(r.output=[]),r.output.push(t.string());break;case 3:r.name=t.string();break;case 4:r.opType=t.string();break;case 7:r.domain=t.string();break;case 5:r.attribute&&r.attribute.length||(r.attribute=[]),r.attribute.push(l.onnx.AttributeProto.decode(t,t.uint32()));break;case 6:r.docString=t.string();break;default:t.skipType(7&i)}}return r},t.decodeDelimited=function(t){return t instanceof s||(t=new s(t)),this.decode(t,t.uint32())},t.verify=function(t){if(\"object\"!=typeof t||null===t)return\"object expected\";if(null!=t.input&&t.hasOwnProperty(\"input\")){if(!Array.isArray(t.input))return\"input: array expected\";for(var e=0;e<t.input.length;++e)if(!c.isString(t.input[e]))return\"input: string[] expected\"}if(null!=t.output&&t.hasOwnProperty(\"output\")){if(!Array.isArray(t.output))return\"output: array expected\";for(e=0;e<t.output.length;++e)if(!c.isString(t.output[e]))return\"output: string[] expected\"}if(null!=t.name&&t.hasOwnProperty(\"name\")&&!c.isString(t.name))return\"name: string expected\";if(null!=t.opType&&t.hasOwnProperty(\"opType\")&&!c.isString(t.opType))return\"opType: string expected\";if(null!=t.domain&&t.hasOwnProperty(\"domain\")&&!c.isString(t.domain))return\"domain: string expected\";if(null!=t.attribute&&t.hasOwnProperty(\"attribute\")){if(!Array.isArray(t.attribute))return\"attribute: array expected\";for(e=0;e<t.attribute.length;++e){var n=l.onnx.AttributeProto.verify(t.attribute[e]);if(n)return\"attribute.\"+n}}return null!=t.docString&&t.hasOwnProperty(\"docString\")&&!c.isString(t.docString)?\"docString: string expected\":null},t.fromObject=function(t){if(t instanceof l.onnx.NodeProto)return t;var e=new l.onnx.NodeProto;if(t.input){if(!Array.isArray(t.input))throw TypeError(\".onnx.NodeProto.input: array expected\");e.input=[];for(var n=0;n<t.input.length;++n)e.input[n]=String(t.input[n])}if(t.output){if(!Array.isArray(t.output))throw TypeError(\".onnx.NodeProto.output: array expected\");for(e.output=[],n=0;n<t.output.length;++n)e.output[n]=String(t.output[n])}if(null!=t.name&&(e.name=String(t.name)),null!=t.opType&&(e.opType=String(t.opType)),null!=t.domain&&(e.domain=String(t.domain)),t.attribute){if(!Array.isArray(t.attribute))throw TypeError(\".onnx.NodeProto.attribute: array expected\");for(e.attribute=[],n=0;n<t.attribute.length;++n){if(\"object\"!=typeof t.attribute[n])throw TypeError(\".onnx.NodeProto.attribute: object expected\");e.attribute[n]=l.onnx.AttributeProto.fromObject(t.attribute[n])}}return null!=t.docString&&(e.docString=String(t.docString)),e},t.toObject=function(t,e){e||(e={});var n={};if((e.arrays||e.defaults)&&(n.input=[],n.output=[],n.attribute=[]),e.defaults&&(n.name=\"\",n.opType=\"\",n.docString=\"\",n.domain=\"\"),t.input&&t.input.length){n.input=[];for(var r=0;r<t.input.length;++r)n.input[r]=t.input[r]}if(t.output&&t.output.length)for(n.output=[],r=0;r<t.output.length;++r)n.output[r]=t.output[r];if(null!=t.name&&t.hasOwnProperty(\"name\")&&(n.name=t.name),null!=t.opType&&t.hasOwnProperty(\"opType\")&&(n.opType=t.opType),t.attribute&&t.attribute.length)for(n.attribute=[],r=0;r<t.attribute.length;++r)n.attribute[r]=l.onnx.AttributeProto.toObject(t.attribute[r],e);return null!=t.docString&&t.hasOwnProperty(\"docString\")&&(n.docString=t.docString),null!=t.domain&&t.hasOwnProperty(\"domain\")&&(n.domain=t.domain),n},t.prototype.toJSON=function(){return this.constructor.toObject(this,a.util.toJSONOptions)},t}(),o.ModelProto=function(){function t(t){if(this.opsetImport=[],this.metadataProps=[],t)for(var e=Object.keys(t),n=0;n<e.length;++n)null!=t[e[n]]&&(this[e[n]]=t[e[n]])}return t.prototype.irVersion=c.Long?c.Long.fromBits(0,0,!1):0,t.prototype.opsetImport=c.emptyArray,t.prototype.producerName=\"\",t.prototype.producerVersion=\"\",t.prototype.domain=\"\",t.prototype.modelVersion=c.Long?c.Long.fromBits(0,0,!1):0,t.prototype.docString=\"\",t.prototype.graph=null,t.prototype.metadataProps=c.emptyArray,t.create=function(e){return new t(e)},t.encode=function(t,e){if(e||(e=u.create()),null!=t.irVersion&&t.hasOwnProperty(\"irVersion\")&&e.uint32(8).int64(t.irVersion),null!=t.producerName&&t.hasOwnProperty(\"producerName\")&&e.uint32(18).string(t.producerName),null!=t.producerVersion&&t.hasOwnProperty(\"producerVersion\")&&e.uint32(26).string(t.producerVersion),null!=t.domain&&t.hasOwnProperty(\"domain\")&&e.uint32(34).string(t.domain),null!=t.modelVersion&&t.hasOwnProperty(\"modelVersion\")&&e.uint32(40).int64(t.modelVersion),null!=t.docString&&t.hasOwnProperty(\"docString\")&&e.uint32(50).string(t.docString),null!=t.graph&&t.hasOwnProperty(\"graph\")&&l.onnx.GraphProto.encode(t.graph,e.uint32(58).fork()).ldelim(),null!=t.opsetImport&&t.opsetImport.length)for(var n=0;n<t.opsetImport.length;++n)l.onnx.OperatorSetIdProto.encode(t.opsetImport[n],e.uint32(66).fork()).ldelim();if(null!=t.metadataProps&&t.metadataProps.length)for(n=0;n<t.metadataProps.length;++n)l.onnx.StringStringEntryProto.encode(t.metadataProps[n],e.uint32(114).fork()).ldelim();return e},t.encodeDelimited=function(t,e){return this.encode(t,e).ldelim()},t.decode=function(t,e){t instanceof s||(t=s.create(t));for(var n=void 0===e?t.len:t.pos+e,r=new l.onnx.ModelProto;t.pos<n;){var i=t.uint32();switch(i>>>3){case 1:r.irVersion=t.int64();break;case 8:r.opsetImport&&r.opsetImport.length||(r.opsetImport=[]),r.opsetImport.push(l.onnx.OperatorSetIdProto.decode(t,t.uint32()));break;case 2:r.producerName=t.string();break;case 3:r.producerVersion=t.string();break;case 4:r.domain=t.string();break;case 5:r.modelVersion=t.int64();break;case 6:r.docString=t.string();break;case 7:r.graph=l.onnx.GraphProto.decode(t,t.uint32());break;case 14:r.metadataProps&&r.metadataProps.length||(r.metadataProps=[]),r.metadataProps.push(l.onnx.StringStringEntryProto.decode(t,t.uint32()));break;default:t.skipType(7&i)}}return r},t.decodeDelimited=function(t){return t instanceof s||(t=new s(t)),this.decode(t,t.uint32())},t.verify=function(t){if(\"object\"!=typeof t||null===t)return\"object expected\";if(null!=t.irVersion&&t.hasOwnProperty(\"irVersion\")&&!(c.isInteger(t.irVersion)||t.irVersion&&c.isInteger(t.irVersion.low)&&c.isInteger(t.irVersion.high)))return\"irVersion: integer|Long expected\";if(null!=t.opsetImport&&t.hasOwnProperty(\"opsetImport\")){if(!Array.isArray(t.opsetImport))return\"opsetImport: array expected\";for(var e=0;e<t.opsetImport.length;++e)if(n=l.onnx.OperatorSetIdProto.verify(t.opsetImport[e]))return\"opsetImport.\"+n}if(null!=t.producerName&&t.hasOwnProperty(\"producerName\")&&!c.isString(t.producerName))return\"producerName: string expected\";if(null!=t.producerVersion&&t.hasOwnProperty(\"producerVersion\")&&!c.isString(t.producerVersion))return\"producerVersion: string expected\";if(null!=t.domain&&t.hasOwnProperty(\"domain\")&&!c.isString(t.domain))return\"domain: string expected\";if(null!=t.modelVersion&&t.hasOwnProperty(\"modelVersion\")&&!(c.isInteger(t.modelVersion)||t.modelVersion&&c.isInteger(t.modelVersion.low)&&c.isInteger(t.modelVersion.high)))return\"modelVersion: integer|Long expected\";if(null!=t.docString&&t.hasOwnProperty(\"docString\")&&!c.isString(t.docString))return\"docString: string expected\";if(null!=t.graph&&t.hasOwnProperty(\"graph\")&&(n=l.onnx.GraphProto.verify(t.graph)))return\"graph.\"+n;if(null!=t.metadataProps&&t.hasOwnProperty(\"metadataProps\")){if(!Array.isArray(t.metadataProps))return\"metadataProps: array expected\";for(e=0;e<t.metadataProps.length;++e){var n;if(n=l.onnx.StringStringEntryProto.verify(t.metadataProps[e]))return\"metadataProps.\"+n}}return null},t.fromObject=function(t){if(t instanceof l.onnx.ModelProto)return t;var e=new l.onnx.ModelProto;if(null!=t.irVersion&&(c.Long?(e.irVersion=c.Long.fromValue(t.irVersion)).unsigned=!1:\"string\"==typeof t.irVersion?e.irVersion=parseInt(t.irVersion,10):\"number\"==typeof t.irVersion?e.irVersion=t.irVersion:\"object\"==typeof t.irVersion&&(e.irVersion=new c.LongBits(t.irVersion.low>>>0,t.irVersion.high>>>0).toNumber())),t.opsetImport){if(!Array.isArray(t.opsetImport))throw TypeError(\".onnx.ModelProto.opsetImport: array expected\");e.opsetImport=[];for(var n=0;n<t.opsetImport.length;++n){if(\"object\"!=typeof t.opsetImport[n])throw TypeError(\".onnx.ModelProto.opsetImport: object expected\");e.opsetImport[n]=l.onnx.OperatorSetIdProto.fromObject(t.opsetImport[n])}}if(null!=t.producerName&&(e.producerName=String(t.producerName)),null!=t.producerVersion&&(e.producerVersion=String(t.producerVersion)),null!=t.domain&&(e.domain=String(t.domain)),null!=t.modelVersion&&(c.Long?(e.modelVersion=c.Long.fromValue(t.modelVersion)).unsigned=!1:\"string\"==typeof t.modelVersion?e.modelVersion=parseInt(t.modelVersion,10):\"number\"==typeof t.modelVersion?e.modelVersion=t.modelVersion:\"object\"==typeof t.modelVersion&&(e.modelVersion=new c.LongBits(t.modelVersion.low>>>0,t.modelVersion.high>>>0).toNumber())),null!=t.docString&&(e.docString=String(t.docString)),null!=t.graph){if(\"object\"!=typeof t.graph)throw TypeError(\".onnx.ModelProto.graph: object expected\");e.graph=l.onnx.GraphProto.fromObject(t.graph)}if(t.metadataProps){if(!Array.isArray(t.metadataProps))throw TypeError(\".onnx.ModelProto.metadataProps: array expected\");for(e.metadataProps=[],n=0;n<t.metadataProps.length;++n){if(\"object\"!=typeof t.metadataProps[n])throw TypeError(\".onnx.ModelProto.metadataProps: object expected\");e.metadataProps[n]=l.onnx.StringStringEntryProto.fromObject(t.metadataProps[n])}}return e},t.toObject=function(t,e){e||(e={});var n={};if((e.arrays||e.defaults)&&(n.opsetImport=[],n.metadataProps=[]),e.defaults){if(c.Long){var r=new c.Long(0,0,!1);n.irVersion=e.longs===String?r.toString():e.longs===Number?r.toNumber():r}else n.irVersion=e.longs===String?\"0\":0;n.producerName=\"\",n.producerVersion=\"\",n.domain=\"\",c.Long?(r=new c.Long(0,0,!1),n.modelVersion=e.longs===String?r.toString():e.longs===Number?r.toNumber():r):n.modelVersion=e.longs===String?\"0\":0,n.docString=\"\",n.graph=null}if(null!=t.irVersion&&t.hasOwnProperty(\"irVersion\")&&(\"number\"==typeof t.irVersion?n.irVersion=e.longs===String?String(t.irVersion):t.irVersion:n.irVersion=e.longs===String?c.Long.prototype.toString.call(t.irVersion):e.longs===Number?new c.LongBits(t.irVersion.low>>>0,t.irVersion.high>>>0).toNumber():t.irVersion),null!=t.producerName&&t.hasOwnProperty(\"producerName\")&&(n.producerName=t.producerName),null!=t.producerVersion&&t.hasOwnProperty(\"producerVersion\")&&(n.producerVersion=t.producerVersion),null!=t.domain&&t.hasOwnProperty(\"domain\")&&(n.domain=t.domain),null!=t.modelVersion&&t.hasOwnProperty(\"modelVersion\")&&(\"number\"==typeof t.modelVersion?n.modelVersion=e.longs===String?String(t.modelVersion):t.modelVersion:n.modelVersion=e.longs===String?c.Long.prototype.toString.call(t.modelVersion):e.longs===Number?new c.LongBits(t.modelVersion.low>>>0,t.modelVersion.high>>>0).toNumber():t.modelVersion),null!=t.docString&&t.hasOwnProperty(\"docString\")&&(n.docString=t.docString),null!=t.graph&&t.hasOwnProperty(\"graph\")&&(n.graph=l.onnx.GraphProto.toObject(t.graph,e)),t.opsetImport&&t.opsetImport.length){n.opsetImport=[];for(var i=0;i<t.opsetImport.length;++i)n.opsetImport[i]=l.onnx.OperatorSetIdProto.toObject(t.opsetImport[i],e)}if(t.metadataProps&&t.metadataProps.length)for(n.metadataProps=[],i=0;i<t.metadataProps.length;++i)n.metadataProps[i]=l.onnx.StringStringEntryProto.toObject(t.metadataProps[i],e);return n},t.prototype.toJSON=function(){return this.constructor.toObject(this,a.util.toJSONOptions)},t}(),o.StringStringEntryProto=function(){function t(t){if(t)for(var e=Object.keys(t),n=0;n<e.length;++n)null!=t[e[n]]&&(this[e[n]]=t[e[n]])}return t.prototype.key=\"\",t.prototype.value=\"\",t.create=function(e){return new t(e)},t.encode=function(t,e){return e||(e=u.create()),null!=t.key&&t.hasOwnProperty(\"key\")&&e.uint32(10).string(t.key),null!=t.value&&t.hasOwnProperty(\"value\")&&e.uint32(18).string(t.value),e},t.encodeDelimited=function(t,e){return this.encode(t,e).ldelim()},t.decode=function(t,e){t instanceof s||(t=s.create(t));for(var n=void 0===e?t.len:t.pos+e,r=new l.onnx.StringStringEntryProto;t.pos<n;){var i=t.uint32();switch(i>>>3){case 1:r.key=t.string();break;case 2:r.value=t.string();break;default:t.skipType(7&i)}}return r},t.decodeDelimited=function(t){return t instanceof s||(t=new s(t)),this.decode(t,t.uint32())},t.verify=function(t){return\"object\"!=typeof t||null===t?\"object expected\":null!=t.key&&t.hasOwnProperty(\"key\")&&!c.isString(t.key)?\"key: string expected\":null!=t.value&&t.hasOwnProperty(\"value\")&&!c.isString(t.value)?\"value: string expected\":null},t.fromObject=function(t){if(t instanceof l.onnx.StringStringEntryProto)return t;var e=new l.onnx.StringStringEntryProto;return null!=t.key&&(e.key=String(t.key)),null!=t.value&&(e.value=String(t.value)),e},t.toObject=function(t,e){e||(e={});var n={};return e.defaults&&(n.key=\"\",n.value=\"\"),null!=t.key&&t.hasOwnProperty(\"key\")&&(n.key=t.key),null!=t.value&&t.hasOwnProperty(\"value\")&&(n.value=t.value),n},t.prototype.toJSON=function(){return this.constructor.toObject(this,a.util.toJSONOptions)},t}(),o.TensorAnnotation=function(){function t(t){if(this.quantParameterTensorNames=[],t)for(var e=Object.keys(t),n=0;n<e.length;++n)null!=t[e[n]]&&(this[e[n]]=t[e[n]])}return t.prototype.tensorName=\"\",t.prototype.quantParameterTensorNames=c.emptyArray,t.create=function(e){return new t(e)},t.encode=function(t,e){if(e||(e=u.create()),null!=t.tensorName&&t.hasOwnProperty(\"tensorName\")&&e.uint32(10).string(t.tensorName),null!=t.quantParameterTensorNames&&t.quantParameterTensorNames.length)for(var n=0;n<t.quantParameterTensorNames.length;++n)l.onnx.StringStringEntryProto.encode(t.quantParameterTensorNames[n],e.uint32(18).fork()).ldelim();return e},t.encodeDelimited=function(t,e){return this.encode(t,e).ldelim()},t.decode=function(t,e){t instanceof s||(t=s.create(t));for(var n=void 0===e?t.len:t.pos+e,r=new l.onnx.TensorAnnotation;t.pos<n;){var i=t.uint32();switch(i>>>3){case 1:r.tensorName=t.string();break;case 2:r.quantParameterTensorNames&&r.quantParameterTensorNames.length||(r.quantParameterTensorNames=[]),r.quantParameterTensorNames.push(l.onnx.StringStringEntryProto.decode(t,t.uint32()));break;default:t.skipType(7&i)}}return r},t.decodeDelimited=function(t){return t instanceof s||(t=new s(t)),this.decode(t,t.uint32())},t.verify=function(t){if(\"object\"!=typeof t||null===t)return\"object expected\";if(null!=t.tensorName&&t.hasOwnProperty(\"tensorName\")&&!c.isString(t.tensorName))return\"tensorName: string expected\";if(null!=t.quantParameterTensorNames&&t.hasOwnProperty(\"quantParameterTensorNames\")){if(!Array.isArray(t.quantParameterTensorNames))return\"quantParameterTensorNames: array expected\";for(var e=0;e<t.quantParameterTensorNames.length;++e){var n=l.onnx.StringStringEntryProto.verify(t.quantParameterTensorNames[e]);if(n)return\"quantParameterTensorNames.\"+n}}return null},t.fromObject=function(t){if(t instanceof l.onnx.TensorAnnotation)return t;var e=new l.onnx.TensorAnnotation;if(null!=t.tensorName&&(e.tensorName=String(t.tensorName)),t.quantParameterTensorNames){if(!Array.isArray(t.quantParameterTensorNames))throw TypeError(\".onnx.TensorAnnotation.quantParameterTensorNames: array expected\");e.quantParameterTensorNames=[];for(var n=0;n<t.quantParameterTensorNames.length;++n){if(\"object\"!=typeof t.quantParameterTensorNames[n])throw TypeError(\".onnx.TensorAnnotation.quantParameterTensorNames: object expected\");e.quantParameterTensorNames[n]=l.onnx.StringStringEntryProto.fromObject(t.quantParameterTensorNames[n])}}return e},t.toObject=function(t,e){e||(e={});var n={};if((e.arrays||e.defaults)&&(n.quantParameterTensorNames=[]),e.defaults&&(n.tensorName=\"\"),null!=t.tensorName&&t.hasOwnProperty(\"tensorName\")&&(n.tensorName=t.tensorName),t.quantParameterTensorNames&&t.quantParameterTensorNames.length){n.quantParameterTensorNames=[];for(var r=0;r<t.quantParameterTensorNames.length;++r)n.quantParameterTensorNames[r]=l.onnx.StringStringEntryProto.toObject(t.quantParameterTensorNames[r],e)}return n},t.prototype.toJSON=function(){return this.constructor.toObject(this,a.util.toJSONOptions)},t}(),o.GraphProto=function(){function t(t){if(this.node=[],this.initializer=[],this.input=[],this.output=[],this.valueInfo=[],this.quantizationAnnotation=[],t)for(var e=Object.keys(t),n=0;n<e.length;++n)null!=t[e[n]]&&(this[e[n]]=t[e[n]])}return t.prototype.node=c.emptyArray,t.prototype.name=\"\",t.prototype.initializer=c.emptyArray,t.prototype.docString=\"\",t.prototype.input=c.emptyArray,t.prototype.output=c.emptyArray,t.prototype.valueInfo=c.emptyArray,t.prototype.quantizationAnnotation=c.emptyArray,t.create=function(e){return new t(e)},t.encode=function(t,e){if(e||(e=u.create()),null!=t.node&&t.node.length)for(var n=0;n<t.node.length;++n)l.onnx.NodeProto.encode(t.node[n],e.uint32(10).fork()).ldelim();if(null!=t.name&&t.hasOwnProperty(\"name\")&&e.uint32(18).string(t.name),null!=t.initializer&&t.initializer.length)for(n=0;n<t.initializer.length;++n)l.onnx.TensorProto.encode(t.initializer[n],e.uint32(42).fork()).ldelim();if(null!=t.docString&&t.hasOwnProperty(\"docString\")&&e.uint32(82).string(t.docString),null!=t.input&&t.input.length)for(n=0;n<t.input.length;++n)l.onnx.ValueInfoProto.encode(t.input[n],e.uint32(90).fork()).ldelim();if(null!=t.output&&t.output.length)for(n=0;n<t.output.length;++n)l.onnx.ValueInfoProto.encode(t.output[n],e.uint32(98).fork()).ldelim();if(null!=t.valueInfo&&t.valueInfo.length)for(n=0;n<t.valueInfo.length;++n)l.onnx.ValueInfoProto.encode(t.valueInfo[n],e.uint32(106).fork()).ldelim();if(null!=t.quantizationAnnotation&&t.quantizationAnnotation.length)for(n=0;n<t.quantizationAnnotation.length;++n)l.onnx.TensorAnnotation.encode(t.quantizationAnnotation[n],e.uint32(114).fork()).ldelim();return e},t.encodeDelimited=function(t,e){return this.encode(t,e).ldelim()},t.decode=function(t,e){t instanceof s||(t=s.create(t));for(var n=void 0===e?t.len:t.pos+e,r=new l.onnx.GraphProto;t.pos<n;){var i=t.uint32();switch(i>>>3){case 1:r.node&&r.node.length||(r.node=[]),r.node.push(l.onnx.NodeProto.decode(t,t.uint32()));break;case 2:r.name=t.string();break;case 5:r.initializer&&r.initializer.length||(r.initializer=[]),r.initializer.push(l.onnx.TensorProto.decode(t,t.uint32()));break;case 10:r.docString=t.string();break;case 11:r.input&&r.input.length||(r.input=[]),r.input.push(l.onnx.ValueInfoProto.decode(t,t.uint32()));break;case 12:r.output&&r.output.length||(r.output=[]),r.output.push(l.onnx.ValueInfoProto.decode(t,t.uint32()));break;case 13:r.valueInfo&&r.valueInfo.length||(r.valueInfo=[]),r.valueInfo.push(l.onnx.ValueInfoProto.decode(t,t.uint32()));break;case 14:r.quantizationAnnotation&&r.quantizationAnnotation.length||(r.quantizationAnnotation=[]),r.quantizationAnnotation.push(l.onnx.TensorAnnotation.decode(t,t.uint32()));break;default:t.skipType(7&i)}}return r},t.decodeDelimited=function(t){return t instanceof s||(t=new s(t)),this.decode(t,t.uint32())},t.verify=function(t){if(\"object\"!=typeof t||null===t)return\"object expected\";if(null!=t.node&&t.hasOwnProperty(\"node\")){if(!Array.isArray(t.node))return\"node: array expected\";for(var e=0;e<t.node.length;++e)if(n=l.onnx.NodeProto.verify(t.node[e]))return\"node.\"+n}if(null!=t.name&&t.hasOwnProperty(\"name\")&&!c.isString(t.name))return\"name: string expected\";if(null!=t.initializer&&t.hasOwnProperty(\"initializer\")){if(!Array.isArray(t.initializer))return\"initializer: array expected\";for(e=0;e<t.initializer.length;++e)if(n=l.onnx.TensorProto.verify(t.initializer[e]))return\"initializer.\"+n}if(null!=t.docString&&t.hasOwnProperty(\"docString\")&&!c.isString(t.docString))return\"docString: string expected\";if(null!=t.input&&t.hasOwnProperty(\"input\")){if(!Array.isArray(t.input))return\"input: array expected\";for(e=0;e<t.input.length;++e)if(n=l.onnx.ValueInfoProto.verify(t.input[e]))return\"input.\"+n}if(null!=t.output&&t.hasOwnProperty(\"output\")){if(!Array.isArray(t.output))return\"output: array expected\";for(e=0;e<t.output.length;++e)if(n=l.onnx.ValueInfoProto.verify(t.output[e]))return\"output.\"+n}if(null!=t.valueInfo&&t.hasOwnProperty(\"valueInfo\")){if(!Array.isArray(t.valueInfo))return\"valueInfo: array expected\";for(e=0;e<t.valueInfo.length;++e)if(n=l.onnx.ValueInfoProto.verify(t.valueInfo[e]))return\"valueInfo.\"+n}if(null!=t.quantizationAnnotation&&t.hasOwnProperty(\"quantizationAnnotation\")){if(!Array.isArray(t.quantizationAnnotation))return\"quantizationAnnotation: array expected\";for(e=0;e<t.quantizationAnnotation.length;++e){var n;if(n=l.onnx.TensorAnnotation.verify(t.quantizationAnnotation[e]))return\"quantizationAnnotation.\"+n}}return null},t.fromObject=function(t){if(t instanceof l.onnx.GraphProto)return t;var e=new l.onnx.GraphProto;if(t.node){if(!Array.isArray(t.node))throw TypeError(\".onnx.GraphProto.node: array expected\");e.node=[];for(var n=0;n<t.node.length;++n){if(\"object\"!=typeof t.node[n])throw TypeError(\".onnx.GraphProto.node: object expected\");e.node[n]=l.onnx.NodeProto.fromObject(t.node[n])}}if(null!=t.name&&(e.name=String(t.name)),t.initializer){if(!Array.isArray(t.initializer))throw TypeError(\".onnx.GraphProto.initializer: array expected\");for(e.initializer=[],n=0;n<t.initializer.length;++n){if(\"object\"!=typeof t.initializer[n])throw TypeError(\".onnx.GraphProto.initializer: object expected\");e.initializer[n]=l.onnx.TensorProto.fromObject(t.initializer[n])}}if(null!=t.docString&&(e.docString=String(t.docString)),t.input){if(!Array.isArray(t.input))throw TypeError(\".onnx.GraphProto.input: array expected\");for(e.input=[],n=0;n<t.input.length;++n){if(\"object\"!=typeof t.input[n])throw TypeError(\".onnx.GraphProto.input: object expected\");e.input[n]=l.onnx.ValueInfoProto.fromObject(t.input[n])}}if(t.output){if(!Array.isArray(t.output))throw TypeError(\".onnx.GraphProto.output: array expected\");for(e.output=[],n=0;n<t.output.length;++n){if(\"object\"!=typeof t.output[n])throw TypeError(\".onnx.GraphProto.output: object expected\");e.output[n]=l.onnx.ValueInfoProto.fromObject(t.output[n])}}if(t.valueInfo){if(!Array.isArray(t.valueInfo))throw TypeError(\".onnx.GraphProto.valueInfo: array expected\");for(e.valueInfo=[],n=0;n<t.valueInfo.length;++n){if(\"object\"!=typeof t.valueInfo[n])throw TypeError(\".onnx.GraphProto.valueInfo: object expected\");e.valueInfo[n]=l.onnx.ValueInfoProto.fromObject(t.valueInfo[n])}}if(t.quantizationAnnotation){if(!Array.isArray(t.quantizationAnnotation))throw TypeError(\".onnx.GraphProto.quantizationAnnotation: array expected\");for(e.quantizationAnnotation=[],n=0;n<t.quantizationAnnotation.length;++n){if(\"object\"!=typeof t.quantizationAnnotation[n])throw TypeError(\".onnx.GraphProto.quantizationAnnotation: object expected\");e.quantizationAnnotation[n]=l.onnx.TensorAnnotation.fromObject(t.quantizationAnnotation[n])}}return e},t.toObject=function(t,e){e||(e={});var n={};if((e.arrays||e.defaults)&&(n.node=[],n.initializer=[],n.input=[],n.output=[],n.valueInfo=[],n.quantizationAnnotation=[]),e.defaults&&(n.name=\"\",n.docString=\"\"),t.node&&t.node.length){n.node=[];for(var r=0;r<t.node.length;++r)n.node[r]=l.onnx.NodeProto.toObject(t.node[r],e)}if(null!=t.name&&t.hasOwnProperty(\"name\")&&(n.name=t.name),t.initializer&&t.initializer.length)for(n.initializer=[],r=0;r<t.initializer.length;++r)n.initializer[r]=l.onnx.TensorProto.toObject(t.initializer[r],e);if(null!=t.docString&&t.hasOwnProperty(\"docString\")&&(n.docString=t.docString),t.input&&t.input.length)for(n.input=[],r=0;r<t.input.length;++r)n.input[r]=l.onnx.ValueInfoProto.toObject(t.input[r],e);if(t.output&&t.output.length)for(n.output=[],r=0;r<t.output.length;++r)n.output[r]=l.onnx.ValueInfoProto.toObject(t.output[r],e);if(t.valueInfo&&t.valueInfo.length)for(n.valueInfo=[],r=0;r<t.valueInfo.length;++r)n.valueInfo[r]=l.onnx.ValueInfoProto.toObject(t.valueInfo[r],e);if(t.quantizationAnnotation&&t.quantizationAnnotation.length)for(n.quantizationAnnotation=[],r=0;r<t.quantizationAnnotation.length;++r)n.quantizationAnnotation[r]=l.onnx.TensorAnnotation.toObject(t.quantizationAnnotation[r],e);return n},t.prototype.toJSON=function(){return this.constructor.toObject(this,a.util.toJSONOptions)},t}(),o.TensorProto=function(){function t(t){if(this.dims=[],this.floatData=[],this.int32Data=[],this.stringData=[],this.int64Data=[],this.externalData=[],this.doubleData=[],this.uint64Data=[],t)for(var e=Object.keys(t),n=0;n<e.length;++n)null!=t[e[n]]&&(this[e[n]]=t[e[n]])}return t.prototype.dims=c.emptyArray,t.prototype.dataType=0,t.prototype.segment=null,t.prototype.floatData=c.emptyArray,t.prototype.int32Data=c.emptyArray,t.prototype.stringData=c.emptyArray,t.prototype.int64Data=c.emptyArray,t.prototype.name=\"\",t.prototype.docString=\"\",t.prototype.rawData=c.newBuffer([]),t.prototype.externalData=c.emptyArray,t.prototype.dataLocation=0,t.prototype.doubleData=c.emptyArray,t.prototype.uint64Data=c.emptyArray,t.create=function(e){return new t(e)},t.encode=function(t,e){if(e||(e=u.create()),null!=t.dims&&t.dims.length){e.uint32(10).fork();for(var n=0;n<t.dims.length;++n)e.int64(t.dims[n]);e.ldelim()}if(null!=t.dataType&&t.hasOwnProperty(\"dataType\")&&e.uint32(16).int32(t.dataType),null!=t.segment&&t.hasOwnProperty(\"segment\")&&l.onnx.TensorProto.Segment.encode(t.segment,e.uint32(26).fork()).ldelim(),null!=t.floatData&&t.floatData.length){for(e.uint32(34).fork(),n=0;n<t.floatData.length;++n)e.float(t.floatData[n]);e.ldelim()}if(null!=t.int32Data&&t.int32Data.length){for(e.uint32(42).fork(),n=0;n<t.int32Data.length;++n)e.int32(t.int32Data[n]);e.ldelim()}if(null!=t.stringData&&t.stringData.length)for(n=0;n<t.stringData.length;++n)e.uint32(50).bytes(t.stringData[n]);if(null!=t.int64Data&&t.int64Data.length){for(e.uint32(58).fork(),n=0;n<t.int64Data.length;++n)e.int64(t.int64Data[n]);e.ldelim()}if(null!=t.name&&t.hasOwnProperty(\"name\")&&e.uint32(66).string(t.name),null!=t.rawData&&t.hasOwnProperty(\"rawData\")&&e.uint32(74).bytes(t.rawData),null!=t.doubleData&&t.doubleData.length){for(e.uint32(82).fork(),n=0;n<t.doubleData.length;++n)e.double(t.doubleData[n]);e.ldelim()}if(null!=t.uint64Data&&t.uint64Data.length){for(e.uint32(90).fork(),n=0;n<t.uint64Data.length;++n)e.uint64(t.uint64Data[n]);e.ldelim()}if(null!=t.docString&&t.hasOwnProperty(\"docString\")&&e.uint32(98).string(t.docString),null!=t.externalData&&t.externalData.length)for(n=0;n<t.externalData.length;++n)l.onnx.StringStringEntryProto.encode(t.externalData[n],e.uint32(106).fork()).ldelim();return null!=t.dataLocation&&t.hasOwnProperty(\"dataLocation\")&&e.uint32(112).int32(t.dataLocation),e},t.encodeDelimited=function(t,e){return this.encode(t,e).ldelim()},t.decode=function(t,e){t instanceof s||(t=s.create(t));for(var n=void 0===e?t.len:t.pos+e,r=new l.onnx.TensorProto;t.pos<n;){var i=t.uint32();switch(i>>>3){case 1:if(r.dims&&r.dims.length||(r.dims=[]),2==(7&i))for(var o=t.uint32()+t.pos;t.pos<o;)r.dims.push(t.int64());else r.dims.push(t.int64());break;case 2:r.dataType=t.int32();break;case 3:r.segment=l.onnx.TensorProto.Segment.decode(t,t.uint32());break;case 4:if(r.floatData&&r.floatData.length||(r.floatData=[]),2==(7&i))for(o=t.uint32()+t.pos;t.pos<o;)r.floatData.push(t.float());else r.floatData.push(t.float());break;case 5:if(r.int32Data&&r.int32Data.length||(r.int32Data=[]),2==(7&i))for(o=t.uint32()+t.pos;t.pos<o;)r.int32Data.push(t.int32());else r.int32Data.push(t.int32());break;case 6:r.stringData&&r.stringData.length||(r.stringData=[]),r.stringData.push(t.bytes());break;case 7:if(r.int64Data&&r.int64Data.length||(r.int64Data=[]),2==(7&i))for(o=t.uint32()+t.pos;t.pos<o;)r.int64Data.push(t.int64());else r.int64Data.push(t.int64());break;case 8:r.name=t.string();break;case 12:r.docString=t.string();break;case 9:r.rawData=t.bytes();break;case 13:r.externalData&&r.externalData.length||(r.externalData=[]),r.externalData.push(l.onnx.StringStringEntryProto.decode(t,t.uint32()));break;case 14:r.dataLocation=t.int32();break;case 10:if(r.doubleData&&r.doubleData.length||(r.doubleData=[]),2==(7&i))for(o=t.uint32()+t.pos;t.pos<o;)r.doubleData.push(t.double());else r.doubleData.push(t.double());break;case 11:if(r.uint64Data&&r.uint64Data.length||(r.uint64Data=[]),2==(7&i))for(o=t.uint32()+t.pos;t.pos<o;)r.uint64Data.push(t.uint64());else r.uint64Data.push(t.uint64());break;default:t.skipType(7&i)}}return r},t.decodeDelimited=function(t){return t instanceof s||(t=new s(t)),this.decode(t,t.uint32())},t.verify=function(t){if(\"object\"!=typeof t||null===t)return\"object expected\";if(null!=t.dims&&t.hasOwnProperty(\"dims\")){if(!Array.isArray(t.dims))return\"dims: array expected\";for(var e=0;e<t.dims.length;++e)if(!(c.isInteger(t.dims[e])||t.dims[e]&&c.isInteger(t.dims[e].low)&&c.isInteger(t.dims[e].high)))return\"dims: integer|Long[] expected\"}if(null!=t.dataType&&t.hasOwnProperty(\"dataType\")&&!c.isInteger(t.dataType))return\"dataType: integer expected\";if(null!=t.segment&&t.hasOwnProperty(\"segment\")&&(n=l.onnx.TensorProto.Segment.verify(t.segment)))return\"segment.\"+n;if(null!=t.floatData&&t.hasOwnProperty(\"floatData\")){if(!Array.isArray(t.floatData))return\"floatData: array expected\";for(e=0;e<t.floatData.length;++e)if(\"number\"!=typeof t.floatData[e])return\"floatData: number[] expected\"}if(null!=t.int32Data&&t.hasOwnProperty(\"int32Data\")){if(!Array.isArray(t.int32Data))return\"int32Data: array expected\";for(e=0;e<t.int32Data.length;++e)if(!c.isInteger(t.int32Data[e]))return\"int32Data: integer[] expected\"}if(null!=t.stringData&&t.hasOwnProperty(\"stringData\")){if(!Array.isArray(t.stringData))return\"stringData: array expected\";for(e=0;e<t.stringData.length;++e)if(!(t.stringData[e]&&\"number\"==typeof t.stringData[e].length||c.isString(t.stringData[e])))return\"stringData: buffer[] expected\"}if(null!=t.int64Data&&t.hasOwnProperty(\"int64Data\")){if(!Array.isArray(t.int64Data))return\"int64Data: array expected\";for(e=0;e<t.int64Data.length;++e)if(!(c.isInteger(t.int64Data[e])||t.int64Data[e]&&c.isInteger(t.int64Data[e].low)&&c.isInteger(t.int64Data[e].high)))return\"int64Data: integer|Long[] expected\"}if(null!=t.name&&t.hasOwnProperty(\"name\")&&!c.isString(t.name))return\"name: string expected\";if(null!=t.docString&&t.hasOwnProperty(\"docString\")&&!c.isString(t.docString))return\"docString: string expected\";if(null!=t.rawData&&t.hasOwnProperty(\"rawData\")&&!(t.rawData&&\"number\"==typeof t.rawData.length||c.isString(t.rawData)))return\"rawData: buffer expected\";if(null!=t.externalData&&t.hasOwnProperty(\"externalData\")){if(!Array.isArray(t.externalData))return\"externalData: array expected\";for(e=0;e<t.externalData.length;++e){var n;if(n=l.onnx.StringStringEntryProto.verify(t.externalData[e]))return\"externalData.\"+n}}if(null!=t.dataLocation&&t.hasOwnProperty(\"dataLocation\"))switch(t.dataLocation){default:return\"dataLocation: enum value expected\";case 0:case 1:}if(null!=t.doubleData&&t.hasOwnProperty(\"doubleData\")){if(!Array.isArray(t.doubleData))return\"doubleData: array expected\";for(e=0;e<t.doubleData.length;++e)if(\"number\"!=typeof t.doubleData[e])return\"doubleData: number[] expected\"}if(null!=t.uint64Data&&t.hasOwnProperty(\"uint64Data\")){if(!Array.isArray(t.uint64Data))return\"uint64Data: array expected\";for(e=0;e<t.uint64Data.length;++e)if(!(c.isInteger(t.uint64Data[e])||t.uint64Data[e]&&c.isInteger(t.uint64Data[e].low)&&c.isInteger(t.uint64Data[e].high)))return\"uint64Data: integer|Long[] expected\"}return null},t.fromObject=function(t){if(t instanceof l.onnx.TensorProto)return t;var e=new l.onnx.TensorProto;if(t.dims){if(!Array.isArray(t.dims))throw TypeError(\".onnx.TensorProto.dims: array expected\");e.dims=[];for(var n=0;n<t.dims.length;++n)c.Long?(e.dims[n]=c.Long.fromValue(t.dims[n])).unsigned=!1:\"string\"==typeof t.dims[n]?e.dims[n]=parseInt(t.dims[n],10):\"number\"==typeof t.dims[n]?e.dims[n]=t.dims[n]:\"object\"==typeof t.dims[n]&&(e.dims[n]=new c.LongBits(t.dims[n].low>>>0,t.dims[n].high>>>0).toNumber())}if(null!=t.dataType&&(e.dataType=0|t.dataType),null!=t.segment){if(\"object\"!=typeof t.segment)throw TypeError(\".onnx.TensorProto.segment: object expected\");e.segment=l.onnx.TensorProto.Segment.fromObject(t.segment)}if(t.floatData){if(!Array.isArray(t.floatData))throw TypeError(\".onnx.TensorProto.floatData: array expected\");for(e.floatData=[],n=0;n<t.floatData.length;++n)e.floatData[n]=Number(t.floatData[n])}if(t.int32Data){if(!Array.isArray(t.int32Data))throw TypeError(\".onnx.TensorProto.int32Data: array expected\");for(e.int32Data=[],n=0;n<t.int32Data.length;++n)e.int32Data[n]=0|t.int32Data[n]}if(t.stringData){if(!Array.isArray(t.stringData))throw TypeError(\".onnx.TensorProto.stringData: array expected\");for(e.stringData=[],n=0;n<t.stringData.length;++n)\"string\"==typeof t.stringData[n]?c.base64.decode(t.stringData[n],e.stringData[n]=c.newBuffer(c.base64.length(t.stringData[n])),0):t.stringData[n].length&&(e.stringData[n]=t.stringData[n])}if(t.int64Data){if(!Array.isArray(t.int64Data))throw TypeError(\".onnx.TensorProto.int64Data: array expected\");for(e.int64Data=[],n=0;n<t.int64Data.length;++n)c.Long?(e.int64Data[n]=c.Long.fromValue(t.int64Data[n])).unsigned=!1:\"string\"==typeof t.int64Data[n]?e.int64Data[n]=parseInt(t.int64Data[n],10):\"number\"==typeof t.int64Data[n]?e.int64Data[n]=t.int64Data[n]:\"object\"==typeof t.int64Data[n]&&(e.int64Data[n]=new c.LongBits(t.int64Data[n].low>>>0,t.int64Data[n].high>>>0).toNumber())}if(null!=t.name&&(e.name=String(t.name)),null!=t.docString&&(e.docString=String(t.docString)),null!=t.rawData&&(\"string\"==typeof t.rawData?c.base64.decode(t.rawData,e.rawData=c.newBuffer(c.base64.length(t.rawData)),0):t.rawData.length&&(e.rawData=t.rawData)),t.externalData){if(!Array.isArray(t.externalData))throw TypeError(\".onnx.TensorProto.externalData: array expected\");for(e.externalData=[],n=0;n<t.externalData.length;++n){if(\"object\"!=typeof t.externalData[n])throw TypeError(\".onnx.TensorProto.externalData: object expected\");e.externalData[n]=l.onnx.StringStringEntryProto.fromObject(t.externalData[n])}}switch(t.dataLocation){case\"DEFAULT\":case 0:e.dataLocation=0;break;case\"EXTERNAL\":case 1:e.dataLocation=1}if(t.doubleData){if(!Array.isArray(t.doubleData))throw TypeError(\".onnx.TensorProto.doubleData: array expected\");for(e.doubleData=[],n=0;n<t.doubleData.length;++n)e.doubleData[n]=Number(t.doubleData[n])}if(t.uint64Data){if(!Array.isArray(t.uint64Data))throw TypeError(\".onnx.TensorProto.uint64Data: array expected\");for(e.uint64Data=[],n=0;n<t.uint64Data.length;++n)c.Long?(e.uint64Data[n]=c.Long.fromValue(t.uint64Data[n])).unsigned=!0:\"string\"==typeof t.uint64Data[n]?e.uint64Data[n]=parseInt(t.uint64Data[n],10):\"number\"==typeof t.uint64Data[n]?e.uint64Data[n]=t.uint64Data[n]:\"object\"==typeof t.uint64Data[n]&&(e.uint64Data[n]=new c.LongBits(t.uint64Data[n].low>>>0,t.uint64Data[n].high>>>0).toNumber(!0))}return e},t.toObject=function(t,e){e||(e={});var n={};if((e.arrays||e.defaults)&&(n.dims=[],n.floatData=[],n.int32Data=[],n.stringData=[],n.int64Data=[],n.doubleData=[],n.uint64Data=[],n.externalData=[]),e.defaults&&(n.dataType=0,n.segment=null,n.name=\"\",e.bytes===String?n.rawData=\"\":(n.rawData=[],e.bytes!==Array&&(n.rawData=c.newBuffer(n.rawData))),n.docString=\"\",n.dataLocation=e.enums===String?\"DEFAULT\":0),t.dims&&t.dims.length){n.dims=[];for(var r=0;r<t.dims.length;++r)\"number\"==typeof t.dims[r]?n.dims[r]=e.longs===String?String(t.dims[r]):t.dims[r]:n.dims[r]=e.longs===String?c.Long.prototype.toString.call(t.dims[r]):e.longs===Number?new c.LongBits(t.dims[r].low>>>0,t.dims[r].high>>>0).toNumber():t.dims[r]}if(null!=t.dataType&&t.hasOwnProperty(\"dataType\")&&(n.dataType=t.dataType),null!=t.segment&&t.hasOwnProperty(\"segment\")&&(n.segment=l.onnx.TensorProto.Segment.toObject(t.segment,e)),t.floatData&&t.floatData.length)for(n.floatData=[],r=0;r<t.floatData.length;++r)n.floatData[r]=e.json&&!isFinite(t.floatData[r])?String(t.floatData[r]):t.floatData[r];if(t.int32Data&&t.int32Data.length)for(n.int32Data=[],r=0;r<t.int32Data.length;++r)n.int32Data[r]=t.int32Data[r];if(t.stringData&&t.stringData.length)for(n.stringData=[],r=0;r<t.stringData.length;++r)n.stringData[r]=e.bytes===String?c.base64.encode(t.stringData[r],0,t.stringData[r].length):e.bytes===Array?Array.prototype.slice.call(t.stringData[r]):t.stringData[r];if(t.int64Data&&t.int64Data.length)for(n.int64Data=[],r=0;r<t.int64Data.length;++r)\"number\"==typeof t.int64Data[r]?n.int64Data[r]=e.longs===String?String(t.int64Data[r]):t.int64Data[r]:n.int64Data[r]=e.longs===String?c.Long.prototype.toString.call(t.int64Data[r]):e.longs===Number?new c.LongBits(t.int64Data[r].low>>>0,t.int64Data[r].high>>>0).toNumber():t.int64Data[r];if(null!=t.name&&t.hasOwnProperty(\"name\")&&(n.name=t.name),null!=t.rawData&&t.hasOwnProperty(\"rawData\")&&(n.rawData=e.bytes===String?c.base64.encode(t.rawData,0,t.rawData.length):e.bytes===Array?Array.prototype.slice.call(t.rawData):t.rawData),t.doubleData&&t.doubleData.length)for(n.doubleData=[],r=0;r<t.doubleData.length;++r)n.doubleData[r]=e.json&&!isFinite(t.doubleData[r])?String(t.doubleData[r]):t.doubleData[r];if(t.uint64Data&&t.uint64Data.length)for(n.uint64Data=[],r=0;r<t.uint64Data.length;++r)\"number\"==typeof t.uint64Data[r]?n.uint64Data[r]=e.longs===String?String(t.uint64Data[r]):t.uint64Data[r]:n.uint64Data[r]=e.longs===String?c.Long.prototype.toString.call(t.uint64Data[r]):e.longs===Number?new c.LongBits(t.uint64Data[r].low>>>0,t.uint64Data[r].high>>>0).toNumber(!0):t.uint64Data[r];if(null!=t.docString&&t.hasOwnProperty(\"docString\")&&(n.docString=t.docString),t.externalData&&t.externalData.length)for(n.externalData=[],r=0;r<t.externalData.length;++r)n.externalData[r]=l.onnx.StringStringEntryProto.toObject(t.externalData[r],e);return null!=t.dataLocation&&t.hasOwnProperty(\"dataLocation\")&&(n.dataLocation=e.enums===String?l.onnx.TensorProto.DataLocation[t.dataLocation]:t.dataLocation),n},t.prototype.toJSON=function(){return this.constructor.toObject(this,a.util.toJSONOptions)},t.DataType=function(){var t={},e=Object.create(t);return e[t[0]=\"UNDEFINED\"]=0,e[t[1]=\"FLOAT\"]=1,e[t[2]=\"UINT8\"]=2,e[t[3]=\"INT8\"]=3,e[t[4]=\"UINT16\"]=4,e[t[5]=\"INT16\"]=5,e[t[6]=\"INT32\"]=6,e[t[7]=\"INT64\"]=7,e[t[8]=\"STRING\"]=8,e[t[9]=\"BOOL\"]=9,e[t[10]=\"FLOAT16\"]=10,e[t[11]=\"DOUBLE\"]=11,e[t[12]=\"UINT32\"]=12,e[t[13]=\"UINT64\"]=13,e[t[14]=\"COMPLEX64\"]=14,e[t[15]=\"COMPLEX128\"]=15,e[t[16]=\"BFLOAT16\"]=16,e}(),t.Segment=function(){function t(t){if(t)for(var e=Object.keys(t),n=0;n<e.length;++n)null!=t[e[n]]&&(this[e[n]]=t[e[n]])}return t.prototype.begin=c.Long?c.Long.fromBits(0,0,!1):0,t.prototype.end=c.Long?c.Long.fromBits(0,0,!1):0,t.create=function(e){return new t(e)},t.encode=function(t,e){return e||(e=u.create()),null!=t.begin&&t.hasOwnProperty(\"begin\")&&e.uint32(8).int64(t.begin),null!=t.end&&t.hasOwnProperty(\"end\")&&e.uint32(16).int64(t.end),e},t.encodeDelimited=function(t,e){return this.encode(t,e).ldelim()},t.decode=function(t,e){t instanceof s||(t=s.create(t));for(var n=void 0===e?t.len:t.pos+e,r=new l.onnx.TensorProto.Segment;t.pos<n;){var i=t.uint32();switch(i>>>3){case 1:r.begin=t.int64();break;case 2:r.end=t.int64();break;default:t.skipType(7&i)}}return r},t.decodeDelimited=function(t){return t instanceof s||(t=new s(t)),this.decode(t,t.uint32())},t.verify=function(t){return\"object\"!=typeof t||null===t?\"object expected\":null!=t.begin&&t.hasOwnProperty(\"begin\")&&!(c.isInteger(t.begin)||t.begin&&c.isInteger(t.begin.low)&&c.isInteger(t.begin.high))?\"begin: integer|Long expected\":null!=t.end&&t.hasOwnProperty(\"end\")&&!(c.isInteger(t.end)||t.end&&c.isInteger(t.end.low)&&c.isInteger(t.end.high))?\"end: integer|Long expected\":null},t.fromObject=function(t){if(t instanceof l.onnx.TensorProto.Segment)return t;var e=new l.onnx.TensorProto.Segment;return null!=t.begin&&(c.Long?(e.begin=c.Long.fromValue(t.begin)).unsigned=!1:\"string\"==typeof t.begin?e.begin=parseInt(t.begin,10):\"number\"==typeof t.begin?e.begin=t.begin:\"object\"==typeof t.begin&&(e.begin=new c.LongBits(t.begin.low>>>0,t.begin.high>>>0).toNumber())),null!=t.end&&(c.Long?(e.end=c.Long.fromValue(t.end)).unsigned=!1:\"string\"==typeof t.end?e.end=parseInt(t.end,10):\"number\"==typeof t.end?e.end=t.end:\"object\"==typeof t.end&&(e.end=new c.LongBits(t.end.low>>>0,t.end.high>>>0).toNumber())),e},t.toObject=function(t,e){e||(e={});var n={};if(e.defaults){if(c.Long){var r=new c.Long(0,0,!1);n.begin=e.longs===String?r.toString():e.longs===Number?r.toNumber():r}else n.begin=e.longs===String?\"0\":0;c.Long?(r=new c.Long(0,0,!1),n.end=e.longs===String?r.toString():e.longs===Number?r.toNumber():r):n.end=e.longs===String?\"0\":0}return null!=t.begin&&t.hasOwnProperty(\"begin\")&&(\"number\"==typeof t.begin?n.begin=e.longs===String?String(t.begin):t.begin:n.begin=e.longs===String?c.Long.prototype.toString.call(t.begin):e.longs===Number?new c.LongBits(t.begin.low>>>0,t.begin.high>>>0).toNumber():t.begin),null!=t.end&&t.hasOwnProperty(\"end\")&&(\"number\"==typeof t.end?n.end=e.longs===String?String(t.end):t.end:n.end=e.longs===String?c.Long.prototype.toString.call(t.end):e.longs===Number?new c.LongBits(t.end.low>>>0,t.end.high>>>0).toNumber():t.end),n},t.prototype.toJSON=function(){return this.constructor.toObject(this,a.util.toJSONOptions)},t}(),t.DataLocation=function(){var t={},e=Object.create(t);return e[t[0]=\"DEFAULT\"]=0,e[t[1]=\"EXTERNAL\"]=1,e}(),t}(),o.TensorShapeProto=function(){function t(t){if(this.dim=[],t)for(var e=Object.keys(t),n=0;n<e.length;++n)null!=t[e[n]]&&(this[e[n]]=t[e[n]])}return t.prototype.dim=c.emptyArray,t.create=function(e){return new t(e)},t.encode=function(t,e){if(e||(e=u.create()),null!=t.dim&&t.dim.length)for(var n=0;n<t.dim.length;++n)l.onnx.TensorShapeProto.Dimension.encode(t.dim[n],e.uint32(10).fork()).ldelim();return e},t.encodeDelimited=function(t,e){return this.encode(t,e).ldelim()},t.decode=function(t,e){t instanceof s||(t=s.create(t));for(var n=void 0===e?t.len:t.pos+e,r=new l.onnx.TensorShapeProto;t.pos<n;){var i=t.uint32();i>>>3==1?(r.dim&&r.dim.length||(r.dim=[]),r.dim.push(l.onnx.TensorShapeProto.Dimension.decode(t,t.uint32()))):t.skipType(7&i)}return r},t.decodeDelimited=function(t){return t instanceof s||(t=new s(t)),this.decode(t,t.uint32())},t.verify=function(t){if(\"object\"!=typeof t||null===t)return\"object expected\";if(null!=t.dim&&t.hasOwnProperty(\"dim\")){if(!Array.isArray(t.dim))return\"dim: array expected\";for(var e=0;e<t.dim.length;++e){var n=l.onnx.TensorShapeProto.Dimension.verify(t.dim[e]);if(n)return\"dim.\"+n}}return null},t.fromObject=function(t){if(t instanceof l.onnx.TensorShapeProto)return t;var e=new l.onnx.TensorShapeProto;if(t.dim){if(!Array.isArray(t.dim))throw TypeError(\".onnx.TensorShapeProto.dim: array expected\");e.dim=[];for(var n=0;n<t.dim.length;++n){if(\"object\"!=typeof t.dim[n])throw TypeError(\".onnx.TensorShapeProto.dim: object expected\");e.dim[n]=l.onnx.TensorShapeProto.Dimension.fromObject(t.dim[n])}}return e},t.toObject=function(t,e){e||(e={});var n={};if((e.arrays||e.defaults)&&(n.dim=[]),t.dim&&t.dim.length){n.dim=[];for(var r=0;r<t.dim.length;++r)n.dim[r]=l.onnx.TensorShapeProto.Dimension.toObject(t.dim[r],e)}return n},t.prototype.toJSON=function(){return this.constructor.toObject(this,a.util.toJSONOptions)},t.Dimension=function(){function t(t){if(t)for(var e=Object.keys(t),n=0;n<e.length;++n)null!=t[e[n]]&&(this[e[n]]=t[e[n]])}var e;return t.prototype.dimValue=c.Long?c.Long.fromBits(0,0,!1):0,t.prototype.dimParam=\"\",t.prototype.denotation=\"\",Object.defineProperty(t.prototype,\"value\",{get:c.oneOfGetter(e=[\"dimValue\",\"dimParam\"]),set:c.oneOfSetter(e)}),t.create=function(e){return new t(e)},t.encode=function(t,e){return e||(e=u.create()),null!=t.dimValue&&t.hasOwnProperty(\"dimValue\")&&e.uint32(8).int64(t.dimValue),null!=t.dimParam&&t.hasOwnProperty(\"dimParam\")&&e.uint32(18).string(t.dimParam),null!=t.denotation&&t.hasOwnProperty(\"denotation\")&&e.uint32(26).string(t.denotation),e},t.encodeDelimited=function(t,e){return this.encode(t,e).ldelim()},t.decode=function(t,e){t instanceof s||(t=s.create(t));for(var n=void 0===e?t.len:t.pos+e,r=new l.onnx.TensorShapeProto.Dimension;t.pos<n;){var i=t.uint32();switch(i>>>3){case 1:r.dimValue=t.int64();break;case 2:r.dimParam=t.string();break;case 3:r.denotation=t.string();break;default:t.skipType(7&i)}}return r},t.decodeDelimited=function(t){return t instanceof s||(t=new s(t)),this.decode(t,t.uint32())},t.verify=function(t){if(\"object\"!=typeof t||null===t)return\"object expected\";var e={};if(null!=t.dimValue&&t.hasOwnProperty(\"dimValue\")&&(e.value=1,!(c.isInteger(t.dimValue)||t.dimValue&&c.isInteger(t.dimValue.low)&&c.isInteger(t.dimValue.high))))return\"dimValue: integer|Long expected\";if(null!=t.dimParam&&t.hasOwnProperty(\"dimParam\")){if(1===e.value)return\"value: multiple values\";if(e.value=1,!c.isString(t.dimParam))return\"dimParam: string expected\"}return null!=t.denotation&&t.hasOwnProperty(\"denotation\")&&!c.isString(t.denotation)?\"denotation: string expected\":null},t.fromObject=function(t){if(t instanceof l.onnx.TensorShapeProto.Dimension)return t;var e=new l.onnx.TensorShapeProto.Dimension;return null!=t.dimValue&&(c.Long?(e.dimValue=c.Long.fromValue(t.dimValue)).unsigned=!1:\"string\"==typeof t.dimValue?e.dimValue=parseInt(t.dimValue,10):\"number\"==typeof t.dimValue?e.dimValue=t.dimValue:\"object\"==typeof t.dimValue&&(e.dimValue=new c.LongBits(t.dimValue.low>>>0,t.dimValue.high>>>0).toNumber())),null!=t.dimParam&&(e.dimParam=String(t.dimParam)),null!=t.denotation&&(e.denotation=String(t.denotation)),e},t.toObject=function(t,e){e||(e={});var n={};return e.defaults&&(n.denotation=\"\"),null!=t.dimValue&&t.hasOwnProperty(\"dimValue\")&&(\"number\"==typeof t.dimValue?n.dimValue=e.longs===String?String(t.dimValue):t.dimValue:n.dimValue=e.longs===String?c.Long.prototype.toString.call(t.dimValue):e.longs===Number?new c.LongBits(t.dimValue.low>>>0,t.dimValue.high>>>0).toNumber():t.dimValue,e.oneofs&&(n.value=\"dimValue\")),null!=t.dimParam&&t.hasOwnProperty(\"dimParam\")&&(n.dimParam=t.dimParam,e.oneofs&&(n.value=\"dimParam\")),null!=t.denotation&&t.hasOwnProperty(\"denotation\")&&(n.denotation=t.denotation),n},t.prototype.toJSON=function(){return this.constructor.toObject(this,a.util.toJSONOptions)},t}(),t}(),o.TypeProto=function(){function t(t){if(t)for(var e=Object.keys(t),n=0;n<e.length;++n)null!=t[e[n]]&&(this[e[n]]=t[e[n]])}var e;return t.prototype.tensorType=null,t.prototype.denotation=\"\",Object.defineProperty(t.prototype,\"value\",{get:c.oneOfGetter(e=[\"tensorType\"]),set:c.oneOfSetter(e)}),t.create=function(e){return new t(e)},t.encode=function(t,e){return e||(e=u.create()),null!=t.tensorType&&t.hasOwnProperty(\"tensorType\")&&l.onnx.TypeProto.Tensor.encode(t.tensorType,e.uint32(10).fork()).ldelim(),null!=t.denotation&&t.hasOwnProperty(\"denotation\")&&e.uint32(50).string(t.denotation),e},t.encodeDelimited=function(t,e){return this.encode(t,e).ldelim()},t.decode=function(t,e){t instanceof s||(t=s.create(t));for(var n=void 0===e?t.len:t.pos+e,r=new l.onnx.TypeProto;t.pos<n;){var i=t.uint32();switch(i>>>3){case 1:r.tensorType=l.onnx.TypeProto.Tensor.decode(t,t.uint32());break;case 6:r.denotation=t.string();break;default:t.skipType(7&i)}}return r},t.decodeDelimited=function(t){return t instanceof s||(t=new s(t)),this.decode(t,t.uint32())},t.verify=function(t){if(\"object\"!=typeof t||null===t)return\"object expected\";if(null!=t.tensorType&&t.hasOwnProperty(\"tensorType\")){var e=l.onnx.TypeProto.Tensor.verify(t.tensorType);if(e)return\"tensorType.\"+e}return null!=t.denotation&&t.hasOwnProperty(\"denotation\")&&!c.isString(t.denotation)?\"denotation: string expected\":null},t.fromObject=function(t){if(t instanceof l.onnx.TypeProto)return t;var e=new l.onnx.TypeProto;if(null!=t.tensorType){if(\"object\"!=typeof t.tensorType)throw TypeError(\".onnx.TypeProto.tensorType: object expected\");e.tensorType=l.onnx.TypeProto.Tensor.fromObject(t.tensorType)}return null!=t.denotation&&(e.denotation=String(t.denotation)),e},t.toObject=function(t,e){e||(e={});var n={};return e.defaults&&(n.denotation=\"\"),null!=t.tensorType&&t.hasOwnProperty(\"tensorType\")&&(n.tensorType=l.onnx.TypeProto.Tensor.toObject(t.tensorType,e),e.oneofs&&(n.value=\"tensorType\")),null!=t.denotation&&t.hasOwnProperty(\"denotation\")&&(n.denotation=t.denotation),n},t.prototype.toJSON=function(){return this.constructor.toObject(this,a.util.toJSONOptions)},t.Tensor=function(){function t(t){if(t)for(var e=Object.keys(t),n=0;n<e.length;++n)null!=t[e[n]]&&(this[e[n]]=t[e[n]])}return t.prototype.elemType=0,t.prototype.shape=null,t.create=function(e){return new t(e)},t.encode=function(t,e){return e||(e=u.create()),null!=t.elemType&&t.hasOwnProperty(\"elemType\")&&e.uint32(8).int32(t.elemType),null!=t.shape&&t.hasOwnProperty(\"shape\")&&l.onnx.TensorShapeProto.encode(t.shape,e.uint32(18).fork()).ldelim(),e},t.encodeDelimited=function(t,e){return this.encode(t,e).ldelim()},t.decode=function(t,e){t instanceof s||(t=s.create(t));for(var n=void 0===e?t.len:t.pos+e,r=new l.onnx.TypeProto.Tensor;t.pos<n;){var i=t.uint32();switch(i>>>3){case 1:r.elemType=t.int32();break;case 2:r.shape=l.onnx.TensorShapeProto.decode(t,t.uint32());break;default:t.skipType(7&i)}}return r},t.decodeDelimited=function(t){return t instanceof s||(t=new s(t)),this.decode(t,t.uint32())},t.verify=function(t){if(\"object\"!=typeof t||null===t)return\"object expected\";if(null!=t.elemType&&t.hasOwnProperty(\"elemType\")&&!c.isInteger(t.elemType))return\"elemType: integer expected\";if(null!=t.shape&&t.hasOwnProperty(\"shape\")){var e=l.onnx.TensorShapeProto.verify(t.shape);if(e)return\"shape.\"+e}return null},t.fromObject=function(t){if(t instanceof l.onnx.TypeProto.Tensor)return t;var e=new l.onnx.TypeProto.Tensor;if(null!=t.elemType&&(e.elemType=0|t.elemType),null!=t.shape){if(\"object\"!=typeof t.shape)throw TypeError(\".onnx.TypeProto.Tensor.shape: object expected\");e.shape=l.onnx.TensorShapeProto.fromObject(t.shape)}return e},t.toObject=function(t,e){e||(e={});var n={};return e.defaults&&(n.elemType=0,n.shape=null),null!=t.elemType&&t.hasOwnProperty(\"elemType\")&&(n.elemType=t.elemType),null!=t.shape&&t.hasOwnProperty(\"shape\")&&(n.shape=l.onnx.TensorShapeProto.toObject(t.shape,e)),n},t.prototype.toJSON=function(){return this.constructor.toObject(this,a.util.toJSONOptions)},t}(),t}(),o.OperatorSetIdProto=function(){function t(t){if(t)for(var e=Object.keys(t),n=0;n<e.length;++n)null!=t[e[n]]&&(this[e[n]]=t[e[n]])}return t.prototype.domain=\"\",t.prototype.version=c.Long?c.Long.fromBits(0,0,!1):0,t.create=function(e){return new t(e)},t.encode=function(t,e){return e||(e=u.create()),null!=t.domain&&t.hasOwnProperty(\"domain\")&&e.uint32(10).string(t.domain),null!=t.version&&t.hasOwnProperty(\"version\")&&e.uint32(16).int64(t.version),e},t.encodeDelimited=function(t,e){return this.encode(t,e).ldelim()},t.decode=function(t,e){t instanceof s||(t=s.create(t));for(var n=void 0===e?t.len:t.pos+e,r=new l.onnx.OperatorSetIdProto;t.pos<n;){var i=t.uint32();switch(i>>>3){case 1:r.domain=t.string();break;case 2:r.version=t.int64();break;default:t.skipType(7&i)}}return r},t.decodeDelimited=function(t){return t instanceof s||(t=new s(t)),this.decode(t,t.uint32())},t.verify=function(t){return\"object\"!=typeof t||null===t?\"object expected\":null!=t.domain&&t.hasOwnProperty(\"domain\")&&!c.isString(t.domain)?\"domain: string expected\":null!=t.version&&t.hasOwnProperty(\"version\")&&!(c.isInteger(t.version)||t.version&&c.isInteger(t.version.low)&&c.isInteger(t.version.high))?\"version: integer|Long expected\":null},t.fromObject=function(t){if(t instanceof l.onnx.OperatorSetIdProto)return t;var e=new l.onnx.OperatorSetIdProto;return null!=t.domain&&(e.domain=String(t.domain)),null!=t.version&&(c.Long?(e.version=c.Long.fromValue(t.version)).unsigned=!1:\"string\"==typeof t.version?e.version=parseInt(t.version,10):\"number\"==typeof t.version?e.version=t.version:\"object\"==typeof t.version&&(e.version=new c.LongBits(t.version.low>>>0,t.version.high>>>0).toNumber())),e},t.toObject=function(t,e){e||(e={});var n={};if(e.defaults)if(n.domain=\"\",c.Long){var r=new c.Long(0,0,!1);n.version=e.longs===String?r.toString():e.longs===Number?r.toNumber():r}else n.version=e.longs===String?\"0\":0;return null!=t.domain&&t.hasOwnProperty(\"domain\")&&(n.domain=t.domain),null!=t.version&&t.hasOwnProperty(\"version\")&&(\"number\"==typeof t.version?n.version=e.longs===String?String(t.version):t.version:n.version=e.longs===String?c.Long.prototype.toString.call(t.version):e.longs===Number?new c.LongBits(t.version.low>>>0,t.version.high>>>0).toNumber():t.version),n},t.prototype.toJSON=function(){return this.constructor.toObject(this,a.util.toJSONOptions)},t}(),o),t.exports=l},2100:(t,e,n)=>{\"use strict\";t.exports=n(9482)},9482:(t,e,n)=>{\"use strict\";var r=e;function i(){r.util._configure(),r.Writer._configure(r.BufferWriter),r.Reader._configure(r.BufferReader)}r.build=\"minimal\",r.Writer=n(1173),r.BufferWriter=n(3155),r.Reader=n(1408),r.BufferReader=n(593),r.util=n(9693),r.rpc=n(5994),r.roots=n(5054),r.configure=i,i()},1408:(t,e,n)=>{\"use strict\";t.exports=u;var r,i=n(9693),o=i.LongBits,a=i.utf8;function s(t,e){return RangeError(\"index out of range: \"+t.pos+\" + \"+(e||1)+\" > \"+t.len)}function u(t){this.buf=t,this.pos=0,this.len=t.length}var c,l=\"undefined\"!=typeof Uint8Array?function(t){if(t instanceof Uint8Array||Array.isArray(t))return new u(t);throw Error(\"illegal buffer\")}:function(t){if(Array.isArray(t))return new u(t);throw Error(\"illegal buffer\")},p=function(){return i.Buffer?function(t){return(u.create=function(t){return i.Buffer.isBuffer(t)?new r(t):l(t)})(t)}:l};function f(){var t=new o(0,0),e=0;if(!(this.len-this.pos>4)){for(;e<3;++e){if(this.pos>=this.len)throw s(this);if(t.lo=(t.lo|(127&this.buf[this.pos])<<7*e)>>>0,this.buf[this.pos++]<128)return t}return t.lo=(t.lo|(127&this.buf[this.pos++])<<7*e)>>>0,t}for(;e<4;++e)if(t.lo=(t.lo|(127&this.buf[this.pos])<<7*e)>>>0,this.buf[this.pos++]<128)return t;if(t.lo=(t.lo|(127&this.buf[this.pos])<<28)>>>0,t.hi=(t.hi|(127&this.buf[this.pos])>>4)>>>0,this.buf[this.pos++]<128)return t;if(e=0,this.len-this.pos>4){for(;e<5;++e)if(t.hi=(t.hi|(127&this.buf[this.pos])<<7*e+3)>>>0,this.buf[this.pos++]<128)return t}else for(;e<5;++e){if(this.pos>=this.len)throw s(this);if(t.hi=(t.hi|(127&this.buf[this.pos])<<7*e+3)>>>0,this.buf[this.pos++]<128)return t}throw Error(\"invalid varint encoding\")}function d(t,e){return(t[e-4]|t[e-3]<<8|t[e-2]<<16|t[e-1]<<24)>>>0}function h(){if(this.pos+8>this.len)throw s(this,8);return new o(d(this.buf,this.pos+=4),d(this.buf,this.pos+=4))}u.create=p(),u.prototype._slice=i.Array.prototype.subarray||i.Array.prototype.slice,u.prototype.uint32=(c=4294967295,function(){if(c=(127&this.buf[this.pos])>>>0,this.buf[this.pos++]<128)return c;if(c=(c|(127&this.buf[this.pos])<<7)>>>0,this.buf[this.pos++]<128)return c;if(c=(c|(127&this.buf[this.pos])<<14)>>>0,this.buf[this.pos++]<128)return c;if(c=(c|(127&this.buf[this.pos])<<21)>>>0,this.buf[this.pos++]<128)return c;if(c=(c|(15&this.buf[this.pos])<<28)>>>0,this.buf[this.pos++]<128)return c;if((this.pos+=5)>this.len)throw this.pos=this.len,s(this,10);return c}),u.prototype.int32=function(){return 0|this.uint32()},u.prototype.sint32=function(){var t=this.uint32();return t>>>1^-(1&t)|0},u.prototype.bool=function(){return 0!==this.uint32()},u.prototype.fixed32=function(){if(this.pos+4>this.len)throw s(this,4);return d(this.buf,this.pos+=4)},u.prototype.sfixed32=function(){if(this.pos+4>this.len)throw s(this,4);return 0|d(this.buf,this.pos+=4)},u.prototype.float=function(){if(this.pos+4>this.len)throw s(this,4);var t=i.float.readFloatLE(this.buf,this.pos);return this.pos+=4,t},u.prototype.double=function(){if(this.pos+8>this.len)throw s(this,4);var t=i.float.readDoubleLE(this.buf,this.pos);return this.pos+=8,t},u.prototype.bytes=function(){var t=this.uint32(),e=this.pos,n=this.pos+t;if(n>this.len)throw s(this,t);return this.pos+=t,Array.isArray(this.buf)?this.buf.slice(e,n):e===n?new this.buf.constructor(0):this._slice.call(this.buf,e,n)},u.prototype.string=function(){var t=this.bytes();return a.read(t,0,t.length)},u.prototype.skip=function(t){if(\"number\"==typeof t){if(this.pos+t>this.len)throw s(this,t);this.pos+=t}else do{if(this.pos>=this.len)throw s(this)}while(128&this.buf[this.pos++]);return this},u.prototype.skipType=function(t){switch(t){case 0:this.skip();break;case 1:this.skip(8);break;case 2:this.skip(this.uint32());break;case 3:for(;4!=(t=7&this.uint32());)this.skipType(t);break;case 5:this.skip(4);break;default:throw Error(\"invalid wire type \"+t+\" at offset \"+this.pos)}return this},u._configure=function(t){r=t,u.create=p(),r._configure();var e=i.Long?\"toLong\":\"toNumber\";i.merge(u.prototype,{int64:function(){return f.call(this)[e](!1)},uint64:function(){return f.call(this)[e](!0)},sint64:function(){return f.call(this).zzDecode()[e](!1)},fixed64:function(){return h.call(this)[e](!0)},sfixed64:function(){return h.call(this)[e](!1)}})}},593:(t,e,n)=>{\"use strict\";t.exports=o;var r=n(1408);(o.prototype=Object.create(r.prototype)).constructor=o;var i=n(9693);function o(t){r.call(this,t)}o._configure=function(){i.Buffer&&(o.prototype._slice=i.Buffer.prototype.slice)},o.prototype.string=function(){var t=this.uint32();return this.buf.utf8Slice?this.buf.utf8Slice(this.pos,this.pos=Math.min(this.pos+t,this.len)):this.buf.toString(\"utf-8\",this.pos,this.pos=Math.min(this.pos+t,this.len))},o._configure()},5054:t=>{\"use strict\";t.exports={}},5994:(t,e,n)=>{\"use strict\";e.Service=n(7948)},7948:(t,e,n)=>{\"use strict\";t.exports=i;var r=n(9693);function i(t,e,n){if(\"function\"!=typeof t)throw TypeError(\"rpcImpl must be a function\");r.EventEmitter.call(this),this.rpcImpl=t,this.requestDelimited=Boolean(e),this.responseDelimited=Boolean(n)}(i.prototype=Object.create(r.EventEmitter.prototype)).constructor=i,i.prototype.rpcCall=function t(e,n,i,o,a){if(!o)throw TypeError(\"request must be specified\");var s=this;if(!a)return r.asPromise(t,s,e,n,i,o);if(s.rpcImpl)try{return s.rpcImpl(e,n[s.requestDelimited?\"encodeDelimited\":\"encode\"](o).finish(),(function(t,n){if(t)return s.emit(\"error\",t,e),a(t);if(null!==n){if(!(n instanceof i))try{n=i[s.responseDelimited?\"decodeDelimited\":\"decode\"](n)}catch(t){return s.emit(\"error\",t,e),a(t)}return s.emit(\"data\",n,e),a(null,n)}s.end(!0)}))}catch(t){return s.emit(\"error\",t,e),void setTimeout((function(){a(t)}),0)}else setTimeout((function(){a(Error(\"already ended\"))}),0)},i.prototype.end=function(t){return this.rpcImpl&&(t||this.rpcImpl(null,null,null),this.rpcImpl=null,this.emit(\"end\").off()),this}},1945:(t,e,n)=>{\"use strict\";t.exports=i;var r=n(9693);function i(t,e){this.lo=t>>>0,this.hi=e>>>0}var o=i.zero=new i(0,0);o.toNumber=function(){return 0},o.zzEncode=o.zzDecode=function(){return this},o.length=function(){return 1};var a=i.zeroHash=\"\\0\\0\\0\\0\\0\\0\\0\\0\";i.fromNumber=function(t){if(0===t)return o;var e=t<0;e&&(t=-t);var n=t>>>0,r=(t-n)/4294967296>>>0;return e&&(r=~r>>>0,n=~n>>>0,++n>4294967295&&(n=0,++r>4294967295&&(r=0))),new i(n,r)},i.from=function(t){if(\"number\"==typeof t)return i.fromNumber(t);if(r.isString(t)){if(!r.Long)return i.fromNumber(parseInt(t,10));t=r.Long.fromString(t)}return t.low||t.high?new i(t.low>>>0,t.high>>>0):o},i.prototype.toNumber=function(t){if(!t&&this.hi>>>31){var e=1+~this.lo>>>0,n=~this.hi>>>0;return e||(n=n+1>>>0),-(e+4294967296*n)}return this.lo+4294967296*this.hi},i.prototype.toLong=function(t){return r.Long?new r.Long(0|this.lo,0|this.hi,Boolean(t)):{low:0|this.lo,high:0|this.hi,unsigned:Boolean(t)}};var s=String.prototype.charCodeAt;i.fromHash=function(t){return t===a?o:new i((s.call(t,0)|s.call(t,1)<<8|s.call(t,2)<<16|s.call(t,3)<<24)>>>0,(s.call(t,4)|s.call(t,5)<<8|s.call(t,6)<<16|s.call(t,7)<<24)>>>0)},i.prototype.toHash=function(){return String.fromCharCode(255&this.lo,this.lo>>>8&255,this.lo>>>16&255,this.lo>>>24,255&this.hi,this.hi>>>8&255,this.hi>>>16&255,this.hi>>>24)},i.prototype.zzEncode=function(){var t=this.hi>>31;return this.hi=((this.hi<<1|this.lo>>>31)^t)>>>0,this.lo=(this.lo<<1^t)>>>0,this},i.prototype.zzDecode=function(){var t=-(1&this.lo);return this.lo=((this.lo>>>1|this.hi<<31)^t)>>>0,this.hi=(this.hi>>>1^t)>>>0,this},i.prototype.length=function(){var t=this.lo,e=(this.lo>>>28|this.hi<<4)>>>0,n=this.hi>>>24;return 0===n?0===e?t<16384?t<128?1:2:t<2097152?3:4:e<16384?e<128?5:6:e<2097152?7:8:n<128?9:10}},9693:function(t,e,n){\"use strict\";var r=e;function i(t,e,n){for(var r=Object.keys(e),i=0;i<r.length;++i)void 0!==t[r[i]]&&n||(t[r[i]]=e[r[i]]);return t}function o(t){function e(t,n){if(!(this instanceof e))return new e(t,n);Object.defineProperty(this,\"message\",{get:function(){return t}}),Error.captureStackTrace?Error.captureStackTrace(this,e):Object.defineProperty(this,\"stack\",{value:(new Error).stack||\"\"}),n&&i(this,n)}return(e.prototype=Object.create(Error.prototype)).constructor=e,Object.defineProperty(e.prototype,\"name\",{get:function(){return t}}),e.prototype.toString=function(){return this.name+\": \"+this.message},e}r.asPromise=n(4537),r.base64=n(7419),r.EventEmitter=n(9211),r.float=n(945),r.inquire=n(7199),r.utf8=n(4997),r.pool=n(6662),r.LongBits=n(1945),r.isNode=Boolean(\"undefined\"!=typeof global&&global&&global.process&&global.process.versions&&global.process.versions.node),r.global=r.isNode&&global||\"undefined\"!=typeof window&&window||\"undefined\"!=typeof self&&self||this,r.emptyArray=Object.freeze?Object.freeze([]):[],r.emptyObject=Object.freeze?Object.freeze({}):{},r.isInteger=Number.isInteger||function(t){return\"number\"==typeof t&&isFinite(t)&&Math.floor(t)===t},r.isString=function(t){return\"string\"==typeof t||t instanceof String},r.isObject=function(t){return t&&\"object\"==typeof t},r.isset=r.isSet=function(t,e){var n=t[e];return!(null==n||!t.hasOwnProperty(e))&&(\"object\"!=typeof n||(Array.isArray(n)?n.length:Object.keys(n).length)>0)},r.Buffer=function(){try{var t=r.inquire(\"buffer\").Buffer;return t.prototype.utf8Write?t:null}catch(t){return null}}(),r._Buffer_from=null,r._Buffer_allocUnsafe=null,r.newBuffer=function(t){return\"number\"==typeof t?r.Buffer?r._Buffer_allocUnsafe(t):new r.Array(t):r.Buffer?r._Buffer_from(t):\"undefined\"==typeof Uint8Array?t:new Uint8Array(t)},r.Array=\"undefined\"!=typeof Uint8Array?Uint8Array:Array,r.Long=r.global.dcodeIO&&r.global.dcodeIO.Long||r.global.Long||r.inquire(\"long\"),r.key2Re=/^true|false|0|1$/,r.key32Re=/^-?(?:0|[1-9][0-9]*)$/,r.key64Re=/^(?:[\\\\x00-\\\\xff]{8}|-?(?:0|[1-9][0-9]*))$/,r.longToHash=function(t){return t?r.LongBits.from(t).toHash():r.LongBits.zeroHash},r.longFromHash=function(t,e){var n=r.LongBits.fromHash(t);return r.Long?r.Long.fromBits(n.lo,n.hi,e):n.toNumber(Boolean(e))},r.merge=i,r.lcFirst=function(t){return t.charAt(0).toLowerCase()+t.substring(1)},r.newError=o,r.ProtocolError=o(\"ProtocolError\"),r.oneOfGetter=function(t){for(var e={},n=0;n<t.length;++n)e[t[n]]=1;return function(){for(var t=Object.keys(this),n=t.length-1;n>-1;--n)if(1===e[t[n]]&&void 0!==this[t[n]]&&null!==this[t[n]])return t[n]}},r.oneOfSetter=function(t){return function(e){for(var n=0;n<t.length;++n)t[n]!==e&&delete this[t[n]]}},r.toJSONOptions={longs:String,enums:String,bytes:String,json:!0},r._configure=function(){var t=r.Buffer;t?(r._Buffer_from=t.from!==Uint8Array.from&&t.from||function(e,n){return new t(e,n)},r._Buffer_allocUnsafe=t.allocUnsafe||function(e){return new t(e)}):r._Buffer_from=r._Buffer_allocUnsafe=null}},1173:(t,e,n)=>{\"use strict\";t.exports=p;var r,i=n(9693),o=i.LongBits,a=i.base64,s=i.utf8;function u(t,e,n){this.fn=t,this.len=e,this.next=void 0,this.val=n}function c(){}function l(t){this.head=t.head,this.tail=t.tail,this.len=t.len,this.next=t.states}function p(){this.len=0,this.head=new u(c,0,0),this.tail=this.head,this.states=null}var f=function(){return i.Buffer?function(){return(p.create=function(){return new r})()}:function(){return new p}};function d(t,e,n){e[n]=255&t}function h(t,e){this.len=t,this.next=void 0,this.val=e}function g(t,e,n){for(;t.hi;)e[n++]=127&t.lo|128,t.lo=(t.lo>>>7|t.hi<<25)>>>0,t.hi>>>=7;for(;t.lo>127;)e[n++]=127&t.lo|128,t.lo=t.lo>>>7;e[n++]=t.lo}function b(t,e,n){e[n]=255&t,e[n+1]=t>>>8&255,e[n+2]=t>>>16&255,e[n+3]=t>>>24}p.create=f(),p.alloc=function(t){return new i.Array(t)},i.Array!==Array&&(p.alloc=i.pool(p.alloc,i.Array.prototype.subarray)),p.prototype._push=function(t,e,n){return this.tail=this.tail.next=new u(t,e,n),this.len+=e,this},h.prototype=Object.create(u.prototype),h.prototype.fn=function(t,e,n){for(;t>127;)e[n++]=127&t|128,t>>>=7;e[n]=t},p.prototype.uint32=function(t){return this.len+=(this.tail=this.tail.next=new h((t>>>=0)<128?1:t<16384?2:t<2097152?3:t<268435456?4:5,t)).len,this},p.prototype.int32=function(t){return t<0?this._push(g,10,o.fromNumber(t)):this.uint32(t)},p.prototype.sint32=function(t){return this.uint32((t<<1^t>>31)>>>0)},p.prototype.uint64=function(t){var e=o.from(t);return this._push(g,e.length(),e)},p.prototype.int64=p.prototype.uint64,p.prototype.sint64=function(t){var e=o.from(t).zzEncode();return this._push(g,e.length(),e)},p.prototype.bool=function(t){return this._push(d,1,t?1:0)},p.prototype.fixed32=function(t){return this._push(b,4,t>>>0)},p.prototype.sfixed32=p.prototype.fixed32,p.prototype.fixed64=function(t){var e=o.from(t);return this._push(b,4,e.lo)._push(b,4,e.hi)},p.prototype.sfixed64=p.prototype.fixed64,p.prototype.float=function(t){return this._push(i.float.writeFloatLE,4,t)},p.prototype.double=function(t){return this._push(i.float.writeDoubleLE,8,t)};var m=i.Array.prototype.set?function(t,e,n){e.set(t,n)}:function(t,e,n){for(var r=0;r<t.length;++r)e[n+r]=t[r]};p.prototype.bytes=function(t){var e=t.length>>>0;if(!e)return this._push(d,1,0);if(i.isString(t)){var n=p.alloc(e=a.length(t));a.decode(t,n,0),t=n}return this.uint32(e)._push(m,e,t)},p.prototype.string=function(t){var e=s.length(t);return e?this.uint32(e)._push(s.write,e,t):this._push(d,1,0)},p.prototype.fork=function(){return this.states=new l(this),this.head=this.tail=new u(c,0,0),this.len=0,this},p.prototype.reset=function(){return this.states?(this.head=this.states.head,this.tail=this.states.tail,this.len=this.states.len,this.states=this.states.next):(this.head=this.tail=new u(c,0,0),this.len=0),this},p.prototype.ldelim=function(){var t=this.head,e=this.tail,n=this.len;return this.reset().uint32(n),n&&(this.tail.next=t.next,this.tail=e,this.len+=n),this},p.prototype.finish=function(){for(var t=this.head.next,e=this.constructor.alloc(this.len),n=0;t;)t.fn(t.val,e,n),n+=t.len,t=t.next;return e},p._configure=function(t){r=t,p.create=f(),r._configure()}},3155:(t,e,n)=>{\"use strict\";t.exports=o;var r=n(1173);(o.prototype=Object.create(r.prototype)).constructor=o;var i=n(9693);function o(){r.call(this)}function a(t,e,n){t.length<40?i.utf8.write(t,e,n):e.utf8Write?e.utf8Write(t,n):e.write(t,n)}o._configure=function(){o.alloc=i._Buffer_allocUnsafe,o.writeBytesBuffer=i.Buffer&&i.Buffer.prototype instanceof Uint8Array&&\"set\"===i.Buffer.prototype.set.name?function(t,e,n){e.set(t,n)}:function(t,e,n){if(t.copy)t.copy(e,n,0,t.length);else for(var r=0;r<t.length;)e[n++]=t[r++]}},o.prototype.bytes=function(t){i.isString(t)&&(t=i._Buffer_from(t,\"base64\"));var e=t.length>>>0;return this.uint32(e),e&&this._push(o.writeBytesBuffer,e,t),this},o.prototype.string=function(t){var e=i.Buffer.byteLength(t);return this.uint32(e),e&&this._push(a,e,t),this},o._configure()},7714:(t,e,n)=>{\"use strict\";e.R=void 0;const r=n(6919),i=n(7448);e.R=new class{async init(){}async createSessionHandler(t,e){const n=new r.Session(e);return await n.loadModel(t),new i.OnnxjsSessionHandler(n)}}},4200:(t,e,n)=>{\"use strict\";e.c8=e.rX=void 0;const r=n(6207),i=n(9719),o=n(2157),a=n(2306);e.rX=()=>{if((\"number\"!=typeof r.env.wasm.initTimeout||r.env.wasm.initTimeout<0)&&(r.env.wasm.initTimeout=0),\"boolean\"!=typeof r.env.wasm.simd&&(r.env.wasm.simd=!0),\"boolean\"!=typeof r.env.wasm.proxy&&(r.env.wasm.proxy=!1),\"number\"!=typeof r.env.wasm.numThreads||!Number.isInteger(r.env.wasm.numThreads)||r.env.wasm.numThreads<=0){const t=\"undefined\"==typeof navigator?(0,i.cpus)().length:navigator.hardwareConcurrency;r.env.wasm.numThreads=Math.min(4,Math.ceil((t||1)/2))}},e.c8=new class{async init(){(0,e.rX)(),await(0,o.initWasm)()}async createSessionHandler(t,e){const n=new a.OnnxruntimeWebAssemblySessionHandler;return await n.loadModel(t,e),Promise.resolve(n)}}},6018:function(t,e,n){\"use strict\";var r=this&&this.__createBinding||(Object.create?function(t,e,n,r){void 0===r&&(r=n);var i=Object.getOwnPropertyDescriptor(e,n);i&&!(\"get\"in i?!e.__esModule:i.writable||i.configurable)||(i={enumerable:!0,get:function(){return e[n]}}),Object.defineProperty(t,r,i)}:function(t,e,n,r){void 0===r&&(r=n),t[r]=e[n]}),i=this&&this.__exportStar||function(t,e){for(var n in t)\"default\"===n||Object.prototype.hasOwnProperty.call(e,n)||r(e,t,n)};Object.defineProperty(e,\"__esModule\",{value:!0}),i(n(6207),e);const o=n(6207);{const t=n(7714).R;(0,o.registerBackend)(\"webgl\",t,-10)}{const t=n(4200).c8;(0,o.registerBackend)(\"cpu\",t,10),(0,o.registerBackend)(\"wasm\",t,10),(0,o.registerBackend)(\"xnnpack\",t,9)}},246:(t,e)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.createAttributeWithCacheKey=void 0;class n{constructor(t){Object.assign(this,t)}get cacheKey(){return this._cacheKey||(this._cacheKey=Object.getOwnPropertyNames(this).sort().map((t=>`${this[t]}`)).join(\";\")),this._cacheKey}}e.createAttributeWithCacheKey=t=>new n(t)},7778:(t,e,n)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.Attribute=void 0;const r=n(1446),i=n(9395),o=n(9162),a=n(2517);var s=i.onnxruntime.experimental.fbs;class u{constructor(t){if(this._attributes=new Map,null!=t){for(const e of t)e instanceof r.onnx.AttributeProto?this._attributes.set(e.name,[u.getValue(e),u.getType(e)]):e instanceof s.Attribute&&this._attributes.set(e.name(),[u.getValue(e),u.getType(e)]);if(this._attributes.size<t.length)throw new Error(\"duplicated attribute names\")}}set(t,e,n){this._attributes.set(t,[n,e])}delete(t){this._attributes.delete(t)}getFloat(t,e){return this.get(t,\"float\",e)}getInt(t,e){return this.get(t,\"int\",e)}getString(t,e){return this.get(t,\"string\",e)}getTensor(t,e){return this.get(t,\"tensor\",e)}getFloats(t,e){return this.get(t,\"floats\",e)}getInts(t,e){return this.get(t,\"ints\",e)}getStrings(t,e){return this.get(t,\"strings\",e)}getTensors(t,e){return this.get(t,\"tensors\",e)}get(t,e,n){const r=this._attributes.get(t);if(void 0===r){if(void 0!==n)return n;throw new Error(`required attribute not found: ${t}`)}if(r[1]!==e)throw new Error(`type mismatch: expected ${e} but got ${r[1]}`);return r[0]}static getType(t){const e=t instanceof r.onnx.AttributeProto?t.type:t.type();switch(e){case r.onnx.AttributeProto.AttributeType.FLOAT:return\"float\";case r.onnx.AttributeProto.AttributeType.INT:return\"int\";case r.onnx.AttributeProto.AttributeType.STRING:return\"string\";case r.onnx.AttributeProto.AttributeType.TENSOR:return\"tensor\";case r.onnx.AttributeProto.AttributeType.FLOATS:return\"floats\";case r.onnx.AttributeProto.AttributeType.INTS:return\"ints\";case r.onnx.AttributeProto.AttributeType.STRINGS:return\"strings\";case r.onnx.AttributeProto.AttributeType.TENSORS:return\"tensors\";default:throw new Error(`attribute type is not supported yet: ${r.onnx.AttributeProto.AttributeType[e]}`)}}static getValue(t){const e=t instanceof r.onnx.AttributeProto?t.type:t.type();if(e===r.onnx.AttributeProto.AttributeType.GRAPH||e===r.onnx.AttributeProto.AttributeType.GRAPHS)throw new Error(\"graph attribute is not supported yet\");const n=this.getValueNoCheck(t);if(e===r.onnx.AttributeProto.AttributeType.INT&&a.LongUtil.isLong(n))return a.LongUtil.longToNumber(n);if(e===r.onnx.AttributeProto.AttributeType.INTS){const t=n,e=new Array(t.length);for(let n=0;n<t.length;n++){const r=t[n];e[n]=a.LongUtil.longToNumber(r)}return e}if(e===r.onnx.AttributeProto.AttributeType.TENSOR)return t instanceof r.onnx.AttributeProto?o.Tensor.fromProto(n):o.Tensor.fromOrtTensor(n);if(e===r.onnx.AttributeProto.AttributeType.TENSORS){if(t instanceof r.onnx.AttributeProto)return n.map((t=>o.Tensor.fromProto(t)));if(t instanceof s.Attribute)return n.map((t=>o.Tensor.fromOrtTensor(t)))}if(e===r.onnx.AttributeProto.AttributeType.STRING&&t instanceof r.onnx.AttributeProto){const t=n;return(0,a.decodeUtf8String)(t)}return e===r.onnx.AttributeProto.AttributeType.STRINGS&&t instanceof r.onnx.AttributeProto?n.map(a.decodeUtf8String):n}static getValueNoCheck(t){return t instanceof r.onnx.AttributeProto?this.getValueNoCheckFromOnnxFormat(t):this.getValueNoCheckFromOrtFormat(t)}static getValueNoCheckFromOnnxFormat(t){switch(t.type){case r.onnx.AttributeProto.AttributeType.FLOAT:return t.f;case r.onnx.AttributeProto.AttributeType.INT:return t.i;case r.onnx.AttributeProto.AttributeType.STRING:return t.s;case r.onnx.AttributeProto.AttributeType.TENSOR:return t.t;case r.onnx.AttributeProto.AttributeType.GRAPH:return t.g;case r.onnx.AttributeProto.AttributeType.FLOATS:return t.floats;case r.onnx.AttributeProto.AttributeType.INTS:return t.ints;case r.onnx.AttributeProto.AttributeType.STRINGS:return t.strings;case r.onnx.AttributeProto.AttributeType.TENSORS:return t.tensors;case r.onnx.AttributeProto.AttributeType.GRAPHS:return t.graphs;default:throw new Error(`unsupported attribute type: ${r.onnx.AttributeProto.AttributeType[t.type]}`)}}static getValueNoCheckFromOrtFormat(t){switch(t.type()){case s.AttributeType.FLOAT:return t.f();case s.AttributeType.INT:return t.i();case s.AttributeType.STRING:return t.s();case s.AttributeType.TENSOR:return t.t();case s.AttributeType.GRAPH:return t.g();case s.AttributeType.FLOATS:return t.floatsArray();case s.AttributeType.INTS:{const e=[];for(let n=0;n<t.intsLength();n++)e.push(t.ints(n));return e}case s.AttributeType.STRINGS:{const e=[];for(let n=0;n<t.stringsLength();n++)e.push(t.strings(n));return e}case s.AttributeType.TENSORS:{const e=[];for(let n=0;n<t.tensorsLength();n++)e.push(t.tensors(n));return e}default:throw new Error(`unsupported attribute type: ${s.AttributeType[t.type()]}`)}}}e.Attribute=u},7091:(t,e,n)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.resolveBackend=e.backend=void 0;const r=n(5038),i=new Map;async function o(t){const n=e.backend;if(void 0!==n[t]&&function(t){const e=t;return\"initialize\"in e&&\"function\"==typeof e.initialize&&\"createSessionHandler\"in e&&\"function\"==typeof e.createSessionHandler&&\"dispose\"in e&&\"function\"==typeof e.dispose}(n[t])){const e=n[t];let r=e.initialize();if(\"object\"==typeof r&&\"then\"in r&&(r=await r),r)return i.set(t,e),e}}e.backend={webgl:new r.WebGLBackend},e.resolveBackend=async function t(e){if(!e)return t([\"webgl\"]);{const t=\"string\"==typeof e?[e]:e;for(const e of t){const t=i.get(e);if(t)return t;const n=await o(e);if(n)return n}}throw new Error(\"no available backend to use\")}},5038:(t,e,n)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.WebGLBackend=void 0;const r=n(6207),i=n(3694),o=n(6416),a=n(7305);e.WebGLBackend=class{get contextId(){return r.env.webgl.contextId}set contextId(t){r.env.webgl.contextId=t}get matmulMaxBatchSize(){return r.env.webgl.matmulMaxBatchSize}set matmulMaxBatchSize(t){r.env.webgl.matmulMaxBatchSize=t}get textureCacheMode(){return r.env.webgl.textureCacheMode}set textureCacheMode(t){r.env.webgl.textureCacheMode=t}get pack(){return r.env.webgl.pack}set pack(t){r.env.webgl.pack=t}get async(){return r.env.webgl.async}set async(t){r.env.webgl.async=t}initialize(){try{return this.glContext=(0,a.createWebGLContext)(this.contextId),\"number\"!=typeof this.matmulMaxBatchSize&&(this.matmulMaxBatchSize=16),\"string\"!=typeof this.textureCacheMode&&(this.textureCacheMode=\"full\"),\"boolean\"!=typeof this.pack&&(this.pack=!1),\"boolean\"!=typeof this.async&&(this.async=!1),i.Logger.setWithEnv(r.env),i.Logger.verbose(\"WebGLBackend\",`Created WebGLContext: ${typeof this.glContext} with matmulMaxBatchSize: ${this.matmulMaxBatchSize}; textureCacheMode: ${this.textureCacheMode}; pack: ${this.pack}; async: ${this.async}.`),!0}catch(t){return i.Logger.warning(\"WebGLBackend\",`Unable to initialize WebGLBackend. ${t}`),!1}}createSessionHandler(t){return new o.WebGLSessionHandler(this,t)}dispose(){this.glContext.dispose()}}},5107:(t,e,n)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.CoordsGlslLib=void 0;const r=n(2517),i=n(8520),o=n(5060),a=n(7859),s=n(9390);class u extends i.GlslLib{constructor(t){super(t)}getFunctions(){return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({},this.offsetToCoords()),this.coordsToOffset()),this.toVec()),this.valueFrom()),this.getCommonUtilFuncs()),this.getInputsSamplingSnippets()),this.getOutputSamplingSnippet())}getCustomTypes(){return{}}offsetToCoords(){return{offsetToCoords:new i.GlslLibRoutine(\"\\n      vec2 offsetToCoords(int offset, int width, int height) {\\n        int t = offset / width;\\n        int s = offset - t*width;\\n        vec2 coords = (vec2(s,t) + vec2(0.5,0.5)) / vec2(width, height);\\n        return coords;\\n      }\\n      \")}}coordsToOffset(){return{coordsToOffset:new i.GlslLibRoutine(\"\\n      int coordsToOffset(vec2 coords, int width, int height) {\\n        float s = coords.s * float(width);\\n        float t = coords.t * float(height);\\n        int offset = int(t) * width + int(s);\\n        return offset;\\n      }\\n      \")}}getOutputSamplingSnippet(){const t=this.context.outputTextureLayout;return t.isPacked?this.getPackedOutputSamplingSnippet(t):this.getUnpackedOutputSamplingSnippet(t)}getPackedOutputSamplingSnippet(t){const e=t.unpackedShape,n=[t.width,t.height],r={},a=\"getOutputCoords\";switch(e.length){case 0:r[a]=this.getOutputScalarCoords();break;case 1:r[a]=this.getOutputPacked1DCoords(e,n);break;case 2:r[a]=this.getOutputPacked2DCoords(e,n);break;case 3:r[a]=this.getOutputPacked3DCoords(e,n);break;default:r[a]=this.getOutputPackedNDCoords(e,n)}const s=`\\n      void setOutput(vec4 val) {\\n        ${(0,o.getGlsl)(this.context.glContext.version).output} = val;\\n      }\\n    `;return r.floatTextureSetRGBA=new i.GlslLibRoutine(s),r}getUnpackedOutputSamplingSnippet(t){const e=t.unpackedShape,n=[t.width,t.height],r={},a=\"getOutputCoords\";switch(e.length){case 0:r[a]=this.getOutputScalarCoords();break;case 1:r[a]=this.getOutputUnpacked1DCoords(e,n);break;case 2:r[a]=this.getOutputUnpacked2DCoords(e,n);break;case 3:r[a]=this.getOutputUnpacked3DCoords(e,n);break;case 4:r[a]=this.getOutputUnpacked4DCoords(e,n);break;case 5:r[a]=this.getOutputUnpacked5DCoords(e,n);break;case 6:r[a]=this.getOutputUnpacked6DCoords(e,n);break;default:throw new Error(`Unsupported output dimensionality: ${e.length}`)}const s=`\\n        void setOutput(float val) {\\n          ${(0,o.getGlsl)(this.context.glContext.version).output} = vec4(val, 0, 0, 0);\\n        }\\n    `;return r.floatTextureSetR=new i.GlslLibRoutine(s),r}getOutputScalarCoords(){return new i.GlslLibRoutine(\"\\n      int getOutputCoords() {\\n        return 0;\\n      }\\n    \")}getOutputPacked1DCoords(t,e){const n=e;let r=\"\";return 1===n[0]?(r=`\\n          int getOutputCoords() {\\n            return 2 * int(TexCoords.y * ${n[1]}.0);\\n          }\\n        `,new i.GlslLibRoutine(r)):1===n[1]?(r=`\\n          int getOutputCoords() {\\n            return 2 * int(TexCoords.x * ${n[0]}.0);\\n          }\\n        `,new i.GlslLibRoutine(r)):(r=`\\n        int getOutputCoords() {\\n          ivec2 resTexRC = ivec2(TexCoords.xy *\\n                                 vec2(${n[0]}, ${n[1]}));\\n          return 2 * (resTexRC.y * ${n[0]} + resTexRC.x);\\n        }\\n      `,new i.GlslLibRoutine(r))}getOutputPacked2DCoords(t,e){let n=\"\";if(r.ArrayUtil.arraysEqual(t,e))return n=`\\n        ivec2 getOutputCoords() {\\n          return 2 * ivec2(TexCoords.xy * vec2(${e[0]}, ${e[1]}));\\n        }\\n      `,new i.GlslLibRoutine(n);const o=e,a=Math.ceil(t[1]/2);return n=`\\n        ivec2 getOutputCoords() {\\n          ivec2 resTexRC = ivec2(TexCoords.xy *\\n                                vec2(${o[0]}, ${o[1]}));\\n\\n          int index = resTexRC.y * ${o[0]} + resTexRC.x;\\n\\n          // reverse r and c order for packed texture\\n          int r = imod(index, ${a}) * 2;\\n          int c = 2 * (index / ${a});\\n\\n          return ivec2(r, c);\\n        }\\n      `,new i.GlslLibRoutine(n)}getOutputPacked3DCoords(t,e){const n=[e[0],e[1]],r=Math.ceil(t[2]/2),o=r*Math.ceil(t[1]/2),a=`\\n        ivec3 getOutputCoords() {\\n          ivec2 resTexRC = ivec2(TexCoords.xy *\\n                                vec2(${n[0]}, ${n[1]}));\\n          int index = resTexRC.y * ${n[0]} + resTexRC.x;\\n\\n          int b = index / ${o};\\n          index -= b * ${o};\\n\\n          // reverse r and c order for packed texture\\n          int r = imod(index, ${r}) * 2;\\n          int c = 2 * (index / ${r});\\n\\n          return ivec3(b, r, c);\\n        }\\n      `;return new i.GlslLibRoutine(a)}getOutputPackedNDCoords(t,e){const n=[e[0],e[1]],r=Math.ceil(t[t.length-1]/2),o=r*Math.ceil(t[t.length-2]/2);let a=o,s=\"\",u=\"b, r, c\";for(let e=2;e<t.length-1;e++)a*=t[t.length-e-1],s=`\\n      int b${e} = index / ${a};\\n      index -= b${e} * ${a};\\n    `+s,u=`b${e}, `+u;const c=`\\n      ivec${t.length} getOutputCoords() {\\n        ivec2 resTexRC = ivec2(TexCoords.xy *\\n                              vec2(${n[0]}, ${n[1]}));\\n        int index = resTexRC.y * ${n[0]} + resTexRC.x;\\n\\n        ${s}\\n\\n        int b = index / ${o};\\n        index -= b * ${o};\\n\\n        // reverse r and c order for packed texture\\n        int r = imod(index, ${r}) * 2;\\n        int c = 2 * (index / ${r});\\n\\n        return ivec${t.length}(${u});\\n      }\\n    `;return new i.GlslLibRoutine(c)}getOutputUnpacked1DCoords(t,e){const n=`\\n        int getOutputCoords() {\\n          ivec2 resTexRC = ivec2(TexCoords.xy *\\n                                vec2(${e[0]}, ${e[1]}));\\n          return resTexRC.y * ${e[0]} + resTexRC.x;\\n        }\\n      `;return new i.GlslLibRoutine(n)}getOutputUnpacked2DCoords(t,e){const n=`\\n        ivec2 getOutputCoords() {\\n          ivec2 resTexRC = ivec2(TexCoords.xy *\\n                                vec2(${e[0]}, ${e[1]}));\\n          int index = resTexRC.y * ${e[0]} + resTexRC.x;\\n          int r = index / ${t[1]};\\n          int c = index - r * ${t[1]};\\n          return ivec2(r, c);\\n        }\\n      `;return new i.GlslLibRoutine(n)}getOutputUnpacked3DCoords(t,e){let n=\"\";const r=t.length;let o=null;r<2&&(o=[]),o=new Array(r-1),o[r-2]=t[r-1];for(let e=r-3;e>=0;--e)o[e]=o[e+1]*t[e+1];const a=[\"r\",\"c\",\"d\"],s=o.map(((t,e)=>`int ${a[e]} = index / ${t}; ${e===o.length-1?`int ${a[e+1]} = index - ${a[e]} * ${t}`:`index -= ${a[e]} * ${t}`};`)).join(\"\");return n=`\\n        ivec3 getOutputCoords() {\\n          ivec2 resTexRC = ivec2(TexCoords.xy *\\n                                vec2(${e[0]}, ${e[1]}));\\n          int index = resTexRC.y * ${e[0]} + resTexRC.x;\\n          ${s}\\n          return ivec3(r, c, d);\\n        }\\n      `,new i.GlslLibRoutine(n)}getOutputUnpacked4DCoords(t,e){let n=\"\";const r=t.length;let o=null;r<2&&(o=[]),o=new Array(r-1),o[r-2]=t[r-1];for(let e=r-3;e>=0;--e)o[e]=o[e+1]*t[e+1];const a=[\"r\",\"c\",\"d\",\"d2\"],s=o.map(((t,e)=>`int ${a[e]} = index / ${t}; ${e===o.length-1?`int ${a[e+1]} = index - ${a[e]} * ${t}`:`index -= ${a[e]} * ${t}`};`)).join(\"\");return n=`\\n      ivec4 getOutputCoords() {\\n          ivec2 resTexRC = ivec2(TexCoords.xy *\\n                                vec2(${e[0]}, ${e[1]}));\\n          int index = resTexRC.y * ${e[0]} + resTexRC.x;\\n          ${s}\\n          return ivec4(r, c, d, d2);\\n        }\\n      `,new i.GlslLibRoutine(n)}getOutputUnpacked5DCoords(t,e){let n=\"\";const r=t.length;let o=null;r<2&&(o=[]),o=new Array(r-1),o[r-2]=t[r-1];for(let e=r-3;e>=0;--e)o[e]=o[e+1]*t[e+1];const a=[\"r\",\"c\",\"d\",\"d2\",\"d3\"],s=o.map(((t,e)=>`int ${a[e]} = index / ${t}; ${e===o.length-1?`int ${a[e+1]} = index - ${a[e]} * ${t}`:`index -= ${a[e]} * ${t}`};`)).join(\"\");return n=`\\n      ivec5 getOutputCoords() {\\n          ivec2 resTexRC = ivec2(TexCoords.xy *\\n                                vec2(${e[0]}, ${e[1]}));\\n          int index = resTexRC.y * ${e[0]} + resTexRC.x;\\n          ${s}\\n          return ivec5(r, c, d, d2, d3);\\n        }\\n      `,new i.GlslLibRoutine(n)}getOutputUnpacked6DCoords(t,e){let n=\"\";const r=t.length;let o=null;r<2&&(o=[]),o=new Array(r-1),o[r-2]=t[r-1];for(let e=r-3;e>=0;--e)o[e]=o[e+1]*t[e+1];const a=[\"r\",\"c\",\"d\",\"d2\",\"d3\",\"d4\"],s=o.map(((t,e)=>`int ${a[e]} = index / ${t}; ${e===o.length-1?`int ${a[e+1]} = index - ${a[e]} * ${t}`:`index -= ${a[e]} * ${t}`};`)).join(\"\");return n=`\\n     ivec6 getOutputCoords() {\\n         ivec2 resTexRC = ivec2(TexCoords.xy *\\n                               vec2(${e[0]}, ${e[1]}));\\n         int index = resTexRC.y * ${e[0]} + resTexRC.x;\\n         ${s}\\n         return ivec6(r, c, d, d2, d3, d4);\\n       }\\n     `,new i.GlslLibRoutine(n)}getCommonUtilFuncs(){const t={};let e=\"uvFromFlat\";t[e]=new i.GlslLibRoutine(\"\\n    vec2 uvFromFlat(int texNumR, int texNumC, int index) {\\n      int texC = index / texNumR;\\n      int texR = index - texC * texNumR;\\n      // TODO: swap texR, texC order in following function so row is corresponding to u and column is corresponding to\\n      //       v.\\n      return (vec2(texR, texC) + halfCR) / vec2(texNumR, texNumC);\\n    }\\n    \"),e=\"packedUVfrom1D\",t[e]=new i.GlslLibRoutine(\"\\n      vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\\n        int texelIndex = index / 2;\\n        int texR = texelIndex / texNumC;\\n        int texC = texelIndex - texR * texNumC;\\n        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\\n      }\\n      \"),e=\"packedUVfrom2D\",t[e]=new i.GlslLibRoutine(\"\\n      vec2 packedUVfrom2D(int texNumR, int texNumC, int texelsInLogicalRow, int row, int col) {\\n        int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\\n        int texR = texelIndex / texNumC;\\n        int texC = texelIndex - texR * texNumC;\\n        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\\n      }\\n      \"),e=\"packedUVfrom3D\",t[e]=new i.GlslLibRoutine(\"\\n      vec2 packedUVfrom3D(int texNumR, int texNumC,\\n          int texelsInBatch, int texelsInLogicalRow, int b,\\n          int row, int col) {\\n        int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\\n        int texR = index / texNumC;\\n        int texC = index - texR * texNumC;\\n        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\\n      }\\n      \"),e=\"sampleTexture\";const n=(0,o.getGlsl)(this.context.glContext.version);return t[e]=new i.GlslLibRoutine(`\\n        float sampleTexture(sampler2D textureSampler, vec2 uv) {\\n            return ${n.texture2D}(textureSampler, uv).r;\\n        }`),t}getInputsSamplingSnippets(){const t={},e=this.context.outputTextureLayout;return this.context.programInfo.inputNames.forEach(((n,r)=>{const i=this.context.inputTextureLayouts[r],o=(0,s.generateShaderFuncNameFromInputSamplerName)(n);i.isPacked?t[o]=this.getPackedSamplerFromInput(o,n,i):t[o]=this.getUnpackedSamplerFromInput(o,n,i);const a=(0,s.generateShaderFuncNameFromInputSamplerNameAtOutCoords)(n);i.unpackedShape.length<=e.unpackedShape.length&&(i.isPacked?t[a]=this.getPackedSamplerAtOutputCoords(a,i,e,n):t[a]=this.getUnpackedSamplerAtOutputCoords(a,i,e,n))})),t}getPackedSamplerAtOutputCoords(t,e,n,o){const a=e.unpackedShape,u=n.unpackedShape,c=o,l=(0,s.generateShaderFuncNameFromInputSamplerName)(c),p=a.length,f=u.length,d=r.BroadcastUtil.getBroadcastDims(a,u),h=(0,s.getCoordsDataType)(f),g=f-p;let b;const m=(0,s.getGlChannels)();b=0===p?\"\":f<2&&d.length>=1?\"coords = 0;\":d.map((t=>`coords.${m[t+g]} = 0;`)).join(\"\\n\");let y=\"\";y=f<2&&p>0?\"coords\":a.map(((t,e)=>`coords.${m[e+g]}`)).join(\", \");let _=\"return outputValue;\";const v=1===r.ShapeUtil.size(a),w=1===r.ShapeUtil.size(u);if(1!==p||v||w){if(v&&!w)_=1===f?\"\\n          return vec4(outputValue.x, outputValue.x, 0., 0.);\\n        \":\"\\n          return vec4(outputValue.x);\\n        \";else if(d.length){const t=p-2,e=p-1;d.indexOf(t)>-1&&d.indexOf(e)>-1?_=\"return vec4(outputValue.x);\":d.indexOf(t)>-1?_=\"return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);\":d.indexOf(e)>-1&&(_=\"return vec4(outputValue.xx, outputValue.zz);\")}}else _=\"\\n        return vec4(outputValue.xy, outputValue.xy);\\n      \";const x=`\\n      vec4 ${t}() {\\n        ${h} coords = getOutputCoords();\\n        \\n        int lastDim = coords.${m[f-1]};\\n        coords.${m[f-1]} = coords.${m[f-2]};\\n        coords.${m[f-2]} = lastDim;\\n      \\n        ${b}\\n        vec4 outputValue = ${l}(${y});\\n        ${_}\\n      }\\n    `;return new i.GlslLibRoutine(x,[\"coordinates.getOutputCoords\"])}getUnpackedSamplerAtOutputCoords(t,e,n,o){const a=[n.width,n.height],u=[e.width,e.height],c=e.unpackedShape.length,l=n.unpackedShape.length,p=e.unpackedShape,f=n.unpackedShape,d=(0,s.generateShaderFuncNameFromInputSamplerName)(o);if(c===l&&r.ArrayUtil.arraysEqual(u,a)){const e=`\\n          float ${t}() {\\n            return sampleTexture(${o}, TexCoords);\\n          }\\n        `;return new i.GlslLibRoutine(e,[\"coordinates.sampleTexture\"])}const h=(0,s.getCoordsDataType)(l),g=r.BroadcastUtil.getBroadcastDims(p,f),b=l-c;let m;const y=(0,s.getGlChannels)();m=0===c?\"\":l<2&&g.length>=1?\"coords = 0;\":g.map((t=>`coords.${y[t+b]} = 0;`)).join(\"\\n\");let _=\"\";_=l<2&&c>0?\"coords\":e.unpackedShape.map(((t,e)=>`coords.${y[e+b]}`)).join(\", \");const v=`\\n        float ${t}() {\\n          ${h} coords = getOutputCoords();\\n          ${m}\\n          return ${d}(${_});\\n        }\\n      `;return new i.GlslLibRoutine(v,[\"coordinates.getOutputCoords\"])}getPackedSamplerFromInput(t,e,n){switch(n.unpackedShape.length){case 0:return this.getPackedSamplerScalar(t,e);case 1:return this.getPackedSampler1D(t,e,n);case 2:return this.getPackedSampler2D(t,e,n);case 3:return this.getPackedSampler3D(t,e,n);default:return this.getPackedSamplerND(t,e,n)}}getUnpackedSamplerFromInput(t,e,n){const r=n.unpackedShape;switch(r.length){case 0:return this.getUnpackedSamplerScalar(t,e,n);case 1:return this.getUnpackedSampler1D(t,e,n);case 2:return this.getUnpackedSampler2D(t,e,n);case 3:return this.getUnpackedSampler3D(t,e,n);case 4:return this.getUnpackedSampler4D(t,e,n);case 5:return this.getUnpackedSampler5D(t,e,n);case 6:return this.getUnpackedSampler6D(t,e,n);default:throw new Error(`Unsupported dimension ${r.length}-D`)}}getPackedSamplerScalar(t,e){const n=`\\n          vec4 ${t}() {\\n            return ${(0,o.getGlsl)(this.context.glContext.version).texture2D}(${e}, halfCR);\\n          }\\n        `;return new i.GlslLibRoutine(n)}getPackedSampler1D(t,e,n){const r=[n.width,n.height],a=[r[1],r[0]],s=(0,o.getGlsl)(this.context.glContext.version),u=`vec4 ${t}(int index) {\\n      vec2 uv = packedUVfrom1D(\\n      ${a[0]}, ${a[1]}, index);\\n      return ${s.texture2D}(${e}, uv);\\n    }`;return new i.GlslLibRoutine(u,[\"coordinates.packedUVfrom1D\"])}getPackedSampler2D(t,e,n){const a=n.unpackedShape,s=[n.width,n.height],u=(0,o.getGlsl)(this.context.glContext.version),c=s[0],l=s[1];if(null!=s&&r.ArrayUtil.arraysEqual(a,s)){const n=`vec4 ${t}(int row, int col) {\\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${l}.0, ${c}.0);\\n        return ${u.texture2D}(${e}, uv);\\n      }`;return new i.GlslLibRoutine(n)}const p=s,f=Math.ceil(a[1]/2),d=`vec4 ${t}(int row, int col) {\\n      vec2 uv = packedUVfrom2D(${p[1]}, ${p[0]}, ${f}, row, col);\\n      return ${u.texture2D}(${e}, uv);\\n    }`;return new i.GlslLibRoutine(d,[\"coordinates.packedUVfrom2D\"])}getPackedSampler3D(t,e,n){const r=n.unpackedShape,a=[n.width,n.height],u=[a[0],a[1]],c=(0,o.getGlsl)(this.context.glContext.version);if(1===r[0]){const o=r.slice(1),a=[1,2],u=(0,s.squeezeInputShape)(r,o),c=[\"b\",\"row\",\"col\"],l=JSON.parse(JSON.stringify(n));l.unpackedShape=u;const p=this.getPackedSamplerFromInput(t,e,l),f=`${p.routineBody}\\n      vec4 ${t}(int b, int row, int col) {\\n        return ${t}(${(0,s.getSqueezedParams)(c,a)});\\n      } `;return new i.GlslLibRoutine(f,p.dependencies)}const l=u[0],p=u[1],f=Math.ceil(r[2]/2),d=`vec4 ${t}(int b, int row, int col) {\\n      vec2 uv = packedUVfrom3D(\\n        ${p}, ${l}, ${f*Math.ceil(r[1]/2)}, ${f}, b, row, col);\\n      return ${c.texture2D}(${e}, uv);}`;return new i.GlslLibRoutine(d,[\"coordinates.packedUVfrom3D\"])}getPackedSamplerND(t,e,n){const r=n.unpackedShape,a=r.length,s=[n.width,n.height],u=(0,o.getGlsl)(this.context.glContext.version),c=[s[0],s[1]],l=c[1],p=c[0],f=Math.ceil(r[a-1]/2);let d=f*Math.ceil(r[a-2]/2),h=\"int b, int row, int col\",g=`b * ${d} + (row / 2) * ${f} + (col / 2)`;for(let t=2;t<a-1;t++)h=`int b${t}, `+h,d*=r[a-t-1],g=`b${t} * ${d} + `+g;const b=`vec4 ${t}(${h}) {\\n      int index = ${g};\\n      int texR = index / ${p};\\n      int texC = index - texR * ${p};\\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${p}, ${l});\\n      return ${u.texture2D}(${e}, uv);\\n    }`;return new i.GlslLibRoutine(b)}getUnpackedSamplerScalar(t,e,n){const[r,o]=[n.width,n.height];if(1===r&&1===o){const n=`\\n          float ${t}() {\\n            return sampleTexture(${e}, halfCR);\\n          }\\n        `;return new i.GlslLibRoutine(n,[\"coordinates.sampleTexture\"])}const a=`\\n        float ${t}() {\\n          int offset_${e} = coordsToOffset(TexCoords, ${r}, ${o});\\n          vec2 uv = uvFromFlat(${r}, ${o}, offset_${e});\\n          return sampleTexture(${e}, uv);\\n        }\\n      `;return new i.GlslLibRoutine(a,[\"coordinates.uvFromFlat\",\"coordinates.sampleTexture\",\"coordinates.coordsToOffset\"])}getUnpackedSampler1D(t,e,n){const r=n.width,o=n.height;if(1===o&&1===r){const n=`\\n        float ${t}(int index) {\\n          return sampleTexture(${e}, halfCR);\\n        }\\n      `;return new i.GlslLibRoutine(n,[\"coordinates.sampleTexture\"])}if(1===o){const n=`\\n          float ${t}(int index) {\\n            vec2 uv = vec2((float(index) + 0.5) / ${r}.0, 0.5);\\n            return sampleTexture(${e}, uv);\\n          }\\n        `;return new i.GlslLibRoutine(n,[\"coordinates.sampleTexture\"])}if(1===r){const n=`\\n          float ${t}(int index) {\\n            vec2 uv = vec2(0.5, (float(index) + 0.5) / ${o}.0);\\n            return sampleTexture(${e}, uv);\\n          }\\n        `;return new i.GlslLibRoutine(n,[\"coordinates.sampleTexture\"])}const a=`\\n        float ${t}(int index) {\\n          vec2 uv = uvFromFlat(${r}, ${o}, index);\\n          return sampleTexture(${e}, uv);\\n        }\\n      `;return new i.GlslLibRoutine(a,[\"coordinates.uvFromFlat\",\"coordinates.sampleTexture\"])}getUnpackedSampler2D(t,e,n){const o=n.unpackedShape,u=[n.height,n.width];if(null!=u&&r.ArrayUtil.arraysEqual(o,u)){const n=`\\n          float ${t}(int row, int col) {\\n            vec2 uv = (vec2(row, col) + halfCR) / vec2(${u[1]}.0, ${u[0]}.0);\\n            return sampleTexture(${e}, uv);\\n          }\\n        `;return new i.GlslLibRoutine(n,[\"coordinates.sampleTexture\"])}const{newShape:c,keptDims:l}=(0,a.squeezeShape)(o),p=c;if(p.length<o.length){const r=(0,s.squeezeInputShape)(o,p),a=JSON.parse(JSON.stringify(n));a.unpackedShape=r;const u=[\"col\",\"row\"],c=`\\n          ${this.getUnpackedSamplerFromInput(t,e,a).routineBody}\\n          float ${t}(int row, int col) {\\n            return ${t}(${(0,s.getSqueezedParams)(u,l)});\\n          }\\n        `;return new i.GlslLibRoutine(c,[\"coordinates.sampleTexture\"])}const f=u[1],d=u[0];if(1===d){const n=`\\n          float ${t}(int row, int col) {\\n            int offset_${e} = coordsToOffset(TexCoords, ${f}, ${d});\\n            float index = dot(vec3(row, col, offset_${e}), vec3(${o[1]}, 1, 1));\\n            vec2 uv = vec2(0.5, (index + 0.5) / ${f}.0);\\n            return sampleTexture(${e}, uv);\\n          }\\n        `;return new i.GlslLibRoutine(n,[\"coordinates.sampleTexture\",\"coordinates.coordsToOffset\"])}if(1===f){const n=`\\n          float ${t}(int row, int col) {\\n            int offset_${e} = coordsToOffset(TexCoords, ${f}, ${d});\\n            float index = dot(vec3(row, col, offset_${e}), vec3(${o[1]}, 1, 1));\\n            vec2 uv = vec2((index + 0.5) / ${d}.0, 0.5);\\n            return sampleTexture(${e}, uv);\\n          }\\n        `;return new i.GlslLibRoutine(n,[\"coordinates.sampleTexture\",\"coordinates.coordsToOffset\"])}const h=`\\n        float ${t}(int row, int col) {\\n          int index = col * ${o[1]} + row;\\n          vec2 uv = uvFromFlat(${f}, ${d}, index);\\n          return sampleTexture(${e}, uv);\\n        }\\n      `;return new i.GlslLibRoutine(h,[\"coordinates.uvFromFlat\",\"coordinates.sampleTexture\",\"coordinates.coordsToOffset\"])}getUnpackedSampler3D(t,e,n){const r=n.unpackedShape,o=r[1]*r[2],u=r[2],{newShape:c,keptDims:l}=(0,a.squeezeShape)(r),p=c;if(p.length<r.length){const o=(0,s.squeezeInputShape)(r,p),a=[\"batch\",\"col\",\"row\"],u=JSON.parse(JSON.stringify(n));u.unpackedShape=o;const c=this.getUnpackedSamplerFromInput(t,e,u),f=l.reverse(),d=`\\n          ${c.routineBody}\\n          float ${t}(int batch, int row, int col) {\\n            return ${t}(${(0,s.getSqueezedParams)(a,f)});\\n          }\\n        `;return new i.GlslLibRoutine(d,c.dependencies)}const f=`\\n          float ${t}(int depth, int row, int col) {\\n            // Explicitly use integer operations as dot() only works on floats.\\n            int index = depth * ${o} + col * ${u} + row;\\n            vec2 uv = uvFromFlat(${n.width}, ${n.height}, index);\\n            return sampleTexture(${e}, uv);\\n          }\\n      `;return new i.GlslLibRoutine(f,[\"coordinates.uvFromFlat\",\"coordinates.sampleTexture\",\"coordinates.coordsToOffset\"])}getUnpackedSampler4D(t,e,n){const r=n.unpackedShape,o=r[3],a=r[2]*o,s=`\\n        float ${t}(int row, int col, int depth, int depth2) {\\n          int index = row * ${r[1]*a} + col * ${a} +\\n              depth2 * ${o} + depth;\\n          vec2 uv = uvFromFlat(${n.width}, ${n.height}, index);\\n          return sampleTexture(${e}, uv);\\n        }\\n      `;return new i.GlslLibRoutine(s,[\"coordinates.uvFromFlat\",\"coordinates.sampleTexture\"])}getUnpackedSampler5D(t,e,n){const r=n.unpackedShape,o=r[4],u=r[3]*o,c=r[2]*u,l=r[1]*c,{newShape:p,keptDims:f}=(0,a.squeezeShape)(r);if(p.length<r.length){const o=(0,s.squeezeInputShape)(r,p),a=[\"row\",\"col\",\"depth\",\"depth2\",\"depth3\"],u=JSON.parse(JSON.stringify(n));u.unpackedShape=o;const c=`\\n          ${this.getUnpackedSamplerFromInput(t,e,u).routineBody}\\n          float ${t}(int row, int col, int depth, int depth2, int depth3) {\\n            return ${t}(${(0,s.getSqueezedParams)(a,f)});\\n          }\\n        `;return new i.GlslLibRoutine(c,[\"coordinates.sampleTexture\",\"coordinates.uvFromFlat\"])}const d=`\\n        float ${t}(int row, int col, int depth, int depth2, int depth3) {\\n          int index = row * ${l} + col * ${c} + depth * ${u} +\\n          depth3 * ${o} + depth2;\\n          vec2 uv = uvFromFlat(${n.width}, ${n.height}, index);\\n          return sampleTexture(${e}, uv);\\n        }\\n      `;return new i.GlslLibRoutine(d,[\"coordinates.sampleTexture\",\"coordinates.uvFromFlat\"])}getUnpackedSampler6D(t,e,n){const r=n.unpackedShape,o=r[5],u=r[4]*o,c=r[3]*u,l=r[2]*c,p=r[1]*l,{newShape:f,keptDims:d}=(0,a.squeezeShape)(r);if(f.length<r.length){const o=(0,s.squeezeInputShape)(r,f),a=[\"row\",\"col\",\"depth\",\"depth2\",\"depth3\",\"depth4\"],u=JSON.parse(JSON.stringify(n));u.unpackedShape=o;const c=`\\n            ${this.getUnpackedSamplerFromInput(t,e,u).routineBody}\\n            float ${t}(int row, int col, int depth,\\n              int depth2, int depth3, int depth4) {\\n              return ${t}(${(0,s.getSqueezedParams)(a,d)});\\n            }\\n          `;return new i.GlslLibRoutine(c,[\"coordinates.sampleTexture\",\"coordinates.uvFromFlat\"])}const h=`\\n          float ${t}(int row, int col, int depth,\\n            int depth2, int depth3, int depth4) {\\n            int index = row * ${p} + col * ${l} + depth * ${c} +\\n            depth2 * ${u} + depth3 * ${o} + depth4;\\n            vec2 uv = uvFromFlat(${n.width}, ${n.height}, index);\\n            return sampleTexture(${e}, uv);\\n          }\\n        `;return new i.GlslLibRoutine(h,[\"coordinates.uvFromFlat\",\"coordinates.sampleTexture\",\"coordinates.coordsToOffset\"])}toVec(){const t=this.context.outputTextureLayout,e=t.shape.length,n=t.strides,r=t.width,o=t.height,a=[];for(let t=0;t<e-1;++t)a.push(`\\n        c[${t}] = offset / ${n[t]};`),a.push(`\\n        offset -= c[${t}] * ${n[t]};`);a.push(`\\n        c[${e-1}] = offset;`);const s=`\\n      void toVec(vec2 texCoords, out int c[${e}]) {\\n        int offset = coordsToOffset(texCoords, ${r}, ${o});\\n        ${a.join(\"\")}\\n      }\\n      void toVec(int offset, out int c[${e}]) {\\n        ${a.join(\"\")}\\n      }\\n    `;return{toVec:new i.GlslLibRoutine(s,[\"coordinates.coordsToOffset\"])}}valueFrom(){const t={};return this.context.programInfo.inputNames.forEach(((e,n)=>{const r=this.context.inputTextureLayouts[n],o=(r.unpackedShape.length>0?r.unpackedShape:r.shape).length;let a=`_${e}`;t[a]=new i.GlslLibRoutine(this.getValueFromSingle(e,o,r.width,r.height,!1),[`shapeUtils.indicesToOffset${a}`,\"coordinates.offsetToCoords\",\"fragcolor.getColorAsFloat\"]),a+=\"_T\",t[a]=new i.GlslLibRoutine(this.getValueFromSingle(e,o,r.width,r.height,!0),[`shapeUtils.indicesToOffset${a}`,\"coordinates.offsetToCoords\",\"fragcolor.getColorAsFloat\"])})),t}getValueFromSingle(t,e,n,r,i){let a=`_${t}`;return i&&(a+=\"_T\"),`\\n        float ${a}(int m[${e}]) {\\n          int offset = indicesToOffset${a}(m);\\n          vec2 coords = offsetToCoords(offset, ${n}, ${r});\\n          float value = getColorAsFloat(${(0,o.getGlsl)(this.context.glContext.version).texture2D}(${t}, coords));\\n          return value;\\n        }\\n        `}getPackedValueFrom(t,e,n,r,i){let a=`_${t}_Pack`;return i&&(a+=\"_T\"),`\\n        vec4 ${a}(int m[${e}]) {\\n          int offset = indicesToOffset_${t}(m);\\n          vec2 coords = offsetToCoords(offset, ${n}, ${r});\\n          return ${(0,o.getGlsl)(this.context.glContext.version).texture2D}(${t}, coords);\\n        }\\n        `}}e.CoordsGlslLib=u},8520:(t,e)=>{\"use strict\";var n;Object.defineProperty(e,\"__esModule\",{value:!0}),e.TopologicalSortGlslRoutines=e.GlslLibRoutineNode=e.GlslLibRoutine=e.GlslLib=e.GlslContext=e.FunctionType=void 0,(n=e.FunctionType||(e.FunctionType={}))[n.ValueBased=0]=\"ValueBased\",n[n.Positional=1]=\"Positional\",e.GlslContext=class{constructor(t,e,n,r){this.glContext=t,this.programInfo=e,this.inputTextureLayouts=n,this.outputTextureLayout=r}},e.GlslLib=class{constructor(t){this.context=t}},e.GlslLibRoutine=class{constructor(t,e){this.routineBody=t,this.dependencies=e}},e.GlslLibRoutineNode=class{constructor(t,e,n){this.name=t,this.dependencies=n||[],e&&(this.routineBody=e)}addDependency(t){t&&this.dependencies.push(t)}},e.TopologicalSortGlslRoutines=class{static returnOrderedNodes(t){if(!t||0===t.length)return[];if(1===t.length)return t;const e=new Set,n=new Set,r=new Array;return this.createOrderedNodes(t,e,n,r),r}static createOrderedNodes(t,e,n,r){for(let i=0;i<t.length;++i)this.dfsTraverse(t[i],e,n,r)}static dfsTraverse(t,e,n,r){if(!t||n.has(t.name))return;if(e.has(t.name))throw new Error(\"Cyclic dependency detected. Can't topologically sort routines needed for shader.\");e.add(t.name);const i=t.dependencies;if(i&&i.length>0)for(let t=0;t<i.length;++t)this.dfsTraverse(i[t],e,n,r);r.push(t),n.add(t.name),e.delete(t.name)}}},7341:(t,e,n)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.EncodingGlslLib=void 0;const r=n(8520);class i extends r.GlslLib{constructor(t){super(t)}getFunctions(){return Object.assign(Object.assign({},this.encodeFloat32()),this.decodeFloat32())}getCustomTypes(){return{}}encodeFloat32(){return{encode:new r.GlslLibRoutine(\"highp vec4 encode(highp float f) {\\n        return vec4(f, 0.0, 0.0, 0.0);\\n      }\\n        \")}}decodeFloat32(){return{decode:new r.GlslLibRoutine(\"highp float decode(highp vec4 rgba) {\\n        return rgba.r;\\n      }\\n        \")}}encodeUint8(){const t=i.isLittleEndian()?\"rgba.rgba=rgba.abgr;\":\"\";return{encode:new r.GlslLibRoutine(`\\n      highp vec4 encode(highp float f) {\\n        highp float F = abs(f);\\n        highp float Sign = step(0.0,-f);\\n        highp float Exponent = floor(log2(F));\\n        highp float Mantissa = (exp2(- Exponent) * F);\\n        Exponent = floor(log2(F) + 127.0) + floor(log2(Mantissa));\\n        highp vec4 rgba;\\n        rgba[0] = 128.0 * Sign  + floor(Exponent*exp2(-1.0));\\n        rgba[1] = 128.0 * mod(Exponent,2.0) + mod(floor(Mantissa*128.0),128.0);\\n        rgba[2] = floor(mod(floor(Mantissa*exp2(23.0 -8.0)),exp2(8.0)));\\n        rgba[3] = floor(exp2(23.0)*mod(Mantissa,exp2(-15.0)));\\n        ${t}\\n        rgba = rgba / 255.0; // values need to be normalized to [0,1]\\n        return rgba;\\n    }\\n        `)}}decodeUint8(){const t=i.isLittleEndian()?\"rgba.rgba=rgba.abgr;\":\"\";return{decode:new r.GlslLibRoutine(`\\n        highp float decode(highp vec4 rgba) {\\n          rgba = rgba * 255.0; // values need to be de-normalized from [0,1] to [0,255]\\n          ${t}\\n          highp float Sign = 1.0 - step(128.0,rgba[0])*2.0;\\n          highp float Exponent = 2.0 * mod(rgba[0],128.0) + step(128.0,rgba[1]) - 127.0;\\n          highp float Mantissa = mod(rgba[1],128.0)*65536.0 + rgba[2]*256.0 +rgba[3] + float(0x800000);\\n          highp float Result =  Sign * exp2(Exponent) * (Mantissa * exp2(-23.0 ));\\n          return Result;\\n      }\\n        `)}}static isLittleEndian(){const t=new ArrayBuffer(4),e=new Uint32Array(t),n=new Uint8Array(t);if(e[0]=3735928559,239===n[0])return!0;if(222===n[0])return!1;throw new Error(\"unknown endianness\")}}e.EncodingGlslLib=i},9894:(t,e,n)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.FragColorGlslLib=void 0;const r=n(8520),i=n(5060);class o extends r.GlslLib{constructor(t){super(t)}getFunctions(){return Object.assign(Object.assign({},this.setFragColor()),this.getColorAsFloat())}getCustomTypes(){return{}}setFragColor(){const t=(0,i.getGlsl)(this.context.glContext.version);return{setFragColor:new r.GlslLibRoutine(`\\n        void setFragColor(float value) {\\n            ${t.output} = encode(value);\\n        }\\n        `,[\"encoding.encode\"])}}getColorAsFloat(){return{getColorAsFloat:new r.GlslLibRoutine(\"\\n        float getColorAsFloat(vec4 color) {\\n            return decode(color);\\n        }\\n        \",[\"encoding.decode\"])}}}e.FragColorGlslLib=o},2848:(t,e)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.replaceInlines=void 0;const n=/@inline[\\s\\n\\r]+(\\w+)[\\s\\n\\r]+([0-9a-zA-Z_]+)\\s*\\(([^)]*)\\)\\s*{(([^}]|[\\n\\r])*)}/gm;e.replaceInlines=function(t){const e={};let r;for(;null!==(r=n.exec(t));){const t=r[3].split(\",\").map((t=>{const e=t.trim().split(\" \");return e&&2===e.length?{type:e[0],name:e[1]}:null})).filter((t=>null!==t));e[r[2]]={params:t,body:r[4]}}for(const n in e){const i=\"(\\\\w+)?\\\\s+([_0-9a-zA-Z]+)\\\\s+=\\\\s+__FUNC__\\\\((.*)\\\\)\\\\s*;\".replace(\"__FUNC__\",n),o=new RegExp(i,\"gm\");for(;null!==(r=o.exec(t));){const i=r[1],o=r[2],a=r[3].split(\",\"),s=i?`${i} ${o};`:\"\";let u=e[n].body,c=\"\";e[n].params.forEach(((t,e)=>{t&&(c+=`${t.type} ${t.name} = ${a[e]};\\n`)})),u=`${c}\\n ${u}`,u=u.replace(\"return\",`${o} = `);const l=`\\n      ${s}\\n      {\\n        ${u}\\n      }\\n      `;t=t.replace(r[0],l)}}return t.replace(n,\"\")}},8879:(t,e,n)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.GlslPreprocessor=void 0;const r=n(8520),i=n(2848),o=n(5483),a=n(5060);e.GlslPreprocessor=class{constructor(t,e,n,i){this.libs={},this.glslLibRoutineDependencyGraph={},this.context=new r.GlslContext(t,e,n,i),Object.keys(o.glslRegistry).forEach((t=>{const e=new o.glslRegistry[t](this.context);this.libs[t]=e}));const a=this.glslLibRoutineDependencyGraph;for(const t in this.libs){const e=this.libs[t].getFunctions();for(const n in e){const i=t+\".\"+n;let o;a[i]?(o=a[i],o.routineBody=e[n].routineBody):(o=new r.GlslLibRoutineNode(i,e[n].routineBody),a[i]=o);const s=e[n].dependencies;if(s)for(let t=0;t<s.length;++t)if(a[s[t]])o.addDependency(a[s[t]]);else{const e=new r.GlslLibRoutineNode(s[t]);a[s[t]]=e,o.addDependency(e)}}}}preprocess(){const t=this.context.programInfo;let e=t.shaderSource;return this.context.programInfo.hasMain||(e=`${e}\\n      ${(0,a.getDefaultFragShaderMain)(this.context.glContext.version,this.context.outputTextureLayout.shape.length)}`),e=(0,i.replaceInlines)(e),`${(0,a.getFragShaderPreamble)(this.context.glContext.version)}\\n    ${this.getUniforms(t.inputNames,t.variables)}\\n    ${this.getImports(e)}\\n    ${e}`}getImports(t){const e=this.selectGlslLibRoutinesToBeIncluded(t);if(0===e.length)return\"\";let n=\"\";for(let t=0;t<e.length;++t){if(!e[t].routineBody)throw new Error(`Missing body for the Glsl Library routine: ${e[t].name}`);n+=e[t].routineBody+\"\\n\"}return n}selectGlslLibRoutinesToBeIncluded(t){const e=[];return Object.keys(this.glslLibRoutineDependencyGraph).forEach((n=>{const r=n.split(\".\")[1];-1!==t.indexOf(r)&&e.push(this.glslLibRoutineDependencyGraph[n])})),r.TopologicalSortGlslRoutines.returnOrderedNodes(e)}getUniforms(t,e){const n=[];if(t)for(const e of t)n.push(`uniform sampler2D ${e};`);if(e)for(const t of e)n.push(`uniform ${t.type} ${t.name}${t.arrayLength?`[${t.arrayLength}]`:\"\"};`);return n.join(\"\\n\")}}},5483:(t,e,n)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.glslRegistry=void 0;const r=n(5107),i=n(7341),o=n(9894),a=n(2655),s=n(3891);e.glslRegistry={encoding:i.EncodingGlslLib,fragcolor:o.FragColorGlslLib,vec:s.VecGlslLib,shapeUtils:a.ShapeUtilsGlslLib,coordinates:r.CoordsGlslLib}},2655:(t,e,n)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.ShapeUtilsGlslLib=void 0;const r=n(8520);class i extends r.GlslLib{constructor(t){super(t)}getFunctions(){return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({},this.bcastIndex()),this.bcastMatmulIndex()),this.offsetToIndices()),this.indicesToOffset()),this.incrementIndices())}getCustomTypes(){return{}}bcastIndex(){const t=this.context.outputTextureLayout.shape.length,e={};return this.context.programInfo.inputNames.forEach(((n,i)=>{const o=this.context.inputTextureLayouts[i].unpackedShape;if(o.length<=t){const i=o.length,a=t-i,s=`bcastIndices_${n}`;let u=\"\";for(let t=0;t<i;++t)u+=`\\n          realIndices[${t}] = int( mod(float(bcastedIndices[${a+t}]), ${o[t]}.0) );\\n          `;const c=`\\n        void ${s} (int bcastedIndices[${t}], out int realIndices[${i}]) {\\n          ${u}\\n        }\\n        `;e[s]=new r.GlslLibRoutine(c)}})),e}bcastMatmulIndex(){const t=this.context.outputTextureLayout.shape.length,e={};return this.context.programInfo.inputNames.forEach(((n,i)=>{const o=this.context.inputTextureLayouts[i].shape;if(!(o.length<2||o.length>t)){const i=o.length,a=t-i,s=`bcastMatmulIndices_${n}`;let u=\"\";for(let t=0;t<i-2;++t)u+=`\\n          realIndices[${t}] = int( mod(float(bcastedIndices[${a+t}]), ${o[t]}.0) );\\n          `;const c=`\\n        void ${s}(int bcastedIndices[${t}], out int realIndices[${i}]) {\\n          ${u}\\n          realIndices[${i-1}] = bcastedIndices[${t-1}];\\n          realIndices[${i-2}] = bcastedIndices[${t-2}];\\n        }\\n        `;e[s]=new r.GlslLibRoutine(c)}})),e}indicesToOffset(){const t={};return this.context.programInfo.inputNames.forEach(((e,n)=>{const o=this.context.inputTextureLayouts[n].shape,a=this.context.inputTextureLayouts[n].strides,s=o.length;let u=`indicesToOffset_${e}`;t[u]=new r.GlslLibRoutine(i.indexToOffsetSingle(u,s,a)),u=`indicesToOffset_${e}_T`,t[u]=new r.GlslLibRoutine(i.indexToOffsetSingle(u,s,a.slice().reverse()))})),t}static indexToOffsetSingle(t,e,n){let r=\"\";for(let t=e-1;t>=0;--t)r+=`\\n        offset += indices[${t}] * ${n[t]};\\n        `;return`\\n      int ${t}(int indices[${e}]) {\\n        int offset = 0;\\n        ${r}\\n        return offset;\\n      }\\n      `}offsetToIndices(){const t={};return this.context.programInfo.inputNames.forEach(((e,n)=>{const o=this.context.inputTextureLayouts[n].shape,a=this.context.inputTextureLayouts[n].strides,s=o.length;let u=`offsetToIndices_${e}`;t[u]=new r.GlslLibRoutine(i.offsetToIndicesSingle(u,s,a)),u=`offsetToIndices_${e}_T`,t[u]=new r.GlslLibRoutine(i.offsetToIndicesSingle(u,s,a.slice().reverse()))})),t}static offsetToIndicesSingle(t,e,n){const r=[];for(let t=0;t<e-1;++t)r.push(`\\n      indices[${t}] = offset / ${n[t]};`),r.push(`\\n        offset -= indices[${t}] * ${n[t]};`);return r.push(`\\n      indices[${e-1}] = offset;`),`\\n      void ${t}(int offset, out int indices[${e}]) {\\n        ${r.join(\"\")}\\n      }\\n      `}incrementIndices(){const t={};return this.context.programInfo.inputNames.forEach(((e,n)=>{const i=this.context.inputTextureLayouts[n].shape,o=i.length,a=`incrementIndices_${e}`;let s=\"\";for(let t=0;t<o;++t)s+=`\\n        shape[${t}] = ${i[t]};`;const u=`\\n        void ${a}(int axis, out int indices[${o}]) {\\n          int shape[${o}];\\n          ${s};\\n          for(int i = ${o} -1 ; i >= 0; --i) {\\n            if(i > axis) continue;\\n            indices[i] += 1;\\n            if(indices[i] < shape[i]) {\\n              break;\\n            }\\n            indices[i] = 0;\\n          }\\n        }\\n        `;t[a]=new r.GlslLibRoutine(u)})),t}}e.ShapeUtilsGlslLib=i},5060:(t,e)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.getDefaultFragShaderMain=e.getFragShaderPreamble=e.getVertexShaderSource=e.getGlsl=void 0;const n={version:\"\",attribute:\"attribute\",varyingVertex:\"varying\",varyingFrag:\"varying\",texture2D:\"texture2D\",output:\"gl_FragColor\",outputDeclaration:\"\"},r={version:\"#version 300 es\",attribute:\"in\",varyingVertex:\"out\",varyingFrag:\"in\",texture2D:\"texture\",output:\"outputColor\",outputDeclaration:\"out vec4 outputColor;\"};function i(t){return 1===t?n:r}e.getGlsl=i,e.getVertexShaderSource=function(t){const e=i(t);return`${e.version}\\n      precision highp float;\\n      ${e.attribute} vec3 position;\\n      ${e.attribute} vec2 textureCoord;\\n\\n      ${e.varyingVertex} vec2 TexCoords;\\n\\n      void main()\\n      {\\n          gl_Position = vec4(position, 1.0);\\n          TexCoords = textureCoord;\\n      }`},e.getFragShaderPreamble=function(t){const e=i(t);return`${e.version}\\n    precision highp float;\\n    precision highp int;\\n    precision highp sampler2D;\\n    ${e.varyingFrag} vec2 TexCoords;\\n    ${e.outputDeclaration}\\n    const vec2 halfCR = vec2(0.5, 0.5);\\n\\n    // Custom vector types to handle higher dimenalities.\\n    struct ivec5\\n    {\\n      int x;\\n      int y;\\n      int z;\\n      int w;\\n      int u;\\n    };\\n\\n    struct ivec6\\n    {\\n      int x;\\n      int y;\\n      int z;\\n      int w;\\n      int u;\\n      int v;\\n    };\\n\\n    int imod(int x, int y) {\\n      return x - y * (x / y);\\n    }\\n\\n    `},e.getDefaultFragShaderMain=function(t,e){return`\\n  void main() {\\n    int indices[${e}];\\n    toVec(TexCoords, indices);\\n    vec4 result = vec4(process(indices));\\n    ${i(t).output} = result;\\n  }\\n  `}},3891:(t,e,n)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.VecGlslLib=void 0;const r=n(8520);class i extends r.GlslLib{constructor(t){super(t)}getCustomTypes(){return{}}getFunctions(){return Object.assign(Object.assign(Object.assign(Object.assign({},this.binaryVecFunctions()),this.copyVec()),this.setVecItem()),this.getVecItem())}binaryVecFunctions(){const t=this.context.outputTextureLayout.shape.length,e={add:\"+=\",sub:\"-=\",mul:\"*=\",div:\"/=\"},n={};for(const i in e){const o=`${i}Vec`;let a=\"\";for(let n=0;n<t;++n)a+=`\\n          dest[${n}] ${e[i]} src[${n}];\\n          `;const s=`\\n        void ${o}(int src[${t}], out int dest[${t}]) {\\n          ${a}\\n        }\\n        `;n[o]=new r.GlslLibRoutine(s)}return n}copyVec(){const t=this.context.outputTextureLayout.shape.length;let e=\"\";for(let n=0;n<t;++n)e+=`\\n        dest[${n}] = src[${n}];\\n        `;const n=`\\n      void copyVec(int src[${t}], out int dest[${t}]) {\\n        ${e}\\n      }\\n      `;return{copyVec:new r.GlslLibRoutine(n)}}setVecItem(){const t=this.context.outputTextureLayout.shape.length;let e=`\\n        if(index < 0)\\n            index =${t} + index;\\n        if (index == 0)\\n            m[0] = value;\\n        `;for(let n=1;n<t-1;++n)e+=`\\n        else if (index == ${n})\\n            m[${n}] = value;\\n            `;e+=`\\n        else\\n            m[${t-1}] = value;\\n        `;const n=`\\n      void setVecItem(out int m[${t}], int index, int value) {\\n        ${e}\\n      }\\n        `;return{setVecItem:new r.GlslLibRoutine(n)}}getVecItem(){const t=this.context.outputTextureLayout.shape.length;let e=`\\n        if(index < 0)\\n            index = ${t} + index;\\n        if (index == 0)\\n            return m[0];\\n      `;for(let n=1;n<t-1;++n)e+=`\\n        else if (index == ${n})\\n            return m[${n}];\\n      `;e+=`\\n        else\\n            return m[${t-1}];\\n        `;const n=`\\n      int getVecItem(int m[${t}], int index) {\\n        ${e}\\n      }\\n    `;return{getVecItem:new r.GlslLibRoutine(n)}}}e.VecGlslLib=i},8316:(t,e,n)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.WebGLInferenceHandler=void 0;const r=n(3694),i=n(9162),o=n(2517),a=n(2403),s=n(7019),u=n(8710),c=n(5611),l=n(4057),p=n(2039);e.WebGLInferenceHandler=class{constructor(t){this.session=t,this.packedTextureDataCache=new Map,this.unpackedTextureDataCache=new Map}calculateTextureWidthAndHeight(t,e){return(0,l.calculateTextureWidthAndHeight)(this.session.layoutStrategy,t,e)}executeProgram(t,e){if(e.length<t.inputNames.length)throw new Error(`Input size mustn't be less than ${t.inputNames.length}.`);if(t.inputNames.length!==t.inputTypes.length)throw new Error(\"input names size does not match input types\");const n=[];for(let r=0;r<t.inputNames.length;++r)n[r]=this.getOrCreateTextureData(e[r],t.inputTypes[r]);const r=((t,e)=>{const n=e.map((t=>`${t.unpackedShape.join(\",\")};${t.width}x${t.height}`)).join(\"_\");let r=t.name;return t.cacheHint&&(r+=\"[\"+t.cacheHint+\"]\"),r+=\":\"+n,r})(t,n);let i=this.session.programManager.getArtifact(r);const o=i?i.programInfo:\"function\"==typeof t.get?t.get():t,a=(0,l.createTextureLayoutFromTextureType)(this.session.layoutStrategy,o.output.dims,o.output.textureType),s=this.createTextureData(a,o.output.type);return i||(i=this.session.programManager.build(o,n,s),this.session.programManager.setArtifact(r,i)),this.runProgram(i,n,s),s}run(t,e){return this.executeProgram(t,e).tensor}runProgram(t,e,n){for(let n=0;n<e.length;++n)if(!!e[n].isPacked!=(t.programInfo.inputTypes[n]===p.TextureType.packed))throw new Error(`input[${n}] property packed inconsistent`);if(!!n.isPacked!=(t.programInfo.output.textureType===p.TextureType.packed))throw new Error(\"output property packed inconsistent\");this.session.programManager.run(t,e,n)}getOrCreateTextureData(t,e){let n=this.getTextureData(t.dataId,e===p.TextureType.packed);if(!n&&(n=this.getTextureData(t.dataId,e!==p.TextureType.packed),n))return e===p.TextureType.packed?this.pack(n):this.unpack(n);if(!n){const r=(0,l.createTextureLayoutFromTextureType)(this.session.layoutStrategy,t.dims,e);if(e===p.TextureType.packedLastDimension){const n=1,r=4,i=t.dims;if(4===i.length){const o=[i[0],Math.ceil(i[1]*i[2]*i[3]/r)],a=(0,l.createTextureLayoutFromTextureType)(this.session.layoutStrategy,o,e);let s=t.numberData;if(i[1]*i[2]*i[3]%r!=0){const e=i[0],o=i[1]*i[2]*i[3],a=Math.ceil(o*n/r)*r;s=new Float32Array(e*a);for(let r=0;r<e;++r){const e=r*o,i=r*a+r%n*o;s.set(t.numberData.subarray(e,e+o),i)}}return this.createTextureData(a,t.type,s,t,1)}}if(e===p.TextureType.packed){const e=(0,l.createTextureLayoutFromShape)(this.session.layoutStrategy,t.dims,1,[],{reverseWH:!0}),r=this.createTextureData(e,t.type,t.numberData,t,1);n=this.pack(r)}else n=this.createTextureData(r,t.type,t.numberData,t,1)}return n}createTextureDataFromLayoutBindTensor(t,e,n,r){return this.createTextureData(t,e,n,r,1)}createTextureData(t,e,n,i,o){r.Logger.verbose(\"InferenceHandler\",`Creating TextureData: layout:[${JSON.stringify(t)}]`);const a=this.session.textureManager.createTextureFromLayout(e,t,n,o);return this.createTextureDataFromTexture(t,e,a,i)}reshapeUnpacked(t,e){const n=this.getOrCreateTextureData(t,p.TextureType.unpacked),r={channels:n.channels,height:n.height,width:n.width,shape:0!==e.length?e:[1],strides:o.ShapeUtil.computeStrides(e),unpackedShape:e};return this.createTextureDataFromTexture(r,t.type,n.texture).tensor}reshapePacked(t,e){const n=this.getOrCreateTextureData(t,p.TextureType.packed);if((0,s.isReshapeCheap)(t.dims,e)){const r={channels:n.channels,height:n.height,width:n.width,shape:0!==e.length?e:[1],strides:o.ShapeUtil.computeStrides(e),unpackedShape:e,isPacked:!0};return this.createTextureDataFromTexture(r,t.type,n.texture).tensor}const r=(0,s.processDims3D)(t.dims),i=(0,s.processDims3D)(e),a=this.reshapePacked(t,r),u=this.run((0,s.createPackedReshape3DProgramInfoLoader)(this,a,i),[a]);return this.reshapePacked(u,e)}cast(t,e){const n=this.getOrCreateTextureData(t,p.TextureType.unpacked);return this.createTextureDataFromTexture(n,e,n.texture).tensor}createTextureDataFromTexture(t,e,n,r,o){const a=Object.assign(Object.assign({},t),{tensor:r||new i.Tensor(t.unpackedShape,e,(t=>this.readTexture(a)),(async t=>this.readTextureAsync(a)),void 0,o),texture:n});return this.setTextureData(a.tensor.dataId,a,t.isPacked),a}getTextureData(t,e=!1){return this.session.isInitializer(t)?this.session.getTextureData(t,e):e?this.packedTextureDataCache.get(t):this.unpackedTextureDataCache.get(t)}setTextureData(t,e,n=!1){this.session.isInitializer(t)?this.session.setTextureData(t,e,n):(n?this.packedTextureDataCache:this.unpackedTextureDataCache).set(t,e)}isTextureLayoutCached(t,e=!1){return!!this.getTextureData(t.dataId,e)}dispose(){this.session.textureManager.clearActiveTextures(),this.packedTextureDataCache.forEach((t=>this.session.textureManager.releaseTexture(t))),this.packedTextureDataCache=new Map,this.unpackedTextureDataCache.forEach((t=>this.session.textureManager.releaseTexture(t))),this.unpackedTextureDataCache=new Map}readTexture(t){return t.isPacked?this.readTexture(this.unpack(t)):this.session.backend.glContext.isFloat32DownloadSupported?this.session.textureManager.readTexture(t,t.tensor.type,t.channels):this.session.textureManager.readUint8TextureAsFloat((0,u.encodeAsUint8)(this,t))}async readTextureAsync(t){return t.isPacked?this.readTextureAsync(this.unpack(t)):this.session.backend.glContext.isFloat32DownloadSupported?this.session.textureManager.readTextureAsync(t,t.tensor.type,t.channels):this.session.textureManager.readUint8TextureAsFloat((0,u.encodeAsUint8)(this,t))}pack(t){return this.executeProgram((0,a.createPackProgramInfoLoader)(this,t.tensor),[t.tensor])}unpack(t){return this.executeProgram((0,c.createUnpackProgramInfoLoader)(this,t.tensor),[t.tensor])}}},1640:function(t,e,n){\"use strict\";var r=this&&this.__createBinding||(Object.create?function(t,e,n,r){void 0===r&&(r=n);var i=Object.getOwnPropertyDescriptor(e,n);i&&!(\"get\"in i?!e.__esModule:i.writable||i.configurable)||(i={enumerable:!0,get:function(){return e[n]}}),Object.defineProperty(t,r,i)}:function(t,e,n,r){void 0===r&&(r=n),t[r]=e[n]}),i=this&&this.__setModuleDefault||(Object.create?function(t,e){Object.defineProperty(t,\"default\",{enumerable:!0,value:e})}:function(t,e){t.default=e}),o=this&&this.__importStar||function(t){if(t&&t.__esModule)return t;var e={};if(null!=t)for(var n in t)\"default\"!==n&&Object.prototype.hasOwnProperty.call(t,n)&&r(e,t,n);return i(e,t),e};Object.defineProperty(e,\"__esModule\",{value:!0}),e.WEBGL_OP_RESOLVE_RULES=void 0;const a=n(2898),s=o(n(7839)),u=n(4196),c=n(2069),l=n(8138),p=n(9663),f=n(5193),d=n(7992),h=n(1253),g=n(4776),b=n(6572),m=n(3346),y=n(5623),_=n(2870),v=n(2143),w=n(4939),x=n(718),T=n(2268),S=n(8117),O=n(2278),A=n(5524),E=n(5975),I=n(3933),P=n(6558),D=n(5723),$=n(3738),k=o(n(4909)),C=n(8428),F=n(9793);e.WEBGL_OP_RESOLVE_RULES=[[\"Abs\",\"\",\"6+\",k.abs],[\"Acos\",\"\",\"7+\",k.acos],[\"Add\",\"\",\"7+\",s.add],[\"And\",\"\",\"7+\",s.and],[\"Asin\",\"\",\"7+\",k.asin],[\"Atan\",\"\",\"7+\",k.atan],[\"AveragePool\",\"\",\"7+\",v.averagePool,v.parseAveragePoolAttributes],[\"BatchNormalization\",\"\",\"7+\",a.batchNormalization,a.parseBatchNormalizationAttributes],[\"Cast\",\"\",\"6+\",u.cast,u.parseCastAttributes],[\"Ceil\",\"\",\"6+\",k.ceil],[\"Clip\",\"\",\"6-10\",k.clip,k.parseClipAttributes],[\"Clip\",\"\",\"11+\",k.clipV11],[\"Concat\",\"\",\"4+\",c.concat,c.parseConcatAttributes],[\"Conv\",\"\",\"1+\",l.conv,l.parseConvAttributes],[\"ConvTranspose\",\"\",\"1+\",p.convTranspose,p.parseConvTransposeAttributes],[\"Cos\",\"\",\"7+\",k.cos],[\"Div\",\"\",\"7+\",s.div],[\"Dropout\",\"\",\"7+\",k.identity],[\"DepthToSpace\",\"\",\"1+\",f.depthToSpace,f.parseDepthToSpaceAttributes],[\"Equal\",\"\",\"7+\",s.equal],[\"Elu\",\"\",\"6+\",k.elu,k.parseEluAttributes],[\"Exp\",\"\",\"6+\",k.exp],[\"Flatten\",\"\",\"1+\",d.flatten,d.parseFlattenAttributes],[\"Floor\",\"\",\"6+\",k.floor],[\"FusedConv\",\"com.microsoft\",\"1+\",l.conv,l.parseConvAttributes],[\"Gather\",\"\",\"1+\",h.gather,h.parseGatherAttributes],[\"Gemm\",\"\",\"7-10\",g.gemm,g.parseGemmAttributesV7],[\"Gemm\",\"\",\"11+\",g.gemm,g.parseGemmAttributesV11],[\"GlobalAveragePool\",\"\",\"1+\",v.globalAveragePool,v.parseGlobalAveragePoolAttributes],[\"GlobalMaxPool\",\"\",\"1+\",v.globalMaxPool],[\"Greater\",\"\",\"7+\",s.greater],[\"Identity\",\"\",\"1+\",k.identity],[\"ImageScaler\",\"\",\"1+\",b.imageScaler,b.parseImageScalerAttributes],[\"InstanceNormalization\",\"\",\"6+\",m.instanceNormalization,m.parseInstanceNormalizationAttributes],[\"LeakyRelu\",\"\",\"6+\",k.leakyRelu,k.parseLeakyReluAttributes],[\"Less\",\"\",\"7+\",s.less],[\"Log\",\"\",\"6+\",k.log],[\"MatMul\",\"\",\"1+\",y.matMul,y.parseMatMulAttributes],[\"MaxPool\",\"\",\"1+\",v.maxPool,v.parseMaxPoolAttributes],[\"Mul\",\"\",\"7+\",s.mul],[\"Neg\",\"\",\"6+\",k.neg],[\"Not\",\"\",\"1+\",k.not],[\"Or\",\"\",\"7+\",s.or],[\"Pad\",\"\",\"2-10\",_.padV2,_.parsePadAttributesV2],[\"Pad\",\"\",\"11+\",_.padV11,_.parsePadAttributesV11],[\"Pow\",\"\",\"7+\",s.pow],[\"PRelu\",\"\",\"7+\",s.pRelu],[\"ReduceLogSum\",\"\",\"1+\",w.reduceLogSum,w.parseReduceAttributes],[\"ReduceMax\",\"\",\"1+\",w.reduceMax,w.parseReduceAttributes],[\"ReduceMean\",\"\",\"1+\",w.reduceMean,w.parseReduceAttributes],[\"ReduceMin\",\"\",\"1+\",w.reduceMin,w.parseReduceAttributes],[\"ReduceProd\",\"\",\"1+\",w.reduceProd,w.parseReduceAttributes],[\"ReduceSum\",\"\",\"1-12\",w.reduceSum,w.parseReduceAttributes],[\"ReduceSumSquare\",\"\",\"1+\",w.reduceLogSumSquare,w.parseReduceAttributes],[\"Relu\",\"\",\"6+\",k.relu],[\"Reshape\",\"\",\"5+\",x.reshape],[\"Resize\",\"\",\"10\",T.resize,T.parseResizeAttributesV10],[\"Resize\",\"\",\"11+\",T.resize,T.parseResizeAttributesV11],[\"Shape\",\"\",\"1+\",S.shape],[\"Sigmoid\",\"\",\"6+\",k.sigmoid],[\"Sin\",\"\",\"7+\",k.sin],[\"Slice\",\"\",\"10+\",O.sliceV10],[\"Slice\",\"\",\"1-9\",O.slice,O.parseSliceAttributes],[\"Softmax\",\"\",\"1-12\",A.softmax,A.parseSoftmaxAttributes],[\"Softmax\",\"\",\"13+\",A.softmaxV13,A.parseSoftmaxAttributesV13],[\"Split\",\"\",\"2-12\",E.split,E.parseSplitAttributes],[\"Sqrt\",\"\",\"6+\",k.sqrt],[\"Squeeze\",\"\",\"1-12\",I.squeeze,I.parseSqueezeAttributes],[\"Squeeze\",\"\",\"13+\",I.squeezeV13],[\"Sub\",\"\",\"7+\",s.sub],[\"Sum\",\"\",\"6+\",P.sum],[\"Tan\",\"\",\"7+\",k.tan],[\"Tanh\",\"\",\"6+\",k.tanh],[\"Tile\",\"\",\"6+\",D.tile],[\"Transpose\",\"\",\"1+\",$.transpose,$.parseTransposeAttributes],[\"Upsample\",\"\",\"7-8\",F.upsample,F.parseUpsampleAttributesV7],[\"Upsample\",\"\",\"9\",F.upsample,F.parseUpsampleAttributesV9],[\"Unsqueeze\",\"\",\"1-12\",C.unsqueeze,C.parseUnsqueezeAttributes],[\"Unsqueeze\",\"\",\"13+\",C.unsqueezeV13],[\"Xor\",\"\",\"7+\",s.xor]]},2898:(t,e,n)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.parseBatchNormalizationAttributes=e.batchNormalization=void 0;const r=n(246),i=n(5060),o=n(2039),a={name:\"BatchNormalization\",inputNames:[\"A\",\"Scale\",\"B\",\"Mean\",\"Variance\"],inputTypes:[o.TextureType.unpacked,o.TextureType.unpacked,o.TextureType.unpacked,o.TextureType.unpacked,o.TextureType.unpacked]};e.batchNormalization=(t,e,n)=>(u(e),[t.run(Object.assign(Object.assign({},a),{cacheHint:n.cacheKey,get:()=>s(t,e,n)}),e)]),e.parseBatchNormalizationAttributes=t=>{const e=t.attributes.getFloat(\"epsilon\",1e-5),n=t.attributes.getFloat(\"momentum\",.9),i=t.attributes.getInt(\"spatial\",1);return(0,r.createAttributeWithCacheKey)({epsilon:e,momentum:n,spatial:i})};const s=(t,e,n)=>{const r=(0,i.getGlsl)(t.session.backend.glContext.version),s=e[0].dims.length,[u,c]=t.calculateTextureWidthAndHeight(e[1].dims,o.TextureType.unpacked),l=`\\n  float process(int[${s}] indices) {\\n    vec2 position = offsetToCoords(indices[1], ${u}, ${c});\\n    float scale = getColorAsFloat(${r.texture2D}(Scale, position));\\n    float mean = getColorAsFloat(${r.texture2D}(Mean, position));\\n    float variance = getColorAsFloat(${r.texture2D}(Variance, position));\\n    float b = getColorAsFloat(${r.texture2D}(B, position));\\n\\n    return scale * ( (_A(indices) - mean) / sqrt(variance + float(${n.epsilon})) ) + b;\\n  }`;return Object.assign(Object.assign({},a),{output:{dims:e[0].dims,type:e[0].type,textureType:o.TextureType.unpacked},shaderSource:l})},u=t=>{if(!t||5!==t.length)throw new Error(\"BatchNormalization requires 5 inputs.\");const e=t[0],n=t[1],r=t[2],i=t[3],o=t[4];if(e.dims.length<3||1!==n.dims.length||1!==r.dims.length||1!==i.dims.length||1!==o.dims.length)throw new Error(\"invalid input shape.\");if(n.dims[0]!==e.dims[1]||r.dims[0]!==e.dims[1]||i.dims[0]!==e.dims[1]||o.dims[0]!==e.dims[1])throw new Error(\"invalid input shape.\");if(\"float32\"!==e.type&&\"float64\"!==e.type||\"float32\"!==n.type&&\"float64\"!==n.type||\"float32\"!==r.type&&\"float64\"!==r.type||\"float32\"!==i.type&&\"float64\"!==i.type||\"float32\"!==o.type&&\"float64\"!==o.type)throw new Error(\"invalid input tensor types.\")}},7839:(t,e,n)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.xor=e.sub=e.pRelu=e.pow=e.or=e.mul=e.less=e.greater=e.equal=e.div=e.and=e.add=e.glslPRelu=e.glslPow=e.glslXor=e.glslOr=e.glslAnd=e.glslLess=e.glslGreater=e.glslEqual=e.glslSub=e.glslMul=e.glslDiv=e.glslAdd=void 0;const r=n(2517),i=n(8520),o=n(5060),a=n(2039);function s(){const t=\"add_\";return{body:`\\n  float ${t}(float a, float b) {\\n    return a + b;\\n  }\\n  vec4 ${t}(vec4 v1, vec4 v2) {\\n    return v1 + v2;\\n  }\\n  `,name:t,type:i.FunctionType.ValueBased}}function u(){const t=\"div_\";return{body:`\\n  float ${t}(float a, float b) {\\n    return a / b;\\n  }\\n  vec4 ${t}(vec4 v1, vec4 v2) {\\n    return v1 / v2;\\n  }\\n  `,name:t,type:i.FunctionType.ValueBased}}function c(){const t=\"mul_\";return{body:`\\n  float ${t}(float a, float b) {\\n    return a * b;\\n  }\\n  vec4 ${t}(vec4 v1, vec4 v2) {\\n    return v1 * v2;\\n  }\\n  `,name:t,type:i.FunctionType.ValueBased}}function l(){const t=\"sub_\";return{body:`\\n  float ${t}(float a, float b) {\\n    return a - b;\\n  }\\n  vec4 ${t}(vec4 v1, vec4 v2) {\\n    return v1 - v2;\\n  }\\n  `,name:t,type:i.FunctionType.ValueBased}}function p(){const t=\"equal_\";return{body:`\\n  float ${t}(float a, float b) {\\n    return float(a == b);\\n  }\\n  vec4 ${t}(vec4 v1, vec4 v2) {\\n    return vec4(equal(v1, v2));\\n  }\\n  `,name:t,type:i.FunctionType.ValueBased}}function f(){const t=\"greater_\";return{body:`\\n  float ${t}(float a, float b) {\\n    return float(a > b);\\n  }\\n  vec4 ${t}(vec4 v1, vec4 v2) {\\n    return vec4( v1.r > v2.r ,\\n      v1.g > v2.g,\\n      v1.b > v2.b,\\n      v1.a > v2.a );\\n  }\\n  `,name:t,type:i.FunctionType.ValueBased}}function d(){const t=\"less_\";return{body:`\\n  float ${t}(float a, float b) {\\n    return float(a < b);\\n  }\\n  vec4 ${t}(vec4 v1, vec4 v2) {\\n    return vec4( v1.r < v2.r ,\\n                v1.g < v2.g,\\n                v1.b < v2.b,\\n                v1.a < v2.a );\\n  }\\n  `,name:t,type:i.FunctionType.ValueBased}}function h(){const t=\"and_\";return{body:`\\n  float ${t}(float a, float b) {\\n    return float( bool(a) && bool(b) );\\n  }\\n  vec4 ${t}(vec4 v1, vec4 v2) {\\n    bvec4 b1 = bvec4(v1);\\n    bvec4 b2 = bvec4(v2);\\n    return vec4( b1.r && b2.r ,\\n                b1.g && b2.g,\\n                b1.b && b2.b,\\n                b1.a && b2.a );\\n  }\\n  `,name:t,type:i.FunctionType.ValueBased}}function g(){const t=\"or_\";return{body:`\\n  float ${t}(float a, float b) {\\n    return float( bool(a) || bool(b) );\\n  }\\n  vec4 ${t}(vec4 v1, vec4 v2) {\\n    bvec4 b1 = bvec4(v1);\\n    bvec4 b2 = bvec4(v2);\\n    return vec4( b1.r || b2.r ,\\n                b1.g || b2.g,\\n                b1.b || b2.b,\\n                b1.a || b2.a );\\n  }\\n  `,name:t,type:i.FunctionType.ValueBased}}function b(){const t=\"xor_\";return{body:`\\n  float ${t}(float a, float b) {\\n    return float( bool(a) ^^ bool(b) );\\n  }\\n  vec4 ${t}(vec4 v1, vec4 v2) {\\n    bvec4 b1 = bvec4(v1);\\n    bvec4 b2 = bvec4(v2);\\n    return vec4( b1.r ^^ b2.r ,\\n                b1.g ^^ b2.g,\\n                b1.b ^^ b2.b,\\n                b1.a ^^ b2.a );\\n  }\\n  `,name:t,type:i.FunctionType.ValueBased}}function m(){return function(t){const e=`${t}_`;return{body:`\\n  float ${e}(float a, float b) {\\n    return ${t}(a, b);\\n  }\\n  vec4 ${e}(vec4 v1, vec4 v2) {\\n    return ${t}(v1, v2);\\n  }\\n  `,name:e,type:i.FunctionType.ValueBased}}(\"pow\")}function y(){const t=\"prelu_\";return{body:`\\n  float ${t}(float a, float b) {\\n    return a < 0.0 ? a * b: a;\\n  }\\n  vec4 ${t}(vec4 v1, vec4 v2) {\\n    return vec4(\\n      v1.r < 0.0 ? v1.r * v2.r: v1.r,\\n      v1.g < 0.0 ? v1.g * v2.g: v1.g,\\n      v1.b < 0.0 ? v1.b * v2.b: v1.b,\\n      v1.a < 0.0 ? v1.a * v2.a: v1.a\\n      );\\n  }\\n  `,name:t,type:i.FunctionType.ValueBased}}e.glslAdd=s,e.glslDiv=u,e.glslMul=c,e.glslSub=l,e.glslEqual=p,e.glslGreater=f,e.glslLess=d,e.glslAnd=h,e.glslOr=g,e.glslXor=b,e.glslPow=m,e.glslPRelu=y;const _=(t,e,n,r=e[0].type,i)=>{const o=t.session.pack?a.TextureType.packed:a.TextureType.unpacked;return{name:n.name,inputNames:[\"A\",\"B\"],inputTypes:[o,o],cacheHint:i,get:()=>v(t,e,n,r)}},v=(t,e,n,i=e[0].type)=>{const s=t.session.pack?a.TextureType.packed:a.TextureType.unpacked,u=!r.ShapeUtil.areEqual(e[0].dims,e[1].dims);let c=e[0].dims;const l=t.session.pack;if(u){const a=r.BroadcastUtil.calcShape(e[0].dims,e[1].dims,!1);if(!a)throw new Error(\"Can't perform binary op on the given tensors\");c=a;const u=c.length,p=0!==e[0].dims.length?e[0].dims.length:1,f=0!==e[1].dims.length?e[1].dims.length:1,d=0!==e[0].dims.length?\"bcastIndices_A(indices, aindices);\":\"aindices[0] = 0;\",h=0!==e[1].dims.length?\"bcastIndices_B(indices, bindices);\":\"bindices[0] = 0;\",g=(0,o.getGlsl)(t.session.backend.glContext.version),b=l?`\\n      ${n.body}\\n      void main() {\\n        vec4 a = getAAtOutCoords();\\n        vec4 b = getBAtOutCoords();\\n        vec4 result = ${n.name}(a, b);\\n        ${g.output} = result;\\n      }`:`\\n      ${n.body}\\n      float process(int indices[${u}]) {\\n        int aindices[${p}];\\n        int bindices[${f}];\\n        ${d}\\n        ${h}\\n        return ${n.name}(_A(aindices), _B(bindices));\\n      }`;return{name:n.name,inputNames:[\"A\",\"B\"],inputTypes:[s,s],output:{dims:c,type:i,textureType:s},shaderSource:b,hasMain:l}}const p=(0,o.getGlsl)(t.session.backend.glContext.version),f=`\\n    ${n.body}\\n    void main() {\\n      vec4 v1 = ${p.texture2D}(A, TexCoords);\\n      vec4 v2 = ${p.texture2D}(B, TexCoords);\\n      vec4 result = ${n.name}(v1, v2);\\n      ${p.output} = result;\\n    }\\n    `;return{name:n.name,inputNames:[\"A\",\"B\"],inputTypes:[s,s],output:{dims:e[0].dims,type:i,textureType:s},shaderSource:f,hasMain:!0}};e.add=(t,e)=>[t.run(_(t,e,s()),e)],e.and=(t,e)=>[t.run(_(t,e,h(),\"bool\"),e)],e.div=(t,e)=>[t.run(_(t,e,u()),e)],e.equal=(t,e)=>[t.run(_(t,e,p(),\"bool\"),e)],e.greater=(t,e)=>[t.run(_(t,e,f(),\"bool\"),e)],e.less=(t,e)=>[t.run(_(t,e,d(),\"bool\"),e)],e.mul=(t,e)=>[t.run(_(t,e,c()),e)],e.or=(t,e)=>[t.run(_(t,e,g(),\"bool\"),e)],e.pow=(t,e)=>[t.run(_(t,e,m()),e)],e.pRelu=(t,e)=>[t.run(_(t,e,y()),e)],e.sub=(t,e)=>[t.run(_(t,e,l()),e)],e.xor=(t,e)=>[t.run(_(t,e,b(),\"bool\"),e)]},4196:(t,e,n)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.parseCastAttributes=e.cast=void 0;const r=n(2517);e.cast=(t,e,n)=>(i(e),[t.cast(e[0],n)]),e.parseCastAttributes=t=>r.ProtoUtil.tensorDataTypeFromProto(t.attributes.getInt(\"to\"));const i=t=>{if(!t||1!==t.length)throw new Error(\"Cast requires 1 input.\");if(\"string\"===t[0].type)throw new Error(\"Invalid input type.\")}},1163:(t,e,n)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.createPackedConcatProgramInfoLoader=void 0;const r=n(5060),i=n(2039),o=n(9390),a=n(2827);e.createPackedConcatProgramInfoLoader=(t,e,n)=>{const u=(c=e.length,l=n.cacheKey,{name:\"Concat (packed)\",inputNames:Array.from({length:c},((t,e)=>`X${e}`)),inputTypes:Array(c).fill(i.TextureType.packed),cacheHint:l});var c,l;return Object.assign(Object.assign({},u),{get:()=>((t,e,n,u)=>{const c=n[0].dims.slice();if(u>=c.length||u<-1*c.length)throw new Error(\"axis specified for concat doesn't match input dimensionality\");u<0&&(u=c.length+u);const l=c.slice(0);for(let t=1;t<n.length;t++){const e=n[t].dims.slice();for(let t=0;t<c.length;t++)if(t===u)l[u]+=e[t];else if(c[t]!==e[t])throw new Error(\"non concat dimensions must match\")}const p=l.length,f=(0,a.getChannels)(\"coords\",p),d=(0,o.getCoordsDataType)(p),h=(0,a.unpackFromChannel)(),g=n.map((t=>t.dims)),b=(0,o.getGlChannels)(p),m=new Array(g.length-1);m[0]=g[0][u];for(let t=1;t<m.length;t++)m[t]=m[t-1]+g[t][u];const y=b[u],_=b.slice(-2),v=b.join();let w=`if (${y} < ${m[0]}) {\\n        return getChannel(\\n            getX0(${v}), vec2(${_.join()}));\\n        }`;for(let t=1;t<m.length;t++){const e=m[t-1];w+=`\\n            if (${y} < ${m[t]}  && ${y} >= ${m[t-1]}) {\\n              return getChannel(\\n                getX${t}(${s(b,y,e)}),\\n                vec2(${s(_,y,e)}));\\n            }`}const x=m.length,T=m[m.length-1];w+=`\\n            return getChannel(\\n              getX${x}(${s(b,y,T)}),\\n              vec2(${s(_,y,T)}));`;const S=(0,r.getGlsl)(t.session.backend.glContext.version),O=`\\n          ${h}\\n          float getValue(${b.map((t=>\"int \"+t))}) {\\n            ${w}\\n          }\\n\\n          void main() {\\n            ${d} coords = getOutputCoords();\\n            int lastDim = coords.${b[p-1]};\\n            coords.${b[p-1]} = coords.${b[p-2]};\\n            coords.${b[p-2]} = lastDim;\\n\\n            vec4 result = vec4(getValue(${f}), 0., 0., 0.);\\n\\n            ${f[p-1]} = ${f[p-1]} + 1;\\n            if (${f[p-1]} < ${l[p-1]}) {\\n              result.g = getValue(${f});\\n            }\\n\\n            ${f[p-2]} = ${f[p-2]} + 1;\\n            if (${f[p-2]} < ${l[p-2]}) {\\n              result.a = getValue(${f});\\n            }\\n\\n            ${f[p-1]} = ${f[p-1]} - 1;\\n            if (${f[p-2]} < ${l[p-2]} &&\\n                ${f[p-1]} < ${l[p-1]}) {\\n              result.b = getValue(${f});\\n            }\\n            ${S.output} = result;\\n          }\\n        `;return Object.assign(Object.assign({},e),{output:{dims:l,type:n[0].type,textureType:i.TextureType.packed},shaderSource:O,hasMain:!0})})(t,u,e,n.axis)})};const s=(t,e,n)=>{const r=t.indexOf(e);return t.map(((t,e)=>e===r?`${t} - ${n}`:t)).join()}},2069:(t,e,n)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.parseConcatAttributes=e.concat=void 0;const r=n(246),i=n(2039),o=n(1163);e.concat=(t,e,n)=>(p(e),t.session.pack&&e[0].dims.length>1?[t.run((0,o.createPackedConcatProgramInfoLoader)(t,e,n),e)]:[t.run(a(t,e,n),e)]);const a=(t,e,n)=>{const r=(o=e.length,a=n.cacheKey,{name:\"Concat\",inputNames:Array.from({length:o},((t,e)=>`X${e}`)),inputTypes:Array(o).fill(i.TextureType.unpacked),cacheHint:a});var o,a;return Object.assign(Object.assign({},r),{get:()=>((t,e,n,r)=>{const o=n[0].dims.slice();if(r>=o.length||r<-1*o.length)throw new Error(\"axis specified for concat doesn't match input dimensionality\");r<0&&(r=o.length+r);const a=o.slice(0);for(let t=1;t<n.length;t++){const e=n[t].dims.slice();for(let t=0;t<o.length;t++)if(t===r)a[r]+=e[t];else if(o[t]!==e[t])throw new Error(\"non concat dimensions must match\")}const p=a.length,f=new Array(n.length);let d=0;for(let t=0;t<f.length;++t)d+=n[t].dims[r],f[t]=d;let h=\"\";h=n.length<5?s(f):u(f);const g=`\\n        ${c(n.length,p)}\\n        ${l(f)}\\n        ${h}\\n        float process(int indices[${p}]) {\\n          int textureIndex = getTextureWhereDataResides (indices[${r}]);\\n\\n          if(textureIndex != 0) {\\n            indices[${r}] = indices[${r}] - int(getSizeInConcatAxisValueFromIndex(textureIndex-int(1)));\\n          }\\n\\n          return fetchDataFromCorrectTexture(textureIndex, indices);\\n        }`;return Object.assign(Object.assign({},e),{output:{dims:a,type:n[0].type,textureType:i.TextureType.unpacked},shaderSource:g})})(0,r,e,n.axis)})},s=t=>{const e=t.map(((t,e)=>`if(index<${t}) {return ${e};}\\n`));return`int getTextureWhereDataResides(int index) {\\n      ${e.join(\"\")}\\n    }`},u=t=>s(t),c=(t,e)=>{const n=[`float fetchDataFromCorrectTexture(int textureIndex, int indices[${e}]) {`];for(let e=0;e<t;++e)0===e?n.push(`\\tif (textureIndex == ${e}) { return _X${e}(indices); }`):e===t-1?n.push(`\\telse { return _X${e}(indices); }`):n.push(`\\telse if (textureIndex == ${e}) { return _X${e}(indices); }`);return n.push(\"\\t}\"),n.join(\"\\n\")},l=t=>{const e=[\"int getSizeInConcatAxisValueFromIndex(int index) {\"];for(let n=0;n<t.length;++n)0===n?e.push(`\\tif (index == ${n}) { return ${t[n]}; }`):n===t.length-1?e.push(`\\telse { return ${t[n]}; }`):e.push(`\\telse if (index == ${n}) { return ${t[n]}; }`);return e.push(\"\\t}\"),e.join(\"\\n\")};e.parseConcatAttributes=t=>(0,r.createAttributeWithCacheKey)({axis:t.attributes.getInt(\"axis\")});const p=t=>{if(!t||t.length<1)throw new Error(\"too few inputs\");const e=t[0].type,n=t[0].dims.length;if(\"string\"===e)throw new Error(\"string tensor is not supported yet\");for(const r of t){if(r.type!==e)throw new Error(\"input tensors should be one type\");if(r.dims.length!==n)throw new Error(\"input tensors should have the same shape\")}}},4770:(t,e,n)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.createUnpackedGroupedConvProgramInfoLoader=void 0;const r=n(3694),i=n(5060),o=n(2039),a=n(8138),s=n(2823);e.createUnpackedGroupedConvProgramInfoLoader=(t,e,n)=>{const u=(c=e.length>2,l=n.cacheKey,{name:\"GroupedConv\",inputNames:c?[\"X\",\"W\",\"Bias\"]:[\"X\",\"W\"],inputTypes:c?[o.TextureType.unpacked,o.TextureType.unpacked,o.TextureType.unpacked]:[o.TextureType.unpacked,o.TextureType.unpacked],cacheHint:l});var c,l;return Object.assign(Object.assign({},u),{get:()=>((t,e,n,u)=>{const c=e.length>2?\"value += getBias(output_channel);\":\"\",l=e[0].dims.slice(),p=e[1].dims.slice(),f=p[0]/u.group;r.Logger.verbose(\"GroupedConv\",`autpPad:${u.autoPad}, dilations:${u.dilations}, group:${u.group}, kernelShape:${u.kernelShape}, pads:${u.pads}, strides:${u.strides}`);const d=(0,a.calculateOutputShape)(l,p,u.dilations,u.pads,u.strides),h=(0,i.getGlsl)(t.session.backend.glContext.version),{activationFunction:g,applyActivation:b}=(0,s.getActivationSnippet)(u),m=`\\n  const ivec2 strides = ivec2(${u.strides[0]}, ${u.strides[1]});\\n  const ivec2 pads = ivec2(${u.pads[0]}, ${u.pads[1]});\\n  ${g}\\n  void main() {\\n    ivec4 coords = getOutputCoords();\\n    int batch = coords.x;\\n    int output_channel = coords.y;\\n    ivec2 xRCCorner = coords.zw * strides - pads;\\n    int group_id = output_channel / ${f};\\n\\n    float value = 0.0;\\n    for (int wInChannel = 0; wInChannel < ${p[1]}; wInChannel++) {\\n      int input_channel = group_id * ${p[1]} + wInChannel;\\n      for (int wHeight = 0; wHeight < ${p[2]}; wHeight++) {\\n        int xHeight = xRCCorner.x + wHeight * ${u.dilations[0]};\\n\\n        if (xHeight < 0 || xHeight >= ${l[2]}) {\\n          continue;\\n        }\\n\\n        for (int wWidth = 0; wWidth < ${p[3]}; wWidth++) {\\n          int xWidth = xRCCorner.y + wWidth * ${u.dilations[1]};\\n          if (xWidth < 0 || xWidth >= ${l[3]}) {\\n            continue;\\n          }\\n\\n          float xVal = getX(batch, input_channel, xWidth, xHeight);\\n          float wVal = getW(output_channel, wInChannel, wWidth, wHeight);\\n          value += xVal*wVal;\\n        }\\n      }\\n    }\\n    ${c}\\n    ${b}\\n    ${h.output} = vec4(value, .0, .0, .0);\\n  }\\n`;return Object.assign(Object.assign({},n),{output:{dims:d,type:e[0].type,textureType:o.TextureType.unpacked},shaderSource:m,hasMain:!0})})(t,e,u,n)})}},1386:(t,e,n)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.conv2DPacked=e.conv2DPackedPointwise=void 0;const r=n(8138),i=n(8555),o=n(708);e.conv2DPackedPointwise=(t,e,n)=>{const i=e[0].dims,a=e[1].dims,s=(0,r.calculateOutputShape)(i,a,n.dilations,n.pads,n.strides),u=t.reshapePacked(e[0],[i[1],i[2]*i[3]]),c=t.reshapePacked(e[1],[a[0],a[1]]),l=e.length>2?[c,u,e[2]]:[c,u],p=t.run((0,o.createPackedMatmulProgramInfoLoader)(t,l,n),l);return t.reshapePacked(p,s)},e.conv2DPacked=(t,e,n)=>{const a=e[0].dims,s=e[1].dims,u=(0,r.calculateOutputShape)(a,s,n.dilations,n.pads,n.strides),c=t.run((0,i.createPackedIm2ColProgramInfoLoader)(t,e[0],e[1],u,n),[e[0]]),l=t.reshapePacked(e[1],[s[0],s[1]*s[2]*s[3]]),p=3===e.length?[l,c,e[2]]:[l,c],f=t.run((0,o.createPackedMatmulProgramInfoLoader)(t,p,n),p);return t.reshapePacked(f,u)}},9663:(t,e,n)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.parseConvTransposeAttributes=e.convTranspose=void 0;const r=n(246),i=n(5060),o=n(2039),a=n(2823),s=(t,e,n,r,i,o)=>(t-1)*e+n+(r-1)*i+1-o,u=(t,e,n,r,i)=>{const o=Math.floor(t/2);\"SAME_UPPER\"===e?(n[r]=o,n[i]=t-o):\"SAME_LOWER\"===e&&(n[r]=t-o,n[i]=o)};e.convTranspose=(t,e,n)=>(f(e,n),c(t,e,n));const c=(t,e,n)=>{const r=p(n,e);return[l(t,e,r)]},l=(t,e,n)=>t.run(((t,e,n)=>{const r=(s=e.length>2,u=n.cacheKey,{name:\"ConvTranspose\",inputNames:s?[\"X\",\"W\",\"B\"]:[\"X\",\"W\"],inputTypes:s?[o.TextureType.unpacked,o.TextureType.unpacked,o.TextureType.unpacked]:[o.TextureType.unpacked,o.TextureType.unpacked],cacheHint:u});var s,u;return Object.assign(Object.assign({},r),{get:()=>((t,e,n,r)=>{const s=e.length>2?\"getB(output_channel)\":\"0.0\",u=e[0].dims,c=e[1].dims,l=c[1],p=c[0]/r.group,f=[e[0].dims[0],e[1].dims[1]*r.group,...r.outputShape],d=(0,i.getGlsl)(t.session.backend.glContext.version),{activationFunction:h,applyActivation:g}=(0,a.getActivationSnippet)(r),b=`\\n  const ivec2 strides = ivec2(${r.strides[0]}, ${r.strides[1]});\\n  const ivec2 pads = ivec2(${r.pads[0]}, ${r.pads[1]});\\n  ${h}\\n  void main() {\\n    ivec4 coords = getOutputCoords();\\n    int batch = coords.x;\\n    int output_channel = coords.y;\\n\\n    ivec2 loc = coords.zw + pads;\\n\\n    int group_id = output_channel / ${l};\\n    int wOutChannel = output_channel - group_id * ${l};\\n\\n    float value = ${s};\\n    for (int inChannelOffset = 0; inChannelOffset < ${p}; inChannelOffset++) {\\n      int input_channel = group_id * ${p} + inChannelOffset;\\n      for (int wWOff = 0; wWOff < ${c[2]}; wWOff++) {\\n        for (int wHOff = 0; wHOff < ${c[3]}; wHOff++) {\\n          ivec2 wOff = ivec2(wWOff * ${r.dilations[0]}, wHOff * ${r.dilations[1]});\\n          ivec2 wLoc = loc - wOff;\\n          ivec2 wLocIn = wLoc / strides;\\n          if (\\n            wLocIn * strides == wLoc &&\\n            wLocIn.x >= 0 && wLocIn.x < ${u[2]} &&\\n            wLocIn.y >= 0 && wLocIn.y < ${u[3]}\\n          ) {\\n            float xVal = getX(batch, input_channel, wLocIn.y, wLocIn.x);\\n            float wVal = getW(input_channel, wOutChannel, wHOff, wWOff);\\n            value += xVal * wVal;\\n          }\\n        }\\n      }\\n    }\\n    ${g}\\n    ${d.output} = vec4(value, .0, .0, .0);\\n  }\\n`;return Object.assign(Object.assign({},n),{output:{dims:f,type:e[0].type,textureType:o.TextureType.unpacked},shaderSource:b,hasMain:!0})})(t,e,r,n)})})(t,e,n),e),p=(t,e)=>{const n=t.kernelShape.slice();if(0===t.kernelShape.length)for(let t=2;t<e[1].dims.length;++t)n.push(e[1].dims[t]);const r=t.pads.slice(),i=t.outputShape.slice();((t,e,n,r,i,o,a,c)=>{const l=t.length-2,p=0===c.length;for(let f=0;f<l;++f){const d=p?t[f+2]*o[f]:c[f],h=s(t[f+2],o[f],i[f],e[f],n[f],d);u(h,r,i,f,f+l),p&&c.push(o[f]*(t[f+2]-1)+a[f]+(e[f]-1)*n[f]+1-i[f]-i[f+l])}})(e[0].dims,n,t.dilations,t.autoPad,r,t.strides,t.outputPadding,i);const o=Object.assign({},t);return Object.assign(o,{kernelShape:n,pads:r,outputShape:i,cacheKey:t.cacheKey}),o};e.parseConvTransposeAttributes=t=>{const e=t.attributes,n=(0,a.parseInternalActivationAttributes)(e),i=e.getString(\"auto_pad\",\"NOTSET\"),o=e.getInts(\"dilations\",[1,1]),s=e.getInt(\"group\",1),u=e.getInts(\"kernel_shape\",[]),c=e.getInts(\"output_padding\",[0,0]),l=e.getInts(\"output_shape\",[]),p=e.getInts(\"pads\",[0,0,0,0]),f=e.getInts(\"strides\",[1,1]);return(0,r.createAttributeWithCacheKey)(Object.assign({autoPad:i,dilations:o,group:s,kernelShape:u,outputPadding:c,outputShape:l,pads:p,strides:f},n))};const f=(t,e)=>{if(!t||2!==t.length&&3!==t.length)throw new Error(\"Conv requires 2 or 3 inputs\");if(4!==t[0].dims.length||4!==t[1].dims.length)throw new Error(\"currently only support 2-dimensional conv\");if(t[0].dims[1]!==t[1].dims[0])throw new Error(\"FILTER_IN_CHANNEL should be equal to DATA_CHANNEL\");const n=t[1].dims[1]*e.group;if(3===t.length&&(1!==t[2].dims.length||t[2].dims[0]!==n))throw new Error(\"invalid bias\");const r=t[0].dims.length-2;if(e.dilations.length!==r)throw new Error(`dilations should be ${r}D`);if(e.strides.length!==r)throw new Error(`strides should be ${r}D`);if(e.pads.length!==2*r)throw new Error(`pads should be ${2*r}D`);if(e.outputPadding.length!==r)throw new Error(`output_padding should be ${r}D`);if(0!==e.kernelShape.length&&e.kernelShape.length!==t[1].dims.length-2)throw new Error(\"invalid kernel shape\");if(0!==e.outputShape.length&&e.outputShape.length!==t[0].dims.length-2)throw new Error(\"invalid output shape\");if(\"float32\"!==t[0].type||\"float32\"!==t[1].type)throw new Error(\"ConvTranspose input(X,W) should be float tensor\");if(3===t.length&&\"float32\"!==t[2].type)throw new Error(\"ConvTranspose input(bias) should be float tensor\")}},8138:(t,e,n)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.parseConvAttributes=e.conv=e.calculateOutputShape=void 0;const r=n(246),i=n(2517),o=n(4770),a=n(1386),s=n(9828),u=n(2823),c=n(3248),l=n(5623);e.calculateOutputShape=(t,e,n,r,i)=>{const o=t[0],a=t.slice(2),s=a.length,u=e[0],c=e.slice(2).map(((t,e)=>t+(t-1)*(n[e]-1))),l=a.map(((t,e)=>t+r[e]+r[e+s])),p=l.map(((t,e)=>Math.floor((t-c[e]+i[e])/i[e])));return[o,u].concat(...p)},e.conv=(t,e,n)=>(g(e,n),p(t,e,n));const p=(t,e,n)=>{const r=h(n,e),i=t.session.pack,s=1===r.kernelShape[0]&&1===r.kernelShape[1];return r.group>1?[t.run((0,o.createUnpackedGroupedConvProgramInfoLoader)(t,e,r),e)]:s&&i?[f(t,e,r)]:i&&4===e[0].dims.length&&1===e[0].dims[0]&&!s?[(0,a.conv2DPacked)(t,e,r)]:[d(t,e,r)]},f=(t,n,r)=>{const i=n[0].dims,o=n[1].dims,a=(0,e.calculateOutputShape)(i,o,r.dilations,r.pads,r.strides),s=t.reshapeUnpacked(n[0],[i[1],i[2]*i[3]]),u=t.reshapeUnpacked(n[1],[o[0],o[1]]),c=n.length>2?[u,s,n[2]]:[u,s],p=t.run((0,l.createMatmulProgramInfoLoader)(c,r),c);return t.reshapeUnpacked(p,a)},d=(t,n,r)=>{const i=n[0].dims,o=n[1].dims,a=(0,e.calculateOutputShape)(i,o,r.dilations,r.pads,r.strides),u=t.run((0,c.createIm2ColProgramInfoLoader)(t,n[0],n[1],a,r),[n[0]]),l=3===n.length?[u,n[1],n[2]]:[u,n[1]];return t.run((0,s.createDotProductProgramInfoLoader)(t,n,a,r),l)},h=(t,e)=>{const n=t.kernelShape.slice();if(0===t.kernelShape.length)for(let t=2;t<e[1].dims.length;++t)n.push(e[1].dims[t]);const r=t.pads.slice();i.PoolConvUtil.adjustPadsBasedOnAutoPad(e[0].dims,t.strides,t.dilations,n,r,t.autoPad);const o=Object.assign({},t);return Object.assign(o,{kernelShape:n,pads:r,cacheKey:t.cacheKey}),o};e.parseConvAttributes=t=>{const e=t.attributes,n=(0,u.parseInternalActivationAttributes)(e),i=e.getString(\"auto_pad\",\"NOTSET\"),o=e.getInts(\"dilations\",[1,1]),a=e.getInt(\"group\",1),s=e.getInts(\"kernel_shape\",[]),c=e.getInts(\"pads\",[0,0,0,0]),l=e.getInts(\"strides\",[1,1]);return(0,r.createAttributeWithCacheKey)(Object.assign({autoPad:i,dilations:o,group:a,kernelShape:s,pads:c,strides:l},n))};const g=(t,e)=>{if(!t||2!==t.length&&3!==t.length)throw new Error(\"Conv requires 2 or 3 inputs\");if(4!==t[0].dims.length||4!==t[1].dims.length)throw new Error(\"currently only support 2-dimensional conv\");if(t[0].dims[1]!==t[1].dims[1]*e.group)throw new Error(\"FILTER_IN_CHANNEL should be equal to DATA_CHANNEL\");if(3===t.length&&(1!==t[2].dims.length||t[1].dims[0]!==t[2].dims[0]))throw new Error(\"invalid bias\");const n=t[0].dims.length-2;if(e.dilations.length!==n)throw new Error(`dilations should be ${n}D`);if(e.strides.length!==n)throw new Error(`strides should be ${n}D`);if(e.pads.length!==2*n)throw new Error(`pads should be ${2*n}D`);if(0!==e.kernelShape.length&&e.kernelShape.length!==t[1].dims.length-2)throw new Error(\"invalid kernel shape\");if(\"float32\"!==t[0].type||\"float32\"!==t[1].type)throw new Error(\"Conv input(X,W) should be float tensor\");if(3===t.length&&\"float32\"!==t[2].type)throw new Error(\"Conv input(bias) should be float tensor\")}},5193:(t,e,n)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.parseDepthToSpaceAttributes=e.depthToSpace=void 0;const r=n(3738);e.depthToSpace=(t,e,n)=>{i(e);const o=n.blocksize,a=o*o,s=\"DCR\"===n.mode?[0,3,4,1,5,2]:[0,1,4,2,5,3],u=\"DCR\"===n.mode?[e[0].dims[0],o,o,e[0].dims[1]/a,e[0].dims[2],e[0].dims[3]]:[e[0].dims[0],e[0].dims[1]/a,o,o,e[0].dims[2],e[0].dims[3]],c=t.reshapeUnpacked(e[0],u),l={perm:s,cacheKey:`${s}`},[p]=(0,r.transpose)(t,[c],l),f=[e[0].dims[0],e[0].dims[1]/a,e[0].dims[2]*o,e[0].dims[3]*o];return[t.reshapeUnpacked(p,f)]},e.parseDepthToSpaceAttributes=t=>{const e=t.attributes.getInt(\"blocksize\");if(e<1)throw new Error(`blocksize must be >= 1, but got : ${e} for DepthToSpace`);const n=t.attributes.getString(\"mode\",\"DCR\");if(\"DCR\"!==n&&\"CRD\"!==n)throw new Error(`unrecognized mode: ${n} for DepthToSpace`);return{mode:n,blocksize:e}};const i=t=>{if(1!==t.length)throw new Error(`DepthToSpace expect 1 inputs, but got ${t.length}`);if(\"string\"===t[0].type||4!==t[0].dims.length)throw new TypeError(\"DepthToSpace input should be a 4-D numeric tensor\")}},9828:(t,e,n)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.createDotProductProgramInfoLoader=void 0;const r=n(2517),i=n(5060),o=n(2039),a=n(2823),s=n(3248);e.createDotProductProgramInfoLoader=(t,e,n,u)=>{const c=((t,e)=>({name:\"ConvDotProduct\",inputNames:t?[\"Im2Col\",\"K\",\"B\"]:[\"Im2Col\",\"K\"],inputTypes:t?[o.TextureType.unpacked,o.TextureType.packedLastDimension,o.TextureType.unpacked]:[o.TextureType.unpacked,o.TextureType.packedLastDimension],cacheKey:e.activationCacheKey}))(e.length>2,u);return Object.assign(Object.assign({},c),{get:()=>((t,e,n,u,c)=>{const l=n[0].dims,p=n[1].dims,f=[p[0],Math.ceil(l[1]*p[2]*p[3]/4)],d=(0,s.calculateIm2ColDims)(l,p,u),[h,g]=t.calculateTextureWidthAndHeight(f,o.TextureType.packedLastDimension),b=r.ShapeUtil.computeStrides(d),[m,y]=t.calculateTextureWidthAndHeight(d,o.TextureType.packedLastDimension),_=u.length,v=n.length<3?\"0.0\":\"_B(b)\",w=Math.ceil(l[1]*p[2]*p[3]/4),{activationFunction:x,applyActivation:T}=(0,a.getActivationSnippet)(c),S=(0,i.getGlsl)(t.session.backend.glContext.version),O=`\\n${x}\\nfloat process(int indices[${_}]) {\\n  int b[1];\\n  b[0] = indices[1];\\n  int im2col[4];\\n  im2col[0] = indices[0];\\n  im2col[1] = indices[2];\\n  im2col[2] = indices[3];\\n  int im2colOffset = im2col[0] * ${b[0]} + im2col[1] * ${b[1]} + im2col[2] * ${b[2]};\\n  int kernelOffset = indices[1] * ${f[1]};\\n  float value = ${v};\\n  for (int i = 0; i < ${w}; ++i) {\\n    vec2 im2colCoords = offsetToCoords(im2colOffset, ${m}, ${y});\\n    vec2 kernelCoords = offsetToCoords(kernelOffset, ${h}, ${g});\\n    value += dot(${S.texture2D}(Im2Col, im2colCoords), ${S.texture2D}(K, kernelCoords));\\n    ++im2colOffset;\\n    ++kernelOffset;\\n  }\\n  ${T}\\n  return value;\\n}`;return Object.assign(Object.assign({},e),{output:{dims:u,type:n[0].type,textureType:o.TextureType.unpacked},shaderSource:O})})(t,c,e,n,u)})}},7992:(t,e,n)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.parseFlattenAttributes=e.flatten=void 0;const r=n(2517);e.flatten=(t,e,n)=>{i(e,n);const o=r.ShapeUtil.flattenShape(e[0].dims,n);return[t.reshapeUnpacked(e[0],o)]},e.parseFlattenAttributes=t=>t.attributes.getInt(\"axis\",1);const i=(t,e)=>{if(!t||1!==t.length)throw new Error(\"Flatten requires 1 input.\");const n=t[0].dims.length;if(0===n)throw new Error(\"scalar tensor is not supported.\");if(e<-n||e>n)throw new Error(\"Invalid axis\");if(\"string\"===t[0].type)throw new Error(\"string tensor is not supported.\")}},2823:(t,e,n)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.parseInternalActivationAttributes=e.getActivationSnippet=void 0;const r=n(2517),i=n(4909);e.getActivationSnippet=function(t){let e;switch(t.activation){case\"Relu\":e=(0,i.glslRelu)();break;case\"Sigmoid\":e=(0,i.glslSigmoid)();break;case\"Clip\":e=(0,i.glslClip)(t.clipMin,t.clipMax);break;default:return{activationFunction:\"\",applyActivation:\"\"}}const n=e.name;return{activationFunction:e.body,applyActivation:`value = ${n}_(value);`}},e.parseInternalActivationAttributes=t=>{const e=t.getString(\"activation\",\"\");if(\"Clip\"===e){const[n,i]=t.getFloats(\"activation_params\",[r.MIN_CLIP,r.MAX_CLIP]);return{activation:e,clipMax:i,clipMin:n,activationCacheKey:`${e}:${n},${i}`}}return{activation:e,activationCacheKey:e}}},1253:(t,e,n)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.parseGatherAttributes=e.gather=void 0;const r=n(246),i=n(782),o=n(2517),a=n(2039);e.gather=(t,e,n)=>(c(e,n.axis),[t.run(u(t,e,n),e)]),e.parseGatherAttributes=t=>(0,r.createAttributeWithCacheKey)({axis:t.attributes.getInt(\"axis\",0)});const s={name:\"Gather\",inputNames:[\"A\",\"B\"],inputTypes:[a.TextureType.unpacked,a.TextureType.unpacked]},u=(t,e,n)=>{const r=Object.assign(Object.assign({},s),{cacheHint:n.cacheKey});return Object.assign(Object.assign({},r),{get:()=>((t,e,n,r)=>{const i=n[0].dims.slice(),s=n[1].dims.slice(),u=new Array(i.length+s.length-1);r=o.ShapeUtil.normalizeAxis(r,i.length);const c=[];for(let t=0;t<u.length;t++)t<r?(u[t]=i[t],c.push(`inputIdx[${t}] = outputIdx[${t}];`)):t<r+s.length?(u[t]=s[t-r],c.push(`indexDataIdx[${t-r}] = outputIdx[${t}];`)):(u[t]=i[t-s.length+1],c.push(`inputIdx[${t-s.length+1}] = outputIdx[${t}];`));const l=`\\n      float process(int outputIdx[${u.length||1}]) {\\n        int inputIdx[${i.length}];\\n        int indexDataIdx[${s.length||1}];\\n        indexDataIdx[0] = 0;\\n        ${c.join(\"\\n        \")}\\n        int idx = int(_B(indexDataIdx));\\n        inputIdx[${r}] = idx < 0 ? idx + ${i[r]} : idx;\\n        return _A(inputIdx);\\n      }`;return Object.assign(Object.assign({},e),{output:{dims:u,type:n[0].type,textureType:a.TextureType.unpacked},shaderSource:l})})(0,r,e,n.axis)})},c=(t,e)=>{if(!t||2!==t.length)throw new Error(\"Gather requires 2 inputs.\");const n=t[0].dims.length;if(n<1)throw new Error(\"Invalid input shape.\");if(e<-n||e>n-1)throw new Error(\"Invalid axis.\");if(-1===i.NUMBER_TYPES.indexOf(t[0].type))throw new Error(\"Invaid input type.\");if(\"int32\"!==t[1].type&&\"int16\"!==t[1].type)throw new Error(\"Invaid input type.\")}},4776:(t,e,n)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.parseGemmAttributesV11=e.parseGemmAttributesV7=e.gemm=void 0;const r=n(246),i=n(2517),o=n(2039);e.gemm=(t,e,n)=>(c(e,n),[t.run(s(e,n),e)]);const a=(t,e)=>{const n=0!==t.attributes.getInt(\"transA\",0),i=0!==t.attributes.getInt(\"transB\",0),o=t.attributes.getFloat(\"alpha\",1),a=t.attributes.getFloat(\"beta\",1);return(0,r.createAttributeWithCacheKey)({transA:n,transB:i,alpha:o,beta:a,isOptionalC:e})};e.parseGemmAttributesV7=t=>a(t,!1),e.parseGemmAttributesV11=t=>a(t,!0);const s=(t,e)=>{const n={name:\"Gemm\",inputNames:3===t.length?[\"A\",\"B\",\"C\"]:[\"A\",\"B\"],inputTypes:3===t.length?[o.TextureType.unpacked,o.TextureType.unpacked,o.TextureType.unpacked]:[o.TextureType.unpacked,o.TextureType.unpacked],key:e.cacheKey};return Object.assign(Object.assign({},n),{get:()=>u(n,t,e)})},u=(t,e,n)=>{const r=e[0].dims.slice(),a=e[1].dims.slice(),[s,u]=i.GemmUtil.getShapeOfGemmResult(r,n.transA,a,n.transB,3===e.length?e[2].dims:void 0),c=[s,u];if(!c)throw new Error(\"Can't use gemm on the given tensors\");let l=r[r.length-1],p=\"\";n.transA&&(l=r[0]),n.transA&&n.transB?p=\"value += _A_T(a) * _B_T(b);\":n.transA&&!n.transB?p=\"value += _A_T(a) * _B(b);\":!n.transA&&n.transB?p=\"value += _A(a) * _B_T(b);\":n.transA||n.transB||(p=\"value += _A(a) * _B(b);\");const f=c.length,d=`\\n      float process(int indices[${f}]) {\\n          int a[${f}];\\n          int b[${f}];\\n          ${3===e.length?`int c[${e[2].dims.length}];`:\"\"}\\n\\n          copyVec(indices, a);\\n          copyVec(indices, b);\\n          ${3===e.length?\"bcastIndices_C(indices, c);\":\"\"}\\n\\n          float value = 0.0;\\n          for (int k=0; k<${l}; ++k) {\\n              a[${f-1}] = k;\\n              b[${f-2}] = k;\\n              ${p}\\n          }\\n\\n          value = value * alpha;\\n          ${3===e.length?\"value += beta * _C(c);\":\"\"}\\n          return value;\\n      }`;return Object.assign(Object.assign({},t),{output:{dims:c,type:e[0].type,textureType:o.TextureType.unpacked},variables:[{name:\"alpha\",type:\"float\",data:n.alpha},{name:\"beta\",type:\"float\",data:n.beta}],shaderSource:d})},c=(t,e)=>{if(!t)throw new Error(\"Input is missing\");if(e.isOptionalC&&(t.length<2||t.length>3))throw new Error(\"Invaid input shape.\");if(!e.isOptionalC&&3!==t.length)throw new Error(\"Gemm requires 3 inputs\");if(3===t.length&&1!==t[2].dims.length&&2!==t[2].dims.length)throw new Error(\"Invalid input shape of C\");if(\"float32\"!==t[0].type&&\"float64\"!==t[0].type||\"float32\"!==t[1].type&&\"float64\"!==t[1].type||3===t.length&&\"float32\"!==t[2].type&&\"float64\"!==t[2].type)throw new Error(\"Invalid input type.\");if(t[0].type!==t[1].type||3===t.length&&t[0].type!==t[2].type)throw new Error(\"Input types are mismatched\")}},8555:(t,e,n)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.createPackedIm2ColProgramInfoLoader=void 0;const r=n(5060),i=n(2039),o=n(2827);e.createPackedIm2ColProgramInfoLoader=(t,e,n,a,s)=>{const u=(c=s.cacheKey,{name:\"Im2Col (packed)\",inputNames:[\"A\"],inputTypes:[i.TextureType.packed],cacheHint:c});var c;return Object.assign(Object.assign({},u),{get:()=>((t,e,n,a,s,u)=>{const c=n.dims,l=a.dims,p=s.length,f=[l[1]*l[2]*l[3],s[2]*s[3]],d=l[2]*l[3],h=(0,o.unpackFromChannel)(),g=(0,r.getGlsl)(t.session.backend.glContext.version);let b=\"\";for(let t=0;t<=1;t++)for(let e=0;e<=1;e++)b+=`\\n            blockIndex = rc.x + ${e};\\n            pos = rc.y + ${t};\\n\\n            if(blockIndex < ${f[1]} && pos < ${f[0]}) {\\n              offsetY = int(blockIndex / (${s[p-1]})) * ${u.strides[0]} -\\n                ${u.pads[0]};\\n              d0 = offsetY + ${u.dilations[0]} * (imod(pos, ${d}) / ${l[2]});\\n\\n              if(d0 < ${c[2]} && d0 >= 0) {\\n                offsetX = imod(blockIndex, ${s[p-1]}) * ${u.strides[1]} -\\n                  ${u.pads[1]};\\n                d1 = offsetX + ${u.dilations[1]} * imod(imod(pos, ${d}), ${l[2]});\\n\\n                if(d1 < ${c[3]} && d1 >= 0) {\\n\\n                  ch = int(float(pos)/ ${d}.);\\n                    innerDims = vec2(d0, d1);\\n                    result[${2*t+e}] = getChannel(\\n                      getA(0, ch, int(innerDims.x),\\n                      int(innerDims.y)), innerDims);\\n                }\\n              }\\n            }\\n\\n          `;const m=`\\n      ${h}\\n\\n      void main() {\\n        ivec2 rc = getOutputCoords();\\n          vec4 result = vec4(0.0);\\n          int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\\n          vec2 innerDims;\\n          ${b}\\n          ${g.output} = result;\\n      }\\n            `;return Object.assign(Object.assign({},e),{output:{dims:f,type:n.type,textureType:i.TextureType.packed},shaderSource:m,hasMain:!0})})(t,u,e,n,a,s)})}},3248:(t,e,n)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.calculateIm2ColDims=e.createIm2ColProgramInfoLoader=void 0;const r=n(2039);e.createIm2ColProgramInfoLoader=(t,n,i,o,a)=>{const s=(u=a.cacheKey,{name:\"Im2Col\",inputNames:[\"X\"],inputTypes:[r.TextureType.unpacked],cacheHint:u});var u;return Object.assign(Object.assign({},s),{get:()=>((t,n,i,o,a,s)=>{const u=i.dims,c=o.dims,l=a.length,p=(0,e.calculateIm2ColDims)(u,c,a,4),f=`\\n        const int XC = ${u[1]};\\n        const int XH = ${u[2]};\\n        const int XW = ${u[3]};\\n        const int KH = ${s.kernelShape[0]};\\n        const int KW = ${s.kernelShape[1]};\\n        const int dilationH = ${s.dilations[0]};\\n        const int dilationW = ${s.dilations[1]};\\n        const int strideH = ${s.strides[0]};\\n        const int strideW = ${s.strides[1]};\\n        const int padH = ${s.pads[0]};\\n        const int padW = ${s.pads[1]};\\n        const int KHKW = KH*KW;\\n        const int XCKHKW = XC * KHKW;\\n        const int outputChannels = 4;\\n        vec4 process(int indices[${l}]) {\\n          int b  = indices[0]; // batch size\\n          int oh = indices[1] * strideH - padH; //output height\\n          int ow = indices[2] * strideW - padW; //output width\\n          int p = indices[3] * outputChannels; //patch\\n          vec4 value = vec4(0.0);\\n          for(int i=0; i < outputChannels; ++i) {\\n            if(p < XCKHKW) {\\n              int patchC = p / KHKW;\\n              int patchH = (p - patchC*KHKW) / KW;\\n              int patchW = (p - patchC*KHKW) - patchH * KW;\\n              int xh2 = oh + patchH * dilationH;\\n              int xw2 = ow + patchW * dilationW;\\n              int x[${u.length}];\\n              x[0] = b;\\n              x[1] = patchC;\\n              x[2] = xh2;\\n              x[3] = xw2;\\n              if(xh2 >= 0 &&\\n                  xh2 < XH &&\\n                  xw2 >= 0 &&\\n                  xw2 < XW) {\\n                value[i] = _X(x);\\n              }\\n            }\\n            ++p;\\n          }\\n          return value;\\n        }\\n        `;return Object.assign(Object.assign({},n),{output:{dims:p,type:i.type,textureType:r.TextureType.packedLastDimension},shaderSource:f})})(0,s,n,i,o,a)})},e.calculateIm2ColDims=(t,e,n,r=4)=>[n[0],n[2],n[3],Math.ceil(t[1]*e[2]*e[3]/r)]},6572:(t,e,n)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.parseImageScalerAttributes=e.imageScaler=void 0;const r=n(246),i=n(2039);e.imageScaler=(t,e,n)=>(u(e),[t.run(a(t,e,n),e)]),e.parseImageScalerAttributes=t=>{const e=t.attributes.getFloat(\"scale\"),n=t.attributes.getFloats(\"bias\");return(0,r.createAttributeWithCacheKey)({scale:e,bias:n})};const o={name:\"ImageScaler\",inputNames:[\"X\"],inputTypes:[i.TextureType.unpacked]},a=(t,e,n)=>{const r=Object.assign(Object.assign({},o),{cacheHint:n.cacheKey});return Object.assign(Object.assign({},r),{get:()=>((t,e,n,r)=>{const o=n[0].dims.slice(),a=o.length,u=`\\n      ${s(r.bias.length)}\\n      float process(int indices[${a}]) {\\n        return _X(indices) * scale + getBias(bias, indices[1]);\\n      }`;return Object.assign(Object.assign({},e),{output:{dims:o,type:n[0].type,textureType:i.TextureType.unpacked},variables:[{name:\"bias\",type:\"float\",arrayLength:r.bias.length,data:r.bias},{name:\"scale\",type:\"float\",data:r.scale}],shaderSource:u})})(0,r,e,n)})},s=t=>{const e=[`float getBias(float bias[${t}], int channel) {`];for(let n=0;n<t;++n)0===n?e.push(`\\tif (channel == ${n}) { return bias[${n}]; }`):n===t-1?e.push(`\\telse { return bias[${n}]; }`):e.push(`\\telse if (channel == ${n}) { return bias[${n}]; }`);return e.push(\"\\t}\"),e.join(\"\\n\")},u=t=>{if(!t||1!==t.length)throw new Error(\"ImageScaler requires 1 input.\");if(4!==t[0].dims.length)throw new Error(\"Invalid input shape.\");if(\"float32\"!==t[0].type&&\"float64\"!==t[0].type)throw new Error(\"Invalid input type.\")}},3346:(t,e,n)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.parseInstanceNormalizationAttributes=e.instanceNormalization=void 0;const r=n(5060),i=n(2039);e.instanceNormalization=(t,e,n)=>{c(e);const r=t.run(a(e[0]),e);return[t.run(u(t,e[0],n,r.dims),[e[0],r,e[1],e[2]])]},e.parseInstanceNormalizationAttributes=t=>t.attributes.getFloat(\"epsilon\",1e-5);const o={name:\"InstanceNormalization_MeanAndVariance\",inputNames:[\"X\"],inputTypes:[i.TextureType.unpacked]},a=t=>Object.assign(Object.assign({},o),{get:()=>((t,e)=>{const n=e.dims.slice(),r=n[1],o=n[2]*n[3],a=[n[0],r],s=`\\n      vec4 process(int[2] indices) {\\n        vec4 v = vec4(0.0);\\n        int a[4];\\n        a[0] = indices[0];\\n        a[1] = indices[1];\\n        float temp = 0.0;\\n        for(int a2=0; a2<${n[2]}; a2++) {\\n          a[2] = a2;\\n          for(int a3=0; a3<${n[3]}; a3++) {\\n            a[3] = a3;\\n            float x = _X(a);\\n            temp += x;\\n          }\\n        }\\n        float mean = temp / float(${o});\\n        temp = 0.0;\\n        for(int a2=0; a2<${n[2]}; a2++) {\\n          a[2] = a2;\\n          for(int a3=0; a3<${n[3]}; a3++) {\\n            a[3] = a3;\\n            float x = _X(a);\\n            temp += (x - mean) * (x - mean);\\n          }\\n        }\\n        v.r = mean;\\n        v.g = temp / float(${o});\\n\\n        return v;\\n      }`;return Object.assign(Object.assign({},t),{output:{dims:a,type:e.type,textureType:i.TextureType.packedLastDimension},shaderSource:s})})(o,t)}),s={name:\"InstanceNormalization_ComputeOutput\",inputNames:[\"X\",\"MeanAndVariance\",\"Scale\",\"B\"],inputTypes:[i.TextureType.unpacked,i.TextureType.packedLastDimension,i.TextureType.unpacked,i.TextureType.unpacked]},u=(t,e,n,o)=>{const a=Object.assign(Object.assign({},s),{cacheHint:`${n}`});return Object.assign(Object.assign({},a),{get:()=>((t,e,n,o,a)=>{const s=(0,r.getGlsl)(t.session.backend.glContext.version),[u,c]=t.calculateTextureWidthAndHeight(a,i.TextureType.packedLastDimension),[l,p]=[u/4,c],f=`\\n      vec4 get_MeanAndVariance(int[2] mv) {\\n        int offset = indicesToOffset_MeanAndVariance(mv);\\n        vec2 coords = offsetToCoords(offset, ${l}, ${p});\\n        return ${s.texture2D}(MeanAndVariance, coords);\\n      }\\n\\n      float process(int[4] indices) {\\n        int mv[2];\\n        mv[0] = indices[0];\\n        mv[1] = indices[1];\\n        vec4 mean_and_variance = get_MeanAndVariance(mv);\\n        float mean = mean_and_variance.r;\\n        float variance = mean_and_variance.g;\\n\\n        int sb[1];\\n        sb[0] = indices[1];\\n        float scale = _Scale(sb);\\n        float b = _B(sb);\\n\\n        return scale * (_X(indices) - mean) / sqrt(variance + epsilon) + b;\\n      }`;return Object.assign(Object.assign({},e),{output:{dims:n.dims,type:n.type,textureType:i.TextureType.unpacked},variables:[{name:\"epsilon\",type:\"float\",data:o}],shaderSource:f})})(t,a,e,n,o)})},c=t=>{if(!t||3!==t.length)throw new Error(\"InstanceNormalization requires 3 inputs.\");const e=t[0],n=t[1],r=t[2];if(e.dims.length<3||1!==n.dims.length||1!==r.dims.length)throw new Error(\"Invalid input shape.\");if(n.dims[0]!==e.dims[1]||r.dims[0]!==e.dims[1])throw new Error(\"Input shapes are mismatched.\");if(\"float32\"!==e.type&&\"float64\"!==e.type||\"float32\"!==n.type&&\"float64\"!==n.type||\"float32\"!==r.type&&\"float64\"!==r.type)throw new Error(\"Invalid input type.\");if(4!==t[0].dims.length)throw new Error(\"Only support 4-D input shape.\")}},708:(t,e,n)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.createPackedMatmulProgramInfoLoader=void 0;const r=n(2517),i=n(5060),o=n(2039),a=n(9390),s=n(2823),u=n(5623);e.createPackedMatmulProgramInfoLoader=(t,e,n)=>{const c=(l=e.length>2,p=n.activationCacheKey,{name:\"MatMul (packed)\",inputNames:l?[\"A\",\"B\",\"Bias\"]:[\"A\",\"B\"],inputTypes:l?[o.TextureType.packed,o.TextureType.packed,o.TextureType.packed]:[o.TextureType.packed,o.TextureType.packed],cacheHint:p});var l,p;return Object.assign(Object.assign({},c),{get:()=>((t,e,n,c)=>{const l=n.length>2,p=l?\"value += getBiasForMatmul();\":\"\",f=n[0].dims,d=n[1].dims,h=r.BroadcastUtil.calcShape(f,d,!0),g=!r.ShapeUtil.areEqual(n[0].dims,n[1].dims);if(!h)throw new Error(\"Can't use matmul on the given tensors\");const b=f[f.length-1],m=Math.ceil(b/2),y=f.length,_=d.length,v=(0,i.getGlsl)(t.session.backend.glContext.version),w=(0,a.getCoordsDataType)(h.length),x=h.length,T=(0,a.getGlChannels)(),{activationFunction:S,applyActivation:O}=(0,s.getActivationSnippet)(c),A=l?`${(0,u.getBiasForMatmul)(w,T,n[2].dims,h,!0)}`:\"\",E=g?`${function(t,e,n,i){let o=[],a=[];const s=n[0].dims,u=n[1].dims,c=s.length,l=u.length,p=i.length,f=p-c,d=p-l;o=s.map(((t,n)=>`coords.${e[n+f]}`)),o[c-1]=\"i*2\",o.join(\", \"),a=u.map(((t,n)=>`coords.${e[n+d]}`)),a[l-2]=\"i*2\",a.join(\", \");const h=r.BroadcastUtil.getBroadcastDims(s,i),g=r.BroadcastUtil.getBroadcastDims(u,i),b=h.map((t=>`coords.${e[t+f]} = 0;`)).join(\"\\n\"),m=g.map((t=>`coords.${e[t+d]} = 0;`)).join(\"\\n\"),y=`int lastDim = coords.${e[p-1]};\\n  coords.${e[p-1]} = coords.${e[p-2]};\\n  coords.${e[p-2]} = lastDim;`;return`\\nvec4 getAAtOutCoordsMatmul(int i) {\\n  ${t} coords = getOutputCoords();\\n  ${y}\\n  ${b}\\n  vec4 outputValue = getA(${o});\\n  return outputValue;\\n}\\n\\nvec4 getBAtOutCoordsMatmul(int i) {\\n  ${t} coords = getOutputCoords();\\n  ${y}\\n  ${m}\\n  vec4 outputValue = getB(${a});\\n  return outputValue;\\n}`}(w,T,n,h)}`:\"\",I=g?\"getAAtOutCoordsMatmul(i)\":`getA(${function(t,e){let n=\"\";for(let r=0;r<e-2;r++)n+=`rc.${t[r]}, `;return n+=`rc.${t[e-2]}, i*2`,n}(T,y)})`,P=g?\"getBAtOutCoordsMatmul(i)\":`getB(${function(t,e){let n=\"\";for(let r=0;r<e-2;r++)n+=`rc.${t[r]}, `;return n+=`i*2, rc.${t[e-1]}`,n}(T,_)})`,D=`\\n            ${E}\\n            ${A}\\n            ${S}\\n            void main() {\\n              ${g?\"\":`${w} rc =\\n          getOutputCoords(); int lastDim = rc.${T[x-1]}; rc.${T[x-1]} =\\n          rc.${T[x-2]}; rc.${T[x-2]} = lastDim;\\n      `}\\n\\n              vec4 value = vec4(0);\\n              for (int i = 0; i < ${m}; i++) {\\n                vec4 a = ${I};\\n                vec4 b = ${P};\\n\\n                value += (a.rrbb * b.rgrg);\\n                value += (a.ggaa * b.baba);\\n              }\\n              ${p}\\n              ${O}\\n              ${v.output} = value;\\n            }`;return Object.assign(Object.assign({},e),{output:{dims:h,type:n[0].type,textureType:o.TextureType.packed},shaderSource:D,hasMain:!0})})(t,c,e,n)})}},5623:(t,e,n)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.getBiasForMatmul=e.createMatmulProgramInfoLoader=e.parseMatMulAttributes=e.matMul=void 0;const r=n(2517),i=n(2039),o=n(9390),a=n(2823),s=n(708);function u(t,e){const n=(s=t.length>2,u=e.activationCacheKey,{name:\"MatMul\",inputNames:s?[\"A\",\"B\",\"Bias\"]:[\"A\",\"B\"],inputTypes:s?[i.TextureType.unpacked,i.TextureType.unpacked,i.TextureType.unpacked]:[i.TextureType.unpacked,i.TextureType.unpacked],cacheHint:u});var s,u;return Object.assign(Object.assign({},n),{get:()=>function(t,e,n){const s=e[0].dims,u=e[1].dims,c=r.BroadcastUtil.calcShape(s,u,!0);if(!c)throw new Error(\"Can't use matmul on the given tensors\");const p=(0,o.getCoordsDataType)(c.length),f=(0,o.getGlChannels)(),{activationFunction:d,applyActivation:h}=(0,a.getActivationSnippet)(n),g=e.length>2,b=g?\"value += getBiasForMatmul();\":\"\",m=g?`${l(p,f,e[2].dims,c,!1)}`:\"\",y=c.length,_=s.length,v=u.length,w=`\\n    ${d}\\n    ${m}\\n    float process(int indices[${y}]) {\\n        int a[${_}];\\n        int b[${v}];\\n        bcastMatmulIndices_A(indices, a);\\n        bcastMatmulIndices_B(indices, b);\\n\\n        float value;\\n        for (int k=0; k<${s[s.length-1]}; ++k) {\\n            a[${_-1}] = k;\\n            b[${v-2}] = k;\\n            value += _A(a) * _B(b);\\n        }\\n        ${b}\\n        ${h}\\n        return value;\\n    }`;return Object.assign(Object.assign({},t),{output:{dims:c,type:e[0].type,textureType:i.TextureType.unpacked},shaderSource:w})}(n,t,e)})}e.matMul=(t,e,n)=>(c(e),t.session.pack?[t.run((0,s.createPackedMatmulProgramInfoLoader)(t,e,n),e)]:[t.run(u(e,n),e)]),e.parseMatMulAttributes=t=>(0,a.parseInternalActivationAttributes)(t.attributes),e.createMatmulProgramInfoLoader=u;const c=t=>{if(!t||2!==t.length)throw new Error(\"MatMul requires 2 inputs.\");if(t[0].dims[t[0].dims.length-1]!==t[1].dims[t[1].dims.length-2])throw new Error(\"shared dimension does not match.\");if(\"float32\"!==t[0].type&&\"float64\"!==t[0].type||\"float32\"!==t[1].type&&\"float64\"!==t[1].type)throw new Error(\"inputs should be float type\");if(t[0].type!==t[1].type)throw new Error(\"inputs types should match\")};function l(t,e,n,i,o){let a=\"\";const s=n.length,u=i.length,c=u-s;a=u<2&&s>0?\"coords\":n.map(((t,n)=>`coords.${e[n+c]}`)).join(\", \");const l=r.BroadcastUtil.getBroadcastDims(n,i).map((t=>`coords.${e[t+c]} = 0;`)).join(\"\\n\");let p=\"vec4(outputValue.xx, outputValue.yy)\";return 1===r.ShapeUtil.size(n)&&(p=\"vec4(outputValue.x)\"),o?`\\nvec4 getBiasForMatmul() {\\n  ${t} coords = getOutputCoords();\\n  ${l}\\n  vec4 outputValue = getBias(${a});\\n  return ${p};\\n}`:`\\nfloat getBiasForMatmul() {\\n  ${t} coords = getOutputCoords();\\n  ${l}\\n  return getBias(coords.x);\\n}`}e.getBiasForMatmul=l},2403:(t,e,n)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.createPackProgramInfoLoader=void 0;const r=n(5060),i=n(2039),o=n(9390),a=n(2827),s={name:\"pack\",inputNames:[\"A\"],inputTypes:[i.TextureType.unpackedReversed]};e.createPackProgramInfoLoader=(t,e)=>Object.assign(Object.assign({},s),{get:()=>((t,e)=>{const n=(0,r.getGlsl)(t.session.backend.glContext.version),u=e.dims,c=u.length,l=e.dims.length,p=(0,o.getCoordsDataType)(l),f=(0,a.getChannels)(\"rc\",l),d=(h=l,g=f,b=u[u.length-2],m=u[u.length-1],0===h||1===h?\"\":`\\n    int r = ${g[h-2]};\\n    int c = ${g[h-1]};\\n    int rp1 = ${g[h-2]} + 1;\\n    int cp1 = ${g[h-1]} + 1;\\n    bool rEdge = rp1 >= ${m};\\n    bool cEdge = cp1 >= ${b};\\n    `);var h,g,b,m;let y;y=0===c?[1,1]:1===c?[u[0],1]:[u[l-1],u[l-2]];const _=function(t,e,n){if(0===t)return\"false\";if(1===t)return`rc > ${e[0]}`;let r=\"\";for(let i=t-2;i<t;i++)r+=`${n[i]} >= ${e[i-t+2]}`,i<t-1&&(r+=\"||\");return r}(l,y,f),v=function(t,e){const n=t.length;if(0===n)return\"getA(), 0, 0, 0\";if(1===n)return`getA(rc),\\n            rc + 1 >= ${t[0]} ? 0. : getA(rc + 1),\\n            0, 0`;let r=\"\";if(n>2)for(let t=0;t<n-2;++t)r+=`${e[t]},`;return`getA(${r}r, c),\\n          rEdge ? 0. : getA(${r}rp1, c),\\n          cEdge ? 0. : getA(${r}r, cp1),\\n          rEdge || cEdge ? 0. : getA(${r}rp1, cp1)`}(u,f),w=`\\n        void main() {\\n          ${p} rc = getOutputCoords();\\n\\n          if(${_}) {\\n            ${n.output} = vec4(0);\\n          } else {\\n            ${d}\\n\\n            ${n.output} = vec4(${v});\\n          }\\n        }\\n      `;return Object.assign(Object.assign({},s),{hasMain:!0,output:{dims:e.dims,type:e.type,textureType:i.TextureType.packed},shaderSource:w})})(t,e)})},2827:(t,e,n)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.unpackFromChannel=e.getChannels=e.getVecChannels=void 0;const r=n(9390);function i(t,e){return(0,r.getGlChannels)(e).map((e=>`${t}.${e}`))}e.getVecChannels=i,e.getChannels=function(t,e){return 1===e?[t]:i(t,e)},e.unpackFromChannel=function(){return\"\\n    float getChannel(vec4 frag, int dim) {\\n      int modCoord = imod(dim, 2);\\n      return modCoord == 0 ? frag.r : frag.g;\\n    }\\n\\n    float getChannel(vec4 frag, vec2 innerDims) {\\n      vec2 modCoord = mod(innerDims, 2.);\\n      return modCoord.x == 0. ?\\n        (modCoord.y == 0. ? frag.r : frag.g) :\\n        (modCoord.y == 0. ? frag.b : frag.a);\\n    }\\n  \"}},2870:(t,e,n)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.parsePadAttributesV11=e.padV11=e.parsePadAttributesV2=e.padV2=void 0;const r=n(246),i=n(2517),o=n(5060),a=n(2039),s={name:\"Pad\",inputNames:[\"A\"],inputTypes:[a.TextureType.unpacked]};e.padV2=(t,e,n)=>(l(e),[t.run(Object.assign(Object.assign({},s),{cacheHint:n.cacheKey,get:()=>c(t,e[0],n)}),e)]),e.parsePadAttributesV2=t=>{const e=t.attributes.getString(\"mode\",\"constant\"),n=t.attributes.getFloat(\"value\",0),i=t.attributes.getInts(\"pads\");return(0,r.createAttributeWithCacheKey)({mode:e,value:n,pads:i})},e.padV11=(t,n,r)=>{p(n);const i=u(t,n,r);return(0,e.padV2)(t,[n[0]],i)},e.parsePadAttributesV11=t=>t.attributes.getString(\"mode\",\"constant\");const u=(t,e,n)=>{if(!t.session.isInitializer(e[1].dataId)||e.length>=3&&!t.session.isInitializer(e[2].dataId))throw new Error(\"dynamic pad attributes are not allowed\");const i=Array.from(e[1].integerData),o=e.length>=3?e[2].floatData[0]:0;return(0,r.createAttributeWithCacheKey)({mode:n,pads:i,value:o})},c=(t,e,n)=>{const r=i.ShapeUtil.padShape(e.dims.slice(),n.pads),o=r.length,s=`\\n      ${f(t,e,n)}\\n      float process(int[${o}] indices) {\\n          return padA(indices);\\n      }`;return{name:\"Pad\",inputNames:[\"A\"],inputTypes:[a.TextureType.unpacked],output:{dims:r,type:e.type,textureType:a.TextureType.unpacked},shaderSource:s}},l=t=>{if(!t||1!==t.length)throw new Error(\"Pad requires 1 input\");if(\"float32\"!==t[0].type&&\"float64\"!==t[0].type)throw new Error(\"Invalid input type.\")},p=t=>{if(!t||2!==t.length&&3!==t.length)throw new Error(\"Pad requires 2 or 3 inputs\");if(\"int32\"!==t[1].type)throw new Error(\"Invalid input type.\");if(t.length>=3&&\"string\"===t[2].type)throw new Error(\"Invalid input type.\")},f=(t,e,n)=>{const r=(0,o.getGlsl)(t.session.backend.glContext.version),[s,u]=t.calculateTextureWidthAndHeight(e.dims,a.TextureType.unpacked),c=i.ShapeUtil.computeStrides(e.dims);switch(n.mode){case\"constant\":return d(r,e.dims,c,s,u,n.pads,n.value);case\"reflect\":return h(r,e.dims,c,s,u,n.pads);case\"edge\":return g(r,e.dims,c,s,u,n.pads);default:throw new Error(\"Invalid mode\")}},d=(t,e,n,r,i,o,a)=>{const s=e.length;let u=\"\";for(let t=s-1;t>=0;--t)u+=`\\n        k = m[${t}] - ${o[t]};\\n        if (k < 0)  return constant;\\n        if (k >= ${e[t]}) return constant;\\n        offset += k * ${n[t]};\\n        `;return`\\n      float padA(int m[${s}]) {\\n        const float constant = float(${a});\\n        int offset = 0;\\n        int k = 0;\\n        ${u}\\n        vec2 coords = offsetToCoords(offset, ${r}, ${i});\\n        float value = getColorAsFloat(${t.texture2D}(A, coords));\\n        return value;\\n      }\\n      `},h=(t,e,n,r,i,o)=>{const a=e.length;let s=\"\";for(let t=a-1;t>=0;--t)s+=`\\n        k = m[${t}] - ${o[t]};\\n        if (k < 0) { k = -k; }\\n        {\\n          const int _2n_1 = ${2*(e[t]-1)};\\n          k = int( mod( float(k), float(_2n_1) ) ) ;\\n          if(k >= ${e[t]}) { k = _2n_1 - k; }\\n        }\\n        offset += k * ${n[t]};\\n        `;return`\\n      float padA(int m[${a}]) {\\n        int offset = 0;\\n        int k = 0;\\n        ${s}\\n        vec2 coords = offsetToCoords(offset, ${r}, ${i});\\n        float value = getColorAsFloat(${t.texture2D}(A, coords));\\n        return value;\\n      }\\n      `},g=(t,e,n,r,i,o)=>{const a=e.length;let s=\"\";for(let t=a-1;t>=0;--t)s+=`\\n        k = m[${t}] - ${o[t]};\\n        if (k < 0)  k = 0;\\n        if (k >= ${e[t]}) k = ${e[t]-1};\\n        offset += k * ${n[t]};\\n      `;return`\\n      float padA(int m[${a}]) {\\n        int offset = 0;\\n        int k = 0;\\n        ${s}\\n        vec2 coords = offsetToCoords(offset, ${r}, ${i});\\n        float value = getColorAsFloat(${t.texture2D}(A, coords));\\n        return value;\\n      }\\n      `}},2143:(t,e,n)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.globalMaxPool=e.parseMaxPoolAttributes=e.maxPool=e.parseGlobalAveragePoolAttributes=e.globalAveragePool=e.parseAveragePoolAttributes=e.averagePool=void 0;const r=n(246),i=n(2517),o=n(2039);e.averagePool=(t,e,n)=>{p(e);const r={name:\"AveragePool\",inputNames:[\"X\"],inputTypes:[o.TextureType.unpacked],cacheHint:n.cacheKey};return[t.run(Object.assign(Object.assign({},r),{get:()=>a(e,r,!1,n)}),e)]},e.parseAveragePoolAttributes=t=>{const e=t.attributes.getString(\"auto_pad\",\"NOTSET\"),n=t.attributes.getInt(\"ceil_mode\",0),i=0!==t.attributes.getInt(\"count_include_pad\",0),o=t.attributes.getInts(\"kernel_shape\"),a=t.attributes.getInts(\"strides\",[]),s=t.attributes.getInts(\"pads\",[]);if(0!==n)throw new Error(\"using ceil() in shape computation is not yet supported for AveragePool\");return(0,r.createAttributeWithCacheKey)({autoPad:e,ceilMode:n,countIncludePad:i,kernelShape:o,strides:a,pads:s})};const a=(t,e,n,r)=>{const[a,s]=u(t,r,n),c=i.ShapeUtil.size(a.kernelShape);let l=\"\";a.countIncludePad?l+=`value /= float(${c});`:l+=`value /= float(${c} - pad);`;const p=`\\n        ${f(t[0].dims,a,\"value += _X(x);\",l,\"0.0\")}\\n      `;return Object.assign(Object.assign({},e),{output:{dims:s,type:t[0].type,textureType:o.TextureType.unpacked},shaderSource:p})};e.globalAveragePool=(t,e,n)=>{p(e);const r={name:\"GlobalAveragePool\",inputNames:[\"X\"],inputTypes:[o.TextureType.unpacked],cacheHint:`${n.countIncludePad}`};return[t.run(Object.assign(Object.assign({},r),{get:()=>a(e,r,!0,n)}),e)]},e.parseGlobalAveragePoolAttributes=t=>{const e=0!==t.attributes.getInt(\"count_include_pad\",0);return(0,r.createAttributeWithCacheKey)({autoPad:\"\",ceilMode:0,countIncludePad:e,kernelShape:[],strides:[],pads:[]})},e.maxPool=(t,e,n)=>{p(e);const r={name:\"MaxPool\",inputNames:[\"X\"],inputTypes:[o.TextureType.unpacked],cacheHint:n.cacheKey};return[t.run(Object.assign(Object.assign({},r),{get:()=>s(e,r,!1,n)}),e)]},e.parseMaxPoolAttributes=t=>{const e=t.attributes.getString(\"auto_pad\",\"NOTSET\"),n=t.attributes.getInt(\"ceil_mode\",0),i=t.attributes.getInts(\"kernel_shape\"),o=t.attributes.getInts(\"strides\",[]),a=t.attributes.getInts(\"pads\",[]),s=t.attributes.getInt(\"storage_order\",0),u=t.attributes.getInts(\"dilations\",[]);if(0!==s)throw new Error(\"column major storage order is not yet supported for MaxPool\");if(0!==n)throw new Error(\"using ceil() in shape computation is not yet supported for MaxPool\");return(0,r.createAttributeWithCacheKey)({autoPad:e,ceilMode:n,countIncludePad:!1,kernelShape:i,strides:o,pads:a,storageOrder:s,dilations:u})};const s=(t,e,n,r)=>{const[i,a]=u(t,r,n),s=`\\n      ${f(t[0].dims,i,\"\\n      value = max(_X(x), value);\\n    \",\"\",\"-1e5\")}\\n    `;return Object.assign(Object.assign({},e),{output:{dims:a,type:t[0].type,textureType:o.TextureType.unpacked},shaderSource:s})},u=(t,e,n)=>{const r=t[0].dims.slice(),o=Object.hasOwnProperty.call(e,\"dilations\"),a=e.kernelShape.slice(),s=e.strides.slice(),u=o?e.dilations.slice():[],c=e.pads.slice();i.PoolConvUtil.adjustPoolAttributes(n,r,a,s,u,c);const l=i.PoolConvUtil.computePoolOutputShape(n,r,s,u,a,c,e.autoPad),p=Object.assign({},e);return o?Object.assign(p,{kernelShape:a,strides:s,pads:c,dilations:u,cacheKey:e.cacheKey}):Object.assign(p,{kernelShape:a,strides:s,pads:c,cacheKey:e.cacheKey}),[p,l]},c={autoPad:\"\",ceilMode:0,countIncludePad:!1,kernelShape:[],strides:[],pads:[],storageOrder:0,dilations:[],cacheKey:\"\"},l={name:\"GlobalMaxPool\",inputNames:[\"X\"],inputTypes:[o.TextureType.unpacked]};e.globalMaxPool=(t,e)=>(p(e),[t.run(Object.assign(Object.assign({},l),{get:()=>s(e,l,!0,c)}),e)]);const p=t=>{if(!t||1!==t.length)throw new Error(\"Pool ops requires 1 input.\");if(\"float32\"!==t[0].type&&\"float64\"!==t[0].type)throw new Error(\"Invalid input type.\")},f=(t,e,n,r,o)=>{const a=t.length;if(e.kernelShape.length<=2){const i=e.kernelShape[e.kernelShape.length-1],s=e.strides[e.strides.length-1],u=e.pads[e.pads.length/2-1],c=e.pads[e.pads.length-1],l=t[a-1];let p=\"\",f=\"\",d=\"\";if(p=u+c!==0?`\\n          for (int i = 0; i < ${i}; i++) {\\n            x[${a} - 1] = indices[${a} - 1] * ${s} - ${u} + i;\\n            if (x[${a} - 1] < 0 || x[${a} - 1] >= ${l}) {\\n              pad++;\\n              continue;\\n            }\\n            ${n}\\n          }`:`\\n          for (int i = 0; i < ${i}; i++) {\\n            x[${a} - 1] = indices[${a} - 1] * ${s} - ${u} + i;\\n            ${n}\\n          }`,2===e.kernelShape.length){const n=e.kernelShape[e.kernelShape.length-2],r=e.strides[e.strides.length-2],o=e.pads[e.pads.length/2-2],s=e.pads[e.pads.length-2],u=t[a-2];f=o+s!==0?`\\n            for (int j = 0; j < ${n}; j++) {\\n              x[${a} - 2] = indices[${a} - 2] * ${r} - ${o} + j;\\n              if (x[${a} - 2] < 0 || x[${a} - 2] >= ${u}) {\\n                pad+= ${i};\\n                continue;\\n              }\\n          `:`\\n            for (int j = 0; j < ${n}; j++) {\\n              x[${a} - 2] = indices[${a} - 2] * ${r} - ${o} + j;\\n            `,d=\"\\n          }\\n        \"}return`\\n        float process(int indices[${a}]) {\\n          int x[${a}];\\n          copyVec(indices, x);\\n\\n          float value = ${o};\\n          int pad = 0;\\n          ${f}\\n          ${p}\\n          ${d}\\n          ${r}\\n          return value;\\n        }\\n      `}{const s=i.ShapeUtil.size(e.kernelShape),u=i.ShapeUtil.computeStrides(e.kernelShape),c=u.length,l=e.pads.length,p=h(c),f=d(t,\"inputDims\"),g=d(e.pads,\"pads\"),b=d(u,\"kernelStrides\"),m=d(e.strides,\"strides\");let y=\"\";return y=e.pads.reduce(((t,e)=>t+e))?`\\n            if (x[j] >= inputDims[j] || x[j] < 0) {\\n              pad++;\\n              isPad = true;\\n              break;\\n            }\\n          }\\n          if (!isPad) {\\n            ${n}\\n          }`:`\\n          }\\n          ${n}\\n        `,`\\n        ${p}\\n        float process(int indices[${a}]) {\\n          int x[${a}];\\n          copyVec(indices, x);\\n          int offset[${c}];\\n          int pads[${l}];\\n          int inputDims[${a}];\\n          int kernelStrides[${c}];\\n          int strides[${c}];\\n          ${g}\\n          ${f}\\n          ${m}\\n          ${b}\\n\\n          float value = ${o};\\n          int pad = 0;\\n          bool isPad = false;\\n          for (int i = 0; i < ${s}; i++) {\\n            offsetToIndices(i, kernelStrides, offset);\\n            isPad = false;\\n            for (int j = ${a} - ${c}; j < ${a}; j++) {\\n              x[j] = indices[j] * strides[j - ${a} + ${c}]\\n                + offset[j - ${a} + ${c}] - pads[j - 2];\\n              ${y}\\n          }\\n          ${r}\\n\\n          return value;\\n        }\\n      `}},d=(t,e)=>{let n=\"\";for(let r=0;r<t.length;r++)n+=`\\n      ${e}[${r}] = ${t[r]};\\n    `;return n},h=t=>`\\n  void offsetToIndices(int offset, int[${t}] strides, out int[${t}] indices) {\\n    if (${t} == 0) {\\n      return;\\n    }\\n    for (int i = 0; i < ${t} - 1; ++i) {\\n      indices[i] = offset / strides[i];\\n      offset -= indices[i] * strides[i];\\n    }\\n    indices[${t} - 1] = offset;\\n  }`},4939:(t,e,n)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.reduceLogSumSquare=e.reduceLogSum=e.reduceProd=e.reduceMin=e.reduceMax=e.reduceMean=e.reduceSum=e.parseReduceAttributes=void 0;const r=n(246),i=n(782),o=n(2517),a=n(2039),s=(t,e,n,r,i)=>{c(e);const o={name:r,inputNames:[\"A\"],inputTypes:[a.TextureType.unpacked]};return[t.run(Object.assign(Object.assign({},o),{cacheHint:n.cacheKey,get:()=>u(t,e,n,r,i,o)}),e)]};e.parseReduceAttributes=t=>{const e=t.attributes.getInts(\"axes\",[]),n=1===t.attributes.getInt(\"keepdims\",1);return(0,r.createAttributeWithCacheKey)({axes:e,keepDims:n})};const u=(t,e,n,r,i,s)=>{const u=[],c=e[0].dims.length||1,l=[],p=o.ShapeUtil.normalizeAxes(n.axes,e[0].dims.length),f=i(e,p);let d=f[1];for(let t=0;t<e[0].dims.length;t++)p.indexOf(t)>=0||0===p.length?(n.keepDims&&u.push(1),d=`\\n          for(int j${t} = 0; j${t} < ${e[0].dims[t]}; j${t}++) {\\n            inputIdx[${t}] = j${t};\\n            ${d}\\n          }`):(l.push(`inputIdx[${t}] = outputIdx[${u.length}];`),u.push(e[0].dims[t]));const h=`\\n      float process(int outputIdx[${u.length||1}]) {\\n        float value;                 // final result\\n        int inputIdx[${c}];      // addressing input data\\n        ${l.join(\"\\n\")}\\n        ${f[0]}       // init ops for reduce max/min\\n        ${d}\\n        ${f[2]}       // final computation for reduce mean\\n        return value;\\n      }`;return Object.assign(Object.assign({},s),{output:{dims:u,type:e[0].type,textureType:a.TextureType.unpacked},shaderSource:h})},c=t=>{if(!t||1!==t.length)throw new Error(\"Reduce op requires 1 input.\");if(-1===i.NUMBER_TYPES.indexOf(t[0].type))throw new Error(\"Invalid input type.\")};e.reduceSum=(t,e,n)=>s(t,e,n,\"ReduceSum\",(()=>[\"value = 0.0;\",\"value += _A(inputIdx);\",\"\"])),e.reduceMean=(t,e,n)=>s(t,e,n,\"ReduceMean\",((t,e)=>{let n=1;for(let r=0;r<t[0].dims.length;r++)(e.indexOf(r)>=0||0===e.length)&&(n*=t[0].dims[r]);return[\"value = 0.0;\",\"value += _A(inputIdx);\",`value /= ${n}.;`]})),e.reduceMax=(t,e,n)=>s(t,e,n,\"ReduceMax\",((t,e)=>{const n=[];for(let r=0;r<t[0].dims.length;r++)(e.indexOf(r)>=0||0===e.length)&&n.push(`inputIdx[${r}] = 0;`);return[`${n.join(\"\\n\")}\\nvalue = _A(inputIdx);`,\"value = max(value, _A(inputIdx));\",\"\"]})),e.reduceMin=(t,e,n)=>s(t,e,n,\"ReduceMin\",((t,e)=>{const n=[];for(let r=0;r<t[0].dims.length;r++)(e.indexOf(r)>=0||0===e.length)&&n.push(`inputIdx[${r}] = 0;`);return[`${n.join(\"\\n\")}\\nvalue = _A(inputIdx);`,\"value = min(value, _A(inputIdx));\",\"\"]})),e.reduceProd=(t,e,n)=>s(t,e,n,\"ReduceProd\",(()=>[\"value = 1.0;\",\"value *= _A(inputIdx);\",\"\"])),e.reduceLogSum=(t,e,n)=>s(t,e,n,\"ReduceLogSum\",(()=>[\"value = 0.0;\",\"value += _A(inputIdx);\",\"value = log(value);\"])),e.reduceLogSumSquare=(t,e,n)=>s(t,e,n,\"ReduceLogSumSquare\",(()=>[\"float t; value = 0.0;\",\"t = _A(inputIdx); value += t * t;\",\"\"]))},7019:(t,e,n)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.isReshapeCheap=e.processDims3D=e.createPackedReshape3DProgramInfoLoader=void 0;const r=n(2517),i=n(5060),o=n(2039),a=n(2827);e.createPackedReshape3DProgramInfoLoader=(t,e,n)=>{const s=(t=>({name:\"Reshape (packed)\",inputTypes:[o.TextureType.packed],inputNames:[\"A\"],cacheHint:`${t}`}))(n);return Object.assign(Object.assign({},s),{get:()=>((t,e,n,s)=>{const u=e.dims,c=s;let l=\"\";for(let t=0;t<4;t++){let e=\"\";switch(t){case 0:e=\"outputCoords = rc;\";break;case 1:e=\"outputCoords = ivec3(rc.x, rc.y+1, rc.z);\";break;case 2:e=\"outputCoords = ivec3(rc.x, rc.y, rc.z+1);\";break;case 3:e=\"outputCoords = ivec3(rc.x, rc.y+1, rc.z+1);\";break;default:throw new Error}l+=`\\n        ${e}\\n        ${t>0?\"if(outputCoords.y < rows && outputCoords.z < cols){\":\"\"}\\n          int flattenedIndex = getFlattenedIndex(outputCoords);\\n\\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flattenedIndex);\\n          vec2 innerDims = vec2(float(inputRC.y),float(inputRC.z));\\n\\n          result[${t}] = getChannel(getA(inputRC.x, inputRC.y, inputRC.z), innerDims);\\n\\n        ${t>0?\"}\":\"\"}\\n      `}const p=(0,i.getGlsl)(t.session.backend.glContext.version),f=`\\n      ${function(t){const e=r.ShapeUtil.computeStrides(t),n=[\"b\",\"r\",\"c\"],i=\"index\",o=e.map(((t,r)=>`int ${n[r]} = ${i} / ${t}; ${r===e.length-1?`int ${n[r+1]} = ${i} - ${n[r]} * ${t}`:`index -= ${n[r]} * ${t}`};`)).join(\"\");return`\\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\\n      ${o}\\n      return ivec3(b, r, c);\\n    }\\n  `}(u)}\\n      ${function(t){const e=r.ShapeUtil.computeStrides(t);return`\\n  int getFlattenedIndex(ivec3 coords) {\\n    // reverse y, z order\\n    return coords.x * ${e[0]} + coords.z * ${e[1]} + coords.y;\\n  }\\n`}(c)}\\n      ${(0,a.unpackFromChannel)()}\\n\\n      void main() {\\n        ivec3 rc = getOutputCoords();\\n\\n        vec4 result = vec4(0.0);\\n\\n        ivec3 outputCoords;\\n        int rows = ${c[2]};\\n        int cols = ${c[1]};\\n\\n        ${l}\\n        ${p.output} = result;\\n      }\\n    `;return Object.assign(Object.assign({},n),{output:{dims:c,type:e.type,textureType:o.TextureType.packed},shaderSource:f,hasMain:!0})})(t,e,s,n)})},e.processDims3D=function(t){if(0===t.length)return[1,1,1];let e=1;for(let n=0;n<t.length-2;++n)e*=t[n];return[e,t.length>1?t[t.length-2]:1,t[t.length-1]]},e.isReshapeCheap=function(t,e){let n=!1;return n=0===t.length||0===e.length||(t.length<2||e.length<2?t[t.length-1]===e[e.length-1]:t[t.length-1]===e[e.length-1]&&t[t.length-2]===e[e.length-2]),n}},718:(t,e,n)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.reshape=void 0;const r=n(2517);e.reshape=(t,e)=>{const n=r.ShapeUtil.calculateReshapedDims(e[0].dims,e[1].integerData);return t.session.pack?[t.reshapePacked(e[0],n)]:[t.reshapeUnpacked(e[0],n)]}},2268:(t,e,n)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.parseResizeAttributesV11=e.parseResizeAttributesV10=e.resize=void 0;const r=n(5060),i=n(2039),o=n(9390),a=n(2827),s=n(9793),u={name:\"Resize\",inputNames:[\"A\"],inputTypes:[i.TextureType.packed]};e.resize=(t,e,n)=>((0,s.validateInputs)(e,n),[t.run(Object.assign(Object.assign({},u),{cacheHint:n.cacheKey,get:()=>c(t,e,n)}),e)]),e.parseResizeAttributesV10=t=>(0,s.parseUpsampleAttributes)(t,10),e.parseResizeAttributesV11=t=>(0,s.parseUpsampleAttributes)(t,11);const c=(t,e,n)=>{const s=(0,r.getGlsl)(t.session.backend.glContext.version),[c,p]=l(e,n);if(c.every((t=>1===t))&&\"tf_crop_and_resize\"!==n.coordinateTransformMode)return Object.assign(Object.assign({},u),{output:{dims:p,type:e[0].type,textureType:i.TextureType.packed},hasMain:!0,shaderSource:`void main() {\\n                    vec4 v = ${s.texture2D}(X, TexCoords);\\n                    ${s.output} = v;\\n                }`});const f=p.length;if(f<2)throw new Error(`output dimension should be at least 2, but got ${f}`);const d=p[f-2],h=p[f-1],g=e[0].dims;if(f!==g.length)throw new Error(`output dimension should match input ${g.length}, but got ${f}`);const b=g[f-2],m=g[f-1],y=c[f-2],_=c[f-1];let v=\"\";if(\"linear\"!==n.mode)throw new Error(`resize (packed) does not support mode: '${n.mode}'`);switch(n.coordinateTransformMode){case\"asymmetric\":v=\"\\n                    vec4 getSourceFracIndex(ivec4 coords) {\\n                        return vec4(coords) / scaleWHWH;\\n                    }\\n                \";break;case\"half_pixel\":v=\"\\n                    vec4 getSourceFracIndex(ivec4 coords) {\\n                        return (vec4(coords) + 0.5) / scaleWHWH - 0.5;\\n                    }\\n                \";break;case\"pytorch_half_pixel\":v=`\\n                    vec4 getSourceFracIndex(ivec4 coords) {\\n                        vec4 fcoords = vec4(coords);\\n                        return vec4(\\n                            ${h}.0 > 1.0 ? (fcoords.x + 0.5) / scaleWHWH.x - 0.5 : 0.0,\\n                            ${d}.0 > 1.0 ? (fcoords.y + 0.5) / scaleWHWH.y - 0.5 : 0.0,\\n                            ${h}.0 > 1.0 ? (fcoords.z + 0.5) / scaleWHWH.z - 0.5 : 0.0,\\n                            ${d}.0 > 1.0 ? (fcoords.w + 0.5) / scaleWHWH.w - 0.5 : 0.0\\n                          );\\n                    }\\n                `;break;case\"align_corners\":v=`\\n                    vec4 getSourceFracIndex(ivec4 coords) {\\n                        vec4 resized = vec4(${h}.0 - 1.0, ${d}.0 - 1.0, ${h}.0 - 1.0,\\n                            ${d}.0 - 1.0);\\n                        vec4 original = vec4(${m}.0 - 1.0, ${b}.0 - 1.0, ${m}.0 - 1.0,\\n                            ${b}.0 - 1.0);\\n                        vec4 new_scale = original / resized;\\n                        return vec4(coords) * new_scale;\\n                    }\\n                `;break;default:throw new Error(`resize (packed) does not support coordinateTransformMode:                                 '${n.coordinateTransformMode}'`)}const w=(0,o.getCoordsDataType)(f),x=`\\n            const vec2 inputWH = vec2(${b}.0, ${m}.0);\\n            const vec4 scaleWHWH = vec4(float(${y}), float(${_}), float(${y}), float(${_}));\\n            ${(0,a.unpackFromChannel)()}\\n            ${v}\\n            float getAValue(int x10, int r, int c, int d) {\\n                return getChannel(getA(x10, r, c, d), vec2(c, d));\\n            }\\n            void main() {\\n                ${w} rc = getOutputCoords();\\n\\n                int batch = rc[0];\\n                int depth = rc[1];\\n\\n                // retrieve the 4 coordinates that is used in the 4 packed output values.\\n                ivec4 coords = ivec4(rc.wz, rc.w + 1, rc.z + 1);\\n\\n                // calculate the source index in fraction\\n                vec4 sourceFrac = getSourceFracIndex(coords);\\n\\n                // get the lower and upper bound of the 4 values that will be packed into one texel.\\n                ivec4 x00 = ivec4(max(sourceFrac.xy, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.xy)));\\n                ivec4 x01 = ivec4(max(sourceFrac.xw, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.xw)));\\n                ivec4 x10 = ivec4(max(sourceFrac.zy, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.zy)));\\n                ivec4 x11 = ivec4(max(sourceFrac.zw, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.zw)));\\n\\n                bool hasNextRow = rc.w < ${d-1};\\n                bool hasNextCol = rc.z < ${h-1};\\n\\n                // pack x00, x01, x10, x11's top-left corner into one vec4 structure\\n                vec4 topLeft = vec4(\\n                    getAValue(batch, depth, x00.x, x00.y),\\n                    hasNextCol ? getAValue(batch, depth, x01.x, x01.y) : 0.0,\\n                    hasNextRow ? getAValue(batch, depth, x10.x, x10.y) : 0.0,\\n                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.x, x11.y) : 0.0);\\n\\n                // pack x00, x01, x10, x11's top-right corner into one vec4 structure\\n                vec4 topRight = vec4(\\n                    getAValue(batch, depth, x00.x, x00.w),\\n                    hasNextCol ? getAValue(batch, depth, x01.x, x01.w) : 0.0,\\n                    hasNextRow ? getAValue(batch, depth, x10.x, x10.w) : 0.0,\\n                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.x, x11.w) : 0.0);\\n\\n                // pack x00, x01, x10, x11's bottom-left corner into one vec4 structure\\n                vec4 bottomLeft = vec4(\\n                    getAValue(batch, depth, x00.z, x00.y),\\n                    hasNextCol ? getAValue(batch, depth, x01.z, x01.y) : 0.0,\\n                    hasNextRow ? getAValue(batch, depth, x10.z, x10.y) : 0.0,\\n                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.z, x11.y) : 0.0);\\n\\n                // pack x00, x01, x10, x11's bottom-right corner into one vec4 structure\\n                vec4 bottomRight = vec4(\\n                    getAValue(batch, depth, x00.z, x00.w),\\n                    hasNextCol ? getAValue(batch, depth, x01.z, x01.w) : 0.0,\\n                    hasNextRow ? getAValue(batch, depth, x10.z, x10.w) : 0.0,\\n                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.z, x11.w) : 0.0);\\n\\n                // calculate the interpolation fraction on u and v direction\\n                vec4 frac = vec4(sourceFrac) - floor(sourceFrac);\\n                vec4 clampFrac = clamp(frac, vec4(0.0), vec4(1.0));\\n\\n                vec4 top = mix(topLeft, topRight, clampFrac.ywyw);\\n                vec4 bottom = mix(bottomLeft, bottomRight, clampFrac.ywyw);\\n                vec4 newValue = mix(top, bottom, clampFrac.xxzz);\\n\\n                ${s.output} = vec4(newValue);\\n            }\\n        `;return Object.assign(Object.assign({},u),{output:{dims:p,type:e[0].type,textureType:i.TextureType.packed},hasMain:!0,shaderSource:x})},l=(t,e)=>{const n=t[0].dims;let r,i=e.scales;if(0===i.length){const o=t[e.scalesInputIdx];if(o&&0!==o.size){if(t[e.sizesInputIdx])throw new Error(\"Only one of scales or sizes must be provided as input.\");i=p(o,e.mode,e.isResize)}else{const o=t[e.sizesInputIdx];if(!o||0===o.size)throw new Error(\"Either scales or sizes MUST be provided as input.\");r=Array.from(o.integerData),i=f(r,n,e.mode,e.isResize)}}else if(t[e.sizesInputIdx])throw new Error(\"Only one of scales or sizes must be provided as input.\");const o=r||n.map(((t,e)=>Math.floor(t*i[e])));return[i,o]},p=(t,e,n)=>{const r=Array.from(t.floatData);return(0,s.scalesValidation)(r,e,n),r},f=(t,e,n,r)=>{const i=e.length,o=new Array(i);for(let n=0,r=i;n<r;n++)if(0===e[n]){if(0!==t[n])throw new Error(\"Input dim is zero but required output dim is non-zero.\");o[n]=1}else o[n]=t[n]/e[n];return(0,s.scalesValidation)(o,n,r),o}},8117:(t,e,n)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.shape=void 0;const r=n(9162);e.shape=(t,e)=>(i(e),[new r.Tensor([e[0].dims.length],\"int32\",void 0,void 0,new Int32Array(e[0].dims))]);const i=t=>{if(!t||1!==t.length)throw new Error(\"Shape requires 1 input.\")}},2278:(t,e,n)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.sliceV10=e.parseSliceAttributes=e.slice=void 0;const r=n(246),i=n(782),o=n(2517),a=n(2039),s={name:\"Slice\",inputNames:[\"A\"],inputTypes:[a.TextureType.unpacked]};e.slice=(t,e,n)=>(c(e),[t.run(Object.assign(Object.assign({},s),{cacheHint:n.cacheKey,get:()=>u(t,e[0],n)}),e)]),e.parseSliceAttributes=t=>{const e=t.attributes.getInts(\"starts\"),n=t.attributes.getInts(\"ends\"),i=t.attributes.getInts(\"axes\",[]);return(0,r.createAttributeWithCacheKey)({starts:e,ends:n,axes:i})};const u=(t,e,n)=>{const r=0===n.axes.length?e.dims.slice(0).map(((t,e)=>e)):n.axes,i=o.ShapeUtil.normalizeAxes(r,e.dims.length),u=n.starts.map(((t,n)=>t>e.dims[i[n]]-1?e.dims[i[n]]:o.ShapeUtil.normalizeAxis(t,e.dims[i[n]]))),c=n.ends.map(((t,n)=>t>e.dims[i[n]]-1?e.dims[i[n]]:o.ShapeUtil.normalizeAxis(t,e.dims[i[n]]))),l=e.dims.slice(),p=[];for(let t=0;t<i.length;t++)l[i[t]]=c[t]-u[t],u[t]>0&&p.push(`outputIdx[${i[t]}] += ${u[t]};`);const f=`\\n      float process(int outputIdx[${l.length}]) {\\n        ${p.join(\"\\n      \")}\\n        return _A(outputIdx);\\n      }`;return Object.assign(Object.assign({},s),{output:{dims:l,type:e.type,textureType:a.TextureType.unpacked},shaderSource:f})},c=t=>{if(!t||1!==t.length)throw new Error(\"Slice requires 1 input.\");if(-1===i.NUMBER_TYPES.indexOf(t[0].type))throw new Error(\"Invalid input type.\")};e.sliceV10=(t,e)=>{p(e);const n=l(t,e);return[t.run(Object.assign(Object.assign({},s),{cacheHint:n.cacheKey,get:()=>u(t,e[0],n)}),[e[0]])]};const l=(t,e)=>{if(!t.session.isInitializer(e[1].dataId)||!t.session.isInitializer(e[2].dataId)||e.length>=4&&!t.session.isInitializer(e[3].dataId)||e.length>=5&&!t.session.isInitializer(e[4].dataId))throw new Error(\"dynamic slice attributes are not allowed\");if(e.length>=5&&e[4].integerData.some((t=>1!==t)))throw new Error(\"currently non-1 steps is not supported for Slice\");const n=Array.from(e[1].integerData),r=Array.from(e[2].integerData),i=e.length>=4?Array.from(e[3].integerData):[];return{starts:n,ends:r,axes:i,cacheKey:`${i};${n};${r}`}},p=t=>{if(!t||t.length<3||t.length>5)throw new Error(\"Invalid input number.\");if(\"int32\"!==t[1].type||1!==t[1].dims.length)throw new Error(\"Invalid input type.\");if(\"int32\"!==t[2].type||1!==t[2].dims.length)throw new Error(\"Invalid input type.\");if(t.length>=4&&(\"int32\"!==t[3].type||1!==t[3].dims.length))throw new Error(\"Invalid input type.\");if(t.length>=5&&(\"int32\"!==t[4].type||1!==t[4].dims.length))throw new Error(\"Invalid input type.\")}},5524:(t,e,n)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.softmaxV13=e.parseSoftmaxAttributesV13=e.parseSoftmaxAttributes=e.softmax=void 0;const r=n(246),i=n(2517),o=n(5060),a=n(2039),s=n(3738),u={name:\"SoftmaxComputeMax\",inputNames:[\"A\"],inputTypes:[a.TextureType.unpacked]},c={name:\"SoftmaxComputeScale\",inputNames:[\"A\",\"Max\"],inputTypes:[a.TextureType.unpacked,a.TextureType.unpacked]},l={name:\"SoftMax\",inputNames:[\"A\",\"Max\",\"Norm\"],inputTypes:[a.TextureType.unpacked,a.TextureType.unpacked,a.TextureType.unpacked]};e.softmax=(t,e,n)=>{g(e);const r=e[0].dims.slice(),o=i.ShapeUtil.normalizeAxis(n.axis,r.length),a=i.ShapeUtil.sizeToDimension(r,o),s=i.ShapeUtil.sizeFromDimension(r,o);return p(t,e,n,a,s)},e.parseSoftmaxAttributes=t=>(0,r.createAttributeWithCacheKey)({axis:t.attributes.getInt(\"axis\",1)}),e.parseSoftmaxAttributesV13=t=>(0,r.createAttributeWithCacheKey)({axis:t.attributes.getInt(\"axis\",-1)}),e.softmaxV13=(t,e,n)=>{g(e);const o=e[0].dims.slice(),a=i.ShapeUtil.normalizeAxis(n.axis,o.length),u=o.length,c=a!==u-1,l=[];let f,d=[],h=[];c&&(d=Array.from({length:u}).map(((t,e)=>e)),d[a]=u-1,d[u-1]=a,d.map((t=>l.push(o[t]))),f=(0,r.createAttributeWithCacheKey)({perm:d}),h=(0,s.transpose)(t,e,f));const b=c?i.ShapeUtil.sizeToDimension(l,u-1):i.ShapeUtil.sizeToDimension(o,u-1),m=c?i.ShapeUtil.sizeFromDimension(l,u-1):i.ShapeUtil.sizeFromDimension(o,u-1),y=p(t,c?h:e,n,b,m);return c?(0,s.transpose)(t,y,f):y};const p=(t,e,n,r,i)=>{const o=f(t,e[0],r,i,[r]),a=t.run(Object.assign(Object.assign({},u),{cacheHint:n.cacheKey,get:()=>o}),e),s=d(t,e[0],r,i,o.output.dims,[r]),p=t.run(Object.assign(Object.assign({},c),{cacheHint:n.cacheKey,get:()=>s}),[e[0],a]),g=h(t,e[0],r,i,o.output.dims,s.output.dims);return[t.run(Object.assign(Object.assign({},l),{cacheHint:n.cacheKey,get:()=>g}),[e[0],a,p])]},f=(t,e,n,r,i)=>{const[s,c]=t.calculateTextureWidthAndHeight(e.dims,a.TextureType.unpacked),l=i.length;if(n<1||r<1)throw new Error(\"Logical row count N and feature count D must be greater than or equal to 1\");if(1!==i.length)throw new Error(\"Dimensionality of the output should be 1\");if(i[0]!==n)throw new Error(\"Shape of the output should be equal to logical row count\");const p=(0,o.getGlsl)(t.session.backend.glContext.version),f=`\\n      float process(int[${l}] indices) {\\n        int logical_row_start_offset = indices[0] * ${r};\\n\\n        float max = getColorAsFloat(${p.texture2D}(A, offsetToCoords(logical_row_start_offset, ${s},\\n        ${c} )));\\n        for(int i=1; i<${r}; ++i)\\n        {\\n          float current = getColorAsFloat(${p.texture2D}(A, offsetToCoords(logical_row_start_offset + i,\\n            ${s}, ${c})));\\n          if(current > max)\\n          max = current;\\n        }\\n\\n        return max;\\n      }`;return Object.assign(Object.assign({},u),{output:{dims:i,type:e.type,textureType:a.TextureType.unpacked},shaderSource:f})},d=(t,e,n,r,i,s)=>{const[u,l]=t.calculateTextureWidthAndHeight(e.dims,a.TextureType.unpacked),p=s.length;if(n<1||r<1)throw new Error(\"Logical row count N and feature count D must be greater than or equal to 1\");if(1!==s.length)throw new Error(\"Dimensionality of the output should be 1\");if(s[0]!==n)throw new Error(\"Shape of the output should be equal to logical row count\");if(1!==i.length)throw new Error(\"Dimensionality of the intermediate results should be 1\");if(i[0]!==n)throw new Error(\"Shape of the intermediate results should be equal to logical row count\");const f=`\\n      float process(int[${p}] indices) {\\n        int logical_row_start_offset = indices[0] * ${r};\\n\\n        float norm_factor = 0.0;\\n        float max = _Max(indices);\\n        for(int i=0; i<${r}; ++i)\\n        {\\n          norm_factor += exp(getColorAsFloat(${(0,o.getGlsl)(t.session.backend.glContext.version).texture2D}(A, offsetToCoords(logical_row_start_offset + i,\\n            ${u}, ${l}))) - max);\\n        }\\n\\n        return norm_factor;\\n      }`;return Object.assign(Object.assign({},c),{output:{dims:s,type:e.type,textureType:a.TextureType.unpacked},shaderSource:f})},h=(t,e,n,r,i,o)=>{const[s,u]=t.calculateTextureWidthAndHeight(e.dims,a.TextureType.unpacked),c=e.dims.length;if(n<1||r<1)throw new Error(\"Logical row count N and feature count D must be greater than or equal to 1\");if(1!==i.length||1!==o.length)throw new Error(\"Dimensionality of the intermediate results should be 1\");if(i[0]!==n||o[0]!==n)throw new Error(\"Shape of the intermediate results should be equal to logical row count\");const p=`\\n      float process(int[${c}] indices) {\\n\\n      // get offset of current logical tensor index from the 2-D texture coordinates (TexCoords)\\n      int offset = coordsToOffset(TexCoords, ${s}, ${u});\\n\\n      //determine the logical row for this index\\n      int logical_row_index[1];\\n      logical_row_index[0] = offset / ${r};\\n\\n      float norm_factor = _Norm(logical_row_index);\\n\\n      // avoid possible division by 0\\n      // if norm_facor is 0, all elements are zero\\n      // if so, return 0\\n      if(norm_factor == 0.0)\\n        return 0.0;\\n\\n      return exp(_A(indices) - _Max(logical_row_index)) / norm_factor;\\n    }`;return Object.assign(Object.assign({},l),{output:{dims:e.dims,type:e.type,textureType:a.TextureType.unpacked},shaderSource:p})},g=t=>{if(!t||1!==t.length)throw new Error(\"Softmax requires 1 input.\");if(\"float32\"!==t[0].type&&\"float64\"!==t[0].type)throw new Error(\"Invalid input type\")}},5975:(t,e,n)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.parseSplitAttributes=e.split=void 0;const r=n(246),i=n(2517),o=n(2039),a={name:\"Split\",inputNames:[\"A\"],inputTypes:[o.TextureType.unpacked]};e.split=(t,e,n)=>{c(e);const r=i.ShapeUtil.normalizeAxis(n.axis,e[0].dims.length),o=s(t,e,r,n),l=[];for(let i=0;i<o;++i)l.push(t.run(Object.assign(Object.assign({},a),{cacheHint:`${n.cacheKey};${i}`,get:()=>u(t,e[0],n,r,i)}),e));return l},e.parseSplitAttributes=t=>{const e=t.attributes.getInt(\"axis\",0),n=t.attributes.getInts(\"split\",[]),i=t.outputs.length;return(0,r.createAttributeWithCacheKey)({axis:e,split:n,numOutputs:i})};const s=(t,e,n,r)=>{const[,o]=i.SplitUtil.splitShape(e[0].dims,n,r.split,r.numOutputs);return o.length},u=(t,e,n,r,s)=>{const[u,c]=i.SplitUtil.splitShape(e.dims,r,n.split,n.numOutputs),l=c[s],p=u[s],f=`\\n      float process(int indices[${p.length}]) {\\n        indices[${r}] += ${l};\\n        return _A(indices);\\n      }\\n    `;return Object.assign(Object.assign({},a),{cacheHint:`${n.cacheKey}:${s}`,output:{dims:p,type:e.type,textureType:o.TextureType.unpacked},shaderSource:f})},c=t=>{if(!t||1!==t.length)throw new Error(\"Split requires one input.\");if(\"int8\"!==t[0].type&&\"uint8\"!==t[0].type&&\"int16\"!==t[0].type&&\"uint16\"!==t[0].type&&\"int32\"!==t[0].type&&\"uint32\"!==t[0].type&&\"float32\"!==t[0].type&&\"float64\"!==t[0].type&&\"bool\"!==t[0].type)throw new Error(\"Invalid input type.\")}},3933:(t,e,n)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.parseSqueezeAttributes=e.squeezeV13=e.squeeze=void 0;const r=n(2517);e.squeeze=(t,e,n)=>{i(e);const o=r.ShapeUtil.squeezeShape(e[0].dims,n);return[t.reshapeUnpacked(e[0],o)]},e.squeezeV13=(t,n)=>(o(n),(0,e.squeeze)(t,[n[0]],Array.from(n[1].integerData))),e.parseSqueezeAttributes=t=>t.attributes.getInts(\"axes\");const i=t=>{if(!t||1!==t.length)throw new Error(\"Squeeze requires 1 input.\");if(\"string\"===t[0].type)throw new Error(\"invalid input tensor types.\")},o=t=>{if(!t||2!==t.length)throw new Error(\"Squeeze requires 2 inputs.\");if(\"int32\"!==t[1].type)throw new Error(\"Invalid input type.\")}},6558:(t,e,n)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.sum=void 0;const r=n(5060),i=n(2039);e.sum=(t,e)=>{a(e);const n={name:\"Sum\",inputNames:e.map(((t,e)=>`X${e}`)),inputTypes:new Array(e.length).fill(i.TextureType.unpacked)};return[t.run(Object.assign(Object.assign({},n),{get:()=>o(t,e,n)}),e)]};const o=(t,e,n)=>{const o=(0,r.getGlsl)(t.session.backend.glContext.version),a=e[0].dims.slice(),s=e.map(((t,e)=>`${o.texture2D}(X${e},TexCoords)`)).join(\" + \"),u=`\\n      void main() {\\n        vec4 result = ${s};\\n        ${o.output} = result;\\n      }\\n    `;return Object.assign(Object.assign({},n),{output:{dims:a,type:e[0].type,textureType:i.TextureType.unpacked},hasMain:!0,shaderSource:u})},a=t=>{if(!t||0===t.length)throw new Error(\"Sum requires inputs.\");const e=t[0].dims.length;for(let n=1;n<t.length;n++){if(e!==t[n].dims.length)throw new Error(\"Input shapes are mismatched.\");for(let r=0;r<e;r++)if(t[0].dims[r]!==t[n].dims[r])throw new Error(\"Input shapes are not matched.\")}if(\"float32\"!==t[0].type&&\"float64\"!==t[0].type)throw new Error(\"Invalid input type.\");for(let e=1;e<t.length;e++)if(t[0].type!==t[e].type)throw new Error(\"Input types are not matched.\")}},5723:(t,e,n)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.tile=void 0;const r=n(782),i=n(2039);e.tile=(t,e)=>{a(e);const n={name:\"Tile\",inputNames:[\"A\"],inputTypes:[i.TextureType.unpacked]};return[t.run(Object.assign(Object.assign({},n),{get:()=>o(t,e,n)}),e)]};const o=(t,e,n)=>{const r=e[0].dims.slice(),o=new Array(r.length),a=[];for(let t=0;t<r.length;t++)o[t]=r[t]*e[1].numberData[t],a.push(`inputIdx[${t}] = int(mod(float(outputIdx[${t}]), ${r[t]}.));`);const s=o.length,u=`\\n      float process(int outputIdx[${s}]) {\\n        int inputIdx[${s}];\\n        ${a.join(\"\\n\")}\\n        return _A(inputIdx);\\n      }\\n    `;return Object.assign(Object.assign({},n),{output:{dims:o,type:e[0].type,textureType:i.TextureType.unpacked},shaderSource:u})},a=t=>{if(!t||2!==t.length)throw new Error(\"Tile requires 2 input.\");if(1!==t[1].dims.length)throw new Error(\"The second input shape must 1 dimension.\");if(t[1].dims[0]!==t[0].dims.length)throw new Error(\"Invalid input shape.\");if(-1===r.NUMBER_TYPES.indexOf(t[0].type))throw new Error(\"Invalid input type.\");if(\"int32\"!==t[1].type&&\"int16\"!==t[1].type)throw new Error(\"Invalid repeat type.\")}},3738:(t,e,n)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.parseTransposeAttributes=e.transpose=void 0;const r=n(246),i=n(2517),o=n(2039),a={name:\"Transpose\",inputNames:[\"A\"],inputTypes:[o.TextureType.unpacked]};e.transpose=(t,e,n)=>(p(e),[t.run(Object.assign(Object.assign({},a),{cacheHint:n.cacheKey,get:()=>s(t,e[0],n.perm)}),e)]),e.parseTransposeAttributes=t=>(0,r.createAttributeWithCacheKey)({perm:t.attributes.getInts(\"perm\",[])});const s=(t,e,n)=>{const r=e.dims;n=u(r,n);const i=c(r,n),s=r.length,p=`\\n      ${l(\"perm\",n,s)}\\n      float process(int indices[${s}]) {\\n        int a[${s}];\\n        perm(a, indices);\\n        return _A(a);\\n      }`;return Object.assign(Object.assign({},a),{output:{dims:i,type:e.type,textureType:o.TextureType.unpacked},shaderSource:p})},u=(t,e)=>(e&&e.length!==t.length&&(e=[...t.keys()].reverse()),e),c=(t,e)=>(e=u(t,e),i.ShapeUtil.sortBasedOnPerm(t,e)),l=(t,e,n)=>{const r=[];r.push(`void ${t}(out int a[${n}], int src[${n}]) {`);for(let t=0;t<n;++t)r.push(`\\ta[${e[t]}]=src[${t}];`);return r.push(\"\\t}\"),r.join(\"\\n\")},p=t=>{if(!t||1!==t.length)throw new Error(\"Transpose requires 1 input.\");if(\"float32\"!==t[0].type&&\"float64\"!==t[0].type)throw new Error(\"input should be float tensor\")}},8710:(t,e,n)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.encodeAsUint8=void 0;const r=n(5060),i=n(2039);e.encodeAsUint8=(t,e)=>{const n=e.shape,o=(0,r.getGlsl)(t.session.backend.glContext.version),a=`\\n    const float FLOAT_MAX = 1.70141184e38;\\n    const float FLOAT_MIN = 1.17549435e-38;\\n\\n    bool isNaN(float val) {\\n      return (val < 1.0 || 0.0 < val || val == 0.0) ? false : true;\\n    }\\n\\n    highp vec4 encodeAsUint8(highp float v) {\\n      if (isNaN(v)) {\\n        return vec4(255, 255, 255, 255);\\n      }\\n\\n      highp float av = abs(v);\\n\\n      if(av < FLOAT_MIN) {\\n        return vec4(0.0, 0.0, 0.0, 0.0);\\n      } else if(v > FLOAT_MAX) {\\n        return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\\n      } else if(v < -FLOAT_MAX) {\\n        return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\\n      }\\n\\n      highp vec4 c = vec4(0,0,0,0);\\n\\n      highp float e = floor(log2(av));\\n      highp float m = exp2(fract(log2(av))) - 1.0;\\n\\n      c[2] = floor(128.0 * m);\\n      m -= c[2] / 128.0;\\n      c[1] = floor(32768.0 * m);\\n      m -= c[1] / 32768.0;\\n      c[0] = floor(8388608.0 * m);\\n\\n      highp float ebias = e + 127.0;\\n      c[3] = floor(ebias / 2.0);\\n      ebias -= c[3] * 2.0;\\n      c[2] += floor(ebias) * 128.0;\\n\\n      c[3] += 128.0 * step(0.0, -v);\\n\\n      return c / 255.0;\\n    }\\n\\n    void main() {\\n      float value = ${o.texture2D}(X,TexCoords).r;\\n      ${o.output} = encodeAsUint8(value);\\n    }`,s={name:\"Uint8Encode\",inputTypes:[i.TextureType.unpacked],inputNames:[\"X\"],output:{dims:n,type:e.tensor.type,textureType:i.TextureType.downloadUint8AsFloat},shaderSource:a,hasMain:!0};return t.executeProgram(s,[e.tensor])}},4909:(t,e,n)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.tanh=e.tan=e.sqrt=e.sin=e.sigmoid=e.relu=e.not=e.neg=e.log=e.parseLeakyReluAttributes=e.leakyRelu=e.identity=e.floor=e.exp=e.parseEluAttributes=e.elu=e.cos=e.ceil=e.clipV11=e.parseClipAttributes=e.clip=e.atan=e.asin=e.acos=e.abs=e.glslTanh=e.glslTan=e.glslSqrt=e.glslSigmoid=e.glslRelu=e.glslSin=e.glslNot=e.glslNeg=e.glslLog=e.glslLeakyRelu=e.glslIdentity=e.glslClip=e.glslFloor=e.glslExp=e.glslElu=e.glslCos=e.glslCeil=e.glslAtan=e.glslAsin=e.glslAcos=e.glslAbs=void 0;const r=n(246),i=n(2517),o=n(8520),a=n(5060),s=n(2039);function u(){return P(\"abs\")}function c(){return P(\"acos\")}function l(){return P(\"asin\")}function p(){return P(\"atan\")}function f(){return P(\"ceil\")}function d(){return P(\"cos\")}function h(t){const e=\"elu\";return{body:`\\n  const float alpha = float(${t});\\n\\n  float ${e}_(float a) {\\n    return a >= 0.0 ? a: (exp(a) - 1.0) * alpha;\\n  }\\n  vec4 ${e}_(vec4 v) {\\n    return vec4(${e}_(v.x), ${e}_(v.y), ${e}_(v.z), ${e}_(v.w));\\n  }\\n  `,name:e,type:o.FunctionType.ValueBased}}function g(){return P(\"exp\")}function b(){return P(\"floor\")}function m(t,e){const n=\"clip\";return{body:`\\n  const float min = float(${t});\\n  const float max = float(${e});\\n\\n  float ${n}_(float a) {\\n    return clamp(a, min, max);\\n  }\\n  vec4 ${n}_(vec4 v) {\\n    return clamp(v, min, max);\\n  }\\n  `,name:n,type:o.FunctionType.ValueBased}}function y(){const t=\"indentity\";return{body:`\\n  float ${t}_(float a) {\\n    return a;\\n  }\\n  vec4 ${t}_(vec4 v) {\\n    return v;\\n  }\\n  `,name:t,type:o.FunctionType.ValueBased}}function _(t){const e=\"leakyRelu\";return{body:`\\n  const float alpha = float(${t});\\n\\n  float ${e}_(float a) {\\n    return a < 0.0 ? a * alpha : a;\\n  }\\n  vec4 ${e}_(vec4 v) {\\n    return vec4(${e}_(v.x), ${e}_(v.y), ${e}_(v.z), ${e}_(v.w));\\n  }\\n  `,name:e,type:o.FunctionType.ValueBased}}function v(){return P(\"log\")}function w(){const t=\"neg\";return{body:`\\n  float ${t}_(float a) {\\n    return -a;\\n  }\\n  vec4 ${t}_(vec4 v) {\\n    return -v;\\n  }\\n  `,name:t,type:o.FunctionType.ValueBased}}function x(){const t=\"not\";return{body:`\\n  float ${t}_(float a) {\\n    return float( ! bool(a) );\\n  }\\n  bool ${t}_(bool a) {\\n    return !a;\\n  }\\n  vec4 ${t}_(vec4 v) {\\n    return vec4(!bool(v.x), !bool(v.y), !bool(v.z), !bool(v.w));\\n  }\\n  bvec4 ${t}_(bvec4 v) {\\n    return bvec4(!v.x, !v.y, !v.z, !v.w);\\n  }\\n  `,name:t,type:o.FunctionType.ValueBased}}function T(){return P(\"sin\")}function S(){const t=\"relu\";return{body:`\\n  float ${t}_(float a) {\\n    return max( a, 0.0 );\\n  }\\n  vec4 ${t}_(vec4 v) {\\n    return max( v, 0.0 );\\n  }\\n  `,name:t,type:o.FunctionType.ValueBased}}function O(){const t=\"sigmoid\";return{body:`\\n  float ${t}_(float a) {\\n    return 1.0 / (1.0 + exp(-a));\\n  }\\n  vec4 ${t}_(vec4 v) {\\n    return 1.0 / (1.0 + exp(-v));\\n  }\\n  `,name:t,type:o.FunctionType.ValueBased}}function A(){return P(\"sqrt\")}function E(){return P(\"tan\")}function I(){const t=\"tanh\";return{body:`\\n  float ${t}_(float a) {\\n    a = clamp(a, -10., 10.);\\n    a = exp(2.*a);\\n    return (a - 1.) / (a + 1.);\\n  }\\n  vec4 ${t}_(vec4 v) {\\n    v = clamp(v, -10., 10.);\\n    v = exp(2.*v);\\n    return (v - 1.) / (v + 1.);\\n  }\\n  `,name:t,type:o.FunctionType.ValueBased}}function P(t){return{body:`\\n  float ${t}_(float a) {\\n    return ${t}(a);\\n  }\\n  vec4 ${t}_(vec4 v) {\\n    return ${t}(v);\\n  }\\n  `,name:t,type:o.FunctionType.ValueBased}}e.glslAbs=u,e.glslAcos=c,e.glslAsin=l,e.glslAtan=p,e.glslCeil=f,e.glslCos=d,e.glslElu=h,e.glslExp=g,e.glslFloor=b,e.glslClip=m,e.glslIdentity=y,e.glslLeakyRelu=_,e.glslLog=v,e.glslNeg=w,e.glslNot=x,e.glslSin=T,e.glslRelu=S,e.glslSigmoid=O,e.glslSqrt=A,e.glslTan=E,e.glslTanh=I;const D=(t,e,n,r)=>{const i=t.session.pack?s.TextureType.packed:s.TextureType.unpacked,o={name:n.name,inputTypes:[i],inputNames:[\"A\"],cacheHint:r};return Object.assign(Object.assign({},o),{get:()=>((t,e,n,r)=>{const i=t.session.pack?s.TextureType.packed:s.TextureType.unpacked,o=(0,a.getGlsl)(t.session.backend.glContext.version);return Object.assign(Object.assign({},e),{output:{dims:n.dims,type:n.type,textureType:i},shaderSource:`\\n     ${r.body}\\n     void main() {\\n       vec4 v = ${o.texture2D}(A, TexCoords);\\n       v = ${r.name}_(v);\\n       ${o.output} = v;\\n     }\\n     `,hasMain:!0})})(t,o,e,n)})};e.abs=(t,e)=>[t.run(D(t,e[0],u()),e)],e.acos=(t,e)=>[t.run(D(t,e[0],c()),e)],e.asin=(t,e)=>[t.run(D(t,e[0],l()),e)],e.atan=(t,e)=>[t.run(D(t,e[0],p()),e)],e.clip=(t,e,n)=>[t.run(D(t,e[0],m(n.min,n.max),n.cacheKey),e)],e.parseClipAttributes=t=>(0,r.createAttributeWithCacheKey)({min:t.attributes.getFloat(\"min\",i.MIN_CLIP),max:t.attributes.getFloat(\"max\",i.MAX_CLIP)}),e.clipV11=(t,n)=>{const r=$(t,n);return(0,e.clip)(t,[n[0]],r)};const $=(t,e)=>{if(e.length>=3&&(!t.session.isInitializer(e[1].dataId)||!t.session.isInitializer(e[2].dataId)))throw new Error(\"dynamic clip attributes are not allowed\");const n=e.length>=3?e[1].numberData[0]:i.MIN_CLIP,o=e.length>=3?e[2].numberData[0]:i.MAX_CLIP;return(0,r.createAttributeWithCacheKey)({min:n,max:o})};e.ceil=(t,e)=>[t.run(D(t,e[0],f()),e)],e.cos=(t,e)=>[t.run(D(t,e[0],d()),e)],e.elu=(t,e,n)=>[t.run(D(t,e[0],h(n.alpha),n.cacheKey),e)],e.parseEluAttributes=t=>(0,r.createAttributeWithCacheKey)({alpha:t.attributes.getFloat(\"alpha\",1)}),e.exp=(t,e)=>[t.run(D(t,e[0],g()),e)],e.floor=(t,e)=>[t.run(D(t,e[0],b()),e)],e.identity=(t,e)=>[t.run(D(t,e[0],y()),e)],e.leakyRelu=(t,e,n)=>[t.run(D(t,e[0],_(n.alpha),n.cacheKey),e)],e.parseLeakyReluAttributes=t=>(0,r.createAttributeWithCacheKey)({alpha:t.attributes.getFloat(\"alpha\",.01)}),e.log=(t,e)=>[t.run(D(t,e[0],v()),e)],e.neg=(t,e)=>[t.run(D(t,e[0],w()),e)],e.not=(t,e)=>[t.run(D(t,e[0],x()),e)],e.relu=(t,e)=>[t.run(D(t,e[0],S()),e)],e.sigmoid=(t,e)=>[t.run(D(t,e[0],O()),e)],e.sin=(t,e)=>[t.run(D(t,e[0],T()),e)],e.sqrt=(t,e)=>[t.run(D(t,e[0],A()),e)],e.tan=(t,e)=>[t.run(D(t,e[0],E()),e)],e.tanh=(t,e)=>[t.run(D(t,e[0],I()),e)]},5611:(t,e,n)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.createUnpackProgramInfoLoader=e.createUnpackProgramInfo=void 0;const r=n(5060),i=n(2039),o=n(9390),a=n(2827),s={name:\"unpack\",inputNames:[\"A\"],inputTypes:[i.TextureType.packed]};e.createUnpackProgramInfo=(t,e)=>{const n=e.dims.length,u=(0,a.getChannels)(\"rc\",n),c=u.slice(-2),l=(0,o.getCoordsDataType)(n),p=(0,a.unpackFromChannel)(),f=0===e.dims.length?\"\":function(t,e){if(1===t)return\"rc\";let n=\"\";for(let r=0;r<t;r++)n+=e[r],r<t-1&&(n+=\",\");return n}(n,u),d=n<=1?\"rc\":`vec2(${c.join(\",\")})`,h=`\\n    ${p}\\n    void main() {\\n      ${l} rc = getOutputCoords();\\n\\n       // Sample the texture with the coords to get the rgba channel value.\\n       vec4 packedInput = getA(${f});\\n\\n       ${(0,r.getGlsl)(t.session.backend.glContext.version).output} = vec4(getChannel(packedInput, ${d}), 0, 0, 0);\\n     }\\n   `;return Object.assign(Object.assign({},s),{hasMain:!0,output:{dims:e.dims,type:e.type,textureType:i.TextureType.unpacked},shaderSource:h})},e.createUnpackProgramInfoLoader=(t,n)=>Object.assign(Object.assign({},s),{get:()=>(0,e.createUnpackProgramInfo)(t,n)})},8428:(t,e,n)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.parseUnsqueezeAttributes=e.unsqueezeV13=e.unsqueeze=void 0;const r=n(2517);e.unsqueeze=(t,e,n)=>{i(e);const o=r.ShapeUtil.unsqueezeShape(e[0].dims,n);return[t.reshapeUnpacked(e[0],o)]},e.unsqueezeV13=(t,n)=>(o(n),(0,e.unsqueeze)(t,[n[0]],Array.from(n[1].integerData))),e.parseUnsqueezeAttributes=t=>t.attributes.getInts(\"axes\");const i=t=>{if(!t||1!==t.length)throw new Error(\"Unsqueeze requires 1 input.\");if(\"string\"===t[0].type)throw new Error(\"invalid input tensor types.\")},o=t=>{if(!t||2!==t.length)throw new Error(\"Unsqueeze requires 2 inputs.\");if(\"int32\"!==t[1].type)throw new Error(\"Invalid input type.\")}},9793:(t,e,n)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.scalesValidation=e.validateInputs=e.parseUpsampleAttributes=e.parseUpsampleAttributesV9=e.parseUpsampleAttributesV7=e.upsample=void 0;const r=n(246),i=n(5060),o=n(2039),a={name:\"Upsample\",inputNames:[\"X\"],inputTypes:[o.TextureType.unpacked]};e.upsample=(t,n,r)=>((0,e.validateInputs)(n,r),[t.run(Object.assign(Object.assign({},a),{cacheHint:r.cacheKey,get:()=>s(t,n,r)}),n)]),e.parseUpsampleAttributesV7=t=>(0,e.parseUpsampleAttributes)(t,7),e.parseUpsampleAttributesV9=t=>(0,e.parseUpsampleAttributes)(t,9),e.parseUpsampleAttributes=(t,n)=>{const i=n>=10,o=t.attributes.getString(\"mode\",\"nearest\");if(\"nearest\"!==o&&\"linear\"!==o&&(n<11||\"cubic\"!==o))throw new Error(`unrecognized mode: ${o}`);let a=[];n<9&&(a=t.attributes.getFloats(\"scales\"),(0,e.scalesValidation)(a,o,i));const s=t.attributes.getFloat(\"extrapolation_value\",0),u=n>10?t.attributes.getString(\"coordinate_transformation_mode\",\"half_pixel\"):\"asymmetric\";if(-1===[\"asymmetric\",\"pytorch_half_pixel\",\"tf_half_pixel_for_nn\",\"align_corners\",\"tf_crop_and_resize\",\"half_pixel\"].indexOf(u))throw new Error(`coordinate_transform_mode '${u}' is not supported`);const c=\"tf_crop_and_resize\"===u,l=c,p=\"nearest\"===o&&n>=11?t.attributes.getString(\"nearest_mode\",\"round_prefer_floor\"):\"\";if(-1===[\"round_prefer_floor\",\"round_prefer_ceil\",\"floor\",\"ceil\",\"\"].indexOf(p))throw new Error(`nearest_mode '${p}' is not supported`);const f=t.attributes.getFloat(\"cubic_coeff_a\",-.75),d=0!==t.attributes.getInt(\"exclude_outside\",0);if(d&&\"cubic\"!==o)throw new Error(\"exclude_outside can be set to 1 only when mode is CUBIC.\");const h=n<11||\"nearest\"===o&&\"asymmetric\"===u&&\"floor\"===p;let g=0,b=0,m=0;return n>10?t.inputs.length>2?(g=1,b=2,m=3):(b=1,m=2):9===n&&(b=1),(0,r.createAttributeWithCacheKey)({opset:n,isResize:i,mode:o,scales:a,extrapolationValue:s,coordinateTransformMode:u,useExtrapolation:l,needRoiInput:c,nearestMode:p,cubicCoefficientA:f,excludeOutside:d,useNearest2xOptimization:h,roiInputIdx:g,scalesInputIdx:b,sizesInputIdx:m})};const s=(t,e,n)=>{const r=(0,i.getGlsl)(t.session.backend.glContext.version),[s,u]=t.calculateTextureWidthAndHeight(e[0].dims,o.TextureType.unpacked),c=e[0].dims.map(((t,e)=>Math.floor(t*n.scales[e]))),[l,p]=t.calculateTextureWidthAndHeight(c,o.TextureType.unpacked),f=c.length,d=new Array(f),h=new Array(f);let g=`\\n      int output_pitches[${f}];\\n      int input_pitches[${f}];\\n      `;for(let t=f-1;t>=0;t--)d[t]=t===f-1?1:d[t+1]*c[t+1],h[t]=t===f-1?1:h[t+1]*e[0].dims[t+1],g+=`\\n        output_pitches[${t}] = ${d[t]};\\n        input_pitches[${t}] = ${h[t]};\\n        `;const b=`\\n      float getInputFloat(int index) {\\n        vec2 coords = offsetToCoords(index, ${s}, ${u});\\n        float value = getColorAsFloat(${r.texture2D}(X, coords));\\n        return value;\\n      }\\n      `,m=\"nearest\"===n.mode?`\\n    ${b}\\n    float process(int indices[${f}]) {\\n      int input_index = 0;\\n      int output_index = coordsToOffset(TexCoords, ${l}, ${p});\\n\\n      ${g}\\n\\n      int d, m;\\n      for (int dim = 0; dim < ${f}; ++dim) {\\n        d = output_index / output_pitches[dim];\\n        m = output_index - d * output_pitches[dim];\\n        output_index = m;\\n\\n        if (scales[dim] != 1 && d > 0) {\\n          int d2 = d / scales[dim];\\n          m = d - d2 * scales[dim];\\n          d = d2;\\n        }\\n        input_index += input_pitches[dim] * d;\\n      }\\n\\n      return getInputFloat(input_index);\\n    }`:4===f?`\\n    ${b}\\n    float process(int indices[4]) {\\n      int input_index = 0;\\n      int output_index = coordsToOffset(TexCoords, ${l}, ${p});\\n\\n      ${g}\\n\\n      int m;\\n      int index_of_dim0, index_of_dim1, index_of_dim2, index_of_dim3;\\n      index_of_dim0 = output_index / output_pitches[0];\\n      m = output_index - index_of_dim0 * output_pitches[0];\\n      index_of_dim1 = m / output_pitches[1];\\n      m = m - index_of_dim1 * output_pitches[1];\\n      index_of_dim2 = m / output_pitches[2];\\n      m = m - index_of_dim2 * output_pitches[2];\\n      index_of_dim3 = m;\\n\\n      int index_of_input_dim2, index_of_input_dim3, x_offset, y_offset;\\n      index_of_input_dim2 = index_of_dim2 / scales[2];\\n      y_offset = index_of_dim2 - index_of_input_dim2 * scales[2];\\n      index_of_input_dim3 = index_of_dim3 / scales[3];\\n      x_offset = index_of_dim3 - index_of_input_dim3 * scales[3];\\n\\n      input_index = index_of_dim0 * input_pitches[0] +\\n            index_of_dim1 * input_pitches[1] +\\n            index_of_input_dim2 * input_pitches[2] +\\n            index_of_input_dim3;\\n\\n      float x00 = getInputFloat(input_index);\\n      float x10, x01, x11;\\n\\n      bool end_of_dim2 = false;\\n      if (index_of_input_dim2 == (${e[0].dims[2]} - 1)) {\\n        // It's the end in dimension 2\\n        x01 = x00;\\n        end_of_dim2 = true;\\n      } else {\\n        x01 = getInputFloat(input_index + input_pitches[2]);\\n      }\\n\\n      if (index_of_input_dim3 == (input_pitches[2] - 1)) {\\n        // It's the end in dimension 3\\n        x10 = x00;\\n        x11 = x01;\\n      }\\n      else {\\n        x10 = getInputFloat(input_index + 1);\\n        x11 = end_of_dim2 ? x10 : getInputFloat(input_index + input_pitches[2] + 1);\\n      }\\n\\n      float y0 = x00 + float(y_offset) * (x01 - x00) / float(scales[2]);\\n      float y1 = x10 + float(y_offset) * (x11 - x10) / float(scales[2]);\\n      return y0 + float(x_offset) * (y1 - y0) / float(scales[3]);\\n    }`:`\\n    ${b}\\n    float process(int indices[2]) {\\n      int input_index = 0;\\n      int output_index = coordsToOffset(TexCoords, ${l}, ${p});\\n\\n      ${g}\\n\\n      int m;\\n      int index_of_dim0, index_of_dim1;\\n      index_of_dim0 = output_index / output_pitches[0];\\n      m = output_index - index_of_dim0 * output_pitches[0];\\n      index_of_dim1 = m;\\n\\n      int index_of_input_dim0, index_of_input_dim1, x_offset, y_offset;\\n      index_of_input_dim0 = index_of_dim0 / scales[0];\\n      y_offset = index_of_dim0 - index_of_input_dim0 * scales[0];\\n      index_of_input_dim1 = index_of_dim1 / scales[1];\\n      x_offset = index_of_dim1 - index_of_input_dim1 * scales[1];\\n\\n      input_index = index_of_input_dim0 * input_pitches[0] + index_of_input_dim1;\\n\\n      float x00 = getInputFloat(input_index);\\n      float x10, x01, x11;\\n\\n      bool end_of_dim0 = false;\\n      if (index_of_input_dim0 == (${e[0].dims[0]} - 1)) {\\n        // It's the end in dimension 0\\n        x01 = x00;\\n        end_of_dim0 = true;\\n      } else {\\n        x01 = getInputFloat(input_index + input_pitches[0]);\\n      }\\n\\n      if (index_of_input_dim1 == (input_pitches[0] - 1)) {\\n        // It's the end in dimension 1\\n        x10 = x00;\\n        x11 = x01;\\n      }\\n      else {\\n        x10 = getInputFloat(input_index + 1);\\n        x11 = end_of_dim0 ? x10 : getInputFloat(input_index + input_pitches[0] + 1);\\n      }\\n\\n      float y0 = x00 + float(y_offset) * (x01 - x00) / float(scales[0]);\\n      float y1 = x10 + float(y_offset) * (x11 - x10) / float(scales[0]);\\n      return y0 + float(x_offset) * (y1 - y0) / float(scales[1]);\\n    }`;return Object.assign(Object.assign({},a),{output:{dims:c,type:e[0].type,textureType:o.TextureType.unpacked},shaderSource:m,variables:[{name:\"scales\",type:\"int\",arrayLength:n.scales.length,data:n.scales.map((t=>Math.ceil(t)))}]})};e.validateInputs=(t,e)=>{if(!t||e.opset<9&&1!==t.length||e.opset>=9&&e.opset<11&&2!==t.length||e.opset>=11&&t.length<2)throw new Error(\"invalid inputs.\");if(e.scales.length>0&&t[0].dims.length!==e.scales.length)throw new Error(\"Invalid input shape.\");if(\"string\"===t[0].type)throw new Error(\"Invalid input tensor types.\")},e.scalesValidation=(t,e,n)=>{if(n){for(const e of t)if(e<=0)throw new Error(\"Scale value should be greater than 0.\")}else for(const e of t)if(e<1)throw new Error(\"Scale value should be greater than or equal to 1.\");if(!(\"linear\"!==e&&\"cubic\"!==e||2===t.length||4===t.length&&1===t[0]&&1===t[1]))throw new Error(`'Linear' mode and 'Cubic' mode only support 2-D inputs ('Bilinear', 'Bicubic')         or 4-D inputs with the corresponding outermost 2 scale values being 1         in the ${n?\"Resize\":\"Upsample\"} opeartor.`)}},1958:(t,e,n)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.ProgramManager=void 0;const r=n(6207),i=n(3694),o=n(8879),a=n(5060);e.ProgramManager=class{constructor(t,e,n){this.profiler=t,this.glContext=e,this.textureLayoutStrategy=n,this.repo=new Map,this.attributesBound=!1}getArtifact(t){return this.repo.get(t)}setArtifact(t,e){this.repo.set(t,e)}run(t,e,n){var r;this.profiler.event(\"op\",`ProgramManager.run ${null!==(r=t.programInfo.name)&&void 0!==r?r:\"unknown kernel\"}`,(()=>{var r;const o=this.glContext.gl,a=t.program;o.useProgram(a);try{this.bindOutput(n),this.attributesBound||this.bindAttributes(t.attribLocations),this.bindUniforms(t.uniformLocations,null!==(r=t.programInfo.variables)&&void 0!==r?r:[],e)}catch(e){throw i.Logger.error(\"ProgramManager\",t.programInfo.shaderSource),e}this.profiler.event(\"backend\",\"GlContext.draw()\",(()=>{this.glContext.draw()}))}),this.glContext)}dispose(){this.vertexShader&&this.glContext.deleteShader(this.vertexShader),this.repo.forEach((t=>this.glContext.deleteProgram(t.program)))}build(t,e,n){return this.profiler.event(\"backend\",\"ProgramManager.build\",(()=>{const r=new o.GlslPreprocessor(this.glContext,t,e,n),i=r.preprocess(),a=this.compile(i);return{programInfo:t,program:a,uniformLocations:this.getUniformLocations(a,r.context.programInfo.inputNames,r.context.programInfo.variables),attribLocations:this.getAttribLocations(a)}}))}compile(t){if(!this.vertexShader){i.Logger.verbose(\"ProrgramManager\",\"Compiling and caching Vertex shader for the first time\");const t=(0,a.getVertexShaderSource)(this.glContext.version);this.vertexShader=this.glContext.compileShader(t,this.glContext.gl.VERTEX_SHADER)}r.env.debug&&i.Logger.verbose(\"ProrgramManager\",`FragShader:\\n${t}\\n`);const e=this.glContext.compileShader(t,this.glContext.gl.FRAGMENT_SHADER),n=this.glContext.createProgram(this.vertexShader,e);return this.glContext.deleteShader(e),n}bindOutput(t){const e=t.width,n=t.height;i.Logger.verbose(\"ProrgramManager\",`Binding output texture to Framebuffer: w/h=${e}/${n}, shape=${t.shape}, type=${t.tensor.type}`),this.glContext.attachFramebuffer(t.texture,e,n)}bindAttributes(t){const e=t.position,n=t.textureCoord;this.glContext.setVertexAttributes(e,n),this.attributesBound=!0}bindUniforms(t,e,n){var r;const i=this.glContext.gl;let o=0;for(const{name:a,type:s,location:u,arrayLength:c}of t){const t=null===(r=e.find((t=>t.name===a)))||void 0===r?void 0:r.data;if(\"sampler2D\"!==s&&!t)throw new Error(`variable '${a}' does not have data defined in program info`);switch(s){case\"sampler2D\":this.bindTexture(n[o],u,o),o++;break;case\"float\":c?i.uniform1fv(u,t):i.uniform1f(u,t);break;case\"int\":c?i.uniform1iv(u,t):i.uniform1i(u,t);break;default:throw new Error(`Uniform not implemented: ${s}`)}}}bindTexture(t,e,n){this.glContext.bindTextureToUniform(t.texture,n,e)}getAttribLocations(t){return{position:this.getAttribLocation(t,\"position\"),textureCoord:this.getAttribLocation(t,\"textureCoord\")}}getUniformLocations(t,e,n){const r=[];if(e)for(const n of e)r.push({name:n,type:\"sampler2D\",location:this.getUniformLocation(t,n)});if(n)for(const e of n)r.push(Object.assign(Object.assign({},e),{location:this.getUniformLocation(t,e.name)}));return r}getUniformLocation(t,e){const n=this.glContext.gl.getUniformLocation(t,e);if(null===n)throw new Error(`Uniform ${e} not found.`);return n}getAttribLocation(t,e){return this.glContext.gl.getAttribLocation(t,e)}}},6416:(t,e,n)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.WebGLSessionHandler=void 0;const r=n(3694),i=n(1047),o=n(8316),a=n(1640),s=n(1958),u=n(7859),c=n(5702);e.WebGLSessionHandler=class{constructor(t,e){this.backend=t,this.context=e,this.layoutStrategy=new u.PreferLogicalStrategy(t.glContext.maxTextureSize),this.programManager=new s.ProgramManager(this.context.profiler,t.glContext,this.layoutStrategy),this.textureManager=new c.TextureManager(t.glContext,this.layoutStrategy,this.context.profiler,{reuseTextures:\"full\"===t.textureCacheMode}),this.packedTextureDataCache=new Map,this.unpackedTextureDataCache=new Map,this.pack=t.pack,this.pack2unpackMap=new Map,this.unpack2packMap=new Map}createInferenceHandler(){return new o.WebGLInferenceHandler(this)}onGraphInitialized(t){const e=t.getValues().filter((t=>-1===t.from&&t.tensor)).map((t=>t.tensor.dataId));this.initializers=new Set(e)}isInitializer(t){return!!this.initializers&&this.initializers.has(t)}addInitializer(t){this.initializers.add(t)}getTextureData(t,e){return e?this.packedTextureDataCache.get(t):this.unpackedTextureDataCache.get(t)}setTextureData(t,e,n=!1){r.Logger.verbose(\"WebGLSessionHandler\",\"Storing Texture data in cache\"),n?this.packedTextureDataCache.set(t,e):this.unpackedTextureDataCache.set(t,e)}dispose(){this.programManager.dispose(),this.textureManager.clearActiveTextures(),this.packedTextureDataCache.forEach((t=>this.textureManager.releaseTexture(t,!0))),this.packedTextureDataCache=new Map,this.unpackedTextureDataCache.forEach((t=>this.textureManager.releaseTexture(t,!0))),this.unpackedTextureDataCache=new Map}resolve(t,e,n){const r=(0,i.resolveOperator)(t,e,a.WEBGL_OP_RESOLVE_RULES);return{impl:r.opImpl,context:r.opInit?r.opInit(t,n):t}}}},7769:(t,e,n)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.Uint8DataEncoder=e.RGBAFloatDataEncoder=e.RedFloat32DataEncoder=void 0;const r=n(3694);e.RedFloat32DataEncoder=class{constructor(t,e=1){if(1===e)this.internalFormat=t.R32F,this.format=t.RED,this.textureType=t.FLOAT,this.channelSize=e;else{if(4!==e)throw new Error(`Invalid number of channels: ${e}`);this.internalFormat=t.RGBA32F,this.format=t.RGBA,this.textureType=t.FLOAT,this.channelSize=e}}encode(t,e){let n,i;return t.constructor!==Float32Array&&(r.Logger.warning(\"Encoder\",\"data was not of type Float32; creating new Float32Array\"),i=new Float32Array(t)),e*this.channelSize>t.length?(r.Logger.warning(\"Encoder\",\"Source data too small. Allocating larger array\"),i=t,n=this.allocate(e*this.channelSize),i.forEach(((t,e)=>n[e]=t))):(i=t,n=i),n}allocate(t){return new Float32Array(4*t)}decode(t,e){return 1===this.channelSize?t.filter(((t,e)=>e%4==0)).subarray(0,e):t.subarray(0,e)}},e.RGBAFloatDataEncoder=class{constructor(t,e=1,n){if(1!==e&&4!==e)throw new Error(`Invalid number of channels: ${e}`);this.internalFormat=t.RGBA,this.format=t.RGBA,this.channelSize=e,this.textureType=n||t.FLOAT}encode(t,e){let n=t;return 1===this.channelSize&&(r.Logger.verbose(\"Encoder\",\"Exploding into a larger array\"),n=this.allocate(e),t.forEach(((t,e)=>n[4*e]=t))),n}allocate(t){return new Float32Array(4*t)}decode(t,e){return 1===this.channelSize?t.filter(((t,e)=>e%4==0)).subarray(0,e):t.subarray(0,e)}},e.Uint8DataEncoder=class{constructor(t,e=1){if(this.channelSize=4,1===e)this.internalFormat=t.ALPHA,this.format=t.ALPHA,this.textureType=t.UNSIGNED_BYTE,this.channelSize=e;else{if(4!==e)throw new Error(`Invalid number of channels: ${e}`);this.internalFormat=t.RGBA,this.format=t.RGBA,this.textureType=t.UNSIGNED_BYTE,this.channelSize=e}}encode(t,e){return new Uint8Array(t.buffer,t.byteOffset,t.byteLength)}allocate(t){return new Uint8Array(t*this.channelSize)}decode(t,e){if(t instanceof Uint8Array)return t.subarray(0,e);throw new Error(`Invalid array type: ${t.constructor}`)}}},7859:(t,e,n)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.getBatchDim=e.sizeToSquarishShape=e.getRowsCols=e.sizeFromShape=e.isInt=e.parseAxisParam=e.squeezeShape=e.PreferLogicalStrategy=e.AlwaysKeepOriginalSizeStrategy=void 0;const r=n(3694),i=n(2517);function o(t,e){const n=[],r=[],i=null!=e&&Array.isArray(e)&&0===e.length,o=null==e||i?null:a(e,t).sort();let s=0;for(let e=0;e<t.length;++e){if(null!=o){if(o[s]===e&&1!==t[e])throw new Error(`Can't squeeze axis ${e} since its dim '${t[e]}' is not 1`);(null==o[s]||o[s]>e)&&1===t[e]&&(n.push(t[e]),r.push(e)),o[s]<=e&&s++}1!==t[e]&&(n.push(t[e]),r.push(e))}return{newShape:n,keptDims:r}}function a(t,e){const n=e.length;return t=null==t?e.map(((t,e)=>e)):[].concat(t),(0,i.assert)(t.every((t=>t>=-n&&t<n)),(()=>`All values in axis param must be in range [-${n}, ${n}) but got axis ${t}`)),(0,i.assert)(t.every(s),(()=>`All values in axis param must be integers but got axis ${t}`)),t.map((t=>t<0?n+t:t))}function s(t){return t%1==0}function u(t){if(0===t.length)return 1;let e=t[0];for(let n=1;n<t.length;n++)e*=t[n];return e}function c(t){const e=Math.ceil(Math.sqrt(t));return[e,Math.ceil(t/e)]}e.AlwaysKeepOriginalSizeStrategy=class{constructor(t){this.maxTextureSize=t}computeTextureWH(t,e){if(0===t.length)return[1,1];const n=this.maxTextureSize;if(e&&void 0!==e.breakAxis){const i=e.breakAxis>=t.length?1:t.slice(e.breakAxis).reduce(((t,e)=>t*e)),o=e.breakAxis<=0?1:t.slice(0,e.breakAxis).reduce(((t,e)=>t*e));if(!(i>n||o>n))return[i,o];r.Logger.verbose(\"TextureLayout\",`Given width/height preferences were unattainable: shape:${t}, breakAxis:${e.breakAxis}`)}const i=t.reduce(((t,e)=>t*e));let o=Math.floor(Math.sqrt(i));for(;o<n&&o<i&&i%o!=0;o++);if(o>=n||i%o!=0)throw new Error(`The given dimensions are outside this GPU's boundaries: ${t}`);return[o,i/o]}},e.PreferLogicalStrategy=class{constructor(t){this.maxTextureSize=t}computeTextureWH(t,e){const n=this.computeTexture(t,e);return e&&e.isPacked&&(n[0]/=2,n[1]/=2),e&&e.reverseWH?[n[1],n[0]]:n}computeTexture(t,e){const n=e&&e.isPacked;if(0===t.length)return n?[2,2]:[1,1];let i=this.maxTextureSize;if(e&&void 0!==e.breakAxis){const n=e.breakAxis>=t.length?1:t.slice(e.breakAxis).reduce(((t,e)=>t*e)),o=e.breakAxis<=0?1:t.slice(0,e.breakAxis).reduce(((t,e)=>t*e));if(!(n>i||o>i))return[n,o];r.Logger.verbose(\"TextureLayout\",`Given width/height preferences were unattainable: shape:${t}, breakAxis:${e.breakAxis}`)}let a=t.slice(0);if(n&&(i*=2,a=a.map(((t,e)=>e>=a.length-2?a[e]%2==0?a[e]:a[e]+1:a[e])),1===a.length&&(a=[2,a[0]])),2!==a.length){const t=o(a);a=t.newShape}const s=u(a);return a.length<=1&&s<=i?[1,s]:2===a.length&&a[0]<=i&&a[1]<=i?a:3===a.length&&a[0]*a[1]<=i&&a[2]<=i?[a[0]*a[1],a[2]]:3===a.length&&a[0]<=i&&a[1]*a[2]<=i?[a[0],a[1]*a[2]]:4===a.length&&a[0]*a[1]*a[2]<=i&&a[3]<=i?[a[0]*a[1]*a[2],a[3]]:4===a.length&&a[0]<=i&&a[1]*a[2]*a[3]<=i?[a[0],a[1]*a[2]*a[3]]:n?c(s/4).map((t=>2*t)):c(s)}},e.squeezeShape=o,e.parseAxisParam=a,e.isInt=s,e.sizeFromShape=u,e.getRowsCols=function(t){if(0===t.length)throw Error(\"Cannot get rows and columns of an empty shape array.\");return[t.length>1?t[t.length-2]:1,t[t.length-1]]},e.sizeToSquarishShape=c,e.getBatchDim=function(t,e=2){return u(t.slice(0,t.length-e))}},4057:(t,e,n)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.createTextureLayoutFromShape=e.calculateTextureWidthAndHeight=e.createTextureLayoutFromTextureType=void 0;const r=n(2517),i=n(2039);e.createTextureLayoutFromTextureType=(t,n,r)=>{const o=r===i.TextureType.unpacked||r===i.TextureType.unpackedReversed?1:4,a=r===i.TextureType.packed,s=r===i.TextureType.unpackedReversed||r===i.TextureType.packed,u=r===i.TextureType.packedLastDimension?n.length-1:void 0,c=r===i.TextureType.packedLastDimension?n.map(((t,e)=>e===n.length-1?4*t:t)):void 0;return(0,e.createTextureLayoutFromShape)(t,n,o,c,{isPacked:a,reverseWH:s,breakAxis:u})},e.calculateTextureWidthAndHeight=(t,n,r)=>{const i=(0,e.createTextureLayoutFromTextureType)(t,n,r);return[i.width,i.height]},e.createTextureLayoutFromShape=(t,e,n=1,i,o)=>{const a=!(!o||!o.isPacked),[s,u]=t.computeTextureWH(a&&i||e,o),c=e.length;let l=e.slice(0);if(0===c&&(l=[1]),1===n)i=e;else if(a){if(4!==n)throw new Error(\"a packed texture must be 4-channel\");i=e,c>0&&(l[c-1]=Math.ceil(l[c-1]/2)),c>1&&(l[c-2]=Math.ceil(l[c-2]/2))}else if(!i)throw new Error(\"Unpacked shape is needed when using channels > 1\");return{width:s,height:u,channels:n,isPacked:a,shape:l,strides:r.ShapeUtil.computeStrides(l),unpackedShape:i,reversedWH:o&&o.reverseWH}}},5702:(t,e,n)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.TextureManager=void 0;const r=n(3694);e.TextureManager=class{constructor(t,e,n,r){this.glContext=t,this.layoutStrategy=e,this.profiler=n,this.config=r,this.pendingRead=new Map,r.reuseTextures&&(this.inUseTextures=new Map,this.idleTextures=new Map,this.textureLookup=new Map)}createTextureFromLayout(t,e,n,i){const o=this.toEncoderType(t),a=this.glContext.getEncoder(o,e.channels||1,i);if(e.isPacked&&1===i)throw new Error(\"not implemented\");const s=e.width,u=e.height;let c,l;if(this.config.reuseTextures){c=`${s}x${u}_${a.format}_${a.internalFormat}_${a.textureType}`,l=this.inUseTextures.get(c),l||(l=[],this.inUseTextures.set(c,l));const e=this.idleTextures.get(c);if(e&&e.length>0){const r=e.pop();return l.push(r),1===i&&this.glContext.updateTexture(r,s,u,a,this.toTextureData(t,n)),r}}r.Logger.verbose(\"TextureManager\",`Creating new texture of size ${e.width}x${e.height}`);const p=this.glContext.allocateTexture(s,u,a,this.toTextureData(t,n));return this.config.reuseTextures&&(l.push(p),this.textureLookup.set(p,c)),p}readTexture(t,e,n){return n||(n=1),this.profiler.event(\"backend\",\"TextureManager.readTexture\",(()=>{const r=t.shape.reduce(((t,e)=>t*e))*n,i=this.glContext.readTexture(t.texture,t.width,t.height,r,this.toEncoderType(e),n);return this.toTensorData(e,i)}))}async readTextureAsync(t,e,n){const r=t.tensor.dataId;if(n||(n=1),this.pendingRead.has(r)){const t=this.pendingRead.get(r);return new Promise((e=>null==t?void 0:t.push(e)))}return this.profiler.event(\"backend\",\"TextureManager.readTextureAsync\",(async()=>{this.pendingRead.set(r,[]);const i=t.shape.reduce(((t,e)=>t*e))*n;await this.glContext.createAndWaitForFence();const o=this.glContext.readTexture(t.texture,t.width,t.height,i,this.toEncoderType(e),n),a=this.toTensorData(e,o),s=this.pendingRead.get(r);return this.pendingRead.delete(r),null==s||s.forEach((t=>t(a))),a}))}readUint8TextureAsFloat(t){return this.profiler.event(\"backend\",\"TextureManager.readUint8TextureAsFloat\",(()=>{const e=t.shape.reduce(((t,e)=>t*e)),n=this.glContext.readTexture(t.texture,t.width,t.height,4*e,\"byte\",4);return new Float32Array(n.buffer,n.byteOffset,e)}))}releaseTexture(t,e){let n;if(this.config.reuseTextures&&(n=this.textureLookup.get(t.texture),n)){e&&this.textureLookup.delete(n);const r=this.inUseTextures.get(n);if(r){const e=r.indexOf(t.texture);if(-1!==e){r.splice(e,1);let i=this.idleTextures.get(n);i||(i=[],this.idleTextures.set(n,i)),i.push(t.texture)}}}n&&!e||(r.Logger.verbose(\"TextureManager\",`Deleting texture of size ${t.width}x${t.height}`),this.glContext.deleteTexture(t.texture))}toTensorData(t,e){switch(t){case\"int16\":return e instanceof Int16Array?e:Int16Array.from(e);case\"int32\":return e instanceof Int32Array?e:Int32Array.from(e);case\"int8\":return e instanceof Int8Array?e:Int8Array.from(e);case\"uint16\":return e instanceof Uint16Array?e:Uint16Array.from(e);case\"uint32\":return e instanceof Uint32Array?e:Uint32Array.from(e);case\"uint8\":case\"bool\":return e instanceof Uint8Array?e:Uint8Array.from(e);case\"float32\":return e instanceof Float32Array?e:Float32Array.from(e);case\"float64\":return e instanceof Float64Array?e:Float64Array.from(e);default:throw new Error(`TensorData type ${t} is not supported`)}}toTextureData(t,e){if(e)return e instanceof Float32Array?e:new Float32Array(e)}toEncoderType(t){return\"float\"}clearActiveTextures(){this.glContext.clearActiveTextures()}}},2039:(t,e)=>{\"use strict\";var n;Object.defineProperty(e,\"__esModule\",{value:!0}),e.TextureType=void 0,(n=e.TextureType||(e.TextureType={}))[n.unpacked=0]=\"unpacked\",n[n.unpackedReversed=1]=\"unpackedReversed\",n[n.packed=2]=\"packed\",n[n.downloadUint8AsFloat=3]=\"downloadUint8AsFloat\",n[n.packedLastDimension=4]=\"packedLastDimension\"},9390:(t,e,n)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.getGlChannels=e.getCoordsDataType=e.getSqueezedParams=e.squeezeInputShape=e.generateShaderFuncNameFromInputSamplerNameAtOutCoords=e.generateShaderFuncNameFromInputSamplerName=e.repeatedTry=e.getPackedShape=void 0;const r=n(2517);e.getPackedShape=function(t){const e=t.length;return t.slice(0,e-1).concat(t[e-1]/4)},e.repeatedTry=async function(t,e=(t=>0),n){return new Promise(((r,i)=>{let o=0;const a=()=>{if(t())return void r();o++;const s=e(o);null!=n&&o>=n?i():setTimeout(a,s)};a()}))},e.generateShaderFuncNameFromInputSamplerName=function(t){return(0,r.assert)(void 0!==t&&0!==t.length,(()=>\"empty string found for sampler name\")),\"get\"+t.charAt(0).toUpperCase()+t.slice(1)},e.generateShaderFuncNameFromInputSamplerNameAtOutCoords=function(t){return(0,r.assert)(void 0!==t&&0!==t.length,(()=>\"empty string found for sampler name\")),\"get\"+t.charAt(0).toUpperCase()+t.slice(1)+\"AtOutCoords\"},e.squeezeInputShape=function(t,e){let n=JSON.parse(JSON.stringify(t));return n=e,n},e.getSqueezedParams=function(t,e){return e.map((e=>t[e])).join(\", \")},e.getCoordsDataType=function(t){if(t<=1)return\"int\";if(2===t)return\"ivec2\";if(3===t)return\"ivec3\";if(4===t)return\"ivec4\";if(5===t)return\"ivec5\";if(6===t)return\"ivec6\";throw Error(`GPU for rank ${t} is not yet supported`)},e.getGlChannels=function(t=6){return[\"x\",\"y\",\"z\",\"w\",\"u\",\"v\"].slice(0,t)}},7305:(t,e,n)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.createNewWebGLContext=e.createWebGLContext=void 0;const r=n(3694),i=n(1713),o={};function a(t){const e=function(){if(\"undefined\"==typeof document){if(\"undefined\"==typeof OffscreenCanvas)throw new TypeError(\"failed to create canvas: OffscreenCanvas is not supported\");return new OffscreenCanvas(1,1)}const t=document.createElement(\"canvas\");return t.width=1,t.height=1,t}();let n;const o={alpha:!1,depth:!1,antialias:!1,stencil:!1,preserveDrawingBuffer:!1,premultipliedAlpha:!1,failIfMajorPerformanceCaveat:!1};if((!t||\"webgl2\"===t)&&(n=e.getContext(\"webgl2\",o),n))try{return new i.WebGLContext(n,2)}catch(t){r.Logger.warning(\"GlContextFactory\",`failed to create WebGLContext using contextId 'webgl2'. Error: ${t}`)}if((!t||\"webgl\"===t)&&(n=e.getContext(\"webgl\",o)||e.getContext(\"experimental-webgl\",o),n))try{return new i.WebGLContext(n,1)}catch(t){r.Logger.warning(\"GlContextFactory\",`failed to create WebGLContext using contextId 'webgl' or 'experimental-webgl'. Error: ${t}`)}throw new Error(\"WebGL is not supported\")}e.createWebGLContext=function t(e){let n;e&&\"webgl2\"!==e||!(\"webgl2\"in o)?e&&\"webgl\"!==e||!(\"webgl\"in o)||(n=o.webgl):n=o.webgl2,n=n||a(e),e=e||1===n.version?\"webgl\":\"webgl2\";const r=n.gl;return o[e]=n,r.isContextLost()?(delete o[e],t(e)):(r.disable(r.DEPTH_TEST),r.disable(r.STENCIL_TEST),r.disable(r.BLEND),r.disable(r.DITHER),r.disable(r.POLYGON_OFFSET_FILL),r.disable(r.SAMPLE_COVERAGE),r.enable(r.SCISSOR_TEST),r.enable(r.CULL_FACE),r.cullFace(r.BACK),n)},e.createNewWebGLContext=a},1713:function(t,e,n){\"use strict\";var r=this&&this.__createBinding||(Object.create?function(t,e,n,r){void 0===r&&(r=n);var i=Object.getOwnPropertyDescriptor(e,n);i&&!(\"get\"in i?!e.__esModule:i.writable||i.configurable)||(i={enumerable:!0,get:function(){return e[n]}}),Object.defineProperty(t,r,i)}:function(t,e,n,r){void 0===r&&(r=n),t[r]=e[n]}),i=this&&this.__setModuleDefault||(Object.create?function(t,e){Object.defineProperty(t,\"default\",{enumerable:!0,value:e})}:function(t,e){t.default=e}),o=this&&this.__importStar||function(t){if(t&&t.__esModule)return t;var e={};if(null!=t)for(var n in t)\"default\"!==n&&Object.prototype.hasOwnProperty.call(t,n)&&r(e,t,n);return i(e,t),e};Object.defineProperty(e,\"__esModule\",{value:!0}),e.WebGLContext=e.linearSearchLastTrue=void 0;const a=n(6207),s=o(n(7769)),u=n(9390);function c(t){let e=0;for(;e<t.length&&t[e]();++e);return e-1}e.linearSearchLastTrue=c,e.WebGLContext=class{constructor(t,e){this.frameBufferBound=!1,this.itemsToPoll=[],this.gl=t,this.version=e,this.getExtensions(),this.vertexbuffer=this.createVertexbuffer(),this.framebuffer=this.createFramebuffer(),this.queryVitalParameters()}allocateTexture(t,e,n,r){const i=this.gl,o=i.createTexture();i.bindTexture(i.TEXTURE_2D,o),i.texParameteri(i.TEXTURE_2D,i.TEXTURE_MIN_FILTER,i.NEAREST),i.texParameteri(i.TEXTURE_2D,i.TEXTURE_MAG_FILTER,i.NEAREST),i.texParameteri(i.TEXTURE_2D,i.TEXTURE_WRAP_S,i.CLAMP_TO_EDGE),i.texParameteri(i.TEXTURE_2D,i.TEXTURE_WRAP_T,i.CLAMP_TO_EDGE);const a=r?n.encode(r,t*e):null;return i.texImage2D(i.TEXTURE_2D,0,n.internalFormat,t,e,0,n.format,n.textureType,a),this.checkError(),o}updateTexture(t,e,n,r,i){const o=this.gl;o.bindTexture(o.TEXTURE_2D,t);const a=r.encode(i,e*n);o.texSubImage2D(o.TEXTURE_2D,0,0,0,e,n,r.format,r.textureType,a),this.checkError()}attachFramebuffer(t,e,n){const r=this.gl;r.bindTexture(r.TEXTURE_2D,t),r.bindFramebuffer(r.FRAMEBUFFER,this.framebuffer),r.framebufferTexture2D(r.FRAMEBUFFER,r.COLOR_ATTACHMENT0,r.TEXTURE_2D,t,0),this.checkError(),r.viewport(0,0,e,n),r.scissor(0,0,e,n)}readTexture(t,e,n,r,i,o){const a=this.gl;o||(o=1),this.frameBufferBound||this.attachFramebuffer(t,e,n);const s=this.getEncoder(i,o),u=s.allocate(e*n);return a.bindTexture(a.TEXTURE_2D,t),a.framebufferTexture2D(a.FRAMEBUFFER,a.COLOR_ATTACHMENT0,a.TEXTURE_2D,t,0),a.readPixels(0,0,e,n,a.RGBA,s.textureType,u),this.checkError(),s.decode(u,r)}isFramebufferReady(){return!0}getActiveTexture(){const t=this.gl;return\"TEXTURE\"+(t.getParameter(this.gl.ACTIVE_TEXTURE)-t.TEXTURE0)}getTextureBinding(){return this.gl.getParameter(this.gl.TEXTURE_BINDING_2D)}getFramebufferBinding(){return this.gl.getParameter(this.gl.FRAMEBUFFER_BINDING)}setVertexAttributes(t,e){const n=this.gl;n.vertexAttribPointer(t,3,n.FLOAT,!1,20,0),n.enableVertexAttribArray(t),-1!==e&&(n.vertexAttribPointer(e,2,n.FLOAT,!1,20,12),n.enableVertexAttribArray(e)),this.checkError()}createProgram(t,e){const n=this.gl,r=n.createProgram();return n.attachShader(r,t),n.attachShader(r,e),n.linkProgram(r),r}compileShader(t,e){const n=this.gl,r=n.createShader(e);if(!r)throw new Error(`createShader() returned null with type ${e}`);if(n.shaderSource(r,t),n.compileShader(r),!1===n.getShaderParameter(r,n.COMPILE_STATUS))throw new Error(`Failed to compile shader: ${n.getShaderInfoLog(r)}\\nShader source:\\n${t}`);return r}deleteShader(t){this.gl.deleteShader(t)}bindTextureToUniform(t,e,n){const r=this.gl;r.activeTexture(r.TEXTURE0+e),this.checkError(),r.bindTexture(r.TEXTURE_2D,t),this.checkError(),r.uniform1i(n,e),this.checkError()}draw(){this.gl.drawArrays(this.gl.TRIANGLE_STRIP,0,4),this.checkError()}checkError(){if(a.env.debug){const t=this.gl,e=t.getError();let n=\"\";switch(e){case t.NO_ERROR:return;case t.INVALID_ENUM:n=\"INVALID_ENUM\";break;case t.INVALID_VALUE:n=\"INVALID_VALUE\";break;case t.INVALID_OPERATION:n=\"INVALID_OPERATION\";break;case t.INVALID_FRAMEBUFFER_OPERATION:n=\"INVALID_FRAMEBUFFER_OPERATION\";break;case t.OUT_OF_MEMORY:n=\"OUT_OF_MEMORY\";break;case t.CONTEXT_LOST_WEBGL:n=\"CONTEXT_LOST_WEBGL\";break;default:n=`Unknown WebGL Error: ${e.toString(16)}`}throw new Error(n)}}deleteTexture(t){this.gl.deleteTexture(t)}deleteProgram(t){this.gl.deleteProgram(t)}getEncoder(t,e,n=0){if(2===this.version)return new s.RedFloat32DataEncoder(this.gl,e);switch(t){case\"float\":return 1===n||this.isRenderFloat32Supported?new s.RGBAFloatDataEncoder(this.gl,e):new s.RGBAFloatDataEncoder(this.gl,e,this.textureHalfFloatExtension.HALF_FLOAT_OES);case\"int\":throw new Error(\"not implemented\");case\"byte\":return new s.Uint8DataEncoder(this.gl,e);default:throw new Error(`Invalid dataType: ${t}`)}}clearActiveTextures(){const t=this.gl;for(let e=0;e<this.maxTextureImageUnits;++e)t.activeTexture(t.TEXTURE0+e),t.bindTexture(t.TEXTURE_2D,null)}dispose(){if(this.disposed)return;const t=this.gl;t.bindFramebuffer(t.FRAMEBUFFER,null),t.deleteFramebuffer(this.framebuffer),t.bindBuffer(t.ARRAY_BUFFER,null),t.deleteBuffer(this.vertexbuffer),t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,null),t.finish(),this.disposed=!0}createDefaultGeometry(){return new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0])}createVertexbuffer(){const t=this.gl,e=t.createBuffer();if(!e)throw new Error(\"createBuffer() returned null\");const n=this.createDefaultGeometry();return t.bindBuffer(t.ARRAY_BUFFER,e),t.bufferData(t.ARRAY_BUFFER,n,t.STATIC_DRAW),this.checkError(),e}createFramebuffer(){const t=this.gl.createFramebuffer();if(!t)throw new Error(\"createFramebuffer returned null\");return t}queryVitalParameters(){const t=this.gl;if(this.isFloatTextureAttachableToFrameBuffer=this.checkFloatTextureAttachableToFrameBuffer(),this.isRenderFloat32Supported=this.checkRenderFloat32(),this.isFloat32DownloadSupported=this.checkFloat32Download(),1===this.version&&!this.textureHalfFloatExtension&&!this.isRenderFloat32Supported)throw new Error(\"both float32 and float16 TextureType are not supported\");this.isBlendSupported=!this.isRenderFloat32Supported||this.checkFloat32Blend(),this.maxTextureSize=t.getParameter(t.MAX_TEXTURE_SIZE),this.maxTextureImageUnits=t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS),this.version}getExtensions(){2===this.version?(this.colorBufferFloatExtension=this.gl.getExtension(\"EXT_color_buffer_float\"),this.disjointTimerQueryWebgl2Extension=this.gl.getExtension(\"EXT_disjoint_timer_query_webgl2\")):(this.textureFloatExtension=this.gl.getExtension(\"OES_texture_float\"),this.textureHalfFloatExtension=this.gl.getExtension(\"OES_texture_half_float\"))}checkFloatTextureAttachableToFrameBuffer(){const t=this.gl,e=t.createTexture();t.bindTexture(t.TEXTURE_2D,e);const n=2===this.version?t.RGBA32F:t.RGBA;t.texImage2D(t.TEXTURE_2D,0,n,1,1,0,t.RGBA,t.FLOAT,null);const r=t.createFramebuffer();t.bindFramebuffer(t.FRAMEBUFFER,r),t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,e,0);const i=t.checkFramebufferStatus(t.FRAMEBUFFER)===t.FRAMEBUFFER_COMPLETE;return t.bindTexture(t.TEXTURE_2D,null),t.bindFramebuffer(t.FRAMEBUFFER,null),t.deleteTexture(e),t.deleteFramebuffer(r),i}checkRenderFloat32(){if(2===this.version){if(!this.colorBufferFloatExtension)return!1}else if(!this.textureFloatExtension)return!1;return this.isFloatTextureAttachableToFrameBuffer}checkFloat32Download(){if(2===this.version){if(!this.colorBufferFloatExtension)return!1}else{if(!this.textureFloatExtension)return!1;if(!this.gl.getExtension(\"WEBGL_color_buffer_float\"))return!1}return this.isFloatTextureAttachableToFrameBuffer}checkFloat32Blend(){const t=this.gl;let e,n,r,i,o;try{e=t.createTexture(),n=t.createFramebuffer(),t.bindTexture(t.TEXTURE_2D,e);const a=2===this.version?t.RGBA32F:t.RGBA;return t.texImage2D(t.TEXTURE_2D,0,a,1,1,0,t.RGBA,t.FLOAT,null),t.bindFramebuffer(t.FRAMEBUFFER,n),t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,e,0),t.enable(t.BLEND),r=t.createShader(t.VERTEX_SHADER),!!r&&(t.shaderSource(r,\"void main(){}\"),t.compileShader(r),i=t.createShader(t.FRAGMENT_SHADER),!!i&&(t.shaderSource(i,\"precision highp float;void main(){gl_FragColor=vec4(0.5);}\"),t.compileShader(i),o=t.createProgram(),!!o&&(t.attachShader(o,r),t.attachShader(o,i),t.linkProgram(o),t.useProgram(o),t.drawArrays(t.POINTS,0,1),t.getError()===t.NO_ERROR)))}finally{t.disable(t.BLEND),o&&t.deleteProgram(o),r&&t.deleteShader(r),i&&t.deleteShader(i),n&&(t.bindFramebuffer(t.FRAMEBUFFER,null),t.deleteFramebuffer(n)),e&&(t.bindTexture(t.TEXTURE_2D,null),t.deleteTexture(e))}}beginTimer(){if(2===this.version&&this.disjointTimerQueryWebgl2Extension){const t=this.gl,e=this.disjointTimerQueryWebgl2Extension,n=t.createQuery();return t.beginQuery(e.TIME_ELAPSED_EXT,n),n}throw new Error(\"WebGL1 profiling currently not supported.\")}endTimer(){if(2!==this.version||!this.disjointTimerQueryWebgl2Extension)throw new Error(\"WebGL1 profiling currently not supported\");{const t=this.gl,e=this.disjointTimerQueryWebgl2Extension;t.endQuery(e.TIME_ELAPSED_EXT)}}isTimerResultAvailable(t){let e=!1,n=!1;if(2!==this.version||!this.disjointTimerQueryWebgl2Extension)throw new Error(\"WebGL1 profiling currently not supported\");{const r=this.gl,i=this.disjointTimerQueryWebgl2Extension;e=r.getQueryParameter(t,r.QUERY_RESULT_AVAILABLE),n=r.getParameter(i.GPU_DISJOINT_EXT)}return e&&!n}getTimerResult(t){let e=0;if(2!==this.version)throw new Error(\"WebGL1 profiling currently not supported\");{const n=this.gl;e=n.getQueryParameter(t,n.QUERY_RESULT),n.deleteQuery(t)}return e/1e6}async waitForQueryAndGetTime(t){return await(0,u.repeatedTry)((()=>this.isTimerResultAvailable(t))),this.getTimerResult(t)}async createAndWaitForFence(){const t=this.createFence(this.gl);return this.pollFence(t)}createFence(t){let e;const n=t,r=n.fenceSync(n.SYNC_GPU_COMMANDS_COMPLETE,0);return t.flush(),e=null===r?()=>!0:()=>{const t=n.clientWaitSync(r,0,0);return t===n.ALREADY_SIGNALED||t===n.CONDITION_SATISFIED},{query:r,isFencePassed:e}}async pollFence(t){return new Promise((e=>{this.addItemToPoll((()=>t.isFencePassed()),(()=>e()))}))}pollItems(){const t=c(this.itemsToPoll.map((t=>t.isDoneFn)));for(let e=0;e<=t;++e){const{resolveFn:t}=this.itemsToPoll[e];t()}this.itemsToPoll=this.itemsToPoll.slice(t+1)}async addItemToPoll(t,e){this.itemsToPoll.push({isDoneFn:t,resolveFn:e}),this.itemsToPoll.length>1||await(0,u.repeatedTry)((()=>(this.pollItems(),0===this.itemsToPoll.length)))}}},1036:(t,e,n)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.ExecutionPlan=void 0;const r=n(3694);class i{constructor(t,e){this.op=t,this.node=e}}e.ExecutionPlan=class{constructor(t,e,n){this.graph=t,this.profiler=n,this.initialize(e)}initialize(t){this.profiler.event(\"session\",\"ExecutionPlan.initialize\",(()=>{const e=this.graph.getNodes();if(e.length!==t.length)throw new Error(\"The size of nodes and OPs do not match.\");this._ops=t.map(((t,n)=>new i(t,e[n]))),this.reset(),this._starter=[],this._ops.forEach(((t,e)=>{let n=!0;for(const e of t.node.inputs)if(!this._values[e]&&-1===this.graph.getInputIndices().indexOf(e)){n=!1;break}n&&this._starter.push(e)}))}))}reset(){this._values=this.graph.getValues().map((t=>t.tensor))}async execute(t,e){return this.profiler.event(\"session\",\"ExecutionPlan.execute\",(async()=>{this.reset();const n=t.createInferenceHandler(),i=this.graph.getInputIndices();if(e.length!==i.length)throw new Error(`number of input tensors don't match the number of inputs to the model: actual: ${e.length} expected: ${i.length}`);e.forEach(((t,e)=>{const n=i[e];this._values[n]=t}));const o=this._starter.slice(0),a=this.graph.getValues(),s=this.graph.getNodes();let u=0;for(;u<o.length;){const t=o[u++],e=this._ops[t],i=e.node.inputs.map((t=>this._values[t]));if(-1!==i.indexOf(void 0))throw new Error(`unresolved input detected: op: ${e.node}`);const c=i;r.Logger.verbose(\"ExecPlan\",`Runing op:${e.node.name} (${c.map(((t,n)=>`'${e.node.inputs[n]}': ${t.type}[${t.dims.join(\",\")}]`)).join(\", \")})`);const l=await this.profiler.event(\"node\",e.node.name,(async()=>e.op.impl(n,c,e.op.context)));if(l.length!==e.node.outputs.length)throw new Error(\"the size of output does not match model definition.\");l.forEach(((t,n)=>{const r=e.node.outputs[n];if(this._values[r])throw new Error(`output [${r}] already has value: op:${e.node.name}`);this._values[r]=t}));const p=new Set;l.forEach(((t,n)=>{const r=e.node.outputs[n];for(const t of a[r].to){const e=s[t];let n=!0;for(const t of e.inputs)if(!this._values[t]){n=!1;break}n&&p.add(t)}})),o.push(...p)}const c=[];for(let t=0;t<this.graph.getOutputIndices().length;t++){const e=this.graph.getOutputIndices()[t],n=this._values[e];if(void 0===n)throw new Error(`required output [${e}] does not have value`);0===e?await n.getData():n.data,c.push(n)}return r.Logger.verbose(\"ExecPlan\",\"disposing of inferenceHandler\"),n.dispose(),c}))}}},7070:(t,e,n)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.Graph=void 0;const r=n(1446),i=n(7778),o=n(9395),a=n(9162),s=n(2517);var u=o.onnxruntime.experimental.fbs;e.Graph={from:(t,e)=>new p(t,e)};class c{constructor(t){this._from=void 0,this._to=[],this.tensor=void 0,this.type=void 0,t&&(this.type=s.ProtoUtil.tensorValueTypeFromProto(t.type.tensorType))}get from(){return this._from}get to(){return this._to}}class l{constructor(t,e){t instanceof r.onnx.NodeProto?(this.name=t.name,this.opType=t.opType,this.attributes=new i.Attribute(t.attribute)):t instanceof u.Node&&(this.name=null!=e?e:t.name(),this.opType=t.opType(),this.attributes=new i.Attribute(s.ProtoUtil.tensorAttributesFromORTFormat(t))),this.inputs=[],this.outputs=[],this.executeNode=!0}}class p{constructor(t,e){if(!t)throw new TypeError(\"graph is empty\");this.buildGraph(t),this.transformGraph(e),this.checkIsAcyclic()}getInputIndices(){return this._allInputIndices}getInputNames(){return this._allInputNames}getOutputIndices(){return this._allOutputIndices}getOutputNames(){return this._allOutputNames}getValues(){return this._allData}getNodes(){return this._nodes}buildGraph(t){if(t instanceof r.onnx.GraphProto)this.buildGraphFromOnnxFormat(t);else{if(!(t instanceof u.Graph))throw new TypeError(\"Graph type is not supported.\");this.buildGraphFromOrtFormat(t)}}buildGraphFromOnnxFormat(t){const e=new Map;this._allData=[],this._allInputIndices=[],this._allInputNames=[],this._allOutputIndices=[],this._allOutputNames=[],this._nodes=[];const n=new Map;if(!t.input)throw new Error(\"missing information in graph: input\");const r=[];for(const n of t.input){if(e.has(n.name))throw new Error(`duplicated input name: ${n.name}`);const t=this._allData.push(new c(n))-1;e.set(n.name,t),r.push(n.name)}if(!t.initializer)throw new Error(\"missing information in graph: initializer\");for(const n of t.initializer){let t=e.get(n.name);if(void 0===t){const r=new c;r.type={shape:{dims:s.ProtoUtil.tensorDimsFromProto(n.dims)},tensorType:s.ProtoUtil.tensorDataTypeFromProto(n.dataType)},t=this._allData.push(r)-1,e.set(n.name,t)}this._allData[t]._from=-1,this._allData[t].tensor=a.Tensor.fromProto(n)}for(let t=0;t<this._allData.length;t++)this._allData[t].tensor||(this._allInputIndices.push(t),this._allInputNames.push(r[t]));if(!t.output)throw new Error(\"missing information in graph: output\");for(const n of t.output){if(e.has(n.name))throw new Error(`duplicated output name: ${n.name}`);const t=this._allData.push(new c(n))-1;e.set(n.name,t),this._allOutputIndices.push(t),this._allOutputNames.push(n.name)}if(!t.node)throw new Error(\"missing information in graph: node\");for(const e of t.node){if(!e.name)for(let t=0;;t++){const r=`unnamed_${e.opType}_${t}`;if(!n.has(r)){e.name=r;break}}if(n.has(e.name))throw new Error(`duplicated node name: ${e.name}`);const t=this._nodes.push(new l(e))-1;n.set(e.name,t)}for(let n=0;n<this._nodes.length;n++){const r=this._nodes[n],i=t.node[n];if(!i.output)throw new Error(`missing output for node: ${i.name}`);for(const t of i.output){let o=e.get(t);if(void 0===o&&(o=this._allData.push(new c)-1,e.set(t,o)),r.outputs.push(o),void 0!==this._allData[o]._from)throw new Error(`multiple nodes output to one data value: ${o}`);if(this._allData[o]._from=n,\"Constant\"===i.opType){if(!i.attribute||1!==i.attribute.length||!i.attribute[0].t)throw new Error(\"missing attributes or missing tensor value in attributes for this Constant operator\");if(!i.output||1!==i.output.length)throw new Error(\"missing output or incorrect number of outputs for this Constant operator\");r.outputs.pop(),r.executeNode=!1,this._allData[o]._from=-1,this._allData[o].tensor=a.Tensor.fromProto(i.attribute[0].t)}}}for(let n=0;n<this._nodes.length;n++){const r=this._nodes[n],i=t.node[n];if(!i.input)throw new Error(`missing input for node: ${i.name}`);for(const t of i.input){const o=e.get(t);if(void 0===o){if(\"\"===t&&3===i.input.length&&\"Resize\"===i.opType)continue;throw new Error(`unrecognized input '${t}' for node: ${i.name}`)}r.inputs.push(o),this._allData[o]._to.push(n)}}return!0}buildGraphFromOrtFormat(t){var e,n,r;const i=new Map;this._allData=[],this._allInputIndices=[],this._allInputNames=[],this._allOutputIndices=[],this._allOutputNames=[],this._nodes=[];const o=new Map,p=[];for(let o=0;o<t.inputsLength();o++){const a=t.inputs(o);if(i.has(a))throw new Error(`duplicated input name: ${a}`);for(let o=0;o<t.nodeArgsLength();o++)if((null===(e=t.nodeArgs(o))||void 0===e?void 0:e.name())===a){const e=new c;if((null===(r=null===(n=t.nodeArgs(o))||void 0===n?void 0:n.type())||void 0===r?void 0:r.valueType())!==u.TypeInfoValue.tensor_type)throw new Error(\"Unexpected value type for the nodeArg.\");const l=t.nodeArgs(o).type().value(new u.TensorTypeAndShape),f=s.ProtoUtil.tensorDataTypeFromProto(l.elemType()),d=l.shape(),h=[];for(let t=0;t<d.dimLength();t++)h.push(s.LongUtil.longToNumber(d.dim(t).value().dimValue()));e.type={shape:{dims:h},tensorType:f};const g=this._allData.push(e)-1;i.set(a,g),p.push(a)}}for(let e=0;e<t.initializersLength();e++){const n=t.initializers(e);let r=i.get(n.name());if(void 0===r){const t=new c,e=s.ProtoUtil.tensorDimsFromORTFormat(n),o=s.ProtoUtil.tensorDataTypeFromProto(n.dataType());t.type={shape:{dims:e},tensorType:o},r=this._allData.push(t)-1,i.set(n.name(),r)}this._allData[r]._from=-1,this._allData[r].tensor=a.Tensor.fromOrtTensor(n)}for(let t=0;t<this._allData.length;t++)this._allData[t].tensor||(this._allInputIndices.push(t),this._allInputNames.push(p[t]));for(let e=0;e<t.outputsLength();e++){const n=t.outputs(e);if(i.has(n))throw new Error(`duplicated output name: ${n}`);const r=this._allData.push(new c)-1;i.set(n,r),this._allOutputIndices.push(r),this._allOutputNames.push(n)}if(!t.nodes)throw new Error(\"missing information in graph: node\");for(let e=0;e<t.nodesLength();e++){const n=t.nodes(e);let r=n.name();if(!r)for(let t=0;r=`unnamed_${n.opType()}_${t}`,o.has(r);t++);if(o.has(r))throw new Error(`duplicated node name: ${r}`);const i=this._nodes.push(new l(n,r))-1;o.set(r,i)}for(let e=0;e<this._nodes.length;e++){const n=this._nodes[e],r=t.nodes(e);if(null==r)throw new Error(`No node exists at index ${e}`);if(0===(null==r?void 0:r.outputsLength()))throw new Error(`missing output for node: ${r.name}`);for(let t=0;t<(null==r?void 0:r.outputsLength());t++){const o=null==r?void 0:r.outputs(t);let s=i.get(o);if(void 0===s&&(s=this._allData.push(new c)-1,i.set(o,s)),n.outputs.push(s),void 0!==this._allData[s]._from)throw new Error(`multiple nodes output to one data value: ${s}`);if(this._allData[s]._from=e,\"Constant\"===r.opType()){if(1!==r.attributesLength()||!r.attributes(0).t())throw new Error(\"missing attributes or missing tensor value in attributes for this Constant operator\");if(1!==r.outputsLength())throw new Error(\"missing output or incorrect number of outputs for this Constant operator\");n.outputs.pop(),n.executeNode=!1,this._allData[s]._from=-1,this._allData[s].tensor=a.Tensor.fromOrtTensor(r.attributes(0).t())}}}for(let e=0;e<this._nodes.length;e++){const n=this._nodes[e],r=t.nodes(e);if(0===r.inputsLength())throw new Error(`missing input for node: ${r.name}`);for(let t=0;t<r.inputsLength();t++){const o=r.inputs(t),a=i.get(o);if(void 0===a)throw new Error(`unrecognized input '${o}' for node: ${r.name()}`);n.inputs.push(a),this._allData[a]._to.push(e)}}}checkIsAcyclic(){const t=new Set;this._allInputIndices.forEach((e=>{this._allData[e]._to.forEach((e=>{t.add(e)}))}));const e=Array.from(t),n=new Array(this._nodes.length).fill(\"white\");for(;e.length>0;){const t=e.pop();\"gray\"===n[t]?n[t]=\"black\":(e.push(t),n[t]=\"gray\",this._nodes[t].outputs.forEach((r=>{const i=this._allData[r];if(void 0!==i.tensor)throw new Error(\"node outputs should not be initialized\");if(i._from!==t)throw new Error(\"from property of the Value object doesn't match index of Node being processed\");i._to.forEach((t=>{if(\"gray\"===n[t])throw new Error(\"model graph is cyclic\");\"white\"===n[t]&&e.push(t)}))})))}}transformGraph(t){this.removeAllIdentityNodes(),this.removeAllDropoutNodes(),this.fuseConvActivationNodes(),t&&t.transformGraph(this),this.finalizeGraph()}finalizeGraph(){let t=0;for(let e=0;e<this._nodes.length;e++)this._nodes[e].executeNode?t>0&&(this._nodes[e].inputs.forEach((n=>{const r=this._allData[n]._to.indexOf(e+t);-1!==r&&(this._allData[n]._to[r]=e)})),this._nodes[e].outputs.forEach((n=>{this._allData[n]._from&&this._allData[n]._from===e+t&&(this._allData[n]._from=e)}))):(t++,this._nodes[e].outputs.forEach((t=>{this._allData[t]._from=-2})),this._nodes.splice(e,1),e--);t=0;for(let e=0;e<this._allData.length;e++)if(-2!==this._allData[e].from||-1!==this._allOutputIndices.indexOf(e+t)){if(t>0){let n=-1;void 0!==this._allData[e].from&&-1!==this._allData[e].from?(n=this._nodes[this._allData[e].from].outputs.indexOf(e+t),-1!==n&&(this._nodes[this._allData[e].from].outputs[n]=e)):(n=this._allInputIndices.indexOf(e+t),-1!==n&&(this._allInputIndices[n]=e)),this._allData[e].to.forEach((r=>{n=this._nodes[r].inputs.indexOf(e+t),-1!==n&&(this._nodes[r].inputs[n]=e)})),0===this._allData[e].to.length&&(n=this._allOutputIndices.indexOf(e+t),-1!==n&&(this._allOutputIndices[n]=e))}}else t++,this._allData.splice(e,1),e--}deleteNode(t){const e=this._nodes[t];if(e.outputs.length>1)for(let t=1;t<e.outputs.length;t++)if(this._allData[e.outputs[t]].to.length>0)throw new Error(\"Node deletion with more than one output connected to other nodes is not supported. \");e.executeNode=!1;const n=e.inputs[0],r=e.outputs[0],i=this._allData[r].to,o=this._allData[n].to.indexOf(t);if(-1===o)throw new Error(\"The Value object doesn't have the current Node in it's 'to' property \");this._allData[n].to.splice(o,1),this._allData[r]._to=[];const a=this._allOutputIndices.indexOf(r);if(-1!==a&&(this._allOutputIndices[a]=n),i&&i.length>0)for(const t of i){const e=this._nodes[t].inputs.indexOf(r);if(-1===e)throw new Error(\"The Node object doesn't have the output Value in it's 'inputs' property \");this._nodes[t].inputs[e]=n,this._allData[n].to.push(t)}}removeAllDropoutNodes(){let t=0;for(const e of this._nodes){if(\"Dropout\"===e.opType){if(1!==e.inputs.length)throw new Error(\"Dropout nodes should only contain one input. \");if(1!==e.outputs.length&&2!==e.outputs.length)throw new Error(\"Dropout nodes should contain either 1 or 2 output(s)\");if(2===e.outputs.length&&0!==this._allData[e.outputs[1]]._to.length)throw new Error(\"Dropout nodes's second output should not be referenced by other nodes\");this.deleteNode(t)}t++}}removeAllIdentityNodes(){let t=0;for(const e of this._nodes)\"Identity\"===e.opType&&this.deleteNode(t),t++}isActivation(t){switch(t.opType){case\"Relu\":case\"Sigmoid\":case\"Clip\":return!0;default:return!1}}fuseConvActivationNodes(){for(const t of this._nodes)if(\"Conv\"===t.opType){const e=this._allData[t.outputs[0]]._to;if(1===e.length&&this.isActivation(this._nodes[e[0]])){const n=this._nodes[e[0]];if(\"Clip\"===n.opType)if(1===n.inputs.length)try{t.attributes.set(\"activation_params\",\"floats\",[n.attributes.getFloat(\"min\"),n.attributes.getFloat(\"max\")])}catch(e){t.attributes.set(\"activation_params\",\"floats\",[s.MIN_CLIP,s.MAX_CLIP])}else{if(!(n.inputs.length>=3&&void 0!==this._allData[n.inputs[1]].tensor&&void 0!==this._allData[n.inputs[2]].tensor))continue;t.attributes.set(\"activation_params\",\"floats\",[this._allData[n.inputs[1]].tensor.floatData[0],this._allData[n.inputs[2]].tensor.floatData[0]])}t.attributes.set(\"activation\",\"string\",n.opType),this.deleteNode(e[0])}}}}},3694:(t,e)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.now=e.Profiler=e.Logger=void 0;const n={verbose:1e3,info:2e3,warning:4e3,error:5e3,fatal:6e3},r={none:new class{log(t,e,n){}},console:new class{log(t,e,n){console.log(`${this.color(t)} ${n?\"\u001b[35m\"+n+\"\u001b[0m \":\"\"}${e}`)}color(t){switch(t){case\"verbose\":return\"\u001b[34;40mv\u001b[0m\";case\"info\":return\"\u001b[32mi\u001b[0m\";case\"warning\":return\"\u001b[30;43mw\u001b[0m\";case\"error\":return\"\u001b[31;40me\u001b[0m\";case\"fatal\":return\"\u001b[101mf\u001b[0m\";default:throw new Error(`unsupported severity: ${t}`)}}}},i={provider:\"console\",minimalSeverity:\"warning\",logDateTime:!0,logSourceLocation:!1};let o={\"\":i};function a(t,e,n,r){if(void 0===e)return i=t,{verbose:a.verbose.bind(null,i),info:a.info.bind(null,i),warning:a.warning.bind(null,i),error:a.error.bind(null,i),fatal:a.fatal.bind(null,i)};if(void 0===n)s(t,e);else if(\"number\"==typeof n&&void 0===r)s(t,e);else if(\"string\"==typeof n&&void 0===r)s(t,n,0,e);else{if(\"string\"!=typeof n||\"number\"!=typeof r)throw new TypeError(\"input is valid\");s(t,n,0,e)}var i}function s(t,e,i,a){const s=o[a||\"\"]||o[\"\"];n[t]<n[s.minimalSeverity]||(s.logDateTime&&(e=`${(new Date).toISOString()}|${e}`),s.logSourceLocation,r[s.provider].log(t,e,a))}!function(t){function e(t){o={},n(\"\",t||{})}function n(t,n){if(\"*\"===t)e(n);else{const e=o[t]||i;o[t]={provider:n.provider||e.provider,minimalSeverity:n.minimalSeverity||e.minimalSeverity,logDateTime:void 0===n.logDateTime?e.logDateTime:n.logDateTime,logSourceLocation:void 0===n.logSourceLocation?e.logSourceLocation:n.logSourceLocation}}}t.verbose=function(e,n){t(\"verbose\",e,n)},t.info=function(e,n){t(\"info\",e,n)},t.warning=function(e,n){t(\"warning\",e,n)},t.error=function(e,n){t(\"error\",e,n)},t.fatal=function(e,n){t(\"fatal\",e,n)},t.reset=e,t.set=n,t.setWithEnv=function(t){const e={};t.logLevel&&(e.minimalSeverity=t.logLevel),n(\"\",e)}}(a||(a={})),e.Logger=a;class u{constructor(t,e,n,r,i,o){this.category=t,this.name=e,this.startTime=n,this.endCallback=r,this.timer=i,this.ctx=o}end(){return this.endCallback(this)}async checkTimer(){if(void 0===this.ctx||void 0===this.timer)throw new Error(\"No webgl timer found\");return this.ctx.endTimer(),this.ctx.waitForQueryAndGetTime(this.timer)}}class c{constructor(t,e,n,r){this.category=t,this.name=e,this.startTime=n,this.endTime=r}}e.Profiler=class{static create(t){return void 0===t?new this:new this(t.maxNumberEvents,t.flushBatchSize,t.flushIntervalInMilliseconds)}constructor(t,e,n){this._started=!1,this._flushPointer=0,this._started=!1,this._maxNumberEvents=void 0===t?1e4:t,this._flushBatchSize=void 0===e?10:e,this._flushIntervalInMilliseconds=void 0===n?5e3:n}start(){this._started=!0,this._timingEvents=[],this._flushTime=(0,e.now)(),this._flushPointer=0}stop(){for(this._started=!1;this._flushPointer<this._timingEvents.length;this._flushPointer++)this.logOneEvent(this._timingEvents[this._flushPointer])}event(t,e,n,r){const i=this._started?this.begin(t,e,r):void 0;let o=!1;const a=n();if(a&&\"function\"==typeof a.then)return o=!0,new Promise(((t,e)=>{a.then((async e=>{i&&await i.end(),t(e)}),(async t=>{i&&await i.end(),e(t)}))}));if(!o&&i){const t=i.end();if(t&&\"function\"==typeof t.then)return new Promise(((e,n)=>{t.then((()=>{e(a)}),(t=>{n(t)}))}))}return a}begin(t,n,r){if(!this._started)throw new Error(\"profiler is not started yet\");if(void 0===r){const r=(0,e.now)();return this.flush(r),new u(t,n,r,(t=>this.endSync(t)))}{const e=r.beginTimer();return new u(t,n,0,(async t=>this.end(t)),e,r)}}async end(t){const e=await t.checkTimer();this._timingEvents.length<this._maxNumberEvents&&(this._timingEvents.push(new c(t.category,t.name,t.startTime,e)),this.flush(e))}endSync(t){const n=(0,e.now)();this._timingEvents.length<this._maxNumberEvents&&(this._timingEvents.push(new c(t.category,t.name,t.startTime,n)),this.flush(n))}logOneEvent(t){e.Logger.verbose(`Profiler.${t.category}`,`${(t.endTime-t.startTime).toFixed(2)}ms on event '${t.name}' at ${t.endTime.toFixed(2)}`)}flush(t){if(this._timingEvents.length-this._flushPointer>=this._flushBatchSize||t-this._flushTime>=this._flushIntervalInMilliseconds){for(const t=this._flushPointer;this._flushPointer<t+this._flushBatchSize&&this._flushPointer<this._timingEvents.length;this._flushPointer++)this.logOneEvent(this._timingEvents[this._flushPointer]);this._flushTime=(0,e.now)()}}get started(){return this._started}},e.now=\"undefined\"!=typeof performance&&performance.now?()=>performance.now():Date.now},2644:(t,e,n)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.Model=void 0;const r=n(5686),i=n(1446),o=n(7070),a=n(9395),s=n(2517);var u=a.onnxruntime.experimental.fbs;e.Model=class{constructor(){}load(t,e,n){if(!n)try{return void this.loadFromOnnxFormat(t,e)}catch(t){if(void 0!==n)throw t}this.loadFromOrtFormat(t,e)}loadFromOnnxFormat(t,e){const n=i.onnx.ModelProto.decode(t);if(s.LongUtil.longToNumber(n.irVersion)<3)throw new Error(\"only support ONNX model with IR_VERSION>=3\");this._opsets=n.opsetImport.map((t=>({domain:t.domain,version:s.LongUtil.longToNumber(t.version)}))),this._graph=o.Graph.from(n.graph,e)}loadFromOrtFormat(t,e){const n=new r.flatbuffers.ByteBuffer(t),i=u.InferenceSession.getRootAsInferenceSession(n).model();if(s.LongUtil.longToNumber(i.irVersion())<3)throw new Error(\"only support ONNX model with IR_VERSION>=3\");this._opsets=[];for(let t=0;t<i.opsetImportLength();t++){const e=i.opsetImport(t);this._opsets.push({domain:null==e?void 0:e.domain(),version:s.LongUtil.longToNumber(e.version())})}this._graph=o.Graph.from(i.graph(),e)}get graph(){return this._graph}get opsets(){return this._opsets}}},782:(t,e)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.FLOAT_TYPES=e.INT_TYPES=e.NUMBER_TYPES=void 0,e.NUMBER_TYPES=[\"float32\",\"float64\",\"int32\",\"int16\",\"int8\",\"uint16\",\"uint32\",\"uint8\"],e.INT_TYPES=[\"int32\",\"int16\",\"int8\",\"uint16\",\"uint32\",\"uint8\"],e.FLOAT_TYPES=[\"float32\",\"float64\"]},1047:(t,e)=>{\"use strict\";function n(t,e){if(e.endsWith(\"+\")){const n=Number.parseInt(e.substring(0,e.length-1),10);return!isNaN(n)&&n<=t}if(2===e.split(\"-\").length){const n=e.split(\"-\"),r=Number.parseInt(n[0],10),i=Number.parseInt(n[1],10);return!isNaN(r)&&!isNaN(i)&&r<=t&&t<=i}return Number.parseInt(e,10)===t}Object.defineProperty(e,\"__esModule\",{value:!0}),e.resolveOperator=void 0,e.resolveOperator=function(t,e,r){for(const i of r){const r=i[0],o=i[1],a=i[2],s=i[3],u=i[4];if(t.opType===r)for(const t of e)if((t.domain===o||\"ai.onnx\"===t.domain&&\"\"===o)&&n(t.version,a))return{opImpl:s,opInit:u}}throw new TypeError(`cannot resolve operator '${t.opType}' with opsets: ${e.map((t=>`${t.domain||\"ai.onnx\"} v${t.version}`)).join(\", \")}`)}},9395:(t,e,n)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.onnxruntime=void 0;const r=n(5686);var i,o;i=e.onnxruntime||(e.onnxruntime={}),function(t){let e;!function(t){t[t.UNDEFINED=0]=\"UNDEFINED\",t[t.FLOAT=1]=\"FLOAT\",t[t.INT=2]=\"INT\",t[t.STRING=3]=\"STRING\",t[t.TENSOR=4]=\"TENSOR\",t[t.GRAPH=5]=\"GRAPH\",t[t.FLOATS=6]=\"FLOATS\",t[t.INTS=7]=\"INTS\",t[t.STRINGS=8]=\"STRINGS\",t[t.TENSORS=9]=\"TENSORS\",t[t.GRAPHS=10]=\"GRAPHS\",t[t.SPARSE_TENSOR=11]=\"SPARSE_TENSOR\",t[t.SPARSE_TENSORS=12]=\"SPARSE_TENSORS\"}(e=t.AttributeType||(t.AttributeType={}))}((o=i.experimental||(i.experimental={})).fbs||(o.fbs={})),function(t){!function(t){!function(t){let e;!function(t){t[t.UNKNOWN=0]=\"UNKNOWN\",t[t.VALUE=1]=\"VALUE\",t[t.PARAM=2]=\"PARAM\"}(e=t.DimensionValueType||(t.DimensionValueType={}))}(t.fbs||(t.fbs={}))}(t.experimental||(t.experimental={}))}(e.onnxruntime||(e.onnxruntime={})),function(t){!function(t){!function(t){let e;!function(t){t[t.UNDEFINED=0]=\"UNDEFINED\",t[t.FLOAT=1]=\"FLOAT\",t[t.UINT8=2]=\"UINT8\",t[t.INT8=3]=\"INT8\",t[t.UINT16=4]=\"UINT16\",t[t.INT16=5]=\"INT16\",t[t.INT32=6]=\"INT32\",t[t.INT64=7]=\"INT64\",t[t.STRING=8]=\"STRING\",t[t.BOOL=9]=\"BOOL\",t[t.FLOAT16=10]=\"FLOAT16\",t[t.DOUBLE=11]=\"DOUBLE\",t[t.UINT32=12]=\"UINT32\",t[t.UINT64=13]=\"UINT64\",t[t.COMPLEX64=14]=\"COMPLEX64\",t[t.COMPLEX128=15]=\"COMPLEX128\",t[t.BFLOAT16=16]=\"BFLOAT16\"}(e=t.TensorDataType||(t.TensorDataType={}))}(t.fbs||(t.fbs={}))}(t.experimental||(t.experimental={}))}(e.onnxruntime||(e.onnxruntime={})),function(t){!function(t){!function(t){let e;!function(t){t[t.Primitive=0]=\"Primitive\",t[t.Fused=1]=\"Fused\"}(e=t.NodeType||(t.NodeType={}))}(t.fbs||(t.fbs={}))}(t.experimental||(t.experimental={}))}(e.onnxruntime||(e.onnxruntime={})),function(t){!function(t){!function(t){let e;!function(t){t[t.NONE=0]=\"NONE\",t[t.tensor_type=1]=\"tensor_type\",t[t.sequence_type=2]=\"sequence_type\",t[t.map_type=3]=\"map_type\"}(e=t.TypeInfoValue||(t.TypeInfoValue={}))}(t.fbs||(t.fbs={}))}(t.experimental||(t.experimental={}))}(e.onnxruntime||(e.onnxruntime={})),function(t){!function(e){!function(e){class n{constructor(){this.bb=null,this.bb_pos=0}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsShape(t,e){return(e||new n).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsShape(t,e){return t.setPosition(t.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(e||new n).__init(t.readInt32(t.position())+t.position(),t)}dim(e,n){let r=this.bb.__offset(this.bb_pos,4);return r?(n||new t.experimental.fbs.Dimension).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+r)+4*e),this.bb):null}dimLength(){let t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__vector_len(this.bb_pos+t):0}static startShape(t){t.startObject(1)}static addDim(t,e){t.addFieldOffset(0,e,0)}static createDimVector(t,e){t.startVector(4,e.length,4);for(let n=e.length-1;n>=0;n--)t.addOffset(e[n]);return t.endVector()}static startDimVector(t,e){t.startVector(4,e,4)}static endShape(t){return t.endObject()}static createShape(t,e){return n.startShape(t),n.addDim(t,e),n.endShape(t)}}e.Shape=n}(e.fbs||(e.fbs={}))}(t.experimental||(t.experimental={}))}(e.onnxruntime||(e.onnxruntime={})),function(t){!function(e){!function(e){class n{constructor(){this.bb=null,this.bb_pos=0}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsDimension(t,e){return(e||new n).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsDimension(t,e){return t.setPosition(t.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(e||new n).__init(t.readInt32(t.position())+t.position(),t)}value(e){let n=this.bb.__offset(this.bb_pos,4);return n?(e||new t.experimental.fbs.DimensionValue).__init(this.bb.__indirect(this.bb_pos+n),this.bb):null}denotation(t){let e=this.bb.__offset(this.bb_pos,6);return e?this.bb.__string(this.bb_pos+e,t):null}static startDimension(t){t.startObject(2)}static addValue(t,e){t.addFieldOffset(0,e,0)}static addDenotation(t,e){t.addFieldOffset(1,e,0)}static endDimension(t){return t.endObject()}static createDimension(t,e,r){return n.startDimension(t),n.addValue(t,e),n.addDenotation(t,r),n.endDimension(t)}}e.Dimension=n}(e.fbs||(e.fbs={}))}(t.experimental||(t.experimental={}))}(e.onnxruntime||(e.onnxruntime={})),function(t){!function(e){!function(e){class n{constructor(){this.bb=null,this.bb_pos=0}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsDimensionValue(t,e){return(e||new n).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsDimensionValue(t,e){return t.setPosition(t.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(e||new n).__init(t.readInt32(t.position())+t.position(),t)}dimType(){let e=this.bb.__offset(this.bb_pos,4);return e?this.bb.readInt8(this.bb_pos+e):t.experimental.fbs.DimensionValueType.UNKNOWN}dimValue(){let t=this.bb.__offset(this.bb_pos,6);return t?this.bb.readInt64(this.bb_pos+t):this.bb.createLong(0,0)}dimParam(t){let e=this.bb.__offset(this.bb_pos,8);return e?this.bb.__string(this.bb_pos+e,t):null}static startDimensionValue(t){t.startObject(3)}static addDimType(e,n){e.addFieldInt8(0,n,t.experimental.fbs.DimensionValueType.UNKNOWN)}static addDimValue(t,e){t.addFieldInt64(1,e,t.createLong(0,0))}static addDimParam(t,e){t.addFieldOffset(2,e,0)}static endDimensionValue(t){return t.endObject()}static createDimensionValue(t,e,r,i){return n.startDimensionValue(t),n.addDimType(t,e),n.addDimValue(t,r),n.addDimParam(t,i),n.endDimensionValue(t)}}e.DimensionValue=n}(e.fbs||(e.fbs={}))}(t.experimental||(t.experimental={}))}(e.onnxruntime||(e.onnxruntime={})),function(t){!function(e){!function(e){class n{constructor(){this.bb=null,this.bb_pos=0}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsTensorTypeAndShape(t,e){return(e||new n).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsTensorTypeAndShape(t,e){return t.setPosition(t.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(e||new n).__init(t.readInt32(t.position())+t.position(),t)}elemType(){let e=this.bb.__offset(this.bb_pos,4);return e?this.bb.readInt32(this.bb_pos+e):t.experimental.fbs.TensorDataType.UNDEFINED}shape(e){let n=this.bb.__offset(this.bb_pos,6);return n?(e||new t.experimental.fbs.Shape).__init(this.bb.__indirect(this.bb_pos+n),this.bb):null}static startTensorTypeAndShape(t){t.startObject(2)}static addElemType(e,n){e.addFieldInt32(0,n,t.experimental.fbs.TensorDataType.UNDEFINED)}static addShape(t,e){t.addFieldOffset(1,e,0)}static endTensorTypeAndShape(t){return t.endObject()}static createTensorTypeAndShape(t,e,r){return n.startTensorTypeAndShape(t),n.addElemType(t,e),n.addShape(t,r),n.endTensorTypeAndShape(t)}}e.TensorTypeAndShape=n}(e.fbs||(e.fbs={}))}(t.experimental||(t.experimental={}))}(e.onnxruntime||(e.onnxruntime={})),function(t){!function(e){!function(e){class n{constructor(){this.bb=null,this.bb_pos=0}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsMapType(t,e){return(e||new n).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsMapType(t,e){return t.setPosition(t.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(e||new n).__init(t.readInt32(t.position())+t.position(),t)}keyType(){let e=this.bb.__offset(this.bb_pos,4);return e?this.bb.readInt32(this.bb_pos+e):t.experimental.fbs.TensorDataType.UNDEFINED}valueType(e){let n=this.bb.__offset(this.bb_pos,6);return n?(e||new t.experimental.fbs.TypeInfo).__init(this.bb.__indirect(this.bb_pos+n),this.bb):null}static startMapType(t){t.startObject(2)}static addKeyType(e,n){e.addFieldInt32(0,n,t.experimental.fbs.TensorDataType.UNDEFINED)}static addValueType(t,e){t.addFieldOffset(1,e,0)}static endMapType(t){return t.endObject()}static createMapType(t,e,r){return n.startMapType(t),n.addKeyType(t,e),n.addValueType(t,r),n.endMapType(t)}}e.MapType=n}(e.fbs||(e.fbs={}))}(t.experimental||(t.experimental={}))}(e.onnxruntime||(e.onnxruntime={})),function(t){!function(e){!function(e){class n{constructor(){this.bb=null,this.bb_pos=0}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsSequenceType(t,e){return(e||new n).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsSequenceType(t,e){return t.setPosition(t.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(e||new n).__init(t.readInt32(t.position())+t.position(),t)}elemType(e){let n=this.bb.__offset(this.bb_pos,4);return n?(e||new t.experimental.fbs.TypeInfo).__init(this.bb.__indirect(this.bb_pos+n),this.bb):null}static startSequenceType(t){t.startObject(1)}static addElemType(t,e){t.addFieldOffset(0,e,0)}static endSequenceType(t){return t.endObject()}static createSequenceType(t,e){return n.startSequenceType(t),n.addElemType(t,e),n.endSequenceType(t)}}e.SequenceType=n}(e.fbs||(e.fbs={}))}(t.experimental||(t.experimental={}))}(e.onnxruntime||(e.onnxruntime={})),function(t){!function(t){(t.fbs||(t.fbs={})).EdgeEnd=class{constructor(){this.bb=null,this.bb_pos=0}__init(t,e){return this.bb_pos=t,this.bb=e,this}nodeIndex(){return this.bb.readUint32(this.bb_pos)}srcArgIndex(){return this.bb.readInt32(this.bb_pos+4)}dstArgIndex(){return this.bb.readInt32(this.bb_pos+8)}static createEdgeEnd(t,e,n,r){return t.prep(4,12),t.writeInt32(r),t.writeInt32(n),t.writeInt32(e),t.offset()}}}(t.experimental||(t.experimental={}))}(e.onnxruntime||(e.onnxruntime={})),function(t){!function(e){!function(e){class n{constructor(){this.bb=null,this.bb_pos=0}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsNodeEdge(t,e){return(e||new n).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsNodeEdge(t,e){return t.setPosition(t.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(e||new n).__init(t.readInt32(t.position())+t.position(),t)}nodeIndex(){let t=this.bb.__offset(this.bb_pos,4);return t?this.bb.readUint32(this.bb_pos+t):0}inputEdges(e,n){let r=this.bb.__offset(this.bb_pos,6);return r?(n||new t.experimental.fbs.EdgeEnd).__init(this.bb.__vector(this.bb_pos+r)+12*e,this.bb):null}inputEdgesLength(){let t=this.bb.__offset(this.bb_pos,6);return t?this.bb.__vector_len(this.bb_pos+t):0}outputEdges(e,n){let r=this.bb.__offset(this.bb_pos,8);return r?(n||new t.experimental.fbs.EdgeEnd).__init(this.bb.__vector(this.bb_pos+r)+12*e,this.bb):null}outputEdgesLength(){let t=this.bb.__offset(this.bb_pos,8);return t?this.bb.__vector_len(this.bb_pos+t):0}static startNodeEdge(t){t.startObject(3)}static addNodeIndex(t,e){t.addFieldInt32(0,e,0)}static addInputEdges(t,e){t.addFieldOffset(1,e,0)}static startInputEdgesVector(t,e){t.startVector(12,e,4)}static addOutputEdges(t,e){t.addFieldOffset(2,e,0)}static startOutputEdgesVector(t,e){t.startVector(12,e,4)}static endNodeEdge(t){return t.endObject()}static createNodeEdge(t,e,r,i){return n.startNodeEdge(t),n.addNodeIndex(t,e),n.addInputEdges(t,r),n.addOutputEdges(t,i),n.endNodeEdge(t)}}e.NodeEdge=n}(e.fbs||(e.fbs={}))}(t.experimental||(t.experimental={}))}(e.onnxruntime||(e.onnxruntime={})),function(t){!function(e){!function(e){class n{constructor(){this.bb=null,this.bb_pos=0}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsNode(t,e){return(e||new n).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsNode(t,e){return t.setPosition(t.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(e||new n).__init(t.readInt32(t.position())+t.position(),t)}name(t){let e=this.bb.__offset(this.bb_pos,4);return e?this.bb.__string(this.bb_pos+e,t):null}docString(t){let e=this.bb.__offset(this.bb_pos,6);return e?this.bb.__string(this.bb_pos+e,t):null}domain(t){let e=this.bb.__offset(this.bb_pos,8);return e?this.bb.__string(this.bb_pos+e,t):null}sinceVersion(){let t=this.bb.__offset(this.bb_pos,10);return t?this.bb.readInt32(this.bb_pos+t):0}index(){let t=this.bb.__offset(this.bb_pos,12);return t?this.bb.readUint32(this.bb_pos+t):0}opType(t){let e=this.bb.__offset(this.bb_pos,14);return e?this.bb.__string(this.bb_pos+e,t):null}type(){let e=this.bb.__offset(this.bb_pos,16);return e?this.bb.readInt32(this.bb_pos+e):t.experimental.fbs.NodeType.Primitive}executionProviderType(t){let e=this.bb.__offset(this.bb_pos,18);return e?this.bb.__string(this.bb_pos+e,t):null}inputs(t,e){let n=this.bb.__offset(this.bb_pos,20);return n?this.bb.__string(this.bb.__vector(this.bb_pos+n)+4*t,e):null}inputsLength(){let t=this.bb.__offset(this.bb_pos,20);return t?this.bb.__vector_len(this.bb_pos+t):0}outputs(t,e){let n=this.bb.__offset(this.bb_pos,22);return n?this.bb.__string(this.bb.__vector(this.bb_pos+n)+4*t,e):null}outputsLength(){let t=this.bb.__offset(this.bb_pos,22);return t?this.bb.__vector_len(this.bb_pos+t):0}attributes(e,n){let r=this.bb.__offset(this.bb_pos,24);return r?(n||new t.experimental.fbs.Attribute).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+r)+4*e),this.bb):null}attributesLength(){let t=this.bb.__offset(this.bb_pos,24);return t?this.bb.__vector_len(this.bb_pos+t):0}inputArgCounts(t){let e=this.bb.__offset(this.bb_pos,26);return e?this.bb.readInt32(this.bb.__vector(this.bb_pos+e)+4*t):0}inputArgCountsLength(){let t=this.bb.__offset(this.bb_pos,26);return t?this.bb.__vector_len(this.bb_pos+t):0}inputArgCountsArray(){let t=this.bb.__offset(this.bb_pos,26);return t?new Int32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}implicitInputs(t,e){let n=this.bb.__offset(this.bb_pos,28);return n?this.bb.__string(this.bb.__vector(this.bb_pos+n)+4*t,e):null}implicitInputsLength(){let t=this.bb.__offset(this.bb_pos,28);return t?this.bb.__vector_len(this.bb_pos+t):0}static startNode(t){t.startObject(13)}static addName(t,e){t.addFieldOffset(0,e,0)}static addDocString(t,e){t.addFieldOffset(1,e,0)}static addDomain(t,e){t.addFieldOffset(2,e,0)}static addSinceVersion(t,e){t.addFieldInt32(3,e,0)}static addIndex(t,e){t.addFieldInt32(4,e,0)}static addOpType(t,e){t.addFieldOffset(5,e,0)}static addType(e,n){e.addFieldInt32(6,n,t.experimental.fbs.NodeType.Primitive)}static addExecutionProviderType(t,e){t.addFieldOffset(7,e,0)}static addInputs(t,e){t.addFieldOffset(8,e,0)}static createInputsVector(t,e){t.startVector(4,e.length,4);for(let n=e.length-1;n>=0;n--)t.addOffset(e[n]);return t.endVector()}static startInputsVector(t,e){t.startVector(4,e,4)}static addOutputs(t,e){t.addFieldOffset(9,e,0)}static createOutputsVector(t,e){t.startVector(4,e.length,4);for(let n=e.length-1;n>=0;n--)t.addOffset(e[n]);return t.endVector()}static startOutputsVector(t,e){t.startVector(4,e,4)}static addAttributes(t,e){t.addFieldOffset(10,e,0)}static createAttributesVector(t,e){t.startVector(4,e.length,4);for(let n=e.length-1;n>=0;n--)t.addOffset(e[n]);return t.endVector()}static startAttributesVector(t,e){t.startVector(4,e,4)}static addInputArgCounts(t,e){t.addFieldOffset(11,e,0)}static createInputArgCountsVector(t,e){t.startVector(4,e.length,4);for(let n=e.length-1;n>=0;n--)t.addInt32(e[n]);return t.endVector()}static startInputArgCountsVector(t,e){t.startVector(4,e,4)}static addImplicitInputs(t,e){t.addFieldOffset(12,e,0)}static createImplicitInputsVector(t,e){t.startVector(4,e.length,4);for(let n=e.length-1;n>=0;n--)t.addOffset(e[n]);return t.endVector()}static startImplicitInputsVector(t,e){t.startVector(4,e,4)}static endNode(t){return t.endObject()}static createNode(t,e,r,i,o,a,s,u,c,l,p,f,d,h){return n.startNode(t),n.addName(t,e),n.addDocString(t,r),n.addDomain(t,i),n.addSinceVersion(t,o),n.addIndex(t,a),n.addOpType(t,s),n.addType(t,u),n.addExecutionProviderType(t,c),n.addInputs(t,l),n.addOutputs(t,p),n.addAttributes(t,f),n.addInputArgCounts(t,d),n.addImplicitInputs(t,h),n.endNode(t)}}e.Node=n}(e.fbs||(e.fbs={}))}(t.experimental||(t.experimental={}))}(e.onnxruntime||(e.onnxruntime={})),function(t){!function(e){!function(e){class n{constructor(){this.bb=null,this.bb_pos=0}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsValueInfo(t,e){return(e||new n).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsValueInfo(t,e){return t.setPosition(t.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(e||new n).__init(t.readInt32(t.position())+t.position(),t)}name(t){let e=this.bb.__offset(this.bb_pos,4);return e?this.bb.__string(this.bb_pos+e,t):null}docString(t){let e=this.bb.__offset(this.bb_pos,6);return e?this.bb.__string(this.bb_pos+e,t):null}type(e){let n=this.bb.__offset(this.bb_pos,8);return n?(e||new t.experimental.fbs.TypeInfo).__init(this.bb.__indirect(this.bb_pos+n),this.bb):null}static startValueInfo(t){t.startObject(3)}static addName(t,e){t.addFieldOffset(0,e,0)}static addDocString(t,e){t.addFieldOffset(1,e,0)}static addType(t,e){t.addFieldOffset(2,e,0)}static endValueInfo(t){return t.endObject()}static createValueInfo(t,e,r,i){return n.startValueInfo(t),n.addName(t,e),n.addDocString(t,r),n.addType(t,i),n.endValueInfo(t)}}e.ValueInfo=n}(e.fbs||(e.fbs={}))}(t.experimental||(t.experimental={}))}(e.onnxruntime||(e.onnxruntime={})),function(t){!function(e){!function(e){class n{constructor(){this.bb=null,this.bb_pos=0}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsTypeInfo(t,e){return(e||new n).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsTypeInfo(t,e){return t.setPosition(t.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(e||new n).__init(t.readInt32(t.position())+t.position(),t)}denotation(t){let e=this.bb.__offset(this.bb_pos,4);return e?this.bb.__string(this.bb_pos+e,t):null}valueType(){let e=this.bb.__offset(this.bb_pos,6);return e?this.bb.readUint8(this.bb_pos+e):t.experimental.fbs.TypeInfoValue.NONE}value(t){let e=this.bb.__offset(this.bb_pos,8);return e?this.bb.__union(t,this.bb_pos+e):null}static startTypeInfo(t){t.startObject(3)}static addDenotation(t,e){t.addFieldOffset(0,e,0)}static addValueType(e,n){e.addFieldInt8(1,n,t.experimental.fbs.TypeInfoValue.NONE)}static addValue(t,e){t.addFieldOffset(2,e,0)}static endTypeInfo(t){return t.endObject()}static createTypeInfo(t,e,r,i){return n.startTypeInfo(t),n.addDenotation(t,e),n.addValueType(t,r),n.addValue(t,i),n.endTypeInfo(t)}}e.TypeInfo=n}(e.fbs||(e.fbs={}))}(t.experimental||(t.experimental={}))}(e.onnxruntime||(e.onnxruntime={})),function(t){!function(t){!function(t){class e{constructor(){this.bb=null,this.bb_pos=0}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsOperatorSetId(t,n){return(n||new e).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsOperatorSetId(t,n){return t.setPosition(t.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(n||new e).__init(t.readInt32(t.position())+t.position(),t)}domain(t){let e=this.bb.__offset(this.bb_pos,4);return e?this.bb.__string(this.bb_pos+e,t):null}version(){let t=this.bb.__offset(this.bb_pos,6);return t?this.bb.readInt64(this.bb_pos+t):this.bb.createLong(0,0)}static startOperatorSetId(t){t.startObject(2)}static addDomain(t,e){t.addFieldOffset(0,e,0)}static addVersion(t,e){t.addFieldInt64(1,e,t.createLong(0,0))}static endOperatorSetId(t){return t.endObject()}static createOperatorSetId(t,n,r){return e.startOperatorSetId(t),e.addDomain(t,n),e.addVersion(t,r),e.endOperatorSetId(t)}}t.OperatorSetId=e}(t.fbs||(t.fbs={}))}(t.experimental||(t.experimental={}))}(e.onnxruntime||(e.onnxruntime={})),function(t){!function(e){!function(e){class n{constructor(){this.bb=null,this.bb_pos=0}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsTensor(t,e){return(e||new n).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsTensor(t,e){return t.setPosition(t.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(e||new n).__init(t.readInt32(t.position())+t.position(),t)}name(t){let e=this.bb.__offset(this.bb_pos,4);return e?this.bb.__string(this.bb_pos+e,t):null}docString(t){let e=this.bb.__offset(this.bb_pos,6);return e?this.bb.__string(this.bb_pos+e,t):null}dims(t){let e=this.bb.__offset(this.bb_pos,8);return e?this.bb.readInt64(this.bb.__vector(this.bb_pos+e)+8*t):this.bb.createLong(0,0)}dimsLength(){let t=this.bb.__offset(this.bb_pos,8);return t?this.bb.__vector_len(this.bb_pos+t):0}dataType(){let e=this.bb.__offset(this.bb_pos,10);return e?this.bb.readInt32(this.bb_pos+e):t.experimental.fbs.TensorDataType.UNDEFINED}rawData(t){let e=this.bb.__offset(this.bb_pos,12);return e?this.bb.readUint8(this.bb.__vector(this.bb_pos+e)+t):0}rawDataLength(){let t=this.bb.__offset(this.bb_pos,12);return t?this.bb.__vector_len(this.bb_pos+t):0}rawDataArray(){let t=this.bb.__offset(this.bb_pos,12);return t?new Uint8Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}stringData(t,e){let n=this.bb.__offset(this.bb_pos,14);return n?this.bb.__string(this.bb.__vector(this.bb_pos+n)+4*t,e):null}stringDataLength(){let t=this.bb.__offset(this.bb_pos,14);return t?this.bb.__vector_len(this.bb_pos+t):0}static startTensor(t){t.startObject(6)}static addName(t,e){t.addFieldOffset(0,e,0)}static addDocString(t,e){t.addFieldOffset(1,e,0)}static addDims(t,e){t.addFieldOffset(2,e,0)}static createDimsVector(t,e){t.startVector(8,e.length,8);for(let n=e.length-1;n>=0;n--)t.addInt64(e[n]);return t.endVector()}static startDimsVector(t,e){t.startVector(8,e,8)}static addDataType(e,n){e.addFieldInt32(3,n,t.experimental.fbs.TensorDataType.UNDEFINED)}static addRawData(t,e){t.addFieldOffset(4,e,0)}static createRawDataVector(t,e){t.startVector(1,e.length,1);for(let n=e.length-1;n>=0;n--)t.addInt8(e[n]);return t.endVector()}static startRawDataVector(t,e){t.startVector(1,e,1)}static addStringData(t,e){t.addFieldOffset(5,e,0)}static createStringDataVector(t,e){t.startVector(4,e.length,4);for(let n=e.length-1;n>=0;n--)t.addOffset(e[n]);return t.endVector()}static startStringDataVector(t,e){t.startVector(4,e,4)}static endTensor(t){return t.endObject()}static createTensor(t,e,r,i,o,a,s){return n.startTensor(t),n.addName(t,e),n.addDocString(t,r),n.addDims(t,i),n.addDataType(t,o),n.addRawData(t,a),n.addStringData(t,s),n.endTensor(t)}}e.Tensor=n}(e.fbs||(e.fbs={}))}(t.experimental||(t.experimental={}))}(e.onnxruntime||(e.onnxruntime={})),function(t){!function(e){!function(e){class n{constructor(){this.bb=null,this.bb_pos=0}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsSparseTensor(t,e){return(e||new n).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsSparseTensor(t,e){return t.setPosition(t.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(e||new n).__init(t.readInt32(t.position())+t.position(),t)}values(e){let n=this.bb.__offset(this.bb_pos,4);return n?(e||new t.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb_pos+n),this.bb):null}indices(e){let n=this.bb.__offset(this.bb_pos,6);return n?(e||new t.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb_pos+n),this.bb):null}dims(t){let e=this.bb.__offset(this.bb_pos,8);return e?this.bb.readInt64(this.bb.__vector(this.bb_pos+e)+8*t):this.bb.createLong(0,0)}dimsLength(){let t=this.bb.__offset(this.bb_pos,8);return t?this.bb.__vector_len(this.bb_pos+t):0}static startSparseTensor(t){t.startObject(3)}static addValues(t,e){t.addFieldOffset(0,e,0)}static addIndices(t,e){t.addFieldOffset(1,e,0)}static addDims(t,e){t.addFieldOffset(2,e,0)}static createDimsVector(t,e){t.startVector(8,e.length,8);for(let n=e.length-1;n>=0;n--)t.addInt64(e[n]);return t.endVector()}static startDimsVector(t,e){t.startVector(8,e,8)}static endSparseTensor(t){return t.endObject()}static createSparseTensor(t,e,r,i){return n.startSparseTensor(t),n.addValues(t,e),n.addIndices(t,r),n.addDims(t,i),n.endSparseTensor(t)}}e.SparseTensor=n}(e.fbs||(e.fbs={}))}(t.experimental||(t.experimental={}))}(e.onnxruntime||(e.onnxruntime={})),function(t){!function(e){!function(e){class n{constructor(){this.bb=null,this.bb_pos=0}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsAttribute(t,e){return(e||new n).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsAttribute(t,e){return t.setPosition(t.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(e||new n).__init(t.readInt32(t.position())+t.position(),t)}name(t){let e=this.bb.__offset(this.bb_pos,4);return e?this.bb.__string(this.bb_pos+e,t):null}docString(t){let e=this.bb.__offset(this.bb_pos,6);return e?this.bb.__string(this.bb_pos+e,t):null}type(){let e=this.bb.__offset(this.bb_pos,8);return e?this.bb.readInt32(this.bb_pos+e):t.experimental.fbs.AttributeType.UNDEFINED}f(){let t=this.bb.__offset(this.bb_pos,10);return t?this.bb.readFloat32(this.bb_pos+t):0}i(){let t=this.bb.__offset(this.bb_pos,12);return t?this.bb.readInt64(this.bb_pos+t):this.bb.createLong(0,0)}s(t){let e=this.bb.__offset(this.bb_pos,14);return e?this.bb.__string(this.bb_pos+e,t):null}t(e){let n=this.bb.__offset(this.bb_pos,16);return n?(e||new t.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb_pos+n),this.bb):null}g(e){let n=this.bb.__offset(this.bb_pos,18);return n?(e||new t.experimental.fbs.Graph).__init(this.bb.__indirect(this.bb_pos+n),this.bb):null}floats(t){let e=this.bb.__offset(this.bb_pos,20);return e?this.bb.readFloat32(this.bb.__vector(this.bb_pos+e)+4*t):0}floatsLength(){let t=this.bb.__offset(this.bb_pos,20);return t?this.bb.__vector_len(this.bb_pos+t):0}floatsArray(){let t=this.bb.__offset(this.bb_pos,20);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}ints(t){let e=this.bb.__offset(this.bb_pos,22);return e?this.bb.readInt64(this.bb.__vector(this.bb_pos+e)+8*t):this.bb.createLong(0,0)}intsLength(){let t=this.bb.__offset(this.bb_pos,22);return t?this.bb.__vector_len(this.bb_pos+t):0}strings(t,e){let n=this.bb.__offset(this.bb_pos,24);return n?this.bb.__string(this.bb.__vector(this.bb_pos+n)+4*t,e):null}stringsLength(){let t=this.bb.__offset(this.bb_pos,24);return t?this.bb.__vector_len(this.bb_pos+t):0}tensors(e,n){let r=this.bb.__offset(this.bb_pos,26);return r?(n||new t.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+r)+4*e),this.bb):null}tensorsLength(){let t=this.bb.__offset(this.bb_pos,26);return t?this.bb.__vector_len(this.bb_pos+t):0}graphs(e,n){let r=this.bb.__offset(this.bb_pos,28);return r?(n||new t.experimental.fbs.Graph).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+r)+4*e),this.bb):null}graphsLength(){let t=this.bb.__offset(this.bb_pos,28);return t?this.bb.__vector_len(this.bb_pos+t):0}static startAttribute(t){t.startObject(13)}static addName(t,e){t.addFieldOffset(0,e,0)}static addDocString(t,e){t.addFieldOffset(1,e,0)}static addType(e,n){e.addFieldInt32(2,n,t.experimental.fbs.AttributeType.UNDEFINED)}static addF(t,e){t.addFieldFloat32(3,e,0)}static addI(t,e){t.addFieldInt64(4,e,t.createLong(0,0))}static addS(t,e){t.addFieldOffset(5,e,0)}static addT(t,e){t.addFieldOffset(6,e,0)}static addG(t,e){t.addFieldOffset(7,e,0)}static addFloats(t,e){t.addFieldOffset(8,e,0)}static createFloatsVector(t,e){t.startVector(4,e.length,4);for(let n=e.length-1;n>=0;n--)t.addFloat32(e[n]);return t.endVector()}static startFloatsVector(t,e){t.startVector(4,e,4)}static addInts(t,e){t.addFieldOffset(9,e,0)}static createIntsVector(t,e){t.startVector(8,e.length,8);for(let n=e.length-1;n>=0;n--)t.addInt64(e[n]);return t.endVector()}static startIntsVector(t,e){t.startVector(8,e,8)}static addStrings(t,e){t.addFieldOffset(10,e,0)}static createStringsVector(t,e){t.startVector(4,e.length,4);for(let n=e.length-1;n>=0;n--)t.addOffset(e[n]);return t.endVector()}static startStringsVector(t,e){t.startVector(4,e,4)}static addTensors(t,e){t.addFieldOffset(11,e,0)}static createTensorsVector(t,e){t.startVector(4,e.length,4);for(let n=e.length-1;n>=0;n--)t.addOffset(e[n]);return t.endVector()}static startTensorsVector(t,e){t.startVector(4,e,4)}static addGraphs(t,e){t.addFieldOffset(12,e,0)}static createGraphsVector(t,e){t.startVector(4,e.length,4);for(let n=e.length-1;n>=0;n--)t.addOffset(e[n]);return t.endVector()}static startGraphsVector(t,e){t.startVector(4,e,4)}static endAttribute(t){return t.endObject()}static createAttribute(t,e,r,i,o,a,s,u,c,l,p,f,d,h){return n.startAttribute(t),n.addName(t,e),n.addDocString(t,r),n.addType(t,i),n.addF(t,o),n.addI(t,a),n.addS(t,s),n.addT(t,u),n.addG(t,c),n.addFloats(t,l),n.addInts(t,p),n.addStrings(t,f),n.addTensors(t,d),n.addGraphs(t,h),n.endAttribute(t)}}e.Attribute=n}(e.fbs||(e.fbs={}))}(t.experimental||(t.experimental={}))}(e.onnxruntime||(e.onnxruntime={})),function(t){!function(e){!function(e){class n{constructor(){this.bb=null,this.bb_pos=0}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsGraph(t,e){return(e||new n).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsGraph(t,e){return t.setPosition(t.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(e||new n).__init(t.readInt32(t.position())+t.position(),t)}initializers(e,n){let r=this.bb.__offset(this.bb_pos,4);return r?(n||new t.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+r)+4*e),this.bb):null}initializersLength(){let t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__vector_len(this.bb_pos+t):0}nodeArgs(e,n){let r=this.bb.__offset(this.bb_pos,6);return r?(n||new t.experimental.fbs.ValueInfo).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+r)+4*e),this.bb):null}nodeArgsLength(){let t=this.bb.__offset(this.bb_pos,6);return t?this.bb.__vector_len(this.bb_pos+t):0}nodes(e,n){let r=this.bb.__offset(this.bb_pos,8);return r?(n||new t.experimental.fbs.Node).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+r)+4*e),this.bb):null}nodesLength(){let t=this.bb.__offset(this.bb_pos,8);return t?this.bb.__vector_len(this.bb_pos+t):0}maxNodeIndex(){let t=this.bb.__offset(this.bb_pos,10);return t?this.bb.readUint32(this.bb_pos+t):0}nodeEdges(e,n){let r=this.bb.__offset(this.bb_pos,12);return r?(n||new t.experimental.fbs.NodeEdge).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+r)+4*e),this.bb):null}nodeEdgesLength(){let t=this.bb.__offset(this.bb_pos,12);return t?this.bb.__vector_len(this.bb_pos+t):0}inputs(t,e){let n=this.bb.__offset(this.bb_pos,14);return n?this.bb.__string(this.bb.__vector(this.bb_pos+n)+4*t,e):null}inputsLength(){let t=this.bb.__offset(this.bb_pos,14);return t?this.bb.__vector_len(this.bb_pos+t):0}outputs(t,e){let n=this.bb.__offset(this.bb_pos,16);return n?this.bb.__string(this.bb.__vector(this.bb_pos+n)+4*t,e):null}outputsLength(){let t=this.bb.__offset(this.bb_pos,16);return t?this.bb.__vector_len(this.bb_pos+t):0}sparseInitializers(e,n){let r=this.bb.__offset(this.bb_pos,18);return r?(n||new t.experimental.fbs.SparseTensor).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+r)+4*e),this.bb):null}sparseInitializersLength(){let t=this.bb.__offset(this.bb_pos,18);return t?this.bb.__vector_len(this.bb_pos+t):0}static startGraph(t){t.startObject(8)}static addInitializers(t,e){t.addFieldOffset(0,e,0)}static createInitializersVector(t,e){t.startVector(4,e.length,4);for(let n=e.length-1;n>=0;n--)t.addOffset(e[n]);return t.endVector()}static startInitializersVector(t,e){t.startVector(4,e,4)}static addNodeArgs(t,e){t.addFieldOffset(1,e,0)}static createNodeArgsVector(t,e){t.startVector(4,e.length,4);for(let n=e.length-1;n>=0;n--)t.addOffset(e[n]);return t.endVector()}static startNodeArgsVector(t,e){t.startVector(4,e,4)}static addNodes(t,e){t.addFieldOffset(2,e,0)}static createNodesVector(t,e){t.startVector(4,e.length,4);for(let n=e.length-1;n>=0;n--)t.addOffset(e[n]);return t.endVector()}static startNodesVector(t,e){t.startVector(4,e,4)}static addMaxNodeIndex(t,e){t.addFieldInt32(3,e,0)}static addNodeEdges(t,e){t.addFieldOffset(4,e,0)}static createNodeEdgesVector(t,e){t.startVector(4,e.length,4);for(let n=e.length-1;n>=0;n--)t.addOffset(e[n]);return t.endVector()}static startNodeEdgesVector(t,e){t.startVector(4,e,4)}static addInputs(t,e){t.addFieldOffset(5,e,0)}static createInputsVector(t,e){t.startVector(4,e.length,4);for(let n=e.length-1;n>=0;n--)t.addOffset(e[n]);return t.endVector()}static startInputsVector(t,e){t.startVector(4,e,4)}static addOutputs(t,e){t.addFieldOffset(6,e,0)}static createOutputsVector(t,e){t.startVector(4,e.length,4);for(let n=e.length-1;n>=0;n--)t.addOffset(e[n]);return t.endVector()}static startOutputsVector(t,e){t.startVector(4,e,4)}static addSparseInitializers(t,e){t.addFieldOffset(7,e,0)}static createSparseInitializersVector(t,e){t.startVector(4,e.length,4);for(let n=e.length-1;n>=0;n--)t.addOffset(e[n]);return t.endVector()}static startSparseInitializersVector(t,e){t.startVector(4,e,4)}static endGraph(t){return t.endObject()}static createGraph(t,e,r,i,o,a,s,u,c){return n.startGraph(t),n.addInitializers(t,e),n.addNodeArgs(t,r),n.addNodes(t,i),n.addMaxNodeIndex(t,o),n.addNodeEdges(t,a),n.addInputs(t,s),n.addOutputs(t,u),n.addSparseInitializers(t,c),n.endGraph(t)}}e.Graph=n}(e.fbs||(e.fbs={}))}(t.experimental||(t.experimental={}))}(e.onnxruntime||(e.onnxruntime={})),function(t){!function(e){!function(e){class n{constructor(){this.bb=null,this.bb_pos=0}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsModel(t,e){return(e||new n).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsModel(t,e){return t.setPosition(t.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(e||new n).__init(t.readInt32(t.position())+t.position(),t)}irVersion(){let t=this.bb.__offset(this.bb_pos,4);return t?this.bb.readInt64(this.bb_pos+t):this.bb.createLong(0,0)}opsetImport(e,n){let r=this.bb.__offset(this.bb_pos,6);return r?(n||new t.experimental.fbs.OperatorSetId).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+r)+4*e),this.bb):null}opsetImportLength(){let t=this.bb.__offset(this.bb_pos,6);return t?this.bb.__vector_len(this.bb_pos+t):0}producerName(t){let e=this.bb.__offset(this.bb_pos,8);return e?this.bb.__string(this.bb_pos+e,t):null}producerVersion(t){let e=this.bb.__offset(this.bb_pos,10);return e?this.bb.__string(this.bb_pos+e,t):null}domain(t){let e=this.bb.__offset(this.bb_pos,12);return e?this.bb.__string(this.bb_pos+e,t):null}modelVersion(){let t=this.bb.__offset(this.bb_pos,14);return t?this.bb.readInt64(this.bb_pos+t):this.bb.createLong(0,0)}docString(t){let e=this.bb.__offset(this.bb_pos,16);return e?this.bb.__string(this.bb_pos+e,t):null}graph(e){let n=this.bb.__offset(this.bb_pos,18);return n?(e||new t.experimental.fbs.Graph).__init(this.bb.__indirect(this.bb_pos+n),this.bb):null}graphDocString(t){let e=this.bb.__offset(this.bb_pos,20);return e?this.bb.__string(this.bb_pos+e,t):null}static startModel(t){t.startObject(9)}static addIrVersion(t,e){t.addFieldInt64(0,e,t.createLong(0,0))}static addOpsetImport(t,e){t.addFieldOffset(1,e,0)}static createOpsetImportVector(t,e){t.startVector(4,e.length,4);for(let n=e.length-1;n>=0;n--)t.addOffset(e[n]);return t.endVector()}static startOpsetImportVector(t,e){t.startVector(4,e,4)}static addProducerName(t,e){t.addFieldOffset(2,e,0)}static addProducerVersion(t,e){t.addFieldOffset(3,e,0)}static addDomain(t,e){t.addFieldOffset(4,e,0)}static addModelVersion(t,e){t.addFieldInt64(5,e,t.createLong(0,0))}static addDocString(t,e){t.addFieldOffset(6,e,0)}static addGraph(t,e){t.addFieldOffset(7,e,0)}static addGraphDocString(t,e){t.addFieldOffset(8,e,0)}static endModel(t){return t.endObject()}static createModel(t,e,r,i,o,a,s,u,c,l){return n.startModel(t),n.addIrVersion(t,e),n.addOpsetImport(t,r),n.addProducerName(t,i),n.addProducerVersion(t,o),n.addDomain(t,a),n.addModelVersion(t,s),n.addDocString(t,u),n.addGraph(t,c),n.addGraphDocString(t,l),n.endModel(t)}}e.Model=n}(e.fbs||(e.fbs={}))}(t.experimental||(t.experimental={}))}(e.onnxruntime||(e.onnxruntime={})),function(t){!function(t){!function(t){class e{constructor(){this.bb=null,this.bb_pos=0}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsKernelCreateInfos(t,n){return(n||new e).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsKernelCreateInfos(t,n){return t.setPosition(t.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(n||new e).__init(t.readInt32(t.position())+t.position(),t)}nodeIndices(t){let e=this.bb.__offset(this.bb_pos,4);return e?this.bb.readUint32(this.bb.__vector(this.bb_pos+e)+4*t):0}nodeIndicesLength(){let t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__vector_len(this.bb_pos+t):0}nodeIndicesArray(){let t=this.bb.__offset(this.bb_pos,4);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}kernelDefHashes(t){let e=this.bb.__offset(this.bb_pos,6);return e?this.bb.readUint64(this.bb.__vector(this.bb_pos+e)+8*t):this.bb.createLong(0,0)}kernelDefHashesLength(){let t=this.bb.__offset(this.bb_pos,6);return t?this.bb.__vector_len(this.bb_pos+t):0}static startKernelCreateInfos(t){t.startObject(2)}static addNodeIndices(t,e){t.addFieldOffset(0,e,0)}static createNodeIndicesVector(t,e){t.startVector(4,e.length,4);for(let n=e.length-1;n>=0;n--)t.addInt32(e[n]);return t.endVector()}static startNodeIndicesVector(t,e){t.startVector(4,e,4)}static addKernelDefHashes(t,e){t.addFieldOffset(1,e,0)}static createKernelDefHashesVector(t,e){t.startVector(8,e.length,8);for(let n=e.length-1;n>=0;n--)t.addInt64(e[n]);return t.endVector()}static startKernelDefHashesVector(t,e){t.startVector(8,e,8)}static endKernelCreateInfos(t){return t.endObject()}static createKernelCreateInfos(t,n,r){return e.startKernelCreateInfos(t),e.addNodeIndices(t,n),e.addKernelDefHashes(t,r),e.endKernelCreateInfos(t)}}t.KernelCreateInfos=e}(t.fbs||(t.fbs={}))}(t.experimental||(t.experimental={}))}(e.onnxruntime||(e.onnxruntime={})),function(t){!function(e){!function(e){class n{constructor(){this.bb=null,this.bb_pos=0}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsSubGraphSessionState(t,e){return(e||new n).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsSubGraphSessionState(t,e){return t.setPosition(t.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(e||new n).__init(t.readInt32(t.position())+t.position(),t)}graphId(t){let e=this.bb.__offset(this.bb_pos,4);return e?this.bb.__string(this.bb_pos+e,t):null}sessionState(e){let n=this.bb.__offset(this.bb_pos,6);return n?(e||new t.experimental.fbs.SessionState).__init(this.bb.__indirect(this.bb_pos+n),this.bb):null}static startSubGraphSessionState(t){t.startObject(2)}static addGraphId(t,e){t.addFieldOffset(0,e,0)}static addSessionState(t,e){t.addFieldOffset(1,e,0)}static endSubGraphSessionState(t){let e=t.endObject();return t.requiredField(e,4),e}static createSubGraphSessionState(t,e,r){return n.startSubGraphSessionState(t),n.addGraphId(t,e),n.addSessionState(t,r),n.endSubGraphSessionState(t)}}e.SubGraphSessionState=n}(e.fbs||(e.fbs={}))}(t.experimental||(t.experimental={}))}(e.onnxruntime||(e.onnxruntime={})),function(t){!function(e){!function(e){class n{constructor(){this.bb=null,this.bb_pos=0}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsSessionState(t,e){return(e||new n).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsSessionState(t,e){return t.setPosition(t.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(e||new n).__init(t.readInt32(t.position())+t.position(),t)}kernels(e){let n=this.bb.__offset(this.bb_pos,4);return n?(e||new t.experimental.fbs.KernelCreateInfos).__init(this.bb.__indirect(this.bb_pos+n),this.bb):null}subGraphSessionStates(e,n){let r=this.bb.__offset(this.bb_pos,6);return r?(n||new t.experimental.fbs.SubGraphSessionState).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+r)+4*e),this.bb):null}subGraphSessionStatesLength(){let t=this.bb.__offset(this.bb_pos,6);return t?this.bb.__vector_len(this.bb_pos+t):0}static startSessionState(t){t.startObject(2)}static addKernels(t,e){t.addFieldOffset(0,e,0)}static addSubGraphSessionStates(t,e){t.addFieldOffset(1,e,0)}static createSubGraphSessionStatesVector(t,e){t.startVector(4,e.length,4);for(let n=e.length-1;n>=0;n--)t.addOffset(e[n]);return t.endVector()}static startSubGraphSessionStatesVector(t,e){t.startVector(4,e,4)}static endSessionState(t){return t.endObject()}static createSessionState(t,e,r){return n.startSessionState(t),n.addKernels(t,e),n.addSubGraphSessionStates(t,r),n.endSessionState(t)}}e.SessionState=n}(e.fbs||(e.fbs={}))}(t.experimental||(t.experimental={}))}(e.onnxruntime||(e.onnxruntime={})),function(t){!function(e){!function(e){class n{constructor(){this.bb=null,this.bb_pos=0}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsInferenceSession(t,e){return(e||new n).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsInferenceSession(t,e){return t.setPosition(t.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(e||new n).__init(t.readInt32(t.position())+t.position(),t)}static bufferHasIdentifier(t){return t.__has_identifier(\"ORTM\")}ortVersion(t){let e=this.bb.__offset(this.bb_pos,4);return e?this.bb.__string(this.bb_pos+e,t):null}model(e){let n=this.bb.__offset(this.bb_pos,6);return n?(e||new t.experimental.fbs.Model).__init(this.bb.__indirect(this.bb_pos+n),this.bb):null}sessionState(e){let n=this.bb.__offset(this.bb_pos,8);return n?(e||new t.experimental.fbs.SessionState).__init(this.bb.__indirect(this.bb_pos+n),this.bb):null}static startInferenceSession(t){t.startObject(3)}static addOrtVersion(t,e){t.addFieldOffset(0,e,0)}static addModel(t,e){t.addFieldOffset(1,e,0)}static addSessionState(t,e){t.addFieldOffset(2,e,0)}static endInferenceSession(t){return t.endObject()}static finishInferenceSessionBuffer(t,e){t.finish(e,\"ORTM\")}static finishSizePrefixedInferenceSessionBuffer(t,e){t.finish(e,\"ORTM\",!0)}static createInferenceSession(t,e,r,i){return n.startInferenceSession(t),n.addOrtVersion(t,e),n.addModel(t,r),n.addSessionState(t,i),n.endInferenceSession(t)}}e.InferenceSession=n}(e.fbs||(e.fbs={}))}(t.experimental||(t.experimental={}))}(e.onnxruntime||(e.onnxruntime={}))},7448:(t,e,n)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.OnnxjsSessionHandler=void 0;const r=n(6207),i=n(9162);e.OnnxjsSessionHandler=class{constructor(t){this.session=t,this.inputNames=this.session.inputNames,this.outputNames=this.session.outputNames}async dispose(){}async run(t,e,n){const o=new Map;for(const e in t)if(Object.hasOwnProperty.call(t,e)){const n=t[e];o.set(e,new i.Tensor(n.dims,n.type,void 0,void 0,n.data))}const a=await this.session.run(o),s={};return a.forEach(((t,e)=>{s[e]=new r.Tensor(t.type,t.data,t.dims)})),s}startProfiling(){this.session.startProfiling()}endProfiling(){this.session.endProfiling()}}},6919:(t,e,n)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.Session=void 0;const r=n(6231),i=n(6464),o=n(7091),a=n(1036),s=n(3694),u=n(2644);e.Session=class{constructor(t={}){this._initialized=!1,this.backendHint=t.backendHint,this.profiler=s.Profiler.create(t.profiler),this.context={profiler:this.profiler,graphInputTypes:[],graphInputDims:[]}}get inputNames(){return this._model.graph.getInputNames()}get outputNames(){return this._model.graph.getOutputNames()}startProfiling(){this.profiler.start()}endProfiling(){this.profiler.stop()}async loadModel(t,e,n){await this.profiler.event(\"session\",\"Session.loadModel\",(async()=>{const a=await(0,o.resolveBackend)(this.backendHint);if(this.sessionHandler=a.createSessionHandler(this.context),this._model=new u.Model,\"string\"==typeof t){const e=t.endsWith(\".ort\");if(\"undefined\"==typeof fetch){const n=await(0,i.promisify)(r.readFile)(t);this.initialize(n,e)}else{const n=await fetch(t),r=await n.arrayBuffer();this.initialize(new Uint8Array(r),e)}}else if(ArrayBuffer.isView(t))this.initialize(t);else{const r=new Uint8Array(t,e||0,n||t.byteLength);this.initialize(r)}}))}initialize(t,e){if(this._initialized)throw new Error(\"already initialized\");this.profiler.event(\"session\",\"Session.initialize\",(()=>{const n=this.sessionHandler.transformGraph?this.sessionHandler:void 0;this._model.load(t,n,e),this.sessionHandler.onGraphInitialized&&this.sessionHandler.onGraphInitialized(this._model.graph),this.initializeOps(this._model.graph),this._executionPlan=new a.ExecutionPlan(this._model.graph,this._ops,this.profiler)})),this._initialized=!0}async run(t){if(!this._initialized)throw new Error(\"session not initialized yet\");return this.profiler.event(\"session\",\"Session.run\",(async()=>{const e=this.normalizeAndValidateInputs(t),n=await this._executionPlan.execute(this.sessionHandler,e);return this.createOutput(n)}))}normalizeAndValidateInputs(t){const e=this._model.graph.getInputNames();if(Array.isArray(t)){if(t.length!==e.length)throw new Error(`incorrect input array length: expected ${e.length} but got ${t.length}`)}else{if(t.size!==e.length)throw new Error(`incorrect input map size: expected ${e.length} but got ${t.size}`);const n=new Array(t.size);let r=0;for(let i=0;i<e.length;++i){const o=t.get(e[i]);if(!o)throw new Error(`missing input tensor for: '${name}'`);n[r++]=o}t=n}if(this.context.graphInputTypes&&0!==this.context.graphInputTypes.length&&this.context.graphInputDims&&0!==this.context.graphInputDims.length)this.validateInputTensorDims(this.context.graphInputDims,t,!1);else{const e=this._model.graph.getInputIndices(),n=this._model.graph.getValues(),r=new Array(e.length);for(let i=0;i<e.length;++i){const o=n[e[i]];r[i]=o.type.shape.dims,this.context.graphInputTypes.push(o.type.tensorType),this.context.graphInputDims.push(t[i].dims)}this.validateInputTensorDims(r,t,!0)}return this.validateInputTensorTypes(this.context.graphInputTypes,t),t}validateInputTensorTypes(t,e){for(let n=0;n<e.length;n++){const r=t[n],i=e[n].type;if(r!==i)throw new Error(`input tensor[${n}] check failed: expected type '${r}' but got ${i}`)}}validateInputTensorDims(t,e,n){for(let r=0;r<e.length;r++){const i=t[r],o=e[r].dims;if(!this.compareTensorDims(i,o,n))throw new Error(`input tensor[${r}] check failed: expected shape '[${i.join(\",\")}]' but got [${o.join(\",\")}]`)}}compareTensorDims(t,e,n){if(t.length!==e.length)return!1;for(let r=0;r<t.length;++r)if(t[r]!==e[r]&&(!n||0!==t[r]))return!1;return!0}createOutput(t){const e=this._model.graph.getOutputNames();if(t.length!==e.length)throw new Error(\"expected number of outputs do not match number of generated outputs\");const n=new Map;for(let r=0;r<e.length;++r)n.set(e[r],t[r]);return n}initializeOps(t){const e=t.getNodes();this._ops=new Array(e.length);for(let n=0;n<e.length;n++)this._ops[n]=this.sessionHandler.resolve(e[n],this._model.opsets,t)}}},9162:function(t,e,n){\"use strict\";var r=this&&this.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(e,\"__esModule\",{value:!0}),e.Tensor=void 0;const i=n(3442),o=r(n(3720)),a=n(1446),s=n(9395),u=n(2517);var c=s.onnxruntime.experimental.fbs;class l{get data(){if(void 0===this.cache){const t=this.dataProvider(this.dataId);if(t.length!==this.size)throw new Error(\"Length of data provided by the Data Provider is inconsistent with the dims of this Tensor.\");this.cache=t}return this.cache}get stringData(){if(\"string\"!==this.type)throw new TypeError(\"data type is not string\");return this.data}get integerData(){switch(this.type){case\"uint8\":case\"int8\":case\"uint16\":case\"int16\":case\"int32\":case\"uint32\":case\"bool\":return this.data;default:throw new TypeError(\"data type is not integer (uint8, int8, uint16, int16, int32, uint32, bool)\")}}get floatData(){switch(this.type){case\"float32\":case\"float64\":return this.data;default:throw new TypeError(\"data type is not float (float32, float64)\")}}get numberData(){if(\"string\"!==this.type)return this.data;throw new TypeError(\"type cannot be non-number (string)\")}get(t){return this.data[u.ShapeUtil.indicesToOffset(t,this.strides)]}set(t,e){this.data[u.ShapeUtil.indicesToOffset(t,this.strides)]=e}async getData(){return void 0===this.cache&&(this.cache=await this.asyncDataProvider(this.dataId)),this.cache}get strides(){return this._strides||(this._strides=u.ShapeUtil.computeStrides(this.dims)),this._strides}constructor(t,e,n,r,o,a=i.Guid.create()){this.dims=t,this.type=e,this.dataProvider=n,this.asyncDataProvider=r,this.cache=o,this.dataId=a,this.size=u.ShapeUtil.validateDimsAndCalcSize(t);const s=this.size,c=void 0===n&&void 0===r&&void 0===o;if(void 0!==o&&o.length!==s)throw new RangeError(\"Input dims doesn't match data length.\");if(\"string\"===e){if(!(void 0===o||Array.isArray(o)&&o.every((t=>\"string\"==typeof t))))throw new TypeError(\"cache should be a string array\");c&&(this.cache=new Array(s))}else{if(void 0!==o){const t=f(e);if(!(o instanceof t))throw new TypeError(`cache should be type ${t.name}`)}if(c){const t=new ArrayBuffer(s*function(t){switch(t){case\"bool\":case\"int8\":case\"uint8\":return 1;case\"int16\":case\"uint16\":return 2;case\"int32\":case\"uint32\":case\"float32\":return 4;case\"float64\":return 8;default:throw new Error(`cannot calculate sizeof() on type ${t}`)}}(e));this.cache=function(t,e){return new(f(e))(t)}(t,e)}}}static fromProto(t){if(!t)throw new Error(\"cannot construct Value from an empty tensor\");const e=u.ProtoUtil.tensorDataTypeFromProto(t.dataType),n=u.ProtoUtil.tensorDimsFromProto(t.dims),r=new l(n,e);if(\"string\"===e)t.stringData.forEach(((t,e)=>{r.data[e]=(0,u.decodeUtf8String)(t)}));else if(t.rawData&&\"number\"==typeof t.rawData.byteLength&&t.rawData.byteLength>0){const e=r.data,n=new DataView(t.rawData.buffer,t.rawData.byteOffset,t.rawData.byteLength),i=p(t.dataType),o=t.rawData.byteLength/i;if(t.rawData.byteLength%i!=0)throw new Error(\"invalid buffer length\");if(e.length!==o)throw new Error(\"buffer length mismatch\");for(let r=0;r<o;r++){const o=h(n,t.dataType,r*i);e[r]=o}}else{let e;switch(t.dataType){case a.onnx.TensorProto.DataType.FLOAT:e=t.floatData;break;case a.onnx.TensorProto.DataType.INT32:case a.onnx.TensorProto.DataType.INT16:case a.onnx.TensorProto.DataType.UINT16:case a.onnx.TensorProto.DataType.INT8:case a.onnx.TensorProto.DataType.UINT8:case a.onnx.TensorProto.DataType.BOOL:e=t.int32Data;break;case a.onnx.TensorProto.DataType.INT64:e=t.int64Data;break;case a.onnx.TensorProto.DataType.DOUBLE:e=t.doubleData;break;case a.onnx.TensorProto.DataType.UINT32:case a.onnx.TensorProto.DataType.UINT64:e=t.uint64Data;break;default:throw new Error(\"unspecific error\")}if(null==e)throw new Error(\"failed to populate data from a tensorproto value\");const n=r.data;if(n.length!==e.length)throw new Error(\"array length mismatch\");for(let r=0;r<e.length;r++){const i=e[r];o.default.isLong(i)?n[r]=d(i,t.dataType):n[r]=i}}return r}static fromData(t,e,n){return new l(e,n,void 0,void 0,t)}static fromOrtTensor(t){if(!t)throw new Error(\"cannot construct Value from an empty tensor\");const e=u.ProtoUtil.tensorDimsFromORTFormat(t),n=u.ProtoUtil.tensorDataTypeFromProto(t.dataType()),r=new l(e,n);if(\"string\"===n)for(let e=0;e<t.stringDataLength();e++)r.data[e]=t.stringData(e);else if(t.rawDataArray()&&\"number\"==typeof t.rawDataLength()&&t.rawDataLength()>0){const e=r.data,n=new DataView(t.rawDataArray().buffer,t.rawDataArray().byteOffset,t.rawDataLength()),i=p(t.dataType()),o=t.rawDataLength()/i;if(t.rawDataLength()%i!=0)throw new Error(\"invalid buffer length\");if(e.length!==o)throw new Error(\"buffer length mismatch\");for(let r=0;r<o;r++){const o=h(n,t.dataType(),r*i);e[r]=o}}return r}}function p(t){switch(t){case a.onnx.TensorProto.DataType.UINT8:case a.onnx.TensorProto.DataType.INT8:case a.onnx.TensorProto.DataType.BOOL:return 1;case a.onnx.TensorProto.DataType.UINT16:case a.onnx.TensorProto.DataType.INT16:return 2;case a.onnx.TensorProto.DataType.FLOAT:case a.onnx.TensorProto.DataType.INT32:case a.onnx.TensorProto.DataType.UINT32:return 4;case a.onnx.TensorProto.DataType.INT64:case a.onnx.TensorProto.DataType.DOUBLE:case a.onnx.TensorProto.DataType.UINT64:return 8;default:throw new Error(`cannot calculate sizeof() on type ${a.onnx.TensorProto.DataType[t]}`)}}function f(t){switch(t){case\"bool\":case\"uint8\":return Uint8Array;case\"int8\":return Int8Array;case\"int16\":return Int16Array;case\"uint16\":return Uint16Array;case\"int32\":return Int32Array;case\"uint32\":return Uint32Array;case\"float32\":return Float32Array;case\"float64\":return Float64Array;default:throw new Error(\"unspecified error\")}}function d(t,e){if(e===a.onnx.TensorProto.DataType.INT64||e===c.TensorDataType.INT64){if(t.greaterThanOrEqual(2147483648)||t.lessThan(-2147483648))throw new TypeError(\"int64 is not supported\")}else{if(e!==a.onnx.TensorProto.DataType.UINT32&&e!==c.TensorDataType.UINT32&&e!==a.onnx.TensorProto.DataType.UINT64&&e!==c.TensorDataType.UINT64)throw new TypeError(`not a LONG type: ${a.onnx.TensorProto.DataType[e]}`);if(t.greaterThanOrEqual(4294967296)||t.lessThan(0))throw new TypeError(\"uint64 is not supported\")}return t.toNumber()}function h(t,e,n){switch(e){case a.onnx.TensorProto.DataType.BOOL:case a.onnx.TensorProto.DataType.UINT8:return t.getUint8(n);case a.onnx.TensorProto.DataType.INT8:return t.getInt8(n);case a.onnx.TensorProto.DataType.UINT16:return t.getUint16(n,!0);case a.onnx.TensorProto.DataType.INT16:return t.getInt16(n,!0);case a.onnx.TensorProto.DataType.FLOAT:return t.getFloat32(n,!0);case a.onnx.TensorProto.DataType.INT32:return t.getInt32(n,!0);case a.onnx.TensorProto.DataType.UINT32:return t.getUint32(n,!0);case a.onnx.TensorProto.DataType.INT64:return d(o.default.fromBits(t.getUint32(n,!0),t.getUint32(n+4,!0),!1),e);case a.onnx.TensorProto.DataType.DOUBLE:return t.getFloat64(n,!0);case a.onnx.TensorProto.DataType.UINT64:return d(o.default.fromBits(t.getUint32(n,!0),t.getUint32(n+4,!0),!0),e);default:throw new Error(`cannot read from DataView for type ${a.onnx.TensorProto.DataType[e]}`)}}e.Tensor=l},2517:function(t,e,n){\"use strict\";var r=this&&this.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(e,\"__esModule\",{value:!0}),e.decodeUtf8String=e.MAX_CLIP=e.MIN_CLIP=e.PoolConvUtil=e.ReduceUtil=e.SplitUtil=e.MathUtil=e.ShapeUtil=e.LongUtil=e.ProtoUtil=e.GemmUtil=e.arrayCopyHelper=e.BroadcastUtil=e.MatMulUtil=e.ArrayUtil=e.assert=e.checkInputsShape=void 0;const i=n(5686),o=r(n(3720)),a=n(1446),s=n(9162);e.checkInputsShape=function(t,...e){if(!t||t.length!==e.length)return!1;for(let n=0;n<t.length;n++)if(!t[n].dims||t[n].dims.length!==e[n])return!1;return!0},e.assert=function(t,e){if(!t)throw new Error(\"string\"==typeof e?e:e())},e.ArrayUtil=class{static arraysEqual(t,e){if(t.length!==e.length)return!1;for(let n=0;n<t.length;n++)if(t[n]!==e[n])return!1;return!0}};class u{static preprocessInputShapes(t,e){return[1===t.length?[1,t[0]]:t,1===e.length?[e[0],1]:e]}static postprocessOutputShape(t,e,n){1===e&&t.splice(t.length-2,1),1===n&&t.pop()}static calcMatMulShape(t,e){return t[1]!==e[0]?void 0:[t[0],e[1]]}}e.MatMulUtil=u;class c{static calcShape(t,e,n=!1){const r=t.length,i=e.length;if(0===r)return e;if(0===i)return t;const o=Math.max(t.length,e.length),a=new Array(o);if(n){if(r<2||i<2)return;const n=u.calcMatMulShape([t[r-2],t[r-1]],[e[i-2],e[i-1]]);if(void 0===n)return;[a[o-2],a[o-1]]=n}for(let s=n?3:1;s<=o;s++){const n=r-s<0?1:t[r-s],u=i-s<0?1:e[i-s];if(n!==u&&n>1&&u>1)return;a[o-s]=Math.max(n,u)}return a}static index(t,e){const n=new Array(e.length);return c.fillIndex(t,e,n),n}static fillIndex(t,e,n){const r=t.length-e.length;for(let i=0;i<e.length;i++)n[i]=t[r+i]%e[i]}static calc(t,e,n,r,i){const o=c.calcShape(t.dims,e.dims);if(o){if(r&&!f.areEqual(o,t.dims))return;const a=f.size(o),u=r?t:new s.Tensor(o,i||t.type);if(0===o.length)u.set([],n(t.get([]),e.get([])));else{const r=new Array(o.length),i=new Array(t.dims.length),s=new Array(e.dims.length);let l,p=0,f=0,d=!1,h=!1;0===t.dims.length&&(p=t.get([]),d=!0),0===e.dims.length&&(f=e.get([]),h=!0);for(let g=0;g<a;g++){l=g;for(let t=o.length-1;t>=0;t--)r[t]=l%o[t],l=Math.floor(l/o[t]);d||(c.fillIndex(r,t.dims,i),p=t.get(i)),h||(c.fillIndex(r,e.dims,s),f=e.get(s)),u.set(r,n(p,f))}}return u}}static isValidBroadcast(t,e){const n=t.length,r=e.length;if(n>r)return!1;for(let i=1;i<=n;i++)if(1!==t[n-i]&&t[n-i]!==e[r-i])return!1;return!0}static getBroadcastDims(t,e){const n=t.length,r=[];for(let i=0;i<n;i++){const o=n-1-i,a=t[o]||1;(e[e.length-1-i]||1)>1&&1===a&&r.unshift(o)}return r}}e.BroadcastUtil=c,e.arrayCopyHelper=function(t,e,n,r,i){if(r<0||r>=e.length)throw new Error(\"sourceIndex out of bounds\");if(n<0||n>=t.length)throw new Error(\"targetIndex out of bounds\");if(r+i>e.length)throw new Error(\"source indices to be copied are outside bounds\");if(n+i>t.length)throw new Error(\"target array is too small to hold result\");for(let o=0;o<i;o++)t[n+o]=e[r+o]},e.GemmUtil=class{static getShapeOfGemmResult(t,e,n,r,i){if(2!==t.length||2!==n.length)throw new Error(\"shape need to be of size 2\");let o,a,s;e?(o=t[1],a=t[0]):(o=t[0],a=t[1]);let u=-1;if(r?(s=n[0],u=1):(s=n[1],u=0),n[u]!==a)throw new Error(\"dimension mismatch\");if(o<=0||s<=0||a<=0)throw new Error(\"invalid shape specified\");if(i&&!c.isValidBroadcast(i,[o,s]))throw new Error(\"gemm: invalid bias shape for broadcast\");return[o,s,a]}};class l{static tensorDataTypeFromProto(t){switch(t){case a.onnx.TensorProto.DataType.INT8:return\"int8\";case a.onnx.TensorProto.DataType.UINT8:return\"uint8\";case a.onnx.TensorProto.DataType.BOOL:return\"bool\";case a.onnx.TensorProto.DataType.INT16:return\"int16\";case a.onnx.TensorProto.DataType.UINT16:return\"uint16\";case a.onnx.TensorProto.DataType.INT32:return\"int32\";case a.onnx.TensorProto.DataType.UINT32:return\"uint32\";case a.onnx.TensorProto.DataType.FLOAT:return\"float32\";case a.onnx.TensorProto.DataType.DOUBLE:return\"float64\";case a.onnx.TensorProto.DataType.STRING:return\"string\";case a.onnx.TensorProto.DataType.INT64:return\"int32\";case a.onnx.TensorProto.DataType.UINT64:return\"uint32\";default:throw new Error(`unsupported data type: ${a.onnx.TensorProto.DataType[t]}`)}}static tensorDataTypeStringToEnum(t){switch(t){case\"int8\":return a.onnx.TensorProto.DataType.INT8;case\"uint8\":return a.onnx.TensorProto.DataType.UINT8;case\"bool\":return a.onnx.TensorProto.DataType.BOOL;case\"int16\":return a.onnx.TensorProto.DataType.INT16;case\"uint16\":return a.onnx.TensorProto.DataType.UINT16;case\"int32\":return a.onnx.TensorProto.DataType.INT32;case\"uint32\":return a.onnx.TensorProto.DataType.UINT32;case\"float32\":return a.onnx.TensorProto.DataType.FLOAT;case\"float64\":return a.onnx.TensorProto.DataType.DOUBLE;case\"string\":return a.onnx.TensorProto.DataType.STRING;case\"int64\":return a.onnx.TensorProto.DataType.INT64;case\"uint64\":return a.onnx.TensorProto.DataType.UINT64;default:throw new Error(`unsupported data type: ${t}`)}}static tensorDimsFromProto(t){return t.map((t=>o.default.isLong(t)?t.toNumber():t))}static tensorValueTypeFromProto(t){return{tensorType:l.tensorDataTypeFromProto(t.elemType),shape:{dims:l.tensorDimsFromProto(t.shape.dim.map((t=>t.dimValue)))}}}static tensorDimsFromORTFormat(t){const e=[];for(let n=0;n<t.dimsLength();n++)e.push(p.longToNumber(t.dims(n)));return e}static tensorAttributesFromORTFormat(t){const e=[];for(let n=0;n<t.attributesLength();n++)e.push(t.attributes(n));return e}}e.ProtoUtil=l;class p{static longToNumber(t,e){return o.default.isLong(t)?t.toNumber():t instanceof i.flatbuffers.Long?o.default.fromValue({low:t.low,high:t.high,unsigned:null!=e&&e}).toNumber():t}static isLong(t){return o.default.isLong(t)||t instanceof i.flatbuffers.Long}}e.LongUtil=p;class f{static size(t){return f.getSizeFromDimensionRange(t,0,t.length)}static sizeFromDimension(t,e){if(e<0||e>t.length)throw new Error(`invalid dimension of ${e} for sizeFromDimension as Tensor has ${t.length} dimensions.`);return f.getSizeFromDimensionRange(t,e,t.length)}static sizeToDimension(t,e){if(e<0||e>t.length)throw new Error(`invalid dimension of ${e} for sizeToDimension as Tensor has ${t.length} dimensions.`);return f.getSizeFromDimensionRange(t,0,e)}static getSizeFromDimensionRange(t,e,n){let r=1;for(let i=e;i<n;i++){if(t[i]<=0)throw new Error(\"cannot get valid size from specified dimension range. Most likely the range contains 0 or negative values in them.\");r*=t[i]}return r}static computeStrides(t){const e=t.length;if(0===e)return[];if(1===e)return[1];const n=new Array(e);n[e-1]=1,n[e-2]=t[e-1];for(let r=e-3;r>=0;--r)n[r]=n[r+1]*t[r+1];return n}static transpose(t){return t.slice().reverse()}static indicesToOffset(t,e,n){void 0===n&&(n=t.length);let r=0;for(let i=0;i<n;++i)r+=e[i]*t[i];return r}static offsetToIndices(t,e){const n=e.length;if(0===n)return[];if(1===n)return[t*e[0]];const r=new Array(e.length);for(let n=0;n<r.length-1;++n)r[n]=Math.floor(t/e[n]),t-=r[n]*e[n];return r[r.length-1]=t,r}static normalizeAxis(t,e){if(t<-e&&t>=e)throw new Error(\"unsupported axis for this operation.\");return t<0?t+e:t}static normalizeAxes(t,e){return t.map((t=>this.normalizeAxis(t,e)))}static incrementIndex(t,e,n){if(0===e.length||0===t.length)throw new Error(\"Index incrementing unsupported for scalar Tensor\");if(void 0===n)n=e.length;else if(n<=0||n>e.length)throw new Error(\"Incorrect axis to increment on\");for(let r=n-1;r>=0&&(t[r]++,!(t[r]<e[r]));--r)t[r]=0}static calculateReshapedDims(t,e){if(0===e.length){if(0===t.length||1===f.size(t))return[];throw new Error(\"cannot reshape to a scalar Tensor\")}const n=e.length,r=new Array(n);let i=-1,o=1;for(let a=0;a<n;a++){if(e[a]<-1)throw new Error(\"a dimension in shape hints cannot be less than -1\");if(-1===e[a]){if(-1!==i)throw new Error(\"at most one dimension in shape hints can be -1\");i=a}else{if(0===e[a]){if(a>=t.length)throw new Error(\"the dimension with value zero exceeds the dimension size of the input tensor\");r[a]=t[a]}else r[a]=e[a];o*=r[a]}}const a=f.size(t);if(-1!==i){if(a%o!=0)throw new Error(`the input tensor cannot be reshaped to the requested shape. Input shape: [${t}] Output shape: [${e}]`);r[i]=a/o}else if(o!==a)throw new Error(\"reshapedDims and originalDims don't have matching sizes\");return r}static sortBasedOnPerm(t,e){return e?e.map((e=>t[e])):t.slice().reverse()}static padShape(t,e){const n=t.length;return t.map(((t,r)=>t+e[r]+e[r+n]))}static areEqual(t,e){return t.length===e.length&&t.every(((t,n)=>t===e[n]))}static validateDimsAndCalcSize(t){if(t.length>6)throw new TypeError(\"Only rank 0 to 6 is supported for tensor shape.\");let e=1;for(const n of t){if(!Number.isInteger(n))throw new TypeError(`Invalid shape: ${n} is not an integer`);if(n<0||n>2147483647)throw new TypeError(`Invalid shape: length ${n} is not allowed`);e*=n}return e}static flattenShape(t,e){e<0&&(e+=t.length);const n=t.reduce(((t,e)=>t*e),1),r=t.slice(e).reduce(((t,e)=>t*e),1);return[n/r,r]}static squeezeShape(t,e){const n=new Array;e=f.normalizeAxes(e,t.length);for(let r=0;r<t.length;r++){const i=e.indexOf(r)>=0;if(i&&1!==t[r])throw new Error(\"squeeze an axis of size different than 1\");(0===e.length&&t[r]>1||e.length>0&&!i)&&n.push(t[r])}return n}static unsqueezeShape(t,e){const n=new Array(t.length+e.length);n.fill(0);for(let t=0;t<e.length;t++){const r=f.normalizeAxis(e[t],n.length);if(r>=n.length)throw new Error(\"'axes' has an out of range axis\");if(0!==n[r])throw new Error(\"'axes' has a duplicate axis\");n[r]=1}let r=0;for(let e=0;e<n.length;e++)0===n[e]&&(n[e]=t[r++]);if(r!==t.length)throw new Error(\"the unsqueezed dimension could not be established\");return n}}e.ShapeUtil=f,e.MathUtil=class{static sqr(t,e,n,r,i){if(r<0||r>=e.length)throw new Error(\"sourceIndex out of bounds\");if(n<0||n>=t.length)throw new Error(\"targetIndex out of bounds\");if(r+i>e.length)throw new Error(\"source indices to be copied are outside bounds\");if(n+i>t.length)throw new Error(\"target array is too small to hold result\");for(let o=0;o<i;o++)t[n+o]+=Math.pow(e[r+o],2)}static axpy(t,e,n,r,i,o){if(r<0||r>=e.length)throw new Error(\"sourceIndex out of bounds\");if(n<0||n>=t.length)throw new Error(\"targetIndex out of bounds\");if(r+i>e.length)throw new Error(\"source indices to be copied are outside bounds\");if(n+i>t.length)throw new Error(\"target array is too small to hold result\");for(let a=0;a<i;a++)t[n+a]+=o*e[r+a]}static powx(t,e,n,r,i,o){if(r<0||r>=e.length)throw new Error(\"sourceIndex out of bounds\");if(n<0||n>=t.length)throw new Error(\"targetIndex out of bounds\");if(r+i>e.length)throw new Error(\"source indices to be copied are outside bounds\");if(n+i>t.length)throw new Error(\"target array is too small to hold result\");for(let a=0;a<i;a++)t[n+a]=Math.pow(e[r+a],o)}static mul(t,e,n,r,i){if(r<0||r>=e.length)throw new Error(\"sourceIndex out of bounds\");if(n<0||n>=t.length)throw new Error(\"targetIndex out of bounds\");if(r+i>e.length)throw new Error(\"source indices to be copied are outside bounds\");if(n+i>t.length)throw new Error(\"target array is too small to hold result\");for(let o=0;o<i;o++)t[n+o]=e[r+o]*t[n+o]}};class d{static splitShape(t,e,n,r){if(0===n.length){if(!r)throw new Error(\"need to know number of outputs when the 'split' attribute is not specified\");d.determineSplit(t[e],r,n)}const i=[],o=[0];for(let r=0;r<n.length;++r){0!==r&&o.push(o[r-1]+n[r-1]);const a=t.slice();a[e]=n[r],i.push(a)}return[i,o]}static determineSplit(t,e,n){if(t%e!=0)throw new Error(\"cannot split tensor to equal sized parts\");for(let r=0;r<e;++r)n.push(t/e)}}e.SplitUtil=d;class h{static calcReduce(t,e,n,r,i){const o=t.dims.slice(0);0===e.length&&o.forEach(((t,n)=>e.push(n)));const a=h.calcReduceShape(o,e,!0),u=f.size(a),l=new s.Tensor(a,t.type),p=f.computeStrides(a),d=f.computeStrides(o),g=new Array(o.length);for(let n=0;n<u;n++){const a=f.offsetToIndices(n,p);c.fillIndex(a,o,g),l.set(a,h.calcReduceByAxis(t.numberData,e,o,0,f.indicesToOffset(g,d),r,i))}return n?l:new s.Tensor(h.calcReduceShape(o,e,n),l.type,void 0,void 0,l.data,l.dataId)}static calcReduceByAxis(t,e,n,r,i,o,a){let s=0;if(r>=e.length)return o(t[i]);const u=e[r],c=u>=n.length?1:f.size(n.slice(u+1));for(let l=0;l<n[u];l++)s=0===l?h.calcReduceByAxis(t,e,n,r+1,i,o,a):a(s,h.calcReduceByAxis(t,e,n,r+1,i,o,a)),i+=c;return s}static calcReduceShape(t,e,n){const r=t.slice();for(let t=0;t<e.length;t++)r[e[t]]=n?1:0;return r.filter((t=>0!==t))}}e.ReduceUtil=h;class g{static adjustPoolAttributes(t,e,n,r,i,o){if(!t&&n.length!==e.length-2)throw new Error(\"length of specified kernel shapes should be 2 less than length of input dimensions\");if(t)for(let t=0;t<e.length-2;t++)t>=n.length?n.push(e[t+2]):n[t]=e[t+2];for(let t=0;t<n.length;t++)if(t<r.length){if(r[t]<0)throw new Error(\"strides should be greater than or equal to 1\")}else r.push(1);for(let t=0;t<n.length;t++)if(t<i.length){if(i[t]<0)throw new Error(\"dilations should be greater than or equal to 1\")}else i.push(1);for(let t=0;t<2*n.length;t++)if(t<o.length){if(o[t]<0)throw new Error(\"pad should be greater than or equal to 1\")}else o.push(0);for(let t=0;t<n.length;t++){if(n[t]<=0)throw new Error(\"kernel shapes need to be greater than 0\");if(o[t]>=n[t]||o[t+n.length]>=n[t])throw new Error(\"pads should be smaller than kernel\")}}static adjustPadsBasedOnAutoPad(t,e,n,r,i,o){if(o){if(i.length!==2*(t.length-2))throw new Error(\"length of pads should be twice the length of data dimensions\");if(e.length!==t.length-2)throw new Error(\"length of strides should be the length of data dimensions\");if(r.length!==t.length-2)throw new Error(\"length of kernel shapes should be the length of data dimensions\");for(let a=0;a<t.length-2;a++)g.adjustPadAndReturnShape(t[a+2],e[a],n[a],r[a],i,a,a+t.length-2,o)}}static computePoolOutputShape(t,e,n,r,i,o,a){if(e.length<=0)throw new Error(\"input shape must be of size greater than 0\");const s=[e[0],e[1]];return g.computeShapeHelper(t,e,s,n,r,i,o,a),s}static computeConvOutputShape(t,e,n,r,i,o,a){if(t.length<=0||e.length<=0)throw new Error(\"invalid input tensor dims or invalid filter tensor dims\");const s=[t[0],e[0]];return g.computeShapeHelper(!1,t,s,n,r,i,o,a),s}static computeShapeHelper(t,e,n,r,i,o,a,s){if(t)for(let t=0;t<e.length-2;t++)n.push(1);else for(let t=0;t<e.length-2;t++)n.push(g.adjustPadAndReturnShape(e[t+2],r[t],i[t],o[t],a,t,t+e.length-2,s))}static adjustPadAndReturnShape(t,e,n,r,i,o,a,s){const u=n*(r-1)+1;if(!s||\"NOTSET\"===s)return Math.floor((t+i[o]+i[a]-u)/e+1);switch(s){case\"VALID\":return i[o]=0,i[a]=0,Math.floor((t-u)/e+1);case\"SAME_LOWER\":case\"SAME_UPPER\":if(1!==n)throw new Error(\"Dilation not supported for SAME_UPPER or SAME_LOWER\");{const n=((t+e-1)/e-1)*e+r-t;return i[o]=\"SAME_LOWER\"===s?Math.floor((n+1)/2):Math.floor(n/2),i[a]=n-i[o],Math.floor((t+n-r)/e+1)}default:throw new Error(\"Unsupported AutoPad type\")}}}e.PoolConvUtil=g,e.MIN_CLIP=-34028234663852886e22,e.MAX_CLIP=34028234663852886e22,e.decodeUtf8String=function(t){return(new TextDecoder).decode(t)}},7967:(t,e)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.iterateExtraOptions=void 0,e.iterateExtraOptions=(t,n,r,i)=>{if(\"object\"==typeof t&&null!==t){if(r.has(t))throw new Error(\"Circular reference in options\");r.add(t)}Object.entries(t).forEach((([t,o])=>{const a=n?n+t:t;if(\"object\"==typeof o)(0,e.iterateExtraOptions)(o,a+\".\",r,i);else if(\"string\"==typeof o||\"number\"==typeof o)i(a,o.toString());else{if(\"boolean\"!=typeof o)throw new Error(\"Can't handle extra config type: \"+typeof o);i(a,o?\"1\":\"0\")}}))}},2157:function(t,e,n){\"use strict\";var r,i=this&&this.__createBinding||(Object.create?function(t,e,n,r){void 0===r&&(r=n);var i=Object.getOwnPropertyDescriptor(e,n);i&&!(\"get\"in i?!e.__esModule:i.writable||i.configurable)||(i={enumerable:!0,get:function(){return e[n]}}),Object.defineProperty(t,r,i)}:function(t,e,n,r){void 0===r&&(r=n),t[r]=e[n]}),o=this&&this.__setModuleDefault||(Object.create?function(t,e){Object.defineProperty(t,\"default\",{enumerable:!0,value:e})}:function(t,e){t.default=e}),a=this&&this.__importStar||function(t){if(t&&t.__esModule)return t;var e={};if(null!=t)for(var n in t)\"default\"!==n&&Object.prototype.hasOwnProperty.call(t,n)&&i(e,t,n);return o(e,t),e};Object.defineProperty(e,\"__esModule\",{value:!0}),e.endProfiling=e.run=e.releaseSession=e.createSession=e.createSessionFinalize=e.createSessionAllocate=e.initOrt=e.initWasm=void 0;const s=n(6207),u=a(n(349)),c=n(6361),l=()=>!!s.env.wasm.proxy&&\"undefined\"!=typeof document;let p,f,d,h=!1,g=!1,b=!1;const m=[],y=[],_=[],v=[],w=[],x=[],T=()=>{if(h||!g||b||!p)throw new Error(\"worker not ready\")},S=t=>{switch(t.data.type){case\"init-wasm\":h=!1,t.data.err?(b=!0,f[1](t.data.err)):(g=!0,f[0]());break;case\"init-ort\":t.data.err?d[1](t.data.err):d[0]();break;case\"create_allocate\":t.data.err?m.shift()[1](t.data.err):m.shift()[0](t.data.out);break;case\"create_finalize\":t.data.err?y.shift()[1](t.data.err):y.shift()[0](t.data.out);break;case\"create\":t.data.err?_.shift()[1](t.data.err):_.shift()[0](t.data.out);break;case\"release\":t.data.err?v.shift()[1](t.data.err):v.shift()[0]();break;case\"run\":t.data.err?w.shift()[1](t.data.err):w.shift()[0](t.data.out);break;case\"end-profiling\":t.data.err?x.shift()[1](t.data.err):x.shift()[0]()}},O=\"undefined\"!=typeof document?null===(r=null===document||void 0===document?void 0:document.currentScript)||void 0===r?void 0:r.src:void 0;e.initWasm=async()=>{if(l()){if(g)return;if(h)throw new Error(\"multiple calls to 'initWasm()' detected.\");if(b)throw new Error(\"previous call to 'initWasm()' failed.\");return h=!0,void 0===s.env.wasm.wasmPaths&&O&&0!==O.indexOf(\"blob:\")&&(s.env.wasm.wasmPaths=O.substr(0,+O.lastIndexOf(\"/\")+1)),new Promise(((t,e)=>{null==p||p.terminate(),p=n(9710).Z(),p.onmessage=S,f=[t,e];const r={type:\"init-wasm\",in:s.env.wasm};p.postMessage(r)}))}return(0,c.initializeWebAssembly)(s.env.wasm)},e.initOrt=async(t,e)=>{if(l())return T(),new Promise(((n,r)=>{d=[n,r];const i={type:\"init-ort\",in:{numThreads:t,loggingLevel:e}};p.postMessage(i)}));u.initOrt(t,e)},e.createSessionAllocate=async t=>l()?(T(),new Promise(((e,n)=>{m.push([e,n]);const r={type:\"create_allocate\",in:{model:t}};p.postMessage(r,[t.buffer])}))):u.createSessionAllocate(t),e.createSessionFinalize=async(t,e)=>l()?(T(),new Promise(((n,r)=>{y.push([n,r]);const i={type:\"create_finalize\",in:{modeldata:t,options:e}};p.postMessage(i)}))):u.createSessionFinalize(t,e),e.createSession=async(t,e)=>l()?(T(),new Promise(((n,r)=>{_.push([n,r]);const i={type:\"create\",in:{model:t,options:e}};p.postMessage(i,[t.buffer])}))):u.createSession(t,e),e.releaseSession=async t=>{if(l())return T(),new Promise(((e,n)=>{v.push([e,n]);const r={type:\"release\",in:t};p.postMessage(r)}));u.releaseSession(t)},e.run=async(t,e,n,r,i)=>l()?(T(),new Promise(((o,a)=>{w.push([o,a]);const s={type:\"run\",in:{sessionId:t,inputIndices:e,inputs:n,outputIndices:r,options:i}};p.postMessage(s,u.extractTransferableBuffers(n))}))):u.run(t,e,n,r,i),e.endProfiling=async t=>{if(l())return T(),new Promise(((e,n)=>{x.push([e,n]);const r={type:\"end-profiling\",in:t};p.postMessage(r)}));u.endProfiling(t)}},586:(t,e,n)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.setRunOptions=void 0;const r=n(7967),i=n(4983),o=n(6361);e.setRunOptions=t=>{const e=(0,o.getInstance)();let n=0;const a=[],s=t||{};try{if(void 0===(null==t?void 0:t.logSeverityLevel))s.logSeverityLevel=2;else if(\"number\"!=typeof t.logSeverityLevel||!Number.isInteger(t.logSeverityLevel)||t.logSeverityLevel<0||t.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${t.logSeverityLevel}`);if(void 0===(null==t?void 0:t.logVerbosityLevel))s.logVerbosityLevel=0;else if(\"number\"!=typeof t.logVerbosityLevel||!Number.isInteger(t.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${t.logVerbosityLevel}`);void 0===(null==t?void 0:t.terminate)&&(s.terminate=!1);let o=0;if(void 0!==(null==t?void 0:t.tag)&&(o=(0,i.allocWasmString)(t.tag,a)),n=e._OrtCreateRunOptions(s.logSeverityLevel,s.logVerbosityLevel,!!s.terminate,o),0===n)throw new Error(\"Can't create run options\");return void 0!==(null==t?void 0:t.extra)&&(0,r.iterateExtraOptions)(t.extra,\"\",new WeakSet,((t,r)=>{const o=(0,i.allocWasmString)(t,a),s=(0,i.allocWasmString)(r,a);if(0!==e._OrtAddRunConfigEntry(n,o,s))throw new Error(`Can't set a run config entry: ${t} - ${r}`)})),[n,a]}catch(t){throw 0!==n&&e._OrtReleaseRunOptions(n),a.forEach(e._free),t}}},2306:(t,e,n)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.OnnxruntimeWebAssemblySessionHandler=void 0;const r=n(6231),i=n(6207),o=n(6464),a=n(2157);let s;e.OnnxruntimeWebAssemblySessionHandler=class{async createSessionAllocate(t){const e=await fetch(t),n=await e.arrayBuffer();return(0,a.createSessionAllocate)(new Uint8Array(n))}async loadModel(t,e){if(s||(await(0,a.initOrt)(i.env.wasm.numThreads,(t=>{switch(t){case\"verbose\":return 0;case\"info\":return 1;case\"warning\":return 2;case\"error\":return 3;case\"fatal\":return 4;default:throw new Error(`unsupported logging level: ${t}`)}})(i.env.logLevel)),s=!0),\"string\"==typeof t)if(\"undefined\"==typeof fetch){const n=await(0,o.promisify)(r.readFile)(t);[this.sessionId,this.inputNames,this.outputNames]=await(0,a.createSession)(n,e)}else{const n=await this.createSessionAllocate(t);[this.sessionId,this.inputNames,this.outputNames]=await(0,a.createSessionFinalize)(n,e)}else[this.sessionId,this.inputNames,this.outputNames]=await(0,a.createSession)(t,e)}async dispose(){return(0,a.releaseSession)(this.sessionId)}async run(t,e,n){const r=[],o=[];Object.entries(t).forEach((t=>{const e=t[0],n=t[1],i=this.inputNames.indexOf(e);if(-1===i)throw new Error(`invalid input '${e}'`);r.push(n),o.push(i)}));const s=[];Object.entries(e).forEach((t=>{const e=t[0],n=this.outputNames.indexOf(e);if(-1===n)throw new Error(`invalid output '${e}'`);s.push(n)}));const u=await(0,a.run)(this.sessionId,o,r.map((t=>[t.type,t.dims,t.data])),s,n),c={};for(let t=0;t<u.length;t++)c[this.outputNames[s[t]]]=new i.Tensor(u[t][0],u[t][2],u[t][1]);return c}startProfiling(){}endProfiling(){(0,a.endProfiling)(this.sessionId)}}},4919:(t,e,n)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.setSessionOptions=void 0;const r=n(7967),i=n(4983),o=n(6361);e.setSessionOptions=t=>{const e=(0,o.getInstance)();let n=0;const a=[],s=t||{};(t=>{t.extra||(t.extra={}),t.extra.session||(t.extra.session={});const e=t.extra.session;e.use_ort_model_bytes_directly||(e.use_ort_model_bytes_directly=\"1\")})(s);try{void 0===(null==t?void 0:t.graphOptimizationLevel)&&(s.graphOptimizationLevel=\"all\");const u=(t=>{switch(t){case\"disabled\":return 0;case\"basic\":return 1;case\"extended\":return 2;case\"all\":return 99;default:throw new Error(`unsupported graph optimization level: ${t}`)}})(s.graphOptimizationLevel);void 0===(null==t?void 0:t.enableCpuMemArena)&&(s.enableCpuMemArena=!0),void 0===(null==t?void 0:t.enableMemPattern)&&(s.enableMemPattern=!0),void 0===(null==t?void 0:t.executionMode)&&(s.executionMode=\"sequential\");const c=(t=>{switch(t){case\"sequential\":return 0;case\"parallel\":return 1;default:throw new Error(`unsupported execution mode: ${t}`)}})(s.executionMode);let l=0;if(void 0!==(null==t?void 0:t.logId)&&(l=(0,i.allocWasmString)(t.logId,a)),void 0===(null==t?void 0:t.logSeverityLevel))s.logSeverityLevel=2;else if(\"number\"!=typeof t.logSeverityLevel||!Number.isInteger(t.logSeverityLevel)||t.logSeverityLevel<0||t.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${t.logSeverityLevel}`);if(void 0===(null==t?void 0:t.logVerbosityLevel))s.logVerbosityLevel=0;else if(\"number\"!=typeof t.logVerbosityLevel||!Number.isInteger(t.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${t.logVerbosityLevel}`);if(void 0===(null==t?void 0:t.enableProfiling)&&(s.enableProfiling=!1),n=e._OrtCreateSessionOptions(u,!!s.enableCpuMemArena,!!s.enableMemPattern,c,!!s.enableProfiling,0,l,s.logSeverityLevel,s.logVerbosityLevel),0===n)throw new Error(\"Can't create session options\");return(null==t?void 0:t.executionProviders)&&((t,e,n)=>{for(const r of e){let e=\"string\"==typeof r?r:r.name;switch(e){case\"xnnpack\":e=\"XNNPACK\";break;case\"wasm\":case\"cpu\":continue;default:throw new Error(`not supported EP: ${e}`)}const a=(0,i.allocWasmString)(e,n);if(0!==(0,o.getInstance)()._OrtAppendExecutionProvider(t,a))throw new Error(`Can't append execution provider: ${e}`)}})(n,t.executionProviders,a),void 0!==(null==t?void 0:t.extra)&&(0,r.iterateExtraOptions)(t.extra,\"\",new WeakSet,((t,r)=>{const o=(0,i.allocWasmString)(t,a),s=(0,i.allocWasmString)(r,a);if(0!==e._OrtAddSessionConfigEntry(n,o,s))throw new Error(`Can't set a session config entry: ${t} - ${r}`)})),[n,a]}catch(t){throw 0!==n&&e._OrtReleaseSessionOptions(n),a.forEach(e._free),t}}},4983:(t,e,n)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.allocWasmString=void 0;const r=n(6361);e.allocWasmString=(t,e)=>{const n=(0,r.getInstance)(),i=n.lengthBytesUTF8(t)+1,o=n._malloc(i);return n.stringToUTF8(t,o,i),e.push(o),o}},349:(t,e,n)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.extractTransferableBuffers=e.endProfiling=e.run=e.releaseSession=e.createSession=e.createSessionFinalize=e.createSessionAllocate=e.initOrt=void 0;const r=n(586),i=n(4919),o=n(4983),a=n(6361);e.initOrt=(t,e)=>{const n=(0,a.getInstance)()._OrtInit(t,e);if(0!==n)throw new Error(`Can't initialize onnxruntime. error code = ${n}`)};const s=new Map;e.createSessionAllocate=t=>{const e=(0,a.getInstance)(),n=e._malloc(t.byteLength);return e.HEAPU8.set(t,n),[n,t.byteLength]},e.createSessionFinalize=(t,e)=>{const n=(0,a.getInstance)();let r=0,o=0,u=[];try{if([o,u]=(0,i.setSessionOptions)(e),r=n._OrtCreateSession(t[0],t[1],o),0===r)throw new Error(\"Can't create a session\")}finally{n._free(t[0]),n._OrtReleaseSessionOptions(o),u.forEach(n._free)}const c=n._OrtGetInputCount(r),l=n._OrtGetOutputCount(r),p=[],f=[],d=[],h=[];for(let t=0;t<c;t++){const e=n._OrtGetInputName(r,t);if(0===e)throw new Error(\"Can't get an input name\");f.push(e),p.push(n.UTF8ToString(e))}for(let t=0;t<l;t++){const e=n._OrtGetOutputName(r,t);if(0===e)throw new Error(\"Can't get an output name\");h.push(e),d.push(n.UTF8ToString(e))}return s.set(r,[r,f,h]),[r,p,d]},e.createSession=(t,n)=>{const r=(0,e.createSessionAllocate)(t);return(0,e.createSessionFinalize)(r,n)},e.releaseSession=t=>{const e=(0,a.getInstance)(),n=s.get(t);if(!n)throw new Error(\"invalid session id\");const r=n[0],i=n[1],o=n[2];i.forEach(e._OrtFree),o.forEach(e._OrtFree),e._OrtReleaseSession(r),s.delete(t)};const u=t=>{switch(t){case\"int8\":return 3;case\"uint8\":return 2;case\"bool\":return 9;case\"int16\":return 5;case\"uint16\":return 4;case\"int32\":return 6;case\"uint32\":return 12;case\"float32\":return 1;case\"float64\":return 11;case\"string\":return 8;case\"int64\":return 7;case\"uint64\":return 13;default:throw new Error(`unsupported data type: ${t}`)}},c=t=>{switch(t){case 3:return\"int8\";case 2:return\"uint8\";case 9:return\"bool\";case 5:return\"int16\";case 4:return\"uint16\";case 6:return\"int32\";case 12:return\"uint32\";case 1:return\"float32\";case 11:return\"float64\";case 8:return\"string\";case 7:return\"int64\";case 13:return\"uint64\";default:throw new Error(`unsupported data type: ${t}`)}},l=t=>{switch(t){case\"float32\":return Float32Array;case\"uint8\":case\"bool\":return Uint8Array;case\"int8\":return Int8Array;case\"uint16\":return Uint16Array;case\"int16\":return Int16Array;case\"int32\":return Int32Array;case\"float64\":return Float64Array;case\"uint32\":return Uint32Array;case\"int64\":return BigInt64Array;case\"uint64\":return BigUint64Array;default:throw new Error(`unsupported type: ${t}`)}};e.run=(t,e,n,i,p)=>{const f=(0,a.getInstance)(),d=s.get(t);if(!d)throw new Error(\"invalid session id\");const h=d[0],g=d[1],b=d[2],m=e.length,y=i.length;let _=0,v=[];const w=[],x=[];try{[_,v]=(0,r.setRunOptions)(p);for(let t=0;t<m;t++){const e=n[t][0],r=n[t][1],i=n[t][2];let a,s;if(Array.isArray(i)){s=4*i.length,a=f._malloc(s),x.push(a);let t=a/4;for(let e=0;e<i.length;e++){if(\"string\"!=typeof i[e])throw new TypeError(`tensor data at index ${e} is not a string`);f.HEAPU32[t++]=(0,o.allocWasmString)(i[e],x)}}else s=i.byteLength,a=f._malloc(s),x.push(a),f.HEAPU8.set(new Uint8Array(i.buffer,i.byteOffset,s),a);const c=f.stackSave(),l=f.stackAlloc(4*r.length);try{let t=l/4;r.forEach((e=>f.HEAP32[t++]=e));const n=f._OrtCreateTensor(u(e),a,s,l,r.length);if(0===n)throw new Error(\"Can't create a tensor\");w.push(n)}finally{f.stackRestore(c)}}const t=f.stackSave(),a=f.stackAlloc(4*m),s=f.stackAlloc(4*m),d=f.stackAlloc(4*y),T=f.stackAlloc(4*y);try{let n=a/4,r=s/4,o=d/4,u=T/4;for(let t=0;t<m;t++)f.HEAPU32[n++]=w[t],f.HEAPU32[r++]=g[e[t]];for(let t=0;t<y;t++)f.HEAPU32[o++]=0,f.HEAPU32[u++]=b[i[t]];let p=f._OrtRun(h,s,a,m,T,y,d,_);const v=[];if(0===p)for(let t=0;t<y;t++){const e=f.HEAPU32[d/4+t],n=f.stackSave(),r=f.stackAlloc(16);let i,o=0;try{if(p=f._OrtGetTensorData(e,r,r+4,r+8,r+12),0!==p)throw new Error(`Can't access output tensor data. error code = ${p}`);let t=r/4;const a=f.HEAPU32[t++];o=f.HEAPU32[t++];const s=f.HEAPU32[t++],u=f.HEAPU32[t++],d=[];for(let t=0;t<u;t++)d.push(f.HEAPU32[s/4+t]);f._OrtFree(s);const h=0===d.length?1:d.reduce(((t,e)=>t*e));if(i=c(a),\"string\"===i){const t=[];let e=o/4;for(let n=0;n<h;n++){const r=f.HEAPU32[e++],i=n===h-1?void 0:f.HEAPU32[e]-r;t.push(f.UTF8ToString(r,i))}v.push([i,d,t])}else{const t=new(l(i))(h);new Uint8Array(t.buffer,t.byteOffset,t.byteLength).set(f.HEAPU8.subarray(o,o+t.byteLength)),v.push([i,d,t])}}finally{f.stackRestore(n),\"string\"===i&&o&&f._free(o),f._OrtReleaseTensor(e)}}if(0===p)return v;throw new Error(`failed to call OrtRun(). error code = ${p}.`)}finally{f.stackRestore(t)}}finally{w.forEach(f._OrtReleaseTensor),x.forEach(f._free),f._OrtReleaseRunOptions(_),v.forEach(f._free)}},e.endProfiling=t=>{const e=(0,a.getInstance)(),n=s.get(t);if(!n)throw new Error(\"invalid session id\");const r=n[0],i=e._OrtEndProfiling(r);if(0===i)throw new Error(\"Can't get an profile file name\");e._OrtFree(i)},e.extractTransferableBuffers=t=>{const e=[];for(const n of t){const t=n[2];!Array.isArray(t)&&t.buffer&&e.push(t.buffer)}return e}},6361:function(t,e,n){\"use strict\";var r=this&&this.__createBinding||(Object.create?function(t,e,n,r){void 0===r&&(r=n);var i=Object.getOwnPropertyDescriptor(e,n);i&&!(\"get\"in i?!e.__esModule:i.writable||i.configurable)||(i={enumerable:!0,get:function(){return e[n]}}),Object.defineProperty(t,r,i)}:function(t,e,n,r){void 0===r&&(r=n),t[r]=e[n]}),i=this&&this.__setModuleDefault||(Object.create?function(t,e){Object.defineProperty(t,\"default\",{enumerable:!0,value:e})}:function(t,e){t.default=e}),o=this&&this.__importStar||function(t){if(t&&t.__esModule)return t;var e={};if(null!=t)for(var n in t)\"default\"!==n&&Object.prototype.hasOwnProperty.call(t,n)&&r(e,t,n);return i(e,t),e},a=this&&this.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(e,\"__esModule\",{value:!0}),e.dispose=e.getInstance=e.initializeWebAssembly=void 0;const s=o(n(1423)),u=a(n(932)),c=n(3474);let l,p=!1,f=!1,d=!1;const h=(t,e)=>e?t?\"ort-wasm-simd-threaded.wasm\":\"ort-wasm-threaded.wasm\":t?\"ort-wasm-simd.wasm\":\"ort-wasm.wasm\";e.initializeWebAssembly=async t=>{if(p)return Promise.resolve();if(f)throw new Error(\"multiple calls to 'initializeWebAssembly()' detected.\");if(d)throw new Error(\"previous call to 'initializeWebAssembly()' failed.\");f=!0;const e=t.initTimeout,r=t.numThreads,i=t.simd,o=r>1&&(()=>{try{return\"undefined\"!=typeof SharedArrayBuffer&&(\"undefined\"!=typeof MessageChannel&&(new MessageChannel).port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11])))}catch(t){return!1}})(),a=i&&(()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch(t){return!1}})(),g=\"string\"==typeof t.wasmPaths?t.wasmPaths:void 0,b=h(!1,o),m=h(a,o),y=\"object\"==typeof t.wasmPaths?t.wasmPaths[m]:void 0;let _=!1;const v=[];if(e>0&&v.push(new Promise((t=>{setTimeout((()=>{_=!0,t()}),e)}))),v.push(new Promise(((t,e)=>{const r=o?c:u.default,i={locateFile:(t,e)=>o&&t.endsWith(\".worker.js\")&&\"undefined\"!=typeof Blob?URL.createObjectURL(new Blob([n(4154)],{type:\"text/javascript\"})):t===b?null!=y?y:(null!=g?g:e)+m:e+t};if(o)if(\"undefined\"==typeof Blob)i.mainScriptUrlOrBlob=s.join(__dirname,\"ort-wasm-threaded.js\");else{const t=`var ortWasmThreaded=(function(){var _scriptDir;return ${r.toString()}})();`;i.mainScriptUrlOrBlob=new Blob([t],{type:\"text/javascript\"})}r(i).then((e=>{f=!1,p=!0,l=e,t()}),(t=>{f=!1,d=!0,e(t)}))}))),await Promise.race(v),_)throw new Error(`WebAssembly backend initializing failed due to timeout: ${e}ms`)},e.getInstance=()=>{if(p&&l)return l;throw new Error(\"WebAssembly is not initialized yet.\")},e.dispose=()=>{var t;!p||f||d||(f=!0,null===(t=l.PThread)||void 0===t||t.terminateAllThreads(),l=void 0,f=!1,p=!1,d=!0)}},9710:(t,e,n)=>{\"use strict\";n.d(e,{Z:()=>o});var r=n(477),i=n.n(r);function o(){return i()('/*!\\n* ONNX Runtime Web v1.14.0\\n* Copyright (c) Microsoft Corporation. All rights reserved.\\n* Licensed under the MIT License.\\n*/\\n(()=>{var t={474:(t,e,n)=>{var _scriptDir,r=(_scriptDir=(_scriptDir=\"undefined\"!=typeof document&&document.currentScript?document.currentScript.src:void 0)||__filename,function(t){function e(){return k.buffer!=D&&N(k.buffer),P}function r(){return k.buffer!=D&&N(k.buffer),U}function a(){return k.buffer!=D&&N(k.buffer),F}function i(){return k.buffer!=D&&N(k.buffer),I}function o(){return k.buffer!=D&&N(k.buffer),W}var u,s,c;t=t||{},u||(u=void 0!==t?t:{}),u.ready=new Promise((function(t,e){s=t,c=e}));var l,f,p,h,d,y,b=Object.assign({},u),m=\"./this.program\",g=(t,e)=>{throw e},v=\"object\"==typeof window,_=\"function\"==typeof importScripts,w=\"object\"==typeof process&&\"object\"==typeof process.versions&&\"string\"==typeof process.versions.node,O=u.ENVIRONMENT_IS_PTHREAD||!1,A=\"\";function S(t){return u.locateFile?u.locateFile(t,A):A+t}if(w){let e;A=_?n(17).dirname(A)+\"/\":__dirname+\"/\",y=()=>{d||(h=n(147),d=n(17))},l=function(t,e){return y(),t=d.normalize(t),h.readFileSync(t,e?void 0:\"utf8\")},p=t=>((t=l(t,!0)).buffer||(t=new Uint8Array(t)),t),f=(t,e,n)=>{y(),t=d.normalize(t),h.readFile(t,(function(t,r){t?n(t):e(r.buffer)}))},1<process.argv.length&&(m=process.argv[1].replace(/\\\\\\\\/g,\"/\")),process.argv.slice(2),process.on(\"uncaughtException\",(function(t){if(!(t instanceof st))throw t})),process.on(\"unhandledRejection\",(function(t){throw t})),g=(t,e)=>{if(Q())throw process.exitCode=t,e;e instanceof st||x(\"exiting due to exception: \"+e),process.exit(t)},u.inspect=function(){return\"[Emscripten Module object]\"};try{e=n(267)}catch(t){throw console.error(\\'The \"worker_threads\" module is not supported in this node.js build - perhaps a newer version is needed?\\'),t}global.Worker=e.Worker}else(v||_)&&(_?A=self.location.href:\"undefined\"!=typeof document&&document.currentScript&&(A=document.currentScript.src),_scriptDir&&(A=_scriptDir),A=0!==A.indexOf(\"blob:\")?A.substr(0,A.replace(/[?#].*/,\"\").lastIndexOf(\"/\")+1):\"\",w||(l=t=>{var e=new XMLHttpRequest;return e.open(\"GET\",t,!1),e.send(null),e.responseText},_&&(p=t=>{var e=new XMLHttpRequest;return e.open(\"GET\",t,!1),e.responseType=\"arraybuffer\",e.send(null),new Uint8Array(e.response)}),f=(t,e,n)=>{var r=new XMLHttpRequest;r.open(\"GET\",t,!0),r.responseType=\"arraybuffer\",r.onload=()=>{200==r.status||0==r.status&&r.response?e(r.response):n()},r.onerror=n,r.send(null)}));w&&\"undefined\"==typeof performance&&(global.performance=n(74).performance);var T=console.log.bind(console),E=console.warn.bind(console);w&&(y(),T=t=>h.writeSync(1,t+\"\\\\n\"),E=t=>h.writeSync(2,t+\"\\\\n\"));var M,C=u.print||T,x=u.printErr||E;Object.assign(u,b),b=null,u.thisProgram&&(m=u.thisProgram),u.quit&&(g=u.quit),u.wasmBinary&&(M=u.wasmBinary);var R=u.noExitRuntime||!1;\"object\"!=typeof WebAssembly&&at(\"no native wasm support detected\");var k,j,D,P,U,F,I,W,H=!1,z=\"undefined\"!=typeof TextDecoder?new TextDecoder(\"utf8\"):void 0;function L(t,e,n){var r=(e>>>=0)+n;for(n=e;t[n]&&!(n>=r);)++n;if(16<n-e&&t.buffer&&z)return z.decode(t.buffer instanceof SharedArrayBuffer?t.slice(e,n):t.subarray(e,n));for(r=\"\";e<n;){var a=t[e++];if(128&a){var i=63&t[e++];if(192==(224&a))r+=String.fromCharCode((31&a)<<6|i);else{var o=63&t[e++];65536>(a=224==(240&a)?(15&a)<<12|i<<6|o:(7&a)<<18|i<<12|o<<6|63&t[e++])?r+=String.fromCharCode(a):(a-=65536,r+=String.fromCharCode(55296|a>>10,56320|1023&a))}}else r+=String.fromCharCode(a)}return r}function Y(t,e){return(t>>>=0)?L(r(),t,e):\"\"}function B(t,e,n,r){if(!(0<r))return 0;var a=n>>>=0;r=n+r-1;for(var i=0;i<t.length;++i){var o=t.charCodeAt(i);if(55296<=o&&57343>=o&&(o=65536+((1023&o)<<10)|1023&t.charCodeAt(++i)),127>=o){if(n>=r)break;e[n++>>>0]=o}else{if(2047>=o){if(n+1>=r)break;e[n++>>>0]=192|o>>6}else{if(65535>=o){if(n+2>=r)break;e[n++>>>0]=224|o>>12}else{if(n+3>=r)break;e[n++>>>0]=240|o>>18,e[n++>>>0]=128|o>>12&63}e[n++>>>0]=128|o>>6&63}e[n++>>>0]=128|63&o}}return e[n>>>0]=0,n-a}function G(t){for(var e=0,n=0;n<t.length;++n){var r=t.charCodeAt(n);127>=r?e++:2047>=r?e+=2:55296<=r&&57343>=r?(e+=4,++n):e+=3}return e}function N(t){D=t,u.HEAP8=P=new Int8Array(t),u.HEAP16=new Int16Array(t),u.HEAP32=F=new Int32Array(t),u.HEAPU8=U=new Uint8Array(t),u.HEAPU16=new Uint16Array(t),u.HEAPU32=I=new Uint32Array(t),u.HEAPF32=new Float32Array(t),u.HEAPF64=W=new Float64Array(t)}O&&(D=u.buffer);var V=u.INITIAL_MEMORY||16777216;if(O)k=u.wasmMemory,D=u.buffer;else if(u.wasmMemory)k=u.wasmMemory;else if(!((k=new WebAssembly.Memory({initial:V/65536,maximum:65536,shared:!0})).buffer instanceof SharedArrayBuffer))throw x(\"requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag\"),w&&console.log(\"(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and also use a recent version)\"),Error(\"bad memory\");k&&(D=k.buffer),V=D.byteLength,N(D);var q,$=[],X=[],J=[],Z=[];function Q(){return R||!1}function K(){var t=u.preRun.shift();$.unshift(t)}var tt,et=0,nt=null,rt=null;function at(t){throw O?postMessage({cmd:\"onAbort\",arg:t}):u.onAbort&&u.onAbort(t),x(t=\"Aborted(\"+t+\")\"),H=!0,t=new WebAssembly.RuntimeError(t+\". Build with -sASSERTIONS for more info.\"),c(t),t}function it(){return tt.startsWith(\"data:application/octet-stream;base64,\")}function ot(){var t=tt;try{if(t==tt&&M)return new Uint8Array(M);if(p)return p(t);throw\"both async and sync fetching of the wasm failed\"}catch(t){at(t)}}tt=\"ort-wasm-threaded.wasm\",it()||(tt=S(tt));var ut={};function st(t){this.name=\"ExitStatus\",this.message=\"Program terminated with exit(\"+t+\")\",this.status=t}function ct(t){(t=ht.Vb[t])||at(),ht.mc(t)}function lt(t){var e=ht.Cc();if(!e)return 6;ht.ac.push(e),ht.Vb[t.Ub]=e,e.Ub=t.Ub;var n={cmd:\"run\",start_routine:t.Ic,arg:t.zc,pthread_ptr:t.Ub};return e.$b=()=>{n.time=performance.now(),e.postMessage(n,t.Nc)},e.loaded&&(e.$b(),delete e.$b),0}function ft(t){if(O)return qt(1,1,t);Q()||(ht.oc(),u.onExit&&u.onExit(t),H=!0),g(t,new st(t))}function pt(t,e){if(!e&&O)throw bt(t),\"unwind\";Q()||O||(me(),dt(J),be(0),re[1].length&&ae(1,10),re[2].length&&ae(2,10),ht.oc()),ft(t)}var ht={Yb:[],ac:[],qc:[],Vb:{},fc:function(){O&&ht.Ec()},Pc:function(){},Ec:function(){ht.receiveObjectTransfer=ht.Gc,ht.threadInitTLS=ht.pc,ht.setExitStatus=ht.nc,R=!1},nc:function(){},oc:function(){for(var t of Object.values(ht.Vb))ht.mc(t);for(t of ht.Yb)t.terminate();ht.Yb=[]},mc:function(t){var e=t.Ub;delete ht.Vb[e],ht.Yb.push(t),ht.ac.splice(ht.ac.indexOf(t),1),t.Ub=0,Oe(e)},Gc:function(){},pc:function(){ht.qc.forEach((t=>t()))},Fc:function(t,e){t.onmessage=n=>{var r=(n=n.data).cmd;if(t.Ub&&(ht.Bc=t.Ub),n.targetThread&&n.targetThread!=he()){var a=ht.Vb[n.Qc];a?a.postMessage(n,n.transferList):x(\\'Internal error! Worker sent a message \"\\'+r+\\'\" to target pthread \\'+n.targetThread+\", but that thread no longer exists!\")}else\"processProxyingQueue\"===r?Lt(n.queue):\"spawnThread\"===r?lt(n):\"cleanupThread\"===r?ct(n.thread):\"killThread\"===r?(n=n.thread,r=ht.Vb[n],delete ht.Vb[n],r.terminate(),Oe(n),ht.ac.splice(ht.ac.indexOf(r),1),r.Ub=0):\"cancelThread\"===r?ht.Vb[n.thread].postMessage({cmd:\"cancel\"}):\"loaded\"===r?(t.loaded=!0,e&&e(t),t.$b&&(t.$b(),delete t.$b)):\"print\"===r?C(\"Thread \"+n.threadId+\": \"+n.text):\"printErr\"===r?x(\"Thread \"+n.threadId+\": \"+n.text):\"alert\"===r?alert(\"Thread \"+n.threadId+\": \"+n.text):\"setimmediate\"===n.target?t.postMessage(n):\"onAbort\"===r?u.onAbort&&u.onAbort(n.arg):r&&x(\"worker sent an unknown command \"+r);ht.Bc=void 0},t.onerror=t=>{throw x(\"worker sent an error! \"+t.filename+\":\"+t.lineno+\": \"+t.message),t},w&&(t.on(\"message\",(function(e){t.onmessage({data:e})})),t.on(\"error\",(function(e){t.onerror(e)})),t.on(\"detachedExit\",(function(){}))),t.postMessage({cmd:\"load\",urlOrBlob:u.mainScriptUrlOrBlob||_scriptDir,wasmMemory:k,wasmModule:j})},yc:function(){var t=S(\"ort-wasm-threaded.worker.js\");ht.Yb.push(new Worker(t))},Cc:function(){return 0==ht.Yb.length&&(ht.yc(),ht.Fc(ht.Yb[0])),ht.Yb.pop()}};function dt(t){for(;0<t.length;)t.shift()(u)}function yt(t){var e=Ee();return t=t(),Me(e),t}function bt(t){if(O)return qt(2,0,t);try{pt(t)}catch(t){t instanceof st||\"unwind\"==t||g(1,t)}}u.PThread=ht,u.establishStackSpace=function(){var t=he(),e=a()[t+44>>2>>>0];t=a()[t+48>>2>>>0],Te(e,e-t),Me(e)};var mt=[];function gt(t){var e=mt[t];return e||(t>=mt.length&&(mt.length=t+1),mt[t]=e=q.get(t)),e}u.invokeEntryPoint=function(t,e){t=gt(t)(e),Q()?ht.nc(t):Ae(t)};var vt,_t,wt=[],Ot=0,At=0;function St(t){this.Zb=t,this.Sb=t-24,this.xc=function(t){i()[this.Sb+4>>2>>>0]=t},this.bc=function(){return i()[this.Sb+4>>2>>>0]},this.wc=function(t){i()[this.Sb+8>>2>>>0]=t},this.Dc=function(){return i()[this.Sb+8>>2>>>0]},this.rc=function(){a()[this.Sb>>2>>>0]=0},this.hc=function(t){t=t?1:0,e()[this.Sb+12>>0>>>0]=t},this.uc=function(){return 0!=e()[this.Sb+12>>0>>>0]},this.ic=function(t){t=t?1:0,e()[this.Sb+13>>0>>>0]=t},this.kc=function(){return 0!=e()[this.Sb+13>>0>>>0]},this.fc=function(t,e){this.cc(0),this.xc(t),this.wc(e),this.rc(),this.hc(!1),this.ic(!1)},this.sc=function(){Atomics.add(a(),this.Sb>>2,1)},this.Hc=function(){return 1===Atomics.sub(a(),this.Sb>>2,1)},this.cc=function(t){i()[this.Sb+16>>2>>>0]=t},this.tc=function(){return i()[this.Sb+16>>2>>>0]},this.vc=function(){if(Re(this.bc()))return i()[this.Zb>>2>>>0];var t=this.tc();return 0!==t?t:this.Zb}}function Tt(t){return ye(new St(t).Sb)}function Et(t,e,n,r){return O?qt(3,1,t,e,n,r):Mt(t,e,n,r)}function Mt(t,e,n,r){if(\"undefined\"==typeof SharedArrayBuffer)return x(\"Current environment does not support SharedArrayBuffer, pthreads are not available!\"),6;var a=[];return O&&0===a.length?Et(t,e,n,r):(t={Ic:n,Ub:t,zc:r,Nc:a},O?(t.Oc=\"spawnThread\",postMessage(t,a),0):lt(t))}function Ct(t,e,n){return O?qt(4,1,t,e,n):0}function xt(t,e){if(O)return qt(5,1,t,e)}function Rt(t,e){if(O)return qt(6,1,t,e)}function kt(t,e,n){if(O)return qt(7,1,t,e,n)}function jt(t,e,n){return O?qt(8,1,t,e,n):0}function Dt(t,e){if(O)return qt(9,1,t,e)}function Pt(t,e,n){if(O)return qt(10,1,t,e,n)}function Ut(t,e,n,r){if(O)return qt(11,1,t,e,n,r)}function Ft(t,e,n,r){if(O)return qt(12,1,t,e,n,r)}function It(t,e,n,r){if(O)return qt(13,1,t,e,n,r)}function Wt(t){if(O)return qt(14,1,t)}function Ht(t,e){if(O)return qt(15,1,t,e)}function zt(t,e,n){if(O)return qt(16,1,t,e,n)}function Lt(t){Atomics.store(a(),t>>2,1),he()&&we(t),Atomics.compareExchange(a(),t>>2,1,0)}function Yt(t){return i()[t>>>2]+4294967296*a()[t+4>>>2]}function Bt(t,e,n,r,a,i){return O?qt(17,1,t,e,n,r,a,i):-52}function Gt(t,e,n,r,a,i){if(O)return qt(18,1,t,e,n,r,a,i)}function Nt(t){var n=G(t)+1,r=de(n);return r&&B(t,e(),r,n),r}function Vt(t,e,n){function r(t){return(t=t.toTimeString().match(/\\\\(([A-Za-z ]+)\\\\)$/))?t[1]:\"GMT\"}if(O)return qt(19,1,t,e,n);var o=(new Date).getFullYear(),u=new Date(o,0,1),s=new Date(o,6,1);o=u.getTimezoneOffset();var c=s.getTimezoneOffset(),l=Math.max(o,c);a()[t>>2>>>0]=60*l,a()[e>>2>>>0]=Number(o!=c),t=r(u),e=r(s),t=Nt(t),e=Nt(e),c<o?(i()[n>>2>>>0]=t,i()[n+4>>2>>>0]=e):(i()[n>>2>>>0]=e,i()[n+4>>2>>>0]=t)}function qt(t,e){var n=arguments.length-2,r=arguments;return yt((()=>{for(var a=Ce(8*n),i=a>>3,u=0;u<n;u++){var s=r[2+u];o()[i+u>>>0]=s}return _e(t,n,a,e)}))}u.executeNotifiedProxyingQueue=Lt,_t=w?()=>{var t=process.hrtime();return 1e3*t[0]+t[1]/1e6}:O?()=>performance.now()-u.__performance_now_clock_drift:()=>performance.now();var $t,Xt=[],Jt={};function Zt(){if(!$t){var t,e={USER:\"web_user\",LOGNAME:\"web_user\",PATH:\"/\",PWD:\"/\",HOME:\"/home/web_user\",LANG:(\"object\"==typeof navigator&&navigator.languages&&navigator.languages[0]||\"C\").replace(\"-\",\"_\")+\".UTF-8\",_:m||\"./this.program\"};for(t in Jt)void 0===Jt[t]?delete e[t]:e[t]=Jt[t];var n=[];for(t in e)n.push(t+\"=\"+e[t]);$t=n}return $t}function Qt(t,n){if(O)return qt(20,1,t,n);var r=0;return Zt().forEach((function(a,o){var u=n+r;for(o=i()[t+4*o>>2>>>0]=u,u=0;u<a.length;++u)e()[o++>>0>>>0]=a.charCodeAt(u);e()[o>>0>>>0]=0,r+=a.length+1})),0}function Kt(t,e){if(O)return qt(21,1,t,e);var n=Zt();i()[t>>2>>>0]=n.length;var r=0;return n.forEach((function(t){r+=t.length+1})),i()[e>>2>>>0]=r,0}function te(t){return O?qt(22,1,t):52}function ee(t,e,n,r){return O?qt(23,1,t,e,n,r):52}function ne(t,e,n,r,a){return O?qt(24,1,t,e,n,r,a):70}var re=[null,[],[]];function ae(t,e){var n=re[t];0===e||10===e?((1===t?C:x)(L(n,0)),n.length=0):n.push(e)}function ie(t,e,n,a){if(O)return qt(25,1,t,e,n,a);for(var o=0,u=0;u<n;u++){var s=i()[e>>2>>>0],c=i()[e+4>>2>>>0];e+=8;for(var l=0;l<c;l++)ae(t,r()[s+l>>>0]);o+=c}return i()[a>>2>>>0]=o,0}var oe=0;function ue(t){return 0==t%4&&(0!=t%100||0==t%400)}var se=[31,29,31,30,31,30,31,31,30,31,30,31],ce=[31,28,31,30,31,30,31,31,30,31,30,31];function le(t,n,r,i){function o(t,e,n){for(t=\"number\"==typeof t?t.toString():t||\"\";t.length<e;)t=n[0]+t;return t}function u(t,e){return o(t,e,\"0\")}function s(t,e){function n(t){return 0>t?-1:0<t?1:0}var r;return 0===(r=n(t.getFullYear()-e.getFullYear()))&&0===(r=n(t.getMonth()-e.getMonth()))&&(r=n(t.getDate()-e.getDate())),r}function c(t){switch(t.getDay()){case 0:return new Date(t.getFullYear()-1,11,29);case 1:return t;case 2:return new Date(t.getFullYear(),0,3);case 3:return new Date(t.getFullYear(),0,2);case 4:return new Date(t.getFullYear(),0,1);case 5:return new Date(t.getFullYear()-1,11,31);case 6:return new Date(t.getFullYear()-1,11,30)}}function l(t){var e=t.Wb;for(t=new Date(new Date(t.Xb+1900,0,1).getTime());0<e;){var n=t.getMonth(),r=(ue(t.getFullYear())?se:ce)[n];if(!(e>r-t.getDate())){t.setDate(t.getDate()+e);break}e-=r-t.getDate()+1,t.setDate(1),11>n?t.setMonth(n+1):(t.setMonth(0),t.setFullYear(t.getFullYear()+1))}return n=new Date(t.getFullYear()+1,0,4),e=c(new Date(t.getFullYear(),0,4)),n=c(n),0>=s(e,t)?0>=s(n,t)?t.getFullYear()+1:t.getFullYear():t.getFullYear()-1}var f=a()[i+40>>2>>>0];for(var p in i={Lc:a()[i>>2>>>0],Kc:a()[i+4>>2>>>0],dc:a()[i+8>>2>>>0],jc:a()[i+12>>2>>>0],ec:a()[i+16>>2>>>0],Xb:a()[i+20>>2>>>0],Tb:a()[i+24>>2>>>0],Wb:a()[i+28>>2>>>0],Rc:a()[i+32>>2>>>0],Jc:a()[i+36>>2>>>0],Mc:f?Y(f):\"\"},r=Y(r),f={\"%c\":\"%a %b %d %H:%M:%S %Y\",\"%D\":\"%m/%d/%y\",\"%F\":\"%Y-%m-%d\",\"%h\":\"%b\",\"%r\":\"%I:%M:%S %p\",\"%R\":\"%H:%M\",\"%T\":\"%H:%M:%S\",\"%x\":\"%m/%d/%y\",\"%X\":\"%H:%M:%S\",\"%Ec\":\"%c\",\"%EC\":\"%C\",\"%Ex\":\"%m/%d/%y\",\"%EX\":\"%H:%M:%S\",\"%Ey\":\"%y\",\"%EY\":\"%Y\",\"%Od\":\"%d\",\"%Oe\":\"%e\",\"%OH\":\"%H\",\"%OI\":\"%I\",\"%Om\":\"%m\",\"%OM\":\"%M\",\"%OS\":\"%S\",\"%Ou\":\"%u\",\"%OU\":\"%U\",\"%OV\":\"%V\",\"%Ow\":\"%w\",\"%OW\":\"%W\",\"%Oy\":\"%y\"})r=r.replace(new RegExp(p,\"g\"),f[p]);var h=\"Sunday Monday Tuesday Wednesday Thursday Friday Saturday\".split(\" \"),d=\"January February March April May June July August September October November December\".split(\" \");for(p in f={\"%a\":function(t){return h[t.Tb].substring(0,3)},\"%A\":function(t){return h[t.Tb]},\"%b\":function(t){return d[t.ec].substring(0,3)},\"%B\":function(t){return d[t.ec]},\"%C\":function(t){return u((t.Xb+1900)/100|0,2)},\"%d\":function(t){return u(t.jc,2)},\"%e\":function(t){return o(t.jc,2,\" \")},\"%g\":function(t){return l(t).toString().substring(2)},\"%G\":function(t){return l(t)},\"%H\":function(t){return u(t.dc,2)},\"%I\":function(t){return 0==(t=t.dc)?t=12:12<t&&(t-=12),u(t,2)},\"%j\":function(t){for(var e=0,n=0;n<=t.ec-1;e+=(ue(t.Xb+1900)?se:ce)[n++]);return u(t.jc+e,3)},\"%m\":function(t){return u(t.ec+1,2)},\"%M\":function(t){return u(t.Kc,2)},\"%n\":function(){return\"\\\\n\"},\"%p\":function(t){return 0<=t.dc&&12>t.dc?\"AM\":\"PM\"},\"%S\":function(t){return u(t.Lc,2)},\"%t\":function(){return\"\\\\t\"},\"%u\":function(t){return t.Tb||7},\"%U\":function(t){return u(Math.floor((t.Wb+7-t.Tb)/7),2)},\"%V\":function(t){var e=Math.floor((t.Wb+7-(t.Tb+6)%7)/7);if(2>=(t.Tb+371-t.Wb-2)%7&&e++,e)53==e&&(4==(n=(t.Tb+371-t.Wb)%7)||3==n&&ue(t.Xb)||(e=1));else{e=52;var n=(t.Tb+7-t.Wb-1)%7;(4==n||5==n&&ue(t.Xb%400-1))&&e++}return u(e,2)},\"%w\":function(t){return t.Tb},\"%W\":function(t){return u(Math.floor((t.Wb+7-(t.Tb+6)%7)/7),2)},\"%y\":function(t){return(t.Xb+1900).toString().substring(2)},\"%Y\":function(t){return t.Xb+1900},\"%z\":function(t){var e=0<=(t=t.Jc);return t=Math.abs(t)/60,(e?\"+\":\"-\")+String(\"0000\"+(t/60*100+t%60)).slice(-4)},\"%Z\":function(t){return t.Mc},\"%%\":function(){return\"%\"}},r=r.replace(/%%/g,\"\\\\0\\\\0\"),f)r.includes(p)&&(r=r.replace(new RegExp(p,\"g\"),f[p](i)));return p=function(t){var e=Array(G(t)+1);return B(t,e,0,e.length),e}(r=r.replace(/\\\\0\\\\0/g,\"%\")),p.length>n?0:(function(t,n){e().set(t,n>>>0)}(p,t),p.length-1)}ht.fc();var fe=[null,ft,bt,Et,Ct,xt,Rt,kt,jt,Dt,Pt,Ut,Ft,It,Wt,Ht,zt,Bt,Gt,Vt,Qt,Kt,te,ee,ne,ie],pe={b:function(t){return de(t+24)+24},n:function(t){return(t=new St(t)).uc()||(t.hc(!0),Ot--),t.ic(!1),wt.push(t),t.sc(),t.vc()},ma:function(t){throw x(\"Unexpected exception thrown, this is not properly supported - aborting\"),H=!0,t},x:function(){Se(0);var t=wt.pop();if(t.Hc()&&!t.kc()){var e=t.Dc();e&&gt(e)(t.Zb),Tt(t.Zb)}At=0},e:function(){var t=At;if(!t)return oe=0;var e=new St(t);e.cc(t);var n=e.bc();if(!n)return oe=0,t;for(var r=Array.prototype.slice.call(arguments),a=0;a<r.length;a++){var i=r[a];if(0===i||i===n)break;if(xe(i,n,e.Sb+16))return oe=i,t}return oe=n,t},l:function(){var t=At;if(!t)return oe=0;var e=new St(t);e.cc(t);var n=e.bc();if(!n)return oe=0,t;for(var r=Array.prototype.slice.call(arguments),a=0;a<r.length;a++){var i=r[a];if(0===i||i===n)break;if(xe(i,n,e.Sb+16))return oe=i,t}return oe=n,t},h:function(){var t=At;if(!t)return oe=0;var e=new St(t);e.cc(t);var n=e.bc();if(!n)return oe=0,t;for(var r=Array.prototype.slice.call(arguments),a=0;a<r.length;a++){var i=r[a];if(0===i||i===n)break;if(xe(i,n,e.Sb+16))return oe=i,t}return oe=n,t},t:Tt,M:function(){var t=wt.pop();t||at(\"no exception to throw\");var e=t.Zb;throw t.kc()||(wt.push(t),t.ic(!0),t.hc(!1),Ot++),At=e,e},c:function(t,e,n){throw new St(t).fc(e,n),At=t,Ot++,t},pa:function(){return Ot},Fa:function(t){ge(t,!_,1,!v),ht.pc()},T:function(t){O?postMessage({cmd:\"cleanupThread\",thread:t}):ct(t)},xa:Mt,j:function(t){throw At||(At=t),t},H:Ct,Ma:xt,ua:Rt,wa:kt,oa:jt,Ka:Dt,Ca:Pt,Ja:Ut,V:Ft,va:It,sa:Wt,La:Ht,ta:zt,Ta:function(){},X:function(){at(\"To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking\")},Ua:function(){at(\"To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking\")},W:function(){return Date.now()},ya:function(){return 2097152},Oa:function(){return!0},za:function(t,e,n,r){if(t==e)setTimeout((()=>Lt(r)));else if(O)postMessage({targetThread:t,cmd:\"processProxyingQueue\",queue:r});else{if(!(t=ht.Vb[t]))return;t.postMessage({cmd:\"processProxyingQueue\",queue:r})}return 1},Ea:function(){return-1},Pa:function(t,e){t=new Date(1e3*Yt(t)),a()[e>>2>>>0]=t.getUTCSeconds(),a()[e+4>>2>>>0]=t.getUTCMinutes(),a()[e+8>>2>>>0]=t.getUTCHours(),a()[e+12>>2>>>0]=t.getUTCDate(),a()[e+16>>2>>>0]=t.getUTCMonth(),a()[e+20>>2>>>0]=t.getUTCFullYear()-1900,a()[e+24>>2>>>0]=t.getUTCDay(),t=(t.getTime()-Date.UTC(t.getUTCFullYear(),0,1,0,0,0,0))/864e5|0,a()[e+28>>2>>>0]=t},Qa:function(t,e){t=new Date(1e3*Yt(t)),a()[e>>2>>>0]=t.getSeconds(),a()[e+4>>2>>>0]=t.getMinutes(),a()[e+8>>2>>>0]=t.getHours(),a()[e+12>>2>>>0]=t.getDate(),a()[e+16>>2>>>0]=t.getMonth(),a()[e+20>>2>>>0]=t.getFullYear()-1900,a()[e+24>>2>>>0]=t.getDay();var n=new Date(t.getFullYear(),0,1),r=(t.getTime()-n.getTime())/864e5|0;a()[e+28>>2>>>0]=r,a()[e+36>>2>>>0]=-60*t.getTimezoneOffset(),r=new Date(t.getFullYear(),6,1).getTimezoneOffset(),t=0|(r!=(n=n.getTimezoneOffset())&&t.getTimezoneOffset()==Math.min(n,r)),a()[e+32>>2>>>0]=t},Ra:function(t){var e=new Date(a()[t+20>>2>>>0]+1900,a()[t+16>>2>>>0],a()[t+12>>2>>>0],a()[t+8>>2>>>0],a()[t+4>>2>>>0],a()[t>>2>>>0],0),n=a()[t+32>>2>>>0],r=e.getTimezoneOffset(),i=new Date(e.getFullYear(),0,1),o=new Date(e.getFullYear(),6,1).getTimezoneOffset(),u=i.getTimezoneOffset(),s=Math.min(u,o);return 0>n?a()[t+32>>2>>>0]=Number(o!=u&&s==r):0<n!=(s==r)&&(o=Math.max(u,o),e.setTime(e.getTime()+6e4*((0<n?s:o)-r))),a()[t+24>>2>>>0]=e.getDay(),n=(e.getTime()-i.getTime())/864e5|0,a()[t+28>>2>>>0]=n,a()[t>>2>>>0]=e.getSeconds(),a()[t+4>>2>>>0]=e.getMinutes(),a()[t+8>>2>>>0]=e.getHours(),a()[t+12>>2>>>0]=e.getDate(),a()[t+16>>2>>>0]=e.getMonth(),e.getTime()/1e3|0},Aa:Bt,Ba:Gt,Sa:function t(e,n,r){t.Ac||(t.Ac=!0,Vt(e,n,r))},y:function(){at(\"\")},U:function(){if(!w&&!_){var t=\"Blocking on the main thread is very dangerous, see https://emscripten.org/docs/porting/pthreads.html#blocking-on-the-main-browser-thread\";vt||(vt={}),vt[t]||(vt[t]=1,w&&(t=\"warning: \"+t),x(t))}},ra:function(){return 4294901760},B:_t,Ia:function(t,e,n){r().copyWithin(t>>>0,e>>>0,e+n>>>0)},F:function(){return w?n(37).cpus().length:navigator.hardwareConcurrency},Da:function(t,e,n){Xt.length=e,n>>=3;for(var r=0;r<e;r++)Xt[r]=o()[n+r>>>0];return(0>t?ut[-t-1]:fe[t]).apply(null,Xt)},qa:function(t){var e=r().length;if((t>>>=0)<=e||4294901760<t)return!1;for(var n=1;4>=n;n*=2){var a=e*(1+.2/n);a=Math.min(a,t+100663296);var i=Math;a=Math.max(t,a),i=i.min.call(i,4294901760,a+(65536-a%65536)%65536);t:{try{k.grow(i-D.byteLength+65535>>>16),N(k.buffer);var o=1;break t}catch(t){}o=void 0}if(o)return!0}return!1},Na:function(){throw\"unwind\"},Ga:Qt,Ha:Kt,J:pt,I:te,S:ee,ga:ne,R:ie,d:function(){return oe},na:function t(r,a){t.lc||(t.lc=function(){if(\"object\"==typeof crypto&&\"function\"==typeof crypto.getRandomValues){var t=new Uint8Array(1);return()=>(crypto.getRandomValues(t),t[0])}if(w)try{var e=n(113);return()=>e.randomBytes(1)[0]}catch(t){}return()=>at(\"randomDevice\")}());for(var i=0;i<a;i++)e()[r+i>>0>>>0]=t.lc();return 0},ia:function(t,e,n){var r=Ee();try{return gt(t)(e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},ja:function(t,e,n){var r=Ee();try{return gt(t)(e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},K:function(t){var e=Ee();try{return gt(t)()}catch(t){if(Me(e),t!==t+0)throw t;Se(1,0)}},f:function(t,e){var n=Ee();try{return gt(t)(e)}catch(t){if(Me(n),t!==t+0)throw t;Se(1,0)}},P:function(t,e,n){var r=Ee();try{return gt(t)(e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},Q:function(t,e,n){var r=Ee();try{return gt(t)(e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},k:function(t,e,n){var r=Ee();try{return gt(t)(e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},p:function(t,e,n,r){var a=Ee();try{return gt(t)(e,n,r)}catch(t){if(Me(a),t!==t+0)throw t;Se(1,0)}},q:function(t,e,n,r,a){var i=Ee();try{return gt(t)(e,n,r,a)}catch(t){if(Me(i),t!==t+0)throw t;Se(1,0)}},N:function(t,e,n,r,a,i){var o=Ee();try{return gt(t)(e,n,r,a,i)}catch(t){if(Me(o),t!==t+0)throw t;Se(1,0)}},s:function(t,e,n,r,a,i){var o=Ee();try{return gt(t)(e,n,r,a,i)}catch(t){if(Me(o),t!==t+0)throw t;Se(1,0)}},w:function(t,e,n,r,a,i,o){var u=Ee();try{return gt(t)(e,n,r,a,i,o)}catch(t){if(Me(u),t!==t+0)throw t;Se(1,0)}},L:function(t,e,n,r,a,i,o,u){var s=Ee();try{return gt(t)(e,n,r,a,i,o,u)}catch(t){if(Me(s),t!==t+0)throw t;Se(1,0)}},E:function(t,e,n,r,a,i,o,u,s,c,l,f){var p=Ee();try{return gt(t)(e,n,r,a,i,o,u,s,c,l,f)}catch(t){if(Me(p),t!==t+0)throw t;Se(1,0)}},aa:function(t,e,n,r,a,i,o,u){var s=Ee();try{return He(t,e,n,r,a,i,o,u)}catch(t){if(Me(s),t!==t+0)throw t;Se(1,0)}},_:function(t,e,n,r,a,i,o){var u=Ee();try{return je(t,e,n,r,a,i,o)}catch(t){if(Me(u),t!==t+0)throw t;Se(1,0)}},Z:function(t,e,n,r,a){var i=Ee();try{return ze(t,e,n,r,a)}catch(t){if(Me(i),t!==t+0)throw t;Se(1,0)}},ca:function(t,e,n,r){var a=Ee();try{return Ie(t,e,n,r)}catch(t){if(Me(a),t!==t+0)throw t;Se(1,0)}},$:function(t){var e=Ee();try{return ke(t)}catch(t){if(Me(e),t!==t+0)throw t;Se(1,0)}},ba:function(t,e){var n=Ee();try{return We(t,e)}catch(t){if(Me(n),t!==t+0)throw t;Se(1,0)}},Y:function(t,e,n){var r=Ee();try{return De(t,e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},g:function(t){var e=Ee();try{gt(t)()}catch(t){if(Me(e),t!==t+0)throw t;Se(1,0)}},r:function(t,e){var n=Ee();try{gt(t)(e)}catch(t){if(Me(n),t!==t+0)throw t;Se(1,0)}},i:function(t,e,n){var r=Ee();try{gt(t)(e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},ha:function(t,e,n,r){var a=Ee();try{gt(t)(e,n,r)}catch(t){if(Me(a),t!==t+0)throw t;Se(1,0)}},m:function(t,e,n,r){var a=Ee();try{gt(t)(e,n,r)}catch(t){if(Me(a),t!==t+0)throw t;Se(1,0)}},v:function(t,e,n,r,a){var i=Ee();try{gt(t)(e,n,r,a)}catch(t){if(Me(i),t!==t+0)throw t;Se(1,0)}},u:function(t,e,n,r,a,i){var o=Ee();try{gt(t)(e,n,r,a,i)}catch(t){if(Me(o),t!==t+0)throw t;Se(1,0)}},O:function(t,e,n,r,a,i,o){var u=Ee();try{gt(t)(e,n,r,a,i,o)}catch(t){if(Me(u),t!==t+0)throw t;Se(1,0)}},A:function(t,e,n,r,a,i,o,u){var s=Ee();try{gt(t)(e,n,r,a,i,o,u)}catch(t){if(Me(s),t!==t+0)throw t;Se(1,0)}},ka:function(t,e,n,r,a,i,o,u,s){var c=Ee();try{gt(t)(e,n,r,a,i,o,u,s)}catch(t){if(Me(c),t!==t+0)throw t;Se(1,0)}},C:function(t,e,n,r,a,i,o,u,s,c,l){var f=Ee();try{gt(t)(e,n,r,a,i,o,u,s,c,l)}catch(t){if(Me(f),t!==t+0)throw t;Se(1,0)}},D:function(t,e,n,r,a,i,o,u,s,c,l,f,p,h,d,y){var b=Ee();try{gt(t)(e,n,r,a,i,o,u,s,c,l,f,p,h,d,y)}catch(t){if(Me(b),t!==t+0)throw t;Se(1,0)}},fa:function(t,e,n,r,a,i,o,u){var s=Ee();try{Pe(t,e,n,r,a,i,o,u)}catch(t){if(Me(s),t!==t+0)throw t;Se(1,0)}},da:function(t,e,n,r,a,i,o,u,s,c,l,f){var p=Ee();try{Fe(t,e,n,r,a,i,o,u,s,c,l,f)}catch(t){if(Me(p),t!==t+0)throw t;Se(1,0)}},ea:function(t,e,n,r,a,i){var o=Ee();try{Ue(t,e,n,r,a,i)}catch(t){if(Me(o),t!==t+0)throw t;Se(1,0)}},o:function(t){return t},a:k||u.wasmMemory,G:function(t){oe=t},la:le,z:function(t,e,n,r){return le(t,e,n,r)}};!function(){function t(t,e){u.asm=t.exports,ht.qc.push(u.asm.sb),q=u.asm.ub,X.unshift(u.asm.Va),j=e,O||(et--,u.monitorRunDependencies&&u.monitorRunDependencies(et),0==et&&(null!==nt&&(clearInterval(nt),nt=null),rt&&(t=rt,rt=null,t())))}function e(e){t(e.instance,e.module)}function n(t){return function(){if(!M&&(v||_)){if(\"function\"==typeof fetch&&!tt.startsWith(\"file://\"))return fetch(tt,{credentials:\"same-origin\"}).then((function(t){if(!t.ok)throw\"failed to load wasm binary file at \\'\"+tt+\"\\'\";return t.arrayBuffer()})).catch((function(){return ot()}));if(f)return new Promise((function(t,e){f(tt,(function(e){t(new Uint8Array(e))}),e)}))}return Promise.resolve().then((function(){return ot()}))}().then((function(t){return WebAssembly.instantiate(t,r)})).then((function(t){return t})).then(t,(function(t){x(\"failed to asynchronously prepare wasm: \"+t),at(t)}))}var r={a:pe};if(O||(et++,u.monitorRunDependencies&&u.monitorRunDependencies(et)),u.instantiateWasm)try{return u.instantiateWasm(r,t)}catch(t){return x(\"Module.instantiateWasm callback failed with error: \"+t),!1}(M||\"function\"!=typeof WebAssembly.instantiateStreaming||it()||tt.startsWith(\"file://\")||w||\"function\"!=typeof fetch?n(e):fetch(tt,{credentials:\"same-origin\"}).then((function(t){return WebAssembly.instantiateStreaming(t,r).then(e,(function(t){return x(\"wasm streaming compile failed: \"+t),x(\"falling back to ArrayBuffer instantiation\"),n(e)}))}))).catch(c)}(),u.___wasm_call_ctors=function(){return(u.___wasm_call_ctors=u.asm.Va).apply(null,arguments)},u._OrtInit=function(){return(u._OrtInit=u.asm.Wa).apply(null,arguments)},u._OrtCreateSessionOptions=function(){return(u._OrtCreateSessionOptions=u.asm.Xa).apply(null,arguments)},u._OrtAppendExecutionProvider=function(){return(u._OrtAppendExecutionProvider=u.asm.Ya).apply(null,arguments)},u._OrtAddSessionConfigEntry=function(){return(u._OrtAddSessionConfigEntry=u.asm.Za).apply(null,arguments)},u._OrtReleaseSessionOptions=function(){return(u._OrtReleaseSessionOptions=u.asm._a).apply(null,arguments)},u._OrtCreateSession=function(){return(u._OrtCreateSession=u.asm.$a).apply(null,arguments)},u._OrtReleaseSession=function(){return(u._OrtReleaseSession=u.asm.ab).apply(null,arguments)},u._OrtGetInputCount=function(){return(u._OrtGetInputCount=u.asm.bb).apply(null,arguments)},u._OrtGetOutputCount=function(){return(u._OrtGetOutputCount=u.asm.cb).apply(null,arguments)},u._OrtGetInputName=function(){return(u._OrtGetInputName=u.asm.db).apply(null,arguments)},u._OrtGetOutputName=function(){return(u._OrtGetOutputName=u.asm.eb).apply(null,arguments)},u._OrtFree=function(){return(u._OrtFree=u.asm.fb).apply(null,arguments)},u._OrtCreateTensor=function(){return(u._OrtCreateTensor=u.asm.gb).apply(null,arguments)},u._OrtGetTensorData=function(){return(u._OrtGetTensorData=u.asm.hb).apply(null,arguments)},u._OrtReleaseTensor=function(){return(u._OrtReleaseTensor=u.asm.ib).apply(null,arguments)},u._OrtCreateRunOptions=function(){return(u._OrtCreateRunOptions=u.asm.jb).apply(null,arguments)},u._OrtAddRunConfigEntry=function(){return(u._OrtAddRunConfigEntry=u.asm.kb).apply(null,arguments)},u._OrtReleaseRunOptions=function(){return(u._OrtReleaseRunOptions=u.asm.lb).apply(null,arguments)},u._OrtRun=function(){return(u._OrtRun=u.asm.mb).apply(null,arguments)},u._OrtEndProfiling=function(){return(u._OrtEndProfiling=u.asm.nb).apply(null,arguments)};var he=u._pthread_self=function(){return(he=u._pthread_self=u.asm.ob).apply(null,arguments)},de=u._malloc=function(){return(de=u._malloc=u.asm.pb).apply(null,arguments)},ye=u._free=function(){return(ye=u._free=u.asm.qb).apply(null,arguments)},be=u._fflush=function(){return(be=u._fflush=u.asm.rb).apply(null,arguments)};u.__emscripten_tls_init=function(){return(u.__emscripten_tls_init=u.asm.sb).apply(null,arguments)};var me=u.___funcs_on_exit=function(){return(me=u.___funcs_on_exit=u.asm.tb).apply(null,arguments)},ge=u.__emscripten_thread_init=function(){return(ge=u.__emscripten_thread_init=u.asm.vb).apply(null,arguments)};u.__emscripten_thread_crashed=function(){return(u.__emscripten_thread_crashed=u.asm.wb).apply(null,arguments)};var ve,_e=u._emscripten_run_in_main_runtime_thread_js=function(){return(_e=u._emscripten_run_in_main_runtime_thread_js=u.asm.xb).apply(null,arguments)},we=u.__emscripten_proxy_execute_task_queue=function(){return(we=u.__emscripten_proxy_execute_task_queue=u.asm.yb).apply(null,arguments)},Oe=u.__emscripten_thread_free_data=function(){return(Oe=u.__emscripten_thread_free_data=u.asm.zb).apply(null,arguments)},Ae=u.__emscripten_thread_exit=function(){return(Ae=u.__emscripten_thread_exit=u.asm.Ab).apply(null,arguments)},Se=u._setThrew=function(){return(Se=u._setThrew=u.asm.Bb).apply(null,arguments)},Te=u._emscripten_stack_set_limits=function(){return(Te=u._emscripten_stack_set_limits=u.asm.Cb).apply(null,arguments)},Ee=u.stackSave=function(){return(Ee=u.stackSave=u.asm.Db).apply(null,arguments)},Me=u.stackRestore=function(){return(Me=u.stackRestore=u.asm.Eb).apply(null,arguments)},Ce=u.stackAlloc=function(){return(Ce=u.stackAlloc=u.asm.Fb).apply(null,arguments)},xe=u.___cxa_can_catch=function(){return(xe=u.___cxa_can_catch=u.asm.Gb).apply(null,arguments)},Re=u.___cxa_is_pointer_type=function(){return(Re=u.___cxa_is_pointer_type=u.asm.Hb).apply(null,arguments)},ke=u.dynCall_j=function(){return(ke=u.dynCall_j=u.asm.Ib).apply(null,arguments)},je=u.dynCall_iiiiij=function(){return(je=u.dynCall_iiiiij=u.asm.Jb).apply(null,arguments)},De=u.dynCall_jii=function(){return(De=u.dynCall_jii=u.asm.Kb).apply(null,arguments)},Pe=u.dynCall_viiiiij=function(){return(Pe=u.dynCall_viiiiij=u.asm.Lb).apply(null,arguments)},Ue=u.dynCall_vjji=function(){return(Ue=u.dynCall_vjji=u.asm.Mb).apply(null,arguments)},Fe=u.dynCall_viiijjjii=function(){return(Fe=u.dynCall_viiijjjii=u.asm.Nb).apply(null,arguments)},Ie=u.dynCall_iij=function(){return(Ie=u.dynCall_iij=u.asm.Ob).apply(null,arguments)},We=u.dynCall_ji=function(){return(We=u.dynCall_ji=u.asm.Pb).apply(null,arguments)},He=u.dynCall_iiiiiij=function(){return(He=u.dynCall_iiiiiij=u.asm.Qb).apply(null,arguments)},ze=u.dynCall_iiij=function(){return(ze=u.dynCall_iiij=u.asm.Rb).apply(null,arguments)};function Le(){function t(){if(!ve&&(ve=!0,u.calledRun=!0,!H)&&(O||dt(X),s(u),u.onRuntimeInitialized&&u.onRuntimeInitialized(),!O)){if(u.postRun)for(\"function\"==typeof u.postRun&&(u.postRun=[u.postRun]);u.postRun.length;){var t=u.postRun.shift();Z.unshift(t)}dt(Z)}}if(!(0<et))if(O)s(u),O||dt(X),postMessage({cmd:\"loaded\"});else{if(u.preRun)for(\"function\"==typeof u.preRun&&(u.preRun=[u.preRun]);u.preRun.length;)K();dt($),0<et||(u.setStatus?(u.setStatus(\"Running...\"),setTimeout((function(){setTimeout((function(){u.setStatus(\"\")}),1),t()}),1)):t())}}if(u.UTF8ToString=Y,u.stringToUTF8=function(t,e,n){return B(t,r(),e,n)},u.lengthBytesUTF8=G,u.keepRuntimeAlive=Q,u.wasmMemory=k,u.stackSave=Ee,u.stackRestore=Me,u.stackAlloc=Ce,u.ExitStatus=st,u.PThread=ht,rt=function t(){ve||Le(),ve||(rt=t)},u.preInit)for(\"function\"==typeof u.preInit&&(u.preInit=[u.preInit]);0<u.preInit.length;)u.preInit.pop()();return Le(),t.ready});t.exports=r},932:(t,e,n)=>{var _scriptDir,r=(_scriptDir=(_scriptDir=\"undefined\"!=typeof document&&document.currentScript?document.currentScript.src:void 0)||__filename,function(t){var e,r,a;t=t||{},e||(e=void 0!==t?t:{}),e.ready=new Promise((function(t,e){r=t,a=e}));var i,o,u,s,c,l,f=Object.assign({},e),p=\"./this.program\",h=(t,e)=>{throw e},d=\"object\"==typeof window,y=\"function\"==typeof importScripts,b=\"object\"==typeof process&&\"object\"==typeof process.versions&&\"string\"==typeof process.versions.node,m=\"\";b?(m=y?n(17).dirname(m)+\"/\":__dirname+\"/\",l=()=>{c||(s=n(147),c=n(17))},i=function(t,e){return l(),t=c.normalize(t),s.readFileSync(t,e?void 0:\"utf8\")},u=t=>((t=i(t,!0)).buffer||(t=new Uint8Array(t)),t),o=(t,e,n)=>{l(),t=c.normalize(t),s.readFile(t,(function(t,r){t?n(t):e(r.buffer)}))},1<process.argv.length&&(p=process.argv[1].replace(/\\\\\\\\/g,\"/\")),process.argv.slice(2),process.on(\"uncaughtException\",(function(t){if(!(t instanceof J))throw t})),process.on(\"unhandledRejection\",(function(t){throw t})),h=(t,e)=>{if(w||0<z)throw process.exitCode=t,e;e instanceof J||_(\"exiting due to exception: \"+e),process.exit(t)},e.inspect=function(){return\"[Emscripten Module object]\"}):(d||y)&&(y?m=self.location.href:\"undefined\"!=typeof document&&document.currentScript&&(m=document.currentScript.src),_scriptDir&&(m=_scriptDir),m=0!==m.indexOf(\"blob:\")?m.substr(0,m.replace(/[?#].*/,\"\").lastIndexOf(\"/\")+1):\"\",i=t=>{var e=new XMLHttpRequest;return e.open(\"GET\",t,!1),e.send(null),e.responseText},y&&(u=t=>{var e=new XMLHttpRequest;return e.open(\"GET\",t,!1),e.responseType=\"arraybuffer\",e.send(null),new Uint8Array(e.response)}),o=(t,e,n)=>{var r=new XMLHttpRequest;r.open(\"GET\",t,!0),r.responseType=\"arraybuffer\",r.onload=()=>{200==r.status||0==r.status&&r.response?e(r.response):n()},r.onerror=n,r.send(null)});var g,v=e.print||console.log.bind(console),_=e.printErr||console.warn.bind(console);Object.assign(e,f),f=null,e.thisProgram&&(p=e.thisProgram),e.quit&&(h=e.quit),e.wasmBinary&&(g=e.wasmBinary);var w=e.noExitRuntime||!1;\"object\"!=typeof WebAssembly&&V(\"no native wasm support detected\");var O,A,S,T,E,M,C=!1,x=\"undefined\"!=typeof TextDecoder?new TextDecoder(\"utf8\"):void 0;function R(t,e,n){var r=(e>>>=0)+n;for(n=e;t[n]&&!(n>=r);)++n;if(16<n-e&&t.buffer&&x)return x.decode(t.subarray(e,n));for(r=\"\";e<n;){var a=t[e++];if(128&a){var i=63&t[e++];if(192==(224&a))r+=String.fromCharCode((31&a)<<6|i);else{var o=63&t[e++];65536>(a=224==(240&a)?(15&a)<<12|i<<6|o:(7&a)<<18|i<<12|o<<6|63&t[e++])?r+=String.fromCharCode(a):(a-=65536,r+=String.fromCharCode(55296|a>>10,56320|1023&a))}}else r+=String.fromCharCode(a)}return r}function k(t,e){return(t>>>=0)?R(T,t,e):\"\"}function j(t,e,n,r){if(!(0<r))return 0;var a=n>>>=0;r=n+r-1;for(var i=0;i<t.length;++i){var o=t.charCodeAt(i);if(55296<=o&&57343>=o&&(o=65536+((1023&o)<<10)|1023&t.charCodeAt(++i)),127>=o){if(n>=r)break;e[n++>>>0]=o}else{if(2047>=o){if(n+1>=r)break;e[n++>>>0]=192|o>>6}else{if(65535>=o){if(n+2>=r)break;e[n++>>>0]=224|o>>12}else{if(n+3>=r)break;e[n++>>>0]=240|o>>18,e[n++>>>0]=128|o>>12&63}e[n++>>>0]=128|o>>6&63}e[n++>>>0]=128|63&o}}return e[n>>>0]=0,n-a}function D(t){for(var e=0,n=0;n<t.length;++n){var r=t.charCodeAt(n);127>=r?e++:2047>=r?e+=2:55296<=r&&57343>=r?(e+=4,++n):e+=3}return e}function P(){var t=O.buffer;A=t,e.HEAP8=S=new Int8Array(t),e.HEAP16=new Int16Array(t),e.HEAP32=E=new Int32Array(t),e.HEAPU8=T=new Uint8Array(t),e.HEAPU16=new Uint16Array(t),e.HEAPU32=M=new Uint32Array(t),e.HEAPF32=new Float32Array(t),e.HEAPF64=new Float64Array(t)}var U,F=[],I=[],W=[],H=[],z=0;function L(){var t=e.preRun.shift();F.unshift(t)}var Y,B=0,G=null,N=null;function V(t){throw e.onAbort&&e.onAbort(t),_(t=\"Aborted(\"+t+\")\"),C=!0,t=new WebAssembly.RuntimeError(t+\". Build with -sASSERTIONS for more info.\"),a(t),t}function q(){return Y.startsWith(\"data:application/octet-stream;base64,\")}if(Y=\"ort-wasm.wasm\",!q()){var $=Y;Y=e.locateFile?e.locateFile($,m):m+$}function X(){var t=Y;try{if(t==Y&&g)return new Uint8Array(g);if(u)return u(t);throw\"both async and sync fetching of the wasm failed\"}catch(t){V(t)}}function J(t){this.name=\"ExitStatus\",this.message=\"Program terminated with exit(\"+t+\")\",this.status=t}function Z(t){for(;0<t.length;)t.shift()(e)}var Q=[],K=0,tt=0;function et(t){this.Db=t,this.zb=t-24,this.Ub=function(t){M[this.zb+4>>2>>>0]=t},this.Eb=function(){return M[this.zb+4>>2>>>0]},this.Sb=function(t){M[this.zb+8>>2>>>0]=t},this.Wb=function(){return M[this.zb+8>>2>>>0]},this.Tb=function(){E[this.zb>>2>>>0]=0},this.Ib=function(t){S[this.zb+12>>0>>>0]=t?1:0},this.Pb=function(){return 0!=S[this.zb+12>>0>>>0]},this.Jb=function(t){S[this.zb+13>>0>>>0]=t?1:0},this.Lb=function(){return 0!=S[this.zb+13>>0>>>0]},this.Rb=function(t,e){this.Fb(0),this.Ub(t),this.Sb(e),this.Tb(),this.Ib(!1),this.Jb(!1)},this.Nb=function(){E[this.zb>>2>>>0]+=1},this.Xb=function(){var t=E[this.zb>>2>>>0];return E[this.zb>>2>>>0]=t-1,1===t},this.Fb=function(t){M[this.zb+16>>2>>>0]=t},this.Ob=function(){return M[this.zb+16>>2>>>0]},this.Qb=function(){if(Mt(this.Eb()))return M[this.Db>>2>>>0];var t=this.Ob();return 0!==t?t:this.Db}}function nt(t){return vt(new et(t).zb)}var rt=[];function at(t){var e=rt[t];return e||(t>=rt.length&&(rt.length=t+1),rt[t]=e=U.get(t)),e}function it(t){var e=D(t)+1,n=gt(e);return n&&j(t,S,n,e),n}var ot={};function ut(){if(!st){var t,e={USER:\"web_user\",LOGNAME:\"web_user\",PATH:\"/\",PWD:\"/\",HOME:\"/home/web_user\",LANG:(\"object\"==typeof navigator&&navigator.languages&&navigator.languages[0]||\"C\").replace(\"-\",\"_\")+\".UTF-8\",_:p||\"./this.program\"};for(t in ot)void 0===ot[t]?delete e[t]:e[t]=ot[t];var n=[];for(t in e)n.push(t+\"=\"+e[t]);st=n}return st}var st,ct=[null,[],[]];function lt(t,e){var n=ct[t];0===e||10===e?((1===t?v:_)(R(n,0)),n.length=0):n.push(e)}var ft=0;function pt(t){return 0==t%4&&(0!=t%100||0==t%400)}var ht=[31,29,31,30,31,30,31,31,30,31,30,31],dt=[31,28,31,30,31,30,31,31,30,31,30,31];function yt(t,e,n,r){function a(t,e,n){for(t=\"number\"==typeof t?t.toString():t||\"\";t.length<e;)t=n[0]+t;return t}function i(t,e){return a(t,e,\"0\")}function o(t,e){function n(t){return 0>t?-1:0<t?1:0}var r;return 0===(r=n(t.getFullYear()-e.getFullYear()))&&0===(r=n(t.getMonth()-e.getMonth()))&&(r=n(t.getDate()-e.getDate())),r}function u(t){switch(t.getDay()){case 0:return new Date(t.getFullYear()-1,11,29);case 1:return t;case 2:return new Date(t.getFullYear(),0,3);case 3:return new Date(t.getFullYear(),0,2);case 4:return new Date(t.getFullYear(),0,1);case 5:return new Date(t.getFullYear()-1,11,31);case 6:return new Date(t.getFullYear()-1,11,30)}}function s(t){var e=t.Bb;for(t=new Date(new Date(t.Cb+1900,0,1).getTime());0<e;){var n=t.getMonth(),r=(pt(t.getFullYear())?ht:dt)[n];if(!(e>r-t.getDate())){t.setDate(t.getDate()+e);break}e-=r-t.getDate()+1,t.setDate(1),11>n?t.setMonth(n+1):(t.setMonth(0),t.setFullYear(t.getFullYear()+1))}return n=new Date(t.getFullYear()+1,0,4),e=u(new Date(t.getFullYear(),0,4)),n=u(n),0>=o(e,t)?0>=o(n,t)?t.getFullYear()+1:t.getFullYear():t.getFullYear()-1}var c=E[r+40>>2>>>0];for(var l in r={$b:E[r>>2>>>0],Zb:E[r+4>>2>>>0],Gb:E[r+8>>2>>>0],Kb:E[r+12>>2>>>0],Hb:E[r+16>>2>>>0],Cb:E[r+20>>2>>>0],Ab:E[r+24>>2>>>0],Bb:E[r+28>>2>>>0],bc:E[r+32>>2>>>0],Yb:E[r+36>>2>>>0],ac:c?k(c):\"\"},n=k(n),c={\"%c\":\"%a %b %d %H:%M:%S %Y\",\"%D\":\"%m/%d/%y\",\"%F\":\"%Y-%m-%d\",\"%h\":\"%b\",\"%r\":\"%I:%M:%S %p\",\"%R\":\"%H:%M\",\"%T\":\"%H:%M:%S\",\"%x\":\"%m/%d/%y\",\"%X\":\"%H:%M:%S\",\"%Ec\":\"%c\",\"%EC\":\"%C\",\"%Ex\":\"%m/%d/%y\",\"%EX\":\"%H:%M:%S\",\"%Ey\":\"%y\",\"%EY\":\"%Y\",\"%Od\":\"%d\",\"%Oe\":\"%e\",\"%OH\":\"%H\",\"%OI\":\"%I\",\"%Om\":\"%m\",\"%OM\":\"%M\",\"%OS\":\"%S\",\"%Ou\":\"%u\",\"%OU\":\"%U\",\"%OV\":\"%V\",\"%Ow\":\"%w\",\"%OW\":\"%W\",\"%Oy\":\"%y\"})n=n.replace(new RegExp(l,\"g\"),c[l]);var f=\"Sunday Monday Tuesday Wednesday Thursday Friday Saturday\".split(\" \"),p=\"January February March April May June July August September October November December\".split(\" \");for(l in c={\"%a\":function(t){return f[t.Ab].substring(0,3)},\"%A\":function(t){return f[t.Ab]},\"%b\":function(t){return p[t.Hb].substring(0,3)},\"%B\":function(t){return p[t.Hb]},\"%C\":function(t){return i((t.Cb+1900)/100|0,2)},\"%d\":function(t){return i(t.Kb,2)},\"%e\":function(t){return a(t.Kb,2,\" \")},\"%g\":function(t){return s(t).toString().substring(2)},\"%G\":function(t){return s(t)},\"%H\":function(t){return i(t.Gb,2)},\"%I\":function(t){return 0==(t=t.Gb)?t=12:12<t&&(t-=12),i(t,2)},\"%j\":function(t){for(var e=0,n=0;n<=t.Hb-1;e+=(pt(t.Cb+1900)?ht:dt)[n++]);return i(t.Kb+e,3)},\"%m\":function(t){return i(t.Hb+1,2)},\"%M\":function(t){return i(t.Zb,2)},\"%n\":function(){return\"\\\\n\"},\"%p\":function(t){return 0<=t.Gb&&12>t.Gb?\"AM\":\"PM\"},\"%S\":function(t){return i(t.$b,2)},\"%t\":function(){return\"\\\\t\"},\"%u\":function(t){return t.Ab||7},\"%U\":function(t){return i(Math.floor((t.Bb+7-t.Ab)/7),2)},\"%V\":function(t){var e=Math.floor((t.Bb+7-(t.Ab+6)%7)/7);if(2>=(t.Ab+371-t.Bb-2)%7&&e++,e)53==e&&(4==(n=(t.Ab+371-t.Bb)%7)||3==n&&pt(t.Cb)||(e=1));else{e=52;var n=(t.Ab+7-t.Bb-1)%7;(4==n||5==n&&pt(t.Cb%400-1))&&e++}return i(e,2)},\"%w\":function(t){return t.Ab},\"%W\":function(t){return i(Math.floor((t.Bb+7-(t.Ab+6)%7)/7),2)},\"%y\":function(t){return(t.Cb+1900).toString().substring(2)},\"%Y\":function(t){return t.Cb+1900},\"%z\":function(t){var e=0<=(t=t.Yb);return t=Math.abs(t)/60,(e?\"+\":\"-\")+String(\"0000\"+(t/60*100+t%60)).slice(-4)},\"%Z\":function(t){return t.ac},\"%%\":function(){return\"%\"}},n=n.replace(/%%/g,\"\\\\0\\\\0\"),c)n.includes(l)&&(n=n.replace(new RegExp(l,\"g\"),c[l](r)));return l=function(t){var e=Array(D(t)+1);return j(t,e,0,e.length),e}(n=n.replace(/\\\\0\\\\0/g,\"%\")),l.length>e?0:(S.set(l,t>>>0),l.length-1)}var bt={a:function(t){return gt(t+24)+24},m:function(t){return(t=new et(t)).Pb()||(t.Ib(!0),K--),t.Jb(!1),Q.push(t),t.Nb(),t.Qb()},ia:function(t){throw _(\"Unexpected exception thrown, this is not properly supported - aborting\"),C=!0,t},w:function(){Ot(0);var t=Q.pop();if(t.Xb()&&!t.Lb()){var e=t.Wb();e&&at(e)(t.Db),nt(t.Db)}tt=0},d:function(){var t=tt;if(!t)return ft=0;var e=new et(t);e.Fb(t);var n=e.Eb();if(!n)return ft=0,t;for(var r=Array.prototype.slice.call(arguments),a=0;a<r.length;a++){var i=r[a];if(0===i||i===n)break;if(Et(i,n,e.zb+16))return ft=i,t}return ft=n,t},k:function(){var t=tt;if(!t)return ft=0;var e=new et(t);e.Fb(t);var n=e.Eb();if(!n)return ft=0,t;for(var r=Array.prototype.slice.call(arguments),a=0;a<r.length;a++){var i=r[a];if(0===i||i===n)break;if(Et(i,n,e.zb+16))return ft=i,t}return ft=n,t},g:function(){var t=tt;if(!t)return ft=0;var e=new et(t);e.Fb(t);var n=e.Eb();if(!n)return ft=0,t;for(var r=Array.prototype.slice.call(arguments),a=0;a<r.length;a++){var i=r[a];if(0===i||i===n)break;if(Et(i,n,e.zb+16))return ft=i,t}return ft=n,t},s:nt,L:function(){var t=Q.pop();t||V(\"no exception to throw\");var e=t.Db;throw t.Lb()||(Q.push(t),t.Jb(!0),t.Ib(!1),K++),tt=e,e},b:function(t,e,n){throw new et(t).Rb(e,n),tt=t,K++,t},la:function(){return K},i:function(t){throw tt||(tt=t),t},H:function(){return 0},Ba:function(){},pa:function(){},ra:function(){},ka:function(){return 0},za:function(){},ua:function(){},ya:function(){},R:function(){},qa:function(){},na:function(){},Aa:function(){},oa:function(){},Ha:function(){},Ja:function(){V(\"To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking\")},Ia:function(){V(\"To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking\")},S:function(){return Date.now()},Ca:function(){return!0},Da:function(t,e){t=new Date(1e3*(M[t>>>2]+4294967296*E[t+4>>>2])),E[e>>2>>>0]=t.getUTCSeconds(),E[e+4>>2>>>0]=t.getUTCMinutes(),E[e+8>>2>>>0]=t.getUTCHours(),E[e+12>>2>>>0]=t.getUTCDate(),E[e+16>>2>>>0]=t.getUTCMonth(),E[e+20>>2>>>0]=t.getUTCFullYear()-1900,E[e+24>>2>>>0]=t.getUTCDay(),E[e+28>>2>>>0]=(t.getTime()-Date.UTC(t.getUTCFullYear(),0,1,0,0,0,0))/864e5|0},Ea:function(t,e){t=new Date(1e3*(M[t>>>2]+4294967296*E[t+4>>>2])),E[e>>2>>>0]=t.getSeconds(),E[e+4>>2>>>0]=t.getMinutes(),E[e+8>>2>>>0]=t.getHours(),E[e+12>>2>>>0]=t.getDate(),E[e+16>>2>>>0]=t.getMonth(),E[e+20>>2>>>0]=t.getFullYear()-1900,E[e+24>>2>>>0]=t.getDay();var n=new Date(t.getFullYear(),0,1);E[e+28>>2>>>0]=(t.getTime()-n.getTime())/864e5|0,E[e+36>>2>>>0]=-60*t.getTimezoneOffset();var r=new Date(t.getFullYear(),6,1).getTimezoneOffset();n=n.getTimezoneOffset(),E[e+32>>2>>>0]=0|(r!=n&&t.getTimezoneOffset()==Math.min(n,r))},Fa:function(t){var e=new Date(E[t+20>>2>>>0]+1900,E[t+16>>2>>>0],E[t+12>>2>>>0],E[t+8>>2>>>0],E[t+4>>2>>>0],E[t>>2>>>0],0),n=E[t+32>>2>>>0],r=e.getTimezoneOffset(),a=new Date(e.getFullYear(),0,1),i=new Date(e.getFullYear(),6,1).getTimezoneOffset(),o=a.getTimezoneOffset(),u=Math.min(o,i);return 0>n?E[t+32>>2>>>0]=Number(i!=o&&u==r):0<n!=(u==r)&&(i=Math.max(o,i),e.setTime(e.getTime()+6e4*((0<n?u:i)-r))),E[t+24>>2>>>0]=e.getDay(),E[t+28>>2>>>0]=(e.getTime()-a.getTime())/864e5|0,E[t>>2>>>0]=e.getSeconds(),E[t+4>>2>>>0]=e.getMinutes(),E[t+8>>2>>>0]=e.getHours(),E[t+12>>2>>>0]=e.getDate(),E[t+16>>2>>>0]=e.getMonth(),e.getTime()/1e3|0},sa:function(){return-52},ta:function(){},Ga:function t(e,n,r){t.Vb||(t.Vb=!0,function(t,e,n){function r(t){return(t=t.toTimeString().match(/\\\\(([A-Za-z ]+)\\\\)$/))?t[1]:\"GMT\"}var a=(new Date).getFullYear(),i=new Date(a,0,1),o=new Date(a,6,1);a=i.getTimezoneOffset();var u=o.getTimezoneOffset();E[t>>2>>>0]=60*Math.max(a,u),E[e>>2>>>0]=Number(a!=u),t=r(i),e=r(o),t=it(t),e=it(e),u<a?(M[n>>2>>>0]=t,M[n+4>>2>>>0]=e):(M[n>>2>>>0]=e,M[n+4>>2>>>0]=t)}(e,n,r))},B:function(){V(\"\")},ma:function(){return 4294901760},I:b?()=>{var t=process.hrtime();return 1e3*t[0]+t[1]/1e6}:()=>performance.now(),xa:function(t,e,n){T.copyWithin(t>>>0,e>>>0,e+n>>>0)},G:function(t){var e=T.length;if(4294901760<(t>>>=0))return!1;for(var n=1;4>=n;n*=2){var r=e*(1+.2/n);r=Math.min(r,t+100663296);var a=Math;r=Math.max(t,r),a=a.min.call(a,4294901760,r+(65536-r%65536)%65536);t:{try{O.grow(a-A.byteLength+65535>>>16),P();var i=1;break t}catch(t){}i=void 0}if(i)return!0}return!1},va:function(t,e){var n=0;return ut().forEach((function(r,a){var i=e+n;for(a=M[t+4*a>>2>>>0]=i,i=0;i<r.length;++i)S[a++>>0>>>0]=r.charCodeAt(i);S[a>>0>>>0]=0,n+=r.length+1})),0},wa:function(t,e){var n=ut();M[t>>2>>>0]=n.length;var r=0;return n.forEach((function(t){r+=t.length+1})),M[e>>2>>>0]=r,0},ba:function(t){w||0<z||(wt(),Z(W),_t(0),ct[1].length&&lt(1,10),ct[2].length&&lt(2,10)),w||0<z||(e.onExit&&e.onExit(t),C=!0),h(t,new J(t))},E:function(){return 52},Q:function(){return 52},ca:function(){return 70},P:function(t,e,n,r){for(var a=0,i=0;i<n;i++){var o=M[e>>2>>>0],u=M[e+4>>2>>>0];e+=8;for(var s=0;s<u;s++)lt(t,T[o+s>>>0]);a+=u}return M[r>>2>>>0]=a,0},c:function(){return ft},ja:function t(e,r){t.Mb||(t.Mb=function(){if(\"object\"==typeof crypto&&\"function\"==typeof crypto.getRandomValues){var t=new Uint8Array(1);return()=>(crypto.getRandomValues(t),t[0])}if(b)try{var e=n(113);return()=>e.randomBytes(1)[0]}catch(t){}return()=>V(\"randomDevice\")}());for(var a=0;a<r;a++)S[e+a>>0>>>0]=t.Mb();return 0},ea:function(t,e,n){var r=At();try{return at(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},fa:function(t,e,n){var r=At();try{return at(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},J:function(t){var e=At();try{return at(t)()}catch(t){if(St(e),t!==t+0)throw t;Ot(1,0)}},e:function(t,e){var n=At();try{return at(t)(e)}catch(t){if(St(n),t!==t+0)throw t;Ot(1,0)}},N:function(t,e,n){var r=At();try{return at(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},O:function(t,e,n){var r=At();try{return at(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},j:function(t,e,n){var r=At();try{return at(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},o:function(t,e,n,r){var a=At();try{return at(t)(e,n,r)}catch(t){if(St(a),t!==t+0)throw t;Ot(1,0)}},p:function(t,e,n,r,a){var i=At();try{return at(t)(e,n,r,a)}catch(t){if(St(i),t!==t+0)throw t;Ot(1,0)}},M:function(t,e,n,r,a,i){var o=At();try{return at(t)(e,n,r,a,i)}catch(t){if(St(o),t!==t+0)throw t;Ot(1,0)}},r:function(t,e,n,r,a,i){var o=At();try{return at(t)(e,n,r,a,i)}catch(t){if(St(o),t!==t+0)throw t;Ot(1,0)}},v:function(t,e,n,r,a,i,o){var u=At();try{return at(t)(e,n,r,a,i,o)}catch(t){if(St(u),t!==t+0)throw t;Ot(1,0)}},K:function(t,e,n,r,a,i,o,u){var s=At();try{return at(t)(e,n,r,a,i,o,u)}catch(t){if(St(s),t!==t+0)throw t;Ot(1,0)}},D:function(t,e,n,r,a,i,o,u,s,c,l,f){var p=At();try{return at(t)(e,n,r,a,i,o,u,s,c,l,f)}catch(t){if(St(p),t!==t+0)throw t;Ot(1,0)}},X:function(t,e,n,r,a,i,o,u){var s=At();try{return Ft(t,e,n,r,a,i,o,u)}catch(t){if(St(s),t!==t+0)throw t;Ot(1,0)}},V:function(t,e,n,r,a,i,o){var u=At();try{return xt(t,e,n,r,a,i,o)}catch(t){if(St(u),t!==t+0)throw t;Ot(1,0)}},U:function(t,e,n,r,a){var i=At();try{return It(t,e,n,r,a)}catch(t){if(St(i),t!==t+0)throw t;Ot(1,0)}},Z:function(t,e,n,r){var a=At();try{return Pt(t,e,n,r)}catch(t){if(St(a),t!==t+0)throw t;Ot(1,0)}},W:function(t){var e=At();try{return Ct(t)}catch(t){if(St(e),t!==t+0)throw t;Ot(1,0)}},Y:function(t,e){var n=At();try{return Ut(t,e)}catch(t){if(St(n),t!==t+0)throw t;Ot(1,0)}},T:function(t,e,n){var r=At();try{return Rt(t,e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},f:function(t){var e=At();try{at(t)()}catch(t){if(St(e),t!==t+0)throw t;Ot(1,0)}},q:function(t,e){var n=At();try{at(t)(e)}catch(t){if(St(n),t!==t+0)throw t;Ot(1,0)}},h:function(t,e,n){var r=At();try{at(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},da:function(t,e,n,r){var a=At();try{at(t)(e,n,r)}catch(t){if(St(a),t!==t+0)throw t;Ot(1,0)}},l:function(t,e,n,r){var a=At();try{at(t)(e,n,r)}catch(t){if(St(a),t!==t+0)throw t;Ot(1,0)}},t:function(t,e,n,r,a){var i=At();try{at(t)(e,n,r,a)}catch(t){if(St(i),t!==t+0)throw t;Ot(1,0)}},u:function(t,e,n,r,a,i){var o=At();try{at(t)(e,n,r,a,i)}catch(t){if(St(o),t!==t+0)throw t;Ot(1,0)}},x:function(t,e,n,r,a,i,o){var u=At();try{at(t)(e,n,r,a,i,o)}catch(t){if(St(u),t!==t+0)throw t;Ot(1,0)}},z:function(t,e,n,r,a,i,o,u){var s=At();try{at(t)(e,n,r,a,i,o,u)}catch(t){if(St(s),t!==t+0)throw t;Ot(1,0)}},ga:function(t,e,n,r,a,i,o,u,s){var c=At();try{at(t)(e,n,r,a,i,o,u,s)}catch(t){if(St(c),t!==t+0)throw t;Ot(1,0)}},A:function(t,e,n,r,a,i,o,u,s,c,l){var f=At();try{at(t)(e,n,r,a,i,o,u,s,c,l)}catch(t){if(St(f),t!==t+0)throw t;Ot(1,0)}},C:function(t,e,n,r,a,i,o,u,s,c,l,f,p,h,d,y){var b=At();try{at(t)(e,n,r,a,i,o,u,s,c,l,f,p,h,d,y)}catch(t){if(St(b),t!==t+0)throw t;Ot(1,0)}},aa:function(t,e,n,r,a,i,o,u){var s=At();try{kt(t,e,n,r,a,i,o,u)}catch(t){if(St(s),t!==t+0)throw t;Ot(1,0)}},_:function(t,e,n,r,a,i,o,u,s,c,l,f){var p=At();try{Dt(t,e,n,r,a,i,o,u,s,c,l,f)}catch(t){if(St(p),t!==t+0)throw t;Ot(1,0)}},$:function(t,e,n,r,a,i){var o=At();try{jt(t,e,n,r,a,i)}catch(t){if(St(o),t!==t+0)throw t;Ot(1,0)}},n:function(t){return t},F:function(t){ft=t},ha:yt,y:function(t,e,n,r){return yt(t,e,n,r)}};!function(){function t(t){e.asm=t.exports,O=e.asm.Ka,P(),U=e.asm.ib,I.unshift(e.asm.La),B--,e.monitorRunDependencies&&e.monitorRunDependencies(B),0==B&&(null!==G&&(clearInterval(G),G=null),N&&(t=N,N=null,t()))}function n(e){t(e.instance)}function r(t){return function(){if(!g&&(d||y)){if(\"function\"==typeof fetch&&!Y.startsWith(\"file://\"))return fetch(Y,{credentials:\"same-origin\"}).then((function(t){if(!t.ok)throw\"failed to load wasm binary file at \\'\"+Y+\"\\'\";return t.arrayBuffer()})).catch((function(){return X()}));if(o)return new Promise((function(t,e){o(Y,(function(e){t(new Uint8Array(e))}),e)}))}return Promise.resolve().then((function(){return X()}))}().then((function(t){return WebAssembly.instantiate(t,i)})).then((function(t){return t})).then(t,(function(t){_(\"failed to asynchronously prepare wasm: \"+t),V(t)}))}var i={a:bt};if(B++,e.monitorRunDependencies&&e.monitorRunDependencies(B),e.instantiateWasm)try{return e.instantiateWasm(i,t)}catch(t){return _(\"Module.instantiateWasm callback failed with error: \"+t),!1}(g||\"function\"!=typeof WebAssembly.instantiateStreaming||q()||Y.startsWith(\"file://\")||b||\"function\"!=typeof fetch?r(n):fetch(Y,{credentials:\"same-origin\"}).then((function(t){return WebAssembly.instantiateStreaming(t,i).then(n,(function(t){return _(\"wasm streaming compile failed: \"+t),_(\"falling back to ArrayBuffer instantiation\"),r(n)}))}))).catch(a)}(),e.___wasm_call_ctors=function(){return(e.___wasm_call_ctors=e.asm.La).apply(null,arguments)},e._OrtInit=function(){return(e._OrtInit=e.asm.Ma).apply(null,arguments)},e._OrtCreateSessionOptions=function(){return(e._OrtCreateSessionOptions=e.asm.Na).apply(null,arguments)},e._OrtAppendExecutionProvider=function(){return(e._OrtAppendExecutionProvider=e.asm.Oa).apply(null,arguments)},e._OrtAddSessionConfigEntry=function(){return(e._OrtAddSessionConfigEntry=e.asm.Pa).apply(null,arguments)},e._OrtReleaseSessionOptions=function(){return(e._OrtReleaseSessionOptions=e.asm.Qa).apply(null,arguments)},e._OrtCreateSession=function(){return(e._OrtCreateSession=e.asm.Ra).apply(null,arguments)},e._OrtReleaseSession=function(){return(e._OrtReleaseSession=e.asm.Sa).apply(null,arguments)},e._OrtGetInputCount=function(){return(e._OrtGetInputCount=e.asm.Ta).apply(null,arguments)},e._OrtGetOutputCount=function(){return(e._OrtGetOutputCount=e.asm.Ua).apply(null,arguments)},e._OrtGetInputName=function(){return(e._OrtGetInputName=e.asm.Va).apply(null,arguments)},e._OrtGetOutputName=function(){return(e._OrtGetOutputName=e.asm.Wa).apply(null,arguments)},e._OrtFree=function(){return(e._OrtFree=e.asm.Xa).apply(null,arguments)},e._OrtCreateTensor=function(){return(e._OrtCreateTensor=e.asm.Ya).apply(null,arguments)},e._OrtGetTensorData=function(){return(e._OrtGetTensorData=e.asm.Za).apply(null,arguments)},e._OrtReleaseTensor=function(){return(e._OrtReleaseTensor=e.asm._a).apply(null,arguments)},e._OrtCreateRunOptions=function(){return(e._OrtCreateRunOptions=e.asm.$a).apply(null,arguments)},e._OrtAddRunConfigEntry=function(){return(e._OrtAddRunConfigEntry=e.asm.ab).apply(null,arguments)},e._OrtReleaseRunOptions=function(){return(e._OrtReleaseRunOptions=e.asm.bb).apply(null,arguments)},e._OrtRun=function(){return(e._OrtRun=e.asm.cb).apply(null,arguments)},e._OrtEndProfiling=function(){return(e._OrtEndProfiling=e.asm.db).apply(null,arguments)};var mt,gt=e._malloc=function(){return(gt=e._malloc=e.asm.eb).apply(null,arguments)},vt=e._free=function(){return(vt=e._free=e.asm.fb).apply(null,arguments)},_t=e._fflush=function(){return(_t=e._fflush=e.asm.gb).apply(null,arguments)},wt=e.___funcs_on_exit=function(){return(wt=e.___funcs_on_exit=e.asm.hb).apply(null,arguments)},Ot=e._setThrew=function(){return(Ot=e._setThrew=e.asm.jb).apply(null,arguments)},At=e.stackSave=function(){return(At=e.stackSave=e.asm.kb).apply(null,arguments)},St=e.stackRestore=function(){return(St=e.stackRestore=e.asm.lb).apply(null,arguments)},Tt=e.stackAlloc=function(){return(Tt=e.stackAlloc=e.asm.mb).apply(null,arguments)},Et=e.___cxa_can_catch=function(){return(Et=e.___cxa_can_catch=e.asm.nb).apply(null,arguments)},Mt=e.___cxa_is_pointer_type=function(){return(Mt=e.___cxa_is_pointer_type=e.asm.ob).apply(null,arguments)},Ct=e.dynCall_j=function(){return(Ct=e.dynCall_j=e.asm.pb).apply(null,arguments)},xt=e.dynCall_iiiiij=function(){return(xt=e.dynCall_iiiiij=e.asm.qb).apply(null,arguments)},Rt=e.dynCall_jii=function(){return(Rt=e.dynCall_jii=e.asm.rb).apply(null,arguments)},kt=e.dynCall_viiiiij=function(){return(kt=e.dynCall_viiiiij=e.asm.sb).apply(null,arguments)},jt=e.dynCall_vjji=function(){return(jt=e.dynCall_vjji=e.asm.tb).apply(null,arguments)},Dt=e.dynCall_viiijjjii=function(){return(Dt=e.dynCall_viiijjjii=e.asm.ub).apply(null,arguments)},Pt=e.dynCall_iij=function(){return(Pt=e.dynCall_iij=e.asm.vb).apply(null,arguments)},Ut=e.dynCall_ji=function(){return(Ut=e.dynCall_ji=e.asm.wb).apply(null,arguments)},Ft=e.dynCall_iiiiiij=function(){return(Ft=e.dynCall_iiiiiij=e.asm.xb).apply(null,arguments)},It=e.dynCall_iiij=function(){return(It=e.dynCall_iiij=e.asm.yb).apply(null,arguments)};function Wt(){function t(){if(!mt&&(mt=!0,e.calledRun=!0,!C)){if(Z(I),r(e),e.onRuntimeInitialized&&e.onRuntimeInitialized(),e.postRun)for(\"function\"==typeof e.postRun&&(e.postRun=[e.postRun]);e.postRun.length;){var t=e.postRun.shift();H.unshift(t)}Z(H)}}if(!(0<B)){if(e.preRun)for(\"function\"==typeof e.preRun&&(e.preRun=[e.preRun]);e.preRun.length;)L();Z(F),0<B||(e.setStatus?(e.setStatus(\"Running...\"),setTimeout((function(){setTimeout((function(){e.setStatus(\"\")}),1),t()}),1)):t())}}if(e.UTF8ToString=k,e.stringToUTF8=function(t,e,n){return j(t,T,e,n)},e.lengthBytesUTF8=D,e.stackSave=At,e.stackRestore=St,e.stackAlloc=Tt,N=function t(){mt||Wt(),mt||(N=t)},e.preInit)for(\"function\"==typeof e.preInit&&(e.preInit=[e.preInit]);0<e.preInit.length;)e.preInit.pop()();return Wt(),t.ready});t.exports=r},967:(t,e)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.iterateExtraOptions=void 0,e.iterateExtraOptions=(t,n,r,a)=>{if(\"object\"==typeof t&&null!==t){if(r.has(t))throw new Error(\"Circular reference in options\");r.add(t)}Object.entries(t).forEach((([t,i])=>{const o=n?n+t:t;if(\"object\"==typeof i)(0,e.iterateExtraOptions)(i,o+\".\",r,a);else if(\"string\"==typeof i||\"number\"==typeof i)a(o,i.toString());else{if(\"boolean\"!=typeof i)throw new Error(\"Can\\'t handle extra config type: \"+typeof i);a(o,i?\"1\":\"0\")}}))}},586:(t,e,n)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.setRunOptions=void 0;const r=n(967),a=n(983),i=n(361);e.setRunOptions=t=>{const e=(0,i.getInstance)();let n=0;const o=[],u=t||{};try{if(void 0===(null==t?void 0:t.logSeverityLevel))u.logSeverityLevel=2;else if(\"number\"!=typeof t.logSeverityLevel||!Number.isInteger(t.logSeverityLevel)||t.logSeverityLevel<0||t.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${t.logSeverityLevel}`);if(void 0===(null==t?void 0:t.logVerbosityLevel))u.logVerbosityLevel=0;else if(\"number\"!=typeof t.logVerbosityLevel||!Number.isInteger(t.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${t.logVerbosityLevel}`);void 0===(null==t?void 0:t.terminate)&&(u.terminate=!1);let i=0;if(void 0!==(null==t?void 0:t.tag)&&(i=(0,a.allocWasmString)(t.tag,o)),n=e._OrtCreateRunOptions(u.logSeverityLevel,u.logVerbosityLevel,!!u.terminate,i),0===n)throw new Error(\"Can\\'t create run options\");return void 0!==(null==t?void 0:t.extra)&&(0,r.iterateExtraOptions)(t.extra,\"\",new WeakSet,((t,r)=>{const i=(0,a.allocWasmString)(t,o),u=(0,a.allocWasmString)(r,o);if(0!==e._OrtAddRunConfigEntry(n,i,u))throw new Error(`Can\\'t set a run config entry: ${t} - ${r}`)})),[n,o]}catch(t){throw 0!==n&&e._OrtReleaseRunOptions(n),o.forEach(e._free),t}}},919:(t,e,n)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.setSessionOptions=void 0;const r=n(967),a=n(983),i=n(361);e.setSessionOptions=t=>{const e=(0,i.getInstance)();let n=0;const o=[],u=t||{};(t=>{t.extra||(t.extra={}),t.extra.session||(t.extra.session={});const e=t.extra.session;e.use_ort_model_bytes_directly||(e.use_ort_model_bytes_directly=\"1\")})(u);try{void 0===(null==t?void 0:t.graphOptimizationLevel)&&(u.graphOptimizationLevel=\"all\");const s=(t=>{switch(t){case\"disabled\":return 0;case\"basic\":return 1;case\"extended\":return 2;case\"all\":return 99;default:throw new Error(`unsupported graph optimization level: ${t}`)}})(u.graphOptimizationLevel);void 0===(null==t?void 0:t.enableCpuMemArena)&&(u.enableCpuMemArena=!0),void 0===(null==t?void 0:t.enableMemPattern)&&(u.enableMemPattern=!0),void 0===(null==t?void 0:t.executionMode)&&(u.executionMode=\"sequential\");const c=(t=>{switch(t){case\"sequential\":return 0;case\"parallel\":return 1;default:throw new Error(`unsupported execution mode: ${t}`)}})(u.executionMode);let l=0;if(void 0!==(null==t?void 0:t.logId)&&(l=(0,a.allocWasmString)(t.logId,o)),void 0===(null==t?void 0:t.logSeverityLevel))u.logSeverityLevel=2;else if(\"number\"!=typeof t.logSeverityLevel||!Number.isInteger(t.logSeverityLevel)||t.logSeverityLevel<0||t.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${t.logSeverityLevel}`);if(void 0===(null==t?void 0:t.logVerbosityLevel))u.logVerbosityLevel=0;else if(\"number\"!=typeof t.logVerbosityLevel||!Number.isInteger(t.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${t.logVerbosityLevel}`);if(void 0===(null==t?void 0:t.enableProfiling)&&(u.enableProfiling=!1),n=e._OrtCreateSessionOptions(s,!!u.enableCpuMemArena,!!u.enableMemPattern,c,!!u.enableProfiling,0,l,u.logSeverityLevel,u.logVerbosityLevel),0===n)throw new Error(\"Can\\'t create session options\");return(null==t?void 0:t.executionProviders)&&((t,e,n)=>{for(const r of e){let e=\"string\"==typeof r?r:r.name;switch(e){case\"xnnpack\":e=\"XNNPACK\";break;case\"wasm\":case\"cpu\":continue;default:throw new Error(`not supported EP: ${e}`)}const o=(0,a.allocWasmString)(e,n);if(0!==(0,i.getInstance)()._OrtAppendExecutionProvider(t,o))throw new Error(`Can\\'t append execution provider: ${e}`)}})(n,t.executionProviders,o),void 0!==(null==t?void 0:t.extra)&&(0,r.iterateExtraOptions)(t.extra,\"\",new WeakSet,((t,r)=>{const i=(0,a.allocWasmString)(t,o),u=(0,a.allocWasmString)(r,o);if(0!==e._OrtAddSessionConfigEntry(n,i,u))throw new Error(`Can\\'t set a session config entry: ${t} - ${r}`)})),[n,o]}catch(t){throw 0!==n&&e._OrtReleaseSessionOptions(n),o.forEach(e._free),t}}},983:(t,e,n)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.allocWasmString=void 0;const r=n(361);e.allocWasmString=(t,e)=>{const n=(0,r.getInstance)(),a=n.lengthBytesUTF8(t)+1,i=n._malloc(a);return n.stringToUTF8(t,i,a),e.push(i),i}},349:(t,e,n)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.extractTransferableBuffers=e.endProfiling=e.run=e.releaseSession=e.createSession=e.createSessionFinalize=e.createSessionAllocate=e.initOrt=void 0;const r=n(586),a=n(919),i=n(983),o=n(361);e.initOrt=(t,e)=>{const n=(0,o.getInstance)()._OrtInit(t,e);if(0!==n)throw new Error(`Can\\'t initialize onnxruntime. error code = ${n}`)};const u=new Map;e.createSessionAllocate=t=>{const e=(0,o.getInstance)(),n=e._malloc(t.byteLength);return e.HEAPU8.set(t,n),[n,t.byteLength]},e.createSessionFinalize=(t,e)=>{const n=(0,o.getInstance)();let r=0,i=0,s=[];try{if([i,s]=(0,a.setSessionOptions)(e),r=n._OrtCreateSession(t[0],t[1],i),0===r)throw new Error(\"Can\\'t create a session\")}finally{n._free(t[0]),n._OrtReleaseSessionOptions(i),s.forEach(n._free)}const c=n._OrtGetInputCount(r),l=n._OrtGetOutputCount(r),f=[],p=[],h=[],d=[];for(let t=0;t<c;t++){const e=n._OrtGetInputName(r,t);if(0===e)throw new Error(\"Can\\'t get an input name\");p.push(e),f.push(n.UTF8ToString(e))}for(let t=0;t<l;t++){const e=n._OrtGetOutputName(r,t);if(0===e)throw new Error(\"Can\\'t get an output name\");d.push(e),h.push(n.UTF8ToString(e))}return u.set(r,[r,p,d]),[r,f,h]},e.createSession=(t,n)=>{const r=(0,e.createSessionAllocate)(t);return(0,e.createSessionFinalize)(r,n)},e.releaseSession=t=>{const e=(0,o.getInstance)(),n=u.get(t);if(!n)throw new Error(\"invalid session id\");const r=n[0],a=n[1],i=n[2];a.forEach(e._OrtFree),i.forEach(e._OrtFree),e._OrtReleaseSession(r),u.delete(t)};const s=t=>{switch(t){case\"int8\":return 3;case\"uint8\":return 2;case\"bool\":return 9;case\"int16\":return 5;case\"uint16\":return 4;case\"int32\":return 6;case\"uint32\":return 12;case\"float32\":return 1;case\"float64\":return 11;case\"string\":return 8;case\"int64\":return 7;case\"uint64\":return 13;default:throw new Error(`unsupported data type: ${t}`)}},c=t=>{switch(t){case 3:return\"int8\";case 2:return\"uint8\";case 9:return\"bool\";case 5:return\"int16\";case 4:return\"uint16\";case 6:return\"int32\";case 12:return\"uint32\";case 1:return\"float32\";case 11:return\"float64\";case 8:return\"string\";case 7:return\"int64\";case 13:return\"uint64\";default:throw new Error(`unsupported data type: ${t}`)}},l=t=>{switch(t){case\"float32\":return Float32Array;case\"uint8\":case\"bool\":return Uint8Array;case\"int8\":return Int8Array;case\"uint16\":return Uint16Array;case\"int16\":return Int16Array;case\"int32\":return Int32Array;case\"float64\":return Float64Array;case\"uint32\":return Uint32Array;case\"int64\":return BigInt64Array;case\"uint64\":return BigUint64Array;default:throw new Error(`unsupported type: ${t}`)}};e.run=(t,e,n,a,f)=>{const p=(0,o.getInstance)(),h=u.get(t);if(!h)throw new Error(\"invalid session id\");const d=h[0],y=h[1],b=h[2],m=e.length,g=a.length;let v=0,_=[];const w=[],O=[];try{[v,_]=(0,r.setRunOptions)(f);for(let t=0;t<m;t++){const e=n[t][0],r=n[t][1],a=n[t][2];let o,u;if(Array.isArray(a)){u=4*a.length,o=p._malloc(u),O.push(o);let t=o/4;for(let e=0;e<a.length;e++){if(\"string\"!=typeof a[e])throw new TypeError(`tensor data at index ${e} is not a string`);p.HEAPU32[t++]=(0,i.allocWasmString)(a[e],O)}}else u=a.byteLength,o=p._malloc(u),O.push(o),p.HEAPU8.set(new Uint8Array(a.buffer,a.byteOffset,u),o);const c=p.stackSave(),l=p.stackAlloc(4*r.length);try{let t=l/4;r.forEach((e=>p.HEAP32[t++]=e));const n=p._OrtCreateTensor(s(e),o,u,l,r.length);if(0===n)throw new Error(\"Can\\'t create a tensor\");w.push(n)}finally{p.stackRestore(c)}}const t=p.stackSave(),o=p.stackAlloc(4*m),u=p.stackAlloc(4*m),h=p.stackAlloc(4*g),A=p.stackAlloc(4*g);try{let n=o/4,r=u/4,i=h/4,s=A/4;for(let t=0;t<m;t++)p.HEAPU32[n++]=w[t],p.HEAPU32[r++]=y[e[t]];for(let t=0;t<g;t++)p.HEAPU32[i++]=0,p.HEAPU32[s++]=b[a[t]];let f=p._OrtRun(d,u,o,m,A,g,h,v);const _=[];if(0===f)for(let t=0;t<g;t++){const e=p.HEAPU32[h/4+t],n=p.stackSave(),r=p.stackAlloc(16);let a,i=0;try{if(f=p._OrtGetTensorData(e,r,r+4,r+8,r+12),0!==f)throw new Error(`Can\\'t access output tensor data. error code = ${f}`);let t=r/4;const o=p.HEAPU32[t++];i=p.HEAPU32[t++];const u=p.HEAPU32[t++],s=p.HEAPU32[t++],h=[];for(let t=0;t<s;t++)h.push(p.HEAPU32[u/4+t]);p._OrtFree(u);const d=0===h.length?1:h.reduce(((t,e)=>t*e));if(a=c(o),\"string\"===a){const t=[];let e=i/4;for(let n=0;n<d;n++){const r=p.HEAPU32[e++],a=n===d-1?void 0:p.HEAPU32[e]-r;t.push(p.UTF8ToString(r,a))}_.push([a,h,t])}else{const t=new(l(a))(d);new Uint8Array(t.buffer,t.byteOffset,t.byteLength).set(p.HEAPU8.subarray(i,i+t.byteLength)),_.push([a,h,t])}}finally{p.stackRestore(n),\"string\"===a&&i&&p._free(i),p._OrtReleaseTensor(e)}}if(0===f)return _;throw new Error(`failed to call OrtRun(). error code = ${f}.`)}finally{p.stackRestore(t)}}finally{w.forEach(p._OrtReleaseTensor),O.forEach(p._free),p._OrtReleaseRunOptions(v),_.forEach(p._free)}},e.endProfiling=t=>{const e=(0,o.getInstance)(),n=u.get(t);if(!n)throw new Error(\"invalid session id\");const r=n[0],a=e._OrtEndProfiling(r);if(0===a)throw new Error(\"Can\\'t get an profile file name\");e._OrtFree(a)},e.extractTransferableBuffers=t=>{const e=[];for(const n of t){const t=n[2];!Array.isArray(t)&&t.buffer&&e.push(t.buffer)}return e}},361:function(t,e,n){\"use strict\";var r=this&&this.__createBinding||(Object.create?function(t,e,n,r){void 0===r&&(r=n);var a=Object.getOwnPropertyDescriptor(e,n);a&&!(\"get\"in a?!e.__esModule:a.writable||a.configurable)||(a={enumerable:!0,get:function(){return e[n]}}),Object.defineProperty(t,r,a)}:function(t,e,n,r){void 0===r&&(r=n),t[r]=e[n]}),a=this&&this.__setModuleDefault||(Object.create?function(t,e){Object.defineProperty(t,\"default\",{enumerable:!0,value:e})}:function(t,e){t.default=e}),i=this&&this.__importStar||function(t){if(t&&t.__esModule)return t;var e={};if(null!=t)for(var n in t)\"default\"!==n&&Object.prototype.hasOwnProperty.call(t,n)&&r(e,t,n);return a(e,t),e},o=this&&this.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(e,\"__esModule\",{value:!0}),e.dispose=e.getInstance=e.initializeWebAssembly=void 0;const u=i(n(17)),s=o(n(932)),c=n(474);let l,f=!1,p=!1,h=!1;const d=(t,e)=>e?t?\"ort-wasm-simd-threaded.wasm\":\"ort-wasm-threaded.wasm\":t?\"ort-wasm-simd.wasm\":\"ort-wasm.wasm\";e.initializeWebAssembly=async t=>{if(f)return Promise.resolve();if(p)throw new Error(\"multiple calls to \\'initializeWebAssembly()\\' detected.\");if(h)throw new Error(\"previous call to \\'initializeWebAssembly()\\' failed.\");p=!0;const e=t.initTimeout,r=t.numThreads,a=t.simd,i=r>1&&(()=>{try{return\"undefined\"!=typeof SharedArrayBuffer&&(\"undefined\"!=typeof MessageChannel&&(new MessageChannel).port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11])))}catch(t){return!1}})(),o=a&&(()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch(t){return!1}})(),y=\"string\"==typeof t.wasmPaths?t.wasmPaths:void 0,b=d(!1,i),m=d(o,i),g=\"object\"==typeof t.wasmPaths?t.wasmPaths[m]:void 0;let v=!1;const _=[];if(e>0&&_.push(new Promise((t=>{setTimeout((()=>{v=!0,t()}),e)}))),_.push(new Promise(((t,e)=>{const r=i?c:s.default,a={locateFile:(t,e)=>i&&t.endsWith(\".worker.js\")&&\"undefined\"!=typeof Blob?URL.createObjectURL(new Blob([n(154)],{type:\"text/javascript\"})):t===b?null!=g?g:(null!=y?y:e)+m:e+t};if(i)if(\"undefined\"==typeof Blob)a.mainScriptUrlOrBlob=u.join(__dirname,\"ort-wasm-threaded.js\");else{const t=`var ortWasmThreaded=(function(){var _scriptDir;return ${r.toString()}})();`;a.mainScriptUrlOrBlob=new Blob([t],{type:\"text/javascript\"})}r(a).then((e=>{p=!1,f=!0,l=e,t()}),(t=>{p=!1,h=!0,e(t)}))}))),await Promise.race(_),v)throw new Error(`WebAssembly backend initializing failed due to timeout: ${e}ms`)},e.getInstance=()=>{if(f&&l)return l;throw new Error(\"WebAssembly is not initialized yet.\")},e.dispose=()=>{var t;!f||p||h||(p=!0,null===(t=l.PThread)||void 0===t||t.terminateAllThreads(),l=void 0,p=!1,f=!1,h=!0)}},154:t=>{\"use strict\";t.exports=\\'\"use strict\";var e={},t=\"object\"==typeof process&&\"object\"==typeof process.versions&&\"string\"==typeof process.versions.node;if(t){var r=require(\"worker_threads\"),a=r.parentPort;a.on(\"message\",(e=>onmessage({data:e})));var o=require(\"fs\");Object.assign(global,{self:global,require:require,Module:e,location:{href:__filename},Worker:r.Worker,importScripts:function(e){(0,eval)(o.readFileSync(e,\"utf8\"))},postMessage:function(e){a.postMessage(e)},performance:global.performance||{now:function(){return Date.now()}}})}var s=!1,n=[],i=function(){var e=Array.prototype.slice.call(arguments).join(\" \");t?o.writeSync(2,e+\"\\\\\\\\n\"):console.error(e)};self.alert=function(){var t=Array.prototype.slice.call(arguments).join(\" \");postMessage({cmd:\"alert\",text:t,threadId:e._pthread_self()})},e.instantiateWasm=(t,r)=>{var a=new WebAssembly.Instance(e.wasmModule,t);return r(a),e.wasmModule=null,a.exports},self.onunhandledrejection=e=>{throw e.reason??e},self.onmessage=t=>{try{if(\"load\"===t.data.cmd){if(e.wasmModule=t.data.wasmModule,e.wasmMemory=t.data.wasmMemory,e.buffer=e.wasmMemory.buffer,e.ENVIRONMENT_IS_PTHREAD=!0,\"string\"==typeof t.data.urlOrBlob)importScripts(t.data.urlOrBlob);else{var r=URL.createObjectURL(t.data.urlOrBlob);importScripts(r),URL.revokeObjectURL(r)}ortWasmThreaded(e).then((function(t){e=t}))}else if(\"run\"===t.data.cmd){e.__performance_now_clock_drift=performance.now()-t.data.time,e.__emscripten_thread_init(t.data.pthread_ptr,0,0,1),e.establishStackSpace(),e.PThread.receiveObjectTransfer(t.data),e.PThread.threadInitTLS(),s||(n.forEach((t=>{e.executeNotifiedProxyingQueue(t)})),n=[],s=!0);try{e.invokeEntryPoint(t.data.start_routine,t.data.arg)}catch(t){if(\"unwind\"!=t){if(!(t instanceof e.ExitStatus))throw t;e.keepRuntimeAlive()||e.__emscripten_thread_exit(t.status)}}}else\"cancel\"===t.data.cmd?e._pthread_self()&&e.__emscripten_thread_exit(-1):\"setimmediate\"===t.data.target||(\"processProxyingQueue\"===t.data.cmd?s?e.executeNotifiedProxyingQueue(t.data.queue):n.push(t.data.queue):(i(\"worker.js received unknown command \"+t.data.cmd),i(t.data)))}catch(t){throw i(\"worker.js onmessage() captured an uncaught exception: \"+t),t&&t.stack&&i(t.stack),e.__emscripten_thread_crashed&&e.__emscripten_thread_crashed(),t}};\\\\n\\'},113:t=>{\"use strict\";t.exports=require(\"crypto\")},147:t=>{\"use strict\";t.exports=require(\"fs\")},37:t=>{\"use strict\";t.exports=require(\"os\")},17:t=>{\"use strict\";t.exports=require(\"path\")},74:t=>{\"use strict\";t.exports=require(\"perf_hooks\")},267:t=>{\"use strict\";t.exports=require(\"worker_threads\")}},e={};function n(r){var a=e[r];if(void 0!==a)return a.exports;var i=e[r]={exports:{}};return t[r].call(i.exports,i,i.exports,n),i.exports}(()=>{\"use strict\";const t=n(349),e=n(361);self.onmessage=n=>{switch(n.data.type){case\"init-wasm\":(0,e.initializeWebAssembly)(n.data.in).then((()=>postMessage({type:\"init-wasm\"})),(t=>postMessage({type:\"init-wasm\",err:t})));break;case\"init-ort\":try{const{numThreads:e,loggingLevel:r}=n.data.in;(0,t.initOrt)(e,r),postMessage({type:\"init-ort\"})}catch(t){postMessage({type:\"init-ort\",err:t})}break;case\"create_allocate\":try{const{model:e}=n.data.in,r=(0,t.createSessionAllocate)(e);postMessage({type:\"create_allocate\",out:r})}catch(t){postMessage({type:\"create_allocate\",err:t})}break;case\"create_finalize\":try{const{modeldata:e,options:r}=n.data.in,a=(0,t.createSessionFinalize)(e,r);postMessage({type:\"create_finalize\",out:a})}catch(t){postMessage({type:\"create_finalize\",err:t})}break;case\"create\":try{const{model:e,options:r}=n.data.in,a=(0,t.createSession)(e,r);postMessage({type:\"create\",out:a})}catch(t){postMessage({type:\"create\",err:t})}break;case\"release\":try{const e=n.data.in;(0,t.releaseSession)(e),postMessage({type:\"release\"})}catch(t){postMessage({type:\"release\",err:t})}break;case\"run\":try{const{sessionId:e,inputIndices:r,inputs:a,outputIndices:i,options:o}=n.data.in,u=(0,t.run)(e,r,a,i,o);postMessage({type:\"run\",out:u},(0,t.extractTransferableBuffers)(u))}catch(t){postMessage({type:\"run\",err:t})}break;case\"end-profiling\":try{const e=n.data.in;(0,t.endProfiling)(e),postMessage({type:\"end-profiling\"})}catch(t){postMessage({type:\"end-profiling\",err:t})}}}})()})();\\n',\"Worker\",void 0,void 0)}},477:t=>{\"use strict\";t.exports=function(t,e,n,r){var i=self||window;try{try{var o;try{o=new i.Blob([t])}catch(e){(o=new(i.BlobBuilder||i.WebKitBlobBuilder||i.MozBlobBuilder||i.MSBlobBuilder)).append(t),o=o.getBlob()}var a=i.URL||i.webkitURL,s=a.createObjectURL(o),u=new i[e](s,n);return a.revokeObjectURL(s),u}catch(r){return new i[e](\"data:application/javascript,\".concat(encodeURIComponent(t)),n)}}catch(t){if(!r)throw Error(\"Inline worker is not supported\");return new i[e](r,n)}}},4154:t=>{\"use strict\";t.exports='\"use strict\";var e={},t=\"object\"==typeof process&&\"object\"==typeof process.versions&&\"string\"==typeof process.versions.node;if(t){var r=require(\"worker_threads\"),a=r.parentPort;a.on(\"message\",(e=>onmessage({data:e})));var o=require(\"fs\");Object.assign(global,{self:global,require:require,Module:e,location:{href:__filename},Worker:r.Worker,importScripts:function(e){(0,eval)(o.readFileSync(e,\"utf8\"))},postMessage:function(e){a.postMessage(e)},performance:global.performance||{now:function(){return Date.now()}}})}var s=!1,n=[],i=function(){var e=Array.prototype.slice.call(arguments).join(\" \");t?o.writeSync(2,e+\"\\\\n\"):console.error(e)};self.alert=function(){var t=Array.prototype.slice.call(arguments).join(\" \");postMessage({cmd:\"alert\",text:t,threadId:e._pthread_self()})},e.instantiateWasm=(t,r)=>{var a=new WebAssembly.Instance(e.wasmModule,t);return r(a),e.wasmModule=null,a.exports},self.onunhandledrejection=e=>{throw e.reason??e},self.onmessage=t=>{try{if(\"load\"===t.data.cmd){if(e.wasmModule=t.data.wasmModule,e.wasmMemory=t.data.wasmMemory,e.buffer=e.wasmMemory.buffer,e.ENVIRONMENT_IS_PTHREAD=!0,\"string\"==typeof t.data.urlOrBlob)importScripts(t.data.urlOrBlob);else{var r=URL.createObjectURL(t.data.urlOrBlob);importScripts(r),URL.revokeObjectURL(r)}ortWasmThreaded(e).then((function(t){e=t}))}else if(\"run\"===t.data.cmd){e.__performance_now_clock_drift=performance.now()-t.data.time,e.__emscripten_thread_init(t.data.pthread_ptr,0,0,1),e.establishStackSpace(),e.PThread.receiveObjectTransfer(t.data),e.PThread.threadInitTLS(),s||(n.forEach((t=>{e.executeNotifiedProxyingQueue(t)})),n=[],s=!0);try{e.invokeEntryPoint(t.data.start_routine,t.data.arg)}catch(t){if(\"unwind\"!=t){if(!(t instanceof e.ExitStatus))throw t;e.keepRuntimeAlive()||e.__emscripten_thread_exit(t.status)}}}else\"cancel\"===t.data.cmd?e._pthread_self()&&e.__emscripten_thread_exit(-1):\"setimmediate\"===t.data.target||(\"processProxyingQueue\"===t.data.cmd?s?e.executeNotifiedProxyingQueue(t.data.queue):n.push(t.data.queue):(i(\"worker.js received unknown command \"+t.data.cmd),i(t.data)))}catch(t){throw i(\"worker.js onmessage() captured an uncaught exception: \"+t),t&&t.stack&&i(t.stack),e.__emscripten_thread_crashed&&e.__emscripten_thread_crashed(),t}};\\n'},6231:t=>{\"use strict\";t.exports=__webpack_require__(/*! fs */ \"fs\")},9719:t=>{\"use strict\";t.exports=__webpack_require__(/*! os */ \"os\")},1423:t=>{\"use strict\";t.exports=__webpack_require__(/*! path */ \"path\")},498:t=>{\"use strict\";t.exports=__webpack_require__(/*! perf_hooks */ \"perf_hooks\")},6464:t=>{\"use strict\";t.exports=__webpack_require__(/*! util */ \"util\")},4564:t=>{\"use strict\";t.exports=__webpack_require__(/*! worker_threads */ \"worker_threads\")},6207:t=>{\"use strict\";t.exports=__webpack_require__(/*! onnxruntime-common */ \"(ssr)/./node_modules/onnxruntime-common/dist/ort-common.node.js\")},6113:t=>{\"use strict\";t.exports=__webpack_require__(/*! crypto */ \"crypto\")},5686:(t,e,n)=>{\"use strict\";n.r(e),n.d(e,{flatbuffers:()=>r});var r={};r.Offset,r.Table,r.SIZEOF_SHORT=2,r.SIZEOF_INT=4,r.FILE_IDENTIFIER_LENGTH=4,r.SIZE_PREFIX_LENGTH=4,r.Encoding={UTF8_BYTES:1,UTF16_STRING:2},r.int32=new Int32Array(2),r.float32=new Float32Array(r.int32.buffer),r.float64=new Float64Array(r.int32.buffer),r.isLittleEndian=1===new Uint16Array(new Uint8Array([1,0]).buffer)[0],r.Long=function(t,e){this.low=0|t,this.high=0|e},r.Long.create=function(t,e){return 0==t&&0==e?r.Long.ZERO:new r.Long(t,e)},r.Long.prototype.toFloat64=function(){return(this.low>>>0)+4294967296*this.high},r.Long.prototype.equals=function(t){return this.low==t.low&&this.high==t.high},r.Long.ZERO=new r.Long(0,0),r.Builder=function(t){if(t)e=t;else var e=1024;this.bb=r.ByteBuffer.allocate(e),this.space=e,this.minalign=1,this.vtable=null,this.vtable_in_use=0,this.isNested=!1,this.object_start=0,this.vtables=[],this.vector_num_elems=0,this.force_defaults=!1},r.Builder.prototype.clear=function(){this.bb.clear(),this.space=this.bb.capacity(),this.minalign=1,this.vtable=null,this.vtable_in_use=0,this.isNested=!1,this.object_start=0,this.vtables=[],this.vector_num_elems=0,this.force_defaults=!1},r.Builder.prototype.forceDefaults=function(t){this.force_defaults=t},r.Builder.prototype.dataBuffer=function(){return this.bb},r.Builder.prototype.asUint8Array=function(){return this.bb.bytes().subarray(this.bb.position(),this.bb.position()+this.offset())},r.Builder.prototype.prep=function(t,e){t>this.minalign&&(this.minalign=t);for(var n=1+~(this.bb.capacity()-this.space+e)&t-1;this.space<n+t+e;){var i=this.bb.capacity();this.bb=r.Builder.growByteBuffer(this.bb),this.space+=this.bb.capacity()-i}this.pad(n)},r.Builder.prototype.pad=function(t){for(var e=0;e<t;e++)this.bb.writeInt8(--this.space,0)},r.Builder.prototype.writeInt8=function(t){this.bb.writeInt8(this.space-=1,t)},r.Builder.prototype.writeInt16=function(t){this.bb.writeInt16(this.space-=2,t)},r.Builder.prototype.writeInt32=function(t){this.bb.writeInt32(this.space-=4,t)},r.Builder.prototype.writeInt64=function(t){this.bb.writeInt64(this.space-=8,t)},r.Builder.prototype.writeFloat32=function(t){this.bb.writeFloat32(this.space-=4,t)},r.Builder.prototype.writeFloat64=function(t){this.bb.writeFloat64(this.space-=8,t)},r.Builder.prototype.addInt8=function(t){this.prep(1,0),this.writeInt8(t)},r.Builder.prototype.addInt16=function(t){this.prep(2,0),this.writeInt16(t)},r.Builder.prototype.addInt32=function(t){this.prep(4,0),this.writeInt32(t)},r.Builder.prototype.addInt64=function(t){this.prep(8,0),this.writeInt64(t)},r.Builder.prototype.addFloat32=function(t){this.prep(4,0),this.writeFloat32(t)},r.Builder.prototype.addFloat64=function(t){this.prep(8,0),this.writeFloat64(t)},r.Builder.prototype.addFieldInt8=function(t,e,n){(this.force_defaults||e!=n)&&(this.addInt8(e),this.slot(t))},r.Builder.prototype.addFieldInt16=function(t,e,n){(this.force_defaults||e!=n)&&(this.addInt16(e),this.slot(t))},r.Builder.prototype.addFieldInt32=function(t,e,n){(this.force_defaults||e!=n)&&(this.addInt32(e),this.slot(t))},r.Builder.prototype.addFieldInt64=function(t,e,n){!this.force_defaults&&e.equals(n)||(this.addInt64(e),this.slot(t))},r.Builder.prototype.addFieldFloat32=function(t,e,n){(this.force_defaults||e!=n)&&(this.addFloat32(e),this.slot(t))},r.Builder.prototype.addFieldFloat64=function(t,e,n){(this.force_defaults||e!=n)&&(this.addFloat64(e),this.slot(t))},r.Builder.prototype.addFieldOffset=function(t,e,n){(this.force_defaults||e!=n)&&(this.addOffset(e),this.slot(t))},r.Builder.prototype.addFieldStruct=function(t,e,n){e!=n&&(this.nested(e),this.slot(t))},r.Builder.prototype.nested=function(t){if(t!=this.offset())throw new Error(\"FlatBuffers: struct must be serialized inline.\")},r.Builder.prototype.notNested=function(){if(this.isNested)throw new Error(\"FlatBuffers: object serialization must not be nested.\")},r.Builder.prototype.slot=function(t){this.vtable[t]=this.offset()},r.Builder.prototype.offset=function(){return this.bb.capacity()-this.space},r.Builder.growByteBuffer=function(t){var e=t.capacity();if(3221225472&e)throw new Error(\"FlatBuffers: cannot grow buffer beyond 2 gigabytes.\");var n=e<<1,i=r.ByteBuffer.allocate(n);return i.setPosition(n-e),i.bytes().set(t.bytes(),n-e),i},r.Builder.prototype.addOffset=function(t){this.prep(r.SIZEOF_INT,0),this.writeInt32(this.offset()-t+r.SIZEOF_INT)},r.Builder.prototype.startObject=function(t){this.notNested(),null==this.vtable&&(this.vtable=[]),this.vtable_in_use=t;for(var e=0;e<t;e++)this.vtable[e]=0;this.isNested=!0,this.object_start=this.offset()},r.Builder.prototype.endObject=function(){if(null==this.vtable||!this.isNested)throw new Error(\"FlatBuffers: endObject called without startObject\");this.addInt32(0);for(var t=this.offset(),e=this.vtable_in_use-1;e>=0&&0==this.vtable[e];e--);for(var n=e+1;e>=0;e--)this.addInt16(0!=this.vtable[e]?t-this.vtable[e]:0);this.addInt16(t-this.object_start);var i=(n+2)*r.SIZEOF_SHORT;this.addInt16(i);var o=0,a=this.space;t:for(e=0;e<this.vtables.length;e++){var s=this.bb.capacity()-this.vtables[e];if(i==this.bb.readInt16(s)){for(var u=r.SIZEOF_SHORT;u<i;u+=r.SIZEOF_SHORT)if(this.bb.readInt16(a+u)!=this.bb.readInt16(s+u))continue t;o=this.vtables[e];break}}return o?(this.space=this.bb.capacity()-t,this.bb.writeInt32(this.space,o-t)):(this.vtables.push(this.offset()),this.bb.writeInt32(this.bb.capacity()-t,this.offset()-t)),this.isNested=!1,t},r.Builder.prototype.finish=function(t,e,n){var i=n?r.SIZE_PREFIX_LENGTH:0;if(e){var o=e;if(this.prep(this.minalign,r.SIZEOF_INT+r.FILE_IDENTIFIER_LENGTH+i),o.length!=r.FILE_IDENTIFIER_LENGTH)throw new Error(\"FlatBuffers: file identifier must be length \"+r.FILE_IDENTIFIER_LENGTH);for(var a=r.FILE_IDENTIFIER_LENGTH-1;a>=0;a--)this.writeInt8(o.charCodeAt(a))}this.prep(this.minalign,r.SIZEOF_INT+i),this.addOffset(t),i&&this.addInt32(this.bb.capacity()-this.space),this.bb.setPosition(this.space)},r.Builder.prototype.finishSizePrefixed=function(t,e){this.finish(t,e,!0)},r.Builder.prototype.requiredField=function(t,e){var n=this.bb.capacity()-t,r=n-this.bb.readInt32(n);if(0==this.bb.readInt16(r+e))throw new Error(\"FlatBuffers: field \"+e+\" must be set\")},r.Builder.prototype.startVector=function(t,e,n){this.notNested(),this.vector_num_elems=e,this.prep(r.SIZEOF_INT,t*e),this.prep(n,t*e)},r.Builder.prototype.endVector=function(){return this.writeInt32(this.vector_num_elems),this.offset()},r.Builder.prototype.createString=function(t){if(t instanceof Uint8Array)var e=t;else{e=[];for(var n=0;n<t.length;){var r,i=t.charCodeAt(n++);(r=i<55296||i>=56320?i:(i<<10)+t.charCodeAt(n++)+-56613888)<128?e.push(r):(r<2048?e.push(r>>6&31|192):(r<65536?e.push(r>>12&15|224):e.push(r>>18&7|240,r>>12&63|128),e.push(r>>6&63|128)),e.push(63&r|128))}}this.addInt8(0),this.startVector(1,e.length,1),this.bb.setPosition(this.space-=e.length),n=0;for(var o=this.space,a=this.bb.bytes();n<e.length;n++)a[o++]=e[n];return this.endVector()},r.Builder.prototype.createLong=function(t,e){return r.Long.create(t,e)},r.ByteBuffer=function(t){this.bytes_=t,this.position_=0},r.ByteBuffer.allocate=function(t){return new r.ByteBuffer(new Uint8Array(t))},r.ByteBuffer.prototype.clear=function(){this.position_=0},r.ByteBuffer.prototype.bytes=function(){return this.bytes_},r.ByteBuffer.prototype.position=function(){return this.position_},r.ByteBuffer.prototype.setPosition=function(t){this.position_=t},r.ByteBuffer.prototype.capacity=function(){return this.bytes_.length},r.ByteBuffer.prototype.readInt8=function(t){return this.readUint8(t)<<24>>24},r.ByteBuffer.prototype.readUint8=function(t){return this.bytes_[t]},r.ByteBuffer.prototype.readInt16=function(t){return this.readUint16(t)<<16>>16},r.ByteBuffer.prototype.readUint16=function(t){return this.bytes_[t]|this.bytes_[t+1]<<8},r.ByteBuffer.prototype.readInt32=function(t){return this.bytes_[t]|this.bytes_[t+1]<<8|this.bytes_[t+2]<<16|this.bytes_[t+3]<<24},r.ByteBuffer.prototype.readUint32=function(t){return this.readInt32(t)>>>0},r.ByteBuffer.prototype.readInt64=function(t){return new r.Long(this.readInt32(t),this.readInt32(t+4))},r.ByteBuffer.prototype.readUint64=function(t){return new r.Long(this.readUint32(t),this.readUint32(t+4))},r.ByteBuffer.prototype.readFloat32=function(t){return r.int32[0]=this.readInt32(t),r.float32[0]},r.ByteBuffer.prototype.readFloat64=function(t){return r.int32[r.isLittleEndian?0:1]=this.readInt32(t),r.int32[r.isLittleEndian?1:0]=this.readInt32(t+4),r.float64[0]},r.ByteBuffer.prototype.writeInt8=function(t,e){this.bytes_[t]=e},r.ByteBuffer.prototype.writeUint8=function(t,e){this.bytes_[t]=e},r.ByteBuffer.prototype.writeInt16=function(t,e){this.bytes_[t]=e,this.bytes_[t+1]=e>>8},r.ByteBuffer.prototype.writeUint16=function(t,e){this.bytes_[t]=e,this.bytes_[t+1]=e>>8},r.ByteBuffer.prototype.writeInt32=function(t,e){this.bytes_[t]=e,this.bytes_[t+1]=e>>8,this.bytes_[t+2]=e>>16,this.bytes_[t+3]=e>>24},r.ByteBuffer.prototype.writeUint32=function(t,e){this.bytes_[t]=e,this.bytes_[t+1]=e>>8,this.bytes_[t+2]=e>>16,this.bytes_[t+3]=e>>24},r.ByteBuffer.prototype.writeInt64=function(t,e){this.writeInt32(t,e.low),this.writeInt32(t+4,e.high)},r.ByteBuffer.prototype.writeUint64=function(t,e){this.writeUint32(t,e.low),this.writeUint32(t+4,e.high)},r.ByteBuffer.prototype.writeFloat32=function(t,e){r.float32[0]=e,this.writeInt32(t,r.int32[0])},r.ByteBuffer.prototype.writeFloat64=function(t,e){r.float64[0]=e,this.writeInt32(t,r.int32[r.isLittleEndian?0:1]),this.writeInt32(t+4,r.int32[r.isLittleEndian?1:0])},r.ByteBuffer.prototype.getBufferIdentifier=function(){if(this.bytes_.length<this.position_+r.SIZEOF_INT+r.FILE_IDENTIFIER_LENGTH)throw new Error(\"FlatBuffers: ByteBuffer is too short to contain an identifier.\");for(var t=\"\",e=0;e<r.FILE_IDENTIFIER_LENGTH;e++)t+=String.fromCharCode(this.readInt8(this.position_+r.SIZEOF_INT+e));return t},r.ByteBuffer.prototype.__offset=function(t,e){var n=t-this.readInt32(t);return e<this.readInt16(n)?this.readInt16(n+e):0},r.ByteBuffer.prototype.__union=function(t,e){return t.bb_pos=e+this.readInt32(e),t.bb=this,t},r.ByteBuffer.prototype.__string=function(t,e){t+=this.readInt32(t);var n=this.readInt32(t),i=\"\",o=0;if(t+=r.SIZEOF_INT,e===r.Encoding.UTF8_BYTES)return this.bytes_.subarray(t,t+n);for(;o<n;){var a,s=this.readUint8(t+o++);if(s<192)a=s;else{var u=this.readUint8(t+o++);if(s<224)a=(31&s)<<6|63&u;else{var c=this.readUint8(t+o++);a=s<240?(15&s)<<12|(63&u)<<6|63&c:(7&s)<<18|(63&u)<<12|(63&c)<<6|63&this.readUint8(t+o++)}}a<65536?i+=String.fromCharCode(a):(a-=65536,i+=String.fromCharCode(55296+(a>>10),56320+(1023&a)))}return i},r.ByteBuffer.prototype.__indirect=function(t){return t+this.readInt32(t)},r.ByteBuffer.prototype.__vector=function(t){return t+this.readInt32(t)+r.SIZEOF_INT},r.ByteBuffer.prototype.__vector_len=function(t){return this.readInt32(t+this.readInt32(t))},r.ByteBuffer.prototype.__has_identifier=function(t){if(t.length!=r.FILE_IDENTIFIER_LENGTH)throw new Error(\"FlatBuffers: file identifier must be length \"+r.FILE_IDENTIFIER_LENGTH);for(var e=0;e<r.FILE_IDENTIFIER_LENGTH;e++)if(t.charCodeAt(e)!=this.readInt8(this.position_+r.SIZEOF_INT+e))return!1;return!0},r.ByteBuffer.prototype.createLong=function(t,e){return r.Long.create(t,e)}}},__webpack_module_cache__={};function __nested_webpack_require_546448__(t){var e=__webpack_module_cache__[t];if(void 0!==e)return e.exports;var n=__webpack_module_cache__[t]={exports:{}};return __webpack_modules__[t].call(n.exports,n,n.exports,__nested_webpack_require_546448__),n.exports}__nested_webpack_require_546448__.n=t=>{var e=t&&t.__esModule?()=>t.default:()=>t;return __nested_webpack_require_546448__.d(e,{a:e}),e},__nested_webpack_require_546448__.d=(t,e)=>{for(var n in e)__nested_webpack_require_546448__.o(e,n)&&!__nested_webpack_require_546448__.o(t,n)&&Object.defineProperty(t,n,{enumerable:!0,get:e[n]})},__nested_webpack_require_546448__.o=(t,e)=>Object.prototype.hasOwnProperty.call(t,e),__nested_webpack_require_546448__.r=t=>{\"undefined\"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:\"Module\"}),Object.defineProperty(t,\"__esModule\",{value:!0})};var __nested_webpack_exports__=__nested_webpack_require_546448__(6018),__webpack_export_target__=exports;for(var i in __nested_webpack_exports__)__webpack_export_target__[i]=__nested_webpack_exports__[i];__nested_webpack_exports__.__esModule&&Object.defineProperty(__webpack_export_target__,\"__esModule\",{value:!0})})();\n//# sourceMappingURL=ort-web.node.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb25ueHJ1bnRpbWUtd2ViL2Rpc3Qvb3J0LXdlYi5ub2RlLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLHlCQUF5QixlQUFlLHlKQUF5SixhQUFhLGtDQUFrQyxhQUFhLGtDQUFrQyxhQUFhLGtDQUFrQyxhQUFhLGtDQUFrQyxhQUFhLGtDQUFrQyxVQUFVLE9BQU8sc0JBQXNCLHFDQUFxQyxRQUFRLEdBQUcsa0NBQWtDLGlDQUFpQyxRQUFRLHdNQUF3TSxjQUFjLDBDQUEwQyxNQUFNLE1BQU0sZ0RBQWdELHlCQUF5QixpQkFBaUIsOERBQThELGdFQUFnRSxpREFBaUQsbUJBQW1CLEdBQUcsaUlBQWlJLDhCQUE4QixnREFBZ0QsUUFBUSxhQUFhLGtDQUFrQyxtRUFBbUUsc0JBQXNCLG9DQUFvQyxJQUFJLFVBQVUsU0FBUyxpSUFBaUksdUJBQXVCLGdQQUFnUCx5QkFBeUIsc0RBQXNELFdBQVcseUJBQXlCLCtGQUErRixjQUFjLHlCQUF5Qiw4REFBOEQseURBQXlELDBCQUEwQixHQUFHLDRFQUE0RSw2REFBNkQsK0RBQStELG1DQUFtQyw2R0FBNkcsMEJBQTBCLG9FQUFvRSwwRkFBMEYsa0JBQWtCLGlCQUFpQixRQUFRLGNBQWMsS0FBSywyR0FBMkcsU0FBUyxJQUFJLEVBQUUsYUFBYSxVQUFVLGdCQUFnQixvREFBb0QsS0FBSyxnQkFBZ0IsK0pBQStKLCtCQUErQixTQUFTLGdCQUFnQiw2QkFBNkIsb0JBQW9CLG1CQUFtQixhQUFhLFFBQVEsWUFBWSxXQUFXLEtBQUssc0JBQXNCLCtFQUErRSxjQUFjLGFBQWEsS0FBSyxZQUFZLGdCQUFnQixvQkFBb0IsS0FBSyxhQUFhLGdCQUFnQixxQkFBcUIsS0FBSyxnQkFBZ0IsNkNBQTZDLHVCQUF1QixxQkFBcUIsc0JBQXNCLGNBQWMsZ0JBQWdCLFdBQVcsS0FBSyxzQkFBc0IsMkRBQTJELFNBQVMsY0FBYyw4T0FBOE8sZ0JBQWdCLGlDQUFp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QWlELDhDQUE4QyxnREFBZ0QsK0NBQStDLHFCQUFxQixpQ0FBaUMsZ0ZBQWdGLEtBQUssSUFBSSxFQUFFLDhCQUE4QixhQUFhLEtBQUssNEJBQTRCLDBCQUEwQixLQUFLLDRCQUE0QiwyRkFBMkYsa0dBQWtHLFNBQVMsK0NBQStDLDJCQUEyQiw2Q0FBNkMsd0NBQXdDLGlEQUFpRCwyQ0FBMkMscURBQXFELCtIQUErSCxZQUFZLDJCQUEyQiw4RUFBOEUsU0FBUyxpREFBaUQsNEJBQTRCLDZCQUE2QixTQUFTLGlDQUFtQixJQUFJLGtDQUFrQywrQkFBK0IsbUNBQW1DLFlBQVkseURBQXlELGlDQUFtQixZQUFZLGlDQUFtQixPQUFPLDBDQUEwQyxPQUFPLGlDQUFtQixNQUFNLElBQUksSUFBSSxDQUFDLGlDQUFtQixXQUFXLGVBQWUsaUNBQW1CLFVBQVUsaUNBQW1CLG9DQUFvQyx1QkFBdUIsRUFBRSxDQUFDLGlDQUFtQixvREFBb0QsaUNBQW1CLE9BQU8sNEZBQTRGLGVBQWUsd0NBQXdDLFNBQVMsR0FBRyxJQUFJLDBCQUFtQixDQUFDLGlDQUFtQix5Q0FBeUMsYUFBYSwwQkFBbUIsOEJBQThCLDBCQUFtQixJQUFJLDBCQUFtQiwyRUFBMkUsU0FBUyxFQUFFO0FBQ2xodGhCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdHJhbnNmb3JtZXJzanMtcGxheWdyb3VuZC8uL25vZGVfbW9kdWxlcy9vbm54cnVudGltZS13ZWIvZGlzdC9vcnQtd2ViLm5vZGUuanM/YmNkYiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiogT05OWCBSdW50aW1lIFdlYiB2MS4xNC4wXG4qIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4qL1xuKCgpPT57dmFyIF9fd2VicGFja19tb2R1bGVzX189ezM0NzQ6KHQsZSxuKT0+e3ZhciBfc2NyaXB0RGlyLHI9KF9zY3JpcHREaXI9KF9zY3JpcHREaXI9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGRvY3VtZW50JiZkb2N1bWVudC5jdXJyZW50U2NyaXB0P2RvY3VtZW50LmN1cnJlbnRTY3JpcHQuc3JjOnZvaWQgMCl8fF9fZmlsZW5hbWUsZnVuY3Rpb24odCl7ZnVuY3Rpb24gZSgpe3JldHVybiAkLmJ1ZmZlciE9QyYmSCgkLmJ1ZmZlciksRn1mdW5jdGlvbiByKCl7cmV0dXJuICQuYnVmZmVyIT1DJiZIKCQuYnVmZmVyKSxOfWZ1bmN0aW9uIGkoKXtyZXR1cm4gJC5idWZmZXIhPUMmJkgoJC5idWZmZXIpLFJ9ZnVuY3Rpb24gbygpe3JldHVybiAkLmJ1ZmZlciE9QyYmSCgkLmJ1ZmZlciksTH1mdW5jdGlvbiBhKCl7cmV0dXJuICQuYnVmZmVyIT1DJiZIKCQuYnVmZmVyKSxNfXZhciBzLHUsYzt0PXR8fHt9LHN8fChzPXZvaWQgMCE9PXQ/dDp7fSkscy5yZWFkeT1uZXcgUHJvbWlzZSgoZnVuY3Rpb24odCxlKXt1PXQsYz1lfSkpO3ZhciBsLHAsZixkLGgsZyxiPU9iamVjdC5hc3NpZ24oe30scyksbT1cIi4vdGhpcy5wcm9ncmFtXCIseT0odCxlKT0+e3Rocm93IGV9LF89XCJvYmplY3RcIj09dHlwZW9mIHdpbmRvdyx2PVwiZnVuY3Rpb25cIj09dHlwZW9mIGltcG9ydFNjcmlwdHMsdz1cIm9iamVjdFwiPT10eXBlb2YgcHJvY2VzcyYmXCJvYmplY3RcIj09dHlwZW9mIHByb2Nlc3MudmVyc2lvbnMmJlwic3RyaW5nXCI9PXR5cGVvZiBwcm9jZXNzLnZlcnNpb25zLm5vZGUseD1zLkVOVklST05NRU5UX0lTX1BUSFJFQUR8fCExLFQ9XCJcIjtmdW5jdGlvbiBTKHQpe3JldHVybiBzLmxvY2F0ZUZpbGU/cy5sb2NhdGVGaWxlKHQsVCk6VCt0fWlmKHcpe2xldCBlO1Q9dj9uKDE0MjMpLmRpcm5hbWUoVCkrXCIvXCI6X19kaXJuYW1lK1wiL1wiLGc9KCk9PntofHwoZD1uKDYyMzEpLGg9bigxNDIzKSl9LGw9ZnVuY3Rpb24odCxlKXtyZXR1cm4gZygpLHQ9aC5ub3JtYWxpemUodCksZC5yZWFkRmlsZVN5bmModCxlP3ZvaWQgMDpcInV0ZjhcIil9LGY9dD0+KCh0PWwodCwhMCkpLmJ1ZmZlcnx8KHQ9bmV3IFVpbnQ4QXJyYXkodCkpLHQpLHA9KHQsZSxuKT0+e2coKSx0PWgubm9ybWFsaXplKHQpLGQucmVhZEZpbGUodCwoZnVuY3Rpb24odCxyKXt0P24odCk6ZShyLmJ1ZmZlcil9KSl9LDE8cHJvY2Vzcy5hcmd2Lmxlbmd0aCYmKG09cHJvY2Vzcy5hcmd2WzFdLnJlcGxhY2UoL1xcXFwvZyxcIi9cIikpLHByb2Nlc3MuYXJndi5zbGljZSgyKSxwcm9jZXNzLm9uKFwidW5jYXVnaHRFeGNlcHRpb25cIiwoZnVuY3Rpb24odCl7aWYoISh0IGluc3RhbmNlb2YgdXQpKXRocm93IHR9KSkscHJvY2Vzcy5vbihcInVuaGFuZGxlZFJlamVjdGlvblwiLChmdW5jdGlvbih0KXt0aHJvdyB0fSkpLHk9KHQsZSk9PntpZihKKCkpdGhyb3cgcHJvY2Vzcy5leGl0Q29kZT10LGU7ZSBpbnN0YW5jZW9mIHV0fHxQKFwiZXhpdGluZyBkdWUgdG8gZXhjZXB0aW9uOiBcIitlKSxwcm9jZXNzLmV4aXQodCl9LHMuaW5zcGVjdD1mdW5jdGlvbigpe3JldHVyblwiW0Vtc2NyaXB0ZW4gTW9kdWxlIG9iamVjdF1cIn07dHJ5e2U9big0NTY0KX1jYXRjaCh0KXt0aHJvdyBjb25zb2xlLmVycm9yKCdUaGUgXCJ3b3JrZXJfdGhyZWFkc1wiIG1vZHVsZSBpcyBub3Qgc3VwcG9ydGVkIGluIHRoaXMgbm9kZS5qcyBidWlsZCAtIHBlcmhhcHMgYSBuZXdlciB2ZXJzaW9uIGlzIG5lZWRlZD8nKSx0fWdsb2JhbC5Xb3JrZXI9ZS5Xb3JrZXJ9ZWxzZShffHx2KSYmKHY/VD1zZWxmLmxvY2F0aW9uLmhyZWY6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGRvY3VtZW50JiZkb2N1bWVudC5jdXJyZW50U2NyaXB0JiYoVD1kb2N1bWVudC5jdXJyZW50U2NyaXB0LnNyYyksX3NjcmlwdERpciYmKFQ9X3NjcmlwdERpciksVD0wIT09VC5pbmRleE9mKFwiYmxvYjpcIik/VC5zdWJzdHIoMCxULnJlcGxhY2UoL1s/I10uKi8sXCJcIikubGFzdEluZGV4T2YoXCIvXCIpKzEpOlwiXCIsd3x8KGw9dD0+e3ZhciBlPW5ldyBYTUxIdHRwUmVxdWVzdDtyZXR1cm4gZS5vcGVuKFwiR0VUXCIsdCwhMSksZS5zZW5kKG51bGwpLGUucmVzcG9uc2VUZXh0fSx2JiYoZj10PT57dmFyIGU9bmV3IFhNTEh0dHBSZXF1ZXN0O3JldHVybiBlLm9wZW4oXCJHRVRcIix0LCExKSxlLnJlc3BvbnNlVHlwZT1cImFycmF5YnVmZmVyXCIsZS5zZW5kKG51bGwpLG5ldyBVaW50OEFycmF5KGUucmVzcG9uc2UpfSkscD0odCxlLG4pPT57dmFyIHI9bmV3IFhNTEh0dHBSZXF1ZXN0O3Iub3BlbihcIkdFVFwiLHQsITApLHIucmVzcG9uc2VUeXBlPVwiYXJyYXlidWZmZXJcIixyLm9ubG9hZD0oKT0+ezIwMD09ci5zdGF0dXN8fDA9PXIuc3RhdHVzJiZyLnJlc3BvbnNlP2Uoci5yZXNwb25zZSk6bigpfSxyLm9uZXJyb3I9bixyLnNlbmQobnVsbCl9KSk7dyYmXCJ1bmRlZmluZWRcIj09dHlwZW9mIHBlcmZvcm1hbmNlJiYoZ2xvYmFsLnBlcmZvcm1hbmNlPW4oNDk4KS5wZXJmb3JtYW5jZSk7dmFyIE89Y29uc29sZS5sb2cuYmluZChjb25zb2xlKSxBPWNvbnNvbGUud2Fybi5iaW5kKGNvbnNvbGUpO3cmJihnKCksTz10PT5kLndyaXRlU3luYygxLHQrXCJcXG5cIiksQT10PT5kLndyaXRlU3luYygyLHQrXCJcXG5cIikpO3ZhciBFLEk9cy5wcmludHx8TyxQPXMucHJpbnRFcnJ8fEE7T2JqZWN0LmFzc2lnbihzLGIpLGI9bnVsbCxzLnRoaXNQcm9ncmFtJiYobT1zLnRoaXNQcm9ncmFtKSxzLnF1aXQmJih5PXMucXVpdCkscy53YXNtQmluYXJ5JiYoRT1zLndhc21CaW5hcnkpO3ZhciBEPXMubm9FeGl0UnVudGltZXx8ITE7XCJvYmplY3RcIiE9dHlwZW9mIFdlYkFzc2VtYmx5JiZpdChcIm5vIG5hdGl2ZSB3YXNtIHN1cHBvcnQgZGV0ZWN0ZWRcIik7dmFyICQsayxDLEYsTixSLEwsTSxqPSExLFU9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIFRleHREZWNvZGVyP25ldyBUZXh0RGVjb2RlcihcInV0ZjhcIik6dm9pZCAwO2Z1bmN0aW9uIFYodCxlLG4pe3ZhciByPShlPj4+PTApK247Zm9yKG49ZTt0W25dJiYhKG4+PXIpOykrK247aWYoMTY8bi1lJiZ0LmJ1ZmZlciYmVSlyZXR1cm4gVS5kZWNvZGUodC5idWZmZXIgaW5zdGFuY2VvZiBTaGFyZWRBcnJheUJ1ZmZlcj90LnNsaWNlKGUsbik6dC5zdWJhcnJheShlLG4pKTtmb3Iocj1cIlwiO2U8bjspe3ZhciBpPXRbZSsrXTtpZigxMjgmaSl7dmFyIG89NjMmdFtlKytdO2lmKDE5Mj09KDIyNCZpKSlyKz1TdHJpbmcuZnJvbUNoYXJDb2RlKCgzMSZpKTw8NnxvKTtlbHNle3ZhciBhPTYzJnRbZSsrXTs2NTUzNj4oaT0yMjQ9PSgyNDAmaSk/KDE1JmkpPDwxMnxvPDw2fGE6KDcmaSk8PDE4fG88PDEyfGE8PDZ8NjMmdFtlKytdKT9yKz1TdHJpbmcuZnJvbUNoYXJDb2RlKGkpOihpLT02NTUzNixyKz1TdHJpbmcuZnJvbUNoYXJDb2RlKDU1Mjk2fGk+PjEwLDU2MzIwfDEwMjMmaSkpfX1lbHNlIHIrPVN0cmluZy5mcm9tQ2hhckNvZGUoaSl9cmV0dXJuIHJ9ZnVuY3Rpb24gQih0LGUpe3JldHVybih0Pj4+PTApP1YocigpLHQsZSk6XCJcIn1mdW5jdGlvbiB6KHQsZSxuLHIpe2lmKCEoMDxyKSlyZXR1cm4gMDt2YXIgaT1uPj4+PTA7cj1uK3ItMTtmb3IodmFyIG89MDtvPHQubGVuZ3RoOysrbyl7dmFyIGE9dC5jaGFyQ29kZUF0KG8pO2lmKDU1Mjk2PD1hJiY1NzM0Mz49YSYmKGE9NjU1MzYrKCgxMDIzJmEpPDwxMCl8MTAyMyZ0LmNoYXJDb2RlQXQoKytvKSksMTI3Pj1hKXtpZihuPj1yKWJyZWFrO2VbbisrPj4+MF09YX1lbHNle2lmKDIwNDc+PWEpe2lmKG4rMT49cilicmVhaztlW24rKz4+PjBdPTE5MnxhPj42fWVsc2V7aWYoNjU1MzU+PWEpe2lmKG4rMj49cilicmVhaztlW24rKz4+PjBdPTIyNHxhPj4xMn1lbHNle2lmKG4rMz49cilicmVhaztlW24rKz4+PjBdPTI0MHxhPj4xOCxlW24rKz4+PjBdPTEyOHxhPj4xMiY2M31lW24rKz4+PjBdPTEyOHxhPj42JjYzfWVbbisrPj4+MF09MTI4fDYzJmF9fXJldHVybiBlW24+Pj4wXT0wLG4taX1mdW5jdGlvbiBHKHQpe2Zvcih2YXIgZT0wLG49MDtuPHQubGVuZ3RoOysrbil7dmFyIHI9dC5jaGFyQ29kZUF0KG4pOzEyNz49cj9lKys6MjA0Nz49cj9lKz0yOjU1Mjk2PD1yJiY1NzM0Mz49cj8oZSs9NCwrK24pOmUrPTN9cmV0dXJuIGV9ZnVuY3Rpb24gSCh0KXtDPXQscy5IRUFQOD1GPW5ldyBJbnQ4QXJyYXkodCkscy5IRUFQMTY9bmV3IEludDE2QXJyYXkodCkscy5IRUFQMzI9Uj1uZXcgSW50MzJBcnJheSh0KSxzLkhFQVBVOD1OPW5ldyBVaW50OEFycmF5KHQpLHMuSEVBUFUxNj1uZXcgVWludDE2QXJyYXkodCkscy5IRUFQVTMyPUw9bmV3IFVpbnQzMkFycmF5KHQpLHMuSEVBUEYzMj1uZXcgRmxvYXQzMkFycmF5KHQpLHMuSEVBUEY2ND1NPW5ldyBGbG9hdDY0QXJyYXkodCl9eCYmKEM9cy5idWZmZXIpO3ZhciBxPXMuSU5JVElBTF9NRU1PUll8fDE2Nzc3MjE2O2lmKHgpJD1zLndhc21NZW1vcnksQz1zLmJ1ZmZlcjtlbHNlIGlmKHMud2FzbU1lbW9yeSkkPXMud2FzbU1lbW9yeTtlbHNlIGlmKCEoKCQ9bmV3IFdlYkFzc2VtYmx5Lk1lbW9yeSh7aW5pdGlhbDpxLzY1NTM2LG1heGltdW06NjU1MzYsc2hhcmVkOiEwfSkpLmJ1ZmZlciBpbnN0YW5jZW9mIFNoYXJlZEFycmF5QnVmZmVyKSl0aHJvdyBQKFwicmVxdWVzdGVkIGEgc2hhcmVkIFdlYkFzc2VtYmx5Lk1lbW9yeSBidXQgdGhlIHJldHVybmVkIGJ1ZmZlciBpcyBub3QgYSBTaGFyZWRBcnJheUJ1ZmZlciwgaW5kaWNhdGluZyB0aGF0IHdoaWxlIHRoZSBicm93c2VyIGhhcyBTaGFyZWRBcnJheUJ1ZmZlciBpdCBkb2VzIG5vdCBoYXZlIFdlYkFzc2VtYmx5IHRocmVhZHMgc3VwcG9ydCAtIHlvdSBtYXkgbmVlZCB0byBzZXQgYSBmbGFnXCIpLHcmJmNvbnNvbGUubG9nKFwiKG9uIG5vZGUgeW91IG1heSBuZWVkOiAtLWV4cGVyaW1lbnRhbC13YXNtLXRocmVhZHMgLS1leHBlcmltZW50YWwtd2FzbS1idWxrLW1lbW9yeSBhbmQgYWxzbyB1c2UgYSByZWNlbnQgdmVyc2lvbilcIiksRXJyb3IoXCJiYWQgbWVtb3J5XCIpOyQmJihDPSQuYnVmZmVyKSxxPUMuYnl0ZUxlbmd0aCxIKEMpO3ZhciBXLFg9W10sWT1bXSxLPVtdLFo9W107ZnVuY3Rpb24gSigpe3JldHVybiBEfHwhMX1mdW5jdGlvbiBRKCl7dmFyIHQ9cy5wcmVSdW4uc2hpZnQoKTtYLnVuc2hpZnQodCl9dmFyIHR0LGV0PTAsbnQ9bnVsbCxydD1udWxsO2Z1bmN0aW9uIGl0KHQpe3Rocm93IHg/cG9zdE1lc3NhZ2Uoe2NtZDpcIm9uQWJvcnRcIixhcmc6dH0pOnMub25BYm9ydCYmcy5vbkFib3J0KHQpLFAodD1cIkFib3J0ZWQoXCIrdCtcIilcIiksaj0hMCx0PW5ldyBXZWJBc3NlbWJseS5SdW50aW1lRXJyb3IodCtcIi4gQnVpbGQgd2l0aCAtc0FTU0VSVElPTlMgZm9yIG1vcmUgaW5mby5cIiksYyh0KSx0fWZ1bmN0aW9uIG90KCl7cmV0dXJuIHR0LnN0YXJ0c1dpdGgoXCJkYXRhOmFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbTtiYXNlNjQsXCIpfWZ1bmN0aW9uIGF0KCl7dmFyIHQ9dHQ7dHJ5e2lmKHQ9PXR0JiZFKXJldHVybiBuZXcgVWludDhBcnJheShFKTtpZihmKXJldHVybiBmKHQpO3Rocm93XCJib3RoIGFzeW5jIGFuZCBzeW5jIGZldGNoaW5nIG9mIHRoZSB3YXNtIGZhaWxlZFwifWNhdGNoKHQpe2l0KHQpfX10dD1cIm9ydC13YXNtLXRocmVhZGVkLndhc21cIixvdCgpfHwodHQ9Uyh0dCkpO3ZhciBzdD17fTtmdW5jdGlvbiB1dCh0KXt0aGlzLm5hbWU9XCJFeGl0U3RhdHVzXCIsdGhpcy5tZXNzYWdlPVwiUHJvZ3JhbSB0ZXJtaW5hdGVkIHdpdGggZXhpdChcIit0K1wiKVwiLHRoaXMuc3RhdHVzPXR9ZnVuY3Rpb24gY3QodCl7KHQ9ZHQuVmJbdF0pfHxpdCgpLGR0Lm1jKHQpfWZ1bmN0aW9uIGx0KHQpe3ZhciBlPWR0LkNjKCk7aWYoIWUpcmV0dXJuIDY7ZHQuYWMucHVzaChlKSxkdC5WYlt0LlViXT1lLGUuVWI9dC5VYjt2YXIgbj17Y21kOlwicnVuXCIsc3RhcnRfcm91dGluZTp0LkljLGFyZzp0LnpjLHB0aHJlYWRfcHRyOnQuVWJ9O3JldHVybiBlLiRiPSgpPT57bi50aW1lPXBlcmZvcm1hbmNlLm5vdygpLGUucG9zdE1lc3NhZ2Uobix0Lk5jKX0sZS5sb2FkZWQmJihlLiRiKCksZGVsZXRlIGUuJGIpLDB9ZnVuY3Rpb24gcHQodCl7aWYoeClyZXR1cm4gV3QoMSwxLHQpO0ooKXx8KGR0Lm9jKCkscy5vbkV4aXQmJnMub25FeGl0KHQpLGo9ITApLHkodCxuZXcgdXQodCkpfWZ1bmN0aW9uIGZ0KHQsZSl7aWYoIWUmJngpdGhyb3cgYnQodCksXCJ1bndpbmRcIjtKKCl8fHh8fChtZSgpLGh0KEspLGJlKDApLHJlWzFdLmxlbmd0aCYmaWUoMSwxMCkscmVbMl0ubGVuZ3RoJiZpZSgyLDEwKSxkdC5vYygpKSxwdCh0KX12YXIgZHQ9e1liOltdLGFjOltdLHFjOltdLFZiOnt9LGZjOmZ1bmN0aW9uKCl7eCYmZHQuRWMoKX0sUGM6ZnVuY3Rpb24oKXt9LEVjOmZ1bmN0aW9uKCl7ZHQucmVjZWl2ZU9iamVjdFRyYW5zZmVyPWR0LkdjLGR0LnRocmVhZEluaXRUTFM9ZHQucGMsZHQuc2V0RXhpdFN0YXR1cz1kdC5uYyxEPSExfSxuYzpmdW5jdGlvbigpe30sb2M6ZnVuY3Rpb24oKXtmb3IodmFyIHQgb2YgT2JqZWN0LnZhbHVlcyhkdC5WYikpZHQubWModCk7Zm9yKHQgb2YgZHQuWWIpdC50ZXJtaW5hdGUoKTtkdC5ZYj1bXX0sbWM6ZnVuY3Rpb24odCl7dmFyIGU9dC5VYjtkZWxldGUgZHQuVmJbZV0sZHQuWWIucHVzaCh0KSxkdC5hYy5zcGxpY2UoZHQuYWMuaW5kZXhPZih0KSwxKSx0LlViPTAseGUoZSl9LEdjOmZ1bmN0aW9uKCl7fSxwYzpmdW5jdGlvbigpe2R0LnFjLmZvckVhY2goKHQ9PnQoKSkpfSxGYzpmdW5jdGlvbih0LGUpe3Qub25tZXNzYWdlPW49Pnt2YXIgcj0obj1uLmRhdGEpLmNtZDtpZih0LlViJiYoZHQuQmM9dC5VYiksbi50YXJnZXRUaHJlYWQmJm4udGFyZ2V0VGhyZWFkIT1kZSgpKXt2YXIgaT1kdC5WYltuLlFjXTtpP2kucG9zdE1lc3NhZ2UobixuLnRyYW5zZmVyTGlzdCk6UCgnSW50ZXJuYWwgZXJyb3IhIFdvcmtlciBzZW50IGEgbWVzc2FnZSBcIicrcisnXCIgdG8gdGFyZ2V0IHB0aHJlYWQgJytuLnRhcmdldFRocmVhZCtcIiwgYnV0IHRoYXQgdGhyZWFkIG5vIGxvbmdlciBleGlzdHMhXCIpfWVsc2VcInByb2Nlc3NQcm94eWluZ1F1ZXVlXCI9PT1yP1Z0KG4ucXVldWUpOlwic3Bhd25UaHJlYWRcIj09PXI/bHQobik6XCJjbGVhbnVwVGhyZWFkXCI9PT1yP2N0KG4udGhyZWFkKTpcImtpbGxUaHJlYWRcIj09PXI/KG49bi50aHJlYWQscj1kdC5WYltuXSxkZWxldGUgZHQuVmJbbl0sci50ZXJtaW5hdGUoKSx4ZShuKSxkdC5hYy5zcGxpY2UoZHQuYWMuaW5kZXhPZihyKSwxKSxyLlViPTApOlwiY2FuY2VsVGhyZWFkXCI9PT1yP2R0LlZiW24udGhyZWFkXS5wb3N0TWVzc2FnZSh7Y21kOlwiY2FuY2VsXCJ9KTpcImxvYWRlZFwiPT09cj8odC5sb2FkZWQ9ITAsZSYmZSh0KSx0LiRiJiYodC4kYigpLGRlbGV0ZSB0LiRiKSk6XCJwcmludFwiPT09cj9JKFwiVGhyZWFkIFwiK24udGhyZWFkSWQrXCI6IFwiK24udGV4dCk6XCJwcmludEVyclwiPT09cj9QKFwiVGhyZWFkIFwiK24udGhyZWFkSWQrXCI6IFwiK24udGV4dCk6XCJhbGVydFwiPT09cj9hbGVydChcIlRocmVhZCBcIituLnRocmVhZElkK1wiOiBcIituLnRleHQpOlwic2V0aW1tZWRpYXRlXCI9PT1uLnRhcmdldD90LnBvc3RNZXNzYWdlKG4pOlwib25BYm9ydFwiPT09cj9zLm9uQWJvcnQmJnMub25BYm9ydChuLmFyZyk6ciYmUChcIndvcmtlciBzZW50IGFuIHVua25vd24gY29tbWFuZCBcIityKTtkdC5CYz12b2lkIDB9LHQub25lcnJvcj10PT57dGhyb3cgUChcIndvcmtlciBzZW50IGFuIGVycm9yISBcIit0LmZpbGVuYW1lK1wiOlwiK3QubGluZW5vK1wiOiBcIit0Lm1lc3NhZ2UpLHR9LHcmJih0Lm9uKFwibWVzc2FnZVwiLChmdW5jdGlvbihlKXt0Lm9ubWVzc2FnZSh7ZGF0YTplfSl9KSksdC5vbihcImVycm9yXCIsKGZ1bmN0aW9uKGUpe3Qub25lcnJvcihlKX0pKSx0Lm9uKFwiZGV0YWNoZWRFeGl0XCIsKGZ1bmN0aW9uKCl7fSkpKSx0LnBvc3RNZXNzYWdlKHtjbWQ6XCJsb2FkXCIsdXJsT3JCbG9iOnMubWFpblNjcmlwdFVybE9yQmxvYnx8X3NjcmlwdERpcix3YXNtTWVtb3J5OiQsd2FzbU1vZHVsZTprfSl9LHljOmZ1bmN0aW9uKCl7dmFyIHQ9UyhcIm9ydC13YXNtLXRocmVhZGVkLndvcmtlci5qc1wiKTtkdC5ZYi5wdXNoKG5ldyBXb3JrZXIodCkpfSxDYzpmdW5jdGlvbigpe3JldHVybiAwPT1kdC5ZYi5sZW5ndGgmJihkdC55YygpLGR0LkZjKGR0LlliWzBdKSksZHQuWWIucG9wKCl9fTtmdW5jdGlvbiBodCh0KXtmb3IoOzA8dC5sZW5ndGg7KXQuc2hpZnQoKShzKX1mdW5jdGlvbiBndCh0KXt2YXIgZT1BZSgpO3JldHVybiB0PXQoKSxFZShlKSx0fWZ1bmN0aW9uIGJ0KHQpe2lmKHgpcmV0dXJuIFd0KDIsMCx0KTt0cnl7ZnQodCl9Y2F0Y2godCl7dCBpbnN0YW5jZW9mIHV0fHxcInVud2luZFwiPT10fHx5KDEsdCl9fXMuUFRocmVhZD1kdCxzLmVzdGFibGlzaFN0YWNrU3BhY2U9ZnVuY3Rpb24oKXt2YXIgdD1kZSgpLGU9aSgpW3QrNDQ+PjI+Pj4wXTt0PWkoKVt0KzQ4Pj4yPj4+MF0sT2UoZSxlLXQpLEVlKGUpfTt2YXIgbXQ9W107ZnVuY3Rpb24geXQodCl7dmFyIGU9bXRbdF07cmV0dXJuIGV8fCh0Pj1tdC5sZW5ndGgmJihtdC5sZW5ndGg9dCsxKSxtdFt0XT1lPVcuZ2V0KHQpKSxlfXMuaW52b2tlRW50cnlQb2ludD1mdW5jdGlvbih0LGUpe3Q9eXQodCkoZSksSigpP2R0Lm5jKHQpOlRlKHQpfTt2YXIgX3QsdnQsd3Q9W10seHQ9MCxUdD0wO2Z1bmN0aW9uIFN0KHQpe3RoaXMuWmI9dCx0aGlzLlNiPXQtMjQsdGhpcy54Yz1mdW5jdGlvbih0KXtvKClbdGhpcy5TYis0Pj4yPj4+MF09dH0sdGhpcy5iYz1mdW5jdGlvbigpe3JldHVybiBvKClbdGhpcy5TYis0Pj4yPj4+MF19LHRoaXMud2M9ZnVuY3Rpb24odCl7bygpW3RoaXMuU2IrOD4+Mj4+PjBdPXR9LHRoaXMuRGM9ZnVuY3Rpb24oKXtyZXR1cm4gbygpW3RoaXMuU2IrOD4+Mj4+PjBdfSx0aGlzLnJjPWZ1bmN0aW9uKCl7aSgpW3RoaXMuU2I+PjI+Pj4wXT0wfSx0aGlzLmhjPWZ1bmN0aW9uKHQpe3Q9dD8xOjAsZSgpW3RoaXMuU2IrMTI+PjA+Pj4wXT10fSx0aGlzLnVjPWZ1bmN0aW9uKCl7cmV0dXJuIDAhPWUoKVt0aGlzLlNiKzEyPj4wPj4+MF19LHRoaXMuaWM9ZnVuY3Rpb24odCl7dD10PzE6MCxlKClbdGhpcy5TYisxMz4+MD4+PjBdPXR9LHRoaXMua2M9ZnVuY3Rpb24oKXtyZXR1cm4gMCE9ZSgpW3RoaXMuU2IrMTM+PjA+Pj4wXX0sdGhpcy5mYz1mdW5jdGlvbih0LGUpe3RoaXMuY2MoMCksdGhpcy54Yyh0KSx0aGlzLndjKGUpLHRoaXMucmMoKSx0aGlzLmhjKCExKSx0aGlzLmljKCExKX0sdGhpcy5zYz1mdW5jdGlvbigpe0F0b21pY3MuYWRkKGkoKSx0aGlzLlNiPj4yLDEpfSx0aGlzLkhjPWZ1bmN0aW9uKCl7cmV0dXJuIDE9PT1BdG9taWNzLnN1YihpKCksdGhpcy5TYj4+MiwxKX0sdGhpcy5jYz1mdW5jdGlvbih0KXtvKClbdGhpcy5TYisxNj4+Mj4+PjBdPXR9LHRoaXMudGM9ZnVuY3Rpb24oKXtyZXR1cm4gbygpW3RoaXMuU2IrMTY+PjI+Pj4wXX0sdGhpcy52Yz1mdW5jdGlvbigpe2lmKERlKHRoaXMuYmMoKSkpcmV0dXJuIG8oKVt0aGlzLlpiPj4yPj4+MF07dmFyIHQ9dGhpcy50YygpO3JldHVybiAwIT09dD90OnRoaXMuWmJ9fWZ1bmN0aW9uIE90KHQpe3JldHVybiBnZShuZXcgU3QodCkuU2IpfWZ1bmN0aW9uIEF0KHQsZSxuLHIpe3JldHVybiB4P1d0KDMsMSx0LGUsbixyKTpFdCh0LGUsbixyKX1mdW5jdGlvbiBFdCh0LGUsbixyKXtpZihcInVuZGVmaW5lZFwiPT10eXBlb2YgU2hhcmVkQXJyYXlCdWZmZXIpcmV0dXJuIFAoXCJDdXJyZW50IGVudmlyb25tZW50IGRvZXMgbm90IHN1cHBvcnQgU2hhcmVkQXJyYXlCdWZmZXIsIHB0aHJlYWRzIGFyZSBub3QgYXZhaWxhYmxlIVwiKSw2O3ZhciBpPVtdO3JldHVybiB4JiYwPT09aS5sZW5ndGg/QXQodCxlLG4scik6KHQ9e0ljOm4sVWI6dCx6YzpyLE5jOml9LHg/KHQuT2M9XCJzcGF3blRocmVhZFwiLHBvc3RNZXNzYWdlKHQsaSksMCk6bHQodCkpfWZ1bmN0aW9uIEl0KHQsZSxuKXtyZXR1cm4geD9XdCg0LDEsdCxlLG4pOjB9ZnVuY3Rpb24gUHQodCxlKXtpZih4KXJldHVybiBXdCg1LDEsdCxlKX1mdW5jdGlvbiBEdCh0LGUpe2lmKHgpcmV0dXJuIFd0KDYsMSx0LGUpfWZ1bmN0aW9uICR0KHQsZSxuKXtpZih4KXJldHVybiBXdCg3LDEsdCxlLG4pfWZ1bmN0aW9uIGt0KHQsZSxuKXtyZXR1cm4geD9XdCg4LDEsdCxlLG4pOjB9ZnVuY3Rpb24gQ3QodCxlKXtpZih4KXJldHVybiBXdCg5LDEsdCxlKX1mdW5jdGlvbiBGdCh0LGUsbil7aWYoeClyZXR1cm4gV3QoMTAsMSx0LGUsbil9ZnVuY3Rpb24gTnQodCxlLG4scil7aWYoeClyZXR1cm4gV3QoMTEsMSx0LGUsbixyKX1mdW5jdGlvbiBSdCh0LGUsbixyKXtpZih4KXJldHVybiBXdCgxMiwxLHQsZSxuLHIpfWZ1bmN0aW9uIEx0KHQsZSxuLHIpe2lmKHgpcmV0dXJuIFd0KDEzLDEsdCxlLG4scil9ZnVuY3Rpb24gTXQodCl7aWYoeClyZXR1cm4gV3QoMTQsMSx0KX1mdW5jdGlvbiBqdCh0LGUpe2lmKHgpcmV0dXJuIFd0KDE1LDEsdCxlKX1mdW5jdGlvbiBVdCh0LGUsbil7aWYoeClyZXR1cm4gV3QoMTYsMSx0LGUsbil9ZnVuY3Rpb24gVnQodCl7QXRvbWljcy5zdG9yZShpKCksdD4+MiwxKSxkZSgpJiZ3ZSh0KSxBdG9taWNzLmNvbXBhcmVFeGNoYW5nZShpKCksdD4+MiwxLDApfWZ1bmN0aW9uIEJ0KHQpe3JldHVybiBvKClbdD4+PjJdKzQyOTQ5NjcyOTYqaSgpW3QrND4+PjJdfWZ1bmN0aW9uIHp0KHQsZSxuLHIsaSxvKXtyZXR1cm4geD9XdCgxNywxLHQsZSxuLHIsaSxvKTotNTJ9ZnVuY3Rpb24gR3QodCxlLG4scixpLG8pe2lmKHgpcmV0dXJuIFd0KDE4LDEsdCxlLG4scixpLG8pfWZ1bmN0aW9uIEh0KHQpe3ZhciBuPUcodCkrMSxyPWhlKG4pO3JldHVybiByJiZ6KHQsZSgpLHIsbikscn1mdW5jdGlvbiBxdCh0LGUsbil7ZnVuY3Rpb24gcih0KXtyZXR1cm4odD10LnRvVGltZVN0cmluZygpLm1hdGNoKC9cXCgoW0EtWmEteiBdKylcXCkkLykpP3RbMV06XCJHTVRcIn1pZih4KXJldHVybiBXdCgxOSwxLHQsZSxuKTt2YXIgYT0obmV3IERhdGUpLmdldEZ1bGxZZWFyKCkscz1uZXcgRGF0ZShhLDAsMSksdT1uZXcgRGF0ZShhLDYsMSk7YT1zLmdldFRpbWV6b25lT2Zmc2V0KCk7dmFyIGM9dS5nZXRUaW1lem9uZU9mZnNldCgpLGw9TWF0aC5tYXgoYSxjKTtpKClbdD4+Mj4+PjBdPTYwKmwsaSgpW2U+PjI+Pj4wXT1OdW1iZXIoYSE9YyksdD1yKHMpLGU9cih1KSx0PUh0KHQpLGU9SHQoZSksYzxhPyhvKClbbj4+Mj4+PjBdPXQsbygpW24rND4+Mj4+PjBdPWUpOihvKClbbj4+Mj4+PjBdPWUsbygpW24rND4+Mj4+PjBdPXQpfWZ1bmN0aW9uIFd0KHQsZSl7dmFyIG49YXJndW1lbnRzLmxlbmd0aC0yLHI9YXJndW1lbnRzO3JldHVybiBndCgoKCk9Pntmb3IodmFyIGk9SWUoOCpuKSxvPWk+PjMscz0wO3M8bjtzKyspe3ZhciB1PXJbMitzXTthKClbbytzPj4+MF09dX1yZXR1cm4gdmUodCxuLGksZSl9KSl9cy5leGVjdXRlTm90aWZpZWRQcm94eWluZ1F1ZXVlPVZ0LHZ0PXc/KCk9Pnt2YXIgdD1wcm9jZXNzLmhydGltZSgpO3JldHVybiAxZTMqdFswXSt0WzFdLzFlNn06eD8oKT0+cGVyZm9ybWFuY2Uubm93KCktcy5fX3BlcmZvcm1hbmNlX25vd19jbG9ja19kcmlmdDooKT0+cGVyZm9ybWFuY2Uubm93KCk7dmFyIFh0LFl0PVtdLEt0PXt9O2Z1bmN0aW9uIFp0KCl7aWYoIVh0KXt2YXIgdCxlPXtVU0VSOlwid2ViX3VzZXJcIixMT0dOQU1FOlwid2ViX3VzZXJcIixQQVRIOlwiL1wiLFBXRDpcIi9cIixIT01FOlwiL2hvbWUvd2ViX3VzZXJcIixMQU5HOihcIm9iamVjdFwiPT10eXBlb2YgbmF2aWdhdG9yJiZuYXZpZ2F0b3IubGFuZ3VhZ2VzJiZuYXZpZ2F0b3IubGFuZ3VhZ2VzWzBdfHxcIkNcIikucmVwbGFjZShcIi1cIixcIl9cIikrXCIuVVRGLThcIixfOm18fFwiLi90aGlzLnByb2dyYW1cIn07Zm9yKHQgaW4gS3Qpdm9pZCAwPT09S3RbdF0/ZGVsZXRlIGVbdF06ZVt0XT1LdFt0XTt2YXIgbj1bXTtmb3IodCBpbiBlKW4ucHVzaCh0K1wiPVwiK2VbdF0pO1h0PW59cmV0dXJuIFh0fWZ1bmN0aW9uIEp0KHQsbil7aWYoeClyZXR1cm4gV3QoMjAsMSx0LG4pO3ZhciByPTA7cmV0dXJuIFp0KCkuZm9yRWFjaCgoZnVuY3Rpb24oaSxhKXt2YXIgcz1uK3I7Zm9yKGE9bygpW3QrNCphPj4yPj4+MF09cyxzPTA7czxpLmxlbmd0aDsrK3MpZSgpW2ErKz4+MD4+PjBdPWkuY2hhckNvZGVBdChzKTtlKClbYT4+MD4+PjBdPTAscis9aS5sZW5ndGgrMX0pKSwwfWZ1bmN0aW9uIFF0KHQsZSl7aWYoeClyZXR1cm4gV3QoMjEsMSx0LGUpO3ZhciBuPVp0KCk7bygpW3Q+PjI+Pj4wXT1uLmxlbmd0aDt2YXIgcj0wO3JldHVybiBuLmZvckVhY2goKGZ1bmN0aW9uKHQpe3IrPXQubGVuZ3RoKzF9KSksbygpW2U+PjI+Pj4wXT1yLDB9ZnVuY3Rpb24gdGUodCl7cmV0dXJuIHg/V3QoMjIsMSx0KTo1Mn1mdW5jdGlvbiBlZSh0LGUsbixyKXtyZXR1cm4geD9XdCgyMywxLHQsZSxuLHIpOjUyfWZ1bmN0aW9uIG5lKHQsZSxuLHIsaSl7cmV0dXJuIHg/V3QoMjQsMSx0LGUsbixyLGkpOjcwfXZhciByZT1bbnVsbCxbXSxbXV07ZnVuY3Rpb24gaWUodCxlKXt2YXIgbj1yZVt0XTswPT09ZXx8MTA9PT1lPygoMT09PXQ/STpQKShWKG4sMCkpLG4ubGVuZ3RoPTApOm4ucHVzaChlKX1mdW5jdGlvbiBvZSh0LGUsbixpKXtpZih4KXJldHVybiBXdCgyNSwxLHQsZSxuLGkpO2Zvcih2YXIgYT0wLHM9MDtzPG47cysrKXt2YXIgdT1vKClbZT4+Mj4+PjBdLGM9bygpW2UrND4+Mj4+PjBdO2UrPTg7Zm9yKHZhciBsPTA7bDxjO2wrKylpZSh0LHIoKVt1K2w+Pj4wXSk7YSs9Y31yZXR1cm4gbygpW2k+PjI+Pj4wXT1hLDB9dmFyIGFlPTA7ZnVuY3Rpb24gc2UodCl7cmV0dXJuIDA9PXQlNCYmKDAhPXQlMTAwfHwwPT10JTQwMCl9dmFyIHVlPVszMSwyOSwzMSwzMCwzMSwzMCwzMSwzMSwzMCwzMSwzMCwzMV0sY2U9WzMxLDI4LDMxLDMwLDMxLDMwLDMxLDMxLDMwLDMxLDMwLDMxXTtmdW5jdGlvbiBsZSh0LG4scixvKXtmdW5jdGlvbiBhKHQsZSxuKXtmb3IodD1cIm51bWJlclwiPT10eXBlb2YgdD90LnRvU3RyaW5nKCk6dHx8XCJcIjt0Lmxlbmd0aDxlOyl0PW5bMF0rdDtyZXR1cm4gdH1mdW5jdGlvbiBzKHQsZSl7cmV0dXJuIGEodCxlLFwiMFwiKX1mdW5jdGlvbiB1KHQsZSl7ZnVuY3Rpb24gbih0KXtyZXR1cm4gMD50Py0xOjA8dD8xOjB9dmFyIHI7cmV0dXJuIDA9PT0ocj1uKHQuZ2V0RnVsbFllYXIoKS1lLmdldEZ1bGxZZWFyKCkpKSYmMD09PShyPW4odC5nZXRNb250aCgpLWUuZ2V0TW9udGgoKSkpJiYocj1uKHQuZ2V0RGF0ZSgpLWUuZ2V0RGF0ZSgpKSkscn1mdW5jdGlvbiBjKHQpe3N3aXRjaCh0LmdldERheSgpKXtjYXNlIDA6cmV0dXJuIG5ldyBEYXRlKHQuZ2V0RnVsbFllYXIoKS0xLDExLDI5KTtjYXNlIDE6cmV0dXJuIHQ7Y2FzZSAyOnJldHVybiBuZXcgRGF0ZSh0LmdldEZ1bGxZZWFyKCksMCwzKTtjYXNlIDM6cmV0dXJuIG5ldyBEYXRlKHQuZ2V0RnVsbFllYXIoKSwwLDIpO2Nhc2UgNDpyZXR1cm4gbmV3IERhdGUodC5nZXRGdWxsWWVhcigpLDAsMSk7Y2FzZSA1OnJldHVybiBuZXcgRGF0ZSh0LmdldEZ1bGxZZWFyKCktMSwxMSwzMSk7Y2FzZSA2OnJldHVybiBuZXcgRGF0ZSh0LmdldEZ1bGxZZWFyKCktMSwxMSwzMCl9fWZ1bmN0aW9uIGwodCl7dmFyIGU9dC5XYjtmb3IodD1uZXcgRGF0ZShuZXcgRGF0ZSh0LlhiKzE5MDAsMCwxKS5nZXRUaW1lKCkpOzA8ZTspe3ZhciBuPXQuZ2V0TW9udGgoKSxyPShzZSh0LmdldEZ1bGxZZWFyKCkpP3VlOmNlKVtuXTtpZighKGU+ci10LmdldERhdGUoKSkpe3Quc2V0RGF0ZSh0LmdldERhdGUoKStlKTticmVha31lLT1yLXQuZ2V0RGF0ZSgpKzEsdC5zZXREYXRlKDEpLDExPm4/dC5zZXRNb250aChuKzEpOih0LnNldE1vbnRoKDApLHQuc2V0RnVsbFllYXIodC5nZXRGdWxsWWVhcigpKzEpKX1yZXR1cm4gbj1uZXcgRGF0ZSh0LmdldEZ1bGxZZWFyKCkrMSwwLDQpLGU9YyhuZXcgRGF0ZSh0LmdldEZ1bGxZZWFyKCksMCw0KSksbj1jKG4pLDA+PXUoZSx0KT8wPj11KG4sdCk/dC5nZXRGdWxsWWVhcigpKzE6dC5nZXRGdWxsWWVhcigpOnQuZ2V0RnVsbFllYXIoKS0xfXZhciBwPWkoKVtvKzQwPj4yPj4+MF07Zm9yKHZhciBmIGluIG89e0xjOmkoKVtvPj4yPj4+MF0sS2M6aSgpW28rND4+Mj4+PjBdLGRjOmkoKVtvKzg+PjI+Pj4wXSxqYzppKClbbysxMj4+Mj4+PjBdLGVjOmkoKVtvKzE2Pj4yPj4+MF0sWGI6aSgpW28rMjA+PjI+Pj4wXSxUYjppKClbbysyND4+Mj4+PjBdLFdiOmkoKVtvKzI4Pj4yPj4+MF0sUmM6aSgpW28rMzI+PjI+Pj4wXSxKYzppKClbbyszNj4+Mj4+PjBdLE1jOnA/QihwKTpcIlwifSxyPUIocikscD17XCIlY1wiOlwiJWEgJWIgJWQgJUg6JU06JVMgJVlcIixcIiVEXCI6XCIlbS8lZC8leVwiLFwiJUZcIjpcIiVZLSVtLSVkXCIsXCIlaFwiOlwiJWJcIixcIiVyXCI6XCIlSTolTTolUyAlcFwiLFwiJVJcIjpcIiVIOiVNXCIsXCIlVFwiOlwiJUg6JU06JVNcIixcIiV4XCI6XCIlbS8lZC8leVwiLFwiJVhcIjpcIiVIOiVNOiVTXCIsXCIlRWNcIjpcIiVjXCIsXCIlRUNcIjpcIiVDXCIsXCIlRXhcIjpcIiVtLyVkLyV5XCIsXCIlRVhcIjpcIiVIOiVNOiVTXCIsXCIlRXlcIjpcIiV5XCIsXCIlRVlcIjpcIiVZXCIsXCIlT2RcIjpcIiVkXCIsXCIlT2VcIjpcIiVlXCIsXCIlT0hcIjpcIiVIXCIsXCIlT0lcIjpcIiVJXCIsXCIlT21cIjpcIiVtXCIsXCIlT01cIjpcIiVNXCIsXCIlT1NcIjpcIiVTXCIsXCIlT3VcIjpcIiV1XCIsXCIlT1VcIjpcIiVVXCIsXCIlT1ZcIjpcIiVWXCIsXCIlT3dcIjpcIiV3XCIsXCIlT1dcIjpcIiVXXCIsXCIlT3lcIjpcIiV5XCJ9KXI9ci5yZXBsYWNlKG5ldyBSZWdFeHAoZixcImdcIikscFtmXSk7dmFyIGQ9XCJTdW5kYXkgTW9uZGF5IFR1ZXNkYXkgV2VkbmVzZGF5IFRodXJzZGF5IEZyaWRheSBTYXR1cmRheVwiLnNwbGl0KFwiIFwiKSxoPVwiSmFudWFyeSBGZWJydWFyeSBNYXJjaCBBcHJpbCBNYXkgSnVuZSBKdWx5IEF1Z3VzdCBTZXB0ZW1iZXIgT2N0b2JlciBOb3ZlbWJlciBEZWNlbWJlclwiLnNwbGl0KFwiIFwiKTtmb3IoZiBpbiBwPXtcIiVhXCI6ZnVuY3Rpb24odCl7cmV0dXJuIGRbdC5UYl0uc3Vic3RyaW5nKDAsMyl9LFwiJUFcIjpmdW5jdGlvbih0KXtyZXR1cm4gZFt0LlRiXX0sXCIlYlwiOmZ1bmN0aW9uKHQpe3JldHVybiBoW3QuZWNdLnN1YnN0cmluZygwLDMpfSxcIiVCXCI6ZnVuY3Rpb24odCl7cmV0dXJuIGhbdC5lY119LFwiJUNcIjpmdW5jdGlvbih0KXtyZXR1cm4gcygodC5YYisxOTAwKS8xMDB8MCwyKX0sXCIlZFwiOmZ1bmN0aW9uKHQpe3JldHVybiBzKHQuamMsMil9LFwiJWVcIjpmdW5jdGlvbih0KXtyZXR1cm4gYSh0LmpjLDIsXCIgXCIpfSxcIiVnXCI6ZnVuY3Rpb24odCl7cmV0dXJuIGwodCkudG9TdHJpbmcoKS5zdWJzdHJpbmcoMil9LFwiJUdcIjpmdW5jdGlvbih0KXtyZXR1cm4gbCh0KX0sXCIlSFwiOmZ1bmN0aW9uKHQpe3JldHVybiBzKHQuZGMsMil9LFwiJUlcIjpmdW5jdGlvbih0KXtyZXR1cm4gMD09KHQ9dC5kYyk/dD0xMjoxMjx0JiYodC09MTIpLHModCwyKX0sXCIlalwiOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT0wLG49MDtuPD10LmVjLTE7ZSs9KHNlKHQuWGIrMTkwMCk/dWU6Y2UpW24rK10pO3JldHVybiBzKHQuamMrZSwzKX0sXCIlbVwiOmZ1bmN0aW9uKHQpe3JldHVybiBzKHQuZWMrMSwyKX0sXCIlTVwiOmZ1bmN0aW9uKHQpe3JldHVybiBzKHQuS2MsMil9LFwiJW5cIjpmdW5jdGlvbigpe3JldHVyblwiXFxuXCJ9LFwiJXBcIjpmdW5jdGlvbih0KXtyZXR1cm4gMDw9dC5kYyYmMTI+dC5kYz9cIkFNXCI6XCJQTVwifSxcIiVTXCI6ZnVuY3Rpb24odCl7cmV0dXJuIHModC5MYywyKX0sXCIldFwiOmZ1bmN0aW9uKCl7cmV0dXJuXCJcXHRcIn0sXCIldVwiOmZ1bmN0aW9uKHQpe3JldHVybiB0LlRifHw3fSxcIiVVXCI6ZnVuY3Rpb24odCl7cmV0dXJuIHMoTWF0aC5mbG9vcigodC5XYis3LXQuVGIpLzcpLDIpfSxcIiVWXCI6ZnVuY3Rpb24odCl7dmFyIGU9TWF0aC5mbG9vcigodC5XYis3LSh0LlRiKzYpJTcpLzcpO2lmKDI+PSh0LlRiKzM3MS10LldiLTIpJTcmJmUrKyxlKTUzPT1lJiYoND09KG49KHQuVGIrMzcxLXQuV2IpJTcpfHwzPT1uJiZzZSh0LlhiKXx8KGU9MSkpO2Vsc2V7ZT01Mjt2YXIgbj0odC5UYis3LXQuV2ItMSklNzsoND09bnx8NT09biYmc2UodC5YYiU0MDAtMSkpJiZlKyt9cmV0dXJuIHMoZSwyKX0sXCIld1wiOmZ1bmN0aW9uKHQpe3JldHVybiB0LlRifSxcIiVXXCI6ZnVuY3Rpb24odCl7cmV0dXJuIHMoTWF0aC5mbG9vcigodC5XYis3LSh0LlRiKzYpJTcpLzcpLDIpfSxcIiV5XCI6ZnVuY3Rpb24odCl7cmV0dXJuKHQuWGIrMTkwMCkudG9TdHJpbmcoKS5zdWJzdHJpbmcoMil9LFwiJVlcIjpmdW5jdGlvbih0KXtyZXR1cm4gdC5YYisxOTAwfSxcIiV6XCI6ZnVuY3Rpb24odCl7dmFyIGU9MDw9KHQ9dC5KYyk7cmV0dXJuIHQ9TWF0aC5hYnModCkvNjAsKGU/XCIrXCI6XCItXCIpK1N0cmluZyhcIjAwMDBcIisodC82MCoxMDArdCU2MCkpLnNsaWNlKC00KX0sXCIlWlwiOmZ1bmN0aW9uKHQpe3JldHVybiB0Lk1jfSxcIiUlXCI6ZnVuY3Rpb24oKXtyZXR1cm5cIiVcIn19LHI9ci5yZXBsYWNlKC8lJS9nLFwiXFwwXFwwXCIpLHApci5pbmNsdWRlcyhmKSYmKHI9ci5yZXBsYWNlKG5ldyBSZWdFeHAoZixcImdcIikscFtmXShvKSkpO3JldHVybiBmPWZ1bmN0aW9uKHQpe3ZhciBlPUFycmF5KEcodCkrMSk7cmV0dXJuIHoodCxlLDAsZS5sZW5ndGgpLGV9KHI9ci5yZXBsYWNlKC9cXDBcXDAvZyxcIiVcIikpLGYubGVuZ3RoPm4/MDooZnVuY3Rpb24odCxuKXtlKCkuc2V0KHQsbj4+PjApfShmLHQpLGYubGVuZ3RoLTEpfWR0LmZjKCk7dmFyIHBlPVtudWxsLHB0LGJ0LEF0LEl0LFB0LER0LCR0LGt0LEN0LEZ0LE50LFJ0LEx0LE10LGp0LFV0LHp0LEd0LHF0LEp0LFF0LHRlLGVlLG5lLG9lXSxmZT17YjpmdW5jdGlvbih0KXtyZXR1cm4gaGUodCsyNCkrMjR9LG46ZnVuY3Rpb24odCl7cmV0dXJuKHQ9bmV3IFN0KHQpKS51YygpfHwodC5oYyghMCkseHQtLSksdC5pYyghMSksd3QucHVzaCh0KSx0LnNjKCksdC52YygpfSxtYTpmdW5jdGlvbih0KXt0aHJvdyBQKFwiVW5leHBlY3RlZCBleGNlcHRpb24gdGhyb3duLCB0aGlzIGlzIG5vdCBwcm9wZXJseSBzdXBwb3J0ZWQgLSBhYm9ydGluZ1wiKSxqPSEwLHR9LHg6ZnVuY3Rpb24oKXtTZSgwKTt2YXIgdD13dC5wb3AoKTtpZih0LkhjKCkmJiF0LmtjKCkpe3ZhciBlPXQuRGMoKTtlJiZ5dChlKSh0LlpiKSxPdCh0LlpiKX1UdD0wfSxlOmZ1bmN0aW9uKCl7dmFyIHQ9VHQ7aWYoIXQpcmV0dXJuIGFlPTA7dmFyIGU9bmV3IFN0KHQpO2UuY2ModCk7dmFyIG49ZS5iYygpO2lmKCFuKXJldHVybiBhZT0wLHQ7Zm9yKHZhciByPUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyksaT0wO2k8ci5sZW5ndGg7aSsrKXt2YXIgbz1yW2ldO2lmKDA9PT1vfHxvPT09bilicmVhaztpZihQZShvLG4sZS5TYisxNikpcmV0dXJuIGFlPW8sdH1yZXR1cm4gYWU9bix0fSxsOmZ1bmN0aW9uKCl7dmFyIHQ9VHQ7aWYoIXQpcmV0dXJuIGFlPTA7dmFyIGU9bmV3IFN0KHQpO2UuY2ModCk7dmFyIG49ZS5iYygpO2lmKCFuKXJldHVybiBhZT0wLHQ7Zm9yKHZhciByPUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyksaT0wO2k8ci5sZW5ndGg7aSsrKXt2YXIgbz1yW2ldO2lmKDA9PT1vfHxvPT09bilicmVhaztpZihQZShvLG4sZS5TYisxNikpcmV0dXJuIGFlPW8sdH1yZXR1cm4gYWU9bix0fSxoOmZ1bmN0aW9uKCl7dmFyIHQ9VHQ7aWYoIXQpcmV0dXJuIGFlPTA7dmFyIGU9bmV3IFN0KHQpO2UuY2ModCk7dmFyIG49ZS5iYygpO2lmKCFuKXJldHVybiBhZT0wLHQ7Zm9yKHZhciByPUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyksaT0wO2k8ci5sZW5ndGg7aSsrKXt2YXIgbz1yW2ldO2lmKDA9PT1vfHxvPT09bilicmVhaztpZihQZShvLG4sZS5TYisxNikpcmV0dXJuIGFlPW8sdH1yZXR1cm4gYWU9bix0fSx0Ok90LE06ZnVuY3Rpb24oKXt2YXIgdD13dC5wb3AoKTt0fHxpdChcIm5vIGV4Y2VwdGlvbiB0byB0aHJvd1wiKTt2YXIgZT10LlpiO3Rocm93IHQua2MoKXx8KHd0LnB1c2godCksdC5pYyghMCksdC5oYyghMSkseHQrKyksVHQ9ZSxlfSxjOmZ1bmN0aW9uKHQsZSxuKXt0aHJvdyBuZXcgU3QodCkuZmMoZSxuKSxUdD10LHh0KyssdH0scGE6ZnVuY3Rpb24oKXtyZXR1cm4geHR9LEZhOmZ1bmN0aW9uKHQpe3llKHQsIXYsMSwhXyksZHQucGMoKX0sVDpmdW5jdGlvbih0KXt4P3Bvc3RNZXNzYWdlKHtjbWQ6XCJjbGVhbnVwVGhyZWFkXCIsdGhyZWFkOnR9KTpjdCh0KX0seGE6RXQsajpmdW5jdGlvbih0KXt0aHJvdyBUdHx8KFR0PXQpLHR9LEg6SXQsTWE6UHQsdWE6RHQsd2E6JHQsb2E6a3QsS2E6Q3QsQ2E6RnQsSmE6TnQsVjpSdCx2YTpMdCxzYTpNdCxMYTpqdCx0YTpVdCxUYTpmdW5jdGlvbigpe30sWDpmdW5jdGlvbigpe2l0KFwiVG8gdXNlIGRsb3BlbiwgeW91IG5lZWQgZW5hYmxlIGR5bmFtaWMgbGlua2luZywgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9lbXNjcmlwdGVuLWNvcmUvZW1zY3JpcHRlbi93aWtpL0xpbmtpbmdcIil9LFVhOmZ1bmN0aW9uKCl7aXQoXCJUbyB1c2UgZGxvcGVuLCB5b3UgbmVlZCBlbmFibGUgZHluYW1pYyBsaW5raW5nLCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2Vtc2NyaXB0ZW4tY29yZS9lbXNjcmlwdGVuL3dpa2kvTGlua2luZ1wiKX0sVzpmdW5jdGlvbigpe3JldHVybiBEYXRlLm5vdygpfSx5YTpmdW5jdGlvbigpe3JldHVybiAyMDk3MTUyfSxPYTpmdW5jdGlvbigpe3JldHVybiEwfSx6YTpmdW5jdGlvbih0LGUsbixyKXtpZih0PT1lKXNldFRpbWVvdXQoKCgpPT5WdChyKSkpO2Vsc2UgaWYoeClwb3N0TWVzc2FnZSh7dGFyZ2V0VGhyZWFkOnQsY21kOlwicHJvY2Vzc1Byb3h5aW5nUXVldWVcIixxdWV1ZTpyfSk7ZWxzZXtpZighKHQ9ZHQuVmJbdF0pKXJldHVybjt0LnBvc3RNZXNzYWdlKHtjbWQ6XCJwcm9jZXNzUHJveHlpbmdRdWV1ZVwiLHF1ZXVlOnJ9KX1yZXR1cm4gMX0sRWE6ZnVuY3Rpb24oKXtyZXR1cm4tMX0sUGE6ZnVuY3Rpb24odCxlKXt0PW5ldyBEYXRlKDFlMypCdCh0KSksaSgpW2U+PjI+Pj4wXT10LmdldFVUQ1NlY29uZHMoKSxpKClbZSs0Pj4yPj4+MF09dC5nZXRVVENNaW51dGVzKCksaSgpW2UrOD4+Mj4+PjBdPXQuZ2V0VVRDSG91cnMoKSxpKClbZSsxMj4+Mj4+PjBdPXQuZ2V0VVRDRGF0ZSgpLGkoKVtlKzE2Pj4yPj4+MF09dC5nZXRVVENNb250aCgpLGkoKVtlKzIwPj4yPj4+MF09dC5nZXRVVENGdWxsWWVhcigpLTE5MDAsaSgpW2UrMjQ+PjI+Pj4wXT10LmdldFVUQ0RheSgpLHQ9KHQuZ2V0VGltZSgpLURhdGUuVVRDKHQuZ2V0VVRDRnVsbFllYXIoKSwwLDEsMCwwLDAsMCkpLzg2NGU1fDAsaSgpW2UrMjg+PjI+Pj4wXT10fSxRYTpmdW5jdGlvbih0LGUpe3Q9bmV3IERhdGUoMWUzKkJ0KHQpKSxpKClbZT4+Mj4+PjBdPXQuZ2V0U2Vjb25kcygpLGkoKVtlKzQ+PjI+Pj4wXT10LmdldE1pbnV0ZXMoKSxpKClbZSs4Pj4yPj4+MF09dC5nZXRIb3VycygpLGkoKVtlKzEyPj4yPj4+MF09dC5nZXREYXRlKCksaSgpW2UrMTY+PjI+Pj4wXT10LmdldE1vbnRoKCksaSgpW2UrMjA+PjI+Pj4wXT10LmdldEZ1bGxZZWFyKCktMTkwMCxpKClbZSsyND4+Mj4+PjBdPXQuZ2V0RGF5KCk7dmFyIG49bmV3IERhdGUodC5nZXRGdWxsWWVhcigpLDAsMSkscj0odC5nZXRUaW1lKCktbi5nZXRUaW1lKCkpLzg2NGU1fDA7aSgpW2UrMjg+PjI+Pj4wXT1yLGkoKVtlKzM2Pj4yPj4+MF09LTYwKnQuZ2V0VGltZXpvbmVPZmZzZXQoKSxyPW5ldyBEYXRlKHQuZ2V0RnVsbFllYXIoKSw2LDEpLmdldFRpbWV6b25lT2Zmc2V0KCksdD0wfChyIT0obj1uLmdldFRpbWV6b25lT2Zmc2V0KCkpJiZ0LmdldFRpbWV6b25lT2Zmc2V0KCk9PU1hdGgubWluKG4scikpLGkoKVtlKzMyPj4yPj4+MF09dH0sUmE6ZnVuY3Rpb24odCl7dmFyIGU9bmV3IERhdGUoaSgpW3QrMjA+PjI+Pj4wXSsxOTAwLGkoKVt0KzE2Pj4yPj4+MF0saSgpW3QrMTI+PjI+Pj4wXSxpKClbdCs4Pj4yPj4+MF0saSgpW3QrND4+Mj4+PjBdLGkoKVt0Pj4yPj4+MF0sMCksbj1pKClbdCszMj4+Mj4+PjBdLHI9ZS5nZXRUaW1lem9uZU9mZnNldCgpLG89bmV3IERhdGUoZS5nZXRGdWxsWWVhcigpLDAsMSksYT1uZXcgRGF0ZShlLmdldEZ1bGxZZWFyKCksNiwxKS5nZXRUaW1lem9uZU9mZnNldCgpLHM9by5nZXRUaW1lem9uZU9mZnNldCgpLHU9TWF0aC5taW4ocyxhKTtyZXR1cm4gMD5uP2koKVt0KzMyPj4yPj4+MF09TnVtYmVyKGEhPXMmJnU9PXIpOjA8biE9KHU9PXIpJiYoYT1NYXRoLm1heChzLGEpLGUuc2V0VGltZShlLmdldFRpbWUoKSs2ZTQqKCgwPG4/dTphKS1yKSkpLGkoKVt0KzI0Pj4yPj4+MF09ZS5nZXREYXkoKSxuPShlLmdldFRpbWUoKS1vLmdldFRpbWUoKSkvODY0ZTV8MCxpKClbdCsyOD4+Mj4+PjBdPW4saSgpW3Q+PjI+Pj4wXT1lLmdldFNlY29uZHMoKSxpKClbdCs0Pj4yPj4+MF09ZS5nZXRNaW51dGVzKCksaSgpW3QrOD4+Mj4+PjBdPWUuZ2V0SG91cnMoKSxpKClbdCsxMj4+Mj4+PjBdPWUuZ2V0RGF0ZSgpLGkoKVt0KzE2Pj4yPj4+MF09ZS5nZXRNb250aCgpLGUuZ2V0VGltZSgpLzFlM3wwfSxBYTp6dCxCYTpHdCxTYTpmdW5jdGlvbiB0KGUsbixyKXt0LkFjfHwodC5BYz0hMCxxdChlLG4scikpfSx5OmZ1bmN0aW9uKCl7aXQoXCJcIil9LFU6ZnVuY3Rpb24oKXtpZighdyYmIXYpe3ZhciB0PVwiQmxvY2tpbmcgb24gdGhlIG1haW4gdGhyZWFkIGlzIHZlcnkgZGFuZ2Vyb3VzLCBzZWUgaHR0cHM6Ly9lbXNjcmlwdGVuLm9yZy9kb2NzL3BvcnRpbmcvcHRocmVhZHMuaHRtbCNibG9ja2luZy1vbi10aGUtbWFpbi1icm93c2VyLXRocmVhZFwiO190fHwoX3Q9e30pLF90W3RdfHwoX3RbdF09MSx3JiYodD1cIndhcm5pbmc6IFwiK3QpLFAodCkpfX0scmE6ZnVuY3Rpb24oKXtyZXR1cm4gNDI5NDkwMTc2MH0sQjp2dCxJYTpmdW5jdGlvbih0LGUsbil7cigpLmNvcHlXaXRoaW4odD4+PjAsZT4+PjAsZStuPj4+MCl9LEY6ZnVuY3Rpb24oKXtyZXR1cm4gdz9uKDk3MTkpLmNwdXMoKS5sZW5ndGg6bmF2aWdhdG9yLmhhcmR3YXJlQ29uY3VycmVuY3l9LERhOmZ1bmN0aW9uKHQsZSxuKXtZdC5sZW5ndGg9ZSxuPj49Mztmb3IodmFyIHI9MDtyPGU7cisrKVl0W3JdPWEoKVtuK3I+Pj4wXTtyZXR1cm4oMD50P3N0Wy10LTFdOnBlW3RdKS5hcHBseShudWxsLFl0KX0scWE6ZnVuY3Rpb24odCl7dmFyIGU9cigpLmxlbmd0aDtpZigodD4+Pj0wKTw9ZXx8NDI5NDkwMTc2MDx0KXJldHVybiExO2Zvcih2YXIgbj0xOzQ+PW47bio9Mil7dmFyIGk9ZSooMSsuMi9uKTtpPU1hdGgubWluKGksdCsxMDA2NjMyOTYpO3ZhciBvPU1hdGg7aT1NYXRoLm1heCh0LGkpLG89by5taW4uY2FsbChvLDQyOTQ5MDE3NjAsaSsoNjU1MzYtaSU2NTUzNiklNjU1MzYpO3Q6e3RyeXskLmdyb3coby1DLmJ5dGVMZW5ndGgrNjU1MzU+Pj4xNiksSCgkLmJ1ZmZlcik7dmFyIGE9MTticmVhayB0fWNhdGNoKHQpe31hPXZvaWQgMH1pZihhKXJldHVybiEwfXJldHVybiExfSxOYTpmdW5jdGlvbigpe3Rocm93XCJ1bndpbmRcIn0sR2E6SnQsSGE6UXQsSjpmdCxJOnRlLFM6ZWUsZ2E6bmUsUjpvZSxkOmZ1bmN0aW9uKCl7cmV0dXJuIGFlfSxuYTpmdW5jdGlvbiB0KHIsaSl7dC5sY3x8KHQubGM9ZnVuY3Rpb24oKXtpZihcIm9iamVjdFwiPT10eXBlb2YgY3J5cHRvJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKXt2YXIgdD1uZXcgVWludDhBcnJheSgxKTtyZXR1cm4oKT0+KGNyeXB0by5nZXRSYW5kb21WYWx1ZXModCksdFswXSl9aWYodyl0cnl7dmFyIGU9big2MTEzKTtyZXR1cm4oKT0+ZS5yYW5kb21CeXRlcygxKVswXX1jYXRjaCh0KXt9cmV0dXJuKCk9Pml0KFwicmFuZG9tRGV2aWNlXCIpfSgpKTtmb3IodmFyIG89MDtvPGk7bysrKWUoKVtyK28+PjA+Pj4wXT10LmxjKCk7cmV0dXJuIDB9LGlhOmZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1BZSgpO3RyeXtyZXR1cm4geXQodCkoZSxuKX1jYXRjaCh0KXtpZihFZShyKSx0IT09dCswKXRocm93IHQ7U2UoMSwwKX19LGphOmZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1BZSgpO3RyeXtyZXR1cm4geXQodCkoZSxuKX1jYXRjaCh0KXtpZihFZShyKSx0IT09dCswKXRocm93IHQ7U2UoMSwwKX19LEs6ZnVuY3Rpb24odCl7dmFyIGU9QWUoKTt0cnl7cmV0dXJuIHl0KHQpKCl9Y2F0Y2godCl7aWYoRWUoZSksdCE9PXQrMCl0aHJvdyB0O1NlKDEsMCl9fSxmOmZ1bmN0aW9uKHQsZSl7dmFyIG49QWUoKTt0cnl7cmV0dXJuIHl0KHQpKGUpfWNhdGNoKHQpe2lmKEVlKG4pLHQhPT10KzApdGhyb3cgdDtTZSgxLDApfX0sUDpmdW5jdGlvbih0LGUsbil7dmFyIHI9QWUoKTt0cnl7cmV0dXJuIHl0KHQpKGUsbil9Y2F0Y2godCl7aWYoRWUociksdCE9PXQrMCl0aHJvdyB0O1NlKDEsMCl9fSxROmZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1BZSgpO3RyeXtyZXR1cm4geXQodCkoZSxuKX1jYXRjaCh0KXtpZihFZShyKSx0IT09dCswKXRocm93IHQ7U2UoMSwwKX19LGs6ZnVuY3Rpb24odCxlLG4pe3ZhciByPUFlKCk7dHJ5e3JldHVybiB5dCh0KShlLG4pfWNhdGNoKHQpe2lmKEVlKHIpLHQhPT10KzApdGhyb3cgdDtTZSgxLDApfX0scDpmdW5jdGlvbih0LGUsbixyKXt2YXIgaT1BZSgpO3RyeXtyZXR1cm4geXQodCkoZSxuLHIpfWNhdGNoKHQpe2lmKEVlKGkpLHQhPT10KzApdGhyb3cgdDtTZSgxLDApfX0scTpmdW5jdGlvbih0LGUsbixyLGkpe3ZhciBvPUFlKCk7dHJ5e3JldHVybiB5dCh0KShlLG4scixpKX1jYXRjaCh0KXtpZihFZShvKSx0IT09dCswKXRocm93IHQ7U2UoMSwwKX19LE46ZnVuY3Rpb24odCxlLG4scixpLG8pe3ZhciBhPUFlKCk7dHJ5e3JldHVybiB5dCh0KShlLG4scixpLG8pfWNhdGNoKHQpe2lmKEVlKGEpLHQhPT10KzApdGhyb3cgdDtTZSgxLDApfX0sczpmdW5jdGlvbih0LGUsbixyLGksbyl7dmFyIGE9QWUoKTt0cnl7cmV0dXJuIHl0KHQpKGUsbixyLGksbyl9Y2F0Y2godCl7aWYoRWUoYSksdCE9PXQrMCl0aHJvdyB0O1NlKDEsMCl9fSx3OmZ1bmN0aW9uKHQsZSxuLHIsaSxvLGEpe3ZhciBzPUFlKCk7dHJ5e3JldHVybiB5dCh0KShlLG4scixpLG8sYSl9Y2F0Y2godCl7aWYoRWUocyksdCE9PXQrMCl0aHJvdyB0O1NlKDEsMCl9fSxMOmZ1bmN0aW9uKHQsZSxuLHIsaSxvLGEscyl7dmFyIHU9QWUoKTt0cnl7cmV0dXJuIHl0KHQpKGUsbixyLGksbyxhLHMpfWNhdGNoKHQpe2lmKEVlKHUpLHQhPT10KzApdGhyb3cgdDtTZSgxLDApfX0sRTpmdW5jdGlvbih0LGUsbixyLGksbyxhLHMsdSxjLGwscCl7dmFyIGY9QWUoKTt0cnl7cmV0dXJuIHl0KHQpKGUsbixyLGksbyxhLHMsdSxjLGwscCl9Y2F0Y2godCl7aWYoRWUoZiksdCE9PXQrMCl0aHJvdyB0O1NlKDEsMCl9fSxhYTpmdW5jdGlvbih0LGUsbixyLGksbyxhLHMpe3ZhciB1PUFlKCk7dHJ5e3JldHVybiBqZSh0LGUsbixyLGksbyxhLHMpfWNhdGNoKHQpe2lmKEVlKHUpLHQhPT10KzApdGhyb3cgdDtTZSgxLDApfX0sXzpmdW5jdGlvbih0LGUsbixyLGksbyxhKXt2YXIgcz1BZSgpO3RyeXtyZXR1cm4ga2UodCxlLG4scixpLG8sYSl9Y2F0Y2godCl7aWYoRWUocyksdCE9PXQrMCl0aHJvdyB0O1NlKDEsMCl9fSxaOmZ1bmN0aW9uKHQsZSxuLHIsaSl7dmFyIG89QWUoKTt0cnl7cmV0dXJuIFVlKHQsZSxuLHIsaSl9Y2F0Y2godCl7aWYoRWUobyksdCE9PXQrMCl0aHJvdyB0O1NlKDEsMCl9fSxjYTpmdW5jdGlvbih0LGUsbixyKXt2YXIgaT1BZSgpO3RyeXtyZXR1cm4gTGUodCxlLG4scil9Y2F0Y2godCl7aWYoRWUoaSksdCE9PXQrMCl0aHJvdyB0O1NlKDEsMCl9fSwkOmZ1bmN0aW9uKHQpe3ZhciBlPUFlKCk7dHJ5e3JldHVybiAkZSh0KX1jYXRjaCh0KXtpZihFZShlKSx0IT09dCswKXRocm93IHQ7U2UoMSwwKX19LGJhOmZ1bmN0aW9uKHQsZSl7dmFyIG49QWUoKTt0cnl7cmV0dXJuIE1lKHQsZSl9Y2F0Y2godCl7aWYoRWUobiksdCE9PXQrMCl0aHJvdyB0O1NlKDEsMCl9fSxZOmZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1BZSgpO3RyeXtyZXR1cm4gQ2UodCxlLG4pfWNhdGNoKHQpe2lmKEVlKHIpLHQhPT10KzApdGhyb3cgdDtTZSgxLDApfX0sZzpmdW5jdGlvbih0KXt2YXIgZT1BZSgpO3RyeXt5dCh0KSgpfWNhdGNoKHQpe2lmKEVlKGUpLHQhPT10KzApdGhyb3cgdDtTZSgxLDApfX0scjpmdW5jdGlvbih0LGUpe3ZhciBuPUFlKCk7dHJ5e3l0KHQpKGUpfWNhdGNoKHQpe2lmKEVlKG4pLHQhPT10KzApdGhyb3cgdDtTZSgxLDApfX0saTpmdW5jdGlvbih0LGUsbil7dmFyIHI9QWUoKTt0cnl7eXQodCkoZSxuKX1jYXRjaCh0KXtpZihFZShyKSx0IT09dCswKXRocm93IHQ7U2UoMSwwKX19LGhhOmZ1bmN0aW9uKHQsZSxuLHIpe3ZhciBpPUFlKCk7dHJ5e3l0KHQpKGUsbixyKX1jYXRjaCh0KXtpZihFZShpKSx0IT09dCswKXRocm93IHQ7U2UoMSwwKX19LG06ZnVuY3Rpb24odCxlLG4scil7dmFyIGk9QWUoKTt0cnl7eXQodCkoZSxuLHIpfWNhdGNoKHQpe2lmKEVlKGkpLHQhPT10KzApdGhyb3cgdDtTZSgxLDApfX0sdjpmdW5jdGlvbih0LGUsbixyLGkpe3ZhciBvPUFlKCk7dHJ5e3l0KHQpKGUsbixyLGkpfWNhdGNoKHQpe2lmKEVlKG8pLHQhPT10KzApdGhyb3cgdDtTZSgxLDApfX0sdTpmdW5jdGlvbih0LGUsbixyLGksbyl7dmFyIGE9QWUoKTt0cnl7eXQodCkoZSxuLHIsaSxvKX1jYXRjaCh0KXtpZihFZShhKSx0IT09dCswKXRocm93IHQ7U2UoMSwwKX19LE86ZnVuY3Rpb24odCxlLG4scixpLG8sYSl7dmFyIHM9QWUoKTt0cnl7eXQodCkoZSxuLHIsaSxvLGEpfWNhdGNoKHQpe2lmKEVlKHMpLHQhPT10KzApdGhyb3cgdDtTZSgxLDApfX0sQTpmdW5jdGlvbih0LGUsbixyLGksbyxhLHMpe3ZhciB1PUFlKCk7dHJ5e3l0KHQpKGUsbixyLGksbyxhLHMpfWNhdGNoKHQpe2lmKEVlKHUpLHQhPT10KzApdGhyb3cgdDtTZSgxLDApfX0sa2E6ZnVuY3Rpb24odCxlLG4scixpLG8sYSxzLHUpe3ZhciBjPUFlKCk7dHJ5e3l0KHQpKGUsbixyLGksbyxhLHMsdSl9Y2F0Y2godCl7aWYoRWUoYyksdCE9PXQrMCl0aHJvdyB0O1NlKDEsMCl9fSxDOmZ1bmN0aW9uKHQsZSxuLHIsaSxvLGEscyx1LGMsbCl7dmFyIHA9QWUoKTt0cnl7eXQodCkoZSxuLHIsaSxvLGEscyx1LGMsbCl9Y2F0Y2godCl7aWYoRWUocCksdCE9PXQrMCl0aHJvdyB0O1NlKDEsMCl9fSxEOmZ1bmN0aW9uKHQsZSxuLHIsaSxvLGEscyx1LGMsbCxwLGYsZCxoLGcpe3ZhciBiPUFlKCk7dHJ5e3l0KHQpKGUsbixyLGksbyxhLHMsdSxjLGwscCxmLGQsaCxnKX1jYXRjaCh0KXtpZihFZShiKSx0IT09dCswKXRocm93IHQ7U2UoMSwwKX19LGZhOmZ1bmN0aW9uKHQsZSxuLHIsaSxvLGEscyl7dmFyIHU9QWUoKTt0cnl7RmUodCxlLG4scixpLG8sYSxzKX1jYXRjaCh0KXtpZihFZSh1KSx0IT09dCswKXRocm93IHQ7U2UoMSwwKX19LGRhOmZ1bmN0aW9uKHQsZSxuLHIsaSxvLGEscyx1LGMsbCxwKXt2YXIgZj1BZSgpO3RyeXtSZSh0LGUsbixyLGksbyxhLHMsdSxjLGwscCl9Y2F0Y2godCl7aWYoRWUoZiksdCE9PXQrMCl0aHJvdyB0O1NlKDEsMCl9fSxlYTpmdW5jdGlvbih0LGUsbixyLGksbyl7dmFyIGE9QWUoKTt0cnl7TmUodCxlLG4scixpLG8pfWNhdGNoKHQpe2lmKEVlKGEpLHQhPT10KzApdGhyb3cgdDtTZSgxLDApfX0sbzpmdW5jdGlvbih0KXtyZXR1cm4gdH0sYTokfHxzLndhc21NZW1vcnksRzpmdW5jdGlvbih0KXthZT10fSxsYTpsZSx6OmZ1bmN0aW9uKHQsZSxuLHIpe3JldHVybiBsZSh0LGUsbixyKX19OyFmdW5jdGlvbigpe2Z1bmN0aW9uIHQodCxlKXtzLmFzbT10LmV4cG9ydHMsZHQucWMucHVzaChzLmFzbS5zYiksVz1zLmFzbS51YixZLnVuc2hpZnQocy5hc20uVmEpLGs9ZSx4fHwoZXQtLSxzLm1vbml0b3JSdW5EZXBlbmRlbmNpZXMmJnMubW9uaXRvclJ1bkRlcGVuZGVuY2llcyhldCksMD09ZXQmJihudWxsIT09bnQmJihjbGVhckludGVydmFsKG50KSxudD1udWxsKSxydCYmKHQ9cnQscnQ9bnVsbCx0KCkpKSl9ZnVuY3Rpb24gZShlKXt0KGUuaW5zdGFuY2UsZS5tb2R1bGUpfWZ1bmN0aW9uIG4odCl7cmV0dXJuIGZ1bmN0aW9uKCl7aWYoIUUmJihffHx2KSl7aWYoXCJmdW5jdGlvblwiPT10eXBlb2YgZmV0Y2gmJiF0dC5zdGFydHNXaXRoKFwiZmlsZTovL1wiKSlyZXR1cm4gZmV0Y2godHQse2NyZWRlbnRpYWxzOlwic2FtZS1vcmlnaW5cIn0pLnRoZW4oKGZ1bmN0aW9uKHQpe2lmKCF0Lm9rKXRocm93XCJmYWlsZWQgdG8gbG9hZCB3YXNtIGJpbmFyeSBmaWxlIGF0ICdcIit0dCtcIidcIjtyZXR1cm4gdC5hcnJheUJ1ZmZlcigpfSkpLmNhdGNoKChmdW5jdGlvbigpe3JldHVybiBhdCgpfSkpO2lmKHApcmV0dXJuIG5ldyBQcm9taXNlKChmdW5jdGlvbih0LGUpe3AodHQsKGZ1bmN0aW9uKGUpe3QobmV3IFVpbnQ4QXJyYXkoZSkpfSksZSl9KSl9cmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKGZ1bmN0aW9uKCl7cmV0dXJuIGF0KCl9KSl9KCkudGhlbigoZnVuY3Rpb24odCl7cmV0dXJuIFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlKHQscil9KSkudGhlbigoZnVuY3Rpb24odCl7cmV0dXJuIHR9KSkudGhlbih0LChmdW5jdGlvbih0KXtQKFwiZmFpbGVkIHRvIGFzeW5jaHJvbm91c2x5IHByZXBhcmUgd2FzbTogXCIrdCksaXQodCl9KSl9dmFyIHI9e2E6ZmV9O2lmKHh8fChldCsrLHMubW9uaXRvclJ1bkRlcGVuZGVuY2llcyYmcy5tb25pdG9yUnVuRGVwZW5kZW5jaWVzKGV0KSkscy5pbnN0YW50aWF0ZVdhc20pdHJ5e3JldHVybiBzLmluc3RhbnRpYXRlV2FzbShyLHQpfWNhdGNoKHQpe3JldHVybiBQKFwiTW9kdWxlLmluc3RhbnRpYXRlV2FzbSBjYWxsYmFjayBmYWlsZWQgd2l0aCBlcnJvcjogXCIrdCksITF9KEV8fFwiZnVuY3Rpb25cIiE9dHlwZW9mIFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlU3RyZWFtaW5nfHxvdCgpfHx0dC5zdGFydHNXaXRoKFwiZmlsZTovL1wiKXx8d3x8XCJmdW5jdGlvblwiIT10eXBlb2YgZmV0Y2g/bihlKTpmZXRjaCh0dCx7Y3JlZGVudGlhbHM6XCJzYW1lLW9yaWdpblwifSkudGhlbigoZnVuY3Rpb24odCl7cmV0dXJuIFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlU3RyZWFtaW5nKHQscikudGhlbihlLChmdW5jdGlvbih0KXtyZXR1cm4gUChcIndhc20gc3RyZWFtaW5nIGNvbXBpbGUgZmFpbGVkOiBcIit0KSxQKFwiZmFsbGluZyBiYWNrIHRvIEFycmF5QnVmZmVyIGluc3RhbnRpYXRpb25cIiksbihlKX0pKX0pKSkuY2F0Y2goYyl9KCkscy5fX193YXNtX2NhbGxfY3RvcnM9ZnVuY3Rpb24oKXtyZXR1cm4ocy5fX193YXNtX2NhbGxfY3RvcnM9cy5hc20uVmEpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0scy5fT3J0SW5pdD1mdW5jdGlvbigpe3JldHVybihzLl9PcnRJbml0PXMuYXNtLldhKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHMuX09ydENyZWF0ZVNlc3Npb25PcHRpb25zPWZ1bmN0aW9uKCl7cmV0dXJuKHMuX09ydENyZWF0ZVNlc3Npb25PcHRpb25zPXMuYXNtLlhhKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHMuX09ydEFwcGVuZEV4ZWN1dGlvblByb3ZpZGVyPWZ1bmN0aW9uKCl7cmV0dXJuKHMuX09ydEFwcGVuZEV4ZWN1dGlvblByb3ZpZGVyPXMuYXNtLllhKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHMuX09ydEFkZFNlc3Npb25Db25maWdFbnRyeT1mdW5jdGlvbigpe3JldHVybihzLl9PcnRBZGRTZXNzaW9uQ29uZmlnRW50cnk9cy5hc20uWmEpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0scy5fT3J0UmVsZWFzZVNlc3Npb25PcHRpb25zPWZ1bmN0aW9uKCl7cmV0dXJuKHMuX09ydFJlbGVhc2VTZXNzaW9uT3B0aW9ucz1zLmFzbS5fYSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxzLl9PcnRDcmVhdGVTZXNzaW9uPWZ1bmN0aW9uKCl7cmV0dXJuKHMuX09ydENyZWF0ZVNlc3Npb249cy5hc20uJGEpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0scy5fT3J0UmVsZWFzZVNlc3Npb249ZnVuY3Rpb24oKXtyZXR1cm4ocy5fT3J0UmVsZWFzZVNlc3Npb249cy5hc20uYWIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0scy5fT3J0R2V0SW5wdXRDb3VudD1mdW5jdGlvbigpe3JldHVybihzLl9PcnRHZXRJbnB1dENvdW50PXMuYXNtLmJiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHMuX09ydEdldE91dHB1dENvdW50PWZ1bmN0aW9uKCl7cmV0dXJuKHMuX09ydEdldE91dHB1dENvdW50PXMuYXNtLmNiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHMuX09ydEdldElucHV0TmFtZT1mdW5jdGlvbigpe3JldHVybihzLl9PcnRHZXRJbnB1dE5hbWU9cy5hc20uZGIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0scy5fT3J0R2V0T3V0cHV0TmFtZT1mdW5jdGlvbigpe3JldHVybihzLl9PcnRHZXRPdXRwdXROYW1lPXMuYXNtLmViKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHMuX09ydEZyZWU9ZnVuY3Rpb24oKXtyZXR1cm4ocy5fT3J0RnJlZT1zLmFzbS5mYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxzLl9PcnRDcmVhdGVUZW5zb3I9ZnVuY3Rpb24oKXtyZXR1cm4ocy5fT3J0Q3JlYXRlVGVuc29yPXMuYXNtLmdiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHMuX09ydEdldFRlbnNvckRhdGE9ZnVuY3Rpb24oKXtyZXR1cm4ocy5fT3J0R2V0VGVuc29yRGF0YT1zLmFzbS5oYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxzLl9PcnRSZWxlYXNlVGVuc29yPWZ1bmN0aW9uKCl7cmV0dXJuKHMuX09ydFJlbGVhc2VUZW5zb3I9cy5hc20uaWIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0scy5fT3J0Q3JlYXRlUnVuT3B0aW9ucz1mdW5jdGlvbigpe3JldHVybihzLl9PcnRDcmVhdGVSdW5PcHRpb25zPXMuYXNtLmpiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHMuX09ydEFkZFJ1bkNvbmZpZ0VudHJ5PWZ1bmN0aW9uKCl7cmV0dXJuKHMuX09ydEFkZFJ1bkNvbmZpZ0VudHJ5PXMuYXNtLmtiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHMuX09ydFJlbGVhc2VSdW5PcHRpb25zPWZ1bmN0aW9uKCl7cmV0dXJuKHMuX09ydFJlbGVhc2VSdW5PcHRpb25zPXMuYXNtLmxiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHMuX09ydFJ1bj1mdW5jdGlvbigpe3JldHVybihzLl9PcnRSdW49cy5hc20ubWIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0scy5fT3J0RW5kUHJvZmlsaW5nPWZ1bmN0aW9uKCl7cmV0dXJuKHMuX09ydEVuZFByb2ZpbGluZz1zLmFzbS5uYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfTt2YXIgZGU9cy5fcHRocmVhZF9zZWxmPWZ1bmN0aW9uKCl7cmV0dXJuKGRlPXMuX3B0aHJlYWRfc2VsZj1zLmFzbS5vYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxoZT1zLl9tYWxsb2M9ZnVuY3Rpb24oKXtyZXR1cm4oaGU9cy5fbWFsbG9jPXMuYXNtLnBiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGdlPXMuX2ZyZWU9ZnVuY3Rpb24oKXtyZXR1cm4oZ2U9cy5fZnJlZT1zLmFzbS5xYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxiZT1zLl9mZmx1c2g9ZnVuY3Rpb24oKXtyZXR1cm4oYmU9cy5fZmZsdXNoPXMuYXNtLnJiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O3MuX19lbXNjcmlwdGVuX3Rsc19pbml0PWZ1bmN0aW9uKCl7cmV0dXJuKHMuX19lbXNjcmlwdGVuX3Rsc19pbml0PXMuYXNtLnNiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O3ZhciBtZT1zLl9fX2Z1bmNzX29uX2V4aXQ9ZnVuY3Rpb24oKXtyZXR1cm4obWU9cy5fX19mdW5jc19vbl9leGl0PXMuYXNtLnRiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHllPXMuX19lbXNjcmlwdGVuX3RocmVhZF9pbml0PWZ1bmN0aW9uKCl7cmV0dXJuKHllPXMuX19lbXNjcmlwdGVuX3RocmVhZF9pbml0PXMuYXNtLnZiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O3MuX19lbXNjcmlwdGVuX3RocmVhZF9jcmFzaGVkPWZ1bmN0aW9uKCl7cmV0dXJuKHMuX19lbXNjcmlwdGVuX3RocmVhZF9jcmFzaGVkPXMuYXNtLndiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O3ZhciBfZSx2ZT1zLl9lbXNjcmlwdGVuX3J1bl9pbl9tYWluX3J1bnRpbWVfdGhyZWFkX2pzPWZ1bmN0aW9uKCl7cmV0dXJuKHZlPXMuX2Vtc2NyaXB0ZW5fcnVuX2luX21haW5fcnVudGltZV90aHJlYWRfanM9cy5hc20ueGIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sd2U9cy5fX2Vtc2NyaXB0ZW5fcHJveHlfZXhlY3V0ZV90YXNrX3F1ZXVlPWZ1bmN0aW9uKCl7cmV0dXJuKHdlPXMuX19lbXNjcmlwdGVuX3Byb3h5X2V4ZWN1dGVfdGFza19xdWV1ZT1zLmFzbS55YikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSx4ZT1zLl9fZW1zY3JpcHRlbl90aHJlYWRfZnJlZV9kYXRhPWZ1bmN0aW9uKCl7cmV0dXJuKHhlPXMuX19lbXNjcmlwdGVuX3RocmVhZF9mcmVlX2RhdGE9cy5hc20uemIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sVGU9cy5fX2Vtc2NyaXB0ZW5fdGhyZWFkX2V4aXQ9ZnVuY3Rpb24oKXtyZXR1cm4oVGU9cy5fX2Vtc2NyaXB0ZW5fdGhyZWFkX2V4aXQ9cy5hc20uQWIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sU2U9cy5fc2V0VGhyZXc9ZnVuY3Rpb24oKXtyZXR1cm4oU2U9cy5fc2V0VGhyZXc9cy5hc20uQmIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sT2U9cy5fZW1zY3JpcHRlbl9zdGFja19zZXRfbGltaXRzPWZ1bmN0aW9uKCl7cmV0dXJuKE9lPXMuX2Vtc2NyaXB0ZW5fc3RhY2tfc2V0X2xpbWl0cz1zLmFzbS5DYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxBZT1zLnN0YWNrU2F2ZT1mdW5jdGlvbigpe3JldHVybihBZT1zLnN0YWNrU2F2ZT1zLmFzbS5EYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxFZT1zLnN0YWNrUmVzdG9yZT1mdW5jdGlvbigpe3JldHVybihFZT1zLnN0YWNrUmVzdG9yZT1zLmFzbS5FYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxJZT1zLnN0YWNrQWxsb2M9ZnVuY3Rpb24oKXtyZXR1cm4oSWU9cy5zdGFja0FsbG9jPXMuYXNtLkZiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LFBlPXMuX19fY3hhX2Nhbl9jYXRjaD1mdW5jdGlvbigpe3JldHVybihQZT1zLl9fX2N4YV9jYW5fY2F0Y2g9cy5hc20uR2IpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sRGU9cy5fX19jeGFfaXNfcG9pbnRlcl90eXBlPWZ1bmN0aW9uKCl7cmV0dXJuKERlPXMuX19fY3hhX2lzX3BvaW50ZXJfdHlwZT1zLmFzbS5IYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSwkZT1zLmR5bkNhbGxfaj1mdW5jdGlvbigpe3JldHVybigkZT1zLmR5bkNhbGxfaj1zLmFzbS5JYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxrZT1zLmR5bkNhbGxfaWlpaWlqPWZ1bmN0aW9uKCl7cmV0dXJuKGtlPXMuZHluQ2FsbF9paWlpaWo9cy5hc20uSmIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sQ2U9cy5keW5DYWxsX2ppaT1mdW5jdGlvbigpe3JldHVybihDZT1zLmR5bkNhbGxfamlpPXMuYXNtLktiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LEZlPXMuZHluQ2FsbF92aWlpaWlqPWZ1bmN0aW9uKCl7cmV0dXJuKEZlPXMuZHluQ2FsbF92aWlpaWlqPXMuYXNtLkxiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LE5lPXMuZHluQ2FsbF92amppPWZ1bmN0aW9uKCl7cmV0dXJuKE5lPXMuZHluQ2FsbF92amppPXMuYXNtLk1iKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LFJlPXMuZHluQ2FsbF92aWlpampqaWk9ZnVuY3Rpb24oKXtyZXR1cm4oUmU9cy5keW5DYWxsX3ZpaWlqamppaT1zLmFzbS5OYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxMZT1zLmR5bkNhbGxfaWlqPWZ1bmN0aW9uKCl7cmV0dXJuKExlPXMuZHluQ2FsbF9paWo9cy5hc20uT2IpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sTWU9cy5keW5DYWxsX2ppPWZ1bmN0aW9uKCl7cmV0dXJuKE1lPXMuZHluQ2FsbF9qaT1zLmFzbS5QYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxqZT1zLmR5bkNhbGxfaWlpaWlpaj1mdW5jdGlvbigpe3JldHVybihqZT1zLmR5bkNhbGxfaWlpaWlpaj1zLmFzbS5RYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxVZT1zLmR5bkNhbGxfaWlpaj1mdW5jdGlvbigpe3JldHVybihVZT1zLmR5bkNhbGxfaWlpaj1zLmFzbS5SYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfTtmdW5jdGlvbiBWZSgpe2Z1bmN0aW9uIHQoKXtpZighX2UmJihfZT0hMCxzLmNhbGxlZFJ1bj0hMCwhaikmJih4fHxodChZKSx1KHMpLHMub25SdW50aW1lSW5pdGlhbGl6ZWQmJnMub25SdW50aW1lSW5pdGlhbGl6ZWQoKSwheCkpe2lmKHMucG9zdFJ1bilmb3IoXCJmdW5jdGlvblwiPT10eXBlb2Ygcy5wb3N0UnVuJiYocy5wb3N0UnVuPVtzLnBvc3RSdW5dKTtzLnBvc3RSdW4ubGVuZ3RoOyl7dmFyIHQ9cy5wb3N0UnVuLnNoaWZ0KCk7Wi51bnNoaWZ0KHQpfWh0KFopfX1pZighKDA8ZXQpKWlmKHgpdShzKSx4fHxodChZKSxwb3N0TWVzc2FnZSh7Y21kOlwibG9hZGVkXCJ9KTtlbHNle2lmKHMucHJlUnVuKWZvcihcImZ1bmN0aW9uXCI9PXR5cGVvZiBzLnByZVJ1biYmKHMucHJlUnVuPVtzLnByZVJ1bl0pO3MucHJlUnVuLmxlbmd0aDspUSgpO2h0KFgpLDA8ZXR8fChzLnNldFN0YXR1cz8ocy5zZXRTdGF0dXMoXCJSdW5uaW5nLi4uXCIpLHNldFRpbWVvdXQoKGZ1bmN0aW9uKCl7c2V0VGltZW91dCgoZnVuY3Rpb24oKXtzLnNldFN0YXR1cyhcIlwiKX0pLDEpLHQoKX0pLDEpKTp0KCkpfX1pZihzLlVURjhUb1N0cmluZz1CLHMuc3RyaW5nVG9VVEY4PWZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4geih0LHIoKSxlLG4pfSxzLmxlbmd0aEJ5dGVzVVRGOD1HLHMua2VlcFJ1bnRpbWVBbGl2ZT1KLHMud2FzbU1lbW9yeT0kLHMuc3RhY2tTYXZlPUFlLHMuc3RhY2tSZXN0b3JlPUVlLHMuc3RhY2tBbGxvYz1JZSxzLkV4aXRTdGF0dXM9dXQscy5QVGhyZWFkPWR0LHJ0PWZ1bmN0aW9uIHQoKXtfZXx8VmUoKSxfZXx8KHJ0PXQpfSxzLnByZUluaXQpZm9yKFwiZnVuY3Rpb25cIj09dHlwZW9mIHMucHJlSW5pdCYmKHMucHJlSW5pdD1bcy5wcmVJbml0XSk7MDxzLnByZUluaXQubGVuZ3RoOylzLnByZUluaXQucG9wKCkoKTtyZXR1cm4gVmUoKSx0LnJlYWR5fSk7dC5leHBvcnRzPXJ9LDkzMjoodCxlLG4pPT57dmFyIF9zY3JpcHREaXIscj0oX3NjcmlwdERpcj0oX3NjcmlwdERpcj1cInVuZGVmaW5lZFwiIT10eXBlb2YgZG9jdW1lbnQmJmRvY3VtZW50LmN1cnJlbnRTY3JpcHQ/ZG9jdW1lbnQuY3VycmVudFNjcmlwdC5zcmM6dm9pZCAwKXx8X19maWxlbmFtZSxmdW5jdGlvbih0KXt2YXIgZSxyLGk7dD10fHx7fSxlfHwoZT12b2lkIDAhPT10P3Q6e30pLGUucmVhZHk9bmV3IFByb21pc2UoKGZ1bmN0aW9uKHQsZSl7cj10LGk9ZX0pKTt2YXIgbyxhLHMsdSxjLGwscD1PYmplY3QuYXNzaWduKHt9LGUpLGY9XCIuL3RoaXMucHJvZ3JhbVwiLGQ9KHQsZSk9Pnt0aHJvdyBlfSxoPVwib2JqZWN0XCI9PXR5cGVvZiB3aW5kb3csZz1cImZ1bmN0aW9uXCI9PXR5cGVvZiBpbXBvcnRTY3JpcHRzLGI9XCJvYmplY3RcIj09dHlwZW9mIHByb2Nlc3MmJlwib2JqZWN0XCI9PXR5cGVvZiBwcm9jZXNzLnZlcnNpb25zJiZcInN0cmluZ1wiPT10eXBlb2YgcHJvY2Vzcy52ZXJzaW9ucy5ub2RlLG09XCJcIjtiPyhtPWc/bigxNDIzKS5kaXJuYW1lKG0pK1wiL1wiOl9fZGlybmFtZStcIi9cIixsPSgpPT57Y3x8KHU9big2MjMxKSxjPW4oMTQyMykpfSxvPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIGwoKSx0PWMubm9ybWFsaXplKHQpLHUucmVhZEZpbGVTeW5jKHQsZT92b2lkIDA6XCJ1dGY4XCIpfSxzPXQ9PigodD1vKHQsITApKS5idWZmZXJ8fCh0PW5ldyBVaW50OEFycmF5KHQpKSx0KSxhPSh0LGUsbik9PntsKCksdD1jLm5vcm1hbGl6ZSh0KSx1LnJlYWRGaWxlKHQsKGZ1bmN0aW9uKHQscil7dD9uKHQpOmUoci5idWZmZXIpfSkpfSwxPHByb2Nlc3MuYXJndi5sZW5ndGgmJihmPXByb2Nlc3MuYXJndlsxXS5yZXBsYWNlKC9cXFxcL2csXCIvXCIpKSxwcm9jZXNzLmFyZ3Yuc2xpY2UoMikscHJvY2Vzcy5vbihcInVuY2F1Z2h0RXhjZXB0aW9uXCIsKGZ1bmN0aW9uKHQpe2lmKCEodCBpbnN0YW5jZW9mIEspKXRocm93IHR9KSkscHJvY2Vzcy5vbihcInVuaGFuZGxlZFJlamVjdGlvblwiLChmdW5jdGlvbih0KXt0aHJvdyB0fSkpLGQ9KHQsZSk9PntpZih3fHwwPFUpdGhyb3cgcHJvY2Vzcy5leGl0Q29kZT10LGU7ZSBpbnN0YW5jZW9mIEt8fHYoXCJleGl0aW5nIGR1ZSB0byBleGNlcHRpb246IFwiK2UpLHByb2Nlc3MuZXhpdCh0KX0sZS5pbnNwZWN0PWZ1bmN0aW9uKCl7cmV0dXJuXCJbRW1zY3JpcHRlbiBNb2R1bGUgb2JqZWN0XVwifSk6KGh8fGcpJiYoZz9tPXNlbGYubG9jYXRpb24uaHJlZjpcInVuZGVmaW5lZFwiIT10eXBlb2YgZG9jdW1lbnQmJmRvY3VtZW50LmN1cnJlbnRTY3JpcHQmJihtPWRvY3VtZW50LmN1cnJlbnRTY3JpcHQuc3JjKSxfc2NyaXB0RGlyJiYobT1fc2NyaXB0RGlyKSxtPTAhPT1tLmluZGV4T2YoXCJibG9iOlwiKT9tLnN1YnN0cigwLG0ucmVwbGFjZSgvWz8jXS4qLyxcIlwiKS5sYXN0SW5kZXhPZihcIi9cIikrMSk6XCJcIixvPXQ9Pnt2YXIgZT1uZXcgWE1MSHR0cFJlcXVlc3Q7cmV0dXJuIGUub3BlbihcIkdFVFwiLHQsITEpLGUuc2VuZChudWxsKSxlLnJlc3BvbnNlVGV4dH0sZyYmKHM9dD0+e3ZhciBlPW5ldyBYTUxIdHRwUmVxdWVzdDtyZXR1cm4gZS5vcGVuKFwiR0VUXCIsdCwhMSksZS5yZXNwb25zZVR5cGU9XCJhcnJheWJ1ZmZlclwiLGUuc2VuZChudWxsKSxuZXcgVWludDhBcnJheShlLnJlc3BvbnNlKX0pLGE9KHQsZSxuKT0+e3ZhciByPW5ldyBYTUxIdHRwUmVxdWVzdDtyLm9wZW4oXCJHRVRcIix0LCEwKSxyLnJlc3BvbnNlVHlwZT1cImFycmF5YnVmZmVyXCIsci5vbmxvYWQ9KCk9PnsyMDA9PXIuc3RhdHVzfHwwPT1yLnN0YXR1cyYmci5yZXNwb25zZT9lKHIucmVzcG9uc2UpOm4oKX0sci5vbmVycm9yPW4sci5zZW5kKG51bGwpfSk7dmFyIHksXz1lLnByaW50fHxjb25zb2xlLmxvZy5iaW5kKGNvbnNvbGUpLHY9ZS5wcmludEVycnx8Y29uc29sZS53YXJuLmJpbmQoY29uc29sZSk7T2JqZWN0LmFzc2lnbihlLHApLHA9bnVsbCxlLnRoaXNQcm9ncmFtJiYoZj1lLnRoaXNQcm9ncmFtKSxlLnF1aXQmJihkPWUucXVpdCksZS53YXNtQmluYXJ5JiYoeT1lLndhc21CaW5hcnkpO3ZhciB3PWUubm9FeGl0UnVudGltZXx8ITE7XCJvYmplY3RcIiE9dHlwZW9mIFdlYkFzc2VtYmx5JiZxKFwibm8gbmF0aXZlIHdhc20gc3VwcG9ydCBkZXRlY3RlZFwiKTt2YXIgeCxULFMsTyxBLEUsST0hMSxQPVwidW5kZWZpbmVkXCIhPXR5cGVvZiBUZXh0RGVjb2Rlcj9uZXcgVGV4dERlY29kZXIoXCJ1dGY4XCIpOnZvaWQgMDtmdW5jdGlvbiBEKHQsZSxuKXt2YXIgcj0oZT4+Pj0wKStuO2ZvcihuPWU7dFtuXSYmIShuPj1yKTspKytuO2lmKDE2PG4tZSYmdC5idWZmZXImJlApcmV0dXJuIFAuZGVjb2RlKHQuc3ViYXJyYXkoZSxuKSk7Zm9yKHI9XCJcIjtlPG47KXt2YXIgaT10W2UrK107aWYoMTI4Jmkpe3ZhciBvPTYzJnRbZSsrXTtpZigxOTI9PSgyMjQmaSkpcis9U3RyaW5nLmZyb21DaGFyQ29kZSgoMzEmaSk8PDZ8byk7ZWxzZXt2YXIgYT02MyZ0W2UrK107NjU1MzY+KGk9MjI0PT0oMjQwJmkpPygxNSZpKTw8MTJ8bzw8NnxhOig3JmkpPDwxOHxvPDwxMnxhPDw2fDYzJnRbZSsrXSk/cis9U3RyaW5nLmZyb21DaGFyQ29kZShpKTooaS09NjU1MzYscis9U3RyaW5nLmZyb21DaGFyQ29kZSg1NTI5NnxpPj4xMCw1NjMyMHwxMDIzJmkpKX19ZWxzZSByKz1TdHJpbmcuZnJvbUNoYXJDb2RlKGkpfXJldHVybiByfWZ1bmN0aW9uICQodCxlKXtyZXR1cm4odD4+Pj0wKT9EKE8sdCxlKTpcIlwifWZ1bmN0aW9uIGsodCxlLG4scil7aWYoISgwPHIpKXJldHVybiAwO3ZhciBpPW4+Pj49MDtyPW4rci0xO2Zvcih2YXIgbz0wO288dC5sZW5ndGg7KytvKXt2YXIgYT10LmNoYXJDb2RlQXQobyk7aWYoNTUyOTY8PWEmJjU3MzQzPj1hJiYoYT02NTUzNisoKDEwMjMmYSk8PDEwKXwxMDIzJnQuY2hhckNvZGVBdCgrK28pKSwxMjc+PWEpe2lmKG4+PXIpYnJlYWs7ZVtuKys+Pj4wXT1hfWVsc2V7aWYoMjA0Nz49YSl7aWYobisxPj1yKWJyZWFrO2VbbisrPj4+MF09MTkyfGE+PjZ9ZWxzZXtpZig2NTUzNT49YSl7aWYobisyPj1yKWJyZWFrO2VbbisrPj4+MF09MjI0fGE+PjEyfWVsc2V7aWYobiszPj1yKWJyZWFrO2VbbisrPj4+MF09MjQwfGE+PjE4LGVbbisrPj4+MF09MTI4fGE+PjEyJjYzfWVbbisrPj4+MF09MTI4fGE+PjYmNjN9ZVtuKys+Pj4wXT0xMjh8NjMmYX19cmV0dXJuIGVbbj4+PjBdPTAsbi1pfWZ1bmN0aW9uIEModCl7Zm9yKHZhciBlPTAsbj0wO248dC5sZW5ndGg7KytuKXt2YXIgcj10LmNoYXJDb2RlQXQobik7MTI3Pj1yP2UrKzoyMDQ3Pj1yP2UrPTI6NTUyOTY8PXImJjU3MzQzPj1yPyhlKz00LCsrbik6ZSs9M31yZXR1cm4gZX1mdW5jdGlvbiBGKCl7dmFyIHQ9eC5idWZmZXI7VD10LGUuSEVBUDg9Uz1uZXcgSW50OEFycmF5KHQpLGUuSEVBUDE2PW5ldyBJbnQxNkFycmF5KHQpLGUuSEVBUDMyPUE9bmV3IEludDMyQXJyYXkodCksZS5IRUFQVTg9Tz1uZXcgVWludDhBcnJheSh0KSxlLkhFQVBVMTY9bmV3IFVpbnQxNkFycmF5KHQpLGUuSEVBUFUzMj1FPW5ldyBVaW50MzJBcnJheSh0KSxlLkhFQVBGMzI9bmV3IEZsb2F0MzJBcnJheSh0KSxlLkhFQVBGNjQ9bmV3IEZsb2F0NjRBcnJheSh0KX12YXIgTixSPVtdLEw9W10sTT1bXSxqPVtdLFU9MDtmdW5jdGlvbiBWKCl7dmFyIHQ9ZS5wcmVSdW4uc2hpZnQoKTtSLnVuc2hpZnQodCl9dmFyIEIsej0wLEc9bnVsbCxIPW51bGw7ZnVuY3Rpb24gcSh0KXt0aHJvdyBlLm9uQWJvcnQmJmUub25BYm9ydCh0KSx2KHQ9XCJBYm9ydGVkKFwiK3QrXCIpXCIpLEk9ITAsdD1uZXcgV2ViQXNzZW1ibHkuUnVudGltZUVycm9yKHQrXCIuIEJ1aWxkIHdpdGggLXNBU1NFUlRJT05TIGZvciBtb3JlIGluZm8uXCIpLGkodCksdH1mdW5jdGlvbiBXKCl7cmV0dXJuIEIuc3RhcnRzV2l0aChcImRhdGE6YXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtO2Jhc2U2NCxcIil9aWYoQj1cIm9ydC13YXNtLndhc21cIiwhVygpKXt2YXIgWD1CO0I9ZS5sb2NhdGVGaWxlP2UubG9jYXRlRmlsZShYLG0pOm0rWH1mdW5jdGlvbiBZKCl7dmFyIHQ9Qjt0cnl7aWYodD09QiYmeSlyZXR1cm4gbmV3IFVpbnQ4QXJyYXkoeSk7aWYocylyZXR1cm4gcyh0KTt0aHJvd1wiYm90aCBhc3luYyBhbmQgc3luYyBmZXRjaGluZyBvZiB0aGUgd2FzbSBmYWlsZWRcIn1jYXRjaCh0KXtxKHQpfX1mdW5jdGlvbiBLKHQpe3RoaXMubmFtZT1cIkV4aXRTdGF0dXNcIix0aGlzLm1lc3NhZ2U9XCJQcm9ncmFtIHRlcm1pbmF0ZWQgd2l0aCBleGl0KFwiK3QrXCIpXCIsdGhpcy5zdGF0dXM9dH1mdW5jdGlvbiBaKHQpe2Zvcig7MDx0Lmxlbmd0aDspdC5zaGlmdCgpKGUpfXZhciBKPVtdLFE9MCx0dD0wO2Z1bmN0aW9uIGV0KHQpe3RoaXMuRGI9dCx0aGlzLnpiPXQtMjQsdGhpcy5VYj1mdW5jdGlvbih0KXtFW3RoaXMuemIrND4+Mj4+PjBdPXR9LHRoaXMuRWI9ZnVuY3Rpb24oKXtyZXR1cm4gRVt0aGlzLnpiKzQ+PjI+Pj4wXX0sdGhpcy5TYj1mdW5jdGlvbih0KXtFW3RoaXMuemIrOD4+Mj4+PjBdPXR9LHRoaXMuV2I9ZnVuY3Rpb24oKXtyZXR1cm4gRVt0aGlzLnpiKzg+PjI+Pj4wXX0sdGhpcy5UYj1mdW5jdGlvbigpe0FbdGhpcy56Yj4+Mj4+PjBdPTB9LHRoaXMuSWI9ZnVuY3Rpb24odCl7U1t0aGlzLnpiKzEyPj4wPj4+MF09dD8xOjB9LHRoaXMuUGI9ZnVuY3Rpb24oKXtyZXR1cm4gMCE9U1t0aGlzLnpiKzEyPj4wPj4+MF19LHRoaXMuSmI9ZnVuY3Rpb24odCl7U1t0aGlzLnpiKzEzPj4wPj4+MF09dD8xOjB9LHRoaXMuTGI9ZnVuY3Rpb24oKXtyZXR1cm4gMCE9U1t0aGlzLnpiKzEzPj4wPj4+MF19LHRoaXMuUmI9ZnVuY3Rpb24odCxlKXt0aGlzLkZiKDApLHRoaXMuVWIodCksdGhpcy5TYihlKSx0aGlzLlRiKCksdGhpcy5JYighMSksdGhpcy5KYighMSl9LHRoaXMuTmI9ZnVuY3Rpb24oKXtBW3RoaXMuemI+PjI+Pj4wXSs9MX0sdGhpcy5YYj1mdW5jdGlvbigpe3ZhciB0PUFbdGhpcy56Yj4+Mj4+PjBdO3JldHVybiBBW3RoaXMuemI+PjI+Pj4wXT10LTEsMT09PXR9LHRoaXMuRmI9ZnVuY3Rpb24odCl7RVt0aGlzLnpiKzE2Pj4yPj4+MF09dH0sdGhpcy5PYj1mdW5jdGlvbigpe3JldHVybiBFW3RoaXMuemIrMTY+PjI+Pj4wXX0sdGhpcy5RYj1mdW5jdGlvbigpe2lmKEV0KHRoaXMuRWIoKSkpcmV0dXJuIEVbdGhpcy5EYj4+Mj4+PjBdO3ZhciB0PXRoaXMuT2IoKTtyZXR1cm4gMCE9PXQ/dDp0aGlzLkRifX1mdW5jdGlvbiBudCh0KXtyZXR1cm4gX3QobmV3IGV0KHQpLnpiKX12YXIgcnQ9W107ZnVuY3Rpb24gaXQodCl7dmFyIGU9cnRbdF07cmV0dXJuIGV8fCh0Pj1ydC5sZW5ndGgmJihydC5sZW5ndGg9dCsxKSxydFt0XT1lPU4uZ2V0KHQpKSxlfWZ1bmN0aW9uIG90KHQpe3ZhciBlPUModCkrMSxuPXl0KGUpO3JldHVybiBuJiZrKHQsUyxuLGUpLG59dmFyIGF0PXt9O2Z1bmN0aW9uIHN0KCl7aWYoIXV0KXt2YXIgdCxlPXtVU0VSOlwid2ViX3VzZXJcIixMT0dOQU1FOlwid2ViX3VzZXJcIixQQVRIOlwiL1wiLFBXRDpcIi9cIixIT01FOlwiL2hvbWUvd2ViX3VzZXJcIixMQU5HOihcIm9iamVjdFwiPT10eXBlb2YgbmF2aWdhdG9yJiZuYXZpZ2F0b3IubGFuZ3VhZ2VzJiZuYXZpZ2F0b3IubGFuZ3VhZ2VzWzBdfHxcIkNcIikucmVwbGFjZShcIi1cIixcIl9cIikrXCIuVVRGLThcIixfOmZ8fFwiLi90aGlzLnByb2dyYW1cIn07Zm9yKHQgaW4gYXQpdm9pZCAwPT09YXRbdF0/ZGVsZXRlIGVbdF06ZVt0XT1hdFt0XTt2YXIgbj1bXTtmb3IodCBpbiBlKW4ucHVzaCh0K1wiPVwiK2VbdF0pO3V0PW59cmV0dXJuIHV0fXZhciB1dCxjdD1bbnVsbCxbXSxbXV07ZnVuY3Rpb24gbHQodCxlKXt2YXIgbj1jdFt0XTswPT09ZXx8MTA9PT1lPygoMT09PXQ/Xzp2KShEKG4sMCkpLG4ubGVuZ3RoPTApOm4ucHVzaChlKX12YXIgcHQ9MDtmdW5jdGlvbiBmdCh0KXtyZXR1cm4gMD09dCU0JiYoMCE9dCUxMDB8fDA9PXQlNDAwKX12YXIgZHQ9WzMxLDI5LDMxLDMwLDMxLDMwLDMxLDMxLDMwLDMxLDMwLDMxXSxodD1bMzEsMjgsMzEsMzAsMzEsMzAsMzEsMzEsMzAsMzEsMzAsMzFdO2Z1bmN0aW9uIGd0KHQsZSxuLHIpe2Z1bmN0aW9uIGkodCxlLG4pe2Zvcih0PVwibnVtYmVyXCI9PXR5cGVvZiB0P3QudG9TdHJpbmcoKTp0fHxcIlwiO3QubGVuZ3RoPGU7KXQ9blswXSt0O3JldHVybiB0fWZ1bmN0aW9uIG8odCxlKXtyZXR1cm4gaSh0LGUsXCIwXCIpfWZ1bmN0aW9uIGEodCxlKXtmdW5jdGlvbiBuKHQpe3JldHVybiAwPnQ/LTE6MDx0PzE6MH12YXIgcjtyZXR1cm4gMD09PShyPW4odC5nZXRGdWxsWWVhcigpLWUuZ2V0RnVsbFllYXIoKSkpJiYwPT09KHI9bih0LmdldE1vbnRoKCktZS5nZXRNb250aCgpKSkmJihyPW4odC5nZXREYXRlKCktZS5nZXREYXRlKCkpKSxyfWZ1bmN0aW9uIHModCl7c3dpdGNoKHQuZ2V0RGF5KCkpe2Nhc2UgMDpyZXR1cm4gbmV3IERhdGUodC5nZXRGdWxsWWVhcigpLTEsMTEsMjkpO2Nhc2UgMTpyZXR1cm4gdDtjYXNlIDI6cmV0dXJuIG5ldyBEYXRlKHQuZ2V0RnVsbFllYXIoKSwwLDMpO2Nhc2UgMzpyZXR1cm4gbmV3IERhdGUodC5nZXRGdWxsWWVhcigpLDAsMik7Y2FzZSA0OnJldHVybiBuZXcgRGF0ZSh0LmdldEZ1bGxZZWFyKCksMCwxKTtjYXNlIDU6cmV0dXJuIG5ldyBEYXRlKHQuZ2V0RnVsbFllYXIoKS0xLDExLDMxKTtjYXNlIDY6cmV0dXJuIG5ldyBEYXRlKHQuZ2V0RnVsbFllYXIoKS0xLDExLDMwKX19ZnVuY3Rpb24gdSh0KXt2YXIgZT10LkJiO2Zvcih0PW5ldyBEYXRlKG5ldyBEYXRlKHQuQ2IrMTkwMCwwLDEpLmdldFRpbWUoKSk7MDxlOyl7dmFyIG49dC5nZXRNb250aCgpLHI9KGZ0KHQuZ2V0RnVsbFllYXIoKSk/ZHQ6aHQpW25dO2lmKCEoZT5yLXQuZ2V0RGF0ZSgpKSl7dC5zZXREYXRlKHQuZ2V0RGF0ZSgpK2UpO2JyZWFrfWUtPXItdC5nZXREYXRlKCkrMSx0LnNldERhdGUoMSksMTE+bj90LnNldE1vbnRoKG4rMSk6KHQuc2V0TW9udGgoMCksdC5zZXRGdWxsWWVhcih0LmdldEZ1bGxZZWFyKCkrMSkpfXJldHVybiBuPW5ldyBEYXRlKHQuZ2V0RnVsbFllYXIoKSsxLDAsNCksZT1zKG5ldyBEYXRlKHQuZ2V0RnVsbFllYXIoKSwwLDQpKSxuPXMobiksMD49YShlLHQpPzA+PWEobix0KT90LmdldEZ1bGxZZWFyKCkrMTp0LmdldEZ1bGxZZWFyKCk6dC5nZXRGdWxsWWVhcigpLTF9dmFyIGM9QVtyKzQwPj4yPj4+MF07Zm9yKHZhciBsIGluIHI9eyRiOkFbcj4+Mj4+PjBdLFpiOkFbcis0Pj4yPj4+MF0sR2I6QVtyKzg+PjI+Pj4wXSxLYjpBW3IrMTI+PjI+Pj4wXSxIYjpBW3IrMTY+PjI+Pj4wXSxDYjpBW3IrMjA+PjI+Pj4wXSxBYjpBW3IrMjQ+PjI+Pj4wXSxCYjpBW3IrMjg+PjI+Pj4wXSxiYzpBW3IrMzI+PjI+Pj4wXSxZYjpBW3IrMzY+PjI+Pj4wXSxhYzpjPyQoYyk6XCJcIn0sbj0kKG4pLGM9e1wiJWNcIjpcIiVhICViICVkICVIOiVNOiVTICVZXCIsXCIlRFwiOlwiJW0vJWQvJXlcIixcIiVGXCI6XCIlWS0lbS0lZFwiLFwiJWhcIjpcIiViXCIsXCIlclwiOlwiJUk6JU06JVMgJXBcIixcIiVSXCI6XCIlSDolTVwiLFwiJVRcIjpcIiVIOiVNOiVTXCIsXCIleFwiOlwiJW0vJWQvJXlcIixcIiVYXCI6XCIlSDolTTolU1wiLFwiJUVjXCI6XCIlY1wiLFwiJUVDXCI6XCIlQ1wiLFwiJUV4XCI6XCIlbS8lZC8leVwiLFwiJUVYXCI6XCIlSDolTTolU1wiLFwiJUV5XCI6XCIleVwiLFwiJUVZXCI6XCIlWVwiLFwiJU9kXCI6XCIlZFwiLFwiJU9lXCI6XCIlZVwiLFwiJU9IXCI6XCIlSFwiLFwiJU9JXCI6XCIlSVwiLFwiJU9tXCI6XCIlbVwiLFwiJU9NXCI6XCIlTVwiLFwiJU9TXCI6XCIlU1wiLFwiJU91XCI6XCIldVwiLFwiJU9VXCI6XCIlVVwiLFwiJU9WXCI6XCIlVlwiLFwiJU93XCI6XCIld1wiLFwiJU9XXCI6XCIlV1wiLFwiJU95XCI6XCIleVwifSluPW4ucmVwbGFjZShuZXcgUmVnRXhwKGwsXCJnXCIpLGNbbF0pO3ZhciBwPVwiU3VuZGF5IE1vbmRheSBUdWVzZGF5IFdlZG5lc2RheSBUaHVyc2RheSBGcmlkYXkgU2F0dXJkYXlcIi5zcGxpdChcIiBcIiksZj1cIkphbnVhcnkgRmVicnVhcnkgTWFyY2ggQXByaWwgTWF5IEp1bmUgSnVseSBBdWd1c3QgU2VwdGVtYmVyIE9jdG9iZXIgTm92ZW1iZXIgRGVjZW1iZXJcIi5zcGxpdChcIiBcIik7Zm9yKGwgaW4gYz17XCIlYVwiOmZ1bmN0aW9uKHQpe3JldHVybiBwW3QuQWJdLnN1YnN0cmluZygwLDMpfSxcIiVBXCI6ZnVuY3Rpb24odCl7cmV0dXJuIHBbdC5BYl19LFwiJWJcIjpmdW5jdGlvbih0KXtyZXR1cm4gZlt0LkhiXS5zdWJzdHJpbmcoMCwzKX0sXCIlQlwiOmZ1bmN0aW9uKHQpe3JldHVybiBmW3QuSGJdfSxcIiVDXCI6ZnVuY3Rpb24odCl7cmV0dXJuIG8oKHQuQ2IrMTkwMCkvMTAwfDAsMil9LFwiJWRcIjpmdW5jdGlvbih0KXtyZXR1cm4gbyh0LktiLDIpfSxcIiVlXCI6ZnVuY3Rpb24odCl7cmV0dXJuIGkodC5LYiwyLFwiIFwiKX0sXCIlZ1wiOmZ1bmN0aW9uKHQpe3JldHVybiB1KHQpLnRvU3RyaW5nKCkuc3Vic3RyaW5nKDIpfSxcIiVHXCI6ZnVuY3Rpb24odCl7cmV0dXJuIHUodCl9LFwiJUhcIjpmdW5jdGlvbih0KXtyZXR1cm4gbyh0LkdiLDIpfSxcIiVJXCI6ZnVuY3Rpb24odCl7cmV0dXJuIDA9PSh0PXQuR2IpP3Q9MTI6MTI8dCYmKHQtPTEyKSxvKHQsMil9LFwiJWpcIjpmdW5jdGlvbih0KXtmb3IodmFyIGU9MCxuPTA7bjw9dC5IYi0xO2UrPShmdCh0LkNiKzE5MDApP2R0Omh0KVtuKytdKTtyZXR1cm4gbyh0LktiK2UsMyl9LFwiJW1cIjpmdW5jdGlvbih0KXtyZXR1cm4gbyh0LkhiKzEsMil9LFwiJU1cIjpmdW5jdGlvbih0KXtyZXR1cm4gbyh0LlpiLDIpfSxcIiVuXCI6ZnVuY3Rpb24oKXtyZXR1cm5cIlxcblwifSxcIiVwXCI6ZnVuY3Rpb24odCl7cmV0dXJuIDA8PXQuR2ImJjEyPnQuR2I/XCJBTVwiOlwiUE1cIn0sXCIlU1wiOmZ1bmN0aW9uKHQpe3JldHVybiBvKHQuJGIsMil9LFwiJXRcIjpmdW5jdGlvbigpe3JldHVyblwiXFx0XCJ9LFwiJXVcIjpmdW5jdGlvbih0KXtyZXR1cm4gdC5BYnx8N30sXCIlVVwiOmZ1bmN0aW9uKHQpe3JldHVybiBvKE1hdGguZmxvb3IoKHQuQmIrNy10LkFiKS83KSwyKX0sXCIlVlwiOmZ1bmN0aW9uKHQpe3ZhciBlPU1hdGguZmxvb3IoKHQuQmIrNy0odC5BYis2KSU3KS83KTtpZigyPj0odC5BYiszNzEtdC5CYi0yKSU3JiZlKyssZSk1Mz09ZSYmKDQ9PShuPSh0LkFiKzM3MS10LkJiKSU3KXx8Mz09biYmZnQodC5DYil8fChlPTEpKTtlbHNle2U9NTI7dmFyIG49KHQuQWIrNy10LkJiLTEpJTc7KDQ9PW58fDU9PW4mJmZ0KHQuQ2IlNDAwLTEpKSYmZSsrfXJldHVybiBvKGUsMil9LFwiJXdcIjpmdW5jdGlvbih0KXtyZXR1cm4gdC5BYn0sXCIlV1wiOmZ1bmN0aW9uKHQpe3JldHVybiBvKE1hdGguZmxvb3IoKHQuQmIrNy0odC5BYis2KSU3KS83KSwyKX0sXCIleVwiOmZ1bmN0aW9uKHQpe3JldHVybih0LkNiKzE5MDApLnRvU3RyaW5nKCkuc3Vic3RyaW5nKDIpfSxcIiVZXCI6ZnVuY3Rpb24odCl7cmV0dXJuIHQuQ2IrMTkwMH0sXCIlelwiOmZ1bmN0aW9uKHQpe3ZhciBlPTA8PSh0PXQuWWIpO3JldHVybiB0PU1hdGguYWJzKHQpLzYwLChlP1wiK1wiOlwiLVwiKStTdHJpbmcoXCIwMDAwXCIrKHQvNjAqMTAwK3QlNjApKS5zbGljZSgtNCl9LFwiJVpcIjpmdW5jdGlvbih0KXtyZXR1cm4gdC5hY30sXCIlJVwiOmZ1bmN0aW9uKCl7cmV0dXJuXCIlXCJ9fSxuPW4ucmVwbGFjZSgvJSUvZyxcIlxcMFxcMFwiKSxjKW4uaW5jbHVkZXMobCkmJihuPW4ucmVwbGFjZShuZXcgUmVnRXhwKGwsXCJnXCIpLGNbbF0ocikpKTtyZXR1cm4gbD1mdW5jdGlvbih0KXt2YXIgZT1BcnJheShDKHQpKzEpO3JldHVybiBrKHQsZSwwLGUubGVuZ3RoKSxlfShuPW4ucmVwbGFjZSgvXFwwXFwwL2csXCIlXCIpKSxsLmxlbmd0aD5lPzA6KFMuc2V0KGwsdD4+PjApLGwubGVuZ3RoLTEpfXZhciBidD17YTpmdW5jdGlvbih0KXtyZXR1cm4geXQodCsyNCkrMjR9LG06ZnVuY3Rpb24odCl7cmV0dXJuKHQ9bmV3IGV0KHQpKS5QYigpfHwodC5JYighMCksUS0tKSx0LkpiKCExKSxKLnB1c2godCksdC5OYigpLHQuUWIoKX0saWE6ZnVuY3Rpb24odCl7dGhyb3cgdihcIlVuZXhwZWN0ZWQgZXhjZXB0aW9uIHRocm93biwgdGhpcyBpcyBub3QgcHJvcGVybHkgc3VwcG9ydGVkIC0gYWJvcnRpbmdcIiksST0hMCx0fSx3OmZ1bmN0aW9uKCl7eHQoMCk7dmFyIHQ9Si5wb3AoKTtpZih0LlhiKCkmJiF0LkxiKCkpe3ZhciBlPXQuV2IoKTtlJiZpdChlKSh0LkRiKSxudCh0LkRiKX10dD0wfSxkOmZ1bmN0aW9uKCl7dmFyIHQ9dHQ7aWYoIXQpcmV0dXJuIHB0PTA7dmFyIGU9bmV3IGV0KHQpO2UuRmIodCk7dmFyIG49ZS5FYigpO2lmKCFuKXJldHVybiBwdD0wLHQ7Zm9yKHZhciByPUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyksaT0wO2k8ci5sZW5ndGg7aSsrKXt2YXIgbz1yW2ldO2lmKDA9PT1vfHxvPT09bilicmVhaztpZihBdChvLG4sZS56YisxNikpcmV0dXJuIHB0PW8sdH1yZXR1cm4gcHQ9bix0fSxrOmZ1bmN0aW9uKCl7dmFyIHQ9dHQ7aWYoIXQpcmV0dXJuIHB0PTA7dmFyIGU9bmV3IGV0KHQpO2UuRmIodCk7dmFyIG49ZS5FYigpO2lmKCFuKXJldHVybiBwdD0wLHQ7Zm9yKHZhciByPUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyksaT0wO2k8ci5sZW5ndGg7aSsrKXt2YXIgbz1yW2ldO2lmKDA9PT1vfHxvPT09bilicmVhaztpZihBdChvLG4sZS56YisxNikpcmV0dXJuIHB0PW8sdH1yZXR1cm4gcHQ9bix0fSxnOmZ1bmN0aW9uKCl7dmFyIHQ9dHQ7aWYoIXQpcmV0dXJuIHB0PTA7dmFyIGU9bmV3IGV0KHQpO2UuRmIodCk7dmFyIG49ZS5FYigpO2lmKCFuKXJldHVybiBwdD0wLHQ7Zm9yKHZhciByPUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyksaT0wO2k8ci5sZW5ndGg7aSsrKXt2YXIgbz1yW2ldO2lmKDA9PT1vfHxvPT09bilicmVhaztpZihBdChvLG4sZS56YisxNikpcmV0dXJuIHB0PW8sdH1yZXR1cm4gcHQ9bix0fSxzOm50LEw6ZnVuY3Rpb24oKXt2YXIgdD1KLnBvcCgpO3R8fHEoXCJubyBleGNlcHRpb24gdG8gdGhyb3dcIik7dmFyIGU9dC5EYjt0aHJvdyB0LkxiKCl8fChKLnB1c2godCksdC5KYighMCksdC5JYighMSksUSsrKSx0dD1lLGV9LGI6ZnVuY3Rpb24odCxlLG4pe3Rocm93IG5ldyBldCh0KS5SYihlLG4pLHR0PXQsUSsrLHR9LGxhOmZ1bmN0aW9uKCl7cmV0dXJuIFF9LGk6ZnVuY3Rpb24odCl7dGhyb3cgdHR8fCh0dD10KSx0fSxIOmZ1bmN0aW9uKCl7cmV0dXJuIDB9LEJhOmZ1bmN0aW9uKCl7fSxwYTpmdW5jdGlvbigpe30scmE6ZnVuY3Rpb24oKXt9LGthOmZ1bmN0aW9uKCl7cmV0dXJuIDB9LHphOmZ1bmN0aW9uKCl7fSx1YTpmdW5jdGlvbigpe30seWE6ZnVuY3Rpb24oKXt9LFI6ZnVuY3Rpb24oKXt9LHFhOmZ1bmN0aW9uKCl7fSxuYTpmdW5jdGlvbigpe30sQWE6ZnVuY3Rpb24oKXt9LG9hOmZ1bmN0aW9uKCl7fSxIYTpmdW5jdGlvbigpe30sSmE6ZnVuY3Rpb24oKXtxKFwiVG8gdXNlIGRsb3BlbiwgeW91IG5lZWQgZW5hYmxlIGR5bmFtaWMgbGlua2luZywgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9lbXNjcmlwdGVuLWNvcmUvZW1zY3JpcHRlbi93aWtpL0xpbmtpbmdcIil9LElhOmZ1bmN0aW9uKCl7cShcIlRvIHVzZSBkbG9wZW4sIHlvdSBuZWVkIGVuYWJsZSBkeW5hbWljIGxpbmtpbmcsIHNlZSBodHRwczovL2dpdGh1Yi5jb20vZW1zY3JpcHRlbi1jb3JlL2Vtc2NyaXB0ZW4vd2lraS9MaW5raW5nXCIpfSxTOmZ1bmN0aW9uKCl7cmV0dXJuIERhdGUubm93KCl9LENhOmZ1bmN0aW9uKCl7cmV0dXJuITB9LERhOmZ1bmN0aW9uKHQsZSl7dD1uZXcgRGF0ZSgxZTMqKEVbdD4+PjJdKzQyOTQ5NjcyOTYqQVt0KzQ+Pj4yXSkpLEFbZT4+Mj4+PjBdPXQuZ2V0VVRDU2Vjb25kcygpLEFbZSs0Pj4yPj4+MF09dC5nZXRVVENNaW51dGVzKCksQVtlKzg+PjI+Pj4wXT10LmdldFVUQ0hvdXJzKCksQVtlKzEyPj4yPj4+MF09dC5nZXRVVENEYXRlKCksQVtlKzE2Pj4yPj4+MF09dC5nZXRVVENNb250aCgpLEFbZSsyMD4+Mj4+PjBdPXQuZ2V0VVRDRnVsbFllYXIoKS0xOTAwLEFbZSsyND4+Mj4+PjBdPXQuZ2V0VVRDRGF5KCksQVtlKzI4Pj4yPj4+MF09KHQuZ2V0VGltZSgpLURhdGUuVVRDKHQuZ2V0VVRDRnVsbFllYXIoKSwwLDEsMCwwLDAsMCkpLzg2NGU1fDB9LEVhOmZ1bmN0aW9uKHQsZSl7dD1uZXcgRGF0ZSgxZTMqKEVbdD4+PjJdKzQyOTQ5NjcyOTYqQVt0KzQ+Pj4yXSkpLEFbZT4+Mj4+PjBdPXQuZ2V0U2Vjb25kcygpLEFbZSs0Pj4yPj4+MF09dC5nZXRNaW51dGVzKCksQVtlKzg+PjI+Pj4wXT10LmdldEhvdXJzKCksQVtlKzEyPj4yPj4+MF09dC5nZXREYXRlKCksQVtlKzE2Pj4yPj4+MF09dC5nZXRNb250aCgpLEFbZSsyMD4+Mj4+PjBdPXQuZ2V0RnVsbFllYXIoKS0xOTAwLEFbZSsyND4+Mj4+PjBdPXQuZ2V0RGF5KCk7dmFyIG49bmV3IERhdGUodC5nZXRGdWxsWWVhcigpLDAsMSk7QVtlKzI4Pj4yPj4+MF09KHQuZ2V0VGltZSgpLW4uZ2V0VGltZSgpKS84NjRlNXwwLEFbZSszNj4+Mj4+PjBdPS02MCp0LmdldFRpbWV6b25lT2Zmc2V0KCk7dmFyIHI9bmV3IERhdGUodC5nZXRGdWxsWWVhcigpLDYsMSkuZ2V0VGltZXpvbmVPZmZzZXQoKTtuPW4uZ2V0VGltZXpvbmVPZmZzZXQoKSxBW2UrMzI+PjI+Pj4wXT0wfChyIT1uJiZ0LmdldFRpbWV6b25lT2Zmc2V0KCk9PU1hdGgubWluKG4scikpfSxGYTpmdW5jdGlvbih0KXt2YXIgZT1uZXcgRGF0ZShBW3QrMjA+PjI+Pj4wXSsxOTAwLEFbdCsxNj4+Mj4+PjBdLEFbdCsxMj4+Mj4+PjBdLEFbdCs4Pj4yPj4+MF0sQVt0KzQ+PjI+Pj4wXSxBW3Q+PjI+Pj4wXSwwKSxuPUFbdCszMj4+Mj4+PjBdLHI9ZS5nZXRUaW1lem9uZU9mZnNldCgpLGk9bmV3IERhdGUoZS5nZXRGdWxsWWVhcigpLDAsMSksbz1uZXcgRGF0ZShlLmdldEZ1bGxZZWFyKCksNiwxKS5nZXRUaW1lem9uZU9mZnNldCgpLGE9aS5nZXRUaW1lem9uZU9mZnNldCgpLHM9TWF0aC5taW4oYSxvKTtyZXR1cm4gMD5uP0FbdCszMj4+Mj4+PjBdPU51bWJlcihvIT1hJiZzPT1yKTowPG4hPShzPT1yKSYmKG89TWF0aC5tYXgoYSxvKSxlLnNldFRpbWUoZS5nZXRUaW1lKCkrNmU0KigoMDxuP3M6byktcikpKSxBW3QrMjQ+PjI+Pj4wXT1lLmdldERheSgpLEFbdCsyOD4+Mj4+PjBdPShlLmdldFRpbWUoKS1pLmdldFRpbWUoKSkvODY0ZTV8MCxBW3Q+PjI+Pj4wXT1lLmdldFNlY29uZHMoKSxBW3QrND4+Mj4+PjBdPWUuZ2V0TWludXRlcygpLEFbdCs4Pj4yPj4+MF09ZS5nZXRIb3VycygpLEFbdCsxMj4+Mj4+PjBdPWUuZ2V0RGF0ZSgpLEFbdCsxNj4+Mj4+PjBdPWUuZ2V0TW9udGgoKSxlLmdldFRpbWUoKS8xZTN8MH0sc2E6ZnVuY3Rpb24oKXtyZXR1cm4tNTJ9LHRhOmZ1bmN0aW9uKCl7fSxHYTpmdW5jdGlvbiB0KGUsbixyKXt0LlZifHwodC5WYj0hMCxmdW5jdGlvbih0LGUsbil7ZnVuY3Rpb24gcih0KXtyZXR1cm4odD10LnRvVGltZVN0cmluZygpLm1hdGNoKC9cXCgoW0EtWmEteiBdKylcXCkkLykpP3RbMV06XCJHTVRcIn12YXIgaT0obmV3IERhdGUpLmdldEZ1bGxZZWFyKCksbz1uZXcgRGF0ZShpLDAsMSksYT1uZXcgRGF0ZShpLDYsMSk7aT1vLmdldFRpbWV6b25lT2Zmc2V0KCk7dmFyIHM9YS5nZXRUaW1lem9uZU9mZnNldCgpO0FbdD4+Mj4+PjBdPTYwKk1hdGgubWF4KGkscyksQVtlPj4yPj4+MF09TnVtYmVyKGkhPXMpLHQ9cihvKSxlPXIoYSksdD1vdCh0KSxlPW90KGUpLHM8aT8oRVtuPj4yPj4+MF09dCxFW24rND4+Mj4+PjBdPWUpOihFW24+PjI+Pj4wXT1lLEVbbis0Pj4yPj4+MF09dCl9KGUsbixyKSl9LEI6ZnVuY3Rpb24oKXtxKFwiXCIpfSxtYTpmdW5jdGlvbigpe3JldHVybiA0Mjk0OTAxNzYwfSxJOmI/KCk9Pnt2YXIgdD1wcm9jZXNzLmhydGltZSgpO3JldHVybiAxZTMqdFswXSt0WzFdLzFlNn06KCk9PnBlcmZvcm1hbmNlLm5vdygpLHhhOmZ1bmN0aW9uKHQsZSxuKXtPLmNvcHlXaXRoaW4odD4+PjAsZT4+PjAsZStuPj4+MCl9LEc6ZnVuY3Rpb24odCl7dmFyIGU9Ty5sZW5ndGg7aWYoNDI5NDkwMTc2MDwodD4+Pj0wKSlyZXR1cm4hMTtmb3IodmFyIG49MTs0Pj1uO24qPTIpe3ZhciByPWUqKDErLjIvbik7cj1NYXRoLm1pbihyLHQrMTAwNjYzMjk2KTt2YXIgaT1NYXRoO3I9TWF0aC5tYXgodCxyKSxpPWkubWluLmNhbGwoaSw0Mjk0OTAxNzYwLHIrKDY1NTM2LXIlNjU1MzYpJTY1NTM2KTt0Ont0cnl7eC5ncm93KGktVC5ieXRlTGVuZ3RoKzY1NTM1Pj4+MTYpLEYoKTt2YXIgbz0xO2JyZWFrIHR9Y2F0Y2godCl7fW89dm9pZCAwfWlmKG8pcmV0dXJuITB9cmV0dXJuITF9LHZhOmZ1bmN0aW9uKHQsZSl7dmFyIG49MDtyZXR1cm4gc3QoKS5mb3JFYWNoKChmdW5jdGlvbihyLGkpe3ZhciBvPWUrbjtmb3IoaT1FW3QrNCppPj4yPj4+MF09byxvPTA7bzxyLmxlbmd0aDsrK28pU1tpKys+PjA+Pj4wXT1yLmNoYXJDb2RlQXQobyk7U1tpPj4wPj4+MF09MCxuKz1yLmxlbmd0aCsxfSkpLDB9LHdhOmZ1bmN0aW9uKHQsZSl7dmFyIG49c3QoKTtFW3Q+PjI+Pj4wXT1uLmxlbmd0aDt2YXIgcj0wO3JldHVybiBuLmZvckVhY2goKGZ1bmN0aW9uKHQpe3IrPXQubGVuZ3RoKzF9KSksRVtlPj4yPj4+MF09ciwwfSxiYTpmdW5jdGlvbih0KXt3fHwwPFV8fCh3dCgpLFooTSksdnQoMCksY3RbMV0ubGVuZ3RoJiZsdCgxLDEwKSxjdFsyXS5sZW5ndGgmJmx0KDIsMTApKSx3fHwwPFV8fChlLm9uRXhpdCYmZS5vbkV4aXQodCksST0hMCksZCh0LG5ldyBLKHQpKX0sRTpmdW5jdGlvbigpe3JldHVybiA1Mn0sUTpmdW5jdGlvbigpe3JldHVybiA1Mn0sY2E6ZnVuY3Rpb24oKXtyZXR1cm4gNzB9LFA6ZnVuY3Rpb24odCxlLG4scil7Zm9yKHZhciBpPTAsbz0wO288bjtvKyspe3ZhciBhPUVbZT4+Mj4+PjBdLHM9RVtlKzQ+PjI+Pj4wXTtlKz04O2Zvcih2YXIgdT0wO3U8czt1KyspbHQodCxPW2ErdT4+PjBdKTtpKz1zfXJldHVybiBFW3I+PjI+Pj4wXT1pLDB9LGM6ZnVuY3Rpb24oKXtyZXR1cm4gcHR9LGphOmZ1bmN0aW9uIHQoZSxyKXt0Lk1ifHwodC5NYj1mdW5jdGlvbigpe2lmKFwib2JqZWN0XCI9PXR5cGVvZiBjcnlwdG8mJlwiZnVuY3Rpb25cIj09dHlwZW9mIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMpe3ZhciB0PW5ldyBVaW50OEFycmF5KDEpO3JldHVybigpPT4oY3J5cHRvLmdldFJhbmRvbVZhbHVlcyh0KSx0WzBdKX1pZihiKXRyeXt2YXIgZT1uKDYxMTMpO3JldHVybigpPT5lLnJhbmRvbUJ5dGVzKDEpWzBdfWNhdGNoKHQpe31yZXR1cm4oKT0+cShcInJhbmRvbURldmljZVwiKX0oKSk7Zm9yKHZhciBpPTA7aTxyO2krKylTW2UraT4+MD4+PjBdPXQuTWIoKTtyZXR1cm4gMH0sZWE6ZnVuY3Rpb24odCxlLG4pe3ZhciByPVR0KCk7dHJ5e3JldHVybiBpdCh0KShlLG4pfWNhdGNoKHQpe2lmKFN0KHIpLHQhPT10KzApdGhyb3cgdDt4dCgxLDApfX0sZmE6ZnVuY3Rpb24odCxlLG4pe3ZhciByPVR0KCk7dHJ5e3JldHVybiBpdCh0KShlLG4pfWNhdGNoKHQpe2lmKFN0KHIpLHQhPT10KzApdGhyb3cgdDt4dCgxLDApfX0sSjpmdW5jdGlvbih0KXt2YXIgZT1UdCgpO3RyeXtyZXR1cm4gaXQodCkoKX1jYXRjaCh0KXtpZihTdChlKSx0IT09dCswKXRocm93IHQ7eHQoMSwwKX19LGU6ZnVuY3Rpb24odCxlKXt2YXIgbj1UdCgpO3RyeXtyZXR1cm4gaXQodCkoZSl9Y2F0Y2godCl7aWYoU3QobiksdCE9PXQrMCl0aHJvdyB0O3h0KDEsMCl9fSxOOmZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1UdCgpO3RyeXtyZXR1cm4gaXQodCkoZSxuKX1jYXRjaCh0KXtpZihTdChyKSx0IT09dCswKXRocm93IHQ7eHQoMSwwKX19LE86ZnVuY3Rpb24odCxlLG4pe3ZhciByPVR0KCk7dHJ5e3JldHVybiBpdCh0KShlLG4pfWNhdGNoKHQpe2lmKFN0KHIpLHQhPT10KzApdGhyb3cgdDt4dCgxLDApfX0sajpmdW5jdGlvbih0LGUsbil7dmFyIHI9VHQoKTt0cnl7cmV0dXJuIGl0KHQpKGUsbil9Y2F0Y2godCl7aWYoU3QociksdCE9PXQrMCl0aHJvdyB0O3h0KDEsMCl9fSxvOmZ1bmN0aW9uKHQsZSxuLHIpe3ZhciBpPVR0KCk7dHJ5e3JldHVybiBpdCh0KShlLG4scil9Y2F0Y2godCl7aWYoU3QoaSksdCE9PXQrMCl0aHJvdyB0O3h0KDEsMCl9fSxwOmZ1bmN0aW9uKHQsZSxuLHIsaSl7dmFyIG89VHQoKTt0cnl7cmV0dXJuIGl0KHQpKGUsbixyLGkpfWNhdGNoKHQpe2lmKFN0KG8pLHQhPT10KzApdGhyb3cgdDt4dCgxLDApfX0sTTpmdW5jdGlvbih0LGUsbixyLGksbyl7dmFyIGE9VHQoKTt0cnl7cmV0dXJuIGl0KHQpKGUsbixyLGksbyl9Y2F0Y2godCl7aWYoU3QoYSksdCE9PXQrMCl0aHJvdyB0O3h0KDEsMCl9fSxyOmZ1bmN0aW9uKHQsZSxuLHIsaSxvKXt2YXIgYT1UdCgpO3RyeXtyZXR1cm4gaXQodCkoZSxuLHIsaSxvKX1jYXRjaCh0KXtpZihTdChhKSx0IT09dCswKXRocm93IHQ7eHQoMSwwKX19LHY6ZnVuY3Rpb24odCxlLG4scixpLG8sYSl7dmFyIHM9VHQoKTt0cnl7cmV0dXJuIGl0KHQpKGUsbixyLGksbyxhKX1jYXRjaCh0KXtpZihTdChzKSx0IT09dCswKXRocm93IHQ7eHQoMSwwKX19LEs6ZnVuY3Rpb24odCxlLG4scixpLG8sYSxzKXt2YXIgdT1UdCgpO3RyeXtyZXR1cm4gaXQodCkoZSxuLHIsaSxvLGEscyl9Y2F0Y2godCl7aWYoU3QodSksdCE9PXQrMCl0aHJvdyB0O3h0KDEsMCl9fSxEOmZ1bmN0aW9uKHQsZSxuLHIsaSxvLGEscyx1LGMsbCxwKXt2YXIgZj1UdCgpO3RyeXtyZXR1cm4gaXQodCkoZSxuLHIsaSxvLGEscyx1LGMsbCxwKX1jYXRjaCh0KXtpZihTdChmKSx0IT09dCswKXRocm93IHQ7eHQoMSwwKX19LFg6ZnVuY3Rpb24odCxlLG4scixpLG8sYSxzKXt2YXIgdT1UdCgpO3RyeXtyZXR1cm4gUnQodCxlLG4scixpLG8sYSxzKX1jYXRjaCh0KXtpZihTdCh1KSx0IT09dCswKXRocm93IHQ7eHQoMSwwKX19LFY6ZnVuY3Rpb24odCxlLG4scixpLG8sYSl7dmFyIHM9VHQoKTt0cnl7cmV0dXJuIFB0KHQsZSxuLHIsaSxvLGEpfWNhdGNoKHQpe2lmKFN0KHMpLHQhPT10KzApdGhyb3cgdDt4dCgxLDApfX0sVTpmdW5jdGlvbih0LGUsbixyLGkpe3ZhciBvPVR0KCk7dHJ5e3JldHVybiBMdCh0LGUsbixyLGkpfWNhdGNoKHQpe2lmKFN0KG8pLHQhPT10KzApdGhyb3cgdDt4dCgxLDApfX0sWjpmdW5jdGlvbih0LGUsbixyKXt2YXIgaT1UdCgpO3RyeXtyZXR1cm4gRnQodCxlLG4scil9Y2F0Y2godCl7aWYoU3QoaSksdCE9PXQrMCl0aHJvdyB0O3h0KDEsMCl9fSxXOmZ1bmN0aW9uKHQpe3ZhciBlPVR0KCk7dHJ5e3JldHVybiBJdCh0KX1jYXRjaCh0KXtpZihTdChlKSx0IT09dCswKXRocm93IHQ7eHQoMSwwKX19LFk6ZnVuY3Rpb24odCxlKXt2YXIgbj1UdCgpO3RyeXtyZXR1cm4gTnQodCxlKX1jYXRjaCh0KXtpZihTdChuKSx0IT09dCswKXRocm93IHQ7eHQoMSwwKX19LFQ6ZnVuY3Rpb24odCxlLG4pe3ZhciByPVR0KCk7dHJ5e3JldHVybiBEdCh0LGUsbil9Y2F0Y2godCl7aWYoU3QociksdCE9PXQrMCl0aHJvdyB0O3h0KDEsMCl9fSxmOmZ1bmN0aW9uKHQpe3ZhciBlPVR0KCk7dHJ5e2l0KHQpKCl9Y2F0Y2godCl7aWYoU3QoZSksdCE9PXQrMCl0aHJvdyB0O3h0KDEsMCl9fSxxOmZ1bmN0aW9uKHQsZSl7dmFyIG49VHQoKTt0cnl7aXQodCkoZSl9Y2F0Y2godCl7aWYoU3QobiksdCE9PXQrMCl0aHJvdyB0O3h0KDEsMCl9fSxoOmZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1UdCgpO3RyeXtpdCh0KShlLG4pfWNhdGNoKHQpe2lmKFN0KHIpLHQhPT10KzApdGhyb3cgdDt4dCgxLDApfX0sZGE6ZnVuY3Rpb24odCxlLG4scil7dmFyIGk9VHQoKTt0cnl7aXQodCkoZSxuLHIpfWNhdGNoKHQpe2lmKFN0KGkpLHQhPT10KzApdGhyb3cgdDt4dCgxLDApfX0sbDpmdW5jdGlvbih0LGUsbixyKXt2YXIgaT1UdCgpO3RyeXtpdCh0KShlLG4scil9Y2F0Y2godCl7aWYoU3QoaSksdCE9PXQrMCl0aHJvdyB0O3h0KDEsMCl9fSx0OmZ1bmN0aW9uKHQsZSxuLHIsaSl7dmFyIG89VHQoKTt0cnl7aXQodCkoZSxuLHIsaSl9Y2F0Y2godCl7aWYoU3QobyksdCE9PXQrMCl0aHJvdyB0O3h0KDEsMCl9fSx1OmZ1bmN0aW9uKHQsZSxuLHIsaSxvKXt2YXIgYT1UdCgpO3RyeXtpdCh0KShlLG4scixpLG8pfWNhdGNoKHQpe2lmKFN0KGEpLHQhPT10KzApdGhyb3cgdDt4dCgxLDApfX0seDpmdW5jdGlvbih0LGUsbixyLGksbyxhKXt2YXIgcz1UdCgpO3RyeXtpdCh0KShlLG4scixpLG8sYSl9Y2F0Y2godCl7aWYoU3QocyksdCE9PXQrMCl0aHJvdyB0O3h0KDEsMCl9fSx6OmZ1bmN0aW9uKHQsZSxuLHIsaSxvLGEscyl7dmFyIHU9VHQoKTt0cnl7aXQodCkoZSxuLHIsaSxvLGEscyl9Y2F0Y2godCl7aWYoU3QodSksdCE9PXQrMCl0aHJvdyB0O3h0KDEsMCl9fSxnYTpmdW5jdGlvbih0LGUsbixyLGksbyxhLHMsdSl7dmFyIGM9VHQoKTt0cnl7aXQodCkoZSxuLHIsaSxvLGEscyx1KX1jYXRjaCh0KXtpZihTdChjKSx0IT09dCswKXRocm93IHQ7eHQoMSwwKX19LEE6ZnVuY3Rpb24odCxlLG4scixpLG8sYSxzLHUsYyxsKXt2YXIgcD1UdCgpO3RyeXtpdCh0KShlLG4scixpLG8sYSxzLHUsYyxsKX1jYXRjaCh0KXtpZihTdChwKSx0IT09dCswKXRocm93IHQ7eHQoMSwwKX19LEM6ZnVuY3Rpb24odCxlLG4scixpLG8sYSxzLHUsYyxsLHAsZixkLGgsZyl7dmFyIGI9VHQoKTt0cnl7aXQodCkoZSxuLHIsaSxvLGEscyx1LGMsbCxwLGYsZCxoLGcpfWNhdGNoKHQpe2lmKFN0KGIpLHQhPT10KzApdGhyb3cgdDt4dCgxLDApfX0sYWE6ZnVuY3Rpb24odCxlLG4scixpLG8sYSxzKXt2YXIgdT1UdCgpO3RyeXskdCh0LGUsbixyLGksbyxhLHMpfWNhdGNoKHQpe2lmKFN0KHUpLHQhPT10KzApdGhyb3cgdDt4dCgxLDApfX0sXzpmdW5jdGlvbih0LGUsbixyLGksbyxhLHMsdSxjLGwscCl7dmFyIGY9VHQoKTt0cnl7Q3QodCxlLG4scixpLG8sYSxzLHUsYyxsLHApfWNhdGNoKHQpe2lmKFN0KGYpLHQhPT10KzApdGhyb3cgdDt4dCgxLDApfX0sJDpmdW5jdGlvbih0LGUsbixyLGksbyl7dmFyIGE9VHQoKTt0cnl7a3QodCxlLG4scixpLG8pfWNhdGNoKHQpe2lmKFN0KGEpLHQhPT10KzApdGhyb3cgdDt4dCgxLDApfX0sbjpmdW5jdGlvbih0KXtyZXR1cm4gdH0sRjpmdW5jdGlvbih0KXtwdD10fSxoYTpndCx5OmZ1bmN0aW9uKHQsZSxuLHIpe3JldHVybiBndCh0LGUsbixyKX19OyFmdW5jdGlvbigpe2Z1bmN0aW9uIHQodCl7ZS5hc209dC5leHBvcnRzLHg9ZS5hc20uS2EsRigpLE49ZS5hc20uaWIsTC51bnNoaWZ0KGUuYXNtLkxhKSx6LS0sZS5tb25pdG9yUnVuRGVwZW5kZW5jaWVzJiZlLm1vbml0b3JSdW5EZXBlbmRlbmNpZXMoeiksMD09eiYmKG51bGwhPT1HJiYoY2xlYXJJbnRlcnZhbChHKSxHPW51bGwpLEgmJih0PUgsSD1udWxsLHQoKSkpfWZ1bmN0aW9uIG4oZSl7dChlLmluc3RhbmNlKX1mdW5jdGlvbiByKHQpe3JldHVybiBmdW5jdGlvbigpe2lmKCF5JiYoaHx8Zykpe2lmKFwiZnVuY3Rpb25cIj09dHlwZW9mIGZldGNoJiYhQi5zdGFydHNXaXRoKFwiZmlsZTovL1wiKSlyZXR1cm4gZmV0Y2goQix7Y3JlZGVudGlhbHM6XCJzYW1lLW9yaWdpblwifSkudGhlbigoZnVuY3Rpb24odCl7aWYoIXQub2spdGhyb3dcImZhaWxlZCB0byBsb2FkIHdhc20gYmluYXJ5IGZpbGUgYXQgJ1wiK0IrXCInXCI7cmV0dXJuIHQuYXJyYXlCdWZmZXIoKX0pKS5jYXRjaCgoZnVuY3Rpb24oKXtyZXR1cm4gWSgpfSkpO2lmKGEpcmV0dXJuIG5ldyBQcm9taXNlKChmdW5jdGlvbih0LGUpe2EoQiwoZnVuY3Rpb24oZSl7dChuZXcgVWludDhBcnJheShlKSl9KSxlKX0pKX1yZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoZnVuY3Rpb24oKXtyZXR1cm4gWSgpfSkpfSgpLnRoZW4oKGZ1bmN0aW9uKHQpe3JldHVybiBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZSh0LG8pfSkpLnRoZW4oKGZ1bmN0aW9uKHQpe3JldHVybiB0fSkpLnRoZW4odCwoZnVuY3Rpb24odCl7dihcImZhaWxlZCB0byBhc3luY2hyb25vdXNseSBwcmVwYXJlIHdhc206IFwiK3QpLHEodCl9KSl9dmFyIG89e2E6YnR9O2lmKHorKyxlLm1vbml0b3JSdW5EZXBlbmRlbmNpZXMmJmUubW9uaXRvclJ1bkRlcGVuZGVuY2llcyh6KSxlLmluc3RhbnRpYXRlV2FzbSl0cnl7cmV0dXJuIGUuaW5zdGFudGlhdGVXYXNtKG8sdCl9Y2F0Y2godCl7cmV0dXJuIHYoXCJNb2R1bGUuaW5zdGFudGlhdGVXYXNtIGNhbGxiYWNrIGZhaWxlZCB3aXRoIGVycm9yOiBcIit0KSwhMX0oeXx8XCJmdW5jdGlvblwiIT10eXBlb2YgV2ViQXNzZW1ibHkuaW5zdGFudGlhdGVTdHJlYW1pbmd8fFcoKXx8Qi5zdGFydHNXaXRoKFwiZmlsZTovL1wiKXx8Ynx8XCJmdW5jdGlvblwiIT10eXBlb2YgZmV0Y2g/cihuKTpmZXRjaChCLHtjcmVkZW50aWFsczpcInNhbWUtb3JpZ2luXCJ9KS50aGVuKChmdW5jdGlvbih0KXtyZXR1cm4gV2ViQXNzZW1ibHkuaW5zdGFudGlhdGVTdHJlYW1pbmcodCxvKS50aGVuKG4sKGZ1bmN0aW9uKHQpe3JldHVybiB2KFwid2FzbSBzdHJlYW1pbmcgY29tcGlsZSBmYWlsZWQ6IFwiK3QpLHYoXCJmYWxsaW5nIGJhY2sgdG8gQXJyYXlCdWZmZXIgaW5zdGFudGlhdGlvblwiKSxyKG4pfSkpfSkpKS5jYXRjaChpKX0oKSxlLl9fX3dhc21fY2FsbF9jdG9ycz1mdW5jdGlvbigpe3JldHVybihlLl9fX3dhc21fY2FsbF9jdG9ycz1lLmFzbS5MYSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxlLl9PcnRJbml0PWZ1bmN0aW9uKCl7cmV0dXJuKGUuX09ydEluaXQ9ZS5hc20uTWEpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sZS5fT3J0Q3JlYXRlU2Vzc2lvbk9wdGlvbnM9ZnVuY3Rpb24oKXtyZXR1cm4oZS5fT3J0Q3JlYXRlU2Vzc2lvbk9wdGlvbnM9ZS5hc20uTmEpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sZS5fT3J0QXBwZW5kRXhlY3V0aW9uUHJvdmlkZXI9ZnVuY3Rpb24oKXtyZXR1cm4oZS5fT3J0QXBwZW5kRXhlY3V0aW9uUHJvdmlkZXI9ZS5hc20uT2EpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sZS5fT3J0QWRkU2Vzc2lvbkNvbmZpZ0VudHJ5PWZ1bmN0aW9uKCl7cmV0dXJuKGUuX09ydEFkZFNlc3Npb25Db25maWdFbnRyeT1lLmFzbS5QYSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxlLl9PcnRSZWxlYXNlU2Vzc2lvbk9wdGlvbnM9ZnVuY3Rpb24oKXtyZXR1cm4oZS5fT3J0UmVsZWFzZVNlc3Npb25PcHRpb25zPWUuYXNtLlFhKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGUuX09ydENyZWF0ZVNlc3Npb249ZnVuY3Rpb24oKXtyZXR1cm4oZS5fT3J0Q3JlYXRlU2Vzc2lvbj1lLmFzbS5SYSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxlLl9PcnRSZWxlYXNlU2Vzc2lvbj1mdW5jdGlvbigpe3JldHVybihlLl9PcnRSZWxlYXNlU2Vzc2lvbj1lLmFzbS5TYSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxlLl9PcnRHZXRJbnB1dENvdW50PWZ1bmN0aW9uKCl7cmV0dXJuKGUuX09ydEdldElucHV0Q291bnQ9ZS5hc20uVGEpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sZS5fT3J0R2V0T3V0cHV0Q291bnQ9ZnVuY3Rpb24oKXtyZXR1cm4oZS5fT3J0R2V0T3V0cHV0Q291bnQ9ZS5hc20uVWEpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sZS5fT3J0R2V0SW5wdXROYW1lPWZ1bmN0aW9uKCl7cmV0dXJuKGUuX09ydEdldElucHV0TmFtZT1lLmFzbS5WYSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxlLl9PcnRHZXRPdXRwdXROYW1lPWZ1bmN0aW9uKCl7cmV0dXJuKGUuX09ydEdldE91dHB1dE5hbWU9ZS5hc20uV2EpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sZS5fT3J0RnJlZT1mdW5jdGlvbigpe3JldHVybihlLl9PcnRGcmVlPWUuYXNtLlhhKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGUuX09ydENyZWF0ZVRlbnNvcj1mdW5jdGlvbigpe3JldHVybihlLl9PcnRDcmVhdGVUZW5zb3I9ZS5hc20uWWEpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sZS5fT3J0R2V0VGVuc29yRGF0YT1mdW5jdGlvbigpe3JldHVybihlLl9PcnRHZXRUZW5zb3JEYXRhPWUuYXNtLlphKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGUuX09ydFJlbGVhc2VUZW5zb3I9ZnVuY3Rpb24oKXtyZXR1cm4oZS5fT3J0UmVsZWFzZVRlbnNvcj1lLmFzbS5fYSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxlLl9PcnRDcmVhdGVSdW5PcHRpb25zPWZ1bmN0aW9uKCl7cmV0dXJuKGUuX09ydENyZWF0ZVJ1bk9wdGlvbnM9ZS5hc20uJGEpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sZS5fT3J0QWRkUnVuQ29uZmlnRW50cnk9ZnVuY3Rpb24oKXtyZXR1cm4oZS5fT3J0QWRkUnVuQ29uZmlnRW50cnk9ZS5hc20uYWIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sZS5fT3J0UmVsZWFzZVJ1bk9wdGlvbnM9ZnVuY3Rpb24oKXtyZXR1cm4oZS5fT3J0UmVsZWFzZVJ1bk9wdGlvbnM9ZS5hc20uYmIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sZS5fT3J0UnVuPWZ1bmN0aW9uKCl7cmV0dXJuKGUuX09ydFJ1bj1lLmFzbS5jYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxlLl9PcnRFbmRQcm9maWxpbmc9ZnVuY3Rpb24oKXtyZXR1cm4oZS5fT3J0RW5kUHJvZmlsaW5nPWUuYXNtLmRiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O3ZhciBtdCx5dD1lLl9tYWxsb2M9ZnVuY3Rpb24oKXtyZXR1cm4oeXQ9ZS5fbWFsbG9jPWUuYXNtLmViKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LF90PWUuX2ZyZWU9ZnVuY3Rpb24oKXtyZXR1cm4oX3Q9ZS5fZnJlZT1lLmFzbS5mYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSx2dD1lLl9mZmx1c2g9ZnVuY3Rpb24oKXtyZXR1cm4odnQ9ZS5fZmZsdXNoPWUuYXNtLmdiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHd0PWUuX19fZnVuY3Nfb25fZXhpdD1mdW5jdGlvbigpe3JldHVybih3dD1lLl9fX2Z1bmNzX29uX2V4aXQ9ZS5hc20uaGIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0seHQ9ZS5fc2V0VGhyZXc9ZnVuY3Rpb24oKXtyZXR1cm4oeHQ9ZS5fc2V0VGhyZXc9ZS5hc20uamIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sVHQ9ZS5zdGFja1NhdmU9ZnVuY3Rpb24oKXtyZXR1cm4oVHQ9ZS5zdGFja1NhdmU9ZS5hc20ua2IpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sU3Q9ZS5zdGFja1Jlc3RvcmU9ZnVuY3Rpb24oKXtyZXR1cm4oU3Q9ZS5zdGFja1Jlc3RvcmU9ZS5hc20ubGIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sT3Q9ZS5zdGFja0FsbG9jPWZ1bmN0aW9uKCl7cmV0dXJuKE90PWUuc3RhY2tBbGxvYz1lLmFzbS5tYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxBdD1lLl9fX2N4YV9jYW5fY2F0Y2g9ZnVuY3Rpb24oKXtyZXR1cm4oQXQ9ZS5fX19jeGFfY2FuX2NhdGNoPWUuYXNtLm5iKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LEV0PWUuX19fY3hhX2lzX3BvaW50ZXJfdHlwZT1mdW5jdGlvbigpe3JldHVybihFdD1lLl9fX2N4YV9pc19wb2ludGVyX3R5cGU9ZS5hc20ub2IpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sSXQ9ZS5keW5DYWxsX2o9ZnVuY3Rpb24oKXtyZXR1cm4oSXQ9ZS5keW5DYWxsX2o9ZS5hc20ucGIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sUHQ9ZS5keW5DYWxsX2lpaWlpaj1mdW5jdGlvbigpe3JldHVybihQdD1lLmR5bkNhbGxfaWlpaWlqPWUuYXNtLnFiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LER0PWUuZHluQ2FsbF9qaWk9ZnVuY3Rpb24oKXtyZXR1cm4oRHQ9ZS5keW5DYWxsX2ppaT1lLmFzbS5yYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSwkdD1lLmR5bkNhbGxfdmlpaWlpaj1mdW5jdGlvbigpe3JldHVybigkdD1lLmR5bkNhbGxfdmlpaWlpaj1lLmFzbS5zYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxrdD1lLmR5bkNhbGxfdmpqaT1mdW5jdGlvbigpe3JldHVybihrdD1lLmR5bkNhbGxfdmpqaT1lLmFzbS50YikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxDdD1lLmR5bkNhbGxfdmlpaWpqamlpPWZ1bmN0aW9uKCl7cmV0dXJuKEN0PWUuZHluQ2FsbF92aWlpampqaWk9ZS5hc20udWIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sRnQ9ZS5keW5DYWxsX2lpaj1mdW5jdGlvbigpe3JldHVybihGdD1lLmR5bkNhbGxfaWlqPWUuYXNtLnZiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LE50PWUuZHluQ2FsbF9qaT1mdW5jdGlvbigpe3JldHVybihOdD1lLmR5bkNhbGxfamk9ZS5hc20ud2IpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sUnQ9ZS5keW5DYWxsX2lpaWlpaWo9ZnVuY3Rpb24oKXtyZXR1cm4oUnQ9ZS5keW5DYWxsX2lpaWlpaWo9ZS5hc20ueGIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sTHQ9ZS5keW5DYWxsX2lpaWo9ZnVuY3Rpb24oKXtyZXR1cm4oTHQ9ZS5keW5DYWxsX2lpaWo9ZS5hc20ueWIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX07ZnVuY3Rpb24gTXQoKXtmdW5jdGlvbiB0KCl7aWYoIW10JiYobXQ9ITAsZS5jYWxsZWRSdW49ITAsIUkpKXtpZihaKEwpLHIoZSksZS5vblJ1bnRpbWVJbml0aWFsaXplZCYmZS5vblJ1bnRpbWVJbml0aWFsaXplZCgpLGUucG9zdFJ1bilmb3IoXCJmdW5jdGlvblwiPT10eXBlb2YgZS5wb3N0UnVuJiYoZS5wb3N0UnVuPVtlLnBvc3RSdW5dKTtlLnBvc3RSdW4ubGVuZ3RoOyl7dmFyIHQ9ZS5wb3N0UnVuLnNoaWZ0KCk7ai51bnNoaWZ0KHQpfVooail9fWlmKCEoMDx6KSl7aWYoZS5wcmVSdW4pZm9yKFwiZnVuY3Rpb25cIj09dHlwZW9mIGUucHJlUnVuJiYoZS5wcmVSdW49W2UucHJlUnVuXSk7ZS5wcmVSdW4ubGVuZ3RoOylWKCk7WihSKSwwPHp8fChlLnNldFN0YXR1cz8oZS5zZXRTdGF0dXMoXCJSdW5uaW5nLi4uXCIpLHNldFRpbWVvdXQoKGZ1bmN0aW9uKCl7c2V0VGltZW91dCgoZnVuY3Rpb24oKXtlLnNldFN0YXR1cyhcIlwiKX0pLDEpLHQoKX0pLDEpKTp0KCkpfX1pZihlLlVURjhUb1N0cmluZz0kLGUuc3RyaW5nVG9VVEY4PWZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gayh0LE8sZSxuKX0sZS5sZW5ndGhCeXRlc1VURjg9QyxlLnN0YWNrU2F2ZT1UdCxlLnN0YWNrUmVzdG9yZT1TdCxlLnN0YWNrQWxsb2M9T3QsSD1mdW5jdGlvbiB0KCl7bXR8fE10KCksbXR8fChIPXQpfSxlLnByZUluaXQpZm9yKFwiZnVuY3Rpb25cIj09dHlwZW9mIGUucHJlSW5pdCYmKGUucHJlSW5pdD1bZS5wcmVJbml0XSk7MDxlLnByZUluaXQubGVuZ3RoOyllLnByZUluaXQucG9wKCkoKTtyZXR1cm4gTXQoKSx0LnJlYWR5fSk7dC5leHBvcnRzPXJ9LDQ1Mzc6dD0+e1widXNlIHN0cmljdFwiO3QuZXhwb3J0cz1mdW5jdGlvbih0LGUpe2Zvcih2YXIgbj1uZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aC0xKSxyPTAsaT0yLG89ITA7aTxhcmd1bWVudHMubGVuZ3RoOyluW3IrK109YXJndW1lbnRzW2krK107cmV0dXJuIG5ldyBQcm9taXNlKChmdW5jdGlvbihpLGEpe25bcl09ZnVuY3Rpb24odCl7aWYobylpZihvPSExLHQpYSh0KTtlbHNle2Zvcih2YXIgZT1uZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aC0xKSxuPTA7bjxlLmxlbmd0aDspZVtuKytdPWFyZ3VtZW50c1tuXTtpLmFwcGx5KG51bGwsZSl9fTt0cnl7dC5hcHBseShlfHxudWxsLG4pfWNhdGNoKHQpe28mJihvPSExLGEodCkpfX0pKX19LDc0MTk6KHQsZSk9PntcInVzZSBzdHJpY3RcIjt2YXIgbj1lO24ubGVuZ3RoPWZ1bmN0aW9uKHQpe3ZhciBlPXQubGVuZ3RoO2lmKCFlKXJldHVybiAwO2Zvcih2YXIgbj0wOy0tZSU0PjEmJlwiPVwiPT09dC5jaGFyQXQoZSk7KSsrbjtyZXR1cm4gTWF0aC5jZWlsKDMqdC5sZW5ndGgpLzQtbn07Zm9yKHZhciByPW5ldyBBcnJheSg2NCksaT1uZXcgQXJyYXkoMTIzKSxvPTA7bzw2NDspaVtyW29dPW88MjY/bys2NTpvPDUyP28rNzE6bzw2Mj9vLTQ6by01OXw0M109bysrO24uZW5jb2RlPWZ1bmN0aW9uKHQsZSxuKXtmb3IodmFyIGksbz1udWxsLGE9W10scz0wLHU9MDtlPG47KXt2YXIgYz10W2UrK107c3dpdGNoKHUpe2Nhc2UgMDphW3MrK109cltjPj4yXSxpPSgzJmMpPDw0LHU9MTticmVhaztjYXNlIDE6YVtzKytdPXJbaXxjPj40XSxpPSgxNSZjKTw8Mix1PTI7YnJlYWs7Y2FzZSAyOmFbcysrXT1yW2l8Yz4+Nl0sYVtzKytdPXJbNjMmY10sdT0wfXM+ODE5MSYmKChvfHwobz1bXSkpLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsYSkpLHM9MCl9cmV0dXJuIHUmJihhW3MrK109cltpXSxhW3MrK109NjEsMT09PXUmJihhW3MrK109NjEpKSxvPyhzJiZvLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsYS5zbGljZSgwLHMpKSksby5qb2luKFwiXCIpKTpTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZyxhLnNsaWNlKDAscykpfTt2YXIgYT1cImludmFsaWQgZW5jb2RpbmdcIjtuLmRlY29kZT1mdW5jdGlvbih0LGUsbil7Zm9yKHZhciByLG89bixzPTAsdT0wO3U8dC5sZW5ndGg7KXt2YXIgYz10LmNoYXJDb2RlQXQodSsrKTtpZig2MT09PWMmJnM+MSlicmVhaztpZih2b2lkIDA9PT0oYz1pW2NdKSl0aHJvdyBFcnJvcihhKTtzd2l0Y2gocyl7Y2FzZSAwOnI9YyxzPTE7YnJlYWs7Y2FzZSAxOmVbbisrXT1yPDwyfCg0OCZjKT4+NCxyPWMscz0yO2JyZWFrO2Nhc2UgMjplW24rK109KDE1JnIpPDw0fCg2MCZjKT4+MixyPWMscz0zO2JyZWFrO2Nhc2UgMzplW24rK109KDMmcik8PDZ8YyxzPTB9fWlmKDE9PT1zKXRocm93IEVycm9yKGEpO3JldHVybiBuLW99LG4udGVzdD1mdW5jdGlvbih0KXtyZXR1cm4vXig/OltBLVphLXowLTkrL117NH0pKig/OltBLVphLXowLTkrL117Mn09PXxbQS1aYS16MC05Ky9dezN9PSk/JC8udGVzdCh0KX19LDkyMTE6dD0+e1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIGUoKXt0aGlzLl9saXN0ZW5lcnM9e319dC5leHBvcnRzPWUsZS5wcm90b3R5cGUub249ZnVuY3Rpb24odCxlLG4pe3JldHVybih0aGlzLl9saXN0ZW5lcnNbdF18fCh0aGlzLl9saXN0ZW5lcnNbdF09W10pKS5wdXNoKHtmbjplLGN0eDpufHx0aGlzfSksdGhpc30sZS5wcm90b3R5cGUub2ZmPWZ1bmN0aW9uKHQsZSl7aWYodm9pZCAwPT09dCl0aGlzLl9saXN0ZW5lcnM9e307ZWxzZSBpZih2b2lkIDA9PT1lKXRoaXMuX2xpc3RlbmVyc1t0XT1bXTtlbHNlIGZvcih2YXIgbj10aGlzLl9saXN0ZW5lcnNbdF0scj0wO3I8bi5sZW5ndGg7KW5bcl0uZm49PT1lP24uc3BsaWNlKHIsMSk6KytyO3JldHVybiB0aGlzfSxlLnByb3RvdHlwZS5lbWl0PWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMuX2xpc3RlbmVyc1t0XTtpZihlKXtmb3IodmFyIG49W10scj0xO3I8YXJndW1lbnRzLmxlbmd0aDspbi5wdXNoKGFyZ3VtZW50c1tyKytdKTtmb3Iocj0wO3I8ZS5sZW5ndGg7KWVbcl0uZm4uYXBwbHkoZVtyKytdLmN0eCxuKX1yZXR1cm4gdGhpc319LDk0NTp0PT57XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gZSh0KXtyZXR1cm5cInVuZGVmaW5lZFwiIT10eXBlb2YgRmxvYXQzMkFycmF5P2Z1bmN0aW9uKCl7dmFyIGU9bmV3IEZsb2F0MzJBcnJheShbLTBdKSxuPW5ldyBVaW50OEFycmF5KGUuYnVmZmVyKSxyPTEyOD09PW5bM107ZnVuY3Rpb24gaSh0LHIsaSl7ZVswXT10LHJbaV09blswXSxyW2krMV09blsxXSxyW2krMl09blsyXSxyW2krM109blszXX1mdW5jdGlvbiBvKHQscixpKXtlWzBdPXQscltpXT1uWzNdLHJbaSsxXT1uWzJdLHJbaSsyXT1uWzFdLHJbaSszXT1uWzBdfWZ1bmN0aW9uIGEodCxyKXtyZXR1cm4gblswXT10W3JdLG5bMV09dFtyKzFdLG5bMl09dFtyKzJdLG5bM109dFtyKzNdLGVbMF19ZnVuY3Rpb24gcyh0LHIpe3JldHVybiBuWzNdPXRbcl0sblsyXT10W3IrMV0sblsxXT10W3IrMl0sblswXT10W3IrM10sZVswXX10LndyaXRlRmxvYXRMRT1yP2k6byx0LndyaXRlRmxvYXRCRT1yP286aSx0LnJlYWRGbG9hdExFPXI/YTpzLHQucmVhZEZsb2F0QkU9cj9zOmF9KCk6ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKHQsZSxuLHIpe3ZhciBpPWU8MD8xOjA7aWYoaSYmKGU9LWUpLDA9PT1lKXQoMS9lPjA/MDoyMTQ3NDgzNjQ4LG4scik7ZWxzZSBpZihpc05hTihlKSl0KDIxNDMyODkzNDQsbixyKTtlbHNlIGlmKGU+MzQwMjgyMzQ2NjM4NTI4ODZlMjIpdCgoaTw8MzF8MjEzOTA5NTA0MCk+Pj4wLG4scik7ZWxzZSBpZihlPDExNzU0OTQzNTA4MjIyODc1ZS01NCl0KChpPDwzMXxNYXRoLnJvdW5kKGUvMTQwMTI5ODQ2NDMyNDgxN2UtNjApKT4+PjAsbixyKTtlbHNle3ZhciBvPU1hdGguZmxvb3IoTWF0aC5sb2coZSkvTWF0aC5MTjIpO3QoKGk8PDMxfG8rMTI3PDwyM3w4Mzg4NjA3Jk1hdGgucm91bmQoZSpNYXRoLnBvdygyLC1vKSo4Mzg4NjA4KSk+Pj4wLG4scil9fWZ1bmN0aW9uIGEodCxlLG4pe3ZhciByPXQoZSxuKSxpPTIqKHI+PjMxKSsxLG89cj4+PjIzJjI1NSxhPTgzODg2MDcmcjtyZXR1cm4gMjU1PT09bz9hP05hTjppKigxLzApOjA9PT1vPzE0MDEyOTg0NjQzMjQ4MTdlLTYwKmkqYTppKk1hdGgucG93KDIsby0xNTApKihhKzgzODg2MDgpfXQud3JpdGVGbG9hdExFPWUuYmluZChudWxsLG4pLHQud3JpdGVGbG9hdEJFPWUuYmluZChudWxsLHIpLHQucmVhZEZsb2F0TEU9YS5iaW5kKG51bGwsaSksdC5yZWFkRmxvYXRCRT1hLmJpbmQobnVsbCxvKX0oKSxcInVuZGVmaW5lZFwiIT10eXBlb2YgRmxvYXQ2NEFycmF5P2Z1bmN0aW9uKCl7dmFyIGU9bmV3IEZsb2F0NjRBcnJheShbLTBdKSxuPW5ldyBVaW50OEFycmF5KGUuYnVmZmVyKSxyPTEyOD09PW5bN107ZnVuY3Rpb24gaSh0LHIsaSl7ZVswXT10LHJbaV09blswXSxyW2krMV09blsxXSxyW2krMl09blsyXSxyW2krM109blszXSxyW2krNF09bls0XSxyW2krNV09bls1XSxyW2krNl09bls2XSxyW2krN109bls3XX1mdW5jdGlvbiBvKHQscixpKXtlWzBdPXQscltpXT1uWzddLHJbaSsxXT1uWzZdLHJbaSsyXT1uWzVdLHJbaSszXT1uWzRdLHJbaSs0XT1uWzNdLHJbaSs1XT1uWzJdLHJbaSs2XT1uWzFdLHJbaSs3XT1uWzBdfWZ1bmN0aW9uIGEodCxyKXtyZXR1cm4gblswXT10W3JdLG5bMV09dFtyKzFdLG5bMl09dFtyKzJdLG5bM109dFtyKzNdLG5bNF09dFtyKzRdLG5bNV09dFtyKzVdLG5bNl09dFtyKzZdLG5bN109dFtyKzddLGVbMF19ZnVuY3Rpb24gcyh0LHIpe3JldHVybiBuWzddPXRbcl0sbls2XT10W3IrMV0sbls1XT10W3IrMl0sbls0XT10W3IrM10sblszXT10W3IrNF0sblsyXT10W3IrNV0sblsxXT10W3IrNl0sblswXT10W3IrN10sZVswXX10LndyaXRlRG91YmxlTEU9cj9pOm8sdC53cml0ZURvdWJsZUJFPXI/bzppLHQucmVhZERvdWJsZUxFPXI/YTpzLHQucmVhZERvdWJsZUJFPXI/czphfSgpOmZ1bmN0aW9uKCl7ZnVuY3Rpb24gZSh0LGUsbixyLGksbyl7dmFyIGE9cjwwPzE6MDtpZihhJiYocj0tciksMD09PXIpdCgwLGksbytlKSx0KDEvcj4wPzA6MjE0NzQ4MzY0OCxpLG8rbik7ZWxzZSBpZihpc05hTihyKSl0KDAsaSxvK2UpLHQoMjE0Njk1OTM2MCxpLG8rbik7ZWxzZSBpZihyPjE3OTc2OTMxMzQ4NjIzMTU3ZTI5Mil0KDAsaSxvK2UpLHQoKGE8PDMxfDIxNDY0MzUwNzIpPj4+MCxpLG8rbik7ZWxzZXt2YXIgcztpZihyPDIyMjUwNzM4NTg1MDcyMDE0ZS0zMjQpdCgocz1yLzVlLTMyNCk+Pj4wLGksbytlKSx0KChhPDwzMXxzLzQyOTQ5NjcyOTYpPj4+MCxpLG8rbik7ZWxzZXt2YXIgdT1NYXRoLmZsb29yKE1hdGgubG9nKHIpL01hdGguTE4yKTsxMDI0PT09dSYmKHU9MTAyMyksdCg0NTAzNTk5NjI3MzcwNDk2KihzPXIqTWF0aC5wb3coMiwtdSkpPj4+MCxpLG8rZSksdCgoYTw8MzF8dSsxMDIzPDwyMHwxMDQ4NTc2KnMmMTA0ODU3NSk+Pj4wLGksbytuKX19fWZ1bmN0aW9uIGEodCxlLG4scixpKXt2YXIgbz10KHIsaStlKSxhPXQocixpK24pLHM9MiooYT4+MzEpKzEsdT1hPj4+MjAmMjA0NyxjPTQyOTQ5NjcyOTYqKDEwNDg1NzUmYSkrbztyZXR1cm4gMjA0Nz09PXU/Yz9OYU46cyooMS8wKTowPT09dT81ZS0zMjQqcypjOnMqTWF0aC5wb3coMix1LTEwNzUpKihjKzQ1MDM1OTk2MjczNzA0OTYpfXQud3JpdGVEb3VibGVMRT1lLmJpbmQobnVsbCxuLDAsNCksdC53cml0ZURvdWJsZUJFPWUuYmluZChudWxsLHIsNCwwKSx0LnJlYWREb3VibGVMRT1hLmJpbmQobnVsbCxpLDAsNCksdC5yZWFkRG91YmxlQkU9YS5iaW5kKG51bGwsbyw0LDApfSgpLHR9ZnVuY3Rpb24gbih0LGUsbil7ZVtuXT0yNTUmdCxlW24rMV09dD4+PjgmMjU1LGVbbisyXT10Pj4+MTYmMjU1LGVbbiszXT10Pj4+MjR9ZnVuY3Rpb24gcih0LGUsbil7ZVtuXT10Pj4+MjQsZVtuKzFdPXQ+Pj4xNiYyNTUsZVtuKzJdPXQ+Pj44JjI1NSxlW24rM109MjU1JnR9ZnVuY3Rpb24gaSh0LGUpe3JldHVybih0W2VdfHRbZSsxXTw8OHx0W2UrMl08PDE2fHRbZSszXTw8MjQpPj4+MH1mdW5jdGlvbiBvKHQsZSl7cmV0dXJuKHRbZV08PDI0fHRbZSsxXTw8MTZ8dFtlKzJdPDw4fHRbZSszXSk+Pj4wfXQuZXhwb3J0cz1lKGUpfSw3MTk5Om1vZHVsZT0+e1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIGlucXVpcmUobW9kdWxlTmFtZSl7dHJ5e3ZhciBtb2Q9ZXZhbChcInF1aXJlXCIucmVwbGFjZSgvXi8sXCJyZVwiKSkobW9kdWxlTmFtZSk7aWYobW9kJiYobW9kLmxlbmd0aHx8T2JqZWN0LmtleXMobW9kKS5sZW5ndGgpKXJldHVybiBtb2R9Y2F0Y2godCl7fXJldHVybiBudWxsfW1vZHVsZS5leHBvcnRzPWlucXVpcmV9LDY2NjI6dD0+e1widXNlIHN0cmljdFwiO3QuZXhwb3J0cz1mdW5jdGlvbih0LGUsbil7dmFyIHI9bnx8ODE5MixpPXI+Pj4xLG89bnVsbCxhPXI7cmV0dXJuIGZ1bmN0aW9uKG4pe2lmKG48MXx8bj5pKXJldHVybiB0KG4pO2Erbj5yJiYobz10KHIpLGE9MCk7dmFyIHM9ZS5jYWxsKG8sYSxhKz1uKTtyZXR1cm4gNyZhJiYoYT0xKyg3fGEpKSxzfX19LDQ5OTc6KHQsZSk9PntcInVzZSBzdHJpY3RcIjt2YXIgbj1lO24ubGVuZ3RoPWZ1bmN0aW9uKHQpe2Zvcih2YXIgZT0wLG49MCxyPTA7cjx0Lmxlbmd0aDsrK3IpKG49dC5jaGFyQ29kZUF0KHIpKTwxMjg/ZSs9MTpuPDIwNDg/ZSs9Mjo1NTI5Nj09KDY0NTEyJm4pJiY1NjMyMD09KDY0NTEyJnQuY2hhckNvZGVBdChyKzEpKT8oKytyLGUrPTQpOmUrPTM7cmV0dXJuIGV9LG4ucmVhZD1mdW5jdGlvbih0LGUsbil7aWYobi1lPDEpcmV0dXJuXCJcIjtmb3IodmFyIHIsaT1udWxsLG89W10sYT0wO2U8bjspKHI9dFtlKytdKTwxMjg/b1thKytdPXI6cj4xOTEmJnI8MjI0P29bYSsrXT0oMzEmcik8PDZ8NjMmdFtlKytdOnI+MjM5JiZyPDM2NT8ocj0oKDcmcik8PDE4fCg2MyZ0W2UrK10pPDwxMnwoNjMmdFtlKytdKTw8Nnw2MyZ0W2UrK10pLTY1NTM2LG9bYSsrXT01NTI5Nisocj4+MTApLG9bYSsrXT01NjMyMCsoMTAyMyZyKSk6b1thKytdPSgxNSZyKTw8MTJ8KDYzJnRbZSsrXSk8PDZ8NjMmdFtlKytdLGE+ODE5MSYmKChpfHwoaT1bXSkpLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsbykpLGE9MCk7cmV0dXJuIGk/KGEmJmkucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZyxvLnNsaWNlKDAsYSkpKSxpLmpvaW4oXCJcIikpOlN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLG8uc2xpY2UoMCxhKSl9LG4ud3JpdGU9ZnVuY3Rpb24odCxlLG4pe2Zvcih2YXIgcixpLG89bixhPTA7YTx0Lmxlbmd0aDsrK2EpKHI9dC5jaGFyQ29kZUF0KGEpKTwxMjg/ZVtuKytdPXI6cjwyMDQ4PyhlW24rK109cj4+NnwxOTIsZVtuKytdPTYzJnJ8MTI4KTo1NTI5Nj09KDY0NTEyJnIpJiY1NjMyMD09KDY0NTEyJihpPXQuY2hhckNvZGVBdChhKzEpKSk/KHI9NjU1MzYrKCgxMDIzJnIpPDwxMCkrKDEwMjMmaSksKythLGVbbisrXT1yPj4xOHwyNDAsZVtuKytdPXI+PjEyJjYzfDEyOCxlW24rK109cj4+NiY2M3wxMjgsZVtuKytdPTYzJnJ8MTI4KTooZVtuKytdPXI+PjEyfDIyNCxlW24rK109cj4+NiY2M3wxMjgsZVtuKytdPTYzJnJ8MTI4KTtyZXR1cm4gbi1vfX0sMzQ0MjoodCxlKT0+e1widXNlIHN0cmljdFwiO2UuX19lc01vZHVsZT0hMDt2YXIgbj1mdW5jdGlvbigpe2Z1bmN0aW9uIHQoZSl7aWYoIWUpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXJndW1lbnQ7IGB2YWx1ZWAgaGFzIG5vIHZhbHVlLlwiKTt0aGlzLnZhbHVlPXQuRU1QVFksZSYmdC5pc0d1aWQoZSkmJih0aGlzLnZhbHVlPWUpfXJldHVybiB0LmlzR3VpZD1mdW5jdGlvbihlKXt2YXIgbj1lLnRvU3RyaW5nKCk7cmV0dXJuIGUmJihlIGluc3RhbmNlb2YgdHx8dC52YWxpZGF0b3IudGVzdChuKSl9LHQuY3JlYXRlPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyB0KFt0LmdlbigyKSx0LmdlbigxKSx0LmdlbigxKSx0LmdlbigxKSx0LmdlbigzKV0uam9pbihcIi1cIikpfSx0LmNyZWF0ZUVtcHR5PWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyB0KFwiZW1wdHlndWlkXCIpfSx0LnBhcnNlPWZ1bmN0aW9uKGUpe3JldHVybiBuZXcgdChlKX0sdC5yYXc9ZnVuY3Rpb24oKXtyZXR1cm5bdC5nZW4oMiksdC5nZW4oMSksdC5nZW4oMSksdC5nZW4oMSksdC5nZW4oMyldLmpvaW4oXCItXCIpfSx0Lmdlbj1mdW5jdGlvbih0KXtmb3IodmFyIGU9XCJcIixuPTA7bjx0O24rKyllKz0oNjU1MzYqKDErTWF0aC5yYW5kb20oKSl8MCkudG9TdHJpbmcoMTYpLnN1YnN0cmluZygxKTtyZXR1cm4gZX0sdC5wcm90b3R5cGUuZXF1YWxzPWZ1bmN0aW9uKGUpe3JldHVybiB0LmlzR3VpZChlKSYmdGhpcy52YWx1ZT09PWUudG9TdHJpbmcoKX0sdC5wcm90b3R5cGUuaXNFbXB0eT1mdW5jdGlvbigpe3JldHVybiB0aGlzLnZhbHVlPT09dC5FTVBUWX0sdC5wcm90b3R5cGUudG9TdHJpbmc9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy52YWx1ZX0sdC5wcm90b3R5cGUudG9KU09OPWZ1bmN0aW9uKCl7cmV0dXJue3ZhbHVlOnRoaXMudmFsdWV9fSx0LnZhbGlkYXRvcj1uZXcgUmVnRXhwKFwiXlthLXowLTldezh9LVthLXowLTldezR9LVthLXowLTldezR9LVthLXowLTldezR9LVthLXowLTldezEyfSRcIixcImlcIiksdC5FTVBUWT1cIjAwMDAwMDAwLTAwMDAtMDAwMC0wMDAwLTAwMDAwMDAwMDAwMFwiLHR9KCk7ZS5HdWlkPW59LDM3MjA6dD0+e3QuZXhwb3J0cz1uO3ZhciBlPW51bGw7dHJ5e2U9bmV3IFdlYkFzc2VtYmx5Lkluc3RhbmNlKG5ldyBXZWJBc3NlbWJseS5Nb2R1bGUobmV3IFVpbnQ4QXJyYXkoWzAsOTcsMTE1LDEwOSwxLDAsMCwwLDEsMTMsMiw5NiwwLDEsMTI3LDk2LDQsMTI3LDEyNywxMjcsMTI3LDEsMTI3LDMsNyw2LDAsMSwxLDEsMSwxLDYsNiwxLDEyNywxLDY1LDAsMTEsNyw1MCw2LDMsMTA5LDExNywxMDgsMCwxLDUsMTAwLDEwNSwxMTgsOTUsMTE1LDAsMiw1LDEwMCwxMDUsMTE4LDk1LDExNywwLDMsNSwxMTQsMTAxLDEwOSw5NSwxMTUsMCw0LDUsMTE0LDEwMSwxMDksOTUsMTE3LDAsNSw4LDEwMywxMDEsMTE2LDk1LDEwNCwxMDUsMTAzLDEwNCwwLDAsMTAsMTkxLDEsNiw0LDAsMzUsMCwxMSwzNiwxLDEsMTI2LDMyLDAsMTczLDMyLDEsMTczLDY2LDMyLDEzNCwxMzIsMzIsMiwxNzMsMzIsMywxNzMsNjYsMzIsMTM0LDEzMiwxMjYsMzQsNCw2NiwzMiwxMzUsMTY3LDM2LDAsMzIsNCwxNjcsMTEsMzYsMSwxLDEyNiwzMiwwLDE3MywzMiwxLDE3Myw2NiwzMiwxMzQsMTMyLDMyLDIsMTczLDMyLDMsMTczLDY2LDMyLDEzNCwxMzIsMTI3LDM0LDQsNjYsMzIsMTM1LDE2NywzNiwwLDMyLDQsMTY3LDExLDM2LDEsMSwxMjYsMzIsMCwxNzMsMzIsMSwxNzMsNjYsMzIsMTM0LDEzMiwzMiwyLDE3MywzMiwzLDE3Myw2NiwzMiwxMzQsMTMyLDEyOCwzNCw0LDY2LDMyLDEzNSwxNjcsMzYsMCwzMiw0LDE2NywxMSwzNiwxLDEsMTI2LDMyLDAsMTczLDMyLDEsMTczLDY2LDMyLDEzNCwxMzIsMzIsMiwxNzMsMzIsMywxNzMsNjYsMzIsMTM0LDEzMiwxMjksMzQsNCw2NiwzMiwxMzUsMTY3LDM2LDAsMzIsNCwxNjcsMTEsMzYsMSwxLDEyNiwzMiwwLDE3MywzMiwxLDE3Myw2NiwzMiwxMzQsMTMyLDMyLDIsMTczLDMyLDMsMTczLDY2LDMyLDEzNCwxMzIsMTMwLDM0LDQsNjYsMzIsMTM1LDE2NywzNiwwLDMyLDQsMTY3LDExXSkpLHt9KS5leHBvcnRzfWNhdGNoKHQpe31mdW5jdGlvbiBuKHQsZSxuKXt0aGlzLmxvdz0wfHQsdGhpcy5oaWdoPTB8ZSx0aGlzLnVuc2lnbmVkPSEhbn1mdW5jdGlvbiByKHQpe3JldHVybiEwPT09KHQmJnQuX19pc0xvbmdfXyl9bi5wcm90b3R5cGUuX19pc0xvbmdfXyxPYmplY3QuZGVmaW5lUHJvcGVydHkobi5wcm90b3R5cGUsXCJfX2lzTG9uZ19fXCIse3ZhbHVlOiEwfSksbi5pc0xvbmc9cjt2YXIgaT17fSxvPXt9O2Z1bmN0aW9uIGEodCxlKXt2YXIgbixyLGE7cmV0dXJuIGU/KGE9MDw9KHQ+Pj49MCkmJnQ8MjU2KSYmKHI9b1t0XSk/cjoobj11KHQsKDB8dCk8MD8tMTowLCEwKSxhJiYob1t0XT1uKSxuKTooYT0tMTI4PD0odHw9MCkmJnQ8MTI4KSYmKHI9aVt0XSk/cjoobj11KHQsdDwwPy0xOjAsITEpLGEmJihpW3RdPW4pLG4pfWZ1bmN0aW9uIHModCxlKXtpZihpc05hTih0KSlyZXR1cm4gZT9tOmI7aWYoZSl7aWYodDwwKXJldHVybiBtO2lmKHQ+PWQpcmV0dXJuIHh9ZWxzZXtpZih0PD0taClyZXR1cm4gVDtpZih0KzE+PWgpcmV0dXJuIHd9cmV0dXJuIHQ8MD9zKC10LGUpLm5lZygpOnUodCVmfDAsdC9mfDAsZSl9ZnVuY3Rpb24gdSh0LGUscil7cmV0dXJuIG5ldyBuKHQsZSxyKX1uLmZyb21JbnQ9YSxuLmZyb21OdW1iZXI9cyxuLmZyb21CaXRzPXU7dmFyIGM9TWF0aC5wb3c7ZnVuY3Rpb24gbCh0LGUsbil7aWYoMD09PXQubGVuZ3RoKXRocm93IEVycm9yKFwiZW1wdHkgc3RyaW5nXCIpO2lmKFwiTmFOXCI9PT10fHxcIkluZmluaXR5XCI9PT10fHxcIitJbmZpbml0eVwiPT09dHx8XCItSW5maW5pdHlcIj09PXQpcmV0dXJuIGI7aWYoXCJudW1iZXJcIj09dHlwZW9mIGU/KG49ZSxlPSExKTplPSEhZSwobj1ufHwxMCk8Mnx8MzY8bil0aHJvdyBSYW5nZUVycm9yKFwicmFkaXhcIik7dmFyIHI7aWYoKHI9dC5pbmRleE9mKFwiLVwiKSk+MCl0aHJvdyBFcnJvcihcImludGVyaW9yIGh5cGhlblwiKTtpZigwPT09cilyZXR1cm4gbCh0LnN1YnN0cmluZygxKSxlLG4pLm5lZygpO2Zvcih2YXIgaT1zKGMobiw4KSksbz1iLGE9MDthPHQubGVuZ3RoO2ErPTgpe3ZhciB1PU1hdGgubWluKDgsdC5sZW5ndGgtYSkscD1wYXJzZUludCh0LnN1YnN0cmluZyhhLGErdSksbik7aWYodTw4KXt2YXIgZj1zKGMobix1KSk7bz1vLm11bChmKS5hZGQocyhwKSl9ZWxzZSBvPShvPW8ubXVsKGkpKS5hZGQocyhwKSl9cmV0dXJuIG8udW5zaWduZWQ9ZSxvfWZ1bmN0aW9uIHAodCxlKXtyZXR1cm5cIm51bWJlclwiPT10eXBlb2YgdD9zKHQsZSk6XCJzdHJpbmdcIj09dHlwZW9mIHQ/bCh0LGUpOnUodC5sb3csdC5oaWdoLFwiYm9vbGVhblwiPT10eXBlb2YgZT9lOnQudW5zaWduZWQpfW4uZnJvbVN0cmluZz1sLG4uZnJvbVZhbHVlPXA7dmFyIGY9NDI5NDk2NzI5NixkPWYqZixoPWQvMixnPWEoMTw8MjQpLGI9YSgwKTtuLlpFUk89Yjt2YXIgbT1hKDAsITApO24uVVpFUk89bTt2YXIgeT1hKDEpO24uT05FPXk7dmFyIF89YSgxLCEwKTtuLlVPTkU9Xzt2YXIgdj1hKC0xKTtuLk5FR19PTkU9djt2YXIgdz11KC0xLDIxNDc0ODM2NDcsITEpO24uTUFYX1ZBTFVFPXc7dmFyIHg9dSgtMSwtMSwhMCk7bi5NQVhfVU5TSUdORURfVkFMVUU9eDt2YXIgVD11KDAsLTIxNDc0ODM2NDgsITEpO24uTUlOX1ZBTFVFPVQ7dmFyIFM9bi5wcm90b3R5cGU7Uy50b0ludD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnVuc2lnbmVkP3RoaXMubG93Pj4+MDp0aGlzLmxvd30sUy50b051bWJlcj1mdW5jdGlvbigpe3JldHVybiB0aGlzLnVuc2lnbmVkPyh0aGlzLmhpZ2g+Pj4wKSpmKyh0aGlzLmxvdz4+PjApOnRoaXMuaGlnaCpmKyh0aGlzLmxvdz4+PjApfSxTLnRvU3RyaW5nPWZ1bmN0aW9uKHQpe2lmKCh0PXR8fDEwKTwyfHwzNjx0KXRocm93IFJhbmdlRXJyb3IoXCJyYWRpeFwiKTtpZih0aGlzLmlzWmVybygpKXJldHVyblwiMFwiO2lmKHRoaXMuaXNOZWdhdGl2ZSgpKXtpZih0aGlzLmVxKFQpKXt2YXIgZT1zKHQpLG49dGhpcy5kaXYoZSkscj1uLm11bChlKS5zdWIodGhpcyk7cmV0dXJuIG4udG9TdHJpbmcodCkrci50b0ludCgpLnRvU3RyaW5nKHQpfXJldHVyblwiLVwiK3RoaXMubmVnKCkudG9TdHJpbmcodCl9Zm9yKHZhciBpPXMoYyh0LDYpLHRoaXMudW5zaWduZWQpLG89dGhpcyxhPVwiXCI7Oyl7dmFyIHU9by5kaXYoaSksbD0oby5zdWIodS5tdWwoaSkpLnRvSW50KCk+Pj4wKS50b1N0cmluZyh0KTtpZigobz11KS5pc1plcm8oKSlyZXR1cm4gbCthO2Zvcig7bC5sZW5ndGg8NjspbD1cIjBcIitsO2E9XCJcIitsK2F9fSxTLmdldEhpZ2hCaXRzPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaGlnaH0sUy5nZXRIaWdoQml0c1Vuc2lnbmVkPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaGlnaD4+PjB9LFMuZ2V0TG93Qml0cz1mdW5jdGlvbigpe3JldHVybiB0aGlzLmxvd30sUy5nZXRMb3dCaXRzVW5zaWduZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5sb3c+Pj4wfSxTLmdldE51bUJpdHNBYnM9ZnVuY3Rpb24oKXtpZih0aGlzLmlzTmVnYXRpdmUoKSlyZXR1cm4gdGhpcy5lcShUKT82NDp0aGlzLm5lZygpLmdldE51bUJpdHNBYnMoKTtmb3IodmFyIHQ9MCE9dGhpcy5oaWdoP3RoaXMuaGlnaDp0aGlzLmxvdyxlPTMxO2U+MCYmMD09KHQmMTw8ZSk7ZS0tKTtyZXR1cm4gMCE9dGhpcy5oaWdoP2UrMzM6ZSsxfSxTLmlzWmVybz1mdW5jdGlvbigpe3JldHVybiAwPT09dGhpcy5oaWdoJiYwPT09dGhpcy5sb3d9LFMuZXF6PVMuaXNaZXJvLFMuaXNOZWdhdGl2ZT1mdW5jdGlvbigpe3JldHVybiF0aGlzLnVuc2lnbmVkJiZ0aGlzLmhpZ2g8MH0sUy5pc1Bvc2l0aXZlPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudW5zaWduZWR8fHRoaXMuaGlnaD49MH0sUy5pc09kZD1mdW5jdGlvbigpe3JldHVybiAxPT0oMSZ0aGlzLmxvdyl9LFMuaXNFdmVuPWZ1bmN0aW9uKCl7cmV0dXJuIDA9PSgxJnRoaXMubG93KX0sUy5lcXVhbHM9ZnVuY3Rpb24odCl7cmV0dXJuIHIodCl8fCh0PXAodCkpLCh0aGlzLnVuc2lnbmVkPT09dC51bnNpZ25lZHx8dGhpcy5oaWdoPj4+MzEhPTF8fHQuaGlnaD4+PjMxIT0xKSYmdGhpcy5oaWdoPT09dC5oaWdoJiZ0aGlzLmxvdz09PXQubG93fSxTLmVxPVMuZXF1YWxzLFMubm90RXF1YWxzPWZ1bmN0aW9uKHQpe3JldHVybiF0aGlzLmVxKHQpfSxTLm5lcT1TLm5vdEVxdWFscyxTLm5lPVMubm90RXF1YWxzLFMubGVzc1RoYW49ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuY29tcCh0KTwwfSxTLmx0PVMubGVzc1RoYW4sUy5sZXNzVGhhbk9yRXF1YWw9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuY29tcCh0KTw9MH0sUy5sdGU9Uy5sZXNzVGhhbk9yRXF1YWwsUy5sZT1TLmxlc3NUaGFuT3JFcXVhbCxTLmdyZWF0ZXJUaGFuPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmNvbXAodCk+MH0sUy5ndD1TLmdyZWF0ZXJUaGFuLFMuZ3JlYXRlclRoYW5PckVxdWFsPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmNvbXAodCk+PTB9LFMuZ3RlPVMuZ3JlYXRlclRoYW5PckVxdWFsLFMuZ2U9Uy5ncmVhdGVyVGhhbk9yRXF1YWwsUy5jb21wYXJlPWZ1bmN0aW9uKHQpe2lmKHIodCl8fCh0PXAodCkpLHRoaXMuZXEodCkpcmV0dXJuIDA7dmFyIGU9dGhpcy5pc05lZ2F0aXZlKCksbj10LmlzTmVnYXRpdmUoKTtyZXR1cm4gZSYmIW4/LTE6IWUmJm4/MTp0aGlzLnVuc2lnbmVkP3QuaGlnaD4+PjA+dGhpcy5oaWdoPj4+MHx8dC5oaWdoPT09dGhpcy5oaWdoJiZ0Lmxvdz4+PjA+dGhpcy5sb3c+Pj4wPy0xOjE6dGhpcy5zdWIodCkuaXNOZWdhdGl2ZSgpPy0xOjF9LFMuY29tcD1TLmNvbXBhcmUsUy5uZWdhdGU9ZnVuY3Rpb24oKXtyZXR1cm4hdGhpcy51bnNpZ25lZCYmdGhpcy5lcShUKT9UOnRoaXMubm90KCkuYWRkKHkpfSxTLm5lZz1TLm5lZ2F0ZSxTLmFkZD1mdW5jdGlvbih0KXtyKHQpfHwodD1wKHQpKTt2YXIgZT10aGlzLmhpZ2g+Pj4xNixuPTY1NTM1JnRoaXMuaGlnaCxpPXRoaXMubG93Pj4+MTYsbz02NTUzNSZ0aGlzLmxvdyxhPXQuaGlnaD4+PjE2LHM9NjU1MzUmdC5oaWdoLGM9dC5sb3c+Pj4xNixsPTAsZj0wLGQ9MCxoPTA7cmV0dXJuIGQrPShoKz1vKyg2NTUzNSZ0LmxvdykpPj4+MTYsZis9KGQrPWkrYyk+Pj4xNixsKz0oZis9bitzKT4+PjE2LGwrPWUrYSx1KChkJj02NTUzNSk8PDE2fChoJj02NTUzNSksKGwmPTY1NTM1KTw8MTZ8KGYmPTY1NTM1KSx0aGlzLnVuc2lnbmVkKX0sUy5zdWJ0cmFjdD1mdW5jdGlvbih0KXtyZXR1cm4gcih0KXx8KHQ9cCh0KSksdGhpcy5hZGQodC5uZWcoKSl9LFMuc3ViPVMuc3VidHJhY3QsUy5tdWx0aXBseT1mdW5jdGlvbih0KXtpZih0aGlzLmlzWmVybygpKXJldHVybiBiO2lmKHIodCl8fCh0PXAodCkpLGUpcmV0dXJuIHUoZS5tdWwodGhpcy5sb3csdGhpcy5oaWdoLHQubG93LHQuaGlnaCksZS5nZXRfaGlnaCgpLHRoaXMudW5zaWduZWQpO2lmKHQuaXNaZXJvKCkpcmV0dXJuIGI7aWYodGhpcy5lcShUKSlyZXR1cm4gdC5pc09kZCgpP1Q6YjtpZih0LmVxKFQpKXJldHVybiB0aGlzLmlzT2RkKCk/VDpiO2lmKHRoaXMuaXNOZWdhdGl2ZSgpKXJldHVybiB0LmlzTmVnYXRpdmUoKT90aGlzLm5lZygpLm11bCh0Lm5lZygpKTp0aGlzLm5lZygpLm11bCh0KS5uZWcoKTtpZih0LmlzTmVnYXRpdmUoKSlyZXR1cm4gdGhpcy5tdWwodC5uZWcoKSkubmVnKCk7aWYodGhpcy5sdChnKSYmdC5sdChnKSlyZXR1cm4gcyh0aGlzLnRvTnVtYmVyKCkqdC50b051bWJlcigpLHRoaXMudW5zaWduZWQpO3ZhciBuPXRoaXMuaGlnaD4+PjE2LGk9NjU1MzUmdGhpcy5oaWdoLG89dGhpcy5sb3c+Pj4xNixhPTY1NTM1JnRoaXMubG93LGM9dC5oaWdoPj4+MTYsbD02NTUzNSZ0LmhpZ2gsZj10Lmxvdz4+PjE2LGQ9NjU1MzUmdC5sb3csaD0wLG09MCx5PTAsXz0wO3JldHVybiB5Kz0oXys9YSpkKT4+PjE2LG0rPSh5Kz1vKmQpPj4+MTYseSY9NjU1MzUsbSs9KHkrPWEqZik+Pj4xNixoKz0obSs9aSpkKT4+PjE2LG0mPTY1NTM1LGgrPShtKz1vKmYpPj4+MTYsbSY9NjU1MzUsaCs9KG0rPWEqbCk+Pj4xNixoKz1uKmQraSpmK28qbCthKmMsdSgoeSY9NjU1MzUpPDwxNnwoXyY9NjU1MzUpLChoJj02NTUzNSk8PDE2fChtJj02NTUzNSksdGhpcy51bnNpZ25lZCl9LFMubXVsPVMubXVsdGlwbHksUy5kaXZpZGU9ZnVuY3Rpb24odCl7aWYocih0KXx8KHQ9cCh0KSksdC5pc1plcm8oKSl0aHJvdyBFcnJvcihcImRpdmlzaW9uIGJ5IHplcm9cIik7dmFyIG4saSxvO2lmKGUpcmV0dXJuIHRoaXMudW5zaWduZWR8fC0yMTQ3NDgzNjQ4IT09dGhpcy5oaWdofHwtMSE9PXQubG93fHwtMSE9PXQuaGlnaD91KCh0aGlzLnVuc2lnbmVkP2UuZGl2X3U6ZS5kaXZfcykodGhpcy5sb3csdGhpcy5oaWdoLHQubG93LHQuaGlnaCksZS5nZXRfaGlnaCgpLHRoaXMudW5zaWduZWQpOnRoaXM7aWYodGhpcy5pc1plcm8oKSlyZXR1cm4gdGhpcy51bnNpZ25lZD9tOmI7aWYodGhpcy51bnNpZ25lZCl7aWYodC51bnNpZ25lZHx8KHQ9dC50b1Vuc2lnbmVkKCkpLHQuZ3QodGhpcykpcmV0dXJuIG07aWYodC5ndCh0aGlzLnNocnUoMSkpKXJldHVybiBfO289bX1lbHNle2lmKHRoaXMuZXEoVCkpcmV0dXJuIHQuZXEoeSl8fHQuZXEodik/VDp0LmVxKFQpP3k6KG49dGhpcy5zaHIoMSkuZGl2KHQpLnNobCgxKSkuZXEoYik/dC5pc05lZ2F0aXZlKCk/eTp2OihpPXRoaXMuc3ViKHQubXVsKG4pKSxvPW4uYWRkKGkuZGl2KHQpKSk7aWYodC5lcShUKSlyZXR1cm4gdGhpcy51bnNpZ25lZD9tOmI7aWYodGhpcy5pc05lZ2F0aXZlKCkpcmV0dXJuIHQuaXNOZWdhdGl2ZSgpP3RoaXMubmVnKCkuZGl2KHQubmVnKCkpOnRoaXMubmVnKCkuZGl2KHQpLm5lZygpO2lmKHQuaXNOZWdhdGl2ZSgpKXJldHVybiB0aGlzLmRpdih0Lm5lZygpKS5uZWcoKTtvPWJ9Zm9yKGk9dGhpcztpLmd0ZSh0KTspe249TWF0aC5tYXgoMSxNYXRoLmZsb29yKGkudG9OdW1iZXIoKS90LnRvTnVtYmVyKCkpKTtmb3IodmFyIGE9TWF0aC5jZWlsKE1hdGgubG9nKG4pL01hdGguTE4yKSxsPWE8PTQ4PzE6YygyLGEtNDgpLGY9cyhuKSxkPWYubXVsKHQpO2QuaXNOZWdhdGl2ZSgpfHxkLmd0KGkpOylkPShmPXMobi09bCx0aGlzLnVuc2lnbmVkKSkubXVsKHQpO2YuaXNaZXJvKCkmJihmPXkpLG89by5hZGQoZiksaT1pLnN1YihkKX1yZXR1cm4gb30sUy5kaXY9Uy5kaXZpZGUsUy5tb2R1bG89ZnVuY3Rpb24odCl7cmV0dXJuIHIodCl8fCh0PXAodCkpLGU/dSgodGhpcy51bnNpZ25lZD9lLnJlbV91OmUucmVtX3MpKHRoaXMubG93LHRoaXMuaGlnaCx0Lmxvdyx0LmhpZ2gpLGUuZ2V0X2hpZ2goKSx0aGlzLnVuc2lnbmVkKTp0aGlzLnN1Yih0aGlzLmRpdih0KS5tdWwodCkpfSxTLm1vZD1TLm1vZHVsbyxTLnJlbT1TLm1vZHVsbyxTLm5vdD1mdW5jdGlvbigpe3JldHVybiB1KH50aGlzLmxvdyx+dGhpcy5oaWdoLHRoaXMudW5zaWduZWQpfSxTLmFuZD1mdW5jdGlvbih0KXtyZXR1cm4gcih0KXx8KHQ9cCh0KSksdSh0aGlzLmxvdyZ0Lmxvdyx0aGlzLmhpZ2gmdC5oaWdoLHRoaXMudW5zaWduZWQpfSxTLm9yPWZ1bmN0aW9uKHQpe3JldHVybiByKHQpfHwodD1wKHQpKSx1KHRoaXMubG93fHQubG93LHRoaXMuaGlnaHx0LmhpZ2gsdGhpcy51bnNpZ25lZCl9LFMueG9yPWZ1bmN0aW9uKHQpe3JldHVybiByKHQpfHwodD1wKHQpKSx1KHRoaXMubG93XnQubG93LHRoaXMuaGlnaF50LmhpZ2gsdGhpcy51bnNpZ25lZCl9LFMuc2hpZnRMZWZ0PWZ1bmN0aW9uKHQpe3JldHVybiByKHQpJiYodD10LnRvSW50KCkpLDA9PSh0Jj02Myk/dGhpczp0PDMyP3UodGhpcy5sb3c8PHQsdGhpcy5oaWdoPDx0fHRoaXMubG93Pj4+MzItdCx0aGlzLnVuc2lnbmVkKTp1KDAsdGhpcy5sb3c8PHQtMzIsdGhpcy51bnNpZ25lZCl9LFMuc2hsPVMuc2hpZnRMZWZ0LFMuc2hpZnRSaWdodD1mdW5jdGlvbih0KXtyZXR1cm4gcih0KSYmKHQ9dC50b0ludCgpKSwwPT0odCY9NjMpP3RoaXM6dDwzMj91KHRoaXMubG93Pj4+dHx0aGlzLmhpZ2g8PDMyLXQsdGhpcy5oaWdoPj50LHRoaXMudW5zaWduZWQpOnUodGhpcy5oaWdoPj50LTMyLHRoaXMuaGlnaD49MD8wOi0xLHRoaXMudW5zaWduZWQpfSxTLnNocj1TLnNoaWZ0UmlnaHQsUy5zaGlmdFJpZ2h0VW5zaWduZWQ9ZnVuY3Rpb24odCl7aWYocih0KSYmKHQ9dC50b0ludCgpKSwwPT0odCY9NjMpKXJldHVybiB0aGlzO3ZhciBlPXRoaXMuaGlnaDtyZXR1cm4gdDwzMj91KHRoaXMubG93Pj4+dHxlPDwzMi10LGU+Pj50LHRoaXMudW5zaWduZWQpOnUoMzI9PT10P2U6ZT4+PnQtMzIsMCx0aGlzLnVuc2lnbmVkKX0sUy5zaHJ1PVMuc2hpZnRSaWdodFVuc2lnbmVkLFMuc2hyX3U9Uy5zaGlmdFJpZ2h0VW5zaWduZWQsUy50b1NpZ25lZD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnVuc2lnbmVkP3UodGhpcy5sb3csdGhpcy5oaWdoLCExKTp0aGlzfSxTLnRvVW5zaWduZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy51bnNpZ25lZD90aGlzOnUodGhpcy5sb3csdGhpcy5oaWdoLCEwKX0sUy50b0J5dGVzPWZ1bmN0aW9uKHQpe3JldHVybiB0P3RoaXMudG9CeXRlc0xFKCk6dGhpcy50b0J5dGVzQkUoKX0sUy50b0J5dGVzTEU9ZnVuY3Rpb24oKXt2YXIgdD10aGlzLmhpZ2gsZT10aGlzLmxvdztyZXR1cm5bMjU1JmUsZT4+PjgmMjU1LGU+Pj4xNiYyNTUsZT4+PjI0LDI1NSZ0LHQ+Pj44JjI1NSx0Pj4+MTYmMjU1LHQ+Pj4yNF19LFMudG9CeXRlc0JFPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5oaWdoLGU9dGhpcy5sb3c7cmV0dXJuW3Q+Pj4yNCx0Pj4+MTYmMjU1LHQ+Pj44JjI1NSwyNTUmdCxlPj4+MjQsZT4+PjE2JjI1NSxlPj4+OCYyNTUsMjU1JmVdfSxuLmZyb21CeXRlcz1mdW5jdGlvbih0LGUscil7cmV0dXJuIHI/bi5mcm9tQnl0ZXNMRSh0LGUpOm4uZnJvbUJ5dGVzQkUodCxlKX0sbi5mcm9tQnl0ZXNMRT1mdW5jdGlvbih0LGUpe3JldHVybiBuZXcgbih0WzBdfHRbMV08PDh8dFsyXTw8MTZ8dFszXTw8MjQsdFs0XXx0WzVdPDw4fHRbNl08PDE2fHRbN108PDI0LGUpfSxuLmZyb21CeXRlc0JFPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIG5ldyBuKHRbNF08PDI0fHRbNV08PDE2fHRbNl08PDh8dFs3XSx0WzBdPDwyNHx0WzFdPDwxNnx0WzJdPDw4fHRbM10sZSl9fSwxNDQ2Oih0LGUsbik9PntcInVzZSBzdHJpY3RcIjt2YXIgcixpLG8sYT1uKDIxMDApLHM9YS5SZWFkZXIsdT1hLldyaXRlcixjPWEudXRpbCxsPWEucm9vdHMuZGVmYXVsdHx8KGEucm9vdHMuZGVmYXVsdD17fSk7bC5vbm54PSgobz17fSkuVmVyc2lvbj0ocj17fSwoaT1PYmplY3QuY3JlYXRlKHIpKVtyWzBdPVwiX1NUQVJUX1ZFUlNJT05cIl09MCxpW3JbMV09XCJJUl9WRVJTSU9OXzIwMTdfMTBfMTBcIl09MSxpW3JbMl09XCJJUl9WRVJTSU9OXzIwMTdfMTBfMzBcIl09MixpW3JbM109XCJJUl9WRVJTSU9OXzIwMTdfMTFfM1wiXT0zLGlbcls0XT1cIklSX1ZFUlNJT05fMjAxOV8xXzIyXCJdPTQsaVtyWzVdPVwiSVJfVkVSU0lPTlwiXT01LGkpLG8uQXR0cmlidXRlUHJvdG89ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQpe2lmKHRoaXMuZmxvYXRzPVtdLHRoaXMuaW50cz1bXSx0aGlzLnN0cmluZ3M9W10sdGhpcy50ZW5zb3JzPVtdLHRoaXMuZ3JhcGhzPVtdLHQpZm9yKHZhciBlPU9iamVjdC5rZXlzKHQpLG49MDtuPGUubGVuZ3RoOysrbiludWxsIT10W2Vbbl1dJiYodGhpc1tlW25dXT10W2Vbbl1dKX1yZXR1cm4gdC5wcm90b3R5cGUubmFtZT1cIlwiLHQucHJvdG90eXBlLnJlZkF0dHJOYW1lPVwiXCIsdC5wcm90b3R5cGUuZG9jU3RyaW5nPVwiXCIsdC5wcm90b3R5cGUudHlwZT0wLHQucHJvdG90eXBlLmY9MCx0LnByb3RvdHlwZS5pPWMuTG9uZz9jLkxvbmcuZnJvbUJpdHMoMCwwLCExKTowLHQucHJvdG90eXBlLnM9Yy5uZXdCdWZmZXIoW10pLHQucHJvdG90eXBlLnQ9bnVsbCx0LnByb3RvdHlwZS5nPW51bGwsdC5wcm90b3R5cGUuZmxvYXRzPWMuZW1wdHlBcnJheSx0LnByb3RvdHlwZS5pbnRzPWMuZW1wdHlBcnJheSx0LnByb3RvdHlwZS5zdHJpbmdzPWMuZW1wdHlBcnJheSx0LnByb3RvdHlwZS50ZW5zb3JzPWMuZW1wdHlBcnJheSx0LnByb3RvdHlwZS5ncmFwaHM9Yy5lbXB0eUFycmF5LHQuY3JlYXRlPWZ1bmN0aW9uKGUpe3JldHVybiBuZXcgdChlKX0sdC5lbmNvZGU9ZnVuY3Rpb24odCxlKXtpZihlfHwoZT11LmNyZWF0ZSgpKSxudWxsIT10Lm5hbWUmJnQuaGFzT3duUHJvcGVydHkoXCJuYW1lXCIpJiZlLnVpbnQzMigxMCkuc3RyaW5nKHQubmFtZSksbnVsbCE9dC5mJiZ0Lmhhc093blByb3BlcnR5KFwiZlwiKSYmZS51aW50MzIoMjEpLmZsb2F0KHQuZiksbnVsbCE9dC5pJiZ0Lmhhc093blByb3BlcnR5KFwiaVwiKSYmZS51aW50MzIoMjQpLmludDY0KHQuaSksbnVsbCE9dC5zJiZ0Lmhhc093blByb3BlcnR5KFwic1wiKSYmZS51aW50MzIoMzQpLmJ5dGVzKHQucyksbnVsbCE9dC50JiZ0Lmhhc093blByb3BlcnR5KFwidFwiKSYmbC5vbm54LlRlbnNvclByb3RvLmVuY29kZSh0LnQsZS51aW50MzIoNDIpLmZvcmsoKSkubGRlbGltKCksbnVsbCE9dC5nJiZ0Lmhhc093blByb3BlcnR5KFwiZ1wiKSYmbC5vbm54LkdyYXBoUHJvdG8uZW5jb2RlKHQuZyxlLnVpbnQzMig1MCkuZm9yaygpKS5sZGVsaW0oKSxudWxsIT10LmZsb2F0cyYmdC5mbG9hdHMubGVuZ3RoKXtlLnVpbnQzMig1OCkuZm9yaygpO2Zvcih2YXIgbj0wO248dC5mbG9hdHMubGVuZ3RoOysrbillLmZsb2F0KHQuZmxvYXRzW25dKTtlLmxkZWxpbSgpfWlmKG51bGwhPXQuaW50cyYmdC5pbnRzLmxlbmd0aCl7Zm9yKGUudWludDMyKDY2KS5mb3JrKCksbj0wO248dC5pbnRzLmxlbmd0aDsrK24pZS5pbnQ2NCh0LmludHNbbl0pO2UubGRlbGltKCl9aWYobnVsbCE9dC5zdHJpbmdzJiZ0LnN0cmluZ3MubGVuZ3RoKWZvcihuPTA7bjx0LnN0cmluZ3MubGVuZ3RoOysrbillLnVpbnQzMig3NCkuYnl0ZXModC5zdHJpbmdzW25dKTtpZihudWxsIT10LnRlbnNvcnMmJnQudGVuc29ycy5sZW5ndGgpZm9yKG49MDtuPHQudGVuc29ycy5sZW5ndGg7KytuKWwub25ueC5UZW5zb3JQcm90by5lbmNvZGUodC50ZW5zb3JzW25dLGUudWludDMyKDgyKS5mb3JrKCkpLmxkZWxpbSgpO2lmKG51bGwhPXQuZ3JhcGhzJiZ0LmdyYXBocy5sZW5ndGgpZm9yKG49MDtuPHQuZ3JhcGhzLmxlbmd0aDsrK24pbC5vbm54LkdyYXBoUHJvdG8uZW5jb2RlKHQuZ3JhcGhzW25dLGUudWludDMyKDkwKS5mb3JrKCkpLmxkZWxpbSgpO3JldHVybiBudWxsIT10LmRvY1N0cmluZyYmdC5oYXNPd25Qcm9wZXJ0eShcImRvY1N0cmluZ1wiKSYmZS51aW50MzIoMTA2KS5zdHJpbmcodC5kb2NTdHJpbmcpLG51bGwhPXQudHlwZSYmdC5oYXNPd25Qcm9wZXJ0eShcInR5cGVcIikmJmUudWludDMyKDE2MCkuaW50MzIodC50eXBlKSxudWxsIT10LnJlZkF0dHJOYW1lJiZ0Lmhhc093blByb3BlcnR5KFwicmVmQXR0ck5hbWVcIikmJmUudWludDMyKDE3MCkuc3RyaW5nKHQucmVmQXR0ck5hbWUpLGV9LHQuZW5jb2RlRGVsaW1pdGVkPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMuZW5jb2RlKHQsZSkubGRlbGltKCl9LHQuZGVjb2RlPWZ1bmN0aW9uKHQsZSl7dCBpbnN0YW5jZW9mIHN8fCh0PXMuY3JlYXRlKHQpKTtmb3IodmFyIG49dm9pZCAwPT09ZT90Lmxlbjp0LnBvcytlLHI9bmV3IGwub25ueC5BdHRyaWJ1dGVQcm90bzt0LnBvczxuOyl7dmFyIGk9dC51aW50MzIoKTtzd2l0Y2goaT4+PjMpe2Nhc2UgMTpyLm5hbWU9dC5zdHJpbmcoKTticmVhaztjYXNlIDIxOnIucmVmQXR0ck5hbWU9dC5zdHJpbmcoKTticmVhaztjYXNlIDEzOnIuZG9jU3RyaW5nPXQuc3RyaW5nKCk7YnJlYWs7Y2FzZSAyMDpyLnR5cGU9dC5pbnQzMigpO2JyZWFrO2Nhc2UgMjpyLmY9dC5mbG9hdCgpO2JyZWFrO2Nhc2UgMzpyLmk9dC5pbnQ2NCgpO2JyZWFrO2Nhc2UgNDpyLnM9dC5ieXRlcygpO2JyZWFrO2Nhc2UgNTpyLnQ9bC5vbm54LlRlbnNvclByb3RvLmRlY29kZSh0LHQudWludDMyKCkpO2JyZWFrO2Nhc2UgNjpyLmc9bC5vbm54LkdyYXBoUHJvdG8uZGVjb2RlKHQsdC51aW50MzIoKSk7YnJlYWs7Y2FzZSA3OmlmKHIuZmxvYXRzJiZyLmZsb2F0cy5sZW5ndGh8fChyLmZsb2F0cz1bXSksMj09KDcmaSkpZm9yKHZhciBvPXQudWludDMyKCkrdC5wb3M7dC5wb3M8bzspci5mbG9hdHMucHVzaCh0LmZsb2F0KCkpO2Vsc2Ugci5mbG9hdHMucHVzaCh0LmZsb2F0KCkpO2JyZWFrO2Nhc2UgODppZihyLmludHMmJnIuaW50cy5sZW5ndGh8fChyLmludHM9W10pLDI9PSg3JmkpKWZvcihvPXQudWludDMyKCkrdC5wb3M7dC5wb3M8bzspci5pbnRzLnB1c2godC5pbnQ2NCgpKTtlbHNlIHIuaW50cy5wdXNoKHQuaW50NjQoKSk7YnJlYWs7Y2FzZSA5OnIuc3RyaW5ncyYmci5zdHJpbmdzLmxlbmd0aHx8KHIuc3RyaW5ncz1bXSksci5zdHJpbmdzLnB1c2godC5ieXRlcygpKTticmVhaztjYXNlIDEwOnIudGVuc29ycyYmci50ZW5zb3JzLmxlbmd0aHx8KHIudGVuc29ycz1bXSksci50ZW5zb3JzLnB1c2gobC5vbm54LlRlbnNvclByb3RvLmRlY29kZSh0LHQudWludDMyKCkpKTticmVhaztjYXNlIDExOnIuZ3JhcGhzJiZyLmdyYXBocy5sZW5ndGh8fChyLmdyYXBocz1bXSksci5ncmFwaHMucHVzaChsLm9ubnguR3JhcGhQcm90by5kZWNvZGUodCx0LnVpbnQzMigpKSk7YnJlYWs7ZGVmYXVsdDp0LnNraXBUeXBlKDcmaSl9fXJldHVybiByfSx0LmRlY29kZURlbGltaXRlZD1mdW5jdGlvbih0KXtyZXR1cm4gdCBpbnN0YW5jZW9mIHN8fCh0PW5ldyBzKHQpKSx0aGlzLmRlY29kZSh0LHQudWludDMyKCkpfSx0LnZlcmlmeT1mdW5jdGlvbih0KXtpZihcIm9iamVjdFwiIT10eXBlb2YgdHx8bnVsbD09PXQpcmV0dXJuXCJvYmplY3QgZXhwZWN0ZWRcIjtpZihudWxsIT10Lm5hbWUmJnQuaGFzT3duUHJvcGVydHkoXCJuYW1lXCIpJiYhYy5pc1N0cmluZyh0Lm5hbWUpKXJldHVyblwibmFtZTogc3RyaW5nIGV4cGVjdGVkXCI7aWYobnVsbCE9dC5yZWZBdHRyTmFtZSYmdC5oYXNPd25Qcm9wZXJ0eShcInJlZkF0dHJOYW1lXCIpJiYhYy5pc1N0cmluZyh0LnJlZkF0dHJOYW1lKSlyZXR1cm5cInJlZkF0dHJOYW1lOiBzdHJpbmcgZXhwZWN0ZWRcIjtpZihudWxsIT10LmRvY1N0cmluZyYmdC5oYXNPd25Qcm9wZXJ0eShcImRvY1N0cmluZ1wiKSYmIWMuaXNTdHJpbmcodC5kb2NTdHJpbmcpKXJldHVyblwiZG9jU3RyaW5nOiBzdHJpbmcgZXhwZWN0ZWRcIjtpZihudWxsIT10LnR5cGUmJnQuaGFzT3duUHJvcGVydHkoXCJ0eXBlXCIpKXN3aXRjaCh0LnR5cGUpe2RlZmF1bHQ6cmV0dXJuXCJ0eXBlOiBlbnVtIHZhbHVlIGV4cGVjdGVkXCI7Y2FzZSAwOmNhc2UgMTpjYXNlIDI6Y2FzZSAzOmNhc2UgNDpjYXNlIDU6Y2FzZSA2OmNhc2UgNzpjYXNlIDg6Y2FzZSA5OmNhc2UgMTA6fWlmKG51bGwhPXQuZiYmdC5oYXNPd25Qcm9wZXJ0eShcImZcIikmJlwibnVtYmVyXCIhPXR5cGVvZiB0LmYpcmV0dXJuXCJmOiBudW1iZXIgZXhwZWN0ZWRcIjtpZihudWxsIT10LmkmJnQuaGFzT3duUHJvcGVydHkoXCJpXCIpJiYhKGMuaXNJbnRlZ2VyKHQuaSl8fHQuaSYmYy5pc0ludGVnZXIodC5pLmxvdykmJmMuaXNJbnRlZ2VyKHQuaS5oaWdoKSkpcmV0dXJuXCJpOiBpbnRlZ2VyfExvbmcgZXhwZWN0ZWRcIjtpZihudWxsIT10LnMmJnQuaGFzT3duUHJvcGVydHkoXCJzXCIpJiYhKHQucyYmXCJudW1iZXJcIj09dHlwZW9mIHQucy5sZW5ndGh8fGMuaXNTdHJpbmcodC5zKSkpcmV0dXJuXCJzOiBidWZmZXIgZXhwZWN0ZWRcIjtpZihudWxsIT10LnQmJnQuaGFzT3duUHJvcGVydHkoXCJ0XCIpJiYobj1sLm9ubnguVGVuc29yUHJvdG8udmVyaWZ5KHQudCkpKXJldHVyblwidC5cIituO2lmKG51bGwhPXQuZyYmdC5oYXNPd25Qcm9wZXJ0eShcImdcIikmJihuPWwub25ueC5HcmFwaFByb3RvLnZlcmlmeSh0LmcpKSlyZXR1cm5cImcuXCIrbjtpZihudWxsIT10LmZsb2F0cyYmdC5oYXNPd25Qcm9wZXJ0eShcImZsb2F0c1wiKSl7aWYoIUFycmF5LmlzQXJyYXkodC5mbG9hdHMpKXJldHVyblwiZmxvYXRzOiBhcnJheSBleHBlY3RlZFwiO2Zvcih2YXIgZT0wO2U8dC5mbG9hdHMubGVuZ3RoOysrZSlpZihcIm51bWJlclwiIT10eXBlb2YgdC5mbG9hdHNbZV0pcmV0dXJuXCJmbG9hdHM6IG51bWJlcltdIGV4cGVjdGVkXCJ9aWYobnVsbCE9dC5pbnRzJiZ0Lmhhc093blByb3BlcnR5KFwiaW50c1wiKSl7aWYoIUFycmF5LmlzQXJyYXkodC5pbnRzKSlyZXR1cm5cImludHM6IGFycmF5IGV4cGVjdGVkXCI7Zm9yKGU9MDtlPHQuaW50cy5sZW5ndGg7KytlKWlmKCEoYy5pc0ludGVnZXIodC5pbnRzW2VdKXx8dC5pbnRzW2VdJiZjLmlzSW50ZWdlcih0LmludHNbZV0ubG93KSYmYy5pc0ludGVnZXIodC5pbnRzW2VdLmhpZ2gpKSlyZXR1cm5cImludHM6IGludGVnZXJ8TG9uZ1tdIGV4cGVjdGVkXCJ9aWYobnVsbCE9dC5zdHJpbmdzJiZ0Lmhhc093blByb3BlcnR5KFwic3RyaW5nc1wiKSl7aWYoIUFycmF5LmlzQXJyYXkodC5zdHJpbmdzKSlyZXR1cm5cInN0cmluZ3M6IGFycmF5IGV4cGVjdGVkXCI7Zm9yKGU9MDtlPHQuc3RyaW5ncy5sZW5ndGg7KytlKWlmKCEodC5zdHJpbmdzW2VdJiZcIm51bWJlclwiPT10eXBlb2YgdC5zdHJpbmdzW2VdLmxlbmd0aHx8Yy5pc1N0cmluZyh0LnN0cmluZ3NbZV0pKSlyZXR1cm5cInN0cmluZ3M6IGJ1ZmZlcltdIGV4cGVjdGVkXCJ9aWYobnVsbCE9dC50ZW5zb3JzJiZ0Lmhhc093blByb3BlcnR5KFwidGVuc29yc1wiKSl7aWYoIUFycmF5LmlzQXJyYXkodC50ZW5zb3JzKSlyZXR1cm5cInRlbnNvcnM6IGFycmF5IGV4cGVjdGVkXCI7Zm9yKGU9MDtlPHQudGVuc29ycy5sZW5ndGg7KytlKWlmKG49bC5vbm54LlRlbnNvclByb3RvLnZlcmlmeSh0LnRlbnNvcnNbZV0pKXJldHVyblwidGVuc29ycy5cIitufWlmKG51bGwhPXQuZ3JhcGhzJiZ0Lmhhc093blByb3BlcnR5KFwiZ3JhcGhzXCIpKXtpZighQXJyYXkuaXNBcnJheSh0LmdyYXBocykpcmV0dXJuXCJncmFwaHM6IGFycmF5IGV4cGVjdGVkXCI7Zm9yKGU9MDtlPHQuZ3JhcGhzLmxlbmd0aDsrK2Upe3ZhciBuO2lmKG49bC5vbm54LkdyYXBoUHJvdG8udmVyaWZ5KHQuZ3JhcGhzW2VdKSlyZXR1cm5cImdyYXBocy5cIitufX1yZXR1cm4gbnVsbH0sdC5mcm9tT2JqZWN0PWZ1bmN0aW9uKHQpe2lmKHQgaW5zdGFuY2VvZiBsLm9ubnguQXR0cmlidXRlUHJvdG8pcmV0dXJuIHQ7dmFyIGU9bmV3IGwub25ueC5BdHRyaWJ1dGVQcm90bztzd2l0Y2gobnVsbCE9dC5uYW1lJiYoZS5uYW1lPVN0cmluZyh0Lm5hbWUpKSxudWxsIT10LnJlZkF0dHJOYW1lJiYoZS5yZWZBdHRyTmFtZT1TdHJpbmcodC5yZWZBdHRyTmFtZSkpLG51bGwhPXQuZG9jU3RyaW5nJiYoZS5kb2NTdHJpbmc9U3RyaW5nKHQuZG9jU3RyaW5nKSksdC50eXBlKXtjYXNlXCJVTkRFRklORURcIjpjYXNlIDA6ZS50eXBlPTA7YnJlYWs7Y2FzZVwiRkxPQVRcIjpjYXNlIDE6ZS50eXBlPTE7YnJlYWs7Y2FzZVwiSU5UXCI6Y2FzZSAyOmUudHlwZT0yO2JyZWFrO2Nhc2VcIlNUUklOR1wiOmNhc2UgMzplLnR5cGU9MzticmVhaztjYXNlXCJURU5TT1JcIjpjYXNlIDQ6ZS50eXBlPTQ7YnJlYWs7Y2FzZVwiR1JBUEhcIjpjYXNlIDU6ZS50eXBlPTU7YnJlYWs7Y2FzZVwiRkxPQVRTXCI6Y2FzZSA2OmUudHlwZT02O2JyZWFrO2Nhc2VcIklOVFNcIjpjYXNlIDc6ZS50eXBlPTc7YnJlYWs7Y2FzZVwiU1RSSU5HU1wiOmNhc2UgODplLnR5cGU9ODticmVhaztjYXNlXCJURU5TT1JTXCI6Y2FzZSA5OmUudHlwZT05O2JyZWFrO2Nhc2VcIkdSQVBIU1wiOmNhc2UgMTA6ZS50eXBlPTEwfWlmKG51bGwhPXQuZiYmKGUuZj1OdW1iZXIodC5mKSksbnVsbCE9dC5pJiYoYy5Mb25nPyhlLmk9Yy5Mb25nLmZyb21WYWx1ZSh0LmkpKS51bnNpZ25lZD0hMTpcInN0cmluZ1wiPT10eXBlb2YgdC5pP2UuaT1wYXJzZUludCh0LmksMTApOlwibnVtYmVyXCI9PXR5cGVvZiB0Lmk/ZS5pPXQuaTpcIm9iamVjdFwiPT10eXBlb2YgdC5pJiYoZS5pPW5ldyBjLkxvbmdCaXRzKHQuaS5sb3c+Pj4wLHQuaS5oaWdoPj4+MCkudG9OdW1iZXIoKSkpLG51bGwhPXQucyYmKFwic3RyaW5nXCI9PXR5cGVvZiB0LnM/Yy5iYXNlNjQuZGVjb2RlKHQucyxlLnM9Yy5uZXdCdWZmZXIoYy5iYXNlNjQubGVuZ3RoKHQucykpLDApOnQucy5sZW5ndGgmJihlLnM9dC5zKSksbnVsbCE9dC50KXtpZihcIm9iamVjdFwiIT10eXBlb2YgdC50KXRocm93IFR5cGVFcnJvcihcIi5vbm54LkF0dHJpYnV0ZVByb3RvLnQ6IG9iamVjdCBleHBlY3RlZFwiKTtlLnQ9bC5vbm54LlRlbnNvclByb3RvLmZyb21PYmplY3QodC50KX1pZihudWxsIT10Lmcpe2lmKFwib2JqZWN0XCIhPXR5cGVvZiB0LmcpdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguQXR0cmlidXRlUHJvdG8uZzogb2JqZWN0IGV4cGVjdGVkXCIpO2UuZz1sLm9ubnguR3JhcGhQcm90by5mcm9tT2JqZWN0KHQuZyl9aWYodC5mbG9hdHMpe2lmKCFBcnJheS5pc0FycmF5KHQuZmxvYXRzKSl0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5BdHRyaWJ1dGVQcm90by5mbG9hdHM6IGFycmF5IGV4cGVjdGVkXCIpO2UuZmxvYXRzPVtdO2Zvcih2YXIgbj0wO248dC5mbG9hdHMubGVuZ3RoOysrbillLmZsb2F0c1tuXT1OdW1iZXIodC5mbG9hdHNbbl0pfWlmKHQuaW50cyl7aWYoIUFycmF5LmlzQXJyYXkodC5pbnRzKSl0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5BdHRyaWJ1dGVQcm90by5pbnRzOiBhcnJheSBleHBlY3RlZFwiKTtmb3IoZS5pbnRzPVtdLG49MDtuPHQuaW50cy5sZW5ndGg7KytuKWMuTG9uZz8oZS5pbnRzW25dPWMuTG9uZy5mcm9tVmFsdWUodC5pbnRzW25dKSkudW5zaWduZWQ9ITE6XCJzdHJpbmdcIj09dHlwZW9mIHQuaW50c1tuXT9lLmludHNbbl09cGFyc2VJbnQodC5pbnRzW25dLDEwKTpcIm51bWJlclwiPT10eXBlb2YgdC5pbnRzW25dP2UuaW50c1tuXT10LmludHNbbl06XCJvYmplY3RcIj09dHlwZW9mIHQuaW50c1tuXSYmKGUuaW50c1tuXT1uZXcgYy5Mb25nQml0cyh0LmludHNbbl0ubG93Pj4+MCx0LmludHNbbl0uaGlnaD4+PjApLnRvTnVtYmVyKCkpfWlmKHQuc3RyaW5ncyl7aWYoIUFycmF5LmlzQXJyYXkodC5zdHJpbmdzKSl0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5BdHRyaWJ1dGVQcm90by5zdHJpbmdzOiBhcnJheSBleHBlY3RlZFwiKTtmb3IoZS5zdHJpbmdzPVtdLG49MDtuPHQuc3RyaW5ncy5sZW5ndGg7KytuKVwic3RyaW5nXCI9PXR5cGVvZiB0LnN0cmluZ3Nbbl0/Yy5iYXNlNjQuZGVjb2RlKHQuc3RyaW5nc1tuXSxlLnN0cmluZ3Nbbl09Yy5uZXdCdWZmZXIoYy5iYXNlNjQubGVuZ3RoKHQuc3RyaW5nc1tuXSkpLDApOnQuc3RyaW5nc1tuXS5sZW5ndGgmJihlLnN0cmluZ3Nbbl09dC5zdHJpbmdzW25dKX1pZih0LnRlbnNvcnMpe2lmKCFBcnJheS5pc0FycmF5KHQudGVuc29ycykpdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguQXR0cmlidXRlUHJvdG8udGVuc29yczogYXJyYXkgZXhwZWN0ZWRcIik7Zm9yKGUudGVuc29ycz1bXSxuPTA7bjx0LnRlbnNvcnMubGVuZ3RoOysrbil7aWYoXCJvYmplY3RcIiE9dHlwZW9mIHQudGVuc29yc1tuXSl0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5BdHRyaWJ1dGVQcm90by50ZW5zb3JzOiBvYmplY3QgZXhwZWN0ZWRcIik7ZS50ZW5zb3JzW25dPWwub25ueC5UZW5zb3JQcm90by5mcm9tT2JqZWN0KHQudGVuc29yc1tuXSl9fWlmKHQuZ3JhcGhzKXtpZighQXJyYXkuaXNBcnJheSh0LmdyYXBocykpdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguQXR0cmlidXRlUHJvdG8uZ3JhcGhzOiBhcnJheSBleHBlY3RlZFwiKTtmb3IoZS5ncmFwaHM9W10sbj0wO248dC5ncmFwaHMubGVuZ3RoOysrbil7aWYoXCJvYmplY3RcIiE9dHlwZW9mIHQuZ3JhcGhzW25dKXRocm93IFR5cGVFcnJvcihcIi5vbm54LkF0dHJpYnV0ZVByb3RvLmdyYXBoczogb2JqZWN0IGV4cGVjdGVkXCIpO2UuZ3JhcGhzW25dPWwub25ueC5HcmFwaFByb3RvLmZyb21PYmplY3QodC5ncmFwaHNbbl0pfX1yZXR1cm4gZX0sdC50b09iamVjdD1mdW5jdGlvbih0LGUpe2V8fChlPXt9KTt2YXIgbj17fTtpZigoZS5hcnJheXN8fGUuZGVmYXVsdHMpJiYobi5mbG9hdHM9W10sbi5pbnRzPVtdLG4uc3RyaW5ncz1bXSxuLnRlbnNvcnM9W10sbi5ncmFwaHM9W10pLGUuZGVmYXVsdHMpe2lmKG4ubmFtZT1cIlwiLG4uZj0wLGMuTG9uZyl7dmFyIHI9bmV3IGMuTG9uZygwLDAsITEpO24uaT1lLmxvbmdzPT09U3RyaW5nP3IudG9TdHJpbmcoKTplLmxvbmdzPT09TnVtYmVyP3IudG9OdW1iZXIoKTpyfWVsc2Ugbi5pPWUubG9uZ3M9PT1TdHJpbmc/XCIwXCI6MDtlLmJ5dGVzPT09U3RyaW5nP24ucz1cIlwiOihuLnM9W10sZS5ieXRlcyE9PUFycmF5JiYobi5zPWMubmV3QnVmZmVyKG4ucykpKSxuLnQ9bnVsbCxuLmc9bnVsbCxuLmRvY1N0cmluZz1cIlwiLG4udHlwZT1lLmVudW1zPT09U3RyaW5nP1wiVU5ERUZJTkVEXCI6MCxuLnJlZkF0dHJOYW1lPVwiXCJ9aWYobnVsbCE9dC5uYW1lJiZ0Lmhhc093blByb3BlcnR5KFwibmFtZVwiKSYmKG4ubmFtZT10Lm5hbWUpLG51bGwhPXQuZiYmdC5oYXNPd25Qcm9wZXJ0eShcImZcIikmJihuLmY9ZS5qc29uJiYhaXNGaW5pdGUodC5mKT9TdHJpbmcodC5mKTp0LmYpLG51bGwhPXQuaSYmdC5oYXNPd25Qcm9wZXJ0eShcImlcIikmJihcIm51bWJlclwiPT10eXBlb2YgdC5pP24uaT1lLmxvbmdzPT09U3RyaW5nP1N0cmluZyh0LmkpOnQuaTpuLmk9ZS5sb25ncz09PVN0cmluZz9jLkxvbmcucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodC5pKTplLmxvbmdzPT09TnVtYmVyP25ldyBjLkxvbmdCaXRzKHQuaS5sb3c+Pj4wLHQuaS5oaWdoPj4+MCkudG9OdW1iZXIoKTp0LmkpLG51bGwhPXQucyYmdC5oYXNPd25Qcm9wZXJ0eShcInNcIikmJihuLnM9ZS5ieXRlcz09PVN0cmluZz9jLmJhc2U2NC5lbmNvZGUodC5zLDAsdC5zLmxlbmd0aCk6ZS5ieXRlcz09PUFycmF5P0FycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHQucyk6dC5zKSxudWxsIT10LnQmJnQuaGFzT3duUHJvcGVydHkoXCJ0XCIpJiYobi50PWwub25ueC5UZW5zb3JQcm90by50b09iamVjdCh0LnQsZSkpLG51bGwhPXQuZyYmdC5oYXNPd25Qcm9wZXJ0eShcImdcIikmJihuLmc9bC5vbm54LkdyYXBoUHJvdG8udG9PYmplY3QodC5nLGUpKSx0LmZsb2F0cyYmdC5mbG9hdHMubGVuZ3RoKXtuLmZsb2F0cz1bXTtmb3IodmFyIGk9MDtpPHQuZmxvYXRzLmxlbmd0aDsrK2kpbi5mbG9hdHNbaV09ZS5qc29uJiYhaXNGaW5pdGUodC5mbG9hdHNbaV0pP1N0cmluZyh0LmZsb2F0c1tpXSk6dC5mbG9hdHNbaV19aWYodC5pbnRzJiZ0LmludHMubGVuZ3RoKWZvcihuLmludHM9W10saT0wO2k8dC5pbnRzLmxlbmd0aDsrK2kpXCJudW1iZXJcIj09dHlwZW9mIHQuaW50c1tpXT9uLmludHNbaV09ZS5sb25ncz09PVN0cmluZz9TdHJpbmcodC5pbnRzW2ldKTp0LmludHNbaV06bi5pbnRzW2ldPWUubG9uZ3M9PT1TdHJpbmc/Yy5Mb25nLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHQuaW50c1tpXSk6ZS5sb25ncz09PU51bWJlcj9uZXcgYy5Mb25nQml0cyh0LmludHNbaV0ubG93Pj4+MCx0LmludHNbaV0uaGlnaD4+PjApLnRvTnVtYmVyKCk6dC5pbnRzW2ldO2lmKHQuc3RyaW5ncyYmdC5zdHJpbmdzLmxlbmd0aClmb3Iobi5zdHJpbmdzPVtdLGk9MDtpPHQuc3RyaW5ncy5sZW5ndGg7KytpKW4uc3RyaW5nc1tpXT1lLmJ5dGVzPT09U3RyaW5nP2MuYmFzZTY0LmVuY29kZSh0LnN0cmluZ3NbaV0sMCx0LnN0cmluZ3NbaV0ubGVuZ3RoKTplLmJ5dGVzPT09QXJyYXk/QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodC5zdHJpbmdzW2ldKTp0LnN0cmluZ3NbaV07aWYodC50ZW5zb3JzJiZ0LnRlbnNvcnMubGVuZ3RoKWZvcihuLnRlbnNvcnM9W10saT0wO2k8dC50ZW5zb3JzLmxlbmd0aDsrK2kpbi50ZW5zb3JzW2ldPWwub25ueC5UZW5zb3JQcm90by50b09iamVjdCh0LnRlbnNvcnNbaV0sZSk7aWYodC5ncmFwaHMmJnQuZ3JhcGhzLmxlbmd0aClmb3Iobi5ncmFwaHM9W10saT0wO2k8dC5ncmFwaHMubGVuZ3RoOysraSluLmdyYXBoc1tpXT1sLm9ubnguR3JhcGhQcm90by50b09iamVjdCh0LmdyYXBoc1tpXSxlKTtyZXR1cm4gbnVsbCE9dC5kb2NTdHJpbmcmJnQuaGFzT3duUHJvcGVydHkoXCJkb2NTdHJpbmdcIikmJihuLmRvY1N0cmluZz10LmRvY1N0cmluZyksbnVsbCE9dC50eXBlJiZ0Lmhhc093blByb3BlcnR5KFwidHlwZVwiKSYmKG4udHlwZT1lLmVudW1zPT09U3RyaW5nP2wub25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlW3QudHlwZV06dC50eXBlKSxudWxsIT10LnJlZkF0dHJOYW1lJiZ0Lmhhc093blByb3BlcnR5KFwicmVmQXR0ck5hbWVcIikmJihuLnJlZkF0dHJOYW1lPXQucmVmQXR0ck5hbWUpLG59LHQucHJvdG90eXBlLnRvSlNPTj1mdW5jdGlvbigpe3JldHVybiB0aGlzLmNvbnN0cnVjdG9yLnRvT2JqZWN0KHRoaXMsYS51dGlsLnRvSlNPTk9wdGlvbnMpfSx0LkF0dHJpYnV0ZVR5cGU9ZnVuY3Rpb24oKXt2YXIgdD17fSxlPU9iamVjdC5jcmVhdGUodCk7cmV0dXJuIGVbdFswXT1cIlVOREVGSU5FRFwiXT0wLGVbdFsxXT1cIkZMT0FUXCJdPTEsZVt0WzJdPVwiSU5UXCJdPTIsZVt0WzNdPVwiU1RSSU5HXCJdPTMsZVt0WzRdPVwiVEVOU09SXCJdPTQsZVt0WzVdPVwiR1JBUEhcIl09NSxlW3RbNl09XCJGTE9BVFNcIl09NixlW3RbN109XCJJTlRTXCJdPTcsZVt0WzhdPVwiU1RSSU5HU1wiXT04LGVbdFs5XT1cIlRFTlNPUlNcIl09OSxlW3RbMTBdPVwiR1JBUEhTXCJdPTEwLGV9KCksdH0oKSxvLlZhbHVlSW5mb1Byb3RvPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0KXtpZih0KWZvcih2YXIgZT1PYmplY3Qua2V5cyh0KSxuPTA7bjxlLmxlbmd0aDsrK24pbnVsbCE9dFtlW25dXSYmKHRoaXNbZVtuXV09dFtlW25dXSl9cmV0dXJuIHQucHJvdG90eXBlLm5hbWU9XCJcIix0LnByb3RvdHlwZS50eXBlPW51bGwsdC5wcm90b3R5cGUuZG9jU3RyaW5nPVwiXCIsdC5jcmVhdGU9ZnVuY3Rpb24oZSl7cmV0dXJuIG5ldyB0KGUpfSx0LmVuY29kZT1mdW5jdGlvbih0LGUpe3JldHVybiBlfHwoZT11LmNyZWF0ZSgpKSxudWxsIT10Lm5hbWUmJnQuaGFzT3duUHJvcGVydHkoXCJuYW1lXCIpJiZlLnVpbnQzMigxMCkuc3RyaW5nKHQubmFtZSksbnVsbCE9dC50eXBlJiZ0Lmhhc093blByb3BlcnR5KFwidHlwZVwiKSYmbC5vbm54LlR5cGVQcm90by5lbmNvZGUodC50eXBlLGUudWludDMyKDE4KS5mb3JrKCkpLmxkZWxpbSgpLG51bGwhPXQuZG9jU3RyaW5nJiZ0Lmhhc093blByb3BlcnR5KFwiZG9jU3RyaW5nXCIpJiZlLnVpbnQzMigyNikuc3RyaW5nKHQuZG9jU3RyaW5nKSxlfSx0LmVuY29kZURlbGltaXRlZD1mdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLmVuY29kZSh0LGUpLmxkZWxpbSgpfSx0LmRlY29kZT1mdW5jdGlvbih0LGUpe3QgaW5zdGFuY2VvZiBzfHwodD1zLmNyZWF0ZSh0KSk7Zm9yKHZhciBuPXZvaWQgMD09PWU/dC5sZW46dC5wb3MrZSxyPW5ldyBsLm9ubnguVmFsdWVJbmZvUHJvdG87dC5wb3M8bjspe3ZhciBpPXQudWludDMyKCk7c3dpdGNoKGk+Pj4zKXtjYXNlIDE6ci5uYW1lPXQuc3RyaW5nKCk7YnJlYWs7Y2FzZSAyOnIudHlwZT1sLm9ubnguVHlwZVByb3RvLmRlY29kZSh0LHQudWludDMyKCkpO2JyZWFrO2Nhc2UgMzpyLmRvY1N0cmluZz10LnN0cmluZygpO2JyZWFrO2RlZmF1bHQ6dC5za2lwVHlwZSg3JmkpfX1yZXR1cm4gcn0sdC5kZWNvZGVEZWxpbWl0ZWQ9ZnVuY3Rpb24odCl7cmV0dXJuIHQgaW5zdGFuY2VvZiBzfHwodD1uZXcgcyh0KSksdGhpcy5kZWNvZGUodCx0LnVpbnQzMigpKX0sdC52ZXJpZnk9ZnVuY3Rpb24odCl7aWYoXCJvYmplY3RcIiE9dHlwZW9mIHR8fG51bGw9PT10KXJldHVyblwib2JqZWN0IGV4cGVjdGVkXCI7aWYobnVsbCE9dC5uYW1lJiZ0Lmhhc093blByb3BlcnR5KFwibmFtZVwiKSYmIWMuaXNTdHJpbmcodC5uYW1lKSlyZXR1cm5cIm5hbWU6IHN0cmluZyBleHBlY3RlZFwiO2lmKG51bGwhPXQudHlwZSYmdC5oYXNPd25Qcm9wZXJ0eShcInR5cGVcIikpe3ZhciBlPWwub25ueC5UeXBlUHJvdG8udmVyaWZ5KHQudHlwZSk7aWYoZSlyZXR1cm5cInR5cGUuXCIrZX1yZXR1cm4gbnVsbCE9dC5kb2NTdHJpbmcmJnQuaGFzT3duUHJvcGVydHkoXCJkb2NTdHJpbmdcIikmJiFjLmlzU3RyaW5nKHQuZG9jU3RyaW5nKT9cImRvY1N0cmluZzogc3RyaW5nIGV4cGVjdGVkXCI6bnVsbH0sdC5mcm9tT2JqZWN0PWZ1bmN0aW9uKHQpe2lmKHQgaW5zdGFuY2VvZiBsLm9ubnguVmFsdWVJbmZvUHJvdG8pcmV0dXJuIHQ7dmFyIGU9bmV3IGwub25ueC5WYWx1ZUluZm9Qcm90bztpZihudWxsIT10Lm5hbWUmJihlLm5hbWU9U3RyaW5nKHQubmFtZSkpLG51bGwhPXQudHlwZSl7aWYoXCJvYmplY3RcIiE9dHlwZW9mIHQudHlwZSl0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5WYWx1ZUluZm9Qcm90by50eXBlOiBvYmplY3QgZXhwZWN0ZWRcIik7ZS50eXBlPWwub25ueC5UeXBlUHJvdG8uZnJvbU9iamVjdCh0LnR5cGUpfXJldHVybiBudWxsIT10LmRvY1N0cmluZyYmKGUuZG9jU3RyaW5nPVN0cmluZyh0LmRvY1N0cmluZykpLGV9LHQudG9PYmplY3Q9ZnVuY3Rpb24odCxlKXtlfHwoZT17fSk7dmFyIG49e307cmV0dXJuIGUuZGVmYXVsdHMmJihuLm5hbWU9XCJcIixuLnR5cGU9bnVsbCxuLmRvY1N0cmluZz1cIlwiKSxudWxsIT10Lm5hbWUmJnQuaGFzT3duUHJvcGVydHkoXCJuYW1lXCIpJiYobi5uYW1lPXQubmFtZSksbnVsbCE9dC50eXBlJiZ0Lmhhc093blByb3BlcnR5KFwidHlwZVwiKSYmKG4udHlwZT1sLm9ubnguVHlwZVByb3RvLnRvT2JqZWN0KHQudHlwZSxlKSksbnVsbCE9dC5kb2NTdHJpbmcmJnQuaGFzT3duUHJvcGVydHkoXCJkb2NTdHJpbmdcIikmJihuLmRvY1N0cmluZz10LmRvY1N0cmluZyksbn0sdC5wcm90b3R5cGUudG9KU09OPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY29uc3RydWN0b3IudG9PYmplY3QodGhpcyxhLnV0aWwudG9KU09OT3B0aW9ucyl9LHR9KCksby5Ob2RlUHJvdG89ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQpe2lmKHRoaXMuaW5wdXQ9W10sdGhpcy5vdXRwdXQ9W10sdGhpcy5hdHRyaWJ1dGU9W10sdClmb3IodmFyIGU9T2JqZWN0LmtleXModCksbj0wO248ZS5sZW5ndGg7KytuKW51bGwhPXRbZVtuXV0mJih0aGlzW2Vbbl1dPXRbZVtuXV0pfXJldHVybiB0LnByb3RvdHlwZS5pbnB1dD1jLmVtcHR5QXJyYXksdC5wcm90b3R5cGUub3V0cHV0PWMuZW1wdHlBcnJheSx0LnByb3RvdHlwZS5uYW1lPVwiXCIsdC5wcm90b3R5cGUub3BUeXBlPVwiXCIsdC5wcm90b3R5cGUuZG9tYWluPVwiXCIsdC5wcm90b3R5cGUuYXR0cmlidXRlPWMuZW1wdHlBcnJheSx0LnByb3RvdHlwZS5kb2NTdHJpbmc9XCJcIix0LmNyZWF0ZT1mdW5jdGlvbihlKXtyZXR1cm4gbmV3IHQoZSl9LHQuZW5jb2RlPWZ1bmN0aW9uKHQsZSl7aWYoZXx8KGU9dS5jcmVhdGUoKSksbnVsbCE9dC5pbnB1dCYmdC5pbnB1dC5sZW5ndGgpZm9yKHZhciBuPTA7bjx0LmlucHV0Lmxlbmd0aDsrK24pZS51aW50MzIoMTApLnN0cmluZyh0LmlucHV0W25dKTtpZihudWxsIT10Lm91dHB1dCYmdC5vdXRwdXQubGVuZ3RoKWZvcihuPTA7bjx0Lm91dHB1dC5sZW5ndGg7KytuKWUudWludDMyKDE4KS5zdHJpbmcodC5vdXRwdXRbbl0pO2lmKG51bGwhPXQubmFtZSYmdC5oYXNPd25Qcm9wZXJ0eShcIm5hbWVcIikmJmUudWludDMyKDI2KS5zdHJpbmcodC5uYW1lKSxudWxsIT10Lm9wVHlwZSYmdC5oYXNPd25Qcm9wZXJ0eShcIm9wVHlwZVwiKSYmZS51aW50MzIoMzQpLnN0cmluZyh0Lm9wVHlwZSksbnVsbCE9dC5hdHRyaWJ1dGUmJnQuYXR0cmlidXRlLmxlbmd0aClmb3Iobj0wO248dC5hdHRyaWJ1dGUubGVuZ3RoOysrbilsLm9ubnguQXR0cmlidXRlUHJvdG8uZW5jb2RlKHQuYXR0cmlidXRlW25dLGUudWludDMyKDQyKS5mb3JrKCkpLmxkZWxpbSgpO3JldHVybiBudWxsIT10LmRvY1N0cmluZyYmdC5oYXNPd25Qcm9wZXJ0eShcImRvY1N0cmluZ1wiKSYmZS51aW50MzIoNTApLnN0cmluZyh0LmRvY1N0cmluZyksbnVsbCE9dC5kb21haW4mJnQuaGFzT3duUHJvcGVydHkoXCJkb21haW5cIikmJmUudWludDMyKDU4KS5zdHJpbmcodC5kb21haW4pLGV9LHQuZW5jb2RlRGVsaW1pdGVkPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMuZW5jb2RlKHQsZSkubGRlbGltKCl9LHQuZGVjb2RlPWZ1bmN0aW9uKHQsZSl7dCBpbnN0YW5jZW9mIHN8fCh0PXMuY3JlYXRlKHQpKTtmb3IodmFyIG49dm9pZCAwPT09ZT90Lmxlbjp0LnBvcytlLHI9bmV3IGwub25ueC5Ob2RlUHJvdG87dC5wb3M8bjspe3ZhciBpPXQudWludDMyKCk7c3dpdGNoKGk+Pj4zKXtjYXNlIDE6ci5pbnB1dCYmci5pbnB1dC5sZW5ndGh8fChyLmlucHV0PVtdKSxyLmlucHV0LnB1c2godC5zdHJpbmcoKSk7YnJlYWs7Y2FzZSAyOnIub3V0cHV0JiZyLm91dHB1dC5sZW5ndGh8fChyLm91dHB1dD1bXSksci5vdXRwdXQucHVzaCh0LnN0cmluZygpKTticmVhaztjYXNlIDM6ci5uYW1lPXQuc3RyaW5nKCk7YnJlYWs7Y2FzZSA0OnIub3BUeXBlPXQuc3RyaW5nKCk7YnJlYWs7Y2FzZSA3OnIuZG9tYWluPXQuc3RyaW5nKCk7YnJlYWs7Y2FzZSA1OnIuYXR0cmlidXRlJiZyLmF0dHJpYnV0ZS5sZW5ndGh8fChyLmF0dHJpYnV0ZT1bXSksci5hdHRyaWJ1dGUucHVzaChsLm9ubnguQXR0cmlidXRlUHJvdG8uZGVjb2RlKHQsdC51aW50MzIoKSkpO2JyZWFrO2Nhc2UgNjpyLmRvY1N0cmluZz10LnN0cmluZygpO2JyZWFrO2RlZmF1bHQ6dC5za2lwVHlwZSg3JmkpfX1yZXR1cm4gcn0sdC5kZWNvZGVEZWxpbWl0ZWQ9ZnVuY3Rpb24odCl7cmV0dXJuIHQgaW5zdGFuY2VvZiBzfHwodD1uZXcgcyh0KSksdGhpcy5kZWNvZGUodCx0LnVpbnQzMigpKX0sdC52ZXJpZnk9ZnVuY3Rpb24odCl7aWYoXCJvYmplY3RcIiE9dHlwZW9mIHR8fG51bGw9PT10KXJldHVyblwib2JqZWN0IGV4cGVjdGVkXCI7aWYobnVsbCE9dC5pbnB1dCYmdC5oYXNPd25Qcm9wZXJ0eShcImlucHV0XCIpKXtpZighQXJyYXkuaXNBcnJheSh0LmlucHV0KSlyZXR1cm5cImlucHV0OiBhcnJheSBleHBlY3RlZFwiO2Zvcih2YXIgZT0wO2U8dC5pbnB1dC5sZW5ndGg7KytlKWlmKCFjLmlzU3RyaW5nKHQuaW5wdXRbZV0pKXJldHVyblwiaW5wdXQ6IHN0cmluZ1tdIGV4cGVjdGVkXCJ9aWYobnVsbCE9dC5vdXRwdXQmJnQuaGFzT3duUHJvcGVydHkoXCJvdXRwdXRcIikpe2lmKCFBcnJheS5pc0FycmF5KHQub3V0cHV0KSlyZXR1cm5cIm91dHB1dDogYXJyYXkgZXhwZWN0ZWRcIjtmb3IoZT0wO2U8dC5vdXRwdXQubGVuZ3RoOysrZSlpZighYy5pc1N0cmluZyh0Lm91dHB1dFtlXSkpcmV0dXJuXCJvdXRwdXQ6IHN0cmluZ1tdIGV4cGVjdGVkXCJ9aWYobnVsbCE9dC5uYW1lJiZ0Lmhhc093blByb3BlcnR5KFwibmFtZVwiKSYmIWMuaXNTdHJpbmcodC5uYW1lKSlyZXR1cm5cIm5hbWU6IHN0cmluZyBleHBlY3RlZFwiO2lmKG51bGwhPXQub3BUeXBlJiZ0Lmhhc093blByb3BlcnR5KFwib3BUeXBlXCIpJiYhYy5pc1N0cmluZyh0Lm9wVHlwZSkpcmV0dXJuXCJvcFR5cGU6IHN0cmluZyBleHBlY3RlZFwiO2lmKG51bGwhPXQuZG9tYWluJiZ0Lmhhc093blByb3BlcnR5KFwiZG9tYWluXCIpJiYhYy5pc1N0cmluZyh0LmRvbWFpbikpcmV0dXJuXCJkb21haW46IHN0cmluZyBleHBlY3RlZFwiO2lmKG51bGwhPXQuYXR0cmlidXRlJiZ0Lmhhc093blByb3BlcnR5KFwiYXR0cmlidXRlXCIpKXtpZighQXJyYXkuaXNBcnJheSh0LmF0dHJpYnV0ZSkpcmV0dXJuXCJhdHRyaWJ1dGU6IGFycmF5IGV4cGVjdGVkXCI7Zm9yKGU9MDtlPHQuYXR0cmlidXRlLmxlbmd0aDsrK2Upe3ZhciBuPWwub25ueC5BdHRyaWJ1dGVQcm90by52ZXJpZnkodC5hdHRyaWJ1dGVbZV0pO2lmKG4pcmV0dXJuXCJhdHRyaWJ1dGUuXCIrbn19cmV0dXJuIG51bGwhPXQuZG9jU3RyaW5nJiZ0Lmhhc093blByb3BlcnR5KFwiZG9jU3RyaW5nXCIpJiYhYy5pc1N0cmluZyh0LmRvY1N0cmluZyk/XCJkb2NTdHJpbmc6IHN0cmluZyBleHBlY3RlZFwiOm51bGx9LHQuZnJvbU9iamVjdD1mdW5jdGlvbih0KXtpZih0IGluc3RhbmNlb2YgbC5vbm54Lk5vZGVQcm90bylyZXR1cm4gdDt2YXIgZT1uZXcgbC5vbm54Lk5vZGVQcm90bztpZih0LmlucHV0KXtpZighQXJyYXkuaXNBcnJheSh0LmlucHV0KSl0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5Ob2RlUHJvdG8uaW5wdXQ6IGFycmF5IGV4cGVjdGVkXCIpO2UuaW5wdXQ9W107Zm9yKHZhciBuPTA7bjx0LmlucHV0Lmxlbmd0aDsrK24pZS5pbnB1dFtuXT1TdHJpbmcodC5pbnB1dFtuXSl9aWYodC5vdXRwdXQpe2lmKCFBcnJheS5pc0FycmF5KHQub3V0cHV0KSl0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5Ob2RlUHJvdG8ub3V0cHV0OiBhcnJheSBleHBlY3RlZFwiKTtmb3IoZS5vdXRwdXQ9W10sbj0wO248dC5vdXRwdXQubGVuZ3RoOysrbillLm91dHB1dFtuXT1TdHJpbmcodC5vdXRwdXRbbl0pfWlmKG51bGwhPXQubmFtZSYmKGUubmFtZT1TdHJpbmcodC5uYW1lKSksbnVsbCE9dC5vcFR5cGUmJihlLm9wVHlwZT1TdHJpbmcodC5vcFR5cGUpKSxudWxsIT10LmRvbWFpbiYmKGUuZG9tYWluPVN0cmluZyh0LmRvbWFpbikpLHQuYXR0cmlidXRlKXtpZighQXJyYXkuaXNBcnJheSh0LmF0dHJpYnV0ZSkpdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguTm9kZVByb3RvLmF0dHJpYnV0ZTogYXJyYXkgZXhwZWN0ZWRcIik7Zm9yKGUuYXR0cmlidXRlPVtdLG49MDtuPHQuYXR0cmlidXRlLmxlbmd0aDsrK24pe2lmKFwib2JqZWN0XCIhPXR5cGVvZiB0LmF0dHJpYnV0ZVtuXSl0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5Ob2RlUHJvdG8uYXR0cmlidXRlOiBvYmplY3QgZXhwZWN0ZWRcIik7ZS5hdHRyaWJ1dGVbbl09bC5vbm54LkF0dHJpYnV0ZVByb3RvLmZyb21PYmplY3QodC5hdHRyaWJ1dGVbbl0pfX1yZXR1cm4gbnVsbCE9dC5kb2NTdHJpbmcmJihlLmRvY1N0cmluZz1TdHJpbmcodC5kb2NTdHJpbmcpKSxlfSx0LnRvT2JqZWN0PWZ1bmN0aW9uKHQsZSl7ZXx8KGU9e30pO3ZhciBuPXt9O2lmKChlLmFycmF5c3x8ZS5kZWZhdWx0cykmJihuLmlucHV0PVtdLG4ub3V0cHV0PVtdLG4uYXR0cmlidXRlPVtdKSxlLmRlZmF1bHRzJiYobi5uYW1lPVwiXCIsbi5vcFR5cGU9XCJcIixuLmRvY1N0cmluZz1cIlwiLG4uZG9tYWluPVwiXCIpLHQuaW5wdXQmJnQuaW5wdXQubGVuZ3RoKXtuLmlucHV0PVtdO2Zvcih2YXIgcj0wO3I8dC5pbnB1dC5sZW5ndGg7KytyKW4uaW5wdXRbcl09dC5pbnB1dFtyXX1pZih0Lm91dHB1dCYmdC5vdXRwdXQubGVuZ3RoKWZvcihuLm91dHB1dD1bXSxyPTA7cjx0Lm91dHB1dC5sZW5ndGg7KytyKW4ub3V0cHV0W3JdPXQub3V0cHV0W3JdO2lmKG51bGwhPXQubmFtZSYmdC5oYXNPd25Qcm9wZXJ0eShcIm5hbWVcIikmJihuLm5hbWU9dC5uYW1lKSxudWxsIT10Lm9wVHlwZSYmdC5oYXNPd25Qcm9wZXJ0eShcIm9wVHlwZVwiKSYmKG4ub3BUeXBlPXQub3BUeXBlKSx0LmF0dHJpYnV0ZSYmdC5hdHRyaWJ1dGUubGVuZ3RoKWZvcihuLmF0dHJpYnV0ZT1bXSxyPTA7cjx0LmF0dHJpYnV0ZS5sZW5ndGg7KytyKW4uYXR0cmlidXRlW3JdPWwub25ueC5BdHRyaWJ1dGVQcm90by50b09iamVjdCh0LmF0dHJpYnV0ZVtyXSxlKTtyZXR1cm4gbnVsbCE9dC5kb2NTdHJpbmcmJnQuaGFzT3duUHJvcGVydHkoXCJkb2NTdHJpbmdcIikmJihuLmRvY1N0cmluZz10LmRvY1N0cmluZyksbnVsbCE9dC5kb21haW4mJnQuaGFzT3duUHJvcGVydHkoXCJkb21haW5cIikmJihuLmRvbWFpbj10LmRvbWFpbiksbn0sdC5wcm90b3R5cGUudG9KU09OPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY29uc3RydWN0b3IudG9PYmplY3QodGhpcyxhLnV0aWwudG9KU09OT3B0aW9ucyl9LHR9KCksby5Nb2RlbFByb3RvPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0KXtpZih0aGlzLm9wc2V0SW1wb3J0PVtdLHRoaXMubWV0YWRhdGFQcm9wcz1bXSx0KWZvcih2YXIgZT1PYmplY3Qua2V5cyh0KSxuPTA7bjxlLmxlbmd0aDsrK24pbnVsbCE9dFtlW25dXSYmKHRoaXNbZVtuXV09dFtlW25dXSl9cmV0dXJuIHQucHJvdG90eXBlLmlyVmVyc2lvbj1jLkxvbmc/Yy5Mb25nLmZyb21CaXRzKDAsMCwhMSk6MCx0LnByb3RvdHlwZS5vcHNldEltcG9ydD1jLmVtcHR5QXJyYXksdC5wcm90b3R5cGUucHJvZHVjZXJOYW1lPVwiXCIsdC5wcm90b3R5cGUucHJvZHVjZXJWZXJzaW9uPVwiXCIsdC5wcm90b3R5cGUuZG9tYWluPVwiXCIsdC5wcm90b3R5cGUubW9kZWxWZXJzaW9uPWMuTG9uZz9jLkxvbmcuZnJvbUJpdHMoMCwwLCExKTowLHQucHJvdG90eXBlLmRvY1N0cmluZz1cIlwiLHQucHJvdG90eXBlLmdyYXBoPW51bGwsdC5wcm90b3R5cGUubWV0YWRhdGFQcm9wcz1jLmVtcHR5QXJyYXksdC5jcmVhdGU9ZnVuY3Rpb24oZSl7cmV0dXJuIG5ldyB0KGUpfSx0LmVuY29kZT1mdW5jdGlvbih0LGUpe2lmKGV8fChlPXUuY3JlYXRlKCkpLG51bGwhPXQuaXJWZXJzaW9uJiZ0Lmhhc093blByb3BlcnR5KFwiaXJWZXJzaW9uXCIpJiZlLnVpbnQzMig4KS5pbnQ2NCh0LmlyVmVyc2lvbiksbnVsbCE9dC5wcm9kdWNlck5hbWUmJnQuaGFzT3duUHJvcGVydHkoXCJwcm9kdWNlck5hbWVcIikmJmUudWludDMyKDE4KS5zdHJpbmcodC5wcm9kdWNlck5hbWUpLG51bGwhPXQucHJvZHVjZXJWZXJzaW9uJiZ0Lmhhc093blByb3BlcnR5KFwicHJvZHVjZXJWZXJzaW9uXCIpJiZlLnVpbnQzMigyNikuc3RyaW5nKHQucHJvZHVjZXJWZXJzaW9uKSxudWxsIT10LmRvbWFpbiYmdC5oYXNPd25Qcm9wZXJ0eShcImRvbWFpblwiKSYmZS51aW50MzIoMzQpLnN0cmluZyh0LmRvbWFpbiksbnVsbCE9dC5tb2RlbFZlcnNpb24mJnQuaGFzT3duUHJvcGVydHkoXCJtb2RlbFZlcnNpb25cIikmJmUudWludDMyKDQwKS5pbnQ2NCh0Lm1vZGVsVmVyc2lvbiksbnVsbCE9dC5kb2NTdHJpbmcmJnQuaGFzT3duUHJvcGVydHkoXCJkb2NTdHJpbmdcIikmJmUudWludDMyKDUwKS5zdHJpbmcodC5kb2NTdHJpbmcpLG51bGwhPXQuZ3JhcGgmJnQuaGFzT3duUHJvcGVydHkoXCJncmFwaFwiKSYmbC5vbm54LkdyYXBoUHJvdG8uZW5jb2RlKHQuZ3JhcGgsZS51aW50MzIoNTgpLmZvcmsoKSkubGRlbGltKCksbnVsbCE9dC5vcHNldEltcG9ydCYmdC5vcHNldEltcG9ydC5sZW5ndGgpZm9yKHZhciBuPTA7bjx0Lm9wc2V0SW1wb3J0Lmxlbmd0aDsrK24pbC5vbm54Lk9wZXJhdG9yU2V0SWRQcm90by5lbmNvZGUodC5vcHNldEltcG9ydFtuXSxlLnVpbnQzMig2NikuZm9yaygpKS5sZGVsaW0oKTtpZihudWxsIT10Lm1ldGFkYXRhUHJvcHMmJnQubWV0YWRhdGFQcm9wcy5sZW5ndGgpZm9yKG49MDtuPHQubWV0YWRhdGFQcm9wcy5sZW5ndGg7KytuKWwub25ueC5TdHJpbmdTdHJpbmdFbnRyeVByb3RvLmVuY29kZSh0Lm1ldGFkYXRhUHJvcHNbbl0sZS51aW50MzIoMTE0KS5mb3JrKCkpLmxkZWxpbSgpO3JldHVybiBlfSx0LmVuY29kZURlbGltaXRlZD1mdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLmVuY29kZSh0LGUpLmxkZWxpbSgpfSx0LmRlY29kZT1mdW5jdGlvbih0LGUpe3QgaW5zdGFuY2VvZiBzfHwodD1zLmNyZWF0ZSh0KSk7Zm9yKHZhciBuPXZvaWQgMD09PWU/dC5sZW46dC5wb3MrZSxyPW5ldyBsLm9ubnguTW9kZWxQcm90bzt0LnBvczxuOyl7dmFyIGk9dC51aW50MzIoKTtzd2l0Y2goaT4+PjMpe2Nhc2UgMTpyLmlyVmVyc2lvbj10LmludDY0KCk7YnJlYWs7Y2FzZSA4OnIub3BzZXRJbXBvcnQmJnIub3BzZXRJbXBvcnQubGVuZ3RofHwoci5vcHNldEltcG9ydD1bXSksci5vcHNldEltcG9ydC5wdXNoKGwub25ueC5PcGVyYXRvclNldElkUHJvdG8uZGVjb2RlKHQsdC51aW50MzIoKSkpO2JyZWFrO2Nhc2UgMjpyLnByb2R1Y2VyTmFtZT10LnN0cmluZygpO2JyZWFrO2Nhc2UgMzpyLnByb2R1Y2VyVmVyc2lvbj10LnN0cmluZygpO2JyZWFrO2Nhc2UgNDpyLmRvbWFpbj10LnN0cmluZygpO2JyZWFrO2Nhc2UgNTpyLm1vZGVsVmVyc2lvbj10LmludDY0KCk7YnJlYWs7Y2FzZSA2OnIuZG9jU3RyaW5nPXQuc3RyaW5nKCk7YnJlYWs7Y2FzZSA3OnIuZ3JhcGg9bC5vbm54LkdyYXBoUHJvdG8uZGVjb2RlKHQsdC51aW50MzIoKSk7YnJlYWs7Y2FzZSAxNDpyLm1ldGFkYXRhUHJvcHMmJnIubWV0YWRhdGFQcm9wcy5sZW5ndGh8fChyLm1ldGFkYXRhUHJvcHM9W10pLHIubWV0YWRhdGFQcm9wcy5wdXNoKGwub25ueC5TdHJpbmdTdHJpbmdFbnRyeVByb3RvLmRlY29kZSh0LHQudWludDMyKCkpKTticmVhaztkZWZhdWx0OnQuc2tpcFR5cGUoNyZpKX19cmV0dXJuIHJ9LHQuZGVjb2RlRGVsaW1pdGVkPWZ1bmN0aW9uKHQpe3JldHVybiB0IGluc3RhbmNlb2Ygc3x8KHQ9bmV3IHModCkpLHRoaXMuZGVjb2RlKHQsdC51aW50MzIoKSl9LHQudmVyaWZ5PWZ1bmN0aW9uKHQpe2lmKFwib2JqZWN0XCIhPXR5cGVvZiB0fHxudWxsPT09dClyZXR1cm5cIm9iamVjdCBleHBlY3RlZFwiO2lmKG51bGwhPXQuaXJWZXJzaW9uJiZ0Lmhhc093blByb3BlcnR5KFwiaXJWZXJzaW9uXCIpJiYhKGMuaXNJbnRlZ2VyKHQuaXJWZXJzaW9uKXx8dC5pclZlcnNpb24mJmMuaXNJbnRlZ2VyKHQuaXJWZXJzaW9uLmxvdykmJmMuaXNJbnRlZ2VyKHQuaXJWZXJzaW9uLmhpZ2gpKSlyZXR1cm5cImlyVmVyc2lvbjogaW50ZWdlcnxMb25nIGV4cGVjdGVkXCI7aWYobnVsbCE9dC5vcHNldEltcG9ydCYmdC5oYXNPd25Qcm9wZXJ0eShcIm9wc2V0SW1wb3J0XCIpKXtpZighQXJyYXkuaXNBcnJheSh0Lm9wc2V0SW1wb3J0KSlyZXR1cm5cIm9wc2V0SW1wb3J0OiBhcnJheSBleHBlY3RlZFwiO2Zvcih2YXIgZT0wO2U8dC5vcHNldEltcG9ydC5sZW5ndGg7KytlKWlmKG49bC5vbm54Lk9wZXJhdG9yU2V0SWRQcm90by52ZXJpZnkodC5vcHNldEltcG9ydFtlXSkpcmV0dXJuXCJvcHNldEltcG9ydC5cIitufWlmKG51bGwhPXQucHJvZHVjZXJOYW1lJiZ0Lmhhc093blByb3BlcnR5KFwicHJvZHVjZXJOYW1lXCIpJiYhYy5pc1N0cmluZyh0LnByb2R1Y2VyTmFtZSkpcmV0dXJuXCJwcm9kdWNlck5hbWU6IHN0cmluZyBleHBlY3RlZFwiO2lmKG51bGwhPXQucHJvZHVjZXJWZXJzaW9uJiZ0Lmhhc093blByb3BlcnR5KFwicHJvZHVjZXJWZXJzaW9uXCIpJiYhYy5pc1N0cmluZyh0LnByb2R1Y2VyVmVyc2lvbikpcmV0dXJuXCJwcm9kdWNlclZlcnNpb246IHN0cmluZyBleHBlY3RlZFwiO2lmKG51bGwhPXQuZG9tYWluJiZ0Lmhhc093blByb3BlcnR5KFwiZG9tYWluXCIpJiYhYy5pc1N0cmluZyh0LmRvbWFpbikpcmV0dXJuXCJkb21haW46IHN0cmluZyBleHBlY3RlZFwiO2lmKG51bGwhPXQubW9kZWxWZXJzaW9uJiZ0Lmhhc093blByb3BlcnR5KFwibW9kZWxWZXJzaW9uXCIpJiYhKGMuaXNJbnRlZ2VyKHQubW9kZWxWZXJzaW9uKXx8dC5tb2RlbFZlcnNpb24mJmMuaXNJbnRlZ2VyKHQubW9kZWxWZXJzaW9uLmxvdykmJmMuaXNJbnRlZ2VyKHQubW9kZWxWZXJzaW9uLmhpZ2gpKSlyZXR1cm5cIm1vZGVsVmVyc2lvbjogaW50ZWdlcnxMb25nIGV4cGVjdGVkXCI7aWYobnVsbCE9dC5kb2NTdHJpbmcmJnQuaGFzT3duUHJvcGVydHkoXCJkb2NTdHJpbmdcIikmJiFjLmlzU3RyaW5nKHQuZG9jU3RyaW5nKSlyZXR1cm5cImRvY1N0cmluZzogc3RyaW5nIGV4cGVjdGVkXCI7aWYobnVsbCE9dC5ncmFwaCYmdC5oYXNPd25Qcm9wZXJ0eShcImdyYXBoXCIpJiYobj1sLm9ubnguR3JhcGhQcm90by52ZXJpZnkodC5ncmFwaCkpKXJldHVyblwiZ3JhcGguXCIrbjtpZihudWxsIT10Lm1ldGFkYXRhUHJvcHMmJnQuaGFzT3duUHJvcGVydHkoXCJtZXRhZGF0YVByb3BzXCIpKXtpZighQXJyYXkuaXNBcnJheSh0Lm1ldGFkYXRhUHJvcHMpKXJldHVyblwibWV0YWRhdGFQcm9wczogYXJyYXkgZXhwZWN0ZWRcIjtmb3IoZT0wO2U8dC5tZXRhZGF0YVByb3BzLmxlbmd0aDsrK2Upe3ZhciBuO2lmKG49bC5vbm54LlN0cmluZ1N0cmluZ0VudHJ5UHJvdG8udmVyaWZ5KHQubWV0YWRhdGFQcm9wc1tlXSkpcmV0dXJuXCJtZXRhZGF0YVByb3BzLlwiK259fXJldHVybiBudWxsfSx0LmZyb21PYmplY3Q9ZnVuY3Rpb24odCl7aWYodCBpbnN0YW5jZW9mIGwub25ueC5Nb2RlbFByb3RvKXJldHVybiB0O3ZhciBlPW5ldyBsLm9ubnguTW9kZWxQcm90bztpZihudWxsIT10LmlyVmVyc2lvbiYmKGMuTG9uZz8oZS5pclZlcnNpb249Yy5Mb25nLmZyb21WYWx1ZSh0LmlyVmVyc2lvbikpLnVuc2lnbmVkPSExOlwic3RyaW5nXCI9PXR5cGVvZiB0LmlyVmVyc2lvbj9lLmlyVmVyc2lvbj1wYXJzZUludCh0LmlyVmVyc2lvbiwxMCk6XCJudW1iZXJcIj09dHlwZW9mIHQuaXJWZXJzaW9uP2UuaXJWZXJzaW9uPXQuaXJWZXJzaW9uOlwib2JqZWN0XCI9PXR5cGVvZiB0LmlyVmVyc2lvbiYmKGUuaXJWZXJzaW9uPW5ldyBjLkxvbmdCaXRzKHQuaXJWZXJzaW9uLmxvdz4+PjAsdC5pclZlcnNpb24uaGlnaD4+PjApLnRvTnVtYmVyKCkpKSx0Lm9wc2V0SW1wb3J0KXtpZighQXJyYXkuaXNBcnJheSh0Lm9wc2V0SW1wb3J0KSl0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5Nb2RlbFByb3RvLm9wc2V0SW1wb3J0OiBhcnJheSBleHBlY3RlZFwiKTtlLm9wc2V0SW1wb3J0PVtdO2Zvcih2YXIgbj0wO248dC5vcHNldEltcG9ydC5sZW5ndGg7KytuKXtpZihcIm9iamVjdFwiIT10eXBlb2YgdC5vcHNldEltcG9ydFtuXSl0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5Nb2RlbFByb3RvLm9wc2V0SW1wb3J0OiBvYmplY3QgZXhwZWN0ZWRcIik7ZS5vcHNldEltcG9ydFtuXT1sLm9ubnguT3BlcmF0b3JTZXRJZFByb3RvLmZyb21PYmplY3QodC5vcHNldEltcG9ydFtuXSl9fWlmKG51bGwhPXQucHJvZHVjZXJOYW1lJiYoZS5wcm9kdWNlck5hbWU9U3RyaW5nKHQucHJvZHVjZXJOYW1lKSksbnVsbCE9dC5wcm9kdWNlclZlcnNpb24mJihlLnByb2R1Y2VyVmVyc2lvbj1TdHJpbmcodC5wcm9kdWNlclZlcnNpb24pKSxudWxsIT10LmRvbWFpbiYmKGUuZG9tYWluPVN0cmluZyh0LmRvbWFpbikpLG51bGwhPXQubW9kZWxWZXJzaW9uJiYoYy5Mb25nPyhlLm1vZGVsVmVyc2lvbj1jLkxvbmcuZnJvbVZhbHVlKHQubW9kZWxWZXJzaW9uKSkudW5zaWduZWQ9ITE6XCJzdHJpbmdcIj09dHlwZW9mIHQubW9kZWxWZXJzaW9uP2UubW9kZWxWZXJzaW9uPXBhcnNlSW50KHQubW9kZWxWZXJzaW9uLDEwKTpcIm51bWJlclwiPT10eXBlb2YgdC5tb2RlbFZlcnNpb24/ZS5tb2RlbFZlcnNpb249dC5tb2RlbFZlcnNpb246XCJvYmplY3RcIj09dHlwZW9mIHQubW9kZWxWZXJzaW9uJiYoZS5tb2RlbFZlcnNpb249bmV3IGMuTG9uZ0JpdHModC5tb2RlbFZlcnNpb24ubG93Pj4+MCx0Lm1vZGVsVmVyc2lvbi5oaWdoPj4+MCkudG9OdW1iZXIoKSkpLG51bGwhPXQuZG9jU3RyaW5nJiYoZS5kb2NTdHJpbmc9U3RyaW5nKHQuZG9jU3RyaW5nKSksbnVsbCE9dC5ncmFwaCl7aWYoXCJvYmplY3RcIiE9dHlwZW9mIHQuZ3JhcGgpdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguTW9kZWxQcm90by5ncmFwaDogb2JqZWN0IGV4cGVjdGVkXCIpO2UuZ3JhcGg9bC5vbm54LkdyYXBoUHJvdG8uZnJvbU9iamVjdCh0LmdyYXBoKX1pZih0Lm1ldGFkYXRhUHJvcHMpe2lmKCFBcnJheS5pc0FycmF5KHQubWV0YWRhdGFQcm9wcykpdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguTW9kZWxQcm90by5tZXRhZGF0YVByb3BzOiBhcnJheSBleHBlY3RlZFwiKTtmb3IoZS5tZXRhZGF0YVByb3BzPVtdLG49MDtuPHQubWV0YWRhdGFQcm9wcy5sZW5ndGg7KytuKXtpZihcIm9iamVjdFwiIT10eXBlb2YgdC5tZXRhZGF0YVByb3BzW25dKXRocm93IFR5cGVFcnJvcihcIi5vbm54Lk1vZGVsUHJvdG8ubWV0YWRhdGFQcm9wczogb2JqZWN0IGV4cGVjdGVkXCIpO2UubWV0YWRhdGFQcm9wc1tuXT1sLm9ubnguU3RyaW5nU3RyaW5nRW50cnlQcm90by5mcm9tT2JqZWN0KHQubWV0YWRhdGFQcm9wc1tuXSl9fXJldHVybiBlfSx0LnRvT2JqZWN0PWZ1bmN0aW9uKHQsZSl7ZXx8KGU9e30pO3ZhciBuPXt9O2lmKChlLmFycmF5c3x8ZS5kZWZhdWx0cykmJihuLm9wc2V0SW1wb3J0PVtdLG4ubWV0YWRhdGFQcm9wcz1bXSksZS5kZWZhdWx0cyl7aWYoYy5Mb25nKXt2YXIgcj1uZXcgYy5Mb25nKDAsMCwhMSk7bi5pclZlcnNpb249ZS5sb25ncz09PVN0cmluZz9yLnRvU3RyaW5nKCk6ZS5sb25ncz09PU51bWJlcj9yLnRvTnVtYmVyKCk6cn1lbHNlIG4uaXJWZXJzaW9uPWUubG9uZ3M9PT1TdHJpbmc/XCIwXCI6MDtuLnByb2R1Y2VyTmFtZT1cIlwiLG4ucHJvZHVjZXJWZXJzaW9uPVwiXCIsbi5kb21haW49XCJcIixjLkxvbmc/KHI9bmV3IGMuTG9uZygwLDAsITEpLG4ubW9kZWxWZXJzaW9uPWUubG9uZ3M9PT1TdHJpbmc/ci50b1N0cmluZygpOmUubG9uZ3M9PT1OdW1iZXI/ci50b051bWJlcigpOnIpOm4ubW9kZWxWZXJzaW9uPWUubG9uZ3M9PT1TdHJpbmc/XCIwXCI6MCxuLmRvY1N0cmluZz1cIlwiLG4uZ3JhcGg9bnVsbH1pZihudWxsIT10LmlyVmVyc2lvbiYmdC5oYXNPd25Qcm9wZXJ0eShcImlyVmVyc2lvblwiKSYmKFwibnVtYmVyXCI9PXR5cGVvZiB0LmlyVmVyc2lvbj9uLmlyVmVyc2lvbj1lLmxvbmdzPT09U3RyaW5nP1N0cmluZyh0LmlyVmVyc2lvbik6dC5pclZlcnNpb246bi5pclZlcnNpb249ZS5sb25ncz09PVN0cmluZz9jLkxvbmcucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodC5pclZlcnNpb24pOmUubG9uZ3M9PT1OdW1iZXI/bmV3IGMuTG9uZ0JpdHModC5pclZlcnNpb24ubG93Pj4+MCx0LmlyVmVyc2lvbi5oaWdoPj4+MCkudG9OdW1iZXIoKTp0LmlyVmVyc2lvbiksbnVsbCE9dC5wcm9kdWNlck5hbWUmJnQuaGFzT3duUHJvcGVydHkoXCJwcm9kdWNlck5hbWVcIikmJihuLnByb2R1Y2VyTmFtZT10LnByb2R1Y2VyTmFtZSksbnVsbCE9dC5wcm9kdWNlclZlcnNpb24mJnQuaGFzT3duUHJvcGVydHkoXCJwcm9kdWNlclZlcnNpb25cIikmJihuLnByb2R1Y2VyVmVyc2lvbj10LnByb2R1Y2VyVmVyc2lvbiksbnVsbCE9dC5kb21haW4mJnQuaGFzT3duUHJvcGVydHkoXCJkb21haW5cIikmJihuLmRvbWFpbj10LmRvbWFpbiksbnVsbCE9dC5tb2RlbFZlcnNpb24mJnQuaGFzT3duUHJvcGVydHkoXCJtb2RlbFZlcnNpb25cIikmJihcIm51bWJlclwiPT10eXBlb2YgdC5tb2RlbFZlcnNpb24/bi5tb2RlbFZlcnNpb249ZS5sb25ncz09PVN0cmluZz9TdHJpbmcodC5tb2RlbFZlcnNpb24pOnQubW9kZWxWZXJzaW9uOm4ubW9kZWxWZXJzaW9uPWUubG9uZ3M9PT1TdHJpbmc/Yy5Mb25nLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHQubW9kZWxWZXJzaW9uKTplLmxvbmdzPT09TnVtYmVyP25ldyBjLkxvbmdCaXRzKHQubW9kZWxWZXJzaW9uLmxvdz4+PjAsdC5tb2RlbFZlcnNpb24uaGlnaD4+PjApLnRvTnVtYmVyKCk6dC5tb2RlbFZlcnNpb24pLG51bGwhPXQuZG9jU3RyaW5nJiZ0Lmhhc093blByb3BlcnR5KFwiZG9jU3RyaW5nXCIpJiYobi5kb2NTdHJpbmc9dC5kb2NTdHJpbmcpLG51bGwhPXQuZ3JhcGgmJnQuaGFzT3duUHJvcGVydHkoXCJncmFwaFwiKSYmKG4uZ3JhcGg9bC5vbm54LkdyYXBoUHJvdG8udG9PYmplY3QodC5ncmFwaCxlKSksdC5vcHNldEltcG9ydCYmdC5vcHNldEltcG9ydC5sZW5ndGgpe24ub3BzZXRJbXBvcnQ9W107Zm9yKHZhciBpPTA7aTx0Lm9wc2V0SW1wb3J0Lmxlbmd0aDsrK2kpbi5vcHNldEltcG9ydFtpXT1sLm9ubnguT3BlcmF0b3JTZXRJZFByb3RvLnRvT2JqZWN0KHQub3BzZXRJbXBvcnRbaV0sZSl9aWYodC5tZXRhZGF0YVByb3BzJiZ0Lm1ldGFkYXRhUHJvcHMubGVuZ3RoKWZvcihuLm1ldGFkYXRhUHJvcHM9W10saT0wO2k8dC5tZXRhZGF0YVByb3BzLmxlbmd0aDsrK2kpbi5tZXRhZGF0YVByb3BzW2ldPWwub25ueC5TdHJpbmdTdHJpbmdFbnRyeVByb3RvLnRvT2JqZWN0KHQubWV0YWRhdGFQcm9wc1tpXSxlKTtyZXR1cm4gbn0sdC5wcm90b3R5cGUudG9KU09OPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY29uc3RydWN0b3IudG9PYmplY3QodGhpcyxhLnV0aWwudG9KU09OT3B0aW9ucyl9LHR9KCksby5TdHJpbmdTdHJpbmdFbnRyeVByb3RvPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0KXtpZih0KWZvcih2YXIgZT1PYmplY3Qua2V5cyh0KSxuPTA7bjxlLmxlbmd0aDsrK24pbnVsbCE9dFtlW25dXSYmKHRoaXNbZVtuXV09dFtlW25dXSl9cmV0dXJuIHQucHJvdG90eXBlLmtleT1cIlwiLHQucHJvdG90eXBlLnZhbHVlPVwiXCIsdC5jcmVhdGU9ZnVuY3Rpb24oZSl7cmV0dXJuIG5ldyB0KGUpfSx0LmVuY29kZT1mdW5jdGlvbih0LGUpe3JldHVybiBlfHwoZT11LmNyZWF0ZSgpKSxudWxsIT10LmtleSYmdC5oYXNPd25Qcm9wZXJ0eShcImtleVwiKSYmZS51aW50MzIoMTApLnN0cmluZyh0LmtleSksbnVsbCE9dC52YWx1ZSYmdC5oYXNPd25Qcm9wZXJ0eShcInZhbHVlXCIpJiZlLnVpbnQzMigxOCkuc3RyaW5nKHQudmFsdWUpLGV9LHQuZW5jb2RlRGVsaW1pdGVkPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMuZW5jb2RlKHQsZSkubGRlbGltKCl9LHQuZGVjb2RlPWZ1bmN0aW9uKHQsZSl7dCBpbnN0YW5jZW9mIHN8fCh0PXMuY3JlYXRlKHQpKTtmb3IodmFyIG49dm9pZCAwPT09ZT90Lmxlbjp0LnBvcytlLHI9bmV3IGwub25ueC5TdHJpbmdTdHJpbmdFbnRyeVByb3RvO3QucG9zPG47KXt2YXIgaT10LnVpbnQzMigpO3N3aXRjaChpPj4+Myl7Y2FzZSAxOnIua2V5PXQuc3RyaW5nKCk7YnJlYWs7Y2FzZSAyOnIudmFsdWU9dC5zdHJpbmcoKTticmVhaztkZWZhdWx0OnQuc2tpcFR5cGUoNyZpKX19cmV0dXJuIHJ9LHQuZGVjb2RlRGVsaW1pdGVkPWZ1bmN0aW9uKHQpe3JldHVybiB0IGluc3RhbmNlb2Ygc3x8KHQ9bmV3IHModCkpLHRoaXMuZGVjb2RlKHQsdC51aW50MzIoKSl9LHQudmVyaWZ5PWZ1bmN0aW9uKHQpe3JldHVyblwib2JqZWN0XCIhPXR5cGVvZiB0fHxudWxsPT09dD9cIm9iamVjdCBleHBlY3RlZFwiOm51bGwhPXQua2V5JiZ0Lmhhc093blByb3BlcnR5KFwia2V5XCIpJiYhYy5pc1N0cmluZyh0LmtleSk/XCJrZXk6IHN0cmluZyBleHBlY3RlZFwiOm51bGwhPXQudmFsdWUmJnQuaGFzT3duUHJvcGVydHkoXCJ2YWx1ZVwiKSYmIWMuaXNTdHJpbmcodC52YWx1ZSk/XCJ2YWx1ZTogc3RyaW5nIGV4cGVjdGVkXCI6bnVsbH0sdC5mcm9tT2JqZWN0PWZ1bmN0aW9uKHQpe2lmKHQgaW5zdGFuY2VvZiBsLm9ubnguU3RyaW5nU3RyaW5nRW50cnlQcm90bylyZXR1cm4gdDt2YXIgZT1uZXcgbC5vbm54LlN0cmluZ1N0cmluZ0VudHJ5UHJvdG87cmV0dXJuIG51bGwhPXQua2V5JiYoZS5rZXk9U3RyaW5nKHQua2V5KSksbnVsbCE9dC52YWx1ZSYmKGUudmFsdWU9U3RyaW5nKHQudmFsdWUpKSxlfSx0LnRvT2JqZWN0PWZ1bmN0aW9uKHQsZSl7ZXx8KGU9e30pO3ZhciBuPXt9O3JldHVybiBlLmRlZmF1bHRzJiYobi5rZXk9XCJcIixuLnZhbHVlPVwiXCIpLG51bGwhPXQua2V5JiZ0Lmhhc093blByb3BlcnR5KFwia2V5XCIpJiYobi5rZXk9dC5rZXkpLG51bGwhPXQudmFsdWUmJnQuaGFzT3duUHJvcGVydHkoXCJ2YWx1ZVwiKSYmKG4udmFsdWU9dC52YWx1ZSksbn0sdC5wcm90b3R5cGUudG9KU09OPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY29uc3RydWN0b3IudG9PYmplY3QodGhpcyxhLnV0aWwudG9KU09OT3B0aW9ucyl9LHR9KCksby5UZW5zb3JBbm5vdGF0aW9uPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0KXtpZih0aGlzLnF1YW50UGFyYW1ldGVyVGVuc29yTmFtZXM9W10sdClmb3IodmFyIGU9T2JqZWN0LmtleXModCksbj0wO248ZS5sZW5ndGg7KytuKW51bGwhPXRbZVtuXV0mJih0aGlzW2Vbbl1dPXRbZVtuXV0pfXJldHVybiB0LnByb3RvdHlwZS50ZW5zb3JOYW1lPVwiXCIsdC5wcm90b3R5cGUucXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lcz1jLmVtcHR5QXJyYXksdC5jcmVhdGU9ZnVuY3Rpb24oZSl7cmV0dXJuIG5ldyB0KGUpfSx0LmVuY29kZT1mdW5jdGlvbih0LGUpe2lmKGV8fChlPXUuY3JlYXRlKCkpLG51bGwhPXQudGVuc29yTmFtZSYmdC5oYXNPd25Qcm9wZXJ0eShcInRlbnNvck5hbWVcIikmJmUudWludDMyKDEwKS5zdHJpbmcodC50ZW5zb3JOYW1lKSxudWxsIT10LnF1YW50UGFyYW1ldGVyVGVuc29yTmFtZXMmJnQucXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lcy5sZW5ndGgpZm9yKHZhciBuPTA7bjx0LnF1YW50UGFyYW1ldGVyVGVuc29yTmFtZXMubGVuZ3RoOysrbilsLm9ubnguU3RyaW5nU3RyaW5nRW50cnlQcm90by5lbmNvZGUodC5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzW25dLGUudWludDMyKDE4KS5mb3JrKCkpLmxkZWxpbSgpO3JldHVybiBlfSx0LmVuY29kZURlbGltaXRlZD1mdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLmVuY29kZSh0LGUpLmxkZWxpbSgpfSx0LmRlY29kZT1mdW5jdGlvbih0LGUpe3QgaW5zdGFuY2VvZiBzfHwodD1zLmNyZWF0ZSh0KSk7Zm9yKHZhciBuPXZvaWQgMD09PWU/dC5sZW46dC5wb3MrZSxyPW5ldyBsLm9ubnguVGVuc29yQW5ub3RhdGlvbjt0LnBvczxuOyl7dmFyIGk9dC51aW50MzIoKTtzd2l0Y2goaT4+PjMpe2Nhc2UgMTpyLnRlbnNvck5hbWU9dC5zdHJpbmcoKTticmVhaztjYXNlIDI6ci5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzJiZyLnF1YW50UGFyYW1ldGVyVGVuc29yTmFtZXMubGVuZ3RofHwoci5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzPVtdKSxyLnF1YW50UGFyYW1ldGVyVGVuc29yTmFtZXMucHVzaChsLm9ubnguU3RyaW5nU3RyaW5nRW50cnlQcm90by5kZWNvZGUodCx0LnVpbnQzMigpKSk7YnJlYWs7ZGVmYXVsdDp0LnNraXBUeXBlKDcmaSl9fXJldHVybiByfSx0LmRlY29kZURlbGltaXRlZD1mdW5jdGlvbih0KXtyZXR1cm4gdCBpbnN0YW5jZW9mIHN8fCh0PW5ldyBzKHQpKSx0aGlzLmRlY29kZSh0LHQudWludDMyKCkpfSx0LnZlcmlmeT1mdW5jdGlvbih0KXtpZihcIm9iamVjdFwiIT10eXBlb2YgdHx8bnVsbD09PXQpcmV0dXJuXCJvYmplY3QgZXhwZWN0ZWRcIjtpZihudWxsIT10LnRlbnNvck5hbWUmJnQuaGFzT3duUHJvcGVydHkoXCJ0ZW5zb3JOYW1lXCIpJiYhYy5pc1N0cmluZyh0LnRlbnNvck5hbWUpKXJldHVyblwidGVuc29yTmFtZTogc3RyaW5nIGV4cGVjdGVkXCI7aWYobnVsbCE9dC5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzJiZ0Lmhhc093blByb3BlcnR5KFwicXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lc1wiKSl7aWYoIUFycmF5LmlzQXJyYXkodC5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzKSlyZXR1cm5cInF1YW50UGFyYW1ldGVyVGVuc29yTmFtZXM6IGFycmF5IGV4cGVjdGVkXCI7Zm9yKHZhciBlPTA7ZTx0LnF1YW50UGFyYW1ldGVyVGVuc29yTmFtZXMubGVuZ3RoOysrZSl7dmFyIG49bC5vbm54LlN0cmluZ1N0cmluZ0VudHJ5UHJvdG8udmVyaWZ5KHQucXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lc1tlXSk7aWYobilyZXR1cm5cInF1YW50UGFyYW1ldGVyVGVuc29yTmFtZXMuXCIrbn19cmV0dXJuIG51bGx9LHQuZnJvbU9iamVjdD1mdW5jdGlvbih0KXtpZih0IGluc3RhbmNlb2YgbC5vbm54LlRlbnNvckFubm90YXRpb24pcmV0dXJuIHQ7dmFyIGU9bmV3IGwub25ueC5UZW5zb3JBbm5vdGF0aW9uO2lmKG51bGwhPXQudGVuc29yTmFtZSYmKGUudGVuc29yTmFtZT1TdHJpbmcodC50ZW5zb3JOYW1lKSksdC5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzKXtpZighQXJyYXkuaXNBcnJheSh0LnF1YW50UGFyYW1ldGVyVGVuc29yTmFtZXMpKXRocm93IFR5cGVFcnJvcihcIi5vbm54LlRlbnNvckFubm90YXRpb24ucXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lczogYXJyYXkgZXhwZWN0ZWRcIik7ZS5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzPVtdO2Zvcih2YXIgbj0wO248dC5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzLmxlbmd0aDsrK24pe2lmKFwib2JqZWN0XCIhPXR5cGVvZiB0LnF1YW50UGFyYW1ldGVyVGVuc29yTmFtZXNbbl0pdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguVGVuc29yQW5ub3RhdGlvbi5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzOiBvYmplY3QgZXhwZWN0ZWRcIik7ZS5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzW25dPWwub25ueC5TdHJpbmdTdHJpbmdFbnRyeVByb3RvLmZyb21PYmplY3QodC5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzW25dKX19cmV0dXJuIGV9LHQudG9PYmplY3Q9ZnVuY3Rpb24odCxlKXtlfHwoZT17fSk7dmFyIG49e307aWYoKGUuYXJyYXlzfHxlLmRlZmF1bHRzKSYmKG4ucXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lcz1bXSksZS5kZWZhdWx0cyYmKG4udGVuc29yTmFtZT1cIlwiKSxudWxsIT10LnRlbnNvck5hbWUmJnQuaGFzT3duUHJvcGVydHkoXCJ0ZW5zb3JOYW1lXCIpJiYobi50ZW5zb3JOYW1lPXQudGVuc29yTmFtZSksdC5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzJiZ0LnF1YW50UGFyYW1ldGVyVGVuc29yTmFtZXMubGVuZ3RoKXtuLnF1YW50UGFyYW1ldGVyVGVuc29yTmFtZXM9W107Zm9yKHZhciByPTA7cjx0LnF1YW50UGFyYW1ldGVyVGVuc29yTmFtZXMubGVuZ3RoOysrciluLnF1YW50UGFyYW1ldGVyVGVuc29yTmFtZXNbcl09bC5vbm54LlN0cmluZ1N0cmluZ0VudHJ5UHJvdG8udG9PYmplY3QodC5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzW3JdLGUpfXJldHVybiBufSx0LnByb3RvdHlwZS50b0pTT049ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci50b09iamVjdCh0aGlzLGEudXRpbC50b0pTT05PcHRpb25zKX0sdH0oKSxvLkdyYXBoUHJvdG89ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQpe2lmKHRoaXMubm9kZT1bXSx0aGlzLmluaXRpYWxpemVyPVtdLHRoaXMuaW5wdXQ9W10sdGhpcy5vdXRwdXQ9W10sdGhpcy52YWx1ZUluZm89W10sdGhpcy5xdWFudGl6YXRpb25Bbm5vdGF0aW9uPVtdLHQpZm9yKHZhciBlPU9iamVjdC5rZXlzKHQpLG49MDtuPGUubGVuZ3RoOysrbiludWxsIT10W2Vbbl1dJiYodGhpc1tlW25dXT10W2Vbbl1dKX1yZXR1cm4gdC5wcm90b3R5cGUubm9kZT1jLmVtcHR5QXJyYXksdC5wcm90b3R5cGUubmFtZT1cIlwiLHQucHJvdG90eXBlLmluaXRpYWxpemVyPWMuZW1wdHlBcnJheSx0LnByb3RvdHlwZS5kb2NTdHJpbmc9XCJcIix0LnByb3RvdHlwZS5pbnB1dD1jLmVtcHR5QXJyYXksdC5wcm90b3R5cGUub3V0cHV0PWMuZW1wdHlBcnJheSx0LnByb3RvdHlwZS52YWx1ZUluZm89Yy5lbXB0eUFycmF5LHQucHJvdG90eXBlLnF1YW50aXphdGlvbkFubm90YXRpb249Yy5lbXB0eUFycmF5LHQuY3JlYXRlPWZ1bmN0aW9uKGUpe3JldHVybiBuZXcgdChlKX0sdC5lbmNvZGU9ZnVuY3Rpb24odCxlKXtpZihlfHwoZT11LmNyZWF0ZSgpKSxudWxsIT10Lm5vZGUmJnQubm9kZS5sZW5ndGgpZm9yKHZhciBuPTA7bjx0Lm5vZGUubGVuZ3RoOysrbilsLm9ubnguTm9kZVByb3RvLmVuY29kZSh0Lm5vZGVbbl0sZS51aW50MzIoMTApLmZvcmsoKSkubGRlbGltKCk7aWYobnVsbCE9dC5uYW1lJiZ0Lmhhc093blByb3BlcnR5KFwibmFtZVwiKSYmZS51aW50MzIoMTgpLnN0cmluZyh0Lm5hbWUpLG51bGwhPXQuaW5pdGlhbGl6ZXImJnQuaW5pdGlhbGl6ZXIubGVuZ3RoKWZvcihuPTA7bjx0LmluaXRpYWxpemVyLmxlbmd0aDsrK24pbC5vbm54LlRlbnNvclByb3RvLmVuY29kZSh0LmluaXRpYWxpemVyW25dLGUudWludDMyKDQyKS5mb3JrKCkpLmxkZWxpbSgpO2lmKG51bGwhPXQuZG9jU3RyaW5nJiZ0Lmhhc093blByb3BlcnR5KFwiZG9jU3RyaW5nXCIpJiZlLnVpbnQzMig4Mikuc3RyaW5nKHQuZG9jU3RyaW5nKSxudWxsIT10LmlucHV0JiZ0LmlucHV0Lmxlbmd0aClmb3Iobj0wO248dC5pbnB1dC5sZW5ndGg7KytuKWwub25ueC5WYWx1ZUluZm9Qcm90by5lbmNvZGUodC5pbnB1dFtuXSxlLnVpbnQzMig5MCkuZm9yaygpKS5sZGVsaW0oKTtpZihudWxsIT10Lm91dHB1dCYmdC5vdXRwdXQubGVuZ3RoKWZvcihuPTA7bjx0Lm91dHB1dC5sZW5ndGg7KytuKWwub25ueC5WYWx1ZUluZm9Qcm90by5lbmNvZGUodC5vdXRwdXRbbl0sZS51aW50MzIoOTgpLmZvcmsoKSkubGRlbGltKCk7aWYobnVsbCE9dC52YWx1ZUluZm8mJnQudmFsdWVJbmZvLmxlbmd0aClmb3Iobj0wO248dC52YWx1ZUluZm8ubGVuZ3RoOysrbilsLm9ubnguVmFsdWVJbmZvUHJvdG8uZW5jb2RlKHQudmFsdWVJbmZvW25dLGUudWludDMyKDEwNikuZm9yaygpKS5sZGVsaW0oKTtpZihudWxsIT10LnF1YW50aXphdGlvbkFubm90YXRpb24mJnQucXVhbnRpemF0aW9uQW5ub3RhdGlvbi5sZW5ndGgpZm9yKG49MDtuPHQucXVhbnRpemF0aW9uQW5ub3RhdGlvbi5sZW5ndGg7KytuKWwub25ueC5UZW5zb3JBbm5vdGF0aW9uLmVuY29kZSh0LnF1YW50aXphdGlvbkFubm90YXRpb25bbl0sZS51aW50MzIoMTE0KS5mb3JrKCkpLmxkZWxpbSgpO3JldHVybiBlfSx0LmVuY29kZURlbGltaXRlZD1mdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLmVuY29kZSh0LGUpLmxkZWxpbSgpfSx0LmRlY29kZT1mdW5jdGlvbih0LGUpe3QgaW5zdGFuY2VvZiBzfHwodD1zLmNyZWF0ZSh0KSk7Zm9yKHZhciBuPXZvaWQgMD09PWU/dC5sZW46dC5wb3MrZSxyPW5ldyBsLm9ubnguR3JhcGhQcm90bzt0LnBvczxuOyl7dmFyIGk9dC51aW50MzIoKTtzd2l0Y2goaT4+PjMpe2Nhc2UgMTpyLm5vZGUmJnIubm9kZS5sZW5ndGh8fChyLm5vZGU9W10pLHIubm9kZS5wdXNoKGwub25ueC5Ob2RlUHJvdG8uZGVjb2RlKHQsdC51aW50MzIoKSkpO2JyZWFrO2Nhc2UgMjpyLm5hbWU9dC5zdHJpbmcoKTticmVhaztjYXNlIDU6ci5pbml0aWFsaXplciYmci5pbml0aWFsaXplci5sZW5ndGh8fChyLmluaXRpYWxpemVyPVtdKSxyLmluaXRpYWxpemVyLnB1c2gobC5vbm54LlRlbnNvclByb3RvLmRlY29kZSh0LHQudWludDMyKCkpKTticmVhaztjYXNlIDEwOnIuZG9jU3RyaW5nPXQuc3RyaW5nKCk7YnJlYWs7Y2FzZSAxMTpyLmlucHV0JiZyLmlucHV0Lmxlbmd0aHx8KHIuaW5wdXQ9W10pLHIuaW5wdXQucHVzaChsLm9ubnguVmFsdWVJbmZvUHJvdG8uZGVjb2RlKHQsdC51aW50MzIoKSkpO2JyZWFrO2Nhc2UgMTI6ci5vdXRwdXQmJnIub3V0cHV0Lmxlbmd0aHx8KHIub3V0cHV0PVtdKSxyLm91dHB1dC5wdXNoKGwub25ueC5WYWx1ZUluZm9Qcm90by5kZWNvZGUodCx0LnVpbnQzMigpKSk7YnJlYWs7Y2FzZSAxMzpyLnZhbHVlSW5mbyYmci52YWx1ZUluZm8ubGVuZ3RofHwoci52YWx1ZUluZm89W10pLHIudmFsdWVJbmZvLnB1c2gobC5vbm54LlZhbHVlSW5mb1Byb3RvLmRlY29kZSh0LHQudWludDMyKCkpKTticmVhaztjYXNlIDE0OnIucXVhbnRpemF0aW9uQW5ub3RhdGlvbiYmci5xdWFudGl6YXRpb25Bbm5vdGF0aW9uLmxlbmd0aHx8KHIucXVhbnRpemF0aW9uQW5ub3RhdGlvbj1bXSksci5xdWFudGl6YXRpb25Bbm5vdGF0aW9uLnB1c2gobC5vbm54LlRlbnNvckFubm90YXRpb24uZGVjb2RlKHQsdC51aW50MzIoKSkpO2JyZWFrO2RlZmF1bHQ6dC5za2lwVHlwZSg3JmkpfX1yZXR1cm4gcn0sdC5kZWNvZGVEZWxpbWl0ZWQ9ZnVuY3Rpb24odCl7cmV0dXJuIHQgaW5zdGFuY2VvZiBzfHwodD1uZXcgcyh0KSksdGhpcy5kZWNvZGUodCx0LnVpbnQzMigpKX0sdC52ZXJpZnk9ZnVuY3Rpb24odCl7aWYoXCJvYmplY3RcIiE9dHlwZW9mIHR8fG51bGw9PT10KXJldHVyblwib2JqZWN0IGV4cGVjdGVkXCI7aWYobnVsbCE9dC5ub2RlJiZ0Lmhhc093blByb3BlcnR5KFwibm9kZVwiKSl7aWYoIUFycmF5LmlzQXJyYXkodC5ub2RlKSlyZXR1cm5cIm5vZGU6IGFycmF5IGV4cGVjdGVkXCI7Zm9yKHZhciBlPTA7ZTx0Lm5vZGUubGVuZ3RoOysrZSlpZihuPWwub25ueC5Ob2RlUHJvdG8udmVyaWZ5KHQubm9kZVtlXSkpcmV0dXJuXCJub2RlLlwiK259aWYobnVsbCE9dC5uYW1lJiZ0Lmhhc093blByb3BlcnR5KFwibmFtZVwiKSYmIWMuaXNTdHJpbmcodC5uYW1lKSlyZXR1cm5cIm5hbWU6IHN0cmluZyBleHBlY3RlZFwiO2lmKG51bGwhPXQuaW5pdGlhbGl6ZXImJnQuaGFzT3duUHJvcGVydHkoXCJpbml0aWFsaXplclwiKSl7aWYoIUFycmF5LmlzQXJyYXkodC5pbml0aWFsaXplcikpcmV0dXJuXCJpbml0aWFsaXplcjogYXJyYXkgZXhwZWN0ZWRcIjtmb3IoZT0wO2U8dC5pbml0aWFsaXplci5sZW5ndGg7KytlKWlmKG49bC5vbm54LlRlbnNvclByb3RvLnZlcmlmeSh0LmluaXRpYWxpemVyW2VdKSlyZXR1cm5cImluaXRpYWxpemVyLlwiK259aWYobnVsbCE9dC5kb2NTdHJpbmcmJnQuaGFzT3duUHJvcGVydHkoXCJkb2NTdHJpbmdcIikmJiFjLmlzU3RyaW5nKHQuZG9jU3RyaW5nKSlyZXR1cm5cImRvY1N0cmluZzogc3RyaW5nIGV4cGVjdGVkXCI7aWYobnVsbCE9dC5pbnB1dCYmdC5oYXNPd25Qcm9wZXJ0eShcImlucHV0XCIpKXtpZighQXJyYXkuaXNBcnJheSh0LmlucHV0KSlyZXR1cm5cImlucHV0OiBhcnJheSBleHBlY3RlZFwiO2ZvcihlPTA7ZTx0LmlucHV0Lmxlbmd0aDsrK2UpaWYobj1sLm9ubnguVmFsdWVJbmZvUHJvdG8udmVyaWZ5KHQuaW5wdXRbZV0pKXJldHVyblwiaW5wdXQuXCIrbn1pZihudWxsIT10Lm91dHB1dCYmdC5oYXNPd25Qcm9wZXJ0eShcIm91dHB1dFwiKSl7aWYoIUFycmF5LmlzQXJyYXkodC5vdXRwdXQpKXJldHVyblwib3V0cHV0OiBhcnJheSBleHBlY3RlZFwiO2ZvcihlPTA7ZTx0Lm91dHB1dC5sZW5ndGg7KytlKWlmKG49bC5vbm54LlZhbHVlSW5mb1Byb3RvLnZlcmlmeSh0Lm91dHB1dFtlXSkpcmV0dXJuXCJvdXRwdXQuXCIrbn1pZihudWxsIT10LnZhbHVlSW5mbyYmdC5oYXNPd25Qcm9wZXJ0eShcInZhbHVlSW5mb1wiKSl7aWYoIUFycmF5LmlzQXJyYXkodC52YWx1ZUluZm8pKXJldHVyblwidmFsdWVJbmZvOiBhcnJheSBleHBlY3RlZFwiO2ZvcihlPTA7ZTx0LnZhbHVlSW5mby5sZW5ndGg7KytlKWlmKG49bC5vbm54LlZhbHVlSW5mb1Byb3RvLnZlcmlmeSh0LnZhbHVlSW5mb1tlXSkpcmV0dXJuXCJ2YWx1ZUluZm8uXCIrbn1pZihudWxsIT10LnF1YW50aXphdGlvbkFubm90YXRpb24mJnQuaGFzT3duUHJvcGVydHkoXCJxdWFudGl6YXRpb25Bbm5vdGF0aW9uXCIpKXtpZighQXJyYXkuaXNBcnJheSh0LnF1YW50aXphdGlvbkFubm90YXRpb24pKXJldHVyblwicXVhbnRpemF0aW9uQW5ub3RhdGlvbjogYXJyYXkgZXhwZWN0ZWRcIjtmb3IoZT0wO2U8dC5xdWFudGl6YXRpb25Bbm5vdGF0aW9uLmxlbmd0aDsrK2Upe3ZhciBuO2lmKG49bC5vbm54LlRlbnNvckFubm90YXRpb24udmVyaWZ5KHQucXVhbnRpemF0aW9uQW5ub3RhdGlvbltlXSkpcmV0dXJuXCJxdWFudGl6YXRpb25Bbm5vdGF0aW9uLlwiK259fXJldHVybiBudWxsfSx0LmZyb21PYmplY3Q9ZnVuY3Rpb24odCl7aWYodCBpbnN0YW5jZW9mIGwub25ueC5HcmFwaFByb3RvKXJldHVybiB0O3ZhciBlPW5ldyBsLm9ubnguR3JhcGhQcm90bztpZih0Lm5vZGUpe2lmKCFBcnJheS5pc0FycmF5KHQubm9kZSkpdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguR3JhcGhQcm90by5ub2RlOiBhcnJheSBleHBlY3RlZFwiKTtlLm5vZGU9W107Zm9yKHZhciBuPTA7bjx0Lm5vZGUubGVuZ3RoOysrbil7aWYoXCJvYmplY3RcIiE9dHlwZW9mIHQubm9kZVtuXSl0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5HcmFwaFByb3RvLm5vZGU6IG9iamVjdCBleHBlY3RlZFwiKTtlLm5vZGVbbl09bC5vbm54Lk5vZGVQcm90by5mcm9tT2JqZWN0KHQubm9kZVtuXSl9fWlmKG51bGwhPXQubmFtZSYmKGUubmFtZT1TdHJpbmcodC5uYW1lKSksdC5pbml0aWFsaXplcil7aWYoIUFycmF5LmlzQXJyYXkodC5pbml0aWFsaXplcikpdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguR3JhcGhQcm90by5pbml0aWFsaXplcjogYXJyYXkgZXhwZWN0ZWRcIik7Zm9yKGUuaW5pdGlhbGl6ZXI9W10sbj0wO248dC5pbml0aWFsaXplci5sZW5ndGg7KytuKXtpZihcIm9iamVjdFwiIT10eXBlb2YgdC5pbml0aWFsaXplcltuXSl0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5HcmFwaFByb3RvLmluaXRpYWxpemVyOiBvYmplY3QgZXhwZWN0ZWRcIik7ZS5pbml0aWFsaXplcltuXT1sLm9ubnguVGVuc29yUHJvdG8uZnJvbU9iamVjdCh0LmluaXRpYWxpemVyW25dKX19aWYobnVsbCE9dC5kb2NTdHJpbmcmJihlLmRvY1N0cmluZz1TdHJpbmcodC5kb2NTdHJpbmcpKSx0LmlucHV0KXtpZighQXJyYXkuaXNBcnJheSh0LmlucHV0KSl0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5HcmFwaFByb3RvLmlucHV0OiBhcnJheSBleHBlY3RlZFwiKTtmb3IoZS5pbnB1dD1bXSxuPTA7bjx0LmlucHV0Lmxlbmd0aDsrK24pe2lmKFwib2JqZWN0XCIhPXR5cGVvZiB0LmlucHV0W25dKXRocm93IFR5cGVFcnJvcihcIi5vbm54LkdyYXBoUHJvdG8uaW5wdXQ6IG9iamVjdCBleHBlY3RlZFwiKTtlLmlucHV0W25dPWwub25ueC5WYWx1ZUluZm9Qcm90by5mcm9tT2JqZWN0KHQuaW5wdXRbbl0pfX1pZih0Lm91dHB1dCl7aWYoIUFycmF5LmlzQXJyYXkodC5vdXRwdXQpKXRocm93IFR5cGVFcnJvcihcIi5vbm54LkdyYXBoUHJvdG8ub3V0cHV0OiBhcnJheSBleHBlY3RlZFwiKTtmb3IoZS5vdXRwdXQ9W10sbj0wO248dC5vdXRwdXQubGVuZ3RoOysrbil7aWYoXCJvYmplY3RcIiE9dHlwZW9mIHQub3V0cHV0W25dKXRocm93IFR5cGVFcnJvcihcIi5vbm54LkdyYXBoUHJvdG8ub3V0cHV0OiBvYmplY3QgZXhwZWN0ZWRcIik7ZS5vdXRwdXRbbl09bC5vbm54LlZhbHVlSW5mb1Byb3RvLmZyb21PYmplY3QodC5vdXRwdXRbbl0pfX1pZih0LnZhbHVlSW5mbyl7aWYoIUFycmF5LmlzQXJyYXkodC52YWx1ZUluZm8pKXRocm93IFR5cGVFcnJvcihcIi5vbm54LkdyYXBoUHJvdG8udmFsdWVJbmZvOiBhcnJheSBleHBlY3RlZFwiKTtmb3IoZS52YWx1ZUluZm89W10sbj0wO248dC52YWx1ZUluZm8ubGVuZ3RoOysrbil7aWYoXCJvYmplY3RcIiE9dHlwZW9mIHQudmFsdWVJbmZvW25dKXRocm93IFR5cGVFcnJvcihcIi5vbm54LkdyYXBoUHJvdG8udmFsdWVJbmZvOiBvYmplY3QgZXhwZWN0ZWRcIik7ZS52YWx1ZUluZm9bbl09bC5vbm54LlZhbHVlSW5mb1Byb3RvLmZyb21PYmplY3QodC52YWx1ZUluZm9bbl0pfX1pZih0LnF1YW50aXphdGlvbkFubm90YXRpb24pe2lmKCFBcnJheS5pc0FycmF5KHQucXVhbnRpemF0aW9uQW5ub3RhdGlvbikpdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguR3JhcGhQcm90by5xdWFudGl6YXRpb25Bbm5vdGF0aW9uOiBhcnJheSBleHBlY3RlZFwiKTtmb3IoZS5xdWFudGl6YXRpb25Bbm5vdGF0aW9uPVtdLG49MDtuPHQucXVhbnRpemF0aW9uQW5ub3RhdGlvbi5sZW5ndGg7KytuKXtpZihcIm9iamVjdFwiIT10eXBlb2YgdC5xdWFudGl6YXRpb25Bbm5vdGF0aW9uW25dKXRocm93IFR5cGVFcnJvcihcIi5vbm54LkdyYXBoUHJvdG8ucXVhbnRpemF0aW9uQW5ub3RhdGlvbjogb2JqZWN0IGV4cGVjdGVkXCIpO2UucXVhbnRpemF0aW9uQW5ub3RhdGlvbltuXT1sLm9ubnguVGVuc29yQW5ub3RhdGlvbi5mcm9tT2JqZWN0KHQucXVhbnRpemF0aW9uQW5ub3RhdGlvbltuXSl9fXJldHVybiBlfSx0LnRvT2JqZWN0PWZ1bmN0aW9uKHQsZSl7ZXx8KGU9e30pO3ZhciBuPXt9O2lmKChlLmFycmF5c3x8ZS5kZWZhdWx0cykmJihuLm5vZGU9W10sbi5pbml0aWFsaXplcj1bXSxuLmlucHV0PVtdLG4ub3V0cHV0PVtdLG4udmFsdWVJbmZvPVtdLG4ucXVhbnRpemF0aW9uQW5ub3RhdGlvbj1bXSksZS5kZWZhdWx0cyYmKG4ubmFtZT1cIlwiLG4uZG9jU3RyaW5nPVwiXCIpLHQubm9kZSYmdC5ub2RlLmxlbmd0aCl7bi5ub2RlPVtdO2Zvcih2YXIgcj0wO3I8dC5ub2RlLmxlbmd0aDsrK3Ipbi5ub2RlW3JdPWwub25ueC5Ob2RlUHJvdG8udG9PYmplY3QodC5ub2RlW3JdLGUpfWlmKG51bGwhPXQubmFtZSYmdC5oYXNPd25Qcm9wZXJ0eShcIm5hbWVcIikmJihuLm5hbWU9dC5uYW1lKSx0LmluaXRpYWxpemVyJiZ0LmluaXRpYWxpemVyLmxlbmd0aClmb3Iobi5pbml0aWFsaXplcj1bXSxyPTA7cjx0LmluaXRpYWxpemVyLmxlbmd0aDsrK3Ipbi5pbml0aWFsaXplcltyXT1sLm9ubnguVGVuc29yUHJvdG8udG9PYmplY3QodC5pbml0aWFsaXplcltyXSxlKTtpZihudWxsIT10LmRvY1N0cmluZyYmdC5oYXNPd25Qcm9wZXJ0eShcImRvY1N0cmluZ1wiKSYmKG4uZG9jU3RyaW5nPXQuZG9jU3RyaW5nKSx0LmlucHV0JiZ0LmlucHV0Lmxlbmd0aClmb3Iobi5pbnB1dD1bXSxyPTA7cjx0LmlucHV0Lmxlbmd0aDsrK3Ipbi5pbnB1dFtyXT1sLm9ubnguVmFsdWVJbmZvUHJvdG8udG9PYmplY3QodC5pbnB1dFtyXSxlKTtpZih0Lm91dHB1dCYmdC5vdXRwdXQubGVuZ3RoKWZvcihuLm91dHB1dD1bXSxyPTA7cjx0Lm91dHB1dC5sZW5ndGg7KytyKW4ub3V0cHV0W3JdPWwub25ueC5WYWx1ZUluZm9Qcm90by50b09iamVjdCh0Lm91dHB1dFtyXSxlKTtpZih0LnZhbHVlSW5mbyYmdC52YWx1ZUluZm8ubGVuZ3RoKWZvcihuLnZhbHVlSW5mbz1bXSxyPTA7cjx0LnZhbHVlSW5mby5sZW5ndGg7KytyKW4udmFsdWVJbmZvW3JdPWwub25ueC5WYWx1ZUluZm9Qcm90by50b09iamVjdCh0LnZhbHVlSW5mb1tyXSxlKTtpZih0LnF1YW50aXphdGlvbkFubm90YXRpb24mJnQucXVhbnRpemF0aW9uQW5ub3RhdGlvbi5sZW5ndGgpZm9yKG4ucXVhbnRpemF0aW9uQW5ub3RhdGlvbj1bXSxyPTA7cjx0LnF1YW50aXphdGlvbkFubm90YXRpb24ubGVuZ3RoOysrciluLnF1YW50aXphdGlvbkFubm90YXRpb25bcl09bC5vbm54LlRlbnNvckFubm90YXRpb24udG9PYmplY3QodC5xdWFudGl6YXRpb25Bbm5vdGF0aW9uW3JdLGUpO3JldHVybiBufSx0LnByb3RvdHlwZS50b0pTT049ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci50b09iamVjdCh0aGlzLGEudXRpbC50b0pTT05PcHRpb25zKX0sdH0oKSxvLlRlbnNvclByb3RvPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0KXtpZih0aGlzLmRpbXM9W10sdGhpcy5mbG9hdERhdGE9W10sdGhpcy5pbnQzMkRhdGE9W10sdGhpcy5zdHJpbmdEYXRhPVtdLHRoaXMuaW50NjREYXRhPVtdLHRoaXMuZXh0ZXJuYWxEYXRhPVtdLHRoaXMuZG91YmxlRGF0YT1bXSx0aGlzLnVpbnQ2NERhdGE9W10sdClmb3IodmFyIGU9T2JqZWN0LmtleXModCksbj0wO248ZS5sZW5ndGg7KytuKW51bGwhPXRbZVtuXV0mJih0aGlzW2Vbbl1dPXRbZVtuXV0pfXJldHVybiB0LnByb3RvdHlwZS5kaW1zPWMuZW1wdHlBcnJheSx0LnByb3RvdHlwZS5kYXRhVHlwZT0wLHQucHJvdG90eXBlLnNlZ21lbnQ9bnVsbCx0LnByb3RvdHlwZS5mbG9hdERhdGE9Yy5lbXB0eUFycmF5LHQucHJvdG90eXBlLmludDMyRGF0YT1jLmVtcHR5QXJyYXksdC5wcm90b3R5cGUuc3RyaW5nRGF0YT1jLmVtcHR5QXJyYXksdC5wcm90b3R5cGUuaW50NjREYXRhPWMuZW1wdHlBcnJheSx0LnByb3RvdHlwZS5uYW1lPVwiXCIsdC5wcm90b3R5cGUuZG9jU3RyaW5nPVwiXCIsdC5wcm90b3R5cGUucmF3RGF0YT1jLm5ld0J1ZmZlcihbXSksdC5wcm90b3R5cGUuZXh0ZXJuYWxEYXRhPWMuZW1wdHlBcnJheSx0LnByb3RvdHlwZS5kYXRhTG9jYXRpb249MCx0LnByb3RvdHlwZS5kb3VibGVEYXRhPWMuZW1wdHlBcnJheSx0LnByb3RvdHlwZS51aW50NjREYXRhPWMuZW1wdHlBcnJheSx0LmNyZWF0ZT1mdW5jdGlvbihlKXtyZXR1cm4gbmV3IHQoZSl9LHQuZW5jb2RlPWZ1bmN0aW9uKHQsZSl7aWYoZXx8KGU9dS5jcmVhdGUoKSksbnVsbCE9dC5kaW1zJiZ0LmRpbXMubGVuZ3RoKXtlLnVpbnQzMigxMCkuZm9yaygpO2Zvcih2YXIgbj0wO248dC5kaW1zLmxlbmd0aDsrK24pZS5pbnQ2NCh0LmRpbXNbbl0pO2UubGRlbGltKCl9aWYobnVsbCE9dC5kYXRhVHlwZSYmdC5oYXNPd25Qcm9wZXJ0eShcImRhdGFUeXBlXCIpJiZlLnVpbnQzMigxNikuaW50MzIodC5kYXRhVHlwZSksbnVsbCE9dC5zZWdtZW50JiZ0Lmhhc093blByb3BlcnR5KFwic2VnbWVudFwiKSYmbC5vbm54LlRlbnNvclByb3RvLlNlZ21lbnQuZW5jb2RlKHQuc2VnbWVudCxlLnVpbnQzMigyNikuZm9yaygpKS5sZGVsaW0oKSxudWxsIT10LmZsb2F0RGF0YSYmdC5mbG9hdERhdGEubGVuZ3RoKXtmb3IoZS51aW50MzIoMzQpLmZvcmsoKSxuPTA7bjx0LmZsb2F0RGF0YS5sZW5ndGg7KytuKWUuZmxvYXQodC5mbG9hdERhdGFbbl0pO2UubGRlbGltKCl9aWYobnVsbCE9dC5pbnQzMkRhdGEmJnQuaW50MzJEYXRhLmxlbmd0aCl7Zm9yKGUudWludDMyKDQyKS5mb3JrKCksbj0wO248dC5pbnQzMkRhdGEubGVuZ3RoOysrbillLmludDMyKHQuaW50MzJEYXRhW25dKTtlLmxkZWxpbSgpfWlmKG51bGwhPXQuc3RyaW5nRGF0YSYmdC5zdHJpbmdEYXRhLmxlbmd0aClmb3Iobj0wO248dC5zdHJpbmdEYXRhLmxlbmd0aDsrK24pZS51aW50MzIoNTApLmJ5dGVzKHQuc3RyaW5nRGF0YVtuXSk7aWYobnVsbCE9dC5pbnQ2NERhdGEmJnQuaW50NjREYXRhLmxlbmd0aCl7Zm9yKGUudWludDMyKDU4KS5mb3JrKCksbj0wO248dC5pbnQ2NERhdGEubGVuZ3RoOysrbillLmludDY0KHQuaW50NjREYXRhW25dKTtlLmxkZWxpbSgpfWlmKG51bGwhPXQubmFtZSYmdC5oYXNPd25Qcm9wZXJ0eShcIm5hbWVcIikmJmUudWludDMyKDY2KS5zdHJpbmcodC5uYW1lKSxudWxsIT10LnJhd0RhdGEmJnQuaGFzT3duUHJvcGVydHkoXCJyYXdEYXRhXCIpJiZlLnVpbnQzMig3NCkuYnl0ZXModC5yYXdEYXRhKSxudWxsIT10LmRvdWJsZURhdGEmJnQuZG91YmxlRGF0YS5sZW5ndGgpe2ZvcihlLnVpbnQzMig4MikuZm9yaygpLG49MDtuPHQuZG91YmxlRGF0YS5sZW5ndGg7KytuKWUuZG91YmxlKHQuZG91YmxlRGF0YVtuXSk7ZS5sZGVsaW0oKX1pZihudWxsIT10LnVpbnQ2NERhdGEmJnQudWludDY0RGF0YS5sZW5ndGgpe2ZvcihlLnVpbnQzMig5MCkuZm9yaygpLG49MDtuPHQudWludDY0RGF0YS5sZW5ndGg7KytuKWUudWludDY0KHQudWludDY0RGF0YVtuXSk7ZS5sZGVsaW0oKX1pZihudWxsIT10LmRvY1N0cmluZyYmdC5oYXNPd25Qcm9wZXJ0eShcImRvY1N0cmluZ1wiKSYmZS51aW50MzIoOTgpLnN0cmluZyh0LmRvY1N0cmluZyksbnVsbCE9dC5leHRlcm5hbERhdGEmJnQuZXh0ZXJuYWxEYXRhLmxlbmd0aClmb3Iobj0wO248dC5leHRlcm5hbERhdGEubGVuZ3RoOysrbilsLm9ubnguU3RyaW5nU3RyaW5nRW50cnlQcm90by5lbmNvZGUodC5leHRlcm5hbERhdGFbbl0sZS51aW50MzIoMTA2KS5mb3JrKCkpLmxkZWxpbSgpO3JldHVybiBudWxsIT10LmRhdGFMb2NhdGlvbiYmdC5oYXNPd25Qcm9wZXJ0eShcImRhdGFMb2NhdGlvblwiKSYmZS51aW50MzIoMTEyKS5pbnQzMih0LmRhdGFMb2NhdGlvbiksZX0sdC5lbmNvZGVEZWxpbWl0ZWQ9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5lbmNvZGUodCxlKS5sZGVsaW0oKX0sdC5kZWNvZGU9ZnVuY3Rpb24odCxlKXt0IGluc3RhbmNlb2Ygc3x8KHQ9cy5jcmVhdGUodCkpO2Zvcih2YXIgbj12b2lkIDA9PT1lP3QubGVuOnQucG9zK2Uscj1uZXcgbC5vbm54LlRlbnNvclByb3RvO3QucG9zPG47KXt2YXIgaT10LnVpbnQzMigpO3N3aXRjaChpPj4+Myl7Y2FzZSAxOmlmKHIuZGltcyYmci5kaW1zLmxlbmd0aHx8KHIuZGltcz1bXSksMj09KDcmaSkpZm9yKHZhciBvPXQudWludDMyKCkrdC5wb3M7dC5wb3M8bzspci5kaW1zLnB1c2godC5pbnQ2NCgpKTtlbHNlIHIuZGltcy5wdXNoKHQuaW50NjQoKSk7YnJlYWs7Y2FzZSAyOnIuZGF0YVR5cGU9dC5pbnQzMigpO2JyZWFrO2Nhc2UgMzpyLnNlZ21lbnQ9bC5vbm54LlRlbnNvclByb3RvLlNlZ21lbnQuZGVjb2RlKHQsdC51aW50MzIoKSk7YnJlYWs7Y2FzZSA0OmlmKHIuZmxvYXREYXRhJiZyLmZsb2F0RGF0YS5sZW5ndGh8fChyLmZsb2F0RGF0YT1bXSksMj09KDcmaSkpZm9yKG89dC51aW50MzIoKSt0LnBvczt0LnBvczxvOylyLmZsb2F0RGF0YS5wdXNoKHQuZmxvYXQoKSk7ZWxzZSByLmZsb2F0RGF0YS5wdXNoKHQuZmxvYXQoKSk7YnJlYWs7Y2FzZSA1OmlmKHIuaW50MzJEYXRhJiZyLmludDMyRGF0YS5sZW5ndGh8fChyLmludDMyRGF0YT1bXSksMj09KDcmaSkpZm9yKG89dC51aW50MzIoKSt0LnBvczt0LnBvczxvOylyLmludDMyRGF0YS5wdXNoKHQuaW50MzIoKSk7ZWxzZSByLmludDMyRGF0YS5wdXNoKHQuaW50MzIoKSk7YnJlYWs7Y2FzZSA2OnIuc3RyaW5nRGF0YSYmci5zdHJpbmdEYXRhLmxlbmd0aHx8KHIuc3RyaW5nRGF0YT1bXSksci5zdHJpbmdEYXRhLnB1c2godC5ieXRlcygpKTticmVhaztjYXNlIDc6aWYoci5pbnQ2NERhdGEmJnIuaW50NjREYXRhLmxlbmd0aHx8KHIuaW50NjREYXRhPVtdKSwyPT0oNyZpKSlmb3Iobz10LnVpbnQzMigpK3QucG9zO3QucG9zPG87KXIuaW50NjREYXRhLnB1c2godC5pbnQ2NCgpKTtlbHNlIHIuaW50NjREYXRhLnB1c2godC5pbnQ2NCgpKTticmVhaztjYXNlIDg6ci5uYW1lPXQuc3RyaW5nKCk7YnJlYWs7Y2FzZSAxMjpyLmRvY1N0cmluZz10LnN0cmluZygpO2JyZWFrO2Nhc2UgOTpyLnJhd0RhdGE9dC5ieXRlcygpO2JyZWFrO2Nhc2UgMTM6ci5leHRlcm5hbERhdGEmJnIuZXh0ZXJuYWxEYXRhLmxlbmd0aHx8KHIuZXh0ZXJuYWxEYXRhPVtdKSxyLmV4dGVybmFsRGF0YS5wdXNoKGwub25ueC5TdHJpbmdTdHJpbmdFbnRyeVByb3RvLmRlY29kZSh0LHQudWludDMyKCkpKTticmVhaztjYXNlIDE0OnIuZGF0YUxvY2F0aW9uPXQuaW50MzIoKTticmVhaztjYXNlIDEwOmlmKHIuZG91YmxlRGF0YSYmci5kb3VibGVEYXRhLmxlbmd0aHx8KHIuZG91YmxlRGF0YT1bXSksMj09KDcmaSkpZm9yKG89dC51aW50MzIoKSt0LnBvczt0LnBvczxvOylyLmRvdWJsZURhdGEucHVzaCh0LmRvdWJsZSgpKTtlbHNlIHIuZG91YmxlRGF0YS5wdXNoKHQuZG91YmxlKCkpO2JyZWFrO2Nhc2UgMTE6aWYoci51aW50NjREYXRhJiZyLnVpbnQ2NERhdGEubGVuZ3RofHwoci51aW50NjREYXRhPVtdKSwyPT0oNyZpKSlmb3Iobz10LnVpbnQzMigpK3QucG9zO3QucG9zPG87KXIudWludDY0RGF0YS5wdXNoKHQudWludDY0KCkpO2Vsc2Ugci51aW50NjREYXRhLnB1c2godC51aW50NjQoKSk7YnJlYWs7ZGVmYXVsdDp0LnNraXBUeXBlKDcmaSl9fXJldHVybiByfSx0LmRlY29kZURlbGltaXRlZD1mdW5jdGlvbih0KXtyZXR1cm4gdCBpbnN0YW5jZW9mIHN8fCh0PW5ldyBzKHQpKSx0aGlzLmRlY29kZSh0LHQudWludDMyKCkpfSx0LnZlcmlmeT1mdW5jdGlvbih0KXtpZihcIm9iamVjdFwiIT10eXBlb2YgdHx8bnVsbD09PXQpcmV0dXJuXCJvYmplY3QgZXhwZWN0ZWRcIjtpZihudWxsIT10LmRpbXMmJnQuaGFzT3duUHJvcGVydHkoXCJkaW1zXCIpKXtpZighQXJyYXkuaXNBcnJheSh0LmRpbXMpKXJldHVyblwiZGltczogYXJyYXkgZXhwZWN0ZWRcIjtmb3IodmFyIGU9MDtlPHQuZGltcy5sZW5ndGg7KytlKWlmKCEoYy5pc0ludGVnZXIodC5kaW1zW2VdKXx8dC5kaW1zW2VdJiZjLmlzSW50ZWdlcih0LmRpbXNbZV0ubG93KSYmYy5pc0ludGVnZXIodC5kaW1zW2VdLmhpZ2gpKSlyZXR1cm5cImRpbXM6IGludGVnZXJ8TG9uZ1tdIGV4cGVjdGVkXCJ9aWYobnVsbCE9dC5kYXRhVHlwZSYmdC5oYXNPd25Qcm9wZXJ0eShcImRhdGFUeXBlXCIpJiYhYy5pc0ludGVnZXIodC5kYXRhVHlwZSkpcmV0dXJuXCJkYXRhVHlwZTogaW50ZWdlciBleHBlY3RlZFwiO2lmKG51bGwhPXQuc2VnbWVudCYmdC5oYXNPd25Qcm9wZXJ0eShcInNlZ21lbnRcIikmJihuPWwub25ueC5UZW5zb3JQcm90by5TZWdtZW50LnZlcmlmeSh0LnNlZ21lbnQpKSlyZXR1cm5cInNlZ21lbnQuXCIrbjtpZihudWxsIT10LmZsb2F0RGF0YSYmdC5oYXNPd25Qcm9wZXJ0eShcImZsb2F0RGF0YVwiKSl7aWYoIUFycmF5LmlzQXJyYXkodC5mbG9hdERhdGEpKXJldHVyblwiZmxvYXREYXRhOiBhcnJheSBleHBlY3RlZFwiO2ZvcihlPTA7ZTx0LmZsb2F0RGF0YS5sZW5ndGg7KytlKWlmKFwibnVtYmVyXCIhPXR5cGVvZiB0LmZsb2F0RGF0YVtlXSlyZXR1cm5cImZsb2F0RGF0YTogbnVtYmVyW10gZXhwZWN0ZWRcIn1pZihudWxsIT10LmludDMyRGF0YSYmdC5oYXNPd25Qcm9wZXJ0eShcImludDMyRGF0YVwiKSl7aWYoIUFycmF5LmlzQXJyYXkodC5pbnQzMkRhdGEpKXJldHVyblwiaW50MzJEYXRhOiBhcnJheSBleHBlY3RlZFwiO2ZvcihlPTA7ZTx0LmludDMyRGF0YS5sZW5ndGg7KytlKWlmKCFjLmlzSW50ZWdlcih0LmludDMyRGF0YVtlXSkpcmV0dXJuXCJpbnQzMkRhdGE6IGludGVnZXJbXSBleHBlY3RlZFwifWlmKG51bGwhPXQuc3RyaW5nRGF0YSYmdC5oYXNPd25Qcm9wZXJ0eShcInN0cmluZ0RhdGFcIikpe2lmKCFBcnJheS5pc0FycmF5KHQuc3RyaW5nRGF0YSkpcmV0dXJuXCJzdHJpbmdEYXRhOiBhcnJheSBleHBlY3RlZFwiO2ZvcihlPTA7ZTx0LnN0cmluZ0RhdGEubGVuZ3RoOysrZSlpZighKHQuc3RyaW5nRGF0YVtlXSYmXCJudW1iZXJcIj09dHlwZW9mIHQuc3RyaW5nRGF0YVtlXS5sZW5ndGh8fGMuaXNTdHJpbmcodC5zdHJpbmdEYXRhW2VdKSkpcmV0dXJuXCJzdHJpbmdEYXRhOiBidWZmZXJbXSBleHBlY3RlZFwifWlmKG51bGwhPXQuaW50NjREYXRhJiZ0Lmhhc093blByb3BlcnR5KFwiaW50NjREYXRhXCIpKXtpZighQXJyYXkuaXNBcnJheSh0LmludDY0RGF0YSkpcmV0dXJuXCJpbnQ2NERhdGE6IGFycmF5IGV4cGVjdGVkXCI7Zm9yKGU9MDtlPHQuaW50NjREYXRhLmxlbmd0aDsrK2UpaWYoIShjLmlzSW50ZWdlcih0LmludDY0RGF0YVtlXSl8fHQuaW50NjREYXRhW2VdJiZjLmlzSW50ZWdlcih0LmludDY0RGF0YVtlXS5sb3cpJiZjLmlzSW50ZWdlcih0LmludDY0RGF0YVtlXS5oaWdoKSkpcmV0dXJuXCJpbnQ2NERhdGE6IGludGVnZXJ8TG9uZ1tdIGV4cGVjdGVkXCJ9aWYobnVsbCE9dC5uYW1lJiZ0Lmhhc093blByb3BlcnR5KFwibmFtZVwiKSYmIWMuaXNTdHJpbmcodC5uYW1lKSlyZXR1cm5cIm5hbWU6IHN0cmluZyBleHBlY3RlZFwiO2lmKG51bGwhPXQuZG9jU3RyaW5nJiZ0Lmhhc093blByb3BlcnR5KFwiZG9jU3RyaW5nXCIpJiYhYy5pc1N0cmluZyh0LmRvY1N0cmluZykpcmV0dXJuXCJkb2NTdHJpbmc6IHN0cmluZyBleHBlY3RlZFwiO2lmKG51bGwhPXQucmF3RGF0YSYmdC5oYXNPd25Qcm9wZXJ0eShcInJhd0RhdGFcIikmJiEodC5yYXdEYXRhJiZcIm51bWJlclwiPT10eXBlb2YgdC5yYXdEYXRhLmxlbmd0aHx8Yy5pc1N0cmluZyh0LnJhd0RhdGEpKSlyZXR1cm5cInJhd0RhdGE6IGJ1ZmZlciBleHBlY3RlZFwiO2lmKG51bGwhPXQuZXh0ZXJuYWxEYXRhJiZ0Lmhhc093blByb3BlcnR5KFwiZXh0ZXJuYWxEYXRhXCIpKXtpZighQXJyYXkuaXNBcnJheSh0LmV4dGVybmFsRGF0YSkpcmV0dXJuXCJleHRlcm5hbERhdGE6IGFycmF5IGV4cGVjdGVkXCI7Zm9yKGU9MDtlPHQuZXh0ZXJuYWxEYXRhLmxlbmd0aDsrK2Upe3ZhciBuO2lmKG49bC5vbm54LlN0cmluZ1N0cmluZ0VudHJ5UHJvdG8udmVyaWZ5KHQuZXh0ZXJuYWxEYXRhW2VdKSlyZXR1cm5cImV4dGVybmFsRGF0YS5cIitufX1pZihudWxsIT10LmRhdGFMb2NhdGlvbiYmdC5oYXNPd25Qcm9wZXJ0eShcImRhdGFMb2NhdGlvblwiKSlzd2l0Y2godC5kYXRhTG9jYXRpb24pe2RlZmF1bHQ6cmV0dXJuXCJkYXRhTG9jYXRpb246IGVudW0gdmFsdWUgZXhwZWN0ZWRcIjtjYXNlIDA6Y2FzZSAxOn1pZihudWxsIT10LmRvdWJsZURhdGEmJnQuaGFzT3duUHJvcGVydHkoXCJkb3VibGVEYXRhXCIpKXtpZighQXJyYXkuaXNBcnJheSh0LmRvdWJsZURhdGEpKXJldHVyblwiZG91YmxlRGF0YTogYXJyYXkgZXhwZWN0ZWRcIjtmb3IoZT0wO2U8dC5kb3VibGVEYXRhLmxlbmd0aDsrK2UpaWYoXCJudW1iZXJcIiE9dHlwZW9mIHQuZG91YmxlRGF0YVtlXSlyZXR1cm5cImRvdWJsZURhdGE6IG51bWJlcltdIGV4cGVjdGVkXCJ9aWYobnVsbCE9dC51aW50NjREYXRhJiZ0Lmhhc093blByb3BlcnR5KFwidWludDY0RGF0YVwiKSl7aWYoIUFycmF5LmlzQXJyYXkodC51aW50NjREYXRhKSlyZXR1cm5cInVpbnQ2NERhdGE6IGFycmF5IGV4cGVjdGVkXCI7Zm9yKGU9MDtlPHQudWludDY0RGF0YS5sZW5ndGg7KytlKWlmKCEoYy5pc0ludGVnZXIodC51aW50NjREYXRhW2VdKXx8dC51aW50NjREYXRhW2VdJiZjLmlzSW50ZWdlcih0LnVpbnQ2NERhdGFbZV0ubG93KSYmYy5pc0ludGVnZXIodC51aW50NjREYXRhW2VdLmhpZ2gpKSlyZXR1cm5cInVpbnQ2NERhdGE6IGludGVnZXJ8TG9uZ1tdIGV4cGVjdGVkXCJ9cmV0dXJuIG51bGx9LHQuZnJvbU9iamVjdD1mdW5jdGlvbih0KXtpZih0IGluc3RhbmNlb2YgbC5vbm54LlRlbnNvclByb3RvKXJldHVybiB0O3ZhciBlPW5ldyBsLm9ubnguVGVuc29yUHJvdG87aWYodC5kaW1zKXtpZighQXJyYXkuaXNBcnJheSh0LmRpbXMpKXRocm93IFR5cGVFcnJvcihcIi5vbm54LlRlbnNvclByb3RvLmRpbXM6IGFycmF5IGV4cGVjdGVkXCIpO2UuZGltcz1bXTtmb3IodmFyIG49MDtuPHQuZGltcy5sZW5ndGg7KytuKWMuTG9uZz8oZS5kaW1zW25dPWMuTG9uZy5mcm9tVmFsdWUodC5kaW1zW25dKSkudW5zaWduZWQ9ITE6XCJzdHJpbmdcIj09dHlwZW9mIHQuZGltc1tuXT9lLmRpbXNbbl09cGFyc2VJbnQodC5kaW1zW25dLDEwKTpcIm51bWJlclwiPT10eXBlb2YgdC5kaW1zW25dP2UuZGltc1tuXT10LmRpbXNbbl06XCJvYmplY3RcIj09dHlwZW9mIHQuZGltc1tuXSYmKGUuZGltc1tuXT1uZXcgYy5Mb25nQml0cyh0LmRpbXNbbl0ubG93Pj4+MCx0LmRpbXNbbl0uaGlnaD4+PjApLnRvTnVtYmVyKCkpfWlmKG51bGwhPXQuZGF0YVR5cGUmJihlLmRhdGFUeXBlPTB8dC5kYXRhVHlwZSksbnVsbCE9dC5zZWdtZW50KXtpZihcIm9iamVjdFwiIT10eXBlb2YgdC5zZWdtZW50KXRocm93IFR5cGVFcnJvcihcIi5vbm54LlRlbnNvclByb3RvLnNlZ21lbnQ6IG9iamVjdCBleHBlY3RlZFwiKTtlLnNlZ21lbnQ9bC5vbm54LlRlbnNvclByb3RvLlNlZ21lbnQuZnJvbU9iamVjdCh0LnNlZ21lbnQpfWlmKHQuZmxvYXREYXRhKXtpZighQXJyYXkuaXNBcnJheSh0LmZsb2F0RGF0YSkpdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguVGVuc29yUHJvdG8uZmxvYXREYXRhOiBhcnJheSBleHBlY3RlZFwiKTtmb3IoZS5mbG9hdERhdGE9W10sbj0wO248dC5mbG9hdERhdGEubGVuZ3RoOysrbillLmZsb2F0RGF0YVtuXT1OdW1iZXIodC5mbG9hdERhdGFbbl0pfWlmKHQuaW50MzJEYXRhKXtpZighQXJyYXkuaXNBcnJheSh0LmludDMyRGF0YSkpdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguVGVuc29yUHJvdG8uaW50MzJEYXRhOiBhcnJheSBleHBlY3RlZFwiKTtmb3IoZS5pbnQzMkRhdGE9W10sbj0wO248dC5pbnQzMkRhdGEubGVuZ3RoOysrbillLmludDMyRGF0YVtuXT0wfHQuaW50MzJEYXRhW25dfWlmKHQuc3RyaW5nRGF0YSl7aWYoIUFycmF5LmlzQXJyYXkodC5zdHJpbmdEYXRhKSl0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5UZW5zb3JQcm90by5zdHJpbmdEYXRhOiBhcnJheSBleHBlY3RlZFwiKTtmb3IoZS5zdHJpbmdEYXRhPVtdLG49MDtuPHQuc3RyaW5nRGF0YS5sZW5ndGg7KytuKVwic3RyaW5nXCI9PXR5cGVvZiB0LnN0cmluZ0RhdGFbbl0/Yy5iYXNlNjQuZGVjb2RlKHQuc3RyaW5nRGF0YVtuXSxlLnN0cmluZ0RhdGFbbl09Yy5uZXdCdWZmZXIoYy5iYXNlNjQubGVuZ3RoKHQuc3RyaW5nRGF0YVtuXSkpLDApOnQuc3RyaW5nRGF0YVtuXS5sZW5ndGgmJihlLnN0cmluZ0RhdGFbbl09dC5zdHJpbmdEYXRhW25dKX1pZih0LmludDY0RGF0YSl7aWYoIUFycmF5LmlzQXJyYXkodC5pbnQ2NERhdGEpKXRocm93IFR5cGVFcnJvcihcIi5vbm54LlRlbnNvclByb3RvLmludDY0RGF0YTogYXJyYXkgZXhwZWN0ZWRcIik7Zm9yKGUuaW50NjREYXRhPVtdLG49MDtuPHQuaW50NjREYXRhLmxlbmd0aDsrK24pYy5Mb25nPyhlLmludDY0RGF0YVtuXT1jLkxvbmcuZnJvbVZhbHVlKHQuaW50NjREYXRhW25dKSkudW5zaWduZWQ9ITE6XCJzdHJpbmdcIj09dHlwZW9mIHQuaW50NjREYXRhW25dP2UuaW50NjREYXRhW25dPXBhcnNlSW50KHQuaW50NjREYXRhW25dLDEwKTpcIm51bWJlclwiPT10eXBlb2YgdC5pbnQ2NERhdGFbbl0/ZS5pbnQ2NERhdGFbbl09dC5pbnQ2NERhdGFbbl06XCJvYmplY3RcIj09dHlwZW9mIHQuaW50NjREYXRhW25dJiYoZS5pbnQ2NERhdGFbbl09bmV3IGMuTG9uZ0JpdHModC5pbnQ2NERhdGFbbl0ubG93Pj4+MCx0LmludDY0RGF0YVtuXS5oaWdoPj4+MCkudG9OdW1iZXIoKSl9aWYobnVsbCE9dC5uYW1lJiYoZS5uYW1lPVN0cmluZyh0Lm5hbWUpKSxudWxsIT10LmRvY1N0cmluZyYmKGUuZG9jU3RyaW5nPVN0cmluZyh0LmRvY1N0cmluZykpLG51bGwhPXQucmF3RGF0YSYmKFwic3RyaW5nXCI9PXR5cGVvZiB0LnJhd0RhdGE/Yy5iYXNlNjQuZGVjb2RlKHQucmF3RGF0YSxlLnJhd0RhdGE9Yy5uZXdCdWZmZXIoYy5iYXNlNjQubGVuZ3RoKHQucmF3RGF0YSkpLDApOnQucmF3RGF0YS5sZW5ndGgmJihlLnJhd0RhdGE9dC5yYXdEYXRhKSksdC5leHRlcm5hbERhdGEpe2lmKCFBcnJheS5pc0FycmF5KHQuZXh0ZXJuYWxEYXRhKSl0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5UZW5zb3JQcm90by5leHRlcm5hbERhdGE6IGFycmF5IGV4cGVjdGVkXCIpO2ZvcihlLmV4dGVybmFsRGF0YT1bXSxuPTA7bjx0LmV4dGVybmFsRGF0YS5sZW5ndGg7KytuKXtpZihcIm9iamVjdFwiIT10eXBlb2YgdC5leHRlcm5hbERhdGFbbl0pdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguVGVuc29yUHJvdG8uZXh0ZXJuYWxEYXRhOiBvYmplY3QgZXhwZWN0ZWRcIik7ZS5leHRlcm5hbERhdGFbbl09bC5vbm54LlN0cmluZ1N0cmluZ0VudHJ5UHJvdG8uZnJvbU9iamVjdCh0LmV4dGVybmFsRGF0YVtuXSl9fXN3aXRjaCh0LmRhdGFMb2NhdGlvbil7Y2FzZVwiREVGQVVMVFwiOmNhc2UgMDplLmRhdGFMb2NhdGlvbj0wO2JyZWFrO2Nhc2VcIkVYVEVSTkFMXCI6Y2FzZSAxOmUuZGF0YUxvY2F0aW9uPTF9aWYodC5kb3VibGVEYXRhKXtpZighQXJyYXkuaXNBcnJheSh0LmRvdWJsZURhdGEpKXRocm93IFR5cGVFcnJvcihcIi5vbm54LlRlbnNvclByb3RvLmRvdWJsZURhdGE6IGFycmF5IGV4cGVjdGVkXCIpO2ZvcihlLmRvdWJsZURhdGE9W10sbj0wO248dC5kb3VibGVEYXRhLmxlbmd0aDsrK24pZS5kb3VibGVEYXRhW25dPU51bWJlcih0LmRvdWJsZURhdGFbbl0pfWlmKHQudWludDY0RGF0YSl7aWYoIUFycmF5LmlzQXJyYXkodC51aW50NjREYXRhKSl0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5UZW5zb3JQcm90by51aW50NjREYXRhOiBhcnJheSBleHBlY3RlZFwiKTtmb3IoZS51aW50NjREYXRhPVtdLG49MDtuPHQudWludDY0RGF0YS5sZW5ndGg7KytuKWMuTG9uZz8oZS51aW50NjREYXRhW25dPWMuTG9uZy5mcm9tVmFsdWUodC51aW50NjREYXRhW25dKSkudW5zaWduZWQ9ITA6XCJzdHJpbmdcIj09dHlwZW9mIHQudWludDY0RGF0YVtuXT9lLnVpbnQ2NERhdGFbbl09cGFyc2VJbnQodC51aW50NjREYXRhW25dLDEwKTpcIm51bWJlclwiPT10eXBlb2YgdC51aW50NjREYXRhW25dP2UudWludDY0RGF0YVtuXT10LnVpbnQ2NERhdGFbbl06XCJvYmplY3RcIj09dHlwZW9mIHQudWludDY0RGF0YVtuXSYmKGUudWludDY0RGF0YVtuXT1uZXcgYy5Mb25nQml0cyh0LnVpbnQ2NERhdGFbbl0ubG93Pj4+MCx0LnVpbnQ2NERhdGFbbl0uaGlnaD4+PjApLnRvTnVtYmVyKCEwKSl9cmV0dXJuIGV9LHQudG9PYmplY3Q9ZnVuY3Rpb24odCxlKXtlfHwoZT17fSk7dmFyIG49e307aWYoKGUuYXJyYXlzfHxlLmRlZmF1bHRzKSYmKG4uZGltcz1bXSxuLmZsb2F0RGF0YT1bXSxuLmludDMyRGF0YT1bXSxuLnN0cmluZ0RhdGE9W10sbi5pbnQ2NERhdGE9W10sbi5kb3VibGVEYXRhPVtdLG4udWludDY0RGF0YT1bXSxuLmV4dGVybmFsRGF0YT1bXSksZS5kZWZhdWx0cyYmKG4uZGF0YVR5cGU9MCxuLnNlZ21lbnQ9bnVsbCxuLm5hbWU9XCJcIixlLmJ5dGVzPT09U3RyaW5nP24ucmF3RGF0YT1cIlwiOihuLnJhd0RhdGE9W10sZS5ieXRlcyE9PUFycmF5JiYobi5yYXdEYXRhPWMubmV3QnVmZmVyKG4ucmF3RGF0YSkpKSxuLmRvY1N0cmluZz1cIlwiLG4uZGF0YUxvY2F0aW9uPWUuZW51bXM9PT1TdHJpbmc/XCJERUZBVUxUXCI6MCksdC5kaW1zJiZ0LmRpbXMubGVuZ3RoKXtuLmRpbXM9W107Zm9yKHZhciByPTA7cjx0LmRpbXMubGVuZ3RoOysrcilcIm51bWJlclwiPT10eXBlb2YgdC5kaW1zW3JdP24uZGltc1tyXT1lLmxvbmdzPT09U3RyaW5nP1N0cmluZyh0LmRpbXNbcl0pOnQuZGltc1tyXTpuLmRpbXNbcl09ZS5sb25ncz09PVN0cmluZz9jLkxvbmcucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodC5kaW1zW3JdKTplLmxvbmdzPT09TnVtYmVyP25ldyBjLkxvbmdCaXRzKHQuZGltc1tyXS5sb3c+Pj4wLHQuZGltc1tyXS5oaWdoPj4+MCkudG9OdW1iZXIoKTp0LmRpbXNbcl19aWYobnVsbCE9dC5kYXRhVHlwZSYmdC5oYXNPd25Qcm9wZXJ0eShcImRhdGFUeXBlXCIpJiYobi5kYXRhVHlwZT10LmRhdGFUeXBlKSxudWxsIT10LnNlZ21lbnQmJnQuaGFzT3duUHJvcGVydHkoXCJzZWdtZW50XCIpJiYobi5zZWdtZW50PWwub25ueC5UZW5zb3JQcm90by5TZWdtZW50LnRvT2JqZWN0KHQuc2VnbWVudCxlKSksdC5mbG9hdERhdGEmJnQuZmxvYXREYXRhLmxlbmd0aClmb3Iobi5mbG9hdERhdGE9W10scj0wO3I8dC5mbG9hdERhdGEubGVuZ3RoOysrciluLmZsb2F0RGF0YVtyXT1lLmpzb24mJiFpc0Zpbml0ZSh0LmZsb2F0RGF0YVtyXSk/U3RyaW5nKHQuZmxvYXREYXRhW3JdKTp0LmZsb2F0RGF0YVtyXTtpZih0LmludDMyRGF0YSYmdC5pbnQzMkRhdGEubGVuZ3RoKWZvcihuLmludDMyRGF0YT1bXSxyPTA7cjx0LmludDMyRGF0YS5sZW5ndGg7KytyKW4uaW50MzJEYXRhW3JdPXQuaW50MzJEYXRhW3JdO2lmKHQuc3RyaW5nRGF0YSYmdC5zdHJpbmdEYXRhLmxlbmd0aClmb3Iobi5zdHJpbmdEYXRhPVtdLHI9MDtyPHQuc3RyaW5nRGF0YS5sZW5ndGg7KytyKW4uc3RyaW5nRGF0YVtyXT1lLmJ5dGVzPT09U3RyaW5nP2MuYmFzZTY0LmVuY29kZSh0LnN0cmluZ0RhdGFbcl0sMCx0LnN0cmluZ0RhdGFbcl0ubGVuZ3RoKTplLmJ5dGVzPT09QXJyYXk/QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodC5zdHJpbmdEYXRhW3JdKTp0LnN0cmluZ0RhdGFbcl07aWYodC5pbnQ2NERhdGEmJnQuaW50NjREYXRhLmxlbmd0aClmb3Iobi5pbnQ2NERhdGE9W10scj0wO3I8dC5pbnQ2NERhdGEubGVuZ3RoOysrcilcIm51bWJlclwiPT10eXBlb2YgdC5pbnQ2NERhdGFbcl0/bi5pbnQ2NERhdGFbcl09ZS5sb25ncz09PVN0cmluZz9TdHJpbmcodC5pbnQ2NERhdGFbcl0pOnQuaW50NjREYXRhW3JdOm4uaW50NjREYXRhW3JdPWUubG9uZ3M9PT1TdHJpbmc/Yy5Mb25nLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHQuaW50NjREYXRhW3JdKTplLmxvbmdzPT09TnVtYmVyP25ldyBjLkxvbmdCaXRzKHQuaW50NjREYXRhW3JdLmxvdz4+PjAsdC5pbnQ2NERhdGFbcl0uaGlnaD4+PjApLnRvTnVtYmVyKCk6dC5pbnQ2NERhdGFbcl07aWYobnVsbCE9dC5uYW1lJiZ0Lmhhc093blByb3BlcnR5KFwibmFtZVwiKSYmKG4ubmFtZT10Lm5hbWUpLG51bGwhPXQucmF3RGF0YSYmdC5oYXNPd25Qcm9wZXJ0eShcInJhd0RhdGFcIikmJihuLnJhd0RhdGE9ZS5ieXRlcz09PVN0cmluZz9jLmJhc2U2NC5lbmNvZGUodC5yYXdEYXRhLDAsdC5yYXdEYXRhLmxlbmd0aCk6ZS5ieXRlcz09PUFycmF5P0FycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHQucmF3RGF0YSk6dC5yYXdEYXRhKSx0LmRvdWJsZURhdGEmJnQuZG91YmxlRGF0YS5sZW5ndGgpZm9yKG4uZG91YmxlRGF0YT1bXSxyPTA7cjx0LmRvdWJsZURhdGEubGVuZ3RoOysrciluLmRvdWJsZURhdGFbcl09ZS5qc29uJiYhaXNGaW5pdGUodC5kb3VibGVEYXRhW3JdKT9TdHJpbmcodC5kb3VibGVEYXRhW3JdKTp0LmRvdWJsZURhdGFbcl07aWYodC51aW50NjREYXRhJiZ0LnVpbnQ2NERhdGEubGVuZ3RoKWZvcihuLnVpbnQ2NERhdGE9W10scj0wO3I8dC51aW50NjREYXRhLmxlbmd0aDsrK3IpXCJudW1iZXJcIj09dHlwZW9mIHQudWludDY0RGF0YVtyXT9uLnVpbnQ2NERhdGFbcl09ZS5sb25ncz09PVN0cmluZz9TdHJpbmcodC51aW50NjREYXRhW3JdKTp0LnVpbnQ2NERhdGFbcl06bi51aW50NjREYXRhW3JdPWUubG9uZ3M9PT1TdHJpbmc/Yy5Mb25nLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHQudWludDY0RGF0YVtyXSk6ZS5sb25ncz09PU51bWJlcj9uZXcgYy5Mb25nQml0cyh0LnVpbnQ2NERhdGFbcl0ubG93Pj4+MCx0LnVpbnQ2NERhdGFbcl0uaGlnaD4+PjApLnRvTnVtYmVyKCEwKTp0LnVpbnQ2NERhdGFbcl07aWYobnVsbCE9dC5kb2NTdHJpbmcmJnQuaGFzT3duUHJvcGVydHkoXCJkb2NTdHJpbmdcIikmJihuLmRvY1N0cmluZz10LmRvY1N0cmluZyksdC5leHRlcm5hbERhdGEmJnQuZXh0ZXJuYWxEYXRhLmxlbmd0aClmb3Iobi5leHRlcm5hbERhdGE9W10scj0wO3I8dC5leHRlcm5hbERhdGEubGVuZ3RoOysrciluLmV4dGVybmFsRGF0YVtyXT1sLm9ubnguU3RyaW5nU3RyaW5nRW50cnlQcm90by50b09iamVjdCh0LmV4dGVybmFsRGF0YVtyXSxlKTtyZXR1cm4gbnVsbCE9dC5kYXRhTG9jYXRpb24mJnQuaGFzT3duUHJvcGVydHkoXCJkYXRhTG9jYXRpb25cIikmJihuLmRhdGFMb2NhdGlvbj1lLmVudW1zPT09U3RyaW5nP2wub25ueC5UZW5zb3JQcm90by5EYXRhTG9jYXRpb25bdC5kYXRhTG9jYXRpb25dOnQuZGF0YUxvY2F0aW9uKSxufSx0LnByb3RvdHlwZS50b0pTT049ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci50b09iamVjdCh0aGlzLGEudXRpbC50b0pTT05PcHRpb25zKX0sdC5EYXRhVHlwZT1mdW5jdGlvbigpe3ZhciB0PXt9LGU9T2JqZWN0LmNyZWF0ZSh0KTtyZXR1cm4gZVt0WzBdPVwiVU5ERUZJTkVEXCJdPTAsZVt0WzFdPVwiRkxPQVRcIl09MSxlW3RbMl09XCJVSU5UOFwiXT0yLGVbdFszXT1cIklOVDhcIl09MyxlW3RbNF09XCJVSU5UMTZcIl09NCxlW3RbNV09XCJJTlQxNlwiXT01LGVbdFs2XT1cIklOVDMyXCJdPTYsZVt0WzddPVwiSU5UNjRcIl09NyxlW3RbOF09XCJTVFJJTkdcIl09OCxlW3RbOV09XCJCT09MXCJdPTksZVt0WzEwXT1cIkZMT0FUMTZcIl09MTAsZVt0WzExXT1cIkRPVUJMRVwiXT0xMSxlW3RbMTJdPVwiVUlOVDMyXCJdPTEyLGVbdFsxM109XCJVSU5UNjRcIl09MTMsZVt0WzE0XT1cIkNPTVBMRVg2NFwiXT0xNCxlW3RbMTVdPVwiQ09NUExFWDEyOFwiXT0xNSxlW3RbMTZdPVwiQkZMT0FUMTZcIl09MTYsZX0oKSx0LlNlZ21lbnQ9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQpe2lmKHQpZm9yKHZhciBlPU9iamVjdC5rZXlzKHQpLG49MDtuPGUubGVuZ3RoOysrbiludWxsIT10W2Vbbl1dJiYodGhpc1tlW25dXT10W2Vbbl1dKX1yZXR1cm4gdC5wcm90b3R5cGUuYmVnaW49Yy5Mb25nP2MuTG9uZy5mcm9tQml0cygwLDAsITEpOjAsdC5wcm90b3R5cGUuZW5kPWMuTG9uZz9jLkxvbmcuZnJvbUJpdHMoMCwwLCExKTowLHQuY3JlYXRlPWZ1bmN0aW9uKGUpe3JldHVybiBuZXcgdChlKX0sdC5lbmNvZGU9ZnVuY3Rpb24odCxlKXtyZXR1cm4gZXx8KGU9dS5jcmVhdGUoKSksbnVsbCE9dC5iZWdpbiYmdC5oYXNPd25Qcm9wZXJ0eShcImJlZ2luXCIpJiZlLnVpbnQzMig4KS5pbnQ2NCh0LmJlZ2luKSxudWxsIT10LmVuZCYmdC5oYXNPd25Qcm9wZXJ0eShcImVuZFwiKSYmZS51aW50MzIoMTYpLmludDY0KHQuZW5kKSxlfSx0LmVuY29kZURlbGltaXRlZD1mdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLmVuY29kZSh0LGUpLmxkZWxpbSgpfSx0LmRlY29kZT1mdW5jdGlvbih0LGUpe3QgaW5zdGFuY2VvZiBzfHwodD1zLmNyZWF0ZSh0KSk7Zm9yKHZhciBuPXZvaWQgMD09PWU/dC5sZW46dC5wb3MrZSxyPW5ldyBsLm9ubnguVGVuc29yUHJvdG8uU2VnbWVudDt0LnBvczxuOyl7dmFyIGk9dC51aW50MzIoKTtzd2l0Y2goaT4+PjMpe2Nhc2UgMTpyLmJlZ2luPXQuaW50NjQoKTticmVhaztjYXNlIDI6ci5lbmQ9dC5pbnQ2NCgpO2JyZWFrO2RlZmF1bHQ6dC5za2lwVHlwZSg3JmkpfX1yZXR1cm4gcn0sdC5kZWNvZGVEZWxpbWl0ZWQ9ZnVuY3Rpb24odCl7cmV0dXJuIHQgaW5zdGFuY2VvZiBzfHwodD1uZXcgcyh0KSksdGhpcy5kZWNvZGUodCx0LnVpbnQzMigpKX0sdC52ZXJpZnk9ZnVuY3Rpb24odCl7cmV0dXJuXCJvYmplY3RcIiE9dHlwZW9mIHR8fG51bGw9PT10P1wib2JqZWN0IGV4cGVjdGVkXCI6bnVsbCE9dC5iZWdpbiYmdC5oYXNPd25Qcm9wZXJ0eShcImJlZ2luXCIpJiYhKGMuaXNJbnRlZ2VyKHQuYmVnaW4pfHx0LmJlZ2luJiZjLmlzSW50ZWdlcih0LmJlZ2luLmxvdykmJmMuaXNJbnRlZ2VyKHQuYmVnaW4uaGlnaCkpP1wiYmVnaW46IGludGVnZXJ8TG9uZyBleHBlY3RlZFwiOm51bGwhPXQuZW5kJiZ0Lmhhc093blByb3BlcnR5KFwiZW5kXCIpJiYhKGMuaXNJbnRlZ2VyKHQuZW5kKXx8dC5lbmQmJmMuaXNJbnRlZ2VyKHQuZW5kLmxvdykmJmMuaXNJbnRlZ2VyKHQuZW5kLmhpZ2gpKT9cImVuZDogaW50ZWdlcnxMb25nIGV4cGVjdGVkXCI6bnVsbH0sdC5mcm9tT2JqZWN0PWZ1bmN0aW9uKHQpe2lmKHQgaW5zdGFuY2VvZiBsLm9ubnguVGVuc29yUHJvdG8uU2VnbWVudClyZXR1cm4gdDt2YXIgZT1uZXcgbC5vbm54LlRlbnNvclByb3RvLlNlZ21lbnQ7cmV0dXJuIG51bGwhPXQuYmVnaW4mJihjLkxvbmc/KGUuYmVnaW49Yy5Mb25nLmZyb21WYWx1ZSh0LmJlZ2luKSkudW5zaWduZWQ9ITE6XCJzdHJpbmdcIj09dHlwZW9mIHQuYmVnaW4/ZS5iZWdpbj1wYXJzZUludCh0LmJlZ2luLDEwKTpcIm51bWJlclwiPT10eXBlb2YgdC5iZWdpbj9lLmJlZ2luPXQuYmVnaW46XCJvYmplY3RcIj09dHlwZW9mIHQuYmVnaW4mJihlLmJlZ2luPW5ldyBjLkxvbmdCaXRzKHQuYmVnaW4ubG93Pj4+MCx0LmJlZ2luLmhpZ2g+Pj4wKS50b051bWJlcigpKSksbnVsbCE9dC5lbmQmJihjLkxvbmc/KGUuZW5kPWMuTG9uZy5mcm9tVmFsdWUodC5lbmQpKS51bnNpZ25lZD0hMTpcInN0cmluZ1wiPT10eXBlb2YgdC5lbmQ/ZS5lbmQ9cGFyc2VJbnQodC5lbmQsMTApOlwibnVtYmVyXCI9PXR5cGVvZiB0LmVuZD9lLmVuZD10LmVuZDpcIm9iamVjdFwiPT10eXBlb2YgdC5lbmQmJihlLmVuZD1uZXcgYy5Mb25nQml0cyh0LmVuZC5sb3c+Pj4wLHQuZW5kLmhpZ2g+Pj4wKS50b051bWJlcigpKSksZX0sdC50b09iamVjdD1mdW5jdGlvbih0LGUpe2V8fChlPXt9KTt2YXIgbj17fTtpZihlLmRlZmF1bHRzKXtpZihjLkxvbmcpe3ZhciByPW5ldyBjLkxvbmcoMCwwLCExKTtuLmJlZ2luPWUubG9uZ3M9PT1TdHJpbmc/ci50b1N0cmluZygpOmUubG9uZ3M9PT1OdW1iZXI/ci50b051bWJlcigpOnJ9ZWxzZSBuLmJlZ2luPWUubG9uZ3M9PT1TdHJpbmc/XCIwXCI6MDtjLkxvbmc/KHI9bmV3IGMuTG9uZygwLDAsITEpLG4uZW5kPWUubG9uZ3M9PT1TdHJpbmc/ci50b1N0cmluZygpOmUubG9uZ3M9PT1OdW1iZXI/ci50b051bWJlcigpOnIpOm4uZW5kPWUubG9uZ3M9PT1TdHJpbmc/XCIwXCI6MH1yZXR1cm4gbnVsbCE9dC5iZWdpbiYmdC5oYXNPd25Qcm9wZXJ0eShcImJlZ2luXCIpJiYoXCJudW1iZXJcIj09dHlwZW9mIHQuYmVnaW4/bi5iZWdpbj1lLmxvbmdzPT09U3RyaW5nP1N0cmluZyh0LmJlZ2luKTp0LmJlZ2luOm4uYmVnaW49ZS5sb25ncz09PVN0cmluZz9jLkxvbmcucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodC5iZWdpbik6ZS5sb25ncz09PU51bWJlcj9uZXcgYy5Mb25nQml0cyh0LmJlZ2luLmxvdz4+PjAsdC5iZWdpbi5oaWdoPj4+MCkudG9OdW1iZXIoKTp0LmJlZ2luKSxudWxsIT10LmVuZCYmdC5oYXNPd25Qcm9wZXJ0eShcImVuZFwiKSYmKFwibnVtYmVyXCI9PXR5cGVvZiB0LmVuZD9uLmVuZD1lLmxvbmdzPT09U3RyaW5nP1N0cmluZyh0LmVuZCk6dC5lbmQ6bi5lbmQ9ZS5sb25ncz09PVN0cmluZz9jLkxvbmcucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodC5lbmQpOmUubG9uZ3M9PT1OdW1iZXI/bmV3IGMuTG9uZ0JpdHModC5lbmQubG93Pj4+MCx0LmVuZC5oaWdoPj4+MCkudG9OdW1iZXIoKTp0LmVuZCksbn0sdC5wcm90b3R5cGUudG9KU09OPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY29uc3RydWN0b3IudG9PYmplY3QodGhpcyxhLnV0aWwudG9KU09OT3B0aW9ucyl9LHR9KCksdC5EYXRhTG9jYXRpb249ZnVuY3Rpb24oKXt2YXIgdD17fSxlPU9iamVjdC5jcmVhdGUodCk7cmV0dXJuIGVbdFswXT1cIkRFRkFVTFRcIl09MCxlW3RbMV09XCJFWFRFUk5BTFwiXT0xLGV9KCksdH0oKSxvLlRlbnNvclNoYXBlUHJvdG89ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQpe2lmKHRoaXMuZGltPVtdLHQpZm9yKHZhciBlPU9iamVjdC5rZXlzKHQpLG49MDtuPGUubGVuZ3RoOysrbiludWxsIT10W2Vbbl1dJiYodGhpc1tlW25dXT10W2Vbbl1dKX1yZXR1cm4gdC5wcm90b3R5cGUuZGltPWMuZW1wdHlBcnJheSx0LmNyZWF0ZT1mdW5jdGlvbihlKXtyZXR1cm4gbmV3IHQoZSl9LHQuZW5jb2RlPWZ1bmN0aW9uKHQsZSl7aWYoZXx8KGU9dS5jcmVhdGUoKSksbnVsbCE9dC5kaW0mJnQuZGltLmxlbmd0aClmb3IodmFyIG49MDtuPHQuZGltLmxlbmd0aDsrK24pbC5vbm54LlRlbnNvclNoYXBlUHJvdG8uRGltZW5zaW9uLmVuY29kZSh0LmRpbVtuXSxlLnVpbnQzMigxMCkuZm9yaygpKS5sZGVsaW0oKTtyZXR1cm4gZX0sdC5lbmNvZGVEZWxpbWl0ZWQ9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5lbmNvZGUodCxlKS5sZGVsaW0oKX0sdC5kZWNvZGU9ZnVuY3Rpb24odCxlKXt0IGluc3RhbmNlb2Ygc3x8KHQ9cy5jcmVhdGUodCkpO2Zvcih2YXIgbj12b2lkIDA9PT1lP3QubGVuOnQucG9zK2Uscj1uZXcgbC5vbm54LlRlbnNvclNoYXBlUHJvdG87dC5wb3M8bjspe3ZhciBpPXQudWludDMyKCk7aT4+PjM9PTE/KHIuZGltJiZyLmRpbS5sZW5ndGh8fChyLmRpbT1bXSksci5kaW0ucHVzaChsLm9ubnguVGVuc29yU2hhcGVQcm90by5EaW1lbnNpb24uZGVjb2RlKHQsdC51aW50MzIoKSkpKTp0LnNraXBUeXBlKDcmaSl9cmV0dXJuIHJ9LHQuZGVjb2RlRGVsaW1pdGVkPWZ1bmN0aW9uKHQpe3JldHVybiB0IGluc3RhbmNlb2Ygc3x8KHQ9bmV3IHModCkpLHRoaXMuZGVjb2RlKHQsdC51aW50MzIoKSl9LHQudmVyaWZ5PWZ1bmN0aW9uKHQpe2lmKFwib2JqZWN0XCIhPXR5cGVvZiB0fHxudWxsPT09dClyZXR1cm5cIm9iamVjdCBleHBlY3RlZFwiO2lmKG51bGwhPXQuZGltJiZ0Lmhhc093blByb3BlcnR5KFwiZGltXCIpKXtpZighQXJyYXkuaXNBcnJheSh0LmRpbSkpcmV0dXJuXCJkaW06IGFycmF5IGV4cGVjdGVkXCI7Zm9yKHZhciBlPTA7ZTx0LmRpbS5sZW5ndGg7KytlKXt2YXIgbj1sLm9ubnguVGVuc29yU2hhcGVQcm90by5EaW1lbnNpb24udmVyaWZ5KHQuZGltW2VdKTtpZihuKXJldHVyblwiZGltLlwiK259fXJldHVybiBudWxsfSx0LmZyb21PYmplY3Q9ZnVuY3Rpb24odCl7aWYodCBpbnN0YW5jZW9mIGwub25ueC5UZW5zb3JTaGFwZVByb3RvKXJldHVybiB0O3ZhciBlPW5ldyBsLm9ubnguVGVuc29yU2hhcGVQcm90bztpZih0LmRpbSl7aWYoIUFycmF5LmlzQXJyYXkodC5kaW0pKXRocm93IFR5cGVFcnJvcihcIi5vbm54LlRlbnNvclNoYXBlUHJvdG8uZGltOiBhcnJheSBleHBlY3RlZFwiKTtlLmRpbT1bXTtmb3IodmFyIG49MDtuPHQuZGltLmxlbmd0aDsrK24pe2lmKFwib2JqZWN0XCIhPXR5cGVvZiB0LmRpbVtuXSl0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5UZW5zb3JTaGFwZVByb3RvLmRpbTogb2JqZWN0IGV4cGVjdGVkXCIpO2UuZGltW25dPWwub25ueC5UZW5zb3JTaGFwZVByb3RvLkRpbWVuc2lvbi5mcm9tT2JqZWN0KHQuZGltW25dKX19cmV0dXJuIGV9LHQudG9PYmplY3Q9ZnVuY3Rpb24odCxlKXtlfHwoZT17fSk7dmFyIG49e307aWYoKGUuYXJyYXlzfHxlLmRlZmF1bHRzKSYmKG4uZGltPVtdKSx0LmRpbSYmdC5kaW0ubGVuZ3RoKXtuLmRpbT1bXTtmb3IodmFyIHI9MDtyPHQuZGltLmxlbmd0aDsrK3Ipbi5kaW1bcl09bC5vbm54LlRlbnNvclNoYXBlUHJvdG8uRGltZW5zaW9uLnRvT2JqZWN0KHQuZGltW3JdLGUpfXJldHVybiBufSx0LnByb3RvdHlwZS50b0pTT049ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci50b09iamVjdCh0aGlzLGEudXRpbC50b0pTT05PcHRpb25zKX0sdC5EaW1lbnNpb249ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQpe2lmKHQpZm9yKHZhciBlPU9iamVjdC5rZXlzKHQpLG49MDtuPGUubGVuZ3RoOysrbiludWxsIT10W2Vbbl1dJiYodGhpc1tlW25dXT10W2Vbbl1dKX12YXIgZTtyZXR1cm4gdC5wcm90b3R5cGUuZGltVmFsdWU9Yy5Mb25nP2MuTG9uZy5mcm9tQml0cygwLDAsITEpOjAsdC5wcm90b3R5cGUuZGltUGFyYW09XCJcIix0LnByb3RvdHlwZS5kZW5vdGF0aW9uPVwiXCIsT2JqZWN0LmRlZmluZVByb3BlcnR5KHQucHJvdG90eXBlLFwidmFsdWVcIix7Z2V0OmMub25lT2ZHZXR0ZXIoZT1bXCJkaW1WYWx1ZVwiLFwiZGltUGFyYW1cIl0pLHNldDpjLm9uZU9mU2V0dGVyKGUpfSksdC5jcmVhdGU9ZnVuY3Rpb24oZSl7cmV0dXJuIG5ldyB0KGUpfSx0LmVuY29kZT1mdW5jdGlvbih0LGUpe3JldHVybiBlfHwoZT11LmNyZWF0ZSgpKSxudWxsIT10LmRpbVZhbHVlJiZ0Lmhhc093blByb3BlcnR5KFwiZGltVmFsdWVcIikmJmUudWludDMyKDgpLmludDY0KHQuZGltVmFsdWUpLG51bGwhPXQuZGltUGFyYW0mJnQuaGFzT3duUHJvcGVydHkoXCJkaW1QYXJhbVwiKSYmZS51aW50MzIoMTgpLnN0cmluZyh0LmRpbVBhcmFtKSxudWxsIT10LmRlbm90YXRpb24mJnQuaGFzT3duUHJvcGVydHkoXCJkZW5vdGF0aW9uXCIpJiZlLnVpbnQzMigyNikuc3RyaW5nKHQuZGVub3RhdGlvbiksZX0sdC5lbmNvZGVEZWxpbWl0ZWQ9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5lbmNvZGUodCxlKS5sZGVsaW0oKX0sdC5kZWNvZGU9ZnVuY3Rpb24odCxlKXt0IGluc3RhbmNlb2Ygc3x8KHQ9cy5jcmVhdGUodCkpO2Zvcih2YXIgbj12b2lkIDA9PT1lP3QubGVuOnQucG9zK2Uscj1uZXcgbC5vbm54LlRlbnNvclNoYXBlUHJvdG8uRGltZW5zaW9uO3QucG9zPG47KXt2YXIgaT10LnVpbnQzMigpO3N3aXRjaChpPj4+Myl7Y2FzZSAxOnIuZGltVmFsdWU9dC5pbnQ2NCgpO2JyZWFrO2Nhc2UgMjpyLmRpbVBhcmFtPXQuc3RyaW5nKCk7YnJlYWs7Y2FzZSAzOnIuZGVub3RhdGlvbj10LnN0cmluZygpO2JyZWFrO2RlZmF1bHQ6dC5za2lwVHlwZSg3JmkpfX1yZXR1cm4gcn0sdC5kZWNvZGVEZWxpbWl0ZWQ9ZnVuY3Rpb24odCl7cmV0dXJuIHQgaW5zdGFuY2VvZiBzfHwodD1uZXcgcyh0KSksdGhpcy5kZWNvZGUodCx0LnVpbnQzMigpKX0sdC52ZXJpZnk9ZnVuY3Rpb24odCl7aWYoXCJvYmplY3RcIiE9dHlwZW9mIHR8fG51bGw9PT10KXJldHVyblwib2JqZWN0IGV4cGVjdGVkXCI7dmFyIGU9e307aWYobnVsbCE9dC5kaW1WYWx1ZSYmdC5oYXNPd25Qcm9wZXJ0eShcImRpbVZhbHVlXCIpJiYoZS52YWx1ZT0xLCEoYy5pc0ludGVnZXIodC5kaW1WYWx1ZSl8fHQuZGltVmFsdWUmJmMuaXNJbnRlZ2VyKHQuZGltVmFsdWUubG93KSYmYy5pc0ludGVnZXIodC5kaW1WYWx1ZS5oaWdoKSkpKXJldHVyblwiZGltVmFsdWU6IGludGVnZXJ8TG9uZyBleHBlY3RlZFwiO2lmKG51bGwhPXQuZGltUGFyYW0mJnQuaGFzT3duUHJvcGVydHkoXCJkaW1QYXJhbVwiKSl7aWYoMT09PWUudmFsdWUpcmV0dXJuXCJ2YWx1ZTogbXVsdGlwbGUgdmFsdWVzXCI7aWYoZS52YWx1ZT0xLCFjLmlzU3RyaW5nKHQuZGltUGFyYW0pKXJldHVyblwiZGltUGFyYW06IHN0cmluZyBleHBlY3RlZFwifXJldHVybiBudWxsIT10LmRlbm90YXRpb24mJnQuaGFzT3duUHJvcGVydHkoXCJkZW5vdGF0aW9uXCIpJiYhYy5pc1N0cmluZyh0LmRlbm90YXRpb24pP1wiZGVub3RhdGlvbjogc3RyaW5nIGV4cGVjdGVkXCI6bnVsbH0sdC5mcm9tT2JqZWN0PWZ1bmN0aW9uKHQpe2lmKHQgaW5zdGFuY2VvZiBsLm9ubnguVGVuc29yU2hhcGVQcm90by5EaW1lbnNpb24pcmV0dXJuIHQ7dmFyIGU9bmV3IGwub25ueC5UZW5zb3JTaGFwZVByb3RvLkRpbWVuc2lvbjtyZXR1cm4gbnVsbCE9dC5kaW1WYWx1ZSYmKGMuTG9uZz8oZS5kaW1WYWx1ZT1jLkxvbmcuZnJvbVZhbHVlKHQuZGltVmFsdWUpKS51bnNpZ25lZD0hMTpcInN0cmluZ1wiPT10eXBlb2YgdC5kaW1WYWx1ZT9lLmRpbVZhbHVlPXBhcnNlSW50KHQuZGltVmFsdWUsMTApOlwibnVtYmVyXCI9PXR5cGVvZiB0LmRpbVZhbHVlP2UuZGltVmFsdWU9dC5kaW1WYWx1ZTpcIm9iamVjdFwiPT10eXBlb2YgdC5kaW1WYWx1ZSYmKGUuZGltVmFsdWU9bmV3IGMuTG9uZ0JpdHModC5kaW1WYWx1ZS5sb3c+Pj4wLHQuZGltVmFsdWUuaGlnaD4+PjApLnRvTnVtYmVyKCkpKSxudWxsIT10LmRpbVBhcmFtJiYoZS5kaW1QYXJhbT1TdHJpbmcodC5kaW1QYXJhbSkpLG51bGwhPXQuZGVub3RhdGlvbiYmKGUuZGVub3RhdGlvbj1TdHJpbmcodC5kZW5vdGF0aW9uKSksZX0sdC50b09iamVjdD1mdW5jdGlvbih0LGUpe2V8fChlPXt9KTt2YXIgbj17fTtyZXR1cm4gZS5kZWZhdWx0cyYmKG4uZGVub3RhdGlvbj1cIlwiKSxudWxsIT10LmRpbVZhbHVlJiZ0Lmhhc093blByb3BlcnR5KFwiZGltVmFsdWVcIikmJihcIm51bWJlclwiPT10eXBlb2YgdC5kaW1WYWx1ZT9uLmRpbVZhbHVlPWUubG9uZ3M9PT1TdHJpbmc/U3RyaW5nKHQuZGltVmFsdWUpOnQuZGltVmFsdWU6bi5kaW1WYWx1ZT1lLmxvbmdzPT09U3RyaW5nP2MuTG9uZy5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0LmRpbVZhbHVlKTplLmxvbmdzPT09TnVtYmVyP25ldyBjLkxvbmdCaXRzKHQuZGltVmFsdWUubG93Pj4+MCx0LmRpbVZhbHVlLmhpZ2g+Pj4wKS50b051bWJlcigpOnQuZGltVmFsdWUsZS5vbmVvZnMmJihuLnZhbHVlPVwiZGltVmFsdWVcIikpLG51bGwhPXQuZGltUGFyYW0mJnQuaGFzT3duUHJvcGVydHkoXCJkaW1QYXJhbVwiKSYmKG4uZGltUGFyYW09dC5kaW1QYXJhbSxlLm9uZW9mcyYmKG4udmFsdWU9XCJkaW1QYXJhbVwiKSksbnVsbCE9dC5kZW5vdGF0aW9uJiZ0Lmhhc093blByb3BlcnR5KFwiZGVub3RhdGlvblwiKSYmKG4uZGVub3RhdGlvbj10LmRlbm90YXRpb24pLG59LHQucHJvdG90eXBlLnRvSlNPTj1mdW5jdGlvbigpe3JldHVybiB0aGlzLmNvbnN0cnVjdG9yLnRvT2JqZWN0KHRoaXMsYS51dGlsLnRvSlNPTk9wdGlvbnMpfSx0fSgpLHR9KCksby5UeXBlUHJvdG89ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQpe2lmKHQpZm9yKHZhciBlPU9iamVjdC5rZXlzKHQpLG49MDtuPGUubGVuZ3RoOysrbiludWxsIT10W2Vbbl1dJiYodGhpc1tlW25dXT10W2Vbbl1dKX12YXIgZTtyZXR1cm4gdC5wcm90b3R5cGUudGVuc29yVHlwZT1udWxsLHQucHJvdG90eXBlLmRlbm90YXRpb249XCJcIixPYmplY3QuZGVmaW5lUHJvcGVydHkodC5wcm90b3R5cGUsXCJ2YWx1ZVwiLHtnZXQ6Yy5vbmVPZkdldHRlcihlPVtcInRlbnNvclR5cGVcIl0pLHNldDpjLm9uZU9mU2V0dGVyKGUpfSksdC5jcmVhdGU9ZnVuY3Rpb24oZSl7cmV0dXJuIG5ldyB0KGUpfSx0LmVuY29kZT1mdW5jdGlvbih0LGUpe3JldHVybiBlfHwoZT11LmNyZWF0ZSgpKSxudWxsIT10LnRlbnNvclR5cGUmJnQuaGFzT3duUHJvcGVydHkoXCJ0ZW5zb3JUeXBlXCIpJiZsLm9ubnguVHlwZVByb3RvLlRlbnNvci5lbmNvZGUodC50ZW5zb3JUeXBlLGUudWludDMyKDEwKS5mb3JrKCkpLmxkZWxpbSgpLG51bGwhPXQuZGVub3RhdGlvbiYmdC5oYXNPd25Qcm9wZXJ0eShcImRlbm90YXRpb25cIikmJmUudWludDMyKDUwKS5zdHJpbmcodC5kZW5vdGF0aW9uKSxlfSx0LmVuY29kZURlbGltaXRlZD1mdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLmVuY29kZSh0LGUpLmxkZWxpbSgpfSx0LmRlY29kZT1mdW5jdGlvbih0LGUpe3QgaW5zdGFuY2VvZiBzfHwodD1zLmNyZWF0ZSh0KSk7Zm9yKHZhciBuPXZvaWQgMD09PWU/dC5sZW46dC5wb3MrZSxyPW5ldyBsLm9ubnguVHlwZVByb3RvO3QucG9zPG47KXt2YXIgaT10LnVpbnQzMigpO3N3aXRjaChpPj4+Myl7Y2FzZSAxOnIudGVuc29yVHlwZT1sLm9ubnguVHlwZVByb3RvLlRlbnNvci5kZWNvZGUodCx0LnVpbnQzMigpKTticmVhaztjYXNlIDY6ci5kZW5vdGF0aW9uPXQuc3RyaW5nKCk7YnJlYWs7ZGVmYXVsdDp0LnNraXBUeXBlKDcmaSl9fXJldHVybiByfSx0LmRlY29kZURlbGltaXRlZD1mdW5jdGlvbih0KXtyZXR1cm4gdCBpbnN0YW5jZW9mIHN8fCh0PW5ldyBzKHQpKSx0aGlzLmRlY29kZSh0LHQudWludDMyKCkpfSx0LnZlcmlmeT1mdW5jdGlvbih0KXtpZihcIm9iamVjdFwiIT10eXBlb2YgdHx8bnVsbD09PXQpcmV0dXJuXCJvYmplY3QgZXhwZWN0ZWRcIjtpZihudWxsIT10LnRlbnNvclR5cGUmJnQuaGFzT3duUHJvcGVydHkoXCJ0ZW5zb3JUeXBlXCIpKXt2YXIgZT1sLm9ubnguVHlwZVByb3RvLlRlbnNvci52ZXJpZnkodC50ZW5zb3JUeXBlKTtpZihlKXJldHVyblwidGVuc29yVHlwZS5cIitlfXJldHVybiBudWxsIT10LmRlbm90YXRpb24mJnQuaGFzT3duUHJvcGVydHkoXCJkZW5vdGF0aW9uXCIpJiYhYy5pc1N0cmluZyh0LmRlbm90YXRpb24pP1wiZGVub3RhdGlvbjogc3RyaW5nIGV4cGVjdGVkXCI6bnVsbH0sdC5mcm9tT2JqZWN0PWZ1bmN0aW9uKHQpe2lmKHQgaW5zdGFuY2VvZiBsLm9ubnguVHlwZVByb3RvKXJldHVybiB0O3ZhciBlPW5ldyBsLm9ubnguVHlwZVByb3RvO2lmKG51bGwhPXQudGVuc29yVHlwZSl7aWYoXCJvYmplY3RcIiE9dHlwZW9mIHQudGVuc29yVHlwZSl0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5UeXBlUHJvdG8udGVuc29yVHlwZTogb2JqZWN0IGV4cGVjdGVkXCIpO2UudGVuc29yVHlwZT1sLm9ubnguVHlwZVByb3RvLlRlbnNvci5mcm9tT2JqZWN0KHQudGVuc29yVHlwZSl9cmV0dXJuIG51bGwhPXQuZGVub3RhdGlvbiYmKGUuZGVub3RhdGlvbj1TdHJpbmcodC5kZW5vdGF0aW9uKSksZX0sdC50b09iamVjdD1mdW5jdGlvbih0LGUpe2V8fChlPXt9KTt2YXIgbj17fTtyZXR1cm4gZS5kZWZhdWx0cyYmKG4uZGVub3RhdGlvbj1cIlwiKSxudWxsIT10LnRlbnNvclR5cGUmJnQuaGFzT3duUHJvcGVydHkoXCJ0ZW5zb3JUeXBlXCIpJiYobi50ZW5zb3JUeXBlPWwub25ueC5UeXBlUHJvdG8uVGVuc29yLnRvT2JqZWN0KHQudGVuc29yVHlwZSxlKSxlLm9uZW9mcyYmKG4udmFsdWU9XCJ0ZW5zb3JUeXBlXCIpKSxudWxsIT10LmRlbm90YXRpb24mJnQuaGFzT3duUHJvcGVydHkoXCJkZW5vdGF0aW9uXCIpJiYobi5kZW5vdGF0aW9uPXQuZGVub3RhdGlvbiksbn0sdC5wcm90b3R5cGUudG9KU09OPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY29uc3RydWN0b3IudG9PYmplY3QodGhpcyxhLnV0aWwudG9KU09OT3B0aW9ucyl9LHQuVGVuc29yPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0KXtpZih0KWZvcih2YXIgZT1PYmplY3Qua2V5cyh0KSxuPTA7bjxlLmxlbmd0aDsrK24pbnVsbCE9dFtlW25dXSYmKHRoaXNbZVtuXV09dFtlW25dXSl9cmV0dXJuIHQucHJvdG90eXBlLmVsZW1UeXBlPTAsdC5wcm90b3R5cGUuc2hhcGU9bnVsbCx0LmNyZWF0ZT1mdW5jdGlvbihlKXtyZXR1cm4gbmV3IHQoZSl9LHQuZW5jb2RlPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIGV8fChlPXUuY3JlYXRlKCkpLG51bGwhPXQuZWxlbVR5cGUmJnQuaGFzT3duUHJvcGVydHkoXCJlbGVtVHlwZVwiKSYmZS51aW50MzIoOCkuaW50MzIodC5lbGVtVHlwZSksbnVsbCE9dC5zaGFwZSYmdC5oYXNPd25Qcm9wZXJ0eShcInNoYXBlXCIpJiZsLm9ubnguVGVuc29yU2hhcGVQcm90by5lbmNvZGUodC5zaGFwZSxlLnVpbnQzMigxOCkuZm9yaygpKS5sZGVsaW0oKSxlfSx0LmVuY29kZURlbGltaXRlZD1mdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLmVuY29kZSh0LGUpLmxkZWxpbSgpfSx0LmRlY29kZT1mdW5jdGlvbih0LGUpe3QgaW5zdGFuY2VvZiBzfHwodD1zLmNyZWF0ZSh0KSk7Zm9yKHZhciBuPXZvaWQgMD09PWU/dC5sZW46dC5wb3MrZSxyPW5ldyBsLm9ubnguVHlwZVByb3RvLlRlbnNvcjt0LnBvczxuOyl7dmFyIGk9dC51aW50MzIoKTtzd2l0Y2goaT4+PjMpe2Nhc2UgMTpyLmVsZW1UeXBlPXQuaW50MzIoKTticmVhaztjYXNlIDI6ci5zaGFwZT1sLm9ubnguVGVuc29yU2hhcGVQcm90by5kZWNvZGUodCx0LnVpbnQzMigpKTticmVhaztkZWZhdWx0OnQuc2tpcFR5cGUoNyZpKX19cmV0dXJuIHJ9LHQuZGVjb2RlRGVsaW1pdGVkPWZ1bmN0aW9uKHQpe3JldHVybiB0IGluc3RhbmNlb2Ygc3x8KHQ9bmV3IHModCkpLHRoaXMuZGVjb2RlKHQsdC51aW50MzIoKSl9LHQudmVyaWZ5PWZ1bmN0aW9uKHQpe2lmKFwib2JqZWN0XCIhPXR5cGVvZiB0fHxudWxsPT09dClyZXR1cm5cIm9iamVjdCBleHBlY3RlZFwiO2lmKG51bGwhPXQuZWxlbVR5cGUmJnQuaGFzT3duUHJvcGVydHkoXCJlbGVtVHlwZVwiKSYmIWMuaXNJbnRlZ2VyKHQuZWxlbVR5cGUpKXJldHVyblwiZWxlbVR5cGU6IGludGVnZXIgZXhwZWN0ZWRcIjtpZihudWxsIT10LnNoYXBlJiZ0Lmhhc093blByb3BlcnR5KFwic2hhcGVcIikpe3ZhciBlPWwub25ueC5UZW5zb3JTaGFwZVByb3RvLnZlcmlmeSh0LnNoYXBlKTtpZihlKXJldHVyblwic2hhcGUuXCIrZX1yZXR1cm4gbnVsbH0sdC5mcm9tT2JqZWN0PWZ1bmN0aW9uKHQpe2lmKHQgaW5zdGFuY2VvZiBsLm9ubnguVHlwZVByb3RvLlRlbnNvcilyZXR1cm4gdDt2YXIgZT1uZXcgbC5vbm54LlR5cGVQcm90by5UZW5zb3I7aWYobnVsbCE9dC5lbGVtVHlwZSYmKGUuZWxlbVR5cGU9MHx0LmVsZW1UeXBlKSxudWxsIT10LnNoYXBlKXtpZihcIm9iamVjdFwiIT10eXBlb2YgdC5zaGFwZSl0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5UeXBlUHJvdG8uVGVuc29yLnNoYXBlOiBvYmplY3QgZXhwZWN0ZWRcIik7ZS5zaGFwZT1sLm9ubnguVGVuc29yU2hhcGVQcm90by5mcm9tT2JqZWN0KHQuc2hhcGUpfXJldHVybiBlfSx0LnRvT2JqZWN0PWZ1bmN0aW9uKHQsZSl7ZXx8KGU9e30pO3ZhciBuPXt9O3JldHVybiBlLmRlZmF1bHRzJiYobi5lbGVtVHlwZT0wLG4uc2hhcGU9bnVsbCksbnVsbCE9dC5lbGVtVHlwZSYmdC5oYXNPd25Qcm9wZXJ0eShcImVsZW1UeXBlXCIpJiYobi5lbGVtVHlwZT10LmVsZW1UeXBlKSxudWxsIT10LnNoYXBlJiZ0Lmhhc093blByb3BlcnR5KFwic2hhcGVcIikmJihuLnNoYXBlPWwub25ueC5UZW5zb3JTaGFwZVByb3RvLnRvT2JqZWN0KHQuc2hhcGUsZSkpLG59LHQucHJvdG90eXBlLnRvSlNPTj1mdW5jdGlvbigpe3JldHVybiB0aGlzLmNvbnN0cnVjdG9yLnRvT2JqZWN0KHRoaXMsYS51dGlsLnRvSlNPTk9wdGlvbnMpfSx0fSgpLHR9KCksby5PcGVyYXRvclNldElkUHJvdG89ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQpe2lmKHQpZm9yKHZhciBlPU9iamVjdC5rZXlzKHQpLG49MDtuPGUubGVuZ3RoOysrbiludWxsIT10W2Vbbl1dJiYodGhpc1tlW25dXT10W2Vbbl1dKX1yZXR1cm4gdC5wcm90b3R5cGUuZG9tYWluPVwiXCIsdC5wcm90b3R5cGUudmVyc2lvbj1jLkxvbmc/Yy5Mb25nLmZyb21CaXRzKDAsMCwhMSk6MCx0LmNyZWF0ZT1mdW5jdGlvbihlKXtyZXR1cm4gbmV3IHQoZSl9LHQuZW5jb2RlPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIGV8fChlPXUuY3JlYXRlKCkpLG51bGwhPXQuZG9tYWluJiZ0Lmhhc093blByb3BlcnR5KFwiZG9tYWluXCIpJiZlLnVpbnQzMigxMCkuc3RyaW5nKHQuZG9tYWluKSxudWxsIT10LnZlcnNpb24mJnQuaGFzT3duUHJvcGVydHkoXCJ2ZXJzaW9uXCIpJiZlLnVpbnQzMigxNikuaW50NjQodC52ZXJzaW9uKSxlfSx0LmVuY29kZURlbGltaXRlZD1mdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLmVuY29kZSh0LGUpLmxkZWxpbSgpfSx0LmRlY29kZT1mdW5jdGlvbih0LGUpe3QgaW5zdGFuY2VvZiBzfHwodD1zLmNyZWF0ZSh0KSk7Zm9yKHZhciBuPXZvaWQgMD09PWU/dC5sZW46dC5wb3MrZSxyPW5ldyBsLm9ubnguT3BlcmF0b3JTZXRJZFByb3RvO3QucG9zPG47KXt2YXIgaT10LnVpbnQzMigpO3N3aXRjaChpPj4+Myl7Y2FzZSAxOnIuZG9tYWluPXQuc3RyaW5nKCk7YnJlYWs7Y2FzZSAyOnIudmVyc2lvbj10LmludDY0KCk7YnJlYWs7ZGVmYXVsdDp0LnNraXBUeXBlKDcmaSl9fXJldHVybiByfSx0LmRlY29kZURlbGltaXRlZD1mdW5jdGlvbih0KXtyZXR1cm4gdCBpbnN0YW5jZW9mIHN8fCh0PW5ldyBzKHQpKSx0aGlzLmRlY29kZSh0LHQudWludDMyKCkpfSx0LnZlcmlmeT1mdW5jdGlvbih0KXtyZXR1cm5cIm9iamVjdFwiIT10eXBlb2YgdHx8bnVsbD09PXQ/XCJvYmplY3QgZXhwZWN0ZWRcIjpudWxsIT10LmRvbWFpbiYmdC5oYXNPd25Qcm9wZXJ0eShcImRvbWFpblwiKSYmIWMuaXNTdHJpbmcodC5kb21haW4pP1wiZG9tYWluOiBzdHJpbmcgZXhwZWN0ZWRcIjpudWxsIT10LnZlcnNpb24mJnQuaGFzT3duUHJvcGVydHkoXCJ2ZXJzaW9uXCIpJiYhKGMuaXNJbnRlZ2VyKHQudmVyc2lvbil8fHQudmVyc2lvbiYmYy5pc0ludGVnZXIodC52ZXJzaW9uLmxvdykmJmMuaXNJbnRlZ2VyKHQudmVyc2lvbi5oaWdoKSk/XCJ2ZXJzaW9uOiBpbnRlZ2VyfExvbmcgZXhwZWN0ZWRcIjpudWxsfSx0LmZyb21PYmplY3Q9ZnVuY3Rpb24odCl7aWYodCBpbnN0YW5jZW9mIGwub25ueC5PcGVyYXRvclNldElkUHJvdG8pcmV0dXJuIHQ7dmFyIGU9bmV3IGwub25ueC5PcGVyYXRvclNldElkUHJvdG87cmV0dXJuIG51bGwhPXQuZG9tYWluJiYoZS5kb21haW49U3RyaW5nKHQuZG9tYWluKSksbnVsbCE9dC52ZXJzaW9uJiYoYy5Mb25nPyhlLnZlcnNpb249Yy5Mb25nLmZyb21WYWx1ZSh0LnZlcnNpb24pKS51bnNpZ25lZD0hMTpcInN0cmluZ1wiPT10eXBlb2YgdC52ZXJzaW9uP2UudmVyc2lvbj1wYXJzZUludCh0LnZlcnNpb24sMTApOlwibnVtYmVyXCI9PXR5cGVvZiB0LnZlcnNpb24/ZS52ZXJzaW9uPXQudmVyc2lvbjpcIm9iamVjdFwiPT10eXBlb2YgdC52ZXJzaW9uJiYoZS52ZXJzaW9uPW5ldyBjLkxvbmdCaXRzKHQudmVyc2lvbi5sb3c+Pj4wLHQudmVyc2lvbi5oaWdoPj4+MCkudG9OdW1iZXIoKSkpLGV9LHQudG9PYmplY3Q9ZnVuY3Rpb24odCxlKXtlfHwoZT17fSk7dmFyIG49e307aWYoZS5kZWZhdWx0cylpZihuLmRvbWFpbj1cIlwiLGMuTG9uZyl7dmFyIHI9bmV3IGMuTG9uZygwLDAsITEpO24udmVyc2lvbj1lLmxvbmdzPT09U3RyaW5nP3IudG9TdHJpbmcoKTplLmxvbmdzPT09TnVtYmVyP3IudG9OdW1iZXIoKTpyfWVsc2Ugbi52ZXJzaW9uPWUubG9uZ3M9PT1TdHJpbmc/XCIwXCI6MDtyZXR1cm4gbnVsbCE9dC5kb21haW4mJnQuaGFzT3duUHJvcGVydHkoXCJkb21haW5cIikmJihuLmRvbWFpbj10LmRvbWFpbiksbnVsbCE9dC52ZXJzaW9uJiZ0Lmhhc093blByb3BlcnR5KFwidmVyc2lvblwiKSYmKFwibnVtYmVyXCI9PXR5cGVvZiB0LnZlcnNpb24/bi52ZXJzaW9uPWUubG9uZ3M9PT1TdHJpbmc/U3RyaW5nKHQudmVyc2lvbik6dC52ZXJzaW9uOm4udmVyc2lvbj1lLmxvbmdzPT09U3RyaW5nP2MuTG9uZy5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0LnZlcnNpb24pOmUubG9uZ3M9PT1OdW1iZXI/bmV3IGMuTG9uZ0JpdHModC52ZXJzaW9uLmxvdz4+PjAsdC52ZXJzaW9uLmhpZ2g+Pj4wKS50b051bWJlcigpOnQudmVyc2lvbiksbn0sdC5wcm90b3R5cGUudG9KU09OPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY29uc3RydWN0b3IudG9PYmplY3QodGhpcyxhLnV0aWwudG9KU09OT3B0aW9ucyl9LHR9KCksbyksdC5leHBvcnRzPWx9LDIxMDA6KHQsZSxuKT0+e1widXNlIHN0cmljdFwiO3QuZXhwb3J0cz1uKDk0ODIpfSw5NDgyOih0LGUsbik9PntcInVzZSBzdHJpY3RcIjt2YXIgcj1lO2Z1bmN0aW9uIGkoKXtyLnV0aWwuX2NvbmZpZ3VyZSgpLHIuV3JpdGVyLl9jb25maWd1cmUoci5CdWZmZXJXcml0ZXIpLHIuUmVhZGVyLl9jb25maWd1cmUoci5CdWZmZXJSZWFkZXIpfXIuYnVpbGQ9XCJtaW5pbWFsXCIsci5Xcml0ZXI9bigxMTczKSxyLkJ1ZmZlcldyaXRlcj1uKDMxNTUpLHIuUmVhZGVyPW4oMTQwOCksci5CdWZmZXJSZWFkZXI9big1OTMpLHIudXRpbD1uKDk2OTMpLHIucnBjPW4oNTk5NCksci5yb290cz1uKDUwNTQpLHIuY29uZmlndXJlPWksaSgpfSwxNDA4Oih0LGUsbik9PntcInVzZSBzdHJpY3RcIjt0LmV4cG9ydHM9dTt2YXIgcixpPW4oOTY5Myksbz1pLkxvbmdCaXRzLGE9aS51dGY4O2Z1bmN0aW9uIHModCxlKXtyZXR1cm4gUmFuZ2VFcnJvcihcImluZGV4IG91dCBvZiByYW5nZTogXCIrdC5wb3MrXCIgKyBcIisoZXx8MSkrXCIgPiBcIit0Lmxlbil9ZnVuY3Rpb24gdSh0KXt0aGlzLmJ1Zj10LHRoaXMucG9zPTAsdGhpcy5sZW49dC5sZW5ndGh9dmFyIGMsbD1cInVuZGVmaW5lZFwiIT10eXBlb2YgVWludDhBcnJheT9mdW5jdGlvbih0KXtpZih0IGluc3RhbmNlb2YgVWludDhBcnJheXx8QXJyYXkuaXNBcnJheSh0KSlyZXR1cm4gbmV3IHUodCk7dGhyb3cgRXJyb3IoXCJpbGxlZ2FsIGJ1ZmZlclwiKX06ZnVuY3Rpb24odCl7aWYoQXJyYXkuaXNBcnJheSh0KSlyZXR1cm4gbmV3IHUodCk7dGhyb3cgRXJyb3IoXCJpbGxlZ2FsIGJ1ZmZlclwiKX0scD1mdW5jdGlvbigpe3JldHVybiBpLkJ1ZmZlcj9mdW5jdGlvbih0KXtyZXR1cm4odS5jcmVhdGU9ZnVuY3Rpb24odCl7cmV0dXJuIGkuQnVmZmVyLmlzQnVmZmVyKHQpP25ldyByKHQpOmwodCl9KSh0KX06bH07ZnVuY3Rpb24gZigpe3ZhciB0PW5ldyBvKDAsMCksZT0wO2lmKCEodGhpcy5sZW4tdGhpcy5wb3M+NCkpe2Zvcig7ZTwzOysrZSl7aWYodGhpcy5wb3M+PXRoaXMubGVuKXRocm93IHModGhpcyk7aWYodC5sbz0odC5sb3woMTI3JnRoaXMuYnVmW3RoaXMucG9zXSk8PDcqZSk+Pj4wLHRoaXMuYnVmW3RoaXMucG9zKytdPDEyOClyZXR1cm4gdH1yZXR1cm4gdC5sbz0odC5sb3woMTI3JnRoaXMuYnVmW3RoaXMucG9zKytdKTw8NyplKT4+PjAsdH1mb3IoO2U8NDsrK2UpaWYodC5sbz0odC5sb3woMTI3JnRoaXMuYnVmW3RoaXMucG9zXSk8PDcqZSk+Pj4wLHRoaXMuYnVmW3RoaXMucG9zKytdPDEyOClyZXR1cm4gdDtpZih0LmxvPSh0LmxvfCgxMjcmdGhpcy5idWZbdGhpcy5wb3NdKTw8MjgpPj4+MCx0LmhpPSh0LmhpfCgxMjcmdGhpcy5idWZbdGhpcy5wb3NdKT4+NCk+Pj4wLHRoaXMuYnVmW3RoaXMucG9zKytdPDEyOClyZXR1cm4gdDtpZihlPTAsdGhpcy5sZW4tdGhpcy5wb3M+NCl7Zm9yKDtlPDU7KytlKWlmKHQuaGk9KHQuaGl8KDEyNyZ0aGlzLmJ1Zlt0aGlzLnBvc10pPDw3KmUrMyk+Pj4wLHRoaXMuYnVmW3RoaXMucG9zKytdPDEyOClyZXR1cm4gdH1lbHNlIGZvcig7ZTw1OysrZSl7aWYodGhpcy5wb3M+PXRoaXMubGVuKXRocm93IHModGhpcyk7aWYodC5oaT0odC5oaXwoMTI3JnRoaXMuYnVmW3RoaXMucG9zXSk8PDcqZSszKT4+PjAsdGhpcy5idWZbdGhpcy5wb3MrK108MTI4KXJldHVybiB0fXRocm93IEVycm9yKFwiaW52YWxpZCB2YXJpbnQgZW5jb2RpbmdcIil9ZnVuY3Rpb24gZCh0LGUpe3JldHVybih0W2UtNF18dFtlLTNdPDw4fHRbZS0yXTw8MTZ8dFtlLTFdPDwyNCk+Pj4wfWZ1bmN0aW9uIGgoKXtpZih0aGlzLnBvcys4PnRoaXMubGVuKXRocm93IHModGhpcyw4KTtyZXR1cm4gbmV3IG8oZCh0aGlzLmJ1Zix0aGlzLnBvcys9NCksZCh0aGlzLmJ1Zix0aGlzLnBvcys9NCkpfXUuY3JlYXRlPXAoKSx1LnByb3RvdHlwZS5fc2xpY2U9aS5BcnJheS5wcm90b3R5cGUuc3ViYXJyYXl8fGkuQXJyYXkucHJvdG90eXBlLnNsaWNlLHUucHJvdG90eXBlLnVpbnQzMj0oYz00Mjk0OTY3Mjk1LGZ1bmN0aW9uKCl7aWYoYz0oMTI3JnRoaXMuYnVmW3RoaXMucG9zXSk+Pj4wLHRoaXMuYnVmW3RoaXMucG9zKytdPDEyOClyZXR1cm4gYztpZihjPShjfCgxMjcmdGhpcy5idWZbdGhpcy5wb3NdKTw8Nyk+Pj4wLHRoaXMuYnVmW3RoaXMucG9zKytdPDEyOClyZXR1cm4gYztpZihjPShjfCgxMjcmdGhpcy5idWZbdGhpcy5wb3NdKTw8MTQpPj4+MCx0aGlzLmJ1Zlt0aGlzLnBvcysrXTwxMjgpcmV0dXJuIGM7aWYoYz0oY3woMTI3JnRoaXMuYnVmW3RoaXMucG9zXSk8PDIxKT4+PjAsdGhpcy5idWZbdGhpcy5wb3MrK108MTI4KXJldHVybiBjO2lmKGM9KGN8KDE1JnRoaXMuYnVmW3RoaXMucG9zXSk8PDI4KT4+PjAsdGhpcy5idWZbdGhpcy5wb3MrK108MTI4KXJldHVybiBjO2lmKCh0aGlzLnBvcys9NSk+dGhpcy5sZW4pdGhyb3cgdGhpcy5wb3M9dGhpcy5sZW4scyh0aGlzLDEwKTtyZXR1cm4gY30pLHUucHJvdG90eXBlLmludDMyPWZ1bmN0aW9uKCl7cmV0dXJuIDB8dGhpcy51aW50MzIoKX0sdS5wcm90b3R5cGUuc2ludDMyPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy51aW50MzIoKTtyZXR1cm4gdD4+PjFeLSgxJnQpfDB9LHUucHJvdG90eXBlLmJvb2w9ZnVuY3Rpb24oKXtyZXR1cm4gMCE9PXRoaXMudWludDMyKCl9LHUucHJvdG90eXBlLmZpeGVkMzI9ZnVuY3Rpb24oKXtpZih0aGlzLnBvcys0PnRoaXMubGVuKXRocm93IHModGhpcyw0KTtyZXR1cm4gZCh0aGlzLmJ1Zix0aGlzLnBvcys9NCl9LHUucHJvdG90eXBlLnNmaXhlZDMyPWZ1bmN0aW9uKCl7aWYodGhpcy5wb3MrND50aGlzLmxlbil0aHJvdyBzKHRoaXMsNCk7cmV0dXJuIDB8ZCh0aGlzLmJ1Zix0aGlzLnBvcys9NCl9LHUucHJvdG90eXBlLmZsb2F0PWZ1bmN0aW9uKCl7aWYodGhpcy5wb3MrND50aGlzLmxlbil0aHJvdyBzKHRoaXMsNCk7dmFyIHQ9aS5mbG9hdC5yZWFkRmxvYXRMRSh0aGlzLmJ1Zix0aGlzLnBvcyk7cmV0dXJuIHRoaXMucG9zKz00LHR9LHUucHJvdG90eXBlLmRvdWJsZT1mdW5jdGlvbigpe2lmKHRoaXMucG9zKzg+dGhpcy5sZW4pdGhyb3cgcyh0aGlzLDQpO3ZhciB0PWkuZmxvYXQucmVhZERvdWJsZUxFKHRoaXMuYnVmLHRoaXMucG9zKTtyZXR1cm4gdGhpcy5wb3MrPTgsdH0sdS5wcm90b3R5cGUuYnl0ZXM9ZnVuY3Rpb24oKXt2YXIgdD10aGlzLnVpbnQzMigpLGU9dGhpcy5wb3Msbj10aGlzLnBvcyt0O2lmKG4+dGhpcy5sZW4pdGhyb3cgcyh0aGlzLHQpO3JldHVybiB0aGlzLnBvcys9dCxBcnJheS5pc0FycmF5KHRoaXMuYnVmKT90aGlzLmJ1Zi5zbGljZShlLG4pOmU9PT1uP25ldyB0aGlzLmJ1Zi5jb25zdHJ1Y3RvcigwKTp0aGlzLl9zbGljZS5jYWxsKHRoaXMuYnVmLGUsbil9LHUucHJvdG90eXBlLnN0cmluZz1mdW5jdGlvbigpe3ZhciB0PXRoaXMuYnl0ZXMoKTtyZXR1cm4gYS5yZWFkKHQsMCx0Lmxlbmd0aCl9LHUucHJvdG90eXBlLnNraXA9ZnVuY3Rpb24odCl7aWYoXCJudW1iZXJcIj09dHlwZW9mIHQpe2lmKHRoaXMucG9zK3Q+dGhpcy5sZW4pdGhyb3cgcyh0aGlzLHQpO3RoaXMucG9zKz10fWVsc2UgZG97aWYodGhpcy5wb3M+PXRoaXMubGVuKXRocm93IHModGhpcyl9d2hpbGUoMTI4JnRoaXMuYnVmW3RoaXMucG9zKytdKTtyZXR1cm4gdGhpc30sdS5wcm90b3R5cGUuc2tpcFR5cGU9ZnVuY3Rpb24odCl7c3dpdGNoKHQpe2Nhc2UgMDp0aGlzLnNraXAoKTticmVhaztjYXNlIDE6dGhpcy5za2lwKDgpO2JyZWFrO2Nhc2UgMjp0aGlzLnNraXAodGhpcy51aW50MzIoKSk7YnJlYWs7Y2FzZSAzOmZvcig7NCE9KHQ9NyZ0aGlzLnVpbnQzMigpKTspdGhpcy5za2lwVHlwZSh0KTticmVhaztjYXNlIDU6dGhpcy5za2lwKDQpO2JyZWFrO2RlZmF1bHQ6dGhyb3cgRXJyb3IoXCJpbnZhbGlkIHdpcmUgdHlwZSBcIit0K1wiIGF0IG9mZnNldCBcIit0aGlzLnBvcyl9cmV0dXJuIHRoaXN9LHUuX2NvbmZpZ3VyZT1mdW5jdGlvbih0KXtyPXQsdS5jcmVhdGU9cCgpLHIuX2NvbmZpZ3VyZSgpO3ZhciBlPWkuTG9uZz9cInRvTG9uZ1wiOlwidG9OdW1iZXJcIjtpLm1lcmdlKHUucHJvdG90eXBlLHtpbnQ2NDpmdW5jdGlvbigpe3JldHVybiBmLmNhbGwodGhpcylbZV0oITEpfSx1aW50NjQ6ZnVuY3Rpb24oKXtyZXR1cm4gZi5jYWxsKHRoaXMpW2VdKCEwKX0sc2ludDY0OmZ1bmN0aW9uKCl7cmV0dXJuIGYuY2FsbCh0aGlzKS56ekRlY29kZSgpW2VdKCExKX0sZml4ZWQ2NDpmdW5jdGlvbigpe3JldHVybiBoLmNhbGwodGhpcylbZV0oITApfSxzZml4ZWQ2NDpmdW5jdGlvbigpe3JldHVybiBoLmNhbGwodGhpcylbZV0oITEpfX0pfX0sNTkzOih0LGUsbik9PntcInVzZSBzdHJpY3RcIjt0LmV4cG9ydHM9bzt2YXIgcj1uKDE0MDgpOyhvLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKHIucHJvdG90eXBlKSkuY29uc3RydWN0b3I9bzt2YXIgaT1uKDk2OTMpO2Z1bmN0aW9uIG8odCl7ci5jYWxsKHRoaXMsdCl9by5fY29uZmlndXJlPWZ1bmN0aW9uKCl7aS5CdWZmZXImJihvLnByb3RvdHlwZS5fc2xpY2U9aS5CdWZmZXIucHJvdG90eXBlLnNsaWNlKX0sby5wcm90b3R5cGUuc3RyaW5nPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy51aW50MzIoKTtyZXR1cm4gdGhpcy5idWYudXRmOFNsaWNlP3RoaXMuYnVmLnV0ZjhTbGljZSh0aGlzLnBvcyx0aGlzLnBvcz1NYXRoLm1pbih0aGlzLnBvcyt0LHRoaXMubGVuKSk6dGhpcy5idWYudG9TdHJpbmcoXCJ1dGYtOFwiLHRoaXMucG9zLHRoaXMucG9zPU1hdGgubWluKHRoaXMucG9zK3QsdGhpcy5sZW4pKX0sby5fY29uZmlndXJlKCl9LDUwNTQ6dD0+e1widXNlIHN0cmljdFwiO3QuZXhwb3J0cz17fX0sNTk5NDoodCxlLG4pPT57XCJ1c2Ugc3RyaWN0XCI7ZS5TZXJ2aWNlPW4oNzk0OCl9LDc5NDg6KHQsZSxuKT0+e1widXNlIHN0cmljdFwiO3QuZXhwb3J0cz1pO3ZhciByPW4oOTY5Myk7ZnVuY3Rpb24gaSh0LGUsbil7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgdCl0aHJvdyBUeXBlRXJyb3IoXCJycGNJbXBsIG11c3QgYmUgYSBmdW5jdGlvblwiKTtyLkV2ZW50RW1pdHRlci5jYWxsKHRoaXMpLHRoaXMucnBjSW1wbD10LHRoaXMucmVxdWVzdERlbGltaXRlZD1Cb29sZWFuKGUpLHRoaXMucmVzcG9uc2VEZWxpbWl0ZWQ9Qm9vbGVhbihuKX0oaS5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShyLkV2ZW50RW1pdHRlci5wcm90b3R5cGUpKS5jb25zdHJ1Y3Rvcj1pLGkucHJvdG90eXBlLnJwY0NhbGw9ZnVuY3Rpb24gdChlLG4saSxvLGEpe2lmKCFvKXRocm93IFR5cGVFcnJvcihcInJlcXVlc3QgbXVzdCBiZSBzcGVjaWZpZWRcIik7dmFyIHM9dGhpcztpZighYSlyZXR1cm4gci5hc1Byb21pc2UodCxzLGUsbixpLG8pO2lmKHMucnBjSW1wbCl0cnl7cmV0dXJuIHMucnBjSW1wbChlLG5bcy5yZXF1ZXN0RGVsaW1pdGVkP1wiZW5jb2RlRGVsaW1pdGVkXCI6XCJlbmNvZGVcIl0obykuZmluaXNoKCksKGZ1bmN0aW9uKHQsbil7aWYodClyZXR1cm4gcy5lbWl0KFwiZXJyb3JcIix0LGUpLGEodCk7aWYobnVsbCE9PW4pe2lmKCEobiBpbnN0YW5jZW9mIGkpKXRyeXtuPWlbcy5yZXNwb25zZURlbGltaXRlZD9cImRlY29kZURlbGltaXRlZFwiOlwiZGVjb2RlXCJdKG4pfWNhdGNoKHQpe3JldHVybiBzLmVtaXQoXCJlcnJvclwiLHQsZSksYSh0KX1yZXR1cm4gcy5lbWl0KFwiZGF0YVwiLG4sZSksYShudWxsLG4pfXMuZW5kKCEwKX0pKX1jYXRjaCh0KXtyZXR1cm4gcy5lbWl0KFwiZXJyb3JcIix0LGUpLHZvaWQgc2V0VGltZW91dCgoZnVuY3Rpb24oKXthKHQpfSksMCl9ZWxzZSBzZXRUaW1lb3V0KChmdW5jdGlvbigpe2EoRXJyb3IoXCJhbHJlYWR5IGVuZGVkXCIpKX0pLDApfSxpLnByb3RvdHlwZS5lbmQ9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMucnBjSW1wbCYmKHR8fHRoaXMucnBjSW1wbChudWxsLG51bGwsbnVsbCksdGhpcy5ycGNJbXBsPW51bGwsdGhpcy5lbWl0KFwiZW5kXCIpLm9mZigpKSx0aGlzfX0sMTk0NToodCxlLG4pPT57XCJ1c2Ugc3RyaWN0XCI7dC5leHBvcnRzPWk7dmFyIHI9big5NjkzKTtmdW5jdGlvbiBpKHQsZSl7dGhpcy5sbz10Pj4+MCx0aGlzLmhpPWU+Pj4wfXZhciBvPWkuemVybz1uZXcgaSgwLDApO28udG9OdW1iZXI9ZnVuY3Rpb24oKXtyZXR1cm4gMH0sby56ekVuY29kZT1vLnp6RGVjb2RlPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXN9LG8ubGVuZ3RoPWZ1bmN0aW9uKCl7cmV0dXJuIDF9O3ZhciBhPWkuemVyb0hhc2g9XCJcXDBcXDBcXDBcXDBcXDBcXDBcXDBcXDBcIjtpLmZyb21OdW1iZXI9ZnVuY3Rpb24odCl7aWYoMD09PXQpcmV0dXJuIG87dmFyIGU9dDwwO2UmJih0PS10KTt2YXIgbj10Pj4+MCxyPSh0LW4pLzQyOTQ5NjcyOTY+Pj4wO3JldHVybiBlJiYocj1+cj4+PjAsbj1+bj4+PjAsKytuPjQyOTQ5NjcyOTUmJihuPTAsKytyPjQyOTQ5NjcyOTUmJihyPTApKSksbmV3IGkobixyKX0saS5mcm9tPWZ1bmN0aW9uKHQpe2lmKFwibnVtYmVyXCI9PXR5cGVvZiB0KXJldHVybiBpLmZyb21OdW1iZXIodCk7aWYoci5pc1N0cmluZyh0KSl7aWYoIXIuTG9uZylyZXR1cm4gaS5mcm9tTnVtYmVyKHBhcnNlSW50KHQsMTApKTt0PXIuTG9uZy5mcm9tU3RyaW5nKHQpfXJldHVybiB0Lmxvd3x8dC5oaWdoP25ldyBpKHQubG93Pj4+MCx0LmhpZ2g+Pj4wKTpvfSxpLnByb3RvdHlwZS50b051bWJlcj1mdW5jdGlvbih0KXtpZighdCYmdGhpcy5oaT4+PjMxKXt2YXIgZT0xK350aGlzLmxvPj4+MCxuPX50aGlzLmhpPj4+MDtyZXR1cm4gZXx8KG49bisxPj4+MCksLShlKzQyOTQ5NjcyOTYqbil9cmV0dXJuIHRoaXMubG8rNDI5NDk2NzI5Nip0aGlzLmhpfSxpLnByb3RvdHlwZS50b0xvbmc9ZnVuY3Rpb24odCl7cmV0dXJuIHIuTG9uZz9uZXcgci5Mb25nKDB8dGhpcy5sbywwfHRoaXMuaGksQm9vbGVhbih0KSk6e2xvdzowfHRoaXMubG8saGlnaDowfHRoaXMuaGksdW5zaWduZWQ6Qm9vbGVhbih0KX19O3ZhciBzPVN0cmluZy5wcm90b3R5cGUuY2hhckNvZGVBdDtpLmZyb21IYXNoPWZ1bmN0aW9uKHQpe3JldHVybiB0PT09YT9vOm5ldyBpKChzLmNhbGwodCwwKXxzLmNhbGwodCwxKTw8OHxzLmNhbGwodCwyKTw8MTZ8cy5jYWxsKHQsMyk8PDI0KT4+PjAsKHMuY2FsbCh0LDQpfHMuY2FsbCh0LDUpPDw4fHMuY2FsbCh0LDYpPDwxNnxzLmNhbGwodCw3KTw8MjQpPj4+MCl9LGkucHJvdG90eXBlLnRvSGFzaD1mdW5jdGlvbigpe3JldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKDI1NSZ0aGlzLmxvLHRoaXMubG8+Pj44JjI1NSx0aGlzLmxvPj4+MTYmMjU1LHRoaXMubG8+Pj4yNCwyNTUmdGhpcy5oaSx0aGlzLmhpPj4+OCYyNTUsdGhpcy5oaT4+PjE2JjI1NSx0aGlzLmhpPj4+MjQpfSxpLnByb3RvdHlwZS56ekVuY29kZT1mdW5jdGlvbigpe3ZhciB0PXRoaXMuaGk+PjMxO3JldHVybiB0aGlzLmhpPSgodGhpcy5oaTw8MXx0aGlzLmxvPj4+MzEpXnQpPj4+MCx0aGlzLmxvPSh0aGlzLmxvPDwxXnQpPj4+MCx0aGlzfSxpLnByb3RvdHlwZS56ekRlY29kZT1mdW5jdGlvbigpe3ZhciB0PS0oMSZ0aGlzLmxvKTtyZXR1cm4gdGhpcy5sbz0oKHRoaXMubG8+Pj4xfHRoaXMuaGk8PDMxKV50KT4+PjAsdGhpcy5oaT0odGhpcy5oaT4+PjFedCk+Pj4wLHRoaXN9LGkucHJvdG90eXBlLmxlbmd0aD1mdW5jdGlvbigpe3ZhciB0PXRoaXMubG8sZT0odGhpcy5sbz4+PjI4fHRoaXMuaGk8PDQpPj4+MCxuPXRoaXMuaGk+Pj4yNDtyZXR1cm4gMD09PW4/MD09PWU/dDwxNjM4ND90PDEyOD8xOjI6dDwyMDk3MTUyPzM6NDplPDE2Mzg0P2U8MTI4PzU6NjplPDIwOTcxNTI/Nzo4Om48MTI4Pzk6MTB9fSw5NjkzOmZ1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjt2YXIgcj1lO2Z1bmN0aW9uIGkodCxlLG4pe2Zvcih2YXIgcj1PYmplY3Qua2V5cyhlKSxpPTA7aTxyLmxlbmd0aDsrK2kpdm9pZCAwIT09dFtyW2ldXSYmbnx8KHRbcltpXV09ZVtyW2ldXSk7cmV0dXJuIHR9ZnVuY3Rpb24gbyh0KXtmdW5jdGlvbiBlKHQsbil7aWYoISh0aGlzIGluc3RhbmNlb2YgZSkpcmV0dXJuIG5ldyBlKHQsbik7T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsXCJtZXNzYWdlXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0fX0pLEVycm9yLmNhcHR1cmVTdGFja1RyYWNlP0Vycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsZSk6T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsXCJzdGFja1wiLHt2YWx1ZToobmV3IEVycm9yKS5zdGFja3x8XCJcIn0pLG4mJmkodGhpcyxuKX1yZXR1cm4oZS5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShFcnJvci5wcm90b3R5cGUpKS5jb25zdHJ1Y3Rvcj1lLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLnByb3RvdHlwZSxcIm5hbWVcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHR9fSksZS5wcm90b3R5cGUudG9TdHJpbmc9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5uYW1lK1wiOiBcIit0aGlzLm1lc3NhZ2V9LGV9ci5hc1Byb21pc2U9big0NTM3KSxyLmJhc2U2ND1uKDc0MTkpLHIuRXZlbnRFbWl0dGVyPW4oOTIxMSksci5mbG9hdD1uKDk0NSksci5pbnF1aXJlPW4oNzE5OSksci51dGY4PW4oNDk5Nyksci5wb29sPW4oNjY2Miksci5Mb25nQml0cz1uKDE5NDUpLHIuaXNOb2RlPUJvb2xlYW4oXCJ1bmRlZmluZWRcIiE9dHlwZW9mIGdsb2JhbCYmZ2xvYmFsJiZnbG9iYWwucHJvY2VzcyYmZ2xvYmFsLnByb2Nlc3MudmVyc2lvbnMmJmdsb2JhbC5wcm9jZXNzLnZlcnNpb25zLm5vZGUpLHIuZ2xvYmFsPXIuaXNOb2RlJiZnbG9iYWx8fFwidW5kZWZpbmVkXCIhPXR5cGVvZiB3aW5kb3cmJndpbmRvd3x8XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHNlbGYmJnNlbGZ8fHRoaXMsci5lbXB0eUFycmF5PU9iamVjdC5mcmVlemU/T2JqZWN0LmZyZWV6ZShbXSk6W10sci5lbXB0eU9iamVjdD1PYmplY3QuZnJlZXplP09iamVjdC5mcmVlemUoe30pOnt9LHIuaXNJbnRlZ2VyPU51bWJlci5pc0ludGVnZXJ8fGZ1bmN0aW9uKHQpe3JldHVyblwibnVtYmVyXCI9PXR5cGVvZiB0JiZpc0Zpbml0ZSh0KSYmTWF0aC5mbG9vcih0KT09PXR9LHIuaXNTdHJpbmc9ZnVuY3Rpb24odCl7cmV0dXJuXCJzdHJpbmdcIj09dHlwZW9mIHR8fHQgaW5zdGFuY2VvZiBTdHJpbmd9LHIuaXNPYmplY3Q9ZnVuY3Rpb24odCl7cmV0dXJuIHQmJlwib2JqZWN0XCI9PXR5cGVvZiB0fSxyLmlzc2V0PXIuaXNTZXQ9ZnVuY3Rpb24odCxlKXt2YXIgbj10W2VdO3JldHVybiEobnVsbD09bnx8IXQuaGFzT3duUHJvcGVydHkoZSkpJiYoXCJvYmplY3RcIiE9dHlwZW9mIG58fChBcnJheS5pc0FycmF5KG4pP24ubGVuZ3RoOk9iamVjdC5rZXlzKG4pLmxlbmd0aCk+MCl9LHIuQnVmZmVyPWZ1bmN0aW9uKCl7dHJ5e3ZhciB0PXIuaW5xdWlyZShcImJ1ZmZlclwiKS5CdWZmZXI7cmV0dXJuIHQucHJvdG90eXBlLnV0ZjhXcml0ZT90Om51bGx9Y2F0Y2godCl7cmV0dXJuIG51bGx9fSgpLHIuX0J1ZmZlcl9mcm9tPW51bGwsci5fQnVmZmVyX2FsbG9jVW5zYWZlPW51bGwsci5uZXdCdWZmZXI9ZnVuY3Rpb24odCl7cmV0dXJuXCJudW1iZXJcIj09dHlwZW9mIHQ/ci5CdWZmZXI/ci5fQnVmZmVyX2FsbG9jVW5zYWZlKHQpOm5ldyByLkFycmF5KHQpOnIuQnVmZmVyP3IuX0J1ZmZlcl9mcm9tKHQpOlwidW5kZWZpbmVkXCI9PXR5cGVvZiBVaW50OEFycmF5P3Q6bmV3IFVpbnQ4QXJyYXkodCl9LHIuQXJyYXk9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIFVpbnQ4QXJyYXk/VWludDhBcnJheTpBcnJheSxyLkxvbmc9ci5nbG9iYWwuZGNvZGVJTyYmci5nbG9iYWwuZGNvZGVJTy5Mb25nfHxyLmdsb2JhbC5Mb25nfHxyLmlucXVpcmUoXCJsb25nXCIpLHIua2V5MlJlPS9edHJ1ZXxmYWxzZXwwfDEkLyxyLmtleTMyUmU9L14tPyg/OjB8WzEtOV1bMC05XSopJC8sci5rZXk2NFJlPS9eKD86W1xcXFx4MDAtXFxcXHhmZl17OH18LT8oPzowfFsxLTldWzAtOV0qKSkkLyxyLmxvbmdUb0hhc2g9ZnVuY3Rpb24odCl7cmV0dXJuIHQ/ci5Mb25nQml0cy5mcm9tKHQpLnRvSGFzaCgpOnIuTG9uZ0JpdHMuemVyb0hhc2h9LHIubG9uZ0Zyb21IYXNoPWZ1bmN0aW9uKHQsZSl7dmFyIG49ci5Mb25nQml0cy5mcm9tSGFzaCh0KTtyZXR1cm4gci5Mb25nP3IuTG9uZy5mcm9tQml0cyhuLmxvLG4uaGksZSk6bi50b051bWJlcihCb29sZWFuKGUpKX0sci5tZXJnZT1pLHIubGNGaXJzdD1mdW5jdGlvbih0KXtyZXR1cm4gdC5jaGFyQXQoMCkudG9Mb3dlckNhc2UoKSt0LnN1YnN0cmluZygxKX0sci5uZXdFcnJvcj1vLHIuUHJvdG9jb2xFcnJvcj1vKFwiUHJvdG9jb2xFcnJvclwiKSxyLm9uZU9mR2V0dGVyPWZ1bmN0aW9uKHQpe2Zvcih2YXIgZT17fSxuPTA7bjx0Lmxlbmd0aDsrK24pZVt0W25dXT0xO3JldHVybiBmdW5jdGlvbigpe2Zvcih2YXIgdD1PYmplY3Qua2V5cyh0aGlzKSxuPXQubGVuZ3RoLTE7bj4tMTstLW4paWYoMT09PWVbdFtuXV0mJnZvaWQgMCE9PXRoaXNbdFtuXV0mJm51bGwhPT10aGlzW3Rbbl1dKXJldHVybiB0W25dfX0sci5vbmVPZlNldHRlcj1mdW5jdGlvbih0KXtyZXR1cm4gZnVuY3Rpb24oZSl7Zm9yKHZhciBuPTA7bjx0Lmxlbmd0aDsrK24pdFtuXSE9PWUmJmRlbGV0ZSB0aGlzW3Rbbl1dfX0sci50b0pTT05PcHRpb25zPXtsb25nczpTdHJpbmcsZW51bXM6U3RyaW5nLGJ5dGVzOlN0cmluZyxqc29uOiEwfSxyLl9jb25maWd1cmU9ZnVuY3Rpb24oKXt2YXIgdD1yLkJ1ZmZlcjt0PyhyLl9CdWZmZXJfZnJvbT10LmZyb20hPT1VaW50OEFycmF5LmZyb20mJnQuZnJvbXx8ZnVuY3Rpb24oZSxuKXtyZXR1cm4gbmV3IHQoZSxuKX0sci5fQnVmZmVyX2FsbG9jVW5zYWZlPXQuYWxsb2NVbnNhZmV8fGZ1bmN0aW9uKGUpe3JldHVybiBuZXcgdChlKX0pOnIuX0J1ZmZlcl9mcm9tPXIuX0J1ZmZlcl9hbGxvY1Vuc2FmZT1udWxsfX0sMTE3MzoodCxlLG4pPT57XCJ1c2Ugc3RyaWN0XCI7dC5leHBvcnRzPXA7dmFyIHIsaT1uKDk2OTMpLG89aS5Mb25nQml0cyxhPWkuYmFzZTY0LHM9aS51dGY4O2Z1bmN0aW9uIHUodCxlLG4pe3RoaXMuZm49dCx0aGlzLmxlbj1lLHRoaXMubmV4dD12b2lkIDAsdGhpcy52YWw9bn1mdW5jdGlvbiBjKCl7fWZ1bmN0aW9uIGwodCl7dGhpcy5oZWFkPXQuaGVhZCx0aGlzLnRhaWw9dC50YWlsLHRoaXMubGVuPXQubGVuLHRoaXMubmV4dD10LnN0YXRlc31mdW5jdGlvbiBwKCl7dGhpcy5sZW49MCx0aGlzLmhlYWQ9bmV3IHUoYywwLDApLHRoaXMudGFpbD10aGlzLmhlYWQsdGhpcy5zdGF0ZXM9bnVsbH12YXIgZj1mdW5jdGlvbigpe3JldHVybiBpLkJ1ZmZlcj9mdW5jdGlvbigpe3JldHVybihwLmNyZWF0ZT1mdW5jdGlvbigpe3JldHVybiBuZXcgcn0pKCl9OmZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBwfX07ZnVuY3Rpb24gZCh0LGUsbil7ZVtuXT0yNTUmdH1mdW5jdGlvbiBoKHQsZSl7dGhpcy5sZW49dCx0aGlzLm5leHQ9dm9pZCAwLHRoaXMudmFsPWV9ZnVuY3Rpb24gZyh0LGUsbil7Zm9yKDt0LmhpOyllW24rK109MTI3JnQubG98MTI4LHQubG89KHQubG8+Pj43fHQuaGk8PDI1KT4+PjAsdC5oaT4+Pj03O2Zvcig7dC5sbz4xMjc7KWVbbisrXT0xMjcmdC5sb3wxMjgsdC5sbz10LmxvPj4+NztlW24rK109dC5sb31mdW5jdGlvbiBiKHQsZSxuKXtlW25dPTI1NSZ0LGVbbisxXT10Pj4+OCYyNTUsZVtuKzJdPXQ+Pj4xNiYyNTUsZVtuKzNdPXQ+Pj4yNH1wLmNyZWF0ZT1mKCkscC5hbGxvYz1mdW5jdGlvbih0KXtyZXR1cm4gbmV3IGkuQXJyYXkodCl9LGkuQXJyYXkhPT1BcnJheSYmKHAuYWxsb2M9aS5wb29sKHAuYWxsb2MsaS5BcnJheS5wcm90b3R5cGUuc3ViYXJyYXkpKSxwLnByb3RvdHlwZS5fcHVzaD1mdW5jdGlvbih0LGUsbil7cmV0dXJuIHRoaXMudGFpbD10aGlzLnRhaWwubmV4dD1uZXcgdSh0LGUsbiksdGhpcy5sZW4rPWUsdGhpc30saC5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZSh1LnByb3RvdHlwZSksaC5wcm90b3R5cGUuZm49ZnVuY3Rpb24odCxlLG4pe2Zvcig7dD4xMjc7KWVbbisrXT0xMjcmdHwxMjgsdD4+Pj03O2Vbbl09dH0scC5wcm90b3R5cGUudWludDMyPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmxlbis9KHRoaXMudGFpbD10aGlzLnRhaWwubmV4dD1uZXcgaCgodD4+Pj0wKTwxMjg/MTp0PDE2Mzg0PzI6dDwyMDk3MTUyPzM6dDwyNjg0MzU0NTY/NDo1LHQpKS5sZW4sdGhpc30scC5wcm90b3R5cGUuaW50MzI9ZnVuY3Rpb24odCl7cmV0dXJuIHQ8MD90aGlzLl9wdXNoKGcsMTAsby5mcm9tTnVtYmVyKHQpKTp0aGlzLnVpbnQzMih0KX0scC5wcm90b3R5cGUuc2ludDMyPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnVpbnQzMigodDw8MV50Pj4zMSk+Pj4wKX0scC5wcm90b3R5cGUudWludDY0PWZ1bmN0aW9uKHQpe3ZhciBlPW8uZnJvbSh0KTtyZXR1cm4gdGhpcy5fcHVzaChnLGUubGVuZ3RoKCksZSl9LHAucHJvdG90eXBlLmludDY0PXAucHJvdG90eXBlLnVpbnQ2NCxwLnByb3RvdHlwZS5zaW50NjQ9ZnVuY3Rpb24odCl7dmFyIGU9by5mcm9tKHQpLnp6RW5jb2RlKCk7cmV0dXJuIHRoaXMuX3B1c2goZyxlLmxlbmd0aCgpLGUpfSxwLnByb3RvdHlwZS5ib29sPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLl9wdXNoKGQsMSx0PzE6MCl9LHAucHJvdG90eXBlLmZpeGVkMzI9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuX3B1c2goYiw0LHQ+Pj4wKX0scC5wcm90b3R5cGUuc2ZpeGVkMzI9cC5wcm90b3R5cGUuZml4ZWQzMixwLnByb3RvdHlwZS5maXhlZDY0PWZ1bmN0aW9uKHQpe3ZhciBlPW8uZnJvbSh0KTtyZXR1cm4gdGhpcy5fcHVzaChiLDQsZS5sbykuX3B1c2goYiw0LGUuaGkpfSxwLnByb3RvdHlwZS5zZml4ZWQ2ND1wLnByb3RvdHlwZS5maXhlZDY0LHAucHJvdG90eXBlLmZsb2F0PWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLl9wdXNoKGkuZmxvYXQud3JpdGVGbG9hdExFLDQsdCl9LHAucHJvdG90eXBlLmRvdWJsZT1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5fcHVzaChpLmZsb2F0LndyaXRlRG91YmxlTEUsOCx0KX07dmFyIG09aS5BcnJheS5wcm90b3R5cGUuc2V0P2Z1bmN0aW9uKHQsZSxuKXtlLnNldCh0LG4pfTpmdW5jdGlvbih0LGUsbil7Zm9yKHZhciByPTA7cjx0Lmxlbmd0aDsrK3IpZVtuK3JdPXRbcl19O3AucHJvdG90eXBlLmJ5dGVzPWZ1bmN0aW9uKHQpe3ZhciBlPXQubGVuZ3RoPj4+MDtpZighZSlyZXR1cm4gdGhpcy5fcHVzaChkLDEsMCk7aWYoaS5pc1N0cmluZyh0KSl7dmFyIG49cC5hbGxvYyhlPWEubGVuZ3RoKHQpKTthLmRlY29kZSh0LG4sMCksdD1ufXJldHVybiB0aGlzLnVpbnQzMihlKS5fcHVzaChtLGUsdCl9LHAucHJvdG90eXBlLnN0cmluZz1mdW5jdGlvbih0KXt2YXIgZT1zLmxlbmd0aCh0KTtyZXR1cm4gZT90aGlzLnVpbnQzMihlKS5fcHVzaChzLndyaXRlLGUsdCk6dGhpcy5fcHVzaChkLDEsMCl9LHAucHJvdG90eXBlLmZvcms9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zdGF0ZXM9bmV3IGwodGhpcyksdGhpcy5oZWFkPXRoaXMudGFpbD1uZXcgdShjLDAsMCksdGhpcy5sZW49MCx0aGlzfSxwLnByb3RvdHlwZS5yZXNldD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnN0YXRlcz8odGhpcy5oZWFkPXRoaXMuc3RhdGVzLmhlYWQsdGhpcy50YWlsPXRoaXMuc3RhdGVzLnRhaWwsdGhpcy5sZW49dGhpcy5zdGF0ZXMubGVuLHRoaXMuc3RhdGVzPXRoaXMuc3RhdGVzLm5leHQpOih0aGlzLmhlYWQ9dGhpcy50YWlsPW5ldyB1KGMsMCwwKSx0aGlzLmxlbj0wKSx0aGlzfSxwLnByb3RvdHlwZS5sZGVsaW09ZnVuY3Rpb24oKXt2YXIgdD10aGlzLmhlYWQsZT10aGlzLnRhaWwsbj10aGlzLmxlbjtyZXR1cm4gdGhpcy5yZXNldCgpLnVpbnQzMihuKSxuJiYodGhpcy50YWlsLm5leHQ9dC5uZXh0LHRoaXMudGFpbD1lLHRoaXMubGVuKz1uKSx0aGlzfSxwLnByb3RvdHlwZS5maW5pc2g9ZnVuY3Rpb24oKXtmb3IodmFyIHQ9dGhpcy5oZWFkLm5leHQsZT10aGlzLmNvbnN0cnVjdG9yLmFsbG9jKHRoaXMubGVuKSxuPTA7dDspdC5mbih0LnZhbCxlLG4pLG4rPXQubGVuLHQ9dC5uZXh0O3JldHVybiBlfSxwLl9jb25maWd1cmU9ZnVuY3Rpb24odCl7cj10LHAuY3JlYXRlPWYoKSxyLl9jb25maWd1cmUoKX19LDMxNTU6KHQsZSxuKT0+e1widXNlIHN0cmljdFwiO3QuZXhwb3J0cz1vO3ZhciByPW4oMTE3Myk7KG8ucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoci5wcm90b3R5cGUpKS5jb25zdHJ1Y3Rvcj1vO3ZhciBpPW4oOTY5Myk7ZnVuY3Rpb24gbygpe3IuY2FsbCh0aGlzKX1mdW5jdGlvbiBhKHQsZSxuKXt0Lmxlbmd0aDw0MD9pLnV0Zjgud3JpdGUodCxlLG4pOmUudXRmOFdyaXRlP2UudXRmOFdyaXRlKHQsbik6ZS53cml0ZSh0LG4pfW8uX2NvbmZpZ3VyZT1mdW5jdGlvbigpe28uYWxsb2M9aS5fQnVmZmVyX2FsbG9jVW5zYWZlLG8ud3JpdGVCeXRlc0J1ZmZlcj1pLkJ1ZmZlciYmaS5CdWZmZXIucHJvdG90eXBlIGluc3RhbmNlb2YgVWludDhBcnJheSYmXCJzZXRcIj09PWkuQnVmZmVyLnByb3RvdHlwZS5zZXQubmFtZT9mdW5jdGlvbih0LGUsbil7ZS5zZXQodCxuKX06ZnVuY3Rpb24odCxlLG4pe2lmKHQuY29weSl0LmNvcHkoZSxuLDAsdC5sZW5ndGgpO2Vsc2UgZm9yKHZhciByPTA7cjx0Lmxlbmd0aDspZVtuKytdPXRbcisrXX19LG8ucHJvdG90eXBlLmJ5dGVzPWZ1bmN0aW9uKHQpe2kuaXNTdHJpbmcodCkmJih0PWkuX0J1ZmZlcl9mcm9tKHQsXCJiYXNlNjRcIikpO3ZhciBlPXQubGVuZ3RoPj4+MDtyZXR1cm4gdGhpcy51aW50MzIoZSksZSYmdGhpcy5fcHVzaChvLndyaXRlQnl0ZXNCdWZmZXIsZSx0KSx0aGlzfSxvLnByb3RvdHlwZS5zdHJpbmc9ZnVuY3Rpb24odCl7dmFyIGU9aS5CdWZmZXIuYnl0ZUxlbmd0aCh0KTtyZXR1cm4gdGhpcy51aW50MzIoZSksZSYmdGhpcy5fcHVzaChhLGUsdCksdGhpc30sby5fY29uZmlndXJlKCl9LDc3MTQ6KHQsZSxuKT0+e1widXNlIHN0cmljdFwiO2UuUj12b2lkIDA7Y29uc3Qgcj1uKDY5MTkpLGk9big3NDQ4KTtlLlI9bmV3IGNsYXNze2FzeW5jIGluaXQoKXt9YXN5bmMgY3JlYXRlU2Vzc2lvbkhhbmRsZXIodCxlKXtjb25zdCBuPW5ldyByLlNlc3Npb24oZSk7cmV0dXJuIGF3YWl0IG4ubG9hZE1vZGVsKHQpLG5ldyBpLk9ubnhqc1Nlc3Npb25IYW5kbGVyKG4pfX19LDQyMDA6KHQsZSxuKT0+e1widXNlIHN0cmljdFwiO2UuYzg9ZS5yWD12b2lkIDA7Y29uc3Qgcj1uKDYyMDcpLGk9big5NzE5KSxvPW4oMjE1NyksYT1uKDIzMDYpO2Uuclg9KCk9PntpZigoXCJudW1iZXJcIiE9dHlwZW9mIHIuZW52Lndhc20uaW5pdFRpbWVvdXR8fHIuZW52Lndhc20uaW5pdFRpbWVvdXQ8MCkmJihyLmVudi53YXNtLmluaXRUaW1lb3V0PTApLFwiYm9vbGVhblwiIT10eXBlb2Ygci5lbnYud2FzbS5zaW1kJiYoci5lbnYud2FzbS5zaW1kPSEwKSxcImJvb2xlYW5cIiE9dHlwZW9mIHIuZW52Lndhc20ucHJveHkmJihyLmVudi53YXNtLnByb3h5PSExKSxcIm51bWJlclwiIT10eXBlb2Ygci5lbnYud2FzbS5udW1UaHJlYWRzfHwhTnVtYmVyLmlzSW50ZWdlcihyLmVudi53YXNtLm51bVRocmVhZHMpfHxyLmVudi53YXNtLm51bVRocmVhZHM8PTApe2NvbnN0IHQ9XCJ1bmRlZmluZWRcIj09dHlwZW9mIG5hdmlnYXRvcj8oMCxpLmNwdXMpKCkubGVuZ3RoOm5hdmlnYXRvci5oYXJkd2FyZUNvbmN1cnJlbmN5O3IuZW52Lndhc20ubnVtVGhyZWFkcz1NYXRoLm1pbig0LE1hdGguY2VpbCgodHx8MSkvMikpfX0sZS5jOD1uZXcgY2xhc3N7YXN5bmMgaW5pdCgpeygwLGUuclgpKCksYXdhaXQoMCxvLmluaXRXYXNtKSgpfWFzeW5jIGNyZWF0ZVNlc3Npb25IYW5kbGVyKHQsZSl7Y29uc3Qgbj1uZXcgYS5Pbm54cnVudGltZVdlYkFzc2VtYmx5U2Vzc2lvbkhhbmRsZXI7cmV0dXJuIGF3YWl0IG4ubG9hZE1vZGVsKHQsZSksUHJvbWlzZS5yZXNvbHZlKG4pfX19LDYwMTg6ZnVuY3Rpb24odCxlLG4pe1widXNlIHN0cmljdFwiO3ZhciByPXRoaXMmJnRoaXMuX19jcmVhdGVCaW5kaW5nfHwoT2JqZWN0LmNyZWF0ZT9mdW5jdGlvbih0LGUsbixyKXt2b2lkIDA9PT1yJiYocj1uKTt2YXIgaT1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsbik7aSYmIShcImdldFwiaW4gaT8hZS5fX2VzTW9kdWxlOmkud3JpdGFibGV8fGkuY29uZmlndXJhYmxlKXx8KGk9e2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGVbbl19fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQscixpKX06ZnVuY3Rpb24odCxlLG4scil7dm9pZCAwPT09ciYmKHI9biksdFtyXT1lW25dfSksaT10aGlzJiZ0aGlzLl9fZXhwb3J0U3Rhcnx8ZnVuY3Rpb24odCxlKXtmb3IodmFyIG4gaW4gdClcImRlZmF1bHRcIj09PW58fE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLG4pfHxyKGUsdCxuKX07T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksaShuKDYyMDcpLGUpO2NvbnN0IG89big2MjA3KTt7Y29uc3QgdD1uKDc3MTQpLlI7KDAsby5yZWdpc3RlckJhY2tlbmQpKFwid2ViZ2xcIix0LC0xMCl9e2NvbnN0IHQ9big0MjAwKS5jODsoMCxvLnJlZ2lzdGVyQmFja2VuZCkoXCJjcHVcIix0LDEwKSwoMCxvLnJlZ2lzdGVyQmFja2VuZCkoXCJ3YXNtXCIsdCwxMCksKDAsby5yZWdpc3RlckJhY2tlbmQpKFwieG5ucGFja1wiLHQsOSl9fSwyNDY6KHQsZSk9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLmNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleT12b2lkIDA7Y2xhc3Mgbntjb25zdHJ1Y3Rvcih0KXtPYmplY3QuYXNzaWduKHRoaXMsdCl9Z2V0IGNhY2hlS2V5KCl7cmV0dXJuIHRoaXMuX2NhY2hlS2V5fHwodGhpcy5fY2FjaGVLZXk9T2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGhpcykuc29ydCgpLm1hcCgodD0+YCR7dGhpc1t0XX1gKSkuam9pbihcIjtcIikpLHRoaXMuX2NhY2hlS2V5fX1lLmNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleT10PT5uZXcgbih0KX0sNzc3ODoodCxlLG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5BdHRyaWJ1dGU9dm9pZCAwO2NvbnN0IHI9bigxNDQ2KSxpPW4oOTM5NSksbz1uKDkxNjIpLGE9bigyNTE3KTt2YXIgcz1pLm9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnM7Y2xhc3MgdXtjb25zdHJ1Y3Rvcih0KXtpZih0aGlzLl9hdHRyaWJ1dGVzPW5ldyBNYXAsbnVsbCE9dCl7Zm9yKGNvbnN0IGUgb2YgdCllIGluc3RhbmNlb2Ygci5vbm54LkF0dHJpYnV0ZVByb3RvP3RoaXMuX2F0dHJpYnV0ZXMuc2V0KGUubmFtZSxbdS5nZXRWYWx1ZShlKSx1LmdldFR5cGUoZSldKTplIGluc3RhbmNlb2Ygcy5BdHRyaWJ1dGUmJnRoaXMuX2F0dHJpYnV0ZXMuc2V0KGUubmFtZSgpLFt1LmdldFZhbHVlKGUpLHUuZ2V0VHlwZShlKV0pO2lmKHRoaXMuX2F0dHJpYnV0ZXMuc2l6ZTx0Lmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJkdXBsaWNhdGVkIGF0dHJpYnV0ZSBuYW1lc1wiKX19c2V0KHQsZSxuKXt0aGlzLl9hdHRyaWJ1dGVzLnNldCh0LFtuLGVdKX1kZWxldGUodCl7dGhpcy5fYXR0cmlidXRlcy5kZWxldGUodCl9Z2V0RmxvYXQodCxlKXtyZXR1cm4gdGhpcy5nZXQodCxcImZsb2F0XCIsZSl9Z2V0SW50KHQsZSl7cmV0dXJuIHRoaXMuZ2V0KHQsXCJpbnRcIixlKX1nZXRTdHJpbmcodCxlKXtyZXR1cm4gdGhpcy5nZXQodCxcInN0cmluZ1wiLGUpfWdldFRlbnNvcih0LGUpe3JldHVybiB0aGlzLmdldCh0LFwidGVuc29yXCIsZSl9Z2V0RmxvYXRzKHQsZSl7cmV0dXJuIHRoaXMuZ2V0KHQsXCJmbG9hdHNcIixlKX1nZXRJbnRzKHQsZSl7cmV0dXJuIHRoaXMuZ2V0KHQsXCJpbnRzXCIsZSl9Z2V0U3RyaW5ncyh0LGUpe3JldHVybiB0aGlzLmdldCh0LFwic3RyaW5nc1wiLGUpfWdldFRlbnNvcnModCxlKXtyZXR1cm4gdGhpcy5nZXQodCxcInRlbnNvcnNcIixlKX1nZXQodCxlLG4pe2NvbnN0IHI9dGhpcy5fYXR0cmlidXRlcy5nZXQodCk7aWYodm9pZCAwPT09cil7aWYodm9pZCAwIT09bilyZXR1cm4gbjt0aHJvdyBuZXcgRXJyb3IoYHJlcXVpcmVkIGF0dHJpYnV0ZSBub3QgZm91bmQ6ICR7dH1gKX1pZihyWzFdIT09ZSl0aHJvdyBuZXcgRXJyb3IoYHR5cGUgbWlzbWF0Y2g6IGV4cGVjdGVkICR7ZX0gYnV0IGdvdCAke3JbMV19YCk7cmV0dXJuIHJbMF19c3RhdGljIGdldFR5cGUodCl7Y29uc3QgZT10IGluc3RhbmNlb2Ygci5vbm54LkF0dHJpYnV0ZVByb3RvP3QudHlwZTp0LnR5cGUoKTtzd2l0Y2goZSl7Y2FzZSByLm9ubnguQXR0cmlidXRlUHJvdG8uQXR0cmlidXRlVHlwZS5GTE9BVDpyZXR1cm5cImZsb2F0XCI7Y2FzZSByLm9ubnguQXR0cmlidXRlUHJvdG8uQXR0cmlidXRlVHlwZS5JTlQ6cmV0dXJuXCJpbnRcIjtjYXNlIHIub25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlLlNUUklORzpyZXR1cm5cInN0cmluZ1wiO2Nhc2Ugci5vbm54LkF0dHJpYnV0ZVByb3RvLkF0dHJpYnV0ZVR5cGUuVEVOU09SOnJldHVyblwidGVuc29yXCI7Y2FzZSByLm9ubnguQXR0cmlidXRlUHJvdG8uQXR0cmlidXRlVHlwZS5GTE9BVFM6cmV0dXJuXCJmbG9hdHNcIjtjYXNlIHIub25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlLklOVFM6cmV0dXJuXCJpbnRzXCI7Y2FzZSByLm9ubnguQXR0cmlidXRlUHJvdG8uQXR0cmlidXRlVHlwZS5TVFJJTkdTOnJldHVyblwic3RyaW5nc1wiO2Nhc2Ugci5vbm54LkF0dHJpYnV0ZVByb3RvLkF0dHJpYnV0ZVR5cGUuVEVOU09SUzpyZXR1cm5cInRlbnNvcnNcIjtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgYXR0cmlidXRlIHR5cGUgaXMgbm90IHN1cHBvcnRlZCB5ZXQ6ICR7ci5vbm54LkF0dHJpYnV0ZVByb3RvLkF0dHJpYnV0ZVR5cGVbZV19YCl9fXN0YXRpYyBnZXRWYWx1ZSh0KXtjb25zdCBlPXQgaW5zdGFuY2VvZiByLm9ubnguQXR0cmlidXRlUHJvdG8/dC50eXBlOnQudHlwZSgpO2lmKGU9PT1yLm9ubnguQXR0cmlidXRlUHJvdG8uQXR0cmlidXRlVHlwZS5HUkFQSHx8ZT09PXIub25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlLkdSQVBIUyl0aHJvdyBuZXcgRXJyb3IoXCJncmFwaCBhdHRyaWJ1dGUgaXMgbm90IHN1cHBvcnRlZCB5ZXRcIik7Y29uc3Qgbj10aGlzLmdldFZhbHVlTm9DaGVjayh0KTtpZihlPT09ci5vbm54LkF0dHJpYnV0ZVByb3RvLkF0dHJpYnV0ZVR5cGUuSU5UJiZhLkxvbmdVdGlsLmlzTG9uZyhuKSlyZXR1cm4gYS5Mb25nVXRpbC5sb25nVG9OdW1iZXIobik7aWYoZT09PXIub25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlLklOVFMpe2NvbnN0IHQ9bixlPW5ldyBBcnJheSh0Lmxlbmd0aCk7Zm9yKGxldCBuPTA7bjx0Lmxlbmd0aDtuKyspe2NvbnN0IHI9dFtuXTtlW25dPWEuTG9uZ1V0aWwubG9uZ1RvTnVtYmVyKHIpfXJldHVybiBlfWlmKGU9PT1yLm9ubnguQXR0cmlidXRlUHJvdG8uQXR0cmlidXRlVHlwZS5URU5TT1IpcmV0dXJuIHQgaW5zdGFuY2VvZiByLm9ubnguQXR0cmlidXRlUHJvdG8/by5UZW5zb3IuZnJvbVByb3RvKG4pOm8uVGVuc29yLmZyb21PcnRUZW5zb3Iobik7aWYoZT09PXIub25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlLlRFTlNPUlMpe2lmKHQgaW5zdGFuY2VvZiByLm9ubnguQXR0cmlidXRlUHJvdG8pcmV0dXJuIG4ubWFwKCh0PT5vLlRlbnNvci5mcm9tUHJvdG8odCkpKTtpZih0IGluc3RhbmNlb2Ygcy5BdHRyaWJ1dGUpcmV0dXJuIG4ubWFwKCh0PT5vLlRlbnNvci5mcm9tT3J0VGVuc29yKHQpKSl9aWYoZT09PXIub25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlLlNUUklORyYmdCBpbnN0YW5jZW9mIHIub25ueC5BdHRyaWJ1dGVQcm90byl7Y29uc3QgdD1uO3JldHVybigwLGEuZGVjb2RlVXRmOFN0cmluZykodCl9cmV0dXJuIGU9PT1yLm9ubnguQXR0cmlidXRlUHJvdG8uQXR0cmlidXRlVHlwZS5TVFJJTkdTJiZ0IGluc3RhbmNlb2Ygci5vbm54LkF0dHJpYnV0ZVByb3RvP24ubWFwKGEuZGVjb2RlVXRmOFN0cmluZyk6bn1zdGF0aWMgZ2V0VmFsdWVOb0NoZWNrKHQpe3JldHVybiB0IGluc3RhbmNlb2Ygci5vbm54LkF0dHJpYnV0ZVByb3RvP3RoaXMuZ2V0VmFsdWVOb0NoZWNrRnJvbU9ubnhGb3JtYXQodCk6dGhpcy5nZXRWYWx1ZU5vQ2hlY2tGcm9tT3J0Rm9ybWF0KHQpfXN0YXRpYyBnZXRWYWx1ZU5vQ2hlY2tGcm9tT25ueEZvcm1hdCh0KXtzd2l0Y2godC50eXBlKXtjYXNlIHIub25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlLkZMT0FUOnJldHVybiB0LmY7Y2FzZSByLm9ubnguQXR0cmlidXRlUHJvdG8uQXR0cmlidXRlVHlwZS5JTlQ6cmV0dXJuIHQuaTtjYXNlIHIub25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlLlNUUklORzpyZXR1cm4gdC5zO2Nhc2Ugci5vbm54LkF0dHJpYnV0ZVByb3RvLkF0dHJpYnV0ZVR5cGUuVEVOU09SOnJldHVybiB0LnQ7Y2FzZSByLm9ubnguQXR0cmlidXRlUHJvdG8uQXR0cmlidXRlVHlwZS5HUkFQSDpyZXR1cm4gdC5nO2Nhc2Ugci5vbm54LkF0dHJpYnV0ZVByb3RvLkF0dHJpYnV0ZVR5cGUuRkxPQVRTOnJldHVybiB0LmZsb2F0cztjYXNlIHIub25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlLklOVFM6cmV0dXJuIHQuaW50cztjYXNlIHIub25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlLlNUUklOR1M6cmV0dXJuIHQuc3RyaW5ncztjYXNlIHIub25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlLlRFTlNPUlM6cmV0dXJuIHQudGVuc29ycztjYXNlIHIub25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlLkdSQVBIUzpyZXR1cm4gdC5ncmFwaHM7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIGF0dHJpYnV0ZSB0eXBlOiAke3Iub25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlW3QudHlwZV19YCl9fXN0YXRpYyBnZXRWYWx1ZU5vQ2hlY2tGcm9tT3J0Rm9ybWF0KHQpe3N3aXRjaCh0LnR5cGUoKSl7Y2FzZSBzLkF0dHJpYnV0ZVR5cGUuRkxPQVQ6cmV0dXJuIHQuZigpO2Nhc2Ugcy5BdHRyaWJ1dGVUeXBlLklOVDpyZXR1cm4gdC5pKCk7Y2FzZSBzLkF0dHJpYnV0ZVR5cGUuU1RSSU5HOnJldHVybiB0LnMoKTtjYXNlIHMuQXR0cmlidXRlVHlwZS5URU5TT1I6cmV0dXJuIHQudCgpO2Nhc2Ugcy5BdHRyaWJ1dGVUeXBlLkdSQVBIOnJldHVybiB0LmcoKTtjYXNlIHMuQXR0cmlidXRlVHlwZS5GTE9BVFM6cmV0dXJuIHQuZmxvYXRzQXJyYXkoKTtjYXNlIHMuQXR0cmlidXRlVHlwZS5JTlRTOntjb25zdCBlPVtdO2ZvcihsZXQgbj0wO248dC5pbnRzTGVuZ3RoKCk7bisrKWUucHVzaCh0LmludHMobikpO3JldHVybiBlfWNhc2Ugcy5BdHRyaWJ1dGVUeXBlLlNUUklOR1M6e2NvbnN0IGU9W107Zm9yKGxldCBuPTA7bjx0LnN0cmluZ3NMZW5ndGgoKTtuKyspZS5wdXNoKHQuc3RyaW5ncyhuKSk7cmV0dXJuIGV9Y2FzZSBzLkF0dHJpYnV0ZVR5cGUuVEVOU09SUzp7Y29uc3QgZT1bXTtmb3IobGV0IG49MDtuPHQudGVuc29yc0xlbmd0aCgpO24rKyllLnB1c2godC50ZW5zb3JzKG4pKTtyZXR1cm4gZX1kZWZhdWx0OnRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgYXR0cmlidXRlIHR5cGU6ICR7cy5BdHRyaWJ1dGVUeXBlW3QudHlwZSgpXX1gKX19fWUuQXR0cmlidXRlPXV9LDcwOTE6KHQsZSxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUucmVzb2x2ZUJhY2tlbmQ9ZS5iYWNrZW5kPXZvaWQgMDtjb25zdCByPW4oNTAzOCksaT1uZXcgTWFwO2FzeW5jIGZ1bmN0aW9uIG8odCl7Y29uc3Qgbj1lLmJhY2tlbmQ7aWYodm9pZCAwIT09blt0XSYmZnVuY3Rpb24odCl7Y29uc3QgZT10O3JldHVyblwiaW5pdGlhbGl6ZVwiaW4gZSYmXCJmdW5jdGlvblwiPT10eXBlb2YgZS5pbml0aWFsaXplJiZcImNyZWF0ZVNlc3Npb25IYW5kbGVyXCJpbiBlJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBlLmNyZWF0ZVNlc3Npb25IYW5kbGVyJiZcImRpc3Bvc2VcImluIGUmJlwiZnVuY3Rpb25cIj09dHlwZW9mIGUuZGlzcG9zZX0oblt0XSkpe2NvbnN0IGU9blt0XTtsZXQgcj1lLmluaXRpYWxpemUoKTtpZihcIm9iamVjdFwiPT10eXBlb2YgciYmXCJ0aGVuXCJpbiByJiYocj1hd2FpdCByKSxyKXJldHVybiBpLnNldCh0LGUpLGV9fWUuYmFja2VuZD17d2ViZ2w6bmV3IHIuV2ViR0xCYWNrZW5kfSxlLnJlc29sdmVCYWNrZW5kPWFzeW5jIGZ1bmN0aW9uIHQoZSl7aWYoIWUpcmV0dXJuIHQoW1wid2ViZ2xcIl0pO3tjb25zdCB0PVwic3RyaW5nXCI9PXR5cGVvZiBlP1tlXTplO2Zvcihjb25zdCBlIG9mIHQpe2NvbnN0IHQ9aS5nZXQoZSk7aWYodClyZXR1cm4gdDtjb25zdCBuPWF3YWl0IG8oZSk7aWYobilyZXR1cm4gbn19dGhyb3cgbmV3IEVycm9yKFwibm8gYXZhaWxhYmxlIGJhY2tlbmQgdG8gdXNlXCIpfX0sNTAzODoodCxlLG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5XZWJHTEJhY2tlbmQ9dm9pZCAwO2NvbnN0IHI9big2MjA3KSxpPW4oMzY5NCksbz1uKDY0MTYpLGE9big3MzA1KTtlLldlYkdMQmFja2VuZD1jbGFzc3tnZXQgY29udGV4dElkKCl7cmV0dXJuIHIuZW52LndlYmdsLmNvbnRleHRJZH1zZXQgY29udGV4dElkKHQpe3IuZW52LndlYmdsLmNvbnRleHRJZD10fWdldCBtYXRtdWxNYXhCYXRjaFNpemUoKXtyZXR1cm4gci5lbnYud2ViZ2wubWF0bXVsTWF4QmF0Y2hTaXplfXNldCBtYXRtdWxNYXhCYXRjaFNpemUodCl7ci5lbnYud2ViZ2wubWF0bXVsTWF4QmF0Y2hTaXplPXR9Z2V0IHRleHR1cmVDYWNoZU1vZGUoKXtyZXR1cm4gci5lbnYud2ViZ2wudGV4dHVyZUNhY2hlTW9kZX1zZXQgdGV4dHVyZUNhY2hlTW9kZSh0KXtyLmVudi53ZWJnbC50ZXh0dXJlQ2FjaGVNb2RlPXR9Z2V0IHBhY2soKXtyZXR1cm4gci5lbnYud2ViZ2wucGFja31zZXQgcGFjayh0KXtyLmVudi53ZWJnbC5wYWNrPXR9Z2V0IGFzeW5jKCl7cmV0dXJuIHIuZW52LndlYmdsLmFzeW5jfXNldCBhc3luYyh0KXtyLmVudi53ZWJnbC5hc3luYz10fWluaXRpYWxpemUoKXt0cnl7cmV0dXJuIHRoaXMuZ2xDb250ZXh0PSgwLGEuY3JlYXRlV2ViR0xDb250ZXh0KSh0aGlzLmNvbnRleHRJZCksXCJudW1iZXJcIiE9dHlwZW9mIHRoaXMubWF0bXVsTWF4QmF0Y2hTaXplJiYodGhpcy5tYXRtdWxNYXhCYXRjaFNpemU9MTYpLFwic3RyaW5nXCIhPXR5cGVvZiB0aGlzLnRleHR1cmVDYWNoZU1vZGUmJih0aGlzLnRleHR1cmVDYWNoZU1vZGU9XCJmdWxsXCIpLFwiYm9vbGVhblwiIT10eXBlb2YgdGhpcy5wYWNrJiYodGhpcy5wYWNrPSExKSxcImJvb2xlYW5cIiE9dHlwZW9mIHRoaXMuYXN5bmMmJih0aGlzLmFzeW5jPSExKSxpLkxvZ2dlci5zZXRXaXRoRW52KHIuZW52KSxpLkxvZ2dlci52ZXJib3NlKFwiV2ViR0xCYWNrZW5kXCIsYENyZWF0ZWQgV2ViR0xDb250ZXh0OiAke3R5cGVvZiB0aGlzLmdsQ29udGV4dH0gd2l0aCBtYXRtdWxNYXhCYXRjaFNpemU6ICR7dGhpcy5tYXRtdWxNYXhCYXRjaFNpemV9OyB0ZXh0dXJlQ2FjaGVNb2RlOiAke3RoaXMudGV4dHVyZUNhY2hlTW9kZX07IHBhY2s6ICR7dGhpcy5wYWNrfTsgYXN5bmM6ICR7dGhpcy5hc3luY30uYCksITB9Y2F0Y2godCl7cmV0dXJuIGkuTG9nZ2VyLndhcm5pbmcoXCJXZWJHTEJhY2tlbmRcIixgVW5hYmxlIHRvIGluaXRpYWxpemUgV2ViR0xCYWNrZW5kLiAke3R9YCksITF9fWNyZWF0ZVNlc3Npb25IYW5kbGVyKHQpe3JldHVybiBuZXcgby5XZWJHTFNlc3Npb25IYW5kbGVyKHRoaXMsdCl9ZGlzcG9zZSgpe3RoaXMuZ2xDb250ZXh0LmRpc3Bvc2UoKX19fSw1MTA3Oih0LGUsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLkNvb3Jkc0dsc2xMaWI9dm9pZCAwO2NvbnN0IHI9bigyNTE3KSxpPW4oODUyMCksbz1uKDUwNjApLGE9big3ODU5KSxzPW4oOTM5MCk7Y2xhc3MgdSBleHRlbmRzIGkuR2xzbExpYntjb25zdHJ1Y3Rvcih0KXtzdXBlcih0KX1nZXRGdW5jdGlvbnMoKXtyZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSx0aGlzLm9mZnNldFRvQ29vcmRzKCkpLHRoaXMuY29vcmRzVG9PZmZzZXQoKSksdGhpcy50b1ZlYygpKSx0aGlzLnZhbHVlRnJvbSgpKSx0aGlzLmdldENvbW1vblV0aWxGdW5jcygpKSx0aGlzLmdldElucHV0c1NhbXBsaW5nU25pcHBldHMoKSksdGhpcy5nZXRPdXRwdXRTYW1wbGluZ1NuaXBwZXQoKSl9Z2V0Q3VzdG9tVHlwZXMoKXtyZXR1cm57fX1vZmZzZXRUb0Nvb3Jkcygpe3JldHVybntvZmZzZXRUb0Nvb3JkczpuZXcgaS5HbHNsTGliUm91dGluZShcIlxcbiAgICAgIHZlYzIgb2Zmc2V0VG9Db29yZHMoaW50IG9mZnNldCwgaW50IHdpZHRoLCBpbnQgaGVpZ2h0KSB7XFxuICAgICAgICBpbnQgdCA9IG9mZnNldCAvIHdpZHRoO1xcbiAgICAgICAgaW50IHMgPSBvZmZzZXQgLSB0KndpZHRoO1xcbiAgICAgICAgdmVjMiBjb29yZHMgPSAodmVjMihzLHQpICsgdmVjMigwLjUsMC41KSkgLyB2ZWMyKHdpZHRoLCBoZWlnaHQpO1xcbiAgICAgICAgcmV0dXJuIGNvb3JkcztcXG4gICAgICB9XFxuICAgICAgXCIpfX1jb29yZHNUb09mZnNldCgpe3JldHVybntjb29yZHNUb09mZnNldDpuZXcgaS5HbHNsTGliUm91dGluZShcIlxcbiAgICAgIGludCBjb29yZHNUb09mZnNldCh2ZWMyIGNvb3JkcywgaW50IHdpZHRoLCBpbnQgaGVpZ2h0KSB7XFxuICAgICAgICBmbG9hdCBzID0gY29vcmRzLnMgKiBmbG9hdCh3aWR0aCk7XFxuICAgICAgICBmbG9hdCB0ID0gY29vcmRzLnQgKiBmbG9hdChoZWlnaHQpO1xcbiAgICAgICAgaW50IG9mZnNldCA9IGludCh0KSAqIHdpZHRoICsgaW50KHMpO1xcbiAgICAgICAgcmV0dXJuIG9mZnNldDtcXG4gICAgICB9XFxuICAgICAgXCIpfX1nZXRPdXRwdXRTYW1wbGluZ1NuaXBwZXQoKXtjb25zdCB0PXRoaXMuY29udGV4dC5vdXRwdXRUZXh0dXJlTGF5b3V0O3JldHVybiB0LmlzUGFja2VkP3RoaXMuZ2V0UGFja2VkT3V0cHV0U2FtcGxpbmdTbmlwcGV0KHQpOnRoaXMuZ2V0VW5wYWNrZWRPdXRwdXRTYW1wbGluZ1NuaXBwZXQodCl9Z2V0UGFja2VkT3V0cHV0U2FtcGxpbmdTbmlwcGV0KHQpe2NvbnN0IGU9dC51bnBhY2tlZFNoYXBlLG49W3Qud2lkdGgsdC5oZWlnaHRdLHI9e30sYT1cImdldE91dHB1dENvb3Jkc1wiO3N3aXRjaChlLmxlbmd0aCl7Y2FzZSAwOnJbYV09dGhpcy5nZXRPdXRwdXRTY2FsYXJDb29yZHMoKTticmVhaztjYXNlIDE6clthXT10aGlzLmdldE91dHB1dFBhY2tlZDFEQ29vcmRzKGUsbik7YnJlYWs7Y2FzZSAyOnJbYV09dGhpcy5nZXRPdXRwdXRQYWNrZWQyRENvb3JkcyhlLG4pO2JyZWFrO2Nhc2UgMzpyW2FdPXRoaXMuZ2V0T3V0cHV0UGFja2VkM0RDb29yZHMoZSxuKTticmVhaztkZWZhdWx0OnJbYV09dGhpcy5nZXRPdXRwdXRQYWNrZWRORENvb3JkcyhlLG4pfWNvbnN0IHM9YFxcbiAgICAgIHZvaWQgc2V0T3V0cHV0KHZlYzQgdmFsKSB7XFxuICAgICAgICAkeygwLG8uZ2V0R2xzbCkodGhpcy5jb250ZXh0LmdsQ29udGV4dC52ZXJzaW9uKS5vdXRwdXR9ID0gdmFsO1xcbiAgICAgIH1cXG4gICAgYDtyZXR1cm4gci5mbG9hdFRleHR1cmVTZXRSR0JBPW5ldyBpLkdsc2xMaWJSb3V0aW5lKHMpLHJ9Z2V0VW5wYWNrZWRPdXRwdXRTYW1wbGluZ1NuaXBwZXQodCl7Y29uc3QgZT10LnVucGFja2VkU2hhcGUsbj1bdC53aWR0aCx0LmhlaWdodF0scj17fSxhPVwiZ2V0T3V0cHV0Q29vcmRzXCI7c3dpdGNoKGUubGVuZ3RoKXtjYXNlIDA6clthXT10aGlzLmdldE91dHB1dFNjYWxhckNvb3JkcygpO2JyZWFrO2Nhc2UgMTpyW2FdPXRoaXMuZ2V0T3V0cHV0VW5wYWNrZWQxRENvb3JkcyhlLG4pO2JyZWFrO2Nhc2UgMjpyW2FdPXRoaXMuZ2V0T3V0cHV0VW5wYWNrZWQyRENvb3JkcyhlLG4pO2JyZWFrO2Nhc2UgMzpyW2FdPXRoaXMuZ2V0T3V0cHV0VW5wYWNrZWQzRENvb3JkcyhlLG4pO2JyZWFrO2Nhc2UgNDpyW2FdPXRoaXMuZ2V0T3V0cHV0VW5wYWNrZWQ0RENvb3JkcyhlLG4pO2JyZWFrO2Nhc2UgNTpyW2FdPXRoaXMuZ2V0T3V0cHV0VW5wYWNrZWQ1RENvb3JkcyhlLG4pO2JyZWFrO2Nhc2UgNjpyW2FdPXRoaXMuZ2V0T3V0cHV0VW5wYWNrZWQ2RENvb3JkcyhlLG4pO2JyZWFrO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBvdXRwdXQgZGltZW5zaW9uYWxpdHk6ICR7ZS5sZW5ndGh9YCl9Y29uc3Qgcz1gXFxuICAgICAgICB2b2lkIHNldE91dHB1dChmbG9hdCB2YWwpIHtcXG4gICAgICAgICAgJHsoMCxvLmdldEdsc2wpKHRoaXMuY29udGV4dC5nbENvbnRleHQudmVyc2lvbikub3V0cHV0fSA9IHZlYzQodmFsLCAwLCAwLCAwKTtcXG4gICAgICAgIH1cXG4gICAgYDtyZXR1cm4gci5mbG9hdFRleHR1cmVTZXRSPW5ldyBpLkdsc2xMaWJSb3V0aW5lKHMpLHJ9Z2V0T3V0cHV0U2NhbGFyQ29vcmRzKCl7cmV0dXJuIG5ldyBpLkdsc2xMaWJSb3V0aW5lKFwiXFxuICAgICAgaW50IGdldE91dHB1dENvb3JkcygpIHtcXG4gICAgICAgIHJldHVybiAwO1xcbiAgICAgIH1cXG4gICAgXCIpfWdldE91dHB1dFBhY2tlZDFEQ29vcmRzKHQsZSl7Y29uc3Qgbj1lO2xldCByPVwiXCI7cmV0dXJuIDE9PT1uWzBdPyhyPWBcXG4gICAgICAgICAgaW50IGdldE91dHB1dENvb3JkcygpIHtcXG4gICAgICAgICAgICByZXR1cm4gMiAqIGludChUZXhDb29yZHMueSAqICR7blsxXX0uMCk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIGAsbmV3IGkuR2xzbExpYlJvdXRpbmUocikpOjE9PT1uWzFdPyhyPWBcXG4gICAgICAgICAgaW50IGdldE91dHB1dENvb3JkcygpIHtcXG4gICAgICAgICAgICByZXR1cm4gMiAqIGludChUZXhDb29yZHMueCAqICR7blswXX0uMCk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIGAsbmV3IGkuR2xzbExpYlJvdXRpbmUocikpOihyPWBcXG4gICAgICAgIGludCBnZXRPdXRwdXRDb29yZHMoKSB7XFxuICAgICAgICAgIGl2ZWMyIHJlc1RleFJDID0gaXZlYzIoVGV4Q29vcmRzLnh5ICpcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZWMyKCR7blswXX0sICR7blsxXX0pKTtcXG4gICAgICAgICAgcmV0dXJuIDIgKiAocmVzVGV4UkMueSAqICR7blswXX0gKyByZXNUZXhSQy54KTtcXG4gICAgICAgIH1cXG4gICAgICBgLG5ldyBpLkdsc2xMaWJSb3V0aW5lKHIpKX1nZXRPdXRwdXRQYWNrZWQyRENvb3Jkcyh0LGUpe2xldCBuPVwiXCI7aWYoci5BcnJheVV0aWwuYXJyYXlzRXF1YWwodCxlKSlyZXR1cm4gbj1gXFxuICAgICAgICBpdmVjMiBnZXRPdXRwdXRDb29yZHMoKSB7XFxuICAgICAgICAgIHJldHVybiAyICogaXZlYzIoVGV4Q29vcmRzLnh5ICogdmVjMigke2VbMF19LCAke2VbMV19KSk7XFxuICAgICAgICB9XFxuICAgICAgYCxuZXcgaS5HbHNsTGliUm91dGluZShuKTtjb25zdCBvPWUsYT1NYXRoLmNlaWwodFsxXS8yKTtyZXR1cm4gbj1gXFxuICAgICAgICBpdmVjMiBnZXRPdXRwdXRDb29yZHMoKSB7XFxuICAgICAgICAgIGl2ZWMyIHJlc1RleFJDID0gaXZlYzIoVGV4Q29vcmRzLnh5ICpcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIoJHtvWzBdfSwgJHtvWzFdfSkpO1xcblxcbiAgICAgICAgICBpbnQgaW5kZXggPSByZXNUZXhSQy55ICogJHtvWzBdfSArIHJlc1RleFJDLng7XFxuXFxuICAgICAgICAgIC8vIHJldmVyc2UgciBhbmQgYyBvcmRlciBmb3IgcGFja2VkIHRleHR1cmVcXG4gICAgICAgICAgaW50IHIgPSBpbW9kKGluZGV4LCAke2F9KSAqIDI7XFxuICAgICAgICAgIGludCBjID0gMiAqIChpbmRleCAvICR7YX0pO1xcblxcbiAgICAgICAgICByZXR1cm4gaXZlYzIociwgYyk7XFxuICAgICAgICB9XFxuICAgICAgYCxuZXcgaS5HbHNsTGliUm91dGluZShuKX1nZXRPdXRwdXRQYWNrZWQzRENvb3Jkcyh0LGUpe2NvbnN0IG49W2VbMF0sZVsxXV0scj1NYXRoLmNlaWwodFsyXS8yKSxvPXIqTWF0aC5jZWlsKHRbMV0vMiksYT1gXFxuICAgICAgICBpdmVjMyBnZXRPdXRwdXRDb29yZHMoKSB7XFxuICAgICAgICAgIGl2ZWMyIHJlc1RleFJDID0gaXZlYzIoVGV4Q29vcmRzLnh5ICpcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIoJHtuWzBdfSwgJHtuWzFdfSkpO1xcbiAgICAgICAgICBpbnQgaW5kZXggPSByZXNUZXhSQy55ICogJHtuWzBdfSArIHJlc1RleFJDLng7XFxuXFxuICAgICAgICAgIGludCBiID0gaW5kZXggLyAke299O1xcbiAgICAgICAgICBpbmRleCAtPSBiICogJHtvfTtcXG5cXG4gICAgICAgICAgLy8gcmV2ZXJzZSByIGFuZCBjIG9yZGVyIGZvciBwYWNrZWQgdGV4dHVyZVxcbiAgICAgICAgICBpbnQgciA9IGltb2QoaW5kZXgsICR7cn0pICogMjtcXG4gICAgICAgICAgaW50IGMgPSAyICogKGluZGV4IC8gJHtyfSk7XFxuXFxuICAgICAgICAgIHJldHVybiBpdmVjMyhiLCByLCBjKTtcXG4gICAgICAgIH1cXG4gICAgICBgO3JldHVybiBuZXcgaS5HbHNsTGliUm91dGluZShhKX1nZXRPdXRwdXRQYWNrZWRORENvb3Jkcyh0LGUpe2NvbnN0IG49W2VbMF0sZVsxXV0scj1NYXRoLmNlaWwodFt0Lmxlbmd0aC0xXS8yKSxvPXIqTWF0aC5jZWlsKHRbdC5sZW5ndGgtMl0vMik7bGV0IGE9byxzPVwiXCIsdT1cImIsIHIsIGNcIjtmb3IobGV0IGU9MjtlPHQubGVuZ3RoLTE7ZSsrKWEqPXRbdC5sZW5ndGgtZS0xXSxzPWBcXG4gICAgICBpbnQgYiR7ZX0gPSBpbmRleCAvICR7YX07XFxuICAgICAgaW5kZXggLT0gYiR7ZX0gKiAke2F9O1xcbiAgICBgK3MsdT1gYiR7ZX0sIGArdTtjb25zdCBjPWBcXG4gICAgICBpdmVjJHt0Lmxlbmd0aH0gZ2V0T3V0cHV0Q29vcmRzKCkge1xcbiAgICAgICAgaXZlYzIgcmVzVGV4UkMgPSBpdmVjMihUZXhDb29yZHMueHkgKlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIoJHtuWzBdfSwgJHtuWzFdfSkpO1xcbiAgICAgICAgaW50IGluZGV4ID0gcmVzVGV4UkMueSAqICR7blswXX0gKyByZXNUZXhSQy54O1xcblxcbiAgICAgICAgJHtzfVxcblxcbiAgICAgICAgaW50IGIgPSBpbmRleCAvICR7b307XFxuICAgICAgICBpbmRleCAtPSBiICogJHtvfTtcXG5cXG4gICAgICAgIC8vIHJldmVyc2UgciBhbmQgYyBvcmRlciBmb3IgcGFja2VkIHRleHR1cmVcXG4gICAgICAgIGludCByID0gaW1vZChpbmRleCwgJHtyfSkgKiAyO1xcbiAgICAgICAgaW50IGMgPSAyICogKGluZGV4IC8gJHtyfSk7XFxuXFxuICAgICAgICByZXR1cm4gaXZlYyR7dC5sZW5ndGh9KCR7dX0pO1xcbiAgICAgIH1cXG4gICAgYDtyZXR1cm4gbmV3IGkuR2xzbExpYlJvdXRpbmUoYyl9Z2V0T3V0cHV0VW5wYWNrZWQxRENvb3Jkcyh0LGUpe2NvbnN0IG49YFxcbiAgICAgICAgaW50IGdldE91dHB1dENvb3JkcygpIHtcXG4gICAgICAgICAgaXZlYzIgcmVzVGV4UkMgPSBpdmVjMihUZXhDb29yZHMueHkgKlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVjMigke2VbMF19LCAke2VbMV19KSk7XFxuICAgICAgICAgIHJldHVybiByZXNUZXhSQy55ICogJHtlWzBdfSArIHJlc1RleFJDLng7XFxuICAgICAgICB9XFxuICAgICAgYDtyZXR1cm4gbmV3IGkuR2xzbExpYlJvdXRpbmUobil9Z2V0T3V0cHV0VW5wYWNrZWQyRENvb3Jkcyh0LGUpe2NvbnN0IG49YFxcbiAgICAgICAgaXZlYzIgZ2V0T3V0cHV0Q29vcmRzKCkge1xcbiAgICAgICAgICBpdmVjMiByZXNUZXhSQyA9IGl2ZWMyKFRleENvb3Jkcy54eSAqXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZWMyKCR7ZVswXX0sICR7ZVsxXX0pKTtcXG4gICAgICAgICAgaW50IGluZGV4ID0gcmVzVGV4UkMueSAqICR7ZVswXX0gKyByZXNUZXhSQy54O1xcbiAgICAgICAgICBpbnQgciA9IGluZGV4IC8gJHt0WzFdfTtcXG4gICAgICAgICAgaW50IGMgPSBpbmRleCAtIHIgKiAke3RbMV19O1xcbiAgICAgICAgICByZXR1cm4gaXZlYzIociwgYyk7XFxuICAgICAgICB9XFxuICAgICAgYDtyZXR1cm4gbmV3IGkuR2xzbExpYlJvdXRpbmUobil9Z2V0T3V0cHV0VW5wYWNrZWQzRENvb3Jkcyh0LGUpe2xldCBuPVwiXCI7Y29uc3Qgcj10Lmxlbmd0aDtsZXQgbz1udWxsO3I8MiYmKG89W10pLG89bmV3IEFycmF5KHItMSksb1tyLTJdPXRbci0xXTtmb3IobGV0IGU9ci0zO2U+PTA7LS1lKW9bZV09b1tlKzFdKnRbZSsxXTtjb25zdCBhPVtcInJcIixcImNcIixcImRcIl0scz1vLm1hcCgoKHQsZSk9PmBpbnQgJHthW2VdfSA9IGluZGV4IC8gJHt0fTsgJHtlPT09by5sZW5ndGgtMT9gaW50ICR7YVtlKzFdfSA9IGluZGV4IC0gJHthW2VdfSAqICR7dH1gOmBpbmRleCAtPSAke2FbZV19ICogJHt0fWB9O2ApKS5qb2luKFwiXCIpO3JldHVybiBuPWBcXG4gICAgICAgIGl2ZWMzIGdldE91dHB1dENvb3JkcygpIHtcXG4gICAgICAgICAgaXZlYzIgcmVzVGV4UkMgPSBpdmVjMihUZXhDb29yZHMueHkgKlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVjMigke2VbMF19LCAke2VbMV19KSk7XFxuICAgICAgICAgIGludCBpbmRleCA9IHJlc1RleFJDLnkgKiAke2VbMF19ICsgcmVzVGV4UkMueDtcXG4gICAgICAgICAgJHtzfVxcbiAgICAgICAgICByZXR1cm4gaXZlYzMociwgYywgZCk7XFxuICAgICAgICB9XFxuICAgICAgYCxuZXcgaS5HbHNsTGliUm91dGluZShuKX1nZXRPdXRwdXRVbnBhY2tlZDREQ29vcmRzKHQsZSl7bGV0IG49XCJcIjtjb25zdCByPXQubGVuZ3RoO2xldCBvPW51bGw7cjwyJiYobz1bXSksbz1uZXcgQXJyYXkoci0xKSxvW3ItMl09dFtyLTFdO2ZvcihsZXQgZT1yLTM7ZT49MDstLWUpb1tlXT1vW2UrMV0qdFtlKzFdO2NvbnN0IGE9W1wiclwiLFwiY1wiLFwiZFwiLFwiZDJcIl0scz1vLm1hcCgoKHQsZSk9PmBpbnQgJHthW2VdfSA9IGluZGV4IC8gJHt0fTsgJHtlPT09by5sZW5ndGgtMT9gaW50ICR7YVtlKzFdfSA9IGluZGV4IC0gJHthW2VdfSAqICR7dH1gOmBpbmRleCAtPSAke2FbZV19ICogJHt0fWB9O2ApKS5qb2luKFwiXCIpO3JldHVybiBuPWBcXG4gICAgICBpdmVjNCBnZXRPdXRwdXRDb29yZHMoKSB7XFxuICAgICAgICAgIGl2ZWMyIHJlc1RleFJDID0gaXZlYzIoVGV4Q29vcmRzLnh5ICpcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIoJHtlWzBdfSwgJHtlWzFdfSkpO1xcbiAgICAgICAgICBpbnQgaW5kZXggPSByZXNUZXhSQy55ICogJHtlWzBdfSArIHJlc1RleFJDLng7XFxuICAgICAgICAgICR7c31cXG4gICAgICAgICAgcmV0dXJuIGl2ZWM0KHIsIGMsIGQsIGQyKTtcXG4gICAgICAgIH1cXG4gICAgICBgLG5ldyBpLkdsc2xMaWJSb3V0aW5lKG4pfWdldE91dHB1dFVucGFja2VkNURDb29yZHModCxlKXtsZXQgbj1cIlwiO2NvbnN0IHI9dC5sZW5ndGg7bGV0IG89bnVsbDtyPDImJihvPVtdKSxvPW5ldyBBcnJheShyLTEpLG9bci0yXT10W3ItMV07Zm9yKGxldCBlPXItMztlPj0wOy0tZSlvW2VdPW9bZSsxXSp0W2UrMV07Y29uc3QgYT1bXCJyXCIsXCJjXCIsXCJkXCIsXCJkMlwiLFwiZDNcIl0scz1vLm1hcCgoKHQsZSk9PmBpbnQgJHthW2VdfSA9IGluZGV4IC8gJHt0fTsgJHtlPT09by5sZW5ndGgtMT9gaW50ICR7YVtlKzFdfSA9IGluZGV4IC0gJHthW2VdfSAqICR7dH1gOmBpbmRleCAtPSAke2FbZV19ICogJHt0fWB9O2ApKS5qb2luKFwiXCIpO3JldHVybiBuPWBcXG4gICAgICBpdmVjNSBnZXRPdXRwdXRDb29yZHMoKSB7XFxuICAgICAgICAgIGl2ZWMyIHJlc1RleFJDID0gaXZlYzIoVGV4Q29vcmRzLnh5ICpcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIoJHtlWzBdfSwgJHtlWzFdfSkpO1xcbiAgICAgICAgICBpbnQgaW5kZXggPSByZXNUZXhSQy55ICogJHtlWzBdfSArIHJlc1RleFJDLng7XFxuICAgICAgICAgICR7c31cXG4gICAgICAgICAgcmV0dXJuIGl2ZWM1KHIsIGMsIGQsIGQyLCBkMyk7XFxuICAgICAgICB9XFxuICAgICAgYCxuZXcgaS5HbHNsTGliUm91dGluZShuKX1nZXRPdXRwdXRVbnBhY2tlZDZEQ29vcmRzKHQsZSl7bGV0IG49XCJcIjtjb25zdCByPXQubGVuZ3RoO2xldCBvPW51bGw7cjwyJiYobz1bXSksbz1uZXcgQXJyYXkoci0xKSxvW3ItMl09dFtyLTFdO2ZvcihsZXQgZT1yLTM7ZT49MDstLWUpb1tlXT1vW2UrMV0qdFtlKzFdO2NvbnN0IGE9W1wiclwiLFwiY1wiLFwiZFwiLFwiZDJcIixcImQzXCIsXCJkNFwiXSxzPW8ubWFwKCgodCxlKT0+YGludCAke2FbZV19ID0gaW5kZXggLyAke3R9OyAke2U9PT1vLmxlbmd0aC0xP2BpbnQgJHthW2UrMV19ID0gaW5kZXggLSAke2FbZV19ICogJHt0fWA6YGluZGV4IC09ICR7YVtlXX0gKiAke3R9YH07YCkpLmpvaW4oXCJcIik7cmV0dXJuIG49YFxcbiAgICAgaXZlYzYgZ2V0T3V0cHV0Q29vcmRzKCkge1xcbiAgICAgICAgIGl2ZWMyIHJlc1RleFJDID0gaXZlYzIoVGV4Q29vcmRzLnh5ICpcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVjMigke2VbMF19LCAke2VbMV19KSk7XFxuICAgICAgICAgaW50IGluZGV4ID0gcmVzVGV4UkMueSAqICR7ZVswXX0gKyByZXNUZXhSQy54O1xcbiAgICAgICAgICR7c31cXG4gICAgICAgICByZXR1cm4gaXZlYzYociwgYywgZCwgZDIsIGQzLCBkNCk7XFxuICAgICAgIH1cXG4gICAgIGAsbmV3IGkuR2xzbExpYlJvdXRpbmUobil9Z2V0Q29tbW9uVXRpbEZ1bmNzKCl7Y29uc3QgdD17fTtsZXQgZT1cInV2RnJvbUZsYXRcIjt0W2VdPW5ldyBpLkdsc2xMaWJSb3V0aW5lKFwiXFxuICAgIHZlYzIgdXZGcm9tRmxhdChpbnQgdGV4TnVtUiwgaW50IHRleE51bUMsIGludCBpbmRleCkge1xcbiAgICAgIGludCB0ZXhDID0gaW5kZXggLyB0ZXhOdW1SO1xcbiAgICAgIGludCB0ZXhSID0gaW5kZXggLSB0ZXhDICogdGV4TnVtUjtcXG4gICAgICAvLyBUT0RPOiBzd2FwIHRleFIsIHRleEMgb3JkZXIgaW4gZm9sbG93aW5nIGZ1bmN0aW9uIHNvIHJvdyBpcyBjb3JyZXNwb25kaW5nIHRvIHUgYW5kIGNvbHVtbiBpcyBjb3JyZXNwb25kaW5nIHRvXFxuICAgICAgLy8gICAgICAgdi5cXG4gICAgICByZXR1cm4gKHZlYzIodGV4UiwgdGV4QykgKyBoYWxmQ1IpIC8gdmVjMih0ZXhOdW1SLCB0ZXhOdW1DKTtcXG4gICAgfVxcbiAgICBcIiksZT1cInBhY2tlZFVWZnJvbTFEXCIsdFtlXT1uZXcgaS5HbHNsTGliUm91dGluZShcIlxcbiAgICAgIHZlYzIgcGFja2VkVVZmcm9tMUQoaW50IHRleE51bVIsIGludCB0ZXhOdW1DLCBpbnQgaW5kZXgpIHtcXG4gICAgICAgIGludCB0ZXhlbEluZGV4ID0gaW5kZXggLyAyO1xcbiAgICAgICAgaW50IHRleFIgPSB0ZXhlbEluZGV4IC8gdGV4TnVtQztcXG4gICAgICAgIGludCB0ZXhDID0gdGV4ZWxJbmRleCAtIHRleFIgKiB0ZXhOdW1DO1xcbiAgICAgICAgcmV0dXJuICh2ZWMyKHRleEMsIHRleFIpICsgaGFsZkNSKSAvIHZlYzIodGV4TnVtQywgdGV4TnVtUik7XFxuICAgICAgfVxcbiAgICAgIFwiKSxlPVwicGFja2VkVVZmcm9tMkRcIix0W2VdPW5ldyBpLkdsc2xMaWJSb3V0aW5lKFwiXFxuICAgICAgdmVjMiBwYWNrZWRVVmZyb20yRChpbnQgdGV4TnVtUiwgaW50IHRleE51bUMsIGludCB0ZXhlbHNJbkxvZ2ljYWxSb3csIGludCByb3csIGludCBjb2wpIHtcXG4gICAgICAgIGludCB0ZXhlbEluZGV4ID0gKHJvdyAvIDIpICogdGV4ZWxzSW5Mb2dpY2FsUm93ICsgKGNvbCAvIDIpO1xcbiAgICAgICAgaW50IHRleFIgPSB0ZXhlbEluZGV4IC8gdGV4TnVtQztcXG4gICAgICAgIGludCB0ZXhDID0gdGV4ZWxJbmRleCAtIHRleFIgKiB0ZXhOdW1DO1xcbiAgICAgICAgcmV0dXJuICh2ZWMyKHRleEMsIHRleFIpICsgaGFsZkNSKSAvIHZlYzIodGV4TnVtQywgdGV4TnVtUik7XFxuICAgICAgfVxcbiAgICAgIFwiKSxlPVwicGFja2VkVVZmcm9tM0RcIix0W2VdPW5ldyBpLkdsc2xMaWJSb3V0aW5lKFwiXFxuICAgICAgdmVjMiBwYWNrZWRVVmZyb20zRChpbnQgdGV4TnVtUiwgaW50IHRleE51bUMsXFxuICAgICAgICAgIGludCB0ZXhlbHNJbkJhdGNoLCBpbnQgdGV4ZWxzSW5Mb2dpY2FsUm93LCBpbnQgYixcXG4gICAgICAgICAgaW50IHJvdywgaW50IGNvbCkge1xcbiAgICAgICAgaW50IGluZGV4ID0gYiAqIHRleGVsc0luQmF0Y2ggKyAocm93IC8gMikgKiB0ZXhlbHNJbkxvZ2ljYWxSb3cgKyAoY29sIC8gMik7XFxuICAgICAgICBpbnQgdGV4UiA9IGluZGV4IC8gdGV4TnVtQztcXG4gICAgICAgIGludCB0ZXhDID0gaW5kZXggLSB0ZXhSICogdGV4TnVtQztcXG4gICAgICAgIHJldHVybiAodmVjMih0ZXhDLCB0ZXhSKSArIGhhbGZDUikgLyB2ZWMyKHRleE51bUMsIHRleE51bVIpO1xcbiAgICAgIH1cXG4gICAgICBcIiksZT1cInNhbXBsZVRleHR1cmVcIjtjb25zdCBuPSgwLG8uZ2V0R2xzbCkodGhpcy5jb250ZXh0LmdsQ29udGV4dC52ZXJzaW9uKTtyZXR1cm4gdFtlXT1uZXcgaS5HbHNsTGliUm91dGluZShgXFxuICAgICAgICBmbG9hdCBzYW1wbGVUZXh0dXJlKHNhbXBsZXIyRCB0ZXh0dXJlU2FtcGxlciwgdmVjMiB1dikge1xcbiAgICAgICAgICAgIHJldHVybiAke24udGV4dHVyZTJEfSh0ZXh0dXJlU2FtcGxlciwgdXYpLnI7XFxuICAgICAgICB9YCksdH1nZXRJbnB1dHNTYW1wbGluZ1NuaXBwZXRzKCl7Y29uc3QgdD17fSxlPXRoaXMuY29udGV4dC5vdXRwdXRUZXh0dXJlTGF5b3V0O3JldHVybiB0aGlzLmNvbnRleHQucHJvZ3JhbUluZm8uaW5wdXROYW1lcy5mb3JFYWNoKCgobixyKT0+e2NvbnN0IGk9dGhpcy5jb250ZXh0LmlucHV0VGV4dHVyZUxheW91dHNbcl0sbz0oMCxzLmdlbmVyYXRlU2hhZGVyRnVuY05hbWVGcm9tSW5wdXRTYW1wbGVyTmFtZSkobik7aS5pc1BhY2tlZD90W29dPXRoaXMuZ2V0UGFja2VkU2FtcGxlckZyb21JbnB1dChvLG4saSk6dFtvXT10aGlzLmdldFVucGFja2VkU2FtcGxlckZyb21JbnB1dChvLG4saSk7Y29uc3QgYT0oMCxzLmdlbmVyYXRlU2hhZGVyRnVuY05hbWVGcm9tSW5wdXRTYW1wbGVyTmFtZUF0T3V0Q29vcmRzKShuKTtpLnVucGFja2VkU2hhcGUubGVuZ3RoPD1lLnVucGFja2VkU2hhcGUubGVuZ3RoJiYoaS5pc1BhY2tlZD90W2FdPXRoaXMuZ2V0UGFja2VkU2FtcGxlckF0T3V0cHV0Q29vcmRzKGEsaSxlLG4pOnRbYV09dGhpcy5nZXRVbnBhY2tlZFNhbXBsZXJBdE91dHB1dENvb3JkcyhhLGksZSxuKSl9KSksdH1nZXRQYWNrZWRTYW1wbGVyQXRPdXRwdXRDb29yZHModCxlLG4sbyl7Y29uc3QgYT1lLnVucGFja2VkU2hhcGUsdT1uLnVucGFja2VkU2hhcGUsYz1vLGw9KDAscy5nZW5lcmF0ZVNoYWRlckZ1bmNOYW1lRnJvbUlucHV0U2FtcGxlck5hbWUpKGMpLHA9YS5sZW5ndGgsZj11Lmxlbmd0aCxkPXIuQnJvYWRjYXN0VXRpbC5nZXRCcm9hZGNhc3REaW1zKGEsdSksaD0oMCxzLmdldENvb3Jkc0RhdGFUeXBlKShmKSxnPWYtcDtsZXQgYjtjb25zdCBtPSgwLHMuZ2V0R2xDaGFubmVscykoKTtiPTA9PT1wP1wiXCI6ZjwyJiZkLmxlbmd0aD49MT9cImNvb3JkcyA9IDA7XCI6ZC5tYXAoKHQ9PmBjb29yZHMuJHttW3QrZ119ID0gMDtgKSkuam9pbihcIlxcblwiKTtsZXQgeT1cIlwiO3k9ZjwyJiZwPjA/XCJjb29yZHNcIjphLm1hcCgoKHQsZSk9PmBjb29yZHMuJHttW2UrZ119YCkpLmpvaW4oXCIsIFwiKTtsZXQgXz1cInJldHVybiBvdXRwdXRWYWx1ZTtcIjtjb25zdCB2PTE9PT1yLlNoYXBlVXRpbC5zaXplKGEpLHc9MT09PXIuU2hhcGVVdGlsLnNpemUodSk7aWYoMSE9PXB8fHZ8fHcpe2lmKHYmJiF3KV89MT09PWY/XCJcXG4gICAgICAgICAgcmV0dXJuIHZlYzQob3V0cHV0VmFsdWUueCwgb3V0cHV0VmFsdWUueCwgMC4sIDAuKTtcXG4gICAgICAgIFwiOlwiXFxuICAgICAgICAgIHJldHVybiB2ZWM0KG91dHB1dFZhbHVlLngpO1xcbiAgICAgICAgXCI7ZWxzZSBpZihkLmxlbmd0aCl7Y29uc3QgdD1wLTIsZT1wLTE7ZC5pbmRleE9mKHQpPi0xJiZkLmluZGV4T2YoZSk+LTE/Xz1cInJldHVybiB2ZWM0KG91dHB1dFZhbHVlLngpO1wiOmQuaW5kZXhPZih0KT4tMT9fPVwicmV0dXJuIHZlYzQob3V0cHV0VmFsdWUueCwgb3V0cHV0VmFsdWUueSwgb3V0cHV0VmFsdWUueCwgb3V0cHV0VmFsdWUueSk7XCI6ZC5pbmRleE9mKGUpPi0xJiYoXz1cInJldHVybiB2ZWM0KG91dHB1dFZhbHVlLnh4LCBvdXRwdXRWYWx1ZS56eik7XCIpfX1lbHNlIF89XCJcXG4gICAgICAgIHJldHVybiB2ZWM0KG91dHB1dFZhbHVlLnh5LCBvdXRwdXRWYWx1ZS54eSk7XFxuICAgICAgXCI7Y29uc3QgeD1gXFxuICAgICAgdmVjNCAke3R9KCkge1xcbiAgICAgICAgJHtofSBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIFxcbiAgICAgICAgaW50IGxhc3REaW0gPSBjb29yZHMuJHttW2YtMV19O1xcbiAgICAgICAgY29vcmRzLiR7bVtmLTFdfSA9IGNvb3Jkcy4ke21bZi0yXX07XFxuICAgICAgICBjb29yZHMuJHttW2YtMl19ID0gbGFzdERpbTtcXG4gICAgICBcXG4gICAgICAgICR7Yn1cXG4gICAgICAgIHZlYzQgb3V0cHV0VmFsdWUgPSAke2x9KCR7eX0pO1xcbiAgICAgICAgJHtffVxcbiAgICAgIH1cXG4gICAgYDtyZXR1cm4gbmV3IGkuR2xzbExpYlJvdXRpbmUoeCxbXCJjb29yZGluYXRlcy5nZXRPdXRwdXRDb29yZHNcIl0pfWdldFVucGFja2VkU2FtcGxlckF0T3V0cHV0Q29vcmRzKHQsZSxuLG8pe2NvbnN0IGE9W24ud2lkdGgsbi5oZWlnaHRdLHU9W2Uud2lkdGgsZS5oZWlnaHRdLGM9ZS51bnBhY2tlZFNoYXBlLmxlbmd0aCxsPW4udW5wYWNrZWRTaGFwZS5sZW5ndGgscD1lLnVucGFja2VkU2hhcGUsZj1uLnVucGFja2VkU2hhcGUsZD0oMCxzLmdlbmVyYXRlU2hhZGVyRnVuY05hbWVGcm9tSW5wdXRTYW1wbGVyTmFtZSkobyk7aWYoYz09PWwmJnIuQXJyYXlVdGlsLmFycmF5c0VxdWFsKHUsYSkpe2NvbnN0IGU9YFxcbiAgICAgICAgICBmbG9hdCAke3R9KCkge1xcbiAgICAgICAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKCR7b30sIFRleENvb3Jkcyk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIGA7cmV0dXJuIG5ldyBpLkdsc2xMaWJSb3V0aW5lKGUsW1wiY29vcmRpbmF0ZXMuc2FtcGxlVGV4dHVyZVwiXSl9Y29uc3QgaD0oMCxzLmdldENvb3Jkc0RhdGFUeXBlKShsKSxnPXIuQnJvYWRjYXN0VXRpbC5nZXRCcm9hZGNhc3REaW1zKHAsZiksYj1sLWM7bGV0IG07Y29uc3QgeT0oMCxzLmdldEdsQ2hhbm5lbHMpKCk7bT0wPT09Yz9cIlwiOmw8MiYmZy5sZW5ndGg+PTE/XCJjb29yZHMgPSAwO1wiOmcubWFwKCh0PT5gY29vcmRzLiR7eVt0K2JdfSA9IDA7YCkpLmpvaW4oXCJcXG5cIik7bGV0IF89XCJcIjtfPWw8MiYmYz4wP1wiY29vcmRzXCI6ZS51bnBhY2tlZFNoYXBlLm1hcCgoKHQsZSk9PmBjb29yZHMuJHt5W2UrYl19YCkpLmpvaW4oXCIsIFwiKTtjb25zdCB2PWBcXG4gICAgICAgIGZsb2F0ICR7dH0oKSB7XFxuICAgICAgICAgICR7aH0gY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICAgICR7bX1cXG4gICAgICAgICAgcmV0dXJuICR7ZH0oJHtffSk7XFxuICAgICAgICB9XFxuICAgICAgYDtyZXR1cm4gbmV3IGkuR2xzbExpYlJvdXRpbmUodixbXCJjb29yZGluYXRlcy5nZXRPdXRwdXRDb29yZHNcIl0pfWdldFBhY2tlZFNhbXBsZXJGcm9tSW5wdXQodCxlLG4pe3N3aXRjaChuLnVucGFja2VkU2hhcGUubGVuZ3RoKXtjYXNlIDA6cmV0dXJuIHRoaXMuZ2V0UGFja2VkU2FtcGxlclNjYWxhcih0LGUpO2Nhc2UgMTpyZXR1cm4gdGhpcy5nZXRQYWNrZWRTYW1wbGVyMUQodCxlLG4pO2Nhc2UgMjpyZXR1cm4gdGhpcy5nZXRQYWNrZWRTYW1wbGVyMkQodCxlLG4pO2Nhc2UgMzpyZXR1cm4gdGhpcy5nZXRQYWNrZWRTYW1wbGVyM0QodCxlLG4pO2RlZmF1bHQ6cmV0dXJuIHRoaXMuZ2V0UGFja2VkU2FtcGxlck5EKHQsZSxuKX19Z2V0VW5wYWNrZWRTYW1wbGVyRnJvbUlucHV0KHQsZSxuKXtjb25zdCByPW4udW5wYWNrZWRTaGFwZTtzd2l0Y2goci5sZW5ndGgpe2Nhc2UgMDpyZXR1cm4gdGhpcy5nZXRVbnBhY2tlZFNhbXBsZXJTY2FsYXIodCxlLG4pO2Nhc2UgMTpyZXR1cm4gdGhpcy5nZXRVbnBhY2tlZFNhbXBsZXIxRCh0LGUsbik7Y2FzZSAyOnJldHVybiB0aGlzLmdldFVucGFja2VkU2FtcGxlcjJEKHQsZSxuKTtjYXNlIDM6cmV0dXJuIHRoaXMuZ2V0VW5wYWNrZWRTYW1wbGVyM0QodCxlLG4pO2Nhc2UgNDpyZXR1cm4gdGhpcy5nZXRVbnBhY2tlZFNhbXBsZXI0RCh0LGUsbik7Y2FzZSA1OnJldHVybiB0aGlzLmdldFVucGFja2VkU2FtcGxlcjVEKHQsZSxuKTtjYXNlIDY6cmV0dXJuIHRoaXMuZ2V0VW5wYWNrZWRTYW1wbGVyNkQodCxlLG4pO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBkaW1lbnNpb24gJHtyLmxlbmd0aH0tRGApfX1nZXRQYWNrZWRTYW1wbGVyU2NhbGFyKHQsZSl7Y29uc3Qgbj1gXFxuICAgICAgICAgIHZlYzQgJHt0fSgpIHtcXG4gICAgICAgICAgICByZXR1cm4gJHsoMCxvLmdldEdsc2wpKHRoaXMuY29udGV4dC5nbENvbnRleHQudmVyc2lvbikudGV4dHVyZTJEfSgke2V9LCBoYWxmQ1IpO1xcbiAgICAgICAgICB9XFxuICAgICAgICBgO3JldHVybiBuZXcgaS5HbHNsTGliUm91dGluZShuKX1nZXRQYWNrZWRTYW1wbGVyMUQodCxlLG4pe2NvbnN0IHI9W24ud2lkdGgsbi5oZWlnaHRdLGE9W3JbMV0sclswXV0scz0oMCxvLmdldEdsc2wpKHRoaXMuY29udGV4dC5nbENvbnRleHQudmVyc2lvbiksdT1gdmVjNCAke3R9KGludCBpbmRleCkge1xcbiAgICAgIHZlYzIgdXYgPSBwYWNrZWRVVmZyb20xRChcXG4gICAgICAke2FbMF19LCAke2FbMV19LCBpbmRleCk7XFxuICAgICAgcmV0dXJuICR7cy50ZXh0dXJlMkR9KCR7ZX0sIHV2KTtcXG4gICAgfWA7cmV0dXJuIG5ldyBpLkdsc2xMaWJSb3V0aW5lKHUsW1wiY29vcmRpbmF0ZXMucGFja2VkVVZmcm9tMURcIl0pfWdldFBhY2tlZFNhbXBsZXIyRCh0LGUsbil7Y29uc3QgYT1uLnVucGFja2VkU2hhcGUscz1bbi53aWR0aCxuLmhlaWdodF0sdT0oMCxvLmdldEdsc2wpKHRoaXMuY29udGV4dC5nbENvbnRleHQudmVyc2lvbiksYz1zWzBdLGw9c1sxXTtpZihudWxsIT1zJiZyLkFycmF5VXRpbC5hcnJheXNFcXVhbChhLHMpKXtjb25zdCBuPWB2ZWM0ICR7dH0oaW50IHJvdywgaW50IGNvbCkge1xcbiAgICAgICAgdmVjMiB1diA9ICh2ZWMyKGNvbCwgcm93KSArIGhhbGZDUikgLyB2ZWMyKCR7bH0uMCwgJHtjfS4wKTtcXG4gICAgICAgIHJldHVybiAke3UudGV4dHVyZTJEfSgke2V9LCB1dik7XFxuICAgICAgfWA7cmV0dXJuIG5ldyBpLkdsc2xMaWJSb3V0aW5lKG4pfWNvbnN0IHA9cyxmPU1hdGguY2VpbChhWzFdLzIpLGQ9YHZlYzQgJHt0fShpbnQgcm93LCBpbnQgY29sKSB7XFxuICAgICAgdmVjMiB1diA9IHBhY2tlZFVWZnJvbTJEKCR7cFsxXX0sICR7cFswXX0sICR7Zn0sIHJvdywgY29sKTtcXG4gICAgICByZXR1cm4gJHt1LnRleHR1cmUyRH0oJHtlfSwgdXYpO1xcbiAgICB9YDtyZXR1cm4gbmV3IGkuR2xzbExpYlJvdXRpbmUoZCxbXCJjb29yZGluYXRlcy5wYWNrZWRVVmZyb20yRFwiXSl9Z2V0UGFja2VkU2FtcGxlcjNEKHQsZSxuKXtjb25zdCByPW4udW5wYWNrZWRTaGFwZSxhPVtuLndpZHRoLG4uaGVpZ2h0XSx1PVthWzBdLGFbMV1dLGM9KDAsby5nZXRHbHNsKSh0aGlzLmNvbnRleHQuZ2xDb250ZXh0LnZlcnNpb24pO2lmKDE9PT1yWzBdKXtjb25zdCBvPXIuc2xpY2UoMSksYT1bMSwyXSx1PSgwLHMuc3F1ZWV6ZUlucHV0U2hhcGUpKHIsbyksYz1bXCJiXCIsXCJyb3dcIixcImNvbFwiXSxsPUpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkobikpO2wudW5wYWNrZWRTaGFwZT11O2NvbnN0IHA9dGhpcy5nZXRQYWNrZWRTYW1wbGVyRnJvbUlucHV0KHQsZSxsKSxmPWAke3Aucm91dGluZUJvZHl9XFxuICAgICAgdmVjNCAke3R9KGludCBiLCBpbnQgcm93LCBpbnQgY29sKSB7XFxuICAgICAgICByZXR1cm4gJHt0fSgkeygwLHMuZ2V0U3F1ZWV6ZWRQYXJhbXMpKGMsYSl9KTtcXG4gICAgICB9IGA7cmV0dXJuIG5ldyBpLkdsc2xMaWJSb3V0aW5lKGYscC5kZXBlbmRlbmNpZXMpfWNvbnN0IGw9dVswXSxwPXVbMV0sZj1NYXRoLmNlaWwoclsyXS8yKSxkPWB2ZWM0ICR7dH0oaW50IGIsIGludCByb3csIGludCBjb2wpIHtcXG4gICAgICB2ZWMyIHV2ID0gcGFja2VkVVZmcm9tM0QoXFxuICAgICAgICAke3B9LCAke2x9LCAke2YqTWF0aC5jZWlsKHJbMV0vMil9LCAke2Z9LCBiLCByb3csIGNvbCk7XFxuICAgICAgcmV0dXJuICR7Yy50ZXh0dXJlMkR9KCR7ZX0sIHV2KTt9YDtyZXR1cm4gbmV3IGkuR2xzbExpYlJvdXRpbmUoZCxbXCJjb29yZGluYXRlcy5wYWNrZWRVVmZyb20zRFwiXSl9Z2V0UGFja2VkU2FtcGxlck5EKHQsZSxuKXtjb25zdCByPW4udW5wYWNrZWRTaGFwZSxhPXIubGVuZ3RoLHM9W24ud2lkdGgsbi5oZWlnaHRdLHU9KDAsby5nZXRHbHNsKSh0aGlzLmNvbnRleHQuZ2xDb250ZXh0LnZlcnNpb24pLGM9W3NbMF0sc1sxXV0sbD1jWzFdLHA9Y1swXSxmPU1hdGguY2VpbChyW2EtMV0vMik7bGV0IGQ9ZipNYXRoLmNlaWwoclthLTJdLzIpLGg9XCJpbnQgYiwgaW50IHJvdywgaW50IGNvbFwiLGc9YGIgKiAke2R9ICsgKHJvdyAvIDIpICogJHtmfSArIChjb2wgLyAyKWA7Zm9yKGxldCB0PTI7dDxhLTE7dCsrKWg9YGludCBiJHt0fSwgYCtoLGQqPXJbYS10LTFdLGc9YGIke3R9ICogJHtkfSArIGArZztjb25zdCBiPWB2ZWM0ICR7dH0oJHtofSkge1xcbiAgICAgIGludCBpbmRleCA9ICR7Z307XFxuICAgICAgaW50IHRleFIgPSBpbmRleCAvICR7cH07XFxuICAgICAgaW50IHRleEMgPSBpbmRleCAtIHRleFIgKiAke3B9O1xcbiAgICAgIHZlYzIgdXYgPSAodmVjMih0ZXhDLCB0ZXhSKSArIGhhbGZDUikgLyB2ZWMyKCR7cH0sICR7bH0pO1xcbiAgICAgIHJldHVybiAke3UudGV4dHVyZTJEfSgke2V9LCB1dik7XFxuICAgIH1gO3JldHVybiBuZXcgaS5HbHNsTGliUm91dGluZShiKX1nZXRVbnBhY2tlZFNhbXBsZXJTY2FsYXIodCxlLG4pe2NvbnN0W3Isb109W24ud2lkdGgsbi5oZWlnaHRdO2lmKDE9PT1yJiYxPT09byl7Y29uc3Qgbj1gXFxuICAgICAgICAgIGZsb2F0ICR7dH0oKSB7XFxuICAgICAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoJHtlfSwgaGFsZkNSKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgYDtyZXR1cm4gbmV3IGkuR2xzbExpYlJvdXRpbmUobixbXCJjb29yZGluYXRlcy5zYW1wbGVUZXh0dXJlXCJdKX1jb25zdCBhPWBcXG4gICAgICAgIGZsb2F0ICR7dH0oKSB7XFxuICAgICAgICAgIGludCBvZmZzZXRfJHtlfSA9IGNvb3Jkc1RvT2Zmc2V0KFRleENvb3JkcywgJHtyfSwgJHtvfSk7XFxuICAgICAgICAgIHZlYzIgdXYgPSB1dkZyb21GbGF0KCR7cn0sICR7b30sIG9mZnNldF8ke2V9KTtcXG4gICAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoJHtlfSwgdXYpO1xcbiAgICAgICAgfVxcbiAgICAgIGA7cmV0dXJuIG5ldyBpLkdsc2xMaWJSb3V0aW5lKGEsW1wiY29vcmRpbmF0ZXMudXZGcm9tRmxhdFwiLFwiY29vcmRpbmF0ZXMuc2FtcGxlVGV4dHVyZVwiLFwiY29vcmRpbmF0ZXMuY29vcmRzVG9PZmZzZXRcIl0pfWdldFVucGFja2VkU2FtcGxlcjFEKHQsZSxuKXtjb25zdCByPW4ud2lkdGgsbz1uLmhlaWdodDtpZigxPT09byYmMT09PXIpe2NvbnN0IG49YFxcbiAgICAgICAgZmxvYXQgJHt0fShpbnQgaW5kZXgpIHtcXG4gICAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoJHtlfSwgaGFsZkNSKTtcXG4gICAgICAgIH1cXG4gICAgICBgO3JldHVybiBuZXcgaS5HbHNsTGliUm91dGluZShuLFtcImNvb3JkaW5hdGVzLnNhbXBsZVRleHR1cmVcIl0pfWlmKDE9PT1vKXtjb25zdCBuPWBcXG4gICAgICAgICAgZmxvYXQgJHt0fShpbnQgaW5kZXgpIHtcXG4gICAgICAgICAgICB2ZWMyIHV2ID0gdmVjMigoZmxvYXQoaW5kZXgpICsgMC41KSAvICR7cn0uMCwgMC41KTtcXG4gICAgICAgICAgICByZXR1cm4gc2FtcGxlVGV4dHVyZSgke2V9LCB1dik7XFxuICAgICAgICAgIH1cXG4gICAgICAgIGA7cmV0dXJuIG5ldyBpLkdsc2xMaWJSb3V0aW5lKG4sW1wiY29vcmRpbmF0ZXMuc2FtcGxlVGV4dHVyZVwiXSl9aWYoMT09PXIpe2NvbnN0IG49YFxcbiAgICAgICAgICBmbG9hdCAke3R9KGludCBpbmRleCkge1xcbiAgICAgICAgICAgIHZlYzIgdXYgPSB2ZWMyKDAuNSwgKGZsb2F0KGluZGV4KSArIDAuNSkgLyAke299LjApO1xcbiAgICAgICAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKCR7ZX0sIHV2KTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgYDtyZXR1cm4gbmV3IGkuR2xzbExpYlJvdXRpbmUobixbXCJjb29yZGluYXRlcy5zYW1wbGVUZXh0dXJlXCJdKX1jb25zdCBhPWBcXG4gICAgICAgIGZsb2F0ICR7dH0oaW50IGluZGV4KSB7XFxuICAgICAgICAgIHZlYzIgdXYgPSB1dkZyb21GbGF0KCR7cn0sICR7b30sIGluZGV4KTtcXG4gICAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoJHtlfSwgdXYpO1xcbiAgICAgICAgfVxcbiAgICAgIGA7cmV0dXJuIG5ldyBpLkdsc2xMaWJSb3V0aW5lKGEsW1wiY29vcmRpbmF0ZXMudXZGcm9tRmxhdFwiLFwiY29vcmRpbmF0ZXMuc2FtcGxlVGV4dHVyZVwiXSl9Z2V0VW5wYWNrZWRTYW1wbGVyMkQodCxlLG4pe2NvbnN0IG89bi51bnBhY2tlZFNoYXBlLHU9W24uaGVpZ2h0LG4ud2lkdGhdO2lmKG51bGwhPXUmJnIuQXJyYXlVdGlsLmFycmF5c0VxdWFsKG8sdSkpe2NvbnN0IG49YFxcbiAgICAgICAgICBmbG9hdCAke3R9KGludCByb3csIGludCBjb2wpIHtcXG4gICAgICAgICAgICB2ZWMyIHV2ID0gKHZlYzIocm93LCBjb2wpICsgaGFsZkNSKSAvIHZlYzIoJHt1WzFdfS4wLCAke3VbMF19LjApO1xcbiAgICAgICAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKCR7ZX0sIHV2KTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgYDtyZXR1cm4gbmV3IGkuR2xzbExpYlJvdXRpbmUobixbXCJjb29yZGluYXRlcy5zYW1wbGVUZXh0dXJlXCJdKX1jb25zdHtuZXdTaGFwZTpjLGtlcHREaW1zOmx9PSgwLGEuc3F1ZWV6ZVNoYXBlKShvKSxwPWM7aWYocC5sZW5ndGg8by5sZW5ndGgpe2NvbnN0IHI9KDAscy5zcXVlZXplSW5wdXRTaGFwZSkobyxwKSxhPUpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkobikpO2EudW5wYWNrZWRTaGFwZT1yO2NvbnN0IHU9W1wiY29sXCIsXCJyb3dcIl0sYz1gXFxuICAgICAgICAgICR7dGhpcy5nZXRVbnBhY2tlZFNhbXBsZXJGcm9tSW5wdXQodCxlLGEpLnJvdXRpbmVCb2R5fVxcbiAgICAgICAgICBmbG9hdCAke3R9KGludCByb3csIGludCBjb2wpIHtcXG4gICAgICAgICAgICByZXR1cm4gJHt0fSgkeygwLHMuZ2V0U3F1ZWV6ZWRQYXJhbXMpKHUsbCl9KTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgYDtyZXR1cm4gbmV3IGkuR2xzbExpYlJvdXRpbmUoYyxbXCJjb29yZGluYXRlcy5zYW1wbGVUZXh0dXJlXCJdKX1jb25zdCBmPXVbMV0sZD11WzBdO2lmKDE9PT1kKXtjb25zdCBuPWBcXG4gICAgICAgICAgZmxvYXQgJHt0fShpbnQgcm93LCBpbnQgY29sKSB7XFxuICAgICAgICAgICAgaW50IG9mZnNldF8ke2V9ID0gY29vcmRzVG9PZmZzZXQoVGV4Q29vcmRzLCAke2Z9LCAke2R9KTtcXG4gICAgICAgICAgICBmbG9hdCBpbmRleCA9IGRvdCh2ZWMzKHJvdywgY29sLCBvZmZzZXRfJHtlfSksIHZlYzMoJHtvWzFdfSwgMSwgMSkpO1xcbiAgICAgICAgICAgIHZlYzIgdXYgPSB2ZWMyKDAuNSwgKGluZGV4ICsgMC41KSAvICR7Zn0uMCk7XFxuICAgICAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoJHtlfSwgdXYpO1xcbiAgICAgICAgICB9XFxuICAgICAgICBgO3JldHVybiBuZXcgaS5HbHNsTGliUm91dGluZShuLFtcImNvb3JkaW5hdGVzLnNhbXBsZVRleHR1cmVcIixcImNvb3JkaW5hdGVzLmNvb3Jkc1RvT2Zmc2V0XCJdKX1pZigxPT09Zil7Y29uc3Qgbj1gXFxuICAgICAgICAgIGZsb2F0ICR7dH0oaW50IHJvdywgaW50IGNvbCkge1xcbiAgICAgICAgICAgIGludCBvZmZzZXRfJHtlfSA9IGNvb3Jkc1RvT2Zmc2V0KFRleENvb3JkcywgJHtmfSwgJHtkfSk7XFxuICAgICAgICAgICAgZmxvYXQgaW5kZXggPSBkb3QodmVjMyhyb3csIGNvbCwgb2Zmc2V0XyR7ZX0pLCB2ZWMzKCR7b1sxXX0sIDEsIDEpKTtcXG4gICAgICAgICAgICB2ZWMyIHV2ID0gdmVjMigoaW5kZXggKyAwLjUpIC8gJHtkfS4wLCAwLjUpO1xcbiAgICAgICAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKCR7ZX0sIHV2KTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgYDtyZXR1cm4gbmV3IGkuR2xzbExpYlJvdXRpbmUobixbXCJjb29yZGluYXRlcy5zYW1wbGVUZXh0dXJlXCIsXCJjb29yZGluYXRlcy5jb29yZHNUb09mZnNldFwiXSl9Y29uc3QgaD1gXFxuICAgICAgICBmbG9hdCAke3R9KGludCByb3csIGludCBjb2wpIHtcXG4gICAgICAgICAgaW50IGluZGV4ID0gY29sICogJHtvWzFdfSArIHJvdztcXG4gICAgICAgICAgdmVjMiB1diA9IHV2RnJvbUZsYXQoJHtmfSwgJHtkfSwgaW5kZXgpO1xcbiAgICAgICAgICByZXR1cm4gc2FtcGxlVGV4dHVyZSgke2V9LCB1dik7XFxuICAgICAgICB9XFxuICAgICAgYDtyZXR1cm4gbmV3IGkuR2xzbExpYlJvdXRpbmUoaCxbXCJjb29yZGluYXRlcy51dkZyb21GbGF0XCIsXCJjb29yZGluYXRlcy5zYW1wbGVUZXh0dXJlXCIsXCJjb29yZGluYXRlcy5jb29yZHNUb09mZnNldFwiXSl9Z2V0VW5wYWNrZWRTYW1wbGVyM0QodCxlLG4pe2NvbnN0IHI9bi51bnBhY2tlZFNoYXBlLG89clsxXSpyWzJdLHU9clsyXSx7bmV3U2hhcGU6YyxrZXB0RGltczpsfT0oMCxhLnNxdWVlemVTaGFwZSkocikscD1jO2lmKHAubGVuZ3RoPHIubGVuZ3RoKXtjb25zdCBvPSgwLHMuc3F1ZWV6ZUlucHV0U2hhcGUpKHIscCksYT1bXCJiYXRjaFwiLFwiY29sXCIsXCJyb3dcIl0sdT1KU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG4pKTt1LnVucGFja2VkU2hhcGU9bztjb25zdCBjPXRoaXMuZ2V0VW5wYWNrZWRTYW1wbGVyRnJvbUlucHV0KHQsZSx1KSxmPWwucmV2ZXJzZSgpLGQ9YFxcbiAgICAgICAgICAke2Mucm91dGluZUJvZHl9XFxuICAgICAgICAgIGZsb2F0ICR7dH0oaW50IGJhdGNoLCBpbnQgcm93LCBpbnQgY29sKSB7XFxuICAgICAgICAgICAgcmV0dXJuICR7dH0oJHsoMCxzLmdldFNxdWVlemVkUGFyYW1zKShhLGYpfSk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIGA7cmV0dXJuIG5ldyBpLkdsc2xMaWJSb3V0aW5lKGQsYy5kZXBlbmRlbmNpZXMpfWNvbnN0IGY9YFxcbiAgICAgICAgICBmbG9hdCAke3R9KGludCBkZXB0aCwgaW50IHJvdywgaW50IGNvbCkge1xcbiAgICAgICAgICAgIC8vIEV4cGxpY2l0bHkgdXNlIGludGVnZXIgb3BlcmF0aW9ucyBhcyBkb3QoKSBvbmx5IHdvcmtzIG9uIGZsb2F0cy5cXG4gICAgICAgICAgICBpbnQgaW5kZXggPSBkZXB0aCAqICR7b30gKyBjb2wgKiAke3V9ICsgcm93O1xcbiAgICAgICAgICAgIHZlYzIgdXYgPSB1dkZyb21GbGF0KCR7bi53aWR0aH0sICR7bi5oZWlnaHR9LCBpbmRleCk7XFxuICAgICAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoJHtlfSwgdXYpO1xcbiAgICAgICAgICB9XFxuICAgICAgYDtyZXR1cm4gbmV3IGkuR2xzbExpYlJvdXRpbmUoZixbXCJjb29yZGluYXRlcy51dkZyb21GbGF0XCIsXCJjb29yZGluYXRlcy5zYW1wbGVUZXh0dXJlXCIsXCJjb29yZGluYXRlcy5jb29yZHNUb09mZnNldFwiXSl9Z2V0VW5wYWNrZWRTYW1wbGVyNEQodCxlLG4pe2NvbnN0IHI9bi51bnBhY2tlZFNoYXBlLG89clszXSxhPXJbMl0qbyxzPWBcXG4gICAgICAgIGZsb2F0ICR7dH0oaW50IHJvdywgaW50IGNvbCwgaW50IGRlcHRoLCBpbnQgZGVwdGgyKSB7XFxuICAgICAgICAgIGludCBpbmRleCA9IHJvdyAqICR7clsxXSphfSArIGNvbCAqICR7YX0gK1xcbiAgICAgICAgICAgICAgZGVwdGgyICogJHtvfSArIGRlcHRoO1xcbiAgICAgICAgICB2ZWMyIHV2ID0gdXZGcm9tRmxhdCgke24ud2lkdGh9LCAke24uaGVpZ2h0fSwgaW5kZXgpO1xcbiAgICAgICAgICByZXR1cm4gc2FtcGxlVGV4dHVyZSgke2V9LCB1dik7XFxuICAgICAgICB9XFxuICAgICAgYDtyZXR1cm4gbmV3IGkuR2xzbExpYlJvdXRpbmUocyxbXCJjb29yZGluYXRlcy51dkZyb21GbGF0XCIsXCJjb29yZGluYXRlcy5zYW1wbGVUZXh0dXJlXCJdKX1nZXRVbnBhY2tlZFNhbXBsZXI1RCh0LGUsbil7Y29uc3Qgcj1uLnVucGFja2VkU2hhcGUsbz1yWzRdLHU9clszXSpvLGM9clsyXSp1LGw9clsxXSpjLHtuZXdTaGFwZTpwLGtlcHREaW1zOmZ9PSgwLGEuc3F1ZWV6ZVNoYXBlKShyKTtpZihwLmxlbmd0aDxyLmxlbmd0aCl7Y29uc3Qgbz0oMCxzLnNxdWVlemVJbnB1dFNoYXBlKShyLHApLGE9W1wicm93XCIsXCJjb2xcIixcImRlcHRoXCIsXCJkZXB0aDJcIixcImRlcHRoM1wiXSx1PUpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkobikpO3UudW5wYWNrZWRTaGFwZT1vO2NvbnN0IGM9YFxcbiAgICAgICAgICAke3RoaXMuZ2V0VW5wYWNrZWRTYW1wbGVyRnJvbUlucHV0KHQsZSx1KS5yb3V0aW5lQm9keX1cXG4gICAgICAgICAgZmxvYXQgJHt0fShpbnQgcm93LCBpbnQgY29sLCBpbnQgZGVwdGgsIGludCBkZXB0aDIsIGludCBkZXB0aDMpIHtcXG4gICAgICAgICAgICByZXR1cm4gJHt0fSgkeygwLHMuZ2V0U3F1ZWV6ZWRQYXJhbXMpKGEsZil9KTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgYDtyZXR1cm4gbmV3IGkuR2xzbExpYlJvdXRpbmUoYyxbXCJjb29yZGluYXRlcy5zYW1wbGVUZXh0dXJlXCIsXCJjb29yZGluYXRlcy51dkZyb21GbGF0XCJdKX1jb25zdCBkPWBcXG4gICAgICAgIGZsb2F0ICR7dH0oaW50IHJvdywgaW50IGNvbCwgaW50IGRlcHRoLCBpbnQgZGVwdGgyLCBpbnQgZGVwdGgzKSB7XFxuICAgICAgICAgIGludCBpbmRleCA9IHJvdyAqICR7bH0gKyBjb2wgKiAke2N9ICsgZGVwdGggKiAke3V9ICtcXG4gICAgICAgICAgZGVwdGgzICogJHtvfSArIGRlcHRoMjtcXG4gICAgICAgICAgdmVjMiB1diA9IHV2RnJvbUZsYXQoJHtuLndpZHRofSwgJHtuLmhlaWdodH0sIGluZGV4KTtcXG4gICAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoJHtlfSwgdXYpO1xcbiAgICAgICAgfVxcbiAgICAgIGA7cmV0dXJuIG5ldyBpLkdsc2xMaWJSb3V0aW5lKGQsW1wiY29vcmRpbmF0ZXMuc2FtcGxlVGV4dHVyZVwiLFwiY29vcmRpbmF0ZXMudXZGcm9tRmxhdFwiXSl9Z2V0VW5wYWNrZWRTYW1wbGVyNkQodCxlLG4pe2NvbnN0IHI9bi51bnBhY2tlZFNoYXBlLG89cls1XSx1PXJbNF0qbyxjPXJbM10qdSxsPXJbMl0qYyxwPXJbMV0qbCx7bmV3U2hhcGU6ZixrZXB0RGltczpkfT0oMCxhLnNxdWVlemVTaGFwZSkocik7aWYoZi5sZW5ndGg8ci5sZW5ndGgpe2NvbnN0IG89KDAscy5zcXVlZXplSW5wdXRTaGFwZSkocixmKSxhPVtcInJvd1wiLFwiY29sXCIsXCJkZXB0aFwiLFwiZGVwdGgyXCIsXCJkZXB0aDNcIixcImRlcHRoNFwiXSx1PUpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkobikpO3UudW5wYWNrZWRTaGFwZT1vO2NvbnN0IGM9YFxcbiAgICAgICAgICAgICR7dGhpcy5nZXRVbnBhY2tlZFNhbXBsZXJGcm9tSW5wdXQodCxlLHUpLnJvdXRpbmVCb2R5fVxcbiAgICAgICAgICAgIGZsb2F0ICR7dH0oaW50IHJvdywgaW50IGNvbCwgaW50IGRlcHRoLFxcbiAgICAgICAgICAgICAgaW50IGRlcHRoMiwgaW50IGRlcHRoMywgaW50IGRlcHRoNCkge1xcbiAgICAgICAgICAgICAgcmV0dXJuICR7dH0oJHsoMCxzLmdldFNxdWVlemVkUGFyYW1zKShhLGQpfSk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICBgO3JldHVybiBuZXcgaS5HbHNsTGliUm91dGluZShjLFtcImNvb3JkaW5hdGVzLnNhbXBsZVRleHR1cmVcIixcImNvb3JkaW5hdGVzLnV2RnJvbUZsYXRcIl0pfWNvbnN0IGg9YFxcbiAgICAgICAgICBmbG9hdCAke3R9KGludCByb3csIGludCBjb2wsIGludCBkZXB0aCxcXG4gICAgICAgICAgICBpbnQgZGVwdGgyLCBpbnQgZGVwdGgzLCBpbnQgZGVwdGg0KSB7XFxuICAgICAgICAgICAgaW50IGluZGV4ID0gcm93ICogJHtwfSArIGNvbCAqICR7bH0gKyBkZXB0aCAqICR7Y30gK1xcbiAgICAgICAgICAgIGRlcHRoMiAqICR7dX0gKyBkZXB0aDMgKiAke299ICsgZGVwdGg0O1xcbiAgICAgICAgICAgIHZlYzIgdXYgPSB1dkZyb21GbGF0KCR7bi53aWR0aH0sICR7bi5oZWlnaHR9LCBpbmRleCk7XFxuICAgICAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoJHtlfSwgdXYpO1xcbiAgICAgICAgICB9XFxuICAgICAgICBgO3JldHVybiBuZXcgaS5HbHNsTGliUm91dGluZShoLFtcImNvb3JkaW5hdGVzLnV2RnJvbUZsYXRcIixcImNvb3JkaW5hdGVzLnNhbXBsZVRleHR1cmVcIixcImNvb3JkaW5hdGVzLmNvb3Jkc1RvT2Zmc2V0XCJdKX10b1ZlYygpe2NvbnN0IHQ9dGhpcy5jb250ZXh0Lm91dHB1dFRleHR1cmVMYXlvdXQsZT10LnNoYXBlLmxlbmd0aCxuPXQuc3RyaWRlcyxyPXQud2lkdGgsbz10LmhlaWdodCxhPVtdO2ZvcihsZXQgdD0wO3Q8ZS0xOysrdClhLnB1c2goYFxcbiAgICAgICAgY1ske3R9XSA9IG9mZnNldCAvICR7blt0XX07YCksYS5wdXNoKGBcXG4gICAgICAgIG9mZnNldCAtPSBjWyR7dH1dICogJHtuW3RdfTtgKTthLnB1c2goYFxcbiAgICAgICAgY1ske2UtMX1dID0gb2Zmc2V0O2ApO2NvbnN0IHM9YFxcbiAgICAgIHZvaWQgdG9WZWModmVjMiB0ZXhDb29yZHMsIG91dCBpbnQgY1ske2V9XSkge1xcbiAgICAgICAgaW50IG9mZnNldCA9IGNvb3Jkc1RvT2Zmc2V0KHRleENvb3JkcywgJHtyfSwgJHtvfSk7XFxuICAgICAgICAke2Euam9pbihcIlwiKX1cXG4gICAgICB9XFxuICAgICAgdm9pZCB0b1ZlYyhpbnQgb2Zmc2V0LCBvdXQgaW50IGNbJHtlfV0pIHtcXG4gICAgICAgICR7YS5qb2luKFwiXCIpfVxcbiAgICAgIH1cXG4gICAgYDtyZXR1cm57dG9WZWM6bmV3IGkuR2xzbExpYlJvdXRpbmUocyxbXCJjb29yZGluYXRlcy5jb29yZHNUb09mZnNldFwiXSl9fXZhbHVlRnJvbSgpe2NvbnN0IHQ9e307cmV0dXJuIHRoaXMuY29udGV4dC5wcm9ncmFtSW5mby5pbnB1dE5hbWVzLmZvckVhY2goKChlLG4pPT57Y29uc3Qgcj10aGlzLmNvbnRleHQuaW5wdXRUZXh0dXJlTGF5b3V0c1tuXSxvPShyLnVucGFja2VkU2hhcGUubGVuZ3RoPjA/ci51bnBhY2tlZFNoYXBlOnIuc2hhcGUpLmxlbmd0aDtsZXQgYT1gXyR7ZX1gO3RbYV09bmV3IGkuR2xzbExpYlJvdXRpbmUodGhpcy5nZXRWYWx1ZUZyb21TaW5nbGUoZSxvLHIud2lkdGgsci5oZWlnaHQsITEpLFtgc2hhcGVVdGlscy5pbmRpY2VzVG9PZmZzZXQke2F9YCxcImNvb3JkaW5hdGVzLm9mZnNldFRvQ29vcmRzXCIsXCJmcmFnY29sb3IuZ2V0Q29sb3JBc0Zsb2F0XCJdKSxhKz1cIl9UXCIsdFthXT1uZXcgaS5HbHNsTGliUm91dGluZSh0aGlzLmdldFZhbHVlRnJvbVNpbmdsZShlLG8sci53aWR0aCxyLmhlaWdodCwhMCksW2BzaGFwZVV0aWxzLmluZGljZXNUb09mZnNldCR7YX1gLFwiY29vcmRpbmF0ZXMub2Zmc2V0VG9Db29yZHNcIixcImZyYWdjb2xvci5nZXRDb2xvckFzRmxvYXRcIl0pfSkpLHR9Z2V0VmFsdWVGcm9tU2luZ2xlKHQsZSxuLHIsaSl7bGV0IGE9YF8ke3R9YDtyZXR1cm4gaSYmKGErPVwiX1RcIiksYFxcbiAgICAgICAgZmxvYXQgJHthfShpbnQgbVske2V9XSkge1xcbiAgICAgICAgICBpbnQgb2Zmc2V0ID0gaW5kaWNlc1RvT2Zmc2V0JHthfShtKTtcXG4gICAgICAgICAgdmVjMiBjb29yZHMgPSBvZmZzZXRUb0Nvb3JkcyhvZmZzZXQsICR7bn0sICR7cn0pO1xcbiAgICAgICAgICBmbG9hdCB2YWx1ZSA9IGdldENvbG9yQXNGbG9hdCgkeygwLG8uZ2V0R2xzbCkodGhpcy5jb250ZXh0LmdsQ29udGV4dC52ZXJzaW9uKS50ZXh0dXJlMkR9KCR7dH0sIGNvb3JkcykpO1xcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XFxuICAgICAgICB9XFxuICAgICAgICBgfWdldFBhY2tlZFZhbHVlRnJvbSh0LGUsbixyLGkpe2xldCBhPWBfJHt0fV9QYWNrYDtyZXR1cm4gaSYmKGErPVwiX1RcIiksYFxcbiAgICAgICAgdmVjNCAke2F9KGludCBtWyR7ZX1dKSB7XFxuICAgICAgICAgIGludCBvZmZzZXQgPSBpbmRpY2VzVG9PZmZzZXRfJHt0fShtKTtcXG4gICAgICAgICAgdmVjMiBjb29yZHMgPSBvZmZzZXRUb0Nvb3JkcyhvZmZzZXQsICR7bn0sICR7cn0pO1xcbiAgICAgICAgICByZXR1cm4gJHsoMCxvLmdldEdsc2wpKHRoaXMuY29udGV4dC5nbENvbnRleHQudmVyc2lvbikudGV4dHVyZTJEfSgke3R9LCBjb29yZHMpO1xcbiAgICAgICAgfVxcbiAgICAgICAgYH19ZS5Db29yZHNHbHNsTGliPXV9LDg1MjA6KHQsZSk9PntcInVzZSBzdHJpY3RcIjt2YXIgbjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLlRvcG9sb2dpY2FsU29ydEdsc2xSb3V0aW5lcz1lLkdsc2xMaWJSb3V0aW5lTm9kZT1lLkdsc2xMaWJSb3V0aW5lPWUuR2xzbExpYj1lLkdsc2xDb250ZXh0PWUuRnVuY3Rpb25UeXBlPXZvaWQgMCwobj1lLkZ1bmN0aW9uVHlwZXx8KGUuRnVuY3Rpb25UeXBlPXt9KSlbbi5WYWx1ZUJhc2VkPTBdPVwiVmFsdWVCYXNlZFwiLG5bbi5Qb3NpdGlvbmFsPTFdPVwiUG9zaXRpb25hbFwiLGUuR2xzbENvbnRleHQ9Y2xhc3N7Y29uc3RydWN0b3IodCxlLG4scil7dGhpcy5nbENvbnRleHQ9dCx0aGlzLnByb2dyYW1JbmZvPWUsdGhpcy5pbnB1dFRleHR1cmVMYXlvdXRzPW4sdGhpcy5vdXRwdXRUZXh0dXJlTGF5b3V0PXJ9fSxlLkdsc2xMaWI9Y2xhc3N7Y29uc3RydWN0b3IodCl7dGhpcy5jb250ZXh0PXR9fSxlLkdsc2xMaWJSb3V0aW5lPWNsYXNze2NvbnN0cnVjdG9yKHQsZSl7dGhpcy5yb3V0aW5lQm9keT10LHRoaXMuZGVwZW5kZW5jaWVzPWV9fSxlLkdsc2xMaWJSb3V0aW5lTm9kZT1jbGFzc3tjb25zdHJ1Y3Rvcih0LGUsbil7dGhpcy5uYW1lPXQsdGhpcy5kZXBlbmRlbmNpZXM9bnx8W10sZSYmKHRoaXMucm91dGluZUJvZHk9ZSl9YWRkRGVwZW5kZW5jeSh0KXt0JiZ0aGlzLmRlcGVuZGVuY2llcy5wdXNoKHQpfX0sZS5Ub3BvbG9naWNhbFNvcnRHbHNsUm91dGluZXM9Y2xhc3N7c3RhdGljIHJldHVybk9yZGVyZWROb2Rlcyh0KXtpZighdHx8MD09PXQubGVuZ3RoKXJldHVybltdO2lmKDE9PT10Lmxlbmd0aClyZXR1cm4gdDtjb25zdCBlPW5ldyBTZXQsbj1uZXcgU2V0LHI9bmV3IEFycmF5O3JldHVybiB0aGlzLmNyZWF0ZU9yZGVyZWROb2Rlcyh0LGUsbixyKSxyfXN0YXRpYyBjcmVhdGVPcmRlcmVkTm9kZXModCxlLG4scil7Zm9yKGxldCBpPTA7aTx0Lmxlbmd0aDsrK2kpdGhpcy5kZnNUcmF2ZXJzZSh0W2ldLGUsbixyKX1zdGF0aWMgZGZzVHJhdmVyc2UodCxlLG4scil7aWYoIXR8fG4uaGFzKHQubmFtZSkpcmV0dXJuO2lmKGUuaGFzKHQubmFtZSkpdGhyb3cgbmV3IEVycm9yKFwiQ3ljbGljIGRlcGVuZGVuY3kgZGV0ZWN0ZWQuIENhbid0IHRvcG9sb2dpY2FsbHkgc29ydCByb3V0aW5lcyBuZWVkZWQgZm9yIHNoYWRlci5cIik7ZS5hZGQodC5uYW1lKTtjb25zdCBpPXQuZGVwZW5kZW5jaWVzO2lmKGkmJmkubGVuZ3RoPjApZm9yKGxldCB0PTA7dDxpLmxlbmd0aDsrK3QpdGhpcy5kZnNUcmF2ZXJzZShpW3RdLGUsbixyKTtyLnB1c2godCksbi5hZGQodC5uYW1lKSxlLmRlbGV0ZSh0Lm5hbWUpfX19LDczNDE6KHQsZSxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUuRW5jb2RpbmdHbHNsTGliPXZvaWQgMDtjb25zdCByPW4oODUyMCk7Y2xhc3MgaSBleHRlbmRzIHIuR2xzbExpYntjb25zdHJ1Y3Rvcih0KXtzdXBlcih0KX1nZXRGdW5jdGlvbnMoKXtyZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LHRoaXMuZW5jb2RlRmxvYXQzMigpKSx0aGlzLmRlY29kZUZsb2F0MzIoKSl9Z2V0Q3VzdG9tVHlwZXMoKXtyZXR1cm57fX1lbmNvZGVGbG9hdDMyKCl7cmV0dXJue2VuY29kZTpuZXcgci5HbHNsTGliUm91dGluZShcImhpZ2hwIHZlYzQgZW5jb2RlKGhpZ2hwIGZsb2F0IGYpIHtcXG4gICAgICAgIHJldHVybiB2ZWM0KGYsIDAuMCwgMC4wLCAwLjApO1xcbiAgICAgIH1cXG4gICAgICAgIFwiKX19ZGVjb2RlRmxvYXQzMigpe3JldHVybntkZWNvZGU6bmV3IHIuR2xzbExpYlJvdXRpbmUoXCJoaWdocCBmbG9hdCBkZWNvZGUoaGlnaHAgdmVjNCByZ2JhKSB7XFxuICAgICAgICByZXR1cm4gcmdiYS5yO1xcbiAgICAgIH1cXG4gICAgICAgIFwiKX19ZW5jb2RlVWludDgoKXtjb25zdCB0PWkuaXNMaXR0bGVFbmRpYW4oKT9cInJnYmEucmdiYT1yZ2JhLmFiZ3I7XCI6XCJcIjtyZXR1cm57ZW5jb2RlOm5ldyByLkdsc2xMaWJSb3V0aW5lKGBcXG4gICAgICBoaWdocCB2ZWM0IGVuY29kZShoaWdocCBmbG9hdCBmKSB7XFxuICAgICAgICBoaWdocCBmbG9hdCBGID0gYWJzKGYpO1xcbiAgICAgICAgaGlnaHAgZmxvYXQgU2lnbiA9IHN0ZXAoMC4wLC1mKTtcXG4gICAgICAgIGhpZ2hwIGZsb2F0IEV4cG9uZW50ID0gZmxvb3IobG9nMihGKSk7XFxuICAgICAgICBoaWdocCBmbG9hdCBNYW50aXNzYSA9IChleHAyKC0gRXhwb25lbnQpICogRik7XFxuICAgICAgICBFeHBvbmVudCA9IGZsb29yKGxvZzIoRikgKyAxMjcuMCkgKyBmbG9vcihsb2cyKE1hbnRpc3NhKSk7XFxuICAgICAgICBoaWdocCB2ZWM0IHJnYmE7XFxuICAgICAgICByZ2JhWzBdID0gMTI4LjAgKiBTaWduICArIGZsb29yKEV4cG9uZW50KmV4cDIoLTEuMCkpO1xcbiAgICAgICAgcmdiYVsxXSA9IDEyOC4wICogbW9kKEV4cG9uZW50LDIuMCkgKyBtb2QoZmxvb3IoTWFudGlzc2EqMTI4LjApLDEyOC4wKTtcXG4gICAgICAgIHJnYmFbMl0gPSBmbG9vcihtb2QoZmxvb3IoTWFudGlzc2EqZXhwMigyMy4wIC04LjApKSxleHAyKDguMCkpKTtcXG4gICAgICAgIHJnYmFbM10gPSBmbG9vcihleHAyKDIzLjApKm1vZChNYW50aXNzYSxleHAyKC0xNS4wKSkpO1xcbiAgICAgICAgJHt0fVxcbiAgICAgICAgcmdiYSA9IHJnYmEgLyAyNTUuMDsgLy8gdmFsdWVzIG5lZWQgdG8gYmUgbm9ybWFsaXplZCB0byBbMCwxXVxcbiAgICAgICAgcmV0dXJuIHJnYmE7XFxuICAgIH1cXG4gICAgICAgIGApfX1kZWNvZGVVaW50OCgpe2NvbnN0IHQ9aS5pc0xpdHRsZUVuZGlhbigpP1wicmdiYS5yZ2JhPXJnYmEuYWJncjtcIjpcIlwiO3JldHVybntkZWNvZGU6bmV3IHIuR2xzbExpYlJvdXRpbmUoYFxcbiAgICAgICAgaGlnaHAgZmxvYXQgZGVjb2RlKGhpZ2hwIHZlYzQgcmdiYSkge1xcbiAgICAgICAgICByZ2JhID0gcmdiYSAqIDI1NS4wOyAvLyB2YWx1ZXMgbmVlZCB0byBiZSBkZS1ub3JtYWxpemVkIGZyb20gWzAsMV0gdG8gWzAsMjU1XVxcbiAgICAgICAgICAke3R9XFxuICAgICAgICAgIGhpZ2hwIGZsb2F0IFNpZ24gPSAxLjAgLSBzdGVwKDEyOC4wLHJnYmFbMF0pKjIuMDtcXG4gICAgICAgICAgaGlnaHAgZmxvYXQgRXhwb25lbnQgPSAyLjAgKiBtb2QocmdiYVswXSwxMjguMCkgKyBzdGVwKDEyOC4wLHJnYmFbMV0pIC0gMTI3LjA7XFxuICAgICAgICAgIGhpZ2hwIGZsb2F0IE1hbnRpc3NhID0gbW9kKHJnYmFbMV0sMTI4LjApKjY1NTM2LjAgKyByZ2JhWzJdKjI1Ni4wICtyZ2JhWzNdICsgZmxvYXQoMHg4MDAwMDApO1xcbiAgICAgICAgICBoaWdocCBmbG9hdCBSZXN1bHQgPSAgU2lnbiAqIGV4cDIoRXhwb25lbnQpICogKE1hbnRpc3NhICogZXhwMigtMjMuMCApKTtcXG4gICAgICAgICAgcmV0dXJuIFJlc3VsdDtcXG4gICAgICB9XFxuICAgICAgICBgKX19c3RhdGljIGlzTGl0dGxlRW5kaWFuKCl7Y29uc3QgdD1uZXcgQXJyYXlCdWZmZXIoNCksZT1uZXcgVWludDMyQXJyYXkodCksbj1uZXcgVWludDhBcnJheSh0KTtpZihlWzBdPTM3MzU5Mjg1NTksMjM5PT09blswXSlyZXR1cm4hMDtpZigyMjI9PT1uWzBdKXJldHVybiExO3Rocm93IG5ldyBFcnJvcihcInVua25vd24gZW5kaWFubmVzc1wiKX19ZS5FbmNvZGluZ0dsc2xMaWI9aX0sOTg5NDoodCxlLG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5GcmFnQ29sb3JHbHNsTGliPXZvaWQgMDtjb25zdCByPW4oODUyMCksaT1uKDUwNjApO2NsYXNzIG8gZXh0ZW5kcyByLkdsc2xMaWJ7Y29uc3RydWN0b3IodCl7c3VwZXIodCl9Z2V0RnVuY3Rpb25zKCl7cmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSx0aGlzLnNldEZyYWdDb2xvcigpKSx0aGlzLmdldENvbG9yQXNGbG9hdCgpKX1nZXRDdXN0b21UeXBlcygpe3JldHVybnt9fXNldEZyYWdDb2xvcigpe2NvbnN0IHQ9KDAsaS5nZXRHbHNsKSh0aGlzLmNvbnRleHQuZ2xDb250ZXh0LnZlcnNpb24pO3JldHVybntzZXRGcmFnQ29sb3I6bmV3IHIuR2xzbExpYlJvdXRpbmUoYFxcbiAgICAgICAgdm9pZCBzZXRGcmFnQ29sb3IoZmxvYXQgdmFsdWUpIHtcXG4gICAgICAgICAgICAke3Qub3V0cHV0fSA9IGVuY29kZSh2YWx1ZSk7XFxuICAgICAgICB9XFxuICAgICAgICBgLFtcImVuY29kaW5nLmVuY29kZVwiXSl9fWdldENvbG9yQXNGbG9hdCgpe3JldHVybntnZXRDb2xvckFzRmxvYXQ6bmV3IHIuR2xzbExpYlJvdXRpbmUoXCJcXG4gICAgICAgIGZsb2F0IGdldENvbG9yQXNGbG9hdCh2ZWM0IGNvbG9yKSB7XFxuICAgICAgICAgICAgcmV0dXJuIGRlY29kZShjb2xvcik7XFxuICAgICAgICB9XFxuICAgICAgICBcIixbXCJlbmNvZGluZy5kZWNvZGVcIl0pfX19ZS5GcmFnQ29sb3JHbHNsTGliPW99LDI4NDg6KHQsZSk9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLnJlcGxhY2VJbmxpbmVzPXZvaWQgMDtjb25zdCBuPS9AaW5saW5lW1xcc1xcblxccl0rKFxcdyspW1xcc1xcblxccl0rKFswLTlhLXpBLVpfXSspXFxzKlxcKChbXildKilcXClcXHMqeygoW159XXxbXFxuXFxyXSkqKX0vZ207ZS5yZXBsYWNlSW5saW5lcz1mdW5jdGlvbih0KXtjb25zdCBlPXt9O2xldCByO2Zvcig7bnVsbCE9PShyPW4uZXhlYyh0KSk7KXtjb25zdCB0PXJbM10uc3BsaXQoXCIsXCIpLm1hcCgodD0+e2NvbnN0IGU9dC50cmltKCkuc3BsaXQoXCIgXCIpO3JldHVybiBlJiYyPT09ZS5sZW5ndGg/e3R5cGU6ZVswXSxuYW1lOmVbMV19Om51bGx9KSkuZmlsdGVyKCh0PT5udWxsIT09dCkpO2VbclsyXV09e3BhcmFtczp0LGJvZHk6cls0XX19Zm9yKGNvbnN0IG4gaW4gZSl7Y29uc3QgaT1cIihcXFxcdyspP1xcXFxzKyhbXzAtOWEtekEtWl0rKVxcXFxzKz1cXFxccytfX0ZVTkNfX1xcXFwoKC4qKVxcXFwpXFxcXHMqO1wiLnJlcGxhY2UoXCJfX0ZVTkNfX1wiLG4pLG89bmV3IFJlZ0V4cChpLFwiZ21cIik7Zm9yKDtudWxsIT09KHI9by5leGVjKHQpKTspe2NvbnN0IGk9clsxXSxvPXJbMl0sYT1yWzNdLnNwbGl0KFwiLFwiKSxzPWk/YCR7aX0gJHtvfTtgOlwiXCI7bGV0IHU9ZVtuXS5ib2R5LGM9XCJcIjtlW25dLnBhcmFtcy5mb3JFYWNoKCgodCxlKT0+e3QmJihjKz1gJHt0LnR5cGV9ICR7dC5uYW1lfSA9ICR7YVtlXX07XFxuYCl9KSksdT1gJHtjfVxcbiAke3V9YCx1PXUucmVwbGFjZShcInJldHVyblwiLGAke299ID0gYCk7Y29uc3QgbD1gXFxuICAgICAgJHtzfVxcbiAgICAgIHtcXG4gICAgICAgICR7dX1cXG4gICAgICB9XFxuICAgICAgYDt0PXQucmVwbGFjZShyWzBdLGwpfX1yZXR1cm4gdC5yZXBsYWNlKG4sXCJcIil9fSw4ODc5Oih0LGUsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLkdsc2xQcmVwcm9jZXNzb3I9dm9pZCAwO2NvbnN0IHI9big4NTIwKSxpPW4oMjg0OCksbz1uKDU0ODMpLGE9big1MDYwKTtlLkdsc2xQcmVwcm9jZXNzb3I9Y2xhc3N7Y29uc3RydWN0b3IodCxlLG4saSl7dGhpcy5saWJzPXt9LHRoaXMuZ2xzbExpYlJvdXRpbmVEZXBlbmRlbmN5R3JhcGg9e30sdGhpcy5jb250ZXh0PW5ldyByLkdsc2xDb250ZXh0KHQsZSxuLGkpLE9iamVjdC5rZXlzKG8uZ2xzbFJlZ2lzdHJ5KS5mb3JFYWNoKCh0PT57Y29uc3QgZT1uZXcgby5nbHNsUmVnaXN0cnlbdF0odGhpcy5jb250ZXh0KTt0aGlzLmxpYnNbdF09ZX0pKTtjb25zdCBhPXRoaXMuZ2xzbExpYlJvdXRpbmVEZXBlbmRlbmN5R3JhcGg7Zm9yKGNvbnN0IHQgaW4gdGhpcy5saWJzKXtjb25zdCBlPXRoaXMubGlic1t0XS5nZXRGdW5jdGlvbnMoKTtmb3IoY29uc3QgbiBpbiBlKXtjb25zdCBpPXQrXCIuXCIrbjtsZXQgbzthW2ldPyhvPWFbaV0sby5yb3V0aW5lQm9keT1lW25dLnJvdXRpbmVCb2R5KToobz1uZXcgci5HbHNsTGliUm91dGluZU5vZGUoaSxlW25dLnJvdXRpbmVCb2R5KSxhW2ldPW8pO2NvbnN0IHM9ZVtuXS5kZXBlbmRlbmNpZXM7aWYocylmb3IobGV0IHQ9MDt0PHMubGVuZ3RoOysrdClpZihhW3NbdF1dKW8uYWRkRGVwZW5kZW5jeShhW3NbdF1dKTtlbHNle2NvbnN0IGU9bmV3IHIuR2xzbExpYlJvdXRpbmVOb2RlKHNbdF0pO2Fbc1t0XV09ZSxvLmFkZERlcGVuZGVuY3koZSl9fX19cHJlcHJvY2Vzcygpe2NvbnN0IHQ9dGhpcy5jb250ZXh0LnByb2dyYW1JbmZvO2xldCBlPXQuc2hhZGVyU291cmNlO3JldHVybiB0aGlzLmNvbnRleHQucHJvZ3JhbUluZm8uaGFzTWFpbnx8KGU9YCR7ZX1cXG4gICAgICAkeygwLGEuZ2V0RGVmYXVsdEZyYWdTaGFkZXJNYWluKSh0aGlzLmNvbnRleHQuZ2xDb250ZXh0LnZlcnNpb24sdGhpcy5jb250ZXh0Lm91dHB1dFRleHR1cmVMYXlvdXQuc2hhcGUubGVuZ3RoKX1gKSxlPSgwLGkucmVwbGFjZUlubGluZXMpKGUpLGAkeygwLGEuZ2V0RnJhZ1NoYWRlclByZWFtYmxlKSh0aGlzLmNvbnRleHQuZ2xDb250ZXh0LnZlcnNpb24pfVxcbiAgICAke3RoaXMuZ2V0VW5pZm9ybXModC5pbnB1dE5hbWVzLHQudmFyaWFibGVzKX1cXG4gICAgJHt0aGlzLmdldEltcG9ydHMoZSl9XFxuICAgICR7ZX1gfWdldEltcG9ydHModCl7Y29uc3QgZT10aGlzLnNlbGVjdEdsc2xMaWJSb3V0aW5lc1RvQmVJbmNsdWRlZCh0KTtpZigwPT09ZS5sZW5ndGgpcmV0dXJuXCJcIjtsZXQgbj1cIlwiO2ZvcihsZXQgdD0wO3Q8ZS5sZW5ndGg7Kyt0KXtpZighZVt0XS5yb3V0aW5lQm9keSl0aHJvdyBuZXcgRXJyb3IoYE1pc3NpbmcgYm9keSBmb3IgdGhlIEdsc2wgTGlicmFyeSByb3V0aW5lOiAke2VbdF0ubmFtZX1gKTtuKz1lW3RdLnJvdXRpbmVCb2R5K1wiXFxuXCJ9cmV0dXJuIG59c2VsZWN0R2xzbExpYlJvdXRpbmVzVG9CZUluY2x1ZGVkKHQpe2NvbnN0IGU9W107cmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuZ2xzbExpYlJvdXRpbmVEZXBlbmRlbmN5R3JhcGgpLmZvckVhY2goKG49Pntjb25zdCByPW4uc3BsaXQoXCIuXCIpWzFdOy0xIT09dC5pbmRleE9mKHIpJiZlLnB1c2godGhpcy5nbHNsTGliUm91dGluZURlcGVuZGVuY3lHcmFwaFtuXSl9KSksci5Ub3BvbG9naWNhbFNvcnRHbHNsUm91dGluZXMucmV0dXJuT3JkZXJlZE5vZGVzKGUpfWdldFVuaWZvcm1zKHQsZSl7Y29uc3Qgbj1bXTtpZih0KWZvcihjb25zdCBlIG9mIHQpbi5wdXNoKGB1bmlmb3JtIHNhbXBsZXIyRCAke2V9O2ApO2lmKGUpZm9yKGNvbnN0IHQgb2YgZSluLnB1c2goYHVuaWZvcm0gJHt0LnR5cGV9ICR7dC5uYW1lfSR7dC5hcnJheUxlbmd0aD9gWyR7dC5hcnJheUxlbmd0aH1dYDpcIlwifTtgKTtyZXR1cm4gbi5qb2luKFwiXFxuXCIpfX19LDU0ODM6KHQsZSxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUuZ2xzbFJlZ2lzdHJ5PXZvaWQgMDtjb25zdCByPW4oNTEwNyksaT1uKDczNDEpLG89big5ODk0KSxhPW4oMjY1NSkscz1uKDM4OTEpO2UuZ2xzbFJlZ2lzdHJ5PXtlbmNvZGluZzppLkVuY29kaW5nR2xzbExpYixmcmFnY29sb3I6by5GcmFnQ29sb3JHbHNsTGliLHZlYzpzLlZlY0dsc2xMaWIsc2hhcGVVdGlsczphLlNoYXBlVXRpbHNHbHNsTGliLGNvb3JkaW5hdGVzOnIuQ29vcmRzR2xzbExpYn19LDI2NTU6KHQsZSxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUuU2hhcGVVdGlsc0dsc2xMaWI9dm9pZCAwO2NvbnN0IHI9big4NTIwKTtjbGFzcyBpIGV4dGVuZHMgci5HbHNsTGlie2NvbnN0cnVjdG9yKHQpe3N1cGVyKHQpfWdldEZ1bmN0aW9ucygpe3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sdGhpcy5iY2FzdEluZGV4KCkpLHRoaXMuYmNhc3RNYXRtdWxJbmRleCgpKSx0aGlzLm9mZnNldFRvSW5kaWNlcygpKSx0aGlzLmluZGljZXNUb09mZnNldCgpKSx0aGlzLmluY3JlbWVudEluZGljZXMoKSl9Z2V0Q3VzdG9tVHlwZXMoKXtyZXR1cm57fX1iY2FzdEluZGV4KCl7Y29uc3QgdD10aGlzLmNvbnRleHQub3V0cHV0VGV4dHVyZUxheW91dC5zaGFwZS5sZW5ndGgsZT17fTtyZXR1cm4gdGhpcy5jb250ZXh0LnByb2dyYW1JbmZvLmlucHV0TmFtZXMuZm9yRWFjaCgoKG4saSk9Pntjb25zdCBvPXRoaXMuY29udGV4dC5pbnB1dFRleHR1cmVMYXlvdXRzW2ldLnVucGFja2VkU2hhcGU7aWYoby5sZW5ndGg8PXQpe2NvbnN0IGk9by5sZW5ndGgsYT10LWkscz1gYmNhc3RJbmRpY2VzXyR7bn1gO2xldCB1PVwiXCI7Zm9yKGxldCB0PTA7dDxpOysrdCl1Kz1gXFxuICAgICAgICAgIHJlYWxJbmRpY2VzWyR7dH1dID0gaW50KCBtb2QoZmxvYXQoYmNhc3RlZEluZGljZXNbJHthK3R9XSksICR7b1t0XX0uMCkgKTtcXG4gICAgICAgICAgYDtjb25zdCBjPWBcXG4gICAgICAgIHZvaWQgJHtzfSAoaW50IGJjYXN0ZWRJbmRpY2VzWyR7dH1dLCBvdXQgaW50IHJlYWxJbmRpY2VzWyR7aX1dKSB7XFxuICAgICAgICAgICR7dX1cXG4gICAgICAgIH1cXG4gICAgICAgIGA7ZVtzXT1uZXcgci5HbHNsTGliUm91dGluZShjKX19KSksZX1iY2FzdE1hdG11bEluZGV4KCl7Y29uc3QgdD10aGlzLmNvbnRleHQub3V0cHV0VGV4dHVyZUxheW91dC5zaGFwZS5sZW5ndGgsZT17fTtyZXR1cm4gdGhpcy5jb250ZXh0LnByb2dyYW1JbmZvLmlucHV0TmFtZXMuZm9yRWFjaCgoKG4saSk9Pntjb25zdCBvPXRoaXMuY29udGV4dC5pbnB1dFRleHR1cmVMYXlvdXRzW2ldLnNoYXBlO2lmKCEoby5sZW5ndGg8Mnx8by5sZW5ndGg+dCkpe2NvbnN0IGk9by5sZW5ndGgsYT10LWkscz1gYmNhc3RNYXRtdWxJbmRpY2VzXyR7bn1gO2xldCB1PVwiXCI7Zm9yKGxldCB0PTA7dDxpLTI7Kyt0KXUrPWBcXG4gICAgICAgICAgcmVhbEluZGljZXNbJHt0fV0gPSBpbnQoIG1vZChmbG9hdChiY2FzdGVkSW5kaWNlc1ske2ErdH1dKSwgJHtvW3RdfS4wKSApO1xcbiAgICAgICAgICBgO2NvbnN0IGM9YFxcbiAgICAgICAgdm9pZCAke3N9KGludCBiY2FzdGVkSW5kaWNlc1ske3R9XSwgb3V0IGludCByZWFsSW5kaWNlc1ske2l9XSkge1xcbiAgICAgICAgICAke3V9XFxuICAgICAgICAgIHJlYWxJbmRpY2VzWyR7aS0xfV0gPSBiY2FzdGVkSW5kaWNlc1ske3QtMX1dO1xcbiAgICAgICAgICByZWFsSW5kaWNlc1ske2ktMn1dID0gYmNhc3RlZEluZGljZXNbJHt0LTJ9XTtcXG4gICAgICAgIH1cXG4gICAgICAgIGA7ZVtzXT1uZXcgci5HbHNsTGliUm91dGluZShjKX19KSksZX1pbmRpY2VzVG9PZmZzZXQoKXtjb25zdCB0PXt9O3JldHVybiB0aGlzLmNvbnRleHQucHJvZ3JhbUluZm8uaW5wdXROYW1lcy5mb3JFYWNoKCgoZSxuKT0+e2NvbnN0IG89dGhpcy5jb250ZXh0LmlucHV0VGV4dHVyZUxheW91dHNbbl0uc2hhcGUsYT10aGlzLmNvbnRleHQuaW5wdXRUZXh0dXJlTGF5b3V0c1tuXS5zdHJpZGVzLHM9by5sZW5ndGg7bGV0IHU9YGluZGljZXNUb09mZnNldF8ke2V9YDt0W3VdPW5ldyByLkdsc2xMaWJSb3V0aW5lKGkuaW5kZXhUb09mZnNldFNpbmdsZSh1LHMsYSkpLHU9YGluZGljZXNUb09mZnNldF8ke2V9X1RgLHRbdV09bmV3IHIuR2xzbExpYlJvdXRpbmUoaS5pbmRleFRvT2Zmc2V0U2luZ2xlKHUscyxhLnNsaWNlKCkucmV2ZXJzZSgpKSl9KSksdH1zdGF0aWMgaW5kZXhUb09mZnNldFNpbmdsZSh0LGUsbil7bGV0IHI9XCJcIjtmb3IobGV0IHQ9ZS0xO3Q+PTA7LS10KXIrPWBcXG4gICAgICAgIG9mZnNldCArPSBpbmRpY2VzWyR7dH1dICogJHtuW3RdfTtcXG4gICAgICAgIGA7cmV0dXJuYFxcbiAgICAgIGludCAke3R9KGludCBpbmRpY2VzWyR7ZX1dKSB7XFxuICAgICAgICBpbnQgb2Zmc2V0ID0gMDtcXG4gICAgICAgICR7cn1cXG4gICAgICAgIHJldHVybiBvZmZzZXQ7XFxuICAgICAgfVxcbiAgICAgIGB9b2Zmc2V0VG9JbmRpY2VzKCl7Y29uc3QgdD17fTtyZXR1cm4gdGhpcy5jb250ZXh0LnByb2dyYW1JbmZvLmlucHV0TmFtZXMuZm9yRWFjaCgoKGUsbik9Pntjb25zdCBvPXRoaXMuY29udGV4dC5pbnB1dFRleHR1cmVMYXlvdXRzW25dLnNoYXBlLGE9dGhpcy5jb250ZXh0LmlucHV0VGV4dHVyZUxheW91dHNbbl0uc3RyaWRlcyxzPW8ubGVuZ3RoO2xldCB1PWBvZmZzZXRUb0luZGljZXNfJHtlfWA7dFt1XT1uZXcgci5HbHNsTGliUm91dGluZShpLm9mZnNldFRvSW5kaWNlc1NpbmdsZSh1LHMsYSkpLHU9YG9mZnNldFRvSW5kaWNlc18ke2V9X1RgLHRbdV09bmV3IHIuR2xzbExpYlJvdXRpbmUoaS5vZmZzZXRUb0luZGljZXNTaW5nbGUodSxzLGEuc2xpY2UoKS5yZXZlcnNlKCkpKX0pKSx0fXN0YXRpYyBvZmZzZXRUb0luZGljZXNTaW5nbGUodCxlLG4pe2NvbnN0IHI9W107Zm9yKGxldCB0PTA7dDxlLTE7Kyt0KXIucHVzaChgXFxuICAgICAgaW5kaWNlc1ske3R9XSA9IG9mZnNldCAvICR7blt0XX07YCksci5wdXNoKGBcXG4gICAgICAgIG9mZnNldCAtPSBpbmRpY2VzWyR7dH1dICogJHtuW3RdfTtgKTtyZXR1cm4gci5wdXNoKGBcXG4gICAgICBpbmRpY2VzWyR7ZS0xfV0gPSBvZmZzZXQ7YCksYFxcbiAgICAgIHZvaWQgJHt0fShpbnQgb2Zmc2V0LCBvdXQgaW50IGluZGljZXNbJHtlfV0pIHtcXG4gICAgICAgICR7ci5qb2luKFwiXCIpfVxcbiAgICAgIH1cXG4gICAgICBgfWluY3JlbWVudEluZGljZXMoKXtjb25zdCB0PXt9O3JldHVybiB0aGlzLmNvbnRleHQucHJvZ3JhbUluZm8uaW5wdXROYW1lcy5mb3JFYWNoKCgoZSxuKT0+e2NvbnN0IGk9dGhpcy5jb250ZXh0LmlucHV0VGV4dHVyZUxheW91dHNbbl0uc2hhcGUsbz1pLmxlbmd0aCxhPWBpbmNyZW1lbnRJbmRpY2VzXyR7ZX1gO2xldCBzPVwiXCI7Zm9yKGxldCB0PTA7dDxvOysrdClzKz1gXFxuICAgICAgICBzaGFwZVske3R9XSA9ICR7aVt0XX07YDtjb25zdCB1PWBcXG4gICAgICAgIHZvaWQgJHthfShpbnQgYXhpcywgb3V0IGludCBpbmRpY2VzWyR7b31dKSB7XFxuICAgICAgICAgIGludCBzaGFwZVske299XTtcXG4gICAgICAgICAgJHtzfTtcXG4gICAgICAgICAgZm9yKGludCBpID0gJHtvfSAtMSA7IGkgPj0gMDsgLS1pKSB7XFxuICAgICAgICAgICAgaWYoaSA+IGF4aXMpIGNvbnRpbnVlO1xcbiAgICAgICAgICAgIGluZGljZXNbaV0gKz0gMTtcXG4gICAgICAgICAgICBpZihpbmRpY2VzW2ldIDwgc2hhcGVbaV0pIHtcXG4gICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBpbmRpY2VzW2ldID0gMDtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgYDt0W2FdPW5ldyByLkdsc2xMaWJSb3V0aW5lKHUpfSkpLHR9fWUuU2hhcGVVdGlsc0dsc2xMaWI9aX0sNTA2MDoodCxlKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUuZ2V0RGVmYXVsdEZyYWdTaGFkZXJNYWluPWUuZ2V0RnJhZ1NoYWRlclByZWFtYmxlPWUuZ2V0VmVydGV4U2hhZGVyU291cmNlPWUuZ2V0R2xzbD12b2lkIDA7Y29uc3Qgbj17dmVyc2lvbjpcIlwiLGF0dHJpYnV0ZTpcImF0dHJpYnV0ZVwiLHZhcnlpbmdWZXJ0ZXg6XCJ2YXJ5aW5nXCIsdmFyeWluZ0ZyYWc6XCJ2YXJ5aW5nXCIsdGV4dHVyZTJEOlwidGV4dHVyZTJEXCIsb3V0cHV0OlwiZ2xfRnJhZ0NvbG9yXCIsb3V0cHV0RGVjbGFyYXRpb246XCJcIn0scj17dmVyc2lvbjpcIiN2ZXJzaW9uIDMwMCBlc1wiLGF0dHJpYnV0ZTpcImluXCIsdmFyeWluZ1ZlcnRleDpcIm91dFwiLHZhcnlpbmdGcmFnOlwiaW5cIix0ZXh0dXJlMkQ6XCJ0ZXh0dXJlXCIsb3V0cHV0Olwib3V0cHV0Q29sb3JcIixvdXRwdXREZWNsYXJhdGlvbjpcIm91dCB2ZWM0IG91dHB1dENvbG9yO1wifTtmdW5jdGlvbiBpKHQpe3JldHVybiAxPT09dD9uOnJ9ZS5nZXRHbHNsPWksZS5nZXRWZXJ0ZXhTaGFkZXJTb3VyY2U9ZnVuY3Rpb24odCl7Y29uc3QgZT1pKHQpO3JldHVybmAke2UudmVyc2lvbn1cXG4gICAgICBwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuICAgICAgJHtlLmF0dHJpYnV0ZX0gdmVjMyBwb3NpdGlvbjtcXG4gICAgICAke2UuYXR0cmlidXRlfSB2ZWMyIHRleHR1cmVDb29yZDtcXG5cXG4gICAgICAke2UudmFyeWluZ1ZlcnRleH0gdmVjMiBUZXhDb29yZHM7XFxuXFxuICAgICAgdm9pZCBtYWluKClcXG4gICAgICB7XFxuICAgICAgICAgIGdsX1Bvc2l0aW9uID0gdmVjNChwb3NpdGlvbiwgMS4wKTtcXG4gICAgICAgICAgVGV4Q29vcmRzID0gdGV4dHVyZUNvb3JkO1xcbiAgICAgIH1gfSxlLmdldEZyYWdTaGFkZXJQcmVhbWJsZT1mdW5jdGlvbih0KXtjb25zdCBlPWkodCk7cmV0dXJuYCR7ZS52ZXJzaW9ufVxcbiAgICBwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuICAgIHByZWNpc2lvbiBoaWdocCBpbnQ7XFxuICAgIHByZWNpc2lvbiBoaWdocCBzYW1wbGVyMkQ7XFxuICAgICR7ZS52YXJ5aW5nRnJhZ30gdmVjMiBUZXhDb29yZHM7XFxuICAgICR7ZS5vdXRwdXREZWNsYXJhdGlvbn1cXG4gICAgY29uc3QgdmVjMiBoYWxmQ1IgPSB2ZWMyKDAuNSwgMC41KTtcXG5cXG4gICAgLy8gQ3VzdG9tIHZlY3RvciB0eXBlcyB0byBoYW5kbGUgaGlnaGVyIGRpbWVuYWxpdGllcy5cXG4gICAgc3RydWN0IGl2ZWM1XFxuICAgIHtcXG4gICAgICBpbnQgeDtcXG4gICAgICBpbnQgeTtcXG4gICAgICBpbnQgejtcXG4gICAgICBpbnQgdztcXG4gICAgICBpbnQgdTtcXG4gICAgfTtcXG5cXG4gICAgc3RydWN0IGl2ZWM2XFxuICAgIHtcXG4gICAgICBpbnQgeDtcXG4gICAgICBpbnQgeTtcXG4gICAgICBpbnQgejtcXG4gICAgICBpbnQgdztcXG4gICAgICBpbnQgdTtcXG4gICAgICBpbnQgdjtcXG4gICAgfTtcXG5cXG4gICAgaW50IGltb2QoaW50IHgsIGludCB5KSB7XFxuICAgICAgcmV0dXJuIHggLSB5ICogKHggLyB5KTtcXG4gICAgfVxcblxcbiAgICBgfSxlLmdldERlZmF1bHRGcmFnU2hhZGVyTWFpbj1mdW5jdGlvbih0LGUpe3JldHVybmBcXG4gIHZvaWQgbWFpbigpIHtcXG4gICAgaW50IGluZGljZXNbJHtlfV07XFxuICAgIHRvVmVjKFRleENvb3JkcywgaW5kaWNlcyk7XFxuICAgIHZlYzQgcmVzdWx0ID0gdmVjNChwcm9jZXNzKGluZGljZXMpKTtcXG4gICAgJHtpKHQpLm91dHB1dH0gPSByZXN1bHQ7XFxuICB9XFxuICBgfX0sMzg5MToodCxlLG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5WZWNHbHNsTGliPXZvaWQgMDtjb25zdCByPW4oODUyMCk7Y2xhc3MgaSBleHRlbmRzIHIuR2xzbExpYntjb25zdHJ1Y3Rvcih0KXtzdXBlcih0KX1nZXRDdXN0b21UeXBlcygpe3JldHVybnt9fWdldEZ1bmN0aW9ucygpe3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LHRoaXMuYmluYXJ5VmVjRnVuY3Rpb25zKCkpLHRoaXMuY29weVZlYygpKSx0aGlzLnNldFZlY0l0ZW0oKSksdGhpcy5nZXRWZWNJdGVtKCkpfWJpbmFyeVZlY0Z1bmN0aW9ucygpe2NvbnN0IHQ9dGhpcy5jb250ZXh0Lm91dHB1dFRleHR1cmVMYXlvdXQuc2hhcGUubGVuZ3RoLGU9e2FkZDpcIis9XCIsc3ViOlwiLT1cIixtdWw6XCIqPVwiLGRpdjpcIi89XCJ9LG49e307Zm9yKGNvbnN0IGkgaW4gZSl7Y29uc3Qgbz1gJHtpfVZlY2A7bGV0IGE9XCJcIjtmb3IobGV0IG49MDtuPHQ7KytuKWErPWBcXG4gICAgICAgICAgZGVzdFske259XSAke2VbaV19IHNyY1ske259XTtcXG4gICAgICAgICAgYDtjb25zdCBzPWBcXG4gICAgICAgIHZvaWQgJHtvfShpbnQgc3JjWyR7dH1dLCBvdXQgaW50IGRlc3RbJHt0fV0pIHtcXG4gICAgICAgICAgJHthfVxcbiAgICAgICAgfVxcbiAgICAgICAgYDtuW29dPW5ldyByLkdsc2xMaWJSb3V0aW5lKHMpfXJldHVybiBufWNvcHlWZWMoKXtjb25zdCB0PXRoaXMuY29udGV4dC5vdXRwdXRUZXh0dXJlTGF5b3V0LnNoYXBlLmxlbmd0aDtsZXQgZT1cIlwiO2ZvcihsZXQgbj0wO248dDsrK24pZSs9YFxcbiAgICAgICAgZGVzdFske259XSA9IHNyY1ske259XTtcXG4gICAgICAgIGA7Y29uc3Qgbj1gXFxuICAgICAgdm9pZCBjb3B5VmVjKGludCBzcmNbJHt0fV0sIG91dCBpbnQgZGVzdFske3R9XSkge1xcbiAgICAgICAgJHtlfVxcbiAgICAgIH1cXG4gICAgICBgO3JldHVybntjb3B5VmVjOm5ldyByLkdsc2xMaWJSb3V0aW5lKG4pfX1zZXRWZWNJdGVtKCl7Y29uc3QgdD10aGlzLmNvbnRleHQub3V0cHV0VGV4dHVyZUxheW91dC5zaGFwZS5sZW5ndGg7bGV0IGU9YFxcbiAgICAgICAgaWYoaW5kZXggPCAwKVxcbiAgICAgICAgICAgIGluZGV4ID0ke3R9ICsgaW5kZXg7XFxuICAgICAgICBpZiAoaW5kZXggPT0gMClcXG4gICAgICAgICAgICBtWzBdID0gdmFsdWU7XFxuICAgICAgICBgO2ZvcihsZXQgbj0xO248dC0xOysrbillKz1gXFxuICAgICAgICBlbHNlIGlmIChpbmRleCA9PSAke259KVxcbiAgICAgICAgICAgIG1bJHtufV0gPSB2YWx1ZTtcXG4gICAgICAgICAgICBgO2UrPWBcXG4gICAgICAgIGVsc2VcXG4gICAgICAgICAgICBtWyR7dC0xfV0gPSB2YWx1ZTtcXG4gICAgICAgIGA7Y29uc3Qgbj1gXFxuICAgICAgdm9pZCBzZXRWZWNJdGVtKG91dCBpbnQgbVske3R9XSwgaW50IGluZGV4LCBpbnQgdmFsdWUpIHtcXG4gICAgICAgICR7ZX1cXG4gICAgICB9XFxuICAgICAgICBgO3JldHVybntzZXRWZWNJdGVtOm5ldyByLkdsc2xMaWJSb3V0aW5lKG4pfX1nZXRWZWNJdGVtKCl7Y29uc3QgdD10aGlzLmNvbnRleHQub3V0cHV0VGV4dHVyZUxheW91dC5zaGFwZS5sZW5ndGg7bGV0IGU9YFxcbiAgICAgICAgaWYoaW5kZXggPCAwKVxcbiAgICAgICAgICAgIGluZGV4ID0gJHt0fSArIGluZGV4O1xcbiAgICAgICAgaWYgKGluZGV4ID09IDApXFxuICAgICAgICAgICAgcmV0dXJuIG1bMF07XFxuICAgICAgYDtmb3IobGV0IG49MTtuPHQtMTsrK24pZSs9YFxcbiAgICAgICAgZWxzZSBpZiAoaW5kZXggPT0gJHtufSlcXG4gICAgICAgICAgICByZXR1cm4gbVske259XTtcXG4gICAgICBgO2UrPWBcXG4gICAgICAgIGVsc2VcXG4gICAgICAgICAgICByZXR1cm4gbVske3QtMX1dO1xcbiAgICAgICAgYDtjb25zdCBuPWBcXG4gICAgICBpbnQgZ2V0VmVjSXRlbShpbnQgbVske3R9XSwgaW50IGluZGV4KSB7XFxuICAgICAgICAke2V9XFxuICAgICAgfVxcbiAgICBgO3JldHVybntnZXRWZWNJdGVtOm5ldyByLkdsc2xMaWJSb3V0aW5lKG4pfX19ZS5WZWNHbHNsTGliPWl9LDgzMTY6KHQsZSxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUuV2ViR0xJbmZlcmVuY2VIYW5kbGVyPXZvaWQgMDtjb25zdCByPW4oMzY5NCksaT1uKDkxNjIpLG89bigyNTE3KSxhPW4oMjQwMykscz1uKDcwMTkpLHU9big4NzEwKSxjPW4oNTYxMSksbD1uKDQwNTcpLHA9bigyMDM5KTtlLldlYkdMSW5mZXJlbmNlSGFuZGxlcj1jbGFzc3tjb25zdHJ1Y3Rvcih0KXt0aGlzLnNlc3Npb249dCx0aGlzLnBhY2tlZFRleHR1cmVEYXRhQ2FjaGU9bmV3IE1hcCx0aGlzLnVucGFja2VkVGV4dHVyZURhdGFDYWNoZT1uZXcgTWFwfWNhbGN1bGF0ZVRleHR1cmVXaWR0aEFuZEhlaWdodCh0LGUpe3JldHVybigwLGwuY2FsY3VsYXRlVGV4dHVyZVdpZHRoQW5kSGVpZ2h0KSh0aGlzLnNlc3Npb24ubGF5b3V0U3RyYXRlZ3ksdCxlKX1leGVjdXRlUHJvZ3JhbSh0LGUpe2lmKGUubGVuZ3RoPHQuaW5wdXROYW1lcy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKGBJbnB1dCBzaXplIG11c3RuJ3QgYmUgbGVzcyB0aGFuICR7dC5pbnB1dE5hbWVzLmxlbmd0aH0uYCk7aWYodC5pbnB1dE5hbWVzLmxlbmd0aCE9PXQuaW5wdXRUeXBlcy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiaW5wdXQgbmFtZXMgc2l6ZSBkb2VzIG5vdCBtYXRjaCBpbnB1dCB0eXBlc1wiKTtjb25zdCBuPVtdO2ZvcihsZXQgcj0wO3I8dC5pbnB1dE5hbWVzLmxlbmd0aDsrK3IpbltyXT10aGlzLmdldE9yQ3JlYXRlVGV4dHVyZURhdGEoZVtyXSx0LmlucHV0VHlwZXNbcl0pO2NvbnN0IHI9KCh0LGUpPT57Y29uc3Qgbj1lLm1hcCgodD0+YCR7dC51bnBhY2tlZFNoYXBlLmpvaW4oXCIsXCIpfTske3Qud2lkdGh9eCR7dC5oZWlnaHR9YCkpLmpvaW4oXCJfXCIpO2xldCByPXQubmFtZTtyZXR1cm4gdC5jYWNoZUhpbnQmJihyKz1cIltcIit0LmNhY2hlSGludCtcIl1cIikscis9XCI6XCIrbixyfSkodCxuKTtsZXQgaT10aGlzLnNlc3Npb24ucHJvZ3JhbU1hbmFnZXIuZ2V0QXJ0aWZhY3Qocik7Y29uc3Qgbz1pP2kucHJvZ3JhbUluZm86XCJmdW5jdGlvblwiPT10eXBlb2YgdC5nZXQ/dC5nZXQoKTp0LGE9KDAsbC5jcmVhdGVUZXh0dXJlTGF5b3V0RnJvbVRleHR1cmVUeXBlKSh0aGlzLnNlc3Npb24ubGF5b3V0U3RyYXRlZ3ksby5vdXRwdXQuZGltcyxvLm91dHB1dC50ZXh0dXJlVHlwZSkscz10aGlzLmNyZWF0ZVRleHR1cmVEYXRhKGEsby5vdXRwdXQudHlwZSk7cmV0dXJuIGl8fChpPXRoaXMuc2Vzc2lvbi5wcm9ncmFtTWFuYWdlci5idWlsZChvLG4scyksdGhpcy5zZXNzaW9uLnByb2dyYW1NYW5hZ2VyLnNldEFydGlmYWN0KHIsaSkpLHRoaXMucnVuUHJvZ3JhbShpLG4scyksc31ydW4odCxlKXtyZXR1cm4gdGhpcy5leGVjdXRlUHJvZ3JhbSh0LGUpLnRlbnNvcn1ydW5Qcm9ncmFtKHQsZSxuKXtmb3IobGV0IG49MDtuPGUubGVuZ3RoOysrbilpZighIWVbbl0uaXNQYWNrZWQhPSh0LnByb2dyYW1JbmZvLmlucHV0VHlwZXNbbl09PT1wLlRleHR1cmVUeXBlLnBhY2tlZCkpdGhyb3cgbmV3IEVycm9yKGBpbnB1dFske259XSBwcm9wZXJ0eSBwYWNrZWQgaW5jb25zaXN0ZW50YCk7aWYoISFuLmlzUGFja2VkIT0odC5wcm9ncmFtSW5mby5vdXRwdXQudGV4dHVyZVR5cGU9PT1wLlRleHR1cmVUeXBlLnBhY2tlZCkpdGhyb3cgbmV3IEVycm9yKFwib3V0cHV0IHByb3BlcnR5IHBhY2tlZCBpbmNvbnNpc3RlbnRcIik7dGhpcy5zZXNzaW9uLnByb2dyYW1NYW5hZ2VyLnJ1bih0LGUsbil9Z2V0T3JDcmVhdGVUZXh0dXJlRGF0YSh0LGUpe2xldCBuPXRoaXMuZ2V0VGV4dHVyZURhdGEodC5kYXRhSWQsZT09PXAuVGV4dHVyZVR5cGUucGFja2VkKTtpZighbiYmKG49dGhpcy5nZXRUZXh0dXJlRGF0YSh0LmRhdGFJZCxlIT09cC5UZXh0dXJlVHlwZS5wYWNrZWQpLG4pKXJldHVybiBlPT09cC5UZXh0dXJlVHlwZS5wYWNrZWQ/dGhpcy5wYWNrKG4pOnRoaXMudW5wYWNrKG4pO2lmKCFuKXtjb25zdCByPSgwLGwuY3JlYXRlVGV4dHVyZUxheW91dEZyb21UZXh0dXJlVHlwZSkodGhpcy5zZXNzaW9uLmxheW91dFN0cmF0ZWd5LHQuZGltcyxlKTtpZihlPT09cC5UZXh0dXJlVHlwZS5wYWNrZWRMYXN0RGltZW5zaW9uKXtjb25zdCBuPTEscj00LGk9dC5kaW1zO2lmKDQ9PT1pLmxlbmd0aCl7Y29uc3Qgbz1baVswXSxNYXRoLmNlaWwoaVsxXSppWzJdKmlbM10vcildLGE9KDAsbC5jcmVhdGVUZXh0dXJlTGF5b3V0RnJvbVRleHR1cmVUeXBlKSh0aGlzLnNlc3Npb24ubGF5b3V0U3RyYXRlZ3ksbyxlKTtsZXQgcz10Lm51bWJlckRhdGE7aWYoaVsxXSppWzJdKmlbM10lciE9MCl7Y29uc3QgZT1pWzBdLG89aVsxXSppWzJdKmlbM10sYT1NYXRoLmNlaWwobypuL3IpKnI7cz1uZXcgRmxvYXQzMkFycmF5KGUqYSk7Zm9yKGxldCByPTA7cjxlOysrcil7Y29uc3QgZT1yKm8saT1yKmErciVuKm87cy5zZXQodC5udW1iZXJEYXRhLnN1YmFycmF5KGUsZStvKSxpKX19cmV0dXJuIHRoaXMuY3JlYXRlVGV4dHVyZURhdGEoYSx0LnR5cGUscyx0LDEpfX1pZihlPT09cC5UZXh0dXJlVHlwZS5wYWNrZWQpe2NvbnN0IGU9KDAsbC5jcmVhdGVUZXh0dXJlTGF5b3V0RnJvbVNoYXBlKSh0aGlzLnNlc3Npb24ubGF5b3V0U3RyYXRlZ3ksdC5kaW1zLDEsW10se3JldmVyc2VXSDohMH0pLHI9dGhpcy5jcmVhdGVUZXh0dXJlRGF0YShlLHQudHlwZSx0Lm51bWJlckRhdGEsdCwxKTtuPXRoaXMucGFjayhyKX1lbHNlIG49dGhpcy5jcmVhdGVUZXh0dXJlRGF0YShyLHQudHlwZSx0Lm51bWJlckRhdGEsdCwxKX1yZXR1cm4gbn1jcmVhdGVUZXh0dXJlRGF0YUZyb21MYXlvdXRCaW5kVGVuc29yKHQsZSxuLHIpe3JldHVybiB0aGlzLmNyZWF0ZVRleHR1cmVEYXRhKHQsZSxuLHIsMSl9Y3JlYXRlVGV4dHVyZURhdGEodCxlLG4saSxvKXtyLkxvZ2dlci52ZXJib3NlKFwiSW5mZXJlbmNlSGFuZGxlclwiLGBDcmVhdGluZyBUZXh0dXJlRGF0YTogbGF5b3V0Olske0pTT04uc3RyaW5naWZ5KHQpfV1gKTtjb25zdCBhPXRoaXMuc2Vzc2lvbi50ZXh0dXJlTWFuYWdlci5jcmVhdGVUZXh0dXJlRnJvbUxheW91dChlLHQsbixvKTtyZXR1cm4gdGhpcy5jcmVhdGVUZXh0dXJlRGF0YUZyb21UZXh0dXJlKHQsZSxhLGkpfXJlc2hhcGVVbnBhY2tlZCh0LGUpe2NvbnN0IG49dGhpcy5nZXRPckNyZWF0ZVRleHR1cmVEYXRhKHQscC5UZXh0dXJlVHlwZS51bnBhY2tlZCkscj17Y2hhbm5lbHM6bi5jaGFubmVscyxoZWlnaHQ6bi5oZWlnaHQsd2lkdGg6bi53aWR0aCxzaGFwZTowIT09ZS5sZW5ndGg/ZTpbMV0sc3RyaWRlczpvLlNoYXBlVXRpbC5jb21wdXRlU3RyaWRlcyhlKSx1bnBhY2tlZFNoYXBlOmV9O3JldHVybiB0aGlzLmNyZWF0ZVRleHR1cmVEYXRhRnJvbVRleHR1cmUocix0LnR5cGUsbi50ZXh0dXJlKS50ZW5zb3J9cmVzaGFwZVBhY2tlZCh0LGUpe2NvbnN0IG49dGhpcy5nZXRPckNyZWF0ZVRleHR1cmVEYXRhKHQscC5UZXh0dXJlVHlwZS5wYWNrZWQpO2lmKCgwLHMuaXNSZXNoYXBlQ2hlYXApKHQuZGltcyxlKSl7Y29uc3Qgcj17Y2hhbm5lbHM6bi5jaGFubmVscyxoZWlnaHQ6bi5oZWlnaHQsd2lkdGg6bi53aWR0aCxzaGFwZTowIT09ZS5sZW5ndGg/ZTpbMV0sc3RyaWRlczpvLlNoYXBlVXRpbC5jb21wdXRlU3RyaWRlcyhlKSx1bnBhY2tlZFNoYXBlOmUsaXNQYWNrZWQ6ITB9O3JldHVybiB0aGlzLmNyZWF0ZVRleHR1cmVEYXRhRnJvbVRleHR1cmUocix0LnR5cGUsbi50ZXh0dXJlKS50ZW5zb3J9Y29uc3Qgcj0oMCxzLnByb2Nlc3NEaW1zM0QpKHQuZGltcyksaT0oMCxzLnByb2Nlc3NEaW1zM0QpKGUpLGE9dGhpcy5yZXNoYXBlUGFja2VkKHQsciksdT10aGlzLnJ1bigoMCxzLmNyZWF0ZVBhY2tlZFJlc2hhcGUzRFByb2dyYW1JbmZvTG9hZGVyKSh0aGlzLGEsaSksW2FdKTtyZXR1cm4gdGhpcy5yZXNoYXBlUGFja2VkKHUsZSl9Y2FzdCh0LGUpe2NvbnN0IG49dGhpcy5nZXRPckNyZWF0ZVRleHR1cmVEYXRhKHQscC5UZXh0dXJlVHlwZS51bnBhY2tlZCk7cmV0dXJuIHRoaXMuY3JlYXRlVGV4dHVyZURhdGFGcm9tVGV4dHVyZShuLGUsbi50ZXh0dXJlKS50ZW5zb3J9Y3JlYXRlVGV4dHVyZURhdGFGcm9tVGV4dHVyZSh0LGUsbixyLG8pe2NvbnN0IGE9T2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LHQpLHt0ZW5zb3I6cnx8bmV3IGkuVGVuc29yKHQudW5wYWNrZWRTaGFwZSxlLCh0PT50aGlzLnJlYWRUZXh0dXJlKGEpKSwoYXN5bmMgdD0+dGhpcy5yZWFkVGV4dHVyZUFzeW5jKGEpKSx2b2lkIDAsbyksdGV4dHVyZTpufSk7cmV0dXJuIHRoaXMuc2V0VGV4dHVyZURhdGEoYS50ZW5zb3IuZGF0YUlkLGEsdC5pc1BhY2tlZCksYX1nZXRUZXh0dXJlRGF0YSh0LGU9ITEpe3JldHVybiB0aGlzLnNlc3Npb24uaXNJbml0aWFsaXplcih0KT90aGlzLnNlc3Npb24uZ2V0VGV4dHVyZURhdGEodCxlKTplP3RoaXMucGFja2VkVGV4dHVyZURhdGFDYWNoZS5nZXQodCk6dGhpcy51bnBhY2tlZFRleHR1cmVEYXRhQ2FjaGUuZ2V0KHQpfXNldFRleHR1cmVEYXRhKHQsZSxuPSExKXt0aGlzLnNlc3Npb24uaXNJbml0aWFsaXplcih0KT90aGlzLnNlc3Npb24uc2V0VGV4dHVyZURhdGEodCxlLG4pOihuP3RoaXMucGFja2VkVGV4dHVyZURhdGFDYWNoZTp0aGlzLnVucGFja2VkVGV4dHVyZURhdGFDYWNoZSkuc2V0KHQsZSl9aXNUZXh0dXJlTGF5b3V0Q2FjaGVkKHQsZT0hMSl7cmV0dXJuISF0aGlzLmdldFRleHR1cmVEYXRhKHQuZGF0YUlkLGUpfWRpc3Bvc2UoKXt0aGlzLnNlc3Npb24udGV4dHVyZU1hbmFnZXIuY2xlYXJBY3RpdmVUZXh0dXJlcygpLHRoaXMucGFja2VkVGV4dHVyZURhdGFDYWNoZS5mb3JFYWNoKCh0PT50aGlzLnNlc3Npb24udGV4dHVyZU1hbmFnZXIucmVsZWFzZVRleHR1cmUodCkpKSx0aGlzLnBhY2tlZFRleHR1cmVEYXRhQ2FjaGU9bmV3IE1hcCx0aGlzLnVucGFja2VkVGV4dHVyZURhdGFDYWNoZS5mb3JFYWNoKCh0PT50aGlzLnNlc3Npb24udGV4dHVyZU1hbmFnZXIucmVsZWFzZVRleHR1cmUodCkpKSx0aGlzLnVucGFja2VkVGV4dHVyZURhdGFDYWNoZT1uZXcgTWFwfXJlYWRUZXh0dXJlKHQpe3JldHVybiB0LmlzUGFja2VkP3RoaXMucmVhZFRleHR1cmUodGhpcy51bnBhY2sodCkpOnRoaXMuc2Vzc2lvbi5iYWNrZW5kLmdsQ29udGV4dC5pc0Zsb2F0MzJEb3dubG9hZFN1cHBvcnRlZD90aGlzLnNlc3Npb24udGV4dHVyZU1hbmFnZXIucmVhZFRleHR1cmUodCx0LnRlbnNvci50eXBlLHQuY2hhbm5lbHMpOnRoaXMuc2Vzc2lvbi50ZXh0dXJlTWFuYWdlci5yZWFkVWludDhUZXh0dXJlQXNGbG9hdCgoMCx1LmVuY29kZUFzVWludDgpKHRoaXMsdCkpfWFzeW5jIHJlYWRUZXh0dXJlQXN5bmModCl7cmV0dXJuIHQuaXNQYWNrZWQ/dGhpcy5yZWFkVGV4dHVyZUFzeW5jKHRoaXMudW5wYWNrKHQpKTp0aGlzLnNlc3Npb24uYmFja2VuZC5nbENvbnRleHQuaXNGbG9hdDMyRG93bmxvYWRTdXBwb3J0ZWQ/dGhpcy5zZXNzaW9uLnRleHR1cmVNYW5hZ2VyLnJlYWRUZXh0dXJlQXN5bmModCx0LnRlbnNvci50eXBlLHQuY2hhbm5lbHMpOnRoaXMuc2Vzc2lvbi50ZXh0dXJlTWFuYWdlci5yZWFkVWludDhUZXh0dXJlQXNGbG9hdCgoMCx1LmVuY29kZUFzVWludDgpKHRoaXMsdCkpfXBhY2sodCl7cmV0dXJuIHRoaXMuZXhlY3V0ZVByb2dyYW0oKDAsYS5jcmVhdGVQYWNrUHJvZ3JhbUluZm9Mb2FkZXIpKHRoaXMsdC50ZW5zb3IpLFt0LnRlbnNvcl0pfXVucGFjayh0KXtyZXR1cm4gdGhpcy5leGVjdXRlUHJvZ3JhbSgoMCxjLmNyZWF0ZVVucGFja1Byb2dyYW1JbmZvTG9hZGVyKSh0aGlzLHQudGVuc29yKSxbdC50ZW5zb3JdKX19fSwxNjQwOmZ1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjt2YXIgcj10aGlzJiZ0aGlzLl9fY3JlYXRlQmluZGluZ3x8KE9iamVjdC5jcmVhdGU/ZnVuY3Rpb24odCxlLG4scil7dm9pZCAwPT09ciYmKHI9bik7dmFyIGk9T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLG4pO2kmJiEoXCJnZXRcImluIGk/IWUuX19lc01vZHVsZTppLndyaXRhYmxlfHxpLmNvbmZpZ3VyYWJsZSl8fChpPXtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBlW25dfX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LHIsaSl9OmZ1bmN0aW9uKHQsZSxuLHIpe3ZvaWQgMD09PXImJihyPW4pLHRbcl09ZVtuXX0pLGk9dGhpcyYmdGhpcy5fX3NldE1vZHVsZURlZmF1bHR8fChPYmplY3QuY3JlYXRlP2Z1bmN0aW9uKHQsZSl7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJkZWZhdWx0XCIse2VudW1lcmFibGU6ITAsdmFsdWU6ZX0pfTpmdW5jdGlvbih0LGUpe3QuZGVmYXVsdD1lfSksbz10aGlzJiZ0aGlzLl9faW1wb3J0U3Rhcnx8ZnVuY3Rpb24odCl7aWYodCYmdC5fX2VzTW9kdWxlKXJldHVybiB0O3ZhciBlPXt9O2lmKG51bGwhPXQpZm9yKHZhciBuIGluIHQpXCJkZWZhdWx0XCIhPT1uJiZPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCxuKSYmcihlLHQsbik7cmV0dXJuIGkoZSx0KSxlfTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLldFQkdMX09QX1JFU09MVkVfUlVMRVM9dm9pZCAwO2NvbnN0IGE9bigyODk4KSxzPW8obig3ODM5KSksdT1uKDQxOTYpLGM9bigyMDY5KSxsPW4oODEzOCkscD1uKDk2NjMpLGY9big1MTkzKSxkPW4oNzk5MiksaD1uKDEyNTMpLGc9big0Nzc2KSxiPW4oNjU3MiksbT1uKDMzNDYpLHk9big1NjIzKSxfPW4oMjg3MCksdj1uKDIxNDMpLHc9big0OTM5KSx4PW4oNzE4KSxUPW4oMjI2OCksUz1uKDgxMTcpLE89bigyMjc4KSxBPW4oNTUyNCksRT1uKDU5NzUpLEk9bigzOTMzKSxQPW4oNjU1OCksRD1uKDU3MjMpLCQ9bigzNzM4KSxrPW8obig0OTA5KSksQz1uKDg0MjgpLEY9big5NzkzKTtlLldFQkdMX09QX1JFU09MVkVfUlVMRVM9W1tcIkFic1wiLFwiXCIsXCI2K1wiLGsuYWJzXSxbXCJBY29zXCIsXCJcIixcIjcrXCIsay5hY29zXSxbXCJBZGRcIixcIlwiLFwiNytcIixzLmFkZF0sW1wiQW5kXCIsXCJcIixcIjcrXCIscy5hbmRdLFtcIkFzaW5cIixcIlwiLFwiNytcIixrLmFzaW5dLFtcIkF0YW5cIixcIlwiLFwiNytcIixrLmF0YW5dLFtcIkF2ZXJhZ2VQb29sXCIsXCJcIixcIjcrXCIsdi5hdmVyYWdlUG9vbCx2LnBhcnNlQXZlcmFnZVBvb2xBdHRyaWJ1dGVzXSxbXCJCYXRjaE5vcm1hbGl6YXRpb25cIixcIlwiLFwiNytcIixhLmJhdGNoTm9ybWFsaXphdGlvbixhLnBhcnNlQmF0Y2hOb3JtYWxpemF0aW9uQXR0cmlidXRlc10sW1wiQ2FzdFwiLFwiXCIsXCI2K1wiLHUuY2FzdCx1LnBhcnNlQ2FzdEF0dHJpYnV0ZXNdLFtcIkNlaWxcIixcIlwiLFwiNitcIixrLmNlaWxdLFtcIkNsaXBcIixcIlwiLFwiNi0xMFwiLGsuY2xpcCxrLnBhcnNlQ2xpcEF0dHJpYnV0ZXNdLFtcIkNsaXBcIixcIlwiLFwiMTErXCIsay5jbGlwVjExXSxbXCJDb25jYXRcIixcIlwiLFwiNCtcIixjLmNvbmNhdCxjLnBhcnNlQ29uY2F0QXR0cmlidXRlc10sW1wiQ29udlwiLFwiXCIsXCIxK1wiLGwuY29udixsLnBhcnNlQ29udkF0dHJpYnV0ZXNdLFtcIkNvbnZUcmFuc3Bvc2VcIixcIlwiLFwiMStcIixwLmNvbnZUcmFuc3Bvc2UscC5wYXJzZUNvbnZUcmFuc3Bvc2VBdHRyaWJ1dGVzXSxbXCJDb3NcIixcIlwiLFwiNytcIixrLmNvc10sW1wiRGl2XCIsXCJcIixcIjcrXCIscy5kaXZdLFtcIkRyb3BvdXRcIixcIlwiLFwiNytcIixrLmlkZW50aXR5XSxbXCJEZXB0aFRvU3BhY2VcIixcIlwiLFwiMStcIixmLmRlcHRoVG9TcGFjZSxmLnBhcnNlRGVwdGhUb1NwYWNlQXR0cmlidXRlc10sW1wiRXF1YWxcIixcIlwiLFwiNytcIixzLmVxdWFsXSxbXCJFbHVcIixcIlwiLFwiNitcIixrLmVsdSxrLnBhcnNlRWx1QXR0cmlidXRlc10sW1wiRXhwXCIsXCJcIixcIjYrXCIsay5leHBdLFtcIkZsYXR0ZW5cIixcIlwiLFwiMStcIixkLmZsYXR0ZW4sZC5wYXJzZUZsYXR0ZW5BdHRyaWJ1dGVzXSxbXCJGbG9vclwiLFwiXCIsXCI2K1wiLGsuZmxvb3JdLFtcIkZ1c2VkQ29udlwiLFwiY29tLm1pY3Jvc29mdFwiLFwiMStcIixsLmNvbnYsbC5wYXJzZUNvbnZBdHRyaWJ1dGVzXSxbXCJHYXRoZXJcIixcIlwiLFwiMStcIixoLmdhdGhlcixoLnBhcnNlR2F0aGVyQXR0cmlidXRlc10sW1wiR2VtbVwiLFwiXCIsXCI3LTEwXCIsZy5nZW1tLGcucGFyc2VHZW1tQXR0cmlidXRlc1Y3XSxbXCJHZW1tXCIsXCJcIixcIjExK1wiLGcuZ2VtbSxnLnBhcnNlR2VtbUF0dHJpYnV0ZXNWMTFdLFtcIkdsb2JhbEF2ZXJhZ2VQb29sXCIsXCJcIixcIjErXCIsdi5nbG9iYWxBdmVyYWdlUG9vbCx2LnBhcnNlR2xvYmFsQXZlcmFnZVBvb2xBdHRyaWJ1dGVzXSxbXCJHbG9iYWxNYXhQb29sXCIsXCJcIixcIjErXCIsdi5nbG9iYWxNYXhQb29sXSxbXCJHcmVhdGVyXCIsXCJcIixcIjcrXCIscy5ncmVhdGVyXSxbXCJJZGVudGl0eVwiLFwiXCIsXCIxK1wiLGsuaWRlbnRpdHldLFtcIkltYWdlU2NhbGVyXCIsXCJcIixcIjErXCIsYi5pbWFnZVNjYWxlcixiLnBhcnNlSW1hZ2VTY2FsZXJBdHRyaWJ1dGVzXSxbXCJJbnN0YW5jZU5vcm1hbGl6YXRpb25cIixcIlwiLFwiNitcIixtLmluc3RhbmNlTm9ybWFsaXphdGlvbixtLnBhcnNlSW5zdGFuY2VOb3JtYWxpemF0aW9uQXR0cmlidXRlc10sW1wiTGVha3lSZWx1XCIsXCJcIixcIjYrXCIsay5sZWFreVJlbHUsay5wYXJzZUxlYWt5UmVsdUF0dHJpYnV0ZXNdLFtcIkxlc3NcIixcIlwiLFwiNytcIixzLmxlc3NdLFtcIkxvZ1wiLFwiXCIsXCI2K1wiLGsubG9nXSxbXCJNYXRNdWxcIixcIlwiLFwiMStcIix5Lm1hdE11bCx5LnBhcnNlTWF0TXVsQXR0cmlidXRlc10sW1wiTWF4UG9vbFwiLFwiXCIsXCIxK1wiLHYubWF4UG9vbCx2LnBhcnNlTWF4UG9vbEF0dHJpYnV0ZXNdLFtcIk11bFwiLFwiXCIsXCI3K1wiLHMubXVsXSxbXCJOZWdcIixcIlwiLFwiNitcIixrLm5lZ10sW1wiTm90XCIsXCJcIixcIjErXCIsay5ub3RdLFtcIk9yXCIsXCJcIixcIjcrXCIscy5vcl0sW1wiUGFkXCIsXCJcIixcIjItMTBcIixfLnBhZFYyLF8ucGFyc2VQYWRBdHRyaWJ1dGVzVjJdLFtcIlBhZFwiLFwiXCIsXCIxMStcIixfLnBhZFYxMSxfLnBhcnNlUGFkQXR0cmlidXRlc1YxMV0sW1wiUG93XCIsXCJcIixcIjcrXCIscy5wb3ddLFtcIlBSZWx1XCIsXCJcIixcIjcrXCIscy5wUmVsdV0sW1wiUmVkdWNlTG9nU3VtXCIsXCJcIixcIjErXCIsdy5yZWR1Y2VMb2dTdW0sdy5wYXJzZVJlZHVjZUF0dHJpYnV0ZXNdLFtcIlJlZHVjZU1heFwiLFwiXCIsXCIxK1wiLHcucmVkdWNlTWF4LHcucGFyc2VSZWR1Y2VBdHRyaWJ1dGVzXSxbXCJSZWR1Y2VNZWFuXCIsXCJcIixcIjErXCIsdy5yZWR1Y2VNZWFuLHcucGFyc2VSZWR1Y2VBdHRyaWJ1dGVzXSxbXCJSZWR1Y2VNaW5cIixcIlwiLFwiMStcIix3LnJlZHVjZU1pbix3LnBhcnNlUmVkdWNlQXR0cmlidXRlc10sW1wiUmVkdWNlUHJvZFwiLFwiXCIsXCIxK1wiLHcucmVkdWNlUHJvZCx3LnBhcnNlUmVkdWNlQXR0cmlidXRlc10sW1wiUmVkdWNlU3VtXCIsXCJcIixcIjEtMTJcIix3LnJlZHVjZVN1bSx3LnBhcnNlUmVkdWNlQXR0cmlidXRlc10sW1wiUmVkdWNlU3VtU3F1YXJlXCIsXCJcIixcIjErXCIsdy5yZWR1Y2VMb2dTdW1TcXVhcmUsdy5wYXJzZVJlZHVjZUF0dHJpYnV0ZXNdLFtcIlJlbHVcIixcIlwiLFwiNitcIixrLnJlbHVdLFtcIlJlc2hhcGVcIixcIlwiLFwiNStcIix4LnJlc2hhcGVdLFtcIlJlc2l6ZVwiLFwiXCIsXCIxMFwiLFQucmVzaXplLFQucGFyc2VSZXNpemVBdHRyaWJ1dGVzVjEwXSxbXCJSZXNpemVcIixcIlwiLFwiMTErXCIsVC5yZXNpemUsVC5wYXJzZVJlc2l6ZUF0dHJpYnV0ZXNWMTFdLFtcIlNoYXBlXCIsXCJcIixcIjErXCIsUy5zaGFwZV0sW1wiU2lnbW9pZFwiLFwiXCIsXCI2K1wiLGsuc2lnbW9pZF0sW1wiU2luXCIsXCJcIixcIjcrXCIsay5zaW5dLFtcIlNsaWNlXCIsXCJcIixcIjEwK1wiLE8uc2xpY2VWMTBdLFtcIlNsaWNlXCIsXCJcIixcIjEtOVwiLE8uc2xpY2UsTy5wYXJzZVNsaWNlQXR0cmlidXRlc10sW1wiU29mdG1heFwiLFwiXCIsXCIxLTEyXCIsQS5zb2Z0bWF4LEEucGFyc2VTb2Z0bWF4QXR0cmlidXRlc10sW1wiU29mdG1heFwiLFwiXCIsXCIxMytcIixBLnNvZnRtYXhWMTMsQS5wYXJzZVNvZnRtYXhBdHRyaWJ1dGVzVjEzXSxbXCJTcGxpdFwiLFwiXCIsXCIyLTEyXCIsRS5zcGxpdCxFLnBhcnNlU3BsaXRBdHRyaWJ1dGVzXSxbXCJTcXJ0XCIsXCJcIixcIjYrXCIsay5zcXJ0XSxbXCJTcXVlZXplXCIsXCJcIixcIjEtMTJcIixJLnNxdWVlemUsSS5wYXJzZVNxdWVlemVBdHRyaWJ1dGVzXSxbXCJTcXVlZXplXCIsXCJcIixcIjEzK1wiLEkuc3F1ZWV6ZVYxM10sW1wiU3ViXCIsXCJcIixcIjcrXCIscy5zdWJdLFtcIlN1bVwiLFwiXCIsXCI2K1wiLFAuc3VtXSxbXCJUYW5cIixcIlwiLFwiNytcIixrLnRhbl0sW1wiVGFuaFwiLFwiXCIsXCI2K1wiLGsudGFuaF0sW1wiVGlsZVwiLFwiXCIsXCI2K1wiLEQudGlsZV0sW1wiVHJhbnNwb3NlXCIsXCJcIixcIjErXCIsJC50cmFuc3Bvc2UsJC5wYXJzZVRyYW5zcG9zZUF0dHJpYnV0ZXNdLFtcIlVwc2FtcGxlXCIsXCJcIixcIjctOFwiLEYudXBzYW1wbGUsRi5wYXJzZVVwc2FtcGxlQXR0cmlidXRlc1Y3XSxbXCJVcHNhbXBsZVwiLFwiXCIsXCI5XCIsRi51cHNhbXBsZSxGLnBhcnNlVXBzYW1wbGVBdHRyaWJ1dGVzVjldLFtcIlVuc3F1ZWV6ZVwiLFwiXCIsXCIxLTEyXCIsQy51bnNxdWVlemUsQy5wYXJzZVVuc3F1ZWV6ZUF0dHJpYnV0ZXNdLFtcIlVuc3F1ZWV6ZVwiLFwiXCIsXCIxMytcIixDLnVuc3F1ZWV6ZVYxM10sW1wiWG9yXCIsXCJcIixcIjcrXCIscy54b3JdXX0sMjg5ODoodCxlLG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5wYXJzZUJhdGNoTm9ybWFsaXphdGlvbkF0dHJpYnV0ZXM9ZS5iYXRjaE5vcm1hbGl6YXRpb249dm9pZCAwO2NvbnN0IHI9bigyNDYpLGk9big1MDYwKSxvPW4oMjAzOSksYT17bmFtZTpcIkJhdGNoTm9ybWFsaXphdGlvblwiLGlucHV0TmFtZXM6W1wiQVwiLFwiU2NhbGVcIixcIkJcIixcIk1lYW5cIixcIlZhcmlhbmNlXCJdLGlucHV0VHlwZXM6W28uVGV4dHVyZVR5cGUudW5wYWNrZWQsby5UZXh0dXJlVHlwZS51bnBhY2tlZCxvLlRleHR1cmVUeXBlLnVucGFja2VkLG8uVGV4dHVyZVR5cGUudW5wYWNrZWQsby5UZXh0dXJlVHlwZS51bnBhY2tlZF19O2UuYmF0Y2hOb3JtYWxpemF0aW9uPSh0LGUsbik9Pih1KGUpLFt0LnJ1bihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sYSkse2NhY2hlSGludDpuLmNhY2hlS2V5LGdldDooKT0+cyh0LGUsbil9KSxlKV0pLGUucGFyc2VCYXRjaE5vcm1hbGl6YXRpb25BdHRyaWJ1dGVzPXQ9Pntjb25zdCBlPXQuYXR0cmlidXRlcy5nZXRGbG9hdChcImVwc2lsb25cIiwxZS01KSxuPXQuYXR0cmlidXRlcy5nZXRGbG9hdChcIm1vbWVudHVtXCIsLjkpLGk9dC5hdHRyaWJ1dGVzLmdldEludChcInNwYXRpYWxcIiwxKTtyZXR1cm4oMCxyLmNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSkoe2Vwc2lsb246ZSxtb21lbnR1bTpuLHNwYXRpYWw6aX0pfTtjb25zdCBzPSh0LGUsbik9Pntjb25zdCByPSgwLGkuZ2V0R2xzbCkodC5zZXNzaW9uLmJhY2tlbmQuZ2xDb250ZXh0LnZlcnNpb24pLHM9ZVswXS5kaW1zLmxlbmd0aCxbdSxjXT10LmNhbGN1bGF0ZVRleHR1cmVXaWR0aEFuZEhlaWdodChlWzFdLmRpbXMsby5UZXh0dXJlVHlwZS51bnBhY2tlZCksbD1gXFxuICBmbG9hdCBwcm9jZXNzKGludFske3N9XSBpbmRpY2VzKSB7XFxuICAgIHZlYzIgcG9zaXRpb24gPSBvZmZzZXRUb0Nvb3JkcyhpbmRpY2VzWzFdLCAke3V9LCAke2N9KTtcXG4gICAgZmxvYXQgc2NhbGUgPSBnZXRDb2xvckFzRmxvYXQoJHtyLnRleHR1cmUyRH0oU2NhbGUsIHBvc2l0aW9uKSk7XFxuICAgIGZsb2F0IG1lYW4gPSBnZXRDb2xvckFzRmxvYXQoJHtyLnRleHR1cmUyRH0oTWVhbiwgcG9zaXRpb24pKTtcXG4gICAgZmxvYXQgdmFyaWFuY2UgPSBnZXRDb2xvckFzRmxvYXQoJHtyLnRleHR1cmUyRH0oVmFyaWFuY2UsIHBvc2l0aW9uKSk7XFxuICAgIGZsb2F0IGIgPSBnZXRDb2xvckFzRmxvYXQoJHtyLnRleHR1cmUyRH0oQiwgcG9zaXRpb24pKTtcXG5cXG4gICAgcmV0dXJuIHNjYWxlICogKCAoX0EoaW5kaWNlcykgLSBtZWFuKSAvIHNxcnQodmFyaWFuY2UgKyBmbG9hdCgke24uZXBzaWxvbn0pKSApICsgYjtcXG4gIH1gO3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sYSkse291dHB1dDp7ZGltczplWzBdLmRpbXMsdHlwZTplWzBdLnR5cGUsdGV4dHVyZVR5cGU6by5UZXh0dXJlVHlwZS51bnBhY2tlZH0sc2hhZGVyU291cmNlOmx9KX0sdT10PT57aWYoIXR8fDUhPT10Lmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJCYXRjaE5vcm1hbGl6YXRpb24gcmVxdWlyZXMgNSBpbnB1dHMuXCIpO2NvbnN0IGU9dFswXSxuPXRbMV0scj10WzJdLGk9dFszXSxvPXRbNF07aWYoZS5kaW1zLmxlbmd0aDwzfHwxIT09bi5kaW1zLmxlbmd0aHx8MSE9PXIuZGltcy5sZW5ndGh8fDEhPT1pLmRpbXMubGVuZ3RofHwxIT09by5kaW1zLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGlucHV0IHNoYXBlLlwiKTtpZihuLmRpbXNbMF0hPT1lLmRpbXNbMV18fHIuZGltc1swXSE9PWUuZGltc1sxXXx8aS5kaW1zWzBdIT09ZS5kaW1zWzFdfHxvLmRpbXNbMF0hPT1lLmRpbXNbMV0pdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBpbnB1dCBzaGFwZS5cIik7aWYoXCJmbG9hdDMyXCIhPT1lLnR5cGUmJlwiZmxvYXQ2NFwiIT09ZS50eXBlfHxcImZsb2F0MzJcIiE9PW4udHlwZSYmXCJmbG9hdDY0XCIhPT1uLnR5cGV8fFwiZmxvYXQzMlwiIT09ci50eXBlJiZcImZsb2F0NjRcIiE9PXIudHlwZXx8XCJmbG9hdDMyXCIhPT1pLnR5cGUmJlwiZmxvYXQ2NFwiIT09aS50eXBlfHxcImZsb2F0MzJcIiE9PW8udHlwZSYmXCJmbG9hdDY0XCIhPT1vLnR5cGUpdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBpbnB1dCB0ZW5zb3IgdHlwZXMuXCIpfX0sNzgzOToodCxlLG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS54b3I9ZS5zdWI9ZS5wUmVsdT1lLnBvdz1lLm9yPWUubXVsPWUubGVzcz1lLmdyZWF0ZXI9ZS5lcXVhbD1lLmRpdj1lLmFuZD1lLmFkZD1lLmdsc2xQUmVsdT1lLmdsc2xQb3c9ZS5nbHNsWG9yPWUuZ2xzbE9yPWUuZ2xzbEFuZD1lLmdsc2xMZXNzPWUuZ2xzbEdyZWF0ZXI9ZS5nbHNsRXF1YWw9ZS5nbHNsU3ViPWUuZ2xzbE11bD1lLmdsc2xEaXY9ZS5nbHNsQWRkPXZvaWQgMDtjb25zdCByPW4oMjUxNyksaT1uKDg1MjApLG89big1MDYwKSxhPW4oMjAzOSk7ZnVuY3Rpb24gcygpe2NvbnN0IHQ9XCJhZGRfXCI7cmV0dXJue2JvZHk6YFxcbiAgZmxvYXQgJHt0fShmbG9hdCBhLCBmbG9hdCBiKSB7XFxuICAgIHJldHVybiBhICsgYjtcXG4gIH1cXG4gIHZlYzQgJHt0fSh2ZWM0IHYxLCB2ZWM0IHYyKSB7XFxuICAgIHJldHVybiB2MSArIHYyO1xcbiAgfVxcbiAgYCxuYW1lOnQsdHlwZTppLkZ1bmN0aW9uVHlwZS5WYWx1ZUJhc2VkfX1mdW5jdGlvbiB1KCl7Y29uc3QgdD1cImRpdl9cIjtyZXR1cm57Ym9keTpgXFxuICBmbG9hdCAke3R9KGZsb2F0IGEsIGZsb2F0IGIpIHtcXG4gICAgcmV0dXJuIGEgLyBiO1xcbiAgfVxcbiAgdmVjNCAke3R9KHZlYzQgdjEsIHZlYzQgdjIpIHtcXG4gICAgcmV0dXJuIHYxIC8gdjI7XFxuICB9XFxuICBgLG5hbWU6dCx0eXBlOmkuRnVuY3Rpb25UeXBlLlZhbHVlQmFzZWR9fWZ1bmN0aW9uIGMoKXtjb25zdCB0PVwibXVsX1wiO3JldHVybntib2R5OmBcXG4gIGZsb2F0ICR7dH0oZmxvYXQgYSwgZmxvYXQgYikge1xcbiAgICByZXR1cm4gYSAqIGI7XFxuICB9XFxuICB2ZWM0ICR7dH0odmVjNCB2MSwgdmVjNCB2Mikge1xcbiAgICByZXR1cm4gdjEgKiB2MjtcXG4gIH1cXG4gIGAsbmFtZTp0LHR5cGU6aS5GdW5jdGlvblR5cGUuVmFsdWVCYXNlZH19ZnVuY3Rpb24gbCgpe2NvbnN0IHQ9XCJzdWJfXCI7cmV0dXJue2JvZHk6YFxcbiAgZmxvYXQgJHt0fShmbG9hdCBhLCBmbG9hdCBiKSB7XFxuICAgIHJldHVybiBhIC0gYjtcXG4gIH1cXG4gIHZlYzQgJHt0fSh2ZWM0IHYxLCB2ZWM0IHYyKSB7XFxuICAgIHJldHVybiB2MSAtIHYyO1xcbiAgfVxcbiAgYCxuYW1lOnQsdHlwZTppLkZ1bmN0aW9uVHlwZS5WYWx1ZUJhc2VkfX1mdW5jdGlvbiBwKCl7Y29uc3QgdD1cImVxdWFsX1wiO3JldHVybntib2R5OmBcXG4gIGZsb2F0ICR7dH0oZmxvYXQgYSwgZmxvYXQgYikge1xcbiAgICByZXR1cm4gZmxvYXQoYSA9PSBiKTtcXG4gIH1cXG4gIHZlYzQgJHt0fSh2ZWM0IHYxLCB2ZWM0IHYyKSB7XFxuICAgIHJldHVybiB2ZWM0KGVxdWFsKHYxLCB2MikpO1xcbiAgfVxcbiAgYCxuYW1lOnQsdHlwZTppLkZ1bmN0aW9uVHlwZS5WYWx1ZUJhc2VkfX1mdW5jdGlvbiBmKCl7Y29uc3QgdD1cImdyZWF0ZXJfXCI7cmV0dXJue2JvZHk6YFxcbiAgZmxvYXQgJHt0fShmbG9hdCBhLCBmbG9hdCBiKSB7XFxuICAgIHJldHVybiBmbG9hdChhID4gYik7XFxuICB9XFxuICB2ZWM0ICR7dH0odmVjNCB2MSwgdmVjNCB2Mikge1xcbiAgICByZXR1cm4gdmVjNCggdjEuciA+IHYyLnIgLFxcbiAgICAgIHYxLmcgPiB2Mi5nLFxcbiAgICAgIHYxLmIgPiB2Mi5iLFxcbiAgICAgIHYxLmEgPiB2Mi5hICk7XFxuICB9XFxuICBgLG5hbWU6dCx0eXBlOmkuRnVuY3Rpb25UeXBlLlZhbHVlQmFzZWR9fWZ1bmN0aW9uIGQoKXtjb25zdCB0PVwibGVzc19cIjtyZXR1cm57Ym9keTpgXFxuICBmbG9hdCAke3R9KGZsb2F0IGEsIGZsb2F0IGIpIHtcXG4gICAgcmV0dXJuIGZsb2F0KGEgPCBiKTtcXG4gIH1cXG4gIHZlYzQgJHt0fSh2ZWM0IHYxLCB2ZWM0IHYyKSB7XFxuICAgIHJldHVybiB2ZWM0KCB2MS5yIDwgdjIuciAsXFxuICAgICAgICAgICAgICAgIHYxLmcgPCB2Mi5nLFxcbiAgICAgICAgICAgICAgICB2MS5iIDwgdjIuYixcXG4gICAgICAgICAgICAgICAgdjEuYSA8IHYyLmEgKTtcXG4gIH1cXG4gIGAsbmFtZTp0LHR5cGU6aS5GdW5jdGlvblR5cGUuVmFsdWVCYXNlZH19ZnVuY3Rpb24gaCgpe2NvbnN0IHQ9XCJhbmRfXCI7cmV0dXJue2JvZHk6YFxcbiAgZmxvYXQgJHt0fShmbG9hdCBhLCBmbG9hdCBiKSB7XFxuICAgIHJldHVybiBmbG9hdCggYm9vbChhKSAmJiBib29sKGIpICk7XFxuICB9XFxuICB2ZWM0ICR7dH0odmVjNCB2MSwgdmVjNCB2Mikge1xcbiAgICBidmVjNCBiMSA9IGJ2ZWM0KHYxKTtcXG4gICAgYnZlYzQgYjIgPSBidmVjNCh2Mik7XFxuICAgIHJldHVybiB2ZWM0KCBiMS5yICYmIGIyLnIgLFxcbiAgICAgICAgICAgICAgICBiMS5nICYmIGIyLmcsXFxuICAgICAgICAgICAgICAgIGIxLmIgJiYgYjIuYixcXG4gICAgICAgICAgICAgICAgYjEuYSAmJiBiMi5hICk7XFxuICB9XFxuICBgLG5hbWU6dCx0eXBlOmkuRnVuY3Rpb25UeXBlLlZhbHVlQmFzZWR9fWZ1bmN0aW9uIGcoKXtjb25zdCB0PVwib3JfXCI7cmV0dXJue2JvZHk6YFxcbiAgZmxvYXQgJHt0fShmbG9hdCBhLCBmbG9hdCBiKSB7XFxuICAgIHJldHVybiBmbG9hdCggYm9vbChhKSB8fCBib29sKGIpICk7XFxuICB9XFxuICB2ZWM0ICR7dH0odmVjNCB2MSwgdmVjNCB2Mikge1xcbiAgICBidmVjNCBiMSA9IGJ2ZWM0KHYxKTtcXG4gICAgYnZlYzQgYjIgPSBidmVjNCh2Mik7XFxuICAgIHJldHVybiB2ZWM0KCBiMS5yIHx8IGIyLnIgLFxcbiAgICAgICAgICAgICAgICBiMS5nIHx8IGIyLmcsXFxuICAgICAgICAgICAgICAgIGIxLmIgfHwgYjIuYixcXG4gICAgICAgICAgICAgICAgYjEuYSB8fCBiMi5hICk7XFxuICB9XFxuICBgLG5hbWU6dCx0eXBlOmkuRnVuY3Rpb25UeXBlLlZhbHVlQmFzZWR9fWZ1bmN0aW9uIGIoKXtjb25zdCB0PVwieG9yX1wiO3JldHVybntib2R5OmBcXG4gIGZsb2F0ICR7dH0oZmxvYXQgYSwgZmxvYXQgYikge1xcbiAgICByZXR1cm4gZmxvYXQoIGJvb2woYSkgXl4gYm9vbChiKSApO1xcbiAgfVxcbiAgdmVjNCAke3R9KHZlYzQgdjEsIHZlYzQgdjIpIHtcXG4gICAgYnZlYzQgYjEgPSBidmVjNCh2MSk7XFxuICAgIGJ2ZWM0IGIyID0gYnZlYzQodjIpO1xcbiAgICByZXR1cm4gdmVjNCggYjEuciBeXiBiMi5yICxcXG4gICAgICAgICAgICAgICAgYjEuZyBeXiBiMi5nLFxcbiAgICAgICAgICAgICAgICBiMS5iIF5eIGIyLmIsXFxuICAgICAgICAgICAgICAgIGIxLmEgXl4gYjIuYSApO1xcbiAgfVxcbiAgYCxuYW1lOnQsdHlwZTppLkZ1bmN0aW9uVHlwZS5WYWx1ZUJhc2VkfX1mdW5jdGlvbiBtKCl7cmV0dXJuIGZ1bmN0aW9uKHQpe2NvbnN0IGU9YCR7dH1fYDtyZXR1cm57Ym9keTpgXFxuICBmbG9hdCAke2V9KGZsb2F0IGEsIGZsb2F0IGIpIHtcXG4gICAgcmV0dXJuICR7dH0oYSwgYik7XFxuICB9XFxuICB2ZWM0ICR7ZX0odmVjNCB2MSwgdmVjNCB2Mikge1xcbiAgICByZXR1cm4gJHt0fSh2MSwgdjIpO1xcbiAgfVxcbiAgYCxuYW1lOmUsdHlwZTppLkZ1bmN0aW9uVHlwZS5WYWx1ZUJhc2VkfX0oXCJwb3dcIil9ZnVuY3Rpb24geSgpe2NvbnN0IHQ9XCJwcmVsdV9cIjtyZXR1cm57Ym9keTpgXFxuICBmbG9hdCAke3R9KGZsb2F0IGEsIGZsb2F0IGIpIHtcXG4gICAgcmV0dXJuIGEgPCAwLjAgPyBhICogYjogYTtcXG4gIH1cXG4gIHZlYzQgJHt0fSh2ZWM0IHYxLCB2ZWM0IHYyKSB7XFxuICAgIHJldHVybiB2ZWM0KFxcbiAgICAgIHYxLnIgPCAwLjAgPyB2MS5yICogdjIucjogdjEucixcXG4gICAgICB2MS5nIDwgMC4wID8gdjEuZyAqIHYyLmc6IHYxLmcsXFxuICAgICAgdjEuYiA8IDAuMCA/IHYxLmIgKiB2Mi5iOiB2MS5iLFxcbiAgICAgIHYxLmEgPCAwLjAgPyB2MS5hICogdjIuYTogdjEuYVxcbiAgICAgICk7XFxuICB9XFxuICBgLG5hbWU6dCx0eXBlOmkuRnVuY3Rpb25UeXBlLlZhbHVlQmFzZWR9fWUuZ2xzbEFkZD1zLGUuZ2xzbERpdj11LGUuZ2xzbE11bD1jLGUuZ2xzbFN1Yj1sLGUuZ2xzbEVxdWFsPXAsZS5nbHNsR3JlYXRlcj1mLGUuZ2xzbExlc3M9ZCxlLmdsc2xBbmQ9aCxlLmdsc2xPcj1nLGUuZ2xzbFhvcj1iLGUuZ2xzbFBvdz1tLGUuZ2xzbFBSZWx1PXk7Y29uc3QgXz0odCxlLG4scj1lWzBdLnR5cGUsaSk9Pntjb25zdCBvPXQuc2Vzc2lvbi5wYWNrP2EuVGV4dHVyZVR5cGUucGFja2VkOmEuVGV4dHVyZVR5cGUudW5wYWNrZWQ7cmV0dXJue25hbWU6bi5uYW1lLGlucHV0TmFtZXM6W1wiQVwiLFwiQlwiXSxpbnB1dFR5cGVzOltvLG9dLGNhY2hlSGludDppLGdldDooKT0+dih0LGUsbixyKX19LHY9KHQsZSxuLGk9ZVswXS50eXBlKT0+e2NvbnN0IHM9dC5zZXNzaW9uLnBhY2s/YS5UZXh0dXJlVHlwZS5wYWNrZWQ6YS5UZXh0dXJlVHlwZS51bnBhY2tlZCx1PSFyLlNoYXBlVXRpbC5hcmVFcXVhbChlWzBdLmRpbXMsZVsxXS5kaW1zKTtsZXQgYz1lWzBdLmRpbXM7Y29uc3QgbD10LnNlc3Npb24ucGFjaztpZih1KXtjb25zdCBhPXIuQnJvYWRjYXN0VXRpbC5jYWxjU2hhcGUoZVswXS5kaW1zLGVbMV0uZGltcywhMSk7aWYoIWEpdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgcGVyZm9ybSBiaW5hcnkgb3Agb24gdGhlIGdpdmVuIHRlbnNvcnNcIik7Yz1hO2NvbnN0IHU9Yy5sZW5ndGgscD0wIT09ZVswXS5kaW1zLmxlbmd0aD9lWzBdLmRpbXMubGVuZ3RoOjEsZj0wIT09ZVsxXS5kaW1zLmxlbmd0aD9lWzFdLmRpbXMubGVuZ3RoOjEsZD0wIT09ZVswXS5kaW1zLmxlbmd0aD9cImJjYXN0SW5kaWNlc19BKGluZGljZXMsIGFpbmRpY2VzKTtcIjpcImFpbmRpY2VzWzBdID0gMDtcIixoPTAhPT1lWzFdLmRpbXMubGVuZ3RoP1wiYmNhc3RJbmRpY2VzX0IoaW5kaWNlcywgYmluZGljZXMpO1wiOlwiYmluZGljZXNbMF0gPSAwO1wiLGc9KDAsby5nZXRHbHNsKSh0LnNlc3Npb24uYmFja2VuZC5nbENvbnRleHQudmVyc2lvbiksYj1sP2BcXG4gICAgICAke24uYm9keX1cXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICB2ZWM0IGEgPSBnZXRBQXRPdXRDb29yZHMoKTtcXG4gICAgICAgIHZlYzQgYiA9IGdldEJBdE91dENvb3JkcygpO1xcbiAgICAgICAgdmVjNCByZXN1bHQgPSAke24ubmFtZX0oYSwgYik7XFxuICAgICAgICAke2cub3V0cHV0fSA9IHJlc3VsdDtcXG4gICAgICB9YDpgXFxuICAgICAgJHtuLmJvZHl9XFxuICAgICAgZmxvYXQgcHJvY2VzcyhpbnQgaW5kaWNlc1ske3V9XSkge1xcbiAgICAgICAgaW50IGFpbmRpY2VzWyR7cH1dO1xcbiAgICAgICAgaW50IGJpbmRpY2VzWyR7Zn1dO1xcbiAgICAgICAgJHtkfVxcbiAgICAgICAgJHtofVxcbiAgICAgICAgcmV0dXJuICR7bi5uYW1lfShfQShhaW5kaWNlcyksIF9CKGJpbmRpY2VzKSk7XFxuICAgICAgfWA7cmV0dXJue25hbWU6bi5uYW1lLGlucHV0TmFtZXM6W1wiQVwiLFwiQlwiXSxpbnB1dFR5cGVzOltzLHNdLG91dHB1dDp7ZGltczpjLHR5cGU6aSx0ZXh0dXJlVHlwZTpzfSxzaGFkZXJTb3VyY2U6YixoYXNNYWluOmx9fWNvbnN0IHA9KDAsby5nZXRHbHNsKSh0LnNlc3Npb24uYmFja2VuZC5nbENvbnRleHQudmVyc2lvbiksZj1gXFxuICAgICR7bi5ib2R5fVxcbiAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgdmVjNCB2MSA9ICR7cC50ZXh0dXJlMkR9KEEsIFRleENvb3Jkcyk7XFxuICAgICAgdmVjNCB2MiA9ICR7cC50ZXh0dXJlMkR9KEIsIFRleENvb3Jkcyk7XFxuICAgICAgdmVjNCByZXN1bHQgPSAke24ubmFtZX0odjEsIHYyKTtcXG4gICAgICAke3Aub3V0cHV0fSA9IHJlc3VsdDtcXG4gICAgfVxcbiAgICBgO3JldHVybntuYW1lOm4ubmFtZSxpbnB1dE5hbWVzOltcIkFcIixcIkJcIl0saW5wdXRUeXBlczpbcyxzXSxvdXRwdXQ6e2RpbXM6ZVswXS5kaW1zLHR5cGU6aSx0ZXh0dXJlVHlwZTpzfSxzaGFkZXJTb3VyY2U6ZixoYXNNYWluOiEwfX07ZS5hZGQ9KHQsZSk9Plt0LnJ1bihfKHQsZSxzKCkpLGUpXSxlLmFuZD0odCxlKT0+W3QucnVuKF8odCxlLGgoKSxcImJvb2xcIiksZSldLGUuZGl2PSh0LGUpPT5bdC5ydW4oXyh0LGUsdSgpKSxlKV0sZS5lcXVhbD0odCxlKT0+W3QucnVuKF8odCxlLHAoKSxcImJvb2xcIiksZSldLGUuZ3JlYXRlcj0odCxlKT0+W3QucnVuKF8odCxlLGYoKSxcImJvb2xcIiksZSldLGUubGVzcz0odCxlKT0+W3QucnVuKF8odCxlLGQoKSxcImJvb2xcIiksZSldLGUubXVsPSh0LGUpPT5bdC5ydW4oXyh0LGUsYygpKSxlKV0sZS5vcj0odCxlKT0+W3QucnVuKF8odCxlLGcoKSxcImJvb2xcIiksZSldLGUucG93PSh0LGUpPT5bdC5ydW4oXyh0LGUsbSgpKSxlKV0sZS5wUmVsdT0odCxlKT0+W3QucnVuKF8odCxlLHkoKSksZSldLGUuc3ViPSh0LGUpPT5bdC5ydW4oXyh0LGUsbCgpKSxlKV0sZS54b3I9KHQsZSk9Plt0LnJ1bihfKHQsZSxiKCksXCJib29sXCIpLGUpXX0sNDE5NjoodCxlLG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5wYXJzZUNhc3RBdHRyaWJ1dGVzPWUuY2FzdD12b2lkIDA7Y29uc3Qgcj1uKDI1MTcpO2UuY2FzdD0odCxlLG4pPT4oaShlKSxbdC5jYXN0KGVbMF0sbildKSxlLnBhcnNlQ2FzdEF0dHJpYnV0ZXM9dD0+ci5Qcm90b1V0aWwudGVuc29yRGF0YVR5cGVGcm9tUHJvdG8odC5hdHRyaWJ1dGVzLmdldEludChcInRvXCIpKTtjb25zdCBpPXQ9PntpZighdHx8MSE9PXQubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIkNhc3QgcmVxdWlyZXMgMSBpbnB1dC5cIik7aWYoXCJzdHJpbmdcIj09PXRbMF0udHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGlucHV0IHR5cGUuXCIpfX0sMTE2MzoodCxlLG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5jcmVhdGVQYWNrZWRDb25jYXRQcm9ncmFtSW5mb0xvYWRlcj12b2lkIDA7Y29uc3Qgcj1uKDUwNjApLGk9bigyMDM5KSxvPW4oOTM5MCksYT1uKDI4MjcpO2UuY3JlYXRlUGFja2VkQ29uY2F0UHJvZ3JhbUluZm9Mb2FkZXI9KHQsZSxuKT0+e2NvbnN0IHU9KGM9ZS5sZW5ndGgsbD1uLmNhY2hlS2V5LHtuYW1lOlwiQ29uY2F0IChwYWNrZWQpXCIsaW5wdXROYW1lczpBcnJheS5mcm9tKHtsZW5ndGg6Y30sKCh0LGUpPT5gWCR7ZX1gKSksaW5wdXRUeXBlczpBcnJheShjKS5maWxsKGkuVGV4dHVyZVR5cGUucGFja2VkKSxjYWNoZUhpbnQ6bH0pO3ZhciBjLGw7cmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSx1KSx7Z2V0OigpPT4oKHQsZSxuLHUpPT57Y29uc3QgYz1uWzBdLmRpbXMuc2xpY2UoKTtpZih1Pj1jLmxlbmd0aHx8dTwtMSpjLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJheGlzIHNwZWNpZmllZCBmb3IgY29uY2F0IGRvZXNuJ3QgbWF0Y2ggaW5wdXQgZGltZW5zaW9uYWxpdHlcIik7dTwwJiYodT1jLmxlbmd0aCt1KTtjb25zdCBsPWMuc2xpY2UoMCk7Zm9yKGxldCB0PTE7dDxuLmxlbmd0aDt0Kyspe2NvbnN0IGU9blt0XS5kaW1zLnNsaWNlKCk7Zm9yKGxldCB0PTA7dDxjLmxlbmd0aDt0KyspaWYodD09PXUpbFt1XSs9ZVt0XTtlbHNlIGlmKGNbdF0hPT1lW3RdKXRocm93IG5ldyBFcnJvcihcIm5vbiBjb25jYXQgZGltZW5zaW9ucyBtdXN0IG1hdGNoXCIpfWNvbnN0IHA9bC5sZW5ndGgsZj0oMCxhLmdldENoYW5uZWxzKShcImNvb3Jkc1wiLHApLGQ9KDAsby5nZXRDb29yZHNEYXRhVHlwZSkocCksaD0oMCxhLnVucGFja0Zyb21DaGFubmVsKSgpLGc9bi5tYXAoKHQ9PnQuZGltcykpLGI9KDAsby5nZXRHbENoYW5uZWxzKShwKSxtPW5ldyBBcnJheShnLmxlbmd0aC0xKTttWzBdPWdbMF1bdV07Zm9yKGxldCB0PTE7dDxtLmxlbmd0aDt0KyspbVt0XT1tW3QtMV0rZ1t0XVt1XTtjb25zdCB5PWJbdV0sXz1iLnNsaWNlKC0yKSx2PWIuam9pbigpO2xldCB3PWBpZiAoJHt5fSA8ICR7bVswXX0pIHtcXG4gICAgICAgIHJldHVybiBnZXRDaGFubmVsKFxcbiAgICAgICAgICAgIGdldFgwKCR7dn0pLCB2ZWMyKCR7Xy5qb2luKCl9KSk7XFxuICAgICAgICB9YDtmb3IobGV0IHQ9MTt0PG0ubGVuZ3RoO3QrKyl7Y29uc3QgZT1tW3QtMV07dys9YFxcbiAgICAgICAgICAgIGlmICgke3l9IDwgJHttW3RdfSAgJiYgJHt5fSA+PSAke21bdC0xXX0pIHtcXG4gICAgICAgICAgICAgIHJldHVybiBnZXRDaGFubmVsKFxcbiAgICAgICAgICAgICAgICBnZXRYJHt0fSgke3MoYix5LGUpfSksXFxuICAgICAgICAgICAgICAgIHZlYzIoJHtzKF8seSxlKX0pKTtcXG4gICAgICAgICAgICB9YH1jb25zdCB4PW0ubGVuZ3RoLFQ9bVttLmxlbmd0aC0xXTt3Kz1gXFxuICAgICAgICAgICAgcmV0dXJuIGdldENoYW5uZWwoXFxuICAgICAgICAgICAgICBnZXRYJHt4fSgke3MoYix5LFQpfSksXFxuICAgICAgICAgICAgICB2ZWMyKCR7cyhfLHksVCl9KSk7YDtjb25zdCBTPSgwLHIuZ2V0R2xzbCkodC5zZXNzaW9uLmJhY2tlbmQuZ2xDb250ZXh0LnZlcnNpb24pLE89YFxcbiAgICAgICAgICAke2h9XFxuICAgICAgICAgIGZsb2F0IGdldFZhbHVlKCR7Yi5tYXAoKHQ9PlwiaW50IFwiK3QpKX0pIHtcXG4gICAgICAgICAgICAke3d9XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgICAgICR7ZH0gY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICAgICAgaW50IGxhc3REaW0gPSBjb29yZHMuJHtiW3AtMV19O1xcbiAgICAgICAgICAgIGNvb3Jkcy4ke2JbcC0xXX0gPSBjb29yZHMuJHtiW3AtMl19O1xcbiAgICAgICAgICAgIGNvb3Jkcy4ke2JbcC0yXX0gPSBsYXN0RGltO1xcblxcbiAgICAgICAgICAgIHZlYzQgcmVzdWx0ID0gdmVjNChnZXRWYWx1ZSgke2Z9KSwgMC4sIDAuLCAwLik7XFxuXFxuICAgICAgICAgICAgJHtmW3AtMV19ID0gJHtmW3AtMV19ICsgMTtcXG4gICAgICAgICAgICBpZiAoJHtmW3AtMV19IDwgJHtsW3AtMV19KSB7XFxuICAgICAgICAgICAgICByZXN1bHQuZyA9IGdldFZhbHVlKCR7Zn0pO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAke2ZbcC0yXX0gPSAke2ZbcC0yXX0gKyAxO1xcbiAgICAgICAgICAgIGlmICgke2ZbcC0yXX0gPCAke2xbcC0yXX0pIHtcXG4gICAgICAgICAgICAgIHJlc3VsdC5hID0gZ2V0VmFsdWUoJHtmfSk7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICR7ZltwLTFdfSA9ICR7ZltwLTFdfSAtIDE7XFxuICAgICAgICAgICAgaWYgKCR7ZltwLTJdfSA8ICR7bFtwLTJdfSAmJlxcbiAgICAgICAgICAgICAgICAke2ZbcC0xXX0gPCAke2xbcC0xXX0pIHtcXG4gICAgICAgICAgICAgIHJlc3VsdC5iID0gZ2V0VmFsdWUoJHtmfSk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICR7Uy5vdXRwdXR9ID0gcmVzdWx0O1xcbiAgICAgICAgICB9XFxuICAgICAgICBgO3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sZSkse291dHB1dDp7ZGltczpsLHR5cGU6blswXS50eXBlLHRleHR1cmVUeXBlOmkuVGV4dHVyZVR5cGUucGFja2VkfSxzaGFkZXJTb3VyY2U6TyxoYXNNYWluOiEwfSl9KSh0LHUsZSxuLmF4aXMpfSl9O2NvbnN0IHM9KHQsZSxuKT0+e2NvbnN0IHI9dC5pbmRleE9mKGUpO3JldHVybiB0Lm1hcCgoKHQsZSk9PmU9PT1yP2Ake3R9IC0gJHtufWA6dCkpLmpvaW4oKX19LDIwNjk6KHQsZSxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUucGFyc2VDb25jYXRBdHRyaWJ1dGVzPWUuY29uY2F0PXZvaWQgMDtjb25zdCByPW4oMjQ2KSxpPW4oMjAzOSksbz1uKDExNjMpO2UuY29uY2F0PSh0LGUsbik9PihwKGUpLHQuc2Vzc2lvbi5wYWNrJiZlWzBdLmRpbXMubGVuZ3RoPjE/W3QucnVuKCgwLG8uY3JlYXRlUGFja2VkQ29uY2F0UHJvZ3JhbUluZm9Mb2FkZXIpKHQsZSxuKSxlKV06W3QucnVuKGEodCxlLG4pLGUpXSk7Y29uc3QgYT0odCxlLG4pPT57Y29uc3Qgcj0obz1lLmxlbmd0aCxhPW4uY2FjaGVLZXkse25hbWU6XCJDb25jYXRcIixpbnB1dE5hbWVzOkFycmF5LmZyb20oe2xlbmd0aDpvfSwoKHQsZSk9PmBYJHtlfWApKSxpbnB1dFR5cGVzOkFycmF5KG8pLmZpbGwoaS5UZXh0dXJlVHlwZS51bnBhY2tlZCksY2FjaGVIaW50OmF9KTt2YXIgbyxhO3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30scikse2dldDooKT0+KCh0LGUsbixyKT0+e2NvbnN0IG89blswXS5kaW1zLnNsaWNlKCk7aWYocj49by5sZW5ndGh8fHI8LTEqby5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiYXhpcyBzcGVjaWZpZWQgZm9yIGNvbmNhdCBkb2Vzbid0IG1hdGNoIGlucHV0IGRpbWVuc2lvbmFsaXR5XCIpO3I8MCYmKHI9by5sZW5ndGgrcik7Y29uc3QgYT1vLnNsaWNlKDApO2ZvcihsZXQgdD0xO3Q8bi5sZW5ndGg7dCsrKXtjb25zdCBlPW5bdF0uZGltcy5zbGljZSgpO2ZvcihsZXQgdD0wO3Q8by5sZW5ndGg7dCsrKWlmKHQ9PT1yKWFbcl0rPWVbdF07ZWxzZSBpZihvW3RdIT09ZVt0XSl0aHJvdyBuZXcgRXJyb3IoXCJub24gY29uY2F0IGRpbWVuc2lvbnMgbXVzdCBtYXRjaFwiKX1jb25zdCBwPWEubGVuZ3RoLGY9bmV3IEFycmF5KG4ubGVuZ3RoKTtsZXQgZD0wO2ZvcihsZXQgdD0wO3Q8Zi5sZW5ndGg7Kyt0KWQrPW5bdF0uZGltc1tyXSxmW3RdPWQ7bGV0IGg9XCJcIjtoPW4ubGVuZ3RoPDU/cyhmKTp1KGYpO2NvbnN0IGc9YFxcbiAgICAgICAgJHtjKG4ubGVuZ3RoLHApfVxcbiAgICAgICAgJHtsKGYpfVxcbiAgICAgICAgJHtofVxcbiAgICAgICAgZmxvYXQgcHJvY2VzcyhpbnQgaW5kaWNlc1ske3B9XSkge1xcbiAgICAgICAgICBpbnQgdGV4dHVyZUluZGV4ID0gZ2V0VGV4dHVyZVdoZXJlRGF0YVJlc2lkZXMgKGluZGljZXNbJHtyfV0pO1xcblxcbiAgICAgICAgICBpZih0ZXh0dXJlSW5kZXggIT0gMCkge1xcbiAgICAgICAgICAgIGluZGljZXNbJHtyfV0gPSBpbmRpY2VzWyR7cn1dIC0gaW50KGdldFNpemVJbkNvbmNhdEF4aXNWYWx1ZUZyb21JbmRleCh0ZXh0dXJlSW5kZXgtaW50KDEpKSk7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgcmV0dXJuIGZldGNoRGF0YUZyb21Db3JyZWN0VGV4dHVyZSh0ZXh0dXJlSW5kZXgsIGluZGljZXMpO1xcbiAgICAgICAgfWA7cmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxlKSx7b3V0cHV0OntkaW1zOmEsdHlwZTpuWzBdLnR5cGUsdGV4dHVyZVR5cGU6aS5UZXh0dXJlVHlwZS51bnBhY2tlZH0sc2hhZGVyU291cmNlOmd9KX0pKDAscixlLG4uYXhpcyl9KX0scz10PT57Y29uc3QgZT10Lm1hcCgoKHQsZSk9PmBpZihpbmRleDwke3R9KSB7cmV0dXJuICR7ZX07fVxcbmApKTtyZXR1cm5gaW50IGdldFRleHR1cmVXaGVyZURhdGFSZXNpZGVzKGludCBpbmRleCkge1xcbiAgICAgICR7ZS5qb2luKFwiXCIpfVxcbiAgICB9YH0sdT10PT5zKHQpLGM9KHQsZSk9Pntjb25zdCBuPVtgZmxvYXQgZmV0Y2hEYXRhRnJvbUNvcnJlY3RUZXh0dXJlKGludCB0ZXh0dXJlSW5kZXgsIGludCBpbmRpY2VzWyR7ZX1dKSB7YF07Zm9yKGxldCBlPTA7ZTx0OysrZSkwPT09ZT9uLnB1c2goYFxcdGlmICh0ZXh0dXJlSW5kZXggPT0gJHtlfSkgeyByZXR1cm4gX1gke2V9KGluZGljZXMpOyB9YCk6ZT09PXQtMT9uLnB1c2goYFxcdGVsc2UgeyByZXR1cm4gX1gke2V9KGluZGljZXMpOyB9YCk6bi5wdXNoKGBcXHRlbHNlIGlmICh0ZXh0dXJlSW5kZXggPT0gJHtlfSkgeyByZXR1cm4gX1gke2V9KGluZGljZXMpOyB9YCk7cmV0dXJuIG4ucHVzaChcIlxcdH1cIiksbi5qb2luKFwiXFxuXCIpfSxsPXQ9Pntjb25zdCBlPVtcImludCBnZXRTaXplSW5Db25jYXRBeGlzVmFsdWVGcm9tSW5kZXgoaW50IGluZGV4KSB7XCJdO2ZvcihsZXQgbj0wO248dC5sZW5ndGg7KytuKTA9PT1uP2UucHVzaChgXFx0aWYgKGluZGV4ID09ICR7bn0pIHsgcmV0dXJuICR7dFtuXX07IH1gKTpuPT09dC5sZW5ndGgtMT9lLnB1c2goYFxcdGVsc2UgeyByZXR1cm4gJHt0W25dfTsgfWApOmUucHVzaChgXFx0ZWxzZSBpZiAoaW5kZXggPT0gJHtufSkgeyByZXR1cm4gJHt0W25dfTsgfWApO3JldHVybiBlLnB1c2goXCJcXHR9XCIpLGUuam9pbihcIlxcblwiKX07ZS5wYXJzZUNvbmNhdEF0dHJpYnV0ZXM9dD0+KDAsci5jcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkpKHtheGlzOnQuYXR0cmlidXRlcy5nZXRJbnQoXCJheGlzXCIpfSk7Y29uc3QgcD10PT57aWYoIXR8fHQubGVuZ3RoPDEpdGhyb3cgbmV3IEVycm9yKFwidG9vIGZldyBpbnB1dHNcIik7Y29uc3QgZT10WzBdLnR5cGUsbj10WzBdLmRpbXMubGVuZ3RoO2lmKFwic3RyaW5nXCI9PT1lKXRocm93IG5ldyBFcnJvcihcInN0cmluZyB0ZW5zb3IgaXMgbm90IHN1cHBvcnRlZCB5ZXRcIik7Zm9yKGNvbnN0IHIgb2YgdCl7aWYoci50eXBlIT09ZSl0aHJvdyBuZXcgRXJyb3IoXCJpbnB1dCB0ZW5zb3JzIHNob3VsZCBiZSBvbmUgdHlwZVwiKTtpZihyLmRpbXMubGVuZ3RoIT09bil0aHJvdyBuZXcgRXJyb3IoXCJpbnB1dCB0ZW5zb3JzIHNob3VsZCBoYXZlIHRoZSBzYW1lIHNoYXBlXCIpfX19LDQ3NzA6KHQsZSxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUuY3JlYXRlVW5wYWNrZWRHcm91cGVkQ29udlByb2dyYW1JbmZvTG9hZGVyPXZvaWQgMDtjb25zdCByPW4oMzY5NCksaT1uKDUwNjApLG89bigyMDM5KSxhPW4oODEzOCkscz1uKDI4MjMpO2UuY3JlYXRlVW5wYWNrZWRHcm91cGVkQ29udlByb2dyYW1JbmZvTG9hZGVyPSh0LGUsbik9Pntjb25zdCB1PShjPWUubGVuZ3RoPjIsbD1uLmNhY2hlS2V5LHtuYW1lOlwiR3JvdXBlZENvbnZcIixpbnB1dE5hbWVzOmM/W1wiWFwiLFwiV1wiLFwiQmlhc1wiXTpbXCJYXCIsXCJXXCJdLGlucHV0VHlwZXM6Yz9bby5UZXh0dXJlVHlwZS51bnBhY2tlZCxvLlRleHR1cmVUeXBlLnVucGFja2VkLG8uVGV4dHVyZVR5cGUudW5wYWNrZWRdOltvLlRleHR1cmVUeXBlLnVucGFja2VkLG8uVGV4dHVyZVR5cGUudW5wYWNrZWRdLGNhY2hlSGludDpsfSk7dmFyIGMsbDtyZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LHUpLHtnZXQ6KCk9PigodCxlLG4sdSk9Pntjb25zdCBjPWUubGVuZ3RoPjI/XCJ2YWx1ZSArPSBnZXRCaWFzKG91dHB1dF9jaGFubmVsKTtcIjpcIlwiLGw9ZVswXS5kaW1zLnNsaWNlKCkscD1lWzFdLmRpbXMuc2xpY2UoKSxmPXBbMF0vdS5ncm91cDtyLkxvZ2dlci52ZXJib3NlKFwiR3JvdXBlZENvbnZcIixgYXV0cFBhZDoke3UuYXV0b1BhZH0sIGRpbGF0aW9uczoke3UuZGlsYXRpb25zfSwgZ3JvdXA6JHt1Lmdyb3VwfSwga2VybmVsU2hhcGU6JHt1Lmtlcm5lbFNoYXBlfSwgcGFkczoke3UucGFkc30sIHN0cmlkZXM6JHt1LnN0cmlkZXN9YCk7Y29uc3QgZD0oMCxhLmNhbGN1bGF0ZU91dHB1dFNoYXBlKShsLHAsdS5kaWxhdGlvbnMsdS5wYWRzLHUuc3RyaWRlcyksaD0oMCxpLmdldEdsc2wpKHQuc2Vzc2lvbi5iYWNrZW5kLmdsQ29udGV4dC52ZXJzaW9uKSx7YWN0aXZhdGlvbkZ1bmN0aW9uOmcsYXBwbHlBY3RpdmF0aW9uOmJ9PSgwLHMuZ2V0QWN0aXZhdGlvblNuaXBwZXQpKHUpLG09YFxcbiAgY29uc3QgaXZlYzIgc3RyaWRlcyA9IGl2ZWMyKCR7dS5zdHJpZGVzWzBdfSwgJHt1LnN0cmlkZXNbMV19KTtcXG4gIGNvbnN0IGl2ZWMyIHBhZHMgPSBpdmVjMigke3UucGFkc1swXX0sICR7dS5wYWRzWzFdfSk7XFxuICAke2d9XFxuICB2b2lkIG1haW4oKSB7XFxuICAgIGl2ZWM0IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICBpbnQgYmF0Y2ggPSBjb29yZHMueDtcXG4gICAgaW50IG91dHB1dF9jaGFubmVsID0gY29vcmRzLnk7XFxuICAgIGl2ZWMyIHhSQ0Nvcm5lciA9IGNvb3Jkcy56dyAqIHN0cmlkZXMgLSBwYWRzO1xcbiAgICBpbnQgZ3JvdXBfaWQgPSBvdXRwdXRfY2hhbm5lbCAvICR7Zn07XFxuXFxuICAgIGZsb2F0IHZhbHVlID0gMC4wO1xcbiAgICBmb3IgKGludCB3SW5DaGFubmVsID0gMDsgd0luQ2hhbm5lbCA8ICR7cFsxXX07IHdJbkNoYW5uZWwrKykge1xcbiAgICAgIGludCBpbnB1dF9jaGFubmVsID0gZ3JvdXBfaWQgKiAke3BbMV19ICsgd0luQ2hhbm5lbDtcXG4gICAgICBmb3IgKGludCB3SGVpZ2h0ID0gMDsgd0hlaWdodCA8ICR7cFsyXX07IHdIZWlnaHQrKykge1xcbiAgICAgICAgaW50IHhIZWlnaHQgPSB4UkNDb3JuZXIueCArIHdIZWlnaHQgKiAke3UuZGlsYXRpb25zWzBdfTtcXG5cXG4gICAgICAgIGlmICh4SGVpZ2h0IDwgMCB8fCB4SGVpZ2h0ID49ICR7bFsyXX0pIHtcXG4gICAgICAgICAgY29udGludWU7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBmb3IgKGludCB3V2lkdGggPSAwOyB3V2lkdGggPCAke3BbM119OyB3V2lkdGgrKykge1xcbiAgICAgICAgICBpbnQgeFdpZHRoID0geFJDQ29ybmVyLnkgKyB3V2lkdGggKiAke3UuZGlsYXRpb25zWzFdfTtcXG4gICAgICAgICAgaWYgKHhXaWR0aCA8IDAgfHwgeFdpZHRoID49ICR7bFszXX0pIHtcXG4gICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBmbG9hdCB4VmFsID0gZ2V0WChiYXRjaCwgaW5wdXRfY2hhbm5lbCwgeFdpZHRoLCB4SGVpZ2h0KTtcXG4gICAgICAgICAgZmxvYXQgd1ZhbCA9IGdldFcob3V0cHV0X2NoYW5uZWwsIHdJbkNoYW5uZWwsIHdXaWR0aCwgd0hlaWdodCk7XFxuICAgICAgICAgIHZhbHVlICs9IHhWYWwqd1ZhbDtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH1cXG4gICAgJHtjfVxcbiAgICAke2J9XFxuICAgICR7aC5vdXRwdXR9ID0gdmVjNCh2YWx1ZSwgLjAsIC4wLCAuMCk7XFxuICB9XFxuYDtyZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LG4pLHtvdXRwdXQ6e2RpbXM6ZCx0eXBlOmVbMF0udHlwZSx0ZXh0dXJlVHlwZTpvLlRleHR1cmVUeXBlLnVucGFja2VkfSxzaGFkZXJTb3VyY2U6bSxoYXNNYWluOiEwfSl9KSh0LGUsdSxuKX0pfX0sMTM4NjoodCxlLG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5jb252MkRQYWNrZWQ9ZS5jb252MkRQYWNrZWRQb2ludHdpc2U9dm9pZCAwO2NvbnN0IHI9big4MTM4KSxpPW4oODU1NSksbz1uKDcwOCk7ZS5jb252MkRQYWNrZWRQb2ludHdpc2U9KHQsZSxuKT0+e2NvbnN0IGk9ZVswXS5kaW1zLGE9ZVsxXS5kaW1zLHM9KDAsci5jYWxjdWxhdGVPdXRwdXRTaGFwZSkoaSxhLG4uZGlsYXRpb25zLG4ucGFkcyxuLnN0cmlkZXMpLHU9dC5yZXNoYXBlUGFja2VkKGVbMF0sW2lbMV0saVsyXSppWzNdXSksYz10LnJlc2hhcGVQYWNrZWQoZVsxXSxbYVswXSxhWzFdXSksbD1lLmxlbmd0aD4yP1tjLHUsZVsyXV06W2MsdV0scD10LnJ1bigoMCxvLmNyZWF0ZVBhY2tlZE1hdG11bFByb2dyYW1JbmZvTG9hZGVyKSh0LGwsbiksbCk7cmV0dXJuIHQucmVzaGFwZVBhY2tlZChwLHMpfSxlLmNvbnYyRFBhY2tlZD0odCxlLG4pPT57Y29uc3QgYT1lWzBdLmRpbXMscz1lWzFdLmRpbXMsdT0oMCxyLmNhbGN1bGF0ZU91dHB1dFNoYXBlKShhLHMsbi5kaWxhdGlvbnMsbi5wYWRzLG4uc3RyaWRlcyksYz10LnJ1bigoMCxpLmNyZWF0ZVBhY2tlZEltMkNvbFByb2dyYW1JbmZvTG9hZGVyKSh0LGVbMF0sZVsxXSx1LG4pLFtlWzBdXSksbD10LnJlc2hhcGVQYWNrZWQoZVsxXSxbc1swXSxzWzFdKnNbMl0qc1szXV0pLHA9Mz09PWUubGVuZ3RoP1tsLGMsZVsyXV06W2wsY10sZj10LnJ1bigoMCxvLmNyZWF0ZVBhY2tlZE1hdG11bFByb2dyYW1JbmZvTG9hZGVyKSh0LHAsbikscCk7cmV0dXJuIHQucmVzaGFwZVBhY2tlZChmLHUpfX0sOTY2MzoodCxlLG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5wYXJzZUNvbnZUcmFuc3Bvc2VBdHRyaWJ1dGVzPWUuY29udlRyYW5zcG9zZT12b2lkIDA7Y29uc3Qgcj1uKDI0NiksaT1uKDUwNjApLG89bigyMDM5KSxhPW4oMjgyMykscz0odCxlLG4scixpLG8pPT4odC0xKSplK24rKHItMSkqaSsxLW8sdT0odCxlLG4scixpKT0+e2NvbnN0IG89TWF0aC5mbG9vcih0LzIpO1wiU0FNRV9VUFBFUlwiPT09ZT8obltyXT1vLG5baV09dC1vKTpcIlNBTUVfTE9XRVJcIj09PWUmJihuW3JdPXQtbyxuW2ldPW8pfTtlLmNvbnZUcmFuc3Bvc2U9KHQsZSxuKT0+KGYoZSxuKSxjKHQsZSxuKSk7Y29uc3QgYz0odCxlLG4pPT57Y29uc3Qgcj1wKG4sZSk7cmV0dXJuW2wodCxlLHIpXX0sbD0odCxlLG4pPT50LnJ1bigoKHQsZSxuKT0+e2NvbnN0IHI9KHM9ZS5sZW5ndGg+Mix1PW4uY2FjaGVLZXkse25hbWU6XCJDb252VHJhbnNwb3NlXCIsaW5wdXROYW1lczpzP1tcIlhcIixcIldcIixcIkJcIl06W1wiWFwiLFwiV1wiXSxpbnB1dFR5cGVzOnM/W28uVGV4dHVyZVR5cGUudW5wYWNrZWQsby5UZXh0dXJlVHlwZS51bnBhY2tlZCxvLlRleHR1cmVUeXBlLnVucGFja2VkXTpbby5UZXh0dXJlVHlwZS51bnBhY2tlZCxvLlRleHR1cmVUeXBlLnVucGFja2VkXSxjYWNoZUhpbnQ6dX0pO3ZhciBzLHU7cmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxyKSx7Z2V0OigpPT4oKHQsZSxuLHIpPT57Y29uc3Qgcz1lLmxlbmd0aD4yP1wiZ2V0QihvdXRwdXRfY2hhbm5lbClcIjpcIjAuMFwiLHU9ZVswXS5kaW1zLGM9ZVsxXS5kaW1zLGw9Y1sxXSxwPWNbMF0vci5ncm91cCxmPVtlWzBdLmRpbXNbMF0sZVsxXS5kaW1zWzFdKnIuZ3JvdXAsLi4uci5vdXRwdXRTaGFwZV0sZD0oMCxpLmdldEdsc2wpKHQuc2Vzc2lvbi5iYWNrZW5kLmdsQ29udGV4dC52ZXJzaW9uKSx7YWN0aXZhdGlvbkZ1bmN0aW9uOmgsYXBwbHlBY3RpdmF0aW9uOmd9PSgwLGEuZ2V0QWN0aXZhdGlvblNuaXBwZXQpKHIpLGI9YFxcbiAgY29uc3QgaXZlYzIgc3RyaWRlcyA9IGl2ZWMyKCR7ci5zdHJpZGVzWzBdfSwgJHtyLnN0cmlkZXNbMV19KTtcXG4gIGNvbnN0IGl2ZWMyIHBhZHMgPSBpdmVjMigke3IucGFkc1swXX0sICR7ci5wYWRzWzFdfSk7XFxuICAke2h9XFxuICB2b2lkIG1haW4oKSB7XFxuICAgIGl2ZWM0IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICBpbnQgYmF0Y2ggPSBjb29yZHMueDtcXG4gICAgaW50IG91dHB1dF9jaGFubmVsID0gY29vcmRzLnk7XFxuXFxuICAgIGl2ZWMyIGxvYyA9IGNvb3Jkcy56dyArIHBhZHM7XFxuXFxuICAgIGludCBncm91cF9pZCA9IG91dHB1dF9jaGFubmVsIC8gJHtsfTtcXG4gICAgaW50IHdPdXRDaGFubmVsID0gb3V0cHV0X2NoYW5uZWwgLSBncm91cF9pZCAqICR7bH07XFxuXFxuICAgIGZsb2F0IHZhbHVlID0gJHtzfTtcXG4gICAgZm9yIChpbnQgaW5DaGFubmVsT2Zmc2V0ID0gMDsgaW5DaGFubmVsT2Zmc2V0IDwgJHtwfTsgaW5DaGFubmVsT2Zmc2V0KyspIHtcXG4gICAgICBpbnQgaW5wdXRfY2hhbm5lbCA9IGdyb3VwX2lkICogJHtwfSArIGluQ2hhbm5lbE9mZnNldDtcXG4gICAgICBmb3IgKGludCB3V09mZiA9IDA7IHdXT2ZmIDwgJHtjWzJdfTsgd1dPZmYrKykge1xcbiAgICAgICAgZm9yIChpbnQgd0hPZmYgPSAwOyB3SE9mZiA8ICR7Y1szXX07IHdIT2ZmKyspIHtcXG4gICAgICAgICAgaXZlYzIgd09mZiA9IGl2ZWMyKHdXT2ZmICogJHtyLmRpbGF0aW9uc1swXX0sIHdIT2ZmICogJHtyLmRpbGF0aW9uc1sxXX0pO1xcbiAgICAgICAgICBpdmVjMiB3TG9jID0gbG9jIC0gd09mZjtcXG4gICAgICAgICAgaXZlYzIgd0xvY0luID0gd0xvYyAvIHN0cmlkZXM7XFxuICAgICAgICAgIGlmIChcXG4gICAgICAgICAgICB3TG9jSW4gKiBzdHJpZGVzID09IHdMb2MgJiZcXG4gICAgICAgICAgICB3TG9jSW4ueCA+PSAwICYmIHdMb2NJbi54IDwgJHt1WzJdfSAmJlxcbiAgICAgICAgICAgIHdMb2NJbi55ID49IDAgJiYgd0xvY0luLnkgPCAke3VbM119XFxuICAgICAgICAgICkge1xcbiAgICAgICAgICAgIGZsb2F0IHhWYWwgPSBnZXRYKGJhdGNoLCBpbnB1dF9jaGFubmVsLCB3TG9jSW4ueSwgd0xvY0luLngpO1xcbiAgICAgICAgICAgIGZsb2F0IHdWYWwgPSBnZXRXKGlucHV0X2NoYW5uZWwsIHdPdXRDaGFubmVsLCB3SE9mZiwgd1dPZmYpO1xcbiAgICAgICAgICAgIHZhbHVlICs9IHhWYWwgKiB3VmFsO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9XFxuICAgICR7Z31cXG4gICAgJHtkLm91dHB1dH0gPSB2ZWM0KHZhbHVlLCAuMCwgLjAsIC4wKTtcXG4gIH1cXG5gO3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sbikse291dHB1dDp7ZGltczpmLHR5cGU6ZVswXS50eXBlLHRleHR1cmVUeXBlOm8uVGV4dHVyZVR5cGUudW5wYWNrZWR9LHNoYWRlclNvdXJjZTpiLGhhc01haW46ITB9KX0pKHQsZSxyLG4pfSl9KSh0LGUsbiksZSkscD0odCxlKT0+e2NvbnN0IG49dC5rZXJuZWxTaGFwZS5zbGljZSgpO2lmKDA9PT10Lmtlcm5lbFNoYXBlLmxlbmd0aClmb3IobGV0IHQ9Mjt0PGVbMV0uZGltcy5sZW5ndGg7Kyt0KW4ucHVzaChlWzFdLmRpbXNbdF0pO2NvbnN0IHI9dC5wYWRzLnNsaWNlKCksaT10Lm91dHB1dFNoYXBlLnNsaWNlKCk7KCh0LGUsbixyLGksbyxhLGMpPT57Y29uc3QgbD10Lmxlbmd0aC0yLHA9MD09PWMubGVuZ3RoO2ZvcihsZXQgZj0wO2Y8bDsrK2Ype2NvbnN0IGQ9cD90W2YrMl0qb1tmXTpjW2ZdLGg9cyh0W2YrMl0sb1tmXSxpW2ZdLGVbZl0sbltmXSxkKTt1KGgscixpLGYsZitsKSxwJiZjLnB1c2gob1tmXSoodFtmKzJdLTEpK2FbZl0rKGVbZl0tMSkqbltmXSsxLWlbZl0taVtmK2xdKX19KShlWzBdLmRpbXMsbix0LmRpbGF0aW9ucyx0LmF1dG9QYWQscix0LnN0cmlkZXMsdC5vdXRwdXRQYWRkaW5nLGkpO2NvbnN0IG89T2JqZWN0LmFzc2lnbih7fSx0KTtyZXR1cm4gT2JqZWN0LmFzc2lnbihvLHtrZXJuZWxTaGFwZTpuLHBhZHM6cixvdXRwdXRTaGFwZTppLGNhY2hlS2V5OnQuY2FjaGVLZXl9KSxvfTtlLnBhcnNlQ29udlRyYW5zcG9zZUF0dHJpYnV0ZXM9dD0+e2NvbnN0IGU9dC5hdHRyaWJ1dGVzLG49KDAsYS5wYXJzZUludGVybmFsQWN0aXZhdGlvbkF0dHJpYnV0ZXMpKGUpLGk9ZS5nZXRTdHJpbmcoXCJhdXRvX3BhZFwiLFwiTk9UU0VUXCIpLG89ZS5nZXRJbnRzKFwiZGlsYXRpb25zXCIsWzEsMV0pLHM9ZS5nZXRJbnQoXCJncm91cFwiLDEpLHU9ZS5nZXRJbnRzKFwia2VybmVsX3NoYXBlXCIsW10pLGM9ZS5nZXRJbnRzKFwib3V0cHV0X3BhZGRpbmdcIixbMCwwXSksbD1lLmdldEludHMoXCJvdXRwdXRfc2hhcGVcIixbXSkscD1lLmdldEludHMoXCJwYWRzXCIsWzAsMCwwLDBdKSxmPWUuZ2V0SW50cyhcInN0cmlkZXNcIixbMSwxXSk7cmV0dXJuKDAsci5jcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkpKE9iamVjdC5hc3NpZ24oe2F1dG9QYWQ6aSxkaWxhdGlvbnM6byxncm91cDpzLGtlcm5lbFNoYXBlOnUsb3V0cHV0UGFkZGluZzpjLG91dHB1dFNoYXBlOmwscGFkczpwLHN0cmlkZXM6Zn0sbikpfTtjb25zdCBmPSh0LGUpPT57aWYoIXR8fDIhPT10Lmxlbmd0aCYmMyE9PXQubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIkNvbnYgcmVxdWlyZXMgMiBvciAzIGlucHV0c1wiKTtpZig0IT09dFswXS5kaW1zLmxlbmd0aHx8NCE9PXRbMV0uZGltcy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiY3VycmVudGx5IG9ubHkgc3VwcG9ydCAyLWRpbWVuc2lvbmFsIGNvbnZcIik7aWYodFswXS5kaW1zWzFdIT09dFsxXS5kaW1zWzBdKXRocm93IG5ldyBFcnJvcihcIkZJTFRFUl9JTl9DSEFOTkVMIHNob3VsZCBiZSBlcXVhbCB0byBEQVRBX0NIQU5ORUxcIik7Y29uc3Qgbj10WzFdLmRpbXNbMV0qZS5ncm91cDtpZigzPT09dC5sZW5ndGgmJigxIT09dFsyXS5kaW1zLmxlbmd0aHx8dFsyXS5kaW1zWzBdIT09bikpdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBiaWFzXCIpO2NvbnN0IHI9dFswXS5kaW1zLmxlbmd0aC0yO2lmKGUuZGlsYXRpb25zLmxlbmd0aCE9PXIpdGhyb3cgbmV3IEVycm9yKGBkaWxhdGlvbnMgc2hvdWxkIGJlICR7cn1EYCk7aWYoZS5zdHJpZGVzLmxlbmd0aCE9PXIpdGhyb3cgbmV3IEVycm9yKGBzdHJpZGVzIHNob3VsZCBiZSAke3J9RGApO2lmKGUucGFkcy5sZW5ndGghPT0yKnIpdGhyb3cgbmV3IEVycm9yKGBwYWRzIHNob3VsZCBiZSAkezIqcn1EYCk7aWYoZS5vdXRwdXRQYWRkaW5nLmxlbmd0aCE9PXIpdGhyb3cgbmV3IEVycm9yKGBvdXRwdXRfcGFkZGluZyBzaG91bGQgYmUgJHtyfURgKTtpZigwIT09ZS5rZXJuZWxTaGFwZS5sZW5ndGgmJmUua2VybmVsU2hhcGUubGVuZ3RoIT09dFsxXS5kaW1zLmxlbmd0aC0yKXRocm93IG5ldyBFcnJvcihcImludmFsaWQga2VybmVsIHNoYXBlXCIpO2lmKDAhPT1lLm91dHB1dFNoYXBlLmxlbmd0aCYmZS5vdXRwdXRTaGFwZS5sZW5ndGghPT10WzBdLmRpbXMubGVuZ3RoLTIpdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBvdXRwdXQgc2hhcGVcIik7aWYoXCJmbG9hdDMyXCIhPT10WzBdLnR5cGV8fFwiZmxvYXQzMlwiIT09dFsxXS50eXBlKXRocm93IG5ldyBFcnJvcihcIkNvbnZUcmFuc3Bvc2UgaW5wdXQoWCxXKSBzaG91bGQgYmUgZmxvYXQgdGVuc29yXCIpO2lmKDM9PT10Lmxlbmd0aCYmXCJmbG9hdDMyXCIhPT10WzJdLnR5cGUpdGhyb3cgbmV3IEVycm9yKFwiQ29udlRyYW5zcG9zZSBpbnB1dChiaWFzKSBzaG91bGQgYmUgZmxvYXQgdGVuc29yXCIpfX0sODEzODoodCxlLG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5wYXJzZUNvbnZBdHRyaWJ1dGVzPWUuY29udj1lLmNhbGN1bGF0ZU91dHB1dFNoYXBlPXZvaWQgMDtjb25zdCByPW4oMjQ2KSxpPW4oMjUxNyksbz1uKDQ3NzApLGE9bigxMzg2KSxzPW4oOTgyOCksdT1uKDI4MjMpLGM9bigzMjQ4KSxsPW4oNTYyMyk7ZS5jYWxjdWxhdGVPdXRwdXRTaGFwZT0odCxlLG4scixpKT0+e2NvbnN0IG89dFswXSxhPXQuc2xpY2UoMikscz1hLmxlbmd0aCx1PWVbMF0sYz1lLnNsaWNlKDIpLm1hcCgoKHQsZSk9PnQrKHQtMSkqKG5bZV0tMSkpKSxsPWEubWFwKCgodCxlKT0+dCtyW2VdK3JbZStzXSkpLHA9bC5tYXAoKCh0LGUpPT5NYXRoLmZsb29yKCh0LWNbZV0raVtlXSkvaVtlXSkpKTtyZXR1cm5bbyx1XS5jb25jYXQoLi4ucCl9LGUuY29udj0odCxlLG4pPT4oZyhlLG4pLHAodCxlLG4pKTtjb25zdCBwPSh0LGUsbik9Pntjb25zdCByPWgobixlKSxpPXQuc2Vzc2lvbi5wYWNrLHM9MT09PXIua2VybmVsU2hhcGVbMF0mJjE9PT1yLmtlcm5lbFNoYXBlWzFdO3JldHVybiByLmdyb3VwPjE/W3QucnVuKCgwLG8uY3JlYXRlVW5wYWNrZWRHcm91cGVkQ29udlByb2dyYW1JbmZvTG9hZGVyKSh0LGUsciksZSldOnMmJmk/W2YodCxlLHIpXTppJiY0PT09ZVswXS5kaW1zLmxlbmd0aCYmMT09PWVbMF0uZGltc1swXSYmIXM/WygwLGEuY29udjJEUGFja2VkKSh0LGUscildOltkKHQsZSxyKV19LGY9KHQsbixyKT0+e2NvbnN0IGk9blswXS5kaW1zLG89blsxXS5kaW1zLGE9KDAsZS5jYWxjdWxhdGVPdXRwdXRTaGFwZSkoaSxvLHIuZGlsYXRpb25zLHIucGFkcyxyLnN0cmlkZXMpLHM9dC5yZXNoYXBlVW5wYWNrZWQoblswXSxbaVsxXSxpWzJdKmlbM11dKSx1PXQucmVzaGFwZVVucGFja2VkKG5bMV0sW29bMF0sb1sxXV0pLGM9bi5sZW5ndGg+Mj9bdSxzLG5bMl1dOlt1LHNdLHA9dC5ydW4oKDAsbC5jcmVhdGVNYXRtdWxQcm9ncmFtSW5mb0xvYWRlcikoYyxyKSxjKTtyZXR1cm4gdC5yZXNoYXBlVW5wYWNrZWQocCxhKX0sZD0odCxuLHIpPT57Y29uc3QgaT1uWzBdLmRpbXMsbz1uWzFdLmRpbXMsYT0oMCxlLmNhbGN1bGF0ZU91dHB1dFNoYXBlKShpLG8sci5kaWxhdGlvbnMsci5wYWRzLHIuc3RyaWRlcyksdT10LnJ1bigoMCxjLmNyZWF0ZUltMkNvbFByb2dyYW1JbmZvTG9hZGVyKSh0LG5bMF0sblsxXSxhLHIpLFtuWzBdXSksbD0zPT09bi5sZW5ndGg/W3UsblsxXSxuWzJdXTpbdSxuWzFdXTtyZXR1cm4gdC5ydW4oKDAscy5jcmVhdGVEb3RQcm9kdWN0UHJvZ3JhbUluZm9Mb2FkZXIpKHQsbixhLHIpLGwpfSxoPSh0LGUpPT57Y29uc3Qgbj10Lmtlcm5lbFNoYXBlLnNsaWNlKCk7aWYoMD09PXQua2VybmVsU2hhcGUubGVuZ3RoKWZvcihsZXQgdD0yO3Q8ZVsxXS5kaW1zLmxlbmd0aDsrK3Qpbi5wdXNoKGVbMV0uZGltc1t0XSk7Y29uc3Qgcj10LnBhZHMuc2xpY2UoKTtpLlBvb2xDb252VXRpbC5hZGp1c3RQYWRzQmFzZWRPbkF1dG9QYWQoZVswXS5kaW1zLHQuc3RyaWRlcyx0LmRpbGF0aW9ucyxuLHIsdC5hdXRvUGFkKTtjb25zdCBvPU9iamVjdC5hc3NpZ24oe30sdCk7cmV0dXJuIE9iamVjdC5hc3NpZ24obyx7a2VybmVsU2hhcGU6bixwYWRzOnIsY2FjaGVLZXk6dC5jYWNoZUtleX0pLG99O2UucGFyc2VDb252QXR0cmlidXRlcz10PT57Y29uc3QgZT10LmF0dHJpYnV0ZXMsbj0oMCx1LnBhcnNlSW50ZXJuYWxBY3RpdmF0aW9uQXR0cmlidXRlcykoZSksaT1lLmdldFN0cmluZyhcImF1dG9fcGFkXCIsXCJOT1RTRVRcIiksbz1lLmdldEludHMoXCJkaWxhdGlvbnNcIixbMSwxXSksYT1lLmdldEludChcImdyb3VwXCIsMSkscz1lLmdldEludHMoXCJrZXJuZWxfc2hhcGVcIixbXSksYz1lLmdldEludHMoXCJwYWRzXCIsWzAsMCwwLDBdKSxsPWUuZ2V0SW50cyhcInN0cmlkZXNcIixbMSwxXSk7cmV0dXJuKDAsci5jcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkpKE9iamVjdC5hc3NpZ24oe2F1dG9QYWQ6aSxkaWxhdGlvbnM6byxncm91cDphLGtlcm5lbFNoYXBlOnMscGFkczpjLHN0cmlkZXM6bH0sbikpfTtjb25zdCBnPSh0LGUpPT57aWYoIXR8fDIhPT10Lmxlbmd0aCYmMyE9PXQubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIkNvbnYgcmVxdWlyZXMgMiBvciAzIGlucHV0c1wiKTtpZig0IT09dFswXS5kaW1zLmxlbmd0aHx8NCE9PXRbMV0uZGltcy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiY3VycmVudGx5IG9ubHkgc3VwcG9ydCAyLWRpbWVuc2lvbmFsIGNvbnZcIik7aWYodFswXS5kaW1zWzFdIT09dFsxXS5kaW1zWzFdKmUuZ3JvdXApdGhyb3cgbmV3IEVycm9yKFwiRklMVEVSX0lOX0NIQU5ORUwgc2hvdWxkIGJlIGVxdWFsIHRvIERBVEFfQ0hBTk5FTFwiKTtpZigzPT09dC5sZW5ndGgmJigxIT09dFsyXS5kaW1zLmxlbmd0aHx8dFsxXS5kaW1zWzBdIT09dFsyXS5kaW1zWzBdKSl0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGJpYXNcIik7Y29uc3Qgbj10WzBdLmRpbXMubGVuZ3RoLTI7aWYoZS5kaWxhdGlvbnMubGVuZ3RoIT09bil0aHJvdyBuZXcgRXJyb3IoYGRpbGF0aW9ucyBzaG91bGQgYmUgJHtufURgKTtpZihlLnN0cmlkZXMubGVuZ3RoIT09bil0aHJvdyBuZXcgRXJyb3IoYHN0cmlkZXMgc2hvdWxkIGJlICR7bn1EYCk7aWYoZS5wYWRzLmxlbmd0aCE9PTIqbil0aHJvdyBuZXcgRXJyb3IoYHBhZHMgc2hvdWxkIGJlICR7MipufURgKTtpZigwIT09ZS5rZXJuZWxTaGFwZS5sZW5ndGgmJmUua2VybmVsU2hhcGUubGVuZ3RoIT09dFsxXS5kaW1zLmxlbmd0aC0yKXRocm93IG5ldyBFcnJvcihcImludmFsaWQga2VybmVsIHNoYXBlXCIpO2lmKFwiZmxvYXQzMlwiIT09dFswXS50eXBlfHxcImZsb2F0MzJcIiE9PXRbMV0udHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJDb252IGlucHV0KFgsVykgc2hvdWxkIGJlIGZsb2F0IHRlbnNvclwiKTtpZigzPT09dC5sZW5ndGgmJlwiZmxvYXQzMlwiIT09dFsyXS50eXBlKXRocm93IG5ldyBFcnJvcihcIkNvbnYgaW5wdXQoYmlhcykgc2hvdWxkIGJlIGZsb2F0IHRlbnNvclwiKX19LDUxOTM6KHQsZSxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUucGFyc2VEZXB0aFRvU3BhY2VBdHRyaWJ1dGVzPWUuZGVwdGhUb1NwYWNlPXZvaWQgMDtjb25zdCByPW4oMzczOCk7ZS5kZXB0aFRvU3BhY2U9KHQsZSxuKT0+e2koZSk7Y29uc3Qgbz1uLmJsb2Nrc2l6ZSxhPW8qbyxzPVwiRENSXCI9PT1uLm1vZGU/WzAsMyw0LDEsNSwyXTpbMCwxLDQsMiw1LDNdLHU9XCJEQ1JcIj09PW4ubW9kZT9bZVswXS5kaW1zWzBdLG8sbyxlWzBdLmRpbXNbMV0vYSxlWzBdLmRpbXNbMl0sZVswXS5kaW1zWzNdXTpbZVswXS5kaW1zWzBdLGVbMF0uZGltc1sxXS9hLG8sbyxlWzBdLmRpbXNbMl0sZVswXS5kaW1zWzNdXSxjPXQucmVzaGFwZVVucGFja2VkKGVbMF0sdSksbD17cGVybTpzLGNhY2hlS2V5OmAke3N9YH0sW3BdPSgwLHIudHJhbnNwb3NlKSh0LFtjXSxsKSxmPVtlWzBdLmRpbXNbMF0sZVswXS5kaW1zWzFdL2EsZVswXS5kaW1zWzJdKm8sZVswXS5kaW1zWzNdKm9dO3JldHVyblt0LnJlc2hhcGVVbnBhY2tlZChwLGYpXX0sZS5wYXJzZURlcHRoVG9TcGFjZUF0dHJpYnV0ZXM9dD0+e2NvbnN0IGU9dC5hdHRyaWJ1dGVzLmdldEludChcImJsb2Nrc2l6ZVwiKTtpZihlPDEpdGhyb3cgbmV3IEVycm9yKGBibG9ja3NpemUgbXVzdCBiZSA+PSAxLCBidXQgZ290IDogJHtlfSBmb3IgRGVwdGhUb1NwYWNlYCk7Y29uc3Qgbj10LmF0dHJpYnV0ZXMuZ2V0U3RyaW5nKFwibW9kZVwiLFwiRENSXCIpO2lmKFwiRENSXCIhPT1uJiZcIkNSRFwiIT09bil0aHJvdyBuZXcgRXJyb3IoYHVucmVjb2duaXplZCBtb2RlOiAke259IGZvciBEZXB0aFRvU3BhY2VgKTtyZXR1cm57bW9kZTpuLGJsb2Nrc2l6ZTplfX07Y29uc3QgaT10PT57aWYoMSE9PXQubGVuZ3RoKXRocm93IG5ldyBFcnJvcihgRGVwdGhUb1NwYWNlIGV4cGVjdCAxIGlucHV0cywgYnV0IGdvdCAke3QubGVuZ3RofWApO2lmKFwic3RyaW5nXCI9PT10WzBdLnR5cGV8fDQhPT10WzBdLmRpbXMubGVuZ3RoKXRocm93IG5ldyBUeXBlRXJyb3IoXCJEZXB0aFRvU3BhY2UgaW5wdXQgc2hvdWxkIGJlIGEgNC1EIG51bWVyaWMgdGVuc29yXCIpfX0sOTgyODoodCxlLG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5jcmVhdGVEb3RQcm9kdWN0UHJvZ3JhbUluZm9Mb2FkZXI9dm9pZCAwO2NvbnN0IHI9bigyNTE3KSxpPW4oNTA2MCksbz1uKDIwMzkpLGE9bigyODIzKSxzPW4oMzI0OCk7ZS5jcmVhdGVEb3RQcm9kdWN0UHJvZ3JhbUluZm9Mb2FkZXI9KHQsZSxuLHUpPT57Y29uc3QgYz0oKHQsZSk9Pih7bmFtZTpcIkNvbnZEb3RQcm9kdWN0XCIsaW5wdXROYW1lczp0P1tcIkltMkNvbFwiLFwiS1wiLFwiQlwiXTpbXCJJbTJDb2xcIixcIktcIl0saW5wdXRUeXBlczp0P1tvLlRleHR1cmVUeXBlLnVucGFja2VkLG8uVGV4dHVyZVR5cGUucGFja2VkTGFzdERpbWVuc2lvbixvLlRleHR1cmVUeXBlLnVucGFja2VkXTpbby5UZXh0dXJlVHlwZS51bnBhY2tlZCxvLlRleHR1cmVUeXBlLnBhY2tlZExhc3REaW1lbnNpb25dLGNhY2hlS2V5OmUuYWN0aXZhdGlvbkNhY2hlS2V5fSkpKGUubGVuZ3RoPjIsdSk7cmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxjKSx7Z2V0OigpPT4oKHQsZSxuLHUsYyk9Pntjb25zdCBsPW5bMF0uZGltcyxwPW5bMV0uZGltcyxmPVtwWzBdLE1hdGguY2VpbChsWzFdKnBbMl0qcFszXS80KV0sZD0oMCxzLmNhbGN1bGF0ZUltMkNvbERpbXMpKGwscCx1KSxbaCxnXT10LmNhbGN1bGF0ZVRleHR1cmVXaWR0aEFuZEhlaWdodChmLG8uVGV4dHVyZVR5cGUucGFja2VkTGFzdERpbWVuc2lvbiksYj1yLlNoYXBlVXRpbC5jb21wdXRlU3RyaWRlcyhkKSxbbSx5XT10LmNhbGN1bGF0ZVRleHR1cmVXaWR0aEFuZEhlaWdodChkLG8uVGV4dHVyZVR5cGUucGFja2VkTGFzdERpbWVuc2lvbiksXz11Lmxlbmd0aCx2PW4ubGVuZ3RoPDM/XCIwLjBcIjpcIl9CKGIpXCIsdz1NYXRoLmNlaWwobFsxXSpwWzJdKnBbM10vNCkse2FjdGl2YXRpb25GdW5jdGlvbjp4LGFwcGx5QWN0aXZhdGlvbjpUfT0oMCxhLmdldEFjdGl2YXRpb25TbmlwcGV0KShjKSxTPSgwLGkuZ2V0R2xzbCkodC5zZXNzaW9uLmJhY2tlbmQuZ2xDb250ZXh0LnZlcnNpb24pLE89YFxcbiR7eH1cXG5mbG9hdCBwcm9jZXNzKGludCBpbmRpY2VzWyR7X31dKSB7XFxuICBpbnQgYlsxXTtcXG4gIGJbMF0gPSBpbmRpY2VzWzFdO1xcbiAgaW50IGltMmNvbFs0XTtcXG4gIGltMmNvbFswXSA9IGluZGljZXNbMF07XFxuICBpbTJjb2xbMV0gPSBpbmRpY2VzWzJdO1xcbiAgaW0yY29sWzJdID0gaW5kaWNlc1szXTtcXG4gIGludCBpbTJjb2xPZmZzZXQgPSBpbTJjb2xbMF0gKiAke2JbMF19ICsgaW0yY29sWzFdICogJHtiWzFdfSArIGltMmNvbFsyXSAqICR7YlsyXX07XFxuICBpbnQga2VybmVsT2Zmc2V0ID0gaW5kaWNlc1sxXSAqICR7ZlsxXX07XFxuICBmbG9hdCB2YWx1ZSA9ICR7dn07XFxuICBmb3IgKGludCBpID0gMDsgaSA8ICR7d307ICsraSkge1xcbiAgICB2ZWMyIGltMmNvbENvb3JkcyA9IG9mZnNldFRvQ29vcmRzKGltMmNvbE9mZnNldCwgJHttfSwgJHt5fSk7XFxuICAgIHZlYzIga2VybmVsQ29vcmRzID0gb2Zmc2V0VG9Db29yZHMoa2VybmVsT2Zmc2V0LCAke2h9LCAke2d9KTtcXG4gICAgdmFsdWUgKz0gZG90KCR7Uy50ZXh0dXJlMkR9KEltMkNvbCwgaW0yY29sQ29vcmRzKSwgJHtTLnRleHR1cmUyRH0oSywga2VybmVsQ29vcmRzKSk7XFxuICAgICsraW0yY29sT2Zmc2V0O1xcbiAgICArK2tlcm5lbE9mZnNldDtcXG4gIH1cXG4gICR7VH1cXG4gIHJldHVybiB2YWx1ZTtcXG59YDtyZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LGUpLHtvdXRwdXQ6e2RpbXM6dSx0eXBlOm5bMF0udHlwZSx0ZXh0dXJlVHlwZTpvLlRleHR1cmVUeXBlLnVucGFja2VkfSxzaGFkZXJTb3VyY2U6T30pfSkodCxjLGUsbix1KX0pfX0sNzk5MjoodCxlLG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5wYXJzZUZsYXR0ZW5BdHRyaWJ1dGVzPWUuZmxhdHRlbj12b2lkIDA7Y29uc3Qgcj1uKDI1MTcpO2UuZmxhdHRlbj0odCxlLG4pPT57aShlLG4pO2NvbnN0IG89ci5TaGFwZVV0aWwuZmxhdHRlblNoYXBlKGVbMF0uZGltcyxuKTtyZXR1cm5bdC5yZXNoYXBlVW5wYWNrZWQoZVswXSxvKV19LGUucGFyc2VGbGF0dGVuQXR0cmlidXRlcz10PT50LmF0dHJpYnV0ZXMuZ2V0SW50KFwiYXhpc1wiLDEpO2NvbnN0IGk9KHQsZSk9PntpZighdHx8MSE9PXQubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIkZsYXR0ZW4gcmVxdWlyZXMgMSBpbnB1dC5cIik7Y29uc3Qgbj10WzBdLmRpbXMubGVuZ3RoO2lmKDA9PT1uKXRocm93IG5ldyBFcnJvcihcInNjYWxhciB0ZW5zb3IgaXMgbm90IHN1cHBvcnRlZC5cIik7aWYoZTwtbnx8ZT5uKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgYXhpc1wiKTtpZihcInN0cmluZ1wiPT09dFswXS50eXBlKXRocm93IG5ldyBFcnJvcihcInN0cmluZyB0ZW5zb3IgaXMgbm90IHN1cHBvcnRlZC5cIil9fSwyODIzOih0LGUsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLnBhcnNlSW50ZXJuYWxBY3RpdmF0aW9uQXR0cmlidXRlcz1lLmdldEFjdGl2YXRpb25TbmlwcGV0PXZvaWQgMDtjb25zdCByPW4oMjUxNyksaT1uKDQ5MDkpO2UuZ2V0QWN0aXZhdGlvblNuaXBwZXQ9ZnVuY3Rpb24odCl7bGV0IGU7c3dpdGNoKHQuYWN0aXZhdGlvbil7Y2FzZVwiUmVsdVwiOmU9KDAsaS5nbHNsUmVsdSkoKTticmVhaztjYXNlXCJTaWdtb2lkXCI6ZT0oMCxpLmdsc2xTaWdtb2lkKSgpO2JyZWFrO2Nhc2VcIkNsaXBcIjplPSgwLGkuZ2xzbENsaXApKHQuY2xpcE1pbix0LmNsaXBNYXgpO2JyZWFrO2RlZmF1bHQ6cmV0dXJue2FjdGl2YXRpb25GdW5jdGlvbjpcIlwiLGFwcGx5QWN0aXZhdGlvbjpcIlwifX1jb25zdCBuPWUubmFtZTtyZXR1cm57YWN0aXZhdGlvbkZ1bmN0aW9uOmUuYm9keSxhcHBseUFjdGl2YXRpb246YHZhbHVlID0gJHtufV8odmFsdWUpO2B9fSxlLnBhcnNlSW50ZXJuYWxBY3RpdmF0aW9uQXR0cmlidXRlcz10PT57Y29uc3QgZT10LmdldFN0cmluZyhcImFjdGl2YXRpb25cIixcIlwiKTtpZihcIkNsaXBcIj09PWUpe2NvbnN0W24saV09dC5nZXRGbG9hdHMoXCJhY3RpdmF0aW9uX3BhcmFtc1wiLFtyLk1JTl9DTElQLHIuTUFYX0NMSVBdKTtyZXR1cm57YWN0aXZhdGlvbjplLGNsaXBNYXg6aSxjbGlwTWluOm4sYWN0aXZhdGlvbkNhY2hlS2V5OmAke2V9OiR7bn0sJHtpfWB9fXJldHVybnthY3RpdmF0aW9uOmUsYWN0aXZhdGlvbkNhY2hlS2V5OmV9fX0sMTI1MzoodCxlLG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5wYXJzZUdhdGhlckF0dHJpYnV0ZXM9ZS5nYXRoZXI9dm9pZCAwO2NvbnN0IHI9bigyNDYpLGk9big3ODIpLG89bigyNTE3KSxhPW4oMjAzOSk7ZS5nYXRoZXI9KHQsZSxuKT0+KGMoZSxuLmF4aXMpLFt0LnJ1bih1KHQsZSxuKSxlKV0pLGUucGFyc2VHYXRoZXJBdHRyaWJ1dGVzPXQ9PigwLHIuY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KSh7YXhpczp0LmF0dHJpYnV0ZXMuZ2V0SW50KFwiYXhpc1wiLDApfSk7Y29uc3Qgcz17bmFtZTpcIkdhdGhlclwiLGlucHV0TmFtZXM6W1wiQVwiLFwiQlwiXSxpbnB1dFR5cGVzOlthLlRleHR1cmVUeXBlLnVucGFja2VkLGEuVGV4dHVyZVR5cGUudW5wYWNrZWRdfSx1PSh0LGUsbik9Pntjb25zdCByPU9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxzKSx7Y2FjaGVIaW50Om4uY2FjaGVLZXl9KTtyZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LHIpLHtnZXQ6KCk9PigodCxlLG4scik9Pntjb25zdCBpPW5bMF0uZGltcy5zbGljZSgpLHM9blsxXS5kaW1zLnNsaWNlKCksdT1uZXcgQXJyYXkoaS5sZW5ndGgrcy5sZW5ndGgtMSk7cj1vLlNoYXBlVXRpbC5ub3JtYWxpemVBeGlzKHIsaS5sZW5ndGgpO2NvbnN0IGM9W107Zm9yKGxldCB0PTA7dDx1Lmxlbmd0aDt0KyspdDxyPyh1W3RdPWlbdF0sYy5wdXNoKGBpbnB1dElkeFske3R9XSA9IG91dHB1dElkeFske3R9XTtgKSk6dDxyK3MubGVuZ3RoPyh1W3RdPXNbdC1yXSxjLnB1c2goYGluZGV4RGF0YUlkeFske3Qtcn1dID0gb3V0cHV0SWR4WyR7dH1dO2ApKToodVt0XT1pW3Qtcy5sZW5ndGgrMV0sYy5wdXNoKGBpbnB1dElkeFske3Qtcy5sZW5ndGgrMX1dID0gb3V0cHV0SWR4WyR7dH1dO2ApKTtjb25zdCBsPWBcXG4gICAgICBmbG9hdCBwcm9jZXNzKGludCBvdXRwdXRJZHhbJHt1Lmxlbmd0aHx8MX1dKSB7XFxuICAgICAgICBpbnQgaW5wdXRJZHhbJHtpLmxlbmd0aH1dO1xcbiAgICAgICAgaW50IGluZGV4RGF0YUlkeFske3MubGVuZ3RofHwxfV07XFxuICAgICAgICBpbmRleERhdGFJZHhbMF0gPSAwO1xcbiAgICAgICAgJHtjLmpvaW4oXCJcXG4gICAgICAgIFwiKX1cXG4gICAgICAgIGludCBpZHggPSBpbnQoX0IoaW5kZXhEYXRhSWR4KSk7XFxuICAgICAgICBpbnB1dElkeFske3J9XSA9IGlkeCA8IDAgPyBpZHggKyAke2lbcl19IDogaWR4O1xcbiAgICAgICAgcmV0dXJuIF9BKGlucHV0SWR4KTtcXG4gICAgICB9YDtyZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LGUpLHtvdXRwdXQ6e2RpbXM6dSx0eXBlOm5bMF0udHlwZSx0ZXh0dXJlVHlwZTphLlRleHR1cmVUeXBlLnVucGFja2VkfSxzaGFkZXJTb3VyY2U6bH0pfSkoMCxyLGUsbi5heGlzKX0pfSxjPSh0LGUpPT57aWYoIXR8fDIhPT10Lmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJHYXRoZXIgcmVxdWlyZXMgMiBpbnB1dHMuXCIpO2NvbnN0IG49dFswXS5kaW1zLmxlbmd0aDtpZihuPDEpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpbnB1dCBzaGFwZS5cIik7aWYoZTwtbnx8ZT5uLTEpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBheGlzLlwiKTtpZigtMT09PWkuTlVNQkVSX1RZUEVTLmluZGV4T2YodFswXS50eXBlKSl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhaWQgaW5wdXQgdHlwZS5cIik7aWYoXCJpbnQzMlwiIT09dFsxXS50eXBlJiZcImludDE2XCIhPT10WzFdLnR5cGUpdGhyb3cgbmV3IEVycm9yKFwiSW52YWlkIGlucHV0IHR5cGUuXCIpfX0sNDc3NjoodCxlLG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5wYXJzZUdlbW1BdHRyaWJ1dGVzVjExPWUucGFyc2VHZW1tQXR0cmlidXRlc1Y3PWUuZ2VtbT12b2lkIDA7Y29uc3Qgcj1uKDI0NiksaT1uKDI1MTcpLG89bigyMDM5KTtlLmdlbW09KHQsZSxuKT0+KGMoZSxuKSxbdC5ydW4ocyhlLG4pLGUpXSk7Y29uc3QgYT0odCxlKT0+e2NvbnN0IG49MCE9PXQuYXR0cmlidXRlcy5nZXRJbnQoXCJ0cmFuc0FcIiwwKSxpPTAhPT10LmF0dHJpYnV0ZXMuZ2V0SW50KFwidHJhbnNCXCIsMCksbz10LmF0dHJpYnV0ZXMuZ2V0RmxvYXQoXCJhbHBoYVwiLDEpLGE9dC5hdHRyaWJ1dGVzLmdldEZsb2F0KFwiYmV0YVwiLDEpO3JldHVybigwLHIuY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KSh7dHJhbnNBOm4sdHJhbnNCOmksYWxwaGE6byxiZXRhOmEsaXNPcHRpb25hbEM6ZX0pfTtlLnBhcnNlR2VtbUF0dHJpYnV0ZXNWNz10PT5hKHQsITEpLGUucGFyc2VHZW1tQXR0cmlidXRlc1YxMT10PT5hKHQsITApO2NvbnN0IHM9KHQsZSk9Pntjb25zdCBuPXtuYW1lOlwiR2VtbVwiLGlucHV0TmFtZXM6Mz09PXQubGVuZ3RoP1tcIkFcIixcIkJcIixcIkNcIl06W1wiQVwiLFwiQlwiXSxpbnB1dFR5cGVzOjM9PT10Lmxlbmd0aD9bby5UZXh0dXJlVHlwZS51bnBhY2tlZCxvLlRleHR1cmVUeXBlLnVucGFja2VkLG8uVGV4dHVyZVR5cGUudW5wYWNrZWRdOltvLlRleHR1cmVUeXBlLnVucGFja2VkLG8uVGV4dHVyZVR5cGUudW5wYWNrZWRdLGtleTplLmNhY2hlS2V5fTtyZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LG4pLHtnZXQ6KCk9PnUobix0LGUpfSl9LHU9KHQsZSxuKT0+e2NvbnN0IHI9ZVswXS5kaW1zLnNsaWNlKCksYT1lWzFdLmRpbXMuc2xpY2UoKSxbcyx1XT1pLkdlbW1VdGlsLmdldFNoYXBlT2ZHZW1tUmVzdWx0KHIsbi50cmFuc0EsYSxuLnRyYW5zQiwzPT09ZS5sZW5ndGg/ZVsyXS5kaW1zOnZvaWQgMCksYz1bcyx1XTtpZighYyl0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCB1c2UgZ2VtbSBvbiB0aGUgZ2l2ZW4gdGVuc29yc1wiKTtsZXQgbD1yW3IubGVuZ3RoLTFdLHA9XCJcIjtuLnRyYW5zQSYmKGw9clswXSksbi50cmFuc0EmJm4udHJhbnNCP3A9XCJ2YWx1ZSArPSBfQV9UKGEpICogX0JfVChiKTtcIjpuLnRyYW5zQSYmIW4udHJhbnNCP3A9XCJ2YWx1ZSArPSBfQV9UKGEpICogX0IoYik7XCI6IW4udHJhbnNBJiZuLnRyYW5zQj9wPVwidmFsdWUgKz0gX0EoYSkgKiBfQl9UKGIpO1wiOm4udHJhbnNBfHxuLnRyYW5zQnx8KHA9XCJ2YWx1ZSArPSBfQShhKSAqIF9CKGIpO1wiKTtjb25zdCBmPWMubGVuZ3RoLGQ9YFxcbiAgICAgIGZsb2F0IHByb2Nlc3MoaW50IGluZGljZXNbJHtmfV0pIHtcXG4gICAgICAgICAgaW50IGFbJHtmfV07XFxuICAgICAgICAgIGludCBiWyR7Zn1dO1xcbiAgICAgICAgICAkezM9PT1lLmxlbmd0aD9gaW50IGNbJHtlWzJdLmRpbXMubGVuZ3RofV07YDpcIlwifVxcblxcbiAgICAgICAgICBjb3B5VmVjKGluZGljZXMsIGEpO1xcbiAgICAgICAgICBjb3B5VmVjKGluZGljZXMsIGIpO1xcbiAgICAgICAgICAkezM9PT1lLmxlbmd0aD9cImJjYXN0SW5kaWNlc19DKGluZGljZXMsIGMpO1wiOlwiXCJ9XFxuXFxuICAgICAgICAgIGZsb2F0IHZhbHVlID0gMC4wO1xcbiAgICAgICAgICBmb3IgKGludCBrPTA7IGs8JHtsfTsgKytrKSB7XFxuICAgICAgICAgICAgICBhWyR7Zi0xfV0gPSBrO1xcbiAgICAgICAgICAgICAgYlske2YtMn1dID0gaztcXG4gICAgICAgICAgICAgICR7cH1cXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICB2YWx1ZSA9IHZhbHVlICogYWxwaGE7XFxuICAgICAgICAgICR7Mz09PWUubGVuZ3RoP1widmFsdWUgKz0gYmV0YSAqIF9DKGMpO1wiOlwiXCJ9XFxuICAgICAgICAgIHJldHVybiB2YWx1ZTtcXG4gICAgICB9YDtyZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LHQpLHtvdXRwdXQ6e2RpbXM6Yyx0eXBlOmVbMF0udHlwZSx0ZXh0dXJlVHlwZTpvLlRleHR1cmVUeXBlLnVucGFja2VkfSx2YXJpYWJsZXM6W3tuYW1lOlwiYWxwaGFcIix0eXBlOlwiZmxvYXRcIixkYXRhOm4uYWxwaGF9LHtuYW1lOlwiYmV0YVwiLHR5cGU6XCJmbG9hdFwiLGRhdGE6bi5iZXRhfV0sc2hhZGVyU291cmNlOmR9KX0sYz0odCxlKT0+e2lmKCF0KXRocm93IG5ldyBFcnJvcihcIklucHV0IGlzIG1pc3NpbmdcIik7aWYoZS5pc09wdGlvbmFsQyYmKHQubGVuZ3RoPDJ8fHQubGVuZ3RoPjMpKXRocm93IG5ldyBFcnJvcihcIkludmFpZCBpbnB1dCBzaGFwZS5cIik7aWYoIWUuaXNPcHRpb25hbEMmJjMhPT10Lmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJHZW1tIHJlcXVpcmVzIDMgaW5wdXRzXCIpO2lmKDM9PT10Lmxlbmd0aCYmMSE9PXRbMl0uZGltcy5sZW5ndGgmJjIhPT10WzJdLmRpbXMubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW5wdXQgc2hhcGUgb2YgQ1wiKTtpZihcImZsb2F0MzJcIiE9PXRbMF0udHlwZSYmXCJmbG9hdDY0XCIhPT10WzBdLnR5cGV8fFwiZmxvYXQzMlwiIT09dFsxXS50eXBlJiZcImZsb2F0NjRcIiE9PXRbMV0udHlwZXx8Mz09PXQubGVuZ3RoJiZcImZsb2F0MzJcIiE9PXRbMl0udHlwZSYmXCJmbG9hdDY0XCIhPT10WzJdLnR5cGUpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpbnB1dCB0eXBlLlwiKTtpZih0WzBdLnR5cGUhPT10WzFdLnR5cGV8fDM9PT10Lmxlbmd0aCYmdFswXS50eXBlIT09dFsyXS50eXBlKXRocm93IG5ldyBFcnJvcihcIklucHV0IHR5cGVzIGFyZSBtaXNtYXRjaGVkXCIpfX0sODU1NToodCxlLG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5jcmVhdGVQYWNrZWRJbTJDb2xQcm9ncmFtSW5mb0xvYWRlcj12b2lkIDA7Y29uc3Qgcj1uKDUwNjApLGk9bigyMDM5KSxvPW4oMjgyNyk7ZS5jcmVhdGVQYWNrZWRJbTJDb2xQcm9ncmFtSW5mb0xvYWRlcj0odCxlLG4sYSxzKT0+e2NvbnN0IHU9KGM9cy5jYWNoZUtleSx7bmFtZTpcIkltMkNvbCAocGFja2VkKVwiLGlucHV0TmFtZXM6W1wiQVwiXSxpbnB1dFR5cGVzOltpLlRleHR1cmVUeXBlLnBhY2tlZF0sY2FjaGVIaW50OmN9KTt2YXIgYztyZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LHUpLHtnZXQ6KCk9PigodCxlLG4sYSxzLHUpPT57Y29uc3QgYz1uLmRpbXMsbD1hLmRpbXMscD1zLmxlbmd0aCxmPVtsWzFdKmxbMl0qbFszXSxzWzJdKnNbM11dLGQ9bFsyXSpsWzNdLGg9KDAsby51bnBhY2tGcm9tQ2hhbm5lbCkoKSxnPSgwLHIuZ2V0R2xzbCkodC5zZXNzaW9uLmJhY2tlbmQuZ2xDb250ZXh0LnZlcnNpb24pO2xldCBiPVwiXCI7Zm9yKGxldCB0PTA7dDw9MTt0KyspZm9yKGxldCBlPTA7ZTw9MTtlKyspYis9YFxcbiAgICAgICAgICAgIGJsb2NrSW5kZXggPSByYy54ICsgJHtlfTtcXG4gICAgICAgICAgICBwb3MgPSByYy55ICsgJHt0fTtcXG5cXG4gICAgICAgICAgICBpZihibG9ja0luZGV4IDwgJHtmWzFdfSAmJiBwb3MgPCAke2ZbMF19KSB7XFxuICAgICAgICAgICAgICBvZmZzZXRZID0gaW50KGJsb2NrSW5kZXggLyAoJHtzW3AtMV19KSkgKiAke3Uuc3RyaWRlc1swXX0gLVxcbiAgICAgICAgICAgICAgICAke3UucGFkc1swXX07XFxuICAgICAgICAgICAgICBkMCA9IG9mZnNldFkgKyAke3UuZGlsYXRpb25zWzBdfSAqIChpbW9kKHBvcywgJHtkfSkgLyAke2xbMl19KTtcXG5cXG4gICAgICAgICAgICAgIGlmKGQwIDwgJHtjWzJdfSAmJiBkMCA+PSAwKSB7XFxuICAgICAgICAgICAgICAgIG9mZnNldFggPSBpbW9kKGJsb2NrSW5kZXgsICR7c1twLTFdfSkgKiAke3Uuc3RyaWRlc1sxXX0gLVxcbiAgICAgICAgICAgICAgICAgICR7dS5wYWRzWzFdfTtcXG4gICAgICAgICAgICAgICAgZDEgPSBvZmZzZXRYICsgJHt1LmRpbGF0aW9uc1sxXX0gKiBpbW9kKGltb2QocG9zLCAke2R9KSwgJHtsWzJdfSk7XFxuXFxuICAgICAgICAgICAgICAgIGlmKGQxIDwgJHtjWzNdfSAmJiBkMSA+PSAwKSB7XFxuXFxuICAgICAgICAgICAgICAgICAgY2ggPSBpbnQoZmxvYXQocG9zKS8gJHtkfS4pO1xcbiAgICAgICAgICAgICAgICAgICAgaW5uZXJEaW1zID0gdmVjMihkMCwgZDEpO1xcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0WyR7Mip0K2V9XSA9IGdldENoYW5uZWwoXFxuICAgICAgICAgICAgICAgICAgICAgIGdldEEoMCwgY2gsIGludChpbm5lckRpbXMueCksXFxuICAgICAgICAgICAgICAgICAgICAgIGludChpbm5lckRpbXMueSkpLCBpbm5lckRpbXMpO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICBgO2NvbnN0IG09YFxcbiAgICAgICR7aH1cXG5cXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBpdmVjMiByYyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgICB2ZWM0IHJlc3VsdCA9IHZlYzQoMC4wKTtcXG4gICAgICAgICAgaW50IGJsb2NrSW5kZXgsIHBvcywgb2Zmc2V0WSwgZDAsIG9mZnNldFgsIGQxLCBjaDtcXG4gICAgICAgICAgdmVjMiBpbm5lckRpbXM7XFxuICAgICAgICAgICR7Yn1cXG4gICAgICAgICAgJHtnLm91dHB1dH0gPSByZXN1bHQ7XFxuICAgICAgfVxcbiAgICAgICAgICAgIGA7cmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxlKSx7b3V0cHV0OntkaW1zOmYsdHlwZTpuLnR5cGUsdGV4dHVyZVR5cGU6aS5UZXh0dXJlVHlwZS5wYWNrZWR9LHNoYWRlclNvdXJjZTptLGhhc01haW46ITB9KX0pKHQsdSxlLG4sYSxzKX0pfX0sMzI0ODoodCxlLG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5jYWxjdWxhdGVJbTJDb2xEaW1zPWUuY3JlYXRlSW0yQ29sUHJvZ3JhbUluZm9Mb2FkZXI9dm9pZCAwO2NvbnN0IHI9bigyMDM5KTtlLmNyZWF0ZUltMkNvbFByb2dyYW1JbmZvTG9hZGVyPSh0LG4saSxvLGEpPT57Y29uc3Qgcz0odT1hLmNhY2hlS2V5LHtuYW1lOlwiSW0yQ29sXCIsaW5wdXROYW1lczpbXCJYXCJdLGlucHV0VHlwZXM6W3IuVGV4dHVyZVR5cGUudW5wYWNrZWRdLGNhY2hlSGludDp1fSk7dmFyIHU7cmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxzKSx7Z2V0OigpPT4oKHQsbixpLG8sYSxzKT0+e2NvbnN0IHU9aS5kaW1zLGM9by5kaW1zLGw9YS5sZW5ndGgscD0oMCxlLmNhbGN1bGF0ZUltMkNvbERpbXMpKHUsYyxhLDQpLGY9YFxcbiAgICAgICAgY29uc3QgaW50IFhDID0gJHt1WzFdfTtcXG4gICAgICAgIGNvbnN0IGludCBYSCA9ICR7dVsyXX07XFxuICAgICAgICBjb25zdCBpbnQgWFcgPSAke3VbM119O1xcbiAgICAgICAgY29uc3QgaW50IEtIID0gJHtzLmtlcm5lbFNoYXBlWzBdfTtcXG4gICAgICAgIGNvbnN0IGludCBLVyA9ICR7cy5rZXJuZWxTaGFwZVsxXX07XFxuICAgICAgICBjb25zdCBpbnQgZGlsYXRpb25IID0gJHtzLmRpbGF0aW9uc1swXX07XFxuICAgICAgICBjb25zdCBpbnQgZGlsYXRpb25XID0gJHtzLmRpbGF0aW9uc1sxXX07XFxuICAgICAgICBjb25zdCBpbnQgc3RyaWRlSCA9ICR7cy5zdHJpZGVzWzBdfTtcXG4gICAgICAgIGNvbnN0IGludCBzdHJpZGVXID0gJHtzLnN0cmlkZXNbMV19O1xcbiAgICAgICAgY29uc3QgaW50IHBhZEggPSAke3MucGFkc1swXX07XFxuICAgICAgICBjb25zdCBpbnQgcGFkVyA9ICR7cy5wYWRzWzFdfTtcXG4gICAgICAgIGNvbnN0IGludCBLSEtXID0gS0gqS1c7XFxuICAgICAgICBjb25zdCBpbnQgWENLSEtXID0gWEMgKiBLSEtXO1xcbiAgICAgICAgY29uc3QgaW50IG91dHB1dENoYW5uZWxzID0gNDtcXG4gICAgICAgIHZlYzQgcHJvY2VzcyhpbnQgaW5kaWNlc1ske2x9XSkge1xcbiAgICAgICAgICBpbnQgYiAgPSBpbmRpY2VzWzBdOyAvLyBiYXRjaCBzaXplXFxuICAgICAgICAgIGludCBvaCA9IGluZGljZXNbMV0gKiBzdHJpZGVIIC0gcGFkSDsgLy9vdXRwdXQgaGVpZ2h0XFxuICAgICAgICAgIGludCBvdyA9IGluZGljZXNbMl0gKiBzdHJpZGVXIC0gcGFkVzsgLy9vdXRwdXQgd2lkdGhcXG4gICAgICAgICAgaW50IHAgPSBpbmRpY2VzWzNdICogb3V0cHV0Q2hhbm5lbHM7IC8vcGF0Y2hcXG4gICAgICAgICAgdmVjNCB2YWx1ZSA9IHZlYzQoMC4wKTtcXG4gICAgICAgICAgZm9yKGludCBpPTA7IGkgPCBvdXRwdXRDaGFubmVsczsgKytpKSB7XFxuICAgICAgICAgICAgaWYocCA8IFhDS0hLVykge1xcbiAgICAgICAgICAgICAgaW50IHBhdGNoQyA9IHAgLyBLSEtXO1xcbiAgICAgICAgICAgICAgaW50IHBhdGNoSCA9IChwIC0gcGF0Y2hDKktIS1cpIC8gS1c7XFxuICAgICAgICAgICAgICBpbnQgcGF0Y2hXID0gKHAgLSBwYXRjaEMqS0hLVykgLSBwYXRjaEggKiBLVztcXG4gICAgICAgICAgICAgIGludCB4aDIgPSBvaCArIHBhdGNoSCAqIGRpbGF0aW9uSDtcXG4gICAgICAgICAgICAgIGludCB4dzIgPSBvdyArIHBhdGNoVyAqIGRpbGF0aW9uVztcXG4gICAgICAgICAgICAgIGludCB4WyR7dS5sZW5ndGh9XTtcXG4gICAgICAgICAgICAgIHhbMF0gPSBiO1xcbiAgICAgICAgICAgICAgeFsxXSA9IHBhdGNoQztcXG4gICAgICAgICAgICAgIHhbMl0gPSB4aDI7XFxuICAgICAgICAgICAgICB4WzNdID0geHcyO1xcbiAgICAgICAgICAgICAgaWYoeGgyID49IDAgJiZcXG4gICAgICAgICAgICAgICAgICB4aDIgPCBYSCAmJlxcbiAgICAgICAgICAgICAgICAgIHh3MiA+PSAwICYmXFxuICAgICAgICAgICAgICAgICAgeHcyIDwgWFcpIHtcXG4gICAgICAgICAgICAgICAgdmFsdWVbaV0gPSBfWCh4KTtcXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgKytwO1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIHJldHVybiB2YWx1ZTtcXG4gICAgICAgIH1cXG4gICAgICAgIGA7cmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxuKSx7b3V0cHV0OntkaW1zOnAsdHlwZTppLnR5cGUsdGV4dHVyZVR5cGU6ci5UZXh0dXJlVHlwZS5wYWNrZWRMYXN0RGltZW5zaW9ufSxzaGFkZXJTb3VyY2U6Zn0pfSkoMCxzLG4saSxvLGEpfSl9LGUuY2FsY3VsYXRlSW0yQ29sRGltcz0odCxlLG4scj00KT0+W25bMF0sblsyXSxuWzNdLE1hdGguY2VpbCh0WzFdKmVbMl0qZVszXS9yKV19LDY1NzI6KHQsZSxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUucGFyc2VJbWFnZVNjYWxlckF0dHJpYnV0ZXM9ZS5pbWFnZVNjYWxlcj12b2lkIDA7Y29uc3Qgcj1uKDI0NiksaT1uKDIwMzkpO2UuaW1hZ2VTY2FsZXI9KHQsZSxuKT0+KHUoZSksW3QucnVuKGEodCxlLG4pLGUpXSksZS5wYXJzZUltYWdlU2NhbGVyQXR0cmlidXRlcz10PT57Y29uc3QgZT10LmF0dHJpYnV0ZXMuZ2V0RmxvYXQoXCJzY2FsZVwiKSxuPXQuYXR0cmlidXRlcy5nZXRGbG9hdHMoXCJiaWFzXCIpO3JldHVybigwLHIuY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KSh7c2NhbGU6ZSxiaWFzOm59KX07Y29uc3Qgbz17bmFtZTpcIkltYWdlU2NhbGVyXCIsaW5wdXROYW1lczpbXCJYXCJdLGlucHV0VHlwZXM6W2kuVGV4dHVyZVR5cGUudW5wYWNrZWRdfSxhPSh0LGUsbik9Pntjb25zdCByPU9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxvKSx7Y2FjaGVIaW50Om4uY2FjaGVLZXl9KTtyZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LHIpLHtnZXQ6KCk9PigodCxlLG4scik9Pntjb25zdCBvPW5bMF0uZGltcy5zbGljZSgpLGE9by5sZW5ndGgsdT1gXFxuICAgICAgJHtzKHIuYmlhcy5sZW5ndGgpfVxcbiAgICAgIGZsb2F0IHByb2Nlc3MoaW50IGluZGljZXNbJHthfV0pIHtcXG4gICAgICAgIHJldHVybiBfWChpbmRpY2VzKSAqIHNjYWxlICsgZ2V0QmlhcyhiaWFzLCBpbmRpY2VzWzFdKTtcXG4gICAgICB9YDtyZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LGUpLHtvdXRwdXQ6e2RpbXM6byx0eXBlOm5bMF0udHlwZSx0ZXh0dXJlVHlwZTppLlRleHR1cmVUeXBlLnVucGFja2VkfSx2YXJpYWJsZXM6W3tuYW1lOlwiYmlhc1wiLHR5cGU6XCJmbG9hdFwiLGFycmF5TGVuZ3RoOnIuYmlhcy5sZW5ndGgsZGF0YTpyLmJpYXN9LHtuYW1lOlwic2NhbGVcIix0eXBlOlwiZmxvYXRcIixkYXRhOnIuc2NhbGV9XSxzaGFkZXJTb3VyY2U6dX0pfSkoMCxyLGUsbil9KX0scz10PT57Y29uc3QgZT1bYGZsb2F0IGdldEJpYXMoZmxvYXQgYmlhc1ske3R9XSwgaW50IGNoYW5uZWwpIHtgXTtmb3IobGV0IG49MDtuPHQ7KytuKTA9PT1uP2UucHVzaChgXFx0aWYgKGNoYW5uZWwgPT0gJHtufSkgeyByZXR1cm4gYmlhc1ske259XTsgfWApOm49PT10LTE/ZS5wdXNoKGBcXHRlbHNlIHsgcmV0dXJuIGJpYXNbJHtufV07IH1gKTplLnB1c2goYFxcdGVsc2UgaWYgKGNoYW5uZWwgPT0gJHtufSkgeyByZXR1cm4gYmlhc1ske259XTsgfWApO3JldHVybiBlLnB1c2goXCJcXHR9XCIpLGUuam9pbihcIlxcblwiKX0sdT10PT57aWYoIXR8fDEhPT10Lmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJJbWFnZVNjYWxlciByZXF1aXJlcyAxIGlucHV0LlwiKTtpZig0IT09dFswXS5kaW1zLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGlucHV0IHNoYXBlLlwiKTtpZihcImZsb2F0MzJcIiE9PXRbMF0udHlwZSYmXCJmbG9hdDY0XCIhPT10WzBdLnR5cGUpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpbnB1dCB0eXBlLlwiKX19LDMzNDY6KHQsZSxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUucGFyc2VJbnN0YW5jZU5vcm1hbGl6YXRpb25BdHRyaWJ1dGVzPWUuaW5zdGFuY2VOb3JtYWxpemF0aW9uPXZvaWQgMDtjb25zdCByPW4oNTA2MCksaT1uKDIwMzkpO2UuaW5zdGFuY2VOb3JtYWxpemF0aW9uPSh0LGUsbik9PntjKGUpO2NvbnN0IHI9dC5ydW4oYShlWzBdKSxlKTtyZXR1cm5bdC5ydW4odSh0LGVbMF0sbixyLmRpbXMpLFtlWzBdLHIsZVsxXSxlWzJdXSldfSxlLnBhcnNlSW5zdGFuY2VOb3JtYWxpemF0aW9uQXR0cmlidXRlcz10PT50LmF0dHJpYnV0ZXMuZ2V0RmxvYXQoXCJlcHNpbG9uXCIsMWUtNSk7Y29uc3Qgbz17bmFtZTpcIkluc3RhbmNlTm9ybWFsaXphdGlvbl9NZWFuQW5kVmFyaWFuY2VcIixpbnB1dE5hbWVzOltcIlhcIl0saW5wdXRUeXBlczpbaS5UZXh0dXJlVHlwZS51bnBhY2tlZF19LGE9dD0+T2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LG8pLHtnZXQ6KCk9PigodCxlKT0+e2NvbnN0IG49ZS5kaW1zLnNsaWNlKCkscj1uWzFdLG89blsyXSpuWzNdLGE9W25bMF0scl0scz1gXFxuICAgICAgdmVjNCBwcm9jZXNzKGludFsyXSBpbmRpY2VzKSB7XFxuICAgICAgICB2ZWM0IHYgPSB2ZWM0KDAuMCk7XFxuICAgICAgICBpbnQgYVs0XTtcXG4gICAgICAgIGFbMF0gPSBpbmRpY2VzWzBdO1xcbiAgICAgICAgYVsxXSA9IGluZGljZXNbMV07XFxuICAgICAgICBmbG9hdCB0ZW1wID0gMC4wO1xcbiAgICAgICAgZm9yKGludCBhMj0wOyBhMjwke25bMl19OyBhMisrKSB7XFxuICAgICAgICAgIGFbMl0gPSBhMjtcXG4gICAgICAgICAgZm9yKGludCBhMz0wOyBhMzwke25bM119OyBhMysrKSB7XFxuICAgICAgICAgICAgYVszXSA9IGEzO1xcbiAgICAgICAgICAgIGZsb2F0IHggPSBfWChhKTtcXG4gICAgICAgICAgICB0ZW1wICs9IHg7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIGZsb2F0IG1lYW4gPSB0ZW1wIC8gZmxvYXQoJHtvfSk7XFxuICAgICAgICB0ZW1wID0gMC4wO1xcbiAgICAgICAgZm9yKGludCBhMj0wOyBhMjwke25bMl19OyBhMisrKSB7XFxuICAgICAgICAgIGFbMl0gPSBhMjtcXG4gICAgICAgICAgZm9yKGludCBhMz0wOyBhMzwke25bM119OyBhMysrKSB7XFxuICAgICAgICAgICAgYVszXSA9IGEzO1xcbiAgICAgICAgICAgIGZsb2F0IHggPSBfWChhKTtcXG4gICAgICAgICAgICB0ZW1wICs9ICh4IC0gbWVhbikgKiAoeCAtIG1lYW4pO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICB2LnIgPSBtZWFuO1xcbiAgICAgICAgdi5nID0gdGVtcCAvIGZsb2F0KCR7b30pO1xcblxcbiAgICAgICAgcmV0dXJuIHY7XFxuICAgICAgfWA7cmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSx0KSx7b3V0cHV0OntkaW1zOmEsdHlwZTplLnR5cGUsdGV4dHVyZVR5cGU6aS5UZXh0dXJlVHlwZS5wYWNrZWRMYXN0RGltZW5zaW9ufSxzaGFkZXJTb3VyY2U6c30pfSkobyx0KX0pLHM9e25hbWU6XCJJbnN0YW5jZU5vcm1hbGl6YXRpb25fQ29tcHV0ZU91dHB1dFwiLGlucHV0TmFtZXM6W1wiWFwiLFwiTWVhbkFuZFZhcmlhbmNlXCIsXCJTY2FsZVwiLFwiQlwiXSxpbnB1dFR5cGVzOltpLlRleHR1cmVUeXBlLnVucGFja2VkLGkuVGV4dHVyZVR5cGUucGFja2VkTGFzdERpbWVuc2lvbixpLlRleHR1cmVUeXBlLnVucGFja2VkLGkuVGV4dHVyZVR5cGUudW5wYWNrZWRdfSx1PSh0LGUsbixvKT0+e2NvbnN0IGE9T2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LHMpLHtjYWNoZUhpbnQ6YCR7bn1gfSk7cmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxhKSx7Z2V0OigpPT4oKHQsZSxuLG8sYSk9Pntjb25zdCBzPSgwLHIuZ2V0R2xzbCkodC5zZXNzaW9uLmJhY2tlbmQuZ2xDb250ZXh0LnZlcnNpb24pLFt1LGNdPXQuY2FsY3VsYXRlVGV4dHVyZVdpZHRoQW5kSGVpZ2h0KGEsaS5UZXh0dXJlVHlwZS5wYWNrZWRMYXN0RGltZW5zaW9uKSxbbCxwXT1bdS80LGNdLGY9YFxcbiAgICAgIHZlYzQgZ2V0X01lYW5BbmRWYXJpYW5jZShpbnRbMl0gbXYpIHtcXG4gICAgICAgIGludCBvZmZzZXQgPSBpbmRpY2VzVG9PZmZzZXRfTWVhbkFuZFZhcmlhbmNlKG12KTtcXG4gICAgICAgIHZlYzIgY29vcmRzID0gb2Zmc2V0VG9Db29yZHMob2Zmc2V0LCAke2x9LCAke3B9KTtcXG4gICAgICAgIHJldHVybiAke3MudGV4dHVyZTJEfShNZWFuQW5kVmFyaWFuY2UsIGNvb3Jkcyk7XFxuICAgICAgfVxcblxcbiAgICAgIGZsb2F0IHByb2Nlc3MoaW50WzRdIGluZGljZXMpIHtcXG4gICAgICAgIGludCBtdlsyXTtcXG4gICAgICAgIG12WzBdID0gaW5kaWNlc1swXTtcXG4gICAgICAgIG12WzFdID0gaW5kaWNlc1sxXTtcXG4gICAgICAgIHZlYzQgbWVhbl9hbmRfdmFyaWFuY2UgPSBnZXRfTWVhbkFuZFZhcmlhbmNlKG12KTtcXG4gICAgICAgIGZsb2F0IG1lYW4gPSBtZWFuX2FuZF92YXJpYW5jZS5yO1xcbiAgICAgICAgZmxvYXQgdmFyaWFuY2UgPSBtZWFuX2FuZF92YXJpYW5jZS5nO1xcblxcbiAgICAgICAgaW50IHNiWzFdO1xcbiAgICAgICAgc2JbMF0gPSBpbmRpY2VzWzFdO1xcbiAgICAgICAgZmxvYXQgc2NhbGUgPSBfU2NhbGUoc2IpO1xcbiAgICAgICAgZmxvYXQgYiA9IF9CKHNiKTtcXG5cXG4gICAgICAgIHJldHVybiBzY2FsZSAqIChfWChpbmRpY2VzKSAtIG1lYW4pIC8gc3FydCh2YXJpYW5jZSArIGVwc2lsb24pICsgYjtcXG4gICAgICB9YDtyZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LGUpLHtvdXRwdXQ6e2RpbXM6bi5kaW1zLHR5cGU6bi50eXBlLHRleHR1cmVUeXBlOmkuVGV4dHVyZVR5cGUudW5wYWNrZWR9LHZhcmlhYmxlczpbe25hbWU6XCJlcHNpbG9uXCIsdHlwZTpcImZsb2F0XCIsZGF0YTpvfV0sc2hhZGVyU291cmNlOmZ9KX0pKHQsYSxlLG4sbyl9KX0sYz10PT57aWYoIXR8fDMhPT10Lmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJJbnN0YW5jZU5vcm1hbGl6YXRpb24gcmVxdWlyZXMgMyBpbnB1dHMuXCIpO2NvbnN0IGU9dFswXSxuPXRbMV0scj10WzJdO2lmKGUuZGltcy5sZW5ndGg8M3x8MSE9PW4uZGltcy5sZW5ndGh8fDEhPT1yLmRpbXMubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW5wdXQgc2hhcGUuXCIpO2lmKG4uZGltc1swXSE9PWUuZGltc1sxXXx8ci5kaW1zWzBdIT09ZS5kaW1zWzFdKXRocm93IG5ldyBFcnJvcihcIklucHV0IHNoYXBlcyBhcmUgbWlzbWF0Y2hlZC5cIik7aWYoXCJmbG9hdDMyXCIhPT1lLnR5cGUmJlwiZmxvYXQ2NFwiIT09ZS50eXBlfHxcImZsb2F0MzJcIiE9PW4udHlwZSYmXCJmbG9hdDY0XCIhPT1uLnR5cGV8fFwiZmxvYXQzMlwiIT09ci50eXBlJiZcImZsb2F0NjRcIiE9PXIudHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGlucHV0IHR5cGUuXCIpO2lmKDQhPT10WzBdLmRpbXMubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIk9ubHkgc3VwcG9ydCA0LUQgaW5wdXQgc2hhcGUuXCIpfX0sNzA4Oih0LGUsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLmNyZWF0ZVBhY2tlZE1hdG11bFByb2dyYW1JbmZvTG9hZGVyPXZvaWQgMDtjb25zdCByPW4oMjUxNyksaT1uKDUwNjApLG89bigyMDM5KSxhPW4oOTM5MCkscz1uKDI4MjMpLHU9big1NjIzKTtlLmNyZWF0ZVBhY2tlZE1hdG11bFByb2dyYW1JbmZvTG9hZGVyPSh0LGUsbik9Pntjb25zdCBjPShsPWUubGVuZ3RoPjIscD1uLmFjdGl2YXRpb25DYWNoZUtleSx7bmFtZTpcIk1hdE11bCAocGFja2VkKVwiLGlucHV0TmFtZXM6bD9bXCJBXCIsXCJCXCIsXCJCaWFzXCJdOltcIkFcIixcIkJcIl0saW5wdXRUeXBlczpsP1tvLlRleHR1cmVUeXBlLnBhY2tlZCxvLlRleHR1cmVUeXBlLnBhY2tlZCxvLlRleHR1cmVUeXBlLnBhY2tlZF06W28uVGV4dHVyZVR5cGUucGFja2VkLG8uVGV4dHVyZVR5cGUucGFja2VkXSxjYWNoZUhpbnQ6cH0pO3ZhciBsLHA7cmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxjKSx7Z2V0OigpPT4oKHQsZSxuLGMpPT57Y29uc3QgbD1uLmxlbmd0aD4yLHA9bD9cInZhbHVlICs9IGdldEJpYXNGb3JNYXRtdWwoKTtcIjpcIlwiLGY9blswXS5kaW1zLGQ9blsxXS5kaW1zLGg9ci5Ccm9hZGNhc3RVdGlsLmNhbGNTaGFwZShmLGQsITApLGc9IXIuU2hhcGVVdGlsLmFyZUVxdWFsKG5bMF0uZGltcyxuWzFdLmRpbXMpO2lmKCFoKXRocm93IG5ldyBFcnJvcihcIkNhbid0IHVzZSBtYXRtdWwgb24gdGhlIGdpdmVuIHRlbnNvcnNcIik7Y29uc3QgYj1mW2YubGVuZ3RoLTFdLG09TWF0aC5jZWlsKGIvMikseT1mLmxlbmd0aCxfPWQubGVuZ3RoLHY9KDAsaS5nZXRHbHNsKSh0LnNlc3Npb24uYmFja2VuZC5nbENvbnRleHQudmVyc2lvbiksdz0oMCxhLmdldENvb3Jkc0RhdGFUeXBlKShoLmxlbmd0aCkseD1oLmxlbmd0aCxUPSgwLGEuZ2V0R2xDaGFubmVscykoKSx7YWN0aXZhdGlvbkZ1bmN0aW9uOlMsYXBwbHlBY3RpdmF0aW9uOk99PSgwLHMuZ2V0QWN0aXZhdGlvblNuaXBwZXQpKGMpLEE9bD9gJHsoMCx1LmdldEJpYXNGb3JNYXRtdWwpKHcsVCxuWzJdLmRpbXMsaCwhMCl9YDpcIlwiLEU9Zz9gJHtmdW5jdGlvbih0LGUsbixpKXtsZXQgbz1bXSxhPVtdO2NvbnN0IHM9blswXS5kaW1zLHU9blsxXS5kaW1zLGM9cy5sZW5ndGgsbD11Lmxlbmd0aCxwPWkubGVuZ3RoLGY9cC1jLGQ9cC1sO289cy5tYXAoKCh0LG4pPT5gY29vcmRzLiR7ZVtuK2ZdfWApKSxvW2MtMV09XCJpKjJcIixvLmpvaW4oXCIsIFwiKSxhPXUubWFwKCgodCxuKT0+YGNvb3Jkcy4ke2VbbitkXX1gKSksYVtsLTJdPVwiaSoyXCIsYS5qb2luKFwiLCBcIik7Y29uc3QgaD1yLkJyb2FkY2FzdFV0aWwuZ2V0QnJvYWRjYXN0RGltcyhzLGkpLGc9ci5Ccm9hZGNhc3RVdGlsLmdldEJyb2FkY2FzdERpbXModSxpKSxiPWgubWFwKCh0PT5gY29vcmRzLiR7ZVt0K2ZdfSA9IDA7YCkpLmpvaW4oXCJcXG5cIiksbT1nLm1hcCgodD0+YGNvb3Jkcy4ke2VbdCtkXX0gPSAwO2ApKS5qb2luKFwiXFxuXCIpLHk9YGludCBsYXN0RGltID0gY29vcmRzLiR7ZVtwLTFdfTtcXG4gIGNvb3Jkcy4ke2VbcC0xXX0gPSBjb29yZHMuJHtlW3AtMl19O1xcbiAgY29vcmRzLiR7ZVtwLTJdfSA9IGxhc3REaW07YDtyZXR1cm5gXFxudmVjNCBnZXRBQXRPdXRDb29yZHNNYXRtdWwoaW50IGkpIHtcXG4gICR7dH0gY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAke3l9XFxuICAke2J9XFxuICB2ZWM0IG91dHB1dFZhbHVlID0gZ2V0QSgke299KTtcXG4gIHJldHVybiBvdXRwdXRWYWx1ZTtcXG59XFxuXFxudmVjNCBnZXRCQXRPdXRDb29yZHNNYXRtdWwoaW50IGkpIHtcXG4gICR7dH0gY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAke3l9XFxuICAke219XFxuICB2ZWM0IG91dHB1dFZhbHVlID0gZ2V0Qigke2F9KTtcXG4gIHJldHVybiBvdXRwdXRWYWx1ZTtcXG59YH0odyxULG4saCl9YDpcIlwiLEk9Zz9cImdldEFBdE91dENvb3Jkc01hdG11bChpKVwiOmBnZXRBKCR7ZnVuY3Rpb24odCxlKXtsZXQgbj1cIlwiO2ZvcihsZXQgcj0wO3I8ZS0yO3IrKyluKz1gcmMuJHt0W3JdfSwgYDtyZXR1cm4gbis9YHJjLiR7dFtlLTJdfSwgaSoyYCxufShULHkpfSlgLFA9Zz9cImdldEJBdE91dENvb3Jkc01hdG11bChpKVwiOmBnZXRCKCR7ZnVuY3Rpb24odCxlKXtsZXQgbj1cIlwiO2ZvcihsZXQgcj0wO3I8ZS0yO3IrKyluKz1gcmMuJHt0W3JdfSwgYDtyZXR1cm4gbis9YGkqMiwgcmMuJHt0W2UtMV19YCxufShULF8pfSlgLEQ9YFxcbiAgICAgICAgICAgICR7RX1cXG4gICAgICAgICAgICAke0F9XFxuICAgICAgICAgICAgJHtTfVxcbiAgICAgICAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgICAgICAgICR7Zz9cIlwiOmAke3d9IHJjID1cXG4gICAgICAgICAgZ2V0T3V0cHV0Q29vcmRzKCk7IGludCBsYXN0RGltID0gcmMuJHtUW3gtMV19OyByYy4ke1RbeC0xXX0gPVxcbiAgICAgICAgICByYy4ke1RbeC0yXX07IHJjLiR7VFt4LTJdfSA9IGxhc3REaW07XFxuICAgICAgYH1cXG5cXG4gICAgICAgICAgICAgIHZlYzQgdmFsdWUgPSB2ZWM0KDApO1xcbiAgICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCAke219OyBpKyspIHtcXG4gICAgICAgICAgICAgICAgdmVjNCBhID0gJHtJfTtcXG4gICAgICAgICAgICAgICAgdmVjNCBiID0gJHtQfTtcXG5cXG4gICAgICAgICAgICAgICAgdmFsdWUgKz0gKGEucnJiYiAqIGIucmdyZyk7XFxuICAgICAgICAgICAgICAgIHZhbHVlICs9IChhLmdnYWEgKiBiLmJhYmEpO1xcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgJHtwfVxcbiAgICAgICAgICAgICAgJHtPfVxcbiAgICAgICAgICAgICAgJHt2Lm91dHB1dH0gPSB2YWx1ZTtcXG4gICAgICAgICAgICB9YDtyZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LGUpLHtvdXRwdXQ6e2RpbXM6aCx0eXBlOm5bMF0udHlwZSx0ZXh0dXJlVHlwZTpvLlRleHR1cmVUeXBlLnBhY2tlZH0sc2hhZGVyU291cmNlOkQsaGFzTWFpbjohMH0pfSkodCxjLGUsbil9KX19LDU2MjM6KHQsZSxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUuZ2V0Qmlhc0Zvck1hdG11bD1lLmNyZWF0ZU1hdG11bFByb2dyYW1JbmZvTG9hZGVyPWUucGFyc2VNYXRNdWxBdHRyaWJ1dGVzPWUubWF0TXVsPXZvaWQgMDtjb25zdCByPW4oMjUxNyksaT1uKDIwMzkpLG89big5MzkwKSxhPW4oMjgyMykscz1uKDcwOCk7ZnVuY3Rpb24gdSh0LGUpe2NvbnN0IG49KHM9dC5sZW5ndGg+Mix1PWUuYWN0aXZhdGlvbkNhY2hlS2V5LHtuYW1lOlwiTWF0TXVsXCIsaW5wdXROYW1lczpzP1tcIkFcIixcIkJcIixcIkJpYXNcIl06W1wiQVwiLFwiQlwiXSxpbnB1dFR5cGVzOnM/W2kuVGV4dHVyZVR5cGUudW5wYWNrZWQsaS5UZXh0dXJlVHlwZS51bnBhY2tlZCxpLlRleHR1cmVUeXBlLnVucGFja2VkXTpbaS5UZXh0dXJlVHlwZS51bnBhY2tlZCxpLlRleHR1cmVUeXBlLnVucGFja2VkXSxjYWNoZUhpbnQ6dX0pO3ZhciBzLHU7cmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxuKSx7Z2V0OigpPT5mdW5jdGlvbih0LGUsbil7Y29uc3Qgcz1lWzBdLmRpbXMsdT1lWzFdLmRpbXMsYz1yLkJyb2FkY2FzdFV0aWwuY2FsY1NoYXBlKHMsdSwhMCk7aWYoIWMpdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgdXNlIG1hdG11bCBvbiB0aGUgZ2l2ZW4gdGVuc29yc1wiKTtjb25zdCBwPSgwLG8uZ2V0Q29vcmRzRGF0YVR5cGUpKGMubGVuZ3RoKSxmPSgwLG8uZ2V0R2xDaGFubmVscykoKSx7YWN0aXZhdGlvbkZ1bmN0aW9uOmQsYXBwbHlBY3RpdmF0aW9uOmh9PSgwLGEuZ2V0QWN0aXZhdGlvblNuaXBwZXQpKG4pLGc9ZS5sZW5ndGg+MixiPWc/XCJ2YWx1ZSArPSBnZXRCaWFzRm9yTWF0bXVsKCk7XCI6XCJcIixtPWc/YCR7bChwLGYsZVsyXS5kaW1zLGMsITEpfWA6XCJcIix5PWMubGVuZ3RoLF89cy5sZW5ndGgsdj11Lmxlbmd0aCx3PWBcXG4gICAgJHtkfVxcbiAgICAke219XFxuICAgIGZsb2F0IHByb2Nlc3MoaW50IGluZGljZXNbJHt5fV0pIHtcXG4gICAgICAgIGludCBhWyR7X31dO1xcbiAgICAgICAgaW50IGJbJHt2fV07XFxuICAgICAgICBiY2FzdE1hdG11bEluZGljZXNfQShpbmRpY2VzLCBhKTtcXG4gICAgICAgIGJjYXN0TWF0bXVsSW5kaWNlc19CKGluZGljZXMsIGIpO1xcblxcbiAgICAgICAgZmxvYXQgdmFsdWU7XFxuICAgICAgICBmb3IgKGludCBrPTA7IGs8JHtzW3MubGVuZ3RoLTFdfTsgKytrKSB7XFxuICAgICAgICAgICAgYVske18tMX1dID0gaztcXG4gICAgICAgICAgICBiWyR7di0yfV0gPSBrO1xcbiAgICAgICAgICAgIHZhbHVlICs9IF9BKGEpICogX0IoYik7XFxuICAgICAgICB9XFxuICAgICAgICAke2J9XFxuICAgICAgICAke2h9XFxuICAgICAgICByZXR1cm4gdmFsdWU7XFxuICAgIH1gO3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sdCkse291dHB1dDp7ZGltczpjLHR5cGU6ZVswXS50eXBlLHRleHR1cmVUeXBlOmkuVGV4dHVyZVR5cGUudW5wYWNrZWR9LHNoYWRlclNvdXJjZTp3fSl9KG4sdCxlKX0pfWUubWF0TXVsPSh0LGUsbik9PihjKGUpLHQuc2Vzc2lvbi5wYWNrP1t0LnJ1bigoMCxzLmNyZWF0ZVBhY2tlZE1hdG11bFByb2dyYW1JbmZvTG9hZGVyKSh0LGUsbiksZSldOlt0LnJ1bih1KGUsbiksZSldKSxlLnBhcnNlTWF0TXVsQXR0cmlidXRlcz10PT4oMCxhLnBhcnNlSW50ZXJuYWxBY3RpdmF0aW9uQXR0cmlidXRlcykodC5hdHRyaWJ1dGVzKSxlLmNyZWF0ZU1hdG11bFByb2dyYW1JbmZvTG9hZGVyPXU7Y29uc3QgYz10PT57aWYoIXR8fDIhPT10Lmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJNYXRNdWwgcmVxdWlyZXMgMiBpbnB1dHMuXCIpO2lmKHRbMF0uZGltc1t0WzBdLmRpbXMubGVuZ3RoLTFdIT09dFsxXS5kaW1zW3RbMV0uZGltcy5sZW5ndGgtMl0pdGhyb3cgbmV3IEVycm9yKFwic2hhcmVkIGRpbWVuc2lvbiBkb2VzIG5vdCBtYXRjaC5cIik7aWYoXCJmbG9hdDMyXCIhPT10WzBdLnR5cGUmJlwiZmxvYXQ2NFwiIT09dFswXS50eXBlfHxcImZsb2F0MzJcIiE9PXRbMV0udHlwZSYmXCJmbG9hdDY0XCIhPT10WzFdLnR5cGUpdGhyb3cgbmV3IEVycm9yKFwiaW5wdXRzIHNob3VsZCBiZSBmbG9hdCB0eXBlXCIpO2lmKHRbMF0udHlwZSE9PXRbMV0udHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJpbnB1dHMgdHlwZXMgc2hvdWxkIG1hdGNoXCIpfTtmdW5jdGlvbiBsKHQsZSxuLGksbyl7bGV0IGE9XCJcIjtjb25zdCBzPW4ubGVuZ3RoLHU9aS5sZW5ndGgsYz11LXM7YT11PDImJnM+MD9cImNvb3Jkc1wiOm4ubWFwKCgodCxuKT0+YGNvb3Jkcy4ke2VbbitjXX1gKSkuam9pbihcIiwgXCIpO2NvbnN0IGw9ci5Ccm9hZGNhc3RVdGlsLmdldEJyb2FkY2FzdERpbXMobixpKS5tYXAoKHQ9PmBjb29yZHMuJHtlW3QrY119ID0gMDtgKSkuam9pbihcIlxcblwiKTtsZXQgcD1cInZlYzQob3V0cHV0VmFsdWUueHgsIG91dHB1dFZhbHVlLnl5KVwiO3JldHVybiAxPT09ci5TaGFwZVV0aWwuc2l6ZShuKSYmKHA9XCJ2ZWM0KG91dHB1dFZhbHVlLngpXCIpLG8/YFxcbnZlYzQgZ2V0Qmlhc0Zvck1hdG11bCgpIHtcXG4gICR7dH0gY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAke2x9XFxuICB2ZWM0IG91dHB1dFZhbHVlID0gZ2V0Qmlhcygke2F9KTtcXG4gIHJldHVybiAke3B9O1xcbn1gOmBcXG5mbG9hdCBnZXRCaWFzRm9yTWF0bXVsKCkge1xcbiAgJHt0fSBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICR7bH1cXG4gIHJldHVybiBnZXRCaWFzKGNvb3Jkcy54KTtcXG59YH1lLmdldEJpYXNGb3JNYXRtdWw9bH0sMjQwMzoodCxlLG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5jcmVhdGVQYWNrUHJvZ3JhbUluZm9Mb2FkZXI9dm9pZCAwO2NvbnN0IHI9big1MDYwKSxpPW4oMjAzOSksbz1uKDkzOTApLGE9bigyODI3KSxzPXtuYW1lOlwicGFja1wiLGlucHV0TmFtZXM6W1wiQVwiXSxpbnB1dFR5cGVzOltpLlRleHR1cmVUeXBlLnVucGFja2VkUmV2ZXJzZWRdfTtlLmNyZWF0ZVBhY2tQcm9ncmFtSW5mb0xvYWRlcj0odCxlKT0+T2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LHMpLHtnZXQ6KCk9PigodCxlKT0+e2NvbnN0IG49KDAsci5nZXRHbHNsKSh0LnNlc3Npb24uYmFja2VuZC5nbENvbnRleHQudmVyc2lvbiksdT1lLmRpbXMsYz11Lmxlbmd0aCxsPWUuZGltcy5sZW5ndGgscD0oMCxvLmdldENvb3Jkc0RhdGFUeXBlKShsKSxmPSgwLGEuZ2V0Q2hhbm5lbHMpKFwicmNcIixsKSxkPShoPWwsZz1mLGI9dVt1Lmxlbmd0aC0yXSxtPXVbdS5sZW5ndGgtMV0sMD09PWh8fDE9PT1oP1wiXCI6YFxcbiAgICBpbnQgciA9ICR7Z1toLTJdfTtcXG4gICAgaW50IGMgPSAke2dbaC0xXX07XFxuICAgIGludCBycDEgPSAke2dbaC0yXX0gKyAxO1xcbiAgICBpbnQgY3AxID0gJHtnW2gtMV19ICsgMTtcXG4gICAgYm9vbCByRWRnZSA9IHJwMSA+PSAke219O1xcbiAgICBib29sIGNFZGdlID0gY3AxID49ICR7Yn07XFxuICAgIGApO3ZhciBoLGcsYixtO2xldCB5O3k9MD09PWM/WzEsMV06MT09PWM/W3VbMF0sMV06W3VbbC0xXSx1W2wtMl1dO2NvbnN0IF89ZnVuY3Rpb24odCxlLG4pe2lmKDA9PT10KXJldHVyblwiZmFsc2VcIjtpZigxPT09dClyZXR1cm5gcmMgPiAke2VbMF19YDtsZXQgcj1cIlwiO2ZvcihsZXQgaT10LTI7aTx0O2krKylyKz1gJHtuW2ldfSA+PSAke2VbaS10KzJdfWAsaTx0LTEmJihyKz1cInx8XCIpO3JldHVybiByfShsLHksZiksdj1mdW5jdGlvbih0LGUpe2NvbnN0IG49dC5sZW5ndGg7aWYoMD09PW4pcmV0dXJuXCJnZXRBKCksIDAsIDAsIDBcIjtpZigxPT09bilyZXR1cm5gZ2V0QShyYyksXFxuICAgICAgICAgICAgcmMgKyAxID49ICR7dFswXX0gPyAwLiA6IGdldEEocmMgKyAxKSxcXG4gICAgICAgICAgICAwLCAwYDtsZXQgcj1cIlwiO2lmKG4+Milmb3IobGV0IHQ9MDt0PG4tMjsrK3Qpcis9YCR7ZVt0XX0sYDtyZXR1cm5gZ2V0QSgke3J9ciwgYyksXFxuICAgICAgICAgIHJFZGdlID8gMC4gOiBnZXRBKCR7cn1ycDEsIGMpLFxcbiAgICAgICAgICBjRWRnZSA/IDAuIDogZ2V0QSgke3J9ciwgY3AxKSxcXG4gICAgICAgICAgckVkZ2UgfHwgY0VkZ2UgPyAwLiA6IGdldEEoJHtyfXJwMSwgY3AxKWB9KHUsZiksdz1gXFxuICAgICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICAgICR7cH0gcmMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG5cXG4gICAgICAgICAgaWYoJHtffSkge1xcbiAgICAgICAgICAgICR7bi5vdXRwdXR9ID0gdmVjNCgwKTtcXG4gICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAke2R9XFxuXFxuICAgICAgICAgICAgJHtuLm91dHB1dH0gPSB2ZWM0KCR7dn0pO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgYDtyZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LHMpLHtoYXNNYWluOiEwLG91dHB1dDp7ZGltczplLmRpbXMsdHlwZTplLnR5cGUsdGV4dHVyZVR5cGU6aS5UZXh0dXJlVHlwZS5wYWNrZWR9LHNoYWRlclNvdXJjZTp3fSl9KSh0LGUpfSl9LDI4Mjc6KHQsZSxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUudW5wYWNrRnJvbUNoYW5uZWw9ZS5nZXRDaGFubmVscz1lLmdldFZlY0NoYW5uZWxzPXZvaWQgMDtjb25zdCByPW4oOTM5MCk7ZnVuY3Rpb24gaSh0LGUpe3JldHVybigwLHIuZ2V0R2xDaGFubmVscykoZSkubWFwKChlPT5gJHt0fS4ke2V9YCkpfWUuZ2V0VmVjQ2hhbm5lbHM9aSxlLmdldENoYW5uZWxzPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIDE9PT1lP1t0XTppKHQsZSl9LGUudW5wYWNrRnJvbUNoYW5uZWw9ZnVuY3Rpb24oKXtyZXR1cm5cIlxcbiAgICBmbG9hdCBnZXRDaGFubmVsKHZlYzQgZnJhZywgaW50IGRpbSkge1xcbiAgICAgIGludCBtb2RDb29yZCA9IGltb2QoZGltLCAyKTtcXG4gICAgICByZXR1cm4gbW9kQ29vcmQgPT0gMCA/IGZyYWcuciA6IGZyYWcuZztcXG4gICAgfVxcblxcbiAgICBmbG9hdCBnZXRDaGFubmVsKHZlYzQgZnJhZywgdmVjMiBpbm5lckRpbXMpIHtcXG4gICAgICB2ZWMyIG1vZENvb3JkID0gbW9kKGlubmVyRGltcywgMi4pO1xcbiAgICAgIHJldHVybiBtb2RDb29yZC54ID09IDAuID9cXG4gICAgICAgIChtb2RDb29yZC55ID09IDAuID8gZnJhZy5yIDogZnJhZy5nKSA6XFxuICAgICAgICAobW9kQ29vcmQueSA9PSAwLiA/IGZyYWcuYiA6IGZyYWcuYSk7XFxuICAgIH1cXG4gIFwifX0sMjg3MDoodCxlLG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5wYXJzZVBhZEF0dHJpYnV0ZXNWMTE9ZS5wYWRWMTE9ZS5wYXJzZVBhZEF0dHJpYnV0ZXNWMj1lLnBhZFYyPXZvaWQgMDtjb25zdCByPW4oMjQ2KSxpPW4oMjUxNyksbz1uKDUwNjApLGE9bigyMDM5KSxzPXtuYW1lOlwiUGFkXCIsaW5wdXROYW1lczpbXCJBXCJdLGlucHV0VHlwZXM6W2EuVGV4dHVyZVR5cGUudW5wYWNrZWRdfTtlLnBhZFYyPSh0LGUsbik9PihsKGUpLFt0LnJ1bihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30scykse2NhY2hlSGludDpuLmNhY2hlS2V5LGdldDooKT0+Yyh0LGVbMF0sbil9KSxlKV0pLGUucGFyc2VQYWRBdHRyaWJ1dGVzVjI9dD0+e2NvbnN0IGU9dC5hdHRyaWJ1dGVzLmdldFN0cmluZyhcIm1vZGVcIixcImNvbnN0YW50XCIpLG49dC5hdHRyaWJ1dGVzLmdldEZsb2F0KFwidmFsdWVcIiwwKSxpPXQuYXR0cmlidXRlcy5nZXRJbnRzKFwicGFkc1wiKTtyZXR1cm4oMCxyLmNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSkoe21vZGU6ZSx2YWx1ZTpuLHBhZHM6aX0pfSxlLnBhZFYxMT0odCxuLHIpPT57cChuKTtjb25zdCBpPXUodCxuLHIpO3JldHVybigwLGUucGFkVjIpKHQsW25bMF1dLGkpfSxlLnBhcnNlUGFkQXR0cmlidXRlc1YxMT10PT50LmF0dHJpYnV0ZXMuZ2V0U3RyaW5nKFwibW9kZVwiLFwiY29uc3RhbnRcIik7Y29uc3QgdT0odCxlLG4pPT57aWYoIXQuc2Vzc2lvbi5pc0luaXRpYWxpemVyKGVbMV0uZGF0YUlkKXx8ZS5sZW5ndGg+PTMmJiF0LnNlc3Npb24uaXNJbml0aWFsaXplcihlWzJdLmRhdGFJZCkpdGhyb3cgbmV3IEVycm9yKFwiZHluYW1pYyBwYWQgYXR0cmlidXRlcyBhcmUgbm90IGFsbG93ZWRcIik7Y29uc3QgaT1BcnJheS5mcm9tKGVbMV0uaW50ZWdlckRhdGEpLG89ZS5sZW5ndGg+PTM/ZVsyXS5mbG9hdERhdGFbMF06MDtyZXR1cm4oMCxyLmNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSkoe21vZGU6bixwYWRzOmksdmFsdWU6b30pfSxjPSh0LGUsbik9Pntjb25zdCByPWkuU2hhcGVVdGlsLnBhZFNoYXBlKGUuZGltcy5zbGljZSgpLG4ucGFkcyksbz1yLmxlbmd0aCxzPWBcXG4gICAgICAke2YodCxlLG4pfVxcbiAgICAgIGZsb2F0IHByb2Nlc3MoaW50WyR7b31dIGluZGljZXMpIHtcXG4gICAgICAgICAgcmV0dXJuIHBhZEEoaW5kaWNlcyk7XFxuICAgICAgfWA7cmV0dXJue25hbWU6XCJQYWRcIixpbnB1dE5hbWVzOltcIkFcIl0saW5wdXRUeXBlczpbYS5UZXh0dXJlVHlwZS51bnBhY2tlZF0sb3V0cHV0OntkaW1zOnIsdHlwZTplLnR5cGUsdGV4dHVyZVR5cGU6YS5UZXh0dXJlVHlwZS51bnBhY2tlZH0sc2hhZGVyU291cmNlOnN9fSxsPXQ9PntpZighdHx8MSE9PXQubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIlBhZCByZXF1aXJlcyAxIGlucHV0XCIpO2lmKFwiZmxvYXQzMlwiIT09dFswXS50eXBlJiZcImZsb2F0NjRcIiE9PXRbMF0udHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGlucHV0IHR5cGUuXCIpfSxwPXQ9PntpZighdHx8MiE9PXQubGVuZ3RoJiYzIT09dC5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiUGFkIHJlcXVpcmVzIDIgb3IgMyBpbnB1dHNcIik7aWYoXCJpbnQzMlwiIT09dFsxXS50eXBlKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW5wdXQgdHlwZS5cIik7aWYodC5sZW5ndGg+PTMmJlwic3RyaW5nXCI9PT10WzJdLnR5cGUpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpbnB1dCB0eXBlLlwiKX0sZj0odCxlLG4pPT57Y29uc3Qgcj0oMCxvLmdldEdsc2wpKHQuc2Vzc2lvbi5iYWNrZW5kLmdsQ29udGV4dC52ZXJzaW9uKSxbcyx1XT10LmNhbGN1bGF0ZVRleHR1cmVXaWR0aEFuZEhlaWdodChlLmRpbXMsYS5UZXh0dXJlVHlwZS51bnBhY2tlZCksYz1pLlNoYXBlVXRpbC5jb21wdXRlU3RyaWRlcyhlLmRpbXMpO3N3aXRjaChuLm1vZGUpe2Nhc2VcImNvbnN0YW50XCI6cmV0dXJuIGQocixlLmRpbXMsYyxzLHUsbi5wYWRzLG4udmFsdWUpO2Nhc2VcInJlZmxlY3RcIjpyZXR1cm4gaChyLGUuZGltcyxjLHMsdSxuLnBhZHMpO2Nhc2VcImVkZ2VcIjpyZXR1cm4gZyhyLGUuZGltcyxjLHMsdSxuLnBhZHMpO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBtb2RlXCIpfX0sZD0odCxlLG4scixpLG8sYSk9Pntjb25zdCBzPWUubGVuZ3RoO2xldCB1PVwiXCI7Zm9yKGxldCB0PXMtMTt0Pj0wOy0tdCl1Kz1gXFxuICAgICAgICBrID0gbVske3R9XSAtICR7b1t0XX07XFxuICAgICAgICBpZiAoayA8IDApICByZXR1cm4gY29uc3RhbnQ7XFxuICAgICAgICBpZiAoayA+PSAke2VbdF19KSByZXR1cm4gY29uc3RhbnQ7XFxuICAgICAgICBvZmZzZXQgKz0gayAqICR7blt0XX07XFxuICAgICAgICBgO3JldHVybmBcXG4gICAgICBmbG9hdCBwYWRBKGludCBtWyR7c31dKSB7XFxuICAgICAgICBjb25zdCBmbG9hdCBjb25zdGFudCA9IGZsb2F0KCR7YX0pO1xcbiAgICAgICAgaW50IG9mZnNldCA9IDA7XFxuICAgICAgICBpbnQgayA9IDA7XFxuICAgICAgICAke3V9XFxuICAgICAgICB2ZWMyIGNvb3JkcyA9IG9mZnNldFRvQ29vcmRzKG9mZnNldCwgJHtyfSwgJHtpfSk7XFxuICAgICAgICBmbG9hdCB2YWx1ZSA9IGdldENvbG9yQXNGbG9hdCgke3QudGV4dHVyZTJEfShBLCBjb29yZHMpKTtcXG4gICAgICAgIHJldHVybiB2YWx1ZTtcXG4gICAgICB9XFxuICAgICAgYH0saD0odCxlLG4scixpLG8pPT57Y29uc3QgYT1lLmxlbmd0aDtsZXQgcz1cIlwiO2ZvcihsZXQgdD1hLTE7dD49MDstLXQpcys9YFxcbiAgICAgICAgayA9IG1bJHt0fV0gLSAke29bdF19O1xcbiAgICAgICAgaWYgKGsgPCAwKSB7IGsgPSAtazsgfVxcbiAgICAgICAge1xcbiAgICAgICAgICBjb25zdCBpbnQgXzJuXzEgPSAkezIqKGVbdF0tMSl9O1xcbiAgICAgICAgICBrID0gaW50KCBtb2QoIGZsb2F0KGspLCBmbG9hdChfMm5fMSkgKSApIDtcXG4gICAgICAgICAgaWYoayA+PSAke2VbdF19KSB7IGsgPSBfMm5fMSAtIGs7IH1cXG4gICAgICAgIH1cXG4gICAgICAgIG9mZnNldCArPSBrICogJHtuW3RdfTtcXG4gICAgICAgIGA7cmV0dXJuYFxcbiAgICAgIGZsb2F0IHBhZEEoaW50IG1bJHthfV0pIHtcXG4gICAgICAgIGludCBvZmZzZXQgPSAwO1xcbiAgICAgICAgaW50IGsgPSAwO1xcbiAgICAgICAgJHtzfVxcbiAgICAgICAgdmVjMiBjb29yZHMgPSBvZmZzZXRUb0Nvb3JkcyhvZmZzZXQsICR7cn0sICR7aX0pO1xcbiAgICAgICAgZmxvYXQgdmFsdWUgPSBnZXRDb2xvckFzRmxvYXQoJHt0LnRleHR1cmUyRH0oQSwgY29vcmRzKSk7XFxuICAgICAgICByZXR1cm4gdmFsdWU7XFxuICAgICAgfVxcbiAgICAgIGB9LGc9KHQsZSxuLHIsaSxvKT0+e2NvbnN0IGE9ZS5sZW5ndGg7bGV0IHM9XCJcIjtmb3IobGV0IHQ9YS0xO3Q+PTA7LS10KXMrPWBcXG4gICAgICAgIGsgPSBtWyR7dH1dIC0gJHtvW3RdfTtcXG4gICAgICAgIGlmIChrIDwgMCkgIGsgPSAwO1xcbiAgICAgICAgaWYgKGsgPj0gJHtlW3RdfSkgayA9ICR7ZVt0XS0xfTtcXG4gICAgICAgIG9mZnNldCArPSBrICogJHtuW3RdfTtcXG4gICAgICBgO3JldHVybmBcXG4gICAgICBmbG9hdCBwYWRBKGludCBtWyR7YX1dKSB7XFxuICAgICAgICBpbnQgb2Zmc2V0ID0gMDtcXG4gICAgICAgIGludCBrID0gMDtcXG4gICAgICAgICR7c31cXG4gICAgICAgIHZlYzIgY29vcmRzID0gb2Zmc2V0VG9Db29yZHMob2Zmc2V0LCAke3J9LCAke2l9KTtcXG4gICAgICAgIGZsb2F0IHZhbHVlID0gZ2V0Q29sb3JBc0Zsb2F0KCR7dC50ZXh0dXJlMkR9KEEsIGNvb3JkcykpO1xcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xcbiAgICAgIH1cXG4gICAgICBgfX0sMjE0MzoodCxlLG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5nbG9iYWxNYXhQb29sPWUucGFyc2VNYXhQb29sQXR0cmlidXRlcz1lLm1heFBvb2w9ZS5wYXJzZUdsb2JhbEF2ZXJhZ2VQb29sQXR0cmlidXRlcz1lLmdsb2JhbEF2ZXJhZ2VQb29sPWUucGFyc2VBdmVyYWdlUG9vbEF0dHJpYnV0ZXM9ZS5hdmVyYWdlUG9vbD12b2lkIDA7Y29uc3Qgcj1uKDI0NiksaT1uKDI1MTcpLG89bigyMDM5KTtlLmF2ZXJhZ2VQb29sPSh0LGUsbik9PntwKGUpO2NvbnN0IHI9e25hbWU6XCJBdmVyYWdlUG9vbFwiLGlucHV0TmFtZXM6W1wiWFwiXSxpbnB1dFR5cGVzOltvLlRleHR1cmVUeXBlLnVucGFja2VkXSxjYWNoZUhpbnQ6bi5jYWNoZUtleX07cmV0dXJuW3QucnVuKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxyKSx7Z2V0OigpPT5hKGUsciwhMSxuKX0pLGUpXX0sZS5wYXJzZUF2ZXJhZ2VQb29sQXR0cmlidXRlcz10PT57Y29uc3QgZT10LmF0dHJpYnV0ZXMuZ2V0U3RyaW5nKFwiYXV0b19wYWRcIixcIk5PVFNFVFwiKSxuPXQuYXR0cmlidXRlcy5nZXRJbnQoXCJjZWlsX21vZGVcIiwwKSxpPTAhPT10LmF0dHJpYnV0ZXMuZ2V0SW50KFwiY291bnRfaW5jbHVkZV9wYWRcIiwwKSxvPXQuYXR0cmlidXRlcy5nZXRJbnRzKFwia2VybmVsX3NoYXBlXCIpLGE9dC5hdHRyaWJ1dGVzLmdldEludHMoXCJzdHJpZGVzXCIsW10pLHM9dC5hdHRyaWJ1dGVzLmdldEludHMoXCJwYWRzXCIsW10pO2lmKDAhPT1uKXRocm93IG5ldyBFcnJvcihcInVzaW5nIGNlaWwoKSBpbiBzaGFwZSBjb21wdXRhdGlvbiBpcyBub3QgeWV0IHN1cHBvcnRlZCBmb3IgQXZlcmFnZVBvb2xcIik7cmV0dXJuKDAsci5jcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkpKHthdXRvUGFkOmUsY2VpbE1vZGU6bixjb3VudEluY2x1ZGVQYWQ6aSxrZXJuZWxTaGFwZTpvLHN0cmlkZXM6YSxwYWRzOnN9KX07Y29uc3QgYT0odCxlLG4scik9Pntjb25zdFthLHNdPXUodCxyLG4pLGM9aS5TaGFwZVV0aWwuc2l6ZShhLmtlcm5lbFNoYXBlKTtsZXQgbD1cIlwiO2EuY291bnRJbmNsdWRlUGFkP2wrPWB2YWx1ZSAvPSBmbG9hdCgke2N9KTtgOmwrPWB2YWx1ZSAvPSBmbG9hdCgke2N9IC0gcGFkKTtgO2NvbnN0IHA9YFxcbiAgICAgICAgJHtmKHRbMF0uZGltcyxhLFwidmFsdWUgKz0gX1goeCk7XCIsbCxcIjAuMFwiKX1cXG4gICAgICBgO3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sZSkse291dHB1dDp7ZGltczpzLHR5cGU6dFswXS50eXBlLHRleHR1cmVUeXBlOm8uVGV4dHVyZVR5cGUudW5wYWNrZWR9LHNoYWRlclNvdXJjZTpwfSl9O2UuZ2xvYmFsQXZlcmFnZVBvb2w9KHQsZSxuKT0+e3AoZSk7Y29uc3Qgcj17bmFtZTpcIkdsb2JhbEF2ZXJhZ2VQb29sXCIsaW5wdXROYW1lczpbXCJYXCJdLGlucHV0VHlwZXM6W28uVGV4dHVyZVR5cGUudW5wYWNrZWRdLGNhY2hlSGludDpgJHtuLmNvdW50SW5jbHVkZVBhZH1gfTtyZXR1cm5bdC5ydW4oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LHIpLHtnZXQ6KCk9PmEoZSxyLCEwLG4pfSksZSldfSxlLnBhcnNlR2xvYmFsQXZlcmFnZVBvb2xBdHRyaWJ1dGVzPXQ9Pntjb25zdCBlPTAhPT10LmF0dHJpYnV0ZXMuZ2V0SW50KFwiY291bnRfaW5jbHVkZV9wYWRcIiwwKTtyZXR1cm4oMCxyLmNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSkoe2F1dG9QYWQ6XCJcIixjZWlsTW9kZTowLGNvdW50SW5jbHVkZVBhZDplLGtlcm5lbFNoYXBlOltdLHN0cmlkZXM6W10scGFkczpbXX0pfSxlLm1heFBvb2w9KHQsZSxuKT0+e3AoZSk7Y29uc3Qgcj17bmFtZTpcIk1heFBvb2xcIixpbnB1dE5hbWVzOltcIlhcIl0saW5wdXRUeXBlczpbby5UZXh0dXJlVHlwZS51bnBhY2tlZF0sY2FjaGVIaW50Om4uY2FjaGVLZXl9O3JldHVyblt0LnJ1bihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30scikse2dldDooKT0+cyhlLHIsITEsbil9KSxlKV19LGUucGFyc2VNYXhQb29sQXR0cmlidXRlcz10PT57Y29uc3QgZT10LmF0dHJpYnV0ZXMuZ2V0U3RyaW5nKFwiYXV0b19wYWRcIixcIk5PVFNFVFwiKSxuPXQuYXR0cmlidXRlcy5nZXRJbnQoXCJjZWlsX21vZGVcIiwwKSxpPXQuYXR0cmlidXRlcy5nZXRJbnRzKFwia2VybmVsX3NoYXBlXCIpLG89dC5hdHRyaWJ1dGVzLmdldEludHMoXCJzdHJpZGVzXCIsW10pLGE9dC5hdHRyaWJ1dGVzLmdldEludHMoXCJwYWRzXCIsW10pLHM9dC5hdHRyaWJ1dGVzLmdldEludChcInN0b3JhZ2Vfb3JkZXJcIiwwKSx1PXQuYXR0cmlidXRlcy5nZXRJbnRzKFwiZGlsYXRpb25zXCIsW10pO2lmKDAhPT1zKXRocm93IG5ldyBFcnJvcihcImNvbHVtbiBtYWpvciBzdG9yYWdlIG9yZGVyIGlzIG5vdCB5ZXQgc3VwcG9ydGVkIGZvciBNYXhQb29sXCIpO2lmKDAhPT1uKXRocm93IG5ldyBFcnJvcihcInVzaW5nIGNlaWwoKSBpbiBzaGFwZSBjb21wdXRhdGlvbiBpcyBub3QgeWV0IHN1cHBvcnRlZCBmb3IgTWF4UG9vbFwiKTtyZXR1cm4oMCxyLmNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSkoe2F1dG9QYWQ6ZSxjZWlsTW9kZTpuLGNvdW50SW5jbHVkZVBhZDohMSxrZXJuZWxTaGFwZTppLHN0cmlkZXM6byxwYWRzOmEsc3RvcmFnZU9yZGVyOnMsZGlsYXRpb25zOnV9KX07Y29uc3Qgcz0odCxlLG4scik9Pntjb25zdFtpLGFdPXUodCxyLG4pLHM9YFxcbiAgICAgICR7Zih0WzBdLmRpbXMsaSxcIlxcbiAgICAgIHZhbHVlID0gbWF4KF9YKHgpLCB2YWx1ZSk7XFxuICAgIFwiLFwiXCIsXCItMWU1XCIpfVxcbiAgICBgO3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sZSkse291dHB1dDp7ZGltczphLHR5cGU6dFswXS50eXBlLHRleHR1cmVUeXBlOm8uVGV4dHVyZVR5cGUudW5wYWNrZWR9LHNoYWRlclNvdXJjZTpzfSl9LHU9KHQsZSxuKT0+e2NvbnN0IHI9dFswXS5kaW1zLnNsaWNlKCksbz1PYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChlLFwiZGlsYXRpb25zXCIpLGE9ZS5rZXJuZWxTaGFwZS5zbGljZSgpLHM9ZS5zdHJpZGVzLnNsaWNlKCksdT1vP2UuZGlsYXRpb25zLnNsaWNlKCk6W10sYz1lLnBhZHMuc2xpY2UoKTtpLlBvb2xDb252VXRpbC5hZGp1c3RQb29sQXR0cmlidXRlcyhuLHIsYSxzLHUsYyk7Y29uc3QgbD1pLlBvb2xDb252VXRpbC5jb21wdXRlUG9vbE91dHB1dFNoYXBlKG4scixzLHUsYSxjLGUuYXV0b1BhZCkscD1PYmplY3QuYXNzaWduKHt9LGUpO3JldHVybiBvP09iamVjdC5hc3NpZ24ocCx7a2VybmVsU2hhcGU6YSxzdHJpZGVzOnMscGFkczpjLGRpbGF0aW9uczp1LGNhY2hlS2V5OmUuY2FjaGVLZXl9KTpPYmplY3QuYXNzaWduKHAse2tlcm5lbFNoYXBlOmEsc3RyaWRlczpzLHBhZHM6YyxjYWNoZUtleTplLmNhY2hlS2V5fSksW3AsbF19LGM9e2F1dG9QYWQ6XCJcIixjZWlsTW9kZTowLGNvdW50SW5jbHVkZVBhZDohMSxrZXJuZWxTaGFwZTpbXSxzdHJpZGVzOltdLHBhZHM6W10sc3RvcmFnZU9yZGVyOjAsZGlsYXRpb25zOltdLGNhY2hlS2V5OlwiXCJ9LGw9e25hbWU6XCJHbG9iYWxNYXhQb29sXCIsaW5wdXROYW1lczpbXCJYXCJdLGlucHV0VHlwZXM6W28uVGV4dHVyZVR5cGUudW5wYWNrZWRdfTtlLmdsb2JhbE1heFBvb2w9KHQsZSk9PihwKGUpLFt0LnJ1bihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sbCkse2dldDooKT0+cyhlLGwsITAsYyl9KSxlKV0pO2NvbnN0IHA9dD0+e2lmKCF0fHwxIT09dC5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiUG9vbCBvcHMgcmVxdWlyZXMgMSBpbnB1dC5cIik7aWYoXCJmbG9hdDMyXCIhPT10WzBdLnR5cGUmJlwiZmxvYXQ2NFwiIT09dFswXS50eXBlKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW5wdXQgdHlwZS5cIil9LGY9KHQsZSxuLHIsbyk9Pntjb25zdCBhPXQubGVuZ3RoO2lmKGUua2VybmVsU2hhcGUubGVuZ3RoPD0yKXtjb25zdCBpPWUua2VybmVsU2hhcGVbZS5rZXJuZWxTaGFwZS5sZW5ndGgtMV0scz1lLnN0cmlkZXNbZS5zdHJpZGVzLmxlbmd0aC0xXSx1PWUucGFkc1tlLnBhZHMubGVuZ3RoLzItMV0sYz1lLnBhZHNbZS5wYWRzLmxlbmd0aC0xXSxsPXRbYS0xXTtsZXQgcD1cIlwiLGY9XCJcIixkPVwiXCI7aWYocD11K2MhPT0wP2BcXG4gICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCAke2l9OyBpKyspIHtcXG4gICAgICAgICAgICB4WyR7YX0gLSAxXSA9IGluZGljZXNbJHthfSAtIDFdICogJHtzfSAtICR7dX0gKyBpO1xcbiAgICAgICAgICAgIGlmICh4WyR7YX0gLSAxXSA8IDAgfHwgeFske2F9IC0gMV0gPj0gJHtsfSkge1xcbiAgICAgICAgICAgICAgcGFkKys7XFxuICAgICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgJHtufVxcbiAgICAgICAgICB9YDpgXFxuICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgJHtpfTsgaSsrKSB7XFxuICAgICAgICAgICAgeFske2F9IC0gMV0gPSBpbmRpY2VzWyR7YX0gLSAxXSAqICR7c30gLSAke3V9ICsgaTtcXG4gICAgICAgICAgICAke259XFxuICAgICAgICAgIH1gLDI9PT1lLmtlcm5lbFNoYXBlLmxlbmd0aCl7Y29uc3Qgbj1lLmtlcm5lbFNoYXBlW2Uua2VybmVsU2hhcGUubGVuZ3RoLTJdLHI9ZS5zdHJpZGVzW2Uuc3RyaWRlcy5sZW5ndGgtMl0sbz1lLnBhZHNbZS5wYWRzLmxlbmd0aC8yLTJdLHM9ZS5wYWRzW2UucGFkcy5sZW5ndGgtMl0sdT10W2EtMl07Zj1vK3MhPT0wP2BcXG4gICAgICAgICAgICBmb3IgKGludCBqID0gMDsgaiA8ICR7bn07IGorKykge1xcbiAgICAgICAgICAgICAgeFske2F9IC0gMl0gPSBpbmRpY2VzWyR7YX0gLSAyXSAqICR7cn0gLSAke299ICsgajtcXG4gICAgICAgICAgICAgIGlmICh4WyR7YX0gLSAyXSA8IDAgfHwgeFske2F9IC0gMl0gPj0gJHt1fSkge1xcbiAgICAgICAgICAgICAgICBwYWQrPSAke2l9O1xcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgYDpgXFxuICAgICAgICAgICAgZm9yIChpbnQgaiA9IDA7IGogPCAke259OyBqKyspIHtcXG4gICAgICAgICAgICAgIHhbJHthfSAtIDJdID0gaW5kaWNlc1ske2F9IC0gMl0gKiAke3J9IC0gJHtvfSArIGo7XFxuICAgICAgICAgICAgYCxkPVwiXFxuICAgICAgICAgIH1cXG4gICAgICAgIFwifXJldHVybmBcXG4gICAgICAgIGZsb2F0IHByb2Nlc3MoaW50IGluZGljZXNbJHthfV0pIHtcXG4gICAgICAgICAgaW50IHhbJHthfV07XFxuICAgICAgICAgIGNvcHlWZWMoaW5kaWNlcywgeCk7XFxuXFxuICAgICAgICAgIGZsb2F0IHZhbHVlID0gJHtvfTtcXG4gICAgICAgICAgaW50IHBhZCA9IDA7XFxuICAgICAgICAgICR7Zn1cXG4gICAgICAgICAgJHtwfVxcbiAgICAgICAgICAke2R9XFxuICAgICAgICAgICR7cn1cXG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xcbiAgICAgICAgfVxcbiAgICAgIGB9e2NvbnN0IHM9aS5TaGFwZVV0aWwuc2l6ZShlLmtlcm5lbFNoYXBlKSx1PWkuU2hhcGVVdGlsLmNvbXB1dGVTdHJpZGVzKGUua2VybmVsU2hhcGUpLGM9dS5sZW5ndGgsbD1lLnBhZHMubGVuZ3RoLHA9aChjKSxmPWQodCxcImlucHV0RGltc1wiKSxnPWQoZS5wYWRzLFwicGFkc1wiKSxiPWQodSxcImtlcm5lbFN0cmlkZXNcIiksbT1kKGUuc3RyaWRlcyxcInN0cmlkZXNcIik7bGV0IHk9XCJcIjtyZXR1cm4geT1lLnBhZHMucmVkdWNlKCgodCxlKT0+dCtlKSk/YFxcbiAgICAgICAgICAgIGlmICh4W2pdID49IGlucHV0RGltc1tqXSB8fCB4W2pdIDwgMCkge1xcbiAgICAgICAgICAgICAgcGFkKys7XFxuICAgICAgICAgICAgICBpc1BhZCA9IHRydWU7XFxuICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgaWYgKCFpc1BhZCkge1xcbiAgICAgICAgICAgICR7bn1cXG4gICAgICAgICAgfWA6YFxcbiAgICAgICAgICB9XFxuICAgICAgICAgICR7bn1cXG4gICAgICAgIGAsYFxcbiAgICAgICAgJHtwfVxcbiAgICAgICAgZmxvYXQgcHJvY2VzcyhpbnQgaW5kaWNlc1ske2F9XSkge1xcbiAgICAgICAgICBpbnQgeFske2F9XTtcXG4gICAgICAgICAgY29weVZlYyhpbmRpY2VzLCB4KTtcXG4gICAgICAgICAgaW50IG9mZnNldFske2N9XTtcXG4gICAgICAgICAgaW50IHBhZHNbJHtsfV07XFxuICAgICAgICAgIGludCBpbnB1dERpbXNbJHthfV07XFxuICAgICAgICAgIGludCBrZXJuZWxTdHJpZGVzWyR7Y31dO1xcbiAgICAgICAgICBpbnQgc3RyaWRlc1ske2N9XTtcXG4gICAgICAgICAgJHtnfVxcbiAgICAgICAgICAke2Z9XFxuICAgICAgICAgICR7bX1cXG4gICAgICAgICAgJHtifVxcblxcbiAgICAgICAgICBmbG9hdCB2YWx1ZSA9ICR7b307XFxuICAgICAgICAgIGludCBwYWQgPSAwO1xcbiAgICAgICAgICBib29sIGlzUGFkID0gZmFsc2U7XFxuICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgJHtzfTsgaSsrKSB7XFxuICAgICAgICAgICAgb2Zmc2V0VG9JbmRpY2VzKGksIGtlcm5lbFN0cmlkZXMsIG9mZnNldCk7XFxuICAgICAgICAgICAgaXNQYWQgPSBmYWxzZTtcXG4gICAgICAgICAgICBmb3IgKGludCBqID0gJHthfSAtICR7Y307IGogPCAke2F9OyBqKyspIHtcXG4gICAgICAgICAgICAgIHhbal0gPSBpbmRpY2VzW2pdICogc3RyaWRlc1tqIC0gJHthfSArICR7Y31dXFxuICAgICAgICAgICAgICAgICsgb2Zmc2V0W2ogLSAke2F9ICsgJHtjfV0gLSBwYWRzW2ogLSAyXTtcXG4gICAgICAgICAgICAgICR7eX1cXG4gICAgICAgICAgfVxcbiAgICAgICAgICAke3J9XFxuXFxuICAgICAgICAgIHJldHVybiB2YWx1ZTtcXG4gICAgICAgIH1cXG4gICAgICBgfX0sZD0odCxlKT0+e2xldCBuPVwiXCI7Zm9yKGxldCByPTA7cjx0Lmxlbmd0aDtyKyspbis9YFxcbiAgICAgICR7ZX1bJHtyfV0gPSAke3Rbcl19O1xcbiAgICBgO3JldHVybiBufSxoPXQ9PmBcXG4gIHZvaWQgb2Zmc2V0VG9JbmRpY2VzKGludCBvZmZzZXQsIGludFske3R9XSBzdHJpZGVzLCBvdXQgaW50WyR7dH1dIGluZGljZXMpIHtcXG4gICAgaWYgKCR7dH0gPT0gMCkge1xcbiAgICAgIHJldHVybjtcXG4gICAgfVxcbiAgICBmb3IgKGludCBpID0gMDsgaSA8ICR7dH0gLSAxOyArK2kpIHtcXG4gICAgICBpbmRpY2VzW2ldID0gb2Zmc2V0IC8gc3RyaWRlc1tpXTtcXG4gICAgICBvZmZzZXQgLT0gaW5kaWNlc1tpXSAqIHN0cmlkZXNbaV07XFxuICAgIH1cXG4gICAgaW5kaWNlc1ske3R9IC0gMV0gPSBvZmZzZXQ7XFxuICB9YH0sNDkzOToodCxlLG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5yZWR1Y2VMb2dTdW1TcXVhcmU9ZS5yZWR1Y2VMb2dTdW09ZS5yZWR1Y2VQcm9kPWUucmVkdWNlTWluPWUucmVkdWNlTWF4PWUucmVkdWNlTWVhbj1lLnJlZHVjZVN1bT1lLnBhcnNlUmVkdWNlQXR0cmlidXRlcz12b2lkIDA7Y29uc3Qgcj1uKDI0NiksaT1uKDc4Miksbz1uKDI1MTcpLGE9bigyMDM5KSxzPSh0LGUsbixyLGkpPT57YyhlKTtjb25zdCBvPXtuYW1lOnIsaW5wdXROYW1lczpbXCJBXCJdLGlucHV0VHlwZXM6W2EuVGV4dHVyZVR5cGUudW5wYWNrZWRdfTtyZXR1cm5bdC5ydW4oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LG8pLHtjYWNoZUhpbnQ6bi5jYWNoZUtleSxnZXQ6KCk9PnUodCxlLG4scixpLG8pfSksZSldfTtlLnBhcnNlUmVkdWNlQXR0cmlidXRlcz10PT57Y29uc3QgZT10LmF0dHJpYnV0ZXMuZ2V0SW50cyhcImF4ZXNcIixbXSksbj0xPT09dC5hdHRyaWJ1dGVzLmdldEludChcImtlZXBkaW1zXCIsMSk7cmV0dXJuKDAsci5jcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkpKHtheGVzOmUsa2VlcERpbXM6bn0pfTtjb25zdCB1PSh0LGUsbixyLGkscyk9Pntjb25zdCB1PVtdLGM9ZVswXS5kaW1zLmxlbmd0aHx8MSxsPVtdLHA9by5TaGFwZVV0aWwubm9ybWFsaXplQXhlcyhuLmF4ZXMsZVswXS5kaW1zLmxlbmd0aCksZj1pKGUscCk7bGV0IGQ9ZlsxXTtmb3IobGV0IHQ9MDt0PGVbMF0uZGltcy5sZW5ndGg7dCsrKXAuaW5kZXhPZih0KT49MHx8MD09PXAubGVuZ3RoPyhuLmtlZXBEaW1zJiZ1LnB1c2goMSksZD1gXFxuICAgICAgICAgIGZvcihpbnQgaiR7dH0gPSAwOyBqJHt0fSA8ICR7ZVswXS5kaW1zW3RdfTsgaiR7dH0rKykge1xcbiAgICAgICAgICAgIGlucHV0SWR4WyR7dH1dID0gaiR7dH07XFxuICAgICAgICAgICAgJHtkfVxcbiAgICAgICAgICB9YCk6KGwucHVzaChgaW5wdXRJZHhbJHt0fV0gPSBvdXRwdXRJZHhbJHt1Lmxlbmd0aH1dO2ApLHUucHVzaChlWzBdLmRpbXNbdF0pKTtjb25zdCBoPWBcXG4gICAgICBmbG9hdCBwcm9jZXNzKGludCBvdXRwdXRJZHhbJHt1Lmxlbmd0aHx8MX1dKSB7XFxuICAgICAgICBmbG9hdCB2YWx1ZTsgICAgICAgICAgICAgICAgIC8vIGZpbmFsIHJlc3VsdFxcbiAgICAgICAgaW50IGlucHV0SWR4WyR7Y31dOyAgICAgIC8vIGFkZHJlc3NpbmcgaW5wdXQgZGF0YVxcbiAgICAgICAgJHtsLmpvaW4oXCJcXG5cIil9XFxuICAgICAgICAke2ZbMF19ICAgICAgIC8vIGluaXQgb3BzIGZvciByZWR1Y2UgbWF4L21pblxcbiAgICAgICAgJHtkfVxcbiAgICAgICAgJHtmWzJdfSAgICAgICAvLyBmaW5hbCBjb21wdXRhdGlvbiBmb3IgcmVkdWNlIG1lYW5cXG4gICAgICAgIHJldHVybiB2YWx1ZTtcXG4gICAgICB9YDtyZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LHMpLHtvdXRwdXQ6e2RpbXM6dSx0eXBlOmVbMF0udHlwZSx0ZXh0dXJlVHlwZTphLlRleHR1cmVUeXBlLnVucGFja2VkfSxzaGFkZXJTb3VyY2U6aH0pfSxjPXQ9PntpZighdHx8MSE9PXQubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIlJlZHVjZSBvcCByZXF1aXJlcyAxIGlucHV0LlwiKTtpZigtMT09PWkuTlVNQkVSX1RZUEVTLmluZGV4T2YodFswXS50eXBlKSl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGlucHV0IHR5cGUuXCIpfTtlLnJlZHVjZVN1bT0odCxlLG4pPT5zKHQsZSxuLFwiUmVkdWNlU3VtXCIsKCgpPT5bXCJ2YWx1ZSA9IDAuMDtcIixcInZhbHVlICs9IF9BKGlucHV0SWR4KTtcIixcIlwiXSkpLGUucmVkdWNlTWVhbj0odCxlLG4pPT5zKHQsZSxuLFwiUmVkdWNlTWVhblwiLCgodCxlKT0+e2xldCBuPTE7Zm9yKGxldCByPTA7cjx0WzBdLmRpbXMubGVuZ3RoO3IrKykoZS5pbmRleE9mKHIpPj0wfHwwPT09ZS5sZW5ndGgpJiYobio9dFswXS5kaW1zW3JdKTtyZXR1cm5bXCJ2YWx1ZSA9IDAuMDtcIixcInZhbHVlICs9IF9BKGlucHV0SWR4KTtcIixgdmFsdWUgLz0gJHtufS47YF19KSksZS5yZWR1Y2VNYXg9KHQsZSxuKT0+cyh0LGUsbixcIlJlZHVjZU1heFwiLCgodCxlKT0+e2NvbnN0IG49W107Zm9yKGxldCByPTA7cjx0WzBdLmRpbXMubGVuZ3RoO3IrKykoZS5pbmRleE9mKHIpPj0wfHwwPT09ZS5sZW5ndGgpJiZuLnB1c2goYGlucHV0SWR4WyR7cn1dID0gMDtgKTtyZXR1cm5bYCR7bi5qb2luKFwiXFxuXCIpfVxcbnZhbHVlID0gX0EoaW5wdXRJZHgpO2AsXCJ2YWx1ZSA9IG1heCh2YWx1ZSwgX0EoaW5wdXRJZHgpKTtcIixcIlwiXX0pKSxlLnJlZHVjZU1pbj0odCxlLG4pPT5zKHQsZSxuLFwiUmVkdWNlTWluXCIsKCh0LGUpPT57Y29uc3Qgbj1bXTtmb3IobGV0IHI9MDtyPHRbMF0uZGltcy5sZW5ndGg7cisrKShlLmluZGV4T2Yocik+PTB8fDA9PT1lLmxlbmd0aCkmJm4ucHVzaChgaW5wdXRJZHhbJHtyfV0gPSAwO2ApO3JldHVybltgJHtuLmpvaW4oXCJcXG5cIil9XFxudmFsdWUgPSBfQShpbnB1dElkeCk7YCxcInZhbHVlID0gbWluKHZhbHVlLCBfQShpbnB1dElkeCkpO1wiLFwiXCJdfSkpLGUucmVkdWNlUHJvZD0odCxlLG4pPT5zKHQsZSxuLFwiUmVkdWNlUHJvZFwiLCgoKT0+W1widmFsdWUgPSAxLjA7XCIsXCJ2YWx1ZSAqPSBfQShpbnB1dElkeCk7XCIsXCJcIl0pKSxlLnJlZHVjZUxvZ1N1bT0odCxlLG4pPT5zKHQsZSxuLFwiUmVkdWNlTG9nU3VtXCIsKCgpPT5bXCJ2YWx1ZSA9IDAuMDtcIixcInZhbHVlICs9IF9BKGlucHV0SWR4KTtcIixcInZhbHVlID0gbG9nKHZhbHVlKTtcIl0pKSxlLnJlZHVjZUxvZ1N1bVNxdWFyZT0odCxlLG4pPT5zKHQsZSxuLFwiUmVkdWNlTG9nU3VtU3F1YXJlXCIsKCgpPT5bXCJmbG9hdCB0OyB2YWx1ZSA9IDAuMDtcIixcInQgPSBfQShpbnB1dElkeCk7IHZhbHVlICs9IHQgKiB0O1wiLFwiXCJdKSl9LDcwMTk6KHQsZSxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUuaXNSZXNoYXBlQ2hlYXA9ZS5wcm9jZXNzRGltczNEPWUuY3JlYXRlUGFja2VkUmVzaGFwZTNEUHJvZ3JhbUluZm9Mb2FkZXI9dm9pZCAwO2NvbnN0IHI9bigyNTE3KSxpPW4oNTA2MCksbz1uKDIwMzkpLGE9bigyODI3KTtlLmNyZWF0ZVBhY2tlZFJlc2hhcGUzRFByb2dyYW1JbmZvTG9hZGVyPSh0LGUsbik9Pntjb25zdCBzPSh0PT4oe25hbWU6XCJSZXNoYXBlIChwYWNrZWQpXCIsaW5wdXRUeXBlczpbby5UZXh0dXJlVHlwZS5wYWNrZWRdLGlucHV0TmFtZXM6W1wiQVwiXSxjYWNoZUhpbnQ6YCR7dH1gfSkpKG4pO3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30scykse2dldDooKT0+KCh0LGUsbixzKT0+e2NvbnN0IHU9ZS5kaW1zLGM9cztsZXQgbD1cIlwiO2ZvcihsZXQgdD0wO3Q8NDt0Kyspe2xldCBlPVwiXCI7c3dpdGNoKHQpe2Nhc2UgMDplPVwib3V0cHV0Q29vcmRzID0gcmM7XCI7YnJlYWs7Y2FzZSAxOmU9XCJvdXRwdXRDb29yZHMgPSBpdmVjMyhyYy54LCByYy55KzEsIHJjLnopO1wiO2JyZWFrO2Nhc2UgMjplPVwib3V0cHV0Q29vcmRzID0gaXZlYzMocmMueCwgcmMueSwgcmMueisxKTtcIjticmVhaztjYXNlIDM6ZT1cIm91dHB1dENvb3JkcyA9IGl2ZWMzKHJjLngsIHJjLnkrMSwgcmMueisxKTtcIjticmVhaztkZWZhdWx0OnRocm93IG5ldyBFcnJvcn1sKz1gXFxuICAgICAgICAke2V9XFxuICAgICAgICAke3Q+MD9cImlmKG91dHB1dENvb3Jkcy55IDwgcm93cyAmJiBvdXRwdXRDb29yZHMueiA8IGNvbHMpe1wiOlwiXCJ9XFxuICAgICAgICAgIGludCBmbGF0dGVuZWRJbmRleCA9IGdldEZsYXR0ZW5lZEluZGV4KG91dHB1dENvb3Jkcyk7XFxuXFxuICAgICAgICAgIGl2ZWMzIGlucHV0UkMgPSBpbnB1dENvb3Jkc0Zyb21SZXNoYXBlZE91dENvb3JkcyhmbGF0dGVuZWRJbmRleCk7XFxuICAgICAgICAgIHZlYzIgaW5uZXJEaW1zID0gdmVjMihmbG9hdChpbnB1dFJDLnkpLGZsb2F0KGlucHV0UkMueikpO1xcblxcbiAgICAgICAgICByZXN1bHRbJHt0fV0gPSBnZXRDaGFubmVsKGdldEEoaW5wdXRSQy54LCBpbnB1dFJDLnksIGlucHV0UkMueiksIGlubmVyRGltcyk7XFxuXFxuICAgICAgICAke3Q+MD9cIn1cIjpcIlwifVxcbiAgICAgIGB9Y29uc3QgcD0oMCxpLmdldEdsc2wpKHQuc2Vzc2lvbi5iYWNrZW5kLmdsQ29udGV4dC52ZXJzaW9uKSxmPWBcXG4gICAgICAke2Z1bmN0aW9uKHQpe2NvbnN0IGU9ci5TaGFwZVV0aWwuY29tcHV0ZVN0cmlkZXModCksbj1bXCJiXCIsXCJyXCIsXCJjXCJdLGk9XCJpbmRleFwiLG89ZS5tYXAoKCh0LHIpPT5gaW50ICR7bltyXX0gPSAke2l9IC8gJHt0fTsgJHtyPT09ZS5sZW5ndGgtMT9gaW50ICR7bltyKzFdfSA9ICR7aX0gLSAke25bcl19ICogJHt0fWA6YGluZGV4IC09ICR7bltyXX0gKiAke3R9YH07YCkpLmpvaW4oXCJcIik7cmV0dXJuYFxcbiAgICBpdmVjMyBpbnB1dENvb3Jkc0Zyb21SZXNoYXBlZE91dENvb3JkcyhpbnQgaW5kZXgpIHtcXG4gICAgICAke299XFxuICAgICAgcmV0dXJuIGl2ZWMzKGIsIHIsIGMpO1xcbiAgICB9XFxuICBgfSh1KX1cXG4gICAgICAke2Z1bmN0aW9uKHQpe2NvbnN0IGU9ci5TaGFwZVV0aWwuY29tcHV0ZVN0cmlkZXModCk7cmV0dXJuYFxcbiAgaW50IGdldEZsYXR0ZW5lZEluZGV4KGl2ZWMzIGNvb3Jkcykge1xcbiAgICAvLyByZXZlcnNlIHksIHogb3JkZXJcXG4gICAgcmV0dXJuIGNvb3Jkcy54ICogJHtlWzBdfSArIGNvb3Jkcy56ICogJHtlWzFdfSArIGNvb3Jkcy55O1xcbiAgfVxcbmB9KGMpfVxcbiAgICAgICR7KDAsYS51bnBhY2tGcm9tQ2hhbm5lbCkoKX1cXG5cXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBpdmVjMyByYyA9IGdldE91dHB1dENvb3JkcygpO1xcblxcbiAgICAgICAgdmVjNCByZXN1bHQgPSB2ZWM0KDAuMCk7XFxuXFxuICAgICAgICBpdmVjMyBvdXRwdXRDb29yZHM7XFxuICAgICAgICBpbnQgcm93cyA9ICR7Y1syXX07XFxuICAgICAgICBpbnQgY29scyA9ICR7Y1sxXX07XFxuXFxuICAgICAgICAke2x9XFxuICAgICAgICAke3Aub3V0cHV0fSA9IHJlc3VsdDtcXG4gICAgICB9XFxuICAgIGA7cmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxuKSx7b3V0cHV0OntkaW1zOmMsdHlwZTplLnR5cGUsdGV4dHVyZVR5cGU6by5UZXh0dXJlVHlwZS5wYWNrZWR9LHNoYWRlclNvdXJjZTpmLGhhc01haW46ITB9KX0pKHQsZSxzLG4pfSl9LGUucHJvY2Vzc0RpbXMzRD1mdW5jdGlvbih0KXtpZigwPT09dC5sZW5ndGgpcmV0dXJuWzEsMSwxXTtsZXQgZT0xO2ZvcihsZXQgbj0wO248dC5sZW5ndGgtMjsrK24pZSo9dFtuXTtyZXR1cm5bZSx0Lmxlbmd0aD4xP3RbdC5sZW5ndGgtMl06MSx0W3QubGVuZ3RoLTFdXX0sZS5pc1Jlc2hhcGVDaGVhcD1mdW5jdGlvbih0LGUpe2xldCBuPSExO3JldHVybiBuPTA9PT10Lmxlbmd0aHx8MD09PWUubGVuZ3RofHwodC5sZW5ndGg8Mnx8ZS5sZW5ndGg8Mj90W3QubGVuZ3RoLTFdPT09ZVtlLmxlbmd0aC0xXTp0W3QubGVuZ3RoLTFdPT09ZVtlLmxlbmd0aC0xXSYmdFt0Lmxlbmd0aC0yXT09PWVbZS5sZW5ndGgtMl0pLG59fSw3MTg6KHQsZSxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUucmVzaGFwZT12b2lkIDA7Y29uc3Qgcj1uKDI1MTcpO2UucmVzaGFwZT0odCxlKT0+e2NvbnN0IG49ci5TaGFwZVV0aWwuY2FsY3VsYXRlUmVzaGFwZWREaW1zKGVbMF0uZGltcyxlWzFdLmludGVnZXJEYXRhKTtyZXR1cm4gdC5zZXNzaW9uLnBhY2s/W3QucmVzaGFwZVBhY2tlZChlWzBdLG4pXTpbdC5yZXNoYXBlVW5wYWNrZWQoZVswXSxuKV19fSwyMjY4Oih0LGUsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLnBhcnNlUmVzaXplQXR0cmlidXRlc1YxMT1lLnBhcnNlUmVzaXplQXR0cmlidXRlc1YxMD1lLnJlc2l6ZT12b2lkIDA7Y29uc3Qgcj1uKDUwNjApLGk9bigyMDM5KSxvPW4oOTM5MCksYT1uKDI4MjcpLHM9big5NzkzKSx1PXtuYW1lOlwiUmVzaXplXCIsaW5wdXROYW1lczpbXCJBXCJdLGlucHV0VHlwZXM6W2kuVGV4dHVyZVR5cGUucGFja2VkXX07ZS5yZXNpemU9KHQsZSxuKT0+KCgwLHMudmFsaWRhdGVJbnB1dHMpKGUsbiksW3QucnVuKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSx1KSx7Y2FjaGVIaW50Om4uY2FjaGVLZXksZ2V0OigpPT5jKHQsZSxuKX0pLGUpXSksZS5wYXJzZVJlc2l6ZUF0dHJpYnV0ZXNWMTA9dD0+KDAscy5wYXJzZVVwc2FtcGxlQXR0cmlidXRlcykodCwxMCksZS5wYXJzZVJlc2l6ZUF0dHJpYnV0ZXNWMTE9dD0+KDAscy5wYXJzZVVwc2FtcGxlQXR0cmlidXRlcykodCwxMSk7Y29uc3QgYz0odCxlLG4pPT57Y29uc3Qgcz0oMCxyLmdldEdsc2wpKHQuc2Vzc2lvbi5iYWNrZW5kLmdsQ29udGV4dC52ZXJzaW9uKSxbYyxwXT1sKGUsbik7aWYoYy5ldmVyeSgodD0+MT09PXQpKSYmXCJ0Zl9jcm9wX2FuZF9yZXNpemVcIiE9PW4uY29vcmRpbmF0ZVRyYW5zZm9ybU1vZGUpcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSx1KSx7b3V0cHV0OntkaW1zOnAsdHlwZTplWzBdLnR5cGUsdGV4dHVyZVR5cGU6aS5UZXh0dXJlVHlwZS5wYWNrZWR9LGhhc01haW46ITAsc2hhZGVyU291cmNlOmB2b2lkIG1haW4oKSB7XFxuICAgICAgICAgICAgICAgICAgICB2ZWM0IHYgPSAke3MudGV4dHVyZTJEfShYLCBUZXhDb29yZHMpO1xcbiAgICAgICAgICAgICAgICAgICAgJHtzLm91dHB1dH0gPSB2O1xcbiAgICAgICAgICAgICAgICB9YH0pO2NvbnN0IGY9cC5sZW5ndGg7aWYoZjwyKXRocm93IG5ldyBFcnJvcihgb3V0cHV0IGRpbWVuc2lvbiBzaG91bGQgYmUgYXQgbGVhc3QgMiwgYnV0IGdvdCAke2Z9YCk7Y29uc3QgZD1wW2YtMl0saD1wW2YtMV0sZz1lWzBdLmRpbXM7aWYoZiE9PWcubGVuZ3RoKXRocm93IG5ldyBFcnJvcihgb3V0cHV0IGRpbWVuc2lvbiBzaG91bGQgbWF0Y2ggaW5wdXQgJHtnLmxlbmd0aH0sIGJ1dCBnb3QgJHtmfWApO2NvbnN0IGI9Z1tmLTJdLG09Z1tmLTFdLHk9Y1tmLTJdLF89Y1tmLTFdO2xldCB2PVwiXCI7aWYoXCJsaW5lYXJcIiE9PW4ubW9kZSl0aHJvdyBuZXcgRXJyb3IoYHJlc2l6ZSAocGFja2VkKSBkb2VzIG5vdCBzdXBwb3J0IG1vZGU6ICcke24ubW9kZX0nYCk7c3dpdGNoKG4uY29vcmRpbmF0ZVRyYW5zZm9ybU1vZGUpe2Nhc2VcImFzeW1tZXRyaWNcIjp2PVwiXFxuICAgICAgICAgICAgICAgICAgICB2ZWM0IGdldFNvdXJjZUZyYWNJbmRleChpdmVjNCBjb29yZHMpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmVjNChjb29yZHMpIC8gc2NhbGVXSFdIO1xcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICBcIjticmVhaztjYXNlXCJoYWxmX3BpeGVsXCI6dj1cIlxcbiAgICAgICAgICAgICAgICAgICAgdmVjNCBnZXRTb3VyY2VGcmFjSW5kZXgoaXZlYzQgY29vcmRzKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICh2ZWM0KGNvb3JkcykgKyAwLjUpIC8gc2NhbGVXSFdIIC0gMC41O1xcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICBcIjticmVhaztjYXNlXCJweXRvcmNoX2hhbGZfcGl4ZWxcIjp2PWBcXG4gICAgICAgICAgICAgICAgICAgIHZlYzQgZ2V0U291cmNlRnJhY0luZGV4KGl2ZWM0IGNvb3Jkcykge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlYzQgZmNvb3JkcyA9IHZlYzQoY29vcmRzKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmVjNChcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJHtofS4wID4gMS4wID8gKGZjb29yZHMueCArIDAuNSkgLyBzY2FsZVdIV0gueCAtIDAuNSA6IDAuMCxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJHtkfS4wID4gMS4wID8gKGZjb29yZHMueSArIDAuNSkgLyBzY2FsZVdIV0gueSAtIDAuNSA6IDAuMCxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJHtofS4wID4gMS4wID8gKGZjb29yZHMueiArIDAuNSkgLyBzY2FsZVdIV0gueiAtIDAuNSA6IDAuMCxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJHtkfS4wID4gMS4wID8gKGZjb29yZHMudyArIDAuNSkgLyBzY2FsZVdIV0gudyAtIDAuNSA6IDAuMFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgYDticmVhaztjYXNlXCJhbGlnbl9jb3JuZXJzXCI6dj1gXFxuICAgICAgICAgICAgICAgICAgICB2ZWM0IGdldFNvdXJjZUZyYWNJbmRleChpdmVjNCBjb29yZHMpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICB2ZWM0IHJlc2l6ZWQgPSB2ZWM0KCR7aH0uMCAtIDEuMCwgJHtkfS4wIC0gMS4wLCAke2h9LjAgLSAxLjAsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICR7ZH0uMCAtIDEuMCk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgdmVjNCBvcmlnaW5hbCA9IHZlYzQoJHttfS4wIC0gMS4wLCAke2J9LjAgLSAxLjAsICR7bX0uMCAtIDEuMCxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJHtifS4wIC0gMS4wKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICB2ZWM0IG5ld19zY2FsZSA9IG9yaWdpbmFsIC8gcmVzaXplZDtcXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmVjNChjb29yZHMpICogbmV3X3NjYWxlO1xcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICBgO2JyZWFrO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGByZXNpemUgKHBhY2tlZCkgZG9lcyBub3Qgc3VwcG9ydCBjb29yZGluYXRlVHJhbnNmb3JtTW9kZTogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnJHtuLmNvb3JkaW5hdGVUcmFuc2Zvcm1Nb2RlfSdgKX1jb25zdCB3PSgwLG8uZ2V0Q29vcmRzRGF0YVR5cGUpKGYpLHg9YFxcbiAgICAgICAgICAgIGNvbnN0IHZlYzIgaW5wdXRXSCA9IHZlYzIoJHtifS4wLCAke219LjApO1xcbiAgICAgICAgICAgIGNvbnN0IHZlYzQgc2NhbGVXSFdIID0gdmVjNChmbG9hdCgke3l9KSwgZmxvYXQoJHtffSksIGZsb2F0KCR7eX0pLCBmbG9hdCgke199KSk7XFxuICAgICAgICAgICAgJHsoMCxhLnVucGFja0Zyb21DaGFubmVsKSgpfVxcbiAgICAgICAgICAgICR7dn1cXG4gICAgICAgICAgICBmbG9hdCBnZXRBVmFsdWUoaW50IHgxMCwgaW50IHIsIGludCBjLCBpbnQgZCkge1xcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0Q2hhbm5lbChnZXRBKHgxMCwgciwgYywgZCksIHZlYzIoYywgZCkpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICAgICAgICAgICR7d30gcmMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG5cXG4gICAgICAgICAgICAgICAgaW50IGJhdGNoID0gcmNbMF07XFxuICAgICAgICAgICAgICAgIGludCBkZXB0aCA9IHJjWzFdO1xcblxcbiAgICAgICAgICAgICAgICAvLyByZXRyaWV2ZSB0aGUgNCBjb29yZGluYXRlcyB0aGF0IGlzIHVzZWQgaW4gdGhlIDQgcGFja2VkIG91dHB1dCB2YWx1ZXMuXFxuICAgICAgICAgICAgICAgIGl2ZWM0IGNvb3JkcyA9IGl2ZWM0KHJjLnd6LCByYy53ICsgMSwgcmMueiArIDEpO1xcblxcbiAgICAgICAgICAgICAgICAvLyBjYWxjdWxhdGUgdGhlIHNvdXJjZSBpbmRleCBpbiBmcmFjdGlvblxcbiAgICAgICAgICAgICAgICB2ZWM0IHNvdXJjZUZyYWMgPSBnZXRTb3VyY2VGcmFjSW5kZXgoY29vcmRzKTtcXG5cXG4gICAgICAgICAgICAgICAgLy8gZ2V0IHRoZSBsb3dlciBhbmQgdXBwZXIgYm91bmQgb2YgdGhlIDQgdmFsdWVzIHRoYXQgd2lsbCBiZSBwYWNrZWQgaW50byBvbmUgdGV4ZWwuXFxuICAgICAgICAgICAgICAgIGl2ZWM0IHgwMCA9IGl2ZWM0KG1heChzb3VyY2VGcmFjLnh5LCB2ZWMyKDAuMCkpLCBtaW4oaW5wdXRXSCAtIDEuMCwgY2VpbChzb3VyY2VGcmFjLnh5KSkpO1xcbiAgICAgICAgICAgICAgICBpdmVjNCB4MDEgPSBpdmVjNChtYXgoc291cmNlRnJhYy54dywgdmVjMigwLjApKSwgbWluKGlucHV0V0ggLSAxLjAsIGNlaWwoc291cmNlRnJhYy54dykpKTtcXG4gICAgICAgICAgICAgICAgaXZlYzQgeDEwID0gaXZlYzQobWF4KHNvdXJjZUZyYWMuenksIHZlYzIoMC4wKSksIG1pbihpbnB1dFdIIC0gMS4wLCBjZWlsKHNvdXJjZUZyYWMuenkpKSk7XFxuICAgICAgICAgICAgICAgIGl2ZWM0IHgxMSA9IGl2ZWM0KG1heChzb3VyY2VGcmFjLnp3LCB2ZWMyKDAuMCkpLCBtaW4oaW5wdXRXSCAtIDEuMCwgY2VpbChzb3VyY2VGcmFjLnp3KSkpO1xcblxcbiAgICAgICAgICAgICAgICBib29sIGhhc05leHRSb3cgPSByYy53IDwgJHtkLTF9O1xcbiAgICAgICAgICAgICAgICBib29sIGhhc05leHRDb2wgPSByYy56IDwgJHtoLTF9O1xcblxcbiAgICAgICAgICAgICAgICAvLyBwYWNrIHgwMCwgeDAxLCB4MTAsIHgxMSdzIHRvcC1sZWZ0IGNvcm5lciBpbnRvIG9uZSB2ZWM0IHN0cnVjdHVyZVxcbiAgICAgICAgICAgICAgICB2ZWM0IHRvcExlZnQgPSB2ZWM0KFxcbiAgICAgICAgICAgICAgICAgICAgZ2V0QVZhbHVlKGJhdGNoLCBkZXB0aCwgeDAwLngsIHgwMC55KSxcXG4gICAgICAgICAgICAgICAgICAgIGhhc05leHRDb2wgPyBnZXRBVmFsdWUoYmF0Y2gsIGRlcHRoLCB4MDEueCwgeDAxLnkpIDogMC4wLFxcbiAgICAgICAgICAgICAgICAgICAgaGFzTmV4dFJvdyA/IGdldEFWYWx1ZShiYXRjaCwgZGVwdGgsIHgxMC54LCB4MTAueSkgOiAwLjAsXFxuICAgICAgICAgICAgICAgICAgICAoaGFzTmV4dFJvdyAmJiBoYXNOZXh0Q29sKSA/IGdldEFWYWx1ZShiYXRjaCwgZGVwdGgsIHgxMS54LCB4MTEueSkgOiAwLjApO1xcblxcbiAgICAgICAgICAgICAgICAvLyBwYWNrIHgwMCwgeDAxLCB4MTAsIHgxMSdzIHRvcC1yaWdodCBjb3JuZXIgaW50byBvbmUgdmVjNCBzdHJ1Y3R1cmVcXG4gICAgICAgICAgICAgICAgdmVjNCB0b3BSaWdodCA9IHZlYzQoXFxuICAgICAgICAgICAgICAgICAgICBnZXRBVmFsdWUoYmF0Y2gsIGRlcHRoLCB4MDAueCwgeDAwLncpLFxcbiAgICAgICAgICAgICAgICAgICAgaGFzTmV4dENvbCA/IGdldEFWYWx1ZShiYXRjaCwgZGVwdGgsIHgwMS54LCB4MDEudykgOiAwLjAsXFxuICAgICAgICAgICAgICAgICAgICBoYXNOZXh0Um93ID8gZ2V0QVZhbHVlKGJhdGNoLCBkZXB0aCwgeDEwLngsIHgxMC53KSA6IDAuMCxcXG4gICAgICAgICAgICAgICAgICAgIChoYXNOZXh0Um93ICYmIGhhc05leHRDb2wpID8gZ2V0QVZhbHVlKGJhdGNoLCBkZXB0aCwgeDExLngsIHgxMS53KSA6IDAuMCk7XFxuXFxuICAgICAgICAgICAgICAgIC8vIHBhY2sgeDAwLCB4MDEsIHgxMCwgeDExJ3MgYm90dG9tLWxlZnQgY29ybmVyIGludG8gb25lIHZlYzQgc3RydWN0dXJlXFxuICAgICAgICAgICAgICAgIHZlYzQgYm90dG9tTGVmdCA9IHZlYzQoXFxuICAgICAgICAgICAgICAgICAgICBnZXRBVmFsdWUoYmF0Y2gsIGRlcHRoLCB4MDAueiwgeDAwLnkpLFxcbiAgICAgICAgICAgICAgICAgICAgaGFzTmV4dENvbCA/IGdldEFWYWx1ZShiYXRjaCwgZGVwdGgsIHgwMS56LCB4MDEueSkgOiAwLjAsXFxuICAgICAgICAgICAgICAgICAgICBoYXNOZXh0Um93ID8gZ2V0QVZhbHVlKGJhdGNoLCBkZXB0aCwgeDEwLnosIHgxMC55KSA6IDAuMCxcXG4gICAgICAgICAgICAgICAgICAgIChoYXNOZXh0Um93ICYmIGhhc05leHRDb2wpID8gZ2V0QVZhbHVlKGJhdGNoLCBkZXB0aCwgeDExLnosIHgxMS55KSA6IDAuMCk7XFxuXFxuICAgICAgICAgICAgICAgIC8vIHBhY2sgeDAwLCB4MDEsIHgxMCwgeDExJ3MgYm90dG9tLXJpZ2h0IGNvcm5lciBpbnRvIG9uZSB2ZWM0IHN0cnVjdHVyZVxcbiAgICAgICAgICAgICAgICB2ZWM0IGJvdHRvbVJpZ2h0ID0gdmVjNChcXG4gICAgICAgICAgICAgICAgICAgIGdldEFWYWx1ZShiYXRjaCwgZGVwdGgsIHgwMC56LCB4MDAudyksXFxuICAgICAgICAgICAgICAgICAgICBoYXNOZXh0Q29sID8gZ2V0QVZhbHVlKGJhdGNoLCBkZXB0aCwgeDAxLnosIHgwMS53KSA6IDAuMCxcXG4gICAgICAgICAgICAgICAgICAgIGhhc05leHRSb3cgPyBnZXRBVmFsdWUoYmF0Y2gsIGRlcHRoLCB4MTAueiwgeDEwLncpIDogMC4wLFxcbiAgICAgICAgICAgICAgICAgICAgKGhhc05leHRSb3cgJiYgaGFzTmV4dENvbCkgPyBnZXRBVmFsdWUoYmF0Y2gsIGRlcHRoLCB4MTEueiwgeDExLncpIDogMC4wKTtcXG5cXG4gICAgICAgICAgICAgICAgLy8gY2FsY3VsYXRlIHRoZSBpbnRlcnBvbGF0aW9uIGZyYWN0aW9uIG9uIHUgYW5kIHYgZGlyZWN0aW9uXFxuICAgICAgICAgICAgICAgIHZlYzQgZnJhYyA9IHZlYzQoc291cmNlRnJhYykgLSBmbG9vcihzb3VyY2VGcmFjKTtcXG4gICAgICAgICAgICAgICAgdmVjNCBjbGFtcEZyYWMgPSBjbGFtcChmcmFjLCB2ZWM0KDAuMCksIHZlYzQoMS4wKSk7XFxuXFxuICAgICAgICAgICAgICAgIHZlYzQgdG9wID0gbWl4KHRvcExlZnQsIHRvcFJpZ2h0LCBjbGFtcEZyYWMueXd5dyk7XFxuICAgICAgICAgICAgICAgIHZlYzQgYm90dG9tID0gbWl4KGJvdHRvbUxlZnQsIGJvdHRvbVJpZ2h0LCBjbGFtcEZyYWMueXd5dyk7XFxuICAgICAgICAgICAgICAgIHZlYzQgbmV3VmFsdWUgPSBtaXgodG9wLCBib3R0b20sIGNsYW1wRnJhYy54eHp6KTtcXG5cXG4gICAgICAgICAgICAgICAgJHtzLm91dHB1dH0gPSB2ZWM0KG5ld1ZhbHVlKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICBgO3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sdSkse291dHB1dDp7ZGltczpwLHR5cGU6ZVswXS50eXBlLHRleHR1cmVUeXBlOmkuVGV4dHVyZVR5cGUucGFja2VkfSxoYXNNYWluOiEwLHNoYWRlclNvdXJjZTp4fSl9LGw9KHQsZSk9Pntjb25zdCBuPXRbMF0uZGltcztsZXQgcixpPWUuc2NhbGVzO2lmKDA9PT1pLmxlbmd0aCl7Y29uc3Qgbz10W2Uuc2NhbGVzSW5wdXRJZHhdO2lmKG8mJjAhPT1vLnNpemUpe2lmKHRbZS5zaXplc0lucHV0SWR4XSl0aHJvdyBuZXcgRXJyb3IoXCJPbmx5IG9uZSBvZiBzY2FsZXMgb3Igc2l6ZXMgbXVzdCBiZSBwcm92aWRlZCBhcyBpbnB1dC5cIik7aT1wKG8sZS5tb2RlLGUuaXNSZXNpemUpfWVsc2V7Y29uc3Qgbz10W2Uuc2l6ZXNJbnB1dElkeF07aWYoIW98fDA9PT1vLnNpemUpdGhyb3cgbmV3IEVycm9yKFwiRWl0aGVyIHNjYWxlcyBvciBzaXplcyBNVVNUIGJlIHByb3ZpZGVkIGFzIGlucHV0LlwiKTtyPUFycmF5LmZyb20oby5pbnRlZ2VyRGF0YSksaT1mKHIsbixlLm1vZGUsZS5pc1Jlc2l6ZSl9fWVsc2UgaWYodFtlLnNpemVzSW5wdXRJZHhdKXRocm93IG5ldyBFcnJvcihcIk9ubHkgb25lIG9mIHNjYWxlcyBvciBzaXplcyBtdXN0IGJlIHByb3ZpZGVkIGFzIGlucHV0LlwiKTtjb25zdCBvPXJ8fG4ubWFwKCgodCxlKT0+TWF0aC5mbG9vcih0KmlbZV0pKSk7cmV0dXJuW2ksb119LHA9KHQsZSxuKT0+e2NvbnN0IHI9QXJyYXkuZnJvbSh0LmZsb2F0RGF0YSk7cmV0dXJuKDAscy5zY2FsZXNWYWxpZGF0aW9uKShyLGUsbikscn0sZj0odCxlLG4scik9Pntjb25zdCBpPWUubGVuZ3RoLG89bmV3IEFycmF5KGkpO2ZvcihsZXQgbj0wLHI9aTtuPHI7bisrKWlmKDA9PT1lW25dKXtpZigwIT09dFtuXSl0aHJvdyBuZXcgRXJyb3IoXCJJbnB1dCBkaW0gaXMgemVybyBidXQgcmVxdWlyZWQgb3V0cHV0IGRpbSBpcyBub24temVyby5cIik7b1tuXT0xfWVsc2Ugb1tuXT10W25dL2Vbbl07cmV0dXJuKDAscy5zY2FsZXNWYWxpZGF0aW9uKShvLG4sciksb319LDgxMTc6KHQsZSxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUuc2hhcGU9dm9pZCAwO2NvbnN0IHI9big5MTYyKTtlLnNoYXBlPSh0LGUpPT4oaShlKSxbbmV3IHIuVGVuc29yKFtlWzBdLmRpbXMubGVuZ3RoXSxcImludDMyXCIsdm9pZCAwLHZvaWQgMCxuZXcgSW50MzJBcnJheShlWzBdLmRpbXMpKV0pO2NvbnN0IGk9dD0+e2lmKCF0fHwxIT09dC5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiU2hhcGUgcmVxdWlyZXMgMSBpbnB1dC5cIil9fSwyMjc4Oih0LGUsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLnNsaWNlVjEwPWUucGFyc2VTbGljZUF0dHJpYnV0ZXM9ZS5zbGljZT12b2lkIDA7Y29uc3Qgcj1uKDI0NiksaT1uKDc4Miksbz1uKDI1MTcpLGE9bigyMDM5KSxzPXtuYW1lOlwiU2xpY2VcIixpbnB1dE5hbWVzOltcIkFcIl0saW5wdXRUeXBlczpbYS5UZXh0dXJlVHlwZS51bnBhY2tlZF19O2Uuc2xpY2U9KHQsZSxuKT0+KGMoZSksW3QucnVuKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxzKSx7Y2FjaGVIaW50Om4uY2FjaGVLZXksZ2V0OigpPT51KHQsZVswXSxuKX0pLGUpXSksZS5wYXJzZVNsaWNlQXR0cmlidXRlcz10PT57Y29uc3QgZT10LmF0dHJpYnV0ZXMuZ2V0SW50cyhcInN0YXJ0c1wiKSxuPXQuYXR0cmlidXRlcy5nZXRJbnRzKFwiZW5kc1wiKSxpPXQuYXR0cmlidXRlcy5nZXRJbnRzKFwiYXhlc1wiLFtdKTtyZXR1cm4oMCxyLmNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSkoe3N0YXJ0czplLGVuZHM6bixheGVzOml9KX07Y29uc3QgdT0odCxlLG4pPT57Y29uc3Qgcj0wPT09bi5heGVzLmxlbmd0aD9lLmRpbXMuc2xpY2UoMCkubWFwKCgodCxlKT0+ZSkpOm4uYXhlcyxpPW8uU2hhcGVVdGlsLm5vcm1hbGl6ZUF4ZXMocixlLmRpbXMubGVuZ3RoKSx1PW4uc3RhcnRzLm1hcCgoKHQsbik9PnQ+ZS5kaW1zW2lbbl1dLTE/ZS5kaW1zW2lbbl1dOm8uU2hhcGVVdGlsLm5vcm1hbGl6ZUF4aXModCxlLmRpbXNbaVtuXV0pKSksYz1uLmVuZHMubWFwKCgodCxuKT0+dD5lLmRpbXNbaVtuXV0tMT9lLmRpbXNbaVtuXV06by5TaGFwZVV0aWwubm9ybWFsaXplQXhpcyh0LGUuZGltc1tpW25dXSkpKSxsPWUuZGltcy5zbGljZSgpLHA9W107Zm9yKGxldCB0PTA7dDxpLmxlbmd0aDt0KyspbFtpW3RdXT1jW3RdLXVbdF0sdVt0XT4wJiZwLnB1c2goYG91dHB1dElkeFske2lbdF19XSArPSAke3VbdF19O2ApO2NvbnN0IGY9YFxcbiAgICAgIGZsb2F0IHByb2Nlc3MoaW50IG91dHB1dElkeFske2wubGVuZ3RofV0pIHtcXG4gICAgICAgICR7cC5qb2luKFwiXFxuICAgICAgXCIpfVxcbiAgICAgICAgcmV0dXJuIF9BKG91dHB1dElkeCk7XFxuICAgICAgfWA7cmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxzKSx7b3V0cHV0OntkaW1zOmwsdHlwZTplLnR5cGUsdGV4dHVyZVR5cGU6YS5UZXh0dXJlVHlwZS51bnBhY2tlZH0sc2hhZGVyU291cmNlOmZ9KX0sYz10PT57aWYoIXR8fDEhPT10Lmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJTbGljZSByZXF1aXJlcyAxIGlucHV0LlwiKTtpZigtMT09PWkuTlVNQkVSX1RZUEVTLmluZGV4T2YodFswXS50eXBlKSl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGlucHV0IHR5cGUuXCIpfTtlLnNsaWNlVjEwPSh0LGUpPT57cChlKTtjb25zdCBuPWwodCxlKTtyZXR1cm5bdC5ydW4oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LHMpLHtjYWNoZUhpbnQ6bi5jYWNoZUtleSxnZXQ6KCk9PnUodCxlWzBdLG4pfSksW2VbMF1dKV19O2NvbnN0IGw9KHQsZSk9PntpZighdC5zZXNzaW9uLmlzSW5pdGlhbGl6ZXIoZVsxXS5kYXRhSWQpfHwhdC5zZXNzaW9uLmlzSW5pdGlhbGl6ZXIoZVsyXS5kYXRhSWQpfHxlLmxlbmd0aD49NCYmIXQuc2Vzc2lvbi5pc0luaXRpYWxpemVyKGVbM10uZGF0YUlkKXx8ZS5sZW5ndGg+PTUmJiF0LnNlc3Npb24uaXNJbml0aWFsaXplcihlWzRdLmRhdGFJZCkpdGhyb3cgbmV3IEVycm9yKFwiZHluYW1pYyBzbGljZSBhdHRyaWJ1dGVzIGFyZSBub3QgYWxsb3dlZFwiKTtpZihlLmxlbmd0aD49NSYmZVs0XS5pbnRlZ2VyRGF0YS5zb21lKCh0PT4xIT09dCkpKXRocm93IG5ldyBFcnJvcihcImN1cnJlbnRseSBub24tMSBzdGVwcyBpcyBub3Qgc3VwcG9ydGVkIGZvciBTbGljZVwiKTtjb25zdCBuPUFycmF5LmZyb20oZVsxXS5pbnRlZ2VyRGF0YSkscj1BcnJheS5mcm9tKGVbMl0uaW50ZWdlckRhdGEpLGk9ZS5sZW5ndGg+PTQ/QXJyYXkuZnJvbShlWzNdLmludGVnZXJEYXRhKTpbXTtyZXR1cm57c3RhcnRzOm4sZW5kczpyLGF4ZXM6aSxjYWNoZUtleTpgJHtpfTske259OyR7cn1gfX0scD10PT57aWYoIXR8fHQubGVuZ3RoPDN8fHQubGVuZ3RoPjUpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpbnB1dCBudW1iZXIuXCIpO2lmKFwiaW50MzJcIiE9PXRbMV0udHlwZXx8MSE9PXRbMV0uZGltcy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpbnB1dCB0eXBlLlwiKTtpZihcImludDMyXCIhPT10WzJdLnR5cGV8fDEhPT10WzJdLmRpbXMubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW5wdXQgdHlwZS5cIik7aWYodC5sZW5ndGg+PTQmJihcImludDMyXCIhPT10WzNdLnR5cGV8fDEhPT10WzNdLmRpbXMubGVuZ3RoKSl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGlucHV0IHR5cGUuXCIpO2lmKHQubGVuZ3RoPj01JiYoXCJpbnQzMlwiIT09dFs0XS50eXBlfHwxIT09dFs0XS5kaW1zLmxlbmd0aCkpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpbnB1dCB0eXBlLlwiKX19LDU1MjQ6KHQsZSxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUuc29mdG1heFYxMz1lLnBhcnNlU29mdG1heEF0dHJpYnV0ZXNWMTM9ZS5wYXJzZVNvZnRtYXhBdHRyaWJ1dGVzPWUuc29mdG1heD12b2lkIDA7Y29uc3Qgcj1uKDI0NiksaT1uKDI1MTcpLG89big1MDYwKSxhPW4oMjAzOSkscz1uKDM3MzgpLHU9e25hbWU6XCJTb2Z0bWF4Q29tcHV0ZU1heFwiLGlucHV0TmFtZXM6W1wiQVwiXSxpbnB1dFR5cGVzOlthLlRleHR1cmVUeXBlLnVucGFja2VkXX0sYz17bmFtZTpcIlNvZnRtYXhDb21wdXRlU2NhbGVcIixpbnB1dE5hbWVzOltcIkFcIixcIk1heFwiXSxpbnB1dFR5cGVzOlthLlRleHR1cmVUeXBlLnVucGFja2VkLGEuVGV4dHVyZVR5cGUudW5wYWNrZWRdfSxsPXtuYW1lOlwiU29mdE1heFwiLGlucHV0TmFtZXM6W1wiQVwiLFwiTWF4XCIsXCJOb3JtXCJdLGlucHV0VHlwZXM6W2EuVGV4dHVyZVR5cGUudW5wYWNrZWQsYS5UZXh0dXJlVHlwZS51bnBhY2tlZCxhLlRleHR1cmVUeXBlLnVucGFja2VkXX07ZS5zb2Z0bWF4PSh0LGUsbik9PntnKGUpO2NvbnN0IHI9ZVswXS5kaW1zLnNsaWNlKCksbz1pLlNoYXBlVXRpbC5ub3JtYWxpemVBeGlzKG4uYXhpcyxyLmxlbmd0aCksYT1pLlNoYXBlVXRpbC5zaXplVG9EaW1lbnNpb24ocixvKSxzPWkuU2hhcGVVdGlsLnNpemVGcm9tRGltZW5zaW9uKHIsbyk7cmV0dXJuIHAodCxlLG4sYSxzKX0sZS5wYXJzZVNvZnRtYXhBdHRyaWJ1dGVzPXQ9PigwLHIuY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KSh7YXhpczp0LmF0dHJpYnV0ZXMuZ2V0SW50KFwiYXhpc1wiLDEpfSksZS5wYXJzZVNvZnRtYXhBdHRyaWJ1dGVzVjEzPXQ9PigwLHIuY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KSh7YXhpczp0LmF0dHJpYnV0ZXMuZ2V0SW50KFwiYXhpc1wiLC0xKX0pLGUuc29mdG1heFYxMz0odCxlLG4pPT57ZyhlKTtjb25zdCBvPWVbMF0uZGltcy5zbGljZSgpLGE9aS5TaGFwZVV0aWwubm9ybWFsaXplQXhpcyhuLmF4aXMsby5sZW5ndGgpLHU9by5sZW5ndGgsYz1hIT09dS0xLGw9W107bGV0IGYsZD1bXSxoPVtdO2MmJihkPUFycmF5LmZyb20oe2xlbmd0aDp1fSkubWFwKCgodCxlKT0+ZSkpLGRbYV09dS0xLGRbdS0xXT1hLGQubWFwKCh0PT5sLnB1c2gob1t0XSkpKSxmPSgwLHIuY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KSh7cGVybTpkfSksaD0oMCxzLnRyYW5zcG9zZSkodCxlLGYpKTtjb25zdCBiPWM/aS5TaGFwZVV0aWwuc2l6ZVRvRGltZW5zaW9uKGwsdS0xKTppLlNoYXBlVXRpbC5zaXplVG9EaW1lbnNpb24obyx1LTEpLG09Yz9pLlNoYXBlVXRpbC5zaXplRnJvbURpbWVuc2lvbihsLHUtMSk6aS5TaGFwZVV0aWwuc2l6ZUZyb21EaW1lbnNpb24obyx1LTEpLHk9cCh0LGM/aDplLG4sYixtKTtyZXR1cm4gYz8oMCxzLnRyYW5zcG9zZSkodCx5LGYpOnl9O2NvbnN0IHA9KHQsZSxuLHIsaSk9Pntjb25zdCBvPWYodCxlWzBdLHIsaSxbcl0pLGE9dC5ydW4oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LHUpLHtjYWNoZUhpbnQ6bi5jYWNoZUtleSxnZXQ6KCk9Pm99KSxlKSxzPWQodCxlWzBdLHIsaSxvLm91dHB1dC5kaW1zLFtyXSkscD10LnJ1bihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sYykse2NhY2hlSGludDpuLmNhY2hlS2V5LGdldDooKT0+c30pLFtlWzBdLGFdKSxnPWgodCxlWzBdLHIsaSxvLm91dHB1dC5kaW1zLHMub3V0cHV0LmRpbXMpO3JldHVyblt0LnJ1bihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sbCkse2NhY2hlSGludDpuLmNhY2hlS2V5LGdldDooKT0+Z30pLFtlWzBdLGEscF0pXX0sZj0odCxlLG4scixpKT0+e2NvbnN0W3MsY109dC5jYWxjdWxhdGVUZXh0dXJlV2lkdGhBbmRIZWlnaHQoZS5kaW1zLGEuVGV4dHVyZVR5cGUudW5wYWNrZWQpLGw9aS5sZW5ndGg7aWYobjwxfHxyPDEpdGhyb3cgbmV3IEVycm9yKFwiTG9naWNhbCByb3cgY291bnQgTiBhbmQgZmVhdHVyZSBjb3VudCBEIG11c3QgYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIDFcIik7aWYoMSE9PWkubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIkRpbWVuc2lvbmFsaXR5IG9mIHRoZSBvdXRwdXQgc2hvdWxkIGJlIDFcIik7aWYoaVswXSE9PW4pdGhyb3cgbmV3IEVycm9yKFwiU2hhcGUgb2YgdGhlIG91dHB1dCBzaG91bGQgYmUgZXF1YWwgdG8gbG9naWNhbCByb3cgY291bnRcIik7Y29uc3QgcD0oMCxvLmdldEdsc2wpKHQuc2Vzc2lvbi5iYWNrZW5kLmdsQ29udGV4dC52ZXJzaW9uKSxmPWBcXG4gICAgICBmbG9hdCBwcm9jZXNzKGludFske2x9XSBpbmRpY2VzKSB7XFxuICAgICAgICBpbnQgbG9naWNhbF9yb3dfc3RhcnRfb2Zmc2V0ID0gaW5kaWNlc1swXSAqICR7cn07XFxuXFxuICAgICAgICBmbG9hdCBtYXggPSBnZXRDb2xvckFzRmxvYXQoJHtwLnRleHR1cmUyRH0oQSwgb2Zmc2V0VG9Db29yZHMobG9naWNhbF9yb3dfc3RhcnRfb2Zmc2V0LCAke3N9LFxcbiAgICAgICAgJHtjfSApKSk7XFxuICAgICAgICBmb3IoaW50IGk9MTsgaTwke3J9OyArK2kpXFxuICAgICAgICB7XFxuICAgICAgICAgIGZsb2F0IGN1cnJlbnQgPSBnZXRDb2xvckFzRmxvYXQoJHtwLnRleHR1cmUyRH0oQSwgb2Zmc2V0VG9Db29yZHMobG9naWNhbF9yb3dfc3RhcnRfb2Zmc2V0ICsgaSxcXG4gICAgICAgICAgICAke3N9LCAke2N9KSkpO1xcbiAgICAgICAgICBpZihjdXJyZW50ID4gbWF4KVxcbiAgICAgICAgICBtYXggPSBjdXJyZW50O1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgcmV0dXJuIG1heDtcXG4gICAgICB9YDtyZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LHUpLHtvdXRwdXQ6e2RpbXM6aSx0eXBlOmUudHlwZSx0ZXh0dXJlVHlwZTphLlRleHR1cmVUeXBlLnVucGFja2VkfSxzaGFkZXJTb3VyY2U6Zn0pfSxkPSh0LGUsbixyLGkscyk9Pntjb25zdFt1LGxdPXQuY2FsY3VsYXRlVGV4dHVyZVdpZHRoQW5kSGVpZ2h0KGUuZGltcyxhLlRleHR1cmVUeXBlLnVucGFja2VkKSxwPXMubGVuZ3RoO2lmKG48MXx8cjwxKXRocm93IG5ldyBFcnJvcihcIkxvZ2ljYWwgcm93IGNvdW50IE4gYW5kIGZlYXR1cmUgY291bnQgRCBtdXN0IGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAxXCIpO2lmKDEhPT1zLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJEaW1lbnNpb25hbGl0eSBvZiB0aGUgb3V0cHV0IHNob3VsZCBiZSAxXCIpO2lmKHNbMF0hPT1uKXRocm93IG5ldyBFcnJvcihcIlNoYXBlIG9mIHRoZSBvdXRwdXQgc2hvdWxkIGJlIGVxdWFsIHRvIGxvZ2ljYWwgcm93IGNvdW50XCIpO2lmKDEhPT1pLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJEaW1lbnNpb25hbGl0eSBvZiB0aGUgaW50ZXJtZWRpYXRlIHJlc3VsdHMgc2hvdWxkIGJlIDFcIik7aWYoaVswXSE9PW4pdGhyb3cgbmV3IEVycm9yKFwiU2hhcGUgb2YgdGhlIGludGVybWVkaWF0ZSByZXN1bHRzIHNob3VsZCBiZSBlcXVhbCB0byBsb2dpY2FsIHJvdyBjb3VudFwiKTtjb25zdCBmPWBcXG4gICAgICBmbG9hdCBwcm9jZXNzKGludFske3B9XSBpbmRpY2VzKSB7XFxuICAgICAgICBpbnQgbG9naWNhbF9yb3dfc3RhcnRfb2Zmc2V0ID0gaW5kaWNlc1swXSAqICR7cn07XFxuXFxuICAgICAgICBmbG9hdCBub3JtX2ZhY3RvciA9IDAuMDtcXG4gICAgICAgIGZsb2F0IG1heCA9IF9NYXgoaW5kaWNlcyk7XFxuICAgICAgICBmb3IoaW50IGk9MDsgaTwke3J9OyArK2kpXFxuICAgICAgICB7XFxuICAgICAgICAgIG5vcm1fZmFjdG9yICs9IGV4cChnZXRDb2xvckFzRmxvYXQoJHsoMCxvLmdldEdsc2wpKHQuc2Vzc2lvbi5iYWNrZW5kLmdsQ29udGV4dC52ZXJzaW9uKS50ZXh0dXJlMkR9KEEsIG9mZnNldFRvQ29vcmRzKGxvZ2ljYWxfcm93X3N0YXJ0X29mZnNldCArIGksXFxuICAgICAgICAgICAgJHt1fSwgJHtsfSkpKSAtIG1heCk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICByZXR1cm4gbm9ybV9mYWN0b3I7XFxuICAgICAgfWA7cmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxjKSx7b3V0cHV0OntkaW1zOnMsdHlwZTplLnR5cGUsdGV4dHVyZVR5cGU6YS5UZXh0dXJlVHlwZS51bnBhY2tlZH0sc2hhZGVyU291cmNlOmZ9KX0saD0odCxlLG4scixpLG8pPT57Y29uc3Rbcyx1XT10LmNhbGN1bGF0ZVRleHR1cmVXaWR0aEFuZEhlaWdodChlLmRpbXMsYS5UZXh0dXJlVHlwZS51bnBhY2tlZCksYz1lLmRpbXMubGVuZ3RoO2lmKG48MXx8cjwxKXRocm93IG5ldyBFcnJvcihcIkxvZ2ljYWwgcm93IGNvdW50IE4gYW5kIGZlYXR1cmUgY291bnQgRCBtdXN0IGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAxXCIpO2lmKDEhPT1pLmxlbmd0aHx8MSE9PW8ubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIkRpbWVuc2lvbmFsaXR5IG9mIHRoZSBpbnRlcm1lZGlhdGUgcmVzdWx0cyBzaG91bGQgYmUgMVwiKTtpZihpWzBdIT09bnx8b1swXSE9PW4pdGhyb3cgbmV3IEVycm9yKFwiU2hhcGUgb2YgdGhlIGludGVybWVkaWF0ZSByZXN1bHRzIHNob3VsZCBiZSBlcXVhbCB0byBsb2dpY2FsIHJvdyBjb3VudFwiKTtjb25zdCBwPWBcXG4gICAgICBmbG9hdCBwcm9jZXNzKGludFske2N9XSBpbmRpY2VzKSB7XFxuXFxuICAgICAgLy8gZ2V0IG9mZnNldCBvZiBjdXJyZW50IGxvZ2ljYWwgdGVuc29yIGluZGV4IGZyb20gdGhlIDItRCB0ZXh0dXJlIGNvb3JkaW5hdGVzIChUZXhDb29yZHMpXFxuICAgICAgaW50IG9mZnNldCA9IGNvb3Jkc1RvT2Zmc2V0KFRleENvb3JkcywgJHtzfSwgJHt1fSk7XFxuXFxuICAgICAgLy9kZXRlcm1pbmUgdGhlIGxvZ2ljYWwgcm93IGZvciB0aGlzIGluZGV4XFxuICAgICAgaW50IGxvZ2ljYWxfcm93X2luZGV4WzFdO1xcbiAgICAgIGxvZ2ljYWxfcm93X2luZGV4WzBdID0gb2Zmc2V0IC8gJHtyfTtcXG5cXG4gICAgICBmbG9hdCBub3JtX2ZhY3RvciA9IF9Ob3JtKGxvZ2ljYWxfcm93X2luZGV4KTtcXG5cXG4gICAgICAvLyBhdm9pZCBwb3NzaWJsZSBkaXZpc2lvbiBieSAwXFxuICAgICAgLy8gaWYgbm9ybV9mYWNvciBpcyAwLCBhbGwgZWxlbWVudHMgYXJlIHplcm9cXG4gICAgICAvLyBpZiBzbywgcmV0dXJuIDBcXG4gICAgICBpZihub3JtX2ZhY3RvciA9PSAwLjApXFxuICAgICAgICByZXR1cm4gMC4wO1xcblxcbiAgICAgIHJldHVybiBleHAoX0EoaW5kaWNlcykgLSBfTWF4KGxvZ2ljYWxfcm93X2luZGV4KSkgLyBub3JtX2ZhY3RvcjtcXG4gICAgfWA7cmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxsKSx7b3V0cHV0OntkaW1zOmUuZGltcyx0eXBlOmUudHlwZSx0ZXh0dXJlVHlwZTphLlRleHR1cmVUeXBlLnVucGFja2VkfSxzaGFkZXJTb3VyY2U6cH0pfSxnPXQ9PntpZighdHx8MSE9PXQubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIlNvZnRtYXggcmVxdWlyZXMgMSBpbnB1dC5cIik7aWYoXCJmbG9hdDMyXCIhPT10WzBdLnR5cGUmJlwiZmxvYXQ2NFwiIT09dFswXS50eXBlKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW5wdXQgdHlwZVwiKX19LDU5NzU6KHQsZSxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUucGFyc2VTcGxpdEF0dHJpYnV0ZXM9ZS5zcGxpdD12b2lkIDA7Y29uc3Qgcj1uKDI0NiksaT1uKDI1MTcpLG89bigyMDM5KSxhPXtuYW1lOlwiU3BsaXRcIixpbnB1dE5hbWVzOltcIkFcIl0saW5wdXRUeXBlczpbby5UZXh0dXJlVHlwZS51bnBhY2tlZF19O2Uuc3BsaXQ9KHQsZSxuKT0+e2MoZSk7Y29uc3Qgcj1pLlNoYXBlVXRpbC5ub3JtYWxpemVBeGlzKG4uYXhpcyxlWzBdLmRpbXMubGVuZ3RoKSxvPXModCxlLHIsbiksbD1bXTtmb3IobGV0IGk9MDtpPG87KytpKWwucHVzaCh0LnJ1bihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sYSkse2NhY2hlSGludDpgJHtuLmNhY2hlS2V5fTske2l9YCxnZXQ6KCk9PnUodCxlWzBdLG4scixpKX0pLGUpKTtyZXR1cm4gbH0sZS5wYXJzZVNwbGl0QXR0cmlidXRlcz10PT57Y29uc3QgZT10LmF0dHJpYnV0ZXMuZ2V0SW50KFwiYXhpc1wiLDApLG49dC5hdHRyaWJ1dGVzLmdldEludHMoXCJzcGxpdFwiLFtdKSxpPXQub3V0cHV0cy5sZW5ndGg7cmV0dXJuKDAsci5jcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkpKHtheGlzOmUsc3BsaXQ6bixudW1PdXRwdXRzOml9KX07Y29uc3Qgcz0odCxlLG4scik9Pntjb25zdFssb109aS5TcGxpdFV0aWwuc3BsaXRTaGFwZShlWzBdLmRpbXMsbixyLnNwbGl0LHIubnVtT3V0cHV0cyk7cmV0dXJuIG8ubGVuZ3RofSx1PSh0LGUsbixyLHMpPT57Y29uc3RbdSxjXT1pLlNwbGl0VXRpbC5zcGxpdFNoYXBlKGUuZGltcyxyLG4uc3BsaXQsbi5udW1PdXRwdXRzKSxsPWNbc10scD11W3NdLGY9YFxcbiAgICAgIGZsb2F0IHByb2Nlc3MoaW50IGluZGljZXNbJHtwLmxlbmd0aH1dKSB7XFxuICAgICAgICBpbmRpY2VzWyR7cn1dICs9ICR7bH07XFxuICAgICAgICByZXR1cm4gX0EoaW5kaWNlcyk7XFxuICAgICAgfVxcbiAgICBgO3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sYSkse2NhY2hlSGludDpgJHtuLmNhY2hlS2V5fToke3N9YCxvdXRwdXQ6e2RpbXM6cCx0eXBlOmUudHlwZSx0ZXh0dXJlVHlwZTpvLlRleHR1cmVUeXBlLnVucGFja2VkfSxzaGFkZXJTb3VyY2U6Zn0pfSxjPXQ9PntpZighdHx8MSE9PXQubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIlNwbGl0IHJlcXVpcmVzIG9uZSBpbnB1dC5cIik7aWYoXCJpbnQ4XCIhPT10WzBdLnR5cGUmJlwidWludDhcIiE9PXRbMF0udHlwZSYmXCJpbnQxNlwiIT09dFswXS50eXBlJiZcInVpbnQxNlwiIT09dFswXS50eXBlJiZcImludDMyXCIhPT10WzBdLnR5cGUmJlwidWludDMyXCIhPT10WzBdLnR5cGUmJlwiZmxvYXQzMlwiIT09dFswXS50eXBlJiZcImZsb2F0NjRcIiE9PXRbMF0udHlwZSYmXCJib29sXCIhPT10WzBdLnR5cGUpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpbnB1dCB0eXBlLlwiKX19LDM5MzM6KHQsZSxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUucGFyc2VTcXVlZXplQXR0cmlidXRlcz1lLnNxdWVlemVWMTM9ZS5zcXVlZXplPXZvaWQgMDtjb25zdCByPW4oMjUxNyk7ZS5zcXVlZXplPSh0LGUsbik9PntpKGUpO2NvbnN0IG89ci5TaGFwZVV0aWwuc3F1ZWV6ZVNoYXBlKGVbMF0uZGltcyxuKTtyZXR1cm5bdC5yZXNoYXBlVW5wYWNrZWQoZVswXSxvKV19LGUuc3F1ZWV6ZVYxMz0odCxuKT0+KG8obiksKDAsZS5zcXVlZXplKSh0LFtuWzBdXSxBcnJheS5mcm9tKG5bMV0uaW50ZWdlckRhdGEpKSksZS5wYXJzZVNxdWVlemVBdHRyaWJ1dGVzPXQ9PnQuYXR0cmlidXRlcy5nZXRJbnRzKFwiYXhlc1wiKTtjb25zdCBpPXQ9PntpZighdHx8MSE9PXQubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIlNxdWVlemUgcmVxdWlyZXMgMSBpbnB1dC5cIik7aWYoXCJzdHJpbmdcIj09PXRbMF0udHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGlucHV0IHRlbnNvciB0eXBlcy5cIil9LG89dD0+e2lmKCF0fHwyIT09dC5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiU3F1ZWV6ZSByZXF1aXJlcyAyIGlucHV0cy5cIik7aWYoXCJpbnQzMlwiIT09dFsxXS50eXBlKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW5wdXQgdHlwZS5cIil9fSw2NTU4Oih0LGUsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLnN1bT12b2lkIDA7Y29uc3Qgcj1uKDUwNjApLGk9bigyMDM5KTtlLnN1bT0odCxlKT0+e2EoZSk7Y29uc3Qgbj17bmFtZTpcIlN1bVwiLGlucHV0TmFtZXM6ZS5tYXAoKCh0LGUpPT5gWCR7ZX1gKSksaW5wdXRUeXBlczpuZXcgQXJyYXkoZS5sZW5ndGgpLmZpbGwoaS5UZXh0dXJlVHlwZS51bnBhY2tlZCl9O3JldHVyblt0LnJ1bihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sbikse2dldDooKT0+byh0LGUsbil9KSxlKV19O2NvbnN0IG89KHQsZSxuKT0+e2NvbnN0IG89KDAsci5nZXRHbHNsKSh0LnNlc3Npb24uYmFja2VuZC5nbENvbnRleHQudmVyc2lvbiksYT1lWzBdLmRpbXMuc2xpY2UoKSxzPWUubWFwKCgodCxlKT0+YCR7by50ZXh0dXJlMkR9KFgke2V9LFRleENvb3JkcylgKSkuam9pbihcIiArIFwiKSx1PWBcXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICB2ZWM0IHJlc3VsdCA9ICR7c307XFxuICAgICAgICAke28ub3V0cHV0fSA9IHJlc3VsdDtcXG4gICAgICB9XFxuICAgIGA7cmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxuKSx7b3V0cHV0OntkaW1zOmEsdHlwZTplWzBdLnR5cGUsdGV4dHVyZVR5cGU6aS5UZXh0dXJlVHlwZS51bnBhY2tlZH0saGFzTWFpbjohMCxzaGFkZXJTb3VyY2U6dX0pfSxhPXQ9PntpZighdHx8MD09PXQubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIlN1bSByZXF1aXJlcyBpbnB1dHMuXCIpO2NvbnN0IGU9dFswXS5kaW1zLmxlbmd0aDtmb3IobGV0IG49MTtuPHQubGVuZ3RoO24rKyl7aWYoZSE9PXRbbl0uZGltcy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiSW5wdXQgc2hhcGVzIGFyZSBtaXNtYXRjaGVkLlwiKTtmb3IobGV0IHI9MDtyPGU7cisrKWlmKHRbMF0uZGltc1tyXSE9PXRbbl0uZGltc1tyXSl0aHJvdyBuZXcgRXJyb3IoXCJJbnB1dCBzaGFwZXMgYXJlIG5vdCBtYXRjaGVkLlwiKX1pZihcImZsb2F0MzJcIiE9PXRbMF0udHlwZSYmXCJmbG9hdDY0XCIhPT10WzBdLnR5cGUpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpbnB1dCB0eXBlLlwiKTtmb3IobGV0IGU9MTtlPHQubGVuZ3RoO2UrKylpZih0WzBdLnR5cGUhPT10W2VdLnR5cGUpdGhyb3cgbmV3IEVycm9yKFwiSW5wdXQgdHlwZXMgYXJlIG5vdCBtYXRjaGVkLlwiKX19LDU3MjM6KHQsZSxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUudGlsZT12b2lkIDA7Y29uc3Qgcj1uKDc4MiksaT1uKDIwMzkpO2UudGlsZT0odCxlKT0+e2EoZSk7Y29uc3Qgbj17bmFtZTpcIlRpbGVcIixpbnB1dE5hbWVzOltcIkFcIl0saW5wdXRUeXBlczpbaS5UZXh0dXJlVHlwZS51bnBhY2tlZF19O3JldHVyblt0LnJ1bihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sbikse2dldDooKT0+byh0LGUsbil9KSxlKV19O2NvbnN0IG89KHQsZSxuKT0+e2NvbnN0IHI9ZVswXS5kaW1zLnNsaWNlKCksbz1uZXcgQXJyYXkoci5sZW5ndGgpLGE9W107Zm9yKGxldCB0PTA7dDxyLmxlbmd0aDt0Kyspb1t0XT1yW3RdKmVbMV0ubnVtYmVyRGF0YVt0XSxhLnB1c2goYGlucHV0SWR4WyR7dH1dID0gaW50KG1vZChmbG9hdChvdXRwdXRJZHhbJHt0fV0pLCAke3JbdF19LikpO2ApO2NvbnN0IHM9by5sZW5ndGgsdT1gXFxuICAgICAgZmxvYXQgcHJvY2VzcyhpbnQgb3V0cHV0SWR4WyR7c31dKSB7XFxuICAgICAgICBpbnQgaW5wdXRJZHhbJHtzfV07XFxuICAgICAgICAke2Euam9pbihcIlxcblwiKX1cXG4gICAgICAgIHJldHVybiBfQShpbnB1dElkeCk7XFxuICAgICAgfVxcbiAgICBgO3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sbikse291dHB1dDp7ZGltczpvLHR5cGU6ZVswXS50eXBlLHRleHR1cmVUeXBlOmkuVGV4dHVyZVR5cGUudW5wYWNrZWR9LHNoYWRlclNvdXJjZTp1fSl9LGE9dD0+e2lmKCF0fHwyIT09dC5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiVGlsZSByZXF1aXJlcyAyIGlucHV0LlwiKTtpZigxIT09dFsxXS5kaW1zLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJUaGUgc2Vjb25kIGlucHV0IHNoYXBlIG11c3QgMSBkaW1lbnNpb24uXCIpO2lmKHRbMV0uZGltc1swXSE9PXRbMF0uZGltcy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpbnB1dCBzaGFwZS5cIik7aWYoLTE9PT1yLk5VTUJFUl9UWVBFUy5pbmRleE9mKHRbMF0udHlwZSkpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpbnB1dCB0eXBlLlwiKTtpZihcImludDMyXCIhPT10WzFdLnR5cGUmJlwiaW50MTZcIiE9PXRbMV0udHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHJlcGVhdCB0eXBlLlwiKX19LDM3Mzg6KHQsZSxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUucGFyc2VUcmFuc3Bvc2VBdHRyaWJ1dGVzPWUudHJhbnNwb3NlPXZvaWQgMDtjb25zdCByPW4oMjQ2KSxpPW4oMjUxNyksbz1uKDIwMzkpLGE9e25hbWU6XCJUcmFuc3Bvc2VcIixpbnB1dE5hbWVzOltcIkFcIl0saW5wdXRUeXBlczpbby5UZXh0dXJlVHlwZS51bnBhY2tlZF19O2UudHJhbnNwb3NlPSh0LGUsbik9PihwKGUpLFt0LnJ1bihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sYSkse2NhY2hlSGludDpuLmNhY2hlS2V5LGdldDooKT0+cyh0LGVbMF0sbi5wZXJtKX0pLGUpXSksZS5wYXJzZVRyYW5zcG9zZUF0dHJpYnV0ZXM9dD0+KDAsci5jcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkpKHtwZXJtOnQuYXR0cmlidXRlcy5nZXRJbnRzKFwicGVybVwiLFtdKX0pO2NvbnN0IHM9KHQsZSxuKT0+e2NvbnN0IHI9ZS5kaW1zO249dShyLG4pO2NvbnN0IGk9YyhyLG4pLHM9ci5sZW5ndGgscD1gXFxuICAgICAgJHtsKFwicGVybVwiLG4scyl9XFxuICAgICAgZmxvYXQgcHJvY2VzcyhpbnQgaW5kaWNlc1ske3N9XSkge1xcbiAgICAgICAgaW50IGFbJHtzfV07XFxuICAgICAgICBwZXJtKGEsIGluZGljZXMpO1xcbiAgICAgICAgcmV0dXJuIF9BKGEpO1xcbiAgICAgIH1gO3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sYSkse291dHB1dDp7ZGltczppLHR5cGU6ZS50eXBlLHRleHR1cmVUeXBlOm8uVGV4dHVyZVR5cGUudW5wYWNrZWR9LHNoYWRlclNvdXJjZTpwfSl9LHU9KHQsZSk9PihlJiZlLmxlbmd0aCE9PXQubGVuZ3RoJiYoZT1bLi4udC5rZXlzKCldLnJldmVyc2UoKSksZSksYz0odCxlKT0+KGU9dSh0LGUpLGkuU2hhcGVVdGlsLnNvcnRCYXNlZE9uUGVybSh0LGUpKSxsPSh0LGUsbik9Pntjb25zdCByPVtdO3IucHVzaChgdm9pZCAke3R9KG91dCBpbnQgYVske259XSwgaW50IHNyY1ske259XSkge2ApO2ZvcihsZXQgdD0wO3Q8bjsrK3Qpci5wdXNoKGBcXHRhWyR7ZVt0XX1dPXNyY1ske3R9XTtgKTtyZXR1cm4gci5wdXNoKFwiXFx0fVwiKSxyLmpvaW4oXCJcXG5cIil9LHA9dD0+e2lmKCF0fHwxIT09dC5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiVHJhbnNwb3NlIHJlcXVpcmVzIDEgaW5wdXQuXCIpO2lmKFwiZmxvYXQzMlwiIT09dFswXS50eXBlJiZcImZsb2F0NjRcIiE9PXRbMF0udHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJpbnB1dCBzaG91bGQgYmUgZmxvYXQgdGVuc29yXCIpfX0sODcxMDoodCxlLG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5lbmNvZGVBc1VpbnQ4PXZvaWQgMDtjb25zdCByPW4oNTA2MCksaT1uKDIwMzkpO2UuZW5jb2RlQXNVaW50OD0odCxlKT0+e2NvbnN0IG49ZS5zaGFwZSxvPSgwLHIuZ2V0R2xzbCkodC5zZXNzaW9uLmJhY2tlbmQuZ2xDb250ZXh0LnZlcnNpb24pLGE9YFxcbiAgICBjb25zdCBmbG9hdCBGTE9BVF9NQVggPSAxLjcwMTQxMTg0ZTM4O1xcbiAgICBjb25zdCBmbG9hdCBGTE9BVF9NSU4gPSAxLjE3NTQ5NDM1ZS0zODtcXG5cXG4gICAgYm9vbCBpc05hTihmbG9hdCB2YWwpIHtcXG4gICAgICByZXR1cm4gKHZhbCA8IDEuMCB8fCAwLjAgPCB2YWwgfHwgdmFsID09IDAuMCkgPyBmYWxzZSA6IHRydWU7XFxuICAgIH1cXG5cXG4gICAgaGlnaHAgdmVjNCBlbmNvZGVBc1VpbnQ4KGhpZ2hwIGZsb2F0IHYpIHtcXG4gICAgICBpZiAoaXNOYU4odikpIHtcXG4gICAgICAgIHJldHVybiB2ZWM0KDI1NSwgMjU1LCAyNTUsIDI1NSk7XFxuICAgICAgfVxcblxcbiAgICAgIGhpZ2hwIGZsb2F0IGF2ID0gYWJzKHYpO1xcblxcbiAgICAgIGlmKGF2IDwgRkxPQVRfTUlOKSB7XFxuICAgICAgICByZXR1cm4gdmVjNCgwLjAsIDAuMCwgMC4wLCAwLjApO1xcbiAgICAgIH0gZWxzZSBpZih2ID4gRkxPQVRfTUFYKSB7XFxuICAgICAgICByZXR1cm4gdmVjNCgwLjAsIDAuMCwgMTI4LjAsIDEyNy4wKSAvIDI1NS4wO1xcbiAgICAgIH0gZWxzZSBpZih2IDwgLUZMT0FUX01BWCkge1xcbiAgICAgICAgcmV0dXJuIHZlYzQoMC4wLCAwLjAsICAxMjguMCwgMjU1LjApIC8gMjU1LjA7XFxuICAgICAgfVxcblxcbiAgICAgIGhpZ2hwIHZlYzQgYyA9IHZlYzQoMCwwLDAsMCk7XFxuXFxuICAgICAgaGlnaHAgZmxvYXQgZSA9IGZsb29yKGxvZzIoYXYpKTtcXG4gICAgICBoaWdocCBmbG9hdCBtID0gZXhwMihmcmFjdChsb2cyKGF2KSkpIC0gMS4wO1xcblxcbiAgICAgIGNbMl0gPSBmbG9vcigxMjguMCAqIG0pO1xcbiAgICAgIG0gLT0gY1syXSAvIDEyOC4wO1xcbiAgICAgIGNbMV0gPSBmbG9vcigzMjc2OC4wICogbSk7XFxuICAgICAgbSAtPSBjWzFdIC8gMzI3NjguMDtcXG4gICAgICBjWzBdID0gZmxvb3IoODM4ODYwOC4wICogbSk7XFxuXFxuICAgICAgaGlnaHAgZmxvYXQgZWJpYXMgPSBlICsgMTI3LjA7XFxuICAgICAgY1szXSA9IGZsb29yKGViaWFzIC8gMi4wKTtcXG4gICAgICBlYmlhcyAtPSBjWzNdICogMi4wO1xcbiAgICAgIGNbMl0gKz0gZmxvb3IoZWJpYXMpICogMTI4LjA7XFxuXFxuICAgICAgY1szXSArPSAxMjguMCAqIHN0ZXAoMC4wLCAtdik7XFxuXFxuICAgICAgcmV0dXJuIGMgLyAyNTUuMDtcXG4gICAgfVxcblxcbiAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgZmxvYXQgdmFsdWUgPSAke28udGV4dHVyZTJEfShYLFRleENvb3JkcykucjtcXG4gICAgICAke28ub3V0cHV0fSA9IGVuY29kZUFzVWludDgodmFsdWUpO1xcbiAgICB9YCxzPXtuYW1lOlwiVWludDhFbmNvZGVcIixpbnB1dFR5cGVzOltpLlRleHR1cmVUeXBlLnVucGFja2VkXSxpbnB1dE5hbWVzOltcIlhcIl0sb3V0cHV0OntkaW1zOm4sdHlwZTplLnRlbnNvci50eXBlLHRleHR1cmVUeXBlOmkuVGV4dHVyZVR5cGUuZG93bmxvYWRVaW50OEFzRmxvYXR9LHNoYWRlclNvdXJjZTphLGhhc01haW46ITB9O3JldHVybiB0LmV4ZWN1dGVQcm9ncmFtKHMsW2UudGVuc29yXSl9fSw0OTA5Oih0LGUsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLnRhbmg9ZS50YW49ZS5zcXJ0PWUuc2luPWUuc2lnbW9pZD1lLnJlbHU9ZS5ub3Q9ZS5uZWc9ZS5sb2c9ZS5wYXJzZUxlYWt5UmVsdUF0dHJpYnV0ZXM9ZS5sZWFreVJlbHU9ZS5pZGVudGl0eT1lLmZsb29yPWUuZXhwPWUucGFyc2VFbHVBdHRyaWJ1dGVzPWUuZWx1PWUuY29zPWUuY2VpbD1lLmNsaXBWMTE9ZS5wYXJzZUNsaXBBdHRyaWJ1dGVzPWUuY2xpcD1lLmF0YW49ZS5hc2luPWUuYWNvcz1lLmFicz1lLmdsc2xUYW5oPWUuZ2xzbFRhbj1lLmdsc2xTcXJ0PWUuZ2xzbFNpZ21vaWQ9ZS5nbHNsUmVsdT1lLmdsc2xTaW49ZS5nbHNsTm90PWUuZ2xzbE5lZz1lLmdsc2xMb2c9ZS5nbHNsTGVha3lSZWx1PWUuZ2xzbElkZW50aXR5PWUuZ2xzbENsaXA9ZS5nbHNsRmxvb3I9ZS5nbHNsRXhwPWUuZ2xzbEVsdT1lLmdsc2xDb3M9ZS5nbHNsQ2VpbD1lLmdsc2xBdGFuPWUuZ2xzbEFzaW49ZS5nbHNsQWNvcz1lLmdsc2xBYnM9dm9pZCAwO2NvbnN0IHI9bigyNDYpLGk9bigyNTE3KSxvPW4oODUyMCksYT1uKDUwNjApLHM9bigyMDM5KTtmdW5jdGlvbiB1KCl7cmV0dXJuIFAoXCJhYnNcIil9ZnVuY3Rpb24gYygpe3JldHVybiBQKFwiYWNvc1wiKX1mdW5jdGlvbiBsKCl7cmV0dXJuIFAoXCJhc2luXCIpfWZ1bmN0aW9uIHAoKXtyZXR1cm4gUChcImF0YW5cIil9ZnVuY3Rpb24gZigpe3JldHVybiBQKFwiY2VpbFwiKX1mdW5jdGlvbiBkKCl7cmV0dXJuIFAoXCJjb3NcIil9ZnVuY3Rpb24gaCh0KXtjb25zdCBlPVwiZWx1XCI7cmV0dXJue2JvZHk6YFxcbiAgY29uc3QgZmxvYXQgYWxwaGEgPSBmbG9hdCgke3R9KTtcXG5cXG4gIGZsb2F0ICR7ZX1fKGZsb2F0IGEpIHtcXG4gICAgcmV0dXJuIGEgPj0gMC4wID8gYTogKGV4cChhKSAtIDEuMCkgKiBhbHBoYTtcXG4gIH1cXG4gIHZlYzQgJHtlfV8odmVjNCB2KSB7XFxuICAgIHJldHVybiB2ZWM0KCR7ZX1fKHYueCksICR7ZX1fKHYueSksICR7ZX1fKHYueiksICR7ZX1fKHYudykpO1xcbiAgfVxcbiAgYCxuYW1lOmUsdHlwZTpvLkZ1bmN0aW9uVHlwZS5WYWx1ZUJhc2VkfX1mdW5jdGlvbiBnKCl7cmV0dXJuIFAoXCJleHBcIil9ZnVuY3Rpb24gYigpe3JldHVybiBQKFwiZmxvb3JcIil9ZnVuY3Rpb24gbSh0LGUpe2NvbnN0IG49XCJjbGlwXCI7cmV0dXJue2JvZHk6YFxcbiAgY29uc3QgZmxvYXQgbWluID0gZmxvYXQoJHt0fSk7XFxuICBjb25zdCBmbG9hdCBtYXggPSBmbG9hdCgke2V9KTtcXG5cXG4gIGZsb2F0ICR7bn1fKGZsb2F0IGEpIHtcXG4gICAgcmV0dXJuIGNsYW1wKGEsIG1pbiwgbWF4KTtcXG4gIH1cXG4gIHZlYzQgJHtufV8odmVjNCB2KSB7XFxuICAgIHJldHVybiBjbGFtcCh2LCBtaW4sIG1heCk7XFxuICB9XFxuICBgLG5hbWU6bix0eXBlOm8uRnVuY3Rpb25UeXBlLlZhbHVlQmFzZWR9fWZ1bmN0aW9uIHkoKXtjb25zdCB0PVwiaW5kZW50aXR5XCI7cmV0dXJue2JvZHk6YFxcbiAgZmxvYXQgJHt0fV8oZmxvYXQgYSkge1xcbiAgICByZXR1cm4gYTtcXG4gIH1cXG4gIHZlYzQgJHt0fV8odmVjNCB2KSB7XFxuICAgIHJldHVybiB2O1xcbiAgfVxcbiAgYCxuYW1lOnQsdHlwZTpvLkZ1bmN0aW9uVHlwZS5WYWx1ZUJhc2VkfX1mdW5jdGlvbiBfKHQpe2NvbnN0IGU9XCJsZWFreVJlbHVcIjtyZXR1cm57Ym9keTpgXFxuICBjb25zdCBmbG9hdCBhbHBoYSA9IGZsb2F0KCR7dH0pO1xcblxcbiAgZmxvYXQgJHtlfV8oZmxvYXQgYSkge1xcbiAgICByZXR1cm4gYSA8IDAuMCA/IGEgKiBhbHBoYSA6IGE7XFxuICB9XFxuICB2ZWM0ICR7ZX1fKHZlYzQgdikge1xcbiAgICByZXR1cm4gdmVjNCgke2V9Xyh2LngpLCAke2V9Xyh2LnkpLCAke2V9Xyh2LnopLCAke2V9Xyh2LncpKTtcXG4gIH1cXG4gIGAsbmFtZTplLHR5cGU6by5GdW5jdGlvblR5cGUuVmFsdWVCYXNlZH19ZnVuY3Rpb24gdigpe3JldHVybiBQKFwibG9nXCIpfWZ1bmN0aW9uIHcoKXtjb25zdCB0PVwibmVnXCI7cmV0dXJue2JvZHk6YFxcbiAgZmxvYXQgJHt0fV8oZmxvYXQgYSkge1xcbiAgICByZXR1cm4gLWE7XFxuICB9XFxuICB2ZWM0ICR7dH1fKHZlYzQgdikge1xcbiAgICByZXR1cm4gLXY7XFxuICB9XFxuICBgLG5hbWU6dCx0eXBlOm8uRnVuY3Rpb25UeXBlLlZhbHVlQmFzZWR9fWZ1bmN0aW9uIHgoKXtjb25zdCB0PVwibm90XCI7cmV0dXJue2JvZHk6YFxcbiAgZmxvYXQgJHt0fV8oZmxvYXQgYSkge1xcbiAgICByZXR1cm4gZmxvYXQoICEgYm9vbChhKSApO1xcbiAgfVxcbiAgYm9vbCAke3R9Xyhib29sIGEpIHtcXG4gICAgcmV0dXJuICFhO1xcbiAgfVxcbiAgdmVjNCAke3R9Xyh2ZWM0IHYpIHtcXG4gICAgcmV0dXJuIHZlYzQoIWJvb2wodi54KSwgIWJvb2wodi55KSwgIWJvb2wodi56KSwgIWJvb2wodi53KSk7XFxuICB9XFxuICBidmVjNCAke3R9XyhidmVjNCB2KSB7XFxuICAgIHJldHVybiBidmVjNCghdi54LCAhdi55LCAhdi56LCAhdi53KTtcXG4gIH1cXG4gIGAsbmFtZTp0LHR5cGU6by5GdW5jdGlvblR5cGUuVmFsdWVCYXNlZH19ZnVuY3Rpb24gVCgpe3JldHVybiBQKFwic2luXCIpfWZ1bmN0aW9uIFMoKXtjb25zdCB0PVwicmVsdVwiO3JldHVybntib2R5OmBcXG4gIGZsb2F0ICR7dH1fKGZsb2F0IGEpIHtcXG4gICAgcmV0dXJuIG1heCggYSwgMC4wICk7XFxuICB9XFxuICB2ZWM0ICR7dH1fKHZlYzQgdikge1xcbiAgICByZXR1cm4gbWF4KCB2LCAwLjAgKTtcXG4gIH1cXG4gIGAsbmFtZTp0LHR5cGU6by5GdW5jdGlvblR5cGUuVmFsdWVCYXNlZH19ZnVuY3Rpb24gTygpe2NvbnN0IHQ9XCJzaWdtb2lkXCI7cmV0dXJue2JvZHk6YFxcbiAgZmxvYXQgJHt0fV8oZmxvYXQgYSkge1xcbiAgICByZXR1cm4gMS4wIC8gKDEuMCArIGV4cCgtYSkpO1xcbiAgfVxcbiAgdmVjNCAke3R9Xyh2ZWM0IHYpIHtcXG4gICAgcmV0dXJuIDEuMCAvICgxLjAgKyBleHAoLXYpKTtcXG4gIH1cXG4gIGAsbmFtZTp0LHR5cGU6by5GdW5jdGlvblR5cGUuVmFsdWVCYXNlZH19ZnVuY3Rpb24gQSgpe3JldHVybiBQKFwic3FydFwiKX1mdW5jdGlvbiBFKCl7cmV0dXJuIFAoXCJ0YW5cIil9ZnVuY3Rpb24gSSgpe2NvbnN0IHQ9XCJ0YW5oXCI7cmV0dXJue2JvZHk6YFxcbiAgZmxvYXQgJHt0fV8oZmxvYXQgYSkge1xcbiAgICBhID0gY2xhbXAoYSwgLTEwLiwgMTAuKTtcXG4gICAgYSA9IGV4cCgyLiphKTtcXG4gICAgcmV0dXJuIChhIC0gMS4pIC8gKGEgKyAxLik7XFxuICB9XFxuICB2ZWM0ICR7dH1fKHZlYzQgdikge1xcbiAgICB2ID0gY2xhbXAodiwgLTEwLiwgMTAuKTtcXG4gICAgdiA9IGV4cCgyLip2KTtcXG4gICAgcmV0dXJuICh2IC0gMS4pIC8gKHYgKyAxLik7XFxuICB9XFxuICBgLG5hbWU6dCx0eXBlOm8uRnVuY3Rpb25UeXBlLlZhbHVlQmFzZWR9fWZ1bmN0aW9uIFAodCl7cmV0dXJue2JvZHk6YFxcbiAgZmxvYXQgJHt0fV8oZmxvYXQgYSkge1xcbiAgICByZXR1cm4gJHt0fShhKTtcXG4gIH1cXG4gIHZlYzQgJHt0fV8odmVjNCB2KSB7XFxuICAgIHJldHVybiAke3R9KHYpO1xcbiAgfVxcbiAgYCxuYW1lOnQsdHlwZTpvLkZ1bmN0aW9uVHlwZS5WYWx1ZUJhc2VkfX1lLmdsc2xBYnM9dSxlLmdsc2xBY29zPWMsZS5nbHNsQXNpbj1sLGUuZ2xzbEF0YW49cCxlLmdsc2xDZWlsPWYsZS5nbHNsQ29zPWQsZS5nbHNsRWx1PWgsZS5nbHNsRXhwPWcsZS5nbHNsRmxvb3I9YixlLmdsc2xDbGlwPW0sZS5nbHNsSWRlbnRpdHk9eSxlLmdsc2xMZWFreVJlbHU9XyxlLmdsc2xMb2c9dixlLmdsc2xOZWc9dyxlLmdsc2xOb3Q9eCxlLmdsc2xTaW49VCxlLmdsc2xSZWx1PVMsZS5nbHNsU2lnbW9pZD1PLGUuZ2xzbFNxcnQ9QSxlLmdsc2xUYW49RSxlLmdsc2xUYW5oPUk7Y29uc3QgRD0odCxlLG4scik9Pntjb25zdCBpPXQuc2Vzc2lvbi5wYWNrP3MuVGV4dHVyZVR5cGUucGFja2VkOnMuVGV4dHVyZVR5cGUudW5wYWNrZWQsbz17bmFtZTpuLm5hbWUsaW5wdXRUeXBlczpbaV0saW5wdXROYW1lczpbXCJBXCJdLGNhY2hlSGludDpyfTtyZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LG8pLHtnZXQ6KCk9PigodCxlLG4scik9Pntjb25zdCBpPXQuc2Vzc2lvbi5wYWNrP3MuVGV4dHVyZVR5cGUucGFja2VkOnMuVGV4dHVyZVR5cGUudW5wYWNrZWQsbz0oMCxhLmdldEdsc2wpKHQuc2Vzc2lvbi5iYWNrZW5kLmdsQ29udGV4dC52ZXJzaW9uKTtyZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LGUpLHtvdXRwdXQ6e2RpbXM6bi5kaW1zLHR5cGU6bi50eXBlLHRleHR1cmVUeXBlOml9LHNoYWRlclNvdXJjZTpgXFxuICAgICAke3IuYm9keX1cXG4gICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgdmVjNCB2ID0gJHtvLnRleHR1cmUyRH0oQSwgVGV4Q29vcmRzKTtcXG4gICAgICAgdiA9ICR7ci5uYW1lfV8odik7XFxuICAgICAgICR7by5vdXRwdXR9ID0gdjtcXG4gICAgIH1cXG4gICAgIGAsaGFzTWFpbjohMH0pfSkodCxvLGUsbil9KX07ZS5hYnM9KHQsZSk9Plt0LnJ1bihEKHQsZVswXSx1KCkpLGUpXSxlLmFjb3M9KHQsZSk9Plt0LnJ1bihEKHQsZVswXSxjKCkpLGUpXSxlLmFzaW49KHQsZSk9Plt0LnJ1bihEKHQsZVswXSxsKCkpLGUpXSxlLmF0YW49KHQsZSk9Plt0LnJ1bihEKHQsZVswXSxwKCkpLGUpXSxlLmNsaXA9KHQsZSxuKT0+W3QucnVuKEQodCxlWzBdLG0obi5taW4sbi5tYXgpLG4uY2FjaGVLZXkpLGUpXSxlLnBhcnNlQ2xpcEF0dHJpYnV0ZXM9dD0+KDAsci5jcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkpKHttaW46dC5hdHRyaWJ1dGVzLmdldEZsb2F0KFwibWluXCIsaS5NSU5fQ0xJUCksbWF4OnQuYXR0cmlidXRlcy5nZXRGbG9hdChcIm1heFwiLGkuTUFYX0NMSVApfSksZS5jbGlwVjExPSh0LG4pPT57Y29uc3Qgcj0kKHQsbik7cmV0dXJuKDAsZS5jbGlwKSh0LFtuWzBdXSxyKX07Y29uc3QgJD0odCxlKT0+e2lmKGUubGVuZ3RoPj0zJiYoIXQuc2Vzc2lvbi5pc0luaXRpYWxpemVyKGVbMV0uZGF0YUlkKXx8IXQuc2Vzc2lvbi5pc0luaXRpYWxpemVyKGVbMl0uZGF0YUlkKSkpdGhyb3cgbmV3IEVycm9yKFwiZHluYW1pYyBjbGlwIGF0dHJpYnV0ZXMgYXJlIG5vdCBhbGxvd2VkXCIpO2NvbnN0IG49ZS5sZW5ndGg+PTM/ZVsxXS5udW1iZXJEYXRhWzBdOmkuTUlOX0NMSVAsbz1lLmxlbmd0aD49Mz9lWzJdLm51bWJlckRhdGFbMF06aS5NQVhfQ0xJUDtyZXR1cm4oMCxyLmNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSkoe21pbjpuLG1heDpvfSl9O2UuY2VpbD0odCxlKT0+W3QucnVuKEQodCxlWzBdLGYoKSksZSldLGUuY29zPSh0LGUpPT5bdC5ydW4oRCh0LGVbMF0sZCgpKSxlKV0sZS5lbHU9KHQsZSxuKT0+W3QucnVuKEQodCxlWzBdLGgobi5hbHBoYSksbi5jYWNoZUtleSksZSldLGUucGFyc2VFbHVBdHRyaWJ1dGVzPXQ9PigwLHIuY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KSh7YWxwaGE6dC5hdHRyaWJ1dGVzLmdldEZsb2F0KFwiYWxwaGFcIiwxKX0pLGUuZXhwPSh0LGUpPT5bdC5ydW4oRCh0LGVbMF0sZygpKSxlKV0sZS5mbG9vcj0odCxlKT0+W3QucnVuKEQodCxlWzBdLGIoKSksZSldLGUuaWRlbnRpdHk9KHQsZSk9Plt0LnJ1bihEKHQsZVswXSx5KCkpLGUpXSxlLmxlYWt5UmVsdT0odCxlLG4pPT5bdC5ydW4oRCh0LGVbMF0sXyhuLmFscGhhKSxuLmNhY2hlS2V5KSxlKV0sZS5wYXJzZUxlYWt5UmVsdUF0dHJpYnV0ZXM9dD0+KDAsci5jcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkpKHthbHBoYTp0LmF0dHJpYnV0ZXMuZ2V0RmxvYXQoXCJhbHBoYVwiLC4wMSl9KSxlLmxvZz0odCxlKT0+W3QucnVuKEQodCxlWzBdLHYoKSksZSldLGUubmVnPSh0LGUpPT5bdC5ydW4oRCh0LGVbMF0sdygpKSxlKV0sZS5ub3Q9KHQsZSk9Plt0LnJ1bihEKHQsZVswXSx4KCkpLGUpXSxlLnJlbHU9KHQsZSk9Plt0LnJ1bihEKHQsZVswXSxTKCkpLGUpXSxlLnNpZ21vaWQ9KHQsZSk9Plt0LnJ1bihEKHQsZVswXSxPKCkpLGUpXSxlLnNpbj0odCxlKT0+W3QucnVuKEQodCxlWzBdLFQoKSksZSldLGUuc3FydD0odCxlKT0+W3QucnVuKEQodCxlWzBdLEEoKSksZSldLGUudGFuPSh0LGUpPT5bdC5ydW4oRCh0LGVbMF0sRSgpKSxlKV0sZS50YW5oPSh0LGUpPT5bdC5ydW4oRCh0LGVbMF0sSSgpKSxlKV19LDU2MTE6KHQsZSxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUuY3JlYXRlVW5wYWNrUHJvZ3JhbUluZm9Mb2FkZXI9ZS5jcmVhdGVVbnBhY2tQcm9ncmFtSW5mbz12b2lkIDA7Y29uc3Qgcj1uKDUwNjApLGk9bigyMDM5KSxvPW4oOTM5MCksYT1uKDI4MjcpLHM9e25hbWU6XCJ1bnBhY2tcIixpbnB1dE5hbWVzOltcIkFcIl0saW5wdXRUeXBlczpbaS5UZXh0dXJlVHlwZS5wYWNrZWRdfTtlLmNyZWF0ZVVucGFja1Byb2dyYW1JbmZvPSh0LGUpPT57Y29uc3Qgbj1lLmRpbXMubGVuZ3RoLHU9KDAsYS5nZXRDaGFubmVscykoXCJyY1wiLG4pLGM9dS5zbGljZSgtMiksbD0oMCxvLmdldENvb3Jkc0RhdGFUeXBlKShuKSxwPSgwLGEudW5wYWNrRnJvbUNoYW5uZWwpKCksZj0wPT09ZS5kaW1zLmxlbmd0aD9cIlwiOmZ1bmN0aW9uKHQsZSl7aWYoMT09PXQpcmV0dXJuXCJyY1wiO2xldCBuPVwiXCI7Zm9yKGxldCByPTA7cjx0O3IrKyluKz1lW3JdLHI8dC0xJiYobis9XCIsXCIpO3JldHVybiBufShuLHUpLGQ9bjw9MT9cInJjXCI6YHZlYzIoJHtjLmpvaW4oXCIsXCIpfSlgLGg9YFxcbiAgICAke3B9XFxuICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAke2x9IHJjID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuXFxuICAgICAgIC8vIFNhbXBsZSB0aGUgdGV4dHVyZSB3aXRoIHRoZSBjb29yZHMgdG8gZ2V0IHRoZSByZ2JhIGNoYW5uZWwgdmFsdWUuXFxuICAgICAgIHZlYzQgcGFja2VkSW5wdXQgPSBnZXRBKCR7Zn0pO1xcblxcbiAgICAgICAkeygwLHIuZ2V0R2xzbCkodC5zZXNzaW9uLmJhY2tlbmQuZ2xDb250ZXh0LnZlcnNpb24pLm91dHB1dH0gPSB2ZWM0KGdldENoYW5uZWwocGFja2VkSW5wdXQsICR7ZH0pLCAwLCAwLCAwKTtcXG4gICAgIH1cXG4gICBgO3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30scykse2hhc01haW46ITAsb3V0cHV0OntkaW1zOmUuZGltcyx0eXBlOmUudHlwZSx0ZXh0dXJlVHlwZTppLlRleHR1cmVUeXBlLnVucGFja2VkfSxzaGFkZXJTb3VyY2U6aH0pfSxlLmNyZWF0ZVVucGFja1Byb2dyYW1JbmZvTG9hZGVyPSh0LG4pPT5PYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30scykse2dldDooKT0+KDAsZS5jcmVhdGVVbnBhY2tQcm9ncmFtSW5mbykodCxuKX0pfSw4NDI4Oih0LGUsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLnBhcnNlVW5zcXVlZXplQXR0cmlidXRlcz1lLnVuc3F1ZWV6ZVYxMz1lLnVuc3F1ZWV6ZT12b2lkIDA7Y29uc3Qgcj1uKDI1MTcpO2UudW5zcXVlZXplPSh0LGUsbik9PntpKGUpO2NvbnN0IG89ci5TaGFwZVV0aWwudW5zcXVlZXplU2hhcGUoZVswXS5kaW1zLG4pO3JldHVyblt0LnJlc2hhcGVVbnBhY2tlZChlWzBdLG8pXX0sZS51bnNxdWVlemVWMTM9KHQsbik9PihvKG4pLCgwLGUudW5zcXVlZXplKSh0LFtuWzBdXSxBcnJheS5mcm9tKG5bMV0uaW50ZWdlckRhdGEpKSksZS5wYXJzZVVuc3F1ZWV6ZUF0dHJpYnV0ZXM9dD0+dC5hdHRyaWJ1dGVzLmdldEludHMoXCJheGVzXCIpO2NvbnN0IGk9dD0+e2lmKCF0fHwxIT09dC5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiVW5zcXVlZXplIHJlcXVpcmVzIDEgaW5wdXQuXCIpO2lmKFwic3RyaW5nXCI9PT10WzBdLnR5cGUpdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBpbnB1dCB0ZW5zb3IgdHlwZXMuXCIpfSxvPXQ9PntpZighdHx8MiE9PXQubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIlVuc3F1ZWV6ZSByZXF1aXJlcyAyIGlucHV0cy5cIik7aWYoXCJpbnQzMlwiIT09dFsxXS50eXBlKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW5wdXQgdHlwZS5cIil9fSw5NzkzOih0LGUsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLnNjYWxlc1ZhbGlkYXRpb249ZS52YWxpZGF0ZUlucHV0cz1lLnBhcnNlVXBzYW1wbGVBdHRyaWJ1dGVzPWUucGFyc2VVcHNhbXBsZUF0dHJpYnV0ZXNWOT1lLnBhcnNlVXBzYW1wbGVBdHRyaWJ1dGVzVjc9ZS51cHNhbXBsZT12b2lkIDA7Y29uc3Qgcj1uKDI0NiksaT1uKDUwNjApLG89bigyMDM5KSxhPXtuYW1lOlwiVXBzYW1wbGVcIixpbnB1dE5hbWVzOltcIlhcIl0saW5wdXRUeXBlczpbby5UZXh0dXJlVHlwZS51bnBhY2tlZF19O2UudXBzYW1wbGU9KHQsbixyKT0+KCgwLGUudmFsaWRhdGVJbnB1dHMpKG4sciksW3QucnVuKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxhKSx7Y2FjaGVIaW50OnIuY2FjaGVLZXksZ2V0OigpPT5zKHQsbixyKX0pLG4pXSksZS5wYXJzZVVwc2FtcGxlQXR0cmlidXRlc1Y3PXQ9PigwLGUucGFyc2VVcHNhbXBsZUF0dHJpYnV0ZXMpKHQsNyksZS5wYXJzZVVwc2FtcGxlQXR0cmlidXRlc1Y5PXQ9PigwLGUucGFyc2VVcHNhbXBsZUF0dHJpYnV0ZXMpKHQsOSksZS5wYXJzZVVwc2FtcGxlQXR0cmlidXRlcz0odCxuKT0+e2NvbnN0IGk9bj49MTAsbz10LmF0dHJpYnV0ZXMuZ2V0U3RyaW5nKFwibW9kZVwiLFwibmVhcmVzdFwiKTtpZihcIm5lYXJlc3RcIiE9PW8mJlwibGluZWFyXCIhPT1vJiYobjwxMXx8XCJjdWJpY1wiIT09bykpdGhyb3cgbmV3IEVycm9yKGB1bnJlY29nbml6ZWQgbW9kZTogJHtvfWApO2xldCBhPVtdO248OSYmKGE9dC5hdHRyaWJ1dGVzLmdldEZsb2F0cyhcInNjYWxlc1wiKSwoMCxlLnNjYWxlc1ZhbGlkYXRpb24pKGEsbyxpKSk7Y29uc3Qgcz10LmF0dHJpYnV0ZXMuZ2V0RmxvYXQoXCJleHRyYXBvbGF0aW9uX3ZhbHVlXCIsMCksdT1uPjEwP3QuYXR0cmlidXRlcy5nZXRTdHJpbmcoXCJjb29yZGluYXRlX3RyYW5zZm9ybWF0aW9uX21vZGVcIixcImhhbGZfcGl4ZWxcIik6XCJhc3ltbWV0cmljXCI7aWYoLTE9PT1bXCJhc3ltbWV0cmljXCIsXCJweXRvcmNoX2hhbGZfcGl4ZWxcIixcInRmX2hhbGZfcGl4ZWxfZm9yX25uXCIsXCJhbGlnbl9jb3JuZXJzXCIsXCJ0Zl9jcm9wX2FuZF9yZXNpemVcIixcImhhbGZfcGl4ZWxcIl0uaW5kZXhPZih1KSl0aHJvdyBuZXcgRXJyb3IoYGNvb3JkaW5hdGVfdHJhbnNmb3JtX21vZGUgJyR7dX0nIGlzIG5vdCBzdXBwb3J0ZWRgKTtjb25zdCBjPVwidGZfY3JvcF9hbmRfcmVzaXplXCI9PT11LGw9YyxwPVwibmVhcmVzdFwiPT09byYmbj49MTE/dC5hdHRyaWJ1dGVzLmdldFN0cmluZyhcIm5lYXJlc3RfbW9kZVwiLFwicm91bmRfcHJlZmVyX2Zsb29yXCIpOlwiXCI7aWYoLTE9PT1bXCJyb3VuZF9wcmVmZXJfZmxvb3JcIixcInJvdW5kX3ByZWZlcl9jZWlsXCIsXCJmbG9vclwiLFwiY2VpbFwiLFwiXCJdLmluZGV4T2YocCkpdGhyb3cgbmV3IEVycm9yKGBuZWFyZXN0X21vZGUgJyR7cH0nIGlzIG5vdCBzdXBwb3J0ZWRgKTtjb25zdCBmPXQuYXR0cmlidXRlcy5nZXRGbG9hdChcImN1YmljX2NvZWZmX2FcIiwtLjc1KSxkPTAhPT10LmF0dHJpYnV0ZXMuZ2V0SW50KFwiZXhjbHVkZV9vdXRzaWRlXCIsMCk7aWYoZCYmXCJjdWJpY1wiIT09byl0aHJvdyBuZXcgRXJyb3IoXCJleGNsdWRlX291dHNpZGUgY2FuIGJlIHNldCB0byAxIG9ubHkgd2hlbiBtb2RlIGlzIENVQklDLlwiKTtjb25zdCBoPW48MTF8fFwibmVhcmVzdFwiPT09byYmXCJhc3ltbWV0cmljXCI9PT11JiZcImZsb29yXCI9PT1wO2xldCBnPTAsYj0wLG09MDtyZXR1cm4gbj4xMD90LmlucHV0cy5sZW5ndGg+Mj8oZz0xLGI9MixtPTMpOihiPTEsbT0yKTo5PT09biYmKGI9MSksKDAsci5jcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkpKHtvcHNldDpuLGlzUmVzaXplOmksbW9kZTpvLHNjYWxlczphLGV4dHJhcG9sYXRpb25WYWx1ZTpzLGNvb3JkaW5hdGVUcmFuc2Zvcm1Nb2RlOnUsdXNlRXh0cmFwb2xhdGlvbjpsLG5lZWRSb2lJbnB1dDpjLG5lYXJlc3RNb2RlOnAsY3ViaWNDb2VmZmljaWVudEE6ZixleGNsdWRlT3V0c2lkZTpkLHVzZU5lYXJlc3QyeE9wdGltaXphdGlvbjpoLHJvaUlucHV0SWR4Omcsc2NhbGVzSW5wdXRJZHg6YixzaXplc0lucHV0SWR4Om19KX07Y29uc3Qgcz0odCxlLG4pPT57Y29uc3Qgcj0oMCxpLmdldEdsc2wpKHQuc2Vzc2lvbi5iYWNrZW5kLmdsQ29udGV4dC52ZXJzaW9uKSxbcyx1XT10LmNhbGN1bGF0ZVRleHR1cmVXaWR0aEFuZEhlaWdodChlWzBdLmRpbXMsby5UZXh0dXJlVHlwZS51bnBhY2tlZCksYz1lWzBdLmRpbXMubWFwKCgodCxlKT0+TWF0aC5mbG9vcih0Km4uc2NhbGVzW2VdKSkpLFtsLHBdPXQuY2FsY3VsYXRlVGV4dHVyZVdpZHRoQW5kSGVpZ2h0KGMsby5UZXh0dXJlVHlwZS51bnBhY2tlZCksZj1jLmxlbmd0aCxkPW5ldyBBcnJheShmKSxoPW5ldyBBcnJheShmKTtsZXQgZz1gXFxuICAgICAgaW50IG91dHB1dF9waXRjaGVzWyR7Zn1dO1xcbiAgICAgIGludCBpbnB1dF9waXRjaGVzWyR7Zn1dO1xcbiAgICAgIGA7Zm9yKGxldCB0PWYtMTt0Pj0wO3QtLSlkW3RdPXQ9PT1mLTE/MTpkW3QrMV0qY1t0KzFdLGhbdF09dD09PWYtMT8xOmhbdCsxXSplWzBdLmRpbXNbdCsxXSxnKz1gXFxuICAgICAgICBvdXRwdXRfcGl0Y2hlc1ske3R9XSA9ICR7ZFt0XX07XFxuICAgICAgICBpbnB1dF9waXRjaGVzWyR7dH1dID0gJHtoW3RdfTtcXG4gICAgICAgIGA7Y29uc3QgYj1gXFxuICAgICAgZmxvYXQgZ2V0SW5wdXRGbG9hdChpbnQgaW5kZXgpIHtcXG4gICAgICAgIHZlYzIgY29vcmRzID0gb2Zmc2V0VG9Db29yZHMoaW5kZXgsICR7c30sICR7dX0pO1xcbiAgICAgICAgZmxvYXQgdmFsdWUgPSBnZXRDb2xvckFzRmxvYXQoJHtyLnRleHR1cmUyRH0oWCwgY29vcmRzKSk7XFxuICAgICAgICByZXR1cm4gdmFsdWU7XFxuICAgICAgfVxcbiAgICAgIGAsbT1cIm5lYXJlc3RcIj09PW4ubW9kZT9gXFxuICAgICR7Yn1cXG4gICAgZmxvYXQgcHJvY2VzcyhpbnQgaW5kaWNlc1ske2Z9XSkge1xcbiAgICAgIGludCBpbnB1dF9pbmRleCA9IDA7XFxuICAgICAgaW50IG91dHB1dF9pbmRleCA9IGNvb3Jkc1RvT2Zmc2V0KFRleENvb3JkcywgJHtsfSwgJHtwfSk7XFxuXFxuICAgICAgJHtnfVxcblxcbiAgICAgIGludCBkLCBtO1xcbiAgICAgIGZvciAoaW50IGRpbSA9IDA7IGRpbSA8ICR7Zn07ICsrZGltKSB7XFxuICAgICAgICBkID0gb3V0cHV0X2luZGV4IC8gb3V0cHV0X3BpdGNoZXNbZGltXTtcXG4gICAgICAgIG0gPSBvdXRwdXRfaW5kZXggLSBkICogb3V0cHV0X3BpdGNoZXNbZGltXTtcXG4gICAgICAgIG91dHB1dF9pbmRleCA9IG07XFxuXFxuICAgICAgICBpZiAoc2NhbGVzW2RpbV0gIT0gMSAmJiBkID4gMCkge1xcbiAgICAgICAgICBpbnQgZDIgPSBkIC8gc2NhbGVzW2RpbV07XFxuICAgICAgICAgIG0gPSBkIC0gZDIgKiBzY2FsZXNbZGltXTtcXG4gICAgICAgICAgZCA9IGQyO1xcbiAgICAgICAgfVxcbiAgICAgICAgaW5wdXRfaW5kZXggKz0gaW5wdXRfcGl0Y2hlc1tkaW1dICogZDtcXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIGdldElucHV0RmxvYXQoaW5wdXRfaW5kZXgpO1xcbiAgICB9YDo0PT09Zj9gXFxuICAgICR7Yn1cXG4gICAgZmxvYXQgcHJvY2VzcyhpbnQgaW5kaWNlc1s0XSkge1xcbiAgICAgIGludCBpbnB1dF9pbmRleCA9IDA7XFxuICAgICAgaW50IG91dHB1dF9pbmRleCA9IGNvb3Jkc1RvT2Zmc2V0KFRleENvb3JkcywgJHtsfSwgJHtwfSk7XFxuXFxuICAgICAgJHtnfVxcblxcbiAgICAgIGludCBtO1xcbiAgICAgIGludCBpbmRleF9vZl9kaW0wLCBpbmRleF9vZl9kaW0xLCBpbmRleF9vZl9kaW0yLCBpbmRleF9vZl9kaW0zO1xcbiAgICAgIGluZGV4X29mX2RpbTAgPSBvdXRwdXRfaW5kZXggLyBvdXRwdXRfcGl0Y2hlc1swXTtcXG4gICAgICBtID0gb3V0cHV0X2luZGV4IC0gaW5kZXhfb2ZfZGltMCAqIG91dHB1dF9waXRjaGVzWzBdO1xcbiAgICAgIGluZGV4X29mX2RpbTEgPSBtIC8gb3V0cHV0X3BpdGNoZXNbMV07XFxuICAgICAgbSA9IG0gLSBpbmRleF9vZl9kaW0xICogb3V0cHV0X3BpdGNoZXNbMV07XFxuICAgICAgaW5kZXhfb2ZfZGltMiA9IG0gLyBvdXRwdXRfcGl0Y2hlc1syXTtcXG4gICAgICBtID0gbSAtIGluZGV4X29mX2RpbTIgKiBvdXRwdXRfcGl0Y2hlc1syXTtcXG4gICAgICBpbmRleF9vZl9kaW0zID0gbTtcXG5cXG4gICAgICBpbnQgaW5kZXhfb2ZfaW5wdXRfZGltMiwgaW5kZXhfb2ZfaW5wdXRfZGltMywgeF9vZmZzZXQsIHlfb2Zmc2V0O1xcbiAgICAgIGluZGV4X29mX2lucHV0X2RpbTIgPSBpbmRleF9vZl9kaW0yIC8gc2NhbGVzWzJdO1xcbiAgICAgIHlfb2Zmc2V0ID0gaW5kZXhfb2ZfZGltMiAtIGluZGV4X29mX2lucHV0X2RpbTIgKiBzY2FsZXNbMl07XFxuICAgICAgaW5kZXhfb2ZfaW5wdXRfZGltMyA9IGluZGV4X29mX2RpbTMgLyBzY2FsZXNbM107XFxuICAgICAgeF9vZmZzZXQgPSBpbmRleF9vZl9kaW0zIC0gaW5kZXhfb2ZfaW5wdXRfZGltMyAqIHNjYWxlc1szXTtcXG5cXG4gICAgICBpbnB1dF9pbmRleCA9IGluZGV4X29mX2RpbTAgKiBpbnB1dF9waXRjaGVzWzBdICtcXG4gICAgICAgICAgICBpbmRleF9vZl9kaW0xICogaW5wdXRfcGl0Y2hlc1sxXSArXFxuICAgICAgICAgICAgaW5kZXhfb2ZfaW5wdXRfZGltMiAqIGlucHV0X3BpdGNoZXNbMl0gK1xcbiAgICAgICAgICAgIGluZGV4X29mX2lucHV0X2RpbTM7XFxuXFxuICAgICAgZmxvYXQgeDAwID0gZ2V0SW5wdXRGbG9hdChpbnB1dF9pbmRleCk7XFxuICAgICAgZmxvYXQgeDEwLCB4MDEsIHgxMTtcXG5cXG4gICAgICBib29sIGVuZF9vZl9kaW0yID0gZmFsc2U7XFxuICAgICAgaWYgKGluZGV4X29mX2lucHV0X2RpbTIgPT0gKCR7ZVswXS5kaW1zWzJdfSAtIDEpKSB7XFxuICAgICAgICAvLyBJdCdzIHRoZSBlbmQgaW4gZGltZW5zaW9uIDJcXG4gICAgICAgIHgwMSA9IHgwMDtcXG4gICAgICAgIGVuZF9vZl9kaW0yID0gdHJ1ZTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgeDAxID0gZ2V0SW5wdXRGbG9hdChpbnB1dF9pbmRleCArIGlucHV0X3BpdGNoZXNbMl0pO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoaW5kZXhfb2ZfaW5wdXRfZGltMyA9PSAoaW5wdXRfcGl0Y2hlc1syXSAtIDEpKSB7XFxuICAgICAgICAvLyBJdCdzIHRoZSBlbmQgaW4gZGltZW5zaW9uIDNcXG4gICAgICAgIHgxMCA9IHgwMDtcXG4gICAgICAgIHgxMSA9IHgwMTtcXG4gICAgICB9XFxuICAgICAgZWxzZSB7XFxuICAgICAgICB4MTAgPSBnZXRJbnB1dEZsb2F0KGlucHV0X2luZGV4ICsgMSk7XFxuICAgICAgICB4MTEgPSBlbmRfb2ZfZGltMiA/IHgxMCA6IGdldElucHV0RmxvYXQoaW5wdXRfaW5kZXggKyBpbnB1dF9waXRjaGVzWzJdICsgMSk7XFxuICAgICAgfVxcblxcbiAgICAgIGZsb2F0IHkwID0geDAwICsgZmxvYXQoeV9vZmZzZXQpICogKHgwMSAtIHgwMCkgLyBmbG9hdChzY2FsZXNbMl0pO1xcbiAgICAgIGZsb2F0IHkxID0geDEwICsgZmxvYXQoeV9vZmZzZXQpICogKHgxMSAtIHgxMCkgLyBmbG9hdChzY2FsZXNbMl0pO1xcbiAgICAgIHJldHVybiB5MCArIGZsb2F0KHhfb2Zmc2V0KSAqICh5MSAtIHkwKSAvIGZsb2F0KHNjYWxlc1szXSk7XFxuICAgIH1gOmBcXG4gICAgJHtifVxcbiAgICBmbG9hdCBwcm9jZXNzKGludCBpbmRpY2VzWzJdKSB7XFxuICAgICAgaW50IGlucHV0X2luZGV4ID0gMDtcXG4gICAgICBpbnQgb3V0cHV0X2luZGV4ID0gY29vcmRzVG9PZmZzZXQoVGV4Q29vcmRzLCAke2x9LCAke3B9KTtcXG5cXG4gICAgICAke2d9XFxuXFxuICAgICAgaW50IG07XFxuICAgICAgaW50IGluZGV4X29mX2RpbTAsIGluZGV4X29mX2RpbTE7XFxuICAgICAgaW5kZXhfb2ZfZGltMCA9IG91dHB1dF9pbmRleCAvIG91dHB1dF9waXRjaGVzWzBdO1xcbiAgICAgIG0gPSBvdXRwdXRfaW5kZXggLSBpbmRleF9vZl9kaW0wICogb3V0cHV0X3BpdGNoZXNbMF07XFxuICAgICAgaW5kZXhfb2ZfZGltMSA9IG07XFxuXFxuICAgICAgaW50IGluZGV4X29mX2lucHV0X2RpbTAsIGluZGV4X29mX2lucHV0X2RpbTEsIHhfb2Zmc2V0LCB5X29mZnNldDtcXG4gICAgICBpbmRleF9vZl9pbnB1dF9kaW0wID0gaW5kZXhfb2ZfZGltMCAvIHNjYWxlc1swXTtcXG4gICAgICB5X29mZnNldCA9IGluZGV4X29mX2RpbTAgLSBpbmRleF9vZl9pbnB1dF9kaW0wICogc2NhbGVzWzBdO1xcbiAgICAgIGluZGV4X29mX2lucHV0X2RpbTEgPSBpbmRleF9vZl9kaW0xIC8gc2NhbGVzWzFdO1xcbiAgICAgIHhfb2Zmc2V0ID0gaW5kZXhfb2ZfZGltMSAtIGluZGV4X29mX2lucHV0X2RpbTEgKiBzY2FsZXNbMV07XFxuXFxuICAgICAgaW5wdXRfaW5kZXggPSBpbmRleF9vZl9pbnB1dF9kaW0wICogaW5wdXRfcGl0Y2hlc1swXSArIGluZGV4X29mX2lucHV0X2RpbTE7XFxuXFxuICAgICAgZmxvYXQgeDAwID0gZ2V0SW5wdXRGbG9hdChpbnB1dF9pbmRleCk7XFxuICAgICAgZmxvYXQgeDEwLCB4MDEsIHgxMTtcXG5cXG4gICAgICBib29sIGVuZF9vZl9kaW0wID0gZmFsc2U7XFxuICAgICAgaWYgKGluZGV4X29mX2lucHV0X2RpbTAgPT0gKCR7ZVswXS5kaW1zWzBdfSAtIDEpKSB7XFxuICAgICAgICAvLyBJdCdzIHRoZSBlbmQgaW4gZGltZW5zaW9uIDBcXG4gICAgICAgIHgwMSA9IHgwMDtcXG4gICAgICAgIGVuZF9vZl9kaW0wID0gdHJ1ZTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgeDAxID0gZ2V0SW5wdXRGbG9hdChpbnB1dF9pbmRleCArIGlucHV0X3BpdGNoZXNbMF0pO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoaW5kZXhfb2ZfaW5wdXRfZGltMSA9PSAoaW5wdXRfcGl0Y2hlc1swXSAtIDEpKSB7XFxuICAgICAgICAvLyBJdCdzIHRoZSBlbmQgaW4gZGltZW5zaW9uIDFcXG4gICAgICAgIHgxMCA9IHgwMDtcXG4gICAgICAgIHgxMSA9IHgwMTtcXG4gICAgICB9XFxuICAgICAgZWxzZSB7XFxuICAgICAgICB4MTAgPSBnZXRJbnB1dEZsb2F0KGlucHV0X2luZGV4ICsgMSk7XFxuICAgICAgICB4MTEgPSBlbmRfb2ZfZGltMCA/IHgxMCA6IGdldElucHV0RmxvYXQoaW5wdXRfaW5kZXggKyBpbnB1dF9waXRjaGVzWzBdICsgMSk7XFxuICAgICAgfVxcblxcbiAgICAgIGZsb2F0IHkwID0geDAwICsgZmxvYXQoeV9vZmZzZXQpICogKHgwMSAtIHgwMCkgLyBmbG9hdChzY2FsZXNbMF0pO1xcbiAgICAgIGZsb2F0IHkxID0geDEwICsgZmxvYXQoeV9vZmZzZXQpICogKHgxMSAtIHgxMCkgLyBmbG9hdChzY2FsZXNbMF0pO1xcbiAgICAgIHJldHVybiB5MCArIGZsb2F0KHhfb2Zmc2V0KSAqICh5MSAtIHkwKSAvIGZsb2F0KHNjYWxlc1sxXSk7XFxuICAgIH1gO3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sYSkse291dHB1dDp7ZGltczpjLHR5cGU6ZVswXS50eXBlLHRleHR1cmVUeXBlOm8uVGV4dHVyZVR5cGUudW5wYWNrZWR9LHNoYWRlclNvdXJjZTptLHZhcmlhYmxlczpbe25hbWU6XCJzY2FsZXNcIix0eXBlOlwiaW50XCIsYXJyYXlMZW5ndGg6bi5zY2FsZXMubGVuZ3RoLGRhdGE6bi5zY2FsZXMubWFwKCh0PT5NYXRoLmNlaWwodCkpKX1dfSl9O2UudmFsaWRhdGVJbnB1dHM9KHQsZSk9PntpZighdHx8ZS5vcHNldDw5JiYxIT09dC5sZW5ndGh8fGUub3BzZXQ+PTkmJmUub3BzZXQ8MTEmJjIhPT10Lmxlbmd0aHx8ZS5vcHNldD49MTEmJnQubGVuZ3RoPDIpdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBpbnB1dHMuXCIpO2lmKGUuc2NhbGVzLmxlbmd0aD4wJiZ0WzBdLmRpbXMubGVuZ3RoIT09ZS5zY2FsZXMubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW5wdXQgc2hhcGUuXCIpO2lmKFwic3RyaW5nXCI9PT10WzBdLnR5cGUpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpbnB1dCB0ZW5zb3IgdHlwZXMuXCIpfSxlLnNjYWxlc1ZhbGlkYXRpb249KHQsZSxuKT0+e2lmKG4pe2Zvcihjb25zdCBlIG9mIHQpaWYoZTw9MCl0aHJvdyBuZXcgRXJyb3IoXCJTY2FsZSB2YWx1ZSBzaG91bGQgYmUgZ3JlYXRlciB0aGFuIDAuXCIpfWVsc2UgZm9yKGNvbnN0IGUgb2YgdClpZihlPDEpdGhyb3cgbmV3IEVycm9yKFwiU2NhbGUgdmFsdWUgc2hvdWxkIGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAxLlwiKTtpZighKFwibGluZWFyXCIhPT1lJiZcImN1YmljXCIhPT1lfHwyPT09dC5sZW5ndGh8fDQ9PT10Lmxlbmd0aCYmMT09PXRbMF0mJjE9PT10WzFdKSl0aHJvdyBuZXcgRXJyb3IoYCdMaW5lYXInIG1vZGUgYW5kICdDdWJpYycgbW9kZSBvbmx5IHN1cHBvcnQgMi1EIGlucHV0cyAoJ0JpbGluZWFyJywgJ0JpY3ViaWMnKSAgICAgICAgIG9yIDQtRCBpbnB1dHMgd2l0aCB0aGUgY29ycmVzcG9uZGluZyBvdXRlcm1vc3QgMiBzY2FsZSB2YWx1ZXMgYmVpbmcgMSAgICAgICAgIGluIHRoZSAke24/XCJSZXNpemVcIjpcIlVwc2FtcGxlXCJ9IG9wZWFydG9yLmApfX0sMTk1ODoodCxlLG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5Qcm9ncmFtTWFuYWdlcj12b2lkIDA7Y29uc3Qgcj1uKDYyMDcpLGk9bigzNjk0KSxvPW4oODg3OSksYT1uKDUwNjApO2UuUHJvZ3JhbU1hbmFnZXI9Y2xhc3N7Y29uc3RydWN0b3IodCxlLG4pe3RoaXMucHJvZmlsZXI9dCx0aGlzLmdsQ29udGV4dD1lLHRoaXMudGV4dHVyZUxheW91dFN0cmF0ZWd5PW4sdGhpcy5yZXBvPW5ldyBNYXAsdGhpcy5hdHRyaWJ1dGVzQm91bmQ9ITF9Z2V0QXJ0aWZhY3QodCl7cmV0dXJuIHRoaXMucmVwby5nZXQodCl9c2V0QXJ0aWZhY3QodCxlKXt0aGlzLnJlcG8uc2V0KHQsZSl9cnVuKHQsZSxuKXt2YXIgcjt0aGlzLnByb2ZpbGVyLmV2ZW50KFwib3BcIixgUHJvZ3JhbU1hbmFnZXIucnVuICR7bnVsbCE9PShyPXQucHJvZ3JhbUluZm8ubmFtZSkmJnZvaWQgMCE9PXI/cjpcInVua25vd24ga2VybmVsXCJ9YCwoKCk9Pnt2YXIgcjtjb25zdCBvPXRoaXMuZ2xDb250ZXh0LmdsLGE9dC5wcm9ncmFtO28udXNlUHJvZ3JhbShhKTt0cnl7dGhpcy5iaW5kT3V0cHV0KG4pLHRoaXMuYXR0cmlidXRlc0JvdW5kfHx0aGlzLmJpbmRBdHRyaWJ1dGVzKHQuYXR0cmliTG9jYXRpb25zKSx0aGlzLmJpbmRVbmlmb3Jtcyh0LnVuaWZvcm1Mb2NhdGlvbnMsbnVsbCE9PShyPXQucHJvZ3JhbUluZm8udmFyaWFibGVzKSYmdm9pZCAwIT09cj9yOltdLGUpfWNhdGNoKGUpe3Rocm93IGkuTG9nZ2VyLmVycm9yKFwiUHJvZ3JhbU1hbmFnZXJcIix0LnByb2dyYW1JbmZvLnNoYWRlclNvdXJjZSksZX10aGlzLnByb2ZpbGVyLmV2ZW50KFwiYmFja2VuZFwiLFwiR2xDb250ZXh0LmRyYXcoKVwiLCgoKT0+e3RoaXMuZ2xDb250ZXh0LmRyYXcoKX0pKX0pLHRoaXMuZ2xDb250ZXh0KX1kaXNwb3NlKCl7dGhpcy52ZXJ0ZXhTaGFkZXImJnRoaXMuZ2xDb250ZXh0LmRlbGV0ZVNoYWRlcih0aGlzLnZlcnRleFNoYWRlciksdGhpcy5yZXBvLmZvckVhY2goKHQ9PnRoaXMuZ2xDb250ZXh0LmRlbGV0ZVByb2dyYW0odC5wcm9ncmFtKSkpfWJ1aWxkKHQsZSxuKXtyZXR1cm4gdGhpcy5wcm9maWxlci5ldmVudChcImJhY2tlbmRcIixcIlByb2dyYW1NYW5hZ2VyLmJ1aWxkXCIsKCgpPT57Y29uc3Qgcj1uZXcgby5HbHNsUHJlcHJvY2Vzc29yKHRoaXMuZ2xDb250ZXh0LHQsZSxuKSxpPXIucHJlcHJvY2VzcygpLGE9dGhpcy5jb21waWxlKGkpO3JldHVybntwcm9ncmFtSW5mbzp0LHByb2dyYW06YSx1bmlmb3JtTG9jYXRpb25zOnRoaXMuZ2V0VW5pZm9ybUxvY2F0aW9ucyhhLHIuY29udGV4dC5wcm9ncmFtSW5mby5pbnB1dE5hbWVzLHIuY29udGV4dC5wcm9ncmFtSW5mby52YXJpYWJsZXMpLGF0dHJpYkxvY2F0aW9uczp0aGlzLmdldEF0dHJpYkxvY2F0aW9ucyhhKX19KSl9Y29tcGlsZSh0KXtpZighdGhpcy52ZXJ0ZXhTaGFkZXIpe2kuTG9nZ2VyLnZlcmJvc2UoXCJQcm9yZ3JhbU1hbmFnZXJcIixcIkNvbXBpbGluZyBhbmQgY2FjaGluZyBWZXJ0ZXggc2hhZGVyIGZvciB0aGUgZmlyc3QgdGltZVwiKTtjb25zdCB0PSgwLGEuZ2V0VmVydGV4U2hhZGVyU291cmNlKSh0aGlzLmdsQ29udGV4dC52ZXJzaW9uKTt0aGlzLnZlcnRleFNoYWRlcj10aGlzLmdsQ29udGV4dC5jb21waWxlU2hhZGVyKHQsdGhpcy5nbENvbnRleHQuZ2wuVkVSVEVYX1NIQURFUil9ci5lbnYuZGVidWcmJmkuTG9nZ2VyLnZlcmJvc2UoXCJQcm9yZ3JhbU1hbmFnZXJcIixgRnJhZ1NoYWRlcjpcXG4ke3R9XFxuYCk7Y29uc3QgZT10aGlzLmdsQ29udGV4dC5jb21waWxlU2hhZGVyKHQsdGhpcy5nbENvbnRleHQuZ2wuRlJBR01FTlRfU0hBREVSKSxuPXRoaXMuZ2xDb250ZXh0LmNyZWF0ZVByb2dyYW0odGhpcy52ZXJ0ZXhTaGFkZXIsZSk7cmV0dXJuIHRoaXMuZ2xDb250ZXh0LmRlbGV0ZVNoYWRlcihlKSxufWJpbmRPdXRwdXQodCl7Y29uc3QgZT10LndpZHRoLG49dC5oZWlnaHQ7aS5Mb2dnZXIudmVyYm9zZShcIlByb3JncmFtTWFuYWdlclwiLGBCaW5kaW5nIG91dHB1dCB0ZXh0dXJlIHRvIEZyYW1lYnVmZmVyOiB3L2g9JHtlfS8ke259LCBzaGFwZT0ke3Quc2hhcGV9LCB0eXBlPSR7dC50ZW5zb3IudHlwZX1gKSx0aGlzLmdsQ29udGV4dC5hdHRhY2hGcmFtZWJ1ZmZlcih0LnRleHR1cmUsZSxuKX1iaW5kQXR0cmlidXRlcyh0KXtjb25zdCBlPXQucG9zaXRpb24sbj10LnRleHR1cmVDb29yZDt0aGlzLmdsQ29udGV4dC5zZXRWZXJ0ZXhBdHRyaWJ1dGVzKGUsbiksdGhpcy5hdHRyaWJ1dGVzQm91bmQ9ITB9YmluZFVuaWZvcm1zKHQsZSxuKXt2YXIgcjtjb25zdCBpPXRoaXMuZ2xDb250ZXh0LmdsO2xldCBvPTA7Zm9yKGNvbnN0e25hbWU6YSx0eXBlOnMsbG9jYXRpb246dSxhcnJheUxlbmd0aDpjfW9mIHQpe2NvbnN0IHQ9bnVsbD09PShyPWUuZmluZCgodD0+dC5uYW1lPT09YSkpKXx8dm9pZCAwPT09cj92b2lkIDA6ci5kYXRhO2lmKFwic2FtcGxlcjJEXCIhPT1zJiYhdCl0aHJvdyBuZXcgRXJyb3IoYHZhcmlhYmxlICcke2F9JyBkb2VzIG5vdCBoYXZlIGRhdGEgZGVmaW5lZCBpbiBwcm9ncmFtIGluZm9gKTtzd2l0Y2gocyl7Y2FzZVwic2FtcGxlcjJEXCI6dGhpcy5iaW5kVGV4dHVyZShuW29dLHUsbyksbysrO2JyZWFrO2Nhc2VcImZsb2F0XCI6Yz9pLnVuaWZvcm0xZnYodSx0KTppLnVuaWZvcm0xZih1LHQpO2JyZWFrO2Nhc2VcImludFwiOmM/aS51bmlmb3JtMWl2KHUsdCk6aS51bmlmb3JtMWkodSx0KTticmVhaztkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgVW5pZm9ybSBub3QgaW1wbGVtZW50ZWQ6ICR7c31gKX19fWJpbmRUZXh0dXJlKHQsZSxuKXt0aGlzLmdsQ29udGV4dC5iaW5kVGV4dHVyZVRvVW5pZm9ybSh0LnRleHR1cmUsbixlKX1nZXRBdHRyaWJMb2NhdGlvbnModCl7cmV0dXJue3Bvc2l0aW9uOnRoaXMuZ2V0QXR0cmliTG9jYXRpb24odCxcInBvc2l0aW9uXCIpLHRleHR1cmVDb29yZDp0aGlzLmdldEF0dHJpYkxvY2F0aW9uKHQsXCJ0ZXh0dXJlQ29vcmRcIil9fWdldFVuaWZvcm1Mb2NhdGlvbnModCxlLG4pe2NvbnN0IHI9W107aWYoZSlmb3IoY29uc3QgbiBvZiBlKXIucHVzaCh7bmFtZTpuLHR5cGU6XCJzYW1wbGVyMkRcIixsb2NhdGlvbjp0aGlzLmdldFVuaWZvcm1Mb2NhdGlvbih0LG4pfSk7aWYobilmb3IoY29uc3QgZSBvZiBuKXIucHVzaChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sZSkse2xvY2F0aW9uOnRoaXMuZ2V0VW5pZm9ybUxvY2F0aW9uKHQsZS5uYW1lKX0pKTtyZXR1cm4gcn1nZXRVbmlmb3JtTG9jYXRpb24odCxlKXtjb25zdCBuPXRoaXMuZ2xDb250ZXh0LmdsLmdldFVuaWZvcm1Mb2NhdGlvbih0LGUpO2lmKG51bGw9PT1uKXRocm93IG5ldyBFcnJvcihgVW5pZm9ybSAke2V9IG5vdCBmb3VuZC5gKTtyZXR1cm4gbn1nZXRBdHRyaWJMb2NhdGlvbih0LGUpe3JldHVybiB0aGlzLmdsQ29udGV4dC5nbC5nZXRBdHRyaWJMb2NhdGlvbih0LGUpfX19LDY0MTY6KHQsZSxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUuV2ViR0xTZXNzaW9uSGFuZGxlcj12b2lkIDA7Y29uc3Qgcj1uKDM2OTQpLGk9bigxMDQ3KSxvPW4oODMxNiksYT1uKDE2NDApLHM9bigxOTU4KSx1PW4oNzg1OSksYz1uKDU3MDIpO2UuV2ViR0xTZXNzaW9uSGFuZGxlcj1jbGFzc3tjb25zdHJ1Y3Rvcih0LGUpe3RoaXMuYmFja2VuZD10LHRoaXMuY29udGV4dD1lLHRoaXMubGF5b3V0U3RyYXRlZ3k9bmV3IHUuUHJlZmVyTG9naWNhbFN0cmF0ZWd5KHQuZ2xDb250ZXh0Lm1heFRleHR1cmVTaXplKSx0aGlzLnByb2dyYW1NYW5hZ2VyPW5ldyBzLlByb2dyYW1NYW5hZ2VyKHRoaXMuY29udGV4dC5wcm9maWxlcix0LmdsQ29udGV4dCx0aGlzLmxheW91dFN0cmF0ZWd5KSx0aGlzLnRleHR1cmVNYW5hZ2VyPW5ldyBjLlRleHR1cmVNYW5hZ2VyKHQuZ2xDb250ZXh0LHRoaXMubGF5b3V0U3RyYXRlZ3ksdGhpcy5jb250ZXh0LnByb2ZpbGVyLHtyZXVzZVRleHR1cmVzOlwiZnVsbFwiPT09dC50ZXh0dXJlQ2FjaGVNb2RlfSksdGhpcy5wYWNrZWRUZXh0dXJlRGF0YUNhY2hlPW5ldyBNYXAsdGhpcy51bnBhY2tlZFRleHR1cmVEYXRhQ2FjaGU9bmV3IE1hcCx0aGlzLnBhY2s9dC5wYWNrLHRoaXMucGFjazJ1bnBhY2tNYXA9bmV3IE1hcCx0aGlzLnVucGFjazJwYWNrTWFwPW5ldyBNYXB9Y3JlYXRlSW5mZXJlbmNlSGFuZGxlcigpe3JldHVybiBuZXcgby5XZWJHTEluZmVyZW5jZUhhbmRsZXIodGhpcyl9b25HcmFwaEluaXRpYWxpemVkKHQpe2NvbnN0IGU9dC5nZXRWYWx1ZXMoKS5maWx0ZXIoKHQ9Pi0xPT09dC5mcm9tJiZ0LnRlbnNvcikpLm1hcCgodD0+dC50ZW5zb3IuZGF0YUlkKSk7dGhpcy5pbml0aWFsaXplcnM9bmV3IFNldChlKX1pc0luaXRpYWxpemVyKHQpe3JldHVybiEhdGhpcy5pbml0aWFsaXplcnMmJnRoaXMuaW5pdGlhbGl6ZXJzLmhhcyh0KX1hZGRJbml0aWFsaXplcih0KXt0aGlzLmluaXRpYWxpemVycy5hZGQodCl9Z2V0VGV4dHVyZURhdGEodCxlKXtyZXR1cm4gZT90aGlzLnBhY2tlZFRleHR1cmVEYXRhQ2FjaGUuZ2V0KHQpOnRoaXMudW5wYWNrZWRUZXh0dXJlRGF0YUNhY2hlLmdldCh0KX1zZXRUZXh0dXJlRGF0YSh0LGUsbj0hMSl7ci5Mb2dnZXIudmVyYm9zZShcIldlYkdMU2Vzc2lvbkhhbmRsZXJcIixcIlN0b3JpbmcgVGV4dHVyZSBkYXRhIGluIGNhY2hlXCIpLG4/dGhpcy5wYWNrZWRUZXh0dXJlRGF0YUNhY2hlLnNldCh0LGUpOnRoaXMudW5wYWNrZWRUZXh0dXJlRGF0YUNhY2hlLnNldCh0LGUpfWRpc3Bvc2UoKXt0aGlzLnByb2dyYW1NYW5hZ2VyLmRpc3Bvc2UoKSx0aGlzLnRleHR1cmVNYW5hZ2VyLmNsZWFyQWN0aXZlVGV4dHVyZXMoKSx0aGlzLnBhY2tlZFRleHR1cmVEYXRhQ2FjaGUuZm9yRWFjaCgodD0+dGhpcy50ZXh0dXJlTWFuYWdlci5yZWxlYXNlVGV4dHVyZSh0LCEwKSkpLHRoaXMucGFja2VkVGV4dHVyZURhdGFDYWNoZT1uZXcgTWFwLHRoaXMudW5wYWNrZWRUZXh0dXJlRGF0YUNhY2hlLmZvckVhY2goKHQ9PnRoaXMudGV4dHVyZU1hbmFnZXIucmVsZWFzZVRleHR1cmUodCwhMCkpKSx0aGlzLnVucGFja2VkVGV4dHVyZURhdGFDYWNoZT1uZXcgTWFwfXJlc29sdmUodCxlLG4pe2NvbnN0IHI9KDAsaS5yZXNvbHZlT3BlcmF0b3IpKHQsZSxhLldFQkdMX09QX1JFU09MVkVfUlVMRVMpO3JldHVybntpbXBsOnIub3BJbXBsLGNvbnRleHQ6ci5vcEluaXQ/ci5vcEluaXQodCxuKTp0fX19fSw3NzY5Oih0LGUsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLlVpbnQ4RGF0YUVuY29kZXI9ZS5SR0JBRmxvYXREYXRhRW5jb2Rlcj1lLlJlZEZsb2F0MzJEYXRhRW5jb2Rlcj12b2lkIDA7Y29uc3Qgcj1uKDM2OTQpO2UuUmVkRmxvYXQzMkRhdGFFbmNvZGVyPWNsYXNze2NvbnN0cnVjdG9yKHQsZT0xKXtpZigxPT09ZSl0aGlzLmludGVybmFsRm9ybWF0PXQuUjMyRix0aGlzLmZvcm1hdD10LlJFRCx0aGlzLnRleHR1cmVUeXBlPXQuRkxPQVQsdGhpcy5jaGFubmVsU2l6ZT1lO2Vsc2V7aWYoNCE9PWUpdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIG51bWJlciBvZiBjaGFubmVsczogJHtlfWApO3RoaXMuaW50ZXJuYWxGb3JtYXQ9dC5SR0JBMzJGLHRoaXMuZm9ybWF0PXQuUkdCQSx0aGlzLnRleHR1cmVUeXBlPXQuRkxPQVQsdGhpcy5jaGFubmVsU2l6ZT1lfX1lbmNvZGUodCxlKXtsZXQgbixpO3JldHVybiB0LmNvbnN0cnVjdG9yIT09RmxvYXQzMkFycmF5JiYoci5Mb2dnZXIud2FybmluZyhcIkVuY29kZXJcIixcImRhdGEgd2FzIG5vdCBvZiB0eXBlIEZsb2F0MzI7IGNyZWF0aW5nIG5ldyBGbG9hdDMyQXJyYXlcIiksaT1uZXcgRmxvYXQzMkFycmF5KHQpKSxlKnRoaXMuY2hhbm5lbFNpemU+dC5sZW5ndGg/KHIuTG9nZ2VyLndhcm5pbmcoXCJFbmNvZGVyXCIsXCJTb3VyY2UgZGF0YSB0b28gc21hbGwuIEFsbG9jYXRpbmcgbGFyZ2VyIGFycmF5XCIpLGk9dCxuPXRoaXMuYWxsb2NhdGUoZSp0aGlzLmNoYW5uZWxTaXplKSxpLmZvckVhY2goKCh0LGUpPT5uW2VdPXQpKSk6KGk9dCxuPWkpLG59YWxsb2NhdGUodCl7cmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkoNCp0KX1kZWNvZGUodCxlKXtyZXR1cm4gMT09PXRoaXMuY2hhbm5lbFNpemU/dC5maWx0ZXIoKCh0LGUpPT5lJTQ9PTApKS5zdWJhcnJheSgwLGUpOnQuc3ViYXJyYXkoMCxlKX19LGUuUkdCQUZsb2F0RGF0YUVuY29kZXI9Y2xhc3N7Y29uc3RydWN0b3IodCxlPTEsbil7aWYoMSE9PWUmJjQhPT1lKXRocm93IG5ldyBFcnJvcihgSW52YWxpZCBudW1iZXIgb2YgY2hhbm5lbHM6ICR7ZX1gKTt0aGlzLmludGVybmFsRm9ybWF0PXQuUkdCQSx0aGlzLmZvcm1hdD10LlJHQkEsdGhpcy5jaGFubmVsU2l6ZT1lLHRoaXMudGV4dHVyZVR5cGU9bnx8dC5GTE9BVH1lbmNvZGUodCxlKXtsZXQgbj10O3JldHVybiAxPT09dGhpcy5jaGFubmVsU2l6ZSYmKHIuTG9nZ2VyLnZlcmJvc2UoXCJFbmNvZGVyXCIsXCJFeHBsb2RpbmcgaW50byBhIGxhcmdlciBhcnJheVwiKSxuPXRoaXMuYWxsb2NhdGUoZSksdC5mb3JFYWNoKCgodCxlKT0+bls0KmVdPXQpKSksbn1hbGxvY2F0ZSh0KXtyZXR1cm4gbmV3IEZsb2F0MzJBcnJheSg0KnQpfWRlY29kZSh0LGUpe3JldHVybiAxPT09dGhpcy5jaGFubmVsU2l6ZT90LmZpbHRlcigoKHQsZSk9PmUlND09MCkpLnN1YmFycmF5KDAsZSk6dC5zdWJhcnJheSgwLGUpfX0sZS5VaW50OERhdGFFbmNvZGVyPWNsYXNze2NvbnN0cnVjdG9yKHQsZT0xKXtpZih0aGlzLmNoYW5uZWxTaXplPTQsMT09PWUpdGhpcy5pbnRlcm5hbEZvcm1hdD10LkFMUEhBLHRoaXMuZm9ybWF0PXQuQUxQSEEsdGhpcy50ZXh0dXJlVHlwZT10LlVOU0lHTkVEX0JZVEUsdGhpcy5jaGFubmVsU2l6ZT1lO2Vsc2V7aWYoNCE9PWUpdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIG51bWJlciBvZiBjaGFubmVsczogJHtlfWApO3RoaXMuaW50ZXJuYWxGb3JtYXQ9dC5SR0JBLHRoaXMuZm9ybWF0PXQuUkdCQSx0aGlzLnRleHR1cmVUeXBlPXQuVU5TSUdORURfQllURSx0aGlzLmNoYW5uZWxTaXplPWV9fWVuY29kZSh0LGUpe3JldHVybiBuZXcgVWludDhBcnJheSh0LmJ1ZmZlcix0LmJ5dGVPZmZzZXQsdC5ieXRlTGVuZ3RoKX1hbGxvY2F0ZSh0KXtyZXR1cm4gbmV3IFVpbnQ4QXJyYXkodCp0aGlzLmNoYW5uZWxTaXplKX1kZWNvZGUodCxlKXtpZih0IGluc3RhbmNlb2YgVWludDhBcnJheSlyZXR1cm4gdC5zdWJhcnJheSgwLGUpO3Rocm93IG5ldyBFcnJvcihgSW52YWxpZCBhcnJheSB0eXBlOiAke3QuY29uc3RydWN0b3J9YCl9fX0sNzg1OToodCxlLG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5nZXRCYXRjaERpbT1lLnNpemVUb1NxdWFyaXNoU2hhcGU9ZS5nZXRSb3dzQ29scz1lLnNpemVGcm9tU2hhcGU9ZS5pc0ludD1lLnBhcnNlQXhpc1BhcmFtPWUuc3F1ZWV6ZVNoYXBlPWUuUHJlZmVyTG9naWNhbFN0cmF0ZWd5PWUuQWx3YXlzS2VlcE9yaWdpbmFsU2l6ZVN0cmF0ZWd5PXZvaWQgMDtjb25zdCByPW4oMzY5NCksaT1uKDI1MTcpO2Z1bmN0aW9uIG8odCxlKXtjb25zdCBuPVtdLHI9W10saT1udWxsIT1lJiZBcnJheS5pc0FycmF5KGUpJiYwPT09ZS5sZW5ndGgsbz1udWxsPT1lfHxpP251bGw6YShlLHQpLnNvcnQoKTtsZXQgcz0wO2ZvcihsZXQgZT0wO2U8dC5sZW5ndGg7KytlKXtpZihudWxsIT1vKXtpZihvW3NdPT09ZSYmMSE9PXRbZV0pdGhyb3cgbmV3IEVycm9yKGBDYW4ndCBzcXVlZXplIGF4aXMgJHtlfSBzaW5jZSBpdHMgZGltICcke3RbZV19JyBpcyBub3QgMWApOyhudWxsPT1vW3NdfHxvW3NdPmUpJiYxPT09dFtlXSYmKG4ucHVzaCh0W2VdKSxyLnB1c2goZSkpLG9bc108PWUmJnMrK30xIT09dFtlXSYmKG4ucHVzaCh0W2VdKSxyLnB1c2goZSkpfXJldHVybntuZXdTaGFwZTpuLGtlcHREaW1zOnJ9fWZ1bmN0aW9uIGEodCxlKXtjb25zdCBuPWUubGVuZ3RoO3JldHVybiB0PW51bGw9PXQ/ZS5tYXAoKCh0LGUpPT5lKSk6W10uY29uY2F0KHQpLCgwLGkuYXNzZXJ0KSh0LmV2ZXJ5KCh0PT50Pj0tbiYmdDxuKSksKCgpPT5gQWxsIHZhbHVlcyBpbiBheGlzIHBhcmFtIG11c3QgYmUgaW4gcmFuZ2UgWy0ke259LCAke259KSBidXQgZ290IGF4aXMgJHt0fWApKSwoMCxpLmFzc2VydCkodC5ldmVyeShzKSwoKCk9PmBBbGwgdmFsdWVzIGluIGF4aXMgcGFyYW0gbXVzdCBiZSBpbnRlZ2VycyBidXQgZ290IGF4aXMgJHt0fWApKSx0Lm1hcCgodD0+dDwwP24rdDp0KSl9ZnVuY3Rpb24gcyh0KXtyZXR1cm4gdCUxPT0wfWZ1bmN0aW9uIHUodCl7aWYoMD09PXQubGVuZ3RoKXJldHVybiAxO2xldCBlPXRbMF07Zm9yKGxldCBuPTE7bjx0Lmxlbmd0aDtuKyspZSo9dFtuXTtyZXR1cm4gZX1mdW5jdGlvbiBjKHQpe2NvbnN0IGU9TWF0aC5jZWlsKE1hdGguc3FydCh0KSk7cmV0dXJuW2UsTWF0aC5jZWlsKHQvZSldfWUuQWx3YXlzS2VlcE9yaWdpbmFsU2l6ZVN0cmF0ZWd5PWNsYXNze2NvbnN0cnVjdG9yKHQpe3RoaXMubWF4VGV4dHVyZVNpemU9dH1jb21wdXRlVGV4dHVyZVdIKHQsZSl7aWYoMD09PXQubGVuZ3RoKXJldHVyblsxLDFdO2NvbnN0IG49dGhpcy5tYXhUZXh0dXJlU2l6ZTtpZihlJiZ2b2lkIDAhPT1lLmJyZWFrQXhpcyl7Y29uc3QgaT1lLmJyZWFrQXhpcz49dC5sZW5ndGg/MTp0LnNsaWNlKGUuYnJlYWtBeGlzKS5yZWR1Y2UoKCh0LGUpPT50KmUpKSxvPWUuYnJlYWtBeGlzPD0wPzE6dC5zbGljZSgwLGUuYnJlYWtBeGlzKS5yZWR1Y2UoKCh0LGUpPT50KmUpKTtpZighKGk+bnx8bz5uKSlyZXR1cm5baSxvXTtyLkxvZ2dlci52ZXJib3NlKFwiVGV4dHVyZUxheW91dFwiLGBHaXZlbiB3aWR0aC9oZWlnaHQgcHJlZmVyZW5jZXMgd2VyZSB1bmF0dGFpbmFibGU6IHNoYXBlOiR7dH0sIGJyZWFrQXhpczoke2UuYnJlYWtBeGlzfWApfWNvbnN0IGk9dC5yZWR1Y2UoKCh0LGUpPT50KmUpKTtsZXQgbz1NYXRoLmZsb29yKE1hdGguc3FydChpKSk7Zm9yKDtvPG4mJm88aSYmaSVvIT0wO28rKyk7aWYobz49bnx8aSVvIT0wKXRocm93IG5ldyBFcnJvcihgVGhlIGdpdmVuIGRpbWVuc2lvbnMgYXJlIG91dHNpZGUgdGhpcyBHUFUncyBib3VuZGFyaWVzOiAke3R9YCk7cmV0dXJuW28saS9vXX19LGUuUHJlZmVyTG9naWNhbFN0cmF0ZWd5PWNsYXNze2NvbnN0cnVjdG9yKHQpe3RoaXMubWF4VGV4dHVyZVNpemU9dH1jb21wdXRlVGV4dHVyZVdIKHQsZSl7Y29uc3Qgbj10aGlzLmNvbXB1dGVUZXh0dXJlKHQsZSk7cmV0dXJuIGUmJmUuaXNQYWNrZWQmJihuWzBdLz0yLG5bMV0vPTIpLGUmJmUucmV2ZXJzZVdIP1tuWzFdLG5bMF1dOm59Y29tcHV0ZVRleHR1cmUodCxlKXtjb25zdCBuPWUmJmUuaXNQYWNrZWQ7aWYoMD09PXQubGVuZ3RoKXJldHVybiBuP1syLDJdOlsxLDFdO2xldCBpPXRoaXMubWF4VGV4dHVyZVNpemU7aWYoZSYmdm9pZCAwIT09ZS5icmVha0F4aXMpe2NvbnN0IG49ZS5icmVha0F4aXM+PXQubGVuZ3RoPzE6dC5zbGljZShlLmJyZWFrQXhpcykucmVkdWNlKCgodCxlKT0+dCplKSksbz1lLmJyZWFrQXhpczw9MD8xOnQuc2xpY2UoMCxlLmJyZWFrQXhpcykucmVkdWNlKCgodCxlKT0+dCplKSk7aWYoIShuPml8fG8+aSkpcmV0dXJuW24sb107ci5Mb2dnZXIudmVyYm9zZShcIlRleHR1cmVMYXlvdXRcIixgR2l2ZW4gd2lkdGgvaGVpZ2h0IHByZWZlcmVuY2VzIHdlcmUgdW5hdHRhaW5hYmxlOiBzaGFwZToke3R9LCBicmVha0F4aXM6JHtlLmJyZWFrQXhpc31gKX1sZXQgYT10LnNsaWNlKDApO2lmKG4mJihpKj0yLGE9YS5tYXAoKCh0LGUpPT5lPj1hLmxlbmd0aC0yP2FbZV0lMj09MD9hW2VdOmFbZV0rMTphW2VdKSksMT09PWEubGVuZ3RoJiYoYT1bMixhWzBdXSkpLDIhPT1hLmxlbmd0aCl7Y29uc3QgdD1vKGEpO2E9dC5uZXdTaGFwZX1jb25zdCBzPXUoYSk7cmV0dXJuIGEubGVuZ3RoPD0xJiZzPD1pP1sxLHNdOjI9PT1hLmxlbmd0aCYmYVswXTw9aSYmYVsxXTw9aT9hOjM9PT1hLmxlbmd0aCYmYVswXSphWzFdPD1pJiZhWzJdPD1pP1thWzBdKmFbMV0sYVsyXV06Mz09PWEubGVuZ3RoJiZhWzBdPD1pJiZhWzFdKmFbMl08PWk/W2FbMF0sYVsxXSphWzJdXTo0PT09YS5sZW5ndGgmJmFbMF0qYVsxXSphWzJdPD1pJiZhWzNdPD1pP1thWzBdKmFbMV0qYVsyXSxhWzNdXTo0PT09YS5sZW5ndGgmJmFbMF08PWkmJmFbMV0qYVsyXSphWzNdPD1pP1thWzBdLGFbMV0qYVsyXSphWzNdXTpuP2Mocy80KS5tYXAoKHQ9PjIqdCkpOmMocyl9fSxlLnNxdWVlemVTaGFwZT1vLGUucGFyc2VBeGlzUGFyYW09YSxlLmlzSW50PXMsZS5zaXplRnJvbVNoYXBlPXUsZS5nZXRSb3dzQ29scz1mdW5jdGlvbih0KXtpZigwPT09dC5sZW5ndGgpdGhyb3cgRXJyb3IoXCJDYW5ub3QgZ2V0IHJvd3MgYW5kIGNvbHVtbnMgb2YgYW4gZW1wdHkgc2hhcGUgYXJyYXkuXCIpO3JldHVyblt0Lmxlbmd0aD4xP3RbdC5sZW5ndGgtMl06MSx0W3QubGVuZ3RoLTFdXX0sZS5zaXplVG9TcXVhcmlzaFNoYXBlPWMsZS5nZXRCYXRjaERpbT1mdW5jdGlvbih0LGU9Mil7cmV0dXJuIHUodC5zbGljZSgwLHQubGVuZ3RoLWUpKX19LDQwNTc6KHQsZSxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUuY3JlYXRlVGV4dHVyZUxheW91dEZyb21TaGFwZT1lLmNhbGN1bGF0ZVRleHR1cmVXaWR0aEFuZEhlaWdodD1lLmNyZWF0ZVRleHR1cmVMYXlvdXRGcm9tVGV4dHVyZVR5cGU9dm9pZCAwO2NvbnN0IHI9bigyNTE3KSxpPW4oMjAzOSk7ZS5jcmVhdGVUZXh0dXJlTGF5b3V0RnJvbVRleHR1cmVUeXBlPSh0LG4scik9Pntjb25zdCBvPXI9PT1pLlRleHR1cmVUeXBlLnVucGFja2VkfHxyPT09aS5UZXh0dXJlVHlwZS51bnBhY2tlZFJldmVyc2VkPzE6NCxhPXI9PT1pLlRleHR1cmVUeXBlLnBhY2tlZCxzPXI9PT1pLlRleHR1cmVUeXBlLnVucGFja2VkUmV2ZXJzZWR8fHI9PT1pLlRleHR1cmVUeXBlLnBhY2tlZCx1PXI9PT1pLlRleHR1cmVUeXBlLnBhY2tlZExhc3REaW1lbnNpb24/bi5sZW5ndGgtMTp2b2lkIDAsYz1yPT09aS5UZXh0dXJlVHlwZS5wYWNrZWRMYXN0RGltZW5zaW9uP24ubWFwKCgodCxlKT0+ZT09PW4ubGVuZ3RoLTE/NCp0OnQpKTp2b2lkIDA7cmV0dXJuKDAsZS5jcmVhdGVUZXh0dXJlTGF5b3V0RnJvbVNoYXBlKSh0LG4sbyxjLHtpc1BhY2tlZDphLHJldmVyc2VXSDpzLGJyZWFrQXhpczp1fSl9LGUuY2FsY3VsYXRlVGV4dHVyZVdpZHRoQW5kSGVpZ2h0PSh0LG4scik9Pntjb25zdCBpPSgwLGUuY3JlYXRlVGV4dHVyZUxheW91dEZyb21UZXh0dXJlVHlwZSkodCxuLHIpO3JldHVybltpLndpZHRoLGkuaGVpZ2h0XX0sZS5jcmVhdGVUZXh0dXJlTGF5b3V0RnJvbVNoYXBlPSh0LGUsbj0xLGksbyk9Pntjb25zdCBhPSEoIW98fCFvLmlzUGFja2VkKSxbcyx1XT10LmNvbXB1dGVUZXh0dXJlV0goYSYmaXx8ZSxvKSxjPWUubGVuZ3RoO2xldCBsPWUuc2xpY2UoMCk7aWYoMD09PWMmJihsPVsxXSksMT09PW4paT1lO2Vsc2UgaWYoYSl7aWYoNCE9PW4pdGhyb3cgbmV3IEVycm9yKFwiYSBwYWNrZWQgdGV4dHVyZSBtdXN0IGJlIDQtY2hhbm5lbFwiKTtpPWUsYz4wJiYobFtjLTFdPU1hdGguY2VpbChsW2MtMV0vMikpLGM+MSYmKGxbYy0yXT1NYXRoLmNlaWwobFtjLTJdLzIpKX1lbHNlIGlmKCFpKXRocm93IG5ldyBFcnJvcihcIlVucGFja2VkIHNoYXBlIGlzIG5lZWRlZCB3aGVuIHVzaW5nIGNoYW5uZWxzID4gMVwiKTtyZXR1cm57d2lkdGg6cyxoZWlnaHQ6dSxjaGFubmVsczpuLGlzUGFja2VkOmEsc2hhcGU6bCxzdHJpZGVzOnIuU2hhcGVVdGlsLmNvbXB1dGVTdHJpZGVzKGwpLHVucGFja2VkU2hhcGU6aSxyZXZlcnNlZFdIOm8mJm8ucmV2ZXJzZVdIfX19LDU3MDI6KHQsZSxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUuVGV4dHVyZU1hbmFnZXI9dm9pZCAwO2NvbnN0IHI9bigzNjk0KTtlLlRleHR1cmVNYW5hZ2VyPWNsYXNze2NvbnN0cnVjdG9yKHQsZSxuLHIpe3RoaXMuZ2xDb250ZXh0PXQsdGhpcy5sYXlvdXRTdHJhdGVneT1lLHRoaXMucHJvZmlsZXI9bix0aGlzLmNvbmZpZz1yLHRoaXMucGVuZGluZ1JlYWQ9bmV3IE1hcCxyLnJldXNlVGV4dHVyZXMmJih0aGlzLmluVXNlVGV4dHVyZXM9bmV3IE1hcCx0aGlzLmlkbGVUZXh0dXJlcz1uZXcgTWFwLHRoaXMudGV4dHVyZUxvb2t1cD1uZXcgTWFwKX1jcmVhdGVUZXh0dXJlRnJvbUxheW91dCh0LGUsbixpKXtjb25zdCBvPXRoaXMudG9FbmNvZGVyVHlwZSh0KSxhPXRoaXMuZ2xDb250ZXh0LmdldEVuY29kZXIobyxlLmNoYW5uZWxzfHwxLGkpO2lmKGUuaXNQYWNrZWQmJjE9PT1pKXRocm93IG5ldyBFcnJvcihcIm5vdCBpbXBsZW1lbnRlZFwiKTtjb25zdCBzPWUud2lkdGgsdT1lLmhlaWdodDtsZXQgYyxsO2lmKHRoaXMuY29uZmlnLnJldXNlVGV4dHVyZXMpe2M9YCR7c314JHt1fV8ke2EuZm9ybWF0fV8ke2EuaW50ZXJuYWxGb3JtYXR9XyR7YS50ZXh0dXJlVHlwZX1gLGw9dGhpcy5pblVzZVRleHR1cmVzLmdldChjKSxsfHwobD1bXSx0aGlzLmluVXNlVGV4dHVyZXMuc2V0KGMsbCkpO2NvbnN0IGU9dGhpcy5pZGxlVGV4dHVyZXMuZ2V0KGMpO2lmKGUmJmUubGVuZ3RoPjApe2NvbnN0IHI9ZS5wb3AoKTtyZXR1cm4gbC5wdXNoKHIpLDE9PT1pJiZ0aGlzLmdsQ29udGV4dC51cGRhdGVUZXh0dXJlKHIscyx1LGEsdGhpcy50b1RleHR1cmVEYXRhKHQsbikpLHJ9fXIuTG9nZ2VyLnZlcmJvc2UoXCJUZXh0dXJlTWFuYWdlclwiLGBDcmVhdGluZyBuZXcgdGV4dHVyZSBvZiBzaXplICR7ZS53aWR0aH14JHtlLmhlaWdodH1gKTtjb25zdCBwPXRoaXMuZ2xDb250ZXh0LmFsbG9jYXRlVGV4dHVyZShzLHUsYSx0aGlzLnRvVGV4dHVyZURhdGEodCxuKSk7cmV0dXJuIHRoaXMuY29uZmlnLnJldXNlVGV4dHVyZXMmJihsLnB1c2gocCksdGhpcy50ZXh0dXJlTG9va3VwLnNldChwLGMpKSxwfXJlYWRUZXh0dXJlKHQsZSxuKXtyZXR1cm4gbnx8KG49MSksdGhpcy5wcm9maWxlci5ldmVudChcImJhY2tlbmRcIixcIlRleHR1cmVNYW5hZ2VyLnJlYWRUZXh0dXJlXCIsKCgpPT57Y29uc3Qgcj10LnNoYXBlLnJlZHVjZSgoKHQsZSk9PnQqZSkpKm4saT10aGlzLmdsQ29udGV4dC5yZWFkVGV4dHVyZSh0LnRleHR1cmUsdC53aWR0aCx0LmhlaWdodCxyLHRoaXMudG9FbmNvZGVyVHlwZShlKSxuKTtyZXR1cm4gdGhpcy50b1RlbnNvckRhdGEoZSxpKX0pKX1hc3luYyByZWFkVGV4dHVyZUFzeW5jKHQsZSxuKXtjb25zdCByPXQudGVuc29yLmRhdGFJZDtpZihufHwobj0xKSx0aGlzLnBlbmRpbmdSZWFkLmhhcyhyKSl7Y29uc3QgdD10aGlzLnBlbmRpbmdSZWFkLmdldChyKTtyZXR1cm4gbmV3IFByb21pc2UoKGU9Pm51bGw9PXQ/dm9pZCAwOnQucHVzaChlKSkpfXJldHVybiB0aGlzLnByb2ZpbGVyLmV2ZW50KFwiYmFja2VuZFwiLFwiVGV4dHVyZU1hbmFnZXIucmVhZFRleHR1cmVBc3luY1wiLChhc3luYygpPT57dGhpcy5wZW5kaW5nUmVhZC5zZXQocixbXSk7Y29uc3QgaT10LnNoYXBlLnJlZHVjZSgoKHQsZSk9PnQqZSkpKm47YXdhaXQgdGhpcy5nbENvbnRleHQuY3JlYXRlQW5kV2FpdEZvckZlbmNlKCk7Y29uc3Qgbz10aGlzLmdsQ29udGV4dC5yZWFkVGV4dHVyZSh0LnRleHR1cmUsdC53aWR0aCx0LmhlaWdodCxpLHRoaXMudG9FbmNvZGVyVHlwZShlKSxuKSxhPXRoaXMudG9UZW5zb3JEYXRhKGUsbykscz10aGlzLnBlbmRpbmdSZWFkLmdldChyKTtyZXR1cm4gdGhpcy5wZW5kaW5nUmVhZC5kZWxldGUociksbnVsbD09c3x8cy5mb3JFYWNoKCh0PT50KGEpKSksYX0pKX1yZWFkVWludDhUZXh0dXJlQXNGbG9hdCh0KXtyZXR1cm4gdGhpcy5wcm9maWxlci5ldmVudChcImJhY2tlbmRcIixcIlRleHR1cmVNYW5hZ2VyLnJlYWRVaW50OFRleHR1cmVBc0Zsb2F0XCIsKCgpPT57Y29uc3QgZT10LnNoYXBlLnJlZHVjZSgoKHQsZSk9PnQqZSkpLG49dGhpcy5nbENvbnRleHQucmVhZFRleHR1cmUodC50ZXh0dXJlLHQud2lkdGgsdC5oZWlnaHQsNCplLFwiYnl0ZVwiLDQpO3JldHVybiBuZXcgRmxvYXQzMkFycmF5KG4uYnVmZmVyLG4uYnl0ZU9mZnNldCxlKX0pKX1yZWxlYXNlVGV4dHVyZSh0LGUpe2xldCBuO2lmKHRoaXMuY29uZmlnLnJldXNlVGV4dHVyZXMmJihuPXRoaXMudGV4dHVyZUxvb2t1cC5nZXQodC50ZXh0dXJlKSxuKSl7ZSYmdGhpcy50ZXh0dXJlTG9va3VwLmRlbGV0ZShuKTtjb25zdCByPXRoaXMuaW5Vc2VUZXh0dXJlcy5nZXQobik7aWYocil7Y29uc3QgZT1yLmluZGV4T2YodC50ZXh0dXJlKTtpZigtMSE9PWUpe3Iuc3BsaWNlKGUsMSk7bGV0IGk9dGhpcy5pZGxlVGV4dHVyZXMuZ2V0KG4pO2l8fChpPVtdLHRoaXMuaWRsZVRleHR1cmVzLnNldChuLGkpKSxpLnB1c2godC50ZXh0dXJlKX19fW4mJiFlfHwoci5Mb2dnZXIudmVyYm9zZShcIlRleHR1cmVNYW5hZ2VyXCIsYERlbGV0aW5nIHRleHR1cmUgb2Ygc2l6ZSAke3Qud2lkdGh9eCR7dC5oZWlnaHR9YCksdGhpcy5nbENvbnRleHQuZGVsZXRlVGV4dHVyZSh0LnRleHR1cmUpKX10b1RlbnNvckRhdGEodCxlKXtzd2l0Y2godCl7Y2FzZVwiaW50MTZcIjpyZXR1cm4gZSBpbnN0YW5jZW9mIEludDE2QXJyYXk/ZTpJbnQxNkFycmF5LmZyb20oZSk7Y2FzZVwiaW50MzJcIjpyZXR1cm4gZSBpbnN0YW5jZW9mIEludDMyQXJyYXk/ZTpJbnQzMkFycmF5LmZyb20oZSk7Y2FzZVwiaW50OFwiOnJldHVybiBlIGluc3RhbmNlb2YgSW50OEFycmF5P2U6SW50OEFycmF5LmZyb20oZSk7Y2FzZVwidWludDE2XCI6cmV0dXJuIGUgaW5zdGFuY2VvZiBVaW50MTZBcnJheT9lOlVpbnQxNkFycmF5LmZyb20oZSk7Y2FzZVwidWludDMyXCI6cmV0dXJuIGUgaW5zdGFuY2VvZiBVaW50MzJBcnJheT9lOlVpbnQzMkFycmF5LmZyb20oZSk7Y2FzZVwidWludDhcIjpjYXNlXCJib29sXCI6cmV0dXJuIGUgaW5zdGFuY2VvZiBVaW50OEFycmF5P2U6VWludDhBcnJheS5mcm9tKGUpO2Nhc2VcImZsb2F0MzJcIjpyZXR1cm4gZSBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheT9lOkZsb2F0MzJBcnJheS5mcm9tKGUpO2Nhc2VcImZsb2F0NjRcIjpyZXR1cm4gZSBpbnN0YW5jZW9mIEZsb2F0NjRBcnJheT9lOkZsb2F0NjRBcnJheS5mcm9tKGUpO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBUZW5zb3JEYXRhIHR5cGUgJHt0fSBpcyBub3Qgc3VwcG9ydGVkYCl9fXRvVGV4dHVyZURhdGEodCxlKXtpZihlKXJldHVybiBlIGluc3RhbmNlb2YgRmxvYXQzMkFycmF5P2U6bmV3IEZsb2F0MzJBcnJheShlKX10b0VuY29kZXJUeXBlKHQpe3JldHVyblwiZmxvYXRcIn1jbGVhckFjdGl2ZVRleHR1cmVzKCl7dGhpcy5nbENvbnRleHQuY2xlYXJBY3RpdmVUZXh0dXJlcygpfX19LDIwMzk6KHQsZSk9PntcInVzZSBzdHJpY3RcIjt2YXIgbjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLlRleHR1cmVUeXBlPXZvaWQgMCwobj1lLlRleHR1cmVUeXBlfHwoZS5UZXh0dXJlVHlwZT17fSkpW24udW5wYWNrZWQ9MF09XCJ1bnBhY2tlZFwiLG5bbi51bnBhY2tlZFJldmVyc2VkPTFdPVwidW5wYWNrZWRSZXZlcnNlZFwiLG5bbi5wYWNrZWQ9Ml09XCJwYWNrZWRcIixuW24uZG93bmxvYWRVaW50OEFzRmxvYXQ9M109XCJkb3dubG9hZFVpbnQ4QXNGbG9hdFwiLG5bbi5wYWNrZWRMYXN0RGltZW5zaW9uPTRdPVwicGFja2VkTGFzdERpbWVuc2lvblwifSw5MzkwOih0LGUsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLmdldEdsQ2hhbm5lbHM9ZS5nZXRDb29yZHNEYXRhVHlwZT1lLmdldFNxdWVlemVkUGFyYW1zPWUuc3F1ZWV6ZUlucHV0U2hhcGU9ZS5nZW5lcmF0ZVNoYWRlckZ1bmNOYW1lRnJvbUlucHV0U2FtcGxlck5hbWVBdE91dENvb3Jkcz1lLmdlbmVyYXRlU2hhZGVyRnVuY05hbWVGcm9tSW5wdXRTYW1wbGVyTmFtZT1lLnJlcGVhdGVkVHJ5PWUuZ2V0UGFja2VkU2hhcGU9dm9pZCAwO2NvbnN0IHI9bigyNTE3KTtlLmdldFBhY2tlZFNoYXBlPWZ1bmN0aW9uKHQpe2NvbnN0IGU9dC5sZW5ndGg7cmV0dXJuIHQuc2xpY2UoMCxlLTEpLmNvbmNhdCh0W2UtMV0vNCl9LGUucmVwZWF0ZWRUcnk9YXN5bmMgZnVuY3Rpb24odCxlPSh0PT4wKSxuKXtyZXR1cm4gbmV3IFByb21pc2UoKChyLGkpPT57bGV0IG89MDtjb25zdCBhPSgpPT57aWYodCgpKXJldHVybiB2b2lkIHIoKTtvKys7Y29uc3Qgcz1lKG8pO251bGwhPW4mJm8+PW4/aSgpOnNldFRpbWVvdXQoYSxzKX07YSgpfSkpfSxlLmdlbmVyYXRlU2hhZGVyRnVuY05hbWVGcm9tSW5wdXRTYW1wbGVyTmFtZT1mdW5jdGlvbih0KXtyZXR1cm4oMCxyLmFzc2VydCkodm9pZCAwIT09dCYmMCE9PXQubGVuZ3RoLCgoKT0+XCJlbXB0eSBzdHJpbmcgZm91bmQgZm9yIHNhbXBsZXIgbmFtZVwiKSksXCJnZXRcIit0LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpK3Quc2xpY2UoMSl9LGUuZ2VuZXJhdGVTaGFkZXJGdW5jTmFtZUZyb21JbnB1dFNhbXBsZXJOYW1lQXRPdXRDb29yZHM9ZnVuY3Rpb24odCl7cmV0dXJuKDAsci5hc3NlcnQpKHZvaWQgMCE9PXQmJjAhPT10Lmxlbmd0aCwoKCk9PlwiZW1wdHkgc3RyaW5nIGZvdW5kIGZvciBzYW1wbGVyIG5hbWVcIikpLFwiZ2V0XCIrdC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSt0LnNsaWNlKDEpK1wiQXRPdXRDb29yZHNcIn0sZS5zcXVlZXplSW5wdXRTaGFwZT1mdW5jdGlvbih0LGUpe2xldCBuPUpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkodCkpO3JldHVybiBuPWUsbn0sZS5nZXRTcXVlZXplZFBhcmFtcz1mdW5jdGlvbih0LGUpe3JldHVybiBlLm1hcCgoZT0+dFtlXSkpLmpvaW4oXCIsIFwiKX0sZS5nZXRDb29yZHNEYXRhVHlwZT1mdW5jdGlvbih0KXtpZih0PD0xKXJldHVyblwiaW50XCI7aWYoMj09PXQpcmV0dXJuXCJpdmVjMlwiO2lmKDM9PT10KXJldHVyblwiaXZlYzNcIjtpZig0PT09dClyZXR1cm5cIml2ZWM0XCI7aWYoNT09PXQpcmV0dXJuXCJpdmVjNVwiO2lmKDY9PT10KXJldHVyblwiaXZlYzZcIjt0aHJvdyBFcnJvcihgR1BVIGZvciByYW5rICR7dH0gaXMgbm90IHlldCBzdXBwb3J0ZWRgKX0sZS5nZXRHbENoYW5uZWxzPWZ1bmN0aW9uKHQ9Nil7cmV0dXJuW1wieFwiLFwieVwiLFwielwiLFwid1wiLFwidVwiLFwidlwiXS5zbGljZSgwLHQpfX0sNzMwNToodCxlLG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5jcmVhdGVOZXdXZWJHTENvbnRleHQ9ZS5jcmVhdGVXZWJHTENvbnRleHQ9dm9pZCAwO2NvbnN0IHI9bigzNjk0KSxpPW4oMTcxMyksbz17fTtmdW5jdGlvbiBhKHQpe2NvbnN0IGU9ZnVuY3Rpb24oKXtpZihcInVuZGVmaW5lZFwiPT10eXBlb2YgZG9jdW1lbnQpe2lmKFwidW5kZWZpbmVkXCI9PXR5cGVvZiBPZmZzY3JlZW5DYW52YXMpdGhyb3cgbmV3IFR5cGVFcnJvcihcImZhaWxlZCB0byBjcmVhdGUgY2FudmFzOiBPZmZzY3JlZW5DYW52YXMgaXMgbm90IHN1cHBvcnRlZFwiKTtyZXR1cm4gbmV3IE9mZnNjcmVlbkNhbnZhcygxLDEpfWNvbnN0IHQ9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtyZXR1cm4gdC53aWR0aD0xLHQuaGVpZ2h0PTEsdH0oKTtsZXQgbjtjb25zdCBvPXthbHBoYTohMSxkZXB0aDohMSxhbnRpYWxpYXM6ITEsc3RlbmNpbDohMSxwcmVzZXJ2ZURyYXdpbmdCdWZmZXI6ITEscHJlbXVsdGlwbGllZEFscGhhOiExLGZhaWxJZk1ham9yUGVyZm9ybWFuY2VDYXZlYXQ6ITF9O2lmKCghdHx8XCJ3ZWJnbDJcIj09PXQpJiYobj1lLmdldENvbnRleHQoXCJ3ZWJnbDJcIixvKSxuKSl0cnl7cmV0dXJuIG5ldyBpLldlYkdMQ29udGV4dChuLDIpfWNhdGNoKHQpe3IuTG9nZ2VyLndhcm5pbmcoXCJHbENvbnRleHRGYWN0b3J5XCIsYGZhaWxlZCB0byBjcmVhdGUgV2ViR0xDb250ZXh0IHVzaW5nIGNvbnRleHRJZCAnd2ViZ2wyJy4gRXJyb3I6ICR7dH1gKX1pZigoIXR8fFwid2ViZ2xcIj09PXQpJiYobj1lLmdldENvbnRleHQoXCJ3ZWJnbFwiLG8pfHxlLmdldENvbnRleHQoXCJleHBlcmltZW50YWwtd2ViZ2xcIixvKSxuKSl0cnl7cmV0dXJuIG5ldyBpLldlYkdMQ29udGV4dChuLDEpfWNhdGNoKHQpe3IuTG9nZ2VyLndhcm5pbmcoXCJHbENvbnRleHRGYWN0b3J5XCIsYGZhaWxlZCB0byBjcmVhdGUgV2ViR0xDb250ZXh0IHVzaW5nIGNvbnRleHRJZCAnd2ViZ2wnIG9yICdleHBlcmltZW50YWwtd2ViZ2wnLiBFcnJvcjogJHt0fWApfXRocm93IG5ldyBFcnJvcihcIldlYkdMIGlzIG5vdCBzdXBwb3J0ZWRcIil9ZS5jcmVhdGVXZWJHTENvbnRleHQ9ZnVuY3Rpb24gdChlKXtsZXQgbjtlJiZcIndlYmdsMlwiIT09ZXx8IShcIndlYmdsMlwiaW4gbyk/ZSYmXCJ3ZWJnbFwiIT09ZXx8IShcIndlYmdsXCJpbiBvKXx8KG49by53ZWJnbCk6bj1vLndlYmdsMixuPW58fGEoZSksZT1lfHwxPT09bi52ZXJzaW9uP1wid2ViZ2xcIjpcIndlYmdsMlwiO2NvbnN0IHI9bi5nbDtyZXR1cm4gb1tlXT1uLHIuaXNDb250ZXh0TG9zdCgpPyhkZWxldGUgb1tlXSx0KGUpKTooci5kaXNhYmxlKHIuREVQVEhfVEVTVCksci5kaXNhYmxlKHIuU1RFTkNJTF9URVNUKSxyLmRpc2FibGUoci5CTEVORCksci5kaXNhYmxlKHIuRElUSEVSKSxyLmRpc2FibGUoci5QT0xZR09OX09GRlNFVF9GSUxMKSxyLmRpc2FibGUoci5TQU1QTEVfQ09WRVJBR0UpLHIuZW5hYmxlKHIuU0NJU1NPUl9URVNUKSxyLmVuYWJsZShyLkNVTExfRkFDRSksci5jdWxsRmFjZShyLkJBQ0spLG4pfSxlLmNyZWF0ZU5ld1dlYkdMQ29udGV4dD1hfSwxNzEzOmZ1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjt2YXIgcj10aGlzJiZ0aGlzLl9fY3JlYXRlQmluZGluZ3x8KE9iamVjdC5jcmVhdGU/ZnVuY3Rpb24odCxlLG4scil7dm9pZCAwPT09ciYmKHI9bik7dmFyIGk9T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLG4pO2kmJiEoXCJnZXRcImluIGk/IWUuX19lc01vZHVsZTppLndyaXRhYmxlfHxpLmNvbmZpZ3VyYWJsZSl8fChpPXtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBlW25dfX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LHIsaSl9OmZ1bmN0aW9uKHQsZSxuLHIpe3ZvaWQgMD09PXImJihyPW4pLHRbcl09ZVtuXX0pLGk9dGhpcyYmdGhpcy5fX3NldE1vZHVsZURlZmF1bHR8fChPYmplY3QuY3JlYXRlP2Z1bmN0aW9uKHQsZSl7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJkZWZhdWx0XCIse2VudW1lcmFibGU6ITAsdmFsdWU6ZX0pfTpmdW5jdGlvbih0LGUpe3QuZGVmYXVsdD1lfSksbz10aGlzJiZ0aGlzLl9faW1wb3J0U3Rhcnx8ZnVuY3Rpb24odCl7aWYodCYmdC5fX2VzTW9kdWxlKXJldHVybiB0O3ZhciBlPXt9O2lmKG51bGwhPXQpZm9yKHZhciBuIGluIHQpXCJkZWZhdWx0XCIhPT1uJiZPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCxuKSYmcihlLHQsbik7cmV0dXJuIGkoZSx0KSxlfTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLldlYkdMQ29udGV4dD1lLmxpbmVhclNlYXJjaExhc3RUcnVlPXZvaWQgMDtjb25zdCBhPW4oNjIwNykscz1vKG4oNzc2OSkpLHU9big5MzkwKTtmdW5jdGlvbiBjKHQpe2xldCBlPTA7Zm9yKDtlPHQubGVuZ3RoJiZ0W2VdKCk7KytlKTtyZXR1cm4gZS0xfWUubGluZWFyU2VhcmNoTGFzdFRydWU9YyxlLldlYkdMQ29udGV4dD1jbGFzc3tjb25zdHJ1Y3Rvcih0LGUpe3RoaXMuZnJhbWVCdWZmZXJCb3VuZD0hMSx0aGlzLml0ZW1zVG9Qb2xsPVtdLHRoaXMuZ2w9dCx0aGlzLnZlcnNpb249ZSx0aGlzLmdldEV4dGVuc2lvbnMoKSx0aGlzLnZlcnRleGJ1ZmZlcj10aGlzLmNyZWF0ZVZlcnRleGJ1ZmZlcigpLHRoaXMuZnJhbWVidWZmZXI9dGhpcy5jcmVhdGVGcmFtZWJ1ZmZlcigpLHRoaXMucXVlcnlWaXRhbFBhcmFtZXRlcnMoKX1hbGxvY2F0ZVRleHR1cmUodCxlLG4scil7Y29uc3QgaT10aGlzLmdsLG89aS5jcmVhdGVUZXh0dXJlKCk7aS5iaW5kVGV4dHVyZShpLlRFWFRVUkVfMkQsbyksaS50ZXhQYXJhbWV0ZXJpKGkuVEVYVFVSRV8yRCxpLlRFWFRVUkVfTUlOX0ZJTFRFUixpLk5FQVJFU1QpLGkudGV4UGFyYW1ldGVyaShpLlRFWFRVUkVfMkQsaS5URVhUVVJFX01BR19GSUxURVIsaS5ORUFSRVNUKSxpLnRleFBhcmFtZXRlcmkoaS5URVhUVVJFXzJELGkuVEVYVFVSRV9XUkFQX1MsaS5DTEFNUF9UT19FREdFKSxpLnRleFBhcmFtZXRlcmkoaS5URVhUVVJFXzJELGkuVEVYVFVSRV9XUkFQX1QsaS5DTEFNUF9UT19FREdFKTtjb25zdCBhPXI/bi5lbmNvZGUocix0KmUpOm51bGw7cmV0dXJuIGkudGV4SW1hZ2UyRChpLlRFWFRVUkVfMkQsMCxuLmludGVybmFsRm9ybWF0LHQsZSwwLG4uZm9ybWF0LG4udGV4dHVyZVR5cGUsYSksdGhpcy5jaGVja0Vycm9yKCksb311cGRhdGVUZXh0dXJlKHQsZSxuLHIsaSl7Y29uc3Qgbz10aGlzLmdsO28uYmluZFRleHR1cmUoby5URVhUVVJFXzJELHQpO2NvbnN0IGE9ci5lbmNvZGUoaSxlKm4pO28udGV4U3ViSW1hZ2UyRChvLlRFWFRVUkVfMkQsMCwwLDAsZSxuLHIuZm9ybWF0LHIudGV4dHVyZVR5cGUsYSksdGhpcy5jaGVja0Vycm9yKCl9YXR0YWNoRnJhbWVidWZmZXIodCxlLG4pe2NvbnN0IHI9dGhpcy5nbDtyLmJpbmRUZXh0dXJlKHIuVEVYVFVSRV8yRCx0KSxyLmJpbmRGcmFtZWJ1ZmZlcihyLkZSQU1FQlVGRkVSLHRoaXMuZnJhbWVidWZmZXIpLHIuZnJhbWVidWZmZXJUZXh0dXJlMkQoci5GUkFNRUJVRkZFUixyLkNPTE9SX0FUVEFDSE1FTlQwLHIuVEVYVFVSRV8yRCx0LDApLHRoaXMuY2hlY2tFcnJvcigpLHIudmlld3BvcnQoMCwwLGUsbiksci5zY2lzc29yKDAsMCxlLG4pfXJlYWRUZXh0dXJlKHQsZSxuLHIsaSxvKXtjb25zdCBhPXRoaXMuZ2w7b3x8KG89MSksdGhpcy5mcmFtZUJ1ZmZlckJvdW5kfHx0aGlzLmF0dGFjaEZyYW1lYnVmZmVyKHQsZSxuKTtjb25zdCBzPXRoaXMuZ2V0RW5jb2RlcihpLG8pLHU9cy5hbGxvY2F0ZShlKm4pO3JldHVybiBhLmJpbmRUZXh0dXJlKGEuVEVYVFVSRV8yRCx0KSxhLmZyYW1lYnVmZmVyVGV4dHVyZTJEKGEuRlJBTUVCVUZGRVIsYS5DT0xPUl9BVFRBQ0hNRU5UMCxhLlRFWFRVUkVfMkQsdCwwKSxhLnJlYWRQaXhlbHMoMCwwLGUsbixhLlJHQkEscy50ZXh0dXJlVHlwZSx1KSx0aGlzLmNoZWNrRXJyb3IoKSxzLmRlY29kZSh1LHIpfWlzRnJhbWVidWZmZXJSZWFkeSgpe3JldHVybiEwfWdldEFjdGl2ZVRleHR1cmUoKXtjb25zdCB0PXRoaXMuZ2w7cmV0dXJuXCJURVhUVVJFXCIrKHQuZ2V0UGFyYW1ldGVyKHRoaXMuZ2wuQUNUSVZFX1RFWFRVUkUpLXQuVEVYVFVSRTApfWdldFRleHR1cmVCaW5kaW5nKCl7cmV0dXJuIHRoaXMuZ2wuZ2V0UGFyYW1ldGVyKHRoaXMuZ2wuVEVYVFVSRV9CSU5ESU5HXzJEKX1nZXRGcmFtZWJ1ZmZlckJpbmRpbmcoKXtyZXR1cm4gdGhpcy5nbC5nZXRQYXJhbWV0ZXIodGhpcy5nbC5GUkFNRUJVRkZFUl9CSU5ESU5HKX1zZXRWZXJ0ZXhBdHRyaWJ1dGVzKHQsZSl7Y29uc3Qgbj10aGlzLmdsO24udmVydGV4QXR0cmliUG9pbnRlcih0LDMsbi5GTE9BVCwhMSwyMCwwKSxuLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHQpLC0xIT09ZSYmKG4udmVydGV4QXR0cmliUG9pbnRlcihlLDIsbi5GTE9BVCwhMSwyMCwxMiksbi5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShlKSksdGhpcy5jaGVja0Vycm9yKCl9Y3JlYXRlUHJvZ3JhbSh0LGUpe2NvbnN0IG49dGhpcy5nbCxyPW4uY3JlYXRlUHJvZ3JhbSgpO3JldHVybiBuLmF0dGFjaFNoYWRlcihyLHQpLG4uYXR0YWNoU2hhZGVyKHIsZSksbi5saW5rUHJvZ3JhbShyKSxyfWNvbXBpbGVTaGFkZXIodCxlKXtjb25zdCBuPXRoaXMuZ2wscj1uLmNyZWF0ZVNoYWRlcihlKTtpZighcil0aHJvdyBuZXcgRXJyb3IoYGNyZWF0ZVNoYWRlcigpIHJldHVybmVkIG51bGwgd2l0aCB0eXBlICR7ZX1gKTtpZihuLnNoYWRlclNvdXJjZShyLHQpLG4uY29tcGlsZVNoYWRlcihyKSwhMT09PW4uZ2V0U2hhZGVyUGFyYW1ldGVyKHIsbi5DT01QSUxFX1NUQVRVUykpdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gY29tcGlsZSBzaGFkZXI6ICR7bi5nZXRTaGFkZXJJbmZvTG9nKHIpfVxcblNoYWRlciBzb3VyY2U6XFxuJHt0fWApO3JldHVybiByfWRlbGV0ZVNoYWRlcih0KXt0aGlzLmdsLmRlbGV0ZVNoYWRlcih0KX1iaW5kVGV4dHVyZVRvVW5pZm9ybSh0LGUsbil7Y29uc3Qgcj10aGlzLmdsO3IuYWN0aXZlVGV4dHVyZShyLlRFWFRVUkUwK2UpLHRoaXMuY2hlY2tFcnJvcigpLHIuYmluZFRleHR1cmUoci5URVhUVVJFXzJELHQpLHRoaXMuY2hlY2tFcnJvcigpLHIudW5pZm9ybTFpKG4sZSksdGhpcy5jaGVja0Vycm9yKCl9ZHJhdygpe3RoaXMuZ2wuZHJhd0FycmF5cyh0aGlzLmdsLlRSSUFOR0xFX1NUUklQLDAsNCksdGhpcy5jaGVja0Vycm9yKCl9Y2hlY2tFcnJvcigpe2lmKGEuZW52LmRlYnVnKXtjb25zdCB0PXRoaXMuZ2wsZT10LmdldEVycm9yKCk7bGV0IG49XCJcIjtzd2l0Y2goZSl7Y2FzZSB0Lk5PX0VSUk9SOnJldHVybjtjYXNlIHQuSU5WQUxJRF9FTlVNOm49XCJJTlZBTElEX0VOVU1cIjticmVhaztjYXNlIHQuSU5WQUxJRF9WQUxVRTpuPVwiSU5WQUxJRF9WQUxVRVwiO2JyZWFrO2Nhc2UgdC5JTlZBTElEX09QRVJBVElPTjpuPVwiSU5WQUxJRF9PUEVSQVRJT05cIjticmVhaztjYXNlIHQuSU5WQUxJRF9GUkFNRUJVRkZFUl9PUEVSQVRJT046bj1cIklOVkFMSURfRlJBTUVCVUZGRVJfT1BFUkFUSU9OXCI7YnJlYWs7Y2FzZSB0Lk9VVF9PRl9NRU1PUlk6bj1cIk9VVF9PRl9NRU1PUllcIjticmVhaztjYXNlIHQuQ09OVEVYVF9MT1NUX1dFQkdMOm49XCJDT05URVhUX0xPU1RfV0VCR0xcIjticmVhaztkZWZhdWx0Om49YFVua25vd24gV2ViR0wgRXJyb3I6ICR7ZS50b1N0cmluZygxNil9YH10aHJvdyBuZXcgRXJyb3Iobil9fWRlbGV0ZVRleHR1cmUodCl7dGhpcy5nbC5kZWxldGVUZXh0dXJlKHQpfWRlbGV0ZVByb2dyYW0odCl7dGhpcy5nbC5kZWxldGVQcm9ncmFtKHQpfWdldEVuY29kZXIodCxlLG49MCl7aWYoMj09PXRoaXMudmVyc2lvbilyZXR1cm4gbmV3IHMuUmVkRmxvYXQzMkRhdGFFbmNvZGVyKHRoaXMuZ2wsZSk7c3dpdGNoKHQpe2Nhc2VcImZsb2F0XCI6cmV0dXJuIDE9PT1ufHx0aGlzLmlzUmVuZGVyRmxvYXQzMlN1cHBvcnRlZD9uZXcgcy5SR0JBRmxvYXREYXRhRW5jb2Rlcih0aGlzLmdsLGUpOm5ldyBzLlJHQkFGbG9hdERhdGFFbmNvZGVyKHRoaXMuZ2wsZSx0aGlzLnRleHR1cmVIYWxmRmxvYXRFeHRlbnNpb24uSEFMRl9GTE9BVF9PRVMpO2Nhc2VcImludFwiOnRocm93IG5ldyBFcnJvcihcIm5vdCBpbXBsZW1lbnRlZFwiKTtjYXNlXCJieXRlXCI6cmV0dXJuIG5ldyBzLlVpbnQ4RGF0YUVuY29kZXIodGhpcy5nbCxlKTtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgSW52YWxpZCBkYXRhVHlwZTogJHt0fWApfX1jbGVhckFjdGl2ZVRleHR1cmVzKCl7Y29uc3QgdD10aGlzLmdsO2ZvcihsZXQgZT0wO2U8dGhpcy5tYXhUZXh0dXJlSW1hZ2VVbml0czsrK2UpdC5hY3RpdmVUZXh0dXJlKHQuVEVYVFVSRTArZSksdC5iaW5kVGV4dHVyZSh0LlRFWFRVUkVfMkQsbnVsbCl9ZGlzcG9zZSgpe2lmKHRoaXMuZGlzcG9zZWQpcmV0dXJuO2NvbnN0IHQ9dGhpcy5nbDt0LmJpbmRGcmFtZWJ1ZmZlcih0LkZSQU1FQlVGRkVSLG51bGwpLHQuZGVsZXRlRnJhbWVidWZmZXIodGhpcy5mcmFtZWJ1ZmZlciksdC5iaW5kQnVmZmVyKHQuQVJSQVlfQlVGRkVSLG51bGwpLHQuZGVsZXRlQnVmZmVyKHRoaXMudmVydGV4YnVmZmVyKSx0LmJpbmRCdWZmZXIodC5FTEVNRU5UX0FSUkFZX0JVRkZFUixudWxsKSx0LmZpbmlzaCgpLHRoaXMuZGlzcG9zZWQ9ITB9Y3JlYXRlRGVmYXVsdEdlb21ldHJ5KCl7cmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkoWy0xLDEsMCwwLDEsLTEsLTEsMCwwLDAsMSwxLDAsMSwxLDEsLTEsMCwxLDBdKX1jcmVhdGVWZXJ0ZXhidWZmZXIoKXtjb25zdCB0PXRoaXMuZ2wsZT10LmNyZWF0ZUJ1ZmZlcigpO2lmKCFlKXRocm93IG5ldyBFcnJvcihcImNyZWF0ZUJ1ZmZlcigpIHJldHVybmVkIG51bGxcIik7Y29uc3Qgbj10aGlzLmNyZWF0ZURlZmF1bHRHZW9tZXRyeSgpO3JldHVybiB0LmJpbmRCdWZmZXIodC5BUlJBWV9CVUZGRVIsZSksdC5idWZmZXJEYXRhKHQuQVJSQVlfQlVGRkVSLG4sdC5TVEFUSUNfRFJBVyksdGhpcy5jaGVja0Vycm9yKCksZX1jcmVhdGVGcmFtZWJ1ZmZlcigpe2NvbnN0IHQ9dGhpcy5nbC5jcmVhdGVGcmFtZWJ1ZmZlcigpO2lmKCF0KXRocm93IG5ldyBFcnJvcihcImNyZWF0ZUZyYW1lYnVmZmVyIHJldHVybmVkIG51bGxcIik7cmV0dXJuIHR9cXVlcnlWaXRhbFBhcmFtZXRlcnMoKXtjb25zdCB0PXRoaXMuZ2w7aWYodGhpcy5pc0Zsb2F0VGV4dHVyZUF0dGFjaGFibGVUb0ZyYW1lQnVmZmVyPXRoaXMuY2hlY2tGbG9hdFRleHR1cmVBdHRhY2hhYmxlVG9GcmFtZUJ1ZmZlcigpLHRoaXMuaXNSZW5kZXJGbG9hdDMyU3VwcG9ydGVkPXRoaXMuY2hlY2tSZW5kZXJGbG9hdDMyKCksdGhpcy5pc0Zsb2F0MzJEb3dubG9hZFN1cHBvcnRlZD10aGlzLmNoZWNrRmxvYXQzMkRvd25sb2FkKCksMT09PXRoaXMudmVyc2lvbiYmIXRoaXMudGV4dHVyZUhhbGZGbG9hdEV4dGVuc2lvbiYmIXRoaXMuaXNSZW5kZXJGbG9hdDMyU3VwcG9ydGVkKXRocm93IG5ldyBFcnJvcihcImJvdGggZmxvYXQzMiBhbmQgZmxvYXQxNiBUZXh0dXJlVHlwZSBhcmUgbm90IHN1cHBvcnRlZFwiKTt0aGlzLmlzQmxlbmRTdXBwb3J0ZWQ9IXRoaXMuaXNSZW5kZXJGbG9hdDMyU3VwcG9ydGVkfHx0aGlzLmNoZWNrRmxvYXQzMkJsZW5kKCksdGhpcy5tYXhUZXh0dXJlU2l6ZT10LmdldFBhcmFtZXRlcih0Lk1BWF9URVhUVVJFX1NJWkUpLHRoaXMubWF4VGV4dHVyZUltYWdlVW5pdHM9dC5nZXRQYXJhbWV0ZXIodC5NQVhfVEVYVFVSRV9JTUFHRV9VTklUUyksdGhpcy52ZXJzaW9ufWdldEV4dGVuc2lvbnMoKXsyPT09dGhpcy52ZXJzaW9uPyh0aGlzLmNvbG9yQnVmZmVyRmxvYXRFeHRlbnNpb249dGhpcy5nbC5nZXRFeHRlbnNpb24oXCJFWFRfY29sb3JfYnVmZmVyX2Zsb2F0XCIpLHRoaXMuZGlzam9pbnRUaW1lclF1ZXJ5V2ViZ2wyRXh0ZW5zaW9uPXRoaXMuZ2wuZ2V0RXh0ZW5zaW9uKFwiRVhUX2Rpc2pvaW50X3RpbWVyX3F1ZXJ5X3dlYmdsMlwiKSk6KHRoaXMudGV4dHVyZUZsb2F0RXh0ZW5zaW9uPXRoaXMuZ2wuZ2V0RXh0ZW5zaW9uKFwiT0VTX3RleHR1cmVfZmxvYXRcIiksdGhpcy50ZXh0dXJlSGFsZkZsb2F0RXh0ZW5zaW9uPXRoaXMuZ2wuZ2V0RXh0ZW5zaW9uKFwiT0VTX3RleHR1cmVfaGFsZl9mbG9hdFwiKSl9Y2hlY2tGbG9hdFRleHR1cmVBdHRhY2hhYmxlVG9GcmFtZUJ1ZmZlcigpe2NvbnN0IHQ9dGhpcy5nbCxlPXQuY3JlYXRlVGV4dHVyZSgpO3QuYmluZFRleHR1cmUodC5URVhUVVJFXzJELGUpO2NvbnN0IG49Mj09PXRoaXMudmVyc2lvbj90LlJHQkEzMkY6dC5SR0JBO3QudGV4SW1hZ2UyRCh0LlRFWFRVUkVfMkQsMCxuLDEsMSwwLHQuUkdCQSx0LkZMT0FULG51bGwpO2NvbnN0IHI9dC5jcmVhdGVGcmFtZWJ1ZmZlcigpO3QuYmluZEZyYW1lYnVmZmVyKHQuRlJBTUVCVUZGRVIsciksdC5mcmFtZWJ1ZmZlclRleHR1cmUyRCh0LkZSQU1FQlVGRkVSLHQuQ09MT1JfQVRUQUNITUVOVDAsdC5URVhUVVJFXzJELGUsMCk7Y29uc3QgaT10LmNoZWNrRnJhbWVidWZmZXJTdGF0dXModC5GUkFNRUJVRkZFUik9PT10LkZSQU1FQlVGRkVSX0NPTVBMRVRFO3JldHVybiB0LmJpbmRUZXh0dXJlKHQuVEVYVFVSRV8yRCxudWxsKSx0LmJpbmRGcmFtZWJ1ZmZlcih0LkZSQU1FQlVGRkVSLG51bGwpLHQuZGVsZXRlVGV4dHVyZShlKSx0LmRlbGV0ZUZyYW1lYnVmZmVyKHIpLGl9Y2hlY2tSZW5kZXJGbG9hdDMyKCl7aWYoMj09PXRoaXMudmVyc2lvbil7aWYoIXRoaXMuY29sb3JCdWZmZXJGbG9hdEV4dGVuc2lvbilyZXR1cm4hMX1lbHNlIGlmKCF0aGlzLnRleHR1cmVGbG9hdEV4dGVuc2lvbilyZXR1cm4hMTtyZXR1cm4gdGhpcy5pc0Zsb2F0VGV4dHVyZUF0dGFjaGFibGVUb0ZyYW1lQnVmZmVyfWNoZWNrRmxvYXQzMkRvd25sb2FkKCl7aWYoMj09PXRoaXMudmVyc2lvbil7aWYoIXRoaXMuY29sb3JCdWZmZXJGbG9hdEV4dGVuc2lvbilyZXR1cm4hMX1lbHNle2lmKCF0aGlzLnRleHR1cmVGbG9hdEV4dGVuc2lvbilyZXR1cm4hMTtpZighdGhpcy5nbC5nZXRFeHRlbnNpb24oXCJXRUJHTF9jb2xvcl9idWZmZXJfZmxvYXRcIikpcmV0dXJuITF9cmV0dXJuIHRoaXMuaXNGbG9hdFRleHR1cmVBdHRhY2hhYmxlVG9GcmFtZUJ1ZmZlcn1jaGVja0Zsb2F0MzJCbGVuZCgpe2NvbnN0IHQ9dGhpcy5nbDtsZXQgZSxuLHIsaSxvO3RyeXtlPXQuY3JlYXRlVGV4dHVyZSgpLG49dC5jcmVhdGVGcmFtZWJ1ZmZlcigpLHQuYmluZFRleHR1cmUodC5URVhUVVJFXzJELGUpO2NvbnN0IGE9Mj09PXRoaXMudmVyc2lvbj90LlJHQkEzMkY6dC5SR0JBO3JldHVybiB0LnRleEltYWdlMkQodC5URVhUVVJFXzJELDAsYSwxLDEsMCx0LlJHQkEsdC5GTE9BVCxudWxsKSx0LmJpbmRGcmFtZWJ1ZmZlcih0LkZSQU1FQlVGRkVSLG4pLHQuZnJhbWVidWZmZXJUZXh0dXJlMkQodC5GUkFNRUJVRkZFUix0LkNPTE9SX0FUVEFDSE1FTlQwLHQuVEVYVFVSRV8yRCxlLDApLHQuZW5hYmxlKHQuQkxFTkQpLHI9dC5jcmVhdGVTaGFkZXIodC5WRVJURVhfU0hBREVSKSwhIXImJih0LnNoYWRlclNvdXJjZShyLFwidm9pZCBtYWluKCl7fVwiKSx0LmNvbXBpbGVTaGFkZXIociksaT10LmNyZWF0ZVNoYWRlcih0LkZSQUdNRU5UX1NIQURFUiksISFpJiYodC5zaGFkZXJTb3VyY2UoaSxcInByZWNpc2lvbiBoaWdocCBmbG9hdDt2b2lkIG1haW4oKXtnbF9GcmFnQ29sb3I9dmVjNCgwLjUpO31cIiksdC5jb21waWxlU2hhZGVyKGkpLG89dC5jcmVhdGVQcm9ncmFtKCksISFvJiYodC5hdHRhY2hTaGFkZXIobyxyKSx0LmF0dGFjaFNoYWRlcihvLGkpLHQubGlua1Byb2dyYW0obyksdC51c2VQcm9ncmFtKG8pLHQuZHJhd0FycmF5cyh0LlBPSU5UUywwLDEpLHQuZ2V0RXJyb3IoKT09PXQuTk9fRVJST1IpKSl9ZmluYWxseXt0LmRpc2FibGUodC5CTEVORCksbyYmdC5kZWxldGVQcm9ncmFtKG8pLHImJnQuZGVsZXRlU2hhZGVyKHIpLGkmJnQuZGVsZXRlU2hhZGVyKGkpLG4mJih0LmJpbmRGcmFtZWJ1ZmZlcih0LkZSQU1FQlVGRkVSLG51bGwpLHQuZGVsZXRlRnJhbWVidWZmZXIobikpLGUmJih0LmJpbmRUZXh0dXJlKHQuVEVYVFVSRV8yRCxudWxsKSx0LmRlbGV0ZVRleHR1cmUoZSkpfX1iZWdpblRpbWVyKCl7aWYoMj09PXRoaXMudmVyc2lvbiYmdGhpcy5kaXNqb2ludFRpbWVyUXVlcnlXZWJnbDJFeHRlbnNpb24pe2NvbnN0IHQ9dGhpcy5nbCxlPXRoaXMuZGlzam9pbnRUaW1lclF1ZXJ5V2ViZ2wyRXh0ZW5zaW9uLG49dC5jcmVhdGVRdWVyeSgpO3JldHVybiB0LmJlZ2luUXVlcnkoZS5USU1FX0VMQVBTRURfRVhULG4pLG59dGhyb3cgbmV3IEVycm9yKFwiV2ViR0wxIHByb2ZpbGluZyBjdXJyZW50bHkgbm90IHN1cHBvcnRlZC5cIil9ZW5kVGltZXIoKXtpZigyIT09dGhpcy52ZXJzaW9ufHwhdGhpcy5kaXNqb2ludFRpbWVyUXVlcnlXZWJnbDJFeHRlbnNpb24pdGhyb3cgbmV3IEVycm9yKFwiV2ViR0wxIHByb2ZpbGluZyBjdXJyZW50bHkgbm90IHN1cHBvcnRlZFwiKTt7Y29uc3QgdD10aGlzLmdsLGU9dGhpcy5kaXNqb2ludFRpbWVyUXVlcnlXZWJnbDJFeHRlbnNpb247dC5lbmRRdWVyeShlLlRJTUVfRUxBUFNFRF9FWFQpfX1pc1RpbWVyUmVzdWx0QXZhaWxhYmxlKHQpe2xldCBlPSExLG49ITE7aWYoMiE9PXRoaXMudmVyc2lvbnx8IXRoaXMuZGlzam9pbnRUaW1lclF1ZXJ5V2ViZ2wyRXh0ZW5zaW9uKXRocm93IG5ldyBFcnJvcihcIldlYkdMMSBwcm9maWxpbmcgY3VycmVudGx5IG5vdCBzdXBwb3J0ZWRcIik7e2NvbnN0IHI9dGhpcy5nbCxpPXRoaXMuZGlzam9pbnRUaW1lclF1ZXJ5V2ViZ2wyRXh0ZW5zaW9uO2U9ci5nZXRRdWVyeVBhcmFtZXRlcih0LHIuUVVFUllfUkVTVUxUX0FWQUlMQUJMRSksbj1yLmdldFBhcmFtZXRlcihpLkdQVV9ESVNKT0lOVF9FWFQpfXJldHVybiBlJiYhbn1nZXRUaW1lclJlc3VsdCh0KXtsZXQgZT0wO2lmKDIhPT10aGlzLnZlcnNpb24pdGhyb3cgbmV3IEVycm9yKFwiV2ViR0wxIHByb2ZpbGluZyBjdXJyZW50bHkgbm90IHN1cHBvcnRlZFwiKTt7Y29uc3Qgbj10aGlzLmdsO2U9bi5nZXRRdWVyeVBhcmFtZXRlcih0LG4uUVVFUllfUkVTVUxUKSxuLmRlbGV0ZVF1ZXJ5KHQpfXJldHVybiBlLzFlNn1hc3luYyB3YWl0Rm9yUXVlcnlBbmRHZXRUaW1lKHQpe3JldHVybiBhd2FpdCgwLHUucmVwZWF0ZWRUcnkpKCgoKT0+dGhpcy5pc1RpbWVyUmVzdWx0QXZhaWxhYmxlKHQpKSksdGhpcy5nZXRUaW1lclJlc3VsdCh0KX1hc3luYyBjcmVhdGVBbmRXYWl0Rm9yRmVuY2UoKXtjb25zdCB0PXRoaXMuY3JlYXRlRmVuY2UodGhpcy5nbCk7cmV0dXJuIHRoaXMucG9sbEZlbmNlKHQpfWNyZWF0ZUZlbmNlKHQpe2xldCBlO2NvbnN0IG49dCxyPW4uZmVuY2VTeW5jKG4uU1lOQ19HUFVfQ09NTUFORFNfQ09NUExFVEUsMCk7cmV0dXJuIHQuZmx1c2goKSxlPW51bGw9PT1yPygpPT4hMDooKT0+e2NvbnN0IHQ9bi5jbGllbnRXYWl0U3luYyhyLDAsMCk7cmV0dXJuIHQ9PT1uLkFMUkVBRFlfU0lHTkFMRUR8fHQ9PT1uLkNPTkRJVElPTl9TQVRJU0ZJRUR9LHtxdWVyeTpyLGlzRmVuY2VQYXNzZWQ6ZX19YXN5bmMgcG9sbEZlbmNlKHQpe3JldHVybiBuZXcgUHJvbWlzZSgoZT0+e3RoaXMuYWRkSXRlbVRvUG9sbCgoKCk9PnQuaXNGZW5jZVBhc3NlZCgpKSwoKCk9PmUoKSkpfSkpfXBvbGxJdGVtcygpe2NvbnN0IHQ9Yyh0aGlzLml0ZW1zVG9Qb2xsLm1hcCgodD0+dC5pc0RvbmVGbikpKTtmb3IobGV0IGU9MDtlPD10OysrZSl7Y29uc3R7cmVzb2x2ZUZuOnR9PXRoaXMuaXRlbXNUb1BvbGxbZV07dCgpfXRoaXMuaXRlbXNUb1BvbGw9dGhpcy5pdGVtc1RvUG9sbC5zbGljZSh0KzEpfWFzeW5jIGFkZEl0ZW1Ub1BvbGwodCxlKXt0aGlzLml0ZW1zVG9Qb2xsLnB1c2goe2lzRG9uZUZuOnQscmVzb2x2ZUZuOmV9KSx0aGlzLml0ZW1zVG9Qb2xsLmxlbmd0aD4xfHxhd2FpdCgwLHUucmVwZWF0ZWRUcnkpKCgoKT0+KHRoaXMucG9sbEl0ZW1zKCksMD09PXRoaXMuaXRlbXNUb1BvbGwubGVuZ3RoKSkpfX19LDEwMzY6KHQsZSxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUuRXhlY3V0aW9uUGxhbj12b2lkIDA7Y29uc3Qgcj1uKDM2OTQpO2NsYXNzIGl7Y29uc3RydWN0b3IodCxlKXt0aGlzLm9wPXQsdGhpcy5ub2RlPWV9fWUuRXhlY3V0aW9uUGxhbj1jbGFzc3tjb25zdHJ1Y3Rvcih0LGUsbil7dGhpcy5ncmFwaD10LHRoaXMucHJvZmlsZXI9bix0aGlzLmluaXRpYWxpemUoZSl9aW5pdGlhbGl6ZSh0KXt0aGlzLnByb2ZpbGVyLmV2ZW50KFwic2Vzc2lvblwiLFwiRXhlY3V0aW9uUGxhbi5pbml0aWFsaXplXCIsKCgpPT57Y29uc3QgZT10aGlzLmdyYXBoLmdldE5vZGVzKCk7aWYoZS5sZW5ndGghPT10Lmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJUaGUgc2l6ZSBvZiBub2RlcyBhbmQgT1BzIGRvIG5vdCBtYXRjaC5cIik7dGhpcy5fb3BzPXQubWFwKCgodCxuKT0+bmV3IGkodCxlW25dKSkpLHRoaXMucmVzZXQoKSx0aGlzLl9zdGFydGVyPVtdLHRoaXMuX29wcy5mb3JFYWNoKCgodCxlKT0+e2xldCBuPSEwO2Zvcihjb25zdCBlIG9mIHQubm9kZS5pbnB1dHMpaWYoIXRoaXMuX3ZhbHVlc1tlXSYmLTE9PT10aGlzLmdyYXBoLmdldElucHV0SW5kaWNlcygpLmluZGV4T2YoZSkpe249ITE7YnJlYWt9biYmdGhpcy5fc3RhcnRlci5wdXNoKGUpfSkpfSkpfXJlc2V0KCl7dGhpcy5fdmFsdWVzPXRoaXMuZ3JhcGguZ2V0VmFsdWVzKCkubWFwKCh0PT50LnRlbnNvcikpfWFzeW5jIGV4ZWN1dGUodCxlKXtyZXR1cm4gdGhpcy5wcm9maWxlci5ldmVudChcInNlc3Npb25cIixcIkV4ZWN1dGlvblBsYW4uZXhlY3V0ZVwiLChhc3luYygpPT57dGhpcy5yZXNldCgpO2NvbnN0IG49dC5jcmVhdGVJbmZlcmVuY2VIYW5kbGVyKCksaT10aGlzLmdyYXBoLmdldElucHV0SW5kaWNlcygpO2lmKGUubGVuZ3RoIT09aS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKGBudW1iZXIgb2YgaW5wdXQgdGVuc29ycyBkb24ndCBtYXRjaCB0aGUgbnVtYmVyIG9mIGlucHV0cyB0byB0aGUgbW9kZWw6IGFjdHVhbDogJHtlLmxlbmd0aH0gZXhwZWN0ZWQ6ICR7aS5sZW5ndGh9YCk7ZS5mb3JFYWNoKCgodCxlKT0+e2NvbnN0IG49aVtlXTt0aGlzLl92YWx1ZXNbbl09dH0pKTtjb25zdCBvPXRoaXMuX3N0YXJ0ZXIuc2xpY2UoMCksYT10aGlzLmdyYXBoLmdldFZhbHVlcygpLHM9dGhpcy5ncmFwaC5nZXROb2RlcygpO2xldCB1PTA7Zm9yKDt1PG8ubGVuZ3RoOyl7Y29uc3QgdD1vW3UrK10sZT10aGlzLl9vcHNbdF0saT1lLm5vZGUuaW5wdXRzLm1hcCgodD0+dGhpcy5fdmFsdWVzW3RdKSk7aWYoLTEhPT1pLmluZGV4T2Yodm9pZCAwKSl0aHJvdyBuZXcgRXJyb3IoYHVucmVzb2x2ZWQgaW5wdXQgZGV0ZWN0ZWQ6IG9wOiAke2Uubm9kZX1gKTtjb25zdCBjPWk7ci5Mb2dnZXIudmVyYm9zZShcIkV4ZWNQbGFuXCIsYFJ1bmluZyBvcDoke2Uubm9kZS5uYW1lfSAoJHtjLm1hcCgoKHQsbik9PmAnJHtlLm5vZGUuaW5wdXRzW25dfSc6ICR7dC50eXBlfVske3QuZGltcy5qb2luKFwiLFwiKX1dYCkpLmpvaW4oXCIsIFwiKX0pYCk7Y29uc3QgbD1hd2FpdCB0aGlzLnByb2ZpbGVyLmV2ZW50KFwibm9kZVwiLGUubm9kZS5uYW1lLChhc3luYygpPT5lLm9wLmltcGwobixjLGUub3AuY29udGV4dCkpKTtpZihsLmxlbmd0aCE9PWUubm9kZS5vdXRwdXRzLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJ0aGUgc2l6ZSBvZiBvdXRwdXQgZG9lcyBub3QgbWF0Y2ggbW9kZWwgZGVmaW5pdGlvbi5cIik7bC5mb3JFYWNoKCgodCxuKT0+e2NvbnN0IHI9ZS5ub2RlLm91dHB1dHNbbl07aWYodGhpcy5fdmFsdWVzW3JdKXRocm93IG5ldyBFcnJvcihgb3V0cHV0IFske3J9XSBhbHJlYWR5IGhhcyB2YWx1ZTogb3A6JHtlLm5vZGUubmFtZX1gKTt0aGlzLl92YWx1ZXNbcl09dH0pKTtjb25zdCBwPW5ldyBTZXQ7bC5mb3JFYWNoKCgodCxuKT0+e2NvbnN0IHI9ZS5ub2RlLm91dHB1dHNbbl07Zm9yKGNvbnN0IHQgb2YgYVtyXS50byl7Y29uc3QgZT1zW3RdO2xldCBuPSEwO2Zvcihjb25zdCB0IG9mIGUuaW5wdXRzKWlmKCF0aGlzLl92YWx1ZXNbdF0pe249ITE7YnJlYWt9biYmcC5hZGQodCl9fSkpLG8ucHVzaCguLi5wKX1jb25zdCBjPVtdO2ZvcihsZXQgdD0wO3Q8dGhpcy5ncmFwaC5nZXRPdXRwdXRJbmRpY2VzKCkubGVuZ3RoO3QrKyl7Y29uc3QgZT10aGlzLmdyYXBoLmdldE91dHB1dEluZGljZXMoKVt0XSxuPXRoaXMuX3ZhbHVlc1tlXTtpZih2b2lkIDA9PT1uKXRocm93IG5ldyBFcnJvcihgcmVxdWlyZWQgb3V0cHV0IFske2V9XSBkb2VzIG5vdCBoYXZlIHZhbHVlYCk7MD09PWU/YXdhaXQgbi5nZXREYXRhKCk6bi5kYXRhLGMucHVzaChuKX1yZXR1cm4gci5Mb2dnZXIudmVyYm9zZShcIkV4ZWNQbGFuXCIsXCJkaXNwb3Npbmcgb2YgaW5mZXJlbmNlSGFuZGxlclwiKSxuLmRpc3Bvc2UoKSxjfSkpfX19LDcwNzA6KHQsZSxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUuR3JhcGg9dm9pZCAwO2NvbnN0IHI9bigxNDQ2KSxpPW4oNzc3OCksbz1uKDkzOTUpLGE9big5MTYyKSxzPW4oMjUxNyk7dmFyIHU9by5vbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzO2UuR3JhcGg9e2Zyb206KHQsZSk9Pm5ldyBwKHQsZSl9O2NsYXNzIGN7Y29uc3RydWN0b3IodCl7dGhpcy5fZnJvbT12b2lkIDAsdGhpcy5fdG89W10sdGhpcy50ZW5zb3I9dm9pZCAwLHRoaXMudHlwZT12b2lkIDAsdCYmKHRoaXMudHlwZT1zLlByb3RvVXRpbC50ZW5zb3JWYWx1ZVR5cGVGcm9tUHJvdG8odC50eXBlLnRlbnNvclR5cGUpKX1nZXQgZnJvbSgpe3JldHVybiB0aGlzLl9mcm9tfWdldCB0bygpe3JldHVybiB0aGlzLl90b319Y2xhc3MgbHtjb25zdHJ1Y3Rvcih0LGUpe3QgaW5zdGFuY2VvZiByLm9ubnguTm9kZVByb3RvPyh0aGlzLm5hbWU9dC5uYW1lLHRoaXMub3BUeXBlPXQub3BUeXBlLHRoaXMuYXR0cmlidXRlcz1uZXcgaS5BdHRyaWJ1dGUodC5hdHRyaWJ1dGUpKTp0IGluc3RhbmNlb2YgdS5Ob2RlJiYodGhpcy5uYW1lPW51bGwhPWU/ZTp0Lm5hbWUoKSx0aGlzLm9wVHlwZT10Lm9wVHlwZSgpLHRoaXMuYXR0cmlidXRlcz1uZXcgaS5BdHRyaWJ1dGUocy5Qcm90b1V0aWwudGVuc29yQXR0cmlidXRlc0Zyb21PUlRGb3JtYXQodCkpKSx0aGlzLmlucHV0cz1bXSx0aGlzLm91dHB1dHM9W10sdGhpcy5leGVjdXRlTm9kZT0hMH19Y2xhc3MgcHtjb25zdHJ1Y3Rvcih0LGUpe2lmKCF0KXRocm93IG5ldyBUeXBlRXJyb3IoXCJncmFwaCBpcyBlbXB0eVwiKTt0aGlzLmJ1aWxkR3JhcGgodCksdGhpcy50cmFuc2Zvcm1HcmFwaChlKSx0aGlzLmNoZWNrSXNBY3ljbGljKCl9Z2V0SW5wdXRJbmRpY2VzKCl7cmV0dXJuIHRoaXMuX2FsbElucHV0SW5kaWNlc31nZXRJbnB1dE5hbWVzKCl7cmV0dXJuIHRoaXMuX2FsbElucHV0TmFtZXN9Z2V0T3V0cHV0SW5kaWNlcygpe3JldHVybiB0aGlzLl9hbGxPdXRwdXRJbmRpY2VzfWdldE91dHB1dE5hbWVzKCl7cmV0dXJuIHRoaXMuX2FsbE91dHB1dE5hbWVzfWdldFZhbHVlcygpe3JldHVybiB0aGlzLl9hbGxEYXRhfWdldE5vZGVzKCl7cmV0dXJuIHRoaXMuX25vZGVzfWJ1aWxkR3JhcGgodCl7aWYodCBpbnN0YW5jZW9mIHIub25ueC5HcmFwaFByb3RvKXRoaXMuYnVpbGRHcmFwaEZyb21Pbm54Rm9ybWF0KHQpO2Vsc2V7aWYoISh0IGluc3RhbmNlb2YgdS5HcmFwaCkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdyYXBoIHR5cGUgaXMgbm90IHN1cHBvcnRlZC5cIik7dGhpcy5idWlsZEdyYXBoRnJvbU9ydEZvcm1hdCh0KX19YnVpbGRHcmFwaEZyb21Pbm54Rm9ybWF0KHQpe2NvbnN0IGU9bmV3IE1hcDt0aGlzLl9hbGxEYXRhPVtdLHRoaXMuX2FsbElucHV0SW5kaWNlcz1bXSx0aGlzLl9hbGxJbnB1dE5hbWVzPVtdLHRoaXMuX2FsbE91dHB1dEluZGljZXM9W10sdGhpcy5fYWxsT3V0cHV0TmFtZXM9W10sdGhpcy5fbm9kZXM9W107Y29uc3Qgbj1uZXcgTWFwO2lmKCF0LmlucHV0KXRocm93IG5ldyBFcnJvcihcIm1pc3NpbmcgaW5mb3JtYXRpb24gaW4gZ3JhcGg6IGlucHV0XCIpO2NvbnN0IHI9W107Zm9yKGNvbnN0IG4gb2YgdC5pbnB1dCl7aWYoZS5oYXMobi5uYW1lKSl0aHJvdyBuZXcgRXJyb3IoYGR1cGxpY2F0ZWQgaW5wdXQgbmFtZTogJHtuLm5hbWV9YCk7Y29uc3QgdD10aGlzLl9hbGxEYXRhLnB1c2gobmV3IGMobikpLTE7ZS5zZXQobi5uYW1lLHQpLHIucHVzaChuLm5hbWUpfWlmKCF0LmluaXRpYWxpemVyKXRocm93IG5ldyBFcnJvcihcIm1pc3NpbmcgaW5mb3JtYXRpb24gaW4gZ3JhcGg6IGluaXRpYWxpemVyXCIpO2Zvcihjb25zdCBuIG9mIHQuaW5pdGlhbGl6ZXIpe2xldCB0PWUuZ2V0KG4ubmFtZSk7aWYodm9pZCAwPT09dCl7Y29uc3Qgcj1uZXcgYztyLnR5cGU9e3NoYXBlOntkaW1zOnMuUHJvdG9VdGlsLnRlbnNvckRpbXNGcm9tUHJvdG8obi5kaW1zKX0sdGVuc29yVHlwZTpzLlByb3RvVXRpbC50ZW5zb3JEYXRhVHlwZUZyb21Qcm90byhuLmRhdGFUeXBlKX0sdD10aGlzLl9hbGxEYXRhLnB1c2gociktMSxlLnNldChuLm5hbWUsdCl9dGhpcy5fYWxsRGF0YVt0XS5fZnJvbT0tMSx0aGlzLl9hbGxEYXRhW3RdLnRlbnNvcj1hLlRlbnNvci5mcm9tUHJvdG8obil9Zm9yKGxldCB0PTA7dDx0aGlzLl9hbGxEYXRhLmxlbmd0aDt0KyspdGhpcy5fYWxsRGF0YVt0XS50ZW5zb3J8fCh0aGlzLl9hbGxJbnB1dEluZGljZXMucHVzaCh0KSx0aGlzLl9hbGxJbnB1dE5hbWVzLnB1c2goclt0XSkpO2lmKCF0Lm91dHB1dCl0aHJvdyBuZXcgRXJyb3IoXCJtaXNzaW5nIGluZm9ybWF0aW9uIGluIGdyYXBoOiBvdXRwdXRcIik7Zm9yKGNvbnN0IG4gb2YgdC5vdXRwdXQpe2lmKGUuaGFzKG4ubmFtZSkpdGhyb3cgbmV3IEVycm9yKGBkdXBsaWNhdGVkIG91dHB1dCBuYW1lOiAke24ubmFtZX1gKTtjb25zdCB0PXRoaXMuX2FsbERhdGEucHVzaChuZXcgYyhuKSktMTtlLnNldChuLm5hbWUsdCksdGhpcy5fYWxsT3V0cHV0SW5kaWNlcy5wdXNoKHQpLHRoaXMuX2FsbE91dHB1dE5hbWVzLnB1c2gobi5uYW1lKX1pZighdC5ub2RlKXRocm93IG5ldyBFcnJvcihcIm1pc3NpbmcgaW5mb3JtYXRpb24gaW4gZ3JhcGg6IG5vZGVcIik7Zm9yKGNvbnN0IGUgb2YgdC5ub2RlKXtpZighZS5uYW1lKWZvcihsZXQgdD0wOzt0Kyspe2NvbnN0IHI9YHVubmFtZWRfJHtlLm9wVHlwZX1fJHt0fWA7aWYoIW4uaGFzKHIpKXtlLm5hbWU9cjticmVha319aWYobi5oYXMoZS5uYW1lKSl0aHJvdyBuZXcgRXJyb3IoYGR1cGxpY2F0ZWQgbm9kZSBuYW1lOiAke2UubmFtZX1gKTtjb25zdCB0PXRoaXMuX25vZGVzLnB1c2gobmV3IGwoZSkpLTE7bi5zZXQoZS5uYW1lLHQpfWZvcihsZXQgbj0wO248dGhpcy5fbm9kZXMubGVuZ3RoO24rKyl7Y29uc3Qgcj10aGlzLl9ub2Rlc1tuXSxpPXQubm9kZVtuXTtpZighaS5vdXRwdXQpdGhyb3cgbmV3IEVycm9yKGBtaXNzaW5nIG91dHB1dCBmb3Igbm9kZTogJHtpLm5hbWV9YCk7Zm9yKGNvbnN0IHQgb2YgaS5vdXRwdXQpe2xldCBvPWUuZ2V0KHQpO2lmKHZvaWQgMD09PW8mJihvPXRoaXMuX2FsbERhdGEucHVzaChuZXcgYyktMSxlLnNldCh0LG8pKSxyLm91dHB1dHMucHVzaChvKSx2b2lkIDAhPT10aGlzLl9hbGxEYXRhW29dLl9mcm9tKXRocm93IG5ldyBFcnJvcihgbXVsdGlwbGUgbm9kZXMgb3V0cHV0IHRvIG9uZSBkYXRhIHZhbHVlOiAke299YCk7aWYodGhpcy5fYWxsRGF0YVtvXS5fZnJvbT1uLFwiQ29uc3RhbnRcIj09PWkub3BUeXBlKXtpZighaS5hdHRyaWJ1dGV8fDEhPT1pLmF0dHJpYnV0ZS5sZW5ndGh8fCFpLmF0dHJpYnV0ZVswXS50KXRocm93IG5ldyBFcnJvcihcIm1pc3NpbmcgYXR0cmlidXRlcyBvciBtaXNzaW5nIHRlbnNvciB2YWx1ZSBpbiBhdHRyaWJ1dGVzIGZvciB0aGlzIENvbnN0YW50IG9wZXJhdG9yXCIpO2lmKCFpLm91dHB1dHx8MSE9PWkub3V0cHV0Lmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJtaXNzaW5nIG91dHB1dCBvciBpbmNvcnJlY3QgbnVtYmVyIG9mIG91dHB1dHMgZm9yIHRoaXMgQ29uc3RhbnQgb3BlcmF0b3JcIik7ci5vdXRwdXRzLnBvcCgpLHIuZXhlY3V0ZU5vZGU9ITEsdGhpcy5fYWxsRGF0YVtvXS5fZnJvbT0tMSx0aGlzLl9hbGxEYXRhW29dLnRlbnNvcj1hLlRlbnNvci5mcm9tUHJvdG8oaS5hdHRyaWJ1dGVbMF0udCl9fX1mb3IobGV0IG49MDtuPHRoaXMuX25vZGVzLmxlbmd0aDtuKyspe2NvbnN0IHI9dGhpcy5fbm9kZXNbbl0saT10Lm5vZGVbbl07aWYoIWkuaW5wdXQpdGhyb3cgbmV3IEVycm9yKGBtaXNzaW5nIGlucHV0IGZvciBub2RlOiAke2kubmFtZX1gKTtmb3IoY29uc3QgdCBvZiBpLmlucHV0KXtjb25zdCBvPWUuZ2V0KHQpO2lmKHZvaWQgMD09PW8pe2lmKFwiXCI9PT10JiYzPT09aS5pbnB1dC5sZW5ndGgmJlwiUmVzaXplXCI9PT1pLm9wVHlwZSljb250aW51ZTt0aHJvdyBuZXcgRXJyb3IoYHVucmVjb2duaXplZCBpbnB1dCAnJHt0fScgZm9yIG5vZGU6ICR7aS5uYW1lfWApfXIuaW5wdXRzLnB1c2gobyksdGhpcy5fYWxsRGF0YVtvXS5fdG8ucHVzaChuKX19cmV0dXJuITB9YnVpbGRHcmFwaEZyb21PcnRGb3JtYXQodCl7dmFyIGUsbixyO2NvbnN0IGk9bmV3IE1hcDt0aGlzLl9hbGxEYXRhPVtdLHRoaXMuX2FsbElucHV0SW5kaWNlcz1bXSx0aGlzLl9hbGxJbnB1dE5hbWVzPVtdLHRoaXMuX2FsbE91dHB1dEluZGljZXM9W10sdGhpcy5fYWxsT3V0cHV0TmFtZXM9W10sdGhpcy5fbm9kZXM9W107Y29uc3Qgbz1uZXcgTWFwLHA9W107Zm9yKGxldCBvPTA7bzx0LmlucHV0c0xlbmd0aCgpO28rKyl7Y29uc3QgYT10LmlucHV0cyhvKTtpZihpLmhhcyhhKSl0aHJvdyBuZXcgRXJyb3IoYGR1cGxpY2F0ZWQgaW5wdXQgbmFtZTogJHthfWApO2ZvcihsZXQgbz0wO288dC5ub2RlQXJnc0xlbmd0aCgpO28rKylpZigobnVsbD09PShlPXQubm9kZUFyZ3MobykpfHx2b2lkIDA9PT1lP3ZvaWQgMDplLm5hbWUoKSk9PT1hKXtjb25zdCBlPW5ldyBjO2lmKChudWxsPT09KHI9bnVsbD09PShuPXQubm9kZUFyZ3MobykpfHx2b2lkIDA9PT1uP3ZvaWQgMDpuLnR5cGUoKSl8fHZvaWQgMD09PXI/dm9pZCAwOnIudmFsdWVUeXBlKCkpIT09dS5UeXBlSW5mb1ZhbHVlLnRlbnNvcl90eXBlKXRocm93IG5ldyBFcnJvcihcIlVuZXhwZWN0ZWQgdmFsdWUgdHlwZSBmb3IgdGhlIG5vZGVBcmcuXCIpO2NvbnN0IGw9dC5ub2RlQXJncyhvKS50eXBlKCkudmFsdWUobmV3IHUuVGVuc29yVHlwZUFuZFNoYXBlKSxmPXMuUHJvdG9VdGlsLnRlbnNvckRhdGFUeXBlRnJvbVByb3RvKGwuZWxlbVR5cGUoKSksZD1sLnNoYXBlKCksaD1bXTtmb3IobGV0IHQ9MDt0PGQuZGltTGVuZ3RoKCk7dCsrKWgucHVzaChzLkxvbmdVdGlsLmxvbmdUb051bWJlcihkLmRpbSh0KS52YWx1ZSgpLmRpbVZhbHVlKCkpKTtlLnR5cGU9e3NoYXBlOntkaW1zOmh9LHRlbnNvclR5cGU6Zn07Y29uc3QgZz10aGlzLl9hbGxEYXRhLnB1c2goZSktMTtpLnNldChhLGcpLHAucHVzaChhKX19Zm9yKGxldCBlPTA7ZTx0LmluaXRpYWxpemVyc0xlbmd0aCgpO2UrKyl7Y29uc3Qgbj10LmluaXRpYWxpemVycyhlKTtsZXQgcj1pLmdldChuLm5hbWUoKSk7aWYodm9pZCAwPT09cil7Y29uc3QgdD1uZXcgYyxlPXMuUHJvdG9VdGlsLnRlbnNvckRpbXNGcm9tT1JURm9ybWF0KG4pLG89cy5Qcm90b1V0aWwudGVuc29yRGF0YVR5cGVGcm9tUHJvdG8obi5kYXRhVHlwZSgpKTt0LnR5cGU9e3NoYXBlOntkaW1zOmV9LHRlbnNvclR5cGU6b30scj10aGlzLl9hbGxEYXRhLnB1c2godCktMSxpLnNldChuLm5hbWUoKSxyKX10aGlzLl9hbGxEYXRhW3JdLl9mcm9tPS0xLHRoaXMuX2FsbERhdGFbcl0udGVuc29yPWEuVGVuc29yLmZyb21PcnRUZW5zb3Iobil9Zm9yKGxldCB0PTA7dDx0aGlzLl9hbGxEYXRhLmxlbmd0aDt0KyspdGhpcy5fYWxsRGF0YVt0XS50ZW5zb3J8fCh0aGlzLl9hbGxJbnB1dEluZGljZXMucHVzaCh0KSx0aGlzLl9hbGxJbnB1dE5hbWVzLnB1c2gocFt0XSkpO2ZvcihsZXQgZT0wO2U8dC5vdXRwdXRzTGVuZ3RoKCk7ZSsrKXtjb25zdCBuPXQub3V0cHV0cyhlKTtpZihpLmhhcyhuKSl0aHJvdyBuZXcgRXJyb3IoYGR1cGxpY2F0ZWQgb3V0cHV0IG5hbWU6ICR7bn1gKTtjb25zdCByPXRoaXMuX2FsbERhdGEucHVzaChuZXcgYyktMTtpLnNldChuLHIpLHRoaXMuX2FsbE91dHB1dEluZGljZXMucHVzaChyKSx0aGlzLl9hbGxPdXRwdXROYW1lcy5wdXNoKG4pfWlmKCF0Lm5vZGVzKXRocm93IG5ldyBFcnJvcihcIm1pc3NpbmcgaW5mb3JtYXRpb24gaW4gZ3JhcGg6IG5vZGVcIik7Zm9yKGxldCBlPTA7ZTx0Lm5vZGVzTGVuZ3RoKCk7ZSsrKXtjb25zdCBuPXQubm9kZXMoZSk7bGV0IHI9bi5uYW1lKCk7aWYoIXIpZm9yKGxldCB0PTA7cj1gdW5uYW1lZF8ke24ub3BUeXBlKCl9XyR7dH1gLG8uaGFzKHIpO3QrKyk7aWYoby5oYXMocikpdGhyb3cgbmV3IEVycm9yKGBkdXBsaWNhdGVkIG5vZGUgbmFtZTogJHtyfWApO2NvbnN0IGk9dGhpcy5fbm9kZXMucHVzaChuZXcgbChuLHIpKS0xO28uc2V0KHIsaSl9Zm9yKGxldCBlPTA7ZTx0aGlzLl9ub2Rlcy5sZW5ndGg7ZSsrKXtjb25zdCBuPXRoaXMuX25vZGVzW2VdLHI9dC5ub2RlcyhlKTtpZihudWxsPT1yKXRocm93IG5ldyBFcnJvcihgTm8gbm9kZSBleGlzdHMgYXQgaW5kZXggJHtlfWApO2lmKDA9PT0obnVsbD09cj92b2lkIDA6ci5vdXRwdXRzTGVuZ3RoKCkpKXRocm93IG5ldyBFcnJvcihgbWlzc2luZyBvdXRwdXQgZm9yIG5vZGU6ICR7ci5uYW1lfWApO2ZvcihsZXQgdD0wO3Q8KG51bGw9PXI/dm9pZCAwOnIub3V0cHV0c0xlbmd0aCgpKTt0Kyspe2NvbnN0IG89bnVsbD09cj92b2lkIDA6ci5vdXRwdXRzKHQpO2xldCBzPWkuZ2V0KG8pO2lmKHZvaWQgMD09PXMmJihzPXRoaXMuX2FsbERhdGEucHVzaChuZXcgYyktMSxpLnNldChvLHMpKSxuLm91dHB1dHMucHVzaChzKSx2b2lkIDAhPT10aGlzLl9hbGxEYXRhW3NdLl9mcm9tKXRocm93IG5ldyBFcnJvcihgbXVsdGlwbGUgbm9kZXMgb3V0cHV0IHRvIG9uZSBkYXRhIHZhbHVlOiAke3N9YCk7aWYodGhpcy5fYWxsRGF0YVtzXS5fZnJvbT1lLFwiQ29uc3RhbnRcIj09PXIub3BUeXBlKCkpe2lmKDEhPT1yLmF0dHJpYnV0ZXNMZW5ndGgoKXx8IXIuYXR0cmlidXRlcygwKS50KCkpdGhyb3cgbmV3IEVycm9yKFwibWlzc2luZyBhdHRyaWJ1dGVzIG9yIG1pc3NpbmcgdGVuc29yIHZhbHVlIGluIGF0dHJpYnV0ZXMgZm9yIHRoaXMgQ29uc3RhbnQgb3BlcmF0b3JcIik7aWYoMSE9PXIub3V0cHV0c0xlbmd0aCgpKXRocm93IG5ldyBFcnJvcihcIm1pc3Npbmcgb3V0cHV0IG9yIGluY29ycmVjdCBudW1iZXIgb2Ygb3V0cHV0cyBmb3IgdGhpcyBDb25zdGFudCBvcGVyYXRvclwiKTtuLm91dHB1dHMucG9wKCksbi5leGVjdXRlTm9kZT0hMSx0aGlzLl9hbGxEYXRhW3NdLl9mcm9tPS0xLHRoaXMuX2FsbERhdGFbc10udGVuc29yPWEuVGVuc29yLmZyb21PcnRUZW5zb3Ioci5hdHRyaWJ1dGVzKDApLnQoKSl9fX1mb3IobGV0IGU9MDtlPHRoaXMuX25vZGVzLmxlbmd0aDtlKyspe2NvbnN0IG49dGhpcy5fbm9kZXNbZV0scj10Lm5vZGVzKGUpO2lmKDA9PT1yLmlucHV0c0xlbmd0aCgpKXRocm93IG5ldyBFcnJvcihgbWlzc2luZyBpbnB1dCBmb3Igbm9kZTogJHtyLm5hbWV9YCk7Zm9yKGxldCB0PTA7dDxyLmlucHV0c0xlbmd0aCgpO3QrKyl7Y29uc3Qgbz1yLmlucHV0cyh0KSxhPWkuZ2V0KG8pO2lmKHZvaWQgMD09PWEpdGhyb3cgbmV3IEVycm9yKGB1bnJlY29nbml6ZWQgaW5wdXQgJyR7b30nIGZvciBub2RlOiAke3IubmFtZSgpfWApO24uaW5wdXRzLnB1c2goYSksdGhpcy5fYWxsRGF0YVthXS5fdG8ucHVzaChlKX19fWNoZWNrSXNBY3ljbGljKCl7Y29uc3QgdD1uZXcgU2V0O3RoaXMuX2FsbElucHV0SW5kaWNlcy5mb3JFYWNoKChlPT57dGhpcy5fYWxsRGF0YVtlXS5fdG8uZm9yRWFjaCgoZT0+e3QuYWRkKGUpfSkpfSkpO2NvbnN0IGU9QXJyYXkuZnJvbSh0KSxuPW5ldyBBcnJheSh0aGlzLl9ub2Rlcy5sZW5ndGgpLmZpbGwoXCJ3aGl0ZVwiKTtmb3IoO2UubGVuZ3RoPjA7KXtjb25zdCB0PWUucG9wKCk7XCJncmF5XCI9PT1uW3RdP25bdF09XCJibGFja1wiOihlLnB1c2godCksblt0XT1cImdyYXlcIix0aGlzLl9ub2Rlc1t0XS5vdXRwdXRzLmZvckVhY2goKHI9Pntjb25zdCBpPXRoaXMuX2FsbERhdGFbcl07aWYodm9pZCAwIT09aS50ZW5zb3IpdGhyb3cgbmV3IEVycm9yKFwibm9kZSBvdXRwdXRzIHNob3VsZCBub3QgYmUgaW5pdGlhbGl6ZWRcIik7aWYoaS5fZnJvbSE9PXQpdGhyb3cgbmV3IEVycm9yKFwiZnJvbSBwcm9wZXJ0eSBvZiB0aGUgVmFsdWUgb2JqZWN0IGRvZXNuJ3QgbWF0Y2ggaW5kZXggb2YgTm9kZSBiZWluZyBwcm9jZXNzZWRcIik7aS5fdG8uZm9yRWFjaCgodD0+e2lmKFwiZ3JheVwiPT09blt0XSl0aHJvdyBuZXcgRXJyb3IoXCJtb2RlbCBncmFwaCBpcyBjeWNsaWNcIik7XCJ3aGl0ZVwiPT09blt0XSYmZS5wdXNoKHQpfSkpfSkpKX19dHJhbnNmb3JtR3JhcGgodCl7dGhpcy5yZW1vdmVBbGxJZGVudGl0eU5vZGVzKCksdGhpcy5yZW1vdmVBbGxEcm9wb3V0Tm9kZXMoKSx0aGlzLmZ1c2VDb252QWN0aXZhdGlvbk5vZGVzKCksdCYmdC50cmFuc2Zvcm1HcmFwaCh0aGlzKSx0aGlzLmZpbmFsaXplR3JhcGgoKX1maW5hbGl6ZUdyYXBoKCl7bGV0IHQ9MDtmb3IobGV0IGU9MDtlPHRoaXMuX25vZGVzLmxlbmd0aDtlKyspdGhpcy5fbm9kZXNbZV0uZXhlY3V0ZU5vZGU/dD4wJiYodGhpcy5fbm9kZXNbZV0uaW5wdXRzLmZvckVhY2goKG49Pntjb25zdCByPXRoaXMuX2FsbERhdGFbbl0uX3RvLmluZGV4T2YoZSt0KTstMSE9PXImJih0aGlzLl9hbGxEYXRhW25dLl90b1tyXT1lKX0pKSx0aGlzLl9ub2Rlc1tlXS5vdXRwdXRzLmZvckVhY2goKG49Pnt0aGlzLl9hbGxEYXRhW25dLl9mcm9tJiZ0aGlzLl9hbGxEYXRhW25dLl9mcm9tPT09ZSt0JiYodGhpcy5fYWxsRGF0YVtuXS5fZnJvbT1lKX0pKSk6KHQrKyx0aGlzLl9ub2Rlc1tlXS5vdXRwdXRzLmZvckVhY2goKHQ9Pnt0aGlzLl9hbGxEYXRhW3RdLl9mcm9tPS0yfSkpLHRoaXMuX25vZGVzLnNwbGljZShlLDEpLGUtLSk7dD0wO2ZvcihsZXQgZT0wO2U8dGhpcy5fYWxsRGF0YS5sZW5ndGg7ZSsrKWlmKC0yIT09dGhpcy5fYWxsRGF0YVtlXS5mcm9tfHwtMSE9PXRoaXMuX2FsbE91dHB1dEluZGljZXMuaW5kZXhPZihlK3QpKXtpZih0PjApe2xldCBuPS0xO3ZvaWQgMCE9PXRoaXMuX2FsbERhdGFbZV0uZnJvbSYmLTEhPT10aGlzLl9hbGxEYXRhW2VdLmZyb20/KG49dGhpcy5fbm9kZXNbdGhpcy5fYWxsRGF0YVtlXS5mcm9tXS5vdXRwdXRzLmluZGV4T2YoZSt0KSwtMSE9PW4mJih0aGlzLl9ub2Rlc1t0aGlzLl9hbGxEYXRhW2VdLmZyb21dLm91dHB1dHNbbl09ZSkpOihuPXRoaXMuX2FsbElucHV0SW5kaWNlcy5pbmRleE9mKGUrdCksLTEhPT1uJiYodGhpcy5fYWxsSW5wdXRJbmRpY2VzW25dPWUpKSx0aGlzLl9hbGxEYXRhW2VdLnRvLmZvckVhY2goKHI9PntuPXRoaXMuX25vZGVzW3JdLmlucHV0cy5pbmRleE9mKGUrdCksLTEhPT1uJiYodGhpcy5fbm9kZXNbcl0uaW5wdXRzW25dPWUpfSkpLDA9PT10aGlzLl9hbGxEYXRhW2VdLnRvLmxlbmd0aCYmKG49dGhpcy5fYWxsT3V0cHV0SW5kaWNlcy5pbmRleE9mKGUrdCksLTEhPT1uJiYodGhpcy5fYWxsT3V0cHV0SW5kaWNlc1tuXT1lKSl9fWVsc2UgdCsrLHRoaXMuX2FsbERhdGEuc3BsaWNlKGUsMSksZS0tfWRlbGV0ZU5vZGUodCl7Y29uc3QgZT10aGlzLl9ub2Rlc1t0XTtpZihlLm91dHB1dHMubGVuZ3RoPjEpZm9yKGxldCB0PTE7dDxlLm91dHB1dHMubGVuZ3RoO3QrKylpZih0aGlzLl9hbGxEYXRhW2Uub3V0cHV0c1t0XV0udG8ubGVuZ3RoPjApdGhyb3cgbmV3IEVycm9yKFwiTm9kZSBkZWxldGlvbiB3aXRoIG1vcmUgdGhhbiBvbmUgb3V0cHV0IGNvbm5lY3RlZCB0byBvdGhlciBub2RlcyBpcyBub3Qgc3VwcG9ydGVkLiBcIik7ZS5leGVjdXRlTm9kZT0hMTtjb25zdCBuPWUuaW5wdXRzWzBdLHI9ZS5vdXRwdXRzWzBdLGk9dGhpcy5fYWxsRGF0YVtyXS50byxvPXRoaXMuX2FsbERhdGFbbl0udG8uaW5kZXhPZih0KTtpZigtMT09PW8pdGhyb3cgbmV3IEVycm9yKFwiVGhlIFZhbHVlIG9iamVjdCBkb2Vzbid0IGhhdmUgdGhlIGN1cnJlbnQgTm9kZSBpbiBpdCdzICd0bycgcHJvcGVydHkgXCIpO3RoaXMuX2FsbERhdGFbbl0udG8uc3BsaWNlKG8sMSksdGhpcy5fYWxsRGF0YVtyXS5fdG89W107Y29uc3QgYT10aGlzLl9hbGxPdXRwdXRJbmRpY2VzLmluZGV4T2Yocik7aWYoLTEhPT1hJiYodGhpcy5fYWxsT3V0cHV0SW5kaWNlc1thXT1uKSxpJiZpLmxlbmd0aD4wKWZvcihjb25zdCB0IG9mIGkpe2NvbnN0IGU9dGhpcy5fbm9kZXNbdF0uaW5wdXRzLmluZGV4T2Yocik7aWYoLTE9PT1lKXRocm93IG5ldyBFcnJvcihcIlRoZSBOb2RlIG9iamVjdCBkb2Vzbid0IGhhdmUgdGhlIG91dHB1dCBWYWx1ZSBpbiBpdCdzICdpbnB1dHMnIHByb3BlcnR5IFwiKTt0aGlzLl9ub2Rlc1t0XS5pbnB1dHNbZV09bix0aGlzLl9hbGxEYXRhW25dLnRvLnB1c2godCl9fXJlbW92ZUFsbERyb3BvdXROb2Rlcygpe2xldCB0PTA7Zm9yKGNvbnN0IGUgb2YgdGhpcy5fbm9kZXMpe2lmKFwiRHJvcG91dFwiPT09ZS5vcFR5cGUpe2lmKDEhPT1lLmlucHV0cy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiRHJvcG91dCBub2RlcyBzaG91bGQgb25seSBjb250YWluIG9uZSBpbnB1dC4gXCIpO2lmKDEhPT1lLm91dHB1dHMubGVuZ3RoJiYyIT09ZS5vdXRwdXRzLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJEcm9wb3V0IG5vZGVzIHNob3VsZCBjb250YWluIGVpdGhlciAxIG9yIDIgb3V0cHV0KHMpXCIpO2lmKDI9PT1lLm91dHB1dHMubGVuZ3RoJiYwIT09dGhpcy5fYWxsRGF0YVtlLm91dHB1dHNbMV1dLl90by5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiRHJvcG91dCBub2RlcydzIHNlY29uZCBvdXRwdXQgc2hvdWxkIG5vdCBiZSByZWZlcmVuY2VkIGJ5IG90aGVyIG5vZGVzXCIpO3RoaXMuZGVsZXRlTm9kZSh0KX10Kyt9fXJlbW92ZUFsbElkZW50aXR5Tm9kZXMoKXtsZXQgdD0wO2Zvcihjb25zdCBlIG9mIHRoaXMuX25vZGVzKVwiSWRlbnRpdHlcIj09PWUub3BUeXBlJiZ0aGlzLmRlbGV0ZU5vZGUodCksdCsrfWlzQWN0aXZhdGlvbih0KXtzd2l0Y2godC5vcFR5cGUpe2Nhc2VcIlJlbHVcIjpjYXNlXCJTaWdtb2lkXCI6Y2FzZVwiQ2xpcFwiOnJldHVybiEwO2RlZmF1bHQ6cmV0dXJuITF9fWZ1c2VDb252QWN0aXZhdGlvbk5vZGVzKCl7Zm9yKGNvbnN0IHQgb2YgdGhpcy5fbm9kZXMpaWYoXCJDb252XCI9PT10Lm9wVHlwZSl7Y29uc3QgZT10aGlzLl9hbGxEYXRhW3Qub3V0cHV0c1swXV0uX3RvO2lmKDE9PT1lLmxlbmd0aCYmdGhpcy5pc0FjdGl2YXRpb24odGhpcy5fbm9kZXNbZVswXV0pKXtjb25zdCBuPXRoaXMuX25vZGVzW2VbMF1dO2lmKFwiQ2xpcFwiPT09bi5vcFR5cGUpaWYoMT09PW4uaW5wdXRzLmxlbmd0aCl0cnl7dC5hdHRyaWJ1dGVzLnNldChcImFjdGl2YXRpb25fcGFyYW1zXCIsXCJmbG9hdHNcIixbbi5hdHRyaWJ1dGVzLmdldEZsb2F0KFwibWluXCIpLG4uYXR0cmlidXRlcy5nZXRGbG9hdChcIm1heFwiKV0pfWNhdGNoKGUpe3QuYXR0cmlidXRlcy5zZXQoXCJhY3RpdmF0aW9uX3BhcmFtc1wiLFwiZmxvYXRzXCIsW3MuTUlOX0NMSVAscy5NQVhfQ0xJUF0pfWVsc2V7aWYoIShuLmlucHV0cy5sZW5ndGg+PTMmJnZvaWQgMCE9PXRoaXMuX2FsbERhdGFbbi5pbnB1dHNbMV1dLnRlbnNvciYmdm9pZCAwIT09dGhpcy5fYWxsRGF0YVtuLmlucHV0c1syXV0udGVuc29yKSljb250aW51ZTt0LmF0dHJpYnV0ZXMuc2V0KFwiYWN0aXZhdGlvbl9wYXJhbXNcIixcImZsb2F0c1wiLFt0aGlzLl9hbGxEYXRhW24uaW5wdXRzWzFdXS50ZW5zb3IuZmxvYXREYXRhWzBdLHRoaXMuX2FsbERhdGFbbi5pbnB1dHNbMl1dLnRlbnNvci5mbG9hdERhdGFbMF1dKX10LmF0dHJpYnV0ZXMuc2V0KFwiYWN0aXZhdGlvblwiLFwic3RyaW5nXCIsbi5vcFR5cGUpLHRoaXMuZGVsZXRlTm9kZShlWzBdKX19fX19LDM2OTQ6KHQsZSk9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLm5vdz1lLlByb2ZpbGVyPWUuTG9nZ2VyPXZvaWQgMDtjb25zdCBuPXt2ZXJib3NlOjFlMyxpbmZvOjJlMyx3YXJuaW5nOjRlMyxlcnJvcjo1ZTMsZmF0YWw6NmUzfSxyPXtub25lOm5ldyBjbGFzc3tsb2codCxlLG4pe319LGNvbnNvbGU6bmV3IGNsYXNze2xvZyh0LGUsbil7Y29uc29sZS5sb2coYCR7dGhpcy5jb2xvcih0KX0gJHtuP1wiXHUwMDFiWzM1bVwiK24rXCJcdTAwMWJbMG0gXCI6XCJcIn0ke2V9YCl9Y29sb3IodCl7c3dpdGNoKHQpe2Nhc2VcInZlcmJvc2VcIjpyZXR1cm5cIlx1MDAxYlszNDs0MG12XHUwMDFiWzBtXCI7Y2FzZVwiaW5mb1wiOnJldHVyblwiXHUwMDFiWzMybWlcdTAwMWJbMG1cIjtjYXNlXCJ3YXJuaW5nXCI6cmV0dXJuXCJcdTAwMWJbMzA7NDNtd1x1MDAxYlswbVwiO2Nhc2VcImVycm9yXCI6cmV0dXJuXCJcdTAwMWJbMzE7NDBtZVx1MDAxYlswbVwiO2Nhc2VcImZhdGFsXCI6cmV0dXJuXCJcdTAwMWJbMTAxbWZcdTAwMWJbMG1cIjtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgc2V2ZXJpdHk6ICR7dH1gKX19fX0saT17cHJvdmlkZXI6XCJjb25zb2xlXCIsbWluaW1hbFNldmVyaXR5Olwid2FybmluZ1wiLGxvZ0RhdGVUaW1lOiEwLGxvZ1NvdXJjZUxvY2F0aW9uOiExfTtsZXQgbz17XCJcIjppfTtmdW5jdGlvbiBhKHQsZSxuLHIpe2lmKHZvaWQgMD09PWUpcmV0dXJuIGk9dCx7dmVyYm9zZTphLnZlcmJvc2UuYmluZChudWxsLGkpLGluZm86YS5pbmZvLmJpbmQobnVsbCxpKSx3YXJuaW5nOmEud2FybmluZy5iaW5kKG51bGwsaSksZXJyb3I6YS5lcnJvci5iaW5kKG51bGwsaSksZmF0YWw6YS5mYXRhbC5iaW5kKG51bGwsaSl9O2lmKHZvaWQgMD09PW4pcyh0LGUpO2Vsc2UgaWYoXCJudW1iZXJcIj09dHlwZW9mIG4mJnZvaWQgMD09PXIpcyh0LGUpO2Vsc2UgaWYoXCJzdHJpbmdcIj09dHlwZW9mIG4mJnZvaWQgMD09PXIpcyh0LG4sMCxlKTtlbHNle2lmKFwic3RyaW5nXCIhPXR5cGVvZiBufHxcIm51bWJlclwiIT10eXBlb2Ygcil0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW5wdXQgaXMgdmFsaWRcIik7cyh0LG4sMCxlKX12YXIgaX1mdW5jdGlvbiBzKHQsZSxpLGEpe2NvbnN0IHM9b1thfHxcIlwiXXx8b1tcIlwiXTtuW3RdPG5bcy5taW5pbWFsU2V2ZXJpdHldfHwocy5sb2dEYXRlVGltZSYmKGU9YCR7KG5ldyBEYXRlKS50b0lTT1N0cmluZygpfXwke2V9YCkscy5sb2dTb3VyY2VMb2NhdGlvbixyW3MucHJvdmlkZXJdLmxvZyh0LGUsYSkpfSFmdW5jdGlvbih0KXtmdW5jdGlvbiBlKHQpe289e30sbihcIlwiLHR8fHt9KX1mdW5jdGlvbiBuKHQsbil7aWYoXCIqXCI9PT10KWUobik7ZWxzZXtjb25zdCBlPW9bdF18fGk7b1t0XT17cHJvdmlkZXI6bi5wcm92aWRlcnx8ZS5wcm92aWRlcixtaW5pbWFsU2V2ZXJpdHk6bi5taW5pbWFsU2V2ZXJpdHl8fGUubWluaW1hbFNldmVyaXR5LGxvZ0RhdGVUaW1lOnZvaWQgMD09PW4ubG9nRGF0ZVRpbWU/ZS5sb2dEYXRlVGltZTpuLmxvZ0RhdGVUaW1lLGxvZ1NvdXJjZUxvY2F0aW9uOnZvaWQgMD09PW4ubG9nU291cmNlTG9jYXRpb24/ZS5sb2dTb3VyY2VMb2NhdGlvbjpuLmxvZ1NvdXJjZUxvY2F0aW9ufX19dC52ZXJib3NlPWZ1bmN0aW9uKGUsbil7dChcInZlcmJvc2VcIixlLG4pfSx0LmluZm89ZnVuY3Rpb24oZSxuKXt0KFwiaW5mb1wiLGUsbil9LHQud2FybmluZz1mdW5jdGlvbihlLG4pe3QoXCJ3YXJuaW5nXCIsZSxuKX0sdC5lcnJvcj1mdW5jdGlvbihlLG4pe3QoXCJlcnJvclwiLGUsbil9LHQuZmF0YWw9ZnVuY3Rpb24oZSxuKXt0KFwiZmF0YWxcIixlLG4pfSx0LnJlc2V0PWUsdC5zZXQ9bix0LnNldFdpdGhFbnY9ZnVuY3Rpb24odCl7Y29uc3QgZT17fTt0LmxvZ0xldmVsJiYoZS5taW5pbWFsU2V2ZXJpdHk9dC5sb2dMZXZlbCksbihcIlwiLGUpfX0oYXx8KGE9e30pKSxlLkxvZ2dlcj1hO2NsYXNzIHV7Y29uc3RydWN0b3IodCxlLG4scixpLG8pe3RoaXMuY2F0ZWdvcnk9dCx0aGlzLm5hbWU9ZSx0aGlzLnN0YXJ0VGltZT1uLHRoaXMuZW5kQ2FsbGJhY2s9cix0aGlzLnRpbWVyPWksdGhpcy5jdHg9b31lbmQoKXtyZXR1cm4gdGhpcy5lbmRDYWxsYmFjayh0aGlzKX1hc3luYyBjaGVja1RpbWVyKCl7aWYodm9pZCAwPT09dGhpcy5jdHh8fHZvaWQgMD09PXRoaXMudGltZXIpdGhyb3cgbmV3IEVycm9yKFwiTm8gd2ViZ2wgdGltZXIgZm91bmRcIik7cmV0dXJuIHRoaXMuY3R4LmVuZFRpbWVyKCksdGhpcy5jdHgud2FpdEZvclF1ZXJ5QW5kR2V0VGltZSh0aGlzLnRpbWVyKX19Y2xhc3MgY3tjb25zdHJ1Y3Rvcih0LGUsbixyKXt0aGlzLmNhdGVnb3J5PXQsdGhpcy5uYW1lPWUsdGhpcy5zdGFydFRpbWU9bix0aGlzLmVuZFRpbWU9cn19ZS5Qcm9maWxlcj1jbGFzc3tzdGF0aWMgY3JlYXRlKHQpe3JldHVybiB2b2lkIDA9PT10P25ldyB0aGlzOm5ldyB0aGlzKHQubWF4TnVtYmVyRXZlbnRzLHQuZmx1c2hCYXRjaFNpemUsdC5mbHVzaEludGVydmFsSW5NaWxsaXNlY29uZHMpfWNvbnN0cnVjdG9yKHQsZSxuKXt0aGlzLl9zdGFydGVkPSExLHRoaXMuX2ZsdXNoUG9pbnRlcj0wLHRoaXMuX3N0YXJ0ZWQ9ITEsdGhpcy5fbWF4TnVtYmVyRXZlbnRzPXZvaWQgMD09PXQ/MWU0OnQsdGhpcy5fZmx1c2hCYXRjaFNpemU9dm9pZCAwPT09ZT8xMDplLHRoaXMuX2ZsdXNoSW50ZXJ2YWxJbk1pbGxpc2Vjb25kcz12b2lkIDA9PT1uPzVlMzpufXN0YXJ0KCl7dGhpcy5fc3RhcnRlZD0hMCx0aGlzLl90aW1pbmdFdmVudHM9W10sdGhpcy5fZmx1c2hUaW1lPSgwLGUubm93KSgpLHRoaXMuX2ZsdXNoUG9pbnRlcj0wfXN0b3AoKXtmb3IodGhpcy5fc3RhcnRlZD0hMTt0aGlzLl9mbHVzaFBvaW50ZXI8dGhpcy5fdGltaW5nRXZlbnRzLmxlbmd0aDt0aGlzLl9mbHVzaFBvaW50ZXIrKyl0aGlzLmxvZ09uZUV2ZW50KHRoaXMuX3RpbWluZ0V2ZW50c1t0aGlzLl9mbHVzaFBvaW50ZXJdKX1ldmVudCh0LGUsbixyKXtjb25zdCBpPXRoaXMuX3N0YXJ0ZWQ/dGhpcy5iZWdpbih0LGUscik6dm9pZCAwO2xldCBvPSExO2NvbnN0IGE9bigpO2lmKGEmJlwiZnVuY3Rpb25cIj09dHlwZW9mIGEudGhlbilyZXR1cm4gbz0hMCxuZXcgUHJvbWlzZSgoKHQsZSk9PnthLnRoZW4oKGFzeW5jIGU9PntpJiZhd2FpdCBpLmVuZCgpLHQoZSl9KSwoYXN5bmMgdD0+e2kmJmF3YWl0IGkuZW5kKCksZSh0KX0pKX0pKTtpZighbyYmaSl7Y29uc3QgdD1pLmVuZCgpO2lmKHQmJlwiZnVuY3Rpb25cIj09dHlwZW9mIHQudGhlbilyZXR1cm4gbmV3IFByb21pc2UoKChlLG4pPT57dC50aGVuKCgoKT0+e2UoYSl9KSwodD0+e24odCl9KSl9KSl9cmV0dXJuIGF9YmVnaW4odCxuLHIpe2lmKCF0aGlzLl9zdGFydGVkKXRocm93IG5ldyBFcnJvcihcInByb2ZpbGVyIGlzIG5vdCBzdGFydGVkIHlldFwiKTtpZih2b2lkIDA9PT1yKXtjb25zdCByPSgwLGUubm93KSgpO3JldHVybiB0aGlzLmZsdXNoKHIpLG5ldyB1KHQsbixyLCh0PT50aGlzLmVuZFN5bmModCkpKX17Y29uc3QgZT1yLmJlZ2luVGltZXIoKTtyZXR1cm4gbmV3IHUodCxuLDAsKGFzeW5jIHQ9PnRoaXMuZW5kKHQpKSxlLHIpfX1hc3luYyBlbmQodCl7Y29uc3QgZT1hd2FpdCB0LmNoZWNrVGltZXIoKTt0aGlzLl90aW1pbmdFdmVudHMubGVuZ3RoPHRoaXMuX21heE51bWJlckV2ZW50cyYmKHRoaXMuX3RpbWluZ0V2ZW50cy5wdXNoKG5ldyBjKHQuY2F0ZWdvcnksdC5uYW1lLHQuc3RhcnRUaW1lLGUpKSx0aGlzLmZsdXNoKGUpKX1lbmRTeW5jKHQpe2NvbnN0IG49KDAsZS5ub3cpKCk7dGhpcy5fdGltaW5nRXZlbnRzLmxlbmd0aDx0aGlzLl9tYXhOdW1iZXJFdmVudHMmJih0aGlzLl90aW1pbmdFdmVudHMucHVzaChuZXcgYyh0LmNhdGVnb3J5LHQubmFtZSx0LnN0YXJ0VGltZSxuKSksdGhpcy5mbHVzaChuKSl9bG9nT25lRXZlbnQodCl7ZS5Mb2dnZXIudmVyYm9zZShgUHJvZmlsZXIuJHt0LmNhdGVnb3J5fWAsYCR7KHQuZW5kVGltZS10LnN0YXJ0VGltZSkudG9GaXhlZCgyKX1tcyBvbiBldmVudCAnJHt0Lm5hbWV9JyBhdCAke3QuZW5kVGltZS50b0ZpeGVkKDIpfWApfWZsdXNoKHQpe2lmKHRoaXMuX3RpbWluZ0V2ZW50cy5sZW5ndGgtdGhpcy5fZmx1c2hQb2ludGVyPj10aGlzLl9mbHVzaEJhdGNoU2l6ZXx8dC10aGlzLl9mbHVzaFRpbWU+PXRoaXMuX2ZsdXNoSW50ZXJ2YWxJbk1pbGxpc2Vjb25kcyl7Zm9yKGNvbnN0IHQ9dGhpcy5fZmx1c2hQb2ludGVyO3RoaXMuX2ZsdXNoUG9pbnRlcjx0K3RoaXMuX2ZsdXNoQmF0Y2hTaXplJiZ0aGlzLl9mbHVzaFBvaW50ZXI8dGhpcy5fdGltaW5nRXZlbnRzLmxlbmd0aDt0aGlzLl9mbHVzaFBvaW50ZXIrKyl0aGlzLmxvZ09uZUV2ZW50KHRoaXMuX3RpbWluZ0V2ZW50c1t0aGlzLl9mbHVzaFBvaW50ZXJdKTt0aGlzLl9mbHVzaFRpbWU9KDAsZS5ub3cpKCl9fWdldCBzdGFydGVkKCl7cmV0dXJuIHRoaXMuX3N0YXJ0ZWR9fSxlLm5vdz1cInVuZGVmaW5lZFwiIT10eXBlb2YgcGVyZm9ybWFuY2UmJnBlcmZvcm1hbmNlLm5vdz8oKT0+cGVyZm9ybWFuY2Uubm93KCk6RGF0ZS5ub3d9LDI2NDQ6KHQsZSxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUuTW9kZWw9dm9pZCAwO2NvbnN0IHI9big1Njg2KSxpPW4oMTQ0Niksbz1uKDcwNzApLGE9big5Mzk1KSxzPW4oMjUxNyk7dmFyIHU9YS5vbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzO2UuTW9kZWw9Y2xhc3N7Y29uc3RydWN0b3IoKXt9bG9hZCh0LGUsbil7aWYoIW4pdHJ5e3JldHVybiB2b2lkIHRoaXMubG9hZEZyb21Pbm54Rm9ybWF0KHQsZSl9Y2F0Y2godCl7aWYodm9pZCAwIT09bil0aHJvdyB0fXRoaXMubG9hZEZyb21PcnRGb3JtYXQodCxlKX1sb2FkRnJvbU9ubnhGb3JtYXQodCxlKXtjb25zdCBuPWkub25ueC5Nb2RlbFByb3RvLmRlY29kZSh0KTtpZihzLkxvbmdVdGlsLmxvbmdUb051bWJlcihuLmlyVmVyc2lvbik8Myl0aHJvdyBuZXcgRXJyb3IoXCJvbmx5IHN1cHBvcnQgT05OWCBtb2RlbCB3aXRoIElSX1ZFUlNJT04+PTNcIik7dGhpcy5fb3BzZXRzPW4ub3BzZXRJbXBvcnQubWFwKCh0PT4oe2RvbWFpbjp0LmRvbWFpbix2ZXJzaW9uOnMuTG9uZ1V0aWwubG9uZ1RvTnVtYmVyKHQudmVyc2lvbil9KSkpLHRoaXMuX2dyYXBoPW8uR3JhcGguZnJvbShuLmdyYXBoLGUpfWxvYWRGcm9tT3J0Rm9ybWF0KHQsZSl7Y29uc3Qgbj1uZXcgci5mbGF0YnVmZmVycy5CeXRlQnVmZmVyKHQpLGk9dS5JbmZlcmVuY2VTZXNzaW9uLmdldFJvb3RBc0luZmVyZW5jZVNlc3Npb24obikubW9kZWwoKTtpZihzLkxvbmdVdGlsLmxvbmdUb051bWJlcihpLmlyVmVyc2lvbigpKTwzKXRocm93IG5ldyBFcnJvcihcIm9ubHkgc3VwcG9ydCBPTk5YIG1vZGVsIHdpdGggSVJfVkVSU0lPTj49M1wiKTt0aGlzLl9vcHNldHM9W107Zm9yKGxldCB0PTA7dDxpLm9wc2V0SW1wb3J0TGVuZ3RoKCk7dCsrKXtjb25zdCBlPWkub3BzZXRJbXBvcnQodCk7dGhpcy5fb3BzZXRzLnB1c2goe2RvbWFpbjpudWxsPT1lP3ZvaWQgMDplLmRvbWFpbigpLHZlcnNpb246cy5Mb25nVXRpbC5sb25nVG9OdW1iZXIoZS52ZXJzaW9uKCkpfSl9dGhpcy5fZ3JhcGg9by5HcmFwaC5mcm9tKGkuZ3JhcGgoKSxlKX1nZXQgZ3JhcGgoKXtyZXR1cm4gdGhpcy5fZ3JhcGh9Z2V0IG9wc2V0cygpe3JldHVybiB0aGlzLl9vcHNldHN9fX0sNzgyOih0LGUpPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5GTE9BVF9UWVBFUz1lLklOVF9UWVBFUz1lLk5VTUJFUl9UWVBFUz12b2lkIDAsZS5OVU1CRVJfVFlQRVM9W1wiZmxvYXQzMlwiLFwiZmxvYXQ2NFwiLFwiaW50MzJcIixcImludDE2XCIsXCJpbnQ4XCIsXCJ1aW50MTZcIixcInVpbnQzMlwiLFwidWludDhcIl0sZS5JTlRfVFlQRVM9W1wiaW50MzJcIixcImludDE2XCIsXCJpbnQ4XCIsXCJ1aW50MTZcIixcInVpbnQzMlwiLFwidWludDhcIl0sZS5GTE9BVF9UWVBFUz1bXCJmbG9hdDMyXCIsXCJmbG9hdDY0XCJdfSwxMDQ3Oih0LGUpPT57XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gbih0LGUpe2lmKGUuZW5kc1dpdGgoXCIrXCIpKXtjb25zdCBuPU51bWJlci5wYXJzZUludChlLnN1YnN0cmluZygwLGUubGVuZ3RoLTEpLDEwKTtyZXR1cm4haXNOYU4obikmJm48PXR9aWYoMj09PWUuc3BsaXQoXCItXCIpLmxlbmd0aCl7Y29uc3Qgbj1lLnNwbGl0KFwiLVwiKSxyPU51bWJlci5wYXJzZUludChuWzBdLDEwKSxpPU51bWJlci5wYXJzZUludChuWzFdLDEwKTtyZXR1cm4haXNOYU4ocikmJiFpc05hTihpKSYmcjw9dCYmdDw9aX1yZXR1cm4gTnVtYmVyLnBhcnNlSW50KGUsMTApPT09dH1PYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLnJlc29sdmVPcGVyYXRvcj12b2lkIDAsZS5yZXNvbHZlT3BlcmF0b3I9ZnVuY3Rpb24odCxlLHIpe2Zvcihjb25zdCBpIG9mIHIpe2NvbnN0IHI9aVswXSxvPWlbMV0sYT1pWzJdLHM9aVszXSx1PWlbNF07aWYodC5vcFR5cGU9PT1yKWZvcihjb25zdCB0IG9mIGUpaWYoKHQuZG9tYWluPT09b3x8XCJhaS5vbm54XCI9PT10LmRvbWFpbiYmXCJcIj09PW8pJiZuKHQudmVyc2lvbixhKSlyZXR1cm57b3BJbXBsOnMsb3BJbml0OnV9fXRocm93IG5ldyBUeXBlRXJyb3IoYGNhbm5vdCByZXNvbHZlIG9wZXJhdG9yICcke3Qub3BUeXBlfScgd2l0aCBvcHNldHM6ICR7ZS5tYXAoKHQ9PmAke3QuZG9tYWlufHxcImFpLm9ubnhcIn0gdiR7dC52ZXJzaW9ufWApKS5qb2luKFwiLCBcIil9YCl9fSw5Mzk1Oih0LGUsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLm9ubnhydW50aW1lPXZvaWQgMDtjb25zdCByPW4oNTY4Nik7dmFyIGksbztpPWUub25ueHJ1bnRpbWV8fChlLm9ubnhydW50aW1lPXt9KSxmdW5jdGlvbih0KXtsZXQgZTshZnVuY3Rpb24odCl7dFt0LlVOREVGSU5FRD0wXT1cIlVOREVGSU5FRFwiLHRbdC5GTE9BVD0xXT1cIkZMT0FUXCIsdFt0LklOVD0yXT1cIklOVFwiLHRbdC5TVFJJTkc9M109XCJTVFJJTkdcIix0W3QuVEVOU09SPTRdPVwiVEVOU09SXCIsdFt0LkdSQVBIPTVdPVwiR1JBUEhcIix0W3QuRkxPQVRTPTZdPVwiRkxPQVRTXCIsdFt0LklOVFM9N109XCJJTlRTXCIsdFt0LlNUUklOR1M9OF09XCJTVFJJTkdTXCIsdFt0LlRFTlNPUlM9OV09XCJURU5TT1JTXCIsdFt0LkdSQVBIUz0xMF09XCJHUkFQSFNcIix0W3QuU1BBUlNFX1RFTlNPUj0xMV09XCJTUEFSU0VfVEVOU09SXCIsdFt0LlNQQVJTRV9URU5TT1JTPTEyXT1cIlNQQVJTRV9URU5TT1JTXCJ9KGU9dC5BdHRyaWJ1dGVUeXBlfHwodC5BdHRyaWJ1dGVUeXBlPXt9KSl9KChvPWkuZXhwZXJpbWVudGFsfHwoaS5leHBlcmltZW50YWw9e30pKS5mYnN8fChvLmZicz17fSkpLGZ1bmN0aW9uKHQpeyFmdW5jdGlvbih0KXshZnVuY3Rpb24odCl7bGV0IGU7IWZ1bmN0aW9uKHQpe3RbdC5VTktOT1dOPTBdPVwiVU5LTk9XTlwiLHRbdC5WQUxVRT0xXT1cIlZBTFVFXCIsdFt0LlBBUkFNPTJdPVwiUEFSQU1cIn0oZT10LkRpbWVuc2lvblZhbHVlVHlwZXx8KHQuRGltZW5zaW9uVmFsdWVUeXBlPXt9KSl9KHQuZmJzfHwodC5mYnM9e30pKX0odC5leHBlcmltZW50YWx8fCh0LmV4cGVyaW1lbnRhbD17fSkpfShlLm9ubnhydW50aW1lfHwoZS5vbm54cnVudGltZT17fSkpLGZ1bmN0aW9uKHQpeyFmdW5jdGlvbih0KXshZnVuY3Rpb24odCl7bGV0IGU7IWZ1bmN0aW9uKHQpe3RbdC5VTkRFRklORUQ9MF09XCJVTkRFRklORURcIix0W3QuRkxPQVQ9MV09XCJGTE9BVFwiLHRbdC5VSU5UOD0yXT1cIlVJTlQ4XCIsdFt0LklOVDg9M109XCJJTlQ4XCIsdFt0LlVJTlQxNj00XT1cIlVJTlQxNlwiLHRbdC5JTlQxNj01XT1cIklOVDE2XCIsdFt0LklOVDMyPTZdPVwiSU5UMzJcIix0W3QuSU5UNjQ9N109XCJJTlQ2NFwiLHRbdC5TVFJJTkc9OF09XCJTVFJJTkdcIix0W3QuQk9PTD05XT1cIkJPT0xcIix0W3QuRkxPQVQxNj0xMF09XCJGTE9BVDE2XCIsdFt0LkRPVUJMRT0xMV09XCJET1VCTEVcIix0W3QuVUlOVDMyPTEyXT1cIlVJTlQzMlwiLHRbdC5VSU5UNjQ9MTNdPVwiVUlOVDY0XCIsdFt0LkNPTVBMRVg2ND0xNF09XCJDT01QTEVYNjRcIix0W3QuQ09NUExFWDEyOD0xNV09XCJDT01QTEVYMTI4XCIsdFt0LkJGTE9BVDE2PTE2XT1cIkJGTE9BVDE2XCJ9KGU9dC5UZW5zb3JEYXRhVHlwZXx8KHQuVGVuc29yRGF0YVR5cGU9e30pKX0odC5mYnN8fCh0LmZicz17fSkpfSh0LmV4cGVyaW1lbnRhbHx8KHQuZXhwZXJpbWVudGFsPXt9KSl9KGUub25ueHJ1bnRpbWV8fChlLm9ubnhydW50aW1lPXt9KSksZnVuY3Rpb24odCl7IWZ1bmN0aW9uKHQpeyFmdW5jdGlvbih0KXtsZXQgZTshZnVuY3Rpb24odCl7dFt0LlByaW1pdGl2ZT0wXT1cIlByaW1pdGl2ZVwiLHRbdC5GdXNlZD0xXT1cIkZ1c2VkXCJ9KGU9dC5Ob2RlVHlwZXx8KHQuTm9kZVR5cGU9e30pKX0odC5mYnN8fCh0LmZicz17fSkpfSh0LmV4cGVyaW1lbnRhbHx8KHQuZXhwZXJpbWVudGFsPXt9KSl9KGUub25ueHJ1bnRpbWV8fChlLm9ubnhydW50aW1lPXt9KSksZnVuY3Rpb24odCl7IWZ1bmN0aW9uKHQpeyFmdW5jdGlvbih0KXtsZXQgZTshZnVuY3Rpb24odCl7dFt0Lk5PTkU9MF09XCJOT05FXCIsdFt0LnRlbnNvcl90eXBlPTFdPVwidGVuc29yX3R5cGVcIix0W3Quc2VxdWVuY2VfdHlwZT0yXT1cInNlcXVlbmNlX3R5cGVcIix0W3QubWFwX3R5cGU9M109XCJtYXBfdHlwZVwifShlPXQuVHlwZUluZm9WYWx1ZXx8KHQuVHlwZUluZm9WYWx1ZT17fSkpfSh0LmZic3x8KHQuZmJzPXt9KSl9KHQuZXhwZXJpbWVudGFsfHwodC5leHBlcmltZW50YWw9e30pKX0oZS5vbm54cnVudGltZXx8KGUub25ueHJ1bnRpbWU9e30pKSxmdW5jdGlvbih0KXshZnVuY3Rpb24oZSl7IWZ1bmN0aW9uKGUpe2NsYXNzIG57Y29uc3RydWN0b3IoKXt0aGlzLmJiPW51bGwsdGhpcy5iYl9wb3M9MH1fX2luaXQodCxlKXtyZXR1cm4gdGhpcy5iYl9wb3M9dCx0aGlzLmJiPWUsdGhpc31zdGF0aWMgZ2V0Um9vdEFzU2hhcGUodCxlKXtyZXR1cm4oZXx8bmV3IG4pLl9faW5pdCh0LnJlYWRJbnQzMih0LnBvc2l0aW9uKCkpK3QucG9zaXRpb24oKSx0KX1zdGF0aWMgZ2V0U2l6ZVByZWZpeGVkUm9vdEFzU2hhcGUodCxlKXtyZXR1cm4gdC5zZXRQb3NpdGlvbih0LnBvc2l0aW9uKCkrci5mbGF0YnVmZmVycy5TSVpFX1BSRUZJWF9MRU5HVEgpLChlfHxuZXcgbikuX19pbml0KHQucmVhZEludDMyKHQucG9zaXRpb24oKSkrdC5wb3NpdGlvbigpLHQpfWRpbShlLG4pe2xldCByPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNCk7cmV0dXJuIHI/KG58fG5ldyB0LmV4cGVyaW1lbnRhbC5mYnMuRGltZW5zaW9uKS5fX2luaXQodGhpcy5iYi5fX2luZGlyZWN0KHRoaXMuYmIuX192ZWN0b3IodGhpcy5iYl9wb3MrcikrNCplKSx0aGlzLmJiKTpudWxsfWRpbUxlbmd0aCgpe2xldCB0PXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNCk7cmV0dXJuIHQ/dGhpcy5iYi5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MrdCk6MH1zdGF0aWMgc3RhcnRTaGFwZSh0KXt0LnN0YXJ0T2JqZWN0KDEpfXN0YXRpYyBhZGREaW0odCxlKXt0LmFkZEZpZWxkT2Zmc2V0KDAsZSwwKX1zdGF0aWMgY3JlYXRlRGltVmVjdG9yKHQsZSl7dC5zdGFydFZlY3Rvcig0LGUubGVuZ3RoLDQpO2ZvcihsZXQgbj1lLmxlbmd0aC0xO24+PTA7bi0tKXQuYWRkT2Zmc2V0KGVbbl0pO3JldHVybiB0LmVuZFZlY3RvcigpfXN0YXRpYyBzdGFydERpbVZlY3Rvcih0LGUpe3Quc3RhcnRWZWN0b3IoNCxlLDQpfXN0YXRpYyBlbmRTaGFwZSh0KXtyZXR1cm4gdC5lbmRPYmplY3QoKX1zdGF0aWMgY3JlYXRlU2hhcGUodCxlKXtyZXR1cm4gbi5zdGFydFNoYXBlKHQpLG4uYWRkRGltKHQsZSksbi5lbmRTaGFwZSh0KX19ZS5TaGFwZT1ufShlLmZic3x8KGUuZmJzPXt9KSl9KHQuZXhwZXJpbWVudGFsfHwodC5leHBlcmltZW50YWw9e30pKX0oZS5vbm54cnVudGltZXx8KGUub25ueHJ1bnRpbWU9e30pKSxmdW5jdGlvbih0KXshZnVuY3Rpb24oZSl7IWZ1bmN0aW9uKGUpe2NsYXNzIG57Y29uc3RydWN0b3IoKXt0aGlzLmJiPW51bGwsdGhpcy5iYl9wb3M9MH1fX2luaXQodCxlKXtyZXR1cm4gdGhpcy5iYl9wb3M9dCx0aGlzLmJiPWUsdGhpc31zdGF0aWMgZ2V0Um9vdEFzRGltZW5zaW9uKHQsZSl7cmV0dXJuKGV8fG5ldyBuKS5fX2luaXQodC5yZWFkSW50MzIodC5wb3NpdGlvbigpKSt0LnBvc2l0aW9uKCksdCl9c3RhdGljIGdldFNpemVQcmVmaXhlZFJvb3RBc0RpbWVuc2lvbih0LGUpe3JldHVybiB0LnNldFBvc2l0aW9uKHQucG9zaXRpb24oKStyLmZsYXRidWZmZXJzLlNJWkVfUFJFRklYX0xFTkdUSCksKGV8fG5ldyBuKS5fX2luaXQodC5yZWFkSW50MzIodC5wb3NpdGlvbigpKSt0LnBvc2l0aW9uKCksdCl9dmFsdWUoZSl7bGV0IG49dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw0KTtyZXR1cm4gbj8oZXx8bmV3IHQuZXhwZXJpbWVudGFsLmZicy5EaW1lbnNpb25WYWx1ZSkuX19pbml0KHRoaXMuYmIuX19pbmRpcmVjdCh0aGlzLmJiX3BvcytuKSx0aGlzLmJiKTpudWxsfWRlbm90YXRpb24odCl7bGV0IGU9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw2KTtyZXR1cm4gZT90aGlzLmJiLl9fc3RyaW5nKHRoaXMuYmJfcG9zK2UsdCk6bnVsbH1zdGF0aWMgc3RhcnREaW1lbnNpb24odCl7dC5zdGFydE9iamVjdCgyKX1zdGF0aWMgYWRkVmFsdWUodCxlKXt0LmFkZEZpZWxkT2Zmc2V0KDAsZSwwKX1zdGF0aWMgYWRkRGVub3RhdGlvbih0LGUpe3QuYWRkRmllbGRPZmZzZXQoMSxlLDApfXN0YXRpYyBlbmREaW1lbnNpb24odCl7cmV0dXJuIHQuZW5kT2JqZWN0KCl9c3RhdGljIGNyZWF0ZURpbWVuc2lvbih0LGUscil7cmV0dXJuIG4uc3RhcnREaW1lbnNpb24odCksbi5hZGRWYWx1ZSh0LGUpLG4uYWRkRGVub3RhdGlvbih0LHIpLG4uZW5kRGltZW5zaW9uKHQpfX1lLkRpbWVuc2lvbj1ufShlLmZic3x8KGUuZmJzPXt9KSl9KHQuZXhwZXJpbWVudGFsfHwodC5leHBlcmltZW50YWw9e30pKX0oZS5vbm54cnVudGltZXx8KGUub25ueHJ1bnRpbWU9e30pKSxmdW5jdGlvbih0KXshZnVuY3Rpb24oZSl7IWZ1bmN0aW9uKGUpe2NsYXNzIG57Y29uc3RydWN0b3IoKXt0aGlzLmJiPW51bGwsdGhpcy5iYl9wb3M9MH1fX2luaXQodCxlKXtyZXR1cm4gdGhpcy5iYl9wb3M9dCx0aGlzLmJiPWUsdGhpc31zdGF0aWMgZ2V0Um9vdEFzRGltZW5zaW9uVmFsdWUodCxlKXtyZXR1cm4oZXx8bmV3IG4pLl9faW5pdCh0LnJlYWRJbnQzMih0LnBvc2l0aW9uKCkpK3QucG9zaXRpb24oKSx0KX1zdGF0aWMgZ2V0U2l6ZVByZWZpeGVkUm9vdEFzRGltZW5zaW9uVmFsdWUodCxlKXtyZXR1cm4gdC5zZXRQb3NpdGlvbih0LnBvc2l0aW9uKCkrci5mbGF0YnVmZmVycy5TSVpFX1BSRUZJWF9MRU5HVEgpLChlfHxuZXcgbikuX19pbml0KHQucmVhZEludDMyKHQucG9zaXRpb24oKSkrdC5wb3NpdGlvbigpLHQpfWRpbVR5cGUoKXtsZXQgZT10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDQpO3JldHVybiBlP3RoaXMuYmIucmVhZEludDgodGhpcy5iYl9wb3MrZSk6dC5leHBlcmltZW50YWwuZmJzLkRpbWVuc2lvblZhbHVlVHlwZS5VTktOT1dOfWRpbVZhbHVlKCl7bGV0IHQ9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw2KTtyZXR1cm4gdD90aGlzLmJiLnJlYWRJbnQ2NCh0aGlzLmJiX3Bvcyt0KTp0aGlzLmJiLmNyZWF0ZUxvbmcoMCwwKX1kaW1QYXJhbSh0KXtsZXQgZT10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDgpO3JldHVybiBlP3RoaXMuYmIuX19zdHJpbmcodGhpcy5iYl9wb3MrZSx0KTpudWxsfXN0YXRpYyBzdGFydERpbWVuc2lvblZhbHVlKHQpe3Quc3RhcnRPYmplY3QoMyl9c3RhdGljIGFkZERpbVR5cGUoZSxuKXtlLmFkZEZpZWxkSW50OCgwLG4sdC5leHBlcmltZW50YWwuZmJzLkRpbWVuc2lvblZhbHVlVHlwZS5VTktOT1dOKX1zdGF0aWMgYWRkRGltVmFsdWUodCxlKXt0LmFkZEZpZWxkSW50NjQoMSxlLHQuY3JlYXRlTG9uZygwLDApKX1zdGF0aWMgYWRkRGltUGFyYW0odCxlKXt0LmFkZEZpZWxkT2Zmc2V0KDIsZSwwKX1zdGF0aWMgZW5kRGltZW5zaW9uVmFsdWUodCl7cmV0dXJuIHQuZW5kT2JqZWN0KCl9c3RhdGljIGNyZWF0ZURpbWVuc2lvblZhbHVlKHQsZSxyLGkpe3JldHVybiBuLnN0YXJ0RGltZW5zaW9uVmFsdWUodCksbi5hZGREaW1UeXBlKHQsZSksbi5hZGREaW1WYWx1ZSh0LHIpLG4uYWRkRGltUGFyYW0odCxpKSxuLmVuZERpbWVuc2lvblZhbHVlKHQpfX1lLkRpbWVuc2lvblZhbHVlPW59KGUuZmJzfHwoZS5mYnM9e30pKX0odC5leHBlcmltZW50YWx8fCh0LmV4cGVyaW1lbnRhbD17fSkpfShlLm9ubnhydW50aW1lfHwoZS5vbm54cnVudGltZT17fSkpLGZ1bmN0aW9uKHQpeyFmdW5jdGlvbihlKXshZnVuY3Rpb24oZSl7Y2xhc3Mgbntjb25zdHJ1Y3Rvcigpe3RoaXMuYmI9bnVsbCx0aGlzLmJiX3Bvcz0wfV9faW5pdCh0LGUpe3JldHVybiB0aGlzLmJiX3Bvcz10LHRoaXMuYmI9ZSx0aGlzfXN0YXRpYyBnZXRSb290QXNUZW5zb3JUeXBlQW5kU2hhcGUodCxlKXtyZXR1cm4oZXx8bmV3IG4pLl9faW5pdCh0LnJlYWRJbnQzMih0LnBvc2l0aW9uKCkpK3QucG9zaXRpb24oKSx0KX1zdGF0aWMgZ2V0U2l6ZVByZWZpeGVkUm9vdEFzVGVuc29yVHlwZUFuZFNoYXBlKHQsZSl7cmV0dXJuIHQuc2V0UG9zaXRpb24odC5wb3NpdGlvbigpK3IuZmxhdGJ1ZmZlcnMuU0laRV9QUkVGSVhfTEVOR1RIKSwoZXx8bmV3IG4pLl9faW5pdCh0LnJlYWRJbnQzMih0LnBvc2l0aW9uKCkpK3QucG9zaXRpb24oKSx0KX1lbGVtVHlwZSgpe2xldCBlPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNCk7cmV0dXJuIGU/dGhpcy5iYi5yZWFkSW50MzIodGhpcy5iYl9wb3MrZSk6dC5leHBlcmltZW50YWwuZmJzLlRlbnNvckRhdGFUeXBlLlVOREVGSU5FRH1zaGFwZShlKXtsZXQgbj10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDYpO3JldHVybiBuPyhlfHxuZXcgdC5leHBlcmltZW50YWwuZmJzLlNoYXBlKS5fX2luaXQodGhpcy5iYi5fX2luZGlyZWN0KHRoaXMuYmJfcG9zK24pLHRoaXMuYmIpOm51bGx9c3RhdGljIHN0YXJ0VGVuc29yVHlwZUFuZFNoYXBlKHQpe3Quc3RhcnRPYmplY3QoMil9c3RhdGljIGFkZEVsZW1UeXBlKGUsbil7ZS5hZGRGaWVsZEludDMyKDAsbix0LmV4cGVyaW1lbnRhbC5mYnMuVGVuc29yRGF0YVR5cGUuVU5ERUZJTkVEKX1zdGF0aWMgYWRkU2hhcGUodCxlKXt0LmFkZEZpZWxkT2Zmc2V0KDEsZSwwKX1zdGF0aWMgZW5kVGVuc29yVHlwZUFuZFNoYXBlKHQpe3JldHVybiB0LmVuZE9iamVjdCgpfXN0YXRpYyBjcmVhdGVUZW5zb3JUeXBlQW5kU2hhcGUodCxlLHIpe3JldHVybiBuLnN0YXJ0VGVuc29yVHlwZUFuZFNoYXBlKHQpLG4uYWRkRWxlbVR5cGUodCxlKSxuLmFkZFNoYXBlKHQsciksbi5lbmRUZW5zb3JUeXBlQW5kU2hhcGUodCl9fWUuVGVuc29yVHlwZUFuZFNoYXBlPW59KGUuZmJzfHwoZS5mYnM9e30pKX0odC5leHBlcmltZW50YWx8fCh0LmV4cGVyaW1lbnRhbD17fSkpfShlLm9ubnhydW50aW1lfHwoZS5vbm54cnVudGltZT17fSkpLGZ1bmN0aW9uKHQpeyFmdW5jdGlvbihlKXshZnVuY3Rpb24oZSl7Y2xhc3Mgbntjb25zdHJ1Y3Rvcigpe3RoaXMuYmI9bnVsbCx0aGlzLmJiX3Bvcz0wfV9faW5pdCh0LGUpe3JldHVybiB0aGlzLmJiX3Bvcz10LHRoaXMuYmI9ZSx0aGlzfXN0YXRpYyBnZXRSb290QXNNYXBUeXBlKHQsZSl7cmV0dXJuKGV8fG5ldyBuKS5fX2luaXQodC5yZWFkSW50MzIodC5wb3NpdGlvbigpKSt0LnBvc2l0aW9uKCksdCl9c3RhdGljIGdldFNpemVQcmVmaXhlZFJvb3RBc01hcFR5cGUodCxlKXtyZXR1cm4gdC5zZXRQb3NpdGlvbih0LnBvc2l0aW9uKCkrci5mbGF0YnVmZmVycy5TSVpFX1BSRUZJWF9MRU5HVEgpLChlfHxuZXcgbikuX19pbml0KHQucmVhZEludDMyKHQucG9zaXRpb24oKSkrdC5wb3NpdGlvbigpLHQpfWtleVR5cGUoKXtsZXQgZT10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDQpO3JldHVybiBlP3RoaXMuYmIucmVhZEludDMyKHRoaXMuYmJfcG9zK2UpOnQuZXhwZXJpbWVudGFsLmZicy5UZW5zb3JEYXRhVHlwZS5VTkRFRklORUR9dmFsdWVUeXBlKGUpe2xldCBuPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNik7cmV0dXJuIG4/KGV8fG5ldyB0LmV4cGVyaW1lbnRhbC5mYnMuVHlwZUluZm8pLl9faW5pdCh0aGlzLmJiLl9faW5kaXJlY3QodGhpcy5iYl9wb3MrbiksdGhpcy5iYik6bnVsbH1zdGF0aWMgc3RhcnRNYXBUeXBlKHQpe3Quc3RhcnRPYmplY3QoMil9c3RhdGljIGFkZEtleVR5cGUoZSxuKXtlLmFkZEZpZWxkSW50MzIoMCxuLHQuZXhwZXJpbWVudGFsLmZicy5UZW5zb3JEYXRhVHlwZS5VTkRFRklORUQpfXN0YXRpYyBhZGRWYWx1ZVR5cGUodCxlKXt0LmFkZEZpZWxkT2Zmc2V0KDEsZSwwKX1zdGF0aWMgZW5kTWFwVHlwZSh0KXtyZXR1cm4gdC5lbmRPYmplY3QoKX1zdGF0aWMgY3JlYXRlTWFwVHlwZSh0LGUscil7cmV0dXJuIG4uc3RhcnRNYXBUeXBlKHQpLG4uYWRkS2V5VHlwZSh0LGUpLG4uYWRkVmFsdWVUeXBlKHQsciksbi5lbmRNYXBUeXBlKHQpfX1lLk1hcFR5cGU9bn0oZS5mYnN8fChlLmZicz17fSkpfSh0LmV4cGVyaW1lbnRhbHx8KHQuZXhwZXJpbWVudGFsPXt9KSl9KGUub25ueHJ1bnRpbWV8fChlLm9ubnhydW50aW1lPXt9KSksZnVuY3Rpb24odCl7IWZ1bmN0aW9uKGUpeyFmdW5jdGlvbihlKXtjbGFzcyBue2NvbnN0cnVjdG9yKCl7dGhpcy5iYj1udWxsLHRoaXMuYmJfcG9zPTB9X19pbml0KHQsZSl7cmV0dXJuIHRoaXMuYmJfcG9zPXQsdGhpcy5iYj1lLHRoaXN9c3RhdGljIGdldFJvb3RBc1NlcXVlbmNlVHlwZSh0LGUpe3JldHVybihlfHxuZXcgbikuX19pbml0KHQucmVhZEludDMyKHQucG9zaXRpb24oKSkrdC5wb3NpdGlvbigpLHQpfXN0YXRpYyBnZXRTaXplUHJlZml4ZWRSb290QXNTZXF1ZW5jZVR5cGUodCxlKXtyZXR1cm4gdC5zZXRQb3NpdGlvbih0LnBvc2l0aW9uKCkrci5mbGF0YnVmZmVycy5TSVpFX1BSRUZJWF9MRU5HVEgpLChlfHxuZXcgbikuX19pbml0KHQucmVhZEludDMyKHQucG9zaXRpb24oKSkrdC5wb3NpdGlvbigpLHQpfWVsZW1UeXBlKGUpe2xldCBuPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNCk7cmV0dXJuIG4/KGV8fG5ldyB0LmV4cGVyaW1lbnRhbC5mYnMuVHlwZUluZm8pLl9faW5pdCh0aGlzLmJiLl9faW5kaXJlY3QodGhpcy5iYl9wb3MrbiksdGhpcy5iYik6bnVsbH1zdGF0aWMgc3RhcnRTZXF1ZW5jZVR5cGUodCl7dC5zdGFydE9iamVjdCgxKX1zdGF0aWMgYWRkRWxlbVR5cGUodCxlKXt0LmFkZEZpZWxkT2Zmc2V0KDAsZSwwKX1zdGF0aWMgZW5kU2VxdWVuY2VUeXBlKHQpe3JldHVybiB0LmVuZE9iamVjdCgpfXN0YXRpYyBjcmVhdGVTZXF1ZW5jZVR5cGUodCxlKXtyZXR1cm4gbi5zdGFydFNlcXVlbmNlVHlwZSh0KSxuLmFkZEVsZW1UeXBlKHQsZSksbi5lbmRTZXF1ZW5jZVR5cGUodCl9fWUuU2VxdWVuY2VUeXBlPW59KGUuZmJzfHwoZS5mYnM9e30pKX0odC5leHBlcmltZW50YWx8fCh0LmV4cGVyaW1lbnRhbD17fSkpfShlLm9ubnhydW50aW1lfHwoZS5vbm54cnVudGltZT17fSkpLGZ1bmN0aW9uKHQpeyFmdW5jdGlvbih0KXsodC5mYnN8fCh0LmZicz17fSkpLkVkZ2VFbmQ9Y2xhc3N7Y29uc3RydWN0b3IoKXt0aGlzLmJiPW51bGwsdGhpcy5iYl9wb3M9MH1fX2luaXQodCxlKXtyZXR1cm4gdGhpcy5iYl9wb3M9dCx0aGlzLmJiPWUsdGhpc31ub2RlSW5kZXgoKXtyZXR1cm4gdGhpcy5iYi5yZWFkVWludDMyKHRoaXMuYmJfcG9zKX1zcmNBcmdJbmRleCgpe3JldHVybiB0aGlzLmJiLnJlYWRJbnQzMih0aGlzLmJiX3Bvcys0KX1kc3RBcmdJbmRleCgpe3JldHVybiB0aGlzLmJiLnJlYWRJbnQzMih0aGlzLmJiX3Bvcys4KX1zdGF0aWMgY3JlYXRlRWRnZUVuZCh0LGUsbixyKXtyZXR1cm4gdC5wcmVwKDQsMTIpLHQud3JpdGVJbnQzMihyKSx0LndyaXRlSW50MzIobiksdC53cml0ZUludDMyKGUpLHQub2Zmc2V0KCl9fX0odC5leHBlcmltZW50YWx8fCh0LmV4cGVyaW1lbnRhbD17fSkpfShlLm9ubnhydW50aW1lfHwoZS5vbm54cnVudGltZT17fSkpLGZ1bmN0aW9uKHQpeyFmdW5jdGlvbihlKXshZnVuY3Rpb24oZSl7Y2xhc3Mgbntjb25zdHJ1Y3Rvcigpe3RoaXMuYmI9bnVsbCx0aGlzLmJiX3Bvcz0wfV9faW5pdCh0LGUpe3JldHVybiB0aGlzLmJiX3Bvcz10LHRoaXMuYmI9ZSx0aGlzfXN0YXRpYyBnZXRSb290QXNOb2RlRWRnZSh0LGUpe3JldHVybihlfHxuZXcgbikuX19pbml0KHQucmVhZEludDMyKHQucG9zaXRpb24oKSkrdC5wb3NpdGlvbigpLHQpfXN0YXRpYyBnZXRTaXplUHJlZml4ZWRSb290QXNOb2RlRWRnZSh0LGUpe3JldHVybiB0LnNldFBvc2l0aW9uKHQucG9zaXRpb24oKStyLmZsYXRidWZmZXJzLlNJWkVfUFJFRklYX0xFTkdUSCksKGV8fG5ldyBuKS5fX2luaXQodC5yZWFkSW50MzIodC5wb3NpdGlvbigpKSt0LnBvc2l0aW9uKCksdCl9bm9kZUluZGV4KCl7bGV0IHQ9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw0KTtyZXR1cm4gdD90aGlzLmJiLnJlYWRVaW50MzIodGhpcy5iYl9wb3MrdCk6MH1pbnB1dEVkZ2VzKGUsbil7bGV0IHI9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw2KTtyZXR1cm4gcj8obnx8bmV3IHQuZXhwZXJpbWVudGFsLmZicy5FZGdlRW5kKS5fX2luaXQodGhpcy5iYi5fX3ZlY3Rvcih0aGlzLmJiX3BvcytyKSsxMiplLHRoaXMuYmIpOm51bGx9aW5wdXRFZGdlc0xlbmd0aCgpe2xldCB0PXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNik7cmV0dXJuIHQ/dGhpcy5iYi5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MrdCk6MH1vdXRwdXRFZGdlcyhlLG4pe2xldCByPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsOCk7cmV0dXJuIHI/KG58fG5ldyB0LmV4cGVyaW1lbnRhbC5mYnMuRWRnZUVuZCkuX19pbml0KHRoaXMuYmIuX192ZWN0b3IodGhpcy5iYl9wb3MrcikrMTIqZSx0aGlzLmJiKTpudWxsfW91dHB1dEVkZ2VzTGVuZ3RoKCl7bGV0IHQ9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw4KTtyZXR1cm4gdD90aGlzLmJiLl9fdmVjdG9yX2xlbih0aGlzLmJiX3Bvcyt0KTowfXN0YXRpYyBzdGFydE5vZGVFZGdlKHQpe3Quc3RhcnRPYmplY3QoMyl9c3RhdGljIGFkZE5vZGVJbmRleCh0LGUpe3QuYWRkRmllbGRJbnQzMigwLGUsMCl9c3RhdGljIGFkZElucHV0RWRnZXModCxlKXt0LmFkZEZpZWxkT2Zmc2V0KDEsZSwwKX1zdGF0aWMgc3RhcnRJbnB1dEVkZ2VzVmVjdG9yKHQsZSl7dC5zdGFydFZlY3RvcigxMixlLDQpfXN0YXRpYyBhZGRPdXRwdXRFZGdlcyh0LGUpe3QuYWRkRmllbGRPZmZzZXQoMixlLDApfXN0YXRpYyBzdGFydE91dHB1dEVkZ2VzVmVjdG9yKHQsZSl7dC5zdGFydFZlY3RvcigxMixlLDQpfXN0YXRpYyBlbmROb2RlRWRnZSh0KXtyZXR1cm4gdC5lbmRPYmplY3QoKX1zdGF0aWMgY3JlYXRlTm9kZUVkZ2UodCxlLHIsaSl7cmV0dXJuIG4uc3RhcnROb2RlRWRnZSh0KSxuLmFkZE5vZGVJbmRleCh0LGUpLG4uYWRkSW5wdXRFZGdlcyh0LHIpLG4uYWRkT3V0cHV0RWRnZXModCxpKSxuLmVuZE5vZGVFZGdlKHQpfX1lLk5vZGVFZGdlPW59KGUuZmJzfHwoZS5mYnM9e30pKX0odC5leHBlcmltZW50YWx8fCh0LmV4cGVyaW1lbnRhbD17fSkpfShlLm9ubnhydW50aW1lfHwoZS5vbm54cnVudGltZT17fSkpLGZ1bmN0aW9uKHQpeyFmdW5jdGlvbihlKXshZnVuY3Rpb24oZSl7Y2xhc3Mgbntjb25zdHJ1Y3Rvcigpe3RoaXMuYmI9bnVsbCx0aGlzLmJiX3Bvcz0wfV9faW5pdCh0LGUpe3JldHVybiB0aGlzLmJiX3Bvcz10LHRoaXMuYmI9ZSx0aGlzfXN0YXRpYyBnZXRSb290QXNOb2RlKHQsZSl7cmV0dXJuKGV8fG5ldyBuKS5fX2luaXQodC5yZWFkSW50MzIodC5wb3NpdGlvbigpKSt0LnBvc2l0aW9uKCksdCl9c3RhdGljIGdldFNpemVQcmVmaXhlZFJvb3RBc05vZGUodCxlKXtyZXR1cm4gdC5zZXRQb3NpdGlvbih0LnBvc2l0aW9uKCkrci5mbGF0YnVmZmVycy5TSVpFX1BSRUZJWF9MRU5HVEgpLChlfHxuZXcgbikuX19pbml0KHQucmVhZEludDMyKHQucG9zaXRpb24oKSkrdC5wb3NpdGlvbigpLHQpfW5hbWUodCl7bGV0IGU9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw0KTtyZXR1cm4gZT90aGlzLmJiLl9fc3RyaW5nKHRoaXMuYmJfcG9zK2UsdCk6bnVsbH1kb2NTdHJpbmcodCl7bGV0IGU9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw2KTtyZXR1cm4gZT90aGlzLmJiLl9fc3RyaW5nKHRoaXMuYmJfcG9zK2UsdCk6bnVsbH1kb21haW4odCl7bGV0IGU9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw4KTtyZXR1cm4gZT90aGlzLmJiLl9fc3RyaW5nKHRoaXMuYmJfcG9zK2UsdCk6bnVsbH1zaW5jZVZlcnNpb24oKXtsZXQgdD10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDEwKTtyZXR1cm4gdD90aGlzLmJiLnJlYWRJbnQzMih0aGlzLmJiX3Bvcyt0KTowfWluZGV4KCl7bGV0IHQ9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3BvcywxMik7cmV0dXJuIHQ/dGhpcy5iYi5yZWFkVWludDMyKHRoaXMuYmJfcG9zK3QpOjB9b3BUeXBlKHQpe2xldCBlPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsMTQpO3JldHVybiBlP3RoaXMuYmIuX19zdHJpbmcodGhpcy5iYl9wb3MrZSx0KTpudWxsfXR5cGUoKXtsZXQgZT10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDE2KTtyZXR1cm4gZT90aGlzLmJiLnJlYWRJbnQzMih0aGlzLmJiX3BvcytlKTp0LmV4cGVyaW1lbnRhbC5mYnMuTm9kZVR5cGUuUHJpbWl0aXZlfWV4ZWN1dGlvblByb3ZpZGVyVHlwZSh0KXtsZXQgZT10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDE4KTtyZXR1cm4gZT90aGlzLmJiLl9fc3RyaW5nKHRoaXMuYmJfcG9zK2UsdCk6bnVsbH1pbnB1dHModCxlKXtsZXQgbj10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDIwKTtyZXR1cm4gbj90aGlzLmJiLl9fc3RyaW5nKHRoaXMuYmIuX192ZWN0b3IodGhpcy5iYl9wb3MrbikrNCp0LGUpOm51bGx9aW5wdXRzTGVuZ3RoKCl7bGV0IHQ9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3BvcywyMCk7cmV0dXJuIHQ/dGhpcy5iYi5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MrdCk6MH1vdXRwdXRzKHQsZSl7bGV0IG49dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3BvcywyMik7cmV0dXJuIG4/dGhpcy5iYi5fX3N0cmluZyh0aGlzLmJiLl9fdmVjdG9yKHRoaXMuYmJfcG9zK24pKzQqdCxlKTpudWxsfW91dHB1dHNMZW5ndGgoKXtsZXQgdD10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDIyKTtyZXR1cm4gdD90aGlzLmJiLl9fdmVjdG9yX2xlbih0aGlzLmJiX3Bvcyt0KTowfWF0dHJpYnV0ZXMoZSxuKXtsZXQgcj10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDI0KTtyZXR1cm4gcj8obnx8bmV3IHQuZXhwZXJpbWVudGFsLmZicy5BdHRyaWJ1dGUpLl9faW5pdCh0aGlzLmJiLl9faW5kaXJlY3QodGhpcy5iYi5fX3ZlY3Rvcih0aGlzLmJiX3BvcytyKSs0KmUpLHRoaXMuYmIpOm51bGx9YXR0cmlidXRlc0xlbmd0aCgpe2xldCB0PXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsMjQpO3JldHVybiB0P3RoaXMuYmIuX192ZWN0b3JfbGVuKHRoaXMuYmJfcG9zK3QpOjB9aW5wdXRBcmdDb3VudHModCl7bGV0IGU9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3BvcywyNik7cmV0dXJuIGU/dGhpcy5iYi5yZWFkSW50MzIodGhpcy5iYi5fX3ZlY3Rvcih0aGlzLmJiX3BvcytlKSs0KnQpOjB9aW5wdXRBcmdDb3VudHNMZW5ndGgoKXtsZXQgdD10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDI2KTtyZXR1cm4gdD90aGlzLmJiLl9fdmVjdG9yX2xlbih0aGlzLmJiX3Bvcyt0KTowfWlucHV0QXJnQ291bnRzQXJyYXkoKXtsZXQgdD10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDI2KTtyZXR1cm4gdD9uZXcgSW50MzJBcnJheSh0aGlzLmJiLmJ5dGVzKCkuYnVmZmVyLHRoaXMuYmIuYnl0ZXMoKS5ieXRlT2Zmc2V0K3RoaXMuYmIuX192ZWN0b3IodGhpcy5iYl9wb3MrdCksdGhpcy5iYi5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MrdCkpOm51bGx9aW1wbGljaXRJbnB1dHModCxlKXtsZXQgbj10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDI4KTtyZXR1cm4gbj90aGlzLmJiLl9fc3RyaW5nKHRoaXMuYmIuX192ZWN0b3IodGhpcy5iYl9wb3MrbikrNCp0LGUpOm51bGx9aW1wbGljaXRJbnB1dHNMZW5ndGgoKXtsZXQgdD10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDI4KTtyZXR1cm4gdD90aGlzLmJiLl9fdmVjdG9yX2xlbih0aGlzLmJiX3Bvcyt0KTowfXN0YXRpYyBzdGFydE5vZGUodCl7dC5zdGFydE9iamVjdCgxMyl9c3RhdGljIGFkZE5hbWUodCxlKXt0LmFkZEZpZWxkT2Zmc2V0KDAsZSwwKX1zdGF0aWMgYWRkRG9jU3RyaW5nKHQsZSl7dC5hZGRGaWVsZE9mZnNldCgxLGUsMCl9c3RhdGljIGFkZERvbWFpbih0LGUpe3QuYWRkRmllbGRPZmZzZXQoMixlLDApfXN0YXRpYyBhZGRTaW5jZVZlcnNpb24odCxlKXt0LmFkZEZpZWxkSW50MzIoMyxlLDApfXN0YXRpYyBhZGRJbmRleCh0LGUpe3QuYWRkRmllbGRJbnQzMig0LGUsMCl9c3RhdGljIGFkZE9wVHlwZSh0LGUpe3QuYWRkRmllbGRPZmZzZXQoNSxlLDApfXN0YXRpYyBhZGRUeXBlKGUsbil7ZS5hZGRGaWVsZEludDMyKDYsbix0LmV4cGVyaW1lbnRhbC5mYnMuTm9kZVR5cGUuUHJpbWl0aXZlKX1zdGF0aWMgYWRkRXhlY3V0aW9uUHJvdmlkZXJUeXBlKHQsZSl7dC5hZGRGaWVsZE9mZnNldCg3LGUsMCl9c3RhdGljIGFkZElucHV0cyh0LGUpe3QuYWRkRmllbGRPZmZzZXQoOCxlLDApfXN0YXRpYyBjcmVhdGVJbnB1dHNWZWN0b3IodCxlKXt0LnN0YXJ0VmVjdG9yKDQsZS5sZW5ndGgsNCk7Zm9yKGxldCBuPWUubGVuZ3RoLTE7bj49MDtuLS0pdC5hZGRPZmZzZXQoZVtuXSk7cmV0dXJuIHQuZW5kVmVjdG9yKCl9c3RhdGljIHN0YXJ0SW5wdXRzVmVjdG9yKHQsZSl7dC5zdGFydFZlY3Rvcig0LGUsNCl9c3RhdGljIGFkZE91dHB1dHModCxlKXt0LmFkZEZpZWxkT2Zmc2V0KDksZSwwKX1zdGF0aWMgY3JlYXRlT3V0cHV0c1ZlY3Rvcih0LGUpe3Quc3RhcnRWZWN0b3IoNCxlLmxlbmd0aCw0KTtmb3IobGV0IG49ZS5sZW5ndGgtMTtuPj0wO24tLSl0LmFkZE9mZnNldChlW25dKTtyZXR1cm4gdC5lbmRWZWN0b3IoKX1zdGF0aWMgc3RhcnRPdXRwdXRzVmVjdG9yKHQsZSl7dC5zdGFydFZlY3Rvcig0LGUsNCl9c3RhdGljIGFkZEF0dHJpYnV0ZXModCxlKXt0LmFkZEZpZWxkT2Zmc2V0KDEwLGUsMCl9c3RhdGljIGNyZWF0ZUF0dHJpYnV0ZXNWZWN0b3IodCxlKXt0LnN0YXJ0VmVjdG9yKDQsZS5sZW5ndGgsNCk7Zm9yKGxldCBuPWUubGVuZ3RoLTE7bj49MDtuLS0pdC5hZGRPZmZzZXQoZVtuXSk7cmV0dXJuIHQuZW5kVmVjdG9yKCl9c3RhdGljIHN0YXJ0QXR0cmlidXRlc1ZlY3Rvcih0LGUpe3Quc3RhcnRWZWN0b3IoNCxlLDQpfXN0YXRpYyBhZGRJbnB1dEFyZ0NvdW50cyh0LGUpe3QuYWRkRmllbGRPZmZzZXQoMTEsZSwwKX1zdGF0aWMgY3JlYXRlSW5wdXRBcmdDb3VudHNWZWN0b3IodCxlKXt0LnN0YXJ0VmVjdG9yKDQsZS5sZW5ndGgsNCk7Zm9yKGxldCBuPWUubGVuZ3RoLTE7bj49MDtuLS0pdC5hZGRJbnQzMihlW25dKTtyZXR1cm4gdC5lbmRWZWN0b3IoKX1zdGF0aWMgc3RhcnRJbnB1dEFyZ0NvdW50c1ZlY3Rvcih0LGUpe3Quc3RhcnRWZWN0b3IoNCxlLDQpfXN0YXRpYyBhZGRJbXBsaWNpdElucHV0cyh0LGUpe3QuYWRkRmllbGRPZmZzZXQoMTIsZSwwKX1zdGF0aWMgY3JlYXRlSW1wbGljaXRJbnB1dHNWZWN0b3IodCxlKXt0LnN0YXJ0VmVjdG9yKDQsZS5sZW5ndGgsNCk7Zm9yKGxldCBuPWUubGVuZ3RoLTE7bj49MDtuLS0pdC5hZGRPZmZzZXQoZVtuXSk7cmV0dXJuIHQuZW5kVmVjdG9yKCl9c3RhdGljIHN0YXJ0SW1wbGljaXRJbnB1dHNWZWN0b3IodCxlKXt0LnN0YXJ0VmVjdG9yKDQsZSw0KX1zdGF0aWMgZW5kTm9kZSh0KXtyZXR1cm4gdC5lbmRPYmplY3QoKX1zdGF0aWMgY3JlYXRlTm9kZSh0LGUscixpLG8sYSxzLHUsYyxsLHAsZixkLGgpe3JldHVybiBuLnN0YXJ0Tm9kZSh0KSxuLmFkZE5hbWUodCxlKSxuLmFkZERvY1N0cmluZyh0LHIpLG4uYWRkRG9tYWluKHQsaSksbi5hZGRTaW5jZVZlcnNpb24odCxvKSxuLmFkZEluZGV4KHQsYSksbi5hZGRPcFR5cGUodCxzKSxuLmFkZFR5cGUodCx1KSxuLmFkZEV4ZWN1dGlvblByb3ZpZGVyVHlwZSh0LGMpLG4uYWRkSW5wdXRzKHQsbCksbi5hZGRPdXRwdXRzKHQscCksbi5hZGRBdHRyaWJ1dGVzKHQsZiksbi5hZGRJbnB1dEFyZ0NvdW50cyh0LGQpLG4uYWRkSW1wbGljaXRJbnB1dHModCxoKSxuLmVuZE5vZGUodCl9fWUuTm9kZT1ufShlLmZic3x8KGUuZmJzPXt9KSl9KHQuZXhwZXJpbWVudGFsfHwodC5leHBlcmltZW50YWw9e30pKX0oZS5vbm54cnVudGltZXx8KGUub25ueHJ1bnRpbWU9e30pKSxmdW5jdGlvbih0KXshZnVuY3Rpb24oZSl7IWZ1bmN0aW9uKGUpe2NsYXNzIG57Y29uc3RydWN0b3IoKXt0aGlzLmJiPW51bGwsdGhpcy5iYl9wb3M9MH1fX2luaXQodCxlKXtyZXR1cm4gdGhpcy5iYl9wb3M9dCx0aGlzLmJiPWUsdGhpc31zdGF0aWMgZ2V0Um9vdEFzVmFsdWVJbmZvKHQsZSl7cmV0dXJuKGV8fG5ldyBuKS5fX2luaXQodC5yZWFkSW50MzIodC5wb3NpdGlvbigpKSt0LnBvc2l0aW9uKCksdCl9c3RhdGljIGdldFNpemVQcmVmaXhlZFJvb3RBc1ZhbHVlSW5mbyh0LGUpe3JldHVybiB0LnNldFBvc2l0aW9uKHQucG9zaXRpb24oKStyLmZsYXRidWZmZXJzLlNJWkVfUFJFRklYX0xFTkdUSCksKGV8fG5ldyBuKS5fX2luaXQodC5yZWFkSW50MzIodC5wb3NpdGlvbigpKSt0LnBvc2l0aW9uKCksdCl9bmFtZSh0KXtsZXQgZT10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDQpO3JldHVybiBlP3RoaXMuYmIuX19zdHJpbmcodGhpcy5iYl9wb3MrZSx0KTpudWxsfWRvY1N0cmluZyh0KXtsZXQgZT10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDYpO3JldHVybiBlP3RoaXMuYmIuX19zdHJpbmcodGhpcy5iYl9wb3MrZSx0KTpudWxsfXR5cGUoZSl7bGV0IG49dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw4KTtyZXR1cm4gbj8oZXx8bmV3IHQuZXhwZXJpbWVudGFsLmZicy5UeXBlSW5mbykuX19pbml0KHRoaXMuYmIuX19pbmRpcmVjdCh0aGlzLmJiX3BvcytuKSx0aGlzLmJiKTpudWxsfXN0YXRpYyBzdGFydFZhbHVlSW5mbyh0KXt0LnN0YXJ0T2JqZWN0KDMpfXN0YXRpYyBhZGROYW1lKHQsZSl7dC5hZGRGaWVsZE9mZnNldCgwLGUsMCl9c3RhdGljIGFkZERvY1N0cmluZyh0LGUpe3QuYWRkRmllbGRPZmZzZXQoMSxlLDApfXN0YXRpYyBhZGRUeXBlKHQsZSl7dC5hZGRGaWVsZE9mZnNldCgyLGUsMCl9c3RhdGljIGVuZFZhbHVlSW5mbyh0KXtyZXR1cm4gdC5lbmRPYmplY3QoKX1zdGF0aWMgY3JlYXRlVmFsdWVJbmZvKHQsZSxyLGkpe3JldHVybiBuLnN0YXJ0VmFsdWVJbmZvKHQpLG4uYWRkTmFtZSh0LGUpLG4uYWRkRG9jU3RyaW5nKHQsciksbi5hZGRUeXBlKHQsaSksbi5lbmRWYWx1ZUluZm8odCl9fWUuVmFsdWVJbmZvPW59KGUuZmJzfHwoZS5mYnM9e30pKX0odC5leHBlcmltZW50YWx8fCh0LmV4cGVyaW1lbnRhbD17fSkpfShlLm9ubnhydW50aW1lfHwoZS5vbm54cnVudGltZT17fSkpLGZ1bmN0aW9uKHQpeyFmdW5jdGlvbihlKXshZnVuY3Rpb24oZSl7Y2xhc3Mgbntjb25zdHJ1Y3Rvcigpe3RoaXMuYmI9bnVsbCx0aGlzLmJiX3Bvcz0wfV9faW5pdCh0LGUpe3JldHVybiB0aGlzLmJiX3Bvcz10LHRoaXMuYmI9ZSx0aGlzfXN0YXRpYyBnZXRSb290QXNUeXBlSW5mbyh0LGUpe3JldHVybihlfHxuZXcgbikuX19pbml0KHQucmVhZEludDMyKHQucG9zaXRpb24oKSkrdC5wb3NpdGlvbigpLHQpfXN0YXRpYyBnZXRTaXplUHJlZml4ZWRSb290QXNUeXBlSW5mbyh0LGUpe3JldHVybiB0LnNldFBvc2l0aW9uKHQucG9zaXRpb24oKStyLmZsYXRidWZmZXJzLlNJWkVfUFJFRklYX0xFTkdUSCksKGV8fG5ldyBuKS5fX2luaXQodC5yZWFkSW50MzIodC5wb3NpdGlvbigpKSt0LnBvc2l0aW9uKCksdCl9ZGVub3RhdGlvbih0KXtsZXQgZT10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDQpO3JldHVybiBlP3RoaXMuYmIuX19zdHJpbmcodGhpcy5iYl9wb3MrZSx0KTpudWxsfXZhbHVlVHlwZSgpe2xldCBlPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNik7cmV0dXJuIGU/dGhpcy5iYi5yZWFkVWludDgodGhpcy5iYl9wb3MrZSk6dC5leHBlcmltZW50YWwuZmJzLlR5cGVJbmZvVmFsdWUuTk9ORX12YWx1ZSh0KXtsZXQgZT10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDgpO3JldHVybiBlP3RoaXMuYmIuX191bmlvbih0LHRoaXMuYmJfcG9zK2UpOm51bGx9c3RhdGljIHN0YXJ0VHlwZUluZm8odCl7dC5zdGFydE9iamVjdCgzKX1zdGF0aWMgYWRkRGVub3RhdGlvbih0LGUpe3QuYWRkRmllbGRPZmZzZXQoMCxlLDApfXN0YXRpYyBhZGRWYWx1ZVR5cGUoZSxuKXtlLmFkZEZpZWxkSW50OCgxLG4sdC5leHBlcmltZW50YWwuZmJzLlR5cGVJbmZvVmFsdWUuTk9ORSl9c3RhdGljIGFkZFZhbHVlKHQsZSl7dC5hZGRGaWVsZE9mZnNldCgyLGUsMCl9c3RhdGljIGVuZFR5cGVJbmZvKHQpe3JldHVybiB0LmVuZE9iamVjdCgpfXN0YXRpYyBjcmVhdGVUeXBlSW5mbyh0LGUscixpKXtyZXR1cm4gbi5zdGFydFR5cGVJbmZvKHQpLG4uYWRkRGVub3RhdGlvbih0LGUpLG4uYWRkVmFsdWVUeXBlKHQsciksbi5hZGRWYWx1ZSh0LGkpLG4uZW5kVHlwZUluZm8odCl9fWUuVHlwZUluZm89bn0oZS5mYnN8fChlLmZicz17fSkpfSh0LmV4cGVyaW1lbnRhbHx8KHQuZXhwZXJpbWVudGFsPXt9KSl9KGUub25ueHJ1bnRpbWV8fChlLm9ubnhydW50aW1lPXt9KSksZnVuY3Rpb24odCl7IWZ1bmN0aW9uKHQpeyFmdW5jdGlvbih0KXtjbGFzcyBle2NvbnN0cnVjdG9yKCl7dGhpcy5iYj1udWxsLHRoaXMuYmJfcG9zPTB9X19pbml0KHQsZSl7cmV0dXJuIHRoaXMuYmJfcG9zPXQsdGhpcy5iYj1lLHRoaXN9c3RhdGljIGdldFJvb3RBc09wZXJhdG9yU2V0SWQodCxuKXtyZXR1cm4obnx8bmV3IGUpLl9faW5pdCh0LnJlYWRJbnQzMih0LnBvc2l0aW9uKCkpK3QucG9zaXRpb24oKSx0KX1zdGF0aWMgZ2V0U2l6ZVByZWZpeGVkUm9vdEFzT3BlcmF0b3JTZXRJZCh0LG4pe3JldHVybiB0LnNldFBvc2l0aW9uKHQucG9zaXRpb24oKStyLmZsYXRidWZmZXJzLlNJWkVfUFJFRklYX0xFTkdUSCksKG58fG5ldyBlKS5fX2luaXQodC5yZWFkSW50MzIodC5wb3NpdGlvbigpKSt0LnBvc2l0aW9uKCksdCl9ZG9tYWluKHQpe2xldCBlPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNCk7cmV0dXJuIGU/dGhpcy5iYi5fX3N0cmluZyh0aGlzLmJiX3BvcytlLHQpOm51bGx9dmVyc2lvbigpe2xldCB0PXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNik7cmV0dXJuIHQ/dGhpcy5iYi5yZWFkSW50NjQodGhpcy5iYl9wb3MrdCk6dGhpcy5iYi5jcmVhdGVMb25nKDAsMCl9c3RhdGljIHN0YXJ0T3BlcmF0b3JTZXRJZCh0KXt0LnN0YXJ0T2JqZWN0KDIpfXN0YXRpYyBhZGREb21haW4odCxlKXt0LmFkZEZpZWxkT2Zmc2V0KDAsZSwwKX1zdGF0aWMgYWRkVmVyc2lvbih0LGUpe3QuYWRkRmllbGRJbnQ2NCgxLGUsdC5jcmVhdGVMb25nKDAsMCkpfXN0YXRpYyBlbmRPcGVyYXRvclNldElkKHQpe3JldHVybiB0LmVuZE9iamVjdCgpfXN0YXRpYyBjcmVhdGVPcGVyYXRvclNldElkKHQsbixyKXtyZXR1cm4gZS5zdGFydE9wZXJhdG9yU2V0SWQodCksZS5hZGREb21haW4odCxuKSxlLmFkZFZlcnNpb24odCxyKSxlLmVuZE9wZXJhdG9yU2V0SWQodCl9fXQuT3BlcmF0b3JTZXRJZD1lfSh0LmZic3x8KHQuZmJzPXt9KSl9KHQuZXhwZXJpbWVudGFsfHwodC5leHBlcmltZW50YWw9e30pKX0oZS5vbm54cnVudGltZXx8KGUub25ueHJ1bnRpbWU9e30pKSxmdW5jdGlvbih0KXshZnVuY3Rpb24oZSl7IWZ1bmN0aW9uKGUpe2NsYXNzIG57Y29uc3RydWN0b3IoKXt0aGlzLmJiPW51bGwsdGhpcy5iYl9wb3M9MH1fX2luaXQodCxlKXtyZXR1cm4gdGhpcy5iYl9wb3M9dCx0aGlzLmJiPWUsdGhpc31zdGF0aWMgZ2V0Um9vdEFzVGVuc29yKHQsZSl7cmV0dXJuKGV8fG5ldyBuKS5fX2luaXQodC5yZWFkSW50MzIodC5wb3NpdGlvbigpKSt0LnBvc2l0aW9uKCksdCl9c3RhdGljIGdldFNpemVQcmVmaXhlZFJvb3RBc1RlbnNvcih0LGUpe3JldHVybiB0LnNldFBvc2l0aW9uKHQucG9zaXRpb24oKStyLmZsYXRidWZmZXJzLlNJWkVfUFJFRklYX0xFTkdUSCksKGV8fG5ldyBuKS5fX2luaXQodC5yZWFkSW50MzIodC5wb3NpdGlvbigpKSt0LnBvc2l0aW9uKCksdCl9bmFtZSh0KXtsZXQgZT10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDQpO3JldHVybiBlP3RoaXMuYmIuX19zdHJpbmcodGhpcy5iYl9wb3MrZSx0KTpudWxsfWRvY1N0cmluZyh0KXtsZXQgZT10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDYpO3JldHVybiBlP3RoaXMuYmIuX19zdHJpbmcodGhpcy5iYl9wb3MrZSx0KTpudWxsfWRpbXModCl7bGV0IGU9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw4KTtyZXR1cm4gZT90aGlzLmJiLnJlYWRJbnQ2NCh0aGlzLmJiLl9fdmVjdG9yKHRoaXMuYmJfcG9zK2UpKzgqdCk6dGhpcy5iYi5jcmVhdGVMb25nKDAsMCl9ZGltc0xlbmd0aCgpe2xldCB0PXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsOCk7cmV0dXJuIHQ/dGhpcy5iYi5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MrdCk6MH1kYXRhVHlwZSgpe2xldCBlPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsMTApO3JldHVybiBlP3RoaXMuYmIucmVhZEludDMyKHRoaXMuYmJfcG9zK2UpOnQuZXhwZXJpbWVudGFsLmZicy5UZW5zb3JEYXRhVHlwZS5VTkRFRklORUR9cmF3RGF0YSh0KXtsZXQgZT10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDEyKTtyZXR1cm4gZT90aGlzLmJiLnJlYWRVaW50OCh0aGlzLmJiLl9fdmVjdG9yKHRoaXMuYmJfcG9zK2UpK3QpOjB9cmF3RGF0YUxlbmd0aCgpe2xldCB0PXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsMTIpO3JldHVybiB0P3RoaXMuYmIuX192ZWN0b3JfbGVuKHRoaXMuYmJfcG9zK3QpOjB9cmF3RGF0YUFycmF5KCl7bGV0IHQ9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3BvcywxMik7cmV0dXJuIHQ/bmV3IFVpbnQ4QXJyYXkodGhpcy5iYi5ieXRlcygpLmJ1ZmZlcix0aGlzLmJiLmJ5dGVzKCkuYnl0ZU9mZnNldCt0aGlzLmJiLl9fdmVjdG9yKHRoaXMuYmJfcG9zK3QpLHRoaXMuYmIuX192ZWN0b3JfbGVuKHRoaXMuYmJfcG9zK3QpKTpudWxsfXN0cmluZ0RhdGEodCxlKXtsZXQgbj10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDE0KTtyZXR1cm4gbj90aGlzLmJiLl9fc3RyaW5nKHRoaXMuYmIuX192ZWN0b3IodGhpcy5iYl9wb3MrbikrNCp0LGUpOm51bGx9c3RyaW5nRGF0YUxlbmd0aCgpe2xldCB0PXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsMTQpO3JldHVybiB0P3RoaXMuYmIuX192ZWN0b3JfbGVuKHRoaXMuYmJfcG9zK3QpOjB9c3RhdGljIHN0YXJ0VGVuc29yKHQpe3Quc3RhcnRPYmplY3QoNil9c3RhdGljIGFkZE5hbWUodCxlKXt0LmFkZEZpZWxkT2Zmc2V0KDAsZSwwKX1zdGF0aWMgYWRkRG9jU3RyaW5nKHQsZSl7dC5hZGRGaWVsZE9mZnNldCgxLGUsMCl9c3RhdGljIGFkZERpbXModCxlKXt0LmFkZEZpZWxkT2Zmc2V0KDIsZSwwKX1zdGF0aWMgY3JlYXRlRGltc1ZlY3Rvcih0LGUpe3Quc3RhcnRWZWN0b3IoOCxlLmxlbmd0aCw4KTtmb3IobGV0IG49ZS5sZW5ndGgtMTtuPj0wO24tLSl0LmFkZEludDY0KGVbbl0pO3JldHVybiB0LmVuZFZlY3RvcigpfXN0YXRpYyBzdGFydERpbXNWZWN0b3IodCxlKXt0LnN0YXJ0VmVjdG9yKDgsZSw4KX1zdGF0aWMgYWRkRGF0YVR5cGUoZSxuKXtlLmFkZEZpZWxkSW50MzIoMyxuLHQuZXhwZXJpbWVudGFsLmZicy5UZW5zb3JEYXRhVHlwZS5VTkRFRklORUQpfXN0YXRpYyBhZGRSYXdEYXRhKHQsZSl7dC5hZGRGaWVsZE9mZnNldCg0LGUsMCl9c3RhdGljIGNyZWF0ZVJhd0RhdGFWZWN0b3IodCxlKXt0LnN0YXJ0VmVjdG9yKDEsZS5sZW5ndGgsMSk7Zm9yKGxldCBuPWUubGVuZ3RoLTE7bj49MDtuLS0pdC5hZGRJbnQ4KGVbbl0pO3JldHVybiB0LmVuZFZlY3RvcigpfXN0YXRpYyBzdGFydFJhd0RhdGFWZWN0b3IodCxlKXt0LnN0YXJ0VmVjdG9yKDEsZSwxKX1zdGF0aWMgYWRkU3RyaW5nRGF0YSh0LGUpe3QuYWRkRmllbGRPZmZzZXQoNSxlLDApfXN0YXRpYyBjcmVhdGVTdHJpbmdEYXRhVmVjdG9yKHQsZSl7dC5zdGFydFZlY3Rvcig0LGUubGVuZ3RoLDQpO2ZvcihsZXQgbj1lLmxlbmd0aC0xO24+PTA7bi0tKXQuYWRkT2Zmc2V0KGVbbl0pO3JldHVybiB0LmVuZFZlY3RvcigpfXN0YXRpYyBzdGFydFN0cmluZ0RhdGFWZWN0b3IodCxlKXt0LnN0YXJ0VmVjdG9yKDQsZSw0KX1zdGF0aWMgZW5kVGVuc29yKHQpe3JldHVybiB0LmVuZE9iamVjdCgpfXN0YXRpYyBjcmVhdGVUZW5zb3IodCxlLHIsaSxvLGEscyl7cmV0dXJuIG4uc3RhcnRUZW5zb3IodCksbi5hZGROYW1lKHQsZSksbi5hZGREb2NTdHJpbmcodCxyKSxuLmFkZERpbXModCxpKSxuLmFkZERhdGFUeXBlKHQsbyksbi5hZGRSYXdEYXRhKHQsYSksbi5hZGRTdHJpbmdEYXRhKHQscyksbi5lbmRUZW5zb3IodCl9fWUuVGVuc29yPW59KGUuZmJzfHwoZS5mYnM9e30pKX0odC5leHBlcmltZW50YWx8fCh0LmV4cGVyaW1lbnRhbD17fSkpfShlLm9ubnhydW50aW1lfHwoZS5vbm54cnVudGltZT17fSkpLGZ1bmN0aW9uKHQpeyFmdW5jdGlvbihlKXshZnVuY3Rpb24oZSl7Y2xhc3Mgbntjb25zdHJ1Y3Rvcigpe3RoaXMuYmI9bnVsbCx0aGlzLmJiX3Bvcz0wfV9faW5pdCh0LGUpe3JldHVybiB0aGlzLmJiX3Bvcz10LHRoaXMuYmI9ZSx0aGlzfXN0YXRpYyBnZXRSb290QXNTcGFyc2VUZW5zb3IodCxlKXtyZXR1cm4oZXx8bmV3IG4pLl9faW5pdCh0LnJlYWRJbnQzMih0LnBvc2l0aW9uKCkpK3QucG9zaXRpb24oKSx0KX1zdGF0aWMgZ2V0U2l6ZVByZWZpeGVkUm9vdEFzU3BhcnNlVGVuc29yKHQsZSl7cmV0dXJuIHQuc2V0UG9zaXRpb24odC5wb3NpdGlvbigpK3IuZmxhdGJ1ZmZlcnMuU0laRV9QUkVGSVhfTEVOR1RIKSwoZXx8bmV3IG4pLl9faW5pdCh0LnJlYWRJbnQzMih0LnBvc2l0aW9uKCkpK3QucG9zaXRpb24oKSx0KX12YWx1ZXMoZSl7bGV0IG49dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw0KTtyZXR1cm4gbj8oZXx8bmV3IHQuZXhwZXJpbWVudGFsLmZicy5UZW5zb3IpLl9faW5pdCh0aGlzLmJiLl9faW5kaXJlY3QodGhpcy5iYl9wb3MrbiksdGhpcy5iYik6bnVsbH1pbmRpY2VzKGUpe2xldCBuPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNik7cmV0dXJuIG4/KGV8fG5ldyB0LmV4cGVyaW1lbnRhbC5mYnMuVGVuc29yKS5fX2luaXQodGhpcy5iYi5fX2luZGlyZWN0KHRoaXMuYmJfcG9zK24pLHRoaXMuYmIpOm51bGx9ZGltcyh0KXtsZXQgZT10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDgpO3JldHVybiBlP3RoaXMuYmIucmVhZEludDY0KHRoaXMuYmIuX192ZWN0b3IodGhpcy5iYl9wb3MrZSkrOCp0KTp0aGlzLmJiLmNyZWF0ZUxvbmcoMCwwKX1kaW1zTGVuZ3RoKCl7bGV0IHQ9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw4KTtyZXR1cm4gdD90aGlzLmJiLl9fdmVjdG9yX2xlbih0aGlzLmJiX3Bvcyt0KTowfXN0YXRpYyBzdGFydFNwYXJzZVRlbnNvcih0KXt0LnN0YXJ0T2JqZWN0KDMpfXN0YXRpYyBhZGRWYWx1ZXModCxlKXt0LmFkZEZpZWxkT2Zmc2V0KDAsZSwwKX1zdGF0aWMgYWRkSW5kaWNlcyh0LGUpe3QuYWRkRmllbGRPZmZzZXQoMSxlLDApfXN0YXRpYyBhZGREaW1zKHQsZSl7dC5hZGRGaWVsZE9mZnNldCgyLGUsMCl9c3RhdGljIGNyZWF0ZURpbXNWZWN0b3IodCxlKXt0LnN0YXJ0VmVjdG9yKDgsZS5sZW5ndGgsOCk7Zm9yKGxldCBuPWUubGVuZ3RoLTE7bj49MDtuLS0pdC5hZGRJbnQ2NChlW25dKTtyZXR1cm4gdC5lbmRWZWN0b3IoKX1zdGF0aWMgc3RhcnREaW1zVmVjdG9yKHQsZSl7dC5zdGFydFZlY3Rvcig4LGUsOCl9c3RhdGljIGVuZFNwYXJzZVRlbnNvcih0KXtyZXR1cm4gdC5lbmRPYmplY3QoKX1zdGF0aWMgY3JlYXRlU3BhcnNlVGVuc29yKHQsZSxyLGkpe3JldHVybiBuLnN0YXJ0U3BhcnNlVGVuc29yKHQpLG4uYWRkVmFsdWVzKHQsZSksbi5hZGRJbmRpY2VzKHQsciksbi5hZGREaW1zKHQsaSksbi5lbmRTcGFyc2VUZW5zb3IodCl9fWUuU3BhcnNlVGVuc29yPW59KGUuZmJzfHwoZS5mYnM9e30pKX0odC5leHBlcmltZW50YWx8fCh0LmV4cGVyaW1lbnRhbD17fSkpfShlLm9ubnhydW50aW1lfHwoZS5vbm54cnVudGltZT17fSkpLGZ1bmN0aW9uKHQpeyFmdW5jdGlvbihlKXshZnVuY3Rpb24oZSl7Y2xhc3Mgbntjb25zdHJ1Y3Rvcigpe3RoaXMuYmI9bnVsbCx0aGlzLmJiX3Bvcz0wfV9faW5pdCh0LGUpe3JldHVybiB0aGlzLmJiX3Bvcz10LHRoaXMuYmI9ZSx0aGlzfXN0YXRpYyBnZXRSb290QXNBdHRyaWJ1dGUodCxlKXtyZXR1cm4oZXx8bmV3IG4pLl9faW5pdCh0LnJlYWRJbnQzMih0LnBvc2l0aW9uKCkpK3QucG9zaXRpb24oKSx0KX1zdGF0aWMgZ2V0U2l6ZVByZWZpeGVkUm9vdEFzQXR0cmlidXRlKHQsZSl7cmV0dXJuIHQuc2V0UG9zaXRpb24odC5wb3NpdGlvbigpK3IuZmxhdGJ1ZmZlcnMuU0laRV9QUkVGSVhfTEVOR1RIKSwoZXx8bmV3IG4pLl9faW5pdCh0LnJlYWRJbnQzMih0LnBvc2l0aW9uKCkpK3QucG9zaXRpb24oKSx0KX1uYW1lKHQpe2xldCBlPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNCk7cmV0dXJuIGU/dGhpcy5iYi5fX3N0cmluZyh0aGlzLmJiX3BvcytlLHQpOm51bGx9ZG9jU3RyaW5nKHQpe2xldCBlPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNik7cmV0dXJuIGU/dGhpcy5iYi5fX3N0cmluZyh0aGlzLmJiX3BvcytlLHQpOm51bGx9dHlwZSgpe2xldCBlPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsOCk7cmV0dXJuIGU/dGhpcy5iYi5yZWFkSW50MzIodGhpcy5iYl9wb3MrZSk6dC5leHBlcmltZW50YWwuZmJzLkF0dHJpYnV0ZVR5cGUuVU5ERUZJTkVEfWYoKXtsZXQgdD10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDEwKTtyZXR1cm4gdD90aGlzLmJiLnJlYWRGbG9hdDMyKHRoaXMuYmJfcG9zK3QpOjB9aSgpe2xldCB0PXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsMTIpO3JldHVybiB0P3RoaXMuYmIucmVhZEludDY0KHRoaXMuYmJfcG9zK3QpOnRoaXMuYmIuY3JlYXRlTG9uZygwLDApfXModCl7bGV0IGU9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3BvcywxNCk7cmV0dXJuIGU/dGhpcy5iYi5fX3N0cmluZyh0aGlzLmJiX3BvcytlLHQpOm51bGx9dChlKXtsZXQgbj10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDE2KTtyZXR1cm4gbj8oZXx8bmV3IHQuZXhwZXJpbWVudGFsLmZicy5UZW5zb3IpLl9faW5pdCh0aGlzLmJiLl9faW5kaXJlY3QodGhpcy5iYl9wb3MrbiksdGhpcy5iYik6bnVsbH1nKGUpe2xldCBuPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsMTgpO3JldHVybiBuPyhlfHxuZXcgdC5leHBlcmltZW50YWwuZmJzLkdyYXBoKS5fX2luaXQodGhpcy5iYi5fX2luZGlyZWN0KHRoaXMuYmJfcG9zK24pLHRoaXMuYmIpOm51bGx9ZmxvYXRzKHQpe2xldCBlPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsMjApO3JldHVybiBlP3RoaXMuYmIucmVhZEZsb2F0MzIodGhpcy5iYi5fX3ZlY3Rvcih0aGlzLmJiX3BvcytlKSs0KnQpOjB9ZmxvYXRzTGVuZ3RoKCl7bGV0IHQ9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3BvcywyMCk7cmV0dXJuIHQ/dGhpcy5iYi5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MrdCk6MH1mbG9hdHNBcnJheSgpe2xldCB0PXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsMjApO3JldHVybiB0P25ldyBGbG9hdDMyQXJyYXkodGhpcy5iYi5ieXRlcygpLmJ1ZmZlcix0aGlzLmJiLmJ5dGVzKCkuYnl0ZU9mZnNldCt0aGlzLmJiLl9fdmVjdG9yKHRoaXMuYmJfcG9zK3QpLHRoaXMuYmIuX192ZWN0b3JfbGVuKHRoaXMuYmJfcG9zK3QpKTpudWxsfWludHModCl7bGV0IGU9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3BvcywyMik7cmV0dXJuIGU/dGhpcy5iYi5yZWFkSW50NjQodGhpcy5iYi5fX3ZlY3Rvcih0aGlzLmJiX3BvcytlKSs4KnQpOnRoaXMuYmIuY3JlYXRlTG9uZygwLDApfWludHNMZW5ndGgoKXtsZXQgdD10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDIyKTtyZXR1cm4gdD90aGlzLmJiLl9fdmVjdG9yX2xlbih0aGlzLmJiX3Bvcyt0KTowfXN0cmluZ3ModCxlKXtsZXQgbj10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDI0KTtyZXR1cm4gbj90aGlzLmJiLl9fc3RyaW5nKHRoaXMuYmIuX192ZWN0b3IodGhpcy5iYl9wb3MrbikrNCp0LGUpOm51bGx9c3RyaW5nc0xlbmd0aCgpe2xldCB0PXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsMjQpO3JldHVybiB0P3RoaXMuYmIuX192ZWN0b3JfbGVuKHRoaXMuYmJfcG9zK3QpOjB9dGVuc29ycyhlLG4pe2xldCByPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsMjYpO3JldHVybiByPyhufHxuZXcgdC5leHBlcmltZW50YWwuZmJzLlRlbnNvcikuX19pbml0KHRoaXMuYmIuX19pbmRpcmVjdCh0aGlzLmJiLl9fdmVjdG9yKHRoaXMuYmJfcG9zK3IpKzQqZSksdGhpcy5iYik6bnVsbH10ZW5zb3JzTGVuZ3RoKCl7bGV0IHQ9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3BvcywyNik7cmV0dXJuIHQ/dGhpcy5iYi5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MrdCk6MH1ncmFwaHMoZSxuKXtsZXQgcj10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDI4KTtyZXR1cm4gcj8obnx8bmV3IHQuZXhwZXJpbWVudGFsLmZicy5HcmFwaCkuX19pbml0KHRoaXMuYmIuX19pbmRpcmVjdCh0aGlzLmJiLl9fdmVjdG9yKHRoaXMuYmJfcG9zK3IpKzQqZSksdGhpcy5iYik6bnVsbH1ncmFwaHNMZW5ndGgoKXtsZXQgdD10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDI4KTtyZXR1cm4gdD90aGlzLmJiLl9fdmVjdG9yX2xlbih0aGlzLmJiX3Bvcyt0KTowfXN0YXRpYyBzdGFydEF0dHJpYnV0ZSh0KXt0LnN0YXJ0T2JqZWN0KDEzKX1zdGF0aWMgYWRkTmFtZSh0LGUpe3QuYWRkRmllbGRPZmZzZXQoMCxlLDApfXN0YXRpYyBhZGREb2NTdHJpbmcodCxlKXt0LmFkZEZpZWxkT2Zmc2V0KDEsZSwwKX1zdGF0aWMgYWRkVHlwZShlLG4pe2UuYWRkRmllbGRJbnQzMigyLG4sdC5leHBlcmltZW50YWwuZmJzLkF0dHJpYnV0ZVR5cGUuVU5ERUZJTkVEKX1zdGF0aWMgYWRkRih0LGUpe3QuYWRkRmllbGRGbG9hdDMyKDMsZSwwKX1zdGF0aWMgYWRkSSh0LGUpe3QuYWRkRmllbGRJbnQ2NCg0LGUsdC5jcmVhdGVMb25nKDAsMCkpfXN0YXRpYyBhZGRTKHQsZSl7dC5hZGRGaWVsZE9mZnNldCg1LGUsMCl9c3RhdGljIGFkZFQodCxlKXt0LmFkZEZpZWxkT2Zmc2V0KDYsZSwwKX1zdGF0aWMgYWRkRyh0LGUpe3QuYWRkRmllbGRPZmZzZXQoNyxlLDApfXN0YXRpYyBhZGRGbG9hdHModCxlKXt0LmFkZEZpZWxkT2Zmc2V0KDgsZSwwKX1zdGF0aWMgY3JlYXRlRmxvYXRzVmVjdG9yKHQsZSl7dC5zdGFydFZlY3Rvcig0LGUubGVuZ3RoLDQpO2ZvcihsZXQgbj1lLmxlbmd0aC0xO24+PTA7bi0tKXQuYWRkRmxvYXQzMihlW25dKTtyZXR1cm4gdC5lbmRWZWN0b3IoKX1zdGF0aWMgc3RhcnRGbG9hdHNWZWN0b3IodCxlKXt0LnN0YXJ0VmVjdG9yKDQsZSw0KX1zdGF0aWMgYWRkSW50cyh0LGUpe3QuYWRkRmllbGRPZmZzZXQoOSxlLDApfXN0YXRpYyBjcmVhdGVJbnRzVmVjdG9yKHQsZSl7dC5zdGFydFZlY3Rvcig4LGUubGVuZ3RoLDgpO2ZvcihsZXQgbj1lLmxlbmd0aC0xO24+PTA7bi0tKXQuYWRkSW50NjQoZVtuXSk7cmV0dXJuIHQuZW5kVmVjdG9yKCl9c3RhdGljIHN0YXJ0SW50c1ZlY3Rvcih0LGUpe3Quc3RhcnRWZWN0b3IoOCxlLDgpfXN0YXRpYyBhZGRTdHJpbmdzKHQsZSl7dC5hZGRGaWVsZE9mZnNldCgxMCxlLDApfXN0YXRpYyBjcmVhdGVTdHJpbmdzVmVjdG9yKHQsZSl7dC5zdGFydFZlY3Rvcig0LGUubGVuZ3RoLDQpO2ZvcihsZXQgbj1lLmxlbmd0aC0xO24+PTA7bi0tKXQuYWRkT2Zmc2V0KGVbbl0pO3JldHVybiB0LmVuZFZlY3RvcigpfXN0YXRpYyBzdGFydFN0cmluZ3NWZWN0b3IodCxlKXt0LnN0YXJ0VmVjdG9yKDQsZSw0KX1zdGF0aWMgYWRkVGVuc29ycyh0LGUpe3QuYWRkRmllbGRPZmZzZXQoMTEsZSwwKX1zdGF0aWMgY3JlYXRlVGVuc29yc1ZlY3Rvcih0LGUpe3Quc3RhcnRWZWN0b3IoNCxlLmxlbmd0aCw0KTtmb3IobGV0IG49ZS5sZW5ndGgtMTtuPj0wO24tLSl0LmFkZE9mZnNldChlW25dKTtyZXR1cm4gdC5lbmRWZWN0b3IoKX1zdGF0aWMgc3RhcnRUZW5zb3JzVmVjdG9yKHQsZSl7dC5zdGFydFZlY3Rvcig0LGUsNCl9c3RhdGljIGFkZEdyYXBocyh0LGUpe3QuYWRkRmllbGRPZmZzZXQoMTIsZSwwKX1zdGF0aWMgY3JlYXRlR3JhcGhzVmVjdG9yKHQsZSl7dC5zdGFydFZlY3Rvcig0LGUubGVuZ3RoLDQpO2ZvcihsZXQgbj1lLmxlbmd0aC0xO24+PTA7bi0tKXQuYWRkT2Zmc2V0KGVbbl0pO3JldHVybiB0LmVuZFZlY3RvcigpfXN0YXRpYyBzdGFydEdyYXBoc1ZlY3Rvcih0LGUpe3Quc3RhcnRWZWN0b3IoNCxlLDQpfXN0YXRpYyBlbmRBdHRyaWJ1dGUodCl7cmV0dXJuIHQuZW5kT2JqZWN0KCl9c3RhdGljIGNyZWF0ZUF0dHJpYnV0ZSh0LGUscixpLG8sYSxzLHUsYyxsLHAsZixkLGgpe3JldHVybiBuLnN0YXJ0QXR0cmlidXRlKHQpLG4uYWRkTmFtZSh0LGUpLG4uYWRkRG9jU3RyaW5nKHQsciksbi5hZGRUeXBlKHQsaSksbi5hZGRGKHQsbyksbi5hZGRJKHQsYSksbi5hZGRTKHQscyksbi5hZGRUKHQsdSksbi5hZGRHKHQsYyksbi5hZGRGbG9hdHModCxsKSxuLmFkZEludHModCxwKSxuLmFkZFN0cmluZ3ModCxmKSxuLmFkZFRlbnNvcnModCxkKSxuLmFkZEdyYXBocyh0LGgpLG4uZW5kQXR0cmlidXRlKHQpfX1lLkF0dHJpYnV0ZT1ufShlLmZic3x8KGUuZmJzPXt9KSl9KHQuZXhwZXJpbWVudGFsfHwodC5leHBlcmltZW50YWw9e30pKX0oZS5vbm54cnVudGltZXx8KGUub25ueHJ1bnRpbWU9e30pKSxmdW5jdGlvbih0KXshZnVuY3Rpb24oZSl7IWZ1bmN0aW9uKGUpe2NsYXNzIG57Y29uc3RydWN0b3IoKXt0aGlzLmJiPW51bGwsdGhpcy5iYl9wb3M9MH1fX2luaXQodCxlKXtyZXR1cm4gdGhpcy5iYl9wb3M9dCx0aGlzLmJiPWUsdGhpc31zdGF0aWMgZ2V0Um9vdEFzR3JhcGgodCxlKXtyZXR1cm4oZXx8bmV3IG4pLl9faW5pdCh0LnJlYWRJbnQzMih0LnBvc2l0aW9uKCkpK3QucG9zaXRpb24oKSx0KX1zdGF0aWMgZ2V0U2l6ZVByZWZpeGVkUm9vdEFzR3JhcGgodCxlKXtyZXR1cm4gdC5zZXRQb3NpdGlvbih0LnBvc2l0aW9uKCkrci5mbGF0YnVmZmVycy5TSVpFX1BSRUZJWF9MRU5HVEgpLChlfHxuZXcgbikuX19pbml0KHQucmVhZEludDMyKHQucG9zaXRpb24oKSkrdC5wb3NpdGlvbigpLHQpfWluaXRpYWxpemVycyhlLG4pe2xldCByPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNCk7cmV0dXJuIHI/KG58fG5ldyB0LmV4cGVyaW1lbnRhbC5mYnMuVGVuc29yKS5fX2luaXQodGhpcy5iYi5fX2luZGlyZWN0KHRoaXMuYmIuX192ZWN0b3IodGhpcy5iYl9wb3MrcikrNCplKSx0aGlzLmJiKTpudWxsfWluaXRpYWxpemVyc0xlbmd0aCgpe2xldCB0PXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNCk7cmV0dXJuIHQ/dGhpcy5iYi5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MrdCk6MH1ub2RlQXJncyhlLG4pe2xldCByPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNik7cmV0dXJuIHI/KG58fG5ldyB0LmV4cGVyaW1lbnRhbC5mYnMuVmFsdWVJbmZvKS5fX2luaXQodGhpcy5iYi5fX2luZGlyZWN0KHRoaXMuYmIuX192ZWN0b3IodGhpcy5iYl9wb3MrcikrNCplKSx0aGlzLmJiKTpudWxsfW5vZGVBcmdzTGVuZ3RoKCl7bGV0IHQ9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw2KTtyZXR1cm4gdD90aGlzLmJiLl9fdmVjdG9yX2xlbih0aGlzLmJiX3Bvcyt0KTowfW5vZGVzKGUsbil7bGV0IHI9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw4KTtyZXR1cm4gcj8obnx8bmV3IHQuZXhwZXJpbWVudGFsLmZicy5Ob2RlKS5fX2luaXQodGhpcy5iYi5fX2luZGlyZWN0KHRoaXMuYmIuX192ZWN0b3IodGhpcy5iYl9wb3MrcikrNCplKSx0aGlzLmJiKTpudWxsfW5vZGVzTGVuZ3RoKCl7bGV0IHQ9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw4KTtyZXR1cm4gdD90aGlzLmJiLl9fdmVjdG9yX2xlbih0aGlzLmJiX3Bvcyt0KTowfW1heE5vZGVJbmRleCgpe2xldCB0PXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsMTApO3JldHVybiB0P3RoaXMuYmIucmVhZFVpbnQzMih0aGlzLmJiX3Bvcyt0KTowfW5vZGVFZGdlcyhlLG4pe2xldCByPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsMTIpO3JldHVybiByPyhufHxuZXcgdC5leHBlcmltZW50YWwuZmJzLk5vZGVFZGdlKS5fX2luaXQodGhpcy5iYi5fX2luZGlyZWN0KHRoaXMuYmIuX192ZWN0b3IodGhpcy5iYl9wb3MrcikrNCplKSx0aGlzLmJiKTpudWxsfW5vZGVFZGdlc0xlbmd0aCgpe2xldCB0PXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsMTIpO3JldHVybiB0P3RoaXMuYmIuX192ZWN0b3JfbGVuKHRoaXMuYmJfcG9zK3QpOjB9aW5wdXRzKHQsZSl7bGV0IG49dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3BvcywxNCk7cmV0dXJuIG4/dGhpcy5iYi5fX3N0cmluZyh0aGlzLmJiLl9fdmVjdG9yKHRoaXMuYmJfcG9zK24pKzQqdCxlKTpudWxsfWlucHV0c0xlbmd0aCgpe2xldCB0PXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsMTQpO3JldHVybiB0P3RoaXMuYmIuX192ZWN0b3JfbGVuKHRoaXMuYmJfcG9zK3QpOjB9b3V0cHV0cyh0LGUpe2xldCBuPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsMTYpO3JldHVybiBuP3RoaXMuYmIuX19zdHJpbmcodGhpcy5iYi5fX3ZlY3Rvcih0aGlzLmJiX3BvcytuKSs0KnQsZSk6bnVsbH1vdXRwdXRzTGVuZ3RoKCl7bGV0IHQ9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3BvcywxNik7cmV0dXJuIHQ/dGhpcy5iYi5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MrdCk6MH1zcGFyc2VJbml0aWFsaXplcnMoZSxuKXtsZXQgcj10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDE4KTtyZXR1cm4gcj8obnx8bmV3IHQuZXhwZXJpbWVudGFsLmZicy5TcGFyc2VUZW5zb3IpLl9faW5pdCh0aGlzLmJiLl9faW5kaXJlY3QodGhpcy5iYi5fX3ZlY3Rvcih0aGlzLmJiX3BvcytyKSs0KmUpLHRoaXMuYmIpOm51bGx9c3BhcnNlSW5pdGlhbGl6ZXJzTGVuZ3RoKCl7bGV0IHQ9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3BvcywxOCk7cmV0dXJuIHQ/dGhpcy5iYi5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MrdCk6MH1zdGF0aWMgc3RhcnRHcmFwaCh0KXt0LnN0YXJ0T2JqZWN0KDgpfXN0YXRpYyBhZGRJbml0aWFsaXplcnModCxlKXt0LmFkZEZpZWxkT2Zmc2V0KDAsZSwwKX1zdGF0aWMgY3JlYXRlSW5pdGlhbGl6ZXJzVmVjdG9yKHQsZSl7dC5zdGFydFZlY3Rvcig0LGUubGVuZ3RoLDQpO2ZvcihsZXQgbj1lLmxlbmd0aC0xO24+PTA7bi0tKXQuYWRkT2Zmc2V0KGVbbl0pO3JldHVybiB0LmVuZFZlY3RvcigpfXN0YXRpYyBzdGFydEluaXRpYWxpemVyc1ZlY3Rvcih0LGUpe3Quc3RhcnRWZWN0b3IoNCxlLDQpfXN0YXRpYyBhZGROb2RlQXJncyh0LGUpe3QuYWRkRmllbGRPZmZzZXQoMSxlLDApfXN0YXRpYyBjcmVhdGVOb2RlQXJnc1ZlY3Rvcih0LGUpe3Quc3RhcnRWZWN0b3IoNCxlLmxlbmd0aCw0KTtmb3IobGV0IG49ZS5sZW5ndGgtMTtuPj0wO24tLSl0LmFkZE9mZnNldChlW25dKTtyZXR1cm4gdC5lbmRWZWN0b3IoKX1zdGF0aWMgc3RhcnROb2RlQXJnc1ZlY3Rvcih0LGUpe3Quc3RhcnRWZWN0b3IoNCxlLDQpfXN0YXRpYyBhZGROb2Rlcyh0LGUpe3QuYWRkRmllbGRPZmZzZXQoMixlLDApfXN0YXRpYyBjcmVhdGVOb2Rlc1ZlY3Rvcih0LGUpe3Quc3RhcnRWZWN0b3IoNCxlLmxlbmd0aCw0KTtmb3IobGV0IG49ZS5sZW5ndGgtMTtuPj0wO24tLSl0LmFkZE9mZnNldChlW25dKTtyZXR1cm4gdC5lbmRWZWN0b3IoKX1zdGF0aWMgc3RhcnROb2Rlc1ZlY3Rvcih0LGUpe3Quc3RhcnRWZWN0b3IoNCxlLDQpfXN0YXRpYyBhZGRNYXhOb2RlSW5kZXgodCxlKXt0LmFkZEZpZWxkSW50MzIoMyxlLDApfXN0YXRpYyBhZGROb2RlRWRnZXModCxlKXt0LmFkZEZpZWxkT2Zmc2V0KDQsZSwwKX1zdGF0aWMgY3JlYXRlTm9kZUVkZ2VzVmVjdG9yKHQsZSl7dC5zdGFydFZlY3Rvcig0LGUubGVuZ3RoLDQpO2ZvcihsZXQgbj1lLmxlbmd0aC0xO24+PTA7bi0tKXQuYWRkT2Zmc2V0KGVbbl0pO3JldHVybiB0LmVuZFZlY3RvcigpfXN0YXRpYyBzdGFydE5vZGVFZGdlc1ZlY3Rvcih0LGUpe3Quc3RhcnRWZWN0b3IoNCxlLDQpfXN0YXRpYyBhZGRJbnB1dHModCxlKXt0LmFkZEZpZWxkT2Zmc2V0KDUsZSwwKX1zdGF0aWMgY3JlYXRlSW5wdXRzVmVjdG9yKHQsZSl7dC5zdGFydFZlY3Rvcig0LGUubGVuZ3RoLDQpO2ZvcihsZXQgbj1lLmxlbmd0aC0xO24+PTA7bi0tKXQuYWRkT2Zmc2V0KGVbbl0pO3JldHVybiB0LmVuZFZlY3RvcigpfXN0YXRpYyBzdGFydElucHV0c1ZlY3Rvcih0LGUpe3Quc3RhcnRWZWN0b3IoNCxlLDQpfXN0YXRpYyBhZGRPdXRwdXRzKHQsZSl7dC5hZGRGaWVsZE9mZnNldCg2LGUsMCl9c3RhdGljIGNyZWF0ZU91dHB1dHNWZWN0b3IodCxlKXt0LnN0YXJ0VmVjdG9yKDQsZS5sZW5ndGgsNCk7Zm9yKGxldCBuPWUubGVuZ3RoLTE7bj49MDtuLS0pdC5hZGRPZmZzZXQoZVtuXSk7cmV0dXJuIHQuZW5kVmVjdG9yKCl9c3RhdGljIHN0YXJ0T3V0cHV0c1ZlY3Rvcih0LGUpe3Quc3RhcnRWZWN0b3IoNCxlLDQpfXN0YXRpYyBhZGRTcGFyc2VJbml0aWFsaXplcnModCxlKXt0LmFkZEZpZWxkT2Zmc2V0KDcsZSwwKX1zdGF0aWMgY3JlYXRlU3BhcnNlSW5pdGlhbGl6ZXJzVmVjdG9yKHQsZSl7dC5zdGFydFZlY3Rvcig0LGUubGVuZ3RoLDQpO2ZvcihsZXQgbj1lLmxlbmd0aC0xO24+PTA7bi0tKXQuYWRkT2Zmc2V0KGVbbl0pO3JldHVybiB0LmVuZFZlY3RvcigpfXN0YXRpYyBzdGFydFNwYXJzZUluaXRpYWxpemVyc1ZlY3Rvcih0LGUpe3Quc3RhcnRWZWN0b3IoNCxlLDQpfXN0YXRpYyBlbmRHcmFwaCh0KXtyZXR1cm4gdC5lbmRPYmplY3QoKX1zdGF0aWMgY3JlYXRlR3JhcGgodCxlLHIsaSxvLGEscyx1LGMpe3JldHVybiBuLnN0YXJ0R3JhcGgodCksbi5hZGRJbml0aWFsaXplcnModCxlKSxuLmFkZE5vZGVBcmdzKHQsciksbi5hZGROb2Rlcyh0LGkpLG4uYWRkTWF4Tm9kZUluZGV4KHQsbyksbi5hZGROb2RlRWRnZXModCxhKSxuLmFkZElucHV0cyh0LHMpLG4uYWRkT3V0cHV0cyh0LHUpLG4uYWRkU3BhcnNlSW5pdGlhbGl6ZXJzKHQsYyksbi5lbmRHcmFwaCh0KX19ZS5HcmFwaD1ufShlLmZic3x8KGUuZmJzPXt9KSl9KHQuZXhwZXJpbWVudGFsfHwodC5leHBlcmltZW50YWw9e30pKX0oZS5vbm54cnVudGltZXx8KGUub25ueHJ1bnRpbWU9e30pKSxmdW5jdGlvbih0KXshZnVuY3Rpb24oZSl7IWZ1bmN0aW9uKGUpe2NsYXNzIG57Y29uc3RydWN0b3IoKXt0aGlzLmJiPW51bGwsdGhpcy5iYl9wb3M9MH1fX2luaXQodCxlKXtyZXR1cm4gdGhpcy5iYl9wb3M9dCx0aGlzLmJiPWUsdGhpc31zdGF0aWMgZ2V0Um9vdEFzTW9kZWwodCxlKXtyZXR1cm4oZXx8bmV3IG4pLl9faW5pdCh0LnJlYWRJbnQzMih0LnBvc2l0aW9uKCkpK3QucG9zaXRpb24oKSx0KX1zdGF0aWMgZ2V0U2l6ZVByZWZpeGVkUm9vdEFzTW9kZWwodCxlKXtyZXR1cm4gdC5zZXRQb3NpdGlvbih0LnBvc2l0aW9uKCkrci5mbGF0YnVmZmVycy5TSVpFX1BSRUZJWF9MRU5HVEgpLChlfHxuZXcgbikuX19pbml0KHQucmVhZEludDMyKHQucG9zaXRpb24oKSkrdC5wb3NpdGlvbigpLHQpfWlyVmVyc2lvbigpe2xldCB0PXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNCk7cmV0dXJuIHQ/dGhpcy5iYi5yZWFkSW50NjQodGhpcy5iYl9wb3MrdCk6dGhpcy5iYi5jcmVhdGVMb25nKDAsMCl9b3BzZXRJbXBvcnQoZSxuKXtsZXQgcj10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDYpO3JldHVybiByPyhufHxuZXcgdC5leHBlcmltZW50YWwuZmJzLk9wZXJhdG9yU2V0SWQpLl9faW5pdCh0aGlzLmJiLl9faW5kaXJlY3QodGhpcy5iYi5fX3ZlY3Rvcih0aGlzLmJiX3BvcytyKSs0KmUpLHRoaXMuYmIpOm51bGx9b3BzZXRJbXBvcnRMZW5ndGgoKXtsZXQgdD10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDYpO3JldHVybiB0P3RoaXMuYmIuX192ZWN0b3JfbGVuKHRoaXMuYmJfcG9zK3QpOjB9cHJvZHVjZXJOYW1lKHQpe2xldCBlPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsOCk7cmV0dXJuIGU/dGhpcy5iYi5fX3N0cmluZyh0aGlzLmJiX3BvcytlLHQpOm51bGx9cHJvZHVjZXJWZXJzaW9uKHQpe2xldCBlPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsMTApO3JldHVybiBlP3RoaXMuYmIuX19zdHJpbmcodGhpcy5iYl9wb3MrZSx0KTpudWxsfWRvbWFpbih0KXtsZXQgZT10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDEyKTtyZXR1cm4gZT90aGlzLmJiLl9fc3RyaW5nKHRoaXMuYmJfcG9zK2UsdCk6bnVsbH1tb2RlbFZlcnNpb24oKXtsZXQgdD10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDE0KTtyZXR1cm4gdD90aGlzLmJiLnJlYWRJbnQ2NCh0aGlzLmJiX3Bvcyt0KTp0aGlzLmJiLmNyZWF0ZUxvbmcoMCwwKX1kb2NTdHJpbmcodCl7bGV0IGU9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3BvcywxNik7cmV0dXJuIGU/dGhpcy5iYi5fX3N0cmluZyh0aGlzLmJiX3BvcytlLHQpOm51bGx9Z3JhcGgoZSl7bGV0IG49dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3BvcywxOCk7cmV0dXJuIG4/KGV8fG5ldyB0LmV4cGVyaW1lbnRhbC5mYnMuR3JhcGgpLl9faW5pdCh0aGlzLmJiLl9faW5kaXJlY3QodGhpcy5iYl9wb3MrbiksdGhpcy5iYik6bnVsbH1ncmFwaERvY1N0cmluZyh0KXtsZXQgZT10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDIwKTtyZXR1cm4gZT90aGlzLmJiLl9fc3RyaW5nKHRoaXMuYmJfcG9zK2UsdCk6bnVsbH1zdGF0aWMgc3RhcnRNb2RlbCh0KXt0LnN0YXJ0T2JqZWN0KDkpfXN0YXRpYyBhZGRJclZlcnNpb24odCxlKXt0LmFkZEZpZWxkSW50NjQoMCxlLHQuY3JlYXRlTG9uZygwLDApKX1zdGF0aWMgYWRkT3BzZXRJbXBvcnQodCxlKXt0LmFkZEZpZWxkT2Zmc2V0KDEsZSwwKX1zdGF0aWMgY3JlYXRlT3BzZXRJbXBvcnRWZWN0b3IodCxlKXt0LnN0YXJ0VmVjdG9yKDQsZS5sZW5ndGgsNCk7Zm9yKGxldCBuPWUubGVuZ3RoLTE7bj49MDtuLS0pdC5hZGRPZmZzZXQoZVtuXSk7cmV0dXJuIHQuZW5kVmVjdG9yKCl9c3RhdGljIHN0YXJ0T3BzZXRJbXBvcnRWZWN0b3IodCxlKXt0LnN0YXJ0VmVjdG9yKDQsZSw0KX1zdGF0aWMgYWRkUHJvZHVjZXJOYW1lKHQsZSl7dC5hZGRGaWVsZE9mZnNldCgyLGUsMCl9c3RhdGljIGFkZFByb2R1Y2VyVmVyc2lvbih0LGUpe3QuYWRkRmllbGRPZmZzZXQoMyxlLDApfXN0YXRpYyBhZGREb21haW4odCxlKXt0LmFkZEZpZWxkT2Zmc2V0KDQsZSwwKX1zdGF0aWMgYWRkTW9kZWxWZXJzaW9uKHQsZSl7dC5hZGRGaWVsZEludDY0KDUsZSx0LmNyZWF0ZUxvbmcoMCwwKSl9c3RhdGljIGFkZERvY1N0cmluZyh0LGUpe3QuYWRkRmllbGRPZmZzZXQoNixlLDApfXN0YXRpYyBhZGRHcmFwaCh0LGUpe3QuYWRkRmllbGRPZmZzZXQoNyxlLDApfXN0YXRpYyBhZGRHcmFwaERvY1N0cmluZyh0LGUpe3QuYWRkRmllbGRPZmZzZXQoOCxlLDApfXN0YXRpYyBlbmRNb2RlbCh0KXtyZXR1cm4gdC5lbmRPYmplY3QoKX1zdGF0aWMgY3JlYXRlTW9kZWwodCxlLHIsaSxvLGEscyx1LGMsbCl7cmV0dXJuIG4uc3RhcnRNb2RlbCh0KSxuLmFkZElyVmVyc2lvbih0LGUpLG4uYWRkT3BzZXRJbXBvcnQodCxyKSxuLmFkZFByb2R1Y2VyTmFtZSh0LGkpLG4uYWRkUHJvZHVjZXJWZXJzaW9uKHQsbyksbi5hZGREb21haW4odCxhKSxuLmFkZE1vZGVsVmVyc2lvbih0LHMpLG4uYWRkRG9jU3RyaW5nKHQsdSksbi5hZGRHcmFwaCh0LGMpLG4uYWRkR3JhcGhEb2NTdHJpbmcodCxsKSxuLmVuZE1vZGVsKHQpfX1lLk1vZGVsPW59KGUuZmJzfHwoZS5mYnM9e30pKX0odC5leHBlcmltZW50YWx8fCh0LmV4cGVyaW1lbnRhbD17fSkpfShlLm9ubnhydW50aW1lfHwoZS5vbm54cnVudGltZT17fSkpLGZ1bmN0aW9uKHQpeyFmdW5jdGlvbih0KXshZnVuY3Rpb24odCl7Y2xhc3MgZXtjb25zdHJ1Y3Rvcigpe3RoaXMuYmI9bnVsbCx0aGlzLmJiX3Bvcz0wfV9faW5pdCh0LGUpe3JldHVybiB0aGlzLmJiX3Bvcz10LHRoaXMuYmI9ZSx0aGlzfXN0YXRpYyBnZXRSb290QXNLZXJuZWxDcmVhdGVJbmZvcyh0LG4pe3JldHVybihufHxuZXcgZSkuX19pbml0KHQucmVhZEludDMyKHQucG9zaXRpb24oKSkrdC5wb3NpdGlvbigpLHQpfXN0YXRpYyBnZXRTaXplUHJlZml4ZWRSb290QXNLZXJuZWxDcmVhdGVJbmZvcyh0LG4pe3JldHVybiB0LnNldFBvc2l0aW9uKHQucG9zaXRpb24oKStyLmZsYXRidWZmZXJzLlNJWkVfUFJFRklYX0xFTkdUSCksKG58fG5ldyBlKS5fX2luaXQodC5yZWFkSW50MzIodC5wb3NpdGlvbigpKSt0LnBvc2l0aW9uKCksdCl9bm9kZUluZGljZXModCl7bGV0IGU9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw0KTtyZXR1cm4gZT90aGlzLmJiLnJlYWRVaW50MzIodGhpcy5iYi5fX3ZlY3Rvcih0aGlzLmJiX3BvcytlKSs0KnQpOjB9bm9kZUluZGljZXNMZW5ndGgoKXtsZXQgdD10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDQpO3JldHVybiB0P3RoaXMuYmIuX192ZWN0b3JfbGVuKHRoaXMuYmJfcG9zK3QpOjB9bm9kZUluZGljZXNBcnJheSgpe2xldCB0PXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNCk7cmV0dXJuIHQ/bmV3IFVpbnQzMkFycmF5KHRoaXMuYmIuYnl0ZXMoKS5idWZmZXIsdGhpcy5iYi5ieXRlcygpLmJ5dGVPZmZzZXQrdGhpcy5iYi5fX3ZlY3Rvcih0aGlzLmJiX3Bvcyt0KSx0aGlzLmJiLl9fdmVjdG9yX2xlbih0aGlzLmJiX3Bvcyt0KSk6bnVsbH1rZXJuZWxEZWZIYXNoZXModCl7bGV0IGU9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw2KTtyZXR1cm4gZT90aGlzLmJiLnJlYWRVaW50NjQodGhpcy5iYi5fX3ZlY3Rvcih0aGlzLmJiX3BvcytlKSs4KnQpOnRoaXMuYmIuY3JlYXRlTG9uZygwLDApfWtlcm5lbERlZkhhc2hlc0xlbmd0aCgpe2xldCB0PXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNik7cmV0dXJuIHQ/dGhpcy5iYi5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MrdCk6MH1zdGF0aWMgc3RhcnRLZXJuZWxDcmVhdGVJbmZvcyh0KXt0LnN0YXJ0T2JqZWN0KDIpfXN0YXRpYyBhZGROb2RlSW5kaWNlcyh0LGUpe3QuYWRkRmllbGRPZmZzZXQoMCxlLDApfXN0YXRpYyBjcmVhdGVOb2RlSW5kaWNlc1ZlY3Rvcih0LGUpe3Quc3RhcnRWZWN0b3IoNCxlLmxlbmd0aCw0KTtmb3IobGV0IG49ZS5sZW5ndGgtMTtuPj0wO24tLSl0LmFkZEludDMyKGVbbl0pO3JldHVybiB0LmVuZFZlY3RvcigpfXN0YXRpYyBzdGFydE5vZGVJbmRpY2VzVmVjdG9yKHQsZSl7dC5zdGFydFZlY3Rvcig0LGUsNCl9c3RhdGljIGFkZEtlcm5lbERlZkhhc2hlcyh0LGUpe3QuYWRkRmllbGRPZmZzZXQoMSxlLDApfXN0YXRpYyBjcmVhdGVLZXJuZWxEZWZIYXNoZXNWZWN0b3IodCxlKXt0LnN0YXJ0VmVjdG9yKDgsZS5sZW5ndGgsOCk7Zm9yKGxldCBuPWUubGVuZ3RoLTE7bj49MDtuLS0pdC5hZGRJbnQ2NChlW25dKTtyZXR1cm4gdC5lbmRWZWN0b3IoKX1zdGF0aWMgc3RhcnRLZXJuZWxEZWZIYXNoZXNWZWN0b3IodCxlKXt0LnN0YXJ0VmVjdG9yKDgsZSw4KX1zdGF0aWMgZW5kS2VybmVsQ3JlYXRlSW5mb3ModCl7cmV0dXJuIHQuZW5kT2JqZWN0KCl9c3RhdGljIGNyZWF0ZUtlcm5lbENyZWF0ZUluZm9zKHQsbixyKXtyZXR1cm4gZS5zdGFydEtlcm5lbENyZWF0ZUluZm9zKHQpLGUuYWRkTm9kZUluZGljZXModCxuKSxlLmFkZEtlcm5lbERlZkhhc2hlcyh0LHIpLGUuZW5kS2VybmVsQ3JlYXRlSW5mb3ModCl9fXQuS2VybmVsQ3JlYXRlSW5mb3M9ZX0odC5mYnN8fCh0LmZicz17fSkpfSh0LmV4cGVyaW1lbnRhbHx8KHQuZXhwZXJpbWVudGFsPXt9KSl9KGUub25ueHJ1bnRpbWV8fChlLm9ubnhydW50aW1lPXt9KSksZnVuY3Rpb24odCl7IWZ1bmN0aW9uKGUpeyFmdW5jdGlvbihlKXtjbGFzcyBue2NvbnN0cnVjdG9yKCl7dGhpcy5iYj1udWxsLHRoaXMuYmJfcG9zPTB9X19pbml0KHQsZSl7cmV0dXJuIHRoaXMuYmJfcG9zPXQsdGhpcy5iYj1lLHRoaXN9c3RhdGljIGdldFJvb3RBc1N1YkdyYXBoU2Vzc2lvblN0YXRlKHQsZSl7cmV0dXJuKGV8fG5ldyBuKS5fX2luaXQodC5yZWFkSW50MzIodC5wb3NpdGlvbigpKSt0LnBvc2l0aW9uKCksdCl9c3RhdGljIGdldFNpemVQcmVmaXhlZFJvb3RBc1N1YkdyYXBoU2Vzc2lvblN0YXRlKHQsZSl7cmV0dXJuIHQuc2V0UG9zaXRpb24odC5wb3NpdGlvbigpK3IuZmxhdGJ1ZmZlcnMuU0laRV9QUkVGSVhfTEVOR1RIKSwoZXx8bmV3IG4pLl9faW5pdCh0LnJlYWRJbnQzMih0LnBvc2l0aW9uKCkpK3QucG9zaXRpb24oKSx0KX1ncmFwaElkKHQpe2xldCBlPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNCk7cmV0dXJuIGU/dGhpcy5iYi5fX3N0cmluZyh0aGlzLmJiX3BvcytlLHQpOm51bGx9c2Vzc2lvblN0YXRlKGUpe2xldCBuPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNik7cmV0dXJuIG4/KGV8fG5ldyB0LmV4cGVyaW1lbnRhbC5mYnMuU2Vzc2lvblN0YXRlKS5fX2luaXQodGhpcy5iYi5fX2luZGlyZWN0KHRoaXMuYmJfcG9zK24pLHRoaXMuYmIpOm51bGx9c3RhdGljIHN0YXJ0U3ViR3JhcGhTZXNzaW9uU3RhdGUodCl7dC5zdGFydE9iamVjdCgyKX1zdGF0aWMgYWRkR3JhcGhJZCh0LGUpe3QuYWRkRmllbGRPZmZzZXQoMCxlLDApfXN0YXRpYyBhZGRTZXNzaW9uU3RhdGUodCxlKXt0LmFkZEZpZWxkT2Zmc2V0KDEsZSwwKX1zdGF0aWMgZW5kU3ViR3JhcGhTZXNzaW9uU3RhdGUodCl7bGV0IGU9dC5lbmRPYmplY3QoKTtyZXR1cm4gdC5yZXF1aXJlZEZpZWxkKGUsNCksZX1zdGF0aWMgY3JlYXRlU3ViR3JhcGhTZXNzaW9uU3RhdGUodCxlLHIpe3JldHVybiBuLnN0YXJ0U3ViR3JhcGhTZXNzaW9uU3RhdGUodCksbi5hZGRHcmFwaElkKHQsZSksbi5hZGRTZXNzaW9uU3RhdGUodCxyKSxuLmVuZFN1YkdyYXBoU2Vzc2lvblN0YXRlKHQpfX1lLlN1YkdyYXBoU2Vzc2lvblN0YXRlPW59KGUuZmJzfHwoZS5mYnM9e30pKX0odC5leHBlcmltZW50YWx8fCh0LmV4cGVyaW1lbnRhbD17fSkpfShlLm9ubnhydW50aW1lfHwoZS5vbm54cnVudGltZT17fSkpLGZ1bmN0aW9uKHQpeyFmdW5jdGlvbihlKXshZnVuY3Rpb24oZSl7Y2xhc3Mgbntjb25zdHJ1Y3Rvcigpe3RoaXMuYmI9bnVsbCx0aGlzLmJiX3Bvcz0wfV9faW5pdCh0LGUpe3JldHVybiB0aGlzLmJiX3Bvcz10LHRoaXMuYmI9ZSx0aGlzfXN0YXRpYyBnZXRSb290QXNTZXNzaW9uU3RhdGUodCxlKXtyZXR1cm4oZXx8bmV3IG4pLl9faW5pdCh0LnJlYWRJbnQzMih0LnBvc2l0aW9uKCkpK3QucG9zaXRpb24oKSx0KX1zdGF0aWMgZ2V0U2l6ZVByZWZpeGVkUm9vdEFzU2Vzc2lvblN0YXRlKHQsZSl7cmV0dXJuIHQuc2V0UG9zaXRpb24odC5wb3NpdGlvbigpK3IuZmxhdGJ1ZmZlcnMuU0laRV9QUkVGSVhfTEVOR1RIKSwoZXx8bmV3IG4pLl9faW5pdCh0LnJlYWRJbnQzMih0LnBvc2l0aW9uKCkpK3QucG9zaXRpb24oKSx0KX1rZXJuZWxzKGUpe2xldCBuPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNCk7cmV0dXJuIG4/KGV8fG5ldyB0LmV4cGVyaW1lbnRhbC5mYnMuS2VybmVsQ3JlYXRlSW5mb3MpLl9faW5pdCh0aGlzLmJiLl9faW5kaXJlY3QodGhpcy5iYl9wb3MrbiksdGhpcy5iYik6bnVsbH1zdWJHcmFwaFNlc3Npb25TdGF0ZXMoZSxuKXtsZXQgcj10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDYpO3JldHVybiByPyhufHxuZXcgdC5leHBlcmltZW50YWwuZmJzLlN1YkdyYXBoU2Vzc2lvblN0YXRlKS5fX2luaXQodGhpcy5iYi5fX2luZGlyZWN0KHRoaXMuYmIuX192ZWN0b3IodGhpcy5iYl9wb3MrcikrNCplKSx0aGlzLmJiKTpudWxsfXN1YkdyYXBoU2Vzc2lvblN0YXRlc0xlbmd0aCgpe2xldCB0PXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNik7cmV0dXJuIHQ/dGhpcy5iYi5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MrdCk6MH1zdGF0aWMgc3RhcnRTZXNzaW9uU3RhdGUodCl7dC5zdGFydE9iamVjdCgyKX1zdGF0aWMgYWRkS2VybmVscyh0LGUpe3QuYWRkRmllbGRPZmZzZXQoMCxlLDApfXN0YXRpYyBhZGRTdWJHcmFwaFNlc3Npb25TdGF0ZXModCxlKXt0LmFkZEZpZWxkT2Zmc2V0KDEsZSwwKX1zdGF0aWMgY3JlYXRlU3ViR3JhcGhTZXNzaW9uU3RhdGVzVmVjdG9yKHQsZSl7dC5zdGFydFZlY3Rvcig0LGUubGVuZ3RoLDQpO2ZvcihsZXQgbj1lLmxlbmd0aC0xO24+PTA7bi0tKXQuYWRkT2Zmc2V0KGVbbl0pO3JldHVybiB0LmVuZFZlY3RvcigpfXN0YXRpYyBzdGFydFN1YkdyYXBoU2Vzc2lvblN0YXRlc1ZlY3Rvcih0LGUpe3Quc3RhcnRWZWN0b3IoNCxlLDQpfXN0YXRpYyBlbmRTZXNzaW9uU3RhdGUodCl7cmV0dXJuIHQuZW5kT2JqZWN0KCl9c3RhdGljIGNyZWF0ZVNlc3Npb25TdGF0ZSh0LGUscil7cmV0dXJuIG4uc3RhcnRTZXNzaW9uU3RhdGUodCksbi5hZGRLZXJuZWxzKHQsZSksbi5hZGRTdWJHcmFwaFNlc3Npb25TdGF0ZXModCxyKSxuLmVuZFNlc3Npb25TdGF0ZSh0KX19ZS5TZXNzaW9uU3RhdGU9bn0oZS5mYnN8fChlLmZicz17fSkpfSh0LmV4cGVyaW1lbnRhbHx8KHQuZXhwZXJpbWVudGFsPXt9KSl9KGUub25ueHJ1bnRpbWV8fChlLm9ubnhydW50aW1lPXt9KSksZnVuY3Rpb24odCl7IWZ1bmN0aW9uKGUpeyFmdW5jdGlvbihlKXtjbGFzcyBue2NvbnN0cnVjdG9yKCl7dGhpcy5iYj1udWxsLHRoaXMuYmJfcG9zPTB9X19pbml0KHQsZSl7cmV0dXJuIHRoaXMuYmJfcG9zPXQsdGhpcy5iYj1lLHRoaXN9c3RhdGljIGdldFJvb3RBc0luZmVyZW5jZVNlc3Npb24odCxlKXtyZXR1cm4oZXx8bmV3IG4pLl9faW5pdCh0LnJlYWRJbnQzMih0LnBvc2l0aW9uKCkpK3QucG9zaXRpb24oKSx0KX1zdGF0aWMgZ2V0U2l6ZVByZWZpeGVkUm9vdEFzSW5mZXJlbmNlU2Vzc2lvbih0LGUpe3JldHVybiB0LnNldFBvc2l0aW9uKHQucG9zaXRpb24oKStyLmZsYXRidWZmZXJzLlNJWkVfUFJFRklYX0xFTkdUSCksKGV8fG5ldyBuKS5fX2luaXQodC5yZWFkSW50MzIodC5wb3NpdGlvbigpKSt0LnBvc2l0aW9uKCksdCl9c3RhdGljIGJ1ZmZlckhhc0lkZW50aWZpZXIodCl7cmV0dXJuIHQuX19oYXNfaWRlbnRpZmllcihcIk9SVE1cIil9b3J0VmVyc2lvbih0KXtsZXQgZT10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDQpO3JldHVybiBlP3RoaXMuYmIuX19zdHJpbmcodGhpcy5iYl9wb3MrZSx0KTpudWxsfW1vZGVsKGUpe2xldCBuPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNik7cmV0dXJuIG4/KGV8fG5ldyB0LmV4cGVyaW1lbnRhbC5mYnMuTW9kZWwpLl9faW5pdCh0aGlzLmJiLl9faW5kaXJlY3QodGhpcy5iYl9wb3MrbiksdGhpcy5iYik6bnVsbH1zZXNzaW9uU3RhdGUoZSl7bGV0IG49dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw4KTtyZXR1cm4gbj8oZXx8bmV3IHQuZXhwZXJpbWVudGFsLmZicy5TZXNzaW9uU3RhdGUpLl9faW5pdCh0aGlzLmJiLl9faW5kaXJlY3QodGhpcy5iYl9wb3MrbiksdGhpcy5iYik6bnVsbH1zdGF0aWMgc3RhcnRJbmZlcmVuY2VTZXNzaW9uKHQpe3Quc3RhcnRPYmplY3QoMyl9c3RhdGljIGFkZE9ydFZlcnNpb24odCxlKXt0LmFkZEZpZWxkT2Zmc2V0KDAsZSwwKX1zdGF0aWMgYWRkTW9kZWwodCxlKXt0LmFkZEZpZWxkT2Zmc2V0KDEsZSwwKX1zdGF0aWMgYWRkU2Vzc2lvblN0YXRlKHQsZSl7dC5hZGRGaWVsZE9mZnNldCgyLGUsMCl9c3RhdGljIGVuZEluZmVyZW5jZVNlc3Npb24odCl7cmV0dXJuIHQuZW5kT2JqZWN0KCl9c3RhdGljIGZpbmlzaEluZmVyZW5jZVNlc3Npb25CdWZmZXIodCxlKXt0LmZpbmlzaChlLFwiT1JUTVwiKX1zdGF0aWMgZmluaXNoU2l6ZVByZWZpeGVkSW5mZXJlbmNlU2Vzc2lvbkJ1ZmZlcih0LGUpe3QuZmluaXNoKGUsXCJPUlRNXCIsITApfXN0YXRpYyBjcmVhdGVJbmZlcmVuY2VTZXNzaW9uKHQsZSxyLGkpe3JldHVybiBuLnN0YXJ0SW5mZXJlbmNlU2Vzc2lvbih0KSxuLmFkZE9ydFZlcnNpb24odCxlKSxuLmFkZE1vZGVsKHQsciksbi5hZGRTZXNzaW9uU3RhdGUodCxpKSxuLmVuZEluZmVyZW5jZVNlc3Npb24odCl9fWUuSW5mZXJlbmNlU2Vzc2lvbj1ufShlLmZic3x8KGUuZmJzPXt9KSl9KHQuZXhwZXJpbWVudGFsfHwodC5leHBlcmltZW50YWw9e30pKX0oZS5vbm54cnVudGltZXx8KGUub25ueHJ1bnRpbWU9e30pKX0sNzQ0ODoodCxlLG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5Pbm54anNTZXNzaW9uSGFuZGxlcj12b2lkIDA7Y29uc3Qgcj1uKDYyMDcpLGk9big5MTYyKTtlLk9ubnhqc1Nlc3Npb25IYW5kbGVyPWNsYXNze2NvbnN0cnVjdG9yKHQpe3RoaXMuc2Vzc2lvbj10LHRoaXMuaW5wdXROYW1lcz10aGlzLnNlc3Npb24uaW5wdXROYW1lcyx0aGlzLm91dHB1dE5hbWVzPXRoaXMuc2Vzc2lvbi5vdXRwdXROYW1lc31hc3luYyBkaXNwb3NlKCl7fWFzeW5jIHJ1bih0LGUsbil7Y29uc3Qgbz1uZXcgTWFwO2Zvcihjb25zdCBlIGluIHQpaWYoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwodCxlKSl7Y29uc3Qgbj10W2VdO28uc2V0KGUsbmV3IGkuVGVuc29yKG4uZGltcyxuLnR5cGUsdm9pZCAwLHZvaWQgMCxuLmRhdGEpKX1jb25zdCBhPWF3YWl0IHRoaXMuc2Vzc2lvbi5ydW4obykscz17fTtyZXR1cm4gYS5mb3JFYWNoKCgodCxlKT0+e3NbZV09bmV3IHIuVGVuc29yKHQudHlwZSx0LmRhdGEsdC5kaW1zKX0pKSxzfXN0YXJ0UHJvZmlsaW5nKCl7dGhpcy5zZXNzaW9uLnN0YXJ0UHJvZmlsaW5nKCl9ZW5kUHJvZmlsaW5nKCl7dGhpcy5zZXNzaW9uLmVuZFByb2ZpbGluZygpfX19LDY5MTk6KHQsZSxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUuU2Vzc2lvbj12b2lkIDA7Y29uc3Qgcj1uKDYyMzEpLGk9big2NDY0KSxvPW4oNzA5MSksYT1uKDEwMzYpLHM9bigzNjk0KSx1PW4oMjY0NCk7ZS5TZXNzaW9uPWNsYXNze2NvbnN0cnVjdG9yKHQ9e30pe3RoaXMuX2luaXRpYWxpemVkPSExLHRoaXMuYmFja2VuZEhpbnQ9dC5iYWNrZW5kSGludCx0aGlzLnByb2ZpbGVyPXMuUHJvZmlsZXIuY3JlYXRlKHQucHJvZmlsZXIpLHRoaXMuY29udGV4dD17cHJvZmlsZXI6dGhpcy5wcm9maWxlcixncmFwaElucHV0VHlwZXM6W10sZ3JhcGhJbnB1dERpbXM6W119fWdldCBpbnB1dE5hbWVzKCl7cmV0dXJuIHRoaXMuX21vZGVsLmdyYXBoLmdldElucHV0TmFtZXMoKX1nZXQgb3V0cHV0TmFtZXMoKXtyZXR1cm4gdGhpcy5fbW9kZWwuZ3JhcGguZ2V0T3V0cHV0TmFtZXMoKX1zdGFydFByb2ZpbGluZygpe3RoaXMucHJvZmlsZXIuc3RhcnQoKX1lbmRQcm9maWxpbmcoKXt0aGlzLnByb2ZpbGVyLnN0b3AoKX1hc3luYyBsb2FkTW9kZWwodCxlLG4pe2F3YWl0IHRoaXMucHJvZmlsZXIuZXZlbnQoXCJzZXNzaW9uXCIsXCJTZXNzaW9uLmxvYWRNb2RlbFwiLChhc3luYygpPT57Y29uc3QgYT1hd2FpdCgwLG8ucmVzb2x2ZUJhY2tlbmQpKHRoaXMuYmFja2VuZEhpbnQpO2lmKHRoaXMuc2Vzc2lvbkhhbmRsZXI9YS5jcmVhdGVTZXNzaW9uSGFuZGxlcih0aGlzLmNvbnRleHQpLHRoaXMuX21vZGVsPW5ldyB1Lk1vZGVsLFwic3RyaW5nXCI9PXR5cGVvZiB0KXtjb25zdCBlPXQuZW5kc1dpdGgoXCIub3J0XCIpO2lmKFwidW5kZWZpbmVkXCI9PXR5cGVvZiBmZXRjaCl7Y29uc3Qgbj1hd2FpdCgwLGkucHJvbWlzaWZ5KShyLnJlYWRGaWxlKSh0KTt0aGlzLmluaXRpYWxpemUobixlKX1lbHNle2NvbnN0IG49YXdhaXQgZmV0Y2godCkscj1hd2FpdCBuLmFycmF5QnVmZmVyKCk7dGhpcy5pbml0aWFsaXplKG5ldyBVaW50OEFycmF5KHIpLGUpfX1lbHNlIGlmKEFycmF5QnVmZmVyLmlzVmlldyh0KSl0aGlzLmluaXRpYWxpemUodCk7ZWxzZXtjb25zdCByPW5ldyBVaW50OEFycmF5KHQsZXx8MCxufHx0LmJ5dGVMZW5ndGgpO3RoaXMuaW5pdGlhbGl6ZShyKX19KSl9aW5pdGlhbGl6ZSh0LGUpe2lmKHRoaXMuX2luaXRpYWxpemVkKXRocm93IG5ldyBFcnJvcihcImFscmVhZHkgaW5pdGlhbGl6ZWRcIik7dGhpcy5wcm9maWxlci5ldmVudChcInNlc3Npb25cIixcIlNlc3Npb24uaW5pdGlhbGl6ZVwiLCgoKT0+e2NvbnN0IG49dGhpcy5zZXNzaW9uSGFuZGxlci50cmFuc2Zvcm1HcmFwaD90aGlzLnNlc3Npb25IYW5kbGVyOnZvaWQgMDt0aGlzLl9tb2RlbC5sb2FkKHQsbixlKSx0aGlzLnNlc3Npb25IYW5kbGVyLm9uR3JhcGhJbml0aWFsaXplZCYmdGhpcy5zZXNzaW9uSGFuZGxlci5vbkdyYXBoSW5pdGlhbGl6ZWQodGhpcy5fbW9kZWwuZ3JhcGgpLHRoaXMuaW5pdGlhbGl6ZU9wcyh0aGlzLl9tb2RlbC5ncmFwaCksdGhpcy5fZXhlY3V0aW9uUGxhbj1uZXcgYS5FeGVjdXRpb25QbGFuKHRoaXMuX21vZGVsLmdyYXBoLHRoaXMuX29wcyx0aGlzLnByb2ZpbGVyKX0pKSx0aGlzLl9pbml0aWFsaXplZD0hMH1hc3luYyBydW4odCl7aWYoIXRoaXMuX2luaXRpYWxpemVkKXRocm93IG5ldyBFcnJvcihcInNlc3Npb24gbm90IGluaXRpYWxpemVkIHlldFwiKTtyZXR1cm4gdGhpcy5wcm9maWxlci5ldmVudChcInNlc3Npb25cIixcIlNlc3Npb24ucnVuXCIsKGFzeW5jKCk9Pntjb25zdCBlPXRoaXMubm9ybWFsaXplQW5kVmFsaWRhdGVJbnB1dHModCksbj1hd2FpdCB0aGlzLl9leGVjdXRpb25QbGFuLmV4ZWN1dGUodGhpcy5zZXNzaW9uSGFuZGxlcixlKTtyZXR1cm4gdGhpcy5jcmVhdGVPdXRwdXQobil9KSl9bm9ybWFsaXplQW5kVmFsaWRhdGVJbnB1dHModCl7Y29uc3QgZT10aGlzLl9tb2RlbC5ncmFwaC5nZXRJbnB1dE5hbWVzKCk7aWYoQXJyYXkuaXNBcnJheSh0KSl7aWYodC5sZW5ndGghPT1lLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoYGluY29ycmVjdCBpbnB1dCBhcnJheSBsZW5ndGg6IGV4cGVjdGVkICR7ZS5sZW5ndGh9IGJ1dCBnb3QgJHt0Lmxlbmd0aH1gKX1lbHNle2lmKHQuc2l6ZSE9PWUubGVuZ3RoKXRocm93IG5ldyBFcnJvcihgaW5jb3JyZWN0IGlucHV0IG1hcCBzaXplOiBleHBlY3RlZCAke2UubGVuZ3RofSBidXQgZ290ICR7dC5zaXplfWApO2NvbnN0IG49bmV3IEFycmF5KHQuc2l6ZSk7bGV0IHI9MDtmb3IobGV0IGk9MDtpPGUubGVuZ3RoOysraSl7Y29uc3Qgbz10LmdldChlW2ldKTtpZighbyl0aHJvdyBuZXcgRXJyb3IoYG1pc3NpbmcgaW5wdXQgdGVuc29yIGZvcjogJyR7bmFtZX0nYCk7bltyKytdPW99dD1ufWlmKHRoaXMuY29udGV4dC5ncmFwaElucHV0VHlwZXMmJjAhPT10aGlzLmNvbnRleHQuZ3JhcGhJbnB1dFR5cGVzLmxlbmd0aCYmdGhpcy5jb250ZXh0LmdyYXBoSW5wdXREaW1zJiYwIT09dGhpcy5jb250ZXh0LmdyYXBoSW5wdXREaW1zLmxlbmd0aCl0aGlzLnZhbGlkYXRlSW5wdXRUZW5zb3JEaW1zKHRoaXMuY29udGV4dC5ncmFwaElucHV0RGltcyx0LCExKTtlbHNle2NvbnN0IGU9dGhpcy5fbW9kZWwuZ3JhcGguZ2V0SW5wdXRJbmRpY2VzKCksbj10aGlzLl9tb2RlbC5ncmFwaC5nZXRWYWx1ZXMoKSxyPW5ldyBBcnJheShlLmxlbmd0aCk7Zm9yKGxldCBpPTA7aTxlLmxlbmd0aDsrK2kpe2NvbnN0IG89bltlW2ldXTtyW2ldPW8udHlwZS5zaGFwZS5kaW1zLHRoaXMuY29udGV4dC5ncmFwaElucHV0VHlwZXMucHVzaChvLnR5cGUudGVuc29yVHlwZSksdGhpcy5jb250ZXh0LmdyYXBoSW5wdXREaW1zLnB1c2godFtpXS5kaW1zKX10aGlzLnZhbGlkYXRlSW5wdXRUZW5zb3JEaW1zKHIsdCwhMCl9cmV0dXJuIHRoaXMudmFsaWRhdGVJbnB1dFRlbnNvclR5cGVzKHRoaXMuY29udGV4dC5ncmFwaElucHV0VHlwZXMsdCksdH12YWxpZGF0ZUlucHV0VGVuc29yVHlwZXModCxlKXtmb3IobGV0IG49MDtuPGUubGVuZ3RoO24rKyl7Y29uc3Qgcj10W25dLGk9ZVtuXS50eXBlO2lmKHIhPT1pKXRocm93IG5ldyBFcnJvcihgaW5wdXQgdGVuc29yWyR7bn1dIGNoZWNrIGZhaWxlZDogZXhwZWN0ZWQgdHlwZSAnJHtyfScgYnV0IGdvdCAke2l9YCl9fXZhbGlkYXRlSW5wdXRUZW5zb3JEaW1zKHQsZSxuKXtmb3IobGV0IHI9MDtyPGUubGVuZ3RoO3IrKyl7Y29uc3QgaT10W3JdLG89ZVtyXS5kaW1zO2lmKCF0aGlzLmNvbXBhcmVUZW5zb3JEaW1zKGksbyxuKSl0aHJvdyBuZXcgRXJyb3IoYGlucHV0IHRlbnNvclske3J9XSBjaGVjayBmYWlsZWQ6IGV4cGVjdGVkIHNoYXBlICdbJHtpLmpvaW4oXCIsXCIpfV0nIGJ1dCBnb3QgWyR7by5qb2luKFwiLFwiKX1dYCl9fWNvbXBhcmVUZW5zb3JEaW1zKHQsZSxuKXtpZih0Lmxlbmd0aCE9PWUubGVuZ3RoKXJldHVybiExO2ZvcihsZXQgcj0wO3I8dC5sZW5ndGg7KytyKWlmKHRbcl0hPT1lW3JdJiYoIW58fDAhPT10W3JdKSlyZXR1cm4hMTtyZXR1cm4hMH1jcmVhdGVPdXRwdXQodCl7Y29uc3QgZT10aGlzLl9tb2RlbC5ncmFwaC5nZXRPdXRwdXROYW1lcygpO2lmKHQubGVuZ3RoIT09ZS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiZXhwZWN0ZWQgbnVtYmVyIG9mIG91dHB1dHMgZG8gbm90IG1hdGNoIG51bWJlciBvZiBnZW5lcmF0ZWQgb3V0cHV0c1wiKTtjb25zdCBuPW5ldyBNYXA7Zm9yKGxldCByPTA7cjxlLmxlbmd0aDsrK3Ipbi5zZXQoZVtyXSx0W3JdKTtyZXR1cm4gbn1pbml0aWFsaXplT3BzKHQpe2NvbnN0IGU9dC5nZXROb2RlcygpO3RoaXMuX29wcz1uZXcgQXJyYXkoZS5sZW5ndGgpO2ZvcihsZXQgbj0wO248ZS5sZW5ndGg7bisrKXRoaXMuX29wc1tuXT10aGlzLnNlc3Npb25IYW5kbGVyLnJlc29sdmUoZVtuXSx0aGlzLl9tb2RlbC5vcHNldHMsdCl9fX0sOTE2MjpmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7dmFyIHI9dGhpcyYmdGhpcy5fX2ltcG9ydERlZmF1bHR8fGZ1bmN0aW9uKHQpe3JldHVybiB0JiZ0Ll9fZXNNb2R1bGU/dDp7ZGVmYXVsdDp0fX07T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5UZW5zb3I9dm9pZCAwO2NvbnN0IGk9bigzNDQyKSxvPXIobigzNzIwKSksYT1uKDE0NDYpLHM9big5Mzk1KSx1PW4oMjUxNyk7dmFyIGM9cy5vbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzO2NsYXNzIGx7Z2V0IGRhdGEoKXtpZih2b2lkIDA9PT10aGlzLmNhY2hlKXtjb25zdCB0PXRoaXMuZGF0YVByb3ZpZGVyKHRoaXMuZGF0YUlkKTtpZih0Lmxlbmd0aCE9PXRoaXMuc2l6ZSl0aHJvdyBuZXcgRXJyb3IoXCJMZW5ndGggb2YgZGF0YSBwcm92aWRlZCBieSB0aGUgRGF0YSBQcm92aWRlciBpcyBpbmNvbnNpc3RlbnQgd2l0aCB0aGUgZGltcyBvZiB0aGlzIFRlbnNvci5cIik7dGhpcy5jYWNoZT10fXJldHVybiB0aGlzLmNhY2hlfWdldCBzdHJpbmdEYXRhKCl7aWYoXCJzdHJpbmdcIiE9PXRoaXMudHlwZSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiZGF0YSB0eXBlIGlzIG5vdCBzdHJpbmdcIik7cmV0dXJuIHRoaXMuZGF0YX1nZXQgaW50ZWdlckRhdGEoKXtzd2l0Y2godGhpcy50eXBlKXtjYXNlXCJ1aW50OFwiOmNhc2VcImludDhcIjpjYXNlXCJ1aW50MTZcIjpjYXNlXCJpbnQxNlwiOmNhc2VcImludDMyXCI6Y2FzZVwidWludDMyXCI6Y2FzZVwiYm9vbFwiOnJldHVybiB0aGlzLmRhdGE7ZGVmYXVsdDp0aHJvdyBuZXcgVHlwZUVycm9yKFwiZGF0YSB0eXBlIGlzIG5vdCBpbnRlZ2VyICh1aW50OCwgaW50OCwgdWludDE2LCBpbnQxNiwgaW50MzIsIHVpbnQzMiwgYm9vbClcIil9fWdldCBmbG9hdERhdGEoKXtzd2l0Y2godGhpcy50eXBlKXtjYXNlXCJmbG9hdDMyXCI6Y2FzZVwiZmxvYXQ2NFwiOnJldHVybiB0aGlzLmRhdGE7ZGVmYXVsdDp0aHJvdyBuZXcgVHlwZUVycm9yKFwiZGF0YSB0eXBlIGlzIG5vdCBmbG9hdCAoZmxvYXQzMiwgZmxvYXQ2NClcIil9fWdldCBudW1iZXJEYXRhKCl7aWYoXCJzdHJpbmdcIiE9PXRoaXMudHlwZSlyZXR1cm4gdGhpcy5kYXRhO3Rocm93IG5ldyBUeXBlRXJyb3IoXCJ0eXBlIGNhbm5vdCBiZSBub24tbnVtYmVyIChzdHJpbmcpXCIpfWdldCh0KXtyZXR1cm4gdGhpcy5kYXRhW3UuU2hhcGVVdGlsLmluZGljZXNUb09mZnNldCh0LHRoaXMuc3RyaWRlcyldfXNldCh0LGUpe3RoaXMuZGF0YVt1LlNoYXBlVXRpbC5pbmRpY2VzVG9PZmZzZXQodCx0aGlzLnN0cmlkZXMpXT1lfWFzeW5jIGdldERhdGEoKXtyZXR1cm4gdm9pZCAwPT09dGhpcy5jYWNoZSYmKHRoaXMuY2FjaGU9YXdhaXQgdGhpcy5hc3luY0RhdGFQcm92aWRlcih0aGlzLmRhdGFJZCkpLHRoaXMuY2FjaGV9Z2V0IHN0cmlkZXMoKXtyZXR1cm4gdGhpcy5fc3RyaWRlc3x8KHRoaXMuX3N0cmlkZXM9dS5TaGFwZVV0aWwuY29tcHV0ZVN0cmlkZXModGhpcy5kaW1zKSksdGhpcy5fc3RyaWRlc31jb25zdHJ1Y3Rvcih0LGUsbixyLG8sYT1pLkd1aWQuY3JlYXRlKCkpe3RoaXMuZGltcz10LHRoaXMudHlwZT1lLHRoaXMuZGF0YVByb3ZpZGVyPW4sdGhpcy5hc3luY0RhdGFQcm92aWRlcj1yLHRoaXMuY2FjaGU9byx0aGlzLmRhdGFJZD1hLHRoaXMuc2l6ZT11LlNoYXBlVXRpbC52YWxpZGF0ZURpbXNBbmRDYWxjU2l6ZSh0KTtjb25zdCBzPXRoaXMuc2l6ZSxjPXZvaWQgMD09PW4mJnZvaWQgMD09PXImJnZvaWQgMD09PW87aWYodm9pZCAwIT09byYmby5sZW5ndGghPT1zKXRocm93IG5ldyBSYW5nZUVycm9yKFwiSW5wdXQgZGltcyBkb2Vzbid0IG1hdGNoIGRhdGEgbGVuZ3RoLlwiKTtpZihcInN0cmluZ1wiPT09ZSl7aWYoISh2b2lkIDA9PT1vfHxBcnJheS5pc0FycmF5KG8pJiZvLmV2ZXJ5KCh0PT5cInN0cmluZ1wiPT10eXBlb2YgdCkpKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiY2FjaGUgc2hvdWxkIGJlIGEgc3RyaW5nIGFycmF5XCIpO2MmJih0aGlzLmNhY2hlPW5ldyBBcnJheShzKSl9ZWxzZXtpZih2b2lkIDAhPT1vKXtjb25zdCB0PWYoZSk7aWYoIShvIGluc3RhbmNlb2YgdCkpdGhyb3cgbmV3IFR5cGVFcnJvcihgY2FjaGUgc2hvdWxkIGJlIHR5cGUgJHt0Lm5hbWV9YCl9aWYoYyl7Y29uc3QgdD1uZXcgQXJyYXlCdWZmZXIocypmdW5jdGlvbih0KXtzd2l0Y2godCl7Y2FzZVwiYm9vbFwiOmNhc2VcImludDhcIjpjYXNlXCJ1aW50OFwiOnJldHVybiAxO2Nhc2VcImludDE2XCI6Y2FzZVwidWludDE2XCI6cmV0dXJuIDI7Y2FzZVwiaW50MzJcIjpjYXNlXCJ1aW50MzJcIjpjYXNlXCJmbG9hdDMyXCI6cmV0dXJuIDQ7Y2FzZVwiZmxvYXQ2NFwiOnJldHVybiA4O2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBjYW5ub3QgY2FsY3VsYXRlIHNpemVvZigpIG9uIHR5cGUgJHt0fWApfX0oZSkpO3RoaXMuY2FjaGU9ZnVuY3Rpb24odCxlKXtyZXR1cm4gbmV3KGYoZSkpKHQpfSh0LGUpfX19c3RhdGljIGZyb21Qcm90byh0KXtpZighdCl0aHJvdyBuZXcgRXJyb3IoXCJjYW5ub3QgY29uc3RydWN0IFZhbHVlIGZyb20gYW4gZW1wdHkgdGVuc29yXCIpO2NvbnN0IGU9dS5Qcm90b1V0aWwudGVuc29yRGF0YVR5cGVGcm9tUHJvdG8odC5kYXRhVHlwZSksbj11LlByb3RvVXRpbC50ZW5zb3JEaW1zRnJvbVByb3RvKHQuZGltcykscj1uZXcgbChuLGUpO2lmKFwic3RyaW5nXCI9PT1lKXQuc3RyaW5nRGF0YS5mb3JFYWNoKCgodCxlKT0+e3IuZGF0YVtlXT0oMCx1LmRlY29kZVV0ZjhTdHJpbmcpKHQpfSkpO2Vsc2UgaWYodC5yYXdEYXRhJiZcIm51bWJlclwiPT10eXBlb2YgdC5yYXdEYXRhLmJ5dGVMZW5ndGgmJnQucmF3RGF0YS5ieXRlTGVuZ3RoPjApe2NvbnN0IGU9ci5kYXRhLG49bmV3IERhdGFWaWV3KHQucmF3RGF0YS5idWZmZXIsdC5yYXdEYXRhLmJ5dGVPZmZzZXQsdC5yYXdEYXRhLmJ5dGVMZW5ndGgpLGk9cCh0LmRhdGFUeXBlKSxvPXQucmF3RGF0YS5ieXRlTGVuZ3RoL2k7aWYodC5yYXdEYXRhLmJ5dGVMZW5ndGglaSE9MCl0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGJ1ZmZlciBsZW5ndGhcIik7aWYoZS5sZW5ndGghPT1vKXRocm93IG5ldyBFcnJvcihcImJ1ZmZlciBsZW5ndGggbWlzbWF0Y2hcIik7Zm9yKGxldCByPTA7cjxvO3IrKyl7Y29uc3Qgbz1oKG4sdC5kYXRhVHlwZSxyKmkpO2Vbcl09b319ZWxzZXtsZXQgZTtzd2l0Y2godC5kYXRhVHlwZSl7Y2FzZSBhLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuRkxPQVQ6ZT10LmZsb2F0RGF0YTticmVhaztjYXNlIGEub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5JTlQzMjpjYXNlIGEub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5JTlQxNjpjYXNlIGEub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5VSU5UMTY6Y2FzZSBhLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuSU5UODpjYXNlIGEub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5VSU5UODpjYXNlIGEub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5CT09MOmU9dC5pbnQzMkRhdGE7YnJlYWs7Y2FzZSBhLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuSU5UNjQ6ZT10LmludDY0RGF0YTticmVhaztjYXNlIGEub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5ET1VCTEU6ZT10LmRvdWJsZURhdGE7YnJlYWs7Y2FzZSBhLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuVUlOVDMyOmNhc2UgYS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLlVJTlQ2NDplPXQudWludDY0RGF0YTticmVhaztkZWZhdWx0OnRocm93IG5ldyBFcnJvcihcInVuc3BlY2lmaWMgZXJyb3JcIil9aWYobnVsbD09ZSl0aHJvdyBuZXcgRXJyb3IoXCJmYWlsZWQgdG8gcG9wdWxhdGUgZGF0YSBmcm9tIGEgdGVuc29ycHJvdG8gdmFsdWVcIik7Y29uc3Qgbj1yLmRhdGE7aWYobi5sZW5ndGghPT1lLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJhcnJheSBsZW5ndGggbWlzbWF0Y2hcIik7Zm9yKGxldCByPTA7cjxlLmxlbmd0aDtyKyspe2NvbnN0IGk9ZVtyXTtvLmRlZmF1bHQuaXNMb25nKGkpP25bcl09ZChpLHQuZGF0YVR5cGUpOm5bcl09aX19cmV0dXJuIHJ9c3RhdGljIGZyb21EYXRhKHQsZSxuKXtyZXR1cm4gbmV3IGwoZSxuLHZvaWQgMCx2b2lkIDAsdCl9c3RhdGljIGZyb21PcnRUZW5zb3IodCl7aWYoIXQpdGhyb3cgbmV3IEVycm9yKFwiY2Fubm90IGNvbnN0cnVjdCBWYWx1ZSBmcm9tIGFuIGVtcHR5IHRlbnNvclwiKTtjb25zdCBlPXUuUHJvdG9VdGlsLnRlbnNvckRpbXNGcm9tT1JURm9ybWF0KHQpLG49dS5Qcm90b1V0aWwudGVuc29yRGF0YVR5cGVGcm9tUHJvdG8odC5kYXRhVHlwZSgpKSxyPW5ldyBsKGUsbik7aWYoXCJzdHJpbmdcIj09PW4pZm9yKGxldCBlPTA7ZTx0LnN0cmluZ0RhdGFMZW5ndGgoKTtlKyspci5kYXRhW2VdPXQuc3RyaW5nRGF0YShlKTtlbHNlIGlmKHQucmF3RGF0YUFycmF5KCkmJlwibnVtYmVyXCI9PXR5cGVvZiB0LnJhd0RhdGFMZW5ndGgoKSYmdC5yYXdEYXRhTGVuZ3RoKCk+MCl7Y29uc3QgZT1yLmRhdGEsbj1uZXcgRGF0YVZpZXcodC5yYXdEYXRhQXJyYXkoKS5idWZmZXIsdC5yYXdEYXRhQXJyYXkoKS5ieXRlT2Zmc2V0LHQucmF3RGF0YUxlbmd0aCgpKSxpPXAodC5kYXRhVHlwZSgpKSxvPXQucmF3RGF0YUxlbmd0aCgpL2k7aWYodC5yYXdEYXRhTGVuZ3RoKCklaSE9MCl0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGJ1ZmZlciBsZW5ndGhcIik7aWYoZS5sZW5ndGghPT1vKXRocm93IG5ldyBFcnJvcihcImJ1ZmZlciBsZW5ndGggbWlzbWF0Y2hcIik7Zm9yKGxldCByPTA7cjxvO3IrKyl7Y29uc3Qgbz1oKG4sdC5kYXRhVHlwZSgpLHIqaSk7ZVtyXT1vfX1yZXR1cm4gcn19ZnVuY3Rpb24gcCh0KXtzd2l0Y2godCl7Y2FzZSBhLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuVUlOVDg6Y2FzZSBhLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuSU5UODpjYXNlIGEub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5CT09MOnJldHVybiAxO2Nhc2UgYS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLlVJTlQxNjpjYXNlIGEub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5JTlQxNjpyZXR1cm4gMjtjYXNlIGEub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5GTE9BVDpjYXNlIGEub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5JTlQzMjpjYXNlIGEub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5VSU5UMzI6cmV0dXJuIDQ7Y2FzZSBhLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuSU5UNjQ6Y2FzZSBhLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuRE9VQkxFOmNhc2UgYS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLlVJTlQ2NDpyZXR1cm4gODtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgY2Fubm90IGNhbGN1bGF0ZSBzaXplb2YoKSBvbiB0eXBlICR7YS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlW3RdfWApfX1mdW5jdGlvbiBmKHQpe3N3aXRjaCh0KXtjYXNlXCJib29sXCI6Y2FzZVwidWludDhcIjpyZXR1cm4gVWludDhBcnJheTtjYXNlXCJpbnQ4XCI6cmV0dXJuIEludDhBcnJheTtjYXNlXCJpbnQxNlwiOnJldHVybiBJbnQxNkFycmF5O2Nhc2VcInVpbnQxNlwiOnJldHVybiBVaW50MTZBcnJheTtjYXNlXCJpbnQzMlwiOnJldHVybiBJbnQzMkFycmF5O2Nhc2VcInVpbnQzMlwiOnJldHVybiBVaW50MzJBcnJheTtjYXNlXCJmbG9hdDMyXCI6cmV0dXJuIEZsb2F0MzJBcnJheTtjYXNlXCJmbG9hdDY0XCI6cmV0dXJuIEZsb2F0NjRBcnJheTtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihcInVuc3BlY2lmaWVkIGVycm9yXCIpfX1mdW5jdGlvbiBkKHQsZSl7aWYoZT09PWEub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5JTlQ2NHx8ZT09PWMuVGVuc29yRGF0YVR5cGUuSU5UNjQpe2lmKHQuZ3JlYXRlclRoYW5PckVxdWFsKDIxNDc0ODM2NDgpfHx0Lmxlc3NUaGFuKC0yMTQ3NDgzNjQ4KSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW50NjQgaXMgbm90IHN1cHBvcnRlZFwiKX1lbHNle2lmKGUhPT1hLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuVUlOVDMyJiZlIT09Yy5UZW5zb3JEYXRhVHlwZS5VSU5UMzImJmUhPT1hLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuVUlOVDY0JiZlIT09Yy5UZW5zb3JEYXRhVHlwZS5VSU5UNjQpdGhyb3cgbmV3IFR5cGVFcnJvcihgbm90IGEgTE9ORyB0eXBlOiAke2Eub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZVtlXX1gKTtpZih0LmdyZWF0ZXJUaGFuT3JFcXVhbCg0Mjk0OTY3Mjk2KXx8dC5sZXNzVGhhbigwKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwidWludDY0IGlzIG5vdCBzdXBwb3J0ZWRcIil9cmV0dXJuIHQudG9OdW1iZXIoKX1mdW5jdGlvbiBoKHQsZSxuKXtzd2l0Y2goZSl7Y2FzZSBhLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuQk9PTDpjYXNlIGEub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5VSU5UODpyZXR1cm4gdC5nZXRVaW50OChuKTtjYXNlIGEub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5JTlQ4OnJldHVybiB0LmdldEludDgobik7Y2FzZSBhLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuVUlOVDE2OnJldHVybiB0LmdldFVpbnQxNihuLCEwKTtjYXNlIGEub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5JTlQxNjpyZXR1cm4gdC5nZXRJbnQxNihuLCEwKTtjYXNlIGEub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5GTE9BVDpyZXR1cm4gdC5nZXRGbG9hdDMyKG4sITApO2Nhc2UgYS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLklOVDMyOnJldHVybiB0LmdldEludDMyKG4sITApO2Nhc2UgYS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLlVJTlQzMjpyZXR1cm4gdC5nZXRVaW50MzIobiwhMCk7Y2FzZSBhLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuSU5UNjQ6cmV0dXJuIGQoby5kZWZhdWx0LmZyb21CaXRzKHQuZ2V0VWludDMyKG4sITApLHQuZ2V0VWludDMyKG4rNCwhMCksITEpLGUpO2Nhc2UgYS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLkRPVUJMRTpyZXR1cm4gdC5nZXRGbG9hdDY0KG4sITApO2Nhc2UgYS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLlVJTlQ2NDpyZXR1cm4gZChvLmRlZmF1bHQuZnJvbUJpdHModC5nZXRVaW50MzIobiwhMCksdC5nZXRVaW50MzIobis0LCEwKSwhMCksZSk7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYGNhbm5vdCByZWFkIGZyb20gRGF0YVZpZXcgZm9yIHR5cGUgJHthLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGVbZV19YCl9fWUuVGVuc29yPWx9LDI1MTc6ZnVuY3Rpb24odCxlLG4pe1widXNlIHN0cmljdFwiO3ZhciByPXRoaXMmJnRoaXMuX19pbXBvcnREZWZhdWx0fHxmdW5jdGlvbih0KXtyZXR1cm4gdCYmdC5fX2VzTW9kdWxlP3Q6e2RlZmF1bHQ6dH19O09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUuZGVjb2RlVXRmOFN0cmluZz1lLk1BWF9DTElQPWUuTUlOX0NMSVA9ZS5Qb29sQ29udlV0aWw9ZS5SZWR1Y2VVdGlsPWUuU3BsaXRVdGlsPWUuTWF0aFV0aWw9ZS5TaGFwZVV0aWw9ZS5Mb25nVXRpbD1lLlByb3RvVXRpbD1lLkdlbW1VdGlsPWUuYXJyYXlDb3B5SGVscGVyPWUuQnJvYWRjYXN0VXRpbD1lLk1hdE11bFV0aWw9ZS5BcnJheVV0aWw9ZS5hc3NlcnQ9ZS5jaGVja0lucHV0c1NoYXBlPXZvaWQgMDtjb25zdCBpPW4oNTY4Niksbz1yKG4oMzcyMCkpLGE9bigxNDQ2KSxzPW4oOTE2Mik7ZS5jaGVja0lucHV0c1NoYXBlPWZ1bmN0aW9uKHQsLi4uZSl7aWYoIXR8fHQubGVuZ3RoIT09ZS5sZW5ndGgpcmV0dXJuITE7Zm9yKGxldCBuPTA7bjx0Lmxlbmd0aDtuKyspaWYoIXRbbl0uZGltc3x8dFtuXS5kaW1zLmxlbmd0aCE9PWVbbl0pcmV0dXJuITE7cmV0dXJuITB9LGUuYXNzZXJ0PWZ1bmN0aW9uKHQsZSl7aWYoIXQpdGhyb3cgbmV3IEVycm9yKFwic3RyaW5nXCI9PXR5cGVvZiBlP2U6ZSgpKX0sZS5BcnJheVV0aWw9Y2xhc3N7c3RhdGljIGFycmF5c0VxdWFsKHQsZSl7aWYodC5sZW5ndGghPT1lLmxlbmd0aClyZXR1cm4hMTtmb3IobGV0IG49MDtuPHQubGVuZ3RoO24rKylpZih0W25dIT09ZVtuXSlyZXR1cm4hMTtyZXR1cm4hMH19O2NsYXNzIHV7c3RhdGljIHByZXByb2Nlc3NJbnB1dFNoYXBlcyh0LGUpe3JldHVyblsxPT09dC5sZW5ndGg/WzEsdFswXV06dCwxPT09ZS5sZW5ndGg/W2VbMF0sMV06ZV19c3RhdGljIHBvc3Rwcm9jZXNzT3V0cHV0U2hhcGUodCxlLG4pezE9PT1lJiZ0LnNwbGljZSh0Lmxlbmd0aC0yLDEpLDE9PT1uJiZ0LnBvcCgpfXN0YXRpYyBjYWxjTWF0TXVsU2hhcGUodCxlKXtyZXR1cm4gdFsxXSE9PWVbMF0/dm9pZCAwOlt0WzBdLGVbMV1dfX1lLk1hdE11bFV0aWw9dTtjbGFzcyBje3N0YXRpYyBjYWxjU2hhcGUodCxlLG49ITEpe2NvbnN0IHI9dC5sZW5ndGgsaT1lLmxlbmd0aDtpZigwPT09cilyZXR1cm4gZTtpZigwPT09aSlyZXR1cm4gdDtjb25zdCBvPU1hdGgubWF4KHQubGVuZ3RoLGUubGVuZ3RoKSxhPW5ldyBBcnJheShvKTtpZihuKXtpZihyPDJ8fGk8MilyZXR1cm47Y29uc3Qgbj11LmNhbGNNYXRNdWxTaGFwZShbdFtyLTJdLHRbci0xXV0sW2VbaS0yXSxlW2ktMV1dKTtpZih2b2lkIDA9PT1uKXJldHVybjtbYVtvLTJdLGFbby0xXV09bn1mb3IobGV0IHM9bj8zOjE7czw9bztzKyspe2NvbnN0IG49ci1zPDA/MTp0W3Itc10sdT1pLXM8MD8xOmVbaS1zXTtpZihuIT09dSYmbj4xJiZ1PjEpcmV0dXJuO2Fbby1zXT1NYXRoLm1heChuLHUpfXJldHVybiBhfXN0YXRpYyBpbmRleCh0LGUpe2NvbnN0IG49bmV3IEFycmF5KGUubGVuZ3RoKTtyZXR1cm4gYy5maWxsSW5kZXgodCxlLG4pLG59c3RhdGljIGZpbGxJbmRleCh0LGUsbil7Y29uc3Qgcj10Lmxlbmd0aC1lLmxlbmd0aDtmb3IobGV0IGk9MDtpPGUubGVuZ3RoO2krKyluW2ldPXRbcitpXSVlW2ldfXN0YXRpYyBjYWxjKHQsZSxuLHIsaSl7Y29uc3Qgbz1jLmNhbGNTaGFwZSh0LmRpbXMsZS5kaW1zKTtpZihvKXtpZihyJiYhZi5hcmVFcXVhbChvLHQuZGltcykpcmV0dXJuO2NvbnN0IGE9Zi5zaXplKG8pLHU9cj90Om5ldyBzLlRlbnNvcihvLGl8fHQudHlwZSk7aWYoMD09PW8ubGVuZ3RoKXUuc2V0KFtdLG4odC5nZXQoW10pLGUuZ2V0KFtdKSkpO2Vsc2V7Y29uc3Qgcj1uZXcgQXJyYXkoby5sZW5ndGgpLGk9bmV3IEFycmF5KHQuZGltcy5sZW5ndGgpLHM9bmV3IEFycmF5KGUuZGltcy5sZW5ndGgpO2xldCBsLHA9MCxmPTAsZD0hMSxoPSExOzA9PT10LmRpbXMubGVuZ3RoJiYocD10LmdldChbXSksZD0hMCksMD09PWUuZGltcy5sZW5ndGgmJihmPWUuZ2V0KFtdKSxoPSEwKTtmb3IobGV0IGc9MDtnPGE7ZysrKXtsPWc7Zm9yKGxldCB0PW8ubGVuZ3RoLTE7dD49MDt0LS0pclt0XT1sJW9bdF0sbD1NYXRoLmZsb29yKGwvb1t0XSk7ZHx8KGMuZmlsbEluZGV4KHIsdC5kaW1zLGkpLHA9dC5nZXQoaSkpLGh8fChjLmZpbGxJbmRleChyLGUuZGltcyxzKSxmPWUuZ2V0KHMpKSx1LnNldChyLG4ocCxmKSl9fXJldHVybiB1fX1zdGF0aWMgaXNWYWxpZEJyb2FkY2FzdCh0LGUpe2NvbnN0IG49dC5sZW5ndGgscj1lLmxlbmd0aDtpZihuPnIpcmV0dXJuITE7Zm9yKGxldCBpPTE7aTw9bjtpKyspaWYoMSE9PXRbbi1pXSYmdFtuLWldIT09ZVtyLWldKXJldHVybiExO3JldHVybiEwfXN0YXRpYyBnZXRCcm9hZGNhc3REaW1zKHQsZSl7Y29uc3Qgbj10Lmxlbmd0aCxyPVtdO2ZvcihsZXQgaT0wO2k8bjtpKyspe2NvbnN0IG89bi0xLWksYT10W29dfHwxOyhlW2UubGVuZ3RoLTEtaV18fDEpPjEmJjE9PT1hJiZyLnVuc2hpZnQobyl9cmV0dXJuIHJ9fWUuQnJvYWRjYXN0VXRpbD1jLGUuYXJyYXlDb3B5SGVscGVyPWZ1bmN0aW9uKHQsZSxuLHIsaSl7aWYocjwwfHxyPj1lLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJzb3VyY2VJbmRleCBvdXQgb2YgYm91bmRzXCIpO2lmKG48MHx8bj49dC5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwidGFyZ2V0SW5kZXggb3V0IG9mIGJvdW5kc1wiKTtpZihyK2k+ZS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwic291cmNlIGluZGljZXMgdG8gYmUgY29waWVkIGFyZSBvdXRzaWRlIGJvdW5kc1wiKTtpZihuK2k+dC5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwidGFyZ2V0IGFycmF5IGlzIHRvbyBzbWFsbCB0byBob2xkIHJlc3VsdFwiKTtmb3IobGV0IG89MDtvPGk7bysrKXRbbitvXT1lW3Irb119LGUuR2VtbVV0aWw9Y2xhc3N7c3RhdGljIGdldFNoYXBlT2ZHZW1tUmVzdWx0KHQsZSxuLHIsaSl7aWYoMiE9PXQubGVuZ3RofHwyIT09bi5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwic2hhcGUgbmVlZCB0byBiZSBvZiBzaXplIDJcIik7bGV0IG8sYSxzO2U/KG89dFsxXSxhPXRbMF0pOihvPXRbMF0sYT10WzFdKTtsZXQgdT0tMTtpZihyPyhzPW5bMF0sdT0xKToocz1uWzFdLHU9MCksblt1XSE9PWEpdGhyb3cgbmV3IEVycm9yKFwiZGltZW5zaW9uIG1pc21hdGNoXCIpO2lmKG88PTB8fHM8PTB8fGE8PTApdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBzaGFwZSBzcGVjaWZpZWRcIik7aWYoaSYmIWMuaXNWYWxpZEJyb2FkY2FzdChpLFtvLHNdKSl0aHJvdyBuZXcgRXJyb3IoXCJnZW1tOiBpbnZhbGlkIGJpYXMgc2hhcGUgZm9yIGJyb2FkY2FzdFwiKTtyZXR1cm5bbyxzLGFdfX07Y2xhc3MgbHtzdGF0aWMgdGVuc29yRGF0YVR5cGVGcm9tUHJvdG8odCl7c3dpdGNoKHQpe2Nhc2UgYS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLklOVDg6cmV0dXJuXCJpbnQ4XCI7Y2FzZSBhLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuVUlOVDg6cmV0dXJuXCJ1aW50OFwiO2Nhc2UgYS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLkJPT0w6cmV0dXJuXCJib29sXCI7Y2FzZSBhLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuSU5UMTY6cmV0dXJuXCJpbnQxNlwiO2Nhc2UgYS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLlVJTlQxNjpyZXR1cm5cInVpbnQxNlwiO2Nhc2UgYS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLklOVDMyOnJldHVyblwiaW50MzJcIjtjYXNlIGEub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5VSU5UMzI6cmV0dXJuXCJ1aW50MzJcIjtjYXNlIGEub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5GTE9BVDpyZXR1cm5cImZsb2F0MzJcIjtjYXNlIGEub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5ET1VCTEU6cmV0dXJuXCJmbG9hdDY0XCI7Y2FzZSBhLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuU1RSSU5HOnJldHVyblwic3RyaW5nXCI7Y2FzZSBhLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuSU5UNjQ6cmV0dXJuXCJpbnQzMlwiO2Nhc2UgYS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLlVJTlQ2NDpyZXR1cm5cInVpbnQzMlwiO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCBkYXRhIHR5cGU6ICR7YS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlW3RdfWApfX1zdGF0aWMgdGVuc29yRGF0YVR5cGVTdHJpbmdUb0VudW0odCl7c3dpdGNoKHQpe2Nhc2VcImludDhcIjpyZXR1cm4gYS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLklOVDg7Y2FzZVwidWludDhcIjpyZXR1cm4gYS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLlVJTlQ4O2Nhc2VcImJvb2xcIjpyZXR1cm4gYS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLkJPT0w7Y2FzZVwiaW50MTZcIjpyZXR1cm4gYS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLklOVDE2O2Nhc2VcInVpbnQxNlwiOnJldHVybiBhLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuVUlOVDE2O2Nhc2VcImludDMyXCI6cmV0dXJuIGEub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5JTlQzMjtjYXNlXCJ1aW50MzJcIjpyZXR1cm4gYS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLlVJTlQzMjtjYXNlXCJmbG9hdDMyXCI6cmV0dXJuIGEub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5GTE9BVDtjYXNlXCJmbG9hdDY0XCI6cmV0dXJuIGEub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5ET1VCTEU7Y2FzZVwic3RyaW5nXCI6cmV0dXJuIGEub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5TVFJJTkc7Y2FzZVwiaW50NjRcIjpyZXR1cm4gYS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLklOVDY0O2Nhc2VcInVpbnQ2NFwiOnJldHVybiBhLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuVUlOVDY0O2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCBkYXRhIHR5cGU6ICR7dH1gKX19c3RhdGljIHRlbnNvckRpbXNGcm9tUHJvdG8odCl7cmV0dXJuIHQubWFwKCh0PT5vLmRlZmF1bHQuaXNMb25nKHQpP3QudG9OdW1iZXIoKTp0KSl9c3RhdGljIHRlbnNvclZhbHVlVHlwZUZyb21Qcm90byh0KXtyZXR1cm57dGVuc29yVHlwZTpsLnRlbnNvckRhdGFUeXBlRnJvbVByb3RvKHQuZWxlbVR5cGUpLHNoYXBlOntkaW1zOmwudGVuc29yRGltc0Zyb21Qcm90byh0LnNoYXBlLmRpbS5tYXAoKHQ9PnQuZGltVmFsdWUpKSl9fX1zdGF0aWMgdGVuc29yRGltc0Zyb21PUlRGb3JtYXQodCl7Y29uc3QgZT1bXTtmb3IobGV0IG49MDtuPHQuZGltc0xlbmd0aCgpO24rKyllLnB1c2gocC5sb25nVG9OdW1iZXIodC5kaW1zKG4pKSk7cmV0dXJuIGV9c3RhdGljIHRlbnNvckF0dHJpYnV0ZXNGcm9tT1JURm9ybWF0KHQpe2NvbnN0IGU9W107Zm9yKGxldCBuPTA7bjx0LmF0dHJpYnV0ZXNMZW5ndGgoKTtuKyspZS5wdXNoKHQuYXR0cmlidXRlcyhuKSk7cmV0dXJuIGV9fWUuUHJvdG9VdGlsPWw7Y2xhc3MgcHtzdGF0aWMgbG9uZ1RvTnVtYmVyKHQsZSl7cmV0dXJuIG8uZGVmYXVsdC5pc0xvbmcodCk/dC50b051bWJlcigpOnQgaW5zdGFuY2VvZiBpLmZsYXRidWZmZXJzLkxvbmc/by5kZWZhdWx0LmZyb21WYWx1ZSh7bG93OnQubG93LGhpZ2g6dC5oaWdoLHVuc2lnbmVkOm51bGwhPWUmJmV9KS50b051bWJlcigpOnR9c3RhdGljIGlzTG9uZyh0KXtyZXR1cm4gby5kZWZhdWx0LmlzTG9uZyh0KXx8dCBpbnN0YW5jZW9mIGkuZmxhdGJ1ZmZlcnMuTG9uZ319ZS5Mb25nVXRpbD1wO2NsYXNzIGZ7c3RhdGljIHNpemUodCl7cmV0dXJuIGYuZ2V0U2l6ZUZyb21EaW1lbnNpb25SYW5nZSh0LDAsdC5sZW5ndGgpfXN0YXRpYyBzaXplRnJvbURpbWVuc2lvbih0LGUpe2lmKGU8MHx8ZT50Lmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgZGltZW5zaW9uIG9mICR7ZX0gZm9yIHNpemVGcm9tRGltZW5zaW9uIGFzIFRlbnNvciBoYXMgJHt0Lmxlbmd0aH0gZGltZW5zaW9ucy5gKTtyZXR1cm4gZi5nZXRTaXplRnJvbURpbWVuc2lvblJhbmdlKHQsZSx0Lmxlbmd0aCl9c3RhdGljIHNpemVUb0RpbWVuc2lvbih0LGUpe2lmKGU8MHx8ZT50Lmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgZGltZW5zaW9uIG9mICR7ZX0gZm9yIHNpemVUb0RpbWVuc2lvbiBhcyBUZW5zb3IgaGFzICR7dC5sZW5ndGh9IGRpbWVuc2lvbnMuYCk7cmV0dXJuIGYuZ2V0U2l6ZUZyb21EaW1lbnNpb25SYW5nZSh0LDAsZSl9c3RhdGljIGdldFNpemVGcm9tRGltZW5zaW9uUmFuZ2UodCxlLG4pe2xldCByPTE7Zm9yKGxldCBpPWU7aTxuO2krKyl7aWYodFtpXTw9MCl0aHJvdyBuZXcgRXJyb3IoXCJjYW5ub3QgZ2V0IHZhbGlkIHNpemUgZnJvbSBzcGVjaWZpZWQgZGltZW5zaW9uIHJhbmdlLiBNb3N0IGxpa2VseSB0aGUgcmFuZ2UgY29udGFpbnMgMCBvciBuZWdhdGl2ZSB2YWx1ZXMgaW4gdGhlbS5cIik7cio9dFtpXX1yZXR1cm4gcn1zdGF0aWMgY29tcHV0ZVN0cmlkZXModCl7Y29uc3QgZT10Lmxlbmd0aDtpZigwPT09ZSlyZXR1cm5bXTtpZigxPT09ZSlyZXR1cm5bMV07Y29uc3Qgbj1uZXcgQXJyYXkoZSk7bltlLTFdPTEsbltlLTJdPXRbZS0xXTtmb3IobGV0IHI9ZS0zO3I+PTA7LS1yKW5bcl09bltyKzFdKnRbcisxXTtyZXR1cm4gbn1zdGF0aWMgdHJhbnNwb3NlKHQpe3JldHVybiB0LnNsaWNlKCkucmV2ZXJzZSgpfXN0YXRpYyBpbmRpY2VzVG9PZmZzZXQodCxlLG4pe3ZvaWQgMD09PW4mJihuPXQubGVuZ3RoKTtsZXQgcj0wO2ZvcihsZXQgaT0wO2k8bjsrK2kpcis9ZVtpXSp0W2ldO3JldHVybiByfXN0YXRpYyBvZmZzZXRUb0luZGljZXModCxlKXtjb25zdCBuPWUubGVuZ3RoO2lmKDA9PT1uKXJldHVybltdO2lmKDE9PT1uKXJldHVyblt0KmVbMF1dO2NvbnN0IHI9bmV3IEFycmF5KGUubGVuZ3RoKTtmb3IobGV0IG49MDtuPHIubGVuZ3RoLTE7KytuKXJbbl09TWF0aC5mbG9vcih0L2Vbbl0pLHQtPXJbbl0qZVtuXTtyZXR1cm4gcltyLmxlbmd0aC0xXT10LHJ9c3RhdGljIG5vcm1hbGl6ZUF4aXModCxlKXtpZih0PC1lJiZ0Pj1lKXRocm93IG5ldyBFcnJvcihcInVuc3VwcG9ydGVkIGF4aXMgZm9yIHRoaXMgb3BlcmF0aW9uLlwiKTtyZXR1cm4gdDwwP3QrZTp0fXN0YXRpYyBub3JtYWxpemVBeGVzKHQsZSl7cmV0dXJuIHQubWFwKCh0PT50aGlzLm5vcm1hbGl6ZUF4aXModCxlKSkpfXN0YXRpYyBpbmNyZW1lbnRJbmRleCh0LGUsbil7aWYoMD09PWUubGVuZ3RofHwwPT09dC5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiSW5kZXggaW5jcmVtZW50aW5nIHVuc3VwcG9ydGVkIGZvciBzY2FsYXIgVGVuc29yXCIpO2lmKHZvaWQgMD09PW4pbj1lLmxlbmd0aDtlbHNlIGlmKG48PTB8fG4+ZS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiSW5jb3JyZWN0IGF4aXMgdG8gaW5jcmVtZW50IG9uXCIpO2ZvcihsZXQgcj1uLTE7cj49MCYmKHRbcl0rKywhKHRbcl08ZVtyXSkpOy0tcil0W3JdPTB9c3RhdGljIGNhbGN1bGF0ZVJlc2hhcGVkRGltcyh0LGUpe2lmKDA9PT1lLmxlbmd0aCl7aWYoMD09PXQubGVuZ3RofHwxPT09Zi5zaXplKHQpKXJldHVybltdO3Rocm93IG5ldyBFcnJvcihcImNhbm5vdCByZXNoYXBlIHRvIGEgc2NhbGFyIFRlbnNvclwiKX1jb25zdCBuPWUubGVuZ3RoLHI9bmV3IEFycmF5KG4pO2xldCBpPS0xLG89MTtmb3IobGV0IGE9MDthPG47YSsrKXtpZihlW2FdPC0xKXRocm93IG5ldyBFcnJvcihcImEgZGltZW5zaW9uIGluIHNoYXBlIGhpbnRzIGNhbm5vdCBiZSBsZXNzIHRoYW4gLTFcIik7aWYoLTE9PT1lW2FdKXtpZigtMSE9PWkpdGhyb3cgbmV3IEVycm9yKFwiYXQgbW9zdCBvbmUgZGltZW5zaW9uIGluIHNoYXBlIGhpbnRzIGNhbiBiZSAtMVwiKTtpPWF9ZWxzZXtpZigwPT09ZVthXSl7aWYoYT49dC5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwidGhlIGRpbWVuc2lvbiB3aXRoIHZhbHVlIHplcm8gZXhjZWVkcyB0aGUgZGltZW5zaW9uIHNpemUgb2YgdGhlIGlucHV0IHRlbnNvclwiKTtyW2FdPXRbYV19ZWxzZSByW2FdPWVbYV07byo9clthXX19Y29uc3QgYT1mLnNpemUodCk7aWYoLTEhPT1pKXtpZihhJW8hPTApdGhyb3cgbmV3IEVycm9yKGB0aGUgaW5wdXQgdGVuc29yIGNhbm5vdCBiZSByZXNoYXBlZCB0byB0aGUgcmVxdWVzdGVkIHNoYXBlLiBJbnB1dCBzaGFwZTogWyR7dH1dIE91dHB1dCBzaGFwZTogWyR7ZX1dYCk7cltpXT1hL299ZWxzZSBpZihvIT09YSl0aHJvdyBuZXcgRXJyb3IoXCJyZXNoYXBlZERpbXMgYW5kIG9yaWdpbmFsRGltcyBkb24ndCBoYXZlIG1hdGNoaW5nIHNpemVzXCIpO3JldHVybiByfXN0YXRpYyBzb3J0QmFzZWRPblBlcm0odCxlKXtyZXR1cm4gZT9lLm1hcCgoZT0+dFtlXSkpOnQuc2xpY2UoKS5yZXZlcnNlKCl9c3RhdGljIHBhZFNoYXBlKHQsZSl7Y29uc3Qgbj10Lmxlbmd0aDtyZXR1cm4gdC5tYXAoKCh0LHIpPT50K2Vbcl0rZVtyK25dKSl9c3RhdGljIGFyZUVxdWFsKHQsZSl7cmV0dXJuIHQubGVuZ3RoPT09ZS5sZW5ndGgmJnQuZXZlcnkoKCh0LG4pPT50PT09ZVtuXSkpfXN0YXRpYyB2YWxpZGF0ZURpbXNBbmRDYWxjU2l6ZSh0KXtpZih0Lmxlbmd0aD42KXRocm93IG5ldyBUeXBlRXJyb3IoXCJPbmx5IHJhbmsgMCB0byA2IGlzIHN1cHBvcnRlZCBmb3IgdGVuc29yIHNoYXBlLlwiKTtsZXQgZT0xO2Zvcihjb25zdCBuIG9mIHQpe2lmKCFOdW1iZXIuaXNJbnRlZ2VyKG4pKXRocm93IG5ldyBUeXBlRXJyb3IoYEludmFsaWQgc2hhcGU6ICR7bn0gaXMgbm90IGFuIGludGVnZXJgKTtpZihuPDB8fG4+MjE0NzQ4MzY0Nyl0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkIHNoYXBlOiBsZW5ndGggJHtufSBpcyBub3QgYWxsb3dlZGApO2UqPW59cmV0dXJuIGV9c3RhdGljIGZsYXR0ZW5TaGFwZSh0LGUpe2U8MCYmKGUrPXQubGVuZ3RoKTtjb25zdCBuPXQucmVkdWNlKCgodCxlKT0+dCplKSwxKSxyPXQuc2xpY2UoZSkucmVkdWNlKCgodCxlKT0+dCplKSwxKTtyZXR1cm5bbi9yLHJdfXN0YXRpYyBzcXVlZXplU2hhcGUodCxlKXtjb25zdCBuPW5ldyBBcnJheTtlPWYubm9ybWFsaXplQXhlcyhlLHQubGVuZ3RoKTtmb3IobGV0IHI9MDtyPHQubGVuZ3RoO3IrKyl7Y29uc3QgaT1lLmluZGV4T2Yocik+PTA7aWYoaSYmMSE9PXRbcl0pdGhyb3cgbmV3IEVycm9yKFwic3F1ZWV6ZSBhbiBheGlzIG9mIHNpemUgZGlmZmVyZW50IHRoYW4gMVwiKTsoMD09PWUubGVuZ3RoJiZ0W3JdPjF8fGUubGVuZ3RoPjAmJiFpKSYmbi5wdXNoKHRbcl0pfXJldHVybiBufXN0YXRpYyB1bnNxdWVlemVTaGFwZSh0LGUpe2NvbnN0IG49bmV3IEFycmF5KHQubGVuZ3RoK2UubGVuZ3RoKTtuLmZpbGwoMCk7Zm9yKGxldCB0PTA7dDxlLmxlbmd0aDt0Kyspe2NvbnN0IHI9Zi5ub3JtYWxpemVBeGlzKGVbdF0sbi5sZW5ndGgpO2lmKHI+PW4ubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIidheGVzJyBoYXMgYW4gb3V0IG9mIHJhbmdlIGF4aXNcIik7aWYoMCE9PW5bcl0pdGhyb3cgbmV3IEVycm9yKFwiJ2F4ZXMnIGhhcyBhIGR1cGxpY2F0ZSBheGlzXCIpO25bcl09MX1sZXQgcj0wO2ZvcihsZXQgZT0wO2U8bi5sZW5ndGg7ZSsrKTA9PT1uW2VdJiYobltlXT10W3IrK10pO2lmKHIhPT10Lmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJ0aGUgdW5zcXVlZXplZCBkaW1lbnNpb24gY291bGQgbm90IGJlIGVzdGFibGlzaGVkXCIpO3JldHVybiBufX1lLlNoYXBlVXRpbD1mLGUuTWF0aFV0aWw9Y2xhc3N7c3RhdGljIHNxcih0LGUsbixyLGkpe2lmKHI8MHx8cj49ZS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwic291cmNlSW5kZXggb3V0IG9mIGJvdW5kc1wiKTtpZihuPDB8fG4+PXQubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcInRhcmdldEluZGV4IG91dCBvZiBib3VuZHNcIik7aWYocitpPmUubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcInNvdXJjZSBpbmRpY2VzIHRvIGJlIGNvcGllZCBhcmUgb3V0c2lkZSBib3VuZHNcIik7aWYobitpPnQubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcInRhcmdldCBhcnJheSBpcyB0b28gc21hbGwgdG8gaG9sZCByZXN1bHRcIik7Zm9yKGxldCBvPTA7bzxpO28rKyl0W24rb10rPU1hdGgucG93KGVbcitvXSwyKX1zdGF0aWMgYXhweSh0LGUsbixyLGksbyl7aWYocjwwfHxyPj1lLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJzb3VyY2VJbmRleCBvdXQgb2YgYm91bmRzXCIpO2lmKG48MHx8bj49dC5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwidGFyZ2V0SW5kZXggb3V0IG9mIGJvdW5kc1wiKTtpZihyK2k+ZS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwic291cmNlIGluZGljZXMgdG8gYmUgY29waWVkIGFyZSBvdXRzaWRlIGJvdW5kc1wiKTtpZihuK2k+dC5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwidGFyZ2V0IGFycmF5IGlzIHRvbyBzbWFsbCB0byBob2xkIHJlc3VsdFwiKTtmb3IobGV0IGE9MDthPGk7YSsrKXRbbithXSs9byplW3IrYV19c3RhdGljIHBvd3godCxlLG4scixpLG8pe2lmKHI8MHx8cj49ZS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwic291cmNlSW5kZXggb3V0IG9mIGJvdW5kc1wiKTtpZihuPDB8fG4+PXQubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcInRhcmdldEluZGV4IG91dCBvZiBib3VuZHNcIik7aWYocitpPmUubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcInNvdXJjZSBpbmRpY2VzIHRvIGJlIGNvcGllZCBhcmUgb3V0c2lkZSBib3VuZHNcIik7aWYobitpPnQubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcInRhcmdldCBhcnJheSBpcyB0b28gc21hbGwgdG8gaG9sZCByZXN1bHRcIik7Zm9yKGxldCBhPTA7YTxpO2ErKyl0W24rYV09TWF0aC5wb3coZVtyK2FdLG8pfXN0YXRpYyBtdWwodCxlLG4scixpKXtpZihyPDB8fHI+PWUubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcInNvdXJjZUluZGV4IG91dCBvZiBib3VuZHNcIik7aWYobjwwfHxuPj10Lmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJ0YXJnZXRJbmRleCBvdXQgb2YgYm91bmRzXCIpO2lmKHIraT5lLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJzb3VyY2UgaW5kaWNlcyB0byBiZSBjb3BpZWQgYXJlIG91dHNpZGUgYm91bmRzXCIpO2lmKG4raT50Lmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJ0YXJnZXQgYXJyYXkgaXMgdG9vIHNtYWxsIHRvIGhvbGQgcmVzdWx0XCIpO2ZvcihsZXQgbz0wO288aTtvKyspdFtuK29dPWVbcitvXSp0W24rb119fTtjbGFzcyBke3N0YXRpYyBzcGxpdFNoYXBlKHQsZSxuLHIpe2lmKDA9PT1uLmxlbmd0aCl7aWYoIXIpdGhyb3cgbmV3IEVycm9yKFwibmVlZCB0byBrbm93IG51bWJlciBvZiBvdXRwdXRzIHdoZW4gdGhlICdzcGxpdCcgYXR0cmlidXRlIGlzIG5vdCBzcGVjaWZpZWRcIik7ZC5kZXRlcm1pbmVTcGxpdCh0W2VdLHIsbil9Y29uc3QgaT1bXSxvPVswXTtmb3IobGV0IHI9MDtyPG4ubGVuZ3RoOysrcil7MCE9PXImJm8ucHVzaChvW3ItMV0rbltyLTFdKTtjb25zdCBhPXQuc2xpY2UoKTthW2VdPW5bcl0saS5wdXNoKGEpfXJldHVybltpLG9dfXN0YXRpYyBkZXRlcm1pbmVTcGxpdCh0LGUsbil7aWYodCVlIT0wKXRocm93IG5ldyBFcnJvcihcImNhbm5vdCBzcGxpdCB0ZW5zb3IgdG8gZXF1YWwgc2l6ZWQgcGFydHNcIik7Zm9yKGxldCByPTA7cjxlOysrciluLnB1c2godC9lKX19ZS5TcGxpdFV0aWw9ZDtjbGFzcyBoe3N0YXRpYyBjYWxjUmVkdWNlKHQsZSxuLHIsaSl7Y29uc3Qgbz10LmRpbXMuc2xpY2UoMCk7MD09PWUubGVuZ3RoJiZvLmZvckVhY2goKCh0LG4pPT5lLnB1c2gobikpKTtjb25zdCBhPWguY2FsY1JlZHVjZVNoYXBlKG8sZSwhMCksdT1mLnNpemUoYSksbD1uZXcgcy5UZW5zb3IoYSx0LnR5cGUpLHA9Zi5jb21wdXRlU3RyaWRlcyhhKSxkPWYuY29tcHV0ZVN0cmlkZXMobyksZz1uZXcgQXJyYXkoby5sZW5ndGgpO2ZvcihsZXQgbj0wO248dTtuKyspe2NvbnN0IGE9Zi5vZmZzZXRUb0luZGljZXMobixwKTtjLmZpbGxJbmRleChhLG8sZyksbC5zZXQoYSxoLmNhbGNSZWR1Y2VCeUF4aXModC5udW1iZXJEYXRhLGUsbywwLGYuaW5kaWNlc1RvT2Zmc2V0KGcsZCkscixpKSl9cmV0dXJuIG4/bDpuZXcgcy5UZW5zb3IoaC5jYWxjUmVkdWNlU2hhcGUobyxlLG4pLGwudHlwZSx2b2lkIDAsdm9pZCAwLGwuZGF0YSxsLmRhdGFJZCl9c3RhdGljIGNhbGNSZWR1Y2VCeUF4aXModCxlLG4scixpLG8sYSl7bGV0IHM9MDtpZihyPj1lLmxlbmd0aClyZXR1cm4gbyh0W2ldKTtjb25zdCB1PWVbcl0sYz11Pj1uLmxlbmd0aD8xOmYuc2l6ZShuLnNsaWNlKHUrMSkpO2ZvcihsZXQgbD0wO2w8blt1XTtsKyspcz0wPT09bD9oLmNhbGNSZWR1Y2VCeUF4aXModCxlLG4scisxLGksbyxhKTphKHMsaC5jYWxjUmVkdWNlQnlBeGlzKHQsZSxuLHIrMSxpLG8sYSkpLGkrPWM7cmV0dXJuIHN9c3RhdGljIGNhbGNSZWR1Y2VTaGFwZSh0LGUsbil7Y29uc3Qgcj10LnNsaWNlKCk7Zm9yKGxldCB0PTA7dDxlLmxlbmd0aDt0KyspcltlW3RdXT1uPzE6MDtyZXR1cm4gci5maWx0ZXIoKHQ9PjAhPT10KSl9fWUuUmVkdWNlVXRpbD1oO2NsYXNzIGd7c3RhdGljIGFkanVzdFBvb2xBdHRyaWJ1dGVzKHQsZSxuLHIsaSxvKXtpZighdCYmbi5sZW5ndGghPT1lLmxlbmd0aC0yKXRocm93IG5ldyBFcnJvcihcImxlbmd0aCBvZiBzcGVjaWZpZWQga2VybmVsIHNoYXBlcyBzaG91bGQgYmUgMiBsZXNzIHRoYW4gbGVuZ3RoIG9mIGlucHV0IGRpbWVuc2lvbnNcIik7aWYodClmb3IobGV0IHQ9MDt0PGUubGVuZ3RoLTI7dCsrKXQ+PW4ubGVuZ3RoP24ucHVzaChlW3QrMl0pOm5bdF09ZVt0KzJdO2ZvcihsZXQgdD0wO3Q8bi5sZW5ndGg7dCsrKWlmKHQ8ci5sZW5ndGgpe2lmKHJbdF08MCl0aHJvdyBuZXcgRXJyb3IoXCJzdHJpZGVzIHNob3VsZCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMVwiKX1lbHNlIHIucHVzaCgxKTtmb3IobGV0IHQ9MDt0PG4ubGVuZ3RoO3QrKylpZih0PGkubGVuZ3RoKXtpZihpW3RdPDApdGhyb3cgbmV3IEVycm9yKFwiZGlsYXRpb25zIHNob3VsZCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMVwiKX1lbHNlIGkucHVzaCgxKTtmb3IobGV0IHQ9MDt0PDIqbi5sZW5ndGg7dCsrKWlmKHQ8by5sZW5ndGgpe2lmKG9bdF08MCl0aHJvdyBuZXcgRXJyb3IoXCJwYWQgc2hvdWxkIGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAxXCIpfWVsc2Ugby5wdXNoKDApO2ZvcihsZXQgdD0wO3Q8bi5sZW5ndGg7dCsrKXtpZihuW3RdPD0wKXRocm93IG5ldyBFcnJvcihcImtlcm5lbCBzaGFwZXMgbmVlZCB0byBiZSBncmVhdGVyIHRoYW4gMFwiKTtpZihvW3RdPj1uW3RdfHxvW3Qrbi5sZW5ndGhdPj1uW3RdKXRocm93IG5ldyBFcnJvcihcInBhZHMgc2hvdWxkIGJlIHNtYWxsZXIgdGhhbiBrZXJuZWxcIil9fXN0YXRpYyBhZGp1c3RQYWRzQmFzZWRPbkF1dG9QYWQodCxlLG4scixpLG8pe2lmKG8pe2lmKGkubGVuZ3RoIT09MioodC5sZW5ndGgtMikpdGhyb3cgbmV3IEVycm9yKFwibGVuZ3RoIG9mIHBhZHMgc2hvdWxkIGJlIHR3aWNlIHRoZSBsZW5ndGggb2YgZGF0YSBkaW1lbnNpb25zXCIpO2lmKGUubGVuZ3RoIT09dC5sZW5ndGgtMil0aHJvdyBuZXcgRXJyb3IoXCJsZW5ndGggb2Ygc3RyaWRlcyBzaG91bGQgYmUgdGhlIGxlbmd0aCBvZiBkYXRhIGRpbWVuc2lvbnNcIik7aWYoci5sZW5ndGghPT10Lmxlbmd0aC0yKXRocm93IG5ldyBFcnJvcihcImxlbmd0aCBvZiBrZXJuZWwgc2hhcGVzIHNob3VsZCBiZSB0aGUgbGVuZ3RoIG9mIGRhdGEgZGltZW5zaW9uc1wiKTtmb3IobGV0IGE9MDthPHQubGVuZ3RoLTI7YSsrKWcuYWRqdXN0UGFkQW5kUmV0dXJuU2hhcGUodFthKzJdLGVbYV0sblthXSxyW2FdLGksYSxhK3QubGVuZ3RoLTIsbyl9fXN0YXRpYyBjb21wdXRlUG9vbE91dHB1dFNoYXBlKHQsZSxuLHIsaSxvLGEpe2lmKGUubGVuZ3RoPD0wKXRocm93IG5ldyBFcnJvcihcImlucHV0IHNoYXBlIG11c3QgYmUgb2Ygc2l6ZSBncmVhdGVyIHRoYW4gMFwiKTtjb25zdCBzPVtlWzBdLGVbMV1dO3JldHVybiBnLmNvbXB1dGVTaGFwZUhlbHBlcih0LGUscyxuLHIsaSxvLGEpLHN9c3RhdGljIGNvbXB1dGVDb252T3V0cHV0U2hhcGUodCxlLG4scixpLG8sYSl7aWYodC5sZW5ndGg8PTB8fGUubGVuZ3RoPD0wKXRocm93IG5ldyBFcnJvcihcImludmFsaWQgaW5wdXQgdGVuc29yIGRpbXMgb3IgaW52YWxpZCBmaWx0ZXIgdGVuc29yIGRpbXNcIik7Y29uc3Qgcz1bdFswXSxlWzBdXTtyZXR1cm4gZy5jb21wdXRlU2hhcGVIZWxwZXIoITEsdCxzLG4scixpLG8sYSksc31zdGF0aWMgY29tcHV0ZVNoYXBlSGVscGVyKHQsZSxuLHIsaSxvLGEscyl7aWYodClmb3IobGV0IHQ9MDt0PGUubGVuZ3RoLTI7dCsrKW4ucHVzaCgxKTtlbHNlIGZvcihsZXQgdD0wO3Q8ZS5sZW5ndGgtMjt0Kyspbi5wdXNoKGcuYWRqdXN0UGFkQW5kUmV0dXJuU2hhcGUoZVt0KzJdLHJbdF0saVt0XSxvW3RdLGEsdCx0K2UubGVuZ3RoLTIscykpfXN0YXRpYyBhZGp1c3RQYWRBbmRSZXR1cm5TaGFwZSh0LGUsbixyLGksbyxhLHMpe2NvbnN0IHU9biooci0xKSsxO2lmKCFzfHxcIk5PVFNFVFwiPT09cylyZXR1cm4gTWF0aC5mbG9vcigodCtpW29dK2lbYV0tdSkvZSsxKTtzd2l0Y2gocyl7Y2FzZVwiVkFMSURcIjpyZXR1cm4gaVtvXT0wLGlbYV09MCxNYXRoLmZsb29yKCh0LXUpL2UrMSk7Y2FzZVwiU0FNRV9MT1dFUlwiOmNhc2VcIlNBTUVfVVBQRVJcIjppZigxIT09bil0aHJvdyBuZXcgRXJyb3IoXCJEaWxhdGlvbiBub3Qgc3VwcG9ydGVkIGZvciBTQU1FX1VQUEVSIG9yIFNBTUVfTE9XRVJcIik7e2NvbnN0IG49KCh0K2UtMSkvZS0xKSplK3ItdDtyZXR1cm4gaVtvXT1cIlNBTUVfTE9XRVJcIj09PXM/TWF0aC5mbG9vcigobisxKS8yKTpNYXRoLmZsb29yKG4vMiksaVthXT1uLWlbb10sTWF0aC5mbG9vcigodCtuLXIpL2UrMSl9ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCBBdXRvUGFkIHR5cGVcIil9fX1lLlBvb2xDb252VXRpbD1nLGUuTUlOX0NMSVA9LTM0MDI4MjM0NjYzODUyODg2ZTIyLGUuTUFYX0NMSVA9MzQwMjgyMzQ2NjM4NTI4ODZlMjIsZS5kZWNvZGVVdGY4U3RyaW5nPWZ1bmN0aW9uKHQpe3JldHVybihuZXcgVGV4dERlY29kZXIpLmRlY29kZSh0KX19LDc5Njc6KHQsZSk9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLml0ZXJhdGVFeHRyYU9wdGlvbnM9dm9pZCAwLGUuaXRlcmF0ZUV4dHJhT3B0aW9ucz0odCxuLHIsaSk9PntpZihcIm9iamVjdFwiPT10eXBlb2YgdCYmbnVsbCE9PXQpe2lmKHIuaGFzKHQpKXRocm93IG5ldyBFcnJvcihcIkNpcmN1bGFyIHJlZmVyZW5jZSBpbiBvcHRpb25zXCIpO3IuYWRkKHQpfU9iamVjdC5lbnRyaWVzKHQpLmZvckVhY2goKChbdCxvXSk9Pntjb25zdCBhPW4/bit0OnQ7aWYoXCJvYmplY3RcIj09dHlwZW9mIG8pKDAsZS5pdGVyYXRlRXh0cmFPcHRpb25zKShvLGErXCIuXCIscixpKTtlbHNlIGlmKFwic3RyaW5nXCI9PXR5cGVvZiBvfHxcIm51bWJlclwiPT10eXBlb2YgbylpKGEsby50b1N0cmluZygpKTtlbHNle2lmKFwiYm9vbGVhblwiIT10eXBlb2Ygbyl0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBoYW5kbGUgZXh0cmEgY29uZmlnIHR5cGU6IFwiK3R5cGVvZiBvKTtpKGEsbz9cIjFcIjpcIjBcIil9fSkpfX0sMjE1NzpmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7dmFyIHIsaT10aGlzJiZ0aGlzLl9fY3JlYXRlQmluZGluZ3x8KE9iamVjdC5jcmVhdGU/ZnVuY3Rpb24odCxlLG4scil7dm9pZCAwPT09ciYmKHI9bik7dmFyIGk9T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLG4pO2kmJiEoXCJnZXRcImluIGk/IWUuX19lc01vZHVsZTppLndyaXRhYmxlfHxpLmNvbmZpZ3VyYWJsZSl8fChpPXtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBlW25dfX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LHIsaSl9OmZ1bmN0aW9uKHQsZSxuLHIpe3ZvaWQgMD09PXImJihyPW4pLHRbcl09ZVtuXX0pLG89dGhpcyYmdGhpcy5fX3NldE1vZHVsZURlZmF1bHR8fChPYmplY3QuY3JlYXRlP2Z1bmN0aW9uKHQsZSl7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJkZWZhdWx0XCIse2VudW1lcmFibGU6ITAsdmFsdWU6ZX0pfTpmdW5jdGlvbih0LGUpe3QuZGVmYXVsdD1lfSksYT10aGlzJiZ0aGlzLl9faW1wb3J0U3Rhcnx8ZnVuY3Rpb24odCl7aWYodCYmdC5fX2VzTW9kdWxlKXJldHVybiB0O3ZhciBlPXt9O2lmKG51bGwhPXQpZm9yKHZhciBuIGluIHQpXCJkZWZhdWx0XCIhPT1uJiZPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCxuKSYmaShlLHQsbik7cmV0dXJuIG8oZSx0KSxlfTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLmVuZFByb2ZpbGluZz1lLnJ1bj1lLnJlbGVhc2VTZXNzaW9uPWUuY3JlYXRlU2Vzc2lvbj1lLmNyZWF0ZVNlc3Npb25GaW5hbGl6ZT1lLmNyZWF0ZVNlc3Npb25BbGxvY2F0ZT1lLmluaXRPcnQ9ZS5pbml0V2FzbT12b2lkIDA7Y29uc3Qgcz1uKDYyMDcpLHU9YShuKDM0OSkpLGM9big2MzYxKSxsPSgpPT4hIXMuZW52Lndhc20ucHJveHkmJlwidW5kZWZpbmVkXCIhPXR5cGVvZiBkb2N1bWVudDtsZXQgcCxmLGQsaD0hMSxnPSExLGI9ITE7Y29uc3QgbT1bXSx5PVtdLF89W10sdj1bXSx3PVtdLHg9W10sVD0oKT0+e2lmKGh8fCFnfHxifHwhcCl0aHJvdyBuZXcgRXJyb3IoXCJ3b3JrZXIgbm90IHJlYWR5XCIpfSxTPXQ9Pntzd2l0Y2godC5kYXRhLnR5cGUpe2Nhc2VcImluaXQtd2FzbVwiOmg9ITEsdC5kYXRhLmVycj8oYj0hMCxmWzFdKHQuZGF0YS5lcnIpKTooZz0hMCxmWzBdKCkpO2JyZWFrO2Nhc2VcImluaXQtb3J0XCI6dC5kYXRhLmVycj9kWzFdKHQuZGF0YS5lcnIpOmRbMF0oKTticmVhaztjYXNlXCJjcmVhdGVfYWxsb2NhdGVcIjp0LmRhdGEuZXJyP20uc2hpZnQoKVsxXSh0LmRhdGEuZXJyKTptLnNoaWZ0KClbMF0odC5kYXRhLm91dCk7YnJlYWs7Y2FzZVwiY3JlYXRlX2ZpbmFsaXplXCI6dC5kYXRhLmVycj95LnNoaWZ0KClbMV0odC5kYXRhLmVycik6eS5zaGlmdCgpWzBdKHQuZGF0YS5vdXQpO2JyZWFrO2Nhc2VcImNyZWF0ZVwiOnQuZGF0YS5lcnI/Xy5zaGlmdCgpWzFdKHQuZGF0YS5lcnIpOl8uc2hpZnQoKVswXSh0LmRhdGEub3V0KTticmVhaztjYXNlXCJyZWxlYXNlXCI6dC5kYXRhLmVycj92LnNoaWZ0KClbMV0odC5kYXRhLmVycik6di5zaGlmdCgpWzBdKCk7YnJlYWs7Y2FzZVwicnVuXCI6dC5kYXRhLmVycj93LnNoaWZ0KClbMV0odC5kYXRhLmVycik6dy5zaGlmdCgpWzBdKHQuZGF0YS5vdXQpO2JyZWFrO2Nhc2VcImVuZC1wcm9maWxpbmdcIjp0LmRhdGEuZXJyP3guc2hpZnQoKVsxXSh0LmRhdGEuZXJyKTp4LnNoaWZ0KClbMF0oKX19LE89XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGRvY3VtZW50P251bGw9PT0ocj1udWxsPT09ZG9jdW1lbnR8fHZvaWQgMD09PWRvY3VtZW50P3ZvaWQgMDpkb2N1bWVudC5jdXJyZW50U2NyaXB0KXx8dm9pZCAwPT09cj92b2lkIDA6ci5zcmM6dm9pZCAwO2UuaW5pdFdhc209YXN5bmMoKT0+e2lmKGwoKSl7aWYoZylyZXR1cm47aWYoaCl0aHJvdyBuZXcgRXJyb3IoXCJtdWx0aXBsZSBjYWxscyB0byAnaW5pdFdhc20oKScgZGV0ZWN0ZWQuXCIpO2lmKGIpdGhyb3cgbmV3IEVycm9yKFwicHJldmlvdXMgY2FsbCB0byAnaW5pdFdhc20oKScgZmFpbGVkLlwiKTtyZXR1cm4gaD0hMCx2b2lkIDA9PT1zLmVudi53YXNtLndhc21QYXRocyYmTyYmMCE9PU8uaW5kZXhPZihcImJsb2I6XCIpJiYocy5lbnYud2FzbS53YXNtUGF0aHM9Ty5zdWJzdHIoMCwrTy5sYXN0SW5kZXhPZihcIi9cIikrMSkpLG5ldyBQcm9taXNlKCgodCxlKT0+e251bGw9PXB8fHAudGVybWluYXRlKCkscD1uKDk3MTApLlooKSxwLm9ubWVzc2FnZT1TLGY9W3QsZV07Y29uc3Qgcj17dHlwZTpcImluaXQtd2FzbVwiLGluOnMuZW52Lndhc219O3AucG9zdE1lc3NhZ2Uocil9KSl9cmV0dXJuKDAsYy5pbml0aWFsaXplV2ViQXNzZW1ibHkpKHMuZW52Lndhc20pfSxlLmluaXRPcnQ9YXN5bmModCxlKT0+e2lmKGwoKSlyZXR1cm4gVCgpLG5ldyBQcm9taXNlKCgobixyKT0+e2Q9W24scl07Y29uc3QgaT17dHlwZTpcImluaXQtb3J0XCIsaW46e251bVRocmVhZHM6dCxsb2dnaW5nTGV2ZWw6ZX19O3AucG9zdE1lc3NhZ2UoaSl9KSk7dS5pbml0T3J0KHQsZSl9LGUuY3JlYXRlU2Vzc2lvbkFsbG9jYXRlPWFzeW5jIHQ9PmwoKT8oVCgpLG5ldyBQcm9taXNlKCgoZSxuKT0+e20ucHVzaChbZSxuXSk7Y29uc3Qgcj17dHlwZTpcImNyZWF0ZV9hbGxvY2F0ZVwiLGluOnttb2RlbDp0fX07cC5wb3N0TWVzc2FnZShyLFt0LmJ1ZmZlcl0pfSkpKTp1LmNyZWF0ZVNlc3Npb25BbGxvY2F0ZSh0KSxlLmNyZWF0ZVNlc3Npb25GaW5hbGl6ZT1hc3luYyh0LGUpPT5sKCk/KFQoKSxuZXcgUHJvbWlzZSgoKG4scik9Pnt5LnB1c2goW24scl0pO2NvbnN0IGk9e3R5cGU6XCJjcmVhdGVfZmluYWxpemVcIixpbjp7bW9kZWxkYXRhOnQsb3B0aW9uczplfX07cC5wb3N0TWVzc2FnZShpKX0pKSk6dS5jcmVhdGVTZXNzaW9uRmluYWxpemUodCxlKSxlLmNyZWF0ZVNlc3Npb249YXN5bmModCxlKT0+bCgpPyhUKCksbmV3IFByb21pc2UoKChuLHIpPT57Xy5wdXNoKFtuLHJdKTtjb25zdCBpPXt0eXBlOlwiY3JlYXRlXCIsaW46e21vZGVsOnQsb3B0aW9uczplfX07cC5wb3N0TWVzc2FnZShpLFt0LmJ1ZmZlcl0pfSkpKTp1LmNyZWF0ZVNlc3Npb24odCxlKSxlLnJlbGVhc2VTZXNzaW9uPWFzeW5jIHQ9PntpZihsKCkpcmV0dXJuIFQoKSxuZXcgUHJvbWlzZSgoKGUsbik9Pnt2LnB1c2goW2Usbl0pO2NvbnN0IHI9e3R5cGU6XCJyZWxlYXNlXCIsaW46dH07cC5wb3N0TWVzc2FnZShyKX0pKTt1LnJlbGVhc2VTZXNzaW9uKHQpfSxlLnJ1bj1hc3luYyh0LGUsbixyLGkpPT5sKCk/KFQoKSxuZXcgUHJvbWlzZSgoKG8sYSk9Pnt3LnB1c2goW28sYV0pO2NvbnN0IHM9e3R5cGU6XCJydW5cIixpbjp7c2Vzc2lvbklkOnQsaW5wdXRJbmRpY2VzOmUsaW5wdXRzOm4sb3V0cHV0SW5kaWNlczpyLG9wdGlvbnM6aX19O3AucG9zdE1lc3NhZ2Uocyx1LmV4dHJhY3RUcmFuc2ZlcmFibGVCdWZmZXJzKG4pKX0pKSk6dS5ydW4odCxlLG4scixpKSxlLmVuZFByb2ZpbGluZz1hc3luYyB0PT57aWYobCgpKXJldHVybiBUKCksbmV3IFByb21pc2UoKChlLG4pPT57eC5wdXNoKFtlLG5dKTtjb25zdCByPXt0eXBlOlwiZW5kLXByb2ZpbGluZ1wiLGluOnR9O3AucG9zdE1lc3NhZ2Uocil9KSk7dS5lbmRQcm9maWxpbmcodCl9fSw1ODY6KHQsZSxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUuc2V0UnVuT3B0aW9ucz12b2lkIDA7Y29uc3Qgcj1uKDc5NjcpLGk9big0OTgzKSxvPW4oNjM2MSk7ZS5zZXRSdW5PcHRpb25zPXQ9Pntjb25zdCBlPSgwLG8uZ2V0SW5zdGFuY2UpKCk7bGV0IG49MDtjb25zdCBhPVtdLHM9dHx8e307dHJ5e2lmKHZvaWQgMD09PShudWxsPT10P3ZvaWQgMDp0LmxvZ1NldmVyaXR5TGV2ZWwpKXMubG9nU2V2ZXJpdHlMZXZlbD0yO2Vsc2UgaWYoXCJudW1iZXJcIiE9dHlwZW9mIHQubG9nU2V2ZXJpdHlMZXZlbHx8IU51bWJlci5pc0ludGVnZXIodC5sb2dTZXZlcml0eUxldmVsKXx8dC5sb2dTZXZlcml0eUxldmVsPDB8fHQubG9nU2V2ZXJpdHlMZXZlbD40KXRocm93IG5ldyBFcnJvcihgbG9nIHNlcnZlcml0eSBsZXZlbCBpcyBub3QgdmFsaWQ6ICR7dC5sb2dTZXZlcml0eUxldmVsfWApO2lmKHZvaWQgMD09PShudWxsPT10P3ZvaWQgMDp0LmxvZ1ZlcmJvc2l0eUxldmVsKSlzLmxvZ1ZlcmJvc2l0eUxldmVsPTA7ZWxzZSBpZihcIm51bWJlclwiIT10eXBlb2YgdC5sb2dWZXJib3NpdHlMZXZlbHx8IU51bWJlci5pc0ludGVnZXIodC5sb2dWZXJib3NpdHlMZXZlbCkpdGhyb3cgbmV3IEVycm9yKGBsb2cgdmVyYm9zaXR5IGxldmVsIGlzIG5vdCB2YWxpZDogJHt0LmxvZ1ZlcmJvc2l0eUxldmVsfWApO3ZvaWQgMD09PShudWxsPT10P3ZvaWQgMDp0LnRlcm1pbmF0ZSkmJihzLnRlcm1pbmF0ZT0hMSk7bGV0IG89MDtpZih2b2lkIDAhPT0obnVsbD09dD92b2lkIDA6dC50YWcpJiYobz0oMCxpLmFsbG9jV2FzbVN0cmluZykodC50YWcsYSkpLG49ZS5fT3J0Q3JlYXRlUnVuT3B0aW9ucyhzLmxvZ1NldmVyaXR5TGV2ZWwscy5sb2dWZXJib3NpdHlMZXZlbCwhIXMudGVybWluYXRlLG8pLDA9PT1uKXRocm93IG5ldyBFcnJvcihcIkNhbid0IGNyZWF0ZSBydW4gb3B0aW9uc1wiKTtyZXR1cm4gdm9pZCAwIT09KG51bGw9PXQ/dm9pZCAwOnQuZXh0cmEpJiYoMCxyLml0ZXJhdGVFeHRyYU9wdGlvbnMpKHQuZXh0cmEsXCJcIixuZXcgV2Vha1NldCwoKHQscik9Pntjb25zdCBvPSgwLGkuYWxsb2NXYXNtU3RyaW5nKSh0LGEpLHM9KDAsaS5hbGxvY1dhc21TdHJpbmcpKHIsYSk7aWYoMCE9PWUuX09ydEFkZFJ1bkNvbmZpZ0VudHJ5KG4sbyxzKSl0aHJvdyBuZXcgRXJyb3IoYENhbid0IHNldCBhIHJ1biBjb25maWcgZW50cnk6ICR7dH0gLSAke3J9YCl9KSksW24sYV19Y2F0Y2godCl7dGhyb3cgMCE9PW4mJmUuX09ydFJlbGVhc2VSdW5PcHRpb25zKG4pLGEuZm9yRWFjaChlLl9mcmVlKSx0fX19LDIzMDY6KHQsZSxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUuT25ueHJ1bnRpbWVXZWJBc3NlbWJseVNlc3Npb25IYW5kbGVyPXZvaWQgMDtjb25zdCByPW4oNjIzMSksaT1uKDYyMDcpLG89big2NDY0KSxhPW4oMjE1Nyk7bGV0IHM7ZS5Pbm54cnVudGltZVdlYkFzc2VtYmx5U2Vzc2lvbkhhbmRsZXI9Y2xhc3N7YXN5bmMgY3JlYXRlU2Vzc2lvbkFsbG9jYXRlKHQpe2NvbnN0IGU9YXdhaXQgZmV0Y2godCksbj1hd2FpdCBlLmFycmF5QnVmZmVyKCk7cmV0dXJuKDAsYS5jcmVhdGVTZXNzaW9uQWxsb2NhdGUpKG5ldyBVaW50OEFycmF5KG4pKX1hc3luYyBsb2FkTW9kZWwodCxlKXtpZihzfHwoYXdhaXQoMCxhLmluaXRPcnQpKGkuZW52Lndhc20ubnVtVGhyZWFkcywodD0+e3N3aXRjaCh0KXtjYXNlXCJ2ZXJib3NlXCI6cmV0dXJuIDA7Y2FzZVwiaW5mb1wiOnJldHVybiAxO2Nhc2VcIndhcm5pbmdcIjpyZXR1cm4gMjtjYXNlXCJlcnJvclwiOnJldHVybiAzO2Nhc2VcImZhdGFsXCI6cmV0dXJuIDQ7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIGxvZ2dpbmcgbGV2ZWw6ICR7dH1gKX19KShpLmVudi5sb2dMZXZlbCkpLHM9ITApLFwic3RyaW5nXCI9PXR5cGVvZiB0KWlmKFwidW5kZWZpbmVkXCI9PXR5cGVvZiBmZXRjaCl7Y29uc3Qgbj1hd2FpdCgwLG8ucHJvbWlzaWZ5KShyLnJlYWRGaWxlKSh0KTtbdGhpcy5zZXNzaW9uSWQsdGhpcy5pbnB1dE5hbWVzLHRoaXMub3V0cHV0TmFtZXNdPWF3YWl0KDAsYS5jcmVhdGVTZXNzaW9uKShuLGUpfWVsc2V7Y29uc3Qgbj1hd2FpdCB0aGlzLmNyZWF0ZVNlc3Npb25BbGxvY2F0ZSh0KTtbdGhpcy5zZXNzaW9uSWQsdGhpcy5pbnB1dE5hbWVzLHRoaXMub3V0cHV0TmFtZXNdPWF3YWl0KDAsYS5jcmVhdGVTZXNzaW9uRmluYWxpemUpKG4sZSl9ZWxzZVt0aGlzLnNlc3Npb25JZCx0aGlzLmlucHV0TmFtZXMsdGhpcy5vdXRwdXROYW1lc109YXdhaXQoMCxhLmNyZWF0ZVNlc3Npb24pKHQsZSl9YXN5bmMgZGlzcG9zZSgpe3JldHVybigwLGEucmVsZWFzZVNlc3Npb24pKHRoaXMuc2Vzc2lvbklkKX1hc3luYyBydW4odCxlLG4pe2NvbnN0IHI9W10sbz1bXTtPYmplY3QuZW50cmllcyh0KS5mb3JFYWNoKCh0PT57Y29uc3QgZT10WzBdLG49dFsxXSxpPXRoaXMuaW5wdXROYW1lcy5pbmRleE9mKGUpO2lmKC0xPT09aSl0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgaW5wdXQgJyR7ZX0nYCk7ci5wdXNoKG4pLG8ucHVzaChpKX0pKTtjb25zdCBzPVtdO09iamVjdC5lbnRyaWVzKGUpLmZvckVhY2goKHQ9Pntjb25zdCBlPXRbMF0sbj10aGlzLm91dHB1dE5hbWVzLmluZGV4T2YoZSk7aWYoLTE9PT1uKXRocm93IG5ldyBFcnJvcihgaW52YWxpZCBvdXRwdXQgJyR7ZX0nYCk7cy5wdXNoKG4pfSkpO2NvbnN0IHU9YXdhaXQoMCxhLnJ1bikodGhpcy5zZXNzaW9uSWQsbyxyLm1hcCgodD0+W3QudHlwZSx0LmRpbXMsdC5kYXRhXSkpLHMsbiksYz17fTtmb3IobGV0IHQ9MDt0PHUubGVuZ3RoO3QrKyljW3RoaXMub3V0cHV0TmFtZXNbc1t0XV1dPW5ldyBpLlRlbnNvcih1W3RdWzBdLHVbdF1bMl0sdVt0XVsxXSk7cmV0dXJuIGN9c3RhcnRQcm9maWxpbmcoKXt9ZW5kUHJvZmlsaW5nKCl7KDAsYS5lbmRQcm9maWxpbmcpKHRoaXMuc2Vzc2lvbklkKX19fSw0OTE5Oih0LGUsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLnNldFNlc3Npb25PcHRpb25zPXZvaWQgMDtjb25zdCByPW4oNzk2NyksaT1uKDQ5ODMpLG89big2MzYxKTtlLnNldFNlc3Npb25PcHRpb25zPXQ9Pntjb25zdCBlPSgwLG8uZ2V0SW5zdGFuY2UpKCk7bGV0IG49MDtjb25zdCBhPVtdLHM9dHx8e307KHQ9Pnt0LmV4dHJhfHwodC5leHRyYT17fSksdC5leHRyYS5zZXNzaW9ufHwodC5leHRyYS5zZXNzaW9uPXt9KTtjb25zdCBlPXQuZXh0cmEuc2Vzc2lvbjtlLnVzZV9vcnRfbW9kZWxfYnl0ZXNfZGlyZWN0bHl8fChlLnVzZV9vcnRfbW9kZWxfYnl0ZXNfZGlyZWN0bHk9XCIxXCIpfSkocyk7dHJ5e3ZvaWQgMD09PShudWxsPT10P3ZvaWQgMDp0LmdyYXBoT3B0aW1pemF0aW9uTGV2ZWwpJiYocy5ncmFwaE9wdGltaXphdGlvbkxldmVsPVwiYWxsXCIpO2NvbnN0IHU9KHQ9Pntzd2l0Y2godCl7Y2FzZVwiZGlzYWJsZWRcIjpyZXR1cm4gMDtjYXNlXCJiYXNpY1wiOnJldHVybiAxO2Nhc2VcImV4dGVuZGVkXCI6cmV0dXJuIDI7Y2FzZVwiYWxsXCI6cmV0dXJuIDk5O2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCBncmFwaCBvcHRpbWl6YXRpb24gbGV2ZWw6ICR7dH1gKX19KShzLmdyYXBoT3B0aW1pemF0aW9uTGV2ZWwpO3ZvaWQgMD09PShudWxsPT10P3ZvaWQgMDp0LmVuYWJsZUNwdU1lbUFyZW5hKSYmKHMuZW5hYmxlQ3B1TWVtQXJlbmE9ITApLHZvaWQgMD09PShudWxsPT10P3ZvaWQgMDp0LmVuYWJsZU1lbVBhdHRlcm4pJiYocy5lbmFibGVNZW1QYXR0ZXJuPSEwKSx2b2lkIDA9PT0obnVsbD09dD92b2lkIDA6dC5leGVjdXRpb25Nb2RlKSYmKHMuZXhlY3V0aW9uTW9kZT1cInNlcXVlbnRpYWxcIik7Y29uc3QgYz0odD0+e3N3aXRjaCh0KXtjYXNlXCJzZXF1ZW50aWFsXCI6cmV0dXJuIDA7Y2FzZVwicGFyYWxsZWxcIjpyZXR1cm4gMTtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgZXhlY3V0aW9uIG1vZGU6ICR7dH1gKX19KShzLmV4ZWN1dGlvbk1vZGUpO2xldCBsPTA7aWYodm9pZCAwIT09KG51bGw9PXQ/dm9pZCAwOnQubG9nSWQpJiYobD0oMCxpLmFsbG9jV2FzbVN0cmluZykodC5sb2dJZCxhKSksdm9pZCAwPT09KG51bGw9PXQ/dm9pZCAwOnQubG9nU2V2ZXJpdHlMZXZlbCkpcy5sb2dTZXZlcml0eUxldmVsPTI7ZWxzZSBpZihcIm51bWJlclwiIT10eXBlb2YgdC5sb2dTZXZlcml0eUxldmVsfHwhTnVtYmVyLmlzSW50ZWdlcih0LmxvZ1NldmVyaXR5TGV2ZWwpfHx0LmxvZ1NldmVyaXR5TGV2ZWw8MHx8dC5sb2dTZXZlcml0eUxldmVsPjQpdGhyb3cgbmV3IEVycm9yKGBsb2cgc2VydmVyaXR5IGxldmVsIGlzIG5vdCB2YWxpZDogJHt0LmxvZ1NldmVyaXR5TGV2ZWx9YCk7aWYodm9pZCAwPT09KG51bGw9PXQ/dm9pZCAwOnQubG9nVmVyYm9zaXR5TGV2ZWwpKXMubG9nVmVyYm9zaXR5TGV2ZWw9MDtlbHNlIGlmKFwibnVtYmVyXCIhPXR5cGVvZiB0LmxvZ1ZlcmJvc2l0eUxldmVsfHwhTnVtYmVyLmlzSW50ZWdlcih0LmxvZ1ZlcmJvc2l0eUxldmVsKSl0aHJvdyBuZXcgRXJyb3IoYGxvZyB2ZXJib3NpdHkgbGV2ZWwgaXMgbm90IHZhbGlkOiAke3QubG9nVmVyYm9zaXR5TGV2ZWx9YCk7aWYodm9pZCAwPT09KG51bGw9PXQ/dm9pZCAwOnQuZW5hYmxlUHJvZmlsaW5nKSYmKHMuZW5hYmxlUHJvZmlsaW5nPSExKSxuPWUuX09ydENyZWF0ZVNlc3Npb25PcHRpb25zKHUsISFzLmVuYWJsZUNwdU1lbUFyZW5hLCEhcy5lbmFibGVNZW1QYXR0ZXJuLGMsISFzLmVuYWJsZVByb2ZpbGluZywwLGwscy5sb2dTZXZlcml0eUxldmVsLHMubG9nVmVyYm9zaXR5TGV2ZWwpLDA9PT1uKXRocm93IG5ldyBFcnJvcihcIkNhbid0IGNyZWF0ZSBzZXNzaW9uIG9wdGlvbnNcIik7cmV0dXJuKG51bGw9PXQ/dm9pZCAwOnQuZXhlY3V0aW9uUHJvdmlkZXJzKSYmKCh0LGUsbik9Pntmb3IoY29uc3QgciBvZiBlKXtsZXQgZT1cInN0cmluZ1wiPT10eXBlb2Ygcj9yOnIubmFtZTtzd2l0Y2goZSl7Y2FzZVwieG5ucGFja1wiOmU9XCJYTk5QQUNLXCI7YnJlYWs7Y2FzZVwid2FzbVwiOmNhc2VcImNwdVwiOmNvbnRpbnVlO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBub3Qgc3VwcG9ydGVkIEVQOiAke2V9YCl9Y29uc3QgYT0oMCxpLmFsbG9jV2FzbVN0cmluZykoZSxuKTtpZigwIT09KDAsby5nZXRJbnN0YW5jZSkoKS5fT3J0QXBwZW5kRXhlY3V0aW9uUHJvdmlkZXIodCxhKSl0aHJvdyBuZXcgRXJyb3IoYENhbid0IGFwcGVuZCBleGVjdXRpb24gcHJvdmlkZXI6ICR7ZX1gKX19KShuLHQuZXhlY3V0aW9uUHJvdmlkZXJzLGEpLHZvaWQgMCE9PShudWxsPT10P3ZvaWQgMDp0LmV4dHJhKSYmKDAsci5pdGVyYXRlRXh0cmFPcHRpb25zKSh0LmV4dHJhLFwiXCIsbmV3IFdlYWtTZXQsKCh0LHIpPT57Y29uc3Qgbz0oMCxpLmFsbG9jV2FzbVN0cmluZykodCxhKSxzPSgwLGkuYWxsb2NXYXNtU3RyaW5nKShyLGEpO2lmKDAhPT1lLl9PcnRBZGRTZXNzaW9uQ29uZmlnRW50cnkobixvLHMpKXRocm93IG5ldyBFcnJvcihgQ2FuJ3Qgc2V0IGEgc2Vzc2lvbiBjb25maWcgZW50cnk6ICR7dH0gLSAke3J9YCl9KSksW24sYV19Y2F0Y2godCl7dGhyb3cgMCE9PW4mJmUuX09ydFJlbGVhc2VTZXNzaW9uT3B0aW9ucyhuKSxhLmZvckVhY2goZS5fZnJlZSksdH19fSw0OTgzOih0LGUsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLmFsbG9jV2FzbVN0cmluZz12b2lkIDA7Y29uc3Qgcj1uKDYzNjEpO2UuYWxsb2NXYXNtU3RyaW5nPSh0LGUpPT57Y29uc3Qgbj0oMCxyLmdldEluc3RhbmNlKSgpLGk9bi5sZW5ndGhCeXRlc1VURjgodCkrMSxvPW4uX21hbGxvYyhpKTtyZXR1cm4gbi5zdHJpbmdUb1VURjgodCxvLGkpLGUucHVzaChvKSxvfX0sMzQ5Oih0LGUsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLmV4dHJhY3RUcmFuc2ZlcmFibGVCdWZmZXJzPWUuZW5kUHJvZmlsaW5nPWUucnVuPWUucmVsZWFzZVNlc3Npb249ZS5jcmVhdGVTZXNzaW9uPWUuY3JlYXRlU2Vzc2lvbkZpbmFsaXplPWUuY3JlYXRlU2Vzc2lvbkFsbG9jYXRlPWUuaW5pdE9ydD12b2lkIDA7Y29uc3Qgcj1uKDU4NiksaT1uKDQ5MTkpLG89big0OTgzKSxhPW4oNjM2MSk7ZS5pbml0T3J0PSh0LGUpPT57Y29uc3Qgbj0oMCxhLmdldEluc3RhbmNlKSgpLl9PcnRJbml0KHQsZSk7aWYoMCE9PW4pdGhyb3cgbmV3IEVycm9yKGBDYW4ndCBpbml0aWFsaXplIG9ubnhydW50aW1lLiBlcnJvciBjb2RlID0gJHtufWApfTtjb25zdCBzPW5ldyBNYXA7ZS5jcmVhdGVTZXNzaW9uQWxsb2NhdGU9dD0+e2NvbnN0IGU9KDAsYS5nZXRJbnN0YW5jZSkoKSxuPWUuX21hbGxvYyh0LmJ5dGVMZW5ndGgpO3JldHVybiBlLkhFQVBVOC5zZXQodCxuKSxbbix0LmJ5dGVMZW5ndGhdfSxlLmNyZWF0ZVNlc3Npb25GaW5hbGl6ZT0odCxlKT0+e2NvbnN0IG49KDAsYS5nZXRJbnN0YW5jZSkoKTtsZXQgcj0wLG89MCx1PVtdO3RyeXtpZihbbyx1XT0oMCxpLnNldFNlc3Npb25PcHRpb25zKShlKSxyPW4uX09ydENyZWF0ZVNlc3Npb24odFswXSx0WzFdLG8pLDA9PT1yKXRocm93IG5ldyBFcnJvcihcIkNhbid0IGNyZWF0ZSBhIHNlc3Npb25cIil9ZmluYWxseXtuLl9mcmVlKHRbMF0pLG4uX09ydFJlbGVhc2VTZXNzaW9uT3B0aW9ucyhvKSx1LmZvckVhY2gobi5fZnJlZSl9Y29uc3QgYz1uLl9PcnRHZXRJbnB1dENvdW50KHIpLGw9bi5fT3J0R2V0T3V0cHV0Q291bnQocikscD1bXSxmPVtdLGQ9W10saD1bXTtmb3IobGV0IHQ9MDt0PGM7dCsrKXtjb25zdCBlPW4uX09ydEdldElucHV0TmFtZShyLHQpO2lmKDA9PT1lKXRocm93IG5ldyBFcnJvcihcIkNhbid0IGdldCBhbiBpbnB1dCBuYW1lXCIpO2YucHVzaChlKSxwLnB1c2gobi5VVEY4VG9TdHJpbmcoZSkpfWZvcihsZXQgdD0wO3Q8bDt0Kyspe2NvbnN0IGU9bi5fT3J0R2V0T3V0cHV0TmFtZShyLHQpO2lmKDA9PT1lKXRocm93IG5ldyBFcnJvcihcIkNhbid0IGdldCBhbiBvdXRwdXQgbmFtZVwiKTtoLnB1c2goZSksZC5wdXNoKG4uVVRGOFRvU3RyaW5nKGUpKX1yZXR1cm4gcy5zZXQocixbcixmLGhdKSxbcixwLGRdfSxlLmNyZWF0ZVNlc3Npb249KHQsbik9Pntjb25zdCByPSgwLGUuY3JlYXRlU2Vzc2lvbkFsbG9jYXRlKSh0KTtyZXR1cm4oMCxlLmNyZWF0ZVNlc3Npb25GaW5hbGl6ZSkocixuKX0sZS5yZWxlYXNlU2Vzc2lvbj10PT57Y29uc3QgZT0oMCxhLmdldEluc3RhbmNlKSgpLG49cy5nZXQodCk7aWYoIW4pdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBzZXNzaW9uIGlkXCIpO2NvbnN0IHI9blswXSxpPW5bMV0sbz1uWzJdO2kuZm9yRWFjaChlLl9PcnRGcmVlKSxvLmZvckVhY2goZS5fT3J0RnJlZSksZS5fT3J0UmVsZWFzZVNlc3Npb24ocikscy5kZWxldGUodCl9O2NvbnN0IHU9dD0+e3N3aXRjaCh0KXtjYXNlXCJpbnQ4XCI6cmV0dXJuIDM7Y2FzZVwidWludDhcIjpyZXR1cm4gMjtjYXNlXCJib29sXCI6cmV0dXJuIDk7Y2FzZVwiaW50MTZcIjpyZXR1cm4gNTtjYXNlXCJ1aW50MTZcIjpyZXR1cm4gNDtjYXNlXCJpbnQzMlwiOnJldHVybiA2O2Nhc2VcInVpbnQzMlwiOnJldHVybiAxMjtjYXNlXCJmbG9hdDMyXCI6cmV0dXJuIDE7Y2FzZVwiZmxvYXQ2NFwiOnJldHVybiAxMTtjYXNlXCJzdHJpbmdcIjpyZXR1cm4gODtjYXNlXCJpbnQ2NFwiOnJldHVybiA3O2Nhc2VcInVpbnQ2NFwiOnJldHVybiAxMztkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgZGF0YSB0eXBlOiAke3R9YCl9fSxjPXQ9Pntzd2l0Y2godCl7Y2FzZSAzOnJldHVyblwiaW50OFwiO2Nhc2UgMjpyZXR1cm5cInVpbnQ4XCI7Y2FzZSA5OnJldHVyblwiYm9vbFwiO2Nhc2UgNTpyZXR1cm5cImludDE2XCI7Y2FzZSA0OnJldHVyblwidWludDE2XCI7Y2FzZSA2OnJldHVyblwiaW50MzJcIjtjYXNlIDEyOnJldHVyblwidWludDMyXCI7Y2FzZSAxOnJldHVyblwiZmxvYXQzMlwiO2Nhc2UgMTE6cmV0dXJuXCJmbG9hdDY0XCI7Y2FzZSA4OnJldHVyblwic3RyaW5nXCI7Y2FzZSA3OnJldHVyblwiaW50NjRcIjtjYXNlIDEzOnJldHVyblwidWludDY0XCI7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIGRhdGEgdHlwZTogJHt0fWApfX0sbD10PT57c3dpdGNoKHQpe2Nhc2VcImZsb2F0MzJcIjpyZXR1cm4gRmxvYXQzMkFycmF5O2Nhc2VcInVpbnQ4XCI6Y2FzZVwiYm9vbFwiOnJldHVybiBVaW50OEFycmF5O2Nhc2VcImludDhcIjpyZXR1cm4gSW50OEFycmF5O2Nhc2VcInVpbnQxNlwiOnJldHVybiBVaW50MTZBcnJheTtjYXNlXCJpbnQxNlwiOnJldHVybiBJbnQxNkFycmF5O2Nhc2VcImludDMyXCI6cmV0dXJuIEludDMyQXJyYXk7Y2FzZVwiZmxvYXQ2NFwiOnJldHVybiBGbG9hdDY0QXJyYXk7Y2FzZVwidWludDMyXCI6cmV0dXJuIFVpbnQzMkFycmF5O2Nhc2VcImludDY0XCI6cmV0dXJuIEJpZ0ludDY0QXJyYXk7Y2FzZVwidWludDY0XCI6cmV0dXJuIEJpZ1VpbnQ2NEFycmF5O2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCB0eXBlOiAke3R9YCl9fTtlLnJ1bj0odCxlLG4saSxwKT0+e2NvbnN0IGY9KDAsYS5nZXRJbnN0YW5jZSkoKSxkPXMuZ2V0KHQpO2lmKCFkKXRocm93IG5ldyBFcnJvcihcImludmFsaWQgc2Vzc2lvbiBpZFwiKTtjb25zdCBoPWRbMF0sZz1kWzFdLGI9ZFsyXSxtPWUubGVuZ3RoLHk9aS5sZW5ndGg7bGV0IF89MCx2PVtdO2NvbnN0IHc9W10seD1bXTt0cnl7W18sdl09KDAsci5zZXRSdW5PcHRpb25zKShwKTtmb3IobGV0IHQ9MDt0PG07dCsrKXtjb25zdCBlPW5bdF1bMF0scj1uW3RdWzFdLGk9blt0XVsyXTtsZXQgYSxzO2lmKEFycmF5LmlzQXJyYXkoaSkpe3M9NCppLmxlbmd0aCxhPWYuX21hbGxvYyhzKSx4LnB1c2goYSk7bGV0IHQ9YS80O2ZvcihsZXQgZT0wO2U8aS5sZW5ndGg7ZSsrKXtpZihcInN0cmluZ1wiIT10eXBlb2YgaVtlXSl0aHJvdyBuZXcgVHlwZUVycm9yKGB0ZW5zb3IgZGF0YSBhdCBpbmRleCAke2V9IGlzIG5vdCBhIHN0cmluZ2ApO2YuSEVBUFUzMlt0KytdPSgwLG8uYWxsb2NXYXNtU3RyaW5nKShpW2VdLHgpfX1lbHNlIHM9aS5ieXRlTGVuZ3RoLGE9Zi5fbWFsbG9jKHMpLHgucHVzaChhKSxmLkhFQVBVOC5zZXQobmV3IFVpbnQ4QXJyYXkoaS5idWZmZXIsaS5ieXRlT2Zmc2V0LHMpLGEpO2NvbnN0IGM9Zi5zdGFja1NhdmUoKSxsPWYuc3RhY2tBbGxvYyg0KnIubGVuZ3RoKTt0cnl7bGV0IHQ9bC80O3IuZm9yRWFjaCgoZT0+Zi5IRUFQMzJbdCsrXT1lKSk7Y29uc3Qgbj1mLl9PcnRDcmVhdGVUZW5zb3IodShlKSxhLHMsbCxyLmxlbmd0aCk7aWYoMD09PW4pdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgY3JlYXRlIGEgdGVuc29yXCIpO3cucHVzaChuKX1maW5hbGx5e2Yuc3RhY2tSZXN0b3JlKGMpfX1jb25zdCB0PWYuc3RhY2tTYXZlKCksYT1mLnN0YWNrQWxsb2MoNCptKSxzPWYuc3RhY2tBbGxvYyg0Km0pLGQ9Zi5zdGFja0FsbG9jKDQqeSksVD1mLnN0YWNrQWxsb2MoNCp5KTt0cnl7bGV0IG49YS80LHI9cy80LG89ZC80LHU9VC80O2ZvcihsZXQgdD0wO3Q8bTt0KyspZi5IRUFQVTMyW24rK109d1t0XSxmLkhFQVBVMzJbcisrXT1nW2VbdF1dO2ZvcihsZXQgdD0wO3Q8eTt0KyspZi5IRUFQVTMyW28rK109MCxmLkhFQVBVMzJbdSsrXT1iW2lbdF1dO2xldCBwPWYuX09ydFJ1bihoLHMsYSxtLFQseSxkLF8pO2NvbnN0IHY9W107aWYoMD09PXApZm9yKGxldCB0PTA7dDx5O3QrKyl7Y29uc3QgZT1mLkhFQVBVMzJbZC80K3RdLG49Zi5zdGFja1NhdmUoKSxyPWYuc3RhY2tBbGxvYygxNik7bGV0IGksbz0wO3RyeXtpZihwPWYuX09ydEdldFRlbnNvckRhdGEoZSxyLHIrNCxyKzgscisxMiksMCE9PXApdGhyb3cgbmV3IEVycm9yKGBDYW4ndCBhY2Nlc3Mgb3V0cHV0IHRlbnNvciBkYXRhLiBlcnJvciBjb2RlID0gJHtwfWApO2xldCB0PXIvNDtjb25zdCBhPWYuSEVBUFUzMlt0KytdO289Zi5IRUFQVTMyW3QrK107Y29uc3Qgcz1mLkhFQVBVMzJbdCsrXSx1PWYuSEVBUFUzMlt0KytdLGQ9W107Zm9yKGxldCB0PTA7dDx1O3QrKylkLnB1c2goZi5IRUFQVTMyW3MvNCt0XSk7Zi5fT3J0RnJlZShzKTtjb25zdCBoPTA9PT1kLmxlbmd0aD8xOmQucmVkdWNlKCgodCxlKT0+dCplKSk7aWYoaT1jKGEpLFwic3RyaW5nXCI9PT1pKXtjb25zdCB0PVtdO2xldCBlPW8vNDtmb3IobGV0IG49MDtuPGg7bisrKXtjb25zdCByPWYuSEVBUFUzMltlKytdLGk9bj09PWgtMT92b2lkIDA6Zi5IRUFQVTMyW2VdLXI7dC5wdXNoKGYuVVRGOFRvU3RyaW5nKHIsaSkpfXYucHVzaChbaSxkLHRdKX1lbHNle2NvbnN0IHQ9bmV3KGwoaSkpKGgpO25ldyBVaW50OEFycmF5KHQuYnVmZmVyLHQuYnl0ZU9mZnNldCx0LmJ5dGVMZW5ndGgpLnNldChmLkhFQVBVOC5zdWJhcnJheShvLG8rdC5ieXRlTGVuZ3RoKSksdi5wdXNoKFtpLGQsdF0pfX1maW5hbGx5e2Yuc3RhY2tSZXN0b3JlKG4pLFwic3RyaW5nXCI9PT1pJiZvJiZmLl9mcmVlKG8pLGYuX09ydFJlbGVhc2VUZW5zb3IoZSl9fWlmKDA9PT1wKXJldHVybiB2O3Rocm93IG5ldyBFcnJvcihgZmFpbGVkIHRvIGNhbGwgT3J0UnVuKCkuIGVycm9yIGNvZGUgPSAke3B9LmApfWZpbmFsbHl7Zi5zdGFja1Jlc3RvcmUodCl9fWZpbmFsbHl7dy5mb3JFYWNoKGYuX09ydFJlbGVhc2VUZW5zb3IpLHguZm9yRWFjaChmLl9mcmVlKSxmLl9PcnRSZWxlYXNlUnVuT3B0aW9ucyhfKSx2LmZvckVhY2goZi5fZnJlZSl9fSxlLmVuZFByb2ZpbGluZz10PT57Y29uc3QgZT0oMCxhLmdldEluc3RhbmNlKSgpLG49cy5nZXQodCk7aWYoIW4pdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBzZXNzaW9uIGlkXCIpO2NvbnN0IHI9blswXSxpPWUuX09ydEVuZFByb2ZpbGluZyhyKTtpZigwPT09aSl0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBnZXQgYW4gcHJvZmlsZSBmaWxlIG5hbWVcIik7ZS5fT3J0RnJlZShpKX0sZS5leHRyYWN0VHJhbnNmZXJhYmxlQnVmZmVycz10PT57Y29uc3QgZT1bXTtmb3IoY29uc3QgbiBvZiB0KXtjb25zdCB0PW5bMl07IUFycmF5LmlzQXJyYXkodCkmJnQuYnVmZmVyJiZlLnB1c2godC5idWZmZXIpfXJldHVybiBlfX0sNjM2MTpmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7dmFyIHI9dGhpcyYmdGhpcy5fX2NyZWF0ZUJpbmRpbmd8fChPYmplY3QuY3JlYXRlP2Z1bmN0aW9uKHQsZSxuLHIpe3ZvaWQgMD09PXImJihyPW4pO3ZhciBpPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSxuKTtpJiYhKFwiZ2V0XCJpbiBpPyFlLl9fZXNNb2R1bGU6aS53cml0YWJsZXx8aS5jb25maWd1cmFibGUpfHwoaT17ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gZVtuXX19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCxyLGkpfTpmdW5jdGlvbih0LGUsbixyKXt2b2lkIDA9PT1yJiYocj1uKSx0W3JdPWVbbl19KSxpPXRoaXMmJnRoaXMuX19zZXRNb2R1bGVEZWZhdWx0fHwoT2JqZWN0LmNyZWF0ZT9mdW5jdGlvbih0LGUpe09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiZGVmYXVsdFwiLHtlbnVtZXJhYmxlOiEwLHZhbHVlOmV9KX06ZnVuY3Rpb24odCxlKXt0LmRlZmF1bHQ9ZX0pLG89dGhpcyYmdGhpcy5fX2ltcG9ydFN0YXJ8fGZ1bmN0aW9uKHQpe2lmKHQmJnQuX19lc01vZHVsZSlyZXR1cm4gdDt2YXIgZT17fTtpZihudWxsIT10KWZvcih2YXIgbiBpbiB0KVwiZGVmYXVsdFwiIT09biYmT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQsbikmJnIoZSx0LG4pO3JldHVybiBpKGUsdCksZX0sYT10aGlzJiZ0aGlzLl9faW1wb3J0RGVmYXVsdHx8ZnVuY3Rpb24odCl7cmV0dXJuIHQmJnQuX19lc01vZHVsZT90OntkZWZhdWx0OnR9fTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLmRpc3Bvc2U9ZS5nZXRJbnN0YW5jZT1lLmluaXRpYWxpemVXZWJBc3NlbWJseT12b2lkIDA7Y29uc3Qgcz1vKG4oMTQyMykpLHU9YShuKDkzMikpLGM9bigzNDc0KTtsZXQgbCxwPSExLGY9ITEsZD0hMTtjb25zdCBoPSh0LGUpPT5lP3Q/XCJvcnQtd2FzbS1zaW1kLXRocmVhZGVkLndhc21cIjpcIm9ydC13YXNtLXRocmVhZGVkLndhc21cIjp0P1wib3J0LXdhc20tc2ltZC53YXNtXCI6XCJvcnQtd2FzbS53YXNtXCI7ZS5pbml0aWFsaXplV2ViQXNzZW1ibHk9YXN5bmMgdD0+e2lmKHApcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO2lmKGYpdGhyb3cgbmV3IEVycm9yKFwibXVsdGlwbGUgY2FsbHMgdG8gJ2luaXRpYWxpemVXZWJBc3NlbWJseSgpJyBkZXRlY3RlZC5cIik7aWYoZCl0aHJvdyBuZXcgRXJyb3IoXCJwcmV2aW91cyBjYWxsIHRvICdpbml0aWFsaXplV2ViQXNzZW1ibHkoKScgZmFpbGVkLlwiKTtmPSEwO2NvbnN0IGU9dC5pbml0VGltZW91dCxyPXQubnVtVGhyZWFkcyxpPXQuc2ltZCxvPXI+MSYmKCgpPT57dHJ5e3JldHVyblwidW5kZWZpbmVkXCIhPXR5cGVvZiBTaGFyZWRBcnJheUJ1ZmZlciYmKFwidW5kZWZpbmVkXCIhPXR5cGVvZiBNZXNzYWdlQ2hhbm5lbCYmKG5ldyBNZXNzYWdlQ2hhbm5lbCkucG9ydDEucG9zdE1lc3NhZ2UobmV3IFNoYXJlZEFycmF5QnVmZmVyKDEpKSxXZWJBc3NlbWJseS52YWxpZGF0ZShuZXcgVWludDhBcnJheShbMCw5NywxMTUsMTA5LDEsMCwwLDAsMSw0LDEsOTYsMCwwLDMsMiwxLDAsNSw0LDEsMywxLDEsMTAsMTEsMSw5LDAsNjUsMCwyNTQsMTYsMiwwLDI2LDExXSkpKX1jYXRjaCh0KXtyZXR1cm4hMX19KSgpLGE9aSYmKCgpPT57dHJ5e3JldHVybiBXZWJBc3NlbWJseS52YWxpZGF0ZShuZXcgVWludDhBcnJheShbMCw5NywxMTUsMTA5LDEsMCwwLDAsMSw0LDEsOTYsMCwwLDMsMiwxLDAsMTAsMzAsMSwyOCwwLDY1LDAsMjUzLDE1LDI1MywxMiwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDI1MywxODYsMSwyNiwxMV0pKX1jYXRjaCh0KXtyZXR1cm4hMX19KSgpLGc9XCJzdHJpbmdcIj09dHlwZW9mIHQud2FzbVBhdGhzP3Qud2FzbVBhdGhzOnZvaWQgMCxiPWgoITEsbyksbT1oKGEsbykseT1cIm9iamVjdFwiPT10eXBlb2YgdC53YXNtUGF0aHM/dC53YXNtUGF0aHNbbV06dm9pZCAwO2xldCBfPSExO2NvbnN0IHY9W107aWYoZT4wJiZ2LnB1c2gobmV3IFByb21pc2UoKHQ9PntzZXRUaW1lb3V0KCgoKT0+e189ITAsdCgpfSksZSl9KSkpLHYucHVzaChuZXcgUHJvbWlzZSgoKHQsZSk9Pntjb25zdCByPW8/Yzp1LmRlZmF1bHQsaT17bG9jYXRlRmlsZToodCxlKT0+byYmdC5lbmRzV2l0aChcIi53b3JrZXIuanNcIikmJlwidW5kZWZpbmVkXCIhPXR5cGVvZiBCbG9iP1VSTC5jcmVhdGVPYmplY3RVUkwobmV3IEJsb2IoW24oNDE1NCldLHt0eXBlOlwidGV4dC9qYXZhc2NyaXB0XCJ9KSk6dD09PWI/bnVsbCE9eT95OihudWxsIT1nP2c6ZSkrbTplK3R9O2lmKG8paWYoXCJ1bmRlZmluZWRcIj09dHlwZW9mIEJsb2IpaS5tYWluU2NyaXB0VXJsT3JCbG9iPXMuam9pbihfX2Rpcm5hbWUsXCJvcnQtd2FzbS10aHJlYWRlZC5qc1wiKTtlbHNle2NvbnN0IHQ9YHZhciBvcnRXYXNtVGhyZWFkZWQ9KGZ1bmN0aW9uKCl7dmFyIF9zY3JpcHREaXI7cmV0dXJuICR7ci50b1N0cmluZygpfX0pKCk7YDtpLm1haW5TY3JpcHRVcmxPckJsb2I9bmV3IEJsb2IoW3RdLHt0eXBlOlwidGV4dC9qYXZhc2NyaXB0XCJ9KX1yKGkpLnRoZW4oKGU9PntmPSExLHA9ITAsbD1lLHQoKX0pLCh0PT57Zj0hMSxkPSEwLGUodCl9KSl9KSkpLGF3YWl0IFByb21pc2UucmFjZSh2KSxfKXRocm93IG5ldyBFcnJvcihgV2ViQXNzZW1ibHkgYmFja2VuZCBpbml0aWFsaXppbmcgZmFpbGVkIGR1ZSB0byB0aW1lb3V0OiAke2V9bXNgKX0sZS5nZXRJbnN0YW5jZT0oKT0+e2lmKHAmJmwpcmV0dXJuIGw7dGhyb3cgbmV3IEVycm9yKFwiV2ViQXNzZW1ibHkgaXMgbm90IGluaXRpYWxpemVkIHlldC5cIil9LGUuZGlzcG9zZT0oKT0+e3ZhciB0OyFwfHxmfHxkfHwoZj0hMCxudWxsPT09KHQ9bC5QVGhyZWFkKXx8dm9pZCAwPT09dHx8dC50ZXJtaW5hdGVBbGxUaHJlYWRzKCksbD12b2lkIDAsZj0hMSxwPSExLGQ9ITApfX0sOTcxMDoodCxlLG4pPT57XCJ1c2Ugc3RyaWN0XCI7bi5kKGUse1o6KCk9Pm99KTt2YXIgcj1uKDQ3NyksaT1uLm4ocik7ZnVuY3Rpb24gbygpe3JldHVybiBpKCkoJy8qIVxcbiogT05OWCBSdW50aW1lIFdlYiB2MS4xNC4wXFxuKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cXG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cXG4qL1xcbigoKT0+e3ZhciB0PXs0NzQ6KHQsZSxuKT0+e3ZhciBfc2NyaXB0RGlyLHI9KF9zY3JpcHREaXI9KF9zY3JpcHREaXI9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGRvY3VtZW50JiZkb2N1bWVudC5jdXJyZW50U2NyaXB0P2RvY3VtZW50LmN1cnJlbnRTY3JpcHQuc3JjOnZvaWQgMCl8fF9fZmlsZW5hbWUsZnVuY3Rpb24odCl7ZnVuY3Rpb24gZSgpe3JldHVybiBrLmJ1ZmZlciE9RCYmTihrLmJ1ZmZlciksUH1mdW5jdGlvbiByKCl7cmV0dXJuIGsuYnVmZmVyIT1EJiZOKGsuYnVmZmVyKSxVfWZ1bmN0aW9uIGEoKXtyZXR1cm4gay5idWZmZXIhPUQmJk4oay5idWZmZXIpLEZ9ZnVuY3Rpb24gaSgpe3JldHVybiBrLmJ1ZmZlciE9RCYmTihrLmJ1ZmZlciksSX1mdW5jdGlvbiBvKCl7cmV0dXJuIGsuYnVmZmVyIT1EJiZOKGsuYnVmZmVyKSxXfXZhciB1LHMsYzt0PXR8fHt9LHV8fCh1PXZvaWQgMCE9PXQ/dDp7fSksdS5yZWFkeT1uZXcgUHJvbWlzZSgoZnVuY3Rpb24odCxlKXtzPXQsYz1lfSkpO3ZhciBsLGYscCxoLGQseSxiPU9iamVjdC5hc3NpZ24oe30sdSksbT1cIi4vdGhpcy5wcm9ncmFtXCIsZz0odCxlKT0+e3Rocm93IGV9LHY9XCJvYmplY3RcIj09dHlwZW9mIHdpbmRvdyxfPVwiZnVuY3Rpb25cIj09dHlwZW9mIGltcG9ydFNjcmlwdHMsdz1cIm9iamVjdFwiPT10eXBlb2YgcHJvY2VzcyYmXCJvYmplY3RcIj09dHlwZW9mIHByb2Nlc3MudmVyc2lvbnMmJlwic3RyaW5nXCI9PXR5cGVvZiBwcm9jZXNzLnZlcnNpb25zLm5vZGUsTz11LkVOVklST05NRU5UX0lTX1BUSFJFQUR8fCExLEE9XCJcIjtmdW5jdGlvbiBTKHQpe3JldHVybiB1LmxvY2F0ZUZpbGU/dS5sb2NhdGVGaWxlKHQsQSk6QSt0fWlmKHcpe2xldCBlO0E9Xz9uKDE3KS5kaXJuYW1lKEEpK1wiL1wiOl9fZGlybmFtZStcIi9cIix5PSgpPT57ZHx8KGg9bigxNDcpLGQ9bigxNykpfSxsPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHkoKSx0PWQubm9ybWFsaXplKHQpLGgucmVhZEZpbGVTeW5jKHQsZT92b2lkIDA6XCJ1dGY4XCIpfSxwPXQ9PigodD1sKHQsITApKS5idWZmZXJ8fCh0PW5ldyBVaW50OEFycmF5KHQpKSx0KSxmPSh0LGUsbik9Pnt5KCksdD1kLm5vcm1hbGl6ZSh0KSxoLnJlYWRGaWxlKHQsKGZ1bmN0aW9uKHQscil7dD9uKHQpOmUoci5idWZmZXIpfSkpfSwxPHByb2Nlc3MuYXJndi5sZW5ndGgmJihtPXByb2Nlc3MuYXJndlsxXS5yZXBsYWNlKC9cXFxcXFxcXC9nLFwiL1wiKSkscHJvY2Vzcy5hcmd2LnNsaWNlKDIpLHByb2Nlc3Mub24oXCJ1bmNhdWdodEV4Y2VwdGlvblwiLChmdW5jdGlvbih0KXtpZighKHQgaW5zdGFuY2VvZiBzdCkpdGhyb3cgdH0pKSxwcm9jZXNzLm9uKFwidW5oYW5kbGVkUmVqZWN0aW9uXCIsKGZ1bmN0aW9uKHQpe3Rocm93IHR9KSksZz0odCxlKT0+e2lmKFEoKSl0aHJvdyBwcm9jZXNzLmV4aXRDb2RlPXQsZTtlIGluc3RhbmNlb2Ygc3R8fHgoXCJleGl0aW5nIGR1ZSB0byBleGNlcHRpb246IFwiK2UpLHByb2Nlc3MuZXhpdCh0KX0sdS5pbnNwZWN0PWZ1bmN0aW9uKCl7cmV0dXJuXCJbRW1zY3JpcHRlbiBNb2R1bGUgb2JqZWN0XVwifTt0cnl7ZT1uKDI2Nyl9Y2F0Y2godCl7dGhyb3cgY29uc29sZS5lcnJvcihcXCdUaGUgXCJ3b3JrZXJfdGhyZWFkc1wiIG1vZHVsZSBpcyBub3Qgc3VwcG9ydGVkIGluIHRoaXMgbm9kZS5qcyBidWlsZCAtIHBlcmhhcHMgYSBuZXdlciB2ZXJzaW9uIGlzIG5lZWRlZD9cXCcpLHR9Z2xvYmFsLldvcmtlcj1lLldvcmtlcn1lbHNlKHZ8fF8pJiYoXz9BPXNlbGYubG9jYXRpb24uaHJlZjpcInVuZGVmaW5lZFwiIT10eXBlb2YgZG9jdW1lbnQmJmRvY3VtZW50LmN1cnJlbnRTY3JpcHQmJihBPWRvY3VtZW50LmN1cnJlbnRTY3JpcHQuc3JjKSxfc2NyaXB0RGlyJiYoQT1fc2NyaXB0RGlyKSxBPTAhPT1BLmluZGV4T2YoXCJibG9iOlwiKT9BLnN1YnN0cigwLEEucmVwbGFjZSgvWz8jXS4qLyxcIlwiKS5sYXN0SW5kZXhPZihcIi9cIikrMSk6XCJcIix3fHwobD10PT57dmFyIGU9bmV3IFhNTEh0dHBSZXF1ZXN0O3JldHVybiBlLm9wZW4oXCJHRVRcIix0LCExKSxlLnNlbmQobnVsbCksZS5yZXNwb25zZVRleHR9LF8mJihwPXQ9Pnt2YXIgZT1uZXcgWE1MSHR0cFJlcXVlc3Q7cmV0dXJuIGUub3BlbihcIkdFVFwiLHQsITEpLGUucmVzcG9uc2VUeXBlPVwiYXJyYXlidWZmZXJcIixlLnNlbmQobnVsbCksbmV3IFVpbnQ4QXJyYXkoZS5yZXNwb25zZSl9KSxmPSh0LGUsbik9Pnt2YXIgcj1uZXcgWE1MSHR0cFJlcXVlc3Q7ci5vcGVuKFwiR0VUXCIsdCwhMCksci5yZXNwb25zZVR5cGU9XCJhcnJheWJ1ZmZlclwiLHIub25sb2FkPSgpPT57MjAwPT1yLnN0YXR1c3x8MD09ci5zdGF0dXMmJnIucmVzcG9uc2U/ZShyLnJlc3BvbnNlKTpuKCl9LHIub25lcnJvcj1uLHIuc2VuZChudWxsKX0pKTt3JiZcInVuZGVmaW5lZFwiPT10eXBlb2YgcGVyZm9ybWFuY2UmJihnbG9iYWwucGVyZm9ybWFuY2U9big3NCkucGVyZm9ybWFuY2UpO3ZhciBUPWNvbnNvbGUubG9nLmJpbmQoY29uc29sZSksRT1jb25zb2xlLndhcm4uYmluZChjb25zb2xlKTt3JiYoeSgpLFQ9dD0+aC53cml0ZVN5bmMoMSx0K1wiXFxcXG5cIiksRT10PT5oLndyaXRlU3luYygyLHQrXCJcXFxcblwiKSk7dmFyIE0sQz11LnByaW50fHxULHg9dS5wcmludEVycnx8RTtPYmplY3QuYXNzaWduKHUsYiksYj1udWxsLHUudGhpc1Byb2dyYW0mJihtPXUudGhpc1Byb2dyYW0pLHUucXVpdCYmKGc9dS5xdWl0KSx1Lndhc21CaW5hcnkmJihNPXUud2FzbUJpbmFyeSk7dmFyIFI9dS5ub0V4aXRSdW50aW1lfHwhMTtcIm9iamVjdFwiIT10eXBlb2YgV2ViQXNzZW1ibHkmJmF0KFwibm8gbmF0aXZlIHdhc20gc3VwcG9ydCBkZXRlY3RlZFwiKTt2YXIgayxqLEQsUCxVLEYsSSxXLEg9ITEsej1cInVuZGVmaW5lZFwiIT10eXBlb2YgVGV4dERlY29kZXI/bmV3IFRleHREZWNvZGVyKFwidXRmOFwiKTp2b2lkIDA7ZnVuY3Rpb24gTCh0LGUsbil7dmFyIHI9KGU+Pj49MCkrbjtmb3Iobj1lO3Rbbl0mJiEobj49cik7KSsrbjtpZigxNjxuLWUmJnQuYnVmZmVyJiZ6KXJldHVybiB6LmRlY29kZSh0LmJ1ZmZlciBpbnN0YW5jZW9mIFNoYXJlZEFycmF5QnVmZmVyP3Quc2xpY2UoZSxuKTp0LnN1YmFycmF5KGUsbikpO2ZvcihyPVwiXCI7ZTxuOyl7dmFyIGE9dFtlKytdO2lmKDEyOCZhKXt2YXIgaT02MyZ0W2UrK107aWYoMTkyPT0oMjI0JmEpKXIrPVN0cmluZy5mcm9tQ2hhckNvZGUoKDMxJmEpPDw2fGkpO2Vsc2V7dmFyIG89NjMmdFtlKytdOzY1NTM2PihhPTIyND09KDI0MCZhKT8oMTUmYSk8PDEyfGk8PDZ8bzooNyZhKTw8MTh8aTw8MTJ8bzw8Nnw2MyZ0W2UrK10pP3IrPVN0cmluZy5mcm9tQ2hhckNvZGUoYSk6KGEtPTY1NTM2LHIrPVN0cmluZy5mcm9tQ2hhckNvZGUoNTUyOTZ8YT4+MTAsNTYzMjB8MTAyMyZhKSl9fWVsc2Ugcis9U3RyaW5nLmZyb21DaGFyQ29kZShhKX1yZXR1cm4gcn1mdW5jdGlvbiBZKHQsZSl7cmV0dXJuKHQ+Pj49MCk/TChyKCksdCxlKTpcIlwifWZ1bmN0aW9uIEIodCxlLG4scil7aWYoISgwPHIpKXJldHVybiAwO3ZhciBhPW4+Pj49MDtyPW4rci0xO2Zvcih2YXIgaT0wO2k8dC5sZW5ndGg7KytpKXt2YXIgbz10LmNoYXJDb2RlQXQoaSk7aWYoNTUyOTY8PW8mJjU3MzQzPj1vJiYobz02NTUzNisoKDEwMjMmbyk8PDEwKXwxMDIzJnQuY2hhckNvZGVBdCgrK2kpKSwxMjc+PW8pe2lmKG4+PXIpYnJlYWs7ZVtuKys+Pj4wXT1vfWVsc2V7aWYoMjA0Nz49byl7aWYobisxPj1yKWJyZWFrO2VbbisrPj4+MF09MTkyfG8+PjZ9ZWxzZXtpZig2NTUzNT49byl7aWYobisyPj1yKWJyZWFrO2VbbisrPj4+MF09MjI0fG8+PjEyfWVsc2V7aWYobiszPj1yKWJyZWFrO2VbbisrPj4+MF09MjQwfG8+PjE4LGVbbisrPj4+MF09MTI4fG8+PjEyJjYzfWVbbisrPj4+MF09MTI4fG8+PjYmNjN9ZVtuKys+Pj4wXT0xMjh8NjMmb319cmV0dXJuIGVbbj4+PjBdPTAsbi1hfWZ1bmN0aW9uIEcodCl7Zm9yKHZhciBlPTAsbj0wO248dC5sZW5ndGg7KytuKXt2YXIgcj10LmNoYXJDb2RlQXQobik7MTI3Pj1yP2UrKzoyMDQ3Pj1yP2UrPTI6NTUyOTY8PXImJjU3MzQzPj1yPyhlKz00LCsrbik6ZSs9M31yZXR1cm4gZX1mdW5jdGlvbiBOKHQpe0Q9dCx1LkhFQVA4PVA9bmV3IEludDhBcnJheSh0KSx1LkhFQVAxNj1uZXcgSW50MTZBcnJheSh0KSx1LkhFQVAzMj1GPW5ldyBJbnQzMkFycmF5KHQpLHUuSEVBUFU4PVU9bmV3IFVpbnQ4QXJyYXkodCksdS5IRUFQVTE2PW5ldyBVaW50MTZBcnJheSh0KSx1LkhFQVBVMzI9ST1uZXcgVWludDMyQXJyYXkodCksdS5IRUFQRjMyPW5ldyBGbG9hdDMyQXJyYXkodCksdS5IRUFQRjY0PVc9bmV3IEZsb2F0NjRBcnJheSh0KX1PJiYoRD11LmJ1ZmZlcik7dmFyIFY9dS5JTklUSUFMX01FTU9SWXx8MTY3NzcyMTY7aWYoTylrPXUud2FzbU1lbW9yeSxEPXUuYnVmZmVyO2Vsc2UgaWYodS53YXNtTWVtb3J5KWs9dS53YXNtTWVtb3J5O2Vsc2UgaWYoISgoaz1uZXcgV2ViQXNzZW1ibHkuTWVtb3J5KHtpbml0aWFsOlYvNjU1MzYsbWF4aW11bTo2NTUzNixzaGFyZWQ6ITB9KSkuYnVmZmVyIGluc3RhbmNlb2YgU2hhcmVkQXJyYXlCdWZmZXIpKXRocm93IHgoXCJyZXF1ZXN0ZWQgYSBzaGFyZWQgV2ViQXNzZW1ibHkuTWVtb3J5IGJ1dCB0aGUgcmV0dXJuZWQgYnVmZmVyIGlzIG5vdCBhIFNoYXJlZEFycmF5QnVmZmVyLCBpbmRpY2F0aW5nIHRoYXQgd2hpbGUgdGhlIGJyb3dzZXIgaGFzIFNoYXJlZEFycmF5QnVmZmVyIGl0IGRvZXMgbm90IGhhdmUgV2ViQXNzZW1ibHkgdGhyZWFkcyBzdXBwb3J0IC0geW91IG1heSBuZWVkIHRvIHNldCBhIGZsYWdcIiksdyYmY29uc29sZS5sb2coXCIob24gbm9kZSB5b3UgbWF5IG5lZWQ6IC0tZXhwZXJpbWVudGFsLXdhc20tdGhyZWFkcyAtLWV4cGVyaW1lbnRhbC13YXNtLWJ1bGstbWVtb3J5IGFuZCBhbHNvIHVzZSBhIHJlY2VudCB2ZXJzaW9uKVwiKSxFcnJvcihcImJhZCBtZW1vcnlcIik7ayYmKEQ9ay5idWZmZXIpLFY9RC5ieXRlTGVuZ3RoLE4oRCk7dmFyIHEsJD1bXSxYPVtdLEo9W10sWj1bXTtmdW5jdGlvbiBRKCl7cmV0dXJuIFJ8fCExfWZ1bmN0aW9uIEsoKXt2YXIgdD11LnByZVJ1bi5zaGlmdCgpOyQudW5zaGlmdCh0KX12YXIgdHQsZXQ9MCxudD1udWxsLHJ0PW51bGw7ZnVuY3Rpb24gYXQodCl7dGhyb3cgTz9wb3N0TWVzc2FnZSh7Y21kOlwib25BYm9ydFwiLGFyZzp0fSk6dS5vbkFib3J0JiZ1Lm9uQWJvcnQodCkseCh0PVwiQWJvcnRlZChcIit0K1wiKVwiKSxIPSEwLHQ9bmV3IFdlYkFzc2VtYmx5LlJ1bnRpbWVFcnJvcih0K1wiLiBCdWlsZCB3aXRoIC1zQVNTRVJUSU9OUyBmb3IgbW9yZSBpbmZvLlwiKSxjKHQpLHR9ZnVuY3Rpb24gaXQoKXtyZXR1cm4gdHQuc3RhcnRzV2l0aChcImRhdGE6YXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtO2Jhc2U2NCxcIil9ZnVuY3Rpb24gb3QoKXt2YXIgdD10dDt0cnl7aWYodD09dHQmJk0pcmV0dXJuIG5ldyBVaW50OEFycmF5KE0pO2lmKHApcmV0dXJuIHAodCk7dGhyb3dcImJvdGggYXN5bmMgYW5kIHN5bmMgZmV0Y2hpbmcgb2YgdGhlIHdhc20gZmFpbGVkXCJ9Y2F0Y2godCl7YXQodCl9fXR0PVwib3J0LXdhc20tdGhyZWFkZWQud2FzbVwiLGl0KCl8fCh0dD1TKHR0KSk7dmFyIHV0PXt9O2Z1bmN0aW9uIHN0KHQpe3RoaXMubmFtZT1cIkV4aXRTdGF0dXNcIix0aGlzLm1lc3NhZ2U9XCJQcm9ncmFtIHRlcm1pbmF0ZWQgd2l0aCBleGl0KFwiK3QrXCIpXCIsdGhpcy5zdGF0dXM9dH1mdW5jdGlvbiBjdCh0KXsodD1odC5WYlt0XSl8fGF0KCksaHQubWModCl9ZnVuY3Rpb24gbHQodCl7dmFyIGU9aHQuQ2MoKTtpZighZSlyZXR1cm4gNjtodC5hYy5wdXNoKGUpLGh0LlZiW3QuVWJdPWUsZS5VYj10LlViO3ZhciBuPXtjbWQ6XCJydW5cIixzdGFydF9yb3V0aW5lOnQuSWMsYXJnOnQuemMscHRocmVhZF9wdHI6dC5VYn07cmV0dXJuIGUuJGI9KCk9PntuLnRpbWU9cGVyZm9ybWFuY2Uubm93KCksZS5wb3N0TWVzc2FnZShuLHQuTmMpfSxlLmxvYWRlZCYmKGUuJGIoKSxkZWxldGUgZS4kYiksMH1mdW5jdGlvbiBmdCh0KXtpZihPKXJldHVybiBxdCgxLDEsdCk7USgpfHwoaHQub2MoKSx1Lm9uRXhpdCYmdS5vbkV4aXQodCksSD0hMCksZyh0LG5ldyBzdCh0KSl9ZnVuY3Rpb24gcHQodCxlKXtpZighZSYmTyl0aHJvdyBidCh0KSxcInVud2luZFwiO1EoKXx8T3x8KG1lKCksZHQoSiksYmUoMCkscmVbMV0ubGVuZ3RoJiZhZSgxLDEwKSxyZVsyXS5sZW5ndGgmJmFlKDIsMTApLGh0Lm9jKCkpLGZ0KHQpfXZhciBodD17WWI6W10sYWM6W10scWM6W10sVmI6e30sZmM6ZnVuY3Rpb24oKXtPJiZodC5FYygpfSxQYzpmdW5jdGlvbigpe30sRWM6ZnVuY3Rpb24oKXtodC5yZWNlaXZlT2JqZWN0VHJhbnNmZXI9aHQuR2MsaHQudGhyZWFkSW5pdFRMUz1odC5wYyxodC5zZXRFeGl0U3RhdHVzPWh0Lm5jLFI9ITF9LG5jOmZ1bmN0aW9uKCl7fSxvYzpmdW5jdGlvbigpe2Zvcih2YXIgdCBvZiBPYmplY3QudmFsdWVzKGh0LlZiKSlodC5tYyh0KTtmb3IodCBvZiBodC5ZYil0LnRlcm1pbmF0ZSgpO2h0LlliPVtdfSxtYzpmdW5jdGlvbih0KXt2YXIgZT10LlViO2RlbGV0ZSBodC5WYltlXSxodC5ZYi5wdXNoKHQpLGh0LmFjLnNwbGljZShodC5hYy5pbmRleE9mKHQpLDEpLHQuVWI9MCxPZShlKX0sR2M6ZnVuY3Rpb24oKXt9LHBjOmZ1bmN0aW9uKCl7aHQucWMuZm9yRWFjaCgodD0+dCgpKSl9LEZjOmZ1bmN0aW9uKHQsZSl7dC5vbm1lc3NhZ2U9bj0+e3ZhciByPShuPW4uZGF0YSkuY21kO2lmKHQuVWImJihodC5CYz10LlViKSxuLnRhcmdldFRocmVhZCYmbi50YXJnZXRUaHJlYWQhPWhlKCkpe3ZhciBhPWh0LlZiW24uUWNdO2E/YS5wb3N0TWVzc2FnZShuLG4udHJhbnNmZXJMaXN0KTp4KFxcJ0ludGVybmFsIGVycm9yISBXb3JrZXIgc2VudCBhIG1lc3NhZ2UgXCJcXCcrcitcXCdcIiB0byB0YXJnZXQgcHRocmVhZCBcXCcrbi50YXJnZXRUaHJlYWQrXCIsIGJ1dCB0aGF0IHRocmVhZCBubyBsb25nZXIgZXhpc3RzIVwiKX1lbHNlXCJwcm9jZXNzUHJveHlpbmdRdWV1ZVwiPT09cj9MdChuLnF1ZXVlKTpcInNwYXduVGhyZWFkXCI9PT1yP2x0KG4pOlwiY2xlYW51cFRocmVhZFwiPT09cj9jdChuLnRocmVhZCk6XCJraWxsVGhyZWFkXCI9PT1yPyhuPW4udGhyZWFkLHI9aHQuVmJbbl0sZGVsZXRlIGh0LlZiW25dLHIudGVybWluYXRlKCksT2UobiksaHQuYWMuc3BsaWNlKGh0LmFjLmluZGV4T2YociksMSksci5VYj0wKTpcImNhbmNlbFRocmVhZFwiPT09cj9odC5WYltuLnRocmVhZF0ucG9zdE1lc3NhZ2Uoe2NtZDpcImNhbmNlbFwifSk6XCJsb2FkZWRcIj09PXI/KHQubG9hZGVkPSEwLGUmJmUodCksdC4kYiYmKHQuJGIoKSxkZWxldGUgdC4kYikpOlwicHJpbnRcIj09PXI/QyhcIlRocmVhZCBcIituLnRocmVhZElkK1wiOiBcIituLnRleHQpOlwicHJpbnRFcnJcIj09PXI/eChcIlRocmVhZCBcIituLnRocmVhZElkK1wiOiBcIituLnRleHQpOlwiYWxlcnRcIj09PXI/YWxlcnQoXCJUaHJlYWQgXCIrbi50aHJlYWRJZCtcIjogXCIrbi50ZXh0KTpcInNldGltbWVkaWF0ZVwiPT09bi50YXJnZXQ/dC5wb3N0TWVzc2FnZShuKTpcIm9uQWJvcnRcIj09PXI/dS5vbkFib3J0JiZ1Lm9uQWJvcnQobi5hcmcpOnImJngoXCJ3b3JrZXIgc2VudCBhbiB1bmtub3duIGNvbW1hbmQgXCIrcik7aHQuQmM9dm9pZCAwfSx0Lm9uZXJyb3I9dD0+e3Rocm93IHgoXCJ3b3JrZXIgc2VudCBhbiBlcnJvciEgXCIrdC5maWxlbmFtZStcIjpcIit0LmxpbmVubytcIjogXCIrdC5tZXNzYWdlKSx0fSx3JiYodC5vbihcIm1lc3NhZ2VcIiwoZnVuY3Rpb24oZSl7dC5vbm1lc3NhZ2Uoe2RhdGE6ZX0pfSkpLHQub24oXCJlcnJvclwiLChmdW5jdGlvbihlKXt0Lm9uZXJyb3IoZSl9KSksdC5vbihcImRldGFjaGVkRXhpdFwiLChmdW5jdGlvbigpe30pKSksdC5wb3N0TWVzc2FnZSh7Y21kOlwibG9hZFwiLHVybE9yQmxvYjp1Lm1haW5TY3JpcHRVcmxPckJsb2J8fF9zY3JpcHREaXIsd2FzbU1lbW9yeTprLHdhc21Nb2R1bGU6an0pfSx5YzpmdW5jdGlvbigpe3ZhciB0PVMoXCJvcnQtd2FzbS10aHJlYWRlZC53b3JrZXIuanNcIik7aHQuWWIucHVzaChuZXcgV29ya2VyKHQpKX0sQ2M6ZnVuY3Rpb24oKXtyZXR1cm4gMD09aHQuWWIubGVuZ3RoJiYoaHQueWMoKSxodC5GYyhodC5ZYlswXSkpLGh0LlliLnBvcCgpfX07ZnVuY3Rpb24gZHQodCl7Zm9yKDswPHQubGVuZ3RoOyl0LnNoaWZ0KCkodSl9ZnVuY3Rpb24geXQodCl7dmFyIGU9RWUoKTtyZXR1cm4gdD10KCksTWUoZSksdH1mdW5jdGlvbiBidCh0KXtpZihPKXJldHVybiBxdCgyLDAsdCk7dHJ5e3B0KHQpfWNhdGNoKHQpe3QgaW5zdGFuY2VvZiBzdHx8XCJ1bndpbmRcIj09dHx8ZygxLHQpfX11LlBUaHJlYWQ9aHQsdS5lc3RhYmxpc2hTdGFja1NwYWNlPWZ1bmN0aW9uKCl7dmFyIHQ9aGUoKSxlPWEoKVt0KzQ0Pj4yPj4+MF07dD1hKClbdCs0OD4+Mj4+PjBdLFRlKGUsZS10KSxNZShlKX07dmFyIG10PVtdO2Z1bmN0aW9uIGd0KHQpe3ZhciBlPW10W3RdO3JldHVybiBlfHwodD49bXQubGVuZ3RoJiYobXQubGVuZ3RoPXQrMSksbXRbdF09ZT1xLmdldCh0KSksZX11Lmludm9rZUVudHJ5UG9pbnQ9ZnVuY3Rpb24odCxlKXt0PWd0KHQpKGUpLFEoKT9odC5uYyh0KTpBZSh0KX07dmFyIHZ0LF90LHd0PVtdLE90PTAsQXQ9MDtmdW5jdGlvbiBTdCh0KXt0aGlzLlpiPXQsdGhpcy5TYj10LTI0LHRoaXMueGM9ZnVuY3Rpb24odCl7aSgpW3RoaXMuU2IrND4+Mj4+PjBdPXR9LHRoaXMuYmM9ZnVuY3Rpb24oKXtyZXR1cm4gaSgpW3RoaXMuU2IrND4+Mj4+PjBdfSx0aGlzLndjPWZ1bmN0aW9uKHQpe2koKVt0aGlzLlNiKzg+PjI+Pj4wXT10fSx0aGlzLkRjPWZ1bmN0aW9uKCl7cmV0dXJuIGkoKVt0aGlzLlNiKzg+PjI+Pj4wXX0sdGhpcy5yYz1mdW5jdGlvbigpe2EoKVt0aGlzLlNiPj4yPj4+MF09MH0sdGhpcy5oYz1mdW5jdGlvbih0KXt0PXQ/MTowLGUoKVt0aGlzLlNiKzEyPj4wPj4+MF09dH0sdGhpcy51Yz1mdW5jdGlvbigpe3JldHVybiAwIT1lKClbdGhpcy5TYisxMj4+MD4+PjBdfSx0aGlzLmljPWZ1bmN0aW9uKHQpe3Q9dD8xOjAsZSgpW3RoaXMuU2IrMTM+PjA+Pj4wXT10fSx0aGlzLmtjPWZ1bmN0aW9uKCl7cmV0dXJuIDAhPWUoKVt0aGlzLlNiKzEzPj4wPj4+MF19LHRoaXMuZmM9ZnVuY3Rpb24odCxlKXt0aGlzLmNjKDApLHRoaXMueGModCksdGhpcy53YyhlKSx0aGlzLnJjKCksdGhpcy5oYyghMSksdGhpcy5pYyghMSl9LHRoaXMuc2M9ZnVuY3Rpb24oKXtBdG9taWNzLmFkZChhKCksdGhpcy5TYj4+MiwxKX0sdGhpcy5IYz1mdW5jdGlvbigpe3JldHVybiAxPT09QXRvbWljcy5zdWIoYSgpLHRoaXMuU2I+PjIsMSl9LHRoaXMuY2M9ZnVuY3Rpb24odCl7aSgpW3RoaXMuU2IrMTY+PjI+Pj4wXT10fSx0aGlzLnRjPWZ1bmN0aW9uKCl7cmV0dXJuIGkoKVt0aGlzLlNiKzE2Pj4yPj4+MF19LHRoaXMudmM9ZnVuY3Rpb24oKXtpZihSZSh0aGlzLmJjKCkpKXJldHVybiBpKClbdGhpcy5aYj4+Mj4+PjBdO3ZhciB0PXRoaXMudGMoKTtyZXR1cm4gMCE9PXQ/dDp0aGlzLlpifX1mdW5jdGlvbiBUdCh0KXtyZXR1cm4geWUobmV3IFN0KHQpLlNiKX1mdW5jdGlvbiBFdCh0LGUsbixyKXtyZXR1cm4gTz9xdCgzLDEsdCxlLG4scik6TXQodCxlLG4scil9ZnVuY3Rpb24gTXQodCxlLG4scil7aWYoXCJ1bmRlZmluZWRcIj09dHlwZW9mIFNoYXJlZEFycmF5QnVmZmVyKXJldHVybiB4KFwiQ3VycmVudCBlbnZpcm9ubWVudCBkb2VzIG5vdCBzdXBwb3J0IFNoYXJlZEFycmF5QnVmZmVyLCBwdGhyZWFkcyBhcmUgbm90IGF2YWlsYWJsZSFcIiksNjt2YXIgYT1bXTtyZXR1cm4gTyYmMD09PWEubGVuZ3RoP0V0KHQsZSxuLHIpOih0PXtJYzpuLFViOnQsemM6cixOYzphfSxPPyh0Lk9jPVwic3Bhd25UaHJlYWRcIixwb3N0TWVzc2FnZSh0LGEpLDApOmx0KHQpKX1mdW5jdGlvbiBDdCh0LGUsbil7cmV0dXJuIE8/cXQoNCwxLHQsZSxuKTowfWZ1bmN0aW9uIHh0KHQsZSl7aWYoTylyZXR1cm4gcXQoNSwxLHQsZSl9ZnVuY3Rpb24gUnQodCxlKXtpZihPKXJldHVybiBxdCg2LDEsdCxlKX1mdW5jdGlvbiBrdCh0LGUsbil7aWYoTylyZXR1cm4gcXQoNywxLHQsZSxuKX1mdW5jdGlvbiBqdCh0LGUsbil7cmV0dXJuIE8/cXQoOCwxLHQsZSxuKTowfWZ1bmN0aW9uIER0KHQsZSl7aWYoTylyZXR1cm4gcXQoOSwxLHQsZSl9ZnVuY3Rpb24gUHQodCxlLG4pe2lmKE8pcmV0dXJuIHF0KDEwLDEsdCxlLG4pfWZ1bmN0aW9uIFV0KHQsZSxuLHIpe2lmKE8pcmV0dXJuIHF0KDExLDEsdCxlLG4scil9ZnVuY3Rpb24gRnQodCxlLG4scil7aWYoTylyZXR1cm4gcXQoMTIsMSx0LGUsbixyKX1mdW5jdGlvbiBJdCh0LGUsbixyKXtpZihPKXJldHVybiBxdCgxMywxLHQsZSxuLHIpfWZ1bmN0aW9uIFd0KHQpe2lmKE8pcmV0dXJuIHF0KDE0LDEsdCl9ZnVuY3Rpb24gSHQodCxlKXtpZihPKXJldHVybiBxdCgxNSwxLHQsZSl9ZnVuY3Rpb24genQodCxlLG4pe2lmKE8pcmV0dXJuIHF0KDE2LDEsdCxlLG4pfWZ1bmN0aW9uIEx0KHQpe0F0b21pY3Muc3RvcmUoYSgpLHQ+PjIsMSksaGUoKSYmd2UodCksQXRvbWljcy5jb21wYXJlRXhjaGFuZ2UoYSgpLHQ+PjIsMSwwKX1mdW5jdGlvbiBZdCh0KXtyZXR1cm4gaSgpW3Q+Pj4yXSs0Mjk0OTY3Mjk2KmEoKVt0KzQ+Pj4yXX1mdW5jdGlvbiBCdCh0LGUsbixyLGEsaSl7cmV0dXJuIE8/cXQoMTcsMSx0LGUsbixyLGEsaSk6LTUyfWZ1bmN0aW9uIEd0KHQsZSxuLHIsYSxpKXtpZihPKXJldHVybiBxdCgxOCwxLHQsZSxuLHIsYSxpKX1mdW5jdGlvbiBOdCh0KXt2YXIgbj1HKHQpKzEscj1kZShuKTtyZXR1cm4gciYmQih0LGUoKSxyLG4pLHJ9ZnVuY3Rpb24gVnQodCxlLG4pe2Z1bmN0aW9uIHIodCl7cmV0dXJuKHQ9dC50b1RpbWVTdHJpbmcoKS5tYXRjaCgvXFxcXCgoW0EtWmEteiBdKylcXFxcKSQvKSk/dFsxXTpcIkdNVFwifWlmKE8pcmV0dXJuIHF0KDE5LDEsdCxlLG4pO3ZhciBvPShuZXcgRGF0ZSkuZ2V0RnVsbFllYXIoKSx1PW5ldyBEYXRlKG8sMCwxKSxzPW5ldyBEYXRlKG8sNiwxKTtvPXUuZ2V0VGltZXpvbmVPZmZzZXQoKTt2YXIgYz1zLmdldFRpbWV6b25lT2Zmc2V0KCksbD1NYXRoLm1heChvLGMpO2EoKVt0Pj4yPj4+MF09NjAqbCxhKClbZT4+Mj4+PjBdPU51bWJlcihvIT1jKSx0PXIodSksZT1yKHMpLHQ9TnQodCksZT1OdChlKSxjPG8/KGkoKVtuPj4yPj4+MF09dCxpKClbbis0Pj4yPj4+MF09ZSk6KGkoKVtuPj4yPj4+MF09ZSxpKClbbis0Pj4yPj4+MF09dCl9ZnVuY3Rpb24gcXQodCxlKXt2YXIgbj1hcmd1bWVudHMubGVuZ3RoLTIscj1hcmd1bWVudHM7cmV0dXJuIHl0KCgoKT0+e2Zvcih2YXIgYT1DZSg4Km4pLGk9YT4+Myx1PTA7dTxuO3UrKyl7dmFyIHM9clsyK3VdO28oKVtpK3U+Pj4wXT1zfXJldHVybiBfZSh0LG4sYSxlKX0pKX11LmV4ZWN1dGVOb3RpZmllZFByb3h5aW5nUXVldWU9THQsX3Q9dz8oKT0+e3ZhciB0PXByb2Nlc3MuaHJ0aW1lKCk7cmV0dXJuIDFlMyp0WzBdK3RbMV0vMWU2fTpPPygpPT5wZXJmb3JtYW5jZS5ub3coKS11Ll9fcGVyZm9ybWFuY2Vfbm93X2Nsb2NrX2RyaWZ0OigpPT5wZXJmb3JtYW5jZS5ub3coKTt2YXIgJHQsWHQ9W10sSnQ9e307ZnVuY3Rpb24gWnQoKXtpZighJHQpe3ZhciB0LGU9e1VTRVI6XCJ3ZWJfdXNlclwiLExPR05BTUU6XCJ3ZWJfdXNlclwiLFBBVEg6XCIvXCIsUFdEOlwiL1wiLEhPTUU6XCIvaG9tZS93ZWJfdXNlclwiLExBTkc6KFwib2JqZWN0XCI9PXR5cGVvZiBuYXZpZ2F0b3ImJm5hdmlnYXRvci5sYW5ndWFnZXMmJm5hdmlnYXRvci5sYW5ndWFnZXNbMF18fFwiQ1wiKS5yZXBsYWNlKFwiLVwiLFwiX1wiKStcIi5VVEYtOFwiLF86bXx8XCIuL3RoaXMucHJvZ3JhbVwifTtmb3IodCBpbiBKdCl2b2lkIDA9PT1KdFt0XT9kZWxldGUgZVt0XTplW3RdPUp0W3RdO3ZhciBuPVtdO2Zvcih0IGluIGUpbi5wdXNoKHQrXCI9XCIrZVt0XSk7JHQ9bn1yZXR1cm4gJHR9ZnVuY3Rpb24gUXQodCxuKXtpZihPKXJldHVybiBxdCgyMCwxLHQsbik7dmFyIHI9MDtyZXR1cm4gWnQoKS5mb3JFYWNoKChmdW5jdGlvbihhLG8pe3ZhciB1PW4rcjtmb3Iobz1pKClbdCs0Km8+PjI+Pj4wXT11LHU9MDt1PGEubGVuZ3RoOysrdSllKClbbysrPj4wPj4+MF09YS5jaGFyQ29kZUF0KHUpO2UoKVtvPj4wPj4+MF09MCxyKz1hLmxlbmd0aCsxfSkpLDB9ZnVuY3Rpb24gS3QodCxlKXtpZihPKXJldHVybiBxdCgyMSwxLHQsZSk7dmFyIG49WnQoKTtpKClbdD4+Mj4+PjBdPW4ubGVuZ3RoO3ZhciByPTA7cmV0dXJuIG4uZm9yRWFjaCgoZnVuY3Rpb24odCl7cis9dC5sZW5ndGgrMX0pKSxpKClbZT4+Mj4+PjBdPXIsMH1mdW5jdGlvbiB0ZSh0KXtyZXR1cm4gTz9xdCgyMiwxLHQpOjUyfWZ1bmN0aW9uIGVlKHQsZSxuLHIpe3JldHVybiBPP3F0KDIzLDEsdCxlLG4scik6NTJ9ZnVuY3Rpb24gbmUodCxlLG4scixhKXtyZXR1cm4gTz9xdCgyNCwxLHQsZSxuLHIsYSk6NzB9dmFyIHJlPVtudWxsLFtdLFtdXTtmdW5jdGlvbiBhZSh0LGUpe3ZhciBuPXJlW3RdOzA9PT1lfHwxMD09PWU/KCgxPT09dD9DOngpKEwobiwwKSksbi5sZW5ndGg9MCk6bi5wdXNoKGUpfWZ1bmN0aW9uIGllKHQsZSxuLGEpe2lmKE8pcmV0dXJuIHF0KDI1LDEsdCxlLG4sYSk7Zm9yKHZhciBvPTAsdT0wO3U8bjt1Kyspe3ZhciBzPWkoKVtlPj4yPj4+MF0sYz1pKClbZSs0Pj4yPj4+MF07ZSs9ODtmb3IodmFyIGw9MDtsPGM7bCsrKWFlKHQscigpW3MrbD4+PjBdKTtvKz1jfXJldHVybiBpKClbYT4+Mj4+PjBdPW8sMH12YXIgb2U9MDtmdW5jdGlvbiB1ZSh0KXtyZXR1cm4gMD09dCU0JiYoMCE9dCUxMDB8fDA9PXQlNDAwKX12YXIgc2U9WzMxLDI5LDMxLDMwLDMxLDMwLDMxLDMxLDMwLDMxLDMwLDMxXSxjZT1bMzEsMjgsMzEsMzAsMzEsMzAsMzEsMzEsMzAsMzEsMzAsMzFdO2Z1bmN0aW9uIGxlKHQsbixyLGkpe2Z1bmN0aW9uIG8odCxlLG4pe2Zvcih0PVwibnVtYmVyXCI9PXR5cGVvZiB0P3QudG9TdHJpbmcoKTp0fHxcIlwiO3QubGVuZ3RoPGU7KXQ9blswXSt0O3JldHVybiB0fWZ1bmN0aW9uIHUodCxlKXtyZXR1cm4gbyh0LGUsXCIwXCIpfWZ1bmN0aW9uIHModCxlKXtmdW5jdGlvbiBuKHQpe3JldHVybiAwPnQ/LTE6MDx0PzE6MH12YXIgcjtyZXR1cm4gMD09PShyPW4odC5nZXRGdWxsWWVhcigpLWUuZ2V0RnVsbFllYXIoKSkpJiYwPT09KHI9bih0LmdldE1vbnRoKCktZS5nZXRNb250aCgpKSkmJihyPW4odC5nZXREYXRlKCktZS5nZXREYXRlKCkpKSxyfWZ1bmN0aW9uIGModCl7c3dpdGNoKHQuZ2V0RGF5KCkpe2Nhc2UgMDpyZXR1cm4gbmV3IERhdGUodC5nZXRGdWxsWWVhcigpLTEsMTEsMjkpO2Nhc2UgMTpyZXR1cm4gdDtjYXNlIDI6cmV0dXJuIG5ldyBEYXRlKHQuZ2V0RnVsbFllYXIoKSwwLDMpO2Nhc2UgMzpyZXR1cm4gbmV3IERhdGUodC5nZXRGdWxsWWVhcigpLDAsMik7Y2FzZSA0OnJldHVybiBuZXcgRGF0ZSh0LmdldEZ1bGxZZWFyKCksMCwxKTtjYXNlIDU6cmV0dXJuIG5ldyBEYXRlKHQuZ2V0RnVsbFllYXIoKS0xLDExLDMxKTtjYXNlIDY6cmV0dXJuIG5ldyBEYXRlKHQuZ2V0RnVsbFllYXIoKS0xLDExLDMwKX19ZnVuY3Rpb24gbCh0KXt2YXIgZT10LldiO2Zvcih0PW5ldyBEYXRlKG5ldyBEYXRlKHQuWGIrMTkwMCwwLDEpLmdldFRpbWUoKSk7MDxlOyl7dmFyIG49dC5nZXRNb250aCgpLHI9KHVlKHQuZ2V0RnVsbFllYXIoKSk/c2U6Y2UpW25dO2lmKCEoZT5yLXQuZ2V0RGF0ZSgpKSl7dC5zZXREYXRlKHQuZ2V0RGF0ZSgpK2UpO2JyZWFrfWUtPXItdC5nZXREYXRlKCkrMSx0LnNldERhdGUoMSksMTE+bj90LnNldE1vbnRoKG4rMSk6KHQuc2V0TW9udGgoMCksdC5zZXRGdWxsWWVhcih0LmdldEZ1bGxZZWFyKCkrMSkpfXJldHVybiBuPW5ldyBEYXRlKHQuZ2V0RnVsbFllYXIoKSsxLDAsNCksZT1jKG5ldyBEYXRlKHQuZ2V0RnVsbFllYXIoKSwwLDQpKSxuPWMobiksMD49cyhlLHQpPzA+PXMobix0KT90LmdldEZ1bGxZZWFyKCkrMTp0LmdldEZ1bGxZZWFyKCk6dC5nZXRGdWxsWWVhcigpLTF9dmFyIGY9YSgpW2krNDA+PjI+Pj4wXTtmb3IodmFyIHAgaW4gaT17TGM6YSgpW2k+PjI+Pj4wXSxLYzphKClbaSs0Pj4yPj4+MF0sZGM6YSgpW2krOD4+Mj4+PjBdLGpjOmEoKVtpKzEyPj4yPj4+MF0sZWM6YSgpW2krMTY+PjI+Pj4wXSxYYjphKClbaSsyMD4+Mj4+PjBdLFRiOmEoKVtpKzI0Pj4yPj4+MF0sV2I6YSgpW2krMjg+PjI+Pj4wXSxSYzphKClbaSszMj4+Mj4+PjBdLEpjOmEoKVtpKzM2Pj4yPj4+MF0sTWM6Zj9ZKGYpOlwiXCJ9LHI9WShyKSxmPXtcIiVjXCI6XCIlYSAlYiAlZCAlSDolTTolUyAlWVwiLFwiJURcIjpcIiVtLyVkLyV5XCIsXCIlRlwiOlwiJVktJW0tJWRcIixcIiVoXCI6XCIlYlwiLFwiJXJcIjpcIiVJOiVNOiVTICVwXCIsXCIlUlwiOlwiJUg6JU1cIixcIiVUXCI6XCIlSDolTTolU1wiLFwiJXhcIjpcIiVtLyVkLyV5XCIsXCIlWFwiOlwiJUg6JU06JVNcIixcIiVFY1wiOlwiJWNcIixcIiVFQ1wiOlwiJUNcIixcIiVFeFwiOlwiJW0vJWQvJXlcIixcIiVFWFwiOlwiJUg6JU06JVNcIixcIiVFeVwiOlwiJXlcIixcIiVFWVwiOlwiJVlcIixcIiVPZFwiOlwiJWRcIixcIiVPZVwiOlwiJWVcIixcIiVPSFwiOlwiJUhcIixcIiVPSVwiOlwiJUlcIixcIiVPbVwiOlwiJW1cIixcIiVPTVwiOlwiJU1cIixcIiVPU1wiOlwiJVNcIixcIiVPdVwiOlwiJXVcIixcIiVPVVwiOlwiJVVcIixcIiVPVlwiOlwiJVZcIixcIiVPd1wiOlwiJXdcIixcIiVPV1wiOlwiJVdcIixcIiVPeVwiOlwiJXlcIn0pcj1yLnJlcGxhY2UobmV3IFJlZ0V4cChwLFwiZ1wiKSxmW3BdKTt2YXIgaD1cIlN1bmRheSBNb25kYXkgVHVlc2RheSBXZWRuZXNkYXkgVGh1cnNkYXkgRnJpZGF5IFNhdHVyZGF5XCIuc3BsaXQoXCIgXCIpLGQ9XCJKYW51YXJ5IEZlYnJ1YXJ5IE1hcmNoIEFwcmlsIE1heSBKdW5lIEp1bHkgQXVndXN0IFNlcHRlbWJlciBPY3RvYmVyIE5vdmVtYmVyIERlY2VtYmVyXCIuc3BsaXQoXCIgXCIpO2ZvcihwIGluIGY9e1wiJWFcIjpmdW5jdGlvbih0KXtyZXR1cm4gaFt0LlRiXS5zdWJzdHJpbmcoMCwzKX0sXCIlQVwiOmZ1bmN0aW9uKHQpe3JldHVybiBoW3QuVGJdfSxcIiViXCI6ZnVuY3Rpb24odCl7cmV0dXJuIGRbdC5lY10uc3Vic3RyaW5nKDAsMyl9LFwiJUJcIjpmdW5jdGlvbih0KXtyZXR1cm4gZFt0LmVjXX0sXCIlQ1wiOmZ1bmN0aW9uKHQpe3JldHVybiB1KCh0LlhiKzE5MDApLzEwMHwwLDIpfSxcIiVkXCI6ZnVuY3Rpb24odCl7cmV0dXJuIHUodC5qYywyKX0sXCIlZVwiOmZ1bmN0aW9uKHQpe3JldHVybiBvKHQuamMsMixcIiBcIil9LFwiJWdcIjpmdW5jdGlvbih0KXtyZXR1cm4gbCh0KS50b1N0cmluZygpLnN1YnN0cmluZygyKX0sXCIlR1wiOmZ1bmN0aW9uKHQpe3JldHVybiBsKHQpfSxcIiVIXCI6ZnVuY3Rpb24odCl7cmV0dXJuIHUodC5kYywyKX0sXCIlSVwiOmZ1bmN0aW9uKHQpe3JldHVybiAwPT0odD10LmRjKT90PTEyOjEyPHQmJih0LT0xMiksdSh0LDIpfSxcIiVqXCI6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPTAsbj0wO248PXQuZWMtMTtlKz0odWUodC5YYisxOTAwKT9zZTpjZSlbbisrXSk7cmV0dXJuIHUodC5qYytlLDMpfSxcIiVtXCI6ZnVuY3Rpb24odCl7cmV0dXJuIHUodC5lYysxLDIpfSxcIiVNXCI6ZnVuY3Rpb24odCl7cmV0dXJuIHUodC5LYywyKX0sXCIlblwiOmZ1bmN0aW9uKCl7cmV0dXJuXCJcXFxcblwifSxcIiVwXCI6ZnVuY3Rpb24odCl7cmV0dXJuIDA8PXQuZGMmJjEyPnQuZGM/XCJBTVwiOlwiUE1cIn0sXCIlU1wiOmZ1bmN0aW9uKHQpe3JldHVybiB1KHQuTGMsMil9LFwiJXRcIjpmdW5jdGlvbigpe3JldHVyblwiXFxcXHRcIn0sXCIldVwiOmZ1bmN0aW9uKHQpe3JldHVybiB0LlRifHw3fSxcIiVVXCI6ZnVuY3Rpb24odCl7cmV0dXJuIHUoTWF0aC5mbG9vcigodC5XYis3LXQuVGIpLzcpLDIpfSxcIiVWXCI6ZnVuY3Rpb24odCl7dmFyIGU9TWF0aC5mbG9vcigodC5XYis3LSh0LlRiKzYpJTcpLzcpO2lmKDI+PSh0LlRiKzM3MS10LldiLTIpJTcmJmUrKyxlKTUzPT1lJiYoND09KG49KHQuVGIrMzcxLXQuV2IpJTcpfHwzPT1uJiZ1ZSh0LlhiKXx8KGU9MSkpO2Vsc2V7ZT01Mjt2YXIgbj0odC5UYis3LXQuV2ItMSklNzsoND09bnx8NT09biYmdWUodC5YYiU0MDAtMSkpJiZlKyt9cmV0dXJuIHUoZSwyKX0sXCIld1wiOmZ1bmN0aW9uKHQpe3JldHVybiB0LlRifSxcIiVXXCI6ZnVuY3Rpb24odCl7cmV0dXJuIHUoTWF0aC5mbG9vcigodC5XYis3LSh0LlRiKzYpJTcpLzcpLDIpfSxcIiV5XCI6ZnVuY3Rpb24odCl7cmV0dXJuKHQuWGIrMTkwMCkudG9TdHJpbmcoKS5zdWJzdHJpbmcoMil9LFwiJVlcIjpmdW5jdGlvbih0KXtyZXR1cm4gdC5YYisxOTAwfSxcIiV6XCI6ZnVuY3Rpb24odCl7dmFyIGU9MDw9KHQ9dC5KYyk7cmV0dXJuIHQ9TWF0aC5hYnModCkvNjAsKGU/XCIrXCI6XCItXCIpK1N0cmluZyhcIjAwMDBcIisodC82MCoxMDArdCU2MCkpLnNsaWNlKC00KX0sXCIlWlwiOmZ1bmN0aW9uKHQpe3JldHVybiB0Lk1jfSxcIiUlXCI6ZnVuY3Rpb24oKXtyZXR1cm5cIiVcIn19LHI9ci5yZXBsYWNlKC8lJS9nLFwiXFxcXDBcXFxcMFwiKSxmKXIuaW5jbHVkZXMocCkmJihyPXIucmVwbGFjZShuZXcgUmVnRXhwKHAsXCJnXCIpLGZbcF0oaSkpKTtyZXR1cm4gcD1mdW5jdGlvbih0KXt2YXIgZT1BcnJheShHKHQpKzEpO3JldHVybiBCKHQsZSwwLGUubGVuZ3RoKSxlfShyPXIucmVwbGFjZSgvXFxcXDBcXFxcMC9nLFwiJVwiKSkscC5sZW5ndGg+bj8wOihmdW5jdGlvbih0LG4pe2UoKS5zZXQodCxuPj4+MCl9KHAsdCkscC5sZW5ndGgtMSl9aHQuZmMoKTt2YXIgZmU9W251bGwsZnQsYnQsRXQsQ3QseHQsUnQsa3QsanQsRHQsUHQsVXQsRnQsSXQsV3QsSHQsenQsQnQsR3QsVnQsUXQsS3QsdGUsZWUsbmUsaWVdLHBlPXtiOmZ1bmN0aW9uKHQpe3JldHVybiBkZSh0KzI0KSsyNH0sbjpmdW5jdGlvbih0KXtyZXR1cm4odD1uZXcgU3QodCkpLnVjKCl8fCh0LmhjKCEwKSxPdC0tKSx0LmljKCExKSx3dC5wdXNoKHQpLHQuc2MoKSx0LnZjKCl9LG1hOmZ1bmN0aW9uKHQpe3Rocm93IHgoXCJVbmV4cGVjdGVkIGV4Y2VwdGlvbiB0aHJvd24sIHRoaXMgaXMgbm90IHByb3Blcmx5IHN1cHBvcnRlZCAtIGFib3J0aW5nXCIpLEg9ITAsdH0seDpmdW5jdGlvbigpe1NlKDApO3ZhciB0PXd0LnBvcCgpO2lmKHQuSGMoKSYmIXQua2MoKSl7dmFyIGU9dC5EYygpO2UmJmd0KGUpKHQuWmIpLFR0KHQuWmIpfUF0PTB9LGU6ZnVuY3Rpb24oKXt2YXIgdD1BdDtpZighdClyZXR1cm4gb2U9MDt2YXIgZT1uZXcgU3QodCk7ZS5jYyh0KTt2YXIgbj1lLmJjKCk7aWYoIW4pcmV0dXJuIG9lPTAsdDtmb3IodmFyIHI9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSxhPTA7YTxyLmxlbmd0aDthKyspe3ZhciBpPXJbYV07aWYoMD09PWl8fGk9PT1uKWJyZWFrO2lmKHhlKGksbixlLlNiKzE2KSlyZXR1cm4gb2U9aSx0fXJldHVybiBvZT1uLHR9LGw6ZnVuY3Rpb24oKXt2YXIgdD1BdDtpZighdClyZXR1cm4gb2U9MDt2YXIgZT1uZXcgU3QodCk7ZS5jYyh0KTt2YXIgbj1lLmJjKCk7aWYoIW4pcmV0dXJuIG9lPTAsdDtmb3IodmFyIHI9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSxhPTA7YTxyLmxlbmd0aDthKyspe3ZhciBpPXJbYV07aWYoMD09PWl8fGk9PT1uKWJyZWFrO2lmKHhlKGksbixlLlNiKzE2KSlyZXR1cm4gb2U9aSx0fXJldHVybiBvZT1uLHR9LGg6ZnVuY3Rpb24oKXt2YXIgdD1BdDtpZighdClyZXR1cm4gb2U9MDt2YXIgZT1uZXcgU3QodCk7ZS5jYyh0KTt2YXIgbj1lLmJjKCk7aWYoIW4pcmV0dXJuIG9lPTAsdDtmb3IodmFyIHI9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSxhPTA7YTxyLmxlbmd0aDthKyspe3ZhciBpPXJbYV07aWYoMD09PWl8fGk9PT1uKWJyZWFrO2lmKHhlKGksbixlLlNiKzE2KSlyZXR1cm4gb2U9aSx0fXJldHVybiBvZT1uLHR9LHQ6VHQsTTpmdW5jdGlvbigpe3ZhciB0PXd0LnBvcCgpO3R8fGF0KFwibm8gZXhjZXB0aW9uIHRvIHRocm93XCIpO3ZhciBlPXQuWmI7dGhyb3cgdC5rYygpfHwod3QucHVzaCh0KSx0LmljKCEwKSx0LmhjKCExKSxPdCsrKSxBdD1lLGV9LGM6ZnVuY3Rpb24odCxlLG4pe3Rocm93IG5ldyBTdCh0KS5mYyhlLG4pLEF0PXQsT3QrKyx0fSxwYTpmdW5jdGlvbigpe3JldHVybiBPdH0sRmE6ZnVuY3Rpb24odCl7Z2UodCwhXywxLCF2KSxodC5wYygpfSxUOmZ1bmN0aW9uKHQpe08/cG9zdE1lc3NhZ2Uoe2NtZDpcImNsZWFudXBUaHJlYWRcIix0aHJlYWQ6dH0pOmN0KHQpfSx4YTpNdCxqOmZ1bmN0aW9uKHQpe3Rocm93IEF0fHwoQXQ9dCksdH0sSDpDdCxNYTp4dCx1YTpSdCx3YTprdCxvYTpqdCxLYTpEdCxDYTpQdCxKYTpVdCxWOkZ0LHZhOkl0LHNhOld0LExhOkh0LHRhOnp0LFRhOmZ1bmN0aW9uKCl7fSxYOmZ1bmN0aW9uKCl7YXQoXCJUbyB1c2UgZGxvcGVuLCB5b3UgbmVlZCBlbmFibGUgZHluYW1pYyBsaW5raW5nLCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2Vtc2NyaXB0ZW4tY29yZS9lbXNjcmlwdGVuL3dpa2kvTGlua2luZ1wiKX0sVWE6ZnVuY3Rpb24oKXthdChcIlRvIHVzZSBkbG9wZW4sIHlvdSBuZWVkIGVuYWJsZSBkeW5hbWljIGxpbmtpbmcsIHNlZSBodHRwczovL2dpdGh1Yi5jb20vZW1zY3JpcHRlbi1jb3JlL2Vtc2NyaXB0ZW4vd2lraS9MaW5raW5nXCIpfSxXOmZ1bmN0aW9uKCl7cmV0dXJuIERhdGUubm93KCl9LHlhOmZ1bmN0aW9uKCl7cmV0dXJuIDIwOTcxNTJ9LE9hOmZ1bmN0aW9uKCl7cmV0dXJuITB9LHphOmZ1bmN0aW9uKHQsZSxuLHIpe2lmKHQ9PWUpc2V0VGltZW91dCgoKCk9Pkx0KHIpKSk7ZWxzZSBpZihPKXBvc3RNZXNzYWdlKHt0YXJnZXRUaHJlYWQ6dCxjbWQ6XCJwcm9jZXNzUHJveHlpbmdRdWV1ZVwiLHF1ZXVlOnJ9KTtlbHNle2lmKCEodD1odC5WYlt0XSkpcmV0dXJuO3QucG9zdE1lc3NhZ2Uoe2NtZDpcInByb2Nlc3NQcm94eWluZ1F1ZXVlXCIscXVldWU6cn0pfXJldHVybiAxfSxFYTpmdW5jdGlvbigpe3JldHVybi0xfSxQYTpmdW5jdGlvbih0LGUpe3Q9bmV3IERhdGUoMWUzKll0KHQpKSxhKClbZT4+Mj4+PjBdPXQuZ2V0VVRDU2Vjb25kcygpLGEoKVtlKzQ+PjI+Pj4wXT10LmdldFVUQ01pbnV0ZXMoKSxhKClbZSs4Pj4yPj4+MF09dC5nZXRVVENIb3VycygpLGEoKVtlKzEyPj4yPj4+MF09dC5nZXRVVENEYXRlKCksYSgpW2UrMTY+PjI+Pj4wXT10LmdldFVUQ01vbnRoKCksYSgpW2UrMjA+PjI+Pj4wXT10LmdldFVUQ0Z1bGxZZWFyKCktMTkwMCxhKClbZSsyND4+Mj4+PjBdPXQuZ2V0VVRDRGF5KCksdD0odC5nZXRUaW1lKCktRGF0ZS5VVEModC5nZXRVVENGdWxsWWVhcigpLDAsMSwwLDAsMCwwKSkvODY0ZTV8MCxhKClbZSsyOD4+Mj4+PjBdPXR9LFFhOmZ1bmN0aW9uKHQsZSl7dD1uZXcgRGF0ZSgxZTMqWXQodCkpLGEoKVtlPj4yPj4+MF09dC5nZXRTZWNvbmRzKCksYSgpW2UrND4+Mj4+PjBdPXQuZ2V0TWludXRlcygpLGEoKVtlKzg+PjI+Pj4wXT10LmdldEhvdXJzKCksYSgpW2UrMTI+PjI+Pj4wXT10LmdldERhdGUoKSxhKClbZSsxNj4+Mj4+PjBdPXQuZ2V0TW9udGgoKSxhKClbZSsyMD4+Mj4+PjBdPXQuZ2V0RnVsbFllYXIoKS0xOTAwLGEoKVtlKzI0Pj4yPj4+MF09dC5nZXREYXkoKTt2YXIgbj1uZXcgRGF0ZSh0LmdldEZ1bGxZZWFyKCksMCwxKSxyPSh0LmdldFRpbWUoKS1uLmdldFRpbWUoKSkvODY0ZTV8MDthKClbZSsyOD4+Mj4+PjBdPXIsYSgpW2UrMzY+PjI+Pj4wXT0tNjAqdC5nZXRUaW1lem9uZU9mZnNldCgpLHI9bmV3IERhdGUodC5nZXRGdWxsWWVhcigpLDYsMSkuZ2V0VGltZXpvbmVPZmZzZXQoKSx0PTB8KHIhPShuPW4uZ2V0VGltZXpvbmVPZmZzZXQoKSkmJnQuZ2V0VGltZXpvbmVPZmZzZXQoKT09TWF0aC5taW4obixyKSksYSgpW2UrMzI+PjI+Pj4wXT10fSxSYTpmdW5jdGlvbih0KXt2YXIgZT1uZXcgRGF0ZShhKClbdCsyMD4+Mj4+PjBdKzE5MDAsYSgpW3QrMTY+PjI+Pj4wXSxhKClbdCsxMj4+Mj4+PjBdLGEoKVt0Kzg+PjI+Pj4wXSxhKClbdCs0Pj4yPj4+MF0sYSgpW3Q+PjI+Pj4wXSwwKSxuPWEoKVt0KzMyPj4yPj4+MF0scj1lLmdldFRpbWV6b25lT2Zmc2V0KCksaT1uZXcgRGF0ZShlLmdldEZ1bGxZZWFyKCksMCwxKSxvPW5ldyBEYXRlKGUuZ2V0RnVsbFllYXIoKSw2LDEpLmdldFRpbWV6b25lT2Zmc2V0KCksdT1pLmdldFRpbWV6b25lT2Zmc2V0KCkscz1NYXRoLm1pbih1LG8pO3JldHVybiAwPm4/YSgpW3QrMzI+PjI+Pj4wXT1OdW1iZXIobyE9dSYmcz09cik6MDxuIT0ocz09cikmJihvPU1hdGgubWF4KHUsbyksZS5zZXRUaW1lKGUuZ2V0VGltZSgpKzZlNCooKDA8bj9zOm8pLXIpKSksYSgpW3QrMjQ+PjI+Pj4wXT1lLmdldERheSgpLG49KGUuZ2V0VGltZSgpLWkuZ2V0VGltZSgpKS84NjRlNXwwLGEoKVt0KzI4Pj4yPj4+MF09bixhKClbdD4+Mj4+PjBdPWUuZ2V0U2Vjb25kcygpLGEoKVt0KzQ+PjI+Pj4wXT1lLmdldE1pbnV0ZXMoKSxhKClbdCs4Pj4yPj4+MF09ZS5nZXRIb3VycygpLGEoKVt0KzEyPj4yPj4+MF09ZS5nZXREYXRlKCksYSgpW3QrMTY+PjI+Pj4wXT1lLmdldE1vbnRoKCksZS5nZXRUaW1lKCkvMWUzfDB9LEFhOkJ0LEJhOkd0LFNhOmZ1bmN0aW9uIHQoZSxuLHIpe3QuQWN8fCh0LkFjPSEwLFZ0KGUsbixyKSl9LHk6ZnVuY3Rpb24oKXthdChcIlwiKX0sVTpmdW5jdGlvbigpe2lmKCF3JiYhXyl7dmFyIHQ9XCJCbG9ja2luZyBvbiB0aGUgbWFpbiB0aHJlYWQgaXMgdmVyeSBkYW5nZXJvdXMsIHNlZSBodHRwczovL2Vtc2NyaXB0ZW4ub3JnL2RvY3MvcG9ydGluZy9wdGhyZWFkcy5odG1sI2Jsb2NraW5nLW9uLXRoZS1tYWluLWJyb3dzZXItdGhyZWFkXCI7dnR8fCh2dD17fSksdnRbdF18fCh2dFt0XT0xLHcmJih0PVwid2FybmluZzogXCIrdCkseCh0KSl9fSxyYTpmdW5jdGlvbigpe3JldHVybiA0Mjk0OTAxNzYwfSxCOl90LElhOmZ1bmN0aW9uKHQsZSxuKXtyKCkuY29weVdpdGhpbih0Pj4+MCxlPj4+MCxlK24+Pj4wKX0sRjpmdW5jdGlvbigpe3JldHVybiB3P24oMzcpLmNwdXMoKS5sZW5ndGg6bmF2aWdhdG9yLmhhcmR3YXJlQ29uY3VycmVuY3l9LERhOmZ1bmN0aW9uKHQsZSxuKXtYdC5sZW5ndGg9ZSxuPj49Mztmb3IodmFyIHI9MDtyPGU7cisrKVh0W3JdPW8oKVtuK3I+Pj4wXTtyZXR1cm4oMD50P3V0Wy10LTFdOmZlW3RdKS5hcHBseShudWxsLFh0KX0scWE6ZnVuY3Rpb24odCl7dmFyIGU9cigpLmxlbmd0aDtpZigodD4+Pj0wKTw9ZXx8NDI5NDkwMTc2MDx0KXJldHVybiExO2Zvcih2YXIgbj0xOzQ+PW47bio9Mil7dmFyIGE9ZSooMSsuMi9uKTthPU1hdGgubWluKGEsdCsxMDA2NjMyOTYpO3ZhciBpPU1hdGg7YT1NYXRoLm1heCh0LGEpLGk9aS5taW4uY2FsbChpLDQyOTQ5MDE3NjAsYSsoNjU1MzYtYSU2NTUzNiklNjU1MzYpO3Q6e3RyeXtrLmdyb3coaS1ELmJ5dGVMZW5ndGgrNjU1MzU+Pj4xNiksTihrLmJ1ZmZlcik7dmFyIG89MTticmVhayB0fWNhdGNoKHQpe31vPXZvaWQgMH1pZihvKXJldHVybiEwfXJldHVybiExfSxOYTpmdW5jdGlvbigpe3Rocm93XCJ1bndpbmRcIn0sR2E6UXQsSGE6S3QsSjpwdCxJOnRlLFM6ZWUsZ2E6bmUsUjppZSxkOmZ1bmN0aW9uKCl7cmV0dXJuIG9lfSxuYTpmdW5jdGlvbiB0KHIsYSl7dC5sY3x8KHQubGM9ZnVuY3Rpb24oKXtpZihcIm9iamVjdFwiPT10eXBlb2YgY3J5cHRvJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKXt2YXIgdD1uZXcgVWludDhBcnJheSgxKTtyZXR1cm4oKT0+KGNyeXB0by5nZXRSYW5kb21WYWx1ZXModCksdFswXSl9aWYodyl0cnl7dmFyIGU9bigxMTMpO3JldHVybigpPT5lLnJhbmRvbUJ5dGVzKDEpWzBdfWNhdGNoKHQpe31yZXR1cm4oKT0+YXQoXCJyYW5kb21EZXZpY2VcIil9KCkpO2Zvcih2YXIgaT0wO2k8YTtpKyspZSgpW3IraT4+MD4+PjBdPXQubGMoKTtyZXR1cm4gMH0saWE6ZnVuY3Rpb24odCxlLG4pe3ZhciByPUVlKCk7dHJ5e3JldHVybiBndCh0KShlLG4pfWNhdGNoKHQpe2lmKE1lKHIpLHQhPT10KzApdGhyb3cgdDtTZSgxLDApfX0samE6ZnVuY3Rpb24odCxlLG4pe3ZhciByPUVlKCk7dHJ5e3JldHVybiBndCh0KShlLG4pfWNhdGNoKHQpe2lmKE1lKHIpLHQhPT10KzApdGhyb3cgdDtTZSgxLDApfX0sSzpmdW5jdGlvbih0KXt2YXIgZT1FZSgpO3RyeXtyZXR1cm4gZ3QodCkoKX1jYXRjaCh0KXtpZihNZShlKSx0IT09dCswKXRocm93IHQ7U2UoMSwwKX19LGY6ZnVuY3Rpb24odCxlKXt2YXIgbj1FZSgpO3RyeXtyZXR1cm4gZ3QodCkoZSl9Y2F0Y2godCl7aWYoTWUobiksdCE9PXQrMCl0aHJvdyB0O1NlKDEsMCl9fSxQOmZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1FZSgpO3RyeXtyZXR1cm4gZ3QodCkoZSxuKX1jYXRjaCh0KXtpZihNZShyKSx0IT09dCswKXRocm93IHQ7U2UoMSwwKX19LFE6ZnVuY3Rpb24odCxlLG4pe3ZhciByPUVlKCk7dHJ5e3JldHVybiBndCh0KShlLG4pfWNhdGNoKHQpe2lmKE1lKHIpLHQhPT10KzApdGhyb3cgdDtTZSgxLDApfX0sazpmdW5jdGlvbih0LGUsbil7dmFyIHI9RWUoKTt0cnl7cmV0dXJuIGd0KHQpKGUsbil9Y2F0Y2godCl7aWYoTWUociksdCE9PXQrMCl0aHJvdyB0O1NlKDEsMCl9fSxwOmZ1bmN0aW9uKHQsZSxuLHIpe3ZhciBhPUVlKCk7dHJ5e3JldHVybiBndCh0KShlLG4scil9Y2F0Y2godCl7aWYoTWUoYSksdCE9PXQrMCl0aHJvdyB0O1NlKDEsMCl9fSxxOmZ1bmN0aW9uKHQsZSxuLHIsYSl7dmFyIGk9RWUoKTt0cnl7cmV0dXJuIGd0KHQpKGUsbixyLGEpfWNhdGNoKHQpe2lmKE1lKGkpLHQhPT10KzApdGhyb3cgdDtTZSgxLDApfX0sTjpmdW5jdGlvbih0LGUsbixyLGEsaSl7dmFyIG89RWUoKTt0cnl7cmV0dXJuIGd0KHQpKGUsbixyLGEsaSl9Y2F0Y2godCl7aWYoTWUobyksdCE9PXQrMCl0aHJvdyB0O1NlKDEsMCl9fSxzOmZ1bmN0aW9uKHQsZSxuLHIsYSxpKXt2YXIgbz1FZSgpO3RyeXtyZXR1cm4gZ3QodCkoZSxuLHIsYSxpKX1jYXRjaCh0KXtpZihNZShvKSx0IT09dCswKXRocm93IHQ7U2UoMSwwKX19LHc6ZnVuY3Rpb24odCxlLG4scixhLGksbyl7dmFyIHU9RWUoKTt0cnl7cmV0dXJuIGd0KHQpKGUsbixyLGEsaSxvKX1jYXRjaCh0KXtpZihNZSh1KSx0IT09dCswKXRocm93IHQ7U2UoMSwwKX19LEw6ZnVuY3Rpb24odCxlLG4scixhLGksbyx1KXt2YXIgcz1FZSgpO3RyeXtyZXR1cm4gZ3QodCkoZSxuLHIsYSxpLG8sdSl9Y2F0Y2godCl7aWYoTWUocyksdCE9PXQrMCl0aHJvdyB0O1NlKDEsMCl9fSxFOmZ1bmN0aW9uKHQsZSxuLHIsYSxpLG8sdSxzLGMsbCxmKXt2YXIgcD1FZSgpO3RyeXtyZXR1cm4gZ3QodCkoZSxuLHIsYSxpLG8sdSxzLGMsbCxmKX1jYXRjaCh0KXtpZihNZShwKSx0IT09dCswKXRocm93IHQ7U2UoMSwwKX19LGFhOmZ1bmN0aW9uKHQsZSxuLHIsYSxpLG8sdSl7dmFyIHM9RWUoKTt0cnl7cmV0dXJuIEhlKHQsZSxuLHIsYSxpLG8sdSl9Y2F0Y2godCl7aWYoTWUocyksdCE9PXQrMCl0aHJvdyB0O1NlKDEsMCl9fSxfOmZ1bmN0aW9uKHQsZSxuLHIsYSxpLG8pe3ZhciB1PUVlKCk7dHJ5e3JldHVybiBqZSh0LGUsbixyLGEsaSxvKX1jYXRjaCh0KXtpZihNZSh1KSx0IT09dCswKXRocm93IHQ7U2UoMSwwKX19LFo6ZnVuY3Rpb24odCxlLG4scixhKXt2YXIgaT1FZSgpO3RyeXtyZXR1cm4gemUodCxlLG4scixhKX1jYXRjaCh0KXtpZihNZShpKSx0IT09dCswKXRocm93IHQ7U2UoMSwwKX19LGNhOmZ1bmN0aW9uKHQsZSxuLHIpe3ZhciBhPUVlKCk7dHJ5e3JldHVybiBJZSh0LGUsbixyKX1jYXRjaCh0KXtpZihNZShhKSx0IT09dCswKXRocm93IHQ7U2UoMSwwKX19LCQ6ZnVuY3Rpb24odCl7dmFyIGU9RWUoKTt0cnl7cmV0dXJuIGtlKHQpfWNhdGNoKHQpe2lmKE1lKGUpLHQhPT10KzApdGhyb3cgdDtTZSgxLDApfX0sYmE6ZnVuY3Rpb24odCxlKXt2YXIgbj1FZSgpO3RyeXtyZXR1cm4gV2UodCxlKX1jYXRjaCh0KXtpZihNZShuKSx0IT09dCswKXRocm93IHQ7U2UoMSwwKX19LFk6ZnVuY3Rpb24odCxlLG4pe3ZhciByPUVlKCk7dHJ5e3JldHVybiBEZSh0LGUsbil9Y2F0Y2godCl7aWYoTWUociksdCE9PXQrMCl0aHJvdyB0O1NlKDEsMCl9fSxnOmZ1bmN0aW9uKHQpe3ZhciBlPUVlKCk7dHJ5e2d0KHQpKCl9Y2F0Y2godCl7aWYoTWUoZSksdCE9PXQrMCl0aHJvdyB0O1NlKDEsMCl9fSxyOmZ1bmN0aW9uKHQsZSl7dmFyIG49RWUoKTt0cnl7Z3QodCkoZSl9Y2F0Y2godCl7aWYoTWUobiksdCE9PXQrMCl0aHJvdyB0O1NlKDEsMCl9fSxpOmZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1FZSgpO3RyeXtndCh0KShlLG4pfWNhdGNoKHQpe2lmKE1lKHIpLHQhPT10KzApdGhyb3cgdDtTZSgxLDApfX0saGE6ZnVuY3Rpb24odCxlLG4scil7dmFyIGE9RWUoKTt0cnl7Z3QodCkoZSxuLHIpfWNhdGNoKHQpe2lmKE1lKGEpLHQhPT10KzApdGhyb3cgdDtTZSgxLDApfX0sbTpmdW5jdGlvbih0LGUsbixyKXt2YXIgYT1FZSgpO3RyeXtndCh0KShlLG4scil9Y2F0Y2godCl7aWYoTWUoYSksdCE9PXQrMCl0aHJvdyB0O1NlKDEsMCl9fSx2OmZ1bmN0aW9uKHQsZSxuLHIsYSl7dmFyIGk9RWUoKTt0cnl7Z3QodCkoZSxuLHIsYSl9Y2F0Y2godCl7aWYoTWUoaSksdCE9PXQrMCl0aHJvdyB0O1NlKDEsMCl9fSx1OmZ1bmN0aW9uKHQsZSxuLHIsYSxpKXt2YXIgbz1FZSgpO3RyeXtndCh0KShlLG4scixhLGkpfWNhdGNoKHQpe2lmKE1lKG8pLHQhPT10KzApdGhyb3cgdDtTZSgxLDApfX0sTzpmdW5jdGlvbih0LGUsbixyLGEsaSxvKXt2YXIgdT1FZSgpO3RyeXtndCh0KShlLG4scixhLGksbyl9Y2F0Y2godCl7aWYoTWUodSksdCE9PXQrMCl0aHJvdyB0O1NlKDEsMCl9fSxBOmZ1bmN0aW9uKHQsZSxuLHIsYSxpLG8sdSl7dmFyIHM9RWUoKTt0cnl7Z3QodCkoZSxuLHIsYSxpLG8sdSl9Y2F0Y2godCl7aWYoTWUocyksdCE9PXQrMCl0aHJvdyB0O1NlKDEsMCl9fSxrYTpmdW5jdGlvbih0LGUsbixyLGEsaSxvLHUscyl7dmFyIGM9RWUoKTt0cnl7Z3QodCkoZSxuLHIsYSxpLG8sdSxzKX1jYXRjaCh0KXtpZihNZShjKSx0IT09dCswKXRocm93IHQ7U2UoMSwwKX19LEM6ZnVuY3Rpb24odCxlLG4scixhLGksbyx1LHMsYyxsKXt2YXIgZj1FZSgpO3RyeXtndCh0KShlLG4scixhLGksbyx1LHMsYyxsKX1jYXRjaCh0KXtpZihNZShmKSx0IT09dCswKXRocm93IHQ7U2UoMSwwKX19LEQ6ZnVuY3Rpb24odCxlLG4scixhLGksbyx1LHMsYyxsLGYscCxoLGQseSl7dmFyIGI9RWUoKTt0cnl7Z3QodCkoZSxuLHIsYSxpLG8sdSxzLGMsbCxmLHAsaCxkLHkpfWNhdGNoKHQpe2lmKE1lKGIpLHQhPT10KzApdGhyb3cgdDtTZSgxLDApfX0sZmE6ZnVuY3Rpb24odCxlLG4scixhLGksbyx1KXt2YXIgcz1FZSgpO3RyeXtQZSh0LGUsbixyLGEsaSxvLHUpfWNhdGNoKHQpe2lmKE1lKHMpLHQhPT10KzApdGhyb3cgdDtTZSgxLDApfX0sZGE6ZnVuY3Rpb24odCxlLG4scixhLGksbyx1LHMsYyxsLGYpe3ZhciBwPUVlKCk7dHJ5e0ZlKHQsZSxuLHIsYSxpLG8sdSxzLGMsbCxmKX1jYXRjaCh0KXtpZihNZShwKSx0IT09dCswKXRocm93IHQ7U2UoMSwwKX19LGVhOmZ1bmN0aW9uKHQsZSxuLHIsYSxpKXt2YXIgbz1FZSgpO3RyeXtVZSh0LGUsbixyLGEsaSl9Y2F0Y2godCl7aWYoTWUobyksdCE9PXQrMCl0aHJvdyB0O1NlKDEsMCl9fSxvOmZ1bmN0aW9uKHQpe3JldHVybiB0fSxhOmt8fHUud2FzbU1lbW9yeSxHOmZ1bmN0aW9uKHQpe29lPXR9LGxhOmxlLHo6ZnVuY3Rpb24odCxlLG4scil7cmV0dXJuIGxlKHQsZSxuLHIpfX07IWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0LGUpe3UuYXNtPXQuZXhwb3J0cyxodC5xYy5wdXNoKHUuYXNtLnNiKSxxPXUuYXNtLnViLFgudW5zaGlmdCh1LmFzbS5WYSksaj1lLE98fChldC0tLHUubW9uaXRvclJ1bkRlcGVuZGVuY2llcyYmdS5tb25pdG9yUnVuRGVwZW5kZW5jaWVzKGV0KSwwPT1ldCYmKG51bGwhPT1udCYmKGNsZWFySW50ZXJ2YWwobnQpLG50PW51bGwpLHJ0JiYodD1ydCxydD1udWxsLHQoKSkpKX1mdW5jdGlvbiBlKGUpe3QoZS5pbnN0YW5jZSxlLm1vZHVsZSl9ZnVuY3Rpb24gbih0KXtyZXR1cm4gZnVuY3Rpb24oKXtpZighTSYmKHZ8fF8pKXtpZihcImZ1bmN0aW9uXCI9PXR5cGVvZiBmZXRjaCYmIXR0LnN0YXJ0c1dpdGgoXCJmaWxlOi8vXCIpKXJldHVybiBmZXRjaCh0dCx7Y3JlZGVudGlhbHM6XCJzYW1lLW9yaWdpblwifSkudGhlbigoZnVuY3Rpb24odCl7aWYoIXQub2spdGhyb3dcImZhaWxlZCB0byBsb2FkIHdhc20gYmluYXJ5IGZpbGUgYXQgXFwnXCIrdHQrXCJcXCdcIjtyZXR1cm4gdC5hcnJheUJ1ZmZlcigpfSkpLmNhdGNoKChmdW5jdGlvbigpe3JldHVybiBvdCgpfSkpO2lmKGYpcmV0dXJuIG5ldyBQcm9taXNlKChmdW5jdGlvbih0LGUpe2YodHQsKGZ1bmN0aW9uKGUpe3QobmV3IFVpbnQ4QXJyYXkoZSkpfSksZSl9KSl9cmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKGZ1bmN0aW9uKCl7cmV0dXJuIG90KCl9KSl9KCkudGhlbigoZnVuY3Rpb24odCl7cmV0dXJuIFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlKHQscil9KSkudGhlbigoZnVuY3Rpb24odCl7cmV0dXJuIHR9KSkudGhlbih0LChmdW5jdGlvbih0KXt4KFwiZmFpbGVkIHRvIGFzeW5jaHJvbm91c2x5IHByZXBhcmUgd2FzbTogXCIrdCksYXQodCl9KSl9dmFyIHI9e2E6cGV9O2lmKE98fChldCsrLHUubW9uaXRvclJ1bkRlcGVuZGVuY2llcyYmdS5tb25pdG9yUnVuRGVwZW5kZW5jaWVzKGV0KSksdS5pbnN0YW50aWF0ZVdhc20pdHJ5e3JldHVybiB1Lmluc3RhbnRpYXRlV2FzbShyLHQpfWNhdGNoKHQpe3JldHVybiB4KFwiTW9kdWxlLmluc3RhbnRpYXRlV2FzbSBjYWxsYmFjayBmYWlsZWQgd2l0aCBlcnJvcjogXCIrdCksITF9KE18fFwiZnVuY3Rpb25cIiE9dHlwZW9mIFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlU3RyZWFtaW5nfHxpdCgpfHx0dC5zdGFydHNXaXRoKFwiZmlsZTovL1wiKXx8d3x8XCJmdW5jdGlvblwiIT10eXBlb2YgZmV0Y2g/bihlKTpmZXRjaCh0dCx7Y3JlZGVudGlhbHM6XCJzYW1lLW9yaWdpblwifSkudGhlbigoZnVuY3Rpb24odCl7cmV0dXJuIFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlU3RyZWFtaW5nKHQscikudGhlbihlLChmdW5jdGlvbih0KXtyZXR1cm4geChcIndhc20gc3RyZWFtaW5nIGNvbXBpbGUgZmFpbGVkOiBcIit0KSx4KFwiZmFsbGluZyBiYWNrIHRvIEFycmF5QnVmZmVyIGluc3RhbnRpYXRpb25cIiksbihlKX0pKX0pKSkuY2F0Y2goYyl9KCksdS5fX193YXNtX2NhbGxfY3RvcnM9ZnVuY3Rpb24oKXtyZXR1cm4odS5fX193YXNtX2NhbGxfY3RvcnM9dS5hc20uVmEpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sdS5fT3J0SW5pdD1mdW5jdGlvbigpe3JldHVybih1Ll9PcnRJbml0PXUuYXNtLldhKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHUuX09ydENyZWF0ZVNlc3Npb25PcHRpb25zPWZ1bmN0aW9uKCl7cmV0dXJuKHUuX09ydENyZWF0ZVNlc3Npb25PcHRpb25zPXUuYXNtLlhhKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHUuX09ydEFwcGVuZEV4ZWN1dGlvblByb3ZpZGVyPWZ1bmN0aW9uKCl7cmV0dXJuKHUuX09ydEFwcGVuZEV4ZWN1dGlvblByb3ZpZGVyPXUuYXNtLllhKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHUuX09ydEFkZFNlc3Npb25Db25maWdFbnRyeT1mdW5jdGlvbigpe3JldHVybih1Ll9PcnRBZGRTZXNzaW9uQ29uZmlnRW50cnk9dS5hc20uWmEpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sdS5fT3J0UmVsZWFzZVNlc3Npb25PcHRpb25zPWZ1bmN0aW9uKCl7cmV0dXJuKHUuX09ydFJlbGVhc2VTZXNzaW9uT3B0aW9ucz11LmFzbS5fYSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSx1Ll9PcnRDcmVhdGVTZXNzaW9uPWZ1bmN0aW9uKCl7cmV0dXJuKHUuX09ydENyZWF0ZVNlc3Npb249dS5hc20uJGEpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sdS5fT3J0UmVsZWFzZVNlc3Npb249ZnVuY3Rpb24oKXtyZXR1cm4odS5fT3J0UmVsZWFzZVNlc3Npb249dS5hc20uYWIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sdS5fT3J0R2V0SW5wdXRDb3VudD1mdW5jdGlvbigpe3JldHVybih1Ll9PcnRHZXRJbnB1dENvdW50PXUuYXNtLmJiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHUuX09ydEdldE91dHB1dENvdW50PWZ1bmN0aW9uKCl7cmV0dXJuKHUuX09ydEdldE91dHB1dENvdW50PXUuYXNtLmNiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHUuX09ydEdldElucHV0TmFtZT1mdW5jdGlvbigpe3JldHVybih1Ll9PcnRHZXRJbnB1dE5hbWU9dS5hc20uZGIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sdS5fT3J0R2V0T3V0cHV0TmFtZT1mdW5jdGlvbigpe3JldHVybih1Ll9PcnRHZXRPdXRwdXROYW1lPXUuYXNtLmViKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHUuX09ydEZyZWU9ZnVuY3Rpb24oKXtyZXR1cm4odS5fT3J0RnJlZT11LmFzbS5mYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSx1Ll9PcnRDcmVhdGVUZW5zb3I9ZnVuY3Rpb24oKXtyZXR1cm4odS5fT3J0Q3JlYXRlVGVuc29yPXUuYXNtLmdiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHUuX09ydEdldFRlbnNvckRhdGE9ZnVuY3Rpb24oKXtyZXR1cm4odS5fT3J0R2V0VGVuc29yRGF0YT11LmFzbS5oYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSx1Ll9PcnRSZWxlYXNlVGVuc29yPWZ1bmN0aW9uKCl7cmV0dXJuKHUuX09ydFJlbGVhc2VUZW5zb3I9dS5hc20uaWIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sdS5fT3J0Q3JlYXRlUnVuT3B0aW9ucz1mdW5jdGlvbigpe3JldHVybih1Ll9PcnRDcmVhdGVSdW5PcHRpb25zPXUuYXNtLmpiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHUuX09ydEFkZFJ1bkNvbmZpZ0VudHJ5PWZ1bmN0aW9uKCl7cmV0dXJuKHUuX09ydEFkZFJ1bkNvbmZpZ0VudHJ5PXUuYXNtLmtiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHUuX09ydFJlbGVhc2VSdW5PcHRpb25zPWZ1bmN0aW9uKCl7cmV0dXJuKHUuX09ydFJlbGVhc2VSdW5PcHRpb25zPXUuYXNtLmxiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHUuX09ydFJ1bj1mdW5jdGlvbigpe3JldHVybih1Ll9PcnRSdW49dS5hc20ubWIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sdS5fT3J0RW5kUHJvZmlsaW5nPWZ1bmN0aW9uKCl7cmV0dXJuKHUuX09ydEVuZFByb2ZpbGluZz11LmFzbS5uYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfTt2YXIgaGU9dS5fcHRocmVhZF9zZWxmPWZ1bmN0aW9uKCl7cmV0dXJuKGhlPXUuX3B0aHJlYWRfc2VsZj11LmFzbS5vYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxkZT11Ll9tYWxsb2M9ZnVuY3Rpb24oKXtyZXR1cm4oZGU9dS5fbWFsbG9jPXUuYXNtLnBiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHllPXUuX2ZyZWU9ZnVuY3Rpb24oKXtyZXR1cm4oeWU9dS5fZnJlZT11LmFzbS5xYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxiZT11Ll9mZmx1c2g9ZnVuY3Rpb24oKXtyZXR1cm4oYmU9dS5fZmZsdXNoPXUuYXNtLnJiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O3UuX19lbXNjcmlwdGVuX3Rsc19pbml0PWZ1bmN0aW9uKCl7cmV0dXJuKHUuX19lbXNjcmlwdGVuX3Rsc19pbml0PXUuYXNtLnNiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O3ZhciBtZT11Ll9fX2Z1bmNzX29uX2V4aXQ9ZnVuY3Rpb24oKXtyZXR1cm4obWU9dS5fX19mdW5jc19vbl9leGl0PXUuYXNtLnRiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGdlPXUuX19lbXNjcmlwdGVuX3RocmVhZF9pbml0PWZ1bmN0aW9uKCl7cmV0dXJuKGdlPXUuX19lbXNjcmlwdGVuX3RocmVhZF9pbml0PXUuYXNtLnZiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O3UuX19lbXNjcmlwdGVuX3RocmVhZF9jcmFzaGVkPWZ1bmN0aW9uKCl7cmV0dXJuKHUuX19lbXNjcmlwdGVuX3RocmVhZF9jcmFzaGVkPXUuYXNtLndiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O3ZhciB2ZSxfZT11Ll9lbXNjcmlwdGVuX3J1bl9pbl9tYWluX3J1bnRpbWVfdGhyZWFkX2pzPWZ1bmN0aW9uKCl7cmV0dXJuKF9lPXUuX2Vtc2NyaXB0ZW5fcnVuX2luX21haW5fcnVudGltZV90aHJlYWRfanM9dS5hc20ueGIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sd2U9dS5fX2Vtc2NyaXB0ZW5fcHJveHlfZXhlY3V0ZV90YXNrX3F1ZXVlPWZ1bmN0aW9uKCl7cmV0dXJuKHdlPXUuX19lbXNjcmlwdGVuX3Byb3h5X2V4ZWN1dGVfdGFza19xdWV1ZT11LmFzbS55YikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxPZT11Ll9fZW1zY3JpcHRlbl90aHJlYWRfZnJlZV9kYXRhPWZ1bmN0aW9uKCl7cmV0dXJuKE9lPXUuX19lbXNjcmlwdGVuX3RocmVhZF9mcmVlX2RhdGE9dS5hc20uemIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sQWU9dS5fX2Vtc2NyaXB0ZW5fdGhyZWFkX2V4aXQ9ZnVuY3Rpb24oKXtyZXR1cm4oQWU9dS5fX2Vtc2NyaXB0ZW5fdGhyZWFkX2V4aXQ9dS5hc20uQWIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sU2U9dS5fc2V0VGhyZXc9ZnVuY3Rpb24oKXtyZXR1cm4oU2U9dS5fc2V0VGhyZXc9dS5hc20uQmIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sVGU9dS5fZW1zY3JpcHRlbl9zdGFja19zZXRfbGltaXRzPWZ1bmN0aW9uKCl7cmV0dXJuKFRlPXUuX2Vtc2NyaXB0ZW5fc3RhY2tfc2V0X2xpbWl0cz11LmFzbS5DYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxFZT11LnN0YWNrU2F2ZT1mdW5jdGlvbigpe3JldHVybihFZT11LnN0YWNrU2F2ZT11LmFzbS5EYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxNZT11LnN0YWNrUmVzdG9yZT1mdW5jdGlvbigpe3JldHVybihNZT11LnN0YWNrUmVzdG9yZT11LmFzbS5FYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxDZT11LnN0YWNrQWxsb2M9ZnVuY3Rpb24oKXtyZXR1cm4oQ2U9dS5zdGFja0FsbG9jPXUuYXNtLkZiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHhlPXUuX19fY3hhX2Nhbl9jYXRjaD1mdW5jdGlvbigpe3JldHVybih4ZT11Ll9fX2N4YV9jYW5fY2F0Y2g9dS5hc20uR2IpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sUmU9dS5fX19jeGFfaXNfcG9pbnRlcl90eXBlPWZ1bmN0aW9uKCl7cmV0dXJuKFJlPXUuX19fY3hhX2lzX3BvaW50ZXJfdHlwZT11LmFzbS5IYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxrZT11LmR5bkNhbGxfaj1mdW5jdGlvbigpe3JldHVybihrZT11LmR5bkNhbGxfaj11LmFzbS5JYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxqZT11LmR5bkNhbGxfaWlpaWlqPWZ1bmN0aW9uKCl7cmV0dXJuKGplPXUuZHluQ2FsbF9paWlpaWo9dS5hc20uSmIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sRGU9dS5keW5DYWxsX2ppaT1mdW5jdGlvbigpe3JldHVybihEZT11LmR5bkNhbGxfamlpPXUuYXNtLktiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LFBlPXUuZHluQ2FsbF92aWlpaWlqPWZ1bmN0aW9uKCl7cmV0dXJuKFBlPXUuZHluQ2FsbF92aWlpaWlqPXUuYXNtLkxiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LFVlPXUuZHluQ2FsbF92amppPWZ1bmN0aW9uKCl7cmV0dXJuKFVlPXUuZHluQ2FsbF92amppPXUuYXNtLk1iKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LEZlPXUuZHluQ2FsbF92aWlpampqaWk9ZnVuY3Rpb24oKXtyZXR1cm4oRmU9dS5keW5DYWxsX3ZpaWlqamppaT11LmFzbS5OYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxJZT11LmR5bkNhbGxfaWlqPWZ1bmN0aW9uKCl7cmV0dXJuKEllPXUuZHluQ2FsbF9paWo9dS5hc20uT2IpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sV2U9dS5keW5DYWxsX2ppPWZ1bmN0aW9uKCl7cmV0dXJuKFdlPXUuZHluQ2FsbF9qaT11LmFzbS5QYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxIZT11LmR5bkNhbGxfaWlpaWlpaj1mdW5jdGlvbigpe3JldHVybihIZT11LmR5bkNhbGxfaWlpaWlpaj11LmFzbS5RYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSx6ZT11LmR5bkNhbGxfaWlpaj1mdW5jdGlvbigpe3JldHVybih6ZT11LmR5bkNhbGxfaWlpaj11LmFzbS5SYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfTtmdW5jdGlvbiBMZSgpe2Z1bmN0aW9uIHQoKXtpZighdmUmJih2ZT0hMCx1LmNhbGxlZFJ1bj0hMCwhSCkmJihPfHxkdChYKSxzKHUpLHUub25SdW50aW1lSW5pdGlhbGl6ZWQmJnUub25SdW50aW1lSW5pdGlhbGl6ZWQoKSwhTykpe2lmKHUucG9zdFJ1bilmb3IoXCJmdW5jdGlvblwiPT10eXBlb2YgdS5wb3N0UnVuJiYodS5wb3N0UnVuPVt1LnBvc3RSdW5dKTt1LnBvc3RSdW4ubGVuZ3RoOyl7dmFyIHQ9dS5wb3N0UnVuLnNoaWZ0KCk7Wi51bnNoaWZ0KHQpfWR0KFopfX1pZighKDA8ZXQpKWlmKE8pcyh1KSxPfHxkdChYKSxwb3N0TWVzc2FnZSh7Y21kOlwibG9hZGVkXCJ9KTtlbHNle2lmKHUucHJlUnVuKWZvcihcImZ1bmN0aW9uXCI9PXR5cGVvZiB1LnByZVJ1biYmKHUucHJlUnVuPVt1LnByZVJ1bl0pO3UucHJlUnVuLmxlbmd0aDspSygpO2R0KCQpLDA8ZXR8fCh1LnNldFN0YXR1cz8odS5zZXRTdGF0dXMoXCJSdW5uaW5nLi4uXCIpLHNldFRpbWVvdXQoKGZ1bmN0aW9uKCl7c2V0VGltZW91dCgoZnVuY3Rpb24oKXt1LnNldFN0YXR1cyhcIlwiKX0pLDEpLHQoKX0pLDEpKTp0KCkpfX1pZih1LlVURjhUb1N0cmluZz1ZLHUuc3RyaW5nVG9VVEY4PWZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gQih0LHIoKSxlLG4pfSx1Lmxlbmd0aEJ5dGVzVVRGOD1HLHUua2VlcFJ1bnRpbWVBbGl2ZT1RLHUud2FzbU1lbW9yeT1rLHUuc3RhY2tTYXZlPUVlLHUuc3RhY2tSZXN0b3JlPU1lLHUuc3RhY2tBbGxvYz1DZSx1LkV4aXRTdGF0dXM9c3QsdS5QVGhyZWFkPWh0LHJ0PWZ1bmN0aW9uIHQoKXt2ZXx8TGUoKSx2ZXx8KHJ0PXQpfSx1LnByZUluaXQpZm9yKFwiZnVuY3Rpb25cIj09dHlwZW9mIHUucHJlSW5pdCYmKHUucHJlSW5pdD1bdS5wcmVJbml0XSk7MDx1LnByZUluaXQubGVuZ3RoOyl1LnByZUluaXQucG9wKCkoKTtyZXR1cm4gTGUoKSx0LnJlYWR5fSk7dC5leHBvcnRzPXJ9LDkzMjoodCxlLG4pPT57dmFyIF9zY3JpcHREaXIscj0oX3NjcmlwdERpcj0oX3NjcmlwdERpcj1cInVuZGVmaW5lZFwiIT10eXBlb2YgZG9jdW1lbnQmJmRvY3VtZW50LmN1cnJlbnRTY3JpcHQ/ZG9jdW1lbnQuY3VycmVudFNjcmlwdC5zcmM6dm9pZCAwKXx8X19maWxlbmFtZSxmdW5jdGlvbih0KXt2YXIgZSxyLGE7dD10fHx7fSxlfHwoZT12b2lkIDAhPT10P3Q6e30pLGUucmVhZHk9bmV3IFByb21pc2UoKGZ1bmN0aW9uKHQsZSl7cj10LGE9ZX0pKTt2YXIgaSxvLHUscyxjLGwsZj1PYmplY3QuYXNzaWduKHt9LGUpLHA9XCIuL3RoaXMucHJvZ3JhbVwiLGg9KHQsZSk9Pnt0aHJvdyBlfSxkPVwib2JqZWN0XCI9PXR5cGVvZiB3aW5kb3cseT1cImZ1bmN0aW9uXCI9PXR5cGVvZiBpbXBvcnRTY3JpcHRzLGI9XCJvYmplY3RcIj09dHlwZW9mIHByb2Nlc3MmJlwib2JqZWN0XCI9PXR5cGVvZiBwcm9jZXNzLnZlcnNpb25zJiZcInN0cmluZ1wiPT10eXBlb2YgcHJvY2Vzcy52ZXJzaW9ucy5ub2RlLG09XCJcIjtiPyhtPXk/bigxNykuZGlybmFtZShtKStcIi9cIjpfX2Rpcm5hbWUrXCIvXCIsbD0oKT0+e2N8fChzPW4oMTQ3KSxjPW4oMTcpKX0saT1mdW5jdGlvbih0LGUpe3JldHVybiBsKCksdD1jLm5vcm1hbGl6ZSh0KSxzLnJlYWRGaWxlU3luYyh0LGU/dm9pZCAwOlwidXRmOFwiKX0sdT10PT4oKHQ9aSh0LCEwKSkuYnVmZmVyfHwodD1uZXcgVWludDhBcnJheSh0KSksdCksbz0odCxlLG4pPT57bCgpLHQ9Yy5ub3JtYWxpemUodCkscy5yZWFkRmlsZSh0LChmdW5jdGlvbih0LHIpe3Q/bih0KTplKHIuYnVmZmVyKX0pKX0sMTxwcm9jZXNzLmFyZ3YubGVuZ3RoJiYocD1wcm9jZXNzLmFyZ3ZbMV0ucmVwbGFjZSgvXFxcXFxcXFwvZyxcIi9cIikpLHByb2Nlc3MuYXJndi5zbGljZSgyKSxwcm9jZXNzLm9uKFwidW5jYXVnaHRFeGNlcHRpb25cIiwoZnVuY3Rpb24odCl7aWYoISh0IGluc3RhbmNlb2YgSikpdGhyb3cgdH0pKSxwcm9jZXNzLm9uKFwidW5oYW5kbGVkUmVqZWN0aW9uXCIsKGZ1bmN0aW9uKHQpe3Rocm93IHR9KSksaD0odCxlKT0+e2lmKHd8fDA8eil0aHJvdyBwcm9jZXNzLmV4aXRDb2RlPXQsZTtlIGluc3RhbmNlb2YgSnx8XyhcImV4aXRpbmcgZHVlIHRvIGV4Y2VwdGlvbjogXCIrZSkscHJvY2Vzcy5leGl0KHQpfSxlLmluc3BlY3Q9ZnVuY3Rpb24oKXtyZXR1cm5cIltFbXNjcmlwdGVuIE1vZHVsZSBvYmplY3RdXCJ9KTooZHx8eSkmJih5P209c2VsZi5sb2NhdGlvbi5ocmVmOlwidW5kZWZpbmVkXCIhPXR5cGVvZiBkb2N1bWVudCYmZG9jdW1lbnQuY3VycmVudFNjcmlwdCYmKG09ZG9jdW1lbnQuY3VycmVudFNjcmlwdC5zcmMpLF9zY3JpcHREaXImJihtPV9zY3JpcHREaXIpLG09MCE9PW0uaW5kZXhPZihcImJsb2I6XCIpP20uc3Vic3RyKDAsbS5yZXBsYWNlKC9bPyNdLiovLFwiXCIpLmxhc3RJbmRleE9mKFwiL1wiKSsxKTpcIlwiLGk9dD0+e3ZhciBlPW5ldyBYTUxIdHRwUmVxdWVzdDtyZXR1cm4gZS5vcGVuKFwiR0VUXCIsdCwhMSksZS5zZW5kKG51bGwpLGUucmVzcG9uc2VUZXh0fSx5JiYodT10PT57dmFyIGU9bmV3IFhNTEh0dHBSZXF1ZXN0O3JldHVybiBlLm9wZW4oXCJHRVRcIix0LCExKSxlLnJlc3BvbnNlVHlwZT1cImFycmF5YnVmZmVyXCIsZS5zZW5kKG51bGwpLG5ldyBVaW50OEFycmF5KGUucmVzcG9uc2UpfSksbz0odCxlLG4pPT57dmFyIHI9bmV3IFhNTEh0dHBSZXF1ZXN0O3Iub3BlbihcIkdFVFwiLHQsITApLHIucmVzcG9uc2VUeXBlPVwiYXJyYXlidWZmZXJcIixyLm9ubG9hZD0oKT0+ezIwMD09ci5zdGF0dXN8fDA9PXIuc3RhdHVzJiZyLnJlc3BvbnNlP2Uoci5yZXNwb25zZSk6bigpfSxyLm9uZXJyb3I9bixyLnNlbmQobnVsbCl9KTt2YXIgZyx2PWUucHJpbnR8fGNvbnNvbGUubG9nLmJpbmQoY29uc29sZSksXz1lLnByaW50RXJyfHxjb25zb2xlLndhcm4uYmluZChjb25zb2xlKTtPYmplY3QuYXNzaWduKGUsZiksZj1udWxsLGUudGhpc1Byb2dyYW0mJihwPWUudGhpc1Byb2dyYW0pLGUucXVpdCYmKGg9ZS5xdWl0KSxlLndhc21CaW5hcnkmJihnPWUud2FzbUJpbmFyeSk7dmFyIHc9ZS5ub0V4aXRSdW50aW1lfHwhMTtcIm9iamVjdFwiIT10eXBlb2YgV2ViQXNzZW1ibHkmJlYoXCJubyBuYXRpdmUgd2FzbSBzdXBwb3J0IGRldGVjdGVkXCIpO3ZhciBPLEEsUyxULEUsTSxDPSExLHg9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIFRleHREZWNvZGVyP25ldyBUZXh0RGVjb2RlcihcInV0ZjhcIik6dm9pZCAwO2Z1bmN0aW9uIFIodCxlLG4pe3ZhciByPShlPj4+PTApK247Zm9yKG49ZTt0W25dJiYhKG4+PXIpOykrK247aWYoMTY8bi1lJiZ0LmJ1ZmZlciYmeClyZXR1cm4geC5kZWNvZGUodC5zdWJhcnJheShlLG4pKTtmb3Iocj1cIlwiO2U8bjspe3ZhciBhPXRbZSsrXTtpZigxMjgmYSl7dmFyIGk9NjMmdFtlKytdO2lmKDE5Mj09KDIyNCZhKSlyKz1TdHJpbmcuZnJvbUNoYXJDb2RlKCgzMSZhKTw8NnxpKTtlbHNle3ZhciBvPTYzJnRbZSsrXTs2NTUzNj4oYT0yMjQ9PSgyNDAmYSk/KDE1JmEpPDwxMnxpPDw2fG86KDcmYSk8PDE4fGk8PDEyfG88PDZ8NjMmdFtlKytdKT9yKz1TdHJpbmcuZnJvbUNoYXJDb2RlKGEpOihhLT02NTUzNixyKz1TdHJpbmcuZnJvbUNoYXJDb2RlKDU1Mjk2fGE+PjEwLDU2MzIwfDEwMjMmYSkpfX1lbHNlIHIrPVN0cmluZy5mcm9tQ2hhckNvZGUoYSl9cmV0dXJuIHJ9ZnVuY3Rpb24gayh0LGUpe3JldHVybih0Pj4+PTApP1IoVCx0LGUpOlwiXCJ9ZnVuY3Rpb24gaih0LGUsbixyKXtpZighKDA8cikpcmV0dXJuIDA7dmFyIGE9bj4+Pj0wO3I9bityLTE7Zm9yKHZhciBpPTA7aTx0Lmxlbmd0aDsrK2kpe3ZhciBvPXQuY2hhckNvZGVBdChpKTtpZig1NTI5Njw9byYmNTczNDM+PW8mJihvPTY1NTM2KygoMTAyMyZvKTw8MTApfDEwMjMmdC5jaGFyQ29kZUF0KCsraSkpLDEyNz49byl7aWYobj49cilicmVhaztlW24rKz4+PjBdPW99ZWxzZXtpZigyMDQ3Pj1vKXtpZihuKzE+PXIpYnJlYWs7ZVtuKys+Pj4wXT0xOTJ8bz4+Nn1lbHNle2lmKDY1NTM1Pj1vKXtpZihuKzI+PXIpYnJlYWs7ZVtuKys+Pj4wXT0yMjR8bz4+MTJ9ZWxzZXtpZihuKzM+PXIpYnJlYWs7ZVtuKys+Pj4wXT0yNDB8bz4+MTgsZVtuKys+Pj4wXT0xMjh8bz4+MTImNjN9ZVtuKys+Pj4wXT0xMjh8bz4+NiY2M31lW24rKz4+PjBdPTEyOHw2MyZvfX1yZXR1cm4gZVtuPj4+MF09MCxuLWF9ZnVuY3Rpb24gRCh0KXtmb3IodmFyIGU9MCxuPTA7bjx0Lmxlbmd0aDsrK24pe3ZhciByPXQuY2hhckNvZGVBdChuKTsxMjc+PXI/ZSsrOjIwNDc+PXI/ZSs9Mjo1NTI5Njw9ciYmNTczNDM+PXI/KGUrPTQsKytuKTplKz0zfXJldHVybiBlfWZ1bmN0aW9uIFAoKXt2YXIgdD1PLmJ1ZmZlcjtBPXQsZS5IRUFQOD1TPW5ldyBJbnQ4QXJyYXkodCksZS5IRUFQMTY9bmV3IEludDE2QXJyYXkodCksZS5IRUFQMzI9RT1uZXcgSW50MzJBcnJheSh0KSxlLkhFQVBVOD1UPW5ldyBVaW50OEFycmF5KHQpLGUuSEVBUFUxNj1uZXcgVWludDE2QXJyYXkodCksZS5IRUFQVTMyPU09bmV3IFVpbnQzMkFycmF5KHQpLGUuSEVBUEYzMj1uZXcgRmxvYXQzMkFycmF5KHQpLGUuSEVBUEY2ND1uZXcgRmxvYXQ2NEFycmF5KHQpfXZhciBVLEY9W10sST1bXSxXPVtdLEg9W10sej0wO2Z1bmN0aW9uIEwoKXt2YXIgdD1lLnByZVJ1bi5zaGlmdCgpO0YudW5zaGlmdCh0KX12YXIgWSxCPTAsRz1udWxsLE49bnVsbDtmdW5jdGlvbiBWKHQpe3Rocm93IGUub25BYm9ydCYmZS5vbkFib3J0KHQpLF8odD1cIkFib3J0ZWQoXCIrdCtcIilcIiksQz0hMCx0PW5ldyBXZWJBc3NlbWJseS5SdW50aW1lRXJyb3IodCtcIi4gQnVpbGQgd2l0aCAtc0FTU0VSVElPTlMgZm9yIG1vcmUgaW5mby5cIiksYSh0KSx0fWZ1bmN0aW9uIHEoKXtyZXR1cm4gWS5zdGFydHNXaXRoKFwiZGF0YTphcHBsaWNhdGlvbi9vY3RldC1zdHJlYW07YmFzZTY0LFwiKX1pZihZPVwib3J0LXdhc20ud2FzbVwiLCFxKCkpe3ZhciAkPVk7WT1lLmxvY2F0ZUZpbGU/ZS5sb2NhdGVGaWxlKCQsbSk6bSskfWZ1bmN0aW9uIFgoKXt2YXIgdD1ZO3RyeXtpZih0PT1ZJiZnKXJldHVybiBuZXcgVWludDhBcnJheShnKTtpZih1KXJldHVybiB1KHQpO3Rocm93XCJib3RoIGFzeW5jIGFuZCBzeW5jIGZldGNoaW5nIG9mIHRoZSB3YXNtIGZhaWxlZFwifWNhdGNoKHQpe1YodCl9fWZ1bmN0aW9uIEoodCl7dGhpcy5uYW1lPVwiRXhpdFN0YXR1c1wiLHRoaXMubWVzc2FnZT1cIlByb2dyYW0gdGVybWluYXRlZCB3aXRoIGV4aXQoXCIrdCtcIilcIix0aGlzLnN0YXR1cz10fWZ1bmN0aW9uIFoodCl7Zm9yKDswPHQubGVuZ3RoOyl0LnNoaWZ0KCkoZSl9dmFyIFE9W10sSz0wLHR0PTA7ZnVuY3Rpb24gZXQodCl7dGhpcy5EYj10LHRoaXMuemI9dC0yNCx0aGlzLlViPWZ1bmN0aW9uKHQpe01bdGhpcy56Yis0Pj4yPj4+MF09dH0sdGhpcy5FYj1mdW5jdGlvbigpe3JldHVybiBNW3RoaXMuemIrND4+Mj4+PjBdfSx0aGlzLlNiPWZ1bmN0aW9uKHQpe01bdGhpcy56Yis4Pj4yPj4+MF09dH0sdGhpcy5XYj1mdW5jdGlvbigpe3JldHVybiBNW3RoaXMuemIrOD4+Mj4+PjBdfSx0aGlzLlRiPWZ1bmN0aW9uKCl7RVt0aGlzLnpiPj4yPj4+MF09MH0sdGhpcy5JYj1mdW5jdGlvbih0KXtTW3RoaXMuemIrMTI+PjA+Pj4wXT10PzE6MH0sdGhpcy5QYj1mdW5jdGlvbigpe3JldHVybiAwIT1TW3RoaXMuemIrMTI+PjA+Pj4wXX0sdGhpcy5KYj1mdW5jdGlvbih0KXtTW3RoaXMuemIrMTM+PjA+Pj4wXT10PzE6MH0sdGhpcy5MYj1mdW5jdGlvbigpe3JldHVybiAwIT1TW3RoaXMuemIrMTM+PjA+Pj4wXX0sdGhpcy5SYj1mdW5jdGlvbih0LGUpe3RoaXMuRmIoMCksdGhpcy5VYih0KSx0aGlzLlNiKGUpLHRoaXMuVGIoKSx0aGlzLkliKCExKSx0aGlzLkpiKCExKX0sdGhpcy5OYj1mdW5jdGlvbigpe0VbdGhpcy56Yj4+Mj4+PjBdKz0xfSx0aGlzLlhiPWZ1bmN0aW9uKCl7dmFyIHQ9RVt0aGlzLnpiPj4yPj4+MF07cmV0dXJuIEVbdGhpcy56Yj4+Mj4+PjBdPXQtMSwxPT09dH0sdGhpcy5GYj1mdW5jdGlvbih0KXtNW3RoaXMuemIrMTY+PjI+Pj4wXT10fSx0aGlzLk9iPWZ1bmN0aW9uKCl7cmV0dXJuIE1bdGhpcy56YisxNj4+Mj4+PjBdfSx0aGlzLlFiPWZ1bmN0aW9uKCl7aWYoTXQodGhpcy5FYigpKSlyZXR1cm4gTVt0aGlzLkRiPj4yPj4+MF07dmFyIHQ9dGhpcy5PYigpO3JldHVybiAwIT09dD90OnRoaXMuRGJ9fWZ1bmN0aW9uIG50KHQpe3JldHVybiB2dChuZXcgZXQodCkuemIpfXZhciBydD1bXTtmdW5jdGlvbiBhdCh0KXt2YXIgZT1ydFt0XTtyZXR1cm4gZXx8KHQ+PXJ0Lmxlbmd0aCYmKHJ0Lmxlbmd0aD10KzEpLHJ0W3RdPWU9VS5nZXQodCkpLGV9ZnVuY3Rpb24gaXQodCl7dmFyIGU9RCh0KSsxLG49Z3QoZSk7cmV0dXJuIG4mJmoodCxTLG4sZSksbn12YXIgb3Q9e307ZnVuY3Rpb24gdXQoKXtpZighc3Qpe3ZhciB0LGU9e1VTRVI6XCJ3ZWJfdXNlclwiLExPR05BTUU6XCJ3ZWJfdXNlclwiLFBBVEg6XCIvXCIsUFdEOlwiL1wiLEhPTUU6XCIvaG9tZS93ZWJfdXNlclwiLExBTkc6KFwib2JqZWN0XCI9PXR5cGVvZiBuYXZpZ2F0b3ImJm5hdmlnYXRvci5sYW5ndWFnZXMmJm5hdmlnYXRvci5sYW5ndWFnZXNbMF18fFwiQ1wiKS5yZXBsYWNlKFwiLVwiLFwiX1wiKStcIi5VVEYtOFwiLF86cHx8XCIuL3RoaXMucHJvZ3JhbVwifTtmb3IodCBpbiBvdCl2b2lkIDA9PT1vdFt0XT9kZWxldGUgZVt0XTplW3RdPW90W3RdO3ZhciBuPVtdO2Zvcih0IGluIGUpbi5wdXNoKHQrXCI9XCIrZVt0XSk7c3Q9bn1yZXR1cm4gc3R9dmFyIHN0LGN0PVtudWxsLFtdLFtdXTtmdW5jdGlvbiBsdCh0LGUpe3ZhciBuPWN0W3RdOzA9PT1lfHwxMD09PWU/KCgxPT09dD92Ol8pKFIobiwwKSksbi5sZW5ndGg9MCk6bi5wdXNoKGUpfXZhciBmdD0wO2Z1bmN0aW9uIHB0KHQpe3JldHVybiAwPT10JTQmJigwIT10JTEwMHx8MD09dCU0MDApfXZhciBodD1bMzEsMjksMzEsMzAsMzEsMzAsMzEsMzEsMzAsMzEsMzAsMzFdLGR0PVszMSwyOCwzMSwzMCwzMSwzMCwzMSwzMSwzMCwzMSwzMCwzMV07ZnVuY3Rpb24geXQodCxlLG4scil7ZnVuY3Rpb24gYSh0LGUsbil7Zm9yKHQ9XCJudW1iZXJcIj09dHlwZW9mIHQ/dC50b1N0cmluZygpOnR8fFwiXCI7dC5sZW5ndGg8ZTspdD1uWzBdK3Q7cmV0dXJuIHR9ZnVuY3Rpb24gaSh0LGUpe3JldHVybiBhKHQsZSxcIjBcIil9ZnVuY3Rpb24gbyh0LGUpe2Z1bmN0aW9uIG4odCl7cmV0dXJuIDA+dD8tMTowPHQ/MTowfXZhciByO3JldHVybiAwPT09KHI9bih0LmdldEZ1bGxZZWFyKCktZS5nZXRGdWxsWWVhcigpKSkmJjA9PT0ocj1uKHQuZ2V0TW9udGgoKS1lLmdldE1vbnRoKCkpKSYmKHI9bih0LmdldERhdGUoKS1lLmdldERhdGUoKSkpLHJ9ZnVuY3Rpb24gdSh0KXtzd2l0Y2godC5nZXREYXkoKSl7Y2FzZSAwOnJldHVybiBuZXcgRGF0ZSh0LmdldEZ1bGxZZWFyKCktMSwxMSwyOSk7Y2FzZSAxOnJldHVybiB0O2Nhc2UgMjpyZXR1cm4gbmV3IERhdGUodC5nZXRGdWxsWWVhcigpLDAsMyk7Y2FzZSAzOnJldHVybiBuZXcgRGF0ZSh0LmdldEZ1bGxZZWFyKCksMCwyKTtjYXNlIDQ6cmV0dXJuIG5ldyBEYXRlKHQuZ2V0RnVsbFllYXIoKSwwLDEpO2Nhc2UgNTpyZXR1cm4gbmV3IERhdGUodC5nZXRGdWxsWWVhcigpLTEsMTEsMzEpO2Nhc2UgNjpyZXR1cm4gbmV3IERhdGUodC5nZXRGdWxsWWVhcigpLTEsMTEsMzApfX1mdW5jdGlvbiBzKHQpe3ZhciBlPXQuQmI7Zm9yKHQ9bmV3IERhdGUobmV3IERhdGUodC5DYisxOTAwLDAsMSkuZ2V0VGltZSgpKTswPGU7KXt2YXIgbj10LmdldE1vbnRoKCkscj0ocHQodC5nZXRGdWxsWWVhcigpKT9odDpkdClbbl07aWYoIShlPnItdC5nZXREYXRlKCkpKXt0LnNldERhdGUodC5nZXREYXRlKCkrZSk7YnJlYWt9ZS09ci10LmdldERhdGUoKSsxLHQuc2V0RGF0ZSgxKSwxMT5uP3Quc2V0TW9udGgobisxKToodC5zZXRNb250aCgwKSx0LnNldEZ1bGxZZWFyKHQuZ2V0RnVsbFllYXIoKSsxKSl9cmV0dXJuIG49bmV3IERhdGUodC5nZXRGdWxsWWVhcigpKzEsMCw0KSxlPXUobmV3IERhdGUodC5nZXRGdWxsWWVhcigpLDAsNCkpLG49dShuKSwwPj1vKGUsdCk/MD49byhuLHQpP3QuZ2V0RnVsbFllYXIoKSsxOnQuZ2V0RnVsbFllYXIoKTp0LmdldEZ1bGxZZWFyKCktMX12YXIgYz1FW3IrNDA+PjI+Pj4wXTtmb3IodmFyIGwgaW4gcj17JGI6RVtyPj4yPj4+MF0sWmI6RVtyKzQ+PjI+Pj4wXSxHYjpFW3IrOD4+Mj4+PjBdLEtiOkVbcisxMj4+Mj4+PjBdLEhiOkVbcisxNj4+Mj4+PjBdLENiOkVbcisyMD4+Mj4+PjBdLEFiOkVbcisyND4+Mj4+PjBdLEJiOkVbcisyOD4+Mj4+PjBdLGJjOkVbciszMj4+Mj4+PjBdLFliOkVbciszNj4+Mj4+PjBdLGFjOmM/ayhjKTpcIlwifSxuPWsobiksYz17XCIlY1wiOlwiJWEgJWIgJWQgJUg6JU06JVMgJVlcIixcIiVEXCI6XCIlbS8lZC8leVwiLFwiJUZcIjpcIiVZLSVtLSVkXCIsXCIlaFwiOlwiJWJcIixcIiVyXCI6XCIlSTolTTolUyAlcFwiLFwiJVJcIjpcIiVIOiVNXCIsXCIlVFwiOlwiJUg6JU06JVNcIixcIiV4XCI6XCIlbS8lZC8leVwiLFwiJVhcIjpcIiVIOiVNOiVTXCIsXCIlRWNcIjpcIiVjXCIsXCIlRUNcIjpcIiVDXCIsXCIlRXhcIjpcIiVtLyVkLyV5XCIsXCIlRVhcIjpcIiVIOiVNOiVTXCIsXCIlRXlcIjpcIiV5XCIsXCIlRVlcIjpcIiVZXCIsXCIlT2RcIjpcIiVkXCIsXCIlT2VcIjpcIiVlXCIsXCIlT0hcIjpcIiVIXCIsXCIlT0lcIjpcIiVJXCIsXCIlT21cIjpcIiVtXCIsXCIlT01cIjpcIiVNXCIsXCIlT1NcIjpcIiVTXCIsXCIlT3VcIjpcIiV1XCIsXCIlT1VcIjpcIiVVXCIsXCIlT1ZcIjpcIiVWXCIsXCIlT3dcIjpcIiV3XCIsXCIlT1dcIjpcIiVXXCIsXCIlT3lcIjpcIiV5XCJ9KW49bi5yZXBsYWNlKG5ldyBSZWdFeHAobCxcImdcIiksY1tsXSk7dmFyIGY9XCJTdW5kYXkgTW9uZGF5IFR1ZXNkYXkgV2VkbmVzZGF5IFRodXJzZGF5IEZyaWRheSBTYXR1cmRheVwiLnNwbGl0KFwiIFwiKSxwPVwiSmFudWFyeSBGZWJydWFyeSBNYXJjaCBBcHJpbCBNYXkgSnVuZSBKdWx5IEF1Z3VzdCBTZXB0ZW1iZXIgT2N0b2JlciBOb3ZlbWJlciBEZWNlbWJlclwiLnNwbGl0KFwiIFwiKTtmb3IobCBpbiBjPXtcIiVhXCI6ZnVuY3Rpb24odCl7cmV0dXJuIGZbdC5BYl0uc3Vic3RyaW5nKDAsMyl9LFwiJUFcIjpmdW5jdGlvbih0KXtyZXR1cm4gZlt0LkFiXX0sXCIlYlwiOmZ1bmN0aW9uKHQpe3JldHVybiBwW3QuSGJdLnN1YnN0cmluZygwLDMpfSxcIiVCXCI6ZnVuY3Rpb24odCl7cmV0dXJuIHBbdC5IYl19LFwiJUNcIjpmdW5jdGlvbih0KXtyZXR1cm4gaSgodC5DYisxOTAwKS8xMDB8MCwyKX0sXCIlZFwiOmZ1bmN0aW9uKHQpe3JldHVybiBpKHQuS2IsMil9LFwiJWVcIjpmdW5jdGlvbih0KXtyZXR1cm4gYSh0LktiLDIsXCIgXCIpfSxcIiVnXCI6ZnVuY3Rpb24odCl7cmV0dXJuIHModCkudG9TdHJpbmcoKS5zdWJzdHJpbmcoMil9LFwiJUdcIjpmdW5jdGlvbih0KXtyZXR1cm4gcyh0KX0sXCIlSFwiOmZ1bmN0aW9uKHQpe3JldHVybiBpKHQuR2IsMil9LFwiJUlcIjpmdW5jdGlvbih0KXtyZXR1cm4gMD09KHQ9dC5HYik/dD0xMjoxMjx0JiYodC09MTIpLGkodCwyKX0sXCIlalwiOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT0wLG49MDtuPD10LkhiLTE7ZSs9KHB0KHQuQ2IrMTkwMCk/aHQ6ZHQpW24rK10pO3JldHVybiBpKHQuS2IrZSwzKX0sXCIlbVwiOmZ1bmN0aW9uKHQpe3JldHVybiBpKHQuSGIrMSwyKX0sXCIlTVwiOmZ1bmN0aW9uKHQpe3JldHVybiBpKHQuWmIsMil9LFwiJW5cIjpmdW5jdGlvbigpe3JldHVyblwiXFxcXG5cIn0sXCIlcFwiOmZ1bmN0aW9uKHQpe3JldHVybiAwPD10LkdiJiYxMj50LkdiP1wiQU1cIjpcIlBNXCJ9LFwiJVNcIjpmdW5jdGlvbih0KXtyZXR1cm4gaSh0LiRiLDIpfSxcIiV0XCI6ZnVuY3Rpb24oKXtyZXR1cm5cIlxcXFx0XCJ9LFwiJXVcIjpmdW5jdGlvbih0KXtyZXR1cm4gdC5BYnx8N30sXCIlVVwiOmZ1bmN0aW9uKHQpe3JldHVybiBpKE1hdGguZmxvb3IoKHQuQmIrNy10LkFiKS83KSwyKX0sXCIlVlwiOmZ1bmN0aW9uKHQpe3ZhciBlPU1hdGguZmxvb3IoKHQuQmIrNy0odC5BYis2KSU3KS83KTtpZigyPj0odC5BYiszNzEtdC5CYi0yKSU3JiZlKyssZSk1Mz09ZSYmKDQ9PShuPSh0LkFiKzM3MS10LkJiKSU3KXx8Mz09biYmcHQodC5DYil8fChlPTEpKTtlbHNle2U9NTI7dmFyIG49KHQuQWIrNy10LkJiLTEpJTc7KDQ9PW58fDU9PW4mJnB0KHQuQ2IlNDAwLTEpKSYmZSsrfXJldHVybiBpKGUsMil9LFwiJXdcIjpmdW5jdGlvbih0KXtyZXR1cm4gdC5BYn0sXCIlV1wiOmZ1bmN0aW9uKHQpe3JldHVybiBpKE1hdGguZmxvb3IoKHQuQmIrNy0odC5BYis2KSU3KS83KSwyKX0sXCIleVwiOmZ1bmN0aW9uKHQpe3JldHVybih0LkNiKzE5MDApLnRvU3RyaW5nKCkuc3Vic3RyaW5nKDIpfSxcIiVZXCI6ZnVuY3Rpb24odCl7cmV0dXJuIHQuQ2IrMTkwMH0sXCIlelwiOmZ1bmN0aW9uKHQpe3ZhciBlPTA8PSh0PXQuWWIpO3JldHVybiB0PU1hdGguYWJzKHQpLzYwLChlP1wiK1wiOlwiLVwiKStTdHJpbmcoXCIwMDAwXCIrKHQvNjAqMTAwK3QlNjApKS5zbGljZSgtNCl9LFwiJVpcIjpmdW5jdGlvbih0KXtyZXR1cm4gdC5hY30sXCIlJVwiOmZ1bmN0aW9uKCl7cmV0dXJuXCIlXCJ9fSxuPW4ucmVwbGFjZSgvJSUvZyxcIlxcXFwwXFxcXDBcIiksYyluLmluY2x1ZGVzKGwpJiYobj1uLnJlcGxhY2UobmV3IFJlZ0V4cChsLFwiZ1wiKSxjW2xdKHIpKSk7cmV0dXJuIGw9ZnVuY3Rpb24odCl7dmFyIGU9QXJyYXkoRCh0KSsxKTtyZXR1cm4gaih0LGUsMCxlLmxlbmd0aCksZX0obj1uLnJlcGxhY2UoL1xcXFwwXFxcXDAvZyxcIiVcIikpLGwubGVuZ3RoPmU/MDooUy5zZXQobCx0Pj4+MCksbC5sZW5ndGgtMSl9dmFyIGJ0PXthOmZ1bmN0aW9uKHQpe3JldHVybiBndCh0KzI0KSsyNH0sbTpmdW5jdGlvbih0KXtyZXR1cm4odD1uZXcgZXQodCkpLlBiKCl8fCh0LkliKCEwKSxLLS0pLHQuSmIoITEpLFEucHVzaCh0KSx0Lk5iKCksdC5RYigpfSxpYTpmdW5jdGlvbih0KXt0aHJvdyBfKFwiVW5leHBlY3RlZCBleGNlcHRpb24gdGhyb3duLCB0aGlzIGlzIG5vdCBwcm9wZXJseSBzdXBwb3J0ZWQgLSBhYm9ydGluZ1wiKSxDPSEwLHR9LHc6ZnVuY3Rpb24oKXtPdCgwKTt2YXIgdD1RLnBvcCgpO2lmKHQuWGIoKSYmIXQuTGIoKSl7dmFyIGU9dC5XYigpO2UmJmF0KGUpKHQuRGIpLG50KHQuRGIpfXR0PTB9LGQ6ZnVuY3Rpb24oKXt2YXIgdD10dDtpZighdClyZXR1cm4gZnQ9MDt2YXIgZT1uZXcgZXQodCk7ZS5GYih0KTt2YXIgbj1lLkViKCk7aWYoIW4pcmV0dXJuIGZ0PTAsdDtmb3IodmFyIHI9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSxhPTA7YTxyLmxlbmd0aDthKyspe3ZhciBpPXJbYV07aWYoMD09PWl8fGk9PT1uKWJyZWFrO2lmKEV0KGksbixlLnpiKzE2KSlyZXR1cm4gZnQ9aSx0fXJldHVybiBmdD1uLHR9LGs6ZnVuY3Rpb24oKXt2YXIgdD10dDtpZighdClyZXR1cm4gZnQ9MDt2YXIgZT1uZXcgZXQodCk7ZS5GYih0KTt2YXIgbj1lLkViKCk7aWYoIW4pcmV0dXJuIGZ0PTAsdDtmb3IodmFyIHI9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSxhPTA7YTxyLmxlbmd0aDthKyspe3ZhciBpPXJbYV07aWYoMD09PWl8fGk9PT1uKWJyZWFrO2lmKEV0KGksbixlLnpiKzE2KSlyZXR1cm4gZnQ9aSx0fXJldHVybiBmdD1uLHR9LGc6ZnVuY3Rpb24oKXt2YXIgdD10dDtpZighdClyZXR1cm4gZnQ9MDt2YXIgZT1uZXcgZXQodCk7ZS5GYih0KTt2YXIgbj1lLkViKCk7aWYoIW4pcmV0dXJuIGZ0PTAsdDtmb3IodmFyIHI9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSxhPTA7YTxyLmxlbmd0aDthKyspe3ZhciBpPXJbYV07aWYoMD09PWl8fGk9PT1uKWJyZWFrO2lmKEV0KGksbixlLnpiKzE2KSlyZXR1cm4gZnQ9aSx0fXJldHVybiBmdD1uLHR9LHM6bnQsTDpmdW5jdGlvbigpe3ZhciB0PVEucG9wKCk7dHx8VihcIm5vIGV4Y2VwdGlvbiB0byB0aHJvd1wiKTt2YXIgZT10LkRiO3Rocm93IHQuTGIoKXx8KFEucHVzaCh0KSx0LkpiKCEwKSx0LkliKCExKSxLKyspLHR0PWUsZX0sYjpmdW5jdGlvbih0LGUsbil7dGhyb3cgbmV3IGV0KHQpLlJiKGUsbiksdHQ9dCxLKyssdH0sbGE6ZnVuY3Rpb24oKXtyZXR1cm4gS30saTpmdW5jdGlvbih0KXt0aHJvdyB0dHx8KHR0PXQpLHR9LEg6ZnVuY3Rpb24oKXtyZXR1cm4gMH0sQmE6ZnVuY3Rpb24oKXt9LHBhOmZ1bmN0aW9uKCl7fSxyYTpmdW5jdGlvbigpe30sa2E6ZnVuY3Rpb24oKXtyZXR1cm4gMH0semE6ZnVuY3Rpb24oKXt9LHVhOmZ1bmN0aW9uKCl7fSx5YTpmdW5jdGlvbigpe30sUjpmdW5jdGlvbigpe30scWE6ZnVuY3Rpb24oKXt9LG5hOmZ1bmN0aW9uKCl7fSxBYTpmdW5jdGlvbigpe30sb2E6ZnVuY3Rpb24oKXt9LEhhOmZ1bmN0aW9uKCl7fSxKYTpmdW5jdGlvbigpe1YoXCJUbyB1c2UgZGxvcGVuLCB5b3UgbmVlZCBlbmFibGUgZHluYW1pYyBsaW5raW5nLCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2Vtc2NyaXB0ZW4tY29yZS9lbXNjcmlwdGVuL3dpa2kvTGlua2luZ1wiKX0sSWE6ZnVuY3Rpb24oKXtWKFwiVG8gdXNlIGRsb3BlbiwgeW91IG5lZWQgZW5hYmxlIGR5bmFtaWMgbGlua2luZywgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9lbXNjcmlwdGVuLWNvcmUvZW1zY3JpcHRlbi93aWtpL0xpbmtpbmdcIil9LFM6ZnVuY3Rpb24oKXtyZXR1cm4gRGF0ZS5ub3coKX0sQ2E6ZnVuY3Rpb24oKXtyZXR1cm4hMH0sRGE6ZnVuY3Rpb24odCxlKXt0PW5ldyBEYXRlKDFlMyooTVt0Pj4+Ml0rNDI5NDk2NzI5NipFW3QrND4+PjJdKSksRVtlPj4yPj4+MF09dC5nZXRVVENTZWNvbmRzKCksRVtlKzQ+PjI+Pj4wXT10LmdldFVUQ01pbnV0ZXMoKSxFW2UrOD4+Mj4+PjBdPXQuZ2V0VVRDSG91cnMoKSxFW2UrMTI+PjI+Pj4wXT10LmdldFVUQ0RhdGUoKSxFW2UrMTY+PjI+Pj4wXT10LmdldFVUQ01vbnRoKCksRVtlKzIwPj4yPj4+MF09dC5nZXRVVENGdWxsWWVhcigpLTE5MDAsRVtlKzI0Pj4yPj4+MF09dC5nZXRVVENEYXkoKSxFW2UrMjg+PjI+Pj4wXT0odC5nZXRUaW1lKCktRGF0ZS5VVEModC5nZXRVVENGdWxsWWVhcigpLDAsMSwwLDAsMCwwKSkvODY0ZTV8MH0sRWE6ZnVuY3Rpb24odCxlKXt0PW5ldyBEYXRlKDFlMyooTVt0Pj4+Ml0rNDI5NDk2NzI5NipFW3QrND4+PjJdKSksRVtlPj4yPj4+MF09dC5nZXRTZWNvbmRzKCksRVtlKzQ+PjI+Pj4wXT10LmdldE1pbnV0ZXMoKSxFW2UrOD4+Mj4+PjBdPXQuZ2V0SG91cnMoKSxFW2UrMTI+PjI+Pj4wXT10LmdldERhdGUoKSxFW2UrMTY+PjI+Pj4wXT10LmdldE1vbnRoKCksRVtlKzIwPj4yPj4+MF09dC5nZXRGdWxsWWVhcigpLTE5MDAsRVtlKzI0Pj4yPj4+MF09dC5nZXREYXkoKTt2YXIgbj1uZXcgRGF0ZSh0LmdldEZ1bGxZZWFyKCksMCwxKTtFW2UrMjg+PjI+Pj4wXT0odC5nZXRUaW1lKCktbi5nZXRUaW1lKCkpLzg2NGU1fDAsRVtlKzM2Pj4yPj4+MF09LTYwKnQuZ2V0VGltZXpvbmVPZmZzZXQoKTt2YXIgcj1uZXcgRGF0ZSh0LmdldEZ1bGxZZWFyKCksNiwxKS5nZXRUaW1lem9uZU9mZnNldCgpO249bi5nZXRUaW1lem9uZU9mZnNldCgpLEVbZSszMj4+Mj4+PjBdPTB8KHIhPW4mJnQuZ2V0VGltZXpvbmVPZmZzZXQoKT09TWF0aC5taW4obixyKSl9LEZhOmZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBEYXRlKEVbdCsyMD4+Mj4+PjBdKzE5MDAsRVt0KzE2Pj4yPj4+MF0sRVt0KzEyPj4yPj4+MF0sRVt0Kzg+PjI+Pj4wXSxFW3QrND4+Mj4+PjBdLEVbdD4+Mj4+PjBdLDApLG49RVt0KzMyPj4yPj4+MF0scj1lLmdldFRpbWV6b25lT2Zmc2V0KCksYT1uZXcgRGF0ZShlLmdldEZ1bGxZZWFyKCksMCwxKSxpPW5ldyBEYXRlKGUuZ2V0RnVsbFllYXIoKSw2LDEpLmdldFRpbWV6b25lT2Zmc2V0KCksbz1hLmdldFRpbWV6b25lT2Zmc2V0KCksdT1NYXRoLm1pbihvLGkpO3JldHVybiAwPm4/RVt0KzMyPj4yPj4+MF09TnVtYmVyKGkhPW8mJnU9PXIpOjA8biE9KHU9PXIpJiYoaT1NYXRoLm1heChvLGkpLGUuc2V0VGltZShlLmdldFRpbWUoKSs2ZTQqKCgwPG4/dTppKS1yKSkpLEVbdCsyND4+Mj4+PjBdPWUuZ2V0RGF5KCksRVt0KzI4Pj4yPj4+MF09KGUuZ2V0VGltZSgpLWEuZ2V0VGltZSgpKS84NjRlNXwwLEVbdD4+Mj4+PjBdPWUuZ2V0U2Vjb25kcygpLEVbdCs0Pj4yPj4+MF09ZS5nZXRNaW51dGVzKCksRVt0Kzg+PjI+Pj4wXT1lLmdldEhvdXJzKCksRVt0KzEyPj4yPj4+MF09ZS5nZXREYXRlKCksRVt0KzE2Pj4yPj4+MF09ZS5nZXRNb250aCgpLGUuZ2V0VGltZSgpLzFlM3wwfSxzYTpmdW5jdGlvbigpe3JldHVybi01Mn0sdGE6ZnVuY3Rpb24oKXt9LEdhOmZ1bmN0aW9uIHQoZSxuLHIpe3QuVmJ8fCh0LlZiPSEwLGZ1bmN0aW9uKHQsZSxuKXtmdW5jdGlvbiByKHQpe3JldHVybih0PXQudG9UaW1lU3RyaW5nKCkubWF0Y2goL1xcXFwoKFtBLVphLXogXSspXFxcXCkkLykpP3RbMV06XCJHTVRcIn12YXIgYT0obmV3IERhdGUpLmdldEZ1bGxZZWFyKCksaT1uZXcgRGF0ZShhLDAsMSksbz1uZXcgRGF0ZShhLDYsMSk7YT1pLmdldFRpbWV6b25lT2Zmc2V0KCk7dmFyIHU9by5nZXRUaW1lem9uZU9mZnNldCgpO0VbdD4+Mj4+PjBdPTYwKk1hdGgubWF4KGEsdSksRVtlPj4yPj4+MF09TnVtYmVyKGEhPXUpLHQ9cihpKSxlPXIobyksdD1pdCh0KSxlPWl0KGUpLHU8YT8oTVtuPj4yPj4+MF09dCxNW24rND4+Mj4+PjBdPWUpOihNW24+PjI+Pj4wXT1lLE1bbis0Pj4yPj4+MF09dCl9KGUsbixyKSl9LEI6ZnVuY3Rpb24oKXtWKFwiXCIpfSxtYTpmdW5jdGlvbigpe3JldHVybiA0Mjk0OTAxNzYwfSxJOmI/KCk9Pnt2YXIgdD1wcm9jZXNzLmhydGltZSgpO3JldHVybiAxZTMqdFswXSt0WzFdLzFlNn06KCk9PnBlcmZvcm1hbmNlLm5vdygpLHhhOmZ1bmN0aW9uKHQsZSxuKXtULmNvcHlXaXRoaW4odD4+PjAsZT4+PjAsZStuPj4+MCl9LEc6ZnVuY3Rpb24odCl7dmFyIGU9VC5sZW5ndGg7aWYoNDI5NDkwMTc2MDwodD4+Pj0wKSlyZXR1cm4hMTtmb3IodmFyIG49MTs0Pj1uO24qPTIpe3ZhciByPWUqKDErLjIvbik7cj1NYXRoLm1pbihyLHQrMTAwNjYzMjk2KTt2YXIgYT1NYXRoO3I9TWF0aC5tYXgodCxyKSxhPWEubWluLmNhbGwoYSw0Mjk0OTAxNzYwLHIrKDY1NTM2LXIlNjU1MzYpJTY1NTM2KTt0Ont0cnl7Ty5ncm93KGEtQS5ieXRlTGVuZ3RoKzY1NTM1Pj4+MTYpLFAoKTt2YXIgaT0xO2JyZWFrIHR9Y2F0Y2godCl7fWk9dm9pZCAwfWlmKGkpcmV0dXJuITB9cmV0dXJuITF9LHZhOmZ1bmN0aW9uKHQsZSl7dmFyIG49MDtyZXR1cm4gdXQoKS5mb3JFYWNoKChmdW5jdGlvbihyLGEpe3ZhciBpPWUrbjtmb3IoYT1NW3QrNCphPj4yPj4+MF09aSxpPTA7aTxyLmxlbmd0aDsrK2kpU1thKys+PjA+Pj4wXT1yLmNoYXJDb2RlQXQoaSk7U1thPj4wPj4+MF09MCxuKz1yLmxlbmd0aCsxfSkpLDB9LHdhOmZ1bmN0aW9uKHQsZSl7dmFyIG49dXQoKTtNW3Q+PjI+Pj4wXT1uLmxlbmd0aDt2YXIgcj0wO3JldHVybiBuLmZvckVhY2goKGZ1bmN0aW9uKHQpe3IrPXQubGVuZ3RoKzF9KSksTVtlPj4yPj4+MF09ciwwfSxiYTpmdW5jdGlvbih0KXt3fHwwPHp8fCh3dCgpLFooVyksX3QoMCksY3RbMV0ubGVuZ3RoJiZsdCgxLDEwKSxjdFsyXS5sZW5ndGgmJmx0KDIsMTApKSx3fHwwPHp8fChlLm9uRXhpdCYmZS5vbkV4aXQodCksQz0hMCksaCh0LG5ldyBKKHQpKX0sRTpmdW5jdGlvbigpe3JldHVybiA1Mn0sUTpmdW5jdGlvbigpe3JldHVybiA1Mn0sY2E6ZnVuY3Rpb24oKXtyZXR1cm4gNzB9LFA6ZnVuY3Rpb24odCxlLG4scil7Zm9yKHZhciBhPTAsaT0wO2k8bjtpKyspe3ZhciBvPU1bZT4+Mj4+PjBdLHU9TVtlKzQ+PjI+Pj4wXTtlKz04O2Zvcih2YXIgcz0wO3M8dTtzKyspbHQodCxUW28rcz4+PjBdKTthKz11fXJldHVybiBNW3I+PjI+Pj4wXT1hLDB9LGM6ZnVuY3Rpb24oKXtyZXR1cm4gZnR9LGphOmZ1bmN0aW9uIHQoZSxyKXt0Lk1ifHwodC5NYj1mdW5jdGlvbigpe2lmKFwib2JqZWN0XCI9PXR5cGVvZiBjcnlwdG8mJlwiZnVuY3Rpb25cIj09dHlwZW9mIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMpe3ZhciB0PW5ldyBVaW50OEFycmF5KDEpO3JldHVybigpPT4oY3J5cHRvLmdldFJhbmRvbVZhbHVlcyh0KSx0WzBdKX1pZihiKXRyeXt2YXIgZT1uKDExMyk7cmV0dXJuKCk9PmUucmFuZG9tQnl0ZXMoMSlbMF19Y2F0Y2godCl7fXJldHVybigpPT5WKFwicmFuZG9tRGV2aWNlXCIpfSgpKTtmb3IodmFyIGE9MDthPHI7YSsrKVNbZSthPj4wPj4+MF09dC5NYigpO3JldHVybiAwfSxlYTpmdW5jdGlvbih0LGUsbil7dmFyIHI9QXQoKTt0cnl7cmV0dXJuIGF0KHQpKGUsbil9Y2F0Y2godCl7aWYoU3QociksdCE9PXQrMCl0aHJvdyB0O090KDEsMCl9fSxmYTpmdW5jdGlvbih0LGUsbil7dmFyIHI9QXQoKTt0cnl7cmV0dXJuIGF0KHQpKGUsbil9Y2F0Y2godCl7aWYoU3QociksdCE9PXQrMCl0aHJvdyB0O090KDEsMCl9fSxKOmZ1bmN0aW9uKHQpe3ZhciBlPUF0KCk7dHJ5e3JldHVybiBhdCh0KSgpfWNhdGNoKHQpe2lmKFN0KGUpLHQhPT10KzApdGhyb3cgdDtPdCgxLDApfX0sZTpmdW5jdGlvbih0LGUpe3ZhciBuPUF0KCk7dHJ5e3JldHVybiBhdCh0KShlKX1jYXRjaCh0KXtpZihTdChuKSx0IT09dCswKXRocm93IHQ7T3QoMSwwKX19LE46ZnVuY3Rpb24odCxlLG4pe3ZhciByPUF0KCk7dHJ5e3JldHVybiBhdCh0KShlLG4pfWNhdGNoKHQpe2lmKFN0KHIpLHQhPT10KzApdGhyb3cgdDtPdCgxLDApfX0sTzpmdW5jdGlvbih0LGUsbil7dmFyIHI9QXQoKTt0cnl7cmV0dXJuIGF0KHQpKGUsbil9Y2F0Y2godCl7aWYoU3QociksdCE9PXQrMCl0aHJvdyB0O090KDEsMCl9fSxqOmZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1BdCgpO3RyeXtyZXR1cm4gYXQodCkoZSxuKX1jYXRjaCh0KXtpZihTdChyKSx0IT09dCswKXRocm93IHQ7T3QoMSwwKX19LG86ZnVuY3Rpb24odCxlLG4scil7dmFyIGE9QXQoKTt0cnl7cmV0dXJuIGF0KHQpKGUsbixyKX1jYXRjaCh0KXtpZihTdChhKSx0IT09dCswKXRocm93IHQ7T3QoMSwwKX19LHA6ZnVuY3Rpb24odCxlLG4scixhKXt2YXIgaT1BdCgpO3RyeXtyZXR1cm4gYXQodCkoZSxuLHIsYSl9Y2F0Y2godCl7aWYoU3QoaSksdCE9PXQrMCl0aHJvdyB0O090KDEsMCl9fSxNOmZ1bmN0aW9uKHQsZSxuLHIsYSxpKXt2YXIgbz1BdCgpO3RyeXtyZXR1cm4gYXQodCkoZSxuLHIsYSxpKX1jYXRjaCh0KXtpZihTdChvKSx0IT09dCswKXRocm93IHQ7T3QoMSwwKX19LHI6ZnVuY3Rpb24odCxlLG4scixhLGkpe3ZhciBvPUF0KCk7dHJ5e3JldHVybiBhdCh0KShlLG4scixhLGkpfWNhdGNoKHQpe2lmKFN0KG8pLHQhPT10KzApdGhyb3cgdDtPdCgxLDApfX0sdjpmdW5jdGlvbih0LGUsbixyLGEsaSxvKXt2YXIgdT1BdCgpO3RyeXtyZXR1cm4gYXQodCkoZSxuLHIsYSxpLG8pfWNhdGNoKHQpe2lmKFN0KHUpLHQhPT10KzApdGhyb3cgdDtPdCgxLDApfX0sSzpmdW5jdGlvbih0LGUsbixyLGEsaSxvLHUpe3ZhciBzPUF0KCk7dHJ5e3JldHVybiBhdCh0KShlLG4scixhLGksbyx1KX1jYXRjaCh0KXtpZihTdChzKSx0IT09dCswKXRocm93IHQ7T3QoMSwwKX19LEQ6ZnVuY3Rpb24odCxlLG4scixhLGksbyx1LHMsYyxsLGYpe3ZhciBwPUF0KCk7dHJ5e3JldHVybiBhdCh0KShlLG4scixhLGksbyx1LHMsYyxsLGYpfWNhdGNoKHQpe2lmKFN0KHApLHQhPT10KzApdGhyb3cgdDtPdCgxLDApfX0sWDpmdW5jdGlvbih0LGUsbixyLGEsaSxvLHUpe3ZhciBzPUF0KCk7dHJ5e3JldHVybiBGdCh0LGUsbixyLGEsaSxvLHUpfWNhdGNoKHQpe2lmKFN0KHMpLHQhPT10KzApdGhyb3cgdDtPdCgxLDApfX0sVjpmdW5jdGlvbih0LGUsbixyLGEsaSxvKXt2YXIgdT1BdCgpO3RyeXtyZXR1cm4geHQodCxlLG4scixhLGksbyl9Y2F0Y2godCl7aWYoU3QodSksdCE9PXQrMCl0aHJvdyB0O090KDEsMCl9fSxVOmZ1bmN0aW9uKHQsZSxuLHIsYSl7dmFyIGk9QXQoKTt0cnl7cmV0dXJuIEl0KHQsZSxuLHIsYSl9Y2F0Y2godCl7aWYoU3QoaSksdCE9PXQrMCl0aHJvdyB0O090KDEsMCl9fSxaOmZ1bmN0aW9uKHQsZSxuLHIpe3ZhciBhPUF0KCk7dHJ5e3JldHVybiBQdCh0LGUsbixyKX1jYXRjaCh0KXtpZihTdChhKSx0IT09dCswKXRocm93IHQ7T3QoMSwwKX19LFc6ZnVuY3Rpb24odCl7dmFyIGU9QXQoKTt0cnl7cmV0dXJuIEN0KHQpfWNhdGNoKHQpe2lmKFN0KGUpLHQhPT10KzApdGhyb3cgdDtPdCgxLDApfX0sWTpmdW5jdGlvbih0LGUpe3ZhciBuPUF0KCk7dHJ5e3JldHVybiBVdCh0LGUpfWNhdGNoKHQpe2lmKFN0KG4pLHQhPT10KzApdGhyb3cgdDtPdCgxLDApfX0sVDpmdW5jdGlvbih0LGUsbil7dmFyIHI9QXQoKTt0cnl7cmV0dXJuIFJ0KHQsZSxuKX1jYXRjaCh0KXtpZihTdChyKSx0IT09dCswKXRocm93IHQ7T3QoMSwwKX19LGY6ZnVuY3Rpb24odCl7dmFyIGU9QXQoKTt0cnl7YXQodCkoKX1jYXRjaCh0KXtpZihTdChlKSx0IT09dCswKXRocm93IHQ7T3QoMSwwKX19LHE6ZnVuY3Rpb24odCxlKXt2YXIgbj1BdCgpO3RyeXthdCh0KShlKX1jYXRjaCh0KXtpZihTdChuKSx0IT09dCswKXRocm93IHQ7T3QoMSwwKX19LGg6ZnVuY3Rpb24odCxlLG4pe3ZhciByPUF0KCk7dHJ5e2F0KHQpKGUsbil9Y2F0Y2godCl7aWYoU3QociksdCE9PXQrMCl0aHJvdyB0O090KDEsMCl9fSxkYTpmdW5jdGlvbih0LGUsbixyKXt2YXIgYT1BdCgpO3RyeXthdCh0KShlLG4scil9Y2F0Y2godCl7aWYoU3QoYSksdCE9PXQrMCl0aHJvdyB0O090KDEsMCl9fSxsOmZ1bmN0aW9uKHQsZSxuLHIpe3ZhciBhPUF0KCk7dHJ5e2F0KHQpKGUsbixyKX1jYXRjaCh0KXtpZihTdChhKSx0IT09dCswKXRocm93IHQ7T3QoMSwwKX19LHQ6ZnVuY3Rpb24odCxlLG4scixhKXt2YXIgaT1BdCgpO3RyeXthdCh0KShlLG4scixhKX1jYXRjaCh0KXtpZihTdChpKSx0IT09dCswKXRocm93IHQ7T3QoMSwwKX19LHU6ZnVuY3Rpb24odCxlLG4scixhLGkpe3ZhciBvPUF0KCk7dHJ5e2F0KHQpKGUsbixyLGEsaSl9Y2F0Y2godCl7aWYoU3QobyksdCE9PXQrMCl0aHJvdyB0O090KDEsMCl9fSx4OmZ1bmN0aW9uKHQsZSxuLHIsYSxpLG8pe3ZhciB1PUF0KCk7dHJ5e2F0KHQpKGUsbixyLGEsaSxvKX1jYXRjaCh0KXtpZihTdCh1KSx0IT09dCswKXRocm93IHQ7T3QoMSwwKX19LHo6ZnVuY3Rpb24odCxlLG4scixhLGksbyx1KXt2YXIgcz1BdCgpO3RyeXthdCh0KShlLG4scixhLGksbyx1KX1jYXRjaCh0KXtpZihTdChzKSx0IT09dCswKXRocm93IHQ7T3QoMSwwKX19LGdhOmZ1bmN0aW9uKHQsZSxuLHIsYSxpLG8sdSxzKXt2YXIgYz1BdCgpO3RyeXthdCh0KShlLG4scixhLGksbyx1LHMpfWNhdGNoKHQpe2lmKFN0KGMpLHQhPT10KzApdGhyb3cgdDtPdCgxLDApfX0sQTpmdW5jdGlvbih0LGUsbixyLGEsaSxvLHUscyxjLGwpe3ZhciBmPUF0KCk7dHJ5e2F0KHQpKGUsbixyLGEsaSxvLHUscyxjLGwpfWNhdGNoKHQpe2lmKFN0KGYpLHQhPT10KzApdGhyb3cgdDtPdCgxLDApfX0sQzpmdW5jdGlvbih0LGUsbixyLGEsaSxvLHUscyxjLGwsZixwLGgsZCx5KXt2YXIgYj1BdCgpO3RyeXthdCh0KShlLG4scixhLGksbyx1LHMsYyxsLGYscCxoLGQseSl9Y2F0Y2godCl7aWYoU3QoYiksdCE9PXQrMCl0aHJvdyB0O090KDEsMCl9fSxhYTpmdW5jdGlvbih0LGUsbixyLGEsaSxvLHUpe3ZhciBzPUF0KCk7dHJ5e2t0KHQsZSxuLHIsYSxpLG8sdSl9Y2F0Y2godCl7aWYoU3QocyksdCE9PXQrMCl0aHJvdyB0O090KDEsMCl9fSxfOmZ1bmN0aW9uKHQsZSxuLHIsYSxpLG8sdSxzLGMsbCxmKXt2YXIgcD1BdCgpO3RyeXtEdCh0LGUsbixyLGEsaSxvLHUscyxjLGwsZil9Y2F0Y2godCl7aWYoU3QocCksdCE9PXQrMCl0aHJvdyB0O090KDEsMCl9fSwkOmZ1bmN0aW9uKHQsZSxuLHIsYSxpKXt2YXIgbz1BdCgpO3RyeXtqdCh0LGUsbixyLGEsaSl9Y2F0Y2godCl7aWYoU3QobyksdCE9PXQrMCl0aHJvdyB0O090KDEsMCl9fSxuOmZ1bmN0aW9uKHQpe3JldHVybiB0fSxGOmZ1bmN0aW9uKHQpe2Z0PXR9LGhhOnl0LHk6ZnVuY3Rpb24odCxlLG4scil7cmV0dXJuIHl0KHQsZSxuLHIpfX07IWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0KXtlLmFzbT10LmV4cG9ydHMsTz1lLmFzbS5LYSxQKCksVT1lLmFzbS5pYixJLnVuc2hpZnQoZS5hc20uTGEpLEItLSxlLm1vbml0b3JSdW5EZXBlbmRlbmNpZXMmJmUubW9uaXRvclJ1bkRlcGVuZGVuY2llcyhCKSwwPT1CJiYobnVsbCE9PUcmJihjbGVhckludGVydmFsKEcpLEc9bnVsbCksTiYmKHQ9TixOPW51bGwsdCgpKSl9ZnVuY3Rpb24gbihlKXt0KGUuaW5zdGFuY2UpfWZ1bmN0aW9uIHIodCl7cmV0dXJuIGZ1bmN0aW9uKCl7aWYoIWcmJihkfHx5KSl7aWYoXCJmdW5jdGlvblwiPT10eXBlb2YgZmV0Y2gmJiFZLnN0YXJ0c1dpdGgoXCJmaWxlOi8vXCIpKXJldHVybiBmZXRjaChZLHtjcmVkZW50aWFsczpcInNhbWUtb3JpZ2luXCJ9KS50aGVuKChmdW5jdGlvbih0KXtpZighdC5vayl0aHJvd1wiZmFpbGVkIHRvIGxvYWQgd2FzbSBiaW5hcnkgZmlsZSBhdCBcXCdcIitZK1wiXFwnXCI7cmV0dXJuIHQuYXJyYXlCdWZmZXIoKX0pKS5jYXRjaCgoZnVuY3Rpb24oKXtyZXR1cm4gWCgpfSkpO2lmKG8pcmV0dXJuIG5ldyBQcm9taXNlKChmdW5jdGlvbih0LGUpe28oWSwoZnVuY3Rpb24oZSl7dChuZXcgVWludDhBcnJheShlKSl9KSxlKX0pKX1yZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoZnVuY3Rpb24oKXtyZXR1cm4gWCgpfSkpfSgpLnRoZW4oKGZ1bmN0aW9uKHQpe3JldHVybiBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZSh0LGkpfSkpLnRoZW4oKGZ1bmN0aW9uKHQpe3JldHVybiB0fSkpLnRoZW4odCwoZnVuY3Rpb24odCl7XyhcImZhaWxlZCB0byBhc3luY2hyb25vdXNseSBwcmVwYXJlIHdhc206IFwiK3QpLFYodCl9KSl9dmFyIGk9e2E6YnR9O2lmKEIrKyxlLm1vbml0b3JSdW5EZXBlbmRlbmNpZXMmJmUubW9uaXRvclJ1bkRlcGVuZGVuY2llcyhCKSxlLmluc3RhbnRpYXRlV2FzbSl0cnl7cmV0dXJuIGUuaW5zdGFudGlhdGVXYXNtKGksdCl9Y2F0Y2godCl7cmV0dXJuIF8oXCJNb2R1bGUuaW5zdGFudGlhdGVXYXNtIGNhbGxiYWNrIGZhaWxlZCB3aXRoIGVycm9yOiBcIit0KSwhMX0oZ3x8XCJmdW5jdGlvblwiIT10eXBlb2YgV2ViQXNzZW1ibHkuaW5zdGFudGlhdGVTdHJlYW1pbmd8fHEoKXx8WS5zdGFydHNXaXRoKFwiZmlsZTovL1wiKXx8Ynx8XCJmdW5jdGlvblwiIT10eXBlb2YgZmV0Y2g/cihuKTpmZXRjaChZLHtjcmVkZW50aWFsczpcInNhbWUtb3JpZ2luXCJ9KS50aGVuKChmdW5jdGlvbih0KXtyZXR1cm4gV2ViQXNzZW1ibHkuaW5zdGFudGlhdGVTdHJlYW1pbmcodCxpKS50aGVuKG4sKGZ1bmN0aW9uKHQpe3JldHVybiBfKFwid2FzbSBzdHJlYW1pbmcgY29tcGlsZSBmYWlsZWQ6IFwiK3QpLF8oXCJmYWxsaW5nIGJhY2sgdG8gQXJyYXlCdWZmZXIgaW5zdGFudGlhdGlvblwiKSxyKG4pfSkpfSkpKS5jYXRjaChhKX0oKSxlLl9fX3dhc21fY2FsbF9jdG9ycz1mdW5jdGlvbigpe3JldHVybihlLl9fX3dhc21fY2FsbF9jdG9ycz1lLmFzbS5MYSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxlLl9PcnRJbml0PWZ1bmN0aW9uKCl7cmV0dXJuKGUuX09ydEluaXQ9ZS5hc20uTWEpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sZS5fT3J0Q3JlYXRlU2Vzc2lvbk9wdGlvbnM9ZnVuY3Rpb24oKXtyZXR1cm4oZS5fT3J0Q3JlYXRlU2Vzc2lvbk9wdGlvbnM9ZS5hc20uTmEpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sZS5fT3J0QXBwZW5kRXhlY3V0aW9uUHJvdmlkZXI9ZnVuY3Rpb24oKXtyZXR1cm4oZS5fT3J0QXBwZW5kRXhlY3V0aW9uUHJvdmlkZXI9ZS5hc20uT2EpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sZS5fT3J0QWRkU2Vzc2lvbkNvbmZpZ0VudHJ5PWZ1bmN0aW9uKCl7cmV0dXJuKGUuX09ydEFkZFNlc3Npb25Db25maWdFbnRyeT1lLmFzbS5QYSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxlLl9PcnRSZWxlYXNlU2Vzc2lvbk9wdGlvbnM9ZnVuY3Rpb24oKXtyZXR1cm4oZS5fT3J0UmVsZWFzZVNlc3Npb25PcHRpb25zPWUuYXNtLlFhKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGUuX09ydENyZWF0ZVNlc3Npb249ZnVuY3Rpb24oKXtyZXR1cm4oZS5fT3J0Q3JlYXRlU2Vzc2lvbj1lLmFzbS5SYSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxlLl9PcnRSZWxlYXNlU2Vzc2lvbj1mdW5jdGlvbigpe3JldHVybihlLl9PcnRSZWxlYXNlU2Vzc2lvbj1lLmFzbS5TYSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxlLl9PcnRHZXRJbnB1dENvdW50PWZ1bmN0aW9uKCl7cmV0dXJuKGUuX09ydEdldElucHV0Q291bnQ9ZS5hc20uVGEpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sZS5fT3J0R2V0T3V0cHV0Q291bnQ9ZnVuY3Rpb24oKXtyZXR1cm4oZS5fT3J0R2V0T3V0cHV0Q291bnQ9ZS5hc20uVWEpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sZS5fT3J0R2V0SW5wdXROYW1lPWZ1bmN0aW9uKCl7cmV0dXJuKGUuX09ydEdldElucHV0TmFtZT1lLmFzbS5WYSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxlLl9PcnRHZXRPdXRwdXROYW1lPWZ1bmN0aW9uKCl7cmV0dXJuKGUuX09ydEdldE91dHB1dE5hbWU9ZS5hc20uV2EpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sZS5fT3J0RnJlZT1mdW5jdGlvbigpe3JldHVybihlLl9PcnRGcmVlPWUuYXNtLlhhKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGUuX09ydENyZWF0ZVRlbnNvcj1mdW5jdGlvbigpe3JldHVybihlLl9PcnRDcmVhdGVUZW5zb3I9ZS5hc20uWWEpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sZS5fT3J0R2V0VGVuc29yRGF0YT1mdW5jdGlvbigpe3JldHVybihlLl9PcnRHZXRUZW5zb3JEYXRhPWUuYXNtLlphKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGUuX09ydFJlbGVhc2VUZW5zb3I9ZnVuY3Rpb24oKXtyZXR1cm4oZS5fT3J0UmVsZWFzZVRlbnNvcj1lLmFzbS5fYSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxlLl9PcnRDcmVhdGVSdW5PcHRpb25zPWZ1bmN0aW9uKCl7cmV0dXJuKGUuX09ydENyZWF0ZVJ1bk9wdGlvbnM9ZS5hc20uJGEpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sZS5fT3J0QWRkUnVuQ29uZmlnRW50cnk9ZnVuY3Rpb24oKXtyZXR1cm4oZS5fT3J0QWRkUnVuQ29uZmlnRW50cnk9ZS5hc20uYWIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sZS5fT3J0UmVsZWFzZVJ1bk9wdGlvbnM9ZnVuY3Rpb24oKXtyZXR1cm4oZS5fT3J0UmVsZWFzZVJ1bk9wdGlvbnM9ZS5hc20uYmIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sZS5fT3J0UnVuPWZ1bmN0aW9uKCl7cmV0dXJuKGUuX09ydFJ1bj1lLmFzbS5jYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxlLl9PcnRFbmRQcm9maWxpbmc9ZnVuY3Rpb24oKXtyZXR1cm4oZS5fT3J0RW5kUHJvZmlsaW5nPWUuYXNtLmRiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O3ZhciBtdCxndD1lLl9tYWxsb2M9ZnVuY3Rpb24oKXtyZXR1cm4oZ3Q9ZS5fbWFsbG9jPWUuYXNtLmViKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHZ0PWUuX2ZyZWU9ZnVuY3Rpb24oKXtyZXR1cm4odnQ9ZS5fZnJlZT1lLmFzbS5mYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxfdD1lLl9mZmx1c2g9ZnVuY3Rpb24oKXtyZXR1cm4oX3Q9ZS5fZmZsdXNoPWUuYXNtLmdiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHd0PWUuX19fZnVuY3Nfb25fZXhpdD1mdW5jdGlvbigpe3JldHVybih3dD1lLl9fX2Z1bmNzX29uX2V4aXQ9ZS5hc20uaGIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sT3Q9ZS5fc2V0VGhyZXc9ZnVuY3Rpb24oKXtyZXR1cm4oT3Q9ZS5fc2V0VGhyZXc9ZS5hc20uamIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sQXQ9ZS5zdGFja1NhdmU9ZnVuY3Rpb24oKXtyZXR1cm4oQXQ9ZS5zdGFja1NhdmU9ZS5hc20ua2IpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sU3Q9ZS5zdGFja1Jlc3RvcmU9ZnVuY3Rpb24oKXtyZXR1cm4oU3Q9ZS5zdGFja1Jlc3RvcmU9ZS5hc20ubGIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sVHQ9ZS5zdGFja0FsbG9jPWZ1bmN0aW9uKCl7cmV0dXJuKFR0PWUuc3RhY2tBbGxvYz1lLmFzbS5tYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxFdD1lLl9fX2N4YV9jYW5fY2F0Y2g9ZnVuY3Rpb24oKXtyZXR1cm4oRXQ9ZS5fX19jeGFfY2FuX2NhdGNoPWUuYXNtLm5iKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LE10PWUuX19fY3hhX2lzX3BvaW50ZXJfdHlwZT1mdW5jdGlvbigpe3JldHVybihNdD1lLl9fX2N4YV9pc19wb2ludGVyX3R5cGU9ZS5hc20ub2IpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sQ3Q9ZS5keW5DYWxsX2o9ZnVuY3Rpb24oKXtyZXR1cm4oQ3Q9ZS5keW5DYWxsX2o9ZS5hc20ucGIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0seHQ9ZS5keW5DYWxsX2lpaWlpaj1mdW5jdGlvbigpe3JldHVybih4dD1lLmR5bkNhbGxfaWlpaWlqPWUuYXNtLnFiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LFJ0PWUuZHluQ2FsbF9qaWk9ZnVuY3Rpb24oKXtyZXR1cm4oUnQ9ZS5keW5DYWxsX2ppaT1lLmFzbS5yYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxrdD1lLmR5bkNhbGxfdmlpaWlpaj1mdW5jdGlvbigpe3JldHVybihrdD1lLmR5bkNhbGxfdmlpaWlpaj1lLmFzbS5zYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxqdD1lLmR5bkNhbGxfdmpqaT1mdW5jdGlvbigpe3JldHVybihqdD1lLmR5bkNhbGxfdmpqaT1lLmFzbS50YikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxEdD1lLmR5bkNhbGxfdmlpaWpqamlpPWZ1bmN0aW9uKCl7cmV0dXJuKER0PWUuZHluQ2FsbF92aWlpampqaWk9ZS5hc20udWIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sUHQ9ZS5keW5DYWxsX2lpaj1mdW5jdGlvbigpe3JldHVybihQdD1lLmR5bkNhbGxfaWlqPWUuYXNtLnZiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LFV0PWUuZHluQ2FsbF9qaT1mdW5jdGlvbigpe3JldHVybihVdD1lLmR5bkNhbGxfamk9ZS5hc20ud2IpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sRnQ9ZS5keW5DYWxsX2lpaWlpaWo9ZnVuY3Rpb24oKXtyZXR1cm4oRnQ9ZS5keW5DYWxsX2lpaWlpaWo9ZS5hc20ueGIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sSXQ9ZS5keW5DYWxsX2lpaWo9ZnVuY3Rpb24oKXtyZXR1cm4oSXQ9ZS5keW5DYWxsX2lpaWo9ZS5hc20ueWIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX07ZnVuY3Rpb24gV3QoKXtmdW5jdGlvbiB0KCl7aWYoIW10JiYobXQ9ITAsZS5jYWxsZWRSdW49ITAsIUMpKXtpZihaKEkpLHIoZSksZS5vblJ1bnRpbWVJbml0aWFsaXplZCYmZS5vblJ1bnRpbWVJbml0aWFsaXplZCgpLGUucG9zdFJ1bilmb3IoXCJmdW5jdGlvblwiPT10eXBlb2YgZS5wb3N0UnVuJiYoZS5wb3N0UnVuPVtlLnBvc3RSdW5dKTtlLnBvc3RSdW4ubGVuZ3RoOyl7dmFyIHQ9ZS5wb3N0UnVuLnNoaWZ0KCk7SC51bnNoaWZ0KHQpfVooSCl9fWlmKCEoMDxCKSl7aWYoZS5wcmVSdW4pZm9yKFwiZnVuY3Rpb25cIj09dHlwZW9mIGUucHJlUnVuJiYoZS5wcmVSdW49W2UucHJlUnVuXSk7ZS5wcmVSdW4ubGVuZ3RoOylMKCk7WihGKSwwPEJ8fChlLnNldFN0YXR1cz8oZS5zZXRTdGF0dXMoXCJSdW5uaW5nLi4uXCIpLHNldFRpbWVvdXQoKGZ1bmN0aW9uKCl7c2V0VGltZW91dCgoZnVuY3Rpb24oKXtlLnNldFN0YXR1cyhcIlwiKX0pLDEpLHQoKX0pLDEpKTp0KCkpfX1pZihlLlVURjhUb1N0cmluZz1rLGUuc3RyaW5nVG9VVEY4PWZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gaih0LFQsZSxuKX0sZS5sZW5ndGhCeXRlc1VURjg9RCxlLnN0YWNrU2F2ZT1BdCxlLnN0YWNrUmVzdG9yZT1TdCxlLnN0YWNrQWxsb2M9VHQsTj1mdW5jdGlvbiB0KCl7bXR8fFd0KCksbXR8fChOPXQpfSxlLnByZUluaXQpZm9yKFwiZnVuY3Rpb25cIj09dHlwZW9mIGUucHJlSW5pdCYmKGUucHJlSW5pdD1bZS5wcmVJbml0XSk7MDxlLnByZUluaXQubGVuZ3RoOyllLnByZUluaXQucG9wKCkoKTtyZXR1cm4gV3QoKSx0LnJlYWR5fSk7dC5leHBvcnRzPXJ9LDk2NzoodCxlKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUuaXRlcmF0ZUV4dHJhT3B0aW9ucz12b2lkIDAsZS5pdGVyYXRlRXh0cmFPcHRpb25zPSh0LG4scixhKT0+e2lmKFwib2JqZWN0XCI9PXR5cGVvZiB0JiZudWxsIT09dCl7aWYoci5oYXModCkpdGhyb3cgbmV3IEVycm9yKFwiQ2lyY3VsYXIgcmVmZXJlbmNlIGluIG9wdGlvbnNcIik7ci5hZGQodCl9T2JqZWN0LmVudHJpZXModCkuZm9yRWFjaCgoKFt0LGldKT0+e2NvbnN0IG89bj9uK3Q6dDtpZihcIm9iamVjdFwiPT10eXBlb2YgaSkoMCxlLml0ZXJhdGVFeHRyYU9wdGlvbnMpKGksbytcIi5cIixyLGEpO2Vsc2UgaWYoXCJzdHJpbmdcIj09dHlwZW9mIGl8fFwibnVtYmVyXCI9PXR5cGVvZiBpKWEobyxpLnRvU3RyaW5nKCkpO2Vsc2V7aWYoXCJib29sZWFuXCIhPXR5cGVvZiBpKXRocm93IG5ldyBFcnJvcihcIkNhblxcJ3QgaGFuZGxlIGV4dHJhIGNvbmZpZyB0eXBlOiBcIit0eXBlb2YgaSk7YShvLGk/XCIxXCI6XCIwXCIpfX0pKX19LDU4NjoodCxlLG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5zZXRSdW5PcHRpb25zPXZvaWQgMDtjb25zdCByPW4oOTY3KSxhPW4oOTgzKSxpPW4oMzYxKTtlLnNldFJ1bk9wdGlvbnM9dD0+e2NvbnN0IGU9KDAsaS5nZXRJbnN0YW5jZSkoKTtsZXQgbj0wO2NvbnN0IG89W10sdT10fHx7fTt0cnl7aWYodm9pZCAwPT09KG51bGw9PXQ/dm9pZCAwOnQubG9nU2V2ZXJpdHlMZXZlbCkpdS5sb2dTZXZlcml0eUxldmVsPTI7ZWxzZSBpZihcIm51bWJlclwiIT10eXBlb2YgdC5sb2dTZXZlcml0eUxldmVsfHwhTnVtYmVyLmlzSW50ZWdlcih0LmxvZ1NldmVyaXR5TGV2ZWwpfHx0LmxvZ1NldmVyaXR5TGV2ZWw8MHx8dC5sb2dTZXZlcml0eUxldmVsPjQpdGhyb3cgbmV3IEVycm9yKGBsb2cgc2VydmVyaXR5IGxldmVsIGlzIG5vdCB2YWxpZDogJHt0LmxvZ1NldmVyaXR5TGV2ZWx9YCk7aWYodm9pZCAwPT09KG51bGw9PXQ/dm9pZCAwOnQubG9nVmVyYm9zaXR5TGV2ZWwpKXUubG9nVmVyYm9zaXR5TGV2ZWw9MDtlbHNlIGlmKFwibnVtYmVyXCIhPXR5cGVvZiB0LmxvZ1ZlcmJvc2l0eUxldmVsfHwhTnVtYmVyLmlzSW50ZWdlcih0LmxvZ1ZlcmJvc2l0eUxldmVsKSl0aHJvdyBuZXcgRXJyb3IoYGxvZyB2ZXJib3NpdHkgbGV2ZWwgaXMgbm90IHZhbGlkOiAke3QubG9nVmVyYm9zaXR5TGV2ZWx9YCk7dm9pZCAwPT09KG51bGw9PXQ/dm9pZCAwOnQudGVybWluYXRlKSYmKHUudGVybWluYXRlPSExKTtsZXQgaT0wO2lmKHZvaWQgMCE9PShudWxsPT10P3ZvaWQgMDp0LnRhZykmJihpPSgwLGEuYWxsb2NXYXNtU3RyaW5nKSh0LnRhZyxvKSksbj1lLl9PcnRDcmVhdGVSdW5PcHRpb25zKHUubG9nU2V2ZXJpdHlMZXZlbCx1LmxvZ1ZlcmJvc2l0eUxldmVsLCEhdS50ZXJtaW5hdGUsaSksMD09PW4pdGhyb3cgbmV3IEVycm9yKFwiQ2FuXFwndCBjcmVhdGUgcnVuIG9wdGlvbnNcIik7cmV0dXJuIHZvaWQgMCE9PShudWxsPT10P3ZvaWQgMDp0LmV4dHJhKSYmKDAsci5pdGVyYXRlRXh0cmFPcHRpb25zKSh0LmV4dHJhLFwiXCIsbmV3IFdlYWtTZXQsKCh0LHIpPT57Y29uc3QgaT0oMCxhLmFsbG9jV2FzbVN0cmluZykodCxvKSx1PSgwLGEuYWxsb2NXYXNtU3RyaW5nKShyLG8pO2lmKDAhPT1lLl9PcnRBZGRSdW5Db25maWdFbnRyeShuLGksdSkpdGhyb3cgbmV3IEVycm9yKGBDYW5cXCd0IHNldCBhIHJ1biBjb25maWcgZW50cnk6ICR7dH0gLSAke3J9YCl9KSksW24sb119Y2F0Y2godCl7dGhyb3cgMCE9PW4mJmUuX09ydFJlbGVhc2VSdW5PcHRpb25zKG4pLG8uZm9yRWFjaChlLl9mcmVlKSx0fX19LDkxOToodCxlLG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5zZXRTZXNzaW9uT3B0aW9ucz12b2lkIDA7Y29uc3Qgcj1uKDk2NyksYT1uKDk4MyksaT1uKDM2MSk7ZS5zZXRTZXNzaW9uT3B0aW9ucz10PT57Y29uc3QgZT0oMCxpLmdldEluc3RhbmNlKSgpO2xldCBuPTA7Y29uc3Qgbz1bXSx1PXR8fHt9Oyh0PT57dC5leHRyYXx8KHQuZXh0cmE9e30pLHQuZXh0cmEuc2Vzc2lvbnx8KHQuZXh0cmEuc2Vzc2lvbj17fSk7Y29uc3QgZT10LmV4dHJhLnNlc3Npb247ZS51c2Vfb3J0X21vZGVsX2J5dGVzX2RpcmVjdGx5fHwoZS51c2Vfb3J0X21vZGVsX2J5dGVzX2RpcmVjdGx5PVwiMVwiKX0pKHUpO3RyeXt2b2lkIDA9PT0obnVsbD09dD92b2lkIDA6dC5ncmFwaE9wdGltaXphdGlvbkxldmVsKSYmKHUuZ3JhcGhPcHRpbWl6YXRpb25MZXZlbD1cImFsbFwiKTtjb25zdCBzPSh0PT57c3dpdGNoKHQpe2Nhc2VcImRpc2FibGVkXCI6cmV0dXJuIDA7Y2FzZVwiYmFzaWNcIjpyZXR1cm4gMTtjYXNlXCJleHRlbmRlZFwiOnJldHVybiAyO2Nhc2VcImFsbFwiOnJldHVybiA5OTtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgZ3JhcGggb3B0aW1pemF0aW9uIGxldmVsOiAke3R9YCl9fSkodS5ncmFwaE9wdGltaXphdGlvbkxldmVsKTt2b2lkIDA9PT0obnVsbD09dD92b2lkIDA6dC5lbmFibGVDcHVNZW1BcmVuYSkmJih1LmVuYWJsZUNwdU1lbUFyZW5hPSEwKSx2b2lkIDA9PT0obnVsbD09dD92b2lkIDA6dC5lbmFibGVNZW1QYXR0ZXJuKSYmKHUuZW5hYmxlTWVtUGF0dGVybj0hMCksdm9pZCAwPT09KG51bGw9PXQ/dm9pZCAwOnQuZXhlY3V0aW9uTW9kZSkmJih1LmV4ZWN1dGlvbk1vZGU9XCJzZXF1ZW50aWFsXCIpO2NvbnN0IGM9KHQ9Pntzd2l0Y2godCl7Y2FzZVwic2VxdWVudGlhbFwiOnJldHVybiAwO2Nhc2VcInBhcmFsbGVsXCI6cmV0dXJuIDE7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIGV4ZWN1dGlvbiBtb2RlOiAke3R9YCl9fSkodS5leGVjdXRpb25Nb2RlKTtsZXQgbD0wO2lmKHZvaWQgMCE9PShudWxsPT10P3ZvaWQgMDp0LmxvZ0lkKSYmKGw9KDAsYS5hbGxvY1dhc21TdHJpbmcpKHQubG9nSWQsbykpLHZvaWQgMD09PShudWxsPT10P3ZvaWQgMDp0LmxvZ1NldmVyaXR5TGV2ZWwpKXUubG9nU2V2ZXJpdHlMZXZlbD0yO2Vsc2UgaWYoXCJudW1iZXJcIiE9dHlwZW9mIHQubG9nU2V2ZXJpdHlMZXZlbHx8IU51bWJlci5pc0ludGVnZXIodC5sb2dTZXZlcml0eUxldmVsKXx8dC5sb2dTZXZlcml0eUxldmVsPDB8fHQubG9nU2V2ZXJpdHlMZXZlbD40KXRocm93IG5ldyBFcnJvcihgbG9nIHNlcnZlcml0eSBsZXZlbCBpcyBub3QgdmFsaWQ6ICR7dC5sb2dTZXZlcml0eUxldmVsfWApO2lmKHZvaWQgMD09PShudWxsPT10P3ZvaWQgMDp0LmxvZ1ZlcmJvc2l0eUxldmVsKSl1LmxvZ1ZlcmJvc2l0eUxldmVsPTA7ZWxzZSBpZihcIm51bWJlclwiIT10eXBlb2YgdC5sb2dWZXJib3NpdHlMZXZlbHx8IU51bWJlci5pc0ludGVnZXIodC5sb2dWZXJib3NpdHlMZXZlbCkpdGhyb3cgbmV3IEVycm9yKGBsb2cgdmVyYm9zaXR5IGxldmVsIGlzIG5vdCB2YWxpZDogJHt0LmxvZ1ZlcmJvc2l0eUxldmVsfWApO2lmKHZvaWQgMD09PShudWxsPT10P3ZvaWQgMDp0LmVuYWJsZVByb2ZpbGluZykmJih1LmVuYWJsZVByb2ZpbGluZz0hMSksbj1lLl9PcnRDcmVhdGVTZXNzaW9uT3B0aW9ucyhzLCEhdS5lbmFibGVDcHVNZW1BcmVuYSwhIXUuZW5hYmxlTWVtUGF0dGVybixjLCEhdS5lbmFibGVQcm9maWxpbmcsMCxsLHUubG9nU2V2ZXJpdHlMZXZlbCx1LmxvZ1ZlcmJvc2l0eUxldmVsKSwwPT09bil0aHJvdyBuZXcgRXJyb3IoXCJDYW5cXCd0IGNyZWF0ZSBzZXNzaW9uIG9wdGlvbnNcIik7cmV0dXJuKG51bGw9PXQ/dm9pZCAwOnQuZXhlY3V0aW9uUHJvdmlkZXJzKSYmKCh0LGUsbik9Pntmb3IoY29uc3QgciBvZiBlKXtsZXQgZT1cInN0cmluZ1wiPT10eXBlb2Ygcj9yOnIubmFtZTtzd2l0Y2goZSl7Y2FzZVwieG5ucGFja1wiOmU9XCJYTk5QQUNLXCI7YnJlYWs7Y2FzZVwid2FzbVwiOmNhc2VcImNwdVwiOmNvbnRpbnVlO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBub3Qgc3VwcG9ydGVkIEVQOiAke2V9YCl9Y29uc3Qgbz0oMCxhLmFsbG9jV2FzbVN0cmluZykoZSxuKTtpZigwIT09KDAsaS5nZXRJbnN0YW5jZSkoKS5fT3J0QXBwZW5kRXhlY3V0aW9uUHJvdmlkZXIodCxvKSl0aHJvdyBuZXcgRXJyb3IoYENhblxcJ3QgYXBwZW5kIGV4ZWN1dGlvbiBwcm92aWRlcjogJHtlfWApfX0pKG4sdC5leGVjdXRpb25Qcm92aWRlcnMsbyksdm9pZCAwIT09KG51bGw9PXQ/dm9pZCAwOnQuZXh0cmEpJiYoMCxyLml0ZXJhdGVFeHRyYU9wdGlvbnMpKHQuZXh0cmEsXCJcIixuZXcgV2Vha1NldCwoKHQscik9Pntjb25zdCBpPSgwLGEuYWxsb2NXYXNtU3RyaW5nKSh0LG8pLHU9KDAsYS5hbGxvY1dhc21TdHJpbmcpKHIsbyk7aWYoMCE9PWUuX09ydEFkZFNlc3Npb25Db25maWdFbnRyeShuLGksdSkpdGhyb3cgbmV3IEVycm9yKGBDYW5cXCd0IHNldCBhIHNlc3Npb24gY29uZmlnIGVudHJ5OiAke3R9IC0gJHtyfWApfSkpLFtuLG9dfWNhdGNoKHQpe3Rocm93IDAhPT1uJiZlLl9PcnRSZWxlYXNlU2Vzc2lvbk9wdGlvbnMobiksby5mb3JFYWNoKGUuX2ZyZWUpLHR9fX0sOTgzOih0LGUsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLmFsbG9jV2FzbVN0cmluZz12b2lkIDA7Y29uc3Qgcj1uKDM2MSk7ZS5hbGxvY1dhc21TdHJpbmc9KHQsZSk9Pntjb25zdCBuPSgwLHIuZ2V0SW5zdGFuY2UpKCksYT1uLmxlbmd0aEJ5dGVzVVRGOCh0KSsxLGk9bi5fbWFsbG9jKGEpO3JldHVybiBuLnN0cmluZ1RvVVRGOCh0LGksYSksZS5wdXNoKGkpLGl9fSwzNDk6KHQsZSxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUuZXh0cmFjdFRyYW5zZmVyYWJsZUJ1ZmZlcnM9ZS5lbmRQcm9maWxpbmc9ZS5ydW49ZS5yZWxlYXNlU2Vzc2lvbj1lLmNyZWF0ZVNlc3Npb249ZS5jcmVhdGVTZXNzaW9uRmluYWxpemU9ZS5jcmVhdGVTZXNzaW9uQWxsb2NhdGU9ZS5pbml0T3J0PXZvaWQgMDtjb25zdCByPW4oNTg2KSxhPW4oOTE5KSxpPW4oOTgzKSxvPW4oMzYxKTtlLmluaXRPcnQ9KHQsZSk9Pntjb25zdCBuPSgwLG8uZ2V0SW5zdGFuY2UpKCkuX09ydEluaXQodCxlKTtpZigwIT09bil0aHJvdyBuZXcgRXJyb3IoYENhblxcJ3QgaW5pdGlhbGl6ZSBvbm54cnVudGltZS4gZXJyb3IgY29kZSA9ICR7bn1gKX07Y29uc3QgdT1uZXcgTWFwO2UuY3JlYXRlU2Vzc2lvbkFsbG9jYXRlPXQ9Pntjb25zdCBlPSgwLG8uZ2V0SW5zdGFuY2UpKCksbj1lLl9tYWxsb2ModC5ieXRlTGVuZ3RoKTtyZXR1cm4gZS5IRUFQVTguc2V0KHQsbiksW24sdC5ieXRlTGVuZ3RoXX0sZS5jcmVhdGVTZXNzaW9uRmluYWxpemU9KHQsZSk9Pntjb25zdCBuPSgwLG8uZ2V0SW5zdGFuY2UpKCk7bGV0IHI9MCxpPTAscz1bXTt0cnl7aWYoW2ksc109KDAsYS5zZXRTZXNzaW9uT3B0aW9ucykoZSkscj1uLl9PcnRDcmVhdGVTZXNzaW9uKHRbMF0sdFsxXSxpKSwwPT09cil0aHJvdyBuZXcgRXJyb3IoXCJDYW5cXCd0IGNyZWF0ZSBhIHNlc3Npb25cIil9ZmluYWxseXtuLl9mcmVlKHRbMF0pLG4uX09ydFJlbGVhc2VTZXNzaW9uT3B0aW9ucyhpKSxzLmZvckVhY2gobi5fZnJlZSl9Y29uc3QgYz1uLl9PcnRHZXRJbnB1dENvdW50KHIpLGw9bi5fT3J0R2V0T3V0cHV0Q291bnQociksZj1bXSxwPVtdLGg9W10sZD1bXTtmb3IobGV0IHQ9MDt0PGM7dCsrKXtjb25zdCBlPW4uX09ydEdldElucHV0TmFtZShyLHQpO2lmKDA9PT1lKXRocm93IG5ldyBFcnJvcihcIkNhblxcJ3QgZ2V0IGFuIGlucHV0IG5hbWVcIik7cC5wdXNoKGUpLGYucHVzaChuLlVURjhUb1N0cmluZyhlKSl9Zm9yKGxldCB0PTA7dDxsO3QrKyl7Y29uc3QgZT1uLl9PcnRHZXRPdXRwdXROYW1lKHIsdCk7aWYoMD09PWUpdGhyb3cgbmV3IEVycm9yKFwiQ2FuXFwndCBnZXQgYW4gb3V0cHV0IG5hbWVcIik7ZC5wdXNoKGUpLGgucHVzaChuLlVURjhUb1N0cmluZyhlKSl9cmV0dXJuIHUuc2V0KHIsW3IscCxkXSksW3IsZixoXX0sZS5jcmVhdGVTZXNzaW9uPSh0LG4pPT57Y29uc3Qgcj0oMCxlLmNyZWF0ZVNlc3Npb25BbGxvY2F0ZSkodCk7cmV0dXJuKDAsZS5jcmVhdGVTZXNzaW9uRmluYWxpemUpKHIsbil9LGUucmVsZWFzZVNlc3Npb249dD0+e2NvbnN0IGU9KDAsby5nZXRJbnN0YW5jZSkoKSxuPXUuZ2V0KHQpO2lmKCFuKXRocm93IG5ldyBFcnJvcihcImludmFsaWQgc2Vzc2lvbiBpZFwiKTtjb25zdCByPW5bMF0sYT1uWzFdLGk9blsyXTthLmZvckVhY2goZS5fT3J0RnJlZSksaS5mb3JFYWNoKGUuX09ydEZyZWUpLGUuX09ydFJlbGVhc2VTZXNzaW9uKHIpLHUuZGVsZXRlKHQpfTtjb25zdCBzPXQ9Pntzd2l0Y2godCl7Y2FzZVwiaW50OFwiOnJldHVybiAzO2Nhc2VcInVpbnQ4XCI6cmV0dXJuIDI7Y2FzZVwiYm9vbFwiOnJldHVybiA5O2Nhc2VcImludDE2XCI6cmV0dXJuIDU7Y2FzZVwidWludDE2XCI6cmV0dXJuIDQ7Y2FzZVwiaW50MzJcIjpyZXR1cm4gNjtjYXNlXCJ1aW50MzJcIjpyZXR1cm4gMTI7Y2FzZVwiZmxvYXQzMlwiOnJldHVybiAxO2Nhc2VcImZsb2F0NjRcIjpyZXR1cm4gMTE7Y2FzZVwic3RyaW5nXCI6cmV0dXJuIDg7Y2FzZVwiaW50NjRcIjpyZXR1cm4gNztjYXNlXCJ1aW50NjRcIjpyZXR1cm4gMTM7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIGRhdGEgdHlwZTogJHt0fWApfX0sYz10PT57c3dpdGNoKHQpe2Nhc2UgMzpyZXR1cm5cImludDhcIjtjYXNlIDI6cmV0dXJuXCJ1aW50OFwiO2Nhc2UgOTpyZXR1cm5cImJvb2xcIjtjYXNlIDU6cmV0dXJuXCJpbnQxNlwiO2Nhc2UgNDpyZXR1cm5cInVpbnQxNlwiO2Nhc2UgNjpyZXR1cm5cImludDMyXCI7Y2FzZSAxMjpyZXR1cm5cInVpbnQzMlwiO2Nhc2UgMTpyZXR1cm5cImZsb2F0MzJcIjtjYXNlIDExOnJldHVyblwiZmxvYXQ2NFwiO2Nhc2UgODpyZXR1cm5cInN0cmluZ1wiO2Nhc2UgNzpyZXR1cm5cImludDY0XCI7Y2FzZSAxMzpyZXR1cm5cInVpbnQ2NFwiO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCBkYXRhIHR5cGU6ICR7dH1gKX19LGw9dD0+e3N3aXRjaCh0KXtjYXNlXCJmbG9hdDMyXCI6cmV0dXJuIEZsb2F0MzJBcnJheTtjYXNlXCJ1aW50OFwiOmNhc2VcImJvb2xcIjpyZXR1cm4gVWludDhBcnJheTtjYXNlXCJpbnQ4XCI6cmV0dXJuIEludDhBcnJheTtjYXNlXCJ1aW50MTZcIjpyZXR1cm4gVWludDE2QXJyYXk7Y2FzZVwiaW50MTZcIjpyZXR1cm4gSW50MTZBcnJheTtjYXNlXCJpbnQzMlwiOnJldHVybiBJbnQzMkFycmF5O2Nhc2VcImZsb2F0NjRcIjpyZXR1cm4gRmxvYXQ2NEFycmF5O2Nhc2VcInVpbnQzMlwiOnJldHVybiBVaW50MzJBcnJheTtjYXNlXCJpbnQ2NFwiOnJldHVybiBCaWdJbnQ2NEFycmF5O2Nhc2VcInVpbnQ2NFwiOnJldHVybiBCaWdVaW50NjRBcnJheTtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgdHlwZTogJHt0fWApfX07ZS5ydW49KHQsZSxuLGEsZik9Pntjb25zdCBwPSgwLG8uZ2V0SW5zdGFuY2UpKCksaD11LmdldCh0KTtpZighaCl0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHNlc3Npb24gaWRcIik7Y29uc3QgZD1oWzBdLHk9aFsxXSxiPWhbMl0sbT1lLmxlbmd0aCxnPWEubGVuZ3RoO2xldCB2PTAsXz1bXTtjb25zdCB3PVtdLE89W107dHJ5e1t2LF9dPSgwLHIuc2V0UnVuT3B0aW9ucykoZik7Zm9yKGxldCB0PTA7dDxtO3QrKyl7Y29uc3QgZT1uW3RdWzBdLHI9blt0XVsxXSxhPW5bdF1bMl07bGV0IG8sdTtpZihBcnJheS5pc0FycmF5KGEpKXt1PTQqYS5sZW5ndGgsbz1wLl9tYWxsb2ModSksTy5wdXNoKG8pO2xldCB0PW8vNDtmb3IobGV0IGU9MDtlPGEubGVuZ3RoO2UrKyl7aWYoXCJzdHJpbmdcIiE9dHlwZW9mIGFbZV0pdGhyb3cgbmV3IFR5cGVFcnJvcihgdGVuc29yIGRhdGEgYXQgaW5kZXggJHtlfSBpcyBub3QgYSBzdHJpbmdgKTtwLkhFQVBVMzJbdCsrXT0oMCxpLmFsbG9jV2FzbVN0cmluZykoYVtlXSxPKX19ZWxzZSB1PWEuYnl0ZUxlbmd0aCxvPXAuX21hbGxvYyh1KSxPLnB1c2gobykscC5IRUFQVTguc2V0KG5ldyBVaW50OEFycmF5KGEuYnVmZmVyLGEuYnl0ZU9mZnNldCx1KSxvKTtjb25zdCBjPXAuc3RhY2tTYXZlKCksbD1wLnN0YWNrQWxsb2MoNCpyLmxlbmd0aCk7dHJ5e2xldCB0PWwvNDtyLmZvckVhY2goKGU9PnAuSEVBUDMyW3QrK109ZSkpO2NvbnN0IG49cC5fT3J0Q3JlYXRlVGVuc29yKHMoZSksbyx1LGwsci5sZW5ndGgpO2lmKDA9PT1uKXRocm93IG5ldyBFcnJvcihcIkNhblxcJ3QgY3JlYXRlIGEgdGVuc29yXCIpO3cucHVzaChuKX1maW5hbGx5e3Auc3RhY2tSZXN0b3JlKGMpfX1jb25zdCB0PXAuc3RhY2tTYXZlKCksbz1wLnN0YWNrQWxsb2MoNCptKSx1PXAuc3RhY2tBbGxvYyg0Km0pLGg9cC5zdGFja0FsbG9jKDQqZyksQT1wLnN0YWNrQWxsb2MoNCpnKTt0cnl7bGV0IG49by80LHI9dS80LGk9aC80LHM9QS80O2ZvcihsZXQgdD0wO3Q8bTt0KyspcC5IRUFQVTMyW24rK109d1t0XSxwLkhFQVBVMzJbcisrXT15W2VbdF1dO2ZvcihsZXQgdD0wO3Q8Zzt0KyspcC5IRUFQVTMyW2krK109MCxwLkhFQVBVMzJbcysrXT1iW2FbdF1dO2xldCBmPXAuX09ydFJ1bihkLHUsbyxtLEEsZyxoLHYpO2NvbnN0IF89W107aWYoMD09PWYpZm9yKGxldCB0PTA7dDxnO3QrKyl7Y29uc3QgZT1wLkhFQVBVMzJbaC80K3RdLG49cC5zdGFja1NhdmUoKSxyPXAuc3RhY2tBbGxvYygxNik7bGV0IGEsaT0wO3RyeXtpZihmPXAuX09ydEdldFRlbnNvckRhdGEoZSxyLHIrNCxyKzgscisxMiksMCE9PWYpdGhyb3cgbmV3IEVycm9yKGBDYW5cXCd0IGFjY2VzcyBvdXRwdXQgdGVuc29yIGRhdGEuIGVycm9yIGNvZGUgPSAke2Z9YCk7bGV0IHQ9ci80O2NvbnN0IG89cC5IRUFQVTMyW3QrK107aT1wLkhFQVBVMzJbdCsrXTtjb25zdCB1PXAuSEVBUFUzMlt0KytdLHM9cC5IRUFQVTMyW3QrK10saD1bXTtmb3IobGV0IHQ9MDt0PHM7dCsrKWgucHVzaChwLkhFQVBVMzJbdS80K3RdKTtwLl9PcnRGcmVlKHUpO2NvbnN0IGQ9MD09PWgubGVuZ3RoPzE6aC5yZWR1Y2UoKCh0LGUpPT50KmUpKTtpZihhPWMobyksXCJzdHJpbmdcIj09PWEpe2NvbnN0IHQ9W107bGV0IGU9aS80O2ZvcihsZXQgbj0wO248ZDtuKyspe2NvbnN0IHI9cC5IRUFQVTMyW2UrK10sYT1uPT09ZC0xP3ZvaWQgMDpwLkhFQVBVMzJbZV0tcjt0LnB1c2gocC5VVEY4VG9TdHJpbmcocixhKSl9Xy5wdXNoKFthLGgsdF0pfWVsc2V7Y29uc3QgdD1uZXcobChhKSkoZCk7bmV3IFVpbnQ4QXJyYXkodC5idWZmZXIsdC5ieXRlT2Zmc2V0LHQuYnl0ZUxlbmd0aCkuc2V0KHAuSEVBUFU4LnN1YmFycmF5KGksaSt0LmJ5dGVMZW5ndGgpKSxfLnB1c2goW2EsaCx0XSl9fWZpbmFsbHl7cC5zdGFja1Jlc3RvcmUobiksXCJzdHJpbmdcIj09PWEmJmkmJnAuX2ZyZWUoaSkscC5fT3J0UmVsZWFzZVRlbnNvcihlKX19aWYoMD09PWYpcmV0dXJuIF87dGhyb3cgbmV3IEVycm9yKGBmYWlsZWQgdG8gY2FsbCBPcnRSdW4oKS4gZXJyb3IgY29kZSA9ICR7Zn0uYCl9ZmluYWxseXtwLnN0YWNrUmVzdG9yZSh0KX19ZmluYWxseXt3LmZvckVhY2gocC5fT3J0UmVsZWFzZVRlbnNvciksTy5mb3JFYWNoKHAuX2ZyZWUpLHAuX09ydFJlbGVhc2VSdW5PcHRpb25zKHYpLF8uZm9yRWFjaChwLl9mcmVlKX19LGUuZW5kUHJvZmlsaW5nPXQ9Pntjb25zdCBlPSgwLG8uZ2V0SW5zdGFuY2UpKCksbj11LmdldCh0KTtpZighbil0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHNlc3Npb24gaWRcIik7Y29uc3Qgcj1uWzBdLGE9ZS5fT3J0RW5kUHJvZmlsaW5nKHIpO2lmKDA9PT1hKXRocm93IG5ldyBFcnJvcihcIkNhblxcJ3QgZ2V0IGFuIHByb2ZpbGUgZmlsZSBuYW1lXCIpO2UuX09ydEZyZWUoYSl9LGUuZXh0cmFjdFRyYW5zZmVyYWJsZUJ1ZmZlcnM9dD0+e2NvbnN0IGU9W107Zm9yKGNvbnN0IG4gb2YgdCl7Y29uc3QgdD1uWzJdOyFBcnJheS5pc0FycmF5KHQpJiZ0LmJ1ZmZlciYmZS5wdXNoKHQuYnVmZmVyKX1yZXR1cm4gZX19LDM2MTpmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7dmFyIHI9dGhpcyYmdGhpcy5fX2NyZWF0ZUJpbmRpbmd8fChPYmplY3QuY3JlYXRlP2Z1bmN0aW9uKHQsZSxuLHIpe3ZvaWQgMD09PXImJihyPW4pO3ZhciBhPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSxuKTthJiYhKFwiZ2V0XCJpbiBhPyFlLl9fZXNNb2R1bGU6YS53cml0YWJsZXx8YS5jb25maWd1cmFibGUpfHwoYT17ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gZVtuXX19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCxyLGEpfTpmdW5jdGlvbih0LGUsbixyKXt2b2lkIDA9PT1yJiYocj1uKSx0W3JdPWVbbl19KSxhPXRoaXMmJnRoaXMuX19zZXRNb2R1bGVEZWZhdWx0fHwoT2JqZWN0LmNyZWF0ZT9mdW5jdGlvbih0LGUpe09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiZGVmYXVsdFwiLHtlbnVtZXJhYmxlOiEwLHZhbHVlOmV9KX06ZnVuY3Rpb24odCxlKXt0LmRlZmF1bHQ9ZX0pLGk9dGhpcyYmdGhpcy5fX2ltcG9ydFN0YXJ8fGZ1bmN0aW9uKHQpe2lmKHQmJnQuX19lc01vZHVsZSlyZXR1cm4gdDt2YXIgZT17fTtpZihudWxsIT10KWZvcih2YXIgbiBpbiB0KVwiZGVmYXVsdFwiIT09biYmT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQsbikmJnIoZSx0LG4pO3JldHVybiBhKGUsdCksZX0sbz10aGlzJiZ0aGlzLl9faW1wb3J0RGVmYXVsdHx8ZnVuY3Rpb24odCl7cmV0dXJuIHQmJnQuX19lc01vZHVsZT90OntkZWZhdWx0OnR9fTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLmRpc3Bvc2U9ZS5nZXRJbnN0YW5jZT1lLmluaXRpYWxpemVXZWJBc3NlbWJseT12b2lkIDA7Y29uc3QgdT1pKG4oMTcpKSxzPW8obig5MzIpKSxjPW4oNDc0KTtsZXQgbCxmPSExLHA9ITEsaD0hMTtjb25zdCBkPSh0LGUpPT5lP3Q/XCJvcnQtd2FzbS1zaW1kLXRocmVhZGVkLndhc21cIjpcIm9ydC13YXNtLXRocmVhZGVkLndhc21cIjp0P1wib3J0LXdhc20tc2ltZC53YXNtXCI6XCJvcnQtd2FzbS53YXNtXCI7ZS5pbml0aWFsaXplV2ViQXNzZW1ibHk9YXN5bmMgdD0+e2lmKGYpcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO2lmKHApdGhyb3cgbmV3IEVycm9yKFwibXVsdGlwbGUgY2FsbHMgdG8gXFwnaW5pdGlhbGl6ZVdlYkFzc2VtYmx5KClcXCcgZGV0ZWN0ZWQuXCIpO2lmKGgpdGhyb3cgbmV3IEVycm9yKFwicHJldmlvdXMgY2FsbCB0byBcXCdpbml0aWFsaXplV2ViQXNzZW1ibHkoKVxcJyBmYWlsZWQuXCIpO3A9ITA7Y29uc3QgZT10LmluaXRUaW1lb3V0LHI9dC5udW1UaHJlYWRzLGE9dC5zaW1kLGk9cj4xJiYoKCk9Pnt0cnl7cmV0dXJuXCJ1bmRlZmluZWRcIiE9dHlwZW9mIFNoYXJlZEFycmF5QnVmZmVyJiYoXCJ1bmRlZmluZWRcIiE9dHlwZW9mIE1lc3NhZ2VDaGFubmVsJiYobmV3IE1lc3NhZ2VDaGFubmVsKS5wb3J0MS5wb3N0TWVzc2FnZShuZXcgU2hhcmVkQXJyYXlCdWZmZXIoMSkpLFdlYkFzc2VtYmx5LnZhbGlkYXRlKG5ldyBVaW50OEFycmF5KFswLDk3LDExNSwxMDksMSwwLDAsMCwxLDQsMSw5NiwwLDAsMywyLDEsMCw1LDQsMSwzLDEsMSwxMCwxMSwxLDksMCw2NSwwLDI1NCwxNiwyLDAsMjYsMTFdKSkpfWNhdGNoKHQpe3JldHVybiExfX0pKCksbz1hJiYoKCk9Pnt0cnl7cmV0dXJuIFdlYkFzc2VtYmx5LnZhbGlkYXRlKG5ldyBVaW50OEFycmF5KFswLDk3LDExNSwxMDksMSwwLDAsMCwxLDQsMSw5NiwwLDAsMywyLDEsMCwxMCwzMCwxLDI4LDAsNjUsMCwyNTMsMTUsMjUzLDEyLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMjUzLDE4NiwxLDI2LDExXSkpfWNhdGNoKHQpe3JldHVybiExfX0pKCkseT1cInN0cmluZ1wiPT10eXBlb2YgdC53YXNtUGF0aHM/dC53YXNtUGF0aHM6dm9pZCAwLGI9ZCghMSxpKSxtPWQobyxpKSxnPVwib2JqZWN0XCI9PXR5cGVvZiB0Lndhc21QYXRocz90Lndhc21QYXRoc1ttXTp2b2lkIDA7bGV0IHY9ITE7Y29uc3QgXz1bXTtpZihlPjAmJl8ucHVzaChuZXcgUHJvbWlzZSgodD0+e3NldFRpbWVvdXQoKCgpPT57dj0hMCx0KCl9KSxlKX0pKSksXy5wdXNoKG5ldyBQcm9taXNlKCgodCxlKT0+e2NvbnN0IHI9aT9jOnMuZGVmYXVsdCxhPXtsb2NhdGVGaWxlOih0LGUpPT5pJiZ0LmVuZHNXaXRoKFwiLndvcmtlci5qc1wiKSYmXCJ1bmRlZmluZWRcIiE9dHlwZW9mIEJsb2I/VVJMLmNyZWF0ZU9iamVjdFVSTChuZXcgQmxvYihbbigxNTQpXSx7dHlwZTpcInRleHQvamF2YXNjcmlwdFwifSkpOnQ9PT1iP251bGwhPWc/ZzoobnVsbCE9eT95OmUpK206ZSt0fTtpZihpKWlmKFwidW5kZWZpbmVkXCI9PXR5cGVvZiBCbG9iKWEubWFpblNjcmlwdFVybE9yQmxvYj11LmpvaW4oX19kaXJuYW1lLFwib3J0LXdhc20tdGhyZWFkZWQuanNcIik7ZWxzZXtjb25zdCB0PWB2YXIgb3J0V2FzbVRocmVhZGVkPShmdW5jdGlvbigpe3ZhciBfc2NyaXB0RGlyO3JldHVybiAke3IudG9TdHJpbmcoKX19KSgpO2A7YS5tYWluU2NyaXB0VXJsT3JCbG9iPW5ldyBCbG9iKFt0XSx7dHlwZTpcInRleHQvamF2YXNjcmlwdFwifSl9cihhKS50aGVuKChlPT57cD0hMSxmPSEwLGw9ZSx0KCl9KSwodD0+e3A9ITEsaD0hMCxlKHQpfSkpfSkpKSxhd2FpdCBQcm9taXNlLnJhY2UoXyksdil0aHJvdyBuZXcgRXJyb3IoYFdlYkFzc2VtYmx5IGJhY2tlbmQgaW5pdGlhbGl6aW5nIGZhaWxlZCBkdWUgdG8gdGltZW91dDogJHtlfW1zYCl9LGUuZ2V0SW5zdGFuY2U9KCk9PntpZihmJiZsKXJldHVybiBsO3Rocm93IG5ldyBFcnJvcihcIldlYkFzc2VtYmx5IGlzIG5vdCBpbml0aWFsaXplZCB5ZXQuXCIpfSxlLmRpc3Bvc2U9KCk9Pnt2YXIgdDshZnx8cHx8aHx8KHA9ITAsbnVsbD09PSh0PWwuUFRocmVhZCl8fHZvaWQgMD09PXR8fHQudGVybWluYXRlQWxsVGhyZWFkcygpLGw9dm9pZCAwLHA9ITEsZj0hMSxoPSEwKX19LDE1NDp0PT57XCJ1c2Ugc3RyaWN0XCI7dC5leHBvcnRzPVxcJ1widXNlIHN0cmljdFwiO3ZhciBlPXt9LHQ9XCJvYmplY3RcIj09dHlwZW9mIHByb2Nlc3MmJlwib2JqZWN0XCI9PXR5cGVvZiBwcm9jZXNzLnZlcnNpb25zJiZcInN0cmluZ1wiPT10eXBlb2YgcHJvY2Vzcy52ZXJzaW9ucy5ub2RlO2lmKHQpe3ZhciByPXJlcXVpcmUoXCJ3b3JrZXJfdGhyZWFkc1wiKSxhPXIucGFyZW50UG9ydDthLm9uKFwibWVzc2FnZVwiLChlPT5vbm1lc3NhZ2Uoe2RhdGE6ZX0pKSk7dmFyIG89cmVxdWlyZShcImZzXCIpO09iamVjdC5hc3NpZ24oZ2xvYmFsLHtzZWxmOmdsb2JhbCxyZXF1aXJlOnJlcXVpcmUsTW9kdWxlOmUsbG9jYXRpb246e2hyZWY6X19maWxlbmFtZX0sV29ya2VyOnIuV29ya2VyLGltcG9ydFNjcmlwdHM6ZnVuY3Rpb24oZSl7KDAsZXZhbCkoby5yZWFkRmlsZVN5bmMoZSxcInV0ZjhcIikpfSxwb3N0TWVzc2FnZTpmdW5jdGlvbihlKXthLnBvc3RNZXNzYWdlKGUpfSxwZXJmb3JtYW5jZTpnbG9iYWwucGVyZm9ybWFuY2V8fHtub3c6ZnVuY3Rpb24oKXtyZXR1cm4gRGF0ZS5ub3coKX19fSl9dmFyIHM9ITEsbj1bXSxpPWZ1bmN0aW9uKCl7dmFyIGU9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKS5qb2luKFwiIFwiKTt0P28ud3JpdGVTeW5jKDIsZStcIlxcXFxcXFxcblwiKTpjb25zb2xlLmVycm9yKGUpfTtzZWxmLmFsZXJ0PWZ1bmN0aW9uKCl7dmFyIHQ9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKS5qb2luKFwiIFwiKTtwb3N0TWVzc2FnZSh7Y21kOlwiYWxlcnRcIix0ZXh0OnQsdGhyZWFkSWQ6ZS5fcHRocmVhZF9zZWxmKCl9KX0sZS5pbnN0YW50aWF0ZVdhc209KHQscik9Pnt2YXIgYT1uZXcgV2ViQXNzZW1ibHkuSW5zdGFuY2UoZS53YXNtTW9kdWxlLHQpO3JldHVybiByKGEpLGUud2FzbU1vZHVsZT1udWxsLGEuZXhwb3J0c30sc2VsZi5vbnVuaGFuZGxlZHJlamVjdGlvbj1lPT57dGhyb3cgZS5yZWFzb24/P2V9LHNlbGYub25tZXNzYWdlPXQ9Pnt0cnl7aWYoXCJsb2FkXCI9PT10LmRhdGEuY21kKXtpZihlLndhc21Nb2R1bGU9dC5kYXRhLndhc21Nb2R1bGUsZS53YXNtTWVtb3J5PXQuZGF0YS53YXNtTWVtb3J5LGUuYnVmZmVyPWUud2FzbU1lbW9yeS5idWZmZXIsZS5FTlZJUk9OTUVOVF9JU19QVEhSRUFEPSEwLFwic3RyaW5nXCI9PXR5cGVvZiB0LmRhdGEudXJsT3JCbG9iKWltcG9ydFNjcmlwdHModC5kYXRhLnVybE9yQmxvYik7ZWxzZXt2YXIgcj1VUkwuY3JlYXRlT2JqZWN0VVJMKHQuZGF0YS51cmxPckJsb2IpO2ltcG9ydFNjcmlwdHMociksVVJMLnJldm9rZU9iamVjdFVSTChyKX1vcnRXYXNtVGhyZWFkZWQoZSkudGhlbigoZnVuY3Rpb24odCl7ZT10fSkpfWVsc2UgaWYoXCJydW5cIj09PXQuZGF0YS5jbWQpe2UuX19wZXJmb3JtYW5jZV9ub3dfY2xvY2tfZHJpZnQ9cGVyZm9ybWFuY2Uubm93KCktdC5kYXRhLnRpbWUsZS5fX2Vtc2NyaXB0ZW5fdGhyZWFkX2luaXQodC5kYXRhLnB0aHJlYWRfcHRyLDAsMCwxKSxlLmVzdGFibGlzaFN0YWNrU3BhY2UoKSxlLlBUaHJlYWQucmVjZWl2ZU9iamVjdFRyYW5zZmVyKHQuZGF0YSksZS5QVGhyZWFkLnRocmVhZEluaXRUTFMoKSxzfHwobi5mb3JFYWNoKCh0PT57ZS5leGVjdXRlTm90aWZpZWRQcm94eWluZ1F1ZXVlKHQpfSkpLG49W10scz0hMCk7dHJ5e2UuaW52b2tlRW50cnlQb2ludCh0LmRhdGEuc3RhcnRfcm91dGluZSx0LmRhdGEuYXJnKX1jYXRjaCh0KXtpZihcInVud2luZFwiIT10KXtpZighKHQgaW5zdGFuY2VvZiBlLkV4aXRTdGF0dXMpKXRocm93IHQ7ZS5rZWVwUnVudGltZUFsaXZlKCl8fGUuX19lbXNjcmlwdGVuX3RocmVhZF9leGl0KHQuc3RhdHVzKX19fWVsc2VcImNhbmNlbFwiPT09dC5kYXRhLmNtZD9lLl9wdGhyZWFkX3NlbGYoKSYmZS5fX2Vtc2NyaXB0ZW5fdGhyZWFkX2V4aXQoLTEpOlwic2V0aW1tZWRpYXRlXCI9PT10LmRhdGEudGFyZ2V0fHwoXCJwcm9jZXNzUHJveHlpbmdRdWV1ZVwiPT09dC5kYXRhLmNtZD9zP2UuZXhlY3V0ZU5vdGlmaWVkUHJveHlpbmdRdWV1ZSh0LmRhdGEucXVldWUpOm4ucHVzaCh0LmRhdGEucXVldWUpOihpKFwid29ya2VyLmpzIHJlY2VpdmVkIHVua25vd24gY29tbWFuZCBcIit0LmRhdGEuY21kKSxpKHQuZGF0YSkpKX1jYXRjaCh0KXt0aHJvdyBpKFwid29ya2VyLmpzIG9ubWVzc2FnZSgpIGNhcHR1cmVkIGFuIHVuY2F1Z2h0IGV4Y2VwdGlvbjogXCIrdCksdCYmdC5zdGFjayYmaSh0LnN0YWNrKSxlLl9fZW1zY3JpcHRlbl90aHJlYWRfY3Jhc2hlZCYmZS5fX2Vtc2NyaXB0ZW5fdGhyZWFkX2NyYXNoZWQoKSx0fX07XFxcXG5cXCd9LDExMzp0PT57XCJ1c2Ugc3RyaWN0XCI7dC5leHBvcnRzPXJlcXVpcmUoXCJjcnlwdG9cIil9LDE0Nzp0PT57XCJ1c2Ugc3RyaWN0XCI7dC5leHBvcnRzPXJlcXVpcmUoXCJmc1wiKX0sMzc6dD0+e1widXNlIHN0cmljdFwiO3QuZXhwb3J0cz1yZXF1aXJlKFwib3NcIil9LDE3OnQ9PntcInVzZSBzdHJpY3RcIjt0LmV4cG9ydHM9cmVxdWlyZShcInBhdGhcIil9LDc0OnQ9PntcInVzZSBzdHJpY3RcIjt0LmV4cG9ydHM9cmVxdWlyZShcInBlcmZfaG9va3NcIil9LDI2Nzp0PT57XCJ1c2Ugc3RyaWN0XCI7dC5leHBvcnRzPXJlcXVpcmUoXCJ3b3JrZXJfdGhyZWFkc1wiKX19LGU9e307ZnVuY3Rpb24gbihyKXt2YXIgYT1lW3JdO2lmKHZvaWQgMCE9PWEpcmV0dXJuIGEuZXhwb3J0czt2YXIgaT1lW3JdPXtleHBvcnRzOnt9fTtyZXR1cm4gdFtyXS5jYWxsKGkuZXhwb3J0cyxpLGkuZXhwb3J0cyxuKSxpLmV4cG9ydHN9KCgpPT57XCJ1c2Ugc3RyaWN0XCI7Y29uc3QgdD1uKDM0OSksZT1uKDM2MSk7c2VsZi5vbm1lc3NhZ2U9bj0+e3N3aXRjaChuLmRhdGEudHlwZSl7Y2FzZVwiaW5pdC13YXNtXCI6KDAsZS5pbml0aWFsaXplV2ViQXNzZW1ibHkpKG4uZGF0YS5pbikudGhlbigoKCk9PnBvc3RNZXNzYWdlKHt0eXBlOlwiaW5pdC13YXNtXCJ9KSksKHQ9PnBvc3RNZXNzYWdlKHt0eXBlOlwiaW5pdC13YXNtXCIsZXJyOnR9KSkpO2JyZWFrO2Nhc2VcImluaXQtb3J0XCI6dHJ5e2NvbnN0e251bVRocmVhZHM6ZSxsb2dnaW5nTGV2ZWw6cn09bi5kYXRhLmluOygwLHQuaW5pdE9ydCkoZSxyKSxwb3N0TWVzc2FnZSh7dHlwZTpcImluaXQtb3J0XCJ9KX1jYXRjaCh0KXtwb3N0TWVzc2FnZSh7dHlwZTpcImluaXQtb3J0XCIsZXJyOnR9KX1icmVhaztjYXNlXCJjcmVhdGVfYWxsb2NhdGVcIjp0cnl7Y29uc3R7bW9kZWw6ZX09bi5kYXRhLmluLHI9KDAsdC5jcmVhdGVTZXNzaW9uQWxsb2NhdGUpKGUpO3Bvc3RNZXNzYWdlKHt0eXBlOlwiY3JlYXRlX2FsbG9jYXRlXCIsb3V0OnJ9KX1jYXRjaCh0KXtwb3N0TWVzc2FnZSh7dHlwZTpcImNyZWF0ZV9hbGxvY2F0ZVwiLGVycjp0fSl9YnJlYWs7Y2FzZVwiY3JlYXRlX2ZpbmFsaXplXCI6dHJ5e2NvbnN0e21vZGVsZGF0YTplLG9wdGlvbnM6cn09bi5kYXRhLmluLGE9KDAsdC5jcmVhdGVTZXNzaW9uRmluYWxpemUpKGUscik7cG9zdE1lc3NhZ2Uoe3R5cGU6XCJjcmVhdGVfZmluYWxpemVcIixvdXQ6YX0pfWNhdGNoKHQpe3Bvc3RNZXNzYWdlKHt0eXBlOlwiY3JlYXRlX2ZpbmFsaXplXCIsZXJyOnR9KX1icmVhaztjYXNlXCJjcmVhdGVcIjp0cnl7Y29uc3R7bW9kZWw6ZSxvcHRpb25zOnJ9PW4uZGF0YS5pbixhPSgwLHQuY3JlYXRlU2Vzc2lvbikoZSxyKTtwb3N0TWVzc2FnZSh7dHlwZTpcImNyZWF0ZVwiLG91dDphfSl9Y2F0Y2godCl7cG9zdE1lc3NhZ2Uoe3R5cGU6XCJjcmVhdGVcIixlcnI6dH0pfWJyZWFrO2Nhc2VcInJlbGVhc2VcIjp0cnl7Y29uc3QgZT1uLmRhdGEuaW47KDAsdC5yZWxlYXNlU2Vzc2lvbikoZSkscG9zdE1lc3NhZ2Uoe3R5cGU6XCJyZWxlYXNlXCJ9KX1jYXRjaCh0KXtwb3N0TWVzc2FnZSh7dHlwZTpcInJlbGVhc2VcIixlcnI6dH0pfWJyZWFrO2Nhc2VcInJ1blwiOnRyeXtjb25zdHtzZXNzaW9uSWQ6ZSxpbnB1dEluZGljZXM6cixpbnB1dHM6YSxvdXRwdXRJbmRpY2VzOmksb3B0aW9uczpvfT1uLmRhdGEuaW4sdT0oMCx0LnJ1bikoZSxyLGEsaSxvKTtwb3N0TWVzc2FnZSh7dHlwZTpcInJ1blwiLG91dDp1fSwoMCx0LmV4dHJhY3RUcmFuc2ZlcmFibGVCdWZmZXJzKSh1KSl9Y2F0Y2godCl7cG9zdE1lc3NhZ2Uoe3R5cGU6XCJydW5cIixlcnI6dH0pfWJyZWFrO2Nhc2VcImVuZC1wcm9maWxpbmdcIjp0cnl7Y29uc3QgZT1uLmRhdGEuaW47KDAsdC5lbmRQcm9maWxpbmcpKGUpLHBvc3RNZXNzYWdlKHt0eXBlOlwiZW5kLXByb2ZpbGluZ1wifSl9Y2F0Y2godCl7cG9zdE1lc3NhZ2Uoe3R5cGU6XCJlbmQtcHJvZmlsaW5nXCIsZXJyOnR9KX19fX0pKCl9KSgpO1xcbicsXCJXb3JrZXJcIix2b2lkIDAsdm9pZCAwKX19LDQ3Nzp0PT57XCJ1c2Ugc3RyaWN0XCI7dC5leHBvcnRzPWZ1bmN0aW9uKHQsZSxuLHIpe3ZhciBpPXNlbGZ8fHdpbmRvdzt0cnl7dHJ5e3ZhciBvO3RyeXtvPW5ldyBpLkJsb2IoW3RdKX1jYXRjaChlKXsobz1uZXcoaS5CbG9iQnVpbGRlcnx8aS5XZWJLaXRCbG9iQnVpbGRlcnx8aS5Nb3pCbG9iQnVpbGRlcnx8aS5NU0Jsb2JCdWlsZGVyKSkuYXBwZW5kKHQpLG89by5nZXRCbG9iKCl9dmFyIGE9aS5VUkx8fGkud2Via2l0VVJMLHM9YS5jcmVhdGVPYmplY3RVUkwobyksdT1uZXcgaVtlXShzLG4pO3JldHVybiBhLnJldm9rZU9iamVjdFVSTChzKSx1fWNhdGNoKHIpe3JldHVybiBuZXcgaVtlXShcImRhdGE6YXBwbGljYXRpb24vamF2YXNjcmlwdCxcIi5jb25jYXQoZW5jb2RlVVJJQ29tcG9uZW50KHQpKSxuKX19Y2F0Y2godCl7aWYoIXIpdGhyb3cgRXJyb3IoXCJJbmxpbmUgd29ya2VyIGlzIG5vdCBzdXBwb3J0ZWRcIik7cmV0dXJuIG5ldyBpW2VdKHIsbil9fX0sNDE1NDp0PT57XCJ1c2Ugc3RyaWN0XCI7dC5leHBvcnRzPSdcInVzZSBzdHJpY3RcIjt2YXIgZT17fSx0PVwib2JqZWN0XCI9PXR5cGVvZiBwcm9jZXNzJiZcIm9iamVjdFwiPT10eXBlb2YgcHJvY2Vzcy52ZXJzaW9ucyYmXCJzdHJpbmdcIj09dHlwZW9mIHByb2Nlc3MudmVyc2lvbnMubm9kZTtpZih0KXt2YXIgcj1yZXF1aXJlKFwid29ya2VyX3RocmVhZHNcIiksYT1yLnBhcmVudFBvcnQ7YS5vbihcIm1lc3NhZ2VcIiwoZT0+b25tZXNzYWdlKHtkYXRhOmV9KSkpO3ZhciBvPXJlcXVpcmUoXCJmc1wiKTtPYmplY3QuYXNzaWduKGdsb2JhbCx7c2VsZjpnbG9iYWwscmVxdWlyZTpyZXF1aXJlLE1vZHVsZTplLGxvY2F0aW9uOntocmVmOl9fZmlsZW5hbWV9LFdvcmtlcjpyLldvcmtlcixpbXBvcnRTY3JpcHRzOmZ1bmN0aW9uKGUpeygwLGV2YWwpKG8ucmVhZEZpbGVTeW5jKGUsXCJ1dGY4XCIpKX0scG9zdE1lc3NhZ2U6ZnVuY3Rpb24oZSl7YS5wb3N0TWVzc2FnZShlKX0scGVyZm9ybWFuY2U6Z2xvYmFsLnBlcmZvcm1hbmNlfHx7bm93OmZ1bmN0aW9uKCl7cmV0dXJuIERhdGUubm93KCl9fX0pfXZhciBzPSExLG49W10saT1mdW5jdGlvbigpe3ZhciBlPUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykuam9pbihcIiBcIik7dD9vLndyaXRlU3luYygyLGUrXCJcXFxcblwiKTpjb25zb2xlLmVycm9yKGUpfTtzZWxmLmFsZXJ0PWZ1bmN0aW9uKCl7dmFyIHQ9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKS5qb2luKFwiIFwiKTtwb3N0TWVzc2FnZSh7Y21kOlwiYWxlcnRcIix0ZXh0OnQsdGhyZWFkSWQ6ZS5fcHRocmVhZF9zZWxmKCl9KX0sZS5pbnN0YW50aWF0ZVdhc209KHQscik9Pnt2YXIgYT1uZXcgV2ViQXNzZW1ibHkuSW5zdGFuY2UoZS53YXNtTW9kdWxlLHQpO3JldHVybiByKGEpLGUud2FzbU1vZHVsZT1udWxsLGEuZXhwb3J0c30sc2VsZi5vbnVuaGFuZGxlZHJlamVjdGlvbj1lPT57dGhyb3cgZS5yZWFzb24/P2V9LHNlbGYub25tZXNzYWdlPXQ9Pnt0cnl7aWYoXCJsb2FkXCI9PT10LmRhdGEuY21kKXtpZihlLndhc21Nb2R1bGU9dC5kYXRhLndhc21Nb2R1bGUsZS53YXNtTWVtb3J5PXQuZGF0YS53YXNtTWVtb3J5LGUuYnVmZmVyPWUud2FzbU1lbW9yeS5idWZmZXIsZS5FTlZJUk9OTUVOVF9JU19QVEhSRUFEPSEwLFwic3RyaW5nXCI9PXR5cGVvZiB0LmRhdGEudXJsT3JCbG9iKWltcG9ydFNjcmlwdHModC5kYXRhLnVybE9yQmxvYik7ZWxzZXt2YXIgcj1VUkwuY3JlYXRlT2JqZWN0VVJMKHQuZGF0YS51cmxPckJsb2IpO2ltcG9ydFNjcmlwdHMociksVVJMLnJldm9rZU9iamVjdFVSTChyKX1vcnRXYXNtVGhyZWFkZWQoZSkudGhlbigoZnVuY3Rpb24odCl7ZT10fSkpfWVsc2UgaWYoXCJydW5cIj09PXQuZGF0YS5jbWQpe2UuX19wZXJmb3JtYW5jZV9ub3dfY2xvY2tfZHJpZnQ9cGVyZm9ybWFuY2Uubm93KCktdC5kYXRhLnRpbWUsZS5fX2Vtc2NyaXB0ZW5fdGhyZWFkX2luaXQodC5kYXRhLnB0aHJlYWRfcHRyLDAsMCwxKSxlLmVzdGFibGlzaFN0YWNrU3BhY2UoKSxlLlBUaHJlYWQucmVjZWl2ZU9iamVjdFRyYW5zZmVyKHQuZGF0YSksZS5QVGhyZWFkLnRocmVhZEluaXRUTFMoKSxzfHwobi5mb3JFYWNoKCh0PT57ZS5leGVjdXRlTm90aWZpZWRQcm94eWluZ1F1ZXVlKHQpfSkpLG49W10scz0hMCk7dHJ5e2UuaW52b2tlRW50cnlQb2ludCh0LmRhdGEuc3RhcnRfcm91dGluZSx0LmRhdGEuYXJnKX1jYXRjaCh0KXtpZihcInVud2luZFwiIT10KXtpZighKHQgaW5zdGFuY2VvZiBlLkV4aXRTdGF0dXMpKXRocm93IHQ7ZS5rZWVwUnVudGltZUFsaXZlKCl8fGUuX19lbXNjcmlwdGVuX3RocmVhZF9leGl0KHQuc3RhdHVzKX19fWVsc2VcImNhbmNlbFwiPT09dC5kYXRhLmNtZD9lLl9wdGhyZWFkX3NlbGYoKSYmZS5fX2Vtc2NyaXB0ZW5fdGhyZWFkX2V4aXQoLTEpOlwic2V0aW1tZWRpYXRlXCI9PT10LmRhdGEudGFyZ2V0fHwoXCJwcm9jZXNzUHJveHlpbmdRdWV1ZVwiPT09dC5kYXRhLmNtZD9zP2UuZXhlY3V0ZU5vdGlmaWVkUHJveHlpbmdRdWV1ZSh0LmRhdGEucXVldWUpOm4ucHVzaCh0LmRhdGEucXVldWUpOihpKFwid29ya2VyLmpzIHJlY2VpdmVkIHVua25vd24gY29tbWFuZCBcIit0LmRhdGEuY21kKSxpKHQuZGF0YSkpKX1jYXRjaCh0KXt0aHJvdyBpKFwid29ya2VyLmpzIG9ubWVzc2FnZSgpIGNhcHR1cmVkIGFuIHVuY2F1Z2h0IGV4Y2VwdGlvbjogXCIrdCksdCYmdC5zdGFjayYmaSh0LnN0YWNrKSxlLl9fZW1zY3JpcHRlbl90aHJlYWRfY3Jhc2hlZCYmZS5fX2Vtc2NyaXB0ZW5fdGhyZWFkX2NyYXNoZWQoKSx0fX07XFxuJ30sNjIzMTp0PT57XCJ1c2Ugc3RyaWN0XCI7dC5leHBvcnRzPXJlcXVpcmUoXCJmc1wiKX0sOTcxOTp0PT57XCJ1c2Ugc3RyaWN0XCI7dC5leHBvcnRzPXJlcXVpcmUoXCJvc1wiKX0sMTQyMzp0PT57XCJ1c2Ugc3RyaWN0XCI7dC5leHBvcnRzPXJlcXVpcmUoXCJwYXRoXCIpfSw0OTg6dD0+e1widXNlIHN0cmljdFwiO3QuZXhwb3J0cz1yZXF1aXJlKFwicGVyZl9ob29rc1wiKX0sNjQ2NDp0PT57XCJ1c2Ugc3RyaWN0XCI7dC5leHBvcnRzPXJlcXVpcmUoXCJ1dGlsXCIpfSw0NTY0OnQ9PntcInVzZSBzdHJpY3RcIjt0LmV4cG9ydHM9cmVxdWlyZShcIndvcmtlcl90aHJlYWRzXCIpfSw2MjA3OnQ9PntcInVzZSBzdHJpY3RcIjt0LmV4cG9ydHM9cmVxdWlyZShcIm9ubnhydW50aW1lLWNvbW1vblwiKX0sNjExMzp0PT57XCJ1c2Ugc3RyaWN0XCI7dC5leHBvcnRzPXJlcXVpcmUoXCJjcnlwdG9cIil9LDU2ODY6KHQsZSxuKT0+e1widXNlIHN0cmljdFwiO24ucihlKSxuLmQoZSx7ZmxhdGJ1ZmZlcnM6KCk9PnJ9KTt2YXIgcj17fTtyLk9mZnNldCxyLlRhYmxlLHIuU0laRU9GX1NIT1JUPTIsci5TSVpFT0ZfSU5UPTQsci5GSUxFX0lERU5USUZJRVJfTEVOR1RIPTQsci5TSVpFX1BSRUZJWF9MRU5HVEg9NCxyLkVuY29kaW5nPXtVVEY4X0JZVEVTOjEsVVRGMTZfU1RSSU5HOjJ9LHIuaW50MzI9bmV3IEludDMyQXJyYXkoMiksci5mbG9hdDMyPW5ldyBGbG9hdDMyQXJyYXkoci5pbnQzMi5idWZmZXIpLHIuZmxvYXQ2ND1uZXcgRmxvYXQ2NEFycmF5KHIuaW50MzIuYnVmZmVyKSxyLmlzTGl0dGxlRW5kaWFuPTE9PT1uZXcgVWludDE2QXJyYXkobmV3IFVpbnQ4QXJyYXkoWzEsMF0pLmJ1ZmZlcilbMF0sci5Mb25nPWZ1bmN0aW9uKHQsZSl7dGhpcy5sb3c9MHx0LHRoaXMuaGlnaD0wfGV9LHIuTG9uZy5jcmVhdGU9ZnVuY3Rpb24odCxlKXtyZXR1cm4gMD09dCYmMD09ZT9yLkxvbmcuWkVSTzpuZXcgci5Mb25nKHQsZSl9LHIuTG9uZy5wcm90b3R5cGUudG9GbG9hdDY0PWZ1bmN0aW9uKCl7cmV0dXJuKHRoaXMubG93Pj4+MCkrNDI5NDk2NzI5Nip0aGlzLmhpZ2h9LHIuTG9uZy5wcm90b3R5cGUuZXF1YWxzPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmxvdz09dC5sb3cmJnRoaXMuaGlnaD09dC5oaWdofSxyLkxvbmcuWkVSTz1uZXcgci5Mb25nKDAsMCksci5CdWlsZGVyPWZ1bmN0aW9uKHQpe2lmKHQpZT10O2Vsc2UgdmFyIGU9MTAyNDt0aGlzLmJiPXIuQnl0ZUJ1ZmZlci5hbGxvY2F0ZShlKSx0aGlzLnNwYWNlPWUsdGhpcy5taW5hbGlnbj0xLHRoaXMudnRhYmxlPW51bGwsdGhpcy52dGFibGVfaW5fdXNlPTAsdGhpcy5pc05lc3RlZD0hMSx0aGlzLm9iamVjdF9zdGFydD0wLHRoaXMudnRhYmxlcz1bXSx0aGlzLnZlY3Rvcl9udW1fZWxlbXM9MCx0aGlzLmZvcmNlX2RlZmF1bHRzPSExfSxyLkJ1aWxkZXIucHJvdG90eXBlLmNsZWFyPWZ1bmN0aW9uKCl7dGhpcy5iYi5jbGVhcigpLHRoaXMuc3BhY2U9dGhpcy5iYi5jYXBhY2l0eSgpLHRoaXMubWluYWxpZ249MSx0aGlzLnZ0YWJsZT1udWxsLHRoaXMudnRhYmxlX2luX3VzZT0wLHRoaXMuaXNOZXN0ZWQ9ITEsdGhpcy5vYmplY3Rfc3RhcnQ9MCx0aGlzLnZ0YWJsZXM9W10sdGhpcy52ZWN0b3JfbnVtX2VsZW1zPTAsdGhpcy5mb3JjZV9kZWZhdWx0cz0hMX0sci5CdWlsZGVyLnByb3RvdHlwZS5mb3JjZURlZmF1bHRzPWZ1bmN0aW9uKHQpe3RoaXMuZm9yY2VfZGVmYXVsdHM9dH0sci5CdWlsZGVyLnByb3RvdHlwZS5kYXRhQnVmZmVyPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuYmJ9LHIuQnVpbGRlci5wcm90b3R5cGUuYXNVaW50OEFycmF5PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuYmIuYnl0ZXMoKS5zdWJhcnJheSh0aGlzLmJiLnBvc2l0aW9uKCksdGhpcy5iYi5wb3NpdGlvbigpK3RoaXMub2Zmc2V0KCkpfSxyLkJ1aWxkZXIucHJvdG90eXBlLnByZXA9ZnVuY3Rpb24odCxlKXt0PnRoaXMubWluYWxpZ24mJih0aGlzLm1pbmFsaWduPXQpO2Zvcih2YXIgbj0xK34odGhpcy5iYi5jYXBhY2l0eSgpLXRoaXMuc3BhY2UrZSkmdC0xO3RoaXMuc3BhY2U8bit0K2U7KXt2YXIgaT10aGlzLmJiLmNhcGFjaXR5KCk7dGhpcy5iYj1yLkJ1aWxkZXIuZ3Jvd0J5dGVCdWZmZXIodGhpcy5iYiksdGhpcy5zcGFjZSs9dGhpcy5iYi5jYXBhY2l0eSgpLWl9dGhpcy5wYWQobil9LHIuQnVpbGRlci5wcm90b3R5cGUucGFkPWZ1bmN0aW9uKHQpe2Zvcih2YXIgZT0wO2U8dDtlKyspdGhpcy5iYi53cml0ZUludDgoLS10aGlzLnNwYWNlLDApfSxyLkJ1aWxkZXIucHJvdG90eXBlLndyaXRlSW50OD1mdW5jdGlvbih0KXt0aGlzLmJiLndyaXRlSW50OCh0aGlzLnNwYWNlLT0xLHQpfSxyLkJ1aWxkZXIucHJvdG90eXBlLndyaXRlSW50MTY9ZnVuY3Rpb24odCl7dGhpcy5iYi53cml0ZUludDE2KHRoaXMuc3BhY2UtPTIsdCl9LHIuQnVpbGRlci5wcm90b3R5cGUud3JpdGVJbnQzMj1mdW5jdGlvbih0KXt0aGlzLmJiLndyaXRlSW50MzIodGhpcy5zcGFjZS09NCx0KX0sci5CdWlsZGVyLnByb3RvdHlwZS53cml0ZUludDY0PWZ1bmN0aW9uKHQpe3RoaXMuYmIud3JpdGVJbnQ2NCh0aGlzLnNwYWNlLT04LHQpfSxyLkJ1aWxkZXIucHJvdG90eXBlLndyaXRlRmxvYXQzMj1mdW5jdGlvbih0KXt0aGlzLmJiLndyaXRlRmxvYXQzMih0aGlzLnNwYWNlLT00LHQpfSxyLkJ1aWxkZXIucHJvdG90eXBlLndyaXRlRmxvYXQ2ND1mdW5jdGlvbih0KXt0aGlzLmJiLndyaXRlRmxvYXQ2NCh0aGlzLnNwYWNlLT04LHQpfSxyLkJ1aWxkZXIucHJvdG90eXBlLmFkZEludDg9ZnVuY3Rpb24odCl7dGhpcy5wcmVwKDEsMCksdGhpcy53cml0ZUludDgodCl9LHIuQnVpbGRlci5wcm90b3R5cGUuYWRkSW50MTY9ZnVuY3Rpb24odCl7dGhpcy5wcmVwKDIsMCksdGhpcy53cml0ZUludDE2KHQpfSxyLkJ1aWxkZXIucHJvdG90eXBlLmFkZEludDMyPWZ1bmN0aW9uKHQpe3RoaXMucHJlcCg0LDApLHRoaXMud3JpdGVJbnQzMih0KX0sci5CdWlsZGVyLnByb3RvdHlwZS5hZGRJbnQ2ND1mdW5jdGlvbih0KXt0aGlzLnByZXAoOCwwKSx0aGlzLndyaXRlSW50NjQodCl9LHIuQnVpbGRlci5wcm90b3R5cGUuYWRkRmxvYXQzMj1mdW5jdGlvbih0KXt0aGlzLnByZXAoNCwwKSx0aGlzLndyaXRlRmxvYXQzMih0KX0sci5CdWlsZGVyLnByb3RvdHlwZS5hZGRGbG9hdDY0PWZ1bmN0aW9uKHQpe3RoaXMucHJlcCg4LDApLHRoaXMud3JpdGVGbG9hdDY0KHQpfSxyLkJ1aWxkZXIucHJvdG90eXBlLmFkZEZpZWxkSW50OD1mdW5jdGlvbih0LGUsbil7KHRoaXMuZm9yY2VfZGVmYXVsdHN8fGUhPW4pJiYodGhpcy5hZGRJbnQ4KGUpLHRoaXMuc2xvdCh0KSl9LHIuQnVpbGRlci5wcm90b3R5cGUuYWRkRmllbGRJbnQxNj1mdW5jdGlvbih0LGUsbil7KHRoaXMuZm9yY2VfZGVmYXVsdHN8fGUhPW4pJiYodGhpcy5hZGRJbnQxNihlKSx0aGlzLnNsb3QodCkpfSxyLkJ1aWxkZXIucHJvdG90eXBlLmFkZEZpZWxkSW50MzI9ZnVuY3Rpb24odCxlLG4peyh0aGlzLmZvcmNlX2RlZmF1bHRzfHxlIT1uKSYmKHRoaXMuYWRkSW50MzIoZSksdGhpcy5zbG90KHQpKX0sci5CdWlsZGVyLnByb3RvdHlwZS5hZGRGaWVsZEludDY0PWZ1bmN0aW9uKHQsZSxuKXshdGhpcy5mb3JjZV9kZWZhdWx0cyYmZS5lcXVhbHMobil8fCh0aGlzLmFkZEludDY0KGUpLHRoaXMuc2xvdCh0KSl9LHIuQnVpbGRlci5wcm90b3R5cGUuYWRkRmllbGRGbG9hdDMyPWZ1bmN0aW9uKHQsZSxuKXsodGhpcy5mb3JjZV9kZWZhdWx0c3x8ZSE9bikmJih0aGlzLmFkZEZsb2F0MzIoZSksdGhpcy5zbG90KHQpKX0sci5CdWlsZGVyLnByb3RvdHlwZS5hZGRGaWVsZEZsb2F0NjQ9ZnVuY3Rpb24odCxlLG4peyh0aGlzLmZvcmNlX2RlZmF1bHRzfHxlIT1uKSYmKHRoaXMuYWRkRmxvYXQ2NChlKSx0aGlzLnNsb3QodCkpfSxyLkJ1aWxkZXIucHJvdG90eXBlLmFkZEZpZWxkT2Zmc2V0PWZ1bmN0aW9uKHQsZSxuKXsodGhpcy5mb3JjZV9kZWZhdWx0c3x8ZSE9bikmJih0aGlzLmFkZE9mZnNldChlKSx0aGlzLnNsb3QodCkpfSxyLkJ1aWxkZXIucHJvdG90eXBlLmFkZEZpZWxkU3RydWN0PWZ1bmN0aW9uKHQsZSxuKXtlIT1uJiYodGhpcy5uZXN0ZWQoZSksdGhpcy5zbG90KHQpKX0sci5CdWlsZGVyLnByb3RvdHlwZS5uZXN0ZWQ9ZnVuY3Rpb24odCl7aWYodCE9dGhpcy5vZmZzZXQoKSl0aHJvdyBuZXcgRXJyb3IoXCJGbGF0QnVmZmVyczogc3RydWN0IG11c3QgYmUgc2VyaWFsaXplZCBpbmxpbmUuXCIpfSxyLkJ1aWxkZXIucHJvdG90eXBlLm5vdE5lc3RlZD1mdW5jdGlvbigpe2lmKHRoaXMuaXNOZXN0ZWQpdGhyb3cgbmV3IEVycm9yKFwiRmxhdEJ1ZmZlcnM6IG9iamVjdCBzZXJpYWxpemF0aW9uIG11c3Qgbm90IGJlIG5lc3RlZC5cIil9LHIuQnVpbGRlci5wcm90b3R5cGUuc2xvdD1mdW5jdGlvbih0KXt0aGlzLnZ0YWJsZVt0XT10aGlzLm9mZnNldCgpfSxyLkJ1aWxkZXIucHJvdG90eXBlLm9mZnNldD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmJiLmNhcGFjaXR5KCktdGhpcy5zcGFjZX0sci5CdWlsZGVyLmdyb3dCeXRlQnVmZmVyPWZ1bmN0aW9uKHQpe3ZhciBlPXQuY2FwYWNpdHkoKTtpZigzMjIxMjI1NDcyJmUpdGhyb3cgbmV3IEVycm9yKFwiRmxhdEJ1ZmZlcnM6IGNhbm5vdCBncm93IGJ1ZmZlciBiZXlvbmQgMiBnaWdhYnl0ZXMuXCIpO3ZhciBuPWU8PDEsaT1yLkJ5dGVCdWZmZXIuYWxsb2NhdGUobik7cmV0dXJuIGkuc2V0UG9zaXRpb24obi1lKSxpLmJ5dGVzKCkuc2V0KHQuYnl0ZXMoKSxuLWUpLGl9LHIuQnVpbGRlci5wcm90b3R5cGUuYWRkT2Zmc2V0PWZ1bmN0aW9uKHQpe3RoaXMucHJlcChyLlNJWkVPRl9JTlQsMCksdGhpcy53cml0ZUludDMyKHRoaXMub2Zmc2V0KCktdCtyLlNJWkVPRl9JTlQpfSxyLkJ1aWxkZXIucHJvdG90eXBlLnN0YXJ0T2JqZWN0PWZ1bmN0aW9uKHQpe3RoaXMubm90TmVzdGVkKCksbnVsbD09dGhpcy52dGFibGUmJih0aGlzLnZ0YWJsZT1bXSksdGhpcy52dGFibGVfaW5fdXNlPXQ7Zm9yKHZhciBlPTA7ZTx0O2UrKyl0aGlzLnZ0YWJsZVtlXT0wO3RoaXMuaXNOZXN0ZWQ9ITAsdGhpcy5vYmplY3Rfc3RhcnQ9dGhpcy5vZmZzZXQoKX0sci5CdWlsZGVyLnByb3RvdHlwZS5lbmRPYmplY3Q9ZnVuY3Rpb24oKXtpZihudWxsPT10aGlzLnZ0YWJsZXx8IXRoaXMuaXNOZXN0ZWQpdGhyb3cgbmV3IEVycm9yKFwiRmxhdEJ1ZmZlcnM6IGVuZE9iamVjdCBjYWxsZWQgd2l0aG91dCBzdGFydE9iamVjdFwiKTt0aGlzLmFkZEludDMyKDApO2Zvcih2YXIgdD10aGlzLm9mZnNldCgpLGU9dGhpcy52dGFibGVfaW5fdXNlLTE7ZT49MCYmMD09dGhpcy52dGFibGVbZV07ZS0tKTtmb3IodmFyIG49ZSsxO2U+PTA7ZS0tKXRoaXMuYWRkSW50MTYoMCE9dGhpcy52dGFibGVbZV0/dC10aGlzLnZ0YWJsZVtlXTowKTt0aGlzLmFkZEludDE2KHQtdGhpcy5vYmplY3Rfc3RhcnQpO3ZhciBpPShuKzIpKnIuU0laRU9GX1NIT1JUO3RoaXMuYWRkSW50MTYoaSk7dmFyIG89MCxhPXRoaXMuc3BhY2U7dDpmb3IoZT0wO2U8dGhpcy52dGFibGVzLmxlbmd0aDtlKyspe3ZhciBzPXRoaXMuYmIuY2FwYWNpdHkoKS10aGlzLnZ0YWJsZXNbZV07aWYoaT09dGhpcy5iYi5yZWFkSW50MTYocykpe2Zvcih2YXIgdT1yLlNJWkVPRl9TSE9SVDt1PGk7dSs9ci5TSVpFT0ZfU0hPUlQpaWYodGhpcy5iYi5yZWFkSW50MTYoYSt1KSE9dGhpcy5iYi5yZWFkSW50MTYocyt1KSljb250aW51ZSB0O289dGhpcy52dGFibGVzW2VdO2JyZWFrfX1yZXR1cm4gbz8odGhpcy5zcGFjZT10aGlzLmJiLmNhcGFjaXR5KCktdCx0aGlzLmJiLndyaXRlSW50MzIodGhpcy5zcGFjZSxvLXQpKToodGhpcy52dGFibGVzLnB1c2godGhpcy5vZmZzZXQoKSksdGhpcy5iYi53cml0ZUludDMyKHRoaXMuYmIuY2FwYWNpdHkoKS10LHRoaXMub2Zmc2V0KCktdCkpLHRoaXMuaXNOZXN0ZWQ9ITEsdH0sci5CdWlsZGVyLnByb3RvdHlwZS5maW5pc2g9ZnVuY3Rpb24odCxlLG4pe3ZhciBpPW4/ci5TSVpFX1BSRUZJWF9MRU5HVEg6MDtpZihlKXt2YXIgbz1lO2lmKHRoaXMucHJlcCh0aGlzLm1pbmFsaWduLHIuU0laRU9GX0lOVCtyLkZJTEVfSURFTlRJRklFUl9MRU5HVEgraSksby5sZW5ndGghPXIuRklMRV9JREVOVElGSUVSX0xFTkdUSCl0aHJvdyBuZXcgRXJyb3IoXCJGbGF0QnVmZmVyczogZmlsZSBpZGVudGlmaWVyIG11c3QgYmUgbGVuZ3RoIFwiK3IuRklMRV9JREVOVElGSUVSX0xFTkdUSCk7Zm9yKHZhciBhPXIuRklMRV9JREVOVElGSUVSX0xFTkdUSC0xO2E+PTA7YS0tKXRoaXMud3JpdGVJbnQ4KG8uY2hhckNvZGVBdChhKSl9dGhpcy5wcmVwKHRoaXMubWluYWxpZ24sci5TSVpFT0ZfSU5UK2kpLHRoaXMuYWRkT2Zmc2V0KHQpLGkmJnRoaXMuYWRkSW50MzIodGhpcy5iYi5jYXBhY2l0eSgpLXRoaXMuc3BhY2UpLHRoaXMuYmIuc2V0UG9zaXRpb24odGhpcy5zcGFjZSl9LHIuQnVpbGRlci5wcm90b3R5cGUuZmluaXNoU2l6ZVByZWZpeGVkPWZ1bmN0aW9uKHQsZSl7dGhpcy5maW5pc2godCxlLCEwKX0sci5CdWlsZGVyLnByb3RvdHlwZS5yZXF1aXJlZEZpZWxkPWZ1bmN0aW9uKHQsZSl7dmFyIG49dGhpcy5iYi5jYXBhY2l0eSgpLXQscj1uLXRoaXMuYmIucmVhZEludDMyKG4pO2lmKDA9PXRoaXMuYmIucmVhZEludDE2KHIrZSkpdGhyb3cgbmV3IEVycm9yKFwiRmxhdEJ1ZmZlcnM6IGZpZWxkIFwiK2UrXCIgbXVzdCBiZSBzZXRcIil9LHIuQnVpbGRlci5wcm90b3R5cGUuc3RhcnRWZWN0b3I9ZnVuY3Rpb24odCxlLG4pe3RoaXMubm90TmVzdGVkKCksdGhpcy52ZWN0b3JfbnVtX2VsZW1zPWUsdGhpcy5wcmVwKHIuU0laRU9GX0lOVCx0KmUpLHRoaXMucHJlcChuLHQqZSl9LHIuQnVpbGRlci5wcm90b3R5cGUuZW5kVmVjdG9yPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMud3JpdGVJbnQzMih0aGlzLnZlY3Rvcl9udW1fZWxlbXMpLHRoaXMub2Zmc2V0KCl9LHIuQnVpbGRlci5wcm90b3R5cGUuY3JlYXRlU3RyaW5nPWZ1bmN0aW9uKHQpe2lmKHQgaW5zdGFuY2VvZiBVaW50OEFycmF5KXZhciBlPXQ7ZWxzZXtlPVtdO2Zvcih2YXIgbj0wO248dC5sZW5ndGg7KXt2YXIgcixpPXQuY2hhckNvZGVBdChuKyspOyhyPWk8NTUyOTZ8fGk+PTU2MzIwP2k6KGk8PDEwKSt0LmNoYXJDb2RlQXQobisrKSstNTY2MTM4ODgpPDEyOD9lLnB1c2gocik6KHI8MjA0OD9lLnB1c2gocj4+NiYzMXwxOTIpOihyPDY1NTM2P2UucHVzaChyPj4xMiYxNXwyMjQpOmUucHVzaChyPj4xOCY3fDI0MCxyPj4xMiY2M3wxMjgpLGUucHVzaChyPj42JjYzfDEyOCkpLGUucHVzaCg2MyZyfDEyOCkpfX10aGlzLmFkZEludDgoMCksdGhpcy5zdGFydFZlY3RvcigxLGUubGVuZ3RoLDEpLHRoaXMuYmIuc2V0UG9zaXRpb24odGhpcy5zcGFjZS09ZS5sZW5ndGgpLG49MDtmb3IodmFyIG89dGhpcy5zcGFjZSxhPXRoaXMuYmIuYnl0ZXMoKTtuPGUubGVuZ3RoO24rKylhW28rK109ZVtuXTtyZXR1cm4gdGhpcy5lbmRWZWN0b3IoKX0sci5CdWlsZGVyLnByb3RvdHlwZS5jcmVhdGVMb25nPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHIuTG9uZy5jcmVhdGUodCxlKX0sci5CeXRlQnVmZmVyPWZ1bmN0aW9uKHQpe3RoaXMuYnl0ZXNfPXQsdGhpcy5wb3NpdGlvbl89MH0sci5CeXRlQnVmZmVyLmFsbG9jYXRlPWZ1bmN0aW9uKHQpe3JldHVybiBuZXcgci5CeXRlQnVmZmVyKG5ldyBVaW50OEFycmF5KHQpKX0sci5CeXRlQnVmZmVyLnByb3RvdHlwZS5jbGVhcj1mdW5jdGlvbigpe3RoaXMucG9zaXRpb25fPTB9LHIuQnl0ZUJ1ZmZlci5wcm90b3R5cGUuYnl0ZXM9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5ieXRlc199LHIuQnl0ZUJ1ZmZlci5wcm90b3R5cGUucG9zaXRpb249ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wb3NpdGlvbl99LHIuQnl0ZUJ1ZmZlci5wcm90b3R5cGUuc2V0UG9zaXRpb249ZnVuY3Rpb24odCl7dGhpcy5wb3NpdGlvbl89dH0sci5CeXRlQnVmZmVyLnByb3RvdHlwZS5jYXBhY2l0eT1mdW5jdGlvbigpe3JldHVybiB0aGlzLmJ5dGVzXy5sZW5ndGh9LHIuQnl0ZUJ1ZmZlci5wcm90b3R5cGUucmVhZEludDg9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMucmVhZFVpbnQ4KHQpPDwyND4+MjR9LHIuQnl0ZUJ1ZmZlci5wcm90b3R5cGUucmVhZFVpbnQ4PWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmJ5dGVzX1t0XX0sci5CeXRlQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTY9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMucmVhZFVpbnQxNih0KTw8MTY+PjE2fSxyLkJ5dGVCdWZmZXIucHJvdG90eXBlLnJlYWRVaW50MTY9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuYnl0ZXNfW3RdfHRoaXMuYnl0ZXNfW3QrMV08PDh9LHIuQnl0ZUJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmJ5dGVzX1t0XXx0aGlzLmJ5dGVzX1t0KzFdPDw4fHRoaXMuYnl0ZXNfW3QrMl08PDE2fHRoaXMuYnl0ZXNfW3QrM108PDI0fSxyLkJ5dGVCdWZmZXIucHJvdG90eXBlLnJlYWRVaW50MzI9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMucmVhZEludDMyKHQpPj4+MH0sci5CeXRlQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50NjQ9ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyByLkxvbmcodGhpcy5yZWFkSW50MzIodCksdGhpcy5yZWFkSW50MzIodCs0KSl9LHIuQnl0ZUJ1ZmZlci5wcm90b3R5cGUucmVhZFVpbnQ2ND1mdW5jdGlvbih0KXtyZXR1cm4gbmV3IHIuTG9uZyh0aGlzLnJlYWRVaW50MzIodCksdGhpcy5yZWFkVWludDMyKHQrNCkpfSxyLkJ5dGVCdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdDMyPWZ1bmN0aW9uKHQpe3JldHVybiByLmludDMyWzBdPXRoaXMucmVhZEludDMyKHQpLHIuZmxvYXQzMlswXX0sci5CeXRlQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXQ2ND1mdW5jdGlvbih0KXtyZXR1cm4gci5pbnQzMltyLmlzTGl0dGxlRW5kaWFuPzA6MV09dGhpcy5yZWFkSW50MzIodCksci5pbnQzMltyLmlzTGl0dGxlRW5kaWFuPzE6MF09dGhpcy5yZWFkSW50MzIodCs0KSxyLmZsb2F0NjRbMF19LHIuQnl0ZUJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4PWZ1bmN0aW9uKHQsZSl7dGhpcy5ieXRlc19bdF09ZX0sci5CeXRlQnVmZmVyLnByb3RvdHlwZS53cml0ZVVpbnQ4PWZ1bmN0aW9uKHQsZSl7dGhpcy5ieXRlc19bdF09ZX0sci5CeXRlQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2PWZ1bmN0aW9uKHQsZSl7dGhpcy5ieXRlc19bdF09ZSx0aGlzLmJ5dGVzX1t0KzFdPWU+Pjh9LHIuQnl0ZUJ1ZmZlci5wcm90b3R5cGUud3JpdGVVaW50MTY9ZnVuY3Rpb24odCxlKXt0aGlzLmJ5dGVzX1t0XT1lLHRoaXMuYnl0ZXNfW3QrMV09ZT4+OH0sci5CeXRlQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyPWZ1bmN0aW9uKHQsZSl7dGhpcy5ieXRlc19bdF09ZSx0aGlzLmJ5dGVzX1t0KzFdPWU+PjgsdGhpcy5ieXRlc19bdCsyXT1lPj4xNix0aGlzLmJ5dGVzX1t0KzNdPWU+PjI0fSxyLkJ5dGVCdWZmZXIucHJvdG90eXBlLndyaXRlVWludDMyPWZ1bmN0aW9uKHQsZSl7dGhpcy5ieXRlc19bdF09ZSx0aGlzLmJ5dGVzX1t0KzFdPWU+PjgsdGhpcy5ieXRlc19bdCsyXT1lPj4xNix0aGlzLmJ5dGVzX1t0KzNdPWU+PjI0fSxyLkJ5dGVCdWZmZXIucHJvdG90eXBlLndyaXRlSW50NjQ9ZnVuY3Rpb24odCxlKXt0aGlzLndyaXRlSW50MzIodCxlLmxvdyksdGhpcy53cml0ZUludDMyKHQrNCxlLmhpZ2gpfSxyLkJ5dGVCdWZmZXIucHJvdG90eXBlLndyaXRlVWludDY0PWZ1bmN0aW9uKHQsZSl7dGhpcy53cml0ZVVpbnQzMih0LGUubG93KSx0aGlzLndyaXRlVWludDMyKHQrNCxlLmhpZ2gpfSxyLkJ5dGVCdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXQzMj1mdW5jdGlvbih0LGUpe3IuZmxvYXQzMlswXT1lLHRoaXMud3JpdGVJbnQzMih0LHIuaW50MzJbMF0pfSxyLkJ5dGVCdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXQ2ND1mdW5jdGlvbih0LGUpe3IuZmxvYXQ2NFswXT1lLHRoaXMud3JpdGVJbnQzMih0LHIuaW50MzJbci5pc0xpdHRsZUVuZGlhbj8wOjFdKSx0aGlzLndyaXRlSW50MzIodCs0LHIuaW50MzJbci5pc0xpdHRsZUVuZGlhbj8xOjBdKX0sci5CeXRlQnVmZmVyLnByb3RvdHlwZS5nZXRCdWZmZXJJZGVudGlmaWVyPWZ1bmN0aW9uKCl7aWYodGhpcy5ieXRlc18ubGVuZ3RoPHRoaXMucG9zaXRpb25fK3IuU0laRU9GX0lOVCtyLkZJTEVfSURFTlRJRklFUl9MRU5HVEgpdGhyb3cgbmV3IEVycm9yKFwiRmxhdEJ1ZmZlcnM6IEJ5dGVCdWZmZXIgaXMgdG9vIHNob3J0IHRvIGNvbnRhaW4gYW4gaWRlbnRpZmllci5cIik7Zm9yKHZhciB0PVwiXCIsZT0wO2U8ci5GSUxFX0lERU5USUZJRVJfTEVOR1RIO2UrKyl0Kz1TdHJpbmcuZnJvbUNoYXJDb2RlKHRoaXMucmVhZEludDgodGhpcy5wb3NpdGlvbl8rci5TSVpFT0ZfSU5UK2UpKTtyZXR1cm4gdH0sci5CeXRlQnVmZmVyLnByb3RvdHlwZS5fX29mZnNldD1mdW5jdGlvbih0LGUpe3ZhciBuPXQtdGhpcy5yZWFkSW50MzIodCk7cmV0dXJuIGU8dGhpcy5yZWFkSW50MTYobik/dGhpcy5yZWFkSW50MTYobitlKTowfSxyLkJ5dGVCdWZmZXIucHJvdG90eXBlLl9fdW5pb249ZnVuY3Rpb24odCxlKXtyZXR1cm4gdC5iYl9wb3M9ZSt0aGlzLnJlYWRJbnQzMihlKSx0LmJiPXRoaXMsdH0sci5CeXRlQnVmZmVyLnByb3RvdHlwZS5fX3N0cmluZz1mdW5jdGlvbih0LGUpe3QrPXRoaXMucmVhZEludDMyKHQpO3ZhciBuPXRoaXMucmVhZEludDMyKHQpLGk9XCJcIixvPTA7aWYodCs9ci5TSVpFT0ZfSU5ULGU9PT1yLkVuY29kaW5nLlVURjhfQllURVMpcmV0dXJuIHRoaXMuYnl0ZXNfLnN1YmFycmF5KHQsdCtuKTtmb3IoO288bjspe3ZhciBhLHM9dGhpcy5yZWFkVWludDgodCtvKyspO2lmKHM8MTkyKWE9cztlbHNle3ZhciB1PXRoaXMucmVhZFVpbnQ4KHQrbysrKTtpZihzPDIyNClhPSgzMSZzKTw8Nnw2MyZ1O2Vsc2V7dmFyIGM9dGhpcy5yZWFkVWludDgodCtvKyspO2E9czwyNDA/KDE1JnMpPDwxMnwoNjMmdSk8PDZ8NjMmYzooNyZzKTw8MTh8KDYzJnUpPDwxMnwoNjMmYyk8PDZ8NjMmdGhpcy5yZWFkVWludDgodCtvKyspfX1hPDY1NTM2P2krPVN0cmluZy5mcm9tQ2hhckNvZGUoYSk6KGEtPTY1NTM2LGkrPVN0cmluZy5mcm9tQ2hhckNvZGUoNTUyOTYrKGE+PjEwKSw1NjMyMCsoMTAyMyZhKSkpfXJldHVybiBpfSxyLkJ5dGVCdWZmZXIucHJvdG90eXBlLl9faW5kaXJlY3Q9ZnVuY3Rpb24odCl7cmV0dXJuIHQrdGhpcy5yZWFkSW50MzIodCl9LHIuQnl0ZUJ1ZmZlci5wcm90b3R5cGUuX192ZWN0b3I9ZnVuY3Rpb24odCl7cmV0dXJuIHQrdGhpcy5yZWFkSW50MzIodCkrci5TSVpFT0ZfSU5UfSxyLkJ5dGVCdWZmZXIucHJvdG90eXBlLl9fdmVjdG9yX2xlbj1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5yZWFkSW50MzIodCt0aGlzLnJlYWRJbnQzMih0KSl9LHIuQnl0ZUJ1ZmZlci5wcm90b3R5cGUuX19oYXNfaWRlbnRpZmllcj1mdW5jdGlvbih0KXtpZih0Lmxlbmd0aCE9ci5GSUxFX0lERU5USUZJRVJfTEVOR1RIKXRocm93IG5ldyBFcnJvcihcIkZsYXRCdWZmZXJzOiBmaWxlIGlkZW50aWZpZXIgbXVzdCBiZSBsZW5ndGggXCIrci5GSUxFX0lERU5USUZJRVJfTEVOR1RIKTtmb3IodmFyIGU9MDtlPHIuRklMRV9JREVOVElGSUVSX0xFTkdUSDtlKyspaWYodC5jaGFyQ29kZUF0KGUpIT10aGlzLnJlYWRJbnQ4KHRoaXMucG9zaXRpb25fK3IuU0laRU9GX0lOVCtlKSlyZXR1cm4hMTtyZXR1cm4hMH0sci5CeXRlQnVmZmVyLnByb3RvdHlwZS5jcmVhdGVMb25nPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHIuTG9uZy5jcmVhdGUodCxlKX19fSxfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX189e307ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyh0KXt2YXIgZT1fX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bdF07aWYodm9pZCAwIT09ZSlyZXR1cm4gZS5leHBvcnRzO3ZhciBuPV9fd2VicGFja19tb2R1bGVfY2FjaGVfX1t0XT17ZXhwb3J0czp7fX07cmV0dXJuIF9fd2VicGFja19tb2R1bGVzX19bdF0uY2FsbChuLmV4cG9ydHMsbixuLmV4cG9ydHMsX193ZWJwYWNrX3JlcXVpcmVfXyksbi5leHBvcnRzfV9fd2VicGFja19yZXF1aXJlX18ubj10PT57dmFyIGU9dCYmdC5fX2VzTW9kdWxlPygpPT50LmRlZmF1bHQ6KCk9PnQ7cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18uZChlLHthOmV9KSxlfSxfX3dlYnBhY2tfcmVxdWlyZV9fLmQ9KHQsZSk9Pntmb3IodmFyIG4gaW4gZSlfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZSxuKSYmIV9fd2VicGFja19yZXF1aXJlX18ubyh0LG4pJiZPYmplY3QuZGVmaW5lUHJvcGVydHkodCxuLHtlbnVtZXJhYmxlOiEwLGdldDplW25dfSl9LF9fd2VicGFja19yZXF1aXJlX18ubz0odCxlKT0+T2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQsZSksX193ZWJwYWNrX3JlcXVpcmVfXy5yPXQ9PntcInVuZGVmaW5lZFwiIT10eXBlb2YgU3ltYm9sJiZTeW1ib2wudG9TdHJpbmdUYWcmJk9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFN5bWJvbC50b1N0cmluZ1RhZyx7dmFsdWU6XCJNb2R1bGVcIn0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pfTt2YXIgX193ZWJwYWNrX2V4cG9ydHNfXz1fX3dlYnBhY2tfcmVxdWlyZV9fKDYwMTgpLF9fd2VicGFja19leHBvcnRfdGFyZ2V0X189ZXhwb3J0cztmb3IodmFyIGkgaW4gX193ZWJwYWNrX2V4cG9ydHNfXylfX3dlYnBhY2tfZXhwb3J0X3RhcmdldF9fW2ldPV9fd2VicGFja19leHBvcnRzX19baV07X193ZWJwYWNrX2V4cG9ydHNfXy5fX2VzTW9kdWxlJiZPYmplY3QuZGVmaW5lUHJvcGVydHkoX193ZWJwYWNrX2V4cG9ydF90YXJnZXRfXyxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KX0pKCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1vcnQtd2ViLm5vZGUuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/onnxruntime-web/dist/ort-web.node.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@xenova/transformers/src/backends/onnx.js":
/*!****************************************************************!*\
  !*** ./node_modules/@xenova/transformers/src/backends/onnx.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("var onnxruntime_node__WEBPACK_IMPORTED_MODULE_0___namespace_cache;\nvar onnxruntime_web__WEBPACK_IMPORTED_MODULE_1___namespace_cache;\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ONNX: () => (/* binding */ ONNX),\n/* harmony export */   executionProviders: () => (/* binding */ executionProviders)\n/* harmony export */ });\n/* harmony import */ var onnxruntime_node__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! onnxruntime-node */ \"?c7c8\");\n/* harmony import */ var onnxruntime_web__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! onnxruntime-web */ \"(ssr)/./node_modules/onnxruntime-web/dist/ort-web.node.js\");\n/**\n * @file Handler file for choosing the correct version of ONNX Runtime, based on the environment.\n * Ideally, we could import the `onnxruntime-web` and `onnxruntime-node` packages only when needed,\n * but dynamic imports don't seem to work with the current webpack version and/or configuration.\n * This is possibly due to the experimental nature of top-level await statements.\n * So, we just import both packages, and use the appropriate one based on the environment:\n *   - When running in node, we use `onnxruntime-node`.\n *   - When running in the browser, we use `onnxruntime-web` (`onnxruntime-node` is not bundled).\n * \n * This module is not directly exported, but can be accessed through the environment variables:\n * ```javascript\n * import { env } from '@xenova/transformers';\n * console.log(env.backends.onnx);\n * ```\n * \n * @module backends/onnx\n */\n\n// NOTE: Import order matters here. We need to import `onnxruntime-node` before `onnxruntime-web`.\n// In either case, we select the default export if it exists, otherwise we use the named export.\n\n\n\n/** @type {module} The ONNX runtime module. */\nlet ONNX;\n\nconst executionProviders = [\n    // 'webgpu',\n    'wasm'\n];\n\nif (typeof process !== 'undefined' && process?.release?.name === 'node') {\n    // Running in a node-like environment.\n    ONNX = onnxruntime_node__WEBPACK_IMPORTED_MODULE_0__ ?? /*#__PURE__*/ (onnxruntime_node__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (onnxruntime_node__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(onnxruntime_node__WEBPACK_IMPORTED_MODULE_0__, 2)));\n\n    // Add `cpu` execution provider, with higher precedence that `wasm`.\n    executionProviders.unshift('cpu');\n\n} else {\n    // Running in a browser-environment\n    ONNX = onnxruntime_web__WEBPACK_IMPORTED_MODULE_1__ ?? /*#__PURE__*/ (onnxruntime_web__WEBPACK_IMPORTED_MODULE_1___namespace_cache || (onnxruntime_web__WEBPACK_IMPORTED_MODULE_1___namespace_cache = __webpack_require__.t(onnxruntime_web__WEBPACK_IMPORTED_MODULE_1__, 2)));\n\n    // SIMD for WebAssembly does not operate correctly in some recent versions of iOS (16.4.x).\n    // As a temporary fix, we disable it for now.\n    // For more information, see: https://github.com/microsoft/onnxruntime/issues/15644\n    const isIOS = typeof navigator !== 'undefined' && /iP(hone|od|ad).+16_4.+AppleWebKit/.test(navigator.userAgent);\n    if (isIOS) {\n        ONNX.env.wasm.simd = false;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHhlbm92YS90cmFuc2Zvcm1lcnMvc3JjL2JhY2tlbmRzL29ubnguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksTUFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDOEM7QUFDRjs7QUFFNUMsV0FBVyxRQUFRO0FBQ1o7O0FBRUE7QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsNkNBQWlCLElBQUksME5BQVM7O0FBRXpDO0FBQ0E7O0FBRUEsRUFBRTtBQUNGO0FBQ0EsV0FBVyw0Q0FBZ0IsSUFBSSx1TkFBUTs7QUFFdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3RyYW5zZm9ybWVyc2pzLXBsYXlncm91bmQvLi9ub2RlX21vZHVsZXMvQHhlbm92YS90cmFuc2Zvcm1lcnMvc3JjL2JhY2tlbmRzL29ubnguanM/YzRmYSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBmaWxlIEhhbmRsZXIgZmlsZSBmb3IgY2hvb3NpbmcgdGhlIGNvcnJlY3QgdmVyc2lvbiBvZiBPTk5YIFJ1bnRpbWUsIGJhc2VkIG9uIHRoZSBlbnZpcm9ubWVudC5cbiAqIElkZWFsbHksIHdlIGNvdWxkIGltcG9ydCB0aGUgYG9ubnhydW50aW1lLXdlYmAgYW5kIGBvbm54cnVudGltZS1ub2RlYCBwYWNrYWdlcyBvbmx5IHdoZW4gbmVlZGVkLFxuICogYnV0IGR5bmFtaWMgaW1wb3J0cyBkb24ndCBzZWVtIHRvIHdvcmsgd2l0aCB0aGUgY3VycmVudCB3ZWJwYWNrIHZlcnNpb24gYW5kL29yIGNvbmZpZ3VyYXRpb24uXG4gKiBUaGlzIGlzIHBvc3NpYmx5IGR1ZSB0byB0aGUgZXhwZXJpbWVudGFsIG5hdHVyZSBvZiB0b3AtbGV2ZWwgYXdhaXQgc3RhdGVtZW50cy5cbiAqIFNvLCB3ZSBqdXN0IGltcG9ydCBib3RoIHBhY2thZ2VzLCBhbmQgdXNlIHRoZSBhcHByb3ByaWF0ZSBvbmUgYmFzZWQgb24gdGhlIGVudmlyb25tZW50OlxuICogICAtIFdoZW4gcnVubmluZyBpbiBub2RlLCB3ZSB1c2UgYG9ubnhydW50aW1lLW5vZGVgLlxuICogICAtIFdoZW4gcnVubmluZyBpbiB0aGUgYnJvd3Nlciwgd2UgdXNlIGBvbm54cnVudGltZS13ZWJgIChgb25ueHJ1bnRpbWUtbm9kZWAgaXMgbm90IGJ1bmRsZWQpLlxuICogXG4gKiBUaGlzIG1vZHVsZSBpcyBub3QgZGlyZWN0bHkgZXhwb3J0ZWQsIGJ1dCBjYW4gYmUgYWNjZXNzZWQgdGhyb3VnaCB0aGUgZW52aXJvbm1lbnQgdmFyaWFibGVzOlxuICogYGBgamF2YXNjcmlwdFxuICogaW1wb3J0IHsgZW52IH0gZnJvbSAnQHhlbm92YS90cmFuc2Zvcm1lcnMnO1xuICogY29uc29sZS5sb2coZW52LmJhY2tlbmRzLm9ubngpO1xuICogYGBgXG4gKiBcbiAqIEBtb2R1bGUgYmFja2VuZHMvb25ueFxuICovXG5cbi8vIE5PVEU6IEltcG9ydCBvcmRlciBtYXR0ZXJzIGhlcmUuIFdlIG5lZWQgdG8gaW1wb3J0IGBvbm54cnVudGltZS1ub2RlYCBiZWZvcmUgYG9ubnhydW50aW1lLXdlYmAuXG4vLyBJbiBlaXRoZXIgY2FzZSwgd2Ugc2VsZWN0IHRoZSBkZWZhdWx0IGV4cG9ydCBpZiBpdCBleGlzdHMsIG90aGVyd2lzZSB3ZSB1c2UgdGhlIG5hbWVkIGV4cG9ydC5cbmltcG9ydCAqIGFzIE9OTlhfTk9ERSBmcm9tICdvbm54cnVudGltZS1ub2RlJztcbmltcG9ydCAqIGFzIE9OTlhfV0VCIGZyb20gJ29ubnhydW50aW1lLXdlYic7XG5cbi8qKiBAdHlwZSB7bW9kdWxlfSBUaGUgT05OWCBydW50aW1lIG1vZHVsZS4gKi9cbmV4cG9ydCBsZXQgT05OWDtcblxuZXhwb3J0IGNvbnN0IGV4ZWN1dGlvblByb3ZpZGVycyA9IFtcbiAgICAvLyAnd2ViZ3B1JyxcbiAgICAnd2FzbSdcbl07XG5cbmlmICh0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgcHJvY2Vzcz8ucmVsZWFzZT8ubmFtZSA9PT0gJ25vZGUnKSB7XG4gICAgLy8gUnVubmluZyBpbiBhIG5vZGUtbGlrZSBlbnZpcm9ubWVudC5cbiAgICBPTk5YID0gT05OWF9OT0RFLmRlZmF1bHQgPz8gT05OWF9OT0RFO1xuXG4gICAgLy8gQWRkIGBjcHVgIGV4ZWN1dGlvbiBwcm92aWRlciwgd2l0aCBoaWdoZXIgcHJlY2VkZW5jZSB0aGF0IGB3YXNtYC5cbiAgICBleGVjdXRpb25Qcm92aWRlcnMudW5zaGlmdCgnY3B1Jyk7XG5cbn0gZWxzZSB7XG4gICAgLy8gUnVubmluZyBpbiBhIGJyb3dzZXItZW52aXJvbm1lbnRcbiAgICBPTk5YID0gT05OWF9XRUIuZGVmYXVsdCA/PyBPTk5YX1dFQjtcblxuICAgIC8vIFNJTUQgZm9yIFdlYkFzc2VtYmx5IGRvZXMgbm90IG9wZXJhdGUgY29ycmVjdGx5IGluIHNvbWUgcmVjZW50IHZlcnNpb25zIG9mIGlPUyAoMTYuNC54KS5cbiAgICAvLyBBcyBhIHRlbXBvcmFyeSBmaXgsIHdlIGRpc2FibGUgaXQgZm9yIG5vdy5cbiAgICAvLyBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgc2VlOiBodHRwczovL2dpdGh1Yi5jb20vbWljcm9zb2Z0L29ubnhydW50aW1lL2lzc3Vlcy8xNTY0NFxuICAgIGNvbnN0IGlzSU9TID0gdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgL2lQKGhvbmV8b2R8YWQpLisxNl80LitBcHBsZVdlYktpdC8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgICBpZiAoaXNJT1MpIHtcbiAgICAgICAgT05OWC5lbnYud2FzbS5zaW1kID0gZmFsc2U7XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@xenova/transformers/src/backends/onnx.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@xenova/transformers/src/configs.js":
/*!**********************************************************!*\
  !*** ./node_modules/@xenova/transformers/src/configs.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AutoConfig: () => (/* binding */ AutoConfig),\n/* harmony export */   PretrainedConfig: () => (/* binding */ PretrainedConfig)\n/* harmony export */ });\n/* harmony import */ var _utils_hub_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/hub.js */ \"(ssr)/./node_modules/@xenova/transformers/src/utils/hub.js\");\n\n/**\n * @file Helper module for using model configs. For more information, see the corresponding\n * [Python documentation](https://huggingface.co/docs/transformers/main/en/model_doc/auto#transformers.AutoConfig).\n * \n * **Example:** Load an `AutoConfig`.\n * \n * ```javascript\n * import { AutoConfig } from '@xenova/transformers';\n * let config = await AutoConfig.from_pretrained('bert-base-uncased');\n * console.log(config);\n * // PretrainedConfig {\n * //   \"model_type\": \"bert\",\n * //   \"is_encoder_decoder\": false,\n * //   \"architectures\": [\n * //       \"BertForMaskedLM\"\n * //   ],\n * //   \"vocab_size\": 30522\n * //   \"num_attention_heads\": 12,\n * //   \"num_hidden_layers\": 12,\n * //   \"hidden_size\": 768,\n * //   \"max_position_embeddings\": 512,\n * //   ...\n * // }\n * ```\n * \n * @module configs\n */\n\n\n\n/**\n * @typedef {import('./utils/hub.js').PretrainedOptions} PretrainedOptions\n */\n\n\n/**\n * Loads a config from the specified path.\n * @param {string} pretrained_model_name_or_path The path to the config directory.\n * @param {PretrainedOptions} options Additional options for loading the config.\n * @returns {Promise<Array>} A promise that resolves with information about the loaded config.\n */\nasync function loadConfig(pretrained_model_name_or_path, options) {\n    let info = await (0,_utils_hub_js__WEBPACK_IMPORTED_MODULE_0__.getModelJSON)(pretrained_model_name_or_path, 'config.json', true, options);\n    return info;\n}\n\n/**\n * Base class for all configuration classes. For more information, see the corresponding\n * [Python documentation](https://huggingface.co/docs/transformers/main/en/main_classes/configuration#transformers.PretrainedConfig).\n */\nclass PretrainedConfig {\n    // NOTE: Typo in original\n\n    /**\n     * Create a new PreTrainedTokenizer instance.\n     * @param {Object} configJSON The JSON of the config.\n     */\n    constructor(configJSON) {\n        this.model_type = null;\n        this.is_encoder_decoder = false;\n\n        Object.assign(this, configJSON);\n    }\n\n    /**\n     * Loads a pre-trained config from the given `pretrained_model_name_or_path`. \n     * \n     * @param {string} pretrained_model_name_or_path The path to the pre-trained config.\n     * @param {PretrainedOptions} options Additional options for loading the config.\n     * @throws {Error} Throws an error if the config.json is not found in the `pretrained_model_name_or_path`.\n     * \n     * @returns {Promise<PretrainedConfig>} A new instance of the `PretrainedConfig` class.\n     */\n    static async from_pretrained(pretrained_model_name_or_path, {\n        progress_callback = null,\n        config = null,\n        cache_dir = null,\n        local_files_only = false,\n        revision = 'main',\n    } = {}) {\n\n        let data = config ?? await loadConfig(pretrained_model_name_or_path, {\n            progress_callback,\n            config,\n            cache_dir,\n            local_files_only,\n            revision,\n        })\n        return new this(data);\n    }\n}\n\n/**\n * Helper class which is used to instantiate pretrained configs with the `from_pretrained` function.\n * \n * @example\n * let config = await AutoConfig.from_pretrained('bert-base-uncased'); \n */\nclass AutoConfig {\n    /** @type {PretrainedConfig.from_pretrained} */\n    static async from_pretrained(...args) {\n        return PretrainedConfig.from_pretrained(...args);\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHhlbm92YS90cmFuc2Zvcm1lcnMvc3JjL2NvbmZpZ3MuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxhQUFhO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUl3Qjs7QUFFeEI7QUFDQSxhQUFhLDRDQUE0QztBQUN6RDs7O0FBR0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLG1CQUFtQjtBQUM5QixhQUFhLGdCQUFnQjtBQUM3QjtBQUNBO0FBQ0EscUJBQXFCLDJEQUFZO0FBQ2pDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxtQkFBbUI7QUFDbEMsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQSxpQkFBaUIsMkJBQTJCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxJQUFJOztBQUVWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxlQUFlLGtDQUFrQztBQUNqRDtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3RyYW5zZm9ybWVyc2pzLXBsYXlncm91bmQvLi9ub2RlX21vZHVsZXMvQHhlbm92YS90cmFuc2Zvcm1lcnMvc3JjL2NvbmZpZ3MuanM/MmM3MiJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qKlxuICogQGZpbGUgSGVscGVyIG1vZHVsZSBmb3IgdXNpbmcgbW9kZWwgY29uZmlncy4gRm9yIG1vcmUgaW5mb3JtYXRpb24sIHNlZSB0aGUgY29ycmVzcG9uZGluZ1xuICogW1B5dGhvbiBkb2N1bWVudGF0aW9uXShodHRwczovL2h1Z2dpbmdmYWNlLmNvL2RvY3MvdHJhbnNmb3JtZXJzL21haW4vZW4vbW9kZWxfZG9jL2F1dG8jdHJhbnNmb3JtZXJzLkF1dG9Db25maWcpLlxuICogXG4gKiAqKkV4YW1wbGU6KiogTG9hZCBhbiBgQXV0b0NvbmZpZ2AuXG4gKiBcbiAqIGBgYGphdmFzY3JpcHRcbiAqIGltcG9ydCB7IEF1dG9Db25maWcgfSBmcm9tICdAeGVub3ZhL3RyYW5zZm9ybWVycyc7XG4gKiBsZXQgY29uZmlnID0gYXdhaXQgQXV0b0NvbmZpZy5mcm9tX3ByZXRyYWluZWQoJ2JlcnQtYmFzZS11bmNhc2VkJyk7XG4gKiBjb25zb2xlLmxvZyhjb25maWcpO1xuICogLy8gUHJldHJhaW5lZENvbmZpZyB7XG4gKiAvLyAgIFwibW9kZWxfdHlwZVwiOiBcImJlcnRcIixcbiAqIC8vICAgXCJpc19lbmNvZGVyX2RlY29kZXJcIjogZmFsc2UsXG4gKiAvLyAgIFwiYXJjaGl0ZWN0dXJlc1wiOiBbXG4gKiAvLyAgICAgICBcIkJlcnRGb3JNYXNrZWRMTVwiXG4gKiAvLyAgIF0sXG4gKiAvLyAgIFwidm9jYWJfc2l6ZVwiOiAzMDUyMlxuICogLy8gICBcIm51bV9hdHRlbnRpb25faGVhZHNcIjogMTIsXG4gKiAvLyAgIFwibnVtX2hpZGRlbl9sYXllcnNcIjogMTIsXG4gKiAvLyAgIFwiaGlkZGVuX3NpemVcIjogNzY4LFxuICogLy8gICBcIm1heF9wb3NpdGlvbl9lbWJlZGRpbmdzXCI6IDUxMixcbiAqIC8vICAgLi4uXG4gKiAvLyB9XG4gKiBgYGBcbiAqIFxuICogQG1vZHVsZSBjb25maWdzXG4gKi9cblxuaW1wb3J0IHtcbiAgICBnZXRNb2RlbEpTT04sXG59IGZyb20gJy4vdXRpbHMvaHViLmpzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuL3V0aWxzL2h1Yi5qcycpLlByZXRyYWluZWRPcHRpb25zfSBQcmV0cmFpbmVkT3B0aW9uc1xuICovXG5cblxuLyoqXG4gKiBMb2FkcyBhIGNvbmZpZyBmcm9tIHRoZSBzcGVjaWZpZWQgcGF0aC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBwcmV0cmFpbmVkX21vZGVsX25hbWVfb3JfcGF0aCBUaGUgcGF0aCB0byB0aGUgY29uZmlnIGRpcmVjdG9yeS5cbiAqIEBwYXJhbSB7UHJldHJhaW5lZE9wdGlvbnN9IG9wdGlvbnMgQWRkaXRpb25hbCBvcHRpb25zIGZvciBsb2FkaW5nIHRoZSBjb25maWcuXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxBcnJheT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggaW5mb3JtYXRpb24gYWJvdXQgdGhlIGxvYWRlZCBjb25maWcuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGxvYWRDb25maWcocHJldHJhaW5lZF9tb2RlbF9uYW1lX29yX3BhdGgsIG9wdGlvbnMpIHtcbiAgICBsZXQgaW5mbyA9IGF3YWl0IGdldE1vZGVsSlNPTihwcmV0cmFpbmVkX21vZGVsX25hbWVfb3JfcGF0aCwgJ2NvbmZpZy5qc29uJywgdHJ1ZSwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIGluZm87XG59XG5cbi8qKlxuICogQmFzZSBjbGFzcyBmb3IgYWxsIGNvbmZpZ3VyYXRpb24gY2xhc3Nlcy4gRm9yIG1vcmUgaW5mb3JtYXRpb24sIHNlZSB0aGUgY29ycmVzcG9uZGluZ1xuICogW1B5dGhvbiBkb2N1bWVudGF0aW9uXShodHRwczovL2h1Z2dpbmdmYWNlLmNvL2RvY3MvdHJhbnNmb3JtZXJzL21haW4vZW4vbWFpbl9jbGFzc2VzL2NvbmZpZ3VyYXRpb24jdHJhbnNmb3JtZXJzLlByZXRyYWluZWRDb25maWcpLlxuICovXG5leHBvcnQgY2xhc3MgUHJldHJhaW5lZENvbmZpZyB7XG4gICAgLy8gTk9URTogVHlwbyBpbiBvcmlnaW5hbFxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IFByZVRyYWluZWRUb2tlbml6ZXIgaW5zdGFuY2UuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ0pTT04gVGhlIEpTT04gb2YgdGhlIGNvbmZpZy5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihjb25maWdKU09OKSB7XG4gICAgICAgIHRoaXMubW9kZWxfdHlwZSA9IG51bGw7XG4gICAgICAgIHRoaXMuaXNfZW5jb2Rlcl9kZWNvZGVyID0gZmFsc2U7XG5cbiAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCBjb25maWdKU09OKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMb2FkcyBhIHByZS10cmFpbmVkIGNvbmZpZyBmcm9tIHRoZSBnaXZlbiBgcHJldHJhaW5lZF9tb2RlbF9uYW1lX29yX3BhdGhgLiBcbiAgICAgKiBcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJldHJhaW5lZF9tb2RlbF9uYW1lX29yX3BhdGggVGhlIHBhdGggdG8gdGhlIHByZS10cmFpbmVkIGNvbmZpZy5cbiAgICAgKiBAcGFyYW0ge1ByZXRyYWluZWRPcHRpb25zfSBvcHRpb25zIEFkZGl0aW9uYWwgb3B0aW9ucyBmb3IgbG9hZGluZyB0aGUgY29uZmlnLlxuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBUaHJvd3MgYW4gZXJyb3IgaWYgdGhlIGNvbmZpZy5qc29uIGlzIG5vdCBmb3VuZCBpbiB0aGUgYHByZXRyYWluZWRfbW9kZWxfbmFtZV9vcl9wYXRoYC5cbiAgICAgKiBcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxQcmV0cmFpbmVkQ29uZmlnPn0gQSBuZXcgaW5zdGFuY2Ugb2YgdGhlIGBQcmV0cmFpbmVkQ29uZmlnYCBjbGFzcy5cbiAgICAgKi9cbiAgICBzdGF0aWMgYXN5bmMgZnJvbV9wcmV0cmFpbmVkKHByZXRyYWluZWRfbW9kZWxfbmFtZV9vcl9wYXRoLCB7XG4gICAgICAgIHByb2dyZXNzX2NhbGxiYWNrID0gbnVsbCxcbiAgICAgICAgY29uZmlnID0gbnVsbCxcbiAgICAgICAgY2FjaGVfZGlyID0gbnVsbCxcbiAgICAgICAgbG9jYWxfZmlsZXNfb25seSA9IGZhbHNlLFxuICAgICAgICByZXZpc2lvbiA9ICdtYWluJyxcbiAgICB9ID0ge30pIHtcblxuICAgICAgICBsZXQgZGF0YSA9IGNvbmZpZyA/PyBhd2FpdCBsb2FkQ29uZmlnKHByZXRyYWluZWRfbW9kZWxfbmFtZV9vcl9wYXRoLCB7XG4gICAgICAgICAgICBwcm9ncmVzc19jYWxsYmFjayxcbiAgICAgICAgICAgIGNvbmZpZyxcbiAgICAgICAgICAgIGNhY2hlX2RpcixcbiAgICAgICAgICAgIGxvY2FsX2ZpbGVzX29ubHksXG4gICAgICAgICAgICByZXZpc2lvbixcbiAgICAgICAgfSlcbiAgICAgICAgcmV0dXJuIG5ldyB0aGlzKGRhdGEpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBIZWxwZXIgY2xhc3Mgd2hpY2ggaXMgdXNlZCB0byBpbnN0YW50aWF0ZSBwcmV0cmFpbmVkIGNvbmZpZ3Mgd2l0aCB0aGUgYGZyb21fcHJldHJhaW5lZGAgZnVuY3Rpb24uXG4gKiBcbiAqIEBleGFtcGxlXG4gKiBsZXQgY29uZmlnID0gYXdhaXQgQXV0b0NvbmZpZy5mcm9tX3ByZXRyYWluZWQoJ2JlcnQtYmFzZS11bmNhc2VkJyk7IFxuICovXG5leHBvcnQgY2xhc3MgQXV0b0NvbmZpZyB7XG4gICAgLyoqIEB0eXBlIHtQcmV0cmFpbmVkQ29uZmlnLmZyb21fcHJldHJhaW5lZH0gKi9cbiAgICBzdGF0aWMgYXN5bmMgZnJvbV9wcmV0cmFpbmVkKC4uLmFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIFByZXRyYWluZWRDb25maWcuZnJvbV9wcmV0cmFpbmVkKC4uLmFyZ3MpO1xuICAgIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@xenova/transformers/src/configs.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@xenova/transformers/src/env.js":
/*!******************************************************!*\
  !*** ./node_modules/@xenova/transformers/src/env.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   env: () => (/* binding */ env)\n/* harmony export */ });\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fs */ \"fs\");\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! path */ \"path\");\n/* harmony import */ var url__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! url */ \"url\");\n/* harmony import */ var _backends_onnx_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./backends/onnx.js */ \"(ssr)/./node_modules/@xenova/transformers/src/backends/onnx.js\");\n/**\n * @file Module used to configure Transformers.js.\n * \n * **Example:** Disable remote models.\n * ```javascript\n * import { env } from '@xenova/transformers';\n * env.allowRemoteModels = false;\n * ```\n * \n * **Example:** Set local model path.\n * ```javascript\n * import { env } from '@xenova/transformers';\n * env.localModelPath = '/path/to/local/models/';\n * ```\n * \n * **Example:** Set cache directory.\n * ```javascript\n * import { env } from '@xenova/transformers';\n * env.cacheDir = '/path/to/cache/directory/';\n * ```\n * \n * @module env\n */\n\n\n\n\n\n\nconst { env: onnx_env } = _backends_onnx_js__WEBPACK_IMPORTED_MODULE_3__.ONNX;\n\nconst VERSION = '2.4.2';\n\n// Check if various APIs are available (depends on environment)\nconst WEB_CACHE_AVAILABLE = typeof self !== 'undefined' && 'caches' in self;\nconst FS_AVAILABLE = !isEmpty(fs__WEBPACK_IMPORTED_MODULE_0__); // check if file system is available\nconst PATH_AVAILABLE = !isEmpty(path__WEBPACK_IMPORTED_MODULE_1__); // check if path is available\n\nconst RUNNING_LOCALLY = FS_AVAILABLE && PATH_AVAILABLE;\n\nconst __dirname = RUNNING_LOCALLY\n    ? path__WEBPACK_IMPORTED_MODULE_1__.dirname(path__WEBPACK_IMPORTED_MODULE_1__.dirname(url__WEBPACK_IMPORTED_MODULE_2__.fileURLToPath(\"file:///Users/jovisaib/code/sides/transformersjs-playground/node_modules/@xenova/transformers/src/env.js\")))\n    : './';\n\n// Only used for environments with access to file system\nconst DEFAULT_CACHE_DIR = RUNNING_LOCALLY\n    ? path__WEBPACK_IMPORTED_MODULE_1__.join(__dirname, '/.cache/')\n    : null;\n\n// Set local model path, based on available APIs\nconst DEFAULT_LOCAL_MODEL_PATH = '/models/';\nconst localModelPath = RUNNING_LOCALLY\n    ? path__WEBPACK_IMPORTED_MODULE_1__.join(__dirname, DEFAULT_LOCAL_MODEL_PATH)\n    : DEFAULT_LOCAL_MODEL_PATH;\n\n// Set path to wasm files. This is needed when running in a web worker.\n// https://onnxruntime.ai/docs/api/js/interfaces/Env.WebAssemblyFlags.html#wasmPaths\n// We use remote wasm files by default to make it easier for newer users.\n// In practice, users should probably self-host the necessary .wasm files.\nonnx_env.wasm.wasmPaths = RUNNING_LOCALLY\n    ? path__WEBPACK_IMPORTED_MODULE_1__.join(__dirname, '/dist/')\n    : `https://cdn.jsdelivr.net/npm/@xenova/transformers@${VERSION}/dist/`;\n\n\n/**\n * Global variable used to control execution. This provides users a simple way to configure Transformers.js.\n * @property {Object} backends Expose environment variables of different backends,\n * allowing users to set these variables if they want to.\n * @property {string} __dirname Directory name of module. Useful for resolving local paths.\n * @property {string} version This version of Transformers.js.\n * @property {boolean} allowRemoteModels Whether to allow loading of remote files, defaults to `true`.\n * If set to `false`, it will have the same effect as setting `local_files_only=true` when loading pipelines, models, tokenizers, processors, etc.\n * @property {string} remoteHost Host URL to load models from. Defaults to the Hugging Face Hub.\n * @property {string} remotePathTemplate Path template to fill in and append to `remoteHost` when loading models.\n * @property {boolean} allowLocalModels Whether to allow loading of local files, defaults to `true`.\n * If set to `false`, it will skip the local file check and try to load the model from the remote host.\n * @property {string} localModelPath Path to load local models from. Defaults to `/models/`.\n * @property {boolean} useFS Whether to use the file system to load files. By default, it is `true` if available.\n * @property {boolean} useBrowserCache Whether to use Cache API to cache models. By default, it is `true` if available.\n * @property {boolean} useFSCache Whether to use the file system to cache files. By default, it is `true` if available.\n * @property {string} cacheDir The directory to use for caching files with the file system. By default, it is `./.cache`.\n*/\nconst env = {\n    /////////////////// Backends settings ///////////////////\n    backends: {\n        // onnxruntime-web/onnxruntime-node\n        onnx: onnx_env,\n\n        // TensorFlow.js\n        tfjs: {},\n    },\n\n    __dirname,\n    version: VERSION,\n\n    /////////////////// Model settings ///////////////////\n    allowRemoteModels: true,\n    remoteHost: 'https://huggingface.co/',\n    remotePathTemplate: '{model}/resolve/{revision}/',\n\n    allowLocalModels: true,\n    localModelPath: localModelPath,\n    useFS: FS_AVAILABLE,\n\n    /////////////////// Cache settings ///////////////////\n    useBrowserCache: WEB_CACHE_AVAILABLE,\n    useFSCache: FS_AVAILABLE,\n    cacheDir: DEFAULT_CACHE_DIR,\n\n    //////////////////////////////////////////////////////\n}\n\n\n/**\n * @param {Object} obj\n * @private\n */\nfunction isEmpty(obj) {\n    return Object.keys(obj).length === 0;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHhlbm92YS90cmFuc2Zvcm1lcnMvc3JjL2Vudi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE1BQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksTUFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRW9CO0FBQ0k7QUFDRjs7QUFFb0I7QUFDMUMsUUFBUSxnQkFBZ0IsRUFBRSxtREFBSTs7QUFFOUI7O0FBRUE7QUFDQTtBQUNBLDhCQUE4QiwrQkFBRSxHQUFHO0FBQ25DLGdDQUFnQyxpQ0FBSSxHQUFHOztBQUV2Qzs7QUFFQTtBQUNBLE1BQU0seUNBQVksQ0FBQyx5Q0FBWSxDQUFDLDhDQUFpQixDQUFDLDBHQUFlO0FBQ2pFOztBQUVBO0FBQ0E7QUFDQSxNQUFNLHNDQUFTO0FBQ2Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTSxzQ0FBUztBQUNmOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLHNDQUFTO0FBQ2YsMkRBQTJELFFBQVE7OztBQUduRTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFNBQVM7QUFDdkI7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsU0FBUztBQUN2QjtBQUNBLGNBQWMsUUFBUTtBQUN0QixjQUFjLFNBQVM7QUFDdkIsY0FBYyxTQUFTO0FBQ3ZCLGNBQWMsU0FBUztBQUN2QixjQUFjLFFBQVE7QUFDdEI7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCO0FBQ2hCLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsTUFBTSxVQUFVLFNBQVM7O0FBRW5EO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdHJhbnNmb3JtZXJzanMtcGxheWdyb3VuZC8uL25vZGVfbW9kdWxlcy9AeGVub3ZhL3RyYW5zZm9ybWVycy9zcmMvZW52LmpzP2NlZTQiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAZmlsZSBNb2R1bGUgdXNlZCB0byBjb25maWd1cmUgVHJhbnNmb3JtZXJzLmpzLlxuICogXG4gKiAqKkV4YW1wbGU6KiogRGlzYWJsZSByZW1vdGUgbW9kZWxzLlxuICogYGBgamF2YXNjcmlwdFxuICogaW1wb3J0IHsgZW52IH0gZnJvbSAnQHhlbm92YS90cmFuc2Zvcm1lcnMnO1xuICogZW52LmFsbG93UmVtb3RlTW9kZWxzID0gZmFsc2U7XG4gKiBgYGBcbiAqIFxuICogKipFeGFtcGxlOioqIFNldCBsb2NhbCBtb2RlbCBwYXRoLlxuICogYGBgamF2YXNjcmlwdFxuICogaW1wb3J0IHsgZW52IH0gZnJvbSAnQHhlbm92YS90cmFuc2Zvcm1lcnMnO1xuICogZW52LmxvY2FsTW9kZWxQYXRoID0gJy9wYXRoL3RvL2xvY2FsL21vZGVscy8nO1xuICogYGBgXG4gKiBcbiAqICoqRXhhbXBsZToqKiBTZXQgY2FjaGUgZGlyZWN0b3J5LlxuICogYGBgamF2YXNjcmlwdFxuICogaW1wb3J0IHsgZW52IH0gZnJvbSAnQHhlbm92YS90cmFuc2Zvcm1lcnMnO1xuICogZW52LmNhY2hlRGlyID0gJy9wYXRoL3RvL2NhY2hlL2RpcmVjdG9yeS8nO1xuICogYGBgXG4gKiBcbiAqIEBtb2R1bGUgZW52XG4gKi9cblxuaW1wb3J0IGZzIGZyb20gJ2ZzJztcbmltcG9ydCBwYXRoIGZyb20gJ3BhdGgnO1xuaW1wb3J0IHVybCBmcm9tICd1cmwnO1xuXG5pbXBvcnQgeyBPTk5YIH0gZnJvbSAnLi9iYWNrZW5kcy9vbm54LmpzJztcbmNvbnN0IHsgZW52OiBvbm54X2VudiB9ID0gT05OWDtcblxuY29uc3QgVkVSU0lPTiA9ICcyLjQuMic7XG5cbi8vIENoZWNrIGlmIHZhcmlvdXMgQVBJcyBhcmUgYXZhaWxhYmxlIChkZXBlbmRzIG9uIGVudmlyb25tZW50KVxuY29uc3QgV0VCX0NBQ0hFX0FWQUlMQUJMRSA9IHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyAmJiAnY2FjaGVzJyBpbiBzZWxmO1xuY29uc3QgRlNfQVZBSUxBQkxFID0gIWlzRW1wdHkoZnMpOyAvLyBjaGVjayBpZiBmaWxlIHN5c3RlbSBpcyBhdmFpbGFibGVcbmNvbnN0IFBBVEhfQVZBSUxBQkxFID0gIWlzRW1wdHkocGF0aCk7IC8vIGNoZWNrIGlmIHBhdGggaXMgYXZhaWxhYmxlXG5cbmNvbnN0IFJVTk5JTkdfTE9DQUxMWSA9IEZTX0FWQUlMQUJMRSAmJiBQQVRIX0FWQUlMQUJMRTtcblxuY29uc3QgX19kaXJuYW1lID0gUlVOTklOR19MT0NBTExZXG4gICAgPyBwYXRoLmRpcm5hbWUocGF0aC5kaXJuYW1lKHVybC5maWxlVVJMVG9QYXRoKGltcG9ydC5tZXRhLnVybCkpKVxuICAgIDogJy4vJztcblxuLy8gT25seSB1c2VkIGZvciBlbnZpcm9ubWVudHMgd2l0aCBhY2Nlc3MgdG8gZmlsZSBzeXN0ZW1cbmNvbnN0IERFRkFVTFRfQ0FDSEVfRElSID0gUlVOTklOR19MT0NBTExZXG4gICAgPyBwYXRoLmpvaW4oX19kaXJuYW1lLCAnLy5jYWNoZS8nKVxuICAgIDogbnVsbDtcblxuLy8gU2V0IGxvY2FsIG1vZGVsIHBhdGgsIGJhc2VkIG9uIGF2YWlsYWJsZSBBUElzXG5jb25zdCBERUZBVUxUX0xPQ0FMX01PREVMX1BBVEggPSAnL21vZGVscy8nO1xuY29uc3QgbG9jYWxNb2RlbFBhdGggPSBSVU5OSU5HX0xPQ0FMTFlcbiAgICA/IHBhdGguam9pbihfX2Rpcm5hbWUsIERFRkFVTFRfTE9DQUxfTU9ERUxfUEFUSClcbiAgICA6IERFRkFVTFRfTE9DQUxfTU9ERUxfUEFUSDtcblxuLy8gU2V0IHBhdGggdG8gd2FzbSBmaWxlcy4gVGhpcyBpcyBuZWVkZWQgd2hlbiBydW5uaW5nIGluIGEgd2ViIHdvcmtlci5cbi8vIGh0dHBzOi8vb25ueHJ1bnRpbWUuYWkvZG9jcy9hcGkvanMvaW50ZXJmYWNlcy9FbnYuV2ViQXNzZW1ibHlGbGFncy5odG1sI3dhc21QYXRoc1xuLy8gV2UgdXNlIHJlbW90ZSB3YXNtIGZpbGVzIGJ5IGRlZmF1bHQgdG8gbWFrZSBpdCBlYXNpZXIgZm9yIG5ld2VyIHVzZXJzLlxuLy8gSW4gcHJhY3RpY2UsIHVzZXJzIHNob3VsZCBwcm9iYWJseSBzZWxmLWhvc3QgdGhlIG5lY2Vzc2FyeSAud2FzbSBmaWxlcy5cbm9ubnhfZW52Lndhc20ud2FzbVBhdGhzID0gUlVOTklOR19MT0NBTExZXG4gICAgPyBwYXRoLmpvaW4oX19kaXJuYW1lLCAnL2Rpc3QvJylcbiAgICA6IGBodHRwczovL2Nkbi5qc2RlbGl2ci5uZXQvbnBtL0B4ZW5vdmEvdHJhbnNmb3JtZXJzQCR7VkVSU0lPTn0vZGlzdC9gO1xuXG5cbi8qKlxuICogR2xvYmFsIHZhcmlhYmxlIHVzZWQgdG8gY29udHJvbCBleGVjdXRpb24uIFRoaXMgcHJvdmlkZXMgdXNlcnMgYSBzaW1wbGUgd2F5IHRvIGNvbmZpZ3VyZSBUcmFuc2Zvcm1lcnMuanMuXG4gKiBAcHJvcGVydHkge09iamVjdH0gYmFja2VuZHMgRXhwb3NlIGVudmlyb25tZW50IHZhcmlhYmxlcyBvZiBkaWZmZXJlbnQgYmFja2VuZHMsXG4gKiBhbGxvd2luZyB1c2VycyB0byBzZXQgdGhlc2UgdmFyaWFibGVzIGlmIHRoZXkgd2FudCB0by5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBfX2Rpcm5hbWUgRGlyZWN0b3J5IG5hbWUgb2YgbW9kdWxlLiBVc2VmdWwgZm9yIHJlc29sdmluZyBsb2NhbCBwYXRocy5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB2ZXJzaW9uIFRoaXMgdmVyc2lvbiBvZiBUcmFuc2Zvcm1lcnMuanMuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGFsbG93UmVtb3RlTW9kZWxzIFdoZXRoZXIgdG8gYWxsb3cgbG9hZGluZyBvZiByZW1vdGUgZmlsZXMsIGRlZmF1bHRzIHRvIGB0cnVlYC5cbiAqIElmIHNldCB0byBgZmFsc2VgLCBpdCB3aWxsIGhhdmUgdGhlIHNhbWUgZWZmZWN0IGFzIHNldHRpbmcgYGxvY2FsX2ZpbGVzX29ubHk9dHJ1ZWAgd2hlbiBsb2FkaW5nIHBpcGVsaW5lcywgbW9kZWxzLCB0b2tlbml6ZXJzLCBwcm9jZXNzb3JzLCBldGMuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gcmVtb3RlSG9zdCBIb3N0IFVSTCB0byBsb2FkIG1vZGVscyBmcm9tLiBEZWZhdWx0cyB0byB0aGUgSHVnZ2luZyBGYWNlIEh1Yi5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSByZW1vdGVQYXRoVGVtcGxhdGUgUGF0aCB0ZW1wbGF0ZSB0byBmaWxsIGluIGFuZCBhcHBlbmQgdG8gYHJlbW90ZUhvc3RgIHdoZW4gbG9hZGluZyBtb2RlbHMuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGFsbG93TG9jYWxNb2RlbHMgV2hldGhlciB0byBhbGxvdyBsb2FkaW5nIG9mIGxvY2FsIGZpbGVzLCBkZWZhdWx0cyB0byBgdHJ1ZWAuXG4gKiBJZiBzZXQgdG8gYGZhbHNlYCwgaXQgd2lsbCBza2lwIHRoZSBsb2NhbCBmaWxlIGNoZWNrIGFuZCB0cnkgdG8gbG9hZCB0aGUgbW9kZWwgZnJvbSB0aGUgcmVtb3RlIGhvc3QuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gbG9jYWxNb2RlbFBhdGggUGF0aCB0byBsb2FkIGxvY2FsIG1vZGVscyBmcm9tLiBEZWZhdWx0cyB0byBgL21vZGVscy9gLlxuICogQHByb3BlcnR5IHtib29sZWFufSB1c2VGUyBXaGV0aGVyIHRvIHVzZSB0aGUgZmlsZSBzeXN0ZW0gdG8gbG9hZCBmaWxlcy4gQnkgZGVmYXVsdCwgaXQgaXMgYHRydWVgIGlmIGF2YWlsYWJsZS5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gdXNlQnJvd3NlckNhY2hlIFdoZXRoZXIgdG8gdXNlIENhY2hlIEFQSSB0byBjYWNoZSBtb2RlbHMuIEJ5IGRlZmF1bHQsIGl0IGlzIGB0cnVlYCBpZiBhdmFpbGFibGUuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IHVzZUZTQ2FjaGUgV2hldGhlciB0byB1c2UgdGhlIGZpbGUgc3lzdGVtIHRvIGNhY2hlIGZpbGVzLiBCeSBkZWZhdWx0LCBpdCBpcyBgdHJ1ZWAgaWYgYXZhaWxhYmxlLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IGNhY2hlRGlyIFRoZSBkaXJlY3RvcnkgdG8gdXNlIGZvciBjYWNoaW5nIGZpbGVzIHdpdGggdGhlIGZpbGUgc3lzdGVtLiBCeSBkZWZhdWx0LCBpdCBpcyBgLi8uY2FjaGVgLlxuKi9cbmV4cG9ydCBjb25zdCBlbnYgPSB7XG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vLyBCYWNrZW5kcyBzZXR0aW5ncyAvLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgYmFja2VuZHM6IHtcbiAgICAgICAgLy8gb25ueHJ1bnRpbWUtd2ViL29ubnhydW50aW1lLW5vZGVcbiAgICAgICAgb25ueDogb25ueF9lbnYsXG5cbiAgICAgICAgLy8gVGVuc29yRmxvdy5qc1xuICAgICAgICB0ZmpzOiB7fSxcbiAgICB9LFxuXG4gICAgX19kaXJuYW1lLFxuICAgIHZlcnNpb246IFZFUlNJT04sXG5cbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vIE1vZGVsIHNldHRpbmdzIC8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICBhbGxvd1JlbW90ZU1vZGVsczogdHJ1ZSxcbiAgICByZW1vdGVIb3N0OiAnaHR0cHM6Ly9odWdnaW5nZmFjZS5jby8nLFxuICAgIHJlbW90ZVBhdGhUZW1wbGF0ZTogJ3ttb2RlbH0vcmVzb2x2ZS97cmV2aXNpb259LycsXG5cbiAgICBhbGxvd0xvY2FsTW9kZWxzOiB0cnVlLFxuICAgIGxvY2FsTW9kZWxQYXRoOiBsb2NhbE1vZGVsUGF0aCxcbiAgICB1c2VGUzogRlNfQVZBSUxBQkxFLFxuXG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vLyBDYWNoZSBzZXR0aW5ncyAvLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgdXNlQnJvd3NlckNhY2hlOiBXRUJfQ0FDSEVfQVZBSUxBQkxFLFxuICAgIHVzZUZTQ2FjaGU6IEZTX0FWQUlMQUJMRSxcbiAgICBjYWNoZURpcjogREVGQVVMVF9DQUNIRV9ESVIsXG5cbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGlzRW1wdHkob2JqKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKG9iaikubGVuZ3RoID09PSAwO1xufVxuXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@xenova/transformers/src/env.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@xenova/transformers/src/models.js":
/*!*********************************************************!*\
  !*** ./node_modules/@xenova/transformers/src/models.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AlbertForMaskedLM: () => (/* binding */ AlbertForMaskedLM),\n/* harmony export */   AlbertForQuestionAnswering: () => (/* binding */ AlbertForQuestionAnswering),\n/* harmony export */   AlbertForSequenceClassification: () => (/* binding */ AlbertForSequenceClassification),\n/* harmony export */   AlbertModel: () => (/* binding */ AlbertModel),\n/* harmony export */   AlbertPreTrainedModel: () => (/* binding */ AlbertPreTrainedModel),\n/* harmony export */   AutoModel: () => (/* binding */ AutoModel),\n/* harmony export */   AutoModelForCausalLM: () => (/* binding */ AutoModelForCausalLM),\n/* harmony export */   AutoModelForImageClassification: () => (/* binding */ AutoModelForImageClassification),\n/* harmony export */   AutoModelForImageSegmentation: () => (/* binding */ AutoModelForImageSegmentation),\n/* harmony export */   AutoModelForMaskGeneration: () => (/* binding */ AutoModelForMaskGeneration),\n/* harmony export */   AutoModelForMaskedLM: () => (/* binding */ AutoModelForMaskedLM),\n/* harmony export */   AutoModelForObjectDetection: () => (/* binding */ AutoModelForObjectDetection),\n/* harmony export */   AutoModelForQuestionAnswering: () => (/* binding */ AutoModelForQuestionAnswering),\n/* harmony export */   AutoModelForSeq2SeqLM: () => (/* binding */ AutoModelForSeq2SeqLM),\n/* harmony export */   AutoModelForSequenceClassification: () => (/* binding */ AutoModelForSequenceClassification),\n/* harmony export */   AutoModelForTokenClassification: () => (/* binding */ AutoModelForTokenClassification),\n/* harmony export */   AutoModelForVision2Seq: () => (/* binding */ AutoModelForVision2Seq),\n/* harmony export */   BartForConditionalGeneration: () => (/* binding */ BartForConditionalGeneration),\n/* harmony export */   BartForSequenceClassification: () => (/* binding */ BartForSequenceClassification),\n/* harmony export */   BartModel: () => (/* binding */ BartModel),\n/* harmony export */   BartPretrainedModel: () => (/* binding */ BartPretrainedModel),\n/* harmony export */   BaseModelOutput: () => (/* binding */ BaseModelOutput),\n/* harmony export */   BertForMaskedLM: () => (/* binding */ BertForMaskedLM),\n/* harmony export */   BertForQuestionAnswering: () => (/* binding */ BertForQuestionAnswering),\n/* harmony export */   BertForSequenceClassification: () => (/* binding */ BertForSequenceClassification),\n/* harmony export */   BertForTokenClassification: () => (/* binding */ BertForTokenClassification),\n/* harmony export */   BertModel: () => (/* binding */ BertModel),\n/* harmony export */   BertPreTrainedModel: () => (/* binding */ BertPreTrainedModel),\n/* harmony export */   CLIPModel: () => (/* binding */ CLIPModel),\n/* harmony export */   CLIPPreTrainedModel: () => (/* binding */ CLIPPreTrainedModel),\n/* harmony export */   CausalLMOutputWithPast: () => (/* binding */ CausalLMOutputWithPast),\n/* harmony export */   CodeGenForCausalLM: () => (/* binding */ CodeGenForCausalLM),\n/* harmony export */   CodeGenModel: () => (/* binding */ CodeGenModel),\n/* harmony export */   CodeGenPreTrainedModel: () => (/* binding */ CodeGenPreTrainedModel),\n/* harmony export */   DetrForObjectDetection: () => (/* binding */ DetrForObjectDetection),\n/* harmony export */   DetrForSegmentation: () => (/* binding */ DetrForSegmentation),\n/* harmony export */   DetrObjectDetectionOutput: () => (/* binding */ DetrObjectDetectionOutput),\n/* harmony export */   DetrPreTrainedModel: () => (/* binding */ DetrPreTrainedModel),\n/* harmony export */   DetrSegmentationOutput: () => (/* binding */ DetrSegmentationOutput),\n/* harmony export */   DistilBertForMaskedLM: () => (/* binding */ DistilBertForMaskedLM),\n/* harmony export */   DistilBertForQuestionAnswering: () => (/* binding */ DistilBertForQuestionAnswering),\n/* harmony export */   DistilBertForSequenceClassification: () => (/* binding */ DistilBertForSequenceClassification),\n/* harmony export */   DistilBertForTokenClassification: () => (/* binding */ DistilBertForTokenClassification),\n/* harmony export */   DistilBertModel: () => (/* binding */ DistilBertModel),\n/* harmony export */   DistilBertPreTrainedModel: () => (/* binding */ DistilBertPreTrainedModel),\n/* harmony export */   GPT2LMHeadModel: () => (/* binding */ GPT2LMHeadModel),\n/* harmony export */   GPT2Model: () => (/* binding */ GPT2Model),\n/* harmony export */   GPT2PreTrainedModel: () => (/* binding */ GPT2PreTrainedModel),\n/* harmony export */   GPTNeoForCausalLM: () => (/* binding */ GPTNeoForCausalLM),\n/* harmony export */   GPTNeoModel: () => (/* binding */ GPTNeoModel),\n/* harmony export */   GPTNeoPreTrainedModel: () => (/* binding */ GPTNeoPreTrainedModel),\n/* harmony export */   M2M100ForConditionalGeneration: () => (/* binding */ M2M100ForConditionalGeneration),\n/* harmony export */   M2M100Model: () => (/* binding */ M2M100Model),\n/* harmony export */   M2M100PreTrainedModel: () => (/* binding */ M2M100PreTrainedModel),\n/* harmony export */   MT5ForConditionalGeneration: () => (/* binding */ MT5ForConditionalGeneration),\n/* harmony export */   MT5Model: () => (/* binding */ MT5Model),\n/* harmony export */   MT5PreTrainedModel: () => (/* binding */ MT5PreTrainedModel),\n/* harmony export */   MarianMTModel: () => (/* binding */ MarianMTModel),\n/* harmony export */   MarianModel: () => (/* binding */ MarianModel),\n/* harmony export */   MarianPreTrainedModel: () => (/* binding */ MarianPreTrainedModel),\n/* harmony export */   MaskedLMOutput: () => (/* binding */ MaskedLMOutput),\n/* harmony export */   MobileBertForMaskedLM: () => (/* binding */ MobileBertForMaskedLM),\n/* harmony export */   MobileBertForQuestionAnswering: () => (/* binding */ MobileBertForQuestionAnswering),\n/* harmony export */   MobileBertForSequenceClassification: () => (/* binding */ MobileBertForSequenceClassification),\n/* harmony export */   MobileBertModel: () => (/* binding */ MobileBertModel),\n/* harmony export */   MobileBertPreTrainedModel: () => (/* binding */ MobileBertPreTrainedModel),\n/* harmony export */   MobileViTForImageClassification: () => (/* binding */ MobileViTForImageClassification),\n/* harmony export */   MobileViTPreTrainedModel: () => (/* binding */ MobileViTPreTrainedModel),\n/* harmony export */   ModelOutput: () => (/* binding */ ModelOutput),\n/* harmony export */   PreTrainedModel: () => (/* binding */ PreTrainedModel),\n/* harmony export */   PretrainedMixin: () => (/* binding */ PretrainedMixin),\n/* harmony export */   QuestionAnsweringModelOutput: () => (/* binding */ QuestionAnsweringModelOutput),\n/* harmony export */   RobertaForMaskedLM: () => (/* binding */ RobertaForMaskedLM),\n/* harmony export */   RobertaForQuestionAnswering: () => (/* binding */ RobertaForQuestionAnswering),\n/* harmony export */   RobertaForSequenceClassification: () => (/* binding */ RobertaForSequenceClassification),\n/* harmony export */   RobertaForTokenClassification: () => (/* binding */ RobertaForTokenClassification),\n/* harmony export */   RobertaModel: () => (/* binding */ RobertaModel),\n/* harmony export */   RobertaPreTrainedModel: () => (/* binding */ RobertaPreTrainedModel),\n/* harmony export */   SamImageSegmentationOutput: () => (/* binding */ SamImageSegmentationOutput),\n/* harmony export */   SamModel: () => (/* binding */ SamModel),\n/* harmony export */   SamPreTrainedModel: () => (/* binding */ SamPreTrainedModel),\n/* harmony export */   Seq2SeqLMOutput: () => (/* binding */ Seq2SeqLMOutput),\n/* harmony export */   SequenceClassifierOutput: () => (/* binding */ SequenceClassifierOutput),\n/* harmony export */   SqueezeBertForMaskedLM: () => (/* binding */ SqueezeBertForMaskedLM),\n/* harmony export */   SqueezeBertForQuestionAnswering: () => (/* binding */ SqueezeBertForQuestionAnswering),\n/* harmony export */   SqueezeBertForSequenceClassification: () => (/* binding */ SqueezeBertForSequenceClassification),\n/* harmony export */   SqueezeBertModel: () => (/* binding */ SqueezeBertModel),\n/* harmony export */   SqueezeBertPreTrainedModel: () => (/* binding */ SqueezeBertPreTrainedModel),\n/* harmony export */   T5ForConditionalGeneration: () => (/* binding */ T5ForConditionalGeneration),\n/* harmony export */   T5Model: () => (/* binding */ T5Model),\n/* harmony export */   T5PreTrainedModel: () => (/* binding */ T5PreTrainedModel),\n/* harmony export */   TokenClassifierOutput: () => (/* binding */ TokenClassifierOutput),\n/* harmony export */   ViTForImageClassification: () => (/* binding */ ViTForImageClassification),\n/* harmony export */   ViTPreTrainedModel: () => (/* binding */ ViTPreTrainedModel),\n/* harmony export */   VisionEncoderDecoderModel: () => (/* binding */ VisionEncoderDecoderModel),\n/* harmony export */   WhisperForConditionalGeneration: () => (/* binding */ WhisperForConditionalGeneration),\n/* harmony export */   WhisperModel: () => (/* binding */ WhisperModel),\n/* harmony export */   WhisperPreTrainedModel: () => (/* binding */ WhisperPreTrainedModel),\n/* harmony export */   XLMRobertaForMaskedLM: () => (/* binding */ XLMRobertaForMaskedLM),\n/* harmony export */   XLMRobertaForQuestionAnswering: () => (/* binding */ XLMRobertaForQuestionAnswering),\n/* harmony export */   XLMRobertaForSequenceClassification: () => (/* binding */ XLMRobertaForSequenceClassification),\n/* harmony export */   XLMRobertaForTokenClassification: () => (/* binding */ XLMRobertaForTokenClassification),\n/* harmony export */   XLMRobertaModel: () => (/* binding */ XLMRobertaModel),\n/* harmony export */   XLMRobertaPreTrainedModel: () => (/* binding */ XLMRobertaPreTrainedModel)\n/* harmony export */ });\n/* harmony import */ var _configs_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./configs.js */ \"(ssr)/./node_modules/@xenova/transformers/src/configs.js\");\n/* harmony import */ var _utils_core_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/core.js */ \"(ssr)/./node_modules/@xenova/transformers/src/utils/core.js\");\n/* harmony import */ var _utils_hub_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/hub.js */ \"(ssr)/./node_modules/@xenova/transformers/src/utils/hub.js\");\n/* harmony import */ var _utils_generation_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/generation.js */ \"(ssr)/./node_modules/@xenova/transformers/src/utils/generation.js\");\n/* harmony import */ var _utils_tensor_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils/tensor.js */ \"(ssr)/./node_modules/@xenova/transformers/src/utils/tensor.js\");\n/* harmony import */ var _backends_onnx_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./backends/onnx.js */ \"(ssr)/./node_modules/@xenova/transformers/src/backends/onnx.js\");\n/* harmony import */ var _transformers_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./transformers.js */ \"(ssr)/./node_modules/@xenova/transformers/src/transformers.js\");\n\n/**\n * @file Definitions of all models available in Transformers.js.\n * \n * **Example:** Load and run an `AutoModel`.\n * \n * ```javascript\n * import { AutoModel, AutoTokenizer } from '@xenova/transformers';\n *\n * let tokenizer = await AutoTokenizer.from_pretrained('Xenova/bert-base-uncased');\n * let model = await AutoModel.from_pretrained('Xenova/bert-base-uncased');\n *\n * let inputs = await tokenizer('I love transformers!');\n * let { logits } = await model(inputs);\n * // Tensor {\n * //     data: Float32Array(183132) [-7.117443084716797, -7.107812881469727, -7.092104911804199, ...]\n * //     dims: (3) [1, 6, 30522],\n * //     type: \"float32\",\n * //     size: 183132,\n * // }\n * ```\n * \n * We also provide other `AutoModel`s (listed below), which you can use in the same way as the Python library. For example:\n * \n * **Example:** Load and run a `AutoModelForSeq2SeqLM`.\n * ```javascript\n * import { AutoModelForSeq2SeqLM, AutoTokenizer } from '@xenova/transformers';\n * \n * let tokenizer = await AutoTokenizer.from_pretrained('Xenova/t5-small');\n * let model = await AutoModelForSeq2SeqLM.from_pretrained('Xenova/t5-small');\n *\n * let { input_ids } = await tokenizer('translate English to German: I love transformers!');\n * let outputs = await model.generate(input_ids);\n * let decoded = tokenizer.decode(outputs[0], { skip_special_tokens: true });\n * // 'Ich liebe Transformatoren!'\n * ```\n * \n * @module models\n */\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst { InferenceSession, Tensor: ONNXTensor } = _backends_onnx_js__WEBPACK_IMPORTED_MODULE_5__.ONNX;\n\n/**\n * @typedef {import('./utils/hub.js').PretrainedOptions} PretrainedOptions\n */\n\n\n//////////////////////////////////////////////////\n// Model types: used internally\nclass ModelType { };\n\n// Either encoder-only or encoder-decoder (and will be decided by `model.config.is_encoder_decoder`)\nclass EncoderOnlyModelType extends ModelType { };\nclass EncoderDecoderModelType extends ModelType { };\nclass Seq2SeqModelType extends EncoderDecoderModelType { };\nclass DecoderOnlyModelType extends ModelType { };\n//////////////////////////////////////////////////\n\n\n//////////////////////////////////////////////////\n// Helper functions\n\n// Will be populated later\nconst MODEL_TYPE_MAPPING = new Map();\nconst MODEL_CLASS_MAPPING = new Map();\n\n/**\n * Helper function to determine which `forward` method to run for a specific model.\n * @param {Object} self The calling object\n * @param {Object} model_inputs The inputs to be sent to the model\n * @returns {Promise<Object>} The model output\n */\nasync function forward(self, model_inputs) {\n    if (MODEL_TYPE_MAPPING.get(self.constructor.name) === DecoderOnlyModelType) {\n        return await decoderForward(self, model_inputs);\n    } else {\n        return await encoderForward(self, model_inputs);\n    }\n}\n\n/**\n * Constructs an InferenceSession using a model file located at the specified path.\n * @param {string} pretrained_model_name_or_path The path to the directory containing the model file.\n * @param {string} fileName The name of the model file.\n * @param {PretrainedOptions} options Additional options for loading the model.\n * @returns {Promise<InferenceSession>} A Promise that resolves to an InferenceSession object.\n * @private\n */\nasync function constructSession(pretrained_model_name_or_path, fileName, options) {\n    // TODO add option for user to force specify their desired execution provider\n    let modelFileName = `onnx/${fileName}${options.quantized ? '_quantized' : ''}.onnx`;\n    let buffer = await (0,_utils_hub_js__WEBPACK_IMPORTED_MODULE_2__.getModelFile)(pretrained_model_name_or_path, modelFileName, true, options);\n\n    try {\n        return await InferenceSession.create(buffer, {\n            executionProviders: _backends_onnx_js__WEBPACK_IMPORTED_MODULE_5__.executionProviders,\n        });\n    } catch (err) {\n        // If the execution provided was only wasm, throw the error\n        if (_backends_onnx_js__WEBPACK_IMPORTED_MODULE_5__.executionProviders.length === 1 && _backends_onnx_js__WEBPACK_IMPORTED_MODULE_5__.executionProviders[0] === 'wasm') {\n            throw err;\n        }\n\n        console.warn(err);\n        console.warn(\n            'Something went wrong during model construction (most likely a missing operation). ' +\n            'Using `wasm` as a fallback. '\n        )\n        return await InferenceSession.create(buffer, {\n            executionProviders: ['wasm']\n        });\n    }\n}\n\n/**\n * Validate model inputs\n * @param {InferenceSession} session The InferenceSession object that will be run.\n * @param {Object} inputs The inputs to check.\n * @returns {Promise<Object>} A Promise that resolves to the checked inputs.\n * @throws {Error} If any inputs are missing.\n * @private\n */\nasync function validateInputs(session, inputs) {\n    // NOTE: Only create a shallow copy\n    const checkedInputs = {};\n    const missingInputs = [];\n    for (let inputName of session.inputNames) {\n        if (inputs[inputName] === undefined) {\n            missingInputs.push(inputName);\n        } else {\n            checkedInputs[inputName] = inputs[inputName];\n        }\n    }\n    if (missingInputs.length > 0) {\n        throw new Error(\n            `An error occurred during model execution: \"Missing the following inputs: ${missingInputs.join(', ')}.`);\n    }\n\n    const numInputsProvided = Object.keys(inputs).length;\n    const numInputsNeeded = session.inputNames.length;\n    if (numInputsProvided > numInputsNeeded) {\n        // No missing inputs, but too many inputs were provided.\n        // Warn the user and ignore the extra inputs.\n        let ignored = Object.keys(inputs).filter(inputName => !session.inputNames.includes(inputName));\n        console.warn(`WARNING: Too many inputs were provided (${numInputsProvided} > ${numInputsNeeded}). The following inputs will be ignored: \"${ignored.join(', ')}\".`);\n    }\n\n    return checkedInputs;\n}\n\n/**\n * Executes an InferenceSession using the specified inputs.\n * NOTE: `inputs` must contain at least the input names of the model.\n *  - If additional inputs are passed, they will be ignored.\n *  - If inputs are missing, an error will be thrown.\n * \n * @param {InferenceSession} session The InferenceSession object to run.\n * @param {Object} inputs An object that maps input names to input tensors.\n * @returns {Promise<Object>} A Promise that resolves to an object that maps output names to output tensors.\n * @private\n */\nasync function sessionRun(session, inputs) {\n    const checkedInputs = await validateInputs(session, inputs);\n    try {\n        let output = await session.run(checkedInputs);\n        output = replaceTensors(output);\n        return output;\n    } catch (e) {\n        // This usually occurs when the inputs are of the wrong type.\n        console.error(`An error occurred during model execution: \"${e}\".`);\n        console.error('Inputs given to model:', checkedInputs);\n        throw e;\n    }\n}\n\n/**\n * Replaces ONNX Tensor objects with custom Tensor objects to support additional functions.\n * @param {Object} obj The object to replace tensor objects in.\n * @returns {Object} The object with tensor objects replaced by custom Tensor objects.\n * @private\n */\nfunction replaceTensors(obj) {\n    for (let prop in obj) {\n        if (obj[prop] instanceof ONNXTensor) {\n            obj[prop] = new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_4__.Tensor(obj[prop]);\n        } else if (typeof obj[prop] === 'object') {\n            replaceTensors(obj[prop]);\n        }\n    }\n    return obj;\n}\n\n\n/**\n * Converts an array or Tensor of integers to an int64 Tensor.\n * @param {Array|Tensor} items The input integers to be converted.\n * @returns {Tensor} The int64 Tensor with the converted values.\n * @throws {Error} If the input array is empty or the input is a batched Tensor and not all sequences have the same length.\n * @private\n */\nfunction toI64Tensor(items) {\n    if (items instanceof _utils_tensor_js__WEBPACK_IMPORTED_MODULE_4__.Tensor) {\n        return items;\n    }\n    // items is an array\n    if (items.length === 0) {\n        throw Error(\"items must be non-empty\");\n    }\n\n    if (Array.isArray(items[0])) {\n        // batched\n        if (items.some(x => x.length !== items[0].length)) {\n            throw Error(\"Unable to create tensor, you should probably activate truncation and/or padding with 'padding=True' and/or 'truncation=True' to have batched tensors with the same length.\")\n        }\n\n        return new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_4__.Tensor('int64',\n            BigInt64Array.from(items.flat().map(x => BigInt(x))),\n            [items.length, items[0].length]\n        );\n    } else {\n        //flat\n        return new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_4__.Tensor('int64',\n            BigInt64Array.from(items.map(x => BigInt(x))),\n            [1, items.length]\n        );\n    }\n}\n\n/**\n * Prepares an attention mask for a sequence of tokens based on configuration options.\n * @param {Object} self The calling object instance.\n * @param {Tensor} tokens The input tokens.\n * @returns {Tensor} The attention mask tensor.\n * @private\n */\nfunction prepareAttentionMask(self, tokens) {\n\n    // Prepare attention mask\n    let pad_token_id = self.config.pad_token_id ?? null;\n    let eos_token_id = self.config.eos_token_id ?? null;\n    if ((0,_utils_core_js__WEBPACK_IMPORTED_MODULE_1__.isIntegralNumber)(eos_token_id)) {\n        eos_token_id = [eos_token_id];\n    }\n\n    let is_pad_token_in_inputs = tokens.indexOf(pad_token_id) !== -1;\n    let is_pad_token_not_equal_to_eos_token_id = (eos_token_id === null) || !eos_token_id.includes(pad_token_id)\n\n    if (is_pad_token_in_inputs && is_pad_token_not_equal_to_eos_token_id) {\n        let data = BigInt64Array.from(\n            // Note: != so that int matches bigint\n            tokens.data.map(x => x != pad_token_id)\n        )\n        return new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_4__.Tensor('int64', data, tokens.dims)\n    } else {\n        return new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_4__.Tensor(\n            'int64',\n            new BigInt64Array(tokens.data.length).fill(1n),\n            tokens.dims\n        )\n    }\n}\n\n/**\n * Creates a boolean tensor with a single value.\n * @param {boolean} value The value of the tensor.\n * @returns {Tensor} The boolean tensor.\n * @private\n */\nfunction boolTensor(value) {\n    return new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_4__.Tensor('bool', [value], [1]);\n}\n\n// JS doesn't support mixins, so we define some reused functions here, and allow \"this\" to be passed in\n/**\n * Perform forward pass on the seq2seq model (both encoder and decoder).\n * @param {Object} self The seq2seq model object.\n * @param {Object} model_inputs The input object for the model containing encoder and decoder inputs.\n * @param {Object} options The options\n * @param {boolean} [options.add_decoder_pkv=true] Flag to add the decoder past key values.\n * @returns {Promise<Seq2SeqLMOutput>} Promise that resolves with the output of the seq2seq model.\n * @private\n */\nasync function seq2seqForward(self, model_inputs, {\n    add_decoder_pkv = true\n} = {}) {\n    let { encoder_outputs, past_key_values } = model_inputs;\n\n    if (!encoder_outputs) {\n        // Encoder outputs are not given, so we must compute them.\n        encoder_outputs = (await encoderForward(self, model_inputs)).last_hidden_state;\n    }\n    let decoderFeeds = {\n        input_ids: model_inputs.decoder_input_ids,\n        encoder_hidden_states: encoder_outputs,\n        use_cache_branch: boolTensor(!!past_key_values)\n    };\n\n    if (self.decoder_merged_session.inputNames.includes('encoder_attention_mask')) {\n        decoderFeeds.encoder_attention_mask = model_inputs.attention_mask\n    }\n    self.addPastKeyValues(decoderFeeds, past_key_values, add_decoder_pkv);\n\n    const decoderResults = await sessionRun(self.decoder_merged_session, decoderFeeds);\n    let logits = decoderResults.logits;\n    past_key_values = self.getPastKeyValues(decoderResults, past_key_values);\n\n    // Get cross attention and/or decoder attentions if they are present\n    const attns = self.getAttentions(decoderResults);\n\n    return new Seq2SeqLMOutput({ logits, past_key_values, encoder_outputs, ...attns });\n}\n\n/**\n * Start the beam search process for the seq2seq model.\n * @param {Object} self The seq2seq model object.\n * @param {Object[]} inputTokenIds Array of input token ids for each input sequence.\n * @param {number} numOutputTokens The maximum number of output tokens for the model.\n * @param {boolean} [requires_attention_mask=true] Flag to indicate if the model requires an attention mask.\n * @returns {Object[]} Array of beam search objects.\n * @private\n */\nfunction seq2seqStartBeams(self, inputTokenIds, numOutputTokens, requires_attention_mask = true) {\n    let beams = [];\n    let beamId = 0;\n\n    // decoder_input_ids == output_token_ids\n    let decoder_input_ids = self.config.decoder_start_token_id;\n    if (!Array.isArray(decoder_input_ids)) {\n        decoder_input_ids = [decoder_input_ids];\n    }\n\n    for (let tokens of inputTokenIds) {\n        // TODO: Improve\n        // Currently, just add back batch dimension.\n        // In future, allow for true parallel execution\n        tokens.dims = [1, ...tokens.dims]\n\n        // Create beam\n        let start = {\n            inputs: tokens,\n            encoder_outputs: null,\n            prev_model_outputs: null,\n\n            output_token_ids: decoder_input_ids,\n            done: false,\n            score: 0,\n            id: beamId++ // assign unique id to beams\n        }\n\n        if (requires_attention_mask) {\n            start.attention_mask = prepareAttentionMask(self, tokens);\n        }\n\n        beams.push(start);\n    }\n\n    return beams;\n}\n\n/**\n * Run beam search on the seq2seq model for a single beam.\n * @param {Object} self The seq2seq model object.\n * @param {Object} beam The beam search object for which to run the model.\n * @param {Object} options options\n * @param {string} [options.input_name='input_ids'] The name of the input tensor for the encoder.\n * @returns {Promise<Object>} Promise that resolves with the output of the seq2seq model for the given beam.\n * @private\n */\nasync function seq2seqRunBeam(self, beam, {\n    input_name = 'input_ids',\n} = {}\n) {\n    // 1. Prepare\n    let model_inputs = {\n        [input_name]: beam.inputs,\n        decoder_input_ids: toI64Tensor(beam.output_token_ids.slice(-1)),\n        encoder_outputs: beam.encoder_outputs,\n        past_key_values: beam.prev_model_outputs?.past_key_values,\n    }\n    if (beam.attention_mask) {\n        model_inputs.attention_mask = beam.attention_mask\n    }\n\n    // 2. Run\n    let output = await self.forward(model_inputs);\n\n    // 3. Update\n    beam.prev_model_outputs = output;\n    beam.encoder_outputs = output.encoder_outputs;\n\n    return output;\n}\n\n/**\n * Forward pass of an encoder model.\n * @param {Object} self The encoder model.\n * @param {Object} model_inputs The input data to be used for the forward pass.\n * @returns {Promise<Object>} Promise that resolves with an object containing the model's outputs.\n * @private\n */\nasync function encoderForward(self, model_inputs) {\n    let encoderFeeds = {};\n    for (let key of self.session.inputNames) {\n        encoderFeeds[key] = model_inputs[key];\n    }\n    return await sessionRun(self.session, encoderFeeds);\n}\n\n\n/**\n * Forward pass of a decoder model.\n * @param {Object} self The decoder model.\n * @param {Object} model_inputs The input data to be used for the forward pass.\n * @returns {Promise<Object>} Promise that resolves with an object containing the logits and past key values.\n * @private\n */\nasync function decoderForward(self, model_inputs) {\n    let { input_ids, past_key_values, attention_mask } = model_inputs;\n    let decoderFeeds = {\n        input_ids: input_ids,\n        attention_mask: attention_mask ?? prepareAttentionMask(self, input_ids),\n        use_cache_branch: boolTensor(past_key_values !== null)\n    }\n\n    self.addPastKeyValues(decoderFeeds, past_key_values);\n\n    let decoderResults = await sessionRun(self.session, decoderFeeds);\n\n    let logits = decoderResults.logits;\n\n    past_key_values = self.getPastKeyValues(decoderResults, past_key_values);\n    return { logits, past_key_values };\n}\n\n/**\n * Starts the generation of text by initializing the beams for the given input token IDs.\n * @param {Object} self The text generation model object.\n * @param {any} inputTokenIds An array of input token IDs to generate text from.\n * @param {number} numOutputTokens The maximum number of tokens to generate for each beam.\n * @param {Tensor} [inputs_attention_mask] The attention mask tensor for the input token IDs.\n * @returns {Object[]} An array of beams initialized with the given inputs and parameters.\n * @private\n */\nfunction decoderStartBeams(self, inputTokenIds, numOutputTokens, inputs_attention_mask) {\n    let beams = [];\n\n    let beamId = 0;\n    for (let tokens of inputTokenIds) {\n        let output_token_ids = tokens.tolist().map(Number);\n\n        // TODO: Improve\n        // Currently, just add back batch dimension.\n        // In future, allow for true parallel execution\n        tokens.dims = [1, ...tokens.dims]\n\n        let attn_mask;\n        if (inputs_attention_mask) {\n            attn_mask = inputs_attention_mask[beamId];\n            attn_mask.dims = [1, ...attn_mask.dims]\n\n        } else {\n            attn_mask = prepareAttentionMask(self, tokens)\n        }\n\n        let start = {\n            input: tokens,\n            model_input_ids: tokens,\n            attention_mask: attn_mask,\n            prev_model_outputs: null,\n\n            output_token_ids: output_token_ids,\n            num_output_tokens: numOutputTokens,\n\n            done: false,\n            score: 0,\n            id: beamId++ // assign unique id to beams\n        }\n\n        beams.push(start);\n    }\n    return beams;\n}\n\n/**\n * Runs a single step of the text generation process for a given beam.\n *\n * @param {Object} self The decoder object.\n * @param {Object} beam The beam to run.\n * @param {Tensor} beam.input The input tensor.\n * @param {Tensor} beam.model_input_ids The input ids to the model.\n * @param {Tensor} beam.attention_mask The attention mask.\n * @param {Object} beam.prev_model_outputs The past key values.\n * @param {number[]} beam.output_token_ids The output token ids.\n * @returns {Promise<Object>} The output of the generation step.\n * @private\n */\nasync function decoderRunBeam(self, beam) {\n    let attnMaskData = new BigInt64Array(beam.output_token_ids.length).fill(1n)\n\n    // 1. Prepare\n    let model_inputs = {\n        input_ids: beam.model_input_ids,\n        attention_mask: new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_4__.Tensor(\n            'int64',\n            attnMaskData,\n            [1, attnMaskData.length]\n        ),\n        past_key_values: beam.prev_model_outputs?.past_key_values,\n    }\n\n    // 2. Run\n    let output = await self.forward(model_inputs);\n\n    // 3. Update\n    beam.prev_model_outputs = output;\n\n    return output;\n}\n\n/**\n * Update a beam with a new token ID.\n * @param {Object} beam The beam to update.\n * @param {number} newTokenId The new token ID to add to the beam's output.\n * @private\n */\nfunction decoderUpdatebeam(beam, newTokenId) {\n    beam.output_token_ids = [...beam.output_token_ids, newTokenId];\n    beam.model_input_ids = new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_4__.Tensor('int64', [BigInt(newTokenId)], [1, 1]);\n}\n//////////////////////////////////////////////////\n\n//////////////////////////////////////////////////\n/**\n * A base class for pre-trained models that provides the model configuration and an ONNX session.\n * @extends Callable\n */\nclass PreTrainedModel extends _utils_core_js__WEBPACK_IMPORTED_MODULE_1__.Callable {\n\n    /**\n     * Creates a new instance of the `PreTrainedModel` class.\n     * @param {Object} config The model configuration.\n     * @param {any} session session for the model.\n     */\n    constructor(config, session) {\n        super();\n\n        this.config = config;\n        this.session = session;\n    }\n\n    /**\n    * Disposes of all the ONNX sessions that were created during inference.\n    * @returns {Promise<unknown[]>} An array of promises, one for each ONNX session that is being disposed.\n    * @todo Use https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/FinalizationRegistry\n    */\n    async dispose() {\n        let promises = [];\n        for (let key of Object.keys(this)) {\n            let item = this[key];\n            if (item instanceof InferenceSession) {\n                promises.push(item.handler.dispose())\n            }\n        }\n        return await Promise.all(promises);\n    }\n\n    /**\n     * Instantiate one of the model classes of the library from a pretrained model.\n     * \n     * The model class to instantiate is selected based on the `model_type` property of the config object\n     * (either passed as an argument or loaded from `pretrained_model_name_or_path` if possible)\n     * \n     * @param {string} pretrained_model_name_or_path The name or path of the pretrained model. Can be either:\n     * - A string, the *model id* of a pretrained model hosted inside a model repo on huggingface.co.\n     *   Valid model ids can be located at the root-level, like `bert-base-uncased`, or namespaced under a\n     *   user or organization name, like `dbmdz/bert-base-german-cased`.\n     * - A path to a *directory* containing model weights, e.g., `./my_model_directory/`.\n     * @param {PretrainedOptions} options Additional options for loading the model.\n     * \n     * @returns {Promise<PreTrainedModel>} A new instance of the `PreTrainedModel` class.\n     */\n    static async from_pretrained(pretrained_model_name_or_path, {\n        quantized = true,\n        progress_callback = null,\n        config = null,\n        cache_dir = null,\n        local_files_only = false,\n        revision = 'main',\n    } = {}) {\n\n        let options = {\n            quantized,\n            progress_callback,\n            config,\n            cache_dir,\n            local_files_only,\n            revision,\n        }\n\n        let modelType = MODEL_TYPE_MAPPING.get(this.name);\n\n        let info;\n        if (modelType === DecoderOnlyModelType) {\n            info = await Promise.all([\n                _configs_js__WEBPACK_IMPORTED_MODULE_0__.AutoConfig.from_pretrained(pretrained_model_name_or_path, options),\n                constructSession(pretrained_model_name_or_path, 'decoder_model_merged', options),\n            ]);\n\n        } else if (modelType === Seq2SeqModelType) {\n            info = await Promise.all([\n                _configs_js__WEBPACK_IMPORTED_MODULE_0__.AutoConfig.from_pretrained(pretrained_model_name_or_path, options),\n                constructSession(pretrained_model_name_or_path, 'encoder_model', options),\n                constructSession(pretrained_model_name_or_path, 'decoder_model_merged', options),\n                (0,_utils_hub_js__WEBPACK_IMPORTED_MODULE_2__.getModelJSON)(pretrained_model_name_or_path, 'generation_config.json', false, options),\n            ]);\n\n        } else if (modelType === EncoderDecoderModelType) {\n            info = await Promise.all([\n                _configs_js__WEBPACK_IMPORTED_MODULE_0__.AutoConfig.from_pretrained(pretrained_model_name_or_path, options),\n                constructSession(pretrained_model_name_or_path, 'encoder_model', options),\n                constructSession(pretrained_model_name_or_path, 'decoder_model_merged', options),\n            ]);\n\n        } else if (modelType === EncoderOnlyModelType) {\n            info = await Promise.all([\n                _configs_js__WEBPACK_IMPORTED_MODULE_0__.AutoConfig.from_pretrained(pretrained_model_name_or_path, options),\n                constructSession(pretrained_model_name_or_path, 'model', options)\n            ]);\n\n        } else {\n            console.warn('Malformed class definition.', this);\n            throw Error(`Unable to load model: ${pretrained_model_name_or_path}. Please report this bug at https://github.com/xenova/transformers.js/issues/new/choose.`);\n        }\n\n        // @ts-ignore\n        return new this(...info);\n    }\n\n    /**\n     * Runs the model with the provided inputs\n     * @param {Object} model_inputs Object containing input tensors\n     * @returns {Promise<Object>} Object containing output tensors\n     */\n    async _call(model_inputs) {\n        return await this.forward(model_inputs);\n    }\n\n    /**\n     * Forward method for a pretrained model. If not overridden by a subclass, the correct forward method\n     * will be chosen based on the model type.\n     * @param {Object} model_inputs The input data to the model in the format specified in the ONNX model.\n     * @returns {Promise<Object>} The output data from the model in the format specified in the ONNX model.\n     * @throws {Error} This method must be implemented in subclasses.\n     */\n    async forward(model_inputs) {\n        return await forward(this, model_inputs);\n    }\n\n    /**\n     * @param {GenerationConfig} generation_config \n     * @param {number} input_ids_seq_length The starting sequence length for the input ids.\n     * @returns {LogitsProcessorList}\n     */\n    _get_logits_processor(\n        generation_config,\n        input_ids_seq_length,\n        // encoder_input_ids, TODO\n        // prefix_allowed_tokens_fn, TODO\n        logits_processor = null\n    ) {\n        const processors = new _utils_generation_js__WEBPACK_IMPORTED_MODULE_3__.LogitsProcessorList();\n\n        // if (generation_config.diversity_penalty !== null && generation_config.diversity_penalty > 0.0) {\n        //     processors.push(new HammingDiversityLogitsProcessor(\n        //         generation_config.diversity_penalty,\n        //         generation_config.num_beams,\n        //         generation_config.num_beam_groups\n        //     ));\n        // }\n\n        // if (generation_config.encoder_repetition_penalty !== null && generation_config.encoder_repetition_penalty !== 1.0) {\n        //     processors.push(new EncoderRepetitionPenaltyLogitsProcessor(\n        //         generation_config.encoder_repetition_penalty,\n        //         encoder_input_ids\n        //     ));\n        // }\n\n        if (generation_config.repetition_penalty !== null && generation_config.repetition_penalty !== 1.0) {\n            processors.push(new _utils_generation_js__WEBPACK_IMPORTED_MODULE_3__.RepetitionPenaltyLogitsProcessor(generation_config.repetition_penalty));\n        }\n\n        if (generation_config.no_repeat_ngram_size !== null && generation_config.no_repeat_ngram_size > 0) {\n            processors.push(new _utils_generation_js__WEBPACK_IMPORTED_MODULE_3__.NoRepeatNGramLogitsProcessor(generation_config.no_repeat_ngram_size));\n        }\n\n        // if (generation_config.encoder_no_repeat_ngram_size !== null && generation_config.encoder_no_repeat_ngram_size > 0) {\n        //     if (this.config.is_encoder_decoder) {\n        //         processors.push(new EncoderNoRepeatNGramLogitsProcessor(\n        //             generation_config.encoder_no_repeat_ngram_size,\n        //             encoder_input_ids\n        //         ));\n        //     } else {\n        //         throw new Error(\"It's impossible to use `encoder_no_repeat_ngram_size` with decoder-only architecture\");\n        //     }\n        // }\n\n        // if (generation_config.bad_words_ids !== null) {\n        //     processors.push(new NoBadWordsLogitsProcessor(generation_config.bad_words_ids, generation_config.eos_token_id));\n        // }\n\n        // if (generation_config.min_length !== null && generation_config.eos_token_id !== null && generation_config.min_length > 0) {\n        //     processors.push(new MinLengthLogitsProcessor(generation_config.min_length, generation_config.eos_token_id));\n        // }\n\n        // if (generation_config.min_new_tokens !== null && generation_config.eos_token_id !== null && generation_config.min_new_tokens > 0) {\n        //     processors.push(new MinNewTokensLengthLogitsProcessor(\n        //         input_ids_seq_length,\n        //         generation_config.min_new_tokens,\n        //         generation_config.eos_token_id\n        //     ));\n        // }\n\n        // if (prefix_allowed_tokens_fn !== null) {\n        //     processors.push(new PrefixConstrainedLogitsProcessor(\n        //         prefix_allowed_tokens_fn,\n        //         generation_config.num_beams / generation_config.num_beam_groups\n        //     ));\n        // }\n\n\n        if (generation_config.forced_bos_token_id !== null) {\n            processors.push(new _utils_generation_js__WEBPACK_IMPORTED_MODULE_3__.ForcedBOSTokenLogitsProcessor(generation_config.forced_bos_token_id));\n        }\n\n        if (generation_config.forced_eos_token_id !== null) {\n            processors.push(new _utils_generation_js__WEBPACK_IMPORTED_MODULE_3__.ForcedEOSTokenLogitsProcessor(\n                generation_config.max_length,\n                generation_config.forced_eos_token_id\n            ));\n        }\n\n        // if (generation_config.remove_invalid_values === true) {\n        //     processors.push(new InfNanRemoveLogitsProcessor());\n        // }\n\n        // if (generation_config.exponential_decay_length_penalty !== null) {\n        //     processors.push(new ExponentialDecayLengthPenalty(\n        //         generation_config.exponential_decay_length_penalty,\n        //         generation_config.eos_token_id,\n        //         input_ids_seq_length\n        //     ));\n        // }\n\n        // if (generation_config.suppress_tokens !== null) {\n        //     processors.push(new SuppressTokensLogitsProcessor(generation_config.suppress_tokens));\n        // }\n\n        if (generation_config.begin_suppress_tokens !== null) {\n            let begin_index = (input_ids_seq_length > 1 || generation_config.forced_bos_token_id === null)\n                ? input_ids_seq_length\n                : input_ids_seq_length + 1;\n\n            if (generation_config.forced_decoder_ids !== null) {\n                // generation starts after the last token that is forced\n                begin_index += generation_config.forced_decoder_ids[generation_config.forced_decoder_ids.length - 1][0];\n            }\n            processors.push(new _utils_generation_js__WEBPACK_IMPORTED_MODULE_3__.SuppressTokensAtBeginLogitsProcessor(generation_config.begin_suppress_tokens, begin_index));\n        }\n\n        if (generation_config.forced_decoder_ids !== null) {\n            processors.push(new _utils_generation_js__WEBPACK_IMPORTED_MODULE_3__.ForceTokensLogitsProcessor(generation_config.forced_decoder_ids));\n        }\n\n        if (logits_processor !== null) {\n            processors.extend(logits_processor)\n        }\n\n        // `LogitNormalization` should always be the last logit processor, when present\n        // if (generation_config.renormalize_logits === true) {\n        //     processors.push(new LogitNormalization());\n        // }\n\n        return processors;\n    }\n\n    /**\n   * This function merges multiple generation configs together to form a final generation config to be used by the model for text generation.\n   * It first creates an empty `GenerationConfig` object, then it applies the model's own `generation_config` property to it. Finally, if a `generation_config` object was passed in the arguments, it overwrites the corresponding properties in the final config with those of the passed config object.\n   *\n   * @param {GenerationConfig} generation_config A `GenerationConfig` object containing generation parameters.\n   * @returns {GenerationConfig} The final generation config object to be used by the model for text generation.\n   */\n    _get_generation_config(generation_config) {\n        // Create empty generation config (contains defaults)\n        let gen_config = new _utils_generation_js__WEBPACK_IMPORTED_MODULE_3__.GenerationConfig();\n\n        // Apply model's generation config, if it exists\n        if ('generation_config' in this) {\n            Object.assign(gen_config, this.generation_config);\n        }\n\n        // Finally, use any generation config specified by the user\n        // when calling `generate`\n        if (generation_config !== null) {\n            Object.assign(gen_config, generation_config);\n        }\n        return gen_config;\n    }\n\n    /**\n     * @typedef {import('./utils/maths.js').TypedArray} TypedArray\n     */\n\n    /**\n     * @typedef {{ sequences: Tensor, decoder_attentions: Tensor, cross_attentions: Tensor }} EncoderDecoderOutput\n     * @typedef {Object} DecoderOutput\n     * \n     * Generates text based on the given inputs and generation configuration using the model.\n     * @param {Tensor|Array|TypedArray} inputs An array of input token IDs.\n     * @param {Object|GenerationConfig|null} generation_config The generation configuration to use. If null, default configuration will be used.\n     * @param {Object|null} logits_processor An optional logits processor to use. If null, a new LogitsProcessorList instance will be created.\n     * @param {Object} options options\n     * @param {Object} [options.inputs_attention_mask=null] An optional attention mask for the inputs.\n     * @returns {Promise<number[][]|EncoderDecoderOutput|DecoderOutput>} An array of generated output sequences, where each sequence is an array of token IDs.\n     * @throws {Error} Throws an error if the inputs array is empty.\n     */\n    async generate(\n        inputs,\n        generation_config = null,\n        logits_processor = null,\n        {\n            inputs_attention_mask = null\n        } = {},\n    ) {\n\n        if (!(inputs instanceof _utils_tensor_js__WEBPACK_IMPORTED_MODULE_4__.Tensor) && !(0,_utils_core_js__WEBPACK_IMPORTED_MODULE_1__.isTypedArray)(inputs) && !Array.isArray(inputs)) {\n            throw Error(`\\`inputs\\` must be a Tensor, TypedArray, or Array, but is \"${inputs.constructor.name}\".`);\n        }\n\n        let input_ids_seq_length;\n\n        // Prepare `input_ids` which will be used for auto-regressive generation\n        // TODO: Update to align with HF transformers' implementation\n        if (this.config.is_encoder_decoder) {\n            // Generating from the encoder outputs\n            input_ids_seq_length = 0;\n\n        } else {\n            input_ids_seq_length = inputs instanceof _utils_tensor_js__WEBPACK_IMPORTED_MODULE_4__.Tensor ? inputs.dims[0] : inputs.length;\n\n            // decoder-only\n            if (input_ids_seq_length === 0) {\n                throw Error(\"Must supply a non-empty array of input token ids.\")\n            }\n        }\n\n        // Update generation config with defaults\n        generation_config = this._get_generation_config(generation_config);\n\n        logits_processor = logits_processor ?? new _utils_generation_js__WEBPACK_IMPORTED_MODULE_3__.LogitsProcessorList()\n\n        // Update logits processor\n        logits_processor = this._get_logits_processor(\n            generation_config,\n            input_ids_seq_length,\n            logits_processor\n        )\n\n        // TODO implement early_stopping\n        // https://huggingface.co/blog/how-to-generate\n\n        let numOutputTokens = 1;\n        const maxOutputTokens = numOutputTokens + (generation_config.max_new_tokens ?? Infinity);\n\n        // Only use max length if max_new_tokens is not provided\n        const useMaxLength = Number.isInteger(generation_config.max_length) && (generation_config.max_new_tokens ?? null) === null;\n        let sampler = _utils_generation_js__WEBPACK_IMPORTED_MODULE_3__.Sampler.getSampler(generation_config);\n\n        // @ts-ignore\n        let beams = this.getStartBeams(inputs, numOutputTokens, inputs_attention_mask);\n\n        while (beams.some(x => !x.done) && numOutputTokens < maxOutputTokens) {\n            let newest_beams = [];\n            for (let beam of beams) {\n                if (beam.done) {\n                    // Add this beam back into the pool\n                    newest_beams.push(beam);\n                    continue\n                }\n                if (useMaxLength && beam.output_token_ids.length >= generation_config.max_length) {\n                    // Set this beam to done and add it back into the pool\n                    beam.done = true;\n                    newest_beams.push(beam);\n                    continue\n                }\n\n                // @ts-ignore\n                let output = await this.runBeam(beam);\n\n                // add attentions/scores to beam only if user requested\n                if (generation_config.output_attentions) {\n                    this.addAttentionsToBeam(beam, output);\n                }\n                if (generation_config.output_scores) {\n                    // TODO add\n                }\n\n                // Logits are of the form [batch_size, out_seq_length, vocab_size]\n                // In most cases, this will be [batch_size, 1, vocab_size]\n                // So, we select the last token's logits:\n                // (equivalent to `logits = outputs.logits[:, -1, :]`)\n                let logits = output.logits.slice(null, -1, null);\n\n                // Apply logits processor\n                logits_processor(beam.output_token_ids, logits);\n\n                let sampledTokens = sampler(logits);\n                for (let [newTokenId, logProb] of sampledTokens) {\n                    // use previous beam as a starting point\n                    let newBeam = { ...beam };\n\n                    // update new beam\n                    // @ts-ignore\n                    this.updateBeam(newBeam, newTokenId);\n\n                    newBeam.score += logProb;\n\n                    if (newTokenId === this.config.eos_token_id) {\n                        newBeam.done = true;\n                    }\n\n                    newest_beams.push(newBeam);\n                }\n            }\n            ++numOutputTokens;\n\n            // Next, we get the best beams, per ID\n            newest_beams = this.groupBeams(newest_beams).map(\n                group => group\n                    .sort((a, b) => b.score - a.score)      // sort by score\n                    .slice(0, generation_config.num_beams)  // remove outside beam width\n            );\n\n            // Flatten beams\n            beams = newest_beams.flat();\n\n            // Run callback\n            if (generation_config.callback_function) {\n                generation_config.callback_function(beams);\n            }\n        }\n\n        // TODO: Ensure that we can return non-batched outputs\n\n        const groupedBeams = this.groupBeams(beams);\n\n        const getFlattened = (key) => groupedBeams.map(\n            batch => {\n                if (generation_config.num_return_sequences > 1) {\n                    return batch.slice(0, generation_config.num_return_sequences).map(x => x[key]);\n                } else {\n                    return [batch[0][key]];\n                }\n            }\n        ).flat(); // Flatten across batches (depth=1)\n\n        const sequences = getFlattened('output_token_ids'); // [1, seqLength]\n\n        if (generation_config.return_dict_in_generate) {\n            // NOTE: `decoder_attentions` and `cross_attentions` should be:\n            //    list (one element for each generated token)\n            //    of list (one element for each layer of the decoder)\n            //    of torch.FloatTensor of shape (batch_size, num_heads, generated_length, sequence_length)\n            // However, since we are only generating one batch at a time, they are of the form:\n            //   list (batches)\n            //   of list (one element for each generated token)\n            //   of list (one element for each layer of the decoder)\n            //   of torch.FloatTensor of shape (1, num_heads, generated_length, sequence_length)\n            // \n            // TODO: In future (when true parallelism, we should be able to return the correct shape)\n\n            const decoder_attentions = getFlattened('decoder_attentions');\n            const cross_attentions = getFlattened('cross_attentions');\n\n            return {\n                sequences,\n\n                decoder_attentions,\n                cross_attentions,\n            }\n        } else {\n            return sequences;\n        }\n    }\n\n    /**\n     * Helper function to add attentions to beam\n     * @param {Object} beam \n     * @param {Object} output\n     * @private \n     */\n    addAttentionsToBeam(beam, output) {\n        if (this.config.is_encoder_decoder) {\n            if (!output.cross_attentions || output.cross_attentions.length === 0) {\n                throw Error(\n                    \"`output_attentions` is true, but the model did not produce cross-attentions. \" +\n                    \"This is most likely because the model was not exported with `output_attentions=True`.\"\n                )\n            }\n            if (!beam.cross_attentions) {\n                beam.cross_attentions = [];\n            }\n            beam.cross_attentions.push(output.cross_attentions);\n        }\n\n        if (!output.decoder_attentions || output.decoder_attentions.length === 0) {\n            throw Error(\n                \"`output_attentions` is true, but the model did not produce decoder-attentions. \" +\n                \"This is most likely because the model was not exported with `output_attentions=True`.\"\n            )\n        }\n        if (!beam.decoder_attentions) {\n            beam.decoder_attentions = [];\n        }\n        beam.decoder_attentions.push(output.decoder_attentions);\n    }\n\n    /**\n     * Groups an array of beam objects by their ids.\n     *\n     * @param {Array} beams The array of beam objects to group.\n     * @returns {Array} An array of arrays, where each inner array contains beam objects with the same id.\n     */\n    groupBeams(beams) {\n        // Group beams by their ids\n        const groups = Object.create(null);\n        for (const obj of beams) {\n            if (groups[obj.id] === undefined) {\n                groups[obj.id] = [obj];\n            } else {\n                groups[obj.id].push(obj);\n            }\n        }\n\n        return Object.values(groups);\n    }\n\n    /**\n     * Returns an object containing past key values from the given decoder results object.\n     *\n     * @param {Object} decoderResults The decoder results object.\n     * @param {Object} pastKeyValues The previous past key values.\n     * @returns {Object} An object containing past key values.\n     * @private\n     */\n    getPastKeyValues(decoderResults, pastKeyValues) {\n\n        const pkvs = Object.create(null);\n\n        for (const name in decoderResults) {\n            if (name.startsWith('present')) {\n                let newName = name.replace('present', 'past_key_values');\n\n                if (pastKeyValues && name.includes('encoder')) {\n                    // Optimization introduced by optimum to reuse past key values. So, we just replace the constant\n                    // outputs with the previous past key values.\n                    // https://github.com/huggingface/optimum/blob/0bf2c05fb7e1182b52d21b703cfc95fd9e4ea3dc/optimum/onnxruntime/base.py#L677-L704\n                    pkvs[newName] = pastKeyValues[newName];\n                } else {\n                    pkvs[newName] = decoderResults[name];\n                }\n            }\n        }\n        return pkvs;\n    }\n\n    /**\n     * Returns an object containing attentions from the given decoder results object.\n     *\n     * @param {Object} decoderResults The decoder results object.\n     * @returns {Object} An object containing attentions.\n     * @private\n     */\n    getAttentions(decoderResults) {\n        const attns = Object.create(null);\n\n        for (const attnName of ['cross_attentions', 'decoder_attentions']) {\n            const result = [];\n            for (const name in decoderResults) {\n                if (name.startsWith(attnName)) {\n                    const index = name.split('.').pop()\n                    result[index] = decoderResults[name];\n                }\n            }\n            attns[attnName] = result;\n        }\n        return attns;\n    }\n\n    /**\n     * Adds past key values to the decoder feeds object. If pastKeyValues is null, creates new tensors for past key values.\n     *\n     * @param {Object} decoderFeeds The decoder feeds object to add past key values to.\n     * @param {Object} pastKeyValues An object containing past key values.\n     * @param {boolean} [hasDecoder=false] Whether the model has a decoder.\n     */\n    addPastKeyValues(decoderFeeds, pastKeyValues, hasDecoder = false) {\n        if (pastKeyValues) {\n            Object.assign(decoderFeeds, pastKeyValues)\n        } else {\n            // TODO support batches (i.e., batch_size > 1)\n            if (hasDecoder) {\n                // @ts-ignore\n                let encoder_dims = [1, this.num_encoder_heads, 0, this.encoder_dim_kv];\n                // @ts-ignore\n                for (let i = 0; i < this.num_encoder_layers; ++i) {\n                    decoderFeeds[`past_key_values.${i}.encoder.key`] = new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_4__.Tensor('float32', [], encoder_dims)\n                    decoderFeeds[`past_key_values.${i}.encoder.value`] = new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_4__.Tensor('float32', [], encoder_dims)\n                }\n\n                // @ts-ignore\n                let decoder_dims = [1, this.num_decoder_heads, 0, this.decoder_dim_kv];\n                // @ts-ignore\n                for (let i = 0; i < this.num_decoder_layers; ++i) {\n                    decoderFeeds[`past_key_values.${i}.decoder.key`] = new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_4__.Tensor('float32', [], decoder_dims)\n                    decoderFeeds[`past_key_values.${i}.decoder.value`] = new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_4__.Tensor('float32', [], decoder_dims)\n                }\n\n            } else {\n                // @ts-ignore\n                let dims = [1, this.num_heads, 0, this.dim_kv]\n                // @ts-ignore\n                for (let i = 0; i < this.num_layers; ++i) {\n                    decoderFeeds[`past_key_values.${i}.key`] = new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_4__.Tensor('float32', [], dims)\n                    decoderFeeds[`past_key_values.${i}.value`] = new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_4__.Tensor('float32', [], dims)\n                }\n            }\n        }\n    }\n}\n//////////////////////////////////////////////////\n// Base model output class\nclass ModelOutput { }\n\n/**\n * Base class for model's outputs, with potential hidden states and attentions.\n */\nclass BaseModelOutput extends ModelOutput {\n    /**\n     * @param {Object} output The output of the model.\n     * @param {Tensor} output.last_hidden_state Sequence of hidden-states at the output of the last layer of the model.\n     * @param {Tensor} [output.hidden_states] Hidden-states of the model at the output of each layer plus the optional initial embedding outputs.\n     * @param {Tensor} [output.attentions] Attentions weights after the attention softmax, used to compute the weighted average in the self-attention heads.\n     */\n    constructor({ last_hidden_state, hidden_states = null, attentions = null }) {\n        super();\n        this.last_hidden_state = last_hidden_state;\n        this.hidden_states = hidden_states;\n        this.attentions = attentions;\n    }\n}\n//////////////////////////////////////////////////\n// Bert models\nclass BertPreTrainedModel extends PreTrainedModel { }\nclass BertModel extends BertPreTrainedModel { }\n\n/**\n * BertForMaskedLM is a class representing a BERT model for masked language modeling.\n * @extends BertPreTrainedModel\n */\nclass BertForMaskedLM extends BertPreTrainedModel {\n    /**\n     * Calls the model on new inputs.\n     *\n     * @param {Object} model_inputs The inputs to the model.\n     * @returns {Promise<MaskedLMOutput>} An object containing the model's output logits for masked language modeling.\n     */\n    async _call(model_inputs) {\n        return new MaskedLMOutput(await super._call(model_inputs));\n    }\n}\n\n/**\n * BertForSequenceClassification is a class representing a BERT model for sequence classification.\n * @extends BertPreTrainedModel\n */\nclass BertForSequenceClassification extends BertPreTrainedModel {\n    /**\n     * Calls the model on new inputs.\n     *\n     * @param {Object} model_inputs The inputs to the model.\n     * @returns {Promise<SequenceClassifierOutput>} An object containing the model's output logits for sequence classification.\n     */\n    async _call(model_inputs) {\n        return new SequenceClassifierOutput(await super._call(model_inputs));\n    }\n}\n\n/**\n * BertForTokenClassification is a class representing a BERT model for token classification.\n * @extends BertPreTrainedModel\n */\nclass BertForTokenClassification extends BertPreTrainedModel {\n    /**\n     * Calls the model on new inputs.\n     *\n     * @param {Object} model_inputs The inputs to the model.\n     * @returns {Promise<TokenClassifierOutput>} An object containing the model's output logits for token classification.\n     */\n    async _call(model_inputs) {\n        return new TokenClassifierOutput(await super._call(model_inputs));\n    }\n}\n\n/**\n * BertForQuestionAnswering is a class representing a BERT model for question answering.\n * @extends BertPreTrainedModel\n */\nclass BertForQuestionAnswering extends BertPreTrainedModel {\n    /**\n     * Calls the model on new inputs.\n     *\n     * @param {Object} model_inputs The inputs to the model.\n     * @returns {Promise<QuestionAnsweringModelOutput>} An object containing the model's output logits for question answering.\n     */\n    async _call(model_inputs) {\n        return new QuestionAnsweringModelOutput(await super._call(model_inputs));\n    }\n}\n//////////////////////////////////////////////////\n\n//////////////////////////////////////////////////\n// DistilBert models\nclass DistilBertPreTrainedModel extends PreTrainedModel { }\nclass DistilBertModel extends DistilBertPreTrainedModel { }\n\n/**\n * DistilBertForSequenceClassification is a class representing a DistilBERT model for sequence classification.\n * @extends DistilBertPreTrainedModel\n */\nclass DistilBertForSequenceClassification extends DistilBertPreTrainedModel {\n    /**\n     * Calls the model on new inputs.\n     *\n     * @param {Object} model_inputs The inputs to the model.\n     * @returns {Promise<SequenceClassifierOutput>} An object containing the model's output logits for sequence classification.\n     */\n    async _call(model_inputs) {\n        return new SequenceClassifierOutput(await super._call(model_inputs));\n    }\n}\n\n/**\n * DistilBertForTokenClassification is a class representing a DistilBERT model for token classification.\n * @extends DistilBertPreTrainedModel\n */\nclass DistilBertForTokenClassification extends DistilBertPreTrainedModel {\n    /**\n     * Calls the model on new inputs.\n     *\n     * @param {Object} model_inputs The inputs to the model.\n     * @returns {Promise<TokenClassifierOutput>} An object containing the model's output logits for token classification.\n     */\n    async _call(model_inputs) {\n        return new TokenClassifierOutput(await super._call(model_inputs));\n    }\n}\n\n\n/**\n * DistilBertForQuestionAnswering is a class representing a DistilBERT model for question answering.\n * @extends DistilBertPreTrainedModel\n */\nclass DistilBertForQuestionAnswering extends DistilBertPreTrainedModel {\n    /**\n     * Calls the model on new inputs.\n     *\n     * @param {Object} model_inputs The inputs to the model.\n     * @returns {Promise<QuestionAnsweringModelOutput>} An object containing the model's output logits for question answering.\n     */\n    async _call(model_inputs) {\n        return new QuestionAnsweringModelOutput(await super._call(model_inputs));\n    }\n}\n\n/**\n * DistilBertForMaskedLM is a class representing a DistilBERT model for masking task.\n * @extends DistilBertPreTrainedModel\n */\nclass DistilBertForMaskedLM extends DistilBertPreTrainedModel {\n    /**\n     * Calls the model on new inputs.\n     *\n     * @param {Object} model_inputs The inputs to the model.\n     * @returns {Promise<MaskedLMOutput>} returned object\n     */\n    async _call(model_inputs) {\n        return new MaskedLMOutput(await super._call(model_inputs));\n    }\n}\n//////////////////////////////////////////////////\n\n\n//////////////////////////////////////////////////\n// MobileBert models\nclass MobileBertPreTrainedModel extends PreTrainedModel { }\nclass MobileBertModel extends MobileBertPreTrainedModel { }\n\n/**\n * MobileBertForMaskedLM is a class representing a MobileBERT model for masking task.\n * @extends MobileBertPreTrainedModel\n */\nclass MobileBertForMaskedLM extends MobileBertPreTrainedModel {\n    /**\n     * Calls the model on new inputs.\n     *\n     * @param {Object} model_inputs The inputs to the model.\n     * @returns {Promise<MaskedLMOutput>} returned object\n     */\n    async _call(model_inputs) {\n        return new MaskedLMOutput(await super._call(model_inputs));\n    }\n}\n\n/**\n * @extends MobileBertPreTrainedModel\n */\nclass MobileBertForSequenceClassification extends MobileBertPreTrainedModel {\n    /**\n     * Calls the model on new inputs.\n     *\n     * @param {Object} model_inputs The inputs to the model.\n     * @returns {Promise<SequenceClassifierOutput>} returned object\n     */\n    async _call(model_inputs) {\n        return new SequenceClassifierOutput(await super._call(model_inputs));\n    }\n}\n\n/**\n * @extends MobileBertPreTrainedModel\n */\nclass MobileBertForQuestionAnswering extends MobileBertPreTrainedModel {\n    /**\n     * Calls the model on new inputs.\n     *\n     * @param {Object} model_inputs The inputs to the model.\n     * @returns {Promise<QuestionAnsweringModelOutput>} returned object\n     */\n    async _call(model_inputs) {\n        return new QuestionAnsweringModelOutput(await super._call(model_inputs));\n    }\n}\n//////////////////////////////////////////////////\n\n\n//////////////////////////////////////////////////\n// SqueezeBert models\nclass SqueezeBertPreTrainedModel extends PreTrainedModel { }\nclass SqueezeBertModel extends SqueezeBertPreTrainedModel { }\nclass SqueezeBertForMaskedLM extends SqueezeBertPreTrainedModel {\n    /**\n     * Calls the model on new inputs.\n     *\n     * @param {Object} model_inputs The inputs to the model.\n     * @returns {Promise<MaskedLMOutput>} returned object\n     */\n    async _call(model_inputs) {\n        return new MaskedLMOutput(await super._call(model_inputs));\n    }\n}\nclass SqueezeBertForSequenceClassification extends SqueezeBertPreTrainedModel {\n    /**\n     * Calls the model on new inputs.\n     *\n     * @param {Object} model_inputs The inputs to the model.\n     * @returns {Promise<SequenceClassifierOutput>} returned object\n     */\n    async _call(model_inputs) {\n        return new SequenceClassifierOutput(await super._call(model_inputs));\n    }\n}\nclass SqueezeBertForQuestionAnswering extends SqueezeBertPreTrainedModel {\n    /**\n     * Calls the model on new inputs.\n     *\n     * @param {Object} model_inputs The inputs to the model.\n     * @returns {Promise<QuestionAnsweringModelOutput>} returned object\n     */\n    async _call(model_inputs) {\n        return new QuestionAnsweringModelOutput(await super._call(model_inputs));\n    }\n}\n//////////////////////////////////////////////////\n\n\n//////////////////////////////////////////////////\n// Albert models\nclass AlbertPreTrainedModel extends PreTrainedModel { }\nclass AlbertModel extends AlbertPreTrainedModel { }\nclass AlbertForSequenceClassification extends AlbertPreTrainedModel {\n    /**\n     * Calls the model on new inputs.\n     *\n     * @param {Object} model_inputs The inputs to the model.\n     * @returns {Promise<SequenceClassifierOutput>} returned object\n     */\n    async _call(model_inputs) {\n        return new SequenceClassifierOutput(await super._call(model_inputs));\n    }\n}\nclass AlbertForQuestionAnswering extends AlbertPreTrainedModel {\n    /**\n     * Calls the model on new inputs.\n     *\n     * @param {Object} model_inputs The inputs to the model.\n     * @returns {Promise<QuestionAnsweringModelOutput>} returned object\n     */\n    async _call(model_inputs) {\n        return new QuestionAnsweringModelOutput(await super._call(model_inputs));\n    }\n}\nclass AlbertForMaskedLM extends AlbertPreTrainedModel {\n    /**\n     * Calls the model on new inputs.\n     *\n     * @param {Object} model_inputs The inputs to the model.\n     * @returns {Promise<MaskedLMOutput>} returned object\n     */\n    async _call(model_inputs) {\n        return new MaskedLMOutput(await super._call(model_inputs));\n    }\n}\n//////////////////////////////////////////////////\n\n\n//////////////////////////////////////////////////\n// T5 models\nclass T5PreTrainedModel extends PreTrainedModel { };\n\nclass T5Model extends T5PreTrainedModel {\n    /**\n     * Generates text based on the provided arguments.\n     * @throws {Error} Throws an error as the current model class (T5Model) is not compatible with `.generate()`.\n     * @returns {Promise<any>}\n     * @param {any[]} args\n     */\n    async generate(...args) {\n        throw Error(\n            \"The current model class (T5Model) is not compatible with `.generate()`, as it doesn't have a language model head. Please use one of the following classes instead: {'T5ForConditionalGeneration'}\"\n        )\n    }\n}\n\n/**\n * T5Model is a class representing a T5 model for conditional generation.\n * @extends T5PreTrainedModel\n */\nclass T5ForConditionalGeneration extends T5PreTrainedModel {\n\n    /**\n     * Creates a new instance of the `T5ForConditionalGeneration` class.\n     * @param {Object} config The model configuration.\n     * @param {any} session session for the model.\n     * @param {any} decoder_merged_session session for the decoder.\n     * @param {GenerationConfig} generation_config The generation configuration.\n     */\n    constructor(config, session, decoder_merged_session, generation_config) {\n        super(config, session);\n        this.decoder_merged_session = decoder_merged_session;\n        this.generation_config = generation_config;\n\n        this.num_decoder_layers = this.config.num_decoder_layers;\n        this.num_decoder_heads = this.config.num_heads;\n        this.decoder_dim_kv = this.config.d_kv;\n\n        this.num_encoder_layers = this.config.num_layers;\n        this.num_encoder_heads = this.config.num_heads;\n        this.encoder_dim_kv = this.config.d_kv;\n    }\n\n    /**\n     * Generates the start beams for a given set of inputs and output length.\n     * @param {number[][]} inputs The input token IDs.\n     * @param {number} numOutputTokens The desired output length.\n     * @returns {Array} The start beams.\n     */\n    getStartBeams(inputs, numOutputTokens, ...args) {\n        return seq2seqStartBeams(this, inputs, numOutputTokens);\n    }\n\n    /**\n     * Runs a single step of the beam search generation algorithm.\n     * @param {any} beam The current beam being generated.\n     * @returns {Promise<any>} The updated beam after a single generation step.\n     */\n    async runBeam(beam) {\n        return await seq2seqRunBeam(this, beam);\n    }\n\n    /**\n     * Updates the given beam with a new token ID.\n     * @param {any} beam The current beam.\n     * @param {number} newTokenId The new token ID to add to the output sequence.\n     */\n    updateBeam(beam, newTokenId) {\n        beam.output_token_ids = [...beam.output_token_ids, newTokenId];\n    }\n\n    /**\n     * Runs the forward pass of the model for a given set of inputs.\n     * @param {Object} model_inputs The model inputs.\n     * @returns {Promise<Object>} The model output.\n     */\n    async forward(model_inputs) {\n        return await seq2seqForward(this, model_inputs);\n    }\n}\n//////////////////////////////////////////////////\n\n//////////////////////////////////////////////////\n// MT5 models\nclass MT5PreTrainedModel extends PreTrainedModel { };\n\nclass MT5Model extends MT5PreTrainedModel {\n    /**\n     * \n     * @param  {...any} args\n     * @returns {Promise<any>}\n     * @throws {Error}\n     */\n    async generate(...args) {\n        throw Error(\n            \"The current model class (MT5Model) is not compatible with `.generate()`, as it doesn't have a language model head. Please use one of the following classes instead: {'MT5ForConditionalGeneration'}\"\n        )\n    }\n}\n\n/**\n * A class representing a conditional sequence-to-sequence model based on the MT5 architecture.\n *\n * @extends MT5PreTrainedModel\n */\nclass MT5ForConditionalGeneration extends MT5PreTrainedModel {\n\n    /**\n     * Creates a new instance of the `MT5ForConditionalGeneration` class.\n     * @param {any} config The model configuration.\n     * @param {any} session The ONNX session containing the encoder weights.\n     * @param {any} decoder_merged_session The ONNX session containing the merged decoder weights.\n     * @param {GenerationConfig} generation_config The generation configuration.\n     */\n    constructor(config, session, decoder_merged_session, generation_config) {\n        super(config, session);\n        this.decoder_merged_session = decoder_merged_session;\n        this.generation_config = generation_config;\n\n        this.num_decoder_layers = this.config.num_decoder_layers;\n        this.num_decoder_heads = this.config.num_heads;\n        this.decoder_dim_kv = this.config.d_kv;\n\n        this.num_encoder_layers = this.config.num_layers;\n        this.num_encoder_heads = this.config.num_heads;\n        this.encoder_dim_kv = this.config.d_kv;\n    }\n\n    /**\n   * Generates the start beams for the given input tokens and output sequence length.\n   *\n   * @param {any[]} inputs The input sequence.\n   * @param {number} numOutputTokens The desired length of the output sequence.\n   * @param {...*} args Additional arguments to pass to the `seq2seqStartBeams` function.\n   * @returns {any[]} An array of `Beam` objects representing the start beams.\n   */\n    getStartBeams(inputs, numOutputTokens, ...args) {\n        return seq2seqStartBeams(this, inputs, numOutputTokens);\n    }\n\n    /**\n     * Runs a single step of the beam search generation algorithm.\n     * @param {any} beam The current beam being generated.\n     * @returns {Promise<any>} The updated beam after a single generation step.\n     */\n    async runBeam(beam) {\n        return await seq2seqRunBeam(this, beam);\n    }\n\n    /**\n     * Updates the given beam with the new predicted token.\n     * @param {any} beam The beam to update.\n     * @param {number} newTokenId The index of the predicted token.\n    */\n    updateBeam(beam, newTokenId) {\n        beam.output_token_ids = [...beam.output_token_ids, newTokenId];\n    }\n\n    /**\n    * Runs the forward pass of the model on the given inputs.\n    * @param {any} model_inputs The model inputs.\n    * @returns {Promise<any>} A Promise that resolves to the model outputs.\n    */\n    async forward(model_inputs) {\n        return await seq2seqForward(this, model_inputs);\n    }\n}\n//////////////////////////////////////////////////\n\n//////////////////////////////////////////////////\n// Bart models\nclass BartPretrainedModel extends PreTrainedModel { };\n\n/**\n * BART encoder and decoder model.\n * \n * @hideconstructor\n * @extends BartPretrainedModel\n */\nclass BartModel extends BartPretrainedModel {\n    /**\n     * Throws an error because the current model class (BartModel) is not compatible with `.generate()`.\n     * \n     * @throws {Error} The current model class (BartModel) is not compatible with `.generate()`.\n     * @returns {Promise<any>}\n     */\n    async generate(...args) {\n        throw Error(\n            \"The current model class (BartModel) is not compatible with `.generate()`, as it doesn't have a language model head. Please use one of the following classes instead: {'BartForConditionalGeneration'}\"\n        )\n    }\n}\n\n/**\n * BART model with a language model head for conditional generation.\n * @extends BartPretrainedModel\n */\nclass BartForConditionalGeneration extends BartPretrainedModel {\n\n    /**\n     * Creates a new instance of the `BartForConditionalGeneration` class.\n     * @param {Object} config The configuration object for the Bart model.\n     * @param {Object} session The ONNX session used to execute the model.\n     * @param {Object} decoder_merged_session The ONNX session used to execute the decoder.\n     * @param {Object} generation_config The generation configuration object.\n     */\n    constructor(config, session, decoder_merged_session, generation_config) {\n        super(config, session);\n        this.decoder_merged_session = decoder_merged_session;\n        this.generation_config = generation_config;\n\n        this.num_decoder_layers = this.config.decoder_layers;\n        this.num_decoder_heads = this.config.decoder_attention_heads;\n        this.decoder_dim_kv = this.config.d_model / this.num_decoder_heads;\n\n        this.num_encoder_layers = this.config.encoder_layers;\n        this.num_encoder_heads = this.config.encoder_attention_heads;\n        this.encoder_dim_kv = this.config.d_model / this.num_encoder_heads;\n    }\n\n    /**\n     * Returns the initial beam for generating output text.\n     * @param {Object} inputs The input object containing the encoded input text.\n     * @param {number} numOutputTokens The maximum number of output tokens to generate.\n     * @param  {...any} args Additional arguments to pass to the sequence-to-sequence generation function.\n     * @returns {any} The initial beam for generating output text.\n     */\n    getStartBeams(inputs, numOutputTokens, ...args) {\n        return seq2seqStartBeams(this, inputs, numOutputTokens);\n    }\n\n    /**\n     * Runs a single step of the beam search generation algorithm.\n     * @param {any} beam The current beam being generated.\n     * @returns {Promise<any>} The updated beam after a single generation step.\n     */\n    async runBeam(beam) {\n        return await seq2seqRunBeam(this, beam);\n    }\n\n    /**\n     * Updates the beam by appending the newly generated token ID to the list of output token IDs.\n     * @param {any} beam The current beam being generated.\n     * @param {number} newTokenId The ID of the newly generated token to append to the list of output token IDs.\n     */\n    updateBeam(beam, newTokenId) {\n        beam.output_token_ids = [...beam.output_token_ids, newTokenId];\n    }\n\n    /**\n     * Runs the forward pass of the model for a given set of inputs.\n     * @param {Object} model_inputs The model inputs.\n     * @returns {Promise<Object>} The model output.\n     */\n    async forward(model_inputs) {\n        return await seq2seqForward(this, model_inputs);\n    }\n}\n\nclass BartForSequenceClassification extends BartPretrainedModel {\n    /**\n     * Calls the model on new inputs.\n     *\n     * @param {Object} model_inputs The inputs to the model.\n     * @returns {Promise<SequenceClassifierOutput>} An object containing the model's output logits for sequence classification.\n     */\n    async _call(model_inputs) {\n        return new SequenceClassifierOutput(await super._call(model_inputs));\n    }\n}\n\n//////////////////////////////////////////////////\n\n//////////////////////////////////////////////////\n// Roberta models\nclass RobertaPreTrainedModel extends PreTrainedModel { }\nclass RobertaModel extends RobertaPreTrainedModel { }\n\n/**\n * RobertaForMaskedLM class for performing masked language modeling on Roberta models.\n * @extends RobertaPreTrainedModel\n */\nclass RobertaForMaskedLM extends RobertaPreTrainedModel {\n    /**\n     * Calls the model on new inputs.\n     *\n     * @param {Object} model_inputs The inputs to the model.\n     * @returns {Promise<MaskedLMOutput>} returned object\n     */\n    async _call(model_inputs) {\n        return new MaskedLMOutput(await super._call(model_inputs));\n    }\n}\n\n/**\n * RobertaForSequenceClassification class for performing sequence classification on Roberta models.\n * @extends RobertaPreTrainedModel\n */\nclass RobertaForSequenceClassification extends RobertaPreTrainedModel {\n    /**\n     * Calls the model on new inputs.\n     *\n     * @param {Object} model_inputs The inputs to the model.\n     * @returns {Promise<SequenceClassifierOutput>} returned object\n     */\n    async _call(model_inputs) {\n        return new SequenceClassifierOutput(await super._call(model_inputs));\n    }\n}\n\n/**\n * RobertaForTokenClassification class for performing token classification on Roberta models.\n * @extends RobertaPreTrainedModel\n */\nclass RobertaForTokenClassification extends RobertaPreTrainedModel {\n    /**\n     * Calls the model on new inputs.\n     *\n     * @param {Object} model_inputs The inputs to the model.\n     * @returns {Promise<TokenClassifierOutput>} An object containing the model's output logits for token classification.\n     */\n    async _call(model_inputs) {\n        return new TokenClassifierOutput(await super._call(model_inputs));\n    }\n}\n\n/**\n * RobertaForQuestionAnswering class for performing question answering on Roberta models.\n * @extends RobertaPreTrainedModel\n */\nclass RobertaForQuestionAnswering extends RobertaPreTrainedModel {\n    /**\n     * Calls the model on new inputs.\n     *\n     * @param {Object} model_inputs The inputs to the model.\n     * @returns {Promise<QuestionAnsweringModelOutput>} returned object\n     */\n    async _call(model_inputs) {\n        return new QuestionAnsweringModelOutput(await super._call(model_inputs));\n    }\n}\n//////////////////////////////////////////////////\n\n//////////////////////////////////////////////////\n// XLMRoberta models\nclass XLMRobertaPreTrainedModel extends PreTrainedModel { }\nclass XLMRobertaModel extends XLMRobertaPreTrainedModel { }\n\n/**\n * XLMRobertaForMaskedLM class for performing masked language modeling on XLMRoberta models.\n * @extends XLMRobertaPreTrainedModel\n */\nclass XLMRobertaForMaskedLM extends XLMRobertaPreTrainedModel {\n    /**\n     * Calls the model on new inputs.\n     *\n     * @param {Object} model_inputs The inputs to the model.\n     * @returns {Promise<MaskedLMOutput>} returned object\n     */\n    async _call(model_inputs) {\n        return new MaskedLMOutput(await super._call(model_inputs));\n    }\n}\n\n/**\n * XLMRobertaForSequenceClassification class for performing sequence classification on XLMRoberta models.\n * @extends XLMRobertaPreTrainedModel\n */\nclass XLMRobertaForSequenceClassification extends XLMRobertaPreTrainedModel {\n    /**\n     * Calls the model on new inputs.\n     *\n     * @param {Object} model_inputs The inputs to the model.\n     * @returns {Promise<SequenceClassifierOutput>} returned object\n     */\n    async _call(model_inputs) {\n        return new SequenceClassifierOutput(await super._call(model_inputs));\n    }\n}\n\n/**\n * XLMRobertaForTokenClassification class for performing token classification on XLMRoberta models.\n * @extends XLMRobertaPreTrainedModel\n */\nclass XLMRobertaForTokenClassification extends XLMRobertaPreTrainedModel {\n    /**\n     * Calls the model on new inputs.\n     *\n     * @param {Object} model_inputs The inputs to the model.\n     * @returns {Promise<TokenClassifierOutput>} An object containing the model's output logits for token classification.\n     */\n    async _call(model_inputs) {\n        return new TokenClassifierOutput(await super._call(model_inputs));\n    }\n}\n\n/**\n * XLMRobertaForQuestionAnswering class for performing question answering on XLMRoberta models.\n * @extends XLMRobertaPreTrainedModel\n */\nclass XLMRobertaForQuestionAnswering extends XLMRobertaPreTrainedModel {\n    /**\n     * Calls the model on new inputs.\n     *\n     * @param {Object} model_inputs The inputs to the model.\n     * @returns {Promise<QuestionAnsweringModelOutput>} returned object\n     */\n    async _call(model_inputs) {\n        return new QuestionAnsweringModelOutput(await super._call(model_inputs));\n    }\n}\n//////////////////////////////////////////////////\n\n//////////////////////////////////////////////////\n// T5 models\nclass WhisperPreTrainedModel extends PreTrainedModel { };\n\n/**\n * WhisperModel class for training Whisper models without a language model head.\n * @extends WhisperPreTrainedModel\n */\nclass WhisperModel extends WhisperPreTrainedModel {\n    /**\n     * Throws an error when attempting to generate output since this model doesn't have a language model head.\n     * @throws Error\n     * @returns {Promise<any>}\n     * @param {any[]} args\n     */\n    async generate(...args) {\n        throw Error(\n            \"The current model class (WhisperModel) is not compatible with `.generate()`, as it doesn't have a language model head. Please use one of the following classes instead: {'WhisperForConditionalGeneration'}\"\n        )\n    }\n}\n\n/**\n * WhisperForConditionalGeneration class for generating conditional outputs from Whisper models.\n * @extends WhisperPreTrainedModel\n */\nclass WhisperForConditionalGeneration extends WhisperPreTrainedModel {\n\n    /**\n     * Creates a new instance of the `WhisperForConditionalGeneration` class.\n     * @param {Object} config Configuration object for the model.\n     * @param {Object} session ONNX Session object for the model.\n     * @param {Object} decoder_merged_session ONNX Session object for the decoder.\n     * @param {Object} generation_config Configuration object for the generation process.\n     */\n    constructor(config, session, decoder_merged_session, generation_config) {\n        super(config, session);\n        this.decoder_merged_session = decoder_merged_session;\n        this.generation_config = generation_config;\n\n        this.num_decoder_layers = this.config.decoder_layers;\n        this.num_decoder_heads = this.config.decoder_attention_heads;\n        this.decoder_dim_kv = this.config.d_model / this.num_decoder_heads;\n\n        this.num_encoder_layers = this.config.encoder_layers;\n        this.num_encoder_heads = this.config.encoder_attention_heads;\n        this.encoder_dim_kv = this.config.d_model / this.num_encoder_heads;\n\n\n    }\n\n    /**\n     * Generates outputs based on input and generation configuration.\n     * @param {Object} inputs Input data for the model.\n     * @param {Object} generation_config Configuration object for the generation process.\n     * @param {Object} logits_processor Optional logits processor object.\n     * @param {Object} options options\n     * @param {Object} [options.return_timestamps=null] Whether to return the timestamps with the text. This enables the `WhisperTimestampsLogitsProcessor`.\n     * @param {Object} [options.return_token_timestamps=null] Whether to return token-level timestamps\n     * with the text. This can be used with or without the `return_timestamps` option. To get word-level\n     * timestamps, use the tokenizer to group the tokens into words.\n     * @returns {Promise<Object>} Promise object represents the generated outputs.\n     */\n    // @ts-ignore\n    async generate(\n        inputs,\n        generation_config = null,\n        logits_processor = null,\n        // {\n        //     return_timestamps = null,\n        //     return_token_timestamps = null,\n        //     language = null,\n        //     task = null,\n        // } = {},\n    ) {\n        // Create generation config object\n        generation_config = this._get_generation_config(generation_config);\n\n\n        // Whisper has additional options for returning timestamps\n        generation_config.return_timestamps ??= false;\n\n        // TODO add language and task\n\n        if (generation_config.return_timestamps) {\n            logits_processor = [new _utils_generation_js__WEBPACK_IMPORTED_MODULE_3__.WhisperTimeStampLogitsProcessor(generation_config)]\n        }\n\n        if (generation_config.return_token_timestamps) {\n            generation_config.output_attentions = true;\n            generation_config.return_dict_in_generate = true;\n\n            if (generation_config.task === 'translate') {\n                console.warn(\"Token-level timestamps may not be reliable for task 'translate'.\")\n            }\n\n            if (!generation_config.alignment_heads) {\n                throw new Error(\n                    \"Model generation config has no `alignment_heads`, token-level timestamps not available. \" +\n                    \"See https://gist.github.com/hollance/42e32852f24243b748ae6bc1f985b13a on how to add this property to the generation config.\"\n                )\n            }\n        }\n\n        const outputs = await super.generate(inputs, generation_config, logits_processor);\n\n        if (generation_config.return_token_timestamps && generation_config.alignment_heads) {\n            outputs[\"token_timestamps\"] = this._extract_token_timestamps(outputs, generation_config.alignment_heads)\n        }\n\n        return outputs\n    }\n\n    /**\n     * Gets the start beams for generating outputs.\n     * @param {Array} inputTokenIds Array of input token IDs.\n     * @param {number} numOutputTokens Number of output tokens to generate.\n     * @returns {Array} Array of start beams.\n     */\n    getStartBeams(inputTokenIds, numOutputTokens, ...args) {\n        // arguments ignored in this case\n        return seq2seqStartBeams(this, inputTokenIds, numOutputTokens, false);\n    }\n\n    /**\n     * Runs a single step of the beam search generation algorithm.\n     * @param {any} beam The current beam being generated.\n     * @returns {Promise<any>} The updated beam after a single generation step.\n     */\n    async runBeam(beam) {\n        return await seq2seqRunBeam(this, beam, {\n            input_name: 'input_features',\n        });\n    }\n\n    /**\n     * Updates the beam by appending the newly generated token ID to the list of output token IDs.\n     * @param {any} beam The current beam being generated.\n     * @param {number} newTokenId The ID of the newly generated token to append to the list of output token IDs.\n     */\n    updateBeam(beam, newTokenId) {\n        beam.output_token_ids = [...beam.output_token_ids, newTokenId];\n    }\n\n    /**\n     * Runs the forward pass of the model for a given set of inputs.\n     * @param {Object} model_inputs The model inputs.\n     * @returns {Promise<Object>} The model output.\n     */\n    async forward(model_inputs) {\n        return await seq2seqForward(this, model_inputs);\n    }\n\n    /**\n     * Calculates token-level timestamps using the encoder-decoder cross-attentions and\n     * dynamic time-warping (DTW) to map each output token to a position in the input audio.\n     * @param {Object} generate_outputs Outputs generated by the model\n     * @param {Tensor[][][]} generate_outputs.cross_attentions The cross attentions output by the model\n     * @param {Tensor[][][]} generate_outputs.decoder_attentions The decoder attentions output by the model\n     * @param {number[][]} generate_outputs.sequences The sequences output by the model\n     * @param {number[][]} alignment_heads Alignment heads of the model\n     * @param {number} time_precision Precision of the timestamps in seconds\n     * @returns {Tensor} tensor containing the timestamps in seconds for each predicted token\n     */\n    _extract_token_timestamps(generate_outputs, alignment_heads, time_precision = 0.02) {\n        if (!generate_outputs.cross_attentions) {\n            throw new Error(\n                \"Model outputs must contain cross attentions to extract timestamps. \" +\n                \"This is most likely because the model was not exported with `output_attentions=True`.\"\n            )\n        }\n\n        let median_filter_width = this.config.median_filter_width;\n        if (median_filter_width === undefined) {\n            console.warn(\"Model config has no `median_filter_width`, using default value of 7.\")\n            median_filter_width = 7;\n        }\n\n        const batchedMatrices = generate_outputs.cross_attentions.map(batch => {\n            // Create a list with `decoder_layers` elements, each a tensor of shape\n            // (batch size, attention_heads, output length, input length).\n            let cross_attentions = Array.from({ length: this.config.decoder_layers },\n                (_, i) => (0,_utils_tensor_js__WEBPACK_IMPORTED_MODULE_4__.cat)(batch.map(x => x[i]), 2)\n            );\n\n            let weights = (0,_utils_tensor_js__WEBPACK_IMPORTED_MODULE_4__.stack)(alignment_heads.map(([l, h]) => cross_attentions[l].slice(null, h)));\n            weights = weights.transpose(1, 0, 2, 3)\n\n            let [std, calculatedMean] = (0,_utils_tensor_js__WEBPACK_IMPORTED_MODULE_4__.std_mean)(weights, -2, 0, true);\n\n            // Normalize and smoothen the weights.\n            let smoothedWeights = weights.clone(); // [1, 8, seqLength, 1500]\n\n            for (let a = 0; a < smoothedWeights.dims[0]; ++a) {\n                let aTensor = smoothedWeights[a]; // [8, seqLength, 1500]\n\n                for (let b = 0; b < aTensor.dims[0]; ++b) {\n                    let bTensor = aTensor[b]; // [seqLength, 1500]\n\n                    const stdTensor = std[a][b][0]; // [1500]\n                    const meanTensor = calculatedMean[a][b][0]; // [1500]\n\n                    for (let c = 0; c < bTensor.dims[0]; ++c) {\n\n                        let cTensor = bTensor[c]; // [1500]\n                        for (let d = 0; d < cTensor.data.length; ++d) {\n                            cTensor.data[d] = (cTensor.data[d] - meanTensor.data[d]) / stdTensor.data[d]\n                        }\n\n                        // Apply median filter.\n                        cTensor.data.set((0,_transformers_js__WEBPACK_IMPORTED_MODULE_6__.medianFilter)(cTensor.data, median_filter_width))\n                    }\n                }\n            }\n\n            // Average the different cross-attention heads.\n            const matrix = (0,_utils_tensor_js__WEBPACK_IMPORTED_MODULE_4__.mean)(smoothedWeights, 1);\n            return matrix;\n        });\n\n        const timestampsShape = [generate_outputs.sequences.length, generate_outputs.sequences[0].length];\n\n        const timestamps = new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_4__.Tensor(\n            'float32',\n            new Float32Array(timestampsShape[0] * timestampsShape[1]),\n            timestampsShape\n        );\n\n        // Perform dynamic time warping on each element of the batch.\n        for (let batch_idx = 0; batch_idx < timestampsShape[0]; ++batch_idx) {\n            // NOTE: Since we run only one batch at a time, we can squeeze to get the same dimensions\n            // as the python implementation\n            const matrix = batchedMatrices[batch_idx].neg().squeeze_(0);\n            let [text_indices, time_indices] = (0,_utils_tensor_js__WEBPACK_IMPORTED_MODULE_4__.dynamicTimeWarping)(matrix);\n\n            let diffs = Array.from({ length: text_indices.length - 1 }, (v, i) => text_indices[i + 1] - text_indices[i]);\n            let jumps = (0,_utils_core_js__WEBPACK_IMPORTED_MODULE_1__.mergeArrays)([1], diffs).map(x => !!x); // convert to boolean\n\n            let jump_times = [];\n            for (let i = 0; i < jumps.length; ++i) {\n                if (jumps[i]) {\n                    jump_times.push(time_indices[i] * time_precision);\n                    // NOTE: No point in rounding here, since we set to Float32Array later\n                }\n            }\n            timestamps[batch_idx].data.set(jump_times, 1)\n        }\n\n        return timestamps;\n    }\n}\n//////////////////////////////////////////////////\n\n//////////////////////////////////////////////////\n/**\n * Vision Encoder-Decoder model based on OpenAI's GPT architecture for image captioning and other vision tasks\n * @extends PreTrainedModel\n */\nclass VisionEncoderDecoderModel extends PreTrainedModel {\n    /**\n     * Creates a new instance of the `VisionEncoderDecoderModel` class.\n     * @param {Object} config The configuration object specifying the hyperparameters and other model settings.\n     * @param {Object} session The ONNX session containing the encoder model.\n     * @param {any} decoder_merged_session The ONNX session containing the merged decoder model.\n     */\n    constructor(config, session, decoder_merged_session) {\n        super(config, session);\n        this.decoder_merged_session = decoder_merged_session;\n\n        this.num_layers = this.config.decoder.n_layer;\n        this.num_heads = this.config.decoder.n_head;\n        this.dim_kv = this.config.decoder.n_embd / this.num_heads;\n    }\n\n    /**\n     * Generate beam search outputs for the given input pixels and number of output tokens.\n     *\n     * @param {array} inputs The input pixels as a Tensor.\n     * @param {number} numOutputTokens The number of output tokens to generate.\n     * @param {...*} args Optional additional arguments to pass to seq2seqStartBeams.\n     * @returns {any} An array of Beam objects representing the top-K output sequences.\n     */\n    getStartBeams(inputs, numOutputTokens, ...args) {\n        return seq2seqStartBeams(this, inputs, numOutputTokens);\n    }\n\n    /**\n     * Runs a single step of the beam search generation algorithm.\n     * @param {any} beam The current beam being generated.\n     * @returns {Promise<any>} The updated beam after a single generation step.\n     */\n    async runBeam(beam) {\n        return seq2seqRunBeam(this, beam, {\n            input_name: 'pixel_values',\n        });\n    }\n\n    /**\n     * Update the given beam with the additional predicted token ID.\n     *\n     * @param {any} beam The current beam.\n     * @param {number} newTokenId The new predicted token ID to add to the beam's output sequence.\n     */\n    updateBeam(beam, newTokenId) {\n        beam.output_token_ids = [...beam.output_token_ids, newTokenId];\n    }\n\n    /**\n     * Compute the forward pass of the model on the given input tensors.\n     *\n     * @param {Object} model_inputs The input tensors as an object with keys 'pixel_values' and 'decoder_input_ids'.\n     * @returns {Promise<any>} The output tensor of the model.\n     */\n    async forward(model_inputs) {\n        return await seq2seqForward(this, model_inputs, {\n            add_decoder_pkv: false\n        })\n    }\n}\n//////////////////////////////////////////////////\n\n//////////////////////////////////////////////////\n// CLIP models\nclass CLIPPreTrainedModel extends PreTrainedModel { }\nclass CLIPModel extends CLIPPreTrainedModel {\n\n}\n\n//////////////////////////////////////////////////\n\n//////////////////////////////////////////////////\n// GPT2 models\nclass GPT2PreTrainedModel extends PreTrainedModel {\n    /**\n     * Creates a new instance of the `GPT2PreTrainedModel` class.\n     * @param {Object} config The configuration of the model.\n     * @param {any} session The ONNX session containing the model weights.\n     */\n    constructor(config, session) {\n        super(config, session);\n\n        // config doesn't contain pad_token_id, so we assume it is the eos_token_id\n        this.config.pad_token_id = this.config.eos_token_id\n\n        this.num_heads = this.config.n_head\n        this.num_layers = this.config.n_layer\n        this.dim_kv = this.config.n_embd / this.num_heads;\n    }\n}\n\nclass GPT2Model extends GPT2PreTrainedModel {\n\n    /**\n     * GPT2Model is not compatible with `.generate()`, as it doesn't have a language model head.\n     * @param  {...any} args \n     * @throws {Error}\n     * @returns {Promise<any>}\n     */\n    async generate(...args) {\n        throw Error(\n            \"The current model class (GPT2Model) is not compatible with `.generate()`, as it doesn't have a language model head. Please use one of the following classes instead: {'GPT2LMHeadModel'}\"\n        )\n    }\n}\n\n/**\n * GPT-2 language model head on top of the GPT-2 base model. This model is suitable for text generation tasks.\n * @extends GPT2PreTrainedModel\n */\nclass GPT2LMHeadModel extends GPT2PreTrainedModel {\n\n    /**\n     * Initializes and returns the beam for text generation task\n     * @param {Tensor} inputTokenIds The input token ids.\n     * @param {number} numOutputTokens The number of tokens to be generated.\n     * @param {Tensor} inputs_attention_mask Optional input attention mask.\n     * @returns {any} A Beam object representing the initialized beam.\n     */\n    getStartBeams(inputTokenIds, numOutputTokens, inputs_attention_mask) {\n        return decoderStartBeams(this, inputTokenIds, numOutputTokens, inputs_attention_mask)\n    }\n\n    /**\n     * Runs a single step of the beam search generation algorithm.\n     * @param {any} beam The current beam being generated.\n     * @returns {Promise<any>} The updated beam after a single generation step.\n     */\n    async runBeam(beam) {\n        return await decoderRunBeam(this, beam);\n    }\n\n    /**\n     * Updates the given beam with the new generated token id.\n     * @param {any} beam The Beam object representing the beam.\n     * @param {number} newTokenId The new generated token id to be added to the beam.\n     */\n    updateBeam(beam, newTokenId) {\n        return decoderUpdatebeam(beam, newTokenId);\n    }\n\n    /**\n     * Forward pass for the model.\n     * @param {Object} model_inputs The inputs for the model.\n     * @returns {Promise<any>} The output tensor of the model.\n     */\n    async forward(model_inputs) {\n        return await decoderForward(this, model_inputs);\n    }\n\n}\n// export class GPT2ForSequenceClassification extends GPT2PreTrainedModel {\n// TODO\n// }\n//////////////////////////////////////////////////\nclass GPTNeoPreTrainedModel extends PreTrainedModel {\n    /**\n     * Creates a new instance of the `GPTNeoPreTrainedModel` class.\n     * @param {Object} config The configuration of the model.\n     * @param {any} session The ONNX session containing the model weights.\n     */\n    constructor(config, session) {\n        super(config, session);\n\n        // config doesn't contain pad_token_id, so we assume it is the eos_token_id\n        this.config.pad_token_id = this.config.eos_token_id\n\n        this.num_heads = this.config.num_heads;\n        this.num_layers = this.config.num_layers;\n        this.dim_kv = this.config.hidden_size / this.num_heads;\n    }\n}\nclass GPTNeoModel extends GPTNeoPreTrainedModel {\n    /**\n     * \n     * @param  {...any} args \n     * @throws {Error}\n     * @returns {Promise<any>}\n     */\n    async generate(...args) {\n        throw Error(\n            \"The current model class (GPTNeoModel) is not compatible with `.generate()`, as it doesn't have a language model head. Please use one of the following classes instead: {'GPTNeoForCausalLM'}\"\n        )\n    }\n}\n\nclass GPTNeoForCausalLM extends GPTNeoPreTrainedModel {\n\n    /**\n     * Initializes and returns the beam for text generation task\n     * @param {Tensor} inputTokenIds The input token ids.\n     * @param {number} numOutputTokens The number of tokens to be generated.\n     * @param {Tensor} inputs_attention_mask Optional input attention mask.\n     * @returns {any} A Beam object representing the initialized beam.\n     */\n    getStartBeams(inputTokenIds, numOutputTokens, inputs_attention_mask) {\n        return decoderStartBeams(this, inputTokenIds, numOutputTokens, inputs_attention_mask)\n    }\n\n    /**\n     * Runs a single step of the beam search generation algorithm.\n     * @param {any} beam The current beam being generated.\n     * @returns {Promise<any>} The updated beam after a single generation step.\n     */\n    async runBeam(beam) {\n        return await decoderRunBeam(this, beam);\n    }\n\n    /**\n     * Updates the given beam with the new generated token id.\n     * @param {any} beam The Beam object representing the beam.\n     * @param {number} newTokenId The new generated token id to be added to the beam.\n     */\n    updateBeam(beam, newTokenId) {\n        return decoderUpdatebeam(beam, newTokenId);\n    }\n\n    /**\n     * Forward pass for the model.\n     * @param {Object} model_inputs The inputs for the model.\n     * @returns {Promise<any>} The output tensor of the model.\n     */\n    async forward(model_inputs) {\n        return await decoderForward(this, model_inputs);\n    }\n}\n\n//////////////////////////////////////////////////\n// CodeGen models\nclass CodeGenPreTrainedModel extends PreTrainedModel {\n    /**\n     * Creates a new instance of the `CodeGenPreTrainedModel` class.\n    * @param {Object} config The model configuration object.\n    * @param {Object} session The ONNX session object.\n    */\n    constructor(config, session) {\n        super(config, session);\n\n        // config doesn't contain pad_token_id, so we assume it is the eos_token_id\n        this.config.pad_token_id = this.config.eos_token_id\n\n        this.num_heads = this.config.n_head\n        this.num_layers = this.config.n_layer\n        this.dim_kv = this.config.n_embd / this.num_heads;\n    }\n}\n/**\n * CodeGenModel is a class representing a code generation model without a language model head.\n * \n * @extends CodeGenPreTrainedModel\n */\nclass CodeGenModel extends CodeGenPreTrainedModel {\n    /**\n     * Throws an error indicating that the current model class is not compatible with `.generate()`,\n     * as it doesn't have a language model head.\n     * \n     * @throws {Error} The current model class is not compatible with `.generate()`\n     * \n     * @param  {...any} args Arguments passed to the generate function\n     * @returns {Promise<any>}\n     */\n    async generate(...args) {\n        throw Error(\n            \"The current model class (CodeGenModel) is not compatible with `.generate()`, as it doesn't have a language model head. Please use one of the following classes instead: {'CodeGenForCausalLM'}\"\n        )\n    }\n}\n\n/**\n * CodeGenForCausalLM is a class that represents a code generation model based on the GPT-2 architecture. It extends the `CodeGenPreTrainedModel` class.\n * @extends CodeGenPreTrainedModel\n */\nclass CodeGenForCausalLM extends CodeGenPreTrainedModel {\n\n    /**\n     * Initializes and returns the beam for text generation task\n     * @param {Tensor} inputTokenIds The input token ids.\n     * @param {number} numOutputTokens The number of tokens to be generated.\n     * @param {Tensor} inputs_attention_mask Optional input attention mask.\n     * @returns {any} A Beam object representing the initialized beam.\n     */\n    getStartBeams(inputTokenIds, numOutputTokens, inputs_attention_mask) {\n        return decoderStartBeams(this, inputTokenIds, numOutputTokens, inputs_attention_mask)\n    }\n\n    /**\n     * Runs a single step of the beam search generation algorithm.\n     * @param {any} beam The current beam being generated.\n     * @returns {Promise<any>} The updated beam after a single generation step.\n     */\n    async runBeam(beam) {\n        return await decoderRunBeam(this, beam);\n    }\n\n    /**\n     * Updates the given beam with the new generated token id.\n     * @param {any} beam The Beam object representing the beam.\n     * @param {number} newTokenId The new generated token id to be added to the beam.\n     */\n    updateBeam(beam, newTokenId) {\n        return decoderUpdatebeam(beam, newTokenId);\n    }\n\n    /**\n     * Forward pass for the model.\n     * @param {Object} model_inputs The inputs for the model.\n     * @returns {Promise<any>} The output tensor of the model.\n     */\n    async forward(model_inputs) {\n        return await decoderForward(this, model_inputs);\n    }\n\n}\n//////////////////////////////////////////////////\n\n//////////////////////////////////////////////////\nclass ViTPreTrainedModel extends PreTrainedModel { }\nclass ViTForImageClassification extends ViTPreTrainedModel {\n    /**\n     * @param {any} model_inputs\n     */\n    async _call(model_inputs) {\n        return new SequenceClassifierOutput(await super._call(model_inputs));\n    }\n}\n//////////////////////////////////////////////////\n\n//////////////////////////////////////////////////\nclass MobileViTPreTrainedModel extends PreTrainedModel { }\nclass MobileViTForImageClassification extends MobileViTPreTrainedModel {\n    /**\n     * @param {any} model_inputs\n     */\n    async _call(model_inputs) {\n        return new SequenceClassifierOutput(await super._call(model_inputs));\n    }\n}\n// TODO: MobileViTForSemanticSegmentation\n\n//////////////////////////////////////////////////\n\n\n\n//////////////////////////////////////////////////\nclass DetrPreTrainedModel extends PreTrainedModel { }\nclass DetrForObjectDetection extends DetrPreTrainedModel {\n    /**\n     * @param {any} model_inputs\n     */\n    async _call(model_inputs) {\n        return new DetrObjectDetectionOutput(await super._call(model_inputs));\n    }\n}\n\nclass DetrForSegmentation extends DetrPreTrainedModel {\n    /**\n     * Runs the model with the provided inputs\n     * @param {Object} model_inputs Model inputs\n     * @returns {Promise<DetrSegmentationOutput>} Object containing segmentation outputs\n     */\n    async _call(model_inputs) {\n        return new DetrSegmentationOutput(await super._call(model_inputs));\n    }\n}\n\nclass DetrObjectDetectionOutput extends ModelOutput {\n    /**\n     * @param {Object} output The output of the model.\n     * @param {Tensor} output.logits Classification logits (including no-object) for all queries.\n     * @param {Tensor} output.pred_boxes Normalized boxes coordinates for all queries, represented as (center_x, center_y, width, height).\n     * These values are normalized in [0, 1], relative to the size of each individual image in the batch (disregarding possible padding).\n     */\n    constructor({ logits, pred_boxes }) {\n        super();\n        this.logits = logits;\n        this.pred_boxes = pred_boxes;\n    }\n}\n\nclass DetrSegmentationOutput extends ModelOutput {\n    /**\n     * @param {Object} output The output of the model.\n     * @param {Tensor} output.logits The output logits of the model.\n     * @param {Tensor} output.pred_boxes Predicted boxes.\n     * @param {Tensor} output.pred_masks Predicted masks.\n     */\n    constructor({ logits, pred_boxes, pred_masks }) {\n        super();\n        this.logits = logits;\n        this.pred_boxes = pred_boxes;\n        this.pred_masks = pred_masks;\n    }\n}\n//////////////////////////////////////////////////\n\n\n//////////////////////////////////////////////////\nclass SamPreTrainedModel extends PreTrainedModel { }\nclass SamModel extends SamPreTrainedModel {\n    /**\n     * @param {Object} model_inputs\n     * @param {Tensor} model_inputs.pixel_values Pixel values as a Tensor with shape `(batch_size, num_channels, height, width)`.\n     * @param {Tensor} model_inputs.input_points Input 2D spatial points with shape `(batch_size, num_points, 2)`. This is used by the prompt encoder to encode the prompt.\n     * @todo Add support for `input_labels`, `input_boxes`, `input_masks`, and `image_embeddings`.\n     */\n    async _call(model_inputs) {\n        return new SamImageSegmentationOutput(await super._call(model_inputs));\n    }\n}\n\n\n/**\n * Base class for Segment-Anything model's output.\n */\nclass SamImageSegmentationOutput extends ModelOutput {\n    /**\n     * @param {Object} output The output of the model.\n     * @param {Tensor} output.iou_scores The output logits of the model.\n     * @param {Tensor} output.pred_masks Predicted boxes.\n     */\n    constructor({ iou_scores, pred_masks }) {\n        super();\n        this.iou_scores = iou_scores;\n        this.pred_masks = pred_masks;\n    }\n}\n//////////////////////////////////////////////////\n\n\n//////////////////////////////////////////////////\n// MarianMT models\nclass MarianPreTrainedModel extends PreTrainedModel { };\n\nclass MarianModel extends MarianPreTrainedModel {\n    /**\n     * \n     * @param  {...any} args \n     * @throws {Error}\n     * @returns {Promise<any>}\n     */\n    async generate(...args) {\n        throw Error(\n            \"The current model class (MarianModel) is not compatible with `.generate()`, as it doesn't have a language model head. Please use one of the following classes instead: {'MarianMTModel'}\"\n        )\n    }\n}\n\nclass MarianMTModel extends MarianPreTrainedModel {\n\n    /**\n     * Creates a new instance of the `MarianMTModel` class.\n    * @param {Object} config The model configuration object.\n    * @param {Object} session The ONNX session object.\n    * @param {any} decoder_merged_session \n    * @param {any} generation_config \n    */\n    constructor(config, session, decoder_merged_session, generation_config) {\n        super(config, session);\n        this.decoder_merged_session = decoder_merged_session;\n        this.generation_config = generation_config;\n\n        this.num_decoder_layers = this.config.decoder_layers;\n        this.num_decoder_heads = this.config.decoder_attention_heads;\n        this.decoder_dim_kv = this.config.d_model / this.num_decoder_heads;\n\n        this.num_encoder_layers = this.config.encoder_layers;\n        this.num_encoder_heads = this.config.encoder_attention_heads;\n        this.encoder_dim_kv = this.config.d_model / this.num_encoder_heads;\n    }\n\n    /**\n     * Initializes and returns the beam for text generation task\n     * @param {any[]} inputs The input token ids.\n     * @param {number} numOutputTokens The number of tokens to be generated.\n     * @returns {any} A Beam object representing the initialized beam.\n     * @param {any[]} args\n     */\n    getStartBeams(inputs, numOutputTokens, ...args) {\n        return seq2seqStartBeams(this, inputs, numOutputTokens);\n    }\n\n    /**\n     * Runs a single step of the beam search generation algorithm.\n     * @param {any} beam The current beam being generated.\n     * @returns {Promise<any>} The updated beam after a single generation step.\n     */\n    async runBeam(beam) {\n        return await seq2seqRunBeam(this, beam);\n    }\n\n    /**\n     * @param {any} beam\n     * @param {any} newTokenId\n     */\n    updateBeam(beam, newTokenId) {\n        beam.output_token_ids = [...beam.output_token_ids, newTokenId];\n    }\n\n    /**\n     * @param {any} model_inputs\n     * @returns {Promise<Seq2SeqLMOutput>}\n     */\n    async forward(model_inputs) {\n        return await seq2seqForward(this, model_inputs);\n    }\n}\n//////////////////////////////////////////////////\n\n//////////////////////////////////////////////////\n// M2M100 models\nclass M2M100PreTrainedModel extends PreTrainedModel { };\n\nclass M2M100Model extends M2M100PreTrainedModel {\n    /**\n     * \n     * @param  {...any} args \n     * @throws {Error}\n     * @returns {Promise<any>}\n     */\n    async generate(...args) {\n        throw Error(\n            \"The current model class (M2M100Model) is not compatible with `.generate()`, as it doesn't have a language model head. Please use one of the following classes instead: {'M2M100ForConditionalGeneration'}\"\n        )\n    }\n}\n\nclass M2M100ForConditionalGeneration extends M2M100PreTrainedModel {\n\n    /**\n     * Creates a new instance of the `M2M100ForConditionalGeneration` class.\n    * @param {Object} config The model configuration object.\n    * @param {Object} session The ONNX session object.\n    * @param {any} decoder_merged_session \n    * @param {any} generation_config \n    */\n    constructor(config, session, decoder_merged_session, generation_config) {\n        super(config, session);\n        this.decoder_merged_session = decoder_merged_session;\n        this.generation_config = generation_config;\n\n        this.num_decoder_layers = this.config.decoder_layers;\n        this.num_decoder_heads = this.config.decoder_attention_heads;\n        this.decoder_dim_kv = this.config.d_model / this.num_decoder_heads;\n\n        this.num_encoder_layers = this.config.encoder_layers;\n        this.num_encoder_heads = this.config.encoder_attention_heads;\n        this.encoder_dim_kv = this.config.d_model / this.num_encoder_heads;\n    }\n\n\n    /**\n     * Initializes and returns the beam for text generation task\n     * @param {any[]} inputs The input token ids.\n     * @param {number} numOutputTokens The number of tokens to be generated.\n     * @returns {any} A Beam object representing the initialized beam.\n     * @param {any[]} args\n     */\n    getStartBeams(inputs, numOutputTokens, ...args) {\n        return seq2seqStartBeams(this, inputs, numOutputTokens);\n    }\n\n    /**\n     * Runs a single step of the beam search generation algorithm.\n     * @param {any} beam The current beam being generated.\n     * @returns {Promise<any>} The updated beam after a single generation step.\n     */\n    async runBeam(beam) {\n        return await seq2seqRunBeam(this, beam);\n    }\n\n    /**\n     * @param {any} beam\n     * @param {any} newTokenId\n     */\n    updateBeam(beam, newTokenId) {\n        beam.output_token_ids = [...beam.output_token_ids, newTokenId];\n    }\n\n    /**\n     * @param {any} model_inputs\n     * @returns {Promise<Seq2SeqLMOutput>}\n     */\n    async forward(model_inputs) {\n        return await seq2seqForward(this, model_inputs);\n    }\n}\n//////////////////////////////////////////////////\n\n\n//////////////////////////////////////////////////\n// AutoModels, used to simplify construction of PreTrainedModels\n// (uses config to instantiate correct class)\n\n/**\n * Base class of all AutoModels. Contains the `from_pretrained` function\n * which is used to instantiate pretrained models.\n */\nclass PretrainedMixin {\n    /**\n     * Mapping from model type to model class.\n     * @type {Map<string, Object>[]}\n     */\n    static MODEL_CLASS_MAPPINGS = null;\n\n    /**\n     * Whether to attempt to instantiate the base class (`PretrainedModel`) if \n     * the model type is not found in the mapping.\n     */\n    static BASE_IF_FAIL = false;\n\n\n    /** @type {PreTrainedModel.from_pretrained} */\n    static async from_pretrained(pretrained_model_name_or_path, {\n        quantized = true,\n        progress_callback = null,\n        config = null,\n        cache_dir = null,\n        local_files_only = false,\n        revision = 'main',\n    } = {}) {\n\n        let options = {\n            quantized,\n            progress_callback,\n            config,\n            cache_dir,\n            local_files_only,\n            revision,\n        }\n        config = await _configs_js__WEBPACK_IMPORTED_MODULE_0__.AutoConfig.from_pretrained(pretrained_model_name_or_path, options);\n\n        if (!this.MODEL_CLASS_MAPPINGS) {\n            throw new Error(\"`MODEL_CLASS_MAPPINGS` not implemented for this type of `AutoClass`: \" + this.name);\n        }\n\n        let modelClass;\n        for (let MODEL_CLASS_MAPPING of this.MODEL_CLASS_MAPPINGS) {\n            modelClass = MODEL_CLASS_MAPPING.get(config.model_type);\n            if (!modelClass) {\n                continue; // Item not found in this mapping\n            }\n\n            return await modelClass.from_pretrained(pretrained_model_name_or_path, options);\n        }\n\n        if (this.BASE_IF_FAIL) {\n            console.warn(`Unknown model class \"${config.model_type}\", attempting to construct from base class.`);\n            return await PreTrainedModel.from_pretrained(pretrained_model_name_or_path, options);\n        } else {\n            throw Error(`Unsupported model type: ${config.model_type}`)\n        }\n    }\n}\n\nconst MODEL_MAPPING_NAMES_ENCODER_ONLY = new Map([\n    ['bert', BertModel],\n    ['albert', AlbertModel],\n    ['distilbert', DistilBertModel],\n    ['roberta', RobertaModel],\n    ['xlm-roberta', XLMRobertaModel],\n    ['clip', CLIPModel],\n    ['mobilebert', MobileBertModel],\n    ['squeezebert', SqueezeBertModel],\n\n    ['sam', SamModel], // TODO change to encoder-decoder when model is split correctly\n]);\n\nconst MODEL_MAPPING_NAMES_ENCODER_DECODER = new Map([\n    ['t5', T5Model],\n    ['mt5', MT5Model],\n    ['bart', BartModel],\n    ['marian', MarianModel],\n    ['whisper', WhisperModel],\n    ['m2m_100', M2M100Model],\n]);\n\n\nconst MODEL_MAPPING_NAMES_DECODER_ONLY = new Map([\n    ['gpt2', GPT2Model],\n    ['gpt_neo', GPTNeoModel],\n    ['codegen', CodeGenModel],\n]);\n\nconst MODEL_FOR_SEQUENCE_CLASSIFICATION_MAPPING_NAMES = new Map([\n    ['bert', BertForSequenceClassification],\n    ['albert', AlbertForSequenceClassification],\n    ['distilbert', DistilBertForSequenceClassification],\n    ['roberta', RobertaForSequenceClassification],\n    ['xlm-roberta', XLMRobertaForSequenceClassification],\n    ['bart', BartForSequenceClassification],\n    ['mobilebert', MobileBertForSequenceClassification],\n    ['squeezebert', SqueezeBertForSequenceClassification],\n]);\n\nconst MODEL_FOR_TOKEN_CLASSIFICATION_MAPPING_NAMES = new Map([\n    ['bert', BertForTokenClassification],\n    ['distilbert', DistilBertForTokenClassification],\n    ['roberta', RobertaForTokenClassification],\n    ['xlm-roberta', XLMRobertaForTokenClassification],\n]);\n\nconst MODEL_FOR_SEQ_2_SEQ_MAPPING_NAMES = new Map([\n    ['t5', T5ForConditionalGeneration],\n    ['mt5', MT5ForConditionalGeneration],\n    ['bart', BartForConditionalGeneration],\n    ['whisper', WhisperForConditionalGeneration],\n    ['marian', MarianMTModel],\n    ['m2m_100', M2M100ForConditionalGeneration],\n]);\n\nconst MODEL_WITH_LM_HEAD_MAPPING_NAMES = new Map([\n    ['gpt2', GPT2LMHeadModel],\n    ['gpt_neo', GPTNeoForCausalLM],\n    ['codegen', CodeGenForCausalLM],\n]);\n\nconst MODEL_FOR_MASKED_LM_MAPPING_NAMES = new Map([\n    ['bert', BertForMaskedLM],\n    ['albert', AlbertForMaskedLM],\n    ['distilbert', DistilBertForMaskedLM],\n    ['roberta', RobertaForMaskedLM],\n    ['xlm-roberta', XLMRobertaForMaskedLM],\n    ['mobilebert', MobileBertForMaskedLM],\n    ['squeezebert', SqueezeBertForMaskedLM],\n]);\n\nconst MODEL_FOR_QUESTION_ANSWERING_MAPPING_NAMES = new Map([\n    ['bert', BertForQuestionAnswering],\n    ['albert', AlbertForQuestionAnswering],\n    ['distilbert', DistilBertForQuestionAnswering],\n    ['roberta', RobertaForQuestionAnswering],\n    ['xlm-roberta', XLMRobertaForQuestionAnswering],\n    ['mobilebert', MobileBertForQuestionAnswering],\n    ['squeezebert', SqueezeBertForQuestionAnswering],\n]);\n\nconst MODEL_FOR_VISION_2_SEQ_MAPPING_NAMES = new Map([\n    ['vision-encoder-decoder', VisionEncoderDecoderModel],\n]);\n\nconst MODEL_FOR_IMAGE_CLASSIFICATION_MAPPING_NAMES = new Map([\n    ['vit', ViTForImageClassification],\n    ['mobilevit', MobileViTForImageClassification],\n]);\n\nconst MODEL_FOR_OBJECT_DETECTION_MAPPING_NAMES = new Map([\n    ['detr', DetrForObjectDetection],\n]);\n\nconst MODEL_FOR_IMAGE_SEGMENTATION_MAPPING_NAMES = new Map([\n    ['detr', DetrForSegmentation],\n]);\n\nconst MODEL_FOR_MASK_GENERATION_MAPPING_NAMES = new Map([\n    ['sam', SamModel],\n]);\n\nconst MODEL_CLASS_TYPE_MAPPING = [\n    [MODEL_MAPPING_NAMES_ENCODER_ONLY, EncoderOnlyModelType],\n    [MODEL_MAPPING_NAMES_ENCODER_DECODER, EncoderDecoderModelType],\n    [MODEL_MAPPING_NAMES_DECODER_ONLY, DecoderOnlyModelType],\n    [MODEL_FOR_SEQUENCE_CLASSIFICATION_MAPPING_NAMES, EncoderOnlyModelType],\n    [MODEL_FOR_TOKEN_CLASSIFICATION_MAPPING_NAMES, EncoderOnlyModelType],\n    [MODEL_FOR_SEQ_2_SEQ_MAPPING_NAMES, Seq2SeqModelType],\n    [MODEL_WITH_LM_HEAD_MAPPING_NAMES, DecoderOnlyModelType],\n    [MODEL_FOR_MASKED_LM_MAPPING_NAMES, EncoderOnlyModelType],\n    [MODEL_FOR_QUESTION_ANSWERING_MAPPING_NAMES, EncoderOnlyModelType],\n    [MODEL_FOR_VISION_2_SEQ_MAPPING_NAMES, EncoderDecoderModelType],\n    [MODEL_FOR_IMAGE_CLASSIFICATION_MAPPING_NAMES, EncoderOnlyModelType],\n    [MODEL_FOR_IMAGE_SEGMENTATION_MAPPING_NAMES, EncoderOnlyModelType],\n    [MODEL_FOR_OBJECT_DETECTION_MAPPING_NAMES, EncoderOnlyModelType],\n    [MODEL_FOR_MASK_GENERATION_MAPPING_NAMES, EncoderOnlyModelType],\n];\n\nfor (let [mappings, type] of MODEL_CLASS_TYPE_MAPPING) {\n    // @ts-ignore\n    for (let [name, model] of mappings.entries()) {\n        MODEL_TYPE_MAPPING.set(model.name, type);\n        MODEL_CLASS_MAPPING.set(model.name, name);\n    }\n}\n\n/**\n * Helper class which is used to instantiate pretrained models with the `from_pretrained` function.\n * The chosen model class is determined by the type specified in the model config.\n * \n * @example\n * let model = await AutoModel.from_pretrained('bert-base-uncased');\n */\nclass AutoModel extends PretrainedMixin {\n    static MODEL_CLASS_MAPPINGS = [MODEL_MAPPING_NAMES_ENCODER_ONLY, MODEL_MAPPING_NAMES_ENCODER_DECODER, MODEL_MAPPING_NAMES_DECODER_ONLY];\n    static BASE_IF_FAIL = true;\n}\n\n/**\n * Helper class which is used to instantiate pretrained sequence classification models with the `from_pretrained` function.\n * The chosen model class is determined by the type specified in the model config.\n * \n * @example\n * let model = await AutoModelForSequenceClassification.from_pretrained('distilbert-base-uncased-finetuned-sst-2-english');\n */\nclass AutoModelForSequenceClassification extends PretrainedMixin {\n    static MODEL_CLASS_MAPPINGS = [MODEL_FOR_SEQUENCE_CLASSIFICATION_MAPPING_NAMES];\n}\n\n/**\n * Helper class which is used to instantiate pretrained token classification models with the `from_pretrained` function.\n * The chosen model class is determined by the type specified in the model config.\n * \n * @example\n * let model = await AutoModelForTokenClassification.from_pretrained('Davlan/distilbert-base-multilingual-cased-ner-hrl');\n */\nclass AutoModelForTokenClassification extends PretrainedMixin {\n    static MODEL_CLASS_MAPPINGS = [MODEL_FOR_TOKEN_CLASSIFICATION_MAPPING_NAMES];\n}\n\n/**\n * Helper class which is used to instantiate pretrained sequence-to-sequence models with the `from_pretrained` function.\n * The chosen model class is determined by the type specified in the model config.\n * \n * @example\n * let model = await AutoModelForSeq2SeqLM.from_pretrained('t5-small');\n */\nclass AutoModelForSeq2SeqLM extends PretrainedMixin {\n    static MODEL_CLASS_MAPPINGS = [MODEL_FOR_SEQ_2_SEQ_MAPPING_NAMES];\n}\n\n/**\n * Helper class which is used to instantiate pretrained causal language models with the `from_pretrained` function.\n * The chosen model class is determined by the type specified in the model config.\n * \n * @example\n * let model = await AutoModelForCausalLM.from_pretrained('gpt2');\n */\nclass AutoModelForCausalLM extends PretrainedMixin {\n    static MODEL_CLASS_MAPPINGS = [MODEL_WITH_LM_HEAD_MAPPING_NAMES];\n}\n\n/**\n * Helper class which is used to instantiate pretrained masked language models with the `from_pretrained` function.\n * The chosen model class is determined by the type specified in the model config.\n * \n * @example\n * let model = await AutoModelForMaskedLM.from_pretrained('bert-base-uncased');\n */\nclass AutoModelForMaskedLM extends PretrainedMixin {\n    static MODEL_CLASS_MAPPINGS = [MODEL_FOR_MASKED_LM_MAPPING_NAMES];\n}\n\n/**\n * Helper class which is used to instantiate pretrained question answering models with the `from_pretrained` function.\n * The chosen model class is determined by the type specified in the model config.\n * \n * @example\n * let model = await AutoModelForQuestionAnswering.from_pretrained('distilbert-base-cased-distilled-squad');\n */\nclass AutoModelForQuestionAnswering extends PretrainedMixin {\n    static MODEL_CLASS_MAPPINGS = [MODEL_FOR_QUESTION_ANSWERING_MAPPING_NAMES];\n}\n\n/**\n * Helper class which is used to instantiate pretrained vision-to-sequence models with the `from_pretrained` function.\n * The chosen model class is determined by the type specified in the model config.\n * \n * @example\n * let model = await AutoModelForVision2Seq.from_pretrained('nlpconnect/vit-gpt2-image-captioning');\n */\nclass AutoModelForVision2Seq extends PretrainedMixin {\n    static MODEL_CLASS_MAPPINGS = [MODEL_FOR_VISION_2_SEQ_MAPPING_NAMES];\n}\n\n/**\n * Helper class which is used to instantiate pretrained image classification models with the `from_pretrained` function.\n * The chosen model class is determined by the type specified in the model config.\n * \n * @example\n * let model = await AutoModelForImageClassification.from_pretrained('google/vit-base-patch16-224');\n */\nclass AutoModelForImageClassification extends PretrainedMixin {\n    static MODEL_CLASS_MAPPINGS = [MODEL_FOR_IMAGE_CLASSIFICATION_MAPPING_NAMES];\n}\n\n/**\n * Helper class which is used to instantiate pretrained image segmentation models with the `from_pretrained` function.\n * The chosen model class is determined by the type specified in the model config.\n * \n * @example\n * let model = await AutoModelForImageSegmentation.from_pretrained('facebook/detr-resnet-50-panoptic');\n */\nclass AutoModelForImageSegmentation extends PretrainedMixin {\n    static MODEL_CLASS_MAPPINGS = [MODEL_FOR_IMAGE_SEGMENTATION_MAPPING_NAMES];\n}\n\n/**\n * Helper class which is used to instantiate pretrained object detection models with the `from_pretrained` function.\n * The chosen model class is determined by the type specified in the model config.\n * \n * @example\n * let model = await AutoModelForObjectDetection.from_pretrained('facebook/detr-resnet-50');\n */\nclass AutoModelForObjectDetection extends PretrainedMixin {\n    static MODEL_CLASS_MAPPINGS = [MODEL_FOR_OBJECT_DETECTION_MAPPING_NAMES];\n}\n\n/**\n * Helper class which is used to instantiate pretrained object detection models with the `from_pretrained` function.\n * The chosen model class is determined by the type specified in the model config.\n * \n * @example\n * let model = await AutoModelForMaskGeneration.from_pretrained('Xenova/sam-vit-base');\n */\nclass AutoModelForMaskGeneration extends PretrainedMixin {\n    static MODEL_CLASS_MAPPINGS = [MODEL_FOR_MASK_GENERATION_MAPPING_NAMES];\n}\n//////////////////////////////////////////////////\n\n//////////////////////////////////////////////////\nclass Seq2SeqLMOutput extends ModelOutput {\n    /**\n     * @param {Object} output The output of the model.\n     * @param {Tensor} output.logits The output logits of the model.\n     * @param {Tensor} output.past_key_values An tensor of key/value pairs that represent the previous state of the model.\n     * @param {Tensor} output.encoder_outputs The output of the encoder in a sequence-to-sequence model.\n     * @param {Tensor} [output.decoder_attentions] Attentions weights of the decoder, after the attention softmax, used to compute the weighted average in the self-attention heads.\n     * @param {Tensor} [output.cross_attentions] Attentions weights of the decoder's cross-attention layer, after the attention softmax, used to compute the weighted average in the cross-attention heads.\n     */\n    constructor({ logits, past_key_values, encoder_outputs, decoder_attentions = null, cross_attentions = null }) {\n        super();\n        this.logits = logits;\n        this.past_key_values = past_key_values;\n        this.encoder_outputs = encoder_outputs;\n        this.decoder_attentions = decoder_attentions;\n        this.cross_attentions = cross_attentions;\n    }\n}\n\n/**\n * Base class for outputs of sentence classification models.\n */\nclass SequenceClassifierOutput extends ModelOutput {\n    /**\n     * @param {Object} output The output of the model.\n     * @param {Tensor} output.logits classification (or regression if config.num_labels==1) scores (before SoftMax).\n     */\n    constructor({ logits }) {\n        super();\n        this.logits = logits;\n    }\n}\n\n/**\n * Base class for outputs of token classification models.\n */\nclass TokenClassifierOutput extends ModelOutput {\n    /**\n     * @param {Object} output The output of the model.\n     * @param {Tensor} output.logits Classification scores (before SoftMax).\n     */\n    constructor({ logits }) {\n        super();\n        this.logits = logits;\n    }\n}\n\n/**\n * Base class for masked language models outputs.\n */\nclass MaskedLMOutput extends ModelOutput {\n    /**\n     * @param {Object} output The output of the model.\n     * @param {Tensor} output.logits Prediction scores of the language modeling head (scores for each vocabulary token before SoftMax).\n     */\n    constructor({ logits }) {\n        super();\n        this.logits = logits;\n    }\n}\n\n/**\n * Base class for outputs of question answering models.\n */\nclass QuestionAnsweringModelOutput extends ModelOutput {\n    /**\n     * @param {Object} output The output of the model.\n     * @param {Tensor} output.start_logits Span-start scores (before SoftMax).\n     * @param {Tensor} output.end_logits Span-end scores (before SoftMax).\n     */\n    constructor({ start_logits, end_logits }) {\n        super();\n        this.start_logits = start_logits;\n        this.end_logits = end_logits;\n    }\n}\n\n\n/**\n * Base class for causal language model (or autoregressive) outputs.\n */\nclass CausalLMOutputWithPast extends ModelOutput {\n    /**\n     * @param {Object} output The output of the model.\n     * @param {Tensor} output.logits Prediction scores of the language modeling head (scores for each vocabulary token before softmax).\n     * @param {Tensor} output.past_key_values Contains pre-computed hidden-states (key and values in the self-attention blocks)\n     * that can be used (see `past_key_values` input) to speed up sequential decoding.\n     */\n    constructor({ logits, past_key_values }) {\n        super();\n        this.logits = logits;\n        this.past_key_values = past_key_values;\n    }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHhlbm92YS90cmFuc2Zvcm1lcnMvc3JjL21vZGVscy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSwyQkFBMkI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsU0FBUztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHVDQUF1QztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsWUFBWTtBQUNyQjtBQUNBLGdEQUFnRCwyQkFBMkI7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFJc0I7O0FBT0c7O0FBS0Q7O0FBY087O0FBU0o7O0FBRW1DO0FBQ047QUFDeEQsUUFBUSx1Q0FBdUMsRUFBRSxtREFBSTs7QUFFckQ7QUFDQSxhQUFhLDRDQUE0QztBQUN6RDs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsYUFBYSxpQkFBaUI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsbUJBQW1CO0FBQzlCLGFBQWEsMkJBQTJCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLFNBQVMsRUFBRSxzQ0FBc0M7QUFDakYsdUJBQXVCLDJEQUFZOztBQUVuQztBQUNB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QUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGtCQUFrQixRQUFRO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0Esa0JBQWtCLFFBQVE7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQSxrQkFBa0IsUUFBUTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQSxrQkFBa0IsMEJBQTBCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0Esa0JBQWtCLHlCQUF5QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdHJhbnNmb3JtZXJzanMtcGxheWdyb3VuZC8uL25vZGVfbW9kdWxlcy9AeGVub3ZhL3RyYW5zZm9ybWVycy9zcmMvbW9kZWxzLmpzPzZhYzciXSwic291cmNlc0NvbnRlbnQiOlsiXG4vKipcbiAqIEBmaWxlIERlZmluaXRpb25zIG9mIGFsbCBtb2RlbHMgYXZhaWxhYmxlIGluIFRyYW5zZm9ybWVycy5qcy5cbiAqIFxuICogKipFeGFtcGxlOioqIExvYWQgYW5kIHJ1biBhbiBgQXV0b01vZGVsYC5cbiAqIFxuICogYGBgamF2YXNjcmlwdFxuICogaW1wb3J0IHsgQXV0b01vZGVsLCBBdXRvVG9rZW5pemVyIH0gZnJvbSAnQHhlbm92YS90cmFuc2Zvcm1lcnMnO1xuICpcbiAqIGxldCB0b2tlbml6ZXIgPSBhd2FpdCBBdXRvVG9rZW5pemVyLmZyb21fcHJldHJhaW5lZCgnWGVub3ZhL2JlcnQtYmFzZS11bmNhc2VkJyk7XG4gKiBsZXQgbW9kZWwgPSBhd2FpdCBBdXRvTW9kZWwuZnJvbV9wcmV0cmFpbmVkKCdYZW5vdmEvYmVydC1iYXNlLXVuY2FzZWQnKTtcbiAqXG4gKiBsZXQgaW5wdXRzID0gYXdhaXQgdG9rZW5pemVyKCdJIGxvdmUgdHJhbnNmb3JtZXJzIScpO1xuICogbGV0IHsgbG9naXRzIH0gPSBhd2FpdCBtb2RlbChpbnB1dHMpO1xuICogLy8gVGVuc29yIHtcbiAqIC8vICAgICBkYXRhOiBGbG9hdDMyQXJyYXkoMTgzMTMyKSBbLTcuMTE3NDQzMDg0NzE2Nzk3LCAtNy4xMDc4MTI4ODE0Njk3MjcsIC03LjA5MjEwNDkxMTgwNDE5OSwgLi4uXVxuICogLy8gICAgIGRpbXM6ICgzKSBbMSwgNiwgMzA1MjJdLFxuICogLy8gICAgIHR5cGU6IFwiZmxvYXQzMlwiLFxuICogLy8gICAgIHNpemU6IDE4MzEzMixcbiAqIC8vIH1cbiAqIGBgYFxuICogXG4gKiBXZSBhbHNvIHByb3ZpZGUgb3RoZXIgYEF1dG9Nb2RlbGBzIChsaXN0ZWQgYmVsb3cpLCB3aGljaCB5b3UgY2FuIHVzZSBpbiB0aGUgc2FtZSB3YXkgYXMgdGhlIFB5dGhvbiBsaWJyYXJ5LiBGb3IgZXhhbXBsZTpcbiAqIFxuICogKipFeGFtcGxlOioqIExvYWQgYW5kIHJ1biBhIGBBdXRvTW9kZWxGb3JTZXEyU2VxTE1gLlxuICogYGBgamF2YXNjcmlwdFxuICogaW1wb3J0IHsgQXV0b01vZGVsRm9yU2VxMlNlcUxNLCBBdXRvVG9rZW5pemVyIH0gZnJvbSAnQHhlbm92YS90cmFuc2Zvcm1lcnMnO1xuICogXG4gKiBsZXQgdG9rZW5pemVyID0gYXdhaXQgQXV0b1Rva2VuaXplci5mcm9tX3ByZXRyYWluZWQoJ1hlbm92YS90NS1zbWFsbCcpO1xuICogbGV0IG1vZGVsID0gYXdhaXQgQXV0b01vZGVsRm9yU2VxMlNlcUxNLmZyb21fcHJldHJhaW5lZCgnWGVub3ZhL3Q1LXNtYWxsJyk7XG4gKlxuICogbGV0IHsgaW5wdXRfaWRzIH0gPSBhd2FpdCB0b2tlbml6ZXIoJ3RyYW5zbGF0ZSBFbmdsaXNoIHRvIEdlcm1hbjogSSBsb3ZlIHRyYW5zZm9ybWVycyEnKTtcbiAqIGxldCBvdXRwdXRzID0gYXdhaXQgbW9kZWwuZ2VuZXJhdGUoaW5wdXRfaWRzKTtcbiAqIGxldCBkZWNvZGVkID0gdG9rZW5pemVyLmRlY29kZShvdXRwdXRzWzBdLCB7IHNraXBfc3BlY2lhbF90b2tlbnM6IHRydWUgfSk7XG4gKiAvLyAnSWNoIGxpZWJlIFRyYW5zZm9ybWF0b3JlbiEnXG4gKiBgYGBcbiAqIFxuICogQG1vZHVsZSBtb2RlbHNcbiAqL1xuXG5pbXBvcnQge1xuICAgIEF1dG9Db25maWcsXG59IGZyb20gJy4vY29uZmlncy5qcyc7XG5cbmltcG9ydCB7XG4gICAgQ2FsbGFibGUsXG4gICAgaXNJbnRlZ3JhbE51bWJlcixcbiAgICBpc1R5cGVkQXJyYXksXG4gICAgbWVyZ2VBcnJheXMsXG59IGZyb20gJy4vdXRpbHMvY29yZS5qcyc7XG5cbmltcG9ydCB7XG4gICAgZ2V0TW9kZWxGaWxlLFxuICAgIGdldE1vZGVsSlNPTixcbn0gZnJvbSAnLi91dGlscy9odWIuanMnO1xuXG5pbXBvcnQge1xuICAgIExvZ2l0c1Byb2Nlc3Nvckxpc3QsXG4gICAgR2VuZXJhdGlvbkNvbmZpZyxcbiAgICBGb3JjZVRva2Vuc0xvZ2l0c1Byb2Nlc3NvcixcbiAgICBGb3JjZWRCT1NUb2tlbkxvZ2l0c1Byb2Nlc3NvcixcbiAgICBGb3JjZWRFT1NUb2tlbkxvZ2l0c1Byb2Nlc3NvcixcbiAgICBTdXBwcmVzc1Rva2Vuc0F0QmVnaW5Mb2dpdHNQcm9jZXNzb3IsXG4gICAgV2hpc3BlclRpbWVTdGFtcExvZ2l0c1Byb2Nlc3NvcixcbiAgICBOb1JlcGVhdE5HcmFtTG9naXRzUHJvY2Vzc29yLFxuICAgIFJlcGV0aXRpb25QZW5hbHR5TG9naXRzUHJvY2Vzc29yLFxuXG4gICAgU2FtcGxlcixcbn0gZnJvbSAnLi91dGlscy9nZW5lcmF0aW9uLmpzJztcblxuaW1wb3J0IHtcbiAgICBjYXQsXG4gICAgZHluYW1pY1RpbWVXYXJwaW5nLFxuICAgIG1lYW4sXG4gICAgc3RhY2ssXG4gICAgc3RkX21lYW4sXG4gICAgVGVuc29yLFxufSBmcm9tICcuL3V0aWxzL3RlbnNvci5qcyc7XG5cbmltcG9ydCB7IGV4ZWN1dGlvblByb3ZpZGVycywgT05OWCB9IGZyb20gJy4vYmFja2VuZHMvb25ueC5qcyc7XG5pbXBvcnQgeyBtZWRpYW5GaWx0ZXIsIHJvdW5kIH0gZnJvbSAnLi90cmFuc2Zvcm1lcnMuanMnO1xuY29uc3QgeyBJbmZlcmVuY2VTZXNzaW9uLCBUZW5zb3I6IE9OTlhUZW5zb3IgfSA9IE9OTlg7XG5cbi8qKlxuICogQHR5cGVkZWYge2ltcG9ydCgnLi91dGlscy9odWIuanMnKS5QcmV0cmFpbmVkT3B0aW9uc30gUHJldHJhaW5lZE9wdGlvbnNcbiAqL1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBNb2RlbCB0eXBlczogdXNlZCBpbnRlcm5hbGx5XG5jbGFzcyBNb2RlbFR5cGUgeyB9O1xuXG4vLyBFaXRoZXIgZW5jb2Rlci1vbmx5IG9yIGVuY29kZXItZGVjb2RlciAoYW5kIHdpbGwgYmUgZGVjaWRlZCBieSBgbW9kZWwuY29uZmlnLmlzX2VuY29kZXJfZGVjb2RlcmApXG5jbGFzcyBFbmNvZGVyT25seU1vZGVsVHlwZSBleHRlbmRzIE1vZGVsVHlwZSB7IH07XG5jbGFzcyBFbmNvZGVyRGVjb2Rlck1vZGVsVHlwZSBleHRlbmRzIE1vZGVsVHlwZSB7IH07XG5jbGFzcyBTZXEyU2VxTW9kZWxUeXBlIGV4dGVuZHMgRW5jb2RlckRlY29kZXJNb2RlbFR5cGUgeyB9O1xuY2xhc3MgRGVjb2Rlck9ubHlNb2RlbFR5cGUgZXh0ZW5kcyBNb2RlbFR5cGUgeyB9O1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gSGVscGVyIGZ1bmN0aW9uc1xuXG4vLyBXaWxsIGJlIHBvcHVsYXRlZCBsYXRlclxuY29uc3QgTU9ERUxfVFlQRV9NQVBQSU5HID0gbmV3IE1hcCgpO1xuY29uc3QgTU9ERUxfQ0xBU1NfTUFQUElORyA9IG5ldyBNYXAoKTtcblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIHdoaWNoIGBmb3J3YXJkYCBtZXRob2QgdG8gcnVuIGZvciBhIHNwZWNpZmljIG1vZGVsLlxuICogQHBhcmFtIHtPYmplY3R9IHNlbGYgVGhlIGNhbGxpbmcgb2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gbW9kZWxfaW5wdXRzIFRoZSBpbnB1dHMgdG8gYmUgc2VudCB0byB0aGUgbW9kZWxcbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD59IFRoZSBtb2RlbCBvdXRwdXRcbiAqL1xuYXN5bmMgZnVuY3Rpb24gZm9yd2FyZChzZWxmLCBtb2RlbF9pbnB1dHMpIHtcbiAgICBpZiAoTU9ERUxfVFlQRV9NQVBQSU5HLmdldChzZWxmLmNvbnN0cnVjdG9yLm5hbWUpID09PSBEZWNvZGVyT25seU1vZGVsVHlwZSkge1xuICAgICAgICByZXR1cm4gYXdhaXQgZGVjb2RlckZvcndhcmQoc2VsZiwgbW9kZWxfaW5wdXRzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gYXdhaXQgZW5jb2RlckZvcndhcmQoc2VsZiwgbW9kZWxfaW5wdXRzKTtcbiAgICB9XG59XG5cbi8qKlxuICogQ29uc3RydWN0cyBhbiBJbmZlcmVuY2VTZXNzaW9uIHVzaW5nIGEgbW9kZWwgZmlsZSBsb2NhdGVkIGF0IHRoZSBzcGVjaWZpZWQgcGF0aC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBwcmV0cmFpbmVkX21vZGVsX25hbWVfb3JfcGF0aCBUaGUgcGF0aCB0byB0aGUgZGlyZWN0b3J5IGNvbnRhaW5pbmcgdGhlIG1vZGVsIGZpbGUuXG4gKiBAcGFyYW0ge3N0cmluZ30gZmlsZU5hbWUgVGhlIG5hbWUgb2YgdGhlIG1vZGVsIGZpbGUuXG4gKiBAcGFyYW0ge1ByZXRyYWluZWRPcHRpb25zfSBvcHRpb25zIEFkZGl0aW9uYWwgb3B0aW9ucyBmb3IgbG9hZGluZyB0aGUgbW9kZWwuXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxJbmZlcmVuY2VTZXNzaW9uPn0gQSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYW4gSW5mZXJlbmNlU2Vzc2lvbiBvYmplY3QuXG4gKiBAcHJpdmF0ZVxuICovXG5hc3luYyBmdW5jdGlvbiBjb25zdHJ1Y3RTZXNzaW9uKHByZXRyYWluZWRfbW9kZWxfbmFtZV9vcl9wYXRoLCBmaWxlTmFtZSwgb3B0aW9ucykge1xuICAgIC8vIFRPRE8gYWRkIG9wdGlvbiBmb3IgdXNlciB0byBmb3JjZSBzcGVjaWZ5IHRoZWlyIGRlc2lyZWQgZXhlY3V0aW9uIHByb3ZpZGVyXG4gICAgbGV0IG1vZGVsRmlsZU5hbWUgPSBgb25ueC8ke2ZpbGVOYW1lfSR7b3B0aW9ucy5xdWFudGl6ZWQgPyAnX3F1YW50aXplZCcgOiAnJ30ub25ueGA7XG4gICAgbGV0IGJ1ZmZlciA9IGF3YWl0IGdldE1vZGVsRmlsZShwcmV0cmFpbmVkX21vZGVsX25hbWVfb3JfcGF0aCwgbW9kZWxGaWxlTmFtZSwgdHJ1ZSwgb3B0aW9ucyk7XG5cbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gYXdhaXQgSW5mZXJlbmNlU2Vzc2lvbi5jcmVhdGUoYnVmZmVyLCB7XG4gICAgICAgICAgICBleGVjdXRpb25Qcm92aWRlcnMsXG4gICAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAvLyBJZiB0aGUgZXhlY3V0aW9uIHByb3ZpZGVkIHdhcyBvbmx5IHdhc20sIHRocm93IHRoZSBlcnJvclxuICAgICAgICBpZiAoZXhlY3V0aW9uUHJvdmlkZXJzLmxlbmd0aCA9PT0gMSAmJiBleGVjdXRpb25Qcm92aWRlcnNbMF0gPT09ICd3YXNtJykge1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc29sZS53YXJuKGVycik7XG4gICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgICdTb21ldGhpbmcgd2VudCB3cm9uZyBkdXJpbmcgbW9kZWwgY29uc3RydWN0aW9uIChtb3N0IGxpa2VseSBhIG1pc3Npbmcgb3BlcmF0aW9uKS4gJyArXG4gICAgICAgICAgICAnVXNpbmcgYHdhc21gIGFzIGEgZmFsbGJhY2suICdcbiAgICAgICAgKVxuICAgICAgICByZXR1cm4gYXdhaXQgSW5mZXJlbmNlU2Vzc2lvbi5jcmVhdGUoYnVmZmVyLCB7XG4gICAgICAgICAgICBleGVjdXRpb25Qcm92aWRlcnM6IFsnd2FzbSddXG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuLyoqXG4gKiBWYWxpZGF0ZSBtb2RlbCBpbnB1dHNcbiAqIEBwYXJhbSB7SW5mZXJlbmNlU2Vzc2lvbn0gc2Vzc2lvbiBUaGUgSW5mZXJlbmNlU2Vzc2lvbiBvYmplY3QgdGhhdCB3aWxsIGJlIHJ1bi5cbiAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dHMgVGhlIGlucHV0cyB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD59IEEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSBjaGVja2VkIGlucHV0cy5cbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiBhbnkgaW5wdXRzIGFyZSBtaXNzaW5nLlxuICogQHByaXZhdGVcbiAqL1xuYXN5bmMgZnVuY3Rpb24gdmFsaWRhdGVJbnB1dHMoc2Vzc2lvbiwgaW5wdXRzKSB7XG4gICAgLy8gTk9URTogT25seSBjcmVhdGUgYSBzaGFsbG93IGNvcHlcbiAgICBjb25zdCBjaGVja2VkSW5wdXRzID0ge307XG4gICAgY29uc3QgbWlzc2luZ0lucHV0cyA9IFtdO1xuICAgIGZvciAobGV0IGlucHV0TmFtZSBvZiBzZXNzaW9uLmlucHV0TmFtZXMpIHtcbiAgICAgICAgaWYgKGlucHV0c1tpbnB1dE5hbWVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG1pc3NpbmdJbnB1dHMucHVzaChpbnB1dE5hbWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2hlY2tlZElucHV0c1tpbnB1dE5hbWVdID0gaW5wdXRzW2lucHV0TmFtZV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKG1pc3NpbmdJbnB1dHMubGVuZ3RoID4gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgQW4gZXJyb3Igb2NjdXJyZWQgZHVyaW5nIG1vZGVsIGV4ZWN1dGlvbjogXCJNaXNzaW5nIHRoZSBmb2xsb3dpbmcgaW5wdXRzOiAke21pc3NpbmdJbnB1dHMuam9pbignLCAnKX0uYCk7XG4gICAgfVxuXG4gICAgY29uc3QgbnVtSW5wdXRzUHJvdmlkZWQgPSBPYmplY3Qua2V5cyhpbnB1dHMpLmxlbmd0aDtcbiAgICBjb25zdCBudW1JbnB1dHNOZWVkZWQgPSBzZXNzaW9uLmlucHV0TmFtZXMubGVuZ3RoO1xuICAgIGlmIChudW1JbnB1dHNQcm92aWRlZCA+IG51bUlucHV0c05lZWRlZCkge1xuICAgICAgICAvLyBObyBtaXNzaW5nIGlucHV0cywgYnV0IHRvbyBtYW55IGlucHV0cyB3ZXJlIHByb3ZpZGVkLlxuICAgICAgICAvLyBXYXJuIHRoZSB1c2VyIGFuZCBpZ25vcmUgdGhlIGV4dHJhIGlucHV0cy5cbiAgICAgICAgbGV0IGlnbm9yZWQgPSBPYmplY3Qua2V5cyhpbnB1dHMpLmZpbHRlcihpbnB1dE5hbWUgPT4gIXNlc3Npb24uaW5wdXROYW1lcy5pbmNsdWRlcyhpbnB1dE5hbWUpKTtcbiAgICAgICAgY29uc29sZS53YXJuKGBXQVJOSU5HOiBUb28gbWFueSBpbnB1dHMgd2VyZSBwcm92aWRlZCAoJHtudW1JbnB1dHNQcm92aWRlZH0gPiAke251bUlucHV0c05lZWRlZH0pLiBUaGUgZm9sbG93aW5nIGlucHV0cyB3aWxsIGJlIGlnbm9yZWQ6IFwiJHtpZ25vcmVkLmpvaW4oJywgJyl9XCIuYCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNoZWNrZWRJbnB1dHM7XG59XG5cbi8qKlxuICogRXhlY3V0ZXMgYW4gSW5mZXJlbmNlU2Vzc2lvbiB1c2luZyB0aGUgc3BlY2lmaWVkIGlucHV0cy5cbiAqIE5PVEU6IGBpbnB1dHNgIG11c3QgY29udGFpbiBhdCBsZWFzdCB0aGUgaW5wdXQgbmFtZXMgb2YgdGhlIG1vZGVsLlxuICogIC0gSWYgYWRkaXRpb25hbCBpbnB1dHMgYXJlIHBhc3NlZCwgdGhleSB3aWxsIGJlIGlnbm9yZWQuXG4gKiAgLSBJZiBpbnB1dHMgYXJlIG1pc3NpbmcsIGFuIGVycm9yIHdpbGwgYmUgdGhyb3duLlxuICogXG4gKiBAcGFyYW0ge0luZmVyZW5jZVNlc3Npb259IHNlc3Npb24gVGhlIEluZmVyZW5jZVNlc3Npb24gb2JqZWN0IHRvIHJ1bi5cbiAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dHMgQW4gb2JqZWN0IHRoYXQgbWFwcyBpbnB1dCBuYW1lcyB0byBpbnB1dCB0ZW5zb3JzLlxuICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0Pn0gQSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYW4gb2JqZWN0IHRoYXQgbWFwcyBvdXRwdXQgbmFtZXMgdG8gb3V0cHV0IHRlbnNvcnMuXG4gKiBAcHJpdmF0ZVxuICovXG5hc3luYyBmdW5jdGlvbiBzZXNzaW9uUnVuKHNlc3Npb24sIGlucHV0cykge1xuICAgIGNvbnN0IGNoZWNrZWRJbnB1dHMgPSBhd2FpdCB2YWxpZGF0ZUlucHV0cyhzZXNzaW9uLCBpbnB1dHMpO1xuICAgIHRyeSB7XG4gICAgICAgIGxldCBvdXRwdXQgPSBhd2FpdCBzZXNzaW9uLnJ1bihjaGVja2VkSW5wdXRzKTtcbiAgICAgICAgb3V0cHV0ID0gcmVwbGFjZVRlbnNvcnMob3V0cHV0KTtcbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8vIFRoaXMgdXN1YWxseSBvY2N1cnMgd2hlbiB0aGUgaW5wdXRzIGFyZSBvZiB0aGUgd3JvbmcgdHlwZS5cbiAgICAgICAgY29uc29sZS5lcnJvcihgQW4gZXJyb3Igb2NjdXJyZWQgZHVyaW5nIG1vZGVsIGV4ZWN1dGlvbjogXCIke2V9XCIuYCk7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0lucHV0cyBnaXZlbiB0byBtb2RlbDonLCBjaGVja2VkSW5wdXRzKTtcbiAgICAgICAgdGhyb3cgZTtcbiAgICB9XG59XG5cbi8qKlxuICogUmVwbGFjZXMgT05OWCBUZW5zb3Igb2JqZWN0cyB3aXRoIGN1c3RvbSBUZW5zb3Igb2JqZWN0cyB0byBzdXBwb3J0IGFkZGl0aW9uYWwgZnVuY3Rpb25zLlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRvIHJlcGxhY2UgdGVuc29yIG9iamVjdHMgaW4uXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgb2JqZWN0IHdpdGggdGVuc29yIG9iamVjdHMgcmVwbGFjZWQgYnkgY3VzdG9tIFRlbnNvciBvYmplY3RzLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcmVwbGFjZVRlbnNvcnMob2JqKSB7XG4gICAgZm9yIChsZXQgcHJvcCBpbiBvYmopIHtcbiAgICAgICAgaWYgKG9ialtwcm9wXSBpbnN0YW5jZW9mIE9OTlhUZW5zb3IpIHtcbiAgICAgICAgICAgIG9ialtwcm9wXSA9IG5ldyBUZW5zb3Iob2JqW3Byb3BdKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygb2JqW3Byb3BdID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgcmVwbGFjZVRlbnNvcnMob2JqW3Byb3BdKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2JqO1xufVxuXG5cbi8qKlxuICogQ29udmVydHMgYW4gYXJyYXkgb3IgVGVuc29yIG9mIGludGVnZXJzIHRvIGFuIGludDY0IFRlbnNvci5cbiAqIEBwYXJhbSB7QXJyYXl8VGVuc29yfSBpdGVtcyBUaGUgaW5wdXQgaW50ZWdlcnMgdG8gYmUgY29udmVydGVkLlxuICogQHJldHVybnMge1RlbnNvcn0gVGhlIGludDY0IFRlbnNvciB3aXRoIHRoZSBjb252ZXJ0ZWQgdmFsdWVzLlxuICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBpbnB1dCBhcnJheSBpcyBlbXB0eSBvciB0aGUgaW5wdXQgaXMgYSBiYXRjaGVkIFRlbnNvciBhbmQgbm90IGFsbCBzZXF1ZW5jZXMgaGF2ZSB0aGUgc2FtZSBsZW5ndGguXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiB0b0k2NFRlbnNvcihpdGVtcykge1xuICAgIGlmIChpdGVtcyBpbnN0YW5jZW9mIFRlbnNvcikge1xuICAgICAgICByZXR1cm4gaXRlbXM7XG4gICAgfVxuICAgIC8vIGl0ZW1zIGlzIGFuIGFycmF5XG4gICAgaWYgKGl0ZW1zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBFcnJvcihcIml0ZW1zIG11c3QgYmUgbm9uLWVtcHR5XCIpO1xuICAgIH1cblxuICAgIGlmIChBcnJheS5pc0FycmF5KGl0ZW1zWzBdKSkge1xuICAgICAgICAvLyBiYXRjaGVkXG4gICAgICAgIGlmIChpdGVtcy5zb21lKHggPT4geC5sZW5ndGggIT09IGl0ZW1zWzBdLmxlbmd0aCkpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKFwiVW5hYmxlIHRvIGNyZWF0ZSB0ZW5zb3IsIHlvdSBzaG91bGQgcHJvYmFibHkgYWN0aXZhdGUgdHJ1bmNhdGlvbiBhbmQvb3IgcGFkZGluZyB3aXRoICdwYWRkaW5nPVRydWUnIGFuZC9vciAndHJ1bmNhdGlvbj1UcnVlJyB0byBoYXZlIGJhdGNoZWQgdGVuc29ycyB3aXRoIHRoZSBzYW1lIGxlbmd0aC5cIilcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXcgVGVuc29yKCdpbnQ2NCcsXG4gICAgICAgICAgICBCaWdJbnQ2NEFycmF5LmZyb20oaXRlbXMuZmxhdCgpLm1hcCh4ID0+IEJpZ0ludCh4KSkpLFxuICAgICAgICAgICAgW2l0ZW1zLmxlbmd0aCwgaXRlbXNbMF0ubGVuZ3RoXVxuICAgICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vZmxhdFxuICAgICAgICByZXR1cm4gbmV3IFRlbnNvcignaW50NjQnLFxuICAgICAgICAgICAgQmlnSW50NjRBcnJheS5mcm9tKGl0ZW1zLm1hcCh4ID0+IEJpZ0ludCh4KSkpLFxuICAgICAgICAgICAgWzEsIGl0ZW1zLmxlbmd0aF1cbiAgICAgICAgKTtcbiAgICB9XG59XG5cbi8qKlxuICogUHJlcGFyZXMgYW4gYXR0ZW50aW9uIG1hc2sgZm9yIGEgc2VxdWVuY2Ugb2YgdG9rZW5zIGJhc2VkIG9uIGNvbmZpZ3VyYXRpb24gb3B0aW9ucy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzZWxmIFRoZSBjYWxsaW5nIG9iamVjdCBpbnN0YW5jZS5cbiAqIEBwYXJhbSB7VGVuc29yfSB0b2tlbnMgVGhlIGlucHV0IHRva2Vucy5cbiAqIEByZXR1cm5zIHtUZW5zb3J9IFRoZSBhdHRlbnRpb24gbWFzayB0ZW5zb3IuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBwcmVwYXJlQXR0ZW50aW9uTWFzayhzZWxmLCB0b2tlbnMpIHtcblxuICAgIC8vIFByZXBhcmUgYXR0ZW50aW9uIG1hc2tcbiAgICBsZXQgcGFkX3Rva2VuX2lkID0gc2VsZi5jb25maWcucGFkX3Rva2VuX2lkID8/IG51bGw7XG4gICAgbGV0IGVvc190b2tlbl9pZCA9IHNlbGYuY29uZmlnLmVvc190b2tlbl9pZCA/PyBudWxsO1xuICAgIGlmIChpc0ludGVncmFsTnVtYmVyKGVvc190b2tlbl9pZCkpIHtcbiAgICAgICAgZW9zX3Rva2VuX2lkID0gW2Vvc190b2tlbl9pZF07XG4gICAgfVxuXG4gICAgbGV0IGlzX3BhZF90b2tlbl9pbl9pbnB1dHMgPSB0b2tlbnMuaW5kZXhPZihwYWRfdG9rZW5faWQpICE9PSAtMTtcbiAgICBsZXQgaXNfcGFkX3Rva2VuX25vdF9lcXVhbF90b19lb3NfdG9rZW5faWQgPSAoZW9zX3Rva2VuX2lkID09PSBudWxsKSB8fCAhZW9zX3Rva2VuX2lkLmluY2x1ZGVzKHBhZF90b2tlbl9pZClcblxuICAgIGlmIChpc19wYWRfdG9rZW5faW5faW5wdXRzICYmIGlzX3BhZF90b2tlbl9ub3RfZXF1YWxfdG9fZW9zX3Rva2VuX2lkKSB7XG4gICAgICAgIGxldCBkYXRhID0gQmlnSW50NjRBcnJheS5mcm9tKFxuICAgICAgICAgICAgLy8gTm90ZTogIT0gc28gdGhhdCBpbnQgbWF0Y2hlcyBiaWdpbnRcbiAgICAgICAgICAgIHRva2Vucy5kYXRhLm1hcCh4ID0+IHggIT0gcGFkX3Rva2VuX2lkKVxuICAgICAgICApXG4gICAgICAgIHJldHVybiBuZXcgVGVuc29yKCdpbnQ2NCcsIGRhdGEsIHRva2Vucy5kaW1zKVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBuZXcgVGVuc29yKFxuICAgICAgICAgICAgJ2ludDY0JyxcbiAgICAgICAgICAgIG5ldyBCaWdJbnQ2NEFycmF5KHRva2Vucy5kYXRhLmxlbmd0aCkuZmlsbCgxbiksXG4gICAgICAgICAgICB0b2tlbnMuZGltc1xuICAgICAgICApXG4gICAgfVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBib29sZWFuIHRlbnNvciB3aXRoIGEgc2luZ2xlIHZhbHVlLlxuICogQHBhcmFtIHtib29sZWFufSB2YWx1ZSBUaGUgdmFsdWUgb2YgdGhlIHRlbnNvci5cbiAqIEByZXR1cm5zIHtUZW5zb3J9IFRoZSBib29sZWFuIHRlbnNvci5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGJvb2xUZW5zb3IodmFsdWUpIHtcbiAgICByZXR1cm4gbmV3IFRlbnNvcignYm9vbCcsIFt2YWx1ZV0sIFsxXSk7XG59XG5cbi8vIEpTIGRvZXNuJ3Qgc3VwcG9ydCBtaXhpbnMsIHNvIHdlIGRlZmluZSBzb21lIHJldXNlZCBmdW5jdGlvbnMgaGVyZSwgYW5kIGFsbG93IFwidGhpc1wiIHRvIGJlIHBhc3NlZCBpblxuLyoqXG4gKiBQZXJmb3JtIGZvcndhcmQgcGFzcyBvbiB0aGUgc2VxMnNlcSBtb2RlbCAoYm90aCBlbmNvZGVyIGFuZCBkZWNvZGVyKS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzZWxmIFRoZSBzZXEyc2VxIG1vZGVsIG9iamVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBtb2RlbF9pbnB1dHMgVGhlIGlucHV0IG9iamVjdCBmb3IgdGhlIG1vZGVsIGNvbnRhaW5pbmcgZW5jb2RlciBhbmQgZGVjb2RlciBpbnB1dHMuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBUaGUgb3B0aW9uc1xuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5hZGRfZGVjb2Rlcl9wa3Y9dHJ1ZV0gRmxhZyB0byBhZGQgdGhlIGRlY29kZXIgcGFzdCBrZXkgdmFsdWVzLlxuICogQHJldHVybnMge1Byb21pc2U8U2VxMlNlcUxNT3V0cHV0Pn0gUHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggdGhlIG91dHB1dCBvZiB0aGUgc2VxMnNlcSBtb2RlbC5cbiAqIEBwcml2YXRlXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHNlcTJzZXFGb3J3YXJkKHNlbGYsIG1vZGVsX2lucHV0cywge1xuICAgIGFkZF9kZWNvZGVyX3BrdiA9IHRydWVcbn0gPSB7fSkge1xuICAgIGxldCB7IGVuY29kZXJfb3V0cHV0cywgcGFzdF9rZXlfdmFsdWVzIH0gPSBtb2RlbF9pbnB1dHM7XG5cbiAgICBpZiAoIWVuY29kZXJfb3V0cHV0cykge1xuICAgICAgICAvLyBFbmNvZGVyIG91dHB1dHMgYXJlIG5vdCBnaXZlbiwgc28gd2UgbXVzdCBjb21wdXRlIHRoZW0uXG4gICAgICAgIGVuY29kZXJfb3V0cHV0cyA9IChhd2FpdCBlbmNvZGVyRm9yd2FyZChzZWxmLCBtb2RlbF9pbnB1dHMpKS5sYXN0X2hpZGRlbl9zdGF0ZTtcbiAgICB9XG4gICAgbGV0IGRlY29kZXJGZWVkcyA9IHtcbiAgICAgICAgaW5wdXRfaWRzOiBtb2RlbF9pbnB1dHMuZGVjb2Rlcl9pbnB1dF9pZHMsXG4gICAgICAgIGVuY29kZXJfaGlkZGVuX3N0YXRlczogZW5jb2Rlcl9vdXRwdXRzLFxuICAgICAgICB1c2VfY2FjaGVfYnJhbmNoOiBib29sVGVuc29yKCEhcGFzdF9rZXlfdmFsdWVzKVxuICAgIH07XG5cbiAgICBpZiAoc2VsZi5kZWNvZGVyX21lcmdlZF9zZXNzaW9uLmlucHV0TmFtZXMuaW5jbHVkZXMoJ2VuY29kZXJfYXR0ZW50aW9uX21hc2snKSkge1xuICAgICAgICBkZWNvZGVyRmVlZHMuZW5jb2Rlcl9hdHRlbnRpb25fbWFzayA9IG1vZGVsX2lucHV0cy5hdHRlbnRpb25fbWFza1xuICAgIH1cbiAgICBzZWxmLmFkZFBhc3RLZXlWYWx1ZXMoZGVjb2RlckZlZWRzLCBwYXN0X2tleV92YWx1ZXMsIGFkZF9kZWNvZGVyX3Brdik7XG5cbiAgICBjb25zdCBkZWNvZGVyUmVzdWx0cyA9IGF3YWl0IHNlc3Npb25SdW4oc2VsZi5kZWNvZGVyX21lcmdlZF9zZXNzaW9uLCBkZWNvZGVyRmVlZHMpO1xuICAgIGxldCBsb2dpdHMgPSBkZWNvZGVyUmVzdWx0cy5sb2dpdHM7XG4gICAgcGFzdF9rZXlfdmFsdWVzID0gc2VsZi5nZXRQYXN0S2V5VmFsdWVzKGRlY29kZXJSZXN1bHRzLCBwYXN0X2tleV92YWx1ZXMpO1xuXG4gICAgLy8gR2V0IGNyb3NzIGF0dGVudGlvbiBhbmQvb3IgZGVjb2RlciBhdHRlbnRpb25zIGlmIHRoZXkgYXJlIHByZXNlbnRcbiAgICBjb25zdCBhdHRucyA9IHNlbGYuZ2V0QXR0ZW50aW9ucyhkZWNvZGVyUmVzdWx0cyk7XG5cbiAgICByZXR1cm4gbmV3IFNlcTJTZXFMTU91dHB1dCh7IGxvZ2l0cywgcGFzdF9rZXlfdmFsdWVzLCBlbmNvZGVyX291dHB1dHMsIC4uLmF0dG5zIH0pO1xufVxuXG4vKipcbiAqIFN0YXJ0IHRoZSBiZWFtIHNlYXJjaCBwcm9jZXNzIGZvciB0aGUgc2VxMnNlcSBtb2RlbC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzZWxmIFRoZSBzZXEyc2VxIG1vZGVsIG9iamVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0W119IGlucHV0VG9rZW5JZHMgQXJyYXkgb2YgaW5wdXQgdG9rZW4gaWRzIGZvciBlYWNoIGlucHV0IHNlcXVlbmNlLlxuICogQHBhcmFtIHtudW1iZXJ9IG51bU91dHB1dFRva2VucyBUaGUgbWF4aW11bSBudW1iZXIgb2Ygb3V0cHV0IHRva2VucyBmb3IgdGhlIG1vZGVsLlxuICogQHBhcmFtIHtib29sZWFufSBbcmVxdWlyZXNfYXR0ZW50aW9uX21hc2s9dHJ1ZV0gRmxhZyB0byBpbmRpY2F0ZSBpZiB0aGUgbW9kZWwgcmVxdWlyZXMgYW4gYXR0ZW50aW9uIG1hc2suXG4gKiBAcmV0dXJucyB7T2JqZWN0W119IEFycmF5IG9mIGJlYW0gc2VhcmNoIG9iamVjdHMuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBzZXEyc2VxU3RhcnRCZWFtcyhzZWxmLCBpbnB1dFRva2VuSWRzLCBudW1PdXRwdXRUb2tlbnMsIHJlcXVpcmVzX2F0dGVudGlvbl9tYXNrID0gdHJ1ZSkge1xuICAgIGxldCBiZWFtcyA9IFtdO1xuICAgIGxldCBiZWFtSWQgPSAwO1xuXG4gICAgLy8gZGVjb2Rlcl9pbnB1dF9pZHMgPT0gb3V0cHV0X3Rva2VuX2lkc1xuICAgIGxldCBkZWNvZGVyX2lucHV0X2lkcyA9IHNlbGYuY29uZmlnLmRlY29kZXJfc3RhcnRfdG9rZW5faWQ7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGRlY29kZXJfaW5wdXRfaWRzKSkge1xuICAgICAgICBkZWNvZGVyX2lucHV0X2lkcyA9IFtkZWNvZGVyX2lucHV0X2lkc107XG4gICAgfVxuXG4gICAgZm9yIChsZXQgdG9rZW5zIG9mIGlucHV0VG9rZW5JZHMpIHtcbiAgICAgICAgLy8gVE9ETzogSW1wcm92ZVxuICAgICAgICAvLyBDdXJyZW50bHksIGp1c3QgYWRkIGJhY2sgYmF0Y2ggZGltZW5zaW9uLlxuICAgICAgICAvLyBJbiBmdXR1cmUsIGFsbG93IGZvciB0cnVlIHBhcmFsbGVsIGV4ZWN1dGlvblxuICAgICAgICB0b2tlbnMuZGltcyA9IFsxLCAuLi50b2tlbnMuZGltc11cblxuICAgICAgICAvLyBDcmVhdGUgYmVhbVxuICAgICAgICBsZXQgc3RhcnQgPSB7XG4gICAgICAgICAgICBpbnB1dHM6IHRva2VucyxcbiAgICAgICAgICAgIGVuY29kZXJfb3V0cHV0czogbnVsbCxcbiAgICAgICAgICAgIHByZXZfbW9kZWxfb3V0cHV0czogbnVsbCxcblxuICAgICAgICAgICAgb3V0cHV0X3Rva2VuX2lkczogZGVjb2Rlcl9pbnB1dF9pZHMsXG4gICAgICAgICAgICBkb25lOiBmYWxzZSxcbiAgICAgICAgICAgIHNjb3JlOiAwLFxuICAgICAgICAgICAgaWQ6IGJlYW1JZCsrIC8vIGFzc2lnbiB1bmlxdWUgaWQgdG8gYmVhbXNcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZXF1aXJlc19hdHRlbnRpb25fbWFzaykge1xuICAgICAgICAgICAgc3RhcnQuYXR0ZW50aW9uX21hc2sgPSBwcmVwYXJlQXR0ZW50aW9uTWFzayhzZWxmLCB0b2tlbnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgYmVhbXMucHVzaChzdGFydCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJlYW1zO1xufVxuXG4vKipcbiAqIFJ1biBiZWFtIHNlYXJjaCBvbiB0aGUgc2VxMnNlcSBtb2RlbCBmb3IgYSBzaW5nbGUgYmVhbS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzZWxmIFRoZSBzZXEyc2VxIG1vZGVsIG9iamVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBiZWFtIFRoZSBiZWFtIHNlYXJjaCBvYmplY3QgZm9yIHdoaWNoIHRvIHJ1biB0aGUgbW9kZWwuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBvcHRpb25zXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuaW5wdXRfbmFtZT0naW5wdXRfaWRzJ10gVGhlIG5hbWUgb2YgdGhlIGlucHV0IHRlbnNvciBmb3IgdGhlIGVuY29kZXIuXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgb3V0cHV0IG9mIHRoZSBzZXEyc2VxIG1vZGVsIGZvciB0aGUgZ2l2ZW4gYmVhbS5cbiAqIEBwcml2YXRlXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHNlcTJzZXFSdW5CZWFtKHNlbGYsIGJlYW0sIHtcbiAgICBpbnB1dF9uYW1lID0gJ2lucHV0X2lkcycsXG59ID0ge31cbikge1xuICAgIC8vIDEuIFByZXBhcmVcbiAgICBsZXQgbW9kZWxfaW5wdXRzID0ge1xuICAgICAgICBbaW5wdXRfbmFtZV06IGJlYW0uaW5wdXRzLFxuICAgICAgICBkZWNvZGVyX2lucHV0X2lkczogdG9JNjRUZW5zb3IoYmVhbS5vdXRwdXRfdG9rZW5faWRzLnNsaWNlKC0xKSksXG4gICAgICAgIGVuY29kZXJfb3V0cHV0czogYmVhbS5lbmNvZGVyX291dHB1dHMsXG4gICAgICAgIHBhc3Rfa2V5X3ZhbHVlczogYmVhbS5wcmV2X21vZGVsX291dHB1dHM/LnBhc3Rfa2V5X3ZhbHVlcyxcbiAgICB9XG4gICAgaWYgKGJlYW0uYXR0ZW50aW9uX21hc2spIHtcbiAgICAgICAgbW9kZWxfaW5wdXRzLmF0dGVudGlvbl9tYXNrID0gYmVhbS5hdHRlbnRpb25fbWFza1xuICAgIH1cblxuICAgIC8vIDIuIFJ1blxuICAgIGxldCBvdXRwdXQgPSBhd2FpdCBzZWxmLmZvcndhcmQobW9kZWxfaW5wdXRzKTtcblxuICAgIC8vIDMuIFVwZGF0ZVxuICAgIGJlYW0ucHJldl9tb2RlbF9vdXRwdXRzID0gb3V0cHV0O1xuICAgIGJlYW0uZW5jb2Rlcl9vdXRwdXRzID0gb3V0cHV0LmVuY29kZXJfb3V0cHV0cztcblxuICAgIHJldHVybiBvdXRwdXQ7XG59XG5cbi8qKlxuICogRm9yd2FyZCBwYXNzIG9mIGFuIGVuY29kZXIgbW9kZWwuXG4gKiBAcGFyYW0ge09iamVjdH0gc2VsZiBUaGUgZW5jb2RlciBtb2RlbC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBtb2RlbF9pbnB1dHMgVGhlIGlucHV0IGRhdGEgdG8gYmUgdXNlZCBmb3IgdGhlIGZvcndhcmQgcGFzcy5cbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD59IFByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIGFuIG9iamVjdCBjb250YWluaW5nIHRoZSBtb2RlbCdzIG91dHB1dHMuXG4gKiBAcHJpdmF0ZVxuICovXG5hc3luYyBmdW5jdGlvbiBlbmNvZGVyRm9yd2FyZChzZWxmLCBtb2RlbF9pbnB1dHMpIHtcbiAgICBsZXQgZW5jb2RlckZlZWRzID0ge307XG4gICAgZm9yIChsZXQga2V5IG9mIHNlbGYuc2Vzc2lvbi5pbnB1dE5hbWVzKSB7XG4gICAgICAgIGVuY29kZXJGZWVkc1trZXldID0gbW9kZWxfaW5wdXRzW2tleV07XG4gICAgfVxuICAgIHJldHVybiBhd2FpdCBzZXNzaW9uUnVuKHNlbGYuc2Vzc2lvbiwgZW5jb2RlckZlZWRzKTtcbn1cblxuXG4vKipcbiAqIEZvcndhcmQgcGFzcyBvZiBhIGRlY29kZXIgbW9kZWwuXG4gKiBAcGFyYW0ge09iamVjdH0gc2VsZiBUaGUgZGVjb2RlciBtb2RlbC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBtb2RlbF9pbnB1dHMgVGhlIGlucHV0IGRhdGEgdG8gYmUgdXNlZCBmb3IgdGhlIGZvcndhcmQgcGFzcy5cbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD59IFByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIGFuIG9iamVjdCBjb250YWluaW5nIHRoZSBsb2dpdHMgYW5kIHBhc3Qga2V5IHZhbHVlcy5cbiAqIEBwcml2YXRlXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGRlY29kZXJGb3J3YXJkKHNlbGYsIG1vZGVsX2lucHV0cykge1xuICAgIGxldCB7IGlucHV0X2lkcywgcGFzdF9rZXlfdmFsdWVzLCBhdHRlbnRpb25fbWFzayB9ID0gbW9kZWxfaW5wdXRzO1xuICAgIGxldCBkZWNvZGVyRmVlZHMgPSB7XG4gICAgICAgIGlucHV0X2lkczogaW5wdXRfaWRzLFxuICAgICAgICBhdHRlbnRpb25fbWFzazogYXR0ZW50aW9uX21hc2sgPz8gcHJlcGFyZUF0dGVudGlvbk1hc2soc2VsZiwgaW5wdXRfaWRzKSxcbiAgICAgICAgdXNlX2NhY2hlX2JyYW5jaDogYm9vbFRlbnNvcihwYXN0X2tleV92YWx1ZXMgIT09IG51bGwpXG4gICAgfVxuXG4gICAgc2VsZi5hZGRQYXN0S2V5VmFsdWVzKGRlY29kZXJGZWVkcywgcGFzdF9rZXlfdmFsdWVzKTtcblxuICAgIGxldCBkZWNvZGVyUmVzdWx0cyA9IGF3YWl0IHNlc3Npb25SdW4oc2VsZi5zZXNzaW9uLCBkZWNvZGVyRmVlZHMpO1xuXG4gICAgbGV0IGxvZ2l0cyA9IGRlY29kZXJSZXN1bHRzLmxvZ2l0cztcblxuICAgIHBhc3Rfa2V5X3ZhbHVlcyA9IHNlbGYuZ2V0UGFzdEtleVZhbHVlcyhkZWNvZGVyUmVzdWx0cywgcGFzdF9rZXlfdmFsdWVzKTtcbiAgICByZXR1cm4geyBsb2dpdHMsIHBhc3Rfa2V5X3ZhbHVlcyB9O1xufVxuXG4vKipcbiAqIFN0YXJ0cyB0aGUgZ2VuZXJhdGlvbiBvZiB0ZXh0IGJ5IGluaXRpYWxpemluZyB0aGUgYmVhbXMgZm9yIHRoZSBnaXZlbiBpbnB1dCB0b2tlbiBJRHMuXG4gKiBAcGFyYW0ge09iamVjdH0gc2VsZiBUaGUgdGV4dCBnZW5lcmF0aW9uIG1vZGVsIG9iamVjdC5cbiAqIEBwYXJhbSB7YW55fSBpbnB1dFRva2VuSWRzIEFuIGFycmF5IG9mIGlucHV0IHRva2VuIElEcyB0byBnZW5lcmF0ZSB0ZXh0IGZyb20uXG4gKiBAcGFyYW0ge251bWJlcn0gbnVtT3V0cHV0VG9rZW5zIFRoZSBtYXhpbXVtIG51bWJlciBvZiB0b2tlbnMgdG8gZ2VuZXJhdGUgZm9yIGVhY2ggYmVhbS5cbiAqIEBwYXJhbSB7VGVuc29yfSBbaW5wdXRzX2F0dGVudGlvbl9tYXNrXSBUaGUgYXR0ZW50aW9uIG1hc2sgdGVuc29yIGZvciB0aGUgaW5wdXQgdG9rZW4gSURzLlxuICogQHJldHVybnMge09iamVjdFtdfSBBbiBhcnJheSBvZiBiZWFtcyBpbml0aWFsaXplZCB3aXRoIHRoZSBnaXZlbiBpbnB1dHMgYW5kIHBhcmFtZXRlcnMuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBkZWNvZGVyU3RhcnRCZWFtcyhzZWxmLCBpbnB1dFRva2VuSWRzLCBudW1PdXRwdXRUb2tlbnMsIGlucHV0c19hdHRlbnRpb25fbWFzaykge1xuICAgIGxldCBiZWFtcyA9IFtdO1xuXG4gICAgbGV0IGJlYW1JZCA9IDA7XG4gICAgZm9yIChsZXQgdG9rZW5zIG9mIGlucHV0VG9rZW5JZHMpIHtcbiAgICAgICAgbGV0IG91dHB1dF90b2tlbl9pZHMgPSB0b2tlbnMudG9saXN0KCkubWFwKE51bWJlcik7XG5cbiAgICAgICAgLy8gVE9ETzogSW1wcm92ZVxuICAgICAgICAvLyBDdXJyZW50bHksIGp1c3QgYWRkIGJhY2sgYmF0Y2ggZGltZW5zaW9uLlxuICAgICAgICAvLyBJbiBmdXR1cmUsIGFsbG93IGZvciB0cnVlIHBhcmFsbGVsIGV4ZWN1dGlvblxuICAgICAgICB0b2tlbnMuZGltcyA9IFsxLCAuLi50b2tlbnMuZGltc11cblxuICAgICAgICBsZXQgYXR0bl9tYXNrO1xuICAgICAgICBpZiAoaW5wdXRzX2F0dGVudGlvbl9tYXNrKSB7XG4gICAgICAgICAgICBhdHRuX21hc2sgPSBpbnB1dHNfYXR0ZW50aW9uX21hc2tbYmVhbUlkXTtcbiAgICAgICAgICAgIGF0dG5fbWFzay5kaW1zID0gWzEsIC4uLmF0dG5fbWFzay5kaW1zXVxuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhdHRuX21hc2sgPSBwcmVwYXJlQXR0ZW50aW9uTWFzayhzZWxmLCB0b2tlbnMpXG4gICAgICAgIH1cblxuICAgICAgICBsZXQgc3RhcnQgPSB7XG4gICAgICAgICAgICBpbnB1dDogdG9rZW5zLFxuICAgICAgICAgICAgbW9kZWxfaW5wdXRfaWRzOiB0b2tlbnMsXG4gICAgICAgICAgICBhdHRlbnRpb25fbWFzazogYXR0bl9tYXNrLFxuICAgICAgICAgICAgcHJldl9tb2RlbF9vdXRwdXRzOiBudWxsLFxuXG4gICAgICAgICAgICBvdXRwdXRfdG9rZW5faWRzOiBvdXRwdXRfdG9rZW5faWRzLFxuICAgICAgICAgICAgbnVtX291dHB1dF90b2tlbnM6IG51bU91dHB1dFRva2VucyxcblxuICAgICAgICAgICAgZG9uZTogZmFsc2UsXG4gICAgICAgICAgICBzY29yZTogMCxcbiAgICAgICAgICAgIGlkOiBiZWFtSWQrKyAvLyBhc3NpZ24gdW5pcXVlIGlkIHRvIGJlYW1zXG4gICAgICAgIH1cblxuICAgICAgICBiZWFtcy5wdXNoKHN0YXJ0KTtcbiAgICB9XG4gICAgcmV0dXJuIGJlYW1zO1xufVxuXG4vKipcbiAqIFJ1bnMgYSBzaW5nbGUgc3RlcCBvZiB0aGUgdGV4dCBnZW5lcmF0aW9uIHByb2Nlc3MgZm9yIGEgZ2l2ZW4gYmVhbS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gc2VsZiBUaGUgZGVjb2RlciBvYmplY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gYmVhbSBUaGUgYmVhbSB0byBydW4uXG4gKiBAcGFyYW0ge1RlbnNvcn0gYmVhbS5pbnB1dCBUaGUgaW5wdXQgdGVuc29yLlxuICogQHBhcmFtIHtUZW5zb3J9IGJlYW0ubW9kZWxfaW5wdXRfaWRzIFRoZSBpbnB1dCBpZHMgdG8gdGhlIG1vZGVsLlxuICogQHBhcmFtIHtUZW5zb3J9IGJlYW0uYXR0ZW50aW9uX21hc2sgVGhlIGF0dGVudGlvbiBtYXNrLlxuICogQHBhcmFtIHtPYmplY3R9IGJlYW0ucHJldl9tb2RlbF9vdXRwdXRzIFRoZSBwYXN0IGtleSB2YWx1ZXMuXG4gKiBAcGFyYW0ge251bWJlcltdfSBiZWFtLm91dHB1dF90b2tlbl9pZHMgVGhlIG91dHB1dCB0b2tlbiBpZHMuXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fSBUaGUgb3V0cHV0IG9mIHRoZSBnZW5lcmF0aW9uIHN0ZXAuXG4gKiBAcHJpdmF0ZVxuICovXG5hc3luYyBmdW5jdGlvbiBkZWNvZGVyUnVuQmVhbShzZWxmLCBiZWFtKSB7XG4gICAgbGV0IGF0dG5NYXNrRGF0YSA9IG5ldyBCaWdJbnQ2NEFycmF5KGJlYW0ub3V0cHV0X3Rva2VuX2lkcy5sZW5ndGgpLmZpbGwoMW4pXG5cbiAgICAvLyAxLiBQcmVwYXJlXG4gICAgbGV0IG1vZGVsX2lucHV0cyA9IHtcbiAgICAgICAgaW5wdXRfaWRzOiBiZWFtLm1vZGVsX2lucHV0X2lkcyxcbiAgICAgICAgYXR0ZW50aW9uX21hc2s6IG5ldyBUZW5zb3IoXG4gICAgICAgICAgICAnaW50NjQnLFxuICAgICAgICAgICAgYXR0bk1hc2tEYXRhLFxuICAgICAgICAgICAgWzEsIGF0dG5NYXNrRGF0YS5sZW5ndGhdXG4gICAgICAgICksXG4gICAgICAgIHBhc3Rfa2V5X3ZhbHVlczogYmVhbS5wcmV2X21vZGVsX291dHB1dHM/LnBhc3Rfa2V5X3ZhbHVlcyxcbiAgICB9XG5cbiAgICAvLyAyLiBSdW5cbiAgICBsZXQgb3V0cHV0ID0gYXdhaXQgc2VsZi5mb3J3YXJkKG1vZGVsX2lucHV0cyk7XG5cbiAgICAvLyAzLiBVcGRhdGVcbiAgICBiZWFtLnByZXZfbW9kZWxfb3V0cHV0cyA9IG91dHB1dDtcblxuICAgIHJldHVybiBvdXRwdXQ7XG59XG5cbi8qKlxuICogVXBkYXRlIGEgYmVhbSB3aXRoIGEgbmV3IHRva2VuIElELlxuICogQHBhcmFtIHtPYmplY3R9IGJlYW0gVGhlIGJlYW0gdG8gdXBkYXRlLlxuICogQHBhcmFtIHtudW1iZXJ9IG5ld1Rva2VuSWQgVGhlIG5ldyB0b2tlbiBJRCB0byBhZGQgdG8gdGhlIGJlYW0ncyBvdXRwdXQuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBkZWNvZGVyVXBkYXRlYmVhbShiZWFtLCBuZXdUb2tlbklkKSB7XG4gICAgYmVhbS5vdXRwdXRfdG9rZW5faWRzID0gWy4uLmJlYW0ub3V0cHV0X3Rva2VuX2lkcywgbmV3VG9rZW5JZF07XG4gICAgYmVhbS5tb2RlbF9pbnB1dF9pZHMgPSBuZXcgVGVuc29yKCdpbnQ2NCcsIFtCaWdJbnQobmV3VG9rZW5JZCldLCBbMSwgMV0pO1xufVxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8qKlxuICogQSBiYXNlIGNsYXNzIGZvciBwcmUtdHJhaW5lZCBtb2RlbHMgdGhhdCBwcm92aWRlcyB0aGUgbW9kZWwgY29uZmlndXJhdGlvbiBhbmQgYW4gT05OWCBzZXNzaW9uLlxuICogQGV4dGVuZHMgQ2FsbGFibGVcbiAqL1xuZXhwb3J0IGNsYXNzIFByZVRyYWluZWRNb2RlbCBleHRlbmRzIENhbGxhYmxlIHtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgdGhlIGBQcmVUcmFpbmVkTW9kZWxgIGNsYXNzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgVGhlIG1vZGVsIGNvbmZpZ3VyYXRpb24uXG4gICAgICogQHBhcmFtIHthbnl9IHNlc3Npb24gc2Vzc2lvbiBmb3IgdGhlIG1vZGVsLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZywgc2Vzc2lvbikge1xuICAgICAgICBzdXBlcigpO1xuXG4gICAgICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgICAgICB0aGlzLnNlc3Npb24gPSBzZXNzaW9uO1xuICAgIH1cblxuICAgIC8qKlxuICAgICogRGlzcG9zZXMgb2YgYWxsIHRoZSBPTk5YIHNlc3Npb25zIHRoYXQgd2VyZSBjcmVhdGVkIGR1cmluZyBpbmZlcmVuY2UuXG4gICAgKiBAcmV0dXJucyB7UHJvbWlzZTx1bmtub3duW10+fSBBbiBhcnJheSBvZiBwcm9taXNlcywgb25lIGZvciBlYWNoIE9OTlggc2Vzc2lvbiB0aGF0IGlzIGJlaW5nIGRpc3Bvc2VkLlxuICAgICogQHRvZG8gVXNlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0ZpbmFsaXphdGlvblJlZ2lzdHJ5XG4gICAgKi9cbiAgICBhc3luYyBkaXNwb3NlKCkge1xuICAgICAgICBsZXQgcHJvbWlzZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQga2V5IG9mIE9iamVjdC5rZXlzKHRoaXMpKSB7XG4gICAgICAgICAgICBsZXQgaXRlbSA9IHRoaXNba2V5XTtcbiAgICAgICAgICAgIGlmIChpdGVtIGluc3RhbmNlb2YgSW5mZXJlbmNlU2Vzc2lvbikge1xuICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2goaXRlbS5oYW5kbGVyLmRpc3Bvc2UoKSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXdhaXQgUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluc3RhbnRpYXRlIG9uZSBvZiB0aGUgbW9kZWwgY2xhc3NlcyBvZiB0aGUgbGlicmFyeSBmcm9tIGEgcHJldHJhaW5lZCBtb2RlbC5cbiAgICAgKiBcbiAgICAgKiBUaGUgbW9kZWwgY2xhc3MgdG8gaW5zdGFudGlhdGUgaXMgc2VsZWN0ZWQgYmFzZWQgb24gdGhlIGBtb2RlbF90eXBlYCBwcm9wZXJ0eSBvZiB0aGUgY29uZmlnIG9iamVjdFxuICAgICAqIChlaXRoZXIgcGFzc2VkIGFzIGFuIGFyZ3VtZW50IG9yIGxvYWRlZCBmcm9tIGBwcmV0cmFpbmVkX21vZGVsX25hbWVfb3JfcGF0aGAgaWYgcG9zc2libGUpXG4gICAgICogXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByZXRyYWluZWRfbW9kZWxfbmFtZV9vcl9wYXRoIFRoZSBuYW1lIG9yIHBhdGggb2YgdGhlIHByZXRyYWluZWQgbW9kZWwuIENhbiBiZSBlaXRoZXI6XG4gICAgICogLSBBIHN0cmluZywgdGhlICptb2RlbCBpZCogb2YgYSBwcmV0cmFpbmVkIG1vZGVsIGhvc3RlZCBpbnNpZGUgYSBtb2RlbCByZXBvIG9uIGh1Z2dpbmdmYWNlLmNvLlxuICAgICAqICAgVmFsaWQgbW9kZWwgaWRzIGNhbiBiZSBsb2NhdGVkIGF0IHRoZSByb290LWxldmVsLCBsaWtlIGBiZXJ0LWJhc2UtdW5jYXNlZGAsIG9yIG5hbWVzcGFjZWQgdW5kZXIgYVxuICAgICAqICAgdXNlciBvciBvcmdhbml6YXRpb24gbmFtZSwgbGlrZSBgZGJtZHovYmVydC1iYXNlLWdlcm1hbi1jYXNlZGAuXG4gICAgICogLSBBIHBhdGggdG8gYSAqZGlyZWN0b3J5KiBjb250YWluaW5nIG1vZGVsIHdlaWdodHMsIGUuZy4sIGAuL215X21vZGVsX2RpcmVjdG9yeS9gLlxuICAgICAqIEBwYXJhbSB7UHJldHJhaW5lZE9wdGlvbnN9IG9wdGlvbnMgQWRkaXRpb25hbCBvcHRpb25zIGZvciBsb2FkaW5nIHRoZSBtb2RlbC5cbiAgICAgKiBcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxQcmVUcmFpbmVkTW9kZWw+fSBBIG5ldyBpbnN0YW5jZSBvZiB0aGUgYFByZVRyYWluZWRNb2RlbGAgY2xhc3MuXG4gICAgICovXG4gICAgc3RhdGljIGFzeW5jIGZyb21fcHJldHJhaW5lZChwcmV0cmFpbmVkX21vZGVsX25hbWVfb3JfcGF0aCwge1xuICAgICAgICBxdWFudGl6ZWQgPSB0cnVlLFxuICAgICAgICBwcm9ncmVzc19jYWxsYmFjayA9IG51bGwsXG4gICAgICAgIGNvbmZpZyA9IG51bGwsXG4gICAgICAgIGNhY2hlX2RpciA9IG51bGwsXG4gICAgICAgIGxvY2FsX2ZpbGVzX29ubHkgPSBmYWxzZSxcbiAgICAgICAgcmV2aXNpb24gPSAnbWFpbicsXG4gICAgfSA9IHt9KSB7XG5cbiAgICAgICAgbGV0IG9wdGlvbnMgPSB7XG4gICAgICAgICAgICBxdWFudGl6ZWQsXG4gICAgICAgICAgICBwcm9ncmVzc19jYWxsYmFjayxcbiAgICAgICAgICAgIGNvbmZpZyxcbiAgICAgICAgICAgIGNhY2hlX2RpcixcbiAgICAgICAgICAgIGxvY2FsX2ZpbGVzX29ubHksXG4gICAgICAgICAgICByZXZpc2lvbixcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBtb2RlbFR5cGUgPSBNT0RFTF9UWVBFX01BUFBJTkcuZ2V0KHRoaXMubmFtZSk7XG5cbiAgICAgICAgbGV0IGluZm87XG4gICAgICAgIGlmIChtb2RlbFR5cGUgPT09IERlY29kZXJPbmx5TW9kZWxUeXBlKSB7XG4gICAgICAgICAgICBpbmZvID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgICAgIEF1dG9Db25maWcuZnJvbV9wcmV0cmFpbmVkKHByZXRyYWluZWRfbW9kZWxfbmFtZV9vcl9wYXRoLCBvcHRpb25zKSxcbiAgICAgICAgICAgICAgICBjb25zdHJ1Y3RTZXNzaW9uKHByZXRyYWluZWRfbW9kZWxfbmFtZV9vcl9wYXRoLCAnZGVjb2Rlcl9tb2RlbF9tZXJnZWQnLCBvcHRpb25zKSxcbiAgICAgICAgICAgIF0pO1xuXG4gICAgICAgIH0gZWxzZSBpZiAobW9kZWxUeXBlID09PSBTZXEyU2VxTW9kZWxUeXBlKSB7XG4gICAgICAgICAgICBpbmZvID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgICAgIEF1dG9Db25maWcuZnJvbV9wcmV0cmFpbmVkKHByZXRyYWluZWRfbW9kZWxfbmFtZV9vcl9wYXRoLCBvcHRpb25zKSxcbiAgICAgICAgICAgICAgICBjb25zdHJ1Y3RTZXNzaW9uKHByZXRyYWluZWRfbW9kZWxfbmFtZV9vcl9wYXRoLCAnZW5jb2Rlcl9tb2RlbCcsIG9wdGlvbnMpLFxuICAgICAgICAgICAgICAgIGNvbnN0cnVjdFNlc3Npb24ocHJldHJhaW5lZF9tb2RlbF9uYW1lX29yX3BhdGgsICdkZWNvZGVyX21vZGVsX21lcmdlZCcsIG9wdGlvbnMpLFxuICAgICAgICAgICAgICAgIGdldE1vZGVsSlNPTihwcmV0cmFpbmVkX21vZGVsX25hbWVfb3JfcGF0aCwgJ2dlbmVyYXRpb25fY29uZmlnLmpzb24nLCBmYWxzZSwgb3B0aW9ucyksXG4gICAgICAgICAgICBdKTtcblxuICAgICAgICB9IGVsc2UgaWYgKG1vZGVsVHlwZSA9PT0gRW5jb2RlckRlY29kZXJNb2RlbFR5cGUpIHtcbiAgICAgICAgICAgIGluZm8gPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICAgICAgQXV0b0NvbmZpZy5mcm9tX3ByZXRyYWluZWQocHJldHJhaW5lZF9tb2RlbF9uYW1lX29yX3BhdGgsIG9wdGlvbnMpLFxuICAgICAgICAgICAgICAgIGNvbnN0cnVjdFNlc3Npb24ocHJldHJhaW5lZF9tb2RlbF9uYW1lX29yX3BhdGgsICdlbmNvZGVyX21vZGVsJywgb3B0aW9ucyksXG4gICAgICAgICAgICAgICAgY29uc3RydWN0U2Vzc2lvbihwcmV0cmFpbmVkX21vZGVsX25hbWVfb3JfcGF0aCwgJ2RlY29kZXJfbW9kZWxfbWVyZ2VkJywgb3B0aW9ucyksXG4gICAgICAgICAgICBdKTtcblxuICAgICAgICB9IGVsc2UgaWYgKG1vZGVsVHlwZSA9PT0gRW5jb2Rlck9ubHlNb2RlbFR5cGUpIHtcbiAgICAgICAgICAgIGluZm8gPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICAgICAgQXV0b0NvbmZpZy5mcm9tX3ByZXRyYWluZWQocHJldHJhaW5lZF9tb2RlbF9uYW1lX29yX3BhdGgsIG9wdGlvbnMpLFxuICAgICAgICAgICAgICAgIGNvbnN0cnVjdFNlc3Npb24ocHJldHJhaW5lZF9tb2RlbF9uYW1lX29yX3BhdGgsICdtb2RlbCcsIG9wdGlvbnMpXG4gICAgICAgICAgICBdKTtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdNYWxmb3JtZWQgY2xhc3MgZGVmaW5pdGlvbi4nLCB0aGlzKTtcbiAgICAgICAgICAgIHRocm93IEVycm9yKGBVbmFibGUgdG8gbG9hZCBtb2RlbDogJHtwcmV0cmFpbmVkX21vZGVsX25hbWVfb3JfcGF0aH0uIFBsZWFzZSByZXBvcnQgdGhpcyBidWcgYXQgaHR0cHM6Ly9naXRodWIuY29tL3hlbm92YS90cmFuc2Zvcm1lcnMuanMvaXNzdWVzL25ldy9jaG9vc2UuYCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIHJldHVybiBuZXcgdGhpcyguLi5pbmZvKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSdW5zIHRoZSBtb2RlbCB3aXRoIHRoZSBwcm92aWRlZCBpbnB1dHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbW9kZWxfaW5wdXRzIE9iamVjdCBjb250YWluaW5nIGlucHV0IHRlbnNvcnNcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fSBPYmplY3QgY29udGFpbmluZyBvdXRwdXQgdGVuc29yc1xuICAgICAqL1xuICAgIGFzeW5jIF9jYWxsKG1vZGVsX2lucHV0cykge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5mb3J3YXJkKG1vZGVsX2lucHV0cyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRm9yd2FyZCBtZXRob2QgZm9yIGEgcHJldHJhaW5lZCBtb2RlbC4gSWYgbm90IG92ZXJyaWRkZW4gYnkgYSBzdWJjbGFzcywgdGhlIGNvcnJlY3QgZm9yd2FyZCBtZXRob2RcbiAgICAgKiB3aWxsIGJlIGNob3NlbiBiYXNlZCBvbiB0aGUgbW9kZWwgdHlwZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbW9kZWxfaW5wdXRzIFRoZSBpbnB1dCBkYXRhIHRvIHRoZSBtb2RlbCBpbiB0aGUgZm9ybWF0IHNwZWNpZmllZCBpbiB0aGUgT05OWCBtb2RlbC5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fSBUaGUgb3V0cHV0IGRhdGEgZnJvbSB0aGUgbW9kZWwgaW4gdGhlIGZvcm1hdCBzcGVjaWZpZWQgaW4gdGhlIE9OTlggbW9kZWwuXG4gICAgICogQHRocm93cyB7RXJyb3J9IFRoaXMgbWV0aG9kIG11c3QgYmUgaW1wbGVtZW50ZWQgaW4gc3ViY2xhc3Nlcy5cbiAgICAgKi9cbiAgICBhc3luYyBmb3J3YXJkKG1vZGVsX2lucHV0cykge1xuICAgICAgICByZXR1cm4gYXdhaXQgZm9yd2FyZCh0aGlzLCBtb2RlbF9pbnB1dHMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7R2VuZXJhdGlvbkNvbmZpZ30gZ2VuZXJhdGlvbl9jb25maWcgXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGlucHV0X2lkc19zZXFfbGVuZ3RoIFRoZSBzdGFydGluZyBzZXF1ZW5jZSBsZW5ndGggZm9yIHRoZSBpbnB1dCBpZHMuXG4gICAgICogQHJldHVybnMge0xvZ2l0c1Byb2Nlc3Nvckxpc3R9XG4gICAgICovXG4gICAgX2dldF9sb2dpdHNfcHJvY2Vzc29yKFxuICAgICAgICBnZW5lcmF0aW9uX2NvbmZpZyxcbiAgICAgICAgaW5wdXRfaWRzX3NlcV9sZW5ndGgsXG4gICAgICAgIC8vIGVuY29kZXJfaW5wdXRfaWRzLCBUT0RPXG4gICAgICAgIC8vIHByZWZpeF9hbGxvd2VkX3Rva2Vuc19mbiwgVE9ET1xuICAgICAgICBsb2dpdHNfcHJvY2Vzc29yID0gbnVsbFxuICAgICkge1xuICAgICAgICBjb25zdCBwcm9jZXNzb3JzID0gbmV3IExvZ2l0c1Byb2Nlc3Nvckxpc3QoKTtcblxuICAgICAgICAvLyBpZiAoZ2VuZXJhdGlvbl9jb25maWcuZGl2ZXJzaXR5X3BlbmFsdHkgIT09IG51bGwgJiYgZ2VuZXJhdGlvbl9jb25maWcuZGl2ZXJzaXR5X3BlbmFsdHkgPiAwLjApIHtcbiAgICAgICAgLy8gICAgIHByb2Nlc3NvcnMucHVzaChuZXcgSGFtbWluZ0RpdmVyc2l0eUxvZ2l0c1Byb2Nlc3NvcihcbiAgICAgICAgLy8gICAgICAgICBnZW5lcmF0aW9uX2NvbmZpZy5kaXZlcnNpdHlfcGVuYWx0eSxcbiAgICAgICAgLy8gICAgICAgICBnZW5lcmF0aW9uX2NvbmZpZy5udW1fYmVhbXMsXG4gICAgICAgIC8vICAgICAgICAgZ2VuZXJhdGlvbl9jb25maWcubnVtX2JlYW1fZ3JvdXBzXG4gICAgICAgIC8vICAgICApKTtcbiAgICAgICAgLy8gfVxuXG4gICAgICAgIC8vIGlmIChnZW5lcmF0aW9uX2NvbmZpZy5lbmNvZGVyX3JlcGV0aXRpb25fcGVuYWx0eSAhPT0gbnVsbCAmJiBnZW5lcmF0aW9uX2NvbmZpZy5lbmNvZGVyX3JlcGV0aXRpb25fcGVuYWx0eSAhPT0gMS4wKSB7XG4gICAgICAgIC8vICAgICBwcm9jZXNzb3JzLnB1c2gobmV3IEVuY29kZXJSZXBldGl0aW9uUGVuYWx0eUxvZ2l0c1Byb2Nlc3NvcihcbiAgICAgICAgLy8gICAgICAgICBnZW5lcmF0aW9uX2NvbmZpZy5lbmNvZGVyX3JlcGV0aXRpb25fcGVuYWx0eSxcbiAgICAgICAgLy8gICAgICAgICBlbmNvZGVyX2lucHV0X2lkc1xuICAgICAgICAvLyAgICAgKSk7XG4gICAgICAgIC8vIH1cblxuICAgICAgICBpZiAoZ2VuZXJhdGlvbl9jb25maWcucmVwZXRpdGlvbl9wZW5hbHR5ICE9PSBudWxsICYmIGdlbmVyYXRpb25fY29uZmlnLnJlcGV0aXRpb25fcGVuYWx0eSAhPT0gMS4wKSB7XG4gICAgICAgICAgICBwcm9jZXNzb3JzLnB1c2gobmV3IFJlcGV0aXRpb25QZW5hbHR5TG9naXRzUHJvY2Vzc29yKGdlbmVyYXRpb25fY29uZmlnLnJlcGV0aXRpb25fcGVuYWx0eSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGdlbmVyYXRpb25fY29uZmlnLm5vX3JlcGVhdF9uZ3JhbV9zaXplICE9PSBudWxsICYmIGdlbmVyYXRpb25fY29uZmlnLm5vX3JlcGVhdF9uZ3JhbV9zaXplID4gMCkge1xuICAgICAgICAgICAgcHJvY2Vzc29ycy5wdXNoKG5ldyBOb1JlcGVhdE5HcmFtTG9naXRzUHJvY2Vzc29yKGdlbmVyYXRpb25fY29uZmlnLm5vX3JlcGVhdF9uZ3JhbV9zaXplKSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiAoZ2VuZXJhdGlvbl9jb25maWcuZW5jb2Rlcl9ub19yZXBlYXRfbmdyYW1fc2l6ZSAhPT0gbnVsbCAmJiBnZW5lcmF0aW9uX2NvbmZpZy5lbmNvZGVyX25vX3JlcGVhdF9uZ3JhbV9zaXplID4gMCkge1xuICAgICAgICAvLyAgICAgaWYgKHRoaXMuY29uZmlnLmlzX2VuY29kZXJfZGVjb2Rlcikge1xuICAgICAgICAvLyAgICAgICAgIHByb2Nlc3NvcnMucHVzaChuZXcgRW5jb2Rlck5vUmVwZWF0TkdyYW1Mb2dpdHNQcm9jZXNzb3IoXG4gICAgICAgIC8vICAgICAgICAgICAgIGdlbmVyYXRpb25fY29uZmlnLmVuY29kZXJfbm9fcmVwZWF0X25ncmFtX3NpemUsXG4gICAgICAgIC8vICAgICAgICAgICAgIGVuY29kZXJfaW5wdXRfaWRzXG4gICAgICAgIC8vICAgICAgICAgKSk7XG4gICAgICAgIC8vICAgICB9IGVsc2Uge1xuICAgICAgICAvLyAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkl0J3MgaW1wb3NzaWJsZSB0byB1c2UgYGVuY29kZXJfbm9fcmVwZWF0X25ncmFtX3NpemVgIHdpdGggZGVjb2Rlci1vbmx5IGFyY2hpdGVjdHVyZVwiKTtcbiAgICAgICAgLy8gICAgIH1cbiAgICAgICAgLy8gfVxuXG4gICAgICAgIC8vIGlmIChnZW5lcmF0aW9uX2NvbmZpZy5iYWRfd29yZHNfaWRzICE9PSBudWxsKSB7XG4gICAgICAgIC8vICAgICBwcm9jZXNzb3JzLnB1c2gobmV3IE5vQmFkV29yZHNMb2dpdHNQcm9jZXNzb3IoZ2VuZXJhdGlvbl9jb25maWcuYmFkX3dvcmRzX2lkcywgZ2VuZXJhdGlvbl9jb25maWcuZW9zX3Rva2VuX2lkKSk7XG4gICAgICAgIC8vIH1cblxuICAgICAgICAvLyBpZiAoZ2VuZXJhdGlvbl9jb25maWcubWluX2xlbmd0aCAhPT0gbnVsbCAmJiBnZW5lcmF0aW9uX2NvbmZpZy5lb3NfdG9rZW5faWQgIT09IG51bGwgJiYgZ2VuZXJhdGlvbl9jb25maWcubWluX2xlbmd0aCA+IDApIHtcbiAgICAgICAgLy8gICAgIHByb2Nlc3NvcnMucHVzaChuZXcgTWluTGVuZ3RoTG9naXRzUHJvY2Vzc29yKGdlbmVyYXRpb25fY29uZmlnLm1pbl9sZW5ndGgsIGdlbmVyYXRpb25fY29uZmlnLmVvc190b2tlbl9pZCkpO1xuICAgICAgICAvLyB9XG5cbiAgICAgICAgLy8gaWYgKGdlbmVyYXRpb25fY29uZmlnLm1pbl9uZXdfdG9rZW5zICE9PSBudWxsICYmIGdlbmVyYXRpb25fY29uZmlnLmVvc190b2tlbl9pZCAhPT0gbnVsbCAmJiBnZW5lcmF0aW9uX2NvbmZpZy5taW5fbmV3X3Rva2VucyA+IDApIHtcbiAgICAgICAgLy8gICAgIHByb2Nlc3NvcnMucHVzaChuZXcgTWluTmV3VG9rZW5zTGVuZ3RoTG9naXRzUHJvY2Vzc29yKFxuICAgICAgICAvLyAgICAgICAgIGlucHV0X2lkc19zZXFfbGVuZ3RoLFxuICAgICAgICAvLyAgICAgICAgIGdlbmVyYXRpb25fY29uZmlnLm1pbl9uZXdfdG9rZW5zLFxuICAgICAgICAvLyAgICAgICAgIGdlbmVyYXRpb25fY29uZmlnLmVvc190b2tlbl9pZFxuICAgICAgICAvLyAgICAgKSk7XG4gICAgICAgIC8vIH1cblxuICAgICAgICAvLyBpZiAocHJlZml4X2FsbG93ZWRfdG9rZW5zX2ZuICE9PSBudWxsKSB7XG4gICAgICAgIC8vICAgICBwcm9jZXNzb3JzLnB1c2gobmV3IFByZWZpeENvbnN0cmFpbmVkTG9naXRzUHJvY2Vzc29yKFxuICAgICAgICAvLyAgICAgICAgIHByZWZpeF9hbGxvd2VkX3Rva2Vuc19mbixcbiAgICAgICAgLy8gICAgICAgICBnZW5lcmF0aW9uX2NvbmZpZy5udW1fYmVhbXMgLyBnZW5lcmF0aW9uX2NvbmZpZy5udW1fYmVhbV9ncm91cHNcbiAgICAgICAgLy8gICAgICkpO1xuICAgICAgICAvLyB9XG5cblxuICAgICAgICBpZiAoZ2VuZXJhdGlvbl9jb25maWcuZm9yY2VkX2Jvc190b2tlbl9pZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcHJvY2Vzc29ycy5wdXNoKG5ldyBGb3JjZWRCT1NUb2tlbkxvZ2l0c1Byb2Nlc3NvcihnZW5lcmF0aW9uX2NvbmZpZy5mb3JjZWRfYm9zX3Rva2VuX2lkKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZ2VuZXJhdGlvbl9jb25maWcuZm9yY2VkX2Vvc190b2tlbl9pZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcHJvY2Vzc29ycy5wdXNoKG5ldyBGb3JjZWRFT1NUb2tlbkxvZ2l0c1Byb2Nlc3NvcihcbiAgICAgICAgICAgICAgICBnZW5lcmF0aW9uX2NvbmZpZy5tYXhfbGVuZ3RoLFxuICAgICAgICAgICAgICAgIGdlbmVyYXRpb25fY29uZmlnLmZvcmNlZF9lb3NfdG9rZW5faWRcbiAgICAgICAgICAgICkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgKGdlbmVyYXRpb25fY29uZmlnLnJlbW92ZV9pbnZhbGlkX3ZhbHVlcyA9PT0gdHJ1ZSkge1xuICAgICAgICAvLyAgICAgcHJvY2Vzc29ycy5wdXNoKG5ldyBJbmZOYW5SZW1vdmVMb2dpdHNQcm9jZXNzb3IoKSk7XG4gICAgICAgIC8vIH1cblxuICAgICAgICAvLyBpZiAoZ2VuZXJhdGlvbl9jb25maWcuZXhwb25lbnRpYWxfZGVjYXlfbGVuZ3RoX3BlbmFsdHkgIT09IG51bGwpIHtcbiAgICAgICAgLy8gICAgIHByb2Nlc3NvcnMucHVzaChuZXcgRXhwb25lbnRpYWxEZWNheUxlbmd0aFBlbmFsdHkoXG4gICAgICAgIC8vICAgICAgICAgZ2VuZXJhdGlvbl9jb25maWcuZXhwb25lbnRpYWxfZGVjYXlfbGVuZ3RoX3BlbmFsdHksXG4gICAgICAgIC8vICAgICAgICAgZ2VuZXJhdGlvbl9jb25maWcuZW9zX3Rva2VuX2lkLFxuICAgICAgICAvLyAgICAgICAgIGlucHV0X2lkc19zZXFfbGVuZ3RoXG4gICAgICAgIC8vICAgICApKTtcbiAgICAgICAgLy8gfVxuXG4gICAgICAgIC8vIGlmIChnZW5lcmF0aW9uX2NvbmZpZy5zdXBwcmVzc190b2tlbnMgIT09IG51bGwpIHtcbiAgICAgICAgLy8gICAgIHByb2Nlc3NvcnMucHVzaChuZXcgU3VwcHJlc3NUb2tlbnNMb2dpdHNQcm9jZXNzb3IoZ2VuZXJhdGlvbl9jb25maWcuc3VwcHJlc3NfdG9rZW5zKSk7XG4gICAgICAgIC8vIH1cblxuICAgICAgICBpZiAoZ2VuZXJhdGlvbl9jb25maWcuYmVnaW5fc3VwcHJlc3NfdG9rZW5zICE9PSBudWxsKSB7XG4gICAgICAgICAgICBsZXQgYmVnaW5faW5kZXggPSAoaW5wdXRfaWRzX3NlcV9sZW5ndGggPiAxIHx8IGdlbmVyYXRpb25fY29uZmlnLmZvcmNlZF9ib3NfdG9rZW5faWQgPT09IG51bGwpXG4gICAgICAgICAgICAgICAgPyBpbnB1dF9pZHNfc2VxX2xlbmd0aFxuICAgICAgICAgICAgICAgIDogaW5wdXRfaWRzX3NlcV9sZW5ndGggKyAxO1xuXG4gICAgICAgICAgICBpZiAoZ2VuZXJhdGlvbl9jb25maWcuZm9yY2VkX2RlY29kZXJfaWRzICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgLy8gZ2VuZXJhdGlvbiBzdGFydHMgYWZ0ZXIgdGhlIGxhc3QgdG9rZW4gdGhhdCBpcyBmb3JjZWRcbiAgICAgICAgICAgICAgICBiZWdpbl9pbmRleCArPSBnZW5lcmF0aW9uX2NvbmZpZy5mb3JjZWRfZGVjb2Rlcl9pZHNbZ2VuZXJhdGlvbl9jb25maWcuZm9yY2VkX2RlY29kZXJfaWRzLmxlbmd0aCAtIDFdWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJvY2Vzc29ycy5wdXNoKG5ldyBTdXBwcmVzc1Rva2Vuc0F0QmVnaW5Mb2dpdHNQcm9jZXNzb3IoZ2VuZXJhdGlvbl9jb25maWcuYmVnaW5fc3VwcHJlc3NfdG9rZW5zLCBiZWdpbl9pbmRleCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGdlbmVyYXRpb25fY29uZmlnLmZvcmNlZF9kZWNvZGVyX2lkcyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcHJvY2Vzc29ycy5wdXNoKG5ldyBGb3JjZVRva2Vuc0xvZ2l0c1Byb2Nlc3NvcihnZW5lcmF0aW9uX2NvbmZpZy5mb3JjZWRfZGVjb2Rlcl9pZHMpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsb2dpdHNfcHJvY2Vzc29yICE9PSBudWxsKSB7XG4gICAgICAgICAgICBwcm9jZXNzb3JzLmV4dGVuZChsb2dpdHNfcHJvY2Vzc29yKVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gYExvZ2l0Tm9ybWFsaXphdGlvbmAgc2hvdWxkIGFsd2F5cyBiZSB0aGUgbGFzdCBsb2dpdCBwcm9jZXNzb3IsIHdoZW4gcHJlc2VudFxuICAgICAgICAvLyBpZiAoZ2VuZXJhdGlvbl9jb25maWcucmVub3JtYWxpemVfbG9naXRzID09PSB0cnVlKSB7XG4gICAgICAgIC8vICAgICBwcm9jZXNzb3JzLnB1c2gobmV3IExvZ2l0Tm9ybWFsaXphdGlvbigpKTtcbiAgICAgICAgLy8gfVxuXG4gICAgICAgIHJldHVybiBwcm9jZXNzb3JzO1xuICAgIH1cblxuICAgIC8qKlxuICAgKiBUaGlzIGZ1bmN0aW9uIG1lcmdlcyBtdWx0aXBsZSBnZW5lcmF0aW9uIGNvbmZpZ3MgdG9nZXRoZXIgdG8gZm9ybSBhIGZpbmFsIGdlbmVyYXRpb24gY29uZmlnIHRvIGJlIHVzZWQgYnkgdGhlIG1vZGVsIGZvciB0ZXh0IGdlbmVyYXRpb24uXG4gICAqIEl0IGZpcnN0IGNyZWF0ZXMgYW4gZW1wdHkgYEdlbmVyYXRpb25Db25maWdgIG9iamVjdCwgdGhlbiBpdCBhcHBsaWVzIHRoZSBtb2RlbCdzIG93biBgZ2VuZXJhdGlvbl9jb25maWdgIHByb3BlcnR5IHRvIGl0LiBGaW5hbGx5LCBpZiBhIGBnZW5lcmF0aW9uX2NvbmZpZ2Agb2JqZWN0IHdhcyBwYXNzZWQgaW4gdGhlIGFyZ3VtZW50cywgaXQgb3ZlcndyaXRlcyB0aGUgY29ycmVzcG9uZGluZyBwcm9wZXJ0aWVzIGluIHRoZSBmaW5hbCBjb25maWcgd2l0aCB0aG9zZSBvZiB0aGUgcGFzc2VkIGNvbmZpZyBvYmplY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7R2VuZXJhdGlvbkNvbmZpZ30gZ2VuZXJhdGlvbl9jb25maWcgQSBgR2VuZXJhdGlvbkNvbmZpZ2Agb2JqZWN0IGNvbnRhaW5pbmcgZ2VuZXJhdGlvbiBwYXJhbWV0ZXJzLlxuICAgKiBAcmV0dXJucyB7R2VuZXJhdGlvbkNvbmZpZ30gVGhlIGZpbmFsIGdlbmVyYXRpb24gY29uZmlnIG9iamVjdCB0byBiZSB1c2VkIGJ5IHRoZSBtb2RlbCBmb3IgdGV4dCBnZW5lcmF0aW9uLlxuICAgKi9cbiAgICBfZ2V0X2dlbmVyYXRpb25fY29uZmlnKGdlbmVyYXRpb25fY29uZmlnKSB7XG4gICAgICAgIC8vIENyZWF0ZSBlbXB0eSBnZW5lcmF0aW9uIGNvbmZpZyAoY29udGFpbnMgZGVmYXVsdHMpXG4gICAgICAgIGxldCBnZW5fY29uZmlnID0gbmV3IEdlbmVyYXRpb25Db25maWcoKTtcblxuICAgICAgICAvLyBBcHBseSBtb2RlbCdzIGdlbmVyYXRpb24gY29uZmlnLCBpZiBpdCBleGlzdHNcbiAgICAgICAgaWYgKCdnZW5lcmF0aW9uX2NvbmZpZycgaW4gdGhpcykge1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihnZW5fY29uZmlnLCB0aGlzLmdlbmVyYXRpb25fY29uZmlnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEZpbmFsbHksIHVzZSBhbnkgZ2VuZXJhdGlvbiBjb25maWcgc3BlY2lmaWVkIGJ5IHRoZSB1c2VyXG4gICAgICAgIC8vIHdoZW4gY2FsbGluZyBgZ2VuZXJhdGVgXG4gICAgICAgIGlmIChnZW5lcmF0aW9uX2NvbmZpZyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihnZW5fY29uZmlnLCBnZW5lcmF0aW9uX2NvbmZpZyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGdlbl9jb25maWc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHR5cGVkZWYge2ltcG9ydCgnLi91dGlscy9tYXRocy5qcycpLlR5cGVkQXJyYXl9IFR5cGVkQXJyYXlcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEB0eXBlZGVmIHt7IHNlcXVlbmNlczogVGVuc29yLCBkZWNvZGVyX2F0dGVudGlvbnM6IFRlbnNvciwgY3Jvc3NfYXR0ZW50aW9uczogVGVuc29yIH19IEVuY29kZXJEZWNvZGVyT3V0cHV0XG4gICAgICogQHR5cGVkZWYge09iamVjdH0gRGVjb2Rlck91dHB1dFxuICAgICAqIFxuICAgICAqIEdlbmVyYXRlcyB0ZXh0IGJhc2VkIG9uIHRoZSBnaXZlbiBpbnB1dHMgYW5kIGdlbmVyYXRpb24gY29uZmlndXJhdGlvbiB1c2luZyB0aGUgbW9kZWwuXG4gICAgICogQHBhcmFtIHtUZW5zb3J8QXJyYXl8VHlwZWRBcnJheX0gaW5wdXRzIEFuIGFycmF5IG9mIGlucHV0IHRva2VuIElEcy5cbiAgICAgKiBAcGFyYW0ge09iamVjdHxHZW5lcmF0aW9uQ29uZmlnfG51bGx9IGdlbmVyYXRpb25fY29uZmlnIFRoZSBnZW5lcmF0aW9uIGNvbmZpZ3VyYXRpb24gdG8gdXNlLiBJZiBudWxsLCBkZWZhdWx0IGNvbmZpZ3VyYXRpb24gd2lsbCBiZSB1c2VkLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fG51bGx9IGxvZ2l0c19wcm9jZXNzb3IgQW4gb3B0aW9uYWwgbG9naXRzIHByb2Nlc3NvciB0byB1c2UuIElmIG51bGwsIGEgbmV3IExvZ2l0c1Byb2Nlc3Nvckxpc3QgaW5zdGFuY2Ugd2lsbCBiZSBjcmVhdGVkLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuaW5wdXRzX2F0dGVudGlvbl9tYXNrPW51bGxdIEFuIG9wdGlvbmFsIGF0dGVudGlvbiBtYXNrIGZvciB0aGUgaW5wdXRzLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPG51bWJlcltdW118RW5jb2RlckRlY29kZXJPdXRwdXR8RGVjb2Rlck91dHB1dD59IEFuIGFycmF5IG9mIGdlbmVyYXRlZCBvdXRwdXQgc2VxdWVuY2VzLCB3aGVyZSBlYWNoIHNlcXVlbmNlIGlzIGFuIGFycmF5IG9mIHRva2VuIElEcy5cbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gVGhyb3dzIGFuIGVycm9yIGlmIHRoZSBpbnB1dHMgYXJyYXkgaXMgZW1wdHkuXG4gICAgICovXG4gICAgYXN5bmMgZ2VuZXJhdGUoXG4gICAgICAgIGlucHV0cyxcbiAgICAgICAgZ2VuZXJhdGlvbl9jb25maWcgPSBudWxsLFxuICAgICAgICBsb2dpdHNfcHJvY2Vzc29yID0gbnVsbCxcbiAgICAgICAge1xuICAgICAgICAgICAgaW5wdXRzX2F0dGVudGlvbl9tYXNrID0gbnVsbFxuICAgICAgICB9ID0ge30sXG4gICAgKSB7XG5cbiAgICAgICAgaWYgKCEoaW5wdXRzIGluc3RhbmNlb2YgVGVuc29yKSAmJiAhaXNUeXBlZEFycmF5KGlucHV0cykgJiYgIUFycmF5LmlzQXJyYXkoaW5wdXRzKSkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoYFxcYGlucHV0c1xcYCBtdXN0IGJlIGEgVGVuc29yLCBUeXBlZEFycmF5LCBvciBBcnJheSwgYnV0IGlzIFwiJHtpbnB1dHMuY29uc3RydWN0b3IubmFtZX1cIi5gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBpbnB1dF9pZHNfc2VxX2xlbmd0aDtcblxuICAgICAgICAvLyBQcmVwYXJlIGBpbnB1dF9pZHNgIHdoaWNoIHdpbGwgYmUgdXNlZCBmb3IgYXV0by1yZWdyZXNzaXZlIGdlbmVyYXRpb25cbiAgICAgICAgLy8gVE9ETzogVXBkYXRlIHRvIGFsaWduIHdpdGggSEYgdHJhbnNmb3JtZXJzJyBpbXBsZW1lbnRhdGlvblxuICAgICAgICBpZiAodGhpcy5jb25maWcuaXNfZW5jb2Rlcl9kZWNvZGVyKSB7XG4gICAgICAgICAgICAvLyBHZW5lcmF0aW5nIGZyb20gdGhlIGVuY29kZXIgb3V0cHV0c1xuICAgICAgICAgICAgaW5wdXRfaWRzX3NlcV9sZW5ndGggPSAwO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpbnB1dF9pZHNfc2VxX2xlbmd0aCA9IGlucHV0cyBpbnN0YW5jZW9mIFRlbnNvciA/IGlucHV0cy5kaW1zWzBdIDogaW5wdXRzLmxlbmd0aDtcblxuICAgICAgICAgICAgLy8gZGVjb2Rlci1vbmx5XG4gICAgICAgICAgICBpZiAoaW5wdXRfaWRzX3NlcV9sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIk11c3Qgc3VwcGx5IGEgbm9uLWVtcHR5IGFycmF5IG9mIGlucHV0IHRva2VuIGlkcy5cIilcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFVwZGF0ZSBnZW5lcmF0aW9uIGNvbmZpZyB3aXRoIGRlZmF1bHRzXG4gICAgICAgIGdlbmVyYXRpb25fY29uZmlnID0gdGhpcy5fZ2V0X2dlbmVyYXRpb25fY29uZmlnKGdlbmVyYXRpb25fY29uZmlnKTtcblxuICAgICAgICBsb2dpdHNfcHJvY2Vzc29yID0gbG9naXRzX3Byb2Nlc3NvciA/PyBuZXcgTG9naXRzUHJvY2Vzc29yTGlzdCgpXG5cbiAgICAgICAgLy8gVXBkYXRlIGxvZ2l0cyBwcm9jZXNzb3JcbiAgICAgICAgbG9naXRzX3Byb2Nlc3NvciA9IHRoaXMuX2dldF9sb2dpdHNfcHJvY2Vzc29yKFxuICAgICAgICAgICAgZ2VuZXJhdGlvbl9jb25maWcsXG4gICAgICAgICAgICBpbnB1dF9pZHNfc2VxX2xlbmd0aCxcbiAgICAgICAgICAgIGxvZ2l0c19wcm9jZXNzb3JcbiAgICAgICAgKVxuXG4gICAgICAgIC8vIFRPRE8gaW1wbGVtZW50IGVhcmx5X3N0b3BwaW5nXG4gICAgICAgIC8vIGh0dHBzOi8vaHVnZ2luZ2ZhY2UuY28vYmxvZy9ob3ctdG8tZ2VuZXJhdGVcblxuICAgICAgICBsZXQgbnVtT3V0cHV0VG9rZW5zID0gMTtcbiAgICAgICAgY29uc3QgbWF4T3V0cHV0VG9rZW5zID0gbnVtT3V0cHV0VG9rZW5zICsgKGdlbmVyYXRpb25fY29uZmlnLm1heF9uZXdfdG9rZW5zID8/IEluZmluaXR5KTtcblxuICAgICAgICAvLyBPbmx5IHVzZSBtYXggbGVuZ3RoIGlmIG1heF9uZXdfdG9rZW5zIGlzIG5vdCBwcm92aWRlZFxuICAgICAgICBjb25zdCB1c2VNYXhMZW5ndGggPSBOdW1iZXIuaXNJbnRlZ2VyKGdlbmVyYXRpb25fY29uZmlnLm1heF9sZW5ndGgpICYmIChnZW5lcmF0aW9uX2NvbmZpZy5tYXhfbmV3X3Rva2VucyA/PyBudWxsKSA9PT0gbnVsbDtcbiAgICAgICAgbGV0IHNhbXBsZXIgPSBTYW1wbGVyLmdldFNhbXBsZXIoZ2VuZXJhdGlvbl9jb25maWcpO1xuXG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgbGV0IGJlYW1zID0gdGhpcy5nZXRTdGFydEJlYW1zKGlucHV0cywgbnVtT3V0cHV0VG9rZW5zLCBpbnB1dHNfYXR0ZW50aW9uX21hc2spO1xuXG4gICAgICAgIHdoaWxlIChiZWFtcy5zb21lKHggPT4gIXguZG9uZSkgJiYgbnVtT3V0cHV0VG9rZW5zIDwgbWF4T3V0cHV0VG9rZW5zKSB7XG4gICAgICAgICAgICBsZXQgbmV3ZXN0X2JlYW1zID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCBiZWFtIG9mIGJlYW1zKSB7XG4gICAgICAgICAgICAgICAgaWYgKGJlYW0uZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBBZGQgdGhpcyBiZWFtIGJhY2sgaW50byB0aGUgcG9vbFxuICAgICAgICAgICAgICAgICAgICBuZXdlc3RfYmVhbXMucHVzaChiZWFtKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHVzZU1heExlbmd0aCAmJiBiZWFtLm91dHB1dF90b2tlbl9pZHMubGVuZ3RoID49IGdlbmVyYXRpb25fY29uZmlnLm1heF9sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2V0IHRoaXMgYmVhbSB0byBkb25lIGFuZCBhZGQgaXQgYmFjayBpbnRvIHRoZSBwb29sXG4gICAgICAgICAgICAgICAgICAgIGJlYW0uZG9uZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIG5ld2VzdF9iZWFtcy5wdXNoKGJlYW0pO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICBsZXQgb3V0cHV0ID0gYXdhaXQgdGhpcy5ydW5CZWFtKGJlYW0pO1xuXG4gICAgICAgICAgICAgICAgLy8gYWRkIGF0dGVudGlvbnMvc2NvcmVzIHRvIGJlYW0gb25seSBpZiB1c2VyIHJlcXVlc3RlZFxuICAgICAgICAgICAgICAgIGlmIChnZW5lcmF0aW9uX2NvbmZpZy5vdXRwdXRfYXR0ZW50aW9ucykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZEF0dGVudGlvbnNUb0JlYW0oYmVhbSwgb3V0cHV0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGdlbmVyYXRpb25fY29uZmlnLm91dHB1dF9zY29yZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyBhZGRcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBMb2dpdHMgYXJlIG9mIHRoZSBmb3JtIFtiYXRjaF9zaXplLCBvdXRfc2VxX2xlbmd0aCwgdm9jYWJfc2l6ZV1cbiAgICAgICAgICAgICAgICAvLyBJbiBtb3N0IGNhc2VzLCB0aGlzIHdpbGwgYmUgW2JhdGNoX3NpemUsIDEsIHZvY2FiX3NpemVdXG4gICAgICAgICAgICAgICAgLy8gU28sIHdlIHNlbGVjdCB0aGUgbGFzdCB0b2tlbidzIGxvZ2l0czpcbiAgICAgICAgICAgICAgICAvLyAoZXF1aXZhbGVudCB0byBgbG9naXRzID0gb3V0cHV0cy5sb2dpdHNbOiwgLTEsIDpdYClcbiAgICAgICAgICAgICAgICBsZXQgbG9naXRzID0gb3V0cHV0LmxvZ2l0cy5zbGljZShudWxsLCAtMSwgbnVsbCk7XG5cbiAgICAgICAgICAgICAgICAvLyBBcHBseSBsb2dpdHMgcHJvY2Vzc29yXG4gICAgICAgICAgICAgICAgbG9naXRzX3Byb2Nlc3NvcihiZWFtLm91dHB1dF90b2tlbl9pZHMsIGxvZ2l0cyk7XG5cbiAgICAgICAgICAgICAgICBsZXQgc2FtcGxlZFRva2VucyA9IHNhbXBsZXIobG9naXRzKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBbbmV3VG9rZW5JZCwgbG9nUHJvYl0gb2Ygc2FtcGxlZFRva2Vucykge1xuICAgICAgICAgICAgICAgICAgICAvLyB1c2UgcHJldmlvdXMgYmVhbSBhcyBhIHN0YXJ0aW5nIHBvaW50XG4gICAgICAgICAgICAgICAgICAgIGxldCBuZXdCZWFtID0geyAuLi5iZWFtIH07XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gdXBkYXRlIG5ldyBiZWFtXG4gICAgICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVCZWFtKG5ld0JlYW0sIG5ld1Rva2VuSWQpO1xuXG4gICAgICAgICAgICAgICAgICAgIG5ld0JlYW0uc2NvcmUgKz0gbG9nUHJvYjtcblxuICAgICAgICAgICAgICAgICAgICBpZiAobmV3VG9rZW5JZCA9PT0gdGhpcy5jb25maWcuZW9zX3Rva2VuX2lkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdCZWFtLmRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgbmV3ZXN0X2JlYW1zLnB1c2gobmV3QmVhbSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKytudW1PdXRwdXRUb2tlbnM7XG5cbiAgICAgICAgICAgIC8vIE5leHQsIHdlIGdldCB0aGUgYmVzdCBiZWFtcywgcGVyIElEXG4gICAgICAgICAgICBuZXdlc3RfYmVhbXMgPSB0aGlzLmdyb3VwQmVhbXMobmV3ZXN0X2JlYW1zKS5tYXAoXG4gICAgICAgICAgICAgICAgZ3JvdXAgPT4gZ3JvdXBcbiAgICAgICAgICAgICAgICAgICAgLnNvcnQoKGEsIGIpID0+IGIuc2NvcmUgLSBhLnNjb3JlKSAgICAgIC8vIHNvcnQgYnkgc2NvcmVcbiAgICAgICAgICAgICAgICAgICAgLnNsaWNlKDAsIGdlbmVyYXRpb25fY29uZmlnLm51bV9iZWFtcykgIC8vIHJlbW92ZSBvdXRzaWRlIGJlYW0gd2lkdGhcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIC8vIEZsYXR0ZW4gYmVhbXNcbiAgICAgICAgICAgIGJlYW1zID0gbmV3ZXN0X2JlYW1zLmZsYXQoKTtcblxuICAgICAgICAgICAgLy8gUnVuIGNhbGxiYWNrXG4gICAgICAgICAgICBpZiAoZ2VuZXJhdGlvbl9jb25maWcuY2FsbGJhY2tfZnVuY3Rpb24pIHtcbiAgICAgICAgICAgICAgICBnZW5lcmF0aW9uX2NvbmZpZy5jYWxsYmFja19mdW5jdGlvbihiZWFtcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUT0RPOiBFbnN1cmUgdGhhdCB3ZSBjYW4gcmV0dXJuIG5vbi1iYXRjaGVkIG91dHB1dHNcblxuICAgICAgICBjb25zdCBncm91cGVkQmVhbXMgPSB0aGlzLmdyb3VwQmVhbXMoYmVhbXMpO1xuXG4gICAgICAgIGNvbnN0IGdldEZsYXR0ZW5lZCA9IChrZXkpID0+IGdyb3VwZWRCZWFtcy5tYXAoXG4gICAgICAgICAgICBiYXRjaCA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGdlbmVyYXRpb25fY29uZmlnLm51bV9yZXR1cm5fc2VxdWVuY2VzID4gMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYmF0Y2guc2xpY2UoMCwgZ2VuZXJhdGlvbl9jb25maWcubnVtX3JldHVybl9zZXF1ZW5jZXMpLm1hcCh4ID0+IHhba2V5XSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtiYXRjaFswXVtrZXldXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICkuZmxhdCgpOyAvLyBGbGF0dGVuIGFjcm9zcyBiYXRjaGVzIChkZXB0aD0xKVxuXG4gICAgICAgIGNvbnN0IHNlcXVlbmNlcyA9IGdldEZsYXR0ZW5lZCgnb3V0cHV0X3Rva2VuX2lkcycpOyAvLyBbMSwgc2VxTGVuZ3RoXVxuXG4gICAgICAgIGlmIChnZW5lcmF0aW9uX2NvbmZpZy5yZXR1cm5fZGljdF9pbl9nZW5lcmF0ZSkge1xuICAgICAgICAgICAgLy8gTk9URTogYGRlY29kZXJfYXR0ZW50aW9uc2AgYW5kIGBjcm9zc19hdHRlbnRpb25zYCBzaG91bGQgYmU6XG4gICAgICAgICAgICAvLyAgICBsaXN0IChvbmUgZWxlbWVudCBmb3IgZWFjaCBnZW5lcmF0ZWQgdG9rZW4pXG4gICAgICAgICAgICAvLyAgICBvZiBsaXN0IChvbmUgZWxlbWVudCBmb3IgZWFjaCBsYXllciBvZiB0aGUgZGVjb2RlcilcbiAgICAgICAgICAgIC8vICAgIG9mIHRvcmNoLkZsb2F0VGVuc29yIG9mIHNoYXBlIChiYXRjaF9zaXplLCBudW1faGVhZHMsIGdlbmVyYXRlZF9sZW5ndGgsIHNlcXVlbmNlX2xlbmd0aClcbiAgICAgICAgICAgIC8vIEhvd2V2ZXIsIHNpbmNlIHdlIGFyZSBvbmx5IGdlbmVyYXRpbmcgb25lIGJhdGNoIGF0IGEgdGltZSwgdGhleSBhcmUgb2YgdGhlIGZvcm06XG4gICAgICAgICAgICAvLyAgIGxpc3QgKGJhdGNoZXMpXG4gICAgICAgICAgICAvLyAgIG9mIGxpc3QgKG9uZSBlbGVtZW50IGZvciBlYWNoIGdlbmVyYXRlZCB0b2tlbilcbiAgICAgICAgICAgIC8vICAgb2YgbGlzdCAob25lIGVsZW1lbnQgZm9yIGVhY2ggbGF5ZXIgb2YgdGhlIGRlY29kZXIpXG4gICAgICAgICAgICAvLyAgIG9mIHRvcmNoLkZsb2F0VGVuc29yIG9mIHNoYXBlICgxLCBudW1faGVhZHMsIGdlbmVyYXRlZF9sZW5ndGgsIHNlcXVlbmNlX2xlbmd0aClcbiAgICAgICAgICAgIC8vIFxuICAgICAgICAgICAgLy8gVE9ETzogSW4gZnV0dXJlICh3aGVuIHRydWUgcGFyYWxsZWxpc20sIHdlIHNob3VsZCBiZSBhYmxlIHRvIHJldHVybiB0aGUgY29ycmVjdCBzaGFwZSlcblxuICAgICAgICAgICAgY29uc3QgZGVjb2Rlcl9hdHRlbnRpb25zID0gZ2V0RmxhdHRlbmVkKCdkZWNvZGVyX2F0dGVudGlvbnMnKTtcbiAgICAgICAgICAgIGNvbnN0IGNyb3NzX2F0dGVudGlvbnMgPSBnZXRGbGF0dGVuZWQoJ2Nyb3NzX2F0dGVudGlvbnMnKTtcblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzZXF1ZW5jZXMsXG5cbiAgICAgICAgICAgICAgICBkZWNvZGVyX2F0dGVudGlvbnMsXG4gICAgICAgICAgICAgICAgY3Jvc3NfYXR0ZW50aW9ucyxcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBzZXF1ZW5jZXM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIZWxwZXIgZnVuY3Rpb24gdG8gYWRkIGF0dGVudGlvbnMgdG8gYmVhbVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBiZWFtIFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvdXRwdXRcbiAgICAgKiBAcHJpdmF0ZSBcbiAgICAgKi9cbiAgICBhZGRBdHRlbnRpb25zVG9CZWFtKGJlYW0sIG91dHB1dCkge1xuICAgICAgICBpZiAodGhpcy5jb25maWcuaXNfZW5jb2Rlcl9kZWNvZGVyKSB7XG4gICAgICAgICAgICBpZiAoIW91dHB1dC5jcm9zc19hdHRlbnRpb25zIHx8IG91dHB1dC5jcm9zc19hdHRlbnRpb25zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICAgICAgICBcImBvdXRwdXRfYXR0ZW50aW9uc2AgaXMgdHJ1ZSwgYnV0IHRoZSBtb2RlbCBkaWQgbm90IHByb2R1Y2UgY3Jvc3MtYXR0ZW50aW9ucy4gXCIgK1xuICAgICAgICAgICAgICAgICAgICBcIlRoaXMgaXMgbW9zdCBsaWtlbHkgYmVjYXVzZSB0aGUgbW9kZWwgd2FzIG5vdCBleHBvcnRlZCB3aXRoIGBvdXRwdXRfYXR0ZW50aW9ucz1UcnVlYC5cIlxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghYmVhbS5jcm9zc19hdHRlbnRpb25zKSB7XG4gICAgICAgICAgICAgICAgYmVhbS5jcm9zc19hdHRlbnRpb25zID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBiZWFtLmNyb3NzX2F0dGVudGlvbnMucHVzaChvdXRwdXQuY3Jvc3NfYXR0ZW50aW9ucyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIW91dHB1dC5kZWNvZGVyX2F0dGVudGlvbnMgfHwgb3V0cHV0LmRlY29kZXJfYXR0ZW50aW9ucy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICAgIFwiYG91dHB1dF9hdHRlbnRpb25zYCBpcyB0cnVlLCBidXQgdGhlIG1vZGVsIGRpZCBub3QgcHJvZHVjZSBkZWNvZGVyLWF0dGVudGlvbnMuIFwiICtcbiAgICAgICAgICAgICAgICBcIlRoaXMgaXMgbW9zdCBsaWtlbHkgYmVjYXVzZSB0aGUgbW9kZWwgd2FzIG5vdCBleHBvcnRlZCB3aXRoIGBvdXRwdXRfYXR0ZW50aW9ucz1UcnVlYC5cIlxuICAgICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICAgIGlmICghYmVhbS5kZWNvZGVyX2F0dGVudGlvbnMpIHtcbiAgICAgICAgICAgIGJlYW0uZGVjb2Rlcl9hdHRlbnRpb25zID0gW107XG4gICAgICAgIH1cbiAgICAgICAgYmVhbS5kZWNvZGVyX2F0dGVudGlvbnMucHVzaChvdXRwdXQuZGVjb2Rlcl9hdHRlbnRpb25zKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHcm91cHMgYW4gYXJyYXkgb2YgYmVhbSBvYmplY3RzIGJ5IHRoZWlyIGlkcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGJlYW1zIFRoZSBhcnJheSBvZiBiZWFtIG9iamVjdHMgdG8gZ3JvdXAuXG4gICAgICogQHJldHVybnMge0FycmF5fSBBbiBhcnJheSBvZiBhcnJheXMsIHdoZXJlIGVhY2ggaW5uZXIgYXJyYXkgY29udGFpbnMgYmVhbSBvYmplY3RzIHdpdGggdGhlIHNhbWUgaWQuXG4gICAgICovXG4gICAgZ3JvdXBCZWFtcyhiZWFtcykge1xuICAgICAgICAvLyBHcm91cCBiZWFtcyBieSB0aGVpciBpZHNcbiAgICAgICAgY29uc3QgZ3JvdXBzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgZm9yIChjb25zdCBvYmogb2YgYmVhbXMpIHtcbiAgICAgICAgICAgIGlmIChncm91cHNbb2JqLmlkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgZ3JvdXBzW29iai5pZF0gPSBbb2JqXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZ3JvdXBzW29iai5pZF0ucHVzaChvYmopO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIE9iamVjdC52YWx1ZXMoZ3JvdXBzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIG9iamVjdCBjb250YWluaW5nIHBhc3Qga2V5IHZhbHVlcyBmcm9tIHRoZSBnaXZlbiBkZWNvZGVyIHJlc3VsdHMgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRlY29kZXJSZXN1bHRzIFRoZSBkZWNvZGVyIHJlc3VsdHMgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXN0S2V5VmFsdWVzIFRoZSBwcmV2aW91cyBwYXN0IGtleSB2YWx1ZXMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgcGFzdCBrZXkgdmFsdWVzLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZ2V0UGFzdEtleVZhbHVlcyhkZWNvZGVyUmVzdWx0cywgcGFzdEtleVZhbHVlcykge1xuXG4gICAgICAgIGNvbnN0IHBrdnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gICAgICAgIGZvciAoY29uc3QgbmFtZSBpbiBkZWNvZGVyUmVzdWx0cykge1xuICAgICAgICAgICAgaWYgKG5hbWUuc3RhcnRzV2l0aCgncHJlc2VudCcpKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5ld05hbWUgPSBuYW1lLnJlcGxhY2UoJ3ByZXNlbnQnLCAncGFzdF9rZXlfdmFsdWVzJyk7XG5cbiAgICAgICAgICAgICAgICBpZiAocGFzdEtleVZhbHVlcyAmJiBuYW1lLmluY2x1ZGVzKCdlbmNvZGVyJykpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gT3B0aW1pemF0aW9uIGludHJvZHVjZWQgYnkgb3B0aW11bSB0byByZXVzZSBwYXN0IGtleSB2YWx1ZXMuIFNvLCB3ZSBqdXN0IHJlcGxhY2UgdGhlIGNvbnN0YW50XG4gICAgICAgICAgICAgICAgICAgIC8vIG91dHB1dHMgd2l0aCB0aGUgcHJldmlvdXMgcGFzdCBrZXkgdmFsdWVzLlxuICAgICAgICAgICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vaHVnZ2luZ2ZhY2Uvb3B0aW11bS9ibG9iLzBiZjJjMDVmYjdlMTE4MmI1MmQyMWI3MDNjZmM5NWZkOWU0ZWEzZGMvb3B0aW11bS9vbm54cnVudGltZS9iYXNlLnB5I0w2NzctTDcwNFxuICAgICAgICAgICAgICAgICAgICBwa3ZzW25ld05hbWVdID0gcGFzdEtleVZhbHVlc1tuZXdOYW1lXTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwa3ZzW25ld05hbWVdID0gZGVjb2RlclJlc3VsdHNbbmFtZV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwa3ZzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gb2JqZWN0IGNvbnRhaW5pbmcgYXR0ZW50aW9ucyBmcm9tIHRoZSBnaXZlbiBkZWNvZGVyIHJlc3VsdHMgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRlY29kZXJSZXN1bHRzIFRoZSBkZWNvZGVyIHJlc3VsdHMgb2JqZWN0LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IEFuIG9iamVjdCBjb250YWluaW5nIGF0dGVudGlvbnMuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBnZXRBdHRlbnRpb25zKGRlY29kZXJSZXN1bHRzKSB7XG4gICAgICAgIGNvbnN0IGF0dG5zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICAgICAgICBmb3IgKGNvbnN0IGF0dG5OYW1lIG9mIFsnY3Jvc3NfYXR0ZW50aW9ucycsICdkZWNvZGVyX2F0dGVudGlvbnMnXSkge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IG5hbWUgaW4gZGVjb2RlclJlc3VsdHMpIHtcbiAgICAgICAgICAgICAgICBpZiAobmFtZS5zdGFydHNXaXRoKGF0dG5OYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpbmRleCA9IG5hbWUuc3BsaXQoJy4nKS5wb3AoKVxuICAgICAgICAgICAgICAgICAgICByZXN1bHRbaW5kZXhdID0gZGVjb2RlclJlc3VsdHNbbmFtZV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXR0bnNbYXR0bk5hbWVdID0gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhdHRucztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIHBhc3Qga2V5IHZhbHVlcyB0byB0aGUgZGVjb2RlciBmZWVkcyBvYmplY3QuIElmIHBhc3RLZXlWYWx1ZXMgaXMgbnVsbCwgY3JlYXRlcyBuZXcgdGVuc29ycyBmb3IgcGFzdCBrZXkgdmFsdWVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRlY29kZXJGZWVkcyBUaGUgZGVjb2RlciBmZWVkcyBvYmplY3QgdG8gYWRkIHBhc3Qga2V5IHZhbHVlcyB0by5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFzdEtleVZhbHVlcyBBbiBvYmplY3QgY29udGFpbmluZyBwYXN0IGtleSB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaGFzRGVjb2Rlcj1mYWxzZV0gV2hldGhlciB0aGUgbW9kZWwgaGFzIGEgZGVjb2Rlci5cbiAgICAgKi9cbiAgICBhZGRQYXN0S2V5VmFsdWVzKGRlY29kZXJGZWVkcywgcGFzdEtleVZhbHVlcywgaGFzRGVjb2RlciA9IGZhbHNlKSB7XG4gICAgICAgIGlmIChwYXN0S2V5VmFsdWVzKSB7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKGRlY29kZXJGZWVkcywgcGFzdEtleVZhbHVlcylcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFRPRE8gc3VwcG9ydCBiYXRjaGVzIChpLmUuLCBiYXRjaF9zaXplID4gMSlcbiAgICAgICAgICAgIGlmIChoYXNEZWNvZGVyKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgIGxldCBlbmNvZGVyX2RpbXMgPSBbMSwgdGhpcy5udW1fZW5jb2Rlcl9oZWFkcywgMCwgdGhpcy5lbmNvZGVyX2RpbV9rdl07XG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5udW1fZW5jb2Rlcl9sYXllcnM7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBkZWNvZGVyRmVlZHNbYHBhc3Rfa2V5X3ZhbHVlcy4ke2l9LmVuY29kZXIua2V5YF0gPSBuZXcgVGVuc29yKCdmbG9hdDMyJywgW10sIGVuY29kZXJfZGltcylcbiAgICAgICAgICAgICAgICAgICAgZGVjb2RlckZlZWRzW2BwYXN0X2tleV92YWx1ZXMuJHtpfS5lbmNvZGVyLnZhbHVlYF0gPSBuZXcgVGVuc29yKCdmbG9hdDMyJywgW10sIGVuY29kZXJfZGltcylcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgbGV0IGRlY29kZXJfZGltcyA9IFsxLCB0aGlzLm51bV9kZWNvZGVyX2hlYWRzLCAwLCB0aGlzLmRlY29kZXJfZGltX2t2XTtcbiAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm51bV9kZWNvZGVyX2xheWVyczsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlY29kZXJGZWVkc1tgcGFzdF9rZXlfdmFsdWVzLiR7aX0uZGVjb2Rlci5rZXlgXSA9IG5ldyBUZW5zb3IoJ2Zsb2F0MzInLCBbXSwgZGVjb2Rlcl9kaW1zKVxuICAgICAgICAgICAgICAgICAgICBkZWNvZGVyRmVlZHNbYHBhc3Rfa2V5X3ZhbHVlcy4ke2l9LmRlY29kZXIudmFsdWVgXSA9IG5ldyBUZW5zb3IoJ2Zsb2F0MzInLCBbXSwgZGVjb2Rlcl9kaW1zKVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgbGV0IGRpbXMgPSBbMSwgdGhpcy5udW1faGVhZHMsIDAsIHRoaXMuZGltX2t2XVxuICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubnVtX2xheWVyczsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlY29kZXJGZWVkc1tgcGFzdF9rZXlfdmFsdWVzLiR7aX0ua2V5YF0gPSBuZXcgVGVuc29yKCdmbG9hdDMyJywgW10sIGRpbXMpXG4gICAgICAgICAgICAgICAgICAgIGRlY29kZXJGZWVkc1tgcGFzdF9rZXlfdmFsdWVzLiR7aX0udmFsdWVgXSA9IG5ldyBUZW5zb3IoJ2Zsb2F0MzInLCBbXSwgZGltcylcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gQmFzZSBtb2RlbCBvdXRwdXQgY2xhc3NcbmV4cG9ydCBjbGFzcyBNb2RlbE91dHB1dCB7IH1cblxuLyoqXG4gKiBCYXNlIGNsYXNzIGZvciBtb2RlbCdzIG91dHB1dHMsIHdpdGggcG90ZW50aWFsIGhpZGRlbiBzdGF0ZXMgYW5kIGF0dGVudGlvbnMuXG4gKi9cbmV4cG9ydCBjbGFzcyBCYXNlTW9kZWxPdXRwdXQgZXh0ZW5kcyBNb2RlbE91dHB1dCB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG91dHB1dCBUaGUgb3V0cHV0IG9mIHRoZSBtb2RlbC5cbiAgICAgKiBAcGFyYW0ge1RlbnNvcn0gb3V0cHV0Lmxhc3RfaGlkZGVuX3N0YXRlIFNlcXVlbmNlIG9mIGhpZGRlbi1zdGF0ZXMgYXQgdGhlIG91dHB1dCBvZiB0aGUgbGFzdCBsYXllciBvZiB0aGUgbW9kZWwuXG4gICAgICogQHBhcmFtIHtUZW5zb3J9IFtvdXRwdXQuaGlkZGVuX3N0YXRlc10gSGlkZGVuLXN0YXRlcyBvZiB0aGUgbW9kZWwgYXQgdGhlIG91dHB1dCBvZiBlYWNoIGxheWVyIHBsdXMgdGhlIG9wdGlvbmFsIGluaXRpYWwgZW1iZWRkaW5nIG91dHB1dHMuXG4gICAgICogQHBhcmFtIHtUZW5zb3J9IFtvdXRwdXQuYXR0ZW50aW9uc10gQXR0ZW50aW9ucyB3ZWlnaHRzIGFmdGVyIHRoZSBhdHRlbnRpb24gc29mdG1heCwgdXNlZCB0byBjb21wdXRlIHRoZSB3ZWlnaHRlZCBhdmVyYWdlIGluIHRoZSBzZWxmLWF0dGVudGlvbiBoZWFkcy5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih7IGxhc3RfaGlkZGVuX3N0YXRlLCBoaWRkZW5fc3RhdGVzID0gbnVsbCwgYXR0ZW50aW9ucyA9IG51bGwgfSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmxhc3RfaGlkZGVuX3N0YXRlID0gbGFzdF9oaWRkZW5fc3RhdGU7XG4gICAgICAgIHRoaXMuaGlkZGVuX3N0YXRlcyA9IGhpZGRlbl9zdGF0ZXM7XG4gICAgICAgIHRoaXMuYXR0ZW50aW9ucyA9IGF0dGVudGlvbnM7XG4gICAgfVxufVxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIEJlcnQgbW9kZWxzXG5leHBvcnQgY2xhc3MgQmVydFByZVRyYWluZWRNb2RlbCBleHRlbmRzIFByZVRyYWluZWRNb2RlbCB7IH1cbmV4cG9ydCBjbGFzcyBCZXJ0TW9kZWwgZXh0ZW5kcyBCZXJ0UHJlVHJhaW5lZE1vZGVsIHsgfVxuXG4vKipcbiAqIEJlcnRGb3JNYXNrZWRMTSBpcyBhIGNsYXNzIHJlcHJlc2VudGluZyBhIEJFUlQgbW9kZWwgZm9yIG1hc2tlZCBsYW5ndWFnZSBtb2RlbGluZy5cbiAqIEBleHRlbmRzIEJlcnRQcmVUcmFpbmVkTW9kZWxcbiAqL1xuZXhwb3J0IGNsYXNzIEJlcnRGb3JNYXNrZWRMTSBleHRlbmRzIEJlcnRQcmVUcmFpbmVkTW9kZWwge1xuICAgIC8qKlxuICAgICAqIENhbGxzIHRoZSBtb2RlbCBvbiBuZXcgaW5wdXRzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1vZGVsX2lucHV0cyBUaGUgaW5wdXRzIHRvIHRoZSBtb2RlbC5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxNYXNrZWRMTU91dHB1dD59IEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBtb2RlbCdzIG91dHB1dCBsb2dpdHMgZm9yIG1hc2tlZCBsYW5ndWFnZSBtb2RlbGluZy5cbiAgICAgKi9cbiAgICBhc3luYyBfY2FsbChtb2RlbF9pbnB1dHMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBNYXNrZWRMTU91dHB1dChhd2FpdCBzdXBlci5fY2FsbChtb2RlbF9pbnB1dHMpKTtcbiAgICB9XG59XG5cbi8qKlxuICogQmVydEZvclNlcXVlbmNlQ2xhc3NpZmljYXRpb24gaXMgYSBjbGFzcyByZXByZXNlbnRpbmcgYSBCRVJUIG1vZGVsIGZvciBzZXF1ZW5jZSBjbGFzc2lmaWNhdGlvbi5cbiAqIEBleHRlbmRzIEJlcnRQcmVUcmFpbmVkTW9kZWxcbiAqL1xuZXhwb3J0IGNsYXNzIEJlcnRGb3JTZXF1ZW5jZUNsYXNzaWZpY2F0aW9uIGV4dGVuZHMgQmVydFByZVRyYWluZWRNb2RlbCB7XG4gICAgLyoqXG4gICAgICogQ2FsbHMgdGhlIG1vZGVsIG9uIG5ldyBpbnB1dHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbW9kZWxfaW5wdXRzIFRoZSBpbnB1dHMgdG8gdGhlIG1vZGVsLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFNlcXVlbmNlQ2xhc3NpZmllck91dHB1dD59IEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBtb2RlbCdzIG91dHB1dCBsb2dpdHMgZm9yIHNlcXVlbmNlIGNsYXNzaWZpY2F0aW9uLlxuICAgICAqL1xuICAgIGFzeW5jIF9jYWxsKG1vZGVsX2lucHV0cykge1xuICAgICAgICByZXR1cm4gbmV3IFNlcXVlbmNlQ2xhc3NpZmllck91dHB1dChhd2FpdCBzdXBlci5fY2FsbChtb2RlbF9pbnB1dHMpKTtcbiAgICB9XG59XG5cbi8qKlxuICogQmVydEZvclRva2VuQ2xhc3NpZmljYXRpb24gaXMgYSBjbGFzcyByZXByZXNlbnRpbmcgYSBCRVJUIG1vZGVsIGZvciB0b2tlbiBjbGFzc2lmaWNhdGlvbi5cbiAqIEBleHRlbmRzIEJlcnRQcmVUcmFpbmVkTW9kZWxcbiAqL1xuZXhwb3J0IGNsYXNzIEJlcnRGb3JUb2tlbkNsYXNzaWZpY2F0aW9uIGV4dGVuZHMgQmVydFByZVRyYWluZWRNb2RlbCB7XG4gICAgLyoqXG4gICAgICogQ2FsbHMgdGhlIG1vZGVsIG9uIG5ldyBpbnB1dHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbW9kZWxfaW5wdXRzIFRoZSBpbnB1dHMgdG8gdGhlIG1vZGVsLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFRva2VuQ2xhc3NpZmllck91dHB1dD59IEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBtb2RlbCdzIG91dHB1dCBsb2dpdHMgZm9yIHRva2VuIGNsYXNzaWZpY2F0aW9uLlxuICAgICAqL1xuICAgIGFzeW5jIF9jYWxsKG1vZGVsX2lucHV0cykge1xuICAgICAgICByZXR1cm4gbmV3IFRva2VuQ2xhc3NpZmllck91dHB1dChhd2FpdCBzdXBlci5fY2FsbChtb2RlbF9pbnB1dHMpKTtcbiAgICB9XG59XG5cbi8qKlxuICogQmVydEZvclF1ZXN0aW9uQW5zd2VyaW5nIGlzIGEgY2xhc3MgcmVwcmVzZW50aW5nIGEgQkVSVCBtb2RlbCBmb3IgcXVlc3Rpb24gYW5zd2VyaW5nLlxuICogQGV4dGVuZHMgQmVydFByZVRyYWluZWRNb2RlbFxuICovXG5leHBvcnQgY2xhc3MgQmVydEZvclF1ZXN0aW9uQW5zd2VyaW5nIGV4dGVuZHMgQmVydFByZVRyYWluZWRNb2RlbCB7XG4gICAgLyoqXG4gICAgICogQ2FsbHMgdGhlIG1vZGVsIG9uIG5ldyBpbnB1dHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbW9kZWxfaW5wdXRzIFRoZSBpbnB1dHMgdG8gdGhlIG1vZGVsLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFF1ZXN0aW9uQW5zd2VyaW5nTW9kZWxPdXRwdXQ+fSBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgbW9kZWwncyBvdXRwdXQgbG9naXRzIGZvciBxdWVzdGlvbiBhbnN3ZXJpbmcuXG4gICAgICovXG4gICAgYXN5bmMgX2NhbGwobW9kZWxfaW5wdXRzKSB7XG4gICAgICAgIHJldHVybiBuZXcgUXVlc3Rpb25BbnN3ZXJpbmdNb2RlbE91dHB1dChhd2FpdCBzdXBlci5fY2FsbChtb2RlbF9pbnB1dHMpKTtcbiAgICB9XG59XG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gRGlzdGlsQmVydCBtb2RlbHNcbmV4cG9ydCBjbGFzcyBEaXN0aWxCZXJ0UHJlVHJhaW5lZE1vZGVsIGV4dGVuZHMgUHJlVHJhaW5lZE1vZGVsIHsgfVxuZXhwb3J0IGNsYXNzIERpc3RpbEJlcnRNb2RlbCBleHRlbmRzIERpc3RpbEJlcnRQcmVUcmFpbmVkTW9kZWwgeyB9XG5cbi8qKlxuICogRGlzdGlsQmVydEZvclNlcXVlbmNlQ2xhc3NpZmljYXRpb24gaXMgYSBjbGFzcyByZXByZXNlbnRpbmcgYSBEaXN0aWxCRVJUIG1vZGVsIGZvciBzZXF1ZW5jZSBjbGFzc2lmaWNhdGlvbi5cbiAqIEBleHRlbmRzIERpc3RpbEJlcnRQcmVUcmFpbmVkTW9kZWxcbiAqL1xuZXhwb3J0IGNsYXNzIERpc3RpbEJlcnRGb3JTZXF1ZW5jZUNsYXNzaWZpY2F0aW9uIGV4dGVuZHMgRGlzdGlsQmVydFByZVRyYWluZWRNb2RlbCB7XG4gICAgLyoqXG4gICAgICogQ2FsbHMgdGhlIG1vZGVsIG9uIG5ldyBpbnB1dHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbW9kZWxfaW5wdXRzIFRoZSBpbnB1dHMgdG8gdGhlIG1vZGVsLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFNlcXVlbmNlQ2xhc3NpZmllck91dHB1dD59IEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBtb2RlbCdzIG91dHB1dCBsb2dpdHMgZm9yIHNlcXVlbmNlIGNsYXNzaWZpY2F0aW9uLlxuICAgICAqL1xuICAgIGFzeW5jIF9jYWxsKG1vZGVsX2lucHV0cykge1xuICAgICAgICByZXR1cm4gbmV3IFNlcXVlbmNlQ2xhc3NpZmllck91dHB1dChhd2FpdCBzdXBlci5fY2FsbChtb2RlbF9pbnB1dHMpKTtcbiAgICB9XG59XG5cbi8qKlxuICogRGlzdGlsQmVydEZvclRva2VuQ2xhc3NpZmljYXRpb24gaXMgYSBjbGFzcyByZXByZXNlbnRpbmcgYSBEaXN0aWxCRVJUIG1vZGVsIGZvciB0b2tlbiBjbGFzc2lmaWNhdGlvbi5cbiAqIEBleHRlbmRzIERpc3RpbEJlcnRQcmVUcmFpbmVkTW9kZWxcbiAqL1xuZXhwb3J0IGNsYXNzIERpc3RpbEJlcnRGb3JUb2tlbkNsYXNzaWZpY2F0aW9uIGV4dGVuZHMgRGlzdGlsQmVydFByZVRyYWluZWRNb2RlbCB7XG4gICAgLyoqXG4gICAgICogQ2FsbHMgdGhlIG1vZGVsIG9uIG5ldyBpbnB1dHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbW9kZWxfaW5wdXRzIFRoZSBpbnB1dHMgdG8gdGhlIG1vZGVsLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFRva2VuQ2xhc3NpZmllck91dHB1dD59IEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBtb2RlbCdzIG91dHB1dCBsb2dpdHMgZm9yIHRva2VuIGNsYXNzaWZpY2F0aW9uLlxuICAgICAqL1xuICAgIGFzeW5jIF9jYWxsKG1vZGVsX2lucHV0cykge1xuICAgICAgICByZXR1cm4gbmV3IFRva2VuQ2xhc3NpZmllck91dHB1dChhd2FpdCBzdXBlci5fY2FsbChtb2RlbF9pbnB1dHMpKTtcbiAgICB9XG59XG5cblxuLyoqXG4gKiBEaXN0aWxCZXJ0Rm9yUXVlc3Rpb25BbnN3ZXJpbmcgaXMgYSBjbGFzcyByZXByZXNlbnRpbmcgYSBEaXN0aWxCRVJUIG1vZGVsIGZvciBxdWVzdGlvbiBhbnN3ZXJpbmcuXG4gKiBAZXh0ZW5kcyBEaXN0aWxCZXJ0UHJlVHJhaW5lZE1vZGVsXG4gKi9cbmV4cG9ydCBjbGFzcyBEaXN0aWxCZXJ0Rm9yUXVlc3Rpb25BbnN3ZXJpbmcgZXh0ZW5kcyBEaXN0aWxCZXJ0UHJlVHJhaW5lZE1vZGVsIHtcbiAgICAvKipcbiAgICAgKiBDYWxscyB0aGUgbW9kZWwgb24gbmV3IGlucHV0cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtb2RlbF9pbnB1dHMgVGhlIGlucHV0cyB0byB0aGUgbW9kZWwuXG4gICAgICogQHJldHVybnMge1Byb21pc2U8UXVlc3Rpb25BbnN3ZXJpbmdNb2RlbE91dHB1dD59IEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBtb2RlbCdzIG91dHB1dCBsb2dpdHMgZm9yIHF1ZXN0aW9uIGFuc3dlcmluZy5cbiAgICAgKi9cbiAgICBhc3luYyBfY2FsbChtb2RlbF9pbnB1dHMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBRdWVzdGlvbkFuc3dlcmluZ01vZGVsT3V0cHV0KGF3YWl0IHN1cGVyLl9jYWxsKG1vZGVsX2lucHV0cykpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBEaXN0aWxCZXJ0Rm9yTWFza2VkTE0gaXMgYSBjbGFzcyByZXByZXNlbnRpbmcgYSBEaXN0aWxCRVJUIG1vZGVsIGZvciBtYXNraW5nIHRhc2suXG4gKiBAZXh0ZW5kcyBEaXN0aWxCZXJ0UHJlVHJhaW5lZE1vZGVsXG4gKi9cbmV4cG9ydCBjbGFzcyBEaXN0aWxCZXJ0Rm9yTWFza2VkTE0gZXh0ZW5kcyBEaXN0aWxCZXJ0UHJlVHJhaW5lZE1vZGVsIHtcbiAgICAvKipcbiAgICAgKiBDYWxscyB0aGUgbW9kZWwgb24gbmV3IGlucHV0cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtb2RlbF9pbnB1dHMgVGhlIGlucHV0cyB0byB0aGUgbW9kZWwuXG4gICAgICogQHJldHVybnMge1Byb21pc2U8TWFza2VkTE1PdXRwdXQ+fSByZXR1cm5lZCBvYmplY3RcbiAgICAgKi9cbiAgICBhc3luYyBfY2FsbChtb2RlbF9pbnB1dHMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBNYXNrZWRMTU91dHB1dChhd2FpdCBzdXBlci5fY2FsbChtb2RlbF9pbnB1dHMpKTtcbiAgICB9XG59XG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBNb2JpbGVCZXJ0IG1vZGVsc1xuZXhwb3J0IGNsYXNzIE1vYmlsZUJlcnRQcmVUcmFpbmVkTW9kZWwgZXh0ZW5kcyBQcmVUcmFpbmVkTW9kZWwgeyB9XG5leHBvcnQgY2xhc3MgTW9iaWxlQmVydE1vZGVsIGV4dGVuZHMgTW9iaWxlQmVydFByZVRyYWluZWRNb2RlbCB7IH1cblxuLyoqXG4gKiBNb2JpbGVCZXJ0Rm9yTWFza2VkTE0gaXMgYSBjbGFzcyByZXByZXNlbnRpbmcgYSBNb2JpbGVCRVJUIG1vZGVsIGZvciBtYXNraW5nIHRhc2suXG4gKiBAZXh0ZW5kcyBNb2JpbGVCZXJ0UHJlVHJhaW5lZE1vZGVsXG4gKi9cbmV4cG9ydCBjbGFzcyBNb2JpbGVCZXJ0Rm9yTWFza2VkTE0gZXh0ZW5kcyBNb2JpbGVCZXJ0UHJlVHJhaW5lZE1vZGVsIHtcbiAgICAvKipcbiAgICAgKiBDYWxscyB0aGUgbW9kZWwgb24gbmV3IGlucHV0cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtb2RlbF9pbnB1dHMgVGhlIGlucHV0cyB0byB0aGUgbW9kZWwuXG4gICAgICogQHJldHVybnMge1Byb21pc2U8TWFza2VkTE1PdXRwdXQ+fSByZXR1cm5lZCBvYmplY3RcbiAgICAgKi9cbiAgICBhc3luYyBfY2FsbChtb2RlbF9pbnB1dHMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBNYXNrZWRMTU91dHB1dChhd2FpdCBzdXBlci5fY2FsbChtb2RlbF9pbnB1dHMpKTtcbiAgICB9XG59XG5cbi8qKlxuICogQGV4dGVuZHMgTW9iaWxlQmVydFByZVRyYWluZWRNb2RlbFxuICovXG5leHBvcnQgY2xhc3MgTW9iaWxlQmVydEZvclNlcXVlbmNlQ2xhc3NpZmljYXRpb24gZXh0ZW5kcyBNb2JpbGVCZXJ0UHJlVHJhaW5lZE1vZGVsIHtcbiAgICAvKipcbiAgICAgKiBDYWxscyB0aGUgbW9kZWwgb24gbmV3IGlucHV0cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtb2RlbF9pbnB1dHMgVGhlIGlucHV0cyB0byB0aGUgbW9kZWwuXG4gICAgICogQHJldHVybnMge1Byb21pc2U8U2VxdWVuY2VDbGFzc2lmaWVyT3V0cHV0Pn0gcmV0dXJuZWQgb2JqZWN0XG4gICAgICovXG4gICAgYXN5bmMgX2NhbGwobW9kZWxfaW5wdXRzKSB7XG4gICAgICAgIHJldHVybiBuZXcgU2VxdWVuY2VDbGFzc2lmaWVyT3V0cHV0KGF3YWl0IHN1cGVyLl9jYWxsKG1vZGVsX2lucHV0cykpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAZXh0ZW5kcyBNb2JpbGVCZXJ0UHJlVHJhaW5lZE1vZGVsXG4gKi9cbmV4cG9ydCBjbGFzcyBNb2JpbGVCZXJ0Rm9yUXVlc3Rpb25BbnN3ZXJpbmcgZXh0ZW5kcyBNb2JpbGVCZXJ0UHJlVHJhaW5lZE1vZGVsIHtcbiAgICAvKipcbiAgICAgKiBDYWxscyB0aGUgbW9kZWwgb24gbmV3IGlucHV0cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtb2RlbF9pbnB1dHMgVGhlIGlucHV0cyB0byB0aGUgbW9kZWwuXG4gICAgICogQHJldHVybnMge1Byb21pc2U8UXVlc3Rpb25BbnN3ZXJpbmdNb2RlbE91dHB1dD59IHJldHVybmVkIG9iamVjdFxuICAgICAqL1xuICAgIGFzeW5jIF9jYWxsKG1vZGVsX2lucHV0cykge1xuICAgICAgICByZXR1cm4gbmV3IFF1ZXN0aW9uQW5zd2VyaW5nTW9kZWxPdXRwdXQoYXdhaXQgc3VwZXIuX2NhbGwobW9kZWxfaW5wdXRzKSk7XG4gICAgfVxufVxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gU3F1ZWV6ZUJlcnQgbW9kZWxzXG5leHBvcnQgY2xhc3MgU3F1ZWV6ZUJlcnRQcmVUcmFpbmVkTW9kZWwgZXh0ZW5kcyBQcmVUcmFpbmVkTW9kZWwgeyB9XG5leHBvcnQgY2xhc3MgU3F1ZWV6ZUJlcnRNb2RlbCBleHRlbmRzIFNxdWVlemVCZXJ0UHJlVHJhaW5lZE1vZGVsIHsgfVxuZXhwb3J0IGNsYXNzIFNxdWVlemVCZXJ0Rm9yTWFza2VkTE0gZXh0ZW5kcyBTcXVlZXplQmVydFByZVRyYWluZWRNb2RlbCB7XG4gICAgLyoqXG4gICAgICogQ2FsbHMgdGhlIG1vZGVsIG9uIG5ldyBpbnB1dHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbW9kZWxfaW5wdXRzIFRoZSBpbnB1dHMgdG8gdGhlIG1vZGVsLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPE1hc2tlZExNT3V0cHV0Pn0gcmV0dXJuZWQgb2JqZWN0XG4gICAgICovXG4gICAgYXN5bmMgX2NhbGwobW9kZWxfaW5wdXRzKSB7XG4gICAgICAgIHJldHVybiBuZXcgTWFza2VkTE1PdXRwdXQoYXdhaXQgc3VwZXIuX2NhbGwobW9kZWxfaW5wdXRzKSk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIFNxdWVlemVCZXJ0Rm9yU2VxdWVuY2VDbGFzc2lmaWNhdGlvbiBleHRlbmRzIFNxdWVlemVCZXJ0UHJlVHJhaW5lZE1vZGVsIHtcbiAgICAvKipcbiAgICAgKiBDYWxscyB0aGUgbW9kZWwgb24gbmV3IGlucHV0cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtb2RlbF9pbnB1dHMgVGhlIGlucHV0cyB0byB0aGUgbW9kZWwuXG4gICAgICogQHJldHVybnMge1Byb21pc2U8U2VxdWVuY2VDbGFzc2lmaWVyT3V0cHV0Pn0gcmV0dXJuZWQgb2JqZWN0XG4gICAgICovXG4gICAgYXN5bmMgX2NhbGwobW9kZWxfaW5wdXRzKSB7XG4gICAgICAgIHJldHVybiBuZXcgU2VxdWVuY2VDbGFzc2lmaWVyT3V0cHV0KGF3YWl0IHN1cGVyLl9jYWxsKG1vZGVsX2lucHV0cykpO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBTcXVlZXplQmVydEZvclF1ZXN0aW9uQW5zd2VyaW5nIGV4dGVuZHMgU3F1ZWV6ZUJlcnRQcmVUcmFpbmVkTW9kZWwge1xuICAgIC8qKlxuICAgICAqIENhbGxzIHRoZSBtb2RlbCBvbiBuZXcgaW5wdXRzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1vZGVsX2lucHV0cyBUaGUgaW5wdXRzIHRvIHRoZSBtb2RlbC5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxRdWVzdGlvbkFuc3dlcmluZ01vZGVsT3V0cHV0Pn0gcmV0dXJuZWQgb2JqZWN0XG4gICAgICovXG4gICAgYXN5bmMgX2NhbGwobW9kZWxfaW5wdXRzKSB7XG4gICAgICAgIHJldHVybiBuZXcgUXVlc3Rpb25BbnN3ZXJpbmdNb2RlbE91dHB1dChhd2FpdCBzdXBlci5fY2FsbChtb2RlbF9pbnB1dHMpKTtcbiAgICB9XG59XG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBBbGJlcnQgbW9kZWxzXG5leHBvcnQgY2xhc3MgQWxiZXJ0UHJlVHJhaW5lZE1vZGVsIGV4dGVuZHMgUHJlVHJhaW5lZE1vZGVsIHsgfVxuZXhwb3J0IGNsYXNzIEFsYmVydE1vZGVsIGV4dGVuZHMgQWxiZXJ0UHJlVHJhaW5lZE1vZGVsIHsgfVxuZXhwb3J0IGNsYXNzIEFsYmVydEZvclNlcXVlbmNlQ2xhc3NpZmljYXRpb24gZXh0ZW5kcyBBbGJlcnRQcmVUcmFpbmVkTW9kZWwge1xuICAgIC8qKlxuICAgICAqIENhbGxzIHRoZSBtb2RlbCBvbiBuZXcgaW5wdXRzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1vZGVsX2lucHV0cyBUaGUgaW5wdXRzIHRvIHRoZSBtb2RlbC5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxTZXF1ZW5jZUNsYXNzaWZpZXJPdXRwdXQ+fSByZXR1cm5lZCBvYmplY3RcbiAgICAgKi9cbiAgICBhc3luYyBfY2FsbChtb2RlbF9pbnB1dHMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTZXF1ZW5jZUNsYXNzaWZpZXJPdXRwdXQoYXdhaXQgc3VwZXIuX2NhbGwobW9kZWxfaW5wdXRzKSk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIEFsYmVydEZvclF1ZXN0aW9uQW5zd2VyaW5nIGV4dGVuZHMgQWxiZXJ0UHJlVHJhaW5lZE1vZGVsIHtcbiAgICAvKipcbiAgICAgKiBDYWxscyB0aGUgbW9kZWwgb24gbmV3IGlucHV0cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtb2RlbF9pbnB1dHMgVGhlIGlucHV0cyB0byB0aGUgbW9kZWwuXG4gICAgICogQHJldHVybnMge1Byb21pc2U8UXVlc3Rpb25BbnN3ZXJpbmdNb2RlbE91dHB1dD59IHJldHVybmVkIG9iamVjdFxuICAgICAqL1xuICAgIGFzeW5jIF9jYWxsKG1vZGVsX2lucHV0cykge1xuICAgICAgICByZXR1cm4gbmV3IFF1ZXN0aW9uQW5zd2VyaW5nTW9kZWxPdXRwdXQoYXdhaXQgc3VwZXIuX2NhbGwobW9kZWxfaW5wdXRzKSk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIEFsYmVydEZvck1hc2tlZExNIGV4dGVuZHMgQWxiZXJ0UHJlVHJhaW5lZE1vZGVsIHtcbiAgICAvKipcbiAgICAgKiBDYWxscyB0aGUgbW9kZWwgb24gbmV3IGlucHV0cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtb2RlbF9pbnB1dHMgVGhlIGlucHV0cyB0byB0aGUgbW9kZWwuXG4gICAgICogQHJldHVybnMge1Byb21pc2U8TWFza2VkTE1PdXRwdXQ+fSByZXR1cm5lZCBvYmplY3RcbiAgICAgKi9cbiAgICBhc3luYyBfY2FsbChtb2RlbF9pbnB1dHMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBNYXNrZWRMTU91dHB1dChhd2FpdCBzdXBlci5fY2FsbChtb2RlbF9pbnB1dHMpKTtcbiAgICB9XG59XG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBUNSBtb2RlbHNcbmV4cG9ydCBjbGFzcyBUNVByZVRyYWluZWRNb2RlbCBleHRlbmRzIFByZVRyYWluZWRNb2RlbCB7IH07XG5cbmV4cG9ydCBjbGFzcyBUNU1vZGVsIGV4dGVuZHMgVDVQcmVUcmFpbmVkTW9kZWwge1xuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyB0ZXh0IGJhc2VkIG9uIHRoZSBwcm92aWRlZCBhcmd1bWVudHMuXG4gICAgICogQHRocm93cyB7RXJyb3J9IFRocm93cyBhbiBlcnJvciBhcyB0aGUgY3VycmVudCBtb2RlbCBjbGFzcyAoVDVNb2RlbCkgaXMgbm90IGNvbXBhdGlibGUgd2l0aCBgLmdlbmVyYXRlKClgLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPGFueT59XG4gICAgICogQHBhcmFtIHthbnlbXX0gYXJnc1xuICAgICAqL1xuICAgIGFzeW5jIGdlbmVyYXRlKC4uLmFyZ3MpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICBcIlRoZSBjdXJyZW50IG1vZGVsIGNsYXNzIChUNU1vZGVsKSBpcyBub3QgY29tcGF0aWJsZSB3aXRoIGAuZ2VuZXJhdGUoKWAsIGFzIGl0IGRvZXNuJ3QgaGF2ZSBhIGxhbmd1YWdlIG1vZGVsIGhlYWQuIFBsZWFzZSB1c2Ugb25lIG9mIHRoZSBmb2xsb3dpbmcgY2xhc3NlcyBpbnN0ZWFkOiB7J1Q1Rm9yQ29uZGl0aW9uYWxHZW5lcmF0aW9uJ31cIlxuICAgICAgICApXG4gICAgfVxufVxuXG4vKipcbiAqIFQ1TW9kZWwgaXMgYSBjbGFzcyByZXByZXNlbnRpbmcgYSBUNSBtb2RlbCBmb3IgY29uZGl0aW9uYWwgZ2VuZXJhdGlvbi5cbiAqIEBleHRlbmRzIFQ1UHJlVHJhaW5lZE1vZGVsXG4gKi9cbmV4cG9ydCBjbGFzcyBUNUZvckNvbmRpdGlvbmFsR2VuZXJhdGlvbiBleHRlbmRzIFQ1UHJlVHJhaW5lZE1vZGVsIHtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgdGhlIGBUNUZvckNvbmRpdGlvbmFsR2VuZXJhdGlvbmAgY2xhc3MuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBUaGUgbW9kZWwgY29uZmlndXJhdGlvbi5cbiAgICAgKiBAcGFyYW0ge2FueX0gc2Vzc2lvbiBzZXNzaW9uIGZvciB0aGUgbW9kZWwuXG4gICAgICogQHBhcmFtIHthbnl9IGRlY29kZXJfbWVyZ2VkX3Nlc3Npb24gc2Vzc2lvbiBmb3IgdGhlIGRlY29kZXIuXG4gICAgICogQHBhcmFtIHtHZW5lcmF0aW9uQ29uZmlnfSBnZW5lcmF0aW9uX2NvbmZpZyBUaGUgZ2VuZXJhdGlvbiBjb25maWd1cmF0aW9uLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZywgc2Vzc2lvbiwgZGVjb2Rlcl9tZXJnZWRfc2Vzc2lvbiwgZ2VuZXJhdGlvbl9jb25maWcpIHtcbiAgICAgICAgc3VwZXIoY29uZmlnLCBzZXNzaW9uKTtcbiAgICAgICAgdGhpcy5kZWNvZGVyX21lcmdlZF9zZXNzaW9uID0gZGVjb2Rlcl9tZXJnZWRfc2Vzc2lvbjtcbiAgICAgICAgdGhpcy5nZW5lcmF0aW9uX2NvbmZpZyA9IGdlbmVyYXRpb25fY29uZmlnO1xuXG4gICAgICAgIHRoaXMubnVtX2RlY29kZXJfbGF5ZXJzID0gdGhpcy5jb25maWcubnVtX2RlY29kZXJfbGF5ZXJzO1xuICAgICAgICB0aGlzLm51bV9kZWNvZGVyX2hlYWRzID0gdGhpcy5jb25maWcubnVtX2hlYWRzO1xuICAgICAgICB0aGlzLmRlY29kZXJfZGltX2t2ID0gdGhpcy5jb25maWcuZF9rdjtcblxuICAgICAgICB0aGlzLm51bV9lbmNvZGVyX2xheWVycyA9IHRoaXMuY29uZmlnLm51bV9sYXllcnM7XG4gICAgICAgIHRoaXMubnVtX2VuY29kZXJfaGVhZHMgPSB0aGlzLmNvbmZpZy5udW1faGVhZHM7XG4gICAgICAgIHRoaXMuZW5jb2Rlcl9kaW1fa3YgPSB0aGlzLmNvbmZpZy5kX2t2O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyB0aGUgc3RhcnQgYmVhbXMgZm9yIGEgZ2l2ZW4gc2V0IG9mIGlucHV0cyBhbmQgb3V0cHV0IGxlbmd0aC5cbiAgICAgKiBAcGFyYW0ge251bWJlcltdW119IGlucHV0cyBUaGUgaW5wdXQgdG9rZW4gSURzLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBudW1PdXRwdXRUb2tlbnMgVGhlIGRlc2lyZWQgb3V0cHV0IGxlbmd0aC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFRoZSBzdGFydCBiZWFtcy5cbiAgICAgKi9cbiAgICBnZXRTdGFydEJlYW1zKGlucHV0cywgbnVtT3V0cHV0VG9rZW5zLCAuLi5hcmdzKSB7XG4gICAgICAgIHJldHVybiBzZXEyc2VxU3RhcnRCZWFtcyh0aGlzLCBpbnB1dHMsIG51bU91dHB1dFRva2Vucyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUnVucyBhIHNpbmdsZSBzdGVwIG9mIHRoZSBiZWFtIHNlYXJjaCBnZW5lcmF0aW9uIGFsZ29yaXRobS5cbiAgICAgKiBAcGFyYW0ge2FueX0gYmVhbSBUaGUgY3VycmVudCBiZWFtIGJlaW5nIGdlbmVyYXRlZC5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxhbnk+fSBUaGUgdXBkYXRlZCBiZWFtIGFmdGVyIGEgc2luZ2xlIGdlbmVyYXRpb24gc3RlcC5cbiAgICAgKi9cbiAgICBhc3luYyBydW5CZWFtKGJlYW0pIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHNlcTJzZXFSdW5CZWFtKHRoaXMsIGJlYW0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIGdpdmVuIGJlYW0gd2l0aCBhIG5ldyB0b2tlbiBJRC5cbiAgICAgKiBAcGFyYW0ge2FueX0gYmVhbSBUaGUgY3VycmVudCBiZWFtLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuZXdUb2tlbklkIFRoZSBuZXcgdG9rZW4gSUQgdG8gYWRkIHRvIHRoZSBvdXRwdXQgc2VxdWVuY2UuXG4gICAgICovXG4gICAgdXBkYXRlQmVhbShiZWFtLCBuZXdUb2tlbklkKSB7XG4gICAgICAgIGJlYW0ub3V0cHV0X3Rva2VuX2lkcyA9IFsuLi5iZWFtLm91dHB1dF90b2tlbl9pZHMsIG5ld1Rva2VuSWRdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJ1bnMgdGhlIGZvcndhcmQgcGFzcyBvZiB0aGUgbW9kZWwgZm9yIGEgZ2l2ZW4gc2V0IG9mIGlucHV0cy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbW9kZWxfaW5wdXRzIFRoZSBtb2RlbCBpbnB1dHMuXG4gICAgICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0Pn0gVGhlIG1vZGVsIG91dHB1dC5cbiAgICAgKi9cbiAgICBhc3luYyBmb3J3YXJkKG1vZGVsX2lucHV0cykge1xuICAgICAgICByZXR1cm4gYXdhaXQgc2VxMnNlcUZvcndhcmQodGhpcywgbW9kZWxfaW5wdXRzKTtcbiAgICB9XG59XG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gTVQ1IG1vZGVsc1xuZXhwb3J0IGNsYXNzIE1UNVByZVRyYWluZWRNb2RlbCBleHRlbmRzIFByZVRyYWluZWRNb2RlbCB7IH07XG5cbmV4cG9ydCBjbGFzcyBNVDVNb2RlbCBleHRlbmRzIE1UNVByZVRyYWluZWRNb2RlbCB7XG4gICAgLyoqXG4gICAgICogXG4gICAgICogQHBhcmFtICB7Li4uYW55fSBhcmdzXG4gICAgICogQHJldHVybnMge1Byb21pc2U8YW55Pn1cbiAgICAgKiBAdGhyb3dzIHtFcnJvcn1cbiAgICAgKi9cbiAgICBhc3luYyBnZW5lcmF0ZSguLi5hcmdzKSB7XG4gICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgXCJUaGUgY3VycmVudCBtb2RlbCBjbGFzcyAoTVQ1TW9kZWwpIGlzIG5vdCBjb21wYXRpYmxlIHdpdGggYC5nZW5lcmF0ZSgpYCwgYXMgaXQgZG9lc24ndCBoYXZlIGEgbGFuZ3VhZ2UgbW9kZWwgaGVhZC4gUGxlYXNlIHVzZSBvbmUgb2YgdGhlIGZvbGxvd2luZyBjbGFzc2VzIGluc3RlYWQ6IHsnTVQ1Rm9yQ29uZGl0aW9uYWxHZW5lcmF0aW9uJ31cIlxuICAgICAgICApXG4gICAgfVxufVxuXG4vKipcbiAqIEEgY2xhc3MgcmVwcmVzZW50aW5nIGEgY29uZGl0aW9uYWwgc2VxdWVuY2UtdG8tc2VxdWVuY2UgbW9kZWwgYmFzZWQgb24gdGhlIE1UNSBhcmNoaXRlY3R1cmUuXG4gKlxuICogQGV4dGVuZHMgTVQ1UHJlVHJhaW5lZE1vZGVsXG4gKi9cbmV4cG9ydCBjbGFzcyBNVDVGb3JDb25kaXRpb25hbEdlbmVyYXRpb24gZXh0ZW5kcyBNVDVQcmVUcmFpbmVkTW9kZWwge1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiB0aGUgYE1UNUZvckNvbmRpdGlvbmFsR2VuZXJhdGlvbmAgY2xhc3MuXG4gICAgICogQHBhcmFtIHthbnl9IGNvbmZpZyBUaGUgbW9kZWwgY29uZmlndXJhdGlvbi5cbiAgICAgKiBAcGFyYW0ge2FueX0gc2Vzc2lvbiBUaGUgT05OWCBzZXNzaW9uIGNvbnRhaW5pbmcgdGhlIGVuY29kZXIgd2VpZ2h0cy5cbiAgICAgKiBAcGFyYW0ge2FueX0gZGVjb2Rlcl9tZXJnZWRfc2Vzc2lvbiBUaGUgT05OWCBzZXNzaW9uIGNvbnRhaW5pbmcgdGhlIG1lcmdlZCBkZWNvZGVyIHdlaWdodHMuXG4gICAgICogQHBhcmFtIHtHZW5lcmF0aW9uQ29uZmlnfSBnZW5lcmF0aW9uX2NvbmZpZyBUaGUgZ2VuZXJhdGlvbiBjb25maWd1cmF0aW9uLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZywgc2Vzc2lvbiwgZGVjb2Rlcl9tZXJnZWRfc2Vzc2lvbiwgZ2VuZXJhdGlvbl9jb25maWcpIHtcbiAgICAgICAgc3VwZXIoY29uZmlnLCBzZXNzaW9uKTtcbiAgICAgICAgdGhpcy5kZWNvZGVyX21lcmdlZF9zZXNzaW9uID0gZGVjb2Rlcl9tZXJnZWRfc2Vzc2lvbjtcbiAgICAgICAgdGhpcy5nZW5lcmF0aW9uX2NvbmZpZyA9IGdlbmVyYXRpb25fY29uZmlnO1xuXG4gICAgICAgIHRoaXMubnVtX2RlY29kZXJfbGF5ZXJzID0gdGhpcy5jb25maWcubnVtX2RlY29kZXJfbGF5ZXJzO1xuICAgICAgICB0aGlzLm51bV9kZWNvZGVyX2hlYWRzID0gdGhpcy5jb25maWcubnVtX2hlYWRzO1xuICAgICAgICB0aGlzLmRlY29kZXJfZGltX2t2ID0gdGhpcy5jb25maWcuZF9rdjtcblxuICAgICAgICB0aGlzLm51bV9lbmNvZGVyX2xheWVycyA9IHRoaXMuY29uZmlnLm51bV9sYXllcnM7XG4gICAgICAgIHRoaXMubnVtX2VuY29kZXJfaGVhZHMgPSB0aGlzLmNvbmZpZy5udW1faGVhZHM7XG4gICAgICAgIHRoaXMuZW5jb2Rlcl9kaW1fa3YgPSB0aGlzLmNvbmZpZy5kX2t2O1xuICAgIH1cblxuICAgIC8qKlxuICAgKiBHZW5lcmF0ZXMgdGhlIHN0YXJ0IGJlYW1zIGZvciB0aGUgZ2l2ZW4gaW5wdXQgdG9rZW5zIGFuZCBvdXRwdXQgc2VxdWVuY2UgbGVuZ3RoLlxuICAgKlxuICAgKiBAcGFyYW0ge2FueVtdfSBpbnB1dHMgVGhlIGlucHV0IHNlcXVlbmNlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gbnVtT3V0cHV0VG9rZW5zIFRoZSBkZXNpcmVkIGxlbmd0aCBvZiB0aGUgb3V0cHV0IHNlcXVlbmNlLlxuICAgKiBAcGFyYW0gey4uLip9IGFyZ3MgQWRkaXRpb25hbCBhcmd1bWVudHMgdG8gcGFzcyB0byB0aGUgYHNlcTJzZXFTdGFydEJlYW1zYCBmdW5jdGlvbi5cbiAgICogQHJldHVybnMge2FueVtdfSBBbiBhcnJheSBvZiBgQmVhbWAgb2JqZWN0cyByZXByZXNlbnRpbmcgdGhlIHN0YXJ0IGJlYW1zLlxuICAgKi9cbiAgICBnZXRTdGFydEJlYW1zKGlucHV0cywgbnVtT3V0cHV0VG9rZW5zLCAuLi5hcmdzKSB7XG4gICAgICAgIHJldHVybiBzZXEyc2VxU3RhcnRCZWFtcyh0aGlzLCBpbnB1dHMsIG51bU91dHB1dFRva2Vucyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUnVucyBhIHNpbmdsZSBzdGVwIG9mIHRoZSBiZWFtIHNlYXJjaCBnZW5lcmF0aW9uIGFsZ29yaXRobS5cbiAgICAgKiBAcGFyYW0ge2FueX0gYmVhbSBUaGUgY3VycmVudCBiZWFtIGJlaW5nIGdlbmVyYXRlZC5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxhbnk+fSBUaGUgdXBkYXRlZCBiZWFtIGFmdGVyIGEgc2luZ2xlIGdlbmVyYXRpb24gc3RlcC5cbiAgICAgKi9cbiAgICBhc3luYyBydW5CZWFtKGJlYW0pIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHNlcTJzZXFSdW5CZWFtKHRoaXMsIGJlYW0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIGdpdmVuIGJlYW0gd2l0aCB0aGUgbmV3IHByZWRpY3RlZCB0b2tlbi5cbiAgICAgKiBAcGFyYW0ge2FueX0gYmVhbSBUaGUgYmVhbSB0byB1cGRhdGUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG5ld1Rva2VuSWQgVGhlIGluZGV4IG9mIHRoZSBwcmVkaWN0ZWQgdG9rZW4uXG4gICAgKi9cbiAgICB1cGRhdGVCZWFtKGJlYW0sIG5ld1Rva2VuSWQpIHtcbiAgICAgICAgYmVhbS5vdXRwdXRfdG9rZW5faWRzID0gWy4uLmJlYW0ub3V0cHV0X3Rva2VuX2lkcywgbmV3VG9rZW5JZF07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgKiBSdW5zIHRoZSBmb3J3YXJkIHBhc3Mgb2YgdGhlIG1vZGVsIG9uIHRoZSBnaXZlbiBpbnB1dHMuXG4gICAgKiBAcGFyYW0ge2FueX0gbW9kZWxfaW5wdXRzIFRoZSBtb2RlbCBpbnB1dHMuXG4gICAgKiBAcmV0dXJucyB7UHJvbWlzZTxhbnk+fSBBIFByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgbW9kZWwgb3V0cHV0cy5cbiAgICAqL1xuICAgIGFzeW5jIGZvcndhcmQobW9kZWxfaW5wdXRzKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCBzZXEyc2VxRm9yd2FyZCh0aGlzLCBtb2RlbF9pbnB1dHMpO1xuICAgIH1cbn1cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBCYXJ0IG1vZGVsc1xuZXhwb3J0IGNsYXNzIEJhcnRQcmV0cmFpbmVkTW9kZWwgZXh0ZW5kcyBQcmVUcmFpbmVkTW9kZWwgeyB9O1xuXG4vKipcbiAqIEJBUlQgZW5jb2RlciBhbmQgZGVjb2RlciBtb2RlbC5cbiAqIFxuICogQGhpZGVjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgQmFydFByZXRyYWluZWRNb2RlbFxuICovXG5leHBvcnQgY2xhc3MgQmFydE1vZGVsIGV4dGVuZHMgQmFydFByZXRyYWluZWRNb2RlbCB7XG4gICAgLyoqXG4gICAgICogVGhyb3dzIGFuIGVycm9yIGJlY2F1c2UgdGhlIGN1cnJlbnQgbW9kZWwgY2xhc3MgKEJhcnRNb2RlbCkgaXMgbm90IGNvbXBhdGlibGUgd2l0aCBgLmdlbmVyYXRlKClgLlxuICAgICAqIFxuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBUaGUgY3VycmVudCBtb2RlbCBjbGFzcyAoQmFydE1vZGVsKSBpcyBub3QgY29tcGF0aWJsZSB3aXRoIGAuZ2VuZXJhdGUoKWAuXG4gICAgICogQHJldHVybnMge1Byb21pc2U8YW55Pn1cbiAgICAgKi9cbiAgICBhc3luYyBnZW5lcmF0ZSguLi5hcmdzKSB7XG4gICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgXCJUaGUgY3VycmVudCBtb2RlbCBjbGFzcyAoQmFydE1vZGVsKSBpcyBub3QgY29tcGF0aWJsZSB3aXRoIGAuZ2VuZXJhdGUoKWAsIGFzIGl0IGRvZXNuJ3QgaGF2ZSBhIGxhbmd1YWdlIG1vZGVsIGhlYWQuIFBsZWFzZSB1c2Ugb25lIG9mIHRoZSBmb2xsb3dpbmcgY2xhc3NlcyBpbnN0ZWFkOiB7J0JhcnRGb3JDb25kaXRpb25hbEdlbmVyYXRpb24nfVwiXG4gICAgICAgIClcbiAgICB9XG59XG5cbi8qKlxuICogQkFSVCBtb2RlbCB3aXRoIGEgbGFuZ3VhZ2UgbW9kZWwgaGVhZCBmb3IgY29uZGl0aW9uYWwgZ2VuZXJhdGlvbi5cbiAqIEBleHRlbmRzIEJhcnRQcmV0cmFpbmVkTW9kZWxcbiAqL1xuZXhwb3J0IGNsYXNzIEJhcnRGb3JDb25kaXRpb25hbEdlbmVyYXRpb24gZXh0ZW5kcyBCYXJ0UHJldHJhaW5lZE1vZGVsIHtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgdGhlIGBCYXJ0Rm9yQ29uZGl0aW9uYWxHZW5lcmF0aW9uYCBjbGFzcy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIFRoZSBjb25maWd1cmF0aW9uIG9iamVjdCBmb3IgdGhlIEJhcnQgbW9kZWwuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNlc3Npb24gVGhlIE9OTlggc2Vzc2lvbiB1c2VkIHRvIGV4ZWN1dGUgdGhlIG1vZGVsLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkZWNvZGVyX21lcmdlZF9zZXNzaW9uIFRoZSBPTk5YIHNlc3Npb24gdXNlZCB0byBleGVjdXRlIHRoZSBkZWNvZGVyLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBnZW5lcmF0aW9uX2NvbmZpZyBUaGUgZ2VuZXJhdGlvbiBjb25maWd1cmF0aW9uIG9iamVjdC5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihjb25maWcsIHNlc3Npb24sIGRlY29kZXJfbWVyZ2VkX3Nlc3Npb24sIGdlbmVyYXRpb25fY29uZmlnKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZywgc2Vzc2lvbik7XG4gICAgICAgIHRoaXMuZGVjb2Rlcl9tZXJnZWRfc2Vzc2lvbiA9IGRlY29kZXJfbWVyZ2VkX3Nlc3Npb247XG4gICAgICAgIHRoaXMuZ2VuZXJhdGlvbl9jb25maWcgPSBnZW5lcmF0aW9uX2NvbmZpZztcblxuICAgICAgICB0aGlzLm51bV9kZWNvZGVyX2xheWVycyA9IHRoaXMuY29uZmlnLmRlY29kZXJfbGF5ZXJzO1xuICAgICAgICB0aGlzLm51bV9kZWNvZGVyX2hlYWRzID0gdGhpcy5jb25maWcuZGVjb2Rlcl9hdHRlbnRpb25faGVhZHM7XG4gICAgICAgIHRoaXMuZGVjb2Rlcl9kaW1fa3YgPSB0aGlzLmNvbmZpZy5kX21vZGVsIC8gdGhpcy5udW1fZGVjb2Rlcl9oZWFkcztcblxuICAgICAgICB0aGlzLm51bV9lbmNvZGVyX2xheWVycyA9IHRoaXMuY29uZmlnLmVuY29kZXJfbGF5ZXJzO1xuICAgICAgICB0aGlzLm51bV9lbmNvZGVyX2hlYWRzID0gdGhpcy5jb25maWcuZW5jb2Rlcl9hdHRlbnRpb25faGVhZHM7XG4gICAgICAgIHRoaXMuZW5jb2Rlcl9kaW1fa3YgPSB0aGlzLmNvbmZpZy5kX21vZGVsIC8gdGhpcy5udW1fZW5jb2Rlcl9oZWFkcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBpbml0aWFsIGJlYW0gZm9yIGdlbmVyYXRpbmcgb3V0cHV0IHRleHQuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0cyBUaGUgaW5wdXQgb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGVuY29kZWQgaW5wdXQgdGV4dC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbnVtT3V0cHV0VG9rZW5zIFRoZSBtYXhpbXVtIG51bWJlciBvZiBvdXRwdXQgdG9rZW5zIHRvIGdlbmVyYXRlLlxuICAgICAqIEBwYXJhbSAgey4uLmFueX0gYXJncyBBZGRpdGlvbmFsIGFyZ3VtZW50cyB0byBwYXNzIHRvIHRoZSBzZXF1ZW5jZS10by1zZXF1ZW5jZSBnZW5lcmF0aW9uIGZ1bmN0aW9uLlxuICAgICAqIEByZXR1cm5zIHthbnl9IFRoZSBpbml0aWFsIGJlYW0gZm9yIGdlbmVyYXRpbmcgb3V0cHV0IHRleHQuXG4gICAgICovXG4gICAgZ2V0U3RhcnRCZWFtcyhpbnB1dHMsIG51bU91dHB1dFRva2VucywgLi4uYXJncykge1xuICAgICAgICByZXR1cm4gc2VxMnNlcVN0YXJ0QmVhbXModGhpcywgaW5wdXRzLCBudW1PdXRwdXRUb2tlbnMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJ1bnMgYSBzaW5nbGUgc3RlcCBvZiB0aGUgYmVhbSBzZWFyY2ggZ2VuZXJhdGlvbiBhbGdvcml0aG0uXG4gICAgICogQHBhcmFtIHthbnl9IGJlYW0gVGhlIGN1cnJlbnQgYmVhbSBiZWluZyBnZW5lcmF0ZWQuXG4gICAgICogQHJldHVybnMge1Byb21pc2U8YW55Pn0gVGhlIHVwZGF0ZWQgYmVhbSBhZnRlciBhIHNpbmdsZSBnZW5lcmF0aW9uIHN0ZXAuXG4gICAgICovXG4gICAgYXN5bmMgcnVuQmVhbShiZWFtKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCBzZXEyc2VxUnVuQmVhbSh0aGlzLCBiZWFtKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSBiZWFtIGJ5IGFwcGVuZGluZyB0aGUgbmV3bHkgZ2VuZXJhdGVkIHRva2VuIElEIHRvIHRoZSBsaXN0IG9mIG91dHB1dCB0b2tlbiBJRHMuXG4gICAgICogQHBhcmFtIHthbnl9IGJlYW0gVGhlIGN1cnJlbnQgYmVhbSBiZWluZyBnZW5lcmF0ZWQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG5ld1Rva2VuSWQgVGhlIElEIG9mIHRoZSBuZXdseSBnZW5lcmF0ZWQgdG9rZW4gdG8gYXBwZW5kIHRvIHRoZSBsaXN0IG9mIG91dHB1dCB0b2tlbiBJRHMuXG4gICAgICovXG4gICAgdXBkYXRlQmVhbShiZWFtLCBuZXdUb2tlbklkKSB7XG4gICAgICAgIGJlYW0ub3V0cHV0X3Rva2VuX2lkcyA9IFsuLi5iZWFtLm91dHB1dF90b2tlbl9pZHMsIG5ld1Rva2VuSWRdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJ1bnMgdGhlIGZvcndhcmQgcGFzcyBvZiB0aGUgbW9kZWwgZm9yIGEgZ2l2ZW4gc2V0IG9mIGlucHV0cy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbW9kZWxfaW5wdXRzIFRoZSBtb2RlbCBpbnB1dHMuXG4gICAgICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0Pn0gVGhlIG1vZGVsIG91dHB1dC5cbiAgICAgKi9cbiAgICBhc3luYyBmb3J3YXJkKG1vZGVsX2lucHV0cykge1xuICAgICAgICByZXR1cm4gYXdhaXQgc2VxMnNlcUZvcndhcmQodGhpcywgbW9kZWxfaW5wdXRzKTtcbiAgICB9XG59XG5cbmV4cG9ydCBjbGFzcyBCYXJ0Rm9yU2VxdWVuY2VDbGFzc2lmaWNhdGlvbiBleHRlbmRzIEJhcnRQcmV0cmFpbmVkTW9kZWwge1xuICAgIC8qKlxuICAgICAqIENhbGxzIHRoZSBtb2RlbCBvbiBuZXcgaW5wdXRzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1vZGVsX2lucHV0cyBUaGUgaW5wdXRzIHRvIHRoZSBtb2RlbC5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxTZXF1ZW5jZUNsYXNzaWZpZXJPdXRwdXQ+fSBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgbW9kZWwncyBvdXRwdXQgbG9naXRzIGZvciBzZXF1ZW5jZSBjbGFzc2lmaWNhdGlvbi5cbiAgICAgKi9cbiAgICBhc3luYyBfY2FsbChtb2RlbF9pbnB1dHMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTZXF1ZW5jZUNsYXNzaWZpZXJPdXRwdXQoYXdhaXQgc3VwZXIuX2NhbGwobW9kZWxfaW5wdXRzKSk7XG4gICAgfVxufVxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gUm9iZXJ0YSBtb2RlbHNcbmV4cG9ydCBjbGFzcyBSb2JlcnRhUHJlVHJhaW5lZE1vZGVsIGV4dGVuZHMgUHJlVHJhaW5lZE1vZGVsIHsgfVxuZXhwb3J0IGNsYXNzIFJvYmVydGFNb2RlbCBleHRlbmRzIFJvYmVydGFQcmVUcmFpbmVkTW9kZWwgeyB9XG5cbi8qKlxuICogUm9iZXJ0YUZvck1hc2tlZExNIGNsYXNzIGZvciBwZXJmb3JtaW5nIG1hc2tlZCBsYW5ndWFnZSBtb2RlbGluZyBvbiBSb2JlcnRhIG1vZGVscy5cbiAqIEBleHRlbmRzIFJvYmVydGFQcmVUcmFpbmVkTW9kZWxcbiAqL1xuZXhwb3J0IGNsYXNzIFJvYmVydGFGb3JNYXNrZWRMTSBleHRlbmRzIFJvYmVydGFQcmVUcmFpbmVkTW9kZWwge1xuICAgIC8qKlxuICAgICAqIENhbGxzIHRoZSBtb2RlbCBvbiBuZXcgaW5wdXRzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1vZGVsX2lucHV0cyBUaGUgaW5wdXRzIHRvIHRoZSBtb2RlbC5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxNYXNrZWRMTU91dHB1dD59IHJldHVybmVkIG9iamVjdFxuICAgICAqL1xuICAgIGFzeW5jIF9jYWxsKG1vZGVsX2lucHV0cykge1xuICAgICAgICByZXR1cm4gbmV3IE1hc2tlZExNT3V0cHV0KGF3YWl0IHN1cGVyLl9jYWxsKG1vZGVsX2lucHV0cykpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBSb2JlcnRhRm9yU2VxdWVuY2VDbGFzc2lmaWNhdGlvbiBjbGFzcyBmb3IgcGVyZm9ybWluZyBzZXF1ZW5jZSBjbGFzc2lmaWNhdGlvbiBvbiBSb2JlcnRhIG1vZGVscy5cbiAqIEBleHRlbmRzIFJvYmVydGFQcmVUcmFpbmVkTW9kZWxcbiAqL1xuZXhwb3J0IGNsYXNzIFJvYmVydGFGb3JTZXF1ZW5jZUNsYXNzaWZpY2F0aW9uIGV4dGVuZHMgUm9iZXJ0YVByZVRyYWluZWRNb2RlbCB7XG4gICAgLyoqXG4gICAgICogQ2FsbHMgdGhlIG1vZGVsIG9uIG5ldyBpbnB1dHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbW9kZWxfaW5wdXRzIFRoZSBpbnB1dHMgdG8gdGhlIG1vZGVsLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFNlcXVlbmNlQ2xhc3NpZmllck91dHB1dD59IHJldHVybmVkIG9iamVjdFxuICAgICAqL1xuICAgIGFzeW5jIF9jYWxsKG1vZGVsX2lucHV0cykge1xuICAgICAgICByZXR1cm4gbmV3IFNlcXVlbmNlQ2xhc3NpZmllck91dHB1dChhd2FpdCBzdXBlci5fY2FsbChtb2RlbF9pbnB1dHMpKTtcbiAgICB9XG59XG5cbi8qKlxuICogUm9iZXJ0YUZvclRva2VuQ2xhc3NpZmljYXRpb24gY2xhc3MgZm9yIHBlcmZvcm1pbmcgdG9rZW4gY2xhc3NpZmljYXRpb24gb24gUm9iZXJ0YSBtb2RlbHMuXG4gKiBAZXh0ZW5kcyBSb2JlcnRhUHJlVHJhaW5lZE1vZGVsXG4gKi9cbmV4cG9ydCBjbGFzcyBSb2JlcnRhRm9yVG9rZW5DbGFzc2lmaWNhdGlvbiBleHRlbmRzIFJvYmVydGFQcmVUcmFpbmVkTW9kZWwge1xuICAgIC8qKlxuICAgICAqIENhbGxzIHRoZSBtb2RlbCBvbiBuZXcgaW5wdXRzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1vZGVsX2lucHV0cyBUaGUgaW5wdXRzIHRvIHRoZSBtb2RlbC5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxUb2tlbkNsYXNzaWZpZXJPdXRwdXQ+fSBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgbW9kZWwncyBvdXRwdXQgbG9naXRzIGZvciB0b2tlbiBjbGFzc2lmaWNhdGlvbi5cbiAgICAgKi9cbiAgICBhc3luYyBfY2FsbChtb2RlbF9pbnB1dHMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUb2tlbkNsYXNzaWZpZXJPdXRwdXQoYXdhaXQgc3VwZXIuX2NhbGwobW9kZWxfaW5wdXRzKSk7XG4gICAgfVxufVxuXG4vKipcbiAqIFJvYmVydGFGb3JRdWVzdGlvbkFuc3dlcmluZyBjbGFzcyBmb3IgcGVyZm9ybWluZyBxdWVzdGlvbiBhbnN3ZXJpbmcgb24gUm9iZXJ0YSBtb2RlbHMuXG4gKiBAZXh0ZW5kcyBSb2JlcnRhUHJlVHJhaW5lZE1vZGVsXG4gKi9cbmV4cG9ydCBjbGFzcyBSb2JlcnRhRm9yUXVlc3Rpb25BbnN3ZXJpbmcgZXh0ZW5kcyBSb2JlcnRhUHJlVHJhaW5lZE1vZGVsIHtcbiAgICAvKipcbiAgICAgKiBDYWxscyB0aGUgbW9kZWwgb24gbmV3IGlucHV0cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtb2RlbF9pbnB1dHMgVGhlIGlucHV0cyB0byB0aGUgbW9kZWwuXG4gICAgICogQHJldHVybnMge1Byb21pc2U8UXVlc3Rpb25BbnN3ZXJpbmdNb2RlbE91dHB1dD59IHJldHVybmVkIG9iamVjdFxuICAgICAqL1xuICAgIGFzeW5jIF9jYWxsKG1vZGVsX2lucHV0cykge1xuICAgICAgICByZXR1cm4gbmV3IFF1ZXN0aW9uQW5zd2VyaW5nTW9kZWxPdXRwdXQoYXdhaXQgc3VwZXIuX2NhbGwobW9kZWxfaW5wdXRzKSk7XG4gICAgfVxufVxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFhMTVJvYmVydGEgbW9kZWxzXG5leHBvcnQgY2xhc3MgWExNUm9iZXJ0YVByZVRyYWluZWRNb2RlbCBleHRlbmRzIFByZVRyYWluZWRNb2RlbCB7IH1cbmV4cG9ydCBjbGFzcyBYTE1Sb2JlcnRhTW9kZWwgZXh0ZW5kcyBYTE1Sb2JlcnRhUHJlVHJhaW5lZE1vZGVsIHsgfVxuXG4vKipcbiAqIFhMTVJvYmVydGFGb3JNYXNrZWRMTSBjbGFzcyBmb3IgcGVyZm9ybWluZyBtYXNrZWQgbGFuZ3VhZ2UgbW9kZWxpbmcgb24gWExNUm9iZXJ0YSBtb2RlbHMuXG4gKiBAZXh0ZW5kcyBYTE1Sb2JlcnRhUHJlVHJhaW5lZE1vZGVsXG4gKi9cbmV4cG9ydCBjbGFzcyBYTE1Sb2JlcnRhRm9yTWFza2VkTE0gZXh0ZW5kcyBYTE1Sb2JlcnRhUHJlVHJhaW5lZE1vZGVsIHtcbiAgICAvKipcbiAgICAgKiBDYWxscyB0aGUgbW9kZWwgb24gbmV3IGlucHV0cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtb2RlbF9pbnB1dHMgVGhlIGlucHV0cyB0byB0aGUgbW9kZWwuXG4gICAgICogQHJldHVybnMge1Byb21pc2U8TWFza2VkTE1PdXRwdXQ+fSByZXR1cm5lZCBvYmplY3RcbiAgICAgKi9cbiAgICBhc3luYyBfY2FsbChtb2RlbF9pbnB1dHMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBNYXNrZWRMTU91dHB1dChhd2FpdCBzdXBlci5fY2FsbChtb2RlbF9pbnB1dHMpKTtcbiAgICB9XG59XG5cbi8qKlxuICogWExNUm9iZXJ0YUZvclNlcXVlbmNlQ2xhc3NpZmljYXRpb24gY2xhc3MgZm9yIHBlcmZvcm1pbmcgc2VxdWVuY2UgY2xhc3NpZmljYXRpb24gb24gWExNUm9iZXJ0YSBtb2RlbHMuXG4gKiBAZXh0ZW5kcyBYTE1Sb2JlcnRhUHJlVHJhaW5lZE1vZGVsXG4gKi9cbmV4cG9ydCBjbGFzcyBYTE1Sb2JlcnRhRm9yU2VxdWVuY2VDbGFzc2lmaWNhdGlvbiBleHRlbmRzIFhMTVJvYmVydGFQcmVUcmFpbmVkTW9kZWwge1xuICAgIC8qKlxuICAgICAqIENhbGxzIHRoZSBtb2RlbCBvbiBuZXcgaW5wdXRzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1vZGVsX2lucHV0cyBUaGUgaW5wdXRzIHRvIHRoZSBtb2RlbC5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxTZXF1ZW5jZUNsYXNzaWZpZXJPdXRwdXQ+fSByZXR1cm5lZCBvYmplY3RcbiAgICAgKi9cbiAgICBhc3luYyBfY2FsbChtb2RlbF9pbnB1dHMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTZXF1ZW5jZUNsYXNzaWZpZXJPdXRwdXQoYXdhaXQgc3VwZXIuX2NhbGwobW9kZWxfaW5wdXRzKSk7XG4gICAgfVxufVxuXG4vKipcbiAqIFhMTVJvYmVydGFGb3JUb2tlbkNsYXNzaWZpY2F0aW9uIGNsYXNzIGZvciBwZXJmb3JtaW5nIHRva2VuIGNsYXNzaWZpY2F0aW9uIG9uIFhMTVJvYmVydGEgbW9kZWxzLlxuICogQGV4dGVuZHMgWExNUm9iZXJ0YVByZVRyYWluZWRNb2RlbFxuICovXG5leHBvcnQgY2xhc3MgWExNUm9iZXJ0YUZvclRva2VuQ2xhc3NpZmljYXRpb24gZXh0ZW5kcyBYTE1Sb2JlcnRhUHJlVHJhaW5lZE1vZGVsIHtcbiAgICAvKipcbiAgICAgKiBDYWxscyB0aGUgbW9kZWwgb24gbmV3IGlucHV0cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtb2RlbF9pbnB1dHMgVGhlIGlucHV0cyB0byB0aGUgbW9kZWwuXG4gICAgICogQHJldHVybnMge1Byb21pc2U8VG9rZW5DbGFzc2lmaWVyT3V0cHV0Pn0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIG1vZGVsJ3Mgb3V0cHV0IGxvZ2l0cyBmb3IgdG9rZW4gY2xhc3NpZmljYXRpb24uXG4gICAgICovXG4gICAgYXN5bmMgX2NhbGwobW9kZWxfaW5wdXRzKSB7XG4gICAgICAgIHJldHVybiBuZXcgVG9rZW5DbGFzc2lmaWVyT3V0cHV0KGF3YWl0IHN1cGVyLl9jYWxsKG1vZGVsX2lucHV0cykpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBYTE1Sb2JlcnRhRm9yUXVlc3Rpb25BbnN3ZXJpbmcgY2xhc3MgZm9yIHBlcmZvcm1pbmcgcXVlc3Rpb24gYW5zd2VyaW5nIG9uIFhMTVJvYmVydGEgbW9kZWxzLlxuICogQGV4dGVuZHMgWExNUm9iZXJ0YVByZVRyYWluZWRNb2RlbFxuICovXG5leHBvcnQgY2xhc3MgWExNUm9iZXJ0YUZvclF1ZXN0aW9uQW5zd2VyaW5nIGV4dGVuZHMgWExNUm9iZXJ0YVByZVRyYWluZWRNb2RlbCB7XG4gICAgLyoqXG4gICAgICogQ2FsbHMgdGhlIG1vZGVsIG9uIG5ldyBpbnB1dHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbW9kZWxfaW5wdXRzIFRoZSBpbnB1dHMgdG8gdGhlIG1vZGVsLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFF1ZXN0aW9uQW5zd2VyaW5nTW9kZWxPdXRwdXQ+fSByZXR1cm5lZCBvYmplY3RcbiAgICAgKi9cbiAgICBhc3luYyBfY2FsbChtb2RlbF9pbnB1dHMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBRdWVzdGlvbkFuc3dlcmluZ01vZGVsT3V0cHV0KGF3YWl0IHN1cGVyLl9jYWxsKG1vZGVsX2lucHV0cykpO1xuICAgIH1cbn1cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBUNSBtb2RlbHNcbmV4cG9ydCBjbGFzcyBXaGlzcGVyUHJlVHJhaW5lZE1vZGVsIGV4dGVuZHMgUHJlVHJhaW5lZE1vZGVsIHsgfTtcblxuLyoqXG4gKiBXaGlzcGVyTW9kZWwgY2xhc3MgZm9yIHRyYWluaW5nIFdoaXNwZXIgbW9kZWxzIHdpdGhvdXQgYSBsYW5ndWFnZSBtb2RlbCBoZWFkLlxuICogQGV4dGVuZHMgV2hpc3BlclByZVRyYWluZWRNb2RlbFxuICovXG5leHBvcnQgY2xhc3MgV2hpc3Blck1vZGVsIGV4dGVuZHMgV2hpc3BlclByZVRyYWluZWRNb2RlbCB7XG4gICAgLyoqXG4gICAgICogVGhyb3dzIGFuIGVycm9yIHdoZW4gYXR0ZW1wdGluZyB0byBnZW5lcmF0ZSBvdXRwdXQgc2luY2UgdGhpcyBtb2RlbCBkb2Vzbid0IGhhdmUgYSBsYW5ndWFnZSBtb2RlbCBoZWFkLlxuICAgICAqIEB0aHJvd3MgRXJyb3JcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxhbnk+fVxuICAgICAqIEBwYXJhbSB7YW55W119IGFyZ3NcbiAgICAgKi9cbiAgICBhc3luYyBnZW5lcmF0ZSguLi5hcmdzKSB7XG4gICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgXCJUaGUgY3VycmVudCBtb2RlbCBjbGFzcyAoV2hpc3Blck1vZGVsKSBpcyBub3QgY29tcGF0aWJsZSB3aXRoIGAuZ2VuZXJhdGUoKWAsIGFzIGl0IGRvZXNuJ3QgaGF2ZSBhIGxhbmd1YWdlIG1vZGVsIGhlYWQuIFBsZWFzZSB1c2Ugb25lIG9mIHRoZSBmb2xsb3dpbmcgY2xhc3NlcyBpbnN0ZWFkOiB7J1doaXNwZXJGb3JDb25kaXRpb25hbEdlbmVyYXRpb24nfVwiXG4gICAgICAgIClcbiAgICB9XG59XG5cbi8qKlxuICogV2hpc3BlckZvckNvbmRpdGlvbmFsR2VuZXJhdGlvbiBjbGFzcyBmb3IgZ2VuZXJhdGluZyBjb25kaXRpb25hbCBvdXRwdXRzIGZyb20gV2hpc3BlciBtb2RlbHMuXG4gKiBAZXh0ZW5kcyBXaGlzcGVyUHJlVHJhaW5lZE1vZGVsXG4gKi9cbmV4cG9ydCBjbGFzcyBXaGlzcGVyRm9yQ29uZGl0aW9uYWxHZW5lcmF0aW9uIGV4dGVuZHMgV2hpc3BlclByZVRyYWluZWRNb2RlbCB7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIHRoZSBgV2hpc3BlckZvckNvbmRpdGlvbmFsR2VuZXJhdGlvbmAgY2xhc3MuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBDb25maWd1cmF0aW9uIG9iamVjdCBmb3IgdGhlIG1vZGVsLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzZXNzaW9uIE9OTlggU2Vzc2lvbiBvYmplY3QgZm9yIHRoZSBtb2RlbC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGVjb2Rlcl9tZXJnZWRfc2Vzc2lvbiBPTk5YIFNlc3Npb24gb2JqZWN0IGZvciB0aGUgZGVjb2Rlci5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZ2VuZXJhdGlvbl9jb25maWcgQ29uZmlndXJhdGlvbiBvYmplY3QgZm9yIHRoZSBnZW5lcmF0aW9uIHByb2Nlc3MuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY29uZmlnLCBzZXNzaW9uLCBkZWNvZGVyX21lcmdlZF9zZXNzaW9uLCBnZW5lcmF0aW9uX2NvbmZpZykge1xuICAgICAgICBzdXBlcihjb25maWcsIHNlc3Npb24pO1xuICAgICAgICB0aGlzLmRlY29kZXJfbWVyZ2VkX3Nlc3Npb24gPSBkZWNvZGVyX21lcmdlZF9zZXNzaW9uO1xuICAgICAgICB0aGlzLmdlbmVyYXRpb25fY29uZmlnID0gZ2VuZXJhdGlvbl9jb25maWc7XG5cbiAgICAgICAgdGhpcy5udW1fZGVjb2Rlcl9sYXllcnMgPSB0aGlzLmNvbmZpZy5kZWNvZGVyX2xheWVycztcbiAgICAgICAgdGhpcy5udW1fZGVjb2Rlcl9oZWFkcyA9IHRoaXMuY29uZmlnLmRlY29kZXJfYXR0ZW50aW9uX2hlYWRzO1xuICAgICAgICB0aGlzLmRlY29kZXJfZGltX2t2ID0gdGhpcy5jb25maWcuZF9tb2RlbCAvIHRoaXMubnVtX2RlY29kZXJfaGVhZHM7XG5cbiAgICAgICAgdGhpcy5udW1fZW5jb2Rlcl9sYXllcnMgPSB0aGlzLmNvbmZpZy5lbmNvZGVyX2xheWVycztcbiAgICAgICAgdGhpcy5udW1fZW5jb2Rlcl9oZWFkcyA9IHRoaXMuY29uZmlnLmVuY29kZXJfYXR0ZW50aW9uX2hlYWRzO1xuICAgICAgICB0aGlzLmVuY29kZXJfZGltX2t2ID0gdGhpcy5jb25maWcuZF9tb2RlbCAvIHRoaXMubnVtX2VuY29kZXJfaGVhZHM7XG5cblxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyBvdXRwdXRzIGJhc2VkIG9uIGlucHV0IGFuZCBnZW5lcmF0aW9uIGNvbmZpZ3VyYXRpb24uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0cyBJbnB1dCBkYXRhIGZvciB0aGUgbW9kZWwuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGdlbmVyYXRpb25fY29uZmlnIENvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciB0aGUgZ2VuZXJhdGlvbiBwcm9jZXNzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBsb2dpdHNfcHJvY2Vzc29yIE9wdGlvbmFsIGxvZ2l0cyBwcm9jZXNzb3Igb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMucmV0dXJuX3RpbWVzdGFtcHM9bnVsbF0gV2hldGhlciB0byByZXR1cm4gdGhlIHRpbWVzdGFtcHMgd2l0aCB0aGUgdGV4dC4gVGhpcyBlbmFibGVzIHRoZSBgV2hpc3BlclRpbWVzdGFtcHNMb2dpdHNQcm9jZXNzb3JgLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5yZXR1cm5fdG9rZW5fdGltZXN0YW1wcz1udWxsXSBXaGV0aGVyIHRvIHJldHVybiB0b2tlbi1sZXZlbCB0aW1lc3RhbXBzXG4gICAgICogd2l0aCB0aGUgdGV4dC4gVGhpcyBjYW4gYmUgdXNlZCB3aXRoIG9yIHdpdGhvdXQgdGhlIGByZXR1cm5fdGltZXN0YW1wc2Agb3B0aW9uLiBUbyBnZXQgd29yZC1sZXZlbFxuICAgICAqIHRpbWVzdGFtcHMsIHVzZSB0aGUgdG9rZW5pemVyIHRvIGdyb3VwIHRoZSB0b2tlbnMgaW50byB3b3Jkcy5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fSBQcm9taXNlIG9iamVjdCByZXByZXNlbnRzIHRoZSBnZW5lcmF0ZWQgb3V0cHV0cy5cbiAgICAgKi9cbiAgICAvLyBAdHMtaWdub3JlXG4gICAgYXN5bmMgZ2VuZXJhdGUoXG4gICAgICAgIGlucHV0cyxcbiAgICAgICAgZ2VuZXJhdGlvbl9jb25maWcgPSBudWxsLFxuICAgICAgICBsb2dpdHNfcHJvY2Vzc29yID0gbnVsbCxcbiAgICAgICAgLy8ge1xuICAgICAgICAvLyAgICAgcmV0dXJuX3RpbWVzdGFtcHMgPSBudWxsLFxuICAgICAgICAvLyAgICAgcmV0dXJuX3Rva2VuX3RpbWVzdGFtcHMgPSBudWxsLFxuICAgICAgICAvLyAgICAgbGFuZ3VhZ2UgPSBudWxsLFxuICAgICAgICAvLyAgICAgdGFzayA9IG51bGwsXG4gICAgICAgIC8vIH0gPSB7fSxcbiAgICApIHtcbiAgICAgICAgLy8gQ3JlYXRlIGdlbmVyYXRpb24gY29uZmlnIG9iamVjdFxuICAgICAgICBnZW5lcmF0aW9uX2NvbmZpZyA9IHRoaXMuX2dldF9nZW5lcmF0aW9uX2NvbmZpZyhnZW5lcmF0aW9uX2NvbmZpZyk7XG5cblxuICAgICAgICAvLyBXaGlzcGVyIGhhcyBhZGRpdGlvbmFsIG9wdGlvbnMgZm9yIHJldHVybmluZyB0aW1lc3RhbXBzXG4gICAgICAgIGdlbmVyYXRpb25fY29uZmlnLnJldHVybl90aW1lc3RhbXBzID8/PSBmYWxzZTtcblxuICAgICAgICAvLyBUT0RPIGFkZCBsYW5ndWFnZSBhbmQgdGFza1xuXG4gICAgICAgIGlmIChnZW5lcmF0aW9uX2NvbmZpZy5yZXR1cm5fdGltZXN0YW1wcykge1xuICAgICAgICAgICAgbG9naXRzX3Byb2Nlc3NvciA9IFtuZXcgV2hpc3BlclRpbWVTdGFtcExvZ2l0c1Byb2Nlc3NvcihnZW5lcmF0aW9uX2NvbmZpZyldXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZ2VuZXJhdGlvbl9jb25maWcucmV0dXJuX3Rva2VuX3RpbWVzdGFtcHMpIHtcbiAgICAgICAgICAgIGdlbmVyYXRpb25fY29uZmlnLm91dHB1dF9hdHRlbnRpb25zID0gdHJ1ZTtcbiAgICAgICAgICAgIGdlbmVyYXRpb25fY29uZmlnLnJldHVybl9kaWN0X2luX2dlbmVyYXRlID0gdHJ1ZTtcblxuICAgICAgICAgICAgaWYgKGdlbmVyYXRpb25fY29uZmlnLnRhc2sgPT09ICd0cmFuc2xhdGUnKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiVG9rZW4tbGV2ZWwgdGltZXN0YW1wcyBtYXkgbm90IGJlIHJlbGlhYmxlIGZvciB0YXNrICd0cmFuc2xhdGUnLlwiKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWdlbmVyYXRpb25fY29uZmlnLmFsaWdubWVudF9oZWFkcykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgXCJNb2RlbCBnZW5lcmF0aW9uIGNvbmZpZyBoYXMgbm8gYGFsaWdubWVudF9oZWFkc2AsIHRva2VuLWxldmVsIHRpbWVzdGFtcHMgbm90IGF2YWlsYWJsZS4gXCIgK1xuICAgICAgICAgICAgICAgICAgICBcIlNlZSBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9ob2xsYW5jZS80MmUzMjg1MmYyNDI0M2I3NDhhZTZiYzFmOTg1YjEzYSBvbiBob3cgdG8gYWRkIHRoaXMgcHJvcGVydHkgdG8gdGhlIGdlbmVyYXRpb24gY29uZmlnLlwiXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgb3V0cHV0cyA9IGF3YWl0IHN1cGVyLmdlbmVyYXRlKGlucHV0cywgZ2VuZXJhdGlvbl9jb25maWcsIGxvZ2l0c19wcm9jZXNzb3IpO1xuXG4gICAgICAgIGlmIChnZW5lcmF0aW9uX2NvbmZpZy5yZXR1cm5fdG9rZW5fdGltZXN0YW1wcyAmJiBnZW5lcmF0aW9uX2NvbmZpZy5hbGlnbm1lbnRfaGVhZHMpIHtcbiAgICAgICAgICAgIG91dHB1dHNbXCJ0b2tlbl90aW1lc3RhbXBzXCJdID0gdGhpcy5fZXh0cmFjdF90b2tlbl90aW1lc3RhbXBzKG91dHB1dHMsIGdlbmVyYXRpb25fY29uZmlnLmFsaWdubWVudF9oZWFkcylcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvdXRwdXRzXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgc3RhcnQgYmVhbXMgZm9yIGdlbmVyYXRpbmcgb3V0cHV0cy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBpbnB1dFRva2VuSWRzIEFycmF5IG9mIGlucHV0IHRva2VuIElEcy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbnVtT3V0cHV0VG9rZW5zIE51bWJlciBvZiBvdXRwdXQgdG9rZW5zIHRvIGdlbmVyYXRlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gQXJyYXkgb2Ygc3RhcnQgYmVhbXMuXG4gICAgICovXG4gICAgZ2V0U3RhcnRCZWFtcyhpbnB1dFRva2VuSWRzLCBudW1PdXRwdXRUb2tlbnMsIC4uLmFyZ3MpIHtcbiAgICAgICAgLy8gYXJndW1lbnRzIGlnbm9yZWQgaW4gdGhpcyBjYXNlXG4gICAgICAgIHJldHVybiBzZXEyc2VxU3RhcnRCZWFtcyh0aGlzLCBpbnB1dFRva2VuSWRzLCBudW1PdXRwdXRUb2tlbnMsIGZhbHNlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSdW5zIGEgc2luZ2xlIHN0ZXAgb2YgdGhlIGJlYW0gc2VhcmNoIGdlbmVyYXRpb24gYWxnb3JpdGhtLlxuICAgICAqIEBwYXJhbSB7YW55fSBiZWFtIFRoZSBjdXJyZW50IGJlYW0gYmVpbmcgZ2VuZXJhdGVkLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPGFueT59IFRoZSB1cGRhdGVkIGJlYW0gYWZ0ZXIgYSBzaW5nbGUgZ2VuZXJhdGlvbiBzdGVwLlxuICAgICAqL1xuICAgIGFzeW5jIHJ1bkJlYW0oYmVhbSkge1xuICAgICAgICByZXR1cm4gYXdhaXQgc2VxMnNlcVJ1bkJlYW0odGhpcywgYmVhbSwge1xuICAgICAgICAgICAgaW5wdXRfbmFtZTogJ2lucHV0X2ZlYXR1cmVzJyxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgYmVhbSBieSBhcHBlbmRpbmcgdGhlIG5ld2x5IGdlbmVyYXRlZCB0b2tlbiBJRCB0byB0aGUgbGlzdCBvZiBvdXRwdXQgdG9rZW4gSURzLlxuICAgICAqIEBwYXJhbSB7YW55fSBiZWFtIFRoZSBjdXJyZW50IGJlYW0gYmVpbmcgZ2VuZXJhdGVkLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuZXdUb2tlbklkIFRoZSBJRCBvZiB0aGUgbmV3bHkgZ2VuZXJhdGVkIHRva2VuIHRvIGFwcGVuZCB0byB0aGUgbGlzdCBvZiBvdXRwdXQgdG9rZW4gSURzLlxuICAgICAqL1xuICAgIHVwZGF0ZUJlYW0oYmVhbSwgbmV3VG9rZW5JZCkge1xuICAgICAgICBiZWFtLm91dHB1dF90b2tlbl9pZHMgPSBbLi4uYmVhbS5vdXRwdXRfdG9rZW5faWRzLCBuZXdUb2tlbklkXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSdW5zIHRoZSBmb3J3YXJkIHBhc3Mgb2YgdGhlIG1vZGVsIGZvciBhIGdpdmVuIHNldCBvZiBpbnB1dHMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1vZGVsX2lucHV0cyBUaGUgbW9kZWwgaW5wdXRzLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD59IFRoZSBtb2RlbCBvdXRwdXQuXG4gICAgICovXG4gICAgYXN5bmMgZm9yd2FyZChtb2RlbF9pbnB1dHMpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHNlcTJzZXFGb3J3YXJkKHRoaXMsIG1vZGVsX2lucHV0cyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlcyB0b2tlbi1sZXZlbCB0aW1lc3RhbXBzIHVzaW5nIHRoZSBlbmNvZGVyLWRlY29kZXIgY3Jvc3MtYXR0ZW50aW9ucyBhbmRcbiAgICAgKiBkeW5hbWljIHRpbWUtd2FycGluZyAoRFRXKSB0byBtYXAgZWFjaCBvdXRwdXQgdG9rZW4gdG8gYSBwb3NpdGlvbiBpbiB0aGUgaW5wdXQgYXVkaW8uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGdlbmVyYXRlX291dHB1dHMgT3V0cHV0cyBnZW5lcmF0ZWQgYnkgdGhlIG1vZGVsXG4gICAgICogQHBhcmFtIHtUZW5zb3JbXVtdW119IGdlbmVyYXRlX291dHB1dHMuY3Jvc3NfYXR0ZW50aW9ucyBUaGUgY3Jvc3MgYXR0ZW50aW9ucyBvdXRwdXQgYnkgdGhlIG1vZGVsXG4gICAgICogQHBhcmFtIHtUZW5zb3JbXVtdW119IGdlbmVyYXRlX291dHB1dHMuZGVjb2Rlcl9hdHRlbnRpb25zIFRoZSBkZWNvZGVyIGF0dGVudGlvbnMgb3V0cHV0IGJ5IHRoZSBtb2RlbFxuICAgICAqIEBwYXJhbSB7bnVtYmVyW11bXX0gZ2VuZXJhdGVfb3V0cHV0cy5zZXF1ZW5jZXMgVGhlIHNlcXVlbmNlcyBvdXRwdXQgYnkgdGhlIG1vZGVsXG4gICAgICogQHBhcmFtIHtudW1iZXJbXVtdfSBhbGlnbm1lbnRfaGVhZHMgQWxpZ25tZW50IGhlYWRzIG9mIHRoZSBtb2RlbFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lX3ByZWNpc2lvbiBQcmVjaXNpb24gb2YgdGhlIHRpbWVzdGFtcHMgaW4gc2Vjb25kc1xuICAgICAqIEByZXR1cm5zIHtUZW5zb3J9IHRlbnNvciBjb250YWluaW5nIHRoZSB0aW1lc3RhbXBzIGluIHNlY29uZHMgZm9yIGVhY2ggcHJlZGljdGVkIHRva2VuXG4gICAgICovXG4gICAgX2V4dHJhY3RfdG9rZW5fdGltZXN0YW1wcyhnZW5lcmF0ZV9vdXRwdXRzLCBhbGlnbm1lbnRfaGVhZHMsIHRpbWVfcHJlY2lzaW9uID0gMC4wMikge1xuICAgICAgICBpZiAoIWdlbmVyYXRlX291dHB1dHMuY3Jvc3NfYXR0ZW50aW9ucykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgIFwiTW9kZWwgb3V0cHV0cyBtdXN0IGNvbnRhaW4gY3Jvc3MgYXR0ZW50aW9ucyB0byBleHRyYWN0IHRpbWVzdGFtcHMuIFwiICtcbiAgICAgICAgICAgICAgICBcIlRoaXMgaXMgbW9zdCBsaWtlbHkgYmVjYXVzZSB0aGUgbW9kZWwgd2FzIG5vdCBleHBvcnRlZCB3aXRoIGBvdXRwdXRfYXR0ZW50aW9ucz1UcnVlYC5cIlxuICAgICAgICAgICAgKVxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IG1lZGlhbl9maWx0ZXJfd2lkdGggPSB0aGlzLmNvbmZpZy5tZWRpYW5fZmlsdGVyX3dpZHRoO1xuICAgICAgICBpZiAobWVkaWFuX2ZpbHRlcl93aWR0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJNb2RlbCBjb25maWcgaGFzIG5vIGBtZWRpYW5fZmlsdGVyX3dpZHRoYCwgdXNpbmcgZGVmYXVsdCB2YWx1ZSBvZiA3LlwiKVxuICAgICAgICAgICAgbWVkaWFuX2ZpbHRlcl93aWR0aCA9IDc7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBiYXRjaGVkTWF0cmljZXMgPSBnZW5lcmF0ZV9vdXRwdXRzLmNyb3NzX2F0dGVudGlvbnMubWFwKGJhdGNoID0+IHtcbiAgICAgICAgICAgIC8vIENyZWF0ZSBhIGxpc3Qgd2l0aCBgZGVjb2Rlcl9sYXllcnNgIGVsZW1lbnRzLCBlYWNoIGEgdGVuc29yIG9mIHNoYXBlXG4gICAgICAgICAgICAvLyAoYmF0Y2ggc2l6ZSwgYXR0ZW50aW9uX2hlYWRzLCBvdXRwdXQgbGVuZ3RoLCBpbnB1dCBsZW5ndGgpLlxuICAgICAgICAgICAgbGV0IGNyb3NzX2F0dGVudGlvbnMgPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiB0aGlzLmNvbmZpZy5kZWNvZGVyX2xheWVycyB9LFxuICAgICAgICAgICAgICAgIChfLCBpKSA9PiBjYXQoYmF0Y2gubWFwKHggPT4geFtpXSksIDIpXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBsZXQgd2VpZ2h0cyA9IHN0YWNrKGFsaWdubWVudF9oZWFkcy5tYXAoKFtsLCBoXSkgPT4gY3Jvc3NfYXR0ZW50aW9uc1tsXS5zbGljZShudWxsLCBoKSkpO1xuICAgICAgICAgICAgd2VpZ2h0cyA9IHdlaWdodHMudHJhbnNwb3NlKDEsIDAsIDIsIDMpXG5cbiAgICAgICAgICAgIGxldCBbc3RkLCBjYWxjdWxhdGVkTWVhbl0gPSBzdGRfbWVhbih3ZWlnaHRzLCAtMiwgMCwgdHJ1ZSk7XG5cbiAgICAgICAgICAgIC8vIE5vcm1hbGl6ZSBhbmQgc21vb3RoZW4gdGhlIHdlaWdodHMuXG4gICAgICAgICAgICBsZXQgc21vb3RoZWRXZWlnaHRzID0gd2VpZ2h0cy5jbG9uZSgpOyAvLyBbMSwgOCwgc2VxTGVuZ3RoLCAxNTAwXVxuXG4gICAgICAgICAgICBmb3IgKGxldCBhID0gMDsgYSA8IHNtb290aGVkV2VpZ2h0cy5kaW1zWzBdOyArK2EpIHtcbiAgICAgICAgICAgICAgICBsZXQgYVRlbnNvciA9IHNtb290aGVkV2VpZ2h0c1thXTsgLy8gWzgsIHNlcUxlbmd0aCwgMTUwMF1cblxuICAgICAgICAgICAgICAgIGZvciAobGV0IGIgPSAwOyBiIDwgYVRlbnNvci5kaW1zWzBdOyArK2IpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGJUZW5zb3IgPSBhVGVuc29yW2JdOyAvLyBbc2VxTGVuZ3RoLCAxNTAwXVxuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN0ZFRlbnNvciA9IHN0ZFthXVtiXVswXTsgLy8gWzE1MDBdXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1lYW5UZW5zb3IgPSBjYWxjdWxhdGVkTWVhblthXVtiXVswXTsgLy8gWzE1MDBdXG5cbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgYyA9IDA7IGMgPCBiVGVuc29yLmRpbXNbMF07ICsrYykge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgY1RlbnNvciA9IGJUZW5zb3JbY107IC8vIFsxNTAwXVxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgZCA9IDA7IGQgPCBjVGVuc29yLmRhdGEubGVuZ3RoOyArK2QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjVGVuc29yLmRhdGFbZF0gPSAoY1RlbnNvci5kYXRhW2RdIC0gbWVhblRlbnNvci5kYXRhW2RdKSAvIHN0ZFRlbnNvci5kYXRhW2RdXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFwcGx5IG1lZGlhbiBmaWx0ZXIuXG4gICAgICAgICAgICAgICAgICAgICAgICBjVGVuc29yLmRhdGEuc2V0KG1lZGlhbkZpbHRlcihjVGVuc29yLmRhdGEsIG1lZGlhbl9maWx0ZXJfd2lkdGgpKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBBdmVyYWdlIHRoZSBkaWZmZXJlbnQgY3Jvc3MtYXR0ZW50aW9uIGhlYWRzLlxuICAgICAgICAgICAgY29uc3QgbWF0cml4ID0gbWVhbihzbW9vdGhlZFdlaWdodHMsIDEpO1xuICAgICAgICAgICAgcmV0dXJuIG1hdHJpeDtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgdGltZXN0YW1wc1NoYXBlID0gW2dlbmVyYXRlX291dHB1dHMuc2VxdWVuY2VzLmxlbmd0aCwgZ2VuZXJhdGVfb3V0cHV0cy5zZXF1ZW5jZXNbMF0ubGVuZ3RoXTtcblxuICAgICAgICBjb25zdCB0aW1lc3RhbXBzID0gbmV3IFRlbnNvcihcbiAgICAgICAgICAgICdmbG9hdDMyJyxcbiAgICAgICAgICAgIG5ldyBGbG9hdDMyQXJyYXkodGltZXN0YW1wc1NoYXBlWzBdICogdGltZXN0YW1wc1NoYXBlWzFdKSxcbiAgICAgICAgICAgIHRpbWVzdGFtcHNTaGFwZVxuICAgICAgICApO1xuXG4gICAgICAgIC8vIFBlcmZvcm0gZHluYW1pYyB0aW1lIHdhcnBpbmcgb24gZWFjaCBlbGVtZW50IG9mIHRoZSBiYXRjaC5cbiAgICAgICAgZm9yIChsZXQgYmF0Y2hfaWR4ID0gMDsgYmF0Y2hfaWR4IDwgdGltZXN0YW1wc1NoYXBlWzBdOyArK2JhdGNoX2lkeCkge1xuICAgICAgICAgICAgLy8gTk9URTogU2luY2Ugd2UgcnVuIG9ubHkgb25lIGJhdGNoIGF0IGEgdGltZSwgd2UgY2FuIHNxdWVlemUgdG8gZ2V0IHRoZSBzYW1lIGRpbWVuc2lvbnNcbiAgICAgICAgICAgIC8vIGFzIHRoZSBweXRob24gaW1wbGVtZW50YXRpb25cbiAgICAgICAgICAgIGNvbnN0IG1hdHJpeCA9IGJhdGNoZWRNYXRyaWNlc1tiYXRjaF9pZHhdLm5lZygpLnNxdWVlemVfKDApO1xuICAgICAgICAgICAgbGV0IFt0ZXh0X2luZGljZXMsIHRpbWVfaW5kaWNlc10gPSBkeW5hbWljVGltZVdhcnBpbmcobWF0cml4KTtcblxuICAgICAgICAgICAgbGV0IGRpZmZzID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogdGV4dF9pbmRpY2VzLmxlbmd0aCAtIDEgfSwgKHYsIGkpID0+IHRleHRfaW5kaWNlc1tpICsgMV0gLSB0ZXh0X2luZGljZXNbaV0pO1xuICAgICAgICAgICAgbGV0IGp1bXBzID0gbWVyZ2VBcnJheXMoWzFdLCBkaWZmcykubWFwKHggPT4gISF4KTsgLy8gY29udmVydCB0byBib29sZWFuXG5cbiAgICAgICAgICAgIGxldCBqdW1wX3RpbWVzID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGp1bXBzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGp1bXBzW2ldKSB7XG4gICAgICAgICAgICAgICAgICAgIGp1bXBfdGltZXMucHVzaCh0aW1lX2luZGljZXNbaV0gKiB0aW1lX3ByZWNpc2lvbik7XG4gICAgICAgICAgICAgICAgICAgIC8vIE5PVEU6IE5vIHBvaW50IGluIHJvdW5kaW5nIGhlcmUsIHNpbmNlIHdlIHNldCB0byBGbG9hdDMyQXJyYXkgbGF0ZXJcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aW1lc3RhbXBzW2JhdGNoX2lkeF0uZGF0YS5zZXQoanVtcF90aW1lcywgMSlcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aW1lc3RhbXBzO1xuICAgIH1cbn1cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vKipcbiAqIFZpc2lvbiBFbmNvZGVyLURlY29kZXIgbW9kZWwgYmFzZWQgb24gT3BlbkFJJ3MgR1BUIGFyY2hpdGVjdHVyZSBmb3IgaW1hZ2UgY2FwdGlvbmluZyBhbmQgb3RoZXIgdmlzaW9uIHRhc2tzXG4gKiBAZXh0ZW5kcyBQcmVUcmFpbmVkTW9kZWxcbiAqL1xuZXhwb3J0IGNsYXNzIFZpc2lvbkVuY29kZXJEZWNvZGVyTW9kZWwgZXh0ZW5kcyBQcmVUcmFpbmVkTW9kZWwge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgdGhlIGBWaXNpb25FbmNvZGVyRGVjb2Rlck1vZGVsYCBjbGFzcy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIFRoZSBjb25maWd1cmF0aW9uIG9iamVjdCBzcGVjaWZ5aW5nIHRoZSBoeXBlcnBhcmFtZXRlcnMgYW5kIG90aGVyIG1vZGVsIHNldHRpbmdzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzZXNzaW9uIFRoZSBPTk5YIHNlc3Npb24gY29udGFpbmluZyB0aGUgZW5jb2RlciBtb2RlbC5cbiAgICAgKiBAcGFyYW0ge2FueX0gZGVjb2Rlcl9tZXJnZWRfc2Vzc2lvbiBUaGUgT05OWCBzZXNzaW9uIGNvbnRhaW5pbmcgdGhlIG1lcmdlZCBkZWNvZGVyIG1vZGVsLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZywgc2Vzc2lvbiwgZGVjb2Rlcl9tZXJnZWRfc2Vzc2lvbikge1xuICAgICAgICBzdXBlcihjb25maWcsIHNlc3Npb24pO1xuICAgICAgICB0aGlzLmRlY29kZXJfbWVyZ2VkX3Nlc3Npb24gPSBkZWNvZGVyX21lcmdlZF9zZXNzaW9uO1xuXG4gICAgICAgIHRoaXMubnVtX2xheWVycyA9IHRoaXMuY29uZmlnLmRlY29kZXIubl9sYXllcjtcbiAgICAgICAgdGhpcy5udW1faGVhZHMgPSB0aGlzLmNvbmZpZy5kZWNvZGVyLm5faGVhZDtcbiAgICAgICAgdGhpcy5kaW1fa3YgPSB0aGlzLmNvbmZpZy5kZWNvZGVyLm5fZW1iZCAvIHRoaXMubnVtX2hlYWRzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlIGJlYW0gc2VhcmNoIG91dHB1dHMgZm9yIHRoZSBnaXZlbiBpbnB1dCBwaXhlbHMgYW5kIG51bWJlciBvZiBvdXRwdXQgdG9rZW5zLlxuICAgICAqXG4gICAgICogQHBhcmFtIHthcnJheX0gaW5wdXRzIFRoZSBpbnB1dCBwaXhlbHMgYXMgYSBUZW5zb3IuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG51bU91dHB1dFRva2VucyBUaGUgbnVtYmVyIG9mIG91dHB1dCB0b2tlbnMgdG8gZ2VuZXJhdGUuXG4gICAgICogQHBhcmFtIHsuLi4qfSBhcmdzIE9wdGlvbmFsIGFkZGl0aW9uYWwgYXJndW1lbnRzIHRvIHBhc3MgdG8gc2VxMnNlcVN0YXJ0QmVhbXMuXG4gICAgICogQHJldHVybnMge2FueX0gQW4gYXJyYXkgb2YgQmVhbSBvYmplY3RzIHJlcHJlc2VudGluZyB0aGUgdG9wLUsgb3V0cHV0IHNlcXVlbmNlcy5cbiAgICAgKi9cbiAgICBnZXRTdGFydEJlYW1zKGlucHV0cywgbnVtT3V0cHV0VG9rZW5zLCAuLi5hcmdzKSB7XG4gICAgICAgIHJldHVybiBzZXEyc2VxU3RhcnRCZWFtcyh0aGlzLCBpbnB1dHMsIG51bU91dHB1dFRva2Vucyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUnVucyBhIHNpbmdsZSBzdGVwIG9mIHRoZSBiZWFtIHNlYXJjaCBnZW5lcmF0aW9uIGFsZ29yaXRobS5cbiAgICAgKiBAcGFyYW0ge2FueX0gYmVhbSBUaGUgY3VycmVudCBiZWFtIGJlaW5nIGdlbmVyYXRlZC5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxhbnk+fSBUaGUgdXBkYXRlZCBiZWFtIGFmdGVyIGEgc2luZ2xlIGdlbmVyYXRpb24gc3RlcC5cbiAgICAgKi9cbiAgICBhc3luYyBydW5CZWFtKGJlYW0pIHtcbiAgICAgICAgcmV0dXJuIHNlcTJzZXFSdW5CZWFtKHRoaXMsIGJlYW0sIHtcbiAgICAgICAgICAgIGlucHV0X25hbWU6ICdwaXhlbF92YWx1ZXMnLFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgdGhlIGdpdmVuIGJlYW0gd2l0aCB0aGUgYWRkaXRpb25hbCBwcmVkaWN0ZWQgdG9rZW4gSUQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2FueX0gYmVhbSBUaGUgY3VycmVudCBiZWFtLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuZXdUb2tlbklkIFRoZSBuZXcgcHJlZGljdGVkIHRva2VuIElEIHRvIGFkZCB0byB0aGUgYmVhbSdzIG91dHB1dCBzZXF1ZW5jZS5cbiAgICAgKi9cbiAgICB1cGRhdGVCZWFtKGJlYW0sIG5ld1Rva2VuSWQpIHtcbiAgICAgICAgYmVhbS5vdXRwdXRfdG9rZW5faWRzID0gWy4uLmJlYW0ub3V0cHV0X3Rva2VuX2lkcywgbmV3VG9rZW5JZF07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29tcHV0ZSB0aGUgZm9yd2FyZCBwYXNzIG9mIHRoZSBtb2RlbCBvbiB0aGUgZ2l2ZW4gaW5wdXQgdGVuc29ycy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtb2RlbF9pbnB1dHMgVGhlIGlucHV0IHRlbnNvcnMgYXMgYW4gb2JqZWN0IHdpdGgga2V5cyAncGl4ZWxfdmFsdWVzJyBhbmQgJ2RlY29kZXJfaW5wdXRfaWRzJy5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxhbnk+fSBUaGUgb3V0cHV0IHRlbnNvciBvZiB0aGUgbW9kZWwuXG4gICAgICovXG4gICAgYXN5bmMgZm9yd2FyZChtb2RlbF9pbnB1dHMpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHNlcTJzZXFGb3J3YXJkKHRoaXMsIG1vZGVsX2lucHV0cywge1xuICAgICAgICAgICAgYWRkX2RlY29kZXJfcGt2OiBmYWxzZVxuICAgICAgICB9KVxuICAgIH1cbn1cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBDTElQIG1vZGVsc1xuZXhwb3J0IGNsYXNzIENMSVBQcmVUcmFpbmVkTW9kZWwgZXh0ZW5kcyBQcmVUcmFpbmVkTW9kZWwgeyB9XG5leHBvcnQgY2xhc3MgQ0xJUE1vZGVsIGV4dGVuZHMgQ0xJUFByZVRyYWluZWRNb2RlbCB7XG5cbn1cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIEdQVDIgbW9kZWxzXG5leHBvcnQgY2xhc3MgR1BUMlByZVRyYWluZWRNb2RlbCBleHRlbmRzIFByZVRyYWluZWRNb2RlbCB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiB0aGUgYEdQVDJQcmVUcmFpbmVkTW9kZWxgIGNsYXNzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgVGhlIGNvbmZpZ3VyYXRpb24gb2YgdGhlIG1vZGVsLlxuICAgICAqIEBwYXJhbSB7YW55fSBzZXNzaW9uIFRoZSBPTk5YIHNlc3Npb24gY29udGFpbmluZyB0aGUgbW9kZWwgd2VpZ2h0cy5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihjb25maWcsIHNlc3Npb24pIHtcbiAgICAgICAgc3VwZXIoY29uZmlnLCBzZXNzaW9uKTtcblxuICAgICAgICAvLyBjb25maWcgZG9lc24ndCBjb250YWluIHBhZF90b2tlbl9pZCwgc28gd2UgYXNzdW1lIGl0IGlzIHRoZSBlb3NfdG9rZW5faWRcbiAgICAgICAgdGhpcy5jb25maWcucGFkX3Rva2VuX2lkID0gdGhpcy5jb25maWcuZW9zX3Rva2VuX2lkXG5cbiAgICAgICAgdGhpcy5udW1faGVhZHMgPSB0aGlzLmNvbmZpZy5uX2hlYWRcbiAgICAgICAgdGhpcy5udW1fbGF5ZXJzID0gdGhpcy5jb25maWcubl9sYXllclxuICAgICAgICB0aGlzLmRpbV9rdiA9IHRoaXMuY29uZmlnLm5fZW1iZCAvIHRoaXMubnVtX2hlYWRzO1xuICAgIH1cbn1cblxuZXhwb3J0IGNsYXNzIEdQVDJNb2RlbCBleHRlbmRzIEdQVDJQcmVUcmFpbmVkTW9kZWwge1xuXG4gICAgLyoqXG4gICAgICogR1BUMk1vZGVsIGlzIG5vdCBjb21wYXRpYmxlIHdpdGggYC5nZW5lcmF0ZSgpYCwgYXMgaXQgZG9lc24ndCBoYXZlIGEgbGFuZ3VhZ2UgbW9kZWwgaGVhZC5cbiAgICAgKiBAcGFyYW0gIHsuLi5hbnl9IGFyZ3MgXG4gICAgICogQHRocm93cyB7RXJyb3J9XG4gICAgICogQHJldHVybnMge1Byb21pc2U8YW55Pn1cbiAgICAgKi9cbiAgICBhc3luYyBnZW5lcmF0ZSguLi5hcmdzKSB7XG4gICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgXCJUaGUgY3VycmVudCBtb2RlbCBjbGFzcyAoR1BUMk1vZGVsKSBpcyBub3QgY29tcGF0aWJsZSB3aXRoIGAuZ2VuZXJhdGUoKWAsIGFzIGl0IGRvZXNuJ3QgaGF2ZSBhIGxhbmd1YWdlIG1vZGVsIGhlYWQuIFBsZWFzZSB1c2Ugb25lIG9mIHRoZSBmb2xsb3dpbmcgY2xhc3NlcyBpbnN0ZWFkOiB7J0dQVDJMTUhlYWRNb2RlbCd9XCJcbiAgICAgICAgKVxuICAgIH1cbn1cblxuLyoqXG4gKiBHUFQtMiBsYW5ndWFnZSBtb2RlbCBoZWFkIG9uIHRvcCBvZiB0aGUgR1BULTIgYmFzZSBtb2RlbC4gVGhpcyBtb2RlbCBpcyBzdWl0YWJsZSBmb3IgdGV4dCBnZW5lcmF0aW9uIHRhc2tzLlxuICogQGV4dGVuZHMgR1BUMlByZVRyYWluZWRNb2RlbFxuICovXG5leHBvcnQgY2xhc3MgR1BUMkxNSGVhZE1vZGVsIGV4dGVuZHMgR1BUMlByZVRyYWluZWRNb2RlbCB7XG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyBhbmQgcmV0dXJucyB0aGUgYmVhbSBmb3IgdGV4dCBnZW5lcmF0aW9uIHRhc2tcbiAgICAgKiBAcGFyYW0ge1RlbnNvcn0gaW5wdXRUb2tlbklkcyBUaGUgaW5wdXQgdG9rZW4gaWRzLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBudW1PdXRwdXRUb2tlbnMgVGhlIG51bWJlciBvZiB0b2tlbnMgdG8gYmUgZ2VuZXJhdGVkLlxuICAgICAqIEBwYXJhbSB7VGVuc29yfSBpbnB1dHNfYXR0ZW50aW9uX21hc2sgT3B0aW9uYWwgaW5wdXQgYXR0ZW50aW9uIG1hc2suXG4gICAgICogQHJldHVybnMge2FueX0gQSBCZWFtIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIGluaXRpYWxpemVkIGJlYW0uXG4gICAgICovXG4gICAgZ2V0U3RhcnRCZWFtcyhpbnB1dFRva2VuSWRzLCBudW1PdXRwdXRUb2tlbnMsIGlucHV0c19hdHRlbnRpb25fbWFzaykge1xuICAgICAgICByZXR1cm4gZGVjb2RlclN0YXJ0QmVhbXModGhpcywgaW5wdXRUb2tlbklkcywgbnVtT3V0cHV0VG9rZW5zLCBpbnB1dHNfYXR0ZW50aW9uX21hc2spXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUnVucyBhIHNpbmdsZSBzdGVwIG9mIHRoZSBiZWFtIHNlYXJjaCBnZW5lcmF0aW9uIGFsZ29yaXRobS5cbiAgICAgKiBAcGFyYW0ge2FueX0gYmVhbSBUaGUgY3VycmVudCBiZWFtIGJlaW5nIGdlbmVyYXRlZC5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxhbnk+fSBUaGUgdXBkYXRlZCBiZWFtIGFmdGVyIGEgc2luZ2xlIGdlbmVyYXRpb24gc3RlcC5cbiAgICAgKi9cbiAgICBhc3luYyBydW5CZWFtKGJlYW0pIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IGRlY29kZXJSdW5CZWFtKHRoaXMsIGJlYW0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIGdpdmVuIGJlYW0gd2l0aCB0aGUgbmV3IGdlbmVyYXRlZCB0b2tlbiBpZC5cbiAgICAgKiBAcGFyYW0ge2FueX0gYmVhbSBUaGUgQmVhbSBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBiZWFtLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuZXdUb2tlbklkIFRoZSBuZXcgZ2VuZXJhdGVkIHRva2VuIGlkIHRvIGJlIGFkZGVkIHRvIHRoZSBiZWFtLlxuICAgICAqL1xuICAgIHVwZGF0ZUJlYW0oYmVhbSwgbmV3VG9rZW5JZCkge1xuICAgICAgICByZXR1cm4gZGVjb2RlclVwZGF0ZWJlYW0oYmVhbSwgbmV3VG9rZW5JZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRm9yd2FyZCBwYXNzIGZvciB0aGUgbW9kZWwuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1vZGVsX2lucHV0cyBUaGUgaW5wdXRzIGZvciB0aGUgbW9kZWwuXG4gICAgICogQHJldHVybnMge1Byb21pc2U8YW55Pn0gVGhlIG91dHB1dCB0ZW5zb3Igb2YgdGhlIG1vZGVsLlxuICAgICAqL1xuICAgIGFzeW5jIGZvcndhcmQobW9kZWxfaW5wdXRzKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCBkZWNvZGVyRm9yd2FyZCh0aGlzLCBtb2RlbF9pbnB1dHMpO1xuICAgIH1cblxufVxuLy8gZXhwb3J0IGNsYXNzIEdQVDJGb3JTZXF1ZW5jZUNsYXNzaWZpY2F0aW9uIGV4dGVuZHMgR1BUMlByZVRyYWluZWRNb2RlbCB7XG4vLyBUT0RPXG4vLyB9XG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuZXhwb3J0IGNsYXNzIEdQVE5lb1ByZVRyYWluZWRNb2RlbCBleHRlbmRzIFByZVRyYWluZWRNb2RlbCB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiB0aGUgYEdQVE5lb1ByZVRyYWluZWRNb2RlbGAgY2xhc3MuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBUaGUgY29uZmlndXJhdGlvbiBvZiB0aGUgbW9kZWwuXG4gICAgICogQHBhcmFtIHthbnl9IHNlc3Npb24gVGhlIE9OTlggc2Vzc2lvbiBjb250YWluaW5nIHRoZSBtb2RlbCB3ZWlnaHRzLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZywgc2Vzc2lvbikge1xuICAgICAgICBzdXBlcihjb25maWcsIHNlc3Npb24pO1xuXG4gICAgICAgIC8vIGNvbmZpZyBkb2Vzbid0IGNvbnRhaW4gcGFkX3Rva2VuX2lkLCBzbyB3ZSBhc3N1bWUgaXQgaXMgdGhlIGVvc190b2tlbl9pZFxuICAgICAgICB0aGlzLmNvbmZpZy5wYWRfdG9rZW5faWQgPSB0aGlzLmNvbmZpZy5lb3NfdG9rZW5faWRcblxuICAgICAgICB0aGlzLm51bV9oZWFkcyA9IHRoaXMuY29uZmlnLm51bV9oZWFkcztcbiAgICAgICAgdGhpcy5udW1fbGF5ZXJzID0gdGhpcy5jb25maWcubnVtX2xheWVycztcbiAgICAgICAgdGhpcy5kaW1fa3YgPSB0aGlzLmNvbmZpZy5oaWRkZW5fc2l6ZSAvIHRoaXMubnVtX2hlYWRzO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBHUFROZW9Nb2RlbCBleHRlbmRzIEdQVE5lb1ByZVRyYWluZWRNb2RlbCB7XG4gICAgLyoqXG4gICAgICogXG4gICAgICogQHBhcmFtICB7Li4uYW55fSBhcmdzIFxuICAgICAqIEB0aHJvd3Mge0Vycm9yfVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPGFueT59XG4gICAgICovXG4gICAgYXN5bmMgZ2VuZXJhdGUoLi4uYXJncykge1xuICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgIFwiVGhlIGN1cnJlbnQgbW9kZWwgY2xhc3MgKEdQVE5lb01vZGVsKSBpcyBub3QgY29tcGF0aWJsZSB3aXRoIGAuZ2VuZXJhdGUoKWAsIGFzIGl0IGRvZXNuJ3QgaGF2ZSBhIGxhbmd1YWdlIG1vZGVsIGhlYWQuIFBsZWFzZSB1c2Ugb25lIG9mIHRoZSBmb2xsb3dpbmcgY2xhc3NlcyBpbnN0ZWFkOiB7J0dQVE5lb0ZvckNhdXNhbExNJ31cIlxuICAgICAgICApXG4gICAgfVxufVxuXG5leHBvcnQgY2xhc3MgR1BUTmVvRm9yQ2F1c2FsTE0gZXh0ZW5kcyBHUFROZW9QcmVUcmFpbmVkTW9kZWwge1xuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgYW5kIHJldHVybnMgdGhlIGJlYW0gZm9yIHRleHQgZ2VuZXJhdGlvbiB0YXNrXG4gICAgICogQHBhcmFtIHtUZW5zb3J9IGlucHV0VG9rZW5JZHMgVGhlIGlucHV0IHRva2VuIGlkcy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbnVtT3V0cHV0VG9rZW5zIFRoZSBudW1iZXIgb2YgdG9rZW5zIHRvIGJlIGdlbmVyYXRlZC5cbiAgICAgKiBAcGFyYW0ge1RlbnNvcn0gaW5wdXRzX2F0dGVudGlvbl9tYXNrIE9wdGlvbmFsIGlucHV0IGF0dGVudGlvbiBtYXNrLlxuICAgICAqIEByZXR1cm5zIHthbnl9IEEgQmVhbSBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBpbml0aWFsaXplZCBiZWFtLlxuICAgICAqL1xuICAgIGdldFN0YXJ0QmVhbXMoaW5wdXRUb2tlbklkcywgbnVtT3V0cHV0VG9rZW5zLCBpbnB1dHNfYXR0ZW50aW9uX21hc2spIHtcbiAgICAgICAgcmV0dXJuIGRlY29kZXJTdGFydEJlYW1zKHRoaXMsIGlucHV0VG9rZW5JZHMsIG51bU91dHB1dFRva2VucywgaW5wdXRzX2F0dGVudGlvbl9tYXNrKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJ1bnMgYSBzaW5nbGUgc3RlcCBvZiB0aGUgYmVhbSBzZWFyY2ggZ2VuZXJhdGlvbiBhbGdvcml0aG0uXG4gICAgICogQHBhcmFtIHthbnl9IGJlYW0gVGhlIGN1cnJlbnQgYmVhbSBiZWluZyBnZW5lcmF0ZWQuXG4gICAgICogQHJldHVybnMge1Byb21pc2U8YW55Pn0gVGhlIHVwZGF0ZWQgYmVhbSBhZnRlciBhIHNpbmdsZSBnZW5lcmF0aW9uIHN0ZXAuXG4gICAgICovXG4gICAgYXN5bmMgcnVuQmVhbShiZWFtKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCBkZWNvZGVyUnVuQmVhbSh0aGlzLCBiZWFtKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSBnaXZlbiBiZWFtIHdpdGggdGhlIG5ldyBnZW5lcmF0ZWQgdG9rZW4gaWQuXG4gICAgICogQHBhcmFtIHthbnl9IGJlYW0gVGhlIEJlYW0gb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgYmVhbS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbmV3VG9rZW5JZCBUaGUgbmV3IGdlbmVyYXRlZCB0b2tlbiBpZCB0byBiZSBhZGRlZCB0byB0aGUgYmVhbS5cbiAgICAgKi9cbiAgICB1cGRhdGVCZWFtKGJlYW0sIG5ld1Rva2VuSWQpIHtcbiAgICAgICAgcmV0dXJuIGRlY29kZXJVcGRhdGViZWFtKGJlYW0sIG5ld1Rva2VuSWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZvcndhcmQgcGFzcyBmb3IgdGhlIG1vZGVsLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtb2RlbF9pbnB1dHMgVGhlIGlucHV0cyBmb3IgdGhlIG1vZGVsLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPGFueT59IFRoZSBvdXRwdXQgdGVuc29yIG9mIHRoZSBtb2RlbC5cbiAgICAgKi9cbiAgICBhc3luYyBmb3J3YXJkKG1vZGVsX2lucHV0cykge1xuICAgICAgICByZXR1cm4gYXdhaXQgZGVjb2RlckZvcndhcmQodGhpcywgbW9kZWxfaW5wdXRzKTtcbiAgICB9XG59XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBDb2RlR2VuIG1vZGVsc1xuZXhwb3J0IGNsYXNzIENvZGVHZW5QcmVUcmFpbmVkTW9kZWwgZXh0ZW5kcyBQcmVUcmFpbmVkTW9kZWwge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgdGhlIGBDb2RlR2VuUHJlVHJhaW5lZE1vZGVsYCBjbGFzcy5cbiAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgVGhlIG1vZGVsIGNvbmZpZ3VyYXRpb24gb2JqZWN0LlxuICAgICogQHBhcmFtIHtPYmplY3R9IHNlc3Npb24gVGhlIE9OTlggc2Vzc2lvbiBvYmplY3QuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihjb25maWcsIHNlc3Npb24pIHtcbiAgICAgICAgc3VwZXIoY29uZmlnLCBzZXNzaW9uKTtcblxuICAgICAgICAvLyBjb25maWcgZG9lc24ndCBjb250YWluIHBhZF90b2tlbl9pZCwgc28gd2UgYXNzdW1lIGl0IGlzIHRoZSBlb3NfdG9rZW5faWRcbiAgICAgICAgdGhpcy5jb25maWcucGFkX3Rva2VuX2lkID0gdGhpcy5jb25maWcuZW9zX3Rva2VuX2lkXG5cbiAgICAgICAgdGhpcy5udW1faGVhZHMgPSB0aGlzLmNvbmZpZy5uX2hlYWRcbiAgICAgICAgdGhpcy5udW1fbGF5ZXJzID0gdGhpcy5jb25maWcubl9sYXllclxuICAgICAgICB0aGlzLmRpbV9rdiA9IHRoaXMuY29uZmlnLm5fZW1iZCAvIHRoaXMubnVtX2hlYWRzO1xuICAgIH1cbn1cbi8qKlxuICogQ29kZUdlbk1vZGVsIGlzIGEgY2xhc3MgcmVwcmVzZW50aW5nIGEgY29kZSBnZW5lcmF0aW9uIG1vZGVsIHdpdGhvdXQgYSBsYW5ndWFnZSBtb2RlbCBoZWFkLlxuICogXG4gKiBAZXh0ZW5kcyBDb2RlR2VuUHJlVHJhaW5lZE1vZGVsXG4gKi9cbmV4cG9ydCBjbGFzcyBDb2RlR2VuTW9kZWwgZXh0ZW5kcyBDb2RlR2VuUHJlVHJhaW5lZE1vZGVsIHtcbiAgICAvKipcbiAgICAgKiBUaHJvd3MgYW4gZXJyb3IgaW5kaWNhdGluZyB0aGF0IHRoZSBjdXJyZW50IG1vZGVsIGNsYXNzIGlzIG5vdCBjb21wYXRpYmxlIHdpdGggYC5nZW5lcmF0ZSgpYCxcbiAgICAgKiBhcyBpdCBkb2Vzbid0IGhhdmUgYSBsYW5ndWFnZSBtb2RlbCBoZWFkLlxuICAgICAqIFxuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBUaGUgY3VycmVudCBtb2RlbCBjbGFzcyBpcyBub3QgY29tcGF0aWJsZSB3aXRoIGAuZ2VuZXJhdGUoKWBcbiAgICAgKiBcbiAgICAgKiBAcGFyYW0gIHsuLi5hbnl9IGFyZ3MgQXJndW1lbnRzIHBhc3NlZCB0byB0aGUgZ2VuZXJhdGUgZnVuY3Rpb25cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxhbnk+fVxuICAgICAqL1xuICAgIGFzeW5jIGdlbmVyYXRlKC4uLmFyZ3MpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICBcIlRoZSBjdXJyZW50IG1vZGVsIGNsYXNzIChDb2RlR2VuTW9kZWwpIGlzIG5vdCBjb21wYXRpYmxlIHdpdGggYC5nZW5lcmF0ZSgpYCwgYXMgaXQgZG9lc24ndCBoYXZlIGEgbGFuZ3VhZ2UgbW9kZWwgaGVhZC4gUGxlYXNlIHVzZSBvbmUgb2YgdGhlIGZvbGxvd2luZyBjbGFzc2VzIGluc3RlYWQ6IHsnQ29kZUdlbkZvckNhdXNhbExNJ31cIlxuICAgICAgICApXG4gICAgfVxufVxuXG4vKipcbiAqIENvZGVHZW5Gb3JDYXVzYWxMTSBpcyBhIGNsYXNzIHRoYXQgcmVwcmVzZW50cyBhIGNvZGUgZ2VuZXJhdGlvbiBtb2RlbCBiYXNlZCBvbiB0aGUgR1BULTIgYXJjaGl0ZWN0dXJlLiBJdCBleHRlbmRzIHRoZSBgQ29kZUdlblByZVRyYWluZWRNb2RlbGAgY2xhc3MuXG4gKiBAZXh0ZW5kcyBDb2RlR2VuUHJlVHJhaW5lZE1vZGVsXG4gKi9cbmV4cG9ydCBjbGFzcyBDb2RlR2VuRm9yQ2F1c2FsTE0gZXh0ZW5kcyBDb2RlR2VuUHJlVHJhaW5lZE1vZGVsIHtcblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIGFuZCByZXR1cm5zIHRoZSBiZWFtIGZvciB0ZXh0IGdlbmVyYXRpb24gdGFza1xuICAgICAqIEBwYXJhbSB7VGVuc29yfSBpbnB1dFRva2VuSWRzIFRoZSBpbnB1dCB0b2tlbiBpZHMuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG51bU91dHB1dFRva2VucyBUaGUgbnVtYmVyIG9mIHRva2VucyB0byBiZSBnZW5lcmF0ZWQuXG4gICAgICogQHBhcmFtIHtUZW5zb3J9IGlucHV0c19hdHRlbnRpb25fbWFzayBPcHRpb25hbCBpbnB1dCBhdHRlbnRpb24gbWFzay5cbiAgICAgKiBAcmV0dXJucyB7YW55fSBBIEJlYW0gb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgaW5pdGlhbGl6ZWQgYmVhbS5cbiAgICAgKi9cbiAgICBnZXRTdGFydEJlYW1zKGlucHV0VG9rZW5JZHMsIG51bU91dHB1dFRva2VucywgaW5wdXRzX2F0dGVudGlvbl9tYXNrKSB7XG4gICAgICAgIHJldHVybiBkZWNvZGVyU3RhcnRCZWFtcyh0aGlzLCBpbnB1dFRva2VuSWRzLCBudW1PdXRwdXRUb2tlbnMsIGlucHV0c19hdHRlbnRpb25fbWFzaylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSdW5zIGEgc2luZ2xlIHN0ZXAgb2YgdGhlIGJlYW0gc2VhcmNoIGdlbmVyYXRpb24gYWxnb3JpdGhtLlxuICAgICAqIEBwYXJhbSB7YW55fSBiZWFtIFRoZSBjdXJyZW50IGJlYW0gYmVpbmcgZ2VuZXJhdGVkLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPGFueT59IFRoZSB1cGRhdGVkIGJlYW0gYWZ0ZXIgYSBzaW5nbGUgZ2VuZXJhdGlvbiBzdGVwLlxuICAgICAqL1xuICAgIGFzeW5jIHJ1bkJlYW0oYmVhbSkge1xuICAgICAgICByZXR1cm4gYXdhaXQgZGVjb2RlclJ1bkJlYW0odGhpcywgYmVhbSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgZ2l2ZW4gYmVhbSB3aXRoIHRoZSBuZXcgZ2VuZXJhdGVkIHRva2VuIGlkLlxuICAgICAqIEBwYXJhbSB7YW55fSBiZWFtIFRoZSBCZWFtIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIGJlYW0uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG5ld1Rva2VuSWQgVGhlIG5ldyBnZW5lcmF0ZWQgdG9rZW4gaWQgdG8gYmUgYWRkZWQgdG8gdGhlIGJlYW0uXG4gICAgICovXG4gICAgdXBkYXRlQmVhbShiZWFtLCBuZXdUb2tlbklkKSB7XG4gICAgICAgIHJldHVybiBkZWNvZGVyVXBkYXRlYmVhbShiZWFtLCBuZXdUb2tlbklkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGb3J3YXJkIHBhc3MgZm9yIHRoZSBtb2RlbC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbW9kZWxfaW5wdXRzIFRoZSBpbnB1dHMgZm9yIHRoZSBtb2RlbC5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxhbnk+fSBUaGUgb3V0cHV0IHRlbnNvciBvZiB0aGUgbW9kZWwuXG4gICAgICovXG4gICAgYXN5bmMgZm9yd2FyZChtb2RlbF9pbnB1dHMpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IGRlY29kZXJGb3J3YXJkKHRoaXMsIG1vZGVsX2lucHV0cyk7XG4gICAgfVxuXG59XG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuZXhwb3J0IGNsYXNzIFZpVFByZVRyYWluZWRNb2RlbCBleHRlbmRzIFByZVRyYWluZWRNb2RlbCB7IH1cbmV4cG9ydCBjbGFzcyBWaVRGb3JJbWFnZUNsYXNzaWZpY2F0aW9uIGV4dGVuZHMgVmlUUHJlVHJhaW5lZE1vZGVsIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge2FueX0gbW9kZWxfaW5wdXRzXG4gICAgICovXG4gICAgYXN5bmMgX2NhbGwobW9kZWxfaW5wdXRzKSB7XG4gICAgICAgIHJldHVybiBuZXcgU2VxdWVuY2VDbGFzc2lmaWVyT3V0cHV0KGF3YWl0IHN1cGVyLl9jYWxsKG1vZGVsX2lucHV0cykpO1xuICAgIH1cbn1cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5leHBvcnQgY2xhc3MgTW9iaWxlVmlUUHJlVHJhaW5lZE1vZGVsIGV4dGVuZHMgUHJlVHJhaW5lZE1vZGVsIHsgfVxuZXhwb3J0IGNsYXNzIE1vYmlsZVZpVEZvckltYWdlQ2xhc3NpZmljYXRpb24gZXh0ZW5kcyBNb2JpbGVWaVRQcmVUcmFpbmVkTW9kZWwge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7YW55fSBtb2RlbF9pbnB1dHNcbiAgICAgKi9cbiAgICBhc3luYyBfY2FsbChtb2RlbF9pbnB1dHMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTZXF1ZW5jZUNsYXNzaWZpZXJPdXRwdXQoYXdhaXQgc3VwZXIuX2NhbGwobW9kZWxfaW5wdXRzKSk7XG4gICAgfVxufVxuLy8gVE9ETzogTW9iaWxlVmlURm9yU2VtYW50aWNTZWdtZW50YXRpb25cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5leHBvcnQgY2xhc3MgRGV0clByZVRyYWluZWRNb2RlbCBleHRlbmRzIFByZVRyYWluZWRNb2RlbCB7IH1cbmV4cG9ydCBjbGFzcyBEZXRyRm9yT2JqZWN0RGV0ZWN0aW9uIGV4dGVuZHMgRGV0clByZVRyYWluZWRNb2RlbCB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHthbnl9IG1vZGVsX2lucHV0c1xuICAgICAqL1xuICAgIGFzeW5jIF9jYWxsKG1vZGVsX2lucHV0cykge1xuICAgICAgICByZXR1cm4gbmV3IERldHJPYmplY3REZXRlY3Rpb25PdXRwdXQoYXdhaXQgc3VwZXIuX2NhbGwobW9kZWxfaW5wdXRzKSk7XG4gICAgfVxufVxuXG5leHBvcnQgY2xhc3MgRGV0ckZvclNlZ21lbnRhdGlvbiBleHRlbmRzIERldHJQcmVUcmFpbmVkTW9kZWwge1xuICAgIC8qKlxuICAgICAqIFJ1bnMgdGhlIG1vZGVsIHdpdGggdGhlIHByb3ZpZGVkIGlucHV0c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtb2RlbF9pbnB1dHMgTW9kZWwgaW5wdXRzXG4gICAgICogQHJldHVybnMge1Byb21pc2U8RGV0clNlZ21lbnRhdGlvbk91dHB1dD59IE9iamVjdCBjb250YWluaW5nIHNlZ21lbnRhdGlvbiBvdXRwdXRzXG4gICAgICovXG4gICAgYXN5bmMgX2NhbGwobW9kZWxfaW5wdXRzKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGV0clNlZ21lbnRhdGlvbk91dHB1dChhd2FpdCBzdXBlci5fY2FsbChtb2RlbF9pbnB1dHMpKTtcbiAgICB9XG59XG5cbmV4cG9ydCBjbGFzcyBEZXRyT2JqZWN0RGV0ZWN0aW9uT3V0cHV0IGV4dGVuZHMgTW9kZWxPdXRwdXQge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvdXRwdXQgVGhlIG91dHB1dCBvZiB0aGUgbW9kZWwuXG4gICAgICogQHBhcmFtIHtUZW5zb3J9IG91dHB1dC5sb2dpdHMgQ2xhc3NpZmljYXRpb24gbG9naXRzIChpbmNsdWRpbmcgbm8tb2JqZWN0KSBmb3IgYWxsIHF1ZXJpZXMuXG4gICAgICogQHBhcmFtIHtUZW5zb3J9IG91dHB1dC5wcmVkX2JveGVzIE5vcm1hbGl6ZWQgYm94ZXMgY29vcmRpbmF0ZXMgZm9yIGFsbCBxdWVyaWVzLCByZXByZXNlbnRlZCBhcyAoY2VudGVyX3gsIGNlbnRlcl95LCB3aWR0aCwgaGVpZ2h0KS5cbiAgICAgKiBUaGVzZSB2YWx1ZXMgYXJlIG5vcm1hbGl6ZWQgaW4gWzAsIDFdLCByZWxhdGl2ZSB0byB0aGUgc2l6ZSBvZiBlYWNoIGluZGl2aWR1YWwgaW1hZ2UgaW4gdGhlIGJhdGNoIChkaXNyZWdhcmRpbmcgcG9zc2libGUgcGFkZGluZykuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoeyBsb2dpdHMsIHByZWRfYm94ZXMgfSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmxvZ2l0cyA9IGxvZ2l0cztcbiAgICAgICAgdGhpcy5wcmVkX2JveGVzID0gcHJlZF9ib3hlcztcbiAgICB9XG59XG5cbmV4cG9ydCBjbGFzcyBEZXRyU2VnbWVudGF0aW9uT3V0cHV0IGV4dGVuZHMgTW9kZWxPdXRwdXQge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvdXRwdXQgVGhlIG91dHB1dCBvZiB0aGUgbW9kZWwuXG4gICAgICogQHBhcmFtIHtUZW5zb3J9IG91dHB1dC5sb2dpdHMgVGhlIG91dHB1dCBsb2dpdHMgb2YgdGhlIG1vZGVsLlxuICAgICAqIEBwYXJhbSB7VGVuc29yfSBvdXRwdXQucHJlZF9ib3hlcyBQcmVkaWN0ZWQgYm94ZXMuXG4gICAgICogQHBhcmFtIHtUZW5zb3J9IG91dHB1dC5wcmVkX21hc2tzIFByZWRpY3RlZCBtYXNrcy5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih7IGxvZ2l0cywgcHJlZF9ib3hlcywgcHJlZF9tYXNrcyB9KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMubG9naXRzID0gbG9naXRzO1xuICAgICAgICB0aGlzLnByZWRfYm94ZXMgPSBwcmVkX2JveGVzO1xuICAgICAgICB0aGlzLnByZWRfbWFza3MgPSBwcmVkX21hc2tzO1xuICAgIH1cbn1cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbmV4cG9ydCBjbGFzcyBTYW1QcmVUcmFpbmVkTW9kZWwgZXh0ZW5kcyBQcmVUcmFpbmVkTW9kZWwgeyB9XG5leHBvcnQgY2xhc3MgU2FtTW9kZWwgZXh0ZW5kcyBTYW1QcmVUcmFpbmVkTW9kZWwge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtb2RlbF9pbnB1dHNcbiAgICAgKiBAcGFyYW0ge1RlbnNvcn0gbW9kZWxfaW5wdXRzLnBpeGVsX3ZhbHVlcyBQaXhlbCB2YWx1ZXMgYXMgYSBUZW5zb3Igd2l0aCBzaGFwZSBgKGJhdGNoX3NpemUsIG51bV9jaGFubmVscywgaGVpZ2h0LCB3aWR0aClgLlxuICAgICAqIEBwYXJhbSB7VGVuc29yfSBtb2RlbF9pbnB1dHMuaW5wdXRfcG9pbnRzIElucHV0IDJEIHNwYXRpYWwgcG9pbnRzIHdpdGggc2hhcGUgYChiYXRjaF9zaXplLCBudW1fcG9pbnRzLCAyKWAuIFRoaXMgaXMgdXNlZCBieSB0aGUgcHJvbXB0IGVuY29kZXIgdG8gZW5jb2RlIHRoZSBwcm9tcHQuXG4gICAgICogQHRvZG8gQWRkIHN1cHBvcnQgZm9yIGBpbnB1dF9sYWJlbHNgLCBgaW5wdXRfYm94ZXNgLCBgaW5wdXRfbWFza3NgLCBhbmQgYGltYWdlX2VtYmVkZGluZ3NgLlxuICAgICAqL1xuICAgIGFzeW5jIF9jYWxsKG1vZGVsX2lucHV0cykge1xuICAgICAgICByZXR1cm4gbmV3IFNhbUltYWdlU2VnbWVudGF0aW9uT3V0cHV0KGF3YWl0IHN1cGVyLl9jYWxsKG1vZGVsX2lucHV0cykpO1xuICAgIH1cbn1cblxuXG4vKipcbiAqIEJhc2UgY2xhc3MgZm9yIFNlZ21lbnQtQW55dGhpbmcgbW9kZWwncyBvdXRwdXQuXG4gKi9cbmV4cG9ydCBjbGFzcyBTYW1JbWFnZVNlZ21lbnRhdGlvbk91dHB1dCBleHRlbmRzIE1vZGVsT3V0cHV0IHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3V0cHV0IFRoZSBvdXRwdXQgb2YgdGhlIG1vZGVsLlxuICAgICAqIEBwYXJhbSB7VGVuc29yfSBvdXRwdXQuaW91X3Njb3JlcyBUaGUgb3V0cHV0IGxvZ2l0cyBvZiB0aGUgbW9kZWwuXG4gICAgICogQHBhcmFtIHtUZW5zb3J9IG91dHB1dC5wcmVkX21hc2tzIFByZWRpY3RlZCBib3hlcy5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih7IGlvdV9zY29yZXMsIHByZWRfbWFza3MgfSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmlvdV9zY29yZXMgPSBpb3Vfc2NvcmVzO1xuICAgICAgICB0aGlzLnByZWRfbWFza3MgPSBwcmVkX21hc2tzO1xuICAgIH1cbn1cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIE1hcmlhbk1UIG1vZGVsc1xuZXhwb3J0IGNsYXNzIE1hcmlhblByZVRyYWluZWRNb2RlbCBleHRlbmRzIFByZVRyYWluZWRNb2RlbCB7IH07XG5cbmV4cG9ydCBjbGFzcyBNYXJpYW5Nb2RlbCBleHRlbmRzIE1hcmlhblByZVRyYWluZWRNb2RlbCB7XG4gICAgLyoqXG4gICAgICogXG4gICAgICogQHBhcmFtICB7Li4uYW55fSBhcmdzIFxuICAgICAqIEB0aHJvd3Mge0Vycm9yfVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPGFueT59XG4gICAgICovXG4gICAgYXN5bmMgZ2VuZXJhdGUoLi4uYXJncykge1xuICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgIFwiVGhlIGN1cnJlbnQgbW9kZWwgY2xhc3MgKE1hcmlhbk1vZGVsKSBpcyBub3QgY29tcGF0aWJsZSB3aXRoIGAuZ2VuZXJhdGUoKWAsIGFzIGl0IGRvZXNuJ3QgaGF2ZSBhIGxhbmd1YWdlIG1vZGVsIGhlYWQuIFBsZWFzZSB1c2Ugb25lIG9mIHRoZSBmb2xsb3dpbmcgY2xhc3NlcyBpbnN0ZWFkOiB7J01hcmlhbk1UTW9kZWwnfVwiXG4gICAgICAgIClcbiAgICB9XG59XG5cbmV4cG9ydCBjbGFzcyBNYXJpYW5NVE1vZGVsIGV4dGVuZHMgTWFyaWFuUHJlVHJhaW5lZE1vZGVsIHtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgdGhlIGBNYXJpYW5NVE1vZGVsYCBjbGFzcy5cbiAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgVGhlIG1vZGVsIGNvbmZpZ3VyYXRpb24gb2JqZWN0LlxuICAgICogQHBhcmFtIHtPYmplY3R9IHNlc3Npb24gVGhlIE9OTlggc2Vzc2lvbiBvYmplY3QuXG4gICAgKiBAcGFyYW0ge2FueX0gZGVjb2Rlcl9tZXJnZWRfc2Vzc2lvbiBcbiAgICAqIEBwYXJhbSB7YW55fSBnZW5lcmF0aW9uX2NvbmZpZyBcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZywgc2Vzc2lvbiwgZGVjb2Rlcl9tZXJnZWRfc2Vzc2lvbiwgZ2VuZXJhdGlvbl9jb25maWcpIHtcbiAgICAgICAgc3VwZXIoY29uZmlnLCBzZXNzaW9uKTtcbiAgICAgICAgdGhpcy5kZWNvZGVyX21lcmdlZF9zZXNzaW9uID0gZGVjb2Rlcl9tZXJnZWRfc2Vzc2lvbjtcbiAgICAgICAgdGhpcy5nZW5lcmF0aW9uX2NvbmZpZyA9IGdlbmVyYXRpb25fY29uZmlnO1xuXG4gICAgICAgIHRoaXMubnVtX2RlY29kZXJfbGF5ZXJzID0gdGhpcy5jb25maWcuZGVjb2Rlcl9sYXllcnM7XG4gICAgICAgIHRoaXMubnVtX2RlY29kZXJfaGVhZHMgPSB0aGlzLmNvbmZpZy5kZWNvZGVyX2F0dGVudGlvbl9oZWFkcztcbiAgICAgICAgdGhpcy5kZWNvZGVyX2RpbV9rdiA9IHRoaXMuY29uZmlnLmRfbW9kZWwgLyB0aGlzLm51bV9kZWNvZGVyX2hlYWRzO1xuXG4gICAgICAgIHRoaXMubnVtX2VuY29kZXJfbGF5ZXJzID0gdGhpcy5jb25maWcuZW5jb2Rlcl9sYXllcnM7XG4gICAgICAgIHRoaXMubnVtX2VuY29kZXJfaGVhZHMgPSB0aGlzLmNvbmZpZy5lbmNvZGVyX2F0dGVudGlvbl9oZWFkcztcbiAgICAgICAgdGhpcy5lbmNvZGVyX2RpbV9rdiA9IHRoaXMuY29uZmlnLmRfbW9kZWwgLyB0aGlzLm51bV9lbmNvZGVyX2hlYWRzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIGFuZCByZXR1cm5zIHRoZSBiZWFtIGZvciB0ZXh0IGdlbmVyYXRpb24gdGFza1xuICAgICAqIEBwYXJhbSB7YW55W119IGlucHV0cyBUaGUgaW5wdXQgdG9rZW4gaWRzLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBudW1PdXRwdXRUb2tlbnMgVGhlIG51bWJlciBvZiB0b2tlbnMgdG8gYmUgZ2VuZXJhdGVkLlxuICAgICAqIEByZXR1cm5zIHthbnl9IEEgQmVhbSBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBpbml0aWFsaXplZCBiZWFtLlxuICAgICAqIEBwYXJhbSB7YW55W119IGFyZ3NcbiAgICAgKi9cbiAgICBnZXRTdGFydEJlYW1zKGlucHV0cywgbnVtT3V0cHV0VG9rZW5zLCAuLi5hcmdzKSB7XG4gICAgICAgIHJldHVybiBzZXEyc2VxU3RhcnRCZWFtcyh0aGlzLCBpbnB1dHMsIG51bU91dHB1dFRva2Vucyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUnVucyBhIHNpbmdsZSBzdGVwIG9mIHRoZSBiZWFtIHNlYXJjaCBnZW5lcmF0aW9uIGFsZ29yaXRobS5cbiAgICAgKiBAcGFyYW0ge2FueX0gYmVhbSBUaGUgY3VycmVudCBiZWFtIGJlaW5nIGdlbmVyYXRlZC5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxhbnk+fSBUaGUgdXBkYXRlZCBiZWFtIGFmdGVyIGEgc2luZ2xlIGdlbmVyYXRpb24gc3RlcC5cbiAgICAgKi9cbiAgICBhc3luYyBydW5CZWFtKGJlYW0pIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHNlcTJzZXFSdW5CZWFtKHRoaXMsIGJlYW0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7YW55fSBiZWFtXG4gICAgICogQHBhcmFtIHthbnl9IG5ld1Rva2VuSWRcbiAgICAgKi9cbiAgICB1cGRhdGVCZWFtKGJlYW0sIG5ld1Rva2VuSWQpIHtcbiAgICAgICAgYmVhbS5vdXRwdXRfdG9rZW5faWRzID0gWy4uLmJlYW0ub3V0cHV0X3Rva2VuX2lkcywgbmV3VG9rZW5JZF07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHthbnl9IG1vZGVsX2lucHV0c1xuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFNlcTJTZXFMTU91dHB1dD59XG4gICAgICovXG4gICAgYXN5bmMgZm9yd2FyZChtb2RlbF9pbnB1dHMpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHNlcTJzZXFGb3J3YXJkKHRoaXMsIG1vZGVsX2lucHV0cyk7XG4gICAgfVxufVxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIE0yTTEwMCBtb2RlbHNcbmV4cG9ydCBjbGFzcyBNMk0xMDBQcmVUcmFpbmVkTW9kZWwgZXh0ZW5kcyBQcmVUcmFpbmVkTW9kZWwgeyB9O1xuXG5leHBvcnQgY2xhc3MgTTJNMTAwTW9kZWwgZXh0ZW5kcyBNMk0xMDBQcmVUcmFpbmVkTW9kZWwge1xuICAgIC8qKlxuICAgICAqIFxuICAgICAqIEBwYXJhbSAgey4uLmFueX0gYXJncyBcbiAgICAgKiBAdGhyb3dzIHtFcnJvcn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxhbnk+fVxuICAgICAqL1xuICAgIGFzeW5jIGdlbmVyYXRlKC4uLmFyZ3MpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICBcIlRoZSBjdXJyZW50IG1vZGVsIGNsYXNzIChNMk0xMDBNb2RlbCkgaXMgbm90IGNvbXBhdGlibGUgd2l0aCBgLmdlbmVyYXRlKClgLCBhcyBpdCBkb2Vzbid0IGhhdmUgYSBsYW5ndWFnZSBtb2RlbCBoZWFkLiBQbGVhc2UgdXNlIG9uZSBvZiB0aGUgZm9sbG93aW5nIGNsYXNzZXMgaW5zdGVhZDogeydNMk0xMDBGb3JDb25kaXRpb25hbEdlbmVyYXRpb24nfVwiXG4gICAgICAgIClcbiAgICB9XG59XG5cbmV4cG9ydCBjbGFzcyBNMk0xMDBGb3JDb25kaXRpb25hbEdlbmVyYXRpb24gZXh0ZW5kcyBNMk0xMDBQcmVUcmFpbmVkTW9kZWwge1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiB0aGUgYE0yTTEwMEZvckNvbmRpdGlvbmFsR2VuZXJhdGlvbmAgY2xhc3MuXG4gICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIFRoZSBtb2RlbCBjb25maWd1cmF0aW9uIG9iamVjdC5cbiAgICAqIEBwYXJhbSB7T2JqZWN0fSBzZXNzaW9uIFRoZSBPTk5YIHNlc3Npb24gb2JqZWN0LlxuICAgICogQHBhcmFtIHthbnl9IGRlY29kZXJfbWVyZ2VkX3Nlc3Npb24gXG4gICAgKiBAcGFyYW0ge2FueX0gZ2VuZXJhdGlvbl9jb25maWcgXG4gICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihjb25maWcsIHNlc3Npb24sIGRlY29kZXJfbWVyZ2VkX3Nlc3Npb24sIGdlbmVyYXRpb25fY29uZmlnKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZywgc2Vzc2lvbik7XG4gICAgICAgIHRoaXMuZGVjb2Rlcl9tZXJnZWRfc2Vzc2lvbiA9IGRlY29kZXJfbWVyZ2VkX3Nlc3Npb247XG4gICAgICAgIHRoaXMuZ2VuZXJhdGlvbl9jb25maWcgPSBnZW5lcmF0aW9uX2NvbmZpZztcblxuICAgICAgICB0aGlzLm51bV9kZWNvZGVyX2xheWVycyA9IHRoaXMuY29uZmlnLmRlY29kZXJfbGF5ZXJzO1xuICAgICAgICB0aGlzLm51bV9kZWNvZGVyX2hlYWRzID0gdGhpcy5jb25maWcuZGVjb2Rlcl9hdHRlbnRpb25faGVhZHM7XG4gICAgICAgIHRoaXMuZGVjb2Rlcl9kaW1fa3YgPSB0aGlzLmNvbmZpZy5kX21vZGVsIC8gdGhpcy5udW1fZGVjb2Rlcl9oZWFkcztcblxuICAgICAgICB0aGlzLm51bV9lbmNvZGVyX2xheWVycyA9IHRoaXMuY29uZmlnLmVuY29kZXJfbGF5ZXJzO1xuICAgICAgICB0aGlzLm51bV9lbmNvZGVyX2hlYWRzID0gdGhpcy5jb25maWcuZW5jb2Rlcl9hdHRlbnRpb25faGVhZHM7XG4gICAgICAgIHRoaXMuZW5jb2Rlcl9kaW1fa3YgPSB0aGlzLmNvbmZpZy5kX21vZGVsIC8gdGhpcy5udW1fZW5jb2Rlcl9oZWFkcztcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIGFuZCByZXR1cm5zIHRoZSBiZWFtIGZvciB0ZXh0IGdlbmVyYXRpb24gdGFza1xuICAgICAqIEBwYXJhbSB7YW55W119IGlucHV0cyBUaGUgaW5wdXQgdG9rZW4gaWRzLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBudW1PdXRwdXRUb2tlbnMgVGhlIG51bWJlciBvZiB0b2tlbnMgdG8gYmUgZ2VuZXJhdGVkLlxuICAgICAqIEByZXR1cm5zIHthbnl9IEEgQmVhbSBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBpbml0aWFsaXplZCBiZWFtLlxuICAgICAqIEBwYXJhbSB7YW55W119IGFyZ3NcbiAgICAgKi9cbiAgICBnZXRTdGFydEJlYW1zKGlucHV0cywgbnVtT3V0cHV0VG9rZW5zLCAuLi5hcmdzKSB7XG4gICAgICAgIHJldHVybiBzZXEyc2VxU3RhcnRCZWFtcyh0aGlzLCBpbnB1dHMsIG51bU91dHB1dFRva2Vucyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUnVucyBhIHNpbmdsZSBzdGVwIG9mIHRoZSBiZWFtIHNlYXJjaCBnZW5lcmF0aW9uIGFsZ29yaXRobS5cbiAgICAgKiBAcGFyYW0ge2FueX0gYmVhbSBUaGUgY3VycmVudCBiZWFtIGJlaW5nIGdlbmVyYXRlZC5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxhbnk+fSBUaGUgdXBkYXRlZCBiZWFtIGFmdGVyIGEgc2luZ2xlIGdlbmVyYXRpb24gc3RlcC5cbiAgICAgKi9cbiAgICBhc3luYyBydW5CZWFtKGJlYW0pIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHNlcTJzZXFSdW5CZWFtKHRoaXMsIGJlYW0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7YW55fSBiZWFtXG4gICAgICogQHBhcmFtIHthbnl9IG5ld1Rva2VuSWRcbiAgICAgKi9cbiAgICB1cGRhdGVCZWFtKGJlYW0sIG5ld1Rva2VuSWQpIHtcbiAgICAgICAgYmVhbS5vdXRwdXRfdG9rZW5faWRzID0gWy4uLmJlYW0ub3V0cHV0X3Rva2VuX2lkcywgbmV3VG9rZW5JZF07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHthbnl9IG1vZGVsX2lucHV0c1xuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFNlcTJTZXFMTU91dHB1dD59XG4gICAgICovXG4gICAgYXN5bmMgZm9yd2FyZChtb2RlbF9pbnB1dHMpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHNlcTJzZXFGb3J3YXJkKHRoaXMsIG1vZGVsX2lucHV0cyk7XG4gICAgfVxufVxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gQXV0b01vZGVscywgdXNlZCB0byBzaW1wbGlmeSBjb25zdHJ1Y3Rpb24gb2YgUHJlVHJhaW5lZE1vZGVsc1xuLy8gKHVzZXMgY29uZmlnIHRvIGluc3RhbnRpYXRlIGNvcnJlY3QgY2xhc3MpXG5cbi8qKlxuICogQmFzZSBjbGFzcyBvZiBhbGwgQXV0b01vZGVscy4gQ29udGFpbnMgdGhlIGBmcm9tX3ByZXRyYWluZWRgIGZ1bmN0aW9uXG4gKiB3aGljaCBpcyB1c2VkIHRvIGluc3RhbnRpYXRlIHByZXRyYWluZWQgbW9kZWxzLlxuICovXG5leHBvcnQgY2xhc3MgUHJldHJhaW5lZE1peGluIHtcbiAgICAvKipcbiAgICAgKiBNYXBwaW5nIGZyb20gbW9kZWwgdHlwZSB0byBtb2RlbCBjbGFzcy5cbiAgICAgKiBAdHlwZSB7TWFwPHN0cmluZywgT2JqZWN0PltdfVxuICAgICAqL1xuICAgIHN0YXRpYyBNT0RFTF9DTEFTU19NQVBQSU5HUyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRvIGF0dGVtcHQgdG8gaW5zdGFudGlhdGUgdGhlIGJhc2UgY2xhc3MgKGBQcmV0cmFpbmVkTW9kZWxgKSBpZiBcbiAgICAgKiB0aGUgbW9kZWwgdHlwZSBpcyBub3QgZm91bmQgaW4gdGhlIG1hcHBpbmcuXG4gICAgICovXG4gICAgc3RhdGljIEJBU0VfSUZfRkFJTCA9IGZhbHNlO1xuXG5cbiAgICAvKiogQHR5cGUge1ByZVRyYWluZWRNb2RlbC5mcm9tX3ByZXRyYWluZWR9ICovXG4gICAgc3RhdGljIGFzeW5jIGZyb21fcHJldHJhaW5lZChwcmV0cmFpbmVkX21vZGVsX25hbWVfb3JfcGF0aCwge1xuICAgICAgICBxdWFudGl6ZWQgPSB0cnVlLFxuICAgICAgICBwcm9ncmVzc19jYWxsYmFjayA9IG51bGwsXG4gICAgICAgIGNvbmZpZyA9IG51bGwsXG4gICAgICAgIGNhY2hlX2RpciA9IG51bGwsXG4gICAgICAgIGxvY2FsX2ZpbGVzX29ubHkgPSBmYWxzZSxcbiAgICAgICAgcmV2aXNpb24gPSAnbWFpbicsXG4gICAgfSA9IHt9KSB7XG5cbiAgICAgICAgbGV0IG9wdGlvbnMgPSB7XG4gICAgICAgICAgICBxdWFudGl6ZWQsXG4gICAgICAgICAgICBwcm9ncmVzc19jYWxsYmFjayxcbiAgICAgICAgICAgIGNvbmZpZyxcbiAgICAgICAgICAgIGNhY2hlX2RpcixcbiAgICAgICAgICAgIGxvY2FsX2ZpbGVzX29ubHksXG4gICAgICAgICAgICByZXZpc2lvbixcbiAgICAgICAgfVxuICAgICAgICBjb25maWcgPSBhd2FpdCBBdXRvQ29uZmlnLmZyb21fcHJldHJhaW5lZChwcmV0cmFpbmVkX21vZGVsX25hbWVfb3JfcGF0aCwgb3B0aW9ucyk7XG5cbiAgICAgICAgaWYgKCF0aGlzLk1PREVMX0NMQVNTX01BUFBJTkdTKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJgTU9ERUxfQ0xBU1NfTUFQUElOR1NgIG5vdCBpbXBsZW1lbnRlZCBmb3IgdGhpcyB0eXBlIG9mIGBBdXRvQ2xhc3NgOiBcIiArIHRoaXMubmFtZSk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgbW9kZWxDbGFzcztcbiAgICAgICAgZm9yIChsZXQgTU9ERUxfQ0xBU1NfTUFQUElORyBvZiB0aGlzLk1PREVMX0NMQVNTX01BUFBJTkdTKSB7XG4gICAgICAgICAgICBtb2RlbENsYXNzID0gTU9ERUxfQ0xBU1NfTUFQUElORy5nZXQoY29uZmlnLm1vZGVsX3R5cGUpO1xuICAgICAgICAgICAgaWYgKCFtb2RlbENsYXNzKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7IC8vIEl0ZW0gbm90IGZvdW5kIGluIHRoaXMgbWFwcGluZ1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgbW9kZWxDbGFzcy5mcm9tX3ByZXRyYWluZWQocHJldHJhaW5lZF9tb2RlbF9uYW1lX29yX3BhdGgsIG9wdGlvbnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuQkFTRV9JRl9GQUlMKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYFVua25vd24gbW9kZWwgY2xhc3MgXCIke2NvbmZpZy5tb2RlbF90eXBlfVwiLCBhdHRlbXB0aW5nIHRvIGNvbnN0cnVjdCBmcm9tIGJhc2UgY2xhc3MuYCk7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgUHJlVHJhaW5lZE1vZGVsLmZyb21fcHJldHJhaW5lZChwcmV0cmFpbmVkX21vZGVsX25hbWVfb3JfcGF0aCwgb3B0aW9ucyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihgVW5zdXBwb3J0ZWQgbW9kZWwgdHlwZTogJHtjb25maWcubW9kZWxfdHlwZX1gKVxuICAgICAgICB9XG4gICAgfVxufVxuXG5jb25zdCBNT0RFTF9NQVBQSU5HX05BTUVTX0VOQ09ERVJfT05MWSA9IG5ldyBNYXAoW1xuICAgIFsnYmVydCcsIEJlcnRNb2RlbF0sXG4gICAgWydhbGJlcnQnLCBBbGJlcnRNb2RlbF0sXG4gICAgWydkaXN0aWxiZXJ0JywgRGlzdGlsQmVydE1vZGVsXSxcbiAgICBbJ3JvYmVydGEnLCBSb2JlcnRhTW9kZWxdLFxuICAgIFsneGxtLXJvYmVydGEnLCBYTE1Sb2JlcnRhTW9kZWxdLFxuICAgIFsnY2xpcCcsIENMSVBNb2RlbF0sXG4gICAgWydtb2JpbGViZXJ0JywgTW9iaWxlQmVydE1vZGVsXSxcbiAgICBbJ3NxdWVlemViZXJ0JywgU3F1ZWV6ZUJlcnRNb2RlbF0sXG5cbiAgICBbJ3NhbScsIFNhbU1vZGVsXSwgLy8gVE9ETyBjaGFuZ2UgdG8gZW5jb2Rlci1kZWNvZGVyIHdoZW4gbW9kZWwgaXMgc3BsaXQgY29ycmVjdGx5XG5dKTtcblxuY29uc3QgTU9ERUxfTUFQUElOR19OQU1FU19FTkNPREVSX0RFQ09ERVIgPSBuZXcgTWFwKFtcbiAgICBbJ3Q1JywgVDVNb2RlbF0sXG4gICAgWydtdDUnLCBNVDVNb2RlbF0sXG4gICAgWydiYXJ0JywgQmFydE1vZGVsXSxcbiAgICBbJ21hcmlhbicsIE1hcmlhbk1vZGVsXSxcbiAgICBbJ3doaXNwZXInLCBXaGlzcGVyTW9kZWxdLFxuICAgIFsnbTJtXzEwMCcsIE0yTTEwME1vZGVsXSxcbl0pO1xuXG5cbmNvbnN0IE1PREVMX01BUFBJTkdfTkFNRVNfREVDT0RFUl9PTkxZID0gbmV3IE1hcChbXG4gICAgWydncHQyJywgR1BUMk1vZGVsXSxcbiAgICBbJ2dwdF9uZW8nLCBHUFROZW9Nb2RlbF0sXG4gICAgWydjb2RlZ2VuJywgQ29kZUdlbk1vZGVsXSxcbl0pO1xuXG5jb25zdCBNT0RFTF9GT1JfU0VRVUVOQ0VfQ0xBU1NJRklDQVRJT05fTUFQUElOR19OQU1FUyA9IG5ldyBNYXAoW1xuICAgIFsnYmVydCcsIEJlcnRGb3JTZXF1ZW5jZUNsYXNzaWZpY2F0aW9uXSxcbiAgICBbJ2FsYmVydCcsIEFsYmVydEZvclNlcXVlbmNlQ2xhc3NpZmljYXRpb25dLFxuICAgIFsnZGlzdGlsYmVydCcsIERpc3RpbEJlcnRGb3JTZXF1ZW5jZUNsYXNzaWZpY2F0aW9uXSxcbiAgICBbJ3JvYmVydGEnLCBSb2JlcnRhRm9yU2VxdWVuY2VDbGFzc2lmaWNhdGlvbl0sXG4gICAgWyd4bG0tcm9iZXJ0YScsIFhMTVJvYmVydGFGb3JTZXF1ZW5jZUNsYXNzaWZpY2F0aW9uXSxcbiAgICBbJ2JhcnQnLCBCYXJ0Rm9yU2VxdWVuY2VDbGFzc2lmaWNhdGlvbl0sXG4gICAgWydtb2JpbGViZXJ0JywgTW9iaWxlQmVydEZvclNlcXVlbmNlQ2xhc3NpZmljYXRpb25dLFxuICAgIFsnc3F1ZWV6ZWJlcnQnLCBTcXVlZXplQmVydEZvclNlcXVlbmNlQ2xhc3NpZmljYXRpb25dLFxuXSk7XG5cbmNvbnN0IE1PREVMX0ZPUl9UT0tFTl9DTEFTU0lGSUNBVElPTl9NQVBQSU5HX05BTUVTID0gbmV3IE1hcChbXG4gICAgWydiZXJ0JywgQmVydEZvclRva2VuQ2xhc3NpZmljYXRpb25dLFxuICAgIFsnZGlzdGlsYmVydCcsIERpc3RpbEJlcnRGb3JUb2tlbkNsYXNzaWZpY2F0aW9uXSxcbiAgICBbJ3JvYmVydGEnLCBSb2JlcnRhRm9yVG9rZW5DbGFzc2lmaWNhdGlvbl0sXG4gICAgWyd4bG0tcm9iZXJ0YScsIFhMTVJvYmVydGFGb3JUb2tlbkNsYXNzaWZpY2F0aW9uXSxcbl0pO1xuXG5jb25zdCBNT0RFTF9GT1JfU0VRXzJfU0VRX01BUFBJTkdfTkFNRVMgPSBuZXcgTWFwKFtcbiAgICBbJ3Q1JywgVDVGb3JDb25kaXRpb25hbEdlbmVyYXRpb25dLFxuICAgIFsnbXQ1JywgTVQ1Rm9yQ29uZGl0aW9uYWxHZW5lcmF0aW9uXSxcbiAgICBbJ2JhcnQnLCBCYXJ0Rm9yQ29uZGl0aW9uYWxHZW5lcmF0aW9uXSxcbiAgICBbJ3doaXNwZXInLCBXaGlzcGVyRm9yQ29uZGl0aW9uYWxHZW5lcmF0aW9uXSxcbiAgICBbJ21hcmlhbicsIE1hcmlhbk1UTW9kZWxdLFxuICAgIFsnbTJtXzEwMCcsIE0yTTEwMEZvckNvbmRpdGlvbmFsR2VuZXJhdGlvbl0sXG5dKTtcblxuY29uc3QgTU9ERUxfV0lUSF9MTV9IRUFEX01BUFBJTkdfTkFNRVMgPSBuZXcgTWFwKFtcbiAgICBbJ2dwdDInLCBHUFQyTE1IZWFkTW9kZWxdLFxuICAgIFsnZ3B0X25lbycsIEdQVE5lb0ZvckNhdXNhbExNXSxcbiAgICBbJ2NvZGVnZW4nLCBDb2RlR2VuRm9yQ2F1c2FsTE1dLFxuXSk7XG5cbmNvbnN0IE1PREVMX0ZPUl9NQVNLRURfTE1fTUFQUElOR19OQU1FUyA9IG5ldyBNYXAoW1xuICAgIFsnYmVydCcsIEJlcnRGb3JNYXNrZWRMTV0sXG4gICAgWydhbGJlcnQnLCBBbGJlcnRGb3JNYXNrZWRMTV0sXG4gICAgWydkaXN0aWxiZXJ0JywgRGlzdGlsQmVydEZvck1hc2tlZExNXSxcbiAgICBbJ3JvYmVydGEnLCBSb2JlcnRhRm9yTWFza2VkTE1dLFxuICAgIFsneGxtLXJvYmVydGEnLCBYTE1Sb2JlcnRhRm9yTWFza2VkTE1dLFxuICAgIFsnbW9iaWxlYmVydCcsIE1vYmlsZUJlcnRGb3JNYXNrZWRMTV0sXG4gICAgWydzcXVlZXplYmVydCcsIFNxdWVlemVCZXJ0Rm9yTWFza2VkTE1dLFxuXSk7XG5cbmNvbnN0IE1PREVMX0ZPUl9RVUVTVElPTl9BTlNXRVJJTkdfTUFQUElOR19OQU1FUyA9IG5ldyBNYXAoW1xuICAgIFsnYmVydCcsIEJlcnRGb3JRdWVzdGlvbkFuc3dlcmluZ10sXG4gICAgWydhbGJlcnQnLCBBbGJlcnRGb3JRdWVzdGlvbkFuc3dlcmluZ10sXG4gICAgWydkaXN0aWxiZXJ0JywgRGlzdGlsQmVydEZvclF1ZXN0aW9uQW5zd2VyaW5nXSxcbiAgICBbJ3JvYmVydGEnLCBSb2JlcnRhRm9yUXVlc3Rpb25BbnN3ZXJpbmddLFxuICAgIFsneGxtLXJvYmVydGEnLCBYTE1Sb2JlcnRhRm9yUXVlc3Rpb25BbnN3ZXJpbmddLFxuICAgIFsnbW9iaWxlYmVydCcsIE1vYmlsZUJlcnRGb3JRdWVzdGlvbkFuc3dlcmluZ10sXG4gICAgWydzcXVlZXplYmVydCcsIFNxdWVlemVCZXJ0Rm9yUXVlc3Rpb25BbnN3ZXJpbmddLFxuXSk7XG5cbmNvbnN0IE1PREVMX0ZPUl9WSVNJT05fMl9TRVFfTUFQUElOR19OQU1FUyA9IG5ldyBNYXAoW1xuICAgIFsndmlzaW9uLWVuY29kZXItZGVjb2RlcicsIFZpc2lvbkVuY29kZXJEZWNvZGVyTW9kZWxdLFxuXSk7XG5cbmNvbnN0IE1PREVMX0ZPUl9JTUFHRV9DTEFTU0lGSUNBVElPTl9NQVBQSU5HX05BTUVTID0gbmV3IE1hcChbXG4gICAgWyd2aXQnLCBWaVRGb3JJbWFnZUNsYXNzaWZpY2F0aW9uXSxcbiAgICBbJ21vYmlsZXZpdCcsIE1vYmlsZVZpVEZvckltYWdlQ2xhc3NpZmljYXRpb25dLFxuXSk7XG5cbmNvbnN0IE1PREVMX0ZPUl9PQkpFQ1RfREVURUNUSU9OX01BUFBJTkdfTkFNRVMgPSBuZXcgTWFwKFtcbiAgICBbJ2RldHInLCBEZXRyRm9yT2JqZWN0RGV0ZWN0aW9uXSxcbl0pO1xuXG5jb25zdCBNT0RFTF9GT1JfSU1BR0VfU0VHTUVOVEFUSU9OX01BUFBJTkdfTkFNRVMgPSBuZXcgTWFwKFtcbiAgICBbJ2RldHInLCBEZXRyRm9yU2VnbWVudGF0aW9uXSxcbl0pO1xuXG5jb25zdCBNT0RFTF9GT1JfTUFTS19HRU5FUkFUSU9OX01BUFBJTkdfTkFNRVMgPSBuZXcgTWFwKFtcbiAgICBbJ3NhbScsIFNhbU1vZGVsXSxcbl0pO1xuXG5jb25zdCBNT0RFTF9DTEFTU19UWVBFX01BUFBJTkcgPSBbXG4gICAgW01PREVMX01BUFBJTkdfTkFNRVNfRU5DT0RFUl9PTkxZLCBFbmNvZGVyT25seU1vZGVsVHlwZV0sXG4gICAgW01PREVMX01BUFBJTkdfTkFNRVNfRU5DT0RFUl9ERUNPREVSLCBFbmNvZGVyRGVjb2Rlck1vZGVsVHlwZV0sXG4gICAgW01PREVMX01BUFBJTkdfTkFNRVNfREVDT0RFUl9PTkxZLCBEZWNvZGVyT25seU1vZGVsVHlwZV0sXG4gICAgW01PREVMX0ZPUl9TRVFVRU5DRV9DTEFTU0lGSUNBVElPTl9NQVBQSU5HX05BTUVTLCBFbmNvZGVyT25seU1vZGVsVHlwZV0sXG4gICAgW01PREVMX0ZPUl9UT0tFTl9DTEFTU0lGSUNBVElPTl9NQVBQSU5HX05BTUVTLCBFbmNvZGVyT25seU1vZGVsVHlwZV0sXG4gICAgW01PREVMX0ZPUl9TRVFfMl9TRVFfTUFQUElOR19OQU1FUywgU2VxMlNlcU1vZGVsVHlwZV0sXG4gICAgW01PREVMX1dJVEhfTE1fSEVBRF9NQVBQSU5HX05BTUVTLCBEZWNvZGVyT25seU1vZGVsVHlwZV0sXG4gICAgW01PREVMX0ZPUl9NQVNLRURfTE1fTUFQUElOR19OQU1FUywgRW5jb2Rlck9ubHlNb2RlbFR5cGVdLFxuICAgIFtNT0RFTF9GT1JfUVVFU1RJT05fQU5TV0VSSU5HX01BUFBJTkdfTkFNRVMsIEVuY29kZXJPbmx5TW9kZWxUeXBlXSxcbiAgICBbTU9ERUxfRk9SX1ZJU0lPTl8yX1NFUV9NQVBQSU5HX05BTUVTLCBFbmNvZGVyRGVjb2Rlck1vZGVsVHlwZV0sXG4gICAgW01PREVMX0ZPUl9JTUFHRV9DTEFTU0lGSUNBVElPTl9NQVBQSU5HX05BTUVTLCBFbmNvZGVyT25seU1vZGVsVHlwZV0sXG4gICAgW01PREVMX0ZPUl9JTUFHRV9TRUdNRU5UQVRJT05fTUFQUElOR19OQU1FUywgRW5jb2Rlck9ubHlNb2RlbFR5cGVdLFxuICAgIFtNT0RFTF9GT1JfT0JKRUNUX0RFVEVDVElPTl9NQVBQSU5HX05BTUVTLCBFbmNvZGVyT25seU1vZGVsVHlwZV0sXG4gICAgW01PREVMX0ZPUl9NQVNLX0dFTkVSQVRJT05fTUFQUElOR19OQU1FUywgRW5jb2Rlck9ubHlNb2RlbFR5cGVdLFxuXTtcblxuZm9yIChsZXQgW21hcHBpbmdzLCB0eXBlXSBvZiBNT0RFTF9DTEFTU19UWVBFX01BUFBJTkcpIHtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgZm9yIChsZXQgW25hbWUsIG1vZGVsXSBvZiBtYXBwaW5ncy5lbnRyaWVzKCkpIHtcbiAgICAgICAgTU9ERUxfVFlQRV9NQVBQSU5HLnNldChtb2RlbC5uYW1lLCB0eXBlKTtcbiAgICAgICAgTU9ERUxfQ0xBU1NfTUFQUElORy5zZXQobW9kZWwubmFtZSwgbmFtZSk7XG4gICAgfVxufVxuXG4vKipcbiAqIEhlbHBlciBjbGFzcyB3aGljaCBpcyB1c2VkIHRvIGluc3RhbnRpYXRlIHByZXRyYWluZWQgbW9kZWxzIHdpdGggdGhlIGBmcm9tX3ByZXRyYWluZWRgIGZ1bmN0aW9uLlxuICogVGhlIGNob3NlbiBtb2RlbCBjbGFzcyBpcyBkZXRlcm1pbmVkIGJ5IHRoZSB0eXBlIHNwZWNpZmllZCBpbiB0aGUgbW9kZWwgY29uZmlnLlxuICogXG4gKiBAZXhhbXBsZVxuICogbGV0IG1vZGVsID0gYXdhaXQgQXV0b01vZGVsLmZyb21fcHJldHJhaW5lZCgnYmVydC1iYXNlLXVuY2FzZWQnKTtcbiAqL1xuZXhwb3J0IGNsYXNzIEF1dG9Nb2RlbCBleHRlbmRzIFByZXRyYWluZWRNaXhpbiB7XG4gICAgc3RhdGljIE1PREVMX0NMQVNTX01BUFBJTkdTID0gW01PREVMX01BUFBJTkdfTkFNRVNfRU5DT0RFUl9PTkxZLCBNT0RFTF9NQVBQSU5HX05BTUVTX0VOQ09ERVJfREVDT0RFUiwgTU9ERUxfTUFQUElOR19OQU1FU19ERUNPREVSX09OTFldO1xuICAgIHN0YXRpYyBCQVNFX0lGX0ZBSUwgPSB0cnVlO1xufVxuXG4vKipcbiAqIEhlbHBlciBjbGFzcyB3aGljaCBpcyB1c2VkIHRvIGluc3RhbnRpYXRlIHByZXRyYWluZWQgc2VxdWVuY2UgY2xhc3NpZmljYXRpb24gbW9kZWxzIHdpdGggdGhlIGBmcm9tX3ByZXRyYWluZWRgIGZ1bmN0aW9uLlxuICogVGhlIGNob3NlbiBtb2RlbCBjbGFzcyBpcyBkZXRlcm1pbmVkIGJ5IHRoZSB0eXBlIHNwZWNpZmllZCBpbiB0aGUgbW9kZWwgY29uZmlnLlxuICogXG4gKiBAZXhhbXBsZVxuICogbGV0IG1vZGVsID0gYXdhaXQgQXV0b01vZGVsRm9yU2VxdWVuY2VDbGFzc2lmaWNhdGlvbi5mcm9tX3ByZXRyYWluZWQoJ2Rpc3RpbGJlcnQtYmFzZS11bmNhc2VkLWZpbmV0dW5lZC1zc3QtMi1lbmdsaXNoJyk7XG4gKi9cbmV4cG9ydCBjbGFzcyBBdXRvTW9kZWxGb3JTZXF1ZW5jZUNsYXNzaWZpY2F0aW9uIGV4dGVuZHMgUHJldHJhaW5lZE1peGluIHtcbiAgICBzdGF0aWMgTU9ERUxfQ0xBU1NfTUFQUElOR1MgPSBbTU9ERUxfRk9SX1NFUVVFTkNFX0NMQVNTSUZJQ0FUSU9OX01BUFBJTkdfTkFNRVNdO1xufVxuXG4vKipcbiAqIEhlbHBlciBjbGFzcyB3aGljaCBpcyB1c2VkIHRvIGluc3RhbnRpYXRlIHByZXRyYWluZWQgdG9rZW4gY2xhc3NpZmljYXRpb24gbW9kZWxzIHdpdGggdGhlIGBmcm9tX3ByZXRyYWluZWRgIGZ1bmN0aW9uLlxuICogVGhlIGNob3NlbiBtb2RlbCBjbGFzcyBpcyBkZXRlcm1pbmVkIGJ5IHRoZSB0eXBlIHNwZWNpZmllZCBpbiB0aGUgbW9kZWwgY29uZmlnLlxuICogXG4gKiBAZXhhbXBsZVxuICogbGV0IG1vZGVsID0gYXdhaXQgQXV0b01vZGVsRm9yVG9rZW5DbGFzc2lmaWNhdGlvbi5mcm9tX3ByZXRyYWluZWQoJ0Rhdmxhbi9kaXN0aWxiZXJ0LWJhc2UtbXVsdGlsaW5ndWFsLWNhc2VkLW5lci1ocmwnKTtcbiAqL1xuZXhwb3J0IGNsYXNzIEF1dG9Nb2RlbEZvclRva2VuQ2xhc3NpZmljYXRpb24gZXh0ZW5kcyBQcmV0cmFpbmVkTWl4aW4ge1xuICAgIHN0YXRpYyBNT0RFTF9DTEFTU19NQVBQSU5HUyA9IFtNT0RFTF9GT1JfVE9LRU5fQ0xBU1NJRklDQVRJT05fTUFQUElOR19OQU1FU107XG59XG5cbi8qKlxuICogSGVscGVyIGNsYXNzIHdoaWNoIGlzIHVzZWQgdG8gaW5zdGFudGlhdGUgcHJldHJhaW5lZCBzZXF1ZW5jZS10by1zZXF1ZW5jZSBtb2RlbHMgd2l0aCB0aGUgYGZyb21fcHJldHJhaW5lZGAgZnVuY3Rpb24uXG4gKiBUaGUgY2hvc2VuIG1vZGVsIGNsYXNzIGlzIGRldGVybWluZWQgYnkgdGhlIHR5cGUgc3BlY2lmaWVkIGluIHRoZSBtb2RlbCBjb25maWcuXG4gKiBcbiAqIEBleGFtcGxlXG4gKiBsZXQgbW9kZWwgPSBhd2FpdCBBdXRvTW9kZWxGb3JTZXEyU2VxTE0uZnJvbV9wcmV0cmFpbmVkKCd0NS1zbWFsbCcpO1xuICovXG5leHBvcnQgY2xhc3MgQXV0b01vZGVsRm9yU2VxMlNlcUxNIGV4dGVuZHMgUHJldHJhaW5lZE1peGluIHtcbiAgICBzdGF0aWMgTU9ERUxfQ0xBU1NfTUFQUElOR1MgPSBbTU9ERUxfRk9SX1NFUV8yX1NFUV9NQVBQSU5HX05BTUVTXTtcbn1cblxuLyoqXG4gKiBIZWxwZXIgY2xhc3Mgd2hpY2ggaXMgdXNlZCB0byBpbnN0YW50aWF0ZSBwcmV0cmFpbmVkIGNhdXNhbCBsYW5ndWFnZSBtb2RlbHMgd2l0aCB0aGUgYGZyb21fcHJldHJhaW5lZGAgZnVuY3Rpb24uXG4gKiBUaGUgY2hvc2VuIG1vZGVsIGNsYXNzIGlzIGRldGVybWluZWQgYnkgdGhlIHR5cGUgc3BlY2lmaWVkIGluIHRoZSBtb2RlbCBjb25maWcuXG4gKiBcbiAqIEBleGFtcGxlXG4gKiBsZXQgbW9kZWwgPSBhd2FpdCBBdXRvTW9kZWxGb3JDYXVzYWxMTS5mcm9tX3ByZXRyYWluZWQoJ2dwdDInKTtcbiAqL1xuZXhwb3J0IGNsYXNzIEF1dG9Nb2RlbEZvckNhdXNhbExNIGV4dGVuZHMgUHJldHJhaW5lZE1peGluIHtcbiAgICBzdGF0aWMgTU9ERUxfQ0xBU1NfTUFQUElOR1MgPSBbTU9ERUxfV0lUSF9MTV9IRUFEX01BUFBJTkdfTkFNRVNdO1xufVxuXG4vKipcbiAqIEhlbHBlciBjbGFzcyB3aGljaCBpcyB1c2VkIHRvIGluc3RhbnRpYXRlIHByZXRyYWluZWQgbWFza2VkIGxhbmd1YWdlIG1vZGVscyB3aXRoIHRoZSBgZnJvbV9wcmV0cmFpbmVkYCBmdW5jdGlvbi5cbiAqIFRoZSBjaG9zZW4gbW9kZWwgY2xhc3MgaXMgZGV0ZXJtaW5lZCBieSB0aGUgdHlwZSBzcGVjaWZpZWQgaW4gdGhlIG1vZGVsIGNvbmZpZy5cbiAqIFxuICogQGV4YW1wbGVcbiAqIGxldCBtb2RlbCA9IGF3YWl0IEF1dG9Nb2RlbEZvck1hc2tlZExNLmZyb21fcHJldHJhaW5lZCgnYmVydC1iYXNlLXVuY2FzZWQnKTtcbiAqL1xuZXhwb3J0IGNsYXNzIEF1dG9Nb2RlbEZvck1hc2tlZExNIGV4dGVuZHMgUHJldHJhaW5lZE1peGluIHtcbiAgICBzdGF0aWMgTU9ERUxfQ0xBU1NfTUFQUElOR1MgPSBbTU9ERUxfRk9SX01BU0tFRF9MTV9NQVBQSU5HX05BTUVTXTtcbn1cblxuLyoqXG4gKiBIZWxwZXIgY2xhc3Mgd2hpY2ggaXMgdXNlZCB0byBpbnN0YW50aWF0ZSBwcmV0cmFpbmVkIHF1ZXN0aW9uIGFuc3dlcmluZyBtb2RlbHMgd2l0aCB0aGUgYGZyb21fcHJldHJhaW5lZGAgZnVuY3Rpb24uXG4gKiBUaGUgY2hvc2VuIG1vZGVsIGNsYXNzIGlzIGRldGVybWluZWQgYnkgdGhlIHR5cGUgc3BlY2lmaWVkIGluIHRoZSBtb2RlbCBjb25maWcuXG4gKiBcbiAqIEBleGFtcGxlXG4gKiBsZXQgbW9kZWwgPSBhd2FpdCBBdXRvTW9kZWxGb3JRdWVzdGlvbkFuc3dlcmluZy5mcm9tX3ByZXRyYWluZWQoJ2Rpc3RpbGJlcnQtYmFzZS1jYXNlZC1kaXN0aWxsZWQtc3F1YWQnKTtcbiAqL1xuZXhwb3J0IGNsYXNzIEF1dG9Nb2RlbEZvclF1ZXN0aW9uQW5zd2VyaW5nIGV4dGVuZHMgUHJldHJhaW5lZE1peGluIHtcbiAgICBzdGF0aWMgTU9ERUxfQ0xBU1NfTUFQUElOR1MgPSBbTU9ERUxfRk9SX1FVRVNUSU9OX0FOU1dFUklOR19NQVBQSU5HX05BTUVTXTtcbn1cblxuLyoqXG4gKiBIZWxwZXIgY2xhc3Mgd2hpY2ggaXMgdXNlZCB0byBpbnN0YW50aWF0ZSBwcmV0cmFpbmVkIHZpc2lvbi10by1zZXF1ZW5jZSBtb2RlbHMgd2l0aCB0aGUgYGZyb21fcHJldHJhaW5lZGAgZnVuY3Rpb24uXG4gKiBUaGUgY2hvc2VuIG1vZGVsIGNsYXNzIGlzIGRldGVybWluZWQgYnkgdGhlIHR5cGUgc3BlY2lmaWVkIGluIHRoZSBtb2RlbCBjb25maWcuXG4gKiBcbiAqIEBleGFtcGxlXG4gKiBsZXQgbW9kZWwgPSBhd2FpdCBBdXRvTW9kZWxGb3JWaXNpb24yU2VxLmZyb21fcHJldHJhaW5lZCgnbmxwY29ubmVjdC92aXQtZ3B0Mi1pbWFnZS1jYXB0aW9uaW5nJyk7XG4gKi9cbmV4cG9ydCBjbGFzcyBBdXRvTW9kZWxGb3JWaXNpb24yU2VxIGV4dGVuZHMgUHJldHJhaW5lZE1peGluIHtcbiAgICBzdGF0aWMgTU9ERUxfQ0xBU1NfTUFQUElOR1MgPSBbTU9ERUxfRk9SX1ZJU0lPTl8yX1NFUV9NQVBQSU5HX05BTUVTXTtcbn1cblxuLyoqXG4gKiBIZWxwZXIgY2xhc3Mgd2hpY2ggaXMgdXNlZCB0byBpbnN0YW50aWF0ZSBwcmV0cmFpbmVkIGltYWdlIGNsYXNzaWZpY2F0aW9uIG1vZGVscyB3aXRoIHRoZSBgZnJvbV9wcmV0cmFpbmVkYCBmdW5jdGlvbi5cbiAqIFRoZSBjaG9zZW4gbW9kZWwgY2xhc3MgaXMgZGV0ZXJtaW5lZCBieSB0aGUgdHlwZSBzcGVjaWZpZWQgaW4gdGhlIG1vZGVsIGNvbmZpZy5cbiAqIFxuICogQGV4YW1wbGVcbiAqIGxldCBtb2RlbCA9IGF3YWl0IEF1dG9Nb2RlbEZvckltYWdlQ2xhc3NpZmljYXRpb24uZnJvbV9wcmV0cmFpbmVkKCdnb29nbGUvdml0LWJhc2UtcGF0Y2gxNi0yMjQnKTtcbiAqL1xuZXhwb3J0IGNsYXNzIEF1dG9Nb2RlbEZvckltYWdlQ2xhc3NpZmljYXRpb24gZXh0ZW5kcyBQcmV0cmFpbmVkTWl4aW4ge1xuICAgIHN0YXRpYyBNT0RFTF9DTEFTU19NQVBQSU5HUyA9IFtNT0RFTF9GT1JfSU1BR0VfQ0xBU1NJRklDQVRJT05fTUFQUElOR19OQU1FU107XG59XG5cbi8qKlxuICogSGVscGVyIGNsYXNzIHdoaWNoIGlzIHVzZWQgdG8gaW5zdGFudGlhdGUgcHJldHJhaW5lZCBpbWFnZSBzZWdtZW50YXRpb24gbW9kZWxzIHdpdGggdGhlIGBmcm9tX3ByZXRyYWluZWRgIGZ1bmN0aW9uLlxuICogVGhlIGNob3NlbiBtb2RlbCBjbGFzcyBpcyBkZXRlcm1pbmVkIGJ5IHRoZSB0eXBlIHNwZWNpZmllZCBpbiB0aGUgbW9kZWwgY29uZmlnLlxuICogXG4gKiBAZXhhbXBsZVxuICogbGV0IG1vZGVsID0gYXdhaXQgQXV0b01vZGVsRm9ySW1hZ2VTZWdtZW50YXRpb24uZnJvbV9wcmV0cmFpbmVkKCdmYWNlYm9vay9kZXRyLXJlc25ldC01MC1wYW5vcHRpYycpO1xuICovXG5leHBvcnQgY2xhc3MgQXV0b01vZGVsRm9ySW1hZ2VTZWdtZW50YXRpb24gZXh0ZW5kcyBQcmV0cmFpbmVkTWl4aW4ge1xuICAgIHN0YXRpYyBNT0RFTF9DTEFTU19NQVBQSU5HUyA9IFtNT0RFTF9GT1JfSU1BR0VfU0VHTUVOVEFUSU9OX01BUFBJTkdfTkFNRVNdO1xufVxuXG4vKipcbiAqIEhlbHBlciBjbGFzcyB3aGljaCBpcyB1c2VkIHRvIGluc3RhbnRpYXRlIHByZXRyYWluZWQgb2JqZWN0IGRldGVjdGlvbiBtb2RlbHMgd2l0aCB0aGUgYGZyb21fcHJldHJhaW5lZGAgZnVuY3Rpb24uXG4gKiBUaGUgY2hvc2VuIG1vZGVsIGNsYXNzIGlzIGRldGVybWluZWQgYnkgdGhlIHR5cGUgc3BlY2lmaWVkIGluIHRoZSBtb2RlbCBjb25maWcuXG4gKiBcbiAqIEBleGFtcGxlXG4gKiBsZXQgbW9kZWwgPSBhd2FpdCBBdXRvTW9kZWxGb3JPYmplY3REZXRlY3Rpb24uZnJvbV9wcmV0cmFpbmVkKCdmYWNlYm9vay9kZXRyLXJlc25ldC01MCcpO1xuICovXG5leHBvcnQgY2xhc3MgQXV0b01vZGVsRm9yT2JqZWN0RGV0ZWN0aW9uIGV4dGVuZHMgUHJldHJhaW5lZE1peGluIHtcbiAgICBzdGF0aWMgTU9ERUxfQ0xBU1NfTUFQUElOR1MgPSBbTU9ERUxfRk9SX09CSkVDVF9ERVRFQ1RJT05fTUFQUElOR19OQU1FU107XG59XG5cbi8qKlxuICogSGVscGVyIGNsYXNzIHdoaWNoIGlzIHVzZWQgdG8gaW5zdGFudGlhdGUgcHJldHJhaW5lZCBvYmplY3QgZGV0ZWN0aW9uIG1vZGVscyB3aXRoIHRoZSBgZnJvbV9wcmV0cmFpbmVkYCBmdW5jdGlvbi5cbiAqIFRoZSBjaG9zZW4gbW9kZWwgY2xhc3MgaXMgZGV0ZXJtaW5lZCBieSB0aGUgdHlwZSBzcGVjaWZpZWQgaW4gdGhlIG1vZGVsIGNvbmZpZy5cbiAqIFxuICogQGV4YW1wbGVcbiAqIGxldCBtb2RlbCA9IGF3YWl0IEF1dG9Nb2RlbEZvck1hc2tHZW5lcmF0aW9uLmZyb21fcHJldHJhaW5lZCgnWGVub3ZhL3NhbS12aXQtYmFzZScpO1xuICovXG5leHBvcnQgY2xhc3MgQXV0b01vZGVsRm9yTWFza0dlbmVyYXRpb24gZXh0ZW5kcyBQcmV0cmFpbmVkTWl4aW4ge1xuICAgIHN0YXRpYyBNT0RFTF9DTEFTU19NQVBQSU5HUyA9IFtNT0RFTF9GT1JfTUFTS19HRU5FUkFUSU9OX01BUFBJTkdfTkFNRVNdO1xufVxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbmV4cG9ydCBjbGFzcyBTZXEyU2VxTE1PdXRwdXQgZXh0ZW5kcyBNb2RlbE91dHB1dCB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG91dHB1dCBUaGUgb3V0cHV0IG9mIHRoZSBtb2RlbC5cbiAgICAgKiBAcGFyYW0ge1RlbnNvcn0gb3V0cHV0LmxvZ2l0cyBUaGUgb3V0cHV0IGxvZ2l0cyBvZiB0aGUgbW9kZWwuXG4gICAgICogQHBhcmFtIHtUZW5zb3J9IG91dHB1dC5wYXN0X2tleV92YWx1ZXMgQW4gdGVuc29yIG9mIGtleS92YWx1ZSBwYWlycyB0aGF0IHJlcHJlc2VudCB0aGUgcHJldmlvdXMgc3RhdGUgb2YgdGhlIG1vZGVsLlxuICAgICAqIEBwYXJhbSB7VGVuc29yfSBvdXRwdXQuZW5jb2Rlcl9vdXRwdXRzIFRoZSBvdXRwdXQgb2YgdGhlIGVuY29kZXIgaW4gYSBzZXF1ZW5jZS10by1zZXF1ZW5jZSBtb2RlbC5cbiAgICAgKiBAcGFyYW0ge1RlbnNvcn0gW291dHB1dC5kZWNvZGVyX2F0dGVudGlvbnNdIEF0dGVudGlvbnMgd2VpZ2h0cyBvZiB0aGUgZGVjb2RlciwgYWZ0ZXIgdGhlIGF0dGVudGlvbiBzb2Z0bWF4LCB1c2VkIHRvIGNvbXB1dGUgdGhlIHdlaWdodGVkIGF2ZXJhZ2UgaW4gdGhlIHNlbGYtYXR0ZW50aW9uIGhlYWRzLlxuICAgICAqIEBwYXJhbSB7VGVuc29yfSBbb3V0cHV0LmNyb3NzX2F0dGVudGlvbnNdIEF0dGVudGlvbnMgd2VpZ2h0cyBvZiB0aGUgZGVjb2RlcidzIGNyb3NzLWF0dGVudGlvbiBsYXllciwgYWZ0ZXIgdGhlIGF0dGVudGlvbiBzb2Z0bWF4LCB1c2VkIHRvIGNvbXB1dGUgdGhlIHdlaWdodGVkIGF2ZXJhZ2UgaW4gdGhlIGNyb3NzLWF0dGVudGlvbiBoZWFkcy5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih7IGxvZ2l0cywgcGFzdF9rZXlfdmFsdWVzLCBlbmNvZGVyX291dHB1dHMsIGRlY29kZXJfYXR0ZW50aW9ucyA9IG51bGwsIGNyb3NzX2F0dGVudGlvbnMgPSBudWxsIH0pIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5sb2dpdHMgPSBsb2dpdHM7XG4gICAgICAgIHRoaXMucGFzdF9rZXlfdmFsdWVzID0gcGFzdF9rZXlfdmFsdWVzO1xuICAgICAgICB0aGlzLmVuY29kZXJfb3V0cHV0cyA9IGVuY29kZXJfb3V0cHV0cztcbiAgICAgICAgdGhpcy5kZWNvZGVyX2F0dGVudGlvbnMgPSBkZWNvZGVyX2F0dGVudGlvbnM7XG4gICAgICAgIHRoaXMuY3Jvc3NfYXR0ZW50aW9ucyA9IGNyb3NzX2F0dGVudGlvbnM7XG4gICAgfVxufVxuXG4vKipcbiAqIEJhc2UgY2xhc3MgZm9yIG91dHB1dHMgb2Ygc2VudGVuY2UgY2xhc3NpZmljYXRpb24gbW9kZWxzLlxuICovXG5leHBvcnQgY2xhc3MgU2VxdWVuY2VDbGFzc2lmaWVyT3V0cHV0IGV4dGVuZHMgTW9kZWxPdXRwdXQge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvdXRwdXQgVGhlIG91dHB1dCBvZiB0aGUgbW9kZWwuXG4gICAgICogQHBhcmFtIHtUZW5zb3J9IG91dHB1dC5sb2dpdHMgY2xhc3NpZmljYXRpb24gKG9yIHJlZ3Jlc3Npb24gaWYgY29uZmlnLm51bV9sYWJlbHM9PTEpIHNjb3JlcyAoYmVmb3JlIFNvZnRNYXgpLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHsgbG9naXRzIH0pIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5sb2dpdHMgPSBsb2dpdHM7XG4gICAgfVxufVxuXG4vKipcbiAqIEJhc2UgY2xhc3MgZm9yIG91dHB1dHMgb2YgdG9rZW4gY2xhc3NpZmljYXRpb24gbW9kZWxzLlxuICovXG5leHBvcnQgY2xhc3MgVG9rZW5DbGFzc2lmaWVyT3V0cHV0IGV4dGVuZHMgTW9kZWxPdXRwdXQge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvdXRwdXQgVGhlIG91dHB1dCBvZiB0aGUgbW9kZWwuXG4gICAgICogQHBhcmFtIHtUZW5zb3J9IG91dHB1dC5sb2dpdHMgQ2xhc3NpZmljYXRpb24gc2NvcmVzIChiZWZvcmUgU29mdE1heCkuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoeyBsb2dpdHMgfSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmxvZ2l0cyA9IGxvZ2l0cztcbiAgICB9XG59XG5cbi8qKlxuICogQmFzZSBjbGFzcyBmb3IgbWFza2VkIGxhbmd1YWdlIG1vZGVscyBvdXRwdXRzLlxuICovXG5leHBvcnQgY2xhc3MgTWFza2VkTE1PdXRwdXQgZXh0ZW5kcyBNb2RlbE91dHB1dCB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG91dHB1dCBUaGUgb3V0cHV0IG9mIHRoZSBtb2RlbC5cbiAgICAgKiBAcGFyYW0ge1RlbnNvcn0gb3V0cHV0LmxvZ2l0cyBQcmVkaWN0aW9uIHNjb3JlcyBvZiB0aGUgbGFuZ3VhZ2UgbW9kZWxpbmcgaGVhZCAoc2NvcmVzIGZvciBlYWNoIHZvY2FidWxhcnkgdG9rZW4gYmVmb3JlIFNvZnRNYXgpLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHsgbG9naXRzIH0pIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5sb2dpdHMgPSBsb2dpdHM7XG4gICAgfVxufVxuXG4vKipcbiAqIEJhc2UgY2xhc3MgZm9yIG91dHB1dHMgb2YgcXVlc3Rpb24gYW5zd2VyaW5nIG1vZGVscy5cbiAqL1xuZXhwb3J0IGNsYXNzIFF1ZXN0aW9uQW5zd2VyaW5nTW9kZWxPdXRwdXQgZXh0ZW5kcyBNb2RlbE91dHB1dCB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG91dHB1dCBUaGUgb3V0cHV0IG9mIHRoZSBtb2RlbC5cbiAgICAgKiBAcGFyYW0ge1RlbnNvcn0gb3V0cHV0LnN0YXJ0X2xvZ2l0cyBTcGFuLXN0YXJ0IHNjb3JlcyAoYmVmb3JlIFNvZnRNYXgpLlxuICAgICAqIEBwYXJhbSB7VGVuc29yfSBvdXRwdXQuZW5kX2xvZ2l0cyBTcGFuLWVuZCBzY29yZXMgKGJlZm9yZSBTb2Z0TWF4KS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih7IHN0YXJ0X2xvZ2l0cywgZW5kX2xvZ2l0cyB9KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuc3RhcnRfbG9naXRzID0gc3RhcnRfbG9naXRzO1xuICAgICAgICB0aGlzLmVuZF9sb2dpdHMgPSBlbmRfbG9naXRzO1xuICAgIH1cbn1cblxuXG4vKipcbiAqIEJhc2UgY2xhc3MgZm9yIGNhdXNhbCBsYW5ndWFnZSBtb2RlbCAob3IgYXV0b3JlZ3Jlc3NpdmUpIG91dHB1dHMuXG4gKi9cbmV4cG9ydCBjbGFzcyBDYXVzYWxMTU91dHB1dFdpdGhQYXN0IGV4dGVuZHMgTW9kZWxPdXRwdXQge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvdXRwdXQgVGhlIG91dHB1dCBvZiB0aGUgbW9kZWwuXG4gICAgICogQHBhcmFtIHtUZW5zb3J9IG91dHB1dC5sb2dpdHMgUHJlZGljdGlvbiBzY29yZXMgb2YgdGhlIGxhbmd1YWdlIG1vZGVsaW5nIGhlYWQgKHNjb3JlcyBmb3IgZWFjaCB2b2NhYnVsYXJ5IHRva2VuIGJlZm9yZSBzb2Z0bWF4KS5cbiAgICAgKiBAcGFyYW0ge1RlbnNvcn0gb3V0cHV0LnBhc3Rfa2V5X3ZhbHVlcyBDb250YWlucyBwcmUtY29tcHV0ZWQgaGlkZGVuLXN0YXRlcyAoa2V5IGFuZCB2YWx1ZXMgaW4gdGhlIHNlbGYtYXR0ZW50aW9uIGJsb2NrcylcbiAgICAgKiB0aGF0IGNhbiBiZSB1c2VkIChzZWUgYHBhc3Rfa2V5X3ZhbHVlc2AgaW5wdXQpIHRvIHNwZWVkIHVwIHNlcXVlbnRpYWwgZGVjb2RpbmcuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoeyBsb2dpdHMsIHBhc3Rfa2V5X3ZhbHVlcyB9KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMubG9naXRzID0gbG9naXRzO1xuICAgICAgICB0aGlzLnBhc3Rfa2V5X3ZhbHVlcyA9IHBhc3Rfa2V5X3ZhbHVlcztcbiAgICB9XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@xenova/transformers/src/models.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@xenova/transformers/src/pipelines.js":
/*!************************************************************!*\
  !*** ./node_modules/@xenova/transformers/src/pipelines.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AutomaticSpeechRecognitionPipeline: () => (/* binding */ AutomaticSpeechRecognitionPipeline),\n/* harmony export */   FeatureExtractionPipeline: () => (/* binding */ FeatureExtractionPipeline),\n/* harmony export */   FillMaskPipeline: () => (/* binding */ FillMaskPipeline),\n/* harmony export */   ImageClassificationPipeline: () => (/* binding */ ImageClassificationPipeline),\n/* harmony export */   ImageSegmentationPipeline: () => (/* binding */ ImageSegmentationPipeline),\n/* harmony export */   ImageToTextPipeline: () => (/* binding */ ImageToTextPipeline),\n/* harmony export */   ObjectDetectionPipeline: () => (/* binding */ ObjectDetectionPipeline),\n/* harmony export */   Pipeline: () => (/* binding */ Pipeline),\n/* harmony export */   QuestionAnsweringPipeline: () => (/* binding */ QuestionAnsweringPipeline),\n/* harmony export */   SummarizationPipeline: () => (/* binding */ SummarizationPipeline),\n/* harmony export */   Text2TextGenerationPipeline: () => (/* binding */ Text2TextGenerationPipeline),\n/* harmony export */   TextClassificationPipeline: () => (/* binding */ TextClassificationPipeline),\n/* harmony export */   TextGenerationPipeline: () => (/* binding */ TextGenerationPipeline),\n/* harmony export */   TokenClassificationPipeline: () => (/* binding */ TokenClassificationPipeline),\n/* harmony export */   TranslationPipeline: () => (/* binding */ TranslationPipeline),\n/* harmony export */   ZeroShotClassificationPipeline: () => (/* binding */ ZeroShotClassificationPipeline),\n/* harmony export */   ZeroShotImageClassificationPipeline: () => (/* binding */ ZeroShotImageClassificationPipeline),\n/* harmony export */   pipeline: () => (/* binding */ pipeline)\n/* harmony export */ });\n/* harmony import */ var _tokenizers_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tokenizers.js */ \"(ssr)/./node_modules/@xenova/transformers/src/tokenizers.js\");\n/* harmony import */ var _models_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./models.js */ \"(ssr)/./node_modules/@xenova/transformers/src/models.js\");\n/* harmony import */ var _processors_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./processors.js */ \"(ssr)/./node_modules/@xenova/transformers/src/processors.js\");\n/* harmony import */ var _utils_core_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/core.js */ \"(ssr)/./node_modules/@xenova/transformers/src/utils/core.js\");\n/* harmony import */ var _utils_maths_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils/maths.js */ \"(ssr)/./node_modules/@xenova/transformers/src/utils/maths.js\");\n/* harmony import */ var _utils_audio_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./utils/audio.js */ \"(ssr)/./node_modules/@xenova/transformers/src/utils/audio.js\");\n/* harmony import */ var _utils_tensor_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./utils/tensor.js */ \"(ssr)/./node_modules/@xenova/transformers/src/utils/tensor.js\");\n/* harmony import */ var _utils_image_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./utils/image.js */ \"(ssr)/./node_modules/@xenova/transformers/src/utils/image.js\");\n/**\n * @file Pipelines provide a high-level, easy to use, API for running machine learning models.\n * \n * **Example:** Instantiate pipeline using the `pipeline` function.\n * ```javascript\n * import { pipeline } from '@xenova/transformers';\n * \n * let classifier = await pipeline('sentiment-analysis');\n * let result = await classifier('I love transformers!');\n * // [{'label': 'POSITIVE', 'score': 0.999817686}]\n * ```\n * \n * @module pipelines\n */\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * Prepare images for further tasks.\n * @param {any[]} images images to prepare.\n * @returns {Promise<any[]>} returns processed images.\n * @private\n */\nasync function prepareImages(images) {\n    if (!Array.isArray(images)) {\n        images = [images];\n    }\n\n    // Possibly convert any non-images to images\n    images = await Promise.all(images.map(x => _utils_image_js__WEBPACK_IMPORTED_MODULE_7__.RawImage.read(x)));\n    return images;\n}\n\n/**\n * The Pipeline class is the class from which all pipelines inherit.\n * Refer to this class for methods shared across different pipelines.\n * @extends Callable\n */\nclass Pipeline extends _utils_core_js__WEBPACK_IMPORTED_MODULE_3__.Callable {\n    /**\n     * Create a new Pipeline.\n     * @param {string} task The task of the pipeline. Useful for specifying subtasks.\n     * @param {PreTrainedTokenizer} tokenizer The tokenizer to use.\n     * @param {PreTrainedModel} model The model to use.\n     */\n    constructor(task, tokenizer, model) {\n        super();\n        this.task = task;\n        this.tokenizer = tokenizer;\n        this.model = model;\n    }\n\n    /**\n     * Disposes the model.\n     * @returns {Promise<void>} A promise that resolves when the model has been disposed.\n     */\n    async dispose() {\n        await this.model.dispose();\n    }\n\n    /**\n     * Executes the task associated with the pipeline.\n     * @param {any} texts The input texts to be processed.\n     * @returns {Promise<any>} A promise that resolves to an array containing the inputs and outputs of the task.\n     */\n    async _call(texts) {\n        // Run tokenization\n        let inputs = this.tokenizer(texts, {\n            padding: true,\n            truncation: true\n        });\n\n        // Run model\n        let outputs = await this.model(inputs)\n\n        return [inputs, outputs];\n    }\n}\n\n/**\n * Text classification pipeline using any `ModelForSequenceClassification`.\n * @extends Pipeline\n */\nclass TextClassificationPipeline extends Pipeline {\n    /**\n     * Executes the text classification task.\n     * @param {any} texts The input texts to be classified.\n     * @param {Object} options An optional object containing the following properties:\n     * @param {number} [options.topk=1] The number of top predictions to be returned.\n     * @returns {Promise<Object[]|Object>} A promise that resolves to an array or object containing the predicted labels and scores.\n     */\n    async _call(texts, {\n        topk = 1\n    } = {}) {\n\n        let [inputs, outputs] = await super._call(texts);\n\n        let id2label = this.model.config.id2label;\n        let toReturn = [];\n        for (let batch of outputs.logits) {\n            let scores = (0,_utils_maths_js__WEBPACK_IMPORTED_MODULE_4__.getTopItems)((0,_utils_maths_js__WEBPACK_IMPORTED_MODULE_4__.softmax)(batch.data), topk);\n\n            let vals = scores.map(function (x) {\n                return {\n                    label: id2label[x[0]],\n                    score: x[1],\n                }\n            });\n            if (topk === 1) {\n                toReturn.push(...vals);\n            } else {\n                toReturn.push(vals);\n            }\n        }\n\n        return Array.isArray(texts) || topk === 1 ? toReturn : toReturn[0];\n    }\n}\n\n\n/**\n * Named Entity Recognition pipeline using any `ModelForTokenClassification`.\n * @extends Pipeline\n */\nclass TokenClassificationPipeline extends Pipeline {\n    /**\n     * Executes the token classification task.\n     * @param {any} texts The input texts to be classified.\n     * @param {Object} options An optional object containing the following properties:\n     * @returns {Promise<Object[]|Object>} A promise that resolves to an array or object containing the predicted labels and scores.\n     */\n    async _call(texts, {\n        ignore_labels = ['O'], // TODO init param?\n    } = {}) {\n\n        let isBatched = Array.isArray(texts);\n\n        if (!isBatched) {\n            texts = [texts];\n        }\n\n        let tokenizer = this.tokenizer;\n        let [inputs, outputs] = await super._call(texts);\n\n        let logits = outputs.logits;\n        let id2label = this.model.config.id2label;\n\n        let toReturn = [];\n        for (let i = 0; i < logits.dims[0]; ++i) {\n            let ids = inputs.input_ids[i];\n            let batch = logits[i];\n\n            // List of tokens that aren't ignored\n            let tokens = [];\n            for (let j = 0; j < batch.dims[0]; ++j) {\n                let tokenData = batch[j];\n                let topScoreIndex = (0,_utils_maths_js__WEBPACK_IMPORTED_MODULE_4__.max)(tokenData.data)[1];\n\n                let entity = id2label[topScoreIndex];\n                if (ignore_labels.includes(entity)) {\n                    // We predicted a token that should be ignored. So, we skip it.\n                    continue;\n                }\n\n                // TODO add option to keep special tokens?\n                let word = tokenizer.decode([ids[j].item()], { skip_special_tokens: true });\n                if (word === '') {\n                    // Was a special token. So, we skip it.\n                    continue;\n                }\n\n                let scores = (0,_utils_maths_js__WEBPACK_IMPORTED_MODULE_4__.softmax)(tokenData.data);\n\n                tokens.push({\n                    entity: entity,\n                    score: scores[topScoreIndex],\n                    index: j,\n                    word: word,\n\n                    // TODO: null for now, but will add\n                    start: null,\n                    end: null,\n                });\n            }\n            toReturn.push(tokens);\n        }\n        return isBatched ? toReturn : toReturn[0];\n    }\n}\n/**\n * Question Answering pipeline using any `ModelForQuestionAnswering`.\n * \n * **Example:** Run question answering with `distilbert-base-uncased-distilled-squad`.\n * ```javascript\n * let question = 'Who was Jim Henson?';\n * let context = 'Jim Henson was a nice puppet.';\n * \n * let answerer = await pipeline('question-answering', 'Xenova/distilbert-base-uncased-distilled-squad');\n * let outputs = await answerer(question, context);\n * console.log(outputs);\n * // {\n * //     \"answer\": \"a nice puppet\",\n * //     \"score\": 0.5768911502526741\n * // }\n * ```\n * @extends Pipeline\n */\nclass QuestionAnsweringPipeline extends Pipeline {\n    /**\n     * Executes the question answering task.\n     * @param {string|string[]} question The question(s) to be answered.\n     * @param {string|string[]} context The context(s) where the answer(s) can be found.\n     * @param {Object} options An optional object containing the following properties:\n     * @param {number} [options.topk=1] The number of top answer predictions to be returned.\n     * @returns {Promise<any>} A promise that resolves to an array or object containing the predicted answers and scores.\n     */\n    // @ts-ignore\n    async _call(question, context, {\n        topk = 1\n    } = {}) {\n\n        // Run tokenization\n        let inputs = this.tokenizer(question, {\n            text_pair: context,\n            padding: true,\n            truncation: true\n        });\n\n        let output = await this.model(inputs);\n\n        let toReturn = [];\n        for (let j = 0; j < output.start_logits.dims[0]; ++j) {\n            let ids = inputs.input_ids[j];\n            let sepIndex = ids.indexOf(this.tokenizer.sep_token_id);\n\n            let s1 = Array.from((0,_utils_maths_js__WEBPACK_IMPORTED_MODULE_4__.softmax)(output.start_logits[j].data))\n                .map((x, i) => [x, i])\n                .filter(x => x[1] > sepIndex);\n            let e1 = Array.from((0,_utils_maths_js__WEBPACK_IMPORTED_MODULE_4__.softmax)(output.end_logits[j].data))\n                .map((x, i) => [x, i])\n                .filter(x => x[1] > sepIndex);\n\n            let options = product(s1, e1)\n                .filter(x => x[0][1] <= x[1][1])\n                .map(x => [x[0][1], x[1][1], x[0][0] * x[1][0]])\n                .sort((a, b) => b[2] - a[2]);\n\n            for (let k = 0; k < Math.min(options.length, topk); ++k) {\n                let [start, end, score] = options[k];\n\n                let answer_tokens = [...ids].slice(start, end + 1)\n\n                let answer = this.tokenizer.decode(answer_tokens, {\n                    skip_special_tokens: true,\n                });\n\n                // TODO add start and end?\n                // NOTE: HF returns character index\n                toReturn.push({\n                    answer, score\n                });\n            }\n        }\n\n        // Mimic HF's return type based on topk\n        return (topk === 1) ? toReturn[0] : toReturn;\n\n    }\n}\n\n/**\n * Masked language modeling prediction pipeline using any `ModelWithLMHead`.\n * @extends Pipeline\n */\nclass FillMaskPipeline extends Pipeline {\n    /**\n     * Fill the masked token in the text(s) given as inputs.\n     * @param {any} texts The masked input texts.\n     * @param {Object} options An optional object containing the following properties:\n     * @param {number} [options.topk=5] The number of top predictions to be returned.\n     * @returns {Promise<Object[]|Object>} A promise that resolves to an array or object containing the predicted tokens and scores.\n     */\n    async _call(texts, {\n        topk = 5\n    } = {}) {\n        // Run tokenization\n        let [inputs, outputs] = await super._call(texts);\n\n        // Determine indices of mask tokens\n        // let mask_token_indices = inputs.input_ids.data.map(x => )\n\n        // let logits = reshape(outputs.logits.data, outputs.logits.dims);\n\n        let tokenizer = this.tokenizer;\n\n        let toReturn = [];\n\n        for (let i = 0; i < inputs.input_ids.dims[0]; ++i) {\n            let ids = inputs.input_ids[i];\n            let mask_token_index = ids.indexOf(this.tokenizer.mask_token_id)\n\n            if (mask_token_index === -1) {\n                throw Error(`Mask token (${tokenizer.mask_token}) not found in text.`)\n            }\n            let logits = outputs.logits[i];\n            let itemLogits = logits[mask_token_index];\n\n            let scores = (0,_utils_maths_js__WEBPACK_IMPORTED_MODULE_4__.getTopItems)((0,_utils_maths_js__WEBPACK_IMPORTED_MODULE_4__.softmax)(itemLogits.data), topk);\n\n            toReturn.push(scores.map(x => {\n                let sequence = [...ids];\n                sequence[mask_token_index] = x[0];\n\n                return {\n                    score: x[1],\n                    token: x[0],\n                    token_str: tokenizer.model.vocab[x[0]],\n                    sequence: tokenizer.decode(sequence, { skip_special_tokens: true }),\n                }\n            }));\n        }\n        return Array.isArray(texts) ? toReturn : toReturn[0];\n    }\n}\n\n/**\n * Text2TextGenerationPipeline class for generating text using a model that performs text-to-text generation tasks.\n * @extends Pipeline\n */\nclass Text2TextGenerationPipeline extends Pipeline {\n    _key = null;\n\n    /**\n     * Fill the masked token in the text(s) given as inputs.\n     * @param {string|string[]} texts The text or array of texts to be processed.\n     * @param {Object} [options={}] Options for the fill-mask pipeline.\n     * @param {number} [options.topk=5] The number of top-k predictions to return.\n     * @returns {Promise<any>} An array of objects containing the score, predicted token, predicted token string,\n     * and the sequence with the predicted token filled in, or an array of such arrays (one for each input text).\n     * If only one input text is given, the output will be an array of objects.\n     * @throws {Error} When the mask token is not found in the input text.\n     */\n    async _call(texts, generate_kwargs = {}) {\n        if (!Array.isArray(texts)) {\n            texts = [texts];\n        }\n\n        // Add global prefix, if present\n        if (this.model.config.prefix) {\n            texts = texts.map(x => this.model.config.prefix + x)\n        }\n\n        // Handle task specific params:\n        let task_specific_params = this.model.config.task_specific_params\n        if (task_specific_params && task_specific_params[this.task]) {\n            // Add prefixes, if present\n            if (task_specific_params[this.task].prefix) {\n                texts = texts.map(x => task_specific_params[this.task].prefix + x)\n            }\n\n            // TODO update generation config\n        }\n\n        let tokenizer_options = {\n            padding: true,\n            truncation: true,\n        }\n        let input_ids;\n        if (this instanceof TranslationPipeline && '_build_translation_inputs' in this.tokenizer) {\n            // TODO: move to Translation pipeline?\n            // Currently put here to avoid code duplication\n            // @ts-ignore\n            input_ids = this.tokenizer._build_translation_inputs(texts, tokenizer_options, generate_kwargs).input_ids;\n\n        } else {\n            input_ids = this.tokenizer(texts, tokenizer_options).input_ids;\n        }\n\n        let outputTokenIds = await this.model.generate(input_ids, generate_kwargs);\n\n        /**\n         * @type {any[]}\n         */\n        let toReturn = this.tokenizer.batch_decode(outputTokenIds, {\n            skip_special_tokens: true,\n        });\n        if (this._key !== null) {\n            toReturn = toReturn.map(text => {\n                return (this._key === null) ? text : { [this._key]: text }\n            })\n        }\n        return toReturn\n    }\n}\n\n\n/**\n * A pipeline for summarization tasks, inheriting from Text2TextGenerationPipeline.\n * @extends Text2TextGenerationPipeline\n */\nclass SummarizationPipeline extends Text2TextGenerationPipeline {\n    _key = 'summary_text';\n}\n\n/**\n * TranslationPipeline class to translate text from one language to another using the provided model and tokenizer.\n * @extends Text2TextGenerationPipeline\n */\nclass TranslationPipeline extends Text2TextGenerationPipeline {\n    _key = 'translation_text';\n}\n\n/**\n * Language generation pipeline using any `ModelWithLMHead` or `ModelForCausalLM`.\n * This pipeline predicts the words that will follow a specified text prompt.\n * NOTE: For the full list of generation parameters, see [`GenerationConfig`](./utils/generation#module_utils/generation.GenerationConfig).\n * \n * **Example:** Text generation with `Xenova/distilgpt2` (default settings).\n * ```javascript\n * let text = 'I enjoy walking with my cute dog,';\n * let generator = await pipeline('text-generation', 'Xenova/distilgpt2');\n * let output = await generator(text);\n * console.log(output);\n * // [{ generated_text: \"I enjoy walking with my cute dog, and I love to play with the other dogs.\" }]\n * ```\n * \n * **Example:** Text generation with `Xenova/distilgpt2` (custom settings).\n * ```javascript\n * let text = 'Once upon a time, there was';\n * let generator = await pipeline('text-generation', 'Xenova/distilgpt2');\n * let output = await generator(text, {\n *     temperature: 2,\n *     max_new_tokens: 10,\n *     repetition_penalty: 1.5,\n *     no_repeat_ngram_size: 2,\n *     num_beams: 2,\n *     num_return_sequences: 2,\n * });\n * console.log(output);\n * // [{\n * //   \"generated_text\": \"Once upon a time, there was an abundance of information about the history and activities that\"\n * // }, {\n * //   \"generated_text\": \"Once upon a time, there was an abundance of information about the most important and influential\"\n * // }]\n * ```\n * \n * **Example:** Run code generation with `Xenova/codegen-350M-mono`.\n * ```javascript\n * let text = 'def fib(n):';\n * let generator = await pipeline('text-generation', 'Xenova/codegen-350M-mono');\n * let output = await generator(text, {\n *     max_new_tokens: 40,\n * });\n * console.log(output[0].generated_text);\n * // def fib(n):\n * //     if n == 0:\n * //         return 0\n * //     if n == 1:\n * //         return 1\n * //     return fib(n-1) + fib(n-2)\n * ```\n * \n * @extends Pipeline\n */\nclass TextGenerationPipeline extends Pipeline {\n    /**\n     * Generates text based on an input prompt.\n     * @param {any} texts The input prompt or prompts to generate text from.\n     * @param {Object} [generate_kwargs={}] Additional arguments for text generation.\n     * @returns {Promise<any>} The generated text or texts.\n     */\n    async _call(texts, generate_kwargs = {}) {\n        let stringInput = typeof texts === 'string' || texts instanceof String;\n        if (stringInput) {\n            texts = [texts];\n        }\n\n        this.tokenizer.padding_side = 'left';\n        let inputs = this.tokenizer(texts, {\n            padding: true,\n            truncation: true,\n        });\n\n        let input_ids = inputs.input_ids;\n        let attention_mask = inputs.attention_mask;\n\n        let outputTokenIds = await this.model.generate(input_ids, generate_kwargs, null, {\n            inputs_attention_mask: attention_mask\n        });\n\n        const decoded = this.tokenizer.batch_decode(outputTokenIds, {\n            skip_special_tokens: true,\n        });\n        const toReturn = Array.from({ length: texts.length }, _ => []);\n        for (let i = 0; i < decoded.length; ++i) {\n            const textIndex = Math.floor(i / outputTokenIds.length * texts.length);\n\n            toReturn[textIndex].push({\n                generated_text: decoded[i]\n            });\n        }\n        return (stringInput && toReturn.length === 1) ? toReturn[0] : toReturn;\n    }\n}\n\n/**\n * NLI-based zero-shot classification pipeline using a `ModelForSequenceClassification`\n * trained on NLI (natural language inference) tasks. Equivalent of `text-classification`\n * pipelines, but these models don't require a hardcoded number of potential classes, they\n * can be chosen at runtime. It usually means it's slower but it is **much** more flexible.\n * @extends Pipeline\n */\nclass ZeroShotClassificationPipeline extends Pipeline {\n\n    /**\n     * Create a new ZeroShotClassificationPipeline.\n     * @param {string} task The task of the pipeline. Useful for specifying subtasks.\n     * @param {PreTrainedTokenizer} tokenizer The tokenizer to use.\n     * @param {PreTrainedModel} model The model to use.\n     */\n    constructor(task, tokenizer, model) {\n        super(task, tokenizer, model);\n\n        // Use model config to get label2id mapping\n        this.label2id = Object.fromEntries(\n            Object.entries(this.model.config.label2id).map(\n                ([k, v]) => [k.toLowerCase(), v]\n            )\n        );\n\n        this.entailment_id = this.label2id['entailment'];\n        if (this.entailment_id === undefined) {\n            console.warn(\"Could not find 'entailment' in label2id mapping. Using 2 as entailment_id.\");\n            this.entailment_id = 2;\n        }\n\n        this.contradiction_id = this.label2id['contradiction'];\n        if (this.contradiction_id === undefined) {\n            console.warn(\"Could not find 'contradiction' in label2id mapping. Using 0 as contradiction_id.\");\n            this.contradiction_id = 0;\n        }\n    }\n    /**\n     * @param {any[]} texts\n     * @param {string[]} candidate_labels\n     * @param {Object} options Additional options:\n     * @param {string} [options.hypothesis_template=\"This example is {}.\"] The template used to turn each\n     * candidate label into an NLI-style hypothesis. The candidate label will replace the {} placeholder.\n     * @param {boolean} [options.multi_label=false] Whether or not multiple candidate labels can be true.\n     * If `false`, the scores are normalized such that the sum of the label likelihoods for each sequence\n     * is 1. If `true`, the labels are considered independent and probabilities are normalized for each\n     * candidate by doing a softmax of the entailment score vs. the contradiction score.\n     * @return {Promise<Object|Object[]>} The prediction(s), as a map (or list of maps) from label to score.\n     */\n    // @ts-ignore\n    async _call(texts, candidate_labels, {\n        hypothesis_template = \"This example is {}.\",\n        multi_label = false,\n    } = {}) {\n\n        let isBatched = Array.isArray(texts);\n\n        if (!isBatched) {\n            texts = [texts];\n        }\n        if (!Array.isArray(candidate_labels)) {\n            candidate_labels = [candidate_labels];\n        }\n\n        // Insert labels into hypothesis template\n        let hypotheses = candidate_labels.map(\n            x => hypothesis_template.replace('{}', x)\n        );\n\n        // How to perform the softmax over the logits:\n        //  - true:  softmax over the entailment vs. contradiction dim for each label independently\n        //  - false: softmax the \"entailment\" logits over all candidate labels\n        let softmaxEach = multi_label || candidate_labels.length === 1;\n\n        let toReturn = [];\n        for (let premise of texts) {\n            let entails_logits = [];\n\n            for (let hypothesis of hypotheses) {\n                let inputs = this.tokenizer(premise, {\n                    text_pair: hypothesis,\n                    padding: true,\n                    truncation: true,\n                })\n                let outputs = await this.model(inputs)\n\n                if (softmaxEach) {\n                    entails_logits.push([\n                        outputs.logits.data[this.contradiction_id],\n                        outputs.logits.data[this.entailment_id]\n                    ])\n                } else {\n                    entails_logits.push(outputs.logits.data[this.entailment_id])\n                }\n            }\n\n            let scores;\n            if (softmaxEach) {\n                scores = entails_logits.map(x => (0,_utils_maths_js__WEBPACK_IMPORTED_MODULE_4__.softmax)(x)[1]);\n            } else {\n                scores = (0,_utils_maths_js__WEBPACK_IMPORTED_MODULE_4__.softmax)(entails_logits);\n            }\n\n            // Sort by scores (desc) and return scores with indices\n            let scores_sorted = scores\n                .map((x, i) => [x, i])\n                .sort((a, b) => {\n                    return b[0] - a[0];\n                });\n\n            toReturn.push({\n                sequence: premise,\n                labels: scores_sorted.map(x => candidate_labels[x[1]]),\n                scores: scores_sorted.map(x => x[0]),\n            });\n        }\n        return isBatched ? toReturn : toReturn[0];\n    }\n}\n\n\n/**\n * Feature extraction pipeline using no model head. This pipeline extracts the hidden\n * states from the base transformer, which can be used as features in downstream tasks.\n * \n * **Example:** Run feature extraction with `bert-base-uncased` (without pooling/normalization).\n * ```javascript\n * let extractor = await pipeline('feature-extraction', 'Xenova/bert-base-uncased', { revision: 'default' });\n * let result = await extractor('This is a simple test.');\n * console.log(result);\n * // Tensor {\n * //     type: 'float32',\n * //     data: Float32Array [0.05939924716949463, 0.021655935794115067, ...],\n * //     dims: [1, 8, 768]\n * // }\n * ```\n * \n * **Example:** Run feature extraction with `bert-base-uncased` (with pooling/normalization).\n * ```javascript\n * let extractor = await pipeline('feature-extraction', 'Xenova/bert-base-uncased', { revision: 'default' });\n * let result = await extractor('This is a simple test.', { pooling: 'mean', normalize: true });\n * console.log(result);\n * // Tensor {\n * //     type: 'float32',\n * //     data: Float32Array [0.03373778983950615, -0.010106077417731285, ...],\n * //     dims: [1, 768]\n * // }\n * ```\n * \n * **Example:** Calculating embeddings with `sentence-transformers` models.\n * ```javascript\n * let extractor = await pipeline('feature-extraction', 'Xenova/all-MiniLM-L6-v2');\n * let result = await extractor('This is a simple test.', { pooling: 'mean', normalize: true });\n * console.log(result);\n * // Tensor {\n * //     type: 'float32',\n * //     data: Float32Array [0.09094982594251633, -0.014774246141314507, ...],\n * //     dims: [1, 384]\n * // }\n * ```\n * @extends Pipeline\n */\nclass FeatureExtractionPipeline extends Pipeline {\n\n    /**\n     * Extract the features of the input(s).\n     * \n     * @param {string|string[]} texts The input texts\n     * @param {Object} options Additional options:\n     * @param {string} [options.pooling=\"none\"] The pooling method to use. Can be one of: \"none\", \"mean\".\n     * @param {boolean} [options.normalize=false] Whether or not to normalize the embeddings in the last dimension.\n     * @returns The features computed by the model.\n     */\n    async _call(texts, {\n        pooling = 'none',\n        normalize = false,\n    } = {}) {\n        let [inputs, outputs] = await super._call(texts);\n\n        // TODO: Provide warning to the user that they might be using model which was not exported\n        // specifically for feature extraction\n        // console.log(this.model.config)\n        // console.log(outputs)\n\n        let result = outputs.last_hidden_state ?? outputs.logits;\n        if (pooling === 'none') {\n            // Skip pooling\n        } else if (pooling === 'mean') {\n            result = (0,_utils_tensor_js__WEBPACK_IMPORTED_MODULE_6__.mean_pooling)(result, inputs.attention_mask);\n        } else {\n            throw Error(`Pooling method '${pooling}' not supported.`);\n        }\n\n        if (normalize) {\n            result = result.normalize(2, -1);\n        }\n\n        return result;\n    }\n}\n\n// TODO\n// export class SentenceSimilarityPipeline extends Pipeline {\n// }\n\n\n/**\n * Pipeline that aims at extracting spoken text contained within some audio.\n *\n * **Example:** Transcribe English.\n * ```javascript\n * let url = 'https://huggingface.co/datasets/Xenova/transformers.js-docs/resolve/main/jfk.wav';\n * let transcriber = await pipeline('automatic-speech-recognition', 'Xenova/whisper-tiny.en');\n * let output = await transcriber(url);\n * // { text: \" And so my fellow Americans ask not what your country can do for you, ask what you can do for your country.\" }\n * ```\n * \n * **Example:** Transcribe English w/ timestamps.\n * ```javascript\n * let url = 'https://huggingface.co/datasets/Xenova/transformers.js-docs/resolve/main/jfk.wav';\n * let transcriber = await pipeline('automatic-speech-recognition', 'Xenova/whisper-tiny.en');\n * let output = await transcriber(url, { return_timestamps: true });\n * // {\n * //   text: \" And so my fellow Americans ask not what your country can do for you, ask what you can do for your country.\"\n * //   chunks: [\n * //     { timestamp: [0, 8],  text: \" And so my fellow Americans ask not what your country can do for you\" }\n * //     { timestamp: [8, 11], text: \" ask what you can do for your country.\" }\n * //   ]\n * // }\n * ```\n * \n * **Example:** Transcribe English w/ word-level timestamps.\n * ```javascript\n * let url = 'https://huggingface.co/datasets/Xenova/transformers.js-docs/resolve/main/jfk.wav';\n * let transcriber = await pipeline('automatic-speech-recognition', 'Xenova/whisper-tiny.en', {\n *     revision: 'output_attentions',\n * });\n * let output = await transcriber(url, { return_timestamps: 'word' });\n * // {\n * //   \"text\": \" And so my fellow Americans ask not what your country can do for you ask what you can do for your country.\",\n * //   \"chunks\": [\n * //     { \"text\": \" And\", \"timestamp\": [0, 0.78] },\n * //     { \"text\": \" so\", \"timestamp\": [0.78, 1.06] },\n * //     { \"text\": \" my\", \"timestamp\": [1.06, 1.46] },\n * //     ...\n * //     { \"text\": \" for\", \"timestamp\": [9.72, 9.92] },\n * //     { \"text\": \" your\", \"timestamp\": [9.92, 10.22] },\n * //     { \"text\": \" country.\", \"timestamp\": [10.22, 13.5] }\n * //   ]\n * // }\n * ```\n * \n * **Example:** Transcribe French.\n * ```javascript\n * let url = 'https://huggingface.co/datasets/Xenova/transformers.js-docs/resolve/main/french-audio.mp3';\n * let transcriber = await pipeline('automatic-speech-recognition', 'Xenova/whisper-small');\n * let output = await transcriber(url, { language: 'french', task: 'transcribe' });\n * // { text: \" J'adore, j'aime, je n'aime pas, je déteste.\" }\n * ```\n * \n * **Example:** Translate French to English.\n * ```javascript\n * let url = 'https://huggingface.co/datasets/Xenova/transformers.js-docs/resolve/main/french-audio.mp3';\n * let transcriber = await pipeline('automatic-speech-recognition', 'Xenova/whisper-small');\n * let output = await transcriber(url, { language: 'french', task: 'translate' });\n * // { text: \" I love, I like, I don't like, I hate.\" }\n * ```\n * \n * **Example:** Transcribe/translate audio longer than 30 seconds.\n * ```javascript\n * let url = 'https://huggingface.co/datasets/Xenova/transformers.js-docs/resolve/main/ted_60.wav';\n * let transcriber = await pipeline('automatic-speech-recognition', 'Xenova/whisper-tiny.en');\n * let output = await transcriber(url, { chunk_length_s: 30, stride_length_s: 5 });\n * // { text: \" So in college, I was a government major, which means [...] So I'd start off light and I'd bump it up\" }\n * ```\n * @extends Pipeline\n */\nclass AutomaticSpeechRecognitionPipeline extends Pipeline {\n\n    /**\n     * Create a new AutomaticSpeechRecognitionPipeline.\n     * @param {string} task The task of the pipeline. Useful for specifying subtasks.\n     * @param {PreTrainedTokenizer} tokenizer The tokenizer to use.\n     * @param {PreTrainedModel} model The model to use.\n     * @param {Processor} processor The processor to use.\n     */\n    constructor(task, tokenizer, model, processor) {\n        super(task, tokenizer, model);\n        this.processor = processor;\n    }\n\n    /**\n     * Preprocesses the input audio for the AutomaticSpeechRecognitionPipeline.\n     * @param {any} audio The audio to be preprocessed.\n     * @param {number} sampling_rate The sampling rate of the audio.\n     * @returns {Promise<Float32Array>} A promise that resolves to the preprocessed audio data.\n     * @private\n     */\n    async _preprocess(audio, sampling_rate) {\n        if ((0,_utils_core_js__WEBPACK_IMPORTED_MODULE_3__.isString)(audio)) {\n            audio = await (0,_utils_audio_js__WEBPACK_IMPORTED_MODULE_5__.read_audio)(audio, sampling_rate);\n        }\n\n        return audio;\n    }\n\n    /**\n     * @typedef {import('./utils/tensor.js').Tensor} Tensor\n     * @typedef {{stride: number[], input_features: Tensor, is_last: boolean, tokens?: number[], token_timestamps?: number[]}} Chunk\n     * \n     * @callback ChunkCallback\n     * @param {Chunk} chunk The chunk to process.\n     */\n\n    /**\n     * Asynchronously processes audio and generates text transcription using the model.\n     * @param {Float32Array|Float32Array[]} audio The audio to be transcribed. Can be a single Float32Array or an array of Float32Arrays.\n     * @param {Object} [kwargs={}] Optional arguments.\n     * @param {boolean|'word'} [kwargs.return_timestamps] Whether to return timestamps or not. Default is `false`.\n     * @param {number} [kwargs.chunk_length_s] The length of audio chunks to process in seconds. Default is 0 (no chunking).\n     * @param {number} [kwargs.stride_length_s] The length of overlap between consecutive audio chunks in seconds. If not provided, defaults to `chunk_length_s / 6`.\n     * @param {ChunkCallback} [kwargs.chunk_callback] Callback function to be called with each chunk processed.\n     * @param {boolean} [kwargs.force_full_sequences] Whether to force outputting full sequences or not. Default is `false`.\n     * @param {string} [kwargs.language] The source language. Default is `null`, meaning it should be auto-detected. Use this to potentially improve performance if the source language is known.\n     * @param {string} [kwargs.task] The task to perform. Default is `null`, meaning it should be auto-detected.\n     * @param {number[][]} [kwargs.forced_decoder_ids] A list of pairs of integers which indicates a mapping from generation indices to token indices\n     * that will be forced before sampling. For example, [[1, 123]] means the second generated token will always be a token of index 123.\n     * @returns {Promise<Object>} A Promise that resolves to an object containing the transcription text and optionally timestamps if `return_timestamps` is `true`.\n     */\n    async _call(audio, kwargs = {}) {\n        let return_timestamps = kwargs.return_timestamps ?? false;\n        let chunk_length_s = kwargs.chunk_length_s ?? 0;\n        let stride_length_s = kwargs.stride_length_s ?? null;\n        let chunk_callback = kwargs.chunk_callback ?? null;\n        let force_full_sequences = kwargs.force_full_sequences ?? false;\n\n        if (return_timestamps === 'word') {\n            kwargs['return_token_timestamps'] = true;\n        }\n\n        let language = (0,_utils_core_js__WEBPACK_IMPORTED_MODULE_3__.pop)(kwargs, 'language', null);\n        let task = (0,_utils_core_js__WEBPACK_IMPORTED_MODULE_3__.pop)(kwargs, 'task', null);\n\n        if (language || task || return_timestamps) {\n            if (kwargs.forced_decoder_ids) {\n                throw new Error(\"Cannot specify `language`/`task`/`return_timestamps` and `forced_decoder_ids` at the same time.\")\n            }\n            // @ts-ignore\n            let decoder_prompt_ids = this.tokenizer.get_decoder_prompt_ids({ language, task, no_timestamps: !return_timestamps })\n            if (decoder_prompt_ids.length > 0) {\n                kwargs.forced_decoder_ids = decoder_prompt_ids;\n            }\n        }\n\n        let single = !Array.isArray(audio);\n        if (single) {\n            // @ts-ignore\n            audio = [audio];\n        }\n\n        const sampling_rate = this.processor.feature_extractor.config.sampling_rate;\n        const time_precision = this.processor.feature_extractor.config.chunk_length / this.model.config.max_source_positions;\n\n        let toReturn = [];\n        for (let aud of audio) {\n            aud = await this._preprocess(aud, sampling_rate)\n\n            /** @type {Chunk[]} */\n            let chunks = [];\n            if (chunk_length_s > 0) {\n                if (stride_length_s === null) {\n                    stride_length_s = chunk_length_s / 6;\n                } else if (chunk_length_s <= stride_length_s) {\n                    throw Error(\"`chunk_length_s` must be larger than `stride_length_s`.\")\n                }\n\n                // TODO support different stride_length_s (for left and right)\n\n                const window = sampling_rate * chunk_length_s;\n                const stride = sampling_rate * stride_length_s;\n                const jump = window - 2 * stride;\n                let offset = 0;\n\n                // Create subarrays of audio with overlaps\n\n                while (offset < aud.length) {\n                    let subarr = aud.subarray(offset, offset + window);\n                    let feature = await this.processor(subarr);\n\n                    let isFirst = offset === 0;\n                    let isLast = offset + jump >= aud.length;\n                    chunks.push({\n                        stride: [\n                            subarr.length,\n                            isFirst ? 0 : stride,\n                            isLast ? 0 : stride\n                        ],\n                        input_features: feature.input_features,\n                        is_last: isLast\n                    })\n                    offset += jump;\n                }\n\n            } else {\n                chunks = [{\n                    stride: [aud.length, 0, 0],\n                    input_features: (await this.processor(aud)).input_features,\n                    is_last: true\n                }]\n            }\n\n            // Generate for each set of input features\n            for (let chunk of chunks) {\n                // NOTE: doing sequentially for now\n                let data = await this.model.generate(chunk.input_features, kwargs);\n\n                // TODO: Right now we only get top beam\n                if (return_timestamps === 'word') {\n                    chunk.tokens = data.sequences[0];\n                    chunk.token_timestamps = data.token_timestamps.tolist()[0].map(\n                        x => (0,_utils_maths_js__WEBPACK_IMPORTED_MODULE_4__.round)(x, 2)\n                    );\n\n                } else {\n                    chunk.tokens = data[0];\n                }\n\n                // convert stride to seconds\n                chunk.stride = chunk.stride.map(x => x / sampling_rate);\n\n                if (chunk_callback !== null) {\n                    chunk_callback(chunk)\n                }\n            }\n\n            // Merge text chunks\n            // @ts-ignore\n            let [full_text, optional] = this.tokenizer._decode_asr(chunks, {\n                time_precision, return_timestamps, force_full_sequences\n            });\n\n            toReturn.push({ text: full_text, ...optional })\n        }\n        return single ? toReturn[0] : toReturn;\n    }\n}\n\n/**\n * Image To Text pipeline using a `AutoModelForVision2Seq`. This pipeline predicts a caption for a given image.\n * @extends Pipeline\n */\nclass ImageToTextPipeline extends Pipeline {\n    /**\n     * Create a new ImageToTextPipeline.\n     * @param {string} task The task of the pipeline. Useful for specifying subtasks.\n     * @param {PreTrainedTokenizer} tokenizer The tokenizer to use.\n     * @param {PreTrainedModel} model The model to use.\n     * @param {Processor} processor The processor to use.\n     */\n    constructor(task, tokenizer, model, processor) {\n        super(task, tokenizer, model);\n        this.processor = processor;\n    }\n\n    /**\n     * Assign labels to the image(s) passed as inputs.\n     * @param {any[]} images The images to be captioned.\n     * @param {Object} [generate_kwargs={}] Optional generation arguments.\n     * @returns {Promise<Object|Object[]>} A Promise that resolves to an object (or array of objects) containing the generated text(s).\n     */\n    async _call(images, generate_kwargs = {}) {\n        let isBatched = Array.isArray(images);\n\n        images = await prepareImages(images);\n\n        let { pixel_values } = await this.processor(images);\n\n        let toReturn = [];\n        for (let batch of pixel_values) {\n            batch.dims = [1, ...batch.dims]\n            let output = await this.model.generate(batch, generate_kwargs);\n            let decoded = this.tokenizer.batch_decode(output, {\n                skip_special_tokens: true,\n            }).map(x => {\n                return { generated_text: x.trim() }\n            })\n            toReturn.push(decoded);\n        }\n\n        return isBatched ? toReturn : toReturn[0];\n    }\n}\n\n/**\n * Image classification pipeline using any `AutoModelForImageClassification`.\n * This pipeline predicts the class of an image.\n * \n * **Example:** Classify an image.\n * ```javascript\n * let classifier = await pipeline('image-classification', 'Xenova/vit-base-patch16-224');\n * let url = 'https://huggingface.co/datasets/Xenova/transformers.js-docs/resolve/main/tiger.jpg';\n * let outputs = await classifier(url);\n * // Array(1) [\n * //   {label: 'tiger, Panthera tigris', score: 0.632695734500885},\n * // ]\n * ```\n * \n * **Example:** Classify an image and return top `n` classes.\n * ```javascript\n * let classifier = await pipeline('image-classification', 'Xenova/vit-base-patch16-224');\n * let url = 'https://huggingface.co/datasets/Xenova/transformers.js-docs/resolve/main/tiger.jpg';\n * let outputs = await classifier(url, { topk: 3 });\n * // Array(3) [\n * //   {label: 'tiger, Panthera tigris', score: 0.632695734500885},\n * //   {label: 'tiger cat', score: 0.3634825646877289},\n * //   {label: 'lion, king of beasts, Panthera leo', score: 0.00045060308184474707},\n * // ]\n * ```\n * \n * **Example:** Classify an image and return all classes.\n * ```javascript\n * let classifier = await pipeline('image-classification', 'Xenova/vit-base-patch16-224');\n * let url = 'https://huggingface.co/datasets/Xenova/transformers.js-docs/resolve/main/tiger.jpg';\n * let outputs = await classifier(url, { topk: 0 });\n * // Array(1000) [\n * //   {label: 'tiger, Panthera tigris', score: 0.632695734500885},\n * //   {label: 'tiger cat', score: 0.3634825646877289},\n * //   {label: 'lion, king of beasts, Panthera leo', score: 0.00045060308184474707},\n * //   {label: 'jaguar, panther, Panthera onca, Felis onca', score: 0.00035465499968267977},\n * //   ...\n * // ]\n * ```\n * @extends Pipeline\n */\nclass ImageClassificationPipeline extends Pipeline {\n    /**\n     * Create a new ImageClassificationPipeline.\n     * @param {string} task The task of the pipeline. Useful for specifying subtasks.\n     * @param {PreTrainedModel} model The model to use.\n     * @param {Processor} processor The processor to use.\n     */\n    constructor(task, model, processor) {\n        super(task, null, model); // TODO tokenizer\n        this.processor = processor;\n    }\n\n    /**\n     * Classify the given images.\n     * @param {any} images The images to classify.\n     * @param {Object} options The options to use for classification.\n     * @param {number} [options.topk=1] The number of top results to return.\n     * @returns {Promise<any>} The top classification results for the images.\n     */\n    async _call(images, {\n        topk = 1\n    } = {}) {\n        let isBatched = Array.isArray(images);\n        images = await prepareImages(images);\n\n        let { pixel_values } = await this.processor(images);\n        let output = await this.model({ pixel_values });\n\n        let id2label = this.model.config.id2label;\n        let toReturn = [];\n        for (let batch of output.logits) {\n            let scores = (0,_utils_maths_js__WEBPACK_IMPORTED_MODULE_4__.getTopItems)((0,_utils_maths_js__WEBPACK_IMPORTED_MODULE_4__.softmax)(batch.data), topk);\n\n            let vals = scores.map(function (x) {\n                return {\n                    label: id2label[x[0]],\n                    score: x[1],\n                }\n            });\n            if (topk === 1) {\n                toReturn.push(...vals);\n            } else {\n                toReturn.push(vals);\n            }\n        }\n\n        return isBatched || topk === 1 ? toReturn : toReturn[0];\n    }\n\n}\n\n/**\n * Image segmentation pipeline using any `AutoModelForXXXSegmentation`.\n * This pipeline predicts masks of objects and their classes.\n * @extends Pipeline\n */\nclass ImageSegmentationPipeline extends Pipeline {\n    /**\n     * Create a new ImageSegmentationPipeline.\n     * @param {string} task The task of the pipeline. Useful for specifying subtasks.\n     * @param {PreTrainedModel} model The model to use.\n     * @param {Processor} processor The processor to use.\n     */\n    constructor(task, model, processor) {\n        super(task, null, model); // TODO tokenizer\n        this.processor = processor;\n\n        this.subtasks_mapping = {\n            // Mapping of subtasks to their corresponding post-processing function names.\n            panoptic: 'post_process_panoptic_segmentation',\n            instance: 'post_process_instance_segmentation',\n            semantic: 'post_process_semantic_segmentation'\n        }\n    }\n\n    /**\n     * Segment the input images.\n     * @param {Array} images The input images.\n     * @param {Object} options The options to use for segmentation.\n     * @param {number} [options.threshold=0.5] Probability threshold to filter out predicted masks.\n     * @param {number} [options.mask_threshold=0.5] Threshold to use when turning the predicted masks into binary values.\n     * @param {number} [options.overlap_mask_area_threshold=0.8] Mask overlap threshold to eliminate small, disconnected segments.\n     * @param {null|string} [options.subtask=null] Segmentation task to be performed. One of [`panoptic`, `instance`, and `semantic`], depending on model capabilities. If not set, the pipeline will attempt to resolve (in that order).\n     * @param {Array} [options.label_ids_to_fuse=null] List of label ids to fuse. If not set, do not fuse any labels.\n     * @param {Array} [options.target_sizes=null] List of target sizes for the input images. If not set, use the original image sizes.\n     * @returns {Promise<Array>} The annotated segments.\n     */\n    async _call(images, {\n        threshold = 0.5,\n        mask_threshold = 0.5,\n        overlap_mask_area_threshold = 0.8,\n        label_ids_to_fuse = null,\n        target_sizes = null,\n        subtask = null, // TODO use\n    } = {}) {\n        let isBatched = Array.isArray(images);\n\n        if (isBatched && images.length !== 1) {\n            throw Error(\"Image segmentation pipeline currently only supports a batch size of 1.\");\n        }\n\n        images = await prepareImages(images);\n        let imageSizes = images.map(x => [x.height, x.width]);\n\n        let { pixel_values, pixel_mask } = await this.processor(images);\n        let output = await this.model({ pixel_values, pixel_mask });\n\n        let fn = null;\n        if (subtask !== null) {\n            fn = this.subtasks_mapping[subtask];\n        } else {\n            for (let [task, func] of Object.entries(this.subtasks_mapping)) {\n                if (func in this.processor.feature_extractor) {\n                    fn = this.processor.feature_extractor[func].bind(this.processor.feature_extractor);\n                    subtask = task;\n                    break;\n                }\n            }\n        }\n\n        // add annotations\n        let annotation = [];\n\n        if (subtask === 'panoptic' || subtask === 'instance') {\n\n            let processed = fn(\n                output,\n                threshold,\n                mask_threshold,\n                overlap_mask_area_threshold,\n                label_ids_to_fuse,\n                target_sizes ?? imageSizes, // TODO FIX?\n            )[0];\n\n            let segmentation = processed.segmentation;\n            let id2label = this.model.config.id2label;\n\n            for (let segment of processed.segments_info) {\n                let maskData = new Uint8ClampedArray(segmentation.data.length);\n                for (let i = 0; i < segmentation.data.length; ++i) {\n                    if (segmentation.data[i] === segment.id) {\n                        maskData[i] = 255;\n                    }\n                }\n\n                let mask = new _utils_image_js__WEBPACK_IMPORTED_MODULE_7__.RawImage(maskData, segmentation.dims[1], segmentation.dims[0], 1)\n\n                annotation.push({\n                    score: segment.score,\n                    label: id2label[segment.label_id],\n                    mask: mask\n                })\n            }\n\n        } else if (subtask === 'semantic') {\n            throw Error(`semantic segmentation not yet supported.`);\n\n        } else {\n            throw Error(`Subtask ${subtask} not supported.`);\n        }\n\n        return annotation;\n    }\n}\n\n\n/**\n * Zero shot image classification pipeline. This pipeline predicts the class of\n * an image when you provide an image and a set of `candidate_labels`.\n * @extends Pipeline\n */\nclass ZeroShotImageClassificationPipeline extends Pipeline {\n\n    /**\n     * Create a new ZeroShotImageClassificationPipeline.\n     * @param {string} task The task of the pipeline. Useful for specifying subtasks.\n     * @param {PreTrainedTokenizer} tokenizer The tokenizer to use.\n     * @param {PreTrainedModel} model The model to use.\n     * @param {Processor} processor The processor to use.\n     */\n    constructor(task, tokenizer, model, processor) {\n        super(task, tokenizer, model);\n        this.processor = processor;\n    }\n\n    /**\n     * Classify the input images with candidate labels using a zero-shot approach.\n     * @param {Array} images The input images.\n     * @param {Array} candidate_labels The candidate labels.\n     * @param {Object} options The options for the classification.\n     * @param {string} [options.hypothesis_template] The hypothesis template to use for zero-shot classification. Default: \"This is a photo of {}\".\n     * @returns {Promise<any>} An array of classifications for each input image or a single classification object if only one input image is provided.\n     */\n    // @ts-ignore\n    async _call(images, candidate_labels, {\n        hypothesis_template = \"This is a photo of {}\"\n    } = {}) {\n        let isBatched = Array.isArray(images);\n        images = await prepareImages(images);\n\n        // Insert label into hypothesis template \n        let texts = candidate_labels.map(\n            x => hypothesis_template.replace('{}', x)\n        );\n\n        // Run tokenization\n        let text_inputs = this.tokenizer(texts, {\n            padding: true,\n            truncation: true\n        });\n\n        // Run processor\n        let { pixel_values } = await this.processor(images);\n\n        // Run model with both text and pixel inputs\n        let output = await this.model({ ...text_inputs, pixel_values });\n\n        // Compare each image with each candidate label\n        let toReturn = [];\n        for (let batch of output.logits_per_image) {\n            // Compute softmax per image\n            let probs = (0,_utils_maths_js__WEBPACK_IMPORTED_MODULE_4__.softmax)(batch.data);\n\n            toReturn.push([...probs].map((x, i) => {\n                return {\n                    score: x,\n                    label: candidate_labels[i]\n                }\n            }));\n        }\n\n        return isBatched ? toReturn : toReturn[0];\n    }\n}\n\n/**\n * Object detection pipeline using any `AutoModelForObjectDetection`.\n * This pipeline predicts bounding boxes of objects and their classes.\n * \n * **Example:** Run object-detection with `facebook/detr-resnet-50`.\n * ```javascript\n * let img = 'https://huggingface.co/datasets/Xenova/transformers.js-docs/resolve/main/cats.jpg';\n * \n * let detector = await pipeline('object-detection', 'Xenova/detr-resnet-50');\n * let output = await detector(img, { threshold: 0.9 });\n * // [{\n * //   \"score\": 0.9976370930671692,\n * //   \"label\": \"remote\",\n * //   \"box\": { \"xmin\": 31, \"ymin\": 68, \"xmax\": 190, \"ymax\": 118 }\n * // },\n * // ...\n * // {\n * //   \"score\": 0.9984092116355896,\n * //   \"label\": \"cat\",\n * //   \"box\": { \"xmin\": 331, \"ymin\": 19, \"xmax\": 649, \"ymax\": 371 }\n * // }]\n * ```\n * \n * @extends Pipeline\n */\nclass ObjectDetectionPipeline extends Pipeline {\n    /**\n     * Create a new ObjectDetectionPipeline.\n     * @param {string} task The task of the pipeline. Useful for specifying subtasks.\n     * @param {PreTrainedModel} model The model to use.\n     * @param {Processor} processor The processor to use.\n     */\n    constructor(task, model, processor) {\n        super(task, null, model); // TODO tokenizer\n        this.processor = processor;\n    }\n\n    /**\n     * Detect objects (bounding boxes & classes) in the image(s) passed as inputs.\n     * @param {any[]} images The input images.\n     * @param {Object} options The options for the object detection.\n     * @param {number} [options.threshold=0.9] The threshold used to filter boxes by score.\n     * @param {boolean} [options.percentage=false] Whether to return the boxes coordinates in percentage (true) or in pixels (false).\n     */\n    async _call(images, {\n        threshold = 0.9,\n        percentage = false,\n    } = {}) {\n        let isBatched = Array.isArray(images);\n\n        if (isBatched && images.length !== 1) {\n            throw Error(\"Object detection pipeline currently only supports a batch size of 1.\");\n        }\n        images = await prepareImages(images);\n\n        let imageSizes = percentage ? null : images.map(x => [x.height, x.width]);\n\n        let { pixel_values, pixel_mask } = await this.processor(images);\n        let output = await this.model({ pixel_values, pixel_mask });\n\n        // @ts-ignore\n        let processed = this.processor.feature_extractor.post_process_object_detection(output, threshold, imageSizes);\n\n        // Add labels\n        let id2label = this.model.config.id2label;\n\n        // Format output\n        const result = processed.map(batch => {\n            return batch.boxes.map((box, i) => {\n                return {\n                    score: batch.scores[i],\n                    label: id2label[batch.classes[i]],\n                    box: this._get_bounding_box(box, !percentage),\n                }\n            })\n        })\n\n        return isBatched ? result : result[0];\n    }\n\n    /**\n     * Helper function to convert list [xmin, xmax, ymin, ymax] into object { \"xmin\": xmin, ... }\n     * @param {number[]} box The bounding box as a list.\n     * @param {boolean} asInteger Whether to cast to integers.\n     * @returns {Object} The bounding box as an object.\n     * @private\n     */\n    _get_bounding_box(box, asInteger) {\n        if (asInteger) {\n            box = box.map(x => x | 0);\n        }\n        const [xmin, ymin, xmax, ymax] = box;\n\n        return { xmin, ymin, xmax, ymax };\n    }\n}\n\nconst SUPPORTED_TASKS = {\n    \"text-classification\": {\n        \"tokenizer\": _tokenizers_js__WEBPACK_IMPORTED_MODULE_0__.AutoTokenizer,\n        \"pipeline\": TextClassificationPipeline,\n        \"model\": _models_js__WEBPACK_IMPORTED_MODULE_1__.AutoModelForSequenceClassification,\n        \"default\": {\n            // TODO: replace with original\n            // \"model\": \"distilbert-base-uncased-finetuned-sst-2-english\",\n            \"model\": \"Xenova/distilbert-base-uncased-finetuned-sst-2-english\",\n        },\n        \"type\": \"text\",\n    },\n    \"token-classification\": {\n        \"tokenizer\": _tokenizers_js__WEBPACK_IMPORTED_MODULE_0__.AutoTokenizer,\n        \"pipeline\": TokenClassificationPipeline,\n        \"model\": _models_js__WEBPACK_IMPORTED_MODULE_1__.AutoModelForTokenClassification,\n        \"default\": {\n            // TODO: replace with original\n            // \"model\": \"Davlan/bert-base-multilingual-cased-ner-hrl\",\n            \"model\": \"Xenova/bert-base-multilingual-cased-ner-hrl\",\n        },\n        \"type\": \"text\",\n    },\n    \"question-answering\": {\n        \"tokenizer\": _tokenizers_js__WEBPACK_IMPORTED_MODULE_0__.AutoTokenizer,\n        \"pipeline\": QuestionAnsweringPipeline,\n        \"model\": _models_js__WEBPACK_IMPORTED_MODULE_1__.AutoModelForQuestionAnswering,\n        \"default\": {\n            // TODO: replace with original\n            // \"model\": \"distilbert-base-cased-distilled-squad\",\n            \"model\": \"Xenova/distilbert-base-cased-distilled-squad\",\n        },\n        \"type\": \"text\",\n    },\n\n    \"fill-mask\": {\n        \"tokenizer\": _tokenizers_js__WEBPACK_IMPORTED_MODULE_0__.AutoTokenizer,\n        \"pipeline\": FillMaskPipeline,\n        \"model\": _models_js__WEBPACK_IMPORTED_MODULE_1__.AutoModelForMaskedLM,\n        \"default\": {\n            // TODO: replace with original\n            // \"model\": \"bert-base-uncased\",\n            \"model\": \"Xenova/bert-base-uncased\",\n        },\n        \"type\": \"text\",\n    },\n    \"summarization\": {\n        \"tokenizer\": _tokenizers_js__WEBPACK_IMPORTED_MODULE_0__.AutoTokenizer,\n        \"pipeline\": SummarizationPipeline,\n        \"model\": _models_js__WEBPACK_IMPORTED_MODULE_1__.AutoModelForSeq2SeqLM,\n        \"default\": {\n            // TODO: replace with original\n            // \"model\": \"sshleifer/distilbart-cnn-6-6\",\n            \"model\": \"Xenova/distilbart-cnn-6-6\",\n        },\n        \"type\": \"text\",\n    },\n    \"translation\": {\n        \"tokenizer\": _tokenizers_js__WEBPACK_IMPORTED_MODULE_0__.AutoTokenizer,\n        \"pipeline\": TranslationPipeline,\n        \"model\": _models_js__WEBPACK_IMPORTED_MODULE_1__.AutoModelForSeq2SeqLM,\n        \"default\": {\n            // TODO: replace with original\n            // \"model\": \"t5-small\",\n            \"model\": \"Xenova/t5-small\",\n        },\n        \"type\": \"text\",\n    },\n    \"text2text-generation\": {\n        \"tokenizer\": _tokenizers_js__WEBPACK_IMPORTED_MODULE_0__.AutoTokenizer,\n        \"pipeline\": Text2TextGenerationPipeline,\n        \"model\": _models_js__WEBPACK_IMPORTED_MODULE_1__.AutoModelForSeq2SeqLM,\n        \"default\": {\n            // TODO: replace with original\n            // \"model\": \"google/flan-t5-small\",\n            \"model\": \"Xenova/flan-t5-small\",\n        },\n        \"type\": \"text\",\n    },\n    \"text-generation\": {\n        \"tokenizer\": _tokenizers_js__WEBPACK_IMPORTED_MODULE_0__.AutoTokenizer,\n        \"pipeline\": TextGenerationPipeline,\n        \"model\": _models_js__WEBPACK_IMPORTED_MODULE_1__.AutoModelForCausalLM,\n        \"default\": {\n            // TODO: replace with original\n            // \"model\": \"gpt2\",\n            \"model\": \"Xenova/gpt2\",\n        },\n        \"type\": \"text\",\n    },\n    \"zero-shot-classification\": {\n        \"tokenizer\": _tokenizers_js__WEBPACK_IMPORTED_MODULE_0__.AutoTokenizer,\n        \"pipeline\": ZeroShotClassificationPipeline,\n        \"model\": _models_js__WEBPACK_IMPORTED_MODULE_1__.AutoModelForSequenceClassification,\n        \"default\": {\n            // TODO: replace with original\n            // \"model\": \"typeform/distilbert-base-uncased-mnli\",\n            \"model\": \"Xenova/distilbert-base-uncased-mnli\",\n        },\n        \"type\": \"text\",\n    },\n\n    \"automatic-speech-recognition\": {\n        \"tokenizer\": _tokenizers_js__WEBPACK_IMPORTED_MODULE_0__.AutoTokenizer,\n        \"pipeline\": AutomaticSpeechRecognitionPipeline,\n        \"model\": _models_js__WEBPACK_IMPORTED_MODULE_1__.AutoModelForSeq2SeqLM,\n        \"processor\": _processors_js__WEBPACK_IMPORTED_MODULE_2__.AutoProcessor,\n        \"default\": {\n            // TODO: replace with original\n            // \"model\": \"openai/whisper-tiny.en\",\n            \"model\": \"Xenova/whisper-tiny.en\",\n        },\n        \"type\": \"multimodal\",\n    },\n\n    \"image-to-text\": {\n        \"tokenizer\": _tokenizers_js__WEBPACK_IMPORTED_MODULE_0__.AutoTokenizer,\n        \"pipeline\": ImageToTextPipeline,\n        \"model\": _models_js__WEBPACK_IMPORTED_MODULE_1__.AutoModelForVision2Seq,\n        \"processor\": _processors_js__WEBPACK_IMPORTED_MODULE_2__.AutoProcessor,\n        \"default\": {\n            // TODO: replace with original\n            // \"model\": \"nlpconnect/vit-gpt2-image-captioning\",\n            \"model\": \"Xenova/vit-gpt2-image-captioning\",\n        },\n        \"type\": \"multimodal\",\n    },\n\n    \"image-classification\": {\n        // no tokenizer\n        \"pipeline\": ImageClassificationPipeline,\n        \"model\": _models_js__WEBPACK_IMPORTED_MODULE_1__.AutoModelForImageClassification,\n        \"processor\": _processors_js__WEBPACK_IMPORTED_MODULE_2__.AutoProcessor,\n        \"default\": {\n            // TODO: replace with original\n            // \"model\": \"google/vit-base-patch16-224\",\n            \"model\": \"Xenova/vit-base-patch16-224\",\n        },\n        \"type\": \"multimodal\",\n    },\n\n    \"image-segmentation\": {\n        // no tokenizer\n        \"pipeline\": ImageSegmentationPipeline,\n        \"model\": _models_js__WEBPACK_IMPORTED_MODULE_1__.AutoModelForImageSegmentation,\n        \"processor\": _processors_js__WEBPACK_IMPORTED_MODULE_2__.AutoProcessor,\n        \"default\": {\n            // TODO: replace with original\n            // \"model\": \"facebook/detr-resnet-50-panoptic\",\n            \"model\": \"Xenova/detr-resnet-50-panoptic\",\n        },\n        \"type\": \"multimodal\",\n    },\n\n    \"zero-shot-image-classification\": {\n        // no tokenizer\n        \"tokenizer\": _tokenizers_js__WEBPACK_IMPORTED_MODULE_0__.AutoTokenizer,\n        \"pipeline\": ZeroShotImageClassificationPipeline,\n        \"model\": _models_js__WEBPACK_IMPORTED_MODULE_1__.AutoModel,\n        \"processor\": _processors_js__WEBPACK_IMPORTED_MODULE_2__.AutoProcessor,\n        \"default\": {\n            // TODO: replace with original\n            // \"model\": \"openai/clip-vit-base-patch32\",\n            \"model\": \"Xenova/clip-vit-base-patch32\",\n        },\n        \"type\": \"multimodal\",\n    },\n\n    \"object-detection\": {\n        // no tokenizer\n        \"pipeline\": ObjectDetectionPipeline,\n        \"model\": _models_js__WEBPACK_IMPORTED_MODULE_1__.AutoModelForObjectDetection,\n        \"processor\": _processors_js__WEBPACK_IMPORTED_MODULE_2__.AutoProcessor,\n        \"default\": {\n            // TODO: replace with original\n            // \"model\": \"facebook/detr-resnet-50\",\n            \"model\": \"Xenova/detr-resnet-50\",\n        },\n        \"type\": \"multimodal\",\n    },\n\n    // This task serves as a useful interface for dealing with sentence-transformers (https://huggingface.co/sentence-transformers).\n    \"feature-extraction\": {\n        \"tokenizer\": _tokenizers_js__WEBPACK_IMPORTED_MODULE_0__.AutoTokenizer,\n        \"pipeline\": FeatureExtractionPipeline,\n        \"model\": _models_js__WEBPACK_IMPORTED_MODULE_1__.AutoModel,\n        \"default\": {\n            // TODO: replace with original\n            // \"model\": \"sentence-transformers/all-MiniLM-L6-v2\",\n            \"model\": \"Xenova/all-MiniLM-L6-v2\",\n        },\n        \"type\": \"text\",\n    },\n}\n\n\nconst TASK_ALIASES = {\n    \"sentiment-analysis\": \"text-classification\",\n    \"ner\": \"token-classification\",\n    \"vqa\": \"visual-question-answering\",\n    \"asr\": \"automatic-speech-recognition\",\n\n    // Add for backwards compatibility\n    \"embeddings\": \"feature-extraction\",\n}\n\n/**\n * @typedef {import('./utils/hub.js').PretrainedOptions} PretrainedOptions\n */\n\n/**\n * Utility factory method to build a [`Pipeline`] object.\n *\n * @param {string} task The task of the pipeline.\n * @param {string} [model=null] The name of the pre-trained model to use. If not specified, the default model for the task will be used.\n * @param {PretrainedOptions} [options] Optional parameters for the pipeline.\n * @returns {Promise<Pipeline>} A Pipeline object for the specified task.\n * @throws {Error} If an unsupported pipeline is requested.\n */\nasync function pipeline(\n    task,\n    model = null,\n    {\n        quantized = true,\n        progress_callback = null,\n        config = null,\n        cache_dir = null,\n        local_files_only = false,\n        revision = 'main',\n    } = {}\n) {\n    // Helper method to construct pipeline\n\n    // Apply aliases\n    task = TASK_ALIASES[task] ?? task;\n\n    // Get pipeline info\n    let pipelineInfo = SUPPORTED_TASKS[task.split('_', 1)[0]];\n    if (!pipelineInfo) {\n        throw Error(`Unsupported pipeline: ${task}. Must be one of [${Object.keys(SUPPORTED_TASKS)}]`)\n    }\n\n    // Use model if specified, otherwise, use default\n    if (!model) {\n        model = pipelineInfo.default.model\n        console.log(`No model specified. Using default model: \"${model}\".`);\n    }\n\n    let tokenizerClass = pipelineInfo.tokenizer;\n    let modelClass = pipelineInfo.model;\n    let pipelineClass = pipelineInfo.pipeline;\n    let processorClass = pipelineInfo.processor;\n\n    let promises = [];\n\n    let pretrainedOptions = {\n        quantized,\n        progress_callback,\n        config,\n        cache_dir,\n        local_files_only,\n        revision,\n    }\n    if (tokenizerClass) {\n        promises.push(\n            tokenizerClass.from_pretrained(model, pretrainedOptions),\n        )\n    }\n    if (modelClass) {\n        promises.push(\n            modelClass.from_pretrained(model, pretrainedOptions)\n        )\n    }\n\n    if (processorClass) {\n        promises.push(\n            processorClass.from_pretrained(model, pretrainedOptions)\n        )\n    }\n\n    // Load tokenizer and model\n    let items = await Promise.all(promises)\n\n    ;(0,_utils_core_js__WEBPACK_IMPORTED_MODULE_3__.dispatchCallback)(progress_callback, {\n        'status': 'ready',\n        'task': task,\n        'model': model,\n    });\n\n    return new pipelineClass(task, ...items);\n\n}\n\n/**\n * Compute the Cartesian product of given arrays\n * @param {...Array} a Arrays to compute the product\n * @returns {Array} Returns the computed Cartesian product as an array\n * @private\n */\nfunction product(...a) {\n    // Cartesian product of items\n    // Adapted from https://stackoverflow.com/a/43053803\n    return a.reduce((a, b) => a.flatMap(d => b.map(e => [d, e])));\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHhlbm92YS90cmFuc2Zvcm1lcnMvc3JjL3BpcGVsaW5lcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFdBQVc7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsUUFBUSwwQ0FBMEM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7O0FBS3lCO0FBY0o7QUFJSTs7O0FBUUE7QUFNQztBQUdBO0FBR0M7QUFDaUI7O0FBRTVDO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYSxnQkFBZ0I7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsK0NBQStDLHFEQUFRO0FBQ3ZEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLHVCQUF1QixvREFBUTtBQUN0QztBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUscUJBQXFCO0FBQ3BDLGVBQWUsaUJBQWlCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsZUFBZTtBQUNoQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxLQUFLO0FBQ3BCLGlCQUFpQixjQUFjO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSxlQUFlLEtBQUs7QUFDcEIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsMEJBQTBCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLE1BQU0sSUFBSTs7QUFFVjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsNERBQVcsQ0FBQyx3REFBTzs7QUFFNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFD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LHFCQUFxQix5REFBYTtBQUNsQztBQUNBLGlCQUFpQixpREFBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLDRDQUE0QztBQUN6RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsbUJBQW1CO0FBQzlCLGFBQWEsbUJBQW1CO0FBQ2hDLFlBQVksT0FBTztBQUNuQjtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsS0FBSyxvQkFBb0IsNkJBQTZCO0FBQ25HOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSxNQUFNO0FBQ3ZFOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsSUFBSSxpRUFBZ0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3RyYW5zZm9ybWVyc2pzLXBsYXlncm91bmQvLi9ub2RlX21vZHVsZXMvQHhlbm92YS90cmFuc2Zvcm1lcnMvc3JjL3BpcGVsaW5lcy5qcz8xM2EwIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGZpbGUgUGlwZWxpbmVzIHByb3ZpZGUgYSBoaWdoLWxldmVsLCBlYXN5IHRvIHVzZSwgQVBJIGZvciBydW5uaW5nIG1hY2hpbmUgbGVhcm5pbmcgbW9kZWxzLlxuICogXG4gKiAqKkV4YW1wbGU6KiogSW5zdGFudGlhdGUgcGlwZWxpbmUgdXNpbmcgdGhlIGBwaXBlbGluZWAgZnVuY3Rpb24uXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBpbXBvcnQgeyBwaXBlbGluZSB9IGZyb20gJ0B4ZW5vdmEvdHJhbnNmb3JtZXJzJztcbiAqIFxuICogbGV0IGNsYXNzaWZpZXIgPSBhd2FpdCBwaXBlbGluZSgnc2VudGltZW50LWFuYWx5c2lzJyk7XG4gKiBsZXQgcmVzdWx0ID0gYXdhaXQgY2xhc3NpZmllcignSSBsb3ZlIHRyYW5zZm9ybWVycyEnKTtcbiAqIC8vIFt7J2xhYmVsJzogJ1BPU0lUSVZFJywgJ3Njb3JlJzogMC45OTk4MTc2ODZ9XVxuICogYGBgXG4gKiBcbiAqIEBtb2R1bGUgcGlwZWxpbmVzXG4gKi9cblxuaW1wb3J0IHtcbiAgICBBdXRvVG9rZW5pemVyLFxuICAgIFByZVRyYWluZWRUb2tlbml6ZXIsXG59IGZyb20gJy4vdG9rZW5pemVycy5qcyc7XG5pbXBvcnQge1xuICAgIEF1dG9Nb2RlbCxcbiAgICBBdXRvTW9kZWxGb3JTZXF1ZW5jZUNsYXNzaWZpY2F0aW9uLFxuICAgIEF1dG9Nb2RlbEZvclRva2VuQ2xhc3NpZmljYXRpb24sXG4gICAgQXV0b01vZGVsRm9yUXVlc3Rpb25BbnN3ZXJpbmcsXG4gICAgQXV0b01vZGVsRm9yTWFza2VkTE0sXG4gICAgQXV0b01vZGVsRm9yU2VxMlNlcUxNLFxuICAgIEF1dG9Nb2RlbEZvckNhdXNhbExNLFxuICAgIEF1dG9Nb2RlbEZvclZpc2lvbjJTZXEsXG4gICAgQXV0b01vZGVsRm9ySW1hZ2VDbGFzc2lmaWNhdGlvbixcbiAgICBBdXRvTW9kZWxGb3JJbWFnZVNlZ21lbnRhdGlvbixcbiAgICBBdXRvTW9kZWxGb3JPYmplY3REZXRlY3Rpb24sXG4gICAgUHJlVHJhaW5lZE1vZGVsLFxufSBmcm9tICcuL21vZGVscy5qcyc7XG5pbXBvcnQge1xuICAgIEF1dG9Qcm9jZXNzb3IsXG4gICAgUHJvY2Vzc29yXG59IGZyb20gJy4vcHJvY2Vzc29ycy5qcyc7XG5cblxuaW1wb3J0IHtcbiAgICBDYWxsYWJsZSxcbiAgICBpc1N0cmluZyxcbiAgICBkaXNwYXRjaENhbGxiYWNrLFxuICAgIHBvcCxcbn0gZnJvbSAnLi91dGlscy9jb3JlLmpzJztcbmltcG9ydCB7XG4gICAgc29mdG1heCxcbiAgICBtYXgsXG4gICAgZ2V0VG9wSXRlbXMsXG4gICAgcm91bmQsXG59IGZyb20gJy4vdXRpbHMvbWF0aHMuanMnO1xuaW1wb3J0IHtcbiAgICByZWFkX2F1ZGlvXG59IGZyb20gJy4vdXRpbHMvYXVkaW8uanMnO1xuaW1wb3J0IHtcbiAgICBtZWFuX3Bvb2xpbmcsXG59IGZyb20gJy4vdXRpbHMvdGVuc29yLmpzJztcbmltcG9ydCB7IFJhd0ltYWdlIH0gZnJvbSAnLi91dGlscy9pbWFnZS5qcyc7XG5cbi8qKlxuICogUHJlcGFyZSBpbWFnZXMgZm9yIGZ1cnRoZXIgdGFza3MuXG4gKiBAcGFyYW0ge2FueVtdfSBpbWFnZXMgaW1hZ2VzIHRvIHByZXBhcmUuXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxhbnlbXT59IHJldHVybnMgcHJvY2Vzc2VkIGltYWdlcy5cbiAqIEBwcml2YXRlXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHByZXBhcmVJbWFnZXMoaW1hZ2VzKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGltYWdlcykpIHtcbiAgICAgICAgaW1hZ2VzID0gW2ltYWdlc107XG4gICAgfVxuXG4gICAgLy8gUG9zc2libHkgY29udmVydCBhbnkgbm9uLWltYWdlcyB0byBpbWFnZXNcbiAgICBpbWFnZXMgPSBhd2FpdCBQcm9taXNlLmFsbChpbWFnZXMubWFwKHggPT4gUmF3SW1hZ2UucmVhZCh4KSkpO1xuICAgIHJldHVybiBpbWFnZXM7XG59XG5cbi8qKlxuICogVGhlIFBpcGVsaW5lIGNsYXNzIGlzIHRoZSBjbGFzcyBmcm9tIHdoaWNoIGFsbCBwaXBlbGluZXMgaW5oZXJpdC5cbiAqIFJlZmVyIHRvIHRoaXMgY2xhc3MgZm9yIG1ldGhvZHMgc2hhcmVkIGFjcm9zcyBkaWZmZXJlbnQgcGlwZWxpbmVzLlxuICogQGV4dGVuZHMgQ2FsbGFibGVcbiAqL1xuZXhwb3J0IGNsYXNzIFBpcGVsaW5lIGV4dGVuZHMgQ2FsbGFibGUge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBQaXBlbGluZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGFzayBUaGUgdGFzayBvZiB0aGUgcGlwZWxpbmUuIFVzZWZ1bCBmb3Igc3BlY2lmeWluZyBzdWJ0YXNrcy5cbiAgICAgKiBAcGFyYW0ge1ByZVRyYWluZWRUb2tlbml6ZXJ9IHRva2VuaXplciBUaGUgdG9rZW5pemVyIHRvIHVzZS5cbiAgICAgKiBAcGFyYW0ge1ByZVRyYWluZWRNb2RlbH0gbW9kZWwgVGhlIG1vZGVsIHRvIHVzZS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih0YXNrLCB0b2tlbml6ZXIsIG1vZGVsKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMudGFzayA9IHRhc2s7XG4gICAgICAgIHRoaXMudG9rZW5pemVyID0gdG9rZW5pemVyO1xuICAgICAgICB0aGlzLm1vZGVsID0gbW9kZWw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGlzcG9zZXMgdGhlIG1vZGVsLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aGVuIHRoZSBtb2RlbCBoYXMgYmVlbiBkaXNwb3NlZC5cbiAgICAgKi9cbiAgICBhc3luYyBkaXNwb3NlKCkge1xuICAgICAgICBhd2FpdCB0aGlzLm1vZGVsLmRpc3Bvc2UoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFeGVjdXRlcyB0aGUgdGFzayBhc3NvY2lhdGVkIHdpdGggdGhlIHBpcGVsaW5lLlxuICAgICAqIEBwYXJhbSB7YW55fSB0ZXh0cyBUaGUgaW5wdXQgdGV4dHMgdG8gYmUgcHJvY2Vzc2VkLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPGFueT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIGlucHV0cyBhbmQgb3V0cHV0cyBvZiB0aGUgdGFzay5cbiAgICAgKi9cbiAgICBhc3luYyBfY2FsbCh0ZXh0cykge1xuICAgICAgICAvLyBSdW4gdG9rZW5pemF0aW9uXG4gICAgICAgIGxldCBpbnB1dHMgPSB0aGlzLnRva2VuaXplcih0ZXh0cywge1xuICAgICAgICAgICAgcGFkZGluZzogdHJ1ZSxcbiAgICAgICAgICAgIHRydW5jYXRpb246IHRydWVcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gUnVuIG1vZGVsXG4gICAgICAgIGxldCBvdXRwdXRzID0gYXdhaXQgdGhpcy5tb2RlbChpbnB1dHMpXG5cbiAgICAgICAgcmV0dXJuIFtpbnB1dHMsIG91dHB1dHNdO1xuICAgIH1cbn1cblxuLyoqXG4gKiBUZXh0IGNsYXNzaWZpY2F0aW9uIHBpcGVsaW5lIHVzaW5nIGFueSBgTW9kZWxGb3JTZXF1ZW5jZUNsYXNzaWZpY2F0aW9uYC5cbiAqIEBleHRlbmRzIFBpcGVsaW5lXG4gKi9cbmV4cG9ydCBjbGFzcyBUZXh0Q2xhc3NpZmljYXRpb25QaXBlbGluZSBleHRlbmRzIFBpcGVsaW5lIHtcbiAgICAvKipcbiAgICAgKiBFeGVjdXRlcyB0aGUgdGV4dCBjbGFzc2lmaWNhdGlvbiB0YXNrLlxuICAgICAqIEBwYXJhbSB7YW55fSB0ZXh0cyBUaGUgaW5wdXQgdGV4dHMgdG8gYmUgY2xhc3NpZmllZC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBBbiBvcHRpb25hbCBvYmplY3QgY29udGFpbmluZyB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnRvcGs9MV0gVGhlIG51bWJlciBvZiB0b3AgcHJlZGljdGlvbnMgdG8gYmUgcmV0dXJuZWQuXG4gICAgICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0W118T2JqZWN0Pn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYW4gYXJyYXkgb3Igb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHByZWRpY3RlZCBsYWJlbHMgYW5kIHNjb3Jlcy5cbiAgICAgKi9cbiAgICBhc3luYyBfY2FsbCh0ZXh0cywge1xuICAgICAgICB0b3BrID0gMVxuICAgIH0gPSB7fSkge1xuXG4gICAgICAgIGxldCBbaW5wdXRzLCBvdXRwdXRzXSA9IGF3YWl0IHN1cGVyLl9jYWxsKHRleHRzKTtcblxuICAgICAgICBsZXQgaWQybGFiZWwgPSB0aGlzLm1vZGVsLmNvbmZpZy5pZDJsYWJlbDtcbiAgICAgICAgbGV0IHRvUmV0dXJuID0gW107XG4gICAgICAgIGZvciAobGV0IGJhdGNoIG9mIG91dHB1dHMubG9naXRzKSB7XG4gICAgICAgICAgICBsZXQgc2NvcmVzID0gZ2V0VG9wSXRlbXMoc29mdG1heChiYXRjaC5kYXRhKSwgdG9wayk7XG5cbiAgICAgICAgICAgIGxldCB2YWxzID0gc2NvcmVzLm1hcChmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGxhYmVsOiBpZDJsYWJlbFt4WzBdXSxcbiAgICAgICAgICAgICAgICAgICAgc2NvcmU6IHhbMV0sXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAodG9wayA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHRvUmV0dXJuLnB1c2goLi4udmFscyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRvUmV0dXJuLnB1c2godmFscyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh0ZXh0cykgfHwgdG9wayA9PT0gMSA/IHRvUmV0dXJuIDogdG9SZXR1cm5bMF07XG4gICAgfVxufVxuXG5cbi8qKlxuICogTmFtZWQgRW50aXR5IFJlY29nbml0aW9uIHBpcGVsaW5lIHVzaW5nIGFueSBgTW9kZWxGb3JUb2tlbkNsYXNzaWZpY2F0aW9uYC5cbiAqIEBleHRlbmRzIFBpcGVsaW5lXG4gKi9cbmV4cG9ydCBjbGFzcyBUb2tlbkNsYXNzaWZpY2F0aW9uUGlwZWxpbmUgZXh0ZW5kcyBQaXBlbGluZSB7XG4gICAgLyoqXG4gICAgICogRXhlY3V0ZXMgdGhlIHRva2VuIGNsYXNzaWZpY2F0aW9uIHRhc2suXG4gICAgICogQHBhcmFtIHthbnl9IHRleHRzIFRoZSBpbnB1dCB0ZXh0cyB0byBiZSBjbGFzc2lmaWVkLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIEFuIG9wdGlvbmFsIG9iamVjdCBjb250YWluaW5nIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3RbXXxPYmplY3Q+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhbiBhcnJheSBvciBvYmplY3QgY29udGFpbmluZyB0aGUgcHJlZGljdGVkIGxhYmVscyBhbmQgc2NvcmVzLlxuICAgICAqL1xuICAgIGFzeW5jIF9jYWxsKHRleHRzLCB7XG4gICAgICAgIGlnbm9yZV9sYWJlbHMgPSBbJ08nXSwgLy8gVE9ETyBpbml0IHBhcmFtP1xuICAgIH0gPSB7fSkge1xuXG4gICAgICAgIGxldCBpc0JhdGNoZWQgPSBBcnJheS5pc0FycmF5KHRleHRzKTtcblxuICAgICAgICBpZiAoIWlzQmF0Y2hlZCkge1xuICAgICAgICAgICAgdGV4dHMgPSBbdGV4dHNdO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHRva2VuaXplciA9IHRoaXMudG9rZW5pemVyO1xuICAgICAgICBsZXQgW2lucHV0cywgb3V0cHV0c10gPSBhd2FpdCBzdXBlci5fY2FsbCh0ZXh0cyk7XG5cbiAgICAgICAgbGV0IGxvZ2l0cyA9IG91dHB1dHMubG9naXRzO1xuICAgICAgICBsZXQgaWQybGFiZWwgPSB0aGlzLm1vZGVsLmNvbmZpZy5pZDJsYWJlbDtcblxuICAgICAgICBsZXQgdG9SZXR1cm4gPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsb2dpdHMuZGltc1swXTsgKytpKSB7XG4gICAgICAgICAgICBsZXQgaWRzID0gaW5wdXRzLmlucHV0X2lkc1tpXTtcbiAgICAgICAgICAgIGxldCBiYXRjaCA9IGxvZ2l0c1tpXTtcblxuICAgICAgICAgICAgLy8gTGlzdCBvZiB0b2tlbnMgdGhhdCBhcmVuJ3QgaWdub3JlZFxuICAgICAgICAgICAgbGV0IHRva2VucyA9IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBiYXRjaC5kaW1zWzBdOyArK2opIHtcbiAgICAgICAgICAgICAgICBsZXQgdG9rZW5EYXRhID0gYmF0Y2hbal07XG4gICAgICAgICAgICAgICAgbGV0IHRvcFNjb3JlSW5kZXggPSBtYXgodG9rZW5EYXRhLmRhdGEpWzFdO1xuXG4gICAgICAgICAgICAgICAgbGV0IGVudGl0eSA9IGlkMmxhYmVsW3RvcFNjb3JlSW5kZXhdO1xuICAgICAgICAgICAgICAgIGlmIChpZ25vcmVfbGFiZWxzLmluY2x1ZGVzKGVudGl0eSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgcHJlZGljdGVkIGEgdG9rZW4gdGhhdCBzaG91bGQgYmUgaWdub3JlZC4gU28sIHdlIHNraXAgaXQuXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFRPRE8gYWRkIG9wdGlvbiB0byBrZWVwIHNwZWNpYWwgdG9rZW5zP1xuICAgICAgICAgICAgICAgIGxldCB3b3JkID0gdG9rZW5pemVyLmRlY29kZShbaWRzW2pdLml0ZW0oKV0sIHsgc2tpcF9zcGVjaWFsX3Rva2VuczogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICBpZiAod29yZCA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2FzIGEgc3BlY2lhbCB0b2tlbi4gU28sIHdlIHNraXAgaXQuXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGxldCBzY29yZXMgPSBzb2Z0bWF4KHRva2VuRGF0YS5kYXRhKTtcblxuICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgZW50aXR5OiBlbnRpdHksXG4gICAgICAgICAgICAgICAgICAgIHNjb3JlOiBzY29yZXNbdG9wU2NvcmVJbmRleF0sXG4gICAgICAgICAgICAgICAgICAgIGluZGV4OiBqLFxuICAgICAgICAgICAgICAgICAgICB3b3JkOiB3b3JkLFxuXG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IG51bGwgZm9yIG5vdywgYnV0IHdpbGwgYWRkXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBlbmQ6IG51bGwsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0b1JldHVybi5wdXNoKHRva2Vucyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlzQmF0Y2hlZCA/IHRvUmV0dXJuIDogdG9SZXR1cm5bMF07XG4gICAgfVxufVxuLyoqXG4gKiBRdWVzdGlvbiBBbnN3ZXJpbmcgcGlwZWxpbmUgdXNpbmcgYW55IGBNb2RlbEZvclF1ZXN0aW9uQW5zd2VyaW5nYC5cbiAqIFxuICogKipFeGFtcGxlOioqIFJ1biBxdWVzdGlvbiBhbnN3ZXJpbmcgd2l0aCBgZGlzdGlsYmVydC1iYXNlLXVuY2FzZWQtZGlzdGlsbGVkLXNxdWFkYC5cbiAqIGBgYGphdmFzY3JpcHRcbiAqIGxldCBxdWVzdGlvbiA9ICdXaG8gd2FzIEppbSBIZW5zb24/JztcbiAqIGxldCBjb250ZXh0ID0gJ0ppbSBIZW5zb24gd2FzIGEgbmljZSBwdXBwZXQuJztcbiAqIFxuICogbGV0IGFuc3dlcmVyID0gYXdhaXQgcGlwZWxpbmUoJ3F1ZXN0aW9uLWFuc3dlcmluZycsICdYZW5vdmEvZGlzdGlsYmVydC1iYXNlLXVuY2FzZWQtZGlzdGlsbGVkLXNxdWFkJyk7XG4gKiBsZXQgb3V0cHV0cyA9IGF3YWl0IGFuc3dlcmVyKHF1ZXN0aW9uLCBjb250ZXh0KTtcbiAqIGNvbnNvbGUubG9nKG91dHB1dHMpO1xuICogLy8ge1xuICogLy8gICAgIFwiYW5zd2VyXCI6IFwiYSBuaWNlIHB1cHBldFwiLFxuICogLy8gICAgIFwic2NvcmVcIjogMC41NzY4OTExNTAyNTI2NzQxXG4gKiAvLyB9XG4gKiBgYGBcbiAqIEBleHRlbmRzIFBpcGVsaW5lXG4gKi9cbmV4cG9ydCBjbGFzcyBRdWVzdGlvbkFuc3dlcmluZ1BpcGVsaW5lIGV4dGVuZHMgUGlwZWxpbmUge1xuICAgIC8qKlxuICAgICAqIEV4ZWN1dGVzIHRoZSBxdWVzdGlvbiBhbnN3ZXJpbmcgdGFzay5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXX0gcXVlc3Rpb24gVGhlIHF1ZXN0aW9uKHMpIHRvIGJlIGFuc3dlcmVkLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfHN0cmluZ1tdfSBjb250ZXh0IFRoZSBjb250ZXh0KHMpIHdoZXJlIHRoZSBhbnN3ZXIocykgY2FuIGJlIGZvdW5kLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIEFuIG9wdGlvbmFsIG9iamVjdCBjb250YWluaW5nIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMudG9waz0xXSBUaGUgbnVtYmVyIG9mIHRvcCBhbnN3ZXIgcHJlZGljdGlvbnMgdG8gYmUgcmV0dXJuZWQuXG4gICAgICogQHJldHVybnMge1Byb21pc2U8YW55Pn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYW4gYXJyYXkgb3Igb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHByZWRpY3RlZCBhbnN3ZXJzIGFuZCBzY29yZXMuXG4gICAgICovXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGFzeW5jIF9jYWxsKHF1ZXN0aW9uLCBjb250ZXh0LCB7XG4gICAgICAgIHRvcGsgPSAxXG4gICAgfSA9IHt9KSB7XG5cbiAgICAgICAgLy8gUnVuIHRva2VuaXphdGlvblxuICAgICAgICBsZXQgaW5wdXRzID0gdGhpcy50b2tlbml6ZXIocXVlc3Rpb24sIHtcbiAgICAgICAgICAgIHRleHRfcGFpcjogY29udGV4dCxcbiAgICAgICAgICAgIHBhZGRpbmc6IHRydWUsXG4gICAgICAgICAgICB0cnVuY2F0aW9uOiB0cnVlXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGxldCBvdXRwdXQgPSBhd2FpdCB0aGlzLm1vZGVsKGlucHV0cyk7XG5cbiAgICAgICAgbGV0IHRvUmV0dXJuID0gW107XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgb3V0cHV0LnN0YXJ0X2xvZ2l0cy5kaW1zWzBdOyArK2opIHtcbiAgICAgICAgICAgIGxldCBpZHMgPSBpbnB1dHMuaW5wdXRfaWRzW2pdO1xuICAgICAgICAgICAgbGV0IHNlcEluZGV4ID0gaWRzLmluZGV4T2YodGhpcy50b2tlbml6ZXIuc2VwX3Rva2VuX2lkKTtcblxuICAgICAgICAgICAgbGV0IHMxID0gQXJyYXkuZnJvbShzb2Z0bWF4KG91dHB1dC5zdGFydF9sb2dpdHNbal0uZGF0YSkpXG4gICAgICAgICAgICAgICAgLm1hcCgoeCwgaSkgPT4gW3gsIGldKVxuICAgICAgICAgICAgICAgIC5maWx0ZXIoeCA9PiB4WzFdID4gc2VwSW5kZXgpO1xuICAgICAgICAgICAgbGV0IGUxID0gQXJyYXkuZnJvbShzb2Z0bWF4KG91dHB1dC5lbmRfbG9naXRzW2pdLmRhdGEpKVxuICAgICAgICAgICAgICAgIC5tYXAoKHgsIGkpID0+IFt4LCBpXSlcbiAgICAgICAgICAgICAgICAuZmlsdGVyKHggPT4geFsxXSA+IHNlcEluZGV4KTtcblxuICAgICAgICAgICAgbGV0IG9wdGlvbnMgPSBwcm9kdWN0KHMxLCBlMSlcbiAgICAgICAgICAgICAgICAuZmlsdGVyKHggPT4geFswXVsxXSA8PSB4WzFdWzFdKVxuICAgICAgICAgICAgICAgIC5tYXAoeCA9PiBbeFswXVsxXSwgeFsxXVsxXSwgeFswXVswXSAqIHhbMV1bMF1dKVxuICAgICAgICAgICAgICAgIC5zb3J0KChhLCBiKSA9PiBiWzJdIC0gYVsyXSk7XG5cbiAgICAgICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgTWF0aC5taW4ob3B0aW9ucy5sZW5ndGgsIHRvcGspOyArK2spIHtcbiAgICAgICAgICAgICAgICBsZXQgW3N0YXJ0LCBlbmQsIHNjb3JlXSA9IG9wdGlvbnNba107XG5cbiAgICAgICAgICAgICAgICBsZXQgYW5zd2VyX3Rva2VucyA9IFsuLi5pZHNdLnNsaWNlKHN0YXJ0LCBlbmQgKyAxKVxuXG4gICAgICAgICAgICAgICAgbGV0IGFuc3dlciA9IHRoaXMudG9rZW5pemVyLmRlY29kZShhbnN3ZXJfdG9rZW5zLCB7XG4gICAgICAgICAgICAgICAgICAgIHNraXBfc3BlY2lhbF90b2tlbnM6IHRydWUsXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAvLyBUT0RPIGFkZCBzdGFydCBhbmQgZW5kP1xuICAgICAgICAgICAgICAgIC8vIE5PVEU6IEhGIHJldHVybnMgY2hhcmFjdGVyIGluZGV4XG4gICAgICAgICAgICAgICAgdG9SZXR1cm4ucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGFuc3dlciwgc2NvcmVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE1pbWljIEhGJ3MgcmV0dXJuIHR5cGUgYmFzZWQgb24gdG9wa1xuICAgICAgICByZXR1cm4gKHRvcGsgPT09IDEpID8gdG9SZXR1cm5bMF0gOiB0b1JldHVybjtcblxuICAgIH1cbn1cblxuLyoqXG4gKiBNYXNrZWQgbGFuZ3VhZ2UgbW9kZWxpbmcgcHJlZGljdGlvbiBwaXBlbGluZSB1c2luZyBhbnkgYE1vZGVsV2l0aExNSGVhZGAuXG4gKiBAZXh0ZW5kcyBQaXBlbGluZVxuICovXG5leHBvcnQgY2xhc3MgRmlsbE1hc2tQaXBlbGluZSBleHRlbmRzIFBpcGVsaW5lIHtcbiAgICAvKipcbiAgICAgKiBGaWxsIHRoZSBtYXNrZWQgdG9rZW4gaW4gdGhlIHRleHQocykgZ2l2ZW4gYXMgaW5wdXRzLlxuICAgICAqIEBwYXJhbSB7YW55fSB0ZXh0cyBUaGUgbWFza2VkIGlucHV0IHRleHRzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIEFuIG9wdGlvbmFsIG9iamVjdCBjb250YWluaW5nIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMudG9waz01XSBUaGUgbnVtYmVyIG9mIHRvcCBwcmVkaWN0aW9ucyB0byBiZSByZXR1cm5lZC5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3RbXXxPYmplY3Q+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhbiBhcnJheSBvciBvYmplY3QgY29udGFpbmluZyB0aGUgcHJlZGljdGVkIHRva2VucyBhbmQgc2NvcmVzLlxuICAgICAqL1xuICAgIGFzeW5jIF9jYWxsKHRleHRzLCB7XG4gICAgICAgIHRvcGsgPSA1XG4gICAgfSA9IHt9KSB7XG4gICAgICAgIC8vIFJ1biB0b2tlbml6YXRpb25cbiAgICAgICAgbGV0IFtpbnB1dHMsIG91dHB1dHNdID0gYXdhaXQgc3VwZXIuX2NhbGwodGV4dHMpO1xuXG4gICAgICAgIC8vIERldGVybWluZSBpbmRpY2VzIG9mIG1hc2sgdG9rZW5zXG4gICAgICAgIC8vIGxldCBtYXNrX3Rva2VuX2luZGljZXMgPSBpbnB1dHMuaW5wdXRfaWRzLmRhdGEubWFwKHggPT4gKVxuXG4gICAgICAgIC8vIGxldCBsb2dpdHMgPSByZXNoYXBlKG91dHB1dHMubG9naXRzLmRhdGEsIG91dHB1dHMubG9naXRzLmRpbXMpO1xuXG4gICAgICAgIGxldCB0b2tlbml6ZXIgPSB0aGlzLnRva2VuaXplcjtcblxuICAgICAgICBsZXQgdG9SZXR1cm4gPSBbXTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0cy5pbnB1dF9pZHMuZGltc1swXTsgKytpKSB7XG4gICAgICAgICAgICBsZXQgaWRzID0gaW5wdXRzLmlucHV0X2lkc1tpXTtcbiAgICAgICAgICAgIGxldCBtYXNrX3Rva2VuX2luZGV4ID0gaWRzLmluZGV4T2YodGhpcy50b2tlbml6ZXIubWFza190b2tlbl9pZClcblxuICAgICAgICAgICAgaWYgKG1hc2tfdG9rZW5faW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoYE1hc2sgdG9rZW4gKCR7dG9rZW5pemVyLm1hc2tfdG9rZW59KSBub3QgZm91bmQgaW4gdGV4dC5gKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGxvZ2l0cyA9IG91dHB1dHMubG9naXRzW2ldO1xuICAgICAgICAgICAgbGV0IGl0ZW1Mb2dpdHMgPSBsb2dpdHNbbWFza190b2tlbl9pbmRleF07XG5cbiAgICAgICAgICAgIGxldCBzY29yZXMgPSBnZXRUb3BJdGVtcyhzb2Z0bWF4KGl0ZW1Mb2dpdHMuZGF0YSksIHRvcGspO1xuXG4gICAgICAgICAgICB0b1JldHVybi5wdXNoKHNjb3Jlcy5tYXAoeCA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IHNlcXVlbmNlID0gWy4uLmlkc107XG4gICAgICAgICAgICAgICAgc2VxdWVuY2VbbWFza190b2tlbl9pbmRleF0gPSB4WzBdO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgc2NvcmU6IHhbMV0sXG4gICAgICAgICAgICAgICAgICAgIHRva2VuOiB4WzBdLFxuICAgICAgICAgICAgICAgICAgICB0b2tlbl9zdHI6IHRva2VuaXplci5tb2RlbC52b2NhYlt4WzBdXSxcbiAgICAgICAgICAgICAgICAgICAgc2VxdWVuY2U6IHRva2VuaXplci5kZWNvZGUoc2VxdWVuY2UsIHsgc2tpcF9zcGVjaWFsX3Rva2VuczogdHJ1ZSB9KSxcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodGV4dHMpID8gdG9SZXR1cm4gOiB0b1JldHVyblswXTtcbiAgICB9XG59XG5cbi8qKlxuICogVGV4dDJUZXh0R2VuZXJhdGlvblBpcGVsaW5lIGNsYXNzIGZvciBnZW5lcmF0aW5nIHRleHQgdXNpbmcgYSBtb2RlbCB0aGF0IHBlcmZvcm1zIHRleHQtdG8tdGV4dCBnZW5lcmF0aW9uIHRhc2tzLlxuICogQGV4dGVuZHMgUGlwZWxpbmVcbiAqL1xuZXhwb3J0IGNsYXNzIFRleHQyVGV4dEdlbmVyYXRpb25QaXBlbGluZSBleHRlbmRzIFBpcGVsaW5lIHtcbiAgICBfa2V5ID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEZpbGwgdGhlIG1hc2tlZCB0b2tlbiBpbiB0aGUgdGV4dChzKSBnaXZlbiBhcyBpbnB1dHMuXG4gICAgICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IHRleHRzIFRoZSB0ZXh0IG9yIGFycmF5IG9mIHRleHRzIHRvIGJlIHByb2Nlc3NlZC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIE9wdGlvbnMgZm9yIHRoZSBmaWxsLW1hc2sgcGlwZWxpbmUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnRvcGs9NV0gVGhlIG51bWJlciBvZiB0b3AtayBwcmVkaWN0aW9ucyB0byByZXR1cm4uXG4gICAgICogQHJldHVybnMge1Byb21pc2U8YW55Pn0gQW4gYXJyYXkgb2Ygb2JqZWN0cyBjb250YWluaW5nIHRoZSBzY29yZSwgcHJlZGljdGVkIHRva2VuLCBwcmVkaWN0ZWQgdG9rZW4gc3RyaW5nLFxuICAgICAqIGFuZCB0aGUgc2VxdWVuY2Ugd2l0aCB0aGUgcHJlZGljdGVkIHRva2VuIGZpbGxlZCBpbiwgb3IgYW4gYXJyYXkgb2Ygc3VjaCBhcnJheXMgKG9uZSBmb3IgZWFjaCBpbnB1dCB0ZXh0KS5cbiAgICAgKiBJZiBvbmx5IG9uZSBpbnB1dCB0ZXh0IGlzIGdpdmVuLCB0aGUgb3V0cHV0IHdpbGwgYmUgYW4gYXJyYXkgb2Ygb2JqZWN0cy5cbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gV2hlbiB0aGUgbWFzayB0b2tlbiBpcyBub3QgZm91bmQgaW4gdGhlIGlucHV0IHRleHQuXG4gICAgICovXG4gICAgYXN5bmMgX2NhbGwodGV4dHMsIGdlbmVyYXRlX2t3YXJncyA9IHt9KSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh0ZXh0cykpIHtcbiAgICAgICAgICAgIHRleHRzID0gW3RleHRzXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFkZCBnbG9iYWwgcHJlZml4LCBpZiBwcmVzZW50XG4gICAgICAgIGlmICh0aGlzLm1vZGVsLmNvbmZpZy5wcmVmaXgpIHtcbiAgICAgICAgICAgIHRleHRzID0gdGV4dHMubWFwKHggPT4gdGhpcy5tb2RlbC5jb25maWcucHJlZml4ICsgeClcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEhhbmRsZSB0YXNrIHNwZWNpZmljIHBhcmFtczpcbiAgICAgICAgbGV0IHRhc2tfc3BlY2lmaWNfcGFyYW1zID0gdGhpcy5tb2RlbC5jb25maWcudGFza19zcGVjaWZpY19wYXJhbXNcbiAgICAgICAgaWYgKHRhc2tfc3BlY2lmaWNfcGFyYW1zICYmIHRhc2tfc3BlY2lmaWNfcGFyYW1zW3RoaXMudGFza10pIHtcbiAgICAgICAgICAgIC8vIEFkZCBwcmVmaXhlcywgaWYgcHJlc2VudFxuICAgICAgICAgICAgaWYgKHRhc2tfc3BlY2lmaWNfcGFyYW1zW3RoaXMudGFza10ucHJlZml4KSB7XG4gICAgICAgICAgICAgICAgdGV4dHMgPSB0ZXh0cy5tYXAoeCA9PiB0YXNrX3NwZWNpZmljX3BhcmFtc1t0aGlzLnRhc2tdLnByZWZpeCArIHgpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFRPRE8gdXBkYXRlIGdlbmVyYXRpb24gY29uZmlnXG4gICAgICAgIH1cblxuICAgICAgICBsZXQgdG9rZW5pemVyX29wdGlvbnMgPSB7XG4gICAgICAgICAgICBwYWRkaW5nOiB0cnVlLFxuICAgICAgICAgICAgdHJ1bmNhdGlvbjogdHJ1ZSxcbiAgICAgICAgfVxuICAgICAgICBsZXQgaW5wdXRfaWRzO1xuICAgICAgICBpZiAodGhpcyBpbnN0YW5jZW9mIFRyYW5zbGF0aW9uUGlwZWxpbmUgJiYgJ19idWlsZF90cmFuc2xhdGlvbl9pbnB1dHMnIGluIHRoaXMudG9rZW5pemVyKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBtb3ZlIHRvIFRyYW5zbGF0aW9uIHBpcGVsaW5lP1xuICAgICAgICAgICAgLy8gQ3VycmVudGx5IHB1dCBoZXJlIHRvIGF2b2lkIGNvZGUgZHVwbGljYXRpb25cbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIGlucHV0X2lkcyA9IHRoaXMudG9rZW5pemVyLl9idWlsZF90cmFuc2xhdGlvbl9pbnB1dHModGV4dHMsIHRva2VuaXplcl9vcHRpb25zLCBnZW5lcmF0ZV9rd2FyZ3MpLmlucHV0X2lkcztcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaW5wdXRfaWRzID0gdGhpcy50b2tlbml6ZXIodGV4dHMsIHRva2VuaXplcl9vcHRpb25zKS5pbnB1dF9pZHM7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgb3V0cHV0VG9rZW5JZHMgPSBhd2FpdCB0aGlzLm1vZGVsLmdlbmVyYXRlKGlucHV0X2lkcywgZ2VuZXJhdGVfa3dhcmdzKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge2FueVtdfVxuICAgICAgICAgKi9cbiAgICAgICAgbGV0IHRvUmV0dXJuID0gdGhpcy50b2tlbml6ZXIuYmF0Y2hfZGVjb2RlKG91dHB1dFRva2VuSWRzLCB7XG4gICAgICAgICAgICBza2lwX3NwZWNpYWxfdG9rZW5zOiB0cnVlLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHRoaXMuX2tleSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdG9SZXR1cm4gPSB0b1JldHVybi5tYXAodGV4dCA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICh0aGlzLl9rZXkgPT09IG51bGwpID8gdGV4dCA6IHsgW3RoaXMuX2tleV06IHRleHQgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG9SZXR1cm5cbiAgICB9XG59XG5cblxuLyoqXG4gKiBBIHBpcGVsaW5lIGZvciBzdW1tYXJpemF0aW9uIHRhc2tzLCBpbmhlcml0aW5nIGZyb20gVGV4dDJUZXh0R2VuZXJhdGlvblBpcGVsaW5lLlxuICogQGV4dGVuZHMgVGV4dDJUZXh0R2VuZXJhdGlvblBpcGVsaW5lXG4gKi9cbmV4cG9ydCBjbGFzcyBTdW1tYXJpemF0aW9uUGlwZWxpbmUgZXh0ZW5kcyBUZXh0MlRleHRHZW5lcmF0aW9uUGlwZWxpbmUge1xuICAgIF9rZXkgPSAnc3VtbWFyeV90ZXh0Jztcbn1cblxuLyoqXG4gKiBUcmFuc2xhdGlvblBpcGVsaW5lIGNsYXNzIHRvIHRyYW5zbGF0ZSB0ZXh0IGZyb20gb25lIGxhbmd1YWdlIHRvIGFub3RoZXIgdXNpbmcgdGhlIHByb3ZpZGVkIG1vZGVsIGFuZCB0b2tlbml6ZXIuXG4gKiBAZXh0ZW5kcyBUZXh0MlRleHRHZW5lcmF0aW9uUGlwZWxpbmVcbiAqL1xuZXhwb3J0IGNsYXNzIFRyYW5zbGF0aW9uUGlwZWxpbmUgZXh0ZW5kcyBUZXh0MlRleHRHZW5lcmF0aW9uUGlwZWxpbmUge1xuICAgIF9rZXkgPSAndHJhbnNsYXRpb25fdGV4dCc7XG59XG5cbi8qKlxuICogTGFuZ3VhZ2UgZ2VuZXJhdGlvbiBwaXBlbGluZSB1c2luZyBhbnkgYE1vZGVsV2l0aExNSGVhZGAgb3IgYE1vZGVsRm9yQ2F1c2FsTE1gLlxuICogVGhpcyBwaXBlbGluZSBwcmVkaWN0cyB0aGUgd29yZHMgdGhhdCB3aWxsIGZvbGxvdyBhIHNwZWNpZmllZCB0ZXh0IHByb21wdC5cbiAqIE5PVEU6IEZvciB0aGUgZnVsbCBsaXN0IG9mIGdlbmVyYXRpb24gcGFyYW1ldGVycywgc2VlIFtgR2VuZXJhdGlvbkNvbmZpZ2BdKC4vdXRpbHMvZ2VuZXJhdGlvbiNtb2R1bGVfdXRpbHMvZ2VuZXJhdGlvbi5HZW5lcmF0aW9uQ29uZmlnKS5cbiAqIFxuICogKipFeGFtcGxlOioqIFRleHQgZ2VuZXJhdGlvbiB3aXRoIGBYZW5vdmEvZGlzdGlsZ3B0MmAgKGRlZmF1bHQgc2V0dGluZ3MpLlxuICogYGBgamF2YXNjcmlwdFxuICogbGV0IHRleHQgPSAnSSBlbmpveSB3YWxraW5nIHdpdGggbXkgY3V0ZSBkb2csJztcbiAqIGxldCBnZW5lcmF0b3IgPSBhd2FpdCBwaXBlbGluZSgndGV4dC1nZW5lcmF0aW9uJywgJ1hlbm92YS9kaXN0aWxncHQyJyk7XG4gKiBsZXQgb3V0cHV0ID0gYXdhaXQgZ2VuZXJhdG9yKHRleHQpO1xuICogY29uc29sZS5sb2cob3V0cHV0KTtcbiAqIC8vIFt7IGdlbmVyYXRlZF90ZXh0OiBcIkkgZW5qb3kgd2Fsa2luZyB3aXRoIG15IGN1dGUgZG9nLCBhbmQgSSBsb3ZlIHRvIHBsYXkgd2l0aCB0aGUgb3RoZXIgZG9ncy5cIiB9XVxuICogYGBgXG4gKiBcbiAqICoqRXhhbXBsZToqKiBUZXh0IGdlbmVyYXRpb24gd2l0aCBgWGVub3ZhL2Rpc3RpbGdwdDJgIChjdXN0b20gc2V0dGluZ3MpLlxuICogYGBgamF2YXNjcmlwdFxuICogbGV0IHRleHQgPSAnT25jZSB1cG9uIGEgdGltZSwgdGhlcmUgd2FzJztcbiAqIGxldCBnZW5lcmF0b3IgPSBhd2FpdCBwaXBlbGluZSgndGV4dC1nZW5lcmF0aW9uJywgJ1hlbm92YS9kaXN0aWxncHQyJyk7XG4gKiBsZXQgb3V0cHV0ID0gYXdhaXQgZ2VuZXJhdG9yKHRleHQsIHtcbiAqICAgICB0ZW1wZXJhdHVyZTogMixcbiAqICAgICBtYXhfbmV3X3Rva2VuczogMTAsXG4gKiAgICAgcmVwZXRpdGlvbl9wZW5hbHR5OiAxLjUsXG4gKiAgICAgbm9fcmVwZWF0X25ncmFtX3NpemU6IDIsXG4gKiAgICAgbnVtX2JlYW1zOiAyLFxuICogICAgIG51bV9yZXR1cm5fc2VxdWVuY2VzOiAyLFxuICogfSk7XG4gKiBjb25zb2xlLmxvZyhvdXRwdXQpO1xuICogLy8gW3tcbiAqIC8vICAgXCJnZW5lcmF0ZWRfdGV4dFwiOiBcIk9uY2UgdXBvbiBhIHRpbWUsIHRoZXJlIHdhcyBhbiBhYnVuZGFuY2Ugb2YgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGhpc3RvcnkgYW5kIGFjdGl2aXRpZXMgdGhhdFwiXG4gKiAvLyB9LCB7XG4gKiAvLyAgIFwiZ2VuZXJhdGVkX3RleHRcIjogXCJPbmNlIHVwb24gYSB0aW1lLCB0aGVyZSB3YXMgYW4gYWJ1bmRhbmNlIG9mIGluZm9ybWF0aW9uIGFib3V0IHRoZSBtb3N0IGltcG9ydGFudCBhbmQgaW5mbHVlbnRpYWxcIlxuICogLy8gfV1cbiAqIGBgYFxuICogXG4gKiAqKkV4YW1wbGU6KiogUnVuIGNvZGUgZ2VuZXJhdGlvbiB3aXRoIGBYZW5vdmEvY29kZWdlbi0zNTBNLW1vbm9gLlxuICogYGBgamF2YXNjcmlwdFxuICogbGV0IHRleHQgPSAnZGVmIGZpYihuKTonO1xuICogbGV0IGdlbmVyYXRvciA9IGF3YWl0IHBpcGVsaW5lKCd0ZXh0LWdlbmVyYXRpb24nLCAnWGVub3ZhL2NvZGVnZW4tMzUwTS1tb25vJyk7XG4gKiBsZXQgb3V0cHV0ID0gYXdhaXQgZ2VuZXJhdG9yKHRleHQsIHtcbiAqICAgICBtYXhfbmV3X3Rva2VuczogNDAsXG4gKiB9KTtcbiAqIGNvbnNvbGUubG9nKG91dHB1dFswXS5nZW5lcmF0ZWRfdGV4dCk7XG4gKiAvLyBkZWYgZmliKG4pOlxuICogLy8gICAgIGlmIG4gPT0gMDpcbiAqIC8vICAgICAgICAgcmV0dXJuIDBcbiAqIC8vICAgICBpZiBuID09IDE6XG4gKiAvLyAgICAgICAgIHJldHVybiAxXG4gKiAvLyAgICAgcmV0dXJuIGZpYihuLTEpICsgZmliKG4tMilcbiAqIGBgYFxuICogXG4gKiBAZXh0ZW5kcyBQaXBlbGluZVxuICovXG5leHBvcnQgY2xhc3MgVGV4dEdlbmVyYXRpb25QaXBlbGluZSBleHRlbmRzIFBpcGVsaW5lIHtcbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgdGV4dCBiYXNlZCBvbiBhbiBpbnB1dCBwcm9tcHQuXG4gICAgICogQHBhcmFtIHthbnl9IHRleHRzIFRoZSBpbnB1dCBwcm9tcHQgb3IgcHJvbXB0cyB0byBnZW5lcmF0ZSB0ZXh0IGZyb20uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtnZW5lcmF0ZV9rd2FyZ3M9e31dIEFkZGl0aW9uYWwgYXJndW1lbnRzIGZvciB0ZXh0IGdlbmVyYXRpb24uXG4gICAgICogQHJldHVybnMge1Byb21pc2U8YW55Pn0gVGhlIGdlbmVyYXRlZCB0ZXh0IG9yIHRleHRzLlxuICAgICAqL1xuICAgIGFzeW5jIF9jYWxsKHRleHRzLCBnZW5lcmF0ZV9rd2FyZ3MgPSB7fSkge1xuICAgICAgICBsZXQgc3RyaW5nSW5wdXQgPSB0eXBlb2YgdGV4dHMgPT09ICdzdHJpbmcnIHx8IHRleHRzIGluc3RhbmNlb2YgU3RyaW5nO1xuICAgICAgICBpZiAoc3RyaW5nSW5wdXQpIHtcbiAgICAgICAgICAgIHRleHRzID0gW3RleHRzXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudG9rZW5pemVyLnBhZGRpbmdfc2lkZSA9ICdsZWZ0JztcbiAgICAgICAgbGV0IGlucHV0cyA9IHRoaXMudG9rZW5pemVyKHRleHRzLCB7XG4gICAgICAgICAgICBwYWRkaW5nOiB0cnVlLFxuICAgICAgICAgICAgdHJ1bmNhdGlvbjogdHJ1ZSxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgbGV0IGlucHV0X2lkcyA9IGlucHV0cy5pbnB1dF9pZHM7XG4gICAgICAgIGxldCBhdHRlbnRpb25fbWFzayA9IGlucHV0cy5hdHRlbnRpb25fbWFzaztcblxuICAgICAgICBsZXQgb3V0cHV0VG9rZW5JZHMgPSBhd2FpdCB0aGlzLm1vZGVsLmdlbmVyYXRlKGlucHV0X2lkcywgZ2VuZXJhdGVfa3dhcmdzLCBudWxsLCB7XG4gICAgICAgICAgICBpbnB1dHNfYXR0ZW50aW9uX21hc2s6IGF0dGVudGlvbl9tYXNrXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IGRlY29kZWQgPSB0aGlzLnRva2VuaXplci5iYXRjaF9kZWNvZGUob3V0cHV0VG9rZW5JZHMsIHtcbiAgICAgICAgICAgIHNraXBfc3BlY2lhbF90b2tlbnM6IHRydWUsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCB0b1JldHVybiA9IEFycmF5LmZyb20oeyBsZW5ndGg6IHRleHRzLmxlbmd0aCB9LCBfID0+IFtdKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkZWNvZGVkLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCB0ZXh0SW5kZXggPSBNYXRoLmZsb29yKGkgLyBvdXRwdXRUb2tlbklkcy5sZW5ndGggKiB0ZXh0cy5sZW5ndGgpO1xuXG4gICAgICAgICAgICB0b1JldHVyblt0ZXh0SW5kZXhdLnB1c2goe1xuICAgICAgICAgICAgICAgIGdlbmVyYXRlZF90ZXh0OiBkZWNvZGVkW2ldXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKHN0cmluZ0lucHV0ICYmIHRvUmV0dXJuLmxlbmd0aCA9PT0gMSkgPyB0b1JldHVyblswXSA6IHRvUmV0dXJuO1xuICAgIH1cbn1cblxuLyoqXG4gKiBOTEktYmFzZWQgemVyby1zaG90IGNsYXNzaWZpY2F0aW9uIHBpcGVsaW5lIHVzaW5nIGEgYE1vZGVsRm9yU2VxdWVuY2VDbGFzc2lmaWNhdGlvbmBcbiAqIHRyYWluZWQgb24gTkxJIChuYXR1cmFsIGxhbmd1YWdlIGluZmVyZW5jZSkgdGFza3MuIEVxdWl2YWxlbnQgb2YgYHRleHQtY2xhc3NpZmljYXRpb25gXG4gKiBwaXBlbGluZXMsIGJ1dCB0aGVzZSBtb2RlbHMgZG9uJ3QgcmVxdWlyZSBhIGhhcmRjb2RlZCBudW1iZXIgb2YgcG90ZW50aWFsIGNsYXNzZXMsIHRoZXlcbiAqIGNhbiBiZSBjaG9zZW4gYXQgcnVudGltZS4gSXQgdXN1YWxseSBtZWFucyBpdCdzIHNsb3dlciBidXQgaXQgaXMgKiptdWNoKiogbW9yZSBmbGV4aWJsZS5cbiAqIEBleHRlbmRzIFBpcGVsaW5lXG4gKi9cbmV4cG9ydCBjbGFzcyBaZXJvU2hvdENsYXNzaWZpY2F0aW9uUGlwZWxpbmUgZXh0ZW5kcyBQaXBlbGluZSB7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgWmVyb1Nob3RDbGFzc2lmaWNhdGlvblBpcGVsaW5lLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0YXNrIFRoZSB0YXNrIG9mIHRoZSBwaXBlbGluZS4gVXNlZnVsIGZvciBzcGVjaWZ5aW5nIHN1YnRhc2tzLlxuICAgICAqIEBwYXJhbSB7UHJlVHJhaW5lZFRva2VuaXplcn0gdG9rZW5pemVyIFRoZSB0b2tlbml6ZXIgdG8gdXNlLlxuICAgICAqIEBwYXJhbSB7UHJlVHJhaW5lZE1vZGVsfSBtb2RlbCBUaGUgbW9kZWwgdG8gdXNlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHRhc2ssIHRva2VuaXplciwgbW9kZWwpIHtcbiAgICAgICAgc3VwZXIodGFzaywgdG9rZW5pemVyLCBtb2RlbCk7XG5cbiAgICAgICAgLy8gVXNlIG1vZGVsIGNvbmZpZyB0byBnZXQgbGFiZWwyaWQgbWFwcGluZ1xuICAgICAgICB0aGlzLmxhYmVsMmlkID0gT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgICAgICAgICAgT2JqZWN0LmVudHJpZXModGhpcy5tb2RlbC5jb25maWcubGFiZWwyaWQpLm1hcChcbiAgICAgICAgICAgICAgICAoW2ssIHZdKSA9PiBbay50b0xvd2VyQ2FzZSgpLCB2XVxuICAgICAgICAgICAgKVxuICAgICAgICApO1xuXG4gICAgICAgIHRoaXMuZW50YWlsbWVudF9pZCA9IHRoaXMubGFiZWwyaWRbJ2VudGFpbG1lbnQnXTtcbiAgICAgICAgaWYgKHRoaXMuZW50YWlsbWVudF9pZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJDb3VsZCBub3QgZmluZCAnZW50YWlsbWVudCcgaW4gbGFiZWwyaWQgbWFwcGluZy4gVXNpbmcgMiBhcyBlbnRhaWxtZW50X2lkLlwiKTtcbiAgICAgICAgICAgIHRoaXMuZW50YWlsbWVudF9pZCA9IDI7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNvbnRyYWRpY3Rpb25faWQgPSB0aGlzLmxhYmVsMmlkWydjb250cmFkaWN0aW9uJ107XG4gICAgICAgIGlmICh0aGlzLmNvbnRyYWRpY3Rpb25faWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiQ291bGQgbm90IGZpbmQgJ2NvbnRyYWRpY3Rpb24nIGluIGxhYmVsMmlkIG1hcHBpbmcuIFVzaW5nIDAgYXMgY29udHJhZGljdGlvbl9pZC5cIik7XG4gICAgICAgICAgICB0aGlzLmNvbnRyYWRpY3Rpb25faWQgPSAwO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7YW55W119IHRleHRzXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gY2FuZGlkYXRlX2xhYmVsc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIEFkZGl0aW9uYWwgb3B0aW9uczpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuaHlwb3RoZXNpc190ZW1wbGF0ZT1cIlRoaXMgZXhhbXBsZSBpcyB7fS5cIl0gVGhlIHRlbXBsYXRlIHVzZWQgdG8gdHVybiBlYWNoXG4gICAgICogY2FuZGlkYXRlIGxhYmVsIGludG8gYW4gTkxJLXN0eWxlIGh5cG90aGVzaXMuIFRoZSBjYW5kaWRhdGUgbGFiZWwgd2lsbCByZXBsYWNlIHRoZSB7fSBwbGFjZWhvbGRlci5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLm11bHRpX2xhYmVsPWZhbHNlXSBXaGV0aGVyIG9yIG5vdCBtdWx0aXBsZSBjYW5kaWRhdGUgbGFiZWxzIGNhbiBiZSB0cnVlLlxuICAgICAqIElmIGBmYWxzZWAsIHRoZSBzY29yZXMgYXJlIG5vcm1hbGl6ZWQgc3VjaCB0aGF0IHRoZSBzdW0gb2YgdGhlIGxhYmVsIGxpa2VsaWhvb2RzIGZvciBlYWNoIHNlcXVlbmNlXG4gICAgICogaXMgMS4gSWYgYHRydWVgLCB0aGUgbGFiZWxzIGFyZSBjb25zaWRlcmVkIGluZGVwZW5kZW50IGFuZCBwcm9iYWJpbGl0aWVzIGFyZSBub3JtYWxpemVkIGZvciBlYWNoXG4gICAgICogY2FuZGlkYXRlIGJ5IGRvaW5nIGEgc29mdG1heCBvZiB0aGUgZW50YWlsbWVudCBzY29yZSB2cy4gdGhlIGNvbnRyYWRpY3Rpb24gc2NvcmUuXG4gICAgICogQHJldHVybiB7UHJvbWlzZTxPYmplY3R8T2JqZWN0W10+fSBUaGUgcHJlZGljdGlvbihzKSwgYXMgYSBtYXAgKG9yIGxpc3Qgb2YgbWFwcykgZnJvbSBsYWJlbCB0byBzY29yZS5cbiAgICAgKi9cbiAgICAvLyBAdHMtaWdub3JlXG4gICAgYXN5bmMgX2NhbGwodGV4dHMsIGNhbmRpZGF0ZV9sYWJlbHMsIHtcbiAgICAgICAgaHlwb3RoZXNpc190ZW1wbGF0ZSA9IFwiVGhpcyBleGFtcGxlIGlzIHt9LlwiLFxuICAgICAgICBtdWx0aV9sYWJlbCA9IGZhbHNlLFxuICAgIH0gPSB7fSkge1xuXG4gICAgICAgIGxldCBpc0JhdGNoZWQgPSBBcnJheS5pc0FycmF5KHRleHRzKTtcblxuICAgICAgICBpZiAoIWlzQmF0Y2hlZCkge1xuICAgICAgICAgICAgdGV4dHMgPSBbdGV4dHNdO1xuICAgICAgICB9XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShjYW5kaWRhdGVfbGFiZWxzKSkge1xuICAgICAgICAgICAgY2FuZGlkYXRlX2xhYmVscyA9IFtjYW5kaWRhdGVfbGFiZWxzXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEluc2VydCBsYWJlbHMgaW50byBoeXBvdGhlc2lzIHRlbXBsYXRlXG4gICAgICAgIGxldCBoeXBvdGhlc2VzID0gY2FuZGlkYXRlX2xhYmVscy5tYXAoXG4gICAgICAgICAgICB4ID0+IGh5cG90aGVzaXNfdGVtcGxhdGUucmVwbGFjZSgne30nLCB4KVxuICAgICAgICApO1xuXG4gICAgICAgIC8vIEhvdyB0byBwZXJmb3JtIHRoZSBzb2Z0bWF4IG92ZXIgdGhlIGxvZ2l0czpcbiAgICAgICAgLy8gIC0gdHJ1ZTogIHNvZnRtYXggb3ZlciB0aGUgZW50YWlsbWVudCB2cy4gY29udHJhZGljdGlvbiBkaW0gZm9yIGVhY2ggbGFiZWwgaW5kZXBlbmRlbnRseVxuICAgICAgICAvLyAgLSBmYWxzZTogc29mdG1heCB0aGUgXCJlbnRhaWxtZW50XCIgbG9naXRzIG92ZXIgYWxsIGNhbmRpZGF0ZSBsYWJlbHNcbiAgICAgICAgbGV0IHNvZnRtYXhFYWNoID0gbXVsdGlfbGFiZWwgfHwgY2FuZGlkYXRlX2xhYmVscy5sZW5ndGggPT09IDE7XG5cbiAgICAgICAgbGV0IHRvUmV0dXJuID0gW107XG4gICAgICAgIGZvciAobGV0IHByZW1pc2Ugb2YgdGV4dHMpIHtcbiAgICAgICAgICAgIGxldCBlbnRhaWxzX2xvZ2l0cyA9IFtdO1xuXG4gICAgICAgICAgICBmb3IgKGxldCBoeXBvdGhlc2lzIG9mIGh5cG90aGVzZXMpIHtcbiAgICAgICAgICAgICAgICBsZXQgaW5wdXRzID0gdGhpcy50b2tlbml6ZXIocHJlbWlzZSwge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0X3BhaXI6IGh5cG90aGVzaXMsXG4gICAgICAgICAgICAgICAgICAgIHBhZGRpbmc6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHRydW5jYXRpb246IHRydWUsXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICBsZXQgb3V0cHV0cyA9IGF3YWl0IHRoaXMubW9kZWwoaW5wdXRzKVxuXG4gICAgICAgICAgICAgICAgaWYgKHNvZnRtYXhFYWNoKSB7XG4gICAgICAgICAgICAgICAgICAgIGVudGFpbHNfbG9naXRzLnB1c2goW1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0cy5sb2dpdHMuZGF0YVt0aGlzLmNvbnRyYWRpY3Rpb25faWRdLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0cy5sb2dpdHMuZGF0YVt0aGlzLmVudGFpbG1lbnRfaWRdXG4gICAgICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZW50YWlsc19sb2dpdHMucHVzaChvdXRwdXRzLmxvZ2l0cy5kYXRhW3RoaXMuZW50YWlsbWVudF9pZF0pXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQgc2NvcmVzO1xuICAgICAgICAgICAgaWYgKHNvZnRtYXhFYWNoKSB7XG4gICAgICAgICAgICAgICAgc2NvcmVzID0gZW50YWlsc19sb2dpdHMubWFwKHggPT4gc29mdG1heCh4KVsxXSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNjb3JlcyA9IHNvZnRtYXgoZW50YWlsc19sb2dpdHMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBTb3J0IGJ5IHNjb3JlcyAoZGVzYykgYW5kIHJldHVybiBzY29yZXMgd2l0aCBpbmRpY2VzXG4gICAgICAgICAgICBsZXQgc2NvcmVzX3NvcnRlZCA9IHNjb3Jlc1xuICAgICAgICAgICAgICAgIC5tYXAoKHgsIGkpID0+IFt4LCBpXSlcbiAgICAgICAgICAgICAgICAuc29ydCgoYSwgYikgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYlswXSAtIGFbMF07XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHRvUmV0dXJuLnB1c2goe1xuICAgICAgICAgICAgICAgIHNlcXVlbmNlOiBwcmVtaXNlLFxuICAgICAgICAgICAgICAgIGxhYmVsczogc2NvcmVzX3NvcnRlZC5tYXAoeCA9PiBjYW5kaWRhdGVfbGFiZWxzW3hbMV1dKSxcbiAgICAgICAgICAgICAgICBzY29yZXM6IHNjb3Jlc19zb3J0ZWQubWFwKHggPT4geFswXSksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXNCYXRjaGVkID8gdG9SZXR1cm4gOiB0b1JldHVyblswXTtcbiAgICB9XG59XG5cblxuLyoqXG4gKiBGZWF0dXJlIGV4dHJhY3Rpb24gcGlwZWxpbmUgdXNpbmcgbm8gbW9kZWwgaGVhZC4gVGhpcyBwaXBlbGluZSBleHRyYWN0cyB0aGUgaGlkZGVuXG4gKiBzdGF0ZXMgZnJvbSB0aGUgYmFzZSB0cmFuc2Zvcm1lciwgd2hpY2ggY2FuIGJlIHVzZWQgYXMgZmVhdHVyZXMgaW4gZG93bnN0cmVhbSB0YXNrcy5cbiAqIFxuICogKipFeGFtcGxlOioqIFJ1biBmZWF0dXJlIGV4dHJhY3Rpb24gd2l0aCBgYmVydC1iYXNlLXVuY2FzZWRgICh3aXRob3V0IHBvb2xpbmcvbm9ybWFsaXphdGlvbikuXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBsZXQgZXh0cmFjdG9yID0gYXdhaXQgcGlwZWxpbmUoJ2ZlYXR1cmUtZXh0cmFjdGlvbicsICdYZW5vdmEvYmVydC1iYXNlLXVuY2FzZWQnLCB7IHJldmlzaW9uOiAnZGVmYXVsdCcgfSk7XG4gKiBsZXQgcmVzdWx0ID0gYXdhaXQgZXh0cmFjdG9yKCdUaGlzIGlzIGEgc2ltcGxlIHRlc3QuJyk7XG4gKiBjb25zb2xlLmxvZyhyZXN1bHQpO1xuICogLy8gVGVuc29yIHtcbiAqIC8vICAgICB0eXBlOiAnZmxvYXQzMicsXG4gKiAvLyAgICAgZGF0YTogRmxvYXQzMkFycmF5IFswLjA1OTM5OTI0NzE2OTQ5NDYzLCAwLjAyMTY1NTkzNTc5NDExNTA2NywgLi4uXSxcbiAqIC8vICAgICBkaW1zOiBbMSwgOCwgNzY4XVxuICogLy8gfVxuICogYGBgXG4gKiBcbiAqICoqRXhhbXBsZToqKiBSdW4gZmVhdHVyZSBleHRyYWN0aW9uIHdpdGggYGJlcnQtYmFzZS11bmNhc2VkYCAod2l0aCBwb29saW5nL25vcm1hbGl6YXRpb24pLlxuICogYGBgamF2YXNjcmlwdFxuICogbGV0IGV4dHJhY3RvciA9IGF3YWl0IHBpcGVsaW5lKCdmZWF0dXJlLWV4dHJhY3Rpb24nLCAnWGVub3ZhL2JlcnQtYmFzZS11bmNhc2VkJywgeyByZXZpc2lvbjogJ2RlZmF1bHQnIH0pO1xuICogbGV0IHJlc3VsdCA9IGF3YWl0IGV4dHJhY3RvcignVGhpcyBpcyBhIHNpbXBsZSB0ZXN0LicsIHsgcG9vbGluZzogJ21lYW4nLCBub3JtYWxpemU6IHRydWUgfSk7XG4gKiBjb25zb2xlLmxvZyhyZXN1bHQpO1xuICogLy8gVGVuc29yIHtcbiAqIC8vICAgICB0eXBlOiAnZmxvYXQzMicsXG4gKiAvLyAgICAgZGF0YTogRmxvYXQzMkFycmF5IFswLjAzMzczNzc4OTgzOTUwNjE1LCAtMC4wMTAxMDYwNzc0MTc3MzEyODUsIC4uLl0sXG4gKiAvLyAgICAgZGltczogWzEsIDc2OF1cbiAqIC8vIH1cbiAqIGBgYFxuICogXG4gKiAqKkV4YW1wbGU6KiogQ2FsY3VsYXRpbmcgZW1iZWRkaW5ncyB3aXRoIGBzZW50ZW5jZS10cmFuc2Zvcm1lcnNgIG1vZGVscy5cbiAqIGBgYGphdmFzY3JpcHRcbiAqIGxldCBleHRyYWN0b3IgPSBhd2FpdCBwaXBlbGluZSgnZmVhdHVyZS1leHRyYWN0aW9uJywgJ1hlbm92YS9hbGwtTWluaUxNLUw2LXYyJyk7XG4gKiBsZXQgcmVzdWx0ID0gYXdhaXQgZXh0cmFjdG9yKCdUaGlzIGlzIGEgc2ltcGxlIHRlc3QuJywgeyBwb29saW5nOiAnbWVhbicsIG5vcm1hbGl6ZTogdHJ1ZSB9KTtcbiAqIGNvbnNvbGUubG9nKHJlc3VsdCk7XG4gKiAvLyBUZW5zb3Ige1xuICogLy8gICAgIHR5cGU6ICdmbG9hdDMyJyxcbiAqIC8vICAgICBkYXRhOiBGbG9hdDMyQXJyYXkgWzAuMDkwOTQ5ODI1OTQyNTE2MzMsIC0wLjAxNDc3NDI0NjE0MTMxNDUwNywgLi4uXSxcbiAqIC8vICAgICBkaW1zOiBbMSwgMzg0XVxuICogLy8gfVxuICogYGBgXG4gKiBAZXh0ZW5kcyBQaXBlbGluZVxuICovXG5leHBvcnQgY2xhc3MgRmVhdHVyZUV4dHJhY3Rpb25QaXBlbGluZSBleHRlbmRzIFBpcGVsaW5lIHtcblxuICAgIC8qKlxuICAgICAqIEV4dHJhY3QgdGhlIGZlYXR1cmVzIG9mIHRoZSBpbnB1dChzKS5cbiAgICAgKiBcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXX0gdGV4dHMgVGhlIGlucHV0IHRleHRzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgQWRkaXRpb25hbCBvcHRpb25zOlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5wb29saW5nPVwibm9uZVwiXSBUaGUgcG9vbGluZyBtZXRob2QgdG8gdXNlLiBDYW4gYmUgb25lIG9mOiBcIm5vbmVcIiwgXCJtZWFuXCIuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5ub3JtYWxpemU9ZmFsc2VdIFdoZXRoZXIgb3Igbm90IHRvIG5vcm1hbGl6ZSB0aGUgZW1iZWRkaW5ncyBpbiB0aGUgbGFzdCBkaW1lbnNpb24uXG4gICAgICogQHJldHVybnMgVGhlIGZlYXR1cmVzIGNvbXB1dGVkIGJ5IHRoZSBtb2RlbC5cbiAgICAgKi9cbiAgICBhc3luYyBfY2FsbCh0ZXh0cywge1xuICAgICAgICBwb29saW5nID0gJ25vbmUnLFxuICAgICAgICBub3JtYWxpemUgPSBmYWxzZSxcbiAgICB9ID0ge30pIHtcbiAgICAgICAgbGV0IFtpbnB1dHMsIG91dHB1dHNdID0gYXdhaXQgc3VwZXIuX2NhbGwodGV4dHMpO1xuXG4gICAgICAgIC8vIFRPRE86IFByb3ZpZGUgd2FybmluZyB0byB0aGUgdXNlciB0aGF0IHRoZXkgbWlnaHQgYmUgdXNpbmcgbW9kZWwgd2hpY2ggd2FzIG5vdCBleHBvcnRlZFxuICAgICAgICAvLyBzcGVjaWZpY2FsbHkgZm9yIGZlYXR1cmUgZXh0cmFjdGlvblxuICAgICAgICAvLyBjb25zb2xlLmxvZyh0aGlzLm1vZGVsLmNvbmZpZylcbiAgICAgICAgLy8gY29uc29sZS5sb2cob3V0cHV0cylcblxuICAgICAgICBsZXQgcmVzdWx0ID0gb3V0cHV0cy5sYXN0X2hpZGRlbl9zdGF0ZSA/PyBvdXRwdXRzLmxvZ2l0cztcbiAgICAgICAgaWYgKHBvb2xpbmcgPT09ICdub25lJykge1xuICAgICAgICAgICAgLy8gU2tpcCBwb29saW5nXG4gICAgICAgIH0gZWxzZSBpZiAocG9vbGluZyA9PT0gJ21lYW4nKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBtZWFuX3Bvb2xpbmcocmVzdWx0LCBpbnB1dHMuYXR0ZW50aW9uX21hc2spO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoYFBvb2xpbmcgbWV0aG9kICcke3Bvb2xpbmd9JyBub3Qgc3VwcG9ydGVkLmApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5vcm1hbGl6ZSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0Lm5vcm1hbGl6ZSgyLCAtMSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cblxuLy8gVE9ET1xuLy8gZXhwb3J0IGNsYXNzIFNlbnRlbmNlU2ltaWxhcml0eVBpcGVsaW5lIGV4dGVuZHMgUGlwZWxpbmUge1xuLy8gfVxuXG5cbi8qKlxuICogUGlwZWxpbmUgdGhhdCBhaW1zIGF0IGV4dHJhY3Rpbmcgc3Bva2VuIHRleHQgY29udGFpbmVkIHdpdGhpbiBzb21lIGF1ZGlvLlxuICpcbiAqICoqRXhhbXBsZToqKiBUcmFuc2NyaWJlIEVuZ2xpc2guXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBsZXQgdXJsID0gJ2h0dHBzOi8vaHVnZ2luZ2ZhY2UuY28vZGF0YXNldHMvWGVub3ZhL3RyYW5zZm9ybWVycy5qcy1kb2NzL3Jlc29sdmUvbWFpbi9qZmsud2F2JztcbiAqIGxldCB0cmFuc2NyaWJlciA9IGF3YWl0IHBpcGVsaW5lKCdhdXRvbWF0aWMtc3BlZWNoLXJlY29nbml0aW9uJywgJ1hlbm92YS93aGlzcGVyLXRpbnkuZW4nKTtcbiAqIGxldCBvdXRwdXQgPSBhd2FpdCB0cmFuc2NyaWJlcih1cmwpO1xuICogLy8geyB0ZXh0OiBcIiBBbmQgc28gbXkgZmVsbG93IEFtZXJpY2FucyBhc2sgbm90IHdoYXQgeW91ciBjb3VudHJ5IGNhbiBkbyBmb3IgeW91LCBhc2sgd2hhdCB5b3UgY2FuIGRvIGZvciB5b3VyIGNvdW50cnkuXCIgfVxuICogYGBgXG4gKiBcbiAqICoqRXhhbXBsZToqKiBUcmFuc2NyaWJlIEVuZ2xpc2ggdy8gdGltZXN0YW1wcy5cbiAqIGBgYGphdmFzY3JpcHRcbiAqIGxldCB1cmwgPSAnaHR0cHM6Ly9odWdnaW5nZmFjZS5jby9kYXRhc2V0cy9YZW5vdmEvdHJhbnNmb3JtZXJzLmpzLWRvY3MvcmVzb2x2ZS9tYWluL2pmay53YXYnO1xuICogbGV0IHRyYW5zY3JpYmVyID0gYXdhaXQgcGlwZWxpbmUoJ2F1dG9tYXRpYy1zcGVlY2gtcmVjb2duaXRpb24nLCAnWGVub3ZhL3doaXNwZXItdGlueS5lbicpO1xuICogbGV0IG91dHB1dCA9IGF3YWl0IHRyYW5zY3JpYmVyKHVybCwgeyByZXR1cm5fdGltZXN0YW1wczogdHJ1ZSB9KTtcbiAqIC8vIHtcbiAqIC8vICAgdGV4dDogXCIgQW5kIHNvIG15IGZlbGxvdyBBbWVyaWNhbnMgYXNrIG5vdCB3aGF0IHlvdXIgY291bnRyeSBjYW4gZG8gZm9yIHlvdSwgYXNrIHdoYXQgeW91IGNhbiBkbyBmb3IgeW91ciBjb3VudHJ5LlwiXG4gKiAvLyAgIGNodW5rczogW1xuICogLy8gICAgIHsgdGltZXN0YW1wOiBbMCwgOF0sICB0ZXh0OiBcIiBBbmQgc28gbXkgZmVsbG93IEFtZXJpY2FucyBhc2sgbm90IHdoYXQgeW91ciBjb3VudHJ5IGNhbiBkbyBmb3IgeW91XCIgfVxuICogLy8gICAgIHsgdGltZXN0YW1wOiBbOCwgMTFdLCB0ZXh0OiBcIiBhc2sgd2hhdCB5b3UgY2FuIGRvIGZvciB5b3VyIGNvdW50cnkuXCIgfVxuICogLy8gICBdXG4gKiAvLyB9XG4gKiBgYGBcbiAqIFxuICogKipFeGFtcGxlOioqIFRyYW5zY3JpYmUgRW5nbGlzaCB3LyB3b3JkLWxldmVsIHRpbWVzdGFtcHMuXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBsZXQgdXJsID0gJ2h0dHBzOi8vaHVnZ2luZ2ZhY2UuY28vZGF0YXNldHMvWGVub3ZhL3RyYW5zZm9ybWVycy5qcy1kb2NzL3Jlc29sdmUvbWFpbi9qZmsud2F2JztcbiAqIGxldCB0cmFuc2NyaWJlciA9IGF3YWl0IHBpcGVsaW5lKCdhdXRvbWF0aWMtc3BlZWNoLXJlY29nbml0aW9uJywgJ1hlbm92YS93aGlzcGVyLXRpbnkuZW4nLCB7XG4gKiAgICAgcmV2aXNpb246ICdvdXRwdXRfYXR0ZW50aW9ucycsXG4gKiB9KTtcbiAqIGxldCBvdXRwdXQgPSBhd2FpdCB0cmFuc2NyaWJlcih1cmwsIHsgcmV0dXJuX3RpbWVzdGFtcHM6ICd3b3JkJyB9KTtcbiAqIC8vIHtcbiAqIC8vICAgXCJ0ZXh0XCI6IFwiIEFuZCBzbyBteSBmZWxsb3cgQW1lcmljYW5zIGFzayBub3Qgd2hhdCB5b3VyIGNvdW50cnkgY2FuIGRvIGZvciB5b3UgYXNrIHdoYXQgeW91IGNhbiBkbyBmb3IgeW91ciBjb3VudHJ5LlwiLFxuICogLy8gICBcImNodW5rc1wiOiBbXG4gKiAvLyAgICAgeyBcInRleHRcIjogXCIgQW5kXCIsIFwidGltZXN0YW1wXCI6IFswLCAwLjc4XSB9LFxuICogLy8gICAgIHsgXCJ0ZXh0XCI6IFwiIHNvXCIsIFwidGltZXN0YW1wXCI6IFswLjc4LCAxLjA2XSB9LFxuICogLy8gICAgIHsgXCJ0ZXh0XCI6IFwiIG15XCIsIFwidGltZXN0YW1wXCI6IFsxLjA2LCAxLjQ2XSB9LFxuICogLy8gICAgIC4uLlxuICogLy8gICAgIHsgXCJ0ZXh0XCI6IFwiIGZvclwiLCBcInRpbWVzdGFtcFwiOiBbOS43MiwgOS45Ml0gfSxcbiAqIC8vICAgICB7IFwidGV4dFwiOiBcIiB5b3VyXCIsIFwidGltZXN0YW1wXCI6IFs5LjkyLCAxMC4yMl0gfSxcbiAqIC8vICAgICB7IFwidGV4dFwiOiBcIiBjb3VudHJ5LlwiLCBcInRpbWVzdGFtcFwiOiBbMTAuMjIsIDEzLjVdIH1cbiAqIC8vICAgXVxuICogLy8gfVxuICogYGBgXG4gKiBcbiAqICoqRXhhbXBsZToqKiBUcmFuc2NyaWJlIEZyZW5jaC5cbiAqIGBgYGphdmFzY3JpcHRcbiAqIGxldCB1cmwgPSAnaHR0cHM6Ly9odWdnaW5nZmFjZS5jby9kYXRhc2V0cy9YZW5vdmEvdHJhbnNmb3JtZXJzLmpzLWRvY3MvcmVzb2x2ZS9tYWluL2ZyZW5jaC1hdWRpby5tcDMnO1xuICogbGV0IHRyYW5zY3JpYmVyID0gYXdhaXQgcGlwZWxpbmUoJ2F1dG9tYXRpYy1zcGVlY2gtcmVjb2duaXRpb24nLCAnWGVub3ZhL3doaXNwZXItc21hbGwnKTtcbiAqIGxldCBvdXRwdXQgPSBhd2FpdCB0cmFuc2NyaWJlcih1cmwsIHsgbGFuZ3VhZ2U6ICdmcmVuY2gnLCB0YXNrOiAndHJhbnNjcmliZScgfSk7XG4gKiAvLyB7IHRleHQ6IFwiIEonYWRvcmUsIGonYWltZSwgamUgbidhaW1lIHBhcywgamUgZMOpdGVzdGUuXCIgfVxuICogYGBgXG4gKiBcbiAqICoqRXhhbXBsZToqKiBUcmFuc2xhdGUgRnJlbmNoIHRvIEVuZ2xpc2guXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBsZXQgdXJsID0gJ2h0dHBzOi8vaHVnZ2luZ2ZhY2UuY28vZGF0YXNldHMvWGVub3ZhL3RyYW5zZm9ybWVycy5qcy1kb2NzL3Jlc29sdmUvbWFpbi9mcmVuY2gtYXVkaW8ubXAzJztcbiAqIGxldCB0cmFuc2NyaWJlciA9IGF3YWl0IHBpcGVsaW5lKCdhdXRvbWF0aWMtc3BlZWNoLXJlY29nbml0aW9uJywgJ1hlbm92YS93aGlzcGVyLXNtYWxsJyk7XG4gKiBsZXQgb3V0cHV0ID0gYXdhaXQgdHJhbnNjcmliZXIodXJsLCB7IGxhbmd1YWdlOiAnZnJlbmNoJywgdGFzazogJ3RyYW5zbGF0ZScgfSk7XG4gKiAvLyB7IHRleHQ6IFwiIEkgbG92ZSwgSSBsaWtlLCBJIGRvbid0IGxpa2UsIEkgaGF0ZS5cIiB9XG4gKiBgYGBcbiAqIFxuICogKipFeGFtcGxlOioqIFRyYW5zY3JpYmUvdHJhbnNsYXRlIGF1ZGlvIGxvbmdlciB0aGFuIDMwIHNlY29uZHMuXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBsZXQgdXJsID0gJ2h0dHBzOi8vaHVnZ2luZ2ZhY2UuY28vZGF0YXNldHMvWGVub3ZhL3RyYW5zZm9ybWVycy5qcy1kb2NzL3Jlc29sdmUvbWFpbi90ZWRfNjAud2F2JztcbiAqIGxldCB0cmFuc2NyaWJlciA9IGF3YWl0IHBpcGVsaW5lKCdhdXRvbWF0aWMtc3BlZWNoLXJlY29nbml0aW9uJywgJ1hlbm92YS93aGlzcGVyLXRpbnkuZW4nKTtcbiAqIGxldCBvdXRwdXQgPSBhd2FpdCB0cmFuc2NyaWJlcih1cmwsIHsgY2h1bmtfbGVuZ3RoX3M6IDMwLCBzdHJpZGVfbGVuZ3RoX3M6IDUgfSk7XG4gKiAvLyB7IHRleHQ6IFwiIFNvIGluIGNvbGxlZ2UsIEkgd2FzIGEgZ292ZXJubWVudCBtYWpvciwgd2hpY2ggbWVhbnMgWy4uLl0gU28gSSdkIHN0YXJ0IG9mZiBsaWdodCBhbmQgSSdkIGJ1bXAgaXQgdXBcIiB9XG4gKiBgYGBcbiAqIEBleHRlbmRzIFBpcGVsaW5lXG4gKi9cbmV4cG9ydCBjbGFzcyBBdXRvbWF0aWNTcGVlY2hSZWNvZ25pdGlvblBpcGVsaW5lIGV4dGVuZHMgUGlwZWxpbmUge1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IEF1dG9tYXRpY1NwZWVjaFJlY29nbml0aW9uUGlwZWxpbmUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRhc2sgVGhlIHRhc2sgb2YgdGhlIHBpcGVsaW5lLiBVc2VmdWwgZm9yIHNwZWNpZnlpbmcgc3VidGFza3MuXG4gICAgICogQHBhcmFtIHtQcmVUcmFpbmVkVG9rZW5pemVyfSB0b2tlbml6ZXIgVGhlIHRva2VuaXplciB0byB1c2UuXG4gICAgICogQHBhcmFtIHtQcmVUcmFpbmVkTW9kZWx9IG1vZGVsIFRoZSBtb2RlbCB0byB1c2UuXG4gICAgICogQHBhcmFtIHtQcm9jZXNzb3J9IHByb2Nlc3NvciBUaGUgcHJvY2Vzc29yIHRvIHVzZS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih0YXNrLCB0b2tlbml6ZXIsIG1vZGVsLCBwcm9jZXNzb3IpIHtcbiAgICAgICAgc3VwZXIodGFzaywgdG9rZW5pemVyLCBtb2RlbCk7XG4gICAgICAgIHRoaXMucHJvY2Vzc29yID0gcHJvY2Vzc29yO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFByZXByb2Nlc3NlcyB0aGUgaW5wdXQgYXVkaW8gZm9yIHRoZSBBdXRvbWF0aWNTcGVlY2hSZWNvZ25pdGlvblBpcGVsaW5lLlxuICAgICAqIEBwYXJhbSB7YW55fSBhdWRpbyBUaGUgYXVkaW8gdG8gYmUgcHJlcHJvY2Vzc2VkLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzYW1wbGluZ19yYXRlIFRoZSBzYW1wbGluZyByYXRlIG9mIHRoZSBhdWRpby5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxGbG9hdDMyQXJyYXk+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgcHJlcHJvY2Vzc2VkIGF1ZGlvIGRhdGEuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBhc3luYyBfcHJlcHJvY2VzcyhhdWRpbywgc2FtcGxpbmdfcmF0ZSkge1xuICAgICAgICBpZiAoaXNTdHJpbmcoYXVkaW8pKSB7XG4gICAgICAgICAgICBhdWRpbyA9IGF3YWl0IHJlYWRfYXVkaW8oYXVkaW8sIHNhbXBsaW5nX3JhdGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF1ZGlvO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEB0eXBlZGVmIHtpbXBvcnQoJy4vdXRpbHMvdGVuc29yLmpzJykuVGVuc29yfSBUZW5zb3JcbiAgICAgKiBAdHlwZWRlZiB7e3N0cmlkZTogbnVtYmVyW10sIGlucHV0X2ZlYXR1cmVzOiBUZW5zb3IsIGlzX2xhc3Q6IGJvb2xlYW4sIHRva2Vucz86IG51bWJlcltdLCB0b2tlbl90aW1lc3RhbXBzPzogbnVtYmVyW119fSBDaHVua1xuICAgICAqIFxuICAgICAqIEBjYWxsYmFjayBDaHVua0NhbGxiYWNrXG4gICAgICogQHBhcmFtIHtDaHVua30gY2h1bmsgVGhlIGNodW5rIHRvIHByb2Nlc3MuXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBBc3luY2hyb25vdXNseSBwcm9jZXNzZXMgYXVkaW8gYW5kIGdlbmVyYXRlcyB0ZXh0IHRyYW5zY3JpcHRpb24gdXNpbmcgdGhlIG1vZGVsLlxuICAgICAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fEZsb2F0MzJBcnJheVtdfSBhdWRpbyBUaGUgYXVkaW8gdG8gYmUgdHJhbnNjcmliZWQuIENhbiBiZSBhIHNpbmdsZSBGbG9hdDMyQXJyYXkgb3IgYW4gYXJyYXkgb2YgRmxvYXQzMkFycmF5cy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2t3YXJncz17fV0gT3B0aW9uYWwgYXJndW1lbnRzLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbnwnd29yZCd9IFtrd2FyZ3MucmV0dXJuX3RpbWVzdGFtcHNdIFdoZXRoZXIgdG8gcmV0dXJuIHRpbWVzdGFtcHMgb3Igbm90LiBEZWZhdWx0IGlzIGBmYWxzZWAuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtrd2FyZ3MuY2h1bmtfbGVuZ3RoX3NdIFRoZSBsZW5ndGggb2YgYXVkaW8gY2h1bmtzIHRvIHByb2Nlc3MgaW4gc2Vjb25kcy4gRGVmYXVsdCBpcyAwIChubyBjaHVua2luZykuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtrd2FyZ3Muc3RyaWRlX2xlbmd0aF9zXSBUaGUgbGVuZ3RoIG9mIG92ZXJsYXAgYmV0d2VlbiBjb25zZWN1dGl2ZSBhdWRpbyBjaHVua3MgaW4gc2Vjb25kcy4gSWYgbm90IHByb3ZpZGVkLCBkZWZhdWx0cyB0byBgY2h1bmtfbGVuZ3RoX3MgLyA2YC5cbiAgICAgKiBAcGFyYW0ge0NodW5rQ2FsbGJhY2t9IFtrd2FyZ3MuY2h1bmtfY2FsbGJhY2tdIENhbGxiYWNrIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCB3aXRoIGVhY2ggY2h1bmsgcHJvY2Vzc2VkLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2t3YXJncy5mb3JjZV9mdWxsX3NlcXVlbmNlc10gV2hldGhlciB0byBmb3JjZSBvdXRwdXR0aW5nIGZ1bGwgc2VxdWVuY2VzIG9yIG5vdC4gRGVmYXVsdCBpcyBgZmFsc2VgLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBba3dhcmdzLmxhbmd1YWdlXSBUaGUgc291cmNlIGxhbmd1YWdlLiBEZWZhdWx0IGlzIGBudWxsYCwgbWVhbmluZyBpdCBzaG91bGQgYmUgYXV0by1kZXRlY3RlZC4gVXNlIHRoaXMgdG8gcG90ZW50aWFsbHkgaW1wcm92ZSBwZXJmb3JtYW5jZSBpZiB0aGUgc291cmNlIGxhbmd1YWdlIGlzIGtub3duLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBba3dhcmdzLnRhc2tdIFRoZSB0YXNrIHRvIHBlcmZvcm0uIERlZmF1bHQgaXMgYG51bGxgLCBtZWFuaW5nIGl0IHNob3VsZCBiZSBhdXRvLWRldGVjdGVkLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyW11bXX0gW2t3YXJncy5mb3JjZWRfZGVjb2Rlcl9pZHNdIEEgbGlzdCBvZiBwYWlycyBvZiBpbnRlZ2VycyB3aGljaCBpbmRpY2F0ZXMgYSBtYXBwaW5nIGZyb20gZ2VuZXJhdGlvbiBpbmRpY2VzIHRvIHRva2VuIGluZGljZXNcbiAgICAgKiB0aGF0IHdpbGwgYmUgZm9yY2VkIGJlZm9yZSBzYW1wbGluZy4gRm9yIGV4YW1wbGUsIFtbMSwgMTIzXV0gbWVhbnMgdGhlIHNlY29uZCBnZW5lcmF0ZWQgdG9rZW4gd2lsbCBhbHdheXMgYmUgYSB0b2tlbiBvZiBpbmRleCAxMjMuXG4gICAgICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0Pn0gQSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHRyYW5zY3JpcHRpb24gdGV4dCBhbmQgb3B0aW9uYWxseSB0aW1lc3RhbXBzIGlmIGByZXR1cm5fdGltZXN0YW1wc2AgaXMgYHRydWVgLlxuICAgICAqL1xuICAgIGFzeW5jIF9jYWxsKGF1ZGlvLCBrd2FyZ3MgPSB7fSkge1xuICAgICAgICBsZXQgcmV0dXJuX3RpbWVzdGFtcHMgPSBrd2FyZ3MucmV0dXJuX3RpbWVzdGFtcHMgPz8gZmFsc2U7XG4gICAgICAgIGxldCBjaHVua19sZW5ndGhfcyA9IGt3YXJncy5jaHVua19sZW5ndGhfcyA/PyAwO1xuICAgICAgICBsZXQgc3RyaWRlX2xlbmd0aF9zID0ga3dhcmdzLnN0cmlkZV9sZW5ndGhfcyA/PyBudWxsO1xuICAgICAgICBsZXQgY2h1bmtfY2FsbGJhY2sgPSBrd2FyZ3MuY2h1bmtfY2FsbGJhY2sgPz8gbnVsbDtcbiAgICAgICAgbGV0IGZvcmNlX2Z1bGxfc2VxdWVuY2VzID0ga3dhcmdzLmZvcmNlX2Z1bGxfc2VxdWVuY2VzID8/IGZhbHNlO1xuXG4gICAgICAgIGlmIChyZXR1cm5fdGltZXN0YW1wcyA9PT0gJ3dvcmQnKSB7XG4gICAgICAgICAgICBrd2FyZ3NbJ3JldHVybl90b2tlbl90aW1lc3RhbXBzJ10gPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGxhbmd1YWdlID0gcG9wKGt3YXJncywgJ2xhbmd1YWdlJywgbnVsbCk7XG4gICAgICAgIGxldCB0YXNrID0gcG9wKGt3YXJncywgJ3Rhc2snLCBudWxsKTtcblxuICAgICAgICBpZiAobGFuZ3VhZ2UgfHwgdGFzayB8fCByZXR1cm5fdGltZXN0YW1wcykge1xuICAgICAgICAgICAgaWYgKGt3YXJncy5mb3JjZWRfZGVjb2Rlcl9pZHMpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3Qgc3BlY2lmeSBgbGFuZ3VhZ2VgL2B0YXNrYC9gcmV0dXJuX3RpbWVzdGFtcHNgIGFuZCBgZm9yY2VkX2RlY29kZXJfaWRzYCBhdCB0aGUgc2FtZSB0aW1lLlwiKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgbGV0IGRlY29kZXJfcHJvbXB0X2lkcyA9IHRoaXMudG9rZW5pemVyLmdldF9kZWNvZGVyX3Byb21wdF9pZHMoeyBsYW5ndWFnZSwgdGFzaywgbm9fdGltZXN0YW1wczogIXJldHVybl90aW1lc3RhbXBzIH0pXG4gICAgICAgICAgICBpZiAoZGVjb2Rlcl9wcm9tcHRfaWRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBrd2FyZ3MuZm9yY2VkX2RlY29kZXJfaWRzID0gZGVjb2Rlcl9wcm9tcHRfaWRzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHNpbmdsZSA9ICFBcnJheS5pc0FycmF5KGF1ZGlvKTtcbiAgICAgICAgaWYgKHNpbmdsZSkge1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgYXVkaW8gPSBbYXVkaW9dO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgc2FtcGxpbmdfcmF0ZSA9IHRoaXMucHJvY2Vzc29yLmZlYXR1cmVfZXh0cmFjdG9yLmNvbmZpZy5zYW1wbGluZ19yYXRlO1xuICAgICAgICBjb25zdCB0aW1lX3ByZWNpc2lvbiA9IHRoaXMucHJvY2Vzc29yLmZlYXR1cmVfZXh0cmFjdG9yLmNvbmZpZy5jaHVua19sZW5ndGggLyB0aGlzLm1vZGVsLmNvbmZpZy5tYXhfc291cmNlX3Bvc2l0aW9ucztcblxuICAgICAgICBsZXQgdG9SZXR1cm4gPSBbXTtcbiAgICAgICAgZm9yIChsZXQgYXVkIG9mIGF1ZGlvKSB7XG4gICAgICAgICAgICBhdWQgPSBhd2FpdCB0aGlzLl9wcmVwcm9jZXNzKGF1ZCwgc2FtcGxpbmdfcmF0ZSlcblxuICAgICAgICAgICAgLyoqIEB0eXBlIHtDaHVua1tdfSAqL1xuICAgICAgICAgICAgbGV0IGNodW5rcyA9IFtdO1xuICAgICAgICAgICAgaWYgKGNodW5rX2xlbmd0aF9zID4gMCkge1xuICAgICAgICAgICAgICAgIGlmIChzdHJpZGVfbGVuZ3RoX3MgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RyaWRlX2xlbmd0aF9zID0gY2h1bmtfbGVuZ3RoX3MgLyA2O1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY2h1bmtfbGVuZ3RoX3MgPD0gc3RyaWRlX2xlbmd0aF9zKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiYGNodW5rX2xlbmd0aF9zYCBtdXN0IGJlIGxhcmdlciB0aGFuIGBzdHJpZGVfbGVuZ3RoX3NgLlwiKVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFRPRE8gc3VwcG9ydCBkaWZmZXJlbnQgc3RyaWRlX2xlbmd0aF9zIChmb3IgbGVmdCBhbmQgcmlnaHQpXG5cbiAgICAgICAgICAgICAgICBjb25zdCB3aW5kb3cgPSBzYW1wbGluZ19yYXRlICogY2h1bmtfbGVuZ3RoX3M7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RyaWRlID0gc2FtcGxpbmdfcmF0ZSAqIHN0cmlkZV9sZW5ndGhfcztcbiAgICAgICAgICAgICAgICBjb25zdCBqdW1wID0gd2luZG93IC0gMiAqIHN0cmlkZTtcbiAgICAgICAgICAgICAgICBsZXQgb2Zmc2V0ID0gMDtcblxuICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBzdWJhcnJheXMgb2YgYXVkaW8gd2l0aCBvdmVybGFwc1xuXG4gICAgICAgICAgICAgICAgd2hpbGUgKG9mZnNldCA8IGF1ZC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHN1YmFyciA9IGF1ZC5zdWJhcnJheShvZmZzZXQsIG9mZnNldCArIHdpbmRvdyk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBmZWF0dXJlID0gYXdhaXQgdGhpcy5wcm9jZXNzb3Ioc3ViYXJyKTtcblxuICAgICAgICAgICAgICAgICAgICBsZXQgaXNGaXJzdCA9IG9mZnNldCA9PT0gMDtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGlzTGFzdCA9IG9mZnNldCArIGp1bXAgPj0gYXVkLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgY2h1bmtzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RyaWRlOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViYXJyLmxlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0ZpcnN0ID8gMCA6IHN0cmlkZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0xhc3QgPyAwIDogc3RyaWRlXG4gICAgICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXRfZmVhdHVyZXM6IGZlYXR1cmUuaW5wdXRfZmVhdHVyZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBpc19sYXN0OiBpc0xhc3RcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ICs9IGp1bXA7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNodW5rcyA9IFt7XG4gICAgICAgICAgICAgICAgICAgIHN0cmlkZTogW2F1ZC5sZW5ndGgsIDAsIDBdLFxuICAgICAgICAgICAgICAgICAgICBpbnB1dF9mZWF0dXJlczogKGF3YWl0IHRoaXMucHJvY2Vzc29yKGF1ZCkpLmlucHV0X2ZlYXR1cmVzLFxuICAgICAgICAgICAgICAgICAgICBpc19sYXN0OiB0cnVlXG4gICAgICAgICAgICAgICAgfV1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gR2VuZXJhdGUgZm9yIGVhY2ggc2V0IG9mIGlucHV0IGZlYXR1cmVzXG4gICAgICAgICAgICBmb3IgKGxldCBjaHVuayBvZiBjaHVua3MpIHtcbiAgICAgICAgICAgICAgICAvLyBOT1RFOiBkb2luZyBzZXF1ZW50aWFsbHkgZm9yIG5vd1xuICAgICAgICAgICAgICAgIGxldCBkYXRhID0gYXdhaXQgdGhpcy5tb2RlbC5nZW5lcmF0ZShjaHVuay5pbnB1dF9mZWF0dXJlcywga3dhcmdzKTtcblxuICAgICAgICAgICAgICAgIC8vIFRPRE86IFJpZ2h0IG5vdyB3ZSBvbmx5IGdldCB0b3AgYmVhbVxuICAgICAgICAgICAgICAgIGlmIChyZXR1cm5fdGltZXN0YW1wcyA9PT0gJ3dvcmQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNodW5rLnRva2VucyA9IGRhdGEuc2VxdWVuY2VzWzBdO1xuICAgICAgICAgICAgICAgICAgICBjaHVuay50b2tlbl90aW1lc3RhbXBzID0gZGF0YS50b2tlbl90aW1lc3RhbXBzLnRvbGlzdCgpWzBdLm1hcChcbiAgICAgICAgICAgICAgICAgICAgICAgIHggPT4gcm91bmQoeCwgMilcbiAgICAgICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNodW5rLnRva2VucyA9IGRhdGFbMF07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gY29udmVydCBzdHJpZGUgdG8gc2Vjb25kc1xuICAgICAgICAgICAgICAgIGNodW5rLnN0cmlkZSA9IGNodW5rLnN0cmlkZS5tYXAoeCA9PiB4IC8gc2FtcGxpbmdfcmF0ZSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoY2h1bmtfY2FsbGJhY2sgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2h1bmtfY2FsbGJhY2soY2h1bmspXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBNZXJnZSB0ZXh0IGNodW5rc1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgbGV0IFtmdWxsX3RleHQsIG9wdGlvbmFsXSA9IHRoaXMudG9rZW5pemVyLl9kZWNvZGVfYXNyKGNodW5rcywge1xuICAgICAgICAgICAgICAgIHRpbWVfcHJlY2lzaW9uLCByZXR1cm5fdGltZXN0YW1wcywgZm9yY2VfZnVsbF9zZXF1ZW5jZXNcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB0b1JldHVybi5wdXNoKHsgdGV4dDogZnVsbF90ZXh0LCAuLi5vcHRpb25hbCB9KVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzaW5nbGUgPyB0b1JldHVyblswXSA6IHRvUmV0dXJuO1xuICAgIH1cbn1cblxuLyoqXG4gKiBJbWFnZSBUbyBUZXh0IHBpcGVsaW5lIHVzaW5nIGEgYEF1dG9Nb2RlbEZvclZpc2lvbjJTZXFgLiBUaGlzIHBpcGVsaW5lIHByZWRpY3RzIGEgY2FwdGlvbiBmb3IgYSBnaXZlbiBpbWFnZS5cbiAqIEBleHRlbmRzIFBpcGVsaW5lXG4gKi9cbmV4cG9ydCBjbGFzcyBJbWFnZVRvVGV4dFBpcGVsaW5lIGV4dGVuZHMgUGlwZWxpbmUge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBJbWFnZVRvVGV4dFBpcGVsaW5lLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0YXNrIFRoZSB0YXNrIG9mIHRoZSBwaXBlbGluZS4gVXNlZnVsIGZvciBzcGVjaWZ5aW5nIHN1YnRhc2tzLlxuICAgICAqIEBwYXJhbSB7UHJlVHJhaW5lZFRva2VuaXplcn0gdG9rZW5pemVyIFRoZSB0b2tlbml6ZXIgdG8gdXNlLlxuICAgICAqIEBwYXJhbSB7UHJlVHJhaW5lZE1vZGVsfSBtb2RlbCBUaGUgbW9kZWwgdG8gdXNlLlxuICAgICAqIEBwYXJhbSB7UHJvY2Vzc29yfSBwcm9jZXNzb3IgVGhlIHByb2Nlc3NvciB0byB1c2UuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IodGFzaywgdG9rZW5pemVyLCBtb2RlbCwgcHJvY2Vzc29yKSB7XG4gICAgICAgIHN1cGVyKHRhc2ssIHRva2VuaXplciwgbW9kZWwpO1xuICAgICAgICB0aGlzLnByb2Nlc3NvciA9IHByb2Nlc3NvcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBc3NpZ24gbGFiZWxzIHRvIHRoZSBpbWFnZShzKSBwYXNzZWQgYXMgaW5wdXRzLlxuICAgICAqIEBwYXJhbSB7YW55W119IGltYWdlcyBUaGUgaW1hZ2VzIHRvIGJlIGNhcHRpb25lZC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2dlbmVyYXRlX2t3YXJncz17fV0gT3B0aW9uYWwgZ2VuZXJhdGlvbiBhcmd1bWVudHMuXG4gICAgICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0fE9iamVjdFtdPn0gQSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYW4gb2JqZWN0IChvciBhcnJheSBvZiBvYmplY3RzKSBjb250YWluaW5nIHRoZSBnZW5lcmF0ZWQgdGV4dChzKS5cbiAgICAgKi9cbiAgICBhc3luYyBfY2FsbChpbWFnZXMsIGdlbmVyYXRlX2t3YXJncyA9IHt9KSB7XG4gICAgICAgIGxldCBpc0JhdGNoZWQgPSBBcnJheS5pc0FycmF5KGltYWdlcyk7XG5cbiAgICAgICAgaW1hZ2VzID0gYXdhaXQgcHJlcGFyZUltYWdlcyhpbWFnZXMpO1xuXG4gICAgICAgIGxldCB7IHBpeGVsX3ZhbHVlcyB9ID0gYXdhaXQgdGhpcy5wcm9jZXNzb3IoaW1hZ2VzKTtcblxuICAgICAgICBsZXQgdG9SZXR1cm4gPSBbXTtcbiAgICAgICAgZm9yIChsZXQgYmF0Y2ggb2YgcGl4ZWxfdmFsdWVzKSB7XG4gICAgICAgICAgICBiYXRjaC5kaW1zID0gWzEsIC4uLmJhdGNoLmRpbXNdXG4gICAgICAgICAgICBsZXQgb3V0cHV0ID0gYXdhaXQgdGhpcy5tb2RlbC5nZW5lcmF0ZShiYXRjaCwgZ2VuZXJhdGVfa3dhcmdzKTtcbiAgICAgICAgICAgIGxldCBkZWNvZGVkID0gdGhpcy50b2tlbml6ZXIuYmF0Y2hfZGVjb2RlKG91dHB1dCwge1xuICAgICAgICAgICAgICAgIHNraXBfc3BlY2lhbF90b2tlbnM6IHRydWUsXG4gICAgICAgICAgICB9KS5tYXAoeCA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZ2VuZXJhdGVkX3RleHQ6IHgudHJpbSgpIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB0b1JldHVybi5wdXNoKGRlY29kZWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGlzQmF0Y2hlZCA/IHRvUmV0dXJuIDogdG9SZXR1cm5bMF07XG4gICAgfVxufVxuXG4vKipcbiAqIEltYWdlIGNsYXNzaWZpY2F0aW9uIHBpcGVsaW5lIHVzaW5nIGFueSBgQXV0b01vZGVsRm9ySW1hZ2VDbGFzc2lmaWNhdGlvbmAuXG4gKiBUaGlzIHBpcGVsaW5lIHByZWRpY3RzIHRoZSBjbGFzcyBvZiBhbiBpbWFnZS5cbiAqIFxuICogKipFeGFtcGxlOioqIENsYXNzaWZ5IGFuIGltYWdlLlxuICogYGBgamF2YXNjcmlwdFxuICogbGV0IGNsYXNzaWZpZXIgPSBhd2FpdCBwaXBlbGluZSgnaW1hZ2UtY2xhc3NpZmljYXRpb24nLCAnWGVub3ZhL3ZpdC1iYXNlLXBhdGNoMTYtMjI0Jyk7XG4gKiBsZXQgdXJsID0gJ2h0dHBzOi8vaHVnZ2luZ2ZhY2UuY28vZGF0YXNldHMvWGVub3ZhL3RyYW5zZm9ybWVycy5qcy1kb2NzL3Jlc29sdmUvbWFpbi90aWdlci5qcGcnO1xuICogbGV0IG91dHB1dHMgPSBhd2FpdCBjbGFzc2lmaWVyKHVybCk7XG4gKiAvLyBBcnJheSgxKSBbXG4gKiAvLyAgIHtsYWJlbDogJ3RpZ2VyLCBQYW50aGVyYSB0aWdyaXMnLCBzY29yZTogMC42MzI2OTU3MzQ1MDA4ODV9LFxuICogLy8gXVxuICogYGBgXG4gKiBcbiAqICoqRXhhbXBsZToqKiBDbGFzc2lmeSBhbiBpbWFnZSBhbmQgcmV0dXJuIHRvcCBgbmAgY2xhc3Nlcy5cbiAqIGBgYGphdmFzY3JpcHRcbiAqIGxldCBjbGFzc2lmaWVyID0gYXdhaXQgcGlwZWxpbmUoJ2ltYWdlLWNsYXNzaWZpY2F0aW9uJywgJ1hlbm92YS92aXQtYmFzZS1wYXRjaDE2LTIyNCcpO1xuICogbGV0IHVybCA9ICdodHRwczovL2h1Z2dpbmdmYWNlLmNvL2RhdGFzZXRzL1hlbm92YS90cmFuc2Zvcm1lcnMuanMtZG9jcy9yZXNvbHZlL21haW4vdGlnZXIuanBnJztcbiAqIGxldCBvdXRwdXRzID0gYXdhaXQgY2xhc3NpZmllcih1cmwsIHsgdG9wazogMyB9KTtcbiAqIC8vIEFycmF5KDMpIFtcbiAqIC8vICAge2xhYmVsOiAndGlnZXIsIFBhbnRoZXJhIHRpZ3JpcycsIHNjb3JlOiAwLjYzMjY5NTczNDUwMDg4NX0sXG4gKiAvLyAgIHtsYWJlbDogJ3RpZ2VyIGNhdCcsIHNjb3JlOiAwLjM2MzQ4MjU2NDY4NzcyODl9LFxuICogLy8gICB7bGFiZWw6ICdsaW9uLCBraW5nIG9mIGJlYXN0cywgUGFudGhlcmEgbGVvJywgc2NvcmU6IDAuMDAwNDUwNjAzMDgxODQ0NzQ3MDd9LFxuICogLy8gXVxuICogYGBgXG4gKiBcbiAqICoqRXhhbXBsZToqKiBDbGFzc2lmeSBhbiBpbWFnZSBhbmQgcmV0dXJuIGFsbCBjbGFzc2VzLlxuICogYGBgamF2YXNjcmlwdFxuICogbGV0IGNsYXNzaWZpZXIgPSBhd2FpdCBwaXBlbGluZSgnaW1hZ2UtY2xhc3NpZmljYXRpb24nLCAnWGVub3ZhL3ZpdC1iYXNlLXBhdGNoMTYtMjI0Jyk7XG4gKiBsZXQgdXJsID0gJ2h0dHBzOi8vaHVnZ2luZ2ZhY2UuY28vZGF0YXNldHMvWGVub3ZhL3RyYW5zZm9ybWVycy5qcy1kb2NzL3Jlc29sdmUvbWFpbi90aWdlci5qcGcnO1xuICogbGV0IG91dHB1dHMgPSBhd2FpdCBjbGFzc2lmaWVyKHVybCwgeyB0b3BrOiAwIH0pO1xuICogLy8gQXJyYXkoMTAwMCkgW1xuICogLy8gICB7bGFiZWw6ICd0aWdlciwgUGFudGhlcmEgdGlncmlzJywgc2NvcmU6IDAuNjMyNjk1NzM0NTAwODg1fSxcbiAqIC8vICAge2xhYmVsOiAndGlnZXIgY2F0Jywgc2NvcmU6IDAuMzYzNDgyNTY0Njg3NzI4OX0sXG4gKiAvLyAgIHtsYWJlbDogJ2xpb24sIGtpbmcgb2YgYmVhc3RzLCBQYW50aGVyYSBsZW8nLCBzY29yZTogMC4wMDA0NTA2MDMwODE4NDQ3NDcwN30sXG4gKiAvLyAgIHtsYWJlbDogJ2phZ3VhciwgcGFudGhlciwgUGFudGhlcmEgb25jYSwgRmVsaXMgb25jYScsIHNjb3JlOiAwLjAwMDM1NDY1NDk5OTY4MjY3OTc3fSxcbiAqIC8vICAgLi4uXG4gKiAvLyBdXG4gKiBgYGBcbiAqIEBleHRlbmRzIFBpcGVsaW5lXG4gKi9cbmV4cG9ydCBjbGFzcyBJbWFnZUNsYXNzaWZpY2F0aW9uUGlwZWxpbmUgZXh0ZW5kcyBQaXBlbGluZSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IEltYWdlQ2xhc3NpZmljYXRpb25QaXBlbGluZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGFzayBUaGUgdGFzayBvZiB0aGUgcGlwZWxpbmUuIFVzZWZ1bCBmb3Igc3BlY2lmeWluZyBzdWJ0YXNrcy5cbiAgICAgKiBAcGFyYW0ge1ByZVRyYWluZWRNb2RlbH0gbW9kZWwgVGhlIG1vZGVsIHRvIHVzZS5cbiAgICAgKiBAcGFyYW0ge1Byb2Nlc3Nvcn0gcHJvY2Vzc29yIFRoZSBwcm9jZXNzb3IgdG8gdXNlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHRhc2ssIG1vZGVsLCBwcm9jZXNzb3IpIHtcbiAgICAgICAgc3VwZXIodGFzaywgbnVsbCwgbW9kZWwpOyAvLyBUT0RPIHRva2VuaXplclxuICAgICAgICB0aGlzLnByb2Nlc3NvciA9IHByb2Nlc3NvcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDbGFzc2lmeSB0aGUgZ2l2ZW4gaW1hZ2VzLlxuICAgICAqIEBwYXJhbSB7YW55fSBpbWFnZXMgVGhlIGltYWdlcyB0byBjbGFzc2lmeS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBUaGUgb3B0aW9ucyB0byB1c2UgZm9yIGNsYXNzaWZpY2F0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy50b3BrPTFdIFRoZSBudW1iZXIgb2YgdG9wIHJlc3VsdHMgdG8gcmV0dXJuLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPGFueT59IFRoZSB0b3AgY2xhc3NpZmljYXRpb24gcmVzdWx0cyBmb3IgdGhlIGltYWdlcy5cbiAgICAgKi9cbiAgICBhc3luYyBfY2FsbChpbWFnZXMsIHtcbiAgICAgICAgdG9wayA9IDFcbiAgICB9ID0ge30pIHtcbiAgICAgICAgbGV0IGlzQmF0Y2hlZCA9IEFycmF5LmlzQXJyYXkoaW1hZ2VzKTtcbiAgICAgICAgaW1hZ2VzID0gYXdhaXQgcHJlcGFyZUltYWdlcyhpbWFnZXMpO1xuXG4gICAgICAgIGxldCB7IHBpeGVsX3ZhbHVlcyB9ID0gYXdhaXQgdGhpcy5wcm9jZXNzb3IoaW1hZ2VzKTtcbiAgICAgICAgbGV0IG91dHB1dCA9IGF3YWl0IHRoaXMubW9kZWwoeyBwaXhlbF92YWx1ZXMgfSk7XG5cbiAgICAgICAgbGV0IGlkMmxhYmVsID0gdGhpcy5tb2RlbC5jb25maWcuaWQybGFiZWw7XG4gICAgICAgIGxldCB0b1JldHVybiA9IFtdO1xuICAgICAgICBmb3IgKGxldCBiYXRjaCBvZiBvdXRwdXQubG9naXRzKSB7XG4gICAgICAgICAgICBsZXQgc2NvcmVzID0gZ2V0VG9wSXRlbXMoc29mdG1heChiYXRjaC5kYXRhKSwgdG9wayk7XG5cbiAgICAgICAgICAgIGxldCB2YWxzID0gc2NvcmVzLm1hcChmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGxhYmVsOiBpZDJsYWJlbFt4WzBdXSxcbiAgICAgICAgICAgICAgICAgICAgc2NvcmU6IHhbMV0sXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAodG9wayA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHRvUmV0dXJuLnB1c2goLi4udmFscyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRvUmV0dXJuLnB1c2godmFscyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaXNCYXRjaGVkIHx8IHRvcGsgPT09IDEgPyB0b1JldHVybiA6IHRvUmV0dXJuWzBdO1xuICAgIH1cblxufVxuXG4vKipcbiAqIEltYWdlIHNlZ21lbnRhdGlvbiBwaXBlbGluZSB1c2luZyBhbnkgYEF1dG9Nb2RlbEZvclhYWFNlZ21lbnRhdGlvbmAuXG4gKiBUaGlzIHBpcGVsaW5lIHByZWRpY3RzIG1hc2tzIG9mIG9iamVjdHMgYW5kIHRoZWlyIGNsYXNzZXMuXG4gKiBAZXh0ZW5kcyBQaXBlbGluZVxuICovXG5leHBvcnQgY2xhc3MgSW1hZ2VTZWdtZW50YXRpb25QaXBlbGluZSBleHRlbmRzIFBpcGVsaW5lIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgSW1hZ2VTZWdtZW50YXRpb25QaXBlbGluZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGFzayBUaGUgdGFzayBvZiB0aGUgcGlwZWxpbmUuIFVzZWZ1bCBmb3Igc3BlY2lmeWluZyBzdWJ0YXNrcy5cbiAgICAgKiBAcGFyYW0ge1ByZVRyYWluZWRNb2RlbH0gbW9kZWwgVGhlIG1vZGVsIHRvIHVzZS5cbiAgICAgKiBAcGFyYW0ge1Byb2Nlc3Nvcn0gcHJvY2Vzc29yIFRoZSBwcm9jZXNzb3IgdG8gdXNlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHRhc2ssIG1vZGVsLCBwcm9jZXNzb3IpIHtcbiAgICAgICAgc3VwZXIodGFzaywgbnVsbCwgbW9kZWwpOyAvLyBUT0RPIHRva2VuaXplclxuICAgICAgICB0aGlzLnByb2Nlc3NvciA9IHByb2Nlc3NvcjtcblxuICAgICAgICB0aGlzLnN1YnRhc2tzX21hcHBpbmcgPSB7XG4gICAgICAgICAgICAvLyBNYXBwaW5nIG9mIHN1YnRhc2tzIHRvIHRoZWlyIGNvcnJlc3BvbmRpbmcgcG9zdC1wcm9jZXNzaW5nIGZ1bmN0aW9uIG5hbWVzLlxuICAgICAgICAgICAgcGFub3B0aWM6ICdwb3N0X3Byb2Nlc3NfcGFub3B0aWNfc2VnbWVudGF0aW9uJyxcbiAgICAgICAgICAgIGluc3RhbmNlOiAncG9zdF9wcm9jZXNzX2luc3RhbmNlX3NlZ21lbnRhdGlvbicsXG4gICAgICAgICAgICBzZW1hbnRpYzogJ3Bvc3RfcHJvY2Vzc19zZW1hbnRpY19zZWdtZW50YXRpb24nXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZWdtZW50IHRoZSBpbnB1dCBpbWFnZXMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gaW1hZ2VzIFRoZSBpbnB1dCBpbWFnZXMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgVGhlIG9wdGlvbnMgdG8gdXNlIGZvciBzZWdtZW50YXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnRocmVzaG9sZD0wLjVdIFByb2JhYmlsaXR5IHRocmVzaG9sZCB0byBmaWx0ZXIgb3V0IHByZWRpY3RlZCBtYXNrcy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMubWFza190aHJlc2hvbGQ9MC41XSBUaHJlc2hvbGQgdG8gdXNlIHdoZW4gdHVybmluZyB0aGUgcHJlZGljdGVkIG1hc2tzIGludG8gYmluYXJ5IHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMub3ZlcmxhcF9tYXNrX2FyZWFfdGhyZXNob2xkPTAuOF0gTWFzayBvdmVybGFwIHRocmVzaG9sZCB0byBlbGltaW5hdGUgc21hbGwsIGRpc2Nvbm5lY3RlZCBzZWdtZW50cy5cbiAgICAgKiBAcGFyYW0ge251bGx8c3RyaW5nfSBbb3B0aW9ucy5zdWJ0YXNrPW51bGxdIFNlZ21lbnRhdGlvbiB0YXNrIHRvIGJlIHBlcmZvcm1lZC4gT25lIG9mIFtgcGFub3B0aWNgLCBgaW5zdGFuY2VgLCBhbmQgYHNlbWFudGljYF0sIGRlcGVuZGluZyBvbiBtb2RlbCBjYXBhYmlsaXRpZXMuIElmIG5vdCBzZXQsIHRoZSBwaXBlbGluZSB3aWxsIGF0dGVtcHQgdG8gcmVzb2x2ZSAoaW4gdGhhdCBvcmRlcikuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW29wdGlvbnMubGFiZWxfaWRzX3RvX2Z1c2U9bnVsbF0gTGlzdCBvZiBsYWJlbCBpZHMgdG8gZnVzZS4gSWYgbm90IHNldCwgZG8gbm90IGZ1c2UgYW55IGxhYmVscy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbb3B0aW9ucy50YXJnZXRfc2l6ZXM9bnVsbF0gTGlzdCBvZiB0YXJnZXQgc2l6ZXMgZm9yIHRoZSBpbnB1dCBpbWFnZXMuIElmIG5vdCBzZXQsIHVzZSB0aGUgb3JpZ2luYWwgaW1hZ2Ugc2l6ZXMuXG4gICAgICogQHJldHVybnMge1Byb21pc2U8QXJyYXk+fSBUaGUgYW5ub3RhdGVkIHNlZ21lbnRzLlxuICAgICAqL1xuICAgIGFzeW5jIF9jYWxsKGltYWdlcywge1xuICAgICAgICB0aHJlc2hvbGQgPSAwLjUsXG4gICAgICAgIG1hc2tfdGhyZXNob2xkID0gMC41LFxuICAgICAgICBvdmVybGFwX21hc2tfYXJlYV90aHJlc2hvbGQgPSAwLjgsXG4gICAgICAgIGxhYmVsX2lkc190b19mdXNlID0gbnVsbCxcbiAgICAgICAgdGFyZ2V0X3NpemVzID0gbnVsbCxcbiAgICAgICAgc3VidGFzayA9IG51bGwsIC8vIFRPRE8gdXNlXG4gICAgfSA9IHt9KSB7XG4gICAgICAgIGxldCBpc0JhdGNoZWQgPSBBcnJheS5pc0FycmF5KGltYWdlcyk7XG5cbiAgICAgICAgaWYgKGlzQmF0Y2hlZCAmJiBpbWFnZXMubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcIkltYWdlIHNlZ21lbnRhdGlvbiBwaXBlbGluZSBjdXJyZW50bHkgb25seSBzdXBwb3J0cyBhIGJhdGNoIHNpemUgb2YgMS5cIik7XG4gICAgICAgIH1cblxuICAgICAgICBpbWFnZXMgPSBhd2FpdCBwcmVwYXJlSW1hZ2VzKGltYWdlcyk7XG4gICAgICAgIGxldCBpbWFnZVNpemVzID0gaW1hZ2VzLm1hcCh4ID0+IFt4LmhlaWdodCwgeC53aWR0aF0pO1xuXG4gICAgICAgIGxldCB7IHBpeGVsX3ZhbHVlcywgcGl4ZWxfbWFzayB9ID0gYXdhaXQgdGhpcy5wcm9jZXNzb3IoaW1hZ2VzKTtcbiAgICAgICAgbGV0IG91dHB1dCA9IGF3YWl0IHRoaXMubW9kZWwoeyBwaXhlbF92YWx1ZXMsIHBpeGVsX21hc2sgfSk7XG5cbiAgICAgICAgbGV0IGZuID0gbnVsbDtcbiAgICAgICAgaWYgKHN1YnRhc2sgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGZuID0gdGhpcy5zdWJ0YXNrc19tYXBwaW5nW3N1YnRhc2tdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm9yIChsZXQgW3Rhc2ssIGZ1bmNdIG9mIE9iamVjdC5lbnRyaWVzKHRoaXMuc3VidGFza3NfbWFwcGluZykpIHtcbiAgICAgICAgICAgICAgICBpZiAoZnVuYyBpbiB0aGlzLnByb2Nlc3Nvci5mZWF0dXJlX2V4dHJhY3Rvcikge1xuICAgICAgICAgICAgICAgICAgICBmbiA9IHRoaXMucHJvY2Vzc29yLmZlYXR1cmVfZXh0cmFjdG9yW2Z1bmNdLmJpbmQodGhpcy5wcm9jZXNzb3IuZmVhdHVyZV9leHRyYWN0b3IpO1xuICAgICAgICAgICAgICAgICAgICBzdWJ0YXNrID0gdGFzaztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gYWRkIGFubm90YXRpb25zXG4gICAgICAgIGxldCBhbm5vdGF0aW9uID0gW107XG5cbiAgICAgICAgaWYgKHN1YnRhc2sgPT09ICdwYW5vcHRpYycgfHwgc3VidGFzayA9PT0gJ2luc3RhbmNlJykge1xuXG4gICAgICAgICAgICBsZXQgcHJvY2Vzc2VkID0gZm4oXG4gICAgICAgICAgICAgICAgb3V0cHV0LFxuICAgICAgICAgICAgICAgIHRocmVzaG9sZCxcbiAgICAgICAgICAgICAgICBtYXNrX3RocmVzaG9sZCxcbiAgICAgICAgICAgICAgICBvdmVybGFwX21hc2tfYXJlYV90aHJlc2hvbGQsXG4gICAgICAgICAgICAgICAgbGFiZWxfaWRzX3RvX2Z1c2UsXG4gICAgICAgICAgICAgICAgdGFyZ2V0X3NpemVzID8/IGltYWdlU2l6ZXMsIC8vIFRPRE8gRklYP1xuICAgICAgICAgICAgKVswXTtcblxuICAgICAgICAgICAgbGV0IHNlZ21lbnRhdGlvbiA9IHByb2Nlc3NlZC5zZWdtZW50YXRpb247XG4gICAgICAgICAgICBsZXQgaWQybGFiZWwgPSB0aGlzLm1vZGVsLmNvbmZpZy5pZDJsYWJlbDtcblxuICAgICAgICAgICAgZm9yIChsZXQgc2VnbWVudCBvZiBwcm9jZXNzZWQuc2VnbWVudHNfaW5mbykge1xuICAgICAgICAgICAgICAgIGxldCBtYXNrRGF0YSA9IG5ldyBVaW50OENsYW1wZWRBcnJheShzZWdtZW50YXRpb24uZGF0YS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2VnbWVudGF0aW9uLmRhdGEubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlZ21lbnRhdGlvbi5kYXRhW2ldID09PSBzZWdtZW50LmlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXNrRGF0YVtpXSA9IDI1NTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGxldCBtYXNrID0gbmV3IFJhd0ltYWdlKG1hc2tEYXRhLCBzZWdtZW50YXRpb24uZGltc1sxXSwgc2VnbWVudGF0aW9uLmRpbXNbMF0sIDEpXG5cbiAgICAgICAgICAgICAgICBhbm5vdGF0aW9uLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBzY29yZTogc2VnbWVudC5zY29yZSxcbiAgICAgICAgICAgICAgICAgICAgbGFiZWw6IGlkMmxhYmVsW3NlZ21lbnQubGFiZWxfaWRdLFxuICAgICAgICAgICAgICAgICAgICBtYXNrOiBtYXNrXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2UgaWYgKHN1YnRhc2sgPT09ICdzZW1hbnRpYycpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKGBzZW1hbnRpYyBzZWdtZW50YXRpb24gbm90IHlldCBzdXBwb3J0ZWQuYCk7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKGBTdWJ0YXNrICR7c3VidGFza30gbm90IHN1cHBvcnRlZC5gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhbm5vdGF0aW9uO1xuICAgIH1cbn1cblxuXG4vKipcbiAqIFplcm8gc2hvdCBpbWFnZSBjbGFzc2lmaWNhdGlvbiBwaXBlbGluZS4gVGhpcyBwaXBlbGluZSBwcmVkaWN0cyB0aGUgY2xhc3Mgb2ZcbiAqIGFuIGltYWdlIHdoZW4geW91IHByb3ZpZGUgYW4gaW1hZ2UgYW5kIGEgc2V0IG9mIGBjYW5kaWRhdGVfbGFiZWxzYC5cbiAqIEBleHRlbmRzIFBpcGVsaW5lXG4gKi9cbmV4cG9ydCBjbGFzcyBaZXJvU2hvdEltYWdlQ2xhc3NpZmljYXRpb25QaXBlbGluZSBleHRlbmRzIFBpcGVsaW5lIHtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBaZXJvU2hvdEltYWdlQ2xhc3NpZmljYXRpb25QaXBlbGluZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGFzayBUaGUgdGFzayBvZiB0aGUgcGlwZWxpbmUuIFVzZWZ1bCBmb3Igc3BlY2lmeWluZyBzdWJ0YXNrcy5cbiAgICAgKiBAcGFyYW0ge1ByZVRyYWluZWRUb2tlbml6ZXJ9IHRva2VuaXplciBUaGUgdG9rZW5pemVyIHRvIHVzZS5cbiAgICAgKiBAcGFyYW0ge1ByZVRyYWluZWRNb2RlbH0gbW9kZWwgVGhlIG1vZGVsIHRvIHVzZS5cbiAgICAgKiBAcGFyYW0ge1Byb2Nlc3Nvcn0gcHJvY2Vzc29yIFRoZSBwcm9jZXNzb3IgdG8gdXNlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHRhc2ssIHRva2VuaXplciwgbW9kZWwsIHByb2Nlc3Nvcikge1xuICAgICAgICBzdXBlcih0YXNrLCB0b2tlbml6ZXIsIG1vZGVsKTtcbiAgICAgICAgdGhpcy5wcm9jZXNzb3IgPSBwcm9jZXNzb3I7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2xhc3NpZnkgdGhlIGlucHV0IGltYWdlcyB3aXRoIGNhbmRpZGF0ZSBsYWJlbHMgdXNpbmcgYSB6ZXJvLXNob3QgYXBwcm9hY2guXG4gICAgICogQHBhcmFtIHtBcnJheX0gaW1hZ2VzIFRoZSBpbnB1dCBpbWFnZXMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gY2FuZGlkYXRlX2xhYmVscyBUaGUgY2FuZGlkYXRlIGxhYmVscy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBUaGUgb3B0aW9ucyBmb3IgdGhlIGNsYXNzaWZpY2F0aW9uLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5oeXBvdGhlc2lzX3RlbXBsYXRlXSBUaGUgaHlwb3RoZXNpcyB0ZW1wbGF0ZSB0byB1c2UgZm9yIHplcm8tc2hvdCBjbGFzc2lmaWNhdGlvbi4gRGVmYXVsdDogXCJUaGlzIGlzIGEgcGhvdG8gb2Yge31cIi5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxhbnk+fSBBbiBhcnJheSBvZiBjbGFzc2lmaWNhdGlvbnMgZm9yIGVhY2ggaW5wdXQgaW1hZ2Ugb3IgYSBzaW5nbGUgY2xhc3NpZmljYXRpb24gb2JqZWN0IGlmIG9ubHkgb25lIGlucHV0IGltYWdlIGlzIHByb3ZpZGVkLlxuICAgICAqL1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBhc3luYyBfY2FsbChpbWFnZXMsIGNhbmRpZGF0ZV9sYWJlbHMsIHtcbiAgICAgICAgaHlwb3RoZXNpc190ZW1wbGF0ZSA9IFwiVGhpcyBpcyBhIHBob3RvIG9mIHt9XCJcbiAgICB9ID0ge30pIHtcbiAgICAgICAgbGV0IGlzQmF0Y2hlZCA9IEFycmF5LmlzQXJyYXkoaW1hZ2VzKTtcbiAgICAgICAgaW1hZ2VzID0gYXdhaXQgcHJlcGFyZUltYWdlcyhpbWFnZXMpO1xuXG4gICAgICAgIC8vIEluc2VydCBsYWJlbCBpbnRvIGh5cG90aGVzaXMgdGVtcGxhdGUgXG4gICAgICAgIGxldCB0ZXh0cyA9IGNhbmRpZGF0ZV9sYWJlbHMubWFwKFxuICAgICAgICAgICAgeCA9PiBoeXBvdGhlc2lzX3RlbXBsYXRlLnJlcGxhY2UoJ3t9JywgeClcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBSdW4gdG9rZW5pemF0aW9uXG4gICAgICAgIGxldCB0ZXh0X2lucHV0cyA9IHRoaXMudG9rZW5pemVyKHRleHRzLCB7XG4gICAgICAgICAgICBwYWRkaW5nOiB0cnVlLFxuICAgICAgICAgICAgdHJ1bmNhdGlvbjogdHJ1ZVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBSdW4gcHJvY2Vzc29yXG4gICAgICAgIGxldCB7IHBpeGVsX3ZhbHVlcyB9ID0gYXdhaXQgdGhpcy5wcm9jZXNzb3IoaW1hZ2VzKTtcblxuICAgICAgICAvLyBSdW4gbW9kZWwgd2l0aCBib3RoIHRleHQgYW5kIHBpeGVsIGlucHV0c1xuICAgICAgICBsZXQgb3V0cHV0ID0gYXdhaXQgdGhpcy5tb2RlbCh7IC4uLnRleHRfaW5wdXRzLCBwaXhlbF92YWx1ZXMgfSk7XG5cbiAgICAgICAgLy8gQ29tcGFyZSBlYWNoIGltYWdlIHdpdGggZWFjaCBjYW5kaWRhdGUgbGFiZWxcbiAgICAgICAgbGV0IHRvUmV0dXJuID0gW107XG4gICAgICAgIGZvciAobGV0IGJhdGNoIG9mIG91dHB1dC5sb2dpdHNfcGVyX2ltYWdlKSB7XG4gICAgICAgICAgICAvLyBDb21wdXRlIHNvZnRtYXggcGVyIGltYWdlXG4gICAgICAgICAgICBsZXQgcHJvYnMgPSBzb2Z0bWF4KGJhdGNoLmRhdGEpO1xuXG4gICAgICAgICAgICB0b1JldHVybi5wdXNoKFsuLi5wcm9ic10ubWFwKCh4LCBpKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgc2NvcmU6IHgsXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsOiBjYW5kaWRhdGVfbGFiZWxzW2ldXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGlzQmF0Y2hlZCA/IHRvUmV0dXJuIDogdG9SZXR1cm5bMF07XG4gICAgfVxufVxuXG4vKipcbiAqIE9iamVjdCBkZXRlY3Rpb24gcGlwZWxpbmUgdXNpbmcgYW55IGBBdXRvTW9kZWxGb3JPYmplY3REZXRlY3Rpb25gLlxuICogVGhpcyBwaXBlbGluZSBwcmVkaWN0cyBib3VuZGluZyBib3hlcyBvZiBvYmplY3RzIGFuZCB0aGVpciBjbGFzc2VzLlxuICogXG4gKiAqKkV4YW1wbGU6KiogUnVuIG9iamVjdC1kZXRlY3Rpb24gd2l0aCBgZmFjZWJvb2svZGV0ci1yZXNuZXQtNTBgLlxuICogYGBgamF2YXNjcmlwdFxuICogbGV0IGltZyA9ICdodHRwczovL2h1Z2dpbmdmYWNlLmNvL2RhdGFzZXRzL1hlbm92YS90cmFuc2Zvcm1lcnMuanMtZG9jcy9yZXNvbHZlL21haW4vY2F0cy5qcGcnO1xuICogXG4gKiBsZXQgZGV0ZWN0b3IgPSBhd2FpdCBwaXBlbGluZSgnb2JqZWN0LWRldGVjdGlvbicsICdYZW5vdmEvZGV0ci1yZXNuZXQtNTAnKTtcbiAqIGxldCBvdXRwdXQgPSBhd2FpdCBkZXRlY3RvcihpbWcsIHsgdGhyZXNob2xkOiAwLjkgfSk7XG4gKiAvLyBbe1xuICogLy8gICBcInNjb3JlXCI6IDAuOTk3NjM3MDkzMDY3MTY5MixcbiAqIC8vICAgXCJsYWJlbFwiOiBcInJlbW90ZVwiLFxuICogLy8gICBcImJveFwiOiB7IFwieG1pblwiOiAzMSwgXCJ5bWluXCI6IDY4LCBcInhtYXhcIjogMTkwLCBcInltYXhcIjogMTE4IH1cbiAqIC8vIH0sXG4gKiAvLyAuLi5cbiAqIC8vIHtcbiAqIC8vICAgXCJzY29yZVwiOiAwLjk5ODQwOTIxMTYzNTU4OTYsXG4gKiAvLyAgIFwibGFiZWxcIjogXCJjYXRcIixcbiAqIC8vICAgXCJib3hcIjogeyBcInhtaW5cIjogMzMxLCBcInltaW5cIjogMTksIFwieG1heFwiOiA2NDksIFwieW1heFwiOiAzNzEgfVxuICogLy8gfV1cbiAqIGBgYFxuICogXG4gKiBAZXh0ZW5kcyBQaXBlbGluZVxuICovXG5leHBvcnQgY2xhc3MgT2JqZWN0RGV0ZWN0aW9uUGlwZWxpbmUgZXh0ZW5kcyBQaXBlbGluZSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IE9iamVjdERldGVjdGlvblBpcGVsaW5lLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0YXNrIFRoZSB0YXNrIG9mIHRoZSBwaXBlbGluZS4gVXNlZnVsIGZvciBzcGVjaWZ5aW5nIHN1YnRhc2tzLlxuICAgICAqIEBwYXJhbSB7UHJlVHJhaW5lZE1vZGVsfSBtb2RlbCBUaGUgbW9kZWwgdG8gdXNlLlxuICAgICAqIEBwYXJhbSB7UHJvY2Vzc29yfSBwcm9jZXNzb3IgVGhlIHByb2Nlc3NvciB0byB1c2UuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IodGFzaywgbW9kZWwsIHByb2Nlc3Nvcikge1xuICAgICAgICBzdXBlcih0YXNrLCBudWxsLCBtb2RlbCk7IC8vIFRPRE8gdG9rZW5pemVyXG4gICAgICAgIHRoaXMucHJvY2Vzc29yID0gcHJvY2Vzc29yO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERldGVjdCBvYmplY3RzIChib3VuZGluZyBib3hlcyAmIGNsYXNzZXMpIGluIHRoZSBpbWFnZShzKSBwYXNzZWQgYXMgaW5wdXRzLlxuICAgICAqIEBwYXJhbSB7YW55W119IGltYWdlcyBUaGUgaW5wdXQgaW1hZ2VzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIFRoZSBvcHRpb25zIGZvciB0aGUgb2JqZWN0IGRldGVjdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMudGhyZXNob2xkPTAuOV0gVGhlIHRocmVzaG9sZCB1c2VkIHRvIGZpbHRlciBib3hlcyBieSBzY29yZS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnBlcmNlbnRhZ2U9ZmFsc2VdIFdoZXRoZXIgdG8gcmV0dXJuIHRoZSBib3hlcyBjb29yZGluYXRlcyBpbiBwZXJjZW50YWdlICh0cnVlKSBvciBpbiBwaXhlbHMgKGZhbHNlKS5cbiAgICAgKi9cbiAgICBhc3luYyBfY2FsbChpbWFnZXMsIHtcbiAgICAgICAgdGhyZXNob2xkID0gMC45LFxuICAgICAgICBwZXJjZW50YWdlID0gZmFsc2UsXG4gICAgfSA9IHt9KSB7XG4gICAgICAgIGxldCBpc0JhdGNoZWQgPSBBcnJheS5pc0FycmF5KGltYWdlcyk7XG5cbiAgICAgICAgaWYgKGlzQmF0Y2hlZCAmJiBpbWFnZXMubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcIk9iamVjdCBkZXRlY3Rpb24gcGlwZWxpbmUgY3VycmVudGx5IG9ubHkgc3VwcG9ydHMgYSBiYXRjaCBzaXplIG9mIDEuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGltYWdlcyA9IGF3YWl0IHByZXBhcmVJbWFnZXMoaW1hZ2VzKTtcblxuICAgICAgICBsZXQgaW1hZ2VTaXplcyA9IHBlcmNlbnRhZ2UgPyBudWxsIDogaW1hZ2VzLm1hcCh4ID0+IFt4LmhlaWdodCwgeC53aWR0aF0pO1xuXG4gICAgICAgIGxldCB7IHBpeGVsX3ZhbHVlcywgcGl4ZWxfbWFzayB9ID0gYXdhaXQgdGhpcy5wcm9jZXNzb3IoaW1hZ2VzKTtcbiAgICAgICAgbGV0IG91dHB1dCA9IGF3YWl0IHRoaXMubW9kZWwoeyBwaXhlbF92YWx1ZXMsIHBpeGVsX21hc2sgfSk7XG5cbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBsZXQgcHJvY2Vzc2VkID0gdGhpcy5wcm9jZXNzb3IuZmVhdHVyZV9leHRyYWN0b3IucG9zdF9wcm9jZXNzX29iamVjdF9kZXRlY3Rpb24ob3V0cHV0LCB0aHJlc2hvbGQsIGltYWdlU2l6ZXMpO1xuXG4gICAgICAgIC8vIEFkZCBsYWJlbHNcbiAgICAgICAgbGV0IGlkMmxhYmVsID0gdGhpcy5tb2RlbC5jb25maWcuaWQybGFiZWw7XG5cbiAgICAgICAgLy8gRm9ybWF0IG91dHB1dFxuICAgICAgICBjb25zdCByZXN1bHQgPSBwcm9jZXNzZWQubWFwKGJhdGNoID0+IHtcbiAgICAgICAgICAgIHJldHVybiBiYXRjaC5ib3hlcy5tYXAoKGJveCwgaSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHNjb3JlOiBiYXRjaC5zY29yZXNbaV0sXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsOiBpZDJsYWJlbFtiYXRjaC5jbGFzc2VzW2ldXSxcbiAgICAgICAgICAgICAgICAgICAgYm94OiB0aGlzLl9nZXRfYm91bmRpbmdfYm94KGJveCwgIXBlcmNlbnRhZ2UpLFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0pXG5cbiAgICAgICAgcmV0dXJuIGlzQmF0Y2hlZCA/IHJlc3VsdCA6IHJlc3VsdFswXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIZWxwZXIgZnVuY3Rpb24gdG8gY29udmVydCBsaXN0IFt4bWluLCB4bWF4LCB5bWluLCB5bWF4XSBpbnRvIG9iamVjdCB7IFwieG1pblwiOiB4bWluLCAuLi4gfVxuICAgICAqIEBwYXJhbSB7bnVtYmVyW119IGJveCBUaGUgYm91bmRpbmcgYm94IGFzIGEgbGlzdC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGFzSW50ZWdlciBXaGV0aGVyIHRvIGNhc3QgdG8gaW50ZWdlcnMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gVGhlIGJvdW5kaW5nIGJveCBhcyBhbiBvYmplY3QuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZ2V0X2JvdW5kaW5nX2JveChib3gsIGFzSW50ZWdlcikge1xuICAgICAgICBpZiAoYXNJbnRlZ2VyKSB7XG4gICAgICAgICAgICBib3ggPSBib3gubWFwKHggPT4geCB8IDApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IFt4bWluLCB5bWluLCB4bWF4LCB5bWF4XSA9IGJveDtcblxuICAgICAgICByZXR1cm4geyB4bWluLCB5bWluLCB4bWF4LCB5bWF4IH07XG4gICAgfVxufVxuXG5jb25zdCBTVVBQT1JURURfVEFTS1MgPSB7XG4gICAgXCJ0ZXh0LWNsYXNzaWZpY2F0aW9uXCI6IHtcbiAgICAgICAgXCJ0b2tlbml6ZXJcIjogQXV0b1Rva2VuaXplcixcbiAgICAgICAgXCJwaXBlbGluZVwiOiBUZXh0Q2xhc3NpZmljYXRpb25QaXBlbGluZSxcbiAgICAgICAgXCJtb2RlbFwiOiBBdXRvTW9kZWxGb3JTZXF1ZW5jZUNsYXNzaWZpY2F0aW9uLFxuICAgICAgICBcImRlZmF1bHRcIjoge1xuICAgICAgICAgICAgLy8gVE9ETzogcmVwbGFjZSB3aXRoIG9yaWdpbmFsXG4gICAgICAgICAgICAvLyBcIm1vZGVsXCI6IFwiZGlzdGlsYmVydC1iYXNlLXVuY2FzZWQtZmluZXR1bmVkLXNzdC0yLWVuZ2xpc2hcIixcbiAgICAgICAgICAgIFwibW9kZWxcIjogXCJYZW5vdmEvZGlzdGlsYmVydC1iYXNlLXVuY2FzZWQtZmluZXR1bmVkLXNzdC0yLWVuZ2xpc2hcIixcbiAgICAgICAgfSxcbiAgICAgICAgXCJ0eXBlXCI6IFwidGV4dFwiLFxuICAgIH0sXG4gICAgXCJ0b2tlbi1jbGFzc2lmaWNhdGlvblwiOiB7XG4gICAgICAgIFwidG9rZW5pemVyXCI6IEF1dG9Ub2tlbml6ZXIsXG4gICAgICAgIFwicGlwZWxpbmVcIjogVG9rZW5DbGFzc2lmaWNhdGlvblBpcGVsaW5lLFxuICAgICAgICBcIm1vZGVsXCI6IEF1dG9Nb2RlbEZvclRva2VuQ2xhc3NpZmljYXRpb24sXG4gICAgICAgIFwiZGVmYXVsdFwiOiB7XG4gICAgICAgICAgICAvLyBUT0RPOiByZXBsYWNlIHdpdGggb3JpZ2luYWxcbiAgICAgICAgICAgIC8vIFwibW9kZWxcIjogXCJEYXZsYW4vYmVydC1iYXNlLW11bHRpbGluZ3VhbC1jYXNlZC1uZXItaHJsXCIsXG4gICAgICAgICAgICBcIm1vZGVsXCI6IFwiWGVub3ZhL2JlcnQtYmFzZS1tdWx0aWxpbmd1YWwtY2FzZWQtbmVyLWhybFwiLFxuICAgICAgICB9LFxuICAgICAgICBcInR5cGVcIjogXCJ0ZXh0XCIsXG4gICAgfSxcbiAgICBcInF1ZXN0aW9uLWFuc3dlcmluZ1wiOiB7XG4gICAgICAgIFwidG9rZW5pemVyXCI6IEF1dG9Ub2tlbml6ZXIsXG4gICAgICAgIFwicGlwZWxpbmVcIjogUXVlc3Rpb25BbnN3ZXJpbmdQaXBlbGluZSxcbiAgICAgICAgXCJtb2RlbFwiOiBBdXRvTW9kZWxGb3JRdWVzdGlvbkFuc3dlcmluZyxcbiAgICAgICAgXCJkZWZhdWx0XCI6IHtcbiAgICAgICAgICAgIC8vIFRPRE86IHJlcGxhY2Ugd2l0aCBvcmlnaW5hbFxuICAgICAgICAgICAgLy8gXCJtb2RlbFwiOiBcImRpc3RpbGJlcnQtYmFzZS1jYXNlZC1kaXN0aWxsZWQtc3F1YWRcIixcbiAgICAgICAgICAgIFwibW9kZWxcIjogXCJYZW5vdmEvZGlzdGlsYmVydC1iYXNlLWNhc2VkLWRpc3RpbGxlZC1zcXVhZFwiLFxuICAgICAgICB9LFxuICAgICAgICBcInR5cGVcIjogXCJ0ZXh0XCIsXG4gICAgfSxcblxuICAgIFwiZmlsbC1tYXNrXCI6IHtcbiAgICAgICAgXCJ0b2tlbml6ZXJcIjogQXV0b1Rva2VuaXplcixcbiAgICAgICAgXCJwaXBlbGluZVwiOiBGaWxsTWFza1BpcGVsaW5lLFxuICAgICAgICBcIm1vZGVsXCI6IEF1dG9Nb2RlbEZvck1hc2tlZExNLFxuICAgICAgICBcImRlZmF1bHRcIjoge1xuICAgICAgICAgICAgLy8gVE9ETzogcmVwbGFjZSB3aXRoIG9yaWdpbmFsXG4gICAgICAgICAgICAvLyBcIm1vZGVsXCI6IFwiYmVydC1iYXNlLXVuY2FzZWRcIixcbiAgICAgICAgICAgIFwibW9kZWxcIjogXCJYZW5vdmEvYmVydC1iYXNlLXVuY2FzZWRcIixcbiAgICAgICAgfSxcbiAgICAgICAgXCJ0eXBlXCI6IFwidGV4dFwiLFxuICAgIH0sXG4gICAgXCJzdW1tYXJpemF0aW9uXCI6IHtcbiAgICAgICAgXCJ0b2tlbml6ZXJcIjogQXV0b1Rva2VuaXplcixcbiAgICAgICAgXCJwaXBlbGluZVwiOiBTdW1tYXJpemF0aW9uUGlwZWxpbmUsXG4gICAgICAgIFwibW9kZWxcIjogQXV0b01vZGVsRm9yU2VxMlNlcUxNLFxuICAgICAgICBcImRlZmF1bHRcIjoge1xuICAgICAgICAgICAgLy8gVE9ETzogcmVwbGFjZSB3aXRoIG9yaWdpbmFsXG4gICAgICAgICAgICAvLyBcIm1vZGVsXCI6IFwic3NobGVpZmVyL2Rpc3RpbGJhcnQtY25uLTYtNlwiLFxuICAgICAgICAgICAgXCJtb2RlbFwiOiBcIlhlbm92YS9kaXN0aWxiYXJ0LWNubi02LTZcIixcbiAgICAgICAgfSxcbiAgICAgICAgXCJ0eXBlXCI6IFwidGV4dFwiLFxuICAgIH0sXG4gICAgXCJ0cmFuc2xhdGlvblwiOiB7XG4gICAgICAgIFwidG9rZW5pemVyXCI6IEF1dG9Ub2tlbml6ZXIsXG4gICAgICAgIFwicGlwZWxpbmVcIjogVHJhbnNsYXRpb25QaXBlbGluZSxcbiAgICAgICAgXCJtb2RlbFwiOiBBdXRvTW9kZWxGb3JTZXEyU2VxTE0sXG4gICAgICAgIFwiZGVmYXVsdFwiOiB7XG4gICAgICAgICAgICAvLyBUT0RPOiByZXBsYWNlIHdpdGggb3JpZ2luYWxcbiAgICAgICAgICAgIC8vIFwibW9kZWxcIjogXCJ0NS1zbWFsbFwiLFxuICAgICAgICAgICAgXCJtb2RlbFwiOiBcIlhlbm92YS90NS1zbWFsbFwiLFxuICAgICAgICB9LFxuICAgICAgICBcInR5cGVcIjogXCJ0ZXh0XCIsXG4gICAgfSxcbiAgICBcInRleHQydGV4dC1nZW5lcmF0aW9uXCI6IHtcbiAgICAgICAgXCJ0b2tlbml6ZXJcIjogQXV0b1Rva2VuaXplcixcbiAgICAgICAgXCJwaXBlbGluZVwiOiBUZXh0MlRleHRHZW5lcmF0aW9uUGlwZWxpbmUsXG4gICAgICAgIFwibW9kZWxcIjogQXV0b01vZGVsRm9yU2VxMlNlcUxNLFxuICAgICAgICBcImRlZmF1bHRcIjoge1xuICAgICAgICAgICAgLy8gVE9ETzogcmVwbGFjZSB3aXRoIG9yaWdpbmFsXG4gICAgICAgICAgICAvLyBcIm1vZGVsXCI6IFwiZ29vZ2xlL2ZsYW4tdDUtc21hbGxcIixcbiAgICAgICAgICAgIFwibW9kZWxcIjogXCJYZW5vdmEvZmxhbi10NS1zbWFsbFwiLFxuICAgICAgICB9LFxuICAgICAgICBcInR5cGVcIjogXCJ0ZXh0XCIsXG4gICAgfSxcbiAgICBcInRleHQtZ2VuZXJhdGlvblwiOiB7XG4gICAgICAgIFwidG9rZW5pemVyXCI6IEF1dG9Ub2tlbml6ZXIsXG4gICAgICAgIFwicGlwZWxpbmVcIjogVGV4dEdlbmVyYXRpb25QaXBlbGluZSxcbiAgICAgICAgXCJtb2RlbFwiOiBBdXRvTW9kZWxGb3JDYXVzYWxMTSxcbiAgICAgICAgXCJkZWZhdWx0XCI6IHtcbiAgICAgICAgICAgIC8vIFRPRE86IHJlcGxhY2Ugd2l0aCBvcmlnaW5hbFxuICAgICAgICAgICAgLy8gXCJtb2RlbFwiOiBcImdwdDJcIixcbiAgICAgICAgICAgIFwibW9kZWxcIjogXCJYZW5vdmEvZ3B0MlwiLFxuICAgICAgICB9LFxuICAgICAgICBcInR5cGVcIjogXCJ0ZXh0XCIsXG4gICAgfSxcbiAgICBcInplcm8tc2hvdC1jbGFzc2lmaWNhdGlvblwiOiB7XG4gICAgICAgIFwidG9rZW5pemVyXCI6IEF1dG9Ub2tlbml6ZXIsXG4gICAgICAgIFwicGlwZWxpbmVcIjogWmVyb1Nob3RDbGFzc2lmaWNhdGlvblBpcGVsaW5lLFxuICAgICAgICBcIm1vZGVsXCI6IEF1dG9Nb2RlbEZvclNlcXVlbmNlQ2xhc3NpZmljYXRpb24sXG4gICAgICAgIFwiZGVmYXVsdFwiOiB7XG4gICAgICAgICAgICAvLyBUT0RPOiByZXBsYWNlIHdpdGggb3JpZ2luYWxcbiAgICAgICAgICAgIC8vIFwibW9kZWxcIjogXCJ0eXBlZm9ybS9kaXN0aWxiZXJ0LWJhc2UtdW5jYXNlZC1tbmxpXCIsXG4gICAgICAgICAgICBcIm1vZGVsXCI6IFwiWGVub3ZhL2Rpc3RpbGJlcnQtYmFzZS11bmNhc2VkLW1ubGlcIixcbiAgICAgICAgfSxcbiAgICAgICAgXCJ0eXBlXCI6IFwidGV4dFwiLFxuICAgIH0sXG5cbiAgICBcImF1dG9tYXRpYy1zcGVlY2gtcmVjb2duaXRpb25cIjoge1xuICAgICAgICBcInRva2VuaXplclwiOiBBdXRvVG9rZW5pemVyLFxuICAgICAgICBcInBpcGVsaW5lXCI6IEF1dG9tYXRpY1NwZWVjaFJlY29nbml0aW9uUGlwZWxpbmUsXG4gICAgICAgIFwibW9kZWxcIjogQXV0b01vZGVsRm9yU2VxMlNlcUxNLFxuICAgICAgICBcInByb2Nlc3NvclwiOiBBdXRvUHJvY2Vzc29yLFxuICAgICAgICBcImRlZmF1bHRcIjoge1xuICAgICAgICAgICAgLy8gVE9ETzogcmVwbGFjZSB3aXRoIG9yaWdpbmFsXG4gICAgICAgICAgICAvLyBcIm1vZGVsXCI6IFwib3BlbmFpL3doaXNwZXItdGlueS5lblwiLFxuICAgICAgICAgICAgXCJtb2RlbFwiOiBcIlhlbm92YS93aGlzcGVyLXRpbnkuZW5cIixcbiAgICAgICAgfSxcbiAgICAgICAgXCJ0eXBlXCI6IFwibXVsdGltb2RhbFwiLFxuICAgIH0sXG5cbiAgICBcImltYWdlLXRvLXRleHRcIjoge1xuICAgICAgICBcInRva2VuaXplclwiOiBBdXRvVG9rZW5pemVyLFxuICAgICAgICBcInBpcGVsaW5lXCI6IEltYWdlVG9UZXh0UGlwZWxpbmUsXG4gICAgICAgIFwibW9kZWxcIjogQXV0b01vZGVsRm9yVmlzaW9uMlNlcSxcbiAgICAgICAgXCJwcm9jZXNzb3JcIjogQXV0b1Byb2Nlc3NvcixcbiAgICAgICAgXCJkZWZhdWx0XCI6IHtcbiAgICAgICAgICAgIC8vIFRPRE86IHJlcGxhY2Ugd2l0aCBvcmlnaW5hbFxuICAgICAgICAgICAgLy8gXCJtb2RlbFwiOiBcIm5scGNvbm5lY3Qvdml0LWdwdDItaW1hZ2UtY2FwdGlvbmluZ1wiLFxuICAgICAgICAgICAgXCJtb2RlbFwiOiBcIlhlbm92YS92aXQtZ3B0Mi1pbWFnZS1jYXB0aW9uaW5nXCIsXG4gICAgICAgIH0sXG4gICAgICAgIFwidHlwZVwiOiBcIm11bHRpbW9kYWxcIixcbiAgICB9LFxuXG4gICAgXCJpbWFnZS1jbGFzc2lmaWNhdGlvblwiOiB7XG4gICAgICAgIC8vIG5vIHRva2VuaXplclxuICAgICAgICBcInBpcGVsaW5lXCI6IEltYWdlQ2xhc3NpZmljYXRpb25QaXBlbGluZSxcbiAgICAgICAgXCJtb2RlbFwiOiBBdXRvTW9kZWxGb3JJbWFnZUNsYXNzaWZpY2F0aW9uLFxuICAgICAgICBcInByb2Nlc3NvclwiOiBBdXRvUHJvY2Vzc29yLFxuICAgICAgICBcImRlZmF1bHRcIjoge1xuICAgICAgICAgICAgLy8gVE9ETzogcmVwbGFjZSB3aXRoIG9yaWdpbmFsXG4gICAgICAgICAgICAvLyBcIm1vZGVsXCI6IFwiZ29vZ2xlL3ZpdC1iYXNlLXBhdGNoMTYtMjI0XCIsXG4gICAgICAgICAgICBcIm1vZGVsXCI6IFwiWGVub3ZhL3ZpdC1iYXNlLXBhdGNoMTYtMjI0XCIsXG4gICAgICAgIH0sXG4gICAgICAgIFwidHlwZVwiOiBcIm11bHRpbW9kYWxcIixcbiAgICB9LFxuXG4gICAgXCJpbWFnZS1zZWdtZW50YXRpb25cIjoge1xuICAgICAgICAvLyBubyB0b2tlbml6ZXJcbiAgICAgICAgXCJwaXBlbGluZVwiOiBJbWFnZVNlZ21lbnRhdGlvblBpcGVsaW5lLFxuICAgICAgICBcIm1vZGVsXCI6IEF1dG9Nb2RlbEZvckltYWdlU2VnbWVudGF0aW9uLFxuICAgICAgICBcInByb2Nlc3NvclwiOiBBdXRvUHJvY2Vzc29yLFxuICAgICAgICBcImRlZmF1bHRcIjoge1xuICAgICAgICAgICAgLy8gVE9ETzogcmVwbGFjZSB3aXRoIG9yaWdpbmFsXG4gICAgICAgICAgICAvLyBcIm1vZGVsXCI6IFwiZmFjZWJvb2svZGV0ci1yZXNuZXQtNTAtcGFub3B0aWNcIixcbiAgICAgICAgICAgIFwibW9kZWxcIjogXCJYZW5vdmEvZGV0ci1yZXNuZXQtNTAtcGFub3B0aWNcIixcbiAgICAgICAgfSxcbiAgICAgICAgXCJ0eXBlXCI6IFwibXVsdGltb2RhbFwiLFxuICAgIH0sXG5cbiAgICBcInplcm8tc2hvdC1pbWFnZS1jbGFzc2lmaWNhdGlvblwiOiB7XG4gICAgICAgIC8vIG5vIHRva2VuaXplclxuICAgICAgICBcInRva2VuaXplclwiOiBBdXRvVG9rZW5pemVyLFxuICAgICAgICBcInBpcGVsaW5lXCI6IFplcm9TaG90SW1hZ2VDbGFzc2lmaWNhdGlvblBpcGVsaW5lLFxuICAgICAgICBcIm1vZGVsXCI6IEF1dG9Nb2RlbCxcbiAgICAgICAgXCJwcm9jZXNzb3JcIjogQXV0b1Byb2Nlc3NvcixcbiAgICAgICAgXCJkZWZhdWx0XCI6IHtcbiAgICAgICAgICAgIC8vIFRPRE86IHJlcGxhY2Ugd2l0aCBvcmlnaW5hbFxuICAgICAgICAgICAgLy8gXCJtb2RlbFwiOiBcIm9wZW5haS9jbGlwLXZpdC1iYXNlLXBhdGNoMzJcIixcbiAgICAgICAgICAgIFwibW9kZWxcIjogXCJYZW5vdmEvY2xpcC12aXQtYmFzZS1wYXRjaDMyXCIsXG4gICAgICAgIH0sXG4gICAgICAgIFwidHlwZVwiOiBcIm11bHRpbW9kYWxcIixcbiAgICB9LFxuXG4gICAgXCJvYmplY3QtZGV0ZWN0aW9uXCI6IHtcbiAgICAgICAgLy8gbm8gdG9rZW5pemVyXG4gICAgICAgIFwicGlwZWxpbmVcIjogT2JqZWN0RGV0ZWN0aW9uUGlwZWxpbmUsXG4gICAgICAgIFwibW9kZWxcIjogQXV0b01vZGVsRm9yT2JqZWN0RGV0ZWN0aW9uLFxuICAgICAgICBcInByb2Nlc3NvclwiOiBBdXRvUHJvY2Vzc29yLFxuICAgICAgICBcImRlZmF1bHRcIjoge1xuICAgICAgICAgICAgLy8gVE9ETzogcmVwbGFjZSB3aXRoIG9yaWdpbmFsXG4gICAgICAgICAgICAvLyBcIm1vZGVsXCI6IFwiZmFjZWJvb2svZGV0ci1yZXNuZXQtNTBcIixcbiAgICAgICAgICAgIFwibW9kZWxcIjogXCJYZW5vdmEvZGV0ci1yZXNuZXQtNTBcIixcbiAgICAgICAgfSxcbiAgICAgICAgXCJ0eXBlXCI6IFwibXVsdGltb2RhbFwiLFxuICAgIH0sXG5cbiAgICAvLyBUaGlzIHRhc2sgc2VydmVzIGFzIGEgdXNlZnVsIGludGVyZmFjZSBmb3IgZGVhbGluZyB3aXRoIHNlbnRlbmNlLXRyYW5zZm9ybWVycyAoaHR0cHM6Ly9odWdnaW5nZmFjZS5jby9zZW50ZW5jZS10cmFuc2Zvcm1lcnMpLlxuICAgIFwiZmVhdHVyZS1leHRyYWN0aW9uXCI6IHtcbiAgICAgICAgXCJ0b2tlbml6ZXJcIjogQXV0b1Rva2VuaXplcixcbiAgICAgICAgXCJwaXBlbGluZVwiOiBGZWF0dXJlRXh0cmFjdGlvblBpcGVsaW5lLFxuICAgICAgICBcIm1vZGVsXCI6IEF1dG9Nb2RlbCxcbiAgICAgICAgXCJkZWZhdWx0XCI6IHtcbiAgICAgICAgICAgIC8vIFRPRE86IHJlcGxhY2Ugd2l0aCBvcmlnaW5hbFxuICAgICAgICAgICAgLy8gXCJtb2RlbFwiOiBcInNlbnRlbmNlLXRyYW5zZm9ybWVycy9hbGwtTWluaUxNLUw2LXYyXCIsXG4gICAgICAgICAgICBcIm1vZGVsXCI6IFwiWGVub3ZhL2FsbC1NaW5pTE0tTDYtdjJcIixcbiAgICAgICAgfSxcbiAgICAgICAgXCJ0eXBlXCI6IFwidGV4dFwiLFxuICAgIH0sXG59XG5cblxuY29uc3QgVEFTS19BTElBU0VTID0ge1xuICAgIFwic2VudGltZW50LWFuYWx5c2lzXCI6IFwidGV4dC1jbGFzc2lmaWNhdGlvblwiLFxuICAgIFwibmVyXCI6IFwidG9rZW4tY2xhc3NpZmljYXRpb25cIixcbiAgICBcInZxYVwiOiBcInZpc3VhbC1xdWVzdGlvbi1hbnN3ZXJpbmdcIixcbiAgICBcImFzclwiOiBcImF1dG9tYXRpYy1zcGVlY2gtcmVjb2duaXRpb25cIixcblxuICAgIC8vIEFkZCBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbiAgICBcImVtYmVkZGluZ3NcIjogXCJmZWF0dXJlLWV4dHJhY3Rpb25cIixcbn1cblxuLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuL3V0aWxzL2h1Yi5qcycpLlByZXRyYWluZWRPcHRpb25zfSBQcmV0cmFpbmVkT3B0aW9uc1xuICovXG5cbi8qKlxuICogVXRpbGl0eSBmYWN0b3J5IG1ldGhvZCB0byBidWlsZCBhIFtgUGlwZWxpbmVgXSBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHRhc2sgVGhlIHRhc2sgb2YgdGhlIHBpcGVsaW5lLlxuICogQHBhcmFtIHtzdHJpbmd9IFttb2RlbD1udWxsXSBUaGUgbmFtZSBvZiB0aGUgcHJlLXRyYWluZWQgbW9kZWwgdG8gdXNlLiBJZiBub3Qgc3BlY2lmaWVkLCB0aGUgZGVmYXVsdCBtb2RlbCBmb3IgdGhlIHRhc2sgd2lsbCBiZSB1c2VkLlxuICogQHBhcmFtIHtQcmV0cmFpbmVkT3B0aW9uc30gW29wdGlvbnNdIE9wdGlvbmFsIHBhcmFtZXRlcnMgZm9yIHRoZSBwaXBlbGluZS5cbiAqIEByZXR1cm5zIHtQcm9taXNlPFBpcGVsaW5lPn0gQSBQaXBlbGluZSBvYmplY3QgZm9yIHRoZSBzcGVjaWZpZWQgdGFzay5cbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiBhbiB1bnN1cHBvcnRlZCBwaXBlbGluZSBpcyByZXF1ZXN0ZWQuXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBwaXBlbGluZShcbiAgICB0YXNrLFxuICAgIG1vZGVsID0gbnVsbCxcbiAgICB7XG4gICAgICAgIHF1YW50aXplZCA9IHRydWUsXG4gICAgICAgIHByb2dyZXNzX2NhbGxiYWNrID0gbnVsbCxcbiAgICAgICAgY29uZmlnID0gbnVsbCxcbiAgICAgICAgY2FjaGVfZGlyID0gbnVsbCxcbiAgICAgICAgbG9jYWxfZmlsZXNfb25seSA9IGZhbHNlLFxuICAgICAgICByZXZpc2lvbiA9ICdtYWluJyxcbiAgICB9ID0ge31cbikge1xuICAgIC8vIEhlbHBlciBtZXRob2QgdG8gY29uc3RydWN0IHBpcGVsaW5lXG5cbiAgICAvLyBBcHBseSBhbGlhc2VzXG4gICAgdGFzayA9IFRBU0tfQUxJQVNFU1t0YXNrXSA/PyB0YXNrO1xuXG4gICAgLy8gR2V0IHBpcGVsaW5lIGluZm9cbiAgICBsZXQgcGlwZWxpbmVJbmZvID0gU1VQUE9SVEVEX1RBU0tTW3Rhc2suc3BsaXQoJ18nLCAxKVswXV07XG4gICAgaWYgKCFwaXBlbGluZUluZm8pIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoYFVuc3VwcG9ydGVkIHBpcGVsaW5lOiAke3Rhc2t9LiBNdXN0IGJlIG9uZSBvZiBbJHtPYmplY3Qua2V5cyhTVVBQT1JURURfVEFTS1MpfV1gKVxuICAgIH1cblxuICAgIC8vIFVzZSBtb2RlbCBpZiBzcGVjaWZpZWQsIG90aGVyd2lzZSwgdXNlIGRlZmF1bHRcbiAgICBpZiAoIW1vZGVsKSB7XG4gICAgICAgIG1vZGVsID0gcGlwZWxpbmVJbmZvLmRlZmF1bHQubW9kZWxcbiAgICAgICAgY29uc29sZS5sb2coYE5vIG1vZGVsIHNwZWNpZmllZC4gVXNpbmcgZGVmYXVsdCBtb2RlbDogXCIke21vZGVsfVwiLmApO1xuICAgIH1cblxuICAgIGxldCB0b2tlbml6ZXJDbGFzcyA9IHBpcGVsaW5lSW5mby50b2tlbml6ZXI7XG4gICAgbGV0IG1vZGVsQ2xhc3MgPSBwaXBlbGluZUluZm8ubW9kZWw7XG4gICAgbGV0IHBpcGVsaW5lQ2xhc3MgPSBwaXBlbGluZUluZm8ucGlwZWxpbmU7XG4gICAgbGV0IHByb2Nlc3NvckNsYXNzID0gcGlwZWxpbmVJbmZvLnByb2Nlc3NvcjtcblxuICAgIGxldCBwcm9taXNlcyA9IFtdO1xuXG4gICAgbGV0IHByZXRyYWluZWRPcHRpb25zID0ge1xuICAgICAgICBxdWFudGl6ZWQsXG4gICAgICAgIHByb2dyZXNzX2NhbGxiYWNrLFxuICAgICAgICBjb25maWcsXG4gICAgICAgIGNhY2hlX2RpcixcbiAgICAgICAgbG9jYWxfZmlsZXNfb25seSxcbiAgICAgICAgcmV2aXNpb24sXG4gICAgfVxuICAgIGlmICh0b2tlbml6ZXJDbGFzcykge1xuICAgICAgICBwcm9taXNlcy5wdXNoKFxuICAgICAgICAgICAgdG9rZW5pemVyQ2xhc3MuZnJvbV9wcmV0cmFpbmVkKG1vZGVsLCBwcmV0cmFpbmVkT3B0aW9ucyksXG4gICAgICAgIClcbiAgICB9XG4gICAgaWYgKG1vZGVsQ2xhc3MpIHtcbiAgICAgICAgcHJvbWlzZXMucHVzaChcbiAgICAgICAgICAgIG1vZGVsQ2xhc3MuZnJvbV9wcmV0cmFpbmVkKG1vZGVsLCBwcmV0cmFpbmVkT3B0aW9ucylcbiAgICAgICAgKVxuICAgIH1cblxuICAgIGlmIChwcm9jZXNzb3JDbGFzcykge1xuICAgICAgICBwcm9taXNlcy5wdXNoKFxuICAgICAgICAgICAgcHJvY2Vzc29yQ2xhc3MuZnJvbV9wcmV0cmFpbmVkKG1vZGVsLCBwcmV0cmFpbmVkT3B0aW9ucylcbiAgICAgICAgKVxuICAgIH1cblxuICAgIC8vIExvYWQgdG9rZW5pemVyIGFuZCBtb2RlbFxuICAgIGxldCBpdGVtcyA9IGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKVxuXG4gICAgZGlzcGF0Y2hDYWxsYmFjayhwcm9ncmVzc19jYWxsYmFjaywge1xuICAgICAgICAnc3RhdHVzJzogJ3JlYWR5JyxcbiAgICAgICAgJ3Rhc2snOiB0YXNrLFxuICAgICAgICAnbW9kZWwnOiBtb2RlbCxcbiAgICB9KTtcblxuICAgIHJldHVybiBuZXcgcGlwZWxpbmVDbGFzcyh0YXNrLCAuLi5pdGVtcyk7XG5cbn1cblxuLyoqXG4gKiBDb21wdXRlIHRoZSBDYXJ0ZXNpYW4gcHJvZHVjdCBvZiBnaXZlbiBhcnJheXNcbiAqIEBwYXJhbSB7Li4uQXJyYXl9IGEgQXJyYXlzIHRvIGNvbXB1dGUgdGhlIHByb2R1Y3RcbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY29tcHV0ZWQgQ2FydGVzaWFuIHByb2R1Y3QgYXMgYW4gYXJyYXlcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHByb2R1Y3QoLi4uYSkge1xuICAgIC8vIENhcnRlc2lhbiBwcm9kdWN0IG9mIGl0ZW1zXG4gICAgLy8gQWRhcHRlZCBmcm9tIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS80MzA1MzgwM1xuICAgIHJldHVybiBhLnJlZHVjZSgoYSwgYikgPT4gYS5mbGF0TWFwKGQgPT4gYi5tYXAoZSA9PiBbZCwgZV0pKSk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@xenova/transformers/src/pipelines.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@xenova/transformers/src/processors.js":
/*!*************************************************************!*\
  !*** ./node_modules/@xenova/transformers/src/processors.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AutoProcessor: () => (/* binding */ AutoProcessor),\n/* harmony export */   DetrFeatureExtractor: () => (/* binding */ DetrFeatureExtractor),\n/* harmony export */   FeatureExtractor: () => (/* binding */ FeatureExtractor),\n/* harmony export */   ImageFeatureExtractor: () => (/* binding */ ImageFeatureExtractor),\n/* harmony export */   MobileViTFeatureExtractor: () => (/* binding */ MobileViTFeatureExtractor),\n/* harmony export */   Processor: () => (/* binding */ Processor),\n/* harmony export */   SamImageProcessor: () => (/* binding */ SamImageProcessor),\n/* harmony export */   SamProcessor: () => (/* binding */ SamProcessor),\n/* harmony export */   ViTFeatureExtractor: () => (/* binding */ ViTFeatureExtractor),\n/* harmony export */   WhisperFeatureExtractor: () => (/* binding */ WhisperFeatureExtractor),\n/* harmony export */   WhisperProcessor: () => (/* binding */ WhisperProcessor)\n/* harmony export */ });\n/* harmony import */ var _utils_core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/core.js */ \"(ssr)/./node_modules/@xenova/transformers/src/utils/core.js\");\n/* harmony import */ var _utils_hub_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/hub.js */ \"(ssr)/./node_modules/@xenova/transformers/src/utils/hub.js\");\n/* harmony import */ var _utils_maths_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/maths.js */ \"(ssr)/./node_modules/@xenova/transformers/src/utils/maths.js\");\n/* harmony import */ var _utils_tensor_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/tensor.js */ \"(ssr)/./node_modules/@xenova/transformers/src/utils/tensor.js\");\n/* harmony import */ var _utils_image_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils/image.js */ \"(ssr)/./node_modules/@xenova/transformers/src/utils/image.js\");\n/* harmony import */ var _utils_audio_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./utils/audio.js */ \"(ssr)/./node_modules/@xenova/transformers/src/utils/audio.js\");\n\n/**\n * @file Processors are used to prepare non-textual inputs (e.g., image or audio) for a model.\n * \n * **Example:** Using a `WhisperProcessor` to prepare an audio input for a model.\n * ```javascript\n * import { AutoProcessor, read_audio } from '@xenova/transformers';\n *\n * let processor = await AutoProcessor.from_pretrained('openai/whisper-tiny.en');\n * let audio = await read_audio('https://huggingface.co/datasets/Narsil/asr_dummy/resolve/main/mlk.flac', 16000);\n * let { input_features } = await processor(audio);\n * // Tensor {\n * //   data: Float32Array(240000) [0.4752984642982483, 0.5597258806228638, 0.56434166431427, ...],\n * //   dims: [1, 80, 3000],\n * //   type: 'float32',\n * //   size: 240000,\n * // }\n * ```\n * \n * @module processors\n */\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * Base class for feature extractors.\n *\n * @extends Callable\n */\nclass FeatureExtractor extends _utils_core_js__WEBPACK_IMPORTED_MODULE_0__.Callable {\n    /**\n     * Constructs a new FeatureExtractor instance.\n     *\n     * @param {Object} config The configuration for the feature extractor.\n     */\n    constructor(config) {\n        super();\n        this.config = config\n    }\n}\n\n/**\n * Feature extractor for image models.\n *\n * @extends FeatureExtractor\n */\nclass ImageFeatureExtractor extends FeatureExtractor {\n\n    /**\n     * Constructs a new ImageFeatureExtractor instance.\n     *\n     * @param {Object} config The configuration for the feature extractor.\n     * @param {number[]} config.image_mean The mean values for image normalization.\n     * @param {number[]} config.image_std The standard deviation values for image normalization.\n     * @param {boolean} config.do_rescale Whether to rescale the image pixel values to the [0,1] range.\n     * @param {number} config.rescale_factor The factor to use for rescaling the image pixel values.\n     * @param {boolean} config.do_normalize Whether to normalize the image pixel values.\n     * @param {boolean} config.do_resize Whether to resize the image.\n     * @param {number} config.resample What method to use for resampling.\n     * @param {number} config.size The size to resize the image to.\n     */\n    constructor(config) {\n        super(config);\n\n        this.image_mean = this.config.image_mean;\n        this.image_std = this.config.image_std;\n\n        this.resample = this.config.resample ?? 2; // 2 => bilinear\n        this.do_rescale = this.config.do_rescale ?? true;\n        this.rescale_factor = this.config.rescale_factor ?? (1 / 255);\n        this.do_normalize = this.config.do_normalize;\n\n        this.do_resize = this.config.do_resize;\n        this.size = this.config.size;\n\n        this.do_center_crop = this.config.do_center_crop;\n        this.crop_size = this.config.crop_size;\n        this.do_convert_rgb = this.config.do_convert_rgb ?? true;\n\n        this.pad_size = this.config.pad_size;\n        this.do_pad = (this.config.do_pad ?? false) && this.pad_size;\n    }\n\n    /**\n     * Preprocesses the given image.\n     *\n     * @param {RawImage} image The image to preprocess.\n     * @returns {Promise<any>} The preprocessed image as a Tensor.\n     */\n    async preprocess(image) {\n\n        // First, convert image to RGB if specified in config.\n        if (this.do_convert_rgb) {\n            image = image.rgb();\n        }\n\n        const srcWidth = image.width;   // original width\n        const srcHeight = image.height; // original height\n\n        // Next, resize all images\n        if (this.do_resize) {\n            // TODO:\n            // For efficiency reasons, it might be best to merge the resize and center crop operations into one.\n\n            // `this.size` comes in many forms, so we need to handle them all here:\n            // 1. `this.size` is an integer, in which case we resize the image to be a square \n\n            let shortest_edge;\n            let longest_edge;\n\n            // Support both formats for backwards compatibility\n            if (Number.isInteger(this.size)) {\n                shortest_edge = this.size;\n                longest_edge = this.config.max_size ?? shortest_edge;\n\n            } else {\n                // Extract known properties from `this.size`\n                shortest_edge = this.size.shortest_edge;\n                longest_edge = this.size.longest_edge;\n            }\n\n            // If `longest_edge` and `shortest_edge` are set, maintain aspect ratio and resize to `shortest_edge`\n            // while keeping the largest dimension <= `longest_edge`\n            if (shortest_edge !== undefined || longest_edge !== undefined) {\n                // http://opensourcehacker.com/2011/12/01/calculate-aspect-ratio-conserving-resize-for-images-in-javascript/\n                // Try resize so that shortest edge is `this.shortest_edge` (target)\n                const shortResizeFactor = shortest_edge === undefined\n                    ? 1 // If `shortest_edge` is not set, don't upscale\n                    : Math.max(shortest_edge / srcWidth, shortest_edge / srcHeight);\n\n                const newWidth = srcWidth * shortResizeFactor;\n                const newHeight = srcHeight * shortResizeFactor;\n\n                // The new width and height might be greater than `this.longest_edge`, so\n                // we downscale again to ensure the largest dimension is `this.longest_edge` \n                const longResizeFactor = longest_edge === undefined\n                    ? 1 // If `longest_edge` is not set, don't downscale\n                    : Math.min(longest_edge / newWidth, longest_edge / newHeight);\n\n                // Perform resize\n                image = await image.resize(Math.floor(newWidth * longResizeFactor), Math.floor(newHeight * longResizeFactor), {\n                    resample: this.resample,\n                });\n\n            } else if (this.size.width !== undefined && this.size.height !== undefined) {\n                // If `width` and `height` are set, resize to those dimensions\n                image = await image.resize(this.size.width, this.size.height, {\n                    resample: this.resample,\n                });\n            } else {\n                throw new Error(`Could not resize image due to unsupported \\`this.size\\` option in config: ${JSON.stringify(this.size)}`);\n            }\n        }\n\n        if (this.do_center_crop) {\n\n            let crop_width;\n            let crop_height;\n            if (Number.isInteger(this.crop_size)) {\n                crop_width = this.crop_size;\n                crop_height = this.crop_size;\n            } else {\n                crop_width = this.crop_size.width;\n                crop_height = this.crop_size.height;\n            }\n\n            image = await image.center_crop(crop_width, crop_height);\n        }\n\n        let reshaped_input_size = [image.height, image.width];\n\n        // TODO is it okay to pad before rescaling/normalizing?\n        if (this.do_pad) {\n            let left = 0;\n            let right = this.pad_size.width - image.width;\n            let top = 0;\n            let bottom = this.pad_size.height - image.height;\n\n            image = await image.pad([left, right, top, bottom]);\n        }\n\n        const pixelData = Float32Array.from(image.data);\n\n        if (this.do_rescale) {\n            for (let i = 0; i < pixelData.length; ++i) {\n                pixelData[i] = this.rescale_factor * pixelData[i];\n            }\n        }\n\n        if (this.do_normalize) {\n            let image_mean = this.image_mean;\n            if (!Array.isArray(this.image_mean)) {\n                image_mean = new Array(image.channels).fill(image_mean);\n            }\n\n            let image_std = this.image_std;\n            if (!Array.isArray(this.image_std)) {\n                image_std = new Array(image.channels).fill(image_mean);\n            }\n\n            if (image_mean.length !== image.channels || image_std.length !== image.channels) {\n                throw new Error(`When set to arrays, the length of \\`image_mean\\` (${image_mean.length}) and \\`image_std\\` (${image_std.length}) must match the number of channels in the image (${image.channels}).`);\n            }\n\n            for (let i = 0; i < pixelData.length; i += image.channels) {\n                for (let j = 0; j < image.channels; ++j) {\n                    pixelData[i + j] = (pixelData[i + j] - this.image_mean[j]) / this.image_std[j];\n                }\n            }\n        }\n\n        // convert to channel dimension format:\n        let imgDims = [image.height, image.width, image.channels];\n        let img = new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_3__.Tensor('float32', pixelData, imgDims);\n        let transposed = (0,_utils_tensor_js__WEBPACK_IMPORTED_MODULE_3__.transpose)(img, [2, 0, 1]); // hwc -> chw\n\n        return {\n            original_size: [srcHeight, srcWidth],\n            reshaped_input_size: reshaped_input_size,\n            pixel_values: transposed,\n        }\n    }\n\n    /**\n     * Calls the feature extraction process on an array of image\n     * URLs, preprocesses each image, and concatenates the resulting\n     * features into a single Tensor.\n     * @param {any} images The URL(s) of the image(s) to extract features from.\n     * @returns {Promise<Object>} An object containing the concatenated pixel values (and other metadata) of the preprocessed images.\n     */\n    async _call(images) {\n        if (!Array.isArray(images)) {\n            images = [images];\n        }\n\n        let imageData = await Promise.all(images.map(x => this.preprocess(x)));\n\n        // TODO:\n\n        // Concatenate pixel values\n        // TEMP: Add batch dimension so that concat works\n        imageData.forEach(x => x.pixel_values.dims = [1, ...x.pixel_values.dims]);\n        let pixel_values = (0,_utils_tensor_js__WEBPACK_IMPORTED_MODULE_3__.cat)(imageData.map(x => x.pixel_values));\n\n        return {\n            pixel_values: pixel_values,\n\n            // Original sizes of images\n            original_sizes: imageData.map(x => x.original_size),\n\n            // Reshaped sizes of images, before padding or cropping\n            reshaped_input_sizes: imageData.map(x => x.reshaped_input_size),\n        }\n    }\n\n}\n\nclass ViTFeatureExtractor extends ImageFeatureExtractor { }\nclass MobileViTFeatureExtractor extends ImageFeatureExtractor { }\n\n/**\n * Detr Feature Extractor.\n *\n * @extends ImageFeatureExtractor\n */\nclass DetrFeatureExtractor extends ImageFeatureExtractor {\n    /**\n     * Calls the feature extraction process on an array of image\n     * URLs, preprocesses each image, and concatenates the resulting\n     * features into a single Tensor.\n     * @param {any} urls The URL(s) of the image(s) to extract features from.\n     * @returns {Promise<Object>} An object containing the concatenated pixel values of the preprocessed images.\n     */\n    async _call(urls) {\n        let result = await super._call(urls);\n\n        // TODO support differently-sized images, for now assume all images are the same size.\n        // TODO support different mask sizes (not just 64x64)\n        // Currently, just fill pixel mask with 1s\n        let maskSize = [result.pixel_values.dims[0], 64, 64];\n        result.pixel_mask = new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_3__.Tensor(\n            'int64',\n            // TODO: fix error below\n            new BigInt64Array(maskSize.reduce((a, b) => a * b)).fill(1n),\n            maskSize\n        );\n\n        return result;\n    }\n\n    /**\n     * @param {number[]} arr The URL(s) of the image(s) to extract features from.\n     * @returns {number[]} An object containing the concatenated pixel values of the preprocessed images.\n     */\n    center_to_corners_format([centerX, centerY, width, height]) {\n        return [\n            centerX - width / 2,\n            centerY - height / 2,\n            centerX + width / 2,\n            centerY + height / 2\n        ];\n    }\n\n    /**\n     * Post-processes the outputs of the model (for object detection).\n     * @param {Object} outputs The outputs of the model that must be post-processed\n     * @param {Tensor} outputs.logits The logits\n     * @param {Tensor} outputs.pred_boxes The predicted boxes.\n     * @return {Object[]} An array of objects containing the post-processed outputs.\n     */\n    post_process_object_detection(outputs, threshold = 0.5, target_sizes = null) {\n        const out_logits = outputs.logits;\n        const out_bbox = outputs.pred_boxes;\n        const [batch_size, num_boxes, num_classes] = out_logits.dims;\n\n        if (target_sizes !== null && target_sizes.length !== batch_size) {\n            throw Error(\"Make sure that you pass in as many target sizes as the batch dimension of the logits\")\n        }\n        let toReturn = [];\n        for (let i = 0; i < batch_size; ++i) {\n            let target_size = target_sizes !== null ? target_sizes[i] : null;\n            let info = {\n                boxes: [],\n                classes: [],\n                scores: []\n            }\n            let logits = out_logits[i];\n            let bbox = out_bbox[i];\n\n            for (let j = 0; j < num_boxes; ++j) {\n                let logit = logits[j];\n\n                // Get most probable class\n                let maxIndex = (0,_utils_maths_js__WEBPACK_IMPORTED_MODULE_2__.max)(logit.data)[1];\n\n                if (maxIndex === num_classes - 1) {\n                    // This is the background class, skip it\n                    continue;\n                }\n\n                // Compute softmax over classes\n                let probs = (0,_utils_maths_js__WEBPACK_IMPORTED_MODULE_2__.softmax)(logit.data);\n\n                let score = probs[maxIndex];\n                if (score > threshold) {\n                    // Some class has a high enough probability\n                    /** @type {number[]} */\n                    let box = bbox[j].data;\n\n                    // convert to [x0, y0, x1, y1] format\n                    box = this.center_to_corners_format(box)\n                    if (target_size !== null) {\n                        box = box.map((x, i) => x * target_size[(i + 1) % 2])\n                    }\n\n                    info.boxes.push(box);\n                    info.classes.push(maxIndex);\n                    info.scores.push(score);\n                }\n            }\n            toReturn.push(info);\n        }\n        return toReturn;\n    }\n\n    /**\n     * Binarize the given masks using `object_mask_threshold`, it returns the associated values of `masks`, `scores` and `labels`.\n     * @param {Tensor} class_logits The class logits.\n     * @param {Tensor} mask_logits The mask logits.\n     * @param {number} object_mask_threshold A number between 0 and 1 used to binarize the masks.\n     * @param {number} num_labels The number of labels.\n     * @returns {[Tensor[], number[], number[]]} The binarized masks, the scores, and the labels.\n     */\n    remove_low_and_no_objects(class_logits, mask_logits, object_mask_threshold, num_labels) {\n\n        let mask_probs_item = [];\n        let pred_scores_item = [];\n        let pred_labels_item = [];\n\n        for (let j = 0; j < class_logits.dims[0]; ++j) {\n            let cls = class_logits[j];\n            let mask = mask_logits[j];\n\n            let pred_label = (0,_utils_maths_js__WEBPACK_IMPORTED_MODULE_2__.max)(cls.data)[1];\n            if (pred_label === num_labels) {\n                // Is the background, so we ignore it\n                continue;\n            }\n\n            let scores = (0,_utils_maths_js__WEBPACK_IMPORTED_MODULE_2__.softmax)(cls.data);\n            let pred_score = scores[pred_label];\n            if (pred_score > object_mask_threshold) {\n                mask_probs_item.push(mask);\n                pred_scores_item.push(pred_score);\n                pred_labels_item.push(pred_label);\n            }\n        }\n\n        return [mask_probs_item, pred_scores_item, pred_labels_item];\n\n    }\n\n    /**\n     * Checks whether the segment is valid or not.\n     * @param {Int32Array} mask_labels Labels for each pixel in the mask.\n     * @param {Tensor[]} mask_probs Probabilities for each pixel in the masks.\n     * @param {number} k The class id of the segment.\n     * @param {number} mask_threshold The mask threshold.\n     * @param {number} overlap_mask_area_threshold The overlap mask area threshold.\n     * @returns {[boolean, number[]]} Whether the segment is valid or not, and the indices of the valid labels.\n     */\n    check_segment_validity(\n        mask_labels,\n        mask_probs,\n        k,\n        mask_threshold = 0.5,\n        overlap_mask_area_threshold = 0.8\n    ) {\n        // mask_k is a 1D array of indices, indicating where the mask is equal to k\n        let mask_k = [];\n        let mask_k_area = 0;\n        let original_area = 0;\n\n        // Compute the area of all the stuff in query k\n        for (let i = 0; i < mask_labels.length; ++i) {\n            if (mask_labels[i] === k) {\n                mask_k.push(i);\n                ++mask_k_area;\n            }\n\n            if (mask_probs[k].data[i] >= mask_threshold) {\n                ++original_area;\n            }\n        }\n        let mask_exists = mask_k_area > 0 && original_area > 0;\n\n        // Eliminate disconnected tiny segments\n        if (mask_exists) {\n            // Perform additional check\n            let area_ratio = mask_k_area / original_area;\n            mask_exists = area_ratio > overlap_mask_area_threshold;\n        }\n\n        return [mask_exists, mask_k]\n    }\n\n    /**\n     * Computes the segments.\n     * @param {Tensor[]} mask_probs The mask probabilities.\n     * @param {number[]} pred_scores The predicted scores.\n     * @param {number[]} pred_labels The predicted labels.\n     * @param {number} mask_threshold The mask threshold.\n     * @param {number} overlap_mask_area_threshold The overlap mask area threshold.\n     * @param {Set<number>} label_ids_to_fuse The label ids to fuse.\n     * @param {number[]} target_size The target size of the image.\n     * @returns {[Tensor, Array<{id: number, label_id: number, score: number}>]} The computed segments.\n     */\n    compute_segments(\n        mask_probs,\n        pred_scores,\n        pred_labels,\n        mask_threshold,\n        overlap_mask_area_threshold,\n        label_ids_to_fuse = null,\n        target_size = null,\n    ) {\n        let [height, width] = target_size ?? mask_probs[0].dims;\n\n        let segmentation = new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_3__.Tensor(\n            'int32',\n            new Int32Array(height * width),\n            [height, width]\n        );\n        let segments = [];\n\n        // 1. If target_size is not null, we need to resize the masks to the target size\n        if (target_size !== null) {\n            // resize the masks to the target size\n            for (let i = 0; i < mask_probs.length; ++i) {\n                mask_probs[i] = (0,_utils_tensor_js__WEBPACK_IMPORTED_MODULE_3__.interpolate)(mask_probs[i], target_size, 'bilinear', false);\n            }\n        }\n\n        // 2. Weigh each mask by its prediction score\n        // NOTE: `mask_probs` is updated in-place\n        // \n        // Temporary storage for the best label/scores for each pixel ([height, width]):\n        let mask_labels = new Int32Array(mask_probs[0].data.length);\n        let bestScores = new Float32Array(mask_probs[0].data.length);\n\n        for (let i = 0; i < mask_probs.length; ++i) {\n            let score = pred_scores[i];\n\n            for (let j = 0; j < mask_probs[i].data.length; ++j) {\n                mask_probs[i].data[j] *= score\n                if (mask_probs[i].data[j] > bestScores[j]) {\n                    mask_labels[j] = i;\n                    bestScores[j] = mask_probs[i].data[j];\n                }\n            }\n        }\n\n        let current_segment_id = 0;\n\n        // let stuff_memory_list = {}\n        for (let k = 0; k < pred_labels.length; ++k) {\n            let pred_class = pred_labels[k];\n\n            // TODO add `should_fuse`\n            // let should_fuse = pred_class in label_ids_to_fuse\n\n            // Check if mask exists and large enough to be a segment\n            let [mask_exists, mask_k] = this.check_segment_validity(\n                mask_labels,\n                mask_probs,\n                k,\n                mask_threshold,\n                overlap_mask_area_threshold\n            )\n\n            if (!mask_exists) {\n                // Nothing to see here\n                continue;\n            }\n\n            // TODO\n            // if (pred_class in stuff_memory_list) {\n            //     current_segment_id = stuff_memory_list[pred_class]\n            // } else {\n            //     current_segment_id += 1;\n            // }\n            ++current_segment_id;\n\n\n            // Add current object segment to final segmentation map\n            for (let index of mask_k) {\n                segmentation.data[index] = current_segment_id;\n            }\n\n            segments.push({\n                id: current_segment_id,\n                label_id: pred_class,\n                // was_fused: should_fuse, TODO\n                score: pred_scores[k],\n            })\n\n            // TODO\n            // if(should_fuse){\n            //     stuff_memory_list[pred_class] = current_segment_id\n            // }\n        }\n\n        return [segmentation, segments];\n    }\n\n    /**\n     * Post-process the model output to generate the final panoptic segmentation.\n     * @param {*} outputs The model output to post process\n     * @param {number} [threshold=0.5] The probability score threshold to keep predicted instance masks.\n     * @param {number} [mask_threshold=0.5] Threshold to use when turning the predicted masks into binary values.\n     * @param {number} [overlap_mask_area_threshold=0.8] The overlap mask area threshold to merge or discard small disconnected parts within each binary instance mask.\n     * @param {Set<number>} [label_ids_to_fuse=null] The labels in this state will have all their instances be fused together.\n     * @param {number[][]} [target_sizes=null] The target sizes to resize the masks to.\n     * @returns {Array<{ segmentation: Tensor, segments_info: Array<{id: number, label_id: number, score: number}>}>}\n     */\n    post_process_panoptic_segmentation(\n        outputs,\n        threshold = 0.5,\n        mask_threshold = 0.5,\n        overlap_mask_area_threshold = 0.8,\n        label_ids_to_fuse = null,\n        target_sizes = null,\n    ) {\n        if (label_ids_to_fuse === null) {\n            console.warn(\"`label_ids_to_fuse` unset. No instance will be fused.\")\n            label_ids_to_fuse = new Set();\n        }\n\n        const class_queries_logits = outputs.logits; // [batch_size, num_queries, num_classes+1]\n        const masks_queries_logits = outputs.pred_masks; // [batch_size, num_queries, height, width]\n\n        const mask_probs = masks_queries_logits.sigmoid()  // [batch_size, num_queries, height, width]\n\n        let [batch_size, num_queries, num_labels] = class_queries_logits.dims;\n        num_labels -= 1; // Remove last class (background)\n\n        if (target_sizes !== null && target_sizes.length !== batch_size) {\n            throw Error(\"Make sure that you pass in as many target sizes as the batch dimension of the logits\")\n        }\n\n        let toReturn = [];\n        for (let i = 0; i < batch_size; ++i) {\n            let target_size = target_sizes !== null ? target_sizes[i] : null;\n\n            let class_logits = class_queries_logits[i];\n            let mask_logits = mask_probs[i];\n\n            let [mask_probs_item, pred_scores_item, pred_labels_item] = this.remove_low_and_no_objects(class_logits, mask_logits, threshold, num_labels);\n\n            if (pred_labels_item.length === 0) {\n                // No mask found\n                let [height, width] = target_size ?? mask_logits.dims.slice(-2);\n\n                let segmentation = new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_3__.Tensor(\n                    'int32',\n                    new Int32Array(height * width).fill(-1),\n                    [height, width]\n                )\n                toReturn.push({\n                    segmentation: segmentation,\n                    segments_info: []\n                });\n                continue;\n            }\n\n\n            // Get segmentation map and segment information of batch item\n            let [segmentation, segments] = this.compute_segments(\n                mask_probs_item,\n                pred_scores_item,\n                pred_labels_item,\n                mask_threshold,\n                overlap_mask_area_threshold,\n                label_ids_to_fuse,\n                target_size,\n            )\n\n            toReturn.push({\n                segmentation: segmentation,\n                segments_info: segments\n            })\n        }\n\n        return toReturn;\n    }\n\n    post_process_instance_segmentation() {\n        // TODO\n        throw Error(\"Not implemented yet\");\n    }\n}\n\nclass SamImageProcessor extends ImageFeatureExtractor {\n    async _call(images, input_points) {\n        let {\n            pixel_values,\n            original_sizes,\n            reshaped_input_sizes,\n        } = await super._call(images);\n\n        let shape = (0,_utils_core_js__WEBPACK_IMPORTED_MODULE_0__.calculateDimensions)(input_points);\n\n        if (shape.length === 3) {\n            // Correct user's input\n            shape = [1, ...shape];\n            input_points = [input_points];\n        } else if (shape.length !== 4) {\n            throw Error(\"The input_points must be a 4D tensor of shape `batch_size`, `point_batch_size`, `nb_points_per_image`, `2`.\")\n        }\n\n        // Reshape input points\n        for (let i = 0; i < input_points.length; ++i) { // batch_size\n            let originalImageSize = original_sizes[i];\n            let reshapedImageSize = reshaped_input_sizes[i];\n\n            let resizeFactors = [\n                reshapedImageSize[0] / originalImageSize[0],\n                reshapedImageSize[1] / originalImageSize[1]\n            ]\n\n            for (let j = 0; j < input_points[i].length; ++j) { // point_batch_size\n                for (let k = 0; k < input_points[i][j].length; ++k) { // nb_points_per_image\n                    for (let w = 0; w < input_points[i][j][k].length; ++w) { // 2\n                        input_points[i][j][k][w] *= resizeFactors[w];\n                    }\n                }\n            }\n        }\n\n        let input_points_tensor = new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_3__.Tensor(\n            'int64',\n            BigInt64Array.from(input_points.flat(Infinity)\n                .map(x => BigInt(Math.round(x)))),\n            shape\n        )\n\n        // TODO: allowed to be floats?\n        // let input_points_tensor = new Tensor(\n        //     'float32',\n        //     Float32Array.from(input_points.flat(Infinity)),\n        //     shape\n        // )\n\n        return {\n            pixel_values,\n            original_sizes: original_sizes,\n            reshaped_input_sizes: reshaped_input_sizes,\n            input_points: input_points_tensor\n        }\n    }\n\n    /**\n     * Remove padding and upscale masks to the original image size.\n     * @param {Tensor} masks Batched masks from the mask_decoder in (batch_size, num_channels, height, width) format.\n     * @param {number[][]} original_sizes The original sizes of each image before it was resized to the model's expected input shape, in (height, width) format.\n     * @param {number[][]} reshaped_input_sizes The size of each image as it is fed to the model, in (height, width) format. Used to remove padding.\n     * @param {Object} options Optional parameters for post-processing.\n     * @param {number} [options.mask_threshold] The threshold to use for binarizing the masks.\n     * @param {boolean} [options.binarize] Whether to binarize the masks.\n     * @param {Object} [options.pad_size] The target size the images were padded to before being passed to the model. If `null`, the target size is assumed to be the processor's `pad_size`.\n     * @param {number} [options.pad_size.height] The height the images were padded to.\n     * @param {number} [options.pad_size.width] The width the images were padded to.\n     * @returns {Tensor[]} Batched masks in batch_size, num_channels, height, width) format, where (height, width) is given by original_size.\n     */\n    post_process_masks(masks, original_sizes, reshaped_input_sizes, {\n        mask_threshold = 0.0,\n        binarize = true,\n        pad_size = null,\n    } = {}) {\n        // masks: [1, 1, 3, 256, 256]\n\n        let output_masks = [];\n\n        pad_size = pad_size ?? this.pad_size;\n\n        let target_image_size = [pad_size.height, pad_size.width];\n\n        for (let i = 0; i < original_sizes.length; ++i) {\n            let original_size = original_sizes[i];\n            let reshaped_input_size = reshaped_input_sizes[i];\n\n            let mask = masks[i]; // [b, c, h, w]\n\n            // TODO: improve\n            let interpolated_masks = [];\n            for (let j = 0; j < mask.dims[0]; ++j) {\n                let m = mask[j]; // 3d tensor\n\n                // Upscale mask to padded size\n                let interpolated_mask = (0,_utils_tensor_js__WEBPACK_IMPORTED_MODULE_3__.interpolate)(m, target_image_size, 'bilinear', false);\n\n                // Crop mask\n                interpolated_mask = interpolated_mask.slice(null, [0, reshaped_input_size[0]], [0, reshaped_input_size[1]]);\n\n                // Downscale mask\n                interpolated_mask = (0,_utils_tensor_js__WEBPACK_IMPORTED_MODULE_3__.interpolate)(mask, original_size, 'bilinear', false);\n\n                if (binarize) {\n                    interpolated_mask = new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_3__.Tensor(\n                        'bool',\n                        Array.from(interpolated_mask.data).map(x => x > mask_threshold),\n                        interpolated_mask.dims\n                    )\n                }\n\n                // add back batch dim for concat\n                interpolated_mask.dims = [1, ...interpolated_mask.dims];\n\n                interpolated_masks.push(interpolated_mask);\n            }\n\n            let concatenated = (0,_utils_tensor_js__WEBPACK_IMPORTED_MODULE_3__.cat)(interpolated_masks);\n            output_masks.push(concatenated);\n        }\n\n        return output_masks;\n\n    }\n}\n\n\nclass WhisperFeatureExtractor extends FeatureExtractor {\n\n    constructor(config) {\n        super(config);\n\n        // Prefer given `mel_filters` from preprocessor_config.json, or calculate them if they don't exist.\n        this.config.mel_filters ??= (0,_utils_audio_js__WEBPACK_IMPORTED_MODULE_5__.getMelFilters)(this.config.sampling_rate, this.config.n_fft, this.config.feature_size);\n    }\n    /**\n     * Calculates the index offset for a given index and window size.\n     * @param {number} i The index.\n     * @param {number} w The window size.\n     * @returns {number} The index offset.\n     */\n    calcOffset(i, w) {\n        return Math.abs((i + w) % (2 * w) - w);\n    }\n\n    /**\n     * Pads an array with a reflected version of itself on both ends.\n     * @param {Float32Array} array The array to pad.\n     * @param {number} left The amount of padding to add to the left.\n     * @param {number} right The amount of padding to add to the right.\n     * @returns {Float32Array} The padded array.\n     */\n    padReflect(array, left, right) {\n        const padded = new Float32Array(array.length + left + right);\n        const w = array.length - 1;\n\n        for (let i = 0; i < array.length; ++i) {\n            padded[left + i] = array[i];\n        }\n\n        for (let i = 1; i <= left; ++i) {\n            padded[left - i] = array[this.calcOffset(i, w)];\n        }\n\n        for (let i = 1; i <= right; ++i) {\n            padded[w + left + i] = array[this.calcOffset(w - i, w)];\n        }\n\n        return padded;\n    }\n\n    /**\n     * Calculates the complex Short-Time Fourier Transform (STFT) of the given framed signal.\n     * \n     * @param {number[][]} frames A 2D array representing the signal frames.\n     * @param {number[]} window A 1D array representing the window to be applied to the frames.\n     * @returns {Object} An object with the following properties:\n     * - data: A 1D array representing the complex STFT of the signal.\n     * - dims: An array representing the dimensions of the STFT data, i.e. [num_frames, num_fft_bins].\n     */\n    stft(frames, window) {\n        // Calculates the complex Short-Time Fourier Transform (STFT) of the given framed signal.\n        // \n        // NOTE: Since the window width is not a power of 2, we must \n        // perform Fast Fourier Transform with chirp-z transform:\n        // https://math.stackexchange.com/questions/77118/non-power-of-2-ffts/77156#77156\n\n        // Helper variables\n        const fft_size = this.config.n_fft;\n        const a = 2 * (fft_size - 1);\n        const b = 2 * (2 * fft_size - 1);\n        const nextP2 = 2 ** (Math.ceil(Math.log2(b)))\n        const num_fft_bins = fft_size + 2;\n\n        // Preallocate array to store output\n        // double since we store complex numbers\n        const data = new Float32Array(num_fft_bins * frames.length);\n\n        // Define buffers\n        // Compute chirp for transform\n        const chirp = new Float32Array(b);\n        const ichirp = new Float32Array(nextP2);\n        const buffer1 = new Float32Array(nextP2);\n        const buffer2 = new Float32Array(nextP2);\n        const outBuffer = new Float32Array(nextP2);\n        const outBuffer2 = new Float32Array(nextP2);\n        const outBuffer3 = new Float32Array(nextP2);\n\n        // Compute complex exponentiation\n        const theta = -2 * Math.PI / fft_size;\n        const baseR = Math.cos(theta);\n        const baseI = Math.sin(theta);\n\n        // Precompute helper for chirp-z transform\n        for (let i = 0; i < b >> 1; ++i) {\n            // Compute complex power:\n            const e = (i + 1 - fft_size) ** 2 / 2.0;\n\n            // Compute the modulus and argument of the result\n            const result_mod = Math.sqrt(baseR ** 2 + baseI ** 2) ** e;\n            const result_arg = e * Math.atan2(baseI, baseR);\n\n            // Convert the result back to rectangular form\n            // and assign to chirp and ichirp\n            let i2 = 2 * i;\n            chirp[i2] = result_mod * Math.cos(result_arg);\n            chirp[i2 + 1] = result_mod * Math.sin(result_arg);\n\n            // conjugate\n            ichirp[i2] = chirp[i2];\n            ichirp[i2 + 1] = - chirp[i2 + 1];\n        }\n        const slicedChirp = chirp.subarray(a, b);\n\n        // create object to perform Fast Fourier Transforms\n        // with `nextP2` complex numbers\n        const f = new _utils_maths_js__WEBPACK_IMPORTED_MODULE_2__.FFT(nextP2 >> 1);\n        // TODO: decide between Float32Array and Float64Array\n        f.transform(outBuffer, ichirp);\n\n        for (let i = 0; i < frames.length; ++i) {\n            const frame = frames[i];\n\n            for (let j = 0; j < slicedChirp.length; j += 2) {\n                const j2 = j + 1\n                const j3 = j >> 1;\n\n                const a_real = frame[j3] * window[j3];\n                buffer1[j] = a_real * slicedChirp[j];\n                buffer1[j2] = a_real * slicedChirp[j2];\n            }\n            // TODO: decide between Float32Array and Float64Array\n            f.transform(outBuffer2, buffer1);\n\n            for (let j = 0; j < outBuffer.length; j += 2) {\n                const j2 = j + 1;\n\n                buffer2[j] = outBuffer2[j] * outBuffer[j] - outBuffer2[j2] * outBuffer[j2]\n                buffer2[j2] = outBuffer2[j] * outBuffer[j2] + outBuffer2[j2] * outBuffer[j]\n            }\n            // TODO: decide between Float32Array and Float64Array\n            f.inverseTransform(outBuffer3, buffer2)\n\n            const offset = i * num_fft_bins;\n            for (let j = 0; j < num_fft_bins; j += 2) {\n                const a_real = outBuffer3[j + a];\n                const a_imag = outBuffer3[j + a + 1];\n                const b_real = slicedChirp[j];\n                const b_imag = slicedChirp[j + 1];\n\n                // TODO write as transpose\n                const o1 = offset + j;\n                data[o1] = a_real * b_real - a_imag * b_imag\n                data[o1 + 1] = a_real * b_imag + a_imag * b_real\n            }\n        }\n\n        return {\n            data: data,\n            dims: [frames.length, num_fft_bins] // [3001, 402]\n        };\n    }\n\n    /**\n     * Creates an array of frames from a given waveform.\n     *\n     * @param {Float32Array} waveform The waveform to create frames from.\n     * @param {boolean} [center=true] Whether to center the frames on their corresponding positions in the waveform. Defaults to true.\n     * @returns {Array} An array of frames.\n     */\n    fram_wave(waveform, center = true) {\n        const frames = [];\n        const half_window = Math.floor((this.config.n_fft - 1) / 2) + 1;\n        const waveformLength = waveform.length;\n\n        for (let i = 0; i < waveformLength + 1; i += this.config.hop_length) {\n\n            let frame;\n            if (center) {\n\n                let frameStart = i > half_window ? i - half_window : 0;\n                let frameEnd =\n                    i < waveformLength - half_window\n                        ? i + half_window\n                        : waveformLength;\n\n                frame = waveform.subarray(frameStart, frameEnd)\n\n                if (frameStart === 0) {\n                    frame = this.padReflect(\n                        frame,\n                        -i + half_window,\n                        0\n                    )\n\n                } else if (frameEnd === waveformLength) {\n                    frame = this.padReflect(\n                        frame,\n                        0,\n                        i - waveformLength + half_window\n                    )\n                }\n\n            } else {\n                frame = new Float32Array(this.config.n_fft);\n                const frameArray = waveform.subarray(i, i + this.config.n_fft);\n\n                if (frameArray.length < this.config.n_fft) {\n                    frame.set(frameArray);\n                    frame.fill(0, frameArray.length, this.config.n_fft)\n                } else {\n                    frame = frameArray;\n                }\n\n            }\n            frames.push(frame);\n        }\n\n        return frames;\n    }\n\n    /**\n     * Generates a Hanning window of length M.\n     *\n     * @param {number} M The length of the Hanning window to generate.\n     * @returns {*} The generated Hanning window.\n     */\n    hanning(M) {\n        if (M < 1) {\n            return [];\n        }\n        if (M === 1) {\n            return [1];\n        }\n        const denom = M - 1;\n        const cos_vals = new Float32Array(denom);\n        for (let i = 0; i < denom; ++i) {\n            const n = 2 * i - M + 1;\n            cos_vals[i] = 0.5 + 0.5 * Math.cos(Math.PI * n / denom);\n        }\n        return cos_vals;\n    }\n\n    /**\n     * Computes the log-Mel spectrogram of the provided audio waveform.\n     * @param {Float32Array|Float64Array} waveform The audio waveform to process.\n     * @returns {{data: Float32Array, dims: number[]}} An object containing the log-Mel spectrogram data as a Float32Array and its dimensions as an array of numbers.\n     */\n    _extract_fbank_features(waveform) {\n        // Compute the log-Mel spectrogram of the provided audio\n\n        const buffer = new Float32Array(this.config.n_samples);\n        buffer.set(waveform)\n\n        const window = this.hanning(this.config.n_fft + 1)\n        const frames = this.fram_wave(buffer)\n\n        const stft = this.stft(frames, window)\n\n        const stftData = stft.data;\n        const d1 = stft.dims[0] - 1; // Ignore last row\n        const d2 = stft.dims[1] >> 1; // Only need to store real numbers now\n\n        // compute magnitudes\n        // NOTE: Unlike the original implementation, we do not\n        // transpose since we perform matrix multiplication later\n        const magnitudes = new Float32Array(d1 * d2);\n        for (let i = 0; i < d1; ++i) {\n            for (let j = 0; j < d2; ++j) {\n                // let outOffset = (j * d1 + i); // transpose\n                let outOffset = i * d2 + j;\n                let inOffset = outOffset << 1; // * 2 since complex\n                let magnitude = stftData[inOffset] ** 2 + stftData[inOffset + 1] ** 2\n                magnitudes[outOffset] = magnitude;\n            }\n        }\n\n        const mel_filters = this.config.mel_filters;\n        const num_mel_filters = mel_filters.length;\n\n        const mel_spec = new Float32Array(num_mel_filters * d1);\n        let mIndex = 0;\n\n        // Perform matrix muliplication:\n        // mel_spec = filters @ magnitudes\n        //  - filters.shape=(80, 201)\n        //  - magnitudes.shape=(201, 3000)\n        //  - mel_spec.shape=(80, 3000)\n        for (let i = 0; i < num_mel_filters; ++i) {\n            const mel_filter = mel_filters[i];\n\n            for (let j = 0; j < d1; ++j) {\n                let sum = 0;\n\n                // perform dot product\n                for (let k = 0; k < d2; ++k) {\n                    sum += mel_filter[k] * magnitudes[j * d2 + k];\n                }\n\n                mel_spec[mIndex++] = sum;\n            }\n        }\n\n        const a_min = 1e-10;\n        const log_spec = new Float32Array(mel_spec.length);\n\n        let maxLogSpec = 0;\n        for (let i = 0; i < mel_spec.length; ++i) {\n            const clipped = Math.max(a_min, mel_spec[i]);\n            const log10 = Math.log10(clipped);\n            log_spec[i] = log10;\n            maxLogSpec = Math.max(log10, maxLogSpec)\n        }\n\n        for (let i = 0; i < log_spec.length; ++i) {\n            log_spec[i] = Math.max(log_spec[i], maxLogSpec - 8);\n            log_spec[i] = (log_spec[i] + 4) / 4;\n        }\n\n        return {\n            data: log_spec,\n            dims: [num_mel_filters, d1]\n        };\n    }\n\n    /**\n     * Asynchronously extracts features from a given audio using the provided configuration.\n     * @param {Float32Array|Float64Array} audio The audio data as a Float32Array.\n     * @returns {Promise<{ input_features: Tensor }>} A Promise resolving to an object containing the extracted input features as a Tensor.\n    */\n    async _call(audio) {\n        if (!(audio instanceof Float32Array || audio instanceof Float64Array)) {\n            throw new Error(\n                // @ts-ignore\n                `WhisperFeatureExtractor expects input to be a Float32Array or a Float64Array, but got ${audio?.constructor?.name ?? typeof audio} instead.` +\n                `If using the feature extractor directly, remember to use \\`read_audio(url, sampling_rate)\\` to obtain the raw audio data of the file/url.`\n            )\n        }\n\n        if (audio.length > this.config.n_samples) {\n            console.warn(\n                \"Attempting to extract features for audio longer than 30 seconds. \" +\n                \"If using a pipeline to extract transcript from a long audio clip, \" +\n                \"remember to specify `chunk_length_s` and/or `stride_length_s`.\"\n            );\n        }\n        let waveform = audio.slice(0, this.config.n_samples);\n\n        let features = this._extract_fbank_features(waveform);\n\n        return {\n            input_features: new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_3__.Tensor('float32',\n                features.data,\n                [1, ...features.dims]\n            )\n        };\n    }\n}\n\n/**\n * Represents a Processor that extracts features from an input.\n * @extends Callable\n */\nclass Processor extends _utils_core_js__WEBPACK_IMPORTED_MODULE_0__.Callable {\n    /**\n     * Creates a new Processor with the given feature extractor.\n     * @param {FeatureExtractor} feature_extractor The function used to extract features from the input.\n     */\n    constructor(feature_extractor) {\n        super();\n        this.feature_extractor = feature_extractor;\n        // TODO use tokenizer here?\n    }\n\n    /**\n     * Calls the feature_extractor function with the given input.\n     * @param {any} input The input to extract features from.\n     * @returns {Promise<any>} A Promise that resolves with the extracted features.\n     */\n    async _call(input) {\n        return await this.feature_extractor(input);\n    }\n}\n\nclass SamProcessor extends Processor {\n\n    async _call(images, input_points) {\n        return await this.feature_extractor(images, input_points);\n    }\n\n    /**\n     * @borrows SamImageProcessor#post_process_masks as post_process_masks\n     */\n    post_process_masks(...args) {\n        // @ts-ignore\n        return this.feature_extractor.post_process_masks(...args);\n    }\n}\n\n/**\n * Represents a WhisperProcessor that extracts features from an audio input.\n * @extends Processor\n */\nclass WhisperProcessor extends Processor {\n    /**\n     * Calls the feature_extractor function with the given audio input.\n     * @param {any} audio The audio input to extract features from.\n     * @returns {Promise<any>} A Promise that resolves with the extracted features.\n     */\n    async _call(audio) {\n        return await this.feature_extractor(audio)\n    }\n}\n\n//////////////////////////////////////////////////\n/**\n * @typedef {import('./utils/hub.js').PretrainedOptions} PretrainedOptions\n */\n/**\n * Helper class which is used to instantiate pretrained processors with the `from_pretrained` function.\n * The chosen processor class is determined by the type specified in the processor config.\n * \n * **Example:** Load a processor using `from_pretrained`.\n * ```javascript\n * let processor = await AutoProcessor.from_pretrained('openai/whisper-tiny.en');\n * ```\n * \n * **Example:** Run an image through a processor.\n * ```javascript\n * let processor = await AutoProcessor.from_pretrained('Xenova/clip-vit-base-patch16');\n * let image = await RawImage.read('https://huggingface.co/datasets/Xenova/transformers.js-docs/resolve/main/football-match.jpg');\n * let image_inputs = await processor(image);\n * // {\n * //   \"pixel_values\": {\n * //     \"dims\": [ 1, 3, 224, 224 ],\n * //     \"type\": \"float32\",\n * //     \"data\": Float32Array [ -1.558687686920166, -1.558687686920166, -1.5440893173217773, ... ],\n * //     \"size\": 150528\n * //   },\n * //   \"original_sizes\": [\n * //     [ 533, 800 ]\n * //   ],\n * //   \"reshaped_input_sizes\": [\n * //     [ 224, 224 ]\n * //   ]\n * // }\n * ```\n */\nclass AutoProcessor {\n    static FEATURE_EXTRACTOR_CLASS_MAPPING = {\n        'WhisperFeatureExtractor': WhisperFeatureExtractor,\n        'ViTFeatureExtractor': ViTFeatureExtractor,\n        'MobileViTFeatureExtractor': MobileViTFeatureExtractor,\n        'DetrFeatureExtractor': DetrFeatureExtractor,\n\n        'SamImageProcessor': SamImageProcessor,\n    }\n\n    static PROCESSOR_CLASS_MAPPING = {\n        'WhisperProcessor': WhisperProcessor,\n        'SamProcessor': SamProcessor,\n    }\n\n    /**\n     * Instantiate one of the processor classes of the library from a pretrained model.\n     * \n     * The processor class to instantiate is selected based on the `feature_extractor_type` property of the config object\n     * (either passed as an argument or loaded from `pretrained_model_name_or_path` if possible)\n     * \n     * @param {string} pretrained_model_name_or_path The name or path of the pretrained model. Can be either:\n     * - A string, the *model id* of a pretrained processor hosted inside a model repo on huggingface.co.\n     *   Valid model ids can be located at the root-level, like `bert-base-uncased`, or namespaced under a\n     *   user or organization name, like `dbmdz/bert-base-german-cased`.\n     * - A path to a *directory* containing processor files, e.g., `./my_model_directory/`.\n     * @param {PretrainedOptions} options Additional options for loading the processor.\n     * \n     * @returns {Promise<Processor>} A new instance of the Processor class.\n     */\n    static async from_pretrained(pretrained_model_name_or_path, {\n        progress_callback = null,\n        config = null,\n        cache_dir = null,\n        local_files_only = false,\n        revision = 'main',\n    } = {}) {\n\n        let preprocessorConfig = config ?? await (0,_utils_hub_js__WEBPACK_IMPORTED_MODULE_1__.getModelJSON)(pretrained_model_name_or_path, 'preprocessor_config.json', true, {\n            progress_callback,\n            config,\n            cache_dir,\n            local_files_only,\n            revision,\n        })\n\n        // Determine feature extractor class\n        // TODO: Ensure backwards compatibility with old configs\n        let key = preprocessorConfig.feature_extractor_type ?? preprocessorConfig.image_processor_type;\n        let feature_extractor_class = this.FEATURE_EXTRACTOR_CLASS_MAPPING[key];\n\n        if (!feature_extractor_class) {\n            if (preprocessorConfig.size !== undefined) {\n                // Assume ImageFeatureExtractor\n                console.warn('Feature extractor type not specified, assuming ImageFeatureExtractor due to size parameter in config.');\n                feature_extractor_class = ImageFeatureExtractor;\n            } else {\n                throw new Error(`Unknown Feature Extractor type: ${preprocessorConfig.feature_extractor_type}`);\n            }\n        }\n\n        // If no associated processor class, use default\n        let processor_class = this.PROCESSOR_CLASS_MAPPING[preprocessorConfig.processor_class] ?? Processor;\n\n        // Instantiate processor and feature extractor\n        let feature_extractor = new feature_extractor_class(preprocessorConfig);\n        return new processor_class(feature_extractor);\n    }\n}\n//////////////////////////////////////////////////\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHhlbm92YS90cmFuc2Zvcm1lcnMvc3JjL3Byb2Nlc3NvcnMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksNEJBQTRCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLFNBQVMsaUJBQWlCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSXlCOztBQUlEOztBQU1FOzs7QUFHOEM7O0FBRTVCO0FBQ0s7OztBQUdqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sK0JBQStCLG9EQUFRO0FBQzlDO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPOztBQUVQO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFVBQVU7QUFDekIsZUFBZSxVQUFVO0FBQ3pCLGVBQWUsU0FBUztBQUN4QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsVUFBVTtBQUN6QixpQkFBaUIsY0FBYztBQUMvQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdDQUF3QztBQUN4Qyx3Q0FBd0M7O0FBRXhDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7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QSxlQUFlLEtBQUs7QUFDcEIsaUJBQWlCLGNBQWM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLGVBQWUsS0FBSztBQUNwQixpQkFBaUIsY0FBYztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLDRDQUE0QztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxtQkFBbUI7QUFDbEM7QUFDQSxpQkFBaUIsb0JBQW9CO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxJQUFJOztBQUVWLGlEQUFpRCwyREFBWTtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLG1FQUFtRSwwQ0FBMEM7QUFDN0c7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3RyYW5zZm9ybWVyc2pzLXBsYXlncm91bmQvLi9ub2RlX21vZHVsZXMvQHhlbm92YS90cmFuc2Zvcm1lcnMvc3JjL3Byb2Nlc3NvcnMuanM/Zjg1MyJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qKlxuICogQGZpbGUgUHJvY2Vzc29ycyBhcmUgdXNlZCB0byBwcmVwYXJlIG5vbi10ZXh0dWFsIGlucHV0cyAoZS5nLiwgaW1hZ2Ugb3IgYXVkaW8pIGZvciBhIG1vZGVsLlxuICogXG4gKiAqKkV4YW1wbGU6KiogVXNpbmcgYSBgV2hpc3BlclByb2Nlc3NvcmAgdG8gcHJlcGFyZSBhbiBhdWRpbyBpbnB1dCBmb3IgYSBtb2RlbC5cbiAqIGBgYGphdmFzY3JpcHRcbiAqIGltcG9ydCB7IEF1dG9Qcm9jZXNzb3IsIHJlYWRfYXVkaW8gfSBmcm9tICdAeGVub3ZhL3RyYW5zZm9ybWVycyc7XG4gKlxuICogbGV0IHByb2Nlc3NvciA9IGF3YWl0IEF1dG9Qcm9jZXNzb3IuZnJvbV9wcmV0cmFpbmVkKCdvcGVuYWkvd2hpc3Blci10aW55LmVuJyk7XG4gKiBsZXQgYXVkaW8gPSBhd2FpdCByZWFkX2F1ZGlvKCdodHRwczovL2h1Z2dpbmdmYWNlLmNvL2RhdGFzZXRzL05hcnNpbC9hc3JfZHVtbXkvcmVzb2x2ZS9tYWluL21say5mbGFjJywgMTYwMDApO1xuICogbGV0IHsgaW5wdXRfZmVhdHVyZXMgfSA9IGF3YWl0IHByb2Nlc3NvcihhdWRpbyk7XG4gKiAvLyBUZW5zb3Ige1xuICogLy8gICBkYXRhOiBGbG9hdDMyQXJyYXkoMjQwMDAwKSBbMC40NzUyOTg0NjQyOTgyNDgzLCAwLjU1OTcyNTg4MDYyMjg2MzgsIDAuNTY0MzQxNjY0MzE0MjcsIC4uLl0sXG4gKiAvLyAgIGRpbXM6IFsxLCA4MCwgMzAwMF0sXG4gKiAvLyAgIHR5cGU6ICdmbG9hdDMyJyxcbiAqIC8vICAgc2l6ZTogMjQwMDAwLFxuICogLy8gfVxuICogYGBgXG4gKiBcbiAqIEBtb2R1bGUgcHJvY2Vzc29yc1xuICovXG5pbXBvcnQge1xuICAgIENhbGxhYmxlLFxuICAgIGNhbGN1bGF0ZURpbWVuc2lvbnMsXG59IGZyb20gJy4vdXRpbHMvY29yZS5qcyc7XG5cbmltcG9ydCB7XG4gICAgZ2V0TW9kZWxKU09OLFxufSBmcm9tICcuL3V0aWxzL2h1Yi5qcyc7XG5cbmltcG9ydCB7XG4gICAgbWF4LFxuICAgIHNvZnRtYXgsXG4gICAgRkZUXG59IGZyb20gJy4vdXRpbHMvbWF0aHMuanMnO1xuXG5cbmltcG9ydCB7IFRlbnNvciwgdHJhbnNwb3NlLCBjYXQsIGludGVycG9sYXRlIH0gZnJvbSAnLi91dGlscy90ZW5zb3IuanMnO1xuXG5pbXBvcnQgeyBSYXdJbWFnZSB9IGZyb20gJy4vdXRpbHMvaW1hZ2UuanMnO1xuaW1wb3J0IHsgZ2V0TWVsRmlsdGVycyB9IGZyb20gJy4vdXRpbHMvYXVkaW8uanMnO1xuXG5cbi8qKlxuICogQmFzZSBjbGFzcyBmb3IgZmVhdHVyZSBleHRyYWN0b3JzLlxuICpcbiAqIEBleHRlbmRzIENhbGxhYmxlXG4gKi9cbmV4cG9ydCBjbGFzcyBGZWF0dXJlRXh0cmFjdG9yIGV4dGVuZHMgQ2FsbGFibGUge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdHMgYSBuZXcgRmVhdHVyZUV4dHJhY3RvciBpbnN0YW5jZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgVGhlIGNvbmZpZ3VyYXRpb24gZm9yIHRoZSBmZWF0dXJlIGV4dHJhY3Rvci5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5jb25maWcgPSBjb25maWdcbiAgICB9XG59XG5cbi8qKlxuICogRmVhdHVyZSBleHRyYWN0b3IgZm9yIGltYWdlIG1vZGVscy5cbiAqXG4gKiBAZXh0ZW5kcyBGZWF0dXJlRXh0cmFjdG9yXG4gKi9cbmV4cG9ydCBjbGFzcyBJbWFnZUZlYXR1cmVFeHRyYWN0b3IgZXh0ZW5kcyBGZWF0dXJlRXh0cmFjdG9yIHtcblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdHMgYSBuZXcgSW1hZ2VGZWF0dXJlRXh0cmFjdG9yIGluc3RhbmNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBUaGUgY29uZmlndXJhdGlvbiBmb3IgdGhlIGZlYXR1cmUgZXh0cmFjdG9yLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyW119IGNvbmZpZy5pbWFnZV9tZWFuIFRoZSBtZWFuIHZhbHVlcyBmb3IgaW1hZ2Ugbm9ybWFsaXphdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcltdfSBjb25maWcuaW1hZ2Vfc3RkIFRoZSBzdGFuZGFyZCBkZXZpYXRpb24gdmFsdWVzIGZvciBpbWFnZSBub3JtYWxpemF0aW9uLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gY29uZmlnLmRvX3Jlc2NhbGUgV2hldGhlciB0byByZXNjYWxlIHRoZSBpbWFnZSBwaXhlbCB2YWx1ZXMgdG8gdGhlIFswLDFdIHJhbmdlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjb25maWcucmVzY2FsZV9mYWN0b3IgVGhlIGZhY3RvciB0byB1c2UgZm9yIHJlc2NhbGluZyB0aGUgaW1hZ2UgcGl4ZWwgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gY29uZmlnLmRvX25vcm1hbGl6ZSBXaGV0aGVyIHRvIG5vcm1hbGl6ZSB0aGUgaW1hZ2UgcGl4ZWwgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gY29uZmlnLmRvX3Jlc2l6ZSBXaGV0aGVyIHRvIHJlc2l6ZSB0aGUgaW1hZ2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNvbmZpZy5yZXNhbXBsZSBXaGF0IG1ldGhvZCB0byB1c2UgZm9yIHJlc2FtcGxpbmcuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNvbmZpZy5zaXplIFRoZSBzaXplIHRvIHJlc2l6ZSB0aGUgaW1hZ2UgdG8uXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZyk7XG5cbiAgICAgICAgdGhpcy5pbWFnZV9tZWFuID0gdGhpcy5jb25maWcuaW1hZ2VfbWVhbjtcbiAgICAgICAgdGhpcy5pbWFnZV9zdGQgPSB0aGlzLmNvbmZpZy5pbWFnZV9zdGQ7XG5cbiAgICAgICAgdGhpcy5yZXNhbXBsZSA9IHRoaXMuY29uZmlnLnJlc2FtcGxlID8/IDI7IC8vIDIgPT4gYmlsaW5lYXJcbiAgICAgICAgdGhpcy5kb19yZXNjYWxlID0gdGhpcy5jb25maWcuZG9fcmVzY2FsZSA/PyB0cnVlO1xuICAgICAgICB0aGlzLnJlc2NhbGVfZmFjdG9yID0gdGhpcy5jb25maWcucmVzY2FsZV9mYWN0b3IgPz8gKDEgLyAyNTUpO1xuICAgICAgICB0aGlzLmRvX25vcm1hbGl6ZSA9IHRoaXMuY29uZmlnLmRvX25vcm1hbGl6ZTtcblxuICAgICAgICB0aGlzLmRvX3Jlc2l6ZSA9IHRoaXMuY29uZmlnLmRvX3Jlc2l6ZTtcbiAgICAgICAgdGhpcy5zaXplID0gdGhpcy5jb25maWcuc2l6ZTtcblxuICAgICAgICB0aGlzLmRvX2NlbnRlcl9jcm9wID0gdGhpcy5jb25maWcuZG9fY2VudGVyX2Nyb3A7XG4gICAgICAgIHRoaXMuY3JvcF9zaXplID0gdGhpcy5jb25maWcuY3JvcF9zaXplO1xuICAgICAgICB0aGlzLmRvX2NvbnZlcnRfcmdiID0gdGhpcy5jb25maWcuZG9fY29udmVydF9yZ2IgPz8gdHJ1ZTtcblxuICAgICAgICB0aGlzLnBhZF9zaXplID0gdGhpcy5jb25maWcucGFkX3NpemU7XG4gICAgICAgIHRoaXMuZG9fcGFkID0gKHRoaXMuY29uZmlnLmRvX3BhZCA/PyBmYWxzZSkgJiYgdGhpcy5wYWRfc2l6ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQcmVwcm9jZXNzZXMgdGhlIGdpdmVuIGltYWdlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtSYXdJbWFnZX0gaW1hZ2UgVGhlIGltYWdlIHRvIHByZXByb2Nlc3MuXG4gICAgICogQHJldHVybnMge1Byb21pc2U8YW55Pn0gVGhlIHByZXByb2Nlc3NlZCBpbWFnZSBhcyBhIFRlbnNvci5cbiAgICAgKi9cbiAgICBhc3luYyBwcmVwcm9jZXNzKGltYWdlKSB7XG5cbiAgICAgICAgLy8gRmlyc3QsIGNvbnZlcnQgaW1hZ2UgdG8gUkdCIGlmIHNwZWNpZmllZCBpbiBjb25maWcuXG4gICAgICAgIGlmICh0aGlzLmRvX2NvbnZlcnRfcmdiKSB7XG4gICAgICAgICAgICBpbWFnZSA9IGltYWdlLnJnYigpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgc3JjV2lkdGggPSBpbWFnZS53aWR0aDsgICAvLyBvcmlnaW5hbCB3aWR0aFxuICAgICAgICBjb25zdCBzcmNIZWlnaHQgPSBpbWFnZS5oZWlnaHQ7IC8vIG9yaWdpbmFsIGhlaWdodFxuXG4gICAgICAgIC8vIE5leHQsIHJlc2l6ZSBhbGwgaW1hZ2VzXG4gICAgICAgIGlmICh0aGlzLmRvX3Jlc2l6ZSkge1xuICAgICAgICAgICAgLy8gVE9ETzpcbiAgICAgICAgICAgIC8vIEZvciBlZmZpY2llbmN5IHJlYXNvbnMsIGl0IG1pZ2h0IGJlIGJlc3QgdG8gbWVyZ2UgdGhlIHJlc2l6ZSBhbmQgY2VudGVyIGNyb3Agb3BlcmF0aW9ucyBpbnRvIG9uZS5cblxuICAgICAgICAgICAgLy8gYHRoaXMuc2l6ZWAgY29tZXMgaW4gbWFueSBmb3Jtcywgc28gd2UgbmVlZCB0byBoYW5kbGUgdGhlbSBhbGwgaGVyZTpcbiAgICAgICAgICAgIC8vIDEuIGB0aGlzLnNpemVgIGlzIGFuIGludGVnZXIsIGluIHdoaWNoIGNhc2Ugd2UgcmVzaXplIHRoZSBpbWFnZSB0byBiZSBhIHNxdWFyZSBcblxuICAgICAgICAgICAgbGV0IHNob3J0ZXN0X2VkZ2U7XG4gICAgICAgICAgICBsZXQgbG9uZ2VzdF9lZGdlO1xuXG4gICAgICAgICAgICAvLyBTdXBwb3J0IGJvdGggZm9ybWF0cyBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbiAgICAgICAgICAgIGlmIChOdW1iZXIuaXNJbnRlZ2VyKHRoaXMuc2l6ZSkpIHtcbiAgICAgICAgICAgICAgICBzaG9ydGVzdF9lZGdlID0gdGhpcy5zaXplO1xuICAgICAgICAgICAgICAgIGxvbmdlc3RfZWRnZSA9IHRoaXMuY29uZmlnLm1heF9zaXplID8/IHNob3J0ZXN0X2VkZ2U7XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gRXh0cmFjdCBrbm93biBwcm9wZXJ0aWVzIGZyb20gYHRoaXMuc2l6ZWBcbiAgICAgICAgICAgICAgICBzaG9ydGVzdF9lZGdlID0gdGhpcy5zaXplLnNob3J0ZXN0X2VkZ2U7XG4gICAgICAgICAgICAgICAgbG9uZ2VzdF9lZGdlID0gdGhpcy5zaXplLmxvbmdlc3RfZWRnZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSWYgYGxvbmdlc3RfZWRnZWAgYW5kIGBzaG9ydGVzdF9lZGdlYCBhcmUgc2V0LCBtYWludGFpbiBhc3BlY3QgcmF0aW8gYW5kIHJlc2l6ZSB0byBgc2hvcnRlc3RfZWRnZWBcbiAgICAgICAgICAgIC8vIHdoaWxlIGtlZXBpbmcgdGhlIGxhcmdlc3QgZGltZW5zaW9uIDw9IGBsb25nZXN0X2VkZ2VgXG4gICAgICAgICAgICBpZiAoc2hvcnRlc3RfZWRnZSAhPT0gdW5kZWZpbmVkIHx8IGxvbmdlc3RfZWRnZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgLy8gaHR0cDovL29wZW5zb3VyY2VoYWNrZXIuY29tLzIwMTEvMTIvMDEvY2FsY3VsYXRlLWFzcGVjdC1yYXRpby1jb25zZXJ2aW5nLXJlc2l6ZS1mb3ItaW1hZ2VzLWluLWphdmFzY3JpcHQvXG4gICAgICAgICAgICAgICAgLy8gVHJ5IHJlc2l6ZSBzbyB0aGF0IHNob3J0ZXN0IGVkZ2UgaXMgYHRoaXMuc2hvcnRlc3RfZWRnZWAgKHRhcmdldClcbiAgICAgICAgICAgICAgICBjb25zdCBzaG9ydFJlc2l6ZUZhY3RvciA9IHNob3J0ZXN0X2VkZ2UgPT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICA/IDEgLy8gSWYgYHNob3J0ZXN0X2VkZ2VgIGlzIG5vdCBzZXQsIGRvbid0IHVwc2NhbGVcbiAgICAgICAgICAgICAgICAgICAgOiBNYXRoLm1heChzaG9ydGVzdF9lZGdlIC8gc3JjV2lkdGgsIHNob3J0ZXN0X2VkZ2UgLyBzcmNIZWlnaHQpO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgbmV3V2lkdGggPSBzcmNXaWR0aCAqIHNob3J0UmVzaXplRmFjdG9yO1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld0hlaWdodCA9IHNyY0hlaWdodCAqIHNob3J0UmVzaXplRmFjdG9yO1xuXG4gICAgICAgICAgICAgICAgLy8gVGhlIG5ldyB3aWR0aCBhbmQgaGVpZ2h0IG1pZ2h0IGJlIGdyZWF0ZXIgdGhhbiBgdGhpcy5sb25nZXN0X2VkZ2VgLCBzb1xuICAgICAgICAgICAgICAgIC8vIHdlIGRvd25zY2FsZSBhZ2FpbiB0byBlbnN1cmUgdGhlIGxhcmdlc3QgZGltZW5zaW9uIGlzIGB0aGlzLmxvbmdlc3RfZWRnZWAgXG4gICAgICAgICAgICAgICAgY29uc3QgbG9uZ1Jlc2l6ZUZhY3RvciA9IGxvbmdlc3RfZWRnZSA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgID8gMSAvLyBJZiBgbG9uZ2VzdF9lZGdlYCBpcyBub3Qgc2V0LCBkb24ndCBkb3duc2NhbGVcbiAgICAgICAgICAgICAgICAgICAgOiBNYXRoLm1pbihsb25nZXN0X2VkZ2UgLyBuZXdXaWR0aCwgbG9uZ2VzdF9lZGdlIC8gbmV3SGVpZ2h0KTtcblxuICAgICAgICAgICAgICAgIC8vIFBlcmZvcm0gcmVzaXplXG4gICAgICAgICAgICAgICAgaW1hZ2UgPSBhd2FpdCBpbWFnZS5yZXNpemUoTWF0aC5mbG9vcihuZXdXaWR0aCAqIGxvbmdSZXNpemVGYWN0b3IpLCBNYXRoLmZsb29yKG5ld0hlaWdodCAqIGxvbmdSZXNpemVGYWN0b3IpLCB7XG4gICAgICAgICAgICAgICAgICAgIHJlc2FtcGxlOiB0aGlzLnJlc2FtcGxlLFxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuc2l6ZS53aWR0aCAhPT0gdW5kZWZpbmVkICYmIHRoaXMuc2l6ZS5oZWlnaHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIC8vIElmIGB3aWR0aGAgYW5kIGBoZWlnaHRgIGFyZSBzZXQsIHJlc2l6ZSB0byB0aG9zZSBkaW1lbnNpb25zXG4gICAgICAgICAgICAgICAgaW1hZ2UgPSBhd2FpdCBpbWFnZS5yZXNpemUodGhpcy5zaXplLndpZHRoLCB0aGlzLnNpemUuaGVpZ2h0LCB7XG4gICAgICAgICAgICAgICAgICAgIHJlc2FtcGxlOiB0aGlzLnJlc2FtcGxlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvdWxkIG5vdCByZXNpemUgaW1hZ2UgZHVlIHRvIHVuc3VwcG9ydGVkIFxcYHRoaXMuc2l6ZVxcYCBvcHRpb24gaW4gY29uZmlnOiAke0pTT04uc3RyaW5naWZ5KHRoaXMuc2l6ZSl9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5kb19jZW50ZXJfY3JvcCkge1xuXG4gICAgICAgICAgICBsZXQgY3JvcF93aWR0aDtcbiAgICAgICAgICAgIGxldCBjcm9wX2hlaWdodDtcbiAgICAgICAgICAgIGlmIChOdW1iZXIuaXNJbnRlZ2VyKHRoaXMuY3JvcF9zaXplKSkge1xuICAgICAgICAgICAgICAgIGNyb3Bfd2lkdGggPSB0aGlzLmNyb3Bfc2l6ZTtcbiAgICAgICAgICAgICAgICBjcm9wX2hlaWdodCA9IHRoaXMuY3JvcF9zaXplO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjcm9wX3dpZHRoID0gdGhpcy5jcm9wX3NpemUud2lkdGg7XG4gICAgICAgICAgICAgICAgY3JvcF9oZWlnaHQgPSB0aGlzLmNyb3Bfc2l6ZS5oZWlnaHQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGltYWdlID0gYXdhaXQgaW1hZ2UuY2VudGVyX2Nyb3AoY3JvcF93aWR0aCwgY3JvcF9oZWlnaHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHJlc2hhcGVkX2lucHV0X3NpemUgPSBbaW1hZ2UuaGVpZ2h0LCBpbWFnZS53aWR0aF07XG5cbiAgICAgICAgLy8gVE9ETyBpcyBpdCBva2F5IHRvIHBhZCBiZWZvcmUgcmVzY2FsaW5nL25vcm1hbGl6aW5nP1xuICAgICAgICBpZiAodGhpcy5kb19wYWQpIHtcbiAgICAgICAgICAgIGxldCBsZWZ0ID0gMDtcbiAgICAgICAgICAgIGxldCByaWdodCA9IHRoaXMucGFkX3NpemUud2lkdGggLSBpbWFnZS53aWR0aDtcbiAgICAgICAgICAgIGxldCB0b3AgPSAwO1xuICAgICAgICAgICAgbGV0IGJvdHRvbSA9IHRoaXMucGFkX3NpemUuaGVpZ2h0IC0gaW1hZ2UuaGVpZ2h0O1xuXG4gICAgICAgICAgICBpbWFnZSA9IGF3YWl0IGltYWdlLnBhZChbbGVmdCwgcmlnaHQsIHRvcCwgYm90dG9tXSk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBwaXhlbERhdGEgPSBGbG9hdDMyQXJyYXkuZnJvbShpbWFnZS5kYXRhKTtcblxuICAgICAgICBpZiAodGhpcy5kb19yZXNjYWxlKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBpeGVsRGF0YS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIHBpeGVsRGF0YVtpXSA9IHRoaXMucmVzY2FsZV9mYWN0b3IgKiBwaXhlbERhdGFbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5kb19ub3JtYWxpemUpIHtcbiAgICAgICAgICAgIGxldCBpbWFnZV9tZWFuID0gdGhpcy5pbWFnZV9tZWFuO1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHRoaXMuaW1hZ2VfbWVhbikpIHtcbiAgICAgICAgICAgICAgICBpbWFnZV9tZWFuID0gbmV3IEFycmF5KGltYWdlLmNoYW5uZWxzKS5maWxsKGltYWdlX21lYW4pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQgaW1hZ2Vfc3RkID0gdGhpcy5pbWFnZV9zdGQ7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodGhpcy5pbWFnZV9zdGQpKSB7XG4gICAgICAgICAgICAgICAgaW1hZ2Vfc3RkID0gbmV3IEFycmF5KGltYWdlLmNoYW5uZWxzKS5maWxsKGltYWdlX21lYW4pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaW1hZ2VfbWVhbi5sZW5ndGggIT09IGltYWdlLmNoYW5uZWxzIHx8IGltYWdlX3N0ZC5sZW5ndGggIT09IGltYWdlLmNoYW5uZWxzKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBXaGVuIHNldCB0byBhcnJheXMsIHRoZSBsZW5ndGggb2YgXFxgaW1hZ2VfbWVhblxcYCAoJHtpbWFnZV9tZWFuLmxlbmd0aH0pIGFuZCBcXGBpbWFnZV9zdGRcXGAgKCR7aW1hZ2Vfc3RkLmxlbmd0aH0pIG11c3QgbWF0Y2ggdGhlIG51bWJlciBvZiBjaGFubmVscyBpbiB0aGUgaW1hZ2UgKCR7aW1hZ2UuY2hhbm5lbHN9KS5gKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwaXhlbERhdGEubGVuZ3RoOyBpICs9IGltYWdlLmNoYW5uZWxzKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBpbWFnZS5jaGFubmVsczsgKytqKSB7XG4gICAgICAgICAgICAgICAgICAgIHBpeGVsRGF0YVtpICsgal0gPSAocGl4ZWxEYXRhW2kgKyBqXSAtIHRoaXMuaW1hZ2VfbWVhbltqXSkgLyB0aGlzLmltYWdlX3N0ZFtqXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjb252ZXJ0IHRvIGNoYW5uZWwgZGltZW5zaW9uIGZvcm1hdDpcbiAgICAgICAgbGV0IGltZ0RpbXMgPSBbaW1hZ2UuaGVpZ2h0LCBpbWFnZS53aWR0aCwgaW1hZ2UuY2hhbm5lbHNdO1xuICAgICAgICBsZXQgaW1nID0gbmV3IFRlbnNvcignZmxvYXQzMicsIHBpeGVsRGF0YSwgaW1nRGltcyk7XG4gICAgICAgIGxldCB0cmFuc3Bvc2VkID0gdHJhbnNwb3NlKGltZywgWzIsIDAsIDFdKTsgLy8gaHdjIC0+IGNod1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBvcmlnaW5hbF9zaXplOiBbc3JjSGVpZ2h0LCBzcmNXaWR0aF0sXG4gICAgICAgICAgICByZXNoYXBlZF9pbnB1dF9zaXplOiByZXNoYXBlZF9pbnB1dF9zaXplLFxuICAgICAgICAgICAgcGl4ZWxfdmFsdWVzOiB0cmFuc3Bvc2VkLFxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsbHMgdGhlIGZlYXR1cmUgZXh0cmFjdGlvbiBwcm9jZXNzIG9uIGFuIGFycmF5IG9mIGltYWdlXG4gICAgICogVVJMcywgcHJlcHJvY2Vzc2VzIGVhY2ggaW1hZ2UsIGFuZCBjb25jYXRlbmF0ZXMgdGhlIHJlc3VsdGluZ1xuICAgICAqIGZlYXR1cmVzIGludG8gYSBzaW5nbGUgVGVuc29yLlxuICAgICAqIEBwYXJhbSB7YW55fSBpbWFnZXMgVGhlIFVSTChzKSBvZiB0aGUgaW1hZ2UocykgdG8gZXh0cmFjdCBmZWF0dXJlcyBmcm9tLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD59IEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBjb25jYXRlbmF0ZWQgcGl4ZWwgdmFsdWVzIChhbmQgb3RoZXIgbWV0YWRhdGEpIG9mIHRoZSBwcmVwcm9jZXNzZWQgaW1hZ2VzLlxuICAgICAqL1xuICAgIGFzeW5jIF9jYWxsKGltYWdlcykge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoaW1hZ2VzKSkge1xuICAgICAgICAgICAgaW1hZ2VzID0gW2ltYWdlc107XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgaW1hZ2VEYXRhID0gYXdhaXQgUHJvbWlzZS5hbGwoaW1hZ2VzLm1hcCh4ID0+IHRoaXMucHJlcHJvY2Vzcyh4KSkpO1xuXG4gICAgICAgIC8vIFRPRE86XG5cbiAgICAgICAgLy8gQ29uY2F0ZW5hdGUgcGl4ZWwgdmFsdWVzXG4gICAgICAgIC8vIFRFTVA6IEFkZCBiYXRjaCBkaW1lbnNpb24gc28gdGhhdCBjb25jYXQgd29ya3NcbiAgICAgICAgaW1hZ2VEYXRhLmZvckVhY2goeCA9PiB4LnBpeGVsX3ZhbHVlcy5kaW1zID0gWzEsIC4uLngucGl4ZWxfdmFsdWVzLmRpbXNdKTtcbiAgICAgICAgbGV0IHBpeGVsX3ZhbHVlcyA9IGNhdChpbWFnZURhdGEubWFwKHggPT4geC5waXhlbF92YWx1ZXMpKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcGl4ZWxfdmFsdWVzOiBwaXhlbF92YWx1ZXMsXG5cbiAgICAgICAgICAgIC8vIE9yaWdpbmFsIHNpemVzIG9mIGltYWdlc1xuICAgICAgICAgICAgb3JpZ2luYWxfc2l6ZXM6IGltYWdlRGF0YS5tYXAoeCA9PiB4Lm9yaWdpbmFsX3NpemUpLFxuXG4gICAgICAgICAgICAvLyBSZXNoYXBlZCBzaXplcyBvZiBpbWFnZXMsIGJlZm9yZSBwYWRkaW5nIG9yIGNyb3BwaW5nXG4gICAgICAgICAgICByZXNoYXBlZF9pbnB1dF9zaXplczogaW1hZ2VEYXRhLm1hcCh4ID0+IHgucmVzaGFwZWRfaW5wdXRfc2l6ZSksXG4gICAgICAgIH1cbiAgICB9XG5cbn1cblxuZXhwb3J0IGNsYXNzIFZpVEZlYXR1cmVFeHRyYWN0b3IgZXh0ZW5kcyBJbWFnZUZlYXR1cmVFeHRyYWN0b3IgeyB9XG5leHBvcnQgY2xhc3MgTW9iaWxlVmlURmVhdHVyZUV4dHJhY3RvciBleHRlbmRzIEltYWdlRmVhdHVyZUV4dHJhY3RvciB7IH1cblxuLyoqXG4gKiBEZXRyIEZlYXR1cmUgRXh0cmFjdG9yLlxuICpcbiAqIEBleHRlbmRzIEltYWdlRmVhdHVyZUV4dHJhY3RvclxuICovXG5leHBvcnQgY2xhc3MgRGV0ckZlYXR1cmVFeHRyYWN0b3IgZXh0ZW5kcyBJbWFnZUZlYXR1cmVFeHRyYWN0b3Ige1xuICAgIC8qKlxuICAgICAqIENhbGxzIHRoZSBmZWF0dXJlIGV4dHJhY3Rpb24gcHJvY2VzcyBvbiBhbiBhcnJheSBvZiBpbWFnZVxuICAgICAqIFVSTHMsIHByZXByb2Nlc3NlcyBlYWNoIGltYWdlLCBhbmQgY29uY2F0ZW5hdGVzIHRoZSByZXN1bHRpbmdcbiAgICAgKiBmZWF0dXJlcyBpbnRvIGEgc2luZ2xlIFRlbnNvci5cbiAgICAgKiBAcGFyYW0ge2FueX0gdXJscyBUaGUgVVJMKHMpIG9mIHRoZSBpbWFnZShzKSB0byBleHRyYWN0IGZlYXR1cmVzIGZyb20uXG4gICAgICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0Pn0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGNvbmNhdGVuYXRlZCBwaXhlbCB2YWx1ZXMgb2YgdGhlIHByZXByb2Nlc3NlZCBpbWFnZXMuXG4gICAgICovXG4gICAgYXN5bmMgX2NhbGwodXJscykge1xuICAgICAgICBsZXQgcmVzdWx0ID0gYXdhaXQgc3VwZXIuX2NhbGwodXJscyk7XG5cbiAgICAgICAgLy8gVE9ETyBzdXBwb3J0IGRpZmZlcmVudGx5LXNpemVkIGltYWdlcywgZm9yIG5vdyBhc3N1bWUgYWxsIGltYWdlcyBhcmUgdGhlIHNhbWUgc2l6ZS5cbiAgICAgICAgLy8gVE9ETyBzdXBwb3J0IGRpZmZlcmVudCBtYXNrIHNpemVzIChub3QganVzdCA2NHg2NClcbiAgICAgICAgLy8gQ3VycmVudGx5LCBqdXN0IGZpbGwgcGl4ZWwgbWFzayB3aXRoIDFzXG4gICAgICAgIGxldCBtYXNrU2l6ZSA9IFtyZXN1bHQucGl4ZWxfdmFsdWVzLmRpbXNbMF0sIDY0LCA2NF07XG4gICAgICAgIHJlc3VsdC5waXhlbF9tYXNrID0gbmV3IFRlbnNvcihcbiAgICAgICAgICAgICdpbnQ2NCcsXG4gICAgICAgICAgICAvLyBUT0RPOiBmaXggZXJyb3IgYmVsb3dcbiAgICAgICAgICAgIG5ldyBCaWdJbnQ2NEFycmF5KG1hc2tTaXplLnJlZHVjZSgoYSwgYikgPT4gYSAqIGIpKS5maWxsKDFuKSxcbiAgICAgICAgICAgIG1hc2tTaXplXG4gICAgICAgICk7XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge251bWJlcltdfSBhcnIgVGhlIFVSTChzKSBvZiB0aGUgaW1hZ2UocykgdG8gZXh0cmFjdCBmZWF0dXJlcyBmcm9tLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJbXX0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGNvbmNhdGVuYXRlZCBwaXhlbCB2YWx1ZXMgb2YgdGhlIHByZXByb2Nlc3NlZCBpbWFnZXMuXG4gICAgICovXG4gICAgY2VudGVyX3RvX2Nvcm5lcnNfZm9ybWF0KFtjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0XSkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgY2VudGVyWCAtIHdpZHRoIC8gMixcbiAgICAgICAgICAgIGNlbnRlclkgLSBoZWlnaHQgLyAyLFxuICAgICAgICAgICAgY2VudGVyWCArIHdpZHRoIC8gMixcbiAgICAgICAgICAgIGNlbnRlclkgKyBoZWlnaHQgLyAyXG4gICAgICAgIF07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUG9zdC1wcm9jZXNzZXMgdGhlIG91dHB1dHMgb2YgdGhlIG1vZGVsIChmb3Igb2JqZWN0IGRldGVjdGlvbikuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG91dHB1dHMgVGhlIG91dHB1dHMgb2YgdGhlIG1vZGVsIHRoYXQgbXVzdCBiZSBwb3N0LXByb2Nlc3NlZFxuICAgICAqIEBwYXJhbSB7VGVuc29yfSBvdXRwdXRzLmxvZ2l0cyBUaGUgbG9naXRzXG4gICAgICogQHBhcmFtIHtUZW5zb3J9IG91dHB1dHMucHJlZF9ib3hlcyBUaGUgcHJlZGljdGVkIGJveGVzLlxuICAgICAqIEByZXR1cm4ge09iamVjdFtdfSBBbiBhcnJheSBvZiBvYmplY3RzIGNvbnRhaW5pbmcgdGhlIHBvc3QtcHJvY2Vzc2VkIG91dHB1dHMuXG4gICAgICovXG4gICAgcG9zdF9wcm9jZXNzX29iamVjdF9kZXRlY3Rpb24ob3V0cHV0cywgdGhyZXNob2xkID0gMC41LCB0YXJnZXRfc2l6ZXMgPSBudWxsKSB7XG4gICAgICAgIGNvbnN0IG91dF9sb2dpdHMgPSBvdXRwdXRzLmxvZ2l0cztcbiAgICAgICAgY29uc3Qgb3V0X2Jib3ggPSBvdXRwdXRzLnByZWRfYm94ZXM7XG4gICAgICAgIGNvbnN0IFtiYXRjaF9zaXplLCBudW1fYm94ZXMsIG51bV9jbGFzc2VzXSA9IG91dF9sb2dpdHMuZGltcztcblxuICAgICAgICBpZiAodGFyZ2V0X3NpemVzICE9PSBudWxsICYmIHRhcmdldF9zaXplcy5sZW5ndGggIT09IGJhdGNoX3NpemUpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKFwiTWFrZSBzdXJlIHRoYXQgeW91IHBhc3MgaW4gYXMgbWFueSB0YXJnZXQgc2l6ZXMgYXMgdGhlIGJhdGNoIGRpbWVuc2lvbiBvZiB0aGUgbG9naXRzXCIpXG4gICAgICAgIH1cbiAgICAgICAgbGV0IHRvUmV0dXJuID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmF0Y2hfc2l6ZTsgKytpKSB7XG4gICAgICAgICAgICBsZXQgdGFyZ2V0X3NpemUgPSB0YXJnZXRfc2l6ZXMgIT09IG51bGwgPyB0YXJnZXRfc2l6ZXNbaV0gOiBudWxsO1xuICAgICAgICAgICAgbGV0IGluZm8gPSB7XG4gICAgICAgICAgICAgICAgYm94ZXM6IFtdLFxuICAgICAgICAgICAgICAgIGNsYXNzZXM6IFtdLFxuICAgICAgICAgICAgICAgIHNjb3JlczogW11cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBsb2dpdHMgPSBvdXRfbG9naXRzW2ldO1xuICAgICAgICAgICAgbGV0IGJib3ggPSBvdXRfYmJveFtpXTtcblxuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBudW1fYm94ZXM7ICsraikge1xuICAgICAgICAgICAgICAgIGxldCBsb2dpdCA9IGxvZ2l0c1tqXTtcblxuICAgICAgICAgICAgICAgIC8vIEdldCBtb3N0IHByb2JhYmxlIGNsYXNzXG4gICAgICAgICAgICAgICAgbGV0IG1heEluZGV4ID0gbWF4KGxvZ2l0LmRhdGEpWzFdO1xuXG4gICAgICAgICAgICAgICAgaWYgKG1heEluZGV4ID09PSBudW1fY2xhc3NlcyAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBpcyB0aGUgYmFja2dyb3VuZCBjbGFzcywgc2tpcCBpdFxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBDb21wdXRlIHNvZnRtYXggb3ZlciBjbGFzc2VzXG4gICAgICAgICAgICAgICAgbGV0IHByb2JzID0gc29mdG1heChsb2dpdC5kYXRhKTtcblxuICAgICAgICAgICAgICAgIGxldCBzY29yZSA9IHByb2JzW21heEluZGV4XTtcbiAgICAgICAgICAgICAgICBpZiAoc2NvcmUgPiB0aHJlc2hvbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU29tZSBjbGFzcyBoYXMgYSBoaWdoIGVub3VnaCBwcm9iYWJpbGl0eVxuICAgICAgICAgICAgICAgICAgICAvKiogQHR5cGUge251bWJlcltdfSAqL1xuICAgICAgICAgICAgICAgICAgICBsZXQgYm94ID0gYmJveFtqXS5kYXRhO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnZlcnQgdG8gW3gwLCB5MCwgeDEsIHkxXSBmb3JtYXRcbiAgICAgICAgICAgICAgICAgICAgYm94ID0gdGhpcy5jZW50ZXJfdG9fY29ybmVyc19mb3JtYXQoYm94KVxuICAgICAgICAgICAgICAgICAgICBpZiAodGFyZ2V0X3NpemUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJveCA9IGJveC5tYXAoKHgsIGkpID0+IHggKiB0YXJnZXRfc2l6ZVsoaSArIDEpICUgMl0pXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpbmZvLmJveGVzLnB1c2goYm94KTtcbiAgICAgICAgICAgICAgICAgICAgaW5mby5jbGFzc2VzLnB1c2gobWF4SW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICBpbmZvLnNjb3Jlcy5wdXNoKHNjb3JlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0b1JldHVybi5wdXNoKGluZm8pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b1JldHVybjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBCaW5hcml6ZSB0aGUgZ2l2ZW4gbWFza3MgdXNpbmcgYG9iamVjdF9tYXNrX3RocmVzaG9sZGAsIGl0IHJldHVybnMgdGhlIGFzc29jaWF0ZWQgdmFsdWVzIG9mIGBtYXNrc2AsIGBzY29yZXNgIGFuZCBgbGFiZWxzYC5cbiAgICAgKiBAcGFyYW0ge1RlbnNvcn0gY2xhc3NfbG9naXRzIFRoZSBjbGFzcyBsb2dpdHMuXG4gICAgICogQHBhcmFtIHtUZW5zb3J9IG1hc2tfbG9naXRzIFRoZSBtYXNrIGxvZ2l0cy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb2JqZWN0X21hc2tfdGhyZXNob2xkIEEgbnVtYmVyIGJldHdlZW4gMCBhbmQgMSB1c2VkIHRvIGJpbmFyaXplIHRoZSBtYXNrcy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbnVtX2xhYmVscyBUaGUgbnVtYmVyIG9mIGxhYmVscy5cbiAgICAgKiBAcmV0dXJucyB7W1RlbnNvcltdLCBudW1iZXJbXSwgbnVtYmVyW11dfSBUaGUgYmluYXJpemVkIG1hc2tzLCB0aGUgc2NvcmVzLCBhbmQgdGhlIGxhYmVscy5cbiAgICAgKi9cbiAgICByZW1vdmVfbG93X2FuZF9ub19vYmplY3RzKGNsYXNzX2xvZ2l0cywgbWFza19sb2dpdHMsIG9iamVjdF9tYXNrX3RocmVzaG9sZCwgbnVtX2xhYmVscykge1xuXG4gICAgICAgIGxldCBtYXNrX3Byb2JzX2l0ZW0gPSBbXTtcbiAgICAgICAgbGV0IHByZWRfc2NvcmVzX2l0ZW0gPSBbXTtcbiAgICAgICAgbGV0IHByZWRfbGFiZWxzX2l0ZW0gPSBbXTtcblxuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGNsYXNzX2xvZ2l0cy5kaW1zWzBdOyArK2opIHtcbiAgICAgICAgICAgIGxldCBjbHMgPSBjbGFzc19sb2dpdHNbal07XG4gICAgICAgICAgICBsZXQgbWFzayA9IG1hc2tfbG9naXRzW2pdO1xuXG4gICAgICAgICAgICBsZXQgcHJlZF9sYWJlbCA9IG1heChjbHMuZGF0YSlbMV07XG4gICAgICAgICAgICBpZiAocHJlZF9sYWJlbCA9PT0gbnVtX2xhYmVscykge1xuICAgICAgICAgICAgICAgIC8vIElzIHRoZSBiYWNrZ3JvdW5kLCBzbyB3ZSBpZ25vcmUgaXRcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV0IHNjb3JlcyA9IHNvZnRtYXgoY2xzLmRhdGEpO1xuICAgICAgICAgICAgbGV0IHByZWRfc2NvcmUgPSBzY29yZXNbcHJlZF9sYWJlbF07XG4gICAgICAgICAgICBpZiAocHJlZF9zY29yZSA+IG9iamVjdF9tYXNrX3RocmVzaG9sZCkge1xuICAgICAgICAgICAgICAgIG1hc2tfcHJvYnNfaXRlbS5wdXNoKG1hc2spO1xuICAgICAgICAgICAgICAgIHByZWRfc2NvcmVzX2l0ZW0ucHVzaChwcmVkX3Njb3JlKTtcbiAgICAgICAgICAgICAgICBwcmVkX2xhYmVsc19pdGVtLnB1c2gocHJlZF9sYWJlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gW21hc2tfcHJvYnNfaXRlbSwgcHJlZF9zY29yZXNfaXRlbSwgcHJlZF9sYWJlbHNfaXRlbV07XG5cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgc2VnbWVudCBpcyB2YWxpZCBvciBub3QuXG4gICAgICogQHBhcmFtIHtJbnQzMkFycmF5fSBtYXNrX2xhYmVscyBMYWJlbHMgZm9yIGVhY2ggcGl4ZWwgaW4gdGhlIG1hc2suXG4gICAgICogQHBhcmFtIHtUZW5zb3JbXX0gbWFza19wcm9icyBQcm9iYWJpbGl0aWVzIGZvciBlYWNoIHBpeGVsIGluIHRoZSBtYXNrcy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gayBUaGUgY2xhc3MgaWQgb2YgdGhlIHNlZ21lbnQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1hc2tfdGhyZXNob2xkIFRoZSBtYXNrIHRocmVzaG9sZC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb3ZlcmxhcF9tYXNrX2FyZWFfdGhyZXNob2xkIFRoZSBvdmVybGFwIG1hc2sgYXJlYSB0aHJlc2hvbGQuXG4gICAgICogQHJldHVybnMge1tib29sZWFuLCBudW1iZXJbXV19IFdoZXRoZXIgdGhlIHNlZ21lbnQgaXMgdmFsaWQgb3Igbm90LCBhbmQgdGhlIGluZGljZXMgb2YgdGhlIHZhbGlkIGxhYmVscy5cbiAgICAgKi9cbiAgICBjaGVja19zZWdtZW50X3ZhbGlkaXR5KFxuICAgICAgICBtYXNrX2xhYmVscyxcbiAgICAgICAgbWFza19wcm9icyxcbiAgICAgICAgayxcbiAgICAgICAgbWFza190aHJlc2hvbGQgPSAwLjUsXG4gICAgICAgIG92ZXJsYXBfbWFza19hcmVhX3RocmVzaG9sZCA9IDAuOFxuICAgICkge1xuICAgICAgICAvLyBtYXNrX2sgaXMgYSAxRCBhcnJheSBvZiBpbmRpY2VzLCBpbmRpY2F0aW5nIHdoZXJlIHRoZSBtYXNrIGlzIGVxdWFsIHRvIGtcbiAgICAgICAgbGV0IG1hc2tfayA9IFtdO1xuICAgICAgICBsZXQgbWFza19rX2FyZWEgPSAwO1xuICAgICAgICBsZXQgb3JpZ2luYWxfYXJlYSA9IDA7XG5cbiAgICAgICAgLy8gQ29tcHV0ZSB0aGUgYXJlYSBvZiBhbGwgdGhlIHN0dWZmIGluIHF1ZXJ5IGtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXNrX2xhYmVscy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgaWYgKG1hc2tfbGFiZWxzW2ldID09PSBrKSB7XG4gICAgICAgICAgICAgICAgbWFza19rLnB1c2goaSk7XG4gICAgICAgICAgICAgICAgKyttYXNrX2tfYXJlYTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG1hc2tfcHJvYnNba10uZGF0YVtpXSA+PSBtYXNrX3RocmVzaG9sZCkge1xuICAgICAgICAgICAgICAgICsrb3JpZ2luYWxfYXJlYTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgbWFza19leGlzdHMgPSBtYXNrX2tfYXJlYSA+IDAgJiYgb3JpZ2luYWxfYXJlYSA+IDA7XG5cbiAgICAgICAgLy8gRWxpbWluYXRlIGRpc2Nvbm5lY3RlZCB0aW55IHNlZ21lbnRzXG4gICAgICAgIGlmIChtYXNrX2V4aXN0cykge1xuICAgICAgICAgICAgLy8gUGVyZm9ybSBhZGRpdGlvbmFsIGNoZWNrXG4gICAgICAgICAgICBsZXQgYXJlYV9yYXRpbyA9IG1hc2tfa19hcmVhIC8gb3JpZ2luYWxfYXJlYTtcbiAgICAgICAgICAgIG1hc2tfZXhpc3RzID0gYXJlYV9yYXRpbyA+IG92ZXJsYXBfbWFza19hcmVhX3RocmVzaG9sZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBbbWFza19leGlzdHMsIG1hc2tfa11cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyB0aGUgc2VnbWVudHMuXG4gICAgICogQHBhcmFtIHtUZW5zb3JbXX0gbWFza19wcm9icyBUaGUgbWFzayBwcm9iYWJpbGl0aWVzLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyW119IHByZWRfc2NvcmVzIFRoZSBwcmVkaWN0ZWQgc2NvcmVzLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyW119IHByZWRfbGFiZWxzIFRoZSBwcmVkaWN0ZWQgbGFiZWxzLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtYXNrX3RocmVzaG9sZCBUaGUgbWFzayB0aHJlc2hvbGQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG92ZXJsYXBfbWFza19hcmVhX3RocmVzaG9sZCBUaGUgb3ZlcmxhcCBtYXNrIGFyZWEgdGhyZXNob2xkLlxuICAgICAqIEBwYXJhbSB7U2V0PG51bWJlcj59IGxhYmVsX2lkc190b19mdXNlIFRoZSBsYWJlbCBpZHMgdG8gZnVzZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcltdfSB0YXJnZXRfc2l6ZSBUaGUgdGFyZ2V0IHNpemUgb2YgdGhlIGltYWdlLlxuICAgICAqIEByZXR1cm5zIHtbVGVuc29yLCBBcnJheTx7aWQ6IG51bWJlciwgbGFiZWxfaWQ6IG51bWJlciwgc2NvcmU6IG51bWJlcn0+XX0gVGhlIGNvbXB1dGVkIHNlZ21lbnRzLlxuICAgICAqL1xuICAgIGNvbXB1dGVfc2VnbWVudHMoXG4gICAgICAgIG1hc2tfcHJvYnMsXG4gICAgICAgIHByZWRfc2NvcmVzLFxuICAgICAgICBwcmVkX2xhYmVscyxcbiAgICAgICAgbWFza190aHJlc2hvbGQsXG4gICAgICAgIG92ZXJsYXBfbWFza19hcmVhX3RocmVzaG9sZCxcbiAgICAgICAgbGFiZWxfaWRzX3RvX2Z1c2UgPSBudWxsLFxuICAgICAgICB0YXJnZXRfc2l6ZSA9IG51bGwsXG4gICAgKSB7XG4gICAgICAgIGxldCBbaGVpZ2h0LCB3aWR0aF0gPSB0YXJnZXRfc2l6ZSA/PyBtYXNrX3Byb2JzWzBdLmRpbXM7XG5cbiAgICAgICAgbGV0IHNlZ21lbnRhdGlvbiA9IG5ldyBUZW5zb3IoXG4gICAgICAgICAgICAnaW50MzInLFxuICAgICAgICAgICAgbmV3IEludDMyQXJyYXkoaGVpZ2h0ICogd2lkdGgpLFxuICAgICAgICAgICAgW2hlaWdodCwgd2lkdGhdXG4gICAgICAgICk7XG4gICAgICAgIGxldCBzZWdtZW50cyA9IFtdO1xuXG4gICAgICAgIC8vIDEuIElmIHRhcmdldF9zaXplIGlzIG5vdCBudWxsLCB3ZSBuZWVkIHRvIHJlc2l6ZSB0aGUgbWFza3MgdG8gdGhlIHRhcmdldCBzaXplXG4gICAgICAgIGlmICh0YXJnZXRfc2l6ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gcmVzaXplIHRoZSBtYXNrcyB0byB0aGUgdGFyZ2V0IHNpemVcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWFza19wcm9icy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIG1hc2tfcHJvYnNbaV0gPSBpbnRlcnBvbGF0ZShtYXNrX3Byb2JzW2ldLCB0YXJnZXRfc2l6ZSwgJ2JpbGluZWFyJywgZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gMi4gV2VpZ2ggZWFjaCBtYXNrIGJ5IGl0cyBwcmVkaWN0aW9uIHNjb3JlXG4gICAgICAgIC8vIE5PVEU6IGBtYXNrX3Byb2JzYCBpcyB1cGRhdGVkIGluLXBsYWNlXG4gICAgICAgIC8vIFxuICAgICAgICAvLyBUZW1wb3Jhcnkgc3RvcmFnZSBmb3IgdGhlIGJlc3QgbGFiZWwvc2NvcmVzIGZvciBlYWNoIHBpeGVsIChbaGVpZ2h0LCB3aWR0aF0pOlxuICAgICAgICBsZXQgbWFza19sYWJlbHMgPSBuZXcgSW50MzJBcnJheShtYXNrX3Byb2JzWzBdLmRhdGEubGVuZ3RoKTtcbiAgICAgICAgbGV0IGJlc3RTY29yZXMgPSBuZXcgRmxvYXQzMkFycmF5KG1hc2tfcHJvYnNbMF0uZGF0YS5sZW5ndGgpO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWFza19wcm9icy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgbGV0IHNjb3JlID0gcHJlZF9zY29yZXNbaV07XG5cbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbWFza19wcm9ic1tpXS5kYXRhLmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgICAgICAgbWFza19wcm9ic1tpXS5kYXRhW2pdICo9IHNjb3JlXG4gICAgICAgICAgICAgICAgaWYgKG1hc2tfcHJvYnNbaV0uZGF0YVtqXSA+IGJlc3RTY29yZXNbal0pIHtcbiAgICAgICAgICAgICAgICAgICAgbWFza19sYWJlbHNbal0gPSBpO1xuICAgICAgICAgICAgICAgICAgICBiZXN0U2NvcmVzW2pdID0gbWFza19wcm9ic1tpXS5kYXRhW2pdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBjdXJyZW50X3NlZ21lbnRfaWQgPSAwO1xuXG4gICAgICAgIC8vIGxldCBzdHVmZl9tZW1vcnlfbGlzdCA9IHt9XG4gICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgcHJlZF9sYWJlbHMubGVuZ3RoOyArK2spIHtcbiAgICAgICAgICAgIGxldCBwcmVkX2NsYXNzID0gcHJlZF9sYWJlbHNba107XG5cbiAgICAgICAgICAgIC8vIFRPRE8gYWRkIGBzaG91bGRfZnVzZWBcbiAgICAgICAgICAgIC8vIGxldCBzaG91bGRfZnVzZSA9IHByZWRfY2xhc3MgaW4gbGFiZWxfaWRzX3RvX2Z1c2VcblxuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgbWFzayBleGlzdHMgYW5kIGxhcmdlIGVub3VnaCB0byBiZSBhIHNlZ21lbnRcbiAgICAgICAgICAgIGxldCBbbWFza19leGlzdHMsIG1hc2tfa10gPSB0aGlzLmNoZWNrX3NlZ21lbnRfdmFsaWRpdHkoXG4gICAgICAgICAgICAgICAgbWFza19sYWJlbHMsXG4gICAgICAgICAgICAgICAgbWFza19wcm9icyxcbiAgICAgICAgICAgICAgICBrLFxuICAgICAgICAgICAgICAgIG1hc2tfdGhyZXNob2xkLFxuICAgICAgICAgICAgICAgIG92ZXJsYXBfbWFza19hcmVhX3RocmVzaG9sZFxuICAgICAgICAgICAgKVxuXG4gICAgICAgICAgICBpZiAoIW1hc2tfZXhpc3RzKSB7XG4gICAgICAgICAgICAgICAgLy8gTm90aGluZyB0byBzZWUgaGVyZVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBUT0RPXG4gICAgICAgICAgICAvLyBpZiAocHJlZF9jbGFzcyBpbiBzdHVmZl9tZW1vcnlfbGlzdCkge1xuICAgICAgICAgICAgLy8gICAgIGN1cnJlbnRfc2VnbWVudF9pZCA9IHN0dWZmX21lbW9yeV9saXN0W3ByZWRfY2xhc3NdXG4gICAgICAgICAgICAvLyB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gICAgIGN1cnJlbnRfc2VnbWVudF9pZCArPSAxO1xuICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgKytjdXJyZW50X3NlZ21lbnRfaWQ7XG5cblxuICAgICAgICAgICAgLy8gQWRkIGN1cnJlbnQgb2JqZWN0IHNlZ21lbnQgdG8gZmluYWwgc2VnbWVudGF0aW9uIG1hcFxuICAgICAgICAgICAgZm9yIChsZXQgaW5kZXggb2YgbWFza19rKSB7XG4gICAgICAgICAgICAgICAgc2VnbWVudGF0aW9uLmRhdGFbaW5kZXhdID0gY3VycmVudF9zZWdtZW50X2lkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzZWdtZW50cy5wdXNoKHtcbiAgICAgICAgICAgICAgICBpZDogY3VycmVudF9zZWdtZW50X2lkLFxuICAgICAgICAgICAgICAgIGxhYmVsX2lkOiBwcmVkX2NsYXNzLFxuICAgICAgICAgICAgICAgIC8vIHdhc19mdXNlZDogc2hvdWxkX2Z1c2UsIFRPRE9cbiAgICAgICAgICAgICAgICBzY29yZTogcHJlZF9zY29yZXNba10sXG4gICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICAvLyBUT0RPXG4gICAgICAgICAgICAvLyBpZihzaG91bGRfZnVzZSl7XG4gICAgICAgICAgICAvLyAgICAgc3R1ZmZfbWVtb3J5X2xpc3RbcHJlZF9jbGFzc10gPSBjdXJyZW50X3NlZ21lbnRfaWRcbiAgICAgICAgICAgIC8vIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBbc2VnbWVudGF0aW9uLCBzZWdtZW50c107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUG9zdC1wcm9jZXNzIHRoZSBtb2RlbCBvdXRwdXQgdG8gZ2VuZXJhdGUgdGhlIGZpbmFsIHBhbm9wdGljIHNlZ21lbnRhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IG91dHB1dHMgVGhlIG1vZGVsIG91dHB1dCB0byBwb3N0IHByb2Nlc3NcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3RocmVzaG9sZD0wLjVdIFRoZSBwcm9iYWJpbGl0eSBzY29yZSB0aHJlc2hvbGQgdG8ga2VlcCBwcmVkaWN0ZWQgaW5zdGFuY2UgbWFza3MuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFttYXNrX3RocmVzaG9sZD0wLjVdIFRocmVzaG9sZCB0byB1c2Ugd2hlbiB0dXJuaW5nIHRoZSBwcmVkaWN0ZWQgbWFza3MgaW50byBiaW5hcnkgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3ZlcmxhcF9tYXNrX2FyZWFfdGhyZXNob2xkPTAuOF0gVGhlIG92ZXJsYXAgbWFzayBhcmVhIHRocmVzaG9sZCB0byBtZXJnZSBvciBkaXNjYXJkIHNtYWxsIGRpc2Nvbm5lY3RlZCBwYXJ0cyB3aXRoaW4gZWFjaCBiaW5hcnkgaW5zdGFuY2UgbWFzay5cbiAgICAgKiBAcGFyYW0ge1NldDxudW1iZXI+fSBbbGFiZWxfaWRzX3RvX2Z1c2U9bnVsbF0gVGhlIGxhYmVscyBpbiB0aGlzIHN0YXRlIHdpbGwgaGF2ZSBhbGwgdGhlaXIgaW5zdGFuY2VzIGJlIGZ1c2VkIHRvZ2V0aGVyLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyW11bXX0gW3RhcmdldF9zaXplcz1udWxsXSBUaGUgdGFyZ2V0IHNpemVzIHRvIHJlc2l6ZSB0aGUgbWFza3MgdG8uXG4gICAgICogQHJldHVybnMge0FycmF5PHsgc2VnbWVudGF0aW9uOiBUZW5zb3IsIHNlZ21lbnRzX2luZm86IEFycmF5PHtpZDogbnVtYmVyLCBsYWJlbF9pZDogbnVtYmVyLCBzY29yZTogbnVtYmVyfT59Pn1cbiAgICAgKi9cbiAgICBwb3N0X3Byb2Nlc3NfcGFub3B0aWNfc2VnbWVudGF0aW9uKFxuICAgICAgICBvdXRwdXRzLFxuICAgICAgICB0aHJlc2hvbGQgPSAwLjUsXG4gICAgICAgIG1hc2tfdGhyZXNob2xkID0gMC41LFxuICAgICAgICBvdmVybGFwX21hc2tfYXJlYV90aHJlc2hvbGQgPSAwLjgsXG4gICAgICAgIGxhYmVsX2lkc190b19mdXNlID0gbnVsbCxcbiAgICAgICAgdGFyZ2V0X3NpemVzID0gbnVsbCxcbiAgICApIHtcbiAgICAgICAgaWYgKGxhYmVsX2lkc190b19mdXNlID09PSBudWxsKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJgbGFiZWxfaWRzX3RvX2Z1c2VgIHVuc2V0LiBObyBpbnN0YW5jZSB3aWxsIGJlIGZ1c2VkLlwiKVxuICAgICAgICAgICAgbGFiZWxfaWRzX3RvX2Z1c2UgPSBuZXcgU2V0KCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjbGFzc19xdWVyaWVzX2xvZ2l0cyA9IG91dHB1dHMubG9naXRzOyAvLyBbYmF0Y2hfc2l6ZSwgbnVtX3F1ZXJpZXMsIG51bV9jbGFzc2VzKzFdXG4gICAgICAgIGNvbnN0IG1hc2tzX3F1ZXJpZXNfbG9naXRzID0gb3V0cHV0cy5wcmVkX21hc2tzOyAvLyBbYmF0Y2hfc2l6ZSwgbnVtX3F1ZXJpZXMsIGhlaWdodCwgd2lkdGhdXG5cbiAgICAgICAgY29uc3QgbWFza19wcm9icyA9IG1hc2tzX3F1ZXJpZXNfbG9naXRzLnNpZ21vaWQoKSAgLy8gW2JhdGNoX3NpemUsIG51bV9xdWVyaWVzLCBoZWlnaHQsIHdpZHRoXVxuXG4gICAgICAgIGxldCBbYmF0Y2hfc2l6ZSwgbnVtX3F1ZXJpZXMsIG51bV9sYWJlbHNdID0gY2xhc3NfcXVlcmllc19sb2dpdHMuZGltcztcbiAgICAgICAgbnVtX2xhYmVscyAtPSAxOyAvLyBSZW1vdmUgbGFzdCBjbGFzcyAoYmFja2dyb3VuZClcblxuICAgICAgICBpZiAodGFyZ2V0X3NpemVzICE9PSBudWxsICYmIHRhcmdldF9zaXplcy5sZW5ndGggIT09IGJhdGNoX3NpemUpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKFwiTWFrZSBzdXJlIHRoYXQgeW91IHBhc3MgaW4gYXMgbWFueSB0YXJnZXQgc2l6ZXMgYXMgdGhlIGJhdGNoIGRpbWVuc2lvbiBvZiB0aGUgbG9naXRzXCIpXG4gICAgICAgIH1cblxuICAgICAgICBsZXQgdG9SZXR1cm4gPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBiYXRjaF9zaXplOyArK2kpIHtcbiAgICAgICAgICAgIGxldCB0YXJnZXRfc2l6ZSA9IHRhcmdldF9zaXplcyAhPT0gbnVsbCA/IHRhcmdldF9zaXplc1tpXSA6IG51bGw7XG5cbiAgICAgICAgICAgIGxldCBjbGFzc19sb2dpdHMgPSBjbGFzc19xdWVyaWVzX2xvZ2l0c1tpXTtcbiAgICAgICAgICAgIGxldCBtYXNrX2xvZ2l0cyA9IG1hc2tfcHJvYnNbaV07XG5cbiAgICAgICAgICAgIGxldCBbbWFza19wcm9ic19pdGVtLCBwcmVkX3Njb3Jlc19pdGVtLCBwcmVkX2xhYmVsc19pdGVtXSA9IHRoaXMucmVtb3ZlX2xvd19hbmRfbm9fb2JqZWN0cyhjbGFzc19sb2dpdHMsIG1hc2tfbG9naXRzLCB0aHJlc2hvbGQsIG51bV9sYWJlbHMpO1xuXG4gICAgICAgICAgICBpZiAocHJlZF9sYWJlbHNfaXRlbS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAvLyBObyBtYXNrIGZvdW5kXG4gICAgICAgICAgICAgICAgbGV0IFtoZWlnaHQsIHdpZHRoXSA9IHRhcmdldF9zaXplID8/IG1hc2tfbG9naXRzLmRpbXMuc2xpY2UoLTIpO1xuXG4gICAgICAgICAgICAgICAgbGV0IHNlZ21lbnRhdGlvbiA9IG5ldyBUZW5zb3IoXG4gICAgICAgICAgICAgICAgICAgICdpbnQzMicsXG4gICAgICAgICAgICAgICAgICAgIG5ldyBJbnQzMkFycmF5KGhlaWdodCAqIHdpZHRoKS5maWxsKC0xKSxcbiAgICAgICAgICAgICAgICAgICAgW2hlaWdodCwgd2lkdGhdXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIHRvUmV0dXJuLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBzZWdtZW50YXRpb246IHNlZ21lbnRhdGlvbixcbiAgICAgICAgICAgICAgICAgICAgc2VnbWVudHNfaW5mbzogW11cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuXG4gICAgICAgICAgICAvLyBHZXQgc2VnbWVudGF0aW9uIG1hcCBhbmQgc2VnbWVudCBpbmZvcm1hdGlvbiBvZiBiYXRjaCBpdGVtXG4gICAgICAgICAgICBsZXQgW3NlZ21lbnRhdGlvbiwgc2VnbWVudHNdID0gdGhpcy5jb21wdXRlX3NlZ21lbnRzKFxuICAgICAgICAgICAgICAgIG1hc2tfcHJvYnNfaXRlbSxcbiAgICAgICAgICAgICAgICBwcmVkX3Njb3Jlc19pdGVtLFxuICAgICAgICAgICAgICAgIHByZWRfbGFiZWxzX2l0ZW0sXG4gICAgICAgICAgICAgICAgbWFza190aHJlc2hvbGQsXG4gICAgICAgICAgICAgICAgb3ZlcmxhcF9tYXNrX2FyZWFfdGhyZXNob2xkLFxuICAgICAgICAgICAgICAgIGxhYmVsX2lkc190b19mdXNlLFxuICAgICAgICAgICAgICAgIHRhcmdldF9zaXplLFxuICAgICAgICAgICAgKVxuXG4gICAgICAgICAgICB0b1JldHVybi5wdXNoKHtcbiAgICAgICAgICAgICAgICBzZWdtZW50YXRpb246IHNlZ21lbnRhdGlvbixcbiAgICAgICAgICAgICAgICBzZWdtZW50c19pbmZvOiBzZWdtZW50c1xuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0b1JldHVybjtcbiAgICB9XG5cbiAgICBwb3N0X3Byb2Nlc3NfaW5zdGFuY2Vfc2VnbWVudGF0aW9uKCkge1xuICAgICAgICAvLyBUT0RPXG4gICAgICAgIHRocm93IEVycm9yKFwiTm90IGltcGxlbWVudGVkIHlldFwiKTtcbiAgICB9XG59XG5cbmV4cG9ydCBjbGFzcyBTYW1JbWFnZVByb2Nlc3NvciBleHRlbmRzIEltYWdlRmVhdHVyZUV4dHJhY3RvciB7XG4gICAgYXN5bmMgX2NhbGwoaW1hZ2VzLCBpbnB1dF9wb2ludHMpIHtcbiAgICAgICAgbGV0IHtcbiAgICAgICAgICAgIHBpeGVsX3ZhbHVlcyxcbiAgICAgICAgICAgIG9yaWdpbmFsX3NpemVzLFxuICAgICAgICAgICAgcmVzaGFwZWRfaW5wdXRfc2l6ZXMsXG4gICAgICAgIH0gPSBhd2FpdCBzdXBlci5fY2FsbChpbWFnZXMpO1xuXG4gICAgICAgIGxldCBzaGFwZSA9IGNhbGN1bGF0ZURpbWVuc2lvbnMoaW5wdXRfcG9pbnRzKTtcblxuICAgICAgICBpZiAoc2hhcGUubGVuZ3RoID09PSAzKSB7XG4gICAgICAgICAgICAvLyBDb3JyZWN0IHVzZXIncyBpbnB1dFxuICAgICAgICAgICAgc2hhcGUgPSBbMSwgLi4uc2hhcGVdO1xuICAgICAgICAgICAgaW5wdXRfcG9pbnRzID0gW2lucHV0X3BvaW50c107XG4gICAgICAgIH0gZWxzZSBpZiAoc2hhcGUubGVuZ3RoICE9PSA0KSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcIlRoZSBpbnB1dF9wb2ludHMgbXVzdCBiZSBhIDREIHRlbnNvciBvZiBzaGFwZSBgYmF0Y2hfc2l6ZWAsIGBwb2ludF9iYXRjaF9zaXplYCwgYG5iX3BvaW50c19wZXJfaW1hZ2VgLCBgMmAuXCIpXG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZXNoYXBlIGlucHV0IHBvaW50c1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0X3BvaW50cy5sZW5ndGg7ICsraSkgeyAvLyBiYXRjaF9zaXplXG4gICAgICAgICAgICBsZXQgb3JpZ2luYWxJbWFnZVNpemUgPSBvcmlnaW5hbF9zaXplc1tpXTtcbiAgICAgICAgICAgIGxldCByZXNoYXBlZEltYWdlU2l6ZSA9IHJlc2hhcGVkX2lucHV0X3NpemVzW2ldO1xuXG4gICAgICAgICAgICBsZXQgcmVzaXplRmFjdG9ycyA9IFtcbiAgICAgICAgICAgICAgICByZXNoYXBlZEltYWdlU2l6ZVswXSAvIG9yaWdpbmFsSW1hZ2VTaXplWzBdLFxuICAgICAgICAgICAgICAgIHJlc2hhcGVkSW1hZ2VTaXplWzFdIC8gb3JpZ2luYWxJbWFnZVNpemVbMV1cbiAgICAgICAgICAgIF1cblxuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBpbnB1dF9wb2ludHNbaV0ubGVuZ3RoOyArK2opIHsgLy8gcG9pbnRfYmF0Y2hfc2l6ZVxuICAgICAgICAgICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgaW5wdXRfcG9pbnRzW2ldW2pdLmxlbmd0aDsgKytrKSB7IC8vIG5iX3BvaW50c19wZXJfaW1hZ2VcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgdyA9IDA7IHcgPCBpbnB1dF9wb2ludHNbaV1bal1ba10ubGVuZ3RoOyArK3cpIHsgLy8gMlxuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXRfcG9pbnRzW2ldW2pdW2tdW3ddICo9IHJlc2l6ZUZhY3RvcnNbd107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgaW5wdXRfcG9pbnRzX3RlbnNvciA9IG5ldyBUZW5zb3IoXG4gICAgICAgICAgICAnaW50NjQnLFxuICAgICAgICAgICAgQmlnSW50NjRBcnJheS5mcm9tKGlucHV0X3BvaW50cy5mbGF0KEluZmluaXR5KVxuICAgICAgICAgICAgICAgIC5tYXAoeCA9PiBCaWdJbnQoTWF0aC5yb3VuZCh4KSkpKSxcbiAgICAgICAgICAgIHNoYXBlXG4gICAgICAgIClcblxuICAgICAgICAvLyBUT0RPOiBhbGxvd2VkIHRvIGJlIGZsb2F0cz9cbiAgICAgICAgLy8gbGV0IGlucHV0X3BvaW50c190ZW5zb3IgPSBuZXcgVGVuc29yKFxuICAgICAgICAvLyAgICAgJ2Zsb2F0MzInLFxuICAgICAgICAvLyAgICAgRmxvYXQzMkFycmF5LmZyb20oaW5wdXRfcG9pbnRzLmZsYXQoSW5maW5pdHkpKSxcbiAgICAgICAgLy8gICAgIHNoYXBlXG4gICAgICAgIC8vIClcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcGl4ZWxfdmFsdWVzLFxuICAgICAgICAgICAgb3JpZ2luYWxfc2l6ZXM6IG9yaWdpbmFsX3NpemVzLFxuICAgICAgICAgICAgcmVzaGFwZWRfaW5wdXRfc2l6ZXM6IHJlc2hhcGVkX2lucHV0X3NpemVzLFxuICAgICAgICAgICAgaW5wdXRfcG9pbnRzOiBpbnB1dF9wb2ludHNfdGVuc29yXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgcGFkZGluZyBhbmQgdXBzY2FsZSBtYXNrcyB0byB0aGUgb3JpZ2luYWwgaW1hZ2Ugc2l6ZS5cbiAgICAgKiBAcGFyYW0ge1RlbnNvcn0gbWFza3MgQmF0Y2hlZCBtYXNrcyBmcm9tIHRoZSBtYXNrX2RlY29kZXIgaW4gKGJhdGNoX3NpemUsIG51bV9jaGFubmVscywgaGVpZ2h0LCB3aWR0aCkgZm9ybWF0LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyW11bXX0gb3JpZ2luYWxfc2l6ZXMgVGhlIG9yaWdpbmFsIHNpemVzIG9mIGVhY2ggaW1hZ2UgYmVmb3JlIGl0IHdhcyByZXNpemVkIHRvIHRoZSBtb2RlbCdzIGV4cGVjdGVkIGlucHV0IHNoYXBlLCBpbiAoaGVpZ2h0LCB3aWR0aCkgZm9ybWF0LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyW11bXX0gcmVzaGFwZWRfaW5wdXRfc2l6ZXMgVGhlIHNpemUgb2YgZWFjaCBpbWFnZSBhcyBpdCBpcyBmZWQgdG8gdGhlIG1vZGVsLCBpbiAoaGVpZ2h0LCB3aWR0aCkgZm9ybWF0LiBVc2VkIHRvIHJlbW92ZSBwYWRkaW5nLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIE9wdGlvbmFsIHBhcmFtZXRlcnMgZm9yIHBvc3QtcHJvY2Vzc2luZy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMubWFza190aHJlc2hvbGRdIFRoZSB0aHJlc2hvbGQgdG8gdXNlIGZvciBiaW5hcml6aW5nIHRoZSBtYXNrcy5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmJpbmFyaXplXSBXaGV0aGVyIHRvIGJpbmFyaXplIHRoZSBtYXNrcy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMucGFkX3NpemVdIFRoZSB0YXJnZXQgc2l6ZSB0aGUgaW1hZ2VzIHdlcmUgcGFkZGVkIHRvIGJlZm9yZSBiZWluZyBwYXNzZWQgdG8gdGhlIG1vZGVsLiBJZiBgbnVsbGAsIHRoZSB0YXJnZXQgc2l6ZSBpcyBhc3N1bWVkIHRvIGJlIHRoZSBwcm9jZXNzb3IncyBgcGFkX3NpemVgLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5wYWRfc2l6ZS5oZWlnaHRdIFRoZSBoZWlnaHQgdGhlIGltYWdlcyB3ZXJlIHBhZGRlZCB0by5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMucGFkX3NpemUud2lkdGhdIFRoZSB3aWR0aCB0aGUgaW1hZ2VzIHdlcmUgcGFkZGVkIHRvLlxuICAgICAqIEByZXR1cm5zIHtUZW5zb3JbXX0gQmF0Y2hlZCBtYXNrcyBpbiBiYXRjaF9zaXplLCBudW1fY2hhbm5lbHMsIGhlaWdodCwgd2lkdGgpIGZvcm1hdCwgd2hlcmUgKGhlaWdodCwgd2lkdGgpIGlzIGdpdmVuIGJ5IG9yaWdpbmFsX3NpemUuXG4gICAgICovXG4gICAgcG9zdF9wcm9jZXNzX21hc2tzKG1hc2tzLCBvcmlnaW5hbF9zaXplcywgcmVzaGFwZWRfaW5wdXRfc2l6ZXMsIHtcbiAgICAgICAgbWFza190aHJlc2hvbGQgPSAwLjAsXG4gICAgICAgIGJpbmFyaXplID0gdHJ1ZSxcbiAgICAgICAgcGFkX3NpemUgPSBudWxsLFxuICAgIH0gPSB7fSkge1xuICAgICAgICAvLyBtYXNrczogWzEsIDEsIDMsIDI1NiwgMjU2XVxuXG4gICAgICAgIGxldCBvdXRwdXRfbWFza3MgPSBbXTtcblxuICAgICAgICBwYWRfc2l6ZSA9IHBhZF9zaXplID8/IHRoaXMucGFkX3NpemU7XG5cbiAgICAgICAgbGV0IHRhcmdldF9pbWFnZV9zaXplID0gW3BhZF9zaXplLmhlaWdodCwgcGFkX3NpemUud2lkdGhdO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3JpZ2luYWxfc2l6ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGxldCBvcmlnaW5hbF9zaXplID0gb3JpZ2luYWxfc2l6ZXNbaV07XG4gICAgICAgICAgICBsZXQgcmVzaGFwZWRfaW5wdXRfc2l6ZSA9IHJlc2hhcGVkX2lucHV0X3NpemVzW2ldO1xuXG4gICAgICAgICAgICBsZXQgbWFzayA9IG1hc2tzW2ldOyAvLyBbYiwgYywgaCwgd11cblxuICAgICAgICAgICAgLy8gVE9ETzogaW1wcm92ZVxuICAgICAgICAgICAgbGV0IGludGVycG9sYXRlZF9tYXNrcyA9IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBtYXNrLmRpbXNbMF07ICsraikge1xuICAgICAgICAgICAgICAgIGxldCBtID0gbWFza1tqXTsgLy8gM2QgdGVuc29yXG5cbiAgICAgICAgICAgICAgICAvLyBVcHNjYWxlIG1hc2sgdG8gcGFkZGVkIHNpemVcbiAgICAgICAgICAgICAgICBsZXQgaW50ZXJwb2xhdGVkX21hc2sgPSBpbnRlcnBvbGF0ZShtLCB0YXJnZXRfaW1hZ2Vfc2l6ZSwgJ2JpbGluZWFyJywgZmFsc2UpO1xuXG4gICAgICAgICAgICAgICAgLy8gQ3JvcCBtYXNrXG4gICAgICAgICAgICAgICAgaW50ZXJwb2xhdGVkX21hc2sgPSBpbnRlcnBvbGF0ZWRfbWFzay5zbGljZShudWxsLCBbMCwgcmVzaGFwZWRfaW5wdXRfc2l6ZVswXV0sIFswLCByZXNoYXBlZF9pbnB1dF9zaXplWzFdXSk7XG5cbiAgICAgICAgICAgICAgICAvLyBEb3duc2NhbGUgbWFza1xuICAgICAgICAgICAgICAgIGludGVycG9sYXRlZF9tYXNrID0gaW50ZXJwb2xhdGUobWFzaywgb3JpZ2luYWxfc2l6ZSwgJ2JpbGluZWFyJywgZmFsc2UpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGJpbmFyaXplKSB7XG4gICAgICAgICAgICAgICAgICAgIGludGVycG9sYXRlZF9tYXNrID0gbmV3IFRlbnNvcihcbiAgICAgICAgICAgICAgICAgICAgICAgICdib29sJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIEFycmF5LmZyb20oaW50ZXJwb2xhdGVkX21hc2suZGF0YSkubWFwKHggPT4geCA+IG1hc2tfdGhyZXNob2xkKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGludGVycG9sYXRlZF9tYXNrLmRpbXNcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGFkZCBiYWNrIGJhdGNoIGRpbSBmb3IgY29uY2F0XG4gICAgICAgICAgICAgICAgaW50ZXJwb2xhdGVkX21hc2suZGltcyA9IFsxLCAuLi5pbnRlcnBvbGF0ZWRfbWFzay5kaW1zXTtcblxuICAgICAgICAgICAgICAgIGludGVycG9sYXRlZF9tYXNrcy5wdXNoKGludGVycG9sYXRlZF9tYXNrKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV0IGNvbmNhdGVuYXRlZCA9IGNhdChpbnRlcnBvbGF0ZWRfbWFza3MpO1xuICAgICAgICAgICAgb3V0cHV0X21hc2tzLnB1c2goY29uY2F0ZW5hdGVkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvdXRwdXRfbWFza3M7XG5cbiAgICB9XG59XG5cblxuZXhwb3J0IGNsYXNzIFdoaXNwZXJGZWF0dXJlRXh0cmFjdG9yIGV4dGVuZHMgRmVhdHVyZUV4dHJhY3RvciB7XG5cbiAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICAgICAgc3VwZXIoY29uZmlnKTtcblxuICAgICAgICAvLyBQcmVmZXIgZ2l2ZW4gYG1lbF9maWx0ZXJzYCBmcm9tIHByZXByb2Nlc3Nvcl9jb25maWcuanNvbiwgb3IgY2FsY3VsYXRlIHRoZW0gaWYgdGhleSBkb24ndCBleGlzdC5cbiAgICAgICAgdGhpcy5jb25maWcubWVsX2ZpbHRlcnMgPz89IGdldE1lbEZpbHRlcnModGhpcy5jb25maWcuc2FtcGxpbmdfcmF0ZSwgdGhpcy5jb25maWcubl9mZnQsIHRoaXMuY29uZmlnLmZlYXR1cmVfc2l6ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZXMgdGhlIGluZGV4IG9mZnNldCBmb3IgYSBnaXZlbiBpbmRleCBhbmQgd2luZG93IHNpemUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGkgVGhlIGluZGV4LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3IFRoZSB3aW5kb3cgc2l6ZS5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgaW5kZXggb2Zmc2V0LlxuICAgICAqL1xuICAgIGNhbGNPZmZzZXQoaSwgdykge1xuICAgICAgICByZXR1cm4gTWF0aC5hYnMoKGkgKyB3KSAlICgyICogdykgLSB3KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYWRzIGFuIGFycmF5IHdpdGggYSByZWZsZWN0ZWQgdmVyc2lvbiBvZiBpdHNlbGYgb24gYm90aCBlbmRzLlxuICAgICAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcGFkLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsZWZ0IFRoZSBhbW91bnQgb2YgcGFkZGluZyB0byBhZGQgdG8gdGhlIGxlZnQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJpZ2h0IFRoZSBhbW91bnQgb2YgcGFkZGluZyB0byBhZGQgdG8gdGhlIHJpZ2h0LlxuICAgICAqIEByZXR1cm5zIHtGbG9hdDMyQXJyYXl9IFRoZSBwYWRkZWQgYXJyYXkuXG4gICAgICovXG4gICAgcGFkUmVmbGVjdChhcnJheSwgbGVmdCwgcmlnaHQpIHtcbiAgICAgICAgY29uc3QgcGFkZGVkID0gbmV3IEZsb2F0MzJBcnJheShhcnJheS5sZW5ndGggKyBsZWZ0ICsgcmlnaHQpO1xuICAgICAgICBjb25zdCB3ID0gYXJyYXkubGVuZ3RoIC0gMTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBwYWRkZWRbbGVmdCArIGldID0gYXJyYXlbaV07XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8PSBsZWZ0OyArK2kpIHtcbiAgICAgICAgICAgIHBhZGRlZFtsZWZ0IC0gaV0gPSBhcnJheVt0aGlzLmNhbGNPZmZzZXQoaSwgdyldO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPD0gcmlnaHQ7ICsraSkge1xuICAgICAgICAgICAgcGFkZGVkW3cgKyBsZWZ0ICsgaV0gPSBhcnJheVt0aGlzLmNhbGNPZmZzZXQodyAtIGksIHcpXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwYWRkZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlcyB0aGUgY29tcGxleCBTaG9ydC1UaW1lIEZvdXJpZXIgVHJhbnNmb3JtIChTVEZUKSBvZiB0aGUgZ2l2ZW4gZnJhbWVkIHNpZ25hbC5cbiAgICAgKiBcbiAgICAgKiBAcGFyYW0ge251bWJlcltdW119IGZyYW1lcyBBIDJEIGFycmF5IHJlcHJlc2VudGluZyB0aGUgc2lnbmFsIGZyYW1lcy5cbiAgICAgKiBAcGFyYW0ge251bWJlcltdfSB3aW5kb3cgQSAxRCBhcnJheSByZXByZXNlbnRpbmcgdGhlIHdpbmRvdyB0byBiZSBhcHBsaWVkIHRvIHRoZSBmcmFtZXMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gQW4gb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICAgICAqIC0gZGF0YTogQSAxRCBhcnJheSByZXByZXNlbnRpbmcgdGhlIGNvbXBsZXggU1RGVCBvZiB0aGUgc2lnbmFsLlxuICAgICAqIC0gZGltczogQW4gYXJyYXkgcmVwcmVzZW50aW5nIHRoZSBkaW1lbnNpb25zIG9mIHRoZSBTVEZUIGRhdGEsIGkuZS4gW251bV9mcmFtZXMsIG51bV9mZnRfYmluc10uXG4gICAgICovXG4gICAgc3RmdChmcmFtZXMsIHdpbmRvdykge1xuICAgICAgICAvLyBDYWxjdWxhdGVzIHRoZSBjb21wbGV4IFNob3J0LVRpbWUgRm91cmllciBUcmFuc2Zvcm0gKFNURlQpIG9mIHRoZSBnaXZlbiBmcmFtZWQgc2lnbmFsLlxuICAgICAgICAvLyBcbiAgICAgICAgLy8gTk9URTogU2luY2UgdGhlIHdpbmRvdyB3aWR0aCBpcyBub3QgYSBwb3dlciBvZiAyLCB3ZSBtdXN0IFxuICAgICAgICAvLyBwZXJmb3JtIEZhc3QgRm91cmllciBUcmFuc2Zvcm0gd2l0aCBjaGlycC16IHRyYW5zZm9ybTpcbiAgICAgICAgLy8gaHR0cHM6Ly9tYXRoLnN0YWNrZXhjaGFuZ2UuY29tL3F1ZXN0aW9ucy83NzExOC9ub24tcG93ZXItb2YtMi1mZnRzLzc3MTU2Izc3MTU2XG5cbiAgICAgICAgLy8gSGVscGVyIHZhcmlhYmxlc1xuICAgICAgICBjb25zdCBmZnRfc2l6ZSA9IHRoaXMuY29uZmlnLm5fZmZ0O1xuICAgICAgICBjb25zdCBhID0gMiAqIChmZnRfc2l6ZSAtIDEpO1xuICAgICAgICBjb25zdCBiID0gMiAqICgyICogZmZ0X3NpemUgLSAxKTtcbiAgICAgICAgY29uc3QgbmV4dFAyID0gMiAqKiAoTWF0aC5jZWlsKE1hdGgubG9nMihiKSkpXG4gICAgICAgIGNvbnN0IG51bV9mZnRfYmlucyA9IGZmdF9zaXplICsgMjtcblxuICAgICAgICAvLyBQcmVhbGxvY2F0ZSBhcnJheSB0byBzdG9yZSBvdXRwdXRcbiAgICAgICAgLy8gZG91YmxlIHNpbmNlIHdlIHN0b3JlIGNvbXBsZXggbnVtYmVyc1xuICAgICAgICBjb25zdCBkYXRhID0gbmV3IEZsb2F0MzJBcnJheShudW1fZmZ0X2JpbnMgKiBmcmFtZXMubGVuZ3RoKTtcblxuICAgICAgICAvLyBEZWZpbmUgYnVmZmVyc1xuICAgICAgICAvLyBDb21wdXRlIGNoaXJwIGZvciB0cmFuc2Zvcm1cbiAgICAgICAgY29uc3QgY2hpcnAgPSBuZXcgRmxvYXQzMkFycmF5KGIpO1xuICAgICAgICBjb25zdCBpY2hpcnAgPSBuZXcgRmxvYXQzMkFycmF5KG5leHRQMik7XG4gICAgICAgIGNvbnN0IGJ1ZmZlcjEgPSBuZXcgRmxvYXQzMkFycmF5KG5leHRQMik7XG4gICAgICAgIGNvbnN0IGJ1ZmZlcjIgPSBuZXcgRmxvYXQzMkFycmF5KG5leHRQMik7XG4gICAgICAgIGNvbnN0IG91dEJ1ZmZlciA9IG5ldyBGbG9hdDMyQXJyYXkobmV4dFAyKTtcbiAgICAgICAgY29uc3Qgb3V0QnVmZmVyMiA9IG5ldyBGbG9hdDMyQXJyYXkobmV4dFAyKTtcbiAgICAgICAgY29uc3Qgb3V0QnVmZmVyMyA9IG5ldyBGbG9hdDMyQXJyYXkobmV4dFAyKTtcblxuICAgICAgICAvLyBDb21wdXRlIGNvbXBsZXggZXhwb25lbnRpYXRpb25cbiAgICAgICAgY29uc3QgdGhldGEgPSAtMiAqIE1hdGguUEkgLyBmZnRfc2l6ZTtcbiAgICAgICAgY29uc3QgYmFzZVIgPSBNYXRoLmNvcyh0aGV0YSk7XG4gICAgICAgIGNvbnN0IGJhc2VJID0gTWF0aC5zaW4odGhldGEpO1xuXG4gICAgICAgIC8vIFByZWNvbXB1dGUgaGVscGVyIGZvciBjaGlycC16IHRyYW5zZm9ybVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGIgPj4gMTsgKytpKSB7XG4gICAgICAgICAgICAvLyBDb21wdXRlIGNvbXBsZXggcG93ZXI6XG4gICAgICAgICAgICBjb25zdCBlID0gKGkgKyAxIC0gZmZ0X3NpemUpICoqIDIgLyAyLjA7XG5cbiAgICAgICAgICAgIC8vIENvbXB1dGUgdGhlIG1vZHVsdXMgYW5kIGFyZ3VtZW50IG9mIHRoZSByZXN1bHRcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdF9tb2QgPSBNYXRoLnNxcnQoYmFzZVIgKiogMiArIGJhc2VJICoqIDIpICoqIGU7XG4gICAgICAgICAgICBjb25zdCByZXN1bHRfYXJnID0gZSAqIE1hdGguYXRhbjIoYmFzZUksIGJhc2VSKTtcblxuICAgICAgICAgICAgLy8gQ29udmVydCB0aGUgcmVzdWx0IGJhY2sgdG8gcmVjdGFuZ3VsYXIgZm9ybVxuICAgICAgICAgICAgLy8gYW5kIGFzc2lnbiB0byBjaGlycCBhbmQgaWNoaXJwXG4gICAgICAgICAgICBsZXQgaTIgPSAyICogaTtcbiAgICAgICAgICAgIGNoaXJwW2kyXSA9IHJlc3VsdF9tb2QgKiBNYXRoLmNvcyhyZXN1bHRfYXJnKTtcbiAgICAgICAgICAgIGNoaXJwW2kyICsgMV0gPSByZXN1bHRfbW9kICogTWF0aC5zaW4ocmVzdWx0X2FyZyk7XG5cbiAgICAgICAgICAgIC8vIGNvbmp1Z2F0ZVxuICAgICAgICAgICAgaWNoaXJwW2kyXSA9IGNoaXJwW2kyXTtcbiAgICAgICAgICAgIGljaGlycFtpMiArIDFdID0gLSBjaGlycFtpMiArIDFdO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNsaWNlZENoaXJwID0gY2hpcnAuc3ViYXJyYXkoYSwgYik7XG5cbiAgICAgICAgLy8gY3JlYXRlIG9iamVjdCB0byBwZXJmb3JtIEZhc3QgRm91cmllciBUcmFuc2Zvcm1zXG4gICAgICAgIC8vIHdpdGggYG5leHRQMmAgY29tcGxleCBudW1iZXJzXG4gICAgICAgIGNvbnN0IGYgPSBuZXcgRkZUKG5leHRQMiA+PiAxKTtcbiAgICAgICAgLy8gVE9ETzogZGVjaWRlIGJldHdlZW4gRmxvYXQzMkFycmF5IGFuZCBGbG9hdDY0QXJyYXlcbiAgICAgICAgZi50cmFuc2Zvcm0ob3V0QnVmZmVyLCBpY2hpcnApO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZnJhbWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCBmcmFtZSA9IGZyYW1lc1tpXTtcblxuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBzbGljZWRDaGlycC5sZW5ndGg7IGogKz0gMikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGoyID0gaiArIDFcbiAgICAgICAgICAgICAgICBjb25zdCBqMyA9IGogPj4gMTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IGFfcmVhbCA9IGZyYW1lW2ozXSAqIHdpbmRvd1tqM107XG4gICAgICAgICAgICAgICAgYnVmZmVyMVtqXSA9IGFfcmVhbCAqIHNsaWNlZENoaXJwW2pdO1xuICAgICAgICAgICAgICAgIGJ1ZmZlcjFbajJdID0gYV9yZWFsICogc2xpY2VkQ2hpcnBbajJdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVE9ETzogZGVjaWRlIGJldHdlZW4gRmxvYXQzMkFycmF5IGFuZCBGbG9hdDY0QXJyYXlcbiAgICAgICAgICAgIGYudHJhbnNmb3JtKG91dEJ1ZmZlcjIsIGJ1ZmZlcjEpO1xuXG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG91dEJ1ZmZlci5sZW5ndGg7IGogKz0gMikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGoyID0gaiArIDE7XG5cbiAgICAgICAgICAgICAgICBidWZmZXIyW2pdID0gb3V0QnVmZmVyMltqXSAqIG91dEJ1ZmZlcltqXSAtIG91dEJ1ZmZlcjJbajJdICogb3V0QnVmZmVyW2oyXVxuICAgICAgICAgICAgICAgIGJ1ZmZlcjJbajJdID0gb3V0QnVmZmVyMltqXSAqIG91dEJ1ZmZlcltqMl0gKyBvdXRCdWZmZXIyW2oyXSAqIG91dEJ1ZmZlcltqXVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVE9ETzogZGVjaWRlIGJldHdlZW4gRmxvYXQzMkFycmF5IGFuZCBGbG9hdDY0QXJyYXlcbiAgICAgICAgICAgIGYuaW52ZXJzZVRyYW5zZm9ybShvdXRCdWZmZXIzLCBidWZmZXIyKVxuXG4gICAgICAgICAgICBjb25zdCBvZmZzZXQgPSBpICogbnVtX2ZmdF9iaW5zO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBudW1fZmZ0X2JpbnM7IGogKz0gMikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFfcmVhbCA9IG91dEJ1ZmZlcjNbaiArIGFdO1xuICAgICAgICAgICAgICAgIGNvbnN0IGFfaW1hZyA9IG91dEJ1ZmZlcjNbaiArIGEgKyAxXTtcbiAgICAgICAgICAgICAgICBjb25zdCBiX3JlYWwgPSBzbGljZWRDaGlycFtqXTtcbiAgICAgICAgICAgICAgICBjb25zdCBiX2ltYWcgPSBzbGljZWRDaGlycFtqICsgMV07XG5cbiAgICAgICAgICAgICAgICAvLyBUT0RPIHdyaXRlIGFzIHRyYW5zcG9zZVxuICAgICAgICAgICAgICAgIGNvbnN0IG8xID0gb2Zmc2V0ICsgajtcbiAgICAgICAgICAgICAgICBkYXRhW28xXSA9IGFfcmVhbCAqIGJfcmVhbCAtIGFfaW1hZyAqIGJfaW1hZ1xuICAgICAgICAgICAgICAgIGRhdGFbbzEgKyAxXSA9IGFfcmVhbCAqIGJfaW1hZyArIGFfaW1hZyAqIGJfcmVhbFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgICAgICBkaW1zOiBbZnJhbWVzLmxlbmd0aCwgbnVtX2ZmdF9iaW5zXSAvLyBbMzAwMSwgNDAyXVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgZnJhbWVzIGZyb20gYSBnaXZlbiB3YXZlZm9ybS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fSB3YXZlZm9ybSBUaGUgd2F2ZWZvcm0gdG8gY3JlYXRlIGZyYW1lcyBmcm9tLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2NlbnRlcj10cnVlXSBXaGV0aGVyIHRvIGNlbnRlciB0aGUgZnJhbWVzIG9uIHRoZWlyIGNvcnJlc3BvbmRpbmcgcG9zaXRpb25zIGluIHRoZSB3YXZlZm9ybS4gRGVmYXVsdHMgdG8gdHJ1ZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IEFuIGFycmF5IG9mIGZyYW1lcy5cbiAgICAgKi9cbiAgICBmcmFtX3dhdmUod2F2ZWZvcm0sIGNlbnRlciA9IHRydWUpIHtcbiAgICAgICAgY29uc3QgZnJhbWVzID0gW107XG4gICAgICAgIGNvbnN0IGhhbGZfd2luZG93ID0gTWF0aC5mbG9vcigodGhpcy5jb25maWcubl9mZnQgLSAxKSAvIDIpICsgMTtcbiAgICAgICAgY29uc3Qgd2F2ZWZvcm1MZW5ndGggPSB3YXZlZm9ybS5sZW5ndGg7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB3YXZlZm9ybUxlbmd0aCArIDE7IGkgKz0gdGhpcy5jb25maWcuaG9wX2xlbmd0aCkge1xuXG4gICAgICAgICAgICBsZXQgZnJhbWU7XG4gICAgICAgICAgICBpZiAoY2VudGVyKSB7XG5cbiAgICAgICAgICAgICAgICBsZXQgZnJhbWVTdGFydCA9IGkgPiBoYWxmX3dpbmRvdyA/IGkgLSBoYWxmX3dpbmRvdyA6IDA7XG4gICAgICAgICAgICAgICAgbGV0IGZyYW1lRW5kID1cbiAgICAgICAgICAgICAgICAgICAgaSA8IHdhdmVmb3JtTGVuZ3RoIC0gaGFsZl93aW5kb3dcbiAgICAgICAgICAgICAgICAgICAgICAgID8gaSArIGhhbGZfd2luZG93XG4gICAgICAgICAgICAgICAgICAgICAgICA6IHdhdmVmb3JtTGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgZnJhbWUgPSB3YXZlZm9ybS5zdWJhcnJheShmcmFtZVN0YXJ0LCBmcmFtZUVuZClcblxuICAgICAgICAgICAgICAgIGlmIChmcmFtZVN0YXJ0ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGZyYW1lID0gdGhpcy5wYWRSZWZsZWN0KFxuICAgICAgICAgICAgICAgICAgICAgICAgZnJhbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAtaSArIGhhbGZfd2luZG93LFxuICAgICAgICAgICAgICAgICAgICAgICAgMFxuICAgICAgICAgICAgICAgICAgICApXG5cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGZyYW1lRW5kID09PSB3YXZlZm9ybUxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBmcmFtZSA9IHRoaXMucGFkUmVmbGVjdChcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGkgLSB3YXZlZm9ybUxlbmd0aCArIGhhbGZfd2luZG93XG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZnJhbWUgPSBuZXcgRmxvYXQzMkFycmF5KHRoaXMuY29uZmlnLm5fZmZ0KTtcbiAgICAgICAgICAgICAgICBjb25zdCBmcmFtZUFycmF5ID0gd2F2ZWZvcm0uc3ViYXJyYXkoaSwgaSArIHRoaXMuY29uZmlnLm5fZmZ0KTtcblxuICAgICAgICAgICAgICAgIGlmIChmcmFtZUFycmF5Lmxlbmd0aCA8IHRoaXMuY29uZmlnLm5fZmZ0KSB7XG4gICAgICAgICAgICAgICAgICAgIGZyYW1lLnNldChmcmFtZUFycmF5KTtcbiAgICAgICAgICAgICAgICAgICAgZnJhbWUuZmlsbCgwLCBmcmFtZUFycmF5Lmxlbmd0aCwgdGhpcy5jb25maWcubl9mZnQpXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZnJhbWUgPSBmcmFtZUFycmF5O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnJhbWVzLnB1c2goZnJhbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZyYW1lcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgYSBIYW5uaW5nIHdpbmRvdyBvZiBsZW5ndGggTS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBNIFRoZSBsZW5ndGggb2YgdGhlIEhhbm5pbmcgd2luZG93IHRvIGdlbmVyYXRlLlxuICAgICAqIEByZXR1cm5zIHsqfSBUaGUgZ2VuZXJhdGVkIEhhbm5pbmcgd2luZG93LlxuICAgICAqL1xuICAgIGhhbm5pbmcoTSkge1xuICAgICAgICBpZiAoTSA8IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoTSA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIFsxXTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkZW5vbSA9IE0gLSAxO1xuICAgICAgICBjb25zdCBjb3NfdmFscyA9IG5ldyBGbG9hdDMyQXJyYXkoZGVub20pO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRlbm9tOyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IG4gPSAyICogaSAtIE0gKyAxO1xuICAgICAgICAgICAgY29zX3ZhbHNbaV0gPSAwLjUgKyAwLjUgKiBNYXRoLmNvcyhNYXRoLlBJICogbiAvIGRlbm9tKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29zX3ZhbHM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgdGhlIGxvZy1NZWwgc3BlY3Ryb2dyYW0gb2YgdGhlIHByb3ZpZGVkIGF1ZGlvIHdhdmVmb3JtLlxuICAgICAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fEZsb2F0NjRBcnJheX0gd2F2ZWZvcm0gVGhlIGF1ZGlvIHdhdmVmb3JtIHRvIHByb2Nlc3MuXG4gICAgICogQHJldHVybnMge3tkYXRhOiBGbG9hdDMyQXJyYXksIGRpbXM6IG51bWJlcltdfX0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGxvZy1NZWwgc3BlY3Ryb2dyYW0gZGF0YSBhcyBhIEZsb2F0MzJBcnJheSBhbmQgaXRzIGRpbWVuc2lvbnMgYXMgYW4gYXJyYXkgb2YgbnVtYmVycy5cbiAgICAgKi9cbiAgICBfZXh0cmFjdF9mYmFua19mZWF0dXJlcyh3YXZlZm9ybSkge1xuICAgICAgICAvLyBDb21wdXRlIHRoZSBsb2ctTWVsIHNwZWN0cm9ncmFtIG9mIHRoZSBwcm92aWRlZCBhdWRpb1xuXG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IG5ldyBGbG9hdDMyQXJyYXkodGhpcy5jb25maWcubl9zYW1wbGVzKTtcbiAgICAgICAgYnVmZmVyLnNldCh3YXZlZm9ybSlcblxuICAgICAgICBjb25zdCB3aW5kb3cgPSB0aGlzLmhhbm5pbmcodGhpcy5jb25maWcubl9mZnQgKyAxKVxuICAgICAgICBjb25zdCBmcmFtZXMgPSB0aGlzLmZyYW1fd2F2ZShidWZmZXIpXG5cbiAgICAgICAgY29uc3Qgc3RmdCA9IHRoaXMuc3RmdChmcmFtZXMsIHdpbmRvdylcblxuICAgICAgICBjb25zdCBzdGZ0RGF0YSA9IHN0ZnQuZGF0YTtcbiAgICAgICAgY29uc3QgZDEgPSBzdGZ0LmRpbXNbMF0gLSAxOyAvLyBJZ25vcmUgbGFzdCByb3dcbiAgICAgICAgY29uc3QgZDIgPSBzdGZ0LmRpbXNbMV0gPj4gMTsgLy8gT25seSBuZWVkIHRvIHN0b3JlIHJlYWwgbnVtYmVycyBub3dcblxuICAgICAgICAvLyBjb21wdXRlIG1hZ25pdHVkZXNcbiAgICAgICAgLy8gTk9URTogVW5saWtlIHRoZSBvcmlnaW5hbCBpbXBsZW1lbnRhdGlvbiwgd2UgZG8gbm90XG4gICAgICAgIC8vIHRyYW5zcG9zZSBzaW5jZSB3ZSBwZXJmb3JtIG1hdHJpeCBtdWx0aXBsaWNhdGlvbiBsYXRlclxuICAgICAgICBjb25zdCBtYWduaXR1ZGVzID0gbmV3IEZsb2F0MzJBcnJheShkMSAqIGQyKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkMTsgKytpKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGQyOyArK2opIHtcbiAgICAgICAgICAgICAgICAvLyBsZXQgb3V0T2Zmc2V0ID0gKGogKiBkMSArIGkpOyAvLyB0cmFuc3Bvc2VcbiAgICAgICAgICAgICAgICBsZXQgb3V0T2Zmc2V0ID0gaSAqIGQyICsgajtcbiAgICAgICAgICAgICAgICBsZXQgaW5PZmZzZXQgPSBvdXRPZmZzZXQgPDwgMTsgLy8gKiAyIHNpbmNlIGNvbXBsZXhcbiAgICAgICAgICAgICAgICBsZXQgbWFnbml0dWRlID0gc3RmdERhdGFbaW5PZmZzZXRdICoqIDIgKyBzdGZ0RGF0YVtpbk9mZnNldCArIDFdICoqIDJcbiAgICAgICAgICAgICAgICBtYWduaXR1ZGVzW291dE9mZnNldF0gPSBtYWduaXR1ZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBtZWxfZmlsdGVycyA9IHRoaXMuY29uZmlnLm1lbF9maWx0ZXJzO1xuICAgICAgICBjb25zdCBudW1fbWVsX2ZpbHRlcnMgPSBtZWxfZmlsdGVycy5sZW5ndGg7XG5cbiAgICAgICAgY29uc3QgbWVsX3NwZWMgPSBuZXcgRmxvYXQzMkFycmF5KG51bV9tZWxfZmlsdGVycyAqIGQxKTtcbiAgICAgICAgbGV0IG1JbmRleCA9IDA7XG5cbiAgICAgICAgLy8gUGVyZm9ybSBtYXRyaXggbXVsaXBsaWNhdGlvbjpcbiAgICAgICAgLy8gbWVsX3NwZWMgPSBmaWx0ZXJzIEAgbWFnbml0dWRlc1xuICAgICAgICAvLyAgLSBmaWx0ZXJzLnNoYXBlPSg4MCwgMjAxKVxuICAgICAgICAvLyAgLSBtYWduaXR1ZGVzLnNoYXBlPSgyMDEsIDMwMDApXG4gICAgICAgIC8vICAtIG1lbF9zcGVjLnNoYXBlPSg4MCwgMzAwMClcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1fbWVsX2ZpbHRlcnM7ICsraSkge1xuICAgICAgICAgICAgY29uc3QgbWVsX2ZpbHRlciA9IG1lbF9maWx0ZXJzW2ldO1xuXG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGQxOyArK2opIHtcbiAgICAgICAgICAgICAgICBsZXQgc3VtID0gMDtcblxuICAgICAgICAgICAgICAgIC8vIHBlcmZvcm0gZG90IHByb2R1Y3RcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IGQyOyArK2spIHtcbiAgICAgICAgICAgICAgICAgICAgc3VtICs9IG1lbF9maWx0ZXJba10gKiBtYWduaXR1ZGVzW2ogKiBkMiArIGtdO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG1lbF9zcGVjW21JbmRleCsrXSA9IHN1bTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGFfbWluID0gMWUtMTA7XG4gICAgICAgIGNvbnN0IGxvZ19zcGVjID0gbmV3IEZsb2F0MzJBcnJheShtZWxfc3BlYy5sZW5ndGgpO1xuXG4gICAgICAgIGxldCBtYXhMb2dTcGVjID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtZWxfc3BlYy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgY29uc3QgY2xpcHBlZCA9IE1hdGgubWF4KGFfbWluLCBtZWxfc3BlY1tpXSk7XG4gICAgICAgICAgICBjb25zdCBsb2cxMCA9IE1hdGgubG9nMTAoY2xpcHBlZCk7XG4gICAgICAgICAgICBsb2dfc3BlY1tpXSA9IGxvZzEwO1xuICAgICAgICAgICAgbWF4TG9nU3BlYyA9IE1hdGgubWF4KGxvZzEwLCBtYXhMb2dTcGVjKVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsb2dfc3BlYy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgbG9nX3NwZWNbaV0gPSBNYXRoLm1heChsb2dfc3BlY1tpXSwgbWF4TG9nU3BlYyAtIDgpO1xuICAgICAgICAgICAgbG9nX3NwZWNbaV0gPSAobG9nX3NwZWNbaV0gKyA0KSAvIDQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGF0YTogbG9nX3NwZWMsXG4gICAgICAgICAgICBkaW1zOiBbbnVtX21lbF9maWx0ZXJzLCBkMV1cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBc3luY2hyb25vdXNseSBleHRyYWN0cyBmZWF0dXJlcyBmcm9tIGEgZ2l2ZW4gYXVkaW8gdXNpbmcgdGhlIHByb3ZpZGVkIGNvbmZpZ3VyYXRpb24uXG4gICAgICogQHBhcmFtIHtGbG9hdDMyQXJyYXl8RmxvYXQ2NEFycmF5fSBhdWRpbyBUaGUgYXVkaW8gZGF0YSBhcyBhIEZsb2F0MzJBcnJheS5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTx7IGlucHV0X2ZlYXR1cmVzOiBUZW5zb3IgfT59IEEgUHJvbWlzZSByZXNvbHZpbmcgdG8gYW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGV4dHJhY3RlZCBpbnB1dCBmZWF0dXJlcyBhcyBhIFRlbnNvci5cbiAgICAqL1xuICAgIGFzeW5jIF9jYWxsKGF1ZGlvKSB7XG4gICAgICAgIGlmICghKGF1ZGlvIGluc3RhbmNlb2YgRmxvYXQzMkFycmF5IHx8IGF1ZGlvIGluc3RhbmNlb2YgRmxvYXQ2NEFycmF5KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICBgV2hpc3BlckZlYXR1cmVFeHRyYWN0b3IgZXhwZWN0cyBpbnB1dCB0byBiZSBhIEZsb2F0MzJBcnJheSBvciBhIEZsb2F0NjRBcnJheSwgYnV0IGdvdCAke2F1ZGlvPy5jb25zdHJ1Y3Rvcj8ubmFtZSA/PyB0eXBlb2YgYXVkaW99IGluc3RlYWQuYCArXG4gICAgICAgICAgICAgICAgYElmIHVzaW5nIHRoZSBmZWF0dXJlIGV4dHJhY3RvciBkaXJlY3RseSwgcmVtZW1iZXIgdG8gdXNlIFxcYHJlYWRfYXVkaW8odXJsLCBzYW1wbGluZ19yYXRlKVxcYCB0byBvYnRhaW4gdGhlIHJhdyBhdWRpbyBkYXRhIG9mIHRoZSBmaWxlL3VybC5gXG4gICAgICAgICAgICApXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYXVkaW8ubGVuZ3RoID4gdGhpcy5jb25maWcubl9zYW1wbGVzKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAgICAgXCJBdHRlbXB0aW5nIHRvIGV4dHJhY3QgZmVhdHVyZXMgZm9yIGF1ZGlvIGxvbmdlciB0aGFuIDMwIHNlY29uZHMuIFwiICtcbiAgICAgICAgICAgICAgICBcIklmIHVzaW5nIGEgcGlwZWxpbmUgdG8gZXh0cmFjdCB0cmFuc2NyaXB0IGZyb20gYSBsb25nIGF1ZGlvIGNsaXAsIFwiICtcbiAgICAgICAgICAgICAgICBcInJlbWVtYmVyIHRvIHNwZWNpZnkgYGNodW5rX2xlbmd0aF9zYCBhbmQvb3IgYHN0cmlkZV9sZW5ndGhfc2AuXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHdhdmVmb3JtID0gYXVkaW8uc2xpY2UoMCwgdGhpcy5jb25maWcubl9zYW1wbGVzKTtcblxuICAgICAgICBsZXQgZmVhdHVyZXMgPSB0aGlzLl9leHRyYWN0X2ZiYW5rX2ZlYXR1cmVzKHdhdmVmb3JtKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaW5wdXRfZmVhdHVyZXM6IG5ldyBUZW5zb3IoJ2Zsb2F0MzInLFxuICAgICAgICAgICAgICAgIGZlYXR1cmVzLmRhdGEsXG4gICAgICAgICAgICAgICAgWzEsIC4uLmZlYXR1cmVzLmRpbXNdXG4gICAgICAgICAgICApXG4gICAgICAgIH07XG4gICAgfVxufVxuXG4vKipcbiAqIFJlcHJlc2VudHMgYSBQcm9jZXNzb3IgdGhhdCBleHRyYWN0cyBmZWF0dXJlcyBmcm9tIGFuIGlucHV0LlxuICogQGV4dGVuZHMgQ2FsbGFibGVcbiAqL1xuZXhwb3J0IGNsYXNzIFByb2Nlc3NvciBleHRlbmRzIENhbGxhYmxlIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IFByb2Nlc3NvciB3aXRoIHRoZSBnaXZlbiBmZWF0dXJlIGV4dHJhY3Rvci5cbiAgICAgKiBAcGFyYW0ge0ZlYXR1cmVFeHRyYWN0b3J9IGZlYXR1cmVfZXh0cmFjdG9yIFRoZSBmdW5jdGlvbiB1c2VkIHRvIGV4dHJhY3QgZmVhdHVyZXMgZnJvbSB0aGUgaW5wdXQuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZmVhdHVyZV9leHRyYWN0b3IpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5mZWF0dXJlX2V4dHJhY3RvciA9IGZlYXR1cmVfZXh0cmFjdG9yO1xuICAgICAgICAvLyBUT0RPIHVzZSB0b2tlbml6ZXIgaGVyZT9cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxscyB0aGUgZmVhdHVyZV9leHRyYWN0b3IgZnVuY3Rpb24gd2l0aCB0aGUgZ2l2ZW4gaW5wdXQuXG4gICAgICogQHBhcmFtIHthbnl9IGlucHV0IFRoZSBpbnB1dCB0byBleHRyYWN0IGZlYXR1cmVzIGZyb20uXG4gICAgICogQHJldHVybnMge1Byb21pc2U8YW55Pn0gQSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgZXh0cmFjdGVkIGZlYXR1cmVzLlxuICAgICAqL1xuICAgIGFzeW5jIF9jYWxsKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmZlYXR1cmVfZXh0cmFjdG9yKGlucHV0KTtcbiAgICB9XG59XG5cbmV4cG9ydCBjbGFzcyBTYW1Qcm9jZXNzb3IgZXh0ZW5kcyBQcm9jZXNzb3Ige1xuXG4gICAgYXN5bmMgX2NhbGwoaW1hZ2VzLCBpbnB1dF9wb2ludHMpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZmVhdHVyZV9leHRyYWN0b3IoaW1hZ2VzLCBpbnB1dF9wb2ludHMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBib3Jyb3dzIFNhbUltYWdlUHJvY2Vzc29yI3Bvc3RfcHJvY2Vzc19tYXNrcyBhcyBwb3N0X3Byb2Nlc3NfbWFza3NcbiAgICAgKi9cbiAgICBwb3N0X3Byb2Nlc3NfbWFza3MoLi4uYXJncykge1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIHJldHVybiB0aGlzLmZlYXR1cmVfZXh0cmFjdG9yLnBvc3RfcHJvY2Vzc19tYXNrcyguLi5hcmdzKTtcbiAgICB9XG59XG5cbi8qKlxuICogUmVwcmVzZW50cyBhIFdoaXNwZXJQcm9jZXNzb3IgdGhhdCBleHRyYWN0cyBmZWF0dXJlcyBmcm9tIGFuIGF1ZGlvIGlucHV0LlxuICogQGV4dGVuZHMgUHJvY2Vzc29yXG4gKi9cbmV4cG9ydCBjbGFzcyBXaGlzcGVyUHJvY2Vzc29yIGV4dGVuZHMgUHJvY2Vzc29yIHtcbiAgICAvKipcbiAgICAgKiBDYWxscyB0aGUgZmVhdHVyZV9leHRyYWN0b3IgZnVuY3Rpb24gd2l0aCB0aGUgZ2l2ZW4gYXVkaW8gaW5wdXQuXG4gICAgICogQHBhcmFtIHthbnl9IGF1ZGlvIFRoZSBhdWRpbyBpbnB1dCB0byBleHRyYWN0IGZlYXR1cmVzIGZyb20uXG4gICAgICogQHJldHVybnMge1Byb21pc2U8YW55Pn0gQSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgZXh0cmFjdGVkIGZlYXR1cmVzLlxuICAgICAqL1xuICAgIGFzeW5jIF9jYWxsKGF1ZGlvKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmZlYXR1cmVfZXh0cmFjdG9yKGF1ZGlvKVxuICAgIH1cbn1cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8qKlxuICogQHR5cGVkZWYge2ltcG9ydCgnLi91dGlscy9odWIuanMnKS5QcmV0cmFpbmVkT3B0aW9uc30gUHJldHJhaW5lZE9wdGlvbnNcbiAqL1xuLyoqXG4gKiBIZWxwZXIgY2xhc3Mgd2hpY2ggaXMgdXNlZCB0byBpbnN0YW50aWF0ZSBwcmV0cmFpbmVkIHByb2Nlc3NvcnMgd2l0aCB0aGUgYGZyb21fcHJldHJhaW5lZGAgZnVuY3Rpb24uXG4gKiBUaGUgY2hvc2VuIHByb2Nlc3NvciBjbGFzcyBpcyBkZXRlcm1pbmVkIGJ5IHRoZSB0eXBlIHNwZWNpZmllZCBpbiB0aGUgcHJvY2Vzc29yIGNvbmZpZy5cbiAqIFxuICogKipFeGFtcGxlOioqIExvYWQgYSBwcm9jZXNzb3IgdXNpbmcgYGZyb21fcHJldHJhaW5lZGAuXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBsZXQgcHJvY2Vzc29yID0gYXdhaXQgQXV0b1Byb2Nlc3Nvci5mcm9tX3ByZXRyYWluZWQoJ29wZW5haS93aGlzcGVyLXRpbnkuZW4nKTtcbiAqIGBgYFxuICogXG4gKiAqKkV4YW1wbGU6KiogUnVuIGFuIGltYWdlIHRocm91Z2ggYSBwcm9jZXNzb3IuXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBsZXQgcHJvY2Vzc29yID0gYXdhaXQgQXV0b1Byb2Nlc3Nvci5mcm9tX3ByZXRyYWluZWQoJ1hlbm92YS9jbGlwLXZpdC1iYXNlLXBhdGNoMTYnKTtcbiAqIGxldCBpbWFnZSA9IGF3YWl0IFJhd0ltYWdlLnJlYWQoJ2h0dHBzOi8vaHVnZ2luZ2ZhY2UuY28vZGF0YXNldHMvWGVub3ZhL3RyYW5zZm9ybWVycy5qcy1kb2NzL3Jlc29sdmUvbWFpbi9mb290YmFsbC1tYXRjaC5qcGcnKTtcbiAqIGxldCBpbWFnZV9pbnB1dHMgPSBhd2FpdCBwcm9jZXNzb3IoaW1hZ2UpO1xuICogLy8ge1xuICogLy8gICBcInBpeGVsX3ZhbHVlc1wiOiB7XG4gKiAvLyAgICAgXCJkaW1zXCI6IFsgMSwgMywgMjI0LCAyMjQgXSxcbiAqIC8vICAgICBcInR5cGVcIjogXCJmbG9hdDMyXCIsXG4gKiAvLyAgICAgXCJkYXRhXCI6IEZsb2F0MzJBcnJheSBbIC0xLjU1ODY4NzY4NjkyMDE2NiwgLTEuNTU4Njg3Njg2OTIwMTY2LCAtMS41NDQwODkzMTczMjE3NzczLCAuLi4gXSxcbiAqIC8vICAgICBcInNpemVcIjogMTUwNTI4XG4gKiAvLyAgIH0sXG4gKiAvLyAgIFwib3JpZ2luYWxfc2l6ZXNcIjogW1xuICogLy8gICAgIFsgNTMzLCA4MDAgXVxuICogLy8gICBdLFxuICogLy8gICBcInJlc2hhcGVkX2lucHV0X3NpemVzXCI6IFtcbiAqIC8vICAgICBbIDIyNCwgMjI0IF1cbiAqIC8vICAgXVxuICogLy8gfVxuICogYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBBdXRvUHJvY2Vzc29yIHtcbiAgICBzdGF0aWMgRkVBVFVSRV9FWFRSQUNUT1JfQ0xBU1NfTUFQUElORyA9IHtcbiAgICAgICAgJ1doaXNwZXJGZWF0dXJlRXh0cmFjdG9yJzogV2hpc3BlckZlYXR1cmVFeHRyYWN0b3IsXG4gICAgICAgICdWaVRGZWF0dXJlRXh0cmFjdG9yJzogVmlURmVhdHVyZUV4dHJhY3RvcixcbiAgICAgICAgJ01vYmlsZVZpVEZlYXR1cmVFeHRyYWN0b3InOiBNb2JpbGVWaVRGZWF0dXJlRXh0cmFjdG9yLFxuICAgICAgICAnRGV0ckZlYXR1cmVFeHRyYWN0b3InOiBEZXRyRmVhdHVyZUV4dHJhY3RvcixcblxuICAgICAgICAnU2FtSW1hZ2VQcm9jZXNzb3InOiBTYW1JbWFnZVByb2Nlc3NvcixcbiAgICB9XG5cbiAgICBzdGF0aWMgUFJPQ0VTU09SX0NMQVNTX01BUFBJTkcgPSB7XG4gICAgICAgICdXaGlzcGVyUHJvY2Vzc29yJzogV2hpc3BlclByb2Nlc3NvcixcbiAgICAgICAgJ1NhbVByb2Nlc3Nvcic6IFNhbVByb2Nlc3NvcixcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbnN0YW50aWF0ZSBvbmUgb2YgdGhlIHByb2Nlc3NvciBjbGFzc2VzIG9mIHRoZSBsaWJyYXJ5IGZyb20gYSBwcmV0cmFpbmVkIG1vZGVsLlxuICAgICAqIFxuICAgICAqIFRoZSBwcm9jZXNzb3IgY2xhc3MgdG8gaW5zdGFudGlhdGUgaXMgc2VsZWN0ZWQgYmFzZWQgb24gdGhlIGBmZWF0dXJlX2V4dHJhY3Rvcl90eXBlYCBwcm9wZXJ0eSBvZiB0aGUgY29uZmlnIG9iamVjdFxuICAgICAqIChlaXRoZXIgcGFzc2VkIGFzIGFuIGFyZ3VtZW50IG9yIGxvYWRlZCBmcm9tIGBwcmV0cmFpbmVkX21vZGVsX25hbWVfb3JfcGF0aGAgaWYgcG9zc2libGUpXG4gICAgICogXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByZXRyYWluZWRfbW9kZWxfbmFtZV9vcl9wYXRoIFRoZSBuYW1lIG9yIHBhdGggb2YgdGhlIHByZXRyYWluZWQgbW9kZWwuIENhbiBiZSBlaXRoZXI6XG4gICAgICogLSBBIHN0cmluZywgdGhlICptb2RlbCBpZCogb2YgYSBwcmV0cmFpbmVkIHByb2Nlc3NvciBob3N0ZWQgaW5zaWRlIGEgbW9kZWwgcmVwbyBvbiBodWdnaW5nZmFjZS5jby5cbiAgICAgKiAgIFZhbGlkIG1vZGVsIGlkcyBjYW4gYmUgbG9jYXRlZCBhdCB0aGUgcm9vdC1sZXZlbCwgbGlrZSBgYmVydC1iYXNlLXVuY2FzZWRgLCBvciBuYW1lc3BhY2VkIHVuZGVyIGFcbiAgICAgKiAgIHVzZXIgb3Igb3JnYW5pemF0aW9uIG5hbWUsIGxpa2UgYGRibWR6L2JlcnQtYmFzZS1nZXJtYW4tY2FzZWRgLlxuICAgICAqIC0gQSBwYXRoIHRvIGEgKmRpcmVjdG9yeSogY29udGFpbmluZyBwcm9jZXNzb3IgZmlsZXMsIGUuZy4sIGAuL215X21vZGVsX2RpcmVjdG9yeS9gLlxuICAgICAqIEBwYXJhbSB7UHJldHJhaW5lZE9wdGlvbnN9IG9wdGlvbnMgQWRkaXRpb25hbCBvcHRpb25zIGZvciBsb2FkaW5nIHRoZSBwcm9jZXNzb3IuXG4gICAgICogXG4gICAgICogQHJldHVybnMge1Byb21pc2U8UHJvY2Vzc29yPn0gQSBuZXcgaW5zdGFuY2Ugb2YgdGhlIFByb2Nlc3NvciBjbGFzcy5cbiAgICAgKi9cbiAgICBzdGF0aWMgYXN5bmMgZnJvbV9wcmV0cmFpbmVkKHByZXRyYWluZWRfbW9kZWxfbmFtZV9vcl9wYXRoLCB7XG4gICAgICAgIHByb2dyZXNzX2NhbGxiYWNrID0gbnVsbCxcbiAgICAgICAgY29uZmlnID0gbnVsbCxcbiAgICAgICAgY2FjaGVfZGlyID0gbnVsbCxcbiAgICAgICAgbG9jYWxfZmlsZXNfb25seSA9IGZhbHNlLFxuICAgICAgICByZXZpc2lvbiA9ICdtYWluJyxcbiAgICB9ID0ge30pIHtcblxuICAgICAgICBsZXQgcHJlcHJvY2Vzc29yQ29uZmlnID0gY29uZmlnID8/IGF3YWl0IGdldE1vZGVsSlNPTihwcmV0cmFpbmVkX21vZGVsX25hbWVfb3JfcGF0aCwgJ3ByZXByb2Nlc3Nvcl9jb25maWcuanNvbicsIHRydWUsIHtcbiAgICAgICAgICAgIHByb2dyZXNzX2NhbGxiYWNrLFxuICAgICAgICAgICAgY29uZmlnLFxuICAgICAgICAgICAgY2FjaGVfZGlyLFxuICAgICAgICAgICAgbG9jYWxfZmlsZXNfb25seSxcbiAgICAgICAgICAgIHJldmlzaW9uLFxuICAgICAgICB9KVxuXG4gICAgICAgIC8vIERldGVybWluZSBmZWF0dXJlIGV4dHJhY3RvciBjbGFzc1xuICAgICAgICAvLyBUT0RPOiBFbnN1cmUgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgd2l0aCBvbGQgY29uZmlnc1xuICAgICAgICBsZXQga2V5ID0gcHJlcHJvY2Vzc29yQ29uZmlnLmZlYXR1cmVfZXh0cmFjdG9yX3R5cGUgPz8gcHJlcHJvY2Vzc29yQ29uZmlnLmltYWdlX3Byb2Nlc3Nvcl90eXBlO1xuICAgICAgICBsZXQgZmVhdHVyZV9leHRyYWN0b3JfY2xhc3MgPSB0aGlzLkZFQVRVUkVfRVhUUkFDVE9SX0NMQVNTX01BUFBJTkdba2V5XTtcblxuICAgICAgICBpZiAoIWZlYXR1cmVfZXh0cmFjdG9yX2NsYXNzKSB7XG4gICAgICAgICAgICBpZiAocHJlcHJvY2Vzc29yQ29uZmlnLnNpemUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIC8vIEFzc3VtZSBJbWFnZUZlYXR1cmVFeHRyYWN0b3JcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ0ZlYXR1cmUgZXh0cmFjdG9yIHR5cGUgbm90IHNwZWNpZmllZCwgYXNzdW1pbmcgSW1hZ2VGZWF0dXJlRXh0cmFjdG9yIGR1ZSB0byBzaXplIHBhcmFtZXRlciBpbiBjb25maWcuJyk7XG4gICAgICAgICAgICAgICAgZmVhdHVyZV9leHRyYWN0b3JfY2xhc3MgPSBJbWFnZUZlYXR1cmVFeHRyYWN0b3I7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBGZWF0dXJlIEV4dHJhY3RvciB0eXBlOiAke3ByZXByb2Nlc3NvckNvbmZpZy5mZWF0dXJlX2V4dHJhY3Rvcl90eXBlfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgbm8gYXNzb2NpYXRlZCBwcm9jZXNzb3IgY2xhc3MsIHVzZSBkZWZhdWx0XG4gICAgICAgIGxldCBwcm9jZXNzb3JfY2xhc3MgPSB0aGlzLlBST0NFU1NPUl9DTEFTU19NQVBQSU5HW3ByZXByb2Nlc3NvckNvbmZpZy5wcm9jZXNzb3JfY2xhc3NdID8/IFByb2Nlc3NvcjtcblxuICAgICAgICAvLyBJbnN0YW50aWF0ZSBwcm9jZXNzb3IgYW5kIGZlYXR1cmUgZXh0cmFjdG9yXG4gICAgICAgIGxldCBmZWF0dXJlX2V4dHJhY3RvciA9IG5ldyBmZWF0dXJlX2V4dHJhY3Rvcl9jbGFzcyhwcmVwcm9jZXNzb3JDb25maWcpO1xuICAgICAgICByZXR1cm4gbmV3IHByb2Nlc3Nvcl9jbGFzcyhmZWF0dXJlX2V4dHJhY3Rvcik7XG4gICAgfVxufVxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@xenova/transformers/src/processors.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@xenova/transformers/src/tokenizers.js":
/*!*************************************************************!*\
  !*** ./node_modules/@xenova/transformers/src/tokenizers.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AlbertTokenizer: () => (/* binding */ AlbertTokenizer),\n/* harmony export */   AutoTokenizer: () => (/* binding */ AutoTokenizer),\n/* harmony export */   BartTokenizer: () => (/* binding */ BartTokenizer),\n/* harmony export */   BertTokenizer: () => (/* binding */ BertTokenizer),\n/* harmony export */   BloomTokenizer: () => (/* binding */ BloomTokenizer),\n/* harmony export */   CLIPTokenizer: () => (/* binding */ CLIPTokenizer),\n/* harmony export */   CodeGenTokenizer: () => (/* binding */ CodeGenTokenizer),\n/* harmony export */   DistilBertTokenizer: () => (/* binding */ DistilBertTokenizer),\n/* harmony export */   FalconTokenizer: () => (/* binding */ FalconTokenizer),\n/* harmony export */   GPT2Tokenizer: () => (/* binding */ GPT2Tokenizer),\n/* harmony export */   GPTNeoXTokenizer: () => (/* binding */ GPTNeoXTokenizer),\n/* harmony export */   LlamaTokenizer: () => (/* binding */ LlamaTokenizer),\n/* harmony export */   MPNetTokenizer: () => (/* binding */ MPNetTokenizer),\n/* harmony export */   MarianTokenizer: () => (/* binding */ MarianTokenizer),\n/* harmony export */   MobileBertTokenizer: () => (/* binding */ MobileBertTokenizer),\n/* harmony export */   NllbTokenizer: () => (/* binding */ NllbTokenizer),\n/* harmony export */   PreTrainedTokenizer: () => (/* binding */ PreTrainedTokenizer),\n/* harmony export */   RobertaTokenizer: () => (/* binding */ RobertaTokenizer),\n/* harmony export */   SqueezeBertTokenizer: () => (/* binding */ SqueezeBertTokenizer),\n/* harmony export */   T5Tokenizer: () => (/* binding */ T5Tokenizer),\n/* harmony export */   TokenizerModel: () => (/* binding */ TokenizerModel),\n/* harmony export */   WhisperTokenizer: () => (/* binding */ WhisperTokenizer),\n/* harmony export */   XLMRobertaTokenizer: () => (/* binding */ XLMRobertaTokenizer)\n/* harmony export */ });\n/* harmony import */ var _utils_core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/core.js */ \"(ssr)/./node_modules/@xenova/transformers/src/utils/core.js\");\n/* harmony import */ var _utils_hub_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/hub.js */ \"(ssr)/./node_modules/@xenova/transformers/src/utils/hub.js\");\n/* harmony import */ var _utils_maths_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/maths.js */ \"(ssr)/./node_modules/@xenova/transformers/src/utils/maths.js\");\n/* harmony import */ var _utils_tensor_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/tensor.js */ \"(ssr)/./node_modules/@xenova/transformers/src/utils/tensor.js\");\n\n/**\n * @file Tokenizers are used to prepare textual inputs for a model.\n * \n * **Example:** Create an `AutoTokenizer` and use it to tokenize a sentence.\n * This will automatically detect the tokenizer type based on the tokenizer class defined in `tokenizer.json`.\n * ```javascript\n * import { AutoTokenizer } from '@xenova/transformers';\n * \n * let tokenizer = await AutoTokenizer.from_pretrained('bert-base-uncased');\n * let { input_ids } = await tokenizer('I love transformers!');\n * // Tensor {\n * //   data: BigInt64Array(6) [101n, 1045n, 2293n, 19081n, 999n, 102n],\n * //   dims: [1, 6],\n * //   type: 'int64',\n * //   size: 6,\n * // }\n * ```\n * \n * @module tokenizers\n */\n\n\n\n\n\n\n\n\n/**\n * @typedef {import('./utils/hub.js').PretrainedOptions} PretrainedOptions\n */\n\n/**\n * Loads a tokenizer from the specified path.\n * @param {string} pretrained_model_name_or_path The path to the tokenizer directory.\n * @param {PretrainedOptions} options Additional options for loading the tokenizer.\n * @returns {Promise<Array>} A promise that resolves with information about the loaded tokenizer.\n */\nasync function loadTokenizer(pretrained_model_name_or_path, options) {\n\n    let info = await Promise.all([\n        (0,_utils_hub_js__WEBPACK_IMPORTED_MODULE_1__.getModelJSON)(pretrained_model_name_or_path, 'tokenizer.json', true, options),\n        (0,_utils_hub_js__WEBPACK_IMPORTED_MODULE_1__.getModelJSON)(pretrained_model_name_or_path, 'tokenizer_config.json', true, options),\n    ])\n    return info;\n}\n\n/**\n * Helper method to construct a pattern from a config object.\n * @param {Object} pattern The pattern object.\n * @param {boolean} invert Whether to invert the pattern (only applicable for Regex patterns).\n * @returns {RegExp|string|null} The compiled pattern.\n */\nfunction createPattern(pattern, invert = true) {\n\n    if (pattern.Regex) {\n        // NOTE: if invert is true, we wrap the pattern in a group so that it is kept when performing .split()\n        return new RegExp(invert ? pattern.Regex : `(${pattern.Regex})`, 'gu');\n\n    } else if (pattern.String) {\n        return pattern.String;\n\n    } else {\n        console.warn('Unknown pattern type:', pattern)\n        return null;\n    }\n}\n\n/**\n * Clean up a list of simple English tokenization artifacts like spaces before punctuations and abbreviated forms\n * @param {string} text The text to clean up.\n * @returns {string} The cleaned up text.\n */\nfunction clean_up_tokenization(text) {\n    // Clean up a list of simple English tokenization artifacts\n    // like spaces before punctuations and abbreviated forms\n    return text.replace(/ \\./g, '.')\n        .replace(/ \\?/g, '?')\n        .replace(/ \\!/g, '!')\n        .replace(/ ,/g, ',')\n        .replace(/ \\' /g, \"'\")\n        .replace(/ n\\'t/g, \"n't\")\n        .replace(/ \\'m/g, \"'m\")\n        .replace(/ \\'s/g, \"'s\")\n        .replace(/ \\'ve/g, \"'ve\")\n        .replace(/ \\'re/g, \"'re\");\n}\n\n/**\n * Helper function to fuse consecutive values in an array equal to the specified value.\n * @param {Array} arr The input array\n * @param {any} value The value to fuse on.\n */\nfunction fuse(arr, value) {\n    let fused = [];\n    let i = 0;\n    while (i < arr.length) {\n        fused.push(arr[i])\n        if (arr[i] !== value) {\n            ++i;\n            continue;\n        }\n\n        while (i < arr.length && arr[i] === value) {\n            ++i;\n        }\n    }\n\n    return fused;\n}\n\n/**\n * Split a string on whitespace.\n * @param {string} text The text to split.\n * @returns {string[]} The split string.\n */\nfunction whitespace_split(text) {\n    return text.match(/\\S+/g) || [];\n}\n\nconst PUNCTUATION_REGEX = '\\\\p{P}\\\\u0021-\\\\u002F\\\\u003A-\\\\u0040\\\\u005B-\\\\u0060\\\\u007B-\\\\u007E';\n\n/**\n * Abstract base class for tokenizer models.\n *\n * @extends Callable\n */\nclass TokenizerModel extends _utils_core_js__WEBPACK_IMPORTED_MODULE_0__.Callable {\n    /**\n     * Creates a new instance of TokenizerModel.\n     * @param {Object} config The configuration object for the TokenizerModel.\n     */\n    constructor(config) {\n        super();\n        this.config = config;\n\n        /** @type {string[]} */\n        this.vocab = [];\n\n        /**\n         * A mapping of tokens to ids.\n         * @type {Map<string, number>}\n         */\n        this.tokens_to_ids = new Map();\n\n        this.unk_token_id = undefined;\n        this.unk_token = undefined;\n        this.end_of_word_suffix = undefined;\n\n        /** @type {boolean} Whether to fuse unknown tokens when encoding. Defaults to false. */\n        this.fuse_unk = false;\n    }\n\n    /**\n     * Instantiates a new TokenizerModel instance based on the configuration object provided.\n     * @param {Object} config The configuration object for the TokenizerModel.\n     * @param {...*} args Optional arguments to pass to the specific TokenizerModel constructor.\n     * @returns {TokenizerModel} A new instance of a TokenizerModel.\n     * @throws Will throw an error if the TokenizerModel type in the config is not recognized.\n     */\n    static fromConfig(config, ...args) {\n        switch (config.type) {\n            case 'WordPiece':\n                return new WordPieceTokenizer(config);\n            case 'Unigram':\n                // @ts-ignore\n                return new Unigram(config, ...args);\n\n            case 'BPE':\n                // @ts-ignore\n                return new BPE(config, ...args);\n            default:\n                throw new Error(`Unknown TokenizerModel type: ${config.type}`);\n        }\n    }\n\n    /**\n     * Internal function to call the TokenizerModel instance.\n     * @param {string[]} tokens The tokens to encode.\n     * @returns {number[]} The encoded token IDs.\n     */\n    _call(tokens) {\n        return this.encode(tokens);\n    }\n\n    /**\n     * Encodes a list of tokens into a list of token IDs.\n     * @param {string[]} tokens The tokens to encode.\n     * @returns {number[]} The encoded token IDs.\n     * @throws Will throw an error if not implemented in a subclass.\n     */\n    encode(tokens) {\n        throw Error(\"encode should be implemented in subclass.\")\n    }\n\n    /**\n     * Converts a list of tokens into a list of token IDs.\n     * @param {string[]} tokens The tokens to convert.\n     * @returns {number[]} The converted token IDs.\n     */\n    convert_tokens_to_ids(tokens) {\n        let ids = tokens.map(t => this.tokens_to_ids.get(t) ?? this.unk_token_id);\n\n        if (this.fuse_unk) {\n            // Fuse unknown tokens\n            ids = fuse(ids, this.unk_token_id);\n        }\n        return ids;\n    }\n\n    /**\n     * Converts a list of token IDs into a list of tokens.\n     * @param {number[]} ids The token IDs to convert.\n     * @returns {string[]} The converted tokens.\n     */\n    convert_ids_to_tokens(ids) {\n        return ids.map(i => this.vocab[i] ?? this.unk_token);\n    }\n}\n\n/**\n * A subclass of TokenizerModel that uses WordPiece encoding to encode tokens.\n * @extends TokenizerModel\n */\nclass WordPieceTokenizer extends TokenizerModel {\n    /**\n     * @param {Object} config The configuration object.\n     * @param {Map<string, number>} config.vocab A mapping of tokens to ids.\n     * @param {string} config.unk_token The unknown token string.\n     * @param {string} config.continuing_subword_prefix The prefix to use for continuing subwords.\n     */\n    constructor(config) {\n        super(config);\n        /**\n         * A mapping of tokens to ids.\n         * @type {Map<string, number>}\n         */\n        this.tokens_to_ids = config.vocab;\n\n        /**\n         * The id of the unknown token.\n         * @type {number}\n         */\n        this.unk_token_id = this.tokens_to_ids.get(config.unk_token);\n\n        /**\n         * The unknown token string.\n         * @type {string}\n         */\n        this.unk_token = config.unk_token;\n\n        /**\n         * An array of tokens.\n         * @type {string[]}\n         */\n        this.vocab = new Array(this.tokens_to_ids.size);\n\n        for (const [key, value] of this.tokens_to_ids) {\n            this.vocab[value] = key;\n        }\n    }\n\n    /**\n     * Encodes an array of tokens using WordPiece encoding.\n     * @param {Array} tokens The tokens to encode.\n     * @returns {Array} An array of encoded tokens.\n     */\n    encode(tokens) {\n        let outputTokens = [];\n        for (let token of tokens) {\n            let chars = [...token];\n            // TODO add\n            // if len(chars) > self.max_input_chars_per_word:\n            //     output_tokens.append(self.unk_token)\n            //     continue\n\n            let isUnknown = false;\n            let start = 0;\n            let subTokens = [];\n\n            while (start < chars.length) {\n                let end = chars.length;\n                let currentSubstring = null;\n                while (start < end) {\n                    let substr = chars.slice(start, end).join('');\n\n                    if (start > 0) {\n                        substr = this.config.continuing_subword_prefix + substr;\n                    }\n                    if (this.tokens_to_ids.has(substr)) {\n                        currentSubstring = substr;\n                        break;\n                    }\n\n                    --end;\n                }\n                if (currentSubstring === null) {\n                    isUnknown = true;\n                    break;\n                }\n                subTokens.push(currentSubstring);\n                start = end;\n            }\n            if (isUnknown) {\n                outputTokens.push(this.unk_token);\n            } else {\n                outputTokens.push(...subTokens);\n            }\n        }\n\n        return outputTokens;\n    }\n\n}\n\n/**\n * Class representing a Unigram tokenizer model.\n * @extends TokenizerModel\n */\nclass Unigram extends TokenizerModel {\n    /**\n     * Create a new Unigram tokenizer model.\n     * @param {Object} config The configuration object for the Unigram model.\n     * @param {number} config.unk_id The ID of the unknown token\n     * @param {Map<string, number>} config.vocab A mapping of tokens to scores.\n     * @param {Object} moreConfig Additional configuration object for the Unigram model.\n     */\n    constructor(config, moreConfig) {\n        super(config);\n\n        this.vocab = new Array(config.vocab.size);\n        this.scores = new Array(config.vocab.size);\n        let count = 0;\n        config.vocab.forEach((value, key) => {\n            this.vocab[count] = key;\n            this.scores[count] = value;\n            ++count;\n        });\n\n        this.unk_token_id = config.unk_id;\n        this.unk_token = this.vocab[config.unk_id];\n\n        this.tokens_to_ids = new Map(this.vocab.map((x, i) => [x, i]));\n        this.bosToken = ' '; // beginning of a sentence token\n\n        this.bosTokenId = this.tokens_to_ids.get(this.bosToken); // NOTE: may be undefined\n        this.eosToken = moreConfig.eos_token;\n\n        this.eosTokenId = this.tokens_to_ids.get(this.eosToken);\n        this.unkToken = this.vocab[this.unk_token_id];\n\n        this.minScore = (0,_utils_maths_js__WEBPACK_IMPORTED_MODULE_2__.min)(this.scores)[0];\n\n        this.unkScore = this.minScore - 10.0;\n        this.scores[this.unk_token_id] = this.unkScore;\n\n        this.trie = new CharTrie();\n        this.trie.extend(this.vocab);\n\n        // NOTE: `fuse_unk` is hardcoded to true for Unigram models\n        // See: https://github.com/huggingface/tokenizers/blob/b58227c7f1ccf8b73ee2268354336da56d91e492/tokenizers/src/models/unigram/model.rs#L119\n        this.fuse_unk = true;\n    }\n\n    /**\n     * Populates lattice nodes.\n     * @param {TokenLattice} lattice The token lattice to populate with nodes.\n     */\n    populateNodes(lattice) {\n        const sentence = lattice.sentence;\n        const len = sentence.length;\n        let beginPos = 0;\n        while (beginPos < len) {\n            const mblen = 1;\n            let hasSingleNode = false;\n            const tokens = [];\n\n            for (let token of this.trie.commonPrefixSearch(sentence.slice(beginPos))) {\n                tokens.push(token);\n                const tokenId = this.tokens_to_ids.get(token);\n                const tokenScore = this.scores[tokenId];\n                const n = token.length;\n                lattice.insert(beginPos, n, tokenScore, tokenId);\n                if (!hasSingleNode && n === mblen) {\n                    hasSingleNode = true;\n                }\n            }\n            if (!hasSingleNode) {\n                lattice.insert(beginPos, mblen, this.unkScore, this.unk_token_id);\n            }\n            beginPos += mblen;\n        }\n    }\n\n    /**\n     * Encodes an array of tokens into an array of subtokens using the unigram model.\n     *\n     * @param {string} normalized The normalized string.\n     * @returns {string[]} An array of subtokens obtained by encoding the input tokens using the unigram model.\n     */\n    tokenize(normalized) {\n        const lattice = new TokenLattice(normalized, this.bosTokenId, this.eosTokenId);\n        this.populateNodes(lattice);\n        return lattice.tokens();\n    }\n\n    /**\n     * Encodes an array of tokens using WordPiece encoding.\n     * @param {Array} tokens The tokens to encode.\n     * @returns {Array} An array of encoded tokens.\n     */\n    encode(tokens) {\n        let toReturn = [];\n        for (let token of tokens) {\n            const tokenized = this.tokenize(token);\n            toReturn.push(...tokenized);\n        }\n        return toReturn;\n    }\n\n}\n\n/**\n * Returns list of utf-8 byte and a mapping to unicode strings.\n * Specifically avoids mapping to whitespace/control characters the BPE code barfs on.\n * @returns {Object} Object with utf-8 byte keys and unicode string values.\n */\nconst BYTES_TO_UNICODE = (() => {\n    // Returns list of utf-8 byte and a mapping to unicode strings.\n    // We specifically avoids mapping to whitespace/control characters\n    // the bpe code barfs on.\n\n    const bs = [\n        ...Array.from({ length: \"~\".charCodeAt(0) - \"!\".charCodeAt(0) + 1 }, (_, i) => i + \"!\".charCodeAt(0)),\n        ...Array.from({ length: \"¬\".charCodeAt(0) - \"¡\".charCodeAt(0) + 1 }, (_, i) => i + \"¡\".charCodeAt(0)),\n        ...Array.from({ length: \"ÿ\".charCodeAt(0) - \"®\".charCodeAt(0) + 1 }, (_, i) => i + \"®\".charCodeAt(0)),\n    ];\n    let cs = bs.slice();\n    let n = 0;\n    for (let b = 0; b < 256; ++b) {\n        if (!bs.includes(b)) {\n            bs.push(b);\n            cs.push(256 + n);\n            n += 1;\n        }\n    }\n    let ccs = cs.map(n => String.fromCharCode(n));\n    return Object.fromEntries(bs.map((b, i) => [b, ccs[i]]));\n})();\n\nconst UNICODE_TO_BYTES = (0,_utils_core_js__WEBPACK_IMPORTED_MODULE_0__.reverseDictionary)(BYTES_TO_UNICODE);\n\n/**\n * BPE class for encoding text into Byte-Pair-Encoding (BPE) tokens.\n * @extends TokenizerModel\n */\nclass BPE extends TokenizerModel {\n    /**\n     * Create a BPE instance.\n     * @param {Object} config The configuration object for BPE.\n     * @param {Map<string, number>} config.vocab A mapping of tokens to ids.\n     * @param {string} config.unk_token The unknown token used for out of vocabulary words.\n     * @param {string} config.end_of_word_suffix The suffix to place at the end of each word.\n     * @param {Array} config.merges An array of BPE merges as strings.\n     */\n    constructor(config) {\n        super(config);\n\n        this.BPE_SPLIT_TOKEN = ' ';\n\n        this.tokens_to_ids = config.vocab;\n\n        this.unk_token_id = this.tokens_to_ids.get(config.unk_token);\n        this.unk_token = config.unk_token;\n\n        this.vocab = new Array(this.tokens_to_ids.size);\n        for (const [key, value] of this.tokens_to_ids) {\n            this.vocab[value] = key;\n        }\n\n        this.bpe_ranks = Object.fromEntries(config.merges.map((x, i) => [x, i]));\n        this.merges = config.merges.map(x => x.split(this.BPE_SPLIT_TOKEN));\n\n        this.end_of_word_suffix = config.end_of_word_suffix;\n\n        this.byte_fallback = this.config.byte_fallback ?? false;\n\n        if (this.byte_fallback) {\n            this.text_encoder = new TextEncoder();\n        }\n\n        this.cache = Object.create(null);\n\n        this.fuse_unk ??= this.config.fuse_unk;\n    }\n\n    /**\n     * Get all the possible pairs of characters in a word.\n     * @param {string[]} word The word to get pairs from.\n     * @returns {Array} An array of pairs.\n     */\n    get_pairs(word) {\n        let pairs = new Set();\n        let prev_char = word[0];\n        for (let i = 1; i < word.length; ++i) {\n            let char = word[i];\n            pairs.add(prev_char + this.BPE_SPLIT_TOKEN + char);\n            prev_char = char;\n        }\n        return Array.from(pairs);\n    }\n\n    /**\n     * Apply Byte-Pair-Encoding (BPE) to a given token.\n     * @param {string} token The token to encode.\n     * @returns {string} The BPE encoded token.\n     */\n    bpe(token) {\n        if (token in this.cache) {\n            return this.cache[token];\n        }\n        let word = Array.from(token);\n        if (this.end_of_word_suffix) {\n            word[word.length - 1] += this.end_of_word_suffix;\n        }\n        let pairs = this.get_pairs(word);\n\n        if (!pairs.length) {\n            if (this.end_of_word_suffix) {\n                token += this.end_of_word_suffix;\n            }\n            return token;\n        }\n\n        while (true) {\n            let bigram = pairs.reduce((a, b) => {\n                let c = this.bpe_ranks[a] ?? Infinity\n                let d = this.bpe_ranks[b] ?? Infinity\n                return c <= d ? a : b;\n            });\n            if (!(bigram in this.bpe_ranks)) {\n                break;\n            }\n            let [first, second] = bigram.split(this.BPE_SPLIT_TOKEN);\n            let new_word = [];\n            let i = 0;\n            let j = -1;\n\n            while (i < word.length) {\n                try {\n                    j = word.indexOf(first, i);\n                    if (j === -1) throw \"Error\";\n                } catch (e) {\n                    new_word.push(...word.slice(i));\n                    break;\n                }\n                new_word.push(...word.slice(i, j));\n                i = j;\n\n                if (word[i] === first && i < word.length - 1 && word[i + 1] === second) {\n                    new_word.push(first + second);\n                    i += 2;\n                } else {\n                    new_word.push(word[i]);\n                    i += 1;\n                }\n            }\n            word = new_word\n            if (word.length === 1) {\n                break;\n            } else {\n                pairs = this.get_pairs(word);\n            }\n        }\n        let final_word = word.join(this.BPE_SPLIT_TOKEN);\n        this.cache[token] = final_word;\n        return final_word;\n    }\n\n    /**\n     * Encodes the input sequence of tokens using the BPE algorithm and returns the resulting subword tokens.\n     * @param {Array} tokens The input sequence of tokens to encode.\n     * @returns {Array} The resulting subword tokens after applying the BPE algorithm to the input sequence of tokens.\n     */\n    encode(tokens) {\n        let outputTokens = [];\n\n        for (let token of tokens) {\n            let bpe_token_list = this.bpe(token).split(this.BPE_SPLIT_TOKEN);\n\n            for (let t of bpe_token_list) {\n                if (this.tokens_to_ids.has(t)) {\n                    outputTokens.push(t);\n                } else {\n                    if (this.byte_fallback) {\n                        outputTokens.push(\n                            ...Array.from(this.text_encoder.encode(t))\n                                .map(x => `<0x${x.toString(16).toUpperCase().padStart(2, '0')}>`)\n                        );\n                    } else {\n                        outputTokens.push(this.unk_token);\n                    }\n                }\n            }\n        }\n\n        return outputTokens;\n    }\n\n}\n\n/**\n * A base class for text normalization.\n * @abstract\n */\nclass Normalizer extends _utils_core_js__WEBPACK_IMPORTED_MODULE_0__.Callable {\n    /**\n     * @param {Object} config The configuration object for the normalizer.\n     */\n    constructor(config) {\n        super();\n        this.config = config;\n    }\n\n    /**\n     * Factory method for creating normalizers from config objects.\n     * @static\n     * @param {Object} config The configuration object for the normalizer.\n     * @returns {Normalizer} A Normalizer object.\n     * @throws {Error} If an unknown Normalizer type is specified in the config.\n     */\n    static fromConfig(config) {\n        if (config === null) return null;\n        switch (config.type) {\n            case 'BertNormalizer':\n                return new BertNormalizer(config);\n            case 'Precompiled':\n                return new Precompiled(config);\n            case 'Sequence':\n                return new NormalizerSequence(config);\n            case 'Replace':\n                return new Replace(config);\n            case 'NFC':\n                return new NFC(config);\n            case 'NFKD':\n                return new NFKD(config);\n            case 'StripAccents':\n                return new StripAccents(config);\n            case 'Lowercase':\n                return new Lowercase(config);\n            case 'Prepend':\n                return new Prepend(config);\n            default:\n                throw new Error(`Unknown Normalizer type: ${config.type}`);\n        }\n    }\n\n    /**\n     * Normalize the input text.\n     * @abstract\n     * @param {string} text The text to normalize.\n     * @returns {string} The normalized text.\n     * @throws {Error} If this method is not implemented in a subclass.\n     */\n    normalize(text) {\n        throw Error(\"normalize should be implemented in subclass.\")\n    }\n\n    /**\n     * Alias for {@link Normalizer#normalize}.\n     * @param {string} text The text to normalize.\n     * @returns {string} The normalized text.\n     */\n    _call(text) {\n        return this.normalize(text);\n    }\n\n}\n\n/**\n * Replace normalizer that replaces occurrences of a pattern with a given string or regular expression.\n * @extends Normalizer\n */\nclass Replace extends Normalizer {\n    /**\n     * Normalize the input text by replacing the pattern with the content.\n     * @param {string} text The input text to be normalized.\n     * @returns {string} The normalized text after replacing the pattern with the content.\n     */\n    normalize(text) {\n        let pattern = createPattern(this.config.pattern);\n        if (pattern === null) {\n            return text;\n        }\n\n        text = text.replaceAll(pattern, this.config.content)\n\n        return text;\n    }\n}\n\n/**\n * A normalizer that applies Unicode normalization form C (NFC) to the input text.\n * @extends Normalizer\n */\nclass NFC extends Normalizer {\n    /**\n     * Normalize the input text by applying Unicode normalization form C (NFC).\n     * @param {string} text The input text to be normalized.\n     * @returns {string} The normalized text.\n     */\n    normalize(text) {\n        text = text.normalize('NFC')\n        return text;\n    }\n}\n\n/**\n * NFKD Normalizer.\n * @extends Normalizer\n */\nclass NFKD extends Normalizer {\n    /**\n     * Normalize text using NFKD normalization.\n     * @param {string} text The text to be normalized.\n     * @returns {string} The normalized text.\n     */\n    normalize(text) {\n        text = text.normalize('NFKD')\n        return text;\n    }\n}\n\n/**\n * StripAccents normalizer removes all accents from the text.\n * @extends Normalizer\n */\nclass StripAccents extends Normalizer {\n    /**\n     * Remove all accents from the text.\n     * @param {string} text The input text.\n     * @returns {string} The normalized text without accents.\n     */\n    normalize(text) {\n        text = text.replace(/[\\u0300-\\u036f]/g, '');\n        return text;\n    }\n}\n\n/**\n * A Normalizer that lowercases the input string.\n * @extends Normalizer\n */\nclass Lowercase extends Normalizer {\n    /**\n     * Lowercases the input string.\n     * @param {string} text The text to normalize.\n     * @returns {string} The normalized text.\n     */\n    normalize(text) {\n        text = text.toLowerCase();\n        return text;\n    }\n}\n\n/**\n * A Normalizer that prepends a string to the input string.\n * @extends Normalizer\n */\nclass Prepend extends Normalizer {\n    /**\n     * Prepends the input string.\n     * @param {string} text The text to normalize.\n     * @returns {string} The normalized text.\n     */\n    normalize(text) {\n        text = this.config.prepend + text;\n        return text;\n    }\n}\n\n/**\n * A Normalizer that applies a sequence of Normalizers.\n * @extends Normalizer\n */\nclass NormalizerSequence extends Normalizer {\n    /**\n   * Create a new instance of NormalizerSequence.\n   * @param {Object} config The configuration object.\n   * @param {Object[]} config.normalizers An array of Normalizer configuration objects.\n   */\n    constructor(config) {\n        super(config);\n        this.normalizers = config.normalizers.map(x => Normalizer.fromConfig(x));\n    }\n    /**\n    * Apply a sequence of Normalizers to the input text.\n    * @param {string} text The text to normalize.\n    * @returns {string} The normalized text.\n    */\n    normalize(text) {\n        return this.normalizers.reduce((t, normalizer) => {\n            return normalizer.normalize(t);\n        }, text);\n    }\n}\n\n/**\n * A class representing a normalizer used in BERT tokenization.\n * @extends Normalizer\n */\nclass BertNormalizer extends Normalizer {\n    /**\n     * Adds whitespace around any CJK (Chinese, Japanese, or Korean) character in the input text.\n     *\n     * @param {string} text The input text to tokenize.\n     * @returns {string} The tokenized text with whitespace added around CJK characters.\n     */\n    _tokenize_chinese_chars(text) {\n        /* Adds whitespace around any CJK character. */\n        let output = [];\n        for (let i = 0; i < text.length; ++i) {\n            let char = text[i];\n            let cp = char.charCodeAt(0);\n            if (this._is_chinese_char(cp)) {\n                output.push(\" \");\n                output.push(char);\n                output.push(\" \");\n            } else {\n                output.push(char);\n            }\n        }\n        return output.join(\"\");\n    }\n\n    /**\n     * Checks whether the given Unicode codepoint represents a CJK (Chinese, Japanese, or Korean) character.\n     *\n     * A \"chinese character\" is defined as anything in the CJK Unicode block:\n     * https://en.wikipedia.org/wiki/CJK_Unified_Ideographs_(Unicode_block)\n     *\n     * Note that the CJK Unicode block is NOT all Japanese and Korean characters, despite its name.\n     * The modern Korean Hangul alphabet is a different block, as is Japanese Hiragana and Katakana.\n     * Those alphabets are used to write space-separated words, so they are not treated specially\n     * and are handled like all other languages.\n     *\n     * @param {number} cp The Unicode codepoint to check.\n     * @returns {boolean} True if the codepoint represents a CJK character, false otherwise.\n     */\n    _is_chinese_char(cp) {\n        return (\n            (cp >= 0x4E00 && cp <= 0x9FFF)\n            || (cp >= 0x3400 && cp <= 0x4DBF)\n            || (cp >= 0x20000 && cp <= 0x2A6DF)\n            || (cp >= 0x2A700 && cp <= 0x2B73F)\n            || (cp >= 0x2B740 && cp <= 0x2B81F)\n            || (cp >= 0x2B820 && cp <= 0x2CEAF)\n            || (cp >= 0xF900 && cp <= 0xFAFF)\n            || (cp >= 0x2F800 && cp <= 0x2FA1F)\n        )\n    }\n    /**\n     * Strips accents from the given text.\n     * @param {string} text The text to strip accents from.\n     * @returns {string} The text with accents removed.\n     */\n    stripAccents(text) {\n        return text.normalize('NFD').replace(/[\\u0300-\\u036f]/g, '');\n    }\n\n    /**\n     * Normalizes the given text based on the configuration.\n     * @param {string} text The text to normalize.\n     * @returns {string} The normalized text.\n     */\n    normalize(text) {\n        // TODO use rest of config\n        // config.clean_text,\n        // config.handle_chinese_chars,\n        // config.strip_accents,\n        // config.lowercase,\n\n        if (this.config.handle_chinese_chars) {\n            text = this._tokenize_chinese_chars(text);\n        }\n\n        if (this.config.lowercase) {\n            text = text.toLowerCase();\n\n            if (this.config.strip_accents !== false) {\n                text = this.stripAccents(text);\n            }\n        } else if (this.config.strip_accents) {\n            text = this.stripAccents(text);\n        }\n\n        return text;\n    }\n}\n\n/**\n * A callable class representing a pre-tokenizer used in tokenization. Subclasses\n * should implement the `pre_tokenize_text` method to define the specific pre-tokenization logic.\n * @extends Callable\n */\nclass PreTokenizer extends _utils_core_js__WEBPACK_IMPORTED_MODULE_0__.Callable {\n    /**\n   * Factory method that returns an instance of a subclass of `PreTokenizer` based on the provided configuration.\n   *\n   * @static\n   * @param {Object} config A configuration object for the pre-tokenizer.\n   * @returns {PreTokenizer} An instance of a subclass of `PreTokenizer`.\n   * @throws {Error} If the provided configuration object does not correspond to any known pre-tokenizer.\n   */\n    static fromConfig(config) {\n        if (config === null) return null;\n\n        switch (config.type) {\n            case 'BertPreTokenizer':\n                return new BertPreTokenizer(config);\n            case 'Sequence':\n                return new PreTokenizerSequence(config);\n            case 'WhitespaceSplit':\n                return new WhitespaceSplit(config);\n            case 'Metaspace':\n                return new MetaspacePreTokenizer(config);\n\n            case 'ByteLevel':\n                return new ByteLevelPreTokenizer(config);\n            case 'Split':\n                return new SplitPreTokenizer(config);\n            case 'Punctuation':\n                return new PunctuationPreTokenizer(config);\n            case 'Digits':\n                return new DigitsPreTokenizer(config);\n            default:\n                throw new Error(`Unknown PreTokenizer type: ${config.type}`);\n        }\n    }\n\n    /**\n   * Method that should be implemented by subclasses to define the specific pre-tokenization logic.\n   *\n   * @abstract\n   * @param {string} text The text to pre-tokenize.\n   * @returns {string[]} The pre-tokenized text.\n   * @throws {Error} If the method is not implemented in the subclass.\n   */\n    pre_tokenize_text(text) {\n        throw Error(\"pre_tokenize_text should be implemented in subclass.\")\n    }\n\n    /**\n     * Tokenizes the given text into pre-tokens.\n     * @param {string|string[]} text The text or array of texts to pre-tokenize.\n     * @returns {string[]} An array of pre-tokens.\n     */\n    pre_tokenize(text) {\n        let result = [];\n        if (Array.isArray(text)) {\n            result = text.map(x => this.pre_tokenize_text(x))\n        } else {\n            result = this.pre_tokenize_text(text);\n        }\n        return result.flat();\n    }\n\n    /**\n     * Alias for {@link PreTokenizer#pre_tokenize}.\n     * @param {string|string[]} text The text or array of texts to pre-tokenize.\n     * @returns {string[]} An array of pre-tokens.\n     */\n    _call(text) {\n        return this.pre_tokenize(text);\n    }\n}\n\n/**\n * @extends PreTokenizer\n */\nclass BertPreTokenizer extends PreTokenizer {\n    /**\n     * A PreTokenizer that splits text into wordpieces using a basic tokenization scheme\n     * similar to that used in the original implementation of BERT.\n     * \n     * @param {Object} config The configuration object.\n     */\n    constructor(config) {\n        super();\n        // Construct a pattern which matches the rust implementation:\n        // https://github.com/huggingface/tokenizers/blob/b4fcc9ce6e4ad5806e82826f816acfdfdc4fcc67/tokenizers/src/pre_tokenizers/bert.rs#L11\n        // Equivalent to removing whitespace and splitting on punctuation (both \\p{P} and other ascii characters)\n        this.pattern = new RegExp(`[^\\\\s${PUNCTUATION_REGEX}]+|[${PUNCTUATION_REGEX}]`, 'gu');\n    }\n    /**\n     * Tokenizes a single text using the BERT pre-tokenization scheme.\n     * \n     * @param {string} text The text to tokenize.\n     * @returns {string[]} An array of tokens.\n     */\n    pre_tokenize_text(text) {\n        return text.trim().match(this.pattern) || [];\n    }\n}\n\n/**\n * A pre-tokenizer that splits text into Byte-Pair-Encoding (BPE) subwords.\n * @extends PreTokenizer\n */\nclass ByteLevelPreTokenizer extends PreTokenizer {\n    /**\n     * Creates a new instance of the `ByteLevelPreTokenizer` class.\n     * @param {Object} config The configuration object.\n     */\n    constructor(config) {\n        super();\n        this.config = config;\n\n        /**\n         * @type {boolean} Whether to add a leading space to the first word.\n         * This allows to treat the leading word just as any other word.\n         */\n        this.add_prefix_space = this.config.add_prefix_space;\n\n        /**\n         * @type {boolean} Whether the post processing step should trim offsets\n         * to avoid including whitespaces.\n         * @todo Use this in the pretokenization step.\n         */\n        this.trim_offsets = this.config.trim_offsets;\n\n        /**\n         * @type {boolean} Whether to use the standard GPT2 regex for whitespace splitting.\n         * Set it to False if you want to use your own splitting. Defaults to true.\n         */\n        this.use_regex = this.config.use_regex ?? true;\n        this.pattern = /'s|'t|'re|'ve|'m|'ll|'d| ?\\p{L}+| ?\\p{N}+| ?[^\\s\\p{L}\\p{N}]+|\\s+(?!\\S)|\\s+/gu;\n\n        this.byte_encoder = BYTES_TO_UNICODE;\n        this.text_encoder = new TextEncoder();\n    }\n\n    /**\n     * Tokenizes a single piece of text using byte-level tokenization.\n     * @param {string} text The text to tokenize.\n     * @returns {string[]} An array of tokens.\n     */\n    pre_tokenize_text(text) {\n        // Split on whitespace and punctuation\n        let tokens = this.use_regex ? (text.match(this.pattern) || []) : [text];\n\n        return tokens.map(token => {\n            if (this.add_prefix_space && !token.startsWith(' ')) {\n                token = ' ' + token;\n            }\n\n            // Maps all our bytes to unicode strings, avoiding control tokens of the BPE (spaces in our case)\n            token = Array.from(this.text_encoder.encode(token), byte => this.byte_encoder[byte]).join('');\n\n            return token;\n        });\n    }\n}\n\n/**\n * @typedef {'removed'|'isolated'|'mergedWithPrevious'|'mergedWithNext'|'contiguous'} SplitDelimiterBehavior\n */\n\n/**\n * Splits text using a given pattern.\n * @extends PreTokenizer\n */\nclass SplitPreTokenizer extends PreTokenizer {\n    /**\n     * @param {Object} config The configuration options for the pre-tokenizer.\n     * @param {Object} config.pattern The pattern used to split the text. Can be a string or a regex object.\n     * @param {string|undefined} config.pattern.String The string to use for splitting. Only defined if the pattern is a string.\n     * @param {string|undefined} config.pattern.Regex The regex to use for splitting. Only defined if the pattern is a regex.\n     * @param {SplitDelimiterBehavior} config.behavior The behavior to use when splitting.\n     * @param {boolean} config.invert Whether to split (invert=false) or match (invert=true) the pattern.\n     */\n    constructor(config) {\n        super();\n        this.config = config;\n        // TODO support all behaviours (config.behavior)\n\n        this.pattern = createPattern(this.config.pattern, this.config.invert);\n    }\n\n    /**\n     * Tokenizes text by splitting it using the given pattern.\n     * @param {string} text The text to tokenize.\n     * @returns {string[]} An array of tokens.\n     */\n    pre_tokenize_text(text) {\n        if (this.pattern === null) {\n            return [];\n        }\n\n        if (this.config.invert) {\n            return text.match(this.pattern) || [];\n        } else {\n            return text.split(this.pattern).filter(x => x);\n        }\n    }\n}\n\n/**\n * Splits text based on punctuation.\n * @extends PreTokenizer\n */\nclass PunctuationPreTokenizer extends PreTokenizer {\n    /**\n     * @param {Object} config The configuration options for the pre-tokenizer.\n     * @param {SplitDelimiterBehavior} config.behavior The behavior to use when splitting.\n     */\n    constructor(config) {\n        super();\n        this.config = config;\n        this.pattern = new RegExp(`[^${PUNCTUATION_REGEX}]+|[${PUNCTUATION_REGEX}]+`, 'gu');\n    }\n\n    /**\n     * Tokenizes text by splitting it using the given pattern.\n     * @param {string} text The text to tokenize.\n     * @returns {string[]} An array of tokens.\n     */\n    pre_tokenize_text(text) {\n        return text.match(this.pattern) || [];\n    }\n}\n\n\n/**\n * Splits text based on digits.\n * @extends PreTokenizer\n */\nclass DigitsPreTokenizer extends PreTokenizer {\n    /**\n     * @param {Object} config The configuration options for the pre-tokenizer.\n     * @param {boolean} config.individual_digits Whether to split on individual digits.\n     */\n    constructor(config) {\n        super();\n        this.config = config;\n\n        // Construct a pattern which matches the rust implementation:\n        const digit_pattern = `[^\\\\d]+|\\\\d${this.config.individual_digits ? '' : '+'}`;\n        this.pattern = new RegExp(digit_pattern, 'gu');\n    }\n\n    /**\n     * Tokenizes text by splitting it using the given pattern.\n     * @param {string} text The text to tokenize.\n     * @returns {string[]} An array of tokens.\n     */\n    pre_tokenize_text(text) {\n        return text.match(this.pattern) || [];\n    }\n}\n\n/**\n * @extends Callable\n */\nclass PostProcessor extends _utils_core_js__WEBPACK_IMPORTED_MODULE_0__.Callable {\n\n    /**\n     * @param {Object} config The configuration for the post-processor.\n     */\n    constructor(config) {\n        super();\n        this.config = config;\n    }\n\n    /**\n     * Factory method to create a PostProcessor object from a configuration object.\n     *\n     * @param {Object} config Configuration object representing a PostProcessor.\n     * @returns {PostProcessor} A PostProcessor object created from the given configuration.\n     * @throws {Error} If an unknown PostProcessor type is encountered.\n     */\n    static fromConfig(config) {\n        if (config === null) return null;\n        switch (config.type) {\n            case 'TemplateProcessing':\n                return new TemplateProcessing(config);\n\n            case 'ByteLevel':\n                return new ByteLevelPostProcessor(config);\n\n            case 'RobertaProcessing':\n                return new RobertaProcessing(config);\n\n            default:\n                throw new Error(`Unknown PostProcessor type: ${config.type}`);\n        }\n    }\n\n    /**\n     * Method to be implemented in subclass to apply post-processing on the given tokens.\n     *\n     * @param {Array} tokens The input tokens to be post-processed.\n     * @param {...*} args Additional arguments required by the post-processing logic.\n     * @returns {Array} The post-processed tokens.\n     * @throws {Error} If the method is not implemented in subclass.\n     */\n    post_process(tokens, ...args) {\n        throw Error(\"post_process should be implemented in subclass.\")\n    }\n\n    /**\n     * Alias for {@link PostProcessor#post_process}.\n     * @param {Array} tokens The text or array of texts to post-process.\n     * @param {...*} args Additional arguments required by the post-processing logic.\n     * @returns {Array} An array of post-processed tokens.\n     */\n    _call(tokens, ...args) {\n        return this.post_process(tokens, ...args);\n    }\n}\n\n/**\n * A post-processor that adds special tokens to the beginning and end of the input.\n * @extends PostProcessor\n */\nclass RobertaProcessing extends PostProcessor {\n    /**\n     * @param {Object} config The configuration for the post-processor.\n     * @param {string[]} config.cls The special tokens to add to the beginning of the input.\n     * @param {string[]} config.sep The special tokens to add to the end of the input.\n     */\n    constructor(config) {\n        super(config);\n        // TODO use all of config: add_prefix_space, trim_offsets\n\n        this.cls = config.cls[0];\n        this.sep = config.sep[0];\n    }\n\n    /**\n     * Adds the special tokens to the beginning and end of the input.\n     * @param {string[]} tokens The input tokens.\n     * @param {string[]|null} tokens_pair An optional second set of input tokens.\n     * @returns {string[]} The input tokens with the special tokens added to the beginning and end.\n     */\n    post_process(tokens, tokens_pair = null) {\n        tokens = (0,_utils_core_js__WEBPACK_IMPORTED_MODULE_0__.mergeArrays)([this.cls], tokens, [this.sep]);\n\n        // NOTE: It is intended to add 2 EOS tokens after the first set of tokens\n        // https://github.com/huggingface/tokenizers/issues/983\n        if (tokens_pair !== null) {\n            tokens = (0,_utils_core_js__WEBPACK_IMPORTED_MODULE_0__.mergeArrays)(tokens, [this.sep], tokens_pair, [this.sep]);\n        }\n        return tokens;\n    }\n}\n\n/**\n * Post processor that replaces special tokens in a template with actual tokens.\n * @extends PostProcessor\n */\nclass TemplateProcessing extends PostProcessor {\n    /**\n     * Creates a new instance of `TemplateProcessing`.\n     * @param {Object} config The configuration options for the post processor.\n     * @param {Array} config.single The template for a single sequence of tokens.\n     * @param {Array} config.pair The template for a pair of sequences of tokens.\n     */\n    constructor(config) {\n        super(config);\n\n        this.single = config.single;\n        this.pair = config.pair;\n    }\n\n    /**\n     * Replaces special tokens in the template with actual tokens.\n     * @param {Array} tokens The list of tokens for the first sequence.\n     * @param {Array} [tokens_pair=null] The list of tokens for the second sequence (optional).\n     * @returns {Array} The list of tokens with the special tokens replaced with actual tokens.\n     */\n    post_process(tokens, tokens_pair = null) {\n        let type = tokens_pair === null ? this.single : this.pair\n\n        let toReturn = [];\n        for (let item of type) {\n            if ('SpecialToken' in item) {\n                toReturn.push(item.SpecialToken.id);\n\n            } else if ('Sequence' in item) {\n                if (item.Sequence.id === 'A') {\n                    toReturn = (0,_utils_core_js__WEBPACK_IMPORTED_MODULE_0__.mergeArrays)(toReturn, tokens);\n\n                } else if (item.Sequence.id === 'B') {\n                    toReturn = (0,_utils_core_js__WEBPACK_IMPORTED_MODULE_0__.mergeArrays)(toReturn, tokens_pair);\n                }\n            }\n        }\n        return toReturn;\n    }\n}\n\n/**\n * A PostProcessor that returns the given tokens as is.\n * @extends PostProcessor\n */\nclass ByteLevelPostProcessor extends PostProcessor {\n    /**\n     * Post process the given tokens.\n     * @param {string[]} tokens The tokens to be post processed.\n     * @returns {string[]} The post processed tokens.\n     */\n    post_process(tokens) {\n        return tokens;\n    }\n}\n\n/**\n * The base class for token decoders.\n * @extends Callable\n */\nclass Decoder extends _utils_core_js__WEBPACK_IMPORTED_MODULE_0__.Callable {\n\n    /**\n    * Creates an instance of `Decoder`.\n    *\n    * @param {Object} config The configuration object.\n    */\n    constructor(config) {\n        super();\n        this.config = config;\n\n        this.added_tokens = [];\n        this.end_of_word_suffix = null;\n        this.trim_offsets = config.trim_offsets;\n    }\n\n    /**\n   * Creates a decoder instance based on the provided configuration.\n   *\n   * @param {Object} config The configuration object.\n   * @returns {Decoder} A decoder instance.\n   * @throws {Error} If an unknown decoder type is provided.\n   */\n    static fromConfig(config) {\n        switch (config.type) {\n            case 'WordPiece':\n                return new WordPieceDecoder(config);\n            case 'Metaspace':\n                return new MetaspaceDecoder(config);\n            case 'ByteLevel':\n                return new ByteLevelDecoder(config);\n\n            case 'Replace':\n                return new ReplaceDecoder(config);\n            case 'ByteFallback':\n                return new ByteFallback(config);\n            case 'Fuse':\n                return new FuseDecoder(config);\n            case 'Strip':\n                return new StripDecoder(config);\n\n            case 'Sequence':\n                return new DecoderSequence(config);\n\n            default:\n                throw new Error(`Unknown Decoder type: ${config.type}`);\n        }\n    }\n\n    /**\n    * Calls the `decode` method.\n    *\n    * @param {string[]} tokens The list of tokens.\n    * @returns {string} The decoded string.\n    */\n    _call(tokens) {\n        return this.decode(tokens);\n    }\n\n    /**\n    * Decodes a list of tokens.\n    * @param {string[]} tokens The list of tokens.\n    * @returns {string} The decoded string.\n    */\n    decode(tokens) {\n        return this.decode_chain(tokens).join('');\n    }\n\n    /**\n     * Apply the decoder to a list of tokens.\n     * \n     * @param {string[]} tokens The list of tokens.\n     * @returns {string[]} The decoded list of tokens.\n     * @throws {Error} If the `decode_chain` method is not implemented in the subclass.\n     */\n    decode_chain(tokens) {\n        throw Error(\"`decode_chain` should be implemented in subclass.\")\n    }\n\n}\n\nclass ReplaceDecoder extends Decoder {\n    constructor(config) {\n        super(config);\n    }\n\n    /** @type {Decoder['decode_chain']} */\n    decode_chain(tokens) {\n        let pattern = createPattern(this.config.pattern);\n        if (pattern === null) {\n            return tokens;\n        }\n\n        return tokens.map(token => token.replaceAll(pattern, this.config.content))\n    }\n}\n\n\nclass ByteFallback extends Decoder {\n    constructor(config) {\n        super(config);\n\n        this.text_decoder = new TextDecoder();\n    }\n\n    /** @type {Decoder['decode_chain']} */\n    decode_chain(tokens) {\n\n        let new_tokens = [];\n        let previous_byte_tokens = [];\n\n        for (let token of tokens) {\n            let bytes = null;\n            if (token.length === 6 && token.startsWith('<0x') && token.endsWith('>')) {\n                let byte = parseInt(token.slice(3, 5), 16);\n                if (!isNaN(byte)) {\n                    bytes = byte;\n                }\n            }\n            if (bytes !== null) {\n                previous_byte_tokens.push(bytes);\n            } else {\n                if (previous_byte_tokens.length > 0) {\n                    let string = this.text_decoder.decode(Uint8Array.from(previous_byte_tokens));\n                    new_tokens.push(string);\n                    previous_byte_tokens = [];\n                }\n                new_tokens.push(token);\n            }\n        }\n        if (previous_byte_tokens.length > 0) {\n            let string = this.text_decoder.decode(Uint8Array.from(previous_byte_tokens));\n            new_tokens.push(string);\n            previous_byte_tokens = [];\n        }\n\n        return new_tokens;\n    }\n}\n\n/**\n * Fuse simply fuses all tokens into one big string.\n * It's usually the last decoding step anyway, but this decoder\n * exists incase some decoders need to happen after that step\n */\nclass FuseDecoder extends Decoder {\n    constructor(config) {\n        super(config);\n    }\n\n    /** @type {Decoder['decode_chain']} */\n    decode_chain(tokens) {\n        return [tokens.join('')];\n    }\n}\n\nclass StripDecoder extends Decoder {\n    constructor(config) {\n        super(config);\n\n        this.content = this.config.content;\n        this.start = this.config.start;\n        this.stop = this.config.stop;\n    }\n\n    /** @type {Decoder['decode_chain']} */\n    decode_chain(tokens) {\n        return tokens.map(token => {\n            let start_cut = 0;\n            for (let i = 0; i < this.start; ++i) {\n                if (token[i] === this.content) {\n                    start_cut = i + 1;\n                    continue;\n                } else {\n                    break;\n                }\n            }\n\n            let stop_cut = token.length;\n            for (let i = 0; i < this.stop; ++i) {\n                const index = token.length - i - 1;\n                if (token[index] === this.content) {\n                    stop_cut = index;\n                    continue;\n                } else {\n                    break;\n                }\n            }\n\n            return token.slice(start_cut, stop_cut)\n        });\n    }\n}\n\n/**\n * A decoder that decodes a list of WordPiece tokens into a single string.\n * @extends Decoder\n */\nclass WordPieceDecoder extends Decoder {\n\n    /**\n     * Creates a new instance of WordPieceDecoder.\n     * @param {Object} config The configuration object.\n     * @param {string} config.prefix The prefix used for WordPiece encoding.\n     * @param {boolean} config.cleanup Whether to cleanup the decoded string.\n     */\n    constructor(config) {\n        super(config);\n        this.cleanup = config.cleanup;\n    }\n\n    /** @type {Decoder['decode_chain']} */\n    decode_chain(tokens) {\n        return tokens.map((token, i) => {\n            if (i !== 0) {\n                if (token.startsWith(this.config.prefix)) {\n                    // NOTE: .replace() is intended; only replace first occurrence\n                    token = token.replace(this.config.prefix, '');\n                } else {\n                    token = ' ' + token;\n                }\n            }\n            if (this.cleanup) {\n                token = clean_up_tokenization(token)\n            }\n\n            return token;\n        });\n    }\n}\n\n/**\n * Byte-level decoder for tokenization output. Inherits from the `Decoder` class.\n * @extends Decoder\n */\nclass ByteLevelDecoder extends Decoder {\n\n    /**\n     * Create a `ByteLevelDecoder` object.\n     * @param {Object} config Configuration object.\n     */\n    constructor(config) {\n        super(config);\n\n        this.byte_decoder = UNICODE_TO_BYTES;\n        this.text_decoder = new TextDecoder(\"utf-8\", {\n            fatal: false,\n            ignoreBOM: true,\n        });\n\n        this.end_of_word_suffix = null;\n    }\n\n    /**\n     * Convert an array of tokens to string by decoding each byte.\n     * @param {string[]} tokens Array of tokens to be decoded.\n     * @returns {string} The decoded string.\n     */\n    convert_tokens_to_string(tokens) {\n        let text = tokens.join('');\n\n        let byteArray = new Uint8Array([...text].map(c => this.byte_decoder[c]));\n        let decoded_text = this.text_decoder.decode(byteArray);\n        return decoded_text;\n    }\n\n    /** @type {Decoder['decode_chain']} */\n    decode_chain(tokens) {\n        // TODO move to base class (like HF)\n        // tokens === filtered_tokens\n\n        // To avoid mixing byte-level and unicode for byte-level BPT\n        // we need to build string separately for added tokens and byte-level tokens\n        // cf. https://github.com/huggingface/transformers/issues/1133\n        let sub_texts = [];\n        let current_sub_text = [];\n        for (let token of tokens) {\n            // tokens sent here are already filtered, so we don't need to do this\n            // if (skip_special_tokens && this.all_special_ids.includes(token)) {\n            //     continue;\n            // }\n\n            if (this.added_tokens.includes(token)) {\n                if (current_sub_text.length > 0) {\n                    sub_texts.push(this.convert_tokens_to_string(current_sub_text));\n                    current_sub_text = [];\n                }\n                sub_texts.push(token);\n            } else {\n                current_sub_text.push(token);\n            }\n        }\n        if (current_sub_text.length > 0) {\n            sub_texts.push(this.convert_tokens_to_string(current_sub_text));\n        }\n\n        // TODO add spaces_between_special_tokens and clean_up_tokenization_spaces options\n\n        return sub_texts;\n    }\n}\n\n\n/**\n * Apply a sequence of decoders.\n * @extends Decoder\n */\nclass DecoderSequence extends Decoder {\n\n    /**\n     * Creates a new instance of DecoderSequence.\n     * @param {Object} config The configuration object.\n     * @param {Decoder[]} config.decoders The list of decoders to apply.\n     */\n    constructor(config) {\n        super(config);\n        this.decoders = config.decoders.map(x => Decoder.fromConfig(x));\n    }\n\n    /** @type {Decoder['decode_chain']} */\n    decode_chain(tokens) {\n        // Use reduce to apply each decoder to the tokens\n        return this.decoders.reduce((toks, decoder) => {\n            return decoder.decode_chain(toks);\n        }, tokens);\n    }\n\n}\n\n/**\n * This PreTokenizer replaces spaces with the given replacement character, adds a prefix space if requested,\n * and returns a list of tokens.\n * @extends PreTokenizer\n */\nclass MetaspacePreTokenizer extends PreTokenizer {\n    /**\n     * @param {Object} config The configuration object for the MetaspacePreTokenizer.\n     * @param {boolean} config.add_prefix_space Whether to add a prefix space to the first token.\n     * @param {string} config.replacement The character to replace spaces with.\n     * @param {string} [config.str_rep=config.replacement] An optional string representation of the replacement character.\n     */\n    constructor(config) {\n        super();\n\n        this.addPrefixSpace = config.add_prefix_space;\n        this.replacement = config.replacement;\n        this.strRep = config.str_rep || this.replacement;\n    }\n\n    /**\n     * This method takes a list of normalized tokens, replaces spaces with the replacement character,\n     * adds a prefix space if requested, and returns a new list of tokens.\n     * @param {string[]|string} normalizedTokens The list of normalized tokens to pre-tokenize.\n     * @returns {string[]} A new list of pre-tokenized tokens.\n     */\n    pre_tokenize(normalizedTokens) {\n        if (typeof normalizedTokens === 'string') {\n            // Metaspace acts on a list of tokens. If passing in a string, first split on whitespace\n            // NOTE: For some reason, metaspace includes trailing whitespace, so we only trim leading whitespace.\n            // See: https://github.com/huggingface/tokenizers/issues/1250\n            normalizedTokens = normalizedTokens.trimStart().split(/\\s+/);\n        }\n\n        const result = [];\n        for (let token of normalizedTokens) {\n            let normalized = token.replaceAll(' ', this.strRep);\n            if (this.addPrefixSpace && !normalized.startsWith(this.replacement)) {\n                normalized = this.strRep + normalized;\n            }\n            result.push(normalized);\n        }\n        return result;\n    }\n}\n\n/**\n * MetaspaceDecoder class extends the Decoder class and decodes Metaspace tokenization.\n * @extends Decoder\n */\nclass MetaspaceDecoder extends Decoder {\n    /**\n     * Constructs a new MetaspaceDecoder object.\n     * @param {Object} config The configuration object for the MetaspaceDecoder.\n     * @param {boolean} config.add_prefix_space Whether to add a prefix space to the decoded string.\n     * @param {string} config.replacement The string to replace spaces with.\n     */\n    constructor(config) {\n        super(config);\n\n        this.addPrefixSpace = config.add_prefix_space;\n        this.replacement = config.replacement;\n    }\n\n    /** @type {Decoder['decode_chain']} */\n    decode_chain(tokens) {\n        let result = [];\n        for (let i = 0; i < tokens.length; ++i) {\n            let normalized = tokens[i].replaceAll(this.replacement, ' ');\n            if (this.addPrefixSpace && i == 0 && normalized.startsWith(' ')) {\n                normalized = normalized.substring(1);\n            }\n            result.push(normalized);\n        }\n        return result;\n    }\n}\n\n/**\n * A normalizer that applies a precompiled charsmap.\n * This is useful for applying complex normalizations in C++ and exposing them to JavaScript.\n * @extends Normalizer\n * @param {Object} config The configuration object for the Precompiled normalizer.\n * @param {Object} config.precompiled_charsmap The precompiled charsmap object.\n */\nclass Precompiled extends Normalizer {\n    /**\n     * Create a new instance of Precompiled normalizer.\n     * @param {Object} config The configuration object.\n     * @param {any} config.precompiled_charsmap Precompiled chars mapping.\n     */\n    constructor(config) {\n        super(config);\n        this.charsmap = config.precompiled_charsmap;\n    }\n\n    /**\n     * Normalizes the given text by applying the precompiled charsmap.\n     * @param {string} text The text to normalize.\n     * @returns {string} The normalized text.\n     */\n    normalize(text) {\n        // TODO use this.charsmap\n        // For now, we just apply NFKC normalization\n        // https://github.com/huggingface/tokenizers/blob/291b2e23ae81cf94738835852213ce120152d121/bindings/python/py_src/tokenizers/implementations/sentencepiece_bpe.py#L34\n        text = text.normalize('NFKC');\n        return text;\n    }\n}\n\n/**\n * A pre-tokenizer that applies a sequence of pre-tokenizers to the input text.\n * @extends PreTokenizer\n */\nclass PreTokenizerSequence extends PreTokenizer {\n    /**\n     * Creates an instance of PreTokenizerSequence.\n     * @param {Object} config The configuration object for the pre-tokenizer sequence.\n     * @param {Object[]} config.pretokenizers An array of pre-tokenizer configurations.\n     */\n    constructor(config) {\n        super();\n        this.tokenizers = config.pretokenizers.map(x => PreTokenizer.fromConfig(x));\n    }\n\n    /**\n     * Applies each pre-tokenizer in the sequence to the input text in turn.\n     * @param {string|string[]} text The text(s) to pre-tokenize.\n     * @returns {string[]} The pre-tokenized text.\n     */\n    pre_tokenize_text(text) {\n        if (typeof text === 'string') {\n            text = [text];\n        }\n        // Use reduce to apply each tokenizer to the text\n        return this.tokenizers.reduce((preTokenizedText, tokenizer) => {\n            return tokenizer.pre_tokenize(preTokenizedText);\n        }, text);\n    }\n}\n\n/**\n * Splits a string of text by whitespace characters into individual tokens.\n * @extends PreTokenizer\n */\nclass WhitespaceSplit extends PreTokenizer {\n    /**\n     * Creates an instance of WhitespaceSplit.\n     * @param {Object} config The configuration object for the pre-tokenizer sequence.\n     */\n    constructor(config) {\n        super();\n    }\n    /**\n     * Pre-tokenizes the input text by splitting it on whitespace characters.\n     * @param {string} text The text to be pre-tokenized.\n     * @returns {string[]} An array of tokens produced by splitting the input text on whitespace.\n     */\n    pre_tokenize_text(text) {\n        return whitespace_split(text);\n    }\n}\n\nclass PreTrainedTokenizer extends _utils_core_js__WEBPACK_IMPORTED_MODULE_0__.Callable {\n    /**\n     * Create a new PreTrainedTokenizer instance.\n     * @param {Object} tokenizerJSON The JSON of the tokenizer.\n     * @param {Object} tokenizerConfig The config of the tokenizer.\n     */\n    constructor(tokenizerJSON, tokenizerConfig) {\n        super();\n\n        // Construct parts of the tokenizer from the JSON\n        this.normalizer = Normalizer.fromConfig(tokenizerJSON.normalizer);\n        this.pre_tokenizer = PreTokenizer.fromConfig(tokenizerJSON.pre_tokenizer);\n\n        // Convert the vocabulary to a map, if it exists\n        if (tokenizerJSON.model.vocab) {\n            if (!Array.isArray(tokenizerJSON.model.vocab)) {\n                tokenizerJSON.model.vocab = Object.entries(tokenizerJSON.model.vocab);\n            }\n            tokenizerJSON.model.vocab = new Map(tokenizerJSON.model.vocab);\n        }\n        this.model = TokenizerModel.fromConfig(tokenizerJSON.model, tokenizerConfig);\n        this.post_processor = PostProcessor.fromConfig(tokenizerJSON.post_processor);\n\n        // TODO: maybe, allow this to be null; in which case, we use model as decoder too?\n        this.decoder = Decoder.fromConfig(tokenizerJSON.decoder);\n\n\n        // Another slight hack to add `end_of_word_suffix` (if present) to the decoder\n        // This is needed for cases where BPE model and ByteLevel decoder are used\n        // For more information, see https://github.com/xenova/transformers.js/issues/74\n        // TODO: save this to the decoder when exporting?\n        this.decoder.end_of_word_suffix = this.model.end_of_word_suffix;\n\n        // Add added_tokens to model\n        this.special_tokens = [];\n        this.all_special_ids = [];\n        this.added_tokens = [];\n        for (let addedToken of tokenizerJSON.added_tokens) {\n            let id = addedToken.id;\n            let content = addedToken.content;\n\n            this.added_tokens.push(content);\n\n            this.model.tokens_to_ids.set(content, id);\n            this.model.vocab[id] = content;\n\n            if (addedToken.special) {\n                this.special_tokens.push(content);\n                this.all_special_ids.push(id);\n            }\n        }\n\n        // Slight hack, but it prevents code duplication:\n        this.decoder.added_tokens = this.added_tokens;\n\n        this.added_tokens_regex = new RegExp(\n            '(' + this.added_tokens.map(_utils_core_js__WEBPACK_IMPORTED_MODULE_0__.escapeRegExp).join('|') + ')'\n        );\n\n        // Set mask token if present (otherwise will be undefined, which is fine)\n        this.mask_token = this.getToken(tokenizerConfig, 'mask_token');\n        this.mask_token_id = this.model.tokens_to_ids.get(this.mask_token);\n\n        this.pad_token = this.getToken(tokenizerConfig, 'pad_token', 'eos_token');\n        this.pad_token_id = this.model.tokens_to_ids.get(this.pad_token);\n\n        this.sep_token = this.getToken(tokenizerConfig, 'sep_token');\n        this.sep_token_id = this.model.tokens_to_ids.get(this.sep_token);\n\n        this.model_max_length = tokenizerConfig.model_max_length;\n\n        /** @type {boolean} Whether or not to strip the text when tokenizing (removing excess spaces before and after the string). */\n        this.remove_space = tokenizerConfig.remove_space;\n\n        this.clean_up_tokenization_spaces = tokenizerConfig.clean_up_tokenization_spaces ?? true;\n\n        // TODO allow user to change this\n        this.padding_side = 'right';\n    }\n\n    /**\n     * Returns the value of the first matching key in the tokenizer config object.\n     * @param {...string} keys One or more keys to search for in the tokenizer config object.\n     * @returns {string|null} The value associated with the first matching key, or null if no match is found.\n     * @throws {Error} If an object is found for a matching key and its __type property is not \"AddedToken\".\n     */\n    getToken(tokenizerConfig, ...keys) {\n        for (let key of keys) {\n            let item = tokenizerConfig[key];\n\n            if (!item) continue;\n\n            if (typeof item === 'object') {\n                if (item.__type === 'AddedToken') {\n                    return item.content;\n                } else {\n                    throw Error(`Unknown token: ${item}`);\n                }\n            } else {\n                return item;\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Loads a pre-trained tokenizer from the given `pretrained_model_name_or_path`. \n     * \n     * @param {string} pretrained_model_name_or_path The path to the pre-trained tokenizer.\n     * @param {PretrainedOptions} options Additional options for loading the tokenizer.\n     * \n     * @throws {Error} Throws an error if the tokenizer.json or tokenizer_config.json files are not found in the `pretrained_model_name_or_path`.\n     * @returns {Promise<PreTrainedTokenizer>} A new instance of the `PreTrainedTokenizer` class.\n     */\n    static async from_pretrained(pretrained_model_name_or_path, {\n        progress_callback = null,\n        config = null,\n        cache_dir = null,\n        local_files_only = false,\n        revision = 'main',\n    } = {}) {\n\n        let info = await loadTokenizer(pretrained_model_name_or_path, {\n            progress_callback,\n            config,\n            cache_dir,\n            local_files_only,\n            revision,\n        })\n\n        // @ts-ignore\n        return new this(...info);\n    }\n\n    /**\n     * This function can be overridden by a subclass to apply additional preprocessing\n     * to a model's input data.\n     * @param {Object} inputs An object containing input data as properties.\n     * @returns {Object} The modified inputs object.\n     */\n    prepare_model_inputs(inputs) {\n        return inputs;\n    }\n\n    /**\n     * Encode/tokenize the given text(s).\n     * @param {string|string[]} text The text to tokenize.\n     * @param {Object} options An optional object containing the following properties:\n     * @param {string|string[]} [options.text_pair=null] Optional second sequence to be encoded. If set, must be the same type as text.\n     * @param {boolean} [options.padding=false] Whether to pad the input sequences.\n     * @param {boolean} [options.truncation=null] Whether to truncate the input sequences.\n     * @param {number} [options.max_length=null] Maximum length of the returned list and optionally padding length.\n     * @param {boolean} [options.return_tensor=true] Whether to return the results as Tensors or arrays.\n     * @returns {{ input_ids: number[]|number[][]|Tensor, attention_mask: any[]|Tensor }} Object to be passed to the model.\n     */\n    _call(\n        // Required positional arguments\n        text,\n\n        // Optional keyword arguments\n        {\n            text_pair = null,\n            // add_special_tokens = true, // TODO\n            padding = false,\n            truncation = null,\n            max_length = null,\n            return_tensor = true, // Different to HF\n        } = {},\n    ) {\n\n        /** @type {number[]|number[][]|Tensor} */\n        let tokens;\n\n        if (Array.isArray(text)) {\n            if (text.length === 0) {\n                throw Error('text array must be non-empty')\n            }\n\n            if (text_pair !== null) {\n                if (!Array.isArray(text_pair)) {\n                    throw Error('text_pair must also be an array')\n\n                } else if (text.length !== text_pair.length) {\n                    throw Error('text and text_pair must have the same length')\n                }\n\n                tokens = text.map(\n                    (t, i) => this.encode(t, text_pair[i])\n                )\n\n            } else {\n                tokens = text.map(x => this.encode(x));\n            }\n\n        } else {\n            if (text === null) {\n                throw Error('text may not be null')\n            }\n\n            if (Array.isArray(text_pair)) {\n                throw Error('When specifying `text_pair`, since `text` is a string, `text_pair` must also be a string (i.e., not an array).')\n            }\n\n            // For single input, we just wrap in an array, and then unwrap later.\n            tokens = [this.encode(text, text_pair)];\n        }\n        // At this point, tokens is batched: [batch_size, tokens]\n        // However, array may be jagged. So, we pad to max_length\n\n        let maxLengthOfBatch = (0,_utils_maths_js__WEBPACK_IMPORTED_MODULE_2__.max)(tokens.map(x => x.length))[0];\n\n        // If null, we calculate max length from sequences\n        if (max_length === null) {\n            max_length = maxLengthOfBatch;\n        }\n\n        // Ensure it is less than model max length\n        max_length = Math.min(max_length, this.model_max_length)\n\n        /** @type {any[]|Tensor} */\n        let attention_mask = [];\n        if (padding || truncation) {\n            // Perform padding and/or truncation\n            for (let i = 0; i < tokens.length; ++i) {\n                if (tokens[i].length === max_length) {\n                    attention_mask.push(new Array(tokens[i].length).fill(1))\n                    continue;\n\n                } else if (tokens[i].length > max_length) {\n                    // possibly truncate\n                    if (truncation) {\n                        tokens[i] = tokens[i].slice(0, max_length);\n                    }\n                    attention_mask.push(new Array(tokens[i].length).fill(1))\n\n                } else { // t.length < max_length\n                    if (padding) {\n                        let diff = max_length - tokens[i].length;\n\n                        if (this.padding_side === 'right') {\n                            attention_mask.push(\n                                (new Array(tokens[i].length).fill(1)).concat(new Array(diff).fill(0))\n                            )\n                            tokens[i].push(...new Array(diff).fill(this.pad_token_id))\n                        } else { // left\n                            attention_mask.push(\n                                (new Array(diff).fill(0)).concat(new Array(tokens[i].length).fill(1))\n                            )\n                            tokens[i].unshift(...new Array(diff).fill(this.pad_token_id))\n                        }\n\n                    } else {\n                        attention_mask.push(new Array(tokens[i].length).fill(1))\n                    }\n                }\n            }\n        } else {\n            attention_mask = tokens.map(x => new Array(x.length).fill(1))\n        }\n\n        if (return_tensor) {\n            if (!(padding && truncation)) {\n                // Not, guaranteed that all items have same length, so\n                // we perform additional check\n\n                if (tokens.some(x => x.length !== tokens[0].length)) {\n                    throw Error(\n                        \"Unable to create tensor, you should probably activate truncation and/or padding \" +\n                        \"with 'padding=true' and 'truncation=true' to have batched tensors with the same length.\"\n                    )\n                }\n            }\n\n            // Now we actually convert to tensor\n            // NOTE: In the same way as the python library, we return a batched tensor, regardless of\n            // whether we have a single input or multiple inputs.\n            let dims = [tokens.length, tokens[0].length];\n\n            tokens = new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_3__.Tensor('int64',\n                BigInt64Array.from(tokens.flat().map(BigInt)),\n                dims\n            );\n\n            attention_mask = new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_3__.Tensor(\n                'int64',\n                BigInt64Array.from(attention_mask.flat().map(BigInt)),\n                dims\n            )\n        } else {\n            // If not returning a tensor, we match the input type\n            if (!Array.isArray(text)) {\n                // Input was not batched, so we unwrap\n                tokens = tokens[0];\n                attention_mask = attention_mask[0];\n            }\n        }\n\n\n        // Finally, add attention mask, and possibly model-specific parameters\n        let modelInputs = {\n            input_ids: tokens,\n            attention_mask: attention_mask\n        }\n\n        // Optional post-processing\n        modelInputs = this.prepare_model_inputs(modelInputs);\n\n        return modelInputs\n    }\n\n    /**\n     * Encodes a single text using the preprocessor pipeline of the tokenizer.\n     *\n     * @param {string|null} text The text to encode.\n     * @returns {string[]|null} The encoded tokens.\n     */\n    _encode_text(text) {\n        if (text === null) return null;\n\n        // Actual function which does encoding, for a single text\n        // First, we take care of special tokens. Needed to avoid issues arising from\n        // normalization and/or pretokenization (which may not preserve special tokens)\n        const sections = text.split(this.added_tokens_regex).filter(x => x);\n\n        let tokens = sections.map(x => {\n            if (this.added_tokens.includes(x)) {\n                // Ignore added tokens\n                return x\n            } else {\n                if (this.remove_space === true) {\n                    x = x.trim().split(/\\s+/).join(' ');\n                }\n\n                if (this.normalizer !== null) {\n                    x = this.normalizer(x);\n                }\n\n                let sectionTokens = (this.pre_tokenizer !== null) ? this.pre_tokenizer(x) : [x];\n\n                let tokens = this.model(sectionTokens);\n\n                return tokens;\n            }\n        }).flat();\n\n        return tokens;\n    }\n\n    /**\n     * Encodes a single text or a pair of texts using the model's tokenizer.\n     *\n     * @param {string} text The text to encode.\n     * @param {string|null} text_pair The optional second text to encode.\n     * @returns {number[]} An array of token IDs representing the encoded text(s).\n     */\n    encode(text, text_pair = null) {\n        // Function called by users to encode possibly multiple texts\n        let tokens = this._encode_text(text);\n        let tokens2 = this._encode_text(text_pair);\n\n        let combinedTokens = (this.post_processor !== null)\n            ? this.post_processor(tokens, tokens2)\n            : (0,_utils_core_js__WEBPACK_IMPORTED_MODULE_0__.mergeArrays)(tokens ?? [], tokens2 ?? []);\n\n        let ids = this.model.convert_tokens_to_ids(combinedTokens);\n        return ids;\n    }\n\n    /**\n     * Decode a batch of tokenized sequences.\n     * @param {number[][]} batch List of tokenized input sequences.\n     * @param {Object} decode_args (Optional) Object with decoding arguments.\n     * @returns {string[]} List of decoded sequences.\n     */\n    batch_decode(batch, decode_args = {}) {\n        return batch.map(x => this.decode(x, decode_args));\n    }\n\n    /**\n     * Decodes a sequence of token IDs back to a string.\n     *\n     * @param {number[]} token_ids List of token IDs to decode.\n     * @param {Object} [decode_args={}]\n     * @param {boolean} [decode_args.skip_special_tokens=false] If true, special tokens are removed from the output string.\n     * @param {boolean} [decode_args.clean_up_tokenization_spaces=true] If true, spaces before punctuations and abbreviated forms are removed.\n     *\n     * @returns {string} The decoded string.\n     * @throws {Error} If `token_ids` is not a non-empty array of integers.\n     */\n    decode(\n        token_ids,\n        decode_args = {},\n    ) {\n        if (!Array.isArray(token_ids) || token_ids.length === 0 || !(0,_utils_core_js__WEBPACK_IMPORTED_MODULE_0__.isIntegralNumber)(token_ids[0])) {\n            throw Error(\"token_ids must be a non-empty array of integers.\");\n        }\n\n        return this.decode_single(token_ids, decode_args)\n    }\n\n    /**\n     * Decode a single list of token ids to a string.\n     * @param {number[]} token_ids List of token ids to decode\n     * @param {Object} decode_args Optional arguments for decoding\n     * @param {boolean} [decode_args.skip_special_tokens=false] Whether to skip special tokens during decoding\n     * @param {boolean} [decode_args.clean_up_tokenization_spaces=null] Whether to clean up tokenization spaces during decoding.\n     * If null, the value is set to `this.decoder.cleanup` if it exists, falling back to `this.clean_up_tokenization_spaces` if it exists, falling back to `true`.\n     * @returns {string} The decoded string\n     */\n    decode_single(\n        token_ids,\n        {\n            skip_special_tokens = false,\n            clean_up_tokenization_spaces = null,\n        }\n    ) {\n        let tokens = this.model.convert_ids_to_tokens(token_ids);\n        if (skip_special_tokens) {\n            tokens = tokens.filter(x => !this.special_tokens.includes(x));\n        }\n\n        /** @type {string} */\n        let decoded = this.decoder(tokens);\n\n\n        // Slight hack, but prevents having to pass `skip_special_tokens` to\n        // each call to `decode`, which would lead to code duplication.\n        if (this.decoder.end_of_word_suffix) {\n            decoded = decoded.replaceAll(this.decoder.end_of_word_suffix, ' ');\n            if (skip_special_tokens) {\n                decoded = decoded.trim();\n            }\n        }\n\n        if (clean_up_tokenization_spaces ?? this.clean_up_tokenization_spaces) {\n            decoded = clean_up_tokenization(decoded);\n        }\n\n        return decoded;\n    }\n\n}\n\n/**\n* Helper method for adding `token_type_ids` to model inputs\n* @param {Object} inputs An object containing the input ids and attention mask.\n* @returns {Object} The prepared inputs object.\n*/\nfunction add_token_types(inputs) {\n    // TODO ensure correctness when token pair is present\n    if (inputs.input_ids instanceof _utils_tensor_js__WEBPACK_IMPORTED_MODULE_3__.Tensor) {\n        inputs.token_type_ids = new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_3__.Tensor(\n            'int64',\n            new BigInt64Array(inputs.input_ids.data.length),\n            inputs.input_ids.dims\n        )\n    } else if (Array.isArray(inputs.input_ids)) {\n\n        if (Array.isArray(inputs.input_ids[0])) {\n            // This means input is batched, so we need to batch the token_type_ids as well\n            inputs.token_type_ids = inputs.input_ids.map(\n                x => new Array(x.length).fill(0)\n            )\n        } else {\n            inputs.token_type_ids = new Array(inputs.input_ids.length).fill(0);\n        }\n    } else {\n        throw new Error('Input ids must be a Tensor or an Array')\n    }\n\n    return inputs;\n}\n\n/**\n * BertTokenizer is a class used to tokenize text for BERT models.\n * @extends PreTrainedTokenizer\n */\nclass BertTokenizer extends PreTrainedTokenizer {\n    /** @type {add_token_types} */\n    prepare_model_inputs(inputs) {\n        return add_token_types(inputs);\n    }\n}\n/**\n * Albert tokenizer\n * @extends PreTrainedTokenizer\n */\nclass AlbertTokenizer extends PreTrainedTokenizer {\n    /** @type {add_token_types} */\n    prepare_model_inputs(inputs) {\n        return add_token_types(inputs);\n    }\n}\nclass MobileBertTokenizer extends PreTrainedTokenizer {\n    /** @type {add_token_types} */\n    prepare_model_inputs(inputs) {\n        return add_token_types(inputs);\n    }\n}\nclass SqueezeBertTokenizer extends PreTrainedTokenizer {\n    /** @type {add_token_types} */\n    prepare_model_inputs(inputs) {\n        return add_token_types(inputs);\n    }\n}\nclass DistilBertTokenizer extends PreTrainedTokenizer { }\nclass T5Tokenizer extends PreTrainedTokenizer { }\nclass GPT2Tokenizer extends PreTrainedTokenizer { }\nclass BartTokenizer extends PreTrainedTokenizer { }\nclass RobertaTokenizer extends PreTrainedTokenizer { }\n\nclass BloomTokenizer extends PreTrainedTokenizer { }\nclass LlamaTokenizer extends PreTrainedTokenizer { }\n\nclass XLMRobertaTokenizer extends PreTrainedTokenizer { }\nclass MPNetTokenizer extends PreTrainedTokenizer { }\n\nclass FalconTokenizer extends PreTrainedTokenizer {\n    /** @type {add_token_types} */\n    prepare_model_inputs(inputs) {\n        return add_token_types(inputs);\n    }\n}\n\nclass GPTNeoXTokenizer extends PreTrainedTokenizer { }\n\n/**\n * The NllbTokenizer class is used to tokenize text for NLLB (\"No Language Left Behind\") models.\n * \n * No Language Left Behind (NLLB) is a first-of-its-kind, AI breakthrough project\n * that open-sources models capable of delivering high-quality translations directly\n * between any pair of 200+ languages — including low-resource languages like Asturian,\n * Luganda, Urdu and more. It aims to help people communicate with anyone, anywhere,\n * regardless of their language preferences. For more information, check out their\n * [paper](https://arxiv.org/abs/2207.04672).\n * \n * For a list of supported languages (along with their language codes),\n * @see {@link https://github.com/facebookresearch/flores/blob/main/flores200/README.md#languages-in-flores-200}\n */\nclass NllbTokenizer extends PreTrainedTokenizer {\n\n    constructor(tokenizerJSON, tokenizerConfig) {\n        super(tokenizerJSON, tokenizerConfig);\n\n        this.languageRegex = /^[a-z]{3}_[A-Z][a-z]{3}$/;\n        this.language_codes = this.special_tokens.filter(x => this.languageRegex.test(x));\n    }\n\n    /**\n     * Helper function to build translation inputs for an `NllbTokenizer`.\n     * @param {string|string[]} raw_inputs The text to tokenize.\n     * @param {Object} tokenizer_options Options to be sent to the tokenizer\n     * @param {Object} generate_kwargs Generation options.\n     * @returns {Object} Object to be passed to the model.\n     */\n    _build_translation_inputs(raw_inputs, tokenizer_options, generate_kwargs) {\n\n\n        // Check that the target language is valid:\n        if (!this.language_codes.includes(generate_kwargs.tgt_lang)) {\n            throw new Error(`Target language code \"${generate_kwargs.tgt_lang}\" is not valid. Must be one of: {${this.language_codes.join(', ')}}`);\n        }\n\n        // Allow `src_lang` to be optional. If not set, we'll use the tokenizer's default.\n        if (generate_kwargs.src_lang !== undefined) {\n            // Check that the source language is valid:\n            if (!this.language_codes.includes(generate_kwargs.src_lang)) {\n                throw new Error(`Source language code \"${generate_kwargs.src_lang}\" is not valid. Must be one of: {${this.language_codes.join(', ')}}`);\n            }\n\n            // In the same way as the Python library, we override the post-processor\n            // to force the source language to be first:\n            for (let item of this.post_processor.config.single) {\n                if ('SpecialToken' in item && this.languageRegex.test(item.SpecialToken.id)) {\n                    item.SpecialToken.id = generate_kwargs.src_lang;\n                    break;\n                }\n            }\n        }\n\n        // Override the `forced_bos_token_id` to force the correct language\n        generate_kwargs.forced_bos_token_id = this.model.convert_tokens_to_ids([generate_kwargs.tgt_lang])[0];\n\n        return this._call(raw_inputs, tokenizer_options);\n    }\n}\n\n\nconst WHISPER_LANGUAGES = [\n    [\"en\", \"english\"],\n    [\"zh\", \"chinese\"],\n    [\"de\", \"german\"],\n    [\"es\", \"spanish\"],\n    [\"ru\", \"russian\"],\n    [\"ko\", \"korean\"],\n    [\"fr\", \"french\"],\n    [\"ja\", \"japanese\"],\n    [\"pt\", \"portuguese\"],\n    [\"tr\", \"turkish\"],\n    [\"pl\", \"polish\"],\n    [\"ca\", \"catalan\"],\n    [\"nl\", \"dutch\"],\n    [\"ar\", \"arabic\"],\n    [\"sv\", \"swedish\"],\n    [\"it\", \"italian\"],\n    [\"id\", \"indonesian\"],\n    [\"hi\", \"hindi\"],\n    [\"fi\", \"finnish\"],\n    [\"vi\", \"vietnamese\"],\n    [\"he\", \"hebrew\"],\n    [\"uk\", \"ukrainian\"],\n    [\"el\", \"greek\"],\n    [\"ms\", \"malay\"],\n    [\"cs\", \"czech\"],\n    [\"ro\", \"romanian\"],\n    [\"da\", \"danish\"],\n    [\"hu\", \"hungarian\"],\n    [\"ta\", \"tamil\"],\n    [\"no\", \"norwegian\"],\n    [\"th\", \"thai\"],\n    [\"ur\", \"urdu\"],\n    [\"hr\", \"croatian\"],\n    [\"bg\", \"bulgarian\"],\n    [\"lt\", \"lithuanian\"],\n    [\"la\", \"latin\"],\n    [\"mi\", \"maori\"],\n    [\"ml\", \"malayalam\"],\n    [\"cy\", \"welsh\"],\n    [\"sk\", \"slovak\"],\n    [\"te\", \"telugu\"],\n    [\"fa\", \"persian\"],\n    [\"lv\", \"latvian\"],\n    [\"bn\", \"bengali\"],\n    [\"sr\", \"serbian\"],\n    [\"az\", \"azerbaijani\"],\n    [\"sl\", \"slovenian\"],\n    [\"kn\", \"kannada\"],\n    [\"et\", \"estonian\"],\n    [\"mk\", \"macedonian\"],\n    [\"br\", \"breton\"],\n    [\"eu\", \"basque\"],\n    [\"is\", \"icelandic\"],\n    [\"hy\", \"armenian\"],\n    [\"ne\", \"nepali\"],\n    [\"mn\", \"mongolian\"],\n    [\"bs\", \"bosnian\"],\n    [\"kk\", \"kazakh\"],\n    [\"sq\", \"albanian\"],\n    [\"sw\", \"swahili\"],\n    [\"gl\", \"galician\"],\n    [\"mr\", \"marathi\"],\n    [\"pa\", \"punjabi\"],\n    [\"si\", \"sinhala\"],\n    [\"km\", \"khmer\"],\n    [\"sn\", \"shona\"],\n    [\"yo\", \"yoruba\"],\n    [\"so\", \"somali\"],\n    [\"af\", \"afrikaans\"],\n    [\"oc\", \"occitan\"],\n    [\"ka\", \"georgian\"],\n    [\"be\", \"belarusian\"],\n    [\"tg\", \"tajik\"],\n    [\"sd\", \"sindhi\"],\n    [\"gu\", \"gujarati\"],\n    [\"am\", \"amharic\"],\n    [\"yi\", \"yiddish\"],\n    [\"lo\", \"lao\"],\n    [\"uz\", \"uzbek\"],\n    [\"fo\", \"faroese\"],\n    [\"ht\", \"haitian creole\"],\n    [\"ps\", \"pashto\"],\n    [\"tk\", \"turkmen\"],\n    [\"nn\", \"nynorsk\"],\n    [\"mt\", \"maltese\"],\n    [\"sa\", \"sanskrit\"],\n    [\"lb\", \"luxembourgish\"],\n    [\"my\", \"myanmar\"],\n    [\"bo\", \"tibetan\"],\n    [\"tl\", \"tagalog\"],\n    [\"mg\", \"malagasy\"],\n    [\"as\", \"assamese\"],\n    [\"tt\", \"tatar\"],\n    [\"haw\", \"hawaiian\"],\n    [\"ln\", \"lingala\"],\n    [\"ha\", \"hausa\"],\n    [\"ba\", \"bashkir\"],\n    [\"jw\", \"javanese\"],\n    [\"su\", \"sundanese\"],\n]\n\n// @ts-ignore\nconst WHISPER_LANGUAGE_MAPPING = new Map(WHISPER_LANGUAGES);\n// @ts-ignore\nconst WHISPER_TO_LANGUAGE_CODE_MAPPING = new Map([\n    ...WHISPER_LANGUAGES.map(([k, v]) => [v, k]),\n    ...[\n        [\"burmese\", \"my\"],\n        [\"valencian\", \"ca\"],\n        [\"flemish\", \"nl\"],\n        [\"haitian\", \"ht\"],\n        [\"letzeburgesch\", \"lb\"],\n        [\"pushto\", \"ps\"],\n        [\"panjabi\", \"pa\"],\n        [\"moldavian\", \"ro\"],\n        [\"moldovan\", \"ro\"],\n        [\"sinhalese\", \"si\"],\n        [\"castilian\", \"es\"],\n    ]\n]);\n\n/**\n * WhisperTokenizer tokenizer\n * @extends PreTrainedTokenizer\n */\nclass WhisperTokenizer extends PreTrainedTokenizer {\n\n    /**\n     * Decodes automatic speech recognition (ASR) sequences.\n     * @param {Array<{tokens: number[], token_timestamps?: number[], stride: number[]}>} sequences The sequences to decode.\n     * @param {Object} options The options to use for decoding.\n     * @returns {Array<string|{chunks?: undefined|Array<{language: string|null, timestamp: Array<number|null>, text: string}>}>} The decoded sequences.\n     */\n    _decode_asr(sequences, {\n        return_timestamps = false,\n        return_language = false,\n        time_precision = null,\n        force_full_sequences = true\n    } = {}) {\n        // Set force_full_sequences=false if you want streaming\n        // TODO add support for `return_language`\n\n        // Internal method meant to only be used by asr pipeline.\n        // Handles all the little quirks specific to whisper to handle\n        // the various options not allowed in other seq2seq models\n\n        // =========== Overview ============\n        // - iterate over all outputs\n        // - all tokens within output\n        // - Each token can be\n        //   - language token\n        //   - special token\n        //   - timestamp token\n        //   - text token\n        // - We accumulate the text tokens.\n        // - We split on end timestamps\n        // - Lots of complexity comes from stride and timestamps\n\n        if (time_precision === null) {\n            throw Error(\"Must specify time_precision\")\n        }\n        let last_language = null;\n\n        const returnWordTimestamps = return_timestamps === \"word\";\n\n        function new_chunk() {\n            return { \"language\": last_language, \"timestamp\": [null, null], \"text\": \"\" };\n        }\n\n        // Welcome to the state machine!\n        const chunks = [];\n        let chunk = new_chunk();\n        let time_offset = 0.0;\n        const timestamp_begin = this.model.convert_tokens_to_ids([\"<|notimestamps|>\"])[0] + 1;\n\n        let previous_tokens = [];\n        let previous_token_timestamps = [];\n\n        let skip = false;\n        let right_stride_start = null;\n\n\n        const all_special_ids = new Set(this.all_special_ids);\n\n        for (let output of sequences) {\n            // NOTE: python version has batches, so it uses [0]\n            const token_ids = output.tokens;\n            const token_timestamps = returnWordTimestamps ? output.token_timestamps : null;\n\n            // These keep track of timestamps within strides, which need\n            // to be skipped and resolve all tokens in a single chunk.\n            let last_timestamp = null;\n            let first_timestamp = timestamp_begin;\n\n            if (\"stride\" in output) {\n                const [chunk_len, stride_left, stride_right] = output.stride;\n\n                // Offset the timings to account for the other `model_outputs`.\n                time_offset -= stride_left;\n                right_stride_start = chunk_len - stride_right;\n\n                // Keeping track of timestamps within strides\n                // We're going to NOT split on those, and delay until we're\n                // out of BOTH stride. Otherwise lots of issues occur and\n                // corner cases\n                if (stride_left) {\n                    first_timestamp = stride_left / time_precision + timestamp_begin;\n                }\n\n                if (stride_right) {\n                    for (let i = token_ids.length - 1; i >= 0; --i) {\n                        const token = token_ids[i];\n                        if (token >= timestamp_begin) {\n                            // There can be several token in the right stride\n                            // But the last one is ALWAYS going to be skipped\n                            if (last_timestamp !== null && (token - timestamp_begin) * time_precision < right_stride_start) {\n                                break;\n                            }\n                            last_timestamp = token;\n                        }\n                    }\n                }\n            }\n\n            let current_tokens = [];\n            let current_token_timestamps = [];\n\n            // - all tokens within output\n            for (let i = 0; i < token_ids.length; ++i) {\n                const token = token_ids[i];\n                // 4 possible states for each token\n                // - 1/ Language code\n                // - 2/ all other special tokens (which we ignore)\n                // - 3/ Timestamp\n                // - 4/ Regular text\n\n                if (all_special_ids.has(token)) {\n                    const text = this.decode([token]);\n                    if (text[0] === \"[\" && text[text.length - 1] === \"]\") {\n                        const language = WHISPER_LANGUAGE_MAPPING.get(text.slice(1, -1));\n\n                        if (language !== undefined) {\n                            // 1/ Indeed some language\n                            // TODO Handle when language is different from the previous\n                            // one, and we cannot use timestamped tokens to create chunks\n                            if (last_language !== null && language !== last_language && !return_timestamps) {\n                                previous_tokens.push(current_tokens);\n                                const resolved_tokens = this.findLongestCommonSequence(previous_tokens)[0];\n                                const resolved_text = this.decode(resolved_tokens);\n                                chunk.text = resolved_text;\n                                chunks.push(chunk);\n\n                                // Flush all our temporary context\n                                previous_tokens = [];\n                                current_tokens = [];\n                                chunk = new_chunk();\n                            }\n\n                            last_language = chunk.language = language;\n                        } else {\n                            // 2/ This is a regular special token, ignoring it\n                        }\n                    }\n                } else if (token >= timestamp_begin) {\n                    // 3/ Timestamp token\n                    const time = (token - timestamp_begin) * time_precision + time_offset;\n                    const rounded_time = (0,_utils_maths_js__WEBPACK_IMPORTED_MODULE_2__.round)(time, 2);\n\n                    if (last_timestamp !== null && token >= last_timestamp) {\n                        // Whisper outputted a timestamp token, but it falls within\n                        // our stride, so we're going to skip it for the time being\n                        // and resolve this later\n                        // Skip is necessary because timestamp tokens always come\n                        // by pair, so we need to skip the next one too (which would mark the start of another chunk).\n                        skip = true;\n                    } else if (skip || (previous_tokens.length > 0 && token < first_timestamp)) {\n                        skip = false;\n                    } else if (chunk.timestamp[0] === null) {\n                        chunk.timestamp[0] = rounded_time;\n                    } else {\n                        // This is the end of the timestamp chunk\n                        if (rounded_time === chunk.timestamp[0]) {\n                            // This is a bug in timestamp token output\n                            // where we're taking the duplicate token\n                            // as a stop where it should be a start.\n                            // This is an issue in the underlying model output\n                            // Let's just skip it so it becomes de-factor a start agin\n                        } else {\n                            chunk.timestamp[1] = rounded_time;\n\n                            // Handling merges\n                            previous_tokens.push(current_tokens)\n\n                            if (returnWordTimestamps) {\n                                previous_token_timestamps.push(current_token_timestamps);\n                            }\n                            const [resolved_tokens, resolved_token_timestamps] = this.findLongestCommonSequence(\n                                previous_tokens, previous_token_timestamps\n                            )\n\n                            const resolved_text = this.decode(resolved_tokens)\n                            chunk.text = resolved_text\n\n                            if (returnWordTimestamps) {\n                                chunk.words = this.collateWordTimestamps(\n                                    resolved_tokens, resolved_token_timestamps, last_language,\n                                )\n                            }\n\n                            chunks.push(chunk)\n\n                            // Flush all our temporary context\n                            previous_tokens = []\n                            current_tokens = []\n                            previous_token_timestamps = []\n                            current_token_timestamps = []\n                            chunk = new_chunk()\n                        }\n                    }\n\n                } else {\n                    // 4/ Regular token\n                    // We just append to the list of all tokens so we can handle\n                    // merges later and decode into text.\n                    current_tokens.push(token)\n\n                    if (returnWordTimestamps) {\n                        let start_time = (0,_utils_maths_js__WEBPACK_IMPORTED_MODULE_2__.round)(token_timestamps[i] + time_offset, 2);\n\n                        let end_time;\n                        if (i + 1 < token_timestamps.length) {\n                            end_time = (0,_utils_maths_js__WEBPACK_IMPORTED_MODULE_2__.round)(token_timestamps[i + 1] + time_offset, 2);\n                        } else {\n                            // should never happen\n                            end_time = null;\n                        }\n                        current_token_timestamps.push([start_time, end_time]);\n                    }\n\n                }\n            }\n\n            if ('stride' in output) {\n                const [chunk_len, stride_left, stride_right] = output.stride;\n                time_offset += chunk_len - stride_right\n            }\n\n            // Leftover tokens\n            if (current_tokens.length > 0) {\n                previous_tokens.push(current_tokens)\n                if (returnWordTimestamps) {\n                    previous_token_timestamps.push(current_token_timestamps);\n                }\n            } else if (previous_tokens.every(p => p.length === 0)) {\n                // Flushing previous tokens (END)\"\n                chunk = new_chunk()\n                previous_tokens = []\n                current_tokens = []\n                previous_token_timestamps = [];\n                current_token_timestamps = [];\n            }\n\n        }\n\n        if (previous_tokens.length > 0) {\n            if (force_full_sequences && return_timestamps) {\n                // Last token should always be timestamps, so there shouldn't be\n                // leftover\n                throw new Error(\n                    \"Whisper did not predict an ending timestamp, which can happen if audio is cut off in the middle of a word. \" +\n                    \"Also make sure WhisperTimeStampLogitsProcessor was used during generation.\"\n                );\n            }\n\n            // Happens when we don't use timestamps\n            const [resolved_tokens, resolved_token_timestamps] = this.findLongestCommonSequence(previous_tokens, previous_token_timestamps);\n\n            // Flushing previous tokens (FINAL)\n            const resolved_text = this.decode(resolved_tokens);\n            chunk.text = resolved_text;\n            if (returnWordTimestamps) {\n                chunk.words = this.collateWordTimestamps(\n                    resolved_tokens, resolved_token_timestamps, last_language,\n                )\n            }\n            chunks.push(chunk);\n        }\n\n        let optional = Object.create(null);\n\n        // Preparing and cleaning up the pipeline output\n        const full_text = chunks.map(chunk => chunk.text).join('');\n        if (return_timestamps || return_language) {\n            for (let i = 0; i < chunks.length; ++i) {\n                const chunk = chunks[i];\n                if (!return_timestamps) {\n                    delete chunk[\"timestamp\"];\n                }\n\n                if (!return_language) {\n                    delete chunk[\"language\"];\n                }\n            }\n            if (returnWordTimestamps) {\n                let new_chunks = [];\n                for (let chunk of chunks) {\n                    for (let word of chunk.words) {\n                        new_chunks.push(word);\n                    }\n                }\n                optional = { \"chunks\": new_chunks };\n            } else {\n                optional = { \"chunks\": chunks };\n            }\n        }\n        return [full_text, optional];\n\n    }\n\n    /**\n     * Finds the longest common sequence among the provided sequences.\n     * @param {number[][]} sequences An array of sequences of token ids to compare.\n     * @returns {number[][]} The longest common sequence found.\n     * @throws {Error} If there is a bug within the function.\n     * @private\n     */\n    findLongestCommonSequence(sequences, token_timestamp_sequences = null) {\n        // It would be much harder to do O(n) because of fault tolerance.\n        // We actually have a really good property which is that the total sequence\n        // MUST be those subsequences in order.\n        // If token_timestamp_sequences is provided, will split those sequences in\n        // exactly the same way.\n        let leftSequence = sequences[0];\n        let leftLength = leftSequence.length;\n        let totalSequence = [];\n\n        const use_token_timestamp_sequences = Array.isArray(token_timestamp_sequences) && token_timestamp_sequences.length > 0;\n        let total_token_timestamp_sequence = use_token_timestamp_sequences ? [] : null;\n        let left_token_timestamp_sequence = use_token_timestamp_sequences ? token_timestamp_sequences[0] : null;\n        for (let i = 1; i < sequences.length; ++i) {\n            const rightSequence = sequences[i];\n            let max = 0.0;\n            let maxIndices = [leftLength, leftLength, 0, 0];\n            // Here we're sliding matches\n            // [a, b, c, d]\n            //          [c, d, f]\n            // =        [c] == [d]\n\n            // [a, b, c, d]\n            //       [c, d, f]\n            // =     [c, d] == [c, d]\n\n\n            // [a, b, c, d]\n            //    [c, d, f]\n\n            // =  [b, c, d] == [c, d, f]\n\n            // [a, b, c, d]\n            // [c, d, f]\n\n            // [a, b, c] == [c, d, f]\n\n            // [a, b, c, d]\n            // [d, f]\n\n            // [a, b] == [d, f]\n\n            // [a, b, c, d]\n            // [f]\n\n            // [a] == [f]\n\n            const rightLength = rightSequence.length;\n            for (let j = 1; j < leftLength + rightLength; ++j) {\n                const eps = j / 10000.0;\n                const leftStart = Math.max(0, leftLength - j);\n                const leftStop = Math.min(leftLength, leftLength + rightLength - j);\n                const left = leftSequence.slice(leftStart, leftStop);\n                const rightStart = Math.max(0, j - leftLength);\n                const rightStop = Math.min(rightLength, j);\n                const right = rightSequence.slice(rightStart, rightStop);\n                if (left.length !== right.length) {\n                    throw new Error(\"There is a bug within whisper `decode_asr` function, please report it. Dropping to prevent bad inference.\");\n                }\n                const matches = left.filter((elem, idx) => elem === right[idx]).length;\n                const matching = matches / j + eps;\n                if (matches > 1 && matching > max) {\n                    max = matching;\n                    maxIndices = [leftStart, leftStop, rightStart, rightStop];\n                }\n            }\n            const [leftStart, leftStop, rightStart, rightStop] = maxIndices;\n            const leftMid = Math.floor((leftStop + leftStart) / 2);\n            const rightMid = Math.floor((rightStop + rightStart) / 2);\n            totalSequence.push(...leftSequence.slice(0, leftMid));\n            leftSequence = rightSequence.slice(rightMid);\n            leftLength = leftSequence.length;\n\n            if (use_token_timestamp_sequences) {\n                total_token_timestamp_sequence.push(...left_token_timestamp_sequence.slice(0, leftMid));\n                left_token_timestamp_sequence = token_timestamp_sequences[i].slice(rightMid);\n            }\n        }\n        totalSequence.push(...leftSequence);\n\n        if (use_token_timestamp_sequences) {\n            total_token_timestamp_sequence.push(...left_token_timestamp_sequence);\n            return [totalSequence, total_token_timestamp_sequence];\n        } else {\n            return [totalSequence, []];\n        }\n    }\n\n    /** @private */\n    collateWordTimestamps(tokens, token_timestamps, language) {\n\n        let [words, _, token_indices] = this.combineTokensIntoWords(tokens, language);\n\n        let timings = [];\n        for (let i = 0; i < words.length; ++i) {\n            const indices = token_indices[i];\n            timings.push({\n                text: words[i],\n                timestamp: [\n                    token_timestamps[indices.at(0)][0],\n                    token_timestamps[indices.at(-1)][1],\n                ],\n            });\n        }\n        return timings;\n    }\n\n    /**\n     * Groups tokens by word. Returns a tuple containing a list of strings with the words,\n     * and a list of `token_id` sequences with the tokens making up each word.\n     * @param {number[]} tokens \n     * @param {string} [language] \n     * @param {string} prepend_punctionations \n     * @param {string} append_punctuations \n     * \n     * @private\n     */\n    combineTokensIntoWords(tokens, language, prepend_punctionations = \"\\\"'“¡¿([{-\", append_punctuations = \"\\\"'.。,，!！?？:：”)]}、\") {\n        language = language ?? 'english';\n\n        let words, word_tokens, token_indices;\n\n        if ([\"chinese\", \"japanese\", \"thai\", \"lao\", \"myanmar\"].includes(language)) {\n            // These languages don't typically use spaces.\n\n            [words, word_tokens, token_indices] = this.splitTokensOnUnicode(tokens)\n        } else {\n            [words, word_tokens, token_indices] = this.splitTokensOnSpaces(tokens)\n        }\n\n        return this.mergePunctuations(words, word_tokens, token_indices, prepend_punctionations, append_punctuations);\n    }\n\n    /** @type {PreTrainedTokenizer['decode']} */\n    decode(\n        token_ids,\n        decode_args,\n    ) {\n        let text;\n        // @ts-ignore\n        if (decode_args && decode_args.decode_with_timestamps) {\n            text = this.decodeWithTimestamps(token_ids, decode_args);\n        } else {\n            text = super.decode(token_ids, decode_args);\n        }\n        // TODO: implement offsets\n        // if (decode_args.output_offsets) {\n        //     let offsets = this.computeOffsets\n        // }\n        return text;\n    }\n\n    /**\n     * @param {number[]} token_ids List of token IDs to decode.\n     * @param {Object} decode_args Optional arguments for decoding\n     * @private\n     */\n    decodeWithTimestamps(token_ids, decode_args) {\n        const time_precision = decode_args?.time_precision ?? 0.02;\n\n        const timestamp_begin = Array.from(this.all_special_ids).at(-1) + 1;\n        /**@type {Array} */\n        let outputs = [[]];\n        for (let token of token_ids) {\n            if (token >= timestamp_begin) {\n                let timestamp = (token - timestamp_begin) * time_precision;\n                timestamp = (0,_utils_maths_js__WEBPACK_IMPORTED_MODULE_2__.round)(timestamp, 2);\n                outputs.push(`<|${timestamp}|>`);\n                outputs.push([]);\n            } else {\n                outputs[outputs.length - 1].push(token);\n            }\n        }\n        outputs = outputs.map(\n            s => {\n                if (typeof s === 'string') {\n                    return s;\n                } else {\n                    return super.decode(s, decode_args);\n                }\n            }\n        )\n\n        return outputs.join('');\n    }\n\n    /**\n     * Combine tokens into words by splitting at any position where the tokens are decoded as valid unicode points.\n     * @param {number[]} tokens \n     * @returns {*}\n     * @private\n     */\n    splitTokensOnUnicode(tokens) {\n        const decoded_full = this.decode(tokens, {\n            // @ts-ignore\n            decode_with_timestamps: true,\n        });\n        const replacement_char = '\\uFFFD';\n\n        let words = []\n        let word_tokens = []\n        let token_indices = []\n        let current_tokens = []\n        let current_indices = []\n        let unicode_offset = 0\n\n        for (let token_idx = 0; token_idx < tokens.length; ++token_idx) {\n            const token = tokens[token_idx];\n\n            current_tokens.push(token);\n            current_indices.push(token_idx);\n\n            const decoded = this.decode(current_tokens, {\n                // @ts-ignore\n                decode_with_timestamps: true,\n            });\n\n            if (!decoded.includes(replacement_char) || decoded_full[unicode_offset + decoded.indexOf(replacement_char)] === replacement_char) {\n                words.push(decoded)\n                word_tokens.push(current_tokens)\n                token_indices.push(current_indices)\n                current_tokens = []\n                current_indices = []\n                unicode_offset += decoded.length;\n            }\n\n        }\n\n        return [words, word_tokens, token_indices]\n    }\n\n    /**\n     * Combine tokens into words by splitting at whitespace and punctuation tokens.\n     * @param {number[]} tokens \n     * @private\n     */\n    splitTokensOnSpaces(tokens) {\n\n        let [subwords, subword_tokens_list, subword_indices_list] = this.splitTokensOnUnicode(tokens);\n\n        let words = []\n        let word_tokens = []\n        let token_indices = []\n\n        const punctuationRegex = new RegExp(`[${PUNCTUATION_REGEX}]`)\n\n        for (let i = 0; i < subwords.length; ++i) {\n\n            const subword = subwords[i];\n            const subword_tokens = subword_tokens_list[i];\n            const subword_indices = subword_indices_list[i];\n\n            // @ts-ignore\n            const special = subword_tokens[0] >= this.model.tokens_to_ids.get('<|endoftext|>');\n            const with_space = subword.startsWith(' ');\n            const trimmed = subword.trim();\n            const punctuation = punctuationRegex.test(trimmed);\n\n            if (special || with_space || punctuation || words.length === 0) {\n                words.push(subword);\n                word_tokens.push(subword_tokens);\n                token_indices.push(subword_indices);\n            } else {\n                const ix = words.length - 1;\n                words[ix] += subword;\n                word_tokens[ix].push(...subword_tokens);\n                token_indices[ix].push(...subword_indices);\n            }\n        }\n\n        return [words, word_tokens, token_indices];\n\n    }\n\n    /**\n     * Merges punctuation tokens with neighboring words.\n     * @param {string[]} words \n     * @param {number[][]} tokens \n     * @param {number[][]} indices \n     * @param {string} prepended \n     * @param {string} appended \n     * @private\n     */\n    mergePunctuations(words, tokens, indices, prepended, appended) {\n\n        let newWords = structuredClone(words);\n        let newTokens = structuredClone(tokens);\n        let newIndices = structuredClone(indices);\n\n\n        // prepend punctuations\n        let i = newWords.length - 2;\n        let j = newWords.length - 1;\n\n        while (i >= 0) {\n            if (newWords[i].startsWith(' ') && prepended.includes(newWords[i].trim())) {\n                newWords[j] = newWords[i] + newWords[j];\n                newTokens[j] = (0,_utils_core_js__WEBPACK_IMPORTED_MODULE_0__.mergeArrays)(newTokens[i], newTokens[j]);\n                newIndices[j] = (0,_utils_core_js__WEBPACK_IMPORTED_MODULE_0__.mergeArrays)(newIndices[i], newIndices[j]);\n                newWords[i] = '';\n                newTokens[i] = [];\n                newIndices[i] = [];\n            } else {\n                j = i;\n            }\n            --i;\n        }\n\n        // append punctuations\n        i = 0;\n        j = 1;\n        while (j < newWords.length) {\n            if (!newWords[i].endsWith(' ') && appended.includes(newWords[j])) {\n                newWords[i] += newWords[j];\n                newTokens[i] = (0,_utils_core_js__WEBPACK_IMPORTED_MODULE_0__.mergeArrays)(newTokens[i], newTokens[j]);\n                newIndices[i] = (0,_utils_core_js__WEBPACK_IMPORTED_MODULE_0__.mergeArrays)(newIndices[i], newIndices[j]);\n                newWords[j] = '';\n                newTokens[j] = [];\n                newIndices[j] = [];\n            } else {\n                i = j;\n            }\n            ++j;\n        }\n\n        return [\n            newWords.filter(x => x),\n            newTokens.filter(x => x.length > 0),\n            newIndices.filter(x => x.length > 0),\n        ]\n    }\n\n    /**\n     * Helper function to build translation inputs for a `WhisperTokenizer`,\n     * depending on the language, task, and whether to predict timestamp tokens.\n     * \n     * Used to override the prefix tokens appended to the start of the label sequence.\n     * \n     * **Example: Get ids for a language**\n     * ```javascript\n     * // instantiate the tokenizer and set the prefix token to Spanish\n     * let tokenizer = await WhisperTokenizer.from_pretrained('Xenova/whisper-tiny');\n     * let forced_decoder_ids = tokenizer.get_decoder_prompt_ids({ language: 'spanish' });\n     * // [(1, 50262), (2, 50363)]\n     * ```\n     * \n     * @param {Object} options Options to generate the decoder prompt.\n     * @param {string} [options.language] The language of the transcription text.\n     * The corresponding language id token is appended to the start of the sequence for multilingual\n     * speech recognition and speech translation tasks, e.g. for \"Spanish\" the token \"<|es|>\" is appended\n     * to the start of sequence.\n     * @param {string} [options.task] Task identifier to append at the start of sequence (if any).\n     * This should be used for mulitlingual fine-tuning, with \"transcribe\" for speech recognition and\n     * \"translate\" for speech translation.\n     * @param {boolean} [options.no_timestamps] Whether to add the <|notimestamps|> token at the start of the sequence.\n     * @returns {number[][]} The decoder prompt ids.\n     */\n    get_decoder_prompt_ids({\n        language = null,\n        task = null,\n        no_timestamps = true,\n    } = {}) {\n\n        // <|lang_id|> <|task|> <|notimestamps|>\n\n        let forced_decoder_ids = [];\n\n        if (language) {\n            // User wishes to specify the language\n            language = language.toLowerCase();\n\n            // Map to code from user-friendly name (e.g., \"english\" -> \"en\")\n            let language_code = WHISPER_TO_LANGUAGE_CODE_MAPPING.get(language);\n\n            if (language_code === undefined) {\n                // User provided something that is not a language name\n\n                if (WHISPER_LANGUAGE_MAPPING.has(language)) {\n                    // User provided the language code directly (e.g., \"en\")\n                    language_code = language;\n\n                } else {\n                    // User provided something that is not a language code or name\n                    const is_language_code = language.length === 2;\n                    const langs = is_language_code ? WHISPER_LANGUAGE_MAPPING.keys() : WHISPER_LANGUAGE_MAPPING.values();\n\n                    throw new Error(`Language \"${language}\" is not supported. Must be one of: ${JSON.stringify(langs)}`);\n                }\n            }\n\n            let language_token_id = this.model.tokens_to_ids.get(`<|${language_code}|>`);\n            if (language_token_id === undefined) {\n                throw new Error(`Unable to find language \"${language_code}\" in model vocabulary. Please report this issue at https://github.com/xenova/transformers.js/issues/new/choose.`)\n            }\n\n            forced_decoder_ids.push(language_token_id);\n        } else {\n            // No token will be forced, which leaves the model to predict the language\n            forced_decoder_ids.push(null);\n        }\n\n        if (task) {\n            task = task.toLowerCase();\n            if (task !== 'transcribe' && task !== 'translate') {\n                throw new Error(`Task \"${task}\" is not supported. Must be one of: [\"transcribe\", \"translate\"]`);\n            }\n\n            let task_token_id = this.model.tokens_to_ids.get(`<|${task}|>`);\n            if (task_token_id === undefined) {\n                throw new Error(`Unable to find task \"${task}\" in model vocabulary. Please report this issue at https://github.com/xenova/transformers.js/issues/new/choose.`)\n            }\n\n            forced_decoder_ids.push(task_token_id);\n        } else {\n            // No token will be forced, which leaves the model to predict the task\n            forced_decoder_ids.push(null);\n        }\n\n        if (no_timestamps) {\n            let no_timestamps_id = this.model.tokens_to_ids.get(`<|notimestamps|>`);\n            if (no_timestamps_id === undefined) {\n                throw new Error('Unable to find \"<|notimestamps|>\" in model vocabulary. Please report this issue at https://github.com/xenova/transformers.js/issues/new/choose.')\n            }\n\n            forced_decoder_ids.push(no_timestamps_id);\n        }\n\n        return forced_decoder_ids.map((x, i) => [i + 1, x]).filter(x => x[1] !== null);\n\n    }\n}\nclass CodeGenTokenizer extends PreTrainedTokenizer { }\nclass CLIPTokenizer extends PreTrainedTokenizer { }\n\n\n/**\n * @todo This model is not yet supported by Hugging Face's \"fast\" tokenizers library (https://github.com/huggingface/tokenizers).\n * Therefore, this implementation (which is based on fast tokenizers) may produce slightly inaccurate results.\n */\nclass MarianTokenizer extends PreTrainedTokenizer {\n    /**\n     * Create a new MarianTokenizer instance.\n     * @param {Object} tokenizerJSON The JSON of the tokenizer.\n     * @param {Object} tokenizerConfig The config of the tokenizer.\n     */\n    constructor(tokenizerJSON, tokenizerConfig) {\n        super(tokenizerJSON, tokenizerConfig);\n\n        this.languageRegex = /^(>>\\w+<<)\\s*/g;\n\n        this.supported_language_codes = this.model.vocab.filter(\n            x => this.languageRegex.test(x)\n        );\n\n        console.warn('WARNING: `MarianTokenizer` is not yet supported by Hugging Face\\'s \"fast\" tokenizers library. Therefore, you may experience slightly inaccurate results.')\n    }\n\n    /**\n     * Encodes a single text. Overriding this method is necessary since the language codes\n     * must be removed before encoding with sentencepiece model.\n     * @see https://github.com/huggingface/transformers/blob/12d51db243a00726a548a43cc333390ebae731e3/src/transformers/models/marian/tokenization_marian.py#L204-L213\n     *\n     * @param {string|null} text The text to encode.\n     * @returns {Array} The encoded tokens.\n     */\n    _encode_text(text) {\n        if (text === null) return null;\n\n        // Check if text starts with language code:\n        let [matchInfo, ...remainder] = text.trim().split(this.languageRegex);\n\n        if (remainder.length === 0) {\n            // No language code, encode normally\n            return super._encode_text(matchInfo);\n\n        } else if (remainder.length === 2) {\n            // Text starts with language code, so we do not encode it with sentencepiece.\n            let [language, text] = remainder;\n\n            if (!this.supported_language_codes.includes(language)) {\n                console.warn(`Unsupported language code \"${language}\" detected, which may lead to unexpected behavior. Should be one of: ${JSON.stringify(this.supported_language_codes)}`)\n            }\n            return (0,_utils_core_js__WEBPACK_IMPORTED_MODULE_0__.mergeArrays)([language], super._encode_text(text));\n        }\n    }\n\n}\n\n/**\n * A trie structure to efficiently store and search for strings.\n */\nclass CharTrie {\n    constructor() {\n        this.root = CharTrieNode.default();\n    }\n\n    /**\n     * Adds one or more `texts` to the trie.\n     * @param {string[]} texts The strings to add to the trie.\n     */\n    extend(texts) {\n        for (let text of texts) {\n            this.push(text);\n        }\n    }\n\n    /**\n     * Adds one or more `texts` to the trie.\n     * @param {*} text The strings to add to the trie.\n     */\n    push(text) {\n        let node = this.root;\n        for (let ch of text) {\n            let child = node.children.get(ch);\n            if (child === undefined) {\n                child = CharTrieNode.default();\n                node.children.set(ch, child);\n            }\n            node = child;\n        }\n        node.isLeaf = true;\n    }\n\n    /**\n     * Searches the trie for all strings with a common prefix of `text`.\n     * @param {string} text The common prefix to search for.\n     * @yields {string} Each string in the trie that has `text` as a prefix.\n     */\n    *commonPrefixSearch(text) {\n        let node = this.root;\n        let prefix = \"\";\n        for (let i = 0; i < text.length && node !== undefined; ++i) {\n            const ch = text[i];\n            prefix += ch;\n            node = node.children.get(ch);\n            if (node !== undefined && node.isLeaf) {\n                yield prefix;\n            }\n        }\n    }\n}\n\n/**\n * Represents a node in a character trie.\n * @param {boolean} isLeaf Whether the node is a leaf node or not.\n * @param {Map<string, CharTrieNode>} children A map containing the node's children, where the key is a character and the value is a `CharTrieNode`.\n */\nclass CharTrieNode {\n    constructor(isLeaf, children) {\n        this.isLeaf = isLeaf;\n        this.children = children;\n    }\n\n    /**\n     * Returns a new `CharTrieNode` instance with default values.\n     * @returns {CharTrieNode} A new `CharTrieNode` instance with `isLeaf` set to `false` and an empty `children` map.\n     */\n    static default() {\n        return new CharTrieNode(false, new Map());\n    }\n}\n\nclass TokenLattice {\n    /**\n     * Creates a new TokenLattice instance.\n     *\n     * @param {string} sentence The input sentence to be tokenized.\n     * @param {number} bosTokenId The beginning-of-sequence token ID.\n     * @param {number} eosTokenId The end-of-sequence token ID.\n     */\n    constructor(sentence, bosTokenId, eosTokenId) {\n        this.sentence = sentence;\n        this.len = sentence.length;\n        this.bosTokenId = bosTokenId;\n        this.eosTokenId = eosTokenId;\n        this.nodes = [];\n        this.beginNodes = new Array(this.len + 1);\n        this.endNodes = new Array(this.len + 1);\n        for (let i = 0; i < this.len + 1; ++i) {\n            this.beginNodes[i] = [];\n            this.endNodes[i] = [];\n        }\n        const bos = new TokenLatticeNode(this.bosTokenId, 0, 0, 0, 0.0);\n        const eos = new TokenLatticeNode(this.eosTokenId, 1, this.len, 0, 0.0);\n        this.nodes.push(bos.clone());\n        this.nodes.push(eos.clone());\n        this.beginNodes[this.len].push(eos);\n        this.endNodes[0].push(bos);\n    }\n\n    /**\n     * Inserts a new token node into the token lattice.\n     *\n     * @param {number} pos The starting position of the token.\n     * @param {number} length The length of the token.\n     * @param {number} score The score of the token.\n     * @param {number} tokenId The token ID of the token.\n     */\n    insert(pos, length, score, tokenId) {\n        const nodeId = this.nodes.length;\n        const node = new TokenLatticeNode(tokenId, nodeId, pos, length, score);\n        this.beginNodes[pos].push(node);\n        this.endNodes[pos + length].push(node);\n        this.nodes.push(node);\n    }\n\n    /**\n     * Implements the Viterbi algorithm to compute the most likely sequence of tokens.\n     *\n     * @returns {TokenLatticeNode[]} The array of nodes representing the most likely sequence of tokens.\n     */\n    viterbi() {\n        const len = this.len;\n        let pos = 0;\n        while (pos <= len) {\n            if (this.beginNodes[pos].length == 0) {\n                return [];\n            }\n            for (let rnode of this.beginNodes[pos]) {\n                rnode.prev = null;\n                let bestScore = 0.0;\n                let bestNode = null;\n                for (let lnode of this.endNodes[pos]) {\n                    const score = lnode.backtraceScore + rnode.score;\n                    if (bestNode === null || score > bestScore) {\n                        bestNode = lnode.clone();\n                        bestScore = score;\n                    }\n                }\n\n                if (bestNode !== null) {\n                    rnode.prev = bestNode;\n                    rnode.backtraceScore = bestScore;\n                } else {\n                    return [];\n                }\n            }\n            ++pos;\n        }\n\n        const results = [];\n        const root = this.beginNodes[len][0];\n        const prev = root.prev;\n        if (prev === null) {\n            return [];\n        }\n\n        let node = prev.clone();\n        while (node.prev !== null) {\n            results.push(node.clone());\n            const n = node.clone();\n            node = n.prev.clone();\n        }\n\n        results.reverse();\n        return results;\n    }\n\n    /**\n     * @param {TokenLatticeNode} node\n     * @returns {string} The array of nodes representing the most likely sequence of tokens.\n     */\n    piece(node) {\n        return this.sentence.slice(node.pos, node.pos + node.length);\n    }\n\n    /**\n     * @returns {Array} The array of nodes representing the most likely sequence of tokens.\n     */\n    tokens() {\n        const nodes = this.viterbi();\n        return nodes.map(x => this.piece(x));\n    }\n\n    /**\n     * @returns {Array} The array of nodes representing the most likely sequence of tokens.\n     */\n    tokenIds() {\n        const nodes = this.viterbi();\n        return nodes.map(x => x.tokenId);\n    }\n}\nclass TokenLatticeNode {\n    /**\n     * Represents a node in a token lattice for a given sentence.\n     * @param {number} tokenId The ID of the token associated with this node.\n     * @param {number} nodeId The ID of this node.\n     * @param {number} pos The starting position of the token in the sentence.\n     * @param {number} length The length of the token.\n     * @param {number} score The score associated with the token.\n     */\n    constructor(tokenId, nodeId, pos, length, score) {\n        this.tokenId = tokenId;\n        this.nodeId = nodeId;\n        this.pos = pos;\n        this.length = length;\n        this.score = score;\n        this.prev = null;\n        this.backtraceScore = 0.0;\n    }\n\n    /**\n     * Returns a clone of this node.\n     * @returns {TokenLatticeNode} A clone of this node.\n     */\n    clone() {\n        const n = new TokenLatticeNode(this.tokenId, this.nodeId, this.pos, this.length, this.score);\n        n.prev = this.prev;\n        n.backtraceScore = this.backtraceScore;\n        return n;\n    }\n}\n\n/**\n * Helper class which is used to instantiate pretrained tokenizers with the `from_pretrained` function.\n * The chosen tokenizer class is determined by the type specified in the tokenizer config.\n * \n * @example\n * let tokenizer = await AutoTokenizer.from_pretrained('bert-base-uncased');\n */\nclass AutoTokenizer {\n    static TOKENIZER_CLASS_MAPPING = {\n        'T5Tokenizer': T5Tokenizer,\n        'DistilBertTokenizer': DistilBertTokenizer,\n        'BertTokenizer': BertTokenizer,\n        'MobileBertTokenizer': MobileBertTokenizer,\n        'SqueezeBertTokenizer': SqueezeBertTokenizer,\n        'AlbertTokenizer': AlbertTokenizer,\n        'GPT2Tokenizer': GPT2Tokenizer,\n        'BartTokenizer': BartTokenizer,\n        'RobertaTokenizer': RobertaTokenizer,\n        'WhisperTokenizer': WhisperTokenizer,\n        'CodeGenTokenizer': CodeGenTokenizer,\n        'CLIPTokenizer': CLIPTokenizer,\n        'MarianTokenizer': MarianTokenizer,\n        'BloomTokenizer': BloomTokenizer,\n        'NllbTokenizer': NllbTokenizer,\n        'LlamaTokenizer': LlamaTokenizer,\n        'XLMRobertaTokenizer': XLMRobertaTokenizer,\n        'MPNetTokenizer': MPNetTokenizer,\n        'FalconTokenizer': FalconTokenizer,\n        'GPTNeoXTokenizer': GPTNeoXTokenizer,\n\n        // Base case:\n        'PreTrainedTokenizer': PreTrainedTokenizer,\n    }\n\n\n    /**\n     * Instantiate one of the tokenizer classes of the library from a pretrained model.\n     * \n     * The tokenizer class to instantiate is selected based on the `tokenizer_class` property of the config object\n     * (either passed as an argument or loaded from `pretrained_model_name_or_path` if possible)\n     * \n     * @param {string} pretrained_model_name_or_path The name or path of the pretrained model. Can be either:\n     * - A string, the *model id* of a pretrained tokenizer hosted inside a model repo on huggingface.co.\n     *   Valid model ids can be located at the root-level, like `bert-base-uncased`, or namespaced under a\n     *   user or organization name, like `dbmdz/bert-base-german-cased`.\n     * - A path to a *directory* containing tokenizer files, e.g., `./my_model_directory/`.\n     * @param {PretrainedOptions} options Additional options for loading the tokenizer.\n     * \n     * @returns {Promise<PreTrainedTokenizer>} A new instance of the PreTrainedTokenizer class.\n     */\n    static async from_pretrained(pretrained_model_name_or_path, {\n        quantized = true,\n        progress_callback = null,\n        config = null,\n        cache_dir = null,\n        local_files_only = false,\n        revision = 'main',\n    } = {}) {\n\n        let [tokenizerJSON, tokenizerConfig] = await loadTokenizer(pretrained_model_name_or_path, {\n            quantized,\n            progress_callback,\n            config,\n            cache_dir,\n            local_files_only,\n            revision,\n        })\n\n        // Some tokenizers are saved with the \"Fast\" suffix, so we remove that if present.\n        let tokenizerName = tokenizerConfig.tokenizer_class.replace(/Fast$/, '');\n\n        let cls = this.TOKENIZER_CLASS_MAPPING[tokenizerName];\n        if (!cls) {\n            console.warn(`Unknown tokenizer class \"${tokenizerName}\", attempting to construct from base class.`);\n            cls = PreTrainedTokenizer;\n        }\n        return new cls(tokenizerJSON, tokenizerConfig);\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHhlbm92YS90cmFuc2Zvcm1lcnMvc3JjL3Rva2VuaXplcnMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZ0JBQWdCO0FBQzVCO0FBQ0E7QUFDQSxTQUFTLFlBQVk7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBUXlCOztBQUlEOztBQUUyQjtBQUNSOztBQUUzQztBQUNBLGFBQWEsNENBQTRDO0FBQ3pEOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxtQkFBbUI7QUFDOUIsYUFBYSxnQkFBZ0I7QUFDN0I7QUFDQTs7QUFFQTtBQUNBLFFBQVEsMkRBQVk7QUFDcEIsUUFBUSwyREFBWTtBQUNwQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEIsYUFBYSxvQkFBb0I7QUFDakM7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdURBQXVELGNBQWM7O0FBRXJFLE1BQU07QUFDTjs7QUFFQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxLQUFLO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhLFVBQVU7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsK0JBQStCLEVB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O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxtQkFBbUI7QUFDbEM7QUFDQSxpQkFBaUIsOEJBQThCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLElBQUk7O0FBRVY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFEQUFxRCxjQUFjO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90cmFuc2Zvcm1lcnNqcy1wbGF5Z3JvdW5kLy4vbm9kZV9tb2R1bGVzL0B4ZW5vdmEvdHJhbnNmb3JtZXJzL3NyYy90b2tlbml6ZXJzLmpzPzQ4MDYiXSwic291cmNlc0NvbnRlbnQiOlsiXG4vKipcbiAqIEBmaWxlIFRva2VuaXplcnMgYXJlIHVzZWQgdG8gcHJlcGFyZSB0ZXh0dWFsIGlucHV0cyBmb3IgYSBtb2RlbC5cbiAqIFxuICogKipFeGFtcGxlOioqIENyZWF0ZSBhbiBgQXV0b1Rva2VuaXplcmAgYW5kIHVzZSBpdCB0byB0b2tlbml6ZSBhIHNlbnRlbmNlLlxuICogVGhpcyB3aWxsIGF1dG9tYXRpY2FsbHkgZGV0ZWN0IHRoZSB0b2tlbml6ZXIgdHlwZSBiYXNlZCBvbiB0aGUgdG9rZW5pemVyIGNsYXNzIGRlZmluZWQgaW4gYHRva2VuaXplci5qc29uYC5cbiAqIGBgYGphdmFzY3JpcHRcbiAqIGltcG9ydCB7IEF1dG9Ub2tlbml6ZXIgfSBmcm9tICdAeGVub3ZhL3RyYW5zZm9ybWVycyc7XG4gKiBcbiAqIGxldCB0b2tlbml6ZXIgPSBhd2FpdCBBdXRvVG9rZW5pemVyLmZyb21fcHJldHJhaW5lZCgnYmVydC1iYXNlLXVuY2FzZWQnKTtcbiAqIGxldCB7IGlucHV0X2lkcyB9ID0gYXdhaXQgdG9rZW5pemVyKCdJIGxvdmUgdHJhbnNmb3JtZXJzIScpO1xuICogLy8gVGVuc29yIHtcbiAqIC8vICAgZGF0YTogQmlnSW50NjRBcnJheSg2KSBbMTAxbiwgMTA0NW4sIDIyOTNuLCAxOTA4MW4sIDk5OW4sIDEwMm5dLFxuICogLy8gICBkaW1zOiBbMSwgNl0sXG4gKiAvLyAgIHR5cGU6ICdpbnQ2NCcsXG4gKiAvLyAgIHNpemU6IDYsXG4gKiAvLyB9XG4gKiBgYGBcbiAqIFxuICogQG1vZHVsZSB0b2tlbml6ZXJzXG4gKi9cblxuaW1wb3J0IHtcbiAgICBDYWxsYWJsZSxcbiAgICByZXZlcnNlRGljdGlvbmFyeSxcbiAgICBlc2NhcGVSZWdFeHAsXG4gICAgaXNJbnRlZ3JhbE51bWJlcixcbiAgICBtZXJnZUFycmF5cyxcbn0gZnJvbSAnLi91dGlscy9jb3JlLmpzJztcblxuaW1wb3J0IHtcbiAgICBnZXRNb2RlbEpTT04sXG59IGZyb20gJy4vdXRpbHMvaHViLmpzJztcblxuaW1wb3J0IHsgbWF4LCBtaW4sIHJvdW5kIH0gZnJvbSAnLi91dGlscy9tYXRocy5qcyc7XG5pbXBvcnQgeyBUZW5zb3IgfSBmcm9tICcuL3V0aWxzL3RlbnNvci5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYge2ltcG9ydCgnLi91dGlscy9odWIuanMnKS5QcmV0cmFpbmVkT3B0aW9uc30gUHJldHJhaW5lZE9wdGlvbnNcbiAqL1xuXG4vKipcbiAqIExvYWRzIGEgdG9rZW5pemVyIGZyb20gdGhlIHNwZWNpZmllZCBwYXRoLlxuICogQHBhcmFtIHtzdHJpbmd9IHByZXRyYWluZWRfbW9kZWxfbmFtZV9vcl9wYXRoIFRoZSBwYXRoIHRvIHRoZSB0b2tlbml6ZXIgZGlyZWN0b3J5LlxuICogQHBhcmFtIHtQcmV0cmFpbmVkT3B0aW9uc30gb3B0aW9ucyBBZGRpdGlvbmFsIG9wdGlvbnMgZm9yIGxvYWRpbmcgdGhlIHRva2VuaXplci5cbiAqIEByZXR1cm5zIHtQcm9taXNlPEFycmF5Pn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgbG9hZGVkIHRva2VuaXplci5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gbG9hZFRva2VuaXplcihwcmV0cmFpbmVkX21vZGVsX25hbWVfb3JfcGF0aCwgb3B0aW9ucykge1xuXG4gICAgbGV0IGluZm8gPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgIGdldE1vZGVsSlNPTihwcmV0cmFpbmVkX21vZGVsX25hbWVfb3JfcGF0aCwgJ3Rva2VuaXplci5qc29uJywgdHJ1ZSwgb3B0aW9ucyksXG4gICAgICAgIGdldE1vZGVsSlNPTihwcmV0cmFpbmVkX21vZGVsX25hbWVfb3JfcGF0aCwgJ3Rva2VuaXplcl9jb25maWcuanNvbicsIHRydWUsIG9wdGlvbnMpLFxuICAgIF0pXG4gICAgcmV0dXJuIGluZm87XG59XG5cbi8qKlxuICogSGVscGVyIG1ldGhvZCB0byBjb25zdHJ1Y3QgYSBwYXR0ZXJuIGZyb20gYSBjb25maWcgb2JqZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IHBhdHRlcm4gVGhlIHBhdHRlcm4gb2JqZWN0LlxuICogQHBhcmFtIHtib29sZWFufSBpbnZlcnQgV2hldGhlciB0byBpbnZlcnQgdGhlIHBhdHRlcm4gKG9ubHkgYXBwbGljYWJsZSBmb3IgUmVnZXggcGF0dGVybnMpLlxuICogQHJldHVybnMge1JlZ0V4cHxzdHJpbmd8bnVsbH0gVGhlIGNvbXBpbGVkIHBhdHRlcm4uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVBhdHRlcm4ocGF0dGVybiwgaW52ZXJ0ID0gdHJ1ZSkge1xuXG4gICAgaWYgKHBhdHRlcm4uUmVnZXgpIHtcbiAgICAgICAgLy8gTk9URTogaWYgaW52ZXJ0IGlzIHRydWUsIHdlIHdyYXAgdGhlIHBhdHRlcm4gaW4gYSBncm91cCBzbyB0aGF0IGl0IGlzIGtlcHQgd2hlbiBwZXJmb3JtaW5nIC5zcGxpdCgpXG4gICAgICAgIHJldHVybiBuZXcgUmVnRXhwKGludmVydCA/IHBhdHRlcm4uUmVnZXggOiBgKCR7cGF0dGVybi5SZWdleH0pYCwgJ2d1Jyk7XG5cbiAgICB9IGVsc2UgaWYgKHBhdHRlcm4uU3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBwYXR0ZXJuLlN0cmluZztcblxuICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUud2FybignVW5rbm93biBwYXR0ZXJuIHR5cGU6JywgcGF0dGVybilcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuXG4vKipcbiAqIENsZWFuIHVwIGEgbGlzdCBvZiBzaW1wbGUgRW5nbGlzaCB0b2tlbml6YXRpb24gYXJ0aWZhY3RzIGxpa2Ugc3BhY2VzIGJlZm9yZSBwdW5jdHVhdGlvbnMgYW5kIGFiYnJldmlhdGVkIGZvcm1zXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dCBUaGUgdGV4dCB0byBjbGVhbiB1cC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBjbGVhbmVkIHVwIHRleHQuXG4gKi9cbmZ1bmN0aW9uIGNsZWFuX3VwX3Rva2VuaXphdGlvbih0ZXh0KSB7XG4gICAgLy8gQ2xlYW4gdXAgYSBsaXN0IG9mIHNpbXBsZSBFbmdsaXNoIHRva2VuaXphdGlvbiBhcnRpZmFjdHNcbiAgICAvLyBsaWtlIHNwYWNlcyBiZWZvcmUgcHVuY3R1YXRpb25zIGFuZCBhYmJyZXZpYXRlZCBmb3Jtc1xuICAgIHJldHVybiB0ZXh0LnJlcGxhY2UoLyBcXC4vZywgJy4nKVxuICAgICAgICAucmVwbGFjZSgvIFxcPy9nLCAnPycpXG4gICAgICAgIC5yZXBsYWNlKC8gXFwhL2csICchJylcbiAgICAgICAgLnJlcGxhY2UoLyAsL2csICcsJylcbiAgICAgICAgLnJlcGxhY2UoLyBcXCcgL2csIFwiJ1wiKVxuICAgICAgICAucmVwbGFjZSgvIG5cXCd0L2csIFwibid0XCIpXG4gICAgICAgIC5yZXBsYWNlKC8gXFwnbS9nLCBcIidtXCIpXG4gICAgICAgIC5yZXBsYWNlKC8gXFwncy9nLCBcIidzXCIpXG4gICAgICAgIC5yZXBsYWNlKC8gXFwndmUvZywgXCIndmVcIilcbiAgICAgICAgLnJlcGxhY2UoLyBcXCdyZS9nLCBcIidyZVwiKTtcbn1cblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdG8gZnVzZSBjb25zZWN1dGl2ZSB2YWx1ZXMgaW4gYW4gYXJyYXkgZXF1YWwgdG8gdGhlIHNwZWNpZmllZCB2YWx1ZS5cbiAqIEBwYXJhbSB7QXJyYXl9IGFyciBUaGUgaW5wdXQgYXJyYXlcbiAqIEBwYXJhbSB7YW55fSB2YWx1ZSBUaGUgdmFsdWUgdG8gZnVzZSBvbi5cbiAqL1xuZnVuY3Rpb24gZnVzZShhcnIsIHZhbHVlKSB7XG4gICAgbGV0IGZ1c2VkID0gW107XG4gICAgbGV0IGkgPSAwO1xuICAgIHdoaWxlIChpIDwgYXJyLmxlbmd0aCkge1xuICAgICAgICBmdXNlZC5wdXNoKGFycltpXSlcbiAgICAgICAgaWYgKGFycltpXSAhPT0gdmFsdWUpIHtcbiAgICAgICAgICAgICsraTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgd2hpbGUgKGkgPCBhcnIubGVuZ3RoICYmIGFycltpXSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgICsraTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmdXNlZDtcbn1cblxuLyoqXG4gKiBTcGxpdCBhIHN0cmluZyBvbiB3aGl0ZXNwYWNlLlxuICogQHBhcmFtIHtzdHJpbmd9IHRleHQgVGhlIHRleHQgdG8gc3BsaXQuXG4gKiBAcmV0dXJucyB7c3RyaW5nW119IFRoZSBzcGxpdCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIHdoaXRlc3BhY2Vfc3BsaXQodGV4dCkge1xuICAgIHJldHVybiB0ZXh0Lm1hdGNoKC9cXFMrL2cpIHx8IFtdO1xufVxuXG5jb25zdCBQVU5DVFVBVElPTl9SRUdFWCA9ICdcXFxccHtQfVxcXFx1MDAyMS1cXFxcdTAwMkZcXFxcdTAwM0EtXFxcXHUwMDQwXFxcXHUwMDVCLVxcXFx1MDA2MFxcXFx1MDA3Qi1cXFxcdTAwN0UnO1xuXG4vKipcbiAqIEFic3RyYWN0IGJhc2UgY2xhc3MgZm9yIHRva2VuaXplciBtb2RlbHMuXG4gKlxuICogQGV4dGVuZHMgQ2FsbGFibGVcbiAqL1xuZXhwb3J0IGNsYXNzIFRva2VuaXplck1vZGVsIGV4dGVuZHMgQ2FsbGFibGUge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgVG9rZW5pemVyTW9kZWwuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBUaGUgY29uZmlndXJhdGlvbiBvYmplY3QgZm9yIHRoZSBUb2tlbml6ZXJNb2RlbC5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5jb25maWcgPSBjb25maWc7XG5cbiAgICAgICAgLyoqIEB0eXBlIHtzdHJpbmdbXX0gKi9cbiAgICAgICAgdGhpcy52b2NhYiA9IFtdO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIG1hcHBpbmcgb2YgdG9rZW5zIHRvIGlkcy5cbiAgICAgICAgICogQHR5cGUge01hcDxzdHJpbmcsIG51bWJlcj59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnRva2Vuc190b19pZHMgPSBuZXcgTWFwKCk7XG5cbiAgICAgICAgdGhpcy51bmtfdG9rZW5faWQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMudW5rX3Rva2VuID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmVuZF9vZl93b3JkX3N1ZmZpeCA9IHVuZGVmaW5lZDtcblxuICAgICAgICAvKiogQHR5cGUge2Jvb2xlYW59IFdoZXRoZXIgdG8gZnVzZSB1bmtub3duIHRva2VucyB3aGVuIGVuY29kaW5nLiBEZWZhdWx0cyB0byBmYWxzZS4gKi9cbiAgICAgICAgdGhpcy5mdXNlX3VuayA9IGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluc3RhbnRpYXRlcyBhIG5ldyBUb2tlbml6ZXJNb2RlbCBpbnN0YW5jZSBiYXNlZCBvbiB0aGUgY29uZmlndXJhdGlvbiBvYmplY3QgcHJvdmlkZWQuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBUaGUgY29uZmlndXJhdGlvbiBvYmplY3QgZm9yIHRoZSBUb2tlbml6ZXJNb2RlbC5cbiAgICAgKiBAcGFyYW0gey4uLip9IGFyZ3MgT3B0aW9uYWwgYXJndW1lbnRzIHRvIHBhc3MgdG8gdGhlIHNwZWNpZmljIFRva2VuaXplck1vZGVsIGNvbnN0cnVjdG9yLlxuICAgICAqIEByZXR1cm5zIHtUb2tlbml6ZXJNb2RlbH0gQSBuZXcgaW5zdGFuY2Ugb2YgYSBUb2tlbml6ZXJNb2RlbC5cbiAgICAgKiBAdGhyb3dzIFdpbGwgdGhyb3cgYW4gZXJyb3IgaWYgdGhlIFRva2VuaXplck1vZGVsIHR5cGUgaW4gdGhlIGNvbmZpZyBpcyBub3QgcmVjb2duaXplZC5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbUNvbmZpZyhjb25maWcsIC4uLmFyZ3MpIHtcbiAgICAgICAgc3dpdGNoIChjb25maWcudHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnV29yZFBpZWNlJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFdvcmRQaWVjZVRva2VuaXplcihjb25maWcpO1xuICAgICAgICAgICAgY2FzZSAnVW5pZ3JhbSc6XG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVW5pZ3JhbShjb25maWcsIC4uLmFyZ3MpO1xuXG4gICAgICAgICAgICBjYXNlICdCUEUnOlxuICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEJQRShjb25maWcsIC4uLmFyZ3MpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gVG9rZW5pemVyTW9kZWwgdHlwZTogJHtjb25maWcudHlwZX1gKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEludGVybmFsIGZ1bmN0aW9uIHRvIGNhbGwgdGhlIFRva2VuaXplck1vZGVsIGluc3RhbmNlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IHRva2VucyBUaGUgdG9rZW5zIHRvIGVuY29kZS5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyW119IFRoZSBlbmNvZGVkIHRva2VuIElEcy5cbiAgICAgKi9cbiAgICBfY2FsbCh0b2tlbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW5jb2RlKHRva2Vucyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRW5jb2RlcyBhIGxpc3Qgb2YgdG9rZW5zIGludG8gYSBsaXN0IG9mIHRva2VuIElEcy5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSB0b2tlbnMgVGhlIHRva2VucyB0byBlbmNvZGUuXG4gICAgICogQHJldHVybnMge251bWJlcltdfSBUaGUgZW5jb2RlZCB0b2tlbiBJRHMuXG4gICAgICogQHRocm93cyBXaWxsIHRocm93IGFuIGVycm9yIGlmIG5vdCBpbXBsZW1lbnRlZCBpbiBhIHN1YmNsYXNzLlxuICAgICAqL1xuICAgIGVuY29kZSh0b2tlbnMpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJlbmNvZGUgc2hvdWxkIGJlIGltcGxlbWVudGVkIGluIHN1YmNsYXNzLlwiKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGEgbGlzdCBvZiB0b2tlbnMgaW50byBhIGxpc3Qgb2YgdG9rZW4gSURzLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IHRva2VucyBUaGUgdG9rZW5zIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge251bWJlcltdfSBUaGUgY29udmVydGVkIHRva2VuIElEcy5cbiAgICAgKi9cbiAgICBjb252ZXJ0X3Rva2Vuc190b19pZHModG9rZW5zKSB7XG4gICAgICAgIGxldCBpZHMgPSB0b2tlbnMubWFwKHQgPT4gdGhpcy50b2tlbnNfdG9faWRzLmdldCh0KSA/PyB0aGlzLnVua190b2tlbl9pZCk7XG5cbiAgICAgICAgaWYgKHRoaXMuZnVzZV91bmspIHtcbiAgICAgICAgICAgIC8vIEZ1c2UgdW5rbm93biB0b2tlbnNcbiAgICAgICAgICAgIGlkcyA9IGZ1c2UoaWRzLCB0aGlzLnVua190b2tlbl9pZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlkcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBhIGxpc3Qgb2YgdG9rZW4gSURzIGludG8gYSBsaXN0IG9mIHRva2Vucy5cbiAgICAgKiBAcGFyYW0ge251bWJlcltdfSBpZHMgVGhlIHRva2VuIElEcyB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmdbXX0gVGhlIGNvbnZlcnRlZCB0b2tlbnMuXG4gICAgICovXG4gICAgY29udmVydF9pZHNfdG9fdG9rZW5zKGlkcykge1xuICAgICAgICByZXR1cm4gaWRzLm1hcChpID0+IHRoaXMudm9jYWJbaV0gPz8gdGhpcy51bmtfdG9rZW4pO1xuICAgIH1cbn1cblxuLyoqXG4gKiBBIHN1YmNsYXNzIG9mIFRva2VuaXplck1vZGVsIHRoYXQgdXNlcyBXb3JkUGllY2UgZW5jb2RpbmcgdG8gZW5jb2RlIHRva2Vucy5cbiAqIEBleHRlbmRzIFRva2VuaXplck1vZGVsXG4gKi9cbmNsYXNzIFdvcmRQaWVjZVRva2VuaXplciBleHRlbmRzIFRva2VuaXplck1vZGVsIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIFRoZSBjb25maWd1cmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge01hcDxzdHJpbmcsIG51bWJlcj59IGNvbmZpZy52b2NhYiBBIG1hcHBpbmcgb2YgdG9rZW5zIHRvIGlkcy5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29uZmlnLnVua190b2tlbiBUaGUgdW5rbm93biB0b2tlbiBzdHJpbmcuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbmZpZy5jb250aW51aW5nX3N1YndvcmRfcHJlZml4IFRoZSBwcmVmaXggdG8gdXNlIGZvciBjb250aW51aW5nIHN1YndvcmRzLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgICAgICBzdXBlcihjb25maWcpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBtYXBwaW5nIG9mIHRva2VucyB0byBpZHMuXG4gICAgICAgICAqIEB0eXBlIHtNYXA8c3RyaW5nLCBudW1iZXI+fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy50b2tlbnNfdG9faWRzID0gY29uZmlnLnZvY2FiO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgaWQgb2YgdGhlIHVua25vd24gdG9rZW4uXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnVua190b2tlbl9pZCA9IHRoaXMudG9rZW5zX3RvX2lkcy5nZXQoY29uZmlnLnVua190b2tlbik7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB1bmtub3duIHRva2VuIHN0cmluZy5cbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudW5rX3Rva2VuID0gY29uZmlnLnVua190b2tlbjtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQW4gYXJyYXkgb2YgdG9rZW5zLlxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nW119XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnZvY2FiID0gbmV3IEFycmF5KHRoaXMudG9rZW5zX3RvX2lkcy5zaXplKTtcblxuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiB0aGlzLnRva2Vuc190b19pZHMpIHtcbiAgICAgICAgICAgIHRoaXMudm9jYWJbdmFsdWVdID0ga2V5O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRW5jb2RlcyBhbiBhcnJheSBvZiB0b2tlbnMgdXNpbmcgV29yZFBpZWNlIGVuY29kaW5nLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHRva2VucyBUaGUgdG9rZW5zIHRvIGVuY29kZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IEFuIGFycmF5IG9mIGVuY29kZWQgdG9rZW5zLlxuICAgICAqL1xuICAgIGVuY29kZSh0b2tlbnMpIHtcbiAgICAgICAgbGV0IG91dHB1dFRva2VucyA9IFtdO1xuICAgICAgICBmb3IgKGxldCB0b2tlbiBvZiB0b2tlbnMpIHtcbiAgICAgICAgICAgIGxldCBjaGFycyA9IFsuLi50b2tlbl07XG4gICAgICAgICAgICAvLyBUT0RPIGFkZFxuICAgICAgICAgICAgLy8gaWYgbGVuKGNoYXJzKSA+IHNlbGYubWF4X2lucHV0X2NoYXJzX3Blcl93b3JkOlxuICAgICAgICAgICAgLy8gICAgIG91dHB1dF90b2tlbnMuYXBwZW5kKHNlbGYudW5rX3Rva2VuKVxuICAgICAgICAgICAgLy8gICAgIGNvbnRpbnVlXG5cbiAgICAgICAgICAgIGxldCBpc1Vua25vd24gPSBmYWxzZTtcbiAgICAgICAgICAgIGxldCBzdGFydCA9IDA7XG4gICAgICAgICAgICBsZXQgc3ViVG9rZW5zID0gW107XG5cbiAgICAgICAgICAgIHdoaWxlIChzdGFydCA8IGNoYXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGxldCBlbmQgPSBjaGFycy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgbGV0IGN1cnJlbnRTdWJzdHJpbmcgPSBudWxsO1xuICAgICAgICAgICAgICAgIHdoaWxlIChzdGFydCA8IGVuZCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgc3Vic3RyID0gY2hhcnMuc2xpY2Uoc3RhcnQsIGVuZCkuam9pbignJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXJ0ID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3Vic3RyID0gdGhpcy5jb25maWcuY29udGludWluZ19zdWJ3b3JkX3ByZWZpeCArIHN1YnN0cjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy50b2tlbnNfdG9faWRzLmhhcyhzdWJzdHIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50U3Vic3RyaW5nID0gc3Vic3RyO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAtLWVuZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRTdWJzdHJpbmcgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgaXNVbmtub3duID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN1YlRva2Vucy5wdXNoKGN1cnJlbnRTdWJzdHJpbmcpO1xuICAgICAgICAgICAgICAgIHN0YXJ0ID0gZW5kO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzVW5rbm93bikge1xuICAgICAgICAgICAgICAgIG91dHB1dFRva2Vucy5wdXNoKHRoaXMudW5rX3Rva2VuKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0VG9rZW5zLnB1c2goLi4uc3ViVG9rZW5zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvdXRwdXRUb2tlbnM7XG4gICAgfVxuXG59XG5cbi8qKlxuICogQ2xhc3MgcmVwcmVzZW50aW5nIGEgVW5pZ3JhbSB0b2tlbml6ZXIgbW9kZWwuXG4gKiBAZXh0ZW5kcyBUb2tlbml6ZXJNb2RlbFxuICovXG5jbGFzcyBVbmlncmFtIGV4dGVuZHMgVG9rZW5pemVyTW9kZWwge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBVbmlncmFtIHRva2VuaXplciBtb2RlbC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIFRoZSBjb25maWd1cmF0aW9uIG9iamVjdCBmb3IgdGhlIFVuaWdyYW0gbW9kZWwuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNvbmZpZy51bmtfaWQgVGhlIElEIG9mIHRoZSB1bmtub3duIHRva2VuXG4gICAgICogQHBhcmFtIHtNYXA8c3RyaW5nLCBudW1iZXI+fSBjb25maWcudm9jYWIgQSBtYXBwaW5nIG9mIHRva2VucyB0byBzY29yZXMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1vcmVDb25maWcgQWRkaXRpb25hbCBjb25maWd1cmF0aW9uIG9iamVjdCBmb3IgdGhlIFVuaWdyYW0gbW9kZWwuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY29uZmlnLCBtb3JlQ29uZmlnKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZyk7XG5cbiAgICAgICAgdGhpcy52b2NhYiA9IG5ldyBBcnJheShjb25maWcudm9jYWIuc2l6ZSk7XG4gICAgICAgIHRoaXMuc2NvcmVzID0gbmV3IEFycmF5KGNvbmZpZy52b2NhYi5zaXplKTtcbiAgICAgICAgbGV0IGNvdW50ID0gMDtcbiAgICAgICAgY29uZmlnLnZvY2FiLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgICAgICAgIHRoaXMudm9jYWJbY291bnRdID0ga2V5O1xuICAgICAgICAgICAgdGhpcy5zY29yZXNbY291bnRdID0gdmFsdWU7XG4gICAgICAgICAgICArK2NvdW50O1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLnVua190b2tlbl9pZCA9IGNvbmZpZy51bmtfaWQ7XG4gICAgICAgIHRoaXMudW5rX3Rva2VuID0gdGhpcy52b2NhYltjb25maWcudW5rX2lkXTtcblxuICAgICAgICB0aGlzLnRva2Vuc190b19pZHMgPSBuZXcgTWFwKHRoaXMudm9jYWIubWFwKCh4LCBpKSA9PiBbeCwgaV0pKTtcbiAgICAgICAgdGhpcy5ib3NUb2tlbiA9ICcgJzsgLy8gYmVnaW5uaW5nIG9mIGEgc2VudGVuY2UgdG9rZW5cblxuICAgICAgICB0aGlzLmJvc1Rva2VuSWQgPSB0aGlzLnRva2Vuc190b19pZHMuZ2V0KHRoaXMuYm9zVG9rZW4pOyAvLyBOT1RFOiBtYXkgYmUgdW5kZWZpbmVkXG4gICAgICAgIHRoaXMuZW9zVG9rZW4gPSBtb3JlQ29uZmlnLmVvc190b2tlbjtcblxuICAgICAgICB0aGlzLmVvc1Rva2VuSWQgPSB0aGlzLnRva2Vuc190b19pZHMuZ2V0KHRoaXMuZW9zVG9rZW4pO1xuICAgICAgICB0aGlzLnVua1Rva2VuID0gdGhpcy52b2NhYlt0aGlzLnVua190b2tlbl9pZF07XG5cbiAgICAgICAgdGhpcy5taW5TY29yZSA9IG1pbih0aGlzLnNjb3JlcylbMF07XG5cbiAgICAgICAgdGhpcy51bmtTY29yZSA9IHRoaXMubWluU2NvcmUgLSAxMC4wO1xuICAgICAgICB0aGlzLnNjb3Jlc1t0aGlzLnVua190b2tlbl9pZF0gPSB0aGlzLnVua1Njb3JlO1xuXG4gICAgICAgIHRoaXMudHJpZSA9IG5ldyBDaGFyVHJpZSgpO1xuICAgICAgICB0aGlzLnRyaWUuZXh0ZW5kKHRoaXMudm9jYWIpO1xuXG4gICAgICAgIC8vIE5PVEU6IGBmdXNlX3Vua2AgaXMgaGFyZGNvZGVkIHRvIHRydWUgZm9yIFVuaWdyYW0gbW9kZWxzXG4gICAgICAgIC8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2h1Z2dpbmdmYWNlL3Rva2VuaXplcnMvYmxvYi9iNTgyMjdjN2YxY2NmOGI3M2VlMjI2ODM1NDMzNmRhNTZkOTFlNDkyL3Rva2VuaXplcnMvc3JjL21vZGVscy91bmlncmFtL21vZGVsLnJzI0wxMTlcbiAgICAgICAgdGhpcy5mdXNlX3VuayA9IHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUG9wdWxhdGVzIGxhdHRpY2Ugbm9kZXMuXG4gICAgICogQHBhcmFtIHtUb2tlbkxhdHRpY2V9IGxhdHRpY2UgVGhlIHRva2VuIGxhdHRpY2UgdG8gcG9wdWxhdGUgd2l0aCBub2Rlcy5cbiAgICAgKi9cbiAgICBwb3B1bGF0ZU5vZGVzKGxhdHRpY2UpIHtcbiAgICAgICAgY29uc3Qgc2VudGVuY2UgPSBsYXR0aWNlLnNlbnRlbmNlO1xuICAgICAgICBjb25zdCBsZW4gPSBzZW50ZW5jZS5sZW5ndGg7XG4gICAgICAgIGxldCBiZWdpblBvcyA9IDA7XG4gICAgICAgIHdoaWxlIChiZWdpblBvcyA8IGxlbikge1xuICAgICAgICAgICAgY29uc3QgbWJsZW4gPSAxO1xuICAgICAgICAgICAgbGV0IGhhc1NpbmdsZU5vZGUgPSBmYWxzZTtcbiAgICAgICAgICAgIGNvbnN0IHRva2VucyA9IFtdO1xuXG4gICAgICAgICAgICBmb3IgKGxldCB0b2tlbiBvZiB0aGlzLnRyaWUuY29tbW9uUHJlZml4U2VhcmNoKHNlbnRlbmNlLnNsaWNlKGJlZ2luUG9zKSkpIHtcbiAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICAgICAgY29uc3QgdG9rZW5JZCA9IHRoaXMudG9rZW5zX3RvX2lkcy5nZXQodG9rZW4pO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRva2VuU2NvcmUgPSB0aGlzLnNjb3Jlc1t0b2tlbklkXTtcbiAgICAgICAgICAgICAgICBjb25zdCBuID0gdG9rZW4ubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGxhdHRpY2UuaW5zZXJ0KGJlZ2luUG9zLCBuLCB0b2tlblNjb3JlLCB0b2tlbklkKTtcbiAgICAgICAgICAgICAgICBpZiAoIWhhc1NpbmdsZU5vZGUgJiYgbiA9PT0gbWJsZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgaGFzU2luZ2xlTm9kZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFoYXNTaW5nbGVOb2RlKSB7XG4gICAgICAgICAgICAgICAgbGF0dGljZS5pbnNlcnQoYmVnaW5Qb3MsIG1ibGVuLCB0aGlzLnVua1Njb3JlLCB0aGlzLnVua190b2tlbl9pZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBiZWdpblBvcyArPSBtYmxlbjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVuY29kZXMgYW4gYXJyYXkgb2YgdG9rZW5zIGludG8gYW4gYXJyYXkgb2Ygc3VidG9rZW5zIHVzaW5nIHRoZSB1bmlncmFtIG1vZGVsLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5vcm1hbGl6ZWQgVGhlIG5vcm1hbGl6ZWQgc3RyaW5nLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmdbXX0gQW4gYXJyYXkgb2Ygc3VidG9rZW5zIG9idGFpbmVkIGJ5IGVuY29kaW5nIHRoZSBpbnB1dCB0b2tlbnMgdXNpbmcgdGhlIHVuaWdyYW0gbW9kZWwuXG4gICAgICovXG4gICAgdG9rZW5pemUobm9ybWFsaXplZCkge1xuICAgICAgICBjb25zdCBsYXR0aWNlID0gbmV3IFRva2VuTGF0dGljZShub3JtYWxpemVkLCB0aGlzLmJvc1Rva2VuSWQsIHRoaXMuZW9zVG9rZW5JZCk7XG4gICAgICAgIHRoaXMucG9wdWxhdGVOb2RlcyhsYXR0aWNlKTtcbiAgICAgICAgcmV0dXJuIGxhdHRpY2UudG9rZW5zKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRW5jb2RlcyBhbiBhcnJheSBvZiB0b2tlbnMgdXNpbmcgV29yZFBpZWNlIGVuY29kaW5nLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHRva2VucyBUaGUgdG9rZW5zIHRvIGVuY29kZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IEFuIGFycmF5IG9mIGVuY29kZWQgdG9rZW5zLlxuICAgICAqL1xuICAgIGVuY29kZSh0b2tlbnMpIHtcbiAgICAgICAgbGV0IHRvUmV0dXJuID0gW107XG4gICAgICAgIGZvciAobGV0IHRva2VuIG9mIHRva2Vucykge1xuICAgICAgICAgICAgY29uc3QgdG9rZW5pemVkID0gdGhpcy50b2tlbml6ZSh0b2tlbik7XG4gICAgICAgICAgICB0b1JldHVybi5wdXNoKC4uLnRva2VuaXplZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRvUmV0dXJuO1xuICAgIH1cblxufVxuXG4vKipcbiAqIFJldHVybnMgbGlzdCBvZiB1dGYtOCBieXRlIGFuZCBhIG1hcHBpbmcgdG8gdW5pY29kZSBzdHJpbmdzLlxuICogU3BlY2lmaWNhbGx5IGF2b2lkcyBtYXBwaW5nIHRvIHdoaXRlc3BhY2UvY29udHJvbCBjaGFyYWN0ZXJzIHRoZSBCUEUgY29kZSBiYXJmcyBvbi5cbiAqIEByZXR1cm5zIHtPYmplY3R9IE9iamVjdCB3aXRoIHV0Zi04IGJ5dGUga2V5cyBhbmQgdW5pY29kZSBzdHJpbmcgdmFsdWVzLlxuICovXG5jb25zdCBCWVRFU19UT19VTklDT0RFID0gKCgpID0+IHtcbiAgICAvLyBSZXR1cm5zIGxpc3Qgb2YgdXRmLTggYnl0ZSBhbmQgYSBtYXBwaW5nIHRvIHVuaWNvZGUgc3RyaW5ncy5cbiAgICAvLyBXZSBzcGVjaWZpY2FsbHkgYXZvaWRzIG1hcHBpbmcgdG8gd2hpdGVzcGFjZS9jb250cm9sIGNoYXJhY3RlcnNcbiAgICAvLyB0aGUgYnBlIGNvZGUgYmFyZnMgb24uXG5cbiAgICBjb25zdCBicyA9IFtcbiAgICAgICAgLi4uQXJyYXkuZnJvbSh7IGxlbmd0aDogXCJ+XCIuY2hhckNvZGVBdCgwKSAtIFwiIVwiLmNoYXJDb2RlQXQoMCkgKyAxIH0sIChfLCBpKSA9PiBpICsgXCIhXCIuY2hhckNvZGVBdCgwKSksXG4gICAgICAgIC4uLkFycmF5LmZyb20oeyBsZW5ndGg6IFwiwqxcIi5jaGFyQ29kZUF0KDApIC0gXCLCoVwiLmNoYXJDb2RlQXQoMCkgKyAxIH0sIChfLCBpKSA9PiBpICsgXCLCoVwiLmNoYXJDb2RlQXQoMCkpLFxuICAgICAgICAuLi5BcnJheS5mcm9tKHsgbGVuZ3RoOiBcIsO/XCIuY2hhckNvZGVBdCgwKSAtIFwiwq5cIi5jaGFyQ29kZUF0KDApICsgMSB9LCAoXywgaSkgPT4gaSArIFwiwq5cIi5jaGFyQ29kZUF0KDApKSxcbiAgICBdO1xuICAgIGxldCBjcyA9IGJzLnNsaWNlKCk7XG4gICAgbGV0IG4gPSAwO1xuICAgIGZvciAobGV0IGIgPSAwOyBiIDwgMjU2OyArK2IpIHtcbiAgICAgICAgaWYgKCFicy5pbmNsdWRlcyhiKSkge1xuICAgICAgICAgICAgYnMucHVzaChiKTtcbiAgICAgICAgICAgIGNzLnB1c2goMjU2ICsgbik7XG4gICAgICAgICAgICBuICs9IDE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0IGNjcyA9IGNzLm1hcChuID0+IFN0cmluZy5mcm9tQ2hhckNvZGUobikpO1xuICAgIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMoYnMubWFwKChiLCBpKSA9PiBbYiwgY2NzW2ldXSkpO1xufSkoKTtcblxuY29uc3QgVU5JQ09ERV9UT19CWVRFUyA9IHJldmVyc2VEaWN0aW9uYXJ5KEJZVEVTX1RPX1VOSUNPREUpO1xuXG4vKipcbiAqIEJQRSBjbGFzcyBmb3IgZW5jb2RpbmcgdGV4dCBpbnRvIEJ5dGUtUGFpci1FbmNvZGluZyAoQlBFKSB0b2tlbnMuXG4gKiBAZXh0ZW5kcyBUb2tlbml6ZXJNb2RlbFxuICovXG5jbGFzcyBCUEUgZXh0ZW5kcyBUb2tlbml6ZXJNb2RlbCB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgQlBFIGluc3RhbmNlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgVGhlIGNvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciBCUEUuXG4gICAgICogQHBhcmFtIHtNYXA8c3RyaW5nLCBudW1iZXI+fSBjb25maWcudm9jYWIgQSBtYXBwaW5nIG9mIHRva2VucyB0byBpZHMuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbmZpZy51bmtfdG9rZW4gVGhlIHVua25vd24gdG9rZW4gdXNlZCBmb3Igb3V0IG9mIHZvY2FidWxhcnkgd29yZHMuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbmZpZy5lbmRfb2Zfd29yZF9zdWZmaXggVGhlIHN1ZmZpeCB0byBwbGFjZSBhdCB0aGUgZW5kIG9mIGVhY2ggd29yZC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBjb25maWcubWVyZ2VzIEFuIGFycmF5IG9mIEJQRSBtZXJnZXMgYXMgc3RyaW5ncy5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICAgICAgc3VwZXIoY29uZmlnKTtcblxuICAgICAgICB0aGlzLkJQRV9TUExJVF9UT0tFTiA9ICcgJztcblxuICAgICAgICB0aGlzLnRva2Vuc190b19pZHMgPSBjb25maWcudm9jYWI7XG5cbiAgICAgICAgdGhpcy51bmtfdG9rZW5faWQgPSB0aGlzLnRva2Vuc190b19pZHMuZ2V0KGNvbmZpZy51bmtfdG9rZW4pO1xuICAgICAgICB0aGlzLnVua190b2tlbiA9IGNvbmZpZy51bmtfdG9rZW47XG5cbiAgICAgICAgdGhpcy52b2NhYiA9IG5ldyBBcnJheSh0aGlzLnRva2Vuc190b19pZHMuc2l6ZSk7XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIHRoaXMudG9rZW5zX3RvX2lkcykge1xuICAgICAgICAgICAgdGhpcy52b2NhYlt2YWx1ZV0gPSBrZXk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmJwZV9yYW5rcyA9IE9iamVjdC5mcm9tRW50cmllcyhjb25maWcubWVyZ2VzLm1hcCgoeCwgaSkgPT4gW3gsIGldKSk7XG4gICAgICAgIHRoaXMubWVyZ2VzID0gY29uZmlnLm1lcmdlcy5tYXAoeCA9PiB4LnNwbGl0KHRoaXMuQlBFX1NQTElUX1RPS0VOKSk7XG5cbiAgICAgICAgdGhpcy5lbmRfb2Zfd29yZF9zdWZmaXggPSBjb25maWcuZW5kX29mX3dvcmRfc3VmZml4O1xuXG4gICAgICAgIHRoaXMuYnl0ZV9mYWxsYmFjayA9IHRoaXMuY29uZmlnLmJ5dGVfZmFsbGJhY2sgPz8gZmFsc2U7XG5cbiAgICAgICAgaWYgKHRoaXMuYnl0ZV9mYWxsYmFjaykge1xuICAgICAgICAgICAgdGhpcy50ZXh0X2VuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gICAgICAgIHRoaXMuZnVzZV91bmsgPz89IHRoaXMuY29uZmlnLmZ1c2VfdW5rO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBhbGwgdGhlIHBvc3NpYmxlIHBhaXJzIG9mIGNoYXJhY3RlcnMgaW4gYSB3b3JkLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IHdvcmQgVGhlIHdvcmQgdG8gZ2V0IHBhaXJzIGZyb20uXG4gICAgICogQHJldHVybnMge0FycmF5fSBBbiBhcnJheSBvZiBwYWlycy5cbiAgICAgKi9cbiAgICBnZXRfcGFpcnMod29yZCkge1xuICAgICAgICBsZXQgcGFpcnMgPSBuZXcgU2V0KCk7XG4gICAgICAgIGxldCBwcmV2X2NoYXIgPSB3b3JkWzBdO1xuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHdvcmQubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGxldCBjaGFyID0gd29yZFtpXTtcbiAgICAgICAgICAgIHBhaXJzLmFkZChwcmV2X2NoYXIgKyB0aGlzLkJQRV9TUExJVF9UT0tFTiArIGNoYXIpO1xuICAgICAgICAgICAgcHJldl9jaGFyID0gY2hhcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbShwYWlycyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXBwbHkgQnl0ZS1QYWlyLUVuY29kaW5nIChCUEUpIHRvIGEgZ2l2ZW4gdG9rZW4uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRva2VuIFRoZSB0b2tlbiB0byBlbmNvZGUuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gVGhlIEJQRSBlbmNvZGVkIHRva2VuLlxuICAgICAqL1xuICAgIGJwZSh0b2tlbikge1xuICAgICAgICBpZiAodG9rZW4gaW4gdGhpcy5jYWNoZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2FjaGVbdG9rZW5dO1xuICAgICAgICB9XG4gICAgICAgIGxldCB3b3JkID0gQXJyYXkuZnJvbSh0b2tlbik7XG4gICAgICAgIGlmICh0aGlzLmVuZF9vZl93b3JkX3N1ZmZpeCkge1xuICAgICAgICAgICAgd29yZFt3b3JkLmxlbmd0aCAtIDFdICs9IHRoaXMuZW5kX29mX3dvcmRfc3VmZml4O1xuICAgICAgICB9XG4gICAgICAgIGxldCBwYWlycyA9IHRoaXMuZ2V0X3BhaXJzKHdvcmQpO1xuXG4gICAgICAgIGlmICghcGFpcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5lbmRfb2Zfd29yZF9zdWZmaXgpIHtcbiAgICAgICAgICAgICAgICB0b2tlbiArPSB0aGlzLmVuZF9vZl93b3JkX3N1ZmZpeDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgICAgfVxuXG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBsZXQgYmlncmFtID0gcGFpcnMucmVkdWNlKChhLCBiKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IGMgPSB0aGlzLmJwZV9yYW5rc1thXSA/PyBJbmZpbml0eVxuICAgICAgICAgICAgICAgIGxldCBkID0gdGhpcy5icGVfcmFua3NbYl0gPz8gSW5maW5pdHlcbiAgICAgICAgICAgICAgICByZXR1cm4gYyA8PSBkID8gYSA6IGI7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICghKGJpZ3JhbSBpbiB0aGlzLmJwZV9yYW5rcykpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBbZmlyc3QsIHNlY29uZF0gPSBiaWdyYW0uc3BsaXQodGhpcy5CUEVfU1BMSVRfVE9LRU4pO1xuICAgICAgICAgICAgbGV0IG5ld193b3JkID0gW107XG4gICAgICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgICAgICBsZXQgaiA9IC0xO1xuXG4gICAgICAgICAgICB3aGlsZSAoaSA8IHdvcmQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgaiA9IHdvcmQuaW5kZXhPZihmaXJzdCwgaSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChqID09PSAtMSkgdGhyb3cgXCJFcnJvclwiO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3X3dvcmQucHVzaCguLi53b3JkLnNsaWNlKGkpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5ld193b3JkLnB1c2goLi4ud29yZC5zbGljZShpLCBqKSk7XG4gICAgICAgICAgICAgICAgaSA9IGo7XG5cbiAgICAgICAgICAgICAgICBpZiAod29yZFtpXSA9PT0gZmlyc3QgJiYgaSA8IHdvcmQubGVuZ3RoIC0gMSAmJiB3b3JkW2kgKyAxXSA9PT0gc2Vjb25kKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld193b3JkLnB1c2goZmlyc3QgKyBzZWNvbmQpO1xuICAgICAgICAgICAgICAgICAgICBpICs9IDI7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3X3dvcmQucHVzaCh3b3JkW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgaSArPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdvcmQgPSBuZXdfd29yZFxuICAgICAgICAgICAgaWYgKHdvcmQubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhaXJzID0gdGhpcy5nZXRfcGFpcnMod29yZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGZpbmFsX3dvcmQgPSB3b3JkLmpvaW4odGhpcy5CUEVfU1BMSVRfVE9LRU4pO1xuICAgICAgICB0aGlzLmNhY2hlW3Rva2VuXSA9IGZpbmFsX3dvcmQ7XG4gICAgICAgIHJldHVybiBmaW5hbF93b3JkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVuY29kZXMgdGhlIGlucHV0IHNlcXVlbmNlIG9mIHRva2VucyB1c2luZyB0aGUgQlBFIGFsZ29yaXRobSBhbmQgcmV0dXJucyB0aGUgcmVzdWx0aW5nIHN1YndvcmQgdG9rZW5zLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHRva2VucyBUaGUgaW5wdXQgc2VxdWVuY2Ugb2YgdG9rZW5zIHRvIGVuY29kZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFRoZSByZXN1bHRpbmcgc3Vid29yZCB0b2tlbnMgYWZ0ZXIgYXBwbHlpbmcgdGhlIEJQRSBhbGdvcml0aG0gdG8gdGhlIGlucHV0IHNlcXVlbmNlIG9mIHRva2Vucy5cbiAgICAgKi9cbiAgICBlbmNvZGUodG9rZW5zKSB7XG4gICAgICAgIGxldCBvdXRwdXRUb2tlbnMgPSBbXTtcblxuICAgICAgICBmb3IgKGxldCB0b2tlbiBvZiB0b2tlbnMpIHtcbiAgICAgICAgICAgIGxldCBicGVfdG9rZW5fbGlzdCA9IHRoaXMuYnBlKHRva2VuKS5zcGxpdCh0aGlzLkJQRV9TUExJVF9UT0tFTik7XG5cbiAgICAgICAgICAgIGZvciAobGV0IHQgb2YgYnBlX3Rva2VuX2xpc3QpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy50b2tlbnNfdG9faWRzLmhhcyh0KSkge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXRUb2tlbnMucHVzaCh0KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5ieXRlX2ZhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXRUb2tlbnMucHVzaChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5BcnJheS5mcm9tKHRoaXMudGV4dF9lbmNvZGVyLmVuY29kZSh0KSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLm1hcCh4ID0+IGA8MHgke3gudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCkucGFkU3RhcnQoMiwgJzAnKX0+YClcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXRUb2tlbnMucHVzaCh0aGlzLnVua190b2tlbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb3V0cHV0VG9rZW5zO1xuICAgIH1cblxufVxuXG4vKipcbiAqIEEgYmFzZSBjbGFzcyBmb3IgdGV4dCBub3JtYWxpemF0aW9uLlxuICogQGFic3RyYWN0XG4gKi9cbmNsYXNzIE5vcm1hbGl6ZXIgZXh0ZW5kcyBDYWxsYWJsZSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBUaGUgY29uZmlndXJhdGlvbiBvYmplY3QgZm9yIHRoZSBub3JtYWxpemVyLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGYWN0b3J5IG1ldGhvZCBmb3IgY3JlYXRpbmcgbm9ybWFsaXplcnMgZnJvbSBjb25maWcgb2JqZWN0cy5cbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBUaGUgY29uZmlndXJhdGlvbiBvYmplY3QgZm9yIHRoZSBub3JtYWxpemVyLlxuICAgICAqIEByZXR1cm5zIHtOb3JtYWxpemVyfSBBIE5vcm1hbGl6ZXIgb2JqZWN0LlxuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiBhbiB1bmtub3duIE5vcm1hbGl6ZXIgdHlwZSBpcyBzcGVjaWZpZWQgaW4gdGhlIGNvbmZpZy5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbUNvbmZpZyhjb25maWcpIHtcbiAgICAgICAgaWYgKGNvbmZpZyA9PT0gbnVsbCkgcmV0dXJuIG51bGw7XG4gICAgICAgIHN3aXRjaCAoY29uZmlnLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ0JlcnROb3JtYWxpemVyJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEJlcnROb3JtYWxpemVyKGNvbmZpZyk7XG4gICAgICAgICAgICBjYXNlICdQcmVjb21waWxlZCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcmVjb21waWxlZChjb25maWcpO1xuICAgICAgICAgICAgY2FzZSAnU2VxdWVuY2UnOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgTm9ybWFsaXplclNlcXVlbmNlKGNvbmZpZyk7XG4gICAgICAgICAgICBjYXNlICdSZXBsYWNlJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFJlcGxhY2UoY29uZmlnKTtcbiAgICAgICAgICAgIGNhc2UgJ05GQyc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBORkMoY29uZmlnKTtcbiAgICAgICAgICAgIGNhc2UgJ05GS0QnOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgTkZLRChjb25maWcpO1xuICAgICAgICAgICAgY2FzZSAnU3RyaXBBY2NlbnRzJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFN0cmlwQWNjZW50cyhjb25maWcpO1xuICAgICAgICAgICAgY2FzZSAnTG93ZXJjYXNlJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IExvd2VyY2FzZShjb25maWcpO1xuICAgICAgICAgICAgY2FzZSAnUHJlcGVuZCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcmVwZW5kKGNvbmZpZyk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBOb3JtYWxpemVyIHR5cGU6ICR7Y29uZmlnLnR5cGV9YCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBOb3JtYWxpemUgdGhlIGlucHV0IHRleHQuXG4gICAgICogQGFic3RyYWN0XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgVGhlIHRleHQgdG8gbm9ybWFsaXplLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBub3JtYWxpemVkIHRleHQuXG4gICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoaXMgbWV0aG9kIGlzIG5vdCBpbXBsZW1lbnRlZCBpbiBhIHN1YmNsYXNzLlxuICAgICAqL1xuICAgIG5vcm1hbGl6ZSh0ZXh0KSB7XG4gICAgICAgIHRocm93IEVycm9yKFwibm9ybWFsaXplIHNob3VsZCBiZSBpbXBsZW1lbnRlZCBpbiBzdWJjbGFzcy5cIilcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBbGlhcyBmb3Ige0BsaW5rIE5vcm1hbGl6ZXIjbm9ybWFsaXplfS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCBUaGUgdGV4dCB0byBub3JtYWxpemUuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gVGhlIG5vcm1hbGl6ZWQgdGV4dC5cbiAgICAgKi9cbiAgICBfY2FsbCh0ZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5vcm1hbGl6ZSh0ZXh0KTtcbiAgICB9XG5cbn1cblxuLyoqXG4gKiBSZXBsYWNlIG5vcm1hbGl6ZXIgdGhhdCByZXBsYWNlcyBvY2N1cnJlbmNlcyBvZiBhIHBhdHRlcm4gd2l0aCBhIGdpdmVuIHN0cmluZyBvciByZWd1bGFyIGV4cHJlc3Npb24uXG4gKiBAZXh0ZW5kcyBOb3JtYWxpemVyXG4gKi9cbmNsYXNzIFJlcGxhY2UgZXh0ZW5kcyBOb3JtYWxpemVyIHtcbiAgICAvKipcbiAgICAgKiBOb3JtYWxpemUgdGhlIGlucHV0IHRleHQgYnkgcmVwbGFjaW5nIHRoZSBwYXR0ZXJuIHdpdGggdGhlIGNvbnRlbnQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgVGhlIGlucHV0IHRleHQgdG8gYmUgbm9ybWFsaXplZC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgbm9ybWFsaXplZCB0ZXh0IGFmdGVyIHJlcGxhY2luZyB0aGUgcGF0dGVybiB3aXRoIHRoZSBjb250ZW50LlxuICAgICAqL1xuICAgIG5vcm1hbGl6ZSh0ZXh0KSB7XG4gICAgICAgIGxldCBwYXR0ZXJuID0gY3JlYXRlUGF0dGVybih0aGlzLmNvbmZpZy5wYXR0ZXJuKTtcbiAgICAgICAgaWYgKHBhdHRlcm4gPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB0ZXh0O1xuICAgICAgICB9XG5cbiAgICAgICAgdGV4dCA9IHRleHQucmVwbGFjZUFsbChwYXR0ZXJuLCB0aGlzLmNvbmZpZy5jb250ZW50KVxuXG4gICAgICAgIHJldHVybiB0ZXh0O1xuICAgIH1cbn1cblxuLyoqXG4gKiBBIG5vcm1hbGl6ZXIgdGhhdCBhcHBsaWVzIFVuaWNvZGUgbm9ybWFsaXphdGlvbiBmb3JtIEMgKE5GQykgdG8gdGhlIGlucHV0IHRleHQuXG4gKiBAZXh0ZW5kcyBOb3JtYWxpemVyXG4gKi9cbmNsYXNzIE5GQyBleHRlbmRzIE5vcm1hbGl6ZXIge1xuICAgIC8qKlxuICAgICAqIE5vcm1hbGl6ZSB0aGUgaW5wdXQgdGV4dCBieSBhcHBseWluZyBVbmljb2RlIG5vcm1hbGl6YXRpb24gZm9ybSBDIChORkMpLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IFRoZSBpbnB1dCB0ZXh0IHRvIGJlIG5vcm1hbGl6ZWQuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gVGhlIG5vcm1hbGl6ZWQgdGV4dC5cbiAgICAgKi9cbiAgICBub3JtYWxpemUodGV4dCkge1xuICAgICAgICB0ZXh0ID0gdGV4dC5ub3JtYWxpemUoJ05GQycpXG4gICAgICAgIHJldHVybiB0ZXh0O1xuICAgIH1cbn1cblxuLyoqXG4gKiBORktEIE5vcm1hbGl6ZXIuXG4gKiBAZXh0ZW5kcyBOb3JtYWxpemVyXG4gKi9cbmNsYXNzIE5GS0QgZXh0ZW5kcyBOb3JtYWxpemVyIHtcbiAgICAvKipcbiAgICAgKiBOb3JtYWxpemUgdGV4dCB1c2luZyBORktEIG5vcm1hbGl6YXRpb24uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgVGhlIHRleHQgdG8gYmUgbm9ybWFsaXplZC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgbm9ybWFsaXplZCB0ZXh0LlxuICAgICAqL1xuICAgIG5vcm1hbGl6ZSh0ZXh0KSB7XG4gICAgICAgIHRleHQgPSB0ZXh0Lm5vcm1hbGl6ZSgnTkZLRCcpXG4gICAgICAgIHJldHVybiB0ZXh0O1xuICAgIH1cbn1cblxuLyoqXG4gKiBTdHJpcEFjY2VudHMgbm9ybWFsaXplciByZW1vdmVzIGFsbCBhY2NlbnRzIGZyb20gdGhlIHRleHQuXG4gKiBAZXh0ZW5kcyBOb3JtYWxpemVyXG4gKi9cbmNsYXNzIFN0cmlwQWNjZW50cyBleHRlbmRzIE5vcm1hbGl6ZXIge1xuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhbGwgYWNjZW50cyBmcm9tIHRoZSB0ZXh0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IFRoZSBpbnB1dCB0ZXh0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBub3JtYWxpemVkIHRleHQgd2l0aG91dCBhY2NlbnRzLlxuICAgICAqL1xuICAgIG5vcm1hbGl6ZSh0ZXh0KSB7XG4gICAgICAgIHRleHQgPSB0ZXh0LnJlcGxhY2UoL1tcXHUwMzAwLVxcdTAzNmZdL2csICcnKTtcbiAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfVxufVxuXG4vKipcbiAqIEEgTm9ybWFsaXplciB0aGF0IGxvd2VyY2FzZXMgdGhlIGlucHV0IHN0cmluZy5cbiAqIEBleHRlbmRzIE5vcm1hbGl6ZXJcbiAqL1xuY2xhc3MgTG93ZXJjYXNlIGV4dGVuZHMgTm9ybWFsaXplciB7XG4gICAgLyoqXG4gICAgICogTG93ZXJjYXNlcyB0aGUgaW5wdXQgc3RyaW5nLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IFRoZSB0ZXh0IHRvIG5vcm1hbGl6ZS5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgbm9ybWFsaXplZCB0ZXh0LlxuICAgICAqL1xuICAgIG5vcm1hbGl6ZSh0ZXh0KSB7XG4gICAgICAgIHRleHQgPSB0ZXh0LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHJldHVybiB0ZXh0O1xuICAgIH1cbn1cblxuLyoqXG4gKiBBIE5vcm1hbGl6ZXIgdGhhdCBwcmVwZW5kcyBhIHN0cmluZyB0byB0aGUgaW5wdXQgc3RyaW5nLlxuICogQGV4dGVuZHMgTm9ybWFsaXplclxuICovXG5jbGFzcyBQcmVwZW5kIGV4dGVuZHMgTm9ybWFsaXplciB7XG4gICAgLyoqXG4gICAgICogUHJlcGVuZHMgdGhlIGlucHV0IHN0cmluZy5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCBUaGUgdGV4dCB0byBub3JtYWxpemUuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gVGhlIG5vcm1hbGl6ZWQgdGV4dC5cbiAgICAgKi9cbiAgICBub3JtYWxpemUodGV4dCkge1xuICAgICAgICB0ZXh0ID0gdGhpcy5jb25maWcucHJlcGVuZCArIHRleHQ7XG4gICAgICAgIHJldHVybiB0ZXh0O1xuICAgIH1cbn1cblxuLyoqXG4gKiBBIE5vcm1hbGl6ZXIgdGhhdCBhcHBsaWVzIGEgc2VxdWVuY2Ugb2YgTm9ybWFsaXplcnMuXG4gKiBAZXh0ZW5kcyBOb3JtYWxpemVyXG4gKi9cbmNsYXNzIE5vcm1hbGl6ZXJTZXF1ZW5jZSBleHRlbmRzIE5vcm1hbGl6ZXIge1xuICAgIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgaW5zdGFuY2Ugb2YgTm9ybWFsaXplclNlcXVlbmNlLlxuICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIFRoZSBjb25maWd1cmF0aW9uIG9iamVjdC5cbiAgICogQHBhcmFtIHtPYmplY3RbXX0gY29uZmlnLm5vcm1hbGl6ZXJzIEFuIGFycmF5IG9mIE5vcm1hbGl6ZXIgY29uZmlndXJhdGlvbiBvYmplY3RzLlxuICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICAgICAgc3VwZXIoY29uZmlnKTtcbiAgICAgICAgdGhpcy5ub3JtYWxpemVycyA9IGNvbmZpZy5ub3JtYWxpemVycy5tYXAoeCA9PiBOb3JtYWxpemVyLmZyb21Db25maWcoeCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAqIEFwcGx5IGEgc2VxdWVuY2Ugb2YgTm9ybWFsaXplcnMgdG8gdGhlIGlucHV0IHRleHQuXG4gICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCBUaGUgdGV4dCB0byBub3JtYWxpemUuXG4gICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgbm9ybWFsaXplZCB0ZXh0LlxuICAgICovXG4gICAgbm9ybWFsaXplKHRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubm9ybWFsaXplcnMucmVkdWNlKCh0LCBub3JtYWxpemVyKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gbm9ybWFsaXplci5ub3JtYWxpemUodCk7XG4gICAgICAgIH0sIHRleHQpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBBIGNsYXNzIHJlcHJlc2VudGluZyBhIG5vcm1hbGl6ZXIgdXNlZCBpbiBCRVJUIHRva2VuaXphdGlvbi5cbiAqIEBleHRlbmRzIE5vcm1hbGl6ZXJcbiAqL1xuY2xhc3MgQmVydE5vcm1hbGl6ZXIgZXh0ZW5kcyBOb3JtYWxpemVyIHtcbiAgICAvKipcbiAgICAgKiBBZGRzIHdoaXRlc3BhY2UgYXJvdW5kIGFueSBDSksgKENoaW5lc2UsIEphcGFuZXNlLCBvciBLb3JlYW4pIGNoYXJhY3RlciBpbiB0aGUgaW5wdXQgdGV4dC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IFRoZSBpbnB1dCB0ZXh0IHRvIHRva2VuaXplLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSB0b2tlbml6ZWQgdGV4dCB3aXRoIHdoaXRlc3BhY2UgYWRkZWQgYXJvdW5kIENKSyBjaGFyYWN0ZXJzLlxuICAgICAqL1xuICAgIF90b2tlbml6ZV9jaGluZXNlX2NoYXJzKHRleHQpIHtcbiAgICAgICAgLyogQWRkcyB3aGl0ZXNwYWNlIGFyb3VuZCBhbnkgQ0pLIGNoYXJhY3Rlci4gKi9cbiAgICAgICAgbGV0IG91dHB1dCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRleHQubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGxldCBjaGFyID0gdGV4dFtpXTtcbiAgICAgICAgICAgIGxldCBjcCA9IGNoYXIuY2hhckNvZGVBdCgwKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9pc19jaGluZXNlX2NoYXIoY3ApKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0LnB1c2goXCIgXCIpO1xuICAgICAgICAgICAgICAgIG91dHB1dC5wdXNoKGNoYXIpO1xuICAgICAgICAgICAgICAgIG91dHB1dC5wdXNoKFwiIFwiKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0LnB1c2goY2hhcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dHB1dC5qb2luKFwiXCIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBVbmljb2RlIGNvZGVwb2ludCByZXByZXNlbnRzIGEgQ0pLIChDaGluZXNlLCBKYXBhbmVzZSwgb3IgS29yZWFuKSBjaGFyYWN0ZXIuXG4gICAgICpcbiAgICAgKiBBIFwiY2hpbmVzZSBjaGFyYWN0ZXJcIiBpcyBkZWZpbmVkIGFzIGFueXRoaW5nIGluIHRoZSBDSksgVW5pY29kZSBibG9jazpcbiAgICAgKiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9DSktfVW5pZmllZF9JZGVvZ3JhcGhzXyhVbmljb2RlX2Jsb2NrKVxuICAgICAqXG4gICAgICogTm90ZSB0aGF0IHRoZSBDSksgVW5pY29kZSBibG9jayBpcyBOT1QgYWxsIEphcGFuZXNlIGFuZCBLb3JlYW4gY2hhcmFjdGVycywgZGVzcGl0ZSBpdHMgbmFtZS5cbiAgICAgKiBUaGUgbW9kZXJuIEtvcmVhbiBIYW5ndWwgYWxwaGFiZXQgaXMgYSBkaWZmZXJlbnQgYmxvY2ssIGFzIGlzIEphcGFuZXNlIEhpcmFnYW5hIGFuZCBLYXRha2FuYS5cbiAgICAgKiBUaG9zZSBhbHBoYWJldHMgYXJlIHVzZWQgdG8gd3JpdGUgc3BhY2Utc2VwYXJhdGVkIHdvcmRzLCBzbyB0aGV5IGFyZSBub3QgdHJlYXRlZCBzcGVjaWFsbHlcbiAgICAgKiBhbmQgYXJlIGhhbmRsZWQgbGlrZSBhbGwgb3RoZXIgbGFuZ3VhZ2VzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNwIFRoZSBVbmljb2RlIGNvZGVwb2ludCB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgY29kZXBvaW50IHJlcHJlc2VudHMgYSBDSksgY2hhcmFjdGVyLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgX2lzX2NoaW5lc2VfY2hhcihjcCkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgKGNwID49IDB4NEUwMCAmJiBjcCA8PSAweDlGRkYpXG4gICAgICAgICAgICB8fCAoY3AgPj0gMHgzNDAwICYmIGNwIDw9IDB4NERCRilcbiAgICAgICAgICAgIHx8IChjcCA+PSAweDIwMDAwICYmIGNwIDw9IDB4MkE2REYpXG4gICAgICAgICAgICB8fCAoY3AgPj0gMHgyQTcwMCAmJiBjcCA8PSAweDJCNzNGKVxuICAgICAgICAgICAgfHwgKGNwID49IDB4MkI3NDAgJiYgY3AgPD0gMHgyQjgxRilcbiAgICAgICAgICAgIHx8IChjcCA+PSAweDJCODIwICYmIGNwIDw9IDB4MkNFQUYpXG4gICAgICAgICAgICB8fCAoY3AgPj0gMHhGOTAwICYmIGNwIDw9IDB4RkFGRilcbiAgICAgICAgICAgIHx8IChjcCA+PSAweDJGODAwICYmIGNwIDw9IDB4MkZBMUYpXG4gICAgICAgIClcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RyaXBzIGFjY2VudHMgZnJvbSB0aGUgZ2l2ZW4gdGV4dC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCBUaGUgdGV4dCB0byBzdHJpcCBhY2NlbnRzIGZyb20uXG4gICAgICogQHJldHVybnMge3N0cmluZ30gVGhlIHRleHQgd2l0aCBhY2NlbnRzIHJlbW92ZWQuXG4gICAgICovXG4gICAgc3RyaXBBY2NlbnRzKHRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRleHQubm9ybWFsaXplKCdORkQnKS5yZXBsYWNlKC9bXFx1MDMwMC1cXHUwMzZmXS9nLCAnJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTm9ybWFsaXplcyB0aGUgZ2l2ZW4gdGV4dCBiYXNlZCBvbiB0aGUgY29uZmlndXJhdGlvbi5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCBUaGUgdGV4dCB0byBub3JtYWxpemUuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gVGhlIG5vcm1hbGl6ZWQgdGV4dC5cbiAgICAgKi9cbiAgICBub3JtYWxpemUodGV4dCkge1xuICAgICAgICAvLyBUT0RPIHVzZSByZXN0IG9mIGNvbmZpZ1xuICAgICAgICAvLyBjb25maWcuY2xlYW5fdGV4dCxcbiAgICAgICAgLy8gY29uZmlnLmhhbmRsZV9jaGluZXNlX2NoYXJzLFxuICAgICAgICAvLyBjb25maWcuc3RyaXBfYWNjZW50cyxcbiAgICAgICAgLy8gY29uZmlnLmxvd2VyY2FzZSxcblxuICAgICAgICBpZiAodGhpcy5jb25maWcuaGFuZGxlX2NoaW5lc2VfY2hhcnMpIHtcbiAgICAgICAgICAgIHRleHQgPSB0aGlzLl90b2tlbml6ZV9jaGluZXNlX2NoYXJzKHRleHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuY29uZmlnLmxvd2VyY2FzZSkge1xuICAgICAgICAgICAgdGV4dCA9IHRleHQudG9Mb3dlckNhc2UoKTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlnLnN0cmlwX2FjY2VudHMgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgdGV4dCA9IHRoaXMuc3RyaXBBY2NlbnRzKHRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuY29uZmlnLnN0cmlwX2FjY2VudHMpIHtcbiAgICAgICAgICAgIHRleHQgPSB0aGlzLnN0cmlwQWNjZW50cyh0ZXh0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0ZXh0O1xuICAgIH1cbn1cblxuLyoqXG4gKiBBIGNhbGxhYmxlIGNsYXNzIHJlcHJlc2VudGluZyBhIHByZS10b2tlbml6ZXIgdXNlZCBpbiB0b2tlbml6YXRpb24uIFN1YmNsYXNzZXNcbiAqIHNob3VsZCBpbXBsZW1lbnQgdGhlIGBwcmVfdG9rZW5pemVfdGV4dGAgbWV0aG9kIHRvIGRlZmluZSB0aGUgc3BlY2lmaWMgcHJlLXRva2VuaXphdGlvbiBsb2dpYy5cbiAqIEBleHRlbmRzIENhbGxhYmxlXG4gKi9cbmNsYXNzIFByZVRva2VuaXplciBleHRlbmRzIENhbGxhYmxlIHtcbiAgICAvKipcbiAgICogRmFjdG9yeSBtZXRob2QgdGhhdCByZXR1cm5zIGFuIGluc3RhbmNlIG9mIGEgc3ViY2xhc3Mgb2YgYFByZVRva2VuaXplcmAgYmFzZWQgb24gdGhlIHByb3ZpZGVkIGNvbmZpZ3VyYXRpb24uXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBBIGNvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciB0aGUgcHJlLXRva2VuaXplci5cbiAgICogQHJldHVybnMge1ByZVRva2VuaXplcn0gQW4gaW5zdGFuY2Ugb2YgYSBzdWJjbGFzcyBvZiBgUHJlVG9rZW5pemVyYC5cbiAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBwcm92aWRlZCBjb25maWd1cmF0aW9uIG9iamVjdCBkb2VzIG5vdCBjb3JyZXNwb25kIHRvIGFueSBrbm93biBwcmUtdG9rZW5pemVyLlxuICAgKi9cbiAgICBzdGF0aWMgZnJvbUNvbmZpZyhjb25maWcpIHtcbiAgICAgICAgaWYgKGNvbmZpZyA9PT0gbnVsbCkgcmV0dXJuIG51bGw7XG5cbiAgICAgICAgc3dpdGNoIChjb25maWcudHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnQmVydFByZVRva2VuaXplcic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBCZXJ0UHJlVG9rZW5pemVyKGNvbmZpZyk7XG4gICAgICAgICAgICBjYXNlICdTZXF1ZW5jZSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcmVUb2tlbml6ZXJTZXF1ZW5jZShjb25maWcpO1xuICAgICAgICAgICAgY2FzZSAnV2hpdGVzcGFjZVNwbGl0JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFdoaXRlc3BhY2VTcGxpdChjb25maWcpO1xuICAgICAgICAgICAgY2FzZSAnTWV0YXNwYWNlJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IE1ldGFzcGFjZVByZVRva2VuaXplcihjb25maWcpO1xuXG4gICAgICAgICAgICBjYXNlICdCeXRlTGV2ZWwnOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQnl0ZUxldmVsUHJlVG9rZW5pemVyKGNvbmZpZyk7XG4gICAgICAgICAgICBjYXNlICdTcGxpdCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTcGxpdFByZVRva2VuaXplcihjb25maWcpO1xuICAgICAgICAgICAgY2FzZSAnUHVuY3R1YXRpb24nOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHVuY3R1YXRpb25QcmVUb2tlbml6ZXIoY29uZmlnKTtcbiAgICAgICAgICAgIGNhc2UgJ0RpZ2l0cyc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBEaWdpdHNQcmVUb2tlbml6ZXIoY29uZmlnKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIFByZVRva2VuaXplciB0eXBlOiAke2NvbmZpZy50eXBlfWApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAqIE1ldGhvZCB0aGF0IHNob3VsZCBiZSBpbXBsZW1lbnRlZCBieSBzdWJjbGFzc2VzIHRvIGRlZmluZSB0aGUgc3BlY2lmaWMgcHJlLXRva2VuaXphdGlvbiBsb2dpYy5cbiAgICpcbiAgICogQGFic3RyYWN0XG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IFRoZSB0ZXh0IHRvIHByZS10b2tlbml6ZS5cbiAgICogQHJldHVybnMge3N0cmluZ1tdfSBUaGUgcHJlLXRva2VuaXplZCB0ZXh0LlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIG1ldGhvZCBpcyBub3QgaW1wbGVtZW50ZWQgaW4gdGhlIHN1YmNsYXNzLlxuICAgKi9cbiAgICBwcmVfdG9rZW5pemVfdGV4dCh0ZXh0KSB7XG4gICAgICAgIHRocm93IEVycm9yKFwicHJlX3Rva2VuaXplX3RleHQgc2hvdWxkIGJlIGltcGxlbWVudGVkIGluIHN1YmNsYXNzLlwiKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRva2VuaXplcyB0aGUgZ2l2ZW4gdGV4dCBpbnRvIHByZS10b2tlbnMuXG4gICAgICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IHRleHQgVGhlIHRleHQgb3IgYXJyYXkgb2YgdGV4dHMgdG8gcHJlLXRva2VuaXplLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmdbXX0gQW4gYXJyYXkgb2YgcHJlLXRva2Vucy5cbiAgICAgKi9cbiAgICBwcmVfdG9rZW5pemUodGV4dCkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRleHQpKSB7XG4gICAgICAgICAgICByZXN1bHQgPSB0ZXh0Lm1hcCh4ID0+IHRoaXMucHJlX3Rva2VuaXplX3RleHQoeCkpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLnByZV90b2tlbml6ZV90ZXh0KHRleHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQuZmxhdCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFsaWFzIGZvciB7QGxpbmsgUHJlVG9rZW5pemVyI3ByZV90b2tlbml6ZX0uXG4gICAgICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IHRleHQgVGhlIHRleHQgb3IgYXJyYXkgb2YgdGV4dHMgdG8gcHJlLXRva2VuaXplLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmdbXX0gQW4gYXJyYXkgb2YgcHJlLXRva2Vucy5cbiAgICAgKi9cbiAgICBfY2FsbCh0ZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByZV90b2tlbml6ZSh0ZXh0KTtcbiAgICB9XG59XG5cbi8qKlxuICogQGV4dGVuZHMgUHJlVG9rZW5pemVyXG4gKi9cbmNsYXNzIEJlcnRQcmVUb2tlbml6ZXIgZXh0ZW5kcyBQcmVUb2tlbml6ZXIge1xuICAgIC8qKlxuICAgICAqIEEgUHJlVG9rZW5pemVyIHRoYXQgc3BsaXRzIHRleHQgaW50byB3b3JkcGllY2VzIHVzaW5nIGEgYmFzaWMgdG9rZW5pemF0aW9uIHNjaGVtZVxuICAgICAqIHNpbWlsYXIgdG8gdGhhdCB1c2VkIGluIHRoZSBvcmlnaW5hbCBpbXBsZW1lbnRhdGlvbiBvZiBCRVJULlxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgVGhlIGNvbmZpZ3VyYXRpb24gb2JqZWN0LlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICAvLyBDb25zdHJ1Y3QgYSBwYXR0ZXJuIHdoaWNoIG1hdGNoZXMgdGhlIHJ1c3QgaW1wbGVtZW50YXRpb246XG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9odWdnaW5nZmFjZS90b2tlbml6ZXJzL2Jsb2IvYjRmY2M5Y2U2ZTRhZDU4MDZlODI4MjZmODE2YWNmZGZkYzRmY2M2Ny90b2tlbml6ZXJzL3NyYy9wcmVfdG9rZW5pemVycy9iZXJ0LnJzI0wxMVxuICAgICAgICAvLyBFcXVpdmFsZW50IHRvIHJlbW92aW5nIHdoaXRlc3BhY2UgYW5kIHNwbGl0dGluZyBvbiBwdW5jdHVhdGlvbiAoYm90aCBcXHB7UH0gYW5kIG90aGVyIGFzY2lpIGNoYXJhY3RlcnMpXG4gICAgICAgIHRoaXMucGF0dGVybiA9IG5ldyBSZWdFeHAoYFteXFxcXHMke1BVTkNUVUFUSU9OX1JFR0VYfV0rfFske1BVTkNUVUFUSU9OX1JFR0VYfV1gLCAnZ3UnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVG9rZW5pemVzIGEgc2luZ2xlIHRleHQgdXNpbmcgdGhlIEJFUlQgcHJlLXRva2VuaXphdGlvbiBzY2hlbWUuXG4gICAgICogXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgVGhlIHRleHQgdG8gdG9rZW5pemUuXG4gICAgICogQHJldHVybnMge3N0cmluZ1tdfSBBbiBhcnJheSBvZiB0b2tlbnMuXG4gICAgICovXG4gICAgcHJlX3Rva2VuaXplX3RleHQodGV4dCkge1xuICAgICAgICByZXR1cm4gdGV4dC50cmltKCkubWF0Y2godGhpcy5wYXR0ZXJuKSB8fCBbXTtcbiAgICB9XG59XG5cbi8qKlxuICogQSBwcmUtdG9rZW5pemVyIHRoYXQgc3BsaXRzIHRleHQgaW50byBCeXRlLVBhaXItRW5jb2RpbmcgKEJQRSkgc3Vid29yZHMuXG4gKiBAZXh0ZW5kcyBQcmVUb2tlbml6ZXJcbiAqL1xuY2xhc3MgQnl0ZUxldmVsUHJlVG9rZW5pemVyIGV4dGVuZHMgUHJlVG9rZW5pemVyIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIHRoZSBgQnl0ZUxldmVsUHJlVG9rZW5pemVyYCBjbGFzcy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIFRoZSBjb25maWd1cmF0aW9uIG9iamVjdC5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5jb25maWcgPSBjb25maWc7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufSBXaGV0aGVyIHRvIGFkZCBhIGxlYWRpbmcgc3BhY2UgdG8gdGhlIGZpcnN0IHdvcmQuXG4gICAgICAgICAqIFRoaXMgYWxsb3dzIHRvIHRyZWF0IHRoZSBsZWFkaW5nIHdvcmQganVzdCBhcyBhbnkgb3RoZXIgd29yZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYWRkX3ByZWZpeF9zcGFjZSA9IHRoaXMuY29uZmlnLmFkZF9wcmVmaXhfc3BhY2U7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufSBXaGV0aGVyIHRoZSBwb3N0IHByb2Nlc3Npbmcgc3RlcCBzaG91bGQgdHJpbSBvZmZzZXRzXG4gICAgICAgICAqIHRvIGF2b2lkIGluY2x1ZGluZyB3aGl0ZXNwYWNlcy5cbiAgICAgICAgICogQHRvZG8gVXNlIHRoaXMgaW4gdGhlIHByZXRva2VuaXphdGlvbiBzdGVwLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy50cmltX29mZnNldHMgPSB0aGlzLmNvbmZpZy50cmltX29mZnNldHM7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufSBXaGV0aGVyIHRvIHVzZSB0aGUgc3RhbmRhcmQgR1BUMiByZWdleCBmb3Igd2hpdGVzcGFjZSBzcGxpdHRpbmcuXG4gICAgICAgICAqIFNldCBpdCB0byBGYWxzZSBpZiB5b3Ugd2FudCB0byB1c2UgeW91ciBvd24gc3BsaXR0aW5nLiBEZWZhdWx0cyB0byB0cnVlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy51c2VfcmVnZXggPSB0aGlzLmNvbmZpZy51c2VfcmVnZXggPz8gdHJ1ZTtcbiAgICAgICAgdGhpcy5wYXR0ZXJuID0gLydzfCd0fCdyZXwndmV8J218J2xsfCdkfCA/XFxwe0x9K3wgP1xccHtOfSt8ID9bXlxcc1xccHtMfVxccHtOfV0rfFxccysoPyFcXFMpfFxccysvZ3U7XG5cbiAgICAgICAgdGhpcy5ieXRlX2VuY29kZXIgPSBCWVRFU19UT19VTklDT0RFO1xuICAgICAgICB0aGlzLnRleHRfZW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRva2VuaXplcyBhIHNpbmdsZSBwaWVjZSBvZiB0ZXh0IHVzaW5nIGJ5dGUtbGV2ZWwgdG9rZW5pemF0aW9uLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IFRoZSB0ZXh0IHRvIHRva2VuaXplLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmdbXX0gQW4gYXJyYXkgb2YgdG9rZW5zLlxuICAgICAqL1xuICAgIHByZV90b2tlbml6ZV90ZXh0KHRleHQpIHtcbiAgICAgICAgLy8gU3BsaXQgb24gd2hpdGVzcGFjZSBhbmQgcHVuY3R1YXRpb25cbiAgICAgICAgbGV0IHRva2VucyA9IHRoaXMudXNlX3JlZ2V4ID8gKHRleHQubWF0Y2godGhpcy5wYXR0ZXJuKSB8fCBbXSkgOiBbdGV4dF07XG5cbiAgICAgICAgcmV0dXJuIHRva2Vucy5tYXAodG9rZW4gPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuYWRkX3ByZWZpeF9zcGFjZSAmJiAhdG9rZW4uc3RhcnRzV2l0aCgnICcpKSB7XG4gICAgICAgICAgICAgICAgdG9rZW4gPSAnICcgKyB0b2tlbjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gTWFwcyBhbGwgb3VyIGJ5dGVzIHRvIHVuaWNvZGUgc3RyaW5ncywgYXZvaWRpbmcgY29udHJvbCB0b2tlbnMgb2YgdGhlIEJQRSAoc3BhY2VzIGluIG91ciBjYXNlKVxuICAgICAgICAgICAgdG9rZW4gPSBBcnJheS5mcm9tKHRoaXMudGV4dF9lbmNvZGVyLmVuY29kZSh0b2tlbiksIGJ5dGUgPT4gdGhpcy5ieXRlX2VuY29kZXJbYnl0ZV0pLmpvaW4oJycpO1xuXG4gICAgICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAdHlwZWRlZiB7J3JlbW92ZWQnfCdpc29sYXRlZCd8J21lcmdlZFdpdGhQcmV2aW91cyd8J21lcmdlZFdpdGhOZXh0J3wnY29udGlndW91cyd9IFNwbGl0RGVsaW1pdGVyQmVoYXZpb3JcbiAqL1xuXG4vKipcbiAqIFNwbGl0cyB0ZXh0IHVzaW5nIGEgZ2l2ZW4gcGF0dGVybi5cbiAqIEBleHRlbmRzIFByZVRva2VuaXplclxuICovXG5jbGFzcyBTcGxpdFByZVRva2VuaXplciBleHRlbmRzIFByZVRva2VuaXplciB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBUaGUgY29uZmlndXJhdGlvbiBvcHRpb25zIGZvciB0aGUgcHJlLXRva2VuaXplci5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnLnBhdHRlcm4gVGhlIHBhdHRlcm4gdXNlZCB0byBzcGxpdCB0aGUgdGV4dC4gQ2FuIGJlIGEgc3RyaW5nIG9yIGEgcmVnZXggb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfHVuZGVmaW5lZH0gY29uZmlnLnBhdHRlcm4uU3RyaW5nIFRoZSBzdHJpbmcgdG8gdXNlIGZvciBzcGxpdHRpbmcuIE9ubHkgZGVmaW5lZCBpZiB0aGUgcGF0dGVybiBpcyBhIHN0cmluZy5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ3x1bmRlZmluZWR9IGNvbmZpZy5wYXR0ZXJuLlJlZ2V4IFRoZSByZWdleCB0byB1c2UgZm9yIHNwbGl0dGluZy4gT25seSBkZWZpbmVkIGlmIHRoZSBwYXR0ZXJuIGlzIGEgcmVnZXguXG4gICAgICogQHBhcmFtIHtTcGxpdERlbGltaXRlckJlaGF2aW9yfSBjb25maWcuYmVoYXZpb3IgVGhlIGJlaGF2aW9yIHRvIHVzZSB3aGVuIHNwbGl0dGluZy5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGNvbmZpZy5pbnZlcnQgV2hldGhlciB0byBzcGxpdCAoaW52ZXJ0PWZhbHNlKSBvciBtYXRjaCAoaW52ZXJ0PXRydWUpIHRoZSBwYXR0ZXJuLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICAgICAgLy8gVE9ETyBzdXBwb3J0IGFsbCBiZWhhdmlvdXJzIChjb25maWcuYmVoYXZpb3IpXG5cbiAgICAgICAgdGhpcy5wYXR0ZXJuID0gY3JlYXRlUGF0dGVybih0aGlzLmNvbmZpZy5wYXR0ZXJuLCB0aGlzLmNvbmZpZy5pbnZlcnQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRva2VuaXplcyB0ZXh0IGJ5IHNwbGl0dGluZyBpdCB1c2luZyB0aGUgZ2l2ZW4gcGF0dGVybi5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCBUaGUgdGV4dCB0byB0b2tlbml6ZS5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nW119IEFuIGFycmF5IG9mIHRva2Vucy5cbiAgICAgKi9cbiAgICBwcmVfdG9rZW5pemVfdGV4dCh0ZXh0KSB7XG4gICAgICAgIGlmICh0aGlzLnBhdHRlcm4gPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmNvbmZpZy5pbnZlcnQpIHtcbiAgICAgICAgICAgIHJldHVybiB0ZXh0Lm1hdGNoKHRoaXMucGF0dGVybikgfHwgW107XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGV4dC5zcGxpdCh0aGlzLnBhdHRlcm4pLmZpbHRlcih4ID0+IHgpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIFNwbGl0cyB0ZXh0IGJhc2VkIG9uIHB1bmN0dWF0aW9uLlxuICogQGV4dGVuZHMgUHJlVG9rZW5pemVyXG4gKi9cbmNsYXNzIFB1bmN0dWF0aW9uUHJlVG9rZW5pemVyIGV4dGVuZHMgUHJlVG9rZW5pemVyIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIFRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgZm9yIHRoZSBwcmUtdG9rZW5pemVyLlxuICAgICAqIEBwYXJhbSB7U3BsaXREZWxpbWl0ZXJCZWhhdmlvcn0gY29uZmlnLmJlaGF2aW9yIFRoZSBiZWhhdmlvciB0byB1c2Ugd2hlbiBzcGxpdHRpbmcuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgICAgICB0aGlzLnBhdHRlcm4gPSBuZXcgUmVnRXhwKGBbXiR7UFVOQ1RVQVRJT05fUkVHRVh9XSt8WyR7UFVOQ1RVQVRJT05fUkVHRVh9XStgLCAnZ3UnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUb2tlbml6ZXMgdGV4dCBieSBzcGxpdHRpbmcgaXQgdXNpbmcgdGhlIGdpdmVuIHBhdHRlcm4uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgVGhlIHRleHQgdG8gdG9rZW5pemUuXG4gICAgICogQHJldHVybnMge3N0cmluZ1tdfSBBbiBhcnJheSBvZiB0b2tlbnMuXG4gICAgICovXG4gICAgcHJlX3Rva2VuaXplX3RleHQodGV4dCkge1xuICAgICAgICByZXR1cm4gdGV4dC5tYXRjaCh0aGlzLnBhdHRlcm4pIHx8IFtdO1xuICAgIH1cbn1cblxuXG4vKipcbiAqIFNwbGl0cyB0ZXh0IGJhc2VkIG9uIGRpZ2l0cy5cbiAqIEBleHRlbmRzIFByZVRva2VuaXplclxuICovXG5jbGFzcyBEaWdpdHNQcmVUb2tlbml6ZXIgZXh0ZW5kcyBQcmVUb2tlbml6ZXIge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyBmb3IgdGhlIHByZS10b2tlbml6ZXIuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBjb25maWcuaW5kaXZpZHVhbF9kaWdpdHMgV2hldGhlciB0byBzcGxpdCBvbiBpbmRpdmlkdWFsIGRpZ2l0cy5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5jb25maWcgPSBjb25maWc7XG5cbiAgICAgICAgLy8gQ29uc3RydWN0IGEgcGF0dGVybiB3aGljaCBtYXRjaGVzIHRoZSBydXN0IGltcGxlbWVudGF0aW9uOlxuICAgICAgICBjb25zdCBkaWdpdF9wYXR0ZXJuID0gYFteXFxcXGRdK3xcXFxcZCR7dGhpcy5jb25maWcuaW5kaXZpZHVhbF9kaWdpdHMgPyAnJyA6ICcrJ31gO1xuICAgICAgICB0aGlzLnBhdHRlcm4gPSBuZXcgUmVnRXhwKGRpZ2l0X3BhdHRlcm4sICdndScpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRva2VuaXplcyB0ZXh0IGJ5IHNwbGl0dGluZyBpdCB1c2luZyB0aGUgZ2l2ZW4gcGF0dGVybi5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCBUaGUgdGV4dCB0byB0b2tlbml6ZS5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nW119IEFuIGFycmF5IG9mIHRva2Vucy5cbiAgICAgKi9cbiAgICBwcmVfdG9rZW5pemVfdGV4dCh0ZXh0KSB7XG4gICAgICAgIHJldHVybiB0ZXh0Lm1hdGNoKHRoaXMucGF0dGVybikgfHwgW107XG4gICAgfVxufVxuXG4vKipcbiAqIEBleHRlbmRzIENhbGxhYmxlXG4gKi9cbmNsYXNzIFBvc3RQcm9jZXNzb3IgZXh0ZW5kcyBDYWxsYWJsZSB7XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIFRoZSBjb25maWd1cmF0aW9uIGZvciB0aGUgcG9zdC1wcm9jZXNzb3IuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZhY3RvcnkgbWV0aG9kIHRvIGNyZWF0ZSBhIFBvc3RQcm9jZXNzb3Igb2JqZWN0IGZyb20gYSBjb25maWd1cmF0aW9uIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgQ29uZmlndXJhdGlvbiBvYmplY3QgcmVwcmVzZW50aW5nIGEgUG9zdFByb2Nlc3Nvci5cbiAgICAgKiBAcmV0dXJucyB7UG9zdFByb2Nlc3Nvcn0gQSBQb3N0UHJvY2Vzc29yIG9iamVjdCBjcmVhdGVkIGZyb20gdGhlIGdpdmVuIGNvbmZpZ3VyYXRpb24uXG4gICAgICogQHRocm93cyB7RXJyb3J9IElmIGFuIHVua25vd24gUG9zdFByb2Nlc3NvciB0eXBlIGlzIGVuY291bnRlcmVkLlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tQ29uZmlnKGNvbmZpZykge1xuICAgICAgICBpZiAoY29uZmlnID09PSBudWxsKSByZXR1cm4gbnVsbDtcbiAgICAgICAgc3dpdGNoIChjb25maWcudHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnVGVtcGxhdGVQcm9jZXNzaW5nJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFRlbXBsYXRlUHJvY2Vzc2luZyhjb25maWcpO1xuXG4gICAgICAgICAgICBjYXNlICdCeXRlTGV2ZWwnOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQnl0ZUxldmVsUG9zdFByb2Nlc3Nvcihjb25maWcpO1xuXG4gICAgICAgICAgICBjYXNlICdSb2JlcnRhUHJvY2Vzc2luZyc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBSb2JlcnRhUHJvY2Vzc2luZyhjb25maWcpO1xuXG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBQb3N0UHJvY2Vzc29yIHR5cGU6ICR7Y29uZmlnLnR5cGV9YCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdG8gYmUgaW1wbGVtZW50ZWQgaW4gc3ViY2xhc3MgdG8gYXBwbHkgcG9zdC1wcm9jZXNzaW5nIG9uIHRoZSBnaXZlbiB0b2tlbnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5fSB0b2tlbnMgVGhlIGlucHV0IHRva2VucyB0byBiZSBwb3N0LXByb2Nlc3NlZC5cbiAgICAgKiBAcGFyYW0gey4uLip9IGFyZ3MgQWRkaXRpb25hbCBhcmd1bWVudHMgcmVxdWlyZWQgYnkgdGhlIHBvc3QtcHJvY2Vzc2luZyBsb2dpYy5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFRoZSBwb3N0LXByb2Nlc3NlZCB0b2tlbnMuXG4gICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBtZXRob2QgaXMgbm90IGltcGxlbWVudGVkIGluIHN1YmNsYXNzLlxuICAgICAqL1xuICAgIHBvc3RfcHJvY2Vzcyh0b2tlbnMsIC4uLmFyZ3MpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJwb3N0X3Byb2Nlc3Mgc2hvdWxkIGJlIGltcGxlbWVudGVkIGluIHN1YmNsYXNzLlwiKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFsaWFzIGZvciB7QGxpbmsgUG9zdFByb2Nlc3NvciNwb3N0X3Byb2Nlc3N9LlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHRva2VucyBUaGUgdGV4dCBvciBhcnJheSBvZiB0ZXh0cyB0byBwb3N0LXByb2Nlc3MuXG4gICAgICogQHBhcmFtIHsuLi4qfSBhcmdzIEFkZGl0aW9uYWwgYXJndW1lbnRzIHJlcXVpcmVkIGJ5IHRoZSBwb3N0LXByb2Nlc3NpbmcgbG9naWMuXG4gICAgICogQHJldHVybnMge0FycmF5fSBBbiBhcnJheSBvZiBwb3N0LXByb2Nlc3NlZCB0b2tlbnMuXG4gICAgICovXG4gICAgX2NhbGwodG9rZW5zLCAuLi5hcmdzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBvc3RfcHJvY2Vzcyh0b2tlbnMsIC4uLmFyZ3MpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBBIHBvc3QtcHJvY2Vzc29yIHRoYXQgYWRkcyBzcGVjaWFsIHRva2VucyB0byB0aGUgYmVnaW5uaW5nIGFuZCBlbmQgb2YgdGhlIGlucHV0LlxuICogQGV4dGVuZHMgUG9zdFByb2Nlc3NvclxuICovXG5jbGFzcyBSb2JlcnRhUHJvY2Vzc2luZyBleHRlbmRzIFBvc3RQcm9jZXNzb3Ige1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgVGhlIGNvbmZpZ3VyYXRpb24gZm9yIHRoZSBwb3N0LXByb2Nlc3Nvci5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBjb25maWcuY2xzIFRoZSBzcGVjaWFsIHRva2VucyB0byBhZGQgdG8gdGhlIGJlZ2lubmluZyBvZiB0aGUgaW5wdXQuXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gY29uZmlnLnNlcCBUaGUgc3BlY2lhbCB0b2tlbnMgdG8gYWRkIHRvIHRoZSBlbmQgb2YgdGhlIGlucHV0LlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgICAgICBzdXBlcihjb25maWcpO1xuICAgICAgICAvLyBUT0RPIHVzZSBhbGwgb2YgY29uZmlnOiBhZGRfcHJlZml4X3NwYWNlLCB0cmltX29mZnNldHNcblxuICAgICAgICB0aGlzLmNscyA9IGNvbmZpZy5jbHNbMF07XG4gICAgICAgIHRoaXMuc2VwID0gY29uZmlnLnNlcFswXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIHRoZSBzcGVjaWFsIHRva2VucyB0byB0aGUgYmVnaW5uaW5nIGFuZCBlbmQgb2YgdGhlIGlucHV0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IHRva2VucyBUaGUgaW5wdXQgdG9rZW5zLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nW118bnVsbH0gdG9rZW5zX3BhaXIgQW4gb3B0aW9uYWwgc2Vjb25kIHNldCBvZiBpbnB1dCB0b2tlbnMuXG4gICAgICogQHJldHVybnMge3N0cmluZ1tdfSBUaGUgaW5wdXQgdG9rZW5zIHdpdGggdGhlIHNwZWNpYWwgdG9rZW5zIGFkZGVkIHRvIHRoZSBiZWdpbm5pbmcgYW5kIGVuZC5cbiAgICAgKi9cbiAgICBwb3N0X3Byb2Nlc3ModG9rZW5zLCB0b2tlbnNfcGFpciA9IG51bGwpIHtcbiAgICAgICAgdG9rZW5zID0gbWVyZ2VBcnJheXMoW3RoaXMuY2xzXSwgdG9rZW5zLCBbdGhpcy5zZXBdKTtcblxuICAgICAgICAvLyBOT1RFOiBJdCBpcyBpbnRlbmRlZCB0byBhZGQgMiBFT1MgdG9rZW5zIGFmdGVyIHRoZSBmaXJzdCBzZXQgb2YgdG9rZW5zXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9odWdnaW5nZmFjZS90b2tlbml6ZXJzL2lzc3Vlcy85ODNcbiAgICAgICAgaWYgKHRva2Vuc19wYWlyICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0b2tlbnMgPSBtZXJnZUFycmF5cyh0b2tlbnMsIFt0aGlzLnNlcF0sIHRva2Vuc19wYWlyLCBbdGhpcy5zZXBdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG9rZW5zO1xuICAgIH1cbn1cblxuLyoqXG4gKiBQb3N0IHByb2Nlc3NvciB0aGF0IHJlcGxhY2VzIHNwZWNpYWwgdG9rZW5zIGluIGEgdGVtcGxhdGUgd2l0aCBhY3R1YWwgdG9rZW5zLlxuICogQGV4dGVuZHMgUG9zdFByb2Nlc3NvclxuICovXG5jbGFzcyBUZW1wbGF0ZVByb2Nlc3NpbmcgZXh0ZW5kcyBQb3N0UHJvY2Vzc29yIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIGBUZW1wbGF0ZVByb2Nlc3NpbmdgLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyBmb3IgdGhlIHBvc3QgcHJvY2Vzc29yLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGNvbmZpZy5zaW5nbGUgVGhlIHRlbXBsYXRlIGZvciBhIHNpbmdsZSBzZXF1ZW5jZSBvZiB0b2tlbnMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gY29uZmlnLnBhaXIgVGhlIHRlbXBsYXRlIGZvciBhIHBhaXIgb2Ygc2VxdWVuY2VzIG9mIHRva2Vucy5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICAgICAgc3VwZXIoY29uZmlnKTtcblxuICAgICAgICB0aGlzLnNpbmdsZSA9IGNvbmZpZy5zaW5nbGU7XG4gICAgICAgIHRoaXMucGFpciA9IGNvbmZpZy5wYWlyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlcGxhY2VzIHNwZWNpYWwgdG9rZW5zIGluIHRoZSB0ZW1wbGF0ZSB3aXRoIGFjdHVhbCB0b2tlbnMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gdG9rZW5zIFRoZSBsaXN0IG9mIHRva2VucyBmb3IgdGhlIGZpcnN0IHNlcXVlbmNlLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFt0b2tlbnNfcGFpcj1udWxsXSBUaGUgbGlzdCBvZiB0b2tlbnMgZm9yIHRoZSBzZWNvbmQgc2VxdWVuY2UgKG9wdGlvbmFsKS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFRoZSBsaXN0IG9mIHRva2VucyB3aXRoIHRoZSBzcGVjaWFsIHRva2VucyByZXBsYWNlZCB3aXRoIGFjdHVhbCB0b2tlbnMuXG4gICAgICovXG4gICAgcG9zdF9wcm9jZXNzKHRva2VucywgdG9rZW5zX3BhaXIgPSBudWxsKSB7XG4gICAgICAgIGxldCB0eXBlID0gdG9rZW5zX3BhaXIgPT09IG51bGwgPyB0aGlzLnNpbmdsZSA6IHRoaXMucGFpclxuXG4gICAgICAgIGxldCB0b1JldHVybiA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpdGVtIG9mIHR5cGUpIHtcbiAgICAgICAgICAgIGlmICgnU3BlY2lhbFRva2VuJyBpbiBpdGVtKSB7XG4gICAgICAgICAgICAgICAgdG9SZXR1cm4ucHVzaChpdGVtLlNwZWNpYWxUb2tlbi5pZCk7XG5cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoJ1NlcXVlbmNlJyBpbiBpdGVtKSB7XG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0uU2VxdWVuY2UuaWQgPT09ICdBJykge1xuICAgICAgICAgICAgICAgICAgICB0b1JldHVybiA9IG1lcmdlQXJyYXlzKHRvUmV0dXJuLCB0b2tlbnMpO1xuXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpdGVtLlNlcXVlbmNlLmlkID09PSAnQicpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9SZXR1cm4gPSBtZXJnZUFycmF5cyh0b1JldHVybiwgdG9rZW5zX3BhaXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG9SZXR1cm47XG4gICAgfVxufVxuXG4vKipcbiAqIEEgUG9zdFByb2Nlc3NvciB0aGF0IHJldHVybnMgdGhlIGdpdmVuIHRva2VucyBhcyBpcy5cbiAqIEBleHRlbmRzIFBvc3RQcm9jZXNzb3JcbiAqL1xuY2xhc3MgQnl0ZUxldmVsUG9zdFByb2Nlc3NvciBleHRlbmRzIFBvc3RQcm9jZXNzb3Ige1xuICAgIC8qKlxuICAgICAqIFBvc3QgcHJvY2VzcyB0aGUgZ2l2ZW4gdG9rZW5zLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IHRva2VucyBUaGUgdG9rZW5zIHRvIGJlIHBvc3QgcHJvY2Vzc2VkLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmdbXX0gVGhlIHBvc3QgcHJvY2Vzc2VkIHRva2Vucy5cbiAgICAgKi9cbiAgICBwb3N0X3Byb2Nlc3ModG9rZW5zKSB7XG4gICAgICAgIHJldHVybiB0b2tlbnM7XG4gICAgfVxufVxuXG4vKipcbiAqIFRoZSBiYXNlIGNsYXNzIGZvciB0b2tlbiBkZWNvZGVycy5cbiAqIEBleHRlbmRzIENhbGxhYmxlXG4gKi9cbmNsYXNzIERlY29kZXIgZXh0ZW5kcyBDYWxsYWJsZSB7XG5cbiAgICAvKipcbiAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgYERlY29kZXJgLlxuICAgICpcbiAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgVGhlIGNvbmZpZ3VyYXRpb24gb2JqZWN0LlxuICAgICovXG4gICAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuXG4gICAgICAgIHRoaXMuYWRkZWRfdG9rZW5zID0gW107XG4gICAgICAgIHRoaXMuZW5kX29mX3dvcmRfc3VmZml4ID0gbnVsbDtcbiAgICAgICAgdGhpcy50cmltX29mZnNldHMgPSBjb25maWcudHJpbV9vZmZzZXRzO1xuICAgIH1cblxuICAgIC8qKlxuICAgKiBDcmVhdGVzIGEgZGVjb2RlciBpbnN0YW5jZSBiYXNlZCBvbiB0aGUgcHJvdmlkZWQgY29uZmlndXJhdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBUaGUgY29uZmlndXJhdGlvbiBvYmplY3QuXG4gICAqIEByZXR1cm5zIHtEZWNvZGVyfSBBIGRlY29kZXIgaW5zdGFuY2UuXG4gICAqIEB0aHJvd3Mge0Vycm9yfSBJZiBhbiB1bmtub3duIGRlY29kZXIgdHlwZSBpcyBwcm92aWRlZC5cbiAgICovXG4gICAgc3RhdGljIGZyb21Db25maWcoY29uZmlnKSB7XG4gICAgICAgIHN3aXRjaCAoY29uZmlnLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ1dvcmRQaWVjZSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBXb3JkUGllY2VEZWNvZGVyKGNvbmZpZyk7XG4gICAgICAgICAgICBjYXNlICdNZXRhc3BhY2UnOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgTWV0YXNwYWNlRGVjb2Rlcihjb25maWcpO1xuICAgICAgICAgICAgY2FzZSAnQnl0ZUxldmVsJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEJ5dGVMZXZlbERlY29kZXIoY29uZmlnKTtcblxuICAgICAgICAgICAgY2FzZSAnUmVwbGFjZSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBSZXBsYWNlRGVjb2Rlcihjb25maWcpO1xuICAgICAgICAgICAgY2FzZSAnQnl0ZUZhbGxiYWNrJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEJ5dGVGYWxsYmFjayhjb25maWcpO1xuICAgICAgICAgICAgY2FzZSAnRnVzZSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBGdXNlRGVjb2Rlcihjb25maWcpO1xuICAgICAgICAgICAgY2FzZSAnU3RyaXAnOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU3RyaXBEZWNvZGVyKGNvbmZpZyk7XG5cbiAgICAgICAgICAgIGNhc2UgJ1NlcXVlbmNlJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IERlY29kZXJTZXF1ZW5jZShjb25maWcpO1xuXG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBEZWNvZGVyIHR5cGU6ICR7Y29uZmlnLnR5cGV9YCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAqIENhbGxzIHRoZSBgZGVjb2RlYCBtZXRob2QuXG4gICAgKlxuICAgICogQHBhcmFtIHtzdHJpbmdbXX0gdG9rZW5zIFRoZSBsaXN0IG9mIHRva2Vucy5cbiAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBkZWNvZGVkIHN0cmluZy5cbiAgICAqL1xuICAgIF9jYWxsKHRva2Vucykge1xuICAgICAgICByZXR1cm4gdGhpcy5kZWNvZGUodG9rZW5zKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAqIERlY29kZXMgYSBsaXN0IG9mIHRva2Vucy5cbiAgICAqIEBwYXJhbSB7c3RyaW5nW119IHRva2VucyBUaGUgbGlzdCBvZiB0b2tlbnMuXG4gICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgZGVjb2RlZCBzdHJpbmcuXG4gICAgKi9cbiAgICBkZWNvZGUodG9rZW5zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlY29kZV9jaGFpbih0b2tlbnMpLmpvaW4oJycpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFwcGx5IHRoZSBkZWNvZGVyIHRvIGEgbGlzdCBvZiB0b2tlbnMuXG4gICAgICogXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gdG9rZW5zIFRoZSBsaXN0IG9mIHRva2Vucy5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nW119IFRoZSBkZWNvZGVkIGxpc3Qgb2YgdG9rZW5zLlxuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgYGRlY29kZV9jaGFpbmAgbWV0aG9kIGlzIG5vdCBpbXBsZW1lbnRlZCBpbiB0aGUgc3ViY2xhc3MuXG4gICAgICovXG4gICAgZGVjb2RlX2NoYWluKHRva2Vucykge1xuICAgICAgICB0aHJvdyBFcnJvcihcImBkZWNvZGVfY2hhaW5gIHNob3VsZCBiZSBpbXBsZW1lbnRlZCBpbiBzdWJjbGFzcy5cIilcbiAgICB9XG5cbn1cblxuY2xhc3MgUmVwbGFjZURlY29kZXIgZXh0ZW5kcyBEZWNvZGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICAgICAgc3VwZXIoY29uZmlnKTtcbiAgICB9XG5cbiAgICAvKiogQHR5cGUge0RlY29kZXJbJ2RlY29kZV9jaGFpbiddfSAqL1xuICAgIGRlY29kZV9jaGFpbih0b2tlbnMpIHtcbiAgICAgICAgbGV0IHBhdHRlcm4gPSBjcmVhdGVQYXR0ZXJuKHRoaXMuY29uZmlnLnBhdHRlcm4pO1xuICAgICAgICBpZiAocGF0dGVybiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRva2VucztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0b2tlbnMubWFwKHRva2VuID0+IHRva2VuLnJlcGxhY2VBbGwocGF0dGVybiwgdGhpcy5jb25maWcuY29udGVudCkpXG4gICAgfVxufVxuXG5cbmNsYXNzIEJ5dGVGYWxsYmFjayBleHRlbmRzIERlY29kZXIge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgICAgICBzdXBlcihjb25maWcpO1xuXG4gICAgICAgIHRoaXMudGV4dF9kZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCk7XG4gICAgfVxuXG4gICAgLyoqIEB0eXBlIHtEZWNvZGVyWydkZWNvZGVfY2hhaW4nXX0gKi9cbiAgICBkZWNvZGVfY2hhaW4odG9rZW5zKSB7XG5cbiAgICAgICAgbGV0IG5ld190b2tlbnMgPSBbXTtcbiAgICAgICAgbGV0IHByZXZpb3VzX2J5dGVfdG9rZW5zID0gW107XG5cbiAgICAgICAgZm9yIChsZXQgdG9rZW4gb2YgdG9rZW5zKSB7XG4gICAgICAgICAgICBsZXQgYnl0ZXMgPSBudWxsO1xuICAgICAgICAgICAgaWYgKHRva2VuLmxlbmd0aCA9PT0gNiAmJiB0b2tlbi5zdGFydHNXaXRoKCc8MHgnKSAmJiB0b2tlbi5lbmRzV2l0aCgnPicpKSB7XG4gICAgICAgICAgICAgICAgbGV0IGJ5dGUgPSBwYXJzZUludCh0b2tlbi5zbGljZSgzLCA1KSwgMTYpO1xuICAgICAgICAgICAgICAgIGlmICghaXNOYU4oYnl0ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgYnl0ZXMgPSBieXRlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChieXRlcyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHByZXZpb3VzX2J5dGVfdG9rZW5zLnB1c2goYnl0ZXMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAocHJldmlvdXNfYnl0ZV90b2tlbnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgc3RyaW5nID0gdGhpcy50ZXh0X2RlY29kZXIuZGVjb2RlKFVpbnQ4QXJyYXkuZnJvbShwcmV2aW91c19ieXRlX3Rva2VucykpO1xuICAgICAgICAgICAgICAgICAgICBuZXdfdG9rZW5zLnB1c2goc3RyaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgcHJldmlvdXNfYnl0ZV90b2tlbnMgPSBbXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbmV3X3Rva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocHJldmlvdXNfYnl0ZV90b2tlbnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgbGV0IHN0cmluZyA9IHRoaXMudGV4dF9kZWNvZGVyLmRlY29kZShVaW50OEFycmF5LmZyb20ocHJldmlvdXNfYnl0ZV90b2tlbnMpKTtcbiAgICAgICAgICAgIG5ld190b2tlbnMucHVzaChzdHJpbmcpO1xuICAgICAgICAgICAgcHJldmlvdXNfYnl0ZV90b2tlbnMgPSBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXdfdG9rZW5zO1xuICAgIH1cbn1cblxuLyoqXG4gKiBGdXNlIHNpbXBseSBmdXNlcyBhbGwgdG9rZW5zIGludG8gb25lIGJpZyBzdHJpbmcuXG4gKiBJdCdzIHVzdWFsbHkgdGhlIGxhc3QgZGVjb2Rpbmcgc3RlcCBhbnl3YXksIGJ1dCB0aGlzIGRlY29kZXJcbiAqIGV4aXN0cyBpbmNhc2Ugc29tZSBkZWNvZGVycyBuZWVkIHRvIGhhcHBlbiBhZnRlciB0aGF0IHN0ZXBcbiAqL1xuY2xhc3MgRnVzZURlY29kZXIgZXh0ZW5kcyBEZWNvZGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICAgICAgc3VwZXIoY29uZmlnKTtcbiAgICB9XG5cbiAgICAvKiogQHR5cGUge0RlY29kZXJbJ2RlY29kZV9jaGFpbiddfSAqL1xuICAgIGRlY29kZV9jaGFpbih0b2tlbnMpIHtcbiAgICAgICAgcmV0dXJuIFt0b2tlbnMuam9pbignJyldO1xuICAgIH1cbn1cblxuY2xhc3MgU3RyaXBEZWNvZGVyIGV4dGVuZHMgRGVjb2RlciB7XG4gICAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZyk7XG5cbiAgICAgICAgdGhpcy5jb250ZW50ID0gdGhpcy5jb25maWcuY29udGVudDtcbiAgICAgICAgdGhpcy5zdGFydCA9IHRoaXMuY29uZmlnLnN0YXJ0O1xuICAgICAgICB0aGlzLnN0b3AgPSB0aGlzLmNvbmZpZy5zdG9wO1xuICAgIH1cblxuICAgIC8qKiBAdHlwZSB7RGVjb2RlclsnZGVjb2RlX2NoYWluJ119ICovXG4gICAgZGVjb2RlX2NoYWluKHRva2Vucykge1xuICAgICAgICByZXR1cm4gdG9rZW5zLm1hcCh0b2tlbiA9PiB7XG4gICAgICAgICAgICBsZXQgc3RhcnRfY3V0ID0gMDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zdGFydDsgKytpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRva2VuW2ldID09PSB0aGlzLmNvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRfY3V0ID0gaSArIDE7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV0IHN0b3BfY3V0ID0gdG9rZW4ubGVuZ3RoO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnN0b3A7ICsraSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gdG9rZW4ubGVuZ3RoIC0gaSAtIDE7XG4gICAgICAgICAgICAgICAgaWYgKHRva2VuW2luZGV4XSA9PT0gdGhpcy5jb250ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHN0b3BfY3V0ID0gaW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRva2VuLnNsaWNlKHN0YXJ0X2N1dCwgc3RvcF9jdXQpXG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuLyoqXG4gKiBBIGRlY29kZXIgdGhhdCBkZWNvZGVzIGEgbGlzdCBvZiBXb3JkUGllY2UgdG9rZW5zIGludG8gYSBzaW5nbGUgc3RyaW5nLlxuICogQGV4dGVuZHMgRGVjb2RlclxuICovXG5jbGFzcyBXb3JkUGllY2VEZWNvZGVyIGV4dGVuZHMgRGVjb2RlciB7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIFdvcmRQaWVjZURlY29kZXIuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBUaGUgY29uZmlndXJhdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbmZpZy5wcmVmaXggVGhlIHByZWZpeCB1c2VkIGZvciBXb3JkUGllY2UgZW5jb2RpbmcuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBjb25maWcuY2xlYW51cCBXaGV0aGVyIHRvIGNsZWFudXAgdGhlIGRlY29kZWQgc3RyaW5nLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgICAgICBzdXBlcihjb25maWcpO1xuICAgICAgICB0aGlzLmNsZWFudXAgPSBjb25maWcuY2xlYW51cDtcbiAgICB9XG5cbiAgICAvKiogQHR5cGUge0RlY29kZXJbJ2RlY29kZV9jaGFpbiddfSAqL1xuICAgIGRlY29kZV9jaGFpbih0b2tlbnMpIHtcbiAgICAgICAgcmV0dXJuIHRva2Vucy5tYXAoKHRva2VuLCBpKSA9PiB7XG4gICAgICAgICAgICBpZiAoaSAhPT0gMCkge1xuICAgICAgICAgICAgICAgIGlmICh0b2tlbi5zdGFydHNXaXRoKHRoaXMuY29uZmlnLnByZWZpeCkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTk9URTogLnJlcGxhY2UoKSBpcyBpbnRlbmRlZDsgb25seSByZXBsYWNlIGZpcnN0IG9jY3VycmVuY2VcbiAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSB0b2tlbi5yZXBsYWNlKHRoaXMuY29uZmlnLnByZWZpeCwgJycpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRva2VuID0gJyAnICsgdG9rZW47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY2xlYW51cCkge1xuICAgICAgICAgICAgICAgIHRva2VuID0gY2xlYW5fdXBfdG9rZW5pemF0aW9uKHRva2VuKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuLyoqXG4gKiBCeXRlLWxldmVsIGRlY29kZXIgZm9yIHRva2VuaXphdGlvbiBvdXRwdXQuIEluaGVyaXRzIGZyb20gdGhlIGBEZWNvZGVyYCBjbGFzcy5cbiAqIEBleHRlbmRzIERlY29kZXJcbiAqL1xuY2xhc3MgQnl0ZUxldmVsRGVjb2RlciBleHRlbmRzIERlY29kZXIge1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgYEJ5dGVMZXZlbERlY29kZXJgIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIENvbmZpZ3VyYXRpb24gb2JqZWN0LlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgICAgICBzdXBlcihjb25maWcpO1xuXG4gICAgICAgIHRoaXMuYnl0ZV9kZWNvZGVyID0gVU5JQ09ERV9UT19CWVRFUztcbiAgICAgICAgdGhpcy50ZXh0X2RlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoXCJ1dGYtOFwiLCB7XG4gICAgICAgICAgICBmYXRhbDogZmFsc2UsXG4gICAgICAgICAgICBpZ25vcmVCT006IHRydWUsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuZW5kX29mX3dvcmRfc3VmZml4ID0gbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IGFuIGFycmF5IG9mIHRva2VucyB0byBzdHJpbmcgYnkgZGVjb2RpbmcgZWFjaCBieXRlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IHRva2VucyBBcnJheSBvZiB0b2tlbnMgdG8gYmUgZGVjb2RlZC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgZGVjb2RlZCBzdHJpbmcuXG4gICAgICovXG4gICAgY29udmVydF90b2tlbnNfdG9fc3RyaW5nKHRva2Vucykge1xuICAgICAgICBsZXQgdGV4dCA9IHRva2Vucy5qb2luKCcnKTtcblxuICAgICAgICBsZXQgYnl0ZUFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoWy4uLnRleHRdLm1hcChjID0+IHRoaXMuYnl0ZV9kZWNvZGVyW2NdKSk7XG4gICAgICAgIGxldCBkZWNvZGVkX3RleHQgPSB0aGlzLnRleHRfZGVjb2Rlci5kZWNvZGUoYnl0ZUFycmF5KTtcbiAgICAgICAgcmV0dXJuIGRlY29kZWRfdGV4dDtcbiAgICB9XG5cbiAgICAvKiogQHR5cGUge0RlY29kZXJbJ2RlY29kZV9jaGFpbiddfSAqL1xuICAgIGRlY29kZV9jaGFpbih0b2tlbnMpIHtcbiAgICAgICAgLy8gVE9ETyBtb3ZlIHRvIGJhc2UgY2xhc3MgKGxpa2UgSEYpXG4gICAgICAgIC8vIHRva2VucyA9PT0gZmlsdGVyZWRfdG9rZW5zXG5cbiAgICAgICAgLy8gVG8gYXZvaWQgbWl4aW5nIGJ5dGUtbGV2ZWwgYW5kIHVuaWNvZGUgZm9yIGJ5dGUtbGV2ZWwgQlBUXG4gICAgICAgIC8vIHdlIG5lZWQgdG8gYnVpbGQgc3RyaW5nIHNlcGFyYXRlbHkgZm9yIGFkZGVkIHRva2VucyBhbmQgYnl0ZS1sZXZlbCB0b2tlbnNcbiAgICAgICAgLy8gY2YuIGh0dHBzOi8vZ2l0aHViLmNvbS9odWdnaW5nZmFjZS90cmFuc2Zvcm1lcnMvaXNzdWVzLzExMzNcbiAgICAgICAgbGV0IHN1Yl90ZXh0cyA9IFtdO1xuICAgICAgICBsZXQgY3VycmVudF9zdWJfdGV4dCA9IFtdO1xuICAgICAgICBmb3IgKGxldCB0b2tlbiBvZiB0b2tlbnMpIHtcbiAgICAgICAgICAgIC8vIHRva2VucyBzZW50IGhlcmUgYXJlIGFscmVhZHkgZmlsdGVyZWQsIHNvIHdlIGRvbid0IG5lZWQgdG8gZG8gdGhpc1xuICAgICAgICAgICAgLy8gaWYgKHNraXBfc3BlY2lhbF90b2tlbnMgJiYgdGhpcy5hbGxfc3BlY2lhbF9pZHMuaW5jbHVkZXModG9rZW4pKSB7XG4gICAgICAgICAgICAvLyAgICAgY29udGludWU7XG4gICAgICAgICAgICAvLyB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmFkZGVkX3Rva2Vucy5pbmNsdWRlcyh0b2tlbikpIHtcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudF9zdWJfdGV4dC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1Yl90ZXh0cy5wdXNoKHRoaXMuY29udmVydF90b2tlbnNfdG9fc3RyaW5nKGN1cnJlbnRfc3ViX3RleHQpKTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudF9zdWJfdGV4dCA9IFtdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdWJfdGV4dHMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRfc3ViX3RleHQucHVzaCh0b2tlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN1cnJlbnRfc3ViX3RleHQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgc3ViX3RleHRzLnB1c2godGhpcy5jb252ZXJ0X3Rva2Vuc190b19zdHJpbmcoY3VycmVudF9zdWJfdGV4dCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVE9ETyBhZGQgc3BhY2VzX2JldHdlZW5fc3BlY2lhbF90b2tlbnMgYW5kIGNsZWFuX3VwX3Rva2VuaXphdGlvbl9zcGFjZXMgb3B0aW9uc1xuXG4gICAgICAgIHJldHVybiBzdWJfdGV4dHM7XG4gICAgfVxufVxuXG5cbi8qKlxuICogQXBwbHkgYSBzZXF1ZW5jZSBvZiBkZWNvZGVycy5cbiAqIEBleHRlbmRzIERlY29kZXJcbiAqL1xuY2xhc3MgRGVjb2RlclNlcXVlbmNlIGV4dGVuZHMgRGVjb2RlciB7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIERlY29kZXJTZXF1ZW5jZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIFRoZSBjb25maWd1cmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge0RlY29kZXJbXX0gY29uZmlnLmRlY29kZXJzIFRoZSBsaXN0IG9mIGRlY29kZXJzIHRvIGFwcGx5LlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgICAgICBzdXBlcihjb25maWcpO1xuICAgICAgICB0aGlzLmRlY29kZXJzID0gY29uZmlnLmRlY29kZXJzLm1hcCh4ID0+IERlY29kZXIuZnJvbUNvbmZpZyh4KSk7XG4gICAgfVxuXG4gICAgLyoqIEB0eXBlIHtEZWNvZGVyWydkZWNvZGVfY2hhaW4nXX0gKi9cbiAgICBkZWNvZGVfY2hhaW4odG9rZW5zKSB7XG4gICAgICAgIC8vIFVzZSByZWR1Y2UgdG8gYXBwbHkgZWFjaCBkZWNvZGVyIHRvIHRoZSB0b2tlbnNcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVjb2RlcnMucmVkdWNlKCh0b2tzLCBkZWNvZGVyKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gZGVjb2Rlci5kZWNvZGVfY2hhaW4odG9rcyk7XG4gICAgICAgIH0sIHRva2Vucyk7XG4gICAgfVxuXG59XG5cbi8qKlxuICogVGhpcyBQcmVUb2tlbml6ZXIgcmVwbGFjZXMgc3BhY2VzIHdpdGggdGhlIGdpdmVuIHJlcGxhY2VtZW50IGNoYXJhY3RlciwgYWRkcyBhIHByZWZpeCBzcGFjZSBpZiByZXF1ZXN0ZWQsXG4gKiBhbmQgcmV0dXJucyBhIGxpc3Qgb2YgdG9rZW5zLlxuICogQGV4dGVuZHMgUHJlVG9rZW5pemVyXG4gKi9cbmNsYXNzIE1ldGFzcGFjZVByZVRva2VuaXplciBleHRlbmRzIFByZVRva2VuaXplciB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBUaGUgY29uZmlndXJhdGlvbiBvYmplY3QgZm9yIHRoZSBNZXRhc3BhY2VQcmVUb2tlbml6ZXIuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBjb25maWcuYWRkX3ByZWZpeF9zcGFjZSBXaGV0aGVyIHRvIGFkZCBhIHByZWZpeCBzcGFjZSB0byB0aGUgZmlyc3QgdG9rZW4uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbmZpZy5yZXBsYWNlbWVudCBUaGUgY2hhcmFjdGVyIHRvIHJlcGxhY2Ugc3BhY2VzIHdpdGguXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtjb25maWcuc3RyX3JlcD1jb25maWcucmVwbGFjZW1lbnRdIEFuIG9wdGlvbmFsIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgcmVwbGFjZW1lbnQgY2hhcmFjdGVyLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgICAgICBzdXBlcigpO1xuXG4gICAgICAgIHRoaXMuYWRkUHJlZml4U3BhY2UgPSBjb25maWcuYWRkX3ByZWZpeF9zcGFjZTtcbiAgICAgICAgdGhpcy5yZXBsYWNlbWVudCA9IGNvbmZpZy5yZXBsYWNlbWVudDtcbiAgICAgICAgdGhpcy5zdHJSZXAgPSBjb25maWcuc3RyX3JlcCB8fCB0aGlzLnJlcGxhY2VtZW50O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIHRha2VzIGEgbGlzdCBvZiBub3JtYWxpemVkIHRva2VucywgcmVwbGFjZXMgc3BhY2VzIHdpdGggdGhlIHJlcGxhY2VtZW50IGNoYXJhY3RlcixcbiAgICAgKiBhZGRzIGEgcHJlZml4IHNwYWNlIGlmIHJlcXVlc3RlZCwgYW5kIHJldHVybnMgYSBuZXcgbGlzdCBvZiB0b2tlbnMuXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXXxzdHJpbmd9IG5vcm1hbGl6ZWRUb2tlbnMgVGhlIGxpc3Qgb2Ygbm9ybWFsaXplZCB0b2tlbnMgdG8gcHJlLXRva2VuaXplLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmdbXX0gQSBuZXcgbGlzdCBvZiBwcmUtdG9rZW5pemVkIHRva2Vucy5cbiAgICAgKi9cbiAgICBwcmVfdG9rZW5pemUobm9ybWFsaXplZFRva2Vucykge1xuICAgICAgICBpZiAodHlwZW9mIG5vcm1hbGl6ZWRUb2tlbnMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAvLyBNZXRhc3BhY2UgYWN0cyBvbiBhIGxpc3Qgb2YgdG9rZW5zLiBJZiBwYXNzaW5nIGluIGEgc3RyaW5nLCBmaXJzdCBzcGxpdCBvbiB3aGl0ZXNwYWNlXG4gICAgICAgICAgICAvLyBOT1RFOiBGb3Igc29tZSByZWFzb24sIG1ldGFzcGFjZSBpbmNsdWRlcyB0cmFpbGluZyB3aGl0ZXNwYWNlLCBzbyB3ZSBvbmx5IHRyaW0gbGVhZGluZyB3aGl0ZXNwYWNlLlxuICAgICAgICAgICAgLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vaHVnZ2luZ2ZhY2UvdG9rZW5pemVycy9pc3N1ZXMvMTI1MFxuICAgICAgICAgICAgbm9ybWFsaXplZFRva2VucyA9IG5vcm1hbGl6ZWRUb2tlbnMudHJpbVN0YXJ0KCkuc3BsaXQoL1xccysvKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKGxldCB0b2tlbiBvZiBub3JtYWxpemVkVG9rZW5zKSB7XG4gICAgICAgICAgICBsZXQgbm9ybWFsaXplZCA9IHRva2VuLnJlcGxhY2VBbGwoJyAnLCB0aGlzLnN0clJlcCk7XG4gICAgICAgICAgICBpZiAodGhpcy5hZGRQcmVmaXhTcGFjZSAmJiAhbm9ybWFsaXplZC5zdGFydHNXaXRoKHRoaXMucmVwbGFjZW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgbm9ybWFsaXplZCA9IHRoaXMuc3RyUmVwICsgbm9ybWFsaXplZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5vcm1hbGl6ZWQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuXG4vKipcbiAqIE1ldGFzcGFjZURlY29kZXIgY2xhc3MgZXh0ZW5kcyB0aGUgRGVjb2RlciBjbGFzcyBhbmQgZGVjb2RlcyBNZXRhc3BhY2UgdG9rZW5pemF0aW9uLlxuICogQGV4dGVuZHMgRGVjb2RlclxuICovXG5jbGFzcyBNZXRhc3BhY2VEZWNvZGVyIGV4dGVuZHMgRGVjb2RlciB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0cyBhIG5ldyBNZXRhc3BhY2VEZWNvZGVyIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIFRoZSBjb25maWd1cmF0aW9uIG9iamVjdCBmb3IgdGhlIE1ldGFzcGFjZURlY29kZXIuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBjb25maWcuYWRkX3ByZWZpeF9zcGFjZSBXaGV0aGVyIHRvIGFkZCBhIHByZWZpeCBzcGFjZSB0byB0aGUgZGVjb2RlZCBzdHJpbmcuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbmZpZy5yZXBsYWNlbWVudCBUaGUgc3RyaW5nIHRvIHJlcGxhY2Ugc3BhY2VzIHdpdGguXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZyk7XG5cbiAgICAgICAgdGhpcy5hZGRQcmVmaXhTcGFjZSA9IGNvbmZpZy5hZGRfcHJlZml4X3NwYWNlO1xuICAgICAgICB0aGlzLnJlcGxhY2VtZW50ID0gY29uZmlnLnJlcGxhY2VtZW50O1xuICAgIH1cblxuICAgIC8qKiBAdHlwZSB7RGVjb2RlclsnZGVjb2RlX2NoYWluJ119ICovXG4gICAgZGVjb2RlX2NoYWluKHRva2Vucykge1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBsZXQgbm9ybWFsaXplZCA9IHRva2Vuc1tpXS5yZXBsYWNlQWxsKHRoaXMucmVwbGFjZW1lbnQsICcgJyk7XG4gICAgICAgICAgICBpZiAodGhpcy5hZGRQcmVmaXhTcGFjZSAmJiBpID09IDAgJiYgbm9ybWFsaXplZC5zdGFydHNXaXRoKCcgJykpIHtcbiAgICAgICAgICAgICAgICBub3JtYWxpemVkID0gbm9ybWFsaXplZC5zdWJzdHJpbmcoMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQucHVzaChub3JtYWxpemVkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cblxuLyoqXG4gKiBBIG5vcm1hbGl6ZXIgdGhhdCBhcHBsaWVzIGEgcHJlY29tcGlsZWQgY2hhcnNtYXAuXG4gKiBUaGlzIGlzIHVzZWZ1bCBmb3IgYXBwbHlpbmcgY29tcGxleCBub3JtYWxpemF0aW9ucyBpbiBDKysgYW5kIGV4cG9zaW5nIHRoZW0gdG8gSmF2YVNjcmlwdC5cbiAqIEBleHRlbmRzIE5vcm1hbGl6ZXJcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgVGhlIGNvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciB0aGUgUHJlY29tcGlsZWQgbm9ybWFsaXplci5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcucHJlY29tcGlsZWRfY2hhcnNtYXAgVGhlIHByZWNvbXBpbGVkIGNoYXJzbWFwIG9iamVjdC5cbiAqL1xuY2xhc3MgUHJlY29tcGlsZWQgZXh0ZW5kcyBOb3JtYWxpemVyIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgaW5zdGFuY2Ugb2YgUHJlY29tcGlsZWQgbm9ybWFsaXplci5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIFRoZSBjb25maWd1cmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge2FueX0gY29uZmlnLnByZWNvbXBpbGVkX2NoYXJzbWFwIFByZWNvbXBpbGVkIGNoYXJzIG1hcHBpbmcuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZyk7XG4gICAgICAgIHRoaXMuY2hhcnNtYXAgPSBjb25maWcucHJlY29tcGlsZWRfY2hhcnNtYXA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTm9ybWFsaXplcyB0aGUgZ2l2ZW4gdGV4dCBieSBhcHBseWluZyB0aGUgcHJlY29tcGlsZWQgY2hhcnNtYXAuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgVGhlIHRleHQgdG8gbm9ybWFsaXplLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBub3JtYWxpemVkIHRleHQuXG4gICAgICovXG4gICAgbm9ybWFsaXplKHRleHQpIHtcbiAgICAgICAgLy8gVE9ETyB1c2UgdGhpcy5jaGFyc21hcFxuICAgICAgICAvLyBGb3Igbm93LCB3ZSBqdXN0IGFwcGx5IE5GS0Mgbm9ybWFsaXphdGlvblxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vaHVnZ2luZ2ZhY2UvdG9rZW5pemVycy9ibG9iLzI5MWIyZTIzYWU4MWNmOTQ3Mzg4MzU4NTIyMTNjZTEyMDE1MmQxMjEvYmluZGluZ3MvcHl0aG9uL3B5X3NyYy90b2tlbml6ZXJzL2ltcGxlbWVudGF0aW9ucy9zZW50ZW5jZXBpZWNlX2JwZS5weSNMMzRcbiAgICAgICAgdGV4dCA9IHRleHQubm9ybWFsaXplKCdORktDJyk7XG4gICAgICAgIHJldHVybiB0ZXh0O1xuICAgIH1cbn1cblxuLyoqXG4gKiBBIHByZS10b2tlbml6ZXIgdGhhdCBhcHBsaWVzIGEgc2VxdWVuY2Ugb2YgcHJlLXRva2VuaXplcnMgdG8gdGhlIGlucHV0IHRleHQuXG4gKiBAZXh0ZW5kcyBQcmVUb2tlbml6ZXJcbiAqL1xuY2xhc3MgUHJlVG9rZW5pemVyU2VxdWVuY2UgZXh0ZW5kcyBQcmVUb2tlbml6ZXIge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgUHJlVG9rZW5pemVyU2VxdWVuY2UuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBUaGUgY29uZmlndXJhdGlvbiBvYmplY3QgZm9yIHRoZSBwcmUtdG9rZW5pemVyIHNlcXVlbmNlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0W119IGNvbmZpZy5wcmV0b2tlbml6ZXJzIEFuIGFycmF5IG9mIHByZS10b2tlbml6ZXIgY29uZmlndXJhdGlvbnMuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMudG9rZW5pemVycyA9IGNvbmZpZy5wcmV0b2tlbml6ZXJzLm1hcCh4ID0+IFByZVRva2VuaXplci5mcm9tQ29uZmlnKHgpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIGVhY2ggcHJlLXRva2VuaXplciBpbiB0aGUgc2VxdWVuY2UgdG8gdGhlIGlucHV0IHRleHQgaW4gdHVybi5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXX0gdGV4dCBUaGUgdGV4dChzKSB0byBwcmUtdG9rZW5pemUuXG4gICAgICogQHJldHVybnMge3N0cmluZ1tdfSBUaGUgcHJlLXRva2VuaXplZCB0ZXh0LlxuICAgICAqL1xuICAgIHByZV90b2tlbml6ZV90ZXh0KHRleHQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0ZXh0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGV4dCA9IFt0ZXh0XTtcbiAgICAgICAgfVxuICAgICAgICAvLyBVc2UgcmVkdWNlIHRvIGFwcGx5IGVhY2ggdG9rZW5pemVyIHRvIHRoZSB0ZXh0XG4gICAgICAgIHJldHVybiB0aGlzLnRva2VuaXplcnMucmVkdWNlKChwcmVUb2tlbml6ZWRUZXh0LCB0b2tlbml6ZXIpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0b2tlbml6ZXIucHJlX3Rva2VuaXplKHByZVRva2VuaXplZFRleHQpO1xuICAgICAgICB9LCB0ZXh0KTtcbiAgICB9XG59XG5cbi8qKlxuICogU3BsaXRzIGEgc3RyaW5nIG9mIHRleHQgYnkgd2hpdGVzcGFjZSBjaGFyYWN0ZXJzIGludG8gaW5kaXZpZHVhbCB0b2tlbnMuXG4gKiBAZXh0ZW5kcyBQcmVUb2tlbml6ZXJcbiAqL1xuY2xhc3MgV2hpdGVzcGFjZVNwbGl0IGV4dGVuZHMgUHJlVG9rZW5pemVyIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIFdoaXRlc3BhY2VTcGxpdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIFRoZSBjb25maWd1cmF0aW9uIG9iamVjdCBmb3IgdGhlIHByZS10b2tlbml6ZXIgc2VxdWVuY2UuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByZS10b2tlbml6ZXMgdGhlIGlucHV0IHRleHQgYnkgc3BsaXR0aW5nIGl0IG9uIHdoaXRlc3BhY2UgY2hhcmFjdGVycy5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCBUaGUgdGV4dCB0byBiZSBwcmUtdG9rZW5pemVkLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmdbXX0gQW4gYXJyYXkgb2YgdG9rZW5zIHByb2R1Y2VkIGJ5IHNwbGl0dGluZyB0aGUgaW5wdXQgdGV4dCBvbiB3aGl0ZXNwYWNlLlxuICAgICAqL1xuICAgIHByZV90b2tlbml6ZV90ZXh0KHRleHQpIHtcbiAgICAgICAgcmV0dXJuIHdoaXRlc3BhY2Vfc3BsaXQodGV4dCk7XG4gICAgfVxufVxuXG5leHBvcnQgY2xhc3MgUHJlVHJhaW5lZFRva2VuaXplciBleHRlbmRzIENhbGxhYmxlIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgUHJlVHJhaW5lZFRva2VuaXplciBpbnN0YW5jZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdG9rZW5pemVySlNPTiBUaGUgSlNPTiBvZiB0aGUgdG9rZW5pemVyLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0b2tlbml6ZXJDb25maWcgVGhlIGNvbmZpZyBvZiB0aGUgdG9rZW5pemVyLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHRva2VuaXplckpTT04sIHRva2VuaXplckNvbmZpZykge1xuICAgICAgICBzdXBlcigpO1xuXG4gICAgICAgIC8vIENvbnN0cnVjdCBwYXJ0cyBvZiB0aGUgdG9rZW5pemVyIGZyb20gdGhlIEpTT05cbiAgICAgICAgdGhpcy5ub3JtYWxpemVyID0gTm9ybWFsaXplci5mcm9tQ29uZmlnKHRva2VuaXplckpTT04ubm9ybWFsaXplcik7XG4gICAgICAgIHRoaXMucHJlX3Rva2VuaXplciA9IFByZVRva2VuaXplci5mcm9tQ29uZmlnKHRva2VuaXplckpTT04ucHJlX3Rva2VuaXplcik7XG5cbiAgICAgICAgLy8gQ29udmVydCB0aGUgdm9jYWJ1bGFyeSB0byBhIG1hcCwgaWYgaXQgZXhpc3RzXG4gICAgICAgIGlmICh0b2tlbml6ZXJKU09OLm1vZGVsLnZvY2FiKSB7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodG9rZW5pemVySlNPTi5tb2RlbC52b2NhYikpIHtcbiAgICAgICAgICAgICAgICB0b2tlbml6ZXJKU09OLm1vZGVsLnZvY2FiID0gT2JqZWN0LmVudHJpZXModG9rZW5pemVySlNPTi5tb2RlbC52b2NhYik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0b2tlbml6ZXJKU09OLm1vZGVsLnZvY2FiID0gbmV3IE1hcCh0b2tlbml6ZXJKU09OLm1vZGVsLnZvY2FiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1vZGVsID0gVG9rZW5pemVyTW9kZWwuZnJvbUNvbmZpZyh0b2tlbml6ZXJKU09OLm1vZGVsLCB0b2tlbml6ZXJDb25maWcpO1xuICAgICAgICB0aGlzLnBvc3RfcHJvY2Vzc29yID0gUG9zdFByb2Nlc3Nvci5mcm9tQ29uZmlnKHRva2VuaXplckpTT04ucG9zdF9wcm9jZXNzb3IpO1xuXG4gICAgICAgIC8vIFRPRE86IG1heWJlLCBhbGxvdyB0aGlzIHRvIGJlIG51bGw7IGluIHdoaWNoIGNhc2UsIHdlIHVzZSBtb2RlbCBhcyBkZWNvZGVyIHRvbz9cbiAgICAgICAgdGhpcy5kZWNvZGVyID0gRGVjb2Rlci5mcm9tQ29uZmlnKHRva2VuaXplckpTT04uZGVjb2Rlcik7XG5cblxuICAgICAgICAvLyBBbm90aGVyIHNsaWdodCBoYWNrIHRvIGFkZCBgZW5kX29mX3dvcmRfc3VmZml4YCAoaWYgcHJlc2VudCkgdG8gdGhlIGRlY29kZXJcbiAgICAgICAgLy8gVGhpcyBpcyBuZWVkZWQgZm9yIGNhc2VzIHdoZXJlIEJQRSBtb2RlbCBhbmQgQnl0ZUxldmVsIGRlY29kZXIgYXJlIHVzZWRcbiAgICAgICAgLy8gRm9yIG1vcmUgaW5mb3JtYXRpb24sIHNlZSBodHRwczovL2dpdGh1Yi5jb20veGVub3ZhL3RyYW5zZm9ybWVycy5qcy9pc3N1ZXMvNzRcbiAgICAgICAgLy8gVE9ETzogc2F2ZSB0aGlzIHRvIHRoZSBkZWNvZGVyIHdoZW4gZXhwb3J0aW5nP1xuICAgICAgICB0aGlzLmRlY29kZXIuZW5kX29mX3dvcmRfc3VmZml4ID0gdGhpcy5tb2RlbC5lbmRfb2Zfd29yZF9zdWZmaXg7XG5cbiAgICAgICAgLy8gQWRkIGFkZGVkX3Rva2VucyB0byBtb2RlbFxuICAgICAgICB0aGlzLnNwZWNpYWxfdG9rZW5zID0gW107XG4gICAgICAgIHRoaXMuYWxsX3NwZWNpYWxfaWRzID0gW107XG4gICAgICAgIHRoaXMuYWRkZWRfdG9rZW5zID0gW107XG4gICAgICAgIGZvciAobGV0IGFkZGVkVG9rZW4gb2YgdG9rZW5pemVySlNPTi5hZGRlZF90b2tlbnMpIHtcbiAgICAgICAgICAgIGxldCBpZCA9IGFkZGVkVG9rZW4uaWQ7XG4gICAgICAgICAgICBsZXQgY29udGVudCA9IGFkZGVkVG9rZW4uY29udGVudDtcblxuICAgICAgICAgICAgdGhpcy5hZGRlZF90b2tlbnMucHVzaChjb250ZW50KTtcblxuICAgICAgICAgICAgdGhpcy5tb2RlbC50b2tlbnNfdG9faWRzLnNldChjb250ZW50LCBpZCk7XG4gICAgICAgICAgICB0aGlzLm1vZGVsLnZvY2FiW2lkXSA9IGNvbnRlbnQ7XG5cbiAgICAgICAgICAgIGlmIChhZGRlZFRva2VuLnNwZWNpYWwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNwZWNpYWxfdG9rZW5zLnB1c2goY29udGVudCk7XG4gICAgICAgICAgICAgICAgdGhpcy5hbGxfc3BlY2lhbF9pZHMucHVzaChpZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTbGlnaHQgaGFjaywgYnV0IGl0IHByZXZlbnRzIGNvZGUgZHVwbGljYXRpb246XG4gICAgICAgIHRoaXMuZGVjb2Rlci5hZGRlZF90b2tlbnMgPSB0aGlzLmFkZGVkX3Rva2VucztcblxuICAgICAgICB0aGlzLmFkZGVkX3Rva2Vuc19yZWdleCA9IG5ldyBSZWdFeHAoXG4gICAgICAgICAgICAnKCcgKyB0aGlzLmFkZGVkX3Rva2Vucy5tYXAoZXNjYXBlUmVnRXhwKS5qb2luKCd8JykgKyAnKSdcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBTZXQgbWFzayB0b2tlbiBpZiBwcmVzZW50IChvdGhlcndpc2Ugd2lsbCBiZSB1bmRlZmluZWQsIHdoaWNoIGlzIGZpbmUpXG4gICAgICAgIHRoaXMubWFza190b2tlbiA9IHRoaXMuZ2V0VG9rZW4odG9rZW5pemVyQ29uZmlnLCAnbWFza190b2tlbicpO1xuICAgICAgICB0aGlzLm1hc2tfdG9rZW5faWQgPSB0aGlzLm1vZGVsLnRva2Vuc190b19pZHMuZ2V0KHRoaXMubWFza190b2tlbik7XG5cbiAgICAgICAgdGhpcy5wYWRfdG9rZW4gPSB0aGlzLmdldFRva2VuKHRva2VuaXplckNvbmZpZywgJ3BhZF90b2tlbicsICdlb3NfdG9rZW4nKTtcbiAgICAgICAgdGhpcy5wYWRfdG9rZW5faWQgPSB0aGlzLm1vZGVsLnRva2Vuc190b19pZHMuZ2V0KHRoaXMucGFkX3Rva2VuKTtcblxuICAgICAgICB0aGlzLnNlcF90b2tlbiA9IHRoaXMuZ2V0VG9rZW4odG9rZW5pemVyQ29uZmlnLCAnc2VwX3Rva2VuJyk7XG4gICAgICAgIHRoaXMuc2VwX3Rva2VuX2lkID0gdGhpcy5tb2RlbC50b2tlbnNfdG9faWRzLmdldCh0aGlzLnNlcF90b2tlbik7XG5cbiAgICAgICAgdGhpcy5tb2RlbF9tYXhfbGVuZ3RoID0gdG9rZW5pemVyQ29uZmlnLm1vZGVsX21heF9sZW5ndGg7XG5cbiAgICAgICAgLyoqIEB0eXBlIHtib29sZWFufSBXaGV0aGVyIG9yIG5vdCB0byBzdHJpcCB0aGUgdGV4dCB3aGVuIHRva2VuaXppbmcgKHJlbW92aW5nIGV4Y2VzcyBzcGFjZXMgYmVmb3JlIGFuZCBhZnRlciB0aGUgc3RyaW5nKS4gKi9cbiAgICAgICAgdGhpcy5yZW1vdmVfc3BhY2UgPSB0b2tlbml6ZXJDb25maWcucmVtb3ZlX3NwYWNlO1xuXG4gICAgICAgIHRoaXMuY2xlYW5fdXBfdG9rZW5pemF0aW9uX3NwYWNlcyA9IHRva2VuaXplckNvbmZpZy5jbGVhbl91cF90b2tlbml6YXRpb25fc3BhY2VzID8/IHRydWU7XG5cbiAgICAgICAgLy8gVE9ETyBhbGxvdyB1c2VyIHRvIGNoYW5nZSB0aGlzXG4gICAgICAgIHRoaXMucGFkZGluZ19zaWRlID0gJ3JpZ2h0JztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB2YWx1ZSBvZiB0aGUgZmlyc3QgbWF0Y2hpbmcga2V5IGluIHRoZSB0b2tlbml6ZXIgY29uZmlnIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gey4uLnN0cmluZ30ga2V5cyBPbmUgb3IgbW9yZSBrZXlzIHRvIHNlYXJjaCBmb3IgaW4gdGhlIHRva2VuaXplciBjb25maWcgb2JqZWN0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd8bnVsbH0gVGhlIHZhbHVlIGFzc29jaWF0ZWQgd2l0aCB0aGUgZmlyc3QgbWF0Y2hpbmcga2V5LCBvciBudWxsIGlmIG5vIG1hdGNoIGlzIGZvdW5kLlxuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiBhbiBvYmplY3QgaXMgZm91bmQgZm9yIGEgbWF0Y2hpbmcga2V5IGFuZCBpdHMgX190eXBlIHByb3BlcnR5IGlzIG5vdCBcIkFkZGVkVG9rZW5cIi5cbiAgICAgKi9cbiAgICBnZXRUb2tlbih0b2tlbml6ZXJDb25maWcsIC4uLmtleXMpIHtcbiAgICAgICAgZm9yIChsZXQga2V5IG9mIGtleXMpIHtcbiAgICAgICAgICAgIGxldCBpdGVtID0gdG9rZW5pemVyQ29uZmlnW2tleV07XG5cbiAgICAgICAgICAgIGlmICghaXRlbSkgY29udGludWU7XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgaXRlbSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbS5fX3R5cGUgPT09ICdBZGRlZFRva2VuJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXRlbS5jb250ZW50O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKGBVbmtub3duIHRva2VuOiAke2l0ZW19YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMb2FkcyBhIHByZS10cmFpbmVkIHRva2VuaXplciBmcm9tIHRoZSBnaXZlbiBgcHJldHJhaW5lZF9tb2RlbF9uYW1lX29yX3BhdGhgLiBcbiAgICAgKiBcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJldHJhaW5lZF9tb2RlbF9uYW1lX29yX3BhdGggVGhlIHBhdGggdG8gdGhlIHByZS10cmFpbmVkIHRva2VuaXplci5cbiAgICAgKiBAcGFyYW0ge1ByZXRyYWluZWRPcHRpb25zfSBvcHRpb25zIEFkZGl0aW9uYWwgb3B0aW9ucyBmb3IgbG9hZGluZyB0aGUgdG9rZW5pemVyLlxuICAgICAqIFxuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBUaHJvd3MgYW4gZXJyb3IgaWYgdGhlIHRva2VuaXplci5qc29uIG9yIHRva2VuaXplcl9jb25maWcuanNvbiBmaWxlcyBhcmUgbm90IGZvdW5kIGluIHRoZSBgcHJldHJhaW5lZF9tb2RlbF9uYW1lX29yX3BhdGhgLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFByZVRyYWluZWRUb2tlbml6ZXI+fSBBIG5ldyBpbnN0YW5jZSBvZiB0aGUgYFByZVRyYWluZWRUb2tlbml6ZXJgIGNsYXNzLlxuICAgICAqL1xuICAgIHN0YXRpYyBhc3luYyBmcm9tX3ByZXRyYWluZWQocHJldHJhaW5lZF9tb2RlbF9uYW1lX29yX3BhdGgsIHtcbiAgICAgICAgcHJvZ3Jlc3NfY2FsbGJhY2sgPSBudWxsLFxuICAgICAgICBjb25maWcgPSBudWxsLFxuICAgICAgICBjYWNoZV9kaXIgPSBudWxsLFxuICAgICAgICBsb2NhbF9maWxlc19vbmx5ID0gZmFsc2UsXG4gICAgICAgIHJldmlzaW9uID0gJ21haW4nLFxuICAgIH0gPSB7fSkge1xuXG4gICAgICAgIGxldCBpbmZvID0gYXdhaXQgbG9hZFRva2VuaXplcihwcmV0cmFpbmVkX21vZGVsX25hbWVfb3JfcGF0aCwge1xuICAgICAgICAgICAgcHJvZ3Jlc3NfY2FsbGJhY2ssXG4gICAgICAgICAgICBjb25maWcsXG4gICAgICAgICAgICBjYWNoZV9kaXIsXG4gICAgICAgICAgICBsb2NhbF9maWxlc19vbmx5LFxuICAgICAgICAgICAgcmV2aXNpb24sXG4gICAgICAgIH0pXG5cbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICByZXR1cm4gbmV3IHRoaXMoLi4uaW5mbyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiBjYW4gYmUgb3ZlcnJpZGRlbiBieSBhIHN1YmNsYXNzIHRvIGFwcGx5IGFkZGl0aW9uYWwgcHJlcHJvY2Vzc2luZ1xuICAgICAqIHRvIGEgbW9kZWwncyBpbnB1dCBkYXRhLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dHMgQW4gb2JqZWN0IGNvbnRhaW5pbmcgaW5wdXQgZGF0YSBhcyBwcm9wZXJ0aWVzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBtb2RpZmllZCBpbnB1dHMgb2JqZWN0LlxuICAgICAqL1xuICAgIHByZXBhcmVfbW9kZWxfaW5wdXRzKGlucHV0cykge1xuICAgICAgICByZXR1cm4gaW5wdXRzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVuY29kZS90b2tlbml6ZSB0aGUgZ2l2ZW4gdGV4dChzKS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXX0gdGV4dCBUaGUgdGV4dCB0byB0b2tlbml6ZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBBbiBvcHRpb25hbCBvYmplY3QgY29udGFpbmluZyB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gICAgICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IFtvcHRpb25zLnRleHRfcGFpcj1udWxsXSBPcHRpb25hbCBzZWNvbmQgc2VxdWVuY2UgdG8gYmUgZW5jb2RlZC4gSWYgc2V0LCBtdXN0IGJlIHRoZSBzYW1lIHR5cGUgYXMgdGV4dC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnBhZGRpbmc9ZmFsc2VdIFdoZXRoZXIgdG8gcGFkIHRoZSBpbnB1dCBzZXF1ZW5jZXMuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy50cnVuY2F0aW9uPW51bGxdIFdoZXRoZXIgdG8gdHJ1bmNhdGUgdGhlIGlucHV0IHNlcXVlbmNlcy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMubWF4X2xlbmd0aD1udWxsXSBNYXhpbXVtIGxlbmd0aCBvZiB0aGUgcmV0dXJuZWQgbGlzdCBhbmQgb3B0aW9uYWxseSBwYWRkaW5nIGxlbmd0aC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnJldHVybl90ZW5zb3I9dHJ1ZV0gV2hldGhlciB0byByZXR1cm4gdGhlIHJlc3VsdHMgYXMgVGVuc29ycyBvciBhcnJheXMuXG4gICAgICogQHJldHVybnMge3sgaW5wdXRfaWRzOiBudW1iZXJbXXxudW1iZXJbXVtdfFRlbnNvciwgYXR0ZW50aW9uX21hc2s6IGFueVtdfFRlbnNvciB9fSBPYmplY3QgdG8gYmUgcGFzc2VkIHRvIHRoZSBtb2RlbC5cbiAgICAgKi9cbiAgICBfY2FsbChcbiAgICAgICAgLy8gUmVxdWlyZWQgcG9zaXRpb25hbCBhcmd1bWVudHNcbiAgICAgICAgdGV4dCxcblxuICAgICAgICAvLyBPcHRpb25hbCBrZXl3b3JkIGFyZ3VtZW50c1xuICAgICAgICB7XG4gICAgICAgICAgICB0ZXh0X3BhaXIgPSBudWxsLFxuICAgICAgICAgICAgLy8gYWRkX3NwZWNpYWxfdG9rZW5zID0gdHJ1ZSwgLy8gVE9ET1xuICAgICAgICAgICAgcGFkZGluZyA9IGZhbHNlLFxuICAgICAgICAgICAgdHJ1bmNhdGlvbiA9IG51bGwsXG4gICAgICAgICAgICBtYXhfbGVuZ3RoID0gbnVsbCxcbiAgICAgICAgICAgIHJldHVybl90ZW5zb3IgPSB0cnVlLCAvLyBEaWZmZXJlbnQgdG8gSEZcbiAgICAgICAgfSA9IHt9LFxuICAgICkge1xuXG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyW118bnVtYmVyW11bXXxUZW5zb3J9ICovXG4gICAgICAgIGxldCB0b2tlbnM7XG5cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodGV4dCkpIHtcbiAgICAgICAgICAgIGlmICh0ZXh0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKCd0ZXh0IGFycmF5IG11c3QgYmUgbm9uLWVtcHR5JylcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRleHRfcGFpciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh0ZXh0X3BhaXIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKCd0ZXh0X3BhaXIgbXVzdCBhbHNvIGJlIGFuIGFycmF5JylcblxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGV4dC5sZW5ndGggIT09IHRleHRfcGFpci5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ3RleHQgYW5kIHRleHRfcGFpciBtdXN0IGhhdmUgdGhlIHNhbWUgbGVuZ3RoJylcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0b2tlbnMgPSB0ZXh0Lm1hcChcbiAgICAgICAgICAgICAgICAgICAgKHQsIGkpID0+IHRoaXMuZW5jb2RlKHQsIHRleHRfcGFpcltpXSlcbiAgICAgICAgICAgICAgICApXG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdG9rZW5zID0gdGV4dC5tYXAoeCA9PiB0aGlzLmVuY29kZSh4KSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0ZXh0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ3RleHQgbWF5IG5vdCBiZSBudWxsJylcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodGV4dF9wYWlyKSkge1xuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKCdXaGVuIHNwZWNpZnlpbmcgYHRleHRfcGFpcmAsIHNpbmNlIGB0ZXh0YCBpcyBhIHN0cmluZywgYHRleHRfcGFpcmAgbXVzdCBhbHNvIGJlIGEgc3RyaW5nIChpLmUuLCBub3QgYW4gYXJyYXkpLicpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEZvciBzaW5nbGUgaW5wdXQsIHdlIGp1c3Qgd3JhcCBpbiBhbiBhcnJheSwgYW5kIHRoZW4gdW53cmFwIGxhdGVyLlxuICAgICAgICAgICAgdG9rZW5zID0gW3RoaXMuZW5jb2RlKHRleHQsIHRleHRfcGFpcildO1xuICAgICAgICB9XG4gICAgICAgIC8vIEF0IHRoaXMgcG9pbnQsIHRva2VucyBpcyBiYXRjaGVkOiBbYmF0Y2hfc2l6ZSwgdG9rZW5zXVxuICAgICAgICAvLyBIb3dldmVyLCBhcnJheSBtYXkgYmUgamFnZ2VkLiBTbywgd2UgcGFkIHRvIG1heF9sZW5ndGhcblxuICAgICAgICBsZXQgbWF4TGVuZ3RoT2ZCYXRjaCA9IG1heCh0b2tlbnMubWFwKHggPT4geC5sZW5ndGgpKVswXTtcblxuICAgICAgICAvLyBJZiBudWxsLCB3ZSBjYWxjdWxhdGUgbWF4IGxlbmd0aCBmcm9tIHNlcXVlbmNlc1xuICAgICAgICBpZiAobWF4X2xlbmd0aCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgbWF4X2xlbmd0aCA9IG1heExlbmd0aE9mQmF0Y2g7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBFbnN1cmUgaXQgaXMgbGVzcyB0aGFuIG1vZGVsIG1heCBsZW5ndGhcbiAgICAgICAgbWF4X2xlbmd0aCA9IE1hdGgubWluKG1heF9sZW5ndGgsIHRoaXMubW9kZWxfbWF4X2xlbmd0aClcblxuICAgICAgICAvKiogQHR5cGUge2FueVtdfFRlbnNvcn0gKi9cbiAgICAgICAgbGV0IGF0dGVudGlvbl9tYXNrID0gW107XG4gICAgICAgIGlmIChwYWRkaW5nIHx8IHRydW5jYXRpb24pIHtcbiAgICAgICAgICAgIC8vIFBlcmZvcm0gcGFkZGluZyBhbmQvb3IgdHJ1bmNhdGlvblxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBpZiAodG9rZW5zW2ldLmxlbmd0aCA9PT0gbWF4X2xlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBhdHRlbnRpb25fbWFzay5wdXNoKG5ldyBBcnJheSh0b2tlbnNbaV0ubGVuZ3RoKS5maWxsKDEpKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcblxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodG9rZW5zW2ldLmxlbmd0aCA+IG1heF9sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gcG9zc2libHkgdHJ1bmNhdGVcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRydW5jYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRva2Vuc1tpXSA9IHRva2Vuc1tpXS5zbGljZSgwLCBtYXhfbGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBhdHRlbnRpb25fbWFzay5wdXNoKG5ldyBBcnJheSh0b2tlbnNbaV0ubGVuZ3RoKS5maWxsKDEpKVxuXG4gICAgICAgICAgICAgICAgfSBlbHNlIHsgLy8gdC5sZW5ndGggPCBtYXhfbGVuZ3RoXG4gICAgICAgICAgICAgICAgICAgIGlmIChwYWRkaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZGlmZiA9IG1heF9sZW5ndGggLSB0b2tlbnNbaV0ubGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5wYWRkaW5nX3NpZGUgPT09ICdyaWdodCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRlbnRpb25fbWFzay5wdXNoKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAobmV3IEFycmF5KHRva2Vuc1tpXS5sZW5ndGgpLmZpbGwoMSkpLmNvbmNhdChuZXcgQXJyYXkoZGlmZikuZmlsbCgwKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW5zW2ldLnB1c2goLi4ubmV3IEFycmF5KGRpZmYpLmZpbGwodGhpcy5wYWRfdG9rZW5faWQpKVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsgLy8gbGVmdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dGVudGlvbl9tYXNrLnB1c2goXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChuZXcgQXJyYXkoZGlmZikuZmlsbCgwKSkuY29uY2F0KG5ldyBBcnJheSh0b2tlbnNbaV0ubGVuZ3RoKS5maWxsKDEpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b2tlbnNbaV0udW5zaGlmdCguLi5uZXcgQXJyYXkoZGlmZikuZmlsbCh0aGlzLnBhZF90b2tlbl9pZCkpXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dGVudGlvbl9tYXNrLnB1c2gobmV3IEFycmF5KHRva2Vuc1tpXS5sZW5ndGgpLmZpbGwoMSkpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhdHRlbnRpb25fbWFzayA9IHRva2Vucy5tYXAoeCA9PiBuZXcgQXJyYXkoeC5sZW5ndGgpLmZpbGwoMSkpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmV0dXJuX3RlbnNvcikge1xuICAgICAgICAgICAgaWYgKCEocGFkZGluZyAmJiB0cnVuY2F0aW9uKSkge1xuICAgICAgICAgICAgICAgIC8vIE5vdCwgZ3VhcmFudGVlZCB0aGF0IGFsbCBpdGVtcyBoYXZlIHNhbWUgbGVuZ3RoLCBzb1xuICAgICAgICAgICAgICAgIC8vIHdlIHBlcmZvcm0gYWRkaXRpb25hbCBjaGVja1xuXG4gICAgICAgICAgICAgICAgaWYgKHRva2Vucy5zb21lKHggPT4geC5sZW5ndGggIT09IHRva2Vuc1swXS5sZW5ndGgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJVbmFibGUgdG8gY3JlYXRlIHRlbnNvciwgeW91IHNob3VsZCBwcm9iYWJseSBhY3RpdmF0ZSB0cnVuY2F0aW9uIGFuZC9vciBwYWRkaW5nIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwid2l0aCAncGFkZGluZz10cnVlJyBhbmQgJ3RydW5jYXRpb249dHJ1ZScgdG8gaGF2ZSBiYXRjaGVkIHRlbnNvcnMgd2l0aCB0aGUgc2FtZSBsZW5ndGguXCJcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gTm93IHdlIGFjdHVhbGx5IGNvbnZlcnQgdG8gdGVuc29yXG4gICAgICAgICAgICAvLyBOT1RFOiBJbiB0aGUgc2FtZSB3YXkgYXMgdGhlIHB5dGhvbiBsaWJyYXJ5LCB3ZSByZXR1cm4gYSBiYXRjaGVkIHRlbnNvciwgcmVnYXJkbGVzcyBvZlxuICAgICAgICAgICAgLy8gd2hldGhlciB3ZSBoYXZlIGEgc2luZ2xlIGlucHV0IG9yIG11bHRpcGxlIGlucHV0cy5cbiAgICAgICAgICAgIGxldCBkaW1zID0gW3Rva2Vucy5sZW5ndGgsIHRva2Vuc1swXS5sZW5ndGhdO1xuXG4gICAgICAgICAgICB0b2tlbnMgPSBuZXcgVGVuc29yKCdpbnQ2NCcsXG4gICAgICAgICAgICAgICAgQmlnSW50NjRBcnJheS5mcm9tKHRva2Vucy5mbGF0KCkubWFwKEJpZ0ludCkpLFxuICAgICAgICAgICAgICAgIGRpbXNcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGF0dGVudGlvbl9tYXNrID0gbmV3IFRlbnNvcihcbiAgICAgICAgICAgICAgICAnaW50NjQnLFxuICAgICAgICAgICAgICAgIEJpZ0ludDY0QXJyYXkuZnJvbShhdHRlbnRpb25fbWFzay5mbGF0KCkubWFwKEJpZ0ludCkpLFxuICAgICAgICAgICAgICAgIGRpbXNcbiAgICAgICAgICAgIClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIElmIG5vdCByZXR1cm5pbmcgYSB0ZW5zb3IsIHdlIG1hdGNoIHRoZSBpbnB1dCB0eXBlXG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodGV4dCkpIHtcbiAgICAgICAgICAgICAgICAvLyBJbnB1dCB3YXMgbm90IGJhdGNoZWQsIHNvIHdlIHVud3JhcFxuICAgICAgICAgICAgICAgIHRva2VucyA9IHRva2Vuc1swXTtcbiAgICAgICAgICAgICAgICBhdHRlbnRpb25fbWFzayA9IGF0dGVudGlvbl9tYXNrWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cblxuICAgICAgICAvLyBGaW5hbGx5LCBhZGQgYXR0ZW50aW9uIG1hc2ssIGFuZCBwb3NzaWJseSBtb2RlbC1zcGVjaWZpYyBwYXJhbWV0ZXJzXG4gICAgICAgIGxldCBtb2RlbElucHV0cyA9IHtcbiAgICAgICAgICAgIGlucHV0X2lkczogdG9rZW5zLFxuICAgICAgICAgICAgYXR0ZW50aW9uX21hc2s6IGF0dGVudGlvbl9tYXNrXG4gICAgICAgIH1cblxuICAgICAgICAvLyBPcHRpb25hbCBwb3N0LXByb2Nlc3NpbmdcbiAgICAgICAgbW9kZWxJbnB1dHMgPSB0aGlzLnByZXBhcmVfbW9kZWxfaW5wdXRzKG1vZGVsSW5wdXRzKTtcblxuICAgICAgICByZXR1cm4gbW9kZWxJbnB1dHNcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFbmNvZGVzIGEgc2luZ2xlIHRleHQgdXNpbmcgdGhlIHByZXByb2Nlc3NvciBwaXBlbGluZSBvZiB0aGUgdG9rZW5pemVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd8bnVsbH0gdGV4dCBUaGUgdGV4dCB0byBlbmNvZGUuXG4gICAgICogQHJldHVybnMge3N0cmluZ1tdfG51bGx9IFRoZSBlbmNvZGVkIHRva2Vucy5cbiAgICAgKi9cbiAgICBfZW5jb2RlX3RleHQodGV4dCkge1xuICAgICAgICBpZiAodGV4dCA9PT0gbnVsbCkgcmV0dXJuIG51bGw7XG5cbiAgICAgICAgLy8gQWN0dWFsIGZ1bmN0aW9uIHdoaWNoIGRvZXMgZW5jb2RpbmcsIGZvciBhIHNpbmdsZSB0ZXh0XG4gICAgICAgIC8vIEZpcnN0LCB3ZSB0YWtlIGNhcmUgb2Ygc3BlY2lhbCB0b2tlbnMuIE5lZWRlZCB0byBhdm9pZCBpc3N1ZXMgYXJpc2luZyBmcm9tXG4gICAgICAgIC8vIG5vcm1hbGl6YXRpb24gYW5kL29yIHByZXRva2VuaXphdGlvbiAod2hpY2ggbWF5IG5vdCBwcmVzZXJ2ZSBzcGVjaWFsIHRva2VucylcbiAgICAgICAgY29uc3Qgc2VjdGlvbnMgPSB0ZXh0LnNwbGl0KHRoaXMuYWRkZWRfdG9rZW5zX3JlZ2V4KS5maWx0ZXIoeCA9PiB4KTtcblxuICAgICAgICBsZXQgdG9rZW5zID0gc2VjdGlvbnMubWFwKHggPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuYWRkZWRfdG9rZW5zLmluY2x1ZGVzKHgpKSB7XG4gICAgICAgICAgICAgICAgLy8gSWdub3JlIGFkZGVkIHRva2Vuc1xuICAgICAgICAgICAgICAgIHJldHVybiB4XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnJlbW92ZV9zcGFjZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICB4ID0geC50cmltKCkuc3BsaXQoL1xccysvKS5qb2luKCcgJyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubm9ybWFsaXplciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB4ID0gdGhpcy5ub3JtYWxpemVyKHgpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGxldCBzZWN0aW9uVG9rZW5zID0gKHRoaXMucHJlX3Rva2VuaXplciAhPT0gbnVsbCkgPyB0aGlzLnByZV90b2tlbml6ZXIoeCkgOiBbeF07XG5cbiAgICAgICAgICAgICAgICBsZXQgdG9rZW5zID0gdGhpcy5tb2RlbChzZWN0aW9uVG9rZW5zKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLmZsYXQoKTtcblxuICAgICAgICByZXR1cm4gdG9rZW5zO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVuY29kZXMgYSBzaW5nbGUgdGV4dCBvciBhIHBhaXIgb2YgdGV4dHMgdXNpbmcgdGhlIG1vZGVsJ3MgdG9rZW5pemVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgVGhlIHRleHQgdG8gZW5jb2RlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfG51bGx9IHRleHRfcGFpciBUaGUgb3B0aW9uYWwgc2Vjb25kIHRleHQgdG8gZW5jb2RlLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJbXX0gQW4gYXJyYXkgb2YgdG9rZW4gSURzIHJlcHJlc2VudGluZyB0aGUgZW5jb2RlZCB0ZXh0KHMpLlxuICAgICAqL1xuICAgIGVuY29kZSh0ZXh0LCB0ZXh0X3BhaXIgPSBudWxsKSB7XG4gICAgICAgIC8vIEZ1bmN0aW9uIGNhbGxlZCBieSB1c2VycyB0byBlbmNvZGUgcG9zc2libHkgbXVsdGlwbGUgdGV4dHNcbiAgICAgICAgbGV0IHRva2VucyA9IHRoaXMuX2VuY29kZV90ZXh0KHRleHQpO1xuICAgICAgICBsZXQgdG9rZW5zMiA9IHRoaXMuX2VuY29kZV90ZXh0KHRleHRfcGFpcik7XG5cbiAgICAgICAgbGV0IGNvbWJpbmVkVG9rZW5zID0gKHRoaXMucG9zdF9wcm9jZXNzb3IgIT09IG51bGwpXG4gICAgICAgICAgICA/IHRoaXMucG9zdF9wcm9jZXNzb3IodG9rZW5zLCB0b2tlbnMyKVxuICAgICAgICAgICAgOiBtZXJnZUFycmF5cyh0b2tlbnMgPz8gW10sIHRva2VuczIgPz8gW10pO1xuXG4gICAgICAgIGxldCBpZHMgPSB0aGlzLm1vZGVsLmNvbnZlcnRfdG9rZW5zX3RvX2lkcyhjb21iaW5lZFRva2Vucyk7XG4gICAgICAgIHJldHVybiBpZHM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVjb2RlIGEgYmF0Y2ggb2YgdG9rZW5pemVkIHNlcXVlbmNlcy5cbiAgICAgKiBAcGFyYW0ge251bWJlcltdW119IGJhdGNoIExpc3Qgb2YgdG9rZW5pemVkIGlucHV0IHNlcXVlbmNlcy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGVjb2RlX2FyZ3MgKE9wdGlvbmFsKSBPYmplY3Qgd2l0aCBkZWNvZGluZyBhcmd1bWVudHMuXG4gICAgICogQHJldHVybnMge3N0cmluZ1tdfSBMaXN0IG9mIGRlY29kZWQgc2VxdWVuY2VzLlxuICAgICAqL1xuICAgIGJhdGNoX2RlY29kZShiYXRjaCwgZGVjb2RlX2FyZ3MgPSB7fSkge1xuICAgICAgICByZXR1cm4gYmF0Y2gubWFwKHggPT4gdGhpcy5kZWNvZGUoeCwgZGVjb2RlX2FyZ3MpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZWNvZGVzIGEgc2VxdWVuY2Ugb2YgdG9rZW4gSURzIGJhY2sgdG8gYSBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcltdfSB0b2tlbl9pZHMgTGlzdCBvZiB0b2tlbiBJRHMgdG8gZGVjb2RlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbZGVjb2RlX2FyZ3M9e31dXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbZGVjb2RlX2FyZ3Muc2tpcF9zcGVjaWFsX3Rva2Vucz1mYWxzZV0gSWYgdHJ1ZSwgc3BlY2lhbCB0b2tlbnMgYXJlIHJlbW92ZWQgZnJvbSB0aGUgb3V0cHV0IHN0cmluZy5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtkZWNvZGVfYXJncy5jbGVhbl91cF90b2tlbml6YXRpb25fc3BhY2VzPXRydWVdIElmIHRydWUsIHNwYWNlcyBiZWZvcmUgcHVuY3R1YXRpb25zIGFuZCBhYmJyZXZpYXRlZCBmb3JtcyBhcmUgcmVtb3ZlZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBkZWNvZGVkIHN0cmluZy5cbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgYHRva2VuX2lkc2AgaXMgbm90IGEgbm9uLWVtcHR5IGFycmF5IG9mIGludGVnZXJzLlxuICAgICAqL1xuICAgIGRlY29kZShcbiAgICAgICAgdG9rZW5faWRzLFxuICAgICAgICBkZWNvZGVfYXJncyA9IHt9LFxuICAgICkge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodG9rZW5faWRzKSB8fCB0b2tlbl9pZHMubGVuZ3RoID09PSAwIHx8ICFpc0ludGVncmFsTnVtYmVyKHRva2VuX2lkc1swXSkpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKFwidG9rZW5faWRzIG11c3QgYmUgYSBub24tZW1wdHkgYXJyYXkgb2YgaW50ZWdlcnMuXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZGVjb2RlX3NpbmdsZSh0b2tlbl9pZHMsIGRlY29kZV9hcmdzKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlY29kZSBhIHNpbmdsZSBsaXN0IG9mIHRva2VuIGlkcyB0byBhIHN0cmluZy5cbiAgICAgKiBAcGFyYW0ge251bWJlcltdfSB0b2tlbl9pZHMgTGlzdCBvZiB0b2tlbiBpZHMgdG8gZGVjb2RlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRlY29kZV9hcmdzIE9wdGlvbmFsIGFyZ3VtZW50cyBmb3IgZGVjb2RpbmdcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtkZWNvZGVfYXJncy5za2lwX3NwZWNpYWxfdG9rZW5zPWZhbHNlXSBXaGV0aGVyIHRvIHNraXAgc3BlY2lhbCB0b2tlbnMgZHVyaW5nIGRlY29kaW5nXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbZGVjb2RlX2FyZ3MuY2xlYW5fdXBfdG9rZW5pemF0aW9uX3NwYWNlcz1udWxsXSBXaGV0aGVyIHRvIGNsZWFuIHVwIHRva2VuaXphdGlvbiBzcGFjZXMgZHVyaW5nIGRlY29kaW5nLlxuICAgICAqIElmIG51bGwsIHRoZSB2YWx1ZSBpcyBzZXQgdG8gYHRoaXMuZGVjb2Rlci5jbGVhbnVwYCBpZiBpdCBleGlzdHMsIGZhbGxpbmcgYmFjayB0byBgdGhpcy5jbGVhbl91cF90b2tlbml6YXRpb25fc3BhY2VzYCBpZiBpdCBleGlzdHMsIGZhbGxpbmcgYmFjayB0byBgdHJ1ZWAuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gVGhlIGRlY29kZWQgc3RyaW5nXG4gICAgICovXG4gICAgZGVjb2RlX3NpbmdsZShcbiAgICAgICAgdG9rZW5faWRzLFxuICAgICAgICB7XG4gICAgICAgICAgICBza2lwX3NwZWNpYWxfdG9rZW5zID0gZmFsc2UsXG4gICAgICAgICAgICBjbGVhbl91cF90b2tlbml6YXRpb25fc3BhY2VzID0gbnVsbCxcbiAgICAgICAgfVxuICAgICkge1xuICAgICAgICBsZXQgdG9rZW5zID0gdGhpcy5tb2RlbC5jb252ZXJ0X2lkc190b190b2tlbnModG9rZW5faWRzKTtcbiAgICAgICAgaWYgKHNraXBfc3BlY2lhbF90b2tlbnMpIHtcbiAgICAgICAgICAgIHRva2VucyA9IHRva2Vucy5maWx0ZXIoeCA9PiAhdGhpcy5zcGVjaWFsX3Rva2Vucy5pbmNsdWRlcyh4KSk7XG4gICAgICAgIH1cblxuICAgICAgICAvKiogQHR5cGUge3N0cmluZ30gKi9cbiAgICAgICAgbGV0IGRlY29kZWQgPSB0aGlzLmRlY29kZXIodG9rZW5zKTtcblxuXG4gICAgICAgIC8vIFNsaWdodCBoYWNrLCBidXQgcHJldmVudHMgaGF2aW5nIHRvIHBhc3MgYHNraXBfc3BlY2lhbF90b2tlbnNgIHRvXG4gICAgICAgIC8vIGVhY2ggY2FsbCB0byBgZGVjb2RlYCwgd2hpY2ggd291bGQgbGVhZCB0byBjb2RlIGR1cGxpY2F0aW9uLlxuICAgICAgICBpZiAodGhpcy5kZWNvZGVyLmVuZF9vZl93b3JkX3N1ZmZpeCkge1xuICAgICAgICAgICAgZGVjb2RlZCA9IGRlY29kZWQucmVwbGFjZUFsbCh0aGlzLmRlY29kZXIuZW5kX29mX3dvcmRfc3VmZml4LCAnICcpO1xuICAgICAgICAgICAgaWYgKHNraXBfc3BlY2lhbF90b2tlbnMpIHtcbiAgICAgICAgICAgICAgICBkZWNvZGVkID0gZGVjb2RlZC50cmltKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY2xlYW5fdXBfdG9rZW5pemF0aW9uX3NwYWNlcyA/PyB0aGlzLmNsZWFuX3VwX3Rva2VuaXphdGlvbl9zcGFjZXMpIHtcbiAgICAgICAgICAgIGRlY29kZWQgPSBjbGVhbl91cF90b2tlbml6YXRpb24oZGVjb2RlZCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGVjb2RlZDtcbiAgICB9XG5cbn1cblxuLyoqXG4qIEhlbHBlciBtZXRob2QgZm9yIGFkZGluZyBgdG9rZW5fdHlwZV9pZHNgIHRvIG1vZGVsIGlucHV0c1xuKiBAcGFyYW0ge09iamVjdH0gaW5wdXRzIEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBpbnB1dCBpZHMgYW5kIGF0dGVudGlvbiBtYXNrLlxuKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgcHJlcGFyZWQgaW5wdXRzIG9iamVjdC5cbiovXG5mdW5jdGlvbiBhZGRfdG9rZW5fdHlwZXMoaW5wdXRzKSB7XG4gICAgLy8gVE9ETyBlbnN1cmUgY29ycmVjdG5lc3Mgd2hlbiB0b2tlbiBwYWlyIGlzIHByZXNlbnRcbiAgICBpZiAoaW5wdXRzLmlucHV0X2lkcyBpbnN0YW5jZW9mIFRlbnNvcikge1xuICAgICAgICBpbnB1dHMudG9rZW5fdHlwZV9pZHMgPSBuZXcgVGVuc29yKFxuICAgICAgICAgICAgJ2ludDY0JyxcbiAgICAgICAgICAgIG5ldyBCaWdJbnQ2NEFycmF5KGlucHV0cy5pbnB1dF9pZHMuZGF0YS5sZW5ndGgpLFxuICAgICAgICAgICAgaW5wdXRzLmlucHV0X2lkcy5kaW1zXG4gICAgICAgIClcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoaW5wdXRzLmlucHV0X2lkcykpIHtcblxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShpbnB1dHMuaW5wdXRfaWRzWzBdKSkge1xuICAgICAgICAgICAgLy8gVGhpcyBtZWFucyBpbnB1dCBpcyBiYXRjaGVkLCBzbyB3ZSBuZWVkIHRvIGJhdGNoIHRoZSB0b2tlbl90eXBlX2lkcyBhcyB3ZWxsXG4gICAgICAgICAgICBpbnB1dHMudG9rZW5fdHlwZV9pZHMgPSBpbnB1dHMuaW5wdXRfaWRzLm1hcChcbiAgICAgICAgICAgICAgICB4ID0+IG5ldyBBcnJheSh4Lmxlbmd0aCkuZmlsbCgwKVxuICAgICAgICAgICAgKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaW5wdXRzLnRva2VuX3R5cGVfaWRzID0gbmV3IEFycmF5KGlucHV0cy5pbnB1dF9pZHMubGVuZ3RoKS5maWxsKDApO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBpZHMgbXVzdCBiZSBhIFRlbnNvciBvciBhbiBBcnJheScpXG4gICAgfVxuXG4gICAgcmV0dXJuIGlucHV0cztcbn1cblxuLyoqXG4gKiBCZXJ0VG9rZW5pemVyIGlzIGEgY2xhc3MgdXNlZCB0byB0b2tlbml6ZSB0ZXh0IGZvciBCRVJUIG1vZGVscy5cbiAqIEBleHRlbmRzIFByZVRyYWluZWRUb2tlbml6ZXJcbiAqL1xuZXhwb3J0IGNsYXNzIEJlcnRUb2tlbml6ZXIgZXh0ZW5kcyBQcmVUcmFpbmVkVG9rZW5pemVyIHtcbiAgICAvKiogQHR5cGUge2FkZF90b2tlbl90eXBlc30gKi9cbiAgICBwcmVwYXJlX21vZGVsX2lucHV0cyhpbnB1dHMpIHtcbiAgICAgICAgcmV0dXJuIGFkZF90b2tlbl90eXBlcyhpbnB1dHMpO1xuICAgIH1cbn1cbi8qKlxuICogQWxiZXJ0IHRva2VuaXplclxuICogQGV4dGVuZHMgUHJlVHJhaW5lZFRva2VuaXplclxuICovXG5leHBvcnQgY2xhc3MgQWxiZXJ0VG9rZW5pemVyIGV4dGVuZHMgUHJlVHJhaW5lZFRva2VuaXplciB7XG4gICAgLyoqIEB0eXBlIHthZGRfdG9rZW5fdHlwZXN9ICovXG4gICAgcHJlcGFyZV9tb2RlbF9pbnB1dHMoaW5wdXRzKSB7XG4gICAgICAgIHJldHVybiBhZGRfdG9rZW5fdHlwZXMoaW5wdXRzKTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgTW9iaWxlQmVydFRva2VuaXplciBleHRlbmRzIFByZVRyYWluZWRUb2tlbml6ZXIge1xuICAgIC8qKiBAdHlwZSB7YWRkX3Rva2VuX3R5cGVzfSAqL1xuICAgIHByZXBhcmVfbW9kZWxfaW5wdXRzKGlucHV0cykge1xuICAgICAgICByZXR1cm4gYWRkX3Rva2VuX3R5cGVzKGlucHV0cyk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIFNxdWVlemVCZXJ0VG9rZW5pemVyIGV4dGVuZHMgUHJlVHJhaW5lZFRva2VuaXplciB7XG4gICAgLyoqIEB0eXBlIHthZGRfdG9rZW5fdHlwZXN9ICovXG4gICAgcHJlcGFyZV9tb2RlbF9pbnB1dHMoaW5wdXRzKSB7XG4gICAgICAgIHJldHVybiBhZGRfdG9rZW5fdHlwZXMoaW5wdXRzKTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgRGlzdGlsQmVydFRva2VuaXplciBleHRlbmRzIFByZVRyYWluZWRUb2tlbml6ZXIgeyB9XG5leHBvcnQgY2xhc3MgVDVUb2tlbml6ZXIgZXh0ZW5kcyBQcmVUcmFpbmVkVG9rZW5pemVyIHsgfVxuZXhwb3J0IGNsYXNzIEdQVDJUb2tlbml6ZXIgZXh0ZW5kcyBQcmVUcmFpbmVkVG9rZW5pemVyIHsgfVxuZXhwb3J0IGNsYXNzIEJhcnRUb2tlbml6ZXIgZXh0ZW5kcyBQcmVUcmFpbmVkVG9rZW5pemVyIHsgfVxuZXhwb3J0IGNsYXNzIFJvYmVydGFUb2tlbml6ZXIgZXh0ZW5kcyBQcmVUcmFpbmVkVG9rZW5pemVyIHsgfVxuXG5leHBvcnQgY2xhc3MgQmxvb21Ub2tlbml6ZXIgZXh0ZW5kcyBQcmVUcmFpbmVkVG9rZW5pemVyIHsgfVxuZXhwb3J0IGNsYXNzIExsYW1hVG9rZW5pemVyIGV4dGVuZHMgUHJlVHJhaW5lZFRva2VuaXplciB7IH1cblxuZXhwb3J0IGNsYXNzIFhMTVJvYmVydGFUb2tlbml6ZXIgZXh0ZW5kcyBQcmVUcmFpbmVkVG9rZW5pemVyIHsgfVxuZXhwb3J0IGNsYXNzIE1QTmV0VG9rZW5pemVyIGV4dGVuZHMgUHJlVHJhaW5lZFRva2VuaXplciB7IH1cblxuZXhwb3J0IGNsYXNzIEZhbGNvblRva2VuaXplciBleHRlbmRzIFByZVRyYWluZWRUb2tlbml6ZXIge1xuICAgIC8qKiBAdHlwZSB7YWRkX3Rva2VuX3R5cGVzfSAqL1xuICAgIHByZXBhcmVfbW9kZWxfaW5wdXRzKGlucHV0cykge1xuICAgICAgICByZXR1cm4gYWRkX3Rva2VuX3R5cGVzKGlucHV0cyk7XG4gICAgfVxufVxuXG5leHBvcnQgY2xhc3MgR1BUTmVvWFRva2VuaXplciBleHRlbmRzIFByZVRyYWluZWRUb2tlbml6ZXIgeyB9XG5cbi8qKlxuICogVGhlIE5sbGJUb2tlbml6ZXIgY2xhc3MgaXMgdXNlZCB0byB0b2tlbml6ZSB0ZXh0IGZvciBOTExCIChcIk5vIExhbmd1YWdlIExlZnQgQmVoaW5kXCIpIG1vZGVscy5cbiAqIFxuICogTm8gTGFuZ3VhZ2UgTGVmdCBCZWhpbmQgKE5MTEIpIGlzIGEgZmlyc3Qtb2YtaXRzLWtpbmQsIEFJIGJyZWFrdGhyb3VnaCBwcm9qZWN0XG4gKiB0aGF0IG9wZW4tc291cmNlcyBtb2RlbHMgY2FwYWJsZSBvZiBkZWxpdmVyaW5nIGhpZ2gtcXVhbGl0eSB0cmFuc2xhdGlvbnMgZGlyZWN0bHlcbiAqIGJldHdlZW4gYW55IHBhaXIgb2YgMjAwKyBsYW5ndWFnZXMg4oCUIGluY2x1ZGluZyBsb3ctcmVzb3VyY2UgbGFuZ3VhZ2VzIGxpa2UgQXN0dXJpYW4sXG4gKiBMdWdhbmRhLCBVcmR1IGFuZCBtb3JlLiBJdCBhaW1zIHRvIGhlbHAgcGVvcGxlIGNvbW11bmljYXRlIHdpdGggYW55b25lLCBhbnl3aGVyZSxcbiAqIHJlZ2FyZGxlc3Mgb2YgdGhlaXIgbGFuZ3VhZ2UgcHJlZmVyZW5jZXMuIEZvciBtb3JlIGluZm9ybWF0aW9uLCBjaGVjayBvdXQgdGhlaXJcbiAqIFtwYXBlcl0oaHR0cHM6Ly9hcnhpdi5vcmcvYWJzLzIyMDcuMDQ2NzIpLlxuICogXG4gKiBGb3IgYSBsaXN0IG9mIHN1cHBvcnRlZCBsYW5ndWFnZXMgKGFsb25nIHdpdGggdGhlaXIgbGFuZ3VhZ2UgY29kZXMpLFxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rcmVzZWFyY2gvZmxvcmVzL2Jsb2IvbWFpbi9mbG9yZXMyMDAvUkVBRE1FLm1kI2xhbmd1YWdlcy1pbi1mbG9yZXMtMjAwfVxuICovXG5leHBvcnQgY2xhc3MgTmxsYlRva2VuaXplciBleHRlbmRzIFByZVRyYWluZWRUb2tlbml6ZXIge1xuXG4gICAgY29uc3RydWN0b3IodG9rZW5pemVySlNPTiwgdG9rZW5pemVyQ29uZmlnKSB7XG4gICAgICAgIHN1cGVyKHRva2VuaXplckpTT04sIHRva2VuaXplckNvbmZpZyk7XG5cbiAgICAgICAgdGhpcy5sYW5ndWFnZVJlZ2V4ID0gL15bYS16XXszfV9bQS1aXVthLXpdezN9JC87XG4gICAgICAgIHRoaXMubGFuZ3VhZ2VfY29kZXMgPSB0aGlzLnNwZWNpYWxfdG9rZW5zLmZpbHRlcih4ID0+IHRoaXMubGFuZ3VhZ2VSZWdleC50ZXN0KHgpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIZWxwZXIgZnVuY3Rpb24gdG8gYnVpbGQgdHJhbnNsYXRpb24gaW5wdXRzIGZvciBhbiBgTmxsYlRva2VuaXplcmAuXG4gICAgICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IHJhd19pbnB1dHMgVGhlIHRleHQgdG8gdG9rZW5pemUuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHRva2VuaXplcl9vcHRpb25zIE9wdGlvbnMgdG8gYmUgc2VudCB0byB0aGUgdG9rZW5pemVyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGdlbmVyYXRlX2t3YXJncyBHZW5lcmF0aW9uIG9wdGlvbnMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gT2JqZWN0IHRvIGJlIHBhc3NlZCB0byB0aGUgbW9kZWwuXG4gICAgICovXG4gICAgX2J1aWxkX3RyYW5zbGF0aW9uX2lucHV0cyhyYXdfaW5wdXRzLCB0b2tlbml6ZXJfb3B0aW9ucywgZ2VuZXJhdGVfa3dhcmdzKSB7XG5cblxuICAgICAgICAvLyBDaGVjayB0aGF0IHRoZSB0YXJnZXQgbGFuZ3VhZ2UgaXMgdmFsaWQ6XG4gICAgICAgIGlmICghdGhpcy5sYW5ndWFnZV9jb2Rlcy5pbmNsdWRlcyhnZW5lcmF0ZV9rd2FyZ3MudGd0X2xhbmcpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRhcmdldCBsYW5ndWFnZSBjb2RlIFwiJHtnZW5lcmF0ZV9rd2FyZ3MudGd0X2xhbmd9XCIgaXMgbm90IHZhbGlkLiBNdXN0IGJlIG9uZSBvZjogeyR7dGhpcy5sYW5ndWFnZV9jb2Rlcy5qb2luKCcsICcpfX1gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFsbG93IGBzcmNfbGFuZ2AgdG8gYmUgb3B0aW9uYWwuIElmIG5vdCBzZXQsIHdlJ2xsIHVzZSB0aGUgdG9rZW5pemVyJ3MgZGVmYXVsdC5cbiAgICAgICAgaWYgKGdlbmVyYXRlX2t3YXJncy5zcmNfbGFuZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBDaGVjayB0aGF0IHRoZSBzb3VyY2UgbGFuZ3VhZ2UgaXMgdmFsaWQ6XG4gICAgICAgICAgICBpZiAoIXRoaXMubGFuZ3VhZ2VfY29kZXMuaW5jbHVkZXMoZ2VuZXJhdGVfa3dhcmdzLnNyY19sYW5nKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgU291cmNlIGxhbmd1YWdlIGNvZGUgXCIke2dlbmVyYXRlX2t3YXJncy5zcmNfbGFuZ31cIiBpcyBub3QgdmFsaWQuIE11c3QgYmUgb25lIG9mOiB7JHt0aGlzLmxhbmd1YWdlX2NvZGVzLmpvaW4oJywgJyl9fWApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBJbiB0aGUgc2FtZSB3YXkgYXMgdGhlIFB5dGhvbiBsaWJyYXJ5LCB3ZSBvdmVycmlkZSB0aGUgcG9zdC1wcm9jZXNzb3JcbiAgICAgICAgICAgIC8vIHRvIGZvcmNlIHRoZSBzb3VyY2UgbGFuZ3VhZ2UgdG8gYmUgZmlyc3Q6XG4gICAgICAgICAgICBmb3IgKGxldCBpdGVtIG9mIHRoaXMucG9zdF9wcm9jZXNzb3IuY29uZmlnLnNpbmdsZSkge1xuICAgICAgICAgICAgICAgIGlmICgnU3BlY2lhbFRva2VuJyBpbiBpdGVtICYmIHRoaXMubGFuZ3VhZ2VSZWdleC50ZXN0KGl0ZW0uU3BlY2lhbFRva2VuLmlkKSkge1xuICAgICAgICAgICAgICAgICAgICBpdGVtLlNwZWNpYWxUb2tlbi5pZCA9IGdlbmVyYXRlX2t3YXJncy5zcmNfbGFuZztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gT3ZlcnJpZGUgdGhlIGBmb3JjZWRfYm9zX3Rva2VuX2lkYCB0byBmb3JjZSB0aGUgY29ycmVjdCBsYW5ndWFnZVxuICAgICAgICBnZW5lcmF0ZV9rd2FyZ3MuZm9yY2VkX2Jvc190b2tlbl9pZCA9IHRoaXMubW9kZWwuY29udmVydF90b2tlbnNfdG9faWRzKFtnZW5lcmF0ZV9rd2FyZ3MudGd0X2xhbmddKVswXTtcblxuICAgICAgICByZXR1cm4gdGhpcy5fY2FsbChyYXdfaW5wdXRzLCB0b2tlbml6ZXJfb3B0aW9ucyk7XG4gICAgfVxufVxuXG5cbmNvbnN0IFdISVNQRVJfTEFOR1VBR0VTID0gW1xuICAgIFtcImVuXCIsIFwiZW5nbGlzaFwiXSxcbiAgICBbXCJ6aFwiLCBcImNoaW5lc2VcIl0sXG4gICAgW1wiZGVcIiwgXCJnZXJtYW5cIl0sXG4gICAgW1wiZXNcIiwgXCJzcGFuaXNoXCJdLFxuICAgIFtcInJ1XCIsIFwicnVzc2lhblwiXSxcbiAgICBbXCJrb1wiLCBcImtvcmVhblwiXSxcbiAgICBbXCJmclwiLCBcImZyZW5jaFwiXSxcbiAgICBbXCJqYVwiLCBcImphcGFuZXNlXCJdLFxuICAgIFtcInB0XCIsIFwicG9ydHVndWVzZVwiXSxcbiAgICBbXCJ0clwiLCBcInR1cmtpc2hcIl0sXG4gICAgW1wicGxcIiwgXCJwb2xpc2hcIl0sXG4gICAgW1wiY2FcIiwgXCJjYXRhbGFuXCJdLFxuICAgIFtcIm5sXCIsIFwiZHV0Y2hcIl0sXG4gICAgW1wiYXJcIiwgXCJhcmFiaWNcIl0sXG4gICAgW1wic3ZcIiwgXCJzd2VkaXNoXCJdLFxuICAgIFtcIml0XCIsIFwiaXRhbGlhblwiXSxcbiAgICBbXCJpZFwiLCBcImluZG9uZXNpYW5cIl0sXG4gICAgW1wiaGlcIiwgXCJoaW5kaVwiXSxcbiAgICBbXCJmaVwiLCBcImZpbm5pc2hcIl0sXG4gICAgW1widmlcIiwgXCJ2aWV0bmFtZXNlXCJdLFxuICAgIFtcImhlXCIsIFwiaGVicmV3XCJdLFxuICAgIFtcInVrXCIsIFwidWtyYWluaWFuXCJdLFxuICAgIFtcImVsXCIsIFwiZ3JlZWtcIl0sXG4gICAgW1wibXNcIiwgXCJtYWxheVwiXSxcbiAgICBbXCJjc1wiLCBcImN6ZWNoXCJdLFxuICAgIFtcInJvXCIsIFwicm9tYW5pYW5cIl0sXG4gICAgW1wiZGFcIiwgXCJkYW5pc2hcIl0sXG4gICAgW1wiaHVcIiwgXCJodW5nYXJpYW5cIl0sXG4gICAgW1widGFcIiwgXCJ0YW1pbFwiXSxcbiAgICBbXCJub1wiLCBcIm5vcndlZ2lhblwiXSxcbiAgICBbXCJ0aFwiLCBcInRoYWlcIl0sXG4gICAgW1widXJcIiwgXCJ1cmR1XCJdLFxuICAgIFtcImhyXCIsIFwiY3JvYXRpYW5cIl0sXG4gICAgW1wiYmdcIiwgXCJidWxnYXJpYW5cIl0sXG4gICAgW1wibHRcIiwgXCJsaXRodWFuaWFuXCJdLFxuICAgIFtcImxhXCIsIFwibGF0aW5cIl0sXG4gICAgW1wibWlcIiwgXCJtYW9yaVwiXSxcbiAgICBbXCJtbFwiLCBcIm1hbGF5YWxhbVwiXSxcbiAgICBbXCJjeVwiLCBcIndlbHNoXCJdLFxuICAgIFtcInNrXCIsIFwic2xvdmFrXCJdLFxuICAgIFtcInRlXCIsIFwidGVsdWd1XCJdLFxuICAgIFtcImZhXCIsIFwicGVyc2lhblwiXSxcbiAgICBbXCJsdlwiLCBcImxhdHZpYW5cIl0sXG4gICAgW1wiYm5cIiwgXCJiZW5nYWxpXCJdLFxuICAgIFtcInNyXCIsIFwic2VyYmlhblwiXSxcbiAgICBbXCJhelwiLCBcImF6ZXJiYWlqYW5pXCJdLFxuICAgIFtcInNsXCIsIFwic2xvdmVuaWFuXCJdLFxuICAgIFtcImtuXCIsIFwia2FubmFkYVwiXSxcbiAgICBbXCJldFwiLCBcImVzdG9uaWFuXCJdLFxuICAgIFtcIm1rXCIsIFwibWFjZWRvbmlhblwiXSxcbiAgICBbXCJiclwiLCBcImJyZXRvblwiXSxcbiAgICBbXCJldVwiLCBcImJhc3F1ZVwiXSxcbiAgICBbXCJpc1wiLCBcImljZWxhbmRpY1wiXSxcbiAgICBbXCJoeVwiLCBcImFybWVuaWFuXCJdLFxuICAgIFtcIm5lXCIsIFwibmVwYWxpXCJdLFxuICAgIFtcIm1uXCIsIFwibW9uZ29saWFuXCJdLFxuICAgIFtcImJzXCIsIFwiYm9zbmlhblwiXSxcbiAgICBbXCJra1wiLCBcImthemFraFwiXSxcbiAgICBbXCJzcVwiLCBcImFsYmFuaWFuXCJdLFxuICAgIFtcInN3XCIsIFwic3dhaGlsaVwiXSxcbiAgICBbXCJnbFwiLCBcImdhbGljaWFuXCJdLFxuICAgIFtcIm1yXCIsIFwibWFyYXRoaVwiXSxcbiAgICBbXCJwYVwiLCBcInB1bmphYmlcIl0sXG4gICAgW1wic2lcIiwgXCJzaW5oYWxhXCJdLFxuICAgIFtcImttXCIsIFwia2htZXJcIl0sXG4gICAgW1wic25cIiwgXCJzaG9uYVwiXSxcbiAgICBbXCJ5b1wiLCBcInlvcnViYVwiXSxcbiAgICBbXCJzb1wiLCBcInNvbWFsaVwiXSxcbiAgICBbXCJhZlwiLCBcImFmcmlrYWFuc1wiXSxcbiAgICBbXCJvY1wiLCBcIm9jY2l0YW5cIl0sXG4gICAgW1wia2FcIiwgXCJnZW9yZ2lhblwiXSxcbiAgICBbXCJiZVwiLCBcImJlbGFydXNpYW5cIl0sXG4gICAgW1widGdcIiwgXCJ0YWppa1wiXSxcbiAgICBbXCJzZFwiLCBcInNpbmRoaVwiXSxcbiAgICBbXCJndVwiLCBcImd1amFyYXRpXCJdLFxuICAgIFtcImFtXCIsIFwiYW1oYXJpY1wiXSxcbiAgICBbXCJ5aVwiLCBcInlpZGRpc2hcIl0sXG4gICAgW1wibG9cIiwgXCJsYW9cIl0sXG4gICAgW1widXpcIiwgXCJ1emJla1wiXSxcbiAgICBbXCJmb1wiLCBcImZhcm9lc2VcIl0sXG4gICAgW1wiaHRcIiwgXCJoYWl0aWFuIGNyZW9sZVwiXSxcbiAgICBbXCJwc1wiLCBcInBhc2h0b1wiXSxcbiAgICBbXCJ0a1wiLCBcInR1cmttZW5cIl0sXG4gICAgW1wibm5cIiwgXCJueW5vcnNrXCJdLFxuICAgIFtcIm10XCIsIFwibWFsdGVzZVwiXSxcbiAgICBbXCJzYVwiLCBcInNhbnNrcml0XCJdLFxuICAgIFtcImxiXCIsIFwibHV4ZW1ib3VyZ2lzaFwiXSxcbiAgICBbXCJteVwiLCBcIm15YW5tYXJcIl0sXG4gICAgW1wiYm9cIiwgXCJ0aWJldGFuXCJdLFxuICAgIFtcInRsXCIsIFwidGFnYWxvZ1wiXSxcbiAgICBbXCJtZ1wiLCBcIm1hbGFnYXN5XCJdLFxuICAgIFtcImFzXCIsIFwiYXNzYW1lc2VcIl0sXG4gICAgW1widHRcIiwgXCJ0YXRhclwiXSxcbiAgICBbXCJoYXdcIiwgXCJoYXdhaWlhblwiXSxcbiAgICBbXCJsblwiLCBcImxpbmdhbGFcIl0sXG4gICAgW1wiaGFcIiwgXCJoYXVzYVwiXSxcbiAgICBbXCJiYVwiLCBcImJhc2hraXJcIl0sXG4gICAgW1wiandcIiwgXCJqYXZhbmVzZVwiXSxcbiAgICBbXCJzdVwiLCBcInN1bmRhbmVzZVwiXSxcbl1cblxuLy8gQHRzLWlnbm9yZVxuY29uc3QgV0hJU1BFUl9MQU5HVUFHRV9NQVBQSU5HID0gbmV3IE1hcChXSElTUEVSX0xBTkdVQUdFUyk7XG4vLyBAdHMtaWdub3JlXG5jb25zdCBXSElTUEVSX1RPX0xBTkdVQUdFX0NPREVfTUFQUElORyA9IG5ldyBNYXAoW1xuICAgIC4uLldISVNQRVJfTEFOR1VBR0VTLm1hcCgoW2ssIHZdKSA9PiBbdiwga10pLFxuICAgIC4uLltcbiAgICAgICAgW1wiYnVybWVzZVwiLCBcIm15XCJdLFxuICAgICAgICBbXCJ2YWxlbmNpYW5cIiwgXCJjYVwiXSxcbiAgICAgICAgW1wiZmxlbWlzaFwiLCBcIm5sXCJdLFxuICAgICAgICBbXCJoYWl0aWFuXCIsIFwiaHRcIl0sXG4gICAgICAgIFtcImxldHplYnVyZ2VzY2hcIiwgXCJsYlwiXSxcbiAgICAgICAgW1wicHVzaHRvXCIsIFwicHNcIl0sXG4gICAgICAgIFtcInBhbmphYmlcIiwgXCJwYVwiXSxcbiAgICAgICAgW1wibW9sZGF2aWFuXCIsIFwicm9cIl0sXG4gICAgICAgIFtcIm1vbGRvdmFuXCIsIFwicm9cIl0sXG4gICAgICAgIFtcInNpbmhhbGVzZVwiLCBcInNpXCJdLFxuICAgICAgICBbXCJjYXN0aWxpYW5cIiwgXCJlc1wiXSxcbiAgICBdXG5dKTtcblxuLyoqXG4gKiBXaGlzcGVyVG9rZW5pemVyIHRva2VuaXplclxuICogQGV4dGVuZHMgUHJlVHJhaW5lZFRva2VuaXplclxuICovXG5leHBvcnQgY2xhc3MgV2hpc3BlclRva2VuaXplciBleHRlbmRzIFByZVRyYWluZWRUb2tlbml6ZXIge1xuXG4gICAgLyoqXG4gICAgICogRGVjb2RlcyBhdXRvbWF0aWMgc3BlZWNoIHJlY29nbml0aW9uIChBU1IpIHNlcXVlbmNlcy5cbiAgICAgKiBAcGFyYW0ge0FycmF5PHt0b2tlbnM6IG51bWJlcltdLCB0b2tlbl90aW1lc3RhbXBzPzogbnVtYmVyW10sIHN0cmlkZTogbnVtYmVyW119Pn0gc2VxdWVuY2VzIFRoZSBzZXF1ZW5jZXMgdG8gZGVjb2RlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIFRoZSBvcHRpb25zIHRvIHVzZSBmb3IgZGVjb2RpbmcuXG4gICAgICogQHJldHVybnMge0FycmF5PHN0cmluZ3x7Y2h1bmtzPzogdW5kZWZpbmVkfEFycmF5PHtsYW5ndWFnZTogc3RyaW5nfG51bGwsIHRpbWVzdGFtcDogQXJyYXk8bnVtYmVyfG51bGw+LCB0ZXh0OiBzdHJpbmd9Pn0+fSBUaGUgZGVjb2RlZCBzZXF1ZW5jZXMuXG4gICAgICovXG4gICAgX2RlY29kZV9hc3Ioc2VxdWVuY2VzLCB7XG4gICAgICAgIHJldHVybl90aW1lc3RhbXBzID0gZmFsc2UsXG4gICAgICAgIHJldHVybl9sYW5ndWFnZSA9IGZhbHNlLFxuICAgICAgICB0aW1lX3ByZWNpc2lvbiA9IG51bGwsXG4gICAgICAgIGZvcmNlX2Z1bGxfc2VxdWVuY2VzID0gdHJ1ZVxuICAgIH0gPSB7fSkge1xuICAgICAgICAvLyBTZXQgZm9yY2VfZnVsbF9zZXF1ZW5jZXM9ZmFsc2UgaWYgeW91IHdhbnQgc3RyZWFtaW5nXG4gICAgICAgIC8vIFRPRE8gYWRkIHN1cHBvcnQgZm9yIGByZXR1cm5fbGFuZ3VhZ2VgXG5cbiAgICAgICAgLy8gSW50ZXJuYWwgbWV0aG9kIG1lYW50IHRvIG9ubHkgYmUgdXNlZCBieSBhc3IgcGlwZWxpbmUuXG4gICAgICAgIC8vIEhhbmRsZXMgYWxsIHRoZSBsaXR0bGUgcXVpcmtzIHNwZWNpZmljIHRvIHdoaXNwZXIgdG8gaGFuZGxlXG4gICAgICAgIC8vIHRoZSB2YXJpb3VzIG9wdGlvbnMgbm90IGFsbG93ZWQgaW4gb3RoZXIgc2VxMnNlcSBtb2RlbHNcblxuICAgICAgICAvLyA9PT09PT09PT09PSBPdmVydmlldyA9PT09PT09PT09PT1cbiAgICAgICAgLy8gLSBpdGVyYXRlIG92ZXIgYWxsIG91dHB1dHNcbiAgICAgICAgLy8gLSBhbGwgdG9rZW5zIHdpdGhpbiBvdXRwdXRcbiAgICAgICAgLy8gLSBFYWNoIHRva2VuIGNhbiBiZVxuICAgICAgICAvLyAgIC0gbGFuZ3VhZ2UgdG9rZW5cbiAgICAgICAgLy8gICAtIHNwZWNpYWwgdG9rZW5cbiAgICAgICAgLy8gICAtIHRpbWVzdGFtcCB0b2tlblxuICAgICAgICAvLyAgIC0gdGV4dCB0b2tlblxuICAgICAgICAvLyAtIFdlIGFjY3VtdWxhdGUgdGhlIHRleHQgdG9rZW5zLlxuICAgICAgICAvLyAtIFdlIHNwbGl0IG9uIGVuZCB0aW1lc3RhbXBzXG4gICAgICAgIC8vIC0gTG90cyBvZiBjb21wbGV4aXR5IGNvbWVzIGZyb20gc3RyaWRlIGFuZCB0aW1lc3RhbXBzXG5cbiAgICAgICAgaWYgKHRpbWVfcHJlY2lzaW9uID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcIk11c3Qgc3BlY2lmeSB0aW1lX3ByZWNpc2lvblwiKVxuICAgICAgICB9XG4gICAgICAgIGxldCBsYXN0X2xhbmd1YWdlID0gbnVsbDtcblxuICAgICAgICBjb25zdCByZXR1cm5Xb3JkVGltZXN0YW1wcyA9IHJldHVybl90aW1lc3RhbXBzID09PSBcIndvcmRcIjtcblxuICAgICAgICBmdW5jdGlvbiBuZXdfY2h1bmsoKSB7XG4gICAgICAgICAgICByZXR1cm4geyBcImxhbmd1YWdlXCI6IGxhc3RfbGFuZ3VhZ2UsIFwidGltZXN0YW1wXCI6IFtudWxsLCBudWxsXSwgXCJ0ZXh0XCI6IFwiXCIgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFdlbGNvbWUgdG8gdGhlIHN0YXRlIG1hY2hpbmUhXG4gICAgICAgIGNvbnN0IGNodW5rcyA9IFtdO1xuICAgICAgICBsZXQgY2h1bmsgPSBuZXdfY2h1bmsoKTtcbiAgICAgICAgbGV0IHRpbWVfb2Zmc2V0ID0gMC4wO1xuICAgICAgICBjb25zdCB0aW1lc3RhbXBfYmVnaW4gPSB0aGlzLm1vZGVsLmNvbnZlcnRfdG9rZW5zX3RvX2lkcyhbXCI8fG5vdGltZXN0YW1wc3w+XCJdKVswXSArIDE7XG5cbiAgICAgICAgbGV0IHByZXZpb3VzX3Rva2VucyA9IFtdO1xuICAgICAgICBsZXQgcHJldmlvdXNfdG9rZW5fdGltZXN0YW1wcyA9IFtdO1xuXG4gICAgICAgIGxldCBza2lwID0gZmFsc2U7XG4gICAgICAgIGxldCByaWdodF9zdHJpZGVfc3RhcnQgPSBudWxsO1xuXG5cbiAgICAgICAgY29uc3QgYWxsX3NwZWNpYWxfaWRzID0gbmV3IFNldCh0aGlzLmFsbF9zcGVjaWFsX2lkcyk7XG5cbiAgICAgICAgZm9yIChsZXQgb3V0cHV0IG9mIHNlcXVlbmNlcykge1xuICAgICAgICAgICAgLy8gTk9URTogcHl0aG9uIHZlcnNpb24gaGFzIGJhdGNoZXMsIHNvIGl0IHVzZXMgWzBdXG4gICAgICAgICAgICBjb25zdCB0b2tlbl9pZHMgPSBvdXRwdXQudG9rZW5zO1xuICAgICAgICAgICAgY29uc3QgdG9rZW5fdGltZXN0YW1wcyA9IHJldHVybldvcmRUaW1lc3RhbXBzID8gb3V0cHV0LnRva2VuX3RpbWVzdGFtcHMgOiBudWxsO1xuXG4gICAgICAgICAgICAvLyBUaGVzZSBrZWVwIHRyYWNrIG9mIHRpbWVzdGFtcHMgd2l0aGluIHN0cmlkZXMsIHdoaWNoIG5lZWRcbiAgICAgICAgICAgIC8vIHRvIGJlIHNraXBwZWQgYW5kIHJlc29sdmUgYWxsIHRva2VucyBpbiBhIHNpbmdsZSBjaHVuay5cbiAgICAgICAgICAgIGxldCBsYXN0X3RpbWVzdGFtcCA9IG51bGw7XG4gICAgICAgICAgICBsZXQgZmlyc3RfdGltZXN0YW1wID0gdGltZXN0YW1wX2JlZ2luO1xuXG4gICAgICAgICAgICBpZiAoXCJzdHJpZGVcIiBpbiBvdXRwdXQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBbY2h1bmtfbGVuLCBzdHJpZGVfbGVmdCwgc3RyaWRlX3JpZ2h0XSA9IG91dHB1dC5zdHJpZGU7XG5cbiAgICAgICAgICAgICAgICAvLyBPZmZzZXQgdGhlIHRpbWluZ3MgdG8gYWNjb3VudCBmb3IgdGhlIG90aGVyIGBtb2RlbF9vdXRwdXRzYC5cbiAgICAgICAgICAgICAgICB0aW1lX29mZnNldCAtPSBzdHJpZGVfbGVmdDtcbiAgICAgICAgICAgICAgICByaWdodF9zdHJpZGVfc3RhcnQgPSBjaHVua19sZW4gLSBzdHJpZGVfcmlnaHQ7XG5cbiAgICAgICAgICAgICAgICAvLyBLZWVwaW5nIHRyYWNrIG9mIHRpbWVzdGFtcHMgd2l0aGluIHN0cmlkZXNcbiAgICAgICAgICAgICAgICAvLyBXZSdyZSBnb2luZyB0byBOT1Qgc3BsaXQgb24gdGhvc2UsIGFuZCBkZWxheSB1bnRpbCB3ZSdyZVxuICAgICAgICAgICAgICAgIC8vIG91dCBvZiBCT1RIIHN0cmlkZS4gT3RoZXJ3aXNlIGxvdHMgb2YgaXNzdWVzIG9jY3VyIGFuZFxuICAgICAgICAgICAgICAgIC8vIGNvcm5lciBjYXNlc1xuICAgICAgICAgICAgICAgIGlmIChzdHJpZGVfbGVmdCkge1xuICAgICAgICAgICAgICAgICAgICBmaXJzdF90aW1lc3RhbXAgPSBzdHJpZGVfbGVmdCAvIHRpbWVfcHJlY2lzaW9uICsgdGltZXN0YW1wX2JlZ2luO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChzdHJpZGVfcmlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IHRva2VuX2lkcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdG9rZW4gPSB0b2tlbl9pZHNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodG9rZW4gPj0gdGltZXN0YW1wX2JlZ2luKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlcmUgY2FuIGJlIHNldmVyYWwgdG9rZW4gaW4gdGhlIHJpZ2h0IHN0cmlkZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEJ1dCB0aGUgbGFzdCBvbmUgaXMgQUxXQVlTIGdvaW5nIHRvIGJlIHNraXBwZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobGFzdF90aW1lc3RhbXAgIT09IG51bGwgJiYgKHRva2VuIC0gdGltZXN0YW1wX2JlZ2luKSAqIHRpbWVfcHJlY2lzaW9uIDwgcmlnaHRfc3RyaWRlX3N0YXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0X3RpbWVzdGFtcCA9IHRva2VuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQgY3VycmVudF90b2tlbnMgPSBbXTtcbiAgICAgICAgICAgIGxldCBjdXJyZW50X3Rva2VuX3RpbWVzdGFtcHMgPSBbXTtcblxuICAgICAgICAgICAgLy8gLSBhbGwgdG9rZW5zIHdpdGhpbiBvdXRwdXRcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdG9rZW5faWRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdG9rZW4gPSB0b2tlbl9pZHNbaV07XG4gICAgICAgICAgICAgICAgLy8gNCBwb3NzaWJsZSBzdGF0ZXMgZm9yIGVhY2ggdG9rZW5cbiAgICAgICAgICAgICAgICAvLyAtIDEvIExhbmd1YWdlIGNvZGVcbiAgICAgICAgICAgICAgICAvLyAtIDIvIGFsbCBvdGhlciBzcGVjaWFsIHRva2VucyAod2hpY2ggd2UgaWdub3JlKVxuICAgICAgICAgICAgICAgIC8vIC0gMy8gVGltZXN0YW1wXG4gICAgICAgICAgICAgICAgLy8gLSA0LyBSZWd1bGFyIHRleHRcblxuICAgICAgICAgICAgICAgIGlmIChhbGxfc3BlY2lhbF9pZHMuaGFzKHRva2VuKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0ZXh0ID0gdGhpcy5kZWNvZGUoW3Rva2VuXSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ZXh0WzBdID09PSBcIltcIiAmJiB0ZXh0W3RleHQubGVuZ3RoIC0gMV0gPT09IFwiXVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBsYW5ndWFnZSA9IFdISVNQRVJfTEFOR1VBR0VfTUFQUElORy5nZXQodGV4dC5zbGljZSgxLCAtMSkpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobGFuZ3VhZ2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDEvIEluZGVlZCBzb21lIGxhbmd1YWdlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyBIYW5kbGUgd2hlbiBsYW5ndWFnZSBpcyBkaWZmZXJlbnQgZnJvbSB0aGUgcHJldmlvdXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBvbmUsIGFuZCB3ZSBjYW5ub3QgdXNlIHRpbWVzdGFtcGVkIHRva2VucyB0byBjcmVhdGUgY2h1bmtzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxhc3RfbGFuZ3VhZ2UgIT09IG51bGwgJiYgbGFuZ3VhZ2UgIT09IGxhc3RfbGFuZ3VhZ2UgJiYgIXJldHVybl90aW1lc3RhbXBzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXZpb3VzX3Rva2Vucy5wdXNoKGN1cnJlbnRfdG9rZW5zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzb2x2ZWRfdG9rZW5zID0gdGhpcy5maW5kTG9uZ2VzdENvbW1vblNlcXVlbmNlKHByZXZpb3VzX3Rva2VucylbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc29sdmVkX3RleHQgPSB0aGlzLmRlY29kZShyZXNvbHZlZF90b2tlbnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaHVuay50ZXh0ID0gcmVzb2x2ZWRfdGV4dDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2h1bmtzLnB1c2goY2h1bmspO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZsdXNoIGFsbCBvdXIgdGVtcG9yYXJ5IGNvbnRleHRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJldmlvdXNfdG9rZW5zID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRfdG9rZW5zID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNodW5rID0gbmV3X2NodW5rKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFzdF9sYW5ndWFnZSA9IGNodW5rLmxhbmd1YWdlID0gbGFuZ3VhZ2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDIvIFRoaXMgaXMgYSByZWd1bGFyIHNwZWNpYWwgdG9rZW4sIGlnbm9yaW5nIGl0XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRva2VuID49IHRpbWVzdGFtcF9iZWdpbikge1xuICAgICAgICAgICAgICAgICAgICAvLyAzLyBUaW1lc3RhbXAgdG9rZW5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGltZSA9ICh0b2tlbiAtIHRpbWVzdGFtcF9iZWdpbikgKiB0aW1lX3ByZWNpc2lvbiArIHRpbWVfb2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByb3VuZGVkX3RpbWUgPSByb3VuZCh0aW1lLCAyKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAobGFzdF90aW1lc3RhbXAgIT09IG51bGwgJiYgdG9rZW4gPj0gbGFzdF90aW1lc3RhbXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdoaXNwZXIgb3V0cHV0dGVkIGEgdGltZXN0YW1wIHRva2VuLCBidXQgaXQgZmFsbHMgd2l0aGluXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBvdXIgc3RyaWRlLCBzbyB3ZSdyZSBnb2luZyB0byBza2lwIGl0IGZvciB0aGUgdGltZSBiZWluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYW5kIHJlc29sdmUgdGhpcyBsYXRlclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2tpcCBpcyBuZWNlc3NhcnkgYmVjYXVzZSB0aW1lc3RhbXAgdG9rZW5zIGFsd2F5cyBjb21lXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBieSBwYWlyLCBzbyB3ZSBuZWVkIHRvIHNraXAgdGhlIG5leHQgb25lIHRvbyAod2hpY2ggd291bGQgbWFyayB0aGUgc3RhcnQgb2YgYW5vdGhlciBjaHVuaykuXG4gICAgICAgICAgICAgICAgICAgICAgICBza2lwID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChza2lwIHx8IChwcmV2aW91c190b2tlbnMubGVuZ3RoID4gMCAmJiB0b2tlbiA8IGZpcnN0X3RpbWVzdGFtcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNraXAgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjaHVuay50aW1lc3RhbXBbMF0gPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNodW5rLnRpbWVzdGFtcFswXSA9IHJvdW5kZWRfdGltZTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgdGhlIGVuZCBvZiB0aGUgdGltZXN0YW1wIGNodW5rXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocm91bmRlZF90aW1lID09PSBjaHVuay50aW1lc3RhbXBbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIGEgYnVnIGluIHRpbWVzdGFtcCB0b2tlbiBvdXRwdXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3aGVyZSB3ZSdyZSB0YWtpbmcgdGhlIGR1cGxpY2F0ZSB0b2tlblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFzIGEgc3RvcCB3aGVyZSBpdCBzaG91bGQgYmUgYSBzdGFydC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIGFuIGlzc3VlIGluIHRoZSB1bmRlcmx5aW5nIG1vZGVsIG91dHB1dFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIExldCdzIGp1c3Qgc2tpcCBpdCBzbyBpdCBiZWNvbWVzIGRlLWZhY3RvciBhIHN0YXJ0IGFnaW5cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2h1bmsudGltZXN0YW1wWzFdID0gcm91bmRlZF90aW1lO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSGFuZGxpbmcgbWVyZ2VzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJldmlvdXNfdG9rZW5zLnB1c2goY3VycmVudF90b2tlbnMpXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmV0dXJuV29yZFRpbWVzdGFtcHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJldmlvdXNfdG9rZW5fdGltZXN0YW1wcy5wdXNoKGN1cnJlbnRfdG9rZW5fdGltZXN0YW1wcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IFtyZXNvbHZlZF90b2tlbnMsIHJlc29sdmVkX3Rva2VuX3RpbWVzdGFtcHNdID0gdGhpcy5maW5kTG9uZ2VzdENvbW1vblNlcXVlbmNlKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmV2aW91c190b2tlbnMsIHByZXZpb3VzX3Rva2VuX3RpbWVzdGFtcHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNvbHZlZF90ZXh0ID0gdGhpcy5kZWNvZGUocmVzb2x2ZWRfdG9rZW5zKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNodW5rLnRleHQgPSByZXNvbHZlZF90ZXh0XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmV0dXJuV29yZFRpbWVzdGFtcHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2h1bmsud29yZHMgPSB0aGlzLmNvbGxhdGVXb3JkVGltZXN0YW1wcyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmVkX3Rva2VucywgcmVzb2x2ZWRfdG9rZW5fdGltZXN0YW1wcywgbGFzdF9sYW5ndWFnZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNodW5rcy5wdXNoKGNodW5rKVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRmx1c2ggYWxsIG91ciB0ZW1wb3JhcnkgY29udGV4dFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXZpb3VzX3Rva2VucyA9IFtdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudF90b2tlbnMgPSBbXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXZpb3VzX3Rva2VuX3RpbWVzdGFtcHMgPSBbXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRfdG9rZW5fdGltZXN0YW1wcyA9IFtdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2h1bmsgPSBuZXdfY2h1bmsoKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyA0LyBSZWd1bGFyIHRva2VuXG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIGp1c3QgYXBwZW5kIHRvIHRoZSBsaXN0IG9mIGFsbCB0b2tlbnMgc28gd2UgY2FuIGhhbmRsZVxuICAgICAgICAgICAgICAgICAgICAvLyBtZXJnZXMgbGF0ZXIgYW5kIGRlY29kZSBpbnRvIHRleHQuXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRfdG9rZW5zLnB1c2godG9rZW4pXG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHJldHVybldvcmRUaW1lc3RhbXBzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgc3RhcnRfdGltZSA9IHJvdW5kKHRva2VuX3RpbWVzdGFtcHNbaV0gKyB0aW1lX29mZnNldCwgMik7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBlbmRfdGltZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpICsgMSA8IHRva2VuX3RpbWVzdGFtcHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kX3RpbWUgPSByb3VuZCh0b2tlbl90aW1lc3RhbXBzW2kgKyAxXSArIHRpbWVfb2Zmc2V0LCAyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2hvdWxkIG5ldmVyIGhhcHBlblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZF90aW1lID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRfdG9rZW5fdGltZXN0YW1wcy5wdXNoKFtzdGFydF90aW1lLCBlbmRfdGltZV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICgnc3RyaWRlJyBpbiBvdXRwdXQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBbY2h1bmtfbGVuLCBzdHJpZGVfbGVmdCwgc3RyaWRlX3JpZ2h0XSA9IG91dHB1dC5zdHJpZGU7XG4gICAgICAgICAgICAgICAgdGltZV9vZmZzZXQgKz0gY2h1bmtfbGVuIC0gc3RyaWRlX3JpZ2h0XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIExlZnRvdmVyIHRva2Vuc1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRfdG9rZW5zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBwcmV2aW91c190b2tlbnMucHVzaChjdXJyZW50X3Rva2VucylcbiAgICAgICAgICAgICAgICBpZiAocmV0dXJuV29yZFRpbWVzdGFtcHMpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJldmlvdXNfdG9rZW5fdGltZXN0YW1wcy5wdXNoKGN1cnJlbnRfdG9rZW5fdGltZXN0YW1wcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChwcmV2aW91c190b2tlbnMuZXZlcnkocCA9PiBwLmxlbmd0aCA9PT0gMCkpIHtcbiAgICAgICAgICAgICAgICAvLyBGbHVzaGluZyBwcmV2aW91cyB0b2tlbnMgKEVORClcIlxuICAgICAgICAgICAgICAgIGNodW5rID0gbmV3X2NodW5rKClcbiAgICAgICAgICAgICAgICBwcmV2aW91c190b2tlbnMgPSBbXVxuICAgICAgICAgICAgICAgIGN1cnJlbnRfdG9rZW5zID0gW11cbiAgICAgICAgICAgICAgICBwcmV2aW91c190b2tlbl90aW1lc3RhbXBzID0gW107XG4gICAgICAgICAgICAgICAgY3VycmVudF90b2tlbl90aW1lc3RhbXBzID0gW107XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwcmV2aW91c190b2tlbnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgaWYgKGZvcmNlX2Z1bGxfc2VxdWVuY2VzICYmIHJldHVybl90aW1lc3RhbXBzKSB7XG4gICAgICAgICAgICAgICAgLy8gTGFzdCB0b2tlbiBzaG91bGQgYWx3YXlzIGJlIHRpbWVzdGFtcHMsIHNvIHRoZXJlIHNob3VsZG4ndCBiZVxuICAgICAgICAgICAgICAgIC8vIGxlZnRvdmVyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgICAgICBcIldoaXNwZXIgZGlkIG5vdCBwcmVkaWN0IGFuIGVuZGluZyB0aW1lc3RhbXAsIHdoaWNoIGNhbiBoYXBwZW4gaWYgYXVkaW8gaXMgY3V0IG9mZiBpbiB0aGUgbWlkZGxlIG9mIGEgd29yZC4gXCIgK1xuICAgICAgICAgICAgICAgICAgICBcIkFsc28gbWFrZSBzdXJlIFdoaXNwZXJUaW1lU3RhbXBMb2dpdHNQcm9jZXNzb3Igd2FzIHVzZWQgZHVyaW5nIGdlbmVyYXRpb24uXCJcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBIYXBwZW5zIHdoZW4gd2UgZG9uJ3QgdXNlIHRpbWVzdGFtcHNcbiAgICAgICAgICAgIGNvbnN0IFtyZXNvbHZlZF90b2tlbnMsIHJlc29sdmVkX3Rva2VuX3RpbWVzdGFtcHNdID0gdGhpcy5maW5kTG9uZ2VzdENvbW1vblNlcXVlbmNlKHByZXZpb3VzX3Rva2VucywgcHJldmlvdXNfdG9rZW5fdGltZXN0YW1wcyk7XG5cbiAgICAgICAgICAgIC8vIEZsdXNoaW5nIHByZXZpb3VzIHRva2VucyAoRklOQUwpXG4gICAgICAgICAgICBjb25zdCByZXNvbHZlZF90ZXh0ID0gdGhpcy5kZWNvZGUocmVzb2x2ZWRfdG9rZW5zKTtcbiAgICAgICAgICAgIGNodW5rLnRleHQgPSByZXNvbHZlZF90ZXh0O1xuICAgICAgICAgICAgaWYgKHJldHVybldvcmRUaW1lc3RhbXBzKSB7XG4gICAgICAgICAgICAgICAgY2h1bmsud29yZHMgPSB0aGlzLmNvbGxhdGVXb3JkVGltZXN0YW1wcyhcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZWRfdG9rZW5zLCByZXNvbHZlZF90b2tlbl90aW1lc3RhbXBzLCBsYXN0X2xhbmd1YWdlLFxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNodW5rcy5wdXNoKGNodW5rKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBvcHRpb25hbCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgICAgICAgLy8gUHJlcGFyaW5nIGFuZCBjbGVhbmluZyB1cCB0aGUgcGlwZWxpbmUgb3V0cHV0XG4gICAgICAgIGNvbnN0IGZ1bGxfdGV4dCA9IGNodW5rcy5tYXAoY2h1bmsgPT4gY2h1bmsudGV4dCkuam9pbignJyk7XG4gICAgICAgIGlmIChyZXR1cm5fdGltZXN0YW1wcyB8fCByZXR1cm5fbGFuZ3VhZ2UpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2h1bmtzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2h1bmsgPSBjaHVua3NbaV07XG4gICAgICAgICAgICAgICAgaWYgKCFyZXR1cm5fdGltZXN0YW1wcykge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgY2h1bmtbXCJ0aW1lc3RhbXBcIl07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCFyZXR1cm5fbGFuZ3VhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGNodW5rW1wibGFuZ3VhZ2VcIl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJldHVybldvcmRUaW1lc3RhbXBzKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5ld19jaHVua3MgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBjaHVuayBvZiBjaHVua3MpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgd29yZCBvZiBjaHVuay53b3Jkcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3X2NodW5rcy5wdXNoKHdvcmQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9wdGlvbmFsID0geyBcImNodW5rc1wiOiBuZXdfY2h1bmtzIH07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG9wdGlvbmFsID0geyBcImNodW5rc1wiOiBjaHVua3MgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW2Z1bGxfdGV4dCwgb3B0aW9uYWxdO1xuXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmluZHMgdGhlIGxvbmdlc3QgY29tbW9uIHNlcXVlbmNlIGFtb25nIHRoZSBwcm92aWRlZCBzZXF1ZW5jZXMuXG4gICAgICogQHBhcmFtIHtudW1iZXJbXVtdfSBzZXF1ZW5jZXMgQW4gYXJyYXkgb2Ygc2VxdWVuY2VzIG9mIHRva2VuIGlkcyB0byBjb21wYXJlLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJbXVtdfSBUaGUgbG9uZ2VzdCBjb21tb24gc2VxdWVuY2UgZm91bmQuXG4gICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZXJlIGlzIGEgYnVnIHdpdGhpbiB0aGUgZnVuY3Rpb24uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBmaW5kTG9uZ2VzdENvbW1vblNlcXVlbmNlKHNlcXVlbmNlcywgdG9rZW5fdGltZXN0YW1wX3NlcXVlbmNlcyA9IG51bGwpIHtcbiAgICAgICAgLy8gSXQgd291bGQgYmUgbXVjaCBoYXJkZXIgdG8gZG8gTyhuKSBiZWNhdXNlIG9mIGZhdWx0IHRvbGVyYW5jZS5cbiAgICAgICAgLy8gV2UgYWN0dWFsbHkgaGF2ZSBhIHJlYWxseSBnb29kIHByb3BlcnR5IHdoaWNoIGlzIHRoYXQgdGhlIHRvdGFsIHNlcXVlbmNlXG4gICAgICAgIC8vIE1VU1QgYmUgdGhvc2Ugc3Vic2VxdWVuY2VzIGluIG9yZGVyLlxuICAgICAgICAvLyBJZiB0b2tlbl90aW1lc3RhbXBfc2VxdWVuY2VzIGlzIHByb3ZpZGVkLCB3aWxsIHNwbGl0IHRob3NlIHNlcXVlbmNlcyBpblxuICAgICAgICAvLyBleGFjdGx5IHRoZSBzYW1lIHdheS5cbiAgICAgICAgbGV0IGxlZnRTZXF1ZW5jZSA9IHNlcXVlbmNlc1swXTtcbiAgICAgICAgbGV0IGxlZnRMZW5ndGggPSBsZWZ0U2VxdWVuY2UubGVuZ3RoO1xuICAgICAgICBsZXQgdG90YWxTZXF1ZW5jZSA9IFtdO1xuXG4gICAgICAgIGNvbnN0IHVzZV90b2tlbl90aW1lc3RhbXBfc2VxdWVuY2VzID0gQXJyYXkuaXNBcnJheSh0b2tlbl90aW1lc3RhbXBfc2VxdWVuY2VzKSAmJiB0b2tlbl90aW1lc3RhbXBfc2VxdWVuY2VzLmxlbmd0aCA+IDA7XG4gICAgICAgIGxldCB0b3RhbF90b2tlbl90aW1lc3RhbXBfc2VxdWVuY2UgPSB1c2VfdG9rZW5fdGltZXN0YW1wX3NlcXVlbmNlcyA/IFtdIDogbnVsbDtcbiAgICAgICAgbGV0IGxlZnRfdG9rZW5fdGltZXN0YW1wX3NlcXVlbmNlID0gdXNlX3Rva2VuX3RpbWVzdGFtcF9zZXF1ZW5jZXMgPyB0b2tlbl90aW1lc3RhbXBfc2VxdWVuY2VzWzBdIDogbnVsbDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBzZXF1ZW5jZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IHJpZ2h0U2VxdWVuY2UgPSBzZXF1ZW5jZXNbaV07XG4gICAgICAgICAgICBsZXQgbWF4ID0gMC4wO1xuICAgICAgICAgICAgbGV0IG1heEluZGljZXMgPSBbbGVmdExlbmd0aCwgbGVmdExlbmd0aCwgMCwgMF07XG4gICAgICAgICAgICAvLyBIZXJlIHdlJ3JlIHNsaWRpbmcgbWF0Y2hlc1xuICAgICAgICAgICAgLy8gW2EsIGIsIGMsIGRdXG4gICAgICAgICAgICAvLyAgICAgICAgICBbYywgZCwgZl1cbiAgICAgICAgICAgIC8vID0gICAgICAgIFtjXSA9PSBbZF1cblxuICAgICAgICAgICAgLy8gW2EsIGIsIGMsIGRdXG4gICAgICAgICAgICAvLyAgICAgICBbYywgZCwgZl1cbiAgICAgICAgICAgIC8vID0gICAgIFtjLCBkXSA9PSBbYywgZF1cblxuXG4gICAgICAgICAgICAvLyBbYSwgYiwgYywgZF1cbiAgICAgICAgICAgIC8vICAgIFtjLCBkLCBmXVxuXG4gICAgICAgICAgICAvLyA9ICBbYiwgYywgZF0gPT0gW2MsIGQsIGZdXG5cbiAgICAgICAgICAgIC8vIFthLCBiLCBjLCBkXVxuICAgICAgICAgICAgLy8gW2MsIGQsIGZdXG5cbiAgICAgICAgICAgIC8vIFthLCBiLCBjXSA9PSBbYywgZCwgZl1cblxuICAgICAgICAgICAgLy8gW2EsIGIsIGMsIGRdXG4gICAgICAgICAgICAvLyBbZCwgZl1cblxuICAgICAgICAgICAgLy8gW2EsIGJdID09IFtkLCBmXVxuXG4gICAgICAgICAgICAvLyBbYSwgYiwgYywgZF1cbiAgICAgICAgICAgIC8vIFtmXVxuXG4gICAgICAgICAgICAvLyBbYV0gPT0gW2ZdXG5cbiAgICAgICAgICAgIGNvbnN0IHJpZ2h0TGVuZ3RoID0gcmlnaHRTZXF1ZW5jZS5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMTsgaiA8IGxlZnRMZW5ndGggKyByaWdodExlbmd0aDsgKytqKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXBzID0gaiAvIDEwMDAwLjA7XG4gICAgICAgICAgICAgICAgY29uc3QgbGVmdFN0YXJ0ID0gTWF0aC5tYXgoMCwgbGVmdExlbmd0aCAtIGopO1xuICAgICAgICAgICAgICAgIGNvbnN0IGxlZnRTdG9wID0gTWF0aC5taW4obGVmdExlbmd0aCwgbGVmdExlbmd0aCArIHJpZ2h0TGVuZ3RoIC0gaik7XG4gICAgICAgICAgICAgICAgY29uc3QgbGVmdCA9IGxlZnRTZXF1ZW5jZS5zbGljZShsZWZ0U3RhcnQsIGxlZnRTdG9wKTtcbiAgICAgICAgICAgICAgICBjb25zdCByaWdodFN0YXJ0ID0gTWF0aC5tYXgoMCwgaiAtIGxlZnRMZW5ndGgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJpZ2h0U3RvcCA9IE1hdGgubWluKHJpZ2h0TGVuZ3RoLCBqKTtcbiAgICAgICAgICAgICAgICBjb25zdCByaWdodCA9IHJpZ2h0U2VxdWVuY2Uuc2xpY2UocmlnaHRTdGFydCwgcmlnaHRTdG9wKTtcbiAgICAgICAgICAgICAgICBpZiAobGVmdC5sZW5ndGggIT09IHJpZ2h0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGVyZSBpcyBhIGJ1ZyB3aXRoaW4gd2hpc3BlciBgZGVjb2RlX2FzcmAgZnVuY3Rpb24sIHBsZWFzZSByZXBvcnQgaXQuIERyb3BwaW5nIHRvIHByZXZlbnQgYmFkIGluZmVyZW5jZS5cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IG1hdGNoZXMgPSBsZWZ0LmZpbHRlcigoZWxlbSwgaWR4KSA9PiBlbGVtID09PSByaWdodFtpZHhdKS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgY29uc3QgbWF0Y2hpbmcgPSBtYXRjaGVzIC8gaiArIGVwcztcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2hlcyA+IDEgJiYgbWF0Y2hpbmcgPiBtYXgpIHtcbiAgICAgICAgICAgICAgICAgICAgbWF4ID0gbWF0Y2hpbmc7XG4gICAgICAgICAgICAgICAgICAgIG1heEluZGljZXMgPSBbbGVmdFN0YXJ0LCBsZWZ0U3RvcCwgcmlnaHRTdGFydCwgcmlnaHRTdG9wXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBbbGVmdFN0YXJ0LCBsZWZ0U3RvcCwgcmlnaHRTdGFydCwgcmlnaHRTdG9wXSA9IG1heEluZGljZXM7XG4gICAgICAgICAgICBjb25zdCBsZWZ0TWlkID0gTWF0aC5mbG9vcigobGVmdFN0b3AgKyBsZWZ0U3RhcnQpIC8gMik7XG4gICAgICAgICAgICBjb25zdCByaWdodE1pZCA9IE1hdGguZmxvb3IoKHJpZ2h0U3RvcCArIHJpZ2h0U3RhcnQpIC8gMik7XG4gICAgICAgICAgICB0b3RhbFNlcXVlbmNlLnB1c2goLi4ubGVmdFNlcXVlbmNlLnNsaWNlKDAsIGxlZnRNaWQpKTtcbiAgICAgICAgICAgIGxlZnRTZXF1ZW5jZSA9IHJpZ2h0U2VxdWVuY2Uuc2xpY2UocmlnaHRNaWQpO1xuICAgICAgICAgICAgbGVmdExlbmd0aCA9IGxlZnRTZXF1ZW5jZS5sZW5ndGg7XG5cbiAgICAgICAgICAgIGlmICh1c2VfdG9rZW5fdGltZXN0YW1wX3NlcXVlbmNlcykge1xuICAgICAgICAgICAgICAgIHRvdGFsX3Rva2VuX3RpbWVzdGFtcF9zZXF1ZW5jZS5wdXNoKC4uLmxlZnRfdG9rZW5fdGltZXN0YW1wX3NlcXVlbmNlLnNsaWNlKDAsIGxlZnRNaWQpKTtcbiAgICAgICAgICAgICAgICBsZWZ0X3Rva2VuX3RpbWVzdGFtcF9zZXF1ZW5jZSA9IHRva2VuX3RpbWVzdGFtcF9zZXF1ZW5jZXNbaV0uc2xpY2UocmlnaHRNaWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRvdGFsU2VxdWVuY2UucHVzaCguLi5sZWZ0U2VxdWVuY2UpO1xuXG4gICAgICAgIGlmICh1c2VfdG9rZW5fdGltZXN0YW1wX3NlcXVlbmNlcykge1xuICAgICAgICAgICAgdG90YWxfdG9rZW5fdGltZXN0YW1wX3NlcXVlbmNlLnB1c2goLi4ubGVmdF90b2tlbl90aW1lc3RhbXBfc2VxdWVuY2UpO1xuICAgICAgICAgICAgcmV0dXJuIFt0b3RhbFNlcXVlbmNlLCB0b3RhbF90b2tlbl90aW1lc3RhbXBfc2VxdWVuY2VdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFt0b3RhbFNlcXVlbmNlLCBbXV07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKiogQHByaXZhdGUgKi9cbiAgICBjb2xsYXRlV29yZFRpbWVzdGFtcHModG9rZW5zLCB0b2tlbl90aW1lc3RhbXBzLCBsYW5ndWFnZSkge1xuXG4gICAgICAgIGxldCBbd29yZHMsIF8sIHRva2VuX2luZGljZXNdID0gdGhpcy5jb21iaW5lVG9rZW5zSW50b1dvcmRzKHRva2VucywgbGFuZ3VhZ2UpO1xuXG4gICAgICAgIGxldCB0aW1pbmdzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgd29yZHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IGluZGljZXMgPSB0b2tlbl9pbmRpY2VzW2ldO1xuICAgICAgICAgICAgdGltaW5ncy5wdXNoKHtcbiAgICAgICAgICAgICAgICB0ZXh0OiB3b3Jkc1tpXSxcbiAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IFtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5fdGltZXN0YW1wc1tpbmRpY2VzLmF0KDApXVswXSxcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5fdGltZXN0YW1wc1tpbmRpY2VzLmF0KC0xKV1bMV0sXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aW1pbmdzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdyb3VwcyB0b2tlbnMgYnkgd29yZC4gUmV0dXJucyBhIHR1cGxlIGNvbnRhaW5pbmcgYSBsaXN0IG9mIHN0cmluZ3Mgd2l0aCB0aGUgd29yZHMsXG4gICAgICogYW5kIGEgbGlzdCBvZiBgdG9rZW5faWRgIHNlcXVlbmNlcyB3aXRoIHRoZSB0b2tlbnMgbWFraW5nIHVwIGVhY2ggd29yZC5cbiAgICAgKiBAcGFyYW0ge251bWJlcltdfSB0b2tlbnMgXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtsYW5ndWFnZV0gXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByZXBlbmRfcHVuY3Rpb25hdGlvbnMgXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFwcGVuZF9wdW5jdHVhdGlvbnMgXG4gICAgICogXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBjb21iaW5lVG9rZW5zSW50b1dvcmRzKHRva2VucywgbGFuZ3VhZ2UsIHByZXBlbmRfcHVuY3Rpb25hdGlvbnMgPSBcIlxcXCIn4oCcwqHCvyhbey1cIiwgYXBwZW5kX3B1bmN0dWF0aW9ucyA9IFwiXFxcIicu44CCLO+8jCHvvIE/77yfOu+8muKAnSldfeOAgVwiKSB7XG4gICAgICAgIGxhbmd1YWdlID0gbGFuZ3VhZ2UgPz8gJ2VuZ2xpc2gnO1xuXG4gICAgICAgIGxldCB3b3Jkcywgd29yZF90b2tlbnMsIHRva2VuX2luZGljZXM7XG5cbiAgICAgICAgaWYgKFtcImNoaW5lc2VcIiwgXCJqYXBhbmVzZVwiLCBcInRoYWlcIiwgXCJsYW9cIiwgXCJteWFubWFyXCJdLmluY2x1ZGVzKGxhbmd1YWdlKSkge1xuICAgICAgICAgICAgLy8gVGhlc2UgbGFuZ3VhZ2VzIGRvbid0IHR5cGljYWxseSB1c2Ugc3BhY2VzLlxuXG4gICAgICAgICAgICBbd29yZHMsIHdvcmRfdG9rZW5zLCB0b2tlbl9pbmRpY2VzXSA9IHRoaXMuc3BsaXRUb2tlbnNPblVuaWNvZGUodG9rZW5zKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgW3dvcmRzLCB3b3JkX3Rva2VucywgdG9rZW5faW5kaWNlc10gPSB0aGlzLnNwbGl0VG9rZW5zT25TcGFjZXModG9rZW5zKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMubWVyZ2VQdW5jdHVhdGlvbnMod29yZHMsIHdvcmRfdG9rZW5zLCB0b2tlbl9pbmRpY2VzLCBwcmVwZW5kX3B1bmN0aW9uYXRpb25zLCBhcHBlbmRfcHVuY3R1YXRpb25zKTtcbiAgICB9XG5cbiAgICAvKiogQHR5cGUge1ByZVRyYWluZWRUb2tlbml6ZXJbJ2RlY29kZSddfSAqL1xuICAgIGRlY29kZShcbiAgICAgICAgdG9rZW5faWRzLFxuICAgICAgICBkZWNvZGVfYXJncyxcbiAgICApIHtcbiAgICAgICAgbGV0IHRleHQ7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgaWYgKGRlY29kZV9hcmdzICYmIGRlY29kZV9hcmdzLmRlY29kZV93aXRoX3RpbWVzdGFtcHMpIHtcbiAgICAgICAgICAgIHRleHQgPSB0aGlzLmRlY29kZVdpdGhUaW1lc3RhbXBzKHRva2VuX2lkcywgZGVjb2RlX2FyZ3MpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGV4dCA9IHN1cGVyLmRlY29kZSh0b2tlbl9pZHMsIGRlY29kZV9hcmdzKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUT0RPOiBpbXBsZW1lbnQgb2Zmc2V0c1xuICAgICAgICAvLyBpZiAoZGVjb2RlX2FyZ3Mub3V0cHV0X29mZnNldHMpIHtcbiAgICAgICAgLy8gICAgIGxldCBvZmZzZXRzID0gdGhpcy5jb21wdXRlT2Zmc2V0c1xuICAgICAgICAvLyB9XG4gICAgICAgIHJldHVybiB0ZXh0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyW119IHRva2VuX2lkcyBMaXN0IG9mIHRva2VuIElEcyB0byBkZWNvZGUuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRlY29kZV9hcmdzIE9wdGlvbmFsIGFyZ3VtZW50cyBmb3IgZGVjb2RpbmdcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGRlY29kZVdpdGhUaW1lc3RhbXBzKHRva2VuX2lkcywgZGVjb2RlX2FyZ3MpIHtcbiAgICAgICAgY29uc3QgdGltZV9wcmVjaXNpb24gPSBkZWNvZGVfYXJncz8udGltZV9wcmVjaXNpb24gPz8gMC4wMjtcblxuICAgICAgICBjb25zdCB0aW1lc3RhbXBfYmVnaW4gPSBBcnJheS5mcm9tKHRoaXMuYWxsX3NwZWNpYWxfaWRzKS5hdCgtMSkgKyAxO1xuICAgICAgICAvKipAdHlwZSB7QXJyYXl9ICovXG4gICAgICAgIGxldCBvdXRwdXRzID0gW1tdXTtcbiAgICAgICAgZm9yIChsZXQgdG9rZW4gb2YgdG9rZW5faWRzKSB7XG4gICAgICAgICAgICBpZiAodG9rZW4gPj0gdGltZXN0YW1wX2JlZ2luKSB7XG4gICAgICAgICAgICAgICAgbGV0IHRpbWVzdGFtcCA9ICh0b2tlbiAtIHRpbWVzdGFtcF9iZWdpbikgKiB0aW1lX3ByZWNpc2lvbjtcbiAgICAgICAgICAgICAgICB0aW1lc3RhbXAgPSByb3VuZCh0aW1lc3RhbXAsIDIpO1xuICAgICAgICAgICAgICAgIG91dHB1dHMucHVzaChgPHwke3RpbWVzdGFtcH18PmApO1xuICAgICAgICAgICAgICAgIG91dHB1dHMucHVzaChbXSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG91dHB1dHNbb3V0cHV0cy5sZW5ndGggLSAxXS5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBvdXRwdXRzID0gb3V0cHV0cy5tYXAoXG4gICAgICAgICAgICBzID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdXBlci5kZWNvZGUocywgZGVjb2RlX2FyZ3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgKVxuXG4gICAgICAgIHJldHVybiBvdXRwdXRzLmpvaW4oJycpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbWJpbmUgdG9rZW5zIGludG8gd29yZHMgYnkgc3BsaXR0aW5nIGF0IGFueSBwb3NpdGlvbiB3aGVyZSB0aGUgdG9rZW5zIGFyZSBkZWNvZGVkIGFzIHZhbGlkIHVuaWNvZGUgcG9pbnRzLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyW119IHRva2VucyBcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHNwbGl0VG9rZW5zT25Vbmljb2RlKHRva2Vucykge1xuICAgICAgICBjb25zdCBkZWNvZGVkX2Z1bGwgPSB0aGlzLmRlY29kZSh0b2tlbnMsIHtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIGRlY29kZV93aXRoX3RpbWVzdGFtcHM6IHRydWUsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCByZXBsYWNlbWVudF9jaGFyID0gJ1xcdUZGRkQnO1xuXG4gICAgICAgIGxldCB3b3JkcyA9IFtdXG4gICAgICAgIGxldCB3b3JkX3Rva2VucyA9IFtdXG4gICAgICAgIGxldCB0b2tlbl9pbmRpY2VzID0gW11cbiAgICAgICAgbGV0IGN1cnJlbnRfdG9rZW5zID0gW11cbiAgICAgICAgbGV0IGN1cnJlbnRfaW5kaWNlcyA9IFtdXG4gICAgICAgIGxldCB1bmljb2RlX29mZnNldCA9IDBcblxuICAgICAgICBmb3IgKGxldCB0b2tlbl9pZHggPSAwOyB0b2tlbl9pZHggPCB0b2tlbnMubGVuZ3RoOyArK3Rva2VuX2lkeCkge1xuICAgICAgICAgICAgY29uc3QgdG9rZW4gPSB0b2tlbnNbdG9rZW5faWR4XTtcblxuICAgICAgICAgICAgY3VycmVudF90b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICBjdXJyZW50X2luZGljZXMucHVzaCh0b2tlbl9pZHgpO1xuXG4gICAgICAgICAgICBjb25zdCBkZWNvZGVkID0gdGhpcy5kZWNvZGUoY3VycmVudF90b2tlbnMsIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgZGVjb2RlX3dpdGhfdGltZXN0YW1wczogdHJ1ZSxcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAoIWRlY29kZWQuaW5jbHVkZXMocmVwbGFjZW1lbnRfY2hhcikgfHwgZGVjb2RlZF9mdWxsW3VuaWNvZGVfb2Zmc2V0ICsgZGVjb2RlZC5pbmRleE9mKHJlcGxhY2VtZW50X2NoYXIpXSA9PT0gcmVwbGFjZW1lbnRfY2hhcikge1xuICAgICAgICAgICAgICAgIHdvcmRzLnB1c2goZGVjb2RlZClcbiAgICAgICAgICAgICAgICB3b3JkX3Rva2Vucy5wdXNoKGN1cnJlbnRfdG9rZW5zKVxuICAgICAgICAgICAgICAgIHRva2VuX2luZGljZXMucHVzaChjdXJyZW50X2luZGljZXMpXG4gICAgICAgICAgICAgICAgY3VycmVudF90b2tlbnMgPSBbXVxuICAgICAgICAgICAgICAgIGN1cnJlbnRfaW5kaWNlcyA9IFtdXG4gICAgICAgICAgICAgICAgdW5pY29kZV9vZmZzZXQgKz0gZGVjb2RlZC5sZW5ndGg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBbd29yZHMsIHdvcmRfdG9rZW5zLCB0b2tlbl9pbmRpY2VzXVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbWJpbmUgdG9rZW5zIGludG8gd29yZHMgYnkgc3BsaXR0aW5nIGF0IHdoaXRlc3BhY2UgYW5kIHB1bmN0dWF0aW9uIHRva2Vucy5cbiAgICAgKiBAcGFyYW0ge251bWJlcltdfSB0b2tlbnMgXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBzcGxpdFRva2Vuc09uU3BhY2VzKHRva2Vucykge1xuXG4gICAgICAgIGxldCBbc3Vid29yZHMsIHN1YndvcmRfdG9rZW5zX2xpc3QsIHN1YndvcmRfaW5kaWNlc19saXN0XSA9IHRoaXMuc3BsaXRUb2tlbnNPblVuaWNvZGUodG9rZW5zKTtcblxuICAgICAgICBsZXQgd29yZHMgPSBbXVxuICAgICAgICBsZXQgd29yZF90b2tlbnMgPSBbXVxuICAgICAgICBsZXQgdG9rZW5faW5kaWNlcyA9IFtdXG5cbiAgICAgICAgY29uc3QgcHVuY3R1YXRpb25SZWdleCA9IG5ldyBSZWdFeHAoYFske1BVTkNUVUFUSU9OX1JFR0VYfV1gKVxuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3Vid29yZHMubGVuZ3RoOyArK2kpIHtcblxuICAgICAgICAgICAgY29uc3Qgc3Vid29yZCA9IHN1YndvcmRzW2ldO1xuICAgICAgICAgICAgY29uc3Qgc3Vid29yZF90b2tlbnMgPSBzdWJ3b3JkX3Rva2Vuc19saXN0W2ldO1xuICAgICAgICAgICAgY29uc3Qgc3Vid29yZF9pbmRpY2VzID0gc3Vid29yZF9pbmRpY2VzX2xpc3RbaV07XG5cbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIGNvbnN0IHNwZWNpYWwgPSBzdWJ3b3JkX3Rva2Vuc1swXSA+PSB0aGlzLm1vZGVsLnRva2Vuc190b19pZHMuZ2V0KCc8fGVuZG9mdGV4dHw+Jyk7XG4gICAgICAgICAgICBjb25zdCB3aXRoX3NwYWNlID0gc3Vid29yZC5zdGFydHNXaXRoKCcgJyk7XG4gICAgICAgICAgICBjb25zdCB0cmltbWVkID0gc3Vid29yZC50cmltKCk7XG4gICAgICAgICAgICBjb25zdCBwdW5jdHVhdGlvbiA9IHB1bmN0dWF0aW9uUmVnZXgudGVzdCh0cmltbWVkKTtcblxuICAgICAgICAgICAgaWYgKHNwZWNpYWwgfHwgd2l0aF9zcGFjZSB8fCBwdW5jdHVhdGlvbiB8fCB3b3Jkcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICB3b3Jkcy5wdXNoKHN1YndvcmQpO1xuICAgICAgICAgICAgICAgIHdvcmRfdG9rZW5zLnB1c2goc3Vid29yZF90b2tlbnMpO1xuICAgICAgICAgICAgICAgIHRva2VuX2luZGljZXMucHVzaChzdWJ3b3JkX2luZGljZXMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpeCA9IHdvcmRzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgICAgd29yZHNbaXhdICs9IHN1YndvcmQ7XG4gICAgICAgICAgICAgICAgd29yZF90b2tlbnNbaXhdLnB1c2goLi4uc3Vid29yZF90b2tlbnMpO1xuICAgICAgICAgICAgICAgIHRva2VuX2luZGljZXNbaXhdLnB1c2goLi4uc3Vid29yZF9pbmRpY2VzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBbd29yZHMsIHdvcmRfdG9rZW5zLCB0b2tlbl9pbmRpY2VzXTtcblxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1lcmdlcyBwdW5jdHVhdGlvbiB0b2tlbnMgd2l0aCBuZWlnaGJvcmluZyB3b3Jkcy5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSB3b3JkcyBcbiAgICAgKiBAcGFyYW0ge251bWJlcltdW119IHRva2VucyBcbiAgICAgKiBAcGFyYW0ge251bWJlcltdW119IGluZGljZXMgXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByZXBlbmRlZCBcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYXBwZW5kZWQgXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBtZXJnZVB1bmN0dWF0aW9ucyh3b3JkcywgdG9rZW5zLCBpbmRpY2VzLCBwcmVwZW5kZWQsIGFwcGVuZGVkKSB7XG5cbiAgICAgICAgbGV0IG5ld1dvcmRzID0gc3RydWN0dXJlZENsb25lKHdvcmRzKTtcbiAgICAgICAgbGV0IG5ld1Rva2VucyA9IHN0cnVjdHVyZWRDbG9uZSh0b2tlbnMpO1xuICAgICAgICBsZXQgbmV3SW5kaWNlcyA9IHN0cnVjdHVyZWRDbG9uZShpbmRpY2VzKTtcblxuXG4gICAgICAgIC8vIHByZXBlbmQgcHVuY3R1YXRpb25zXG4gICAgICAgIGxldCBpID0gbmV3V29yZHMubGVuZ3RoIC0gMjtcbiAgICAgICAgbGV0IGogPSBuZXdXb3Jkcy5sZW5ndGggLSAxO1xuXG4gICAgICAgIHdoaWxlIChpID49IDApIHtcbiAgICAgICAgICAgIGlmIChuZXdXb3Jkc1tpXS5zdGFydHNXaXRoKCcgJykgJiYgcHJlcGVuZGVkLmluY2x1ZGVzKG5ld1dvcmRzW2ldLnRyaW0oKSkpIHtcbiAgICAgICAgICAgICAgICBuZXdXb3Jkc1tqXSA9IG5ld1dvcmRzW2ldICsgbmV3V29yZHNbal07XG4gICAgICAgICAgICAgICAgbmV3VG9rZW5zW2pdID0gbWVyZ2VBcnJheXMobmV3VG9rZW5zW2ldLCBuZXdUb2tlbnNbal0pO1xuICAgICAgICAgICAgICAgIG5ld0luZGljZXNbal0gPSBtZXJnZUFycmF5cyhuZXdJbmRpY2VzW2ldLCBuZXdJbmRpY2VzW2pdKTtcbiAgICAgICAgICAgICAgICBuZXdXb3Jkc1tpXSA9ICcnO1xuICAgICAgICAgICAgICAgIG5ld1Rva2Vuc1tpXSA9IFtdO1xuICAgICAgICAgICAgICAgIG5ld0luZGljZXNbaV0gPSBbXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaiA9IGk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAtLWk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhcHBlbmQgcHVuY3R1YXRpb25zXG4gICAgICAgIGkgPSAwO1xuICAgICAgICBqID0gMTtcbiAgICAgICAgd2hpbGUgKGogPCBuZXdXb3Jkcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmICghbmV3V29yZHNbaV0uZW5kc1dpdGgoJyAnKSAmJiBhcHBlbmRlZC5pbmNsdWRlcyhuZXdXb3Jkc1tqXSkpIHtcbiAgICAgICAgICAgICAgICBuZXdXb3Jkc1tpXSArPSBuZXdXb3Jkc1tqXTtcbiAgICAgICAgICAgICAgICBuZXdUb2tlbnNbaV0gPSBtZXJnZUFycmF5cyhuZXdUb2tlbnNbaV0sIG5ld1Rva2Vuc1tqXSk7XG4gICAgICAgICAgICAgICAgbmV3SW5kaWNlc1tpXSA9IG1lcmdlQXJyYXlzKG5ld0luZGljZXNbaV0sIG5ld0luZGljZXNbal0pO1xuICAgICAgICAgICAgICAgIG5ld1dvcmRzW2pdID0gJyc7XG4gICAgICAgICAgICAgICAgbmV3VG9rZW5zW2pdID0gW107XG4gICAgICAgICAgICAgICAgbmV3SW5kaWNlc1tqXSA9IFtdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpID0gajtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICsrajtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBuZXdXb3Jkcy5maWx0ZXIoeCA9PiB4KSxcbiAgICAgICAgICAgIG5ld1Rva2Vucy5maWx0ZXIoeCA9PiB4Lmxlbmd0aCA+IDApLFxuICAgICAgICAgICAgbmV3SW5kaWNlcy5maWx0ZXIoeCA9PiB4Lmxlbmd0aCA+IDApLFxuICAgICAgICBdXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGVscGVyIGZ1bmN0aW9uIHRvIGJ1aWxkIHRyYW5zbGF0aW9uIGlucHV0cyBmb3IgYSBgV2hpc3BlclRva2VuaXplcmAsXG4gICAgICogZGVwZW5kaW5nIG9uIHRoZSBsYW5ndWFnZSwgdGFzaywgYW5kIHdoZXRoZXIgdG8gcHJlZGljdCB0aW1lc3RhbXAgdG9rZW5zLlxuICAgICAqIFxuICAgICAqIFVzZWQgdG8gb3ZlcnJpZGUgdGhlIHByZWZpeCB0b2tlbnMgYXBwZW5kZWQgdG8gdGhlIHN0YXJ0IG9mIHRoZSBsYWJlbCBzZXF1ZW5jZS5cbiAgICAgKiBcbiAgICAgKiAqKkV4YW1wbGU6IEdldCBpZHMgZm9yIGEgbGFuZ3VhZ2UqKlxuICAgICAqIGBgYGphdmFzY3JpcHRcbiAgICAgKiAvLyBpbnN0YW50aWF0ZSB0aGUgdG9rZW5pemVyIGFuZCBzZXQgdGhlIHByZWZpeCB0b2tlbiB0byBTcGFuaXNoXG4gICAgICogbGV0IHRva2VuaXplciA9IGF3YWl0IFdoaXNwZXJUb2tlbml6ZXIuZnJvbV9wcmV0cmFpbmVkKCdYZW5vdmEvd2hpc3Blci10aW55Jyk7XG4gICAgICogbGV0IGZvcmNlZF9kZWNvZGVyX2lkcyA9IHRva2VuaXplci5nZXRfZGVjb2Rlcl9wcm9tcHRfaWRzKHsgbGFuZ3VhZ2U6ICdzcGFuaXNoJyB9KTtcbiAgICAgKiAvLyBbKDEsIDUwMjYyKSwgKDIsIDUwMzYzKV1cbiAgICAgKiBgYGBcbiAgICAgKiBcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBPcHRpb25zIHRvIGdlbmVyYXRlIHRoZSBkZWNvZGVyIHByb21wdC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMubGFuZ3VhZ2VdIFRoZSBsYW5ndWFnZSBvZiB0aGUgdHJhbnNjcmlwdGlvbiB0ZXh0LlxuICAgICAqIFRoZSBjb3JyZXNwb25kaW5nIGxhbmd1YWdlIGlkIHRva2VuIGlzIGFwcGVuZGVkIHRvIHRoZSBzdGFydCBvZiB0aGUgc2VxdWVuY2UgZm9yIG11bHRpbGluZ3VhbFxuICAgICAqIHNwZWVjaCByZWNvZ25pdGlvbiBhbmQgc3BlZWNoIHRyYW5zbGF0aW9uIHRhc2tzLCBlLmcuIGZvciBcIlNwYW5pc2hcIiB0aGUgdG9rZW4gXCI8fGVzfD5cIiBpcyBhcHBlbmRlZFxuICAgICAqIHRvIHRoZSBzdGFydCBvZiBzZXF1ZW5jZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMudGFza10gVGFzayBpZGVudGlmaWVyIHRvIGFwcGVuZCBhdCB0aGUgc3RhcnQgb2Ygc2VxdWVuY2UgKGlmIGFueSkuXG4gICAgICogVGhpcyBzaG91bGQgYmUgdXNlZCBmb3IgbXVsaXRsaW5ndWFsIGZpbmUtdHVuaW5nLCB3aXRoIFwidHJhbnNjcmliZVwiIGZvciBzcGVlY2ggcmVjb2duaXRpb24gYW5kXG4gICAgICogXCJ0cmFuc2xhdGVcIiBmb3Igc3BlZWNoIHRyYW5zbGF0aW9uLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMubm9fdGltZXN0YW1wc10gV2hldGhlciB0byBhZGQgdGhlIDx8bm90aW1lc3RhbXBzfD4gdG9rZW4gYXQgdGhlIHN0YXJ0IG9mIHRoZSBzZXF1ZW5jZS5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyW11bXX0gVGhlIGRlY29kZXIgcHJvbXB0IGlkcy5cbiAgICAgKi9cbiAgICBnZXRfZGVjb2Rlcl9wcm9tcHRfaWRzKHtcbiAgICAgICAgbGFuZ3VhZ2UgPSBudWxsLFxuICAgICAgICB0YXNrID0gbnVsbCxcbiAgICAgICAgbm9fdGltZXN0YW1wcyA9IHRydWUsXG4gICAgfSA9IHt9KSB7XG5cbiAgICAgICAgLy8gPHxsYW5nX2lkfD4gPHx0YXNrfD4gPHxub3RpbWVzdGFtcHN8PlxuXG4gICAgICAgIGxldCBmb3JjZWRfZGVjb2Rlcl9pZHMgPSBbXTtcblxuICAgICAgICBpZiAobGFuZ3VhZ2UpIHtcbiAgICAgICAgICAgIC8vIFVzZXIgd2lzaGVzIHRvIHNwZWNpZnkgdGhlIGxhbmd1YWdlXG4gICAgICAgICAgICBsYW5ndWFnZSA9IGxhbmd1YWdlLnRvTG93ZXJDYXNlKCk7XG5cbiAgICAgICAgICAgIC8vIE1hcCB0byBjb2RlIGZyb20gdXNlci1mcmllbmRseSBuYW1lIChlLmcuLCBcImVuZ2xpc2hcIiAtPiBcImVuXCIpXG4gICAgICAgICAgICBsZXQgbGFuZ3VhZ2VfY29kZSA9IFdISVNQRVJfVE9fTEFOR1VBR0VfQ09ERV9NQVBQSU5HLmdldChsYW5ndWFnZSk7XG5cbiAgICAgICAgICAgIGlmIChsYW5ndWFnZV9jb2RlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBVc2VyIHByb3ZpZGVkIHNvbWV0aGluZyB0aGF0IGlzIG5vdCBhIGxhbmd1YWdlIG5hbWVcblxuICAgICAgICAgICAgICAgIGlmIChXSElTUEVSX0xBTkdVQUdFX01BUFBJTkcuaGFzKGxhbmd1YWdlKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBVc2VyIHByb3ZpZGVkIHRoZSBsYW5ndWFnZSBjb2RlIGRpcmVjdGx5IChlLmcuLCBcImVuXCIpXG4gICAgICAgICAgICAgICAgICAgIGxhbmd1YWdlX2NvZGUgPSBsYW5ndWFnZTtcblxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFVzZXIgcHJvdmlkZWQgc29tZXRoaW5nIHRoYXQgaXMgbm90IGEgbGFuZ3VhZ2UgY29kZSBvciBuYW1lXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGlzX2xhbmd1YWdlX2NvZGUgPSBsYW5ndWFnZS5sZW5ndGggPT09IDI7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxhbmdzID0gaXNfbGFuZ3VhZ2VfY29kZSA/IFdISVNQRVJfTEFOR1VBR0VfTUFQUElORy5rZXlzKCkgOiBXSElTUEVSX0xBTkdVQUdFX01BUFBJTkcudmFsdWVzKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBMYW5ndWFnZSBcIiR7bGFuZ3VhZ2V9XCIgaXMgbm90IHN1cHBvcnRlZC4gTXVzdCBiZSBvbmUgb2Y6ICR7SlNPTi5zdHJpbmdpZnkobGFuZ3MpfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV0IGxhbmd1YWdlX3Rva2VuX2lkID0gdGhpcy5tb2RlbC50b2tlbnNfdG9faWRzLmdldChgPHwke2xhbmd1YWdlX2NvZGV9fD5gKTtcbiAgICAgICAgICAgIGlmIChsYW5ndWFnZV90b2tlbl9pZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmFibGUgdG8gZmluZCBsYW5ndWFnZSBcIiR7bGFuZ3VhZ2VfY29kZX1cIiBpbiBtb2RlbCB2b2NhYnVsYXJ5LiBQbGVhc2UgcmVwb3J0IHRoaXMgaXNzdWUgYXQgaHR0cHM6Ly9naXRodWIuY29tL3hlbm92YS90cmFuc2Zvcm1lcnMuanMvaXNzdWVzL25ldy9jaG9vc2UuYClcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yY2VkX2RlY29kZXJfaWRzLnB1c2gobGFuZ3VhZ2VfdG9rZW5faWQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gTm8gdG9rZW4gd2lsbCBiZSBmb3JjZWQsIHdoaWNoIGxlYXZlcyB0aGUgbW9kZWwgdG8gcHJlZGljdCB0aGUgbGFuZ3VhZ2VcbiAgICAgICAgICAgIGZvcmNlZF9kZWNvZGVyX2lkcy5wdXNoKG51bGwpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRhc2spIHtcbiAgICAgICAgICAgIHRhc2sgPSB0YXNrLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICBpZiAodGFzayAhPT0gJ3RyYW5zY3JpYmUnICYmIHRhc2sgIT09ICd0cmFuc2xhdGUnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUYXNrIFwiJHt0YXNrfVwiIGlzIG5vdCBzdXBwb3J0ZWQuIE11c3QgYmUgb25lIG9mOiBbXCJ0cmFuc2NyaWJlXCIsIFwidHJhbnNsYXRlXCJdYCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxldCB0YXNrX3Rva2VuX2lkID0gdGhpcy5tb2RlbC50b2tlbnNfdG9faWRzLmdldChgPHwke3Rhc2t9fD5gKTtcbiAgICAgICAgICAgIGlmICh0YXNrX3Rva2VuX2lkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuYWJsZSB0byBmaW5kIHRhc2sgXCIke3Rhc2t9XCIgaW4gbW9kZWwgdm9jYWJ1bGFyeS4gUGxlYXNlIHJlcG9ydCB0aGlzIGlzc3VlIGF0IGh0dHBzOi8vZ2l0aHViLmNvbS94ZW5vdmEvdHJhbnNmb3JtZXJzLmpzL2lzc3Vlcy9uZXcvY2hvb3NlLmApXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvcmNlZF9kZWNvZGVyX2lkcy5wdXNoKHRhc2tfdG9rZW5faWQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gTm8gdG9rZW4gd2lsbCBiZSBmb3JjZWQsIHdoaWNoIGxlYXZlcyB0aGUgbW9kZWwgdG8gcHJlZGljdCB0aGUgdGFza1xuICAgICAgICAgICAgZm9yY2VkX2RlY29kZXJfaWRzLnB1c2gobnVsbCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobm9fdGltZXN0YW1wcykge1xuICAgICAgICAgICAgbGV0IG5vX3RpbWVzdGFtcHNfaWQgPSB0aGlzLm1vZGVsLnRva2Vuc190b19pZHMuZ2V0KGA8fG5vdGltZXN0YW1wc3w+YCk7XG4gICAgICAgICAgICBpZiAobm9fdGltZXN0YW1wc19pZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gZmluZCBcIjx8bm90aW1lc3RhbXBzfD5cIiBpbiBtb2RlbCB2b2NhYnVsYXJ5LiBQbGVhc2UgcmVwb3J0IHRoaXMgaXNzdWUgYXQgaHR0cHM6Ly9naXRodWIuY29tL3hlbm92YS90cmFuc2Zvcm1lcnMuanMvaXNzdWVzL25ldy9jaG9vc2UuJylcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yY2VkX2RlY29kZXJfaWRzLnB1c2gobm9fdGltZXN0YW1wc19pZCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZm9yY2VkX2RlY29kZXJfaWRzLm1hcCgoeCwgaSkgPT4gW2kgKyAxLCB4XSkuZmlsdGVyKHggPT4geFsxXSAhPT0gbnVsbCk7XG5cbiAgICB9XG59XG5leHBvcnQgY2xhc3MgQ29kZUdlblRva2VuaXplciBleHRlbmRzIFByZVRyYWluZWRUb2tlbml6ZXIgeyB9XG5leHBvcnQgY2xhc3MgQ0xJUFRva2VuaXplciBleHRlbmRzIFByZVRyYWluZWRUb2tlbml6ZXIgeyB9XG5cblxuLyoqXG4gKiBAdG9kbyBUaGlzIG1vZGVsIGlzIG5vdCB5ZXQgc3VwcG9ydGVkIGJ5IEh1Z2dpbmcgRmFjZSdzIFwiZmFzdFwiIHRva2VuaXplcnMgbGlicmFyeSAoaHR0cHM6Ly9naXRodWIuY29tL2h1Z2dpbmdmYWNlL3Rva2VuaXplcnMpLlxuICogVGhlcmVmb3JlLCB0aGlzIGltcGxlbWVudGF0aW9uICh3aGljaCBpcyBiYXNlZCBvbiBmYXN0IHRva2VuaXplcnMpIG1heSBwcm9kdWNlIHNsaWdodGx5IGluYWNjdXJhdGUgcmVzdWx0cy5cbiAqL1xuZXhwb3J0IGNsYXNzIE1hcmlhblRva2VuaXplciBleHRlbmRzIFByZVRyYWluZWRUb2tlbml6ZXIge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBNYXJpYW5Ub2tlbml6ZXIgaW5zdGFuY2UuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHRva2VuaXplckpTT04gVGhlIEpTT04gb2YgdGhlIHRva2VuaXplci5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdG9rZW5pemVyQ29uZmlnIFRoZSBjb25maWcgb2YgdGhlIHRva2VuaXplci5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih0b2tlbml6ZXJKU09OLCB0b2tlbml6ZXJDb25maWcpIHtcbiAgICAgICAgc3VwZXIodG9rZW5pemVySlNPTiwgdG9rZW5pemVyQ29uZmlnKTtcblxuICAgICAgICB0aGlzLmxhbmd1YWdlUmVnZXggPSAvXig+Plxcdys8PClcXHMqL2c7XG5cbiAgICAgICAgdGhpcy5zdXBwb3J0ZWRfbGFuZ3VhZ2VfY29kZXMgPSB0aGlzLm1vZGVsLnZvY2FiLmZpbHRlcihcbiAgICAgICAgICAgIHggPT4gdGhpcy5sYW5ndWFnZVJlZ2V4LnRlc3QoeClcbiAgICAgICAgKTtcblxuICAgICAgICBjb25zb2xlLndhcm4oJ1dBUk5JTkc6IGBNYXJpYW5Ub2tlbml6ZXJgIGlzIG5vdCB5ZXQgc3VwcG9ydGVkIGJ5IEh1Z2dpbmcgRmFjZVxcJ3MgXCJmYXN0XCIgdG9rZW5pemVycyBsaWJyYXJ5LiBUaGVyZWZvcmUsIHlvdSBtYXkgZXhwZXJpZW5jZSBzbGlnaHRseSBpbmFjY3VyYXRlIHJlc3VsdHMuJylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFbmNvZGVzIGEgc2luZ2xlIHRleHQuIE92ZXJyaWRpbmcgdGhpcyBtZXRob2QgaXMgbmVjZXNzYXJ5IHNpbmNlIHRoZSBsYW5ndWFnZSBjb2Rlc1xuICAgICAqIG11c3QgYmUgcmVtb3ZlZCBiZWZvcmUgZW5jb2Rpbmcgd2l0aCBzZW50ZW5jZXBpZWNlIG1vZGVsLlxuICAgICAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2h1Z2dpbmdmYWNlL3RyYW5zZm9ybWVycy9ibG9iLzEyZDUxZGIyNDNhMDA3MjZhNTQ4YTQzY2MzMzMzOTBlYmFlNzMxZTMvc3JjL3RyYW5zZm9ybWVycy9tb2RlbHMvbWFyaWFuL3Rva2VuaXphdGlvbl9tYXJpYW4ucHkjTDIwNC1MMjEzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xudWxsfSB0ZXh0IFRoZSB0ZXh0IHRvIGVuY29kZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFRoZSBlbmNvZGVkIHRva2Vucy5cbiAgICAgKi9cbiAgICBfZW5jb2RlX3RleHQodGV4dCkge1xuICAgICAgICBpZiAodGV4dCA9PT0gbnVsbCkgcmV0dXJuIG51bGw7XG5cbiAgICAgICAgLy8gQ2hlY2sgaWYgdGV4dCBzdGFydHMgd2l0aCBsYW5ndWFnZSBjb2RlOlxuICAgICAgICBsZXQgW21hdGNoSW5mbywgLi4ucmVtYWluZGVyXSA9IHRleHQudHJpbSgpLnNwbGl0KHRoaXMubGFuZ3VhZ2VSZWdleCk7XG5cbiAgICAgICAgaWYgKHJlbWFpbmRlci5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIC8vIE5vIGxhbmd1YWdlIGNvZGUsIGVuY29kZSBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIHN1cGVyLl9lbmNvZGVfdGV4dChtYXRjaEluZm8pO1xuXG4gICAgICAgIH0gZWxzZSBpZiAocmVtYWluZGVyLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgLy8gVGV4dCBzdGFydHMgd2l0aCBsYW5ndWFnZSBjb2RlLCBzbyB3ZSBkbyBub3QgZW5jb2RlIGl0IHdpdGggc2VudGVuY2VwaWVjZS5cbiAgICAgICAgICAgIGxldCBbbGFuZ3VhZ2UsIHRleHRdID0gcmVtYWluZGVyO1xuXG4gICAgICAgICAgICBpZiAoIXRoaXMuc3VwcG9ydGVkX2xhbmd1YWdlX2NvZGVzLmluY2x1ZGVzKGxhbmd1YWdlKSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgVW5zdXBwb3J0ZWQgbGFuZ3VhZ2UgY29kZSBcIiR7bGFuZ3VhZ2V9XCIgZGV0ZWN0ZWQsIHdoaWNoIG1heSBsZWFkIHRvIHVuZXhwZWN0ZWQgYmVoYXZpb3IuIFNob3VsZCBiZSBvbmUgb2Y6ICR7SlNPTi5zdHJpbmdpZnkodGhpcy5zdXBwb3J0ZWRfbGFuZ3VhZ2VfY29kZXMpfWApXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWVyZ2VBcnJheXMoW2xhbmd1YWdlXSwgc3VwZXIuX2VuY29kZV90ZXh0KHRleHQpKTtcbiAgICAgICAgfVxuICAgIH1cblxufVxuXG4vKipcbiAqIEEgdHJpZSBzdHJ1Y3R1cmUgdG8gZWZmaWNpZW50bHkgc3RvcmUgYW5kIHNlYXJjaCBmb3Igc3RyaW5ncy5cbiAqL1xuY2xhc3MgQ2hhclRyaWUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnJvb3QgPSBDaGFyVHJpZU5vZGUuZGVmYXVsdCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZHMgb25lIG9yIG1vcmUgYHRleHRzYCB0byB0aGUgdHJpZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSB0ZXh0cyBUaGUgc3RyaW5ncyB0byBhZGQgdG8gdGhlIHRyaWUuXG4gICAgICovXG4gICAgZXh0ZW5kKHRleHRzKSB7XG4gICAgICAgIGZvciAobGV0IHRleHQgb2YgdGV4dHMpIHtcbiAgICAgICAgICAgIHRoaXMucHVzaCh0ZXh0KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZHMgb25lIG9yIG1vcmUgYHRleHRzYCB0byB0aGUgdHJpZS5cbiAgICAgKiBAcGFyYW0geyp9IHRleHQgVGhlIHN0cmluZ3MgdG8gYWRkIHRvIHRoZSB0cmllLlxuICAgICAqL1xuICAgIHB1c2godGV4dCkge1xuICAgICAgICBsZXQgbm9kZSA9IHRoaXMucm9vdDtcbiAgICAgICAgZm9yIChsZXQgY2ggb2YgdGV4dCkge1xuICAgICAgICAgICAgbGV0IGNoaWxkID0gbm9kZS5jaGlsZHJlbi5nZXQoY2gpO1xuICAgICAgICAgICAgaWYgKGNoaWxkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjaGlsZCA9IENoYXJUcmllTm9kZS5kZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgbm9kZS5jaGlsZHJlbi5zZXQoY2gsIGNoaWxkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5vZGUgPSBjaGlsZDtcbiAgICAgICAgfVxuICAgICAgICBub2RlLmlzTGVhZiA9IHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2VhcmNoZXMgdGhlIHRyaWUgZm9yIGFsbCBzdHJpbmdzIHdpdGggYSBjb21tb24gcHJlZml4IG9mIGB0ZXh0YC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCBUaGUgY29tbW9uIHByZWZpeCB0byBzZWFyY2ggZm9yLlxuICAgICAqIEB5aWVsZHMge3N0cmluZ30gRWFjaCBzdHJpbmcgaW4gdGhlIHRyaWUgdGhhdCBoYXMgYHRleHRgIGFzIGEgcHJlZml4LlxuICAgICAqL1xuICAgICpjb21tb25QcmVmaXhTZWFyY2godGV4dCkge1xuICAgICAgICBsZXQgbm9kZSA9IHRoaXMucm9vdDtcbiAgICAgICAgbGV0IHByZWZpeCA9IFwiXCI7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGV4dC5sZW5ndGggJiYgbm9kZSAhPT0gdW5kZWZpbmVkOyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IGNoID0gdGV4dFtpXTtcbiAgICAgICAgICAgIHByZWZpeCArPSBjaDtcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLmNoaWxkcmVuLmdldChjaCk7XG4gICAgICAgICAgICBpZiAobm9kZSAhPT0gdW5kZWZpbmVkICYmIG5vZGUuaXNMZWFmKSB7XG4gICAgICAgICAgICAgICAgeWllbGQgcHJlZml4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIFJlcHJlc2VudHMgYSBub2RlIGluIGEgY2hhcmFjdGVyIHRyaWUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGlzTGVhZiBXaGV0aGVyIHRoZSBub2RlIGlzIGEgbGVhZiBub2RlIG9yIG5vdC5cbiAqIEBwYXJhbSB7TWFwPHN0cmluZywgQ2hhclRyaWVOb2RlPn0gY2hpbGRyZW4gQSBtYXAgY29udGFpbmluZyB0aGUgbm9kZSdzIGNoaWxkcmVuLCB3aGVyZSB0aGUga2V5IGlzIGEgY2hhcmFjdGVyIGFuZCB0aGUgdmFsdWUgaXMgYSBgQ2hhclRyaWVOb2RlYC5cbiAqL1xuY2xhc3MgQ2hhclRyaWVOb2RlIHtcbiAgICBjb25zdHJ1Y3Rvcihpc0xlYWYsIGNoaWxkcmVuKSB7XG4gICAgICAgIHRoaXMuaXNMZWFmID0gaXNMZWFmO1xuICAgICAgICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIG5ldyBgQ2hhclRyaWVOb2RlYCBpbnN0YW5jZSB3aXRoIGRlZmF1bHQgdmFsdWVzLlxuICAgICAqIEByZXR1cm5zIHtDaGFyVHJpZU5vZGV9IEEgbmV3IGBDaGFyVHJpZU5vZGVgIGluc3RhbmNlIHdpdGggYGlzTGVhZmAgc2V0IHRvIGBmYWxzZWAgYW5kIGFuIGVtcHR5IGBjaGlsZHJlbmAgbWFwLlxuICAgICAqL1xuICAgIHN0YXRpYyBkZWZhdWx0KCkge1xuICAgICAgICByZXR1cm4gbmV3IENoYXJUcmllTm9kZShmYWxzZSwgbmV3IE1hcCgpKTtcbiAgICB9XG59XG5cbmNsYXNzIFRva2VuTGF0dGljZSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBUb2tlbkxhdHRpY2UgaW5zdGFuY2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc2VudGVuY2UgVGhlIGlucHV0IHNlbnRlbmNlIHRvIGJlIHRva2VuaXplZC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYm9zVG9rZW5JZCBUaGUgYmVnaW5uaW5nLW9mLXNlcXVlbmNlIHRva2VuIElELlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBlb3NUb2tlbklkIFRoZSBlbmQtb2Ytc2VxdWVuY2UgdG9rZW4gSUQuXG4gICAgICovXG4gICAgY29uc3RydWN0b3Ioc2VudGVuY2UsIGJvc1Rva2VuSWQsIGVvc1Rva2VuSWQpIHtcbiAgICAgICAgdGhpcy5zZW50ZW5jZSA9IHNlbnRlbmNlO1xuICAgICAgICB0aGlzLmxlbiA9IHNlbnRlbmNlLmxlbmd0aDtcbiAgICAgICAgdGhpcy5ib3NUb2tlbklkID0gYm9zVG9rZW5JZDtcbiAgICAgICAgdGhpcy5lb3NUb2tlbklkID0gZW9zVG9rZW5JZDtcbiAgICAgICAgdGhpcy5ub2RlcyA9IFtdO1xuICAgICAgICB0aGlzLmJlZ2luTm9kZXMgPSBuZXcgQXJyYXkodGhpcy5sZW4gKyAxKTtcbiAgICAgICAgdGhpcy5lbmROb2RlcyA9IG5ldyBBcnJheSh0aGlzLmxlbiArIDEpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubGVuICsgMTsgKytpKSB7XG4gICAgICAgICAgICB0aGlzLmJlZ2luTm9kZXNbaV0gPSBbXTtcbiAgICAgICAgICAgIHRoaXMuZW5kTm9kZXNbaV0gPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBib3MgPSBuZXcgVG9rZW5MYXR0aWNlTm9kZSh0aGlzLmJvc1Rva2VuSWQsIDAsIDAsIDAsIDAuMCk7XG4gICAgICAgIGNvbnN0IGVvcyA9IG5ldyBUb2tlbkxhdHRpY2VOb2RlKHRoaXMuZW9zVG9rZW5JZCwgMSwgdGhpcy5sZW4sIDAsIDAuMCk7XG4gICAgICAgIHRoaXMubm9kZXMucHVzaChib3MuY2xvbmUoKSk7XG4gICAgICAgIHRoaXMubm9kZXMucHVzaChlb3MuY2xvbmUoKSk7XG4gICAgICAgIHRoaXMuYmVnaW5Ob2Rlc1t0aGlzLmxlbl0ucHVzaChlb3MpO1xuICAgICAgICB0aGlzLmVuZE5vZGVzWzBdLnB1c2goYm9zKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbnNlcnRzIGEgbmV3IHRva2VuIG5vZGUgaW50byB0aGUgdG9rZW4gbGF0dGljZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwb3MgVGhlIHN0YXJ0aW5nIHBvc2l0aW9uIG9mIHRoZSB0b2tlbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbGVuZ3RoIFRoZSBsZW5ndGggb2YgdGhlIHRva2VuLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzY29yZSBUaGUgc2NvcmUgb2YgdGhlIHRva2VuLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0b2tlbklkIFRoZSB0b2tlbiBJRCBvZiB0aGUgdG9rZW4uXG4gICAgICovXG4gICAgaW5zZXJ0KHBvcywgbGVuZ3RoLCBzY29yZSwgdG9rZW5JZCkge1xuICAgICAgICBjb25zdCBub2RlSWQgPSB0aGlzLm5vZGVzLmxlbmd0aDtcbiAgICAgICAgY29uc3Qgbm9kZSA9IG5ldyBUb2tlbkxhdHRpY2VOb2RlKHRva2VuSWQsIG5vZGVJZCwgcG9zLCBsZW5ndGgsIHNjb3JlKTtcbiAgICAgICAgdGhpcy5iZWdpbk5vZGVzW3Bvc10ucHVzaChub2RlKTtcbiAgICAgICAgdGhpcy5lbmROb2Rlc1twb3MgKyBsZW5ndGhdLnB1c2gobm9kZSk7XG4gICAgICAgIHRoaXMubm9kZXMucHVzaChub2RlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbXBsZW1lbnRzIHRoZSBWaXRlcmJpIGFsZ29yaXRobSB0byBjb21wdXRlIHRoZSBtb3N0IGxpa2VseSBzZXF1ZW5jZSBvZiB0b2tlbnMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7VG9rZW5MYXR0aWNlTm9kZVtdfSBUaGUgYXJyYXkgb2Ygbm9kZXMgcmVwcmVzZW50aW5nIHRoZSBtb3N0IGxpa2VseSBzZXF1ZW5jZSBvZiB0b2tlbnMuXG4gICAgICovXG4gICAgdml0ZXJiaSgpIHtcbiAgICAgICAgY29uc3QgbGVuID0gdGhpcy5sZW47XG4gICAgICAgIGxldCBwb3MgPSAwO1xuICAgICAgICB3aGlsZSAocG9zIDw9IGxlbikge1xuICAgICAgICAgICAgaWYgKHRoaXMuYmVnaW5Ob2Rlc1twb3NdLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgcm5vZGUgb2YgdGhpcy5iZWdpbk5vZGVzW3Bvc10pIHtcbiAgICAgICAgICAgICAgICBybm9kZS5wcmV2ID0gbnVsbDtcbiAgICAgICAgICAgICAgICBsZXQgYmVzdFNjb3JlID0gMC4wO1xuICAgICAgICAgICAgICAgIGxldCBiZXN0Tm9kZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgbG5vZGUgb2YgdGhpcy5lbmROb2Rlc1twb3NdKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNjb3JlID0gbG5vZGUuYmFja3RyYWNlU2NvcmUgKyBybm9kZS5zY29yZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJlc3ROb2RlID09PSBudWxsIHx8IHNjb3JlID4gYmVzdFNjb3JlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBiZXN0Tm9kZSA9IGxub2RlLmNsb25lKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBiZXN0U2NvcmUgPSBzY29yZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChiZXN0Tm9kZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBybm9kZS5wcmV2ID0gYmVzdE5vZGU7XG4gICAgICAgICAgICAgICAgICAgIHJub2RlLmJhY2t0cmFjZVNjb3JlID0gYmVzdFNjb3JlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICArK3BvcztcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcbiAgICAgICAgY29uc3Qgcm9vdCA9IHRoaXMuYmVnaW5Ob2Rlc1tsZW5dWzBdO1xuICAgICAgICBjb25zdCBwcmV2ID0gcm9vdC5wcmV2O1xuICAgICAgICBpZiAocHJldiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IG5vZGUgPSBwcmV2LmNsb25lKCk7XG4gICAgICAgIHdoaWxlIChub2RlLnByZXYgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaChub2RlLmNsb25lKCkpO1xuICAgICAgICAgICAgY29uc3QgbiA9IG5vZGUuY2xvbmUoKTtcbiAgICAgICAgICAgIG5vZGUgPSBuLnByZXYuY2xvbmUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdHMucmV2ZXJzZSgpO1xuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1Rva2VuTGF0dGljZU5vZGV9IG5vZGVcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgYXJyYXkgb2Ygbm9kZXMgcmVwcmVzZW50aW5nIHRoZSBtb3N0IGxpa2VseSBzZXF1ZW5jZSBvZiB0b2tlbnMuXG4gICAgICovXG4gICAgcGllY2Uobm9kZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZW50ZW5jZS5zbGljZShub2RlLnBvcywgbm9kZS5wb3MgKyBub2RlLmxlbmd0aCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge0FycmF5fSBUaGUgYXJyYXkgb2Ygbm9kZXMgcmVwcmVzZW50aW5nIHRoZSBtb3N0IGxpa2VseSBzZXF1ZW5jZSBvZiB0b2tlbnMuXG4gICAgICovXG4gICAgdG9rZW5zKCkge1xuICAgICAgICBjb25zdCBub2RlcyA9IHRoaXMudml0ZXJiaSgpO1xuICAgICAgICByZXR1cm4gbm9kZXMubWFwKHggPT4gdGhpcy5waWVjZSh4KSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge0FycmF5fSBUaGUgYXJyYXkgb2Ygbm9kZXMgcmVwcmVzZW50aW5nIHRoZSBtb3N0IGxpa2VseSBzZXF1ZW5jZSBvZiB0b2tlbnMuXG4gICAgICovXG4gICAgdG9rZW5JZHMoKSB7XG4gICAgICAgIGNvbnN0IG5vZGVzID0gdGhpcy52aXRlcmJpKCk7XG4gICAgICAgIHJldHVybiBub2Rlcy5tYXAoeCA9PiB4LnRva2VuSWQpO1xuICAgIH1cbn1cbmNsYXNzIFRva2VuTGF0dGljZU5vZGUge1xuICAgIC8qKlxuICAgICAqIFJlcHJlc2VudHMgYSBub2RlIGluIGEgdG9rZW4gbGF0dGljZSBmb3IgYSBnaXZlbiBzZW50ZW5jZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdG9rZW5JZCBUaGUgSUQgb2YgdGhlIHRva2VuIGFzc29jaWF0ZWQgd2l0aCB0aGlzIG5vZGUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG5vZGVJZCBUaGUgSUQgb2YgdGhpcyBub2RlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwb3MgVGhlIHN0YXJ0aW5nIHBvc2l0aW9uIG9mIHRoZSB0b2tlbiBpbiB0aGUgc2VudGVuY2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxlbmd0aCBUaGUgbGVuZ3RoIG9mIHRoZSB0b2tlbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc2NvcmUgVGhlIHNjb3JlIGFzc29jaWF0ZWQgd2l0aCB0aGUgdG9rZW4uXG4gICAgICovXG4gICAgY29uc3RydWN0b3IodG9rZW5JZCwgbm9kZUlkLCBwb3MsIGxlbmd0aCwgc2NvcmUpIHtcbiAgICAgICAgdGhpcy50b2tlbklkID0gdG9rZW5JZDtcbiAgICAgICAgdGhpcy5ub2RlSWQgPSBub2RlSWQ7XG4gICAgICAgIHRoaXMucG9zID0gcG9zO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IGxlbmd0aDtcbiAgICAgICAgdGhpcy5zY29yZSA9IHNjb3JlO1xuICAgICAgICB0aGlzLnByZXYgPSBudWxsO1xuICAgICAgICB0aGlzLmJhY2t0cmFjZVNjb3JlID0gMC4wO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBjbG9uZSBvZiB0aGlzIG5vZGUuXG4gICAgICogQHJldHVybnMge1Rva2VuTGF0dGljZU5vZGV9IEEgY2xvbmUgb2YgdGhpcyBub2RlLlxuICAgICAqL1xuICAgIGNsb25lKCkge1xuICAgICAgICBjb25zdCBuID0gbmV3IFRva2VuTGF0dGljZU5vZGUodGhpcy50b2tlbklkLCB0aGlzLm5vZGVJZCwgdGhpcy5wb3MsIHRoaXMubGVuZ3RoLCB0aGlzLnNjb3JlKTtcbiAgICAgICAgbi5wcmV2ID0gdGhpcy5wcmV2O1xuICAgICAgICBuLmJhY2t0cmFjZVNjb3JlID0gdGhpcy5iYWNrdHJhY2VTY29yZTtcbiAgICAgICAgcmV0dXJuIG47XG4gICAgfVxufVxuXG4vKipcbiAqIEhlbHBlciBjbGFzcyB3aGljaCBpcyB1c2VkIHRvIGluc3RhbnRpYXRlIHByZXRyYWluZWQgdG9rZW5pemVycyB3aXRoIHRoZSBgZnJvbV9wcmV0cmFpbmVkYCBmdW5jdGlvbi5cbiAqIFRoZSBjaG9zZW4gdG9rZW5pemVyIGNsYXNzIGlzIGRldGVybWluZWQgYnkgdGhlIHR5cGUgc3BlY2lmaWVkIGluIHRoZSB0b2tlbml6ZXIgY29uZmlnLlxuICogXG4gKiBAZXhhbXBsZVxuICogbGV0IHRva2VuaXplciA9IGF3YWl0IEF1dG9Ub2tlbml6ZXIuZnJvbV9wcmV0cmFpbmVkKCdiZXJ0LWJhc2UtdW5jYXNlZCcpO1xuICovXG5leHBvcnQgY2xhc3MgQXV0b1Rva2VuaXplciB7XG4gICAgc3RhdGljIFRPS0VOSVpFUl9DTEFTU19NQVBQSU5HID0ge1xuICAgICAgICAnVDVUb2tlbml6ZXInOiBUNVRva2VuaXplcixcbiAgICAgICAgJ0Rpc3RpbEJlcnRUb2tlbml6ZXInOiBEaXN0aWxCZXJ0VG9rZW5pemVyLFxuICAgICAgICAnQmVydFRva2VuaXplcic6IEJlcnRUb2tlbml6ZXIsXG4gICAgICAgICdNb2JpbGVCZXJ0VG9rZW5pemVyJzogTW9iaWxlQmVydFRva2VuaXplcixcbiAgICAgICAgJ1NxdWVlemVCZXJ0VG9rZW5pemVyJzogU3F1ZWV6ZUJlcnRUb2tlbml6ZXIsXG4gICAgICAgICdBbGJlcnRUb2tlbml6ZXInOiBBbGJlcnRUb2tlbml6ZXIsXG4gICAgICAgICdHUFQyVG9rZW5pemVyJzogR1BUMlRva2VuaXplcixcbiAgICAgICAgJ0JhcnRUb2tlbml6ZXInOiBCYXJ0VG9rZW5pemVyLFxuICAgICAgICAnUm9iZXJ0YVRva2VuaXplcic6IFJvYmVydGFUb2tlbml6ZXIsXG4gICAgICAgICdXaGlzcGVyVG9rZW5pemVyJzogV2hpc3BlclRva2VuaXplcixcbiAgICAgICAgJ0NvZGVHZW5Ub2tlbml6ZXInOiBDb2RlR2VuVG9rZW5pemVyLFxuICAgICAgICAnQ0xJUFRva2VuaXplcic6IENMSVBUb2tlbml6ZXIsXG4gICAgICAgICdNYXJpYW5Ub2tlbml6ZXInOiBNYXJpYW5Ub2tlbml6ZXIsXG4gICAgICAgICdCbG9vbVRva2VuaXplcic6IEJsb29tVG9rZW5pemVyLFxuICAgICAgICAnTmxsYlRva2VuaXplcic6IE5sbGJUb2tlbml6ZXIsXG4gICAgICAgICdMbGFtYVRva2VuaXplcic6IExsYW1hVG9rZW5pemVyLFxuICAgICAgICAnWExNUm9iZXJ0YVRva2VuaXplcic6IFhMTVJvYmVydGFUb2tlbml6ZXIsXG4gICAgICAgICdNUE5ldFRva2VuaXplcic6IE1QTmV0VG9rZW5pemVyLFxuICAgICAgICAnRmFsY29uVG9rZW5pemVyJzogRmFsY29uVG9rZW5pemVyLFxuICAgICAgICAnR1BUTmVvWFRva2VuaXplcic6IEdQVE5lb1hUb2tlbml6ZXIsXG5cbiAgICAgICAgLy8gQmFzZSBjYXNlOlxuICAgICAgICAnUHJlVHJhaW5lZFRva2VuaXplcic6IFByZVRyYWluZWRUb2tlbml6ZXIsXG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBJbnN0YW50aWF0ZSBvbmUgb2YgdGhlIHRva2VuaXplciBjbGFzc2VzIG9mIHRoZSBsaWJyYXJ5IGZyb20gYSBwcmV0cmFpbmVkIG1vZGVsLlxuICAgICAqIFxuICAgICAqIFRoZSB0b2tlbml6ZXIgY2xhc3MgdG8gaW5zdGFudGlhdGUgaXMgc2VsZWN0ZWQgYmFzZWQgb24gdGhlIGB0b2tlbml6ZXJfY2xhc3NgIHByb3BlcnR5IG9mIHRoZSBjb25maWcgb2JqZWN0XG4gICAgICogKGVpdGhlciBwYXNzZWQgYXMgYW4gYXJndW1lbnQgb3IgbG9hZGVkIGZyb20gYHByZXRyYWluZWRfbW9kZWxfbmFtZV9vcl9wYXRoYCBpZiBwb3NzaWJsZSlcbiAgICAgKiBcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJldHJhaW5lZF9tb2RlbF9uYW1lX29yX3BhdGggVGhlIG5hbWUgb3IgcGF0aCBvZiB0aGUgcHJldHJhaW5lZCBtb2RlbC4gQ2FuIGJlIGVpdGhlcjpcbiAgICAgKiAtIEEgc3RyaW5nLCB0aGUgKm1vZGVsIGlkKiBvZiBhIHByZXRyYWluZWQgdG9rZW5pemVyIGhvc3RlZCBpbnNpZGUgYSBtb2RlbCByZXBvIG9uIGh1Z2dpbmdmYWNlLmNvLlxuICAgICAqICAgVmFsaWQgbW9kZWwgaWRzIGNhbiBiZSBsb2NhdGVkIGF0IHRoZSByb290LWxldmVsLCBsaWtlIGBiZXJ0LWJhc2UtdW5jYXNlZGAsIG9yIG5hbWVzcGFjZWQgdW5kZXIgYVxuICAgICAqICAgdXNlciBvciBvcmdhbml6YXRpb24gbmFtZSwgbGlrZSBgZGJtZHovYmVydC1iYXNlLWdlcm1hbi1jYXNlZGAuXG4gICAgICogLSBBIHBhdGggdG8gYSAqZGlyZWN0b3J5KiBjb250YWluaW5nIHRva2VuaXplciBmaWxlcywgZS5nLiwgYC4vbXlfbW9kZWxfZGlyZWN0b3J5L2AuXG4gICAgICogQHBhcmFtIHtQcmV0cmFpbmVkT3B0aW9uc30gb3B0aW9ucyBBZGRpdGlvbmFsIG9wdGlvbnMgZm9yIGxvYWRpbmcgdGhlIHRva2VuaXplci5cbiAgICAgKiBcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxQcmVUcmFpbmVkVG9rZW5pemVyPn0gQSBuZXcgaW5zdGFuY2Ugb2YgdGhlIFByZVRyYWluZWRUb2tlbml6ZXIgY2xhc3MuXG4gICAgICovXG4gICAgc3RhdGljIGFzeW5jIGZyb21fcHJldHJhaW5lZChwcmV0cmFpbmVkX21vZGVsX25hbWVfb3JfcGF0aCwge1xuICAgICAgICBxdWFudGl6ZWQgPSB0cnVlLFxuICAgICAgICBwcm9ncmVzc19jYWxsYmFjayA9IG51bGwsXG4gICAgICAgIGNvbmZpZyA9IG51bGwsXG4gICAgICAgIGNhY2hlX2RpciA9IG51bGwsXG4gICAgICAgIGxvY2FsX2ZpbGVzX29ubHkgPSBmYWxzZSxcbiAgICAgICAgcmV2aXNpb24gPSAnbWFpbicsXG4gICAgfSA9IHt9KSB7XG5cbiAgICAgICAgbGV0IFt0b2tlbml6ZXJKU09OLCB0b2tlbml6ZXJDb25maWddID0gYXdhaXQgbG9hZFRva2VuaXplcihwcmV0cmFpbmVkX21vZGVsX25hbWVfb3JfcGF0aCwge1xuICAgICAgICAgICAgcXVhbnRpemVkLFxuICAgICAgICAgICAgcHJvZ3Jlc3NfY2FsbGJhY2ssXG4gICAgICAgICAgICBjb25maWcsXG4gICAgICAgICAgICBjYWNoZV9kaXIsXG4gICAgICAgICAgICBsb2NhbF9maWxlc19vbmx5LFxuICAgICAgICAgICAgcmV2aXNpb24sXG4gICAgICAgIH0pXG5cbiAgICAgICAgLy8gU29tZSB0b2tlbml6ZXJzIGFyZSBzYXZlZCB3aXRoIHRoZSBcIkZhc3RcIiBzdWZmaXgsIHNvIHdlIHJlbW92ZSB0aGF0IGlmIHByZXNlbnQuXG4gICAgICAgIGxldCB0b2tlbml6ZXJOYW1lID0gdG9rZW5pemVyQ29uZmlnLnRva2VuaXplcl9jbGFzcy5yZXBsYWNlKC9GYXN0JC8sICcnKTtcblxuICAgICAgICBsZXQgY2xzID0gdGhpcy5UT0tFTklaRVJfQ0xBU1NfTUFQUElOR1t0b2tlbml6ZXJOYW1lXTtcbiAgICAgICAgaWYgKCFjbHMpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgVW5rbm93biB0b2tlbml6ZXIgY2xhc3MgXCIke3Rva2VuaXplck5hbWV9XCIsIGF0dGVtcHRpbmcgdG8gY29uc3RydWN0IGZyb20gYmFzZSBjbGFzcy5gKTtcbiAgICAgICAgICAgIGNscyA9IFByZVRyYWluZWRUb2tlbml6ZXI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBjbHModG9rZW5pemVySlNPTiwgdG9rZW5pemVyQ29uZmlnKTtcbiAgICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@xenova/transformers/src/tokenizers.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@xenova/transformers/src/transformers.js":
/*!***************************************************************!*\
  !*** ./node_modules/@xenova/transformers/src/transformers.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AlbertForMaskedLM: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.AlbertForMaskedLM),\n/* harmony export */   AlbertForQuestionAnswering: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.AlbertForQuestionAnswering),\n/* harmony export */   AlbertForSequenceClassification: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.AlbertForSequenceClassification),\n/* harmony export */   AlbertModel: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.AlbertModel),\n/* harmony export */   AlbertPreTrainedModel: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.AlbertPreTrainedModel),\n/* harmony export */   AlbertTokenizer: () => (/* reexport safe */ _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.AlbertTokenizer),\n/* harmony export */   AutoConfig: () => (/* reexport safe */ _configs_js__WEBPACK_IMPORTED_MODULE_5__.AutoConfig),\n/* harmony export */   AutoModel: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.AutoModel),\n/* harmony export */   AutoModelForCausalLM: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.AutoModelForCausalLM),\n/* harmony export */   AutoModelForImageClassification: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.AutoModelForImageClassification),\n/* harmony export */   AutoModelForImageSegmentation: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.AutoModelForImageSegmentation),\n/* harmony export */   AutoModelForMaskGeneration: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.AutoModelForMaskGeneration),\n/* harmony export */   AutoModelForMaskedLM: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.AutoModelForMaskedLM),\n/* harmony export */   AutoModelForObjectDetection: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.AutoModelForObjectDetection),\n/* harmony export */   AutoModelForQuestionAnswering: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.AutoModelForQuestionAnswering),\n/* harmony export */   AutoModelForSeq2SeqLM: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.AutoModelForSeq2SeqLM),\n/* harmony export */   AutoModelForSequenceClassification: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.AutoModelForSequenceClassification),\n/* harmony export */   AutoModelForTokenClassification: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.AutoModelForTokenClassification),\n/* harmony export */   AutoModelForVision2Seq: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.AutoModelForVision2Seq),\n/* harmony export */   AutoProcessor: () => (/* reexport safe */ _processors_js__WEBPACK_IMPORTED_MODULE_4__.AutoProcessor),\n/* harmony export */   AutoTokenizer: () => (/* reexport safe */ _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.AutoTokenizer),\n/* harmony export */   AutomaticSpeechRecognitionPipeline: () => (/* reexport safe */ _pipelines_js__WEBPACK_IMPORTED_MODULE_0__.AutomaticSpeechRecognitionPipeline),\n/* harmony export */   BartForConditionalGeneration: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.BartForConditionalGeneration),\n/* harmony export */   BartForSequenceClassification: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.BartForSequenceClassification),\n/* harmony export */   BartModel: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.BartModel),\n/* harmony export */   BartPretrainedModel: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.BartPretrainedModel),\n/* harmony export */   BartTokenizer: () => (/* reexport safe */ _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.BartTokenizer),\n/* harmony export */   BaseModelOutput: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.BaseModelOutput),\n/* harmony export */   BertForMaskedLM: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.BertForMaskedLM),\n/* harmony export */   BertForQuestionAnswering: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.BertForQuestionAnswering),\n/* harmony export */   BertForSequenceClassification: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.BertForSequenceClassification),\n/* harmony export */   BertForTokenClassification: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.BertForTokenClassification),\n/* harmony export */   BertModel: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.BertModel),\n/* harmony export */   BertPreTrainedModel: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.BertPreTrainedModel),\n/* harmony export */   BertTokenizer: () => (/* reexport safe */ _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.BertTokenizer),\n/* harmony export */   BloomTokenizer: () => (/* reexport safe */ _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.BloomTokenizer),\n/* harmony export */   CLIPModel: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.CLIPModel),\n/* harmony export */   CLIPPreTrainedModel: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.CLIPPreTrainedModel),\n/* harmony export */   CLIPTokenizer: () => (/* reexport safe */ _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.CLIPTokenizer),\n/* harmony export */   CausalLMOutputWithPast: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.CausalLMOutputWithPast),\n/* harmony export */   CodeGenForCausalLM: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.CodeGenForCausalLM),\n/* harmony export */   CodeGenModel: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.CodeGenModel),\n/* harmony export */   CodeGenPreTrainedModel: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.CodeGenPreTrainedModel),\n/* harmony export */   CodeGenTokenizer: () => (/* reexport safe */ _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.CodeGenTokenizer),\n/* harmony export */   DetrFeatureExtractor: () => (/* reexport safe */ _processors_js__WEBPACK_IMPORTED_MODULE_4__.DetrFeatureExtractor),\n/* harmony export */   DetrForObjectDetection: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.DetrForObjectDetection),\n/* harmony export */   DetrForSegmentation: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.DetrForSegmentation),\n/* harmony export */   DetrObjectDetectionOutput: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.DetrObjectDetectionOutput),\n/* harmony export */   DetrPreTrainedModel: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.DetrPreTrainedModel),\n/* harmony export */   DetrSegmentationOutput: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.DetrSegmentationOutput),\n/* harmony export */   DistilBertForMaskedLM: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.DistilBertForMaskedLM),\n/* harmony export */   DistilBertForQuestionAnswering: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.DistilBertForQuestionAnswering),\n/* harmony export */   DistilBertForSequenceClassification: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.DistilBertForSequenceClassification),\n/* harmony export */   DistilBertForTokenClassification: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.DistilBertForTokenClassification),\n/* harmony export */   DistilBertModel: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.DistilBertModel),\n/* harmony export */   DistilBertPreTrainedModel: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.DistilBertPreTrainedModel),\n/* harmony export */   DistilBertTokenizer: () => (/* reexport safe */ _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.DistilBertTokenizer),\n/* harmony export */   FFT: () => (/* reexport safe */ _utils_maths_js__WEBPACK_IMPORTED_MODULE_9__.FFT),\n/* harmony export */   FalconTokenizer: () => (/* reexport safe */ _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.FalconTokenizer),\n/* harmony export */   FeatureExtractionPipeline: () => (/* reexport safe */ _pipelines_js__WEBPACK_IMPORTED_MODULE_0__.FeatureExtractionPipeline),\n/* harmony export */   FeatureExtractor: () => (/* reexport safe */ _processors_js__WEBPACK_IMPORTED_MODULE_4__.FeatureExtractor),\n/* harmony export */   FillMaskPipeline: () => (/* reexport safe */ _pipelines_js__WEBPACK_IMPORTED_MODULE_0__.FillMaskPipeline),\n/* harmony export */   GPT2LMHeadModel: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.GPT2LMHeadModel),\n/* harmony export */   GPT2Model: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.GPT2Model),\n/* harmony export */   GPT2PreTrainedModel: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.GPT2PreTrainedModel),\n/* harmony export */   GPT2Tokenizer: () => (/* reexport safe */ _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.GPT2Tokenizer),\n/* harmony export */   GPTNeoForCausalLM: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.GPTNeoForCausalLM),\n/* harmony export */   GPTNeoModel: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.GPTNeoModel),\n/* harmony export */   GPTNeoPreTrainedModel: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.GPTNeoPreTrainedModel),\n/* harmony export */   GPTNeoXTokenizer: () => (/* reexport safe */ _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.GPTNeoXTokenizer),\n/* harmony export */   ImageClassificationPipeline: () => (/* reexport safe */ _pipelines_js__WEBPACK_IMPORTED_MODULE_0__.ImageClassificationPipeline),\n/* harmony export */   ImageFeatureExtractor: () => (/* reexport safe */ _processors_js__WEBPACK_IMPORTED_MODULE_4__.ImageFeatureExtractor),\n/* harmony export */   ImageSegmentationPipeline: () => (/* reexport safe */ _pipelines_js__WEBPACK_IMPORTED_MODULE_0__.ImageSegmentationPipeline),\n/* harmony export */   ImageToTextPipeline: () => (/* reexport safe */ _pipelines_js__WEBPACK_IMPORTED_MODULE_0__.ImageToTextPipeline),\n/* harmony export */   LlamaTokenizer: () => (/* reexport safe */ _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.LlamaTokenizer),\n/* harmony export */   M2M100ForConditionalGeneration: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.M2M100ForConditionalGeneration),\n/* harmony export */   M2M100Model: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.M2M100Model),\n/* harmony export */   M2M100PreTrainedModel: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.M2M100PreTrainedModel),\n/* harmony export */   MPNetTokenizer: () => (/* reexport safe */ _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.MPNetTokenizer),\n/* harmony export */   MT5ForConditionalGeneration: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.MT5ForConditionalGeneration),\n/* harmony export */   MT5Model: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.MT5Model),\n/* harmony export */   MT5PreTrainedModel: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.MT5PreTrainedModel),\n/* harmony export */   MarianMTModel: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.MarianMTModel),\n/* harmony export */   MarianModel: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.MarianModel),\n/* harmony export */   MarianPreTrainedModel: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.MarianPreTrainedModel),\n/* harmony export */   MarianTokenizer: () => (/* reexport safe */ _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.MarianTokenizer),\n/* harmony export */   MaskedLMOutput: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.MaskedLMOutput),\n/* harmony export */   MobileBertForMaskedLM: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.MobileBertForMaskedLM),\n/* harmony export */   MobileBertForQuestionAnswering: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.MobileBertForQuestionAnswering),\n/* harmony export */   MobileBertForSequenceClassification: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.MobileBertForSequenceClassification),\n/* harmony export */   MobileBertModel: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.MobileBertModel),\n/* harmony export */   MobileBertPreTrainedModel: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.MobileBertPreTrainedModel),\n/* harmony export */   MobileBertTokenizer: () => (/* reexport safe */ _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.MobileBertTokenizer),\n/* harmony export */   MobileViTFeatureExtractor: () => (/* reexport safe */ _processors_js__WEBPACK_IMPORTED_MODULE_4__.MobileViTFeatureExtractor),\n/* harmony export */   MobileViTForImageClassification: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.MobileViTForImageClassification),\n/* harmony export */   MobileViTPreTrainedModel: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.MobileViTPreTrainedModel),\n/* harmony export */   ModelOutput: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.ModelOutput),\n/* harmony export */   NllbTokenizer: () => (/* reexport safe */ _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.NllbTokenizer),\n/* harmony export */   ObjectDetectionPipeline: () => (/* reexport safe */ _pipelines_js__WEBPACK_IMPORTED_MODULE_0__.ObjectDetectionPipeline),\n/* harmony export */   Pipeline: () => (/* reexport safe */ _pipelines_js__WEBPACK_IMPORTED_MODULE_0__.Pipeline),\n/* harmony export */   PreTrainedModel: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.PreTrainedModel),\n/* harmony export */   PreTrainedTokenizer: () => (/* reexport safe */ _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.PreTrainedTokenizer),\n/* harmony export */   PretrainedConfig: () => (/* reexport safe */ _configs_js__WEBPACK_IMPORTED_MODULE_5__.PretrainedConfig),\n/* harmony export */   PretrainedMixin: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.PretrainedMixin),\n/* harmony export */   Processor: () => (/* reexport safe */ _processors_js__WEBPACK_IMPORTED_MODULE_4__.Processor),\n/* harmony export */   QuestionAnsweringModelOutput: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.QuestionAnsweringModelOutput),\n/* harmony export */   QuestionAnsweringPipeline: () => (/* reexport safe */ _pipelines_js__WEBPACK_IMPORTED_MODULE_0__.QuestionAnsweringPipeline),\n/* harmony export */   RawImage: () => (/* reexport safe */ _utils_image_js__WEBPACK_IMPORTED_MODULE_7__.RawImage),\n/* harmony export */   RobertaForMaskedLM: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.RobertaForMaskedLM),\n/* harmony export */   RobertaForQuestionAnswering: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.RobertaForQuestionAnswering),\n/* harmony export */   RobertaForSequenceClassification: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.RobertaForSequenceClassification),\n/* harmony export */   RobertaForTokenClassification: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.RobertaForTokenClassification),\n/* harmony export */   RobertaModel: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.RobertaModel),\n/* harmony export */   RobertaPreTrainedModel: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.RobertaPreTrainedModel),\n/* harmony export */   RobertaTokenizer: () => (/* reexport safe */ _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.RobertaTokenizer),\n/* harmony export */   SamImageProcessor: () => (/* reexport safe */ _processors_js__WEBPACK_IMPORTED_MODULE_4__.SamImageProcessor),\n/* harmony export */   SamImageSegmentationOutput: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.SamImageSegmentationOutput),\n/* harmony export */   SamModel: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.SamModel),\n/* harmony export */   SamPreTrainedModel: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.SamPreTrainedModel),\n/* harmony export */   SamProcessor: () => (/* reexport safe */ _processors_js__WEBPACK_IMPORTED_MODULE_4__.SamProcessor),\n/* harmony export */   Seq2SeqLMOutput: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.Seq2SeqLMOutput),\n/* harmony export */   SequenceClassifierOutput: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.SequenceClassifierOutput),\n/* harmony export */   SqueezeBertForMaskedLM: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.SqueezeBertForMaskedLM),\n/* harmony export */   SqueezeBertForQuestionAnswering: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.SqueezeBertForQuestionAnswering),\n/* harmony export */   SqueezeBertForSequenceClassification: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.SqueezeBertForSequenceClassification),\n/* harmony export */   SqueezeBertModel: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.SqueezeBertModel),\n/* harmony export */   SqueezeBertPreTrainedModel: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.SqueezeBertPreTrainedModel),\n/* harmony export */   SqueezeBertTokenizer: () => (/* reexport safe */ _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.SqueezeBertTokenizer),\n/* harmony export */   SummarizationPipeline: () => (/* reexport safe */ _pipelines_js__WEBPACK_IMPORTED_MODULE_0__.SummarizationPipeline),\n/* harmony export */   T5ForConditionalGeneration: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.T5ForConditionalGeneration),\n/* harmony export */   T5Model: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.T5Model),\n/* harmony export */   T5PreTrainedModel: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.T5PreTrainedModel),\n/* harmony export */   T5Tokenizer: () => (/* reexport safe */ _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.T5Tokenizer),\n/* harmony export */   Tensor: () => (/* reexport safe */ _utils_tensor_js__WEBPACK_IMPORTED_MODULE_8__.Tensor),\n/* harmony export */   Text2TextGenerationPipeline: () => (/* reexport safe */ _pipelines_js__WEBPACK_IMPORTED_MODULE_0__.Text2TextGenerationPipeline),\n/* harmony export */   TextClassificationPipeline: () => (/* reexport safe */ _pipelines_js__WEBPACK_IMPORTED_MODULE_0__.TextClassificationPipeline),\n/* harmony export */   TextGenerationPipeline: () => (/* reexport safe */ _pipelines_js__WEBPACK_IMPORTED_MODULE_0__.TextGenerationPipeline),\n/* harmony export */   TokenClassificationPipeline: () => (/* reexport safe */ _pipelines_js__WEBPACK_IMPORTED_MODULE_0__.TokenClassificationPipeline),\n/* harmony export */   TokenClassifierOutput: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.TokenClassifierOutput),\n/* harmony export */   TokenizerModel: () => (/* reexport safe */ _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.TokenizerModel),\n/* harmony export */   TranslationPipeline: () => (/* reexport safe */ _pipelines_js__WEBPACK_IMPORTED_MODULE_0__.TranslationPipeline),\n/* harmony export */   ViTFeatureExtractor: () => (/* reexport safe */ _processors_js__WEBPACK_IMPORTED_MODULE_4__.ViTFeatureExtractor),\n/* harmony export */   ViTForImageClassification: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.ViTForImageClassification),\n/* harmony export */   ViTPreTrainedModel: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.ViTPreTrainedModel),\n/* harmony export */   VisionEncoderDecoderModel: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.VisionEncoderDecoderModel),\n/* harmony export */   WhisperFeatureExtractor: () => (/* reexport safe */ _processors_js__WEBPACK_IMPORTED_MODULE_4__.WhisperFeatureExtractor),\n/* harmony export */   WhisperForConditionalGeneration: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.WhisperForConditionalGeneration),\n/* harmony export */   WhisperModel: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.WhisperModel),\n/* harmony export */   WhisperPreTrainedModel: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.WhisperPreTrainedModel),\n/* harmony export */   WhisperProcessor: () => (/* reexport safe */ _processors_js__WEBPACK_IMPORTED_MODULE_4__.WhisperProcessor),\n/* harmony export */   WhisperTokenizer: () => (/* reexport safe */ _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.WhisperTokenizer),\n/* harmony export */   XLMRobertaForMaskedLM: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.XLMRobertaForMaskedLM),\n/* harmony export */   XLMRobertaForQuestionAnswering: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.XLMRobertaForQuestionAnswering),\n/* harmony export */   XLMRobertaForSequenceClassification: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.XLMRobertaForSequenceClassification),\n/* harmony export */   XLMRobertaForTokenClassification: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.XLMRobertaForTokenClassification),\n/* harmony export */   XLMRobertaModel: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.XLMRobertaModel),\n/* harmony export */   XLMRobertaPreTrainedModel: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.XLMRobertaPreTrainedModel),\n/* harmony export */   XLMRobertaTokenizer: () => (/* reexport safe */ _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.XLMRobertaTokenizer),\n/* harmony export */   ZeroShotClassificationPipeline: () => (/* reexport safe */ _pipelines_js__WEBPACK_IMPORTED_MODULE_0__.ZeroShotClassificationPipeline),\n/* harmony export */   ZeroShotImageClassificationPipeline: () => (/* reexport safe */ _pipelines_js__WEBPACK_IMPORTED_MODULE_0__.ZeroShotImageClassificationPipeline),\n/* harmony export */   cat: () => (/* reexport safe */ _utils_tensor_js__WEBPACK_IMPORTED_MODULE_8__.cat),\n/* harmony export */   cos_sim: () => (/* reexport safe */ _utils_maths_js__WEBPACK_IMPORTED_MODULE_9__.cos_sim),\n/* harmony export */   dot: () => (/* reexport safe */ _utils_maths_js__WEBPACK_IMPORTED_MODULE_9__.dot),\n/* harmony export */   dynamicTimeWarping: () => (/* reexport safe */ _utils_tensor_js__WEBPACK_IMPORTED_MODULE_8__.dynamicTimeWarping),\n/* harmony export */   env: () => (/* reexport safe */ _env_js__WEBPACK_IMPORTED_MODULE_1__.env),\n/* harmony export */   getMelFilters: () => (/* reexport safe */ _utils_audio_js__WEBPACK_IMPORTED_MODULE_6__.getMelFilters),\n/* harmony export */   getTopItems: () => (/* reexport safe */ _utils_maths_js__WEBPACK_IMPORTED_MODULE_9__.getTopItems),\n/* harmony export */   interpolate: () => (/* reexport safe */ _utils_tensor_js__WEBPACK_IMPORTED_MODULE_8__.interpolate),\n/* harmony export */   interpolate_data: () => (/* reexport safe */ _utils_maths_js__WEBPACK_IMPORTED_MODULE_9__.interpolate_data),\n/* harmony export */   log_softmax: () => (/* reexport safe */ _utils_maths_js__WEBPACK_IMPORTED_MODULE_9__.log_softmax),\n/* harmony export */   magnitude: () => (/* reexport safe */ _utils_maths_js__WEBPACK_IMPORTED_MODULE_9__.magnitude),\n/* harmony export */   max: () => (/* reexport safe */ _utils_maths_js__WEBPACK_IMPORTED_MODULE_9__.max),\n/* harmony export */   mean: () => (/* reexport safe */ _utils_tensor_js__WEBPACK_IMPORTED_MODULE_8__.mean),\n/* harmony export */   mean_pooling: () => (/* reexport safe */ _utils_tensor_js__WEBPACK_IMPORTED_MODULE_8__.mean_pooling),\n/* harmony export */   medianFilter: () => (/* reexport safe */ _utils_maths_js__WEBPACK_IMPORTED_MODULE_9__.medianFilter),\n/* harmony export */   min: () => (/* reexport safe */ _utils_maths_js__WEBPACK_IMPORTED_MODULE_9__.min),\n/* harmony export */   pipeline: () => (/* reexport safe */ _pipelines_js__WEBPACK_IMPORTED_MODULE_0__.pipeline),\n/* harmony export */   read_audio: () => (/* reexport safe */ _utils_audio_js__WEBPACK_IMPORTED_MODULE_6__.read_audio),\n/* harmony export */   rfftfreq: () => (/* reexport safe */ _utils_maths_js__WEBPACK_IMPORTED_MODULE_9__.rfftfreq),\n/* harmony export */   round: () => (/* reexport safe */ _utils_maths_js__WEBPACK_IMPORTED_MODULE_9__.round),\n/* harmony export */   softmax: () => (/* reexport safe */ _utils_maths_js__WEBPACK_IMPORTED_MODULE_9__.softmax),\n/* harmony export */   stack: () => (/* reexport safe */ _utils_tensor_js__WEBPACK_IMPORTED_MODULE_8__.stack),\n/* harmony export */   std_mean: () => (/* reexport safe */ _utils_tensor_js__WEBPACK_IMPORTED_MODULE_8__.std_mean),\n/* harmony export */   transpose: () => (/* reexport safe */ _utils_tensor_js__WEBPACK_IMPORTED_MODULE_8__.transpose),\n/* harmony export */   transpose_data: () => (/* reexport safe */ _utils_maths_js__WEBPACK_IMPORTED_MODULE_9__.transpose_data)\n/* harmony export */ });\n/* harmony import */ var _pipelines_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./pipelines.js */ \"(ssr)/./node_modules/@xenova/transformers/src/pipelines.js\");\n/* harmony import */ var _env_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./env.js */ \"(ssr)/./node_modules/@xenova/transformers/src/env.js\");\n/* harmony import */ var _models_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./models.js */ \"(ssr)/./node_modules/@xenova/transformers/src/models.js\");\n/* harmony import */ var _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./tokenizers.js */ \"(ssr)/./node_modules/@xenova/transformers/src/tokenizers.js\");\n/* harmony import */ var _processors_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./processors.js */ \"(ssr)/./node_modules/@xenova/transformers/src/processors.js\");\n/* harmony import */ var _configs_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./configs.js */ \"(ssr)/./node_modules/@xenova/transformers/src/configs.js\");\n/* harmony import */ var _utils_audio_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./utils/audio.js */ \"(ssr)/./node_modules/@xenova/transformers/src/utils/audio.js\");\n/* harmony import */ var _utils_image_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./utils/image.js */ \"(ssr)/./node_modules/@xenova/transformers/src/utils/image.js\");\n/* harmony import */ var _utils_tensor_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./utils/tensor.js */ \"(ssr)/./node_modules/@xenova/transformers/src/utils/tensor.js\");\n/* harmony import */ var _utils_maths_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./utils/maths.js */ \"(ssr)/./node_modules/@xenova/transformers/src/utils/maths.js\");\n// @ts-nocheck\n\n/**\n * @file Entry point for the Transformers.js library. Only the exports from this file\n * are available to the end user, and are grouped as follows:\n * \n * 1. [Pipelines](./pipelines)\n * 2. [Environment variables](./env)\n * 3. [Models](./models)\n * 4. [Tokenizers](./tokenizers)\n * 5. [Processors](./processors)\n * \n * @module transformers\n */\n\n\n\n\n\n\n\n\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHhlbm92YS90cmFuc2Zvcm1lcnMvc3JjL3RyYW5zZm9ybWVycy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRStCO0FBQ047QUFDRztBQUNJO0FBQ0E7QUFDSDs7QUFFSTtBQUNBO0FBQ0M7QUFDRCIsInNvdXJjZXMiOlsid2VicGFjazovL3RyYW5zZm9ybWVyc2pzLXBsYXlncm91bmQvLi9ub2RlX21vZHVsZXMvQHhlbm92YS90cmFuc2Zvcm1lcnMvc3JjL3RyYW5zZm9ybWVycy5qcz81OGFjIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIEB0cy1ub2NoZWNrXG5cbi8qKlxuICogQGZpbGUgRW50cnkgcG9pbnQgZm9yIHRoZSBUcmFuc2Zvcm1lcnMuanMgbGlicmFyeS4gT25seSB0aGUgZXhwb3J0cyBmcm9tIHRoaXMgZmlsZVxuICogYXJlIGF2YWlsYWJsZSB0byB0aGUgZW5kIHVzZXIsIGFuZCBhcmUgZ3JvdXBlZCBhcyBmb2xsb3dzOlxuICogXG4gKiAxLiBbUGlwZWxpbmVzXSguL3BpcGVsaW5lcylcbiAqIDIuIFtFbnZpcm9ubWVudCB2YXJpYWJsZXNdKC4vZW52KVxuICogMy4gW01vZGVsc10oLi9tb2RlbHMpXG4gKiA0LiBbVG9rZW5pemVyc10oLi90b2tlbml6ZXJzKVxuICogNS4gW1Byb2Nlc3NvcnNdKC4vcHJvY2Vzc29ycylcbiAqIFxuICogQG1vZHVsZSB0cmFuc2Zvcm1lcnNcbiAqL1xuXG5leHBvcnQgKiBmcm9tICcuL3BpcGVsaW5lcy5qcyc7XG5leHBvcnQgKiBmcm9tICcuL2Vudi5qcyc7XG5leHBvcnQgKiBmcm9tICcuL21vZGVscy5qcyc7XG5leHBvcnQgKiBmcm9tICcuL3Rva2VuaXplcnMuanMnO1xuZXhwb3J0ICogZnJvbSAnLi9wcm9jZXNzb3JzLmpzJztcbmV4cG9ydCAqIGZyb20gJy4vY29uZmlncy5qcyc7XG5cbmV4cG9ydCAqIGZyb20gJy4vdXRpbHMvYXVkaW8uanMnO1xuZXhwb3J0ICogZnJvbSAnLi91dGlscy9pbWFnZS5qcyc7XG5leHBvcnQgKiBmcm9tICcuL3V0aWxzL3RlbnNvci5qcyc7XG5leHBvcnQgKiBmcm9tICcuL3V0aWxzL21hdGhzLmpzJztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@xenova/transformers/src/transformers.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@xenova/transformers/src/utils/audio.js":
/*!**************************************************************!*\
  !*** ./node_modules/@xenova/transformers/src/utils/audio.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getMelFilters: () => (/* binding */ getMelFilters),\n/* harmony export */   read_audio: () => (/* binding */ read_audio)\n/* harmony export */ });\n/* harmony import */ var _hub_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./hub.js */ \"(ssr)/./node_modules/@xenova/transformers/src/utils/hub.js\");\n/* harmony import */ var _maths_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./maths.js */ \"(ssr)/./node_modules/@xenova/transformers/src/utils/maths.js\");\n/**\n * @file Helper module for audio processing. \n * \n * These functions and classes are only used internally, \n * meaning an end-user shouldn't need to access anything here.\n * \n * @module utils/audio\n */\n\n\n\n\n/**\n * Helper function to read audio from a path/URL.\n * @param {string|URL} url The path/URL to load the audio from.\n * @param {number} sampling_rate The sampling rate to use when decoding the audio.\n * @returns {Promise<Float32Array>} The decoded audio as a `Float32Array`.\n */\nasync function read_audio(url, sampling_rate) {\n    if (typeof AudioContext === 'undefined') {\n        // Running in node or an environment without AudioContext\n        throw Error(\n            \"Unable to load audio from path/URL since `AudioContext` is not available in your environment. \" +\n            \"Instead, audio data should be passed directly to the pipeline/processor. \" +\n            \"For more information and some example code, see https://huggingface.co/docs/transformers.js/tutorials/node-audio-processing.\"\n        )\n    }\n\n    const response = await (await (0,_hub_js__WEBPACK_IMPORTED_MODULE_0__.getFile)(url)).arrayBuffer();\n    const audioCTX = new AudioContext({ sampleRate: sampling_rate });\n    if (typeof sampling_rate === 'undefined') {\n        console.warn(`No sampling rate provided, using default of ${audioCTX.sampleRate}Hz.`)\n    }\n    const decoded = await audioCTX.decodeAudioData(response);\n    let audio;\n\n    // We now replicate HuggingFace's `ffmpeg_read` method:\n    if (decoded.numberOfChannels === 2) {\n        // When downmixing a stereo audio file to mono using the -ac 1 option in FFmpeg,\n        // the audio signal is summed across both channels to create a single mono channel.\n        // However, if the audio is at full scale (i.e. the highest possible volume level),\n        // the summing of the two channels can cause the audio signal to clip or distort.\n\n        // To prevent this clipping, FFmpeg applies a scaling factor of 1/sqrt(2) (~ 0.707)\n        // to the audio signal before summing the two channels. This scaling factor ensures\n        // that the combined audio signal will not exceed the maximum possible level, even\n        // if both channels are at full scale.\n\n        // After applying this scaling factor, the audio signal from both channels is summed\n        // to create a single mono channel. It's worth noting that this scaling factor is\n        // only applied when downmixing stereo audio to mono using the -ac 1 option in FFmpeg.\n        // If you're using a different downmixing method, or if you're not downmixing the\n        // audio at all, this scaling factor may not be needed.\n        const SCALING_FACTOR = Math.sqrt(2);\n\n        let left = decoded.getChannelData(0);\n        let right = decoded.getChannelData(1);\n\n        audio = new Float32Array(left.length);\n        for (let i = 0; i < decoded.length; ++i) {\n            audio[i] = SCALING_FACTOR * (left[i] + right[i]) / 2;\n        }\n\n    } else {\n        // If the audio is not stereo, we can just use the first channel:\n        audio = decoded.getChannelData(0);\n    }\n\n    return audio;\n}\n\n/**\n * Creates a frequency bin conversion matrix used to obtain a mel spectrogram.\n * @param {number} sr Sample rate of the audio waveform.\n * @param {number} n_fft Number of frequencies used to compute the spectrogram (should be the same as in `stft`).\n * @param {number} n_mels Number of mel filters to generate.\n * @returns {number[][]} Projection matrix to go from a spectrogram to a mel spectrogram.\n */\nfunction getMelFilters(sr, n_fft, n_mels = 128) {\n    n_mels = Math.floor(n_mels);\n\n    // Initialize the weights\n    const mel_size = Math.floor(1 + n_fft / 2);\n    const weights = new Array(n_mels);\n\n    // Center freqs of each FFT bin\n    const fftfreqs = (0,_maths_js__WEBPACK_IMPORTED_MODULE_1__.rfftfreq)(n_fft, 1 / sr);\n\n    // 'Center freqs' of mel bands - uniformly spaced between limits\n    const min_mel = 0.0;\n    const max_mel = 45.245640471924965;\n    const mel_range = max_mel - min_mel;\n    const mel_scale = mel_range / (n_mels + 1);\n\n    // Fill in the linear scale\n    const f_min = 0.0;\n    const f_sp = 200.0 / 3;\n    const freqs = new Array(n_mels + 2);\n\n    // And now the nonlinear scale\n    const min_log_hz = 1000.0; // beginning of log region (Hz)\n    const min_log_mel = (min_log_hz - f_min) / f_sp; // same (Mels)\n    const logstep = Math.log(6.4) / 27.0; // step size for log region\n\n    const ramps = new Array(freqs.length);\n    for (let i = 0; i < freqs.length; ++i) {\n        const mel = i * mel_scale + min_mel;\n        if (mel >= min_log_mel) {\n            freqs[i] = min_log_hz * Math.exp(logstep * (mel - min_log_mel));\n        } else {\n            freqs[i] = f_min + f_sp * mel;\n        }\n        ramps[i] = fftfreqs.map(k => freqs[i] - k);\n    }\n\n    const fdiffinv = freqs.slice(1).map((v, i) => 1 / (v - freqs[i]));\n\n    for (let i = 0; i < weights.length; ++i) {\n        weights[i] = new Array(mel_size);\n\n        const a = fdiffinv[i];\n        const b = fdiffinv[i + 1];\n        const c = ramps[i];\n        const d = ramps[i + 2];\n\n        // Slaney-style mel is scaled to be approx constant energy per channel\n        const enorm = 2.0 / (freqs[i + 2] - freqs[i]);\n\n        for (let j = 0; j < weights[i].length; ++j) {\n            // lower and upper slopes for all bins\n            const lower = -c[j] * a;\n            const upper = d[j] * b;\n            weights[i][j] = Math.max(0, Math.min(lower, upper)) * enorm;\n        }\n    }\n\n    return weights;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHhlbm92YS90cmFuc2Zvcm1lcnMvc3JjL3V0aWxzL2F1ZGlvLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUlrQjtBQUNvQjs7QUFFdEM7QUFDQTtBQUNBLFdBQVcsWUFBWTtBQUN2QixXQUFXLFFBQVE7QUFDbkIsYUFBYSx1QkFBdUI7QUFDcEM7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0NBQWtDLGdEQUFPO0FBQ3pDLHdDQUF3QywyQkFBMkI7QUFDbkU7QUFDQSxvRUFBb0Usb0JBQW9CO0FBQ3hGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0Isb0JBQW9CO0FBQzVDO0FBQ0E7O0FBRUEsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixhQUFhLFlBQVk7QUFDekI7QUFDTztBQUNQOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQixtREFBUTs7QUFFN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLCtCQUErQjtBQUMvQixxREFBcUQ7QUFDckQsMENBQTBDOztBQUUxQztBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLG9CQUFvQixvQkFBb0I7QUFDeEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx3QkFBd0IsdUJBQXVCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdHJhbnNmb3JtZXJzanMtcGxheWdyb3VuZC8uL25vZGVfbW9kdWxlcy9AeGVub3ZhL3RyYW5zZm9ybWVycy9zcmMvdXRpbHMvYXVkaW8uanM/YjhlYSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBmaWxlIEhlbHBlciBtb2R1bGUgZm9yIGF1ZGlvIHByb2Nlc3NpbmcuIFxuICogXG4gKiBUaGVzZSBmdW5jdGlvbnMgYW5kIGNsYXNzZXMgYXJlIG9ubHkgdXNlZCBpbnRlcm5hbGx5LCBcbiAqIG1lYW5pbmcgYW4gZW5kLXVzZXIgc2hvdWxkbid0IG5lZWQgdG8gYWNjZXNzIGFueXRoaW5nIGhlcmUuXG4gKiBcbiAqIEBtb2R1bGUgdXRpbHMvYXVkaW9cbiAqL1xuXG5pbXBvcnQge1xuICAgIGdldEZpbGUsXG59IGZyb20gJy4vaHViLmpzJztcbmltcG9ydCB7IHJmZnRmcmVxIH0gZnJvbSAnLi9tYXRocy5qcyc7XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRvIHJlYWQgYXVkaW8gZnJvbSBhIHBhdGgvVVJMLlxuICogQHBhcmFtIHtzdHJpbmd8VVJMfSB1cmwgVGhlIHBhdGgvVVJMIHRvIGxvYWQgdGhlIGF1ZGlvIGZyb20uXG4gKiBAcGFyYW0ge251bWJlcn0gc2FtcGxpbmdfcmF0ZSBUaGUgc2FtcGxpbmcgcmF0ZSB0byB1c2Ugd2hlbiBkZWNvZGluZyB0aGUgYXVkaW8uXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxGbG9hdDMyQXJyYXk+fSBUaGUgZGVjb2RlZCBhdWRpbyBhcyBhIGBGbG9hdDMyQXJyYXlgLlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcmVhZF9hdWRpbyh1cmwsIHNhbXBsaW5nX3JhdGUpIHtcbiAgICBpZiAodHlwZW9mIEF1ZGlvQ29udGV4dCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgLy8gUnVubmluZyBpbiBub2RlIG9yIGFuIGVudmlyb25tZW50IHdpdGhvdXQgQXVkaW9Db250ZXh0XG4gICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgXCJVbmFibGUgdG8gbG9hZCBhdWRpbyBmcm9tIHBhdGgvVVJMIHNpbmNlIGBBdWRpb0NvbnRleHRgIGlzIG5vdCBhdmFpbGFibGUgaW4geW91ciBlbnZpcm9ubWVudC4gXCIgK1xuICAgICAgICAgICAgXCJJbnN0ZWFkLCBhdWRpbyBkYXRhIHNob3VsZCBiZSBwYXNzZWQgZGlyZWN0bHkgdG8gdGhlIHBpcGVsaW5lL3Byb2Nlc3Nvci4gXCIgK1xuICAgICAgICAgICAgXCJGb3IgbW9yZSBpbmZvcm1hdGlvbiBhbmQgc29tZSBleGFtcGxlIGNvZGUsIHNlZSBodHRwczovL2h1Z2dpbmdmYWNlLmNvL2RvY3MvdHJhbnNmb3JtZXJzLmpzL3R1dG9yaWFscy9ub2RlLWF1ZGlvLXByb2Nlc3NpbmcuXCJcbiAgICAgICAgKVxuICAgIH1cblxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgKGF3YWl0IGdldEZpbGUodXJsKSkuYXJyYXlCdWZmZXIoKTtcbiAgICBjb25zdCBhdWRpb0NUWCA9IG5ldyBBdWRpb0NvbnRleHQoeyBzYW1wbGVSYXRlOiBzYW1wbGluZ19yYXRlIH0pO1xuICAgIGlmICh0eXBlb2Ygc2FtcGxpbmdfcmF0ZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgY29uc29sZS53YXJuKGBObyBzYW1wbGluZyByYXRlIHByb3ZpZGVkLCB1c2luZyBkZWZhdWx0IG9mICR7YXVkaW9DVFguc2FtcGxlUmF0ZX1Iei5gKVxuICAgIH1cbiAgICBjb25zdCBkZWNvZGVkID0gYXdhaXQgYXVkaW9DVFguZGVjb2RlQXVkaW9EYXRhKHJlc3BvbnNlKTtcbiAgICBsZXQgYXVkaW87XG5cbiAgICAvLyBXZSBub3cgcmVwbGljYXRlIEh1Z2dpbmdGYWNlJ3MgYGZmbXBlZ19yZWFkYCBtZXRob2Q6XG4gICAgaWYgKGRlY29kZWQubnVtYmVyT2ZDaGFubmVscyA9PT0gMikge1xuICAgICAgICAvLyBXaGVuIGRvd25taXhpbmcgYSBzdGVyZW8gYXVkaW8gZmlsZSB0byBtb25vIHVzaW5nIHRoZSAtYWMgMSBvcHRpb24gaW4gRkZtcGVnLFxuICAgICAgICAvLyB0aGUgYXVkaW8gc2lnbmFsIGlzIHN1bW1lZCBhY3Jvc3MgYm90aCBjaGFubmVscyB0byBjcmVhdGUgYSBzaW5nbGUgbW9ubyBjaGFubmVsLlxuICAgICAgICAvLyBIb3dldmVyLCBpZiB0aGUgYXVkaW8gaXMgYXQgZnVsbCBzY2FsZSAoaS5lLiB0aGUgaGlnaGVzdCBwb3NzaWJsZSB2b2x1bWUgbGV2ZWwpLFxuICAgICAgICAvLyB0aGUgc3VtbWluZyBvZiB0aGUgdHdvIGNoYW5uZWxzIGNhbiBjYXVzZSB0aGUgYXVkaW8gc2lnbmFsIHRvIGNsaXAgb3IgZGlzdG9ydC5cblxuICAgICAgICAvLyBUbyBwcmV2ZW50IHRoaXMgY2xpcHBpbmcsIEZGbXBlZyBhcHBsaWVzIGEgc2NhbGluZyBmYWN0b3Igb2YgMS9zcXJ0KDIpICh+IDAuNzA3KVxuICAgICAgICAvLyB0byB0aGUgYXVkaW8gc2lnbmFsIGJlZm9yZSBzdW1taW5nIHRoZSB0d28gY2hhbm5lbHMuIFRoaXMgc2NhbGluZyBmYWN0b3IgZW5zdXJlc1xuICAgICAgICAvLyB0aGF0IHRoZSBjb21iaW5lZCBhdWRpbyBzaWduYWwgd2lsbCBub3QgZXhjZWVkIHRoZSBtYXhpbXVtIHBvc3NpYmxlIGxldmVsLCBldmVuXG4gICAgICAgIC8vIGlmIGJvdGggY2hhbm5lbHMgYXJlIGF0IGZ1bGwgc2NhbGUuXG5cbiAgICAgICAgLy8gQWZ0ZXIgYXBwbHlpbmcgdGhpcyBzY2FsaW5nIGZhY3RvciwgdGhlIGF1ZGlvIHNpZ25hbCBmcm9tIGJvdGggY2hhbm5lbHMgaXMgc3VtbWVkXG4gICAgICAgIC8vIHRvIGNyZWF0ZSBhIHNpbmdsZSBtb25vIGNoYW5uZWwuIEl0J3Mgd29ydGggbm90aW5nIHRoYXQgdGhpcyBzY2FsaW5nIGZhY3RvciBpc1xuICAgICAgICAvLyBvbmx5IGFwcGxpZWQgd2hlbiBkb3dubWl4aW5nIHN0ZXJlbyBhdWRpbyB0byBtb25vIHVzaW5nIHRoZSAtYWMgMSBvcHRpb24gaW4gRkZtcGVnLlxuICAgICAgICAvLyBJZiB5b3UncmUgdXNpbmcgYSBkaWZmZXJlbnQgZG93bm1peGluZyBtZXRob2QsIG9yIGlmIHlvdSdyZSBub3QgZG93bm1peGluZyB0aGVcbiAgICAgICAgLy8gYXVkaW8gYXQgYWxsLCB0aGlzIHNjYWxpbmcgZmFjdG9yIG1heSBub3QgYmUgbmVlZGVkLlxuICAgICAgICBjb25zdCBTQ0FMSU5HX0ZBQ1RPUiA9IE1hdGguc3FydCgyKTtcblxuICAgICAgICBsZXQgbGVmdCA9IGRlY29kZWQuZ2V0Q2hhbm5lbERhdGEoMCk7XG4gICAgICAgIGxldCByaWdodCA9IGRlY29kZWQuZ2V0Q2hhbm5lbERhdGEoMSk7XG5cbiAgICAgICAgYXVkaW8gPSBuZXcgRmxvYXQzMkFycmF5KGxlZnQubGVuZ3RoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkZWNvZGVkLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBhdWRpb1tpXSA9IFNDQUxJTkdfRkFDVE9SICogKGxlZnRbaV0gKyByaWdodFtpXSkgLyAyO1xuICAgICAgICB9XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBJZiB0aGUgYXVkaW8gaXMgbm90IHN0ZXJlbywgd2UgY2FuIGp1c3QgdXNlIHRoZSBmaXJzdCBjaGFubmVsOlxuICAgICAgICBhdWRpbyA9IGRlY29kZWQuZ2V0Q2hhbm5lbERhdGEoMCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGF1ZGlvO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBmcmVxdWVuY3kgYmluIGNvbnZlcnNpb24gbWF0cml4IHVzZWQgdG8gb2J0YWluIGEgbWVsIHNwZWN0cm9ncmFtLlxuICogQHBhcmFtIHtudW1iZXJ9IHNyIFNhbXBsZSByYXRlIG9mIHRoZSBhdWRpbyB3YXZlZm9ybS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBuX2ZmdCBOdW1iZXIgb2YgZnJlcXVlbmNpZXMgdXNlZCB0byBjb21wdXRlIHRoZSBzcGVjdHJvZ3JhbSAoc2hvdWxkIGJlIHRoZSBzYW1lIGFzIGluIGBzdGZ0YCkuXG4gKiBAcGFyYW0ge251bWJlcn0gbl9tZWxzIE51bWJlciBvZiBtZWwgZmlsdGVycyB0byBnZW5lcmF0ZS5cbiAqIEByZXR1cm5zIHtudW1iZXJbXVtdfSBQcm9qZWN0aW9uIG1hdHJpeCB0byBnbyBmcm9tIGEgc3BlY3Ryb2dyYW0gdG8gYSBtZWwgc3BlY3Ryb2dyYW0uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRNZWxGaWx0ZXJzKHNyLCBuX2ZmdCwgbl9tZWxzID0gMTI4KSB7XG4gICAgbl9tZWxzID0gTWF0aC5mbG9vcihuX21lbHMpO1xuXG4gICAgLy8gSW5pdGlhbGl6ZSB0aGUgd2VpZ2h0c1xuICAgIGNvbnN0IG1lbF9zaXplID0gTWF0aC5mbG9vcigxICsgbl9mZnQgLyAyKTtcbiAgICBjb25zdCB3ZWlnaHRzID0gbmV3IEFycmF5KG5fbWVscyk7XG5cbiAgICAvLyBDZW50ZXIgZnJlcXMgb2YgZWFjaCBGRlQgYmluXG4gICAgY29uc3QgZmZ0ZnJlcXMgPSByZmZ0ZnJlcShuX2ZmdCwgMSAvIHNyKTtcblxuICAgIC8vICdDZW50ZXIgZnJlcXMnIG9mIG1lbCBiYW5kcyAtIHVuaWZvcm1seSBzcGFjZWQgYmV0d2VlbiBsaW1pdHNcbiAgICBjb25zdCBtaW5fbWVsID0gMC4wO1xuICAgIGNvbnN0IG1heF9tZWwgPSA0NS4yNDU2NDA0NzE5MjQ5NjU7XG4gICAgY29uc3QgbWVsX3JhbmdlID0gbWF4X21lbCAtIG1pbl9tZWw7XG4gICAgY29uc3QgbWVsX3NjYWxlID0gbWVsX3JhbmdlIC8gKG5fbWVscyArIDEpO1xuXG4gICAgLy8gRmlsbCBpbiB0aGUgbGluZWFyIHNjYWxlXG4gICAgY29uc3QgZl9taW4gPSAwLjA7XG4gICAgY29uc3QgZl9zcCA9IDIwMC4wIC8gMztcbiAgICBjb25zdCBmcmVxcyA9IG5ldyBBcnJheShuX21lbHMgKyAyKTtcblxuICAgIC8vIEFuZCBub3cgdGhlIG5vbmxpbmVhciBzY2FsZVxuICAgIGNvbnN0IG1pbl9sb2dfaHogPSAxMDAwLjA7IC8vIGJlZ2lubmluZyBvZiBsb2cgcmVnaW9uIChIeilcbiAgICBjb25zdCBtaW5fbG9nX21lbCA9IChtaW5fbG9nX2h6IC0gZl9taW4pIC8gZl9zcDsgLy8gc2FtZSAoTWVscylcbiAgICBjb25zdCBsb2dzdGVwID0gTWF0aC5sb2coNi40KSAvIDI3LjA7IC8vIHN0ZXAgc2l6ZSBmb3IgbG9nIHJlZ2lvblxuXG4gICAgY29uc3QgcmFtcHMgPSBuZXcgQXJyYXkoZnJlcXMubGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZyZXFzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IG1lbCA9IGkgKiBtZWxfc2NhbGUgKyBtaW5fbWVsO1xuICAgICAgICBpZiAobWVsID49IG1pbl9sb2dfbWVsKSB7XG4gICAgICAgICAgICBmcmVxc1tpXSA9IG1pbl9sb2dfaHogKiBNYXRoLmV4cChsb2dzdGVwICogKG1lbCAtIG1pbl9sb2dfbWVsKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmcmVxc1tpXSA9IGZfbWluICsgZl9zcCAqIG1lbDtcbiAgICAgICAgfVxuICAgICAgICByYW1wc1tpXSA9IGZmdGZyZXFzLm1hcChrID0+IGZyZXFzW2ldIC0gayk7XG4gICAgfVxuXG4gICAgY29uc3QgZmRpZmZpbnYgPSBmcmVxcy5zbGljZSgxKS5tYXAoKHYsIGkpID0+IDEgLyAodiAtIGZyZXFzW2ldKSk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHdlaWdodHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgd2VpZ2h0c1tpXSA9IG5ldyBBcnJheShtZWxfc2l6ZSk7XG5cbiAgICAgICAgY29uc3QgYSA9IGZkaWZmaW52W2ldO1xuICAgICAgICBjb25zdCBiID0gZmRpZmZpbnZbaSArIDFdO1xuICAgICAgICBjb25zdCBjID0gcmFtcHNbaV07XG4gICAgICAgIGNvbnN0IGQgPSByYW1wc1tpICsgMl07XG5cbiAgICAgICAgLy8gU2xhbmV5LXN0eWxlIG1lbCBpcyBzY2FsZWQgdG8gYmUgYXBwcm94IGNvbnN0YW50IGVuZXJneSBwZXIgY2hhbm5lbFxuICAgICAgICBjb25zdCBlbm9ybSA9IDIuMCAvIChmcmVxc1tpICsgMl0gLSBmcmVxc1tpXSk7XG5cbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB3ZWlnaHRzW2ldLmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgICAvLyBsb3dlciBhbmQgdXBwZXIgc2xvcGVzIGZvciBhbGwgYmluc1xuICAgICAgICAgICAgY29uc3QgbG93ZXIgPSAtY1tqXSAqIGE7XG4gICAgICAgICAgICBjb25zdCB1cHBlciA9IGRbal0gKiBiO1xuICAgICAgICAgICAgd2VpZ2h0c1tpXVtqXSA9IE1hdGgubWF4KDAsIE1hdGgubWluKGxvd2VyLCB1cHBlcikpICogZW5vcm07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gd2VpZ2h0cztcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@xenova/transformers/src/utils/audio.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@xenova/transformers/src/utils/core.js":
/*!*************************************************************!*\
  !*** ./node_modules/@xenova/transformers/src/utils/core.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Callable: () => (/* binding */ Callable),\n/* harmony export */   calculateDimensions: () => (/* binding */ calculateDimensions),\n/* harmony export */   dispatchCallback: () => (/* binding */ dispatchCallback),\n/* harmony export */   escapeRegExp: () => (/* binding */ escapeRegExp),\n/* harmony export */   exists: () => (/* binding */ exists),\n/* harmony export */   isIntegralNumber: () => (/* binding */ isIntegralNumber),\n/* harmony export */   isString: () => (/* binding */ isString),\n/* harmony export */   isTypedArray: () => (/* binding */ isTypedArray),\n/* harmony export */   mergeArrays: () => (/* binding */ mergeArrays),\n/* harmony export */   pop: () => (/* binding */ pop),\n/* harmony export */   reverseDictionary: () => (/* binding */ reverseDictionary)\n/* harmony export */ });\n\n/**\n * @file Core utility functions/classes for Transformers.js.\n * \n * These are only used internally, meaning an end-user shouldn't\n * need to access anything here.\n * \n * @module utils/core\n */\n\n/**\n * Helper function to dispatch progress callbacks.\n *\n * @param {function} progress_callback The progress callback function to dispatch.\n * @param {any} data The data to pass to the progress callback function.\n * @returns {void}\n * @private\n */\nfunction dispatchCallback(progress_callback, data) {\n    if (progress_callback !== null) progress_callback(data);\n}\n\n/**\n * Reverses the keys and values of an object.\n *\n * @param {Object} data The object to reverse.\n * @returns {Object} The reversed object.\n * @see https://ultimatecourses.com/blog/reverse-object-keys-and-values-in-javascript\n */\nfunction reverseDictionary(data) {\n    // https://ultimatecourses.com/blog/reverse-object-keys-and-values-in-javascript\n    return Object.fromEntries(Object.entries(data).map(([key, value]) => [value, key]));\n}\n\n/**\n * Escapes regular expression special characters from a string by replacing them with their escaped counterparts.\n *\n * @param {string} string The string to escape.\n * @returns {string} The escaped string.\n */\nfunction escapeRegExp(string) {\n    return string.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&'); // $& means the whole matched string\n}\n\n/**\n * A base class for creating callable objects.\n * \n * @type {new () => {(...args: any[]): any, _call(...args: any[]): any}}\n */\nconst Callable = /** @type {any} */ (class {\n    /**\n    * Creates a new instance of the Callable class.\n    */\n    constructor() {\n        /**\n         * Creates a closure that delegates to a private method '_call' with the given arguments.\n         * @type {any}\n         * @param {...any} args Zero or more arguments to pass to the '_call' method.\n         * @returns {*} The result of calling the '_call' method.\n         */\n        let closure = function (...args) {\n            return closure._call(...args)\n        }\n        return Object.setPrototypeOf(closure, new.target.prototype)\n    }\n\n    /**\n     * This method should be implemented in subclasses to provide the\n     * functionality of the callable object.\n     *\n     * @param {any[]} args\n     * @throws {Error} If the subclass does not implement the `_call` method.\n     */\n    _call(...args) {\n        throw Error('Must implement _call method in subclass')\n    }\n});\n\n\n/**\n * Check if a value is a string.\n * @param {*} text The value to check.\n * @returns {boolean} True if the value is a string, false otherwise.\n */\nfunction isString(text) {\n    return typeof text === 'string' || text instanceof String\n}\n\n\n/**\n * Check if a value is a typed array.\n * @param {*} val The value to check.\n * @returns {boolean} True if the value is a `TypedArray`, false otherwise.\n * \n * Adapted from https://stackoverflow.com/a/71091338/13989043\n */\nfunction isTypedArray(val) {\n    return val?.prototype?.__proto__?.constructor?.name === 'TypedArray';\n}\n\n\n/**\n * Check if a value is an integer.\n * @param {*} x The value to check.\n * @returns {boolean} True if the value is a string, false otherwise.\n */\nfunction isIntegralNumber(x) {\n    return Number.isInteger(x) || typeof x === 'bigint'\n}\n\n/**\n * Check if a value is exists.\n * @param {*} x The value to check.\n * @returns {boolean} True if the value exists, false otherwise.\n */\nfunction exists(x) {\n    return x !== undefined && x !== null;\n}\n\n/**\n * Calculates the dimensions of a nested array.\n *\n * @param {Array} arr The nested array to calculate dimensions for.\n * @returns {Array} An array containing the dimensions of the input array.\n */\nfunction calculateDimensions(arr) {\n    const dimensions = [];\n    let current = arr;\n    while (Array.isArray(current)) {\n        dimensions.push(current.length);\n        current = current[0];\n    }\n    return dimensions;\n}\n\n/**\n * Replicate python's .pop() method for objects.\n * @param {Object} obj The object to pop from.\n * @param {string} key The key to pop.\n * @param {*} defaultValue The default value to return if the key does not exist.\n * @returns {*} The value of the popped key.\n * @throws {Error} If the key does not exist and no default value is provided.\n */\nfunction pop(obj, key, defaultValue = undefined) {\n    const value = obj[key];\n    if (value !== undefined) {\n        delete obj[key];\n        return value;\n    }\n    if (defaultValue === undefined) {\n        throw Error(`Key ${key} does not exist in object.`)\n    }\n    return defaultValue;\n}\n\n/**\n * Efficiently merge arrays, creating a new copy.\n * Adapted from https://stackoverflow.com/a/6768642/13989043\n * @param  {...any} arrs Arrays to merge.\n * @returns The merged array.\n */\nfunction mergeArrays(...arrs) {\n    return Array.prototype.concat.apply([], arrs);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHhlbm92YS90cmFuc2Zvcm1lcnMvc3JjL3V0aWxzL2NvcmUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckIsV0FBVyxLQUFLO0FBQ2hCLGFBQWE7QUFDYjtBQUNBO0FBQ087QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhLFFBQVE7QUFDckI7QUFDTztBQUNQLG9DQUFvQyxzQkFBc0I7QUFDMUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVSxXQUFXO0FBQ3JCO0FBQ08sNEJBQTRCLEtBQUs7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCLG1CQUFtQixRQUFRO0FBQzNCLHFCQUFxQixHQUFHO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxhQUFhLFNBQVM7QUFDdEI7QUFDTztBQUNQO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsYUFBYSxTQUFTO0FBQ3RCO0FBQ087QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxhQUFhLFNBQVM7QUFDdEI7QUFDTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsT0FBTztBQUNwQjtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLEdBQUc7QUFDZCxhQUFhLEdBQUc7QUFDaEIsWUFBWSxPQUFPO0FBQ25CO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsS0FBSztBQUNoQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDTztBQUNQO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90cmFuc2Zvcm1lcnNqcy1wbGF5Z3JvdW5kLy4vbm9kZV9tb2R1bGVzL0B4ZW5vdmEvdHJhbnNmb3JtZXJzL3NyYy91dGlscy9jb3JlLmpzPzZjYmIiXSwic291cmNlc0NvbnRlbnQiOlsiXG4vKipcbiAqIEBmaWxlIENvcmUgdXRpbGl0eSBmdW5jdGlvbnMvY2xhc3NlcyBmb3IgVHJhbnNmb3JtZXJzLmpzLlxuICogXG4gKiBUaGVzZSBhcmUgb25seSB1c2VkIGludGVybmFsbHksIG1lYW5pbmcgYW4gZW5kLXVzZXIgc2hvdWxkbid0XG4gKiBuZWVkIHRvIGFjY2VzcyBhbnl0aGluZyBoZXJlLlxuICogXG4gKiBAbW9kdWxlIHV0aWxzL2NvcmVcbiAqL1xuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0byBkaXNwYXRjaCBwcm9ncmVzcyBjYWxsYmFja3MuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gcHJvZ3Jlc3NfY2FsbGJhY2sgVGhlIHByb2dyZXNzIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGRpc3BhdGNoLlxuICogQHBhcmFtIHthbnl9IGRhdGEgVGhlIGRhdGEgdG8gcGFzcyB0byB0aGUgcHJvZ3Jlc3MgY2FsbGJhY2sgZnVuY3Rpb24uXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkaXNwYXRjaENhbGxiYWNrKHByb2dyZXNzX2NhbGxiYWNrLCBkYXRhKSB7XG4gICAgaWYgKHByb2dyZXNzX2NhbGxiYWNrICE9PSBudWxsKSBwcm9ncmVzc19jYWxsYmFjayhkYXRhKTtcbn1cblxuLyoqXG4gKiBSZXZlcnNlcyB0aGUga2V5cyBhbmQgdmFsdWVzIG9mIGFuIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZGF0YSBUaGUgb2JqZWN0IHRvIHJldmVyc2UuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgcmV2ZXJzZWQgb2JqZWN0LlxuICogQHNlZSBodHRwczovL3VsdGltYXRlY291cnNlcy5jb20vYmxvZy9yZXZlcnNlLW9iamVjdC1rZXlzLWFuZC12YWx1ZXMtaW4tamF2YXNjcmlwdFxuICovXG5leHBvcnQgZnVuY3Rpb24gcmV2ZXJzZURpY3Rpb25hcnkoZGF0YSkge1xuICAgIC8vIGh0dHBzOi8vdWx0aW1hdGVjb3Vyc2VzLmNvbS9ibG9nL3JldmVyc2Utb2JqZWN0LWtleXMtYW5kLXZhbHVlcy1pbi1qYXZhc2NyaXB0XG4gICAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhPYmplY3QuZW50cmllcyhkYXRhKS5tYXAoKFtrZXksIHZhbHVlXSkgPT4gW3ZhbHVlLCBrZXldKSk7XG59XG5cbi8qKlxuICogRXNjYXBlcyByZWd1bGFyIGV4cHJlc3Npb24gc3BlY2lhbCBjaGFyYWN0ZXJzIGZyb20gYSBzdHJpbmcgYnkgcmVwbGFjaW5nIHRoZW0gd2l0aCB0aGVpciBlc2NhcGVkIGNvdW50ZXJwYXJ0cy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gZXNjYXBlLlxuICogQHJldHVybnMge3N0cmluZ30gVGhlIGVzY2FwZWQgc3RyaW5nLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZXNjYXBlUmVnRXhwKHN0cmluZykge1xuICAgIHJldHVybiBzdHJpbmcucmVwbGFjZSgvWy4qKz9eJHt9KCl8W1xcXVxcXFxdL2csICdcXFxcJCYnKTsgLy8gJCYgbWVhbnMgdGhlIHdob2xlIG1hdGNoZWQgc3RyaW5nXG59XG5cbi8qKlxuICogQSBiYXNlIGNsYXNzIGZvciBjcmVhdGluZyBjYWxsYWJsZSBvYmplY3RzLlxuICogXG4gKiBAdHlwZSB7bmV3ICgpID0+IHsoLi4uYXJnczogYW55W10pOiBhbnksIF9jYWxsKC4uLmFyZ3M6IGFueVtdKTogYW55fX1cbiAqL1xuZXhwb3J0IGNvbnN0IENhbGxhYmxlID0gLyoqIEB0eXBlIHthbnl9ICovIChjbGFzcyB7XG4gICAgLyoqXG4gICAgKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIHRoZSBDYWxsYWJsZSBjbGFzcy5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIGNsb3N1cmUgdGhhdCBkZWxlZ2F0ZXMgdG8gYSBwcml2YXRlIG1ldGhvZCAnX2NhbGwnIHdpdGggdGhlIGdpdmVuIGFyZ3VtZW50cy5cbiAgICAgICAgICogQHR5cGUge2FueX1cbiAgICAgICAgICogQHBhcmFtIHsuLi5hbnl9IGFyZ3MgWmVybyBvciBtb3JlIGFyZ3VtZW50cyB0byBwYXNzIHRvIHRoZSAnX2NhbGwnIG1ldGhvZC5cbiAgICAgICAgICogQHJldHVybnMgeyp9IFRoZSByZXN1bHQgb2YgY2FsbGluZyB0aGUgJ19jYWxsJyBtZXRob2QuXG4gICAgICAgICAqL1xuICAgICAgICBsZXQgY2xvc3VyZSA9IGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgICAgICByZXR1cm4gY2xvc3VyZS5fY2FsbCguLi5hcmdzKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBPYmplY3Quc2V0UHJvdG90eXBlT2YoY2xvc3VyZSwgbmV3LnRhcmdldC5wcm90b3R5cGUpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2Qgc2hvdWxkIGJlIGltcGxlbWVudGVkIGluIHN1YmNsYXNzZXMgdG8gcHJvdmlkZSB0aGVcbiAgICAgKiBmdW5jdGlvbmFsaXR5IG9mIHRoZSBjYWxsYWJsZSBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2FueVtdfSBhcmdzXG4gICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBzdWJjbGFzcyBkb2VzIG5vdCBpbXBsZW1lbnQgdGhlIGBfY2FsbGAgbWV0aG9kLlxuICAgICAqL1xuICAgIF9jYWxsKC4uLmFyZ3MpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ011c3QgaW1wbGVtZW50IF9jYWxsIG1ldGhvZCBpbiBzdWJjbGFzcycpXG4gICAgfVxufSk7XG5cblxuLyoqXG4gKiBDaGVjayBpZiBhIHZhbHVlIGlzIGEgc3RyaW5nLlxuICogQHBhcmFtIHsqfSB0ZXh0IFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSB2YWx1ZSBpcyBhIHN0cmluZywgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNTdHJpbmcodGV4dCkge1xuICAgIHJldHVybiB0eXBlb2YgdGV4dCA9PT0gJ3N0cmluZycgfHwgdGV4dCBpbnN0YW5jZW9mIFN0cmluZ1xufVxuXG5cbi8qKlxuICogQ2hlY2sgaWYgYSB2YWx1ZSBpcyBhIHR5cGVkIGFycmF5LlxuICogQHBhcmFtIHsqfSB2YWwgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIHZhbHVlIGlzIGEgYFR5cGVkQXJyYXlgLCBmYWxzZSBvdGhlcndpc2UuXG4gKiBcbiAqIEFkYXB0ZWQgZnJvbSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvNzEwOTEzMzgvMTM5ODkwNDNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzVHlwZWRBcnJheSh2YWwpIHtcbiAgICByZXR1cm4gdmFsPy5wcm90b3R5cGU/Ll9fcHJvdG9fXz8uY29uc3RydWN0b3I/Lm5hbWUgPT09ICdUeXBlZEFycmF5Jztcbn1cblxuXG4vKipcbiAqIENoZWNrIGlmIGEgdmFsdWUgaXMgYW4gaW50ZWdlci5cbiAqIEBwYXJhbSB7Kn0geCBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgdmFsdWUgaXMgYSBzdHJpbmcsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzSW50ZWdyYWxOdW1iZXIoeCkge1xuICAgIHJldHVybiBOdW1iZXIuaXNJbnRlZ2VyKHgpIHx8IHR5cGVvZiB4ID09PSAnYmlnaW50J1xufVxuXG4vKipcbiAqIENoZWNrIGlmIGEgdmFsdWUgaXMgZXhpc3RzLlxuICogQHBhcmFtIHsqfSB4IFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSB2YWx1ZSBleGlzdHMsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGV4aXN0cyh4KSB7XG4gICAgcmV0dXJuIHggIT09IHVuZGVmaW5lZCAmJiB4ICE9PSBudWxsO1xufVxuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGRpbWVuc2lvbnMgb2YgYSBuZXN0ZWQgYXJyYXkuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYXJyIFRoZSBuZXN0ZWQgYXJyYXkgdG8gY2FsY3VsYXRlIGRpbWVuc2lvbnMgZm9yLlxuICogQHJldHVybnMge0FycmF5fSBBbiBhcnJheSBjb250YWluaW5nIHRoZSBkaW1lbnNpb25zIG9mIHRoZSBpbnB1dCBhcnJheS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNhbGN1bGF0ZURpbWVuc2lvbnMoYXJyKSB7XG4gICAgY29uc3QgZGltZW5zaW9ucyA9IFtdO1xuICAgIGxldCBjdXJyZW50ID0gYXJyO1xuICAgIHdoaWxlIChBcnJheS5pc0FycmF5KGN1cnJlbnQpKSB7XG4gICAgICAgIGRpbWVuc2lvbnMucHVzaChjdXJyZW50Lmxlbmd0aCk7XG4gICAgICAgIGN1cnJlbnQgPSBjdXJyZW50WzBdO1xuICAgIH1cbiAgICByZXR1cm4gZGltZW5zaW9ucztcbn1cblxuLyoqXG4gKiBSZXBsaWNhdGUgcHl0aG9uJ3MgLnBvcCgpIG1ldGhvZCBmb3Igb2JqZWN0cy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCB0byBwb3AgZnJvbS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSB0byBwb3AuXG4gKiBAcGFyYW0geyp9IGRlZmF1bHRWYWx1ZSBUaGUgZGVmYXVsdCB2YWx1ZSB0byByZXR1cm4gaWYgdGhlIGtleSBkb2VzIG5vdCBleGlzdC5cbiAqIEByZXR1cm5zIHsqfSBUaGUgdmFsdWUgb2YgdGhlIHBvcHBlZCBrZXkuXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIGtleSBkb2VzIG5vdCBleGlzdCBhbmQgbm8gZGVmYXVsdCB2YWx1ZSBpcyBwcm92aWRlZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBvcChvYmosIGtleSwgZGVmYXVsdFZhbHVlID0gdW5kZWZpbmVkKSB7XG4gICAgY29uc3QgdmFsdWUgPSBvYmpba2V5XTtcbiAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBkZWxldGUgb2JqW2tleV07XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgaWYgKGRlZmF1bHRWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IEVycm9yKGBLZXkgJHtrZXl9IGRvZXMgbm90IGV4aXN0IGluIG9iamVjdC5gKVxuICAgIH1cbiAgICByZXR1cm4gZGVmYXVsdFZhbHVlO1xufVxuXG4vKipcbiAqIEVmZmljaWVudGx5IG1lcmdlIGFycmF5cywgY3JlYXRpbmcgYSBuZXcgY29weS5cbiAqIEFkYXB0ZWQgZnJvbSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvNjc2ODY0Mi8xMzk4OTA0M1xuICogQHBhcmFtICB7Li4uYW55fSBhcnJzIEFycmF5cyB0byBtZXJnZS5cbiAqIEByZXR1cm5zIFRoZSBtZXJnZWQgYXJyYXkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtZXJnZUFycmF5cyguLi5hcnJzKSB7XG4gICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5jb25jYXQuYXBwbHkoW10sIGFycnMpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@xenova/transformers/src/utils/core.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@xenova/transformers/src/utils/generation.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@xenova/transformers/src/utils/generation.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ForceTokensLogitsProcessor: () => (/* binding */ ForceTokensLogitsProcessor),\n/* harmony export */   ForcedBOSTokenLogitsProcessor: () => (/* binding */ ForcedBOSTokenLogitsProcessor),\n/* harmony export */   ForcedEOSTokenLogitsProcessor: () => (/* binding */ ForcedEOSTokenLogitsProcessor),\n/* harmony export */   GenerationConfig: () => (/* binding */ GenerationConfig),\n/* harmony export */   LogitsProcessor: () => (/* binding */ LogitsProcessor),\n/* harmony export */   LogitsProcessorList: () => (/* binding */ LogitsProcessorList),\n/* harmony export */   NoRepeatNGramLogitsProcessor: () => (/* binding */ NoRepeatNGramLogitsProcessor),\n/* harmony export */   RepetitionPenaltyLogitsProcessor: () => (/* binding */ RepetitionPenaltyLogitsProcessor),\n/* harmony export */   Sampler: () => (/* binding */ Sampler),\n/* harmony export */   SuppressTokensAtBeginLogitsProcessor: () => (/* binding */ SuppressTokensAtBeginLogitsProcessor),\n/* harmony export */   WhisperTimeStampLogitsProcessor: () => (/* binding */ WhisperTimeStampLogitsProcessor)\n/* harmony export */ });\n/* harmony import */ var _tensor_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tensor.js */ \"(ssr)/./node_modules/@xenova/transformers/src/utils/tensor.js\");\n/* harmony import */ var _core_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./core.js */ \"(ssr)/./node_modules/@xenova/transformers/src/utils/core.js\");\n/* harmony import */ var _maths_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./maths.js */ \"(ssr)/./node_modules/@xenova/transformers/src/utils/maths.js\");\n\n/**\n * @file Classes, functions, and utilities for generation.\n * \n * @todo Describe how to create a custom `GenerationConfig`.\n * \n * @module utils/generation\n */\n\n\n\n\n/**\n * A class representing a list of logits processors. A logits processor is a function that modifies the logits\n * output of a language model. This class provides methods for adding new processors and applying all processors to a\n * batch of logits.\n *\n * @extends Callable\n */\nclass LogitsProcessorList extends _core_js__WEBPACK_IMPORTED_MODULE_1__.Callable {\n    /**\n     * Constructs a new instance of `LogitsProcessorList`.\n     */\n    constructor() {\n        super();\n        this.processors = [];\n    }\n\n    /**\n     * Adds a new logits processor to the list.\n     *\n     * @param {LogitsProcessor} item The logits processor function to add.\n     */\n    push(item) {\n        this.processors.push(item);\n    }\n\n    /**\n     * Adds multiple logits processors to the list.\n     *\n     * @param {LogitsProcessor[]} items The logits processor functions to add.\n     */\n    extend(items) {\n        this.processors.push(...items);\n    }\n\n    /**\n     * Applies all logits processors in the list to a batch of logits, modifying them in-place.\n     *\n     * @param {number[]} input_ids The input IDs for the language model.\n     * @param {number[][]} batchedLogits A 2D array of logits, where each row corresponds to a single\n     *                                                input sequence in the batch.\n     */\n    _call(input_ids, batchedLogits) {\n        // NOTE: This is different from the Python code, since vanilla JS does not support vectorized operations. \n        // As a result, we apply each processor to each item in the batch.\n        for (let logits of batchedLogits) {\n            // Modifies logits inplace\n            this.processors.forEach(\n                func => func(input_ids, logits)\n            )\n        }\n    }\n\n    [Symbol.iterator]() {\n        return this.processors.values();\n    }\n}\n\n/**\n * Base class for processing logits.\n * @extends Callable\n */\nclass LogitsProcessor extends _core_js__WEBPACK_IMPORTED_MODULE_1__.Callable {\n    /**\n     * Apply the processor to the input logits.\n     *\n     * @abstract\n     * @param {Array} input_ids The input ids.\n     * @param {Tensor} logits The logits to process.\n     * @throws {Error} Throws an error if `_call` is not implemented in the subclass.\n     */\n    _call(input_ids, logits) {\n        throw Error(\"`_call` should be implemented in a subclass\")\n    }\n}\n\n/**\n * A logits processor that forces a specific token to be generated by the decoder.\n * \n * @extends LogitsProcessor\n */\nclass ForceTokensLogitsProcessor extends LogitsProcessor {\n    /**\n     * Constructs a new instance of `ForceTokensLogitsProcessor`.\n     * \n     * @param {Array} forced_decoder_ids The ids of tokens that should be forced.\n     */\n    constructor(forced_decoder_ids) {\n        super();\n        this.force_token_map = Object.fromEntries(forced_decoder_ids ?? []);\n    }\n\n    /**\n     * Apply the processor to the input logits.\n     *\n     * @param {Array} input_ids The input ids.\n     * @param {Tensor} logits The logits to process.\n     * @returns {Tensor} The processed logits.\n     */\n    _call(input_ids, logits) {\n        let map = this.force_token_map[input_ids.length];\n        if ((0,_core_js__WEBPACK_IMPORTED_MODULE_1__.exists)(map)) { // There exists a mapping\n            logits.data.fill(-Infinity)\n            logits.data[map] = 0;\n        }\n        return logits;\n    }\n}\n\n/**\n * A LogitsProcessor that forces a BOS token at the beginning of the generated sequence.\n * @extends LogitsProcessor\n */\nclass ForcedBOSTokenLogitsProcessor extends LogitsProcessor {\n    /**\n     * Create a ForcedBOSTokenLogitsProcessor.\n     * @param {number} bos_token_id The ID of the beginning-of-sequence token to be forced.\n     */\n    constructor(bos_token_id) {\n        super();\n        this.bos_token_id = bos_token_id;\n    }\n\n    /**\n     * Apply the BOS token forcing to the logits.\n     * @param {Array} input_ids The input IDs.\n     * @param {Object} logits The logits.\n     * @returns {Object} The logits with BOS token forcing.\n     */\n    _call(input_ids, logits) {\n        if (input_ids.length === 1) {\n            logits.data.fill(-Infinity)\n            logits.data[this.bos_token_id] = 0;\n        }\n        return logits;\n    }\n}\n\n/**\n * A logits processor that forces end-of-sequence token probability to 1.\n * \n * @extends LogitsProcessor\n */\nclass ForcedEOSTokenLogitsProcessor extends LogitsProcessor {\n    /**\n     * Create a ForcedEOSTokenLogitsProcessor.\n     * @param {number} max_length Max length of the sequence.\n     * @param {number|number[]} forced_eos_token_id The ID of the end-of-sequence token to be forced.\n     */\n    constructor(max_length, forced_eos_token_id) {\n        super();\n        this.max_length = max_length;\n        this.forced_eos_token_id = forced_eos_token_id;\n    }\n\n    /**\n     * Apply the processor to input_ids and logits.\n     * \n     * @param {number[]} input_ids The input ids.\n     * @param {Tensor} logits The logits tensor.\n     */\n    _call(input_ids, logits) {\n        // console.log('call ForcedEOSTokenLogitsProcessor')\n        // TODO\n    }\n}\n\n/**\n * A LogitsProcessor that suppresses a list of tokens as soon as the `generate` function starts\n * generating using `begin_index` tokens. This should ensure that the tokens defined by\n * `begin_suppress_tokens` at not sampled at the begining of the generation.\n * @extends LogitsProcessor\n */\nclass SuppressTokensAtBeginLogitsProcessor extends LogitsProcessor {\n    /**\n     * Create a SuppressTokensAtBeginLogitsProcessor.\n     * @param {number[]} begin_suppress_tokens The IDs of the tokens to suppress.\n     * @param {number} begin_index The number of tokens to generate before suppressing tokens.\n     */\n    constructor(begin_suppress_tokens, begin_index) {\n        super();\n        this.begin_suppress_tokens = begin_suppress_tokens;\n        this.begin_index = begin_index;\n    }\n\n    /**\n     * Apply the BOS token forcing to the logits.\n     * @param {Array} input_ids The input IDs.\n     * @param {Object} logits The logits.\n     * @returns {Object} The logits with BOS token forcing.\n     */\n    _call(input_ids, logits) {\n        if (input_ids.length === this.begin_index) {\n            for (let token_id of this.begin_suppress_tokens) {\n                logits.data[token_id] = -Infinity;\n            }\n        }\n        return logits;\n    }\n}\n\n/**\n * A LogitsProcessor that handles adding timestamps to generated text.\n * @extends LogitsProcessor\n */\nclass WhisperTimeStampLogitsProcessor extends LogitsProcessor {\n    /**\n     * Constructs a new WhisperTimeStampLogitsProcessor.\n     * @param {Object} generate_config The config object passed to the `generate()` method of a transformer model.\n     * @param {number} generate_config.eos_token_id The ID of the end-of-sequence token.\n     * @param {number} generate_config.no_timestamps_token_id The ID of the token used to indicate that a token should not have a timestamp.\n     * @param {number[][]} [generate_config.forced_decoder_ids] An array of two-element arrays representing decoder IDs that are forced to appear in the output. The second element of each array indicates whether the token is a timestamp.\n     * @param {number} [generate_config.max_initial_timestamp_index] The maximum index at which an initial timestamp can appear.\n     */\n    constructor(generate_config) {\n        super();\n        this.eos_token_id = generate_config.eos_token_id;\n        this.no_timestamps_token_id = generate_config.no_timestamps_token_id;\n        this.timestamp_begin = this.no_timestamps_token_id + 1;\n\n        this.begin_index = (generate_config.forced_decoder_ids || []).length + 2;\n        if (generate_config.forced_decoder_ids.slice(-1)[0][1] === this.no_timestamps_token_id) {\n            this.begin_index -= 1;\n        }\n        this.max_initial_timestamp_index = generate_config.max_initial_timestamp_index;\n\n    }\n\n    /**\n     * Modify the logits to handle timestamp tokens.\n     * @param {Array} input_ids The input sequence of tokens.\n     * @param {Tensor} logits The logits output by the model.\n     * @returns {Tensor} The modified logits.\n     */\n    _call(input_ids, logits) {\n        // suppress <|notimestamps|> which is handled by without_timestamps\n        logits.data[this.no_timestamps_token_id] = -Infinity;\n\n        if (input_ids.length === this.begin_index - 1) {\n            logits.data.fill(-Infinity);\n            logits.data[this.timestamp_begin] = 0;\n            return logits;\n        }\n\n        // timestamps have to appear in pairs, except directly before eos_token; mask logits accordingly\n        const seq = input_ids.slice(this.begin_index);\n        const last_was_timestamp = seq.length >= 1 && seq[seq.length - 1] >= this.timestamp_begin;\n        const penultimate_was_timestamp = seq.length < 2 || seq[seq.length - 2] >= this.timestamp_begin;\n\n        if (last_was_timestamp) {\n            if (penultimate_was_timestamp) { // has to be non-timestamp\n                logits.data.subarray(this.timestamp_begin).fill(-Infinity);\n            } else { // cannot be normal text tokens\n                logits.data.subarray(0, this.eos_token_id).fill(-Infinity);\n            }\n        }\n\n        // apply the `max_initial_timestamp` option\n        if (input_ids.length === this.begin_index && this.max_initial_timestamp_index !== null) {\n            const last_allowed = this.timestamp_begin + this.max_initial_timestamp_index;\n            logits.data.subarray(last_allowed + 1).fill(-Infinity);\n        }\n\n        // if sum of probability over timestamps is above any other token, sample timestamp\n        const logprobs = (0,_maths_js__WEBPACK_IMPORTED_MODULE_2__.log_softmax)(logits.data);\n        const timestamp_logprob = Math.log(logprobs.subarray(this.timestamp_begin).map(Math.exp).reduce((a, b) => a + b));\n        const max_text_token_logprob = (0,_maths_js__WEBPACK_IMPORTED_MODULE_2__.max)(logprobs.subarray(0, this.timestamp_begin))[0];\n\n        if (timestamp_logprob > max_text_token_logprob) {\n            logits.data.subarray(0, this.timestamp_begin).fill(-Infinity);\n        }\n\n        return logits;\n    }\n}\n\n/**\n * A logits processor that disallows ngrams of a certain size to be repeated.\n * \n * @extends LogitsProcessor\n */\nclass NoRepeatNGramLogitsProcessor extends LogitsProcessor {\n    /**\n     * Create a NoRepeatNGramLogitsProcessor.\n     * @param {number} no_repeat_ngram_size The no-repeat-ngram size. All ngrams of this size can only occur once.\n     */\n    constructor(no_repeat_ngram_size) {\n        super();\n        this.no_repeat_ngram_size = no_repeat_ngram_size;\n    }\n\n    /**\n     * Generate n-grams from a sequence of token ids.\n     * @param {number[]} prevInputIds List of previous input ids\n     * @returns {Map<string, number[]>} Map of generated n-grams\n     */\n    getNgrams(prevInputIds) {\n        const curLen = prevInputIds.length;\n\n        /**@type {number[][]} */\n        const ngrams = [];\n        for (let j = 0; j < curLen + 1 - this.no_repeat_ngram_size; ++j) {\n            const ngram = [];\n            for (let k = 0; k < this.no_repeat_ngram_size; ++k) {\n                ngram.push(prevInputIds[j + k]);\n            }\n            ngrams.push(ngram);\n        }\n\n        /** @type {Map<string, number[]>} */\n        const generatedNgram = new Map();\n        for (const ngram of ngrams) {\n            const prevNgram = ngram.slice(0, ngram.length - 1);\n            const prevNgramKey = JSON.stringify(prevNgram);\n            const prevNgramValue = generatedNgram.get(prevNgramKey) ?? [];\n            prevNgramValue.push(ngram[ngram.length - 1]);\n            generatedNgram.set(prevNgramKey, prevNgramValue);\n        }\n        return generatedNgram;\n    }\n\n    /**\n     * Generate n-grams from a sequence of token ids.\n     * @param {Map<string, number[]>} bannedNgrams Map of banned n-grams\n     * @param {number[]} prevInputIds List of previous input ids\n     * @returns {number[]} Map of generated n-grams\n     */\n    getGeneratedNgrams(bannedNgrams, prevInputIds) {\n        const ngramIdx = prevInputIds.slice(prevInputIds.length + 1 - this.no_repeat_ngram_size, prevInputIds.length);\n        const banned = bannedNgrams.get(JSON.stringify(ngramIdx)) ?? [];\n        return banned;\n    }\n\n    /**\n     * Calculate banned n-gram tokens\n     * @param {number[]} prevInputIds List of previous input ids\n     * @returns {number[]} Map of generated n-grams\n     */\n    calcBannedNgramTokens(prevInputIds) {\n        const bannedTokens = [];\n        if (prevInputIds.length + 1 < this.no_repeat_ngram_size) {\n            // return no banned tokens if we haven't generated no_repeat_ngram_size tokens yet\n            return bannedTokens;\n\n        } else {\n            const generatedNgrams = this.getNgrams(prevInputIds);\n            const bannedTokens = this.getGeneratedNgrams(generatedNgrams, prevInputIds);\n            return bannedTokens;\n        }\n    }\n\n    /**\n     * Apply the no-repeat-ngram processor to the logits.\n     * @param {Array} input_ids The input IDs.\n     * @param {Object} logits The logits.\n     * @returns {Object} The logits with no-repeat-ngram processing.\n     */\n    _call(input_ids, logits) {\n        const bannedTokens = this.calcBannedNgramTokens(input_ids);\n\n        for (const token of bannedTokens) {\n            logits.data[token] = -Infinity;\n        }\n        return logits;\n    }\n}\n\n/**\n * A logits processor that penalises repeated output tokens.\n * \n * @extends LogitsProcessor\n */\nclass RepetitionPenaltyLogitsProcessor extends LogitsProcessor {\n    /**\n     * Create a RepetitionPenaltyLogitsProcessor.\n     * @param {number} penalty The penalty to apply for repeated tokens.\n     */\n    constructor(penalty) {\n        super();\n        this.penalty = penalty;\n    }\n\n    /**\n     * Apply the repetition penalty to the logits.\n     * @param {Array} input_ids The input IDs.\n     * @param {Object} logits The logits.\n     * @returns {Object} The logits with repetition penalty processing.\n     */\n    _call(input_ids, logits) {\n        // Modify the logits corresponding to each element in `input_ids`.\n        // As a consequence, the logits corresponding to tokens that appear\n        // many times in the output will be penalised more.\n        for (const input_id of input_ids) {\n            if (logits.data[input_id] < 0) {\n                logits.data[input_id] *= this.penalty;\n            } else {\n                logits.data[input_id] /= this.penalty;\n            }\n        }\n        return logits\n    }\n}\n\n/**\n * Class that holds a configuration for a generation task.\n */\nclass GenerationConfig {\n    /**\n     * Create a GenerationConfig object\n     * @param {Object} [kwargs={}] The configuration parameters. If not set, the default values are used.\n     * @param {number} [kwargs.max_length=20] The maximum length the generated tokens can have. Corresponds to the length of the input prompt + `max_new_tokens`. Its effect is overridden by `max_new_tokens`, if also set.\n     * @param {number} [kwargs.max_new_tokens=null] The maximum numbers of tokens to generate, ignoring the number of tokens in the prompt.\n     * @param {number} [kwargs.min_length=0] The minimum length of the sequence to be generated. Corresponds to the length of the input prompt + `min_new_tokens`. Its effect is overridden by `min_new_tokens`, if also set.\n     * @param {number} [kwargs.min_new_tokens=null] The minimum numbers of tokens to generate, ignoring the number of tokens in the prompt.\n     * @param {boolean|\"never\"} [kwargs.early_stopping=false] Controls the stopping condition for beam-based methods, like beam-search. It accepts the following values:\n     * - `true`, where the generation stops as soon as there are `num_beams` complete candidates;\n     * - `false`, where an heuristic is applied and the generation stops when is it very unlikely to find better candidates;\n     * - `\"never\"`, where the beam search procedure only stops when there cannot be better candidates (canonical beam search algorithm).\n     * @param {number} [kwargs.max_time=null] The maximum amount of time you allow the computation to run for in seconds. Generation will still finish the current pass after allocated time has been passed.\n     *\n     * @param {boolean} [kwargs.do_sample=false] Whether or not to use sampling; use greedy decoding otherwise.\n     * @param {number} [kwargs.num_beams=1] Number of beams for beam search. 1 means no beam search.\n     * @param {number} [kwargs.num_beam_groups=1] Number of groups to divide `num_beams` into in order to ensure diversity among different groups of beams. See [this paper](https://arxiv.org/pdf/1610.02424.pdf) for more details.\n     * @param {number} [kwargs.penalty_alpha=null] The values balance the model confidence and the degeneration penalty in contrastive search decoding.\n     * @param {boolean} [kwargs.use_cache=true] Whether or not the model should use the past last key/values attentions (if applicable to the model) to speed up decoding.\n     *\n     * @param {number} [kwargs.temperature=1.0] The value used to modulate the next token probabilities.\n     * @param {number} [kwargs.top_k=50] The number of highest probability vocabulary tokens to keep for top-k-filtering.\n     * @param {number} [kwargs.top_p=1.0] If set to float < 1, only the smallest set of most probable tokens with probabilities that add up to `top_p` or higher are kept for generation.\n     * @param {number} [kwargs.typical_p=1.0] Local typicality measures how similar the conditional probability of predicting a target token next is to the expected conditional probability of predicting a random token next, given the partial text already generated. If set to float < 1, the smallest set of the most locally typical tokens with probabilities that add up to `typical_p` or higher are kept for generation. See [this paper](https://arxiv.org/pdf/2202.00666.pdf) for more details.\n     * @param {number} [kwargs.epsilon_cutoff=0.0] If set to float strictly between 0 and 1, only tokens with a conditional probability greater than `epsilon_cutoff` will be sampled. In the paper, suggested values range from 3e-4 to 9e-4, depending on the size of the model. See [Truncation Sampling as Language Model Desmoothing](https://arxiv.org/abs/2210.15191) for more details.\n     * @param {number} [kwargs.eta_cutoff=0.0] Eta sampling is a hybrid of locally typical sampling and epsilon sampling. If set to float strictly between 0 and 1, a token is only considered if it is greater than either `eta_cutoff` or `sqrt(eta_cutoff) * exp(-entropy(softmax(next_token_logits)))`. The latter term is intuitively the expected next token probability, scaled by `sqrt(eta_cutoff)`. In the paper, suggested values range from 3e-4 to 2e-3, depending on the size of the model. See [Truncation Sampling as Language Model Desmoothing](https://arxiv.org/abs/2210.15191) for more details.\n     * @param {number} [kwargs.diversity_penalty=0.0] This value is subtracted from a beam's score if it generates a token same as any beam from other group at a particular time. Note that `diversity_penalty` is only effective if `group beam search` is enabled.\n     * @param {number} [kwargs.repetition_penalty=1.0] The parameter for repetition penalty. 1.0 means no penalty. See [this paper](https://arxiv.org/pdf/1909.05858.pdf) for more details.\n     * @param {number} [kwargs.encoder_repetition_penalty=1.0] The paramater for encoder_repetition_penalty. An exponential penalty on sequences that are not in the original input. 1.0 means no penalty.\n     * @param {number} [kwargs.length_penalty=1.0] Exponential penalty to the length that is used with beam-based generation. It is applied as an exponent to the sequence length, which in turn is used to divide the score of the sequence. Since the score is the log likelihood of the sequence (i.e. negative), `length_penalty` > 0.0 promotes longer sequences, while `length_penalty` < 0.0 encourages shorter sequences.\n     * @param {number} [kwargs.no_repeat_ngram_size=0] If set to int > 0, all ngrams of that size can only occur once.\n     * @param {number[][]} [kwargs.bad_words_ids=null] List of token ids that are not allowed to be generated. In order to get the token ids of the words that should not appear in the generated text, use `(await tokenizer(bad_words, {add_prefix_space: true, add_special_tokens: false})).input_ids`.\n     * @param {number[][]|number[][][]} [kwargs.force_words_ids=null] List of token ids that must be generated. If given a `number[][]`, this is treated as a simple list of words that must be included, the opposite to `bad_words_ids`. If given `number[][][]`, this triggers a [disjunctive constraint](https://github.com/huggingface/transformers/issues/14081), where one can allow different forms of each word.\n     * @param {boolean} [kwargs.renormalize_logits=false] Whether to renormalize the logits after applying all the logits processors or warpers (including the custom ones). It's highly recommended to set this flag to `true` as the search algorithms suppose the score logits are normalized but some logit processors or warpers break the normalization.\n     * @param {Object[]} [kwargs.constraints=null] Custom constraints that can be added to the generation to ensure that the output will contain the use of certain tokens as defined by `Constraint` objects, in the most sensible way possible.\n     * \n     * @param {number} [kwargs.forced_bos_token_id=null] The id of the token to force as the first generated token after the `decoder_start_token_id`. Useful for multilingual models like mBART where the first generated token needs to be the target language token.\n     * @param {number|number[]} [kwargs.forced_eos_token_id=null] The id of the token to force as the last generated token when `max_length` is reached. Optionally, use a list to set multiple *end-of-sequence* tokens.\n     * @param {boolean} [kwargs.remove_invalid_values=false] Whether to remove possible *nan* and *inf* outputs of the model to prevent the generation method to crash. Note that using `remove_invalid_values` can slow down generation.\n     * @param {number[]} [kwargs.exponential_decay_length_penalty=null] This Tuple adds an exponentially increasing length penalty, after a certain amount of tokens have been generated. The tuple shall consist of: `(start_index, decay_factor)` where `start_index` indicates where penalty starts and `decay_factor` represents the factor of exponential decay.\n     * @param {number[]} [kwargs.suppress_tokens=null] A list of tokens that will be suppressed at generation. The `SupressTokens` logit processor will set their log probs to `-inf` so that they are not sampled.\n     * @param {number[]} [kwargs.begin_suppress_tokens=null] A list of tokens that will be suppressed at the beginning of the generation. The `SupressBeginTokens` logit processor will set their log probs to `-inf` so that they are not sampled.\n     * @param {number[][]} [kwargs.forced_decoder_ids=null] A list of pairs of integers which indicates a mapping from generation indices to token indices that will be forced before sampling. For example, `[[1, 123]]` means the second generated token will always be a token of index 123.\n     * \n     * @param {number} [kwargs.num_return_sequences=1] The number of independently computed returned sequences for each element in the batch.\n     * @param {boolean} [kwargs.output_attentions=false] Whether or not to return the attentions tensors of all attention layers. See `attentions` under returned tensors for more details.\n     * @param {boolean} [kwargs.output_hidden_states=false] Whether or not to return the hidden states of all layers. See `hidden_states` under returned tensors for more details.\n     * @param {boolean} [kwargs.output_scores=false] Whether or not to return the prediction scores. See `scores` under returned tensors for more details.\n     * @param {boolean} [kwargs.return_dict_in_generate=false] Whether or not to return a `ModelOutput` instead of a plain tuple.\n     * \n     * @param {number} [kwargs.pad_token_id=null] The id of the *padding* token.\n     * @param {number} [kwargs.bos_token_id=null] The id of the *beginning-of-sequence* token.\n     * @param {number|number[]} [kwargs.eos_token_id=null] The id of the *end-of-sequence* token. Optionally, use a list to set multiple *end-of-sequence* tokens.\n     * \n     * @param {number} [kwargs.encoder_no_repeat_ngram_size=0] If set to int > 0, all ngrams of that size that occur in the `encoder_input_ids` cannot occur in the `decoder_input_ids`.\n     * @param {number} [kwargs.decoder_start_token_id=null] If an encoder-decoder model starts decoding with a different token than *bos*, the id of that token.\n     * \n     * @param {Object} [kwargs.generation_kwargs={}] Additional generation kwargs will be forwarded to the `generate` function of the model. Kwargs that are not present in `generate`'s signature will be used in the model forward pass.\n     */\n    constructor(kwargs = {}) {\n        // Parameters that control the length of the output\n        this.max_length = kwargs.max_length ?? 20;\n        this.max_new_tokens = kwargs.max_new_tokens ?? null;\n        this.min_length = kwargs.min_length ?? 0;\n        this.min_new_tokens = kwargs.min_new_tokens ?? null;\n        this.early_stopping = kwargs.early_stopping ?? false;\n        this.max_time = kwargs.max_time ?? null;\n\n        // Parameters that control the generation strategy used\n        this.do_sample = kwargs.do_sample ?? false;\n        this.num_beams = kwargs.num_beams ?? 1;\n        this.num_beam_groups = kwargs.num_beam_groups ?? 1;\n        this.penalty_alpha = kwargs.penalty_alpha ?? null;\n        this.use_cache = kwargs.use_cache ?? true;\n\n        // Parameters for manipulation of the model output logits\n        this.temperature = kwargs.temperature ?? 1.0;\n        this.top_k = kwargs.top_k ?? 50;\n        this.top_p = kwargs.top_p ?? 1.0;\n        this.typical_p = kwargs.typical_p ?? 1.0;\n        this.epsilon_cutoff = kwargs.epsilon_cutoff ?? 0.0;\n        this.eta_cutoff = kwargs.eta_cutoff ?? 0.0;\n        this.diversity_penalty = kwargs.diversity_penalty ?? 0.0;\n        this.repetition_penalty = kwargs.repetition_penalty ?? 1.0;\n        this.encoder_repetition_penalty = kwargs.encoder_repetition_penalty ?? 1.0;\n        this.length_penalty = kwargs.length_penalty ?? 1.0;\n        this.no_repeat_ngram_size = kwargs.no_repeat_ngram_size ?? 0;\n        this.bad_words_ids = kwargs.bad_words_ids ?? null;\n        this.force_words_ids = kwargs.force_words_ids ?? null;\n        this.renormalize_logits = kwargs.renormalize_logits ?? false;\n        this.constraints = kwargs.constraints ?? null;\n        this.forced_bos_token_id = kwargs.forced_bos_token_id ?? null;\n        this.forced_eos_token_id = kwargs.forced_eos_token_id ?? null;\n        this.remove_invalid_values = kwargs.remove_invalid_values ?? false;\n        this.exponential_decay_length_penalty = kwargs.exponential_decay_length_penalty ?? null;\n        this.suppress_tokens = kwargs.suppress_tokens ?? null;\n        this.begin_suppress_tokens = kwargs.begin_suppress_tokens ?? null;\n        this.forced_decoder_ids = kwargs.forced_decoder_ids ?? null;\n\n        // Parameters that define the output variables of `generate`\n        this.num_return_sequences = kwargs.num_return_sequences ?? 1;\n        this.output_attentions = kwargs.output_attentions ?? false;\n        this.output_hidden_states = kwargs.output_hidden_states ?? false;\n        this.output_scores = kwargs.output_scores ?? false;\n        this.return_dict_in_generate = kwargs.return_dict_in_generate ?? false;\n\n        // Special tokens that can be used at generation time\n        this.pad_token_id = kwargs.pad_token_id ?? null;\n        this.bos_token_id = kwargs.bos_token_id ?? null;\n        this.eos_token_id = kwargs.eos_token_id ?? null;\n\n        // Generation parameters exclusive to encoder-decoder models\n        this.encoder_no_repeat_ngram_size = kwargs.encoder_no_repeat_ngram_size ?? 0;\n        this.decoder_start_token_id = kwargs.decoder_start_token_id ?? null;\n\n        // Wild card\n        this.generation_kwargs = kwargs.generation_kwargs ?? {};\n    }\n}\n\n\n/**\n * Sampler is a base class for all sampling methods used for text generation.\n */\nclass Sampler extends _core_js__WEBPACK_IMPORTED_MODULE_1__.Callable {\n    /**\n     * Creates a new Sampler object with the specified generation config.\n     * @param {GenerationConfig} generation_config The generation config.\n     */\n    constructor(generation_config) {\n        super();\n        this.generation_config = generation_config;\n    }\n\n    /**\n     * Executes the sampler, using the specified logits.\n     * @param {Tensor} logits\n     * @param {number} index\n     * @returns {void}\n     */\n    _call(logits, index = -1) {\n        // Sample from logits, of dims [batch, sequence_length, vocab_size].\n        // If index is specified, sample from [batch, index, vocab_size].\n        return this.sample(logits, index);\n    }\n\n    /**\n     * Abstract method for sampling the logits.\n     * @param {Tensor} logits\n     * @param {number} index\n     * @throws {Error}\n     */\n    sample(logits, index) {\n        throw Error(\"sample should be implemented in subclasses.\")\n    }\n\n    /**\n     * Returns the specified logits as an array, with temperature applied.\n     * @param {Tensor} logits\n     * @param {number} index\n     * @returns {Array}\n     */\n    getLogits(logits, index) {\n        let vocabSize = logits.dims.at(-1);\n\n        let logs = logits.data;\n\n        if (index === -1) {\n            logs = logs.slice(-vocabSize);\n        } else {\n            let startIndex = index * vocabSize;\n            logs = logs.slice(startIndex, startIndex + vocabSize);\n        }\n\n        // add temperature\n        if (this.generation_config.temperature > 0) {\n            logs = logs.map(x => x / this.generation_config.temperature)\n        }\n        return logs;\n    }\n\n    /**\n     * Selects an item randomly based on the specified probabilities.\n     * @param {Array} probabilities An array of probabilities to use for selection.\n     * @returns {number} The index of the selected item.\n     */\n    randomSelect(probabilities) {\n        // Return index of chosen item\n        let sumProbabilities = probabilities.reduce((acc, curr) => acc + curr, 0);\n\n        let r = Math.random() * sumProbabilities;\n        for (let i = 0; i < probabilities.length; ++i) {\n            r -= probabilities[i];\n            if (r <= 0) {\n                return i;\n            }\n        }\n        return 0; // return first (most probable) as a fallback\n    }\n\n    /**\n     * Returns a Sampler object based on the specified options.\n     * @param {GenerationConfig} generation_config An object containing options for the sampler.\n     * @returns {Sampler} A Sampler object.\n     */\n    static getSampler(generation_config) {\n        // - *greedy decoding*: `num_beams=1` and `do_sample=False`\n        // - *contrastive search*: `penalty_alpha>0` and `top_k>1`\n        // - *multinomial sampling*: `num_beams=1` and `do_sample=True`\n        // - *beam-search decoding*: `num_beams>1` and `do_sample=False`\n        // - *beam-search multinomial sampling*: `num_beams>1` and `do_sample=True`\n        // - *diverse beam-search decoding*: `num_beams>1` and `num_beam_groups>1`\n        // - *constrained beam-search decoding*: `constraints!=None` or `force_words_ids!=None`\n\n        // NOTE: beam search is implemented directly into the generation function\n        if (generation_config.do_sample) {\n            return new MultinomialSampler(generation_config);\n\n        } else if (generation_config.num_beams > 1) {\n            return new BeamSearchSampler(generation_config);\n\n        } else {\n            if (generation_config.num_return_sequences > 1) {\n                throw Error(`num_return_sequences has to be 1 when doing greedy search, but is ${generation_config.num_return_sequences}.`)\n            }\n            return new GreedySampler(generation_config);\n        }\n    }\n}\n\n/**\n * Class representing a Greedy Sampler.\n * @extends Sampler\n */\nclass GreedySampler extends Sampler {\n    /**\n     * Sample the maximum probability of a given logits tensor.\n     * @param {Tensor} logits\n     * @param {number} [index=-1]\n     * @returns {Array} An array with a single tuple, containing the index of the maximum value and a meaningless score (since this is a greedy search).\n     */\n    sample(logits, index = -1) {\n        // NOTE: no need to do log_softmax here since we only take the maximum\n        let logs = this.getLogits(logits, index);\n        let argmax = (0,_maths_js__WEBPACK_IMPORTED_MODULE_2__.max)(logs)[1];\n\n        // Note: score is meaningless in this context, since we are performing\n        // greedy search (p = 1 => log(p) = 0)\n        return [\n            [argmax, 0]\n        ];\n    }\n}\n\n/**\n * Class representing a MultinomialSampler.\n * @extends Sampler\n */\nclass MultinomialSampler extends Sampler {\n\n    /**\n     * Sample from the logits.\n     * @param {Tensor} logits\n     * @param {number} index\n     * @returns {Array}\n     */\n    sample(logits, index = -1) {\n        let k = logits.dims.at(-1); // defaults to vocab size\n        if (this.generation_config.top_k > 0) {\n            k = Math.min(this.generation_config.top_k, k);\n        }\n\n        // Get logits of nth token\n        const logs = this.getLogits(logits, index);\n\n        // Get top k tokens\n        const topLogits = (0,_maths_js__WEBPACK_IMPORTED_MODULE_2__.getTopItems)(logs, k);\n\n        // Compute softmax over logits\n        const probabilities = (0,_maths_js__WEBPACK_IMPORTED_MODULE_2__.softmax)(topLogits.map(x => x[1]));\n\n        return Array.from({ length: this.generation_config.num_beams }, () => {\n            const sampledIndex = this.randomSelect(probabilities);\n            return [\n                topLogits[sampledIndex][0], // token id\n                Math.log(probabilities[sampledIndex]), // score\n            ];\n        });\n    }\n}\n\n\n/**\n * Class representing a BeamSearchSampler.\n * @extends Sampler\n */\nclass BeamSearchSampler extends Sampler {\n\n    /**\n     * Sample from the logits.\n     * @param {Tensor} logits\n     * @param {number} index\n     * @returns {Array}\n     */\n    sample(logits, index = -1) {\n        let k = logits.dims.at(-1); // defaults to vocab size\n        if (this.generation_config.top_k > 0) {\n            k = Math.min(this.generation_config.top_k, k);\n        }\n\n        // Get logits of nth token\n        const logs = this.getLogits(logits, index);\n\n        // Get top k tokens\n        const topLogits = (0,_maths_js__WEBPACK_IMPORTED_MODULE_2__.getTopItems)(logs, k);\n\n        // Compute softmax over logits\n        const probabilities = (0,_maths_js__WEBPACK_IMPORTED_MODULE_2__.softmax)(topLogits.map(x => x[1]));\n\n        return Array.from({ length: this.generation_config.num_beams }, (_, i) => {\n            return [\n                topLogits[i][0], // token id\n                Math.log(probabilities[i]), // score\n            ];\n        });\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHhlbm92YS90cmFuc2Zvcm1lcnMvc3JjL3V0aWxzL2dlbmVyYXRpb24uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDcUM7QUFJbEI7QUFNQzs7QUFFcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxrQ0FBa0MsOENBQVE7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxpQkFBaUI7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxtQkFBbUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCLGVBQWUsWUFBWTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDTyw4QkFBOEIsOENBQVE7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxRQUFRO0FBQ3ZCLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQSxZQUFZLGdEQUFNLFNBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0EsZUFBZSxR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QUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxVQUFVO0FBQ1Y7O0FBRUEsVUFBVTtBQUNWO0FBQ0EsaUdBQWlHLHVDQUF1QztBQUN4STtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiw4Q0FBRzs7QUFFeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQixzREFBVzs7QUFFckM7QUFDQSw4QkFBOEIsa0RBQU87O0FBRXJDLDRCQUE0QiwwQ0FBMEM7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsMEJBQTBCLHNEQUFXOztBQUVyQztBQUNBLDhCQUE4QixrREFBTzs7QUFFckMsNEJBQTRCLDBDQUEwQztBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdHJhbnNmb3JtZXJzanMtcGxheWdyb3VuZC8uL25vZGVfbW9kdWxlcy9AeGVub3ZhL3RyYW5zZm9ybWVycy9zcmMvdXRpbHMvZ2VuZXJhdGlvbi5qcz9lZDgzIl0sInNvdXJjZXNDb250ZW50IjpbIlxuLyoqXG4gKiBAZmlsZSBDbGFzc2VzLCBmdW5jdGlvbnMsIGFuZCB1dGlsaXRpZXMgZm9yIGdlbmVyYXRpb24uXG4gKiBcbiAqIEB0b2RvIERlc2NyaWJlIGhvdyB0byBjcmVhdGUgYSBjdXN0b20gYEdlbmVyYXRpb25Db25maWdgLlxuICogXG4gKiBAbW9kdWxlIHV0aWxzL2dlbmVyYXRpb25cbiAqL1xuaW1wb3J0IHsgVGVuc29yIH0gZnJvbSAnLi90ZW5zb3IuanMnO1xuaW1wb3J0IHtcbiAgICBDYWxsYWJsZSxcbiAgICBleGlzdHMsXG59IGZyb20gJy4vY29yZS5qcyc7XG5pbXBvcnQge1xuICAgIG1heCxcbiAgICBzb2Z0bWF4LFxuICAgIGxvZ19zb2Z0bWF4LFxuICAgIGdldFRvcEl0ZW1zLFxufSBmcm9tICcuL21hdGhzLmpzJztcblxuLyoqXG4gKiBBIGNsYXNzIHJlcHJlc2VudGluZyBhIGxpc3Qgb2YgbG9naXRzIHByb2Nlc3NvcnMuIEEgbG9naXRzIHByb2Nlc3NvciBpcyBhIGZ1bmN0aW9uIHRoYXQgbW9kaWZpZXMgdGhlIGxvZ2l0c1xuICogb3V0cHV0IG9mIGEgbGFuZ3VhZ2UgbW9kZWwuIFRoaXMgY2xhc3MgcHJvdmlkZXMgbWV0aG9kcyBmb3IgYWRkaW5nIG5ldyBwcm9jZXNzb3JzIGFuZCBhcHBseWluZyBhbGwgcHJvY2Vzc29ycyB0byBhXG4gKiBiYXRjaCBvZiBsb2dpdHMuXG4gKlxuICogQGV4dGVuZHMgQ2FsbGFibGVcbiAqL1xuZXhwb3J0IGNsYXNzIExvZ2l0c1Byb2Nlc3Nvckxpc3QgZXh0ZW5kcyBDYWxsYWJsZSB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0cyBhIG5ldyBpbnN0YW5jZSBvZiBgTG9naXRzUHJvY2Vzc29yTGlzdGAuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMucHJvY2Vzc29ycyA9IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBuZXcgbG9naXRzIHByb2Nlc3NvciB0byB0aGUgbGlzdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TG9naXRzUHJvY2Vzc29yfSBpdGVtIFRoZSBsb2dpdHMgcHJvY2Vzc29yIGZ1bmN0aW9uIHRvIGFkZC5cbiAgICAgKi9cbiAgICBwdXNoKGl0ZW0pIHtcbiAgICAgICAgdGhpcy5wcm9jZXNzb3JzLnB1c2goaXRlbSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkcyBtdWx0aXBsZSBsb2dpdHMgcHJvY2Vzc29ycyB0byB0aGUgbGlzdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TG9naXRzUHJvY2Vzc29yW119IGl0ZW1zIFRoZSBsb2dpdHMgcHJvY2Vzc29yIGZ1bmN0aW9ucyB0byBhZGQuXG4gICAgICovXG4gICAgZXh0ZW5kKGl0ZW1zKSB7XG4gICAgICAgIHRoaXMucHJvY2Vzc29ycy5wdXNoKC4uLml0ZW1zKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIGFsbCBsb2dpdHMgcHJvY2Vzc29ycyBpbiB0aGUgbGlzdCB0byBhIGJhdGNoIG9mIGxvZ2l0cywgbW9kaWZ5aW5nIHRoZW0gaW4tcGxhY2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcltdfSBpbnB1dF9pZHMgVGhlIGlucHV0IElEcyBmb3IgdGhlIGxhbmd1YWdlIG1vZGVsLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyW11bXX0gYmF0Y2hlZExvZ2l0cyBBIDJEIGFycmF5IG9mIGxvZ2l0cywgd2hlcmUgZWFjaCByb3cgY29ycmVzcG9uZHMgdG8gYSBzaW5nbGVcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0IHNlcXVlbmNlIGluIHRoZSBiYXRjaC5cbiAgICAgKi9cbiAgICBfY2FsbChpbnB1dF9pZHMsIGJhdGNoZWRMb2dpdHMpIHtcbiAgICAgICAgLy8gTk9URTogVGhpcyBpcyBkaWZmZXJlbnQgZnJvbSB0aGUgUHl0aG9uIGNvZGUsIHNpbmNlIHZhbmlsbGEgSlMgZG9lcyBub3Qgc3VwcG9ydCB2ZWN0b3JpemVkIG9wZXJhdGlvbnMuIFxuICAgICAgICAvLyBBcyBhIHJlc3VsdCwgd2UgYXBwbHkgZWFjaCBwcm9jZXNzb3IgdG8gZWFjaCBpdGVtIGluIHRoZSBiYXRjaC5cbiAgICAgICAgZm9yIChsZXQgbG9naXRzIG9mIGJhdGNoZWRMb2dpdHMpIHtcbiAgICAgICAgICAgIC8vIE1vZGlmaWVzIGxvZ2l0cyBpbnBsYWNlXG4gICAgICAgICAgICB0aGlzLnByb2Nlc3NvcnMuZm9yRWFjaChcbiAgICAgICAgICAgICAgICBmdW5jID0+IGZ1bmMoaW5wdXRfaWRzLCBsb2dpdHMpXG4gICAgICAgICAgICApXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvY2Vzc29ycy52YWx1ZXMoKTtcbiAgICB9XG59XG5cbi8qKlxuICogQmFzZSBjbGFzcyBmb3IgcHJvY2Vzc2luZyBsb2dpdHMuXG4gKiBAZXh0ZW5kcyBDYWxsYWJsZVxuICovXG5leHBvcnQgY2xhc3MgTG9naXRzUHJvY2Vzc29yIGV4dGVuZHMgQ2FsbGFibGUge1xuICAgIC8qKlxuICAgICAqIEFwcGx5IHRoZSBwcm9jZXNzb3IgdG8gdGhlIGlucHV0IGxvZ2l0cy5cbiAgICAgKlxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGlucHV0X2lkcyBUaGUgaW5wdXQgaWRzLlxuICAgICAqIEBwYXJhbSB7VGVuc29yfSBsb2dpdHMgVGhlIGxvZ2l0cyB0byBwcm9jZXNzLlxuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBUaHJvd3MgYW4gZXJyb3IgaWYgYF9jYWxsYCBpcyBub3QgaW1wbGVtZW50ZWQgaW4gdGhlIHN1YmNsYXNzLlxuICAgICAqL1xuICAgIF9jYWxsKGlucHV0X2lkcywgbG9naXRzKSB7XG4gICAgICAgIHRocm93IEVycm9yKFwiYF9jYWxsYCBzaG91bGQgYmUgaW1wbGVtZW50ZWQgaW4gYSBzdWJjbGFzc1wiKVxuICAgIH1cbn1cblxuLyoqXG4gKiBBIGxvZ2l0cyBwcm9jZXNzb3IgdGhhdCBmb3JjZXMgYSBzcGVjaWZpYyB0b2tlbiB0byBiZSBnZW5lcmF0ZWQgYnkgdGhlIGRlY29kZXIuXG4gKiBcbiAqIEBleHRlbmRzIExvZ2l0c1Byb2Nlc3NvclxuICovXG5leHBvcnQgY2xhc3MgRm9yY2VUb2tlbnNMb2dpdHNQcm9jZXNzb3IgZXh0ZW5kcyBMb2dpdHNQcm9jZXNzb3Ige1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdHMgYSBuZXcgaW5zdGFuY2Ugb2YgYEZvcmNlVG9rZW5zTG9naXRzUHJvY2Vzc29yYC5cbiAgICAgKiBcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBmb3JjZWRfZGVjb2Rlcl9pZHMgVGhlIGlkcyBvZiB0b2tlbnMgdGhhdCBzaG91bGQgYmUgZm9yY2VkLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGZvcmNlZF9kZWNvZGVyX2lkcykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmZvcmNlX3Rva2VuX21hcCA9IE9iamVjdC5mcm9tRW50cmllcyhmb3JjZWRfZGVjb2Rlcl9pZHMgPz8gW10pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFwcGx5IHRoZSBwcm9jZXNzb3IgdG8gdGhlIGlucHV0IGxvZ2l0cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGlucHV0X2lkcyBUaGUgaW5wdXQgaWRzLlxuICAgICAqIEBwYXJhbSB7VGVuc29yfSBsb2dpdHMgVGhlIGxvZ2l0cyB0byBwcm9jZXNzLlxuICAgICAqIEByZXR1cm5zIHtUZW5zb3J9IFRoZSBwcm9jZXNzZWQgbG9naXRzLlxuICAgICAqL1xuICAgIF9jYWxsKGlucHV0X2lkcywgbG9naXRzKSB7XG4gICAgICAgIGxldCBtYXAgPSB0aGlzLmZvcmNlX3Rva2VuX21hcFtpbnB1dF9pZHMubGVuZ3RoXTtcbiAgICAgICAgaWYgKGV4aXN0cyhtYXApKSB7IC8vIFRoZXJlIGV4aXN0cyBhIG1hcHBpbmdcbiAgICAgICAgICAgIGxvZ2l0cy5kYXRhLmZpbGwoLUluZmluaXR5KVxuICAgICAgICAgICAgbG9naXRzLmRhdGFbbWFwXSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxvZ2l0cztcbiAgICB9XG59XG5cbi8qKlxuICogQSBMb2dpdHNQcm9jZXNzb3IgdGhhdCBmb3JjZXMgYSBCT1MgdG9rZW4gYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgZ2VuZXJhdGVkIHNlcXVlbmNlLlxuICogQGV4dGVuZHMgTG9naXRzUHJvY2Vzc29yXG4gKi9cbmV4cG9ydCBjbGFzcyBGb3JjZWRCT1NUb2tlbkxvZ2l0c1Byb2Nlc3NvciBleHRlbmRzIExvZ2l0c1Byb2Nlc3NvciB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgRm9yY2VkQk9TVG9rZW5Mb2dpdHNQcm9jZXNzb3IuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJvc190b2tlbl9pZCBUaGUgSUQgb2YgdGhlIGJlZ2lubmluZy1vZi1zZXF1ZW5jZSB0b2tlbiB0byBiZSBmb3JjZWQuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoYm9zX3Rva2VuX2lkKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuYm9zX3Rva2VuX2lkID0gYm9zX3Rva2VuX2lkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFwcGx5IHRoZSBCT1MgdG9rZW4gZm9yY2luZyB0byB0aGUgbG9naXRzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGlucHV0X2lkcyBUaGUgaW5wdXQgSURzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBsb2dpdHMgVGhlIGxvZ2l0cy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgbG9naXRzIHdpdGggQk9TIHRva2VuIGZvcmNpbmcuXG4gICAgICovXG4gICAgX2NhbGwoaW5wdXRfaWRzLCBsb2dpdHMpIHtcbiAgICAgICAgaWYgKGlucHV0X2lkcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIGxvZ2l0cy5kYXRhLmZpbGwoLUluZmluaXR5KVxuICAgICAgICAgICAgbG9naXRzLmRhdGFbdGhpcy5ib3NfdG9rZW5faWRdID0gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbG9naXRzO1xuICAgIH1cbn1cblxuLyoqXG4gKiBBIGxvZ2l0cyBwcm9jZXNzb3IgdGhhdCBmb3JjZXMgZW5kLW9mLXNlcXVlbmNlIHRva2VuIHByb2JhYmlsaXR5IHRvIDEuXG4gKiBcbiAqIEBleHRlbmRzIExvZ2l0c1Byb2Nlc3NvclxuICovXG5leHBvcnQgY2xhc3MgRm9yY2VkRU9TVG9rZW5Mb2dpdHNQcm9jZXNzb3IgZXh0ZW5kcyBMb2dpdHNQcm9jZXNzb3Ige1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIEZvcmNlZEVPU1Rva2VuTG9naXRzUHJvY2Vzc29yLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtYXhfbGVuZ3RoIE1heCBsZW5ndGggb2YgdGhlIHNlcXVlbmNlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfG51bWJlcltdfSBmb3JjZWRfZW9zX3Rva2VuX2lkIFRoZSBJRCBvZiB0aGUgZW5kLW9mLXNlcXVlbmNlIHRva2VuIHRvIGJlIGZvcmNlZC5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihtYXhfbGVuZ3RoLCBmb3JjZWRfZW9zX3Rva2VuX2lkKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMubWF4X2xlbmd0aCA9IG1heF9sZW5ndGg7XG4gICAgICAgIHRoaXMuZm9yY2VkX2Vvc190b2tlbl9pZCA9IGZvcmNlZF9lb3NfdG9rZW5faWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXBwbHkgdGhlIHByb2Nlc3NvciB0byBpbnB1dF9pZHMgYW5kIGxvZ2l0cy5cbiAgICAgKiBcbiAgICAgKiBAcGFyYW0ge251bWJlcltdfSBpbnB1dF9pZHMgVGhlIGlucHV0IGlkcy5cbiAgICAgKiBAcGFyYW0ge1RlbnNvcn0gbG9naXRzIFRoZSBsb2dpdHMgdGVuc29yLlxuICAgICAqL1xuICAgIF9jYWxsKGlucHV0X2lkcywgbG9naXRzKSB7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdjYWxsIEZvcmNlZEVPU1Rva2VuTG9naXRzUHJvY2Vzc29yJylcbiAgICAgICAgLy8gVE9ET1xuICAgIH1cbn1cblxuLyoqXG4gKiBBIExvZ2l0c1Byb2Nlc3NvciB0aGF0IHN1cHByZXNzZXMgYSBsaXN0IG9mIHRva2VucyBhcyBzb29uIGFzIHRoZSBgZ2VuZXJhdGVgIGZ1bmN0aW9uIHN0YXJ0c1xuICogZ2VuZXJhdGluZyB1c2luZyBgYmVnaW5faW5kZXhgIHRva2Vucy4gVGhpcyBzaG91bGQgZW5zdXJlIHRoYXQgdGhlIHRva2VucyBkZWZpbmVkIGJ5XG4gKiBgYmVnaW5fc3VwcHJlc3NfdG9rZW5zYCBhdCBub3Qgc2FtcGxlZCBhdCB0aGUgYmVnaW5pbmcgb2YgdGhlIGdlbmVyYXRpb24uXG4gKiBAZXh0ZW5kcyBMb2dpdHNQcm9jZXNzb3JcbiAqL1xuZXhwb3J0IGNsYXNzIFN1cHByZXNzVG9rZW5zQXRCZWdpbkxvZ2l0c1Byb2Nlc3NvciBleHRlbmRzIExvZ2l0c1Byb2Nlc3NvciB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgU3VwcHJlc3NUb2tlbnNBdEJlZ2luTG9naXRzUHJvY2Vzc29yLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyW119IGJlZ2luX3N1cHByZXNzX3Rva2VucyBUaGUgSURzIG9mIHRoZSB0b2tlbnMgdG8gc3VwcHJlc3MuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJlZ2luX2luZGV4IFRoZSBudW1iZXIgb2YgdG9rZW5zIHRvIGdlbmVyYXRlIGJlZm9yZSBzdXBwcmVzc2luZyB0b2tlbnMuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoYmVnaW5fc3VwcHJlc3NfdG9rZW5zLCBiZWdpbl9pbmRleCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmJlZ2luX3N1cHByZXNzX3Rva2VucyA9IGJlZ2luX3N1cHByZXNzX3Rva2VucztcbiAgICAgICAgdGhpcy5iZWdpbl9pbmRleCA9IGJlZ2luX2luZGV4O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFwcGx5IHRoZSBCT1MgdG9rZW4gZm9yY2luZyB0byB0aGUgbG9naXRzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGlucHV0X2lkcyBUaGUgaW5wdXQgSURzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBsb2dpdHMgVGhlIGxvZ2l0cy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgbG9naXRzIHdpdGggQk9TIHRva2VuIGZvcmNpbmcuXG4gICAgICovXG4gICAgX2NhbGwoaW5wdXRfaWRzLCBsb2dpdHMpIHtcbiAgICAgICAgaWYgKGlucHV0X2lkcy5sZW5ndGggPT09IHRoaXMuYmVnaW5faW5kZXgpIHtcbiAgICAgICAgICAgIGZvciAobGV0IHRva2VuX2lkIG9mIHRoaXMuYmVnaW5fc3VwcHJlc3NfdG9rZW5zKSB7XG4gICAgICAgICAgICAgICAgbG9naXRzLmRhdGFbdG9rZW5faWRdID0gLUluZmluaXR5O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsb2dpdHM7XG4gICAgfVxufVxuXG4vKipcbiAqIEEgTG9naXRzUHJvY2Vzc29yIHRoYXQgaGFuZGxlcyBhZGRpbmcgdGltZXN0YW1wcyB0byBnZW5lcmF0ZWQgdGV4dC5cbiAqIEBleHRlbmRzIExvZ2l0c1Byb2Nlc3NvclxuICovXG5leHBvcnQgY2xhc3MgV2hpc3BlclRpbWVTdGFtcExvZ2l0c1Byb2Nlc3NvciBleHRlbmRzIExvZ2l0c1Byb2Nlc3NvciB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0cyBhIG5ldyBXaGlzcGVyVGltZVN0YW1wTG9naXRzUHJvY2Vzc29yLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBnZW5lcmF0ZV9jb25maWcgVGhlIGNvbmZpZyBvYmplY3QgcGFzc2VkIHRvIHRoZSBgZ2VuZXJhdGUoKWAgbWV0aG9kIG9mIGEgdHJhbnNmb3JtZXIgbW9kZWwuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGdlbmVyYXRlX2NvbmZpZy5lb3NfdG9rZW5faWQgVGhlIElEIG9mIHRoZSBlbmQtb2Ytc2VxdWVuY2UgdG9rZW4uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGdlbmVyYXRlX2NvbmZpZy5ub190aW1lc3RhbXBzX3Rva2VuX2lkIFRoZSBJRCBvZiB0aGUgdG9rZW4gdXNlZCB0byBpbmRpY2F0ZSB0aGF0IGEgdG9rZW4gc2hvdWxkIG5vdCBoYXZlIGEgdGltZXN0YW1wLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyW11bXX0gW2dlbmVyYXRlX2NvbmZpZy5mb3JjZWRfZGVjb2Rlcl9pZHNdIEFuIGFycmF5IG9mIHR3by1lbGVtZW50IGFycmF5cyByZXByZXNlbnRpbmcgZGVjb2RlciBJRHMgdGhhdCBhcmUgZm9yY2VkIHRvIGFwcGVhciBpbiB0aGUgb3V0cHV0LiBUaGUgc2Vjb25kIGVsZW1lbnQgb2YgZWFjaCBhcnJheSBpbmRpY2F0ZXMgd2hldGhlciB0aGUgdG9rZW4gaXMgYSB0aW1lc3RhbXAuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtnZW5lcmF0ZV9jb25maWcubWF4X2luaXRpYWxfdGltZXN0YW1wX2luZGV4XSBUaGUgbWF4aW11bSBpbmRleCBhdCB3aGljaCBhbiBpbml0aWFsIHRpbWVzdGFtcCBjYW4gYXBwZWFyLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGdlbmVyYXRlX2NvbmZpZykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmVvc190b2tlbl9pZCA9IGdlbmVyYXRlX2NvbmZpZy5lb3NfdG9rZW5faWQ7XG4gICAgICAgIHRoaXMubm9fdGltZXN0YW1wc190b2tlbl9pZCA9IGdlbmVyYXRlX2NvbmZpZy5ub190aW1lc3RhbXBzX3Rva2VuX2lkO1xuICAgICAgICB0aGlzLnRpbWVzdGFtcF9iZWdpbiA9IHRoaXMubm9fdGltZXN0YW1wc190b2tlbl9pZCArIDE7XG5cbiAgICAgICAgdGhpcy5iZWdpbl9pbmRleCA9IChnZW5lcmF0ZV9jb25maWcuZm9yY2VkX2RlY29kZXJfaWRzIHx8IFtdKS5sZW5ndGggKyAyO1xuICAgICAgICBpZiAoZ2VuZXJhdGVfY29uZmlnLmZvcmNlZF9kZWNvZGVyX2lkcy5zbGljZSgtMSlbMF1bMV0gPT09IHRoaXMubm9fdGltZXN0YW1wc190b2tlbl9pZCkge1xuICAgICAgICAgICAgdGhpcy5iZWdpbl9pbmRleCAtPSAxO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubWF4X2luaXRpYWxfdGltZXN0YW1wX2luZGV4ID0gZ2VuZXJhdGVfY29uZmlnLm1heF9pbml0aWFsX3RpbWVzdGFtcF9pbmRleDtcblxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1vZGlmeSB0aGUgbG9naXRzIHRvIGhhbmRsZSB0aW1lc3RhbXAgdG9rZW5zLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGlucHV0X2lkcyBUaGUgaW5wdXQgc2VxdWVuY2Ugb2YgdG9rZW5zLlxuICAgICAqIEBwYXJhbSB7VGVuc29yfSBsb2dpdHMgVGhlIGxvZ2l0cyBvdXRwdXQgYnkgdGhlIG1vZGVsLlxuICAgICAqIEByZXR1cm5zIHtUZW5zb3J9IFRoZSBtb2RpZmllZCBsb2dpdHMuXG4gICAgICovXG4gICAgX2NhbGwoaW5wdXRfaWRzLCBsb2dpdHMpIHtcbiAgICAgICAgLy8gc3VwcHJlc3MgPHxub3RpbWVzdGFtcHN8PiB3aGljaCBpcyBoYW5kbGVkIGJ5IHdpdGhvdXRfdGltZXN0YW1wc1xuICAgICAgICBsb2dpdHMuZGF0YVt0aGlzLm5vX3RpbWVzdGFtcHNfdG9rZW5faWRdID0gLUluZmluaXR5O1xuXG4gICAgICAgIGlmIChpbnB1dF9pZHMubGVuZ3RoID09PSB0aGlzLmJlZ2luX2luZGV4IC0gMSkge1xuICAgICAgICAgICAgbG9naXRzLmRhdGEuZmlsbCgtSW5maW5pdHkpO1xuICAgICAgICAgICAgbG9naXRzLmRhdGFbdGhpcy50aW1lc3RhbXBfYmVnaW5dID0gMDtcbiAgICAgICAgICAgIHJldHVybiBsb2dpdHM7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB0aW1lc3RhbXBzIGhhdmUgdG8gYXBwZWFyIGluIHBhaXJzLCBleGNlcHQgZGlyZWN0bHkgYmVmb3JlIGVvc190b2tlbjsgbWFzayBsb2dpdHMgYWNjb3JkaW5nbHlcbiAgICAgICAgY29uc3Qgc2VxID0gaW5wdXRfaWRzLnNsaWNlKHRoaXMuYmVnaW5faW5kZXgpO1xuICAgICAgICBjb25zdCBsYXN0X3dhc190aW1lc3RhbXAgPSBzZXEubGVuZ3RoID49IDEgJiYgc2VxW3NlcS5sZW5ndGggLSAxXSA+PSB0aGlzLnRpbWVzdGFtcF9iZWdpbjtcbiAgICAgICAgY29uc3QgcGVudWx0aW1hdGVfd2FzX3RpbWVzdGFtcCA9IHNlcS5sZW5ndGggPCAyIHx8IHNlcVtzZXEubGVuZ3RoIC0gMl0gPj0gdGhpcy50aW1lc3RhbXBfYmVnaW47XG5cbiAgICAgICAgaWYgKGxhc3Rfd2FzX3RpbWVzdGFtcCkge1xuICAgICAgICAgICAgaWYgKHBlbnVsdGltYXRlX3dhc190aW1lc3RhbXApIHsgLy8gaGFzIHRvIGJlIG5vbi10aW1lc3RhbXBcbiAgICAgICAgICAgICAgICBsb2dpdHMuZGF0YS5zdWJhcnJheSh0aGlzLnRpbWVzdGFtcF9iZWdpbikuZmlsbCgtSW5maW5pdHkpO1xuICAgICAgICAgICAgfSBlbHNlIHsgLy8gY2Fubm90IGJlIG5vcm1hbCB0ZXh0IHRva2Vuc1xuICAgICAgICAgICAgICAgIGxvZ2l0cy5kYXRhLnN1YmFycmF5KDAsIHRoaXMuZW9zX3Rva2VuX2lkKS5maWxsKC1JbmZpbml0eSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhcHBseSB0aGUgYG1heF9pbml0aWFsX3RpbWVzdGFtcGAgb3B0aW9uXG4gICAgICAgIGlmIChpbnB1dF9pZHMubGVuZ3RoID09PSB0aGlzLmJlZ2luX2luZGV4ICYmIHRoaXMubWF4X2luaXRpYWxfdGltZXN0YW1wX2luZGV4ICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCBsYXN0X2FsbG93ZWQgPSB0aGlzLnRpbWVzdGFtcF9iZWdpbiArIHRoaXMubWF4X2luaXRpYWxfdGltZXN0YW1wX2luZGV4O1xuICAgICAgICAgICAgbG9naXRzLmRhdGEuc3ViYXJyYXkobGFzdF9hbGxvd2VkICsgMSkuZmlsbCgtSW5maW5pdHkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgc3VtIG9mIHByb2JhYmlsaXR5IG92ZXIgdGltZXN0YW1wcyBpcyBhYm92ZSBhbnkgb3RoZXIgdG9rZW4sIHNhbXBsZSB0aW1lc3RhbXBcbiAgICAgICAgY29uc3QgbG9ncHJvYnMgPSBsb2dfc29mdG1heChsb2dpdHMuZGF0YSk7XG4gICAgICAgIGNvbnN0IHRpbWVzdGFtcF9sb2dwcm9iID0gTWF0aC5sb2cobG9ncHJvYnMuc3ViYXJyYXkodGhpcy50aW1lc3RhbXBfYmVnaW4pLm1hcChNYXRoLmV4cCkucmVkdWNlKChhLCBiKSA9PiBhICsgYikpO1xuICAgICAgICBjb25zdCBtYXhfdGV4dF90b2tlbl9sb2dwcm9iID0gbWF4KGxvZ3Byb2JzLnN1YmFycmF5KDAsIHRoaXMudGltZXN0YW1wX2JlZ2luKSlbMF07XG5cbiAgICAgICAgaWYgKHRpbWVzdGFtcF9sb2dwcm9iID4gbWF4X3RleHRfdG9rZW5fbG9ncHJvYikge1xuICAgICAgICAgICAgbG9naXRzLmRhdGEuc3ViYXJyYXkoMCwgdGhpcy50aW1lc3RhbXBfYmVnaW4pLmZpbGwoLUluZmluaXR5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBsb2dpdHM7XG4gICAgfVxufVxuXG4vKipcbiAqIEEgbG9naXRzIHByb2Nlc3NvciB0aGF0IGRpc2FsbG93cyBuZ3JhbXMgb2YgYSBjZXJ0YWluIHNpemUgdG8gYmUgcmVwZWF0ZWQuXG4gKiBcbiAqIEBleHRlbmRzIExvZ2l0c1Byb2Nlc3NvclxuICovXG5leHBvcnQgY2xhc3MgTm9SZXBlYXROR3JhbUxvZ2l0c1Byb2Nlc3NvciBleHRlbmRzIExvZ2l0c1Byb2Nlc3NvciB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgTm9SZXBlYXROR3JhbUxvZ2l0c1Byb2Nlc3Nvci5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbm9fcmVwZWF0X25ncmFtX3NpemUgVGhlIG5vLXJlcGVhdC1uZ3JhbSBzaXplLiBBbGwgbmdyYW1zIG9mIHRoaXMgc2l6ZSBjYW4gb25seSBvY2N1ciBvbmNlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG5vX3JlcGVhdF9uZ3JhbV9zaXplKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMubm9fcmVwZWF0X25ncmFtX3NpemUgPSBub19yZXBlYXRfbmdyYW1fc2l6ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZSBuLWdyYW1zIGZyb20gYSBzZXF1ZW5jZSBvZiB0b2tlbiBpZHMuXG4gICAgICogQHBhcmFtIHtudW1iZXJbXX0gcHJldklucHV0SWRzIExpc3Qgb2YgcHJldmlvdXMgaW5wdXQgaWRzXG4gICAgICogQHJldHVybnMge01hcDxzdHJpbmcsIG51bWJlcltdPn0gTWFwIG9mIGdlbmVyYXRlZCBuLWdyYW1zXG4gICAgICovXG4gICAgZ2V0TmdyYW1zKHByZXZJbnB1dElkcykge1xuICAgICAgICBjb25zdCBjdXJMZW4gPSBwcmV2SW5wdXRJZHMubGVuZ3RoO1xuXG4gICAgICAgIC8qKkB0eXBlIHtudW1iZXJbXVtdfSAqL1xuICAgICAgICBjb25zdCBuZ3JhbXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBjdXJMZW4gKyAxIC0gdGhpcy5ub19yZXBlYXRfbmdyYW1fc2l6ZTsgKytqKSB7XG4gICAgICAgICAgICBjb25zdCBuZ3JhbSA9IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCB0aGlzLm5vX3JlcGVhdF9uZ3JhbV9zaXplOyArK2spIHtcbiAgICAgICAgICAgICAgICBuZ3JhbS5wdXNoKHByZXZJbnB1dElkc1tqICsga10pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmdyYW1zLnB1c2gobmdyYW0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqIEB0eXBlIHtNYXA8c3RyaW5nLCBudW1iZXJbXT59ICovXG4gICAgICAgIGNvbnN0IGdlbmVyYXRlZE5ncmFtID0gbmV3IE1hcCgpO1xuICAgICAgICBmb3IgKGNvbnN0IG5ncmFtIG9mIG5ncmFtcykge1xuICAgICAgICAgICAgY29uc3QgcHJldk5ncmFtID0gbmdyYW0uc2xpY2UoMCwgbmdyYW0ubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICBjb25zdCBwcmV2TmdyYW1LZXkgPSBKU09OLnN0cmluZ2lmeShwcmV2TmdyYW0pO1xuICAgICAgICAgICAgY29uc3QgcHJldk5ncmFtVmFsdWUgPSBnZW5lcmF0ZWROZ3JhbS5nZXQocHJldk5ncmFtS2V5KSA/PyBbXTtcbiAgICAgICAgICAgIHByZXZOZ3JhbVZhbHVlLnB1c2gobmdyYW1bbmdyYW0ubGVuZ3RoIC0gMV0pO1xuICAgICAgICAgICAgZ2VuZXJhdGVkTmdyYW0uc2V0KHByZXZOZ3JhbUtleSwgcHJldk5ncmFtVmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBnZW5lcmF0ZWROZ3JhbTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZSBuLWdyYW1zIGZyb20gYSBzZXF1ZW5jZSBvZiB0b2tlbiBpZHMuXG4gICAgICogQHBhcmFtIHtNYXA8c3RyaW5nLCBudW1iZXJbXT59IGJhbm5lZE5ncmFtcyBNYXAgb2YgYmFubmVkIG4tZ3JhbXNcbiAgICAgKiBAcGFyYW0ge251bWJlcltdfSBwcmV2SW5wdXRJZHMgTGlzdCBvZiBwcmV2aW91cyBpbnB1dCBpZHNcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyW119IE1hcCBvZiBnZW5lcmF0ZWQgbi1ncmFtc1xuICAgICAqL1xuICAgIGdldEdlbmVyYXRlZE5ncmFtcyhiYW5uZWROZ3JhbXMsIHByZXZJbnB1dElkcykge1xuICAgICAgICBjb25zdCBuZ3JhbUlkeCA9IHByZXZJbnB1dElkcy5zbGljZShwcmV2SW5wdXRJZHMubGVuZ3RoICsgMSAtIHRoaXMubm9fcmVwZWF0X25ncmFtX3NpemUsIHByZXZJbnB1dElkcy5sZW5ndGgpO1xuICAgICAgICBjb25zdCBiYW5uZWQgPSBiYW5uZWROZ3JhbXMuZ2V0KEpTT04uc3RyaW5naWZ5KG5ncmFtSWR4KSkgPz8gW107XG4gICAgICAgIHJldHVybiBiYW5uZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIGJhbm5lZCBuLWdyYW0gdG9rZW5zXG4gICAgICogQHBhcmFtIHtudW1iZXJbXX0gcHJldklucHV0SWRzIExpc3Qgb2YgcHJldmlvdXMgaW5wdXQgaWRzXG4gICAgICogQHJldHVybnMge251bWJlcltdfSBNYXAgb2YgZ2VuZXJhdGVkIG4tZ3JhbXNcbiAgICAgKi9cbiAgICBjYWxjQmFubmVkTmdyYW1Ub2tlbnMocHJldklucHV0SWRzKSB7XG4gICAgICAgIGNvbnN0IGJhbm5lZFRva2VucyA9IFtdO1xuICAgICAgICBpZiAocHJldklucHV0SWRzLmxlbmd0aCArIDEgPCB0aGlzLm5vX3JlcGVhdF9uZ3JhbV9zaXplKSB7XG4gICAgICAgICAgICAvLyByZXR1cm4gbm8gYmFubmVkIHRva2VucyBpZiB3ZSBoYXZlbid0IGdlbmVyYXRlZCBub19yZXBlYXRfbmdyYW1fc2l6ZSB0b2tlbnMgeWV0XG4gICAgICAgICAgICByZXR1cm4gYmFubmVkVG9rZW5zO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBnZW5lcmF0ZWROZ3JhbXMgPSB0aGlzLmdldE5ncmFtcyhwcmV2SW5wdXRJZHMpO1xuICAgICAgICAgICAgY29uc3QgYmFubmVkVG9rZW5zID0gdGhpcy5nZXRHZW5lcmF0ZWROZ3JhbXMoZ2VuZXJhdGVkTmdyYW1zLCBwcmV2SW5wdXRJZHMpO1xuICAgICAgICAgICAgcmV0dXJuIGJhbm5lZFRva2VucztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFwcGx5IHRoZSBuby1yZXBlYXQtbmdyYW0gcHJvY2Vzc29yIHRvIHRoZSBsb2dpdHMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gaW5wdXRfaWRzIFRoZSBpbnB1dCBJRHMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGxvZ2l0cyBUaGUgbG9naXRzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBsb2dpdHMgd2l0aCBuby1yZXBlYXQtbmdyYW0gcHJvY2Vzc2luZy5cbiAgICAgKi9cbiAgICBfY2FsbChpbnB1dF9pZHMsIGxvZ2l0cykge1xuICAgICAgICBjb25zdCBiYW5uZWRUb2tlbnMgPSB0aGlzLmNhbGNCYW5uZWROZ3JhbVRva2VucyhpbnB1dF9pZHMpO1xuXG4gICAgICAgIGZvciAoY29uc3QgdG9rZW4gb2YgYmFubmVkVG9rZW5zKSB7XG4gICAgICAgICAgICBsb2dpdHMuZGF0YVt0b2tlbl0gPSAtSW5maW5pdHk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxvZ2l0cztcbiAgICB9XG59XG5cbi8qKlxuICogQSBsb2dpdHMgcHJvY2Vzc29yIHRoYXQgcGVuYWxpc2VzIHJlcGVhdGVkIG91dHB1dCB0b2tlbnMuXG4gKiBcbiAqIEBleHRlbmRzIExvZ2l0c1Byb2Nlc3NvclxuICovXG5leHBvcnQgY2xhc3MgUmVwZXRpdGlvblBlbmFsdHlMb2dpdHNQcm9jZXNzb3IgZXh0ZW5kcyBMb2dpdHNQcm9jZXNzb3Ige1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIFJlcGV0aXRpb25QZW5hbHR5TG9naXRzUHJvY2Vzc29yLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwZW5hbHR5IFRoZSBwZW5hbHR5IHRvIGFwcGx5IGZvciByZXBlYXRlZCB0b2tlbnMuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IocGVuYWx0eSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnBlbmFsdHkgPSBwZW5hbHR5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFwcGx5IHRoZSByZXBldGl0aW9uIHBlbmFsdHkgdG8gdGhlIGxvZ2l0cy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBpbnB1dF9pZHMgVGhlIGlucHV0IElEcy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbG9naXRzIFRoZSBsb2dpdHMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gVGhlIGxvZ2l0cyB3aXRoIHJlcGV0aXRpb24gcGVuYWx0eSBwcm9jZXNzaW5nLlxuICAgICAqL1xuICAgIF9jYWxsKGlucHV0X2lkcywgbG9naXRzKSB7XG4gICAgICAgIC8vIE1vZGlmeSB0aGUgbG9naXRzIGNvcnJlc3BvbmRpbmcgdG8gZWFjaCBlbGVtZW50IGluIGBpbnB1dF9pZHNgLlxuICAgICAgICAvLyBBcyBhIGNvbnNlcXVlbmNlLCB0aGUgbG9naXRzIGNvcnJlc3BvbmRpbmcgdG8gdG9rZW5zIHRoYXQgYXBwZWFyXG4gICAgICAgIC8vIG1hbnkgdGltZXMgaW4gdGhlIG91dHB1dCB3aWxsIGJlIHBlbmFsaXNlZCBtb3JlLlxuICAgICAgICBmb3IgKGNvbnN0IGlucHV0X2lkIG9mIGlucHV0X2lkcykge1xuICAgICAgICAgICAgaWYgKGxvZ2l0cy5kYXRhW2lucHV0X2lkXSA8IDApIHtcbiAgICAgICAgICAgICAgICBsb2dpdHMuZGF0YVtpbnB1dF9pZF0gKj0gdGhpcy5wZW5hbHR5O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBsb2dpdHMuZGF0YVtpbnB1dF9pZF0gLz0gdGhpcy5wZW5hbHR5O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsb2dpdHNcbiAgICB9XG59XG5cbi8qKlxuICogQ2xhc3MgdGhhdCBob2xkcyBhIGNvbmZpZ3VyYXRpb24gZm9yIGEgZ2VuZXJhdGlvbiB0YXNrLlxuICovXG5leHBvcnQgY2xhc3MgR2VuZXJhdGlvbkNvbmZpZyB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgR2VuZXJhdGlvbkNvbmZpZyBvYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2t3YXJncz17fV0gVGhlIGNvbmZpZ3VyYXRpb24gcGFyYW1ldGVycy4gSWYgbm90IHNldCwgdGhlIGRlZmF1bHQgdmFsdWVzIGFyZSB1c2VkLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBba3dhcmdzLm1heF9sZW5ndGg9MjBdIFRoZSBtYXhpbXVtIGxlbmd0aCB0aGUgZ2VuZXJhdGVkIHRva2VucyBjYW4gaGF2ZS4gQ29ycmVzcG9uZHMgdG8gdGhlIGxlbmd0aCBvZiB0aGUgaW5wdXQgcHJvbXB0ICsgYG1heF9uZXdfdG9rZW5zYC4gSXRzIGVmZmVjdCBpcyBvdmVycmlkZGVuIGJ5IGBtYXhfbmV3X3Rva2Vuc2AsIGlmIGFsc28gc2V0LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBba3dhcmdzLm1heF9uZXdfdG9rZW5zPW51bGxdIFRoZSBtYXhpbXVtIG51bWJlcnMgb2YgdG9rZW5zIHRvIGdlbmVyYXRlLCBpZ25vcmluZyB0aGUgbnVtYmVyIG9mIHRva2VucyBpbiB0aGUgcHJvbXB0LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBba3dhcmdzLm1pbl9sZW5ndGg9MF0gVGhlIG1pbmltdW0gbGVuZ3RoIG9mIHRoZSBzZXF1ZW5jZSB0byBiZSBnZW5lcmF0ZWQuIENvcnJlc3BvbmRzIHRvIHRoZSBsZW5ndGggb2YgdGhlIGlucHV0IHByb21wdCArIGBtaW5fbmV3X3Rva2Vuc2AuIEl0cyBlZmZlY3QgaXMgb3ZlcnJpZGRlbiBieSBgbWluX25ld190b2tlbnNgLCBpZiBhbHNvIHNldC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2t3YXJncy5taW5fbmV3X3Rva2Vucz1udWxsXSBUaGUgbWluaW11bSBudW1iZXJzIG9mIHRva2VucyB0byBnZW5lcmF0ZSwgaWdub3JpbmcgdGhlIG51bWJlciBvZiB0b2tlbnMgaW4gdGhlIHByb21wdC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW58XCJuZXZlclwifSBba3dhcmdzLmVhcmx5X3N0b3BwaW5nPWZhbHNlXSBDb250cm9scyB0aGUgc3RvcHBpbmcgY29uZGl0aW9uIGZvciBiZWFtLWJhc2VkIG1ldGhvZHMsIGxpa2UgYmVhbS1zZWFyY2guIEl0IGFjY2VwdHMgdGhlIGZvbGxvd2luZyB2YWx1ZXM6XG4gICAgICogLSBgdHJ1ZWAsIHdoZXJlIHRoZSBnZW5lcmF0aW9uIHN0b3BzIGFzIHNvb24gYXMgdGhlcmUgYXJlIGBudW1fYmVhbXNgIGNvbXBsZXRlIGNhbmRpZGF0ZXM7XG4gICAgICogLSBgZmFsc2VgLCB3aGVyZSBhbiBoZXVyaXN0aWMgaXMgYXBwbGllZCBhbmQgdGhlIGdlbmVyYXRpb24gc3RvcHMgd2hlbiBpcyBpdCB2ZXJ5IHVubGlrZWx5IHRvIGZpbmQgYmV0dGVyIGNhbmRpZGF0ZXM7XG4gICAgICogLSBgXCJuZXZlclwiYCwgd2hlcmUgdGhlIGJlYW0gc2VhcmNoIHByb2NlZHVyZSBvbmx5IHN0b3BzIHdoZW4gdGhlcmUgY2Fubm90IGJlIGJldHRlciBjYW5kaWRhdGVzIChjYW5vbmljYWwgYmVhbSBzZWFyY2ggYWxnb3JpdGhtKS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2t3YXJncy5tYXhfdGltZT1udWxsXSBUaGUgbWF4aW11bSBhbW91bnQgb2YgdGltZSB5b3UgYWxsb3cgdGhlIGNvbXB1dGF0aW9uIHRvIHJ1biBmb3IgaW4gc2Vjb25kcy4gR2VuZXJhdGlvbiB3aWxsIHN0aWxsIGZpbmlzaCB0aGUgY3VycmVudCBwYXNzIGFmdGVyIGFsbG9jYXRlZCB0aW1lIGhhcyBiZWVuIHBhc3NlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2t3YXJncy5kb19zYW1wbGU9ZmFsc2VdIFdoZXRoZXIgb3Igbm90IHRvIHVzZSBzYW1wbGluZzsgdXNlIGdyZWVkeSBkZWNvZGluZyBvdGhlcndpc2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtrd2FyZ3MubnVtX2JlYW1zPTFdIE51bWJlciBvZiBiZWFtcyBmb3IgYmVhbSBzZWFyY2guIDEgbWVhbnMgbm8gYmVhbSBzZWFyY2guXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtrd2FyZ3MubnVtX2JlYW1fZ3JvdXBzPTFdIE51bWJlciBvZiBncm91cHMgdG8gZGl2aWRlIGBudW1fYmVhbXNgIGludG8gaW4gb3JkZXIgdG8gZW5zdXJlIGRpdmVyc2l0eSBhbW9uZyBkaWZmZXJlbnQgZ3JvdXBzIG9mIGJlYW1zLiBTZWUgW3RoaXMgcGFwZXJdKGh0dHBzOi8vYXJ4aXYub3JnL3BkZi8xNjEwLjAyNDI0LnBkZikgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2t3YXJncy5wZW5hbHR5X2FscGhhPW51bGxdIFRoZSB2YWx1ZXMgYmFsYW5jZSB0aGUgbW9kZWwgY29uZmlkZW5jZSBhbmQgdGhlIGRlZ2VuZXJhdGlvbiBwZW5hbHR5IGluIGNvbnRyYXN0aXZlIHNlYXJjaCBkZWNvZGluZy5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtrd2FyZ3MudXNlX2NhY2hlPXRydWVdIFdoZXRoZXIgb3Igbm90IHRoZSBtb2RlbCBzaG91bGQgdXNlIHRoZSBwYXN0IGxhc3Qga2V5L3ZhbHVlcyBhdHRlbnRpb25zIChpZiBhcHBsaWNhYmxlIHRvIHRoZSBtb2RlbCkgdG8gc3BlZWQgdXAgZGVjb2RpbmcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2t3YXJncy50ZW1wZXJhdHVyZT0xLjBdIFRoZSB2YWx1ZSB1c2VkIHRvIG1vZHVsYXRlIHRoZSBuZXh0IHRva2VuIHByb2JhYmlsaXRpZXMuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtrd2FyZ3MudG9wX2s9NTBdIFRoZSBudW1iZXIgb2YgaGlnaGVzdCBwcm9iYWJpbGl0eSB2b2NhYnVsYXJ5IHRva2VucyB0byBrZWVwIGZvciB0b3Atay1maWx0ZXJpbmcuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtrd2FyZ3MudG9wX3A9MS4wXSBJZiBzZXQgdG8gZmxvYXQgPCAxLCBvbmx5IHRoZSBzbWFsbGVzdCBzZXQgb2YgbW9zdCBwcm9iYWJsZSB0b2tlbnMgd2l0aCBwcm9iYWJpbGl0aWVzIHRoYXQgYWRkIHVwIHRvIGB0b3BfcGAgb3IgaGlnaGVyIGFyZSBrZXB0IGZvciBnZW5lcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBba3dhcmdzLnR5cGljYWxfcD0xLjBdIExvY2FsIHR5cGljYWxpdHkgbWVhc3VyZXMgaG93IHNpbWlsYXIgdGhlIGNvbmRpdGlvbmFsIHByb2JhYmlsaXR5IG9mIHByZWRpY3RpbmcgYSB0YXJnZXQgdG9rZW4gbmV4dCBpcyB0byB0aGUgZXhwZWN0ZWQgY29uZGl0aW9uYWwgcHJvYmFiaWxpdHkgb2YgcHJlZGljdGluZyBhIHJhbmRvbSB0b2tlbiBuZXh0LCBnaXZlbiB0aGUgcGFydGlhbCB0ZXh0IGFscmVhZHkgZ2VuZXJhdGVkLiBJZiBzZXQgdG8gZmxvYXQgPCAxLCB0aGUgc21hbGxlc3Qgc2V0IG9mIHRoZSBtb3N0IGxvY2FsbHkgdHlwaWNhbCB0b2tlbnMgd2l0aCBwcm9iYWJpbGl0aWVzIHRoYXQgYWRkIHVwIHRvIGB0eXBpY2FsX3BgIG9yIGhpZ2hlciBhcmUga2VwdCBmb3IgZ2VuZXJhdGlvbi4gU2VlIFt0aGlzIHBhcGVyXShodHRwczovL2FyeGl2Lm9yZy9wZGYvMjIwMi4wMDY2Ni5wZGYpIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtrd2FyZ3MuZXBzaWxvbl9jdXRvZmY9MC4wXSBJZiBzZXQgdG8gZmxvYXQgc3RyaWN0bHkgYmV0d2VlbiAwIGFuZCAxLCBvbmx5IHRva2VucyB3aXRoIGEgY29uZGl0aW9uYWwgcHJvYmFiaWxpdHkgZ3JlYXRlciB0aGFuIGBlcHNpbG9uX2N1dG9mZmAgd2lsbCBiZSBzYW1wbGVkLiBJbiB0aGUgcGFwZXIsIHN1Z2dlc3RlZCB2YWx1ZXMgcmFuZ2UgZnJvbSAzZS00IHRvIDllLTQsIGRlcGVuZGluZyBvbiB0aGUgc2l6ZSBvZiB0aGUgbW9kZWwuIFNlZSBbVHJ1bmNhdGlvbiBTYW1wbGluZyBhcyBMYW5ndWFnZSBNb2RlbCBEZXNtb290aGluZ10oaHR0cHM6Ly9hcnhpdi5vcmcvYWJzLzIyMTAuMTUxOTEpIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtrd2FyZ3MuZXRhX2N1dG9mZj0wLjBdIEV0YSBzYW1wbGluZyBpcyBhIGh5YnJpZCBvZiBsb2NhbGx5IHR5cGljYWwgc2FtcGxpbmcgYW5kIGVwc2lsb24gc2FtcGxpbmcuIElmIHNldCB0byBmbG9hdCBzdHJpY3RseSBiZXR3ZWVuIDAgYW5kIDEsIGEgdG9rZW4gaXMgb25seSBjb25zaWRlcmVkIGlmIGl0IGlzIGdyZWF0ZXIgdGhhbiBlaXRoZXIgYGV0YV9jdXRvZmZgIG9yIGBzcXJ0KGV0YV9jdXRvZmYpICogZXhwKC1lbnRyb3B5KHNvZnRtYXgobmV4dF90b2tlbl9sb2dpdHMpKSlgLiBUaGUgbGF0dGVyIHRlcm0gaXMgaW50dWl0aXZlbHkgdGhlIGV4cGVjdGVkIG5leHQgdG9rZW4gcHJvYmFiaWxpdHksIHNjYWxlZCBieSBgc3FydChldGFfY3V0b2ZmKWAuIEluIHRoZSBwYXBlciwgc3VnZ2VzdGVkIHZhbHVlcyByYW5nZSBmcm9tIDNlLTQgdG8gMmUtMywgZGVwZW5kaW5nIG9uIHRoZSBzaXplIG9mIHRoZSBtb2RlbC4gU2VlIFtUcnVuY2F0aW9uIFNhbXBsaW5nIGFzIExhbmd1YWdlIE1vZGVsIERlc21vb3RoaW5nXShodHRwczovL2FyeGl2Lm9yZy9hYnMvMjIxMC4xNTE5MSkgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2t3YXJncy5kaXZlcnNpdHlfcGVuYWx0eT0wLjBdIFRoaXMgdmFsdWUgaXMgc3VidHJhY3RlZCBmcm9tIGEgYmVhbSdzIHNjb3JlIGlmIGl0IGdlbmVyYXRlcyBhIHRva2VuIHNhbWUgYXMgYW55IGJlYW0gZnJvbSBvdGhlciBncm91cCBhdCBhIHBhcnRpY3VsYXIgdGltZS4gTm90ZSB0aGF0IGBkaXZlcnNpdHlfcGVuYWx0eWAgaXMgb25seSBlZmZlY3RpdmUgaWYgYGdyb3VwIGJlYW0gc2VhcmNoYCBpcyBlbmFibGVkLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBba3dhcmdzLnJlcGV0aXRpb25fcGVuYWx0eT0xLjBdIFRoZSBwYXJhbWV0ZXIgZm9yIHJlcGV0aXRpb24gcGVuYWx0eS4gMS4wIG1lYW5zIG5vIHBlbmFsdHkuIFNlZSBbdGhpcyBwYXBlcl0oaHR0cHM6Ly9hcnhpdi5vcmcvcGRmLzE5MDkuMDU4NTgucGRmKSBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBba3dhcmdzLmVuY29kZXJfcmVwZXRpdGlvbl9wZW5hbHR5PTEuMF0gVGhlIHBhcmFtYXRlciBmb3IgZW5jb2Rlcl9yZXBldGl0aW9uX3BlbmFsdHkuIEFuIGV4cG9uZW50aWFsIHBlbmFsdHkgb24gc2VxdWVuY2VzIHRoYXQgYXJlIG5vdCBpbiB0aGUgb3JpZ2luYWwgaW5wdXQuIDEuMCBtZWFucyBubyBwZW5hbHR5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBba3dhcmdzLmxlbmd0aF9wZW5hbHR5PTEuMF0gRXhwb25lbnRpYWwgcGVuYWx0eSB0byB0aGUgbGVuZ3RoIHRoYXQgaXMgdXNlZCB3aXRoIGJlYW0tYmFzZWQgZ2VuZXJhdGlvbi4gSXQgaXMgYXBwbGllZCBhcyBhbiBleHBvbmVudCB0byB0aGUgc2VxdWVuY2UgbGVuZ3RoLCB3aGljaCBpbiB0dXJuIGlzIHVzZWQgdG8gZGl2aWRlIHRoZSBzY29yZSBvZiB0aGUgc2VxdWVuY2UuIFNpbmNlIHRoZSBzY29yZSBpcyB0aGUgbG9nIGxpa2VsaWhvb2Qgb2YgdGhlIHNlcXVlbmNlIChpLmUuIG5lZ2F0aXZlKSwgYGxlbmd0aF9wZW5hbHR5YCA+IDAuMCBwcm9tb3RlcyBsb25nZXIgc2VxdWVuY2VzLCB3aGlsZSBgbGVuZ3RoX3BlbmFsdHlgIDwgMC4wIGVuY291cmFnZXMgc2hvcnRlciBzZXF1ZW5jZXMuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtrd2FyZ3Mubm9fcmVwZWF0X25ncmFtX3NpemU9MF0gSWYgc2V0IHRvIGludCA+IDAsIGFsbCBuZ3JhbXMgb2YgdGhhdCBzaXplIGNhbiBvbmx5IG9jY3VyIG9uY2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJbXVtdfSBba3dhcmdzLmJhZF93b3Jkc19pZHM9bnVsbF0gTGlzdCBvZiB0b2tlbiBpZHMgdGhhdCBhcmUgbm90IGFsbG93ZWQgdG8gYmUgZ2VuZXJhdGVkLiBJbiBvcmRlciB0byBnZXQgdGhlIHRva2VuIGlkcyBvZiB0aGUgd29yZHMgdGhhdCBzaG91bGQgbm90IGFwcGVhciBpbiB0aGUgZ2VuZXJhdGVkIHRleHQsIHVzZSBgKGF3YWl0IHRva2VuaXplcihiYWRfd29yZHMsIHthZGRfcHJlZml4X3NwYWNlOiB0cnVlLCBhZGRfc3BlY2lhbF90b2tlbnM6IGZhbHNlfSkpLmlucHV0X2lkc2AuXG4gICAgICogQHBhcmFtIHtudW1iZXJbXVtdfG51bWJlcltdW11bXX0gW2t3YXJncy5mb3JjZV93b3Jkc19pZHM9bnVsbF0gTGlzdCBvZiB0b2tlbiBpZHMgdGhhdCBtdXN0IGJlIGdlbmVyYXRlZC4gSWYgZ2l2ZW4gYSBgbnVtYmVyW11bXWAsIHRoaXMgaXMgdHJlYXRlZCBhcyBhIHNpbXBsZSBsaXN0IG9mIHdvcmRzIHRoYXQgbXVzdCBiZSBpbmNsdWRlZCwgdGhlIG9wcG9zaXRlIHRvIGBiYWRfd29yZHNfaWRzYC4gSWYgZ2l2ZW4gYG51bWJlcltdW11bXWAsIHRoaXMgdHJpZ2dlcnMgYSBbZGlzanVuY3RpdmUgY29uc3RyYWludF0oaHR0cHM6Ly9naXRodWIuY29tL2h1Z2dpbmdmYWNlL3RyYW5zZm9ybWVycy9pc3N1ZXMvMTQwODEpLCB3aGVyZSBvbmUgY2FuIGFsbG93IGRpZmZlcmVudCBmb3JtcyBvZiBlYWNoIHdvcmQuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBba3dhcmdzLnJlbm9ybWFsaXplX2xvZ2l0cz1mYWxzZV0gV2hldGhlciB0byByZW5vcm1hbGl6ZSB0aGUgbG9naXRzIGFmdGVyIGFwcGx5aW5nIGFsbCB0aGUgbG9naXRzIHByb2Nlc3NvcnMgb3Igd2FycGVycyAoaW5jbHVkaW5nIHRoZSBjdXN0b20gb25lcykuIEl0J3MgaGlnaGx5IHJlY29tbWVuZGVkIHRvIHNldCB0aGlzIGZsYWcgdG8gYHRydWVgIGFzIHRoZSBzZWFyY2ggYWxnb3JpdGhtcyBzdXBwb3NlIHRoZSBzY29yZSBsb2dpdHMgYXJlIG5vcm1hbGl6ZWQgYnV0IHNvbWUgbG9naXQgcHJvY2Vzc29ycyBvciB3YXJwZXJzIGJyZWFrIHRoZSBub3JtYWxpemF0aW9uLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0W119IFtrd2FyZ3MuY29uc3RyYWludHM9bnVsbF0gQ3VzdG9tIGNvbnN0cmFpbnRzIHRoYXQgY2FuIGJlIGFkZGVkIHRvIHRoZSBnZW5lcmF0aW9uIHRvIGVuc3VyZSB0aGF0IHRoZSBvdXRwdXQgd2lsbCBjb250YWluIHRoZSB1c2Ugb2YgY2VydGFpbiB0b2tlbnMgYXMgZGVmaW5lZCBieSBgQ29uc3RyYWludGAgb2JqZWN0cywgaW4gdGhlIG1vc3Qgc2Vuc2libGUgd2F5IHBvc3NpYmxlLlxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBba3dhcmdzLmZvcmNlZF9ib3NfdG9rZW5faWQ9bnVsbF0gVGhlIGlkIG9mIHRoZSB0b2tlbiB0byBmb3JjZSBhcyB0aGUgZmlyc3QgZ2VuZXJhdGVkIHRva2VuIGFmdGVyIHRoZSBgZGVjb2Rlcl9zdGFydF90b2tlbl9pZGAuIFVzZWZ1bCBmb3IgbXVsdGlsaW5ndWFsIG1vZGVscyBsaWtlIG1CQVJUIHdoZXJlIHRoZSBmaXJzdCBnZW5lcmF0ZWQgdG9rZW4gbmVlZHMgdG8gYmUgdGhlIHRhcmdldCBsYW5ndWFnZSB0b2tlbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcnxudW1iZXJbXX0gW2t3YXJncy5mb3JjZWRfZW9zX3Rva2VuX2lkPW51bGxdIFRoZSBpZCBvZiB0aGUgdG9rZW4gdG8gZm9yY2UgYXMgdGhlIGxhc3QgZ2VuZXJhdGVkIHRva2VuIHdoZW4gYG1heF9sZW5ndGhgIGlzIHJlYWNoZWQuIE9wdGlvbmFsbHksIHVzZSBhIGxpc3QgdG8gc2V0IG11bHRpcGxlICplbmQtb2Ytc2VxdWVuY2UqIHRva2Vucy5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtrd2FyZ3MucmVtb3ZlX2ludmFsaWRfdmFsdWVzPWZhbHNlXSBXaGV0aGVyIHRvIHJlbW92ZSBwb3NzaWJsZSAqbmFuKiBhbmQgKmluZiogb3V0cHV0cyBvZiB0aGUgbW9kZWwgdG8gcHJldmVudCB0aGUgZ2VuZXJhdGlvbiBtZXRob2QgdG8gY3Jhc2guIE5vdGUgdGhhdCB1c2luZyBgcmVtb3ZlX2ludmFsaWRfdmFsdWVzYCBjYW4gc2xvdyBkb3duIGdlbmVyYXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJbXX0gW2t3YXJncy5leHBvbmVudGlhbF9kZWNheV9sZW5ndGhfcGVuYWx0eT1udWxsXSBUaGlzIFR1cGxlIGFkZHMgYW4gZXhwb25lbnRpYWxseSBpbmNyZWFzaW5nIGxlbmd0aCBwZW5hbHR5LCBhZnRlciBhIGNlcnRhaW4gYW1vdW50IG9mIHRva2VucyBoYXZlIGJlZW4gZ2VuZXJhdGVkLiBUaGUgdHVwbGUgc2hhbGwgY29uc2lzdCBvZjogYChzdGFydF9pbmRleCwgZGVjYXlfZmFjdG9yKWAgd2hlcmUgYHN0YXJ0X2luZGV4YCBpbmRpY2F0ZXMgd2hlcmUgcGVuYWx0eSBzdGFydHMgYW5kIGBkZWNheV9mYWN0b3JgIHJlcHJlc2VudHMgdGhlIGZhY3RvciBvZiBleHBvbmVudGlhbCBkZWNheS5cbiAgICAgKiBAcGFyYW0ge251bWJlcltdfSBba3dhcmdzLnN1cHByZXNzX3Rva2Vucz1udWxsXSBBIGxpc3Qgb2YgdG9rZW5zIHRoYXQgd2lsbCBiZSBzdXBwcmVzc2VkIGF0IGdlbmVyYXRpb24uIFRoZSBgU3VwcmVzc1Rva2Vuc2AgbG9naXQgcHJvY2Vzc29yIHdpbGwgc2V0IHRoZWlyIGxvZyBwcm9icyB0byBgLWluZmAgc28gdGhhdCB0aGV5IGFyZSBub3Qgc2FtcGxlZC5cbiAgICAgKiBAcGFyYW0ge251bWJlcltdfSBba3dhcmdzLmJlZ2luX3N1cHByZXNzX3Rva2Vucz1udWxsXSBBIGxpc3Qgb2YgdG9rZW5zIHRoYXQgd2lsbCBiZSBzdXBwcmVzc2VkIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIGdlbmVyYXRpb24uIFRoZSBgU3VwcmVzc0JlZ2luVG9rZW5zYCBsb2dpdCBwcm9jZXNzb3Igd2lsbCBzZXQgdGhlaXIgbG9nIHByb2JzIHRvIGAtaW5mYCBzbyB0aGF0IHRoZXkgYXJlIG5vdCBzYW1wbGVkLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyW11bXX0gW2t3YXJncy5mb3JjZWRfZGVjb2Rlcl9pZHM9bnVsbF0gQSBsaXN0IG9mIHBhaXJzIG9mIGludGVnZXJzIHdoaWNoIGluZGljYXRlcyBhIG1hcHBpbmcgZnJvbSBnZW5lcmF0aW9uIGluZGljZXMgdG8gdG9rZW4gaW5kaWNlcyB0aGF0IHdpbGwgYmUgZm9yY2VkIGJlZm9yZSBzYW1wbGluZy4gRm9yIGV4YW1wbGUsIGBbWzEsIDEyM11dYCBtZWFucyB0aGUgc2Vjb25kIGdlbmVyYXRlZCB0b2tlbiB3aWxsIGFsd2F5cyBiZSBhIHRva2VuIG9mIGluZGV4IDEyMy5cbiAgICAgKiBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2t3YXJncy5udW1fcmV0dXJuX3NlcXVlbmNlcz0xXSBUaGUgbnVtYmVyIG9mIGluZGVwZW5kZW50bHkgY29tcHV0ZWQgcmV0dXJuZWQgc2VxdWVuY2VzIGZvciBlYWNoIGVsZW1lbnQgaW4gdGhlIGJhdGNoLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2t3YXJncy5vdXRwdXRfYXR0ZW50aW9ucz1mYWxzZV0gV2hldGhlciBvciBub3QgdG8gcmV0dXJuIHRoZSBhdHRlbnRpb25zIHRlbnNvcnMgb2YgYWxsIGF0dGVudGlvbiBsYXllcnMuIFNlZSBgYXR0ZW50aW9uc2AgdW5kZXIgcmV0dXJuZWQgdGVuc29ycyBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2t3YXJncy5vdXRwdXRfaGlkZGVuX3N0YXRlcz1mYWxzZV0gV2hldGhlciBvciBub3QgdG8gcmV0dXJuIHRoZSBoaWRkZW4gc3RhdGVzIG9mIGFsbCBsYXllcnMuIFNlZSBgaGlkZGVuX3N0YXRlc2AgdW5kZXIgcmV0dXJuZWQgdGVuc29ycyBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2t3YXJncy5vdXRwdXRfc2NvcmVzPWZhbHNlXSBXaGV0aGVyIG9yIG5vdCB0byByZXR1cm4gdGhlIHByZWRpY3Rpb24gc2NvcmVzLiBTZWUgYHNjb3Jlc2AgdW5kZXIgcmV0dXJuZWQgdGVuc29ycyBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2t3YXJncy5yZXR1cm5fZGljdF9pbl9nZW5lcmF0ZT1mYWxzZV0gV2hldGhlciBvciBub3QgdG8gcmV0dXJuIGEgYE1vZGVsT3V0cHV0YCBpbnN0ZWFkIG9mIGEgcGxhaW4gdHVwbGUuXG4gICAgICogXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtrd2FyZ3MucGFkX3Rva2VuX2lkPW51bGxdIFRoZSBpZCBvZiB0aGUgKnBhZGRpbmcqIHRva2VuLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBba3dhcmdzLmJvc190b2tlbl9pZD1udWxsXSBUaGUgaWQgb2YgdGhlICpiZWdpbm5pbmctb2Ytc2VxdWVuY2UqIHRva2VuLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfG51bWJlcltdfSBba3dhcmdzLmVvc190b2tlbl9pZD1udWxsXSBUaGUgaWQgb2YgdGhlICplbmQtb2Ytc2VxdWVuY2UqIHRva2VuLiBPcHRpb25hbGx5LCB1c2UgYSBsaXN0IHRvIHNldCBtdWx0aXBsZSAqZW5kLW9mLXNlcXVlbmNlKiB0b2tlbnMuXG4gICAgICogXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtrd2FyZ3MuZW5jb2Rlcl9ub19yZXBlYXRfbmdyYW1fc2l6ZT0wXSBJZiBzZXQgdG8gaW50ID4gMCwgYWxsIG5ncmFtcyBvZiB0aGF0IHNpemUgdGhhdCBvY2N1ciBpbiB0aGUgYGVuY29kZXJfaW5wdXRfaWRzYCBjYW5ub3Qgb2NjdXIgaW4gdGhlIGBkZWNvZGVyX2lucHV0X2lkc2AuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtrd2FyZ3MuZGVjb2Rlcl9zdGFydF90b2tlbl9pZD1udWxsXSBJZiBhbiBlbmNvZGVyLWRlY29kZXIgbW9kZWwgc3RhcnRzIGRlY29kaW5nIHdpdGggYSBkaWZmZXJlbnQgdG9rZW4gdGhhbiAqYm9zKiwgdGhlIGlkIG9mIHRoYXQgdG9rZW4uXG4gICAgICogXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtrd2FyZ3MuZ2VuZXJhdGlvbl9rd2FyZ3M9e31dIEFkZGl0aW9uYWwgZ2VuZXJhdGlvbiBrd2FyZ3Mgd2lsbCBiZSBmb3J3YXJkZWQgdG8gdGhlIGBnZW5lcmF0ZWAgZnVuY3Rpb24gb2YgdGhlIG1vZGVsLiBLd2FyZ3MgdGhhdCBhcmUgbm90IHByZXNlbnQgaW4gYGdlbmVyYXRlYCdzIHNpZ25hdHVyZSB3aWxsIGJlIHVzZWQgaW4gdGhlIG1vZGVsIGZvcndhcmQgcGFzcy5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihrd2FyZ3MgPSB7fSkge1xuICAgICAgICAvLyBQYXJhbWV0ZXJzIHRoYXQgY29udHJvbCB0aGUgbGVuZ3RoIG9mIHRoZSBvdXRwdXRcbiAgICAgICAgdGhpcy5tYXhfbGVuZ3RoID0ga3dhcmdzLm1heF9sZW5ndGggPz8gMjA7XG4gICAgICAgIHRoaXMubWF4X25ld190b2tlbnMgPSBrd2FyZ3MubWF4X25ld190b2tlbnMgPz8gbnVsbDtcbiAgICAgICAgdGhpcy5taW5fbGVuZ3RoID0ga3dhcmdzLm1pbl9sZW5ndGggPz8gMDtcbiAgICAgICAgdGhpcy5taW5fbmV3X3Rva2VucyA9IGt3YXJncy5taW5fbmV3X3Rva2VucyA/PyBudWxsO1xuICAgICAgICB0aGlzLmVhcmx5X3N0b3BwaW5nID0ga3dhcmdzLmVhcmx5X3N0b3BwaW5nID8/IGZhbHNlO1xuICAgICAgICB0aGlzLm1heF90aW1lID0ga3dhcmdzLm1heF90aW1lID8/IG51bGw7XG5cbiAgICAgICAgLy8gUGFyYW1ldGVycyB0aGF0IGNvbnRyb2wgdGhlIGdlbmVyYXRpb24gc3RyYXRlZ3kgdXNlZFxuICAgICAgICB0aGlzLmRvX3NhbXBsZSA9IGt3YXJncy5kb19zYW1wbGUgPz8gZmFsc2U7XG4gICAgICAgIHRoaXMubnVtX2JlYW1zID0ga3dhcmdzLm51bV9iZWFtcyA/PyAxO1xuICAgICAgICB0aGlzLm51bV9iZWFtX2dyb3VwcyA9IGt3YXJncy5udW1fYmVhbV9ncm91cHMgPz8gMTtcbiAgICAgICAgdGhpcy5wZW5hbHR5X2FscGhhID0ga3dhcmdzLnBlbmFsdHlfYWxwaGEgPz8gbnVsbDtcbiAgICAgICAgdGhpcy51c2VfY2FjaGUgPSBrd2FyZ3MudXNlX2NhY2hlID8/IHRydWU7XG5cbiAgICAgICAgLy8gUGFyYW1ldGVycyBmb3IgbWFuaXB1bGF0aW9uIG9mIHRoZSBtb2RlbCBvdXRwdXQgbG9naXRzXG4gICAgICAgIHRoaXMudGVtcGVyYXR1cmUgPSBrd2FyZ3MudGVtcGVyYXR1cmUgPz8gMS4wO1xuICAgICAgICB0aGlzLnRvcF9rID0ga3dhcmdzLnRvcF9rID8/IDUwO1xuICAgICAgICB0aGlzLnRvcF9wID0ga3dhcmdzLnRvcF9wID8/IDEuMDtcbiAgICAgICAgdGhpcy50eXBpY2FsX3AgPSBrd2FyZ3MudHlwaWNhbF9wID8/IDEuMDtcbiAgICAgICAgdGhpcy5lcHNpbG9uX2N1dG9mZiA9IGt3YXJncy5lcHNpbG9uX2N1dG9mZiA/PyAwLjA7XG4gICAgICAgIHRoaXMuZXRhX2N1dG9mZiA9IGt3YXJncy5ldGFfY3V0b2ZmID8/IDAuMDtcbiAgICAgICAgdGhpcy5kaXZlcnNpdHlfcGVuYWx0eSA9IGt3YXJncy5kaXZlcnNpdHlfcGVuYWx0eSA/PyAwLjA7XG4gICAgICAgIHRoaXMucmVwZXRpdGlvbl9wZW5hbHR5ID0ga3dhcmdzLnJlcGV0aXRpb25fcGVuYWx0eSA/PyAxLjA7XG4gICAgICAgIHRoaXMuZW5jb2Rlcl9yZXBldGl0aW9uX3BlbmFsdHkgPSBrd2FyZ3MuZW5jb2Rlcl9yZXBldGl0aW9uX3BlbmFsdHkgPz8gMS4wO1xuICAgICAgICB0aGlzLmxlbmd0aF9wZW5hbHR5ID0ga3dhcmdzLmxlbmd0aF9wZW5hbHR5ID8/IDEuMDtcbiAgICAgICAgdGhpcy5ub19yZXBlYXRfbmdyYW1fc2l6ZSA9IGt3YXJncy5ub19yZXBlYXRfbmdyYW1fc2l6ZSA/PyAwO1xuICAgICAgICB0aGlzLmJhZF93b3Jkc19pZHMgPSBrd2FyZ3MuYmFkX3dvcmRzX2lkcyA/PyBudWxsO1xuICAgICAgICB0aGlzLmZvcmNlX3dvcmRzX2lkcyA9IGt3YXJncy5mb3JjZV93b3Jkc19pZHMgPz8gbnVsbDtcbiAgICAgICAgdGhpcy5yZW5vcm1hbGl6ZV9sb2dpdHMgPSBrd2FyZ3MucmVub3JtYWxpemVfbG9naXRzID8/IGZhbHNlO1xuICAgICAgICB0aGlzLmNvbnN0cmFpbnRzID0ga3dhcmdzLmNvbnN0cmFpbnRzID8/IG51bGw7XG4gICAgICAgIHRoaXMuZm9yY2VkX2Jvc190b2tlbl9pZCA9IGt3YXJncy5mb3JjZWRfYm9zX3Rva2VuX2lkID8/IG51bGw7XG4gICAgICAgIHRoaXMuZm9yY2VkX2Vvc190b2tlbl9pZCA9IGt3YXJncy5mb3JjZWRfZW9zX3Rva2VuX2lkID8/IG51bGw7XG4gICAgICAgIHRoaXMucmVtb3ZlX2ludmFsaWRfdmFsdWVzID0ga3dhcmdzLnJlbW92ZV9pbnZhbGlkX3ZhbHVlcyA/PyBmYWxzZTtcbiAgICAgICAgdGhpcy5leHBvbmVudGlhbF9kZWNheV9sZW5ndGhfcGVuYWx0eSA9IGt3YXJncy5leHBvbmVudGlhbF9kZWNheV9sZW5ndGhfcGVuYWx0eSA/PyBudWxsO1xuICAgICAgICB0aGlzLnN1cHByZXNzX3Rva2VucyA9IGt3YXJncy5zdXBwcmVzc190b2tlbnMgPz8gbnVsbDtcbiAgICAgICAgdGhpcy5iZWdpbl9zdXBwcmVzc190b2tlbnMgPSBrd2FyZ3MuYmVnaW5fc3VwcHJlc3NfdG9rZW5zID8/IG51bGw7XG4gICAgICAgIHRoaXMuZm9yY2VkX2RlY29kZXJfaWRzID0ga3dhcmdzLmZvcmNlZF9kZWNvZGVyX2lkcyA/PyBudWxsO1xuXG4gICAgICAgIC8vIFBhcmFtZXRlcnMgdGhhdCBkZWZpbmUgdGhlIG91dHB1dCB2YXJpYWJsZXMgb2YgYGdlbmVyYXRlYFxuICAgICAgICB0aGlzLm51bV9yZXR1cm5fc2VxdWVuY2VzID0ga3dhcmdzLm51bV9yZXR1cm5fc2VxdWVuY2VzID8/IDE7XG4gICAgICAgIHRoaXMub3V0cHV0X2F0dGVudGlvbnMgPSBrd2FyZ3Mub3V0cHV0X2F0dGVudGlvbnMgPz8gZmFsc2U7XG4gICAgICAgIHRoaXMub3V0cHV0X2hpZGRlbl9zdGF0ZXMgPSBrd2FyZ3Mub3V0cHV0X2hpZGRlbl9zdGF0ZXMgPz8gZmFsc2U7XG4gICAgICAgIHRoaXMub3V0cHV0X3Njb3JlcyA9IGt3YXJncy5vdXRwdXRfc2NvcmVzID8/IGZhbHNlO1xuICAgICAgICB0aGlzLnJldHVybl9kaWN0X2luX2dlbmVyYXRlID0ga3dhcmdzLnJldHVybl9kaWN0X2luX2dlbmVyYXRlID8/IGZhbHNlO1xuXG4gICAgICAgIC8vIFNwZWNpYWwgdG9rZW5zIHRoYXQgY2FuIGJlIHVzZWQgYXQgZ2VuZXJhdGlvbiB0aW1lXG4gICAgICAgIHRoaXMucGFkX3Rva2VuX2lkID0ga3dhcmdzLnBhZF90b2tlbl9pZCA/PyBudWxsO1xuICAgICAgICB0aGlzLmJvc190b2tlbl9pZCA9IGt3YXJncy5ib3NfdG9rZW5faWQgPz8gbnVsbDtcbiAgICAgICAgdGhpcy5lb3NfdG9rZW5faWQgPSBrd2FyZ3MuZW9zX3Rva2VuX2lkID8/IG51bGw7XG5cbiAgICAgICAgLy8gR2VuZXJhdGlvbiBwYXJhbWV0ZXJzIGV4Y2x1c2l2ZSB0byBlbmNvZGVyLWRlY29kZXIgbW9kZWxzXG4gICAgICAgIHRoaXMuZW5jb2Rlcl9ub19yZXBlYXRfbmdyYW1fc2l6ZSA9IGt3YXJncy5lbmNvZGVyX25vX3JlcGVhdF9uZ3JhbV9zaXplID8/IDA7XG4gICAgICAgIHRoaXMuZGVjb2Rlcl9zdGFydF90b2tlbl9pZCA9IGt3YXJncy5kZWNvZGVyX3N0YXJ0X3Rva2VuX2lkID8/IG51bGw7XG5cbiAgICAgICAgLy8gV2lsZCBjYXJkXG4gICAgICAgIHRoaXMuZ2VuZXJhdGlvbl9rd2FyZ3MgPSBrd2FyZ3MuZ2VuZXJhdGlvbl9rd2FyZ3MgPz8ge307XG4gICAgfVxufVxuXG5cbi8qKlxuICogU2FtcGxlciBpcyBhIGJhc2UgY2xhc3MgZm9yIGFsbCBzYW1wbGluZyBtZXRob2RzIHVzZWQgZm9yIHRleHQgZ2VuZXJhdGlvbi5cbiAqL1xuZXhwb3J0IGNsYXNzIFNhbXBsZXIgZXh0ZW5kcyBDYWxsYWJsZSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBTYW1wbGVyIG9iamVjdCB3aXRoIHRoZSBzcGVjaWZpZWQgZ2VuZXJhdGlvbiBjb25maWcuXG4gICAgICogQHBhcmFtIHtHZW5lcmF0aW9uQ29uZmlnfSBnZW5lcmF0aW9uX2NvbmZpZyBUaGUgZ2VuZXJhdGlvbiBjb25maWcuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZ2VuZXJhdGlvbl9jb25maWcpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5nZW5lcmF0aW9uX2NvbmZpZyA9IGdlbmVyYXRpb25fY29uZmlnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV4ZWN1dGVzIHRoZSBzYW1wbGVyLCB1c2luZyB0aGUgc3BlY2lmaWVkIGxvZ2l0cy5cbiAgICAgKiBAcGFyYW0ge1RlbnNvcn0gbG9naXRzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICovXG4gICAgX2NhbGwobG9naXRzLCBpbmRleCA9IC0xKSB7XG4gICAgICAgIC8vIFNhbXBsZSBmcm9tIGxvZ2l0cywgb2YgZGltcyBbYmF0Y2gsIHNlcXVlbmNlX2xlbmd0aCwgdm9jYWJfc2l6ZV0uXG4gICAgICAgIC8vIElmIGluZGV4IGlzIHNwZWNpZmllZCwgc2FtcGxlIGZyb20gW2JhdGNoLCBpbmRleCwgdm9jYWJfc2l6ZV0uXG4gICAgICAgIHJldHVybiB0aGlzLnNhbXBsZShsb2dpdHMsIGluZGV4KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBYnN0cmFjdCBtZXRob2QgZm9yIHNhbXBsaW5nIHRoZSBsb2dpdHMuXG4gICAgICogQHBhcmFtIHtUZW5zb3J9IGxvZ2l0c1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICAgICAqIEB0aHJvd3Mge0Vycm9yfVxuICAgICAqL1xuICAgIHNhbXBsZShsb2dpdHMsIGluZGV4KSB7XG4gICAgICAgIHRocm93IEVycm9yKFwic2FtcGxlIHNob3VsZCBiZSBpbXBsZW1lbnRlZCBpbiBzdWJjbGFzc2VzLlwiKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHNwZWNpZmllZCBsb2dpdHMgYXMgYW4gYXJyYXksIHdpdGggdGVtcGVyYXR1cmUgYXBwbGllZC5cbiAgICAgKiBAcGFyYW0ge1RlbnNvcn0gbG9naXRzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gICAgICogQHJldHVybnMge0FycmF5fVxuICAgICAqL1xuICAgIGdldExvZ2l0cyhsb2dpdHMsIGluZGV4KSB7XG4gICAgICAgIGxldCB2b2NhYlNpemUgPSBsb2dpdHMuZGltcy5hdCgtMSk7XG5cbiAgICAgICAgbGV0IGxvZ3MgPSBsb2dpdHMuZGF0YTtcblxuICAgICAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICBsb2dzID0gbG9ncy5zbGljZSgtdm9jYWJTaXplKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldCBzdGFydEluZGV4ID0gaW5kZXggKiB2b2NhYlNpemU7XG4gICAgICAgICAgICBsb2dzID0gbG9ncy5zbGljZShzdGFydEluZGV4LCBzdGFydEluZGV4ICsgdm9jYWJTaXplKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFkZCB0ZW1wZXJhdHVyZVxuICAgICAgICBpZiAodGhpcy5nZW5lcmF0aW9uX2NvbmZpZy50ZW1wZXJhdHVyZSA+IDApIHtcbiAgICAgICAgICAgIGxvZ3MgPSBsb2dzLm1hcCh4ID0+IHggLyB0aGlzLmdlbmVyYXRpb25fY29uZmlnLnRlbXBlcmF0dXJlKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsb2dzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNlbGVjdHMgYW4gaXRlbSByYW5kb21seSBiYXNlZCBvbiB0aGUgc3BlY2lmaWVkIHByb2JhYmlsaXRpZXMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gcHJvYmFiaWxpdGllcyBBbiBhcnJheSBvZiBwcm9iYWJpbGl0aWVzIHRvIHVzZSBmb3Igc2VsZWN0aW9uLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSBpbmRleCBvZiB0aGUgc2VsZWN0ZWQgaXRlbS5cbiAgICAgKi9cbiAgICByYW5kb21TZWxlY3QocHJvYmFiaWxpdGllcykge1xuICAgICAgICAvLyBSZXR1cm4gaW5kZXggb2YgY2hvc2VuIGl0ZW1cbiAgICAgICAgbGV0IHN1bVByb2JhYmlsaXRpZXMgPSBwcm9iYWJpbGl0aWVzLnJlZHVjZSgoYWNjLCBjdXJyKSA9PiBhY2MgKyBjdXJyLCAwKTtcblxuICAgICAgICBsZXQgciA9IE1hdGgucmFuZG9tKCkgKiBzdW1Qcm9iYWJpbGl0aWVzO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByb2JhYmlsaXRpZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHIgLT0gcHJvYmFiaWxpdGllc1tpXTtcbiAgICAgICAgICAgIGlmIChyIDw9IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMDsgLy8gcmV0dXJuIGZpcnN0IChtb3N0IHByb2JhYmxlKSBhcyBhIGZhbGxiYWNrXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIFNhbXBsZXIgb2JqZWN0IGJhc2VkIG9uIHRoZSBzcGVjaWZpZWQgb3B0aW9ucy5cbiAgICAgKiBAcGFyYW0ge0dlbmVyYXRpb25Db25maWd9IGdlbmVyYXRpb25fY29uZmlnIEFuIG9iamVjdCBjb250YWluaW5nIG9wdGlvbnMgZm9yIHRoZSBzYW1wbGVyLlxuICAgICAqIEByZXR1cm5zIHtTYW1wbGVyfSBBIFNhbXBsZXIgb2JqZWN0LlxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRTYW1wbGVyKGdlbmVyYXRpb25fY29uZmlnKSB7XG4gICAgICAgIC8vIC0gKmdyZWVkeSBkZWNvZGluZyo6IGBudW1fYmVhbXM9MWAgYW5kIGBkb19zYW1wbGU9RmFsc2VgXG4gICAgICAgIC8vIC0gKmNvbnRyYXN0aXZlIHNlYXJjaCo6IGBwZW5hbHR5X2FscGhhPjBgIGFuZCBgdG9wX2s+MWBcbiAgICAgICAgLy8gLSAqbXVsdGlub21pYWwgc2FtcGxpbmcqOiBgbnVtX2JlYW1zPTFgIGFuZCBgZG9fc2FtcGxlPVRydWVgXG4gICAgICAgIC8vIC0gKmJlYW0tc2VhcmNoIGRlY29kaW5nKjogYG51bV9iZWFtcz4xYCBhbmQgYGRvX3NhbXBsZT1GYWxzZWBcbiAgICAgICAgLy8gLSAqYmVhbS1zZWFyY2ggbXVsdGlub21pYWwgc2FtcGxpbmcqOiBgbnVtX2JlYW1zPjFgIGFuZCBgZG9fc2FtcGxlPVRydWVgXG4gICAgICAgIC8vIC0gKmRpdmVyc2UgYmVhbS1zZWFyY2ggZGVjb2RpbmcqOiBgbnVtX2JlYW1zPjFgIGFuZCBgbnVtX2JlYW1fZ3JvdXBzPjFgXG4gICAgICAgIC8vIC0gKmNvbnN0cmFpbmVkIGJlYW0tc2VhcmNoIGRlY29kaW5nKjogYGNvbnN0cmFpbnRzIT1Ob25lYCBvciBgZm9yY2Vfd29yZHNfaWRzIT1Ob25lYFxuXG4gICAgICAgIC8vIE5PVEU6IGJlYW0gc2VhcmNoIGlzIGltcGxlbWVudGVkIGRpcmVjdGx5IGludG8gdGhlIGdlbmVyYXRpb24gZnVuY3Rpb25cbiAgICAgICAgaWYgKGdlbmVyYXRpb25fY29uZmlnLmRvX3NhbXBsZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBNdWx0aW5vbWlhbFNhbXBsZXIoZ2VuZXJhdGlvbl9jb25maWcpO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoZ2VuZXJhdGlvbl9jb25maWcubnVtX2JlYW1zID4gMSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBCZWFtU2VhcmNoU2FtcGxlcihnZW5lcmF0aW9uX2NvbmZpZyk7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChnZW5lcmF0aW9uX2NvbmZpZy5udW1fcmV0dXJuX3NlcXVlbmNlcyA+IDEpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihgbnVtX3JldHVybl9zZXF1ZW5jZXMgaGFzIHRvIGJlIDEgd2hlbiBkb2luZyBncmVlZHkgc2VhcmNoLCBidXQgaXMgJHtnZW5lcmF0aW9uX2NvbmZpZy5udW1fcmV0dXJuX3NlcXVlbmNlc30uYClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgR3JlZWR5U2FtcGxlcihnZW5lcmF0aW9uX2NvbmZpZyk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKlxuICogQ2xhc3MgcmVwcmVzZW50aW5nIGEgR3JlZWR5IFNhbXBsZXIuXG4gKiBAZXh0ZW5kcyBTYW1wbGVyXG4gKi9cbmNsYXNzIEdyZWVkeVNhbXBsZXIgZXh0ZW5kcyBTYW1wbGVyIHtcbiAgICAvKipcbiAgICAgKiBTYW1wbGUgdGhlIG1heGltdW0gcHJvYmFiaWxpdHkgb2YgYSBnaXZlbiBsb2dpdHMgdGVuc29yLlxuICAgICAqIEBwYXJhbSB7VGVuc29yfSBsb2dpdHNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2luZGV4PS0xXVxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gQW4gYXJyYXkgd2l0aCBhIHNpbmdsZSB0dXBsZSwgY29udGFpbmluZyB0aGUgaW5kZXggb2YgdGhlIG1heGltdW0gdmFsdWUgYW5kIGEgbWVhbmluZ2xlc3Mgc2NvcmUgKHNpbmNlIHRoaXMgaXMgYSBncmVlZHkgc2VhcmNoKS5cbiAgICAgKi9cbiAgICBzYW1wbGUobG9naXRzLCBpbmRleCA9IC0xKSB7XG4gICAgICAgIC8vIE5PVEU6IG5vIG5lZWQgdG8gZG8gbG9nX3NvZnRtYXggaGVyZSBzaW5jZSB3ZSBvbmx5IHRha2UgdGhlIG1heGltdW1cbiAgICAgICAgbGV0IGxvZ3MgPSB0aGlzLmdldExvZ2l0cyhsb2dpdHMsIGluZGV4KTtcbiAgICAgICAgbGV0IGFyZ21heCA9IG1heChsb2dzKVsxXTtcblxuICAgICAgICAvLyBOb3RlOiBzY29yZSBpcyBtZWFuaW5nbGVzcyBpbiB0aGlzIGNvbnRleHQsIHNpbmNlIHdlIGFyZSBwZXJmb3JtaW5nXG4gICAgICAgIC8vIGdyZWVkeSBzZWFyY2ggKHAgPSAxID0+IGxvZyhwKSA9IDApXG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBbYXJnbWF4LCAwXVxuICAgICAgICBdO1xuICAgIH1cbn1cblxuLyoqXG4gKiBDbGFzcyByZXByZXNlbnRpbmcgYSBNdWx0aW5vbWlhbFNhbXBsZXIuXG4gKiBAZXh0ZW5kcyBTYW1wbGVyXG4gKi9cbmNsYXNzIE11bHRpbm9taWFsU2FtcGxlciBleHRlbmRzIFNhbXBsZXIge1xuXG4gICAgLyoqXG4gICAgICogU2FtcGxlIGZyb20gdGhlIGxvZ2l0cy5cbiAgICAgKiBAcGFyYW0ge1RlbnNvcn0gbG9naXRzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gICAgICogQHJldHVybnMge0FycmF5fVxuICAgICAqL1xuICAgIHNhbXBsZShsb2dpdHMsIGluZGV4ID0gLTEpIHtcbiAgICAgICAgbGV0IGsgPSBsb2dpdHMuZGltcy5hdCgtMSk7IC8vIGRlZmF1bHRzIHRvIHZvY2FiIHNpemVcbiAgICAgICAgaWYgKHRoaXMuZ2VuZXJhdGlvbl9jb25maWcudG9wX2sgPiAwKSB7XG4gICAgICAgICAgICBrID0gTWF0aC5taW4odGhpcy5nZW5lcmF0aW9uX2NvbmZpZy50b3Bfaywgayk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBHZXQgbG9naXRzIG9mIG50aCB0b2tlblxuICAgICAgICBjb25zdCBsb2dzID0gdGhpcy5nZXRMb2dpdHMobG9naXRzLCBpbmRleCk7XG5cbiAgICAgICAgLy8gR2V0IHRvcCBrIHRva2Vuc1xuICAgICAgICBjb25zdCB0b3BMb2dpdHMgPSBnZXRUb3BJdGVtcyhsb2dzLCBrKTtcblxuICAgICAgICAvLyBDb21wdXRlIHNvZnRtYXggb3ZlciBsb2dpdHNcbiAgICAgICAgY29uc3QgcHJvYmFiaWxpdGllcyA9IHNvZnRtYXgodG9wTG9naXRzLm1hcCh4ID0+IHhbMV0pKTtcblxuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbSh7IGxlbmd0aDogdGhpcy5nZW5lcmF0aW9uX2NvbmZpZy5udW1fYmVhbXMgfSwgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc2FtcGxlZEluZGV4ID0gdGhpcy5yYW5kb21TZWxlY3QocHJvYmFiaWxpdGllcyk7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIHRvcExvZ2l0c1tzYW1wbGVkSW5kZXhdWzBdLCAvLyB0b2tlbiBpZFxuICAgICAgICAgICAgICAgIE1hdGgubG9nKHByb2JhYmlsaXRpZXNbc2FtcGxlZEluZGV4XSksIC8vIHNjb3JlXG4gICAgICAgICAgICBdO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5cblxuLyoqXG4gKiBDbGFzcyByZXByZXNlbnRpbmcgYSBCZWFtU2VhcmNoU2FtcGxlci5cbiAqIEBleHRlbmRzIFNhbXBsZXJcbiAqL1xuY2xhc3MgQmVhbVNlYXJjaFNhbXBsZXIgZXh0ZW5kcyBTYW1wbGVyIHtcblxuICAgIC8qKlxuICAgICAqIFNhbXBsZSBmcm9tIHRoZSBsb2dpdHMuXG4gICAgICogQHBhcmFtIHtUZW5zb3J9IGxvZ2l0c1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICAgICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICAgKi9cbiAgICBzYW1wbGUobG9naXRzLCBpbmRleCA9IC0xKSB7XG4gICAgICAgIGxldCBrID0gbG9naXRzLmRpbXMuYXQoLTEpOyAvLyBkZWZhdWx0cyB0byB2b2NhYiBzaXplXG4gICAgICAgIGlmICh0aGlzLmdlbmVyYXRpb25fY29uZmlnLnRvcF9rID4gMCkge1xuICAgICAgICAgICAgayA9IE1hdGgubWluKHRoaXMuZ2VuZXJhdGlvbl9jb25maWcudG9wX2ssIGspO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gR2V0IGxvZ2l0cyBvZiBudGggdG9rZW5cbiAgICAgICAgY29uc3QgbG9ncyA9IHRoaXMuZ2V0TG9naXRzKGxvZ2l0cywgaW5kZXgpO1xuXG4gICAgICAgIC8vIEdldCB0b3AgayB0b2tlbnNcbiAgICAgICAgY29uc3QgdG9wTG9naXRzID0gZ2V0VG9wSXRlbXMobG9ncywgayk7XG5cbiAgICAgICAgLy8gQ29tcHV0ZSBzb2Z0bWF4IG92ZXIgbG9naXRzXG4gICAgICAgIGNvbnN0IHByb2JhYmlsaXRpZXMgPSBzb2Z0bWF4KHRvcExvZ2l0cy5tYXAoeCA9PiB4WzFdKSk7XG5cbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20oeyBsZW5ndGg6IHRoaXMuZ2VuZXJhdGlvbl9jb25maWcubnVtX2JlYW1zIH0sIChfLCBpKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIHRvcExvZ2l0c1tpXVswXSwgLy8gdG9rZW4gaWRcbiAgICAgICAgICAgICAgICBNYXRoLmxvZyhwcm9iYWJpbGl0aWVzW2ldKSwgLy8gc2NvcmVcbiAgICAgICAgICAgIF07XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@xenova/transformers/src/utils/generation.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@xenova/transformers/src/utils/hub.js":
/*!************************************************************!*\
  !*** ./node_modules/@xenova/transformers/src/utils/hub.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getFile: () => (/* binding */ getFile),\n/* harmony export */   getModelFile: () => (/* binding */ getModelFile),\n/* harmony export */   getModelJSON: () => (/* binding */ getModelJSON)\n/* harmony export */ });\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fs */ \"fs\");\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! path */ \"path\");\n/* harmony import */ var stream_web__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! stream/web */ \"stream/web\");\n/* harmony import */ var _env_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../env.js */ \"(ssr)/./node_modules/@xenova/transformers/src/env.js\");\n/* harmony import */ var _core_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./core.js */ \"(ssr)/./node_modules/@xenova/transformers/src/utils/core.js\");\n\n/**\n * @file Utility functions to interact with the Hugging Face Hub (https://huggingface.co/models)\n * \n * @module utils/hub\n */\n\n\n\n\n\n\n\n\nif (!globalThis.ReadableStream) {\n    // @ts-ignore\n    globalThis.ReadableStream = stream_web__WEBPACK_IMPORTED_MODULE_2__.ReadableStream; // ReadableStream is not a global with Node 16\n}\n\n/**\n * @typedef {Object} PretrainedOptions Options for loading a pretrained model.     \n * @property {boolean?} [options.quantized=true] Whether to load the 8-bit quantized version of the model (only applicable when loading model files).\n * @property {function} [options.progress_callback=null] If specified, this function will be called during model construction, to provide the user with progress updates.\n * @property {Object} [options.config=null] Configuration for the model to use instead of an automatically loaded configuration. Configuration can be automatically loaded when:\n * - The model is a model provided by the library (loaded with the *model id* string of a pretrained model).\n * - The model is loaded by supplying a local directory as `pretrained_model_name_or_path` and a configuration JSON file named *config.json* is found in the directory.\n * @property {string} [options.cache_dir=null] Path to a directory in which a downloaded pretrained model configuration should be cached if the standard cache should not be used.\n * @property {boolean} [options.local_files_only=false] Whether or not to only look at local files (e.g., not try downloading the model).\n * @property {string} [options.revision='main'] The specific model version to use. It can be a branch name, a tag name, or a commit id,\n * since we use a git-based system for storing models and other artifacts on huggingface.co, so `revision` can be any identifier allowed by git.\n * NOTE: This setting is ignored for local requests.\n */\n\nclass FileResponse {\n    /**\n     * Mapping from file extensions to MIME types.\n     */\n    _CONTENT_TYPE_MAP = {\n        'txt': 'text/plain',\n        'html': 'text/html',\n        'css': 'text/css',\n        'js': 'text/javascript',\n        'json': 'application/json',\n        'png': 'image/png',\n        'jpg': 'image/jpeg',\n        'jpeg': 'image/jpeg',\n        'gif': 'image/gif',\n    }\n    /**\n     * Creates a new `FileResponse` object.\n     * @param {string|URL} filePath\n     */\n    constructor(filePath) {\n        this.filePath = filePath;\n        this.headers = new Headers();\n\n        this.exists = fs__WEBPACK_IMPORTED_MODULE_0__.existsSync(filePath);\n        if (this.exists) {\n            this.status = 200;\n            this.statusText = 'OK';\n\n            let stats = fs__WEBPACK_IMPORTED_MODULE_0__.statSync(filePath);\n            this.headers.set('content-length', stats.size.toString());\n\n            this.updateContentType();\n\n            let self = this;\n            this.body = new ReadableStream({\n                start(controller) {\n                    self.arrayBuffer().then(buffer => {\n                        controller.enqueue(new Uint8Array(buffer));\n                        controller.close();\n                    })\n                }\n            });\n        } else {\n            this.status = 404;\n            this.statusText = 'Not Found';\n            this.body = null;\n        }\n    }\n\n    /**\n     * Updates the 'content-type' header property of the response based on the extension of\n     * the file specified by the filePath property of the current object.\n     * @returns {void}\n     */\n    updateContentType() {\n        // Set content-type header based on file extension\n        const extension = this.filePath.toString().split('.').pop().toLowerCase();\n        this.headers.set('content-type', this._CONTENT_TYPE_MAP[extension] ?? 'application/octet-stream');\n    }\n\n    /**\n     * Clone the current FileResponse object.\n     * @returns {FileResponse} A new FileResponse object with the same properties as the current object.\n     */\n    clone() {\n        let response = new FileResponse(this.filePath);\n        response.exists = this.exists;\n        response.status = this.status;\n        response.statusText = this.statusText;\n        response.headers = new Headers(this.headers);\n        return response;\n    }\n\n    /**\n     * Reads the contents of the file specified by the filePath property and returns a Promise that\n     * resolves with an ArrayBuffer containing the file's contents.\n     * @returns {Promise<ArrayBuffer>} A Promise that resolves with an ArrayBuffer containing the file's contents.\n     * @throws {Error} If the file cannot be read.\n     */\n    async arrayBuffer() {\n        const data = await fs__WEBPACK_IMPORTED_MODULE_0__.promises.readFile(this.filePath);\n        return data.buffer;\n    }\n\n    /**\n     * Reads the contents of the file specified by the filePath property and returns a Promise that\n     * resolves with a Blob containing the file's contents.\n     * @returns {Promise<Blob>} A Promise that resolves with a Blob containing the file's contents.\n     * @throws {Error} If the file cannot be read.\n     */\n    async blob() {\n        const data = await fs__WEBPACK_IMPORTED_MODULE_0__.promises.readFile(this.filePath);\n        return new Blob([data], { type: this.headers.get('content-type') });\n    }\n\n    /**\n     * Reads the contents of the file specified by the filePath property and returns a Promise that\n     * resolves with a string containing the file's contents.\n     * @returns {Promise<string>} A Promise that resolves with a string containing the file's contents.\n     * @throws {Error} If the file cannot be read.\n     */\n    async text() {\n        const data = await fs__WEBPACK_IMPORTED_MODULE_0__.promises.readFile(this.filePath, 'utf8');\n        return data;\n    }\n\n    /**\n     * Reads the contents of the file specified by the filePath property and returns a Promise that\n     * resolves with a parsed JavaScript object containing the file's contents.\n     * \n     * @returns {Promise<Object>} A Promise that resolves with a parsed JavaScript object containing the file's contents.\n     * @throws {Error} If the file cannot be read.\n     */\n    async json() {\n        return JSON.parse(await this.text());\n    }\n}\n\n/**\n * Determines whether the given string is a valid HTTP or HTTPS URL.\n * @param {string|URL} string The string to test for validity as an HTTP or HTTPS URL.\n * @param {string[]} [validHosts=null] A list of valid hostnames. If specified, the URL's hostname must be in this list.\n * @returns {boolean} True if the string is a valid HTTP or HTTPS URL, false otherwise.\n */\nfunction isValidHttpUrl(string, validHosts = null) {\n    // https://stackoverflow.com/a/43467144\n    let url;\n    try {\n        url = new URL(string);\n    } catch (_) {\n        return false;\n    }\n    if (validHosts && !validHosts.includes(url.hostname)) {\n        return false;\n    }\n    return url.protocol === \"http:\" || url.protocol === \"https:\";\n}\n\n/**\n * Helper function to get a file, using either the Fetch API or FileSystem API.\n *\n * @param {URL|string} urlOrPath The URL/path of the file to get.\n * @returns {Promise<FileResponse|Response>} A promise that resolves to a FileResponse object (if the file is retrieved using the FileSystem API), or a Response object (if the file is retrieved using the Fetch API).\n */\nasync function getFile(urlOrPath) {\n\n    if (_env_js__WEBPACK_IMPORTED_MODULE_3__.env.useFS && !isValidHttpUrl(urlOrPath)) {\n        return new FileResponse(urlOrPath);\n\n    } else if (typeof process !== 'undefined' && process?.release?.name === 'node') {\n        const IS_CI = !!process.env?.TESTING_REMOTELY;\n        const version = _env_js__WEBPACK_IMPORTED_MODULE_3__.env.version;\n\n        const headers = new Headers();\n        headers.set('User-Agent', `transformers.js/${version}; is_ci/${IS_CI};`);\n\n        // Check whether we are making a request to the Hugging Face Hub.\n        const isHFURL = isValidHttpUrl(urlOrPath, ['huggingface.co', 'hf.co']);\n        if (isHFURL) {\n            // If an access token is present in the environment variables,\n            // we add it to the request headers.\n            const token = process.env?.HF_ACCESS_TOKEN;\n            if (token) {\n                headers.set('Authorization', `Bearer ${token}`);\n            }\n        }\n        return fetch(urlOrPath, { headers });\n    } else {\n        // Running in a browser-environment, so we use default headers\n        // NOTE: We do not allow passing authorization headers in the browser,\n        // since this would require exposing the token to the client.\n        return fetch(urlOrPath);\n    }\n}\n\nconst ERROR_MAPPING = {\n    // 4xx errors (https://developer.mozilla.org/en-US/docs/Web/HTTP/Status#client_error_responses)\n    400: 'Bad request error occurred while trying to load file',\n    401: 'Unauthorized access to file',\n    403: 'Forbidden access to file',\n    404: 'Could not locate file',\n    408: 'Request timeout error occurred while trying to load file',\n\n    // 5xx errors (https://developer.mozilla.org/en-US/docs/Web/HTTP/Status#server_error_responses)\n    500: 'Internal server error error occurred while trying to load file',\n    502: 'Bad gateway error occurred while trying to load file',\n    503: 'Service unavailable error occurred while trying to load file',\n    504: 'Gateway timeout error occurred while trying to load file',\n}\n/**\n * Helper method to handle fatal errors that occur while trying to load a file from the Hugging Face Hub.\n * @param {number} status The HTTP status code of the error.\n * @param {string} remoteURL The URL of the file that could not be loaded.\n * @param {boolean} fatal Whether to raise an error if the file could not be loaded.\n * @returns {null} Returns `null` if `fatal = true`.\n * @throws {Error} If `fatal = false`.\n */\nfunction handleError(status, remoteURL, fatal) {\n    if (!fatal) {\n        // File was not loaded correctly, but it is optional.\n        // TODO in future, cache the response?\n        return null;\n    }\n\n    const message = ERROR_MAPPING[status] ?? `Error (${status}) occurred while trying to load file`;\n    throw Error(`${message}: \"${remoteURL}\".`);\n}\n\nclass FileCache {\n    /**\n     * Instantiate a `FileCache` object.\n     * @param {string} path \n     */\n    constructor(path) {\n        this.path = path;\n    }\n\n    /**\n     * Checks whether the given request is in the cache.\n     * @param {string} request \n     * @returns {Promise<FileResponse | undefined>}\n     */\n    async match(request) {\n\n        let filePath = path__WEBPACK_IMPORTED_MODULE_1__.join(this.path, request);\n        let file = new FileResponse(filePath);\n\n        if (file.exists) {\n            return file;\n        } else {\n            return undefined;\n        }\n    }\n\n    /**\n     * Adds the given response to the cache.\n     * @param {string} request \n     * @param {Response|FileResponse} response \n     * @returns {Promise<void>}\n     */\n    async put(request, response) {\n        const buffer = Buffer.from(await response.arrayBuffer());\n\n        let outputPath = path__WEBPACK_IMPORTED_MODULE_1__.join(this.path, request);\n\n        try {\n            await fs__WEBPACK_IMPORTED_MODULE_0__.promises.mkdir(path__WEBPACK_IMPORTED_MODULE_1__.dirname(outputPath), { recursive: true });\n            await fs__WEBPACK_IMPORTED_MODULE_0__.promises.writeFile(outputPath, buffer);\n\n        } catch (err) {\n            console.warn('An error occurred while writing the file to cache:', err)\n        }\n    }\n\n    // TODO add the rest?\n    // addAll(requests: RequestInfo[]): Promise<void>;\n    // delete(request: RequestInfo | URL, options?: CacheQueryOptions): Promise<boolean>;\n    // keys(request?: RequestInfo | URL, options?: CacheQueryOptions): Promise<ReadonlyArray<Request>>;\n    // match(request: RequestInfo | URL, options?: CacheQueryOptions): Promise<Response | undefined>;\n    // matchAll(request?: RequestInfo | URL, options?: CacheQueryOptions): Promise<ReadonlyArray<Response>>;\n}\n\n/**\n * \n * @param {FileCache|Cache} cache The cache to search\n * @param {string[]} names The names of the item to search for\n * @returns {Promise<FileResponse|Response|undefined>} The item from the cache, or undefined if not found.\n */\nasync function tryCache(cache, ...names) {\n    for (let name of names) {\n        try {\n            let result = await cache.match(name);\n            if (result) return result;\n        } catch (e) {\n            continue;\n        }\n    }\n    return undefined;\n}\n\n/**\n * \n * Retrieves a file from either a remote URL using the Fetch API or from the local file system using the FileSystem API.\n * If the filesystem is available and `env.useCache = true`, the file will be downloaded and cached.\n * \n * @param {string} path_or_repo_id This can be either:\n * - a string, the *model id* of a model repo on huggingface.co.\n * - a path to a *directory* potentially containing the file.\n * @param {string} filename The name of the file to locate in `path_or_repo`.\n * @param {boolean} [fatal=true] Whether to throw an error if the file is not found.\n * @param {PretrainedOptions} [options] An object containing optional parameters.\n * \n * @throws Will throw an error if the file is not found and `fatal` is true.\n * @returns {Promise} A Promise that resolves with the file content as a buffer.\n */\nasync function getModelFile(path_or_repo_id, filename, fatal = true, options = {}) {\n\n    if (!_env_js__WEBPACK_IMPORTED_MODULE_3__.env.allowLocalModels) {\n        // User has disabled local models, so we just make sure other settings are correct.\n\n        if (options.local_files_only) {\n            throw Error(\"Invalid configuration detected: local models are disabled (`env.allowLocalModels=false`) but you have requested to only use local models (`local_files_only=true`).\")\n        } else if (!_env_js__WEBPACK_IMPORTED_MODULE_3__.env.allowRemoteModels) {\n            throw Error(\"Invalid configuration detected: both local and remote models are disabled. Fix by setting `env.allowLocalModels` or `env.allowRemoteModels` to `true`.\")\n        }\n    }\n\n    // Initiate file retrieval\n    (0,_core_js__WEBPACK_IMPORTED_MODULE_4__.dispatchCallback)(options.progress_callback, {\n        status: 'initiate',\n        name: path_or_repo_id,\n        file: filename\n    })\n\n    // First, check if the a caching backend is available\n    // If no caching mechanism available, will download the file every time\n    let cache;\n    if (!cache && _env_js__WEBPACK_IMPORTED_MODULE_3__.env.useBrowserCache) {\n        if (typeof caches === 'undefined') {\n            throw Error('Browser cache is not available in this environment.')\n        }\n        try {\n            // In some cases, the browser cache may be visible, but not accessible due to security restrictions.\n            // For example, when running an application in an iframe, if a user attempts to load the page in\n            // incognito mode, the following error is thrown: `DOMException: Failed to execute 'open' on 'CacheStorage':\n            // An attempt was made to break through the security policy of the user agent.`\n            // So, instead of crashing, we just ignore the error and continue without using the cache.\n            cache = await caches.open('transformers-cache');\n        } catch (e) {\n            console.warn('An error occurred while opening the browser cache:', e);\n        }\n    }\n\n    if (!cache && _env_js__WEBPACK_IMPORTED_MODULE_3__.env.useFSCache) {\n        // TODO throw error if not available\n\n        // If `cache_dir` is not specified, use the default cache directory\n        cache = new FileCache(options.cache_dir ?? _env_js__WEBPACK_IMPORTED_MODULE_3__.env.cacheDir);\n    }\n\n    const revision = options.revision ?? 'main';\n\n    let requestURL = pathJoin(path_or_repo_id, filename);\n    let localPath = pathJoin(_env_js__WEBPACK_IMPORTED_MODULE_3__.env.localModelPath, requestURL);\n\n    let remoteURL = pathJoin(\n        _env_js__WEBPACK_IMPORTED_MODULE_3__.env.remoteHost,\n        _env_js__WEBPACK_IMPORTED_MODULE_3__.env.remotePathTemplate\n            .replaceAll('{model}', path_or_repo_id)\n            .replaceAll('{revision}', revision),\n        filename\n    );\n\n    // Choose cache key for filesystem cache\n    // When using the main revision (default), we use the request URL as the cache key.\n    // If a specific revision is requested, we account for this in the cache key.\n    let fsCacheKey = revision === 'main' ? requestURL : pathJoin(path_or_repo_id, revision, filename);\n\n    /** @type {string} */\n    let cacheKey;\n    let proposedCacheKey = cache instanceof FileCache ? fsCacheKey : remoteURL;\n\n    /** @type {Response|undefined} */\n    let responseToCache;\n\n    /** @type {Response|FileResponse|undefined} */\n    let response;\n\n    if (cache) {\n        // A caching system is available, so we try to get the file from it.\n        //  1. We first try to get from cache using the local path. In some environments (like deno),\n        //     non-URL cache keys are not allowed. In these cases, `response` will be undefined.\n        //  2. If no response is found, we try to get from cache using the remote URL or file system cache.\n        response = await tryCache(cache, localPath, proposedCacheKey);\n    }\n\n    if (response === undefined) {\n        // Caching not available, or file is not cached, so we perform the request\n\n        if (_env_js__WEBPACK_IMPORTED_MODULE_3__.env.allowLocalModels) {\n            // Accessing local models is enabled, so we try to get the file locally.\n            // If request is a valid HTTP URL, we skip the local file check. Otherwise, we try to get the file locally.\n            const isURL = isValidHttpUrl(requestURL);\n            if (!isURL) {\n                try {\n                    response = await getFile(localPath);\n                    cacheKey = localPath; // Update the cache key to be the local path\n                } catch (e) {\n                    // Something went wrong while trying to get the file locally.\n                    // NOTE: error handling is done in the next step (since `response` will be undefined)\n                    console.warn(`Unable to load from local path \"${localPath}\": \"${e}\"`);\n                }\n            } else if (options.local_files_only) {\n                throw new Error(`\\`local_files_only=true\\`, but attempted to load a remote file from: ${requestURL}.`);\n            } else if (!_env_js__WEBPACK_IMPORTED_MODULE_3__.env.allowRemoteModels) {\n                throw new Error(`\\`env.allowRemoteModels=false\\`, but attempted to load a remote file from: ${requestURL}.`);\n            }\n        }\n\n        if (response === undefined || response.status === 404) {\n            // File not found locally. This means either:\n            // - The user has disabled local file access (`env.allowLocalModels=false`)\n            // - the path is a valid HTTP url (`response === undefined`)\n            // - the path is not a valid HTTP url and the file is not present on the file system or local server (`response.status === 404`)\n\n            if (options.local_files_only || !_env_js__WEBPACK_IMPORTED_MODULE_3__.env.allowRemoteModels) {\n                // User requested local files only, but the file is not found locally.\n                if (fatal) {\n                    throw Error(`\\`local_files_only=true\\` or \\`env.allowRemoteModels=false\\` and file was not found locally at \"${localPath}\".`);\n                } else {\n                    // File not found, but this file is optional.\n                    // TODO in future, cache the response?\n                    return null;\n                }\n            }\n\n            // File not found locally, so we try to download it from the remote server\n            response = await getFile(remoteURL);\n\n            if (response.status !== 200) {\n                return handleError(response.status, remoteURL, fatal);\n            }\n\n            // Success! We use the proposed cache key from earlier\n            cacheKey = proposedCacheKey;\n        }\n\n\n        if (cache && response instanceof Response && response.status === 200) {\n            // only clone if cache available, and response is valid\n            responseToCache = response.clone();\n        }\n    }\n\n\n    // Start downloading\n    (0,_core_js__WEBPACK_IMPORTED_MODULE_4__.dispatchCallback)(options.progress_callback, {\n        status: 'download',\n        name: path_or_repo_id,\n        file: filename\n    })\n\n    const buffer = await readResponse(response, data => {\n        ;(0,_core_js__WEBPACK_IMPORTED_MODULE_4__.dispatchCallback)(options.progress_callback, {\n            status: 'progress',\n            ...data,\n            name: path_or_repo_id,\n            file: filename\n        })\n    })\n\n\n    if (\n        // Only cache web responses\n        // i.e., do not cache FileResponses (prevents duplication)\n        responseToCache && cacheKey\n        &&\n        // Check again whether request is in cache. If not, we add the response to the cache\n        (await cache.match(cacheKey) === undefined)\n    ) {\n        await cache.put(cacheKey, responseToCache)\n            .catch(err => {\n                // Do not crash if unable to add to cache (e.g., QuotaExceededError).\n                // Rather, log a warning and proceed with execution.\n                console.warn(`Unable to add response to browser cache: ${err}.`);\n            });\n\n    }\n\n    (0,_core_js__WEBPACK_IMPORTED_MODULE_4__.dispatchCallback)(options.progress_callback, {\n        status: 'done',\n        name: path_or_repo_id,\n        file: filename\n    });\n\n    return buffer;\n}\n\n/**\n * Fetches a JSON file from a given path and file name.\n *\n * @param {string} modelPath The path to the directory containing the file.\n * @param {string} fileName The name of the file to fetch.\n * @param {boolean} [fatal=true] Whether to throw an error if the file is not found.\n * @param {PretrainedOptions} [options] An object containing optional parameters.\n * @returns {Promise<Object>} The JSON data parsed into a JavaScript object.\n * @throws Will throw an error if the file is not found and `fatal` is true.\n */\nasync function getModelJSON(modelPath, fileName, fatal = true, options = {}) {\n    let buffer = await getModelFile(modelPath, fileName, fatal, options);\n    if (buffer === null) {\n        // Return empty object\n        return {}\n    }\n\n    let decoder = new TextDecoder('utf-8');\n    let jsonData = decoder.decode(buffer);\n\n    return JSON.parse(jsonData);\n}\n\n/**\n * Read and track progress when reading a Response object\n *\n * @param {any} response The Response object to read\n * @param {function} progress_callback The function to call with progress updates\n * @returns {Promise<Uint8Array>} A Promise that resolves with the Uint8Array buffer\n */\nasync function readResponse(response, progress_callback) {\n    // Read and track progress when reading a Response object\n\n    const contentLength = response.headers.get('Content-Length');\n    if (contentLength === null) {\n        console.warn('Unable to determine content-length from response headers. Will expand buffer when needed.')\n    }\n    let total = parseInt(contentLength ?? '0');\n    let buffer = new Uint8Array(total);\n    let loaded = 0;\n\n    const reader = response.body.getReader();\n    async function read() {\n        const { done, value } = await reader.read();\n        if (done) return;\n\n        let newLoaded = loaded + value.length;\n        if (newLoaded > total) {\n            total = newLoaded;\n\n            // Adding the new data will overflow buffer.\n            // In this case, we extend the buffer\n            let newBuffer = new Uint8Array(total);\n\n            // copy contents\n            newBuffer.set(buffer);\n\n            buffer = newBuffer;\n        }\n        buffer.set(value, loaded)\n        loaded = newLoaded;\n\n        const progress = (loaded / total) * 100;\n\n        // Call your function here\n        progress_callback({\n            progress: progress,\n            loaded: loaded,\n            total: total,\n        })\n\n        return read();\n    }\n\n    // Actually read\n    await read();\n\n    return buffer;\n}\n\n/**\n * Joins multiple parts of a path into a single path, while handling leading and trailing slashes.\n *\n * @param {...string} parts Multiple parts of a path.\n * @returns {string} A string representing the joined path.\n */\nfunction pathJoin(...parts) {\n    // https://stackoverflow.com/a/55142565\n    parts = parts.map((part, index) => {\n        if (index) {\n            part = part.replace(new RegExp('^/'), '');\n        }\n        if (index !== parts.length - 1) {\n            part = part.replace(new RegExp('/$'), '');\n        }\n        return part;\n    })\n    return parts.join('/');\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHhlbm92YS90cmFuc2Zvcm1lcnMvc3JjL3V0aWxzL2h1Yi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVvQjtBQUNJO0FBQ1E7O0FBRUE7QUFDYTs7QUFFN0M7QUFDQTtBQUNBLGdDQUFnQyxzREFBcUIsRUFBRTtBQUN2RDs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjLFVBQVU7QUFDeEIsY0FBYyxVQUFVO0FBQ3hCLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsU0FBUztBQUN2QixjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFlBQVk7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLDBDQUFhO0FBQ25DO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0Isd0NBQVc7QUFDbkM7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsYUFBYTtBQUNiLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixjQUFjO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsc0JBQXNCO0FBQ3ZDLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQSwyQkFBMkIsd0NBQVc7QUFDdEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsZUFBZTtBQUNoQyxnQkFBZ0IsT0FB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Q0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQixXQUFXLG1CQUFtQjtBQUM5QixhQUFhLGlCQUFpQjtBQUM5QjtBQUNBO0FBQ08sMkVBQTJFO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLFVBQVU7QUFDckIsYUFBYSxxQkFBcUI7QUFDbEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0IsY0FBYztBQUM5Qjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxXQUFXO0FBQ3RCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90cmFuc2Zvcm1lcnNqcy1wbGF5Z3JvdW5kLy4vbm9kZV9tb2R1bGVzL0B4ZW5vdmEvdHJhbnNmb3JtZXJzL3NyYy91dGlscy9odWIuanM/ZTg0ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qKlxuICogQGZpbGUgVXRpbGl0eSBmdW5jdGlvbnMgdG8gaW50ZXJhY3Qgd2l0aCB0aGUgSHVnZ2luZyBGYWNlIEh1YiAoaHR0cHM6Ly9odWdnaW5nZmFjZS5jby9tb2RlbHMpXG4gKiBcbiAqIEBtb2R1bGUgdXRpbHMvaHViXG4gKi9cblxuaW1wb3J0IGZzIGZyb20gJ2ZzJztcbmltcG9ydCBwYXRoIGZyb20gJ3BhdGgnO1xuaW1wb3J0IHN0cmVhbSBmcm9tICdzdHJlYW0vd2ViJztcblxuaW1wb3J0IHsgZW52IH0gZnJvbSAnLi4vZW52LmpzJztcbmltcG9ydCB7IGRpc3BhdGNoQ2FsbGJhY2sgfSBmcm9tICcuL2NvcmUuanMnO1xuXG5pZiAoIWdsb2JhbFRoaXMuUmVhZGFibGVTdHJlYW0pIHtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgZ2xvYmFsVGhpcy5SZWFkYWJsZVN0cmVhbSA9IHN0cmVhbS5SZWFkYWJsZVN0cmVhbTsgLy8gUmVhZGFibGVTdHJlYW0gaXMgbm90IGEgZ2xvYmFsIHdpdGggTm9kZSAxNlxufVxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFByZXRyYWluZWRPcHRpb25zIE9wdGlvbnMgZm9yIGxvYWRpbmcgYSBwcmV0cmFpbmVkIG1vZGVsLiAgICAgXG4gKiBAcHJvcGVydHkge2Jvb2xlYW4/fSBbb3B0aW9ucy5xdWFudGl6ZWQ9dHJ1ZV0gV2hldGhlciB0byBsb2FkIHRoZSA4LWJpdCBxdWFudGl6ZWQgdmVyc2lvbiBvZiB0aGUgbW9kZWwgKG9ubHkgYXBwbGljYWJsZSB3aGVuIGxvYWRpbmcgbW9kZWwgZmlsZXMpLlxuICogQHByb3BlcnR5IHtmdW5jdGlvbn0gW29wdGlvbnMucHJvZ3Jlc3NfY2FsbGJhY2s9bnVsbF0gSWYgc3BlY2lmaWVkLCB0aGlzIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIGR1cmluZyBtb2RlbCBjb25zdHJ1Y3Rpb24sIHRvIHByb3ZpZGUgdGhlIHVzZXIgd2l0aCBwcm9ncmVzcyB1cGRhdGVzLlxuICogQHByb3BlcnR5IHtPYmplY3R9IFtvcHRpb25zLmNvbmZpZz1udWxsXSBDb25maWd1cmF0aW9uIGZvciB0aGUgbW9kZWwgdG8gdXNlIGluc3RlYWQgb2YgYW4gYXV0b21hdGljYWxseSBsb2FkZWQgY29uZmlndXJhdGlvbi4gQ29uZmlndXJhdGlvbiBjYW4gYmUgYXV0b21hdGljYWxseSBsb2FkZWQgd2hlbjpcbiAqIC0gVGhlIG1vZGVsIGlzIGEgbW9kZWwgcHJvdmlkZWQgYnkgdGhlIGxpYnJhcnkgKGxvYWRlZCB3aXRoIHRoZSAqbW9kZWwgaWQqIHN0cmluZyBvZiBhIHByZXRyYWluZWQgbW9kZWwpLlxuICogLSBUaGUgbW9kZWwgaXMgbG9hZGVkIGJ5IHN1cHBseWluZyBhIGxvY2FsIGRpcmVjdG9yeSBhcyBgcHJldHJhaW5lZF9tb2RlbF9uYW1lX29yX3BhdGhgIGFuZCBhIGNvbmZpZ3VyYXRpb24gSlNPTiBmaWxlIG5hbWVkICpjb25maWcuanNvbiogaXMgZm91bmQgaW4gdGhlIGRpcmVjdG9yeS5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbb3B0aW9ucy5jYWNoZV9kaXI9bnVsbF0gUGF0aCB0byBhIGRpcmVjdG9yeSBpbiB3aGljaCBhIGRvd25sb2FkZWQgcHJldHJhaW5lZCBtb2RlbCBjb25maWd1cmF0aW9uIHNob3VsZCBiZSBjYWNoZWQgaWYgdGhlIHN0YW5kYXJkIGNhY2hlIHNob3VsZCBub3QgYmUgdXNlZC5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW29wdGlvbnMubG9jYWxfZmlsZXNfb25seT1mYWxzZV0gV2hldGhlciBvciBub3QgdG8gb25seSBsb29rIGF0IGxvY2FsIGZpbGVzIChlLmcuLCBub3QgdHJ5IGRvd25sb2FkaW5nIHRoZSBtb2RlbCkuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW29wdGlvbnMucmV2aXNpb249J21haW4nXSBUaGUgc3BlY2lmaWMgbW9kZWwgdmVyc2lvbiB0byB1c2UuIEl0IGNhbiBiZSBhIGJyYW5jaCBuYW1lLCBhIHRhZyBuYW1lLCBvciBhIGNvbW1pdCBpZCxcbiAqIHNpbmNlIHdlIHVzZSBhIGdpdC1iYXNlZCBzeXN0ZW0gZm9yIHN0b3JpbmcgbW9kZWxzIGFuZCBvdGhlciBhcnRpZmFjdHMgb24gaHVnZ2luZ2ZhY2UuY28sIHNvIGByZXZpc2lvbmAgY2FuIGJlIGFueSBpZGVudGlmaWVyIGFsbG93ZWQgYnkgZ2l0LlxuICogTk9URTogVGhpcyBzZXR0aW5nIGlzIGlnbm9yZWQgZm9yIGxvY2FsIHJlcXVlc3RzLlxuICovXG5cbmNsYXNzIEZpbGVSZXNwb25zZSB7XG4gICAgLyoqXG4gICAgICogTWFwcGluZyBmcm9tIGZpbGUgZXh0ZW5zaW9ucyB0byBNSU1FIHR5cGVzLlxuICAgICAqL1xuICAgIF9DT05URU5UX1RZUEVfTUFQID0ge1xuICAgICAgICAndHh0JzogJ3RleHQvcGxhaW4nLFxuICAgICAgICAnaHRtbCc6ICd0ZXh0L2h0bWwnLFxuICAgICAgICAnY3NzJzogJ3RleHQvY3NzJyxcbiAgICAgICAgJ2pzJzogJ3RleHQvamF2YXNjcmlwdCcsXG4gICAgICAgICdqc29uJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAncG5nJzogJ2ltYWdlL3BuZycsXG4gICAgICAgICdqcGcnOiAnaW1hZ2UvanBlZycsXG4gICAgICAgICdqcGVnJzogJ2ltYWdlL2pwZWcnLFxuICAgICAgICAnZ2lmJzogJ2ltYWdlL2dpZicsXG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgYEZpbGVSZXNwb25zZWAgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfFVSTH0gZmlsZVBhdGhcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihmaWxlUGF0aCkge1xuICAgICAgICB0aGlzLmZpbGVQYXRoID0gZmlsZVBhdGg7XG4gICAgICAgIHRoaXMuaGVhZGVycyA9IG5ldyBIZWFkZXJzKCk7XG5cbiAgICAgICAgdGhpcy5leGlzdHMgPSBmcy5leGlzdHNTeW5jKGZpbGVQYXRoKTtcbiAgICAgICAgaWYgKHRoaXMuZXhpc3RzKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXR1cyA9IDIwMDtcbiAgICAgICAgICAgIHRoaXMuc3RhdHVzVGV4dCA9ICdPSyc7XG5cbiAgICAgICAgICAgIGxldCBzdGF0cyA9IGZzLnN0YXRTeW5jKGZpbGVQYXRoKTtcbiAgICAgICAgICAgIHRoaXMuaGVhZGVycy5zZXQoJ2NvbnRlbnQtbGVuZ3RoJywgc3RhdHMuc2l6ZS50b1N0cmluZygpKTtcblxuICAgICAgICAgICAgdGhpcy51cGRhdGVDb250ZW50VHlwZSgpO1xuXG4gICAgICAgICAgICBsZXQgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLmJvZHkgPSBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgICAgICAgICAgICAgIHN0YXJ0KGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5hcnJheUJ1ZmZlcigpLnRoZW4oYnVmZmVyID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShuZXcgVWludDhBcnJheShidWZmZXIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdHVzID0gNDA0O1xuICAgICAgICAgICAgdGhpcy5zdGF0dXNUZXh0ID0gJ05vdCBGb3VuZCc7XG4gICAgICAgICAgICB0aGlzLmJvZHkgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgJ2NvbnRlbnQtdHlwZScgaGVhZGVyIHByb3BlcnR5IG9mIHRoZSByZXNwb25zZSBiYXNlZCBvbiB0aGUgZXh0ZW5zaW9uIG9mXG4gICAgICogdGhlIGZpbGUgc3BlY2lmaWVkIGJ5IHRoZSBmaWxlUGF0aCBwcm9wZXJ0eSBvZiB0aGUgY3VycmVudCBvYmplY3QuXG4gICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICovXG4gICAgdXBkYXRlQ29udGVudFR5cGUoKSB7XG4gICAgICAgIC8vIFNldCBjb250ZW50LXR5cGUgaGVhZGVyIGJhc2VkIG9uIGZpbGUgZXh0ZW5zaW9uXG4gICAgICAgIGNvbnN0IGV4dGVuc2lvbiA9IHRoaXMuZmlsZVBhdGgudG9TdHJpbmcoKS5zcGxpdCgnLicpLnBvcCgpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHRoaXMuaGVhZGVycy5zZXQoJ2NvbnRlbnQtdHlwZScsIHRoaXMuX0NPTlRFTlRfVFlQRV9NQVBbZXh0ZW5zaW9uXSA/PyAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2xvbmUgdGhlIGN1cnJlbnQgRmlsZVJlc3BvbnNlIG9iamVjdC5cbiAgICAgKiBAcmV0dXJucyB7RmlsZVJlc3BvbnNlfSBBIG5ldyBGaWxlUmVzcG9uc2Ugb2JqZWN0IHdpdGggdGhlIHNhbWUgcHJvcGVydGllcyBhcyB0aGUgY3VycmVudCBvYmplY3QuXG4gICAgICovXG4gICAgY2xvbmUoKSB7XG4gICAgICAgIGxldCByZXNwb25zZSA9IG5ldyBGaWxlUmVzcG9uc2UodGhpcy5maWxlUGF0aCk7XG4gICAgICAgIHJlc3BvbnNlLmV4aXN0cyA9IHRoaXMuZXhpc3RzO1xuICAgICAgICByZXNwb25zZS5zdGF0dXMgPSB0aGlzLnN0YXR1cztcbiAgICAgICAgcmVzcG9uc2Uuc3RhdHVzVGV4dCA9IHRoaXMuc3RhdHVzVGV4dDtcbiAgICAgICAgcmVzcG9uc2UuaGVhZGVycyA9IG5ldyBIZWFkZXJzKHRoaXMuaGVhZGVycyk7XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWFkcyB0aGUgY29udGVudHMgb2YgdGhlIGZpbGUgc3BlY2lmaWVkIGJ5IHRoZSBmaWxlUGF0aCBwcm9wZXJ0eSBhbmQgcmV0dXJucyBhIFByb21pc2UgdGhhdFxuICAgICAqIHJlc29sdmVzIHdpdGggYW4gQXJyYXlCdWZmZXIgY29udGFpbmluZyB0aGUgZmlsZSdzIGNvbnRlbnRzLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEFycmF5QnVmZmVyPn0gQSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCBhbiBBcnJheUJ1ZmZlciBjb250YWluaW5nIHRoZSBmaWxlJ3MgY29udGVudHMuXG4gICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBmaWxlIGNhbm5vdCBiZSByZWFkLlxuICAgICAqL1xuICAgIGFzeW5jIGFycmF5QnVmZmVyKCkge1xuICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgZnMucHJvbWlzZXMucmVhZEZpbGUodGhpcy5maWxlUGF0aCk7XG4gICAgICAgIHJldHVybiBkYXRhLmJ1ZmZlcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWFkcyB0aGUgY29udGVudHMgb2YgdGhlIGZpbGUgc3BlY2lmaWVkIGJ5IHRoZSBmaWxlUGF0aCBwcm9wZXJ0eSBhbmQgcmV0dXJucyBhIFByb21pc2UgdGhhdFxuICAgICAqIHJlc29sdmVzIHdpdGggYSBCbG9iIGNvbnRhaW5pbmcgdGhlIGZpbGUncyBjb250ZW50cy5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxCbG9iPn0gQSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCBhIEJsb2IgY29udGFpbmluZyB0aGUgZmlsZSdzIGNvbnRlbnRzLlxuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgZmlsZSBjYW5ub3QgYmUgcmVhZC5cbiAgICAgKi9cbiAgICBhc3luYyBibG9iKCkge1xuICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgZnMucHJvbWlzZXMucmVhZEZpbGUodGhpcy5maWxlUGF0aCk7XG4gICAgICAgIHJldHVybiBuZXcgQmxvYihbZGF0YV0sIHsgdHlwZTogdGhpcy5oZWFkZXJzLmdldCgnY29udGVudC10eXBlJykgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVhZHMgdGhlIGNvbnRlbnRzIG9mIHRoZSBmaWxlIHNwZWNpZmllZCBieSB0aGUgZmlsZVBhdGggcHJvcGVydHkgYW5kIHJldHVybnMgYSBQcm9taXNlIHRoYXRcbiAgICAgKiByZXNvbHZlcyB3aXRoIGEgc3RyaW5nIGNvbnRhaW5pbmcgdGhlIGZpbGUncyBjb250ZW50cy5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxzdHJpbmc+fSBBIFByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIGEgc3RyaW5nIGNvbnRhaW5pbmcgdGhlIGZpbGUncyBjb250ZW50cy5cbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIGZpbGUgY2Fubm90IGJlIHJlYWQuXG4gICAgICovXG4gICAgYXN5bmMgdGV4dCgpIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IGZzLnByb21pc2VzLnJlYWRGaWxlKHRoaXMuZmlsZVBhdGgsICd1dGY4Jyk7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlYWRzIHRoZSBjb250ZW50cyBvZiB0aGUgZmlsZSBzcGVjaWZpZWQgYnkgdGhlIGZpbGVQYXRoIHByb3BlcnR5IGFuZCByZXR1cm5zIGEgUHJvbWlzZSB0aGF0XG4gICAgICogcmVzb2x2ZXMgd2l0aCBhIHBhcnNlZCBKYXZhU2NyaXB0IG9iamVjdCBjb250YWluaW5nIHRoZSBmaWxlJ3MgY29udGVudHMuXG4gICAgICogXG4gICAgICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0Pn0gQSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCBhIHBhcnNlZCBKYXZhU2NyaXB0IG9iamVjdCBjb250YWluaW5nIHRoZSBmaWxlJ3MgY29udGVudHMuXG4gICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBmaWxlIGNhbm5vdCBiZSByZWFkLlxuICAgICAqL1xuICAgIGFzeW5jIGpzb24oKSB7XG4gICAgICAgIHJldHVybiBKU09OLnBhcnNlKGF3YWl0IHRoaXMudGV4dCgpKTtcbiAgICB9XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBnaXZlbiBzdHJpbmcgaXMgYSB2YWxpZCBIVFRQIG9yIEhUVFBTIFVSTC5cbiAqIEBwYXJhbSB7c3RyaW5nfFVSTH0gc3RyaW5nIFRoZSBzdHJpbmcgdG8gdGVzdCBmb3IgdmFsaWRpdHkgYXMgYW4gSFRUUCBvciBIVFRQUyBVUkwuXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBbdmFsaWRIb3N0cz1udWxsXSBBIGxpc3Qgb2YgdmFsaWQgaG9zdG5hbWVzLiBJZiBzcGVjaWZpZWQsIHRoZSBVUkwncyBob3N0bmFtZSBtdXN0IGJlIGluIHRoaXMgbGlzdC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSBzdHJpbmcgaXMgYSB2YWxpZCBIVFRQIG9yIEhUVFBTIFVSTCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5mdW5jdGlvbiBpc1ZhbGlkSHR0cFVybChzdHJpbmcsIHZhbGlkSG9zdHMgPSBudWxsKSB7XG4gICAgLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzQzNDY3MTQ0XG4gICAgbGV0IHVybDtcbiAgICB0cnkge1xuICAgICAgICB1cmwgPSBuZXcgVVJMKHN0cmluZyk7XG4gICAgfSBjYXRjaCAoXykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICh2YWxpZEhvc3RzICYmICF2YWxpZEhvc3RzLmluY2x1ZGVzKHVybC5ob3N0bmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdXJsLnByb3RvY29sID09PSBcImh0dHA6XCIgfHwgdXJsLnByb3RvY29sID09PSBcImh0dHBzOlwiO1xufVxuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0byBnZXQgYSBmaWxlLCB1c2luZyBlaXRoZXIgdGhlIEZldGNoIEFQSSBvciBGaWxlU3lzdGVtIEFQSS5cbiAqXG4gKiBAcGFyYW0ge1VSTHxzdHJpbmd9IHVybE9yUGF0aCBUaGUgVVJML3BhdGggb2YgdGhlIGZpbGUgdG8gZ2V0LlxuICogQHJldHVybnMge1Byb21pc2U8RmlsZVJlc3BvbnNlfFJlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBGaWxlUmVzcG9uc2Ugb2JqZWN0IChpZiB0aGUgZmlsZSBpcyByZXRyaWV2ZWQgdXNpbmcgdGhlIEZpbGVTeXN0ZW0gQVBJKSwgb3IgYSBSZXNwb25zZSBvYmplY3QgKGlmIHRoZSBmaWxlIGlzIHJldHJpZXZlZCB1c2luZyB0aGUgRmV0Y2ggQVBJKS5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEZpbGUodXJsT3JQYXRoKSB7XG5cbiAgICBpZiAoZW52LnVzZUZTICYmICFpc1ZhbGlkSHR0cFVybCh1cmxPclBhdGgpKSB7XG4gICAgICAgIHJldHVybiBuZXcgRmlsZVJlc3BvbnNlKHVybE9yUGF0aCk7XG5cbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiBwcm9jZXNzPy5yZWxlYXNlPy5uYW1lID09PSAnbm9kZScpIHtcbiAgICAgICAgY29uc3QgSVNfQ0kgPSAhIXByb2Nlc3MuZW52Py5URVNUSU5HX1JFTU9URUxZO1xuICAgICAgICBjb25zdCB2ZXJzaW9uID0gZW52LnZlcnNpb247XG5cbiAgICAgICAgY29uc3QgaGVhZGVycyA9IG5ldyBIZWFkZXJzKCk7XG4gICAgICAgIGhlYWRlcnMuc2V0KCdVc2VyLUFnZW50JywgYHRyYW5zZm9ybWVycy5qcy8ke3ZlcnNpb259OyBpc19jaS8ke0lTX0NJfTtgKTtcblxuICAgICAgICAvLyBDaGVjayB3aGV0aGVyIHdlIGFyZSBtYWtpbmcgYSByZXF1ZXN0IHRvIHRoZSBIdWdnaW5nIEZhY2UgSHViLlxuICAgICAgICBjb25zdCBpc0hGVVJMID0gaXNWYWxpZEh0dHBVcmwodXJsT3JQYXRoLCBbJ2h1Z2dpbmdmYWNlLmNvJywgJ2hmLmNvJ10pO1xuICAgICAgICBpZiAoaXNIRlVSTCkge1xuICAgICAgICAgICAgLy8gSWYgYW4gYWNjZXNzIHRva2VuIGlzIHByZXNlbnQgaW4gdGhlIGVudmlyb25tZW50IHZhcmlhYmxlcyxcbiAgICAgICAgICAgIC8vIHdlIGFkZCBpdCB0byB0aGUgcmVxdWVzdCBoZWFkZXJzLlxuICAgICAgICAgICAgY29uc3QgdG9rZW4gPSBwcm9jZXNzLmVudj8uSEZfQUNDRVNTX1RPS0VOO1xuICAgICAgICAgICAgaWYgKHRva2VuKSB7XG4gICAgICAgICAgICAgICAgaGVhZGVycy5zZXQoJ0F1dGhvcml6YXRpb24nLCBgQmVhcmVyICR7dG9rZW59YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZldGNoKHVybE9yUGF0aCwgeyBoZWFkZXJzIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFJ1bm5pbmcgaW4gYSBicm93c2VyLWVudmlyb25tZW50LCBzbyB3ZSB1c2UgZGVmYXVsdCBoZWFkZXJzXG4gICAgICAgIC8vIE5PVEU6IFdlIGRvIG5vdCBhbGxvdyBwYXNzaW5nIGF1dGhvcml6YXRpb24gaGVhZGVycyBpbiB0aGUgYnJvd3NlcixcbiAgICAgICAgLy8gc2luY2UgdGhpcyB3b3VsZCByZXF1aXJlIGV4cG9zaW5nIHRoZSB0b2tlbiB0byB0aGUgY2xpZW50LlxuICAgICAgICByZXR1cm4gZmV0Y2godXJsT3JQYXRoKTtcbiAgICB9XG59XG5cbmNvbnN0IEVSUk9SX01BUFBJTkcgPSB7XG4gICAgLy8gNHh4IGVycm9ycyAoaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRUUC9TdGF0dXMjY2xpZW50X2Vycm9yX3Jlc3BvbnNlcylcbiAgICA0MDA6ICdCYWQgcmVxdWVzdCBlcnJvciBvY2N1cnJlZCB3aGlsZSB0cnlpbmcgdG8gbG9hZCBmaWxlJyxcbiAgICA0MDE6ICdVbmF1dGhvcml6ZWQgYWNjZXNzIHRvIGZpbGUnLFxuICAgIDQwMzogJ0ZvcmJpZGRlbiBhY2Nlc3MgdG8gZmlsZScsXG4gICAgNDA0OiAnQ291bGQgbm90IGxvY2F0ZSBmaWxlJyxcbiAgICA0MDg6ICdSZXF1ZXN0IHRpbWVvdXQgZXJyb3Igb2NjdXJyZWQgd2hpbGUgdHJ5aW5nIHRvIGxvYWQgZmlsZScsXG5cbiAgICAvLyA1eHggZXJyb3JzIChodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVFRQL1N0YXR1cyNzZXJ2ZXJfZXJyb3JfcmVzcG9uc2VzKVxuICAgIDUwMDogJ0ludGVybmFsIHNlcnZlciBlcnJvciBlcnJvciBvY2N1cnJlZCB3aGlsZSB0cnlpbmcgdG8gbG9hZCBmaWxlJyxcbiAgICA1MDI6ICdCYWQgZ2F0ZXdheSBlcnJvciBvY2N1cnJlZCB3aGlsZSB0cnlpbmcgdG8gbG9hZCBmaWxlJyxcbiAgICA1MDM6ICdTZXJ2aWNlIHVuYXZhaWxhYmxlIGVycm9yIG9jY3VycmVkIHdoaWxlIHRyeWluZyB0byBsb2FkIGZpbGUnLFxuICAgIDUwNDogJ0dhdGV3YXkgdGltZW91dCBlcnJvciBvY2N1cnJlZCB3aGlsZSB0cnlpbmcgdG8gbG9hZCBmaWxlJyxcbn1cbi8qKlxuICogSGVscGVyIG1ldGhvZCB0byBoYW5kbGUgZmF0YWwgZXJyb3JzIHRoYXQgb2NjdXIgd2hpbGUgdHJ5aW5nIHRvIGxvYWQgYSBmaWxlIGZyb20gdGhlIEh1Z2dpbmcgRmFjZSBIdWIuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RhdHVzIFRoZSBIVFRQIHN0YXR1cyBjb2RlIG9mIHRoZSBlcnJvci5cbiAqIEBwYXJhbSB7c3RyaW5nfSByZW1vdGVVUkwgVGhlIFVSTCBvZiB0aGUgZmlsZSB0aGF0IGNvdWxkIG5vdCBiZSBsb2FkZWQuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGZhdGFsIFdoZXRoZXIgdG8gcmFpc2UgYW4gZXJyb3IgaWYgdGhlIGZpbGUgY291bGQgbm90IGJlIGxvYWRlZC5cbiAqIEByZXR1cm5zIHtudWxsfSBSZXR1cm5zIGBudWxsYCBpZiBgZmF0YWwgPSB0cnVlYC5cbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiBgZmF0YWwgPSBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhbmRsZUVycm9yKHN0YXR1cywgcmVtb3RlVVJMLCBmYXRhbCkge1xuICAgIGlmICghZmF0YWwpIHtcbiAgICAgICAgLy8gRmlsZSB3YXMgbm90IGxvYWRlZCBjb3JyZWN0bHksIGJ1dCBpdCBpcyBvcHRpb25hbC5cbiAgICAgICAgLy8gVE9ETyBpbiBmdXR1cmUsIGNhY2hlIHRoZSByZXNwb25zZT9cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgY29uc3QgbWVzc2FnZSA9IEVSUk9SX01BUFBJTkdbc3RhdHVzXSA/PyBgRXJyb3IgKCR7c3RhdHVzfSkgb2NjdXJyZWQgd2hpbGUgdHJ5aW5nIHRvIGxvYWQgZmlsZWA7XG4gICAgdGhyb3cgRXJyb3IoYCR7bWVzc2FnZX06IFwiJHtyZW1vdGVVUkx9XCIuYCk7XG59XG5cbmNsYXNzIEZpbGVDYWNoZSB7XG4gICAgLyoqXG4gICAgICogSW5zdGFudGlhdGUgYSBgRmlsZUNhY2hlYCBvYmplY3QuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGggXG4gICAgICovXG4gICAgY29uc3RydWN0b3IocGF0aCkge1xuICAgICAgICB0aGlzLnBhdGggPSBwYXRoO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiByZXF1ZXN0IGlzIGluIHRoZSBjYWNoZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcmVxdWVzdCBcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxGaWxlUmVzcG9uc2UgfCB1bmRlZmluZWQ+fVxuICAgICAqL1xuICAgIGFzeW5jIG1hdGNoKHJlcXVlc3QpIHtcblxuICAgICAgICBsZXQgZmlsZVBhdGggPSBwYXRoLmpvaW4odGhpcy5wYXRoLCByZXF1ZXN0KTtcbiAgICAgICAgbGV0IGZpbGUgPSBuZXcgRmlsZVJlc3BvbnNlKGZpbGVQYXRoKTtcblxuICAgICAgICBpZiAoZmlsZS5leGlzdHMpIHtcbiAgICAgICAgICAgIHJldHVybiBmaWxlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZHMgdGhlIGdpdmVuIHJlc3BvbnNlIHRvIHRoZSBjYWNoZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcmVxdWVzdCBcbiAgICAgKiBAcGFyYW0ge1Jlc3BvbnNlfEZpbGVSZXNwb25zZX0gcmVzcG9uc2UgXG4gICAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gICAgICovXG4gICAgYXN5bmMgcHV0KHJlcXVlc3QsIHJlc3BvbnNlKSB7XG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IEJ1ZmZlci5mcm9tKGF3YWl0IHJlc3BvbnNlLmFycmF5QnVmZmVyKCkpO1xuXG4gICAgICAgIGxldCBvdXRwdXRQYXRoID0gcGF0aC5qb2luKHRoaXMucGF0aCwgcmVxdWVzdCk7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IGZzLnByb21pc2VzLm1rZGlyKHBhdGguZGlybmFtZShvdXRwdXRQYXRoKSwgeyByZWN1cnNpdmU6IHRydWUgfSk7XG4gICAgICAgICAgICBhd2FpdCBmcy5wcm9taXNlcy53cml0ZUZpbGUob3V0cHV0UGF0aCwgYnVmZmVyKTtcblxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignQW4gZXJyb3Igb2NjdXJyZWQgd2hpbGUgd3JpdGluZyB0aGUgZmlsZSB0byBjYWNoZTonLCBlcnIpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUT0RPIGFkZCB0aGUgcmVzdD9cbiAgICAvLyBhZGRBbGwocmVxdWVzdHM6IFJlcXVlc3RJbmZvW10pOiBQcm9taXNlPHZvaWQ+O1xuICAgIC8vIGRlbGV0ZShyZXF1ZXN0OiBSZXF1ZXN0SW5mbyB8IFVSTCwgb3B0aW9ucz86IENhY2hlUXVlcnlPcHRpb25zKTogUHJvbWlzZTxib29sZWFuPjtcbiAgICAvLyBrZXlzKHJlcXVlc3Q/OiBSZXF1ZXN0SW5mbyB8IFVSTCwgb3B0aW9ucz86IENhY2hlUXVlcnlPcHRpb25zKTogUHJvbWlzZTxSZWFkb25seUFycmF5PFJlcXVlc3Q+PjtcbiAgICAvLyBtYXRjaChyZXF1ZXN0OiBSZXF1ZXN0SW5mbyB8IFVSTCwgb3B0aW9ucz86IENhY2hlUXVlcnlPcHRpb25zKTogUHJvbWlzZTxSZXNwb25zZSB8IHVuZGVmaW5lZD47XG4gICAgLy8gbWF0Y2hBbGwocmVxdWVzdD86IFJlcXVlc3RJbmZvIHwgVVJMLCBvcHRpb25zPzogQ2FjaGVRdWVyeU9wdGlvbnMpOiBQcm9taXNlPFJlYWRvbmx5QXJyYXk8UmVzcG9uc2U+Pjtcbn1cblxuLyoqXG4gKiBcbiAqIEBwYXJhbSB7RmlsZUNhY2hlfENhY2hlfSBjYWNoZSBUaGUgY2FjaGUgdG8gc2VhcmNoXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBuYW1lcyBUaGUgbmFtZXMgb2YgdGhlIGl0ZW0gdG8gc2VhcmNoIGZvclxuICogQHJldHVybnMge1Byb21pc2U8RmlsZVJlc3BvbnNlfFJlc3BvbnNlfHVuZGVmaW5lZD59IFRoZSBpdGVtIGZyb20gdGhlIGNhY2hlLCBvciB1bmRlZmluZWQgaWYgbm90IGZvdW5kLlxuICovXG5hc3luYyBmdW5jdGlvbiB0cnlDYWNoZShjYWNoZSwgLi4ubmFtZXMpIHtcbiAgICBmb3IgKGxldCBuYW1lIG9mIG5hbWVzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gYXdhaXQgY2FjaGUubWF0Y2gobmFtZSk7XG4gICAgICAgICAgICBpZiAocmVzdWx0KSByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIFxuICogUmV0cmlldmVzIGEgZmlsZSBmcm9tIGVpdGhlciBhIHJlbW90ZSBVUkwgdXNpbmcgdGhlIEZldGNoIEFQSSBvciBmcm9tIHRoZSBsb2NhbCBmaWxlIHN5c3RlbSB1c2luZyB0aGUgRmlsZVN5c3RlbSBBUEkuXG4gKiBJZiB0aGUgZmlsZXN5c3RlbSBpcyBhdmFpbGFibGUgYW5kIGBlbnYudXNlQ2FjaGUgPSB0cnVlYCwgdGhlIGZpbGUgd2lsbCBiZSBkb3dubG9hZGVkIGFuZCBjYWNoZWQuXG4gKiBcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoX29yX3JlcG9faWQgVGhpcyBjYW4gYmUgZWl0aGVyOlxuICogLSBhIHN0cmluZywgdGhlICptb2RlbCBpZCogb2YgYSBtb2RlbCByZXBvIG9uIGh1Z2dpbmdmYWNlLmNvLlxuICogLSBhIHBhdGggdG8gYSAqZGlyZWN0b3J5KiBwb3RlbnRpYWxseSBjb250YWluaW5nIHRoZSBmaWxlLlxuICogQHBhcmFtIHtzdHJpbmd9IGZpbGVuYW1lIFRoZSBuYW1lIG9mIHRoZSBmaWxlIHRvIGxvY2F0ZSBpbiBgcGF0aF9vcl9yZXBvYC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2ZhdGFsPXRydWVdIFdoZXRoZXIgdG8gdGhyb3cgYW4gZXJyb3IgaWYgdGhlIGZpbGUgaXMgbm90IGZvdW5kLlxuICogQHBhcmFtIHtQcmV0cmFpbmVkT3B0aW9uc30gW29wdGlvbnNdIEFuIG9iamVjdCBjb250YWluaW5nIG9wdGlvbmFsIHBhcmFtZXRlcnMuXG4gKiBcbiAqIEB0aHJvd3MgV2lsbCB0aHJvdyBhbiBlcnJvciBpZiB0aGUgZmlsZSBpcyBub3QgZm91bmQgYW5kIGBmYXRhbGAgaXMgdHJ1ZS5cbiAqIEByZXR1cm5zIHtQcm9taXNlfSBBIFByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSBmaWxlIGNvbnRlbnQgYXMgYSBidWZmZXIuXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRNb2RlbEZpbGUocGF0aF9vcl9yZXBvX2lkLCBmaWxlbmFtZSwgZmF0YWwgPSB0cnVlLCBvcHRpb25zID0ge30pIHtcblxuICAgIGlmICghZW52LmFsbG93TG9jYWxNb2RlbHMpIHtcbiAgICAgICAgLy8gVXNlciBoYXMgZGlzYWJsZWQgbG9jYWwgbW9kZWxzLCBzbyB3ZSBqdXN0IG1ha2Ugc3VyZSBvdGhlciBzZXR0aW5ncyBhcmUgY29ycmVjdC5cblxuICAgICAgICBpZiAob3B0aW9ucy5sb2NhbF9maWxlc19vbmx5KSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcIkludmFsaWQgY29uZmlndXJhdGlvbiBkZXRlY3RlZDogbG9jYWwgbW9kZWxzIGFyZSBkaXNhYmxlZCAoYGVudi5hbGxvd0xvY2FsTW9kZWxzPWZhbHNlYCkgYnV0IHlvdSBoYXZlIHJlcXVlc3RlZCB0byBvbmx5IHVzZSBsb2NhbCBtb2RlbHMgKGBsb2NhbF9maWxlc19vbmx5PXRydWVgKS5cIilcbiAgICAgICAgfSBlbHNlIGlmICghZW52LmFsbG93UmVtb3RlTW9kZWxzKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcIkludmFsaWQgY29uZmlndXJhdGlvbiBkZXRlY3RlZDogYm90aCBsb2NhbCBhbmQgcmVtb3RlIG1vZGVscyBhcmUgZGlzYWJsZWQuIEZpeCBieSBzZXR0aW5nIGBlbnYuYWxsb3dMb2NhbE1vZGVsc2Agb3IgYGVudi5hbGxvd1JlbW90ZU1vZGVsc2AgdG8gYHRydWVgLlwiKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gSW5pdGlhdGUgZmlsZSByZXRyaWV2YWxcbiAgICBkaXNwYXRjaENhbGxiYWNrKG9wdGlvbnMucHJvZ3Jlc3NfY2FsbGJhY2ssIHtcbiAgICAgICAgc3RhdHVzOiAnaW5pdGlhdGUnLFxuICAgICAgICBuYW1lOiBwYXRoX29yX3JlcG9faWQsXG4gICAgICAgIGZpbGU6IGZpbGVuYW1lXG4gICAgfSlcblxuICAgIC8vIEZpcnN0LCBjaGVjayBpZiB0aGUgYSBjYWNoaW5nIGJhY2tlbmQgaXMgYXZhaWxhYmxlXG4gICAgLy8gSWYgbm8gY2FjaGluZyBtZWNoYW5pc20gYXZhaWxhYmxlLCB3aWxsIGRvd25sb2FkIHRoZSBmaWxlIGV2ZXJ5IHRpbWVcbiAgICBsZXQgY2FjaGU7XG4gICAgaWYgKCFjYWNoZSAmJiBlbnYudXNlQnJvd3NlckNhY2hlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2FjaGVzID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ0Jyb3dzZXIgY2FjaGUgaXMgbm90IGF2YWlsYWJsZSBpbiB0aGlzIGVudmlyb25tZW50LicpXG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIEluIHNvbWUgY2FzZXMsIHRoZSBicm93c2VyIGNhY2hlIG1heSBiZSB2aXNpYmxlLCBidXQgbm90IGFjY2Vzc2libGUgZHVlIHRvIHNlY3VyaXR5IHJlc3RyaWN0aW9ucy5cbiAgICAgICAgICAgIC8vIEZvciBleGFtcGxlLCB3aGVuIHJ1bm5pbmcgYW4gYXBwbGljYXRpb24gaW4gYW4gaWZyYW1lLCBpZiBhIHVzZXIgYXR0ZW1wdHMgdG8gbG9hZCB0aGUgcGFnZSBpblxuICAgICAgICAgICAgLy8gaW5jb2duaXRvIG1vZGUsIHRoZSBmb2xsb3dpbmcgZXJyb3IgaXMgdGhyb3duOiBgRE9NRXhjZXB0aW9uOiBGYWlsZWQgdG8gZXhlY3V0ZSAnb3Blbicgb24gJ0NhY2hlU3RvcmFnZSc6XG4gICAgICAgICAgICAvLyBBbiBhdHRlbXB0IHdhcyBtYWRlIHRvIGJyZWFrIHRocm91Z2ggdGhlIHNlY3VyaXR5IHBvbGljeSBvZiB0aGUgdXNlciBhZ2VudC5gXG4gICAgICAgICAgICAvLyBTbywgaW5zdGVhZCBvZiBjcmFzaGluZywgd2UganVzdCBpZ25vcmUgdGhlIGVycm9yIGFuZCBjb250aW51ZSB3aXRob3V0IHVzaW5nIHRoZSBjYWNoZS5cbiAgICAgICAgICAgIGNhY2hlID0gYXdhaXQgY2FjaGVzLm9wZW4oJ3RyYW5zZm9ybWVycy1jYWNoZScpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ0FuIGVycm9yIG9jY3VycmVkIHdoaWxlIG9wZW5pbmcgdGhlIGJyb3dzZXIgY2FjaGU6JywgZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIWNhY2hlICYmIGVudi51c2VGU0NhY2hlKSB7XG4gICAgICAgIC8vIFRPRE8gdGhyb3cgZXJyb3IgaWYgbm90IGF2YWlsYWJsZVxuXG4gICAgICAgIC8vIElmIGBjYWNoZV9kaXJgIGlzIG5vdCBzcGVjaWZpZWQsIHVzZSB0aGUgZGVmYXVsdCBjYWNoZSBkaXJlY3RvcnlcbiAgICAgICAgY2FjaGUgPSBuZXcgRmlsZUNhY2hlKG9wdGlvbnMuY2FjaGVfZGlyID8/IGVudi5jYWNoZURpcik7XG4gICAgfVxuXG4gICAgY29uc3QgcmV2aXNpb24gPSBvcHRpb25zLnJldmlzaW9uID8/ICdtYWluJztcblxuICAgIGxldCByZXF1ZXN0VVJMID0gcGF0aEpvaW4ocGF0aF9vcl9yZXBvX2lkLCBmaWxlbmFtZSk7XG4gICAgbGV0IGxvY2FsUGF0aCA9IHBhdGhKb2luKGVudi5sb2NhbE1vZGVsUGF0aCwgcmVxdWVzdFVSTCk7XG5cbiAgICBsZXQgcmVtb3RlVVJMID0gcGF0aEpvaW4oXG4gICAgICAgIGVudi5yZW1vdGVIb3N0LFxuICAgICAgICBlbnYucmVtb3RlUGF0aFRlbXBsYXRlXG4gICAgICAgICAgICAucmVwbGFjZUFsbCgne21vZGVsfScsIHBhdGhfb3JfcmVwb19pZClcbiAgICAgICAgICAgIC5yZXBsYWNlQWxsKCd7cmV2aXNpb259JywgcmV2aXNpb24pLFxuICAgICAgICBmaWxlbmFtZVxuICAgICk7XG5cbiAgICAvLyBDaG9vc2UgY2FjaGUga2V5IGZvciBmaWxlc3lzdGVtIGNhY2hlXG4gICAgLy8gV2hlbiB1c2luZyB0aGUgbWFpbiByZXZpc2lvbiAoZGVmYXVsdCksIHdlIHVzZSB0aGUgcmVxdWVzdCBVUkwgYXMgdGhlIGNhY2hlIGtleS5cbiAgICAvLyBJZiBhIHNwZWNpZmljIHJldmlzaW9uIGlzIHJlcXVlc3RlZCwgd2UgYWNjb3VudCBmb3IgdGhpcyBpbiB0aGUgY2FjaGUga2V5LlxuICAgIGxldCBmc0NhY2hlS2V5ID0gcmV2aXNpb24gPT09ICdtYWluJyA/IHJlcXVlc3RVUkwgOiBwYXRoSm9pbihwYXRoX29yX3JlcG9faWQsIHJldmlzaW9uLCBmaWxlbmFtZSk7XG5cbiAgICAvKiogQHR5cGUge3N0cmluZ30gKi9cbiAgICBsZXQgY2FjaGVLZXk7XG4gICAgbGV0IHByb3Bvc2VkQ2FjaGVLZXkgPSBjYWNoZSBpbnN0YW5jZW9mIEZpbGVDYWNoZSA/IGZzQ2FjaGVLZXkgOiByZW1vdGVVUkw7XG5cbiAgICAvKiogQHR5cGUge1Jlc3BvbnNlfHVuZGVmaW5lZH0gKi9cbiAgICBsZXQgcmVzcG9uc2VUb0NhY2hlO1xuXG4gICAgLyoqIEB0eXBlIHtSZXNwb25zZXxGaWxlUmVzcG9uc2V8dW5kZWZpbmVkfSAqL1xuICAgIGxldCByZXNwb25zZTtcblxuICAgIGlmIChjYWNoZSkge1xuICAgICAgICAvLyBBIGNhY2hpbmcgc3lzdGVtIGlzIGF2YWlsYWJsZSwgc28gd2UgdHJ5IHRvIGdldCB0aGUgZmlsZSBmcm9tIGl0LlxuICAgICAgICAvLyAgMS4gV2UgZmlyc3QgdHJ5IHRvIGdldCBmcm9tIGNhY2hlIHVzaW5nIHRoZSBsb2NhbCBwYXRoLiBJbiBzb21lIGVudmlyb25tZW50cyAobGlrZSBkZW5vKSxcbiAgICAgICAgLy8gICAgIG5vbi1VUkwgY2FjaGUga2V5cyBhcmUgbm90IGFsbG93ZWQuIEluIHRoZXNlIGNhc2VzLCBgcmVzcG9uc2VgIHdpbGwgYmUgdW5kZWZpbmVkLlxuICAgICAgICAvLyAgMi4gSWYgbm8gcmVzcG9uc2UgaXMgZm91bmQsIHdlIHRyeSB0byBnZXQgZnJvbSBjYWNoZSB1c2luZyB0aGUgcmVtb3RlIFVSTCBvciBmaWxlIHN5c3RlbSBjYWNoZS5cbiAgICAgICAgcmVzcG9uc2UgPSBhd2FpdCB0cnlDYWNoZShjYWNoZSwgbG9jYWxQYXRoLCBwcm9wb3NlZENhY2hlS2V5KTtcbiAgICB9XG5cbiAgICBpZiAocmVzcG9uc2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBDYWNoaW5nIG5vdCBhdmFpbGFibGUsIG9yIGZpbGUgaXMgbm90IGNhY2hlZCwgc28gd2UgcGVyZm9ybSB0aGUgcmVxdWVzdFxuXG4gICAgICAgIGlmIChlbnYuYWxsb3dMb2NhbE1vZGVscykge1xuICAgICAgICAgICAgLy8gQWNjZXNzaW5nIGxvY2FsIG1vZGVscyBpcyBlbmFibGVkLCBzbyB3ZSB0cnkgdG8gZ2V0IHRoZSBmaWxlIGxvY2FsbHkuXG4gICAgICAgICAgICAvLyBJZiByZXF1ZXN0IGlzIGEgdmFsaWQgSFRUUCBVUkwsIHdlIHNraXAgdGhlIGxvY2FsIGZpbGUgY2hlY2suIE90aGVyd2lzZSwgd2UgdHJ5IHRvIGdldCB0aGUgZmlsZSBsb2NhbGx5LlxuICAgICAgICAgICAgY29uc3QgaXNVUkwgPSBpc1ZhbGlkSHR0cFVybChyZXF1ZXN0VVJMKTtcbiAgICAgICAgICAgIGlmICghaXNVUkwpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9IGF3YWl0IGdldEZpbGUobG9jYWxQYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgY2FjaGVLZXkgPSBsb2NhbFBhdGg7IC8vIFVwZGF0ZSB0aGUgY2FjaGUga2V5IHRvIGJlIHRoZSBsb2NhbCBwYXRoXG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBTb21ldGhpbmcgd2VudCB3cm9uZyB3aGlsZSB0cnlpbmcgdG8gZ2V0IHRoZSBmaWxlIGxvY2FsbHkuXG4gICAgICAgICAgICAgICAgICAgIC8vIE5PVEU6IGVycm9yIGhhbmRsaW5nIGlzIGRvbmUgaW4gdGhlIG5leHQgc3RlcCAoc2luY2UgYHJlc3BvbnNlYCB3aWxsIGJlIHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBVbmFibGUgdG8gbG9hZCBmcm9tIGxvY2FsIHBhdGggXCIke2xvY2FsUGF0aH1cIjogXCIke2V9XCJgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG9wdGlvbnMubG9jYWxfZmlsZXNfb25seSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgXFxgbG9jYWxfZmlsZXNfb25seT10cnVlXFxgLCBidXQgYXR0ZW1wdGVkIHRvIGxvYWQgYSByZW1vdGUgZmlsZSBmcm9tOiAke3JlcXVlc3RVUkx9LmApO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghZW52LmFsbG93UmVtb3RlTW9kZWxzKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBcXGBlbnYuYWxsb3dSZW1vdGVNb2RlbHM9ZmFsc2VcXGAsIGJ1dCBhdHRlbXB0ZWQgdG8gbG9hZCBhIHJlbW90ZSBmaWxlIGZyb206ICR7cmVxdWVzdFVSTH0uYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVzcG9uc2UgPT09IHVuZGVmaW5lZCB8fCByZXNwb25zZS5zdGF0dXMgPT09IDQwNCkge1xuICAgICAgICAgICAgLy8gRmlsZSBub3QgZm91bmQgbG9jYWxseS4gVGhpcyBtZWFucyBlaXRoZXI6XG4gICAgICAgICAgICAvLyAtIFRoZSB1c2VyIGhhcyBkaXNhYmxlZCBsb2NhbCBmaWxlIGFjY2VzcyAoYGVudi5hbGxvd0xvY2FsTW9kZWxzPWZhbHNlYClcbiAgICAgICAgICAgIC8vIC0gdGhlIHBhdGggaXMgYSB2YWxpZCBIVFRQIHVybCAoYHJlc3BvbnNlID09PSB1bmRlZmluZWRgKVxuICAgICAgICAgICAgLy8gLSB0aGUgcGF0aCBpcyBub3QgYSB2YWxpZCBIVFRQIHVybCBhbmQgdGhlIGZpbGUgaXMgbm90IHByZXNlbnQgb24gdGhlIGZpbGUgc3lzdGVtIG9yIGxvY2FsIHNlcnZlciAoYHJlc3BvbnNlLnN0YXR1cyA9PT0gNDA0YClcblxuICAgICAgICAgICAgaWYgKG9wdGlvbnMubG9jYWxfZmlsZXNfb25seSB8fCAhZW52LmFsbG93UmVtb3RlTW9kZWxzKSB7XG4gICAgICAgICAgICAgICAgLy8gVXNlciByZXF1ZXN0ZWQgbG9jYWwgZmlsZXMgb25seSwgYnV0IHRoZSBmaWxlIGlzIG5vdCBmb3VuZCBsb2NhbGx5LlxuICAgICAgICAgICAgICAgIGlmIChmYXRhbCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihgXFxgbG9jYWxfZmlsZXNfb25seT10cnVlXFxgIG9yIFxcYGVudi5hbGxvd1JlbW90ZU1vZGVscz1mYWxzZVxcYCBhbmQgZmlsZSB3YXMgbm90IGZvdW5kIGxvY2FsbHkgYXQgXCIke2xvY2FsUGF0aH1cIi5gKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBGaWxlIG5vdCBmb3VuZCwgYnV0IHRoaXMgZmlsZSBpcyBvcHRpb25hbC5cbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyBpbiBmdXR1cmUsIGNhY2hlIHRoZSByZXNwb25zZT9cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBGaWxlIG5vdCBmb3VuZCBsb2NhbGx5LCBzbyB3ZSB0cnkgdG8gZG93bmxvYWQgaXQgZnJvbSB0aGUgcmVtb3RlIHNlcnZlclxuICAgICAgICAgICAgcmVzcG9uc2UgPSBhd2FpdCBnZXRGaWxlKHJlbW90ZVVSTCk7XG5cbiAgICAgICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgIT09IDIwMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBoYW5kbGVFcnJvcihyZXNwb25zZS5zdGF0dXMsIHJlbW90ZVVSTCwgZmF0YWwpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBTdWNjZXNzISBXZSB1c2UgdGhlIHByb3Bvc2VkIGNhY2hlIGtleSBmcm9tIGVhcmxpZXJcbiAgICAgICAgICAgIGNhY2hlS2V5ID0gcHJvcG9zZWRDYWNoZUtleTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgaWYgKGNhY2hlICYmIHJlc3BvbnNlIGluc3RhbmNlb2YgUmVzcG9uc2UgJiYgcmVzcG9uc2Uuc3RhdHVzID09PSAyMDApIHtcbiAgICAgICAgICAgIC8vIG9ubHkgY2xvbmUgaWYgY2FjaGUgYXZhaWxhYmxlLCBhbmQgcmVzcG9uc2UgaXMgdmFsaWRcbiAgICAgICAgICAgIHJlc3BvbnNlVG9DYWNoZSA9IHJlc3BvbnNlLmNsb25lKCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIC8vIFN0YXJ0IGRvd25sb2FkaW5nXG4gICAgZGlzcGF0Y2hDYWxsYmFjayhvcHRpb25zLnByb2dyZXNzX2NhbGxiYWNrLCB7XG4gICAgICAgIHN0YXR1czogJ2Rvd25sb2FkJyxcbiAgICAgICAgbmFtZTogcGF0aF9vcl9yZXBvX2lkLFxuICAgICAgICBmaWxlOiBmaWxlbmFtZVxuICAgIH0pXG5cbiAgICBjb25zdCBidWZmZXIgPSBhd2FpdCByZWFkUmVzcG9uc2UocmVzcG9uc2UsIGRhdGEgPT4ge1xuICAgICAgICBkaXNwYXRjaENhbGxiYWNrKG9wdGlvbnMucHJvZ3Jlc3NfY2FsbGJhY2ssIHtcbiAgICAgICAgICAgIHN0YXR1czogJ3Byb2dyZXNzJyxcbiAgICAgICAgICAgIC4uLmRhdGEsXG4gICAgICAgICAgICBuYW1lOiBwYXRoX29yX3JlcG9faWQsXG4gICAgICAgICAgICBmaWxlOiBmaWxlbmFtZVxuICAgICAgICB9KVxuICAgIH0pXG5cblxuICAgIGlmIChcbiAgICAgICAgLy8gT25seSBjYWNoZSB3ZWIgcmVzcG9uc2VzXG4gICAgICAgIC8vIGkuZS4sIGRvIG5vdCBjYWNoZSBGaWxlUmVzcG9uc2VzIChwcmV2ZW50cyBkdXBsaWNhdGlvbilcbiAgICAgICAgcmVzcG9uc2VUb0NhY2hlICYmIGNhY2hlS2V5XG4gICAgICAgICYmXG4gICAgICAgIC8vIENoZWNrIGFnYWluIHdoZXRoZXIgcmVxdWVzdCBpcyBpbiBjYWNoZS4gSWYgbm90LCB3ZSBhZGQgdGhlIHJlc3BvbnNlIHRvIHRoZSBjYWNoZVxuICAgICAgICAoYXdhaXQgY2FjaGUubWF0Y2goY2FjaGVLZXkpID09PSB1bmRlZmluZWQpXG4gICAgKSB7XG4gICAgICAgIGF3YWl0IGNhY2hlLnB1dChjYWNoZUtleSwgcmVzcG9uc2VUb0NhY2hlKVxuICAgICAgICAgICAgLmNhdGNoKGVyciA9PiB7XG4gICAgICAgICAgICAgICAgLy8gRG8gbm90IGNyYXNoIGlmIHVuYWJsZSB0byBhZGQgdG8gY2FjaGUgKGUuZy4sIFF1b3RhRXhjZWVkZWRFcnJvcikuXG4gICAgICAgICAgICAgICAgLy8gUmF0aGVyLCBsb2cgYSB3YXJuaW5nIGFuZCBwcm9jZWVkIHdpdGggZXhlY3V0aW9uLlxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgVW5hYmxlIHRvIGFkZCByZXNwb25zZSB0byBicm93c2VyIGNhY2hlOiAke2Vycn0uYCk7XG4gICAgICAgICAgICB9KTtcblxuICAgIH1cblxuICAgIGRpc3BhdGNoQ2FsbGJhY2sob3B0aW9ucy5wcm9ncmVzc19jYWxsYmFjaywge1xuICAgICAgICBzdGF0dXM6ICdkb25lJyxcbiAgICAgICAgbmFtZTogcGF0aF9vcl9yZXBvX2lkLFxuICAgICAgICBmaWxlOiBmaWxlbmFtZVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGJ1ZmZlcjtcbn1cblxuLyoqXG4gKiBGZXRjaGVzIGEgSlNPTiBmaWxlIGZyb20gYSBnaXZlbiBwYXRoIGFuZCBmaWxlIG5hbWUuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG1vZGVsUGF0aCBUaGUgcGF0aCB0byB0aGUgZGlyZWN0b3J5IGNvbnRhaW5pbmcgdGhlIGZpbGUuXG4gKiBAcGFyYW0ge3N0cmluZ30gZmlsZU5hbWUgVGhlIG5hbWUgb2YgdGhlIGZpbGUgdG8gZmV0Y2guXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtmYXRhbD10cnVlXSBXaGV0aGVyIHRvIHRocm93IGFuIGVycm9yIGlmIHRoZSBmaWxlIGlzIG5vdCBmb3VuZC5cbiAqIEBwYXJhbSB7UHJldHJhaW5lZE9wdGlvbnN9IFtvcHRpb25zXSBBbiBvYmplY3QgY29udGFpbmluZyBvcHRpb25hbCBwYXJhbWV0ZXJzLlxuICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0Pn0gVGhlIEpTT04gZGF0YSBwYXJzZWQgaW50byBhIEphdmFTY3JpcHQgb2JqZWN0LlxuICogQHRocm93cyBXaWxsIHRocm93IGFuIGVycm9yIGlmIHRoZSBmaWxlIGlzIG5vdCBmb3VuZCBhbmQgYGZhdGFsYCBpcyB0cnVlLlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0TW9kZWxKU09OKG1vZGVsUGF0aCwgZmlsZU5hbWUsIGZhdGFsID0gdHJ1ZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgbGV0IGJ1ZmZlciA9IGF3YWl0IGdldE1vZGVsRmlsZShtb2RlbFBhdGgsIGZpbGVOYW1lLCBmYXRhbCwgb3B0aW9ucyk7XG4gICAgaWYgKGJ1ZmZlciA9PT0gbnVsbCkge1xuICAgICAgICAvLyBSZXR1cm4gZW1wdHkgb2JqZWN0XG4gICAgICAgIHJldHVybiB7fVxuICAgIH1cblxuICAgIGxldCBkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCd1dGYtOCcpO1xuICAgIGxldCBqc29uRGF0YSA9IGRlY29kZXIuZGVjb2RlKGJ1ZmZlcik7XG5cbiAgICByZXR1cm4gSlNPTi5wYXJzZShqc29uRGF0YSk7XG59XG5cbi8qKlxuICogUmVhZCBhbmQgdHJhY2sgcHJvZ3Jlc3Mgd2hlbiByZWFkaW5nIGEgUmVzcG9uc2Ugb2JqZWN0XG4gKlxuICogQHBhcmFtIHthbnl9IHJlc3BvbnNlIFRoZSBSZXNwb25zZSBvYmplY3QgdG8gcmVhZFxuICogQHBhcmFtIHtmdW5jdGlvbn0gcHJvZ3Jlc3NfY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRvIGNhbGwgd2l0aCBwcm9ncmVzcyB1cGRhdGVzXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxVaW50OEFycmF5Pn0gQSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgVWludDhBcnJheSBidWZmZXJcbiAqL1xuYXN5bmMgZnVuY3Rpb24gcmVhZFJlc3BvbnNlKHJlc3BvbnNlLCBwcm9ncmVzc19jYWxsYmFjaykge1xuICAgIC8vIFJlYWQgYW5kIHRyYWNrIHByb2dyZXNzIHdoZW4gcmVhZGluZyBhIFJlc3BvbnNlIG9iamVjdFxuXG4gICAgY29uc3QgY29udGVudExlbmd0aCA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KCdDb250ZW50LUxlbmd0aCcpO1xuICAgIGlmIChjb250ZW50TGVuZ3RoID09PSBudWxsKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignVW5hYmxlIHRvIGRldGVybWluZSBjb250ZW50LWxlbmd0aCBmcm9tIHJlc3BvbnNlIGhlYWRlcnMuIFdpbGwgZXhwYW5kIGJ1ZmZlciB3aGVuIG5lZWRlZC4nKVxuICAgIH1cbiAgICBsZXQgdG90YWwgPSBwYXJzZUludChjb250ZW50TGVuZ3RoID8/ICcwJyk7XG4gICAgbGV0IGJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KHRvdGFsKTtcbiAgICBsZXQgbG9hZGVkID0gMDtcblxuICAgIGNvbnN0IHJlYWRlciA9IHJlc3BvbnNlLmJvZHkuZ2V0UmVhZGVyKCk7XG4gICAgYXN5bmMgZnVuY3Rpb24gcmVhZCgpIHtcbiAgICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICAgICAgaWYgKGRvbmUpIHJldHVybjtcblxuICAgICAgICBsZXQgbmV3TG9hZGVkID0gbG9hZGVkICsgdmFsdWUubGVuZ3RoO1xuICAgICAgICBpZiAobmV3TG9hZGVkID4gdG90YWwpIHtcbiAgICAgICAgICAgIHRvdGFsID0gbmV3TG9hZGVkO1xuXG4gICAgICAgICAgICAvLyBBZGRpbmcgdGhlIG5ldyBkYXRhIHdpbGwgb3ZlcmZsb3cgYnVmZmVyLlxuICAgICAgICAgICAgLy8gSW4gdGhpcyBjYXNlLCB3ZSBleHRlbmQgdGhlIGJ1ZmZlclxuICAgICAgICAgICAgbGV0IG5ld0J1ZmZlciA9IG5ldyBVaW50OEFycmF5KHRvdGFsKTtcblxuICAgICAgICAgICAgLy8gY29weSBjb250ZW50c1xuICAgICAgICAgICAgbmV3QnVmZmVyLnNldChidWZmZXIpO1xuXG4gICAgICAgICAgICBidWZmZXIgPSBuZXdCdWZmZXI7XG4gICAgICAgIH1cbiAgICAgICAgYnVmZmVyLnNldCh2YWx1ZSwgbG9hZGVkKVxuICAgICAgICBsb2FkZWQgPSBuZXdMb2FkZWQ7XG5cbiAgICAgICAgY29uc3QgcHJvZ3Jlc3MgPSAobG9hZGVkIC8gdG90YWwpICogMTAwO1xuXG4gICAgICAgIC8vIENhbGwgeW91ciBmdW5jdGlvbiBoZXJlXG4gICAgICAgIHByb2dyZXNzX2NhbGxiYWNrKHtcbiAgICAgICAgICAgIHByb2dyZXNzOiBwcm9ncmVzcyxcbiAgICAgICAgICAgIGxvYWRlZDogbG9hZGVkLFxuICAgICAgICAgICAgdG90YWw6IHRvdGFsLFxuICAgICAgICB9KVxuXG4gICAgICAgIHJldHVybiByZWFkKCk7XG4gICAgfVxuXG4gICAgLy8gQWN0dWFsbHkgcmVhZFxuICAgIGF3YWl0IHJlYWQoKTtcblxuICAgIHJldHVybiBidWZmZXI7XG59XG5cbi8qKlxuICogSm9pbnMgbXVsdGlwbGUgcGFydHMgb2YgYSBwYXRoIGludG8gYSBzaW5nbGUgcGF0aCwgd2hpbGUgaGFuZGxpbmcgbGVhZGluZyBhbmQgdHJhaWxpbmcgc2xhc2hlcy5cbiAqXG4gKiBAcGFyYW0gey4uLnN0cmluZ30gcGFydHMgTXVsdGlwbGUgcGFydHMgb2YgYSBwYXRoLlxuICogQHJldHVybnMge3N0cmluZ30gQSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBqb2luZWQgcGF0aC5cbiAqL1xuZnVuY3Rpb24gcGF0aEpvaW4oLi4ucGFydHMpIHtcbiAgICAvLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvNTUxNDI1NjVcbiAgICBwYXJ0cyA9IHBhcnRzLm1hcCgocGFydCwgaW5kZXgpID0+IHtcbiAgICAgICAgaWYgKGluZGV4KSB7XG4gICAgICAgICAgICBwYXJ0ID0gcGFydC5yZXBsYWNlKG5ldyBSZWdFeHAoJ14vJyksICcnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5kZXggIT09IHBhcnRzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIHBhcnQgPSBwYXJ0LnJlcGxhY2UobmV3IFJlZ0V4cCgnLyQnKSwgJycpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJ0O1xuICAgIH0pXG4gICAgcmV0dXJuIHBhcnRzLmpvaW4oJy8nKTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@xenova/transformers/src/utils/hub.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@xenova/transformers/src/utils/image.js":
/*!**************************************************************!*\
  !*** ./node_modules/@xenova/transformers/src/utils/image.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RawImage: () => (/* binding */ RawImage)\n/* harmony export */ });\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fs */ \"fs\");\n/* harmony import */ var _core_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./core.js */ \"(ssr)/./node_modules/@xenova/transformers/src/utils/core.js\");\n/* harmony import */ var _hub_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./hub.js */ \"(ssr)/./node_modules/@xenova/transformers/src/utils/hub.js\");\n/* harmony import */ var _env_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../env.js */ \"(ssr)/./node_modules/@xenova/transformers/src/env.js\");\n/* harmony import */ var sharp__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! sharp */ \"?1170\");\n\n/**\n * @file Helper module for image processing. \n * \n * These functions and classes are only used internally, \n * meaning an end-user shouldn't need to access anything here.\n * \n * @module utils/image\n */\n\n\n\n\n\n\n// Will be empty (or not used) if running in browser or web-worker\n\n\nconst BROWSER_ENV = typeof self !== 'undefined';\n\nlet createCanvasFunction;\nlet ImageDataClass;\nlet loadImageFunction;\nif (BROWSER_ENV) {\n    // Running in browser or web-worker\n    createCanvasFunction = (/** @type {number} */ width, /** @type {number} */ height) => {\n        if (!self.OffscreenCanvas) {\n            throw new Error('OffscreenCanvas not supported by this browser.');\n        }\n        return new self.OffscreenCanvas(width, height)\n    };\n    loadImageFunction = self.createImageBitmap;\n    ImageDataClass = self.ImageData;\n\n} else if (sharp__WEBPACK_IMPORTED_MODULE_4__) {\n    // Running in Node.js, electron, or other non-browser environment\n\n    loadImageFunction = async (/**@type {sharp.Sharp}*/img) => {\n        const metadata = await img.metadata();\n        const rawChannels = metadata.channels;\n\n        let { data, info } = await img.raw().toBuffer({ resolveWithObject: true });\n\n        const newImage = new RawImage(new Uint8ClampedArray(data), info.width, info.height, info.channels);\n        if (rawChannels !== undefined && rawChannels !== info.channels) {\n            // Make sure the new image has the same number of channels as the input image.\n            // This is necessary for grayscale images.\n            newImage.convert(rawChannels);\n        }\n        return newImage;\n    }\n\n} else {\n    throw new Error('Unable to load image processing library.');\n}\n\n\n// Defined here: https://github.com/python-pillow/Pillow/blob/a405e8406b83f8bfb8916e93971edc7407b8b1ff/src/libImaging/Imaging.h#L262-L268\nconst RESAMPLING_MAPPING = {\n    0: 'nearest',\n    1: 'lanczos',\n    2: 'bilinear',\n    3: 'bicubic',\n    4: 'box',\n    5: 'hamming',\n}\n\nclass RawImage {\n\n    /**\n     * Create a new `RawImage` object.\n     * @param {Uint8ClampedArray} data The pixel data.\n     * @param {number} width The width of the image.\n     * @param {number} height The height of the image.\n     * @param {1|2|3|4} channels The number of channels.\n     */\n    constructor(data, width, height, channels) {\n        this._update(data, width, height, channels);\n    }\n\n    /**\n     * Helper method for reading an image from a variety of input types.\n     * @param {RawImage|string|URL} input \n     * @returns The image object.\n     * \n     * **Example:** Read image from a URL.\n     * ```javascript\n     * let image = await RawImage.read('https://huggingface.co/datasets/Xenova/transformers.js-docs/resolve/main/football-match.jpg');\n     * // test {\n     * //   \"data\": Uint8ClampedArray [ 25, 25, 25, 19, 19, 19, ... ],\n     * //   \"width\": 800,\n     * //   \"height\": 533,\n     * //   \"channels\": 3\n     * // }\n     * ```\n     */\n    static async read(input) {\n        if (input instanceof RawImage) {\n            return input;\n        } else if ((0,_core_js__WEBPACK_IMPORTED_MODULE_1__.isString)(input) || input instanceof URL) {\n            return await this.fromURL(input);\n        } else {\n            throw new Error(`Unsupported input type: ${typeof input}`);\n        }\n    }\n\n\n    /**\n     * Read an image from a URL or file path.\n     * @param {string|URL} url The URL or file path to read the image from.\n     * @returns {Promise<RawImage>} The image object.\n     */\n    static async fromURL(url) {\n        let response = await (0,_hub_js__WEBPACK_IMPORTED_MODULE_2__.getFile)(url);\n        let blob = await response.blob();\n        return this.fromBlob(blob);\n    }\n\n    /**\n     * Helper method to create a new Image from a blob.\n     * @param {Blob} blob The blob to read the image from.\n     * @returns {Promise<RawImage>} The image object.\n     */\n    static async fromBlob(blob) {\n        if (BROWSER_ENV) {\n            // Running in environment with canvas\n            let img = await loadImageFunction(blob);\n\n            const ctx = createCanvasFunction(img.width, img.height).getContext('2d');\n\n            // Draw image to context\n            ctx.drawImage(img, 0, 0);\n\n            return new this(ctx.getImageData(0, 0, img.width, img.height).data, img.width, img.height, 4);\n\n        } else {\n            // Use sharp.js to read (and possible resize) the image.\n            let img = sharp__WEBPACK_IMPORTED_MODULE_4__(await blob.arrayBuffer());\n\n            return await loadImageFunction(img);\n        }\n    }\n\n    /**\n     * Convert the image to grayscale format.\n     * @returns {RawImage} `this` to support chaining.\n     */\n    grayscale() {\n        if (this.channels === 1) {\n            return this;\n        }\n\n        let newData = new Uint8ClampedArray(this.width * this.height * 1);\n        switch (this.channels) {\n            case 3: // rgb to grayscale\n            case 4: // rgba to grayscale\n                for (let i = 0, offset = 0; i < this.data.length; i += this.channels) {\n                    const red = this.data[i];\n                    const green = this.data[i + 1];\n                    const blue = this.data[i + 2];\n\n                    newData[offset++] = Math.round(0.2989 * red + 0.5870 * green + 0.1140 * blue);\n                }\n                break;\n            default:\n                throw new Error(`Conversion failed due to unsupported number of channels: ${this.channels}`);\n        }\n        return this._update(newData, this.width, this.height, 1);\n    }\n\n    /**\n     * Convert the image to RGB format.\n     * @returns {RawImage} `this` to support chaining.\n     */\n    rgb() {\n        if (this.channels === 3) {\n            return this;\n        }\n\n        let newData = new Uint8ClampedArray(this.width * this.height * 3);\n\n        switch (this.channels) {\n            case 1: // grayscale to rgb\n                for (let i = 0, offset = 0; i < this.data.length; ++i) {\n                    newData[offset++] = this.data[i];\n                    newData[offset++] = this.data[i];\n                    newData[offset++] = this.data[i];\n                }\n                break;\n            case 4: // rgba to rgb\n                for (let i = 0, offset = 0; i < this.data.length; i += 4) {\n                    newData[offset++] = this.data[i];\n                    newData[offset++] = this.data[i + 1];\n                    newData[offset++] = this.data[i + 2];\n                }\n                break;\n            default:\n                throw new Error(`Conversion failed due to unsupported number of channels: ${this.channels}`);\n        }\n        return this._update(newData, this.width, this.height, 3);\n\n    }\n\n    /**\n     * Convert the image to RGBA format.\n     * @returns {RawImage} `this` to support chaining.\n     */\n    rgba() {\n        if (this.channels === 4) {\n            return this;\n        }\n\n        let newData = new Uint8ClampedArray(this.width * this.height * 4);\n\n        switch (this.channels) {\n            case 1: // grayscale to rgba\n                for (let i = 0, offset = 0; i < this.data.length; ++i) {\n                    newData[offset++] = this.data[i];\n                    newData[offset++] = this.data[i];\n                    newData[offset++] = this.data[i];\n                    newData[offset++] = 255;\n                }\n                break;\n            case 3: // rgb to rgba\n                for (let i = 0, offset = 0; i < this.data.length; i += 3) {\n                    newData[offset++] = this.data[i];\n                    newData[offset++] = this.data[i + 1];\n                    newData[offset++] = this.data[i + 2];\n                    newData[offset++] = 255;\n                }\n                break;\n            default:\n                throw new Error(`Conversion failed due to unsupported number of channels: ${this.channels}`);\n        }\n\n        return this._update(newData, this.width, this.height, 4);\n    }\n\n    /**\n     * Resize the image to the given dimensions. This method uses the canvas API to perform the resizing.\n     * @param {number} width The width of the new image.\n     * @param {number} height The height of the new image.\n     * @param {Object} options Additional options for resizing.\n     * @param {0|1|2|3|4|5|string} [options.resample] The resampling method to use.\n     * @returns {Promise<RawImage>} `this` to support chaining.\n     */\n    async resize(width, height, {\n        resample = 2,\n    } = {}) {\n\n        // Ensure resample method is a string\n        let resampleMethod = RESAMPLING_MAPPING[resample] ?? resample;\n\n        if (BROWSER_ENV) {\n            // TODO use `resample` in browser environment\n\n            // Store number of channels before resizing\n            let numChannels = this.channels;\n\n            // Create canvas object for this image\n            let canvas = this.toCanvas();\n\n            // Actually perform resizing using the canvas API\n            const ctx = createCanvasFunction(width, height).getContext('2d');\n\n            // Draw image to context, resizing in the process\n            ctx.drawImage(canvas, 0, 0, width, height);\n\n            // Create image from the resized data\n            let resizedImage = new RawImage(ctx.getImageData(0, 0, width, height).data, width, height, 4);\n\n            // Convert back so that image has the same number of channels as before\n            return resizedImage.convert(numChannels);\n\n        } else {\n            // Create sharp image from raw data, and resize\n            let img = sharp__WEBPACK_IMPORTED_MODULE_4__(this.data, {\n                raw: {\n                    width: this.width,\n                    height: this.height,\n                    channels: this.channels\n                }\n            });\n\n            switch (resampleMethod) {\n                case 'box':\n                case 'hamming':\n                    if (resampleMethod === 'box' || resampleMethod === 'hamming') {\n                        console.warn(`Resampling method ${resampleMethod} is not yet supported. Using bilinear instead.`);\n                        resampleMethod = 'bilinear';\n                    }\n\n                case 'nearest':\n                case 'bilinear':\n                case 'bicubic':\n                    // Perform resizing using affine transform. \n                    // This matches how the python Pillow library does it.\n                    img = img.affine([width / this.width, 0, 0, height / this.height], {\n                        interpolator: resampleMethod\n                    });\n                    break;\n\n                case 'lanczos':\n                    // https://github.com/python-pillow/Pillow/discussions/5519\n                    // https://github.com/lovell/sharp/blob/main/docs/api-resize.md\n                    img = img.resize({\n                        width, height,\n                        fit: 'fill',\n                        kernel: 'lanczos3', // PIL Lanczos uses a kernel size of 3 \n                    });\n                    break;\n\n                default:\n                    throw new Error(`Resampling method ${resampleMethod} is not supported.`);\n            }\n\n            return await loadImageFunction(img);\n        }\n\n    }\n\n    async pad([left, right, top, bottom]) {\n        left = Math.max(left, 0);\n        right = Math.max(right, 0);\n        top = Math.max(top, 0);\n        bottom = Math.max(bottom, 0);\n\n        if (left === 0 && right === 0 && top === 0 && bottom === 0) {\n            // No padding needed\n            return this;\n        }\n\n        if (BROWSER_ENV) {\n            // Store number of channels before padding\n            let numChannels = this.channels;\n\n            // Create canvas object for this image\n            let canvas = this.toCanvas();\n\n            let newWidth = this.width + left + right;\n            let newHeight = this.height + top + bottom;\n\n            // Create a new canvas of the desired size.\n            const ctx = createCanvasFunction(newWidth, newHeight).getContext('2d');\n\n            // Draw image to context, padding in the process\n            ctx.drawImage(canvas,\n                0, 0, this.width, this.height,\n                left, top, newWidth, newHeight\n            );\n\n            // Create image from the padded data\n            let paddedImage = new RawImage(\n                ctx.getImageData(0, 0, newWidth, newHeight).data,\n                newWidth, newHeight, 4);\n\n            // Convert back so that image has the same number of channels as before\n            return paddedImage.convert(numChannels);\n\n        } else {\n            let img = sharp__WEBPACK_IMPORTED_MODULE_4__(this.data, {\n                raw: {\n                    width: this.width,\n                    height: this.height,\n                    channels: this.channels\n                }\n            }).extend({ left, right, top, bottom });\n            return await loadImageFunction(img);\n        }\n    }\n\n    async center_crop(crop_width, crop_height) {\n        // If the image is already the desired size, return it\n        if (this.width === crop_width && this.height === crop_height) {\n            return this;\n        }\n\n        // Determine bounds of the image in the new canvas\n        let width_offset = (this.width - crop_width) / 2;\n        let height_offset = (this.height - crop_height) / 2;\n\n\n        if (BROWSER_ENV) {\n            // Store number of channels before resizing\n            let numChannels = this.channels;\n\n            // Create canvas object for this image\n            let canvas = this.toCanvas();\n\n            // Create a new canvas of the desired size. This is needed since if the \n            // image is too small, we need to pad it with black pixels.\n            const ctx = createCanvasFunction(crop_width, crop_height).getContext('2d');\n\n            let sourceX = 0;\n            let sourceY = 0;\n            let destX = 0;\n            let destY = 0;\n\n            if (width_offset >= 0) {\n                sourceX = width_offset;\n            } else {\n                destX = -width_offset;\n            }\n\n            if (height_offset >= 0) {\n                sourceY = height_offset;\n            } else {\n                destY = -height_offset;\n            }\n\n            // Draw image to context, cropping in the process\n            ctx.drawImage(canvas,\n                sourceX, sourceY, crop_width, crop_height,\n                destX, destY, crop_width, crop_height\n            );\n\n            // Create image from the resized data\n            let resizedImage = new RawImage(ctx.getImageData(0, 0, crop_width, crop_height).data, crop_width, crop_height, 4);\n\n            // Convert back so that image has the same number of channels as before\n            return resizedImage.convert(numChannels);\n\n        } else {\n            // Create sharp image from raw data\n            let img = sharp__WEBPACK_IMPORTED_MODULE_4__(this.data, {\n                raw: {\n                    width: this.width,\n                    height: this.height,\n                    channels: this.channels\n                }\n            });\n\n            if (width_offset >= 0 && height_offset >= 0) {\n                // Cropped image lies entirely within the original image\n                img = img.extract({\n                    left: Math.floor(width_offset),\n                    top: Math.floor(height_offset),\n                    width: crop_width,\n                    height: crop_height,\n                })\n            } else if (width_offset <= 0 && height_offset <= 0) {\n                // Cropped image lies entirely outside the original image,\n                // so we add padding\n                let top = Math.floor(-height_offset);\n                let left = Math.floor(-width_offset);\n                img = img.extend({\n                    top: top,\n                    left: left,\n\n                    // Ensures the resulting image has the desired dimensions\n                    right: crop_width - this.width - left,\n                    bottom: crop_height - this.height - top,\n                });\n            } else {\n                // Cropped image lies partially outside the original image.\n                // We first pad, then crop.\n\n                let y_padding = [0, 0];\n                let y_extract = 0;\n                if (height_offset < 0) {\n                    y_padding[0] = Math.floor(-height_offset);\n                    y_padding[1] = crop_height - this.height - y_padding[0];\n                } else {\n                    y_extract = Math.floor(height_offset);\n                }\n\n                let x_padding = [0, 0];\n                let x_extract = 0;\n                if (width_offset < 0) {\n                    x_padding[0] = Math.floor(-width_offset);\n                    x_padding[1] = crop_width - this.width - x_padding[0];\n                } else {\n                    x_extract = Math.floor(width_offset);\n                }\n\n                img = img.extend({\n                    top: y_padding[0],\n                    bottom: y_padding[1],\n                    left: x_padding[0],\n                    right: x_padding[1],\n                }).extract({\n                    left: x_extract,\n                    top: y_extract,\n                    width: crop_width,\n                    height: crop_height,\n                })\n            }\n\n            return await loadImageFunction(img);\n        }\n    }\n\n    toCanvas() {\n        // Clone, and convert data to RGBA before drawing to canvas.\n        // This is because the canvas API only supports RGBA\n        let cloned = this.clone().rgba();\n\n        // Create canvas object for the cloned image\n        let clonedCanvas = createCanvasFunction(cloned.width, cloned.height);\n\n        // Draw image to context\n        let data = new ImageDataClass(cloned.data, cloned.width, cloned.height);\n        clonedCanvas.getContext('2d').putImageData(data, 0, 0);\n\n        return clonedCanvas;\n    }\n\n    /**\n     * Helper method to update the image data.\n     * @param {Uint8ClampedArray} data The new image data.\n     * @param {number} width The new width of the image.\n     * @param {number} height The new height of the image.\n     * @param {1|2|3|4} channels The new number of channels of the image.\n     */\n    _update(data, width, height, channels = null) {\n        this.data = data;\n        this.width = width;\n        this.height = height;\n        if (channels !== null) {\n            this.channels = channels;\n        }\n        return this;\n    }\n\n    /**\n     * Clone the image\n     * @returns {RawImage} The cloned image\n     */\n    clone() {\n        return new RawImage(this.data.slice(), this.width, this.height, this.channels);\n    }\n\n    /**\n     * Helper method for converting image to have a certain number of channels\n     * @param {number} numChannels The number of channels. Must be 1, 3, or 4.\n     * @returns {RawImage} `this` to support chaining.\n     */\n    convert(numChannels) {\n        if (this.channels === numChannels) return this; // Already correct number of channels\n\n        switch (numChannels) {\n            case 1:\n                this.grayscale();\n                break;\n            case 3:\n                this.rgb();\n                break;\n            case 4:\n                this.rgba();\n                break;\n            default:\n                throw new Error(`Conversion failed due to unsupported number of channels: ${this.channels}`);\n        }\n        return this;\n    }\n\n    /**\n     * Save the image to the given path. This method is only available in environments with access to the FileSystem.\n     * @param {string|Buffer|URL} path The path to save the image to.\n     * @param {string} [mime='image/png'] The mime type of the image.\n     */\n    save(path, mime = 'image/png') {\n        if (!_env_js__WEBPACK_IMPORTED_MODULE_3__.env.useFS) {\n            throw new Error('Unable to save the image because filesystem is disabled in this environment.')\n        }\n\n        let canvas = this.toCanvas();\n        const buffer = canvas.toBuffer(mime);\n        fs__WEBPACK_IMPORTED_MODULE_0__.writeFileSync(path, buffer);\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHhlbm92YS90cmFuc2Zvcm1lcnMvc3JjL3V0aWxzL2ltYWdlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVvQjtBQUNpQjtBQUNGO0FBQ0g7O0FBRWhDO0FBQzBCOztBQUUxQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLFFBQVEscUJBQXFCLFFBQVE7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsRUFBRSxTQUFTLGtDQUFLO0FBQ2hCOztBQUVBLHlDQUF5QyxZQUFZO0FBQ3JEO0FBQ0E7O0FBRUEsY0FBYyxhQUFhLDZCQUE2Qix5QkFBeUI7O0FBRWpGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsRUFBRTtBQUNGO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTzs7QUFFUDtBQUNBO0FBQ0EsZUFBZSxtQkFBbUI7QUFDbEMsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUscUJBQXFCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxTQUFTLGtEQUFRO0FBQzNCO0FBQ0EsVUFBVTtBQUNWLHVEQUF1RCxhQUFhO0FBQ3BFO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxlQUFlLFlBQVk7QUFDM0IsaUJBQWlCLG1CQUFtQjtBQUNwQztBQUNBO0FBQ0EsNkJBQTZCLGdEQUFPO0FBQ3BDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCLGlCQUFpQixtQkFBbUI7QUFDcEM7QUFD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O0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsbUJBQW1CO0FBQ2xDLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsVUFBVTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixVQUFVO0FBQzNCO0FBQ0E7QUFDQSx3REFBd0Q7O0FBRXhEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RkFBNEYsY0FBYztBQUMxRztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsbUJBQW1CO0FBQ2xDLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0EsYUFBYSx3Q0FBRztBQUNoQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRLDZDQUFnQjtBQUN4QjtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdHJhbnNmb3JtZXJzanMtcGxheWdyb3VuZC8uL25vZGVfbW9kdWxlcy9AeGVub3ZhL3RyYW5zZm9ybWVycy9zcmMvdXRpbHMvaW1hZ2UuanM/OTE3NiJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qKlxuICogQGZpbGUgSGVscGVyIG1vZHVsZSBmb3IgaW1hZ2UgcHJvY2Vzc2luZy4gXG4gKiBcbiAqIFRoZXNlIGZ1bmN0aW9ucyBhbmQgY2xhc3NlcyBhcmUgb25seSB1c2VkIGludGVybmFsbHksIFxuICogbWVhbmluZyBhbiBlbmQtdXNlciBzaG91bGRuJ3QgbmVlZCB0byBhY2Nlc3MgYW55dGhpbmcgaGVyZS5cbiAqIFxuICogQG1vZHVsZSB1dGlscy9pbWFnZVxuICovXG5cbmltcG9ydCBmcyBmcm9tICdmcyc7XG5pbXBvcnQgeyBpc1N0cmluZyB9IGZyb20gJy4vY29yZS5qcyc7XG5pbXBvcnQgeyBnZXRGaWxlIH0gZnJvbSAnLi9odWIuanMnO1xuaW1wb3J0IHsgZW52IH0gZnJvbSAnLi4vZW52LmpzJztcblxuLy8gV2lsbCBiZSBlbXB0eSAob3Igbm90IHVzZWQpIGlmIHJ1bm5pbmcgaW4gYnJvd3NlciBvciB3ZWItd29ya2VyXG5pbXBvcnQgc2hhcnAgZnJvbSAnc2hhcnAnO1xuXG5jb25zdCBCUk9XU0VSX0VOViA9IHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJztcblxubGV0IGNyZWF0ZUNhbnZhc0Z1bmN0aW9uO1xubGV0IEltYWdlRGF0YUNsYXNzO1xubGV0IGxvYWRJbWFnZUZ1bmN0aW9uO1xuaWYgKEJST1dTRVJfRU5WKSB7XG4gICAgLy8gUnVubmluZyBpbiBicm93c2VyIG9yIHdlYi13b3JrZXJcbiAgICBjcmVhdGVDYW52YXNGdW5jdGlvbiA9ICgvKiogQHR5cGUge251bWJlcn0gKi8gd2lkdGgsIC8qKiBAdHlwZSB7bnVtYmVyfSAqLyBoZWlnaHQpID0+IHtcbiAgICAgICAgaWYgKCFzZWxmLk9mZnNjcmVlbkNhbnZhcykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdPZmZzY3JlZW5DYW52YXMgbm90IHN1cHBvcnRlZCBieSB0aGlzIGJyb3dzZXIuJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBzZWxmLk9mZnNjcmVlbkNhbnZhcyh3aWR0aCwgaGVpZ2h0KVxuICAgIH07XG4gICAgbG9hZEltYWdlRnVuY3Rpb24gPSBzZWxmLmNyZWF0ZUltYWdlQml0bWFwO1xuICAgIEltYWdlRGF0YUNsYXNzID0gc2VsZi5JbWFnZURhdGE7XG5cbn0gZWxzZSBpZiAoc2hhcnApIHtcbiAgICAvLyBSdW5uaW5nIGluIE5vZGUuanMsIGVsZWN0cm9uLCBvciBvdGhlciBub24tYnJvd3NlciBlbnZpcm9ubWVudFxuXG4gICAgbG9hZEltYWdlRnVuY3Rpb24gPSBhc3luYyAoLyoqQHR5cGUge3NoYXJwLlNoYXJwfSovaW1nKSA9PiB7XG4gICAgICAgIGNvbnN0IG1ldGFkYXRhID0gYXdhaXQgaW1nLm1ldGFkYXRhKCk7XG4gICAgICAgIGNvbnN0IHJhd0NoYW5uZWxzID0gbWV0YWRhdGEuY2hhbm5lbHM7XG5cbiAgICAgICAgbGV0IHsgZGF0YSwgaW5mbyB9ID0gYXdhaXQgaW1nLnJhdygpLnRvQnVmZmVyKHsgcmVzb2x2ZVdpdGhPYmplY3Q6IHRydWUgfSk7XG5cbiAgICAgICAgY29uc3QgbmV3SW1hZ2UgPSBuZXcgUmF3SW1hZ2UobmV3IFVpbnQ4Q2xhbXBlZEFycmF5KGRhdGEpLCBpbmZvLndpZHRoLCBpbmZvLmhlaWdodCwgaW5mby5jaGFubmVscyk7XG4gICAgICAgIGlmIChyYXdDaGFubmVscyAhPT0gdW5kZWZpbmVkICYmIHJhd0NoYW5uZWxzICE9PSBpbmZvLmNoYW5uZWxzKSB7XG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIG5ldyBpbWFnZSBoYXMgdGhlIHNhbWUgbnVtYmVyIG9mIGNoYW5uZWxzIGFzIHRoZSBpbnB1dCBpbWFnZS5cbiAgICAgICAgICAgIC8vIFRoaXMgaXMgbmVjZXNzYXJ5IGZvciBncmF5c2NhbGUgaW1hZ2VzLlxuICAgICAgICAgICAgbmV3SW1hZ2UuY29udmVydChyYXdDaGFubmVscyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld0ltYWdlO1xuICAgIH1cblxufSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBsb2FkIGltYWdlIHByb2Nlc3NpbmcgbGlicmFyeS4nKTtcbn1cblxuXG4vLyBEZWZpbmVkIGhlcmU6IGh0dHBzOi8vZ2l0aHViLmNvbS9weXRob24tcGlsbG93L1BpbGxvdy9ibG9iL2E0MDVlODQwNmI4M2Y4YmZiODkxNmU5Mzk3MWVkYzc0MDdiOGIxZmYvc3JjL2xpYkltYWdpbmcvSW1hZ2luZy5oI0wyNjItTDI2OFxuY29uc3QgUkVTQU1QTElOR19NQVBQSU5HID0ge1xuICAgIDA6ICduZWFyZXN0JyxcbiAgICAxOiAnbGFuY3pvcycsXG4gICAgMjogJ2JpbGluZWFyJyxcbiAgICAzOiAnYmljdWJpYycsXG4gICAgNDogJ2JveCcsXG4gICAgNTogJ2hhbW1pbmcnLFxufVxuXG5leHBvcnQgY2xhc3MgUmF3SW1hZ2Uge1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IGBSYXdJbWFnZWAgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7VWludDhDbGFtcGVkQXJyYXl9IGRhdGEgVGhlIHBpeGVsIGRhdGEuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoIFRoZSB3aWR0aCBvZiB0aGUgaW1hZ2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCBUaGUgaGVpZ2h0IG9mIHRoZSBpbWFnZS5cbiAgICAgKiBAcGFyYW0gezF8MnwzfDR9IGNoYW5uZWxzIFRoZSBudW1iZXIgb2YgY2hhbm5lbHMuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZGF0YSwgd2lkdGgsIGhlaWdodCwgY2hhbm5lbHMpIHtcbiAgICAgICAgdGhpcy5fdXBkYXRlKGRhdGEsIHdpZHRoLCBoZWlnaHQsIGNoYW5uZWxzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIZWxwZXIgbWV0aG9kIGZvciByZWFkaW5nIGFuIGltYWdlIGZyb20gYSB2YXJpZXR5IG9mIGlucHV0IHR5cGVzLlxuICAgICAqIEBwYXJhbSB7UmF3SW1hZ2V8c3RyaW5nfFVSTH0gaW5wdXQgXG4gICAgICogQHJldHVybnMgVGhlIGltYWdlIG9iamVjdC5cbiAgICAgKiBcbiAgICAgKiAqKkV4YW1wbGU6KiogUmVhZCBpbWFnZSBmcm9tIGEgVVJMLlxuICAgICAqIGBgYGphdmFzY3JpcHRcbiAgICAgKiBsZXQgaW1hZ2UgPSBhd2FpdCBSYXdJbWFnZS5yZWFkKCdodHRwczovL2h1Z2dpbmdmYWNlLmNvL2RhdGFzZXRzL1hlbm92YS90cmFuc2Zvcm1lcnMuanMtZG9jcy9yZXNvbHZlL21haW4vZm9vdGJhbGwtbWF0Y2guanBnJyk7XG4gICAgICogLy8gdGVzdCB7XG4gICAgICogLy8gICBcImRhdGFcIjogVWludDhDbGFtcGVkQXJyYXkgWyAyNSwgMjUsIDI1LCAxOSwgMTksIDE5LCAuLi4gXSxcbiAgICAgKiAvLyAgIFwid2lkdGhcIjogODAwLFxuICAgICAqIC8vICAgXCJoZWlnaHRcIjogNTMzLFxuICAgICAqIC8vICAgXCJjaGFubmVsc1wiOiAzXG4gICAgICogLy8gfVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHN0YXRpYyBhc3luYyByZWFkKGlucHV0KSB7XG4gICAgICAgIGlmIChpbnB1dCBpbnN0YW5jZW9mIFJhd0ltYWdlKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQ7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNTdHJpbmcoaW5wdXQpIHx8IGlucHV0IGluc3RhbmNlb2YgVVJMKSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5mcm9tVVJMKGlucHV0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgaW5wdXQgdHlwZTogJHt0eXBlb2YgaW5wdXR9YCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIFJlYWQgYW4gaW1hZ2UgZnJvbSBhIFVSTCBvciBmaWxlIHBhdGguXG4gICAgICogQHBhcmFtIHtzdHJpbmd8VVJMfSB1cmwgVGhlIFVSTCBvciBmaWxlIHBhdGggdG8gcmVhZCB0aGUgaW1hZ2UgZnJvbS5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxSYXdJbWFnZT59IFRoZSBpbWFnZSBvYmplY3QuXG4gICAgICovXG4gICAgc3RhdGljIGFzeW5jIGZyb21VUkwodXJsKSB7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IGdldEZpbGUodXJsKTtcbiAgICAgICAgbGV0IGJsb2IgPSBhd2FpdCByZXNwb25zZS5ibG9iKCk7XG4gICAgICAgIHJldHVybiB0aGlzLmZyb21CbG9iKGJsb2IpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhlbHBlciBtZXRob2QgdG8gY3JlYXRlIGEgbmV3IEltYWdlIGZyb20gYSBibG9iLlxuICAgICAqIEBwYXJhbSB7QmxvYn0gYmxvYiBUaGUgYmxvYiB0byByZWFkIHRoZSBpbWFnZSBmcm9tLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFJhd0ltYWdlPn0gVGhlIGltYWdlIG9iamVjdC5cbiAgICAgKi9cbiAgICBzdGF0aWMgYXN5bmMgZnJvbUJsb2IoYmxvYikge1xuICAgICAgICBpZiAoQlJPV1NFUl9FTlYpIHtcbiAgICAgICAgICAgIC8vIFJ1bm5pbmcgaW4gZW52aXJvbm1lbnQgd2l0aCBjYW52YXNcbiAgICAgICAgICAgIGxldCBpbWcgPSBhd2FpdCBsb2FkSW1hZ2VGdW5jdGlvbihibG9iKTtcblxuICAgICAgICAgICAgY29uc3QgY3R4ID0gY3JlYXRlQ2FudmFzRnVuY3Rpb24oaW1nLndpZHRoLCBpbWcuaGVpZ2h0KS5nZXRDb250ZXh0KCcyZCcpO1xuXG4gICAgICAgICAgICAvLyBEcmF3IGltYWdlIHRvIGNvbnRleHRcbiAgICAgICAgICAgIGN0eC5kcmF3SW1hZ2UoaW1nLCAwLCAwKTtcblxuICAgICAgICAgICAgcmV0dXJuIG5ldyB0aGlzKGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgaW1nLndpZHRoLCBpbWcuaGVpZ2h0KS5kYXRhLCBpbWcud2lkdGgsIGltZy5oZWlnaHQsIDQpO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBVc2Ugc2hhcnAuanMgdG8gcmVhZCAoYW5kIHBvc3NpYmxlIHJlc2l6ZSkgdGhlIGltYWdlLlxuICAgICAgICAgICAgbGV0IGltZyA9IHNoYXJwKGF3YWl0IGJsb2IuYXJyYXlCdWZmZXIoKSk7XG5cbiAgICAgICAgICAgIHJldHVybiBhd2FpdCBsb2FkSW1hZ2VGdW5jdGlvbihpbWcpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydCB0aGUgaW1hZ2UgdG8gZ3JheXNjYWxlIGZvcm1hdC5cbiAgICAgKiBAcmV0dXJucyB7UmF3SW1hZ2V9IGB0aGlzYCB0byBzdXBwb3J0IGNoYWluaW5nLlxuICAgICAqL1xuICAgIGdyYXlzY2FsZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuY2hhbm5lbHMgPT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IG5ld0RhdGEgPSBuZXcgVWludDhDbGFtcGVkQXJyYXkodGhpcy53aWR0aCAqIHRoaXMuaGVpZ2h0ICogMSk7XG4gICAgICAgIHN3aXRjaCAodGhpcy5jaGFubmVscykge1xuICAgICAgICAgICAgY2FzZSAzOiAvLyByZ2IgdG8gZ3JheXNjYWxlXG4gICAgICAgICAgICBjYXNlIDQ6IC8vIHJnYmEgdG8gZ3JheXNjYWxlXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIG9mZnNldCA9IDA7IGkgPCB0aGlzLmRhdGEubGVuZ3RoOyBpICs9IHRoaXMuY2hhbm5lbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVkID0gdGhpcy5kYXRhW2ldO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBncmVlbiA9IHRoaXMuZGF0YVtpICsgMV07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJsdWUgPSB0aGlzLmRhdGFbaSArIDJdO1xuXG4gICAgICAgICAgICAgICAgICAgIG5ld0RhdGFbb2Zmc2V0KytdID0gTWF0aC5yb3VuZCgwLjI5ODkgKiByZWQgKyAwLjU4NzAgKiBncmVlbiArIDAuMTE0MCAqIGJsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb252ZXJzaW9uIGZhaWxlZCBkdWUgdG8gdW5zdXBwb3J0ZWQgbnVtYmVyIG9mIGNoYW5uZWxzOiAke3RoaXMuY2hhbm5lbHN9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3VwZGF0ZShuZXdEYXRhLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCwgMSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydCB0aGUgaW1hZ2UgdG8gUkdCIGZvcm1hdC5cbiAgICAgKiBAcmV0dXJucyB7UmF3SW1hZ2V9IGB0aGlzYCB0byBzdXBwb3J0IGNoYWluaW5nLlxuICAgICAqL1xuICAgIHJnYigpIHtcbiAgICAgICAgaWYgKHRoaXMuY2hhbm5lbHMgPT09IDMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IG5ld0RhdGEgPSBuZXcgVWludDhDbGFtcGVkQXJyYXkodGhpcy53aWR0aCAqIHRoaXMuaGVpZ2h0ICogMyk7XG5cbiAgICAgICAgc3dpdGNoICh0aGlzLmNoYW5uZWxzKSB7XG4gICAgICAgICAgICBjYXNlIDE6IC8vIGdyYXlzY2FsZSB0byByZ2JcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgb2Zmc2V0ID0gMDsgaSA8IHRoaXMuZGF0YS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBuZXdEYXRhW29mZnNldCsrXSA9IHRoaXMuZGF0YVtpXTtcbiAgICAgICAgICAgICAgICAgICAgbmV3RGF0YVtvZmZzZXQrK10gPSB0aGlzLmRhdGFbaV07XG4gICAgICAgICAgICAgICAgICAgIG5ld0RhdGFbb2Zmc2V0KytdID0gdGhpcy5kYXRhW2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNDogLy8gcmdiYSB0byByZ2JcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgb2Zmc2V0ID0gMDsgaSA8IHRoaXMuZGF0YS5sZW5ndGg7IGkgKz0gNCkge1xuICAgICAgICAgICAgICAgICAgICBuZXdEYXRhW29mZnNldCsrXSA9IHRoaXMuZGF0YVtpXTtcbiAgICAgICAgICAgICAgICAgICAgbmV3RGF0YVtvZmZzZXQrK10gPSB0aGlzLmRhdGFbaSArIDFdO1xuICAgICAgICAgICAgICAgICAgICBuZXdEYXRhW29mZnNldCsrXSA9IHRoaXMuZGF0YVtpICsgMl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvbnZlcnNpb24gZmFpbGVkIGR1ZSB0byB1bnN1cHBvcnRlZCBudW1iZXIgb2YgY2hhbm5lbHM6ICR7dGhpcy5jaGFubmVsc31gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fdXBkYXRlKG5ld0RhdGEsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0LCAzKTtcblxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnQgdGhlIGltYWdlIHRvIFJHQkEgZm9ybWF0LlxuICAgICAqIEByZXR1cm5zIHtSYXdJbWFnZX0gYHRoaXNgIHRvIHN1cHBvcnQgY2hhaW5pbmcuXG4gICAgICovXG4gICAgcmdiYSgpIHtcbiAgICAgICAgaWYgKHRoaXMuY2hhbm5lbHMgPT09IDQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IG5ld0RhdGEgPSBuZXcgVWludDhDbGFtcGVkQXJyYXkodGhpcy53aWR0aCAqIHRoaXMuaGVpZ2h0ICogNCk7XG5cbiAgICAgICAgc3dpdGNoICh0aGlzLmNoYW5uZWxzKSB7XG4gICAgICAgICAgICBjYXNlIDE6IC8vIGdyYXlzY2FsZSB0byByZ2JhXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIG9mZnNldCA9IDA7IGkgPCB0aGlzLmRhdGEubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3RGF0YVtvZmZzZXQrK10gPSB0aGlzLmRhdGFbaV07XG4gICAgICAgICAgICAgICAgICAgIG5ld0RhdGFbb2Zmc2V0KytdID0gdGhpcy5kYXRhW2ldO1xuICAgICAgICAgICAgICAgICAgICBuZXdEYXRhW29mZnNldCsrXSA9IHRoaXMuZGF0YVtpXTtcbiAgICAgICAgICAgICAgICAgICAgbmV3RGF0YVtvZmZzZXQrK10gPSAyNTU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAzOiAvLyByZ2IgdG8gcmdiYVxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBvZmZzZXQgPSAwOyBpIDwgdGhpcy5kYXRhLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld0RhdGFbb2Zmc2V0KytdID0gdGhpcy5kYXRhW2ldO1xuICAgICAgICAgICAgICAgICAgICBuZXdEYXRhW29mZnNldCsrXSA9IHRoaXMuZGF0YVtpICsgMV07XG4gICAgICAgICAgICAgICAgICAgIG5ld0RhdGFbb2Zmc2V0KytdID0gdGhpcy5kYXRhW2kgKyAyXTtcbiAgICAgICAgICAgICAgICAgICAgbmV3RGF0YVtvZmZzZXQrK10gPSAyNTU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvbnZlcnNpb24gZmFpbGVkIGR1ZSB0byB1bnN1cHBvcnRlZCBudW1iZXIgb2YgY2hhbm5lbHM6ICR7dGhpcy5jaGFubmVsc31gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLl91cGRhdGUobmV3RGF0YSwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQsIDQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlc2l6ZSB0aGUgaW1hZ2UgdG8gdGhlIGdpdmVuIGRpbWVuc2lvbnMuIFRoaXMgbWV0aG9kIHVzZXMgdGhlIGNhbnZhcyBBUEkgdG8gcGVyZm9ybSB0aGUgcmVzaXppbmcuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoIFRoZSB3aWR0aCBvZiB0aGUgbmV3IGltYWdlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQgVGhlIGhlaWdodCBvZiB0aGUgbmV3IGltYWdlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIEFkZGl0aW9uYWwgb3B0aW9ucyBmb3IgcmVzaXppbmcuXG4gICAgICogQHBhcmFtIHswfDF8MnwzfDR8NXxzdHJpbmd9IFtvcHRpb25zLnJlc2FtcGxlXSBUaGUgcmVzYW1wbGluZyBtZXRob2QgdG8gdXNlLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFJhd0ltYWdlPn0gYHRoaXNgIHRvIHN1cHBvcnQgY2hhaW5pbmcuXG4gICAgICovXG4gICAgYXN5bmMgcmVzaXplKHdpZHRoLCBoZWlnaHQsIHtcbiAgICAgICAgcmVzYW1wbGUgPSAyLFxuICAgIH0gPSB7fSkge1xuXG4gICAgICAgIC8vIEVuc3VyZSByZXNhbXBsZSBtZXRob2QgaXMgYSBzdHJpbmdcbiAgICAgICAgbGV0IHJlc2FtcGxlTWV0aG9kID0gUkVTQU1QTElOR19NQVBQSU5HW3Jlc2FtcGxlXSA/PyByZXNhbXBsZTtcblxuICAgICAgICBpZiAoQlJPV1NFUl9FTlYpIHtcbiAgICAgICAgICAgIC8vIFRPRE8gdXNlIGByZXNhbXBsZWAgaW4gYnJvd3NlciBlbnZpcm9ubWVudFxuXG4gICAgICAgICAgICAvLyBTdG9yZSBudW1iZXIgb2YgY2hhbm5lbHMgYmVmb3JlIHJlc2l6aW5nXG4gICAgICAgICAgICBsZXQgbnVtQ2hhbm5lbHMgPSB0aGlzLmNoYW5uZWxzO1xuXG4gICAgICAgICAgICAvLyBDcmVhdGUgY2FudmFzIG9iamVjdCBmb3IgdGhpcyBpbWFnZVxuICAgICAgICAgICAgbGV0IGNhbnZhcyA9IHRoaXMudG9DYW52YXMoKTtcblxuICAgICAgICAgICAgLy8gQWN0dWFsbHkgcGVyZm9ybSByZXNpemluZyB1c2luZyB0aGUgY2FudmFzIEFQSVxuICAgICAgICAgICAgY29uc3QgY3R4ID0gY3JlYXRlQ2FudmFzRnVuY3Rpb24od2lkdGgsIGhlaWdodCkuZ2V0Q29udGV4dCgnMmQnKTtcblxuICAgICAgICAgICAgLy8gRHJhdyBpbWFnZSB0byBjb250ZXh0LCByZXNpemluZyBpbiB0aGUgcHJvY2Vzc1xuICAgICAgICAgICAgY3R4LmRyYXdJbWFnZShjYW52YXMsIDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuXG4gICAgICAgICAgICAvLyBDcmVhdGUgaW1hZ2UgZnJvbSB0aGUgcmVzaXplZCBkYXRhXG4gICAgICAgICAgICBsZXQgcmVzaXplZEltYWdlID0gbmV3IFJhd0ltYWdlKGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgd2lkdGgsIGhlaWdodCkuZGF0YSwgd2lkdGgsIGhlaWdodCwgNCk7XG5cbiAgICAgICAgICAgIC8vIENvbnZlcnQgYmFjayBzbyB0aGF0IGltYWdlIGhhcyB0aGUgc2FtZSBudW1iZXIgb2YgY2hhbm5lbHMgYXMgYmVmb3JlXG4gICAgICAgICAgICByZXR1cm4gcmVzaXplZEltYWdlLmNvbnZlcnQobnVtQ2hhbm5lbHMpO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBDcmVhdGUgc2hhcnAgaW1hZ2UgZnJvbSByYXcgZGF0YSwgYW5kIHJlc2l6ZVxuICAgICAgICAgICAgbGV0IGltZyA9IHNoYXJwKHRoaXMuZGF0YSwge1xuICAgICAgICAgICAgICAgIHJhdzoge1xuICAgICAgICAgICAgICAgICAgICB3aWR0aDogdGhpcy53aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLmhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgY2hhbm5lbHM6IHRoaXMuY2hhbm5lbHNcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgc3dpdGNoIChyZXNhbXBsZU1ldGhvZCkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2JveCc6XG4gICAgICAgICAgICAgICAgY2FzZSAnaGFtbWluZyc6XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXNhbXBsZU1ldGhvZCA9PT0gJ2JveCcgfHwgcmVzYW1wbGVNZXRob2QgPT09ICdoYW1taW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBSZXNhbXBsaW5nIG1ldGhvZCAke3Jlc2FtcGxlTWV0aG9kfSBpcyBub3QgeWV0IHN1cHBvcnRlZC4gVXNpbmcgYmlsaW5lYXIgaW5zdGVhZC5gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc2FtcGxlTWV0aG9kID0gJ2JpbGluZWFyJztcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY2FzZSAnbmVhcmVzdCc6XG4gICAgICAgICAgICAgICAgY2FzZSAnYmlsaW5lYXInOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2JpY3ViaWMnOlxuICAgICAgICAgICAgICAgICAgICAvLyBQZXJmb3JtIHJlc2l6aW5nIHVzaW5nIGFmZmluZSB0cmFuc2Zvcm0uIFxuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIG1hdGNoZXMgaG93IHRoZSBweXRob24gUGlsbG93IGxpYnJhcnkgZG9lcyBpdC5cbiAgICAgICAgICAgICAgICAgICAgaW1nID0gaW1nLmFmZmluZShbd2lkdGggLyB0aGlzLndpZHRoLCAwLCAwLCBoZWlnaHQgLyB0aGlzLmhlaWdodF0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGludGVycG9sYXRvcjogcmVzYW1wbGVNZXRob2RcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSAnbGFuY3pvcyc6XG4gICAgICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9weXRob24tcGlsbG93L1BpbGxvdy9kaXNjdXNzaW9ucy81NTE5XG4gICAgICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9sb3ZlbGwvc2hhcnAvYmxvYi9tYWluL2RvY3MvYXBpLXJlc2l6ZS5tZFxuICAgICAgICAgICAgICAgICAgICBpbWcgPSBpbWcucmVzaXplKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoLCBoZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgICAgICBmaXQ6ICdmaWxsJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGtlcm5lbDogJ2xhbmN6b3MzJywgLy8gUElMIExhbmN6b3MgdXNlcyBhIGtlcm5lbCBzaXplIG9mIDMgXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUmVzYW1wbGluZyBtZXRob2QgJHtyZXNhbXBsZU1ldGhvZH0gaXMgbm90IHN1cHBvcnRlZC5gKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IGxvYWRJbWFnZUZ1bmN0aW9uKGltZyk7XG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIGFzeW5jIHBhZChbbGVmdCwgcmlnaHQsIHRvcCwgYm90dG9tXSkge1xuICAgICAgICBsZWZ0ID0gTWF0aC5tYXgobGVmdCwgMCk7XG4gICAgICAgIHJpZ2h0ID0gTWF0aC5tYXgocmlnaHQsIDApO1xuICAgICAgICB0b3AgPSBNYXRoLm1heCh0b3AsIDApO1xuICAgICAgICBib3R0b20gPSBNYXRoLm1heChib3R0b20sIDApO1xuXG4gICAgICAgIGlmIChsZWZ0ID09PSAwICYmIHJpZ2h0ID09PSAwICYmIHRvcCA9PT0gMCAmJiBib3R0b20gPT09IDApIHtcbiAgICAgICAgICAgIC8vIE5vIHBhZGRpbmcgbmVlZGVkXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChCUk9XU0VSX0VOVikge1xuICAgICAgICAgICAgLy8gU3RvcmUgbnVtYmVyIG9mIGNoYW5uZWxzIGJlZm9yZSBwYWRkaW5nXG4gICAgICAgICAgICBsZXQgbnVtQ2hhbm5lbHMgPSB0aGlzLmNoYW5uZWxzO1xuXG4gICAgICAgICAgICAvLyBDcmVhdGUgY2FudmFzIG9iamVjdCBmb3IgdGhpcyBpbWFnZVxuICAgICAgICAgICAgbGV0IGNhbnZhcyA9IHRoaXMudG9DYW52YXMoKTtcblxuICAgICAgICAgICAgbGV0IG5ld1dpZHRoID0gdGhpcy53aWR0aCArIGxlZnQgKyByaWdodDtcbiAgICAgICAgICAgIGxldCBuZXdIZWlnaHQgPSB0aGlzLmhlaWdodCArIHRvcCArIGJvdHRvbTtcblxuICAgICAgICAgICAgLy8gQ3JlYXRlIGEgbmV3IGNhbnZhcyBvZiB0aGUgZGVzaXJlZCBzaXplLlxuICAgICAgICAgICAgY29uc3QgY3R4ID0gY3JlYXRlQ2FudmFzRnVuY3Rpb24obmV3V2lkdGgsIG5ld0hlaWdodCkuZ2V0Q29udGV4dCgnMmQnKTtcblxuICAgICAgICAgICAgLy8gRHJhdyBpbWFnZSB0byBjb250ZXh0LCBwYWRkaW5nIGluIHRoZSBwcm9jZXNzXG4gICAgICAgICAgICBjdHguZHJhd0ltYWdlKGNhbnZhcyxcbiAgICAgICAgICAgICAgICAwLCAwLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCxcbiAgICAgICAgICAgICAgICBsZWZ0LCB0b3AsIG5ld1dpZHRoLCBuZXdIZWlnaHRcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIC8vIENyZWF0ZSBpbWFnZSBmcm9tIHRoZSBwYWRkZWQgZGF0YVxuICAgICAgICAgICAgbGV0IHBhZGRlZEltYWdlID0gbmV3IFJhd0ltYWdlKFxuICAgICAgICAgICAgICAgIGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgbmV3V2lkdGgsIG5ld0hlaWdodCkuZGF0YSxcbiAgICAgICAgICAgICAgICBuZXdXaWR0aCwgbmV3SGVpZ2h0LCA0KTtcblxuICAgICAgICAgICAgLy8gQ29udmVydCBiYWNrIHNvIHRoYXQgaW1hZ2UgaGFzIHRoZSBzYW1lIG51bWJlciBvZiBjaGFubmVscyBhcyBiZWZvcmVcbiAgICAgICAgICAgIHJldHVybiBwYWRkZWRJbWFnZS5jb252ZXJ0KG51bUNoYW5uZWxzKTtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGV0IGltZyA9IHNoYXJwKHRoaXMuZGF0YSwge1xuICAgICAgICAgICAgICAgIHJhdzoge1xuICAgICAgICAgICAgICAgICAgICB3aWR0aDogdGhpcy53aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLmhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgY2hhbm5lbHM6IHRoaXMuY2hhbm5lbHNcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KS5leHRlbmQoeyBsZWZ0LCByaWdodCwgdG9wLCBib3R0b20gfSk7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgbG9hZEltYWdlRnVuY3Rpb24oaW1nKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFzeW5jIGNlbnRlcl9jcm9wKGNyb3Bfd2lkdGgsIGNyb3BfaGVpZ2h0KSB7XG4gICAgICAgIC8vIElmIHRoZSBpbWFnZSBpcyBhbHJlYWR5IHRoZSBkZXNpcmVkIHNpemUsIHJldHVybiBpdFxuICAgICAgICBpZiAodGhpcy53aWR0aCA9PT0gY3JvcF93aWR0aCAmJiB0aGlzLmhlaWdodCA9PT0gY3JvcF9oZWlnaHQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRGV0ZXJtaW5lIGJvdW5kcyBvZiB0aGUgaW1hZ2UgaW4gdGhlIG5ldyBjYW52YXNcbiAgICAgICAgbGV0IHdpZHRoX29mZnNldCA9ICh0aGlzLndpZHRoIC0gY3JvcF93aWR0aCkgLyAyO1xuICAgICAgICBsZXQgaGVpZ2h0X29mZnNldCA9ICh0aGlzLmhlaWdodCAtIGNyb3BfaGVpZ2h0KSAvIDI7XG5cblxuICAgICAgICBpZiAoQlJPV1NFUl9FTlYpIHtcbiAgICAgICAgICAgIC8vIFN0b3JlIG51bWJlciBvZiBjaGFubmVscyBiZWZvcmUgcmVzaXppbmdcbiAgICAgICAgICAgIGxldCBudW1DaGFubmVscyA9IHRoaXMuY2hhbm5lbHM7XG5cbiAgICAgICAgICAgIC8vIENyZWF0ZSBjYW52YXMgb2JqZWN0IGZvciB0aGlzIGltYWdlXG4gICAgICAgICAgICBsZXQgY2FudmFzID0gdGhpcy50b0NhbnZhcygpO1xuXG4gICAgICAgICAgICAvLyBDcmVhdGUgYSBuZXcgY2FudmFzIG9mIHRoZSBkZXNpcmVkIHNpemUuIFRoaXMgaXMgbmVlZGVkIHNpbmNlIGlmIHRoZSBcbiAgICAgICAgICAgIC8vIGltYWdlIGlzIHRvbyBzbWFsbCwgd2UgbmVlZCB0byBwYWQgaXQgd2l0aCBibGFjayBwaXhlbHMuXG4gICAgICAgICAgICBjb25zdCBjdHggPSBjcmVhdGVDYW52YXNGdW5jdGlvbihjcm9wX3dpZHRoLCBjcm9wX2hlaWdodCkuZ2V0Q29udGV4dCgnMmQnKTtcblxuICAgICAgICAgICAgbGV0IHNvdXJjZVggPSAwO1xuICAgICAgICAgICAgbGV0IHNvdXJjZVkgPSAwO1xuICAgICAgICAgICAgbGV0IGRlc3RYID0gMDtcbiAgICAgICAgICAgIGxldCBkZXN0WSA9IDA7XG5cbiAgICAgICAgICAgIGlmICh3aWR0aF9vZmZzZXQgPj0gMCkge1xuICAgICAgICAgICAgICAgIHNvdXJjZVggPSB3aWR0aF9vZmZzZXQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRlc3RYID0gLXdpZHRoX29mZnNldDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGhlaWdodF9vZmZzZXQgPj0gMCkge1xuICAgICAgICAgICAgICAgIHNvdXJjZVkgPSBoZWlnaHRfb2Zmc2V0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkZXN0WSA9IC1oZWlnaHRfb2Zmc2V0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBEcmF3IGltYWdlIHRvIGNvbnRleHQsIGNyb3BwaW5nIGluIHRoZSBwcm9jZXNzXG4gICAgICAgICAgICBjdHguZHJhd0ltYWdlKGNhbnZhcyxcbiAgICAgICAgICAgICAgICBzb3VyY2VYLCBzb3VyY2VZLCBjcm9wX3dpZHRoLCBjcm9wX2hlaWdodCxcbiAgICAgICAgICAgICAgICBkZXN0WCwgZGVzdFksIGNyb3Bfd2lkdGgsIGNyb3BfaGVpZ2h0XG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAvLyBDcmVhdGUgaW1hZ2UgZnJvbSB0aGUgcmVzaXplZCBkYXRhXG4gICAgICAgICAgICBsZXQgcmVzaXplZEltYWdlID0gbmV3IFJhd0ltYWdlKGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgY3JvcF93aWR0aCwgY3JvcF9oZWlnaHQpLmRhdGEsIGNyb3Bfd2lkdGgsIGNyb3BfaGVpZ2h0LCA0KTtcblxuICAgICAgICAgICAgLy8gQ29udmVydCBiYWNrIHNvIHRoYXQgaW1hZ2UgaGFzIHRoZSBzYW1lIG51bWJlciBvZiBjaGFubmVscyBhcyBiZWZvcmVcbiAgICAgICAgICAgIHJldHVybiByZXNpemVkSW1hZ2UuY29udmVydChudW1DaGFubmVscyk7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIENyZWF0ZSBzaGFycCBpbWFnZSBmcm9tIHJhdyBkYXRhXG4gICAgICAgICAgICBsZXQgaW1nID0gc2hhcnAodGhpcy5kYXRhLCB7XG4gICAgICAgICAgICAgICAgcmF3OiB7XG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiB0aGlzLndpZHRoLFxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IHRoaXMuaGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICBjaGFubmVsczogdGhpcy5jaGFubmVsc1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAod2lkdGhfb2Zmc2V0ID49IDAgJiYgaGVpZ2h0X29mZnNldCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gQ3JvcHBlZCBpbWFnZSBsaWVzIGVudGlyZWx5IHdpdGhpbiB0aGUgb3JpZ2luYWwgaW1hZ2VcbiAgICAgICAgICAgICAgICBpbWcgPSBpbWcuZXh0cmFjdCh7XG4gICAgICAgICAgICAgICAgICAgIGxlZnQ6IE1hdGguZmxvb3Iod2lkdGhfb2Zmc2V0KSxcbiAgICAgICAgICAgICAgICAgICAgdG9wOiBNYXRoLmZsb29yKGhlaWdodF9vZmZzZXQpLFxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogY3JvcF93aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBjcm9wX2hlaWdodCxcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSBlbHNlIGlmICh3aWR0aF9vZmZzZXQgPD0gMCAmJiBoZWlnaHRfb2Zmc2V0IDw9IDApIHtcbiAgICAgICAgICAgICAgICAvLyBDcm9wcGVkIGltYWdlIGxpZXMgZW50aXJlbHkgb3V0c2lkZSB0aGUgb3JpZ2luYWwgaW1hZ2UsXG4gICAgICAgICAgICAgICAgLy8gc28gd2UgYWRkIHBhZGRpbmdcbiAgICAgICAgICAgICAgICBsZXQgdG9wID0gTWF0aC5mbG9vcigtaGVpZ2h0X29mZnNldCk7XG4gICAgICAgICAgICAgICAgbGV0IGxlZnQgPSBNYXRoLmZsb29yKC13aWR0aF9vZmZzZXQpO1xuICAgICAgICAgICAgICAgIGltZyA9IGltZy5leHRlbmQoe1xuICAgICAgICAgICAgICAgICAgICB0b3A6IHRvcCxcbiAgICAgICAgICAgICAgICAgICAgbGVmdDogbGVmdCxcblxuICAgICAgICAgICAgICAgICAgICAvLyBFbnN1cmVzIHRoZSByZXN1bHRpbmcgaW1hZ2UgaGFzIHRoZSBkZXNpcmVkIGRpbWVuc2lvbnNcbiAgICAgICAgICAgICAgICAgICAgcmlnaHQ6IGNyb3Bfd2lkdGggLSB0aGlzLndpZHRoIC0gbGVmdCxcbiAgICAgICAgICAgICAgICAgICAgYm90dG9tOiBjcm9wX2hlaWdodCAtIHRoaXMuaGVpZ2h0IC0gdG9wLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBDcm9wcGVkIGltYWdlIGxpZXMgcGFydGlhbGx5IG91dHNpZGUgdGhlIG9yaWdpbmFsIGltYWdlLlxuICAgICAgICAgICAgICAgIC8vIFdlIGZpcnN0IHBhZCwgdGhlbiBjcm9wLlxuXG4gICAgICAgICAgICAgICAgbGV0IHlfcGFkZGluZyA9IFswLCAwXTtcbiAgICAgICAgICAgICAgICBsZXQgeV9leHRyYWN0ID0gMDtcbiAgICAgICAgICAgICAgICBpZiAoaGVpZ2h0X29mZnNldCA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgeV9wYWRkaW5nWzBdID0gTWF0aC5mbG9vcigtaGVpZ2h0X29mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgIHlfcGFkZGluZ1sxXSA9IGNyb3BfaGVpZ2h0IC0gdGhpcy5oZWlnaHQgLSB5X3BhZGRpbmdbMF07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgeV9leHRyYWN0ID0gTWF0aC5mbG9vcihoZWlnaHRfb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBsZXQgeF9wYWRkaW5nID0gWzAsIDBdO1xuICAgICAgICAgICAgICAgIGxldCB4X2V4dHJhY3QgPSAwO1xuICAgICAgICAgICAgICAgIGlmICh3aWR0aF9vZmZzZXQgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHhfcGFkZGluZ1swXSA9IE1hdGguZmxvb3IoLXdpZHRoX29mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgIHhfcGFkZGluZ1sxXSA9IGNyb3Bfd2lkdGggLSB0aGlzLndpZHRoIC0geF9wYWRkaW5nWzBdO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHhfZXh0cmFjdCA9IE1hdGguZmxvb3Iod2lkdGhfb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpbWcgPSBpbWcuZXh0ZW5kKHtcbiAgICAgICAgICAgICAgICAgICAgdG9wOiB5X3BhZGRpbmdbMF0sXG4gICAgICAgICAgICAgICAgICAgIGJvdHRvbTogeV9wYWRkaW5nWzFdLFxuICAgICAgICAgICAgICAgICAgICBsZWZ0OiB4X3BhZGRpbmdbMF0sXG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0OiB4X3BhZGRpbmdbMV0sXG4gICAgICAgICAgICAgICAgfSkuZXh0cmFjdCh7XG4gICAgICAgICAgICAgICAgICAgIGxlZnQ6IHhfZXh0cmFjdCxcbiAgICAgICAgICAgICAgICAgICAgdG9wOiB5X2V4dHJhY3QsXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiBjcm9wX3dpZHRoLFxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGNyb3BfaGVpZ2h0LFxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBhd2FpdCBsb2FkSW1hZ2VGdW5jdGlvbihpbWcpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdG9DYW52YXMoKSB7XG4gICAgICAgIC8vIENsb25lLCBhbmQgY29udmVydCBkYXRhIHRvIFJHQkEgYmVmb3JlIGRyYXdpbmcgdG8gY2FudmFzLlxuICAgICAgICAvLyBUaGlzIGlzIGJlY2F1c2UgdGhlIGNhbnZhcyBBUEkgb25seSBzdXBwb3J0cyBSR0JBXG4gICAgICAgIGxldCBjbG9uZWQgPSB0aGlzLmNsb25lKCkucmdiYSgpO1xuXG4gICAgICAgIC8vIENyZWF0ZSBjYW52YXMgb2JqZWN0IGZvciB0aGUgY2xvbmVkIGltYWdlXG4gICAgICAgIGxldCBjbG9uZWRDYW52YXMgPSBjcmVhdGVDYW52YXNGdW5jdGlvbihjbG9uZWQud2lkdGgsIGNsb25lZC5oZWlnaHQpO1xuXG4gICAgICAgIC8vIERyYXcgaW1hZ2UgdG8gY29udGV4dFxuICAgICAgICBsZXQgZGF0YSA9IG5ldyBJbWFnZURhdGFDbGFzcyhjbG9uZWQuZGF0YSwgY2xvbmVkLndpZHRoLCBjbG9uZWQuaGVpZ2h0KTtcbiAgICAgICAgY2xvbmVkQ2FudmFzLmdldENvbnRleHQoJzJkJykucHV0SW1hZ2VEYXRhKGRhdGEsIDAsIDApO1xuXG4gICAgICAgIHJldHVybiBjbG9uZWRDYW52YXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGVscGVyIG1ldGhvZCB0byB1cGRhdGUgdGhlIGltYWdlIGRhdGEuXG4gICAgICogQHBhcmFtIHtVaW50OENsYW1wZWRBcnJheX0gZGF0YSBUaGUgbmV3IGltYWdlIGRhdGEuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoIFRoZSBuZXcgd2lkdGggb2YgdGhlIGltYWdlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQgVGhlIG5ldyBoZWlnaHQgb2YgdGhlIGltYWdlLlxuICAgICAqIEBwYXJhbSB7MXwyfDN8NH0gY2hhbm5lbHMgVGhlIG5ldyBudW1iZXIgb2YgY2hhbm5lbHMgb2YgdGhlIGltYWdlLlxuICAgICAqL1xuICAgIF91cGRhdGUoZGF0YSwgd2lkdGgsIGhlaWdodCwgY2hhbm5lbHMgPSBudWxsKSB7XG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIGlmIChjaGFubmVscyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5jaGFubmVscyA9IGNoYW5uZWxzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENsb25lIHRoZSBpbWFnZVxuICAgICAqIEByZXR1cm5zIHtSYXdJbWFnZX0gVGhlIGNsb25lZCBpbWFnZVxuICAgICAqL1xuICAgIGNsb25lKCkge1xuICAgICAgICByZXR1cm4gbmV3IFJhd0ltYWdlKHRoaXMuZGF0YS5zbGljZSgpLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCwgdGhpcy5jaGFubmVscyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGVscGVyIG1ldGhvZCBmb3IgY29udmVydGluZyBpbWFnZSB0byBoYXZlIGEgY2VydGFpbiBudW1iZXIgb2YgY2hhbm5lbHNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbnVtQ2hhbm5lbHMgVGhlIG51bWJlciBvZiBjaGFubmVscy4gTXVzdCBiZSAxLCAzLCBvciA0LlxuICAgICAqIEByZXR1cm5zIHtSYXdJbWFnZX0gYHRoaXNgIHRvIHN1cHBvcnQgY2hhaW5pbmcuXG4gICAgICovXG4gICAgY29udmVydChudW1DaGFubmVscykge1xuICAgICAgICBpZiAodGhpcy5jaGFubmVscyA9PT0gbnVtQ2hhbm5lbHMpIHJldHVybiB0aGlzOyAvLyBBbHJlYWR5IGNvcnJlY3QgbnVtYmVyIG9mIGNoYW5uZWxzXG5cbiAgICAgICAgc3dpdGNoIChudW1DaGFubmVscykge1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIHRoaXMuZ3JheXNjYWxlKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgdGhpcy5yZ2IoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICB0aGlzLnJnYmEoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb252ZXJzaW9uIGZhaWxlZCBkdWUgdG8gdW5zdXBwb3J0ZWQgbnVtYmVyIG9mIGNoYW5uZWxzOiAke3RoaXMuY2hhbm5lbHN9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2F2ZSB0aGUgaW1hZ2UgdG8gdGhlIGdpdmVuIHBhdGguIFRoaXMgbWV0aG9kIGlzIG9ubHkgYXZhaWxhYmxlIGluIGVudmlyb25tZW50cyB3aXRoIGFjY2VzcyB0byB0aGUgRmlsZVN5c3RlbS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xCdWZmZXJ8VVJMfSBwYXRoIFRoZSBwYXRoIHRvIHNhdmUgdGhlIGltYWdlIHRvLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbbWltZT0naW1hZ2UvcG5nJ10gVGhlIG1pbWUgdHlwZSBvZiB0aGUgaW1hZ2UuXG4gICAgICovXG4gICAgc2F2ZShwYXRoLCBtaW1lID0gJ2ltYWdlL3BuZycpIHtcbiAgICAgICAgaWYgKCFlbnYudXNlRlMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIHNhdmUgdGhlIGltYWdlIGJlY2F1c2UgZmlsZXN5c3RlbSBpcyBkaXNhYmxlZCBpbiB0aGlzIGVudmlyb25tZW50LicpXG4gICAgICAgIH1cblxuICAgICAgICBsZXQgY2FudmFzID0gdGhpcy50b0NhbnZhcygpO1xuICAgICAgICBjb25zdCBidWZmZXIgPSBjYW52YXMudG9CdWZmZXIobWltZSk7XG4gICAgICAgIGZzLndyaXRlRmlsZVN5bmMocGF0aCwgYnVmZmVyKTtcbiAgICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@xenova/transformers/src/utils/image.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@xenova/transformers/src/utils/maths.js":
/*!**************************************************************!*\
  !*** ./node_modules/@xenova/transformers/src/utils/maths.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FFT: () => (/* binding */ FFT),\n/* harmony export */   cos_sim: () => (/* binding */ cos_sim),\n/* harmony export */   dot: () => (/* binding */ dot),\n/* harmony export */   getTopItems: () => (/* binding */ getTopItems),\n/* harmony export */   interpolate_data: () => (/* binding */ interpolate_data),\n/* harmony export */   log_softmax: () => (/* binding */ log_softmax),\n/* harmony export */   magnitude: () => (/* binding */ magnitude),\n/* harmony export */   max: () => (/* binding */ max),\n/* harmony export */   medianFilter: () => (/* binding */ medianFilter),\n/* harmony export */   min: () => (/* binding */ min),\n/* harmony export */   rfftfreq: () => (/* binding */ rfftfreq),\n/* harmony export */   round: () => (/* binding */ round),\n/* harmony export */   softmax: () => (/* binding */ softmax),\n/* harmony export */   transpose_data: () => (/* binding */ transpose_data)\n/* harmony export */ });\n\n/**\n * @file Helper module for mathematical processing. \n * \n * These functions and classes are only used internally, \n * meaning an end-user shouldn't need to access anything here.\n * \n * @module utils/maths\n */\n\n/**\n * @typedef {Int8Array | Uint8Array | Uint8ClampedArray | Int16Array | Uint16Array | Int32Array | Uint32Array | Float32Array | Float64Array} TypedArray\n * @typedef {BigInt64Array | BigUint64Array} BigTypedArray\n * @typedef {TypedArray | BigTypedArray} AnyTypedArray\n */\n\n/**\n * @param {TypedArray} input\n */\nfunction interpolate_data(input, [in_channels, in_height, in_width], [out_height, out_width], mode = 'bilinear', align_corners = false) {\n    // TODO use mode and align_corners\n\n    // Output image dimensions\n    const x_scale = out_width / in_width;\n    const y_scale = out_height / in_height;\n\n    // Output image\n    // @ts-ignore\n    const out_img = new input.constructor(out_height * out_width * in_channels);\n\n    // Pre-calculate strides\n    const inStride = in_height * in_width;\n    const outStride = out_height * out_width;\n\n    for (let i = 0; i < out_height; ++i) {\n        for (let j = 0; j < out_width; ++j) {\n            // Calculate output offset\n            const outOffset = i * out_width + j;\n\n            // Calculate input pixel coordinates\n            const x = (j + 0.5) / x_scale - 0.5;\n            const y = (i + 0.5) / y_scale - 0.5;\n\n            // Calculate the four nearest input pixels\n            // We also check if the input pixel coordinates are within the image bounds\n            let x1 = Math.floor(x);\n            let y1 = Math.floor(y);\n            const x2 = Math.min(x1 + 1, in_width - 1);\n            const y2 = Math.min(y1 + 1, in_height - 1);\n\n            x1 = Math.max(x1, 0);\n            y1 = Math.max(y1, 0);\n\n\n            // Calculate the fractional distances between the input pixel and the four nearest pixels\n            const s = x - x1;\n            const t = y - y1;\n\n            // Perform bilinear interpolation\n            const w1 = (1 - s) * (1 - t);\n            const w2 = s * (1 - t);\n            const w3 = (1 - s) * t;\n            const w4 = s * t;\n\n            // Calculate the four nearest input pixel indices\n            const yStride = y1 * in_width;\n            const xStride = y2 * in_width;\n            const idx1 = yStride + x1;\n            const idx2 = yStride + x2;\n            const idx3 = xStride + x1;\n            const idx4 = xStride + x2;\n\n            for (let k = 0; k < in_channels; ++k) {\n                // Calculate channel offset\n                const cOffset = k * inStride;\n\n                out_img[k * outStride + outOffset] =\n                    w1 * input[cOffset + idx1] +\n                    w2 * input[cOffset + idx2] +\n                    w3 * input[cOffset + idx3] +\n                    w4 * input[cOffset + idx4];\n            }\n        }\n    }\n\n    return out_img;\n}\n\n\n/**\n * Helper method to transpose a `AnyTypedArray` directly\n * @param {T} array \n * @template {AnyTypedArray} T \n * @param {number[]} dims \n * @param {number[]} axes \n * @returns {[T, number[]]} The transposed array and the new shape.\n */\nfunction transpose_data(array, dims, axes) {\n    // Calculate the new shape of the transposed array\n    // and the stride of the original array\n    const shape = new Array(axes.length);\n    const stride = new Array(axes.length);\n\n    for (let i = axes.length - 1, s = 1; i >= 0; --i) {\n        stride[i] = s;\n        shape[i] = dims[axes[i]];\n        s *= shape[i];\n    }\n\n    // Precompute inverse mapping of stride\n    const invStride = axes.map((_, i) => stride[axes.indexOf(i)]);\n\n    // Create the transposed array with the new shape\n    // @ts-ignore\n    const transposedData = new array.constructor(array.length);\n\n    // Transpose the original array to the new array\n    for (let i = 0; i < array.length; ++i) {\n        let newIndex = 0;\n        for (let j = dims.length - 1, k = i; j >= 0; --j) {\n            newIndex += (k % dims[j]) * invStride[j];\n            k = Math.floor(k / dims[j]);\n        }\n        transposedData[newIndex] = array[i];\n    }\n\n    return [transposedData, shape];\n}\n\n\n/**\n * Compute the softmax of an array of numbers.\n *\n * @param {number[]} arr The array of numbers to compute the softmax of.\n * @returns {number[]} The softmax array.\n */\nfunction softmax(arr) {\n    // Compute the maximum value in the array\n    const maxVal = max(arr)[0];\n\n    // Compute the exponentials of the array values\n    const exps = arr.map(x => Math.exp(x - maxVal));\n\n    // Compute the sum of the exponentials\n    const sumExps = exps.reduce((acc, val) => acc + val, 0);\n\n    // Compute the softmax values\n    const softmaxArr = exps.map(x => x / sumExps);\n\n    return softmaxArr;\n}\n\n/**\n * Calculates the logarithm of the softmax function for the input array.\n * @param {number[]} arr The input array to calculate the log_softmax function for.\n * @returns {any} The resulting log_softmax array.\n */\nfunction log_softmax(arr) {\n    // Compute the softmax values\n    const softmaxArr = softmax(arr);\n\n    // Apply log formula to each element\n    const logSoftmaxArr = softmaxArr.map(x => Math.log(x));\n\n    return logSoftmaxArr;\n}\n\n/**\n * Calculates the dot product of two arrays.\n * @param {number[]} arr1 The first array.\n * @param {number[]} arr2 The second array.\n * @returns {number} The dot product of arr1 and arr2.\n */\nfunction dot(arr1, arr2) {\n    return arr1.reduce((acc, val, i) => acc + val * arr2[i], 0);\n}\n\n\n/**\n * Get the top k items from an iterable, sorted by descending order\n *\n * @param {Array} items The items to be sorted\n * @param {number} [top_k=0] The number of top items to return (default: 0 = return all)\n * @returns {Array} The top k items, sorted by descending order\n */\nfunction getTopItems(items, top_k = 0) {\n    // if top == 0, return all\n\n    items = Array.from(items)\n        .map((x, i) => [i, x])            // Get indices ([index, score])\n        .sort((a, b) => b[1] - a[1])      // Sort by log probabilities\n\n    if (top_k > 0) {\n        items = items.slice(0, top_k);    // Get top k items\n    }\n\n    return items\n}\n\n/**\n * Computes the cosine similarity between two arrays.\n *\n * @param {number[]} arr1 The first array.\n * @param {number[]} arr2 The second array.\n * @returns {number} The cosine similarity between the two arrays.\n */\nfunction cos_sim(arr1, arr2) {\n    // Calculate dot product of the two arrays\n    const dotProduct = dot(arr1, arr2);\n\n    // Calculate the magnitude of the first array\n    const magnitudeA = magnitude(arr1);\n\n    // Calculate the magnitude of the second array\n    const magnitudeB = magnitude(arr2);\n\n    // Calculate the cosine similarity\n    const cosineSimilarity = dotProduct / (magnitudeA * magnitudeB);\n\n    return cosineSimilarity;\n}\n\n/**\n * Calculates the magnitude of a given array.\n * @param {number[]} arr The array to calculate the magnitude of.\n * @returns {number} The magnitude of the array.\n */\nfunction magnitude(arr) {\n    return Math.sqrt(arr.reduce((acc, val) => acc + val * val, 0));\n}\n\n\n/**\n * Returns the value and index of the minimum element in an array.\n * @param {number[]} arr array of numbers.\n * @returns {number[]} the value and index of the minimum element, of the form: [valueOfMin, indexOfMin]\n * @throws {Error} If array is empty.\n */\nfunction min(arr) {\n    if (arr.length === 0) throw Error('Array must not be empty');\n    let min = arr[0];\n    let indexOfMin = 0;\n    for (let i = 1; i < arr.length; ++i) {\n        if (arr[i] < min) {\n            min = arr[i];\n            indexOfMin = i;\n        }\n    }\n    return [min, indexOfMin];\n}\n\n\n/**\n * Returns the value and index of the maximum element in an array.\n * @param {number[]} arr array of numbers.\n * @returns {number[]} the value and index of the maximum element, of the form: [valueOfMax, indexOfMax]\n * @throws {Error} If array is empty.\n */\nfunction max(arr) {\n    if (arr.length === 0) throw Error('Array must not be empty');\n    let max = arr[0];\n    let indexOfMax = 0;\n    for (let i = 1; i < arr.length; ++i) {\n        if (arr[i] > max) {\n            max = arr[i];\n            indexOfMax = i;\n        }\n    }\n    return [max, indexOfMax];\n}\n\n/**\n * Return the Discrete Fourier Transform sample frequencies.\n * \n * Code adapted from https://github.com/numpy/numpy/blob/25908cacd19915bf3ddd659c28be28a41bd97a54/numpy/fft/helper.py#L173-L221\n * Original Python doc: https://numpy.org/doc/stable/reference/generated/numpy.fft.rfftfreq.html\n * @example\n * rfftfreq(400, 1 / 16000) // (201) [0, 40, 80, 120, 160, 200, ..., 8000]\n * @param {number} n Window length\n * @param {number} [d = 1.0] Sample spacing (inverse of the sampling rate). Defaults to 1.\n * @throws {TypeError} If n is not an integer.\n * @returns {number[]} Array of length `Math.floor(n / 2) + 1;` containing the sample frequencies.\n */\nfunction rfftfreq(n, d = 1.0) {\n    if (!Number.isInteger(n)) {\n        throw new TypeError(`n should be an integer, but ${n} given.`);\n    }\n    const val = 1.0 / (n * d);\n    const len = Math.floor(n / 2) + 1;\n    const results = new Array(len);\n    for (let i = 0; i < len; ++i) {\n        results[i] = i * val;\n    }\n    return results;\n}\n\n/**\n * FFT class provides functionality for performing Fast Fourier Transform on arrays\n * Code adapted from https://www.npmjs.com/package/fft.js\n */\nclass FFT {\n    /**\n     * @param {number} size The size of the input array. Must be a power of two and bigger than 1.\n     * @throws {Error} FFT size must be a power of two and bigger than 1.\n     */\n    constructor(size) {\n        this.size = size | 0; // convert to a 32-bit signed integer\n        if (this.size <= 1 || (this.size & (this.size - 1)) !== 0)\n            throw new Error('FFT size must be a power of two and bigger than 1');\n\n        this._csize = size << 1;\n\n        this.table = new Float32Array(this.size * 2);\n        for (let i = 0; i < this.table.length; i += 2) {\n            const angle = Math.PI * i / this.size;\n            this.table[i] = Math.cos(angle);\n            this.table[i + 1] = -Math.sin(angle);\n        }\n\n        // Find size's power of two\n        let power = 0;\n        for (let t = 1; this.size > t; t <<= 1)\n            ++power;\n\n        // Calculate initial step's width:\n        //   * If we are full radix-4, it is 2x smaller to give inital len=8\n        //   * Otherwise it is the same as `power` to give len=4\n        this._width = power % 2 === 0 ? power - 1 : power;\n\n        // Pre-compute bit-reversal patterns\n        this._bitrev = new Int32Array(1 << this._width);\n        for (let j = 0; j < this._bitrev.length; ++j) {\n            this._bitrev[j] = 0;\n            for (let shift = 0; shift < this._width; shift += 2) {\n                const revShift = this._width - shift - 2;\n                this._bitrev[j] |= ((j >>> shift) & 3) << revShift;\n            }\n        }\n    }\n\n    /**\n     * Create a complex number array with size `2 * size`\n     *\n     * @returns {Float32Array} A complex number array with size `2 * size`\n     */\n    createComplexArray() {\n        return new Float32Array(this._csize);\n    }\n\n    /**\n     * Converts a complex number representation stored in a Float32Array to an array of real numbers.\n     * \n     * @param {Float32Array} complex The complex number representation to be converted.\n     * @param {number[]} [storage] An optional array to store the result in.\n     * @returns {number[]} An array of real numbers representing the input complex number representation.\n     */\n    fromComplexArray(complex, storage) {\n        const res = storage || new Array(complex.length >>> 1);\n        for (let i = 0; i < complex.length; i += 2)\n            res[i >>> 1] = complex[i];\n        return res;\n    }\n\n    /**\n     * Convert a real-valued input array to a complex-valued output array.\n     * @param {Float32Array} input The real-valued input array.\n     * @param {Float32Array} [storage] Optional buffer to store the output array.\n     * @returns {Float32Array} The complex-valued output array.\n     */\n    toComplexArray(input, storage) {\n        const res = storage || this.createComplexArray();\n        for (let i = 0; i < res.length; i += 2) {\n            res[i] = input[i >>> 1];\n            res[i + 1] = 0;\n        }\n        return res;\n    }\n\n    /**\n     * Completes the spectrum by adding its mirrored negative frequency components.\n     * @param {Float32Array} spectrum The input spectrum.\n     * @returns {void}\n     */\n    completeSpectrum(spectrum) {\n        const size = this._csize;\n        const half = size >>> 1;\n        for (let i = 2; i < half; i += 2) {\n            spectrum[size - i] = spectrum[i];\n            spectrum[size - i + 1] = -spectrum[i + 1];\n        }\n    }\n\n    /**\n     * Performs a Fast Fourier Transform (FFT) on the given input data and stores the result in the output buffer.\n     * \n     * @param {Float32Array} out The output buffer to store the result.\n     * @param {Float32Array} data The input data to transform.\n     * \n     * @throws {Error} Input and output buffers must be different.\n     * \n     * @returns {void}\n     */\n    transform(out, data) {\n        if (out === data)\n            throw new Error('Input and output buffers must be different');\n\n        this._transform4(out, data, 1 /* DONE */);\n    }\n\n    /**\n     * Performs a real-valued forward FFT on the given input buffer and stores the result in the given output buffer.\n     * The input buffer must contain real values only, while the output buffer will contain complex values. The input and\n     * output buffers must be different.\n     *\n     * @param {Float32Array} out The output buffer.\n     * @param {Float32Array} data The input buffer containing real values.\n     *\n     * @throws {Error} If the input and output buffers are the same.\n     */\n    realTransform(out, data) {\n        if (out === data)\n            throw new Error('Input and output buffers must be different');\n\n        this._realTransform4(out, data, 1 /* DONE */);\n    }\n\n    /**\n     * Performs an inverse FFT transformation on the given `data` array, and stores the result in `out`.\n     * The `out` array must be a different buffer than the `data` array. The `out` array will contain the\n     * result of the transformation. The `data` array will not be modified.\n     * \n     * @param {Float32Array} out The output buffer for the transformed data.\n     * @param {Float32Array} data The input data to transform.\n     * @throws {Error} If `out` and `data` refer to the same buffer.\n     * @returns {void}\n     */\n    inverseTransform(out, data) {\n        if (out === data)\n            throw new Error('Input and output buffers must be different');\n\n        this._transform4(out, data, -1 /* DONE */);\n        for (let i = 0; i < out.length; ++i)\n            out[i] /= this.size;\n    }\n\n    /**\n     * Performs a radix-4 implementation of a discrete Fourier transform on a given set of data.\n     *\n     * @param {Float32Array} out The output buffer for the transformed data.\n     * @param {Float32Array} data The input buffer of data to be transformed.\n     * @param {number} inv A scaling factor to apply to the transform.\n     * @returns {void}\n     */\n    _transform4(out, data, inv) {\n        // radix-4 implementation\n\n        const size = this._csize;\n\n        // Initial step (permute and transform)\n        const width = this._width;\n        let step = 1 << width;\n        let len = (size / step) << 1;\n\n        let outOff;\n        let t;\n        let bitrev = this._bitrev;\n        if (len === 4) {\n            for (outOff = 0, t = 0; outOff < size; outOff += len, ++t) {\n                const off = bitrev[t];\n                this._singleTransform2(data, out, outOff, off, step);\n            }\n        } else {\n            // len === 8\n            for (outOff = 0, t = 0; outOff < size; outOff += len, ++t) {\n                const off = bitrev[t];\n                this._singleTransform4(data, out, outOff, off, step, inv);\n            }\n        }\n\n        // Loop through steps in decreasing order\n        for (step >>= 2; step >= 2; step >>= 2) {\n            len = (size / step) << 1;\n            let quarterLen = len >>> 2;\n\n            // Loop through offsets in the data\n            for (outOff = 0; outOff < size; outOff += len) {\n                // Full case\n                let limit = outOff + quarterLen;\n                for (let i = outOff, k = 0; i < limit; i += 2, k += step) {\n                    const A = i;\n                    const B = A + quarterLen;\n                    const C = B + quarterLen;\n                    const D = C + quarterLen;\n\n                    // Original values\n                    const Ar = out[A];\n                    const Ai = out[A + 1];\n                    const Br = out[B];\n                    const Bi = out[B + 1];\n                    const Cr = out[C];\n                    const Ci = out[C + 1];\n                    const Dr = out[D];\n                    const Di = out[D + 1];\n\n                    const tableBr = this.table[k];\n                    const tableBi = inv * this.table[k + 1];\n                    const MBr = Br * tableBr - Bi * tableBi;\n                    const MBi = Br * tableBi + Bi * tableBr;\n\n                    const tableCr = this.table[2 * k];\n                    const tableCi = inv * this.table[2 * k + 1];\n                    const MCr = Cr * tableCr - Ci * tableCi;\n                    const MCi = Cr * tableCi + Ci * tableCr;\n\n                    const tableDr = this.table[3 * k];\n                    const tableDi = inv * this.table[3 * k + 1];\n                    const MDr = Dr * tableDr - Di * tableDi;\n                    const MDi = Dr * tableDi + Di * tableDr;\n\n                    // Pre-Final values\n                    const T0r = Ar + MCr;\n                    const T0i = Ai + MCi;\n                    const T1r = Ar - MCr;\n                    const T1i = Ai - MCi;\n                    const T2r = MBr + MDr;\n                    const T2i = MBi + MDi;\n                    const T3r = inv * (MBr - MDr);\n                    const T3i = inv * (MBi - MDi);\n\n                    // Final values\n                    out[A] = T0r + T2r;\n                    out[A + 1] = T0i + T2i;\n                    out[B] = T1r + T3i;\n                    out[B + 1] = T1i - T3r;\n                    out[C] = T0r - T2r;\n                    out[C + 1] = T0i - T2i;\n                    out[D] = T1r - T3i;\n                    out[D + 1] = T1i + T3r;\n                }\n            }\n        }\n    }\n\n    /**\n     * Performs a radix-2 implementation of a discrete Fourier transform on a given set of data.\n     *\n     * @param {Float32Array} data The input buffer of data to be transformed.\n     * @param {Float32Array} out The output buffer for the transformed data.\n     * @param {number} outOff The offset at which to write the output data.\n     * @param {number} off The offset at which to begin reading the input data.\n     * @param {number} step The step size for indexing the input data.\n     * @returns {void}\n     */\n    _singleTransform2(data, out, outOff, off, step) {\n        // radix-2 implementation\n        // NOTE: Only called for len=4\n\n        const evenR = data[off];\n        const evenI = data[off + 1];\n        const oddR = data[off + step];\n        const oddI = data[off + step + 1];\n\n        out[outOff] = evenR + oddR;\n        out[outOff + 1] = evenI + oddI;\n        out[outOff + 2] = evenR - oddR;\n        out[outOff + 3] = evenI - oddI;\n    }\n\n    /**\n     * Performs radix-4 transformation on input data of length 8\n     *\n     * @param {Float32Array} data Input data array of length 8\n     * @param {Float32Array} out Output data array of length 8\n     * @param {number} outOff Index of output array to start writing from\n     * @param {number} off Index of input array to start reading from\n     * @param {number} step Step size between elements in input array\n     * @param {number} inv Scaling factor for inverse transform\n     * \n     * @returns {void}\n     */\n    _singleTransform4(data, out, outOff, off, step, inv) {\n        // radix-4\n        // NOTE: Only called for len=8\n        const step2 = step * 2;\n        const step3 = step * 3;\n\n        // Original values\n        const Ar = data[off];\n        const Ai = data[off + 1];\n        const Br = data[off + step];\n        const Bi = data[off + step + 1];\n        const Cr = data[off + step2];\n        const Ci = data[off + step2 + 1];\n        const Dr = data[off + step3];\n        const Di = data[off + step3 + 1];\n\n        // Pre-Final values\n        const T0r = Ar + Cr;\n        const T0i = Ai + Ci;\n        const T1r = Ar - Cr;\n        const T1i = Ai - Ci;\n        const T2r = Br + Dr;\n        const T2i = Bi + Di;\n        const T3r = inv * (Br - Dr);\n        const T3i = inv * (Bi - Di);\n\n        // Final values\n        out[outOff] = T0r + T2r;\n        out[outOff + 1] = T0i + T2i;\n        out[outOff + 2] = T1r + T3i;\n        out[outOff + 3] = T1i - T3r;\n        out[outOff + 4] = T0r - T2r;\n        out[outOff + 5] = T0i - T2i;\n        out[outOff + 6] = T1r - T3i;\n        out[outOff + 7] = T1i + T3r;\n    }\n\n    /**\n     * Real input radix-4 implementation\n     * @param {Float32Array} out Output array for the transformed data\n     * @param {Float32Array} data Input array of real data to be transformed\n     * @param {number} inv The scale factor used to normalize the inverse transform\n     */\n    _realTransform4(out, data, inv) {\n        // Real input radix-4 implementation\n        const size = this._csize;\n\n        // Initial step (permute and transform)\n        const width = this._width;\n        let step = 1 << width;\n        let len = (size / step) << 1;\n\n        var outOff;\n        var t;\n        var bitrev = this._bitrev;\n        if (len === 4) {\n            for (outOff = 0, t = 0; outOff < size; outOff += len, ++t) {\n                const off = bitrev[t];\n                this._singleRealTransform2(data, out, outOff, off >>> 1, step >>> 1);\n            }\n        } else {\n            // len === 8\n            for (outOff = 0, t = 0; outOff < size; outOff += len, ++t) {\n                const off = bitrev[t];\n                this._singleRealTransform4(data, out, outOff, off >>> 1, step >>> 1, inv);\n            }\n        }\n\n        // Loop through steps in decreasing order\n        for (step >>= 2; step >= 2; step >>= 2) {\n            len = (size / step) << 1;\n            const halfLen = len >>> 1;\n            const quarterLen = halfLen >>> 1;\n            const hquarterLen = quarterLen >>> 1;\n\n            // Loop through offsets in the data\n            for (outOff = 0; outOff < size; outOff += len) {\n                for (let i = 0, k = 0; i <= hquarterLen; i += 2, k += step) {\n                    const A = outOff + i;\n                    const B = A + quarterLen;\n                    const C = B + quarterLen;\n                    const D = C + quarterLen;\n\n                    // Original values\n                    const Ar = out[A];\n                    const Ai = out[A + 1];\n                    const Br = out[B];\n                    const Bi = out[B + 1];\n                    const Cr = out[C];\n                    const Ci = out[C + 1];\n                    const Dr = out[D];\n                    const Di = out[D + 1];\n\n                    const tableBr = this.table[k];\n                    const tableBi = inv * this.table[k + 1];\n                    const MBr = Br * tableBr - Bi * tableBi;\n                    const MBi = Br * tableBi + Bi * tableBr;\n\n                    const tableCr = this.table[2 * k];\n                    const tableCi = inv * this.table[2 * k + 1];\n                    const MCr = Cr * tableCr - Ci * tableCi;\n                    const MCi = Cr * tableCi + Ci * tableCr;\n\n                    const tableDr = this.table[3 * k];\n                    const tableDi = inv * this.table[3 * k + 1];\n                    const MDr = Dr * tableDr - Di * tableDi;\n                    const MDi = Dr * tableDi + Di * tableDr;\n\n                    // Pre-Final values\n                    const T0r = Ar + MCr;\n                    const T0i = Ai + MCi;\n                    const T1r = Ar - MCr;\n                    const T1i = Ai - MCi;\n                    const T2r = MBr + MDr;\n                    const T2i = MBi + MDi;\n                    const T3r = inv * (MBr - MDr);\n                    const T3i = inv * (MBi - MDi);\n\n                    // Final values\n                    out[A] = T0r + T2r;\n                    out[A + 1] = T0i + T2i;\n                    out[B] = T1r + T3i;\n                    out[B + 1] = T1i - T3r;\n\n                    // Output final middle point\n                    if (i === 0) {\n                        out[C] = T0r - T2r;\n                        out[C + 1] = T0i - T2i;\n                        continue;\n                    }\n\n                    // Do not overwrite ourselves\n                    if (i === hquarterLen)\n                        continue;\n\n                    const SA = outOff + quarterLen - i;\n                    const SB = outOff + halfLen - i;\n\n                    out[SA] = T1r + -inv * T3i;\n                    out[SA + 1] = -T1i - inv * T3r;\n                    out[SB] = T0r + -inv * T2r;\n                    out[SB + 1] = -T0i + inv * T2i;\n                }\n            }\n        }\n    }\n\n    /**\n     * Performs a single real input radix-2 transformation on the provided data\n     * \n     * @param {Float32Array} data The input data array\n     * @param {Float32Array} out The output data array\n     * @param {number} outOff The output offset\n     * @param {number} off The input offset\n     * @param {number} step The step\n     * \n     * @returns {void}\n     */\n    _singleRealTransform2(data, out, outOff, off, step) {\n        // radix-2 implementation\n        // NOTE: Only called for len=4\n\n        const evenR = data[off];\n        const oddR = data[off + step];\n\n        out[outOff] = evenR + oddR;\n        out[outOff + 1] = 0;\n        out[outOff + 2] = evenR - oddR;\n        out[outOff + 3] = 0;\n    }\n\n    /**\n     * Computes a single real-valued transform using radix-4 algorithm.\n     * This method is only called for len=8.\n     *\n     * @param {Float32Array} data The input data array.\n     * @param {Float32Array} out The output data array.\n     * @param {number} outOff The offset into the output array.\n     * @param {number} off The offset into the input array.\n     * @param {number} step The step size for the input array.\n     * @param {number} inv The value of inverse.\n     */\n    _singleRealTransform4(data, out, outOff, off, step, inv) {\n        // radix-4\n        // NOTE: Only called for len=8\n        const step2 = step * 2;\n        const step3 = step * 3;\n\n        // Original values\n        const Ar = data[off];\n        const Br = data[off + step];\n        const Cr = data[off + step2];\n        const Dr = data[off + step3];\n\n        // Pre-Final values\n        const T0r = Ar + Cr;\n        const T1r = Ar - Cr;\n        const T2r = Br + Dr;\n        const T3r = inv * (Br - Dr);\n\n        // Final values\n        out[outOff] = T0r + T2r;\n        out[outOff + 1] = 0;\n        out[outOff + 2] = T1r;\n        out[outOff + 3] = -T3r;\n        out[outOff + 4] = T0r - T2r;\n        out[outOff + 5] = 0;\n        out[outOff + 6] = T1r;\n        out[outOff + 7] = T3r;\n    }\n}\n\n/**\n * Performs median filter on the provided data. Padding is done by mirroring the data.\n * @param {AnyTypedArray} data The input array\n * @param {number} windowSize The window size\n */\nfunction medianFilter(data, windowSize) {\n\n    if (windowSize % 2 === 0 || windowSize <= 0) {\n        throw new Error('Window size must be a positive odd number');\n    }\n\n    // @ts-ignore\n    const outputArray = new data.constructor(data.length);\n\n    // @ts-ignore\n    const buffer = new data.constructor(windowSize); // Reusable array for storing values\n\n    const halfWindowSize = Math.floor(windowSize / 2);\n\n    for (let i = 0; i < data.length; ++i) {\n        let valuesIndex = 0;\n\n        for (let j = -halfWindowSize; j <= halfWindowSize; ++j) {\n            let index = i + j;\n            if (index < 0) {\n                index = Math.abs(index);\n            } else if (index >= data.length) {\n                index = 2 * (data.length - 1) - index;\n            }\n\n            buffer[valuesIndex++] = data[index];\n        }\n\n        buffer.sort();\n        outputArray[i] = buffer[halfWindowSize];\n    }\n\n    return outputArray;\n}\n\n/**\n * Helper function to round a number to a given number of decimals\n * @param {number} num The number to round\n * @param {number} decimals The number of decimals\n * @returns {number} The rounded number\n */\nfunction round(num, decimals) {\n    const pow = Math.pow(10, decimals);\n    return Math.round(num * pow) / pow;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHhlbm92YS90cmFuc2Zvcm1lcnMvc3JjL3V0aWxzL21hdGhzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLGdJQUFnSTtBQUM3SSxhQUFhLGdDQUFnQztBQUM3QyxhQUFhLDRCQUE0QjtBQUN6Qzs7QUFFQTtBQUNBLFdBQVcsWUFBWTtBQUN2QjtBQUNPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLGdCQUFnQjtBQUNwQyx3QkFBd0IsZUFBZTtBQUN2QztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNEJBQTRCLGlCQUFpQjtBQUM3QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLGNBQWMsZUFBZTtBQUM3QixXQUFXLFVBQVU7QUFDckIsV0FBVyxVQUFVO0FBQ3JCLGFBQWEsZUFBZTtBQUM1QjtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUNBQXlDLFFBQVE7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0EsNkNBQTZDLFFBQVE7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckIsYUFBYSxVQUFVO0FBQ3ZCO0FB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eGVub3ZhL3RyYW5zZm9ybWVycy9zcmMvdXRpbHMvbWF0aHMuanM/MDM3MSJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qKlxuICogQGZpbGUgSGVscGVyIG1vZHVsZSBmb3IgbWF0aGVtYXRpY2FsIHByb2Nlc3NpbmcuIFxuICogXG4gKiBUaGVzZSBmdW5jdGlvbnMgYW5kIGNsYXNzZXMgYXJlIG9ubHkgdXNlZCBpbnRlcm5hbGx5LCBcbiAqIG1lYW5pbmcgYW4gZW5kLXVzZXIgc2hvdWxkbid0IG5lZWQgdG8gYWNjZXNzIGFueXRoaW5nIGhlcmUuXG4gKiBcbiAqIEBtb2R1bGUgdXRpbHMvbWF0aHNcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtJbnQ4QXJyYXkgfCBVaW50OEFycmF5IHwgVWludDhDbGFtcGVkQXJyYXkgfCBJbnQxNkFycmF5IHwgVWludDE2QXJyYXkgfCBJbnQzMkFycmF5IHwgVWludDMyQXJyYXkgfCBGbG9hdDMyQXJyYXkgfCBGbG9hdDY0QXJyYXl9IFR5cGVkQXJyYXlcbiAqIEB0eXBlZGVmIHtCaWdJbnQ2NEFycmF5IHwgQmlnVWludDY0QXJyYXl9IEJpZ1R5cGVkQXJyYXlcbiAqIEB0eXBlZGVmIHtUeXBlZEFycmF5IHwgQmlnVHlwZWRBcnJheX0gQW55VHlwZWRBcnJheVxuICovXG5cbi8qKlxuICogQHBhcmFtIHtUeXBlZEFycmF5fSBpbnB1dFxuICovXG5leHBvcnQgZnVuY3Rpb24gaW50ZXJwb2xhdGVfZGF0YShpbnB1dCwgW2luX2NoYW5uZWxzLCBpbl9oZWlnaHQsIGluX3dpZHRoXSwgW291dF9oZWlnaHQsIG91dF93aWR0aF0sIG1vZGUgPSAnYmlsaW5lYXInLCBhbGlnbl9jb3JuZXJzID0gZmFsc2UpIHtcbiAgICAvLyBUT0RPIHVzZSBtb2RlIGFuZCBhbGlnbl9jb3JuZXJzXG5cbiAgICAvLyBPdXRwdXQgaW1hZ2UgZGltZW5zaW9uc1xuICAgIGNvbnN0IHhfc2NhbGUgPSBvdXRfd2lkdGggLyBpbl93aWR0aDtcbiAgICBjb25zdCB5X3NjYWxlID0gb3V0X2hlaWdodCAvIGluX2hlaWdodDtcblxuICAgIC8vIE91dHB1dCBpbWFnZVxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBjb25zdCBvdXRfaW1nID0gbmV3IGlucHV0LmNvbnN0cnVjdG9yKG91dF9oZWlnaHQgKiBvdXRfd2lkdGggKiBpbl9jaGFubmVscyk7XG5cbiAgICAvLyBQcmUtY2FsY3VsYXRlIHN0cmlkZXNcbiAgICBjb25zdCBpblN0cmlkZSA9IGluX2hlaWdodCAqIGluX3dpZHRoO1xuICAgIGNvbnN0IG91dFN0cmlkZSA9IG91dF9oZWlnaHQgKiBvdXRfd2lkdGg7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG91dF9oZWlnaHQ7ICsraSkge1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG91dF93aWR0aDsgKytqKSB7XG4gICAgICAgICAgICAvLyBDYWxjdWxhdGUgb3V0cHV0IG9mZnNldFxuICAgICAgICAgICAgY29uc3Qgb3V0T2Zmc2V0ID0gaSAqIG91dF93aWR0aCArIGo7XG5cbiAgICAgICAgICAgIC8vIENhbGN1bGF0ZSBpbnB1dCBwaXhlbCBjb29yZGluYXRlc1xuICAgICAgICAgICAgY29uc3QgeCA9IChqICsgMC41KSAvIHhfc2NhbGUgLSAwLjU7XG4gICAgICAgICAgICBjb25zdCB5ID0gKGkgKyAwLjUpIC8geV9zY2FsZSAtIDAuNTtcblxuICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBmb3VyIG5lYXJlc3QgaW5wdXQgcGl4ZWxzXG4gICAgICAgICAgICAvLyBXZSBhbHNvIGNoZWNrIGlmIHRoZSBpbnB1dCBwaXhlbCBjb29yZGluYXRlcyBhcmUgd2l0aGluIHRoZSBpbWFnZSBib3VuZHNcbiAgICAgICAgICAgIGxldCB4MSA9IE1hdGguZmxvb3IoeCk7XG4gICAgICAgICAgICBsZXQgeTEgPSBNYXRoLmZsb29yKHkpO1xuICAgICAgICAgICAgY29uc3QgeDIgPSBNYXRoLm1pbih4MSArIDEsIGluX3dpZHRoIC0gMSk7XG4gICAgICAgICAgICBjb25zdCB5MiA9IE1hdGgubWluKHkxICsgMSwgaW5faGVpZ2h0IC0gMSk7XG5cbiAgICAgICAgICAgIHgxID0gTWF0aC5tYXgoeDEsIDApO1xuICAgICAgICAgICAgeTEgPSBNYXRoLm1heCh5MSwgMCk7XG5cblxuICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBmcmFjdGlvbmFsIGRpc3RhbmNlcyBiZXR3ZWVuIHRoZSBpbnB1dCBwaXhlbCBhbmQgdGhlIGZvdXIgbmVhcmVzdCBwaXhlbHNcbiAgICAgICAgICAgIGNvbnN0IHMgPSB4IC0geDE7XG4gICAgICAgICAgICBjb25zdCB0ID0geSAtIHkxO1xuXG4gICAgICAgICAgICAvLyBQZXJmb3JtIGJpbGluZWFyIGludGVycG9sYXRpb25cbiAgICAgICAgICAgIGNvbnN0IHcxID0gKDEgLSBzKSAqICgxIC0gdCk7XG4gICAgICAgICAgICBjb25zdCB3MiA9IHMgKiAoMSAtIHQpO1xuICAgICAgICAgICAgY29uc3QgdzMgPSAoMSAtIHMpICogdDtcbiAgICAgICAgICAgIGNvbnN0IHc0ID0gcyAqIHQ7XG5cbiAgICAgICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgZm91ciBuZWFyZXN0IGlucHV0IHBpeGVsIGluZGljZXNcbiAgICAgICAgICAgIGNvbnN0IHlTdHJpZGUgPSB5MSAqIGluX3dpZHRoO1xuICAgICAgICAgICAgY29uc3QgeFN0cmlkZSA9IHkyICogaW5fd2lkdGg7XG4gICAgICAgICAgICBjb25zdCBpZHgxID0geVN0cmlkZSArIHgxO1xuICAgICAgICAgICAgY29uc3QgaWR4MiA9IHlTdHJpZGUgKyB4MjtcbiAgICAgICAgICAgIGNvbnN0IGlkeDMgPSB4U3RyaWRlICsgeDE7XG4gICAgICAgICAgICBjb25zdCBpZHg0ID0geFN0cmlkZSArIHgyO1xuXG4gICAgICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IGluX2NoYW5uZWxzOyArK2spIHtcbiAgICAgICAgICAgICAgICAvLyBDYWxjdWxhdGUgY2hhbm5lbCBvZmZzZXRcbiAgICAgICAgICAgICAgICBjb25zdCBjT2Zmc2V0ID0gayAqIGluU3RyaWRlO1xuXG4gICAgICAgICAgICAgICAgb3V0X2ltZ1trICogb3V0U3RyaWRlICsgb3V0T2Zmc2V0XSA9XG4gICAgICAgICAgICAgICAgICAgIHcxICogaW5wdXRbY09mZnNldCArIGlkeDFdICtcbiAgICAgICAgICAgICAgICAgICAgdzIgKiBpbnB1dFtjT2Zmc2V0ICsgaWR4Ml0gK1xuICAgICAgICAgICAgICAgICAgICB3MyAqIGlucHV0W2NPZmZzZXQgKyBpZHgzXSArXG4gICAgICAgICAgICAgICAgICAgIHc0ICogaW5wdXRbY09mZnNldCArIGlkeDRdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dF9pbWc7XG59XG5cblxuLyoqXG4gKiBIZWxwZXIgbWV0aG9kIHRvIHRyYW5zcG9zZSBhIGBBbnlUeXBlZEFycmF5YCBkaXJlY3RseVxuICogQHBhcmFtIHtUfSBhcnJheSBcbiAqIEB0ZW1wbGF0ZSB7QW55VHlwZWRBcnJheX0gVCBcbiAqIEBwYXJhbSB7bnVtYmVyW119IGRpbXMgXG4gKiBAcGFyYW0ge251bWJlcltdfSBheGVzIFxuICogQHJldHVybnMge1tULCBudW1iZXJbXV19IFRoZSB0cmFuc3Bvc2VkIGFycmF5IGFuZCB0aGUgbmV3IHNoYXBlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNwb3NlX2RhdGEoYXJyYXksIGRpbXMsIGF4ZXMpIHtcbiAgICAvLyBDYWxjdWxhdGUgdGhlIG5ldyBzaGFwZSBvZiB0aGUgdHJhbnNwb3NlZCBhcnJheVxuICAgIC8vIGFuZCB0aGUgc3RyaWRlIG9mIHRoZSBvcmlnaW5hbCBhcnJheVxuICAgIGNvbnN0IHNoYXBlID0gbmV3IEFycmF5KGF4ZXMubGVuZ3RoKTtcbiAgICBjb25zdCBzdHJpZGUgPSBuZXcgQXJyYXkoYXhlcy5sZW5ndGgpO1xuXG4gICAgZm9yIChsZXQgaSA9IGF4ZXMubGVuZ3RoIC0gMSwgcyA9IDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHN0cmlkZVtpXSA9IHM7XG4gICAgICAgIHNoYXBlW2ldID0gZGltc1theGVzW2ldXTtcbiAgICAgICAgcyAqPSBzaGFwZVtpXTtcbiAgICB9XG5cbiAgICAvLyBQcmVjb21wdXRlIGludmVyc2UgbWFwcGluZyBvZiBzdHJpZGVcbiAgICBjb25zdCBpbnZTdHJpZGUgPSBheGVzLm1hcCgoXywgaSkgPT4gc3RyaWRlW2F4ZXMuaW5kZXhPZihpKV0pO1xuXG4gICAgLy8gQ3JlYXRlIHRoZSB0cmFuc3Bvc2VkIGFycmF5IHdpdGggdGhlIG5ldyBzaGFwZVxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBjb25zdCB0cmFuc3Bvc2VkRGF0YSA9IG5ldyBhcnJheS5jb25zdHJ1Y3RvcihhcnJheS5sZW5ndGgpO1xuXG4gICAgLy8gVHJhbnNwb3NlIHRoZSBvcmlnaW5hbCBhcnJheSB0byB0aGUgbmV3IGFycmF5XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7ICsraSkge1xuICAgICAgICBsZXQgbmV3SW5kZXggPSAwO1xuICAgICAgICBmb3IgKGxldCBqID0gZGltcy5sZW5ndGggLSAxLCBrID0gaTsgaiA+PSAwOyAtLWopIHtcbiAgICAgICAgICAgIG5ld0luZGV4ICs9IChrICUgZGltc1tqXSkgKiBpbnZTdHJpZGVbal07XG4gICAgICAgICAgICBrID0gTWF0aC5mbG9vcihrIC8gZGltc1tqXSk7XG4gICAgICAgIH1cbiAgICAgICAgdHJhbnNwb3NlZERhdGFbbmV3SW5kZXhdID0gYXJyYXlbaV07XG4gICAgfVxuXG4gICAgcmV0dXJuIFt0cmFuc3Bvc2VkRGF0YSwgc2hhcGVdO1xufVxuXG5cbi8qKlxuICogQ29tcHV0ZSB0aGUgc29mdG1heCBvZiBhbiBhcnJheSBvZiBudW1iZXJzLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyW119IGFyciBUaGUgYXJyYXkgb2YgbnVtYmVycyB0byBjb21wdXRlIHRoZSBzb2Z0bWF4IG9mLlxuICogQHJldHVybnMge251bWJlcltdfSBUaGUgc29mdG1heCBhcnJheS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNvZnRtYXgoYXJyKSB7XG4gICAgLy8gQ29tcHV0ZSB0aGUgbWF4aW11bSB2YWx1ZSBpbiB0aGUgYXJyYXlcbiAgICBjb25zdCBtYXhWYWwgPSBtYXgoYXJyKVswXTtcblxuICAgIC8vIENvbXB1dGUgdGhlIGV4cG9uZW50aWFscyBvZiB0aGUgYXJyYXkgdmFsdWVzXG4gICAgY29uc3QgZXhwcyA9IGFyci5tYXAoeCA9PiBNYXRoLmV4cCh4IC0gbWF4VmFsKSk7XG5cbiAgICAvLyBDb21wdXRlIHRoZSBzdW0gb2YgdGhlIGV4cG9uZW50aWFsc1xuICAgIGNvbnN0IHN1bUV4cHMgPSBleHBzLnJlZHVjZSgoYWNjLCB2YWwpID0+IGFjYyArIHZhbCwgMCk7XG5cbiAgICAvLyBDb21wdXRlIHRoZSBzb2Z0bWF4IHZhbHVlc1xuICAgIGNvbnN0IHNvZnRtYXhBcnIgPSBleHBzLm1hcCh4ID0+IHggLyBzdW1FeHBzKTtcblxuICAgIHJldHVybiBzb2Z0bWF4QXJyO1xufVxuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGxvZ2FyaXRobSBvZiB0aGUgc29mdG1heCBmdW5jdGlvbiBmb3IgdGhlIGlucHV0IGFycmF5LlxuICogQHBhcmFtIHtudW1iZXJbXX0gYXJyIFRoZSBpbnB1dCBhcnJheSB0byBjYWxjdWxhdGUgdGhlIGxvZ19zb2Z0bWF4IGZ1bmN0aW9uIGZvci5cbiAqIEByZXR1cm5zIHthbnl9IFRoZSByZXN1bHRpbmcgbG9nX3NvZnRtYXggYXJyYXkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsb2dfc29mdG1heChhcnIpIHtcbiAgICAvLyBDb21wdXRlIHRoZSBzb2Z0bWF4IHZhbHVlc1xuICAgIGNvbnN0IHNvZnRtYXhBcnIgPSBzb2Z0bWF4KGFycik7XG5cbiAgICAvLyBBcHBseSBsb2cgZm9ybXVsYSB0byBlYWNoIGVsZW1lbnRcbiAgICBjb25zdCBsb2dTb2Z0bWF4QXJyID0gc29mdG1heEFyci5tYXAoeCA9PiBNYXRoLmxvZyh4KSk7XG5cbiAgICByZXR1cm4gbG9nU29mdG1heEFycjtcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBkb3QgcHJvZHVjdCBvZiB0d28gYXJyYXlzLlxuICogQHBhcmFtIHtudW1iZXJbXX0gYXJyMSBUaGUgZmlyc3QgYXJyYXkuXG4gKiBAcGFyYW0ge251bWJlcltdfSBhcnIyIFRoZSBzZWNvbmQgYXJyYXkuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgZG90IHByb2R1Y3Qgb2YgYXJyMSBhbmQgYXJyMi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRvdChhcnIxLCBhcnIyKSB7XG4gICAgcmV0dXJuIGFycjEucmVkdWNlKChhY2MsIHZhbCwgaSkgPT4gYWNjICsgdmFsICogYXJyMltpXSwgMCk7XG59XG5cblxuLyoqXG4gKiBHZXQgdGhlIHRvcCBrIGl0ZW1zIGZyb20gYW4gaXRlcmFibGUsIHNvcnRlZCBieSBkZXNjZW5kaW5nIG9yZGVyXG4gKlxuICogQHBhcmFtIHtBcnJheX0gaXRlbXMgVGhlIGl0ZW1zIHRvIGJlIHNvcnRlZFxuICogQHBhcmFtIHtudW1iZXJ9IFt0b3Bfaz0wXSBUaGUgbnVtYmVyIG9mIHRvcCBpdGVtcyB0byByZXR1cm4gKGRlZmF1bHQ6IDAgPSByZXR1cm4gYWxsKVxuICogQHJldHVybnMge0FycmF5fSBUaGUgdG9wIGsgaXRlbXMsIHNvcnRlZCBieSBkZXNjZW5kaW5nIG9yZGVyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRUb3BJdGVtcyhpdGVtcywgdG9wX2sgPSAwKSB7XG4gICAgLy8gaWYgdG9wID09IDAsIHJldHVybiBhbGxcblxuICAgIGl0ZW1zID0gQXJyYXkuZnJvbShpdGVtcylcbiAgICAgICAgLm1hcCgoeCwgaSkgPT4gW2ksIHhdKSAgICAgICAgICAgIC8vIEdldCBpbmRpY2VzIChbaW5kZXgsIHNjb3JlXSlcbiAgICAgICAgLnNvcnQoKGEsIGIpID0+IGJbMV0gLSBhWzFdKSAgICAgIC8vIFNvcnQgYnkgbG9nIHByb2JhYmlsaXRpZXNcblxuICAgIGlmICh0b3BfayA+IDApIHtcbiAgICAgICAgaXRlbXMgPSBpdGVtcy5zbGljZSgwLCB0b3Bfayk7ICAgIC8vIEdldCB0b3AgayBpdGVtc1xuICAgIH1cblxuICAgIHJldHVybiBpdGVtc1xufVxuXG4vKipcbiAqIENvbXB1dGVzIHRoZSBjb3NpbmUgc2ltaWxhcml0eSBiZXR3ZWVuIHR3byBhcnJheXMuXG4gKlxuICogQHBhcmFtIHtudW1iZXJbXX0gYXJyMSBUaGUgZmlyc3QgYXJyYXkuXG4gKiBAcGFyYW0ge251bWJlcltdfSBhcnIyIFRoZSBzZWNvbmQgYXJyYXkuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgY29zaW5lIHNpbWlsYXJpdHkgYmV0d2VlbiB0aGUgdHdvIGFycmF5cy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvc19zaW0oYXJyMSwgYXJyMikge1xuICAgIC8vIENhbGN1bGF0ZSBkb3QgcHJvZHVjdCBvZiB0aGUgdHdvIGFycmF5c1xuICAgIGNvbnN0IGRvdFByb2R1Y3QgPSBkb3QoYXJyMSwgYXJyMik7XG5cbiAgICAvLyBDYWxjdWxhdGUgdGhlIG1hZ25pdHVkZSBvZiB0aGUgZmlyc3QgYXJyYXlcbiAgICBjb25zdCBtYWduaXR1ZGVBID0gbWFnbml0dWRlKGFycjEpO1xuXG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBtYWduaXR1ZGUgb2YgdGhlIHNlY29uZCBhcnJheVxuICAgIGNvbnN0IG1hZ25pdHVkZUIgPSBtYWduaXR1ZGUoYXJyMik7XG5cbiAgICAvLyBDYWxjdWxhdGUgdGhlIGNvc2luZSBzaW1pbGFyaXR5XG4gICAgY29uc3QgY29zaW5lU2ltaWxhcml0eSA9IGRvdFByb2R1Y3QgLyAobWFnbml0dWRlQSAqIG1hZ25pdHVkZUIpO1xuXG4gICAgcmV0dXJuIGNvc2luZVNpbWlsYXJpdHk7XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgbWFnbml0dWRlIG9mIGEgZ2l2ZW4gYXJyYXkuXG4gKiBAcGFyYW0ge251bWJlcltdfSBhcnIgVGhlIGFycmF5IHRvIGNhbGN1bGF0ZSB0aGUgbWFnbml0dWRlIG9mLlxuICogQHJldHVybnMge251bWJlcn0gVGhlIG1hZ25pdHVkZSBvZiB0aGUgYXJyYXkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYWduaXR1ZGUoYXJyKSB7XG4gICAgcmV0dXJuIE1hdGguc3FydChhcnIucmVkdWNlKChhY2MsIHZhbCkgPT4gYWNjICsgdmFsICogdmFsLCAwKSk7XG59XG5cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSB2YWx1ZSBhbmQgaW5kZXggb2YgdGhlIG1pbmltdW0gZWxlbWVudCBpbiBhbiBhcnJheS5cbiAqIEBwYXJhbSB7bnVtYmVyW119IGFyciBhcnJheSBvZiBudW1iZXJzLlxuICogQHJldHVybnMge251bWJlcltdfSB0aGUgdmFsdWUgYW5kIGluZGV4IG9mIHRoZSBtaW5pbXVtIGVsZW1lbnQsIG9mIHRoZSBmb3JtOiBbdmFsdWVPZk1pbiwgaW5kZXhPZk1pbl1cbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiBhcnJheSBpcyBlbXB0eS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1pbihhcnIpIHtcbiAgICBpZiAoYXJyLmxlbmd0aCA9PT0gMCkgdGhyb3cgRXJyb3IoJ0FycmF5IG11c3Qgbm90IGJlIGVtcHR5Jyk7XG4gICAgbGV0IG1pbiA9IGFyclswXTtcbiAgICBsZXQgaW5kZXhPZk1pbiA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBhcnIubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaWYgKGFycltpXSA8IG1pbikge1xuICAgICAgICAgICAgbWluID0gYXJyW2ldO1xuICAgICAgICAgICAgaW5kZXhPZk1pbiA9IGk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFttaW4sIGluZGV4T2ZNaW5dO1xufVxuXG5cbi8qKlxuICogUmV0dXJucyB0aGUgdmFsdWUgYW5kIGluZGV4IG9mIHRoZSBtYXhpbXVtIGVsZW1lbnQgaW4gYW4gYXJyYXkuXG4gKiBAcGFyYW0ge251bWJlcltdfSBhcnIgYXJyYXkgb2YgbnVtYmVycy5cbiAqIEByZXR1cm5zIHtudW1iZXJbXX0gdGhlIHZhbHVlIGFuZCBpbmRleCBvZiB0aGUgbWF4aW11bSBlbGVtZW50LCBvZiB0aGUgZm9ybTogW3ZhbHVlT2ZNYXgsIGluZGV4T2ZNYXhdXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgYXJyYXkgaXMgZW1wdHkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXgoYXJyKSB7XG4gICAgaWYgKGFyci5sZW5ndGggPT09IDApIHRocm93IEVycm9yKCdBcnJheSBtdXN0IG5vdCBiZSBlbXB0eScpO1xuICAgIGxldCBtYXggPSBhcnJbMF07XG4gICAgbGV0IGluZGV4T2ZNYXggPSAwO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgYXJyLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGlmIChhcnJbaV0gPiBtYXgpIHtcbiAgICAgICAgICAgIG1heCA9IGFycltpXTtcbiAgICAgICAgICAgIGluZGV4T2ZNYXggPSBpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBbbWF4LCBpbmRleE9mTWF4XTtcbn1cblxuLyoqXG4gKiBSZXR1cm4gdGhlIERpc2NyZXRlIEZvdXJpZXIgVHJhbnNmb3JtIHNhbXBsZSBmcmVxdWVuY2llcy5cbiAqIFxuICogQ29kZSBhZGFwdGVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL251bXB5L251bXB5L2Jsb2IvMjU5MDhjYWNkMTk5MTViZjNkZGQ2NTljMjhiZTI4YTQxYmQ5N2E1NC9udW1weS9mZnQvaGVscGVyLnB5I0wxNzMtTDIyMVxuICogT3JpZ2luYWwgUHl0aG9uIGRvYzogaHR0cHM6Ly9udW1weS5vcmcvZG9jL3N0YWJsZS9yZWZlcmVuY2UvZ2VuZXJhdGVkL251bXB5LmZmdC5yZmZ0ZnJlcS5odG1sXG4gKiBAZXhhbXBsZVxuICogcmZmdGZyZXEoNDAwLCAxIC8gMTYwMDApIC8vICgyMDEpwqBbMCwgNDAsIDgwLCAxMjAsIDE2MCwgMjAwLCAuLi4sIDgwMDBdXG4gKiBAcGFyYW0ge251bWJlcn0gbiBXaW5kb3cgbGVuZ3RoXG4gKiBAcGFyYW0ge251bWJlcn0gW2QgPSAxLjBdIFNhbXBsZSBzcGFjaW5nIChpbnZlcnNlIG9mIHRoZSBzYW1wbGluZyByYXRlKS4gRGVmYXVsdHMgdG8gMS5cbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgbiBpcyBub3QgYW4gaW50ZWdlci5cbiAqIEByZXR1cm5zIHtudW1iZXJbXX0gQXJyYXkgb2YgbGVuZ3RoIGBNYXRoLmZsb29yKG4gLyAyKSArIDE7YCBjb250YWluaW5nIHRoZSBzYW1wbGUgZnJlcXVlbmNpZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZmZ0ZnJlcShuLCBkID0gMS4wKSB7XG4gICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKG4pKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYG4gc2hvdWxkIGJlIGFuIGludGVnZXIsIGJ1dCAke259IGdpdmVuLmApO1xuICAgIH1cbiAgICBjb25zdCB2YWwgPSAxLjAgLyAobiAqIGQpO1xuICAgIGNvbnN0IGxlbiA9IE1hdGguZmxvb3IobiAvIDIpICsgMTtcbiAgICBjb25zdCByZXN1bHRzID0gbmV3IEFycmF5KGxlbik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgICByZXN1bHRzW2ldID0gaSAqIHZhbDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdHM7XG59XG5cbi8qKlxuICogRkZUIGNsYXNzIHByb3ZpZGVzIGZ1bmN0aW9uYWxpdHkgZm9yIHBlcmZvcm1pbmcgRmFzdCBGb3VyaWVyIFRyYW5zZm9ybSBvbiBhcnJheXNcbiAqIENvZGUgYWRhcHRlZCBmcm9tIGh0dHBzOi8vd3d3Lm5wbWpzLmNvbS9wYWNrYWdlL2ZmdC5qc1xuICovXG5leHBvcnQgY2xhc3MgRkZUIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc2l6ZSBUaGUgc2l6ZSBvZiB0aGUgaW5wdXQgYXJyYXkuIE11c3QgYmUgYSBwb3dlciBvZiB0d28gYW5kIGJpZ2dlciB0aGFuIDEuXG4gICAgICogQHRocm93cyB7RXJyb3J9IEZGVCBzaXplIG11c3QgYmUgYSBwb3dlciBvZiB0d28gYW5kIGJpZ2dlciB0aGFuIDEuXG4gICAgICovXG4gICAgY29uc3RydWN0b3Ioc2l6ZSkge1xuICAgICAgICB0aGlzLnNpemUgPSBzaXplIHwgMDsgLy8gY29udmVydCB0byBhIDMyLWJpdCBzaWduZWQgaW50ZWdlclxuICAgICAgICBpZiAodGhpcy5zaXplIDw9IDEgfHwgKHRoaXMuc2l6ZSAmICh0aGlzLnNpemUgLSAxKSkgIT09IDApXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZGVCBzaXplIG11c3QgYmUgYSBwb3dlciBvZiB0d28gYW5kIGJpZ2dlciB0aGFuIDEnKTtcblxuICAgICAgICB0aGlzLl9jc2l6ZSA9IHNpemUgPDwgMTtcblxuICAgICAgICB0aGlzLnRhYmxlID0gbmV3IEZsb2F0MzJBcnJheSh0aGlzLnNpemUgKiAyKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnRhYmxlLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgICBjb25zdCBhbmdsZSA9IE1hdGguUEkgKiBpIC8gdGhpcy5zaXplO1xuICAgICAgICAgICAgdGhpcy50YWJsZVtpXSA9IE1hdGguY29zKGFuZ2xlKTtcbiAgICAgICAgICAgIHRoaXMudGFibGVbaSArIDFdID0gLU1hdGguc2luKGFuZ2xlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEZpbmQgc2l6ZSdzIHBvd2VyIG9mIHR3b1xuICAgICAgICBsZXQgcG93ZXIgPSAwO1xuICAgICAgICBmb3IgKGxldCB0ID0gMTsgdGhpcy5zaXplID4gdDsgdCA8PD0gMSlcbiAgICAgICAgICAgICsrcG93ZXI7XG5cbiAgICAgICAgLy8gQ2FsY3VsYXRlIGluaXRpYWwgc3RlcCdzIHdpZHRoOlxuICAgICAgICAvLyAgICogSWYgd2UgYXJlIGZ1bGwgcmFkaXgtNCwgaXQgaXMgMnggc21hbGxlciB0byBnaXZlIGluaXRhbCBsZW49OFxuICAgICAgICAvLyAgICogT3RoZXJ3aXNlIGl0IGlzIHRoZSBzYW1lIGFzIGBwb3dlcmAgdG8gZ2l2ZSBsZW49NFxuICAgICAgICB0aGlzLl93aWR0aCA9IHBvd2VyICUgMiA9PT0gMCA/IHBvd2VyIC0gMSA6IHBvd2VyO1xuXG4gICAgICAgIC8vIFByZS1jb21wdXRlIGJpdC1yZXZlcnNhbCBwYXR0ZXJuc1xuICAgICAgICB0aGlzLl9iaXRyZXYgPSBuZXcgSW50MzJBcnJheSgxIDw8IHRoaXMuX3dpZHRoKTtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB0aGlzLl9iaXRyZXYubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICAgIHRoaXMuX2JpdHJldltqXSA9IDA7XG4gICAgICAgICAgICBmb3IgKGxldCBzaGlmdCA9IDA7IHNoaWZ0IDwgdGhpcy5fd2lkdGg7IHNoaWZ0ICs9IDIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXZTaGlmdCA9IHRoaXMuX3dpZHRoIC0gc2hpZnQgLSAyO1xuICAgICAgICAgICAgICAgIHRoaXMuX2JpdHJldltqXSB8PSAoKGogPj4+IHNoaWZ0KSAmIDMpIDw8IHJldlNoaWZ0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgY29tcGxleCBudW1iZXIgYXJyYXkgd2l0aCBzaXplIGAyICogc2l6ZWBcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtGbG9hdDMyQXJyYXl9IEEgY29tcGxleCBudW1iZXIgYXJyYXkgd2l0aCBzaXplIGAyICogc2l6ZWBcbiAgICAgKi9cbiAgICBjcmVhdGVDb21wbGV4QXJyYXkoKSB7XG4gICAgICAgIHJldHVybiBuZXcgRmxvYXQzMkFycmF5KHRoaXMuX2NzaXplKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBhIGNvbXBsZXggbnVtYmVyIHJlcHJlc2VudGF0aW9uIHN0b3JlZCBpbiBhIEZsb2F0MzJBcnJheSB0byBhbiBhcnJheSBvZiByZWFsIG51bWJlcnMuXG4gICAgICogXG4gICAgICogQHBhcmFtIHtGbG9hdDMyQXJyYXl9IGNvbXBsZXggVGhlIGNvbXBsZXggbnVtYmVyIHJlcHJlc2VudGF0aW9uIHRvIGJlIGNvbnZlcnRlZC5cbiAgICAgKiBAcGFyYW0ge251bWJlcltdfSBbc3RvcmFnZV0gQW4gb3B0aW9uYWwgYXJyYXkgdG8gc3RvcmUgdGhlIHJlc3VsdCBpbi5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyW119IEFuIGFycmF5IG9mIHJlYWwgbnVtYmVycyByZXByZXNlbnRpbmcgdGhlIGlucHV0IGNvbXBsZXggbnVtYmVyIHJlcHJlc2VudGF0aW9uLlxuICAgICAqL1xuICAgIGZyb21Db21wbGV4QXJyYXkoY29tcGxleCwgc3RvcmFnZSkge1xuICAgICAgICBjb25zdCByZXMgPSBzdG9yYWdlIHx8IG5ldyBBcnJheShjb21wbGV4Lmxlbmd0aCA+Pj4gMSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29tcGxleC5sZW5ndGg7IGkgKz0gMilcbiAgICAgICAgICAgIHJlc1tpID4+PiAxXSA9IGNvbXBsZXhbaV07XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydCBhIHJlYWwtdmFsdWVkIGlucHV0IGFycmF5IHRvIGEgY29tcGxleC12YWx1ZWQgb3V0cHV0IGFycmF5LlxuICAgICAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fSBpbnB1dCBUaGUgcmVhbC12YWx1ZWQgaW5wdXQgYXJyYXkuXG4gICAgICogQHBhcmFtIHtGbG9hdDMyQXJyYXl9IFtzdG9yYWdlXSBPcHRpb25hbCBidWZmZXIgdG8gc3RvcmUgdGhlIG91dHB1dCBhcnJheS5cbiAgICAgKiBAcmV0dXJucyB7RmxvYXQzMkFycmF5fSBUaGUgY29tcGxleC12YWx1ZWQgb3V0cHV0IGFycmF5LlxuICAgICAqL1xuICAgIHRvQ29tcGxleEFycmF5KGlucHV0LCBzdG9yYWdlKSB7XG4gICAgICAgIGNvbnN0IHJlcyA9IHN0b3JhZ2UgfHwgdGhpcy5jcmVhdGVDb21wbGV4QXJyYXkoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgICAgIHJlc1tpXSA9IGlucHV0W2kgPj4+IDFdO1xuICAgICAgICAgICAgcmVzW2kgKyAxXSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb21wbGV0ZXMgdGhlIHNwZWN0cnVtIGJ5IGFkZGluZyBpdHMgbWlycm9yZWQgbmVnYXRpdmUgZnJlcXVlbmN5IGNvbXBvbmVudHMuXG4gICAgICogQHBhcmFtIHtGbG9hdDMyQXJyYXl9IHNwZWN0cnVtIFRoZSBpbnB1dCBzcGVjdHJ1bS5cbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICAgKi9cbiAgICBjb21wbGV0ZVNwZWN0cnVtKHNwZWN0cnVtKSB7XG4gICAgICAgIGNvbnN0IHNpemUgPSB0aGlzLl9jc2l6ZTtcbiAgICAgICAgY29uc3QgaGFsZiA9IHNpemUgPj4+IDE7XG4gICAgICAgIGZvciAobGV0IGkgPSAyOyBpIDwgaGFsZjsgaSArPSAyKSB7XG4gICAgICAgICAgICBzcGVjdHJ1bVtzaXplIC0gaV0gPSBzcGVjdHJ1bVtpXTtcbiAgICAgICAgICAgIHNwZWN0cnVtW3NpemUgLSBpICsgMV0gPSAtc3BlY3RydW1baSArIDFdO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGVyZm9ybXMgYSBGYXN0IEZvdXJpZXIgVHJhbnNmb3JtIChGRlQpIG9uIHRoZSBnaXZlbiBpbnB1dCBkYXRhIGFuZCBzdG9yZXMgdGhlIHJlc3VsdCBpbiB0aGUgb3V0cHV0IGJ1ZmZlci5cbiAgICAgKiBcbiAgICAgKiBAcGFyYW0ge0Zsb2F0MzJBcnJheX0gb3V0IFRoZSBvdXRwdXQgYnVmZmVyIHRvIHN0b3JlIHRoZSByZXN1bHQuXG4gICAgICogQHBhcmFtIHtGbG9hdDMyQXJyYXl9IGRhdGEgVGhlIGlucHV0IGRhdGEgdG8gdHJhbnNmb3JtLlxuICAgICAqIFxuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJbnB1dCBhbmQgb3V0cHV0IGJ1ZmZlcnMgbXVzdCBiZSBkaWZmZXJlbnQuXG4gICAgICogXG4gICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICovXG4gICAgdHJhbnNmb3JtKG91dCwgZGF0YSkge1xuICAgICAgICBpZiAob3V0ID09PSBkYXRhKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBhbmQgb3V0cHV0IGJ1ZmZlcnMgbXVzdCBiZSBkaWZmZXJlbnQnKTtcblxuICAgICAgICB0aGlzLl90cmFuc2Zvcm00KG91dCwgZGF0YSwgMSAvKiBET05FICovKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtcyBhIHJlYWwtdmFsdWVkIGZvcndhcmQgRkZUIG9uIHRoZSBnaXZlbiBpbnB1dCBidWZmZXIgYW5kIHN0b3JlcyB0aGUgcmVzdWx0IGluIHRoZSBnaXZlbiBvdXRwdXQgYnVmZmVyLlxuICAgICAqIFRoZSBpbnB1dCBidWZmZXIgbXVzdCBjb250YWluIHJlYWwgdmFsdWVzIG9ubHksIHdoaWxlIHRoZSBvdXRwdXQgYnVmZmVyIHdpbGwgY29udGFpbiBjb21wbGV4IHZhbHVlcy4gVGhlIGlucHV0IGFuZFxuICAgICAqIG91dHB1dCBidWZmZXJzIG11c3QgYmUgZGlmZmVyZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtGbG9hdDMyQXJyYXl9IG91dCBUaGUgb3V0cHV0IGJ1ZmZlci5cbiAgICAgKiBAcGFyYW0ge0Zsb2F0MzJBcnJheX0gZGF0YSBUaGUgaW5wdXQgYnVmZmVyIGNvbnRhaW5pbmcgcmVhbCB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIGlucHV0IGFuZCBvdXRwdXQgYnVmZmVycyBhcmUgdGhlIHNhbWUuXG4gICAgICovXG4gICAgcmVhbFRyYW5zZm9ybShvdXQsIGRhdGEpIHtcbiAgICAgICAgaWYgKG91dCA9PT0gZGF0YSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgYW5kIG91dHB1dCBidWZmZXJzIG11c3QgYmUgZGlmZmVyZW50Jyk7XG5cbiAgICAgICAgdGhpcy5fcmVhbFRyYW5zZm9ybTQob3V0LCBkYXRhLCAxIC8qIERPTkUgKi8pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBlcmZvcm1zIGFuIGludmVyc2UgRkZUIHRyYW5zZm9ybWF0aW9uIG9uIHRoZSBnaXZlbiBgZGF0YWAgYXJyYXksIGFuZCBzdG9yZXMgdGhlIHJlc3VsdCBpbiBgb3V0YC5cbiAgICAgKiBUaGUgYG91dGAgYXJyYXkgbXVzdCBiZSBhIGRpZmZlcmVudCBidWZmZXIgdGhhbiB0aGUgYGRhdGFgIGFycmF5LiBUaGUgYG91dGAgYXJyYXkgd2lsbCBjb250YWluIHRoZVxuICAgICAqIHJlc3VsdCBvZiB0aGUgdHJhbnNmb3JtYXRpb24uIFRoZSBgZGF0YWAgYXJyYXkgd2lsbCBub3QgYmUgbW9kaWZpZWQuXG4gICAgICogXG4gICAgICogQHBhcmFtIHtGbG9hdDMyQXJyYXl9IG91dCBUaGUgb3V0cHV0IGJ1ZmZlciBmb3IgdGhlIHRyYW5zZm9ybWVkIGRhdGEuXG4gICAgICogQHBhcmFtIHtGbG9hdDMyQXJyYXl9IGRhdGEgVGhlIGlucHV0IGRhdGEgdG8gdHJhbnNmb3JtLlxuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiBgb3V0YCBhbmQgYGRhdGFgIHJlZmVyIHRvIHRoZSBzYW1lIGJ1ZmZlci5cbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICAgKi9cbiAgICBpbnZlcnNlVHJhbnNmb3JtKG91dCwgZGF0YSkge1xuICAgICAgICBpZiAob3V0ID09PSBkYXRhKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBhbmQgb3V0cHV0IGJ1ZmZlcnMgbXVzdCBiZSBkaWZmZXJlbnQnKTtcblxuICAgICAgICB0aGlzLl90cmFuc2Zvcm00KG91dCwgZGF0YSwgLTEgLyogRE9ORSAqLyk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3V0Lmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgb3V0W2ldIC89IHRoaXMuc2l6ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtcyBhIHJhZGl4LTQgaW1wbGVtZW50YXRpb24gb2YgYSBkaXNjcmV0ZSBGb3VyaWVyIHRyYW5zZm9ybSBvbiBhIGdpdmVuIHNldCBvZiBkYXRhLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtGbG9hdDMyQXJyYXl9IG91dCBUaGUgb3V0cHV0IGJ1ZmZlciBmb3IgdGhlIHRyYW5zZm9ybWVkIGRhdGEuXG4gICAgICogQHBhcmFtIHtGbG9hdDMyQXJyYXl9IGRhdGEgVGhlIGlucHV0IGJ1ZmZlciBvZiBkYXRhIHRvIGJlIHRyYW5zZm9ybWVkLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbnYgQSBzY2FsaW5nIGZhY3RvciB0byBhcHBseSB0byB0aGUgdHJhbnNmb3JtLlxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxuICAgICAqL1xuICAgIF90cmFuc2Zvcm00KG91dCwgZGF0YSwgaW52KSB7XG4gICAgICAgIC8vIHJhZGl4LTQgaW1wbGVtZW50YXRpb25cblxuICAgICAgICBjb25zdCBzaXplID0gdGhpcy5fY3NpemU7XG5cbiAgICAgICAgLy8gSW5pdGlhbCBzdGVwIChwZXJtdXRlIGFuZCB0cmFuc2Zvcm0pXG4gICAgICAgIGNvbnN0IHdpZHRoID0gdGhpcy5fd2lkdGg7XG4gICAgICAgIGxldCBzdGVwID0gMSA8PCB3aWR0aDtcbiAgICAgICAgbGV0IGxlbiA9IChzaXplIC8gc3RlcCkgPDwgMTtcblxuICAgICAgICBsZXQgb3V0T2ZmO1xuICAgICAgICBsZXQgdDtcbiAgICAgICAgbGV0IGJpdHJldiA9IHRoaXMuX2JpdHJldjtcbiAgICAgICAgaWYgKGxlbiA9PT0gNCkge1xuICAgICAgICAgICAgZm9yIChvdXRPZmYgPSAwLCB0ID0gMDsgb3V0T2ZmIDwgc2l6ZTsgb3V0T2ZmICs9IGxlbiwgKyt0KSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb2ZmID0gYml0cmV2W3RdO1xuICAgICAgICAgICAgICAgIHRoaXMuX3NpbmdsZVRyYW5zZm9ybTIoZGF0YSwgb3V0LCBvdXRPZmYsIG9mZiwgc3RlcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBsZW4gPT09IDhcbiAgICAgICAgICAgIGZvciAob3V0T2ZmID0gMCwgdCA9IDA7IG91dE9mZiA8IHNpemU7IG91dE9mZiArPSBsZW4sICsrdCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG9mZiA9IGJpdHJldlt0XTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zaW5nbGVUcmFuc2Zvcm00KGRhdGEsIG91dCwgb3V0T2ZmLCBvZmYsIHN0ZXAsIGludik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBMb29wIHRocm91Z2ggc3RlcHMgaW4gZGVjcmVhc2luZyBvcmRlclxuICAgICAgICBmb3IgKHN0ZXAgPj49IDI7IHN0ZXAgPj0gMjsgc3RlcCA+Pj0gMikge1xuICAgICAgICAgICAgbGVuID0gKHNpemUgLyBzdGVwKSA8PCAxO1xuICAgICAgICAgICAgbGV0IHF1YXJ0ZXJMZW4gPSBsZW4gPj4+IDI7XG5cbiAgICAgICAgICAgIC8vIExvb3AgdGhyb3VnaCBvZmZzZXRzIGluIHRoZSBkYXRhXG4gICAgICAgICAgICBmb3IgKG91dE9mZiA9IDA7IG91dE9mZiA8IHNpemU7IG91dE9mZiArPSBsZW4pIHtcbiAgICAgICAgICAgICAgICAvLyBGdWxsIGNhc2VcbiAgICAgICAgICAgICAgICBsZXQgbGltaXQgPSBvdXRPZmYgKyBxdWFydGVyTGVuO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSBvdXRPZmYsIGsgPSAwOyBpIDwgbGltaXQ7IGkgKz0gMiwgayArPSBzdGVwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IEEgPSBpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBCID0gQSArIHF1YXJ0ZXJMZW47XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IEMgPSBCICsgcXVhcnRlckxlbjtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgRCA9IEMgKyBxdWFydGVyTGVuO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIE9yaWdpbmFsIHZhbHVlc1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBBciA9IG91dFtBXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgQWkgPSBvdXRbQSArIDFdO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBCciA9IG91dFtCXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgQmkgPSBvdXRbQiArIDFdO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBDciA9IG91dFtDXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgQ2kgPSBvdXRbQyArIDFdO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBEciA9IG91dFtEXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgRGkgPSBvdXRbRCArIDFdO1xuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRhYmxlQnIgPSB0aGlzLnRhYmxlW2tdO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0YWJsZUJpID0gaW52ICogdGhpcy50YWJsZVtrICsgMV07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IE1CciA9IEJyICogdGFibGVCciAtIEJpICogdGFibGVCaTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgTUJpID0gQnIgKiB0YWJsZUJpICsgQmkgKiB0YWJsZUJyO1xuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRhYmxlQ3IgPSB0aGlzLnRhYmxlWzIgKiBrXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGFibGVDaSA9IGludiAqIHRoaXMudGFibGVbMiAqIGsgKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgTUNyID0gQ3IgKiB0YWJsZUNyIC0gQ2kgKiB0YWJsZUNpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBNQ2kgPSBDciAqIHRhYmxlQ2kgKyBDaSAqIHRhYmxlQ3I7XG5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGFibGVEciA9IHRoaXMudGFibGVbMyAqIGtdO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0YWJsZURpID0gaW52ICogdGhpcy50YWJsZVszICogayArIDFdO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBNRHIgPSBEciAqIHRhYmxlRHIgLSBEaSAqIHRhYmxlRGk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IE1EaSA9IERyICogdGFibGVEaSArIERpICogdGFibGVEcjtcblxuICAgICAgICAgICAgICAgICAgICAvLyBQcmUtRmluYWwgdmFsdWVzXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IFQwciA9IEFyICsgTUNyO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBUMGkgPSBBaSArIE1DaTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgVDFyID0gQXIgLSBNQ3I7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IFQxaSA9IEFpIC0gTUNpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBUMnIgPSBNQnIgKyBNRHI7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IFQyaSA9IE1CaSArIE1EaTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgVDNyID0gaW52ICogKE1CciAtIE1Ecik7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IFQzaSA9IGludiAqIChNQmkgLSBNRGkpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIEZpbmFsIHZhbHVlc1xuICAgICAgICAgICAgICAgICAgICBvdXRbQV0gPSBUMHIgKyBUMnI7XG4gICAgICAgICAgICAgICAgICAgIG91dFtBICsgMV0gPSBUMGkgKyBUMmk7XG4gICAgICAgICAgICAgICAgICAgIG91dFtCXSA9IFQxciArIFQzaTtcbiAgICAgICAgICAgICAgICAgICAgb3V0W0IgKyAxXSA9IFQxaSAtIFQzcjtcbiAgICAgICAgICAgICAgICAgICAgb3V0W0NdID0gVDByIC0gVDJyO1xuICAgICAgICAgICAgICAgICAgICBvdXRbQyArIDFdID0gVDBpIC0gVDJpO1xuICAgICAgICAgICAgICAgICAgICBvdXRbRF0gPSBUMXIgLSBUM2k7XG4gICAgICAgICAgICAgICAgICAgIG91dFtEICsgMV0gPSBUMWkgKyBUM3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGVyZm9ybXMgYSByYWRpeC0yIGltcGxlbWVudGF0aW9uIG9mIGEgZGlzY3JldGUgRm91cmllciB0cmFuc2Zvcm0gb24gYSBnaXZlbiBzZXQgb2YgZGF0YS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fSBkYXRhIFRoZSBpbnB1dCBidWZmZXIgb2YgZGF0YSB0byBiZSB0cmFuc2Zvcm1lZC5cbiAgICAgKiBAcGFyYW0ge0Zsb2F0MzJBcnJheX0gb3V0IFRoZSBvdXRwdXQgYnVmZmVyIGZvciB0aGUgdHJhbnNmb3JtZWQgZGF0YS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb3V0T2ZmIFRoZSBvZmZzZXQgYXQgd2hpY2ggdG8gd3JpdGUgdGhlIG91dHB1dCBkYXRhLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvZmYgVGhlIG9mZnNldCBhdCB3aGljaCB0byBiZWdpbiByZWFkaW5nIHRoZSBpbnB1dCBkYXRhLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGVwIFRoZSBzdGVwIHNpemUgZm9yIGluZGV4aW5nIHRoZSBpbnB1dCBkYXRhLlxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxuICAgICAqL1xuICAgIF9zaW5nbGVUcmFuc2Zvcm0yKGRhdGEsIG91dCwgb3V0T2ZmLCBvZmYsIHN0ZXApIHtcbiAgICAgICAgLy8gcmFkaXgtMiBpbXBsZW1lbnRhdGlvblxuICAgICAgICAvLyBOT1RFOiBPbmx5IGNhbGxlZCBmb3IgbGVuPTRcblxuICAgICAgICBjb25zdCBldmVuUiA9IGRhdGFbb2ZmXTtcbiAgICAgICAgY29uc3QgZXZlbkkgPSBkYXRhW29mZiArIDFdO1xuICAgICAgICBjb25zdCBvZGRSID0gZGF0YVtvZmYgKyBzdGVwXTtcbiAgICAgICAgY29uc3Qgb2RkSSA9IGRhdGFbb2ZmICsgc3RlcCArIDFdO1xuXG4gICAgICAgIG91dFtvdXRPZmZdID0gZXZlblIgKyBvZGRSO1xuICAgICAgICBvdXRbb3V0T2ZmICsgMV0gPSBldmVuSSArIG9kZEk7XG4gICAgICAgIG91dFtvdXRPZmYgKyAyXSA9IGV2ZW5SIC0gb2RkUjtcbiAgICAgICAgb3V0W291dE9mZiArIDNdID0gZXZlbkkgLSBvZGRJO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBlcmZvcm1zIHJhZGl4LTQgdHJhbnNmb3JtYXRpb24gb24gaW5wdXQgZGF0YSBvZiBsZW5ndGggOFxuICAgICAqXG4gICAgICogQHBhcmFtIHtGbG9hdDMyQXJyYXl9IGRhdGEgSW5wdXQgZGF0YSBhcnJheSBvZiBsZW5ndGggOFxuICAgICAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fSBvdXQgT3V0cHV0IGRhdGEgYXJyYXkgb2YgbGVuZ3RoIDhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb3V0T2ZmIEluZGV4IG9mIG91dHB1dCBhcnJheSB0byBzdGFydCB3cml0aW5nIGZyb21cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb2ZmIEluZGV4IG9mIGlucHV0IGFycmF5IHRvIHN0YXJ0IHJlYWRpbmcgZnJvbVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGVwIFN0ZXAgc2l6ZSBiZXR3ZWVuIGVsZW1lbnRzIGluIGlucHV0IGFycmF5XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGludiBTY2FsaW5nIGZhY3RvciBmb3IgaW52ZXJzZSB0cmFuc2Zvcm1cbiAgICAgKiBcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICAgKi9cbiAgICBfc2luZ2xlVHJhbnNmb3JtNChkYXRhLCBvdXQsIG91dE9mZiwgb2ZmLCBzdGVwLCBpbnYpIHtcbiAgICAgICAgLy8gcmFkaXgtNFxuICAgICAgICAvLyBOT1RFOiBPbmx5IGNhbGxlZCBmb3IgbGVuPThcbiAgICAgICAgY29uc3Qgc3RlcDIgPSBzdGVwICogMjtcbiAgICAgICAgY29uc3Qgc3RlcDMgPSBzdGVwICogMztcblxuICAgICAgICAvLyBPcmlnaW5hbCB2YWx1ZXNcbiAgICAgICAgY29uc3QgQXIgPSBkYXRhW29mZl07XG4gICAgICAgIGNvbnN0IEFpID0gZGF0YVtvZmYgKyAxXTtcbiAgICAgICAgY29uc3QgQnIgPSBkYXRhW29mZiArIHN0ZXBdO1xuICAgICAgICBjb25zdCBCaSA9IGRhdGFbb2ZmICsgc3RlcCArIDFdO1xuICAgICAgICBjb25zdCBDciA9IGRhdGFbb2ZmICsgc3RlcDJdO1xuICAgICAgICBjb25zdCBDaSA9IGRhdGFbb2ZmICsgc3RlcDIgKyAxXTtcbiAgICAgICAgY29uc3QgRHIgPSBkYXRhW29mZiArIHN0ZXAzXTtcbiAgICAgICAgY29uc3QgRGkgPSBkYXRhW29mZiArIHN0ZXAzICsgMV07XG5cbiAgICAgICAgLy8gUHJlLUZpbmFsIHZhbHVlc1xuICAgICAgICBjb25zdCBUMHIgPSBBciArIENyO1xuICAgICAgICBjb25zdCBUMGkgPSBBaSArIENpO1xuICAgICAgICBjb25zdCBUMXIgPSBBciAtIENyO1xuICAgICAgICBjb25zdCBUMWkgPSBBaSAtIENpO1xuICAgICAgICBjb25zdCBUMnIgPSBCciArIERyO1xuICAgICAgICBjb25zdCBUMmkgPSBCaSArIERpO1xuICAgICAgICBjb25zdCBUM3IgPSBpbnYgKiAoQnIgLSBEcik7XG4gICAgICAgIGNvbnN0IFQzaSA9IGludiAqIChCaSAtIERpKTtcblxuICAgICAgICAvLyBGaW5hbCB2YWx1ZXNcbiAgICAgICAgb3V0W291dE9mZl0gPSBUMHIgKyBUMnI7XG4gICAgICAgIG91dFtvdXRPZmYgKyAxXSA9IFQwaSArIFQyaTtcbiAgICAgICAgb3V0W291dE9mZiArIDJdID0gVDFyICsgVDNpO1xuICAgICAgICBvdXRbb3V0T2ZmICsgM10gPSBUMWkgLSBUM3I7XG4gICAgICAgIG91dFtvdXRPZmYgKyA0XSA9IFQwciAtIFQycjtcbiAgICAgICAgb3V0W291dE9mZiArIDVdID0gVDBpIC0gVDJpO1xuICAgICAgICBvdXRbb3V0T2ZmICsgNl0gPSBUMXIgLSBUM2k7XG4gICAgICAgIG91dFtvdXRPZmYgKyA3XSA9IFQxaSArIFQzcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWFsIGlucHV0IHJhZGl4LTQgaW1wbGVtZW50YXRpb25cbiAgICAgKiBAcGFyYW0ge0Zsb2F0MzJBcnJheX0gb3V0IE91dHB1dCBhcnJheSBmb3IgdGhlIHRyYW5zZm9ybWVkIGRhdGFcbiAgICAgKiBAcGFyYW0ge0Zsb2F0MzJBcnJheX0gZGF0YSBJbnB1dCBhcnJheSBvZiByZWFsIGRhdGEgdG8gYmUgdHJhbnNmb3JtZWRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW52IFRoZSBzY2FsZSBmYWN0b3IgdXNlZCB0byBub3JtYWxpemUgdGhlIGludmVyc2UgdHJhbnNmb3JtXG4gICAgICovXG4gICAgX3JlYWxUcmFuc2Zvcm00KG91dCwgZGF0YSwgaW52KSB7XG4gICAgICAgIC8vIFJlYWwgaW5wdXQgcmFkaXgtNCBpbXBsZW1lbnRhdGlvblxuICAgICAgICBjb25zdCBzaXplID0gdGhpcy5fY3NpemU7XG5cbiAgICAgICAgLy8gSW5pdGlhbCBzdGVwIChwZXJtdXRlIGFuZCB0cmFuc2Zvcm0pXG4gICAgICAgIGNvbnN0IHdpZHRoID0gdGhpcy5fd2lkdGg7XG4gICAgICAgIGxldCBzdGVwID0gMSA8PCB3aWR0aDtcbiAgICAgICAgbGV0IGxlbiA9IChzaXplIC8gc3RlcCkgPDwgMTtcblxuICAgICAgICB2YXIgb3V0T2ZmO1xuICAgICAgICB2YXIgdDtcbiAgICAgICAgdmFyIGJpdHJldiA9IHRoaXMuX2JpdHJldjtcbiAgICAgICAgaWYgKGxlbiA9PT0gNCkge1xuICAgICAgICAgICAgZm9yIChvdXRPZmYgPSAwLCB0ID0gMDsgb3V0T2ZmIDwgc2l6ZTsgb3V0T2ZmICs9IGxlbiwgKyt0KSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb2ZmID0gYml0cmV2W3RdO1xuICAgICAgICAgICAgICAgIHRoaXMuX3NpbmdsZVJlYWxUcmFuc2Zvcm0yKGRhdGEsIG91dCwgb3V0T2ZmLCBvZmYgPj4+IDEsIHN0ZXAgPj4+IDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gbGVuID09PSA4XG4gICAgICAgICAgICBmb3IgKG91dE9mZiA9IDAsIHQgPSAwOyBvdXRPZmYgPCBzaXplOyBvdXRPZmYgKz0gbGVuLCArK3QpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvZmYgPSBiaXRyZXZbdF07XG4gICAgICAgICAgICAgICAgdGhpcy5fc2luZ2xlUmVhbFRyYW5zZm9ybTQoZGF0YSwgb3V0LCBvdXRPZmYsIG9mZiA+Pj4gMSwgc3RlcCA+Pj4gMSwgaW52KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIExvb3AgdGhyb3VnaCBzdGVwcyBpbiBkZWNyZWFzaW5nIG9yZGVyXG4gICAgICAgIGZvciAoc3RlcCA+Pj0gMjsgc3RlcCA+PSAyOyBzdGVwID4+PSAyKSB7XG4gICAgICAgICAgICBsZW4gPSAoc2l6ZSAvIHN0ZXApIDw8IDE7XG4gICAgICAgICAgICBjb25zdCBoYWxmTGVuID0gbGVuID4+PiAxO1xuICAgICAgICAgICAgY29uc3QgcXVhcnRlckxlbiA9IGhhbGZMZW4gPj4+IDE7XG4gICAgICAgICAgICBjb25zdCBocXVhcnRlckxlbiA9IHF1YXJ0ZXJMZW4gPj4+IDE7XG5cbiAgICAgICAgICAgIC8vIExvb3AgdGhyb3VnaCBvZmZzZXRzIGluIHRoZSBkYXRhXG4gICAgICAgICAgICBmb3IgKG91dE9mZiA9IDA7IG91dE9mZiA8IHNpemU7IG91dE9mZiArPSBsZW4pIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgayA9IDA7IGkgPD0gaHF1YXJ0ZXJMZW47IGkgKz0gMiwgayArPSBzdGVwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IEEgPSBvdXRPZmYgKyBpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBCID0gQSArIHF1YXJ0ZXJMZW47XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IEMgPSBCICsgcXVhcnRlckxlbjtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgRCA9IEMgKyBxdWFydGVyTGVuO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIE9yaWdpbmFsIHZhbHVlc1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBBciA9IG91dFtBXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgQWkgPSBvdXRbQSArIDFdO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBCciA9IG91dFtCXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgQmkgPSBvdXRbQiArIDFdO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBDciA9IG91dFtDXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgQ2kgPSBvdXRbQyArIDFdO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBEciA9IG91dFtEXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgRGkgPSBvdXRbRCArIDFdO1xuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRhYmxlQnIgPSB0aGlzLnRhYmxlW2tdO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0YWJsZUJpID0gaW52ICogdGhpcy50YWJsZVtrICsgMV07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IE1CciA9IEJyICogdGFibGVCciAtIEJpICogdGFibGVCaTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgTUJpID0gQnIgKiB0YWJsZUJpICsgQmkgKiB0YWJsZUJyO1xuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRhYmxlQ3IgPSB0aGlzLnRhYmxlWzIgKiBrXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGFibGVDaSA9IGludiAqIHRoaXMudGFibGVbMiAqIGsgKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgTUNyID0gQ3IgKiB0YWJsZUNyIC0gQ2kgKiB0YWJsZUNpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBNQ2kgPSBDciAqIHRhYmxlQ2kgKyBDaSAqIHRhYmxlQ3I7XG5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGFibGVEciA9IHRoaXMudGFibGVbMyAqIGtdO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0YWJsZURpID0gaW52ICogdGhpcy50YWJsZVszICogayArIDFdO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBNRHIgPSBEciAqIHRhYmxlRHIgLSBEaSAqIHRhYmxlRGk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IE1EaSA9IERyICogdGFibGVEaSArIERpICogdGFibGVEcjtcblxuICAgICAgICAgICAgICAgICAgICAvLyBQcmUtRmluYWwgdmFsdWVzXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IFQwciA9IEFyICsgTUNyO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBUMGkgPSBBaSArIE1DaTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgVDFyID0gQXIgLSBNQ3I7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IFQxaSA9IEFpIC0gTUNpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBUMnIgPSBNQnIgKyBNRHI7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IFQyaSA9IE1CaSArIE1EaTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgVDNyID0gaW52ICogKE1CciAtIE1Ecik7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IFQzaSA9IGludiAqIChNQmkgLSBNRGkpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIEZpbmFsIHZhbHVlc1xuICAgICAgICAgICAgICAgICAgICBvdXRbQV0gPSBUMHIgKyBUMnI7XG4gICAgICAgICAgICAgICAgICAgIG91dFtBICsgMV0gPSBUMGkgKyBUMmk7XG4gICAgICAgICAgICAgICAgICAgIG91dFtCXSA9IFQxciArIFQzaTtcbiAgICAgICAgICAgICAgICAgICAgb3V0W0IgKyAxXSA9IFQxaSAtIFQzcjtcblxuICAgICAgICAgICAgICAgICAgICAvLyBPdXRwdXQgZmluYWwgbWlkZGxlIHBvaW50XG4gICAgICAgICAgICAgICAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRbQ10gPSBUMHIgLSBUMnI7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRbQyArIDFdID0gVDBpIC0gVDJpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBEbyBub3Qgb3ZlcndyaXRlIG91cnNlbHZlc1xuICAgICAgICAgICAgICAgICAgICBpZiAoaSA9PT0gaHF1YXJ0ZXJMZW4pXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcblxuICAgICAgICAgICAgICAgICAgICBjb25zdCBTQSA9IG91dE9mZiArIHF1YXJ0ZXJMZW4gLSBpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBTQiA9IG91dE9mZiArIGhhbGZMZW4gLSBpO1xuXG4gICAgICAgICAgICAgICAgICAgIG91dFtTQV0gPSBUMXIgKyAtaW52ICogVDNpO1xuICAgICAgICAgICAgICAgICAgICBvdXRbU0EgKyAxXSA9IC1UMWkgLSBpbnYgKiBUM3I7XG4gICAgICAgICAgICAgICAgICAgIG91dFtTQl0gPSBUMHIgKyAtaW52ICogVDJyO1xuICAgICAgICAgICAgICAgICAgICBvdXRbU0IgKyAxXSA9IC1UMGkgKyBpbnYgKiBUMmk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGVyZm9ybXMgYSBzaW5nbGUgcmVhbCBpbnB1dCByYWRpeC0yIHRyYW5zZm9ybWF0aW9uIG9uIHRoZSBwcm92aWRlZCBkYXRhXG4gICAgICogXG4gICAgICogQHBhcmFtIHtGbG9hdDMyQXJyYXl9IGRhdGEgVGhlIGlucHV0IGRhdGEgYXJyYXlcbiAgICAgKiBAcGFyYW0ge0Zsb2F0MzJBcnJheX0gb3V0IFRoZSBvdXRwdXQgZGF0YSBhcnJheVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvdXRPZmYgVGhlIG91dHB1dCBvZmZzZXRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb2ZmIFRoZSBpbnB1dCBvZmZzZXRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RlcCBUaGUgc3RlcFxuICAgICAqIFxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxuICAgICAqL1xuICAgIF9zaW5nbGVSZWFsVHJhbnNmb3JtMihkYXRhLCBvdXQsIG91dE9mZiwgb2ZmLCBzdGVwKSB7XG4gICAgICAgIC8vIHJhZGl4LTIgaW1wbGVtZW50YXRpb25cbiAgICAgICAgLy8gTk9URTogT25seSBjYWxsZWQgZm9yIGxlbj00XG5cbiAgICAgICAgY29uc3QgZXZlblIgPSBkYXRhW29mZl07XG4gICAgICAgIGNvbnN0IG9kZFIgPSBkYXRhW29mZiArIHN0ZXBdO1xuXG4gICAgICAgIG91dFtvdXRPZmZdID0gZXZlblIgKyBvZGRSO1xuICAgICAgICBvdXRbb3V0T2ZmICsgMV0gPSAwO1xuICAgICAgICBvdXRbb3V0T2ZmICsgMl0gPSBldmVuUiAtIG9kZFI7XG4gICAgICAgIG91dFtvdXRPZmYgKyAzXSA9IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgYSBzaW5nbGUgcmVhbC12YWx1ZWQgdHJhbnNmb3JtIHVzaW5nIHJhZGl4LTQgYWxnb3JpdGhtLlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIG9ubHkgY2FsbGVkIGZvciBsZW49OC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fSBkYXRhIFRoZSBpbnB1dCBkYXRhIGFycmF5LlxuICAgICAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fSBvdXQgVGhlIG91dHB1dCBkYXRhIGFycmF5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvdXRPZmYgVGhlIG9mZnNldCBpbnRvIHRoZSBvdXRwdXQgYXJyYXkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG9mZiBUaGUgb2Zmc2V0IGludG8gdGhlIGlucHV0IGFycmF5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGVwIFRoZSBzdGVwIHNpemUgZm9yIHRoZSBpbnB1dCBhcnJheS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW52IFRoZSB2YWx1ZSBvZiBpbnZlcnNlLlxuICAgICAqL1xuICAgIF9zaW5nbGVSZWFsVHJhbnNmb3JtNChkYXRhLCBvdXQsIG91dE9mZiwgb2ZmLCBzdGVwLCBpbnYpIHtcbiAgICAgICAgLy8gcmFkaXgtNFxuICAgICAgICAvLyBOT1RFOiBPbmx5IGNhbGxlZCBmb3IgbGVuPThcbiAgICAgICAgY29uc3Qgc3RlcDIgPSBzdGVwICogMjtcbiAgICAgICAgY29uc3Qgc3RlcDMgPSBzdGVwICogMztcblxuICAgICAgICAvLyBPcmlnaW5hbCB2YWx1ZXNcbiAgICAgICAgY29uc3QgQXIgPSBkYXRhW29mZl07XG4gICAgICAgIGNvbnN0IEJyID0gZGF0YVtvZmYgKyBzdGVwXTtcbiAgICAgICAgY29uc3QgQ3IgPSBkYXRhW29mZiArIHN0ZXAyXTtcbiAgICAgICAgY29uc3QgRHIgPSBkYXRhW29mZiArIHN0ZXAzXTtcblxuICAgICAgICAvLyBQcmUtRmluYWwgdmFsdWVzXG4gICAgICAgIGNvbnN0IFQwciA9IEFyICsgQ3I7XG4gICAgICAgIGNvbnN0IFQxciA9IEFyIC0gQ3I7XG4gICAgICAgIGNvbnN0IFQyciA9IEJyICsgRHI7XG4gICAgICAgIGNvbnN0IFQzciA9IGludiAqIChCciAtIERyKTtcblxuICAgICAgICAvLyBGaW5hbCB2YWx1ZXNcbiAgICAgICAgb3V0W291dE9mZl0gPSBUMHIgKyBUMnI7XG4gICAgICAgIG91dFtvdXRPZmYgKyAxXSA9IDA7XG4gICAgICAgIG91dFtvdXRPZmYgKyAyXSA9IFQxcjtcbiAgICAgICAgb3V0W291dE9mZiArIDNdID0gLVQzcjtcbiAgICAgICAgb3V0W291dE9mZiArIDRdID0gVDByIC0gVDJyO1xuICAgICAgICBvdXRbb3V0T2ZmICsgNV0gPSAwO1xuICAgICAgICBvdXRbb3V0T2ZmICsgNl0gPSBUMXI7XG4gICAgICAgIG91dFtvdXRPZmYgKyA3XSA9IFQzcjtcbiAgICB9XG59XG5cbi8qKlxuICogUGVyZm9ybXMgbWVkaWFuIGZpbHRlciBvbiB0aGUgcHJvdmlkZWQgZGF0YS4gUGFkZGluZyBpcyBkb25lIGJ5IG1pcnJvcmluZyB0aGUgZGF0YS5cbiAqIEBwYXJhbSB7QW55VHlwZWRBcnJheX0gZGF0YSBUaGUgaW5wdXQgYXJyYXlcbiAqIEBwYXJhbSB7bnVtYmVyfSB3aW5kb3dTaXplIFRoZSB3aW5kb3cgc2l6ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gbWVkaWFuRmlsdGVyKGRhdGEsIHdpbmRvd1NpemUpIHtcblxuICAgIGlmICh3aW5kb3dTaXplICUgMiA9PT0gMCB8fCB3aW5kb3dTaXplIDw9IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdXaW5kb3cgc2l6ZSBtdXN0IGJlIGEgcG9zaXRpdmUgb2RkIG51bWJlcicpO1xuICAgIH1cblxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBjb25zdCBvdXRwdXRBcnJheSA9IG5ldyBkYXRhLmNvbnN0cnVjdG9yKGRhdGEubGVuZ3RoKTtcblxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBjb25zdCBidWZmZXIgPSBuZXcgZGF0YS5jb25zdHJ1Y3Rvcih3aW5kb3dTaXplKTsgLy8gUmV1c2FibGUgYXJyYXkgZm9yIHN0b3JpbmcgdmFsdWVzXG5cbiAgICBjb25zdCBoYWxmV2luZG93U2l6ZSA9IE1hdGguZmxvb3Iod2luZG93U2l6ZSAvIDIpO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGxldCB2YWx1ZXNJbmRleCA9IDA7XG5cbiAgICAgICAgZm9yIChsZXQgaiA9IC1oYWxmV2luZG93U2l6ZTsgaiA8PSBoYWxmV2luZG93U2l6ZTsgKytqKSB7XG4gICAgICAgICAgICBsZXQgaW5kZXggPSBpICsgajtcbiAgICAgICAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IE1hdGguYWJzKGluZGV4KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaW5kZXggPj0gZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IDIgKiAoZGF0YS5sZW5ndGggLSAxKSAtIGluZGV4O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBidWZmZXJbdmFsdWVzSW5kZXgrK10gPSBkYXRhW2luZGV4XTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJ1ZmZlci5zb3J0KCk7XG4gICAgICAgIG91dHB1dEFycmF5W2ldID0gYnVmZmVyW2hhbGZXaW5kb3dTaXplXTtcbiAgICB9XG5cbiAgICByZXR1cm4gb3V0cHV0QXJyYXk7XG59XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRvIHJvdW5kIGEgbnVtYmVyIHRvIGEgZ2l2ZW4gbnVtYmVyIG9mIGRlY2ltYWxzXG4gKiBAcGFyYW0ge251bWJlcn0gbnVtIFRoZSBudW1iZXIgdG8gcm91bmRcbiAqIEBwYXJhbSB7bnVtYmVyfSBkZWNpbWFscyBUaGUgbnVtYmVyIG9mIGRlY2ltYWxzXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgcm91bmRlZCBudW1iZXJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJvdW5kKG51bSwgZGVjaW1hbHMpIHtcbiAgICBjb25zdCBwb3cgPSBNYXRoLnBvdygxMCwgZGVjaW1hbHMpO1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG51bSAqIHBvdykgLyBwb3c7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@xenova/transformers/src/utils/maths.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@xenova/transformers/src/utils/tensor.js":
/*!***************************************************************!*\
  !*** ./node_modules/@xenova/transformers/src/utils/tensor.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Tensor: () => (/* binding */ Tensor),\n/* harmony export */   cat: () => (/* binding */ cat),\n/* harmony export */   dynamicTimeWarping: () => (/* binding */ dynamicTimeWarping),\n/* harmony export */   interpolate: () => (/* binding */ interpolate),\n/* harmony export */   mean: () => (/* binding */ mean),\n/* harmony export */   mean_pooling: () => (/* binding */ mean_pooling),\n/* harmony export */   stack: () => (/* binding */ stack),\n/* harmony export */   std_mean: () => (/* binding */ std_mean),\n/* harmony export */   transpose: () => (/* binding */ transpose)\n/* harmony export */ });\n/* harmony import */ var _backends_onnx_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../backends/onnx.js */ \"(ssr)/./node_modules/@xenova/transformers/src/backends/onnx.js\");\n/* harmony import */ var _maths_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./maths.js */ \"(ssr)/./node_modules/@xenova/transformers/src/utils/maths.js\");\n/**\n * @file Helper module for `Tensor` processing.\n * \n * These functions and classes are only used internally, \n * meaning an end-user shouldn't need to access anything here.\n * \n * @module utils/tensor\n */\n\n\n\n\n\n\n/**\n * @typedef {import('./maths.js').AnyTypedArray} AnyTypedArray\n */\n\n/** @type {Object} */\nconst ONNXTensor = _backends_onnx_js__WEBPACK_IMPORTED_MODULE_0__.ONNX.Tensor;\n\nclass Tensor extends ONNXTensor {\n    /**\n     * Create a new Tensor or copy an existing Tensor.\n     * @param {[string, Array|AnyTypedArray, number[]]|[ONNXTensor]} args\n     */\n    constructor(...args) {\n        if (args[0] instanceof _backends_onnx_js__WEBPACK_IMPORTED_MODULE_0__.ONNX.Tensor) {\n            // Create shallow copy\n            super(args[0].type, args[0].data, args[0].dims);\n\n        } else {\n            // Create new\n            super(...args);\n        }\n\n        return new Proxy(this, {\n            get: (obj, key) => {\n                if (typeof key === 'string') {\n                    let index = Number(key);\n                    if (Number.isInteger(index)) {\n                        // key is an integer (i.e., index)\n                        return obj._getitem(index);\n                    }\n                }\n                // @ts-ignore\n                return obj[key];\n            },\n            set: (obj, key, value) => {\n                // TODO allow setting of data\n\n                // @ts-ignore\n                return obj[key] = value;\n            }\n        });\n    }\n\n    /**\n     * Returns an iterator object for iterating over the tensor data in row-major order.\n     * If the tensor has more than one dimension, the iterator will yield subarrays.\n     * @returns {Iterator} An iterator object for iterating over the tensor data in row-major order.\n     */\n    *[Symbol.iterator]() {\n        const [iterLength, ...iterDims] = this.dims;\n\n        if (iterDims.length > 0) {\n            const iterSize = iterDims.reduce((a, b) => a * b);\n            for (let i = 0; i < iterLength; ++i) {\n                yield this._subarray(i, iterSize, iterDims);\n            }\n        } else {\n            yield* this.data\n        }\n\n    }\n\n    /**\n     * Index into a Tensor object.\n     * @param {number} index The index to access.\n     * @returns {Tensor} The data at the specified index.\n     */\n    _getitem(index) {\n        const [iterLength, ...iterDims] = this.dims;\n\n        index = safeIndex(index, iterLength);\n\n        if (iterDims.length > 0) {\n            const iterSize = iterDims.reduce((a, b) => a * b);\n            return this._subarray(index, iterSize, iterDims);\n        } else {\n            return new Tensor(this.type, [this.data[index]], iterDims);\n        }\n    }\n\n    /**\n     * @param {number|bigint} item The item to search for in the tensor\n     * @returns {number} The index of the first occurrence of item in the tensor data.\n     */\n    indexOf(item) {\n        for (let index = 0; index < this.data.length; ++index) {\n            // Note: == instead of === so we can match Ints with BigInts\n            if (this.data[index] == item) {\n                return index;\n            }\n        }\n        return -1;\n    }\n\n    /**\n     * @param {number} index \n     * @param {number} iterSize \n     * @param {any} iterDims \n     * @returns {Tensor}\n     */\n    _subarray(index, iterSize, iterDims) {\n        let data = this.data.subarray(index * iterSize, (index + 1) * iterSize);\n        return new Tensor(this.type, data, iterDims);\n    }\n\n    /**\n     * Returns the value of this tensor as a standard JavaScript Number. This only works\n     * for tensors with one element. For other cases, see `Tensor.tolist()`.\n     * @returns {number} The value of this tensor as a standard JavaScript Number.\n     * @throws {Error} If the tensor has more than one element.\n     */\n    item() {\n        if (this.data.length !== 1) {\n            throw new Error(`a Tensor with ${this.data.length} elements cannot be converted to Scalar`);\n        }\n        return this.data[0];\n    }\n\n    /**\n     * Convert tensor data to a n-dimensional JS list\n     * @returns {Array}\n     */\n    tolist() {\n        return reshape(this.data, this.dims)\n    }\n\n    /**\n     * Return a new Tensor with the sigmoid function applied to each element.\n     * @returns {Tensor} The tensor with the sigmoid function applied.\n     */\n    sigmoid() {\n        return this.clone().sigmoid_();\n    }\n\n    /**\n     * Applies the sigmoid function to the tensor in place.\n     * @returns {Tensor} Returns `this`.\n     */\n    sigmoid_() {\n        for (let i = 0; i < this.data.length; ++i) {\n            this.data[i] = 1 / (1 + Math.exp(-this.data[i]));\n        }\n        return this;\n    }\n\n    clone() {\n        return new Tensor(this.type, this.data.slice(), this.dims.slice());\n    }\n\n    slice(...slices) {\n        // This allows for slicing with ranges and numbers\n        let newTensorDims = [];\n        let newOffsets = [];\n\n        // slices is an array of numbers or arrays of numbers\n        // e.g., slices = [0, [1, 3], null, [0, 3]]\n        for (let sliceIndex = 0; sliceIndex < this.dims.length; ++sliceIndex) {\n            let slice = slices[sliceIndex];\n\n            if (slice === null || slice === undefined) {\n                // null or undefined means take the whole dimension\n                newOffsets.push([0, this.dims[sliceIndex]]);\n                newTensorDims.push(this.dims[sliceIndex]);\n\n            } else if (typeof slice === 'number') {\n                slice = safeIndex(slice, this.dims[sliceIndex], sliceIndex);\n\n                // A number means take a single element\n                newOffsets.push([slice, slice + 1]);\n\n            } else if (Array.isArray(slice) && slice.length === 2) {\n                // An array of length 2 means take a range of elements\n\n                if (slice[0] > slice[1]) {\n                    throw new Error(`Invalid slice: ${slice}`);\n                }\n\n                let offsets = [\n                    Math.max(slice[0], 0),\n                    Math.min(slice[1], this.dims[sliceIndex])\n                ];\n\n                newOffsets.push(offsets);\n                newTensorDims.push(offsets[1] - offsets[0]);\n\n            } else {\n                throw new Error(`Invalid slice: ${slice}`);\n            }\n        }\n\n        let newDims = newOffsets.map(([start, end]) => end - start);\n        let newBufferSize = newDims.reduce((a, b) => a * b);\n\n        // Allocate memory\n        let data = new this.data.constructor(newBufferSize);\n\n        // Precompute strides\n        const stride = this.stride();\n\n        for (let i = 0; i < newBufferSize; ++i) {\n            let originalIndex = 0;\n            for (let j = newDims.length - 1, num = i; j >= 0; --j) {\n                const size = newDims[j];\n                originalIndex += ((num % size) + newOffsets[j][0]) * stride[j];\n                num = Math.floor(num / size);\n            }\n            data[i] = this.data[originalIndex];\n        }\n        return new Tensor(this.type, data, newTensorDims);\n\n    }\n\n    /**\n     * Return a transposed version of this Tensor, according to the provided dimensions.\n     * @param  {...number} dims Dimensions to transpose.\n     * @returns {Tensor} The transposed tensor.\n     */\n    transpose(...dims) {\n        return transpose(this, dims);\n    }\n\n    // TODO: rename transpose to permute\n    // TODO: implement transpose\n\n    // TODO add .max() and .min() methods\n\n    /**\n     * Returns the sum of each row of the input tensor in the given dimension dim.\n     * \n     * @param {number} [dim=null] The dimension or dimensions to reduce. If `null`, all dimensions are reduced.\n     * @param {boolean} keepdim Whether the output tensor has `dim` retained or not.\n     * @returns The summed tensor\n     */\n    sum(dim = null, keepdim = false) {\n        return this.norm(1, dim, keepdim);\n    }\n\n    /**\n     * Returns the matrix norm or vector norm of a given tensor.\n     * @param {number|string} [p='fro'] The order of norm\n     * @param {number} [dim=null] Specifies which dimension of the tensor to calculate the norm across.\n     * If dim is None, the norm will be calculated across all dimensions of input.\n     * @param {boolean} [keepdim=false] Whether the output tensors have dim retained or not.\n     * @returns {Tensor} The norm of the tensor.\n     */\n    norm(p = 'fro', dim = null, keepdim = false) {\n        if (p === 'fro') {\n            // NOTE: Since we only support integer dims, Frobenius norm produces the same result as p=2.\n            p = 2;\n        } else if (typeof p === 'string') {\n            throw Error(`Unsupported norm: ${p}`);\n        }\n\n        if (dim === null) {\n            // @ts-ignore\n            let val = this.data.reduce((a, b) => a + (b ** p), 0) ** (1 / p);\n            return new Tensor(this.type, [val], []);\n        }\n\n        // Negative indexing\n        dim = safeIndex(dim, this.dims.length);\n\n        // Calculate the shape of the resulting array after summation\n        const resultDims = this.dims.slice(); // Copy the original dimensions\n        resultDims[dim] = 1; // Remove the specified axis\n\n        // Create a new array to store the accumulated values\n        const result = new this.data.constructor(this.data.length / this.dims[dim]);\n\n        // Iterate over the data array\n        for (let i = 0; i < this.data.length; ++i) {\n\n            // Calculate the index in the resulting array\n            let resultIndex = 0;\n\n            for (let j = this.dims.length - 1, num = i, resultMultiplier = 1; j >= 0; --j) {\n                const size = this.dims[j];\n                if (j !== dim) {\n                    const index = num % size;\n                    resultIndex += index * resultMultiplier;\n                    resultMultiplier *= resultDims[j];\n                }\n                num = Math.floor(num / size);\n            }\n\n            // Accumulate the value at the current index\n            result[resultIndex] += (this.data[i]) ** p;\n        }\n\n        if (p !== 1) {\n            for (let i = 0; i < result.length; ++i) {\n                result[i] = result[i] ** (1 / p);\n            }\n        }\n\n        if (!keepdim) {\n            resultDims.splice(dim, 1);\n        }\n\n        return new Tensor(this.type, result, resultDims);\n    }\n\n    /**\n     * Performs `L_p` normalization of inputs over specified dimension. Operates in place.\n     * @param {number} [p=2] The exponent value in the norm formulation\n     * @param {number} [dim=1] The dimension to reduce\n     * @returns {Tensor} `this` for operation chaining.\n     */\n    normalize_(p = 2.0, dim = 1) {\n        dim = safeIndex(dim, this.dims.length);\n\n        const norm = this.norm(p, dim, true);\n\n        for (let i = 0; i < this.data.length; ++i) {\n\n            // Calculate the index in the resulting array\n            let resultIndex = 0;\n\n            for (let j = this.dims.length - 1, num = i, resultMultiplier = 1; j >= 0; --j) {\n                const size = this.dims[j];\n                if (j !== dim) {\n                    const index = num % size;\n                    resultIndex += index * resultMultiplier;\n                    resultMultiplier *= this.dims[j];\n                }\n                num = Math.floor(num / size);\n            }\n\n            // Divide by normalized value\n            this.data[i] /= norm.data[resultIndex];\n        }\n\n        return this;\n    }\n\n    /**\n     * Performs `L_p` normalization of inputs over specified dimension.\n     * @param {number} [p=2] The exponent value in the norm formulation\n     * @param {number} [dim=1] The dimension to reduce\n     * @returns {Tensor} The normalized tensor.\n     */\n    normalize(p = 2.0, dim = 1) {\n        return this.clone().normalize_(p, dim);\n    }\n\n    /**\n     * Compute and return the stride of this tensor.\n     * Stride is the jump necessary to go from one element to the next one in the specified dimension dim.\n     * @returns {number[]} The stride of this tensor.\n     */\n    stride() {\n        return dimsToStride(this.dims);\n    }\n\n    /**\n     * Returns a tensor with all specified dimensions of input of size 1 removed.\n     * \n     * NOTE: The returned tensor shares the storage with the input tensor, so changing the contents of one will change the contents of the other.\n     * If you would like a copy, use `tensor.clone()` before squeezing.\n     * \n     * @param {number} [dim=null] If given, the input will be squeezed only in the specified dimensions.\n     * @returns The squeezed tensor\n     */\n    squeeze(dim = null) {\n        return new Tensor(\n            this.type,\n            this.data,\n            calc_squeeze_dims(this.dims, dim)\n        )\n    }\n\n    /**\n     * In-place version of @see {@link Tensor.squeeze}\n     */\n    squeeze_(dim = null) {\n        this.dims = calc_squeeze_dims(this.dims, dim);\n        return this;\n    }\n\n    /**\n     * Returns a new tensor with a dimension of size one inserted at the specified position.\n     * \n     * NOTE: The returned tensor shares the same underlying data with this tensor.\n     * \n     * @param {number} dim The index at which to insert the singleton dimension\n     * @returns The unsqueezed tensor\n     */\n    unsqueeze(dim = null) {\n        return new Tensor(\n            this.type,\n            this.data,\n            calc_unsqueeze_dims(this.dims, dim)\n        );\n    }\n\n    /**\n     * In-place version of @see {@link Tensor.unsqueeze}\n     */\n    unsqueeze_(dim = null) {\n        this.dims = calc_unsqueeze_dims(this.dims, dim);\n        return this;\n    }\n\n    /**\n     * In-place version of @see {@link Tensor.flatten}\n     */\n    flatten_(start_dim = 0, end_dim = -1) {\n        // TODO validate inputs\n        end_dim = (end_dim + this.dims.length) % this.dims.length;\n\n        let dimsToKeepBefore = this.dims.slice(0, start_dim);\n        let dimsToFlatten = this.dims.slice(start_dim, end_dim + 1);\n        let dimsToKeepAfter = this.dims.slice(end_dim + 1);\n\n        this.dims = [...dimsToKeepBefore, dimsToFlatten.reduce((a, b) => a * b, 1), ...dimsToKeepAfter]\n        return this;\n    }\n\n    /**\n     * Flattens input by reshaping it into a one-dimensional tensor.\n     * If `start_dim` or `end_dim` are passed, only dimensions starting with `start_dim`\n     * and ending with `end_dim` are flattened. The order of elements in input is unchanged.\n     * @param {number} start_dim the first dim to flatten\n     * @param {number} end_dim the last dim to flatten\n     * @returns The flattened tensor.\n     */\n    flatten(start_dim = 0, end_dim = -1) {\n        return this.clone().flatten_(start_dim, end_dim);\n    }\n\n    /**\n     * Returns a new tensor with the same data as the `self` tensor but of a different `shape`.\n     * @param  {...number} dims the desired size\n     * @returns {Tensor} The tensor with the same data but different shape\n     */\n    view(...dims) {\n        // TODO: validate dims\n        let inferredIndex = -1;\n        for (let i = 0; i < dims.length; ++i) {\n            if (dims[i] === -1) {\n                if (inferredIndex !== -1) {\n                    throw new Error(\"Only one dimension can be inferred\");\n                }\n                inferredIndex = i;\n            }\n        }\n\n        if (inferredIndex !== -1) {\n            // Some dimension must be inferred\n            const productOther = dims.reduce((product, curr, index) => {\n                return index !== inferredIndex ? product * curr : product\n            }, 1);\n\n            dims[inferredIndex] = this.data.length / productOther;\n        }\n        return new Tensor(this.type, this.data, dims); // NOTE: uses same underlying storage\n    }\n\n    neg_() {\n        for (let i = 0; i < this.data.length; ++i) {\n            this.data[i] = -this.data[i];\n        }\n        return this;\n    }\n    neg() {\n        return this.clone().neg_();\n    }\n}\n\n/**\n * This creates a nested array of a given type and depth (see examples).\n * \n * @example\n *   NestArray<string, 1>; // string[]\n * @example\n *   NestArray<number, 2>; // number[][]\n * @example\n *   NestArray<string, 3>; // string[][][] etc.\n * @template T\n * @template {number} Depth\n * @template {never[]} [Acc=[]]\n * @typedef {Acc['length'] extends Depth ? T : NestArray<T[], Depth, [...Acc, never]>} NestArray\n */\n\n/**\n * Reshapes a 1-dimensional array into an n-dimensional array, according to the provided dimensions.\n *\n * @example\n *   reshape([10                    ], [1      ]); // Type: number[]      Value: [10]\n *   reshape([1, 2, 3, 4            ], [2, 2   ]); // Type: number[][]    Value: [[1, 2], [3, 4]]\n *   reshape([1, 2, 3, 4, 5, 6, 7, 8], [2, 2, 2]); // Type: number[][][]  Value: [[[1, 2], [3, 4]], [[5, 6], [7, 8]]]\n *   reshape([1, 2, 3, 4, 5, 6, 7, 8], [4, 2   ]); // Type: number[][]    Value: [[1, 2], [3, 4], [5, 6], [7, 8]]\n * @param {T[]} data The input array to reshape.\n * @param {DIM} dimensions The target shape/dimensions.\n * @template T\n * @template {[number]|[number, number]|[number, number, number]|[number, number, number, number]} DIM\n * @returns {NestArray<T, DIM[\"length\"]>} The reshaped array.\n */\nfunction reshape(data, dimensions) {\n\n    const totalElements = data.length;\n    const dimensionSize = dimensions.reduce((a, b) => a * b);\n\n    if (totalElements !== dimensionSize) {\n        throw Error(`cannot reshape array of size ${totalElements} into shape (${dimensions})`);\n    }\n\n    /** @type {any} */\n    let reshapedArray = data;\n\n    for (let i = dimensions.length - 1; i >= 0; i--) {\n        reshapedArray = reshapedArray.reduce((acc, val) => {\n            let lastArray = acc[acc.length - 1];\n\n            if (lastArray.length < dimensions[i]) {\n                lastArray.push(val);\n            } else {\n                acc.push([val]);\n            }\n\n            return acc;\n        }, [[]]);\n    }\n\n    return reshapedArray[0];\n}\n\n/**\n * Transposes a tensor according to the provided axes.\n * @param {any} tensor The input tensor to transpose.\n * @param {Array} axes The axes to transpose the tensor along.\n * @returns {Tensor} The transposed tensor.\n */\nfunction transpose(tensor, axes) {\n    const [transposedData, shape] = (0,_maths_js__WEBPACK_IMPORTED_MODULE_1__.transpose_data)(tensor.data, tensor.dims, axes);\n    return new Tensor(tensor.type, transposedData, shape);\n}\n\n\n/**\n * Interpolates an Tensor to the given size.\n * @param {Tensor} input The input tensor to interpolate. Data must be channel-first (i.e., [c, h, w])\n * @param {number[]} size The output size of the image\n * @param {string} mode The interpolation mode\n * @param {boolean} align_corners Whether to align corners.\n * @returns {Tensor} The interpolated tensor.\n */\nfunction interpolate(input, [out_height, out_width], mode = 'bilinear', align_corners = false) {\n\n    // Input image dimensions\n    const in_channels = input.dims.at(-3) ?? 1;\n    const in_height = input.dims.at(-2);\n    const in_width = input.dims.at(-1);\n\n    let output = (0,_maths_js__WEBPACK_IMPORTED_MODULE_1__.interpolate_data)(\n        input.data,\n        [in_channels, in_height, in_width],\n        [out_height, out_width],\n        mode,\n        align_corners\n    );\n    return new Tensor(input.type, output, [in_channels, out_height, out_width]);\n}\n\n/**\n * Perform mean pooling of the last hidden state followed by a normalization step.\n * @param {Tensor} last_hidden_state Tensor of shape [batchSize, seqLength, embedDim]\n * @param {Tensor} attention_mask Tensor of shape [batchSize, seqLength]\n * @returns {Tensor} Returns a new Tensor of shape [batchSize, embedDim].\n */\nfunction mean_pooling(last_hidden_state, attention_mask) {\n    // last_hidden_state: [batchSize, seqLength, embedDim]\n    // attention_mask:    [batchSize, seqLength]\n\n    let shape = [last_hidden_state.dims[0], last_hidden_state.dims[2]];\n    let returnedData = new last_hidden_state.data.constructor(shape[0] * shape[1]);\n    let [batchSize, seqLength, embedDim] = last_hidden_state.dims;\n\n    let outIndex = 0;\n    for (let i = 0; i < batchSize; ++i) {\n        let offset = i * embedDim * seqLength;\n\n        for (let k = 0; k < embedDim; ++k) {\n            let sum = 0;\n            let count = 0;\n\n            let attnMaskOffset = i * seqLength;\n            let offset2 = offset + k;\n            // Pool over all words in sequence\n            for (let j = 0; j < seqLength; ++j) {\n                // index into attention mask\n                let attn = Number(attention_mask.data[attnMaskOffset + j]);\n\n                count += attn;\n                sum += last_hidden_state.data[offset2 + j * embedDim] * attn;\n            }\n\n            let avg = sum / count;\n            returnedData[outIndex++] = avg;\n        }\n    }\n\n    return new Tensor(\n        last_hidden_state.type,\n        returnedData,\n        shape\n    )\n}\n\n/**\n * Helper function to calculate new dimensions when performing a squeeze operation.\n * @param {number[]} dims The dimensions of the tensor.\n * @param {number|number[]|null} dim The dimension(s) to squeeze.\n * @returns The new dimensions.\n * @private\n */\nfunction calc_squeeze_dims(dims, dim) {\n    dims = dims.slice();\n    if (dim === null) {\n        dims = dims.filter((d) => d !== 1);\n    } else if (typeof dim === 'number') {\n        if (dims[dim] === 1) {\n            dims.splice(dim, 1);\n        }\n    } else if (Array.isArray(dim)) {\n        dims = dims.filter((x, i) => {\n            return x !== 1 || !dim.includes(i);\n        });\n    }\n    return dims;\n}\n\n/**\n * Helper function to calculate new dimensions when performing an unsqueeze operation.\n * @param {number[]} dims The dimensions of the tensor.\n * @param {number} dim The dimension to unsqueeze.\n * @returns The new dimensions.\n * @private\n */\nfunction calc_unsqueeze_dims(dims, dim) {\n    // Dimension out of range (e.g., \"expected to be in range of [-4, 3], but got 4\")\n    // + 1 since we allow inserting at the end (i.e. dim = -1)\n    dim = safeIndex(dim, dims.length + 1);\n    dims = dims.slice();\n    // Insert 1 into specified dimension\n    dims.splice(dim, 0, 1);\n    return dims;\n}\n\n/**\n * Safely calculate the index for an array of a given size, allowing negative indexing.\n * @param {number} index The index that will be used.\n * @param {number} size The size of the array.\n * @param {number} [dimension=null] The dimension that the index is for (optional).\n * @returns {number} The index, guaranteed to be non-negative and less than `arrayLength`.\n * \n * @throws {Error} If the index is out of range.\n * @private\n */\nfunction safeIndex(index, size, dimension = null) {\n    if (index < -size || index >= size) {\n        throw new Error(`IndexError: index ${index} is out of bounds for dimension${dimension === null ? '' : ' ' + dimension} with size ${size}`);\n    }\n\n    if (index < 0) {\n        // Negative indexing, ensuring positive index\n        index = ((index % size) + size) % size;\n    }\n    return index;\n}\n\n/**\n * Concatenates an array of tensors along a specified dimension.\n * @param {Tensor[]} tensors The array of tensors to concatenate.\n * @param {number} dim The dimension to concatenate along.\n * @returns {Tensor} The concatenated tensor.\n */\nfunction cat(tensors, dim = 0) {\n    dim = safeIndex(dim, tensors[0].dims.length);\n\n    // TODO do validation of shapes\n\n    const resultDims = tensors[0].dims.slice();\n    resultDims[dim] = tensors.reduce((a, b) => a + b.dims[dim], 0);\n\n    // Create a new array to store the accumulated values\n    const resultSize = resultDims.reduce((a, b) => a * b, 1);\n    const result = new tensors[0].data.constructor(resultSize);\n\n    // Create output tensor of same type as first\n    const resultType = tensors[0].type;\n\n    if (dim === 0) {\n        // Handle special case for performance reasons\n\n        let offset = 0;\n        for (let t of tensors) {\n            result.set(t.data, offset);\n            offset += t.data.length;\n        }\n\n    } else {\n\n        let currentDim = 0;\n\n        for (let t = 0; t < tensors.length; ++t) {\n            let tensor = tensors[t];\n\n            // Iterate over the data array\n            for (let i = 0; i < tensor.data.length; ++i) {\n                // Calculate the index in the resulting array\n                let resultIndex = 0;\n\n                for (let j = tensor.dims.length - 1, num = i, resultMultiplier = 1; j >= 0; --j) {\n                    const size = tensor.dims[j];\n                    let index = num % size;\n                    if (j === dim) {\n                        index += currentDim;\n                    }\n                    resultIndex += index * resultMultiplier;\n                    resultMultiplier *= resultDims[j];\n                    num = Math.floor(num / size);\n                }\n                // Accumulate the value at the current index\n                result[resultIndex] = tensor.data[i];\n            }\n\n            currentDim += tensor.dims[dim];\n        }\n    }\n    return new Tensor(resultType, result, resultDims);\n}\n\n/**\n * Stack an array of tensors along a specified dimension.\n * @param {Tensor[]} tensors The array of tensors to stack.\n * @param {number} dim The dimension to stack along.\n * @returns {Tensor} The stacked tensor.\n */\nfunction stack(tensors, dim = 0) {\n    // TODO do validation of shapes\n    // NOTE: stack expects each tensor to be equal size\n    return cat(tensors.map(t => t.unsqueeze(dim)), dim);\n}\n\n\n/**\n * Calculates the standard deviation and mean over the dimensions specified by dim. dim can be a single dimension or `null` to reduce over all dimensions.\n * @param {Tensor} input the input tenso\n * @param {number|null} dim the dimension to reduce. If None, all dimensions are reduced.\n * @param {number} correction difference between the sample size and sample degrees of freedom. Defaults to Bessel's correction, correction=1.\n * @param {boolean} keepdim whether the output tensor has dim retained or not.\n * @returns {Tensor[]} A tuple of (std, mean) tensors.\n */\nfunction std_mean(input, dim = null, correction = 1, keepdim = false) {\n\n    if (dim === null) {\n        // None to reduce over all dimensions.\n        const sum = input.data.reduce((a, b) => a + b, 0);\n        const mean = sum / input.data.length;\n        const std = Math.sqrt(input.data.reduce((a, b) => a + (b - mean) ** 2, 0) / (input.data.length - correction));\n\n        const meanTensor = new Tensor(input.type, [mean], [/* scalar */]);\n        const stdTensor = new Tensor(input.type, [std], [/* scalar */]);\n\n        return [stdTensor, meanTensor];\n    }\n\n    // Negative indexing\n    dim = safeIndex(dim, input.dims.length);\n\n    const meanTensor = mean(input, dim, keepdim);\n\n    // Calculate the shape of the resulting array after summation\n    const resultDims = input.dims.slice(); // Copy the original dimensions\n    resultDims[dim] = 1; // Remove the specified axis\n\n    // Create a new array to store the accumulated values\n    const result = new input.data.constructor(input.data.length / input.dims[dim]);\n\n    // Iterate over the data array\n    for (let i = 0; i < input.data.length; ++i) {\n\n        // Calculate the index in the resulting array\n        let resultIndex = 0;\n\n        for (let j = input.dims.length - 1, num = i, resultMultiplier = 1; j >= 0; --j) {\n            const size = input.dims[j];\n            if (j !== dim) {\n                const index = num % size;\n                resultIndex += index * resultMultiplier;\n                resultMultiplier *= resultDims[j];\n            }\n            num = Math.floor(num / size);\n        }\n\n        // Accumulate the value at the current index\n        result[resultIndex] += (input.data[i] - meanTensor.data[resultIndex]) ** 2;\n    }\n\n    for (let i = 0; i < result.length; ++i) {\n        result[i] = Math.sqrt(result[i] / (input.dims[dim] - correction));\n    }\n\n    if (!keepdim) {\n        resultDims.splice(dim, 1);\n    }\n\n    const stdTensor = new Tensor(input.type, result, resultDims);\n\n    return [stdTensor, meanTensor];\n}\n\n\n/**\n * Returns the mean value of each row of the input tensor in the given dimension dim.\n * @param {Tensor} input the input tensor.\n * @param {number|null} dim the dimension to reduce.\n * @param {boolean} keepdim whether the output tensor has dim retained or not.\n * @returns A new tensor with means taken along the specified dimension.\n */\nfunction mean(input, dim = null, keepdim = false) {\n\n    if (dim === null) {\n        // None to reduce over all dimensions.\n        let val = input.data.reduce((a, b) => a + b, 0);\n        return new Tensor(input.type, [val / input.data.length], [/* scalar */]);\n    }\n\n    // Negative indexing\n    dim = safeIndex(dim, input.dims.length);\n\n    // Calculate the shape of the resulting array after summation\n    const resultDims = input.dims.slice(); // Copy the original dimensions\n    resultDims[dim] = 1; // Remove the specified axis\n\n    // Create a new array to store the accumulated values\n    const result = new input.data.constructor(input.data.length / input.dims[dim]);\n\n    // Iterate over the data array\n    for (let i = 0; i < input.data.length; ++i) {\n\n        // Calculate the index in the resulting array\n        let resultIndex = 0;\n\n        for (let j = input.dims.length - 1, num = i, resultMultiplier = 1; j >= 0; --j) {\n            const size = input.dims[j];\n            if (j !== dim) {\n                const index = num % size;\n                resultIndex += index * resultMultiplier;\n                resultMultiplier *= resultDims[j];\n            }\n            num = Math.floor(num / size);\n        }\n\n        // Accumulate the value at the current index\n        result[resultIndex] += input.data[i];\n    }\n\n    if (input.dims[dim] !== 1) {\n        for (let i = 0; i < result.length; ++i) {\n            result[i] = result[i] / input.dims[dim];\n        }\n    }\n\n    if (!keepdim) {\n        resultDims.splice(dim, 1);\n    }\n\n    return new Tensor(input.type, result, resultDims);\n}\n\n\n/**\n *\n * Measures similarity between two temporal sequences (e.g., input audio and output tokens\n * to generate token-level timestamps).\n * @param {Tensor} matrix \n * @returns {number[][]}\n */\nfunction dynamicTimeWarping(matrix) {\n    const [output_length, input_length] = matrix.dims;\n\n    const outputShape = [output_length + 1, input_length + 1];\n\n    const cost = new Tensor(\n        'float32',\n        new Float32Array(outputShape[0] * outputShape[1]).fill(Infinity),\n        outputShape\n    );\n\n    const trace = new Tensor(\n        'float32',\n        new Float32Array(outputShape[0] * outputShape[1]).fill(-1),\n        outputShape\n    )\n\n    // same as `cost[0][0] = 0`;\n    cost[0].data[0] = 0;\n\n    for (let j = 1; j < input_length + 1; ++j) {\n        for (let i = 1; i < output_length + 1; ++i) {\n\n            const c0 = cost[i - 1][j - 1].item();\n            const c1 = cost[i - 1][j].item();\n            const c2 = cost[i][j - 1].item();\n\n            let c, t;\n            if (c0 < c1 && c0 < c2) {\n                c = c0;\n                t = 0;\n            } else if (c1 < c0 && c1 < c2) {\n                c = c1;\n                t = 1;\n            } else {\n                c = c2;\n                t = 2;\n            }\n\n            cost[i].data[j] = matrix[i - 1][j - 1].item() + c;\n            trace[i].data[j] = t;\n        }\n    }\n\n    // backtrace\n    let i = output_length;\n    let j = input_length;\n\n    trace.data.fill(2, 0, outputShape[1]) // trace[0, :] = 2\n    for (let i = 0; i < outputShape[0]; ++i) { // trace[:, 0] = 1\n        trace[i].data[0] = 1;\n    }\n\n    let text_indices = [];\n    let time_indices = [];\n\n    while (i > 0 || j > 0) {\n        text_indices.push(i - 1);\n        time_indices.push(j - 1);\n\n        const t = trace[i][j].item();\n        switch (t) {\n            case 0:\n                --i; --j;\n                break;\n            case 1:\n                --i;\n                break;\n            case 2:\n                --j;\n                break;\n            default:\n                throw new Error(\n                    `Internal error in dynamic time warping. Unexpected trace[${i}, ${j}]. Please file a bug report.`\n                )\n        }\n    }\n\n    text_indices.reverse();\n    time_indices.reverse();\n\n    return [text_indices, time_indices];\n\n}\n\nfunction dimsToStride(dims) {\n    const stride = new Array(dims.length);\n    for (let i = dims.length - 1, s2 = 1; i >= 0; --i) {\n        stride[i] = s2;\n        s2 *= dims[i];\n    }\n    return stride;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHhlbm92YS90cmFuc2Zvcm1lcnMvc3JjL3V0aWxzL3RlbnNvci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRTJDOztBQUt2Qjs7O0FBR3BCO0FBQ0EsYUFBYSxvQ0FBb0M7QUFDakQ7O0FBRUEsV0FBVyxRQUFRO0FBQ25CLG1CQUFtQixtREFBSTs7QUFFaEI7QUFDUDtBQUNBO0FBQ0EsZUFBZSxzREFBc0Q7QUFDckU7QUFDQTtBQUNBLCtCQUErQixtREFBSTtBQUNuQztBQUNBOztBQUVBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsVUFBVTtBQUMzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRCQUE0QixnQkFBZ0I7QUFDNUM7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLGVBQWU7QUFDOUIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBLDRCQUE0QiwwQkFBMEI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsS0FBSztBQUNwQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QixnQkFB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OztBQUVBO0FBQ0E7O0FBRUE7QUFDQSwyQ0FBMkM7QUFDM0MseUJBQXlCOztBQUV6QjtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLHVCQUF1Qjs7QUFFM0M7QUFDQTs7QUFFQSwyRUFBMkUsUUFBUTtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdCQUF3QixtQkFBbUI7QUFDM0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDTztBQUNQOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG9CQUFvQixzQkFBc0I7QUFDMUMsd0JBQXdCLHVCQUF1Qjs7QUFFL0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixvQkFBb0IsT0FBTztBQUMvQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRkFBZ0YsRUFBRSxJQUFJLEVBQUU7QUFDeEY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLDBDQUEwQyxRQUFRO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90cmFuc2Zvcm1lcnNqcy1wbGF5Z3JvdW5kLy4vbm9kZV9tb2R1bGVzL0B4ZW5vdmEvdHJhbnNmb3JtZXJzL3NyYy91dGlscy90ZW5zb3IuanM/NTcxNSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBmaWxlIEhlbHBlciBtb2R1bGUgZm9yIGBUZW5zb3JgIHByb2Nlc3NpbmcuXG4gKiBcbiAqIFRoZXNlIGZ1bmN0aW9ucyBhbmQgY2xhc3NlcyBhcmUgb25seSB1c2VkIGludGVybmFsbHksIFxuICogbWVhbmluZyBhbiBlbmQtdXNlciBzaG91bGRuJ3QgbmVlZCB0byBhY2Nlc3MgYW55dGhpbmcgaGVyZS5cbiAqIFxuICogQG1vZHVsZSB1dGlscy90ZW5zb3JcbiAqL1xuXG5pbXBvcnQgeyBPTk5YIH0gZnJvbSAnLi4vYmFja2VuZHMvb25ueC5qcyc7XG5cbmltcG9ydCB7XG4gICAgaW50ZXJwb2xhdGVfZGF0YSxcbiAgICB0cmFuc3Bvc2VfZGF0YVxufSBmcm9tICcuL21hdGhzLmpzJztcblxuXG4vKipcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJy4vbWF0aHMuanMnKS5BbnlUeXBlZEFycmF5fSBBbnlUeXBlZEFycmF5XG4gKi9cblxuLyoqIEB0eXBlIHtPYmplY3R9ICovXG5jb25zdCBPTk5YVGVuc29yID0gT05OWC5UZW5zb3I7XG5cbmV4cG9ydCBjbGFzcyBUZW5zb3IgZXh0ZW5kcyBPTk5YVGVuc29yIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgVGVuc29yIG9yIGNvcHkgYW4gZXhpc3RpbmcgVGVuc29yLlxuICAgICAqIEBwYXJhbSB7W3N0cmluZywgQXJyYXl8QW55VHlwZWRBcnJheSwgbnVtYmVyW11dfFtPTk5YVGVuc29yXX0gYXJnc1xuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICAgICAgaWYgKGFyZ3NbMF0gaW5zdGFuY2VvZiBPTk5YLlRlbnNvcikge1xuICAgICAgICAgICAgLy8gQ3JlYXRlIHNoYWxsb3cgY29weVxuICAgICAgICAgICAgc3VwZXIoYXJnc1swXS50eXBlLCBhcmdzWzBdLmRhdGEsIGFyZ3NbMF0uZGltcyk7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIENyZWF0ZSBuZXdcbiAgICAgICAgICAgIHN1cGVyKC4uLmFyZ3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5ldyBQcm94eSh0aGlzLCB7XG4gICAgICAgICAgICBnZXQ6IChvYmosIGtleSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Yga2V5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgaW5kZXggPSBOdW1iZXIoa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKE51bWJlci5pc0ludGVnZXIoaW5kZXgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBrZXkgaXMgYW4gaW50ZWdlciAoaS5lLiwgaW5kZXgpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb2JqLl9nZXRpdGVtKGluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9ialtrZXldO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldDogKG9iaiwga2V5LCB2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIFRPRE8gYWxsb3cgc2V0dGluZyBvZiBkYXRhXG5cbiAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9ialtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gaXRlcmF0b3Igb2JqZWN0IGZvciBpdGVyYXRpbmcgb3ZlciB0aGUgdGVuc29yIGRhdGEgaW4gcm93LW1ham9yIG9yZGVyLlxuICAgICAqIElmIHRoZSB0ZW5zb3IgaGFzIG1vcmUgdGhhbiBvbmUgZGltZW5zaW9uLCB0aGUgaXRlcmF0b3Igd2lsbCB5aWVsZCBzdWJhcnJheXMuXG4gICAgICogQHJldHVybnMge0l0ZXJhdG9yfSBBbiBpdGVyYXRvciBvYmplY3QgZm9yIGl0ZXJhdGluZyBvdmVyIHRoZSB0ZW5zb3IgZGF0YSBpbiByb3ctbWFqb3Igb3JkZXIuXG4gICAgICovXG4gICAgKltTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgICAgICBjb25zdCBbaXRlckxlbmd0aCwgLi4uaXRlckRpbXNdID0gdGhpcy5kaW1zO1xuXG4gICAgICAgIGlmIChpdGVyRGltcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBpdGVyU2l6ZSA9IGl0ZXJEaW1zLnJlZHVjZSgoYSwgYikgPT4gYSAqIGIpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpdGVyTGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLl9zdWJhcnJheShpLCBpdGVyU2l6ZSwgaXRlckRpbXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgeWllbGQqIHRoaXMuZGF0YVxuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbmRleCBpbnRvIGEgVGVuc29yIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggVGhlIGluZGV4IHRvIGFjY2Vzcy5cbiAgICAgKiBAcmV0dXJucyB7VGVuc29yfSBUaGUgZGF0YSBhdCB0aGUgc3BlY2lmaWVkIGluZGV4LlxuICAgICAqL1xuICAgIF9nZXRpdGVtKGluZGV4KSB7XG4gICAgICAgIGNvbnN0IFtpdGVyTGVuZ3RoLCAuLi5pdGVyRGltc10gPSB0aGlzLmRpbXM7XG5cbiAgICAgICAgaW5kZXggPSBzYWZlSW5kZXgoaW5kZXgsIGl0ZXJMZW5ndGgpO1xuXG4gICAgICAgIGlmIChpdGVyRGltcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBpdGVyU2l6ZSA9IGl0ZXJEaW1zLnJlZHVjZSgoYSwgYikgPT4gYSAqIGIpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3N1YmFycmF5KGluZGV4LCBpdGVyU2l6ZSwgaXRlckRpbXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBUZW5zb3IodGhpcy50eXBlLCBbdGhpcy5kYXRhW2luZGV4XV0sIGl0ZXJEaW1zKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfGJpZ2ludH0gaXRlbSBUaGUgaXRlbSB0byBzZWFyY2ggZm9yIGluIHRoZSB0ZW5zb3JcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgaW5kZXggb2YgdGhlIGZpcnN0IG9jY3VycmVuY2Ugb2YgaXRlbSBpbiB0aGUgdGVuc29yIGRhdGEuXG4gICAgICovXG4gICAgaW5kZXhPZihpdGVtKSB7XG4gICAgICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCB0aGlzLmRhdGEubGVuZ3RoOyArK2luZGV4KSB7XG4gICAgICAgICAgICAvLyBOb3RlOiA9PSBpbnN0ZWFkIG9mID09PSBzbyB3ZSBjYW4gbWF0Y2ggSW50cyB3aXRoIEJpZ0ludHNcbiAgICAgICAgICAgIGlmICh0aGlzLmRhdGFbaW5kZXhdID09IGl0ZW0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaXRlclNpemUgXG4gICAgICogQHBhcmFtIHthbnl9IGl0ZXJEaW1zIFxuICAgICAqIEByZXR1cm5zIHtUZW5zb3J9XG4gICAgICovXG4gICAgX3N1YmFycmF5KGluZGV4LCBpdGVyU2l6ZSwgaXRlckRpbXMpIHtcbiAgICAgICAgbGV0IGRhdGEgPSB0aGlzLmRhdGEuc3ViYXJyYXkoaW5kZXggKiBpdGVyU2l6ZSwgKGluZGV4ICsgMSkgKiBpdGVyU2l6ZSk7XG4gICAgICAgIHJldHVybiBuZXcgVGVuc29yKHRoaXMudHlwZSwgZGF0YSwgaXRlckRpbXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHZhbHVlIG9mIHRoaXMgdGVuc29yIGFzIGEgc3RhbmRhcmQgSmF2YVNjcmlwdCBOdW1iZXIuIFRoaXMgb25seSB3b3Jrc1xuICAgICAqIGZvciB0ZW5zb3JzIHdpdGggb25lIGVsZW1lbnQuIEZvciBvdGhlciBjYXNlcywgc2VlIGBUZW5zb3IudG9saXN0KClgLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSB2YWx1ZSBvZiB0aGlzIHRlbnNvciBhcyBhIHN0YW5kYXJkIEphdmFTY3JpcHQgTnVtYmVyLlxuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgdGVuc29yIGhhcyBtb3JlIHRoYW4gb25lIGVsZW1lbnQuXG4gICAgICovXG4gICAgaXRlbSgpIHtcbiAgICAgICAgaWYgKHRoaXMuZGF0YS5sZW5ndGggIT09IDEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgYSBUZW5zb3Igd2l0aCAke3RoaXMuZGF0YS5sZW5ndGh9IGVsZW1lbnRzIGNhbm5vdCBiZSBjb252ZXJ0ZWQgdG8gU2NhbGFyYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVswXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IHRlbnNvciBkYXRhIHRvIGEgbi1kaW1lbnNpb25hbCBKUyBsaXN0XG4gICAgICogQHJldHVybnMge0FycmF5fVxuICAgICAqL1xuICAgIHRvbGlzdCgpIHtcbiAgICAgICAgcmV0dXJuIHJlc2hhcGUodGhpcy5kYXRhLCB0aGlzLmRpbXMpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIGEgbmV3IFRlbnNvciB3aXRoIHRoZSBzaWdtb2lkIGZ1bmN0aW9uIGFwcGxpZWQgdG8gZWFjaCBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtUZW5zb3J9IFRoZSB0ZW5zb3Igd2l0aCB0aGUgc2lnbW9pZCBmdW5jdGlvbiBhcHBsaWVkLlxuICAgICAqL1xuICAgIHNpZ21vaWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsb25lKCkuc2lnbW9pZF8oKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIHRoZSBzaWdtb2lkIGZ1bmN0aW9uIHRvIHRoZSB0ZW5zb3IgaW4gcGxhY2UuXG4gICAgICogQHJldHVybnMge1RlbnNvcn0gUmV0dXJucyBgdGhpc2AuXG4gICAgICovXG4gICAgc2lnbW9pZF8oKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5kYXRhLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB0aGlzLmRhdGFbaV0gPSAxIC8gKDEgKyBNYXRoLmV4cCgtdGhpcy5kYXRhW2ldKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgY2xvbmUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgVGVuc29yKHRoaXMudHlwZSwgdGhpcy5kYXRhLnNsaWNlKCksIHRoaXMuZGltcy5zbGljZSgpKTtcbiAgICB9XG5cbiAgICBzbGljZSguLi5zbGljZXMpIHtcbiAgICAgICAgLy8gVGhpcyBhbGxvd3MgZm9yIHNsaWNpbmcgd2l0aCByYW5nZXMgYW5kIG51bWJlcnNcbiAgICAgICAgbGV0IG5ld1RlbnNvckRpbXMgPSBbXTtcbiAgICAgICAgbGV0IG5ld09mZnNldHMgPSBbXTtcblxuICAgICAgICAvLyBzbGljZXMgaXMgYW4gYXJyYXkgb2YgbnVtYmVycyBvciBhcnJheXMgb2YgbnVtYmVyc1xuICAgICAgICAvLyBlLmcuLCBzbGljZXMgPSBbMCwgWzEsIDNdLCBudWxsLCBbMCwgM11dXG4gICAgICAgIGZvciAobGV0IHNsaWNlSW5kZXggPSAwOyBzbGljZUluZGV4IDwgdGhpcy5kaW1zLmxlbmd0aDsgKytzbGljZUluZGV4KSB7XG4gICAgICAgICAgICBsZXQgc2xpY2UgPSBzbGljZXNbc2xpY2VJbmRleF07XG5cbiAgICAgICAgICAgIGlmIChzbGljZSA9PT0gbnVsbCB8fCBzbGljZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgLy8gbnVsbCBvciB1bmRlZmluZWQgbWVhbnMgdGFrZSB0aGUgd2hvbGUgZGltZW5zaW9uXG4gICAgICAgICAgICAgICAgbmV3T2Zmc2V0cy5wdXNoKFswLCB0aGlzLmRpbXNbc2xpY2VJbmRleF1dKTtcbiAgICAgICAgICAgICAgICBuZXdUZW5zb3JEaW1zLnB1c2godGhpcy5kaW1zW3NsaWNlSW5kZXhdKTtcblxuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygc2xpY2UgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgc2xpY2UgPSBzYWZlSW5kZXgoc2xpY2UsIHRoaXMuZGltc1tzbGljZUluZGV4XSwgc2xpY2VJbmRleCk7XG5cbiAgICAgICAgICAgICAgICAvLyBBIG51bWJlciBtZWFucyB0YWtlIGEgc2luZ2xlIGVsZW1lbnRcbiAgICAgICAgICAgICAgICBuZXdPZmZzZXRzLnB1c2goW3NsaWNlLCBzbGljZSArIDFdKTtcblxuICAgICAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHNsaWNlKSAmJiBzbGljZS5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgICAgICAvLyBBbiBhcnJheSBvZiBsZW5ndGggMiBtZWFucyB0YWtlIGEgcmFuZ2Ugb2YgZWxlbWVudHNcblxuICAgICAgICAgICAgICAgIGlmIChzbGljZVswXSA+IHNsaWNlWzFdKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBzbGljZTogJHtzbGljZX1gKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBsZXQgb2Zmc2V0cyA9IFtcbiAgICAgICAgICAgICAgICAgICAgTWF0aC5tYXgoc2xpY2VbMF0sIDApLFxuICAgICAgICAgICAgICAgICAgICBNYXRoLm1pbihzbGljZVsxXSwgdGhpcy5kaW1zW3NsaWNlSW5kZXhdKVxuICAgICAgICAgICAgICAgIF07XG5cbiAgICAgICAgICAgICAgICBuZXdPZmZzZXRzLnB1c2gob2Zmc2V0cyk7XG4gICAgICAgICAgICAgICAgbmV3VGVuc29yRGltcy5wdXNoKG9mZnNldHNbMV0gLSBvZmZzZXRzWzBdKTtcblxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgc2xpY2U6ICR7c2xpY2V9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgbmV3RGltcyA9IG5ld09mZnNldHMubWFwKChbc3RhcnQsIGVuZF0pID0+IGVuZCAtIHN0YXJ0KTtcbiAgICAgICAgbGV0IG5ld0J1ZmZlclNpemUgPSBuZXdEaW1zLnJlZHVjZSgoYSwgYikgPT4gYSAqIGIpO1xuXG4gICAgICAgIC8vIEFsbG9jYXRlIG1lbW9yeVxuICAgICAgICBsZXQgZGF0YSA9IG5ldyB0aGlzLmRhdGEuY29uc3RydWN0b3IobmV3QnVmZmVyU2l6ZSk7XG5cbiAgICAgICAgLy8gUHJlY29tcHV0ZSBzdHJpZGVzXG4gICAgICAgIGNvbnN0IHN0cmlkZSA9IHRoaXMuc3RyaWRlKCk7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuZXdCdWZmZXJTaXplOyArK2kpIHtcbiAgICAgICAgICAgIGxldCBvcmlnaW5hbEluZGV4ID0gMDtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSBuZXdEaW1zLmxlbmd0aCAtIDEsIG51bSA9IGk7IGogPj0gMDsgLS1qKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2l6ZSA9IG5ld0RpbXNbal07XG4gICAgICAgICAgICAgICAgb3JpZ2luYWxJbmRleCArPSAoKG51bSAlIHNpemUpICsgbmV3T2Zmc2V0c1tqXVswXSkgKiBzdHJpZGVbal07XG4gICAgICAgICAgICAgICAgbnVtID0gTWF0aC5mbG9vcihudW0gLyBzaXplKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRhdGFbaV0gPSB0aGlzLmRhdGFbb3JpZ2luYWxJbmRleF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBUZW5zb3IodGhpcy50eXBlLCBkYXRhLCBuZXdUZW5zb3JEaW1zKTtcblxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBhIHRyYW5zcG9zZWQgdmVyc2lvbiBvZiB0aGlzIFRlbnNvciwgYWNjb3JkaW5nIHRvIHRoZSBwcm92aWRlZCBkaW1lbnNpb25zLlxuICAgICAqIEBwYXJhbSAgey4uLm51bWJlcn0gZGltcyBEaW1lbnNpb25zIHRvIHRyYW5zcG9zZS5cbiAgICAgKiBAcmV0dXJucyB7VGVuc29yfSBUaGUgdHJhbnNwb3NlZCB0ZW5zb3IuXG4gICAgICovXG4gICAgdHJhbnNwb3NlKC4uLmRpbXMpIHtcbiAgICAgICAgcmV0dXJuIHRyYW5zcG9zZSh0aGlzLCBkaW1zKTtcbiAgICB9XG5cbiAgICAvLyBUT0RPOiByZW5hbWUgdHJhbnNwb3NlIHRvIHBlcm11dGVcbiAgICAvLyBUT0RPOiBpbXBsZW1lbnQgdHJhbnNwb3NlXG5cbiAgICAvLyBUT0RPIGFkZCAubWF4KCkgYW5kIC5taW4oKSBtZXRob2RzXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBzdW0gb2YgZWFjaCByb3cgb2YgdGhlIGlucHV0IHRlbnNvciBpbiB0aGUgZ2l2ZW4gZGltZW5zaW9uIGRpbS5cbiAgICAgKiBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2RpbT1udWxsXSBUaGUgZGltZW5zaW9uIG9yIGRpbWVuc2lvbnMgdG8gcmVkdWNlLiBJZiBgbnVsbGAsIGFsbCBkaW1lbnNpb25zIGFyZSByZWR1Y2VkLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0ga2VlcGRpbSBXaGV0aGVyIHRoZSBvdXRwdXQgdGVuc29yIGhhcyBgZGltYCByZXRhaW5lZCBvciBub3QuXG4gICAgICogQHJldHVybnMgVGhlIHN1bW1lZCB0ZW5zb3JcbiAgICAgKi9cbiAgICBzdW0oZGltID0gbnVsbCwga2VlcGRpbSA9IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5vcm0oMSwgZGltLCBrZWVwZGltKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBtYXRyaXggbm9ybSBvciB2ZWN0b3Igbm9ybSBvZiBhIGdpdmVuIHRlbnNvci5cbiAgICAgKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IFtwPSdmcm8nXSBUaGUgb3JkZXIgb2Ygbm9ybVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZGltPW51bGxdIFNwZWNpZmllcyB3aGljaCBkaW1lbnNpb24gb2YgdGhlIHRlbnNvciB0byBjYWxjdWxhdGUgdGhlIG5vcm0gYWNyb3NzLlxuICAgICAqIElmIGRpbSBpcyBOb25lLCB0aGUgbm9ybSB3aWxsIGJlIGNhbGN1bGF0ZWQgYWNyb3NzIGFsbCBkaW1lbnNpb25zIG9mIGlucHV0LlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2tlZXBkaW09ZmFsc2VdIFdoZXRoZXIgdGhlIG91dHB1dCB0ZW5zb3JzIGhhdmUgZGltIHJldGFpbmVkIG9yIG5vdC5cbiAgICAgKiBAcmV0dXJucyB7VGVuc29yfSBUaGUgbm9ybSBvZiB0aGUgdGVuc29yLlxuICAgICAqL1xuICAgIG5vcm0ocCA9ICdmcm8nLCBkaW0gPSBudWxsLCBrZWVwZGltID0gZmFsc2UpIHtcbiAgICAgICAgaWYgKHAgPT09ICdmcm8nKSB7XG4gICAgICAgICAgICAvLyBOT1RFOiBTaW5jZSB3ZSBvbmx5IHN1cHBvcnQgaW50ZWdlciBkaW1zLCBGcm9iZW5pdXMgbm9ybSBwcm9kdWNlcyB0aGUgc2FtZSByZXN1bHQgYXMgcD0yLlxuICAgICAgICAgICAgcCA9IDI7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHAgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihgVW5zdXBwb3J0ZWQgbm9ybTogJHtwfWApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRpbSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgbGV0IHZhbCA9IHRoaXMuZGF0YS5yZWR1Y2UoKGEsIGIpID0+IGEgKyAoYiAqKiBwKSwgMCkgKiogKDEgLyBwKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVGVuc29yKHRoaXMudHlwZSwgW3ZhbF0sIFtdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE5lZ2F0aXZlIGluZGV4aW5nXG4gICAgICAgIGRpbSA9IHNhZmVJbmRleChkaW0sIHRoaXMuZGltcy5sZW5ndGgpO1xuXG4gICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgc2hhcGUgb2YgdGhlIHJlc3VsdGluZyBhcnJheSBhZnRlciBzdW1tYXRpb25cbiAgICAgICAgY29uc3QgcmVzdWx0RGltcyA9IHRoaXMuZGltcy5zbGljZSgpOyAvLyBDb3B5IHRoZSBvcmlnaW5hbCBkaW1lbnNpb25zXG4gICAgICAgIHJlc3VsdERpbXNbZGltXSA9IDE7IC8vIFJlbW92ZSB0aGUgc3BlY2lmaWVkIGF4aXNcblxuICAgICAgICAvLyBDcmVhdGUgYSBuZXcgYXJyYXkgdG8gc3RvcmUgdGhlIGFjY3VtdWxhdGVkIHZhbHVlc1xuICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgdGhpcy5kYXRhLmNvbnN0cnVjdG9yKHRoaXMuZGF0YS5sZW5ndGggLyB0aGlzLmRpbXNbZGltXSk7XG5cbiAgICAgICAgLy8gSXRlcmF0ZSBvdmVyIHRoZSBkYXRhIGFycmF5XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5kYXRhLmxlbmd0aDsgKytpKSB7XG5cbiAgICAgICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgaW5kZXggaW4gdGhlIHJlc3VsdGluZyBhcnJheVxuICAgICAgICAgICAgbGV0IHJlc3VsdEluZGV4ID0gMDtcblxuICAgICAgICAgICAgZm9yIChsZXQgaiA9IHRoaXMuZGltcy5sZW5ndGggLSAxLCBudW0gPSBpLCByZXN1bHRNdWx0aXBsaWVyID0gMTsgaiA+PSAwOyAtLWopIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzaXplID0gdGhpcy5kaW1zW2pdO1xuICAgICAgICAgICAgICAgIGlmIChqICE9PSBkaW0pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5kZXggPSBudW0gJSBzaXplO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRJbmRleCArPSBpbmRleCAqIHJlc3VsdE11bHRpcGxpZXI7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdE11bHRpcGxpZXIgKj0gcmVzdWx0RGltc1tqXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbnVtID0gTWF0aC5mbG9vcihudW0gLyBzaXplKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQWNjdW11bGF0ZSB0aGUgdmFsdWUgYXQgdGhlIGN1cnJlbnQgaW5kZXhcbiAgICAgICAgICAgIHJlc3VsdFtyZXN1bHRJbmRleF0gKz0gKHRoaXMuZGF0YVtpXSkgKiogcDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwICE9PSAxKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlc3VsdC5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdFtpXSA9IHJlc3VsdFtpXSAqKiAoMSAvIHApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFrZWVwZGltKSB7XG4gICAgICAgICAgICByZXN1bHREaW1zLnNwbGljZShkaW0sIDEpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5ldyBUZW5zb3IodGhpcy50eXBlLCByZXN1bHQsIHJlc3VsdERpbXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBlcmZvcm1zIGBMX3BgIG5vcm1hbGl6YXRpb24gb2YgaW5wdXRzIG92ZXIgc3BlY2lmaWVkIGRpbWVuc2lvbi4gT3BlcmF0ZXMgaW4gcGxhY2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtwPTJdIFRoZSBleHBvbmVudCB2YWx1ZSBpbiB0aGUgbm9ybSBmb3JtdWxhdGlvblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZGltPTFdIFRoZSBkaW1lbnNpb24gdG8gcmVkdWNlXG4gICAgICogQHJldHVybnMge1RlbnNvcn0gYHRoaXNgIGZvciBvcGVyYXRpb24gY2hhaW5pbmcuXG4gICAgICovXG4gICAgbm9ybWFsaXplXyhwID0gMi4wLCBkaW0gPSAxKSB7XG4gICAgICAgIGRpbSA9IHNhZmVJbmRleChkaW0sIHRoaXMuZGltcy5sZW5ndGgpO1xuXG4gICAgICAgIGNvbnN0IG5vcm0gPSB0aGlzLm5vcm0ocCwgZGltLCB0cnVlKTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZGF0YS5sZW5ndGg7ICsraSkge1xuXG4gICAgICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIGluZGV4IGluIHRoZSByZXN1bHRpbmcgYXJyYXlcbiAgICAgICAgICAgIGxldCByZXN1bHRJbmRleCA9IDA7XG5cbiAgICAgICAgICAgIGZvciAobGV0IGogPSB0aGlzLmRpbXMubGVuZ3RoIC0gMSwgbnVtID0gaSwgcmVzdWx0TXVsdGlwbGllciA9IDE7IGogPj0gMDsgLS1qKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2l6ZSA9IHRoaXMuZGltc1tqXTtcbiAgICAgICAgICAgICAgICBpZiAoaiAhPT0gZGltKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gbnVtICUgc2l6ZTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0SW5kZXggKz0gaW5kZXggKiByZXN1bHRNdWx0aXBsaWVyO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRNdWx0aXBsaWVyICo9IHRoaXMuZGltc1tqXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbnVtID0gTWF0aC5mbG9vcihudW0gLyBzaXplKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRGl2aWRlIGJ5IG5vcm1hbGl6ZWQgdmFsdWVcbiAgICAgICAgICAgIHRoaXMuZGF0YVtpXSAvPSBub3JtLmRhdGFbcmVzdWx0SW5kZXhdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGVyZm9ybXMgYExfcGAgbm9ybWFsaXphdGlvbiBvZiBpbnB1dHMgb3ZlciBzcGVjaWZpZWQgZGltZW5zaW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcD0yXSBUaGUgZXhwb25lbnQgdmFsdWUgaW4gdGhlIG5vcm0gZm9ybXVsYXRpb25cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2RpbT0xXSBUaGUgZGltZW5zaW9uIHRvIHJlZHVjZVxuICAgICAqIEByZXR1cm5zIHtUZW5zb3J9IFRoZSBub3JtYWxpemVkIHRlbnNvci5cbiAgICAgKi9cbiAgICBub3JtYWxpemUocCA9IDIuMCwgZGltID0gMSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jbG9uZSgpLm5vcm1hbGl6ZV8ocCwgZGltKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb21wdXRlIGFuZCByZXR1cm4gdGhlIHN0cmlkZSBvZiB0aGlzIHRlbnNvci5cbiAgICAgKiBTdHJpZGUgaXMgdGhlIGp1bXAgbmVjZXNzYXJ5IHRvIGdvIGZyb20gb25lIGVsZW1lbnQgdG8gdGhlIG5leHQgb25lIGluIHRoZSBzcGVjaWZpZWQgZGltZW5zaW9uIGRpbS5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyW119IFRoZSBzdHJpZGUgb2YgdGhpcyB0ZW5zb3IuXG4gICAgICovXG4gICAgc3RyaWRlKCkge1xuICAgICAgICByZXR1cm4gZGltc1RvU3RyaWRlKHRoaXMuZGltcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHRlbnNvciB3aXRoIGFsbCBzcGVjaWZpZWQgZGltZW5zaW9ucyBvZiBpbnB1dCBvZiBzaXplIDEgcmVtb3ZlZC5cbiAgICAgKiBcbiAgICAgKiBOT1RFOiBUaGUgcmV0dXJuZWQgdGVuc29yIHNoYXJlcyB0aGUgc3RvcmFnZSB3aXRoIHRoZSBpbnB1dCB0ZW5zb3IsIHNvIGNoYW5naW5nIHRoZSBjb250ZW50cyBvZiBvbmUgd2lsbCBjaGFuZ2UgdGhlIGNvbnRlbnRzIG9mIHRoZSBvdGhlci5cbiAgICAgKiBJZiB5b3Ugd291bGQgbGlrZSBhIGNvcHksIHVzZSBgdGVuc29yLmNsb25lKClgIGJlZm9yZSBzcXVlZXppbmcuXG4gICAgICogXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtkaW09bnVsbF0gSWYgZ2l2ZW4sIHRoZSBpbnB1dCB3aWxsIGJlIHNxdWVlemVkIG9ubHkgaW4gdGhlIHNwZWNpZmllZCBkaW1lbnNpb25zLlxuICAgICAqIEByZXR1cm5zIFRoZSBzcXVlZXplZCB0ZW5zb3JcbiAgICAgKi9cbiAgICBzcXVlZXplKGRpbSA9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUZW5zb3IoXG4gICAgICAgICAgICB0aGlzLnR5cGUsXG4gICAgICAgICAgICB0aGlzLmRhdGEsXG4gICAgICAgICAgICBjYWxjX3NxdWVlemVfZGltcyh0aGlzLmRpbXMsIGRpbSlcbiAgICAgICAgKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluLXBsYWNlIHZlcnNpb24gb2YgQHNlZSB7QGxpbmsgVGVuc29yLnNxdWVlemV9XG4gICAgICovXG4gICAgc3F1ZWV6ZV8oZGltID0gbnVsbCkge1xuICAgICAgICB0aGlzLmRpbXMgPSBjYWxjX3NxdWVlemVfZGltcyh0aGlzLmRpbXMsIGRpbSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBuZXcgdGVuc29yIHdpdGggYSBkaW1lbnNpb24gb2Ygc2l6ZSBvbmUgaW5zZXJ0ZWQgYXQgdGhlIHNwZWNpZmllZCBwb3NpdGlvbi5cbiAgICAgKiBcbiAgICAgKiBOT1RFOiBUaGUgcmV0dXJuZWQgdGVuc29yIHNoYXJlcyB0aGUgc2FtZSB1bmRlcmx5aW5nIGRhdGEgd2l0aCB0aGlzIHRlbnNvci5cbiAgICAgKiBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZGltIFRoZSBpbmRleCBhdCB3aGljaCB0byBpbnNlcnQgdGhlIHNpbmdsZXRvbiBkaW1lbnNpb25cbiAgICAgKiBAcmV0dXJucyBUaGUgdW5zcXVlZXplZCB0ZW5zb3JcbiAgICAgKi9cbiAgICB1bnNxdWVlemUoZGltID0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbmV3IFRlbnNvcihcbiAgICAgICAgICAgIHRoaXMudHlwZSxcbiAgICAgICAgICAgIHRoaXMuZGF0YSxcbiAgICAgICAgICAgIGNhbGNfdW5zcXVlZXplX2RpbXModGhpcy5kaW1zLCBkaW0pXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW4tcGxhY2UgdmVyc2lvbiBvZiBAc2VlIHtAbGluayBUZW5zb3IudW5zcXVlZXplfVxuICAgICAqL1xuICAgIHVuc3F1ZWV6ZV8oZGltID0gbnVsbCkge1xuICAgICAgICB0aGlzLmRpbXMgPSBjYWxjX3Vuc3F1ZWV6ZV9kaW1zKHRoaXMuZGltcywgZGltKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW4tcGxhY2UgdmVyc2lvbiBvZiBAc2VlIHtAbGluayBUZW5zb3IuZmxhdHRlbn1cbiAgICAgKi9cbiAgICBmbGF0dGVuXyhzdGFydF9kaW0gPSAwLCBlbmRfZGltID0gLTEpIHtcbiAgICAgICAgLy8gVE9ETyB2YWxpZGF0ZSBpbnB1dHNcbiAgICAgICAgZW5kX2RpbSA9IChlbmRfZGltICsgdGhpcy5kaW1zLmxlbmd0aCkgJSB0aGlzLmRpbXMubGVuZ3RoO1xuXG4gICAgICAgIGxldCBkaW1zVG9LZWVwQmVmb3JlID0gdGhpcy5kaW1zLnNsaWNlKDAsIHN0YXJ0X2RpbSk7XG4gICAgICAgIGxldCBkaW1zVG9GbGF0dGVuID0gdGhpcy5kaW1zLnNsaWNlKHN0YXJ0X2RpbSwgZW5kX2RpbSArIDEpO1xuICAgICAgICBsZXQgZGltc1RvS2VlcEFmdGVyID0gdGhpcy5kaW1zLnNsaWNlKGVuZF9kaW0gKyAxKTtcblxuICAgICAgICB0aGlzLmRpbXMgPSBbLi4uZGltc1RvS2VlcEJlZm9yZSwgZGltc1RvRmxhdHRlbi5yZWR1Y2UoKGEsIGIpID0+IGEgKiBiLCAxKSwgLi4uZGltc1RvS2VlcEFmdGVyXVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGbGF0dGVucyBpbnB1dCBieSByZXNoYXBpbmcgaXQgaW50byBhIG9uZS1kaW1lbnNpb25hbCB0ZW5zb3IuXG4gICAgICogSWYgYHN0YXJ0X2RpbWAgb3IgYGVuZF9kaW1gIGFyZSBwYXNzZWQsIG9ubHkgZGltZW5zaW9ucyBzdGFydGluZyB3aXRoIGBzdGFydF9kaW1gXG4gICAgICogYW5kIGVuZGluZyB3aXRoIGBlbmRfZGltYCBhcmUgZmxhdHRlbmVkLiBUaGUgb3JkZXIgb2YgZWxlbWVudHMgaW4gaW5wdXQgaXMgdW5jaGFuZ2VkLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydF9kaW0gdGhlIGZpcnN0IGRpbSB0byBmbGF0dGVuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGVuZF9kaW0gdGhlIGxhc3QgZGltIHRvIGZsYXR0ZW5cbiAgICAgKiBAcmV0dXJucyBUaGUgZmxhdHRlbmVkIHRlbnNvci5cbiAgICAgKi9cbiAgICBmbGF0dGVuKHN0YXJ0X2RpbSA9IDAsIGVuZF9kaW0gPSAtMSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmZsYXR0ZW5fKHN0YXJ0X2RpbSwgZW5kX2RpbSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIG5ldyB0ZW5zb3Igd2l0aCB0aGUgc2FtZSBkYXRhIGFzIHRoZSBgc2VsZmAgdGVuc29yIGJ1dCBvZiBhIGRpZmZlcmVudCBgc2hhcGVgLlxuICAgICAqIEBwYXJhbSAgey4uLm51bWJlcn0gZGltcyB0aGUgZGVzaXJlZCBzaXplXG4gICAgICogQHJldHVybnMge1RlbnNvcn0gVGhlIHRlbnNvciB3aXRoIHRoZSBzYW1lIGRhdGEgYnV0IGRpZmZlcmVudCBzaGFwZVxuICAgICAqL1xuICAgIHZpZXcoLi4uZGltcykge1xuICAgICAgICAvLyBUT0RPOiB2YWxpZGF0ZSBkaW1zXG4gICAgICAgIGxldCBpbmZlcnJlZEluZGV4ID0gLTE7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGltcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgaWYgKGRpbXNbaV0gPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgaWYgKGluZmVycmVkSW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk9ubHkgb25lIGRpbWVuc2lvbiBjYW4gYmUgaW5mZXJyZWRcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGluZmVycmVkSW5kZXggPSBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGluZmVycmVkSW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICAvLyBTb21lIGRpbWVuc2lvbiBtdXN0IGJlIGluZmVycmVkXG4gICAgICAgICAgICBjb25zdCBwcm9kdWN0T3RoZXIgPSBkaW1zLnJlZHVjZSgocHJvZHVjdCwgY3VyciwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5kZXggIT09IGluZmVycmVkSW5kZXggPyBwcm9kdWN0ICogY3VyciA6IHByb2R1Y3RcbiAgICAgICAgICAgIH0sIDEpO1xuXG4gICAgICAgICAgICBkaW1zW2luZmVycmVkSW5kZXhdID0gdGhpcy5kYXRhLmxlbmd0aCAvIHByb2R1Y3RPdGhlcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFRlbnNvcih0aGlzLnR5cGUsIHRoaXMuZGF0YSwgZGltcyk7IC8vIE5PVEU6IHVzZXMgc2FtZSB1bmRlcmx5aW5nIHN0b3JhZ2VcbiAgICB9XG5cbiAgICBuZWdfKCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZGF0YS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdGhpcy5kYXRhW2ldID0gLXRoaXMuZGF0YVtpXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgbmVnKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jbG9uZSgpLm5lZ18oKTtcbiAgICB9XG59XG5cbi8qKlxuICogVGhpcyBjcmVhdGVzIGEgbmVzdGVkIGFycmF5IG9mIGEgZ2l2ZW4gdHlwZSBhbmQgZGVwdGggKHNlZSBleGFtcGxlcykuXG4gKiBcbiAqIEBleGFtcGxlXG4gKiAgIE5lc3RBcnJheTxzdHJpbmcsIDE+OyAvLyBzdHJpbmdbXVxuICogQGV4YW1wbGVcbiAqICAgTmVzdEFycmF5PG51bWJlciwgMj47IC8vIG51bWJlcltdW11cbiAqIEBleGFtcGxlXG4gKiAgIE5lc3RBcnJheTxzdHJpbmcsIDM+OyAvLyBzdHJpbmdbXVtdW10gZXRjLlxuICogQHRlbXBsYXRlIFRcbiAqIEB0ZW1wbGF0ZSB7bnVtYmVyfSBEZXB0aFxuICogQHRlbXBsYXRlIHtuZXZlcltdfSBbQWNjPVtdXVxuICogQHR5cGVkZWYge0FjY1snbGVuZ3RoJ10gZXh0ZW5kcyBEZXB0aCA/IFQgOiBOZXN0QXJyYXk8VFtdLCBEZXB0aCwgWy4uLkFjYywgbmV2ZXJdPn0gTmVzdEFycmF5XG4gKi9cblxuLyoqXG4gKiBSZXNoYXBlcyBhIDEtZGltZW5zaW9uYWwgYXJyYXkgaW50byBhbiBuLWRpbWVuc2lvbmFsIGFycmF5LCBhY2NvcmRpbmcgdG8gdGhlIHByb3ZpZGVkIGRpbWVuc2lvbnMuXG4gKlxuICogQGV4YW1wbGVcbiAqICAgcmVzaGFwZShbMTAgICAgICAgICAgICAgICAgICAgIF0sIFsxICAgICAgXSk7IC8vIFR5cGU6IG51bWJlcltdICAgICAgVmFsdWU6IFsxMF1cbiAqICAgcmVzaGFwZShbMSwgMiwgMywgNCAgICAgICAgICAgIF0sIFsyLCAyICAgXSk7IC8vIFR5cGU6IG51bWJlcltdW10gICAgVmFsdWU6IFtbMSwgMl0sIFszLCA0XV1cbiAqICAgcmVzaGFwZShbMSwgMiwgMywgNCwgNSwgNiwgNywgOF0sIFsyLCAyLCAyXSk7IC8vIFR5cGU6IG51bWJlcltdW11bXSAgVmFsdWU6IFtbWzEsIDJdLCBbMywgNF1dLCBbWzUsIDZdLCBbNywgOF1dXVxuICogICByZXNoYXBlKFsxLCAyLCAzLCA0LCA1LCA2LCA3LCA4XSwgWzQsIDIgICBdKTsgLy8gVHlwZTogbnVtYmVyW11bXSAgICBWYWx1ZTogW1sxLCAyXSwgWzMsIDRdLCBbNSwgNl0sIFs3LCA4XV1cbiAqIEBwYXJhbSB7VFtdfSBkYXRhIFRoZSBpbnB1dCBhcnJheSB0byByZXNoYXBlLlxuICogQHBhcmFtIHtESU19IGRpbWVuc2lvbnMgVGhlIHRhcmdldCBzaGFwZS9kaW1lbnNpb25zLlxuICogQHRlbXBsYXRlIFRcbiAqIEB0ZW1wbGF0ZSB7W251bWJlcl18W251bWJlciwgbnVtYmVyXXxbbnVtYmVyLCBudW1iZXIsIG51bWJlcl18W251bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlcl19IERJTVxuICogQHJldHVybnMge05lc3RBcnJheTxULCBESU1bXCJsZW5ndGhcIl0+fSBUaGUgcmVzaGFwZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIHJlc2hhcGUoZGF0YSwgZGltZW5zaW9ucykge1xuXG4gICAgY29uc3QgdG90YWxFbGVtZW50cyA9IGRhdGEubGVuZ3RoO1xuICAgIGNvbnN0IGRpbWVuc2lvblNpemUgPSBkaW1lbnNpb25zLnJlZHVjZSgoYSwgYikgPT4gYSAqIGIpO1xuXG4gICAgaWYgKHRvdGFsRWxlbWVudHMgIT09IGRpbWVuc2lvblNpemUpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoYGNhbm5vdCByZXNoYXBlIGFycmF5IG9mIHNpemUgJHt0b3RhbEVsZW1lbnRzfSBpbnRvIHNoYXBlICgke2RpbWVuc2lvbnN9KWApO1xuICAgIH1cblxuICAgIC8qKiBAdHlwZSB7YW55fSAqL1xuICAgIGxldCByZXNoYXBlZEFycmF5ID0gZGF0YTtcblxuICAgIGZvciAobGV0IGkgPSBkaW1lbnNpb25zLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHJlc2hhcGVkQXJyYXkgPSByZXNoYXBlZEFycmF5LnJlZHVjZSgoYWNjLCB2YWwpID0+IHtcbiAgICAgICAgICAgIGxldCBsYXN0QXJyYXkgPSBhY2NbYWNjLmxlbmd0aCAtIDFdO1xuXG4gICAgICAgICAgICBpZiAobGFzdEFycmF5Lmxlbmd0aCA8IGRpbWVuc2lvbnNbaV0pIHtcbiAgICAgICAgICAgICAgICBsYXN0QXJyYXkucHVzaCh2YWwpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhY2MucHVzaChbdmFsXSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgIH0sIFtbXV0pO1xuICAgIH1cblxuICAgIHJldHVybiByZXNoYXBlZEFycmF5WzBdO1xufVxuXG4vKipcbiAqIFRyYW5zcG9zZXMgYSB0ZW5zb3IgYWNjb3JkaW5nIHRvIHRoZSBwcm92aWRlZCBheGVzLlxuICogQHBhcmFtIHthbnl9IHRlbnNvciBUaGUgaW5wdXQgdGVuc29yIHRvIHRyYW5zcG9zZS5cbiAqIEBwYXJhbSB7QXJyYXl9IGF4ZXMgVGhlIGF4ZXMgdG8gdHJhbnNwb3NlIHRoZSB0ZW5zb3IgYWxvbmcuXG4gKiBAcmV0dXJucyB7VGVuc29yfSBUaGUgdHJhbnNwb3NlZCB0ZW5zb3IuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc3Bvc2UodGVuc29yLCBheGVzKSB7XG4gICAgY29uc3QgW3RyYW5zcG9zZWREYXRhLCBzaGFwZV0gPSB0cmFuc3Bvc2VfZGF0YSh0ZW5zb3IuZGF0YSwgdGVuc29yLmRpbXMsIGF4ZXMpO1xuICAgIHJldHVybiBuZXcgVGVuc29yKHRlbnNvci50eXBlLCB0cmFuc3Bvc2VkRGF0YSwgc2hhcGUpO1xufVxuXG5cbi8qKlxuICogSW50ZXJwb2xhdGVzIGFuIFRlbnNvciB0byB0aGUgZ2l2ZW4gc2l6ZS5cbiAqIEBwYXJhbSB7VGVuc29yfSBpbnB1dCBUaGUgaW5wdXQgdGVuc29yIHRvIGludGVycG9sYXRlLiBEYXRhIG11c3QgYmUgY2hhbm5lbC1maXJzdCAoaS5lLiwgW2MsIGgsIHddKVxuICogQHBhcmFtIHtudW1iZXJbXX0gc2l6ZSBUaGUgb3V0cHV0IHNpemUgb2YgdGhlIGltYWdlXG4gKiBAcGFyYW0ge3N0cmluZ30gbW9kZSBUaGUgaW50ZXJwb2xhdGlvbiBtb2RlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGFsaWduX2Nvcm5lcnMgV2hldGhlciB0byBhbGlnbiBjb3JuZXJzLlxuICogQHJldHVybnMge1RlbnNvcn0gVGhlIGludGVycG9sYXRlZCB0ZW5zb3IuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbnRlcnBvbGF0ZShpbnB1dCwgW291dF9oZWlnaHQsIG91dF93aWR0aF0sIG1vZGUgPSAnYmlsaW5lYXInLCBhbGlnbl9jb3JuZXJzID0gZmFsc2UpIHtcblxuICAgIC8vIElucHV0IGltYWdlIGRpbWVuc2lvbnNcbiAgICBjb25zdCBpbl9jaGFubmVscyA9IGlucHV0LmRpbXMuYXQoLTMpID8/IDE7XG4gICAgY29uc3QgaW5faGVpZ2h0ID0gaW5wdXQuZGltcy5hdCgtMik7XG4gICAgY29uc3QgaW5fd2lkdGggPSBpbnB1dC5kaW1zLmF0KC0xKTtcblxuICAgIGxldCBvdXRwdXQgPSBpbnRlcnBvbGF0ZV9kYXRhKFxuICAgICAgICBpbnB1dC5kYXRhLFxuICAgICAgICBbaW5fY2hhbm5lbHMsIGluX2hlaWdodCwgaW5fd2lkdGhdLFxuICAgICAgICBbb3V0X2hlaWdodCwgb3V0X3dpZHRoXSxcbiAgICAgICAgbW9kZSxcbiAgICAgICAgYWxpZ25fY29ybmVyc1xuICAgICk7XG4gICAgcmV0dXJuIG5ldyBUZW5zb3IoaW5wdXQudHlwZSwgb3V0cHV0LCBbaW5fY2hhbm5lbHMsIG91dF9oZWlnaHQsIG91dF93aWR0aF0pO1xufVxuXG4vKipcbiAqIFBlcmZvcm0gbWVhbiBwb29saW5nIG9mIHRoZSBsYXN0IGhpZGRlbiBzdGF0ZSBmb2xsb3dlZCBieSBhIG5vcm1hbGl6YXRpb24gc3RlcC5cbiAqIEBwYXJhbSB7VGVuc29yfSBsYXN0X2hpZGRlbl9zdGF0ZSBUZW5zb3Igb2Ygc2hhcGUgW2JhdGNoU2l6ZSwgc2VxTGVuZ3RoLCBlbWJlZERpbV1cbiAqIEBwYXJhbSB7VGVuc29yfSBhdHRlbnRpb25fbWFzayBUZW5zb3Igb2Ygc2hhcGUgW2JhdGNoU2l6ZSwgc2VxTGVuZ3RoXVxuICogQHJldHVybnMge1RlbnNvcn0gUmV0dXJucyBhIG5ldyBUZW5zb3Igb2Ygc2hhcGUgW2JhdGNoU2l6ZSwgZW1iZWREaW1dLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbWVhbl9wb29saW5nKGxhc3RfaGlkZGVuX3N0YXRlLCBhdHRlbnRpb25fbWFzaykge1xuICAgIC8vIGxhc3RfaGlkZGVuX3N0YXRlOiBbYmF0Y2hTaXplLCBzZXFMZW5ndGgsIGVtYmVkRGltXVxuICAgIC8vIGF0dGVudGlvbl9tYXNrOiAgICBbYmF0Y2hTaXplLCBzZXFMZW5ndGhdXG5cbiAgICBsZXQgc2hhcGUgPSBbbGFzdF9oaWRkZW5fc3RhdGUuZGltc1swXSwgbGFzdF9oaWRkZW5fc3RhdGUuZGltc1syXV07XG4gICAgbGV0IHJldHVybmVkRGF0YSA9IG5ldyBsYXN0X2hpZGRlbl9zdGF0ZS5kYXRhLmNvbnN0cnVjdG9yKHNoYXBlWzBdICogc2hhcGVbMV0pO1xuICAgIGxldCBbYmF0Y2hTaXplLCBzZXFMZW5ndGgsIGVtYmVkRGltXSA9IGxhc3RfaGlkZGVuX3N0YXRlLmRpbXM7XG5cbiAgICBsZXQgb3V0SW5kZXggPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmF0Y2hTaXplOyArK2kpIHtcbiAgICAgICAgbGV0IG9mZnNldCA9IGkgKiBlbWJlZERpbSAqIHNlcUxlbmd0aDtcblxuICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IGVtYmVkRGltOyArK2spIHtcbiAgICAgICAgICAgIGxldCBzdW0gPSAwO1xuICAgICAgICAgICAgbGV0IGNvdW50ID0gMDtcblxuICAgICAgICAgICAgbGV0IGF0dG5NYXNrT2Zmc2V0ID0gaSAqIHNlcUxlbmd0aDtcbiAgICAgICAgICAgIGxldCBvZmZzZXQyID0gb2Zmc2V0ICsgaztcbiAgICAgICAgICAgIC8vIFBvb2wgb3ZlciBhbGwgd29yZHMgaW4gc2VxdWVuY2VcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgc2VxTGVuZ3RoOyArK2opIHtcbiAgICAgICAgICAgICAgICAvLyBpbmRleCBpbnRvIGF0dGVudGlvbiBtYXNrXG4gICAgICAgICAgICAgICAgbGV0IGF0dG4gPSBOdW1iZXIoYXR0ZW50aW9uX21hc2suZGF0YVthdHRuTWFza09mZnNldCArIGpdKTtcblxuICAgICAgICAgICAgICAgIGNvdW50ICs9IGF0dG47XG4gICAgICAgICAgICAgICAgc3VtICs9IGxhc3RfaGlkZGVuX3N0YXRlLmRhdGFbb2Zmc2V0MiArIGogKiBlbWJlZERpbV0gKiBhdHRuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQgYXZnID0gc3VtIC8gY291bnQ7XG4gICAgICAgICAgICByZXR1cm5lZERhdGFbb3V0SW5kZXgrK10gPSBhdmc7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFRlbnNvcihcbiAgICAgICAgbGFzdF9oaWRkZW5fc3RhdGUudHlwZSxcbiAgICAgICAgcmV0dXJuZWREYXRhLFxuICAgICAgICBzaGFwZVxuICAgIClcbn1cblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdG8gY2FsY3VsYXRlIG5ldyBkaW1lbnNpb25zIHdoZW4gcGVyZm9ybWluZyBhIHNxdWVlemUgb3BlcmF0aW9uLlxuICogQHBhcmFtIHtudW1iZXJbXX0gZGltcyBUaGUgZGltZW5zaW9ucyBvZiB0aGUgdGVuc29yLlxuICogQHBhcmFtIHtudW1iZXJ8bnVtYmVyW118bnVsbH0gZGltIFRoZSBkaW1lbnNpb24ocykgdG8gc3F1ZWV6ZS5cbiAqIEByZXR1cm5zIFRoZSBuZXcgZGltZW5zaW9ucy5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNhbGNfc3F1ZWV6ZV9kaW1zKGRpbXMsIGRpbSkge1xuICAgIGRpbXMgPSBkaW1zLnNsaWNlKCk7XG4gICAgaWYgKGRpbSA9PT0gbnVsbCkge1xuICAgICAgICBkaW1zID0gZGltcy5maWx0ZXIoKGQpID0+IGQgIT09IDEpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGRpbSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgaWYgKGRpbXNbZGltXSA9PT0gMSkge1xuICAgICAgICAgICAgZGltcy5zcGxpY2UoZGltLCAxKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShkaW0pKSB7XG4gICAgICAgIGRpbXMgPSBkaW1zLmZpbHRlcigoeCwgaSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHggIT09IDEgfHwgIWRpbS5pbmNsdWRlcyhpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBkaW1zO1xufVxuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0byBjYWxjdWxhdGUgbmV3IGRpbWVuc2lvbnMgd2hlbiBwZXJmb3JtaW5nIGFuIHVuc3F1ZWV6ZSBvcGVyYXRpb24uXG4gKiBAcGFyYW0ge251bWJlcltdfSBkaW1zIFRoZSBkaW1lbnNpb25zIG9mIHRoZSB0ZW5zb3IuXG4gKiBAcGFyYW0ge251bWJlcn0gZGltIFRoZSBkaW1lbnNpb24gdG8gdW5zcXVlZXplLlxuICogQHJldHVybnMgVGhlIG5ldyBkaW1lbnNpb25zLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY2FsY191bnNxdWVlemVfZGltcyhkaW1zLCBkaW0pIHtcbiAgICAvLyBEaW1lbnNpb24gb3V0IG9mIHJhbmdlIChlLmcuLCBcImV4cGVjdGVkIHRvIGJlIGluIHJhbmdlIG9mIFstNCwgM10sIGJ1dCBnb3QgNFwiKVxuICAgIC8vICsgMSBzaW5jZSB3ZSBhbGxvdyBpbnNlcnRpbmcgYXQgdGhlIGVuZCAoaS5lLiBkaW0gPSAtMSlcbiAgICBkaW0gPSBzYWZlSW5kZXgoZGltLCBkaW1zLmxlbmd0aCArIDEpO1xuICAgIGRpbXMgPSBkaW1zLnNsaWNlKCk7XG4gICAgLy8gSW5zZXJ0IDEgaW50byBzcGVjaWZpZWQgZGltZW5zaW9uXG4gICAgZGltcy5zcGxpY2UoZGltLCAwLCAxKTtcbiAgICByZXR1cm4gZGltcztcbn1cblxuLyoqXG4gKiBTYWZlbHkgY2FsY3VsYXRlIHRoZSBpbmRleCBmb3IgYW4gYXJyYXkgb2YgYSBnaXZlbiBzaXplLCBhbGxvd2luZyBuZWdhdGl2ZSBpbmRleGluZy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBUaGUgaW5kZXggdGhhdCB3aWxsIGJlIHVzZWQuXG4gKiBAcGFyYW0ge251bWJlcn0gc2l6ZSBUaGUgc2l6ZSBvZiB0aGUgYXJyYXkuXG4gKiBAcGFyYW0ge251bWJlcn0gW2RpbWVuc2lvbj1udWxsXSBUaGUgZGltZW5zaW9uIHRoYXQgdGhlIGluZGV4IGlzIGZvciAob3B0aW9uYWwpLlxuICogQHJldHVybnMge251bWJlcn0gVGhlIGluZGV4LCBndWFyYW50ZWVkIHRvIGJlIG5vbi1uZWdhdGl2ZSBhbmQgbGVzcyB0aGFuIGBhcnJheUxlbmd0aGAuXG4gKiBcbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgaW5kZXggaXMgb3V0IG9mIHJhbmdlLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc2FmZUluZGV4KGluZGV4LCBzaXplLCBkaW1lbnNpb24gPSBudWxsKSB7XG4gICAgaWYgKGluZGV4IDwgLXNpemUgfHwgaW5kZXggPj0gc2l6ZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEluZGV4RXJyb3I6IGluZGV4ICR7aW5kZXh9IGlzIG91dCBvZiBib3VuZHMgZm9yIGRpbWVuc2lvbiR7ZGltZW5zaW9uID09PSBudWxsID8gJycgOiAnICcgKyBkaW1lbnNpb259IHdpdGggc2l6ZSAke3NpemV9YCk7XG4gICAgfVxuXG4gICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICAvLyBOZWdhdGl2ZSBpbmRleGluZywgZW5zdXJpbmcgcG9zaXRpdmUgaW5kZXhcbiAgICAgICAgaW5kZXggPSAoKGluZGV4ICUgc2l6ZSkgKyBzaXplKSAlIHNpemU7XG4gICAgfVxuICAgIHJldHVybiBpbmRleDtcbn1cblxuLyoqXG4gKiBDb25jYXRlbmF0ZXMgYW4gYXJyYXkgb2YgdGVuc29ycyBhbG9uZyBhIHNwZWNpZmllZCBkaW1lbnNpb24uXG4gKiBAcGFyYW0ge1RlbnNvcltdfSB0ZW5zb3JzIFRoZSBhcnJheSBvZiB0ZW5zb3JzIHRvIGNvbmNhdGVuYXRlLlxuICogQHBhcmFtIHtudW1iZXJ9IGRpbSBUaGUgZGltZW5zaW9uIHRvIGNvbmNhdGVuYXRlIGFsb25nLlxuICogQHJldHVybnMge1RlbnNvcn0gVGhlIGNvbmNhdGVuYXRlZCB0ZW5zb3IuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjYXQodGVuc29ycywgZGltID0gMCkge1xuICAgIGRpbSA9IHNhZmVJbmRleChkaW0sIHRlbnNvcnNbMF0uZGltcy5sZW5ndGgpO1xuXG4gICAgLy8gVE9ETyBkbyB2YWxpZGF0aW9uIG9mIHNoYXBlc1xuXG4gICAgY29uc3QgcmVzdWx0RGltcyA9IHRlbnNvcnNbMF0uZGltcy5zbGljZSgpO1xuICAgIHJlc3VsdERpbXNbZGltXSA9IHRlbnNvcnMucmVkdWNlKChhLCBiKSA9PiBhICsgYi5kaW1zW2RpbV0sIDApO1xuXG4gICAgLy8gQ3JlYXRlIGEgbmV3IGFycmF5IHRvIHN0b3JlIHRoZSBhY2N1bXVsYXRlZCB2YWx1ZXNcbiAgICBjb25zdCByZXN1bHRTaXplID0gcmVzdWx0RGltcy5yZWR1Y2UoKGEsIGIpID0+IGEgKiBiLCAxKTtcbiAgICBjb25zdCByZXN1bHQgPSBuZXcgdGVuc29yc1swXS5kYXRhLmNvbnN0cnVjdG9yKHJlc3VsdFNpemUpO1xuXG4gICAgLy8gQ3JlYXRlIG91dHB1dCB0ZW5zb3Igb2Ygc2FtZSB0eXBlIGFzIGZpcnN0XG4gICAgY29uc3QgcmVzdWx0VHlwZSA9IHRlbnNvcnNbMF0udHlwZTtcblxuICAgIGlmIChkaW0gPT09IDApIHtcbiAgICAgICAgLy8gSGFuZGxlIHNwZWNpYWwgY2FzZSBmb3IgcGVyZm9ybWFuY2UgcmVhc29uc1xuXG4gICAgICAgIGxldCBvZmZzZXQgPSAwO1xuICAgICAgICBmb3IgKGxldCB0IG9mIHRlbnNvcnMpIHtcbiAgICAgICAgICAgIHJlc3VsdC5zZXQodC5kYXRhLCBvZmZzZXQpO1xuICAgICAgICAgICAgb2Zmc2V0ICs9IHQuZGF0YS5sZW5ndGg7XG4gICAgICAgIH1cblxuICAgIH0gZWxzZSB7XG5cbiAgICAgICAgbGV0IGN1cnJlbnREaW0gPSAwO1xuXG4gICAgICAgIGZvciAobGV0IHQgPSAwOyB0IDwgdGVuc29ycy5sZW5ndGg7ICsrdCkge1xuICAgICAgICAgICAgbGV0IHRlbnNvciA9IHRlbnNvcnNbdF07XG5cbiAgICAgICAgICAgIC8vIEl0ZXJhdGUgb3ZlciB0aGUgZGF0YSBhcnJheVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0ZW5zb3IuZGF0YS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgaW5kZXggaW4gdGhlIHJlc3VsdGluZyBhcnJheVxuICAgICAgICAgICAgICAgIGxldCByZXN1bHRJbmRleCA9IDA7XG5cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gdGVuc29yLmRpbXMubGVuZ3RoIC0gMSwgbnVtID0gaSwgcmVzdWx0TXVsdGlwbGllciA9IDE7IGogPj0gMDsgLS1qKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNpemUgPSB0ZW5zb3IuZGltc1tqXTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGluZGV4ID0gbnVtICUgc2l6ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGogPT09IGRpbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggKz0gY3VycmVudERpbTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXN1bHRJbmRleCArPSBpbmRleCAqIHJlc3VsdE11bHRpcGxpZXI7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdE11bHRpcGxpZXIgKj0gcmVzdWx0RGltc1tqXTtcbiAgICAgICAgICAgICAgICAgICAgbnVtID0gTWF0aC5mbG9vcihudW0gLyBzaXplKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gQWNjdW11bGF0ZSB0aGUgdmFsdWUgYXQgdGhlIGN1cnJlbnQgaW5kZXhcbiAgICAgICAgICAgICAgICByZXN1bHRbcmVzdWx0SW5kZXhdID0gdGVuc29yLmRhdGFbaV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGN1cnJlbnREaW0gKz0gdGVuc29yLmRpbXNbZGltXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3IFRlbnNvcihyZXN1bHRUeXBlLCByZXN1bHQsIHJlc3VsdERpbXMpO1xufVxuXG4vKipcbiAqIFN0YWNrIGFuIGFycmF5IG9mIHRlbnNvcnMgYWxvbmcgYSBzcGVjaWZpZWQgZGltZW5zaW9uLlxuICogQHBhcmFtIHtUZW5zb3JbXX0gdGVuc29ycyBUaGUgYXJyYXkgb2YgdGVuc29ycyB0byBzdGFjay5cbiAqIEBwYXJhbSB7bnVtYmVyfSBkaW0gVGhlIGRpbWVuc2lvbiB0byBzdGFjayBhbG9uZy5cbiAqIEByZXR1cm5zIHtUZW5zb3J9IFRoZSBzdGFja2VkIHRlbnNvci5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0YWNrKHRlbnNvcnMsIGRpbSA9IDApIHtcbiAgICAvLyBUT0RPIGRvIHZhbGlkYXRpb24gb2Ygc2hhcGVzXG4gICAgLy8gTk9URTogc3RhY2sgZXhwZWN0cyBlYWNoIHRlbnNvciB0byBiZSBlcXVhbCBzaXplXG4gICAgcmV0dXJuIGNhdCh0ZW5zb3JzLm1hcCh0ID0+IHQudW5zcXVlZXplKGRpbSkpLCBkaW0pO1xufVxuXG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgc3RhbmRhcmQgZGV2aWF0aW9uIGFuZCBtZWFuIG92ZXIgdGhlIGRpbWVuc2lvbnMgc3BlY2lmaWVkIGJ5IGRpbS4gZGltIGNhbiBiZSBhIHNpbmdsZSBkaW1lbnNpb24gb3IgYG51bGxgIHRvIHJlZHVjZSBvdmVyIGFsbCBkaW1lbnNpb25zLlxuICogQHBhcmFtIHtUZW5zb3J9IGlucHV0IHRoZSBpbnB1dCB0ZW5zb1xuICogQHBhcmFtIHtudW1iZXJ8bnVsbH0gZGltIHRoZSBkaW1lbnNpb24gdG8gcmVkdWNlLiBJZiBOb25lLCBhbGwgZGltZW5zaW9ucyBhcmUgcmVkdWNlZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBjb3JyZWN0aW9uIGRpZmZlcmVuY2UgYmV0d2VlbiB0aGUgc2FtcGxlIHNpemUgYW5kIHNhbXBsZSBkZWdyZWVzIG9mIGZyZWVkb20uIERlZmF1bHRzIHRvIEJlc3NlbCdzIGNvcnJlY3Rpb24sIGNvcnJlY3Rpb249MS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0ga2VlcGRpbSB3aGV0aGVyIHRoZSBvdXRwdXQgdGVuc29yIGhhcyBkaW0gcmV0YWluZWQgb3Igbm90LlxuICogQHJldHVybnMge1RlbnNvcltdfSBBIHR1cGxlIG9mIChzdGQsIG1lYW4pIHRlbnNvcnMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdGRfbWVhbihpbnB1dCwgZGltID0gbnVsbCwgY29ycmVjdGlvbiA9IDEsIGtlZXBkaW0gPSBmYWxzZSkge1xuXG4gICAgaWYgKGRpbSA9PT0gbnVsbCkge1xuICAgICAgICAvLyBOb25lIHRvIHJlZHVjZSBvdmVyIGFsbCBkaW1lbnNpb25zLlxuICAgICAgICBjb25zdCBzdW0gPSBpbnB1dC5kYXRhLnJlZHVjZSgoYSwgYikgPT4gYSArIGIsIDApO1xuICAgICAgICBjb25zdCBtZWFuID0gc3VtIC8gaW5wdXQuZGF0YS5sZW5ndGg7XG4gICAgICAgIGNvbnN0IHN0ZCA9IE1hdGguc3FydChpbnB1dC5kYXRhLnJlZHVjZSgoYSwgYikgPT4gYSArIChiIC0gbWVhbikgKiogMiwgMCkgLyAoaW5wdXQuZGF0YS5sZW5ndGggLSBjb3JyZWN0aW9uKSk7XG5cbiAgICAgICAgY29uc3QgbWVhblRlbnNvciA9IG5ldyBUZW5zb3IoaW5wdXQudHlwZSwgW21lYW5dLCBbLyogc2NhbGFyICovXSk7XG4gICAgICAgIGNvbnN0IHN0ZFRlbnNvciA9IG5ldyBUZW5zb3IoaW5wdXQudHlwZSwgW3N0ZF0sIFsvKiBzY2FsYXIgKi9dKTtcblxuICAgICAgICByZXR1cm4gW3N0ZFRlbnNvciwgbWVhblRlbnNvcl07XG4gICAgfVxuXG4gICAgLy8gTmVnYXRpdmUgaW5kZXhpbmdcbiAgICBkaW0gPSBzYWZlSW5kZXgoZGltLCBpbnB1dC5kaW1zLmxlbmd0aCk7XG5cbiAgICBjb25zdCBtZWFuVGVuc29yID0gbWVhbihpbnB1dCwgZGltLCBrZWVwZGltKTtcblxuICAgIC8vIENhbGN1bGF0ZSB0aGUgc2hhcGUgb2YgdGhlIHJlc3VsdGluZyBhcnJheSBhZnRlciBzdW1tYXRpb25cbiAgICBjb25zdCByZXN1bHREaW1zID0gaW5wdXQuZGltcy5zbGljZSgpOyAvLyBDb3B5IHRoZSBvcmlnaW5hbCBkaW1lbnNpb25zXG4gICAgcmVzdWx0RGltc1tkaW1dID0gMTsgLy8gUmVtb3ZlIHRoZSBzcGVjaWZpZWQgYXhpc1xuXG4gICAgLy8gQ3JlYXRlIGEgbmV3IGFycmF5IHRvIHN0b3JlIHRoZSBhY2N1bXVsYXRlZCB2YWx1ZXNcbiAgICBjb25zdCByZXN1bHQgPSBuZXcgaW5wdXQuZGF0YS5jb25zdHJ1Y3RvcihpbnB1dC5kYXRhLmxlbmd0aCAvIGlucHV0LmRpbXNbZGltXSk7XG5cbiAgICAvLyBJdGVyYXRlIG92ZXIgdGhlIGRhdGEgYXJyYXlcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0LmRhdGEubGVuZ3RoOyArK2kpIHtcblxuICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIGluZGV4IGluIHRoZSByZXN1bHRpbmcgYXJyYXlcbiAgICAgICAgbGV0IHJlc3VsdEluZGV4ID0gMDtcblxuICAgICAgICBmb3IgKGxldCBqID0gaW5wdXQuZGltcy5sZW5ndGggLSAxLCBudW0gPSBpLCByZXN1bHRNdWx0aXBsaWVyID0gMTsgaiA+PSAwOyAtLWopIHtcbiAgICAgICAgICAgIGNvbnN0IHNpemUgPSBpbnB1dC5kaW1zW2pdO1xuICAgICAgICAgICAgaWYgKGogIT09IGRpbSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gbnVtICUgc2l6ZTtcbiAgICAgICAgICAgICAgICByZXN1bHRJbmRleCArPSBpbmRleCAqIHJlc3VsdE11bHRpcGxpZXI7XG4gICAgICAgICAgICAgICAgcmVzdWx0TXVsdGlwbGllciAqPSByZXN1bHREaW1zW2pdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbnVtID0gTWF0aC5mbG9vcihudW0gLyBzaXplKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFjY3VtdWxhdGUgdGhlIHZhbHVlIGF0IHRoZSBjdXJyZW50IGluZGV4XG4gICAgICAgIHJlc3VsdFtyZXN1bHRJbmRleF0gKz0gKGlucHV0LmRhdGFbaV0gLSBtZWFuVGVuc29yLmRhdGFbcmVzdWx0SW5kZXhdKSAqKiAyO1xuICAgIH1cblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVzdWx0Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHJlc3VsdFtpXSA9IE1hdGguc3FydChyZXN1bHRbaV0gLyAoaW5wdXQuZGltc1tkaW1dIC0gY29ycmVjdGlvbikpO1xuICAgIH1cblxuICAgIGlmICgha2VlcGRpbSkge1xuICAgICAgICByZXN1bHREaW1zLnNwbGljZShkaW0sIDEpO1xuICAgIH1cblxuICAgIGNvbnN0IHN0ZFRlbnNvciA9IG5ldyBUZW5zb3IoaW5wdXQudHlwZSwgcmVzdWx0LCByZXN1bHREaW1zKTtcblxuICAgIHJldHVybiBbc3RkVGVuc29yLCBtZWFuVGVuc29yXTtcbn1cblxuXG4vKipcbiAqIFJldHVybnMgdGhlIG1lYW4gdmFsdWUgb2YgZWFjaCByb3cgb2YgdGhlIGlucHV0IHRlbnNvciBpbiB0aGUgZ2l2ZW4gZGltZW5zaW9uIGRpbS5cbiAqIEBwYXJhbSB7VGVuc29yfSBpbnB1dCB0aGUgaW5wdXQgdGVuc29yLlxuICogQHBhcmFtIHtudW1iZXJ8bnVsbH0gZGltIHRoZSBkaW1lbnNpb24gdG8gcmVkdWNlLlxuICogQHBhcmFtIHtib29sZWFufSBrZWVwZGltIHdoZXRoZXIgdGhlIG91dHB1dCB0ZW5zb3IgaGFzIGRpbSByZXRhaW5lZCBvciBub3QuXG4gKiBAcmV0dXJucyBBIG5ldyB0ZW5zb3Igd2l0aCBtZWFucyB0YWtlbiBhbG9uZyB0aGUgc3BlY2lmaWVkIGRpbWVuc2lvbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1lYW4oaW5wdXQsIGRpbSA9IG51bGwsIGtlZXBkaW0gPSBmYWxzZSkge1xuXG4gICAgaWYgKGRpbSA9PT0gbnVsbCkge1xuICAgICAgICAvLyBOb25lIHRvIHJlZHVjZSBvdmVyIGFsbCBkaW1lbnNpb25zLlxuICAgICAgICBsZXQgdmFsID0gaW5wdXQuZGF0YS5yZWR1Y2UoKGEsIGIpID0+IGEgKyBiLCAwKTtcbiAgICAgICAgcmV0dXJuIG5ldyBUZW5zb3IoaW5wdXQudHlwZSwgW3ZhbCAvIGlucHV0LmRhdGEubGVuZ3RoXSwgWy8qIHNjYWxhciAqL10pO1xuICAgIH1cblxuICAgIC8vIE5lZ2F0aXZlIGluZGV4aW5nXG4gICAgZGltID0gc2FmZUluZGV4KGRpbSwgaW5wdXQuZGltcy5sZW5ndGgpO1xuXG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBzaGFwZSBvZiB0aGUgcmVzdWx0aW5nIGFycmF5IGFmdGVyIHN1bW1hdGlvblxuICAgIGNvbnN0IHJlc3VsdERpbXMgPSBpbnB1dC5kaW1zLnNsaWNlKCk7IC8vIENvcHkgdGhlIG9yaWdpbmFsIGRpbWVuc2lvbnNcbiAgICByZXN1bHREaW1zW2RpbV0gPSAxOyAvLyBSZW1vdmUgdGhlIHNwZWNpZmllZCBheGlzXG5cbiAgICAvLyBDcmVhdGUgYSBuZXcgYXJyYXkgdG8gc3RvcmUgdGhlIGFjY3VtdWxhdGVkIHZhbHVlc1xuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBpbnB1dC5kYXRhLmNvbnN0cnVjdG9yKGlucHV0LmRhdGEubGVuZ3RoIC8gaW5wdXQuZGltc1tkaW1dKTtcblxuICAgIC8vIEl0ZXJhdGUgb3ZlciB0aGUgZGF0YSBhcnJheVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5wdXQuZGF0YS5sZW5ndGg7ICsraSkge1xuXG4gICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgaW5kZXggaW4gdGhlIHJlc3VsdGluZyBhcnJheVxuICAgICAgICBsZXQgcmVzdWx0SW5kZXggPSAwO1xuXG4gICAgICAgIGZvciAobGV0IGogPSBpbnB1dC5kaW1zLmxlbmd0aCAtIDEsIG51bSA9IGksIHJlc3VsdE11bHRpcGxpZXIgPSAxOyBqID49IDA7IC0taikge1xuICAgICAgICAgICAgY29uc3Qgc2l6ZSA9IGlucHV0LmRpbXNbal07XG4gICAgICAgICAgICBpZiAoaiAhPT0gZGltKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5kZXggPSBudW0gJSBzaXplO1xuICAgICAgICAgICAgICAgIHJlc3VsdEluZGV4ICs9IGluZGV4ICogcmVzdWx0TXVsdGlwbGllcjtcbiAgICAgICAgICAgICAgICByZXN1bHRNdWx0aXBsaWVyICo9IHJlc3VsdERpbXNbal07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBudW0gPSBNYXRoLmZsb29yKG51bSAvIHNpemUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQWNjdW11bGF0ZSB0aGUgdmFsdWUgYXQgdGhlIGN1cnJlbnQgaW5kZXhcbiAgICAgICAgcmVzdWx0W3Jlc3VsdEluZGV4XSArPSBpbnB1dC5kYXRhW2ldO1xuICAgIH1cblxuICAgIGlmIChpbnB1dC5kaW1zW2RpbV0gIT09IDEpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXN1bHQubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHJlc3VsdFtpXSA9IHJlc3VsdFtpXSAvIGlucHV0LmRpbXNbZGltXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmICgha2VlcGRpbSkge1xuICAgICAgICByZXN1bHREaW1zLnNwbGljZShkaW0sIDEpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgVGVuc29yKGlucHV0LnR5cGUsIHJlc3VsdCwgcmVzdWx0RGltcyk7XG59XG5cblxuLyoqXG4gKlxuICogTWVhc3VyZXMgc2ltaWxhcml0eSBiZXR3ZWVuIHR3byB0ZW1wb3JhbCBzZXF1ZW5jZXMgKGUuZy4sIGlucHV0IGF1ZGlvIGFuZCBvdXRwdXQgdG9rZW5zXG4gKiB0byBnZW5lcmF0ZSB0b2tlbi1sZXZlbCB0aW1lc3RhbXBzKS5cbiAqIEBwYXJhbSB7VGVuc29yfSBtYXRyaXggXG4gKiBAcmV0dXJucyB7bnVtYmVyW11bXX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGR5bmFtaWNUaW1lV2FycGluZyhtYXRyaXgpIHtcbiAgICBjb25zdCBbb3V0cHV0X2xlbmd0aCwgaW5wdXRfbGVuZ3RoXSA9IG1hdHJpeC5kaW1zO1xuXG4gICAgY29uc3Qgb3V0cHV0U2hhcGUgPSBbb3V0cHV0X2xlbmd0aCArIDEsIGlucHV0X2xlbmd0aCArIDFdO1xuXG4gICAgY29uc3QgY29zdCA9IG5ldyBUZW5zb3IoXG4gICAgICAgICdmbG9hdDMyJyxcbiAgICAgICAgbmV3IEZsb2F0MzJBcnJheShvdXRwdXRTaGFwZVswXSAqIG91dHB1dFNoYXBlWzFdKS5maWxsKEluZmluaXR5KSxcbiAgICAgICAgb3V0cHV0U2hhcGVcbiAgICApO1xuXG4gICAgY29uc3QgdHJhY2UgPSBuZXcgVGVuc29yKFxuICAgICAgICAnZmxvYXQzMicsXG4gICAgICAgIG5ldyBGbG9hdDMyQXJyYXkob3V0cHV0U2hhcGVbMF0gKiBvdXRwdXRTaGFwZVsxXSkuZmlsbCgtMSksXG4gICAgICAgIG91dHB1dFNoYXBlXG4gICAgKVxuXG4gICAgLy8gc2FtZSBhcyBgY29zdFswXVswXSA9IDBgO1xuICAgIGNvc3RbMF0uZGF0YVswXSA9IDA7XG5cbiAgICBmb3IgKGxldCBqID0gMTsgaiA8IGlucHV0X2xlbmd0aCArIDE7ICsraikge1xuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IG91dHB1dF9sZW5ndGggKyAxOyArK2kpIHtcblxuICAgICAgICAgICAgY29uc3QgYzAgPSBjb3N0W2kgLSAxXVtqIC0gMV0uaXRlbSgpO1xuICAgICAgICAgICAgY29uc3QgYzEgPSBjb3N0W2kgLSAxXVtqXS5pdGVtKCk7XG4gICAgICAgICAgICBjb25zdCBjMiA9IGNvc3RbaV1baiAtIDFdLml0ZW0oKTtcblxuICAgICAgICAgICAgbGV0IGMsIHQ7XG4gICAgICAgICAgICBpZiAoYzAgPCBjMSAmJiBjMCA8IGMyKSB7XG4gICAgICAgICAgICAgICAgYyA9IGMwO1xuICAgICAgICAgICAgICAgIHQgPSAwO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjMSA8IGMwICYmIGMxIDwgYzIpIHtcbiAgICAgICAgICAgICAgICBjID0gYzE7XG4gICAgICAgICAgICAgICAgdCA9IDE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGMgPSBjMjtcbiAgICAgICAgICAgICAgICB0ID0gMjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29zdFtpXS5kYXRhW2pdID0gbWF0cml4W2kgLSAxXVtqIC0gMV0uaXRlbSgpICsgYztcbiAgICAgICAgICAgIHRyYWNlW2ldLmRhdGFbal0gPSB0O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gYmFja3RyYWNlXG4gICAgbGV0IGkgPSBvdXRwdXRfbGVuZ3RoO1xuICAgIGxldCBqID0gaW5wdXRfbGVuZ3RoO1xuXG4gICAgdHJhY2UuZGF0YS5maWxsKDIsIDAsIG91dHB1dFNoYXBlWzFdKSAvLyB0cmFjZVswLCA6XSA9IDJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG91dHB1dFNoYXBlWzBdOyArK2kpIHsgLy8gdHJhY2VbOiwgMF0gPSAxXG4gICAgICAgIHRyYWNlW2ldLmRhdGFbMF0gPSAxO1xuICAgIH1cblxuICAgIGxldCB0ZXh0X2luZGljZXMgPSBbXTtcbiAgICBsZXQgdGltZV9pbmRpY2VzID0gW107XG5cbiAgICB3aGlsZSAoaSA+IDAgfHwgaiA+IDApIHtcbiAgICAgICAgdGV4dF9pbmRpY2VzLnB1c2goaSAtIDEpO1xuICAgICAgICB0aW1lX2luZGljZXMucHVzaChqIC0gMSk7XG5cbiAgICAgICAgY29uc3QgdCA9IHRyYWNlW2ldW2pdLml0ZW0oKTtcbiAgICAgICAgc3dpdGNoICh0KSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgLS1pOyAtLWo7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgLS1pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIC0tajtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgICAgICBgSW50ZXJuYWwgZXJyb3IgaW4gZHluYW1pYyB0aW1lIHdhcnBpbmcuIFVuZXhwZWN0ZWQgdHJhY2VbJHtpfSwgJHtqfV0uIFBsZWFzZSBmaWxlIGEgYnVnIHJlcG9ydC5gXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgdGV4dF9pbmRpY2VzLnJldmVyc2UoKTtcbiAgICB0aW1lX2luZGljZXMucmV2ZXJzZSgpO1xuXG4gICAgcmV0dXJuIFt0ZXh0X2luZGljZXMsIHRpbWVfaW5kaWNlc107XG5cbn1cblxuZnVuY3Rpb24gZGltc1RvU3RyaWRlKGRpbXMpIHtcbiAgICBjb25zdCBzdHJpZGUgPSBuZXcgQXJyYXkoZGltcy5sZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSBkaW1zLmxlbmd0aCAtIDEsIHMyID0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgc3RyaWRlW2ldID0gczI7XG4gICAgICAgIHMyICo9IGRpbXNbaV07XG4gICAgfVxuICAgIHJldHVybiBzdHJpZGU7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@xenova/transformers/src/utils/tensor.js\n");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		var threw = true;
/******/ 		try {
/******/ 			__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 			threw = false;
/******/ 		} finally {
/******/ 			if(threw) delete __webpack_module_cache__[moduleId];
/******/ 		}
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/create fake namespace object */
/******/ 	(() => {
/******/ 		var getProto = Object.getPrototypeOf ? (obj) => (Object.getPrototypeOf(obj)) : (obj) => (obj.__proto__);
/******/ 		var leafPrototypes;
/******/ 		// create a fake namespace object
/******/ 		// mode & 1: value is a module id, require it
/******/ 		// mode & 2: merge all properties of value into the ns
/******/ 		// mode & 4: return value when already ns object
/******/ 		// mode & 16: return value when it's Promise-like
/******/ 		// mode & 8|1: behave like require
/******/ 		__webpack_require__.t = function(value, mode) {
/******/ 			if(mode & 1) value = this(value);
/******/ 			if(mode & 8) return value;
/******/ 			if(typeof value === 'object' && value) {
/******/ 				if((mode & 4) && value.__esModule) return value;
/******/ 				if((mode & 16) && typeof value.then === 'function') return value;
/******/ 			}
/******/ 			var ns = Object.create(null);
/******/ 			__webpack_require__.r(ns);
/******/ 			var def = {};
/******/ 			leafPrototypes = leafPrototypes || [null, getProto({}), getProto([]), getProto(getProto)];
/******/ 			for(var current = mode & 2 && value; typeof current == 'object' && !~leafPrototypes.indexOf(current); current = getProto(current)) {
/******/ 				Object.getOwnPropertyNames(current).forEach((key) => (def[key] = () => (value[key])));
/******/ 			}
/******/ 			def['default'] = () => (value);
/******/ 			__webpack_require__.d(ns, def);
/******/ 			return ns;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval-source-map devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("(ssr)/./src/app/worker.js");
/******/ 	module.exports = __webpack_exports__;
/******/ 	
/******/ })()
;